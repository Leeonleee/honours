{
  "repo": "ydb-platform/ydb",
  "pull_number": 9675,
  "instance_id": "ydb-platform__ydb-9675",
  "issue_numbers": [
    "9670"
  ],
  "base_commit": "1283f9e2b92908aca1b442570f36e959cb5dfeab",
  "patch": "diff --git a/.github/config/muted_ya.txt b/.github/config/muted_ya.txt\nindex bc28a1e19ab5..cfc7c0d7ee48 100644\n--- a/.github/config/muted_ya.txt\n+++ b/.github/config/muted_ya.txt\n@@ -10,17 +10,15 @@ ydb/core/keyvalue/ut_trace TKeyValueTracingTest.*\n ydb/core/kqp/provider/ut KikimrIcGateway.TestLoadBasicSecretValueFromExternalDataSourceMetadata\n ydb/core/kqp/ut/olap KqpOlapBlobsSharing.*\n ydb/core/kqp/ut/olap KqpOlapStatistics.StatsUsageWithTTL\n-ydb/core/kqp/ut/olap KqpOlapAggregations.Aggregation_ResultCountAll_FilterL\n-ydb/core/kqp/ut/olap KqpOlapWrite.WriteDeleteCleanGC\n ydb/core/kqp/ut/pg KqpPg.CreateIndex\n+ydb/core/kqp/ut/tx KqpLocksTricky.TestNoLocksIssueInteractiveTx+withSink\n+ydb/core/kqp/ut/tx KqpLocksTricky.TestNoLocksIssue+withSink\n+ydb/core/kqp/ut/tx KqpSnapshotRead.ReadOnlyTxWithIndexCommitsOnConcurrentWrite+withSink\n+ydb/core/kqp/ut/tx KqpSinkTx.InvalidateOnError\n ydb/core/kqp/ut/query KqpLimits.QueryReplySize\n ydb/core/kqp/ut/query KqpQuery.QueryTimeout\n ydb/core/kqp/ut/scan KqpRequestContext.TraceIdInErrorMessage\n ydb/core/kqp/ut/scheme KqpOlapScheme.TenThousandColumns\n-ydb/core/kqp/ut/scheme KqpOlap.OlapRead_GenericQuerys\n-ydb/core/kqp/ut/scheme KqpOlap.OlapRead_StreamGenericQuery\n-ydb/core/kqp/ut/scheme KqpOlap.OlapRead_UsesGenericQueryOnJoinWithDataShardTable\n-ydb/core/kqp/ut/scheme KqpOlapScheme.DropTable\n ydb/core/kqp/ut/scheme KqpScheme.AlterAsyncReplication\n ydb/core/kqp/ut/scheme KqpScheme.QueryWithAlter\n ydb/core/kqp/ut/scheme [14/50]*\n@@ -31,6 +29,7 @@ ydb/core/kqp/ut/service KqpQueryService.QueryOnClosedSession\n ydb/core/kqp/ut/service KqpService.CloseSessionsWithLoad\n ydb/core/kqp/ut/service [38/50]*\n ydb/core/kqp/ut/service KqpQueryService.TableSink_OltpUpdate\n+ydb/core/kqp/ut/service KqpQueryService.TableSink_OltpReplace+HasSecondaryIndex\n ydb/core/persqueue/ut [37/40] chunk chunk\n ydb/core/persqueue/ut [38/40] chunk chunk\n ydb/core/persqueue/ut TPQTest.*DirectRead*\n@@ -106,4 +105,6 @@ ydb/tests/functional/tenants test_storage_config.py.TestStorageConfig.*\n ydb/tests/functional/tenants test_tenants.py.*\n ydb/tests/functional/ydb_cli test_ydb_impex.py.TestImpex.test_big_dataset*\n ydb/tests/tools/pq_read/test test_timeout.py.TestTimeout.test_timeout\n+ydb/core/kqp/ut/olap KqpDecimalColumnShard.TestFilterCompare\n+ydb/core/kqp/ut/olap KqpDecimalColumnShard.TestAggregation\n ydb/tests/functional/rename [test_rename.py */10] chunk chunk\ndiff --git a/ydb/core/base/events.h b/ydb/core/base/events.h\nindex 14eab5de98e9..704f503215e6 100644\n--- a/ydb/core/base/events.h\n+++ b/ydb/core/base/events.h\n@@ -179,6 +179,8 @@ struct TKikimrEvents : TEvents {\n         ES_TX_BACKGROUND = 4256, \n         ES_SS_BG_TASKS = 4257, \n         ES_LIMITER = 4258, \n+        //ES_MEMORY = 4259, NB. exists in main\n+        ES_GROUPED_ALLOCATIONS_MANAGER = 4260,\n     };\n };\n \ndiff --git a/ydb/core/driver_lib/run/kikimr_services_initializers.cpp b/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\nindex 0973b0f93a54..f1fc605581bc 100644\n--- a/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\n+++ b/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\n@@ -186,6 +186,9 @@\n #include <ydb/core/tx/limiter/usage/config.h>\n #include <ydb/core/tx/limiter/usage/service.h>\n \n+#include <ydb/core/tx/limiter/grouped_memory/usage/config.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n+\n #include <ydb/core/backup/controller/tablet.h>\n \n #include <ydb/services/ext_index/common/config.h>\n@@ -2180,6 +2183,26 @@ void TKqpServiceInitializer::InitializeServices(NActors::TActorSystemSetup* setu\n     }\n }\n \n+TGroupedMemoryLimiterInitializer::TGroupedMemoryLimiterInitializer(const TKikimrRunConfig& runConfig)\n+    : IKikimrServicesInitializer(runConfig) {\n+}\n+\n+void TGroupedMemoryLimiterInitializer::InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) {\n+    NOlap::NGroupedMemoryManager::TConfig serviceConfig;\n+    Y_ABORT_UNLESS(serviceConfig.DeserializeFromProto(Config.GetGroupedMemoryLimiterConfig()));\n+\n+    if (serviceConfig.IsEnabled()) {\n+        TIntrusivePtr<::NMonitoring::TDynamicCounters> tabletGroup = GetServiceCounters(appData->Counters, \"tablets\");\n+        TIntrusivePtr<::NMonitoring::TDynamicCounters> countersGroup = tabletGroup->GetSubgroup(\"type\", \"TX_GROUPED_MEMORY_LIMITER\");\n+\n+        auto service = NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::CreateService(serviceConfig, countersGroup);\n+\n+        setup->LocalServices.push_back(std::make_pair(\n+            NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::MakeServiceId(NodeId),\n+            TActorSetupCmd(service, TMailboxType::HTSwap, appData->UserPoolId)));\n+    }\n+}\n+\n TCompDiskLimiterInitializer::TCompDiskLimiterInitializer(const TKikimrRunConfig& runConfig)\n     : IKikimrServicesInitializer(runConfig) {\n }\ndiff --git a/ydb/core/driver_lib/run/kikimr_services_initializers.h b/ydb/core/driver_lib/run/kikimr_services_initializers.h\nindex cd2060c52aec..87d692434081 100644\n--- a/ydb/core/driver_lib/run/kikimr_services_initializers.h\n+++ b/ydb/core/driver_lib/run/kikimr_services_initializers.h\n@@ -397,6 +397,12 @@ class TCompDiskLimiterInitializer: public IKikimrServicesInitializer {\n     void InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) override;\n };\n \n+class TGroupedMemoryLimiterInitializer: public IKikimrServicesInitializer {\n+public:\n+    TGroupedMemoryLimiterInitializer(const TKikimrRunConfig& runConfig);\n+    void InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) override;\n+};\n+\n class TCompConveyorInitializer: public IKikimrServicesInitializer {\n public:\n     TCompConveyorInitializer(const TKikimrRunConfig& runConfig);\ndiff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp\nindex 5e9c23d634e5..bc70d1e83bd4 100644\n--- a/ydb/core/driver_lib/run/run.cpp\n+++ b/ydb/core/driver_lib/run/run.cpp\n@@ -1554,6 +1554,10 @@ TIntrusivePtr<TServiceInitializersList> TKikimrRunner::CreateServiceInitializers\n         sil->AddServiceInitializer(new TCompDiskLimiterInitializer(runConfig));\n     }\n \n+    if (serviceMask.EnableGroupedMemoryLimiter) {\n+        sil->AddServiceInitializer(new TGroupedMemoryLimiterInitializer(runConfig));\n+    }\n+\n     if (serviceMask.EnableScanConveyor) {\n         sil->AddServiceInitializer(new TScanConveyorInitializer(runConfig));\n     }\ndiff --git a/ydb/core/driver_lib/run/service_mask.h b/ydb/core/driver_lib/run/service_mask.h\nindex b99356bd3cff..3b694ce5ac84 100644\n--- a/ydb/core/driver_lib/run/service_mask.h\n+++ b/ydb/core/driver_lib/run/service_mask.h\n@@ -78,6 +78,7 @@ union TBasicKikimrServicesMask {\n         bool EnableDatabaseMetadataCache:1;\n         bool EnableGraphService:1;\n         bool EnableCompDiskLimiter:1;\n+        bool EnableGroupedMemoryLimiter:1;\n     };\n \n     struct {\ndiff --git a/ydb/core/driver_lib/run/ya.make b/ydb/core/driver_lib/run/ya.make\nindex 2433ec8d5b2d..2bcc7925a9db 100644\n--- a/ydb/core/driver_lib/run/ya.make\n+++ b/ydb/core/driver_lib/run/ya.make\n@@ -111,6 +111,7 @@ PEERDIR(\n     ydb/core/tx/coordinator\n     ydb/core/tx/conveyor/service\n     ydb/core/tx/limiter/service\n+    ydb/core/tx/limiter/grouped_memory/usage\n     ydb/core/tx/datashard\n     ydb/core/tx/long_tx_service\n     ydb/core/tx/long_tx_service/public\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/constructor.cpp b/ydb/core/formats/arrow/accessor/abstract/constructor.cpp\nnew file mode 100644\nindex 000000000000..51c2e86cadf7\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/constructor.cpp\n@@ -0,0 +1,11 @@\n+#include \"constructor.h\"\n+#include <ydb/core/formats/arrow/accessor/plain/constructor.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+TConstructorContainer TConstructorContainer::GetDefaultConstructor() {\n+    static std::shared_ptr<IConstructor> result = std::make_shared<NPlain::TConstructor>();\n+    return result;\n+}\n+\n+}\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/constructor.h b/ydb/core/formats/arrow/accessor/abstract/constructor.h\nnew file mode 100644\nindex 000000000000..aa99260e097a\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/constructor.h\n@@ -0,0 +1,75 @@\n+#pragma once\n+\n+#include <ydb/library/formats/arrow/protos/accessor.pb.h>\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/formats/arrow/accessor/common/chunk_data.h>\n+#include <ydb/services/bg_tasks/abstract/interface.h>\n+\n+#include <library/cpp/object_factory/object_factory.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class IConstructor {\n+public:\n+    using TFactory = NObjectFactory::TObjectFactory<IConstructor, TString>;\n+    using TProto = NKikimrArrowAccessorProto::TConstructor;\n+\n+private:\n+    virtual TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> DoConstruct(\n+        const std::shared_ptr<arrow::RecordBatch>& originalData, const TChunkConstructionData& externalInfo) const = 0;\n+    virtual TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> DoConstructDefault(\n+        const TChunkConstructionData& externalInfo) const = 0;\n+    virtual NKikimrArrowAccessorProto::TConstructor DoSerializeToProto() const = 0;\n+    virtual bool DoDeserializeFromProto(const NKikimrArrowAccessorProto::TConstructor& proto) = 0;\n+    virtual std::shared_ptr<arrow::Schema> DoGetExpectedSchema(const std::shared_ptr<arrow::Field>& resultColumn) const = 0;\n+    virtual TString DoDebugString() const {\n+        return \"\";\n+    }\n+\n+public:\n+    virtual ~IConstructor() = default;\n+\n+    TString DebugString() const {\n+        return TStringBuilder() << GetClassName() << \":\" << DoDebugString();\n+    }\n+\n+    TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> Construct(\n+        const std::shared_ptr<arrow::RecordBatch>& originalData, const TChunkConstructionData& externalInfo) const {\n+        return DoConstruct(originalData, externalInfo);\n+    }\n+\n+    TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> ConstructDefault(const TChunkConstructionData& externalInfo) const {\n+        return DoConstructDefault(externalInfo);\n+    }\n+\n+    bool DeserializeFromProto(const NKikimrArrowAccessorProto::TConstructor& proto) {\n+        return DoDeserializeFromProto(proto);\n+    }\n+\n+    NKikimrArrowAccessorProto::TConstructor SerializeToProto() const {\n+        return DoSerializeToProto();\n+    }\n+\n+    void SerializeToProto(NKikimrArrowAccessorProto::TConstructor& proto) const {\n+        proto = DoSerializeToProto();\n+    }\n+\n+    std::shared_ptr<arrow::Schema> GetExpectedSchema(const std::shared_ptr<arrow::Field>& resultColumn) const {\n+        AFL_VERIFY(resultColumn);\n+        return DoGetExpectedSchema(resultColumn);\n+    }\n+\n+    virtual TString GetClassName() const = 0;\n+};\n+\n+class TConstructorContainer: public NBackgroundTasks::TInterfaceProtoContainer<IConstructor> {\n+private:\n+    using TBase = NBackgroundTasks::TInterfaceProtoContainer<IConstructor>;\n+\n+public:\n+    using TBase::TBase;\n+\n+    static TConstructorContainer GetDefaultConstructor();\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/request.cpp b/ydb/core/formats/arrow/accessor/abstract/request.cpp\nnew file mode 100644\nindex 000000000000..08bc3ee5c87d\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/request.cpp\n@@ -0,0 +1,16 @@\n+#include \"request.h\"\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+TConclusionStatus TRequestedConstructorContainer::DeserializeFromRequest(NYql::TFeaturesExtractor& features) {\n+    const std::optional<TString> className = features.Extract(\"DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME\");\n+    if (!className) {\n+        return TConclusionStatus::Success();\n+    }\n+    if (!TBase::Initialize(*className)) {\n+        return TConclusionStatus::Fail(\"don't know anything about class_name=\" + *className);\n+    }\n+    return TBase::GetObjectPtr()->DeserializeFromRequest(features);\n+}\n+\n+}\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/request.h b/ydb/core/formats/arrow/accessor/abstract/request.h\nnew file mode 100644\nindex 000000000000..42fbf3551623\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/request.h\n@@ -0,0 +1,57 @@\n+#pragma once\n+#include \"constructor.h\"\n+\n+#include <ydb/library/formats/arrow/protos/accessor.pb.h>\n+#include <ydb/services/bg_tasks/abstract/interface.h>\n+#include <ydb/services/metadata/abstract/request_features.h>\n+\n+#include <library/cpp/object_factory/object_factory.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class IRequestedConstructor {\n+public:\n+    using TFactory = NObjectFactory::TObjectFactory<IRequestedConstructor, TString>;\n+    using TProto = NKikimrArrowAccessorProto::TRequestedConstructor;\n+private:\n+    virtual TConclusion<NArrow::NAccessor::TConstructorContainer> DoBuildConstructor() const = 0;\n+    virtual NKikimrArrowAccessorProto::TRequestedConstructor DoSerializeToProto() const = 0;\n+    virtual bool DoDeserializeFromProto(const NKikimrArrowAccessorProto::TRequestedConstructor& proto) = 0;\n+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& features) = 0;\n+\n+public:\n+    virtual ~IRequestedConstructor() = default;\n+\n+    NKikimrArrowAccessorProto::TRequestedConstructor SerializeToProto() const {\n+        return DoSerializeToProto();\n+    }\n+\n+    void SerializeToProto(NKikimrArrowAccessorProto::TRequestedConstructor& proto) const {\n+        proto = DoSerializeToProto();\n+    }\n+\n+    bool DeserializeFromProto(const NKikimrArrowAccessorProto::TRequestedConstructor& proto) {\n+        return DoDeserializeFromProto(proto);\n+    }\n+\n+    TConclusionStatus DeserializeFromRequest(NYql::TFeaturesExtractor& features) {\n+        return DoDeserializeFromRequest(features);\n+    }\n+\n+    TConclusion<TConstructorContainer> BuildConstructor() const {\n+        return DoBuildConstructor();\n+    }\n+\n+    virtual TString GetClassName() const = 0;\n+};\n+\n+class TRequestedConstructorContainer: public NBackgroundTasks::TInterfaceProtoContainer<IRequestedConstructor> {\n+private:\n+    using TBase = NBackgroundTasks::TInterfaceProtoContainer<IRequestedConstructor>;\n+\n+public:\n+    using TBase::TBase;\n+    TConclusionStatus DeserializeFromRequest(NYql::TFeaturesExtractor& features);\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/ya.make b/ydb/core/formats/arrow/accessor/abstract/ya.make\nnew file mode 100644\nindex 000000000000..c40f1f297c18\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/ya.make\n@@ -0,0 +1,17 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/conclusion\n+    ydb/services/metadata/abstract\n+    ydb/library/formats/arrow/accessor/abstract\n+    ydb/library/formats/arrow/accessor/common\n+    ydb/library/formats/arrow/protos\n+)\n+\n+SRCS(\n+    constructor.cpp\n+    request.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp b/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp\nnew file mode 100644\nindex 000000000000..d804e92efdd7\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp\n@@ -0,0 +1,46 @@\n+#include \"accessor.h\"\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+namespace {\n+class TSerializedChunkAccessor {\n+private:\n+    const std::vector<TDeserializeChunkedArray::TChunk>& Chunks;\n+    const std::shared_ptr<TColumnLoader>& Loader;\n+    std::optional<IChunkedArray::TLocalChunkedArrayAddress>& Result;\n+\n+public:\n+    TSerializedChunkAccessor(const std::vector<TDeserializeChunkedArray::TChunk>& chunks, const std::shared_ptr<TColumnLoader>& loader,\n+        std::optional<IChunkedArray::TLocalChunkedArrayAddress>& result)\n+        : Chunks(chunks)\n+        , Loader(loader)\n+        , Result(result) {\n+    }\n+    ui64 GetChunksCount() const {\n+        return Chunks.size();\n+    }\n+    ui64 GetChunkLength(const ui32 idx) const {\n+        return Chunks[idx].GetRecordsCount();\n+    }\n+    void OnArray(const ui32 chunkIdx, const ui32 startPosition) const {\n+        Result = IChunkedArray::TLocalChunkedArrayAddress(Chunks[chunkIdx].GetArrayVerified(Loader), startPosition, chunkIdx);\n+    }\n+};\n+}   // namespace\n+\n+IChunkedArray::TLocalDataAddress TDeserializeChunkedArray::DoGetLocalData(\n+    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {\n+    AFL_VERIFY(false);\n+    return IChunkedArray::TLocalDataAddress(nullptr, 0, 0);\n+}\n+\n+IChunkedArray::TLocalChunkedArrayAddress TDeserializeChunkedArray::DoGetLocalChunkedArray(\n+    const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {\n+    std::optional<IChunkedArray::TLocalChunkedArrayAddress> result;\n+    TSerializedChunkAccessor accessor(Chunks, Loader, result);\n+    SelectChunk(chunkCurrent, position, accessor);\n+    AFL_VERIFY(result);\n+    return *result;\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/composite_serial/accessor.h b/ydb/core/formats/arrow/accessor/composite_serial/accessor.h\nnew file mode 100644\nindex 000000000000..ac7e0193d7bd\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/composite_serial/accessor.h\n@@ -0,0 +1,78 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/save_load/loader.h>\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TDeserializeChunkedArray: public NArrow::NAccessor::IChunkedArray {\n+private:\n+    using TBase = NArrow::NAccessor::IChunkedArray;\n+\n+public:\n+    class TChunk {\n+    private:\n+        YDB_READONLY(ui32, RecordsCount, 0);\n+        std::shared_ptr<IChunkedArray> PredefinedArray;\n+        const TString Data;\n+\n+    public:\n+        TChunk(const std::shared_ptr<IChunkedArray>& predefinedArray)\n+            : PredefinedArray(predefinedArray) {\n+            AFL_VERIFY(PredefinedArray);\n+            RecordsCount = PredefinedArray->GetRecordsCount();\n+        }\n+\n+        TChunk(const ui32 recordsCount, const TString& data)\n+            : RecordsCount(recordsCount)\n+            , Data(data) {\n+        }\n+\n+        std::shared_ptr<IChunkedArray> GetArrayVerified(const std::shared_ptr<TColumnLoader>& loader) const {\n+            if (PredefinedArray) {\n+                return PredefinedArray;\n+            }\n+            return loader->ApplyVerified(Data, RecordsCount);\n+        }\n+    };\n+\n+private:\n+    std::shared_ptr<TColumnLoader> Loader;\n+    std::vector<TChunk> Chunks;\n+\n+protected:\n+    virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(\n+        const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n+\n+    virtual std::vector<TChunkedArraySerialized> DoSplitBySizes(\n+        const TColumnSaver& /*saver*/, const TString& /*fullSerializedData*/, const std::vector<ui64>& /*splitSizes*/) override {\n+        AFL_VERIFY(false);\n+        return {};\n+    }\n+\n+    virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 /*index*/) const override {\n+        AFL_VERIFY(false)(\"problem\", \"cannot use method\");\n+        return nullptr;\n+    }\n+    virtual std::optional<ui64> DoGetRawSize() const override {\n+        return {};\n+    }\n+    virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override {\n+        AFL_VERIFY(false);\n+        return nullptr;\n+    }\n+    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n+        AFL_VERIFY(false);\n+        return nullptr;\n+    }\n+\n+public:\n+    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, std::vector<TChunk>&& chunks)\n+        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())\n+        , Loader(loader)\n+        , Chunks(std::move(chunks)) {\n+        AFL_VERIFY(Loader);\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/composite_serial/ya.make b/ydb/core/formats/arrow/accessor/composite_serial/ya.make\nnew file mode 100644\nindex 000000000000..e8095e990285\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/composite_serial/ya.make\n@@ -0,0 +1,14 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/formats/arrow/accessor/abstract\n+    ydb/core/formats/arrow/common\n+    ydb/core/formats/arrow/save_load\n+)\n+\n+SRCS(\n+    accessor.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/accessor/plain/accessor.cpp b/ydb/core/formats/arrow/accessor/plain/accessor.cpp\nnew file mode 100644\nindex 000000000000..c606f2e1952b\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/accessor.cpp\n@@ -0,0 +1,89 @@\n+#include \"accessor.h\"\n+\n+#include <ydb/core/formats/arrow/arrow_helpers.h>\n+#include <ydb/core/formats/arrow/size_calcer.h>\n+#include <ydb/core/formats/arrow/splitter/simple.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+std::optional<ui64> TTrivialArray::DoGetRawSize() const {\n+    return NArrow::GetArrayDataSize(Array);\n+}\n+\n+std::vector<NKikimr::NArrow::NAccessor::TChunkedArraySerialized> TTrivialArray::DoSplitBySizes(\n+    const TColumnSaver& saver, const TString& fullSerializedData, const std::vector<ui64>& splitSizes) {\n+    auto schema = std::make_shared<arrow::Schema>(arrow::FieldVector({ std::make_shared<arrow::Field>(\"f\", GetDataType()) }));\n+    auto chunks = NArrow::NSplitter::TSimpleSplitter(saver).SplitBySizes(\n+        arrow::RecordBatch::Make(schema, GetRecordsCount(), { Array }), fullSerializedData, splitSizes);\n+    std::vector<TChunkedArraySerialized> result;\n+    for (auto&& i : chunks) {\n+        AFL_VERIFY(i.GetSlicedBatch()->num_columns() == 1);\n+        result.emplace_back(std::make_shared<TTrivialArray>(i.GetSlicedBatch()->column(0)), i.GetSerializedChunk());\n+    }\n+    return result;\n+}\n+\n+std::shared_ptr<arrow::Scalar> TTrivialArray::DoGetMaxScalar() const {\n+    auto minMaxPos = NArrow::FindMinMaxPosition(Array);\n+    return NArrow::TStatusValidator::GetValid(Array->GetScalar(minMaxPos.second));\n+}\n+\n+namespace {\n+class TChunkAccessor {\n+private:\n+    std::shared_ptr<arrow::ChunkedArray> ChunkedArray;\n+    std::optional<IChunkedArray::TLocalDataAddress>* Result;\n+\n+public:\n+    TChunkAccessor(const std::shared_ptr<arrow::ChunkedArray>& chunkedArray, std::optional<IChunkedArray::TLocalDataAddress>& result)\n+        : ChunkedArray(chunkedArray)\n+        , Result(&result) {\n+    }\n+    ui64 GetChunksCount() const {\n+        return (ui64)ChunkedArray->num_chunks();\n+    }\n+    ui64 GetChunkLength(const ui32 idx) const {\n+        return (ui64)ChunkedArray->chunk(idx)->length();\n+    }\n+    void OnArray(const ui32 idx, const ui32 startPosition) const {\n+        const auto& arr = ChunkedArray->chunk(idx);\n+        *Result = IChunkedArray::TLocalDataAddress(arr, startPosition, idx);\n+    }\n+};\n+\n+}   // namespace\n+\n+IChunkedArray::TLocalDataAddress TTrivialChunkedArray::DoGetLocalData(\n+    const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {\n+    std::optional<IChunkedArray::TLocalDataAddress> result;\n+    TChunkAccessor accessor(Array, result);\n+    SelectChunk(chunkCurrent, position, accessor);\n+    AFL_VERIFY(result);\n+    return *result;\n+}\n+\n+std::optional<ui64> TTrivialChunkedArray::DoGetRawSize() const {\n+    ui64 result = 0;\n+    for (auto&& i : Array->chunks()) {\n+        result += NArrow::GetArrayDataSize(i);\n+    }\n+    return result;\n+}\n+\n+std::shared_ptr<arrow::Scalar> TTrivialChunkedArray::DoGetMaxScalar() const {\n+    std::shared_ptr<arrow::Scalar> result;\n+    for (auto&& i : Array->chunks()) {\n+        if (!i->length()) {\n+            continue;\n+        }\n+        auto minMaxPos = NArrow::FindMinMaxPosition(i);\n+        auto scalarCurrent = NArrow::TStatusValidator::GetValid(i->GetScalar(minMaxPos.second));\n+        if (!result || ScalarCompare(result, scalarCurrent) < 0) {\n+            result = scalarCurrent;\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/plain/accessor.h b/ydb/core/formats/arrow/accessor/plain/accessor.h\nnew file mode 100644\nindex 000000000000..a00826161c40\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/accessor.h\n@@ -0,0 +1,77 @@\n+#pragma once\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/formats/arrow/validation/validation.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TTrivialArray: public IChunkedArray {\n+private:\n+    using TBase = IChunkedArray;\n+    const std::shared_ptr<arrow::Array> Array;\n+\n+protected:\n+    virtual std::optional<ui64> DoGetRawSize() const override;\n+\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {\n+        return TLocalDataAddress(Array, 0, 0);\n+    }\n+    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n+        return std::make_shared<arrow::ChunkedArray>(Array);\n+    }\n+    virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 index) const override {\n+        return NArrow::TStatusValidator::GetValid(Array->GetScalar(index));\n+    }\n+    virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override;\n+    virtual std::vector<TChunkedArraySerialized> DoSplitBySizes(\n+        const TColumnSaver& saver, const TString& fullSerializedData, const std::vector<ui64>& splitSizes) override;\n+\n+    virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(\n+        const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {\n+        AFL_VERIFY(false);\n+        return TLocalChunkedArrayAddress(nullptr, TCommonChunkAddress(0, GetRecordsCount(), 0));\n+    }\n+\n+public:\n+    TTrivialArray(const std::shared_ptr<arrow::Array>& data)\n+        : TBase(data->length(), EType::Array, data->type())\n+        , Array(data) {\n+    }\n+};\n+\n+class TTrivialChunkedArray: public IChunkedArray {\n+private:\n+    using TBase = IChunkedArray;\n+    const std::shared_ptr<arrow::ChunkedArray> Array;\n+\n+protected:\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n+    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n+        return Array;\n+    }\n+    virtual std::optional<ui64> DoGetRawSize() const override;\n+    virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 index) const override {\n+        auto chunk = GetChunkSlow(index);\n+        return NArrow::TStatusValidator::GetValid(chunk.GetArray()->GetScalar(chunk.GetAddress().GetLocalIndex(index)));\n+    }\n+    virtual std::vector<TChunkedArraySerialized> DoSplitBySizes(\n+        const TColumnSaver& /*saver*/, const TString& /*fullSerializedData*/, const std::vector<ui64>& /*splitSizes*/) override {\n+        AFL_VERIFY(false);\n+        return {};\n+    }\n+\n+    virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override;\n+\n+    virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(\n+        const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {\n+        AFL_VERIFY(false);\n+        return TLocalChunkedArrayAddress(nullptr, TCommonChunkAddress(0, 0, 0));\n+    }\n+\n+public:\n+    TTrivialChunkedArray(const std::shared_ptr<arrow::ChunkedArray>& data)\n+        : TBase(data->length(), EType::ChunkedArray, data->type())\n+        , Array(data) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/plain/constructor.cpp b/ydb/core/formats/arrow/accessor/plain/constructor.cpp\nnew file mode 100644\nindex 000000000000..3ecf41502b33\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/constructor.cpp\n@@ -0,0 +1,33 @@\n+#include \"accessor.h\"\n+#include \"constructor.h\"\n+\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NPlain {\n+\n+TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(\n+    const std::shared_ptr<arrow::RecordBatch>& originalData, const TChunkConstructionData& /*externalInfo*/) const {\n+    AFL_VERIFY(originalData->num_columns() == 1)(\"count\", originalData->num_columns())(\"schema\", originalData->schema()->ToString());\n+    return std::make_shared<NArrow::NAccessor::TTrivialArray>(originalData->column(0));\n+}\n+\n+TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstructDefault(const TChunkConstructionData& externalInfo) const {\n+    return std::make_shared<NArrow::NAccessor::TTrivialArray>(\n+        NArrow::TThreadSimpleArraysCache::Get(externalInfo.GetColumnType(), externalInfo.GetDefaultValue(), externalInfo.GetRecordsCount()));\n+}\n+\n+NKikimrArrowAccessorProto::TConstructor TConstructor::DoSerializeToProto() const {\n+    return NKikimrArrowAccessorProto::TConstructor();\n+}\n+\n+bool TConstructor::DoDeserializeFromProto(const NKikimrArrowAccessorProto::TConstructor& /*proto*/) {\n+    return true;\n+}\n+\n+std::shared_ptr<arrow::Schema> TConstructor::DoGetExpectedSchema(const std::shared_ptr<arrow::Field>& resultColumn) const {\n+    return std::make_shared<arrow::Schema>(arrow::FieldVector({ resultColumn }));\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NPlain\ndiff --git a/ydb/core/formats/arrow/accessor/plain/constructor.h b/ydb/core/formats/arrow/accessor/plain/constructor.h\nnew file mode 100644\nindex 000000000000..57c366689eb0\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/constructor.h\n@@ -0,0 +1,28 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NPlain {\n+\n+class TConstructor: public IConstructor {\n+public:\n+    static TString GetClassNameStatic() {\n+        return TGlobalConst::PlainDataAccessorName;\n+    }\n+\n+private:\n+    static inline auto Registrator = TFactory::TRegistrator<TConstructor>(GetClassNameStatic());\n+    virtual TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> DoConstruct(\n+        const std::shared_ptr<arrow::RecordBatch>& originalData, const TChunkConstructionData& externalInfo) const override;\n+    virtual NKikimrArrowAccessorProto::TConstructor DoSerializeToProto() const override;\n+    virtual bool DoDeserializeFromProto(const NKikimrArrowAccessorProto::TConstructor& proto) override;\n+    virtual std::shared_ptr<arrow::Schema> DoGetExpectedSchema(const std::shared_ptr<arrow::Field>& resultColumn) const override;\n+    virtual TConclusion<std::shared_ptr<IChunkedArray>> DoConstructDefault(const TChunkConstructionData& externalInfo) const override;\n+\n+public:\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NPlain\ndiff --git a/ydb/core/formats/arrow/accessor/plain/request.cpp b/ydb/core/formats/arrow/accessor/plain/request.cpp\nnew file mode 100644\nindex 000000000000..05a6ab128165\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/request.cpp\n@@ -0,0 +1,22 @@\n+#include \"request.h\"\n+#include \"constructor.h\"\n+\n+namespace NKikimr::NArrow::NAccessor::NPlain {\n+\n+NKikimrArrowAccessorProto::TRequestedConstructor TRequestedConstuctor::DoSerializeToProto() const {\n+    return NKikimrArrowAccessorProto::TRequestedConstructor();\n+}\n+\n+bool TRequestedConstuctor::DoDeserializeFromProto(const NKikimrArrowAccessorProto::TRequestedConstructor& /*proto*/) {\n+    return true;\n+}\n+\n+NKikimr::TConclusionStatus TRequestedConstuctor::DoDeserializeFromRequest(NYql::TFeaturesExtractor& /*features*/) {\n+    return TConclusionStatus::Success();\n+}\n+\n+NKikimr::TConclusion<NKikimr::NArrow::NAccessor::TConstructorContainer> TRequestedConstuctor::DoBuildConstructor() const {\n+    return std::make_shared<TConstructor>();\n+}\n+\n+}\ndiff --git a/ydb/core/formats/arrow/accessor/plain/request.h b/ydb/core/formats/arrow/accessor/plain/request.h\nnew file mode 100644\nindex 000000000000..19a8390f2df2\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/request.h\n@@ -0,0 +1,26 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/accessor/abstract/request.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NPlain {\n+\n+class TRequestedConstuctor: public IRequestedConstructor {\n+public:\n+    static TString GetClassNameStatic() {\n+        return TGlobalConst::PlainDataAccessorName;\n+    }\n+\n+private:\n+    static inline auto Registrator = TFactory::TRegistrator<TRequestedConstuctor>(GetClassNameStatic());\n+    virtual TConclusion<TConstructorContainer> DoBuildConstructor() const override;\n+    virtual NKikimrArrowAccessorProto::TRequestedConstructor DoSerializeToProto() const override;\n+    virtual bool DoDeserializeFromProto(const NKikimrArrowAccessorProto::TRequestedConstructor& /*proto*/) override;\n+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& /*features*/) override;\n+\n+public:\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NPlain\ndiff --git a/ydb/core/formats/arrow/accessor/plain/ya.make b/ydb/core/formats/arrow/accessor/plain/ya.make\nnew file mode 100644\nindex 000000000000..5b3dd0bf6081\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/plain/ya.make\n@@ -0,0 +1,15 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    ydb/core/formats/arrow/accessor/abstract\n+    ydb/library/formats/arrow\n+    ydb/library/formats/arrow/protos\n+)\n+\n+SRCS(\n+    accessor.cpp\n+    GLOBAL constructor.cpp\n+    GLOBAL request.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp b/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp\nnew file mode 100644\nindex 000000000000..62c796b811d1\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp\n@@ -0,0 +1,280 @@\n+#include \"accessor.h\"\n+\n+#include <ydb/core/formats/arrow/size_calcer.h>\n+#include <ydb/core/formats/arrow/splitter/simple.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+TSparsedArray::TSparsedArray(const IChunkedArray& defaultArray, const std::shared_ptr<arrow::Scalar>& defaultValue)\n+    : TBase(defaultArray.GetRecordsCount(), EType::SparsedArray, defaultArray.GetDataType())\n+    , DefaultValue(defaultValue) {\n+    if (DefaultValue) {\n+        AFL_VERIFY(DefaultValue->type->id() == defaultArray.GetDataType()->id());\n+    }\n+    std::optional<TFullDataAddress> current;\n+    std::shared_ptr<arrow::RecordBatch> records;\n+    ui32 sparsedRecordsCount = 0;\n+    AFL_VERIFY(SwitchType(GetDataType()->id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TScalar = typename arrow::TypeTraits<typename TWrap::T>::ScalarType;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+        using TBuilder = typename arrow::TypeTraits<typename TWrap::T>::BuilderType;\n+        auto builderValue = NArrow::MakeBuilder(GetDataType());\n+        TBuilder* builderValueImpl = (TBuilder*)builderValue.get();\n+        auto builderIndex = NArrow::MakeBuilder(arrow::uint32());\n+        arrow::UInt32Builder* builderIndexImpl = (arrow::UInt32Builder*)builderIndex.get();\n+        auto scalar = static_pointer_cast<TScalar>(DefaultValue);\n+        for (ui32 pos = 0; pos < GetRecordsCount();) {\n+            current = defaultArray.GetChunk(current, pos);\n+            auto typedArray = static_pointer_cast<TArray>(current->GetArray());\n+            for (ui32 i = 0; i < typedArray->length(); ++i) {\n+                std::optional<bool> isDefault;\n+                if (scalar) {\n+                    if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+                        isDefault = arrow::util::string_view((char*)scalar->value->data(), scalar->value->size()) == typedArray->GetView(i);\n+                    } else if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n+                        isDefault = scalar->value == typedArray->Value(i);\n+                    } else {\n+                        AFL_VERIFY(false)(\"type\", GetDataType()->ToString());\n+                    }\n+                } else {\n+                    isDefault = typedArray->IsNull(i);\n+                }\n+                if (!*isDefault) {\n+                    if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+                        NArrow::TStatusValidator::Validate(builderValueImpl->Append(typedArray->GetView(i)));\n+                        NArrow::TStatusValidator::Validate(builderIndexImpl->Append(pos + i));\n+                        ++sparsedRecordsCount;\n+                    } else if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n+                        NArrow::TStatusValidator::Validate(builderValueImpl->Append(typedArray->Value(i)));\n+                        NArrow::TStatusValidator::Validate(builderIndexImpl->Append(pos + i));\n+                        ++sparsedRecordsCount;\n+                    } else {\n+                        AFL_VERIFY(false)(\"type\", GetDataType()->ToString());\n+                    }\n+                }\n+            }\n+            pos = current->GetAddress().GetGlobalFinishPosition();\n+            AFL_VERIFY(pos <= GetRecordsCount());\n+        }\n+        std::vector<std::shared_ptr<arrow::Array>> columns = { NArrow::TStatusValidator::GetValid(builderIndex->Finish()),\n+            NArrow::TStatusValidator::GetValid(builderValue->Finish()) };\n+        records = arrow::RecordBatch::Make(BuildSchema(GetDataType()), sparsedRecordsCount, columns);\n+        AFL_VERIFY_DEBUG(records->ValidateFull().ok());\n+        return true;\n+    }));\n+    AFL_VERIFY(records);\n+    Records.emplace_back(0, GetRecordsCount(), records, DefaultValue);\n+}\n+\n+std::vector<NKikimr::NArrow::NAccessor::TChunkedArraySerialized> TSparsedArray::DoSplitBySizes(\n+    const TColumnSaver& saver, const TString& fullSerializedData, const std::vector<ui64>& splitSizes) {\n+    AFL_VERIFY(Records.size() == 1)(\"size\", Records.size());\n+    auto chunks = NArrow::NSplitter::TSimpleSplitter(saver).SplitBySizes(Records.front().GetRecords(), fullSerializedData, splitSizes);\n+\n+    std::vector<TChunkedArraySerialized> result;\n+    ui32 idx = 0;\n+    ui32 startIdx = 0;\n+    for (auto&& i : chunks) {\n+        AFL_VERIFY(i.GetSlicedBatch()->num_columns() == 2);\n+        AFL_VERIFY(i.GetSlicedBatch()->column(0)->type()->id() == arrow::uint32()->id());\n+        auto UI32Column = static_pointer_cast<arrow::UInt32Array>(i.GetSlicedBatch()->column(0));\n+        ui32 nextStartIdx = NArrow::NAccessor::TSparsedArray::GetLastIndex(i.GetSlicedBatch()) + 1;\n+        if (idx + 1 == chunks.size()) {\n+            nextStartIdx = GetRecordsCount();\n+        }\n+        std::shared_ptr<arrow::RecordBatch> batch;\n+        {\n+            std::unique_ptr<arrow::ArrayBuilder> builder = NArrow::MakeBuilder(arrow::uint32());\n+            arrow::UInt32Builder* builderImpl = (arrow::UInt32Builder*)builder.get();\n+            for (ui32 rowIdx = 0; rowIdx < UI32Column->length(); ++rowIdx) {\n+                TStatusValidator::Validate(builderImpl->Append(UI32Column->Value(rowIdx) - startIdx));\n+            }\n+            auto colIndex = TStatusValidator::GetValid(builder->Finish());\n+            batch = arrow::RecordBatch::Make(\n+                i.GetSlicedBatch()->schema(), i.GetSlicedBatch()->num_rows(), { colIndex, i.GetSlicedBatch()->column(1) });\n+        }\n+\n+        ++idx;\n+        {\n+            TBuilder builder(DefaultValue, GetDataType());\n+            builder.AddChunk(nextStartIdx - startIdx, batch);\n+            result.emplace_back(builder.Finish(), saver.Apply(batch));\n+        }\n+        startIdx = nextStartIdx;\n+    }\n+\n+    return result;\n+}\n+\n+std::shared_ptr<arrow::Scalar> TSparsedArray::DoGetMaxScalar() const {\n+    std::shared_ptr<arrow::Scalar> result;\n+    for (auto&& i : Records) {\n+        auto scalarCurrent = i.GetMaxScalar();\n+        if (!scalarCurrent) {\n+            continue;\n+        }\n+        if (!result || ScalarCompare(result, scalarCurrent) < 0) {\n+            result = scalarCurrent;\n+        }\n+    }\n+    return result;\n+}\n+\n+ui32 TSparsedArray::GetLastIndex(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    AFL_VERIFY(batch);\n+    AFL_VERIFY(batch->num_rows());\n+    auto c = batch->GetColumnByName(\"index\");\n+    AFL_VERIFY(c)(\"schema\", batch->schema()->ToString());\n+    AFL_VERIFY(c->type_id() == arrow::uint32()->id())(\"type\", c->type()->ToString());\n+    auto ui32Column = static_pointer_cast<arrow::UInt32Array>(c);\n+    return ui32Column->Value(ui32Column->length() - 1);\n+}\n+\n+namespace {\n+static thread_local THashMap<TString, std::shared_ptr<arrow::RecordBatch>> SimpleBatchesCache;\n+}\n+\n+NKikimr::NArrow::NAccessor::TSparsedArrayChunk TSparsedArray::MakeDefaultChunk(\n+    const std::shared_ptr<arrow::Scalar>& defaultValue, const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount) {\n+    auto it = SimpleBatchesCache.find(type->ToString());\n+    if (it == SimpleBatchesCache.end()) {\n+        it = SimpleBatchesCache.emplace(type->ToString(), NArrow::MakeEmptyBatch(BuildSchema(type))).first;\n+        AFL_VERIFY(it->second->ValidateFull().ok());\n+    }\n+    return TSparsedArrayChunk(0, recordsCount, it->second, defaultValue);\n+}\n+\n+IChunkedArray::TLocalDataAddress TSparsedArrayChunk::GetChunk(\n+    const std::optional<IChunkedArray::TCommonChunkAddress>& /*chunkCurrent*/, const ui64 position, const ui32 chunkIdx) const {\n+    const auto predCompare = [](const ui32 position, const TInternalChunkInfo& item) {\n+        return position < item.GetStartExt();\n+    };\n+    auto it = std::upper_bound(RemapExternalToInternal.begin(), RemapExternalToInternal.end(), position, predCompare);\n+    AFL_VERIFY(it != RemapExternalToInternal.begin());\n+    --it;\n+    if (it->GetIsDefault()) {\n+        return IChunkedArray::TLocalDataAddress(\n+            NArrow::TThreadSimpleArraysCache::Get(ColValue->type(), DefaultValue, it->GetSize()), StartPosition + it->GetStartExt(), chunkIdx);\n+    } else {\n+        return IChunkedArray::TLocalDataAddress(\n+            ColValue->Slice(it->GetStartInt(), it->GetSize()), StartPosition + it->GetStartExt(), chunkIdx);\n+    }\n+}\n+\n+std::vector<std::shared_ptr<arrow::Array>> TSparsedArrayChunk::GetChunkedArray() const {\n+    std::vector<std::shared_ptr<arrow::Array>> chunks;\n+    for (auto&& i : RemapExternalToInternal) {\n+        if (i.GetIsDefault()) {\n+            chunks.emplace_back(NArrow::TThreadSimpleArraysCache::Get(ColValue->type(), DefaultValue, i.GetSize()));\n+        } else {\n+            chunks.emplace_back(ColValue->Slice(i.GetStartInt(), i.GetSize()));\n+        }\n+    }\n+    return chunks;\n+}\n+\n+TSparsedArrayChunk::TSparsedArrayChunk(const ui32 posStart, const ui32 recordsCount, const std::shared_ptr<arrow::RecordBatch>& records,\n+    const std::shared_ptr<arrow::Scalar>& defaultValue)\n+    : RecordsCount(recordsCount)\n+    , StartPosition(posStart)\n+    , Records(records)\n+    , DefaultValue(defaultValue) {\n+    AFL_VERIFY(records->num_columns() == 2);\n+    ColIndex = Records->GetColumnByName(\"index\");\n+    AFL_VERIFY(ColIndex);\n+    AFL_VERIFY(ColIndex->type_id() == arrow::uint32()->id());\n+    UI32ColIndex = static_pointer_cast<arrow::UInt32Array>(ColIndex);\n+    if (UI32ColIndex->length()) {\n+        AFL_VERIFY(UI32ColIndex->Value(UI32ColIndex->length() - 1) < recordsCount)(\"val\", UI32ColIndex->Value(UI32ColIndex->length() - 1))(\n+            \"count\", recordsCount);\n+    }\n+    NotDefaultRecordsCount = UI32ColIndex->length();\n+    RawValues = UI32ColIndex->raw_values();\n+    ColValue = Records->GetColumnByName(\"value\");\n+    if (DefaultValue) {\n+        AFL_VERIFY(DefaultValue->type->id() == ColValue->type_id());\n+    }\n+    ui32 nextIndex = 0;\n+    ui32 startIndexExt = 0;\n+    ui32 startIndexInt = 0;\n+    for (ui32 idx = 0; idx < UI32ColIndex->length(); ++idx) {\n+        if (nextIndex != UI32ColIndex->Value(idx)) {\n+            if (idx - startIndexInt) {\n+                RemapExternalToInternal.emplace_back(startIndexExt, startIndexInt, idx - startIndexInt, false);\n+            }\n+            RemapExternalToInternal.emplace_back(nextIndex, 0, UI32ColIndex->Value(idx) - nextIndex, true);\n+            startIndexExt = UI32ColIndex->Value(idx);\n+            startIndexInt = idx;\n+        }\n+        nextIndex = UI32ColIndex->Value(idx) + 1;\n+    }\n+    if (UI32ColIndex->length() > startIndexInt) {\n+        RemapExternalToInternal.emplace_back(startIndexExt, startIndexInt, UI32ColIndex->length() - startIndexInt, false);\n+    }\n+    if (nextIndex != RecordsCount) {\n+        RemapExternalToInternal.emplace_back(nextIndex, 0, RecordsCount - nextIndex, true);\n+    }\n+    ui32 count = 0;\n+    for (auto&& i : RemapExternalToInternal) {\n+        count += i.GetSize();\n+    }\n+    for (ui32 i = 0; i + 1 < RemapExternalToInternal.size(); ++i) {\n+        AFL_VERIFY(RemapExternalToInternal[i + 1].GetStartExt() == RemapExternalToInternal[i].GetStartExt() + RemapExternalToInternal[i].GetSize());\n+    }\n+    AFL_VERIFY(count == RecordsCount)(\"count\", count)(\"records_count\", RecordsCount);\n+    AFL_VERIFY(ColValue);\n+}\n+\n+ui64 TSparsedArrayChunk::GetRawSize() const {\n+    return std::max<ui64>(NArrow::GetBatchDataSize(Records), 8);\n+}\n+\n+std::shared_ptr<arrow::Scalar> TSparsedArrayChunk::GetScalar(const ui32 index) const {\n+    AFL_VERIFY(index < RecordsCount);\n+    for (ui32 idx = 0; idx < UI32ColIndex->length(); ++idx) {\n+        if (UI32ColIndex->Value(idx) == index) {\n+            return NArrow::TStatusValidator::GetValid(ColValue->GetScalar(idx));\n+        }\n+    }\n+    return DefaultValue;\n+}\n+\n+ui32 TSparsedArrayChunk::GetFirstIndexNotDefault() const {\n+    if (UI32ColIndex->length()) {\n+        return StartPosition + GetUI32ColIndex()->Value(0);\n+    } else {\n+        return StartPosition + GetRecordsCount();\n+    }\n+}\n+\n+std::shared_ptr<arrow::Scalar> TSparsedArrayChunk::GetMaxScalar() const {\n+    if (!ColValue->length()) {\n+        return DefaultValue;\n+    }\n+    auto minMax = NArrow::FindMinMaxPosition(ColValue);\n+    auto currentScalar = NArrow::TStatusValidator::GetValid(ColValue->GetScalar(minMax.second));\n+    if (!DefaultValue || ScalarCompare(DefaultValue, currentScalar) < 0) {\n+        return currentScalar;\n+    }\n+    return DefaultValue;\n+}\n+\n+void TSparsedArray::TBuilder::AddChunk(const ui32 recordsCount, const std::shared_ptr<arrow::RecordBatch>& data) {\n+    AFL_VERIFY(data);\n+    AFL_VERIFY(recordsCount);\n+    AFL_VERIFY(data->num_rows() <= recordsCount)(\"rows\", data->num_rows())(\"count\", recordsCount);\n+    AFL_VERIFY(data->num_columns() == 2)(\"count\", data->num_columns());\n+    AFL_VERIFY(data->column(0)->type_id() == arrow::uint32()->id())(\"type\", data->column(0)->type()->ToString());\n+    AFL_VERIFY_DEBUG(data->schema()->field(0)->name() == \"index\")(\"name\", data->schema()->field(0)->name());\n+    if (data->num_rows()) {\n+        auto* arr = static_cast<const arrow::UInt32Array*>(data->column(0).get());\n+        AFL_VERIFY(arr->Value(arr->length() - 1) < recordsCount)(\"val\", arr->Value(arr->length() - 1))(\"count\", recordsCount);\n+    }\n+    Chunks.emplace_back(RecordsCount, recordsCount, data, DefaultValue);\n+    RecordsCount += recordsCount;\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/accessor.h b/ydb/core/formats/arrow/accessor/sparsed/accessor.h\nnew file mode 100644\nindex 000000000000..040224962239\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/accessor.h\n@@ -0,0 +1,189 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/arrow_helpers.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type_fwd.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TSparsedArrayChunk: public TMoveOnly {\n+private:\n+    YDB_READONLY(ui32, RecordsCount, 0);\n+    YDB_READONLY(ui32, StartPosition, 0);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, Records);\n+    std::shared_ptr<arrow::Scalar> DefaultValue;\n+\n+    std::shared_ptr<arrow::Array> ColIndex;\n+    const ui32* RawValues = nullptr;\n+    ui32 NotDefaultRecordsCount = 0;\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::UInt32Array>, UI32ColIndex);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, ColValue);\n+\n+    class TInternalChunkInfo {\n+    private:\n+        YDB_READONLY(ui32, StartExt, 0);\n+        YDB_READONLY(ui32, StartInt, 0);\n+        YDB_READONLY(ui32, Size, 0);\n+        YDB_READONLY(bool, IsDefault, false);\n+\n+    public:\n+        TInternalChunkInfo(const ui32 startExt, const ui32 startInt, const ui32 size, const bool defaultFlag)\n+            : StartExt(startExt)\n+            , StartInt(startInt)\n+            , Size(size)\n+            , IsDefault(defaultFlag) {\n+            AFL_VERIFY(Size);\n+        }\n+\n+        bool operator<(const TInternalChunkInfo& item) const {\n+            return StartExt < item.StartExt;\n+        }\n+    };\n+\n+    std::vector<TInternalChunkInfo> RemapExternalToInternal;\n+\n+public:\n+    ui32 GetFinishPosition() const {\n+        return StartPosition + RecordsCount;\n+    }\n+\n+    ui32 GetNotDefaultRecordsCount() const {\n+        return NotDefaultRecordsCount;\n+    }\n+\n+    ui32 GetIndexUnsafeFast(const ui32 i) const {\n+        return RawValues[i];\n+    }\n+\n+    ui32 GetFirstIndexNotDefault() const;\n+\n+    std::shared_ptr<arrow::Scalar> GetMaxScalar() const;\n+\n+    std::shared_ptr<arrow::Scalar> GetScalar(const ui32 index) const;\n+\n+    IChunkedArray::TLocalDataAddress GetChunk(\n+        const std::optional<IChunkedArray::TCommonChunkAddress>& chunkCurrent, const ui64 position, const ui32 chunkIdx) const;\n+\n+    std::vector<std::shared_ptr<arrow::Array>> GetChunkedArray() const;\n+\n+    TSparsedArrayChunk(const ui32 posStart, const ui32 recordsCount, const std::shared_ptr<arrow::RecordBatch>& records,\n+        const std::shared_ptr<arrow::Scalar>& defaultValue);\n+\n+    ui64 GetRawSize() const;\n+};\n+\n+class TSparsedArray: public IChunkedArray {\n+private:\n+    using TBase = IChunkedArray;\n+    std::shared_ptr<arrow::Scalar> DefaultValue;\n+    std::vector<TSparsedArrayChunk> Records;\n+\n+protected:\n+    virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(\n+        const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {\n+        AFL_VERIFY(false);\n+        return TLocalChunkedArrayAddress(nullptr, 0, 0);\n+    }\n+\n+    virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override;\n+\n+    virtual std::vector<TChunkedArraySerialized> DoSplitBySizes(\n+        const TColumnSaver& saver, const TString& fullSerializedData, const std::vector<ui64>& splitSizes) override;\n+\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override {\n+        ui32 currentIdx = 0;\n+        for (ui32 i = 0; i < Records.size(); ++i) {\n+            if (currentIdx <= position && position < currentIdx + Records[i].GetRecordsCount()) {\n+                return Records[i].GetChunk(chunkCurrent, position - currentIdx, i);\n+            }\n+            currentIdx += Records[i].GetRecordsCount();\n+        }\n+        AFL_VERIFY(false);\n+        return TLocalDataAddress(nullptr, 0, 0);\n+    }\n+    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n+        std::vector<std::shared_ptr<arrow::Array>> chunks;\n+        for (auto&& i : Records) {\n+            auto chunksLocal = i.GetChunkedArray();\n+            chunks.insert(chunks.end(), chunksLocal.begin(), chunksLocal.end());\n+        }\n+        return std::make_shared<arrow::ChunkedArray>(chunks, GetDataType());\n+    }\n+    virtual std::optional<ui64> DoGetRawSize() const override {\n+        ui64 bytes = 0;\n+        for (auto&& i : Records) {\n+            bytes += i.GetRawSize();\n+        }\n+        return bytes;\n+    }\n+\n+    TSparsedArray(std::vector<TSparsedArrayChunk>&& data, const std::shared_ptr<arrow::Scalar>& defaultValue,\n+        const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount)\n+        : TBase(recordsCount, EType::SparsedArray, type)\n+        , DefaultValue(defaultValue)\n+        , Records(std::move(data)) {\n+    }\n+\n+    static ui32 GetLastIndex(const std::shared_ptr<arrow::RecordBatch>& batch);\n+\n+    static std::shared_ptr<arrow::Schema> BuildSchema(const std::shared_ptr<arrow::DataType>& type) {\n+        std::vector<std::shared_ptr<arrow::Field>> fields = { std::make_shared<arrow::Field>(\"index\", arrow::uint32()),\n+            std::make_shared<arrow::Field>(\"value\", type) };\n+        return std::make_shared<arrow::Schema>(fields);\n+    }\n+\n+    static TSparsedArrayChunk MakeDefaultChunk(\n+        const std::shared_ptr<arrow::Scalar>& defaultValue, const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);\n+\n+public:\n+    TSparsedArray(const IChunkedArray& defaultArray, const std::shared_ptr<arrow::Scalar>& defaultValue);\n+\n+    TSparsedArray(const std::shared_ptr<arrow::Scalar>& defaultValue, const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount)\n+        : TBase(recordsCount, EType::SparsedArray, type)\n+        , DefaultValue(defaultValue) {\n+        Records.emplace_back(MakeDefaultChunk(defaultValue, type, recordsCount));\n+    }\n+\n+    virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 index) const override {\n+        auto& chunk = GetSparsedChunk(index);\n+        return chunk.GetScalar(index - chunk.GetStartPosition());\n+    }\n+\n+    const TSparsedArrayChunk& GetSparsedChunk(const ui64 position) const {\n+        const auto pred = [](const ui64 position, const TSparsedArrayChunk& item) {\n+            return position < item.GetStartPosition();\n+        };\n+        auto it = std::upper_bound(Records.begin(), Records.end(), position, pred);\n+        AFL_VERIFY(it != Records.begin());\n+        --it;\n+        AFL_VERIFY(position < it->GetStartPosition() + it->GetRecordsCount());\n+        AFL_VERIFY(it->GetStartPosition() <= position);\n+        return *it;\n+    }\n+\n+    class TBuilder {\n+    private:\n+        ui32 RecordsCount = 0;\n+        std::vector<TSparsedArrayChunk> Chunks;\n+        std::shared_ptr<arrow::Scalar> DefaultValue;\n+        std::shared_ptr<arrow::DataType> Type;\n+\n+    public:\n+        TBuilder(const std::shared_ptr<arrow::Scalar>& defaultValue, const std::shared_ptr<arrow::DataType>& type)\n+            : DefaultValue(defaultValue)\n+            , Type(type) {\n+        }\n+\n+        void AddChunk(const ui32 recordsCount, const std::shared_ptr<arrow::RecordBatch>& data);\n+\n+        std::shared_ptr<TSparsedArray> Finish() {\n+            return std::shared_ptr<TSparsedArray>(new TSparsedArray(std::move(Chunks), DefaultValue, Type, RecordsCount));\n+        }\n+    };\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp b/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp\nnew file mode 100644\nindex 000000000000..e3f45cd75327\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp\n@@ -0,0 +1,34 @@\n+#include \"accessor.h\"\n+#include \"constructor.h\"\n+\n+namespace NKikimr::NArrow::NAccessor::NSparsed {\n+\n+std::shared_ptr<arrow::Schema> TConstructor::DoGetExpectedSchema(const std::shared_ptr<arrow::Field>& resultColumn) const {\n+    arrow::FieldVector fields = { std::make_shared<arrow::Field>(\"index\", arrow::uint32()),\n+        std::make_shared<arrow::Field>(\"value\", resultColumn->type()) };\n+    return std::make_shared<arrow::Schema>(fields);\n+}\n+\n+TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstructDefault(const TChunkConstructionData& externalInfo) const {\n+    return std::make_shared<TSparsedArray>(externalInfo.GetDefaultValue(), externalInfo.GetColumnType(), externalInfo.GetRecordsCount());\n+}\n+\n+TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(\n+    const std::shared_ptr<arrow::RecordBatch>& originalData, const TChunkConstructionData& externalInfo) const {\n+    AFL_VERIFY(originalData->num_columns() == 2)(\"count\", originalData->num_columns())(\"schema\", originalData->schema()->ToString());\n+    NArrow::NAccessor::TSparsedArray::TBuilder builder(externalInfo.GetDefaultValue(), externalInfo.GetColumnType());\n+    builder.AddChunk(externalInfo.GetRecordsCount(), originalData);\n+    return builder.Finish();\n+}\n+\n+NKikimrArrowAccessorProto::TConstructor TConstructor::DoSerializeToProto() const {\n+    NKikimrArrowAccessorProto::TConstructor result;\n+    *result.MutableSparsed() = {};\n+    return result;\n+}\n+\n+bool TConstructor::DoDeserializeFromProto(const NKikimrArrowAccessorProto::TConstructor& /*proto*/) {\n+    return true;\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NSparsed\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/constructor.h b/ydb/core/formats/arrow/accessor/sparsed/constructor.h\nnew file mode 100644\nindex 000000000000..0ccf5efdd70f\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/constructor.h\n@@ -0,0 +1,28 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NSparsed {\n+\n+class TConstructor: public IConstructor {\n+public:\n+    static TString GetClassNameStatic() {\n+        return TGlobalConst::SparsedDataAccessorName;\n+    }\n+\n+private:\n+    static inline auto Registrator = TFactory::TRegistrator<TConstructor>(GetClassNameStatic());\n+    virtual TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> DoConstruct(\n+        const std::shared_ptr<arrow::RecordBatch>& originalData, const TChunkConstructionData& externalInfo) const override;\n+    virtual NKikimrArrowAccessorProto::TConstructor DoSerializeToProto() const override;\n+    virtual bool DoDeserializeFromProto(const NKikimrArrowAccessorProto::TConstructor& proto) override;\n+    virtual std::shared_ptr<arrow::Schema> DoGetExpectedSchema(const std::shared_ptr<arrow::Field>& resultColumn) const override;\n+    virtual TConclusion<std::shared_ptr<IChunkedArray>> DoConstructDefault(const TChunkConstructionData& externalInfo) const override;\n+\n+public:\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NSparsed\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/request.cpp b/ydb/core/formats/arrow/accessor/sparsed/request.cpp\nnew file mode 100644\nindex 000000000000..d484341a95c0\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/request.cpp\n@@ -0,0 +1,22 @@\n+#include \"request.h\"\n+#include \"constructor.h\"\n+\n+namespace NKikimr::NArrow::NAccessor::NSparsed {\n+\n+NKikimrArrowAccessorProto::TRequestedConstructor TRequestedConstuctor::DoSerializeToProto() const {\n+    return NKikimrArrowAccessorProto::TRequestedConstructor();\n+}\n+\n+bool TRequestedConstuctor::DoDeserializeFromProto(const NKikimrArrowAccessorProto::TRequestedConstructor& /*proto*/) {\n+    return true;\n+}\n+\n+NKikimr::TConclusionStatus TRequestedConstuctor::DoDeserializeFromRequest(NYql::TFeaturesExtractor& /*features*/) {\n+    return TConclusionStatus::Success();\n+}\n+\n+NKikimr::TConclusion<NKikimr::NArrow::NAccessor::TConstructorContainer> TRequestedConstuctor::DoBuildConstructor() const {\n+    return std::make_shared<TConstructor>();\n+}\n+\n+}\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/request.h b/ydb/core/formats/arrow/accessor/sparsed/request.h\nnew file mode 100644\nindex 000000000000..4be2d897b090\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/request.h\n@@ -0,0 +1,26 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/accessor/abstract/request.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NSparsed {\n+\n+class TRequestedConstuctor: public IRequestedConstructor {\n+public:\n+    static TString GetClassNameStatic() {\n+        return TGlobalConst::SparsedDataAccessorName;\n+    }\n+\n+private:\n+    static inline auto Registrator = TFactory::TRegistrator<TRequestedConstuctor>(GetClassNameStatic());\n+    virtual TConclusion<TConstructorContainer> DoBuildConstructor() const override;\n+    virtual NKikimrArrowAccessorProto::TRequestedConstructor DoSerializeToProto() const override;\n+    virtual bool DoDeserializeFromProto(const NKikimrArrowAccessorProto::TRequestedConstructor& proto) override;\n+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& features) override;\n+\n+public:\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NSparsed\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/ya.make b/ydb/core/formats/arrow/accessor/sparsed/ya.make\nnew file mode 100644\nindex 000000000000..c68f5f84f9a6\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sparsed/ya.make\n@@ -0,0 +1,15 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    ydb/core/formats/arrow/accessor/abstract\n+    ydb/library/formats/arrow\n+    ydb/library/formats/arrow/protos\n+)\n+\n+SRCS(\n+    GLOBAL constructor.cpp\n+    GLOBAL request.cpp\n+    accessor.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/accessor/ya.make b/ydb/core/formats/arrow/accessor/ya.make\nnew file mode 100644\nindex 000000000000..197b97d9efe7\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/ya.make\n@@ -0,0 +1,10 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    ydb/core/formats/arrow/accessor/abstract\n+    ydb/core/formats/arrow/accessor/plain\n+    ydb/core/formats/arrow/accessor/composite_serial\n+    ydb/core/formats/arrow/accessor/sparsed\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/arrow_filter.cpp b/ydb/core/formats/arrow/arrow_filter.cpp\nindex 58cd7116baed..c404a016f4bd 100644\n--- a/ydb/core/formats/arrow/arrow_filter.cpp\n+++ b/ydb/core/formats/arrow/arrow_filter.cpp\n@@ -1,5 +1,5 @@\n #include \"arrow_filter.h\"\n-#include \"switch_type.h\"\n+#include \"switch/switch_type.h\"\n #include \"common/container.h\"\n #include \"common/adapter.h\"\n \ndiff --git a/ydb/core/formats/arrow/arrow_helpers.cpp b/ydb/core/formats/arrow/arrow_helpers.cpp\nindex 443bb091090c..1246b01e334c 100644\n--- a/ydb/core/formats/arrow/arrow_helpers.cpp\n+++ b/ydb/core/formats/arrow/arrow_helpers.cpp\n@@ -1,13 +1,14 @@\n #include \"arrow_helpers.h\"\n-#include \"switch_type.h\"\n-#include \"common/validation.h\"\n+#include \"switch/switch_type.h\"\n #include \"permutations.h\"\n #include \"common/adapter.h\"\n #include \"serializer/native.h\"\n #include \"serializer/abstract.h\"\n #include \"serializer/stream.h\"\n-#include \"simple_arrays_cache.h\"\n \n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/library/yverify_stream/yverify_stream.h>\n #include <ydb/library/services/services.pb.h>\n \n@@ -105,11 +106,6 @@ arrow::Result<std::shared_ptr<arrow::Schema>> MakeArrowSchema(const std::vector<\n     return fields.status();\n }\n \n-TString SerializeSchema(const arrow::Schema& schema) {\n-    auto buffer = TStatusValidator::GetValid(arrow::ipc::SerializeSchema(schema));\n-    return buffer->ToString();\n-}\n-\n std::shared_ptr<arrow::Schema> DeserializeSchema(const TString& str) {\n     std::shared_ptr<arrow::Buffer> buffer(std::make_shared<NSerialization::TBufferOverString>(str));\n     arrow::io::BufferReader reader(buffer);\n@@ -143,148 +139,6 @@ std::shared_ptr<arrow::RecordBatch> DeserializeBatch(const TString& blob, const\n     }\n }\n \n-std::shared_ptr<arrow::RecordBatch> MakeEmptyBatch(const std::shared_ptr<arrow::Schema>& schema, const ui32 rowsCount) {\n-    std::vector<std::shared_ptr<arrow::Array>> columns;\n-    columns.reserve(schema->num_fields());\n-\n-    for (auto& field : schema->fields()) {\n-        auto result = NArrow::TThreadSimpleArraysCache::GetNull(field->type(), rowsCount);\n-        columns.emplace_back(result);\n-        Y_ABORT_UNLESS(result);\n-    }\n-    return arrow::RecordBatch::Make(schema, rowsCount, columns);\n-}\n-\n-std::shared_ptr<arrow::RecordBatch> CombineBatches(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches) {\n-    if (batches.empty()) {\n-        return nullptr;\n-    }\n-    auto table = TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batches));\n-    return table ? ToBatch(table, true) : nullptr;\n-}\n-\n-std::shared_ptr<arrow::RecordBatch> ToBatch(const std::shared_ptr<arrow::Table>& tableExt, const bool combine) {\n-    if (!tableExt) {\n-        return nullptr;\n-    }\n-    std::shared_ptr<arrow::Table> table;\n-    if (combine) {\n-        auto res = tableExt->CombineChunks();\n-        Y_ABORT_UNLESS(res.ok());\n-        table = *res;\n-    } else {\n-        table = tableExt;\n-    }\n-    std::vector<std::shared_ptr<arrow::Array>> columns;\n-    columns.reserve(table->num_columns());\n-    for (auto& col : table->columns()) {\n-        AFL_VERIFY(col->num_chunks() == 1)(\"size\", col->num_chunks())(\"size_bytes\", GetTableDataSize(tableExt))\n-            (\"schema\", tableExt->schema()->ToString())(\"size_new\", GetTableDataSize(table));\n-        columns.push_back(col->chunk(0));\n-    }\n-    return arrow::RecordBatch::Make(table->schema(), table->num_rows(), columns);\n-}\n-\n-// Check if the permutation doesn't reorder anything\n-bool IsTrivial(const arrow::UInt64Array& permutation, const ui64 originalLength) {\n-    if ((ui64)permutation.length() != originalLength) {\n-        return false;\n-    }\n-    for (i64 i = 0; i < permutation.length(); ++i) {\n-        if (permutation.Value(i) != (ui64)i) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-std::shared_ptr<arrow::RecordBatch> Reorder(const std::shared_ptr<arrow::RecordBatch>& batch,\n-                                            const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove) {\n-    Y_ABORT_UNLESS(permutation->length() == batch->num_rows() || canRemove);\n-\n-    auto res = IsTrivial(*permutation, batch->num_rows()) ? batch : arrow::compute::Take(batch, permutation);\n-    Y_ABORT_UNLESS(res.ok());\n-    return (*res).record_batch();\n-}\n-\n-THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows) {\n-    AFL_VERIFY(batch);\n-    std::shared_ptr<arrow::UInt64Array> permutation;\n-    {\n-        arrow::UInt64Builder builder;\n-        Y_VERIFY_OK(builder.Reserve(batch->num_rows()));\n-\n-        for (auto&& [shardId, rowIdxs]: shardRows) {\n-            for (auto& row : rowIdxs) {\n-                Y_VERIFY_OK(builder.Append(row));\n-            }\n-        }\n-        Y_VERIFY_OK(builder.Finish(&permutation));\n-    }\n-\n-    auto reorderedBatch = Reorder(batch, permutation, false);\n-\n-    THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> out;\n-\n-    int offset = 0;\n-    for (auto&& [shardId, shardRowIdxs] : shardRows) {\n-        if (shardRowIdxs.empty()) {\n-            continue;\n-        }\n-        out.emplace(shardId, reorderedBatch->Slice(offset, shardRowIdxs.size()));\n-        offset += shardRowIdxs.size();\n-    }\n-\n-    Y_ABORT_UNLESS(offset == batch->num_rows());\n-    return out;\n-}\n-\n-std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::vector<ui32>>& shardRows, const ui32 numShards) {\n-    AFL_VERIFY(batch);\n-    std::shared_ptr<arrow::UInt64Array> permutation;\n-    {\n-        arrow::UInt64Builder builder;\n-        Y_VERIFY_OK(builder.Reserve(batch->num_rows()));\n-\n-        for (ui32 shardNo = 0; shardNo < numShards; ++shardNo) {\n-            for (auto& row : shardRows[shardNo]) {\n-                Y_VERIFY_OK(builder.Append(row));\n-            }\n-        }\n-        Y_VERIFY_OK(builder.Finish(&permutation));\n-    }\n-\n-    auto reorderedBatch = Reorder(batch, permutation, false);\n-\n-    std::vector<std::shared_ptr<arrow::RecordBatch>> out(numShards);\n-\n-    int offset = 0;\n-    for (ui32 shardNo = 0; shardNo < numShards; ++shardNo) {\n-        int length = shardRows[shardNo].size();\n-        if (length) {\n-            out[shardNo] = reorderedBatch->Slice(offset, length);\n-            offset += length;\n-        }\n-    }\n-\n-    Y_ABORT_UNLESS(offset == batch->num_rows());\n-    return out;\n-}\n-\n-std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch,\n-                                                               const std::vector<ui32>& sharding, ui32 numShards) {\n-    AFL_VERIFY(batch);\n-    Y_ABORT_UNLESS((size_t)batch->num_rows() == sharding.size());\n-\n-    std::vector<std::vector<ui32>> shardRows(numShards);\n-    for (size_t row = 0; row < sharding.size(); ++row) {\n-        ui32 shardNo = sharding[row];\n-        Y_ABORT_UNLESS(shardNo < numShards);\n-        shardRows[shardNo].push_back(row);\n-    }\n-    return ShardingSplit(batch, shardRows, numShards);\n-}\n-\n void DedupSortedBatch(const std::shared_ptr<arrow::RecordBatch>& batch,\n                       const std::shared_ptr<arrow::Schema>& sortingKey,\n                       std::vector<std::shared_ptr<arrow::RecordBatch>>& out) {\n@@ -322,37 +176,6 @@ void DedupSortedBatch(const std::shared_ptr<arrow::RecordBatch>& batch,\n     Y_DEBUG_ABORT_UNLESS(NArrow::IsSortedAndUnique(out.back(), sortingKey));\n }\n \n-template <bool desc, bool uniq>\n-static bool IsSelfSorted(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    if (batch->num_rows() < 2) {\n-        return true;\n-    }\n-    auto& columns = batch->columns();\n-\n-    for (int i = 1; i < batch->num_rows(); ++i) {\n-        TRawReplaceKey prev(&columns, i - 1);\n-        TRawReplaceKey current(&columns, i);\n-        if constexpr (desc) {\n-            if (prev < current) {\n-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"prev < current\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n-                return false;\n-            }\n-        } else {\n-            if (current < prev) {\n-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"current < prev\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n-                return false;\n-            }\n-        }\n-        if constexpr (uniq) {\n-            if (prev == current) {\n-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"equal\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n-                return false;\n-            }\n-        }\n-    }\n-    return true;\n-}\n-\n bool IsSorted(const std::shared_ptr<arrow::RecordBatch>& batch,\n               const std::shared_ptr<arrow::Schema>& sortingKey, bool desc) {\n     auto keyBatch = TColumnOperator().Adapt(batch, sortingKey).DetachResult();\n@@ -373,280 +196,6 @@ bool IsSortedAndUnique(const std::shared_ptr<arrow::RecordBatch>& batch,\n     }\n }\n \n-bool HasAllColumns(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& schema) {\n-    for (auto& field : schema->fields()) {\n-        if (batch->schema()->GetFieldIndex(field->name()) < 0) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-std::vector<std::unique_ptr<arrow::ArrayBuilder>> MakeBuilders(const std::shared_ptr<arrow::Schema>& schema,\n-                                                               size_t reserve, const std::map<std::string, ui64>& sizeByColumn) {\n-    std::vector<std::unique_ptr<arrow::ArrayBuilder>> builders;\n-    builders.reserve(schema->num_fields());\n-\n-    for (auto& field : schema->fields()) {\n-        std::unique_ptr<arrow::ArrayBuilder> builder;\n-        TStatusValidator::Validate(arrow::MakeBuilder(arrow::default_memory_pool(), field->type(), &builder));\n-        if (sizeByColumn.size()) {\n-            auto it = sizeByColumn.find(field->name());\n-            if (it != sizeByColumn.end()) {\n-                AFL_VERIFY(NArrow::ReserveData(*builder, it->second))(\"size\", it->second)(\"field\", field->name());\n-            }\n-        }\n-\n-        if (reserve) {\n-            TStatusValidator::Validate(builder->Reserve(reserve));\n-        }\n-\n-        builders.emplace_back(std::move(builder));\n-\n-    }\n-    return builders;\n-}\n-\n-std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::Field>& field) {\n-    AFL_VERIFY(field);\n-    return MakeBuilder(field->type());\n-}\n-\n-std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::DataType>& type) {\n-    AFL_VERIFY(type);\n-    std::unique_ptr<arrow::ArrayBuilder> builder;\n-    TStatusValidator::Validate(arrow::MakeBuilder(arrow::default_memory_pool(), type, &builder));\n-    return std::move(builder);\n-}\n-\n-std::vector<std::shared_ptr<arrow::Array>> Finish(std::vector<std::unique_ptr<arrow::ArrayBuilder>>&& builders) {\n-    std::vector<std::shared_ptr<arrow::Array>> out;\n-    for (auto& builder : builders) {\n-        std::shared_ptr<arrow::Array> array;\n-        TStatusValidator::Validate(builder->Finish(&array));\n-        out.emplace_back(array);\n-    }\n-    return out;\n-}\n-\n-std::vector<TString> ColumnNames(const std::shared_ptr<arrow::Schema>& schema) {\n-    std::vector<TString> out;\n-    out.reserve(schema->num_fields());\n-    for (int i = 0; i < schema->num_fields(); ++i) {\n-        auto& name = schema->field(i)->name();\n-        out.emplace_back(TString(name.data(), name.size()));\n-    }\n-    return out;\n-}\n-\n-std::shared_ptr<arrow::UInt64Array> MakeUI64Array(ui64 value, i64 size) {\n-    auto res = arrow::MakeArrayFromScalar(arrow::UInt64Scalar(value), size);\n-    Y_ABORT_UNLESS(res.ok());\n-    return std::static_pointer_cast<arrow::UInt64Array>(*res);\n-}\n-\n-std::pair<int, int> FindMinMaxPosition(const std::shared_ptr<arrow::Array>& array) {\n-    if (array->length() == 0) {\n-        return {-1, -1};\n-    }\n-\n-    int minPos = 0;\n-    int maxPos = 0;\n-    SwitchType(array->type_id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-\n-        auto& column = static_cast<const TArray&>(*array);\n-\n-        for (int i = 1; i < column.length(); ++i) {\n-            const auto& value = column.GetView(i);\n-            if (value < column.GetView(minPos)) {\n-                minPos = i;\n-            }\n-            if (value > column.GetView(maxPos)) {\n-                maxPos = i;\n-            }\n-        }\n-        return true;\n-    });\n-    return {minPos, maxPos};\n-}\n-\n-std::shared_ptr<arrow::Scalar> MinScalar(const std::shared_ptr<arrow::DataType>& type) {\n-    std::shared_ptr<arrow::Scalar> out;\n-    SwitchType(type->id(), [&](const auto& t) {\n-        using TWrap = std::decay_t<decltype(t)>;\n-        using T = typename TWrap::T;\n-        using TScalar = typename arrow::TypeTraits<T>::ScalarType;\n-\n-        if constexpr (std::is_same_v<T, arrow::StringType> ||\n-                      std::is_same_v<T, arrow::BinaryType> ||\n-                      std::is_same_v<T, arrow::LargeStringType> ||\n-                      std::is_same_v<T, arrow::LargeBinaryType>) {\n-            out = std::make_shared<TScalar>(arrow::Buffer::FromString(\"\"), type);\n-        } else if constexpr (std::is_same_v<T, arrow::FixedSizeBinaryType>) {\n-            std::string s(static_cast<arrow::FixedSizeBinaryType&>(*type).byte_width(), '\\0');\n-            out = std::make_shared<TScalar>(arrow::Buffer::FromString(s), type);\n-        } else if constexpr (std::is_same_v<T, arrow::HalfFloatType>) {\n-            return false;\n-        } else if constexpr (arrow::is_temporal_type<T>::value) {\n-            using TCType = typename arrow::TypeTraits<T>::CType;\n-            out = std::make_shared<TScalar>(Min<TCType>(), type);\n-        } else if constexpr (arrow::has_c_type<T>::value) {\n-            using TCType = typename arrow::TypeTraits<T>::CType;\n-            out = std::make_shared<TScalar>(Min<TCType>());\n-        } else {\n-            return false;\n-        }\n-        return true;\n-    });\n-    Y_ABORT_UNLESS(out);\n-    return out;\n-}\n-\n-namespace {\n-\n-template <class T>\n-class TDefaultScalarValue {\n-public:\n-    static constexpr T Value = 0;\n-};\n-\n-template <>\n-class TDefaultScalarValue<bool> {\n-public:\n-    static constexpr bool Value = false;\n-};\n-\n-}\n-\n-std::shared_ptr<arrow::Scalar> DefaultScalar(const std::shared_ptr<arrow::DataType>& type) {\n-    std::shared_ptr<arrow::Scalar> out;\n-    SwitchType(type->id(), [&](const auto& t) {\n-        using TWrap = std::decay_t<decltype(t)>;\n-        using T = typename TWrap::T;\n-        using TScalar = typename arrow::TypeTraits<T>::ScalarType;\n-\n-        if constexpr (std::is_same_v<T, arrow::StringType> ||\n-            std::is_same_v<T, arrow::BinaryType> ||\n-            std::is_same_v<T, arrow::LargeStringType> ||\n-            std::is_same_v<T, arrow::LargeBinaryType>) {\n-            out = std::make_shared<TScalar>(arrow::Buffer::FromString(\"\"), type);\n-        } else if constexpr (std::is_same_v<T, arrow::FixedSizeBinaryType>) {\n-            std::string s(static_cast<arrow::FixedSizeBinaryType&>(*type).byte_width(), '\\0');\n-            out = std::make_shared<TScalar>(arrow::Buffer::FromString(s), type);\n-        } else if constexpr (std::is_same_v<T, arrow::HalfFloatType>) {\n-            return false;\n-        } else if constexpr (arrow::is_temporal_type<T>::value) {\n-            using TCType = typename arrow::TypeTraits<T>::CType;\n-            out = std::make_shared<TScalar>(TDefaultScalarValue<TCType>::Value, type);\n-        } else if constexpr (arrow::has_c_type<T>::value) {\n-            using TCType = typename arrow::TypeTraits<T>::CType;\n-            out = std::make_shared<TScalar>(TDefaultScalarValue<TCType>::Value);\n-        } else {\n-            return false;\n-        }\n-        return true;\n-    });\n-    AFL_VERIFY(out)(\"type\", type->ToString());\n-    return out;\n-}\n-\n-std::shared_ptr<arrow::Scalar> GetScalar(const std::shared_ptr<arrow::Array>& array, int position) {\n-    auto res = array->GetScalar(position);\n-    Y_ABORT_UNLESS(res.ok());\n-    return *res;\n-}\n-\n-bool IsGoodScalar(const std::shared_ptr<arrow::Scalar>& x) {\n-    if (!x) {\n-        return false;\n-    }\n-\n-    return SwitchType(x->type->id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TScalar = typename arrow::TypeTraits<typename TWrap::T>::ScalarType;\n-        using TValue = std::decay_t<decltype(static_cast<const TScalar&>(*x).value)>;\n-\n-        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n-            const auto& xval = static_cast<const TScalar&>(*x).value;\n-            return xval && xval->data();\n-        }\n-        if constexpr (std::is_arithmetic_v<TValue>) {\n-            return true;\n-        }\n-        return false;\n-    });\n-}\n-\n-bool ScalarLess(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y) {\n-    Y_ABORT_UNLESS(x);\n-    Y_ABORT_UNLESS(y);\n-    return ScalarLess(*x, *y);\n-}\n-\n-bool ScalarLess(const arrow::Scalar& x, const arrow::Scalar& y) {\n-    return ScalarCompare(x, y) < 0;\n-}\n-\n-int ScalarCompare(const arrow::Scalar& x, const arrow::Scalar& y) {\n-    Y_VERIFY_S(x.type->Equals(y.type), x.type->ToString() + \" vs \" + y.type->ToString());\n-\n-    return SwitchTypeImpl<int, 0>(x.type->id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TScalar = typename arrow::TypeTraits<typename TWrap::T>::ScalarType;\n-        using TValue = std::decay_t<decltype(static_cast<const TScalar&>(x).value)>;\n-\n-        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n-            const auto& xval = static_cast<const TScalar&>(x).value;\n-            const auto& yval = static_cast<const TScalar&>(y).value;\n-            Y_ABORT_UNLESS(xval);\n-            Y_ABORT_UNLESS(yval);\n-            TStringBuf xBuf(reinterpret_cast<const char*>(xval->data()), xval->size());\n-            TStringBuf yBuf(reinterpret_cast<const char*>(yval->data()), yval->size());\n-            if (xBuf < yBuf) {\n-                return -1;\n-            } else if (yBuf < xBuf) {\n-                return 1;\n-            } else {\n-                return 0;\n-            }\n-        }\n-        if constexpr (std::is_arithmetic_v<TValue>) {\n-            const auto& xval = static_cast<const TScalar&>(x).value;\n-            const auto& yval = static_cast<const TScalar&>(y).value;\n-            if (xval < yval) {\n-                return -1;\n-            } else if (yval < xval) {\n-                return 1;\n-            } else {\n-                return 0;\n-            }\n-        }\n-        Y_ABORT_UNLESS(false); // TODO: non primitive types\n-        return 0;\n-    });\n-}\n-\n-int ScalarCompare(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y) {\n-    Y_ABORT_UNLESS(x);\n-    Y_ABORT_UNLESS(y);\n-    return ScalarCompare(*x, *y);\n-}\n-\n-int ScalarCompareNullable(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y) {\n-    if (!x && !!y) {\n-        return -1;\n-    }\n-    if (!!x && !y) {\n-        return 1;\n-    }\n-    if (!x && !y) {\n-        return 0;\n-    }\n-    return ScalarCompare(*x, *y);\n-}\n-\n std::shared_ptr<arrow::RecordBatch> SortBatch(const std::shared_ptr<arrow::RecordBatch>& batch,\n                                               const std::shared_ptr<arrow::Schema>& sortingKey, const bool andUnique) {\n     auto sortPermutation = MakeSortPermutation(batch, sortingKey, andUnique);\n@@ -657,217 +206,6 @@ std::shared_ptr<arrow::RecordBatch> SortBatch(const std::shared_ptr<arrow::Recor\n     }\n }\n \n-std::shared_ptr<arrow::Array> BoolVecToArray(const std::vector<bool>& vec) {\n-    std::shared_ptr<arrow::Array> out;\n-    arrow::BooleanBuilder builder;\n-    for (const auto val : vec) {\n-        Y_ABORT_UNLESS(builder.Append(val).ok());\n-    }\n-    Y_ABORT_UNLESS(builder.Finish(&out).ok());\n-    return out;\n-}\n-\n-\n-bool ArrayScalarsEqual(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs) {\n-    bool res = lhs->length() == rhs->length();\n-    for (int64_t i = 0; i < lhs->length() && res; ++i) {\n-        res &= arrow::ScalarEquals(*lhs->GetScalar(i).ValueOrDie(), *rhs->GetScalar(i).ValueOrDie());\n-    }\n-    return res;\n-}\n-\n-bool ReserveData(arrow::ArrayBuilder& builder, const size_t size) {\n-    arrow::Status result = arrow::Status::OK();\n-    if (builder.type()->id() == arrow::Type::BINARY ||\n-        builder.type()->id() == arrow::Type::STRING)\n-    {\n-        static_assert(std::is_convertible_v<arrow::StringBuilder&, arrow::BaseBinaryBuilder<arrow::BinaryType>&>,\n-            \"Expected StringBuilder to be BaseBinaryBuilder<BinaryType>\");\n-        auto& bBuilder = static_cast<arrow::BaseBinaryBuilder<arrow::BinaryType>&>(builder);\n-        result = bBuilder.ReserveData(size);\n-    }\n-\n-    if (!result.ok()) {\n-        AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"ReserveData\")(\"error\", result.ToString());\n-    }\n-    return result.ok();\n-}\n-\n-template <class TData, class TColumn, class TBuilder>\n-bool MergeBatchColumnsImpl(const std::vector<std::shared_ptr<TData>>& batches, std::shared_ptr<TData>& result,\n-    const std::vector<std::string>& columnsOrder, const bool orderFieldsAreNecessary, const TBuilder& builder) {\n-    if (batches.empty()) {\n-        result = nullptr;\n-        return true;\n-    }\n-    if (batches.size() == 1) {\n-        result = batches.front();\n-        return true;\n-    }\n-    std::vector<std::shared_ptr<arrow::Field>> fields;\n-    std::vector<std::shared_ptr<TColumn>> columns;\n-    std::map<std::string, ui32> fieldNames;\n-    for (auto&& i : batches) {\n-        Y_ABORT_UNLESS(i);\n-        for (auto&& f : i->schema()->fields()) {\n-            if (!fieldNames.emplace(f->name(), fields.size()).second) {\n-                AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"duplicated column\")(\"name\", f->name());\n-                return false;\n-            }\n-            fields.emplace_back(f);\n-        }\n-        if (i->num_rows() != batches.front()->num_rows()) {\n-            AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"inconsistency record sizes\")(\"i\", i->num_rows())(\"front\", batches.front()->num_rows());\n-            return false;\n-        }\n-        for (auto&& c : i->columns()) {\n-            columns.emplace_back(c);\n-        }\n-    }\n-\n-    Y_ABORT_UNLESS(fields.size() == columns.size());\n-    if (columnsOrder.size()) {\n-        std::vector<std::shared_ptr<arrow::Field>> fieldsOrdered;\n-        std::vector<std::shared_ptr<TColumn>> columnsOrdered;\n-        for (auto&& i : columnsOrder) {\n-            auto it = fieldNames.find(i);\n-            if (orderFieldsAreNecessary) {\n-                Y_ABORT_UNLESS(it != fieldNames.end());\n-            } else if (it == fieldNames.end()) {\n-                continue;\n-            }\n-            fieldsOrdered.emplace_back(fields[it->second]);\n-            columnsOrdered.emplace_back(columns[it->second]);\n-        }\n-        std::swap(fieldsOrdered, fields);\n-        std::swap(columnsOrdered, columns);\n-    }\n-    result = builder(std::make_shared<arrow::Schema>(fields), batches.front()->num_rows(), std::move(columns));\n-    return true;\n-}\n-\n-bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::Table>>& batches, std::shared_ptr<arrow::Table>& result, const std::vector<std::string>& columnsOrder, const bool orderFieldsAreNecessary) {\n-    const auto builder = [](const std::shared_ptr<arrow::Schema>& schema, const ui32 recordsCount, std::vector<std::shared_ptr<arrow::ChunkedArray>>&& columns) {\n-        return arrow::Table::Make(schema, columns, recordsCount);\n-    };\n-\n-    return MergeBatchColumnsImpl<arrow::Table, arrow::ChunkedArray>(batches, result, columnsOrder, orderFieldsAreNecessary, builder);\n-}\n-\n-bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, std::shared_ptr<arrow::RecordBatch>& result, const std::vector<std::string>& columnsOrder, const bool orderFieldsAreNecessary) {\n-    const auto builder = [](const std::shared_ptr<arrow::Schema>& schema, const ui32 recordsCount, std::vector<std::shared_ptr<arrow::Array>>&& columns) {\n-        return arrow::RecordBatch::Make(schema, recordsCount, columns);\n-    };\n-\n-    return MergeBatchColumnsImpl<arrow::RecordBatch, arrow::Array>(batches, result, columnsOrder, orderFieldsAreNecessary, builder);\n-}\n-\n-std::partial_ordering ColumnsCompare(const std::vector<std::shared_ptr<arrow::Array>>& x, const ui32 xRow, const std::vector<std::shared_ptr<arrow::Array>>& y, const ui32 yRow) {\n-    return TRawReplaceKey(&x, xRow).CompareNotNull(TRawReplaceKey(&y, yRow));\n-}\n-\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> array, const ui32 position) {\n-    NJson::TJsonValue result = NJson::JSON_ARRAY;\n-    for (auto&& i : array->columns()) {\n-        result.AppendValue(DebugJson(i, position));\n-    }\n-    return result;\n-}\n-\n-TString DebugString(std::shared_ptr<arrow::Array> array, const ui32 position) {\n-    if (!array) {\n-        return \"_NO_DATA\";\n-    }\n-    Y_ABORT_UNLESS(position < array->length());\n-    TStringBuilder result;\n-    SwitchType(array->type_id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-\n-        auto& column = static_cast<const TArray&>(*array);\n-        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n-            auto value = column.GetString(position);\n-            result << TString(value.data(), value.size());\n-        }\n-        if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n-            result << column.Value(position);\n-        }\n-        return true;\n-    });\n-    return result;\n-}\n-\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 position) {\n-    if (!array) {\n-        return NJson::JSON_NULL;\n-    }\n-    Y_ABORT_UNLESS(position < array->length());\n-    NJson::TJsonValue result = NJson::JSON_MAP;\n-    SwitchType(array->type_id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-\n-        auto& column = static_cast<const TArray&>(*array);\n-        result.InsertValue(\"type\", typeid(TArray).name());\n-        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n-            auto value = column.GetString(position);\n-            result.InsertValue(\"value\", TString(value.data(), value.size()));\n-        }\n-        if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n-            result.InsertValue(\"value\", column.Value(position));\n-        }\n-        return true;\n-    });\n-    return result;\n-}\n-\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 head, const ui32 tail) {\n-    if (!array) {\n-        return NJson::JSON_NULL;\n-    }\n-    NJson::TJsonValue resultFull = NJson::JSON_MAP;\n-    resultFull.InsertValue(\"length\", array->length());\n-    SwitchType(array->type_id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-\n-        auto& column = static_cast<const TArray&>(*array);\n-        resultFull.InsertValue(\"type\", typeid(TArray).name());\n-        resultFull.InsertValue(\"head\", head);\n-        resultFull.InsertValue(\"tail\", tail);\n-        auto& result = resultFull.InsertValue(\"data\", NJson::JSON_ARRAY);\n-        for (int i = 0; i < column.length(); ++i) {\n-            if (i >= (int)head && i + (int)tail < column.length()) {\n-                continue;\n-            }\n-            if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n-                auto value = column.GetString(i);\n-                result.AppendValue(TString(value.data(), value.size()));\n-            }\n-            if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n-                result.AppendValue(column.Value(i));\n-            }\n-        }\n-        return true;\n-        });\n-    return resultFull;\n-}\n-\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> batch, const ui32 head, const ui32 tail) {\n-    if (!batch) {\n-        return NJson::JSON_NULL;\n-    }\n-    NJson::TJsonValue result = NJson::JSON_ARRAY;\n-    ui32 idx = 0;\n-    for (auto&& i : batch->columns()) {\n-        auto& jsonColumn = result.AppendValue(NJson::JSON_MAP);\n-        jsonColumn.InsertValue(\"name\", batch->column_name(idx));\n-        jsonColumn.InsertValue(\"data\", DebugJson(i, head, tail));\n-        ++idx;\n-    }\n-    return result;\n-}\n-\n std::shared_ptr<arrow::RecordBatch> ReallocateBatch(std::shared_ptr<arrow::RecordBatch> original) {\n     if (!original) {\n         return nullptr;\n@@ -875,120 +213,16 @@ std::shared_ptr<arrow::RecordBatch> ReallocateBatch(std::shared_ptr<arrow::Recor\n     return DeserializeBatch(SerializeBatch(original, arrow::ipc::IpcWriteOptions::Defaults()), original->schema());\n }\n \n-std::shared_ptr<arrow::RecordBatch> MergeColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches) {\n-    std::vector<std::shared_ptr<arrow::Array>> columns;\n-    std::vector<std::shared_ptr<arrow::Field>> fields;\n-    std::optional<ui32> recordsCount;\n-    std::set<std::string> columnNames;\n-    for (auto&& batch : batches) {\n-        if (!batch) {\n-            continue;\n-        }\n-        for (auto&& column : batch->columns()) {\n-            columns.emplace_back(column);\n-            if (!recordsCount) {\n-                recordsCount = column->length();\n-            } else {\n-                Y_ABORT_UNLESS(*recordsCount == column->length());\n-            }\n-        }\n-        for (auto&& field : batch->schema()->fields()) {\n-            AFL_VERIFY(columnNames.emplace(field->name()).second)(\"field_name\", field->name());\n-            fields.emplace_back(field);\n-        }\n-    }\n-    if (columns.empty()) {\n-        return nullptr;\n-    }\n-    auto schema = std::make_shared<arrow::Schema>(fields);\n-    return arrow::RecordBatch::Make(schema, *recordsCount, columns);\n-}\n-\n-std::vector<std::shared_ptr<arrow::RecordBatch>> SliceToRecordBatches(const std::shared_ptr<arrow::Table>& t) {\n-    if (!t->num_rows()) {\n-        return {};\n-    }\n-    std::vector<ui32> positions;\n-    {\n-        for (auto&& i : t->columns()) {\n-            ui32 pos = 0;\n-            for (auto&& arr : i->chunks()) {\n-                positions.emplace_back(pos);\n-                pos += arr->length();\n-            }\n-            AFL_VERIFY(pos == t->num_rows());\n-        }\n-        positions.emplace_back(t->num_rows());\n-    }\n-    std::sort(positions.begin(), positions.end());\n-    positions.erase(std::unique(positions.begin(), positions.end()), positions.end());\n-    AFL_VERIFY(positions.size() > 1)(\"size\", positions.size())(\"positions\", JoinSeq(\",\", positions));\n-    std::vector<std::vector<std::shared_ptr<arrow::Array>>> slicedData;\n-    slicedData.resize(positions.size() - 1);\n-    for (auto&& i : t->columns()) {\n-        ui32 currentPosition = 0;\n-        auto it = i->chunks().begin();\n-        ui32 length = 0;\n-        const auto initializeIt = [&length, &it, &i]() {\n-            for (; it != i->chunks().end() && !(*it)->length(); ++it) {\n-            }\n-            if (it != i->chunks().end()) {\n-                length = (*it)->length();\n-            }\n-        };\n-        initializeIt();\n-        for (ui32 idx = 0; idx + 1 < positions.size(); ++idx) {\n-            AFL_VERIFY(it != i->chunks().end());\n-            AFL_VERIFY(positions[idx + 1] - currentPosition <= length)(\"length\", length)(\"idx+1\", positions[idx + 1])(\"pos\", currentPosition);\n-            auto chunk = (*it)->Slice(positions[idx] - currentPosition, positions[idx + 1] - positions[idx]);\n-            AFL_VERIFY_DEBUG(chunk->length() == positions[idx + 1] - positions[idx])(\"length\", chunk->length())(\"expect\", positions[idx + 1] - positions[idx]);\n-            if (positions[idx + 1] - currentPosition == length) {\n-                ++it;\n-                initializeIt();\n-                currentPosition = positions[idx + 1];\n-            }\n-            slicedData[idx].emplace_back(chunk);\n-        }\n-    }\n-    std::vector<std::shared_ptr<arrow::RecordBatch>> result;\n-    ui32 count = 0;\n-    for (auto&& i : slicedData) {\n-        AFL_VERIFY(i.size());\n-        AFL_VERIFY(i.front()->length());\n-        result.emplace_back(arrow::RecordBatch::Make(t->schema(), i.front()->length(), i));\n-        count += result.back()->num_rows();\n-    }\n-    AFL_VERIFY(count == t->num_rows())(\"count\", count)(\"t\", t->num_rows())(\"sd_size\", slicedData.size())(\"columns\", t->num_columns())(\n-                            \"schema\", t->schema()->ToString());\n-    return result;\n-}\n-\n-std::shared_ptr<arrow::Table> ToTable(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    if (!batch) {\n-        return nullptr;\n-    }\n-    return TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batch->schema(), {batch}));\n-}\n-\n-bool HasNulls(const std::shared_ptr<arrow::Array>& column) {\n-    AFL_VERIFY(column);\n-    return column->null_bitmap_data();\n-}\n-\n-std::vector<TString> ConvertStrings(const std::vector<std::string>& input) {\n-    std::vector<TString> result;\n-    for (auto&& i : input) {\n-        result.emplace_back(i);\n+std::shared_ptr<arrow::Table> ReallocateBatch(const std::shared_ptr<arrow::Table>& original) {\n+    if (!original) {\n+        return original;\n     }\n-    return result;\n-}\n-\n-std::vector<std::string> ConvertStrings(const std::vector<TString>& input) {\n-    std::vector<std::string> result;\n-    for (auto&& i : input) {\n-        result.emplace_back(i);\n+    auto batches = NArrow::SliceToRecordBatches(original);\n+    for (auto&& i : batches) {\n+        i = NArrow::TStatusValidator::GetValid(\n+            NArrow::NSerialization::TNativeSerializer().Deserialize(NArrow::NSerialization::TNativeSerializer().SerializeFull(i)));\n     }\n-    return result;\n+    return NArrow::TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batches));\n }\n \n }\ndiff --git a/ydb/core/formats/arrow/arrow_helpers.h b/ydb/core/formats/arrow/arrow_helpers.h\nindex 584803598daf..ea1f7a825bb2 100644\n--- a/ydb/core/formats/arrow/arrow_helpers.h\n+++ b/ydb/core/formats/arrow/arrow_helpers.h\n@@ -1,5 +1,4 @@\n #pragma once\n-#include \"switch_type.h\"\n #include \"process_columns.h\"\n #include <ydb/core/formats/factory.h>\n #include <ydb/core/scheme/scheme_tablecell.h>\n@@ -9,44 +8,16 @@\n #include <contrib/libs/apache/arrow/cpp/src/arrow/ipc/writer.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/util/compression.h>\n #include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/formats/arrow/arrow_helpers.h>\n \n namespace NKikimr::NArrow {\n \n-using TArrayVec = std::vector<std::shared_ptr<arrow::Array>>;\n-\n arrow::Result<std::shared_ptr<arrow::DataType>> GetArrowType(NScheme::TTypeInfo typeInfo);\n arrow::Result<std::shared_ptr<arrow::DataType>> GetCSVArrowType(NScheme::TTypeInfo typeId);\n \n-template <typename T>\n-inline bool ArrayEqualValue(const std::shared_ptr<arrow::Array>& x, const std::shared_ptr<arrow::Array>& y) {\n-    auto& arrX = static_cast<const T&>(*x);\n-    auto& arrY = static_cast<const T&>(*y);\n-    for (int i = 0; i < x->length(); ++i) {\n-        if (arrX.Value(i) != arrY.Value(i)) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-template <typename T>\n-inline bool ArrayEqualView(const std::shared_ptr<arrow::Array>& x, const std::shared_ptr<arrow::Array>& y) {\n-    auto& arrX = static_cast<const T&>(*x);\n-    auto& arrY = static_cast<const T&>(*y);\n-    for (int i = 0; i < x->length(); ++i) {\n-        if (arrX.GetView(i) != arrY.GetView(i)) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n-struct TSortDescription;\n-\n arrow::Result<arrow::FieldVector> MakeArrowFields(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns,  const std::set<std::string>& notNullColumns = {});\n arrow::Result<std::shared_ptr<arrow::Schema>> MakeArrowSchema(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns, const std::set<std::string>& notNullColumns = {});\n \n-TString SerializeSchema(const arrow::Schema& schema);\n std::shared_ptr<arrow::Schema> DeserializeSchema(const TString& str);\n \n TString SerializeBatch(const std::shared_ptr<arrow::RecordBatch>& batch, const arrow::ipc::IpcWriteOptions& options);\n@@ -54,28 +25,6 @@ TString SerializeBatchNoCompression(const std::shared_ptr<arrow::RecordBatch>& b\n \n std::shared_ptr<arrow::RecordBatch> DeserializeBatch(const TString& blob,\n                                                      const std::shared_ptr<arrow::Schema>& schema);\n-std::shared_ptr<arrow::RecordBatch> MakeEmptyBatch(const std::shared_ptr<arrow::Schema>& schema, const ui32 rowsCount = 0);\n-std::shared_ptr<arrow::Table> ToTable(const std::shared_ptr<arrow::RecordBatch>& batch);\n-\n-std::shared_ptr<arrow::RecordBatch> ToBatch(const std::shared_ptr<arrow::Table>& combinedTable, const bool combine);\n-std::shared_ptr<arrow::RecordBatch> CombineBatches(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches);\n-std::shared_ptr<arrow::RecordBatch> MergeColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& rb);\n-std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<ui32>& sharding, ui32 numShards);\n-std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::vector<ui32>>& shardRows, const ui32 numShards);\n-THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows);\n-\n-std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::Field>& field);\n-std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::DataType>& type);\n-\n-std::vector<std::unique_ptr<arrow::ArrayBuilder>> MakeBuilders(const std::shared_ptr<arrow::Schema>& schema,\n-    size_t reserve = 0, const std::map<std::string, ui64>& sizeByColumn = {});\n-std::vector<std::shared_ptr<arrow::Array>> Finish(std::vector<std::unique_ptr<arrow::ArrayBuilder>>&& builders);\n-\n-std::shared_ptr<arrow::UInt64Array> MakeUI64Array(ui64 value, i64 size);\n-std::vector<TString> ColumnNames(const std::shared_ptr<arrow::Schema>& schema);\n-bool ReserveData(arrow::ArrayBuilder& builder, const size_t size);\n-bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, std::shared_ptr<arrow::RecordBatch>& result, const std::vector<std::string>& columnsOrder = {}, const bool orderFieldsAreNecessary = true);\n-bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::Table>>& batches, std::shared_ptr<arrow::Table>& result, const std::vector<std::string>& columnsOrder = {}, const bool orderFieldsAreNecessary = true);\n \n std::shared_ptr<arrow::RecordBatch> SortBatch(const std::shared_ptr<arrow::RecordBatch>& batch,\n                                               const std::shared_ptr<arrow::Schema>& sortingKey, const bool andUnique);\n@@ -88,34 +37,8 @@ bool IsSortedAndUnique(const std::shared_ptr<arrow::RecordBatch>& batch,\n void DedupSortedBatch(const std::shared_ptr<arrow::RecordBatch>& batch,\n                        const std::shared_ptr<arrow::Schema>& sortingKey,\n                        std::vector<std::shared_ptr<arrow::RecordBatch>>& out);\n-bool HasAllColumns(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& schema);\n \n-std::pair<int, int> FindMinMaxPosition(const std::shared_ptr<arrow::Array>& column);\n-\n-std::shared_ptr<arrow::Scalar> DefaultScalar(const std::shared_ptr<arrow::DataType>& type);\n-std::shared_ptr<arrow::Scalar> MinScalar(const std::shared_ptr<arrow::DataType>& type);\n-std::shared_ptr<arrow::Scalar> GetScalar(const std::shared_ptr<arrow::Array>& array, int position);\n-bool IsGoodScalar(const std::shared_ptr<arrow::Scalar>& x);\n-int ScalarCompare(const arrow::Scalar& x, const arrow::Scalar& y);\n-int ScalarCompare(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y);\n-int ScalarCompareNullable(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y);\n-std::partial_ordering ColumnsCompare(const std::vector<std::shared_ptr<arrow::Array>>& x, const ui32 xRow, const std::vector<std::shared_ptr<arrow::Array>>& y, const ui32 yRow);\n-bool ScalarLess(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y);\n-bool ScalarLess(const arrow::Scalar& x, const arrow::Scalar& y);\n std::shared_ptr<arrow::RecordBatch> ReallocateBatch(std::shared_ptr<arrow::RecordBatch> original);\n-\n-bool HasNulls(const std::shared_ptr<arrow::Array>& column);\n-\n-std::vector<std::shared_ptr<arrow::RecordBatch>> SliceToRecordBatches(const std::shared_ptr<arrow::Table>& t);\n-\n-bool ArrayScalarsEqual(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs);\n-std::shared_ptr<arrow::Array> BoolVecToArray(const std::vector<bool>& vec);\n-\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 head, const ui32 tail);\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> batch, const ui32 head, const ui32 tail);\n-\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 position);\n-TString DebugString(std::shared_ptr<arrow::Array> array, const ui32 position);\n-NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> array, const ui32 position);\n+std::shared_ptr<arrow::Table> ReallocateBatch(const std::shared_ptr<arrow::Table>& original);\n \n }\ndiff --git a/ydb/core/formats/arrow/common/accessor.cpp b/ydb/core/formats/arrow/common/accessor.cpp\ndeleted file mode 100644\nindex 775cffa95bab..000000000000\n--- a/ydb/core/formats/arrow/common/accessor.cpp\n+++ /dev/null\n@@ -1,135 +0,0 @@\n-#include \"accessor.h\"\n-#include <ydb/core/formats/arrow/size_calcer.h>\n-#include <ydb/core/formats/arrow/switch/compare.h>\n-#include <ydb/core/formats/arrow/switch/switch_type.h>\n-#include <ydb/library/actors/core/log.h>\n-#include <ydb/core/formats/arrow/permutations.h>\n-#include <ydb/core/formats/arrow/arrow_helpers.h>\n-\n-namespace NKikimr::NArrow::NAccessor {\n-\n-void IChunkedArray::TReader::AppendPositionTo(arrow::ArrayBuilder& builder, const ui64 position, ui64* recordSize) const {\n-    auto address = GetReadChunk(position);\n-    AFL_VERIFY(NArrow::Append(builder, *address.GetArray(), address.GetPosition(), recordSize));\n-}\n-\n-std::shared_ptr<arrow::Array> IChunkedArray::TReader::CopyRecord(const ui64 recordIndex) const {\n-    auto address = GetReadChunk(recordIndex);\n-    return NArrow::CopyRecords(address.GetArray(), {address.GetPosition()});\n-}\n-\n-std::shared_ptr<arrow::ChunkedArray> IChunkedArray::Slice(const ui32 offset, const ui32 count) const {\n-    AFL_VERIFY(offset + count <= (ui64)GetRecordsCount())(\"offset\", offset)(\"count\", count)(\"length\", GetRecordsCount());\n-    ui32 currentOffset = offset;\n-    ui32 countLeast = count;\n-    std::vector<std::shared_ptr<arrow::Array>> chunks;\n-    auto address = GetChunk({}, offset);\n-    while (countLeast) {\n-        address = GetChunk(address, currentOffset);\n-        const ui64 internalPos = currentOffset - address.GetStartPosition();\n-        if (internalPos + countLeast <= (ui64)address.GetArray()->length()) {\n-            chunks.emplace_back(address.GetArray()->Slice(internalPos, countLeast));\n-            break;\n-        } else {\n-            const ui32 deltaCount = address.GetArray()->length() - internalPos;\n-            chunks.emplace_back(address.GetArray()->Slice(internalPos, deltaCount));\n-            AFL_VERIFY(countLeast >= deltaCount);\n-            countLeast -= deltaCount;\n-            currentOffset += deltaCount;\n-        }\n-    }\n-    return std::make_shared<arrow::ChunkedArray>(chunks, DataType);\n-}\n-\n-TString IChunkedArray::TReader::DebugString(const ui32 position) const {\n-    auto address = GetReadChunk(position);\n-    return NArrow::DebugString(address.GetArray(), address.GetPosition());\n-}\n-\n-std::partial_ordering IChunkedArray::TReader::CompareColumns(const std::vector<TReader>& l, const ui64 lPosition, const std::vector<TReader>& r, const ui64 rPosition) {\n-    AFL_VERIFY(l.size() == r.size());\n-    for (ui32 i = 0; i < l.size(); ++i) {\n-        const TAddress lAddress = l[i].GetReadChunk(lPosition);\n-        const TAddress rAddress = r[i].GetReadChunk(rPosition);\n-        auto cmp = lAddress.Compare(rAddress);\n-        if (std::is_neq(cmp)) {\n-            return cmp;\n-        }\n-    }\n-    return std::partial_ordering::equivalent;\n-}\n-\n-IChunkedArray::TAddress IChunkedArray::TReader::GetReadChunk(const ui64 position) const {\n-    AFL_VERIFY(position < ChunkedArray->GetRecordsCount());\n-    if (CurrentChunkAddress && position < CurrentChunkAddress->GetStartPosition() + CurrentChunkAddress->GetArray()->length() && CurrentChunkAddress->GetStartPosition() <= position) {\n-    } else {\n-        CurrentChunkAddress = ChunkedArray->DoGetChunk(CurrentChunkAddress, position);\n-    }\n-    return IChunkedArray::TAddress(CurrentChunkAddress->GetArray(), position - CurrentChunkAddress->GetStartPosition(), CurrentChunkAddress->GetChunkIndex());\n-}\n-\n-const std::partial_ordering IChunkedArray::TAddress::Compare(const TAddress& item) const {\n-    return TComparator::TypedCompare<true>(*Array, Position, *item.Array, item.Position);\n-}\n-\n-namespace {\n-class TChunkAccessor {\n-private:\n-    std::shared_ptr<arrow::ChunkedArray> ChunkedArray;\n-public:\n-    TChunkAccessor(const std::shared_ptr<arrow::ChunkedArray>& chunkedArray)\n-        : ChunkedArray(chunkedArray)\n-    {\n-\n-    }\n-    ui64 GetChunksCount() const {\n-        return (ui64)ChunkedArray->num_chunks();\n-    }\n-    ui64 GetChunkLength(const ui32 idx) const {\n-        return (ui64)ChunkedArray->chunk(idx)->length();\n-    }\n-    std::shared_ptr<arrow::Array> GetArray(const ui32 idx) const {\n-        return ChunkedArray->chunk(idx);\n-    }\n-};\n-\n-}\n-\n-std::optional<ui64> TTrivialArray::DoGetRawSize() const {\n-    return NArrow::GetArrayDataSize(Array);\n-}\n-\n-std::partial_ordering IChunkedArray::TCurrentChunkAddress::Compare(const ui64 position, const TCurrentChunkAddress& item, const ui64 itemPosition) const {\n-    AFL_VERIFY(StartPosition <= position);\n-    AFL_VERIFY(position < FinishPosition);\n-    AFL_VERIFY(item.StartPosition <= itemPosition);\n-    AFL_VERIFY(itemPosition < item.FinishPosition);\n-    return TComparator::TypedCompare<true>(*Array, position - StartPosition, *item.Array, itemPosition - item.StartPosition);\n-}\n-\n-std::shared_ptr<arrow::Array> IChunkedArray::TCurrentChunkAddress::CopyRecord(const ui64 recordIndex) const {\n-    AFL_VERIFY(StartPosition <= recordIndex);\n-    AFL_VERIFY(recordIndex < FinishPosition);\n-    return NArrow::CopyRecords(Array, { recordIndex - StartPosition });\n-}\n-\n-TString IChunkedArray::TCurrentChunkAddress::DebugString(const ui64 position) const {\n-    AFL_VERIFY(position < FinishPosition);\n-    AFL_VERIFY(StartPosition <= position);\n-    return NArrow::DebugString(Array, position - StartPosition);\n-}\n-\n-IChunkedArray::TCurrentChunkAddress TTrivialChunkedArray::DoGetChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position) const {\n-    TChunkAccessor accessor(Array);\n-    return SelectChunk(chunkCurrent, position, accessor);\n-}\n-\n-std::optional<ui64> TTrivialChunkedArray::DoGetRawSize() const {\n-    ui64 result = 0;\n-    for (auto&& i : Array->chunks()) {\n-        result += NArrow::GetArrayDataSize(i);\n-    }\n-    return result;\n-}\n-\n-}\ndiff --git a/ydb/core/formats/arrow/common/accessor.h b/ydb/core/formats/arrow/common/accessor.h\ndeleted file mode 100644\nindex 6021f47f5a88..000000000000\n--- a/ydb/core/formats/arrow/common/accessor.h\n+++ /dev/null\n@@ -1,227 +0,0 @@\n-#pragma once\n-#include <ydb/library/accessor/accessor.h>\n-#include <ydb/library/actors/core/log.h>\n-\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/chunked_array.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n-#include <util/system/types.h>\n-\n-namespace NKikimr::NArrow::NAccessor {\n-\n-class IChunkedArray {\n-public:\n-    enum class EType {\n-        Undefined,\n-        Array,\n-        ChunkedArray,\n-        SerializedChunkedArray\n-    };\n-\n-    class TCurrentChunkAddress {\n-    private:\n-        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);\n-        YDB_READONLY(ui64, StartPosition, 0);\n-        YDB_READONLY(ui64, FinishPosition, 0);\n-        YDB_READONLY(ui64, ChunkIndex, 0);\n-    public:\n-        TString DebugString(const ui64 position) const;\n-\n-        ui64 GetLength() const {\n-            return Array->length();\n-        }\n-\n-        bool Contains(const ui64 position) const {\n-            return position >= StartPosition && position < FinishPosition;\n-        }\n-\n-        std::shared_ptr<arrow::Array> CopyRecord(const ui64 recordIndex) const;\n-\n-        std::partial_ordering Compare(const ui64 position, const TCurrentChunkAddress& item, const ui64 itemPosition) const;\n-\n-        TCurrentChunkAddress(const std::shared_ptr<arrow::Array>& arr, const ui64 pos, const ui32 chunkIdx)\n-            : Array(arr)\n-            , StartPosition(pos)\n-            , ChunkIndex(chunkIdx)\n-        {\n-            AFL_VERIFY(arr);\n-            AFL_VERIFY(arr->length());\n-            FinishPosition = StartPosition + arr->length();\n-        }\n-\n-        TString DebugString() const {\n-            return TStringBuilder()\n-                << \"start=\" << StartPosition << \";\"\n-                << \"chunk_index=\" << ChunkIndex << \";\"\n-                << \"length=\" << Array->length() << \";\";\n-        }\n-    };\n-\n-    class TAddress {\n-    private:\n-        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);\n-        YDB_READONLY(ui64, Position, 0);\n-        YDB_READONLY(ui64, ChunkIdx, 0);\n-    public:\n-        bool NextPosition() {\n-            if (Position + 1 < (ui32)Array->length()) {\n-                ++Position;\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        TAddress(const std::shared_ptr<arrow::Array>& arr, const ui64 position, const ui64 chunkIdx)\n-            : Array(arr)\n-            , Position(position)\n-            , ChunkIdx(chunkIdx)\n-        {\n-\n-        }\n-\n-        const std::partial_ordering Compare(const TAddress& item) const;\n-    };\n-private:\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::DataType>, DataType);\n-    YDB_READONLY(ui64, RecordsCount, 0);\n-    YDB_READONLY(EType, Type, EType::Undefined);\n-    virtual std::optional<ui64> DoGetRawSize() const = 0;\n-protected:\n-    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const = 0;\n-    virtual TCurrentChunkAddress DoGetChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position) const = 0;\n-\n-    template <class TChunkAccessor>\n-    TCurrentChunkAddress SelectChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position, const TChunkAccessor& accessor) const {\n-        if (!chunkCurrent || position >= chunkCurrent->GetStartPosition()) {\n-            ui32 startIndex = 0;\n-            ui64 idx = 0;\n-            if (chunkCurrent) {\n-                if (position < chunkCurrent->GetFinishPosition()) {\n-                    return *chunkCurrent;\n-                }\n-                AFL_VERIFY(chunkCurrent->GetChunkIndex() < accessor.GetChunksCount());\n-                startIndex = chunkCurrent->GetChunkIndex();\n-                idx = chunkCurrent->GetStartPosition();\n-            }\n-            for (ui32 i = startIndex; i < accessor.GetChunksCount(); ++i) {\n-                const ui64 nextIdx = idx + accessor.GetChunkLength(i);\n-                if (idx <= position && position < nextIdx) {\n-                    return TCurrentChunkAddress(accessor.GetArray(i), idx, i);\n-                }\n-                idx = nextIdx;\n-            }\n-        } else {\n-            AFL_VERIFY(chunkCurrent->GetChunkIndex() > 0);\n-            ui64 idx = chunkCurrent->GetStartPosition();\n-            for (i32 i = chunkCurrent->GetChunkIndex() - 1; i >= 0; --i) {\n-                AFL_VERIFY(idx >= accessor.GetChunkLength(i))(\"idx\", idx)(\"length\", accessor.GetChunkLength(i));\n-                const ui64 nextIdx = idx - accessor.GetChunkLength(i);\n-                if (nextIdx <= position && position < idx) {\n-                    return TCurrentChunkAddress(accessor.GetArray(i), nextIdx, i);\n-                }\n-                idx = nextIdx;\n-            }\n-        }\n-        TStringBuilder sb;\n-        ui64 recordsCountChunks = 0;\n-        for (ui32 i = 0; i < accessor.GetChunksCount(); ++i) {\n-            sb << accessor.GetChunkLength(i) << \",\";\n-            recordsCountChunks += accessor.GetChunkLength(i);\n-        }\n-        TStringBuilder chunkCurrentInfo;\n-        if (chunkCurrent) {\n-            chunkCurrentInfo << chunkCurrent->DebugString();\n-        }\n-        AFL_VERIFY(recordsCountChunks == GetRecordsCount())(\"pos\", position)(\"count\", GetRecordsCount())(\"chunks_map\", sb)(\"chunk_current\", chunkCurrentInfo);\n-        AFL_VERIFY(false)(\"pos\", position)(\"count\", GetRecordsCount())(\"chunks_map\", sb)(\"chunk_current\", chunkCurrentInfo);\n-        return TCurrentChunkAddress(nullptr, 0, 0);\n-    }\n-\n-public:\n-\n-    class TReader {\n-    private:\n-        std::shared_ptr<IChunkedArray> ChunkedArray;\n-        mutable std::optional<TCurrentChunkAddress> CurrentChunkAddress;\n-    public:\n-        TReader(const std::shared_ptr<IChunkedArray>& data)\n-            : ChunkedArray(data)\n-        {\n-            AFL_VERIFY(ChunkedArray);\n-        }\n-\n-        ui64 GetRecordsCount() const {\n-            return ChunkedArray->GetRecordsCount();\n-        }\n-\n-        TAddress GetReadChunk(const ui64 position) const;\n-        static std::partial_ordering CompareColumns(const std::vector<TReader>& l, const ui64 lPosition, const std::vector<TReader>& r, const ui64 rPosition);\n-        void AppendPositionTo(arrow::ArrayBuilder& builder, const ui64 position, ui64* recordSize) const;\n-        std::shared_ptr<arrow::Array> CopyRecord(const ui64 recordIndex) const;\n-        TString DebugString(const ui32 position) const;\n-    };\n-\n-    std::optional<ui64> GetRawSize() const {\n-        return DoGetRawSize();\n-    }\n-\n-    std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const {\n-        return DoGetChunkedArray();\n-    }\n-    virtual ~IChunkedArray() = default;\n-\n-    std::shared_ptr<arrow::ChunkedArray> Slice(const ui32 offset, const ui32 count) const;\n-\n-    TCurrentChunkAddress GetChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position) const {\n-        return DoGetChunk(chunkCurrent, position);\n-    }\n-\n-    IChunkedArray(const ui64 recordsCount, const EType type, const std::shared_ptr<arrow::DataType>& dataType)\n-        : DataType(dataType)\n-        , RecordsCount(recordsCount)\n-        , Type(type) {\n-\n-    }\n-};\n-\n-class TTrivialArray: public IChunkedArray {\n-private:\n-    using TBase = IChunkedArray;\n-    const std::shared_ptr<arrow::Array> Array;\n-protected:\n-    virtual std::optional<ui64> DoGetRawSize() const override;\n-\n-    virtual TCurrentChunkAddress DoGetChunk(const std::optional<TCurrentChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {\n-        return TCurrentChunkAddress(Array, 0, 0);\n-    }\n-    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n-        return std::make_shared<arrow::ChunkedArray>(Array);\n-    }\n-\n-public:\n-    TTrivialArray(const std::shared_ptr<arrow::Array>& data)\n-        : TBase(data->length(), EType::Array, data->type())\n-        , Array(data) {\n-\n-    }\n-};\n-\n-class TTrivialChunkedArray: public IChunkedArray {\n-private:\n-    using TBase = IChunkedArray;\n-    const std::shared_ptr<arrow::ChunkedArray> Array;\n-protected:\n-    virtual TCurrentChunkAddress DoGetChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position) const override;\n-    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n-        return Array;\n-    }\n-    virtual std::optional<ui64> DoGetRawSize() const override;\n-\n-public:\n-    TTrivialChunkedArray(const std::shared_ptr<arrow::ChunkedArray>& data)\n-        : TBase(data->length(), EType::ChunkedArray, data->type())\n-        , Array(data) {\n-\n-    }\n-};\n-\n-}\ndiff --git a/ydb/core/formats/arrow/common/adapter.h b/ydb/core/formats/arrow/common/adapter.h\nindex 1b368e38de50..18b2deeacc9b 100644\n--- a/ydb/core/formats/arrow/common/adapter.h\n+++ b/ydb/core/formats/arrow/common/adapter.h\n@@ -1,18 +1,19 @@\n #pragma once\n #include \"container.h\"\n-#include \"accessor.h\"\n-#include \"validation.h\"\n \n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n+\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <ydb/library/yverify_stream/yverify_stream.h>\n \n-#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_primitive.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/chunked_array.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api_vector.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/datum.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/table.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/datum.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api_vector.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_primitive.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \n namespace NKikimr::NArrow::NAdapter {\n \n@@ -27,7 +28,8 @@ class TDataBuilderPolicy<arrow::RecordBatch> {\n     using TColumn = arrow::Array;\n     using TAccessor = NAccessor::TTrivialArray;\n \n-    [[nodiscard]] static std::shared_ptr<arrow::RecordBatch> AddColumn(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& extCol) {\n+    [[nodiscard]] static std::shared_ptr<arrow::RecordBatch> AddColumn(const std::shared_ptr<arrow::RecordBatch>& batch,\n+        const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& extCol) {\n         return TStatusValidator::GetValid(batch->AddColumn(batch->num_columns(), field, extCol));\n     }\n \n@@ -37,7 +39,8 @@ class TDataBuilderPolicy<arrow::RecordBatch> {\n     [[nodiscard]] static std::shared_ptr<arrow::RecordBatch> Build(const std::shared_ptr<arrow::Schema>& schema, std::vector<std::shared_ptr<TColumn>>&& columns, const ui32 count) {\n         return arrow::RecordBatch::Make(schema, count, std::move(columns));\n     }\n-    [[nodiscard]] static std::shared_ptr<arrow::RecordBatch> ApplyArrowFilter(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::BooleanArray>& filter) {\n+    [[nodiscard]] static std::shared_ptr<arrow::RecordBatch> ApplyArrowFilter(\n+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::BooleanArray>& filter) {\n         auto res = arrow::compute::Filter(batch, filter);\n         Y_VERIFY_S(res.ok(), res.status().message());\n         Y_ABORT_UNLESS(res->kind() == arrow::Datum::RECORD_BATCH);\n@@ -46,7 +49,6 @@ class TDataBuilderPolicy<arrow::RecordBatch> {\n     [[nodiscard]] static std::shared_ptr<arrow::RecordBatch> GetEmptySame(const std::shared_ptr<arrow::RecordBatch>& batch) {\n         return batch->Slice(0, 0);\n     }\n-\n };\n \n template <>\n@@ -60,11 +62,13 @@ class TDataBuilderPolicy<arrow::Table> {\n     [[nodiscard]] static std::shared_ptr<arrow::Table> Build(const std::shared_ptr<arrow::Schema>& schema, std::vector<std::shared_ptr<TColumn>>&& columns, const ui32 count) {\n         return arrow::Table::Make(schema, std::move(columns), count);\n     }\n-    [[nodiscard]] static std::shared_ptr<arrow::Table> AddColumn(const std::shared_ptr<arrow::Table>& batch, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& extCol) {\n+    [[nodiscard]] static std::shared_ptr<arrow::Table> AddColumn(\n+        const std::shared_ptr<arrow::Table>& batch, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& extCol) {\n         return TStatusValidator::GetValid(batch->AddColumn(batch->num_columns(), field, std::make_shared<arrow::ChunkedArray>(extCol)));\n     }\n \n-    [[nodiscard]] static std::shared_ptr<arrow::Table> ApplyArrowFilter(const std::shared_ptr<arrow::Table>& batch, const std::shared_ptr<arrow::BooleanArray>& filter) {\n+    [[nodiscard]] static std::shared_ptr<arrow::Table> ApplyArrowFilter(\n+        const std::shared_ptr<arrow::Table>& batch, const std::shared_ptr<arrow::BooleanArray>& filter) {\n         auto res = arrow::compute::Filter(batch, filter);\n         Y_VERIFY_S(res.ok(), res.status().message());\n         Y_ABORT_UNLESS(res->kind() == arrow::Datum::TABLE);\n@@ -86,11 +90,13 @@ class TDataBuilderPolicy<TGeneralContainer> {\n         }\n         return std::make_shared<TGeneralContainer>(std::make_shared<arrow::Schema>(std::move(fields)), std::move(columns));\n     }\n-    [[nodiscard]] static std::shared_ptr<TGeneralContainer> AddColumn(const std::shared_ptr<TGeneralContainer>& batch, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& extCol) {\n+    [[nodiscard]] static std::shared_ptr<TGeneralContainer> AddColumn(const std::shared_ptr<TGeneralContainer>& batch,\n+        const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& extCol) {\n         batch->AddField(field, std::make_shared<NAccessor::TTrivialArray>(extCol)).Validate();\n         return batch;\n     }\n-    [[nodiscard]] static std::shared_ptr<TGeneralContainer> ApplyArrowFilter(const std::shared_ptr<TGeneralContainer>& batch, const std::shared_ptr<arrow::BooleanArray>& filter) {\n+    [[nodiscard]] static std::shared_ptr<TGeneralContainer> ApplyArrowFilter(\n+        const std::shared_ptr<TGeneralContainer>& batch, const std::shared_ptr<arrow::BooleanArray>& filter) {\n         auto table = batch->BuildTableVerified();\n         return std::make_shared<TGeneralContainer>(TDataBuilderPolicy<arrow::Table>::ApplyArrowFilter(table, filter));\n     }\n@@ -99,4 +105,4 @@ class TDataBuilderPolicy<TGeneralContainer> {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NArrow::NAdapter\ndiff --git a/ydb/core/formats/arrow/common/container.cpp b/ydb/core/formats/arrow/common/container.cpp\nindex 57c79ed57114..7b159f2eef06 100644\n--- a/ydb/core/formats/arrow/common/container.cpp\n+++ b/ydb/core/formats/arrow/common/container.cpp\n@@ -1,8 +1,11 @@\n #include \"container.h\"\n-#include <ydb/library/actors/core/log.h>\n+\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n-#include <ydb/library/accessor/validator.h>\n+\n+#include <ydb/library/actors/core/log.h>\n+#include <ydb/library/formats/arrow/common/vector_operations.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n \n namespace NKikimr::NArrow {\n \n@@ -14,8 +17,9 @@ TConclusionStatus TGeneralContainer::MergeColumnsStrictly(const TGeneralContaine\n         RecordsCount = container.RecordsCount;\n     }\n     if (*RecordsCount != *container.RecordsCount) {\n-        return TConclusionStatus::Fail(TStringBuilder() << \"inconsistency records count in additional container: \" <<\n-            container.GetSchema()->ToString() << \". expected: \" << RecordsCount << \", reality: \" << container.GetRecordsCount());\n+        return TConclusionStatus::Fail(TStringBuilder()\n+                                       << \"inconsistency records count in additional container: \" << container.GetSchema()->ToString()\n+                                       << \". expected: \" << RecordsCount << \", reality: \" << container.GetRecordsCount());\n     }\n     for (i32 i = 0; i < container.Schema->num_fields(); ++i) {\n         auto addFieldResult = AddField(container.Schema->field(i), container.Columns[i]);\n@@ -30,11 +34,12 @@ TConclusionStatus TGeneralContainer::AddField(const std::shared_ptr<arrow::Field\n     AFL_VERIFY(f);\n     AFL_VERIFY(data);\n     if (RecordsCount && data->GetRecordsCount() != *RecordsCount) {\n-        return TConclusionStatus::Fail(TStringBuilder() << \"inconsistency records count in new column: \" <<\n-            f->name() << \". expected: \" << RecordsCount << \", reality: \" << data->GetRecordsCount());\n+        return TConclusionStatus::Fail(TStringBuilder() << \"inconsistency records count in new column: \" << f->name()\n+                                                        << \". expected: \" << RecordsCount << \", reality: \" << data->GetRecordsCount());\n     }\n     if (!data->GetDataType()->Equals(f->type())) {\n-        return TConclusionStatus::Fail(\"schema and data type are not equals: \" + data->GetDataType()->ToString() + \" vs \" + f->type()->ToString());\n+        return TConclusionStatus::Fail(\n+            \"schema and data type are not equals: \" + data->GetDataType()->ToString() + \" vs \" + f->type()->ToString());\n     }\n     {\n         auto conclusion = Schema->AddField(f);\n@@ -55,6 +60,11 @@ TConclusionStatus TGeneralContainer::AddField(const std::shared_ptr<arrow::Field\n     return AddField(f, std::make_shared<NAccessor::TTrivialArray>(data));\n }\n \n+void TGeneralContainer::DeleteFieldsByIndex(const std::vector<ui32>& idxs) {\n+    Schema->DeleteFieldsByIndex(idxs);\n+    NUtil::EraseItems(Columns, idxs);\n+}\n+\n void TGeneralContainer::Initialize() {\n     std::optional<ui64> recordsCount;\n     AFL_VERIFY(Schema->num_fields() == (i32)Columns.size())(\"schema\", Schema->num_fields())(\"columns\", Columns.size());\n@@ -65,7 +75,8 @@ void TGeneralContainer::Initialize() {\n             recordsCount = Columns[i]->GetRecordsCount();\n         } else {\n             AFL_VERIFY(*recordsCount == Columns[i]->GetRecordsCount())\n-                (\"event\", \"inconsistency_records_count\")(\"expect\", *recordsCount)(\"real\", Columns[i]->GetRecordsCount())(\"field_name\", Schema->field(i)->name());\n+            (\"event\", \"inconsistency_records_count\")(\"expect\", *recordsCount)(\"real\", Columns[i]->GetRecordsCount())(\n+                \"field_name\", Schema->field(i)->name());\n         }\n     }\n     AFL_VERIFY(recordsCount);\n@@ -73,24 +84,24 @@ void TGeneralContainer::Initialize() {\n     RecordsCount = *recordsCount;\n }\n \n-TGeneralContainer::TGeneralContainer(const std::vector<std::shared_ptr<arrow::Field>>& fields, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns)\n+TGeneralContainer::TGeneralContainer(\n+    const std::vector<std::shared_ptr<arrow::Field>>& fields, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns)\n     : Schema(std::make_shared<NModifier::TSchema>(fields))\n-    , Columns(std::move(columns))\n-{\n+    , Columns(std::move(columns)) {\n     Initialize();\n }\n \n-TGeneralContainer::TGeneralContainer(const std::shared_ptr<NModifier::TSchema>& schema, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns)\n+TGeneralContainer::TGeneralContainer(\n+    const std::shared_ptr<NModifier::TSchema>& schema, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns)\n     : Schema(std::make_shared<NModifier::TSchema>(schema))\n-    , Columns(std::move(columns))\n-{\n+    , Columns(std::move(columns)) {\n     Initialize();\n }\n \n-TGeneralContainer::TGeneralContainer(const std::shared_ptr<arrow::Schema>& schema, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns)\n+TGeneralContainer::TGeneralContainer(\n+    const std::shared_ptr<arrow::Schema>& schema, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns)\n     : Schema(std::make_shared<NModifier::TSchema>(schema))\n-    , Columns(std::move(columns))\n-{\n+    , Columns(std::move(columns)) {\n     Initialize();\n }\n \n@@ -170,7 +181,8 @@ std::shared_ptr<NArrow::NAccessor::IChunkedArray> TGeneralContainer::GetAccessor\n     return Columns[idx];\n }\n \n-TConclusionStatus TGeneralContainer::SyncSchemaTo(const std::shared_ptr<arrow::Schema>& schema, const IFieldsConstructor* defaultFieldsConstructor, const bool forceDefaults) {\n+TConclusionStatus TGeneralContainer::SyncSchemaTo(\n+    const std::shared_ptr<arrow::Schema>& schema, const IFieldsConstructor* defaultFieldsConstructor, const bool forceDefaults) {\n     std::shared_ptr<NModifier::TSchema> schemaNew = std::make_shared<NModifier::TSchema>();\n     std::vector<std::shared_ptr<NAccessor::IChunkedArray>> columnsNew;\n     if (!RecordsCount) {\n@@ -187,12 +199,14 @@ TConclusionStatus TGeneralContainer::SyncSchemaTo(const std::shared_ptr<arrow::S\n                 if (defConclusion.IsFail()) {\n                     return defConclusion;\n                 }\n-                columnsNew.emplace_back(std::make_shared<NAccessor::TTrivialArray>(NArrow::TThreadSimpleArraysCache::Get(i->type(), *defConclusion, *RecordsCount)));\n+                columnsNew.emplace_back(\n+                    std::make_shared<NAccessor::TTrivialArray>(NArrow::TThreadSimpleArraysCache::Get(i->type(), *defConclusion, *RecordsCount)));\n             }\n         } else {\n             const auto& fOwned = Schema->GetFieldVerified(idx);\n             if (!fOwned->type()->Equals(i->type())) {\n-                return TConclusionStatus::Fail(\"different field types for '\" + i->name() + \"'. Have \" + fOwned->type()->ToString() + \", need \" + i->type()->ToString());\n+                return TConclusionStatus::Fail(\n+                    \"different field types for '\" + i->name() + \"'. Have \" + fOwned->type()->ToString() + \", need \" + i->type()->ToString());\n             }\n             schemaNew->AddField(fOwned).Validate();\n             columnsNew.emplace_back(Columns[idx]);\n@@ -212,7 +226,8 @@ TString TGeneralContainer::DebugString() const {\n     return result;\n }\n \n-TConclusion<std::shared_ptr<arrow::Scalar>> IFieldsConstructor::GetDefaultColumnElementValue(const std::shared_ptr<arrow::Field>& field, const bool force) const {\n+TConclusion<std::shared_ptr<arrow::Scalar>> IFieldsConstructor::GetDefaultColumnElementValue(\n+    const std::shared_ptr<arrow::Field>& field, const bool force) const {\n     AFL_VERIFY(field);\n     auto result = DoGetDefaultColumnElementValue(field->name());\n     if (result) {\n@@ -224,4 +239,4 @@ TConclusion<std::shared_ptr<arrow::Scalar>> IFieldsConstructor::GetDefaultColumn\n     return TConclusionStatus::Fail(\"have not default value for column \" + field->name());\n }\n \n-}\n+}   // namespace NKikimr::NArrow\ndiff --git a/ydb/core/formats/arrow/common/container.h b/ydb/core/formats/arrow/common/container.h\nindex aa15c6740741..dacd5d62c0b0 100644\n--- a/ydb/core/formats/arrow/common/container.h\n+++ b/ydb/core/formats/arrow/common/container.h\n@@ -1,11 +1,10 @@\n #pragma once\n-#include \"accessor.h\"\n-\n-#include <ydb/core/formats/arrow/modifier/schema.h>\n \n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/conclusion/result.h>\n #include <ydb/library/conclusion/status.h>\n+#include <ydb/library/formats/arrow/modifier/schema.h>\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/table.h>\n@@ -74,6 +73,8 @@ class TGeneralContainer {\n \n     [[nodiscard]] TConclusionStatus AddField(const std::shared_ptr<arrow::Field>& f, const std::shared_ptr<arrow::ChunkedArray>& data);\n \n+    void DeleteFieldsByIndex(const std::vector<ui32>& idxs);\n+\n     TGeneralContainer(const std::shared_ptr<arrow::Table>& table);\n     TGeneralContainer(const std::shared_ptr<arrow::RecordBatch>& table);\n     TGeneralContainer(const std::shared_ptr<arrow::Schema>& schema, std::vector<std::shared_ptr<NAccessor::IChunkedArray>>&& columns);\ndiff --git a/ydb/core/formats/arrow/common/ya.make b/ydb/core/formats/arrow/common/ya.make\nindex 61f742b09b76..fc34c380aeb0 100644\n--- a/ydb/core/formats/arrow/common/ya.make\n+++ b/ydb/core/formats/arrow/common/ya.make\n@@ -5,13 +5,13 @@ PEERDIR(\n     ydb/core/formats/arrow/switch\n     ydb/library/actors/core\n     ydb/library/conclusion\n+    ydb/library/formats/arrow\n+    ydb/core/formats/arrow/splitter\n )\n \n SRCS(\n     container.cpp\n-    validation.cpp\n     adapter.cpp\n-    accessor.cpp\n )\n \n END()\ndiff --git a/ydb/core/formats/arrow/converter.cpp b/ydb/core/formats/arrow/converter.cpp\nindex 1bd0c92e2ceb..f0a38e2c8149 100644\n--- a/ydb/core/formats/arrow/converter.cpp\n+++ b/ydb/core/formats/arrow/converter.cpp\n@@ -1,5 +1,5 @@\n #include \"converter.h\"\n-#include \"switch_type.h\"\n+#include \"switch/switch_type.h\"\n \n #include <ydb/library/binary_json/read.h>\n #include <ydb/library/binary_json/write.h>\ndiff --git a/ydb/core/formats/arrow/custom_registry.cpp b/ydb/core/formats/arrow/custom_registry.cpp\nindex 13e8dc6150a3..9d61c8bf6476 100644\n--- a/ydb/core/formats/arrow/custom_registry.cpp\n+++ b/ydb/core/formats/arrow/custom_registry.cpp\n@@ -13,6 +13,7 @@\n #include <AggregateFunctions/AggregateFunctionMinMaxAny.h>\n #include <AggregateFunctions/AggregateFunctionSum.h>\n #include <AggregateFunctions/AggregateFunctionAvg.h>\n+#include <AggregateFunctions/AggregateFunctionNumRows.h>\n #endif\n \n namespace cp = ::arrow::compute;\n@@ -62,6 +63,10 @@ static void RegisterYdbCast(cp::FunctionRegistry* registry) {\n     Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<YdbCastMetaFunction>()).ok());\n }\n \n+static void RegisterCustomAggregates(cp::FunctionRegistry* registry) {\n+    Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<TNumRows>(GetFunctionName(EAggregate::NumRows))).ok());\n+}\n+\n static void RegisterHouseAggregates(cp::FunctionRegistry* registry) {\n #ifndef WIN32\n     try {\n@@ -71,6 +76,7 @@ static void RegisterHouseAggregates(cp::FunctionRegistry* registry) {\n         Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<CH::WrappedMax>(GetHouseFunctionName(EAggregate::Max))).ok());\n         Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<CH::WrappedSum>(GetHouseFunctionName(EAggregate::Sum))).ok());\n         //Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<CH::WrappedAvg>(GetHouseFunctionName(EAggregate::Avg))).ok());\n+        Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<CH::WrappedNumRows>(GetHouseFunctionName(EAggregate::NumRows))).ok());\n \n         Y_ABORT_UNLESS(registry->AddFunction(std::make_shared<CH::ArrowGroupBy>(GetHouseGroupByName())).ok());\n     } catch (const std::exception& /*ex*/) {\n@@ -88,6 +94,7 @@ static std::unique_ptr<cp::FunctionRegistry> CreateCustomRegistry() {\n     RegisterRound(registry.get());\n     RegisterArithmetic(registry.get());\n     RegisterYdbCast(registry.get());\n+    RegisterCustomAggregates(registry.get());\n     RegisterHouseAggregates(registry.get());\n     return registry;\n }\ndiff --git a/ydb/core/formats/arrow/dictionary/conversion.cpp b/ydb/core/formats/arrow/dictionary/conversion.cpp\nindex 026ae6ba5d6e..b1decbf14bb6 100644\n--- a/ydb/core/formats/arrow/dictionary/conversion.cpp\n+++ b/ydb/core/formats/arrow/dictionary/conversion.cpp\n@@ -1,8 +1,8 @@\n #include \"conversion.h\"\n #include <ydb/core/formats/arrow/switch/switch_type.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n #include <ydb/core/formats/arrow/size_calcer.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n \n namespace NKikimr::NArrow {\n \n@@ -131,11 +131,4 @@ bool IsDictionableArray(const std::shared_ptr<arrow::Array>& data) {\n     return result;\n }\n \n-ui64 GetDictionarySize(const std::shared_ptr<arrow::DictionaryArray>& data) {\n-    if (!data) {\n-        return 0;\n-    }\n-    return GetArrayDataSize(data->dictionary()) + GetArrayDataSize(data->indices());\n-}\n-\n }\ndiff --git a/ydb/core/formats/arrow/dictionary/conversion.h b/ydb/core/formats/arrow/dictionary/conversion.h\nindex ee044bfd514b..dfedb4aa31a0 100644\n--- a/ydb/core/formats/arrow/dictionary/conversion.h\n+++ b/ydb/core/formats/arrow/dictionary/conversion.h\n@@ -7,7 +7,6 @@\n namespace NKikimr::NArrow {\n \n bool IsDictionableArray(const std::shared_ptr<arrow::Array>& data);\n-ui64 GetDictionarySize(const std::shared_ptr<arrow::DictionaryArray>& data);\n std::shared_ptr<arrow::DictionaryArray> ArrayToDictionary(const std::shared_ptr<arrow::Array>& data);\n std::shared_ptr<arrow::RecordBatch> ArrayToDictionary(const std::shared_ptr<arrow::RecordBatch>& data);\n std::shared_ptr<arrow::Array> DictionaryToArray(const std::shared_ptr<arrow::DictionaryArray>& data);\ndiff --git a/ydb/core/formats/arrow/dictionary/object.cpp b/ydb/core/formats/arrow/dictionary/object.cpp\nindex 4a72802b2aec..36c9fe3fc276 100644\n--- a/ydb/core/formats/arrow/dictionary/object.cpp\n+++ b/ydb/core/formats/arrow/dictionary/object.cpp\n@@ -1,6 +1,6 @@\n #include \"object.h\"\n-#include <ydb/core/formats/arrow/common/validation.h>\n #include <ydb/core/formats/arrow/transformer/dictionary.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <util/string/builder.h>\n \n namespace NKikimr::NArrow::NDictionary {\ndiff --git a/ydb/core/formats/arrow/dictionary/object.h b/ydb/core/formats/arrow/dictionary/object.h\nindex 2fd4d6a12924..09f5efebb56f 100644\n--- a/ydb/core/formats/arrow/dictionary/object.h\n+++ b/ydb/core/formats/arrow/dictionary/object.h\n@@ -3,7 +3,7 @@\n #include <ydb/library/conclusion/result.h>\n #include <ydb/core/protos/flat_scheme_op.pb.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/util/compression.h>\n-#include <ydb/core/formats/arrow/transformer/abstract.h>\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n \n namespace NKikimr::NArrow::NDictionary {\n \ndiff --git a/ydb/core/formats/arrow/dictionary/ya.make b/ydb/core/formats/arrow/dictionary/ya.make\nindex ea71f4c7dacf..35639ea43bea 100644\n--- a/ydb/core/formats/arrow/dictionary/ya.make\n+++ b/ydb/core/formats/arrow/dictionary/ya.make\n@@ -3,9 +3,11 @@ LIBRARY()\n PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/core/protos\n-    ydb/core/formats/arrow/simple_builder\n     ydb/core/formats/arrow/switch\n     ydb/library/actors/core\n+    ydb/library/formats/arrow/transformer\n+    ydb/library/formats/arrow/common\n+    ydb/library/formats/arrow/simple_builder\n )\n \n SRCS(\ndiff --git a/ydb/core/formats/arrow/hash/calcer.cpp b/ydb/core/formats/arrow/hash/calcer.cpp\nindex 71af0492cfea..d5fa4a8dd6a3 100644\n--- a/ydb/core/formats/arrow/hash/calcer.cpp\n+++ b/ydb/core/formats/arrow/hash/calcer.cpp\n@@ -1,8 +1,8 @@\n #include \"calcer.h\"\n-#include \"xx_hash.h\"\n #include <ydb/core/formats/arrow/switch/switch_type.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n #include <ydb/library/services/services.pb.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type_traits.h>\n #include <ydb/library/actors/core/log.h>\n #include <util/string/join.h>\ndiff --git a/ydb/core/formats/arrow/hash/calcer.h b/ydb/core/formats/arrow/hash/calcer.h\nindex d82f669fbee1..51dfe7858f8c 100644\n--- a/ydb/core/formats/arrow/hash/calcer.h\n+++ b/ydb/core/formats/arrow/hash/calcer.h\n@@ -1,11 +1,11 @@\n #pragma once\n-#include \"xx_hash.h\"\n #include <ydb/core/formats/arrow/common/adapter.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n #include <ydb/core/formats/arrow/reader/position.h>\n \n #include <ydb/library/actors/core/log.h>\n #include <ydb/library/services/services.pb.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\ndiff --git a/ydb/core/formats/arrow/hash/ya.make b/ydb/core/formats/arrow/hash/ya.make\nindex 6d9a98b836a6..d7337f6b5588 100644\n--- a/ydb/core/formats/arrow/hash/ya.make\n+++ b/ydb/core/formats/arrow/hash/ya.make\n@@ -2,17 +2,18 @@ LIBRARY()\n \n PEERDIR(\n     contrib/libs/apache/arrow\n-    ydb/core/formats/arrow/simple_builder\n     ydb/core/formats/arrow/switch\n     ydb/core/formats/arrow/reader\n     ydb/library/actors/core\n     ydb/library/services\n     ydb/library/actors/protos\n+    ydb/library/formats/arrow/hash\n+    ydb/library/formats/arrow/common\n+    ydb/library/formats/arrow/simple_builder\n )\n \n SRCS(\n     calcer.cpp\n-    xx_hash.cpp\n )\n \n END()\ndiff --git a/ydb/core/formats/arrow/modifier/schema.h b/ydb/core/formats/arrow/modifier/schema.h\ndeleted file mode 100644\nindex dc663bad9f6a..000000000000\n--- a/ydb/core/formats/arrow/modifier/schema.h\n+++ /dev/null\n@@ -1,55 +0,0 @@\n-#pragma once\n-#include <ydb/library/conclusion/status.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n-#include <util/generic/hash.h>\n-\n-namespace NKikimr::NArrow::NModifier {\n-class TSchema {\n-private:\n-    bool Initialized = false;\n-    THashMap<std::string, ui32> IndexByName;\n-    std::vector<std::shared_ptr<arrow::Field>> Fields;\n-    bool Finished = false;\n-\n-    void Initialize(const std::vector<std::shared_ptr<arrow::Field>>& fields);\n-public:\n-    TSchema() = default;\n-    TSchema(const std::shared_ptr<TSchema>& schema);\n-\n-    TSchema(const std::shared_ptr<arrow::Schema>& schema);\n-\n-    TSchema(const std::vector<std::shared_ptr<arrow::Field>>& fields) {\n-        Initialize(fields);\n-    }\n-\n-    i32 GetFieldIndex(const std::string& fName) const {\n-        auto it = IndexByName.find(fName);\n-        if (it == IndexByName.end()) {\n-            return -1;\n-        }\n-        return it->second;\n-    }\n-\n-    const std::vector<std::shared_ptr<arrow::Field>>& GetFields() const {\n-        return Fields;\n-    }\n-\n-    TString ToString() const;\n-\n-    std::shared_ptr<arrow::Schema> Finish();\n-    [[nodiscard]] TConclusionStatus AddField(const std::shared_ptr<arrow::Field>& f);\n-    const std::shared_ptr<arrow::Field>& GetFieldByName(const std::string& name) const;\n-\n-    bool HasField(const std::string& name) const {\n-        return IndexByName.contains(name);\n-    }\n-\n-    i32 num_fields() const {\n-        return Fields.size();\n-    }\n-\n-    const std::shared_ptr<arrow::Field>& GetFieldVerified(const ui32 index) const;\n-\n-    const std::shared_ptr<arrow::Field>& field(const ui32 index) const;\n-};\n-}\n\\ No newline at end of file\ndiff --git a/ydb/core/formats/arrow/permutations.cpp b/ydb/core/formats/arrow/permutations.cpp\nindex 623bc15c9221..c36a09779c6d 100644\n--- a/ydb/core/formats/arrow/permutations.cpp\n+++ b/ydb/core/formats/arrow/permutations.cpp\n@@ -1,13 +1,13 @@\n #include \"permutations.h\"\n \n #include \"arrow_helpers.h\"\n-#include \"replace_key.h\"\n #include \"size_calcer.h\"\n #include \"hash/calcer.h\"\n \n-#include <ydb/core/formats/arrow/common/validation.h>\n #include <ydb/library/services/services.pb.h>\n \n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/library/actors/core/log.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_primitive.h>\n@@ -15,28 +15,6 @@\n \n namespace NKikimr::NArrow {\n \n-std::shared_ptr<arrow::UInt64Array> MakePermutation(const int size, const bool reverse) {\n-    arrow::UInt64Builder builder;\n-    TStatusValidator::Validate(builder.Reserve(size));\n-\n-    if (size) {\n-        if (reverse) {\n-            ui64 value = size - 1;\n-            for (i64 i = 0; i < size; ++i, --value) {\n-                TStatusValidator::Validate(builder.Append(value));\n-            }\n-        } else {\n-            for (i64 i = 0; i < size; ++i) {\n-                TStatusValidator::Validate(builder.Append(i));\n-            }\n-        }\n-    }\n-\n-    std::shared_ptr<arrow::UInt64Array> out;\n-    TStatusValidator::Validate(builder.Finish(&out));\n-    return out;\n-}\n-\n std::shared_ptr<arrow::UInt64Array> MakeSortPermutation(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& sortingKey, const bool andUnique) {\n     auto keyBatch = TColumnOperator().VerifyIfAbsent().Adapt(batch, sortingKey).DetachResult();\n     auto keyColumns = std::make_shared<TArrayVec>(keyBatch->columns());\n@@ -100,84 +78,6 @@ std::shared_ptr<arrow::UInt64Array> MakeSortPermutation(const std::shared_ptr<ar\n     return out;\n }\n \n-template <class TIndex>\n-std::shared_ptr<arrow::UInt64Array> MakeFilterPermutationImpl(const std::vector<TIndex>& indexes) {\n-    if (indexes.empty()) {\n-        return {};\n-    }\n-\n-    arrow::UInt64Builder builder;\n-    if (!builder.Reserve(indexes.size()).ok()) {\n-        return {};\n-    }\n-\n-    for (auto&& i : indexes) {\n-        TStatusValidator::Validate(builder.Append(i));\n-    }\n-    std::shared_ptr<arrow::UInt64Array> out;\n-    TStatusValidator::Validate(builder.Finish(&out));\n-    return out;\n-}\n-\n-std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui32>& indexes) {\n-    return MakeFilterPermutationImpl(indexes);\n-}\n-\n-std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui64>& indexes) {\n-    return MakeFilterPermutationImpl(indexes);\n-}\n-\n-std::shared_ptr<arrow::RecordBatch> CopyRecords(const std::shared_ptr<arrow::RecordBatch>& source, const std::vector<ui64>& indexes) {\n-    Y_ABORT_UNLESS(!!source);\n-    auto schema = source->schema();\n-    std::vector<std::shared_ptr<arrow::Array>> columns;\n-    for (auto&& i : source->columns()) {\n-        columns.emplace_back(CopyRecords(i, indexes));\n-    }\n-    return arrow::RecordBatch::Make(schema, indexes.size(), columns);\n-}\n-\n-std::shared_ptr<arrow::Array> CopyRecords(const std::shared_ptr<arrow::Array>& source, const std::vector<ui64>& indexes) {\n-    if (!source) {\n-        return source;\n-    }\n-    std::shared_ptr<arrow::Array> result;\n-    SwitchType(source->type_id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-        using TBuilder = typename arrow::TypeTraits<typename TWrap::T>::BuilderType;\n-        auto& column = static_cast<const TArray&>(*source);\n-\n-        std::unique_ptr<arrow::ArrayBuilder> builder;\n-        TStatusValidator::Validate(arrow::MakeBuilder(arrow::default_memory_pool(), source->type(), &builder));\n-        auto& builderImpl = static_cast<TBuilder&>(*builder);\n-\n-        if constexpr (arrow::has_string_view<typename TWrap::T>::value) {\n-            ui64 sumByIndexes = 0;\n-            for (auto&& idx : indexes) {\n-                Y_ABORT_UNLESS(idx < (ui64)column.length());\n-                sumByIndexes += column.GetView(idx).size();\n-            }\n-            TStatusValidator::Validate(builderImpl.ReserveData(sumByIndexes));\n-        }\n-\n-        TStatusValidator::Validate(builder->Reserve(indexes.size()));\n-\n-        {\n-            const ui32 arraySize = column.length();\n-            for (auto&& i : indexes) {\n-                Y_ABORT_UNLESS(i < arraySize);\n-                builderImpl.UnsafeAppend(column.GetView(i));\n-            }\n-        }\n-\n-        TStatusValidator::Validate(builder->Finish(&result));\n-        return true;\n-    });\n-    Y_ABORT_UNLESS(result);\n-    return result;\n-}\n-\n namespace {\n \n template <class TDataContainer>\n@@ -213,101 +113,4 @@ bool THashConstructor::BuildHashUI64(std::shared_ptr<arrow::RecordBatch>& batch,\n     return BuildHashUI64Impl(batch, fieldNames, hashFieldName);\n }\n \n-ui64 TShardedRecordBatch::GetMemorySize() const {\n-    return NArrow::GetTableMemorySize(RecordBatch);\n-}\n-\n-TShardedRecordBatch::TShardedRecordBatch(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    AFL_VERIFY(batch);\n-    RecordBatch = TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batch->schema(), {batch}));\n-}\n-\n-\n-TShardedRecordBatch::TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch)\n-    : RecordBatch(batch)\n-{\n-    AFL_VERIFY(RecordBatch);\n-}\n-\n-TShardedRecordBatch::TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch, std::vector<std::vector<ui32>>&& splittedByShards)\n-    : RecordBatch(batch)\n-    , SplittedByShards(std::move(splittedByShards))\n-{\n-    AFL_VERIFY(RecordBatch);\n-    AFL_VERIFY(SplittedByShards.size());\n-}\n-\n-std::vector<std::shared_ptr<arrow::Table>> TShardingSplitIndex::Apply(const std::shared_ptr<arrow::Table>& input) {\n-    AFL_VERIFY(input);\n-    AFL_VERIFY(input->num_rows() == RecordsCount);\n-    auto permutation = BuildPermutation();\n-    auto resultBatch = NArrow::TStatusValidator::GetValid(arrow::compute::Take(input, *permutation)).table();\n-    AFL_VERIFY(resultBatch->num_rows() == RecordsCount);\n-    std::vector<std::shared_ptr<arrow::Table>> result;\n-    ui64 startIndex = 0;\n-    for (auto&& i : Remapping) {\n-        result.emplace_back(resultBatch->Slice(startIndex, i.size()));\n-        startIndex += i.size();\n-    }\n-    AFL_VERIFY(startIndex == RecordsCount);\n-    return result;\n-}\n-\n-NKikimr::NArrow::TShardedRecordBatch TShardingSplitIndex::Apply(const ui32 shardsCount, const std::shared_ptr<arrow::Table>& input, const std::string& hashColumnName) {\n-    AFL_VERIFY(input);\n-    if (shardsCount == 1) {\n-        return TShardedRecordBatch(input);\n-    }\n-    auto hashColumn = input->GetColumnByName(hashColumnName);\n-    if (!hashColumn) {\n-        return TShardedRecordBatch(input);\n-    }\n-    std::optional<TShardingSplitIndex> splitter;\n-    if (hashColumn->type()->id() == arrow::Type::UINT64) {\n-        splitter = TShardingSplitIndex::Build<arrow::UInt64Array>(shardsCount, *hashColumn);\n-    } else if (hashColumn->type()->id() == arrow::Type::UINT32) {\n-        splitter = TShardingSplitIndex::Build<arrow::UInt32Array>(shardsCount, *hashColumn);\n-    } else if (hashColumn->type()->id() == arrow::Type::INT64) {\n-        splitter = TShardingSplitIndex::Build<arrow::Int64Array>(shardsCount, *hashColumn);\n-    } else if (hashColumn->type()->id() == arrow::Type::INT32) {\n-        splitter = TShardingSplitIndex::Build<arrow::Int32Array>(shardsCount, *hashColumn);\n-    } else {\n-        Y_ABORT_UNLESS(false);\n-    }\n-    auto resultBatch = NArrow::TStatusValidator::GetValid(input->RemoveColumn(input->schema()->GetFieldIndex(hashColumnName)));\n-    return TShardedRecordBatch(resultBatch, splitter->DetachRemapping());\n-}\n-\n-TShardedRecordBatch TShardingSplitIndex::Apply(const ui32 shardsCount, const std::shared_ptr<arrow::RecordBatch>& input, const std::string& hashColumnName) {\n-    return Apply(shardsCount, TStatusValidator::GetValid(arrow::Table::FromRecordBatches(input->schema(), {input}))\n-        , hashColumnName);\n-}\n-\n-std::shared_ptr<arrow::UInt64Array> TShardingSplitIndex::BuildPermutation() const {\n-    arrow::UInt64Builder builder;\n-    Y_ABORT_UNLESS(builder.Reserve(RecordsCount).ok());\n-\n-    for (auto&& i : Remapping) {\n-        for (auto&& idx : i) {\n-            TStatusValidator::Validate(builder.Append(idx));\n-        }\n-    }\n-\n-    std::shared_ptr<arrow::UInt64Array> out;\n-    Y_ABORT_UNLESS(builder.Finish(&out).ok());\n-    return out;\n-}\n-\n-std::shared_ptr<arrow::RecordBatch> ReverseRecords(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    AFL_VERIFY(batch);\n-    auto permutation = NArrow::MakePermutation(batch->num_rows(), true);\n-    return NArrow::TStatusValidator::GetValid(arrow::compute::Take(batch, permutation)).record_batch();\n-}\n-\n-std::shared_ptr<arrow::Table> ReverseRecords(const std::shared_ptr<arrow::Table>& batch) {\n-    AFL_VERIFY(batch);\n-    auto permutation = NArrow::MakePermutation(batch->num_rows(), true);\n-    return NArrow::TStatusValidator::GetValid(arrow::compute::Take(batch, permutation)).table();\n-}\n-\n }\ndiff --git a/ydb/core/formats/arrow/permutations.h b/ydb/core/formats/arrow/permutations.h\nindex 73a433ee52a2..f8c62fb87107 100644\n--- a/ydb/core/formats/arrow/permutations.h\n+++ b/ydb/core/formats/arrow/permutations.h\n@@ -2,6 +2,7 @@\n #include \"arrow_helpers.h\"\n \n #include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/formats/arrow/permutations.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <util/system/types.h>\n@@ -15,143 +16,6 @@ class THashConstructor {\n \n };\n \n-class TShardedRecordBatch {\n-private:\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::Table>, RecordBatch);\n-    YDB_READONLY_DEF(std::vector<std::vector<ui32>>, SplittedByShards);\n-public:\n-    TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch);\n-    TShardedRecordBatch(const std::shared_ptr<arrow::RecordBatch>& batch);\n-\n-    void Cut(const ui32 limit) {\n-        RecordBatch = RecordBatch->Slice(0, limit);\n-        for (auto&& i : SplittedByShards) {\n-            auto it = std::lower_bound(i.begin(), i.end(), limit);\n-            if (it != i.end()) {\n-                i.erase(it, i.end());\n-            }\n-        }\n-    }\n-\n-    bool IsSharded() const {\n-        return SplittedByShards.size() > 1;\n-    }\n-\n-    TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch, std::vector<std::vector<ui32>>&& splittedByShards);\n-\n-    ui64 GetMemorySize() const;\n-\n-    ui64 GetRecordsCount() const {\n-        return RecordBatch->num_rows();\n-    }\n-};\n-\n-class TShardingSplitIndex {\n-private:\n-    ui32 ShardsCount = 0;\n-    std::vector<std::vector<ui32>> Remapping;\n-    ui32 RecordsCount = 0;\n-\n-    template <class TIterator>\n-    std::vector<ui32> MergeLists(const std::vector<ui32>& base, const TIterator itFrom, const TIterator itTo) {\n-        std::vector<ui32> result;\n-        result.reserve(base.size() + (itTo - itFrom));\n-        auto itBase = base.begin();\n-        auto itExt = itFrom;\n-        while (itBase != base.end() && itExt != itTo) {\n-            if (*itBase < *itExt) {\n-                result.emplace_back(*itBase);\n-                ++itBase;\n-            } else {\n-                result.emplace_back(*itExt);\n-                ++itExt;\n-            }\n-        }\n-        if (itBase == base.end()) {\n-            result.insert(result.end(), itExt, itTo);\n-        } else if (itExt == itTo) {\n-            result.insert(result.end(), itBase, base.end());\n-        }\n-        return result;\n-    }\n-\n-    template <class TIntArrowArray>\n-    void Initialize(const arrow::ChunkedArray& arrowHashArrayChunked) {\n-        Y_ABORT_UNLESS(ShardsCount);\n-        Remapping.resize(ShardsCount);\n-        const ui32 expectation = arrowHashArrayChunked.length() / ShardsCount + 1;\n-        for (auto&& i : Remapping) {\n-            i.reserve(2 * expectation);\n-        }\n-        for (auto&& arrowHashArrayAbstract : arrowHashArrayChunked.chunks()) {\n-            auto& arrowHashArray = static_cast<const TIntArrowArray&>(*arrowHashArrayAbstract);\n-            ui64 offset = 0;\n-            for (ui64 i = 0; i < (ui64)arrowHashArray.length(); ++i) {\n-                const i64 v = arrowHashArray.GetView(i);\n-                const ui32 idx = ((v < 0) ? (-v) : v) % ShardsCount;\n-                Remapping[idx].emplace_back(offset + i);\n-            }\n-            offset += (ui64)arrowHashArray.length();\n-        }\n-        std::deque<std::vector<ui32>*> sizeCorrection;\n-        for (auto&& i : Remapping) {\n-            sizeCorrection.emplace_back(&i);\n-        }\n-        const auto pred = [](const std::vector<ui32>* l, const std::vector<ui32>* r) {\n-            return l->size() < r->size();\n-        };\n-        std::sort(sizeCorrection.begin(), sizeCorrection.end(), pred);\n-        while (sizeCorrection.size() > 1 && sizeCorrection.back()->size() > expectation && sizeCorrection.front()->size() < expectation) {\n-            const ui32 uselessRecords = sizeCorrection.back()->size() - expectation;\n-            const ui32 needRecords = expectation - sizeCorrection.front()->size();\n-            const ui32 moveRecords = std::min<ui32>(needRecords, uselessRecords);\n-            if (moveRecords == 0) {\n-                break;\n-            }\n-            *sizeCorrection.front() = MergeLists(*sizeCorrection.front(), sizeCorrection.back()->end() - moveRecords, sizeCorrection.back()->end());\n-            sizeCorrection.back()->resize(sizeCorrection.back()->size() - moveRecords);\n-            if (sizeCorrection.back()->size() <= expectation) {\n-                sizeCorrection.pop_back();\n-            }\n-            if (sizeCorrection.front()->size() >= expectation) {\n-                sizeCorrection.pop_front();\n-            }\n-        }\n-    }\n-\n-    TShardingSplitIndex(const ui32 shardsCount, const arrow::ChunkedArray& arrowHashArray)\n-        : ShardsCount(shardsCount)\n-        , RecordsCount(arrowHashArray.length()) {\n-    }\n-\n-public:\n-\n-    std::vector<std::vector<ui32>> DetachRemapping() {\n-        return std::move(Remapping);\n-    }\n-\n-    template <class TArrayClass>\n-    static TShardingSplitIndex Build(const ui32 shardsCount, const arrow::ChunkedArray& arrowHashArray) {\n-        TShardingSplitIndex result(shardsCount, arrowHashArray);\n-        result.Initialize<TArrayClass>(arrowHashArray);\n-        return result;\n-    }\n-\n-    std::shared_ptr<arrow::UInt64Array> BuildPermutation() const;\n-\n-    std::vector<std::shared_ptr<arrow::Table>> Apply(const std::shared_ptr<arrow::Table>& input);\n-    static TShardedRecordBatch Apply(const ui32 shardsCount, const std::shared_ptr<arrow::Table>& input, const std::string& hashColumnName);\n-    static TShardedRecordBatch Apply(const ui32 shardsCount, const std::shared_ptr<arrow::RecordBatch>& input, const std::string& hashColumnName);\n-};\n-\n-std::shared_ptr<arrow::UInt64Array> MakePermutation(const int size, const bool reverse = false);\n-std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui64>& indexes);\n-std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui32>& indexes);\n std::shared_ptr<arrow::UInt64Array> MakeSortPermutation(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& sortingKey, const bool andUnique);\n-std::shared_ptr<arrow::RecordBatch> ReverseRecords(const std::shared_ptr<arrow::RecordBatch>& batch);\n-std::shared_ptr<arrow::Table> ReverseRecords(const std::shared_ptr<arrow::Table>& batch);\n-\n-std::shared_ptr<arrow::Array> CopyRecords(const std::shared_ptr<arrow::Array>& source, const std::vector<ui64>& indexes);\n-std::shared_ptr<arrow::RecordBatch> CopyRecords(const std::shared_ptr<arrow::RecordBatch>& source, const std::vector<ui64>& indexes);\n \n }\ndiff --git a/ydb/core/formats/arrow/process_columns.cpp b/ydb/core/formats/arrow/process_columns.cpp\nindex 5fb133f90de5..c032d1d8006c 100644\n--- a/ydb/core/formats/arrow/process_columns.cpp\n+++ b/ydb/core/formats/arrow/process_columns.cpp\n@@ -1,15 +1,45 @@\n #include \"process_columns.h\"\n+\n #include \"common/adapter.h\"\n-#include \"modifier/subset.h\"\n+\n+#include <ydb/library/formats/arrow/modifier/schema.h>\n+#include <ydb/library/formats/arrow/modifier/subset.h>\n \n #include <util/string/join.h>\n \n namespace NKikimr::NArrow {\n \n namespace {\n-template <class TDataContainer, class TStringImpl>\n-std::shared_ptr<TDataContainer> ExtractColumnsValidateImpl(const std::shared_ptr<TDataContainer>& srcBatch,\n-    const std::vector<TStringImpl>& columnNames) {\n+\n+template <class T>\n+class TColumnNameAccessor {\n+public:\n+    static const std::string& GetFieldName(const T& val) {\n+        return val;\n+    }\n+    static TString DebugString(const std::vector<T>& items) {\n+        return JoinSeq(\",\", items);\n+    }\n+};\n+\n+template <>\n+class TColumnNameAccessor<std::shared_ptr<arrow::Field>> {\n+public:\n+    static const std::string& GetFieldName(const std::shared_ptr<arrow::Field>& val) {\n+        return val->name();\n+    }\n+    static TString DebugString(const std::vector<std::shared_ptr<arrow::Field>>& items) {\n+        TStringBuilder sb;\n+        for (auto&& i : items) {\n+            sb << i->name() << \",\";\n+        }\n+        return sb;\n+    }\n+};\n+\n+template <class TDataContainer, class TStringContainer>\n+std::shared_ptr<TDataContainer> ExtractColumnsValidateImpl(\n+    const std::shared_ptr<TDataContainer>& srcBatch, const std::vector<TStringContainer>& columnNames) {\n     std::vector<std::shared_ptr<arrow::Field>> fields;\n     fields.reserve(columnNames.size());\n     std::vector<std::shared_ptr<typename NAdapter::TDataBuilderPolicy<TDataContainer>::TColumn>> columns;\n@@ -17,7 +47,7 @@ std::shared_ptr<TDataContainer> ExtractColumnsValidateImpl(const std::shared_ptr\n \n     auto srcSchema = srcBatch->schema();\n     for (auto& name : columnNames) {\n-        const int pos = srcSchema->GetFieldIndex(name);\n+        const int pos = srcSchema->GetFieldIndex(TColumnNameAccessor<TStringContainer>::GetFieldName(name));\n         if (Y_LIKELY(pos > -1)) {\n             fields.push_back(srcSchema->field(pos));\n             columns.push_back(srcBatch->column(pos));\n@@ -27,9 +57,9 @@ std::shared_ptr<TDataContainer> ExtractColumnsValidateImpl(const std::shared_ptr\n     return NAdapter::TDataBuilderPolicy<TDataContainer>::Build(std::move(fields), std::move(columns), srcBatch->num_rows());\n }\n \n-template <class TDataContainer>\n-TConclusion<std::shared_ptr<TDataContainer>> AdaptColumnsImpl(const std::shared_ptr<TDataContainer>& srcBatch,\n-    const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset) {\n+template <class TDataContainer, class TSchemaImpl>\n+TConclusion<std::shared_ptr<TDataContainer>> AdaptColumnsImpl(\n+    const std::shared_ptr<TDataContainer>& srcBatch, const std::shared_ptr<TSchemaImpl>& dstSchema, TSchemaSubset* subset) {\n     AFL_VERIFY(srcBatch);\n     AFL_VERIFY(dstSchema);\n     std::vector<std::shared_ptr<typename NAdapter::TDataBuilderPolicy<TDataContainer>::TColumn>> columns;\n@@ -48,16 +78,16 @@ TConclusion<std::shared_ptr<TDataContainer>> AdaptColumnsImpl(const std::shared_\n             fields.emplace_back(field);\n             auto srcField = srcBatch->schema()->field(index);\n             if (field->Equals(srcField)) {\n-                AFL_VERIFY(columns.back()->type()->Equals(field->type()))(\"event\", \"cannot_use_incoming_batch\")(\"reason\", \"invalid_column_type\")(\"column\", field->name())\n-                    (\"column_type\", field->type()->ToString())(\"incoming_type\", columns.back()->type()->ToString());\n+                AFL_VERIFY(columns.back()->type()->Equals(field->type()))(\"event\", \"cannot_use_incoming_batch\")(\"reason\", \"invalid_column_type\")(\n+                    \"column\", field->name())(\"column_type\", field->type()->ToString())(\"incoming_type\", columns.back()->type()->ToString());\n             } else {\n-                AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"cannot_use_incoming_batch\")(\"reason\", \"invalid_column_type\")(\"column\", field->name())\n-                    (\"column_type\", field->ToString(true))(\"incoming_type\", srcField->ToString(true));\n+                AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"cannot_use_incoming_batch\")(\"reason\", \"invalid_column_type\")(\n+                    \"column\", field->name())(\"column_type\", field->ToString(true))(\"incoming_type\", srcField->ToString(true));\n                 return TConclusionStatus::Fail(\"incompatible column types\");\n             }\n         } else if (!subset) {\n-            AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"not_found_column\")(\"column\", field->name())\n-                (\"column_type\", field->type()->ToString())(\"columns\", JoinSeq(\",\", srcBatch->schema()->field_names()));\n+            AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"not_found_column\")(\"column\", field->name())(\n+                \"column_type\", field->type()->ToString())(\"columns\", JoinSeq(\",\", srcBatch->schema()->field_names()));\n             return TConclusionStatus::Fail(\"not found column '\" + field->name() + \"'\");\n         }\n         ++idx;\n@@ -68,15 +98,16 @@ TConclusion<std::shared_ptr<TDataContainer>> AdaptColumnsImpl(const std::shared_\n     return NAdapter::TDataBuilderPolicy<TDataContainer>::Build(std::make_shared<arrow::Schema>(fields), std::move(columns), srcBatch->num_rows());\n }\n \n-template <class TDataContainer, class TStringType>\n+template <class TDataContainer, class TStringContainer>\n std::shared_ptr<TDataContainer> ExtractImpl(const TColumnOperator::EExtractProblemsPolicy& policy,\n-    const std::shared_ptr<TDataContainer>& incoming, const std::vector<TStringType>& columnNames) {\n+    const std::shared_ptr<TDataContainer>& incoming, const std::vector<TStringContainer>& columnNames) {\n     AFL_VERIFY(incoming);\n     AFL_VERIFY(columnNames.size());\n     auto result = ExtractColumnsValidateImpl(incoming, columnNames);\n     switch (policy) {\n         case TColumnOperator::EExtractProblemsPolicy::Verify:\n-            AFL_VERIFY((ui32)result->num_columns() == columnNames.size())(\"schema\", incoming->schema()->ToString())(\"required\", JoinSeq(\",\", columnNames));\n+            AFL_VERIFY((ui32)result->num_columns() == columnNames.size())(\"schema\", incoming->schema()->ToString())(\n+                                                          \"required\", TColumnNameAccessor<TStringContainer>::DebugString(columnNames));\n             break;\n         case TColumnOperator::EExtractProblemsPolicy::Null:\n             if ((ui32)result->num_columns() != columnNames.size()) {\n@@ -90,7 +121,8 @@ std::shared_ptr<TDataContainer> ExtractImpl(const TColumnOperator::EExtractProbl\n }\n \n template <class TDataContainer, class TStringType>\n-TConclusion<std::shared_ptr<TDataContainer>> ReorderImpl(const std::shared_ptr<TDataContainer>& incoming, const std::vector<TStringType>& columnNames) {\n+TConclusion<std::shared_ptr<TDataContainer>> ReorderImpl(\n+    const std::shared_ptr<TDataContainer>& incoming, const std::vector<TStringType>& columnNames) {\n     AFL_VERIFY(!!incoming);\n     AFL_VERIFY(columnNames.size());\n     if ((ui32)incoming->num_columns() < columnNames.size()) {\n@@ -107,17 +139,30 @@ TConclusion<std::shared_ptr<TDataContainer>> ReorderImpl(const std::shared_ptr<T\n     return result;\n }\n \n-}\n+}   // namespace\n \n-std::shared_ptr<arrow::RecordBatch> TColumnOperator::Extract(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames) {\n+std::shared_ptr<arrow::RecordBatch> TColumnOperator::Extract(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames) {\n     return ExtractImpl(AbsentColumnPolicy, incoming, columnNames);\n }\n \n-std::shared_ptr<arrow::Table> TColumnOperator::Extract(const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames) {\n+std::shared_ptr<arrow::Table> TColumnOperator::Extract(\n+    const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames) {\n     return ExtractImpl(AbsentColumnPolicy, incoming, columnNames);\n }\n \n-std::shared_ptr<arrow::RecordBatch> TColumnOperator::Extract(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames) {\n+std::shared_ptr<arrow::Table> TColumnOperator::Extract(\n+    const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::shared_ptr<arrow::Field>>& columns) {\n+    return ExtractImpl(AbsentColumnPolicy, incoming, columns);\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> TColumnOperator::Extract(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::shared_ptr<arrow::Field>>& columns) {\n+    return ExtractImpl(AbsentColumnPolicy, incoming, columns);\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> TColumnOperator::Extract(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames) {\n     return ExtractImpl(AbsentColumnPolicy, incoming, columnNames);\n }\n \n@@ -125,28 +170,86 @@ std::shared_ptr<arrow::Table> TColumnOperator::Extract(const std::shared_ptr<arr\n     return ExtractImpl(AbsentColumnPolicy, incoming, columnNames);\n }\n \n-NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Adapt(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset) {\n+NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Adapt(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset) {\n+    return AdaptColumnsImpl(incoming, dstSchema, subset);\n+}\n+\n+NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Adapt(\n+    const std::shared_ptr<arrow::Table>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset) {\n+    return AdaptColumnsImpl(incoming, dstSchema, subset);\n+}\n+\n+NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Adapt(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<NArrow::TSchemaLite>& dstSchema, TSchemaSubset* subset) {\n     return AdaptColumnsImpl(incoming, dstSchema, subset);\n }\n \n-NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Adapt(const std::shared_ptr<arrow::Table>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset) {\n+NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Adapt(\n+    const std::shared_ptr<arrow::Table>& incoming, const std::shared_ptr<NArrow::TSchemaLite>& dstSchema, TSchemaSubset* subset) {\n     return AdaptColumnsImpl(incoming, dstSchema, subset);\n }\n \n-NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Reorder(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames) {\n+NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Reorder(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames) {\n     return ReorderImpl(incoming, columnNames);\n }\n \n-NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Reorder(const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames) {\n+NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Reorder(\n+    const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames) {\n     return ReorderImpl(incoming, columnNames);\n }\n \n-NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Reorder(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames) {\n+NKikimr::TConclusion<std::shared_ptr<arrow::RecordBatch>> TColumnOperator::Reorder(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames) {\n     return ReorderImpl(incoming, columnNames);\n }\n \n-NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Reorder(const std::shared_ptr<arrow::Table>& incoming, const std::vector<TString>& columnNames) {\n+NKikimr::TConclusion<std::shared_ptr<arrow::Table>> TColumnOperator::Reorder(\n+    const std::shared_ptr<arrow::Table>& incoming, const std::vector<TString>& columnNames) {\n     return ReorderImpl(incoming, columnNames);\n }\n+namespace {\n+template <class TDataContainer, class TSchemaImpl>\n+TConclusion<TSchemaSubset> BuildSequentialSubsetImpl(\n+    const std::shared_ptr<TDataContainer>& srcBatch, const std::shared_ptr<TSchemaImpl>& dstSchema) {\n+    AFL_VERIFY(srcBatch);\n+    AFL_VERIFY(dstSchema);\n+    if (dstSchema->num_fields() < srcBatch->schema()->num_fields()) {\n+        AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"incorrect columns set: destination must been wider than source\")(\n+            \"source\", srcBatch->schema()->ToString())(\"destination\", dstSchema->ToString());\n+        return TConclusionStatus::Fail(\"incorrect columns set: destination must been wider than source\");\n+    }\n+    std::set<ui32> fieldIdx;\n+    auto itSrc = srcBatch->schema()->fields().begin();\n+    auto itDst = dstSchema->fields().begin();\n+    while (itSrc != srcBatch->schema()->fields().end() && itDst != dstSchema->fields().end()) {\n+        if ((*itSrc)->name() != (*itDst)->name()) {\n+            ++itDst;\n+        } else {\n+            fieldIdx.emplace(itDst - dstSchema->fields().begin());\n+            if (!(*itDst)->Equals(*itSrc)) {\n+                AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"cannot_use_incoming_batch\")(\"reason\", \"invalid_column_type\")(\n+                    \"column_type\", (*itDst)->ToString(true))(\"incoming_type\", (*itSrc)->ToString(true));\n+                return TConclusionStatus::Fail(\"incompatible column types\");\n+            }\n+\n+            ++itDst;\n+            ++itSrc;\n+        }\n+    }\n+    if (itDst == dstSchema->fields().end() && itSrc != srcBatch->schema()->fields().end()) {\n+        AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"incorrect columns order in source set\")(\"source\", srcBatch->schema()->ToString())(\n+            \"destination\", dstSchema->ToString());\n+        return TConclusionStatus::Fail(\"incorrect columns order in source set\");\n+    }\n+    return TSchemaSubset(fieldIdx, dstSchema->num_fields());\n+}\n+}   // namespace\n+\n+TConclusion<TSchemaSubset> TColumnOperator::BuildSequentialSubset(\n+    const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<NArrow::TSchemaLite>& dstSchema) {\n+    return BuildSequentialSubsetImpl(incoming, dstSchema);\n+}\n \n-}\n\\ No newline at end of file\n+}   // namespace NKikimr::NArrow\ndiff --git a/ydb/core/formats/arrow/process_columns.h b/ydb/core/formats/arrow/process_columns.h\nindex be05e84efb14..ad57af9e6647 100644\n--- a/ydb/core/formats/arrow/process_columns.h\n+++ b/ydb/core/formats/arrow/process_columns.h\n@@ -6,6 +6,7 @@\n namespace NKikimr::NArrow {\n \n class TSchemaSubset;\n+class TSchemaLite;\n \n class TColumnOperator {\n public:\n@@ -14,6 +15,7 @@ class TColumnOperator {\n         Verify,\n         Skip\n     };\n+\n private:\n     EExtractProblemsPolicy AbsentColumnPolicy = EExtractProblemsPolicy::Verify;\n \n@@ -33,18 +35,35 @@ class TColumnOperator {\n         return *this;\n     }\n \n-    std::shared_ptr<arrow::RecordBatch> Extract(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames);\n+    std::shared_ptr<arrow::RecordBatch> Extract(\n+        const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames);\n     std::shared_ptr<arrow::Table> Extract(const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames);\n+    std::shared_ptr<arrow::Table> Extract(\n+        const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::shared_ptr<arrow::Field>>& columns);\n+    std::shared_ptr<arrow::RecordBatch> Extract(\n+        const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::shared_ptr<arrow::Field>>& columns);\n     std::shared_ptr<arrow::RecordBatch> Extract(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames);\n     std::shared_ptr<arrow::Table> Extract(const std::shared_ptr<arrow::Table>& incoming, const std::vector<TString>& columnNames);\n \n-    TConclusion<std::shared_ptr<arrow::RecordBatch>> Adapt(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset = nullptr);\n-    TConclusion<std::shared_ptr<arrow::Table>> Adapt(const std::shared_ptr<arrow::Table>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset = nullptr);\n+    TConclusion<TSchemaSubset> BuildSequentialSubset(\n+        const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<NArrow::TSchemaLite>& dstSchema);\n+\n+    TConclusion<std::shared_ptr<arrow::RecordBatch>> Adapt(\n+        const std::shared_ptr<arrow::RecordBatch>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset = nullptr);\n+    TConclusion<std::shared_ptr<arrow::Table>> Adapt(\n+        const std::shared_ptr<arrow::Table>& incoming, const std::shared_ptr<arrow::Schema>& dstSchema, TSchemaSubset* subset = nullptr);\n+    TConclusion<std::shared_ptr<arrow::RecordBatch>> Adapt(const std::shared_ptr<arrow::RecordBatch>& incoming,\n+        const std::shared_ptr<NArrow::TSchemaLite>& dstSchema, TSchemaSubset* subset = nullptr);\n+    TConclusion<std::shared_ptr<arrow::Table>> Adapt(\n+        const std::shared_ptr<arrow::Table>& incoming, const std::shared_ptr<NArrow::TSchemaLite>& dstSchema, TSchemaSubset* subset = nullptr);\n \n-    TConclusion<std::shared_ptr<arrow::RecordBatch>> Reorder(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames);\n-    TConclusion<std::shared_ptr<arrow::Table>> Reorder(const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames);\n-    TConclusion<std::shared_ptr<arrow::RecordBatch>> Reorder(const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames);\n+    TConclusion<std::shared_ptr<arrow::RecordBatch>> Reorder(\n+        const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<std::string>& columnNames);\n+    TConclusion<std::shared_ptr<arrow::Table>> Reorder(\n+        const std::shared_ptr<arrow::Table>& incoming, const std::vector<std::string>& columnNames);\n+    TConclusion<std::shared_ptr<arrow::RecordBatch>> Reorder(\n+        const std::shared_ptr<arrow::RecordBatch>& incoming, const std::vector<TString>& columnNames);\n     TConclusion<std::shared_ptr<arrow::Table>> Reorder(const std::shared_ptr<arrow::Table>& incoming, const std::vector<TString>& columnNames);\n };\n \n-}\n\\ No newline at end of file\n+}   // namespace NKikimr::NArrow\ndiff --git a/ydb/core/formats/arrow/program.cpp b/ydb/core/formats/arrow/program.cpp\nindex 60e59749bb7a..50071d8490e3 100644\n--- a/ydb/core/formats/arrow/program.cpp\n+++ b/ydb/core/formats/arrow/program.cpp\n@@ -19,6 +19,18 @@ enum class AggFunctionId {\n     AGG_MIN = 3,\n     AGG_MAX = 4,\n     AGG_SUM = 5,\n+    AGG_AVG = 6,\n+    //AGG_VAR = 7,\n+    //AGG_COVAR = 8,\n+    //AGG_STDDEV = 9,\n+    //AGG_CORR = 10,\n+    //AGG_ARG_MIN = 11,\n+    //AGG_ARG_MAX = 12,\n+    //AGG_COUNT_DISTINCT = 13,\n+    //AGG_QUANTILES = 14,\n+    //AGG_TOP_COUNT = 15,\n+    //AGG_TOP_SUM = 16,\n+    AGG_NUM_ROWS = 17,\n };\n struct GroupByOptions: public arrow::compute::ScalarAggregateOptions {\n     struct Assign {\n@@ -398,6 +410,8 @@ const char * GetFunctionName(EAggregate op) {\n             return \"min_max\";\n         case EAggregate::Sum:\n             return \"sum\";\n+        case EAggregate::NumRows:\n+            return \"num_rows\";\n #if 0 // TODO\n         case EAggregate::Avg:\n             return \"mean\";\n@@ -424,6 +438,8 @@ const char * GetHouseFunctionName(EAggregate op) {\n         case EAggregate::Avg:\n             return \"ch.avg\";\n #endif\n+        case EAggregate::NumRows:\n+            return \"ch.num_rows\";\n         default:\n             break;\n     }\n@@ -448,6 +464,8 @@ CH::AggFunctionId GetHouseFunction(EAggregate op) {\n         case EAggregate::Avg:\n             return CH::AggFunctionId::AGG_AVG;\n #endif\n+        case EAggregate::NumRows:\n+            return CH::AggFunctionId::AGG_NUM_ROWS;\n         default:\n             break;\n     }\n@@ -678,6 +696,27 @@ IStepFunction<TAggregateAssign>::TPtr TAggregateAssign::GetFunction(arrow::compu\n     return std::make_shared<TAggregateFunction>(ctx);\n }\n \n+TString TAggregateAssign::DebugString() const {\n+    TStringBuilder sb;\n+    sb << \"{\";\n+    if (Operation != EAggregate::Unspecified) {\n+        sb << \"op=\" << GetFunctionName(Operation) << \";\";\n+    }\n+    if (Arguments.size()) {\n+        sb << \"arguments=[\";\n+        for (auto&& i : Arguments) {\n+            sb << i.DebugString() << \";\";\n+        }\n+        sb << \"];\";\n+    }\n+    sb << \"options=\" << ScalarOpts.ToString() << \";\";\n+    if (KernelFunction) {\n+        sb << \"kernel=\" << KernelFunction->name() << \";\";\n+    }\n+    sb << \"column=\" << Column.DebugString() << \";\";\n+    sb << \"}\";\n+    return sb;\n+}\n \n arrow::Status TProgramStep::ApplyAssignes(TDatumBatch& batch, arrow::compute::ExecContext* ctx) const {\n     if (Assignes.empty()) {\ndiff --git a/ydb/core/formats/arrow/program.h b/ydb/core/formats/arrow/program.h\nindex e3f9943e6c13..2b953b55e070 100644\n--- a/ydb/core/formats/arrow/program.h\n+++ b/ydb/core/formats/arrow/program.h\n@@ -21,6 +21,7 @@ enum class EAggregate {\n     Max = 4,\n     Sum = 5,\n     //Avg = 6,\n+    NumRows = 7,\n };\n \n }\n@@ -323,6 +324,7 @@ class TAggregateAssign {\n     const arrow::compute::ScalarAggregateOptions* GetOptions() const { return &ScalarOpts; }\n \n     IStepFunction<TAggregateAssign>::TPtr GetFunction(arrow::compute::ExecContext* ctx) const;\n+    TString DebugString() const;\n \n private:\n     TColumnInfo Column;\n@@ -372,10 +374,18 @@ class TProgramStep {\n             sb << \"];\";\n         }\n         if (GroupBy.size()) {\n-            sb << \"group_by_count=\" << GroupBy.size() << \"; \";\n+            sb << \"group_by_assignes=[\";\n+            for (auto&& i : GroupBy) {\n+                sb << i.DebugString() << \";\";\n+            }\n+            sb << \"];\";\n         }\n         if (GroupByKeys.size()) {\n-            sb << \"group_by_keys_count=\" << GroupByKeys.size() << \";\";\n+            sb << \"group_by_keys=[\";\n+            for (auto&& i : GroupByKeys) {\n+                sb << i.DebugString() << \";\";\n+            }\n+            sb << \"];\";\n         }\n \n         sb << \"projections=[\";\ndiff --git a/ydb/core/formats/arrow/reader/batch_iterator.h b/ydb/core/formats/arrow/reader/batch_iterator.h\nindex 48497a53c452..d3bb365d5706 100644\n--- a/ydb/core/formats/arrow/reader/batch_iterator.h\n+++ b/ydb/core/formats/arrow/reader/batch_iterator.h\n@@ -44,7 +44,8 @@ class TBatchIterator {\n \n     TBatchIterator(TRWSortableBatchPosition&& keyColumns)\n         : ControlPointFlag(true)\n-        , KeyColumns(std::move(keyColumns)) {\n+        , KeyColumns(std::move(keyColumns))\n+    {\n \n     }\n \ndiff --git a/ydb/core/formats/arrow/reader/merger.cpp b/ydb/core/formats/arrow/reader/merger.cpp\nindex a09983971be8..16b9733ad4c0 100644\n--- a/ydb/core/formats/arrow/reader/merger.cpp\n+++ b/ydb/core/formats/arrow/reader/merger.cpp\n@@ -1,15 +1,16 @@\n #include \"merger.h\"\n #include \"result_builder.h\"\n+#include <ydb/library/formats/arrow/permutations.h>\n #include <ydb/library/services/services.pb.h>\n \n namespace NKikimr::NArrow::NMerger {\n \n-void TMergePartialStream::PutControlPoint(const TSortableBatchPosition& point) {\n+void TMergePartialStream::PutControlPoint(const TSortableBatchPosition& point, const bool deepCopy) {\n     AFL_VERIFY(point.IsSameSortingSchema(SortSchema))(\"point\", point.DebugJson())(\"schema\", SortSchema->ToString());\n     Y_ABORT_UNLESS(point.IsReverseSort() == Reverse);\n     Y_ABORT_UNLESS(++ControlPoints == 1);\n \n-    SortHeap.Push(TBatchIterator(point.BuildRWPosition()));\n+    SortHeap.Push(TBatchIterator(point.BuildRWPosition(false, deepCopy)));\n }\n \n void TMergePartialStream::RemoveControlPoint() {\n@@ -65,7 +66,7 @@ bool TMergePartialStream::DrainToControlPoint(TRecordBatchBuilder& builder, cons\n }\n \n bool TMergePartialStream::DrainCurrentTo(TRecordBatchBuilder& builder, const TSortableBatchPosition& readTo, const bool includeFinish, std::optional<TCursor>* lastResultPosition) {\n-    PutControlPoint(readTo);\n+    PutControlPoint(readTo, false);\n     return DrainToControlPoint(builder, includeFinish, lastResultPosition);\n }\n \n@@ -191,6 +192,9 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> TMergePartialStream::DrainAllPa\n     std::vector<std::shared_ptr<arrow::RecordBatch>> result;\n     for (auto&& i : positions) {\n         TRecordBatchBuilder indexesBuilder(resultFields);\n+        if (SortHeap.Empty() || i.GetPosition().Compare(SortHeap.Current().GetKeyColumns()) == std::partial_ordering::less) {\n+            continue;\n+        }\n         DrainCurrentTo(indexesBuilder, i.GetPosition(), i.IsIncludedToLeftInterval());\n         result.emplace_back(indexesBuilder.Finalize());\n         if (result.back()->num_rows() == 0) {\ndiff --git a/ydb/core/formats/arrow/reader/merger.h b/ydb/core/formats/arrow/reader/merger.h\nindex 972e891fe1fd..c30aba0f384f 100644\n--- a/ydb/core/formats/arrow/reader/merger.h\n+++ b/ydb/core/formats/arrow/reader/merger.h\n@@ -37,6 +37,9 @@ class TMergePartialStream {\n     void DrainCurrentPosition(TRecordBatchBuilder* builder, std::shared_ptr<TSortableScanData>* resultScanData, ui64* resultPosition);\n \n     void CheckSequenceInDebug(const TRWSortableBatchPosition& nextKeyColumnsPosition);\n+    bool DrainCurrentTo(TRecordBatchBuilder& builder, const TSortableBatchPosition& readTo, const bool includeFinish,\n+        std::optional<TCursor>* lastResultPosition = nullptr);\n+\n public:\n     TMergePartialStream(std::shared_ptr<arrow::Schema> sortSchema, std::shared_ptr<arrow::Schema> dataSchema, const bool reverse, const std::vector<std::string>& versionColumnNames)\n         : SortSchema(sortSchema)\n@@ -49,6 +52,7 @@ class TMergePartialStream {\n         Y_ABORT_UNLESS(!DataSchema || DataSchema->num_fields());\n     }\n \n+    void PutControlPoint(const TSortableBatchPosition& point, const bool deepCopy);\n     void SkipToLowerBound(const TSortableBatchPosition& pos, const bool include);\n \n     void SetPossibleSameVersion(const bool value) {\n@@ -67,8 +71,6 @@ class TMergePartialStream {\n         return TStringBuilder() << \"sort_heap=\" << SortHeap.DebugJson();\n     }\n \n-    void PutControlPoint(const TSortableBatchPosition& point);\n-\n     void RemoveControlPoint();\n \n     bool ControlPointEnriched() const {\n@@ -92,7 +94,6 @@ class TMergePartialStream {\n \n     void DrainAll(TRecordBatchBuilder& builder);\n     std::shared_ptr<arrow::Table> SingleSourceDrain(const TSortableBatchPosition& readTo, const bool includeFinish, std::optional<TCursor>* lastResultPosition = nullptr);\n-    bool DrainCurrentTo(TRecordBatchBuilder& builder, const TSortableBatchPosition& readTo, const bool includeFinish, std::optional<TCursor>* lastResultPosition = nullptr);\n     bool DrainToControlPoint(TRecordBatchBuilder& builder, const bool includeFinish, std::optional<TCursor>* lastResultPosition = nullptr);\n     std::vector<std::shared_ptr<arrow::RecordBatch>> DrainAllParts(const TIntervalPositions& positions,\n         const std::vector<std::shared_ptr<arrow::Field>>& resultFields);\ndiff --git a/ydb/core/formats/arrow/reader/position.cpp b/ydb/core/formats/arrow/reader/position.cpp\nindex 6431d180d130..b728405769d7 100644\n--- a/ydb/core/formats/arrow/reader/position.cpp\n+++ b/ydb/core/formats/arrow/reader/position.cpp\n@@ -1,4 +1,7 @@\n #include \"position.h\"\n+\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n+\n #include <util/string/join.h>\n \n namespace NKikimr::NArrow::NMerger {\n@@ -15,11 +18,13 @@ NJson::TJsonValue TSortableBatchPosition::DebugJson() const {\n     return result;\n }\n \n-std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(TRWSortableBatchPosition& position, const ui64 posStartExt, const ui64 posFinishExt, const TSortableBatchPosition& forFound, const bool greater) {\n+std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(TRWSortableBatchPosition& position,\n+    const ui64 posStartExt, const ui64 posFinishExt, const TSortableBatchPosition& forFound, const bool greater) {\n     ui64 posStart = posStartExt;\n     ui64 posFinish = posFinishExt;\n+    auto guard = position.CreateAsymmetricAccessGuard();\n     {\n-        AFL_VERIFY(position.InitPosition(posStart));\n+        AFL_VERIFY(guard.InitSortingPosition(posStart));\n         auto cmp = position.Compare(forFound);\n         if (cmp == std::partial_ordering::greater) {\n             return TFoundPosition::Greater(posStart);\n@@ -28,7 +33,7 @@ std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::Fi\n         }\n     }\n     {\n-        AFL_VERIFY(position.InitPosition(posFinish));\n+        AFL_VERIFY(guard.InitSortingPosition(posFinish));\n         auto cmp = position.Compare(forFound);\n         if (cmp == std::partial_ordering::less) {\n             return TFoundPosition::Less(posFinish);\n@@ -37,7 +42,7 @@ std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::Fi\n         }\n     }\n     while (posFinish > posStart + 1) {\n-        Y_ABORT_UNLESS(position.InitPosition(0.5 * (posStart + posFinish)));\n+        AFL_VERIFY(guard.InitSortingPosition(0.5 * (posStart + posFinish)));\n         const auto comparision = position.Compare(forFound);\n         if (comparision == std::partial_ordering::less) {\n             posStart = position.Position;\n@@ -47,17 +52,18 @@ std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::Fi\n             return TFoundPosition::Equal(position.Position);\n         }\n     }\n-    Y_ABORT_UNLESS(posFinish != posStart);\n+    AFL_VERIFY(posFinish != posStart);\n     if (greater) {\n-        Y_ABORT_UNLESS(position.InitPosition(posFinish));\n+        AFL_VERIFY(guard.InitSortingPosition(posFinish));\n         return TFoundPosition::Greater(posFinish);\n     } else {\n-        Y_ABORT_UNLESS(position.InitPosition(posStart));\n+        AFL_VERIFY(guard.InitSortingPosition(posStart));\n         return TFoundPosition::Less(posStart);\n     }\n }\n \n-std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound, const bool greater, const std::optional<ui32> includedStartPosition) {\n+std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch,\n+    const TSortableBatchPosition& forFound, const bool greater, const std::optional<ui32> includedStartPosition) {\n     if (!batch || !batch->num_rows()) {\n         return {};\n     }\n@@ -74,11 +80,14 @@ std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::Fi\n     return FindPosition(position, posStart, posFinish, forFound, greater);\n }\n \n-NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::BuildRWPosition() const {\n-    return TRWSortableBatchPosition(Position, RecordsCount, ReverseSort, Sorting->BuildCopy(Position), Data ? Data->BuildCopy(Position) : nullptr);\n+NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::BuildRWPosition(const bool needData, const bool deepCopy) const {\n+    return TRWSortableBatchPosition(Position, RecordsCount, ReverseSort,\n+        deepCopy ? Sorting->BuildCopy(Position) : Sorting,\n+        (needData && Data) ? (deepCopy ? Data->BuildCopy(Position) : Data) : nullptr);\n }\n \n-NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::BuildRWPosition(std::shared_ptr<arrow::RecordBatch> batch, const ui32 position) const {\n+NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::BuildRWPosition(\n+    std::shared_ptr<arrow::RecordBatch> batch, const ui32 position) const {\n     std::vector<std::string> dataColumns;\n     if (Data) {\n         dataColumns = Data->GetFieldNames();\n@@ -98,7 +107,8 @@ TSortableBatchPosition::TFoundPosition TRWSortableBatchPosition::SkipToLower(con\n     return *pos;\n }\n \n-TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch, const std::vector<std::string>& columns) {\n+TSortableScanData::TSortableScanData(\n+    const ui64 position, const std::shared_ptr<TGeneralContainer>& batch, const std::vector<std::string>& columns) {\n     for (auto&& i : columns) {\n         auto c = batch->GetAccessorByNameOptional(i);\n         AFL_VERIFY(c)(\"column_name\", i)(\"columns\", JoinSeq(\",\", columns))(\"batch\", batch->DebugString());\n@@ -110,7 +120,8 @@ TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<\n     BuildPosition(position);\n }\n \n-TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& columns) {\n+TSortableScanData::TSortableScanData(\n+    const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& columns) {\n     for (auto&& i : columns) {\n         auto c = batch->GetColumnByName(i);\n         AFL_VERIFY(c)(\"column_name\", i)(\"columns\", JoinSeq(\",\", columns));\n@@ -134,10 +145,11 @@ TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<\n     BuildPosition(position);\n }\n \n-void TSortableScanData::AppendPositionTo(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, const ui64 position, ui64* recordSize) const {\n+void TSortableScanData::AppendPositionTo(\n+    const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, const ui64 position, ui64* recordSize) const {\n     AFL_VERIFY(builders.size() == PositionAddress.size());\n     for (ui32 i = 0; i < PositionAddress.size(); ++i) {\n-        AFL_VERIFY(NArrow::Append(*builders[i], *PositionAddress[i].GetArray(), position - PositionAddress[i].GetStartPosition(), recordSize));\n+        AFL_VERIFY(NArrow::Append(*builders[i], *PositionAddress[i].GetArray(), PositionAddress[i].GetAddress().GetLocalIndex(position), recordSize));\n     }\n }\n \n@@ -148,9 +160,9 @@ void TSortableScanData::BuildPosition(const ui64 position) {\n     StartPosition = 0;\n     LastInit = position;\n     for (auto&& i : Columns) {\n-        PositionAddress.emplace_back(i->GetChunk({}, position));\n-        StartPosition = std::max<ui64>(StartPosition, PositionAddress.back().GetStartPosition());\n-        FinishPosition = std::min<ui64>(FinishPosition, PositionAddress.back().GetFinishPosition());\n+        PositionAddress.emplace_back(i->GetChunkSlow(position));\n+        StartPosition = std::max<ui64>(StartPosition, PositionAddress.back().GetAddress().GetGlobalStartPosition());\n+        FinishPosition = std::min<ui64>(FinishPosition, PositionAddress.back().GetAddress().GetGlobalFinishPosition());\n         if (!recordsCount) {\n             recordsCount = i->GetRecordsCount();\n         } else {\n@@ -166,18 +178,19 @@ void TSortableScanData::BuildPosition(const ui64 position) {\n bool TSortableScanData::InitPosition(const ui64 position) {\n     AFL_VERIFY(position < RecordsCount);\n     if (position < FinishPosition && StartPosition <= position) {\n-        return false;\n+        return true;\n     }\n     LastInit = position;\n     ui32 idx = 0;\n     FinishPosition = Max<ui64>();\n     StartPosition = 0;\n     for (auto&& i : PositionAddress) {\n-        if (!i.Contains(position)) {\n-            i = Columns[idx]->GetChunk(i, position);\n+        if (!i.GetAddress().Contains(position)) {\n+            i = Columns[idx]->GetChunk(i.GetAddress(), position);\n         }\n-        StartPosition = std::max<ui64>(StartPosition, i.GetStartPosition());\n-        FinishPosition = std::min<ui64>(FinishPosition, i.GetFinishPosition());\n+        StartPosition = std::max<ui64>(StartPosition, i.GetAddress().GetGlobalStartPosition());\n+        FinishPosition = std::min<ui64>(FinishPosition, i.GetAddress().GetGlobalFinishPosition());\n+        AFL_VERIFY(i.GetAddress().Contains(position));\n         ++idx;\n     }\n     AFL_VERIFY(StartPosition < FinishPosition);\n@@ -212,14 +225,13 @@ void TCursor::AppendPositionTo(const std::vector<std::unique_ptr<arrow::ArrayBui\n     AFL_VERIFY(builders.size() == PositionAddress.size());\n     for (ui32 i = 0; i < PositionAddress.size(); ++i) {\n         AFL_VERIFY_DEBUG(builders[i]->type()->Equals(PositionAddress[i].GetArray()->type()));\n-        AFL_VERIFY(NArrow::Append(*builders[i], *PositionAddress[i].GetArray(), Position - PositionAddress[i].GetStartPosition(), recordSize));\n+        AFL_VERIFY(NArrow::Append(*builders[i], *PositionAddress[i].GetArray(), PositionAddress[i].GetAddress().GetLocalIndex(Position), recordSize));\n     }\n }\n \n TCursor::TCursor(const std::shared_ptr<arrow::Table>& table, const ui64 position, const std::vector<std::string>& columns)\n-    : Position(position)\n-{\n+    : Position(position) {\n     PositionAddress = TSortableScanData(position, table, columns).GetPositionAddress();\n }\n \n-}\n+}   // namespace NKikimr::NArrow::NMerger\ndiff --git a/ydb/core/formats/arrow/reader/position.h b/ydb/core/formats/arrow/reader/position.h\nindex c33f8e75ef01..78233e50b4a5 100644\n--- a/ydb/core/formats/arrow/reader/position.h\n+++ b/ydb/core/formats/arrow/reader/position.h\n@@ -1,10 +1,9 @@\n #pragma once\n-#include <ydb/core/formats/arrow/common/accessor.h>\n #include <ydb/core/formats/arrow/permutations.h>\n #include <ydb/core/formats/arrow/switch/switch_type.h>\n-#include <ydb/core/formats/arrow/switch/compare.h>\n #include <ydb/core/formats/arrow/common/container.h>\n \n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/actors/core/log.h>\n \n@@ -22,12 +21,12 @@ class TSortableScanData;\n class TCursor {\n private:\n     YDB_READONLY(ui64, Position, 0);\n-    std::vector<NAccessor::IChunkedArray::TCurrentChunkAddress> PositionAddress;\n+    std::vector<NAccessor::IChunkedArray::TFullDataAddress> PositionAddress;\n public:\n     TCursor() = default;\n     TCursor(const std::shared_ptr<arrow::Table>& table, const ui64 position, const std::vector<std::string>& columns);\n \n-    TCursor(const ui64 position, const std::vector<NAccessor::IChunkedArray::TCurrentChunkAddress>& addresses)\n+    TCursor(const ui64 position, const std::vector<NAccessor::IChunkedArray::TFullDataAddress>& addresses)\n         : Position(position)\n         , PositionAddress(addresses)\n     {\n@@ -64,7 +63,7 @@ class TCursor {\n class TSortableScanData {\n private:\n     ui64 RecordsCount = 0;\n-    YDB_READONLY_DEF(std::vector<NAccessor::IChunkedArray::TCurrentChunkAddress>, PositionAddress);\n+    YDB_READONLY_DEF(std::vector<NAccessor::IChunkedArray::TFullDataAddress>, PositionAddress);\n     YDB_READONLY_DEF(std::vector<std::shared_ptr<NAccessor::IChunkedArray>>, Columns);\n     YDB_READONLY_DEF(std::vector<std::shared_ptr<arrow::Field>>, Fields);\n     ui64 StartPosition = 0;\n@@ -87,19 +86,18 @@ class TSortableScanData {\n         BuildPosition(position);\n     }\n \n-    const NAccessor::IChunkedArray::TCurrentChunkAddress& GetPositionAddress(const ui32 colIdx) const {\n+    const NAccessor::IChunkedArray::TFullDataAddress& GetPositionAddress(const ui32 colIdx) const {\n         AFL_VERIFY(colIdx < PositionAddress.size());\n         return PositionAddress[colIdx];\n     }\n \n     ui32 GetPositionInChunk(const ui32 colIdx, const ui32 pos) const {\n         AFL_VERIFY(colIdx < PositionAddress.size());\n-        AFL_VERIFY(pos >= PositionAddress[colIdx].GetStartPosition());\n-        return pos - PositionAddress[colIdx].GetStartPosition();\n+        return PositionAddress[colIdx].GetAddress().GetLocalIndex(pos);\n     }\n \n-    std::shared_ptr<TSortableScanData> BuildCopy(const ui64 position) const {\n-        return std::make_shared<TSortableScanData>(position, RecordsCount, Columns, Fields);\n+    std::shared_ptr<TSortableScanData> BuildCopy(const ui64 /*position*/) const {\n+        return std::make_shared<TSortableScanData>(*this);\n     }\n \n     TCursor BuildCursor(const ui64 position) const {\n@@ -109,8 +107,8 @@ class TSortableScanData {\n         auto addresses = PositionAddress;\n         ui32 idx = 0;\n         for (auto&& i : addresses) {\n-            if (!i.Contains(position)) {\n-                i = Columns[idx]->GetChunk(i, position);\n+            if (!i.GetAddress().Contains(position)) {\n+                i = Columns[idx]->GetChunk(i.GetAddress(), position);\n             }\n             ++idx;\n         }\n@@ -129,15 +127,15 @@ class TSortableScanData {\n         } else {\n             for (ui32 idx = 0; idx < PositionAddress.size(); ++idx) {\n                 std::partial_ordering cmp = std::partial_ordering::equivalent;\n-                const bool containsSelf = PositionAddress[idx].Contains(position);\n-                const bool containsItem = item.PositionAddress[idx].Contains(itemPosition);\n+                const bool containsSelf = PositionAddress[idx].GetAddress().Contains(position);\n+                const bool containsItem = item.PositionAddress[idx].GetAddress().Contains(itemPosition);\n                 if (containsSelf && containsItem) {\n                     cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);\n                 } else if (containsSelf) {\n-                    auto temporaryAddress = item.Columns[idx]->GetChunk(item.PositionAddress[idx], itemPosition);\n+                    auto temporaryAddress = item.Columns[idx]->GetChunk(item.PositionAddress[idx].GetAddress(), itemPosition);\n                     cmp = PositionAddress[idx].Compare(position, temporaryAddress, itemPosition);\n                 } else if (containsItem) {\n-                    auto temporaryAddress = Columns[idx]->GetChunk(PositionAddress[idx], position);\n+                    auto temporaryAddress = Columns[idx]->GetChunk(PositionAddress[idx].GetAddress(), position);\n                     cmp = temporaryAddress.Compare(position, item.PositionAddress[idx], itemPosition);\n                 } else {\n                     AFL_VERIFY(false);\n@@ -153,7 +151,7 @@ class TSortableScanData {\n \n     void AppendPositionTo(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, const ui64 position, ui64* recordSize) const;\n \n-    bool InitPosition(const ui64 position);\n+    [[nodiscard]] bool InitPosition(const ui64 position);\n \n     std::shared_ptr<arrow::Table> Slice(const ui64 offset, const ui64 count) const {\n         std::vector<std::shared_ptr<arrow::ChunkedArray>> slicedArrays;\n@@ -210,6 +208,17 @@ class TSortableBatchPosition {\n     bool ReverseSort = false;\n     std::shared_ptr<TSortableScanData> Sorting;\n     std::shared_ptr<TSortableScanData> Data;\n+\n+    TSortableBatchPosition(const i64 position, const i64 recordsCount, const bool reverseSort, const std::shared_ptr<TSortableScanData>& sorting,\n+        const std::shared_ptr<TSortableScanData>& data)\n+        : Position(position)\n+        , RecordsCount(recordsCount)\n+        , ReverseSort(reverseSort)\n+        , Sorting(sorting)\n+        , Data(data) {\n+        AFL_VERIFY(IsAvailablePosition(Position));\n+    }\n+\n public:\n     TSortableBatchPosition() = default;\n \n@@ -221,7 +230,7 @@ class TSortableBatchPosition {\n         return RecordsCount;\n     }\n \n-    std::shared_ptr<TSortableScanData> GetSorting() const {\n+    const std::shared_ptr<TSortableScanData>& GetSorting() const {\n         return Sorting;\n     }\n \n@@ -240,16 +249,6 @@ class TSortableBatchPosition {\n         return Sorting->GetFields();\n     }\n \n-    TSortableBatchPosition(const i64 position, const i64 recordsCount, const bool reverseSort, const std::shared_ptr<TSortableScanData>& sorting, const std::shared_ptr<TSortableScanData>& data)\n-        : Position(position)\n-        , RecordsCount(recordsCount)\n-        , ReverseSort(reverseSort)\n-        , Sorting(sorting)\n-        , Data(data)\n-    {\n-\n-    }\n-\n     TSortableBatchPosition(const TRWSortableBatchPosition& source) = delete;\n     TSortableBatchPosition(TRWSortableBatchPosition& source) = delete;\n     TSortableBatchPosition(TRWSortableBatchPosition&& source) = delete;\n@@ -258,7 +257,7 @@ class TSortableBatchPosition {\n     TSortableBatchPosition operator= (TRWSortableBatchPosition& source) = delete;\n     TSortableBatchPosition operator= (TRWSortableBatchPosition&& source) = delete;\n \n-    TRWSortableBatchPosition BuildRWPosition() const;\n+    TRWSortableBatchPosition BuildRWPosition(const bool needData, const bool deepCopy) const;\n \n     std::shared_ptr<arrow::Table> SliceData(const ui64 offset, const ui64 count) const {\n         AFL_VERIFY(Data);\n@@ -316,7 +315,12 @@ class TSortableBatchPosition {\n         }\n     };\n \n-    static std::optional<TFoundPosition> FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound, const bool needGreater, const std::optional<ui32> includedStartPosition);\n+    [[nodiscard]] bool IsAvailablePosition(const i64 position) const {\n+        return 0 <= position && position < RecordsCount;\n+    }\n+\n+    static std::optional<TFoundPosition> FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound,\n+        const bool needGreater, const std::optional<ui32> includedStartPosition);\n     static std::optional<TSortableBatchPosition::TFoundPosition> FindPosition(TRWSortableBatchPosition& position, const ui64 posStart, const ui64 posFinish, const TSortableBatchPosition& forFound, const bool greater);\n \n     const TSortableScanData& GetData() const {\n@@ -488,7 +492,7 @@ class TIntervalPositions {\n     void AddPosition(TSortableBatchPosition&& position, const bool includePositionToLeftInterval) {\n         TIntervalPosition intervalPosition(std::move(position), includePositionToLeftInterval);\n         AddPosition(std::move(intervalPosition));\n-        }\n+    }\n \n     void AddPosition(const TSortableBatchPosition& position, const bool includePositionToLeftInterval) {\n         TIntervalPosition intervalPosition(position, includePositionToLeftInterval);\n@@ -502,23 +506,53 @@ class TRWSortableBatchPosition: public TSortableBatchPosition, public TMoveOnly\n public:\n     using TBase::TBase;\n \n-    bool NextPosition(const i64 delta) {\n+    [[nodiscard]] bool NextPosition(const i64 delta) {\n         return InitPosition(Position + delta);\n     }\n \n-    bool InitPosition(const i64 position) {\n-        if (position < RecordsCount && position >= 0) {\n-            Sorting->InitPosition(position);\n-            if (Data) {\n-                Data->InitPosition(position);\n+    [[nodiscard]] bool InitPosition(const i64 position) {\n+        if (!IsAvailablePosition(position)) {\n+            return false;\n+        }\n+        AFL_VERIFY(Sorting->InitPosition(position))(\"pos\", position)(\"count\", RecordsCount);\n+        if (Data) {\n+            AFL_VERIFY(Data->InitPosition(position))(\"pos\", position)(\"count\", RecordsCount);\n+        }\n+        Position = position;\n+        return true;\n+    }\n+\n+    class TAsymmetricPositionGuard: TNonCopyable {\n+    private:\n+        TRWSortableBatchPosition& Owner;\n+    public:\n+        TAsymmetricPositionGuard(TRWSortableBatchPosition& owner)\n+            : Owner(owner)\n+        {\n+        }\n+\n+        [[nodiscard]] bool InitSortingPosition(const i64 position) {\n+            if (!Owner.IsAvailablePosition(position)) {\n+                return false;\n             }\n-            Position = position;\n+            AFL_VERIFY(Owner.Sorting->InitPosition(position));\n+            Owner.Position = position;\n             return true;\n-        } else {\n-            return false;\n         }\n \n+        ~TAsymmetricPositionGuard() {\n+            if (Owner.IsAvailablePosition(Owner.Position)) {\n+                if (Owner.Data) {\n+                    AFL_VERIFY(Owner.Data->InitPosition(Owner.Position));\n+                }\n+            }\n+        }\n+    };\n+\n+    TAsymmetricPositionGuard CreateAsymmetricAccessGuard() {\n+        return TAsymmetricPositionGuard(*this);\n     }\n+\n     TSortableBatchPosition::TFoundPosition SkipToLower(const TSortableBatchPosition& forFound);\n \n     //  (-inf, it1), [it1, it2), [it2, it3), ..., [itLast, +inf)\ndiff --git a/ydb/core/formats/arrow/reader/result_builder.cpp b/ydb/core/formats/arrow/reader/result_builder.cpp\nindex deb4fe3e1427..9b412902b1ed 100644\n--- a/ydb/core/formats/arrow/reader/result_builder.cpp\n+++ b/ydb/core/formats/arrow/reader/result_builder.cpp\n@@ -1,9 +1,8 @@\n #include \"result_builder.h\"\n \n-#include <ydb/core/formats/arrow/common/validation.h>\n-\n #include <ydb/library/actors/core/log.h>\n #include <ydb/library/services/services.pb.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n \n #include <util/string/builder.h>\n \n@@ -64,7 +63,7 @@ std::shared_ptr<arrow::RecordBatch> TRecordBatchBuilder::Finalize() {\n     for (auto&& i : Builders) {\n         columns.emplace_back(NArrow::TStatusValidator::GetValid(i->Finish()));\n     }\n-    auto result = arrow::RecordBatch::Make(schema, columns.front()->length(), columns);\n+    auto result = arrow::RecordBatch::Make(schema, columns.front()->length(), std::move(columns));\n #ifndef NDEBUG\n     NArrow::TStatusValidator::Validate(result->ValidateFull());\n #endif\ndiff --git a/ydb/core/formats/arrow/reader/ya.make b/ydb/core/formats/arrow/reader/ya.make\nindex d57bb4e501ca..8dba6acf2efb 100644\n--- a/ydb/core/formats/arrow/reader/ya.make\n+++ b/ydb/core/formats/arrow/reader/ya.make\n@@ -2,11 +2,11 @@ LIBRARY()\n \n PEERDIR(\n     contrib/libs/apache/arrow\n-    ydb/core/formats/arrow/simple_builder\n     ydb/core/formats/arrow/switch\n     ydb/core/formats/arrow/common\n     ydb/library/actors/core\n     ydb/library/services\n+    ydb/library/formats/arrow\n )\n \n SRCS(\ndiff --git a/ydb/core/formats/arrow/save_load/loader.cpp b/ydb/core/formats/arrow/save_load/loader.cpp\nnew file mode 100644\nindex 000000000000..c9328f751d4a\n--- /dev/null\n+++ b/ydb/core/formats/arrow/save_load/loader.cpp\n@@ -0,0 +1,68 @@\n+#include \"loader.h\"\n+\n+#include <ydb/library/formats/arrow/common/validation.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+TString TColumnLoader::DebugString() const {\n+    TStringBuilder result;\n+    result << \"accessor_constructor:\" << AccessorConstructor->DebugString() << \";\";\n+    result << \"result_field:\" << ResultField->ToString() << \";\";\n+    if (Transformer) {\n+        result << \"transformer:\" << Transformer->DebugString() << \";\";\n+    }\n+    result << \"serializer:\" << Serializer->DebugString() << \";\";\n+    return result;\n+}\n+\n+TColumnLoader::TColumnLoader(NTransformation::ITransformer::TPtr transformer, const NSerialization::TSerializerContainer& serializer,\n+    const TConstructorContainer& accessorConstructor, const std::shared_ptr<arrow::Field>& resultField,\n+    const std::shared_ptr<arrow::Scalar>& defaultValue, const ui32 columnId)\n+    : Serializer(serializer)\n+    , Transformer(transformer)\n+    , AccessorConstructor(accessorConstructor)\n+    , ResultField(resultField)\n+    , DefaultValue(defaultValue)\n+    , ColumnId(columnId) {\n+    AFL_VERIFY(!!AccessorConstructor);\n+    AFL_VERIFY(ResultField);\n+    AFL_VERIFY(Serializer);\n+}\n+\n+const std::shared_ptr<arrow::Field>& TColumnLoader::GetField() const {\n+    return ResultField;\n+}\n+\n+arrow::Result<std::shared_ptr<arrow::RecordBatch>> TColumnLoader::Apply(const TString& data) const {\n+    Y_ABORT_UNLESS(Serializer);\n+    arrow::Result<std::shared_ptr<arrow::RecordBatch>> columnArray =\n+        Transformer ? Serializer->Deserialize(data) : Serializer->Deserialize(data, AccessorConstructor->GetExpectedSchema(ResultField));\n+    if (!columnArray.ok()) {\n+        return columnArray;\n+    }\n+    if (Transformer) {\n+        return Transformer->Transform(*columnArray);\n+    } else {\n+        return columnArray;\n+    }\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> TColumnLoader::ApplyRawVerified(const TString& data) const {\n+    return TStatusValidator::GetValid(Apply(data));\n+}\n+\n+std::shared_ptr<IChunkedArray> TColumnLoader::ApplyVerified(const TString& dataStr, const ui32 recordsCount) const {\n+    auto data = TStatusValidator::GetValid(Apply(dataStr));\n+    return BuildAccessor(data, TChunkConstructionData(recordsCount, DefaultValue, ResultField->type()));\n+}\n+\n+std::shared_ptr<IChunkedArray> TColumnLoader::BuildAccessor(\n+    const std::shared_ptr<arrow::RecordBatch>& batch, const TChunkConstructionData& chunkData) const {\n+    return AccessorConstructor->Construct(batch, chunkData).DetachResult();\n+}\n+\n+std::shared_ptr<NKikimr::NArrow::NAccessor::IChunkedArray> TColumnLoader::BuildDefaultAccessor(const ui32 recordsCount) const {\n+    return AccessorConstructor->ConstructDefault(TChunkConstructionData(recordsCount, DefaultValue, ResultField->type())).DetachResult();\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/save_load/loader.h b/ydb/core/formats/arrow/save_load/loader.h\nnew file mode 100644\nindex 000000000000..2d3119ac3fa8\n--- /dev/null\n+++ b/ydb/core/formats/arrow/save_load/loader.h\n@@ -0,0 +1,56 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>\n+#include <ydb/core/formats/arrow/serializer/abstract.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TColumnLoader {\n+private:\n+    NSerialization::TSerializerContainer Serializer;\n+    NTransformation::ITransformer::TPtr Transformer;\n+    YDB_READONLY_DEF(NAccessor::TConstructorContainer, AccessorConstructor);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Field>, ResultField);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Scalar>, DefaultValue);\n+    const ui32 ColumnId;\n+\n+    arrow::Result<std::shared_ptr<arrow::RecordBatch>> Apply(const TString& data) const;\n+    std::shared_ptr<IChunkedArray> BuildAccessor(\n+        const std::shared_ptr<arrow::RecordBatch>& batch, const TChunkConstructionData& chunkData) const;\n+\n+public:\n+    std::shared_ptr<IChunkedArray> BuildDefaultAccessor(const ui32 recordsCount) const;\n+\n+    bool IsEqualTo(const TColumnLoader& item) const {\n+        if (!!Transformer != !!item.Transformer) {\n+            return false;\n+        } else if (!!Transformer && !Transformer->IsEqualTo(*item.Transformer)) {\n+            return false;\n+        }\n+        if (!Serializer.IsEqualTo(item.Serializer)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    TString DebugString() const;\n+\n+    TColumnLoader(NTransformation::ITransformer::TPtr transformer, const NSerialization::TSerializerContainer& serializer,\n+        const NAccessor::TConstructorContainer& accessorConstructor, const std::shared_ptr<arrow::Field>& resultField,\n+        const std::shared_ptr<arrow::Scalar>& defaultValue, const ui32 columnId);\n+\n+    ui32 GetColumnId() const {\n+        return ColumnId;\n+    }\n+\n+    const std::shared_ptr<arrow::Field>& GetField() const;\n+\n+    std::shared_ptr<IChunkedArray> ApplyVerified(const TString& data, const ui32 expectedRecordsCount) const;\n+    std::shared_ptr<arrow::RecordBatch> ApplyRawVerified(const TString& data) const;\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/saver.cpp b/ydb/core/formats/arrow/save_load/saver.cpp\nsimilarity index 63%\nrename from ydb/core/tx/columnshard/engines/scheme/abstract/saver.cpp\nrename to ydb/core/formats/arrow/save_load/saver.cpp\nindex c15db92b8eec..95adebc76471 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/saver.cpp\n+++ b/ydb/core/formats/arrow/save_load/saver.cpp\n@@ -1,6 +1,6 @@\n #include \"saver.h\"\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NAccessor {\n \n TColumnSaver::TColumnSaver(NArrow::NTransformation::ITransformer::TPtr transformer, const NArrow::NSerialization::TSerializerContainer serializer)\n     : Transformer(transformer)\n@@ -21,10 +21,17 @@ TString TColumnSaver::Apply(std::shared_ptr<arrow::Array> data, std::shared_ptr<\n \n TString TColumnSaver::Apply(const std::shared_ptr<arrow::RecordBatch>& data) const {\n     Y_ABORT_UNLESS(Serializer);\n+    NArrow::NSerialization::TSerializerContainer serializer = Serializer;\n+    if (SerializerBySizeUpperBorder.size()) {\n+        auto it = SerializerBySizeUpperBorder.lower_bound(data->num_rows());\n+        if (it != SerializerBySizeUpperBorder.end()) {\n+            serializer = it->second;\n+        }\n+    }\n     if (Transformer) {\n-        return Serializer->SerializeFull(Transformer->Transform(data));\n+        return serializer->SerializeFull(Transformer->Transform(data));\n     } else {\n-        return Serializer->SerializePayload(data);\n+        return serializer->SerializePayload(data);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/saver.h b/ydb/core/formats/arrow/save_load/saver.h\nsimilarity index 55%\nrename from ydb/core/tx/columnshard/engines/scheme/abstract/saver.h\nrename to ydb/core/formats/arrow/save_load/saver.h\nindex c4d10c55a359..dd9feb4114f3 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/saver.h\n+++ b/ydb/core/formats/arrow/save_load/saver.h\n@@ -1,25 +1,30 @@\n #pragma once\n-#include <ydb/core/formats/arrow/transformer/abstract.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n+\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NAccessor {\n \n class TColumnSaver {\n private:\n     NArrow::NTransformation::ITransformer::TPtr Transformer;\n-    NArrow::NSerialization::TSerializerContainer Serializer;\n+    YDB_READONLY_DEF(NArrow::NSerialization::TSerializerContainer, Serializer);\n+    std::map<ui32, NArrow::NSerialization::TSerializerContainer> SerializerBySizeUpperBorder;\n+\n public:\n     TColumnSaver() = default;\n     TColumnSaver(NArrow::NTransformation::ITransformer::TPtr transformer, const NArrow::NSerialization::TSerializerContainer serializer);\n \n-    void ResetSerializer(const NArrow::NSerialization::TSerializerContainer& serializer) {\n-        AFL_VERIFY(serializer);\n+    void AddSerializerWithBorder(const ui32 upperBorder, const NArrow::NSerialization::TSerializerContainer& serializer) {\n         if (Serializer.IsCompatibleForExchange(serializer)) {\n-            Serializer = serializer;\n+            AFL_VERIFY(SerializerBySizeUpperBorder.emplace(upperBorder, serializer).second);\n         } else {\n-            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_reset_serializer\")(\"reason\", \"incompatible_serializers\");\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_add_serializer\")(\"reason\", \"incompatible_serializers\")(\n+                \"border\", upperBorder);\n         }\n     }\n \n@@ -30,5 +35,4 @@ class TColumnSaver {\n     TString Apply(const std::shared_ptr<arrow::RecordBatch>& data) const;\n };\n \n-\n-}\n\\ No newline at end of file\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/save_load/ya.make b/ydb/core/formats/arrow/save_load/ya.make\nnew file mode 100644\nindex 000000000000..7947aa1ab826\n--- /dev/null\n+++ b/ydb/core/formats/arrow/save_load/ya.make\n@@ -0,0 +1,19 @@\n+LIBRARY()\n+\n+SRCS(\n+    saver.cpp\n+    loader.cpp\n+)\n+\n+PEERDIR(\n+    ydb/library/actors/core\n+    contrib/libs/apache/arrow\n+    ydb/library/accessor\n+    ydb/library/conclusion\n+    ydb/library/formats/arrow/transformer\n+    ydb/library/formats/arrow/common\n+    ydb/core/formats/arrow/transformer\n+    ydb/core/formats/arrow/serializer\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/serializer/abstract.cpp b/ydb/core/formats/arrow/serializer/abstract.cpp\nindex 6347cd765b9b..8010197ae409 100644\n--- a/ydb/core/formats/arrow/serializer/abstract.cpp\n+++ b/ydb/core/formats/arrow/serializer/abstract.cpp\n@@ -21,8 +21,12 @@ NKikimr::TConclusionStatus TSerializerContainer::DeserializeFromRequest(NYql::TF\n     return TBase::GetObjectPtr()->DeserializeFromRequest(features);\n }\n \n-std::shared_ptr<NKikimr::NArrow::NSerialization::ISerializer> TSerializerContainer::GetDefaultSerializer() {\n+std::shared_ptr<ISerializer> TSerializerContainer::GetDefaultSerializer() {\n     return std::make_shared<TNativeSerializer>();\n }\n+std::shared_ptr<ISerializer> TSerializerContainer::GetFastestSerializer() {\n+    return std::make_shared<TNativeSerializer>(arrow::Compression::UNCOMPRESSED);\n+}\n+\n \n }\ndiff --git a/ydb/core/formats/arrow/serializer/abstract.h b/ydb/core/formats/arrow/serializer/abstract.h\nindex 1c8d9963dd7e..9811aaaf0f20 100644\n--- a/ydb/core/formats/arrow/serializer/abstract.h\n+++ b/ydb/core/formats/arrow/serializer/abstract.h\n@@ -4,9 +4,9 @@\n #include <ydb/library/conclusion/status.h>\n #include <ydb/services/metadata/abstract/request_features.h>\n #include <ydb/services/bg_tasks/abstract/interface.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n \n #include <ydb/library/conclusion/result.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/status.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n@@ -146,6 +146,7 @@ class TSerializerContainer: public NBackgroundTasks::TInterfaceProtoContainer<IS\n     using TBase::DeserializeFromProto;\n \n     static std::shared_ptr<ISerializer> GetDefaultSerializer();\n+    static std::shared_ptr<ISerializer> GetFastestSerializer();\n \n     TConclusionStatus DeserializeFromProto(const NKikimrSchemeOp::TCompressionOptions& proto);\n \ndiff --git a/ydb/core/formats/arrow/serializer/native.cpp b/ydb/core/formats/arrow/serializer/native.cpp\nindex 7b422a8c1cb1..4b90286001d2 100644\n--- a/ydb/core/formats/arrow/serializer/native.cpp\n+++ b/ydb/core/formats/arrow/serializer/native.cpp\n@@ -2,10 +2,10 @@\n #include \"stream.h\"\n #include \"parsing.h\"\n #include <ydb/core/formats/arrow/dictionary/conversion.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n \n #include <ydb/library/services/services.pb.h>\n #include <ydb/library/actors/core/log.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/ipc/dictionary.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/buffer.h>\ndiff --git a/ydb/core/formats/arrow/serializer/ya.make b/ydb/core/formats/arrow/serializer/ya.make\nindex bf7e091ab4bf..8c9fb49fe08f 100644\n--- a/ydb/core/formats/arrow/serializer/ya.make\n+++ b/ydb/core/formats/arrow/serializer/ya.make\n@@ -2,9 +2,9 @@ LIBRARY()\n \n PEERDIR(\n     contrib/libs/apache/arrow\n-    ydb/core/formats/arrow/common\n     ydb/services/metadata/abstract\n     ydb/library/actors/core\n+    ydb/library/formats/arrow/common\n     ydb/core/protos\n )\n \ndiff --git a/ydb/core/formats/arrow/size_calcer.cpp b/ydb/core/formats/arrow/size_calcer.cpp\nindex c718b7807410..a79f52eb5799 100644\n--- a/ydb/core/formats/arrow/size_calcer.cpp\n+++ b/ydb/core/formats/arrow/size_calcer.cpp\n@@ -1,5 +1,5 @@\n #include \"size_calcer.h\"\n-#include \"switch_type.h\"\n+#include \"switch/switch_type.h\"\n #include \"arrow_helpers.h\"\n #include \"dictionary/conversion.h\"\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n@@ -50,204 +50,16 @@ TConclusion<std::vector<TSerializedBatch>> SplitByBlobSize(const std::shared_ptr\n     return result;\n }\n \n-ui32 TRowSizeCalculator::GetRowBitWidth(const ui32 row) const {\n-    Y_ABORT_UNLESS(Prepared);\n-    ui32 result = CommonSize;\n-    for (auto&& c : BinaryColumns) {\n-        result += GetBitWidthAligned(c->GetView(row).size() * 8);\n-    }\n-    for (auto&& c : StringColumns) {\n-        result += GetBitWidthAligned(c->GetView(row).size() * 8);\n-    }\n-    return result;\n-}\n-\n-bool TRowSizeCalculator::InitBatch(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    Batch = batch;\n-    CommonSize = 0;\n-    BinaryColumns.clear();\n-    StringColumns.clear();\n-    Prepared = false;\n-    for (ui32 i = 0; i < (ui32)Batch->num_columns(); ++i) {\n-        auto fSize = std::dynamic_pointer_cast<arrow::FixedWidthType>(Batch->column(i)->type());\n-        if (fSize) {\n-            CommonSize += GetBitWidthAligned(fSize->bit_width());\n-        } else {\n-            auto c = Batch->column(i);\n-            if (c->type()->id() == arrow::Type::BINARY) {\n-                const arrow::BinaryArray& viewArray = static_cast<const arrow::BinaryArray&>(*c);\n-                BinaryColumns.emplace_back(&viewArray);\n-            } else if (c->type()->id() == arrow::Type::STRING) {\n-                const arrow::StringArray& viewArray = static_cast<const arrow::StringArray&>(*c);\n-                StringColumns.emplace_back(&viewArray);\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-    Prepared = true;\n-    return true;\n-}\n-\n-ui32 TRowSizeCalculator::GetRowBytesSize(const ui32 row) const {\n-    const ui32 bitsWidth = GetRowBitWidth(row);\n-    ui32 result = bitsWidth / 8;\n-    if (bitsWidth % 8) {\n-        ++result;\n-    }\n-    return result;\n-}\n-\n-ui64 GetArrayMemorySize(const std::shared_ptr<arrow::ArrayData>& data) {\n-    if (!data) {\n-        return 0;\n-    }\n-    ui64 result = 0;\n-    for (auto&& i : data->buffers) {\n-        if (i) {\n-            result += i->capacity();\n-        }\n-    }\n-    for (auto&& i : data->child_data) {\n-        for (auto&& b : i->buffers) {\n-            if (b) {\n-                result += b->capacity();\n-            }\n-        }\n-    }\n-    if (data->dictionary) {\n-        for (auto&& b : data->dictionary->buffers) {\n-            if (b) {\n-                result += b->capacity();\n-            }\n-        }\n-    }\n-    return result;\n-}\n-\n-\n-ui64 GetBatchDataSize(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    if (!batch) {\n-        return 0;\n-    }\n-    ui64 bytes = 0;\n-    for (auto& column : batch->columns()) {\n-        bytes += GetArrayDataSize(column);\n-    }\n-    return bytes;\n-}\n-\n-ui64 GetBatchMemorySize(const std::shared_ptr<arrow::RecordBatch>& batch) {\n-    if (!batch) {\n-        return 0;\n-    }\n-    ui64 bytes = 0;\n-    for (auto& column : batch->column_data()) {\n-        bytes += GetArrayMemorySize(column);\n-    }\n-    return bytes;\n-}\n-\n-ui64 GetTableMemorySize(const std::shared_ptr<arrow::Table>& batch) {\n-    if (!batch) {\n-        return 0;\n-    }\n-    ui64 bytes = 0;\n-    for (auto& column : batch->columns()) {\n-        for (auto&& chunk : column->chunks()) {\n-            bytes += GetArrayMemorySize(chunk->data());\n-        }\n-    }\n-    return bytes;\n-}\n-\n-ui64 GetTableDataSize(const std::shared_ptr<arrow::Table>& batch) {\n-    if (!batch) {\n-        return 0;\n-    }\n-    ui64 bytes = 0;\n-    for (auto& column : batch->columns()) {\n-        for (auto&& chunk : column->chunks()) {\n-            bytes += GetArrayDataSize(chunk);\n-        }\n-    }\n-    return bytes;\n-}\n-\n-template <typename TType>\n-ui64 GetArrayDataSizeImpl(const std::shared_ptr<arrow::Array>& column) {\n-    return sizeof(typename TType::c_type) * column->length();\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::NullType>(const std::shared_ptr<arrow::Array>& column) {\n-    return column->length() * 8; // Special value for empty lines\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::StringType>(const std::shared_ptr<arrow::Array>& column) {\n-    auto typedColumn = std::static_pointer_cast<arrow::StringArray>(column);\n-    return typedColumn->total_values_length() + sizeof(arrow::StringArray::offset_type) * column->length();\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::LargeStringType>(const std::shared_ptr<arrow::Array>& column) {\n-    auto typedColumn = std::static_pointer_cast<arrow::LargeStringArray>(column);\n-    return typedColumn->total_values_length() + sizeof(arrow::LargeStringArray::offset_type) * column->length();\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::BinaryType>(const std::shared_ptr<arrow::Array>& column) {\n-    auto typedColumn = std::static_pointer_cast<arrow::BinaryArray>(column);\n-    return typedColumn->total_values_length() + sizeof(arrow::BinaryArray::offset_type) * column->length();\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::LargeBinaryType>(const std::shared_ptr<arrow::Array>& column) {\n-    auto typedColumn = std::static_pointer_cast<arrow::LargeBinaryArray>(column);\n-    return typedColumn->total_values_length() + sizeof(arrow::LargeBinaryArray::offset_type) * column->length();\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::FixedSizeBinaryType>(const std::shared_ptr<arrow::Array>& column) {\n-    auto typedColumn = std::static_pointer_cast<arrow::FixedSizeBinaryArray>(column);\n-    return typedColumn->byte_width() * typedColumn->length();\n-}\n-\n-template <>\n-ui64 GetArrayDataSizeImpl<arrow::Decimal128Type>(const std::shared_ptr<arrow::Array>& column) {\n-    return sizeof(ui64) * 2 * column->length();\n-}\n-\n-ui64 GetArrayDataSize(const std::shared_ptr<arrow::Array>& column) {\n-    auto type = column->type();\n-    if (type->id() == arrow::Type::DICTIONARY) {\n-        auto dictArray = static_pointer_cast<arrow::DictionaryArray>(column);\n-        return GetDictionarySize(dictArray);\n-    }\n-    ui64 bytes = 0;\n-    bool success = SwitchTypeWithNull(type->id(), [&]<typename TType>(TTypeWrapper<TType> typeHolder) {\n-        Y_UNUSED(typeHolder);\n-        bytes = GetArrayDataSizeImpl<TType>(column);\n-        return true;\n-    });\n-\n-    // Add null bit mask overhead if any.\n-    if (HasNulls(column)) {\n-        bytes += column->length() / 8 + 1;\n-    }\n-\n-    Y_DEBUG_ABORT_UNLESS(success, \"Unsupported arrow type %s\", type->ToString().data());\n-    return bytes;\n-}\n-\n NKikimr::NArrow::TSerializedBatch TSerializedBatch::Build(std::shared_ptr<arrow::RecordBatch> batch, const TBatchSplitttingContext& context) {\n-    std::optional<TString> specialKeys;\n+    std::optional<TString> specialKeysPayload;\n+    std::optional<TString> specialKeysFull;\n     if (context.GetFieldsForSpecialKeys().size()) {\n-        specialKeys = TFirstLastSpecialKeys(batch, context.GetFieldsForSpecialKeys()).SerializeToString();\n+        TFirstLastSpecialKeys specialKeys(batch, context.GetFieldsForSpecialKeys());\n+        specialKeysPayload = specialKeys.SerializePayloadToString();\n+        specialKeysFull = specialKeys.SerializeFullToString();\n     }\n-    return TSerializedBatch(NArrow::SerializeSchema(*batch->schema()), NArrow::SerializeBatchNoCompression(batch), batch->num_rows(), \n-        NArrow::GetBatchDataSize(batch), specialKeys);\n+    return TSerializedBatch(NArrow::SerializeBatchNoCompression(batch), batch->num_rows(),\n+        NArrow::GetBatchDataSize(batch), specialKeysPayload, specialKeysFull);\n }\n \n TConclusionStatus TSerializedBatch::BuildWithLimit(std::shared_ptr<arrow::RecordBatch> batch, const TBatchSplitttingContext& context, std::optional<TSerializedBatch>& sbL, std::optional<TSerializedBatch>& sbR) {\n@@ -291,7 +103,7 @@ TConclusion<std::vector<TSerializedBatch>> TSerializedBatch::BuildWithLimit(std:\n }\n \n TString TSerializedBatch::DebugString() const {\n-    return TStringBuilder() << \"(data_size=\" << Data.size() << \";schema_data_size=\" << SchemaData.size() << \";rows_count=\" << RowsCount << \";raw_bytes=\" << RawBytes << \";)\";\n+    return TStringBuilder() << \"(data_size=\" << Data.size() << \";rows_count=\" << RowsCount << \";raw_bytes=\" << RawBytes << \";)\";\n }\n \n }\ndiff --git a/ydb/core/formats/arrow/size_calcer.h b/ydb/core/formats/arrow/size_calcer.h\nindex d260427ade3a..00e55f9ca20b 100644\n--- a/ydb/core/formats/arrow/size_calcer.h\n+++ b/ydb/core/formats/arrow/size_calcer.h\n@@ -3,6 +3,7 @@\n \n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/conclusion/result.h>\n+#include <ydb/library/formats/arrow/size_calcer.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_binary.h>\n@@ -11,43 +12,6 @@\n \n namespace NKikimr::NArrow {\n \n-class TRowSizeCalculator {\n-private:\n-    std::shared_ptr<arrow::RecordBatch> Batch;\n-    ui32 CommonSize = 0;\n-    std::vector<const arrow::BinaryArray*> BinaryColumns;\n-    std::vector<const arrow::StringArray*> StringColumns;\n-    bool Prepared = false;\n-    const ui32 AlignBitsCount = 1;\n-\n-    ui32 GetBitWidthAligned(const ui32 bitWidth) const {\n-        if (AlignBitsCount == 1) {\n-            return bitWidth;\n-        }\n-        ui32 result = bitWidth / AlignBitsCount;\n-        if (bitWidth % AlignBitsCount) {\n-            result += 1;\n-        }\n-        result *= AlignBitsCount;\n-        return result;\n-    }\n-\n-public:\n-\n-    ui64 GetApproxSerializeSize(const ui64 dataSize) const {\n-        return Max<ui64>(dataSize * 1.05, dataSize + Batch->num_columns() * 8);\n-    }\n-\n-    TRowSizeCalculator(const ui32 alignBitsCount)\n-        : AlignBitsCount(alignBitsCount)\n-    {\n-\n-    }\n-    bool InitBatch(const std::shared_ptr<arrow::RecordBatch>& batch);\n-    ui32 GetRowBitWidth(const ui32 row) const;\n-    ui32 GetRowBytesSize(const ui32 row) const;\n-};\n-\n class TBatchSplitttingContext {\n private:\n     YDB_ACCESSOR(ui64, SizeLimit, 6 * 1024 * 1024);\n@@ -70,23 +34,29 @@ class TBatchSplitttingContext {\n \n class TSerializedBatch {\n private:\n-    YDB_READONLY_DEF(TString, SchemaData);\n     YDB_READONLY_DEF(TString, Data);\n     YDB_READONLY(ui32, RowsCount, 0);\n     YDB_READONLY(ui32, RawBytes, 0);\n-    std::optional<TString> SpecialKeys;\n+    std::optional<TString> SpecialKeysFull;\n+    std::optional<TString> SpecialKeysPayload;\n+\n public:\n     size_t GetSize() const {\n         return Data.size();\n     }\n \n-    const TString& GetSpecialKeysSafe() const {\n-        AFL_VERIFY(SpecialKeys);\n-        return *SpecialKeys;\n+    const TString& GetSpecialKeysPayloadSafe() const {\n+        AFL_VERIFY(SpecialKeysPayload);\n+        return *SpecialKeysPayload;\n+    }\n+\n+    const TString& GetSpecialKeysFullSafe() const {\n+        AFL_VERIFY(SpecialKeysFull);\n+        return *SpecialKeysFull;\n     }\n \n     bool HasSpecialKeys() const {\n-        return !!SpecialKeys;\n+        return !!SpecialKeysFull;\n     }\n \n     TString DebugString() const;\n@@ -95,27 +65,17 @@ class TSerializedBatch {\n     static TConclusionStatus BuildWithLimit(std::shared_ptr<arrow::RecordBatch> batch, const TBatchSplitttingContext& context, std::optional<TSerializedBatch>& sbL, std::optional<TSerializedBatch>& sbR);\n     static TSerializedBatch Build(std::shared_ptr<arrow::RecordBatch> batch, const TBatchSplitttingContext& context);\n \n-    TSerializedBatch(TString&& schemaData, TString&& data, const ui32 rowsCount, const ui32 rawBytes, const std::optional<TString>& specialKeys)\n-        : SchemaData(schemaData)\n-        , Data(data)\n+    TSerializedBatch(TString&& data, const ui32 rowsCount, const ui32 rawBytes,\n+        const std::optional<TString>& specialKeysPayload, const std::optional<TString>& specialKeysFull)\n+        : Data(data)\n         , RowsCount(rowsCount)\n         , RawBytes(rawBytes)\n-        , SpecialKeys(specialKeys)\n-    {\n-\n+        , SpecialKeysFull(specialKeysFull)\n+        , SpecialKeysPayload(specialKeysPayload) {\n+        AFL_VERIFY(!!SpecialKeysPayload == !!SpecialKeysFull);\n     }\n };\n \n TConclusion<std::vector<TSerializedBatch>> SplitByBlobSize(const std::shared_ptr<arrow::RecordBatch>& batch, const TBatchSplitttingContext& context);\n \n-// Return size in bytes including size of bitmap mask\n-ui64 GetBatchDataSize(const std::shared_ptr<arrow::RecordBatch>& batch);\n-ui64 GetTableDataSize(const std::shared_ptr<arrow::Table>& batch);\n-// Return size in bytes including size of bitmap mask\n-ui64 GetArrayMemorySize(const std::shared_ptr<arrow::ArrayData>& data);\n-ui64 GetBatchMemorySize(const std::shared_ptr<arrow::RecordBatch>&batch);\n-ui64 GetTableMemorySize(const std::shared_ptr<arrow::Table>& batch);\n-// Return size in bytes *not* including size of bitmap mask\n-ui64 GetArrayDataSize(const std::shared_ptr<arrow::Array>& column);\n-\n }\ndiff --git a/ydb/core/formats/arrow/special_keys.cpp b/ydb/core/formats/arrow/special_keys.cpp\nindex 0b97fb3f25ed..0745fad0e559 100644\n--- a/ydb/core/formats/arrow/special_keys.cpp\n+++ b/ydb/core/formats/arrow/special_keys.cpp\n@@ -27,12 +27,12 @@ NKikimr::NArrow::TReplaceKey TSpecialKeys::GetKeyByIndex(const ui32 position, co\n     }\n }\n \n-TString TSpecialKeys::SerializeToString() const {\n-    return NArrow::NSerialization::TSerializerContainer::GetDefaultSerializer()->SerializeFull(Data);\n+TString TSpecialKeys::SerializePayloadToString() const {\n+    return NArrow::NSerialization::TSerializerContainer::GetFastestSerializer()->SerializePayload(Data);\n }\n \n-TString TSpecialKeys::SerializeToStringDataOnlyNoCompression() const {\n-    return NArrow::SerializeBatchNoCompression(Data);\n+TString TSpecialKeys::SerializeFullToString() const {\n+    return NArrow::NSerialization::TSerializerContainer::GetFastestSerializer()->SerializeFull(Data);\n }\n \n ui64 TSpecialKeys::GetMemoryBytes() const {\n@@ -50,13 +50,17 @@ TFirstLastSpecialKeys::TFirstLastSpecialKeys(const std::shared_ptr<arrow::Record\n     if (columnNames.size()) {\n         keyBatch = NArrow::TColumnOperator().VerifyIfAbsent().Extract(batch, columnNames);\n     }\n-    std::vector<ui64> indexes = {0};\n-    if (batch->num_rows() > 1) {\n-        indexes.emplace_back(batch->num_rows() - 1);\n-    }\n+    if (keyBatch->num_rows() <= 2) {\n+        Data = keyBatch;\n+    } else {\n+        std::vector<ui64> indexes = { 0 };\n+        if (batch->num_rows() > 1) {\n+            indexes.emplace_back(batch->num_rows() - 1);\n+        }\n \n-    Data = NArrow::CopyRecords(keyBatch, indexes);\n-    Y_ABORT_UNLESS(Data->num_rows() == 1 || Data->num_rows() == 2);\n+        Data = NArrow::CopyRecords(keyBatch, indexes);\n+        Y_ABORT_UNLESS(Data->num_rows() == 1 || Data->num_rows() == 2);\n+    }\n }\n \n TMinMaxSpecialKeys::TMinMaxSpecialKeys(std::shared_ptr<arrow::RecordBatch> batch, const std::shared_ptr<arrow::Schema>& schema) {\ndiff --git a/ydb/core/formats/arrow/special_keys.h b/ydb/core/formats/arrow/special_keys.h\nindex d56e658fbb68..7559b4a5f7fb 100644\n--- a/ydb/core/formats/arrow/special_keys.h\n+++ b/ydb/core/formats/arrow/special_keys.h\n@@ -1,5 +1,8 @@\n #pragma once\n-#include <ydb/core/formats/arrow/replace_key.h>\n+\n+#include \"arrow_helpers.h\"\n+\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n \n namespace NKikimr::NArrow {\n@@ -22,8 +25,6 @@ class TSpecialKeys {\n public:\n     ui64 GetMemoryBytes() const;\n \n-    TString SerializeToStringDataOnlyNoCompression() const;\n-\n     TSpecialKeys(const TString& data, const std::shared_ptr<arrow::Schema>& schema) {\n         Data = NArrow::DeserializeBatch(data, schema);\n         Y_ABORT_UNLESS(Data);\n@@ -34,7 +35,8 @@ class TSpecialKeys {\n         Y_ABORT_UNLESS(DeserializeFromString(data));\n     }\n \n-    TString SerializeToString() const;\n+    TString SerializePayloadToString() const;\n+    TString SerializeFullToString() const;\n     ui64 GetMemorySize() const;\n };\n \ndiff --git a/ydb/core/formats/arrow/splitter/scheme_info.cpp b/ydb/core/formats/arrow/splitter/scheme_info.cpp\nnew file mode 100644\nindex 000000000000..35a8fcc5c035\n--- /dev/null\n+++ b/ydb/core/formats/arrow/splitter/scheme_info.cpp\n@@ -0,0 +1,13 @@\n+#include \"scheme_info.h\"\n+\n+namespace NKikimr::NArrow::NSplitter {\n+\n+NAccessor::TColumnSaver ISchemaDetailInfo::GetColumnSaver(const ui32 columnId) const {\n+    auto saver = DoGetColumnSaver(columnId);\n+    if (OverrideSerializer) {\n+        saver.AddSerializerWithBorder(Max<ui32>(), *OverrideSerializer);\n+    }\n+    return saver;\n+}\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/splitter/scheme_info.h b/ydb/core/formats/arrow/splitter/scheme_info.h\nsimilarity index 60%\nrename from ydb/core/tx/columnshard/splitter/scheme_info.h\nrename to ydb/core/formats/arrow/splitter/scheme_info.h\nindex 1e72e63e9d35..0bb30e97300a 100644\n--- a/ydb/core/tx/columnshard/splitter/scheme_info.h\n+++ b/ydb/core/formats/arrow/splitter/scheme_info.h\n@@ -1,26 +1,29 @@\n #pragma once\n-#include \"stats.h\"\n \n-#include <ydb/core/tx/columnshard/engines/scheme/column_features.h>\n+#include <ydb/core/formats/arrow/serializer/abstract.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n \n+#include <ydb/library/formats/arrow/splitter/stats.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NSplitter {\n \n class ISchemaDetailInfo {\n private:\n-    YDB_ACCESSOR_DEF(std::optional<NArrow::NSerialization::TSerializerContainer>, OverrideSerializer);\n+    YDB_ACCESSOR_DEF(std::optional<NSerialization::TSerializerContainer>, OverrideSerializer);\n+\n protected:\n-    virtual TColumnSaver DoGetColumnSaver(const ui32 columnId) const = 0;\n+    virtual NAccessor::TColumnSaver DoGetColumnSaver(const ui32 columnId) const = 0;\n+\n public:\n     using TPtr = std::shared_ptr<ISchemaDetailInfo>;\n     virtual ~ISchemaDetailInfo() = default;\n     virtual ui32 GetColumnId(const std::string& fieldName) const = 0;\n-    TColumnSaver GetColumnSaver(const ui32 columnId) const;\n+    NAccessor::TColumnSaver GetColumnSaver(const ui32 columnId) const;\n     virtual std::shared_ptr<arrow::Field> GetField(const ui32 columnId) const = 0;\n     virtual std::optional<TColumnSerializationStat> GetColumnSerializationStats(const ui32 columnId) const = 0;\n     virtual bool NeedMinMaxForColumn(const ui32 columnId) const = 0;\n     virtual bool IsSortedColumn(const ui32 columnId) const = 0;\n     virtual std::optional<TBatchSerializationStat> GetBatchSerializationStats(const std::shared_ptr<arrow::RecordBatch>& rb) const = 0;\n };\n-}\n+}   // namespace NKikimr::NArrow::NSplitter\ndiff --git a/ydb/core/tx/columnshard/splitter/simple.cpp b/ydb/core/formats/arrow/splitter/simple.cpp\nsimilarity index 78%\nrename from ydb/core/tx/columnshard/splitter/simple.cpp\nrename to ydb/core/formats/arrow/splitter/simple.cpp\nindex 0af14f0ff9b4..a113084b531b 100644\n--- a/ydb/core/tx/columnshard/splitter/simple.cpp\n+++ b/ydb/core/formats/arrow/splitter/simple.cpp\n@@ -1,27 +1,11 @@\n #include \"simple.h\"\n-#include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n-#include <ydb/core/formats/arrow/size_calcer.h>\n-#include <util/string/join.h>\n \n-namespace NKikimr::NOlap {\n-\n-std::vector<std::shared_ptr<IPortionDataChunk>> TSplittedColumnChunk::DoInternalSplitImpl(const TColumnSaver& saver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const {\n-    auto chunks = TSimpleSplitter(saver, counters).SplitBySizes(Data.GetSlicedBatch(), Data.GetSerializedChunk(), splitSizes);\n-    std::vector<std::shared_ptr<IPortionDataChunk>> newChunks;\n-    for (auto&& i : chunks) {\n-        newChunks.emplace_back(std::make_shared<TSplittedColumnChunk>(GetColumnId(), i, SchemaInfo));\n-    }\n-    return newChunks;\n-}\n+#include <ydb/core/formats/arrow/size_calcer.h>\n \n-TString TSplittedColumnChunk::DoDebugString() const {\n-    return TStringBuilder() << \"records_count=\" << GetRecordsCount() << \";data=\" << NArrow::DebugJson(Data.GetSlicedBatch(), 3, 3) << \";\";\n-}\n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <util/string/join.h>\n \n-ui64 TSplittedColumnChunk::DoGetRawBytesImpl() const {\n-    return NArrow::GetBatchDataSize(Data.GetSlicedBatch());\n-}\n+namespace NKikimr::NArrow::NSplitter {\n \n std::vector<TSaverSplittedChunk> TSimpleSplitter::Split(const std::shared_ptr<arrow::Array>& data, const std::shared_ptr<arrow::Field>& field, const ui32 maxBlobSize) const {\n     AFL_VERIFY(data);\n@@ -38,27 +22,27 @@ class TSplitChunk {\n     ui32 SplitFactor = 0;\n     ui32 Iterations = 0;\n     ui32 MaxBlobSize = 8 * 1024 * 1024;\n-    TColumnSaver ColumnSaver;\n-    std::shared_ptr<NColumnShard::TSplitterCounters> Counters;\n+    NAccessor::TColumnSaver ColumnSaver;\n+\n public:\n-    TSplitChunk(const ui32 baseSplitFactor, const ui32 maxBlobSize, const std::shared_ptr<arrow::RecordBatch>& data, const TColumnSaver& columnSaver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters)\n+    TSplitChunk(const ui32 baseSplitFactor, const ui32 maxBlobSize, const std::shared_ptr<arrow::RecordBatch>& data,\n+        const NAccessor::TColumnSaver& columnSaver)\n         : Data(data)\n         , SplitFactor(baseSplitFactor)\n         , MaxBlobSize(maxBlobSize)\n         , ColumnSaver(columnSaver)\n-        , Counters(counters)\n     {\n         AFL_VERIFY(Data && Data->num_rows());\n         AFL_VERIFY(SplitFactor);\n     }\n \n-    TSplitChunk(const ui32 baseSplitFactor, const ui32 maxBlobSize, const std::shared_ptr<arrow::RecordBatch>& data, TString&& serializedData, const TColumnSaver& columnSaver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters)\n+    TSplitChunk(const ui32 baseSplitFactor, const ui32 maxBlobSize, const std::shared_ptr<arrow::RecordBatch>& data, TString&& serializedData,\n+        const NAccessor::TColumnSaver& columnSaver)\n         : Data(data)\n         , Result(TSaverSplittedChunk(data, std::move(serializedData)))\n         , SplitFactor(baseSplitFactor)\n         , MaxBlobSize(maxBlobSize)\n         , ColumnSaver(columnSaver)\n-        , Counters(counters)\n     {\n         AFL_VERIFY(Data && Data->num_rows());\n         AFL_VERIFY(SplitFactor);\n@@ -68,18 +52,17 @@ class TSplitChunk {\n         while (true) {\n             AFL_VERIFY(!Result);\n             AFL_VERIFY(++Iterations < 100);\n-            AFL_VERIFY(SplitFactor <= Data->num_rows())(\"factor\", SplitFactor)(\"records\", Data->num_rows())(\"iteration\", Iterations)(\"size\", NArrow::GetBatchDataSize(Data));\n+            AFL_VERIFY(SplitFactor <= Data->num_rows())(\"factor\", SplitFactor)(\"records\", Data->num_rows())(\"iteration\", Iterations)(\n+                                          \"size\", NArrow::GetBatchDataSize(Data));\n             bool found = false;\n             std::vector<TSplitChunk> result;\n             if (SplitFactor == 1) {\n                 TString blob = ColumnSaver.Apply(Data);\n                 if (blob.size() < MaxBlobSize) {\n-                    Counters->SimpleSplitter.OnCorrectSerialized(blob.size());\n                     Result = TSaverSplittedChunk(Data, std::move(blob));\n                     found = true;\n                     result.emplace_back(*this);\n                 } else {\n-                    Counters->SimpleSplitter.OnTrashSerialized(blob.size());\n                     TBatchSerializationStat stats(blob.size(), Data->num_rows(), NArrow::GetBatchDataSize(Data));\n                     SplitFactor = stats.PredictOptimalSplitFactor(Data->num_rows(), MaxBlobSize).value_or(1);\n                     if (SplitFactor == 1) {\n@@ -98,7 +81,6 @@ class TSplitChunk {\n                     auto slice = Data->Slice(it.GetPosition(), it.GetCurrentPackSize());\n                     TString blob = ColumnSaver.Apply(slice);\n                     if (blob.size() >= MaxBlobSize) {\n-                        Counters->SimpleSplitter.OnTrashSerialized(blob.size());\n                         if (!badStartPosition) {\n                             badStartPosition = it.GetPosition();\n                         }\n@@ -107,25 +89,24 @@ class TSplitChunk {\n                         ++badBatchCount;\n                         Y_ABORT_UNLESS(!linearSplitting.IsMinimalGranularity());\n                     } else {\n-                        Counters->SimpleSplitter.OnCorrectSerialized(blob.size());\n                         if (badStartPosition) {\n                             AFL_VERIFY(badBatchRecordsCount && badBatchCount)(\"count\", badBatchCount)(\"records\", badBatchRecordsCount);\n                             auto badSlice = Data->Slice(*badStartPosition, badBatchRecordsCount);\n                             TBatchSerializationStat stats(badBatchSerializedSize, badBatchRecordsCount, Max<ui32>());\n-                            result.emplace_back(std::max<ui32>(stats.PredictOptimalSplitFactor(badBatchRecordsCount, MaxBlobSize).value_or(1), badBatchCount) + 1, MaxBlobSize, badSlice, ColumnSaver, Counters);\n+                            result.emplace_back(std::max<ui32>(stats.PredictOptimalSplitFactor(badBatchRecordsCount, MaxBlobSize).value_or(1), badBatchCount) + 1, MaxBlobSize, badSlice, ColumnSaver);\n                             badStartPosition = {};\n                             badBatchRecordsCount = 0;\n                             badBatchCount = 0;\n                             badBatchSerializedSize = 0;\n                         }\n                         found = true;\n-                        result.emplace_back(1, MaxBlobSize, slice, std::move(blob), ColumnSaver, Counters);\n+                        result.emplace_back(1, MaxBlobSize, slice, std::move(blob), ColumnSaver);\n                     }\n                 }\n                 if (badStartPosition) {\n                     auto badSlice = Data->Slice(*badStartPosition, badBatchRecordsCount);\n                     TBatchSerializationStat stats(badBatchSerializedSize, badBatchRecordsCount, Max<ui32>());\n-                    result.emplace_back(std::max<ui32>(stats.PredictOptimalSplitFactor(badBatchRecordsCount, MaxBlobSize).value_or(1), badBatchCount) + 1, MaxBlobSize, badSlice, ColumnSaver, Counters);\n+                    result.emplace_back(std::max<ui32>(stats.PredictOptimalSplitFactor(badBatchRecordsCount, MaxBlobSize).value_or(1), badBatchCount) + 1, MaxBlobSize, badSlice, ColumnSaver);\n                 }\n                 ++SplitFactor;\n             }\n@@ -139,9 +120,8 @@ class TSplitChunk {\n };\n \n std::vector<TSaverSplittedChunk> TSimpleSplitter::Split(const std::shared_ptr<arrow::RecordBatch>& data, const ui32 maxBlobSize) const {\n-    AFL_VERIFY(data->num_columns() == 1);\n     AFL_VERIFY(data->num_rows());\n-    TSplitChunk baseChunk(Stats ? Stats->PredictOptimalSplitFactor(data->num_rows(), maxBlobSize).value_or(1) : 1, maxBlobSize, data, ColumnSaver, Counters);\n+    TSplitChunk baseChunk(Stats ? Stats->PredictOptimalSplitFactor(data->num_rows(), maxBlobSize).value_or(1) : 1, maxBlobSize, data, ColumnSaver);\n     std::vector<TSplitChunk> chunks = {baseChunk};\n     for (auto it = chunks.begin(); it != chunks.end(); ) {\n         AFL_VERIFY(chunks.size() < 100);\n@@ -217,12 +197,4 @@ std::vector<TSaverSplittedChunk> TSimpleSplitter::SplitBySizes(std::shared_ptr<a\n     return SplitByRecordsCount(data, recordsCount);\n }\n \n-std::shared_ptr<arrow::Scalar> TSaverSplittedChunk::GetFirstScalar() const {\n-    return NArrow::TStatusValidator::GetValid(SlicedBatch->column(0)->GetScalar(0));\n-}\n-\n-std::shared_ptr<arrow::Scalar> TSaverSplittedChunk::GetLastScalar() const {\n-    return NArrow::TStatusValidator::GetValid(SlicedBatch->column(0)->GetScalar(GetRecordsCount() - 1));\n-}\n-\n }\ndiff --git a/ydb/core/tx/columnshard/splitter/simple.h b/ydb/core/formats/arrow/splitter/simple.h\nsimilarity index 57%\nrename from ydb/core/tx/columnshard/splitter/simple.h\nrename to ydb/core/formats/arrow/splitter/simple.h\nindex 01467190373d..1405d3a6dc20 100644\n--- a/ydb/core/tx/columnshard/splitter/simple.h\n+++ b/ydb/core/formats/arrow/splitter/simple.h\n@@ -1,51 +1,24 @@\n #pragma once\n #include <ydb/library/accessor/accessor.h>\n-#include <ydb/core/tx/columnshard/counters/splitter.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/column_features.h>\n-#include \"stats.h\"\n-#include \"chunks.h\"\n #include \"scheme_info.h\"\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NSplitter {\n \n class TSaverSplittedChunk {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, SlicedBatch);\n     YDB_READONLY_DEF(TString, SerializedChunk);\n public:\n-    std::shared_ptr<arrow::Array> GetColumn() const {\n-        return SlicedBatch->column(0);\n-    }\n-\n     ui32 GetRecordsCount() const {\n         return SlicedBatch->num_rows();\n     }\n \n-    std::shared_ptr<arrow::Scalar> GetFirstScalar() const;\n-    std::shared_ptr<arrow::Scalar> GetLastScalar() const;\n-\n     TSaverSplittedChunk(const std::shared_ptr<arrow::RecordBatch>& batch, TString&& serializedChunk)\n         : SlicedBatch(batch)\n         , SerializedChunk(std::move(serializedChunk)) {\n         Y_ABORT_UNLESS(SlicedBatch);\n-        Y_ABORT_UNLESS(SlicedBatch->num_columns() == 1);\n         Y_ABORT_UNLESS(SlicedBatch->num_rows());\n     }\n-\n-    bool IsCompatibleColumn(const std::shared_ptr<arrow::Field>& f) const {\n-        if (!SlicedBatch) {\n-            return false;\n-        }\n-        if (SlicedBatch->num_columns() != 1) {\n-            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"unexpected columns count\")(\"expectation\", 1)(\"actual\", SlicedBatch->num_columns());\n-            return false;\n-        }\n-        if (!SlicedBatch->schema()->fields().front()->Equals(f)) {\n-            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"unexpected column type\")(\"expectation\", f->ToString())(\"actual\", SlicedBatch->schema()->fields().front()->ToString());\n-            return false;\n-        }\n-        return true;\n-    }\n };\n \n class TLinearSplitInfo {\n@@ -109,13 +82,11 @@ class TLinearSplitInfo {\n \n class TSimpleSplitter {\n private:\n-    TColumnSaver ColumnSaver;\n+    NAccessor::TColumnSaver ColumnSaver;\n     YDB_ACCESSOR_DEF(std::optional<TBatchSerializationStat>, Stats);\n-    std::shared_ptr<NColumnShard::TSplitterCounters> Counters;\n public:\n-    explicit TSimpleSplitter(const TColumnSaver& columnSaver, std::shared_ptr<NColumnShard::TSplitterCounters> counters)\n+    explicit TSimpleSplitter(const NAccessor::TColumnSaver& columnSaver)\n         : ColumnSaver(columnSaver)\n-        , Counters(counters)\n     {\n \n     }\n@@ -146,56 +117,4 @@ class TSimpleSplitter {\n     std::vector<TSaverSplittedChunk> SplitBySizes(std::shared_ptr<arrow::RecordBatch> data, const TString& dataSerialization, const std::vector<ui64>& splitPartSizesExt) const;\n };\n \n-class TSplittedColumnChunk: public IPortionColumnChunk {\n-private:\n-    using TBase = IPortionColumnChunk;\n-    TSaverSplittedChunk Data;\n-    ISchemaDetailInfo::TPtr SchemaInfo;\n-protected:\n-    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplitImpl(const TColumnSaver& saver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const override;\n-    virtual const TString& DoGetData() const override {\n-        return Data.GetSerializedChunk();\n-    }\n-    virtual ui64 DoGetRawBytesImpl() const override;\n-\n-    virtual ui32 DoGetRecordsCountImpl() const override {\n-        return Data.GetRecordsCount();\n-    }\n-\n-    virtual TString DoDebugString() const override;\n-\n-    virtual TSimpleChunkMeta DoBuildSimpleChunkMeta() const override {\n-        return TSimpleChunkMeta(Data.GetColumn(), SchemaInfo->NeedMinMaxForColumn(GetColumnId()), SchemaInfo->IsSortedColumn(GetColumnId()));\n-    }\n-\n-    virtual std::shared_ptr<arrow::Scalar> DoGetFirstScalar() const override {\n-        return Data.GetFirstScalar();\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetLastScalar() const override {\n-        return Data.GetLastScalar();\n-    }\n-    virtual std::shared_ptr<IPortionDataChunk> DoCopyWithAnotherBlob(TString&& /*data*/, const TSimpleColumnInfo& /*columnInfo*/) const override {\n-        AFL_VERIFY(false);\n-        return nullptr;\n-    }\n-\n-public:\n-    i64 GetSize() const {\n-        return Data.GetSerializedChunk().size();\n-    }\n-\n-    const TSaverSplittedChunk& GetData() const {\n-        return Data;\n-    }\n-\n-    TSplittedColumnChunk() = default;\n-\n-    TSplittedColumnChunk(const ui32 columnId, const TSaverSplittedChunk& data, ISchemaDetailInfo::TPtr schemaInfo)\n-        : TBase(columnId)\n-        , Data(data)\n-        , SchemaInfo(schemaInfo) {\n-\n-    }\n-};\n-\n }\ndiff --git a/ydb/core/formats/arrow/splitter/ya.make b/ydb/core/formats/arrow/splitter/ya.make\nnew file mode 100644\nindex 000000000000..70db86e75d4d\n--- /dev/null\n+++ b/ydb/core/formats/arrow/splitter/ya.make\n@@ -0,0 +1,17 @@\n+LIBRARY()\n+\n+SRCS(\n+    simple.cpp\n+    scheme_info.cpp\n+)\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/actors/core\n+    ydb/library/conclusion\n+    ydb/library/formats/arrow/splitter\n+    ydb/library/formats/arrow/common\n+    ydb/core/formats/arrow/serializer\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/ssa_program_optimizer.cpp b/ydb/core/formats/arrow/ssa_program_optimizer.cpp\nindex f55f63110f7b..ff1e5a5cb38c 100644\n--- a/ydb/core/formats/arrow/ssa_program_optimizer.cpp\n+++ b/ydb/core/formats/arrow/ssa_program_optimizer.cpp\n@@ -1,5 +1,7 @@\n #include \"ssa_program_optimizer.h\"\n \n+#include <ydb/library/actors/core/log.h>\n+\n namespace NKikimr::NSsa {\n \n namespace {\n@@ -11,7 +13,8 @@ void ReplaceCountAll(TProgram& program) {\n         Y_ABORT_UNLESS(step);\n \n         for (auto& groupBy : step->MutableGroupBy()) {\n-            if (groupBy.GetOperation() == EAggregate::Count && groupBy.GetArguments().empty()) {\n+            if (groupBy.GetOperation() == EAggregate::NumRows) {\n+                AFL_VERIFY(groupBy.GetArguments().empty());\n                 if (step->GetGroupByKeys().size()) {\n                     groupBy.MutableArguments().push_back(step->GetGroupByKeys()[0]);\n                 } else {\ndiff --git a/ydb/core/formats/arrow/switch/switch_type.h b/ydb/core/formats/arrow/switch/switch_type.h\nindex 78a9dfa04360..383ad1567c4b 100644\n--- a/ydb/core/formats/arrow/switch/switch_type.h\n+++ b/ydb/core/formats/arrow/switch/switch_type.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include <ydb/core/scheme_types/scheme_type_info.h>\n #include <ydb/core/scheme/scheme_type_id.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/switch/switch_type.h>\n #include <ydb/library/yql/parser/pg_wrapper/interface/type_desc.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>\n@@ -13,106 +13,6 @@ extern \"C\" {\n \n namespace NKikimr::NArrow {\n \n-template <typename TType>\n-struct TTypeWrapper\n-{\n-    using T = TType;\n-};\n-\n-template <class TResult, TResult defaultValue, typename TFunc, bool EnableNull = false>\n-TResult SwitchTypeImpl(arrow::Type::type typeId, TFunc&& f) {\n-    switch (typeId) {\n-        case arrow::Type::NA: {\n-            if constexpr (EnableNull) {\n-                return f(TTypeWrapper<arrow::NullType>());\n-            }\n-            break;\n-        }\n-        case arrow::Type::BOOL:\n-            return f(TTypeWrapper<arrow::BooleanType>());\n-        case arrow::Type::UINT8:\n-            return f(TTypeWrapper<arrow::UInt8Type>());\n-        case arrow::Type::INT8:\n-            return f(TTypeWrapper<arrow::Int8Type>());\n-        case arrow::Type::UINT16:\n-            return f(TTypeWrapper<arrow::UInt16Type>());\n-        case arrow::Type::INT16:\n-            return f(TTypeWrapper<arrow::Int16Type>());\n-        case arrow::Type::UINT32:\n-            return f(TTypeWrapper<arrow::UInt32Type>());\n-        case arrow::Type::INT32:\n-            return f(TTypeWrapper<arrow::Int32Type>());\n-        case arrow::Type::UINT64:\n-            return f(TTypeWrapper<arrow::UInt64Type>());\n-        case arrow::Type::INT64:\n-            return f(TTypeWrapper<arrow::Int64Type>());\n-        case arrow::Type::HALF_FLOAT:\n-            return f(TTypeWrapper<arrow::HalfFloatType>());\n-        case arrow::Type::FLOAT:\n-            return f(TTypeWrapper<arrow::FloatType>());\n-        case arrow::Type::DOUBLE:\n-            return f(TTypeWrapper<arrow::DoubleType>());\n-        case arrow::Type::STRING:\n-            return f(TTypeWrapper<arrow::StringType>());\n-        case arrow::Type::BINARY:\n-            return f(TTypeWrapper<arrow::BinaryType>());\n-        case arrow::Type::FIXED_SIZE_BINARY:\n-            return f(TTypeWrapper<arrow::FixedSizeBinaryType>());\n-        case arrow::Type::DATE32:\n-            return f(TTypeWrapper<arrow::Date32Type>());\n-        case arrow::Type::DATE64:\n-            return f(TTypeWrapper<arrow::Date64Type>());\n-        case arrow::Type::TIMESTAMP:\n-            return f(TTypeWrapper<arrow::TimestampType>());\n-        case arrow::Type::TIME32:\n-            return f(TTypeWrapper<arrow::Time32Type>());\n-        case arrow::Type::TIME64:\n-            return f(TTypeWrapper<arrow::Time64Type>());\n-        case arrow::Type::INTERVAL_MONTHS:\n-            return f(TTypeWrapper<arrow::MonthIntervalType>());\n-        case arrow::Type::DECIMAL:\n-            return f(TTypeWrapper<arrow::Decimal128Type>());\n-        case arrow::Type::DURATION:\n-            return f(TTypeWrapper<arrow::DurationType>());\n-        case arrow::Type::LARGE_STRING:\n-            return f(TTypeWrapper<arrow::LargeStringType>());\n-        case arrow::Type::LARGE_BINARY:\n-            return f(TTypeWrapper<arrow::LargeBinaryType>());\n-        case arrow::Type::DECIMAL256:\n-        case arrow::Type::DENSE_UNION:\n-        case arrow::Type::DICTIONARY:\n-        case arrow::Type::EXTENSION:\n-        case arrow::Type::FIXED_SIZE_LIST:\n-        case arrow::Type::INTERVAL_DAY_TIME:\n-        case arrow::Type::LARGE_LIST:\n-        case arrow::Type::LIST:\n-        case arrow::Type::MAP:\n-        case arrow::Type::MAX_ID:\n-        case arrow::Type::SPARSE_UNION:\n-        case arrow::Type::STRUCT:\n-            break;\n-    }\n-\n-    return defaultValue;\n-}\n-\n-template <typename TFunc, bool EnableNull = false>\n-bool SwitchType(arrow::Type::type typeId, TFunc&& f) {\n-    return SwitchTypeImpl<bool, false, TFunc, EnableNull>(typeId, std::move(f));\n-}\n-\n-template <typename TFunc>\n-bool SwitchTypeWithNull(arrow::Type::type typeId, TFunc&& f) {\n-    return SwitchType<TFunc, true>(typeId, std::move(f));\n-}\n-\n-template <typename TFunc>\n-bool SwitchArrayType(const arrow::Datum& column, TFunc&& f) {\n-    auto type = column.type();\n-    Y_ABORT_UNLESS(type);\n-    return SwitchType(type->id(), std::forward<TFunc>(f));\n-}\n-\n /**\n  * @brief Function to switch yql type correctly and uniformly converting it to arrow type using callback\n  *\n@@ -227,74 +127,4 @@ inline bool IsPrimitiveYqlType(const NScheme::TTypeInfo& typeInfo) {\n     return false;\n }\n \n-template <typename T>\n-bool Append(arrow::ArrayBuilder& builder, const typename T::c_type& value) {\n-    using TBuilder = typename arrow::TypeTraits<T>::BuilderType;\n-\n-    TStatusValidator::Validate(static_cast<TBuilder&>(builder).Append(value));\n-    return true;\n-}\n-\n-template <typename T>\n-bool Append(arrow::ArrayBuilder& builder, arrow::util::string_view value) {\n-    using TBuilder = typename arrow::TypeTraits<T>::BuilderType;\n-\n-    TStatusValidator::Validate(static_cast<TBuilder&>(builder).Append(value));\n-    return true;\n-}\n-\n-template <typename T>\n-bool Append(arrow::ArrayBuilder& builder, const typename T::c_type* values, size_t size) {\n-    using TBuilder = typename arrow::NumericBuilder<T>;\n-\n-    TStatusValidator::Validate(static_cast<TBuilder&>(builder).AppendValues(values, size));\n-    return true;\n-}\n-\n-template <typename T>\n-bool Append(arrow::ArrayBuilder& builder, const std::vector<typename T::c_type>& values) {\n-    using TBuilder = typename arrow::NumericBuilder<T>;\n-\n-    TStatusValidator::Validate(static_cast<TBuilder&>(builder).AppendValues(values.data(), values.size()));\n-    return true;\n-}\n-\n-template <typename T>\n-[[nodiscard]] bool Append(T& builder, const arrow::Array& array, int position, ui64* recordSize = nullptr) {\n-    Y_DEBUG_ABORT_UNLESS(builder.type()->id() == array.type_id());\n-    return SwitchType(array.type_id(), [&](const auto& type) {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-        using TBuilder = typename arrow::TypeTraits<typename TWrap::T>::BuilderType;\n-\n-        auto& typedArray = static_cast<const TArray&>(array);\n-        auto& typedBuilder = static_cast<TBuilder&>(builder);\n-\n-        if (typedArray.IsNull(position)) {\n-            TStatusValidator::Validate(typedBuilder.AppendNull());\n-            if (recordSize) {\n-                *recordSize += 4;\n-            }\n-            return true;\n-        } else {\n-            if constexpr (!arrow::has_string_view<typename TWrap::T>::value) {\n-                TStatusValidator::Validate(typedBuilder.Append(typedArray.GetView(position)));\n-                if (recordSize) {\n-                    *recordSize += sizeof(typedArray.GetView(position));\n-                }\n-                return true;\n-            }\n-            if constexpr (arrow::has_string_view<typename TWrap::T>::value) {\n-                TStatusValidator::Validate(typedBuilder.Append(typedArray.GetView(position)));\n-                if (recordSize) {\n-                    *recordSize += typedArray.GetView(position).size();\n-                }\n-                return true;\n-            }\n-        }\n-        Y_ABORT_UNLESS(false, \"unpredictable variant\");\n-        return false;\n-    });\n-}\n-\n }\ndiff --git a/ydb/core/formats/arrow/switch/ya.make b/ydb/core/formats/arrow/switch/ya.make\nindex e11e5e070ca6..622e9bf2a604 100644\n--- a/ydb/core/formats/arrow/switch/ya.make\n+++ b/ydb/core/formats/arrow/switch/ya.make\n@@ -4,11 +4,11 @@ PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/core/scheme_types\n     ydb/library/actors/core\n+    ydb/library/formats/arrow/switch\n )\n \n SRCS(\n     switch_type.cpp\n-    compare.cpp\n )\n \n END()\ndiff --git a/ydb/core/formats/arrow/transformer/dictionary.h b/ydb/core/formats/arrow/transformer/dictionary.h\nindex da0c13a5189a..4229c0ed8071 100644\n--- a/ydb/core/formats/arrow/transformer/dictionary.h\n+++ b/ydb/core/formats/arrow/transformer/dictionary.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"abstract.h\"\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n \n namespace NKikimr::NArrow::NTransformation {\n \ndiff --git a/ydb/core/formats/arrow/transformer/ya.make b/ydb/core/formats/arrow/transformer/ya.make\nindex 3a1c0c4c12ab..8ca15c923dd9 100644\n--- a/ydb/core/formats/arrow/transformer/ya.make\n+++ b/ydb/core/formats/arrow/transformer/ya.make\n@@ -3,12 +3,11 @@ LIBRARY()\n PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/core/formats/arrow/dictionary\n+    ydb/library/formats/arrow/transformer\n )\n \n SRCS(\n-    abstract.cpp\n     dictionary.cpp\n-    composite.cpp\n )\n \n END()\ndiff --git a/ydb/core/formats/arrow/ut/ut_arrow.cpp b/ydb/core/formats/arrow/ut/ut_arrow.cpp\nindex da620d70fa30..b12fc5561b12 100644\n--- a/ydb/core/formats/arrow/ut/ut_arrow.cpp\n+++ b/ydb/core/formats/arrow/ut/ut_arrow.cpp\n@@ -185,11 +185,6 @@ struct TDataRow {\n     }\n };\n \n-\n-std::shared_ptr<arrow::Array> GetColumn(const arrow::Table& table, int i, int chunk = 0) {\n-    return table.column(i)->chunk(chunk);\n-}\n-\n std::shared_ptr<arrow::Array> GetColumn(const arrow::RecordBatch& batch, int i) {\n     return batch.column(i);\n }\n@@ -526,22 +521,6 @@ bool CheckSorted(const std::shared_ptr<arrow::RecordBatch>& batch, bool desc = f\n }\n \n Y_UNIT_TEST_SUITE(ArrowTest) {\n-    Y_UNIT_TEST(Basic) {\n-        std::vector<TDataRow> rows = TestRows();\n-\n-        std::shared_ptr<arrow::Table> table = TDataRowTableBuilder::Build(rows);\n-\n-        auto expectedSchema = TDataRow::MakeArrowSchema();\n-        UNIT_ASSERT_EQUAL(expectedSchema->Equals(*table->schema()), true);\n-\n-        std::vector<TDataRow> readRows = ToVector(table);\n-\n-        UNIT_ASSERT_EQUAL(rows.size(), readRows.size());\n-        for (size_t i = 0; i < rows.size(); ++i) {\n-            UNIT_ASSERT_EQUAL(rows[i], readRows[i]);\n-        }\n-    }\n-\n     Y_UNIT_TEST(BatchBuilder) {\n         std::vector<TDataRow> rows = TestRows();\n \ndiff --git a/ydb/core/formats/arrow/ut/ut_dictionary.cpp b/ydb/core/formats/arrow/ut/ut_dictionary.cpp\nindex c3df2c6a30f0..02a9dc9b3e69 100644\n--- a/ydb/core/formats/arrow/ut/ut_dictionary.cpp\n+++ b/ydb/core/formats/arrow/ut/ut_dictionary.cpp\n@@ -1,10 +1,10 @@\n #include <library/cpp/testing/unittest/registar.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n #include <ydb/core/formats/arrow/serializer/native.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n #include <ydb/core/formats/arrow/dictionary/conversion.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n \n Y_UNIT_TEST_SUITE(Dictionary) {\n \ndiff --git a/ydb/core/formats/arrow/ut/ut_hash.cpp b/ydb/core/formats/arrow/ut/ut_hash.cpp\nindex 3255d430352d..4c64c74895cb 100644\n--- a/ydb/core/formats/arrow/ut/ut_hash.cpp\n+++ b/ydb/core/formats/arrow/ut/ut_hash.cpp\n@@ -1,7 +1,7 @@\n #include <library/cpp/testing/unittest/registar.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/hash/xx_hash.h>\n #include <ydb/core/formats/arrow/hash/calcer.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n \n Y_UNIT_TEST_SUITE(Hash) {\n \ndiff --git a/ydb/core/formats/arrow/ut/ya.make b/ydb/core/formats/arrow/ut/ya.make\nindex c4c993ec3220..54fa4d357730 100644\n--- a/ydb/core/formats/arrow/ut/ya.make\n+++ b/ydb/core/formats/arrow/ut/ya.make\n@@ -5,6 +5,7 @@ SIZE(SMALL)\n PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/library/arrow_kernels\n+    ydb/library/formats/arrow/simple_builder\n     ydb/core/base\n \n     # for NYql::NUdf alloc stuff used in binary_json\n@@ -26,7 +27,6 @@ SRCS(\n     ut_arrow.cpp\n     ut_program_step.cpp\n     ut_dictionary.cpp\n-    ut_size_calcer.cpp\n     ut_column_filter.cpp\n     ut_hash.cpp\n )\ndiff --git a/ydb/core/formats/arrow/ya.make b/ydb/core/formats/arrow/ya.make\nindex 49938a884154..fa66d3a97154 100644\n--- a/ydb/core/formats/arrow/ya.make\n+++ b/ydb/core/formats/arrow/ya.make\n@@ -7,18 +7,19 @@ LIBRARY()\n PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/core/scheme\n+    ydb/core/formats/arrow/accessor\n     ydb/core/formats/arrow/serializer\n-    ydb/core/formats/arrow/simple_builder\n     ydb/core/formats/arrow/dictionary\n     ydb/core/formats/arrow/transformer\n     ydb/core/formats/arrow/reader\n-    ydb/core/formats/arrow/modifier\n-    ydb/core/formats/arrow/scalar\n+    ydb/core/formats/arrow/save_load\n+    ydb/core/formats/arrow/splitter\n     ydb/core/formats/arrow/hash\n     ydb/library/actors/core\n     ydb/library/arrow_kernels\n     ydb/library/binary_json\n     ydb/library/dynumber\n+    ydb/library/formats/arrow\n     ydb/library/services\n     ydb/library/yql/core/arrow_kernels/request\n )\n@@ -46,14 +47,11 @@ SRCS(\n     converter.cpp\n     converter.h\n     custom_registry.cpp\n-    input_stream.h\n     permutations.cpp\n     program.cpp\n-    replace_key.cpp\n     size_calcer.cpp\n     ssa_program_optimizer.cpp\n     special_keys.cpp\n-    simple_arrays_cache.cpp\n     process_columns.cpp\n )\n \ndiff --git a/ydb/core/grpc_services/query/rpc_kqp_tx.cpp b/ydb/core/grpc_services/query/rpc_kqp_tx.cpp\nindex 4f92c00faff7..d71caa0f428e 100644\n--- a/ydb/core/grpc_services/query/rpc_kqp_tx.cpp\n+++ b/ydb/core/grpc_services/query/rpc_kqp_tx.cpp\n@@ -124,6 +124,7 @@ class TBeginTransactionRPC : public  TActorBootstrapped<TBeginTransactionRPC> {\n             if (kqpResponse.HasTxMeta()) {\n                 beginTxResult->mutable_tx_meta()->set_id(kqpResponse.GetTxMeta().id());\n             }\n+            *beginTxResult->mutable_issues() = issueMessage;\n         }\n \n         Reply(record.GetYdbStatus(), beginTxResult);\n@@ -168,7 +169,7 @@ class TFinishTransactionRPC : public  TActorBootstrapped<TFinishTransactionRPC>\n private:\n     virtual std::pair<TString, TString> GetReqData() const = 0;\n     virtual void Fill(NKikimrKqp::TQueryRequest* req) const = 0;\n-    virtual NProtoBuf::Message* CreateResult(Ydb::StatusIds::StatusCode status) const = 0;\n+    virtual NProtoBuf::Message* CreateResult(Ydb::StatusIds::StatusCode status, const NYql::TIssues& issues) const = 0;\n \n     void StateWork(TAutoPtr<IEventHandle>& ev) {\n         try {\n@@ -218,15 +219,15 @@ class TFinishTransactionRPC : public  TActorBootstrapped<TFinishTransactionRPC>\n         const auto& record = ev->Get()->Record.GetRef();\n         FillCommonKqpRespFields(record, Request.get());\n \n+        NYql::TIssues issues;\n         if (record.HasResponse()) {\n             const auto& kqpResponse = record.GetResponse();\n             const auto& issueMessage = kqpResponse.GetQueryIssues();\n-            NYql::TIssues issues;\n             NYql::IssuesFromMessage(issueMessage, issues);\n             Request->RaiseIssues(issues);\n         }\n \n-        Reply(record.GetYdbStatus(), CreateResult(record.GetYdbStatus()));\n+        Reply(record.GetYdbStatus(), CreateResult(record.GetYdbStatus(), issues));\n     }\n \n     void InternalError(const TString& message) {\n@@ -271,9 +272,10 @@ class TCommitTransactionRPC : public TFinishTransactionRPC {\n         req->MutableTxControl()->set_commit_tx(true);\n     }\n \n-    NProtoBuf::Message* CreateResult(Ydb::StatusIds::StatusCode status) const override {\n+    NProtoBuf::Message* CreateResult(Ydb::StatusIds::StatusCode status, const NYql::TIssues& issues) const override {\n         auto result = TEvCommitTransactionRequest::AllocateResult<Ydb::Query::CommitTransactionResponse>(Request);\n         result->set_status(status);\n+        NYql::IssuesToMessage(issues, result->mutable_issues());\n         return result;\n     }\n };\n@@ -293,9 +295,10 @@ class TRollbackTransactionRPC : public TFinishTransactionRPC {\n         req->SetAction(NKikimrKqp::QUERY_ACTION_ROLLBACK_TX);\n     }\n \n-    NProtoBuf::Message* CreateResult(Ydb::StatusIds::StatusCode status) const override {\n+    NProtoBuf::Message* CreateResult(Ydb::StatusIds::StatusCode status, const NYql::TIssues& issues) const override {\n         auto result = TEvRollbackTransactionRequest::AllocateResult<Ydb::Query::RollbackTransactionResponse>(Request);\n         result->set_status(status);\n+        NYql::IssuesToMessage(issues, result->mutable_issues());\n         return result;\n     }\n };\ndiff --git a/ydb/core/grpc_services/rpc_load_rows.cpp b/ydb/core/grpc_services/rpc_load_rows.cpp\nindex e780de7eea05..4b5cab1c5b1c 100644\n--- a/ydb/core/grpc_services/rpc_load_rows.cpp\n+++ b/ydb/core/grpc_services/rpc_load_rows.cpp\n@@ -75,9 +75,12 @@ bool ConvertArrowToYdbPrimitive(const arrow::DataType& type, Ydb::Type& toType)\n         case arrow::Type::DURATION:\n             toType.set_type_id(Ydb::Type::INTERVAL);\n             return true;\n-        case arrow::Type::DECIMAL:\n-            // TODO\n-            return false;\n+        case arrow::Type::DECIMAL: {\n+            Ydb::DecimalType* decimalType = toType.mutable_decimal_type();\n+            decimalType->set_precision(22);\n+            decimalType->set_scale(9);\n+            return true;\n+        }\n         case arrow::Type::NA:\n         case arrow::Type::HALF_FLOAT:\n         case arrow::Type::FIXED_SIZE_BINARY:\ndiff --git a/ydb/core/kqp/compile_service/kqp_compile_actor.cpp b/ydb/core/kqp/compile_service/kqp_compile_actor.cpp\nindex 1f94121d4eb2..dfb8b7a77073 100644\n--- a/ydb/core/kqp/compile_service/kqp_compile_actor.cpp\n+++ b/ydb/core/kqp/compile_service/kqp_compile_actor.cpp\n@@ -173,8 +173,6 @@ class TKqpCompileActor : public TActorBootstrapped<TKqpCompileActor> {\n     }\n \n     void StartSplitting(const TActorContext &ctx) {\n-        YQL_ENSURE(PerStatementResult);\n-\n         const auto prepareSettings = PrepareCompilationSettings(ctx);\n         auto result = KqpHost->SplitQuery(QueryRef, prepareSettings);\n \n@@ -281,7 +279,6 @@ class TKqpCompileActor : public TActorBootstrapped<TKqpCompileActor> {\n         IKqpHost::TPrepareSettings prepareSettings;\n         prepareSettings.DocumentApiRestricted = QueryId.Settings.DocumentApiRestricted;\n         prepareSettings.IsInternalCall = QueryId.Settings.IsInternalCall;\n-        prepareSettings.PerStatementResult = PerStatementResult;\n \n         switch (QueryId.Settings.Syntax) {\n             case Ydb::Query::Syntax::SYNTAX_YQL_V1:\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_actor.cpp b/ydb/core/kqp/compute_actor/kqp_compute_actor.cpp\nindex 74b0f6f14f79..758476d48339 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_actor.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_actor.cpp\n@@ -10,7 +10,7 @@\n #include <ydb/core/kqp/runtime/kqp_sequencer_factory.h>\n #include <ydb/core/kqp/runtime/kqp_stream_lookup_factory.h>\n #include <ydb/library/yql/providers/generic/actors/yql_generic_provider_factories.h>\n-#include <ydb/core/formats/arrow/protos/ssa.pb.h>\n+#include <ydb/library/formats/arrow/protos/ssa.pb.h>\n #include <ydb/library/yql/dq/proto/dq_tasks.pb.h>\n \n \n@@ -131,18 +131,18 @@ namespace NKikimr::NKqp {\n using namespace NYql::NDq;\n using namespace NYql::NDqProto;\n \n-IActor* CreateKqpScanComputeActor(const TActorId& executerId, ui64 txId,\n+IActor* CreateKqpScanComputeActor(const TActorId& executerId, ui64 txId, TMaybe<ui64> lockTxId, ui32 lockNodeId,\n     TDqTask* task, IDqAsyncIoFactory::TPtr asyncIoFactory,\n     const NYql::NDq::TComputeRuntimeSettings& settings, const TComputeMemoryLimits& memoryLimits, NWilson::TTraceId traceId,\n     TIntrusivePtr<NActors::TProtoArenaHolder> arena) {\n-    return new NScanPrivate::TKqpScanComputeActor(executerId, txId, task, std::move(asyncIoFactory),\n+    return new NScanPrivate::TKqpScanComputeActor(executerId, txId, lockTxId, lockNodeId, task, std::move(asyncIoFactory),\n         settings, memoryLimits, std::move(traceId), std::move(arena));\n }\n \n IActor* CreateKqpScanFetcher(const NKikimrKqp::TKqpSnapshot& snapshot, std::vector<NActors::TActorId>&& computeActors,\n     const NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta& meta, const NYql::NDq::TComputeRuntimeSettings& settings,\n-    const ui64 txId, const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId) {\n-    return new NScanPrivate::TKqpScanFetcherActor(snapshot, settings, std::move(computeActors), txId, meta, shardsScanningPolicy, counters, std::move(traceId));\n+    const ui64 txId, TMaybe<ui64> lockTxId, ui32 lockNodeId, const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId) {\n+    return new NScanPrivate::TKqpScanFetcherActor(snapshot, settings, std::move(computeActors), txId, lockTxId, lockNodeId, meta, shardsScanningPolicy, counters, std::move(traceId));\n }\n \n }\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_actor.h b/ydb/core/kqp/compute_actor/kqp_compute_actor.h\nindex 0e191e113780..9bd19c8b002d 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_actor.h\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_actor.h\n@@ -50,14 +50,14 @@ IActor* CreateKqpComputeActor(const TActorId& executerId, ui64 txId, NYql::NDqPr\n     TIntrusivePtr<NActors::TProtoArenaHolder> arena,\n     const std::optional<TKqpFederatedQuerySetup>& federatedQuerySetup, const TGUCSettings::TPtr& GUCSettings);\n \n-IActor* CreateKqpScanComputeActor(const TActorId& executerId, ui64 txId,\n+IActor* CreateKqpScanComputeActor(const TActorId& executerId, ui64 txId, TMaybe<ui64> lockTxId, ui32 lockNodeId,\n     NYql::NDqProto::TDqTask* task, NYql::NDq::IDqAsyncIoFactory::TPtr asyncIoFactory,\n     const NYql::NDq::TComputeRuntimeSettings& settings, const NYql::NDq::TComputeMemoryLimits& memoryLimits, NWilson::TTraceId traceId,\n     TIntrusivePtr<NActors::TProtoArenaHolder> arena);\n \n IActor* CreateKqpScanFetcher(const NKikimrKqp::TKqpSnapshot& snapshot, std::vector<NActors::TActorId>&& computeActors,\n     const NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta& meta, const NYql::NDq::TComputeRuntimeSettings& settings,\n-    const ui64 txId, const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId);\n+    const ui64 txId, TMaybe<ui64> lockTxId, ui32 lockNodeId, const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId);\n \n NYql::NDq::IDqAsyncIoFactory::TPtr CreateKqpAsyncIoFactory(\n     TIntrusivePtr<TKqpCounters> counters,\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp\nindex 4cb5c3d1d97f..7a77406889ee 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp\n@@ -211,7 +211,7 @@ class TKqpCaFactory : public IKqpNodeComputeActorFactory {\n         if (tableKind == ETableKind::Datashard || tableKind == ETableKind::Olap) {\n             YQL_ENSURE(args.ComputesByStages);\n             auto& info = args.ComputesByStages->UpsertTaskWithScan(*args.Task, meta, !AppData()->FeatureFlags.GetEnableSeparationComputeActorsFromRead());\n-            IActor* computeActor = CreateKqpScanComputeActor(args.ExecuterId, args.TxId, args.Task,\n+            IActor* computeActor = CreateKqpScanComputeActor(args.ExecuterId, args.TxId, args.LockTxId, args.LockNodeId, args.Task,\n                 AsyncIoFactory, runtimeSettings, memoryLimits,\n                 std::move(args.TraceId), std::move(args.Arena));\n             TActorId result = TlsActivationContext->Register(computeActor);\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.h b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.h\nindex 2b63e14e5025..5d63a7aa6c9b 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.h\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.h\n@@ -106,6 +106,8 @@ struct IKqpNodeComputeActorFactory {\n     struct TCreateArgs {\n         const NActors::TActorId& ExecuterId;\n         const ui64 TxId;\n+        const TMaybe<ui64> LockTxId;\n+        const ui32 LockNodeId;\n         NYql::NDqProto::TDqTask* Task;\n         TIntrusivePtr<NRm::TTxState> TxInfo;\n         const NYql::NDq::TComputeRuntimeSettings& RuntimeSettings;\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_events.h b/ydb/core/kqp/compute_actor/kqp_compute_events.h\nindex 6092c4a1a378..a9dd127a64b0 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_events.h\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_events.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <ydb/core/kqp/common/kqp.h>\n #include <ydb/core/protos/tx_datashard.pb.h>\n #include <ydb/core/protos/data_events.pb.h>\n@@ -11,164 +11,181 @@\n \n namespace NKikimr::NKqp {\n \n-struct TEvKqpCompute {\n-    struct TEvRemoteScanData : public TEventPB<TEvRemoteScanData, NKikimrKqp::TEvRemoteScanData,\n-        TKqpComputeEvents::EvRemoteScanData> {};\n+struct TLocksInfo {\n+    TVector<NKikimrDataEvents::TLock> Locks;\n+    TVector<NKikimrDataEvents::TLock> BrokenLocks;\n+};\n \n-    class IShardScanStats {\n-    public:\n-        virtual ~IShardScanStats() = default;\n-        virtual THashMap<TString, ui64> GetMetrics() const = 0;\n-    };\n+namespace NInternalImplementation {\n+struct TEvRemoteScanData: public TEventPB<TEvRemoteScanData, NKikimrKqp::TEvRemoteScanData,\n+    TKqpComputeEvents::EvRemoteScanData> {\n+};\n \n-    /*\n-     * Scan communications.\n-     *\n-     * TEvScanData is intentionally preserved as a local event for performance reasons: leaf compute\n-     * actors are communicating with shard scans using this message, so big amount of unfiltered data\n-     * is expected. However, it is possible that after query planning datashard would migrate to other\n-     * node. To support scans in this case we provide serialization routines. For now such remote scan\n-     * is considered as rare event and not worth of some fast serialization, so we just use protobuf.\n-     *\n-     * TEvScanDataAck follows the same pattern mostly for symmetry reasons.\n-     */\n-    struct TEvScanData : public NActors::TEventLocal<TEvScanData, TKqpComputeEvents::EvScanData> {\n-        TEvScanData(const ui32 scanId, const ui32 generation = 0)\n-            : ScanId(scanId)\n-            , Generation(generation)\n-            , Finished(false) {}\n-\n-        std::optional<ui32> AvailablePacks;\n-        ui32 ScanId;\n-        ui32 Generation;\n-        TVector<TOwnedCellVec> Rows;\n-        std::shared_ptr<arrow::Table> ArrowBatch;\n-        std::vector<std::vector<ui32>> SplittedBatches;\n-        \n-        TOwnedCellVec LastKey;\n-        TDuration CpuTime;\n-        TDuration WaitTime;\n-        ui32 PageFaults = 0; // number of page faults occurred when filling in this message\n-        bool RequestedBytesLimitReached = false;\n-        bool Finished = false;\n-        bool PageFault = false; // page fault was the reason for sending this message\n-        mutable THolder<TEvRemoteScanData> Remote;\n-        std::shared_ptr<IShardScanStats> StatsOnFinished;\n-\n-        template <class T>\n-        const T& GetStatsAs() const {\n-            Y_ABORT_UNLESS(!!StatsOnFinished);\n-            return VerifyDynamicCast<const T&>(*StatsOnFinished);\n-        }\n+class IShardScanStats {\n+public:\n+    virtual ~IShardScanStats() = default;\n+    virtual THashMap<TString, ui64> GetMetrics() const = 0;\n+};\n \n-        template <class T>\n-        bool CheckStatsIs() const {\n-            auto p = dynamic_cast<const T*>(StatsOnFinished.get());\n-            return p;\n+/*\n+ * Scan communications.\n+ *\n+ * TEvScanData is intentionally preserved as a local event for performance reasons: leaf compute\n+ * actors are communicating with shard scans using this message, so big amount of unfiltered data\n+ * is expected. However, it is possible that after query planning datashard would migrate to other\n+ * node. To support scans in this case we provide serialization routines. For now such remote scan\n+ * is considered as rare event and not worth of some fast serialization, so we just use protobuf.\n+ *\n+ * TEvScanDataAck follows the same pattern mostly for symmetry reasons.\n+ */\n+struct TEvScanData: public NActors::TEventLocal<TEvScanData, TKqpComputeEvents::EvScanData> {\n+    TEvScanData(const ui32 scanId, const ui32 generation = 0)\n+        : ScanId(scanId)\n+        , Generation(generation)\n+        , Finished(false) {\n+    }\n+\n+    std::optional<ui32> AvailablePacks;\n+    ui32 ScanId;\n+    ui32 Generation;\n+    TVector<TOwnedCellVec> Rows;\n+    std::shared_ptr<arrow::Table> ArrowBatch;\n+    std::vector<std::vector<ui32>> SplittedBatches;\n+\n+    TOwnedCellVec LastKey;\n+    TDuration CpuTime;\n+    TDuration WaitTime;\n+    ui32 PageFaults = 0; // number of page faults occurred when filling in this message\n+    bool RequestedBytesLimitReached = false;\n+    bool Finished = false;\n+    bool PageFault = false; // page fault was the reason for sending this message\n+    mutable THolder<TEvRemoteScanData> Remote;\n+    std::shared_ptr<IShardScanStats> StatsOnFinished;\n+    TLocksInfo LocksInfo;\n+\n+    template <class T>\n+    const T& GetStatsAs() const {\n+        Y_ABORT_UNLESS(!!StatsOnFinished);\n+        return VerifyDynamicCast<const T&>(*StatsOnFinished);\n+    }\n+\n+    template <class T>\n+    bool CheckStatsIs() const {\n+        auto p = dynamic_cast<const T*>(StatsOnFinished.get());\n+        return p;\n+    }\n+\n+    ui32 GetRowsCount() const {\n+        if (ArrowBatch) {\n+            return ArrowBatch->num_rows();\n+        } else {\n+            return Rows.size();\n         }\n+    }\n \n-        ui32 GetRowsCount() const {\n-            if (ArrowBatch) {\n-                return ArrowBatch->num_rows();\n-            } else {\n-                return Rows.size();\n-            }\n-        }\n+    bool IsEmpty() const {\n+        return GetRowsCount() == 0;\n+    }\n \n-        bool IsEmpty() const {\n-            return GetRowsCount() == 0;\n-        }\n+    bool IsSerializable() const override {\n+        return true;\n+    }\n \n-        bool IsSerializable() const override {\n-            return true;\n-        }\n+    ui32 CalculateSerializedSize() const override {\n+        InitRemote();\n+        return Remote->CalculateSerializedSizeCached();\n+    }\n \n-        ui32 CalculateSerializedSize() const override {\n-            InitRemote();\n-            return Remote->CalculateSerializedSizeCached();\n-        }\n+    bool SerializeToArcadiaStream(NActors::TChunkSerializer* chunker) const override {\n+        InitRemote();\n+        return Remote->SerializeToArcadiaStream(chunker);\n+    }\n \n-        bool SerializeToArcadiaStream(NActors::TChunkSerializer* chunker) const override {\n-            InitRemote();\n-            return Remote->SerializeToArcadiaStream(chunker);\n+    NKikimrDataEvents::EDataFormat GetDataFormat() const {\n+        if (ArrowBatch != nullptr || SplittedBatches.size()) {\n+            return NKikimrDataEvents::FORMAT_ARROW;\n         }\n-\n-        NKikimrDataEvents::EDataFormat GetDataFormat() const {\n-            if (ArrowBatch != nullptr || SplittedBatches.size()) {\n-                return NKikimrDataEvents::FORMAT_ARROW;\n-            }\n-            return NKikimrDataEvents::FORMAT_CELLVEC;\n+        return NKikimrDataEvents::FORMAT_CELLVEC;\n+    }\n+\n+\n+    static NActors::IEventBase* Load(TEventSerializedData* data) {\n+        auto pbEv = THolder<TEvRemoteScanData>(static_cast<TEvRemoteScanData*>(TEvRemoteScanData::Load(data)));\n+        auto ev = MakeHolder<TEvScanData>(pbEv->Record.GetScanId(), pbEv->Record.GetGeneration());\n+\n+        ev->CpuTime = TDuration::MicroSeconds(pbEv->Record.GetCpuTimeUs());\n+        ev->WaitTime = TDuration::MilliSeconds(pbEv->Record.GetWaitTimeMs());\n+        ev->PageFault = pbEv->Record.GetPageFault();\n+        ev->PageFaults = pbEv->Record.GetPageFaults();\n+        ev->Finished = pbEv->Record.GetFinished();\n+        ev->RequestedBytesLimitReached = pbEv->Record.GetRequestedBytesLimitReached();\n+        ev->LastKey = TOwnedCellVec(TSerializedCellVec(pbEv->Record.GetLastKey()).GetCells());\n+        if (pbEv->Record.HasAvailablePacks()) {\n+            ev->AvailablePacks = pbEv->Record.GetAvailablePacks();\n         }\n \n+        auto rows = pbEv->Record.GetRows();\n+        ev->Rows.reserve(rows.size());\n+        for (const auto& row : rows) {\n+            ev->Rows.emplace_back(TSerializedCellVec(row).GetCells());\n+        }\n \n-        static NActors::IEventBase* Load(TEventSerializedData* data) {\n-            auto pbEv = THolder<TEvRemoteScanData>(static_cast<TEvRemoteScanData *>(TEvRemoteScanData::Load(data)));\n-            auto ev = MakeHolder<TEvScanData>(pbEv->Record.GetScanId(), pbEv->Record.GetGeneration());\n-\n-            ev->CpuTime = TDuration::MicroSeconds(pbEv->Record.GetCpuTimeUs());\n-            ev->WaitTime = TDuration::MilliSeconds(pbEv->Record.GetWaitTimeMs());\n-            ev->PageFault = pbEv->Record.GetPageFault();\n-            ev->PageFaults = pbEv->Record.GetPageFaults();\n-            ev->Finished = pbEv->Record.GetFinished();\n-            ev->RequestedBytesLimitReached = pbEv->Record.GetRequestedBytesLimitReached();\n-            ev->LastKey = TOwnedCellVec(TSerializedCellVec(pbEv->Record.GetLastKey()).GetCells());\n-            if (pbEv->Record.HasAvailablePacks()) {\n-                ev->AvailablePacks = pbEv->Record.GetAvailablePacks();\n-            }\n-\n-            auto rows = pbEv->Record.GetRows();\n-            ev->Rows.reserve(rows.size());\n-            for (const auto& row: rows) {\n-                ev->Rows.emplace_back(TSerializedCellVec(row).GetCells());\n+        if (pbEv->Record.HasArrowBatch()) {\n+            auto batch = pbEv->Record.GetArrowBatch();\n+            auto schema = NArrow::DeserializeSchema(batch.GetSchema());\n+            ev->ArrowBatch = NArrow::TStatusValidator::GetValid(arrow::Table::FromRecordBatches({ NArrow::DeserializeBatch(batch.GetBatch(), schema) }));\n+        }\n+        return ev.Release();\n+    }\n+\n+private:\n+    void InitRemote() const {\n+        if (!Remote) {\n+            Remote = MakeHolder<TEvRemoteScanData>();\n+\n+            Remote->Record.SetScanId(ScanId);\n+            Remote->Record.SetGeneration(Generation);\n+            Remote->Record.SetCpuTimeUs(CpuTime.MicroSeconds());\n+            Remote->Record.SetWaitTimeMs(WaitTime.MilliSeconds());\n+            Remote->Record.SetPageFaults(PageFaults);\n+            Remote->Record.SetFinished(Finished);\n+            Remote->Record.SetRequestedBytesLimitReached(RequestedBytesLimitReached);\n+            Remote->Record.SetPageFaults(PageFaults);\n+            Remote->Record.SetPageFault(PageFault);\n+            Remote->Record.SetLastKey(TSerializedCellVec::Serialize(LastKey));\n+            if (AvailablePacks) {\n+                Remote->Record.SetAvailablePacks(*AvailablePacks);\n             }\n \n-            if (pbEv->Record.HasArrowBatch()) {\n-                auto batch = pbEv->Record.GetArrowBatch();\n-                auto schema = NArrow::DeserializeSchema(batch.GetSchema());\n-                ev->ArrowBatch = NArrow::TStatusValidator::GetValid(arrow::Table::FromRecordBatches({NArrow::DeserializeBatch(batch.GetBatch(), schema)}));\n+            switch (GetDataFormat()) {\n+                case NKikimrDataEvents::FORMAT_UNSPECIFIED:\n+                case NKikimrDataEvents::FORMAT_CELLVEC: {\n+                    Remote->Record.MutableRows()->Reserve(Rows.size());\n+                    for (const auto& row : Rows) {\n+                        Remote->Record.AddRows(TSerializedCellVec::Serialize(row));\n+                    }\n+                    break;\n+                }\n+                case NKikimrDataEvents::FORMAT_ARROW: {\n+                    Y_DEBUG_ABORT_UNLESS(ArrowBatch != nullptr);\n+                    auto* protoArrowBatch = Remote->Record.MutableArrowBatch();\n+                    protoArrowBatch->SetSchema(NArrow::SerializeSchema(*ArrowBatch->schema()));\n+                    protoArrowBatch->SetBatch(NArrow::SerializeBatchNoCompression(NArrow::ToBatch(ArrowBatch, true)));\n+                    break;\n+                }\n             }\n-            return ev.Release();\n         }\n+    }\n+};\n \n-    private:\n-        void InitRemote() const {\n-            if (!Remote) {\n-                Remote = MakeHolder<TEvRemoteScanData>();\n+}\n \n-                Remote->Record.SetScanId(ScanId);\n-                Remote->Record.SetGeneration(Generation);\n-                Remote->Record.SetCpuTimeUs(CpuTime.MicroSeconds());\n-                Remote->Record.SetWaitTimeMs(WaitTime.MilliSeconds());\n-                Remote->Record.SetPageFaults(PageFaults);\n-                Remote->Record.SetFinished(Finished);\n-                Remote->Record.SetRequestedBytesLimitReached(RequestedBytesLimitReached);\n-                Remote->Record.SetPageFaults(PageFaults);\n-                Remote->Record.SetPageFault(PageFault);\n-                Remote->Record.SetLastKey(TSerializedCellVec::Serialize(LastKey));\n-                if (AvailablePacks) {\n-                    Remote->Record.SetAvailablePacks(*AvailablePacks);\n-                }\n+struct TEvKqpCompute {\n+    using TEvRemoteScanData = NInternalImplementation::TEvRemoteScanData;\n \n-                switch (GetDataFormat()) {\n-                    case NKikimrDataEvents::FORMAT_UNSPECIFIED:\n-                    case NKikimrDataEvents::FORMAT_CELLVEC: {\n-                        Remote->Record.MutableRows()->Reserve(Rows.size());\n-                        for (const auto& row: Rows) {\n-                            Remote->Record.AddRows(TSerializedCellVec::Serialize(row));\n-                        }\n-                        break;\n-                    }\n-                    case NKikimrDataEvents::FORMAT_ARROW: {\n-                        Y_DEBUG_ABORT_UNLESS(ArrowBatch != nullptr);\n-                        auto* protoArrowBatch = Remote->Record.MutableArrowBatch();\n-                        protoArrowBatch->SetSchema(NArrow::SerializeSchema(*ArrowBatch->schema()));\n-                        protoArrowBatch->SetBatch(NArrow::SerializeBatchNoCompression(NArrow::ToBatch(ArrowBatch, true)));\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    };\n+    using IShardScanStats = NInternalImplementation::IShardScanStats;\n+\n+    using TEvScanData = NInternalImplementation::TEvScanData;\n \n     struct TEvRemoteScanDataAck: public NActors::TEventPB<TEvRemoteScanDataAck, NKikimrKqp::TEvRemoteScanDataAck,\n         TKqpComputeEvents::EvRemoteScanDataAck> {\n@@ -247,5 +264,4 @@ struct TEvKqpCompute {\n         TKqpComputeEvents::EvKillScanTablet> {};\n \n };\n-\n } // namespace NKikimr::NKqp\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.cpp b/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.cpp\nindex b144be2b09b0..907b5c03d671 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.cpp\n@@ -23,13 +23,15 @@ static constexpr TDuration RL_MAX_BATCH_DELAY = TDuration::Seconds(50);\n \n } // anonymous namespace\n \n-TKqpScanComputeActor::TKqpScanComputeActor(const TActorId& executerId, ui64 txId, NDqProto::TDqTask* task,\n-    IDqAsyncIoFactory::TPtr asyncIoFactory,\n+TKqpScanComputeActor::TKqpScanComputeActor(const TActorId& executerId, ui64 txId, TMaybe<ui64> lockTxId, ui32 lockNodeId,\n+    NDqProto::TDqTask* task, IDqAsyncIoFactory::TPtr asyncIoFactory,\n     const TComputeRuntimeSettings& settings, const TComputeMemoryLimits& memoryLimits, NWilson::TTraceId traceId,\n     TIntrusivePtr<NActors::TProtoArenaHolder> arena)\n     : TBase(executerId, txId, task, std::move(asyncIoFactory), AppData()->FunctionRegistry, settings,\n         memoryLimits, /* ownMemoryQuota = */ true, /* passExceptions = */ true, /*taskCounters = */ nullptr, std::move(traceId), std::move(arena))\n     , ComputeCtx(settings.StatsMode)\n+    , LockTxId(lockTxId)\n+    , LockNodeId(lockNodeId)\n {\n     InitializeTask();\n     YQL_ENSURE(GetTask().GetMeta().UnpackTo(&Meta), \"Invalid task meta: \" << GetTask().GetMeta().DebugString());\n@@ -103,6 +105,19 @@ void TKqpScanComputeActor::FillExtraStats(NDqProto::TDqComputeActorStats* dst, b\n     }\n }\n \n+TMaybe<google::protobuf::Any> TKqpScanComputeActor::ExtraData() {\n+    NKikimrTxDataShard::TEvKqpInputActorResultInfo resultInfo;\n+    for (const auto& lock : Locks) {\n+        resultInfo.AddLocks()->CopyFrom(lock);\n+    }\n+    for (const auto& lock : BrokenLocks) {\n+        resultInfo.AddLocks()->CopyFrom(lock);\n+    }\n+    google::protobuf::Any result;\n+    result.PackFrom(resultInfo);\n+    return result;\n+}\n+\n void TKqpScanComputeActor::HandleEvWakeup(EEvWakeupTag tag) {\n     AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"HandleEvWakeup\")(\"self_id\", SelfId());\n     switch (tag) {\n@@ -130,10 +145,18 @@ void TKqpScanComputeActor::Handle(TEvScanExchange::TEvTerminateFromFetcher::TPtr\n void TKqpScanComputeActor::Handle(TEvScanExchange::TEvSendData::TPtr& ev) {\n     ALS_DEBUG(NKikimrServices::KQP_COMPUTE) << \"TEvSendData: \" << ev->Sender << \"/\" << SelfId();\n     auto& msg = *ev->Get();\n+    \n+    for (const auto& lock : msg.GetLocksInfo().Locks) {\n+        Locks.insert(lock);\n+    }\n+    for (const auto& lock : msg.GetLocksInfo().BrokenLocks) {\n+        BrokenLocks.insert(lock);\n+    }\n+\n     auto guard = TaskRunner->BindAllocator();\n     if (!!msg.GetArrowBatch()) {\n         ScanData->AddData(NMiniKQL::TBatchDataAccessor(msg.GetArrowBatch(), std::move(msg.MutableDataIndexes())), msg.GetTabletId(), TaskRunner->GetHolderFactory());\n-    } else {\n+    } else if (!msg.GetRows().empty()) {\n         ScanData->AddData(std::move(msg.MutableRows()), msg.GetTabletId(), TaskRunner->GetHolderFactory());\n     }\n     if (IsQuotingEnabled()) {\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.h b/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.h\nindex eae7196cfe9c..6d970f68d08d 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.h\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_actor.h\n@@ -11,6 +11,7 @@ namespace NKikimr::NKqp::NScanPrivate {\n class TKqpScanComputeActor: public NYql::NDq::TDqSyncComputeActorBase<TKqpScanComputeActor> {\n private:\n     using TBase = NYql::NDq::TDqSyncComputeActorBase<TKqpScanComputeActor>;\n+\n     NMiniKQL::TKqpScanComputeContext ComputeCtx;\n     NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta Meta;\n     using TBase::TaskRunner;\n@@ -22,15 +23,49 @@ class TKqpScanComputeActor: public NYql::NDq::TDqSyncComputeActorBase<TKqpScanCo\n     using TBase::ContinueExecute;\n     std::set<NActors::TActorId> Fetchers;\n     NMiniKQL::TKqpScanComputeContext::TScanData* ScanData = nullptr;\n+    const TMaybe<ui64> LockTxId;\n+    const ui32 LockNodeId;\n+\n+    struct TLockHash {\n+        bool operator()(const NKikimrDataEvents::TLock& lock) {\n+            return MultiHash(\n+                lock.GetLockId(),\n+                lock.GetDataShard(),\n+                lock.GetSchemeShard(),\n+                lock.GetPathId(),\n+                lock.GetGeneration(),\n+                lock.GetCounter(),\n+                lock.GetHasWrites());\n+        }\n+    };\n+\n+    struct TLockEqual {\n+        bool operator()(const NKikimrDataEvents::TLock& lhs, const NKikimrDataEvents::TLock& rhs) {\n+            return lhs.GetLockId() == rhs.GetLockId()\n+                && lhs.GetDataShard() == rhs.GetDataShard()\n+                && lhs.GetSchemeShard() == rhs.GetSchemeShard()\n+                && lhs.GetPathId() == rhs.GetPathId()\n+                && lhs.GetGeneration() == rhs.GetGeneration()\n+                && lhs.GetCounter() == rhs.GetCounter()\n+                && lhs.GetHasWrites() == rhs.GetHasWrites();\n+        }\n+    };\n+\n+    using TLocksHashSet = THashSet<NKikimrDataEvents::TLock, TLockHash, TLockEqual>;\n+\n+    TLocksHashSet Locks;\n+    TLocksHashSet BrokenLocks;\n+\n     ui64 CalcMkqlMemoryLimit() override {\n         return TBase::CalcMkqlMemoryLimit() + ComputeCtx.GetTableScans().size() * MemoryLimits.ChannelBufferSize;\n     }\n+\n public:\n     static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n         return NKikimrServices::TActivity::KQP_SCAN_COMPUTE_ACTOR;\n     }\n \n-    TKqpScanComputeActor(const TActorId& executerId, ui64 txId,\n+    TKqpScanComputeActor(const TActorId& executerId, ui64 txId, TMaybe<ui64> lockTxId, ui32 lockNodeId,\n         NYql::NDqProto::TDqTask* task, NYql::NDq::IDqAsyncIoFactory::TPtr asyncIoFactory,\n         const NYql::NDq::TComputeRuntimeSettings& settings, const NYql::NDq::TComputeMemoryLimits& memoryLimits, NWilson::TTraceId traceId,\n         TIntrusivePtr<NActors::TProtoArenaHolder> arena);\n@@ -62,6 +97,8 @@ class TKqpScanComputeActor: public NYql::NDq::TDqSyncComputeActorBase<TKqpScanCo\n \n     void FillExtraStats(NYql::NDqProto::TDqComputeActorStats* dst, bool last);\n \n+    TMaybe<google::protobuf::Any> ExtraData() override;\n+\n     void HandleEvWakeup(EEvWakeupTag tag);\n \n     void Handle(TEvScanExchange::TEvTerminateFromFetcher::TPtr& ev);\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp\nindex 0bc9a487e2ce..7eab5ef78196 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp\n@@ -20,23 +20,22 @@ std::vector<std::unique_ptr<TComputeTaskData>> TShardScannerInfo::OnReceiveData(\n     } else {\n         Finished = true;\n     }\n-    if (data.IsEmpty()) {\n-        AFL_ENSURE(data.Finished);\n-        return {};\n-    }\n     AFL_ENSURE(ActorId);\n     AFL_ENSURE(!DataChunksInFlightCount)(\"data_chunks_in_flightCount\", DataChunksInFlightCount);\n     std::vector<std::unique_ptr<TComputeTaskData>> result;\n-    if (data.SplittedBatches.size() > 1) {\n+    if (data.IsEmpty()) {\n+        AFL_ENSURE(data.Finished);\n+        result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(TabletId, data.LocksInfo)));\n+    } else if (data.SplittedBatches.size() > 1) {\n         ui32 idx = 0;\n         AFL_ENSURE(data.ArrowBatch);\n         for (auto&& i : data.SplittedBatches) {\n-            result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, std::move(i)), idx++));\n+            result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, std::move(i), data.LocksInfo), idx++));\n         }\n     } else if (data.ArrowBatch) {\n-        result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId)));\n+        result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, data.LocksInfo)));\n     } else {\n-        result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(std::move(data.Rows), TabletId)));\n+        result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(std::move(data.Rows), TabletId, data.LocksInfo)));\n     }\n     AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"receive_data\")(\"actor_id\", ActorId)(\"count_chunks\", result.size());\n     DataChunksInFlightCount = result.size();\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h\nindex 1e4d9ac58937..2d684d2f6b09 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h\n@@ -23,6 +23,7 @@ class TComputeTaskData;\n class TShardScannerInfo {\n private:\n     std::optional<TActorId> ActorId;\n+    const ui64 ScanId;\n     const ui64 TabletId;\n     const ui64 Generation;\n     i64 DataChunksInFlightCount = 0;\n@@ -51,15 +52,16 @@ class TShardScannerInfo {\n         }\n     }\n public:\n-    TShardScannerInfo(TShardState& state, const IExternalObjectsProvider& externalObjectsProvider)\n-        : TabletId(state.TabletId)\n+    TShardScannerInfo(const ui64 scanId, TShardState& state, const IExternalObjectsProvider& externalObjectsProvider)\n+        : ScanId(scanId)\n+        , TabletId(state.TabletId)\n         , Generation(++state.Generation)\n     {\n         const bool subscribed = std::exchange(state.SubscribedOnTablet, true);\n \n         const auto& keyColumnTypes = externalObjectsProvider.GetKeyColumnTypes();\n         auto ranges = state.GetScanRanges(keyColumnTypes);\n-        auto ev = externalObjectsProvider.BuildEvKqpScan(0, Generation, ranges);\n+        auto ev = externalObjectsProvider.BuildEvKqpScan(ScanId, Generation, ranges);\n \n         AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"start_scanner\")(\"tablet_id\", TabletId)(\"generation\", Generation)\n             (\"info\", state.ToString(keyColumnTypes))(\"range\", DebugPrintRanges(keyColumnTypes, ranges, *AppData()->TypeRegistry))\n@@ -250,6 +252,7 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {\n     THashMap<NActors::TActorId, TShardState::TPtr> ShardsByActorId;\n     bool IsActiveFlag = true;\n     THashMap<ui64, std::shared_ptr<TShardScannerInfo>> ShardScanners;\n+    const ui64 ScanId;\n     const IExternalObjectsProvider& ExternalObjectsProvider;\n public:\n \n@@ -313,7 +316,7 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {\n         AFL_ENSURE(state.TabletId);\n         AFL_ENSURE(!state.ActorId)(\"actor_id\", state.ActorId);\n         state.State = NComputeActor::EShardState::Starting;\n-        auto newScanner = std::make_shared<TShardScannerInfo>(state, ExternalObjectsProvider);\n+        auto newScanner = std::make_shared<TShardScannerInfo>(ScanId, state, ExternalObjectsProvider);\n         AFL_ENSURE(ShardScanners.emplace(state.TabletId, newScanner).second);\n     }\n \n@@ -356,8 +359,9 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {\n         return nullptr;\n     }\n \n-    TInFlightShards(const IExternalObjectsProvider& externalObjectsProvider)\n-        : ExternalObjectsProvider(externalObjectsProvider)\n+    TInFlightShards(const ui64 scanId, const IExternalObjectsProvider& externalObjectsProvider)\n+        : ScanId(scanId)\n+        , ExternalObjectsProvider(externalObjectsProvider)\n     {\n     }\n     bool IsActive() const {\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_events.h b/ydb/core/kqp/compute_actor/kqp_scan_events.h\nindex af455be7b7e7..08ac0e535a88 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_events.h\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_events.h\n@@ -43,33 +43,42 @@ struct TEvScanExchange {\n         YDB_ACCESSOR_DEF(TVector<TOwnedCellVec>, Rows);\n         YDB_READONLY(ui64, TabletId, 0);\n         YDB_ACCESSOR_DEF(std::vector<ui32>, DataIndexes);\n+        YDB_READONLY_DEF(TLocksInfo, LocksInfo);\n     public:\n         ui32 GetRowsCount() const {\n             return ArrowBatch ? ArrowBatch->num_rows() : Rows.size();\n         }\n \n-        TEvSendData(const std::shared_ptr<arrow::Table>& arrowBatch, const ui64 tabletId)\n+        TEvSendData(const std::shared_ptr<arrow::Table>& arrowBatch, const ui64 tabletId, const TLocksInfo& locksInfo)\n             : ArrowBatch(arrowBatch)\n             , TabletId(tabletId)\n+            , LocksInfo(locksInfo)\n         {\n             Y_ABORT_UNLESS(ArrowBatch);\n             Y_ABORT_UNLESS(ArrowBatch->num_rows());\n         }\n \n-        TEvSendData(const std::shared_ptr<arrow::Table>& arrowBatch, const ui64 tabletId, std::vector<ui32>&& dataIndexes)\n+        TEvSendData(const std::shared_ptr<arrow::Table>& arrowBatch, const ui64 tabletId, std::vector<ui32>&& dataIndexes, const TLocksInfo& locksInfo)\n             : ArrowBatch(arrowBatch)\n             , TabletId(tabletId)\n             , DataIndexes(std::move(dataIndexes))\n+            , LocksInfo(locksInfo)\n         {\n             Y_ABORT_UNLESS(ArrowBatch);\n             Y_ABORT_UNLESS(ArrowBatch->num_rows());\n         }\n \n-        TEvSendData(TVector<TOwnedCellVec>&& rows, const ui64 tabletId)\n+        TEvSendData(TVector<TOwnedCellVec>&& rows, const ui64 tabletId, const TLocksInfo& locksInfo)\n             : Rows(std::move(rows))\n-            , TabletId(tabletId) {\n+            , TabletId(tabletId)\n+            , LocksInfo(locksInfo) {\n             Y_ABORT_UNLESS(Rows.size());\n         }\n+\n+        TEvSendData(const ui64 tabletId, const TLocksInfo& locksInfo)\n+            : TabletId(tabletId)\n+            , LocksInfo(locksInfo) {\n+        }\n     };\n \n     class TEvAckData: public NActors::TEventLocal<TEvAckData, EvAckData> {\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp\nindex 4d4bfed29c89..73f4c86398b9 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp\n@@ -23,18 +23,20 @@ static constexpr ui64 MAX_SHARD_RESOLVES = 3;\n \n \n TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snapshot,\n-    const TComputeRuntimeSettings& settings, std::vector<NActors::TActorId>&& computeActors, const ui64 txId,\n+    const TComputeRuntimeSettings& settings, std::vector<NActors::TActorId>&& computeActors, const ui64 txId, const TMaybe<ui64> lockTxId, const ui32 lockNodeId,\n     const NKikimrTxDataShard::TKqpTransaction_TScanTaskMeta& meta, const TShardsScanningPolicy& shardsScanningPolicy,\n     TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId)\n     : Meta(meta)\n     , ScanDataMeta(Meta)\n     , RuntimeSettings(settings)\n     , TxId(txId)\n+    , LockTxId(lockTxId)\n+    , LockNodeId(lockNodeId)\n     , ComputeActorIds(std::move(computeActors))\n     , Snapshot(snapshot)\n     , ShardsScanningPolicy(shardsScanningPolicy)\n     , Counters(counters)\n-    , InFlightShards(*this)\n+    , InFlightShards(ScanId, *this)\n     , InFlightComputes(ComputeActorIds)\n {\n     Y_UNUSED(traceId);\n@@ -86,7 +88,11 @@ void TKqpScanFetcherActor::Bootstrap() {\n \n void TKqpScanFetcherActor::HandleExecute(TEvScanExchange::TEvAckData::TPtr& ev) {\n     Y_ABORT_UNLESS(ev->Get()->GetFreeSpace());\n-    ALS_DEBUG(NKikimrServices::KQP_COMPUTE) << \"EvAckData (\" << SelfId() << \"): \" << ev->Sender;\n+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"AckDataFromCompute\")(\"self_id\", SelfId())(\"scan_id\", ScanId)\n+        (\"packs_to_send\", InFlightComputes.GetPacksToSendCount())\n+        (\"from\", ev->Sender)(\"shards remain\", PendingShards.size())\n+        (\"in flight scans\", InFlightShards.GetScansCount())\n+        (\"in flight shards\", InFlightShards.GetShardsCount());\n     InFlightComputes.OnComputeAck(ev->Sender, ev->Get()->GetFreeSpace());\n     CheckFinish();\n }\n@@ -119,6 +125,25 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanData::TPtr& ev) {\n     }\n     AFL_ENSURE(state->State == EShardState::Running)(\"state\", state->State)(\"actor_id\", state->ActorId)(\"ev_sender\", ev->Sender);\n \n+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)\n+        (\"Recv TEvScanData from ShardID=\", ev->Sender)\n+        (\"ScanId\", ev->Get()->ScanId)\n+        (\"Finished\", ev->Get()->Finished)\n+        (\"Lock\", [&]() {\n+            TStringBuilder builder;\n+            for (const auto& lock : ev->Get()->LocksInfo.Locks) {\n+                builder << lock.ShortDebugString();\n+            }\n+            return builder;\n+        }())\n+        (\"BrokenLocks\", [&]() {\n+            TStringBuilder builder;\n+            for (const auto& lock : ev->Get()->LocksInfo.BrokenLocks) {\n+                builder << lock.ShortDebugString();\n+            }\n+            return builder;\n+        }());\n+\n     TInstant startTime = TActivationContext::Now();\n     if (ev->Get()->Finished) {\n         state->State = EShardState::PostRunning;\n@@ -411,6 +436,10 @@ std::unique_ptr<NKikimr::TEvDataShard::TEvKqpScan> TKqpScanFetcherActor::BuildEv\n     ev->Record.SetStatsMode(RuntimeSettings.StatsMode);\n     ev->Record.SetScanId(scanId);\n     ev->Record.SetTxId(std::get<ui64>(TxId));\n+    if (LockTxId) {\n+        ev->Record.SetLockTxId(*LockTxId);\n+    }\n+    ev->Record.SetLockNodeId(LockNodeId);\n     ev->Record.SetTablePath(ScanDataMeta.TablePath);\n     ev->Record.SetSchemaVersion(ScanDataMeta.TableId.SchemaVersion);\n \n@@ -458,12 +487,17 @@ void TKqpScanFetcherActor::ProcessPendingScanDataItem(TEvKqpCompute::TEvScanData\n \n     state->LastKey = std::move(msg.LastKey);\n     const ui64 rowsCount = msg.GetRowsCount();\n-    CA_LOG_D(\"action=got EvScanData;rows=\" << rowsCount << \";finished=\" << msg.Finished << \";exceeded=\" << msg.RequestedBytesLimitReached\n-        << \";from=\" << ev->Sender << \";shards remain=\" << PendingShards.size()\n-        << \";in flight scans=\" << InFlightShards.GetScansCount()\n-        << \";in flight shards=\" << InFlightShards.GetShardsCount()\n-        << \";delayed_for=\" << latency.SecondsFloat() << \" seconds by ratelimiter\"\n-        << \";tablet_id=\" << state->TabletId);\n+    AFL_ENSURE(!LockTxId || !msg.LocksInfo.Locks.empty() || !msg.LocksInfo.BrokenLocks.empty());\n+    AFL_ENSURE(LockTxId || (msg.LocksInfo.Locks.empty() && msg.LocksInfo.BrokenLocks.empty()));\n+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"action\",\"got EvScanData\")(\"rows\", rowsCount)(\"finished\", msg.Finished)(\"exceeded\", msg.RequestedBytesLimitReached)\n+        (\"scan\", ScanId)(\"packs_to_send\", InFlightComputes.GetPacksToSendCount())\n+        (\"from\", ev->Sender)(\"shards remain\", PendingShards.size())\n+        (\"in flight scans\", InFlightShards.GetScansCount())\n+        (\"in flight shards\", InFlightShards.GetShardsCount())\n+        (\"delayed_for_seconds_by_ratelimiter\", latency.SecondsFloat())\n+        (\"tablet_id\", state->TabletId)\n+        (\"locks\", msg.LocksInfo.Locks.size())\n+        (\"broken locks\", msg.LocksInfo.BrokenLocks.size());\n     auto shardScanner = InFlightShards.GetShardScannerVerified(state->TabletId);\n     auto tasksForCompute = shardScanner->OnReceiveData(msg, shardScanner);\n     AFL_ENSURE(tasksForCompute.size() == 1 || tasksForCompute.size() == 0 || tasksForCompute.size() == ComputeActorIds.size())(\"size\", tasksForCompute.size())(\"compute_size\", ComputeActorIds.size());\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h\nindex 962aee326470..0bd2bfc1d58b 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h\n@@ -50,13 +50,15 @@ class TKqpScanFetcherActor: public NActors::TActorBootstrapped<TKqpScanFetcherAc\n     const NMiniKQL::TScanDataMetaFull ScanDataMeta;\n     const NYql::NDq::TComputeRuntimeSettings RuntimeSettings;\n     const NYql::NDq::TTxId TxId;\n+    const TMaybe<ui64> LockTxId;\n+    const ui32 LockNodeId;\n public:\n     static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n         return NKikimrServices::TActivity::KQP_SCAN_FETCH_ACTOR;\n     }\n \n     TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snapshot, const NYql::NDq::TComputeRuntimeSettings& settings,\n-        std::vector<NActors::TActorId>&& computeActors, const ui64 txId,\n+        std::vector<NActors::TActorId>&& computeActors, const ui64 txId, const TMaybe<ui64> lockTxId, const ui32 lockNodeId,\n         const NKikimrTxDataShard::TKqpTransaction_TScanTaskMeta& meta,\n         const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId);\n \n@@ -168,6 +170,9 @@ class TKqpScanFetcherActor: public NActors::TActorBootstrapped<TKqpScanFetcherAc\n     std::deque<TShardState> PendingShards;\n     std::deque<TShardState> PendingResolveShards;\n \n+    static inline TAtomicCounter ScanIdCounter = 0;\n+    const ui64 ScanId = ScanIdCounter.Inc();\n+\n     TInFlightShards InFlightShards;\n     TInFlightComputes InFlightComputes;\n     ui32 TotalRetries = 0;\ndiff --git a/ydb/core/kqp/compute_actor/ya.make b/ydb/core/kqp/compute_actor/ya.make\nindex 50d029c6bacf..7b45cfa31530 100644\n--- a/ydb/core/kqp/compute_actor/ya.make\n+++ b/ydb/core/kqp/compute_actor/ya.make\n@@ -22,7 +22,8 @@ PEERDIR(\n     ydb/core/kqp/runtime\n     ydb/core/tx/datashard\n     ydb/core/tx/scheme_cache\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n+    ydb/library/formats/arrow/common\n     ydb/library/yql/dq/actors/compute\n     ydb/library/yql/providers/generic/actors\n     ydb/library/yql/providers/s3/actors_factory\ndiff --git a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\nindex 8716565a269d..b97e71161824 100644\n--- a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\n@@ -279,6 +279,9 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             for (const auto& sink : data.GetSinksExtraData()) {\n                 addLocks(sink);\n             }\n+            if (data.HasComputeExtraData()) {\n+                addLocks(data.GetComputeExtraData());\n+            }\n         }\n \n         ResponseEv->Snapshot = GetSnapshot();\n@@ -495,10 +498,20 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n         NYql::TIssues issues;\n         NYql::IssuesFromMessage(res->Record.GetIssues(), issues);\n-        LOG_D(\"Got evWrite result, shard: \" << shardId << \", status: \"\n-            << NKikimrDataEvents::TEvWriteResult::EStatus_Name(res->Record.GetStatus())\n-            << \", error: \" << issues.ToString());\n \n+        LOG_D(\"Recv EvWriteResult (prepare) from ShardID=\" << shardId\n+            << \", Status=\" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())\n+            << \", TxId=\" << ev->Get()->Record.GetTxId()\n+            << \", Locks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }()\n+            << \", Cookie=\" << ev->Cookie\n+            << \", error=\" << issues.ToString());\n+    \n         if (Stats) {\n             Stats->AddDatashardPrepareStats(std::move(*res->Record.MutableTxStats()));\n         }\n@@ -516,6 +529,19 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             case NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED: {\n                 YQL_ENSURE(false);\n             }\n+            case NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN: {\n+                LOG_D(\"Broken locks: \" << res->Record.DebugString());\n+                YQL_ENSURE(shardState->State == TShardState::EState::Preparing);\n+                Counters->TxProxyMon->TxResultAborted->Inc();\n+                LocksBroken = true;\n+\n+                if (!res->Record.GetTxLocks().empty()) {\n+                    ResponseEv->BrokenLockPathId = NYql::TKikimrPathId(\n+                        res->Record.GetTxLocks(0).GetSchemeShard(),\n+                        res->Record.GetTxLocks(0).GetPathId());\n+                }\n+                ReplyErrorAndDie(Ydb::StatusIds::ABORTED, {});\n+            }\n             default:\n             {\n                 return ShardError(res->Record);\n@@ -891,6 +917,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 return ReplyErrorAndDie(Ydb::StatusIds::SCHEME_ERROR, issues);\n             }\n             case NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN: {\n+                issues.AddIssue(NYql::YqlIssue({}, TIssuesIds::KIKIMR_LOCKS_INVALIDATED, \"Transaction locks invalidated.\"));\n                 return ReplyErrorAndDie(Ydb::StatusIds::ABORTED, issues);\n             }\n         }\n@@ -951,6 +978,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n     }\n \n     void ExecutePlanned() {\n+        YQL_ENSURE(!LocksBroken);\n         YQL_ENSURE(TxCoordinator);\n         auto ev = MakeHolder<TEvTxProxy::TEvProposeTransaction>();\n         ev->Record.SetCoordinatorID(TxCoordinator);\n@@ -1158,9 +1186,19 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n         NYql::TIssues issues;\n         NYql::IssuesFromMessage(res->Record.GetIssues(), issues);\n-        LOG_D(\"Got evWrite result, shard: \" << shardId << \", status: \"\n-            << NKikimrDataEvents::TEvWriteResult::EStatus_Name(res->Record.GetStatus())\n-            << \", error: \" << issues.ToString());\n+\n+        LOG_D(\"Recv EvWriteResult (execute) from ShardID=\" << shardId\n+            << \", Status=\" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())\n+            << \", TxId=\" << ev->Get()->Record.GetTxId()\n+            << \", Locks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }()\n+            << \", Cookie=\" << ev->Cookie\n+            << \", error=\" << issues.ToString());\n \n         if (Stats) {\n             Stats->AddDatashardStats(std::move(*res->Record.MutableTxStats()));\n@@ -1189,14 +1227,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 shardState->State = TShardState::EState::Finished;\n                 Counters->TxProxyMon->TxResultAborted->Inc();\n                 LocksBroken = true;\n-\n                 if (!res->Record.GetTxLocks().empty()) {\n                     ResponseEv->BrokenLockPathId = NYql::TKikimrPathId(\n                         res->Record.GetTxLocks(0).GetSchemeShard(),\n                         res->Record.GetTxLocks(0).GetPathId());\n-                    return ReplyErrorAndDie(Ydb::StatusIds::ABORTED, {});\n+                    ReplyErrorAndDie(Ydb::StatusIds::ABORTED, {});\n                 }\n-\n                 CheckExecutionComplete();\n                 return;\n             }\n@@ -1705,18 +1741,15 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n     }\n \n     void ExecuteEvWriteTransaction(ui64 shardId, NKikimrDataEvents::TEvWrite& evWrite) {\n-        YQL_ENSURE(!ImmediateTx);\n         TShardState shardState;\n-        shardState.State = TShardState::EState::Preparing;\n+        shardState.State = ImmediateTx ? TShardState::EState::Executing : TShardState::EState::Preparing;\n         shardState.DatashardState.ConstructInPlace();\n \n         auto evWriteTransaction = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>();\n         evWriteTransaction->Record = evWrite;\n-        evWriteTransaction->Record.SetTxMode(NKikimrDataEvents::TEvWrite::MODE_PREPARE);\n+        evWriteTransaction->Record.SetTxMode(ImmediateTx ? NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE : NKikimrDataEvents::TEvWrite::MODE_PREPARE);\n         evWriteTransaction->Record.SetTxId(TxId);\n \n-        evWriteTransaction->Record.MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Commit);\n-\n         auto locksCount = evWriteTransaction->Record.GetLocks().LocksSize();\n         shardState.DatashardState->ShardReadLocks = locksCount > 0;\n \n@@ -1727,6 +1760,29 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n         auto traceId = ExecuterSpan.GetTraceId();\n \n+        auto shardsToString = [](const auto& shards) {\n+            TStringBuilder builder;\n+            for (const auto& shard : shards) {\n+                builder << shard << \" \";\n+            }\n+            return builder;\n+        };\n+\n+        LOG_D(\"Send EvWrite to ShardID=\" << shardId\n+            << \", TxId=\" << evWriteTransaction->Record.GetTxId()\n+            << \", TxMode=\" << evWriteTransaction->Record.GetTxMode()\n+            << \", LockTxId=\" << evWriteTransaction->Record.GetLockTxId() << \", LockNodeId=\" << evWriteTransaction->Record.GetLockNodeId()\n+            << \", LocksOp=\" << NKikimrDataEvents::TKqpLocks::ELocksOp_Name(evWriteTransaction->Record.GetLocks().GetOp())\n+            << \", SendingShards=\" << shardsToString(evWriteTransaction->Record.GetLocks().GetSendingShards())\n+            << \", ReceivingShards=\" << shardsToString(evWriteTransaction->Record.GetLocks().GetReceivingShards())\n+            << \", Locks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : evWriteTransaction->Record.GetLocks().GetLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }());\n+\n         LOG_D(\"ExecuteEvWriteTransaction traceId.verbosity: \" << std::to_string(traceId.GetVerbosity()));\n \n         Send(MakePipePerNodeCacheID(false), new TEvPipeCache::TEvForward(evWriteTransaction.release(), shardId, true), 0, 0, std::move(traceId));\n@@ -2445,12 +2501,10 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n     }\n \n     void ExecuteTasks() {\n-        {\n-            auto lockTxId = Request.AcquireLocksTxId;\n-            if (lockTxId.Defined() && *lockTxId == 0) {\n-                lockTxId = TxId;\n-                LockHandle = TLockHandle(TxId, TActivationContext::ActorSystem());\n-            }\n+        auto lockTxId = Request.AcquireLocksTxId;\n+        if (lockTxId.Defined() && *lockTxId == 0) {\n+            lockTxId = TxId;\n+            LockHandle = TLockHandle(TxId, TActivationContext::ActorSystem());\n         }\n \n         LWTRACK(KqpDataExecuterStartTasksAndTxs, ResponseEv->Orbit, TxId, ComputeTasks.size(), DatashardTxs.size() + EvWriteTxs.size());\n@@ -2472,6 +2526,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         Planner = CreateKqpPlanner({\n             .TasksGraph = TasksGraph,\n             .TxId = TxId,\n+            .LockTxId = lockTxId,\n+            .LockNodeId = SelfId().NodeId(),\n             .Executer = SelfId(),\n             .Snapshot = GetSnapshot(),\n             .Database = Database,\ndiff --git a/ydb/core/kqp/executer_actor/kqp_planner.cpp b/ydb/core/kqp/executer_actor/kqp_planner.cpp\nindex 696b8732c1d1..e6699c72e2b3 100644\n--- a/ydb/core/kqp/executer_actor/kqp_planner.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_planner.cpp\n@@ -63,6 +63,8 @@ constexpr ui32 MEMORY_ESTIMATION_OVERFLOW = 2;\n \n TKqpPlanner::TKqpPlanner(TKqpPlanner::TArgs&& args)\n     : TxId(args.TxId)\n+    , LockTxId(args.LockTxId)\n+    , LockNodeId(args.LockNodeId)\n     , ExecuterId(args.Executer)\n     , Snapshot(args.Snapshot)\n     , Database(args.Database)\n@@ -88,7 +90,6 @@ TKqpPlanner::TKqpPlanner(TKqpPlanner::TArgs&& args)\n     , ResourceManager_(args.ResourceManager_)\n     , CaFactory_(args.CaFactory_)\n {\n-\n     if (GUCSettings) {\n         SerializedGUCSettings = GUCSettings->SerializeToString();\n     }\n@@ -176,6 +177,10 @@ std::unique_ptr<TEvKqpNode::TEvStartKqpTasksRequest> TKqpPlanner::SerializeReque\n     auto result = std::make_unique<TEvKqpNode::TEvStartKqpTasksRequest>(TasksGraph.GetMeta().GetArenaIntrusivePtr());\n     auto& request = result->Record;\n     request.SetTxId(TxId);\n+    if (LockTxId) {\n+        request.SetLockTxId(*LockTxId);\n+    }\n+    request.SetLockNodeId(LockNodeId);\n     ActorIdToProto(ExecuterId, request.MutableExecuterActorId());\n \n     if (Deadline) {\n@@ -421,6 +426,8 @@ TString TKqpPlanner::ExecuteDataComputeTask(ui64 taskId, ui32 computeTasksSize)\n     auto startResult = CaFactory_->CreateKqpComputeActor({\n         .ExecuterId = ExecuterId,\n         .TxId = TxId,\n+        .LockTxId = LockTxId,\n+        .LockNodeId = LockNodeId,\n         .Task = taskDesc,\n         .TxInfo = TxInfo,\n         .RuntimeSettings = settings,\ndiff --git a/ydb/core/kqp/executer_actor/kqp_planner.h b/ydb/core/kqp/executer_actor/kqp_planner.h\nindex 03ce07758cf5..e868cc84f6a0 100644\n--- a/ydb/core/kqp/executer_actor/kqp_planner.h\n+++ b/ydb/core/kqp/executer_actor/kqp_planner.h\n@@ -43,6 +43,8 @@ class TKqpPlanner {\n     struct TArgs {\n         TKqpTasksGraph& TasksGraph;\n         const ui64 TxId;\n+        const TMaybe<ui64> LockTxId;\n+        const ui32 LockNodeId;\n         const TActorId& Executer;\n         const IKqpGateway::TKqpSnapshot& Snapshot;\n         const TString& Database;\n@@ -96,6 +98,8 @@ class TKqpPlanner {\n \n private:\n     const ui64 TxId;\n+    const TMaybe<ui64> LockTxId;\n+    const ui32 LockNodeId;\n     const TActorId ExecuterId;\n     TVector<ui64> ComputeTasks;\n     THashMap<ui64, TVector<ui64>> TasksPerNode;\ndiff --git a/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.cpp b/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.cpp\nindex 1467a61bc38e..b000a2fd94a4 100644\n--- a/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.cpp\n+++ b/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.cpp\n@@ -16,15 +16,21 @@ TConclusionStatus TAlterColumnOperation::DoDeserialize(NYql::TObjectSettingsImpl\n     if (StorageId && !*StorageId) {\n         return TConclusionStatus::Fail(\"STORAGE_ID cannot be empty string\");\n     }\n+    {\n+        auto status = AccessorConstructor.DeserializeFromRequest(features);\n+        if (status.IsFail()) {\n+            return status;\n+        }\n+    }\n     {\n         auto result = DictionaryEncodingDiff.DeserializeFromRequestFeatures(features);\n-        if (!result) {\n-            return TConclusionStatus::Fail(result.GetErrorMessage());\n+        if (result.IsFail()) {\n+            return result;\n         }\n     }\n     {\n         auto status = Serializer.DeserializeFromRequest(features);\n-        if (!status) {\n+        if (status.IsFail()) {\n             return status;\n         }\n     }\n@@ -40,6 +46,9 @@ void TAlterColumnOperation::DoSerializeScheme(NKikimrSchemeOp::TAlterColumnTable\n     if (!!Serializer) {\n         Serializer.SerializeToProto(*column->MutableSerializer());\n     }\n+    if (!!AccessorConstructor) {\n+        *column->MutableDataAccessorConstructor() = AccessorConstructor.SerializeToProto();\n+    }\n     *column->MutableDictionaryEncoding() = DictionaryEncodingDiff.SerializeToProto();\n     if (DefaultValue) {\n         column->SetDefaultValue(*DefaultValue);\ndiff --git a/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.h b/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.h\nindex ee51b47bb8df..23d1aef28abb 100644\n--- a/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.h\n+++ b/ydb/core/kqp/gateway/behaviour/tablestore/operations/alter_column.h\n@@ -1,4 +1,5 @@\n #include \"abstract.h\"\n+#include <ydb/core/formats/arrow/accessor/abstract/request.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n #include <ydb/core/formats/arrow/dictionary/diff.h>\n \n@@ -18,6 +19,7 @@ class TAlterColumnOperation : public ITableStoreOperation {\n     NArrow::NSerialization::TSerializerContainer Serializer;\n     NArrow::NDictionary::TEncodingDiff DictionaryEncodingDiff;\n     std::optional<TString> DefaultValue;\n+    NArrow::NAccessor::TRequestedConstructorContainer AccessorConstructor;\n public:\n     TConclusionStatus DoDeserialize(NYql::TObjectSettingsImpl::TFeaturesExtractor& features) override;\n \ndiff --git a/ydb/core/kqp/host/kqp_explain_prepared.cpp b/ydb/core/kqp/host/kqp_explain_prepared.cpp\nindex 91ee362da0f1..f76ce851140c 100644\n--- a/ydb/core/kqp/host/kqp_explain_prepared.cpp\n+++ b/ydb/core/kqp/host/kqp_explain_prepared.cpp\n@@ -66,7 +66,7 @@ class TKqpExplainPreparedTransformer : public NYql::TGraphTransformerBase {\n \n         PhyQuerySetTxPlans(query, TKqpPhysicalQuery(TransformCtx->ExplainTransformerInput), std::move(TxResults),\n             ctx, Cluster, TransformCtx->Tables, TransformCtx->Config, TypeCtx, OptimizeCtx);\n-        query.SetQueryAst(KqpExprToPrettyString(*TransformCtx->ExplainTransformerInput, ctx));\n+        query.SetQueryAst(KqpExprToPrettyString(*input, ctx));\n \n         TransformCtx->ExplainTransformerInput = nullptr;\n         return TStatus::Ok;\ndiff --git a/ydb/core/kqp/host/kqp_host.cpp b/ydb/core/kqp/host/kqp_host.cpp\nindex 3e98f7db8aa3..571234063e59 100644\n--- a/ydb/core/kqp/host/kqp_host.cpp\n+++ b/ydb/core/kqp/host/kqp_host.cpp\n@@ -1258,8 +1258,13 @@ class TKqpHost : public IKqpHost {\n         YQL_CLOG(INFO, ProviderKqp) << \"Compiled query:\\n\" << KqpExprToPrettyString(*queryExpr, ctx);\n \n         if (Config->EnableCreateTableAs) {\n-            result.QueryExprs = RewriteExpression(queryExpr, ctx, *TypesCtx, SessionCtx, Cluster);\n+            auto [rewriteResults, rewriteIssues] = RewriteExpression(queryExpr, ctx, *TypesCtx, SessionCtx, Cluster);\n+            ctx.IssueManager.AddIssues(rewriteIssues);\n+            if (!rewriteIssues.Empty()) {\n+                return result;\n+            }\n \n+            result.QueryExprs = rewriteResults;\n             for (const auto& resultPart : result.QueryExprs) {\n                 YQL_CLOG(INFO, ProviderKqp) << \"Splitted Compiled query part:\\n\" << KqpExprToPrettyString(*resultPart, ctx);\n             }\n@@ -1279,7 +1284,7 @@ class TKqpHost : public IKqpHost {\n         settingsBuilder\n             .SetSqlAutoCommit(false)\n             .SetUsePgParser(settings.UsePgParser);\n-        auto compileResult = CompileYqlQuery(query, /* isSql */ true, *ExprCtx, sqlVersion, settingsBuilder, settings.PerStatementResult);\n+        auto compileResult = CompileYqlQuery(query, /* isSql */ true, *ExprCtx, sqlVersion, settingsBuilder);\n \n         return TSplitResult{\n             .Ctx = std::move(ExprCtxStorage),\n@@ -1289,7 +1294,7 @@ class TKqpHost : public IKqpHost {\n     }\n \n     TCompileExprResult CompileYqlQuery(const TKqpQueryRef& query, bool isSql, TExprContext& ctx, TMaybe<TSqlVersion>& sqlVersion,\n-        TKqpTranslationSettingsBuilder& settingsBuilder, bool perStatementResult) const\n+        TKqpTranslationSettingsBuilder& settingsBuilder) const\n     {\n         auto compileResult = CompileQuery(query, isSql, ctx, sqlVersion, settingsBuilder);\n         if (!compileResult.QueryExprs) {\n@@ -1301,12 +1306,7 @@ class TKqpHost : public IKqpHost {\n         }\n \n         // Currently used only for create table as\n-        if (!perStatementResult && compileResult.QueryExprs.size() > 1) {\n-            ctx.AddError(YqlIssue(TPosition(), TIssuesIds::KIKIMR_BAD_REQUEST,\n-                \"Query can be executed only in per-statement mode (NoTx)\"));\n-            compileResult.QueryExprs = {};\n-            return compileResult;\n-        } else if (compileResult.QueryExprs.size() > 1) {\n+        if (compileResult.QueryExprs.size() > 1) {\n             return compileResult;\n         }\n \n@@ -1378,7 +1378,7 @@ class TKqpHost : public IKqpHost {\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, query.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(false)\n             .SetUsePgParser(settings.UsePgParser);\n-        auto compileResult = CompileYqlQuery(query, isSql, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(query, isSql, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1438,7 +1438,7 @@ class TKqpHost : public IKqpHost {\n         TMaybe<TSqlVersion> sqlVersion;\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, query.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(false);\n-        auto compileResult = CompileYqlQuery(query, /* isSql */ true, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(query, /* isSql */ true, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1466,7 +1466,7 @@ class TKqpHost : public IKqpHost {\n         TMaybe<TSqlVersion> sqlVersion;\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, queryAst.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(false);\n-        auto compileResult = CompileYqlQuery(queryAst, false, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(queryAst, false, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1512,7 +1512,7 @@ class TKqpHost : public IKqpHost {\n             TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, query.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n             settingsBuilder.SetSqlAutoCommit(false)\n                 .SetUsePgParser(settings.UsePgParser);\n-            auto compileResult = CompileYqlQuery(query, /* isSql */ true, ctx, sqlVersion, settingsBuilder, settings.PerStatementResult);\n+            auto compileResult = CompileYqlQuery(query, /* isSql */ true, ctx, sqlVersion, settingsBuilder);\n             if (compileResult.QueryExprs.empty()) {\n                 return nullptr;\n             }\n@@ -1549,7 +1549,7 @@ class TKqpHost : public IKqpHost {\n         TMaybe<TSqlVersion> sqlVersion = 1;\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, query.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(false);\n-        auto compileResult = CompileYqlQuery(query, true, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(query, true, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1570,7 +1570,7 @@ class TKqpHost : public IKqpHost {\n         TMaybe<TSqlVersion> sqlVersion;\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, queryAst.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(false);\n-        auto compileResult = CompileYqlQuery(queryAst, false, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(queryAst, false, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1597,7 +1597,7 @@ class TKqpHost : public IKqpHost {\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, script.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(true)\n             .SetUsePgParser(settings.UsePgParser);\n-        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1626,7 +1626,7 @@ class TKqpHost : public IKqpHost {\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, script.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(true)\n             .SetUsePgParser(settings.UsePgParser);\n-        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1650,7 +1650,7 @@ class TKqpHost : public IKqpHost {\n         TMaybe<TSqlVersion> sqlVersion;\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, script.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(true);\n-        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\n@@ -1678,7 +1678,7 @@ class TKqpHost : public IKqpHost {\n         TMaybe<TSqlVersion> sqlVersion;\n         TKqpTranslationSettingsBuilder settingsBuilder(SessionCtx->Query().Type, SessionCtx->Config()._KqpYqlSyntaxVersion.Get().GetRef(), Cluster, script.Text, SessionCtx->Config().BindingsMode, GUCSettings);\n         settingsBuilder.SetSqlAutoCommit(true);\n-        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder, false);\n+        auto compileResult = CompileYqlQuery(script, true, ctx, sqlVersion, settingsBuilder);\n         if (compileResult.QueryExprs.empty()) {\n             return nullptr;\n         }\ndiff --git a/ydb/core/kqp/host/kqp_host.h b/ydb/core/kqp/host/kqp_host.h\nindex 85a7025a9e1b..f0e2b236e9f1 100644\n--- a/ydb/core/kqp/host/kqp_host.h\n+++ b/ydb/core/kqp/host/kqp_host.h\n@@ -45,7 +45,6 @@ class IKqpHost : public TThrRefBase {\n     struct TPrepareSettings: public TExecSettings {\n         TMaybe<bool> IsInternalCall;\n         TMaybe<bool> ConcurrentResults;\n-        bool PerStatementResult;\n \n         TString ToString() const {\n             return TStringBuilder() << \"TPrepareSettings{\"\ndiff --git a/ydb/core/kqp/host/kqp_statement_rewrite.cpp b/ydb/core/kqp/host/kqp_statement_rewrite.cpp\nindex bf15ab483261..fa06bf64bfb4 100644\n--- a/ydb/core/kqp/host/kqp_statement_rewrite.cpp\n+++ b/ydb/core/kqp/host/kqp_statement_rewrite.cpp\n@@ -213,12 +213,10 @@ namespace {\n                 exprCtx.NewAtom(pos, \"mode\"),\n                 exprCtx.NewAtom(pos, \"replace\"),\n             }));\n-        if (!isOlap) {\n-            insertSettings.push_back(\n-                exprCtx.NewList(pos, {\n-                    exprCtx.NewAtom(pos, \"AllowInconsistentWrites\"),\n-                }));\n-        }\n+        insertSettings.push_back(\n+            exprCtx.NewList(pos, {\n+                exprCtx.NewAtom(pos, \"AllowInconsistentWrites\"),\n+            }));\n \n         const auto insert = exprCtx.NewCallable(pos, \"Write!\", {\n             topLevelRead == nullptr ? exprCtx.NewWorld(pos) : exprCtx.NewCallable(pos, \"Left!\", {topLevelRead.Get()}),\n@@ -292,20 +290,25 @@ namespace {\n     }\n }\n \n-TVector<NYql::TExprNode::TPtr> RewriteExpression(\n+std::pair<TVector<NYql::TExprNode::TPtr>, NYql::TIssues> RewriteExpression(\n         const NYql::TExprNode::TPtr& root,\n         NYql::TExprContext& exprCtx,\n         NYql::TTypeAnnotationContext& typeCtx,\n         const TIntrusivePtr<NYql::TKikimrSessionContext>& sessionCtx,\n         const TString& cluster) {\n+    NYql::TIssues issues;\n     // CREATE TABLE AS statement can be used only with perstatement execution.\n     // Thus we assume that there is only one such statement.\n+    ui64 actionsCount = 0;\n     TVector<NYql::TExprNode::TPtr> result;\n     VisitExpr(root, [&](const NYql::TExprNode::TPtr& node) {\n         if (NYql::NNodes::TCoWrite::Match(node.Get())) {\n+            ++actionsCount;\n             const auto rewriteResult = RewriteCreateTableAs(node, exprCtx, typeCtx, sessionCtx, cluster);\n             if (rewriteResult) {\n-                YQL_ENSURE(result.empty());\n+                if (!result.empty()) {\n+                    issues.AddIssue(\"Several CTAS statement can't be used without per-statement mode.\");\n+                }\n                 result.push_back(rewriteResult->CreateTable);\n                 result.push_back(rewriteResult->ReplaceInto);\n                 if (rewriteResult->MoveTable) {\n@@ -316,10 +319,14 @@ TVector<NYql::TExprNode::TPtr> RewriteExpression(\n         return true;\n     });\n \n+    if (!result.empty() && actionsCount > 1) {\n+        issues.AddIssue(\"CTAS statement can't be used with other statements without per-statement mode.\");\n+    }\n+\n     if (result.empty()) {\n         result.push_back(root);\n     }\n-    return result;\n+    return {result, issues};\n }\n \n }\ndiff --git a/ydb/core/kqp/host/kqp_statement_rewrite.h b/ydb/core/kqp/host/kqp_statement_rewrite.h\nindex 95c4b3a506d1..3b9b560c5684 100644\n--- a/ydb/core/kqp/host/kqp_statement_rewrite.h\n+++ b/ydb/core/kqp/host/kqp_statement_rewrite.h\n@@ -7,7 +7,7 @@\n namespace NKikimr {\n namespace NKqp {\n \n-TVector<NYql::TExprNode::TPtr> RewriteExpression(\n+std::pair<TVector<NYql::TExprNode::TPtr>, NYql::TIssues> RewriteExpression(\n     const NYql::TExprNode::TPtr& root,\n     NYql::TExprContext& ctx,\n     NYql::TTypeAnnotationContext& typeCtx,\ndiff --git a/ydb/core/kqp/node_service/kqp_node_service.cpp b/ydb/core/kqp/node_service/kqp_node_service.cpp\nindex 78ec3ab72022..9e7e1593130a 100644\n--- a/ydb/core/kqp/node_service/kqp_node_service.cpp\n+++ b/ydb/core/kqp/node_service/kqp_node_service.cpp\n@@ -133,6 +133,10 @@ class TKqpNodeService : public TActorBootstrapped<TKqpNodeService> {\n         auto requester = ev->Sender;\n \n         ui64 txId = msg.GetTxId();\n+        TMaybe<ui64> lockTxId = msg.HasLockTxId()\n+            ? TMaybe<ui64>(msg.GetLockTxId())\n+            : Nothing();\n+        ui32 lockNodeId = msg.GetLockNodeId();\n \n         YQL_ENSURE(msg.GetStartAllOrFail()); // todo: support partial start\n \n@@ -191,6 +195,8 @@ class TKqpNodeService : public TActorBootstrapped<TKqpNodeService> {\n             auto result = CaFactory_->CreateKqpComputeActor({\n                 .ExecuterId = request.Executer,\n                 .TxId = txId,\n+                .LockTxId = lockTxId,\n+                .LockNodeId = lockNodeId,\n                 .Task = &dqTask,\n                 .TxInfo = txInfo,\n                 .RuntimeSettings = runtimeSettingsBase,\n@@ -235,7 +241,7 @@ class TKqpNodeService : public TActorBootstrapped<TKqpNodeService> {\n         for (auto&& i : computesByStage) {\n             for (auto&& m : i.second.MutableMetaInfo()) {\n                 Register(CreateKqpScanFetcher(msg.GetSnapshot(), std::move(m.MutableActorIds()),\n-                    m.GetMeta(), runtimeSettingsBase, txId, scanPolicy, Counters, NWilson::TTraceId(ev->TraceId)));\n+                    m.GetMeta(), runtimeSettingsBase, txId, lockTxId, lockNodeId, scanPolicy, Counters, NWilson::TTraceId(ev->TraceId)));\n             }\n         }\n \ndiff --git a/ydb/core/kqp/opt/kqp_opt.cpp b/ydb/core/kqp/opt/kqp_opt.cpp\nindex b056c9c4b955..bd0797040f6c 100644\n--- a/ydb/core/kqp/opt/kqp_opt.cpp\n+++ b/ydb/core/kqp/opt/kqp_opt.cpp\n@@ -83,7 +83,7 @@ bool IsKqpEffectsStage(const TDqStageBase& stage) {\n }\n \n bool NeedSinks(const TKikimrTableDescription& table, const TKqpOptimizeContext& kqpCtx) {\n-    return kqpCtx.IsGenericQuery()\n+    return (kqpCtx.IsGenericQuery() || (kqpCtx.IsDataQuery() && table.Metadata->Kind != EKikimrTableKind::Olap))\n         && (table.Metadata->Kind != EKikimrTableKind::Olap || kqpCtx.Config->EnableOlapSink)\n         && (table.Metadata->Kind != EKikimrTableKind::Datashard || kqpCtx.Config->EnableOltpSink);\n }\ndiff --git a/ydb/core/kqp/opt/kqp_query_plan.cpp b/ydb/core/kqp/opt/kqp_query_plan.cpp\nindex e00ff75bfff2..66b113f0b86b 100644\n--- a/ydb/core/kqp/opt/kqp_query_plan.cpp\n+++ b/ydb/core/kqp/opt/kqp_query_plan.cpp\n@@ -2,7 +2,7 @@\n \n #include <ydb/core/kqp/common/kqp_yql.h>\n #include <ydb/core/kqp/provider/yql_kikimr_provider_impl.h>\n-#include <ydb/core/formats/arrow/protos/ssa.pb.h>\n+#include <ydb/library/formats/arrow/protos/ssa.pb.h>\n #include <ydb/core/kqp/opt/kqp_opt.h>\n #include <ydb/public/lib/value/value.h>\n \ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp\nindex 5092bbeec38d..ffe2ffae4c53 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp\n@@ -299,11 +299,6 @@ TExprBase KqpPushOlapAggregate(TExprBase node, TExprContext& ctx, const TKqpOpti\n         return node;\n     }\n \n-    // temporary for keys grouping push down not useful\n-    if (!aggCombine.Keys().Empty()) {\n-        return node;\n-    }\n-\n     auto read = maybeRead.Cast();\n     auto aggs = Build<TKqpOlapAggOperationList>(ctx, node.Pos());\n \ndiff --git a/ydb/core/kqp/opt/ya.make b/ydb/core/kqp/opt/ya.make\nindex 6f07040d1180..160eb3a8a5f0 100644\n--- a/ydb/core/kqp/opt/ya.make\n+++ b/ydb/core/kqp/opt/ya.make\n@@ -27,7 +27,7 @@ PEERDIR(\n     ydb/library/yql/providers/s3/expr_nodes\n     ydb/library/yql/utils/plan\n     ydb/core/kqp/provider\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n )\n \n YQL_LAST_ABI_VERSION()\ndiff --git a/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp\nindex 73d2fc836863..b2ed454f6e66 100644\n--- a/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp\n+++ b/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp\n@@ -2,7 +2,7 @@\n \n #include <ydb/core/formats/arrow/arrow_helpers.h>\n #include <ydb/core/formats/arrow/ssa_runtime_version.h>\n-#include <ydb/core/formats/arrow/protos/ssa.pb.h>\n+#include <ydb/library/formats/arrow/protos/ssa.pb.h>\n \n #include <ydb/library/yql/core/arrow_kernels/request/request.h>\n #include <ydb/library/yql/core/yql_expr_type_annotation.h>\ndiff --git a/ydb/core/kqp/query_data/kqp_predictor.cpp b/ydb/core/kqp/query_data/kqp_predictor.cpp\nindex 9c0ce87d73e4..3cf0b3b97187 100644\n--- a/ydb/core/kqp/query_data/kqp_predictor.cpp\n+++ b/ydb/core/kqp/query_data/kqp_predictor.cpp\n@@ -131,7 +131,7 @@ ui32 TStagePredictor::GetUsableThreads() {\n         userPoolSize = TlsActivationContext->ActorSystem()->GetPoolThreadsCount(AppData()->UserPoolId);\n     }\n     if (!userPoolSize) {\n-        ALS_ERROR(NKikimrServices::KQP_EXECUTER) << \"user pool is undefined for executer tasks construction\";\n+        ALS_INFO(NKikimrServices::KQP_EXECUTER) << \"user pool is undefined for executer tasks construction\";\n         userPoolSize = NSystemInfo::NumberOfCpus();\n     }\n     return Max<ui32>(1, *userPoolSize);\ndiff --git a/ydb/core/kqp/runtime/kqp_read_actor.cpp b/ydb/core/kqp/runtime/kqp_read_actor.cpp\nindex 7e02b7e58b76..b9bb9f748dd4 100644\n--- a/ydb/core/kqp/runtime/kqp_read_actor.cpp\n+++ b/ydb/core/kqp/runtime/kqp_read_actor.cpp\n@@ -837,8 +837,9 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n             << \", limit: \" << limit\n             << \", readId = \" << id\n             << \", reverse = \" << record.GetReverse()\n-            << \" snapshot = (txid=\" << Settings->GetSnapshot().GetTxId() << \",step=\" << Settings->GetSnapshot().GetStep() << \")\"\n-            << \" lockTxId = \" << Settings->GetLockTxId());\n+            << \", snapshot = (txid=\" << Settings->GetSnapshot().GetTxId() << \",step=\" << Settings->GetSnapshot().GetStep() << \")\"\n+            << \", lockTxId = \" << Settings->GetLockTxId()\n+            << \", lockNodeId = \" << Settings->GetLockNodeId());\n \n         Counters->CreatedIterators->Inc();\n         ReadIdByTabletId[state->TabletId].push_back(id);\n@@ -894,6 +895,26 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n             return;\n         }\n \n+        CA_LOG_D(\"Recv TEvReadResult from ShardID=\" << Reads[id].Shard->TabletId\n+            << \", ReadId=\" << id\n+            << \", Status=\" << Ydb::StatusIds::StatusCode_Name(record.GetStatus().GetCode())\n+            << \", Finished=\" << record.GetFinished()\n+            << \", RowCount=\" << record.GetRowCount()\n+            << \", TxLocks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : record.GetTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }()\n+            << \", BrokenTxLocks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : record.GetBrokenTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }());\n+\n         if (!record.HasNodeId()) {\n             Counters->ReadActorAbsentNodeId->Inc();\n         } else if (record.GetNodeId() != SelfId().NodeId()) {\ndiff --git a/ydb/core/kqp/runtime/kqp_scan_data.cpp b/ydb/core/kqp/runtime/kqp_scan_data.cpp\nindex 2e8b430681e9..96c8f6dbbca3 100644\n--- a/ydb/core/kqp/runtime/kqp_scan_data.cpp\n+++ b/ydb/core/kqp/runtime/kqp_scan_data.cpp\n@@ -3,7 +3,7 @@\n #include <ydb/core/engine/minikql/minikql_engine_host.h>\n #include <ydb/core/protos/tx_datashard.pb.h>\n #include <ydb/core/scheme/scheme_types_proto.h>\n-#include <ydb/core/formats/arrow/common/accessor.h>\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n #include <ydb/core/formats/arrow/size_calcer.h>\n \n #include <ydb/library/yql/minikql/mkql_string_util.h>\n@@ -296,26 +296,27 @@ TBytesStatistics WriteColumnValuesFromArrowSpecImpl(TAccessor editAccessor,\n     auto trivialChunkedArray = std::make_shared<NArrow::NAccessor::TTrivialChunkedArray>(chunkedArrayExt);\n     NArrow::NAccessor::IChunkedArray::TReader reader(trivialChunkedArray);\n \n-    std::optional<ui32> chunkIdx;\n     std::optional<ui32> currentIdxFrom;\n     std::optional<NArrow::NAccessor::IChunkedArray::TAddress> address;\n     const typename TElementAccessor::TArrayType* currentArray = nullptr;\n     const auto applyToIndex = [&](const ui32 rowIndexFrom, const ui32 rowIndexTo) {\n+        bool changed = false;\n         if (!currentIdxFrom) {\n             address = reader.GetReadChunk(rowIndexFrom);\n             AFL_ENSURE(rowIndexFrom == 0)(\"real\", rowIndexFrom);\n+            changed = true;\n         } else {\n             AFL_ENSURE(rowIndexFrom == *currentIdxFrom + 1)(\"next\", rowIndexFrom)(\"current\", *currentIdxFrom);\n             if (!address->NextPosition()) {\n                 address = reader.GetReadChunk(rowIndexFrom);\n+                changed = true;\n             }\n         }\n         currentIdxFrom = rowIndexFrom;\n \n-        if (!chunkIdx || *chunkIdx != address->GetChunkIdx()) {\n+        if (changed) {\n             currentArray = static_cast<const typename TElementAccessor::TArrayType*>(address->GetArray().get());\n             TElementAccessor::Validate(*currentArray);\n-            chunkIdx = address->GetChunkIdx();\n         }\n \n         auto& rowItem = editAccessor(rowIndexTo, columnIndex);\ndiff --git a/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp b/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp\nindex 17ef66580bbf..7f94a524d3cc 100644\n--- a/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp\n+++ b/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp\n@@ -278,8 +278,6 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n     void Handle(TEvDataShard::TEvReadResult::TPtr& ev) {\n         const auto& record = ev->Get()->Record;\n \n-        CA_LOG_D(\"TEvReadResult was received for table: \" << StreamLookupWorker->GetTablePath() <<\n-            \", readId: \" << record.GetReadId() << \", finished: \" << record.GetFinished());\n \n         auto readIt = Reads.find(record.GetReadId());\n         if (readIt == Reads.end() || readIt->second.State != EReadState::Running) {\n@@ -289,6 +287,27 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n \n         auto& read = readIt->second;\n \n+        CA_LOG_D(\"Recv TEvReadResult (stream lookup) from ShardID=\" << read.ShardId\n+            << \", Table = \" << StreamLookupWorker->GetTablePath()\n+            << \", ReadId=\" << record.GetReadId()\n+            << \", Status=\" << Ydb::StatusIds::StatusCode_Name(record.GetStatus().GetCode())\n+            << \", Finished=\" << record.GetFinished()\n+            << \", RowCount=\" << record.GetRowCount()\n+            << \", TxLocks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : record.GetTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }()\n+            << \", BrokenTxLocks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : record.GetBrokenTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }());\n+\n         for (auto& lock : record.GetBrokenTxLocks()) {\n             BrokenLocks.push_back(lock);\n         }\n@@ -466,6 +485,13 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n         record.SetMaxBytes(defaultSettings.GetMaxBytes());\n         record.SetResultFormat(NKikimrDataEvents::FORMAT_CELLVEC);\n \n+        CA_LOG_D(TStringBuilder() << \"Send EvRead (stream lookup) to shardId=\" << shardId\n+            << \", readId = \" << record.GetReadId()\n+            << \", tablePath: \" << StreamLookupWorker->GetTablePath()\n+            << \", snapshot=(txid=\" << record.GetSnapshot().GetTxId() << \", step=\" << record.GetSnapshot().GetStep() << \")\"\n+            << \", lockTxId=\" << record.GetLockTxId()\n+            << \", lockNodeId=\" << record.GetLockNodeId());\n+\n         Send(MainPipeCacheId, new TEvPipeCache::TEvForward(request.Release(), shardId, true),\n             IEventHandle::FlagTrackDelivery, 0, LookupActorSpan.GetTraceId());\n \ndiff --git a/ydb/core/kqp/runtime/kqp_write_actor.cpp b/ydb/core/kqp/runtime/kqp_write_actor.cpp\nindex dbc4059ef033..085b02a1f68f 100644\n--- a/ydb/core/kqp/runtime/kqp_write_actor.cpp\n+++ b/ydb/core/kqp/runtime/kqp_write_actor.cpp\n@@ -228,6 +228,7 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n                 hFunc(TEvPipeCache::TEvDeliveryProblem, Handle);\n                 IgnoreFunc(TEvTxUserProxy::TEvAllocateTxIdResult);\n                 hFunc(TEvPrivate::TEvShardRequestTimeout, Handle);\n+                hFunc(TEvPrivate::TEvResolveRequestPlanned, Handle);\n                 IgnoreFunc(TEvInterconnect::TEvNodeConnected);\n                 IgnoreFunc(TEvTxProxySchemeCache::TEvInvalidateTableResult);\n             }\n@@ -247,21 +248,26 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n     }\n \n     void PlanResolveTable() {\n+        CA_LOG_D(\"Plan resolve with delay \" << CalculateNextAttemptDelay(ResolveAttempts));\n         TlsActivationContext->Schedule(\n             CalculateNextAttemptDelay(ResolveAttempts),\n             new IEventHandle(SelfId(), SelfId(), new TEvPrivate::TEvResolveRequestPlanned{}, 0, 0));   \n     }\n \n+    void Handle(TEvPrivate::TEvResolveRequestPlanned::TPtr&) {\n+        ResolveTable();\n+    }\n+\n     void ResolveTable() {\n         SchemeEntry.reset();\n         SchemeRequest.reset();\n \n         if (ResolveAttempts++ >= BackoffSettings()->MaxResolveAttempts) {\n-            const auto error = TStringBuilder()\n-                << \"Too many table resolve attempts for Sink=\" << this->SelfId() << \".\";\n-            CA_LOG_E(error);\n+            CA_LOG_E(TStringBuilder()\n+                << \"Too many table resolve attempts for table \" << TableId << \".\");\n             RuntimeError(\n-                error,\n+                TStringBuilder()\n+                << \"Too many table resolve attempts for table `\" << Settings.GetTable().GetPath() << \"`.\",\n                 NYql::NDqProto::StatusIds::SCHEME_ERROR);\n             return;\n         }\n@@ -273,6 +279,7 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n         entry.RequestType = NSchemeCache::TSchemeCacheNavigate::TEntry::ERequestType::ByTableId;\n         entry.Operation = NSchemeCache::TSchemeCacheNavigate::OpTable;\n         entry.SyncVersion = false;\n+        entry.ShowPrivatePath = true;\n         request->ResultSet.emplace_back(entry);\n \n         Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvInvalidateTable(TableId, {}));\n@@ -280,14 +287,16 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n     }\n \n     void Handle(TEvTxProxySchemeCache::TEvNavigateKeySetResult::TPtr& ev) {\n+        auto& resultSet = ev->Get()->Request->ResultSet;\n+        YQL_ENSURE(resultSet.size() == 1);\n+\n         if (ev->Get()->Request->ErrorCount > 0) {\n             CA_LOG_E(TStringBuilder() << \"Failed to get table: \"\n-                << TableId << \"'\");\n+                << TableId << \"'. Entry: \" << resultSet[0].ToString());\n             PlanResolveTable();\n             return;\n         }\n-        auto& resultSet = ev->Get()->Request->ResultSet;\n-        YQL_ENSURE(resultSet.size() == 1);\n+\n         SchemeEntry = resultSet[0];\n \n         CA_LOG_D(\"Resolved TableId=\" << TableId << \" (\"\n@@ -362,6 +371,18 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n             return issues;\n         };\n \n+        CA_LOG_D(\"Recv EvWriteResult from ShardID=\" << ev->Get()->Record.GetOrigin()\n+            << \", Status=\" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())\n+            << \", TxId=\" << ev->Get()->Record.GetTxId()\n+            << \", Locks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }()\n+            << \", Cookie=\" << ev->Cookie);\n+\n         switch (ev->Get()->GetStatus()) {\n         case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {\n             CA_LOG_E(\"Got UNSPECIFIED for table `\"\n@@ -424,6 +445,13 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n                 << \" Ignored this error.\"\n                 << getIssues().ToOneLineString());\n             // TODO: support waiting\n+            if (!InconsistentTx)  {\n+                RuntimeError(\n+                    TStringBuilder() << \"Got OVERLOADED for table `\"\n+                        << SchemeEntry->TableId.PathId.ToString() << \"`.\",\n+                    NYql::NDqProto::StatusIds::OVERLOADED,\n+                    getIssues());\n+            }\n             return;\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_CANCELLED: {\n@@ -490,12 +518,24 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n         CA_LOG_D(\"Got completed result TxId=\" << ev->Get()->Record.GetTxId()\n             << \", TabletId=\" << ev->Get()->Record.GetOrigin()\n             << \", Cookie=\" << ev->Cookie\n-            << \", LocksCount=\" << ev->Get()->Record.GetTxLocks().size());\n+            << \", Locks=\" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }());\n \n         OnMessageAcknowledged(ev->Get()->Record.GetOrigin(), ev->Cookie);\n \n         for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n-            LocksInfo[ev->Get()->Record.GetOrigin()].AddAndCheckLock(lock);\n+            if (!LocksInfo[ev->Get()->Record.GetOrigin()].AddAndCheckLock(lock)) {\n+                RuntimeError(\n+                    TStringBuilder() << \"Got LOCKS BROKEN for table `\"\n+                        << SchemeEntry->TableId.PathId.ToString() << \"`.\",\n+                    NYql::NDqProto::StatusIds::ABORTED,\n+                    NYql::TIssues{});\n+            }\n         }\n \n         ProcessBatches();\n@@ -580,10 +620,18 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n                 ShardedWriteController->GetDataFormat());\n         }\n \n-        CA_LOG_D(\"Send EvWrite to ShardID=\" << shardId << \", TxId=\" << std::get<ui64>(TxId)\n+        CA_LOG_D(\"Send EvWrite to ShardID=\" << shardId << \", TxId=\" << evWrite->Record.GetTxId()\n+            << \", TxMode=\" << evWrite->Record.GetTxMode()\n             << \", LockTxId=\" << evWrite->Record.GetLockTxId() << \", LockNodeId=\" << evWrite->Record.GetLockNodeId()\n+            << \", Locks= \" << [&]() {\n+                TStringBuilder builder;\n+                for (const auto& lock : evWrite->Record.GetLocks().GetLocks()) {\n+                    builder << lock.ShortDebugString();\n+                }\n+                return builder;\n+            }()\n             << \", Size=\" << serializationResult.TotalDataSize << \", Cookie=\" << metadata->Cookie\n-            << \", Operations=\" << metadata->OperationsCount << \", IsFinal=\" << metadata->IsFinal\n+            << \", OperationsCount=\" << metadata->OperationsCount << \", IsFinal=\" << metadata->IsFinal\n             << \", Attempts=\" << metadata->SendAttempts);\n         Send(\n             PipeCacheId,\ndiff --git a/ydb/core/kqp/session_actor/kqp_session_actor.cpp b/ydb/core/kqp/session_actor/kqp_session_actor.cpp\nindex e3b18878a325..ede5fb295752 100644\n--- a/ydb/core/kqp/session_actor/kqp_session_actor.cpp\n+++ b/ydb/core/kqp/session_actor/kqp_session_actor.cpp\n@@ -580,10 +580,18 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             LWTRACK(KqpSessionQueryCompiled, QueryState->Orbit, TStringBuilder() << QueryState->CompileResult->Status);\n \n             if (QueryState->CompileResult->NeedToSplit) {\n-                YQL_ENSURE(!QueryState->HasTxControl() && QueryState->GetAction() == NKikimrKqp::QUERY_ACTION_EXECUTE);\n-                auto ev = QueryState->BuildSplitRequest(CompilationCookie, GUCSettings);\n-                Send(MakeKqpCompileServiceID(SelfId().NodeId()), ev.release(), 0, QueryState->QueryId,\n-                    QueryState->KqpSessionSpan.GetTraceId());\n+                if (!QueryState->HasTxControl()) {\n+                    YQL_ENSURE(QueryState->GetAction() == NKikimrKqp::QUERY_ACTION_EXECUTE);\n+                    auto ev = QueryState->BuildSplitRequest(CompilationCookie, GUCSettings);\n+                    Send(MakeKqpCompileServiceID(SelfId().NodeId()), ev.release(), 0, QueryState->QueryId,\n+                        QueryState->KqpSessionSpan.GetTraceId());\n+                } else {\n+                    NYql::TIssues issues;\n+                    ReplyQueryError(\n+                        ::Ydb::StatusIds::StatusCode::StatusIds_StatusCode_BAD_REQUEST,\n+                        \"CTAS statement can be executed only in NoTx mode.\",\n+                        MessageFromIssues(issues));\n+                }\n             } else {\n                 ReplyQueryCompileError();\n             }\n@@ -1282,8 +1290,11 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n         LOG_D(\"Sending to Executer TraceId: \" << request.TraceId.GetTraceId() << \" \" << request.TraceId.GetSpanIdSize());\n \n         const bool useEvWrite = ((HasOlapTable && Settings.TableService.GetEnableOlapSink()) || (!HasOlapTable && Settings.TableService.GetEnableOltpSink()))\n-            && (request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_SQL_GENERIC_QUERY \n-                || request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_SQL_GENERIC_CONCURRENT_QUERY);\n+            && (request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_UNDEFINED\n+                || request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_SQL_GENERIC_QUERY\n+                || request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_SQL_GENERIC_CONCURRENT_QUERY\n+                || (!HasOlapTable && request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_SQL_DML)\n+                || (!HasOlapTable && request.QueryType == NKikimrKqp::EQueryType::QUERY_TYPE_PREPARED_DML));\n         auto executerActor = CreateKqpExecuter(std::move(request), Settings.Database,\n             QueryState ? QueryState->UserToken : TIntrusiveConstPtr<NACLib::TUserToken>(),\n             RequestCounters, Settings.TableService.GetAggregationConfig(), Settings.TableService.GetExecuterRetriesConfig(),\ndiff --git a/ydb/core/kqp/ut/common/columnshard.cpp b/ydb/core/kqp/ut/common/columnshard.cpp\nindex 90e3992b7176..6318a8f1e7ea 100644\n--- a/ydb/core/kqp/ut/common/columnshard.cpp\n+++ b/ydb/core/kqp/ut/common/columnshard.cpp\n@@ -22,7 +22,7 @@ namespace NKqp {\n                 }\n                 SecretableSecretKey: {\n                     Value: {\n-                        Data: \"secretSecretKey\"\n+                        Data: \"fakeSecret\"\n                     }\n                 }\n             }\n@@ -31,32 +31,37 @@ namespace NKqp {\n \n     using namespace NYdb;\n \n-    TTestHelper::TTestHelper(const TKikimrSettings& settings)\n-        : Kikimr(settings)\n-        , TableClient(Kikimr.GetTableClient())\n-        , Session(TableClient.CreateSession().GetValueSync().GetSession())\n-    {}\n+    TTestHelper::TTestHelper(const TKikimrSettings& settings) {\n+        TKikimrSettings kikimrSettings(settings);\n+        if (!kikimrSettings.FeatureFlags.HasEnableTieringInColumnShard()) {\n+            kikimrSettings.SetEnableTieringInColumnShard(true);\n+        }\n+\n+        Kikimr = std::make_unique<TKikimrRunner>(kikimrSettings);\n+        TableClient = std::make_unique<NYdb::NTable::TTableClient>(Kikimr->GetTableClient());\n+        Session = std::make_unique<NYdb::NTable::TSession>(TableClient->CreateSession().GetValueSync().GetSession());\n+    }\n \n     NKikimr::NKqp::TKikimrRunner& TTestHelper::GetKikimr() {\n-        return Kikimr;\n+        return *Kikimr;\n     }\n \n     TTestActorRuntime& TTestHelper::GetRuntime() {\n-        return *Kikimr.GetTestServer().GetRuntime();\n+        return *Kikimr->GetTestServer().GetRuntime();\n     }\n \n     NYdb::NTable::TSession& TTestHelper::GetSession() {\n-        return Session;\n+        return *Session;\n     }\n \n     void TTestHelper::CreateTable(const TColumnTableBase& table, const EStatus expectedStatus) {\n         std::cerr << (table.BuildQuery()) << std::endl;\n-        auto result = Session.ExecuteSchemeQuery(table.BuildQuery()).GetValueSync();\n+        auto result = GetSession().ExecuteSchemeQuery(table.BuildQuery()).GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), expectedStatus, result.GetIssues().ToString());\n     }\n \n     void TTestHelper::CreateTier(const TString& tierName) {\n-        auto result = Session.ExecuteSchemeQuery(\"CREATE OBJECT \" + tierName + \" (TYPE TIER) WITH tierConfig = `\" + GetConfigProtoWithName(tierName) + \"`\").GetValueSync();\n+        auto result = GetSession().ExecuteSchemeQuery(\"CREATE OBJECT \" + tierName + \" (TYPE TIER) WITH tierConfig = `\" + GetConfigProtoWithName(tierName) + \"`\").GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n     }\n \n@@ -70,43 +75,43 @@ namespace NKqp {\n                 }\n             ]\n         })\";\n-        auto result = Session.ExecuteSchemeQuery(\"CREATE OBJECT IF NOT EXISTS \" + ruleName + \" (TYPE TIERING_RULE) WITH (defaultColumn = \" + columnName + \", description = `\" + configTieringStr + \"`)\").GetValueSync();\n+        auto result = GetSession().ExecuteSchemeQuery(\"CREATE OBJECT IF NOT EXISTS \" + ruleName + \" (TYPE TIERING_RULE) WITH (defaultColumn = \" + columnName + \", description = `\" + configTieringStr + \"`)\").GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n         return ruleName;\n     }\n \n     void TTestHelper::SetTiering(const TString& tableName, const TString& ruleName) {\n         auto alterQuery = TStringBuilder() << \"ALTER TABLE `\" << tableName <<  \"` SET (TIERING = '\" << ruleName << \"')\";\n-        auto result = Session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n+        auto result = GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n     }\n \n     void TTestHelper::ResetTiering(const TString& tableName) {\n         auto alterQuery = TStringBuilder() << \"ALTER TABLE `\" << tableName <<  \"` RESET (TIERING)\";\n-        auto result = Session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n+        auto result = GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n     }\n \n     void TTestHelper::DropTable(const TString& tableName) {\n-        auto result = Session.DropTable(tableName).GetValueSync();\n+        auto result = GetSession().DropTable(tableName).GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n     }\n \n     void TTestHelper::BulkUpsert(const TColumnTable& table, TTestHelper::TUpdatesBuilder& updates, const Ydb::StatusIds_StatusCode& opStatus /*= Ydb::StatusIds::SUCCESS*/) {\n         Y_UNUSED(opStatus);\n-        NKikimr::Tests::NCS::THelper helper(Kikimr.GetTestServer());\n+        NKikimr::Tests::NCS::THelper helper(GetKikimr().GetTestServer());\n         auto batch = updates.BuildArrow();\n         helper.SendDataViaActorSystem(table.GetName(), batch, opStatus);\n     }\n \n     void TTestHelper::BulkUpsert(const TColumnTable& table, std::shared_ptr<arrow::RecordBatch> batch, const Ydb::StatusIds_StatusCode& opStatus /*= Ydb::StatusIds::SUCCESS*/) {\n         Y_UNUSED(opStatus);\n-        NKikimr::Tests::NCS::THelper helper(Kikimr.GetTestServer());\n+        NKikimr::Tests::NCS::THelper helper(GetKikimr().GetTestServer());\n         helper.SendDataViaActorSystem(table.GetName(), batch, opStatus);\n     }\n \n     void TTestHelper::ReadData(const TString& query, const TString& expected, const EStatus opStatus /*= EStatus::SUCCESS*/) {\n-        auto it = TableClient.StreamExecuteScanQuery(query).GetValueSync();\n+        auto it = TableClient->StreamExecuteScanQuery(query).GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString()); // Means stream successfully get\n         TString result = StreamResultToYson(it, false, opStatus);\n         if (opStatus == EStatus::SUCCESS) {\n@@ -115,21 +120,29 @@ namespace NKqp {\n     }\n \n     void TTestHelper::RebootTablets(const TString& tableName) {\n-        auto runtime = Kikimr.GetTestServer().GetRuntime();\n+        auto runtime = GetKikimr().GetTestServer().GetRuntime();\n         TActorId sender = runtime->AllocateEdgeActor();\n         TVector<ui64> shards;\n         {\n-            auto describeResult = DescribeTable(&Kikimr.GetTestServer(), sender, tableName);\n+            auto describeResult = DescribeTable(&GetKikimr().GetTestServer(), sender, tableName);\n             for (auto shard : describeResult.GetPathDescription().GetColumnTableDescription().GetSharding().GetColumnShards()) {\n                 shards.push_back(shard);\n             }\n         }\n         for (auto shard : shards) {\n-            Kikimr.GetTestServer().GetRuntime()->Send(MakePipePerNodeCacheID(false), NActors::TActorId(), new TEvPipeCache::TEvForward(\n+            GetKikimr().GetTestServer().GetRuntime()->Send(MakePipePerNodeCacheID(false), NActors::TActorId(), new TEvPipeCache::TEvForward(\n                     new TEvents::TEvPoisonPill(), shard, false));\n         }\n     }\n \n+    void TTestHelper::WaitTabletDeletionInHive(ui64 tabletId, TDuration duration) {\n+        auto deadline = TInstant::Now() + duration;\n+        while (GetKikimr().GetTestClient().TabletExistsInHive(&GetRuntime(), tabletId) && TInstant::Now() <= deadline) {\n+            Cerr << \"WaitTabletDeletionInHive: wait until \" << tabletId << \" is deleted\" << Endl;\n+            Sleep(TDuration::Seconds(1));\n+        }\n+    }\n+\n     TString TTestHelper::TColumnSchema::BuildQuery() const {\n         TStringBuilder str;\n         str << Name << ' ';\n@@ -233,6 +246,8 @@ namespace NKqp {\n             return arrow::field(name, arrow::int64(), nullable);\n         case NScheme::NTypeIds::JsonDocument:\n             return arrow::field(name, arrow::binary(), nullable);\n+        case NScheme::NTypeIds::Decimal:\n+            return arrow::field(name, arrow::decimal(22, 9));\n         case NScheme::NTypeIds::Pg:\n             switch (NPg::PgTypeIdFromTypeDesc(typeDesc)) {\n                 case INT2OID:\ndiff --git a/ydb/core/kqp/ut/common/columnshard.h b/ydb/core/kqp/ut/common/columnshard.h\nindex a938e91b4d4a..d1be363fd5ef 100644\n--- a/ydb/core/kqp/ut/common/columnshard.h\n+++ b/ydb/core/kqp/ut/common/columnshard.h\n@@ -2,15 +2,14 @@\n \n #include \"kqp_ut_common.h\"\n #include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n #include <ydb/public/lib/scheme_types/scheme_type_id.h>\n #include <ydb/public/sdk/cpp/client/ydb_table/table.h>\n #include <ydb/public/sdk/cpp/client/ydb_types/status_codes.h>\n #include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>\n \n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n-\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \n namespace NKikimr {\n@@ -63,9 +62,9 @@ namespace NKqp {\n         };\n \n     private:\n-        TKikimrRunner Kikimr;\n-        NYdb::NTable::TTableClient TableClient;\n-        NYdb::NTable::TSession Session;\n+        std::unique_ptr<TKikimrRunner> Kikimr;\n+        std::unique_ptr<NYdb::NTable::TTableClient> TableClient;\n+        std::unique_ptr<NYdb::NTable::TSession> Session;\n \n     public:\n         TTestHelper(const TKikimrSettings& settings);\n@@ -82,6 +81,7 @@ namespace NKqp {\n         void BulkUpsert(const TColumnTable& table, std::shared_ptr<arrow::RecordBatch> batch, const Ydb::StatusIds_StatusCode& opStatus = Ydb::StatusIds::SUCCESS);\n         void ReadData(const TString& query, const TString& expected, const NYdb::EStatus opStatus = NYdb::EStatus::SUCCESS);\n         void RebootTablets(const TString& tableName);\n+        void WaitTabletDeletionInHive(ui64 tabletId, TDuration duration);\n     };\n \n }\ndiff --git a/ydb/core/kqp/ut/common/kqp_ut_common.cpp b/ydb/core/kqp/ut/common/kqp_ut_common.cpp\nindex 9997745b5da9..7bfcb6b0e18a 100644\n--- a/ydb/core/kqp/ut/common/kqp_ut_common.cpp\n+++ b/ydb/core/kqp/ut/common/kqp_ut_common.cpp\n@@ -133,6 +133,7 @@ TKikimrRunner::TKikimrRunner(const TKikimrSettings& settings) {\n     ServerSettings->SetUseRealThreads(settings.UseRealThreads);\n     ServerSettings->SetEnableTablePgTypes(true);\n     ServerSettings->SetEnablePgSyntax(true);\n+    ServerSettings->SetEnableOlapCompression(true);\n     ServerSettings->S3ActorsFactory = settings.S3ActorsFactory;\n \n     if (settings.Storage) {\ndiff --git a/ydb/core/kqp/ut/common/kqp_ut_common.h b/ydb/core/kqp/ut/common/kqp_ut_common.h\nindex a43d6d14da0d..43c7fabda800 100644\n--- a/ydb/core/kqp/ut/common/kqp_ut_common.h\n+++ b/ydb/core/kqp/ut/common/kqp_ut_common.h\n@@ -97,6 +97,7 @@ struct TKikimrSettings: public TTestFeatureFlagsHolder<TKikimrSettings> {\n         exchangerSettings->SetStartDelayMs(10);\n         exchangerSettings->SetMaxDelayMs(10);\n         AppConfig.MutableColumnShardConfig()->SetDisabledOnSchemeShard(false);\n+        FeatureFlags.SetEnableSparsedColumns(true);\n     }\n \n     TKikimrSettings& SetAppConfig(const NKikimrConfig::TAppConfig& value) { AppConfig = value; return *this; }\ndiff --git a/ydb/core/kqp/ut/olap/aggregations_ut.cpp b/ydb/core/kqp/ut/olap/aggregations_ut.cpp\nindex 9a70ee376fed..4f23f3c67c0d 100644\n--- a/ydb/core/kqp/ut/olap/aggregations_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/aggregations_ut.cpp\n@@ -163,7 +163,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n \n             // Check plan\n #if SSA_RUNTIME_VERSION >= 2U\n-            CheckPlanForAggregatePushdown(query, tableClient, { \"WideCombiner\" }, \"Aggregate-TableFullScan\");\n+            CheckPlanForAggregatePushdown(query, tableClient, { \"WideCombiner\" }, \"TableFullScan\");\n //            CheckPlanForAggregatePushdown(query, tableClient, { \"TKqpOlapAgg\" }, \"TableFullScan\");\n #else\n             CheckPlanForAggregatePushdown(query, tableClient, { \"CombineCore\" }, \"\");\n@@ -352,7 +352,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             .AddExpectedPlanOptions(\"KqpOlapFilter\")\n #if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\")\n-            .MutableLimitChecker().SetExpectedResultCount(1)\n+            // See https://github.com/ydb-platform/ydb/issues/7299 for explanation, why resultCount = 3\n+            .MutableLimitChecker().SetExpectedResultCount(3)\n #else\n             .AddExpectedPlanOptions(\"CombineCore\")\n #endif\n@@ -980,7 +981,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 ORDER BY c, resource_id DESC LIMIT 3\n             )\")\n             .SetExpectedReply(\"[[[\\\"40999\\\"];[4];1u];[[\\\"40998\\\"];[3];1u];[[\\\"40997\\\"];[2];1u]]\")\n-            .SetExpectedReadNodeType(\"Aggregate-TableFullScan\");\n+            .SetExpectedReadNodeType(\"TableFullScan\");\n         testCase.FillExpectedAggregationGroupByPlanOptions();\n         TestAggregations({ testCase });\n     }\ndiff --git a/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp b/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp\nindex 436b1ba0286d..ea97c44484f3 100644\n--- a/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp\n@@ -15,7 +15,6 @@\n namespace NKikimr::NKqp {\n \n Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n-\n     namespace {\n     class TTransferStatus {\n     private:\n@@ -60,7 +59,6 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n             return TConclusionStatus::Success();\n         }\n         virtual void DoSerializeToProto(NKikimrColumnShardDataSharingProto::TInitiator::TController& /*proto*/) const override {\n-\n         }\n \n         virtual TString GetClassName() const override {\n@@ -68,10 +66,16 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n         }\n     };\n \n+    TKikimrSettings GetKikimrSettings() {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableAlterShardingInColumnShard(true);\n+        return TKikimrSettings().SetWithSampleTables(false).SetFeatureFlags(featureFlags);\n+    }\n+\n     class TSharingDataTestCase {\n     private:\n         const ui32 ShardsCount;\n-        TKikimrRunner& Kikimr;\n+        TKikimrRunner Kikimr;\n         TTypedLocalHelper Helper;\n         NYDBTest::TControllers::TGuard<NYDBTest::NColumnShard::TController> Controller;\n         std::vector<ui64> ShardIds;\n@@ -86,15 +90,15 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n             Helper.FillPKOnly(kff, recordsCount);\n         }\n \n-        TSharingDataTestCase(const ui32 shardsCount, TKikimrRunner& kikimr)\n+        TSharingDataTestCase(const ui32 shardsCount)\n             : ShardsCount(shardsCount)\n-            , Kikimr(kikimr)\n+            , Kikimr(GetKikimrSettings())\n             , Helper(\"\", Kikimr, \"olapTable\", \"olapStore12\")\n             , Controller(NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>()) {\n             Controller->SetCompactionControl(NYDBTest::EOptimizerCompactionWeightControl::Disable);\n             Controller->SetExpectedShardsCount(ShardsCount);\n-            Controller->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n-            Controller->SetReadTimeoutClean(TDuration::Seconds(1));\n+            Controller->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+            Controller->SetOverrideReadTimeoutClean(TDuration::Seconds(1));\n \n             Tests::NCommon::TLoggerInit(Kikimr).SetComponents({ NKikimrServices::TX_COLUMNSHARD }, \"CS\").Initialize();\n \n@@ -111,7 +115,7 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n         }\n \n         void WaitNormalization() {\n-            Controller->SetReadTimeoutClean(TDuration::Seconds(1));\n+            Controller->SetOverrideReadTimeoutClean(TDuration::Seconds(1));\n             Controller->SetCompactionControl(NYDBTest::EOptimizerCompactionWeightControl::Force);\n             const auto start = TInstant::Now();\n             while (!Controller->IsTrivialLinks() && TInstant::Now() - start < TDuration::Seconds(30)) {\n@@ -120,11 +124,11 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n             }\n             AFL_VERIFY(Controller->IsTrivialLinks());\n             Controller->CheckInvariants();\n-            Controller->SetReadTimeoutClean(TDuration::Minutes(5));\n+            Controller->SetOverrideReadTimeoutClean(TDuration::Minutes(5));\n         }\n \n         void Execute(const ui64 destinationIdx, const std::vector<ui64>& sourceIdxs, const bool move, const NOlap::TSnapshot& snapshot, const std::set<ui64>& pathIdxs) {\n-            Controller->SetReadTimeoutClean(TDuration::Seconds(1));\n+            Controller->SetOverrideReadTimeoutClean(TDuration::Seconds(1));\n             AFL_VERIFY(destinationIdx < ShardIds.size());\n             const ui64 destination = ShardIds[destinationIdx];\n             std::vector<ui64> sources;\n@@ -192,22 +196,18 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n             CSTransferStatus->Reset();\n             AFL_VERIFY(!Controller->IsTrivialLinks());\n             Controller->CheckInvariants();\n-            Controller->SetReadTimeoutClean(TDuration::Minutes(5));\n+            Controller->SetOverrideReadTimeoutClean(TDuration::Minutes(5));\n         }\n     };\n     Y_UNIT_TEST(BlobsSharingSplit1_1) {\n-        auto settings = TKikimrSettings().SetWithSampleTables(false);\n-        TKikimrRunner kikimr(settings);\n-        TSharingDataTestCase tester(4, kikimr);\n+        TSharingDataTestCase tester(4);\n         tester.AddRecords(800000);\n         Sleep(TDuration::Seconds(1));\n         tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n     }\n \n     Y_UNIT_TEST(BlobsSharingSplit1_1_clean) {\n-        auto settings = TKikimrSettings().SetWithSampleTables(false);\n-        TKikimrRunner kikimr(settings);\n-        TSharingDataTestCase tester(2, kikimr);\n+        TSharingDataTestCase tester(2);\n         tester.AddRecords(80000);\n         CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[80000u;]])\");\n         Sleep(TDuration::Seconds(1));\n@@ -219,9 +219,7 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n     }\n \n     Y_UNIT_TEST(BlobsSharingSplit1_1_clean_with_restarts) {\n-        auto settings = TKikimrSettings().SetWithSampleTables(false);\n-        TKikimrRunner kikimr(settings);\n-        TSharingDataTestCase tester(2, kikimr);\n+        TSharingDataTestCase tester(2);\n         tester.SetRebootTablet(true);\n         tester.AddRecords(80000);\n         CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[80000u;]])\");\n@@ -234,18 +232,14 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n     }\n \n     Y_UNIT_TEST(BlobsSharingSplit3_1) {\n-        auto settings = TKikimrSettings().SetWithSampleTables(false);\n-        TKikimrRunner kikimr(settings);\n-        TSharingDataTestCase tester(4, kikimr);\n+        TSharingDataTestCase tester(4);\n         tester.AddRecords(800000);\n         Sleep(TDuration::Seconds(1));\n         tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n     }\n \n     Y_UNIT_TEST(BlobsSharingSplit1_3_1) {\n-        auto settings = TKikimrSettings().SetWithSampleTables(false);\n-        TKikimrRunner kikimr(settings);\n-        TSharingDataTestCase tester(4, kikimr);\n+        TSharingDataTestCase tester(4);\n         tester.AddRecords(800000);\n         Sleep(TDuration::Seconds(1));\n         tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n@@ -255,9 +249,7 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n     }\n \n     Y_UNIT_TEST(BlobsSharingSplit1_3_2_1_clean) {\n-        auto settings = TKikimrSettings().SetWithSampleTables(false);\n-        TKikimrRunner kikimr(settings);\n-        TSharingDataTestCase tester(4, kikimr);\n+        TSharingDataTestCase tester(4);\n         tester.AddRecords(800000);\n         Sleep(TDuration::Seconds(1));\n         tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n@@ -271,8 +263,15 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n     }\n \n     class TReshardingTest {\n-    private:\n-        YDB_ACCESSOR(TString, ShardingType, \"HASH_FUNCTION_CONSISTENCY_64\");\n+    public:\n+        TReshardingTest()\n+            : Kikimr(GetKikimrSettings())\n+            , CSController(NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>())\n+            , TableClient(Kikimr.GetTableClient()) {\n+            CSController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+            CSController->SetOverrideLagForCompactionBeforeTierings(TDuration::Seconds(1));\n+            CSController->SetOverrideReduceMemoryIntervalLimit(1LLU << 30);\n+        }\n \n         void WaitResharding(const TString& hint = \"\") {\n             const TInstant start = TInstant::Now();\n@@ -308,28 +307,22 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n             CompareYson(result, \"[[\" + ::ToString(expectation) + \"u;]]\");\n         }\n \n+    protected:\n         TKikimrRunner Kikimr;\n-    public:\n+        NKikimr::NYDBTest::TControllers::TGuard<NKikimr::NYDBTest::NColumnShard::TController> CSController;\n+        NYdb::NTable::TTableClient TableClient;\n+    };\n \n-        TReshardingTest()\n-            : Kikimr(TKikimrSettings().SetWithSampleTables(false)) {\n+    class TShardingTypeTest: public TReshardingTest {\n+        YDB_ACCESSOR(TString, ShardingType, \"HASH_FUNCTION_CONSISTENCY_64\");\n \n-        }\n+    public:\n+        using TReshardingTest::TReshardingTest;\n \n         void Execute() {\n-            auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n-            csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n-            csController->SetLagForCompactionBeforeTierings(TDuration::Seconds(1));\n-            csController->SetOverrideReduceMemoryIntervalLimit(1LLU << 30);\n-\n             TLocalHelper(Kikimr).SetShardingMethod(ShardingType).CreateTestOlapTable(\"olapTable\", \"olapStore\", 24, 4);\n-            auto tableClient = Kikimr.GetTableClient();\n \n-            Tests::NCommon::TLoggerInit(Kikimr).SetComponents({ NKikimrServices::TX_COLUMNSHARD }, \"CS\").SetPriority(NActors::NLog::PRI_DEBUG).Initialize();\n-\n-            std::vector<TString> uids;\n-            std::vector<TString> resourceIds;\n-            std::vector<ui32> levels;\n+            Tests::NCommon::TLoggerInit(Kikimr).SetComponents({ NKikimrServices::TX_COLUMNSHARD, NKikimrServices::TX_COLUMNSHARD_SCAN }, \"CS\").SetPriority(NActors::NLog::PRI_DEBUG).Initialize();\n \n             {\n                 WriteTestData(Kikimr, \"/Root/olapStore/olapTable\", 1000000, 300000000, 10000);\n@@ -339,83 +332,161 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n                 WriteTestData(Kikimr, \"/Root/olapStore/olapTable\", 1400000, 300400000, 10000);\n                 WriteTestData(Kikimr, \"/Root/olapStore/olapTable\", 2000000, 200000000, 70000);\n                 WriteTestData(Kikimr, \"/Root/olapStore/olapTable\", 3000000, 100000000, 110000);\n-\n-                const auto filler = [&](const ui32 startRes, const ui32 startUid, const ui32 count) {\n-                    for (ui32 i = 0; i < count; ++i) {\n-                        uids.emplace_back(\"uid_\" + ::ToString(startUid + i));\n-                        resourceIds.emplace_back(::ToString(startRes + i));\n-                        levels.emplace_back(i % 5);\n-                    }\n-                };\n-\n-                filler(1000000, 300000000, 10000);\n-                filler(1100000, 300100000, 10000);\n-                filler(1200000, 300200000, 10000);\n-                filler(1300000, 300300000, 10000);\n-                filler(1400000, 300400000, 10000);\n-                filler(2000000, 200000000, 70000);\n-                filler(3000000, 100000000, 110000);\n-\n             }\n \n             CheckCount(230000);\n             for (ui32 i = 0; i < 2; ++i) {\n                 auto alterQuery = TStringBuilder() << R\"(ALTER OBJECT `/Root/olapStore/olapTable` (TYPE TABLESTORE) SET (ACTION=ALTER_SHARDING, MODIFICATION=SPLIT);)\";\n-                auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+                auto session = TableClient.CreateSession().GetValueSync().GetSession();\n                 auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n                 UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n                 WaitResharding(\"SPLIT:\" + ::ToString(i));\n             }\n             {\n                 auto alterQuery = TStringBuilder() << R\"(ALTER OBJECT `/Root/olapStore/olapTable` (TYPE TABLESTORE) SET (ACTION=ALTER_SHARDING, MODIFICATION=SPLIT);)\";\n-                auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+                auto session = TableClient.CreateSession().GetValueSync().GetSession();\n                 auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n                 UNIT_ASSERT_VALUES_UNEQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n             }\n-            AFL_VERIFY(csController->GetShardingFiltersCount().Val() == 0);\n+            AFL_VERIFY(CSController->GetShardingFiltersCount().Val() == 0);\n             CheckCount(230000);\n-            i64 count = csController->GetShardingFiltersCount().Val();\n+            i64 count = CSController->GetShardingFiltersCount().Val();\n             AFL_VERIFY(count >= 16)(\"count\", count);\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+            CSController->WaitIndexation(TDuration::Seconds(3));\n+            CSController->WaitCompactions(TDuration::Seconds(3));\n             WriteTestData(Kikimr, \"/Root/olapStore/olapTable\", 1000000, 300000000, 10000);\n-            csController->WaitIndexation(TDuration::Seconds(5));\n-            csController->WaitCompactions(TDuration::Seconds(5));\n+            CheckCount(230000);\n+            CSController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+            CSController->WaitIndexation(TDuration::Seconds(5));\n+            CheckCount(230000);\n+            CSController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+            CSController->WaitCompactions(TDuration::Seconds(5));\n+            count = CSController->GetShardingFiltersCount().Val();\n+            CheckCount(230000);\n \n-            csController->SetCompactionControl(NYDBTest::EOptimizerCompactionWeightControl::Disable);\n+            CSController->SetCompactionControl(NYDBTest::EOptimizerCompactionWeightControl::Disable);\n \n             CheckCount(230000);\n \n-            AFL_VERIFY(count == csController->GetShardingFiltersCount().Val())(\"count\", count)(\"val\", csController->GetShardingFiltersCount().Val());\n+            AFL_VERIFY(count == CSController->GetShardingFiltersCount().Val())(\"count\", count)(\n+                                  \"val\", CSController->GetShardingFiltersCount().Val());\n             const ui32 portionsCount = 16;\n             for (ui32 i = 0; i < 4; ++i) {\n                 {\n                     auto alterQuery = TStringBuilder() << R\"(ALTER OBJECT `/Root/olapStore/olapTable` (TYPE TABLESTORE) SET (ACTION=ALTER_SHARDING, MODIFICATION=MERGE);)\";\n-                    auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+                    auto session = TableClient.CreateSession().GetValueSync().GetSession();\n                     auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n                     UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n                 }\n                 WaitResharding(\"MERGE:\" + ::ToString(i));\n-                //            csController->WaitCleaning(TDuration::Seconds(5));\n+                //            CSController->WaitCleaning(TDuration::Seconds(5));\n \n                 CheckCount(230000);\n-                AFL_VERIFY(count + portionsCount == csController->GetShardingFiltersCount().Val())(\"count\", count)(\"val\", csController->GetShardingFiltersCount().Val());\n+                AFL_VERIFY(count + portionsCount == CSController->GetShardingFiltersCount().Val())(\"count\", count)(\n+                                                    \"val\", CSController->GetShardingFiltersCount().Val());\n                 count += portionsCount;\n             }\n             {\n                 auto alterQuery = TStringBuilder() << R\"(ALTER OBJECT `/Root/olapStore/olapTable` (TYPE TABLESTORE) SET (ACTION=ALTER_SHARDING, MODIFICATION=MERGE);)\";\n-                auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+                auto session = TableClient.CreateSession().GetValueSync().GetSession();\n                 auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n                 UNIT_ASSERT_VALUES_UNEQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n             }\n-            csController->CheckInvariants();\n+            CSController->CheckInvariants();\n         }\n     };\n \n     Y_UNIT_TEST(TableReshardingConsistency64) {\n-        TReshardingTest().SetShardingType(\"HASH_FUNCTION_CONSISTENCY_64\").Execute();\n+        TShardingTypeTest().SetShardingType(\"HASH_FUNCTION_CONSISTENCY_64\").Execute();\n     }\n \n     Y_UNIT_TEST(TableReshardingModuloN) {\n-        TReshardingTest().SetShardingType(\"HASH_FUNCTION_MODULO_N\").Execute();\n+        TShardingTypeTest().SetShardingType(\"HASH_FUNCTION_CONSISTENCY_64\").Execute();\n+    }\n+\n+    class TAsyncReshardingTest: public TReshardingTest {\n+        YDB_ACCESSOR(TString, ShardingType, \"HASH_FUNCTION_CONSISTENCY_64\");\n+\n+    public:\n+        TAsyncReshardingTest() {\n+            TLocalHelper(Kikimr).CreateTestOlapTable(\"olapTable\", \"olapStore\", 24, 4);\n+        }\n+\n+        void AddBatch(int numRows) {\n+            WriteTestData(Kikimr, \"/Root/olapStore/olapTable\", LastPathId, LastTs, numRows);\n+            LastPathId += numRows * 10;\n+            LastTs += numRows * 10;\n+            NumRows += numRows;\n+        }\n+\n+        void StartResharding(TString modification) {\n+            auto alterQuery =\n+                TStringBuilder() << R\"(ALTER OBJECT `/Root/olapStore/olapTable` (TYPE TABLESTORE) SET (ACTION=ALTER_SHARDING, MODIFICATION=)\"\n+                                 << modification << \");\";\n+            auto session = TableClient.CreateSession().GetValueSync().GetSession();\n+            auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+        }\n+\n+        void CheckCount() {\n+            TReshardingTest::CheckCount(NumRows);\n+        }\n+\n+        void ChangeSchema() {\n+            auto alterQuery =\n+                \"ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=ALTER_COLUMN, NAME=level, \"\n+                \"`SERIALIZER.CLASS_NAME`=`ARROW_SERIALIZER`, \"\n+                \"`COMPRESSION.TYPE`=`zstd`);\";\n+            auto session = TableClient.CreateSession().GetValueSync().GetSession();\n+            auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+        }\n+\n+        void DisableCompaction() {\n+            CSController->SetCompactionControl(NYDBTest::EOptimizerCompactionWeightControl::Disable);\n+        }\n+\n+    private:\n+        ui64 LastPathId = 1000000;\n+        ui64 LastTs = 300000000;\n+        ui64 NumRows = 0;\n+    };\n+\n+    Y_UNIT_TEST(UpsertWhileSplitTest) {\n+        TAsyncReshardingTest tester;\n+\n+        tester.AddBatch(10000);\n+\n+        tester.CheckCount();\n+\n+        for (int i = 0; i < 4; i++) {\n+            tester.StartResharding(\"SPLIT\");\n+\n+            tester.CheckCount();\n+            tester.AddBatch(10000);\n+            tester.CheckCount();\n+            tester.WaitResharding();\n+        }\n+        tester.AddBatch(10000);\n+        tester.CheckCount();\n+    }\n+\n+    Y_UNIT_TEST(ChangeSchemaAndSplit) {\n+        TAsyncReshardingTest tester;\n+        tester.DisableCompaction();\n+\n+        tester.AddBatch(10000);\n+        tester.ChangeSchema();\n+        tester.AddBatch(10000);\n+\n+        tester.StartResharding(\"SPLIT\");\n+        tester.WaitResharding();\n+\n+        tester.CheckCount();\n     }\n }\n }\ndiff --git a/ydb/core/kqp/ut/olap/clickbench_ut.cpp b/ydb/core/kqp/ut/olap/clickbench_ut.cpp\nindex 1cbcd7be436d..dfdb63033187 100644\n--- a/ydb/core/kqp/ut/olap/clickbench_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/clickbench_ut.cpp\n@@ -155,7 +155,7 @@ Y_UNIT_TEST_SUITE(KqpOlapClickbench) {\n             //.SetExpectedReply(\"[[[\\\"40999\\\"];[4];1u];[[\\\"40998\\\"];[3];1u];[[\\\"40997\\\"];[2];1u]]\")\n             // Should be fixed in https://st.yandex-team.ru/KIKIMR-17009\n             // .SetExpectedReadNodeType(\"TableFullScan\");\n-            .SetExpectedReadNodeType(\"Aggregate-TableFullScan\");\n+            .SetExpectedReadNodeType(\"TableFullScan\");\n         q7.FillExpectedAggregationGroupByPlanOptions();\n \n         TAggregationTestCase q9;\n@@ -186,7 +186,7 @@ Y_UNIT_TEST_SUITE(KqpOlapClickbench) {\n             //.SetExpectedReply(\"[[[\\\"40999\\\"];[4];1u];[[\\\"40998\\\"];[3];1u];[[\\\"40997\\\"];[2];1u]]\")\n             // Should be fixed in https://st.yandex-team.ru/KIKIMR-17009\n             // .SetExpectedReadNodeType(\"TableFullScan\");\n-            .SetExpectedReadNodeType(\"Aggregate-TableFullScan\");\n+            .SetExpectedReadNodeType(\"TableFullScan\");\n         q12.FillExpectedAggregationGroupByPlanOptions();\n \n         TAggregationTestCase q14;\n@@ -202,7 +202,7 @@ Y_UNIT_TEST_SUITE(KqpOlapClickbench) {\n             //.SetExpectedReply(\"[[[\\\"40999\\\"];[4];1u];[[\\\"40998\\\"];[3];1u];[[\\\"40997\\\"];[2];1u]]\")\n             // Should be fixed in https://st.yandex-team.ru/KIKIMR-17009\n             // .SetExpectedReadNodeType(\"TableFullScan\");\n-            .SetExpectedReadNodeType(\"Aggregate-TableFullScan\");\n+            .SetExpectedReadNodeType(\"TableFullScan\");\n         q14.FillExpectedAggregationGroupByPlanOptions();\n \n         TAggregationTestCase q22;\ndiff --git a/ydb/core/kqp/ut/olap/datatime64_ut.cpp b/ydb/core/kqp/ut/olap/datatime64_ut.cpp\nindex b4ea097eafe8..97e2a2f2fd28 100644\n--- a/ydb/core/kqp/ut/olap/datatime64_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/datatime64_ut.cpp\n@@ -170,6 +170,7 @@ Y_UNIT_TEST_SUITE(KqpDatetime64ColumnShard) {\n         runnerSettings.WithSampleTables = false;\n \n         TTestHelper testHelper(runnerSettings);\n+        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).SetComponents({ NKikimrServices::GROUPED_MEMORY_LIMITER }, \"CS\").Initialize();\n \n         TVector<TTestHelper::TColumnSchema> schema = {\n             TTestHelper::TColumnSchema().SetName(\"id\").SetType(NScheme::NTypeIds::Int64).SetNullable(false),\ndiff --git a/ydb/core/kqp/ut/olap/decimal_ut.cpp b/ydb/core/kqp/ut/olap/decimal_ut.cpp\nnew file mode 100644\nindex 000000000000..151226bd01d6\n--- /dev/null\n+++ b/ydb/core/kqp/ut/olap/decimal_ut.cpp\n@@ -0,0 +1,198 @@\n+#include <ydb/core/formats/arrow/arrow_helpers.h>\n+#include <ydb/core/kqp/ut/common/columnshard.h>\n+#include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n+#include <ydb/core/testlib/common_helper.h>\n+#include <ydb/core/testlib/cs_helper.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+#include <ydb/core/tx/tx_proxy/proxy.h>\n+\n+#include <ydb/library/binary_json/write.h>\n+#include <ydb/library/uuid/uuid.h>\n+#include <ydb/public/sdk/cpp/client/draft/ydb_replication.h>\n+#include <ydb/public/sdk/cpp/client/ydb_proto/accessor.h>\n+#include <ydb/public/sdk/cpp/client/ydb_scheme/scheme.h>\n+#include <ydb/public/sdk/cpp/client/ydb_topic/topic.h>\n+\n+#include <library/cpp/threading/local_executor/local_executor.h>\n+#include <util/generic/serialized_enum.h>\n+#include <util/string/printf.h>\n+\n+namespace NKikimr {\n+namespace NKqp {\n+\n+using namespace NYdb;\n+using namespace NYdb::NTable;\n+\n+Y_UNIT_TEST_SUITE(KqpDecimalColumnShard) {\n+    class TDecimalTestCase {\n+    public:\n+        TDecimalTestCase()\n+            : TestHelper(TKikimrSettings().SetWithSampleTables(false)) {\n+        }\n+\n+        TTestHelper::TUpdatesBuilder Inserter() {\n+            return TTestHelper::TUpdatesBuilder(TestTable.GetArrowSchema(Schema));\n+        }\n+\n+        void Upsert(TTestHelper::TUpdatesBuilder& inserter) {\n+            TestHelper.BulkUpsert(TestTable, inserter);\n+        }\n+\n+        void CheckQuery(const TString& query, const TString& expected) {\n+            TestHelper.ReadData(query, expected);\n+        }\n+\n+        void PrepareTable1() {\n+            Schema = {\n+                TTestHelper::TColumnSchema().SetName(\"id\").SetType(NScheme::NTypeIds::Int32).SetNullable(false),\n+                TTestHelper::TColumnSchema().SetName(\"int\").SetType(NScheme::NTypeIds::Int64),\n+                TTestHelper::TColumnSchema().SetName(\"dec\").SetType(NScheme::NTypeIds::Decimal),\n+            };\n+            TestTable.SetName(\"/Root/Table1\").SetPrimaryKey({ \"id\" }).SetSharding({ \"id\" }).SetSchema(Schema);\n+            TestHelper.CreateTable(TestTable);\n+\n+            {\n+                TTestHelper::TUpdatesBuilder inserter = Inserter();\n+                inserter.AddRow().Add(1).Add(4).Add(TDecimalValue(\"3.14\"));\n+                inserter.AddRow().Add(2).Add(3).Add(TDecimalValue(\"8.16\"));\n+                Upsert(inserter);\n+            }\n+            {\n+                TTestHelper::TUpdatesBuilder inserter = Inserter();\n+                inserter.AddRow().Add(4).Add(1).Add(TDecimalValue(\"12.46\"));\n+                inserter.AddRow().Add(3).Add(2).Add(TDecimalValue(\"8.492\"));\n+\n+                Upsert(inserter);\n+            }\n+        }\n+\n+        void PrepareTable2() {\n+            Schema = {\n+                TTestHelper::TColumnSchema().SetName(\"id\").SetType(NScheme::NTypeIds::Int32).SetNullable(false),\n+                TTestHelper::TColumnSchema().SetName(\"table1_id\").SetType(NScheme::NTypeIds::Int64),\n+                TTestHelper::TColumnSchema().SetName(\"dec\").SetType(NScheme::NTypeIds::Decimal),\n+            };\n+            TestTable.SetName(\"/Root/Table2\").SetPrimaryKey({ \"id\" }).SetSharding({ \"id\" }).SetSchema(Schema);\n+            TestHelper.CreateTable(TestTable);\n+\n+            {\n+                TTestHelper::TUpdatesBuilder inserter = Inserter();\n+                inserter.AddRow().Add(1).Add(1).Add(TDecimalValue(\"12.46\"));\n+                inserter.AddRow().Add(2).Add(1).Add(TDecimalValue(\"8.16\"));\n+                inserter.AddRow().Add(3).Add(2).Add(TDecimalValue(\"12.46\"));\n+                inserter.AddRow().Add(4).Add(2).Add(TDecimalValue(\"8.16\"));\n+                Upsert(inserter);\n+            }\n+        }\n+\n+    private:\n+        TTestHelper TestHelper;\n+\n+        TVector<TTestHelper::TColumnSchema> Schema;\n+        TTestHelper::TColumnTable TestTable;\n+    };\n+\n+    Y_UNIT_TEST(TestSimpleQueries) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE id=1\", \"[[[\\\"3.14\\\"];1;[4]]]\");\n+        tester.CheckQuery(\n+            \"SELECT * FROM `/Root/Table1` order by id\", \"[[[\\\"3.14\\\"];1;[4]];[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestFilterEqual) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec == cast(\\\"3.14\\\" as decimal(22,9))\", \"[[[\\\"3.14\\\"];1;[4]]]\");\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec != cast(\\\"3.14\\\" as decimal(22,9)) order by id\",\n+            \"[[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestFilterNulls) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+\n+        TTestHelper::TUpdatesBuilder inserter = tester.Inserter();\n+        inserter.AddRow().Add(5).Add(5).AddNull();\n+        inserter.AddRow().Add(6).Add(6).AddNull();\n+        tester.Upsert(inserter);\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec is NULL order by id\", \"[[#;5;[5]];[#;6;[6]]]\");\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec is not NULL order by id\",\n+            \"[[[\\\"3.14\\\"];1;[4]];[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestFilterCompare) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec < cast(\\\"12.46\\\" as decimal(22,9)) order by id\",\n+            \"[[[\\\"3.14\\\"];1;[4]];[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]]]\");\n+\n+        tester.CheckQuery(\n+            \"SELECT * FROM `/Root/Table1` WHERE dec > cast(\\\"8.16\\\" as decimal(22,9)) order by id\", \"[[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec <= cast(\\\"12.46\\\" as decimal(22,9)) order by id\",\n+            \"[[[\\\"3.14\\\"];1;[4]];[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+\n+        tester.CheckQuery(\"SELECT * FROM `/Root/Table1` WHERE dec >= cast(\\\"8.492\\\" as decimal(22,9)) order by id\",\n+            \"[[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestOrderByDecimal) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+\n+        tester.CheckQuery(\n+            \"SELECT * FROM `/Root/Table1` order by dec\", \"[[[\\\"3.14\\\"];1;[4]];[[\\\"8.16\\\"];2;[3]];[[\\\"8.492\\\"];3;[2]];[[\\\"12.46\\\"];4;[1]]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestGroupByDecimal) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+\n+        TTestHelper::TUpdatesBuilder inserter = tester.Inserter();\n+        inserter.AddRow().Add(5).Add(12).Add(TDecimalValue(\"8.492\"));\n+        inserter.AddRow().Add(6).Add(30).Add(TDecimalValue(\"12.46\"));\n+        tester.Upsert(inserter);\n+\n+        tester.CheckQuery(\"SELECT dec, count(*) FROM `/Root/Table1` group by dec order by dec\",\n+            \"[[[\\\"3.14\\\"];1u];[[\\\"8.16\\\"];1u];[[\\\"8.492\\\"];2u];[[\\\"12.46\\\"];2u]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestAggregation) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+        tester.CheckQuery(\"SELECT min(dec) FROM `/Root/Table1`\", \"[[[\\\"3.14\\\"]]]\");\n+        tester.CheckQuery(\"SELECT max(dec) FROM `/Root/Table1`\", \"[[[\\\"12.46\\\"]]]\");\n+        tester.CheckQuery(\"SELECT sum(dec) FROM `/Root/Table1`\", \"[[[\\\"32.252\\\"]]]\");\n+    }\n+\n+    Y_UNIT_TEST(TestJoinById) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+        tester.PrepareTable2();\n+\n+        tester.CheckQuery(\n+            \"SELECT t1.id, t1.dec, t2.dec FROM `/Root/Table1` as t1 join `/Root/Table2` as t2 on t1.id = t2.table1_id order by t1.id, t1.dec, \"\n+            \"t2.dec\",\n+            R\"([[1;[\"3.14\"];[\"8.16\"]];[1;[\"3.14\"];[\"12.46\"]];[2;[\"8.16\"];[\"8.16\"]];[2;[\"8.16\"];[\"12.46\"]]])\");\n+    }\n+\n+    Y_UNIT_TEST(TestJoinByDecimal) {\n+        TDecimalTestCase tester;\n+        tester.PrepareTable1();\n+        tester.PrepareTable2();\n+\n+        tester.CheckQuery(\n+            \"SELECT t1.id, t2.id, t1.dec FROM `/Root/Table1` as t1 join `/Root/Table2` as t2 on t1.dec = t2.dec order by t1.id, t2.id, t1.dec\",\n+            R\"([[2;2;[\"8.16\"]];[2;4;[\"8.16\"]];[4;1;[\"12.46\"]];[4;3;[\"12.46\"]]])\");\n+    }\n+}\n+\n+}   // namespace NKqp\n+}   // namespace NKikimr\ndiff --git a/ydb/core/kqp/ut/olap/helpers/aggregation.cpp b/ydb/core/kqp/ut/olap/helpers/aggregation.cpp\nindex 7bed6f4a4aa4..1c03f6be9ffa 100644\n--- a/ydb/core/kqp/ut/olap/helpers/aggregation.cpp\n+++ b/ydb/core/kqp/ut/olap/helpers/aggregation.cpp\n@@ -13,6 +13,7 @@ void TestAggregationsBase(const std::vector<TAggregationTestCase>& cases) {\n \n     TLocalHelper(kikimr).CreateTestOlapTable();\n     auto tableClient = kikimr.GetTableClient();\n+    Tests::NCommon::TLoggerInit(kikimr).SetComponents({ NKikimrServices::GROUPED_MEMORY_LIMITER, NKikimrServices::TX_COLUMNSHARD_SCAN }, \"CS\").Initialize();\n \n     {\n         WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 10000, 3000000, 1000);\n@@ -49,10 +50,11 @@ void TestAggregationsInternal(const std::vector<TAggregationTestCase>& cases) {\n     Tests::TServer::TPtr server = new Tests::TServer(settings);\n \n     auto runtime = server->GetRuntime();\n+    Tests::NCommon::TLoggerInit(runtime).Initialize();\n+    Tests::NCommon::TLoggerInit(runtime).SetComponents({ NKikimrServices::GROUPED_MEMORY_LIMITER }, \"CS\").Initialize();\n     auto sender = runtime->AllocateEdgeActor();\n \n     InitRoot(server, sender);\n-    Tests::NCommon::TLoggerInit(runtime).Initialize();\n \n     ui32 numShards = 1;\n     ui32 numIterations = 10;\ndiff --git a/ydb/core/kqp/ut/olap/helpers/aggregation.h b/ydb/core/kqp/ut/olap/helpers/aggregation.h\nindex e83dcb32fd87..de9ab275fa79 100644\n--- a/ydb/core/kqp/ut/olap/helpers/aggregation.h\n+++ b/ydb/core/kqp/ut/olap/helpers/aggregation.h\n@@ -81,12 +81,7 @@ class TAggregationTestCase {\n     bool UseLlvm = true;\n public:\n     void FillExpectedAggregationGroupByPlanOptions() {\n-#if SSA_RUNTIME_VERSION >= 2U\n-        //            AddExpectedPlanOptions(\"TKqpOlapAgg\");\n         AddExpectedPlanOptions(\"WideCombiner\");\n-#else\n-        AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n     }\n     TString GetFixedQuery() const {\n         TStringBuilder queryFixed;\n@@ -177,7 +172,8 @@ void CheckPlanForAggregatePushdown(\n     const TString& query,\n     TClient& client,\n     const std::vector<std::string>& expectedPlanNodes,\n-    const std::string& readNodeType) {\n+    const std::string& readNodeType)\n+{\n     auto res = StreamExplainQuery(query, client);\n     UNIT_ASSERT_C(res.IsSuccess(), res.GetIssues().ToString());\n \n@@ -242,4 +238,4 @@ void WriteTestDataForTableWithNulls(TKikimrRunner& kikimr, TString testTable);\n \n void TestTableWithNulls(const std::vector<TAggregationTestCase>& cases, const bool genericQuery = false);\n \n-}\n\\ No newline at end of file\n+}\ndiff --git a/ydb/core/kqp/ut/olap/helpers/get_value.cpp b/ydb/core/kqp/ut/olap/helpers/get_value.cpp\nindex 208e5e40e02e..67fe905d8e44 100644\n--- a/ydb/core/kqp/ut/olap/helpers/get_value.cpp\n+++ b/ydb/core/kqp/ut/olap/helpers/get_value.cpp\n@@ -36,6 +36,11 @@ void PrintValue(IOutputStream& out, const NYdb::TValue& v) {\n             out << value.GetInt64();\n             break;\n         }\n+        case NYdb::EPrimitiveType::Uint8:\n+        {\n+            out << value.GetUint8();\n+            break;\n+        }\n         case NYdb::EPrimitiveType::Utf8:\n         {\n             out << value.GetUtf8();\ndiff --git a/ydb/core/kqp/ut/olap/helpers/local.h b/ydb/core/kqp/ut/olap/helpers/local.h\nindex dc957f98220e..9511ad1828ef 100644\n--- a/ydb/core/kqp/ut/olap/helpers/local.h\n+++ b/ydb/core/kqp/ut/olap/helpers/local.h\n@@ -28,8 +28,14 @@ class TLocalHelper: public Tests::NCS::THelper {\n \n     void CreateTestOlapTable(TString tableName = \"olapTable\", TString storeName = \"olapStore\",\n         ui32 storeShardsCount = 4, ui32 tableShardsCount = 3) {\n-        CreateOlapTableWithStore(tableName, storeName, storeShardsCount, tableShardsCount);\n+        CreateOlapTablesWithStore({tableName}, storeName, storeShardsCount, tableShardsCount);\n     }\n+\n+    void CreateTestOlapTables(TVector<TString> tableNames = {\"olapTable0\", \"olapTable1\"}, TString storeName = \"olapStore\",\n+        ui32 storeShardsCount = 4, ui32 tableShardsCount = 3) {\n+        CreateOlapTablesWithStore(tableNames, storeName, storeShardsCount, tableShardsCount);\n+    }\n+\n     using TBase::TBase;\n \n     TLocalHelper(TKikimrRunner& runner)\ndiff --git a/ydb/core/kqp/ut/olap/helpers/typed_local.cpp b/ydb/core/kqp/ut/olap/helpers/typed_local.cpp\nindex a37600897d2b..32c08c2c8925 100644\n--- a/ydb/core/kqp/ut/olap/helpers/typed_local.cpp\n+++ b/ydb/core/kqp/ut/olap/helpers/typed_local.cpp\n@@ -18,6 +18,31 @@ TString TTypedLocalHelper::GetTestTableSchema() const {\n     return result;\n }\n \n+TString TTypedLocalHelper::GetMultiColumnTestTableSchema(ui32 reps) const {\n+    TString result;\n+    result += R\"(\n+            Columns { Name: \"pk_int\" Type: \"Int64\" NotNull: true }\n+            Columns { Name: \"ts\" Type: \"Timestamp\" }\n+        )\";\n+    for (ui32 i = 0; i < reps; i++) {\n+        TString strNum = ToString(i);\n+        result += \"Columns {Name: \\\"field_utf\" + strNum + \"\\\" Type: \\\"Utf8\\\"}\\n\";\n+        result += \"Columns {Name: \\\"field_int\" + strNum + \"\\\" Type: \\\"Int64\\\"}\\n\";\n+        result += \"Columns {Name: \\\"field_uint\" + strNum + \"\\\" Type: \\\"Uint8\\\"}\\n\";\n+        result += \"Columns {Name: \\\"field_float\" + strNum + \"\\\" Type: \\\"Float\\\"}\\n\";\n+        result += \"Columns {Name: \\\"field_double\" + strNum + \"\\\" Type: \\\"Double\\\"}\\n\";\n+    }\n+    result += R\"(\n+            KeyColumnNames: \"pk_int\"\n+            Engine: COLUMN_ENGINE_REPLACING_TIMESERIES\n+    )\";\n+    return result;\n+}\n+\n+void TTypedLocalHelper::CreateMultiColumnOlapTableWithStore(ui32 reps,  ui32 storeShardsCount, ui32 tableShardsCount) {\n+    CreateSchemaOlapTablesWithStore(GetMultiColumnTestTableSchema(reps), {TableName}, \"olapStore\", storeShardsCount, tableShardsCount);\n+}\n+\n void TTypedLocalHelper::ExecuteSchemeQuery(const TString& alterQuery, const NYdb::EStatus expectedStatus /*= EStatus::SUCCESS*/) const {\n     auto session = KikimrRunner.GetTableClient().CreateSession().GetValueSync().GetSession();\n     auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n@@ -79,7 +104,7 @@ NKikimr::NKqp::TTypedLocalHelper::TDistribution TTypedLocalHelper::GetDistributi\n }\n \n void TTypedLocalHelper::GetVolumes(ui64& rawBytes, ui64& bytes, const bool verbose /*= false*/, const std::vector<TString> columnNames /*= {}*/) {\n-    TString selectQuery = \"SELECT * FROM `\" + TablePath + \"/.sys/primary_index_stats` WHERE Activity = true\";\n+    TString selectQuery = \"SELECT * FROM `\" + TablePath + \"/.sys/primary_index_stats` WHERE Activity == 1\";\n     if (columnNames.size()) {\n         selectQuery += \" AND EntityName IN ('\" + JoinSeq(\"','\", columnNames) + \"')\";\n     }\n@@ -144,7 +169,7 @@ void TTypedLocalHelper::FillPKOnly(const double pkKff /*= 0*/, const ui32 numRow\n }\n \n void TTypedLocalHelper::GetStats(std::vector<NJson::TJsonValue>& stats, const bool verbose /*= false*/) {\n-    TString selectQuery = \"SELECT * FROM `\" + TablePath + \"/.sys/primary_index_portion_stats` WHERE Activity = true\";\n+    TString selectQuery = \"SELECT * FROM `\" + TablePath + \"/.sys/primary_index_portion_stats` WHERE Activity == 1\";\n     auto tableClient = KikimrRunner.GetTableClient();\n     auto rows = ExecuteScanQuery(tableClient, selectQuery, verbose);\n     for (auto&& r : rows) {\ndiff --git a/ydb/core/kqp/ut/olap/helpers/typed_local.h b/ydb/core/kqp/ut/olap/helpers/typed_local.h\nindex a72cef64e33e..df81c5cd6a86 100644\n--- a/ydb/core/kqp/ut/olap/helpers/typed_local.h\n+++ b/ydb/core/kqp/ut/olap/helpers/typed_local.h\n@@ -1,12 +1,14 @@\n #pragma once\n #include <ydb/core/testlib/cs_helper.h>\n #include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n \n #include <ydb/public/sdk/cpp/client/ydb_types/status_codes.h>\n \n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_binary.h>\n+\n #include <library/cpp/json/writer/json_value.h>\n \n namespace NKikimr::NKqp {\n@@ -29,7 +31,7 @@ class TTypedLocalHelper: public Tests::NCS::THelper {\n         : TBase(kikimrRunner.GetTestServer())\n         , TypeName(typeName)\n         , KikimrRunner(kikimrRunner)\n-        , TablePath(\"/Root/\" + storeName + \"/\" + tableName)\n+        , TablePath(storeName.empty() ? \"/Root/\" + tableName : \"/Root/\" + storeName + \"/\" + tableName)\n         , TableName(tableName)\n         , StoreName(storeName) {\n         SetShardingMethod(\"HASH_FUNCTION_CONSISTENCY_64\");\n@@ -83,11 +85,38 @@ class TTypedLocalHelper: public Tests::NCS::THelper {\n         TBase::SendDataViaActorSystem(TablePath, batch);\n     }\n \n+    void FillMultiColumnTable(ui32 repCount, const double pkKff = 0, const ui32 numRows = 800000) const {\n+        const double frq = 0.9;\n+        NArrow::NConstruction::TPoolFiller<arrow::Int64Type> int64Pool(1000, 0, frq);\n+        NArrow::NConstruction::TPoolFiller<arrow::UInt8Type> uint8Pool(1000, 0, frq);\n+        NArrow::NConstruction::TPoolFiller<arrow::FloatType> floatPool(1000, 0, frq);\n+        NArrow::NConstruction::TPoolFiller<arrow::DoubleType> doublePool(1000, 0, frq);\n+        NArrow::NConstruction::TPoolFiller<NKikimr::NArrow::NConstruction::TStringType> utfPool(1000, 52, \"abcde\", frq);\n+\n+        std::vector<NArrow::NConstruction::IArrayBuilder::TPtr> builders;\n+        builders.emplace_back(NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TIntSeqFiller<arrow::Int64Type>>::BuildNotNullable(\"pk_int\", numRows * pkKff));\n+        for (ui32 i = 0; i < repCount; i++) {\n+            TString repStr = ToString(i);\n+            builders.emplace_back(std::make_shared<NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TPoolFiller<NKikimr::NArrow::NConstruction::TStringType>>>(\"field_utf\" + repStr, utfPool, i));\n+            builders.emplace_back(std::make_shared<NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TPoolFiller<arrow::Int64Type>>>(\"field_int\" + repStr, int64Pool, i));\n+            builders.emplace_back(std::make_shared<NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TPoolFiller<arrow::UInt8Type>>>(\"field_uint\" + repStr, uint8Pool, i));\n+            builders.emplace_back(std::make_shared<NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TPoolFiller<arrow::FloatType>>>(\"field_float\" + repStr, floatPool, i));\n+            builders.emplace_back(std::make_shared<NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TPoolFiller<arrow::DoubleType>>>(\"field_double\" + repStr, doublePool, i));\n+        }\n+        NArrow::NConstruction::TRecordBatchConstructor batchBuilder(builders);\n+        std::shared_ptr<arrow::RecordBatch> batch = batchBuilder.BuildBatch(numRows);\n+        TBase::SendDataViaActorSystem(TablePath, batch);\n+    }\n+\n+\n     void FillPKOnly(const double pkKff = 0, const ui32 numRows = 800000) const;\n \n     void CreateTestOlapTable(ui32 storeShardsCount = 4, ui32 tableShardsCount = 3) {\n-        CreateOlapTableWithStore(TableName, StoreName, storeShardsCount, tableShardsCount);\n+        CreateOlapTablesWithStore({TableName}, StoreName, storeShardsCount, tableShardsCount);\n     }\n+\n+    TString GetMultiColumnTestTableSchema(ui32 reps) const;\n+    void CreateMultiColumnOlapTableWithStore(ui32 reps, ui32 storeShardsCount = 4, ui32 tableShardsCount = 3);\n };\n \n-}\n\\ No newline at end of file\n+}\ndiff --git a/ydb/core/kqp/ut/olap/indexes_ut.cpp b/ydb/core/kqp/ut/olap/indexes_ut.cpp\nindex feff93803fc5..7699cd8d8b6e 100644\n--- a/ydb/core/kqp/ut/olap/indexes_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/indexes_ut.cpp\n@@ -17,8 +17,8 @@ Y_UNIT_TEST_SUITE(KqpOlapIndexes) {\n         TKikimrRunner kikimr(settings);\n \n         auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n-        csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n-        csController->SetLagForCompactionBeforeTierings(TDuration::Seconds(1));\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->SetOverrideLagForCompactionBeforeTierings(TDuration::Seconds(1));\n         csController->SetOverrideReduceMemoryIntervalLimit(1LLU << 30);\n \n         TLocalHelper(kikimr).CreateTestOlapTable();\n@@ -111,7 +111,7 @@ Y_UNIT_TEST_SUITE(KqpOlapIndexes) {\n         TKikimrRunner kikimr(settings);\n \n         auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n-        csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n \n         TLocalHelper(kikimr).CreateTestOlapTable();\n         auto tableClient = kikimr.GetTableClient();\ndiff --git a/ydb/core/kqp/ut/olap/kqp_olap_stats_ut.cpp b/ydb/core/kqp/ut/olap/kqp_olap_stats_ut.cpp\nindex 4f6c90056e89..c1fcab4be0fd 100644\n--- a/ydb/core/kqp/ut/olap/kqp_olap_stats_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/kqp_olap_stats_ut.cpp\n@@ -21,10 +21,10 @@ Y_UNIT_TEST_SUITE(KqpOlapStats) {\n \n     class TOlapStatsController : public NYDBTest::NColumnShard::TController {\n     public:\n-        TDuration GetPeriodicWakeupActivationPeriod(const TDuration /*defaultValue*/) const override {\n+        TDuration DoGetPeriodicWakeupActivationPeriod(const TDuration /*defaultValue*/) const override {\n             return TDuration::MilliSeconds(10);\n         }\n-        TDuration GetStatsReportInterval(const TDuration /*defaultValue*/) const override {\n+        TDuration DoGetStatsReportInterval(const TDuration /*defaultValue*/) const override {\n             return TDuration::MilliSeconds(10);\n         }\n     };\ndiff --git a/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp b/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp\nindex ea3037550a43..b68a7fcea98e 100644\n--- a/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp\n@@ -51,9 +51,10 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             PARTITION BY HASH(timestamp)\n             WITH (\n                 STORE = COLUMN,\n-                AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = %d\n+                PARTITION_COUNT = %d\n                 )\n-            )\", storeName.data(), tableName.data(), shardsCount);\n+            )\",\n+                             storeName.data(), tableName.data(), shardsCount);\n             auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n             if (result.GetStatus() != EStatus::SUCCESS) {\n                 Cerr << result.GetIssues().ToOneLineString() << Endl;\n@@ -1844,8 +1845,8 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             PARTITION BY HASH(WatchID)\n             WITH (\n                 STORE = COLUMN,\n-                AUTO_PARTITIONING_MIN_PARTITIONS_COUNT =)\" << numShards\n-            << \")\";\n+                PARTITION_COUNT =)\" << numShards\n+                                      << \")\";\n         auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n@@ -1932,10 +1933,9 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n                 WITH (\n                     STORE = COLUMN,\n                     AUTO_PARTITIONING_BY_SIZE = ENABLED,\n-                    AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 1\n+                    PARTITION_COUNT = 1\n                 );\n-            )\"\n-        );\n+            )\");\n \n         lHelper.StartDataRequest(\n             R\"(\n@@ -1987,10 +1987,9 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n                 WITH (\n                     STORE = COLUMN,\n                     AUTO_PARTITIONING_BY_SIZE = ENABLED,\n-                    AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 1\n+                    PARTITION_COUNT = 1\n                 );\n-            )\"\n-        );\n+            )\");\n \n         lHelper.StartDataRequest(\n             R\"(\n@@ -1999,7 +1998,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         );\n \n     }\n-/*\n+    /*\n     Y_UNIT_TEST(OlapDeletePlanned) {\n         TPortManager pm;\n \n@@ -2039,7 +2038,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n                 WITH (\n                     STORE = COLUMN,\n                     AUTO_PARTITIONING_BY_SIZE = ENABLED,\n-                    AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 8\n+                    PARTITION_COUNT = 8\n                 );\n             )\"\n         );\n@@ -2479,14 +2478,14 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n                 PRIMARY KEY (a)\n             )\n             PARTITION BY HASH(a)\n-            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 4);\n+            WITH (STORE = COLUMN, PARTITION_COUNT = 4);\n         )\";\n \n         auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n         UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n \n         auto client = kikimr.GetQueryClient();\n-        { \n+        {\n             auto prepareResult = client.ExecuteQuery(R\"(\n                 REPLACE INTO `/Root/ColumnShard` (a, b, c) VALUES\n                     (1u, 1, 5),\n@@ -2516,15 +2515,16 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n                     UNIT_ASSERT_C(plan.QueryStats->Getquery_ast().Contains(\"return (FromFlow (NarrowMap (WideFromBlocks\"), plan.QueryStats->Getquery_ast());\n                     break;\n                 case NKikimrConfig::TTableServiceConfig_EBlockChannelsMode_BLOCK_CHANNELS_AUTO:\n-                    UNIT_ASSERT_C(plan.QueryStats->Getquery_ast().Contains(\"return (FromFlow (ExpandMap (NarrowMap (WideFromBlocks\"), plan.QueryStats->Getquery_ast());\n+                    UNIT_ASSERT_C(plan.QueryStats->Getquery_ast().Contains(\"return (FromFlow (WideFromBlocks\"), plan.QueryStats->Getquery_ast());\n                     break;\n                 case NKikimrConfig::TTableServiceConfig_EBlockChannelsMode_BLOCK_CHANNELS_FORCE:\n-                    UNIT_ASSERT_C(plan.QueryStats->Getquery_ast().Contains(\"return (FromFlow (WideMap\"), plan.QueryStats->Getquery_ast());\n+                    UNIT_ASSERT_C(plan.QueryStats->Getquery_ast().Contains(\"(FromFlow (WideSortBlocks\"), plan.QueryStats->Getquery_ast());\n+                    UNIT_ASSERT_C(plan.QueryStats->Getquery_ast().Contains(\"(FromFlow (NarrowMap (WideFromBlocks\"), plan.QueryStats->Getquery_ast());\n                     break;\n             }\n         }\n \n-        { \n+        {\n             auto it = client.StreamExecuteQuery(R\"(\n                 SELECT\n                     b, COUNT(*), SUM(a)\n@@ -2630,8 +2630,8 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         TLocalHelper testHelper(kikimr);\n \n         auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n-        csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n-        csController->SetLagForCompactionBeforeTierings(TDuration::Seconds(1));\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->SetOverrideLagForCompactionBeforeTierings(TDuration::Seconds(1));\n         csController->SetOverrideReduceMemoryIntervalLimit(1LLU << 30);\n         csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n \n@@ -2696,6 +2696,121 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         }\n     }\n \n+    Y_UNIT_TEST(CountWhereColumnIsNull) {\n+        auto settings = TKikimrSettings()\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::TX_COLUMNSHARD_SCAN, NActors::NLog::PRI_DEBUG);\n+\n+        TLocalHelper(kikimr).CreateTestOlapTable();\n+\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 0, 1000000, 300, true);\n+\n+        auto client = kikimr.GetTableClient();\n+\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        {\n+            auto it = client.StreamExecuteScanQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT COUNT(*), COUNT(level)\n+                FROM `/Root/olapStore/olapTable`\n+                WHERE level IS NULL\n+            )\").GetValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+            TString result = StreamResultToYson(it);\n+            Cout << result << Endl;\n+            CompareYson(\"[[100u;0u]]\", result);\n+        }\n+\n+        {\n+            auto it = client.StreamExecuteScanQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT COUNT(*), COUNT(level)\n+                FROM `/Root/olapStore/olapTable`\n+                WHERE level IS NULL AND uid IS NOT NULL\n+            )\").GetValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+            TString result = StreamResultToYson(it);\n+            Cout << result << Endl;\n+            CompareYson(\"[[100u;0u]]\", result);\n+        }\n+\n+        {\n+            auto it = client.StreamExecuteScanQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT COUNT(*), COUNT(level)\n+                FROM `/Root/olapStore/olapTable`\n+                WHERE level IS NULL\n+                GROUP BY level\n+            )\").GetValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+            TString result = StreamResultToYson(it);\n+            Cout << result << Endl;\n+            CompareYson(\"[[100u;0u]]\", result);\n+        }\n+    }\n+\n+    Y_UNIT_TEST(SimpleCount) {\n+        auto settings = TKikimrSettings()\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::TX_COLUMNSHARD_SCAN, NActors::NLog::PRI_DEBUG);\n+\n+        TLocalHelper(kikimr).CreateTestOlapTable();\n+\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 0, 1000000, 300, true);\n+\n+        auto client = kikimr.GetTableClient();\n+\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        {\n+            auto it = client.StreamExecuteScanQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT COUNT(level)\n+                FROM `/Root/olapStore/olapTable`\n+                WHERE StartsWith(uid, \"uid_\")\n+            )\").GetValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+            TString result = StreamResultToYson(it);\n+            Cout << result << Endl;\n+            CompareYson(\"[[200u]]\", result);\n+        }\n+    }\n+\n+    Y_UNIT_TEST(TableSinkWithOlapStore) {\n+       NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(appConfig)\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        TLocalHelper(kikimr).CreateTestOlapTables();\n+\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable0\", 0, 1000000, 3, true);\n+\n+        auto client = kikimr.GetQueryClient();\n+        {\n+            auto result = client.ExecuteQuery(R\"(\n+                SELECT * FROM `/Root/olapStore/olapTable0` ORDER BY timestamp;\n+                INSERT INTO `/Root/olapStore/olapTable1` SELECT * FROM `/Root/olapStore/olapTable0`;\n+                REPLACE INTO `/Root/olapStore/olapTable0` SELECT * FROM `/Root/olapStore/olapTable1`;\n+                SELECT * FROM `/Root/olapStore/olapTable1` ORDER BY timestamp;\n+            )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+    }\n }\n \n }\ndiff --git a/ydb/core/kqp/ut/olap/sparsed_ut.cpp b/ydb/core/kqp/ut/olap/sparsed_ut.cpp\nnew file mode 100644\nindex 000000000000..73b75f2cc53f\n--- /dev/null\n+++ b/ydb/core/kqp/ut/olap/sparsed_ut.cpp\n@@ -0,0 +1,307 @@\n+#include \"helpers/local.h\"\n+#include \"helpers/writer.h\"\n+#include \"helpers/typed_local.h\"\n+#include \"helpers/query_executor.h\"\n+#include \"helpers/get_value.h\"\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+#include <ydb/core/base/tablet_pipecache.h>\n+#include <ydb/core/wrappers/fake_storage.h>\n+\n+namespace NKikimr::NKqp {\n+\n+Y_UNIT_TEST_SUITE(KqpOlapSparsed) {\n+\n+    class TSparsedDataTest {\n+    private:\n+        const TKikimrSettings Settings = TKikimrSettings().SetWithSampleTables(false);\n+        TKikimrRunner Kikimr;\n+        NKikimr::NYDBTest::TControllers::TGuard<NKikimr::NYDBTest::NColumnShard::TController> CSController;\n+        const TString StoreName;\n+        ui32 MultiColumnRepCount = 100;\n+        static const ui32 SKIP_GROUPS = 7;\n+        const TVector<TString> FIELD_NAMES{\"utf\", \"int\", \"uint\", \"float\", \"double\"};\n+    public:\n+        TSparsedDataTest(const TString& storeName)\n+            : Kikimr(Settings)\n+            , CSController(NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NKikimr::NYDBTest::NColumnShard::TController>())\n+            , StoreName(storeName)\n+        {\n+\n+        }\n+\n+        ui32 GetCount() const {\n+            auto selectQuery = TString(R\"(\n+                SELECT\n+                    count(*) as count,\n+                FROM `/Root/)\") + (StoreName.empty() ? \"\" : StoreName + \"/\") + \"olapTable`\";\n+\n+            auto tableClient = Kikimr.GetTableClient();\n+            auto rows = ExecuteScanQuery(tableClient, selectQuery);\n+            return GetUint64(rows[0].at(\"count\"));\n+        }\n+\n+        ui32 GetDefaultsCount(const TString& fieldName, const TString& defValueStr) const {\n+            auto selectQueryTmpl = TString(R\"(\n+                SELECT\n+                    count(*) as count,\n+                FROM `/Root/)\") + (StoreName.empty() ? \"\" : StoreName + \"/\") + R\"(olapTable`\n+                WHERE %s == %s\n+            )\";\n+\n+            auto tableClient = Kikimr.GetTableClient();\n+            auto rows = ExecuteScanQuery(tableClient, Sprintf(selectQueryTmpl.c_str(), fieldName.c_str(), defValueStr.c_str()));\n+            return GetUint64(rows[0].at(\"count\"));\n+        }\n+\n+        void GetAllDefaultsCount(ui64* counts, ui32 skipCount) {\n+            TString query = \"SELECT\";\n+            ui32 groupsCount = 0;\n+            for (ui32 i = 0; i < MultiColumnRepCount; i += skipCount) {\n+                query += Sprintf(\"%s field_utf%u == 'abcde' AS def_utf%u, field_uint%u == 0 AS def_uint%u, field_int%u == 0 AS def_int%u, field_float%u == 0 AS def_float%u, field_double%u == 0 AS def_double%u\", i == 0 ? \"\" : \",\", i, i, i, i, i, i, i, i, i, i);\n+                groupsCount++;\n+            }\n+            query += \" FROM `/Root/olapStore/olapTable`\";\n+            auto tableClient = Kikimr.GetTableClient();\n+\n+            auto start = TInstant::Now().Seconds();\n+\n+            auto printTime = [&](const char* prefix) {\n+                auto finish = TInstant::Now().Seconds();\n+                fprintf(stderr, \"Timing: %s took %lu seconds\\n\", prefix, finish - start);\n+                start = finish;\n+            };\n+\n+            auto rows = ExecuteScanQuery(tableClient, query, false);\n+\n+            printTime(\"Executing query\");\n+\n+            Fill(&counts[0], &counts[FIELD_NAMES.size() * groupsCount], 0);\n+\n+            for (auto& row: rows) {\n+                auto incCounts = [&](ui32 i, const TString& column) {\n+                    if (*NYdb::TValueParser(row.at(column)).GetOptionalBool()) {\n+                        counts[i]++;\n+                    }\n+                };\n+                ui32 ind = 0;\n+                for (ui32 i = 0; i < MultiColumnRepCount; i += skipCount) {\n+                    TString grStr = ToString(i);\n+                    incCounts(ind++, \"def_utf\" + grStr);\n+                    incCounts(ind++, \"def_uint\" + grStr);\n+                    incCounts(ind++, \"def_int\" + grStr);\n+                    incCounts(ind++, \"def_float\" + grStr);\n+                    incCounts(ind++, \"def_double\" + grStr);\n+                }\n+             }\n+        }\n+\n+        void CheckAllFieldsTable(bool firstCall, ui32 countExpectation, ui32* defCountStart) {\n+            ui32 grCount = (MultiColumnRepCount + SKIP_GROUPS - 1) / SKIP_GROUPS;\n+            ui64 defCounts[FIELD_NAMES.size() * grCount];\n+            const ui32 count = GetCount();\n+            GetAllDefaultsCount(defCounts, SKIP_GROUPS);\n+            for (ui32 i = 0; i < FIELD_NAMES.size() * grCount; i++) {\n+                if (firstCall) {\n+                    defCountStart[i] = defCounts[i];\n+                } else {\n+                    AFL_VERIFY(defCountStart[i] == defCounts[i]);\n+                }\n+                AFL_VERIFY(count == countExpectation)(\"expect\", countExpectation)(\"count\", count);\n+                AFL_VERIFY(1.0 * defCounts[i] / count < 0.95)(\"def\", defCounts[i])(\"count\", count);\n+                AFL_VERIFY(1.0 * defCounts[i] / count > 0.85)(\"def\", defCounts[i])(\"count\", count);\n+            }\n+        }\n+\n+        void CheckTable(const TString& fieldName, const TString& defValueStr, bool firstCall, ui32 countExpectation, ui32& defCountStart) {\n+            const ui32 defCount = GetDefaultsCount(fieldName, defValueStr);\n+            if (firstCall) {\n+                defCountStart = defCount;\n+            } else {\n+                AFL_VERIFY(defCountStart == defCount);\n+            }\n+            const ui32 count = GetCount();\n+            AFL_VERIFY(count == countExpectation)(\"expect\", countExpectation)(\"count\", count);\n+            AFL_VERIFY(1.0 * defCount / count < 0.95)(\"def\", defCount)(\"count\", count);\n+            AFL_VERIFY(1.0 * defCount / count > 0.85)(\"def\", defCount)(\"count\", count);\n+        }\n+\n+        template<class TFillTable, class TCheckTable>\n+        void FillCircleImpl(TFillTable&& fillTable, TCheckTable&& checkTable) {\n+            auto start = TInstant::Now().Seconds();\n+\n+            auto printTime = [&](const char* prefix) {\n+                auto finish = TInstant::Now().Seconds();\n+                fprintf(stderr, \"Timing: %s took %lu seconds\\n\", prefix, finish - start);\n+                start = finish;\n+            };\n+\n+            fillTable();\n+            printTime(\"fillTable\");\n+            checkTable(true);\n+            printTime(\"checkTable\");\n+\n+            CSController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+            CSController->WaitIndexation(TDuration::Seconds(5));\n+            printTime(\"wait\");\n+\n+            checkTable(false);\n+            printTime(\"checkTable\");\n+\n+            CSController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+            CSController->WaitCompactions(TDuration::Seconds(5));\n+            printTime(\"wait\");\n+\n+            checkTable(false);\n+            printTime(\"checkTable\");\n+\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+            printTime(\"wait\");\n+        }\n+\n+        void FillCircle(const double shiftKff, const ui32 countExpectation) {\n+            ui32 defCountStart = (ui32)-1;\n+            FillCircleImpl([&]() {\n+                TTypedLocalHelper helper(\"Utf8\", Kikimr, \"olapTable\", StoreName);\n+                const double frq = 0.9;\n+                NArrow::NConstruction::TStringPoolFiller sPool(1000, 52, \"abcde\", frq);\n+                helper.FillTable(sPool, shiftKff, 10000);\n+            },\n+            [&](bool firstCall) {\n+                CheckTable(\"field\", \"'abcde'\", firstCall, countExpectation, defCountStart);\n+            });\n+        }\n+\n+        void FillMultiColumnCircle(const double shiftKff, const ui32 countExpectation) {\n+            ui32 grCount = (MultiColumnRepCount + SKIP_GROUPS - 1) / SKIP_GROUPS;\n+            ui32 defCountStart[FIELD_NAMES.size() * grCount];\n+            FillCircleImpl([&]() {\n+                TTypedLocalHelper helper(\"Utf8\", Kikimr);\n+                helper.FillMultiColumnTable(MultiColumnRepCount, shiftKff, 10000);\n+            },\n+            [&](bool firstCall) {\n+                CheckAllFieldsTable(firstCall, countExpectation, defCountStart);\n+            });\n+        }\n+\n+        void Execute() {\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+            CSController->SetOverridePeriodicWakeupActivationPeriod(TDuration::MilliSeconds(100));\n+\n+            Tests::NCommon::TLoggerInit(Kikimr).Initialize();\n+            TTypedLocalHelper helper(\"Utf8\", Kikimr, \"olapTable\", StoreName);\n+            if (!StoreName.empty()) {\n+                helper.CreateTestOlapTable();\n+            } else {\n+                auto tableClient = Kikimr.GetTableClient();\n+                auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+\n+                auto query = TStringBuilder() << R\"(\n+                    --!syntax_v1\n+                    CREATE TABLE `/Root/olapTable`\n+                    (\n+                        pk_int int64 NOT NULL,\n+                        field )\" << \"Utf8\" << R\"(,\n+                        ts TimeStamp,\n+                        PRIMARY KEY (pk_int)\n+                    )\n+                    PARTITION BY HASH(pk_int)\n+                    WITH (\n+                        STORE = COLUMN\n+                    ))\";\n+                auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+            }\n+\n+            TString type = StoreName.empty() ? \"TABLE\" : \"TABLESTORE\";\n+            TString name = StoreName.empty() ? \"olapTable\" : \"olapStore\";\n+\n+            FillCircle(0, 10000);\n+            helper.ExecuteSchemeQuery(\"ALTER OBJECT `/Root/\" + name + \"`(TYPE \" + type + \") SET (ACTION=ALTER_COLUMN, NAME=field, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SPARSED`, `DEFAULT_VALUE`=`abcde`);\");\n+            FillCircle(0.1, 11000);\n+            helper.ExecuteSchemeQuery(\"ALTER OBJECT `/Root/\" + name + \"`(TYPE \" + type + \") SET (ACTION=ALTER_COLUMN, NAME=field, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`PLAIN`);\");\n+            FillCircle(0.2, 12000);\n+            helper.ExecuteSchemeQuery(\"ALTER OBJECT `/Root/\" + name + \"`(TYPE \" + type + \") SET (ACTION=ALTER_COLUMN, NAME=field, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SPARSED`);\");\n+            FillCircle(0.3, 13000);\n+            helper.ExecuteSchemeQuery(\"ALTER OBJECT `/Root/\" + name + \"`(TYPE \" + type + \") SET (ACTION=ALTER_COLUMN, NAME=field, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`PLAIN`);\");\n+            FillCircle(0.4, 14000);\n+        }\n+\n+        void ExecuteMultiColumn() {\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+            CSController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+            CSController->SetOverridePeriodicWakeupActivationPeriod(TDuration::MilliSeconds(100));\n+\n+            Tests::NCommon::TLoggerInit(Kikimr).Initialize();\n+            TTypedLocalHelper helper(\"Utf8\", Kikimr);\n+            helper.CreateMultiColumnOlapTableWithStore(MultiColumnRepCount);\n+\n+            auto start = TInstant::Now().Seconds();\n+\n+            auto printTime = [&](const char* prefix) {\n+                auto finish = TInstant::Now().Seconds();\n+                fprintf(stderr, \"Timing: %s took %lu seconds\\n\", prefix, finish - start);\n+                start = finish;\n+            };\n+\n+            FillMultiColumnCircle(0, 10000);\n+            printTime(\"Fill\");\n+            for (ui32 i = 0; i < MultiColumnRepCount; i += SKIP_GROUPS) {\n+                TString grStr = ToString(i);\n+                for (ui32 f = 0; f < FIELD_NAMES.size(); f++) {\n+                    helper.ExecuteSchemeQuery(TString(\"ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=ALTER_COLUMN, NAME=field_\") + FIELD_NAMES[f] + grStr + \", `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SPARSED`, `DEFAULT_VALUE`=\" + (f == 0 ? \"`abcde`\" : \"`0`\") + \");\");\n+                }\n+            }\n+            printTime(\"Alter\");\n+            FillMultiColumnCircle(0.1, 11000);\n+            printTime(\"Fill\");\n+            for (ui32 i = 0; i < MultiColumnRepCount; i += SKIP_GROUPS) {\n+                TString grStr = ToString(i);\n+                for (ui32 f = 0; f < FIELD_NAMES.size(); f++) {\n+                    helper.ExecuteSchemeQuery(TString(\"ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=ALTER_COLUMN, NAME=field_\") + FIELD_NAMES[f] + grStr + \", `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`PLAIN`);\");\n+                }\n+            }\n+            printTime(\"Alter\");\n+            FillMultiColumnCircle(0.2, 12000);\n+            printTime(\"Fill\");\n+            for (ui32 i = 0; i < MultiColumnRepCount; i += SKIP_GROUPS) {\n+                TString grStr = ToString(i);\n+                for (ui32 f = 0; f < FIELD_NAMES.size(); f++) {\n+                    helper.ExecuteSchemeQuery(TString(\"ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=ALTER_COLUMN, NAME=field_\") + FIELD_NAMES[f] + grStr + \", `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SPARSED`);\");\n+                }\n+            }\n+            printTime(\"Alter\");\n+            FillMultiColumnCircle(0.3, 13000);\n+            printTime(\"Fill\");\n+            for (ui32 i = 0; i < MultiColumnRepCount; i += SKIP_GROUPS) {\n+                TString grStr = ToString(i);\n+                for (ui32 f = 0; f < FIELD_NAMES.size(); f++) {\n+                    helper.ExecuteSchemeQuery(TString(\"ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=ALTER_COLUMN, NAME=field_\") + FIELD_NAMES[f] + grStr + \", `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`PLAIN`);\");\n+                }\n+            }\n+            printTime(\"Alter\");\n+            FillMultiColumnCircle(0.4, 14000);\n+            printTime(\"Fill\");\n+        }\n+    };\n+\n+    Y_UNIT_TEST(Switching) {\n+        TSparsedDataTest test(\"olapStore\");\n+        test.Execute();\n+    }\n+\n+    Y_UNIT_TEST(SwitchingMultiColumn) {\n+        TSparsedDataTest test(\"olapStore\");\n+        test.ExecuteMultiColumn();\n+    }\n+\n+    Y_UNIT_TEST(SwitchingStandalone) {\n+        TSparsedDataTest test(\"\");\n+        test.Execute();\n+    }\n+}\n+\n+} // namespace\ndiff --git a/ydb/core/kqp/ut/olap/sys_view_ut.cpp b/ydb/core/kqp/ut/olap/sys_view_ut.cpp\nindex 8583967214ca..27820452542e 100644\n--- a/ydb/core/kqp/ut/olap/sys_view_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/sys_view_ut.cpp\n@@ -453,7 +453,7 @@ Y_UNIT_TEST_SUITE(KqpOlapSysView) {\n                 SELECT PathId, Kind, TabletId\n                 FROM `/Root/olapStore/.sys/store_primary_index_stats`\n                 WHERE\n-                    PathId == UInt64(\"3\") AND Activity = true\n+                    PathId == UInt64(\"3\") AND Activity == 1\n                 GROUP BY TabletId, PathId, Kind\n                 ORDER BY TabletId, Kind\n             )\");\ndiff --git a/ydb/core/kqp/ut/olap/tiering_ut.cpp b/ydb/core/kqp/ut/olap/tiering_ut.cpp\nnew file mode 100644\nindex 000000000000..b9cceba93738\n--- /dev/null\n+++ b/ydb/core/kqp/ut/olap/tiering_ut.cpp\n@@ -0,0 +1,161 @@\n+#include \"helpers/get_value.h\"\n+#include \"helpers/local.h\"\n+#include \"helpers/query_executor.h\"\n+#include \"helpers/typed_local.h\"\n+#include \"helpers/writer.h\"\n+\n+#include <ydb/core/kqp/ut/common/columnshard.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+#include <ydb/core/tx/columnshard/test_helper/controllers.h>\n+#include <ydb/core/wrappers/fake_storage.h>\n+\n+namespace NKikimr::NKqp {\n+\n+Y_UNIT_TEST_SUITE(KqpOlapTiering) {\n+    Y_UNIT_TEST(Eviction) {\n+        auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n+\n+        TKikimrSettings runnerSettings;\n+        runnerSettings.WithSampleTables = false;\n+        TTestHelper testHelper(runnerSettings);\n+        TLocalHelper localHelper(testHelper.GetKikimr());\n+        NYdb::NTable::TTableClient tableClient = testHelper.GetKikimr().GetTableClient();\n+        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();\n+        Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->SetSecretKey(\"fakeSecret\");\n+\n+        localHelper.CreateTestOlapTable();\n+        testHelper.CreateTier(\"tier1\");\n+        const TString tieringRule = testHelper.CreateTieringRule(\"tier1\", \"timestamp\");\n+\n+        for (ui64 i = 0; i < 100; ++i) {\n+            WriteTestData(testHelper.GetKikimr(), \"/Root/olapStore/olapTable\", 0, i * 10000, 1000);\n+        }\n+\n+        csController->WaitActualization(TDuration::Seconds(5));\n+\n+        ui64 columnRawBytes = 0;\n+        {\n+            auto selectQuery = TString(R\"(\n+                SELECT\n+                    TierName, SUM(ColumnRawBytes) As RawBytes\n+                FROM `/Root/olapStore/olapTable/.sys/primary_index_portion_stats`\n+                WHERE Activity == 1\n+                GROUP BY TierName\n+            )\");\n+\n+            auto rows = ExecuteScanQuery(tableClient, selectQuery);\n+            UNIT_ASSERT_VALUES_EQUAL(rows.size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(GetUtf8(rows[0].at(\"TierName\")), \"__DEFAULT\");\n+\n+            columnRawBytes = GetUint64(rows[0].at(\"RawBytes\"));\n+            UNIT_ASSERT_GT(columnRawBytes, 0);\n+        }\n+\n+        testHelper.SetTiering(\"/Root/olapStore/olapTable\", tieringRule);\n+        csController->WaitActualization(TDuration::Seconds(5));\n+\n+        {\n+            auto selectQuery = TString(R\"(\n+                SELECT\n+                    TierName, SUM(ColumnRawBytes) As RawBytes\n+                FROM `/Root/olapStore/olapTable/.sys/primary_index_portion_stats`\n+                WHERE Activity == 1\n+                GROUP BY TierName\n+            )\");\n+\n+            auto rows = ExecuteScanQuery(tableClient, selectQuery);\n+            UNIT_ASSERT_VALUES_EQUAL(rows.size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(GetUtf8(rows[0].at(\"TierName\")), \"tier1\");\n+            UNIT_ASSERT_VALUES_EQUAL_C(GetUint64(rows[0].at(\"RawBytes\")), columnRawBytes,\n+                TStringBuilder() << \"RawBytes changed after eviction: before=\" << columnRawBytes\n+                                 << \" after=\" << GetUint64(rows[0].at(\"RawBytes\")));\n+        }\n+\n+        testHelper.ResetTiering(\"/Root/olapStore/olapTable\");\n+        csController->WaitCompactions(TDuration::Seconds(5));\n+\n+        {\n+            auto selectQuery = TString(R\"(\n+                SELECT\n+                    TierName, SUM(ColumnRawBytes) As RawBytes\n+                FROM `/Root/olapStore/olapTable/.sys/primary_index_portion_stats`\n+                WHERE Activity == 1\n+                GROUP BY TierName\n+            )\");\n+\n+            auto rows = ExecuteScanQuery(tableClient, selectQuery);\n+            UNIT_ASSERT_VALUES_EQUAL(rows.size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(GetUtf8(rows[0].at(\"TierName\")), \"__DEFAULT\");\n+            UNIT_ASSERT_VALUES_EQUAL_C(GetUint64(rows[0].at(\"RawBytes\")), columnRawBytes,\n+                TStringBuilder() << \"RawBytes changed after resetting tiering: before=\" << columnRawBytes\n+                                 << \" after=\" << GetUint64(rows[0].at(\"RawBytes\")));\n+        }\n+    }\n+\n+    Y_UNIT_TEST(TieringRuleValidation) {\n+        auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n+\n+        TKikimrSettings runnerSettings;\n+        runnerSettings.WithSampleTables = false;\n+        TTestHelper testHelper(runnerSettings);\n+        TLocalHelper localHelper(testHelper.GetKikimr());\n+        NYdb::NTable::TTableClient tableClient = testHelper.GetKikimr().GetTableClient();\n+        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();\n+        Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->SetSecretKey(\"fakeSecret\");\n+\n+        localHelper.CreateTestOlapTable();\n+        testHelper.CreateTier(\"tier1\");\n+\n+        {\n+            const TString query = R\"(\n+            CREATE OBJECT IF NOT EXISTS empty_tiering_rule (TYPE TIERING_RULE)\n+                WITH (defaultColumn = timestamp, description = `{\"rules\": []}`))\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+\n+        {\n+            const TString query = R\"(\n+            CREATE OBJECT IF NOT EXISTS empty_default_column (TYPE TIERING_RULE)\n+                WITH (defaultColumn = ``, description = `{\"rules\": [{ \"tierName\" : \"tier1\", \"durationForEvict\" : \"10d\" }]}`))\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+\n+        {\n+            const TString query = R\"(\n+            CREATE OBJECT IF NOT EXISTS no_default_column (TYPE TIERING_RULE)\n+                WITH (description = `{\"rules\": [{ \"tierName\" : \"tier1\", \"durationForEvict\" : \"10d\" }]}`))\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+\n+        const TString correctTieringRule = testHelper.CreateTieringRule(\"tier1\", \"timestamp\");\n+        {\n+            const TString query = \"ALTER OBJECT \" + correctTieringRule + R\"( (TYPE TIERING_RULE) SET description `{\"rules\": []}`)\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+\n+        {\n+            const TString query = \"ALTER OBJECT \" + correctTieringRule + R\"( (TYPE TIERING_RULE) SET description `{\"rules\": []}`)\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+\n+        {\n+            const TString query = \"ALTER OBJECT \" + correctTieringRule + R\"( (TYPE TIERING_RULE) SET defaultColumn ``)\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+\n+        {\n+            const TString query = \"ALTER OBJECT \" + correctTieringRule + R\"( (TYPE TIERING_RULE) RESET defaultColumn)\";\n+            auto result = testHelper.GetSession().ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_UNEQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+        }\n+    }\n+}\n+\n+}   // namespace NKikimr::NKqp\ndiff --git a/ydb/core/kqp/ut/olap/write_ut.cpp b/ydb/core/kqp/ut/olap/write_ut.cpp\nindex ac63da37bc72..8d9751f28193 100644\n--- a/ydb/core/kqp/ut/olap/write_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/write_ut.cpp\n@@ -15,7 +15,7 @@ Y_UNIT_TEST_SUITE(KqpOlapWrite) {\n     Y_UNIT_TEST(TierDraftsGC) {\n         auto csController = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NKikimr::NYDBTest::NColumnShard::TController>();\n         csController->SetIndexWriteControllerEnabled(false);\n-        csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n         Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->ResetWriteCounters();\n \n         auto settings = TKikimrSettings()\n@@ -47,10 +47,31 @@ Y_UNIT_TEST_SUITE(KqpOlapWrite) {\n         AFL_VERIFY(!Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->GetSize());\n     }\n \n+    Y_UNIT_TEST(TestRemoveTableBeforeIndexation) {\n+        auto csController = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NKikimr::NYDBTest::NColumnShard::TController>();\n+        csController->SetIndexWriteControllerEnabled(false);\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+        csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+\n+        auto settings = TKikimrSettings().SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        TLocalHelper(kikimr).CreateTestOlapTable();\n+        Tests::NCommon::TLoggerInit(kikimr).SetComponents({ NKikimrServices::TX_COLUMNSHARD }, \"CS\").SetPriority(NActors::NLog::PRI_DEBUG).Initialize();\n+        auto tableClient = kikimr.GetTableClient();\n+\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 30000, 1000000, 11000);\n+        TTypedLocalHelper(\"Utf8\", kikimr).ExecuteSchemeQuery(\"DROP TABLE `/Root/olapStore/olapTable`;\");\n+        csController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+        csController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+        csController->WaitIndexation(TDuration::Seconds(5));\n+        csController->WaitCompactions(TDuration::Seconds(5));\n+    }\n+\n     Y_UNIT_TEST(TierDraftsGCWithRestart) {\n         auto csController = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NKikimr::NYDBTest::NColumnShard::TController>();\n         csController->SetIndexWriteControllerEnabled(false);\n-        csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1000));\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1000));\n         csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::GC);\n         Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->ResetWriteCounters();\n \n@@ -133,7 +154,7 @@ Y_UNIT_TEST_SUITE(KqpOlapWrite) {\n \n     Y_UNIT_TEST(WriteDeleteCleanGC) {\n         auto csController = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NKikimr::NYDBTest::NColumnShard::TController>();\n-        csController->SetPeriodicWakeupActivationPeriod(TDuration::MilliSeconds(100));\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::MilliSeconds(100));\n         csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::GC);\n         Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->ResetWriteCounters();\n \n@@ -176,7 +197,7 @@ Y_UNIT_TEST_SUITE(KqpOlapWrite) {\n             )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n         }\n-        csController->SetReadTimeoutClean(TDuration::Zero());\n+        csController->SetOverrideReadTimeoutClean(TDuration::Zero());\n         csController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::GC);\n         {\n             const TInstant start = TInstant::Now();\ndiff --git a/ydb/core/kqp/ut/olap/ya.make b/ydb/core/kqp/ut/olap/ya.make\nindex d9b7a06ef77b..e324116597eb 100644\n--- a/ydb/core/kqp/ut/olap/ya.make\n+++ b/ydb/core/kqp/ut/olap/ya.make\n@@ -1,7 +1,7 @@\n UNITTEST_FOR(ydb/core/kqp)\n \n FORK_SUBTESTS()\n-SPLIT_FACTOR(100)\n+SPLIT_FACTOR(200)\n \n IF (WITH_VALGRIND)\n     TIMEOUT(3600)\n@@ -23,6 +23,9 @@ SRCS(\n     clickbench_ut.cpp\n     aggregations_ut.cpp\n     write_ut.cpp\n+    sparsed_ut.cpp\n+    tiering_ut.cpp\n+    decimal_ut.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/core/kqp/ut/query/kqp_query_ut.cpp b/ydb/core/kqp/ut/query/kqp_query_ut.cpp\nindex 6c11b9e2e7bb..15e018470b43 100644\n--- a/ydb/core/kqp/ut/query/kqp_query_ut.cpp\n+++ b/ydb/core/kqp/ut/query/kqp_query_ut.cpp\n@@ -1576,7 +1576,7 @@ Y_UNIT_TEST_SUITE(KqpQuery) {\n             )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT(!prepareResult.IsSuccess());\n             UNIT_ASSERT_C(\n-                prepareResult.GetIssues().ToString().Contains(\"Query can be executed only in per-statement mode (NoTx)\"),\n+                prepareResult.GetIssues().ToString().Contains(\"CTAS statement can be executed only in NoTx mode.\"),\n                 prepareResult.GetIssues().ToString());\n         }\n \n@@ -1782,6 +1782,96 @@ Y_UNIT_TEST_SUITE(KqpQuery) {\n             CompareYson(output, R\"([[1u;[1];[\"test1\"]];[100u;[100];[\"test2\"]]])\");\n         }\n     }\n+\n+    Y_UNIT_TEST_TWIN(TableSink_ReplaceDataShardDataQuery, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(UseSink);\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(appConfig)\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        auto session = kikimr.GetTableClient().CreateSession().GetValueSync().GetSession();\n+\n+        const TString query = R\"(\n+            CREATE TABLE `/Root/DataShard` (\n+                Col1 Uint32 NOT NULL,\n+                Col2 String,\n+                Col3 Int32 NOT NULL,\n+                PRIMARY KEY (Col1)\n+            )\n+            WITH (\n+                AUTO_PARTITIONING_BY_SIZE = DISABLED,\n+                AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 16,\n+                AUTO_PARTITIONING_MAX_PARTITIONS_COUNT = 16,\n+                UNIFORM_PARTITIONS = 16);\n+\n+            CREATE TABLE `/Root/DataShard2` (\n+                Col1 Uint32 NOT NULL,\n+                Col2 String,\n+                Col3 Int32 NOT NULL,\n+                PRIMARY KEY (Col1)\n+            )\n+            WITH (\n+                AUTO_PARTITIONING_BY_SIZE = DISABLED,\n+                AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 17,\n+                AUTO_PARTITIONING_MAX_PARTITIONS_COUNT = 17,\n+                UNIFORM_PARTITIONS = 17);\n+        )\";\n+\n+        auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n+        UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+        {\n+            auto prepareResult = session.ExecuteDataQuery(R\"(\n+                REPLACE INTO `/Root/DataShard` (Col1, Col2, Col3) VALUES\n+                    (10u, \"test1\", 10), (20u, \"test2\", 11), (2147483647u, \"test3\", 12), (2147483640u, NULL, 13);\n+            )\", NYdb::NTable::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(prepareResult.IsSuccess(), prepareResult.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto it = session.ExecuteDataQuery(R\"(\n+                SELECT COUNT(*) FROM `/Root/DataShard`;\n+            )\", NYdb::NTable::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString());\n+            CompareYson(R\"([[4u]])\", FormatResultSetYson(it.GetResultSet(0)));\n+        }\n+\n+        {\n+            auto prepareResult = session.ExecuteDataQuery(R\"(\n+                REPLACE INTO `/Root/DataShard2` SELECT * FROM `/Root/DataShard`;\n+            )\", NYdb::NTable::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(prepareResult.IsSuccess(), prepareResult.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto it = session.ExecuteDataQuery(R\"(\n+                SELECT COUNT(*) FROM `/Root/DataShard2`;\n+            )\", NYdb::NTable::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString());\n+            CompareYson(R\"([[4u]])\", FormatResultSetYson(it.GetResultSet(0)));\n+        }\n+\n+        {\n+            auto prepareResult = session.ExecuteDataQuery(R\"(\n+                REPLACE INTO `/Root/DataShard2` (Col1, Col2, Col3) VALUES\n+                    (11u, \"test1\", 10), (21u, \"test2\", 11), (2147483646u, \"test3\", 12), (2147483641u, NULL, 13);\n+                SELECT COUNT(*) FROM `/Root/DataShard`;\n+            )\", NYdb::NTable::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(prepareResult.IsSuccess(), prepareResult.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto it = session.ExecuteDataQuery(R\"(\n+                SELECT COUNT(*) FROM `/Root/DataShard2`;\n+            )\", NYdb::NTable::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString());\n+            CompareYson(R\"([[8u]])\", FormatResultSetYson(it.GetResultSet(0)));\n+        }\n+    }\n }\n \n } // namespace NKqp\ndiff --git a/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp b/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp\nindex 70d51fb73472..a9e7125dc601 100644\n--- a/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp\n+++ b/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp\n@@ -2,6 +2,7 @@\n #include <ydb/core/kqp/ut/common/columnshard.h>\n #include <ydb/core/kqp/workload_service/ut/common/kqp_workload_service_ut_common.h>\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+#include <ydb/core/tx/columnshard/test_helper/controllers.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n #include <ydb/core/tx/tx_proxy/proxy.h>\n #include <ydb/public/sdk/cpp/client/draft/ydb_replication.h>\n@@ -6543,6 +6544,7 @@ Y_UNIT_TEST_SUITE(KqpOlapScheme) {\n         }\n         testHelper.DropTable(\"/Root/ColumnTableTest\");\n         for (auto tablet: tabletIds) {\n+            testHelper.WaitTabletDeletionInHive(tablet, TDuration::Seconds(5));\n             UNIT_ASSERT_C(!testHelper.GetKikimr().GetTestClient().TabletExistsInHive(&testHelper.GetRuntime(), tablet), ToString(tablet) + \" is alive\");\n         }\n     }\n@@ -7251,6 +7253,87 @@ Y_UNIT_TEST_SUITE(KqpOlapScheme) {\n         testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[1;#;[\\\"test_res_1\\\"]]]\");\n     }\n \n+    void TestDropThenAddColumn(bool enableIndexation, bool enableCompaction) {\n+        if (enableCompaction) {\n+            Y_ABORT_UNLESS(enableIndexation);\n+        }\n+\n+        auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n+        csController->DisableBackground(NYDBTest::ICSController::EBackground::Indexation);\n+        csController->DisableBackground(NYDBTest::ICSController::EBackground::Compaction);\n+\n+        TKikimrSettings runnerSettings;\n+        runnerSettings.WithSampleTables = false;\n+        TTestHelper testHelper(runnerSettings);\n+\n+        TVector<TTestHelper::TColumnSchema> schema = {\n+            TTestHelper::TColumnSchema().SetName(\"id\").SetType(NScheme::NTypeIds::Int32).SetNullable(false),\n+            TTestHelper::TColumnSchema().SetName(\"value\").SetType(NScheme::NTypeIds::Utf8),\n+        };\n+\n+        TTestHelper::TColumnTable testTable;\n+        testTable.SetName(\"/Root/ColumnTableTest\").SetPrimaryKey({ \"id\" }).SetSharding({ \"id\" }).SetSchema(schema);\n+        testHelper.CreateTable(testTable);\n+\n+        {\n+            TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));\n+            tableInserter.AddRow().Add(1).Add(\"test_res_1\");\n+            tableInserter.AddRow().Add(2).Add(\"test_res_2\");\n+            testHelper.BulkUpsert(testTable, tableInserter);\n+        }\n+\n+        if (enableCompaction) {\n+            csController->EnableBackground(NYDBTest::ICSController::EBackground::Indexation);\n+            csController->EnableBackground(NYDBTest::ICSController::EBackground::Compaction);\n+            csController->WaitIndexation(TDuration::Seconds(5));\n+            csController->WaitCompactions(TDuration::Seconds(5));\n+            csController->DisableBackground(NYDBTest::ICSController::EBackground::Indexation);\n+            csController->DisableBackground(NYDBTest::ICSController::EBackground::Compaction);\n+        }\n+\n+        {\n+            auto alterQuery = TStringBuilder() << \"ALTER TABLE `\" << testTable.GetName() << \"` DROP COLUMN value;\";\n+            auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+        }\n+        {\n+            auto alterQuery = TStringBuilder() << \"ALTER TABLE `\" << testTable.GetName() << \"` ADD COLUMN value Uint64;\";\n+            auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+        }\n+        schema.back().SetType(NScheme::NTypeIds::Uint64);\n+\n+        {\n+            TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));\n+            tableInserter.AddRow().Add(3).Add(42);\n+            tableInserter.AddRow().Add(4).Add(43);\n+            testHelper.BulkUpsert(testTable, tableInserter);\n+        }\n+\n+        if (enableIndexation) {\n+            csController->EnableBackground(NYDBTest::ICSController::EBackground::Indexation);\n+            csController->WaitIndexation(TDuration::Seconds(5));\n+        }\n+        if (enableCompaction) {\n+            csController->EnableBackground(NYDBTest::ICSController::EBackground::Compaction);\n+            csController->WaitCompactions(TDuration::Seconds(5));\n+        }\n+\n+        testHelper.ReadData(\"SELECT value FROM `/Root/ColumnTableTest`\", \"[[#];[#];[[42u]];[[43u]]]\");\n+    }\n+\n+    Y_UNIT_TEST(DropThenAddColumn) {\n+        TestDropThenAddColumn(false, false);\n+    }\n+\n+    Y_UNIT_TEST(DropThenAddColumnIndexation) {\n+        TestDropThenAddColumn(true, true);\n+    }\n+\n+    Y_UNIT_TEST(DropThenAddColumnCompaction) {\n+        TestDropThenAddColumn(true, true);\n+    }\n+\n     Y_UNIT_TEST(DropTtlColumn) {\n         TKikimrSettings runnerSettings;\n         runnerSettings.WithSampleTables = false;\ndiff --git a/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp b/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp\nindex f6b812e2f5dc..83e04c5d3d9c 100644\n--- a/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp\n+++ b/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp\n@@ -2568,6 +2568,87 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n         }\n     }\n \n+    Y_UNIT_TEST(CTASWithoutPerStatement) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n+        appConfig.MutableTableServiceConfig()->SetEnableCreateTableAs(true);\n+        appConfig.MutableTableServiceConfig()->SetEnablePreparedDdl(true);\n+        appConfig.MutableTableServiceConfig()->SetEnableAstCache(false);\n+        appConfig.MutableTableServiceConfig()->SetEnablePerStatementQueryExecution(false);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetAppConfig(appConfig)\n+            .SetKqpSettings({setting})\n+            .SetWithSampleTables(false)\n+            .SetEnableTempTables(true);\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        auto db = kikimr.GetQueryClient();\n+\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+                CREATE TABLE Table1 (\n+                    PRIMARY KEY (Key)\n+                ) AS SELECT 1u AS Key, \"1\" AS Value1, \"1\" AS Value2;\n+                CREATE TABLE Table2 (\n+                    PRIMARY KEY (Key)\n+                ) AS SELECT 2u AS Key, \"2\" AS Value1, \"2\" AS Value2;\n+                )\", TTxControl::NoTx(), TExecuteQuerySettings()).ExtractValueSync();\n+\n+            UNIT_ASSERT(!result.IsSuccess());\n+            UNIT_ASSERT_C(\n+                result.GetIssues().ToString().Contains(\"Several CTAS statement can't be used without per-statement mode.\"),\n+                result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+                CREATE TABLE Table2 (\n+                    PRIMARY KEY (Key)\n+                ) AS SELECT 2u AS Key, \"2\" AS Value1, \"2\" AS Value2;\n+                SELECT * FROM Table1 ORDER BY Key;\n+                )\", TTxControl::NoTx(), TExecuteQuerySettings()).ExtractValueSync();\n+\n+            UNIT_ASSERT(!result.IsSuccess());\n+            UNIT_ASSERT_C(\n+                result.GetIssues().ToString().Contains(\"CTAS statement can't be used with other statements without per-statement mode.\"),\n+                result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+            SELECT * FROM Table1 ORDER BY Key;\n+                CREATE TABLE Table2 (\n+                    PRIMARY KEY (Key)\n+                ) AS SELECT 2u AS Key, \"2\" AS Value1, \"2\" AS Value2;\n+                )\", TTxControl::NoTx(), TExecuteQuerySettings()).ExtractValueSync();\n+\n+            UNIT_ASSERT(!result.IsSuccess());\n+            UNIT_ASSERT_C(\n+                result.GetIssues().ToString().Contains(\"CTAS statement can't be used with other statements without per-statement mode.\"),\n+                result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+                CREATE TABLE Table1 (\n+                    PRIMARY KEY (Key)\n+                ) AS SELECT 1u AS Key, \"1\" AS Value1, \"1\" AS Value2;\n+                )\", TTxControl::NoTx(), TExecuteQuerySettings()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+                SELECT * FROM Table1 ORDER BY Key;\n+            )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetResultSets().size(), 1);\n+            CompareYson(R\"([[[1u];[\"1\"];[\"1\"]]])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    }\n+\n     Y_UNIT_TEST(SeveralCTAS) {\n         NKikimrConfig::TAppConfig appConfig;\n         appConfig.MutableTableServiceConfig()->SetEnablePreparedDdl(true);\n@@ -2960,7 +3041,7 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n         CompareYson(output, R\"([[1u;\"test1\";[10];[\"1\"]];[2u;\"test2\";#;[\"2\"]];[3u;\"test3\";[12];#];[4u;\"test4\";#;#];[100u;\"test100\";[1000];[\"100\"]]])\");\n     }\n \n-    Y_UNIT_TEST(TableSink_OltpReplace) {\n+    Y_UNIT_TEST_TWIN(TableSink_OltpReplace, HasSecondaryIndex) {\n         NKikimrConfig::TAppConfig appConfig;\n         appConfig.MutableTableServiceConfig()->SetEnableOltpSink(true);\n         auto settings = TKikimrSettings()\n@@ -2972,14 +3053,15 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n \n         auto session = kikimr.GetTableClient().CreateSession().GetValueSync().GetSession();\n \n-        const TString query = R\"(\n+        const TString query = Sprintf(R\"(\n             CREATE TABLE `/Root/DataShard` (\n                 Col1 Uint64 NOT NULL,\n                 Col2 Int32,\n                 Col3 String,\n+                %s\n                 PRIMARY KEY (Col1)\n             );\n-        )\";\n+        )\", (HasSecondaryIndex ? \"INDEX idx_2 GLOBAL ON (Col2),\" : \"\"));\n \n         auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n         UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n@@ -3042,8 +3124,8 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n             auto session = Kikimr->GetTableClient().CreateSession().GetValueSync().GetSession();\n \n             auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n-            csController->SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n-            csController->SetLagForCompactionBeforeTierings(TDuration::Seconds(1));\n+            csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+            csController->SetOverrideLagForCompactionBeforeTierings(TDuration::Seconds(1));\n             csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n \n             const TString query = Sprintf(R\"(\n@@ -3592,7 +3674,7 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n \n         {\n             auto it = client.StreamExecuteQuery(R\"sql(\n-                SELECT * FROM `/Root/ColumnShard`;\n+                SELECT * FROM `/Root/ColumnShard` ORDER BY Col1;\n             )sql\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString());\n             TString output = StreamResultToYson(it);\n@@ -3605,7 +3687,8 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n             auto it = client.StreamExecuteQuery(R\"sql(\n                 SELECT * FROM `/Root/DataShard`\n                 UNION ALL\n-                SELECT * FROM `/Root/ColumnShard`;\n+                SELECT * FROM `/Root/ColumnShard`\n+                ORDER BY Col1;\n             )sql\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString());\n             TString output = StreamResultToYson(it);\n@@ -3616,8 +3699,9 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n \n         {\n             auto it = client.StreamExecuteQuery(R\"sql(\n-                SELECT r.Col3, c.Col3 FROM `/Root/DataShard` AS r\n-                JOIN `/Root/ColumnShard` AS c ON r.Col1 + 1 = c.Col1;\n+                SELECT r.Col3 AS a, c.Col3 AS b FROM `/Root/DataShard` AS r\n+                JOIN `/Root/ColumnShard` AS c ON r.Col1 + 1 = c.Col1\n+                ORDER BY a;\n             )sql\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL_C(it.GetStatus(), EStatus::SUCCESS, it.GetIssues().ToString());\n             TString output = StreamResultToYson(it);\n@@ -3910,6 +3994,46 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n             UNIT_ASSERT_VALUES_EQUAL(alterResult.GetStatus(), EStatus::SUCCESS);\n         }\n     }\n+\n+    Y_UNIT_TEST(TableSink_OlapRWQueries) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(appConfig)\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        auto session = kikimr.GetTableClient().CreateSession().GetValueSync().GetSession();\n+\n+        const TString query = R\"(\n+            CREATE TABLE `/Root/ColumnShard` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 String,\n+                Col3 Int32 NOT NULL,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 3);\n+        )\";\n+\n+        auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n+        UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+        auto client = kikimr.GetQueryClient();\n+        {\n+            auto result = client.ExecuteQuery(R\"(\n+                REPLACE INTO `/Root/ColumnShard` (Col1, Col2, Col3) VALUES\n+                    (1u, \"test1\", 10), (2u, \"test2\", 11), (3u, \"test3\", 12), (4u, NULL, 13);\n+                SELECT * FROM `/Root/ColumnShard` ORDER BY Col1;\n+                INSERT INTO `/Root/ColumnShard` SELECT Col1 + 100 AS Col1, Col2, Col3 FROM `/Root/ColumnShard`;\n+                SELECT * FROM `/Root/ColumnShard` ORDER BY Col1;\n+            )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+            CompareYson(R\"([[1u;[\"test1\"];10];[2u;[\"test2\"];11];[3u;[\"test3\"];12];[4u;#;13]])\", FormatResultSetYson(result.GetResultSet(0)));\n+            CompareYson(R\"([[1u;[\"test1\"];10];[2u;[\"test2\"];11];[3u;[\"test3\"];12];[4u;#;13];[101u;[\"test1\"];10];[102u;[\"test2\"];11];[103u;[\"test3\"];12];[104u;#;13]])\", FormatResultSetYson(result.GetResultSet(1)));\n+        }\n+    }\n }\n \n } // namespace NKqp\ndiff --git a/ydb/core/kqp/ut/tx/kqp_locks_tricky_ut.cpp b/ydb/core/kqp/ut/tx/kqp_locks_tricky_ut.cpp\nindex 780fdf977c3c..9ac7d3fabee7 100644\n--- a/ydb/core/kqp/ut/tx/kqp_locks_tricky_ut.cpp\n+++ b/ydb/core/kqp/ut/tx/kqp_locks_tricky_ut.cpp\n@@ -29,9 +29,13 @@ using NYql::TExprNode;\n \n Y_UNIT_TEST_SUITE(KqpLocksTricky) {\n \n-    Y_UNIT_TEST(TestNoLocksIssue) {\n+    Y_UNIT_TEST_TWIN(TestNoLocksIssue, withSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n+\n         auto setting = NKikimrKqp::TKqpSetting();\n         TKikimrSettings settings;\n+        settings.SetAppConfig(appConfig);\n         settings.SetUseRealThreads(false);\n         TKikimrRunner kikimr(settings);\n         auto db = kikimr.GetTableClient();\n@@ -123,9 +127,13 @@ Y_UNIT_TEST_SUITE(KqpLocksTricky) {\n         }\n     }\n \n-    Y_UNIT_TEST(TestNoLocksIssueInteractiveTx) {\n+    Y_UNIT_TEST_TWIN(TestNoLocksIssueInteractiveTx, withSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n+\n         auto setting = NKikimrKqp::TKqpSetting();\n         TKikimrSettings settings;\n+        settings.SetAppConfig(appConfig);\n         settings.SetUseRealThreads(false);\n         TKikimrRunner kikimr(settings);\n         auto db = kikimr.GetTableClient();\ndiff --git a/ydb/core/kqp/ut/tx/kqp_mvcc_ut.cpp b/ydb/core/kqp/ut/tx/kqp_mvcc_ut.cpp\nindex a39c839e6ee2..f4eb9ee7a9ce 100644\n--- a/ydb/core/kqp/ut/tx/kqp_mvcc_ut.cpp\n+++ b/ydb/core/kqp/ut/tx/kqp_mvcc_ut.cpp\n@@ -9,9 +9,12 @@ using namespace NYdb;\n using namespace NYdb::NTable;\n \n Y_UNIT_TEST_SUITE(KqpSnapshotRead) {\n-    Y_UNIT_TEST(TestSnapshotExpiration) {\n+    Y_UNIT_TEST_TWIN(TestSnapshotExpiration, withSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n         auto settings = TKikimrSettings()\n-            .SetKeepSnapshotTimeout(TDuration::Seconds(1));\n+            .SetKeepSnapshotTimeout(TDuration::Seconds(1))\n+            .SetAppConfig(appConfig);\n \n         TKikimrRunner kikimr(settings);\n \n@@ -63,8 +66,9 @@ Y_UNIT_TEST_SUITE(KqpSnapshotRead) {\n         UNIT_ASSERT_C(caught, \"Failed to wait for snapshot expiration.\");\n     }\n \n-    Y_UNIT_TEST(ReadOnlyTxCommitsOnConcurrentWrite) {\n+    Y_UNIT_TEST_TWIN(ReadOnlyTxCommitsOnConcurrentWrite, withSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n         appConfig.MutableTableServiceConfig()->SetEnableKqpDataQueryStreamLookup(true);\n         TKikimrRunner kikimr(TKikimrSettings()\n             .SetAppConfig(appConfig)\n@@ -125,8 +129,13 @@ Y_UNIT_TEST_SUITE(KqpSnapshotRead) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(ReadOnlyTxWithIndexCommitsOnConcurrentWrite) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(ReadOnlyTxWithIndexCommitsOnConcurrentWrite, withSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n+        TKikimrRunner kikimr(\n+            TKikimrSettings()\n+                .SetAppConfig(appConfig)\n+        );\n \n //        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_COMPUTE, NActors::NLog::PRI_DEBUG);\n //        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_BLOBS_STORAGE, NActors::NLog::PRI_DEBUG);\n@@ -186,8 +195,13 @@ Y_UNIT_TEST_SUITE(KqpSnapshotRead) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(ReadWriteTxFailsOnConcurrentWrite1) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(ReadWriteTxFailsOnConcurrentWrite1, withSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n+        TKikimrRunner kikimr(\n+            TKikimrSettings()\n+                .SetAppConfig(appConfig)\n+        );\n \n //        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_COMPUTE, NActors::NLog::PRI_DEBUG);\n //        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_BLOBS_STORAGE, NActors::NLog::PRI_DEBUG);\n@@ -223,8 +237,13 @@ Y_UNIT_TEST_SUITE(KqpSnapshotRead) {\n         UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED), result.GetIssues().ToString());\n     }\n \n-    Y_UNIT_TEST(ReadWriteTxFailsOnConcurrentWrite2) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(ReadWriteTxFailsOnConcurrentWrite2, withSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n+        TKikimrRunner kikimr(\n+            TKikimrSettings()\n+                .SetAppConfig(appConfig)\n+        );\n \n //        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_COMPUTE, NActors::NLog::PRI_DEBUG);\n //        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_BLOBS_STORAGE, NActors::NLog::PRI_DEBUG);\n@@ -266,8 +285,9 @@ Y_UNIT_TEST_SUITE(KqpSnapshotRead) {\n         UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED), result.GetIssues().ToString());\n     }\n \n-    Y_UNIT_TEST(ReadWriteTxFailsOnConcurrentWrite3) {\n+    Y_UNIT_TEST_TWIN(ReadWriteTxFailsOnConcurrentWrite3, withSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(withSink);\n         appConfig.MutableTableServiceConfig()->SetEnableKqpDataQueryStreamLookup(true);\n         TKikimrRunner kikimr(\n             TKikimrSettings()\ndiff --git a/ydb/core/kqp/ut/tx/kqp_sink_common.h b/ydb/core/kqp/ut/tx/kqp_sink_common.h\nnew file mode 100644\nindex 000000000000..9dfcad60ed43\n--- /dev/null\n+++ b/ydb/core/kqp/ut/tx/kqp_sink_common.h\n@@ -0,0 +1,109 @@\n+#pragma once\n+\n+#include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n+#include <ydb/core/testlib/common_helper.h>\n+#include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+\n+\n+namespace NKikimr {\n+namespace NKqp {\n+\n+using namespace NYdb;\n+using namespace NYdb::NQuery;\n+\n+class TTableDataModificationTester {\n+protected:\n+    NKikimrConfig::TAppConfig AppConfig;\n+    std::unique_ptr<TKikimrRunner> Kikimr;\n+    YDB_ACCESSOR(bool, IsOlap, false);\n+    YDB_ACCESSOR(bool, FastSnapshotExpiration, false);\n+\n+    virtual void DoExecute() = 0;\n+public:\n+    void Execute() {\n+        AppConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n+        AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(true);\n+        AppConfig.MutableTableServiceConfig()->SetEnableKqpDataQueryStreamLookup(true);\n+        auto settings = TKikimrSettings().SetAppConfig(AppConfig).SetWithSampleTables(false);\n+        if (FastSnapshotExpiration) {\n+            settings.SetKeepSnapshotTimeout(TDuration::Seconds(1));\n+        }\n+\n+        Kikimr = std::make_unique<TKikimrRunner>(settings);\n+        Tests::NCommon::TLoggerInit(*Kikimr).Initialize();\n+\n+        auto client = Kikimr->GetQueryClient();\n+\n+        auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->SetOverrideLagForCompactionBeforeTierings(TDuration::Seconds(1));\n+        csController->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+\n+        {\n+            auto type = IsOlap ? \"COLUMN\" : \"ROW\";\n+            auto result = client.ExecuteQuery(Sprintf(R\"(\n+                CREATE TABLE `/Root/Test` (\n+                    Group Uint32 not null,\n+                    Name String not null,\n+                    Amount Uint64,\n+                    Comment String,\n+                    PRIMARY KEY (Group, Name)\n+                ) WITH (\n+                    STORE = %s,\n+                    AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 10\n+                );\n+\n+                CREATE TABLE `/Root/KV` (\n+                    Key Uint32 not null,\n+                    Value String,\n+                    PRIMARY KEY (Key)\n+                ) WITH (\n+                    STORE = %s,\n+                    AUTO_PARTITIONING_BY_SIZE = DISABLED,\n+                    AUTO_PARTITIONING_BY_LOAD = DISABLED,\n+                    AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 100,\n+                    UNIFORM_PARTITIONS = 100\n+                );\n+\n+                CREATE TABLE `/Root/KV2` (\n+                    Key Uint32 not null,\n+                    Value String,\n+                    PRIMARY KEY (Key)\n+                ) WITH (\n+                    STORE = %s,\n+                    AUTO_PARTITIONING_BY_SIZE = DISABLED,\n+                    AUTO_PARTITIONING_BY_LOAD = DISABLED,\n+                    AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 100,\n+                    UNIFORM_PARTITIONS = 100\n+                );\n+            )\", type, type, type), TTxControl::NoTx()).GetValueSync();\n+            UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = client.ExecuteQuery(R\"(\n+                REPLACE INTO `Test` (Group, Name, Amount, Comment) VALUES\n+                    (1u, \"Anna\", 3500ul, \"None\"),\n+                    (1u, \"Paul\", 300ul, \"None\"),\n+                    (2u, \"Tony\", 7200ul, \"None\");\n+                REPLACE INTO `KV` (Key, Value) VALUES\n+                    (1u, \"One\"),\n+                    (2u, \"Two\"),\n+                    (3u, \"Three\"),\n+                    (4000000001u, \"BigOne\"),\n+                    (4000000002u, \"BigTwo\"),\n+                    (4000000003u, \"BigThree\");\n+                )\", TTxControl::NoTx()).GetValueSync();\n+            UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+\n+        DoExecute();\n+        csController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+        csController->WaitIndexation(TDuration::Seconds(5));\n+    }\n+\n+};\n+\n+}\n+}\ndiff --git a/ydb/core/kqp/ut/tx/kqp_sink_locks_ut.cpp b/ydb/core/kqp/ut/tx/kqp_sink_locks_ut.cpp\nnew file mode 100644\nindex 000000000000..45428d86c8a7\n--- /dev/null\n+++ b/ydb/core/kqp/ut/tx/kqp_sink_locks_ut.cpp\n@@ -0,0 +1,337 @@\n+#include \"kqp_sink_common.h\"\n+\n+#include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n+#include <ydb/core/testlib/common_helper.h>\n+#include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+\n+namespace NKikimr {\n+namespace NKqp {\n+\n+using namespace NYdb;\n+using namespace NYdb::NQuery;\n+\n+Y_UNIT_TEST_SUITE(KqpSinkLocks) {\n+    class TInvalidate : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test`\n+                SELECT Group + 10U AS Group, Name, Amount, Comment ?? \"\" || \"Updated\" AS Comment\n+                FROM `/Root/Test`\n+                WHERE Group == 1U AND Name == \"Paul\";\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto tx1 = result.GetTransaction();\n+            UNIT_ASSERT(tx1);\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test` (Group, Name, Comment)\n+                VALUES (1U, \"Paul\", \"Changed\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test` (Group, Name, Comment)\n+                VALUES (11U, \"Sergey\", \"BadRow\");\n+            )\"), TTxControl::Tx(tx1->GetId()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            result.GetIssues().PrintTo(Cerr);\n+            if (!GetIsOlap()) {\n+                UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,\n+                    [] (const NYql::TIssue& issue) {\n+                        return issue.GetMessage().Contains(\"/Root/Test\");\n+                    }), result.GetIssues().ToString());\n+            }\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/Test` WHERE Name == \"Paul\" ORDER BY Group, Name;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([[[300u];[\"Changed\"];1u;\"Paul\"]])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(TInvalidate) {\n+        TInvalidate tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(TInvalidateOlap) {\n+        TInvalidate tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TInvalidateOnCommit : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test`\n+                SELECT Group + 10U AS Group, Name, Amount, Comment ?? \"\" || \"Updated\" AS Comment\n+                FROM `/Root/Test`\n+                WHERE Group == 1U AND Name == \"Paul\";\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto tx1 = result.GetTransaction();\n+            UNIT_ASSERT(tx1);\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test` (Group, Name, Comment)\n+                VALUES (1U, \"Paul\", \"Changed\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto commitResult = tx1->Commit().GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(commitResult.GetStatus(), EStatus::ABORTED, commitResult.GetIssues().ToString());\n+            commitResult.GetIssues().PrintTo(Cerr);\n+            if (!GetIsOlap()) {\n+                UNIT_ASSERT_C(HasIssue(commitResult.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,\n+                    [] (const NYql::TIssue& issue) {\n+                        return issue.GetMessage().Contains(\"/Root/Test\");\n+                    }), commitResult.GetIssues().ToString());\n+            }\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/Test` WHERE Name == \"Paul\" ORDER BY Group, Name;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([[[300u];[\"Changed\"];1u;\"Paul\"]])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(InvalidateOnCommit) {\n+        TInvalidateOnCommit tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(InvalidateOlapOnCommit) {\n+        TInvalidateOnCommit tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TDifferentKeyUpdate : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/Test` WHERE Group = 1;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+            UNIT_ASSERT(result.IsSuccess());\n+\n+            auto tx1 = result.GetTransaction();\n+            UNIT_ASSERT(tx1);\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test` (Group, Name, Comment)\n+                VALUES (2U, \"Paul\", \"Changed\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT(result.IsSuccess());\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT \"Nothing\";\n+            )\"), TTxControl::Tx(tx1->GetId()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+    };\n+\n+    Y_UNIT_TEST(DifferentKeyUpdate) {\n+        TDifferentKeyUpdate tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(DifferentKeyUpdateOlap) {\n+        TDifferentKeyUpdate tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TEmptyRange : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 11;\n+            )\"), TTxControl::BeginTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto tx1 = result.GetTransaction();\n+            UNIT_ASSERT(tx1);\n+\n+            result = session2.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 11;\n+                UPSERT INTO Test (Group, Name, Amount) VALUES\n+                    (11, \"Session2\", 2);\n+            )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session1.ExecuteQuery(Q1_(R\"(\n+                UPSERT INTO Test (Group, Name, Amount) VALUES\n+                    (11, \"Session1\", 1);\n+            )\"), TTxControl::Tx(tx1->GetId()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            result.GetIssues().PrintTo(Cerr);\n+            if (!GetIsOlap()) {\n+                UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,\n+                    [] (const NYql::TIssue& issue) {\n+                        return issue.GetMessage().Contains(\"/Root/Test\");\n+                    }), result.GetIssues().ToString());\n+            }\n+\n+            result = session1.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 11;\n+            )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([[[2u];#;11u;\"Session2\"]])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(EmptyRange) {\n+        TEmptyRange tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(EmptyRangeOlap) {\n+        TEmptyRange tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TEmptyRangeAlreadyBroken : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 10;\n+            )\"), TTxControl::BeginTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto tx1 = result.GetTransaction();\n+            UNIT_ASSERT(tx1);\n+\n+            result = session2.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 11;\n+\n+                UPSERT INTO Test (Group, Name, Amount) VALUES\n+                    (11, \"Session2\", 2);\n+            )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session1.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 11;\n+\n+                UPSERT INTO Test (Group, Name, Amount) VALUES\n+                    (11, \"Session1\", 1);\n+            )\"), TTxControl::Tx(tx1->GetId()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            result.GetIssues().PrintTo(Cerr);\n+            if (!GetIsOlap()) {\n+                UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,\n+                    [] (const NYql::TIssue& issue) {\n+                        return issue.GetMessage().Contains(\"/Root/Test\");\n+                    }), result.GetIssues().ToString());\n+            }\n+\n+            result = session1.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM Test WHERE Group = 11;\n+            )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([[[2u];#;11u;\"Session2\"]])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(EmptyRangeAlreadyBroken) {\n+        TEmptyRangeAlreadyBroken tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(EmptyRangeAlreadyBrokenOlap) {\n+        TEmptyRangeAlreadyBroken tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TUncommittedRead : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q1_(R\"(\n+                UPSERT INTO Test (Group, Name, Amount) VALUES\n+                    (11, \"TEST\", 2);\n+            )\"), TTxControl::BeginTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto tx1 = result.GetTransaction();\n+            UNIT_ASSERT(tx1);\n+\n+            {\n+                result = session2.ExecuteQuery(Q1_(R\"(\n+                    SELECT * FROM Test WHERE Group = 11;\n+                )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n+            }\n+\n+            {\n+                result = session1.ExecuteQuery(Q1_(R\"(\n+                    SELECT * FROM Test WHERE Group = 11;\n+                )\"), TTxControl::Tx(tx1->GetId())).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CompareYson(R\"([[[2u];#;11u;\"TEST\"]])\", FormatResultSetYson(result.GetResultSet(0)));\n+            }\n+        }\n+    };\n+\n+    Y_UNIT_TEST(UncommittedRead) {\n+        TUncommittedRead tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapUncommittedRead) {\n+        TUncommittedRead tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+}\n+\n+} // namespace NKqp\n+} // namespace NKikimr\ndiff --git a/ydb/core/kqp/ut/tx/kqp_sink_mvcc_ut.cpp b/ydb/core/kqp/ut/tx/kqp_sink_mvcc_ut.cpp\nnew file mode 100644\nindex 000000000000..a0ac82ad151d\n--- /dev/null\n+++ b/ydb/core/kqp/ut/tx/kqp_sink_mvcc_ut.cpp\n@@ -0,0 +1,307 @@\n+#include \"kqp_sink_common.h\"\n+\n+#include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n+#include <ydb/core/testlib/common_helper.h>\n+#include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+\n+namespace NKikimr {\n+namespace NKqp {\n+\n+using namespace NYdb;\n+using namespace NYdb::NQuery;\n+\n+Y_UNIT_TEST_SUITE(KqpSinkMvcc) {\n+    class TSnapshotExpiration : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u OR Key = 4000000001u ORDER BY Key;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"One\"]];\n+                [4000000001u;[\"BigOne\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto tx = result.GetTransaction();\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"ChangedOne\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto deadline = TInstant::Now() + TDuration::Seconds(30);\n+            auto caught = false;\n+            do {\n+                Sleep(TDuration::Seconds(1));\n+                auto result = session1.ExecuteQuery(Q_(R\"(\n+                    SELECT * FROM `/Root/KV` WHERE Key = 1u OR Key = 4000000001u;\n+                )\"), TTxControl::Tx(tx->GetId())).ExtractValueSync();\n+                if (result.GetStatus() == EStatus::SUCCESS)\n+                    continue;\n+\n+                UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR,\n+                    [](const NYql::TIssue& issue){\n+                        return issue.GetMessage().Contains(\"has no snapshot at\");\n+                    }), result.GetIssues().ToString());\n+\n+                UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::ABORTED);\n+\n+                caught = true;\n+                break;\n+            } while (TInstant::Now() < deadline);\n+            UNIT_ASSERT_C(caught, \"Failed to wait for snapshot expiration.\");\n+        }\n+    };\n+\n+    Y_UNIT_TEST(SnapshotExpiration) {\n+        TSnapshotExpiration tester;\n+        tester.SetFastSnapshotExpiration(true);\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+//     Y_UNIT_TEST(OlapSnapshotExpiration) {\n+//         TSnapshotExpiration tester;\n+//         tester.SetFastSnapshotExpiration(true);\n+//         tester.SetIsOlap(true);\n+//         tester.Execute();\n+//     }\n+\n+    class TReadOnlyTxCommitsOnConcurrentWrite : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u OR Key = 4000000001u ORDER BY Key;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+\n+            auto tx = result.GetTransaction();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"One\"]];\n+                [4000000001u;[\"BigOne\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"ChangedOne\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"ChangedOne\"]];\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u;\n+            )\"), TTxControl::Tx(tx->GetId())).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"One\"]];\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 2u OR Key = 4000000002u ORDER BY Key;\n+            )\"), TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CompareYson(R\"([\n+                [2u;[\"Two\"]];\n+                [4000000002u;[\"BigTwo\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(ReadOnlyTxCommitsOnConcurrentWrite) {\n+        TReadOnlyTxCommitsOnConcurrentWrite tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapReadOnlyTxCommitsOnConcurrentWrite) {\n+        TReadOnlyTxCommitsOnConcurrentWrite tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TReadWriteTxFailsOnConcurrentWrite1 : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u OR Key = 4000000001u ORDER BY Key;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+\n+            auto tx = result.GetTransaction();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"One\"]];\n+                [4000000001u;[\"BigOne\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"ChangedOne\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"TwiceChangedOne\");\n+            )\"), TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED), result.GetIssues().ToString());\n+        }\n+    };\n+\n+    Y_UNIT_TEST(ReadWriteTxFailsOnConcurrentWrite1) {\n+        TReadWriteTxFailsOnConcurrentWrite1 tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapReadWriteTxFailsOnConcurrentWrite1) {\n+        TReadWriteTxFailsOnConcurrentWrite1 tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TReadWriteTxFailsOnConcurrentWrite2 : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u OR Key = 4000000001u ORDER BY Key;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+\n+            auto tx = result.GetTransaction();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"One\"]];\n+                [4000000001u;[\"BigOne\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            // We need to sleep before the upsert below, otherwise writes\n+            // might happen in the same step as the snapshot, which would be\n+            // treated as happening before snapshot and will not break any locks.\n+            Sleep(TDuration::Seconds(2));\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV2` (Key, Value) VALUES (101u, \"SomeText\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                UPDATE `/Root/KV` SET Value = \"Something\" WHERE Key = 1u;\n+                UPDATE `/Root/KV2` SET Value = \"AnotherString\" WHERE Key = 101u;\n+            )\"), TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            if (!GetIsOlap()) {\n+                UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED), result.GetIssues().ToString());\n+            }\n+        }\n+    };\n+\n+    Y_UNIT_TEST(ReadWriteTxFailsOnConcurrentWrite2) {\n+        TReadWriteTxFailsOnConcurrentWrite2 tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapReadWriteTxFailsOnConcurrentWrite2) {\n+        TReadWriteTxFailsOnConcurrentWrite2 tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TReadWriteTxFailsOnConcurrentWrite3 : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session1 = client.GetSession().GetValueSync().GetSession();\n+            auto session2 = client.GetSession().GetValueSync().GetSession();\n+\n+            auto result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 1u OR Key = 4000000001u ORDER BY Key;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+\n+            auto tx = result.GetTransaction();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"One\"]];\n+                [4000000001u;[\"BigOne\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session2.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (2u, \"ChangedTwo\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key = 2u OR Key = 4000000002u ORDER BY Key;\n+            )\"), TTxControl::Tx(tx->GetId())).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CompareYson(R\"([\n+                [2u;[\"Two\"]];\n+                [4000000002u;[\"BigTwo\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session1.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (2u, \"TwiceChangedTwo\");\n+            )\"), TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();\n+\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED), result.GetIssues().ToString());\n+        }\n+    };\n+\n+    Y_UNIT_TEST(ReadWriteTxFailsOnConcurrentWrite3) {\n+        TReadWriteTxFailsOnConcurrentWrite3 tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapReadWriteTxFailsOnConcurrentWrite3) {\n+        TReadWriteTxFailsOnConcurrentWrite3 tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+}\n+\n+} // namespace NKqp\n+} // namespace NKikimr\ndiff --git a/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp b/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp\nnew file mode 100644\nindex 000000000000..4959cf240e05\n--- /dev/null\n+++ b/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp\n@@ -0,0 +1,404 @@\n+#include \"kqp_sink_common.h\"\n+\n+#include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n+#include <ydb/core/testlib/common_helper.h>\n+#include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+\n+namespace NKikimr {\n+namespace NKqp {\n+\n+using namespace NYdb;\n+using namespace NYdb::NQuery;\n+\n+Y_UNIT_TEST_SUITE(KqpSinkTx) {\n+    class TDeferredEffects : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            auto result = session.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/Test`\n+                SELECT Group, \"Sergey\" AS Name\n+                FROM `/Root/Test`;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto tx = result.GetTransaction();\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/Test` WHERE Group = 1 ORDER BY Name;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [[3500u];[\"None\"];1u;\"Anna\"];\n+                [[300u];[\"None\"];1u;\"Paul\"]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto commitResult = tx->Commit().ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(commitResult.GetStatus(), EStatus::SUCCESS, commitResult.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/Test` WHERE Group = 1 ORDER BY Name;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [[3500u];[\"None\"];1u;\"Anna\"];\n+                [[300u];[\"None\"];1u;\"Paul\"];\n+                [#;#;1u;\"Sergey\"]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(DeferredEffects) {\n+        TDeferredEffects tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapDeferredEffects) {\n+        TDeferredEffects tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TExplicitTcl : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            auto tx = session.BeginTransaction(TTxSettings::SerializableRW())\n+                .ExtractValueSync()\n+                .GetTransaction();\n+            UNIT_ASSERT(tx.IsActive());\n+\n+            auto result = session.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (10u, \"New\");\n+            )\"), TTxControl::Tx(tx.GetId())).ExtractValueSync();\n+            UNIT_ASSERT(result.IsSuccess());\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Value = \"New\";\n+            )\"), TTxControl::BeginTx(TTxSettings::OnlineRO()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT(result.IsSuccess());\n+            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto commitResult = tx.Commit().ExtractValueSync();\n+            UNIT_ASSERT_C(commitResult.IsSuccess(), commitResult.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Value = \"New\";\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT(result.IsSuccess());\n+            CompareYson(R\"([[10u;[\"New\"]]])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            commitResult = tx.Commit().ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(commitResult.GetStatus(), EStatus::NOT_FOUND, commitResult.GetIssues().ToString());\n+            UNIT_ASSERT_C(HasIssue(commitResult.GetIssues(), NYql::TIssuesIds::KIKIMR_TRANSACTION_NOT_FOUND), commitResult.GetIssues().ToString());\n+        }\n+    };\n+\n+    Y_UNIT_TEST(ExplicitTcl) {\n+        TExplicitTcl tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapExplicitTcl) {\n+        TExplicitTcl tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TLocksAbortOnCommit : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            {\n+                auto result = session.ExecuteQuery(Q_(R\"(\n+                    UPSERT INTO `/Root/KV` (Key, Value) VALUES (1, \"One\");\n+                    UPSERT INTO `/Root/KV` (Key, Value) VALUES (2, \"Two\");\n+                    UPSERT INTO `/Root/KV` (Key, Value) VALUES (3, \"Three\");\n+                    UPSERT INTO `/Root/KV` (Key, Value) VALUES (4, \"Four\");\n+                )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            }\n+\n+\n+            auto result = session.ExecuteQuery(Q_(R\"(\n+                SELECT * FROM `/Root/KV`;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto tx = result.GetTransaction();\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                UPDATE `/Root/KV` SET Value = \"second\" WHERE Key = 3;\n+            )\"), TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                UPDATE `/Root/KV` SET Value = \"third\" WHERE Key = 4;\n+            )\"), TTxControl::Tx(tx->GetId())).ExtractValueSync();\n+            if (GetIsOlap()) {\n+                // Olap has Reads in this query, so it breaks now.\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            } else {\n+                // Oltp doesn't have Reads in this query, so it breaks later.\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            }\n+\n+            auto commitResult = tx->Commit().ExtractValueSync();\n+\n+            if (GetIsOlap()) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(commitResult.GetStatus(), EStatus::NOT_FOUND, commitResult.GetIssues().ToString());\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(commitResult.GetStatus(), EStatus::ABORTED, commitResult.GetIssues().ToString());\n+            }\n+        }\n+    };\n+\n+    Y_UNIT_TEST(LocksAbortOnCommit) {\n+        TLocksAbortOnCommit tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapLocksAbortOnCommit) {\n+        TLocksAbortOnCommit tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TInvalidateOnError : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            auto tx = session.BeginTransaction(TTxSettings::SerializableRW())\n+                .ExtractValueSync()\n+                .GetTransaction();\n+            UNIT_ASSERT(tx.IsActive());\n+\n+            auto result = session.ExecuteQuery(Q_(R\"(\n+                INSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"New\");\n+            )\"), TTxControl::Tx(tx.GetId())).ExtractValueSync();\n+            result.GetIssues().PrintTo(Cerr);\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::BAD_REQUEST, result.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(Q_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"New\");\n+            )\"), TTxControl::Tx(tx.GetId())).ExtractValueSync();\n+            result.GetIssues().PrintTo(Cerr);\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::NOT_FOUND, result.GetIssues().ToString());\n+        }\n+    };\n+\n+    Y_UNIT_TEST(InvalidateOnError) {\n+        TInvalidateOnError tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapInvalidateOnError) {\n+        TInvalidateOnError tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TInteractive : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            auto tx = session.BeginTransaction(TTxSettings::SerializableRW())\n+                .ExtractValueSync()\n+                .GetTransaction();\n+            UNIT_ASSERT(tx.IsActive());\n+\n+            auto result = session.ExecuteQuery(R\"(\n+                SELECT * FROM `/Root/KV`\n+            )\", TTxControl::Tx(tx.GetId())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"New\");\n+            )\", TTxControl::Tx(tx.GetId()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(R\"(\n+                SELECT * FROM `/Root/KV` WHERE Key < 3 ORDER BY Key\n+            )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [1u;[\"New\"]];\n+                [2u;[\"Two\"]]\n+                ])\", FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(Interactive) {\n+        TInteractive tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapInteractive) {\n+        TInteractive tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TSnapshotRO : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            // Read Immediate\n+            auto result = session.ExecuteQuery(Q1_(R\"(\n+                SELECT * FROM KV WHERE Key = 2;\n+            )\"), TTxControl::BeginTx(TTxSettings::SnapshotRO()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([[2u;[\"Two\"]]])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            // Read Distributed\n+            result = session.ExecuteQuery(Q1_(R\"(\n+                SELECT COUNT(*) FROM KV WHERE Value = \"One\";\n+            )\"), TTxControl::BeginTx(TTxSettings::SnapshotRO()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([[1u]])\", FormatResultSetYson(result.GetResultSet(0)));\n+\n+            // Write\n+            result = session.ExecuteQuery(Q1_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES\n+                    (100, \"100500\"),\n+                    (100500, \"100\");\n+            )\"), TTxControl::BeginTx(TTxSettings::SnapshotRO()).CommitTx()).ExtractValueSync();\n+            result.GetIssues().PrintTo(Cerr);\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::GENERIC_ERROR);\n+            UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_OPERATION));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(SnapshotRO) {\n+        TSnapshotRO tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapSnapshotRO) {\n+        TSnapshotRO tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TSnapshotROInteractive1 : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            auto readQuery = Q1_(R\"(\n+                SELECT * FROM KV WHERE Key = 1u;\n+            )\");\n+\n+            auto readResult = R\"([\n+                [1u;[\"One\"]]\n+            ])\";\n+\n+            auto result = session.ExecuteQuery(readQuery,\n+                TTxControl::BeginTx(TTxSettings::SnapshotRO())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(readResult, FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto tx = result.GetTransaction();\n+            UNIT_ASSERT(tx);\n+            UNIT_ASSERT(tx->IsActive());\n+\n+            result = session.ExecuteQuery(Q1_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES\n+                    (1u, \"value\");\n+            )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(readQuery,\n+                TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(readResult, FormatResultSetYson(result.GetResultSet(0)));\n+        }\n+    };\n+\n+    Y_UNIT_TEST(SnapshotROInteractive1) {\n+        TSnapshotROInteractive1 tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapSnapshotROInteractive1) {\n+        TSnapshotROInteractive1 tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n+    class TSnapshotROInteractive2 : public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+            auto readQuery = Q1_(R\"(\n+                SELECT COUNT(*) FROM KV WHERE Value = \"One\";\n+            )\");\n+\n+            auto readResult = R\"([\n+                [1u]\n+            ])\";\n+\n+            auto tx = session.BeginTransaction(TTxSettings::SnapshotRO())\n+                .ExtractValueSync()\n+                .GetTransaction();\n+            UNIT_ASSERT(tx.IsActive());\n+\n+            auto result = session.ExecuteQuery(readQuery,\n+                TTxControl::Tx(tx.GetId())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(readResult, FormatResultSetYson(result.GetResultSet(0)));\n+\n+            result = session.ExecuteQuery(Q1_(R\"(\n+                UPSERT INTO `/Root/KV` (Key, Value) VALUES\n+                    (100500u, \"One\");\n+            )\"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            result = session.ExecuteQuery(readQuery,\n+                TTxControl::Tx(tx.GetId())).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(readResult, FormatResultSetYson(result.GetResultSet(0)));\n+\n+            auto commitResult = tx.Commit().ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(commitResult.GetStatus(), EStatus::SUCCESS, commitResult.GetIssues().ToString());\n+        }\n+    };\n+\n+    Y_UNIT_TEST(SnapshotROInteractive2) {\n+        TSnapshotROInteractive2 tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(OlapSnapshotROInteractive2) {\n+        TSnapshotROInteractive2 tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+}\n+\n+} // namespace NKqp\n+} // namespace NKikimr\ndiff --git a/ydb/core/kqp/ut/tx/ya.make b/ydb/core/kqp/ut/tx/ya.make\nindex 7f4ca5fae0d6..e7369a4a256e 100644\n--- a/ydb/core/kqp/ut/tx/ya.make\n+++ b/ydb/core/kqp/ut/tx/ya.make\n@@ -16,12 +16,16 @@ SRCS(\n     kqp_locks_tricky_ut.cpp\n     kqp_locks_ut.cpp\n     kqp_mvcc_ut.cpp\n+    kqp_sink_locks_ut.cpp\n+    kqp_sink_mvcc_ut.cpp\n+    kqp_sink_tx_ut.cpp\n     kqp_tx_ut.cpp\n )\n \n PEERDIR(\n     ydb/core/kqp\n     ydb/core/kqp/ut/common\n+    ydb/core/tx/columnshard/hooks/testing\n     ydb/library/yql/sql/pg_dummy\n )\n \ndiff --git a/ydb/core/protos/config.proto b/ydb/core/protos/config.proto\nindex c816ec4b3684..1bf74c929823 100644\n--- a/ydb/core/protos/config.proto\n+++ b/ydb/core/protos/config.proto\n@@ -597,6 +597,11 @@ message TLimiterConfig {\n     optional uint64 PeriodMilliSeconds = 3 [default = 1000];\n }\n \n+message TGroupedMemoryLimiterConfig {\n+    optional bool Enabled = 1 [default = true];\n+    optional uint64 MemoryLimit = 2;\n+}\n+\n message TExternalIndexConfig {\n     optional bool Enabled = 1 [default = true];\n     optional TInternalRequestConfig RequestConfig = 2;\n@@ -1530,7 +1535,6 @@ message TColumnShardConfig {\n \n     optional TIndexMetadataMemoryLimit IndexMetadataMemoryLimit = 12;\n     optional bool CleanupEnabled = 13 [default = true];\n-    optional uint32 RemovedPortionLivetimeSeconds = 14 [default = 600];\n \n     message TRepairInfo {\n         optional string ClassName = 1;\n@@ -1539,7 +1543,13 @@ message TColumnShardConfig {\n     repeated TRepairInfo Repairs = 15;\n \n     optional uint32 MaxInFlightIntervalsOnRequest = 16;\n-    optional uint32 MaxInFlightMemoryOnRequest = 17;\n+    optional uint32 MaxReadStaleness_ms = 18 [default = 300000];\n+    optional uint32 GCIntervalMs = 19 [default = 30000];\n+    optional uint32 CompactionActualizationLagMs = 20 [default = 1000];\n+    optional uint32 ActualizationTasksLagMs = 21 [default = 1000];\n+    optional uint32 LagForCompactionBeforeTieringsMs = 22 [default = 3600000];\n+    optional uint32 OptimizerFreshnessCheckDurationMs = 23 [default = 300000];\n+    optional uint32 SmallPortionDetectSizeLimit = 24 [default = 1048576];  // 1 << 20\n }\n \n message TSchemeShardConfig {\n@@ -1924,6 +1934,8 @@ message TAppConfig {\n     optional TBlobCacheConfig BlobCacheConfig = 78;\n     optional TLimiterConfig CompDiskLimiterConfig = 79;\n     optional TMetadataCacheConfig MetadataCacheConfig = 80;\n+    //optional TMemoryControllerConfig MemoryControllerConfig = 81; NB. exist in main\n+\toptional TGroupedMemoryLimiterConfig GroupedMemoryLimiterConfig = 82;\n     optional NKikimrReplication.TReplicationDefaults ReplicationConfig = 83;\n \n     repeated TNamedConfig NamedConfigs = 100;\ndiff --git a/ydb/core/protos/counters_columnshard.proto b/ydb/core/protos/counters_columnshard.proto\nindex cb1ecf21424a..898dac98aad6 100644\n--- a/ydb/core/protos/counters_columnshard.proto\n+++ b/ydb/core/protos/counters_columnshard.proto\n@@ -65,8 +65,8 @@ enum ECumulativeCounters {\n     COUNTER_PLAN_STEP_ACCEPTED = 9                          [(CounterOpts) = {Name: \"PlanStepAccepted\"}];\n     COUNTER_SCANNED_ROWS = 10                               [(CounterOpts) = {Name: \"ScannedRows\"}];\n     COUNTER_SCANNED_BYTES = 11                              [(CounterOpts) = {Name: \"ScannedBytes\"}];\n-    COUNTER_UPSERT_BLOBS_WRITTEN = 12                       [(CounterOpts) = {Name: \"UpsertBlobsWritten\"}];\n-    COUNTER_UPSERT_BYTES_WRITTEN = 13                       [(CounterOpts) = {Name: \"UpsertBytesWritten\"}];\n+    COUNTER_OPERATIONS_BLOBS_WRITTEN = 12                   [(CounterOpts) = {Name: \"OperationsBlobsWritten\"}];\n+    COUNTER_OPERATIONS_BYTES_WRITTEN = 13                   [(CounterOpts) = {Name: \"OperationsBytesWritten\"}];\n     COUNTER_INDEXING_BLOBS_WRITTEN = 14                     [(CounterOpts) = {Name: \"IndexingBlobsWritten\"}];\n     COUNTER_INDEXING_BYTES_WRITTEN = 15                     [(CounterOpts) = {Name: \"IndexingBytesWritten\"}];\n     COUNTER_COMPACTION_BLOBS_WRITTEN = 16                   [(CounterOpts) = {Name: \"CompactionBlobsWritten\"}];\n@@ -135,6 +135,10 @@ enum ECumulativeCounters {\n     COUNTER_READING_EXPORTED_BLOBS = 79                     [(CounterOpts) = {Name: \"ReadingExportedBlobs\"}];\n     COUNTER_READING_EXPORTED_BYTES = 80                     [(CounterOpts) = {Name: \"ReadingExportedBytes\"}];\n     COUNTER_READING_EXPORTED_RANGES = 81                    [(CounterOpts) = {Name: \"ReadingExportedRanges\"}];\n+    COUNTER_PLANNED_TX_COMPLETED = 82                       [(CounterOpts) = {Name: \"PlannedTxCompleted\"}];\n+    COUNTER_IMMEDIATE_TX_COMPLETED = 83                     [(CounterOpts) = {Name: \"ImmediateTxCompleted\"}];\n+    COUNTER_ROWS_ERASED = 84                                [(CounterOpts) = {Name: \"RowsErased\"}];\n+    COUNTER_OPERATIONS_ROWS_WRITTEN = 85                    [(CounterOpts) = {Name: \"OperationsRowsWritten\"}];\n }\n \n enum EPercentileCounters {\ndiff --git a/ydb/core/protos/feature_flags.proto b/ydb/core/protos/feature_flags.proto\nindex 7130ce3a81f4..af68aa5f57d0 100644\n--- a/ydb/core/protos/feature_flags.proto\n+++ b/ydb/core/protos/feature_flags.proto\n@@ -148,7 +148,12 @@ message TFeatureFlags {\n     optional bool EnableChangefeedsOnIndexTables = 134 [default = false];\n     optional bool EnableResourcePoolsCounters = 135 [default = false];\n     optional bool EnableOptionalColumnsInColumnShard = 136 [default = false];\n+    //optional bool EnableGranularTimecast = 137 [default = true]; NB. exists in main\n+    optional bool EnableAlterShardingInColumnShard = 138 [default = false];\n     optional bool EnablePgSyntax = 139 [default = false];\n+    optional bool EnableTieringInColumnShard = 140 [default = false];\n     optional bool EnableMetadataObjectsOnServerless = 141 [default = true];\n+    optional bool EnableOlapCompression = 142 [default = false];\n     optional bool EnableExternalDataSourcesOnServerless = 143 [default = true];\n+    optional bool EnableSparsedColumns = 144 [default = false];\n }\ndiff --git a/ydb/core/protos/flat_scheme_op.proto b/ydb/core/protos/flat_scheme_op.proto\nindex 1d385713a62a..a9e9219778e5 100644\n--- a/ydb/core/protos/flat_scheme_op.proto\n+++ b/ydb/core/protos/flat_scheme_op.proto\n@@ -19,6 +19,7 @@ import \"ydb/library/mkql_proto/protos/minikql.proto\";\n import \"ydb/core/protos/index_builder.proto\";\n import \"ydb/core/tx/columnshard/engines/scheme/defaults/protos/data.proto\";\n import \"ydb/core/tx/columnshard/common/protos/snapshot.proto\";\n+import \"ydb/library/formats/arrow/protos/accessor.proto\";\n \n import \"google/protobuf/empty.proto\";\n \n@@ -422,6 +423,7 @@ message TOlapColumnDiff {\n     optional TOlapColumn.TSerializer Serializer = 5;\n     optional string StorageId = 6;\n     optional string DefaultValue = 7;\n+    optional NKikimrArrowAccessorProto.TRequestedConstructor DataAccessorConstructor = 8;\n }\n \n message TOlapColumnDescription {\n@@ -441,6 +443,7 @@ message TOlapColumnDescription {\n     optional TOlapColumn.TSerializer Serializer = 10;\n     optional string StorageId = 11;\n     optional NKikimrColumnShardColumnDefaults.TColumnDefault DefaultValue = 12;\n+    optional NKikimrArrowAccessorProto.TConstructor DataAccessorConstructor = 13;\n }\n \n message TRequestedBloomFilter {\ndiff --git a/ydb/core/protos/flat_tx_scheme.proto b/ydb/core/protos/flat_tx_scheme.proto\nindex 45b5f0f07a4f..84026ae9f41d 100644\n--- a/ydb/core/protos/flat_tx_scheme.proto\n+++ b/ydb/core/protos/flat_tx_scheme.proto\n@@ -190,6 +190,8 @@ message TSchemeLimits {\n \n     optional uint64 MaxExports = 16;\n     optional uint64 MaxImports = 17;\n+\n+    optional uint64 MaxColumnTableColumns = 18;\n }\n \n message TEvInitTenantSchemeShard {\ndiff --git a/ydb/core/protos/kqp.proto b/ydb/core/protos/kqp.proto\nindex ec1a8cf8f58c..238ae23a7376 100644\n--- a/ydb/core/protos/kqp.proto\n+++ b/ydb/core/protos/kqp.proto\n@@ -584,6 +584,8 @@ message TEvStartKqpTasksRequest {\n     optional bool StartAllOrFail = 6 [default = true];\n     optional uint64 OutputChunkMaxSize = 7 [default = 0]; // 0 - use some default value \n     optional string SerializedGUCSettings = 8;\n+    optional uint64 LockTxId = 13;\n+    optional uint32 LockNodeId = 14;\n }\n \n message TEvStartKqpTasksResponse {\ndiff --git a/ydb/core/protos/table_service_config.proto b/ydb/core/protos/table_service_config.proto\nindex 8ea48a1cdb34..3c91349c40e4 100644\n--- a/ydb/core/protos/table_service_config.proto\n+++ b/ydb/core/protos/table_service_config.proto\n@@ -285,7 +285,7 @@ message TTableServiceConfig {\n     optional bool EnableOlapSink = 55 [default = false];\n \n     optional bool EnablePerStatementQueryExecution = 56 [default = false];\n-    optional bool EnableCreateTableAs = 57 [default = true];\n+    optional bool EnableCreateTableAs = 57 [default = false];\n \n     optional uint64 IdxLookupJoinPointsLimit = 58 [default = 3];\n     optional bool OldLookupJoinBehaviour = 59 [default = false];\ndiff --git a/ydb/core/protos/tx_columnshard.proto b/ydb/core/protos/tx_columnshard.proto\nindex b0339d5aa9fb..9cd849fd61be 100644\n--- a/ydb/core/protos/tx_columnshard.proto\n+++ b/ydb/core/protos/tx_columnshard.proto\n@@ -4,7 +4,7 @@ import \"ydb/core/protos/long_tx_service.proto\";\n import \"ydb/core/protos/statistics.proto\";\n import \"ydb/core/protos/subdomains.proto\";\n import \"ydb/core/protos/tx.proto\";\n-import \"ydb/core/formats/arrow/protos/fields.proto\";\n+import \"ydb/library/formats/arrow/protos/fields.proto\";\n \n package NKikimrTxColumnShard;\n option java_package = \"ru.yandex.kikimr.proto\";\n@@ -90,6 +90,7 @@ message TLogicalMetadata {\n     optional string SpecialKeysRawData = 6;\n     optional TEvWrite.EModificationType ModificationType = 7;\n     optional NKikimrArrowSchema.TSchemaSubset SchemaSubset = 8;\n+    optional string SpecialKeysPayloadData = 9;\n }\n \n message TEvWriteResult {\n@@ -144,6 +145,8 @@ enum ETransactionKind {\n     TX_KIND_COMMIT_WRITE = 5;\n     TX_KIND_BACKUP = 6;\n     TX_KIND_SHARING = 7;\n+    TX_KIND_COMMIT_WRITE_PRIMARY = 8;\n+    TX_KIND_COMMIT_WRITE_SECONDARY = 9;\n }\n \n enum ETransactionFlag {\n@@ -204,6 +207,29 @@ message TBackupTxBody {\n \n message TCommitWriteTxBody {\n     optional uint64 LockId = 1;\n+\n+    message TPrimary {\n+        repeated uint64 SendingShards = 1;\n+        repeated uint64 ReceivingShards = 2;\n+        repeated uint64 WaitShardsBrokenFlags = 3;\n+        repeated uint64 WaitShardsResultAck = 4;\n+        optional bool TxBroken = 5;\n+    }\n+\n+    message TSecondary {\n+        optional uint64 ArbiterTabletId = 1;\n+        optional bool NeedReceiveBroken = 2;\n+        optional bool ReceiveAck = 3;\n+        optional bool SelfBroken = 4;\n+        optional bool TxBroken = 5;\n+    }\n+\n+    oneof Implementation {\n+        TPrimary PrimaryTabletData = 5;\n+        TSecondary SecondaryTabletData = 6;\n+    }\n+\n+    optional bool Broken = 4 [default = false];\n }\n \n message TSchemaPresetVersionInfo {\ndiff --git a/ydb/core/protos/tx_datashard.proto b/ydb/core/protos/tx_datashard.proto\nindex cf528ba91081..682b2373f736 100644\n--- a/ydb/core/protos/tx_datashard.proto\n+++ b/ydb/core/protos/tx_datashard.proto\n@@ -7,7 +7,7 @@ import \"ydb/core/scheme/protos/key_range.proto\";\n import \"ydb/core/scheme/protos/pathid.proto\";\n import \"ydb/core/protos/data_events.proto\";\n import \"ydb/core/protos/kqp.proto\";\n-import \"ydb/core/formats/arrow/protos/ssa.proto\";\n+import \"ydb/library/formats/arrow/protos/ssa.proto\";\n import \"ydb/core/protos/tablet.proto\";\n import \"ydb/core/protos/tx.proto\";\n import \"ydb/core/protos/flat_scheme_op.proto\";\n@@ -1523,6 +1523,8 @@ message TEvKqpScan {\n     optional bytes OlapProgram = 19;\n     optional NKikimrSchemeOp.EOlapProgramType OlapProgramType = 20;\n     optional TComputeShardingPolicy ComputeShardingPolicy = 23;\n+    optional uint64 LockTxId = 24;\n+    optional uint32 LockNodeId = 25;\n }\n \n message TEvCompactTable {\ndiff --git a/ydb/core/protos/ya.make b/ydb/core/protos/ya.make\nindex aa55a2d8a046..535eb29dd3f3 100644\n--- a/ydb/core/protos/ya.make\n+++ b/ydb/core/protos/ya.make\n@@ -168,7 +168,7 @@ PEERDIR(\n     ydb/library/ydb_issue/proto\n     ydb/core/tx/columnshard/engines/scheme/defaults/protos\n     ydb/core/tx/columnshard/engines/protos\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n     ydb/core/tx/columnshard/common/protos\n )\n \ndiff --git a/ydb/core/sys_view/common/schema.h b/ydb/core/sys_view/common/schema.h\nindex c11266041cf1..81542a645969 100644\n--- a/ydb/core/sys_view/common/schema.h\n+++ b/ydb/core/sys_view/common/schema.h\n@@ -415,7 +415,7 @@ struct Schema : NIceDb::Schema {\n         struct BlobId : Column<10, NScheme::NTypeIds::Utf8> {};\n         struct BlobRangeOffset : Column<11, NScheme::NTypeIds::Uint64> {};\n         struct BlobRangeSize : Column<12, NScheme::NTypeIds::Uint64> {};\n-        struct Activity : Column<13, NScheme::NTypeIds::Bool> {};\n+        struct Activity : Column<13, NScheme::NTypeIds::Uint8> {};\n         struct TierName: Column<14, NScheme::NTypeIds::Utf8> {};\n         struct EntityType: Column<15, NScheme::NTypeIds::Utf8> {};\n \n@@ -525,9 +525,10 @@ struct Schema : NIceDb::Schema {\n         struct ColumnBlobBytes: Column<7, NScheme::NTypeIds::Uint64> {};\n         struct IndexBlobBytes: Column<8, NScheme::NTypeIds::Uint64> {};\n         struct PortionId: Column<9, NScheme::NTypeIds::Uint64> {};\n-        struct Activity: Column<10, NScheme::NTypeIds::Bool> {};\n+        struct Activity: Column<10, NScheme::NTypeIds::Uint8> {};\n         struct TierName: Column<11, NScheme::NTypeIds::Utf8> {};\n         struct Stats: Column<12, NScheme::NTypeIds::Utf8> {};\n+        struct Optimized: Column<13, NScheme::NTypeIds::Uint8> {};\n \n         using TKey = TableKey<PathId, TabletId, PortionId>;\n         using TColumns = TableColumns<\n@@ -542,7 +543,8 @@ struct Schema : NIceDb::Schema {\n             PortionId,\n             Activity,\n             TierName,\n-            Stats\n+            Stats,\n+            Optimized\n         >;\n     };\n \ndiff --git a/ydb/core/tablet/tablet_counters_aggregator.cpp b/ydb/core/tablet/tablet_counters_aggregator.cpp\nindex b94e31c175fb..28e7497d2529 100644\n--- a/ydb/core/tablet/tablet_counters_aggregator.cpp\n+++ b/ydb/core/tablet/tablet_counters_aggregator.cpp\n@@ -765,10 +765,16 @@ class TTabletMon {\n         TCounterPtr DatashardSizeBytes;\n         TCounterPtr DatashardCacheHitBytes;\n         TCounterPtr DatashardCacheMissBytes;\n+        TCounterPtr ColumnShardReadRows_;\n+        TCounterPtr ColumnShardReadBytes_;\n         TCounterPtr ColumnShardScanRows_;\n         TCounterPtr ColumnShardScanBytes_;\n+        TCounterPtr ColumnShardWriteRows_;\n+        TCounterPtr ColumnShardWriteBytes_;\n         TCounterPtr ColumnShardBulkUpsertRows_;\n         TCounterPtr ColumnShardBulkUpsertBytes_;\n+        TCounterPtr ColumnShardEraseRows_;\n+        TCounterPtr ColumnShardEraseBytes_;\n         TCounterPtr ResourcesStorageUsedBytes;\n         TCounterPtr ResourcesStorageUsedBytesOnSsd;\n         TCounterPtr ResourcesStorageUsedBytesOnHdd;\n@@ -787,6 +793,7 @@ class TTabletMon {\n         TCounterPtr ResourcesStreamReservedStorageLimit;\n \n         THistogramPtr ShardCpuUtilization;\n+        THistogramPtr ColumnShardCpuUtilization;\n \n         TCounterPtr RowUpdates;\n         TCounterPtr RowUpdateBytes;\n@@ -808,8 +815,11 @@ class TTabletMon {\n \n         TCounterPtr ColumnShardScannedBytes_;\n         TCounterPtr ColumnShardScannedRows_;\n-        TCounterPtr ColumnShardUpsertBlobsWritten_;\n-        TCounterPtr ColumnShardUpsertBytesWritten_;\n+        TCounterPtr ColumnShardOperationsRowsWritten_;\n+        TCounterPtr ColumnShardOperationsBytesWritten_;\n+        TCounterPtr ColumnShardErasedBytes_;\n+        TCounterPtr ColumnShardErasedRows_;\n+        THistogramPtr ColumnShardConsumedCpuHistogram;\n \n         TCounterPtr DiskSpaceTablesTotalBytes;\n         TCounterPtr DiskSpaceTablesTotalBytesOnSsd;\n@@ -859,14 +869,26 @@ class TTabletMon {\n             DatashardCacheMissBytes = ydbGroup->GetNamedCounter(\"name\",\n                 \"table.datashard.cache_miss.bytes\", true);\n \n+            ColumnShardReadRows_ = ydbGroup->GetNamedCounter(\"name\",\n+                \"table.columnshard.read.rows\", true);\n+            ColumnShardReadBytes_ = ydbGroup->GetNamedCounter(\"name\",\n+                \"table.columnshard.read.bytes\", true);\n             ColumnShardScanRows_ = ydbGroup->GetNamedCounter(\"name\",\n                 \"table.columnshard.scan.rows\", true);\n             ColumnShardScanBytes_ = ydbGroup->GetNamedCounter(\"name\",\n                 \"table.columnshard.scan.bytes\", true);\n+            ColumnShardWriteRows_ = ydbGroup->GetNamedCounter(\"name\",\n+                \"table.columnshard.write.rows\", true);\n+            ColumnShardWriteBytes_ = ydbGroup->GetNamedCounter(\"name\",\n+                \"table.columnshard.write.bytes\", true);\n             ColumnShardBulkUpsertRows_ = ydbGroup->GetNamedCounter(\"name\",\n                 \"table.columnshard.bulk_upsert.rows\", true);\n             ColumnShardBulkUpsertBytes_ = ydbGroup->GetNamedCounter(\"name\",\n                 \"table.columnshard.bulk_upsert.bytes\", true);\n+            ColumnShardEraseRows_ = ydbGroup->GetNamedCounter(\"name\",\n+                \"table.columnshard.erase.rows\", true);\n+            ColumnShardEraseBytes_ = ydbGroup->GetNamedCounter(\"name\",\n+                \"table.columnshard.erase.bytes\", true);\n \n             ResourcesStorageUsedBytes = ydbGroup->GetNamedCounter(\"name\",\n                 \"resources.storage.used_bytes\", false);\n@@ -908,6 +930,8 @@ class TTabletMon {\n \n             ShardCpuUtilization = ydbGroup->GetNamedHistogram(\"name\",\n                 \"table.datashard.used_core_percents\", NMonitoring::LinearHistogram(12, 0, 10), false);\n+            ColumnShardCpuUtilization = ydbGroup->GetNamedHistogram(\"name\",\n+                \"table.columnshard.used_core_percents\", NMonitoring::LinearHistogram(12, 0, 10), false);\n         };\n \n         void Initialize(::NMonitoring::TDynamicCounterPtr counters, bool hasDatashard, bool hasSchemeshard, bool hasColumnShard) {\n@@ -943,8 +967,11 @@ class TTabletMon {\n \n                 ColumnShardScannedBytes_ = appGroup->GetCounter(\"ColumnShard/ScannedBytes\");\n                 ColumnShardScannedRows_ = appGroup->GetCounter(\"ColumnShard/ScannedRows\");\n-                ColumnShardUpsertBlobsWritten_ = appGroup->GetCounter(\"ColumnShard/UpsertBlobsWritten\");\n-                ColumnShardUpsertBytesWritten_ = appGroup->GetCounter(\"ColumnShard/UpsertBytesWritten\");\n+                ColumnShardOperationsRowsWritten_ = appGroup->GetCounter(\"ColumnShard/OperationsRowsWritten\");\n+                ColumnShardOperationsBytesWritten_ = appGroup->GetCounter(\"ColumnShard/OperationsBytesWritten\");\n+                ColumnShardErasedBytes_ = appGroup->GetCounter(\"ColumnShard/BytesErased\");\n+                ColumnShardErasedRows_ = appGroup->GetCounter(\"ColumnShard/RowsErased\");\n+                ColumnShardConsumedCpuHistogram = appGroup->FindHistogram(\"HIST(ConsumedCPU)\");\n             }\n \n             if (hasSchemeshard && !DiskSpaceTablesTotalBytes) {\n@@ -990,10 +1017,20 @@ class TTabletMon {\n             }\n \n             if (ColumnShardScannedBytes_) {\n+                ColumnShardReadRows_->Set(0);\n+                ColumnShardReadBytes_->Set(0);\n                 ColumnShardScanRows_->Set(ColumnShardScannedRows_->Val());\n                 ColumnShardScanBytes_->Set(ColumnShardScannedBytes_->Val());\n-                ColumnShardBulkUpsertRows_->Set(ColumnShardUpsertBlobsWritten_->Val());\n-                ColumnShardBulkUpsertBytes_->Set(ColumnShardUpsertBytesWritten_->Val());\n+                ColumnShardWriteRows_->Set(ColumnShardOperationsRowsWritten_->Val());\n+                ColumnShardWriteBytes_->Set(ColumnShardOperationsBytesWritten_->Val());\n+                ColumnShardBulkUpsertRows_->Set(ColumnShardOperationsRowsWritten_->Val());\n+                ColumnShardBulkUpsertBytes_->Set(ColumnShardOperationsBytesWritten_->Val());\n+                ColumnShardEraseRows_->Set(ColumnShardErasedRows_->Val());\n+                ColumnShardEraseBytes_->Set(ColumnShardErasedBytes_->Val());\n+\n+                if (ColumnShardConsumedCpuHistogram) {\n+                    TransferBuckets(ColumnShardCpuUtilization, ColumnShardConsumedCpuHistogram);\n+                }\n             }\n \n             if (DiskSpaceTablesTotalBytes) {\ndiff --git a/ydb/core/tx/columnshard/background_controller.h b/ydb/core/tx/columnshard/background_controller.h\nindex bb38f2744061..b57a29d5b072 100644\n--- a/ydb/core/tx/columnshard/background_controller.h\n+++ b/ydb/core/tx/columnshard/background_controller.h\n@@ -1,6 +1,7 @@\n #pragma once\n #include \"engines/changes/abstract/compaction_info.h\"\n #include \"engines/portions/meta.h\"\n+#include <ydb/core/tx/columnshard/counters/counters_manager.h>\n \n namespace NKikimr::NOlap {\n class TColumnEngineChanges;\n@@ -15,11 +16,16 @@ class TBackgroundController {\n     using TCurrentCompaction = THashMap<ui64, NOlap::TPlanCompactionInfo>;\n     TCurrentCompaction ActiveCompactionInfo;\n \n+    std::shared_ptr<TBackgroundControllerCounters> Counters;\n     bool ActiveCleanupPortions = false;\n     bool ActiveCleanupTables = false;\n     bool ActiveCleanupInsertTable = false;\n     YDB_READONLY(TMonotonic, LastIndexationInstant, TMonotonic::Zero());\n public:\n+    TBackgroundController(std::shared_ptr<TBackgroundControllerCounters> counters)\n+        : Counters(std::move(counters)) {\n+    }\n+\n     THashSet<NOlap::TPortionAddress> GetConflictTTLPortions() const;\n     THashSet<NOlap::TPortionAddress> GetConflictCompactionPortions() const;\n \n@@ -29,6 +35,7 @@ class TBackgroundController {\n     bool StartCompaction(const NOlap::TPlanCompactionInfo& info);\n     void FinishCompaction(const NOlap::TPlanCompactionInfo& info) {\n         Y_ABORT_UNLESS(ActiveCompactionInfo.erase(info.GetPathId()));\n+        Counters->OnCompactionFinish(info.GetPathId());\n     }\n     const TCurrentCompaction& GetActiveCompaction() const {\n         return ActiveCompactionInfo;\ndiff --git a/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.cpp b/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.cpp\nindex cda7186419f6..5008e3e57c7f 100644\n--- a/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.cpp\n+++ b/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.cpp\n@@ -140,14 +140,9 @@ bool TBlobManager::LoadState(IBlobManagerDb& db, const TTabletId selfTabletId) {\n     if (!db.LoadLastGcBarrier(LastCollectedGenStep)) {\n         return false;\n     }\n-    //https://github.com/ydb-platform/ydb/issues/7468\n-    TGenStep storedGCBarrierPreparation;\n-    if (!db.LoadGCBarrierPreparation(storedGCBarrierPreparation)) {\n+    if (!db.LoadGCBarrierPreparation(GCBarrierPreparation)) {\n         return false;\n     }\n-    if (storedGCBarrierPreparation < LastCollectedGenStep) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_BLOBS_BS)(\"mem_genstep\", GCBarrierPreparation)(\"last_genstep\", LastCollectedGenStep)(\"db_genstep\", storedGCBarrierPreparation);\n-    }\n     AFL_VERIFY(!GCBarrierPreparation.Generation() || LastCollectedGenStep <= GCBarrierPreparation)(\"prepared\", GCBarrierPreparation)(\"last\", LastCollectedGenStep);\n \n     // Load the keep and delete queues\n@@ -314,7 +309,7 @@ std::shared_ptr<NBlobOperations::NBlobStorage::TGCTask> TBlobManager::BuildGCTas\n         return nullptr;\n     }\n \n-    if (AppData()->TimeProvider->Now() - PreviousGCTime < NYDBTest::TControllers::GetColumnShardController()->GetOverridenGCPeriod(TDuration::Seconds(GC_INTERVAL_SECONDS))) {\n+    if (AppData()->TimeProvider->Now() - PreviousGCTime < NYDBTest::TControllers::GetColumnShardController()->GetOverridenGCPeriod()) {\n         ACFL_DEBUG(\"event\", \"TBlobManager::BuildGCTask skip\")(\"current_gen\", CurrentGen)(\"current_step\", CurrentStep)(\"reason\", \"too_often\");\n         BlobsManagerCounters.GCCounters.SkipCollectionThrottling->Add(1);\n         return nullptr;\ndiff --git a/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.h b/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.h\nindex 90094e62b7a3..52e0f573eb60 100644\n--- a/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.h\n+++ b/ydb/core/tx/columnshard/blobs_action/bs/blob_manager.h\n@@ -133,9 +133,6 @@ struct TBlobManagerCounters {\n \n // The implementation of BlobManager that hides all GC-related details\n class TBlobManager : public IBlobManager, public TCommonBlobsTracker {\n-private:\n-    static constexpr ui64 GC_INTERVAL_SECONDS = 30;\n-\n private:\n     using TBlobAddress = NBlobOperations::NBlobStorage::TBlobAddress;\n     class TGCContext;\ndiff --git a/ydb/core/tx/columnshard/blobs_action/bs/write.cpp b/ydb/core/tx/columnshard/blobs_action/bs/write.cpp\nindex 021abc972a0d..06ebc64eccf3 100644\n--- a/ydb/core/tx/columnshard/blobs_action/bs/write.cpp\n+++ b/ydb/core/tx/columnshard/blobs_action/bs/write.cpp\n@@ -15,13 +15,10 @@ void TWriteAction::DoOnCompleteTxAfterWrite(NColumnShard::TColumnShard& self, co\n     ui64 blobsWritten = BlobBatch.GetBlobCount();\n     ui64 bytesWritten = BlobBatch.GetTotalSize();\n     if (blobsWroteSuccessfully) {\n-        self.IncCounter(NColumnShard::COUNTER_UPSERT_BLOBS_WRITTEN, blobsWritten);\n-        self.IncCounter(NColumnShard::COUNTER_UPSERT_BYTES_WRITTEN, bytesWritten);\n-        //    self.IncCounter(NColumnShard::COUNTER_RAW_BYTES_UPSERTED, insertedBytes);\n-        self.IncCounter(NColumnShard::COUNTER_WRITE_SUCCESS);\n+        self.Counters.GetTabletCounters()->OnWriteSuccess(blobsWritten, bytesWritten);\n         Manager->SaveBlobBatchOnComplete(std::move(BlobBatch));\n     } else {\n-        self.IncCounter(NColumnShard::COUNTER_WRITE_FAIL);\n+        self.Counters.GetTabletCounters()->OnWriteFailure();\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_gc_insert_table.h b/ydb/core/tx/columnshard/blobs_action/transaction/tx_gc_insert_table.h\nindex 5ca66fe90a34..96d8f09e5e6d 100644\n--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_gc_insert_table.h\n+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_gc_insert_table.h\n@@ -5,10 +5,10 @@\n namespace NKikimr::NColumnShard {\n class TTxInsertTableCleanup: public TTransactionBase<TColumnShard> {\n private:\n-    THashSet<TWriteId> WriteIdsToAbort;\n+    THashSet<TInsertWriteId> WriteIdsToAbort;\n     std::shared_ptr<NOlap::IBlobsDeclareRemovingAction> BlobsAction;\n public:\n-    TTxInsertTableCleanup(TColumnShard* self, THashSet<TWriteId>&& writeIdsToAbort)\n+    TTxInsertTableCleanup(TColumnShard* self, THashSet<TInsertWriteId>&& writeIdsToAbort)\n         : TBase(self)\n         , WriteIdsToAbort(std::move(writeIdsToAbort)) {\n         Y_ABORT_UNLESS(WriteIdsToAbort.size() || self->InsertTable->GetAborted().size());\ndiff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.cpp b/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.cpp\nindex 8e12cf1b8a63..96a5cf794190 100644\n--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.cpp\n+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.cpp\n@@ -1,13 +1,17 @@\n #include \"tx_write.h\"\n \n+#include <ydb/core/tx/columnshard/engines/insert_table/user_data.h>\n+#include <ydb/core/tx/columnshard/transactions/locks/write.h>\n+\n namespace NKikimr::NColumnShard {\n \n-bool TTxWrite::InsertOneBlob(TTransactionContext& txc, const NOlap::TWideSerializedBatch& batch, const TWriteId writeId) {\n+bool TTxWrite::InsertOneBlob(TTransactionContext& txc, const NOlap::TWideSerializedBatch& batch, const TInsertWriteId writeId) {\n     NKikimrTxColumnShard::TLogicalMetadata meta;\n     meta.SetNumRows(batch->GetRowsCount());\n     meta.SetRawBytes(batch->GetRawBytes());\n     meta.SetDirtyWriteTimeSeconds(batch.GetStartInstant().Seconds());\n-    meta.SetSpecialKeysRawData(batch->GetSpecialKeysSafe());\n+    meta.SetSpecialKeysRawData(batch->GetSpecialKeysFullSafe());\n+    meta.SetSpecialKeysPayloadData(batch->GetSpecialKeysPayloadSafe());\n \n     const auto& blobRange = batch.GetRange();\n     Y_ABORT_UNLESS(blobRange.GetBlobId().IsValid());\n@@ -22,9 +26,8 @@ bool TTxWrite::InsertOneBlob(TTransactionContext& txc, const NOlap::TWideSeriali\n     auto schemeVersion = batch.GetAggregation().GetSchemaVersion();\n     auto tableSchema = Self->TablesManager.GetPrimaryIndex()->GetVersionedIndex().GetSchemaVerified(schemeVersion);\n \n-    NOlap::TInsertedData insertData((ui64)writeId, writeMeta.GetTableId(), writeMeta.GetDedupId(), blobRange, \n-        meta, tableSchema->GetVersion(),\n-        batch->GetData());\n+    auto userData = std::make_shared<NOlap::TUserData>(writeMeta.GetTableId(), blobRange, meta, tableSchema->GetVersion(), batch->GetData());\n+    NOlap::TInsertedData insertData(writeId, userData);\n     bool ok = Self->InsertTable->Insert(dbTable, std::move(insertData));\n     if (ok) {\n         Self->UpdateInsertTableCounters();\n@@ -35,7 +38,8 @@ bool TTxWrite::InsertOneBlob(TTransactionContext& txc, const NOlap::TWideSeriali\n \n bool TTxWrite::Execute(TTransactionContext& txc, const TActorContext&) {\n     TMemoryProfileGuard mpg(\"TTxWrite::Execute\");\n-    NActors::TLogContextGuard logGuard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_BLOBS)(\"tablet_id\", Self->TabletID())(\"tx_state\", \"execute\");\n+    NActors::TLogContextGuard logGuard =\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_BLOBS)(\"tablet_id\", Self->TabletID())(\"tx_state\", \"execute\");\n     ACFL_DEBUG(\"event\", \"start_execute\");\n     const NOlap::TWritingBuffer& buffer = PutBlobResult->Get()->MutableWritesBuffer();\n     for (auto&& aggr : buffer.GetAggregations()) {\n@@ -44,33 +48,27 @@ bool TTxWrite::Execute(TTransactionContext& txc, const TActorContext&) {\n         txc.DB.NoMoreReadsForTx();\n         TWriteOperation::TPtr operation;\n         if (writeMeta.HasLongTxId()) {\n+            NIceDb::TNiceDb db(txc.DB);\n+            const TInsertWriteId insertWriteId =\n+                Self->GetLongTxWrite(db, writeMeta.GetLongTxIdUnsafe(), writeMeta.GetWritePartId(), writeMeta.GetGranuleShardingVersion());\n+            aggr->AddInsertWriteId(insertWriteId);\n             if (writeMeta.IsGuaranteeWriter()) {\n                 AFL_VERIFY(aggr->GetSplittedBlobs().size() == 1)(\"count\", aggr->GetSplittedBlobs().size());\n             } else {\n                 AFL_VERIFY(aggr->GetSplittedBlobs().size() <= 1)(\"count\", aggr->GetSplittedBlobs().size());\n             }\n+            if (aggr->GetSplittedBlobs().size() == 1) {\n+                AFL_VERIFY(InsertOneBlob(txc, aggr->GetSplittedBlobs().front(), insertWriteId))(\"write_id\", writeMeta.GetWriteId())(\n+                                                  \"insert_write_id\", insertWriteId);\n+            }\n         } else {\n-            operation = Self->OperationsManager->GetOperation((TWriteId)writeMeta.GetWriteId());\n-            Y_ABORT_UNLESS(operation);\n+            operation = Self->OperationsManager->GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());\n             Y_ABORT_UNLESS(operation->GetStatus() == EOperationStatus::Started);\n-        }\n-\n-        auto writeId = TWriteId(writeMeta.GetWriteId());\n-        if (!operation) {\n-            NIceDb::TNiceDb db(txc.DB);\n-            writeId = Self->GetLongTxWrite(db, writeMeta.GetLongTxIdUnsafe(), writeMeta.GetWritePartId(), writeMeta.GetGranuleShardingVersion());\n-            aggr->AddWriteId(writeId);\n-        }\n-\n-        for (auto&& i : aggr->GetSplittedBlobs()) {\n-            if (operation) {\n-                writeId = Self->BuildNextWriteId(txc);\n-                aggr->AddWriteId(writeId);\n-            }\n-\n-            if (!InsertOneBlob(txc, i, writeId)) {\n-                LOG_S_DEBUG(TxPrefix() << \"duplicate writeId \" << (ui64)writeId << TxSuffix());\n-                Self->IncCounter(COUNTER_WRITE_DUPLICATE);\n+            for (auto&& i : aggr->GetSplittedBlobs()) {\n+                const TInsertWriteId insertWriteId = Self->InsertTable->BuildNextWriteId(txc);\n+                aggr->AddInsertWriteId(insertWriteId);\n+                AFL_VERIFY(InsertOneBlob(txc, i, insertWriteId))(\"write_id\", writeMeta.GetWriteId())(\"insert_write_id\", insertWriteId)(\n+                    \"size\", aggr->GetSplittedBlobs().size());\n             }\n         }\n     }\n@@ -87,32 +85,41 @@ bool TTxWrite::Execute(TTransactionContext& txc, const TActorContext&) {\n     for (auto&& aggr : buffer.GetAggregations()) {\n         const auto& writeMeta = aggr->GetWriteMeta();\n         if (!writeMeta.HasLongTxId()) {\n-            auto operation = Self->OperationsManager->GetOperation((TWriteId)writeMeta.GetWriteId());\n-            Y_ABORT_UNLESS(operation);\n+            auto operation = Self->OperationsManager->GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());\n             Y_ABORT_UNLESS(operation->GetStatus() == EOperationStatus::Started);\n-            operation->OnWriteFinish(txc, aggr->GetWriteIds());\n-            if (operation->GetBehaviour() == EOperationBehaviour::InTxWrite) {\n+            operation->OnWriteFinish(txc, aggr->GetInsertWriteIds(), operation->GetBehaviour() == EOperationBehaviour::NoTxWrite);\n+            Self->OperationsManager->LinkInsertWriteIdToOperationWriteId(aggr->GetInsertWriteIds(), operation->GetWriteId());\n+            if (operation->GetBehaviour() == EOperationBehaviour::NoTxWrite) {\n+                auto ev = NEvents::TDataEvents::TEvWriteResult::BuildCompleted(Self->TabletID());\n+                Results.emplace_back(std::move(ev), writeMeta.GetSource(), operation->GetCookie());\n+                Self->OperationsManager->AddTemporaryTxLink(operation->GetLockId());\n+                Self->OperationsManager->CommitTransactionOnExecute(*Self, operation->GetLockId(), txc, Self->GetLastTxSnapshot());\n+            } else if (operation->GetBehaviour() == EOperationBehaviour::InTxWrite) {\n                 NKikimrTxColumnShard::TCommitWriteTxBody proto;\n                 proto.SetLockId(operation->GetLockId());\n                 TString txBody;\n                 Y_ABORT_UNLESS(proto.SerializeToString(&txBody));\n                 auto op = Self->GetProgressTxController().StartProposeOnExecute(\n-                    TTxController::TTxInfo(NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE, operation->GetLockId(), writeMeta.GetSource(), operation->GetCookie(), {}), txBody,\n-                    txc);\n+                    TTxController::TTxInfo(\n+                        NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE, operation->GetLockId(), writeMeta.GetSource(), operation->GetCookie(), {}),\n+                    txBody, txc);\n                 AFL_VERIFY(!op->IsFail());\n                 ResultOperators.emplace_back(op);\n             } else {\n+                auto& info = Self->OperationsManager->GetLockVerified(operation->GetLockId());\n                 NKikimrDataEvents::TLock lock;\n                 lock.SetLockId(operation->GetLockId());\n                 lock.SetDataShard(Self->TabletID());\n-                lock.SetGeneration(1);\n-                lock.SetCounter(1);\n+                lock.SetGeneration(info.GetGeneration());\n+                lock.SetCounter(info.GetInternalGenerationCounter());\n+                lock.SetPathId(writeMeta.GetTableId());\n                 auto ev = NEvents::TDataEvents::TEvWriteResult::BuildCompleted(Self->TabletID(), operation->GetLockId(), lock);\n                 Results.emplace_back(std::move(ev), writeMeta.GetSource(), operation->GetCookie());\n             }\n         } else {\n-            Y_ABORT_UNLESS(aggr->GetWriteIds().size() == 1);\n-            auto ev = std::make_unique<TEvColumnShard::TEvWriteResult>(Self->TabletID(), writeMeta, (ui64)aggr->GetWriteIds().front(), NKikimrTxColumnShard::EResultStatus::SUCCESS);\n+            Y_ABORT_UNLESS(aggr->GetInsertWriteIds().size() == 1);\n+            auto ev = std::make_unique<TEvColumnShard::TEvWriteResult>(\n+                Self->TabletID(), writeMeta, (ui64)aggr->GetInsertWriteIds().front(), NKikimrTxColumnShard::EResultStatus::SUCCESS);\n             Results.emplace_back(std::move(ev), writeMeta.GetSource(), 0);\n         }\n     }\n@@ -121,7 +128,8 @@ bool TTxWrite::Execute(TTransactionContext& txc, const TActorContext&) {\n \n void TTxWrite::Complete(const TActorContext& ctx) {\n     TMemoryProfileGuard mpg(\"TTxWrite::Complete\");\n-    NActors::TLogContextGuard logGuard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_BLOBS)(\"tablet_id\", Self->TabletID())(\"tx_state\", \"complete\");\n+    NActors::TLogContextGuard logGuard =\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_BLOBS)(\"tablet_id\", Self->TabletID())(\"tx_state\", \"complete\");\n     const auto now = TMonotonic::Now();\n     const NOlap::TWritingBuffer& buffer = PutBlobResult->Get()->MutableWritesBuffer();\n     for (auto&& i : buffer.GetAddActions()) {\n@@ -140,10 +148,21 @@ void TTxWrite::Complete(const TActorContext& ctx) {\n     }\n     for (ui32 i = 0; i < buffer.GetAggregations().size(); ++i) {\n         const auto& writeMeta = buffer.GetAggregations()[i]->GetWriteMeta();\n-        Self->CSCounters.OnWriteTxComplete(now - writeMeta.GetWriteStartInstant());\n-        Self->CSCounters.OnSuccessWriteResponse();\n+        if (!writeMeta.HasLongTxId()) {\n+            auto op = Self->GetOperationsManager().GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());\n+            if (op->GetBehaviour() == EOperationBehaviour::WriteWithLock || op->GetBehaviour() == EOperationBehaviour::NoTxWrite) {\n+                auto evWrite = std::make_shared<NOlap::NTxInteractions::TEvWriteWriter>(writeMeta.GetTableId(),\n+                    buffer.GetAggregations()[i]->GetRecordBatch(), Self->GetIndexOptional()->GetVersionedIndex().GetPrimaryKey());\n+                Self->GetOperationsManager().AddEventForLock(*Self, op->GetLockId(), evWrite);\n+            }\n+            if (op->GetBehaviour() == EOperationBehaviour::NoTxWrite) {\n+                Self->OperationsManager->CommitTransactionOnComplete(*Self, op->GetLockId(), Self->GetLastTxSnapshot());\n+            }\n+        }\n+        Self->Counters.GetCSCounters().OnWriteTxComplete(now - writeMeta.GetWriteStartInstant());\n+        Self->Counters.GetCSCounters().OnSuccessWriteResponse();\n     }\n-\n+    Self->Counters.GetTabletCounters()->IncCounter(COUNTER_IMMEDIATE_TX_COMPLETED);\n }\n \n-}\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.h b/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.h\nindex 98de301e5e16..84ffbe7a9005 100644\n--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.h\n+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_write.h\n@@ -43,7 +43,7 @@ class TTxWrite : public NTabletFlatExecutor::TTransactionBase<TColumnShard> {\n     std::vector<std::shared_ptr<TTxController::ITransactionOperator>> ResultOperators;\n \n \n-    bool InsertOneBlob(TTransactionContext& txc, const NOlap::TWideSerializedBatch& batch, const TWriteId writeId);\n+    bool InsertOneBlob(TTransactionContext& txc, const NOlap::TWideSerializedBatch& batch, const TInsertWriteId writeId);\n \n     TStringBuilder TxPrefix() const {\n         return TStringBuilder() << \"TxWrite[\" << ToString(TabletTxNo) << \"] \";\ndiff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_write_index.cpp b/ydb/core/tx/columnshard/blobs_action/transaction/tx_write_index.cpp\nindex a04c6fb2abef..57a1eee50146 100644\n--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_write_index.cpp\n+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_write_index.cpp\n@@ -43,7 +43,7 @@ bool TTxWriteIndex::Execute(TTransactionContext& txc, const TActorContext& ctx)\n         LOG_S_ERROR(TxPrefix() << \" (\" << changes->TypeString() << \") cannot write index blobs\" << TxSuffix());\n     }\n \n-    Self->EnqueueProgressTx(ctx);\n+    Self->EnqueueProgressTx(ctx, std::nullopt);\n     return true;\n }\n \ndiff --git a/ydb/core/tx/columnshard/columnshard.cpp b/ydb/core/tx/columnshard/columnshard.cpp\nindex c4da7260562e..f3a6b9e99db9 100644\n--- a/ydb/core/tx/columnshard/columnshard.cpp\n+++ b/ydb/core/tx/columnshard/columnshard.cpp\n@@ -1,14 +1,17 @@\n #include \"columnshard_impl.h\"\n+\n+#include \"bg_tasks/manager/manager.h\"\n #include \"blobs_reader/actor.h\"\n+#include \"counters/aggregation/table_stats.h\"\n+#include \"engines/column_engine_logs.h\"\n+#include \"engines/writer/buffer/actor.h\"\n #include \"hooks/abstract/abstract.h\"\n #include \"resource_subscriber/actor.h\"\n-#include \"engines/writer/buffer/actor.h\"\n-#include \"engines/column_engine_logs.h\"\n-#include \"bg_tasks/manager/manager.h\"\n+#include \"transactions/locks/read_finished.h\"\n \n-#include <ydb/core/tx/tiering/manager.h>\n-#include <ydb/core/tx/columnshard/bg_tasks/adapter/adapter.h>\n #include <ydb/core/protos/table_stats.pb.h>\n+#include <ydb/core/tx/columnshard/bg_tasks/adapter/adapter.h>\n+#include <ydb/core/tx/tiering/manager.h>\n \n namespace NKikimr {\n \n@@ -16,7 +19,7 @@ IActor* CreateColumnShard(const TActorId& tablet, TTabletStorageInfo* info) {\n     return new NColumnShard::TColumnShard(info, tablet);\n }\n \n-}\n+}   // namespace NKikimr\n \n namespace NKikimr::NColumnShard {\n \n@@ -26,6 +29,9 @@ void TColumnShard::CleanupActors(const TActorContext& ctx) {\n     }\n     ctx.Send(ResourceSubscribeActor, new TEvents::TEvPoisonPill);\n     ctx.Send(BufferizationWriteActorId, new TEvents::TEvPoisonPill);\n+    for (auto&& i : ActorsToStop) {\n+        ctx.Send(i, new TEvents::TEvPoisonPill);\n+    }\n \n     StoragesManager->Stop();\n     DataLocksManager->Stop();\n@@ -43,7 +49,8 @@ void TColumnShard::BecomeBroken(const TActorContext& ctx) {\n \n void TColumnShard::SwitchToWork(const TActorContext& ctx) {\n     {\n-        const TLogContextGuard gLogging = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"self_id\", SelfId());\n+        const TLogContextGuard gLogging =\n+            NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"self_id\", SelfId());\n         AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"initialize_shard\")(\"step\", \"SwitchToWork\");\n \n         for (auto&& i : TablesManager.GetTables()) {\n@@ -54,24 +61,30 @@ void TColumnShard::SwitchToWork(const TActorContext& ctx) {\n         SignalTabletActive(ctx);\n         AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"initialize_shard\")(\"step\", \"SignalTabletActive\");\n         TryRegisterMediatorTimeCast();\n-        EnqueueProgressTx(ctx);\n+        EnqueueProgressTx(ctx, std::nullopt);\n     }\n-    CSCounters.OnIndexMetadataLimit(NOlap::IColumnEngine::GetMetadataLimit());\n+    Counters.GetCSCounters().OnIndexMetadataLimit(NOlap::IColumnEngine::GetMetadataLimit());\n     EnqueueBackgroundActivities();\n     BackgroundSessionsManager->Start();\n+    ctx.Send(SelfId(), new NActors::TEvents::TEvWakeup());\n     ctx.Send(SelfId(), new TEvPrivate::TEvPeriodicWakeup());\n+    ctx.Send(SelfId(), new TEvPrivate::TEvPingSnapshotsUsage());\n     NYDBTest::TControllers::GetColumnShardController()->OnSwitchToWork(TabletID());\n+    AFL_VERIFY(!!StartInstant);\n+    Counters.GetCSCounters().Initialization.OnSwitchToWork(TMonotonic::Now() - *StartInstant, TMonotonic::Now() - CreateInstant);\n }\n \n void TColumnShard::OnActivateExecutor(const TActorContext& ctx) {\n-    const TLogContextGuard gLogging = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"self_id\", SelfId());\n+    StartInstant = TMonotonic::Now();\n+    Counters.GetCSCounters().Initialization.OnActivateExecutor(TMonotonic::Now() - CreateInstant);\n+    const TLogContextGuard gLogging =\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"self_id\", SelfId());\n     AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"initialize_shard\")(\"step\", \"OnActivateExecutor\");\n-    Executor()->RegisterExternalTabletCounters(TabletCountersPtr.release());\n+    Executor()->RegisterExternalTabletCounters(TabletCountersHolder.release());\n \n     const auto selfActorId = SelfId();\n     StoragesManager->Initialize(Executor()->Generation());\n-    Tiers = std::make_shared<TTiersManager>(TabletID(), SelfId(),\n-        [selfActorId](const TActorContext& ctx) {\n+    Tiers = std::make_shared<TTiersManager>(TabletID(), SelfId(), [selfActorId](const TActorContext& ctx) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"tiering_new_event\");\n         ctx.Send(selfActorId, new TEvPrivate::TEvTieringModified);\n     });\n@@ -79,7 +92,8 @@ void TColumnShard::OnActivateExecutor(const TActorContext& ctx) {\n     if (!NMetadata::NProvider::TServiceOperator::IsEnabled()) {\n         Tiers->TakeConfigs(NYDBTest::TControllers::GetColumnShardController()->GetFallbackTiersSnapshot(), nullptr);\n     }\n-    BackgroundSessionsManager = std::make_shared<NOlap::NBackground::TSessionsManager>(std::make_shared<NBackground::TAdapter>(selfActorId, (NOlap::TTabletId)TabletID(), *this));\n+    BackgroundSessionsManager = std::make_shared<NOlap::NBackground::TSessionsManager>(\n+        std::make_shared<NBackground::TAdapter>(selfActorId, (NOlap::TTabletId)TabletID(), *this));\n \n     AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"initialize_shard\")(\"step\", \"initialize_tiring_finished\");\n     auto& icb = *AppData(ctx)->Icb;\n@@ -141,14 +155,14 @@ void TColumnShard::Handle(TEvTabletPipe::TEvServerDisconnected::TPtr& ev, const\n     LOG_S_DEBUG(\"Server pipe reset at tablet \" << TabletID());\n }\n \n-void TColumnShard::Handle(TEvPrivate::TEvScanStats::TPtr& ev, const TActorContext &ctx) {\n+void TColumnShard::Handle(TEvPrivate::TEvScanStats::TPtr& ev, const TActorContext& ctx) {\n     Y_UNUSED(ctx);\n \n-    IncCounter(COUNTER_SCANNED_ROWS, ev->Get()->Rows);\n-    IncCounter(COUNTER_SCANNED_BYTES, ev->Get()->Bytes);\n+    Counters.GetTabletCounters()->IncCounter(COUNTER_SCANNED_ROWS, ev->Get()->Rows);\n+    Counters.GetTabletCounters()->IncCounter(COUNTER_SCANNED_BYTES, ev->Get()->Bytes);\n }\n \n-void TColumnShard::Handle(TEvPrivate::TEvReadFinished::TPtr& ev, const TActorContext &ctx) {\n+void TColumnShard::Handle(TEvPrivate::TEvReadFinished::TPtr& ev, const TActorContext& ctx) {\n     Y_UNUSED(ctx);\n     ui64 readCookie = ev->Get()->RequestCookie;\n     LOG_S_DEBUG(\"Finished read cookie: \" << readCookie << \" at tablet \" << TabletID());\n@@ -156,17 +170,28 @@ void TColumnShard::Handle(TEvPrivate::TEvReadFinished::TPtr& ev, const TActorCon\n     if (HasIndex()) {\n         index = &GetIndexAs<NOlap::TColumnEngineForLogs>().GetVersionedIndex();\n     }\n-    InFlightReadsTracker.RemoveInFlightRequest(ev->Get()->RequestCookie, index);\n+\n+    auto readMetaBase = InFlightReadsTracker.ExtractInFlightRequest(ev->Get()->RequestCookie, index, TInstant::Now());\n+    readMetaBase->OnReadFinished(*this);\n \n     ui64 txId = ev->Get()->TxId;\n     if (ScanTxInFlight.contains(txId)) {\n         TDuration duration = TAppData::TimeProvider->Now() - ScanTxInFlight[txId];\n-        IncCounter(COUNTER_SCAN_LATENCY, duration);\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_SCAN_LATENCY, duration);\n         ScanTxInFlight.erase(txId);\n-        SetCounter(COUNTER_SCAN_IN_FLY, ScanTxInFlight.size());\n+        Counters.GetTabletCounters()->SetCounter(COUNTER_SCAN_IN_FLY, ScanTxInFlight.size());\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_IMMEDIATE_TX_COMPLETED);\n     }\n }\n \n+void TColumnShard::Handle(TEvPrivate::TEvPingSnapshotsUsage::TPtr& /*ev*/, const TActorContext& ctx) {\n+    if (auto writeTx =\n+            InFlightReadsTracker.Ping(this, NYDBTest::TControllers::GetColumnShardController()->GetPingCheckPeriod(), TInstant::Now())) {\n+        Execute(writeTx.release(), ctx);\n+    }\n+    ctx.Schedule(0.3 * GetMaxReadStaleness(), new TEvPrivate::TEvPingSnapshotsUsage());\n+}\n+\n void TColumnShard::Handle(TEvPrivate::TEvPeriodicWakeup::TPtr& ev, const TActorContext& ctx) {\n     if (ev->Get()->Manual) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"TEvPrivate::TEvPeriodicWakeup::MANUAL\")(\"tablet_id\", TabletID());\n@@ -176,10 +201,20 @@ void TColumnShard::Handle(TEvPrivate::TEvPeriodicWakeup::TPtr& ev, const TActorC\n         SendWaitPlanStep(GetOutdatedStep());\n \n         SendPeriodicStats();\n+        EnqueueBackgroundActivities();\n         ctx.Schedule(PeriodicWakeupActivationPeriod, new TEvPrivate::TEvPeriodicWakeup());\n     }\n }\n \n+void TColumnShard::Handle(NActors::TEvents::TEvWakeup::TPtr& ev, const TActorContext& ctx) {\n+    if (ev->Get()->Tag == 0) {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"TEvPrivate::TEvPeriodicWakeup::MANUAL\")(\"tablet_id\", TabletID());\n+        const TMonotonic now = TMonotonic::Now();\n+        GetProgressTxController().PingTimeouts(now);\n+        ctx.Schedule(TDuration::Seconds(1), new NActors::TEvents::TEvWakeup(0));\n+    }\n+}\n+\n void TColumnShard::Handle(TEvMediatorTimecast::TEvRegisterTabletResult::TPtr& ev, const TActorContext&) {\n     const auto* msg = ev->Get();\n     Y_ABORT_UNLESS(msg->TabletId == TabletID());\n@@ -213,14 +248,13 @@ void TColumnShard::UpdateInsertTableCounters() {\n     auto& prepared = InsertTable->GetCountersPrepared();\n     auto& committed = InsertTable->GetCountersCommitted();\n \n-    SetCounter(COUNTER_PREPARED_RECORDS, prepared.Rows);\n-    SetCounter(COUNTER_PREPARED_BYTES, prepared.Bytes);\n-    SetCounter(COUNTER_COMMITTED_RECORDS, committed.Rows);\n-    SetCounter(COUNTER_COMMITTED_BYTES, committed.Bytes);\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_PREPARED_RECORDS, prepared.Rows);\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_PREPARED_BYTES, prepared.Bytes);\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_COMMITTED_RECORDS, committed.Rows);\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_COMMITTED_BYTES, committed.Bytes);\n \n-    LOG_S_TRACE(\"InsertTable. Prepared: \" << prepared.Bytes << \" in \" << prepared.Rows\n-        << \" records, committed: \" << committed.Bytes << \" in \" << committed.Rows\n-        << \" records at tablet \" << TabletID());\n+    LOG_S_TRACE(\"InsertTable. Prepared: \" << prepared.Bytes << \" in \" << prepared.Rows << \" records, committed: \" << committed.Bytes << \" in \"\n+                                          << committed.Rows << \" records at tablet \" << TabletID());\n }\n \n void TColumnShard::UpdateIndexCounters() {\n@@ -229,70 +263,63 @@ void TColumnShard::UpdateIndexCounters() {\n     }\n \n     auto& stats = TablesManager.MutablePrimaryIndex().GetTotalStats();\n-    SetCounter(COUNTER_INDEX_TABLES, stats.Tables);\n-    SetCounter(COUNTER_INDEX_COLUMN_RECORDS, stats.ColumnRecords);\n-    SetCounter(COUNTER_INSERTED_PORTIONS, stats.GetInsertedStats().Portions);\n-    SetCounter(COUNTER_INSERTED_BLOBS, stats.GetInsertedStats().Blobs);\n-    SetCounter(COUNTER_INSERTED_ROWS, stats.GetInsertedStats().Rows);\n-    SetCounter(COUNTER_INSERTED_BYTES, stats.GetInsertedStats().Bytes);\n-    SetCounter(COUNTER_INSERTED_RAW_BYTES, stats.GetInsertedStats().RawBytes);\n-    SetCounter(COUNTER_COMPACTED_PORTIONS, stats.GetCompactedStats().Portions);\n-    SetCounter(COUNTER_COMPACTED_BLOBS, stats.GetCompactedStats().Blobs);\n-    SetCounter(COUNTER_COMPACTED_ROWS, stats.GetCompactedStats().Rows);\n-    SetCounter(COUNTER_COMPACTED_BYTES, stats.GetCompactedStats().Bytes);\n-    SetCounter(COUNTER_COMPACTED_RAW_BYTES, stats.GetCompactedStats().RawBytes);\n-    SetCounter(COUNTER_SPLIT_COMPACTED_PORTIONS, stats.GetSplitCompactedStats().Portions);\n-    SetCounter(COUNTER_SPLIT_COMPACTED_BLOBS, stats.GetSplitCompactedStats().Blobs);\n-    SetCounter(COUNTER_SPLIT_COMPACTED_ROWS, stats.GetSplitCompactedStats().Rows);\n-    SetCounter(COUNTER_SPLIT_COMPACTED_BYTES, stats.GetSplitCompactedStats().Bytes);\n-    SetCounter(COUNTER_SPLIT_COMPACTED_RAW_BYTES, stats.GetSplitCompactedStats().RawBytes);\n-    SetCounter(COUNTER_INACTIVE_PORTIONS, stats.GetInactiveStats().Portions);\n-    SetCounter(COUNTER_INACTIVE_BLOBS, stats.GetInactiveStats().Blobs);\n-    SetCounter(COUNTER_INACTIVE_ROWS, stats.GetInactiveStats().Rows);\n-    SetCounter(COUNTER_INACTIVE_BYTES, stats.GetInactiveStats().Bytes);\n-    SetCounter(COUNTER_INACTIVE_RAW_BYTES, stats.GetInactiveStats().RawBytes);\n-    SetCounter(COUNTER_EVICTED_PORTIONS, stats.GetEvictedStats().Portions);\n-    SetCounter(COUNTER_EVICTED_BLOBS, stats.GetEvictedStats().Blobs);\n-    SetCounter(COUNTER_EVICTED_ROWS, stats.GetEvictedStats().Rows);\n-    SetCounter(COUNTER_EVICTED_BYTES, stats.GetEvictedStats().Bytes);\n-    SetCounter(COUNTER_EVICTED_RAW_BYTES, stats.GetEvictedStats().RawBytes);\n-\n-    LOG_S_DEBUG(\"Index: tables \" << stats.Tables\n-        << \" inserted \" << stats.GetInsertedStats().DebugString()\n-        << \" compacted \" << stats.GetCompactedStats().DebugString()\n-        << \" s-compacted \" << stats.GetSplitCompactedStats().DebugString()\n-        << \" inactive \" << stats.GetInactiveStats().DebugString()\n-        << \" evicted \" << stats.GetEvictedStats().DebugString()\n-        << \" column records \" << stats.ColumnRecords\n-        << \" at tablet \" << TabletID());\n+    const std::shared_ptr<const TTabletCountersHandle>& counters = Counters.GetTabletCounters();\n+    counters->SetCounter(COUNTER_INDEX_TABLES, stats.Tables);\n+    counters->SetCounter(COUNTER_INDEX_COLUMN_RECORDS, stats.ColumnRecords);\n+    counters->SetCounter(COUNTER_INSERTED_PORTIONS, stats.GetInsertedStats().Portions);\n+    counters->SetCounter(COUNTER_INSERTED_BLOBS, stats.GetInsertedStats().Blobs);\n+    counters->SetCounter(COUNTER_INSERTED_ROWS, stats.GetInsertedStats().Rows);\n+    counters->SetCounter(COUNTER_INSERTED_BYTES, stats.GetInsertedStats().Bytes);\n+    counters->SetCounter(COUNTER_INSERTED_RAW_BYTES, stats.GetInsertedStats().RawBytes);\n+    counters->SetCounter(COUNTER_COMPACTED_PORTIONS, stats.GetCompactedStats().Portions);\n+    counters->SetCounter(COUNTER_COMPACTED_BLOBS, stats.GetCompactedStats().Blobs);\n+    counters->SetCounter(COUNTER_COMPACTED_ROWS, stats.GetCompactedStats().Rows);\n+    counters->SetCounter(COUNTER_COMPACTED_BYTES, stats.GetCompactedStats().Bytes);\n+    counters->SetCounter(COUNTER_COMPACTED_RAW_BYTES, stats.GetCompactedStats().RawBytes);\n+    counters->SetCounter(COUNTER_SPLIT_COMPACTED_PORTIONS, stats.GetSplitCompactedStats().Portions);\n+    counters->SetCounter(COUNTER_SPLIT_COMPACTED_BLOBS, stats.GetSplitCompactedStats().Blobs);\n+    counters->SetCounter(COUNTER_SPLIT_COMPACTED_ROWS, stats.GetSplitCompactedStats().Rows);\n+    counters->SetCounter(COUNTER_SPLIT_COMPACTED_BYTES, stats.GetSplitCompactedStats().Bytes);\n+    counters->SetCounter(COUNTER_SPLIT_COMPACTED_RAW_BYTES, stats.GetSplitCompactedStats().RawBytes);\n+    counters->SetCounter(COUNTER_INACTIVE_PORTIONS, stats.GetInactiveStats().Portions);\n+    counters->SetCounter(COUNTER_INACTIVE_BLOBS, stats.GetInactiveStats().Blobs);\n+    counters->SetCounter(COUNTER_INACTIVE_ROWS, stats.GetInactiveStats().Rows);\n+    counters->SetCounter(COUNTER_INACTIVE_BYTES, stats.GetInactiveStats().Bytes);\n+    counters->SetCounter(COUNTER_INACTIVE_RAW_BYTES, stats.GetInactiveStats().RawBytes);\n+    counters->SetCounter(COUNTER_EVICTED_PORTIONS, stats.GetEvictedStats().Portions);\n+    counters->SetCounter(COUNTER_EVICTED_BLOBS, stats.GetEvictedStats().Blobs);\n+    counters->SetCounter(COUNTER_EVICTED_ROWS, stats.GetEvictedStats().Rows);\n+    counters->SetCounter(COUNTER_EVICTED_BYTES, stats.GetEvictedStats().Bytes);\n+    counters->SetCounter(COUNTER_EVICTED_RAW_BYTES, stats.GetEvictedStats().RawBytes);\n+\n+    LOG_S_DEBUG(\"Index: tables \" << stats.Tables << \" inserted \" << stats.GetInsertedStats().DebugString() << \" compacted \"\n+                                 << stats.GetCompactedStats().DebugString() << \" s-compacted \" << stats.GetSplitCompactedStats().DebugString()\n+                                 << \" inactive \" << stats.GetInactiveStats().DebugString() << \" evicted \"\n+                                 << stats.GetEvictedStats().DebugString() << \" column records \" << stats.ColumnRecords << \" at tablet \"\n+                                 << TabletID());\n }\n \n ui64 TColumnShard::MemoryUsage() const {\n-    ui64 memory =\n-        ProgressTxController->GetMemoryUsage() +\n-        ScanTxInFlight.size() * (sizeof(ui64) + sizeof(TInstant)) +\n-        LongTxWrites.size() * (sizeof(TWriteId) + sizeof(TLongTxWriteInfo)) +\n-        LongTxWritesByUniqueId.size() * (sizeof(TULID) + sizeof(void*)) +\n-        (WaitingScans.size()) * (sizeof(NOlap::TSnapshot) + sizeof(void*)) +\n-        TabletCounters->Simple()[COUNTER_PREPARED_RECORDS].Get() * sizeof(NOlap::TInsertedData) +\n-        TabletCounters->Simple()[COUNTER_COMMITTED_RECORDS].Get() * sizeof(NOlap::TInsertedData);\n+    ui64 memory = ProgressTxController->GetMemoryUsage() + ScanTxInFlight.size() * (sizeof(ui64) + sizeof(TInstant)) +\n+                  LongTxWrites.size() * (sizeof(TInsertWriteId) + sizeof(TLongTxWriteInfo)) +\n+                  LongTxWritesByUniqueId.size() * (sizeof(TULID) + sizeof(void*)) +\n+                  (WaitingScans.size()) * (sizeof(NOlap::TSnapshot) + sizeof(void*)) +\n+                  Counters.GetTabletCounters()->GetValue(COUNTER_PREPARED_RECORDS) * sizeof(NOlap::TInsertedData) +\n+                  Counters.GetTabletCounters()->GetValue(COUNTER_COMMITTED_RECORDS) * sizeof(NOlap::TInsertedData);\n     memory += TablesManager.GetMemoryUsage();\n     return memory;\n }\n \n void TColumnShard::UpdateResourceMetrics(const TActorContext& ctx, const TUsage& usage) {\n-    auto * metrics = Executor()->GetResourceMetrics();\n+    auto* metrics = Executor()->GetResourceMetrics();\n     if (!metrics) {\n         return;\n     }\n \n     ui64 storageBytes =\n-        TabletCounters->Simple()[COUNTER_PREPARED_BYTES].Get() +\n-        TabletCounters->Simple()[COUNTER_COMMITTED_BYTES].Get() +\n-        TabletCounters->Simple()[COUNTER_INSERTED_BYTES].Get() +\n-        TabletCounters->Simple()[COUNTER_COMPACTED_BYTES].Get() +\n-        TabletCounters->Simple()[COUNTER_SPLIT_COMPACTED_BYTES].Get() +\n-        TabletCounters->Simple()[COUNTER_INACTIVE_BYTES].Get();\n+        Counters.GetTabletCounters()->GetValue(COUNTER_PREPARED_BYTES) + Counters.GetTabletCounters()->GetValue(COUNTER_COMMITTED_BYTES) +\n+        Counters.GetTabletCounters()->GetValue(COUNTER_INSERTED_BYTES) + Counters.GetTabletCounters()->GetValue(COUNTER_COMPACTED_BYTES) +\n+        Counters.GetTabletCounters()->GetValue(COUNTER_SPLIT_COMPACTED_BYTES) + Counters.GetTabletCounters()->GetValue(COUNTER_INACTIVE_BYTES);\n \n     ui64 memory = MemoryUsage();\n \n@@ -308,35 +335,6 @@ void TColumnShard::UpdateResourceMetrics(const TActorContext& ctx, const TUsage&\n     metrics->TryUpdate(ctx);\n }\n \n-void TColumnShard::ConfigureStats(const NOlap::TColumnEngineStats& indexStats,\n-                                  ::NKikimrTableStats::TTableStats* tabletStats) {\n-    NOlap::TSnapshot lastIndexUpdate = TablesManager.GetPrimaryIndexSafe().LastUpdate();\n-    auto activeIndexStats = indexStats.Active();   // data stats excluding inactive and evicted\n-\n-    if (activeIndexStats.Rows < 0 || activeIndexStats.Bytes < 0) {\n-        LOG_S_WARN(\"Negative stats counter. Rows: \" << activeIndexStats.Rows << \" Bytes: \" << activeIndexStats.Bytes\n-                                                    << TabletID());\n-\n-        activeIndexStats.Rows = (activeIndexStats.Rows < 0) ? 0 : activeIndexStats.Rows;\n-        activeIndexStats.Bytes = (activeIndexStats.Bytes < 0) ? 0 : activeIndexStats.Bytes;\n-    }\n-\n-    tabletStats->SetRowCount(activeIndexStats.Rows);\n-    tabletStats->SetDataSize(activeIndexStats.Bytes + TabletCounters->Simple()[COUNTER_COMMITTED_BYTES].Get());\n-\n-    // TODO: we need row/dataSize counters for evicted data (managed by tablet but stored outside)\n-    // tabletStats->SetIndexSize(); // TODO: calc size of internal tables\n-\n-    tabletStats->SetLastAccessTime(LastAccessTime.MilliSeconds());\n-    tabletStats->SetLastUpdateTime(lastIndexUpdate.GetPlanStep());\n-}\n-\n-void TColumnShard::FillTxTableStats(::NKikimrTableStats::TTableStats* tableStats) const {\n-    tableStats->SetTxRejectedByOverload(TabletCounters->Cumulative()[COUNTER_WRITE_OVERLOAD].Get());\n-    tableStats->SetTxRejectedBySpace(TabletCounters->Cumulative()[COUNTER_OUT_OF_SPACE].Get());\n-    tableStats->SetInFlightTxCount(Executor()->GetStats().TxInFly);\n-}\n-\n void TColumnShard::FillOlapStats(const TActorContext& ctx, std::unique_ptr<TEvDataShard::TEvPeriodicTableStats>& ev) {\n     ev->Record.SetShardState(2);   // NKikimrTxDataShard.EDatashardState.Ready\n     ev->Record.SetGeneration(Executor()->Generation());\n@@ -346,30 +344,24 @@ void TColumnShard::FillOlapStats(const TActorContext& ctx, std::unique_ptr<TEvDa\n     if (auto* resourceMetrics = Executor()->GetResourceMetrics()) {\n         resourceMetrics->Fill(*ev->Record.MutableTabletMetrics());\n     }\n-    auto* tabletStats = ev->Record.MutableTableStats();\n-    FillTxTableStats(tabletStats);\n+\n     if (TablesManager.HasPrimaryIndex()) {\n-        const auto& indexStats = TablesManager.MutablePrimaryIndex().GetTotalStats();\n-        ConfigureStats(indexStats, tabletStats);\n+        TTableStatsBuilder statsBuilder(Counters, Executor(), TablesManager.MutablePrimaryIndex());\n+        statsBuilder.FillTotalTableStats(*ev->Record.MutableTableStats());\n     }\n }\n \n-void TColumnShard::FillColumnTableStats(const TActorContext& ctx,\n-                                        std::unique_ptr<TEvDataShard::TEvPeriodicTableStats>& ev) {\n-    if (!TablesManager.HasPrimaryIndex()) {\n-        return;\n-    }\n-    const auto& tablesIndexStats = TablesManager.MutablePrimaryIndex().GetStats();\n-    LOG_S_DEBUG(\"There are stats for \" << tablesIndexStats.size() << \" tables\");\n-    for (const auto& [tableLocalID, columnStats] : tablesIndexStats) {\n-        if (!columnStats) {\n-            LOG_S_ERROR(\"SendPeriodicStats: empty stats\");\n-            continue;\n-        }\n+void TColumnShard::FillColumnTableStats(const TActorContext& ctx, std::unique_ptr<TEvDataShard::TEvPeriodicTableStats>& ev) {\n+    auto tables = TablesManager.GetTables();\n+    std::optional<TTableStatsBuilder> tableStatsBuilder =\n+        TablesManager.HasPrimaryIndex() ? std::make_optional<TTableStatsBuilder>(Counters, Executor(), TablesManager.MutablePrimaryIndex())\n+                                        : std::nullopt;\n \n+    LOG_S_DEBUG(\"There are stats for \" << tables.size() << \" tables\");\n+    for (const auto& [pathId, _] : tables) {\n         auto* periodicTableStats = ev->Record.AddTables();\n         periodicTableStats->SetDatashardId(TabletID());\n-        periodicTableStats->SetTableLocalId(tableLocalID);\n+        periodicTableStats->SetTableLocalId(pathId);\n \n         periodicTableStats->SetShardState(2);   // NKikimrTxDataShard.EDatashardState.Ready\n         periodicTableStats->SetGeneration(Executor()->Generation());\n@@ -381,11 +373,11 @@ void TColumnShard::FillColumnTableStats(const TActorContext& ctx,\n             resourceMetrics->Fill(*periodicTableStats->MutableTabletMetrics());\n         }\n \n-        auto* tableStats = periodicTableStats->MutableTableStats();\n-        FillTxTableStats(tableStats);\n-        ConfigureStats(*columnStats, tableStats);\n+        if (tableStatsBuilder) {\n+            tableStatsBuilder->FillTableStats(pathId, *(periodicTableStats->MutableTableStats()));\n+        }\n \n-        LOG_S_TRACE(\"Add stats for table, tableLocalID=\" << tableLocalID);\n+        LOG_S_TRACE(\"Add stats for table, tableLocalID=\" << pathId);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/columnshard.h b/ydb/core/tx/columnshard/columnshard.h\nindex 90ae1fd8c6b7..186d665153af 100644\n--- a/ydb/core/tx/columnshard/columnshard.h\n+++ b/ydb/core/tx/columnshard/columnshard.h\n@@ -98,6 +98,7 @@ struct TEvColumnShard {\n     struct TEvInternalScan: public TEventLocal<TEvInternalScan, EvInternalScan> {\n     private:\n         YDB_READONLY(ui64, PathId, 0);\n+        YDB_READONLY_DEF(std::optional<ui64>, LockId);\n         YDB_ACCESSOR(bool, Reverse, false);\n         YDB_ACCESSOR(ui32, ItemsLimit, 0);\n         YDB_READONLY_DEF(std::vector<ui32>, ColumnIds);\n@@ -116,8 +117,9 @@ struct TEvColumnShard {\n             ColumnNames.emplace_back(columnName);\n         }\n \n-        TEvInternalScan(const ui64 pathId)\n+        TEvInternalScan(const ui64 pathId, const std::optional<ui64> lockId)\n             : PathId(pathId)\n+            , LockId(lockId)\n         {\n \n         }\ndiff --git a/ydb/core/tx/columnshard/columnshard__init.cpp b/ydb/core/tx/columnshard/columnshard__init.cpp\nindex aadee209f6dd..09cf1f4ef71f 100644\n--- a/ydb/core/tx/columnshard/columnshard__init.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__init.cpp\n@@ -19,6 +19,9 @@ namespace NKikimr::NColumnShard {\n using namespace NTabletFlatExecutor;\n \n class TTxInit : public TTransactionBase<TColumnShard> {\n+private:\n+    const TMonotonic StartInstant = TMonotonic::Now();\n+\n public:\n     TTxInit(TColumnShard* self)\n         : TBase(self)\n@@ -38,7 +41,6 @@ void TTxInit::SetDefaults() {\n     Self->CurrentSchemeShardId = 0;\n     Self->LastSchemaSeqNo = { };\n     Self->ProcessingParams.reset();\n-    Self->LastWriteId = TWriteId{0};\n     Self->LastPlannedStep = 0;\n     Self->LastPlannedTxId = 0;\n     Self->LastCompletedTx = NOlap::TSnapshot::Zero();\n@@ -70,7 +72,6 @@ bool TTxInit::Precharge(TTransactionContext& txc) {\n     ready = ready && Schema::GetSpecialValueOpt(db, Schema::EValueIds::LastSchemaSeqNoGeneration, Self->LastSchemaSeqNo.Generation);\n     ready = ready && Schema::GetSpecialValueOpt(db, Schema::EValueIds::LastSchemaSeqNoRound, Self->LastSchemaSeqNo.Round);\n     ready = ready && Schema::GetSpecialProtoValue(db, Schema::EValueIds::ProcessingParams, Self->ProcessingParams);\n-    ready = ready && Schema::GetSpecialValueOpt(db, Schema::EValueIds::LastWriteId, Self->LastWriteId);\n     ready = ready && Schema::GetSpecialValueOpt(db, Schema::EValueIds::LastPlannedStep, Self->LastPlannedStep);\n     ready = ready && Schema::GetSpecialValueOpt(db, Schema::EValueIds::LastPlannedTxId, Self->LastPlannedTxId);\n     ready = ready && Schema::GetSpecialValueOpt(db, Schema::EValueIds::LastExportNumber, Self->LastExportNo);\n@@ -104,7 +105,7 @@ bool TTxInit::ReadEverything(TTransactionContext& txc, const TActorContext& ctx)\n         ACFL_DEBUG(\"step\", \"TInsertTable::Load_Start\");\n         TMemoryProfileGuard g(\"TTxInit/InsertTable\");\n         auto localInsertTable = std::make_unique<NOlap::TInsertTable>();\n-        if (!localInsertTable->Load(dbTable, TAppData::TimeProvider->Now())) {\n+        if (!localInsertTable->Load(db, dbTable, TAppData::TimeProvider->Now())) {\n             ACFL_ERROR(\"step\", \"TInsertTable::Load_Fails\");\n             return false;\n         }\n@@ -165,9 +166,9 @@ bool TTxInit::ReadEverything(TTransactionContext& txc, const TActorContext& ctx)\n         }\n         Self->TablesManager = std::move(tManagerLocal);\n \n-        Self->SetCounter(COUNTER_TABLES, Self->TablesManager.GetTables().size());\n-        Self->SetCounter(COUNTER_TABLE_PRESETS, Self->TablesManager.GetSchemaPresets().size());\n-        Self->SetCounter(COUNTER_TABLE_TTLS, Self->TablesManager.GetTtl().PathsCount());\n+        Self->Counters.GetTabletCounters()->SetCounter(COUNTER_TABLES, Self->TablesManager.GetTables().size());\n+        Self->Counters.GetTabletCounters()->SetCounter(COUNTER_TABLE_PRESETS, Self->TablesManager.GetSchemaPresets().size());\n+        Self->Counters.GetTabletCounters()->SetCounter(COUNTER_TABLE_TTLS, Self->TablesManager.GetTtl().PathsCount());\n         ACFL_DEBUG(\"step\", \"TTablesManager::Load_Finish\");\n     }\n \n@@ -179,7 +180,7 @@ bool TTxInit::ReadEverything(TTransactionContext& txc, const TActorContext& ctx)\n         }\n \n         while (!rowset.EndOfSet()) {\n-            const TWriteId writeId = TWriteId{ rowset.GetValue<Schema::LongTxWrites::WriteId>() };\n+            const TInsertWriteId writeId = (TInsertWriteId)rowset.GetValue<Schema::LongTxWrites::WriteId>();\n             const ui32 writePartId = rowset.GetValue<Schema::LongTxWrites::WritePartId>();\n             NKikimrLongTxService::TLongTxId proto;\n             Y_ABORT_UNLESS(proto.ParseFromString(rowset.GetValue<Schema::LongTxWrites::LongTxId>()));\n@@ -222,6 +223,14 @@ bool TTxInit::ReadEverything(TTransactionContext& txc, const TActorContext& ctx)\n         }\n         Self->SharingSessionsManager = local;\n     }\n+    { \n+        TMemoryProfileGuard g(\"TTxInit/TInFlightReadsTracker\");\n+        TInFlightReadsTracker local(Self->StoragesManager, Self->Counters.GetRequestsTracingCounters());\n+        if (!local.LoadFromDatabase(txc.DB)) {\n+            return false;\n+        }\n+        Self->InFlightReadsTracker = std::move(local);\n+    }\n \n     Self->UpdateInsertTableCounters();\n     Self->UpdateIndexCounters();\n@@ -250,7 +259,7 @@ bool TTxInit::Execute(TTransactionContext& txc, const TActorContext& ctx) {\n }\n \n void TTxInit::Complete(const TActorContext& ctx) {\n-    Self->ProgressTxController->StartOperators();\n+    Self->Counters.GetCSCounters().Initialization.OnTxInitFinished(TMonotonic::Now() - StartInstant);\n     Self->ProgressTxController->OnTabletInit();\n     Self->SwitchToWork(ctx);\n     NYDBTest::TControllers::GetColumnShardController()->OnTabletInitCompleted(*Self);\n@@ -258,6 +267,8 @@ void TTxInit::Complete(const TActorContext& ctx) {\n \n class TTxUpdateSchema : public TTransactionBase<TColumnShard> {\n     std::vector<NOlap::INormalizerTask::TPtr> NormalizerTasks;\n+    const TMonotonic StartInstant = TMonotonic::Now();\n+\n public:\n     TTxUpdateSchema(TColumnShard* self)\n         : TBase(self)\n@@ -296,6 +307,7 @@ bool TTxUpdateSchema::Execute(TTransactionContext& txc, const TActorContext&) {\n \n void TTxUpdateSchema::Complete(const TActorContext& ctx) {\n     AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"step\", \"TTxUpdateSchema.Complete\");\n+    Self->Counters.GetCSCounters().Initialization.OnTxUpdateSchemaFinished(TMonotonic::Now() - StartInstant);\n     if (NormalizerTasks.empty()) {\n         AFL_VERIFY(Self->NormalizerController.IsNormalizationFinished())(\"details\", Self->NormalizerController.DebugString());\n         Self->Execute(new TTxInit(Self), ctx);\n@@ -361,6 +373,9 @@ void TTxApplyNormalizer::Complete(const TActorContext& ctx) {\n \n /// Create local database on tablet start if none\n class TTxInitSchema : public TTransactionBase<TColumnShard> {\n+private:\n+    const TMonotonic StartInstant = TMonotonic::Now();\n+\n public:\n     TTxInitSchema(TColumnShard* self)\n         : TBase(self)\n@@ -423,6 +438,7 @@ bool TTxInitSchema::Execute(TTransactionContext& txc, const TActorContext&) {\n }\n \n void TTxInitSchema::Complete(const TActorContext& ctx) {\n+    Self->Counters.GetCSCounters().Initialization.OnTxInitSchemaFinished(TMonotonic::Now() - StartInstant);\n     LOG_S_DEBUG(\"TxInitSchema.Complete at tablet \" << Self->TabletID(););\n     Self->Execute(new TTxUpdateSchema(Self), ctx);\n }\ndiff --git a/ydb/core/tx/columnshard/columnshard__notify_tx_completion.cpp b/ydb/core/tx/columnshard/columnshard__notify_tx_completion.cpp\nindex cc498125c326..883844cc0357 100644\n--- a/ydb/core/tx/columnshard/columnshard__notify_tx_completion.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__notify_tx_completion.cpp\n@@ -14,7 +14,7 @@ class TTxNotifyTxCompletion : public TTransactionBase<TColumnShard> {\n         LOG_S_DEBUG(\"TTxNotifyTxCompletion.Execute at tablet \" << Self->TabletID());\n \n         const ui64 txId = Ev->Get()->Record.GetTxId();\n-        auto txOperator = Self->ProgressTxController->GetTxOperator(txId);\n+        auto txOperator = Self->ProgressTxController->GetTxOperatorOptional(txId);\n         if (txOperator) {\n             txOperator->RegisterSubscriber(Ev->Sender);\n             return true;\ndiff --git a/ydb/core/tx/columnshard/columnshard__plan_step.cpp b/ydb/core/tx/columnshard/columnshard__plan_step.cpp\nindex 80dda8112e0b..33420df5905c 100644\n--- a/ydb/core/tx/columnshard/columnshard__plan_step.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__plan_step.cpp\n@@ -102,10 +102,10 @@ bool TTxPlanStep::Execute(TTransactionContext& txc, const TActorContext& ctx) {\n \n     Result = std::make_unique<TEvTxProcessing::TEvPlanStepAccepted>(Self->TabletID(), step);\n \n-    Self->IncCounter(COUNTER_PLAN_STEP_ACCEPTED);\n+    Self->Counters.GetTabletCounters()->IncCounter(COUNTER_PLAN_STEP_ACCEPTED);\n \n     if (plannedCount > 0 || Self->ProgressTxController->HaveOutdatedTxs()) {\n-        Self->EnqueueProgressTx(ctx);\n+        Self->EnqueueProgressTx(ctx, std::nullopt);\n     }\n     return true;\n }\ndiff --git a/ydb/core/tx/columnshard/columnshard__progress_tx.cpp b/ydb/core/tx/columnshard/columnshard__progress_tx.cpp\nindex e7d90c111148..73a4a0200d97 100644\n--- a/ydb/core/tx/columnshard/columnshard__progress_tx.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__progress_tx.cpp\n@@ -14,6 +14,8 @@ class TColumnShard::TTxProgressTx: public TTransactionBase<TColumnShard> {\n     const ui32 TabletTxNo;\n     std::optional<NOlap::TSnapshot> LastCompletedTx;\n     std::optional<TTxController::TPlanQueueItem> PlannedQueueItem;\n+    std::optional<TMonotonic> StartExecution;\n+    const TMonotonic ConstructionInstant = TMonotonic::Now();\n \n public:\n     TTxProgressTx(TColumnShard* self)\n@@ -29,7 +31,7 @@ class TColumnShard::TTxProgressTx: public TTransactionBase<TColumnShard> {\n         NActors::TLogContextGuard logGuard =\n             NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", Self->TabletID())(\"tx_state\", \"execute\");\n         Y_ABORT_UNLESS(Self->ProgressTxInFlight);\n-        Self->TabletCounters->Simple()[COUNTER_TX_COMPLETE_LAG].Set(Self->GetTxCompleteLag().MilliSeconds());\n+        Self->Counters.GetTabletCounters()->SetCounter(COUNTER_TX_COMPLETE_LAG, Self->GetTxCompleteLag().MilliSeconds());\n \n         const size_t removedCount = Self->ProgressTxController->CleanExpiredTxs(txc);\n         if (removedCount > 0) {\n@@ -40,11 +42,22 @@ class TColumnShard::TTxProgressTx: public TTransactionBase<TColumnShard> {\n         }\n \n         // Process a single transaction at the front of the queue\n-        auto plannedItem = Self->ProgressTxController->StartPlannedTx();\n+        const auto plannedItem = Self->ProgressTxController->GetFirstPlannedTx();\n         if (!!plannedItem) {\n             PlannedQueueItem.emplace(plannedItem->PlanStep, plannedItem->TxId);\n             ui64 step = plannedItem->PlanStep;\n             ui64 txId = plannedItem->TxId;\n+            TxOperator = Self->ProgressTxController->GetTxOperatorVerified(txId);\n+            if (auto txPrepare = TxOperator->BuildTxPrepareForProgress(Self)) {\n+                AbortedThroughRemoveExpired = true;\n+                Self->ProgressTxInFlight = txId;\n+                Self->Execute(txPrepare.release(), ctx);\n+                return true;\n+            } else {\n+                Self->ProgressTxController->PopFirstPlannedTx();\n+            }\n+            StartExecution = TMonotonic::Now();\n+\n             LastCompletedTx = NOlap::TSnapshot(step, txId);\n             if (LastCompletedTx > Self->LastCompletedTx) {\n                 NIceDb::TNiceDb db(txc.DB);\n@@ -52,9 +65,13 @@ class TColumnShard::TTxProgressTx: public TTransactionBase<TColumnShard> {\n                 Schema::SaveSpecialValue(db, Schema::EValueIds::LastCompletedTxId, LastCompletedTx->GetTxId());\n             }\n \n-            TxOperator = Self->ProgressTxController->GetVerifiedTxOperator(txId);\n             AFL_VERIFY(TxOperator->ProgressOnExecute(*Self, NOlap::TSnapshot(step, txId), txc));\n-            Self->ProgressTxController->FinishPlannedTx(txId, txc);\n+            Self->ProgressTxController->ProgressOnExecute(txId, txc);\n+            Self->Counters.GetTabletCounters()->IncCounter(COUNTER_PLANNED_TX_COMPLETED);\n+        }\n+        Self->ProgressTxInFlight = std::nullopt;\n+        if (!!Self->ProgressTxController->GetPlannedTx()) {\n+            Self->EnqueueProgressTx(ctx, std::nullopt);\n         }\n         return true;\n     }\n@@ -70,23 +87,29 @@ class TColumnShard::TTxProgressTx: public TTransactionBase<TColumnShard> {\n             Self->RescheduleWaitingReads();\n         }\n         if (PlannedQueueItem) {\n-            Self->GetProgressTxController().CompleteRunningTx(*PlannedQueueItem);\n+            AFL_VERIFY(TxOperator);\n+            Self->GetProgressTxController().GetCounters().OnTxProgressLag(\n+                TxOperator->GetOpType(), TMonotonic::Now() - TMonotonic::MilliSeconds(PlannedQueueItem->Step));\n+            Self->GetProgressTxController().ProgressOnComplete(*PlannedQueueItem);\n         }\n         if (LastCompletedTx) {\n             Self->LastCompletedTx = std::max(*LastCompletedTx, Self->LastCompletedTx);\n         }\n-        Self->ProgressTxInFlight = false;\n-        if (!!Self->ProgressTxController->GetPlannedTx()) {\n-            Self->EnqueueProgressTx(ctx);\n+        if (StartExecution) {\n+            Self->GetProgressTxController().GetCounters().OnTxExecuteDuration(TxOperator->GetOpType(), TMonotonic::Now() - *StartExecution);\n+            Self->GetProgressTxController().GetCounters().OnTxLiveDuration(TxOperator->GetOpType(), TMonotonic::Now() - ConstructionInstant);\n         }\n         Self->SetupIndexation();\n     }\n };\n \n-void TColumnShard::EnqueueProgressTx(const TActorContext& ctx) {\n+void TColumnShard::EnqueueProgressTx(const TActorContext& ctx, const std::optional<ui64> continueTxId) {\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"EnqueueProgressTx\")(\"tablet_id\", TabletID());\n-    if (!ProgressTxInFlight) {\n-        ProgressTxInFlight = true;\n+    if (continueTxId) {\n+        AFL_VERIFY(!ProgressTxInFlight || ProgressTxInFlight == continueTxId)(\"current\", ProgressTxInFlight)(\"expected\", continueTxId);\n+    }\n+    if (!ProgressTxInFlight || ProgressTxInFlight == continueTxId) {\n+        ProgressTxInFlight = continueTxId.value_or(0);\n         Execute(new TTxProgressTx(this), ctx);\n     }\n }\ndiff --git a/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp b/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp\nindex d42ad4fc8d4f..d4ded82be3d8 100644\n--- a/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp\n@@ -25,13 +25,14 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum\n         txc.DB.NoMoreReadsForTx();\n         NIceDb::TNiceDb db(txc.DB);\n \n-        Self->IncCounter(COUNTER_PREPARE_REQUEST);\n+        Self->Counters.GetTabletCounters()->IncCounter(COUNTER_PREPARE_REQUEST);\n \n         auto& record = Proto(Ev->Get());\n         const auto txKind = record.GetTxKind();\n         const ui64 txId = record.GetTxId();\n         const auto& txBody = record.GetTxBody();\n-        NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", Self->TabletID())(\"tx_id\", txId)(\"this\", (ui64)this);\n+        NActors::TLogContextGuard lGuard =\n+            NActors::TLogContextBuilder::Build()(\"tablet_id\", Self->TabletID())(\"tx_id\", txId)(\"this\", (ui64)this);\n \n         if (txKind == NKikimrTxColumnShard::TX_KIND_TTL) {\n             auto proposeResult = ProposeTtlDeprecated(txBody);\n@@ -51,7 +52,7 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum\n                 Self->CurrentSchemeShardId = record.GetSchemeShardId();\n                 Schema::SaveSpecialValue(db, Schema::EValueIds::CurrentSchemeShardId, Self->CurrentSchemeShardId);\n             } else {\n-                Y_ABORT_UNLESS(Self->CurrentSchemeShardId == record.GetSchemeShardId());\n+                AFL_VERIFY(Self->CurrentSchemeShardId == record.GetSchemeShardId());\n             }\n         }\n         std::optional<TMessageSeqNo> msgSeqNo;\n@@ -79,28 +80,34 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum\n         AFL_VERIFY(!!TxOperator);\n         AFL_VERIFY(!!TxInfo);\n         const ui64 txId = record.GetTxId();\n-        NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", Self->TabletID())(\"request_tx\", TxInfo->DebugString())(\n-            \"this\", (ui64)this)(\"op_tx\", TxOperator->GetTxInfo().DebugString());\n+        NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", Self->TabletID())(\n+            \"request_tx\", TxInfo->DebugString())(\"this\", (ui64)this)(\"op_tx\", TxOperator->GetTxInfo().DebugString());\n+\n+        Self->TryRegisterMediatorTimeCast();\n \n         if (TxOperator->IsFail()) {\n             TxOperator->SendReply(*Self, ctx);\n+            return;\n+        }\n+        auto internalOp = Self->GetProgressTxController().GetTxOperatorOptional(txId);\n+        if (!internalOp) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"removed tx operator\");\n+            return;\n+        }\n+        NActors::TLogContextGuard lGuardTx =\n+            NActors::TLogContextBuilder::Build()(\"int_op_tx\", internalOp->GetTxInfo().DebugString())(\"int_this\", (ui64)internalOp.get());\n+        if (!internalOp->CheckTxInfoForReply(*TxInfo)) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"deprecated tx operator\");\n+            return;\n+        }\n+\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"actual tx operator\");\n+        if (internalOp->IsAsync()) {\n+            Self->GetProgressTxController().StartProposeOnComplete(*internalOp, ctx);\n         } else {\n-            auto internalOp = Self->GetProgressTxController().GetVerifiedTxOperator(TxOperator->GetTxId());\n-            NActors::TLogContextGuard lGuardTx = NActors::TLogContextBuilder::Build()(\"int_op_tx\", internalOp->GetTxInfo().DebugString());\n-            if (!TxOperator->CheckTxInfoForReply(*TxInfo)) {\n-                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"deprecated tx operator\");\n-                return;\n-            } else {\n-                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"actual tx operator\");\n-            }\n-            if (TxOperator->IsAsync()) {\n-                Self->GetProgressTxController().StartProposeOnComplete(txId, ctx);\n-            } else {\n-                Self->GetProgressTxController().FinishProposeOnComplete(txId, ctx);\n-            }\n+            Self->GetProgressTxController().FinishProposeOnComplete(*internalOp, ctx);\n         }\n \n-        Self->TryRegisterMediatorTimeCast();\n     }\n \n     TTxType GetTxType() const override {\n@@ -138,11 +145,14 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum\n                 return TTxController::TProposeResult(NKikimrTxColumnShard::EResultStatus::SCHEMA_ERROR, \"No primary index for TTL\");\n             }\n \n-            auto schema = Self->TablesManager.GetPrimaryIndexSafe().GetVersionedIndex().GetLastSchema()->GetSchema();\n-            auto ttlColumn = schema->GetFieldByName(columnName);\n-            if (!ttlColumn) {\n-                return TTxController::TProposeResult(NKikimrTxColumnShard::EResultStatus::SCHEMA_ERROR, \"TTL tx wrong TTL column '\" + columnName + \"'\");\n+            auto schemaSnapshot = Self->TablesManager.GetPrimaryIndexSafe().GetVersionedIndex().GetLastSchema();\n+            auto schema = schemaSnapshot->GetSchema();\n+            auto index = schemaSnapshot->GetColumnIdOptional(columnName);\n+            if (!index) {\n+                return TTxController::TProposeResult(\n+                    NKikimrTxColumnShard::EResultStatus::SCHEMA_ERROR, \"TTL tx wrong TTL column '\" + columnName + \"'\");\n             }\n+            auto ttlColumn = schemaSnapshot->GetFieldByColumnIdVerified(*index);\n \n             const TInstant now = TlsActivationContext ? AppData()->TimeProvider->Now() : TInstant::Now();\n             for (ui64 pathId : ttlBody.GetPathIds()) {\ndiff --git a/ydb/core/tx/columnshard/columnshard__scan.cpp b/ydb/core/tx/columnshard/columnshard__scan.cpp\nindex a749e3c4f571..dd60f823139e 100644\n--- a/ydb/core/tx/columnshard/columnshard__scan.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__scan.cpp\n@@ -5,6 +5,7 @@\n #include \"engines/reader/transaction/tx_internal_scan.h\"\n \n #include <ydb/core/protos/kqp.pb.h>\n+#include <ydb/core/base/appdata_fwd.h>\n \n namespace NKikimr::NColumnShard {\n \n@@ -29,9 +30,9 @@ void TColumnShard::Handle(TEvColumnShard::TEvScan::TPtr& ev, const TActorContext\n         return;\n     }\n \n-    LastAccessTime = TAppData::TimeProvider->Now();\n-    ScanTxInFlight.insert({txId, LastAccessTime});\n-    SetCounter(COUNTER_SCAN_IN_FLY, ScanTxInFlight.size());\n+    Counters.GetColumnTablesCounters()->GetPathIdCounter(record.GetLocalPathId())->OnReadEvent();\n+    ScanTxInFlight.insert({txId, TAppData::TimeProvider->Now()});\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_SCAN_IN_FLY, ScanTxInFlight.size());\n     Execute(new NOlap::NReader::TTxScan(this, ev), ctx);\n }\n \ndiff --git a/ydb/core/tx/columnshard/columnshard__write.cpp b/ydb/core/tx/columnshard/columnshard__write.cpp\nindex c7a59351c639..8410fe52ad16 100644\n--- a/ydb/core/tx/columnshard/columnshard__write.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__write.cpp\n@@ -1,9 +1,16 @@\n #include \"columnshard_impl.h\"\n-#include \"blobs_action/transaction/tx_write.h\"\n+\n #include \"blobs_action/transaction/tx_draft.h\"\n+#include \"blobs_action/transaction/tx_write.h\"\n+#include \"common/limits.h\"\n #include \"counters/columnshard.h\"\n+#include \"engines/column_engine_logs.h\"\n #include \"operations/batch_builder/builder.h\"\n+#include \"operations/manager.h\"\n #include \"operations/write_data.h\"\n+#include \"transactions/operators/ev_write/primary.h\"\n+#include \"transactions/operators/ev_write/secondary.h\"\n+#include \"transactions/operators/ev_write/sync.h\"\n \n #include <ydb/core/tx/conveyor/usage/service.h>\n #include <ydb/core/tx/data_events/events.h>\n@@ -12,40 +19,36 @@ namespace NKikimr::NColumnShard {\n \n using namespace NTabletFlatExecutor;\n \n-void TColumnShard::OverloadWriteFail(const EOverloadStatus overloadReason, const NEvWrite::TWriteData& writeData, const ui64 cookie, std::unique_ptr<NActors::IEventBase>&& event, const TActorContext& ctx) {\n-    IncCounter(COUNTER_WRITE_FAIL);\n+void TColumnShard::OverloadWriteFail(const EOverloadStatus overloadReason, const NEvWrite::TWriteMeta& writeMeta, const ui64 writeSize, const ui64 cookie,\n+    std::unique_ptr<NActors::IEventBase>&& event, const TActorContext& ctx) {\n+    Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n     switch (overloadReason) {\n         case EOverloadStatus::Disk:\n-            IncCounter(COUNTER_OUT_OF_SPACE);\n+            Counters.OnWriteOverloadDisk();\n             break;\n         case EOverloadStatus::InsertTable:\n-            IncCounter(COUNTER_WRITE_OVERLOAD);\n-            CSCounters.OnOverloadInsertTable(writeData.GetSize());\n+            Counters.OnWriteOverloadInsertTable(writeSize);\n             break;\n         case EOverloadStatus::OverloadMetadata:\n-            IncCounter(COUNTER_WRITE_OVERLOAD);\n-            CSCounters.OnOverloadMetadata(writeData.GetSize());\n+            Counters.OnWriteOverloadMetadata(writeSize);\n             break;\n         case EOverloadStatus::ShardTxInFly:\n-            IncCounter(COUNTER_WRITE_OVERLOAD);\n-            CSCounters.OnOverloadShardTx(writeData.GetSize());\n+            Counters.OnWriteOverloadShardTx(writeSize);\n             break;\n         case EOverloadStatus::ShardWritesInFly:\n-            IncCounter(COUNTER_WRITE_OVERLOAD);\n-            CSCounters.OnOverloadShardWrites(writeData.GetSize());\n+            Counters.OnWriteOverloadShardWrites(writeSize);\n             break;\n         case EOverloadStatus::ShardWritesSizeInFly:\n-            IncCounter(COUNTER_WRITE_OVERLOAD);\n-            CSCounters.OnOverloadShardWritesSize(writeData.GetSize());\n+            Counters.OnWriteOverloadShardWritesSize(writeSize);\n             break;\n         case EOverloadStatus::None:\n             Y_ABORT(\"invalid function usage\");\n     }\n \n-    AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"write_overload\")(\"size\", writeData.GetSize())\n-        (\"path_id\", writeData.GetWriteMeta().GetTableId())(\"reason\", overloadReason);\n+    AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"write_overload\")(\"size\", writeSize)(\"path_id\", writeMeta.GetTableId())(\n+        \"reason\", overloadReason);\n \n-    ctx.Send(writeData.GetWriteMeta().GetSource(), event.release(), 0, cookie);\n+    ctx.Send(writeMeta.GetSource(), event.release(), 0, cookie);\n }\n \n TColumnShard::EOverloadStatus TColumnShard::CheckOverloaded(const ui64 tableId) const {\n@@ -57,7 +60,7 @@ TColumnShard::EOverloadStatus TColumnShard::CheckOverloaded(const ui64 tableId)\n         return EOverloadStatus::InsertTable;\n     }\n \n-    CSCounters.OnIndexMetadataLimit(NOlap::IColumnEngine::GetMetadataLimit());\n+    Counters.GetCSCounters().OnIndexMetadataLimit(NOlap::IColumnEngine::GetMetadataLimit());\n     if (TablesManager.GetPrimaryIndex() && TablesManager.GetPrimaryIndex()->IsOverloadedByMetadata(NOlap::IColumnEngine::GetMetadataLimit())) {\n         return EOverloadStatus::OverloadMetadata;\n     }\n@@ -66,22 +69,26 @@ TColumnShard::EOverloadStatus TColumnShard::CheckOverloaded(const ui64 tableId)\n     ui64 writesLimit = Settings.OverloadWritesInFlight;\n     ui64 writesSizeLimit = Settings.OverloadWritesSizeInFlight;\n     if (txLimit && Executor()->GetStats().TxInFly > txLimit) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"shard_overload\")(\"reason\", \"tx_in_fly\")(\"sum\", Executor()->GetStats().TxInFly)(\"limit\", txLimit);\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"shard_overload\")(\"reason\", \"tx_in_fly\")(\"sum\", Executor()->GetStats().TxInFly)(\n+            \"limit\", txLimit);\n         return EOverloadStatus::ShardTxInFly;\n     }\n-    if (writesLimit && WritesMonitor.GetWritesInFlight() > writesLimit) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"shard_overload\")(\"reason\", \"writes_in_fly\")(\"sum\", WritesMonitor.GetWritesInFlight())(\"limit\", writesLimit);\n+    if (writesLimit && Counters.GetWritesMonitor()->GetWritesInFlight() > writesLimit) {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"shard_overload\")(\"reason\", \"writes_in_fly\")(\n+            \"sum\", Counters.GetWritesMonitor()->GetWritesInFlight())(\"limit\", writesLimit);\n         return EOverloadStatus::ShardWritesInFly;\n     }\n-    if (writesSizeLimit && WritesMonitor.GetWritesSizeInFlight() > writesSizeLimit) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"shard_overload\")(\"reason\", \"writes_size_in_fly\")(\"sum\", WritesMonitor.GetWritesSizeInFlight())(\"limit\", writesSizeLimit);\n+    if (writesSizeLimit && Counters.GetWritesMonitor()->GetWritesSizeInFlight() > writesSizeLimit) {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"shard_overload\")(\"reason\", \"writes_size_in_fly\")(\n+            \"sum\", Counters.GetWritesMonitor()->GetWritesSizeInFlight())(\"limit\", writesSizeLimit);\n         return EOverloadStatus::ShardWritesSizeInFly;\n     }\n     return EOverloadStatus::None;\n }\n \n void TColumnShard::Handle(TEvPrivate::TEvWriteBlobsResult::TPtr& ev, const TActorContext& ctx) {\n-    NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"event\", \"TEvWriteBlobsResult\");\n+    NActors::TLogContextGuard gLogging =\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"event\", \"TEvWriteBlobsResult\");\n \n     auto& putResult = ev->Get()->GetPutResult();\n     OnYellowChannels(putResult);\n@@ -89,25 +96,25 @@ void TColumnShard::Handle(TEvPrivate::TEvWriteBlobsResult::TPtr& ev, const TActo\n     auto baseAggregations = wBuffer.GetAggregations();\n     wBuffer.InitReplyReceived(TMonotonic::Now());\n \n-    auto wg = WritesMonitor.FinishWrite(wBuffer.GetSumSize(), wBuffer.GetAggregations().size());\n+    Counters.GetWritesMonitor()->OnFinishWrite(wBuffer.GetSumSize(), wBuffer.GetAggregations().size());\n \n     for (auto&& aggr : baseAggregations) {\n         const auto& writeMeta = aggr->GetWriteMeta();\n \n         if (!TablesManager.IsReadyForWrite(writeMeta.GetTableId())) {\n             ACFL_ERROR(\"event\", \"absent_pathId\")(\"path_id\", writeMeta.GetTableId())(\"has_index\", TablesManager.HasPrimaryIndex());\n-            IncCounter(COUNTER_WRITE_FAIL);\n+            Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n \n             auto result = std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeMeta, NKikimrTxColumnShard::EResultStatus::ERROR);\n             ctx.Send(writeMeta.GetSource(), result.release());\n-            CSCounters.OnFailedWriteResponse(EWriteFailReason::NoTable);\n+            Counters.GetCSCounters().OnFailedWriteResponse(EWriteFailReason::NoTable);\n             wBuffer.RemoveData(aggr, StoragesManager->GetInsertOperator());\n             continue;\n         }\n \n         if (putResult.GetPutStatus() != NKikimrProto::OK) {\n-            CSCounters.OnWritePutBlobsFail(TMonotonic::Now() - writeMeta.GetWriteStartInstant());\n-            IncCounter(COUNTER_WRITE_FAIL);\n+            Counters.GetCSCounters().OnWritePutBlobsFail(TMonotonic::Now() - writeMeta.GetWriteStartInstant());\n+            Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n \n             auto errCode = NKikimrTxColumnShard::EResultStatus::STORAGE_ERROR;\n             if (putResult.GetPutStatus() == NKikimrProto::TIMEOUT || putResult.GetPutStatus() == NKikimrProto::DEADLINE) {\n@@ -122,26 +129,26 @@ void TColumnShard::Handle(TEvPrivate::TEvWriteBlobsResult::TPtr& ev, const TActo\n                 auto result = std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeMeta, errCode);\n                 ctx.Send(writeMeta.GetSource(), result.release());\n             } else {\n-                auto operation = OperationsManager->GetOperation((TWriteId)writeMeta.GetWriteId());\n+                auto operation = OperationsManager->GetOperation((TOperationWriteId)writeMeta.GetWriteId());\n                 Y_ABORT_UNLESS(operation);\n-                auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), operation->GetLockId(), NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, \n-                    ev->Get()->GetErrorMessage() ? ev->Get()->GetErrorMessage() : \"put data fails\");\n+                auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), operation->GetLockId(),\n+                    ev->Get()->GetWriteResultStatus(), ev->Get()->GetErrorMessage() ? ev->Get()->GetErrorMessage() : \"put data fails\");\n                 ctx.Send(writeMeta.GetSource(), result.release(), 0, operation->GetCookie());\n             }\n-            CSCounters.OnFailedWriteResponse(EWriteFailReason::PutBlob);\n+            Counters.GetCSCounters().OnFailedWriteResponse(EWriteFailReason::PutBlob);\n             wBuffer.RemoveData(aggr, StoragesManager->GetInsertOperator());\n         } else {\n             const TMonotonic now = TMonotonic::Now();\n-            CSCounters.OnWritePutBlobsSuccess(now - writeMeta.GetWriteStartInstant());\n-            CSCounters.OnWriteMiddle1PutBlobsSuccess(now - writeMeta.GetWriteMiddle1StartInstant());\n-            CSCounters.OnWriteMiddle2PutBlobsSuccess(now - writeMeta.GetWriteMiddle2StartInstant());\n-            CSCounters.OnWriteMiddle3PutBlobsSuccess(now - writeMeta.GetWriteMiddle3StartInstant());\n-            CSCounters.OnWriteMiddle4PutBlobsSuccess(now - writeMeta.GetWriteMiddle4StartInstant());\n-            CSCounters.OnWriteMiddle5PutBlobsSuccess(now - writeMeta.GetWriteMiddle5StartInstant());\n-            CSCounters.OnWriteMiddle6PutBlobsSuccess(now - writeMeta.GetWriteMiddle6StartInstant());\n+            Counters.OnWritePutBlobsSuccess(now - writeMeta.GetWriteStartInstant(), aggr->GetRows());\n+            Counters.GetCSCounters().OnWriteMiddle1PutBlobsSuccess(now - writeMeta.GetWriteMiddle1StartInstant());\n+            Counters.GetCSCounters().OnWriteMiddle2PutBlobsSuccess(now - writeMeta.GetWriteMiddle2StartInstant());\n+            Counters.GetCSCounters().OnWriteMiddle3PutBlobsSuccess(now - writeMeta.GetWriteMiddle3StartInstant());\n+            Counters.GetCSCounters().OnWriteMiddle4PutBlobsSuccess(now - writeMeta.GetWriteMiddle4StartInstant());\n+            Counters.GetCSCounters().OnWriteMiddle5PutBlobsSuccess(now - writeMeta.GetWriteMiddle5StartInstant());\n+            Counters.GetCSCounters().OnWriteMiddle6PutBlobsSuccess(now - writeMeta.GetWriteMiddle6StartInstant());\n             LOG_S_DEBUG(\"Write (record) into pathId \" << writeMeta.GetTableId()\n-                << (writeMeta.GetWriteId() ? (\" writeId \" + ToString(writeMeta.GetWriteId())).c_str() : \"\") << \" at tablet \" << TabletID());\n-\n+                                                      << (writeMeta.GetWriteId() ? (\" writeId \" + ToString(writeMeta.GetWriteId())).c_str() : \"\")\n+                                                      << \" at tablet \" << TabletID());\n         }\n     }\n     Execute(new TTxWrite(this, ev), ctx);\n@@ -152,8 +159,7 @@ void TColumnShard::Handle(TEvPrivate::TEvWriteDraft::TPtr& ev, const TActorConte\n }\n \n void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContext& ctx) {\n-    CSCounters.OnStartWriteRequest();\n-    LastAccessTime = TAppData::TimeProvider->Now();\n+    Counters.GetCSCounters().OnStartWriteRequest();\n \n     const auto& record = Proto(ev->Get());\n     const ui64 tableId = record.GetTableId();\n@@ -162,6 +168,8 @@ void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContex\n     const TString dedupId = record.GetDedupId();\n     const auto source = ev->Sender;\n \n+    Counters.GetColumnTablesCounters()->GetPathIdCounter(tableId)->OnWriteEvent();\n+\n     std::optional<ui32> granuleShardingVersion;\n     if (record.HasGranuleShardingVersion()) {\n         granuleShardingVersion = record.GetGranuleShardingVersion();\n@@ -176,181 +184,336 @@ void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContex\n     writeMeta.SetLongTxId(NLongTxService::TLongTxId::FromProto(record.GetLongTxId()));\n     writeMeta.SetWritePartId(record.GetWritePartId());\n \n-    const auto returnFail = [&](const NColumnShard::ECumulativeCounters signalIndex) {\n-        IncCounter(signalIndex);\n+    const auto returnFail = [&](const NColumnShard::ECumulativeCounters signalIndex, const EWriteFailReason reason) {\n+        Counters.GetTabletCounters()->IncCounter(signalIndex);\n \n         ctx.Send(source, std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeMeta, NKikimrTxColumnShard::EResultStatus::ERROR));\n+        Counters.GetCSCounters().OnFailedWriteResponse(reason);\n         return;\n     };\n \n     if (!AppDataVerified().ColumnShardConfig.GetWritingEnabled()) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_writing\")(\"reason\", \"disabled\");\n-        CSCounters.OnFailedWriteResponse(EWriteFailReason::Disabled);\n-        return returnFail(COUNTER_WRITE_FAIL);\n+        return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::Disabled);\n     }\n \n     if (!TablesManager.IsReadyForWrite(tableId)) {\n-        LOG_S_NOTICE(\"Write (fail) into pathId:\" << writeMeta.GetTableId() << (TablesManager.HasPrimaryIndex()? \"\": \" no index\")\n-            << \" at tablet \" << TabletID());\n+        LOG_S_NOTICE(\"Write (fail) into pathId:\" << writeMeta.GetTableId() << (TablesManager.HasPrimaryIndex() ? \"\" : \" no index\")\n+                                                 << \" at tablet \" << TabletID());\n+\n+        return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::NoTable);\n+    }\n+\n+    {\n+        auto& portionsIndex =\n+            TablesManager.GetPrimaryIndexAsVerified<NOlap::TColumnEngineForLogs>().GetGranuleVerified(writeMeta.GetTableId()).GetPortionsIndex();\n+        {\n+            const ui64 minMemoryRead = portionsIndex.GetMinRawMemoryRead();\n+            if (NOlap::TGlobalLimits::DefaultReduceMemoryIntervalLimit < minMemoryRead) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"overlimit\")(\"reason\", \"read_raw_memory\")(\"current\", minMemoryRead)(\n+                    \"limit\", NOlap::TGlobalLimits::DefaultReduceMemoryIntervalLimit)(\"table_id\", writeMeta.GetTableId());\n+                return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::OverlimitReadRawMemory);\n+            }\n+        }\n \n-        CSCounters.OnFailedWriteResponse(EWriteFailReason::NoTable);\n-        return returnFail(COUNTER_WRITE_FAIL);\n+        {\n+            const ui64 minMemoryRead = portionsIndex.GetMinBlobMemoryRead();\n+            if (NOlap::TGlobalLimits::DefaultBlobsMemoryIntervalLimit < minMemoryRead) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"overlimit\")(\"reason\", \"read_blob_memory\")(\"current\", minMemoryRead)(\n+                    \"limit\", NOlap::TGlobalLimits::DefaultBlobsMemoryIntervalLimit)(\"table_id\", writeMeta.GetTableId());\n+                return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::OverlimitReadBlobMemory);\n+            }\n+        }\n     }\n \n     const auto& snapshotSchema = TablesManager.GetPrimaryIndex()->GetVersionedIndex().GetLastSchema();\n     auto arrowData = std::make_shared<TProtoArrowData>(snapshotSchema);\n     if (!arrowData->ParseFromProto(record)) {\n-        LOG_S_ERROR(\"Write (fail) \" << record.GetData().size() << \" bytes into pathId \" << writeMeta.GetTableId()\n-            << \" at tablet \" << TabletID());\n-        CSCounters.OnFailedWriteResponse(EWriteFailReason::IncorrectSchema);\n-        return returnFail(COUNTER_WRITE_FAIL);\n+        LOG_S_ERROR(\n+            \"Write (fail) \" << record.GetData().size() << \" bytes into pathId \" << writeMeta.GetTableId() << \" at tablet \" << TabletID());\n+        return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::IncorrectSchema);\n     }\n \n     NEvWrite::TWriteData writeData(writeMeta, arrowData, snapshotSchema->GetIndexInfo().GetReplaceKey(),\n         StoragesManager->GetInsertOperator()->StartWritingAction(NOlap::NBlobOperations::EConsumer::WRITING));\n     auto overloadStatus = CheckOverloaded(tableId);\n     if (overloadStatus != EOverloadStatus::None) {\n-        std::unique_ptr<NActors::IEventBase> result = std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeData.GetWriteMeta(), NKikimrTxColumnShard::EResultStatus::OVERLOADED);\n-        OverloadWriteFail(overloadStatus, writeData, cookie, std::move(result), ctx);\n-        CSCounters.OnFailedWriteResponse(EWriteFailReason::Overload);\n+        std::unique_ptr<NActors::IEventBase> result = std::make_unique<TEvColumnShard::TEvWriteResult>(\n+            TabletID(), writeData.GetWriteMeta(), NKikimrTxColumnShard::EResultStatus::OVERLOADED);\n+        OverloadWriteFail(overloadStatus, writeData.GetWriteMeta(), writeData.GetSize(), cookie, std::move(result), ctx);\n+        Counters.GetCSCounters().OnFailedWriteResponse(EWriteFailReason::Overload);\n     } else {\n         if (ui64 writeId = (ui64)HasLongTxWrite(writeMeta.GetLongTxIdUnsafe(), writeMeta.GetWritePartId())) {\n-            LOG_S_DEBUG(\"Write (duplicate) into pathId \" << writeMeta.GetTableId()\n-                << \" longTx \" << writeMeta.GetLongTxIdUnsafe().ToString()\n-                << \" at tablet \" << TabletID());\n+            LOG_S_DEBUG(\"Write (duplicate) into pathId \" << writeMeta.GetTableId() << \" longTx \" << writeMeta.GetLongTxIdUnsafe().ToString()\n+                                                         << \" at tablet \" << TabletID());\n \n-            IncCounter(COUNTER_WRITE_DUPLICATE);\n+            Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_DUPLICATE);\n \n-            auto result = std::make_unique<TEvColumnShard::TEvWriteResult>(\n-                TabletID(), writeMeta, writeId, NKikimrTxColumnShard::EResultStatus::SUCCESS);\n+            auto result =\n+                std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeMeta, writeId, NKikimrTxColumnShard::EResultStatus::SUCCESS);\n             ctx.Send(writeMeta.GetSource(), result.release());\n-            CSCounters.OnFailedWriteResponse(EWriteFailReason::LongTxDuplication);\n+            Counters.GetCSCounters().OnFailedWriteResponse(EWriteFailReason::LongTxDuplication);\n             return;\n         }\n \n-        WritesMonitor.RegisterWrite(writeData.GetSize());\n+        Counters.GetWritesMonitor()->OnStartWrite(writeData.GetSize());\n \n         LOG_S_DEBUG(\"Write (blob) \" << writeData.GetSize() << \" bytes into pathId \" << writeMeta.GetTableId()\n-            << (writeMeta.GetWriteId()? (\" writeId \" + ToString(writeMeta.GetWriteId())).c_str() : \" \")\n-            << WritesMonitor.DebugString()\n-            << \" at tablet \" << TabletID());\n+                                    << (writeMeta.GetWriteId() ? (\" writeId \" + ToString(writeMeta.GetWriteId())).c_str() : \" \")\n+                                    << Counters.GetWritesMonitor()->DebugString() << \" at tablet \" << TabletID());\n         writeData.MutableWriteMeta().SetWriteMiddle1StartInstant(TMonotonic::Now());\n-        std::shared_ptr<NConveyor::ITask> task = std::make_shared<NOlap::TBuildBatchesTask>(TabletID(), SelfId(), BufferizationWriteActorId, std::move(writeData),\n-            snapshotSchema, GetLastTxSnapshot());\n+        std::shared_ptr<NConveyor::ITask> task = std::make_shared<NOlap::TBuildBatchesTask>(\n+            TabletID(), SelfId(), BufferizationWriteActorId, std::move(writeData), snapshotSchema, GetLastTxSnapshot(), Counters.GetCSCounters().WritingCounters);\n         NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);\n     }\n }\n \n class TCommitOperation {\n+private:\n+    const ui64 TabletId;\n+\n public:\n     using TPtr = std::shared_ptr<TCommitOperation>;\n \n-    bool Parse(const NEvents::TDataEvents::TEvWrite& evWrite) {\n-        if (evWrite.Record.GetLocks().GetLocks().size() != 1) {\n-            return false;\n+    bool NeedSyncLocks() const {\n+        return SendingShards.size() && ReceivingShards.size();\n+    }\n+\n+    bool IsPrimary() const {\n+        AFL_VERIFY(NeedSyncLocks());\n+        return TabletId == *ReceivingShards.begin();\n+    }\n+\n+    TCommitOperation(const ui64 tabletId)\n+        : TabletId(tabletId) {\n+    }\n+\n+    TConclusionStatus Parse(const NEvents::TDataEvents::TEvWrite& evWrite) {\n+        AFL_VERIFY(evWrite.Record.GetLocks().GetLocks().size() >= 1);\n+        auto& locks = evWrite.Record.GetLocks();\n+        auto& lock = evWrite.Record.GetLocks().GetLocks()[0];\n+        SendingShards = std::set<ui64>(locks.GetSendingShards().begin(), locks.GetSendingShards().end());\n+        if ((ui32)locks.GetSendingShards().size() != SendingShards.size()) {\n+            return TConclusionStatus::Fail(\"duplications in SendingShards proto field\");\n+        }\n+        ReceivingShards = std::set<ui64>(locks.GetReceivingShards().begin(), locks.GetReceivingShards().end());\n+        if ((ui32)locks.GetReceivingShards().size() != ReceivingShards.size()) {\n+            return TConclusionStatus::Fail(\"duplications in ReceivingShards proto field\");\n         }\n-        LockId = evWrite.Record.GetLocks().GetLocks()[0].GetLockId();\n         TxId = evWrite.Record.GetTxId();\n-        KqpLocks = evWrite.Record.GetLocks();\n-        return !!LockId && !!TxId && KqpLocks.GetOp() == NKikimrDataEvents::TKqpLocks::Commit;\n+        LockId = lock.GetLockId();\n+        Generation = lock.GetGeneration();\n+        InternalGenerationCounter = lock.GetCounter();\n+        if (!GetLockId()) {\n+            return TConclusionStatus::Fail(\"not initialized lock info in commit message\");\n+        }\n+        if (!TxId) {\n+            return TConclusionStatus::Fail(\"not initialized TxId for commit event\");\n+        }\n+        if (evWrite.Record.GetLocks().GetOp() != NKikimrDataEvents::TKqpLocks::Commit) {\n+            return TConclusionStatus::Fail(\"incorrect message type\");\n+        }\n+        if (!ReceivingShards.size() || !SendingShards.size()) {\n+            ReceivingShards.clear();\n+            SendingShards.clear();\n+        } else {\n+            if (!ReceivingShards.contains(TabletId) && !SendingShards.contains(TabletId)) {\n+                return TConclusionStatus::Fail(\"shard is incorrect for sending/receiving lists\");\n+            }\n+        }\n+        return TConclusionStatus::Success();\n+    }\n+\n+    std::unique_ptr<NColumnShard::TEvWriteCommitSyncTransactionOperator> CreateTxOperator(\n+        const NKikimrTxColumnShard::ETransactionKind kind) const {\n+        AFL_VERIFY(ReceivingShards.size());\n+        if (IsPrimary()) {\n+            return std::make_unique<NColumnShard::TEvWriteCommitPrimaryTransactionOperator>(\n+                TFullTxInfo::BuildFake(kind), LockId, ReceivingShards, SendingShards);\n+        } else {\n+            return std::make_unique<NColumnShard::TEvWriteCommitSecondaryTransactionOperator>(\n+                TFullTxInfo::BuildFake(kind), LockId, *ReceivingShards.begin(), ReceivingShards.contains(TabletId));\n+        }\n     }\n \n private:\n-    NKikimrDataEvents::TKqpLocks KqpLocks;\n     YDB_READONLY(ui64, LockId, 0);\n+    YDB_READONLY(ui64, Generation, 0);\n+    YDB_READONLY(ui64, InternalGenerationCounter, 0);\n     YDB_READONLY(ui64, TxId, 0);\n+    YDB_READONLY_DEF(std::set<ui64>, SendingShards);\n+    YDB_READONLY_DEF(std::set<ui64>, ReceivingShards);\n };\n-class TProposeWriteTransaction : public NTabletFlatExecutor::TTransactionBase<TColumnShard> {\n+\n+class TProposeWriteTransaction: public NTabletFlatExecutor::TTransactionBase<TColumnShard> {\n private:\n     using TBase = NTabletFlatExecutor::TTransactionBase<TColumnShard>;\n+\n public:\n     TProposeWriteTransaction(TColumnShard* self, TCommitOperation::TPtr op, const TActorId source, const ui64 cookie)\n         : TBase(self)\n         , WriteCommit(op)\n         , Source(source)\n-        , Cookie(cookie)\n-    {}\n+        , Cookie(cookie) {\n+    }\n+\n+    virtual bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        NKikimrTxColumnShard::TCommitWriteTxBody proto;\n+        NKikimrTxColumnShard::ETransactionKind kind;\n+        if (WriteCommit->NeedSyncLocks()) {\n+            if (WriteCommit->IsPrimary()) {\n+                kind = NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE_PRIMARY;\n+            } else {\n+                kind = NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE_SECONDARY;\n+            }\n+            proto = WriteCommit->CreateTxOperator(kind)->SerializeToProto();\n+        } else {\n+            kind = NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE;\n+        }\n+        proto.SetLockId(WriteCommit->GetLockId());\n+        TxOperator = Self->GetProgressTxController().StartProposeOnExecute(\n+            TTxController::TTxInfo(kind, WriteCommit->GetTxId(), Source, Cookie, {}), proto.SerializeAsString(), txc);\n+        return true;\n+    }\n \n-    bool Execute(TTransactionContext& txc, const TActorContext& ctx) override;\n-    void Complete(const TActorContext& ctx) override;\n-    TTxType GetTxType() const override { return TXTYPE_PROPOSE; }\n+    virtual void Complete(const TActorContext& ctx) override {\n+        Self->GetProgressTxController().FinishProposeOnComplete(WriteCommit->GetTxId(), ctx);\n+    }\n+    TTxType GetTxType() const override {\n+        return TXTYPE_PROPOSE;\n+    }\n \n private:\n     TCommitOperation::TPtr WriteCommit;\n     TActorId Source;\n     ui64 Cookie;\n+    std::shared_ptr<TTxController::ITransactionOperator> TxOperator;\n };\n \n-bool TProposeWriteTransaction::Execute(TTransactionContext& txc, const TActorContext&) {\n-    NKikimrTxColumnShard::TCommitWriteTxBody proto;\n-    proto.SetLockId(WriteCommit->GetLockId());\n-    TString txBody;\n-    Y_ABORT_UNLESS(proto.SerializeToString(&txBody));\n-    Y_UNUSED(Self->GetProgressTxController().StartProposeOnExecute(\n-        TTxController::TTxInfo(NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE, WriteCommit->GetTxId(), Source, Cookie, {}), txBody, txc));\n-    return true;\n-}\n+class TAbortWriteTransaction: public NTabletFlatExecutor::TTransactionBase<TColumnShard> {\n+private:\n+    using TBase = NTabletFlatExecutor::TTransactionBase<TColumnShard>;\n \n-void TProposeWriteTransaction::Complete(const TActorContext& ctx) {\n-    Self->GetProgressTxController().FinishProposeOnComplete(WriteCommit->GetTxId(), ctx);\n-}\n+public:\n+    TAbortWriteTransaction(TColumnShard* self, const ui64 txId, const TActorId source, const ui64 cookie)\n+        : TBase(self)\n+        , TxId(txId)\n+        , Source(source)\n+        , Cookie(cookie) {\n+    }\n+\n+    virtual bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        Self->GetOperationsManager().AbortTransactionOnExecute(*Self, TxId, txc);\n+        return true;\n+    }\n+\n+    virtual void Complete(const TActorContext& ctx) override {\n+        Self->GetOperationsManager().AbortTransactionOnComplete(*Self, TxId);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildCompleted(Self->TabletID(), TxId);\n+        ctx.Send(Source, result.release(), 0, Cookie);\n+    }\n+    TTxType GetTxType() const override {\n+        return TXTYPE_PROPOSE;\n+    }\n+\n+private:\n+    ui64 TxId;\n+    TActorId Source;\n+    ui64 Cookie;\n+};\n \n void TColumnShard::Handle(NEvents::TDataEvents::TEvWrite::TPtr& ev, const TActorContext& ctx) {\n-    NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"event\", \"TEvWrite\");\n+    NActors::TLogContextGuard gLogging =\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletID())(\"event\", \"TEvWrite\");\n \n     const auto& record = ev->Get()->Record;\n     const auto source = ev->Sender;\n     const auto cookie = ev->Cookie;\n-    const auto behaviour = TOperationsManager::GetBehaviour(*ev->Get());\n-\n-    if (behaviour == EOperationBehaviour::Undefined) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"invalid write event\");\n+    const auto behaviourConclusion = TOperationsManager::GetBehaviour(*ev->Get());\n+    //    AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"ev_write\", record.DebugString());\n+    if (behaviourConclusion.IsFail()) {\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST,\n+            \"invalid write event: \" + behaviourConclusion.GetErrorMessage());\n         ctx.Send(source, result.release(), 0, cookie);\n         return;\n     }\n+    auto behaviour = *behaviourConclusion;\n+\n+    if (behaviour == EOperationBehaviour::AbortWriteLock) {\n+        Execute(new TAbortWriteTransaction(this, record.GetLocks().GetLocks()[0].GetLockId(), source, cookie), ctx);\n+        return;\n+    }\n \n     if (behaviour == EOperationBehaviour::CommitWriteLock) {\n-        auto commitOperation = std::make_shared<TCommitOperation>();\n-        if (!commitOperation->Parse(*ev->Get())) {\n-            IncCounter(COUNTER_WRITE_FAIL);\n-            auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"invalid commit event\");\n+        auto commitOperation = std::make_shared<TCommitOperation>(TabletID());\n+        const auto sendError = [&](const TString& message, const NKikimrDataEvents::TEvWriteResult::EStatus status) {\n+            Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+            auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, status, message);\n             ctx.Send(source, result.release(), 0, cookie);\n+        };\n+        auto conclusionParse = commitOperation->Parse(*ev->Get());\n+        if (conclusionParse.IsFail()) {\n+            sendError(conclusionParse.GetErrorMessage(), NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST);\n+        } else {\n+            if (commitOperation->NeedSyncLocks()) {\n+                auto* lockInfo = OperationsManager->GetLockOptional(commitOperation->GetLockId());\n+                if (!lockInfo) {\n+                    sendError(\"haven't lock for commit: \" + ::ToString(commitOperation->GetLockId()),\n+                        NKikimrDataEvents::TEvWriteResult::STATUS_ABORTED);\n+                } else {\n+                    if (lockInfo->GetGeneration() != commitOperation->GetGeneration()) {\n+                        sendError(\"tablet lock have another generation: \" + ::ToString(lockInfo->GetGeneration()) +\n+                                      \" != \" + ::ToString(commitOperation->GetGeneration()),\n+                            NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN);\n+                    } else if (lockInfo->GetInternalGenerationCounter() != commitOperation->GetInternalGenerationCounter()) {\n+                        sendError(\n+                            \"tablet lock have another internal generation counter: \" + ::ToString(lockInfo->GetInternalGenerationCounter()) +\n+                                \" != \" + ::ToString(commitOperation->GetInternalGenerationCounter()),\n+                            NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN);\n+                    } else {\n+                        Execute(new TProposeWriteTransaction(this, commitOperation, source, cookie), ctx);\n+                    }\n+                }\n+            } else {\n+                Execute(new TProposeWriteTransaction(this, commitOperation, source, cookie), ctx);\n+            }\n         }\n-        Execute(new TProposeWriteTransaction(this, commitOperation, source, cookie), ctx);\n         return;\n     }\n \n-    const ui64 lockId = (behaviour == EOperationBehaviour::InTxWrite) ? record.GetTxId() : record.GetLockTxId();\n-\n     if (record.GetOperations().size() != 1) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"only single operation is supported\");\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+            TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"only single operation is supported\");\n         ctx.Send(source, result.release(), 0, cookie);\n         return;\n     }\n \n     const auto& operation = record.GetOperations()[0];\n-    const std::optional<NEvWrite::EModificationType> mType = TEnumOperator<NEvWrite::EModificationType>::DeserializeFromProto(operation.GetType());\n+    const std::optional<NEvWrite::EModificationType> mType =\n+        TEnumOperator<NEvWrite::EModificationType>::DeserializeFromProto(operation.GetType());\n     if (!mType) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST,\n             \"operation \" + NKikimrDataEvents::TEvWrite::TOperation::EOperationType_Name(operation.GetType()) + \" is not supported\");\n         ctx.Send(source, result.release(), 0, cookie);\n         return;\n     }\n \n     if (!operation.GetTableId().HasSchemaVersion()) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"schema version not set\");\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+            TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"schema version not set\");\n         ctx.Send(source, result.release(), 0, cookie);\n         return;\n     }\n \n     auto schema = TablesManager.GetPrimaryIndex()->GetVersionedIndex().GetSchema(operation.GetTableId().GetSchemaVersion());\n     if (!schema) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"unknown schema version\");\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+            TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"unknown schema version\");\n         ctx.Send(source, result.release(), 0, cookie);\n         return;\n     }\n@@ -358,38 +521,50 @@ void TColumnShard::Handle(NEvents::TDataEvents::TEvWrite::TPtr& ev, const TActor\n     const auto tableId = operation.GetTableId().GetTableId();\n \n     if (!TablesManager.IsReadyForWrite(tableId)) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, \"table not writable\");\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+            TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, \"table not writable\");\n         ctx.Send(source, result.release(), 0, cookie);\n         return;\n     }\n \n     auto arrowData = std::make_shared<TArrowData>(schema);\n     if (!arrowData->Parse(operation, NEvWrite::TPayloadReader<NEvents::TDataEvents::TEvWrite>(*ev->Get()))) {\n-        IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"parsing data error\");\n+        Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+            TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST, \"parsing data error\");\n         ctx.Send(source, result.release(), 0, cookie);\n     }\n \n     auto overloadStatus = CheckOverloaded(tableId);\n     if (overloadStatus != EOverloadStatus::None) {\n-        NEvWrite::TWriteData writeData(NEvWrite::TWriteMeta(0, tableId, source, {}), arrowData, nullptr, nullptr);\n-        std::unique_ptr<NActors::IEventBase> result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED, \"overload data error\");\n-        OverloadWriteFail(overloadStatus, writeData, cookie, std::move(result), ctx);\n+        std::unique_ptr<NActors::IEventBase> result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+            TabletID(), 0, NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED, \"overload data error\");\n+        OverloadWriteFail(overloadStatus, NEvWrite::TWriteMeta(0, tableId, source, {}), arrowData->GetSize(), cookie, std::move(result), ctx);\n         return;\n     }\n \n-    auto wg = WritesMonitor.RegisterWrite(arrowData->GetSize());\n+    Counters.GetWritesMonitor()->OnStartWrite(arrowData->GetSize());\n \n     std::optional<ui32> granuleShardingVersionId;\n     if (record.HasGranuleShardingVersionId()) {\n         granuleShardingVersionId = record.GetGranuleShardingVersionId();\n     }\n \n+    ui64 lockId = 0;\n+    if (behaviour == EOperationBehaviour::NoTxWrite) {\n+        lockId = BuildEphemeralTxId();\n+    } else if (behaviour == EOperationBehaviour::InTxWrite) {\n+        lockId = record.GetTxId();\n+    } else {\n+        lockId = record.GetLockTxId();\n+    }\n+\n+    OperationsManager->RegisterLock(lockId, Generation());\n     auto writeOperation = OperationsManager->RegisterOperation(lockId, cookie, granuleShardingVersionId, *mType);\n     Y_ABORT_UNLESS(writeOperation);\n     writeOperation->SetBehaviour(behaviour);\n     writeOperation->Start(*this, tableId, arrowData, source, schema, ctx);\n }\n \n-}\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/columnshard__write_index.cpp b/ydb/core/tx/columnshard/columnshard__write_index.cpp\nindex 69d54a68d1bd..27497b4e8fc6 100644\n--- a/ydb/core/tx/columnshard/columnshard__write_index.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__write_index.cpp\n@@ -41,7 +41,7 @@ void TColumnShard::Handle(TEvPrivate::TEvWriteIndex::TPtr& ev, const TActorConte\n         if (IsAnyChannelYellowStop()) {\n             ACFL_ERROR(\"event\", \"TEvWriteIndex failed\")(\"reason\", \"channel yellow stop\");\n \n-            IncCounter(COUNTER_OUT_OF_SPACE);\n+            Counters.GetTabletCounters()->IncCounter(COUNTER_OUT_OF_SPACE);\n             ev->Get()->SetPutStatus(NKikimrProto::TRYLATER);\n             NOlap::TChangesFinishContext context(\"out of disk space\");\n             ev->Get()->IndexChanges->Abort(*this, context);\ndiff --git a/ydb/core/tx/columnshard/columnshard_common.cpp b/ydb/core/tx/columnshard/columnshard_common.cpp\ndeleted file mode 100644\nindex d9f0dcc5e79b..000000000000\n--- a/ydb/core/tx/columnshard/columnshard_common.cpp\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-#include \"columnshard_common.h\"\n-#include <ydb/core/formats/arrow/arrow_batch_builder.h>\n-\n-namespace NKikimr::NColumnShard {\n-\n-namespace {\n-\n-using EOperation = NArrow::EOperation;\n-using EAggregate = NArrow::EAggregate;\n-using TAssign = NSsa::TAssign;\n-using TAggregateAssign = NSsa::TAggregateAssign;\n-\n-}\n-\n-using EOperation = NArrow::EOperation;\n-using TPredicate = NOlap::TPredicate;\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/columnshard_common.h b/ydb/core/tx/columnshard/columnshard_common.h\ndeleted file mode 100644\nindex 455f39a512cc..000000000000\n--- a/ydb/core/tx/columnshard/columnshard_common.h\n+++ /dev/null\n@@ -1,94 +0,0 @@\n-#pragma once\n-#include \"engines/reader/common/description.h\"\n-#include \"engines/predicate/predicate.h\"\n-\n-#include <library/cpp/cache/cache.h>\n-\n-namespace NKikimr::NOlap {\n-    struct TIndexInfo;\n-}\n-\n-namespace NKikimr::NColumnShard {\n-\n-using TReadDescription = NOlap::NReader::TReadDescription;\n-using IColumnResolver = NOlap::IColumnResolver;\n-using NOlap::TWriteId;\n-\n-class TBatchCache {\n-public:\n-    using TUnifiedBlobId = NOlap::TUnifiedBlobId;\n-    using TInsertedBatch = std::pair<TUnifiedBlobId, std::shared_ptr<arrow::RecordBatch>>;\n-\n-    static constexpr ui32 MAX_COMMITTED_COUNT = 2 * TLimits::MIN_SMALL_BLOBS_TO_INSERT;\n-    static constexpr ui32 MAX_INSERTED_COUNT = 2 * TLimits::MIN_SMALL_BLOBS_TO_INSERT;\n-    static constexpr ui64 MAX_TOTAL_SIZE = 2 * TLimits::MIN_BYTES_TO_INSERT;\n-\n-    TBatchCache()\n-        : Inserted(MAX_INSERTED_COUNT)\n-        , Committed(MAX_COMMITTED_COUNT)\n-    {}\n-\n-    void Insert(TWriteId writeId, const TUnifiedBlobId& blobId, const std::shared_ptr<arrow::RecordBatch>& batch) {\n-        if (Bytes() + blobId.BlobSize() > MAX_TOTAL_SIZE) {\n-            return;\n-        }\n-        InsertedBytes += blobId.BlobSize();\n-        Inserted.Insert(writeId, {blobId, batch});\n-    }\n-\n-    void Commit(TWriteId writeId) {\n-        auto it = Inserted.FindWithoutPromote(writeId);\n-        if (it != Inserted.End()) {\n-            auto& blobId = it->first;\n-            InsertedBytes -= blobId.BlobSize();\n-            CommittedBytes += blobId.BlobSize();\n-\n-            Committed.Insert(blobId, it->second);\n-            Inserted.Erase(it);\n-        }\n-    }\n-\n-    void EraseInserted(TWriteId writeId) {\n-        auto it = Inserted.FindWithoutPromote(writeId);\n-        if (it != Inserted.End()) {\n-            InsertedBytes -= (*it).first.BlobSize();\n-            Inserted.Erase(it);\n-        }\n-    }\n-\n-    void EraseCommitted(const TUnifiedBlobId& blobId) {\n-        auto it = Committed.FindWithoutPromote(blobId);\n-        if (it != Committed.End()) {\n-            CommittedBytes -= blobId.BlobSize();\n-            Committed.Erase(it);\n-        }\n-    }\n-\n-    TInsertedBatch GetInserted(TWriteId writeId) const {\n-        auto it = Inserted.Find(writeId);\n-        if (it != Inserted.End()) {\n-            return *it;\n-        }\n-        return {};\n-    }\n-\n-    std::shared_ptr<arrow::RecordBatch> Get(const TUnifiedBlobId& blobId) const {\n-        auto it = Committed.Find(blobId);\n-        if (it != Committed.End()) {\n-            return *it;\n-        }\n-        return {};\n-    }\n-\n-    ui64 Bytes() const {\n-        return InsertedBytes + CommittedBytes;\n-    }\n-\n-private:\n-    mutable TLRUCache<TWriteId, TInsertedBatch> Inserted;\n-    mutable TLRUCache<TUnifiedBlobId, std::shared_ptr<arrow::RecordBatch>> Committed;\n-    ui64 InsertedBytes{0};\n-    ui64 CommittedBytes{0};\n-};\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/columnshard_impl.cpp b/ydb/core/tx/columnshard/columnshard_impl.cpp\nindex 2bc73b8ee418..9f1c7a10859d 100644\n--- a/ydb/core/tx/columnshard/columnshard_impl.cpp\n+++ b/ydb/core/tx/columnshard/columnshard_impl.cpp\n@@ -28,6 +28,7 @@\n #include \"engines/changes/ttl.h\"\n \n #include \"resource_subscriber/counters.h\"\n+#include \"transactions/operators/ev_write/sync.h\"\n \n #include \"bg_tasks/adapter/adapter.h\"\n #include \"bg_tasks/manager/manager.h\"\n@@ -41,6 +42,7 @@\n #include <ydb/services/metadata/service.h>\n #include <ydb/core/tx/tiering/manager.h>\n #include <ydb/core/tx/conveyor/usage/service.h>\n+#include <ydb/core/engine/minikql/flat_local_tx_factory.h>\n \n namespace NKikimr::NColumnShard {\n \n@@ -64,33 +66,26 @@ NTabletPipe::TClientConfig GetPipeClientConfig() {\n \n TColumnShard::TColumnShard(TTabletStorageInfo* info, const TActorId& tablet)\n     : TActor(&TThis::StateInit)\n-    , TTabletExecutedFlat(info, tablet, nullptr)\n+    , TTabletExecutedFlat(info, tablet, new NMiniKQL::TMiniKQLFactory)\n+    , TabletCountersHolder(new TProtobufTabletCounters<ESimpleCounters_descriptor, ECumulativeCounters_descriptor,\n+          EPercentileCounters_descriptor, ETxTypes_descriptor>())\n+    , Counters(*TabletCountersHolder)\n     , ProgressTxController(std::make_unique<TTxController>(*this))\n     , StoragesManager(std::make_shared<NOlap::TStoragesManager>(*this))\n     , DataLocksManager(std::make_shared<NOlap::NDataLocks::TManager>())\n-    , PeriodicWakeupActivationPeriod(NYDBTest::TControllers::GetColumnShardController()->GetPeriodicWakeupActivationPeriod(TSettings::DefaultPeriodicWakeupActivationPeriod))\n-    , StatsReportInterval(NYDBTest::TControllers::GetColumnShardController()->GetStatsReportInterval(TSettings::DefaultStatsReportInterval))\n-    , InFlightReadsTracker(StoragesManager)\n+    , PeriodicWakeupActivationPeriod(NYDBTest::TControllers::GetColumnShardController()->GetPeriodicWakeupActivationPeriod())\n+    , StatsReportInterval(NYDBTest::TControllers::GetColumnShardController()->GetStatsReportInterval())\n+    , InFlightReadsTracker(StoragesManager, Counters.GetRequestsTracingCounters())\n     , TablesManager(StoragesManager, info->TabletID)\n     , Subscribers(std::make_shared<NSubscriber::TManager>(*this))\n     , PipeClientCache(NTabletPipe::CreateBoundedClientCache(new NTabletPipe::TBoundedClientCacheConfig(), GetPipeClientConfig()))\n     , InsertTable(std::make_unique<NOlap::TInsertTable>())\n-    , SubscribeCounters(std::make_shared<NOlap::NResourceBroker::NSubscribe::TSubscriberCounters>())\n-    , InsertTaskSubscription(NOlap::TInsertColumnEngineChanges::StaticTypeName(), SubscribeCounters)\n-    , CompactTaskSubscription(NOlap::TCompactColumnEngineChanges::StaticTypeName(), SubscribeCounters)\n-    , TTLTaskSubscription(NOlap::TTTLColumnEngineChanges::StaticTypeName(), SubscribeCounters)\n-    , ScanCounters(\"Scan\")\n-    , WritesMonitor(*this)\n-    , NormalizerController(StoragesManager, SubscribeCounters)\n-    , SysLocks(this)\n-{\n-    TabletCountersPtr.reset(new TProtobufTabletCounters<\n-        ESimpleCounters_descriptor,\n-        ECumulativeCounters_descriptor,\n-        EPercentileCounters_descriptor,\n-        ETxTypes_descriptor\n-    >());\n-    TabletCounters = TabletCountersPtr.get();\n+    , InsertTaskSubscription(NOlap::TInsertColumnEngineChanges::StaticTypeName(), Counters.GetSubscribeCounters())\n+    , CompactTaskSubscription(NOlap::TCompactColumnEngineChanges::StaticTypeName(), Counters.GetSubscribeCounters())\n+    , TTLTaskSubscription(NOlap::TTTLColumnEngineChanges::StaticTypeName(), Counters.GetSubscribeCounters())\n+    , BackgroundController(Counters.GetBackgroundControllerCounters())\n+    , NormalizerController(StoragesManager, Counters.GetSubscribeCounters())\n+    , SysLocks(this) {\n }\n \n void TColumnShard::OnDetach(const TActorContext& ctx) {\n@@ -191,74 +186,71 @@ ui64 TColumnShard::GetOutdatedStep() const {\n     return step;\n }\n \n-ui64 TColumnShard::GetMinReadStep() const {\n-    const TDuration maxReadStaleness = NYDBTest::TControllers::GetColumnShardController()->GetReadTimeoutClean(TDuration::Minutes(5));\n-    ui64 delayMillisec = maxReadStaleness.MilliSeconds();\n+NOlap::TSnapshot TColumnShard::GetMinReadSnapshot() const {\n+    ui64 delayMillisec = GetMaxReadStaleness().MilliSeconds();\n     ui64 passedStep = GetOutdatedStep();\n     ui64 minReadStep = (passedStep > delayMillisec ? passedStep - delayMillisec : 0);\n-    return minReadStep;\n+\n+    if (auto ssClean = InFlightReadsTracker.GetSnapshotToClean()) {\n+        if (ssClean->GetPlanStep() < minReadStep) {\n+            Counters.GetRequestsTracingCounters()->OnDefaultMinSnapshotInstant(TInstant::MilliSeconds(ssClean->GetPlanStep()));\n+            return *ssClean;\n+        }\n+    }\n+    Counters.GetRequestsTracingCounters()->OnDefaultMinSnapshotInstant(TInstant::MilliSeconds(minReadStep));\n+    return NOlap::TSnapshot::MaxForPlanStep(minReadStep);\n }\n \n-TWriteId TColumnShard::HasLongTxWrite(const NLongTxService::TLongTxId& longTxId, const ui32 partId) const {\n+TInsertWriteId TColumnShard::HasLongTxWrite(const NLongTxService::TLongTxId& longTxId, const ui32 partId) const {\n     auto it = LongTxWritesByUniqueId.find(longTxId.UniqueId);\n     if (it != LongTxWritesByUniqueId.end()) {\n         auto itPart = it->second.find(partId);\n         if (itPart != it->second.end()) {\n-            return (TWriteId)itPart->second->WriteId;\n+            return itPart->second->InsertWriteId;\n         }\n     }\n-    return (TWriteId)0;\n+    return (TInsertWriteId)0;\n }\n \n-TWriteId TColumnShard::GetLongTxWrite(NIceDb::TNiceDb& db, const NLongTxService::TLongTxId& longTxId, const ui32 partId, const std::optional<ui32> granuleShardingVersionId) {\n+TInsertWriteId TColumnShard::GetLongTxWrite(NIceDb::TNiceDb& db, const NLongTxService::TLongTxId& longTxId, const ui32 partId, const std::optional<ui32> granuleShardingVersionId) {\n     auto it = LongTxWritesByUniqueId.find(longTxId.UniqueId);\n     if (it != LongTxWritesByUniqueId.end()) {\n         auto itPart = it->second.find(partId);\n         if (itPart != it->second.end()) {\n-            return (TWriteId)itPart->second->WriteId;\n+            return itPart->second->InsertWriteId;\n         }\n     } else {\n         it = LongTxWritesByUniqueId.emplace(longTxId.UniqueId, TPartsForLTXShard()).first;\n     }\n \n-    TWriteId writeId = BuildNextWriteId(db);\n-    auto& lw = LongTxWrites[writeId];\n-    lw.WriteId = (ui64)writeId;\n+    TInsertWriteId insertWriteId = InsertTable->BuildNextWriteId(db);\n+    auto& lw = LongTxWrites[insertWriteId];\n+    lw.InsertWriteId = insertWriteId;\n     lw.WritePartId = partId;\n     lw.LongTxId = longTxId;\n     lw.GranuleShardingVersionId = granuleShardingVersionId;\n     it->second[partId] = &lw;\n \n-    Schema::SaveLongTxWrite(db, writeId, partId, longTxId, granuleShardingVersionId);\n-    return writeId;\n-}\n-\n-TWriteId TColumnShard::BuildNextWriteId(NTabletFlatExecutor::TTransactionContext& txc) {\n-    NIceDb::TNiceDb db(txc.DB);\n-    return BuildNextWriteId(db);\n+    Schema::SaveLongTxWrite(db, insertWriteId, partId, longTxId, granuleShardingVersionId);\n+    return insertWriteId;\n }\n \n-TWriteId TColumnShard::BuildNextWriteId(NIceDb::TNiceDb& db) {\n-    TWriteId writeId = ++LastWriteId;\n-    Schema::SaveSpecialValue(db, Schema::EValueIds::LastWriteId, (ui64)writeId);\n-    return writeId;\n+void TColumnShard::AddLongTxWrite(const TInsertWriteId writeId, ui64 txId) {\n+    auto it = LongTxWrites.find(writeId);\n+    AFL_VERIFY(it != LongTxWrites.end());\n+    it->second.PreparedTxId = txId;\n }\n \n-void TColumnShard::AddLongTxWrite(TWriteId writeId, ui64 txId) {\n-    auto& lw = LongTxWrites.at(writeId);\n-    lw.PreparedTxId = txId;\n-}\n-\n-void TColumnShard::LoadLongTxWrite(TWriteId writeId, const ui32 writePartId, const NLongTxService::TLongTxId& longTxId, const std::optional<ui32> granuleShardingVersion) {\n+void TColumnShard::LoadLongTxWrite(const TInsertWriteId writeId, const ui32 writePartId, const NLongTxService::TLongTxId& longTxId, const std::optional<ui32> granuleShardingVersion) {\n     auto& lw = LongTxWrites[writeId];\n     lw.WritePartId = writePartId;\n-    lw.WriteId = (ui64)writeId;\n+    lw.InsertWriteId = writeId;\n     lw.LongTxId = longTxId;\n     lw.GranuleShardingVersionId = granuleShardingVersion;\n     LongTxWritesByUniqueId[longTxId.UniqueId][writePartId] = &lw;\n }\n \n-bool TColumnShard::RemoveLongTxWrite(NIceDb::TNiceDb& db, const TWriteId writeId, const ui64 txId) {\n+bool TColumnShard::RemoveLongTxWrite(NIceDb::TNiceDb& db, const TInsertWriteId writeId, const ui64 txId) {\n     if (auto* lw = LongTxWrites.FindPtr(writeId)) {\n         ui64 prepared = lw->PreparedTxId;\n         if (!prepared || txId == prepared) {\n@@ -272,15 +264,16 @@ bool TColumnShard::RemoveLongTxWrite(NIceDb::TNiceDb& db, const TWriteId writeId\n             return true;\n         } else {\n             AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_remove_prepared_tx_insertion\")(\"write_id\", (ui64)writeId)(\"tx_id\", txId);\n+            return false;\n         }\n     } else {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_remove_removed_tx_insertion\")(\"write_id\", (ui64)writeId)(\"tx_id\", txId);\n+        return true;\n     }\n-    return false;\n }\n \n-void TColumnShard::TryAbortWrites(NIceDb::TNiceDb& db, NOlap::TDbWrapper& dbTable, THashSet<TWriteId>&& writesToAbort) {\n-    std::vector<TWriteId> failedAborts;\n+void TColumnShard::TryAbortWrites(NIceDb::TNiceDb& db, NOlap::TDbWrapper& dbTable, THashSet<TInsertWriteId>&& writesToAbort) {\n+    std::vector<TInsertWriteId> failedAborts;\n     for (auto& writeId : writesToAbort) {\n         if (!RemoveLongTxWrite(db, writeId, 0)) {\n             failedAborts.push_back(writeId);\n@@ -426,9 +419,9 @@ void TColumnShard::RunEnsureTable(const NKikimrTxColumnShard::TCreateTable& tabl\n \n     TablesManager.AddTableVersion(pathId, version, tableVerProto, db, Tiers);\n \n-    SetCounter(COUNTER_TABLES, TablesManager.GetTables().size());\n-    SetCounter(COUNTER_TABLE_PRESETS, TablesManager.GetSchemaPresets().size());\n-    SetCounter(COUNTER_TABLE_TTLS, TablesManager.GetTtl().PathsCount());\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_TABLES, TablesManager.GetTables().size());\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_TABLE_PRESETS, TablesManager.GetSchemaPresets().size());\n+    Counters.GetTabletCounters()->SetCounter(COUNTER_TABLE_TTLS, TablesManager.GetTtl().PathsCount());\n }\n \n void TColumnShard::RunAlterTable(const NKikimrTxColumnShard::TAlterTable& alterProto, const NOlap::TSnapshot& version,\n@@ -476,13 +469,6 @@ void TColumnShard::RunDropTable(const NKikimrTxColumnShard::TDropTable& dropProt\n \n     LOG_S_DEBUG(\"DropTable for pathId: \" << pathId << \" at tablet \" << TabletID());\n     TablesManager.DropTable(pathId, version, db);\n-\n-    // TODO: Allow to read old snapshots after DROP\n-    TBlobGroupSelector dsGroupSelector(Info());\n-    NOlap::TDbWrapper dbTable(txc.DB, &dsGroupSelector);\n-    THashSet<TWriteId> writesToAbort = InsertTable->DropPath(dbTable, pathId);\n-\n-    TryAbortWrites(db, dbTable, std::move(writesToAbort));\n }\n \n void TColumnShard::RunAlterStore(const NKikimrTxColumnShard::TAlterStore& proto, const NOlap::TSnapshot& version,\n@@ -514,7 +500,7 @@ void TColumnShard::EnqueueBackgroundActivities(const bool periodic) {\n     ACFL_DEBUG(\"event\", \"EnqueueBackgroundActivities\")(\"periodic\", periodic);\n     StoragesManager->GetOperatorVerified(NOlap::IStoragesManager::DefaultStorageId);\n     StoragesManager->GetSharedBlobsManager()->GetStorageManagerVerified(NOlap::IStoragesManager::DefaultStorageId);\n-    CSCounters.OnStartBackground();\n+    Counters.GetCSCounters().OnStartBackground();\n \n     if (!TablesManager.HasPrimaryIndex()) {\n         AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)(\"problem\", \"Background activities cannot be started: no index at tablet\");\n@@ -635,13 +621,16 @@ class TTTLChangesReadTask: public TChangesReadTask, public TMonitoringObjectsCou\n     using TBase::TBase;\n };\n \n-void TColumnShard::StartIndexTask(std::vector<const NOlap::TInsertedData*>&& dataToIndex, const i64 bytesToIndex) {\n-    CSCounters.IndexationInput(bytesToIndex);\n+void TColumnShard::StartIndexTask(std::vector<const NOlap::TCommittedData*>&& dataToIndex, const i64 bytesToIndex) {\n+    Counters.GetCSCounters().IndexationInput(bytesToIndex);\n \n-    std::vector<NOlap::TInsertedData> data;\n+    std::vector<NOlap::TCommittedData> data;\n     data.reserve(dataToIndex.size());\n     for (auto& ptr : dataToIndex) {\n         data.push_back(*ptr);\n+        if (!TablesManager.HasTable(data.back().GetPathId())) {\n+            data.back().SetRemove();\n+        }\n     }\n \n     Y_ABORT_UNLESS(data.size());\n@@ -658,7 +647,8 @@ void TColumnShard::StartIndexTask(std::vector<const NOlap::TInsertedData*>&& dat\n \n     NOlap::NResourceBroker::NSubscribe::ITask::StartResourceSubscription(\n         ResourceSubscribeActor, std::make_shared<NOlap::NBlobOperations::NRead::ITask::TReadSubscriber>(\n-                                std::make_shared<TInsertChangesReadTask>(std::move(ev), SelfId(), TabletID(), IndexationCounters, GetLastCompletedTx()), 0, indexChanges->CalcMemoryForUsage(), externalTaskId, InsertTaskSubscription));\n+                                std::make_shared<TInsertChangesReadTask>(std::move(ev), SelfId(), TabletID(), Counters.GetIndexationCounters(), GetLastCompletedTx()),\n+                                0, indexChanges->CalcMemoryForUsage(), externalTaskId, InsertTaskSubscription));\n }\n \n void TColumnShard::SetupIndexation() {\n@@ -678,8 +668,8 @@ void TColumnShard::SetupIndexation() {\n     if (InsertTable->GetPathPriorities().size() && InsertTable->GetPathPriorities().rbegin()->first.GetCategory() == NOlap::TPathInfoIndexPriority::EIndexationPriority::PreventOverload) {\n         force = true;\n     }\n-    const ui64 bytesLimit = NYDBTest::TControllers::GetColumnShardController()->GetGuaranteeIndexationStartBytesLimit(TSettings::GuaranteeIndexationStartBytesLimit);\n-    const TDuration durationLimit = NYDBTest::TControllers::GetColumnShardController()->GetGuaranteeIndexationInterval(TSettings::GuaranteeIndexationInterval);\n+    const ui64 bytesLimit = NYDBTest::TControllers::GetColumnShardController()->GetGuaranteeIndexationStartBytesLimit();\n+    const TDuration durationLimit = NYDBTest::TControllers::GetColumnShardController()->GetGuaranteeIndexationInterval();\n     if (!force && InsertTable->GetCountersCommitted().Bytes < bytesLimit &&\n         TMonotonic::Now() < BackgroundController.GetLastIndexationInstant() + durationLimit) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_indexation\")(\"reason\", \"not_enough_data_and_too_frequency\")\n@@ -688,10 +678,10 @@ void TColumnShard::SetupIndexation() {\n     }\n \n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start_indexation_tasks\")(\"insert_overload_size\", InsertTable->GetCountersCommitted().Bytes);\n-    CSCounters.OnSetupIndexation();\n+    Counters.GetCSCounters().OnSetupIndexation();\n     ui64 bytesToIndex = 0;\n     ui64 txBytesWrite = 0;\n-    std::vector<const NOlap::TInsertedData*> dataToIndex;\n+    std::vector<const NOlap::TCommittedData*> dataToIndex;\n     dataToIndex.reserve(TLimits::MIN_SMALL_BLOBS_TO_INSERT);\n     for (auto it = InsertTable->GetPathPriorities().rbegin(); it != InsertTable->GetPathPriorities().rend(); ++it) {\n         for (auto* pathInfo : it->second) {\n@@ -719,7 +709,7 @@ void TColumnShard::SetupCompaction() {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_compaction\")(\"reason\", \"disabled\");\n         return;\n     }\n-    CSCounters.OnSetupCompaction();\n+    Counters.GetCSCounters().OnSetupCompaction();\n \n     BackgroundController.CheckDeadlines();\n     while (BackgroundController.GetCompactionsCount() < TSettings::MAX_ACTIVE_COMPACTIONS) {\n@@ -738,7 +728,7 @@ void TColumnShard::SetupCompaction() {\n \n         NOlap::NResourceBroker::NSubscribe::ITask::StartResourceSubscription(\n             ResourceSubscribeActor, std::make_shared<NOlap::NBlobOperations::NRead::ITask::TReadSubscriber>(\n-                std::make_shared<TCompactChangesReadTask>(std::move(ev), SelfId(), TabletID(), CompactionCounters, GetLastCompletedTx()), 0, indexChanges->CalcMemoryForUsage(), externalTaskId, CompactTaskSubscription));\n+                std::make_shared<TCompactChangesReadTask>(std::move(ev), SelfId(), TabletID(), Counters.GetCompactionCounters(), GetLastCompletedTx()), 0, indexChanges->CalcMemoryForUsage(), externalTaskId, CompactTaskSubscription));\n     }\n \n     LOG_S_DEBUG(\"ActiveCompactions: \" << BackgroundController.GetCompactionsCount() << \" at tablet \" << TabletID());\n@@ -749,7 +739,7 @@ bool TColumnShard::SetupTtl(const THashMap<ui64, NOlap::TTiering>& pathTtls) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_ttl\")(\"reason\", \"disabled\");\n         return false;\n     }\n-    CSCounters.OnSetupTtl();\n+    Counters.GetCSCounters().OnSetupTtl();\n     THashMap<ui64, NOlap::TTiering> eviction = pathTtls;\n     for (auto&& i : eviction) {\n         ACFL_DEBUG(\"background\", \"ttl\")(\"path\", i.first)(\"info\", i.second.GetDebugString());\n@@ -773,7 +763,8 @@ bool TColumnShard::SetupTtl(const THashMap<ui64, NOlap::TTiering>& pathTtls) {\n         if (needWrites) {\n             NOlap::NResourceBroker::NSubscribe::ITask::StartResourceSubscription(\n                 ResourceSubscribeActor, std::make_shared<NOlap::NBlobOperations::NRead::ITask::TReadSubscriber>(\n-                    std::make_shared<TTTLChangesReadTask>(std::move(ev), SelfId(), TabletID(), CompactionCounters, GetLastCompletedTx()), 0, i->CalcMemoryForUsage(), externalTaskId, TTLTaskSubscription));\n+                    std::make_shared<TTTLChangesReadTask>(std::move(ev), SelfId(), TabletID(), Counters.GetCompactionCounters(), GetLastCompletedTx()),\n+                    0, i->CalcMemoryForUsage(), externalTaskId, TTLTaskSubscription));\n         } else {\n             ev->SetPutStatus(NKikimrProto::OK);\n             ActorContext().Send(SelfId(), std::move(ev));\n@@ -783,7 +774,7 @@ bool TColumnShard::SetupTtl(const THashMap<ui64, NOlap::TTiering>& pathTtls) {\n }\n \n void TColumnShard::SetupCleanupPortions() {\n-    CSCounters.OnSetupCleanup();\n+    Counters.GetCSCounters().OnSetupCleanup();\n     if (!AppDataVerified().ColumnShardConfig.GetCleanupEnabled() || !NYDBTest::TControllers::GetColumnShardController()->IsBackgroundEnabled(NYDBTest::ICSController::EBackground::Cleanup)) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_cleanup\")(\"reason\", \"disabled\");\n         return;\n@@ -793,9 +784,8 @@ void TColumnShard::SetupCleanupPortions() {\n         return;\n     }\n \n-    NOlap::TSnapshot cleanupSnapshot{GetMinReadStep(), 0};\n-\n-    auto changes = TablesManager.MutablePrimaryIndex().StartCleanupPortions(cleanupSnapshot, TablesManager.GetPathsToDrop(), DataLocksManager);\n+    auto changes =\n+        TablesManager.MutablePrimaryIndex().StartCleanupPortions(GetMinReadSnapshot(), TablesManager.GetPathsToDrop(), DataLocksManager);\n     if (!changes) {\n         ACFL_DEBUG(\"background\", \"cleanup\")(\"skip_reason\", \"no_changes\");\n         return;\n@@ -812,13 +802,21 @@ void TColumnShard::SetupCleanupPortions() {\n }\n \n void TColumnShard::SetupCleanupTables() {\n-    CSCounters.OnSetupCleanup();\n+    Counters.GetCSCounters().OnSetupCleanup();\n     if (BackgroundController.IsCleanupTablesActive()) {\n         ACFL_DEBUG(\"background\", \"cleanup\")(\"skip_reason\", \"in_progress\");\n         return;\n     }\n \n-    auto changes = TablesManager.MutablePrimaryIndex().StartCleanupTables(TablesManager.MutablePathsToDrop());\n+    THashSet<ui64> pathIdsEmptyInInsertTable;\n+    for (auto&& i : TablesManager.GetPathsToDrop()) {\n+        if (InsertTable->HasPathIdData(i)) {\n+            continue;\n+        }\n+        pathIdsEmptyInInsertTable.emplace(i);\n+    }\n+\n+    auto changes = TablesManager.MutablePrimaryIndex().StartCleanupTables(pathIdsEmptyInInsertTable);\n     if (!changes) {\n         ACFL_DEBUG(\"background\", \"cleanup\")(\"skip_reason\", \"no_changes\");\n         return;\n@@ -890,6 +888,39 @@ void TColumnShard::Handle(NActors::TEvents::TEvUndelivered::TPtr& ev, const TAct\n     }\n }\n \n+void TColumnShard::Handle(TEvTxProcessing::TEvReadSet::TPtr& ev, const TActorContext& ctx) {\n+    const ui64 txId = ev->Get()->Record.GetTxId();\n+    if (!GetProgressTxController().GetTxOperatorOptional(txId)) {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"read_set_ignored\")(\"proto\", ev->Get()->Record.DebugString());\n+        Send(MakePipePerNodeCacheID(false),\n+            new TEvPipeCache::TEvForward(\n+                new TEvTxProcessing::TEvReadSetAck(0, txId, TabletID(), ev->Get()->Record.GetTabletProducer(), TabletID(), 0),\n+                ev->Get()->Record.GetTabletProducer(), true),\n+            IEventHandle::FlagTrackDelivery, txId);\n+        return;\n+    }\n+    auto op = GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSyncTransactionOperator>(txId);\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"read_set\")(\"proto\", ev->Get()->Record.DebugString())(\"lock_id\", op->GetLockId());\n+    NKikimrTx::TReadSetData data;\n+    AFL_VERIFY(data.ParseFromArray(ev->Get()->Record.GetReadSet().data(), ev->Get()->Record.GetReadSet().size()));\n+    auto tx = op->CreateReceiveBrokenFlagTx(\n+        *this, ev->Get()->Record.GetTabletProducer(), data.GetDecision() != NKikimrTx::TReadSetData::DECISION_COMMIT);\n+    Execute(tx.release(), ctx);\n+}\n+\n+void TColumnShard::Handle(TEvTxProcessing::TEvReadSetAck::TPtr& ev, const TActorContext& ctx) {\n+    auto opPtr = GetProgressTxController().GetTxOperatorOptional(ev->Get()->Record.GetTxId());\n+    if (!opPtr) {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"missed_read_set_ack\")(\"proto\", ev->Get()->Record.DebugString())(\n+            \"tx_id\", ev->Get()->Record.GetTxId());\n+        return;\n+    }\n+    auto op = TValidator::CheckNotNull(dynamic_pointer_cast<TEvWriteCommitSyncTransactionOperator>(opPtr));\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"read_set_ack\")(\"proto\", ev->Get()->Record.DebugString())(\"lock_id\", op->GetLockId());\n+    auto tx = op->CreateReceiveResultAckTx(*this, ev->Get()->Record.GetTabletConsumer());\n+    Execute(tx.release(), ctx);\n+}\n+\n void TColumnShard::Handle(NOlap::NDataSharing::NEvents::TEvProposeFromInitiator::TPtr& ev, const TActorContext& ctx) {\n     AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)(\"process\", \"BlobsSharing\")(\"event\", \"TEvProposeFromInitiator\");\n     auto reqSession = std::make_shared<NOlap::NDataSharing::TDestinationSession>();\n@@ -1142,4 +1173,8 @@ const NKikimr::NColumnShard::NTiers::TManager* TColumnShard::GetTierManagerPoint\n     return Tiers->GetManagerOptional(tierId);\n }\n \n+TDuration TColumnShard::GetMaxReadStaleness() {\n+    return NYDBTest::TControllers::GetColumnShardController()->GetReadTimeoutClean();\n+}\n+\n }\ndiff --git a/ydb/core/tx/columnshard/columnshard_impl.h b/ydb/core/tx/columnshard/columnshard_impl.h\nindex 2fefad7e9e1a..74e8e335f3ed 100644\n--- a/ydb/core/tx/columnshard/columnshard_impl.h\n+++ b/ydb/core/tx/columnshard/columnshard_impl.h\n@@ -3,7 +3,6 @@\n #include \"background_controller.h\"\n #include \"counters.h\"\n #include \"columnshard.h\"\n-#include \"columnshard_common.h\"\n #include \"columnshard_ttl.h\"\n #include \"columnshard_private_events.h\"\n #include \"tables_manager.h\"\n@@ -13,9 +12,11 @@\n #include \"transactions/tx_controller.h\"\n #include \"inflight_request_tracker.h\"\n #include \"counters/columnshard.h\"\n+#include \"counters/counters_manager.h\"\n #include \"resource_subscriber/counters.h\"\n #include \"resource_subscriber/task.h\"\n #include \"normalizer/abstract/abstract.h\"\n+#include \"operations/manager.h\"\n \n #include \"export/events/events.h\"\n \n@@ -202,6 +203,8 @@ class TColumnShard\n     void Handle(TEvTabletPipe::TEvClientDestroyed::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvTabletPipe::TEvServerConnected::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvTabletPipe::TEvServerDisconnected::TPtr& ev, const TActorContext& ctx);\n+    void Handle(TEvTxProcessing::TEvReadSet::TPtr& ev, const TActorContext& ctx);\n+    void Handle(TEvTxProcessing::TEvReadSetAck::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvColumnShard::TEvProposeTransaction::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvColumnShard::TEvCheckPlannedTransaction::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvColumnShard::TEvCancelTransactionProposal::TPtr& ev, const TActorContext& ctx);\n@@ -216,6 +219,9 @@ class TColumnShard\n     void Handle(TEvPrivate::TEvScanStats::TPtr &ev, const TActorContext &ctx);\n     void Handle(TEvPrivate::TEvReadFinished::TPtr &ev, const TActorContext &ctx);\n     void Handle(TEvPrivate::TEvPeriodicWakeup::TPtr& ev, const TActorContext& ctx);\n+    void Handle(NActors::TEvents::TEvWakeup::TPtr& ev, const TActorContext& ctx);\n+    void Handle(TEvPrivate::TEvPingSnapshotsUsage::TPtr& ev, const TActorContext& ctx);\n+\n     void Handle(TEvPrivate::TEvWriteIndex::TPtr& ev, const TActorContext& ctx);\n     void Handle(NMetadata::NProvider::TEvRefreshSubscriberData::TPtr& ev);\n     void Handle(NEvents::TDataEvents::TEvWrite::TPtr& ev, const TActorContext& ctx);\n@@ -275,17 +281,16 @@ class TColumnShard\n         putStatus.OnYellowChannels(Executor());\n     }\n \n-    void SetCounter(NColumnShard::ESimpleCounters counter, ui64 num) const {\n-        TabletCounters->Simple()[counter].Set(num);\n-    }\n-\n-    void IncCounter(NColumnShard::ECumulativeCounters counter, ui64 num = 1) const {\n-        TabletCounters->Cumulative()[counter].Increment(num);\n-    }\n-\n     void ActivateTiering(const ui64 pathId, const TString& useTiering);\n     void OnTieringModified(const std::optional<ui64> pathId = {});\n+\n public:\n+    ui64 BuildEphemeralTxId() {\n+        static TAtomicCounter Counter = 0;\n+        static constexpr ui64 shift = (ui64)1 << 47;\n+        return shift | Counter.Inc();\n+    }\n+\n     enum class EOverloadStatus {\n         ShardTxInFly /* \"shard_tx\" */,\n         ShardWritesInFly /* \"shard_writes\" */,\n@@ -296,25 +301,17 @@ class TColumnShard\n         None /* \"none\" */\n     };\n \n-    void IncCounter(NColumnShard::EPercentileCounters counter, const TDuration& latency) const {\n-        TabletCounters->Percentile()[counter].IncrementFor(latency.MicroSeconds());\n-    }\n-\n-    void IncCounter(NDataShard::ESimpleCounters counter, ui64 num = 1) const {\n-        TabletCounters->Simple()[counter].Add(num);\n-    }\n-\n     // For syslocks\n     void IncCounter(NDataShard::ECumulativeCounters counter, ui64 num = 1) const {\n-        TabletCounters->Cumulative()[counter].Increment(num);\n+        Counters.GetTabletCounters()->IncCounter(counter, num);\n     }\n \n     void IncCounter(NDataShard::EPercentileCounters counter, ui64 num) const {\n-        TabletCounters->Percentile()[counter].IncrementFor(num);\n+        Counters.GetTabletCounters()->IncCounter(counter, num);\n     }\n \n     void IncCounter(NDataShard::EPercentileCounters counter, const TDuration& latency) const {\n-        TabletCounters->Percentile()[counter].IncrementFor(latency.MilliSeconds());\n+        Counters.GetTabletCounters()->IncCounter(counter, latency);\n     }\n \n     inline TRowVersion LastCompleteTxVersion() const {\n@@ -328,7 +325,7 @@ class TColumnShard\n     }\n \n private:\n-    void OverloadWriteFail(const EOverloadStatus overloadReason, const NEvWrite::TWriteData& writeData, const ui64 cookie, std::unique_ptr<NActors::IEventBase>&& event, const TActorContext& ctx);\n+    void OverloadWriteFail(const EOverloadStatus overloadReason, const NEvWrite::TWriteMeta& writeMeta, const ui64 writeSize, const ui64 cookie, std::unique_ptr<NActors::IEventBase>&& event, const TActorContext& ctx);\n     EOverloadStatus CheckOverloaded(const ui64 tableId) const;\n \n protected:\n@@ -356,6 +353,9 @@ class TColumnShard\n         switch (ev->GetTypeRewrite()) {\n             hFunc(NMetadata::NProvider::TEvRefreshSubscriberData, Handle);\n \n+            HFunc(TEvTxProcessing::TEvReadSet, Handle);\n+            HFunc(TEvTxProcessing::TEvReadSetAck, Handle);\n+\n             HFunc(TEvTabletPipe::TEvClientConnected, Handle);\n             HFunc(TEvTabletPipe::TEvClientDestroyed, Handle);\n             HFunc(TEvTabletPipe::TEvServerConnected, Handle);\n@@ -375,6 +375,9 @@ class TColumnShard\n             HFunc(TEvPrivate::TEvScanStats, Handle);\n             HFunc(TEvPrivate::TEvReadFinished, Handle);\n             HFunc(TEvPrivate::TEvPeriodicWakeup, Handle);\n+            HFunc(NActors::TEvents::TEvWakeup, Handle);\n+            HFunc(TEvPrivate::TEvPingSnapshotsUsage, Handle);\n+            \n             HFunc(NEvents::TDataEvents::TEvWrite, Handle);\n             HFunc(TEvPrivate::TEvWriteDraft, Handle);\n             HFunc(TEvPrivate::TEvGarbageCollectionFinished, Handle);\n@@ -408,6 +411,9 @@ class TColumnShard\n     }\n \n private:\n+    std::unique_ptr<TTabletCountersBase> TabletCountersHolder;\n+    TCountersManager Counters;\n+\n     std::unique_ptr<TTxController> ProgressTxController;\n     std::unique_ptr<TOperationsManager> OperationsManager;\n     std::shared_ptr<NOlap::NDataSharing::TSessionsManager> SharingSessionsManager;\n@@ -418,68 +424,20 @@ class TColumnShard\n     using TSchemaPreset = TSchemaPreset;\n     using TTableInfo = TTableInfo;\n \n+    const TMonotonic CreateInstant = TMonotonic::Now();\n+    std::optional<TMonotonic> StartInstant;\n+\n     struct TLongTxWriteInfo {\n-        ui64 WriteId;\n+        TInsertWriteId InsertWriteId;\n         ui32 WritePartId;\n         NLongTxService::TLongTxId LongTxId;\n         ui64 PreparedTxId = 0;\n         std::optional<ui32> GranuleShardingVersionId;\n     };\n \n-    class TWritesMonitor {\n-    private:\n-        TColumnShard& Owner;\n-        YDB_READONLY(ui64, WritesInFlight, 0);\n-        YDB_READONLY(ui64, WritesSizeInFlight, 0);\n-\n-    public:\n-        class TGuard: public TNonCopyable {\n-            friend class TWritesMonitor;\n-        private:\n-            TWritesMonitor& Owner;\n-\n-            explicit TGuard(TWritesMonitor& owner)\n-                : Owner(owner)\n-            {}\n-\n-        public:\n-            ~TGuard() {\n-                Owner.UpdateCounters();\n-            }\n-        };\n-\n-        TWritesMonitor(TColumnShard& owner)\n-            : Owner(owner)\n-        {}\n-\n-        TGuard RegisterWrite(const ui64 dataSize) {\n-            ++WritesInFlight;\n-            WritesSizeInFlight += dataSize;\n-            return TGuard(*this);\n-        }\n-\n-        TGuard FinishWrite(const ui64 dataSize, const ui32 writesCount = 1) {\n-            Y_ABORT_UNLESS(WritesInFlight > 0);\n-            Y_ABORT_UNLESS(WritesSizeInFlight >= dataSize);\n-            WritesInFlight -= writesCount;\n-            WritesSizeInFlight -= dataSize;\n-            return TGuard(*this);\n-        }\n-\n-        TString DebugString() const {\n-            return TStringBuilder() << \"{object=write_monitor;count=\" << WritesInFlight << \";size=\" << WritesSizeInFlight << \"}\";\n-        }\n-\n-    private:\n-        void UpdateCounters() {\n-            Owner.SetCounter(COUNTER_WRITES_IN_FLY, WritesInFlight);\n-        }\n-    };\n-\n     ui64 CurrentSchemeShardId = 0;\n     TMessageSeqNo LastSchemaSeqNo;\n     std::optional<NKikimrSubDomains::TProcessingParams> ProcessingParams;\n-    TWriteId LastWriteId = TWriteId{0};\n     ui64 LastPlannedStep = 0;\n     ui64 LastPlannedTxId = 0;\n     NOlap::TSnapshot LastCompletedTx = NOlap::TSnapshot::Zero();\n@@ -495,35 +453,26 @@ class TColumnShard\n     const TDuration PeriodicWakeupActivationPeriod;\n     TDuration FailActivationDelay = TDuration::Seconds(1);\n     const TDuration StatsReportInterval;\n-    TInstant LastAccessTime;\n     TInstant LastStatsReport;\n \n     TActorId ResourceSubscribeActor;\n     TActorId BufferizationWriteActorId;\n     TActorId StatsReportPipe;\n+    std::vector<TActorId> ActorsToStop;\n \n     TInFlightReadsTracker InFlightReadsTracker;\n     TTablesManager TablesManager;\n     std::shared_ptr<NSubscriber::TManager> Subscribers;\n     std::shared_ptr<TTiersManager> Tiers;\n-    std::unique_ptr<TTabletCountersBase> TabletCountersPtr;\n-    TTabletCountersBase* TabletCounters;\n     std::unique_ptr<NTabletPipe::IClientCache> PipeClientCache;\n     std::unique_ptr<NOlap::TInsertTable> InsertTable;\n-    std::shared_ptr<NOlap::NResourceBroker::NSubscribe::TSubscriberCounters> SubscribeCounters;\n     NOlap::NResourceBroker::NSubscribe::TTaskContext InsertTaskSubscription;\n     NOlap::NResourceBroker::NSubscribe::TTaskContext CompactTaskSubscription;\n     NOlap::NResourceBroker::NSubscribe::TTaskContext TTLTaskSubscription;\n-    const TScanCounters ScanCounters;\n-    const TIndexationCounters CompactionCounters = TIndexationCounters(\"GeneralCompaction\");\n-    const TIndexationCounters IndexationCounters = TIndexationCounters(\"Indexation\");\n-    const TIndexationCounters EvictionCounters = TIndexationCounters(\"Eviction\");\n-\n-    const TCSCounters CSCounters;\n-    TWritesMonitor WritesMonitor;\n-    bool ProgressTxInFlight = false;\n+\n+    std::optional<ui64> ProgressTxInFlight;\n     THashMap<ui64, TInstant> ScanTxInFlight;\n-    THashMap<TWriteId, TLongTxWriteInfo> LongTxWrites;\n+    THashMap<TInsertWriteId, TLongTxWriteInfo> LongTxWrites;\n     using TPartsForLTXShard = THashMap<ui32, TLongTxWriteInfo*>;\n     THashMap<TULID, TPartsForLTXShard> LongTxWritesByUniqueId;\n     TMultiMap<NOlap::TSnapshot, TEvColumnShard::TEvScan::TPtr> WaitingScans;\n@@ -532,32 +481,29 @@ class TColumnShard\n     TLimits Limits;\n     NOlap::TNormalizationController NormalizerController;\n     NDataShard::TSysLocks SysLocks;\n+    static TDuration GetMaxReadStaleness();\n \n     void TryRegisterMediatorTimeCast();\n     void UnregisterMediatorTimeCast();\n-    void TryAbortWrites(NIceDb::TNiceDb& db, NOlap::TDbWrapper& dbTable, THashSet<TWriteId>&& writesToAbort);\n+    void TryAbortWrites(NIceDb::TNiceDb& db, NOlap::TDbWrapper& dbTable, THashSet<TInsertWriteId>&& writesToAbort);\n \n     bool WaitPlanStep(ui64 step);\n     void SendWaitPlanStep(ui64 step);\n     void RescheduleWaitingReads();\n     NOlap::TSnapshot GetMaxReadVersion() const;\n-    ui64 GetMinReadStep() const;\n+    NOlap::TSnapshot GetMinReadSnapshot() const;\n     ui64 GetOutdatedStep() const;\n     TDuration GetTxCompleteLag() const {\n         ui64 mediatorTime = MediatorTimeCastEntry ? MediatorTimeCastEntry->Get(TabletID()) : 0;\n         return ProgressTxController->GetTxCompleteLag(mediatorTime);\n     }\n \n-    TWriteId HasLongTxWrite(const NLongTxService::TLongTxId& longTxId, const ui32 partId) const;\n-    TWriteId GetLongTxWrite(NIceDb::TNiceDb& db, const NLongTxService::TLongTxId& longTxId, const ui32 partId, const std::optional<ui32> granuleShardingVersionId);\n-    void AddLongTxWrite(TWriteId writeId, ui64 txId);\n-    void LoadLongTxWrite(TWriteId writeId, const ui32 writePartId, const NLongTxService::TLongTxId& longTxId, const std::optional<ui32> granuleShardingVersion);\n-    bool RemoveLongTxWrite(NIceDb::TNiceDb& db, const TWriteId writeId, const ui64 txId);\n+    TInsertWriteId HasLongTxWrite(const NLongTxService::TLongTxId& longTxId, const ui32 partId) const;\n+    TInsertWriteId GetLongTxWrite(NIceDb::TNiceDb& db, const NLongTxService::TLongTxId& longTxId, const ui32 partId, const std::optional<ui32> granuleShardingVersionId);\n+    void AddLongTxWrite(const TInsertWriteId writeId, ui64 txId);\n+    void LoadLongTxWrite(const TInsertWriteId writeId, const ui32 writePartId, const NLongTxService::TLongTxId& longTxId, const std::optional<ui32> granuleShardingVersion);\n+    bool RemoveLongTxWrite(NIceDb::TNiceDb& db, const TInsertWriteId writeId, const ui64 txId);\n \n-    TWriteId BuildNextWriteId(NTabletFlatExecutor::TTransactionContext& txc);\n-    TWriteId BuildNextWriteId(NIceDb::TNiceDb& db);\n-\n-    void EnqueueProgressTx(const TActorContext& ctx);\n     void EnqueueBackgroundActivities(const bool periodic = false);\n     virtual void Enqueue(STFUNC_SIG) override;\n \n@@ -571,7 +517,7 @@ class TColumnShard\n     void RunDropTable(const NKikimrTxColumnShard::TDropTable& body, const NOlap::TSnapshot& version, NTabletFlatExecutor::TTransactionContext& txc);\n     void RunAlterStore(const NKikimrTxColumnShard::TAlterStore& body, const NOlap::TSnapshot& version, NTabletFlatExecutor::TTransactionContext& txc);\n \n-    void StartIndexTask(std::vector<const NOlap::TInsertedData*>&& dataToIndex, const i64 bytesToIndex);\n+    void StartIndexTask(std::vector<const NOlap::TCommittedData*>&& dataToIndex, const i64 bytesToIndex);\n     void SetupIndexation();\n     void SetupCompaction();\n     bool SetupTtl(const THashMap<ui64, NOlap::TTiering>& pathTtls = {});\n@@ -588,12 +534,14 @@ class TColumnShard\n     void SendPeriodicStats();\n     void FillOlapStats(const TActorContext& ctx, std::unique_ptr<TEvDataShard::TEvPeriodicTableStats>& ev);\n     void FillColumnTableStats(const TActorContext& ctx, std::unique_ptr<TEvDataShard::TEvPeriodicTableStats>& ev);\n-    void ConfigureStats(const NOlap::TColumnEngineStats& indexStats, ::NKikimrTableStats::TTableStats* tabletStats);\n-    void FillTxTableStats(::NKikimrTableStats::TTableStats* tableStats) const;\n \n public:\n     ui64 TabletTxCounter = 0;\n \n+    bool HasLongTxWrites(const TInsertWriteId insertWriteId) const {\n+        return LongTxWrites.contains(insertWriteId);\n+    }\n+    void EnqueueProgressTx(const TActorContext& ctx, const std::optional<ui64> continueTxId);\n     NOlap::TSnapshot GetLastTxSnapshot() const {\n         return NOlap::TSnapshot(LastPlannedStep, LastPlannedTxId);\n     }\n@@ -621,6 +569,11 @@ class TColumnShard\n         return *ProgressTxController;\n     }\n \n+    TOperationsManager& GetOperationsManager() const {\n+        AFL_VERIFY(OperationsManager);\n+        return *OperationsManager;\n+    }\n+\n     bool HasIndex() const {\n         return !!TablesManager.GetPrimaryIndex();\n     }\ndiff --git a/ydb/core/tx/columnshard/columnshard_private_events.h b/ydb/core/tx/columnshard/columnshard_private_events.h\nindex da31b1938e5a..cb0e8cd97150 100644\n--- a/ydb/core/tx/columnshard/columnshard_private_events.h\n+++ b/ydb/core/tx/columnshard/columnshard_private_events.h\n@@ -46,6 +46,7 @@ struct TEvPrivate {\n         EvExportSaveCursor,\n \n         EvTaskProcessedResult,\n+        EvPingSnapshotsUsage,\n \n         EvEnd\n     };\n@@ -142,8 +143,9 @@ struct TEvPrivate {\n \n     struct TEvReadFinished : public TEventLocal<TEvReadFinished, EvReadFinished> {\n         explicit TEvReadFinished(ui64 requestCookie, ui64 txId = 0)\n-            : RequestCookie(requestCookie), TxId(txId)\n-        {}\n+            : RequestCookie(requestCookie)\n+            , TxId(txId) {\n+        }\n \n         ui64 RequestCookie;\n         ui64 TxId;\n@@ -157,17 +159,39 @@ struct TEvPrivate {\n         bool Manual;\n     };\n \n-    class TEvWriteBlobsResult : public TEventLocal<TEvWriteBlobsResult, EvWriteBlobsResult> {\n+    struct TEvPingSnapshotsUsage: public TEventLocal<TEvPingSnapshotsUsage, EvPingSnapshotsUsage> {\n+        TEvPingSnapshotsUsage() = default;\n+    };\n+\n+    class TEvWriteBlobsResult: public TEventLocal<TEvWriteBlobsResult, EvWriteBlobsResult> {\n+    public:\n+        enum EErrorClass {\n+            Internal,\n+            Request\n+        };\n     private:\n         NColumnShard::TBlobPutResult::TPtr PutResult;\n         NOlap::TWritingBuffer WritesBuffer;\n         YDB_READONLY_DEF(TString, ErrorMessage);\n+        YDB_ACCESSOR(EErrorClass, ErrorClass, EErrorClass::Internal);\n+\n     public:\n+\n+        NKikimrDataEvents::TEvWriteResult::EStatus GetWriteResultStatus() const {\n+            switch (ErrorClass) {\n+                case EErrorClass::Internal:\n+                    return NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR;\n+                case EErrorClass::Request:\n+                    return NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST;\n+            }\n+        }\n         \n-        static std::unique_ptr<TEvWriteBlobsResult> Error(const NKikimrProto::EReplyStatus status, NOlap::TWritingBuffer&& writesBuffer, const TString& error) {\n-            std::unique_ptr<TEvWriteBlobsResult> result = std::make_unique<TEvWriteBlobsResult>(std::make_shared<NColumnShard::TBlobPutResult>(status), \n-                std::move(writesBuffer));\n+        static std::unique_ptr<TEvWriteBlobsResult> Error(\n+            const NKikimrProto::EReplyStatus status, NOlap::TWritingBuffer&& writesBuffer, const TString& error, const EErrorClass errorClass) {\n+            std::unique_ptr<TEvWriteBlobsResult> result =\n+                std::make_unique<TEvWriteBlobsResult>(std::make_shared<NColumnShard::TBlobPutResult>(status), std::move(writesBuffer));\n             result->ErrorMessage = error;\n+            result->ErrorClass = errorClass;\n             return result;\n         }\n \ndiff --git a/ydb/core/tx/columnshard/columnshard_schema.cpp b/ydb/core/tx/columnshard/columnshard_schema.cpp\nindex 3d9dc8e7a9b0..c9a60029a892 100644\n--- a/ydb/core/tx/columnshard/columnshard_schema.cpp\n+++ b/ydb/core/tx/columnshard/columnshard_schema.cpp\n@@ -4,51 +4,24 @@\n namespace NKikimr::NColumnShard {\n \n bool Schema::InsertTable_Load(NIceDb::TNiceDb& db, const IBlobGroupSelector* dsGroupSelector, NOlap::TInsertTableAccessor& insertTable, const TInstant& /*loadTime*/) {\n-    auto rowset = db.Table<InsertTable>().GreaterOrEqual(0, 0, 0, 0, \"\").Select();\n+    auto rowset = db.Table<InsertTable>().Select();\n     if (!rowset.IsReady()) {\n         return false;\n     }\n \n     while (!rowset.EndOfSet()) {\n-        EInsertTableIds recType = (EInsertTableIds)rowset.GetValue<InsertTable::Committed>();\n-        ui64 planStep = rowset.GetValue<InsertTable::PlanStep>();\n-        ui64 writeTxId = rowset.GetValueOrDefault<InsertTable::WriteTxId>();\n-        ui64 pathId = rowset.GetValue<InsertTable::PathId>();\n-        TString dedupId = rowset.GetValue<InsertTable::DedupId>();\n-        TString strBlobId = rowset.GetValue<InsertTable::BlobId>();\n-        TString metaStr = rowset.GetValue<InsertTable::Meta>();\n-        ui64 schemaVersion = rowset.HaveValue<InsertTable::SchemaVersion>() ? rowset.GetValue<InsertTable::SchemaVersion>() : 0;\n+        NOlap::TInsertTableRecordLoadContext constructor;\n+        constructor.ParseFromDatabase(rowset);\n \n-        TString error;\n-        NOlap::TUnifiedBlobId blobId = NOlap::TUnifiedBlobId::ParseFromString(strBlobId, dsGroupSelector, error);\n-        Y_ABORT_UNLESS(blobId.IsValid(), \"Failied to parse blob id: %s\", error.c_str());\n-\n-        NKikimrTxColumnShard::TLogicalMetadata meta;\n-        if (metaStr) {\n-            Y_ABORT_UNLESS(meta.ParseFromString(metaStr));\n-        }\n-\n-        std::optional<ui64> rangeOffset;\n-        if (rowset.HaveValue<InsertTable::BlobRangeOffset>()) {\n-            rangeOffset = rowset.GetValue<InsertTable::BlobRangeOffset>();\n-        }\n-        std::optional<ui64> rangeSize;\n-        if (rowset.HaveValue<InsertTable::BlobRangeSize>()) {\n-            rangeSize = rowset.GetValue<InsertTable::BlobRangeSize>();\n-        }\n-\n-        AFL_VERIFY(!!rangeOffset == !!rangeSize);\n-        TInsertedData data(planStep, writeTxId, pathId, dedupId, NOlap::TBlobRange(blobId, rangeOffset.value_or(0), rangeSize.value_or(blobId.BlobSize())), meta, schemaVersion, {});\n-\n-        switch (recType) {\n-            case EInsertTableIds::Inserted:\n-                insertTable.AddInserted(std::move(data), true);\n+        switch (constructor.GetRecType()) {\n+            case Schema::EInsertTableIds::Inserted:\n+                insertTable.AddInserted(constructor.BuildInsertedOrAborted(dsGroupSelector), true);\n                 break;\n-            case EInsertTableIds::Committed:\n-                insertTable.AddCommitted(std::move(data), true);\n+            case Schema::EInsertTableIds::Committed:\n+                insertTable.AddCommitted(constructor.BuildCommitted(dsGroupSelector), true);\n                 break;\n-            case EInsertTableIds::Aborted:\n-                insertTable.AddAborted(std::move(data), true);\n+            case Schema::EInsertTableIds::Aborted:\n+                insertTable.AddAborted(constructor.BuildInsertedOrAborted(dsGroupSelector), true);\n                 break;\n         }\n         if (!rowset.Next()) {\n@@ -59,6 +32,7 @@ bool Schema::InsertTable_Load(NIceDb::TNiceDb& db, const IBlobGroupSelector* dsG\n }\n \n void Schema::SaveTxInfo(NIceDb::TNiceDb& db, const TFullTxInfo& txInfo, const TString& txBody) {\n+    AFL_VERIFY(txInfo.TxKind != NKikimrTxColumnShard::TX_KIND_NONE);\n     db.Table<TxInfo>().Key(txInfo.TxId).Update(\n         NIceDb::TUpdate<TxInfo::TxKind>(txInfo.TxKind),\n         NIceDb::TUpdate<TxInfo::TxBody>(txBody),\n@@ -70,11 +44,14 @@ void Schema::SaveTxInfo(NIceDb::TNiceDb& db, const TFullTxInfo& txInfo, const TS\n }\n \n void Schema::UpdateTxInfoSource(NIceDb::TNiceDb& db, const TFullTxInfo& txInfo) {\n-    db.Table<TxInfo>().Key(txInfo.GetTxId()).Update(\n-        NIceDb::TUpdate<TxInfo::Source>(txInfo.Source),\n-        NIceDb::TUpdate<TxInfo::Cookie>(txInfo.Cookie),\n-        NIceDb::TUpdate<TxInfo::SeqNo>(txInfo.SerializeSeqNoAsString())\n-    );\n+    db.Table<TxInfo>()\n+        .Key(txInfo.GetTxId())\n+        .Update(NIceDb::TUpdate<TxInfo::Source>(txInfo.Source), NIceDb::TUpdate<TxInfo::Cookie>(txInfo.Cookie),\n+            NIceDb::TUpdate<TxInfo::SeqNo>(txInfo.SerializeSeqNoAsString()));\n }\n \n+void Schema::UpdateTxInfoBody(NIceDb::TNiceDb& db, const ui64 txId, const TString& txBody) {\n+    db.Table<TxInfo>().Key(txId).Update(NIceDb::TUpdate<TxInfo::TxBody>(txBody));\n }\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/columnshard_schema.h b/ydb/core/tx/columnshard/columnshard_schema.h\nindex fd1da16940ef..8b104b9dcd58 100644\n--- a/ydb/core/tx/columnshard/columnshard_schema.h\n+++ b/ydb/core/tx/columnshard/columnshard_schema.h\n@@ -17,7 +17,7 @@ class TColumnChunkLoadContext;\n \n namespace NKikimr::NColumnShard {\n \n-using NOlap::TWriteId;\n+using NOlap::TInsertWriteId;\n using NOlap::IBlobGroupSelector;\n struct TFullTxInfo;\n \n@@ -31,6 +31,7 @@ struct Schema : NIceDb::Schema {\n     using TSettings = SchemaSettings<EmptySettings>;\n \n     using TInsertedData = NOlap::TInsertedData;\n+    using TCommittedData = NOlap::TCommittedData;\n     using TColumnRecord = NOlap::TColumnRecord;\n \n     enum EIndexTables : ui32 {\n@@ -108,7 +109,11 @@ struct Schema : NIceDb::Schema {\n         TableVersionInfo = 11,\n         SmallBlobs = 12,\n         OneToOneEvictedBlobs = 13,\n-        BlobsToDeleteWT = 14\n+        BlobsToDeleteWT = 14,\n+        InFlightSnapshots = 15,\n+        TxDependencies = 16,\n+        TxStates = 17,\n+        TxEvents = 18\n     };\n \n     // Tablet tables\n@@ -250,6 +255,40 @@ struct Schema : NIceDb::Schema {\n         using TColumns = TableColumns<BlobId, TabletId>;\n     };\n \n+    struct InFlightSnapshots: Table<(ui32)ECommonTables::InFlightSnapshots> {\n+        struct PlanStep: Column<1, NScheme::NTypeIds::Uint64> {};\n+        struct TxId: Column<2, NScheme::NTypeIds::Uint64> {};\n+\n+        using TKey = TableKey<PlanStep, TxId>;\n+        using TColumns = TableColumns<PlanStep, TxId>;\n+    };\n+\n+    struct TxDependencies: Table<(ui32)ECommonTables::TxDependencies> {\n+        struct CommitTxId: Column<1, NScheme::NTypeIds::Uint64> {};\n+        struct BrokenTxId: Column<2, NScheme::NTypeIds::Uint64> {};\n+\n+        using TKey = TableKey<CommitTxId, BrokenTxId>;\n+        using TColumns = TableColumns<CommitTxId, BrokenTxId>;\n+    };\n+\n+    struct TxStates: Table<(ui32)ECommonTables::TxStates> {\n+        struct TxId: Column<1, NScheme::NTypeIds::Uint64> {};\n+        struct Broken: Column<2, NScheme::NTypeIds::Bool> {};\n+\n+        using TKey = TableKey<TxId>;\n+        using TColumns = TableColumns<TxId, Broken>;\n+    };\n+\n+    struct TxEvents: Table<(ui32)ECommonTables::TxEvents> {\n+        struct TxId: Column<1, NScheme::NTypeIds::Uint64> {};\n+        struct GenerationId: Column<2, NScheme::NTypeIds::Uint64> {};\n+        struct GenerationInternalId: Column<3, NScheme::NTypeIds::Uint64> {};\n+        struct Data: Column<4, NScheme::NTypeIds::String> {};\n+\n+        using TKey = TableKey<TxId, GenerationId, GenerationInternalId>;\n+        using TColumns = TableColumns<TxId, GenerationId, GenerationInternalId, Data>;\n+    };\n+\n     // Index tables\n \n     // InsertTable - common for all indices\n@@ -545,7 +584,11 @@ struct Schema : NIceDb::Schema {\n         BackgroundSessions,\n         ShardingInfo,\n         Normalizers,\n-        NormalizerEvents\n+        NormalizerEvents,\n+        InFlightSnapshots,\n+        TxDependencies,\n+        TxStates,\n+        TxEvents\n         >;\n \n     //\n@@ -661,8 +704,8 @@ struct Schema : NIceDb::Schema {\n     static void SaveTxInfo(NIceDb::TNiceDb& db, const TFullTxInfo& txInfo,\n                            const TString& txBody);\n \n+    static void UpdateTxInfoBody(NIceDb::TNiceDb& db, const ui64 txId, const TString& txBody);\n     static void UpdateTxInfoSource(NIceDb::TNiceDb& db, const TFullTxInfo& txInfo);\n-\n     static void UpdateTxInfoSource(NIceDb::TNiceDb& db, ui64 txId, const TActorId& source, ui64 cookie) {\n         db.Table<TxInfo>().Key(txId).Update(\n             NIceDb::TUpdate<TxInfo::Source>(source),\n@@ -742,7 +785,7 @@ struct Schema : NIceDb::Schema {\n         db.Table<TableInfo>().Key(pathId).Delete();\n     }\n \n-    static void SaveLongTxWrite(NIceDb::TNiceDb& db, TWriteId writeId, const ui32 writePartId, const NLongTxService::TLongTxId& longTxId, const std::optional<ui32> granuleShardingVersion) {\n+    static void SaveLongTxWrite(NIceDb::TNiceDb& db, const TInsertWriteId writeId, const ui32 writePartId, const NLongTxService::TLongTxId& longTxId, const std::optional<ui32> granuleShardingVersion) {\n         NKikimrLongTxService::TLongTxId proto;\n         longTxId.ToProto(&proto);\n         TString serialized;\n@@ -754,32 +797,49 @@ struct Schema : NIceDb::Schema {\n             );\n     }\n \n-    static void EraseLongTxWrite(NIceDb::TNiceDb& db, TWriteId writeId) {\n+    static void EraseLongTxWrite(NIceDb::TNiceDb& db, const TInsertWriteId writeId) {\n         db.Table<LongTxWrites>().Key((ui64)writeId).Delete();\n     }\n \n     // InsertTable activities\n \n-    static void InsertTable_Upsert(NIceDb::TNiceDb& db, EInsertTableIds recType, const TInsertedData& data) {\n-        db.Table<InsertTable>().Key((ui8)recType, data.PlanStep, data.WriteTxId, data.PathId, data.DedupId).Update(\n-            NIceDb::TUpdate<InsertTable::BlobId>(data.GetBlobRange().GetBlobId().ToStringLegacy()),\n-            NIceDb::TUpdate<InsertTable::BlobRangeOffset>(data.GetBlobRange().Offset),\n-            NIceDb::TUpdate<InsertTable::BlobRangeSize>(data.GetBlobRange().Size),\n-            NIceDb::TUpdate<InsertTable::Meta>(data.GetMeta().SerializeToProto().SerializeAsString()),\n-            NIceDb::TUpdate<InsertTable::SchemaVersion>(data.GetSchemaVersion())\n-        );\n+    static void InsertTable_Upsert(NIceDb::TNiceDb& db, const EInsertTableIds recType, const TInsertedData& data) {\n+        db.Table<InsertTable>()\n+            .Key((ui8)recType, 0, (ui64)data.GetInsertWriteId(), data.GetPathId(), \"\")\n+            .Update(NIceDb::TUpdate<InsertTable::BlobId>(data.GetBlobRange().GetBlobId().ToStringLegacy()),\n+                NIceDb::TUpdate<InsertTable::BlobRangeOffset>(data.GetBlobRange().Offset),\n+                NIceDb::TUpdate<InsertTable::BlobRangeSize>(data.GetBlobRange().Size),\n+                NIceDb::TUpdate<InsertTable::Meta>(data.GetMeta().SerializeToProto().SerializeAsString()),\n+                NIceDb::TUpdate<InsertTable::SchemaVersion>(data.GetSchemaVersion()));\n+    }\n+\n+    static void InsertTable_Upsert(NIceDb::TNiceDb& db, const TCommittedData& data) {\n+        db.Table<InsertTable>()\n+            .Key((ui8)EInsertTableIds::Committed, data.GetSnapshot().GetPlanStep(), data.GetSnapshot().GetTxId(), data.GetPathId(),\n+                data.GetDedupId())\n+            .Update(NIceDb::TUpdate<InsertTable::BlobId>(data.GetBlobRange().GetBlobId().ToStringLegacy()),\n+                NIceDb::TUpdate<InsertTable::BlobRangeOffset>(data.GetBlobRange().Offset),\n+                NIceDb::TUpdate<InsertTable::BlobRangeSize>(data.GetBlobRange().Size),\n+                NIceDb::TUpdate<InsertTable::Meta>(data.GetMeta().SerializeToProto().SerializeAsString()),\n+                NIceDb::TUpdate<InsertTable::SchemaVersion>(data.GetSchemaVersion()));\n     }\n \n     static void InsertTable_Erase(NIceDb::TNiceDb& db, EInsertTableIds recType, const TInsertedData& data) {\n-        db.Table<InsertTable>().Key((ui8)recType, data.PlanStep, data.WriteTxId, data.PathId, data.DedupId).Delete();\n+        db.Table<InsertTable>().Key((ui8)recType, 0, (ui64)data.GetInsertWriteId(), data.GetPathId(), \"\").Delete();\n+    }\n+\n+    static void InsertTable_Erase(NIceDb::TNiceDb& db, const TCommittedData& data) {\n+        db.Table<InsertTable>()\n+            .Key((ui8)EInsertTableIds::Committed, data.GetSnapshot().GetPlanStep(), data.GetSnapshot().GetTxId(), data.GetPathId(), data.GetDedupId())\n+            .Delete();\n     }\n \n     static void InsertTable_Insert(NIceDb::TNiceDb& db, const TInsertedData& data) {\n         InsertTable_Upsert(db, EInsertTableIds::Inserted, data);\n     }\n \n-    static void InsertTable_Commit(NIceDb::TNiceDb& db, const TInsertedData& data) {\n-        InsertTable_Upsert(db, EInsertTableIds::Committed, data);\n+    static void InsertTable_Commit(NIceDb::TNiceDb& db, const TCommittedData& data) {\n+        InsertTable_Upsert(db, data);\n     }\n \n     static void InsertTable_Abort(NIceDb::TNiceDb& db, const TInsertedData& data) {\n@@ -790,8 +850,8 @@ struct Schema : NIceDb::Schema {\n         InsertTable_Erase(db, EInsertTableIds::Inserted, data);\n     }\n \n-    static void InsertTable_EraseCommitted(NIceDb::TNiceDb& db, const TInsertedData& data) {\n-        InsertTable_Erase(db, EInsertTableIds::Committed, data);\n+    static void InsertTable_EraseCommitted(NIceDb::TNiceDb& db, const TCommittedData& data) {\n+        InsertTable_Erase(db, data);\n     }\n \n     static void InsertTable_EraseAborted(NIceDb::TNiceDb& db, const TInsertedData& data) {\n@@ -917,4 +977,124 @@ class TIndexChunkLoadContext {\n     }\n };\n \n-}\n+class TInsertTableRecordLoadContext {\n+private:\n+    NColumnShard::Schema::EInsertTableIds RecType;\n+    ui64 PlanStep;\n+    ui64 WriteTxId;\n+    ui64 PathId;\n+    YDB_ACCESSOR_DEF(TString, DedupId);\n+    ui64 SchemaVersion;\n+    TString BlobIdString;\n+    std::optional<NOlap::TUnifiedBlobId> BlobId;\n+    TString MetadataString;\n+    std::optional<NKikimrTxColumnShard::TLogicalMetadata> Metadata;\n+    std::optional<ui64> RangeOffset;\n+    std::optional<ui64> RangeSize;\n+\n+    void Prepare(const IBlobGroupSelector* dsGroupSelector) {\n+        AFL_VERIFY(!PreparedFlag);\n+        PreparedFlag = true;\n+        TString error;\n+        NOlap::TUnifiedBlobId blobId = NOlap::TUnifiedBlobId::ParseFromString(BlobIdString, dsGroupSelector, error);\n+        Y_ABORT_UNLESS(blobId.IsValid(), \"Failied to parse blob id: %s\", error.c_str());\n+        BlobId = blobId;\n+\n+        NKikimrTxColumnShard::TLogicalMetadata meta;\n+        AFL_VERIFY(MetadataString);\n+        Y_ABORT_UNLESS(meta.ParseFromString(MetadataString));\n+        Metadata = std::move(meta);\n+        AFL_VERIFY(!!RangeOffset == !!RangeSize);\n+    }\n+\n+    bool PreparedFlag = false;\n+    bool ParsedFlag = false;\n+\n+public:\n+    TInsertWriteId GetInsertWriteId() const {\n+        AFL_VERIFY(ParsedFlag);\n+        AFL_VERIFY(RecType != NColumnShard::Schema::EInsertTableIds::Committed);\n+        return (TInsertWriteId)WriteTxId;\n+    }\n+\n+    NColumnShard::Schema::EInsertTableIds GetRecType() const {\n+        AFL_VERIFY(ParsedFlag);\n+        return RecType;\n+    }\n+\n+    ui64 GetPlanStep() const {\n+        AFL_VERIFY(ParsedFlag);\n+        return PlanStep;\n+    }\n+\n+    void Remove(NIceDb::TNiceDb& db) const {\n+        AFL_VERIFY(ParsedFlag);\n+        db.Table<NColumnShard::Schema::InsertTable>().Key((ui8)RecType, PlanStep, WriteTxId, PathId, DedupId).Delete();\n+    }\n+\n+    void Upsert(NIceDb::TNiceDb& db) const {\n+        AFL_VERIFY(ParsedFlag);\n+        using namespace NColumnShard;\n+        if (RangeOffset) {\n+            db.Table<Schema::InsertTable>()\n+                .Key((ui8)RecType, PlanStep, WriteTxId, PathId, DedupId)\n+                .Update(NIceDb::TUpdate<Schema::InsertTable::BlobId>(BlobIdString),\n+                    NIceDb::TUpdate<Schema::InsertTable::BlobRangeOffset>(*RangeOffset),\n+                    NIceDb::TUpdate<Schema::InsertTable::BlobRangeSize>(*RangeSize), NIceDb::TUpdate<Schema::InsertTable::Meta>(MetadataString),\n+                    NIceDb::TUpdate<Schema::InsertTable::SchemaVersion>(SchemaVersion));\n+        } else {\n+            db.Table<Schema::InsertTable>()\n+                .Key((ui8)RecType, PlanStep, WriteTxId, PathId, DedupId)\n+                .Update(NIceDb::TUpdate<Schema::InsertTable::BlobId>(BlobIdString), NIceDb::TUpdate<Schema::InsertTable::Meta>(MetadataString),\n+                    NIceDb::TUpdate<Schema::InsertTable::SchemaVersion>(SchemaVersion));\n+        }\n+    }\n+\n+    template <class TRowset>\n+    void ParseFromDatabase(TRowset& rowset) {\n+        AFL_VERIFY(!ParsedFlag)(\"problem\", \"duplication parsing\");\n+        ParsedFlag = true;\n+        using namespace NColumnShard;\n+        RecType = (Schema::EInsertTableIds)rowset.template GetValue<Schema::InsertTable::Committed>();\n+        PlanStep = rowset.template GetValue<Schema::InsertTable::PlanStep>();\n+        WriteTxId = rowset.template GetValueOrDefault<Schema::InsertTable::WriteTxId>();\n+        AFL_VERIFY(WriteTxId);\n+\n+        PathId = rowset.template GetValue<Schema::InsertTable::PathId>();\n+        DedupId = rowset.template GetValue<Schema::InsertTable::DedupId>();\n+        SchemaVersion =\n+            rowset.template HaveValue<Schema::InsertTable::SchemaVersion>() ? rowset.template GetValue<Schema::InsertTable::SchemaVersion>() : 0;\n+        BlobIdString = rowset.template GetValue<Schema::InsertTable::BlobId>();\n+        MetadataString = rowset.template GetValue<Schema::InsertTable::Meta>();\n+        if (rowset.template HaveValue<Schema::InsertTable::BlobRangeOffset>()) {\n+            RangeOffset = rowset.template GetValue<Schema::InsertTable::BlobRangeOffset>();\n+        }\n+        if (rowset.template HaveValue<Schema::InsertTable::BlobRangeSize>()) {\n+            RangeSize = rowset.template GetValue<Schema::InsertTable::BlobRangeSize>();\n+        }\n+    }\n+\n+    NOlap::TCommittedData BuildCommitted(const IBlobGroupSelector* dsGroupSelector) {\n+        Prepare(dsGroupSelector);\n+        using namespace NColumnShard;\n+        AFL_VERIFY(RecType == Schema::EInsertTableIds::Committed);\n+        auto userData = std::make_shared<NOlap::TUserData>(PathId,\n+            NOlap::TBlobRange(*BlobId, RangeOffset.value_or(0), RangeSize.value_or(BlobId->BlobSize())), *Metadata, SchemaVersion, std::nullopt);\n+        AFL_VERIFY(!!DedupId);\n+        AFL_VERIFY(PlanStep);\n+        return NOlap::TCommittedData(userData, PlanStep, WriteTxId, DedupId);\n+    }\n+\n+    NOlap::TInsertedData BuildInsertedOrAborted(const IBlobGroupSelector* dsGroupSelector) {\n+        Prepare(dsGroupSelector);\n+        using namespace NColumnShard;\n+        AFL_VERIFY(RecType != Schema::EInsertTableIds::Committed);\n+        auto userData = std::make_shared<NOlap::TUserData>(PathId,\n+            NOlap::TBlobRange(*BlobId, RangeOffset.value_or(0), RangeSize.value_or(BlobId->BlobSize())), *Metadata, SchemaVersion, std::nullopt);\n+        AFL_VERIFY(!DedupId);\n+        AFL_VERIFY(!PlanStep);\n+        return NOlap::TInsertedData((TInsertWriteId)WriteTxId, userData);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/common/limits.h b/ydb/core/tx/columnshard/common/limits.h\nindex 796ffef309ac..b30432dfb2fd 100644\n--- a/ydb/core/tx/columnshard/common/limits.h\n+++ b/ydb/core/tx/columnshard/common/limits.h\n@@ -9,5 +9,10 @@ class TGlobalLimits {\n     static constexpr inline ui64 InsertCompactionMemoryLimit = 1ULL << 30;\n     static constexpr inline ui64 GeneralCompactionMemoryLimit = 3ULL << 30;\n     static constexpr inline ui64 ScanMemoryLimit = 3ULL << 30;\n+\n+    static constexpr inline ui64 DefaultBlobsMemoryIntervalLimit = ScanMemoryLimit;\n+    static constexpr inline ui64 DefaultRejectMemoryIntervalLimit = ScanMemoryLimit;\n+    static constexpr inline ui64 DefaultReduceMemoryIntervalLimit = 0.8 * ScanMemoryLimit;\n+    static constexpr inline ui64 DefaultReadSequentiallyBufferSize = ((ui64)8) << 20;\n };\n }\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/common/scalars.cpp b/ydb/core/tx/columnshard/common/scalars.cpp\nindex d614253e9ec1..d85622edeeec 100644\n--- a/ydb/core/tx/columnshard/common/scalars.cpp\n+++ b/ydb/core/tx/columnshard/common/scalars.cpp\n@@ -1,6 +1,6 @@\n #include \"scalars.h\"\n \n-#include <ydb/core/formats/arrow/switch_type.h>\n+#include <ydb/library/formats/arrow/switch_type.h>\n #include <ydb/library/yverify_stream/yverify_stream.h>\n #include <util/system/unaligned_mem.h>\n \ndiff --git a/ydb/core/tx/columnshard/common/scalars.h b/ydb/core/tx/columnshard/common/scalars.h\nindex 328296048620..7635caa19e11 100644\n--- a/ydb/core/tx/columnshard/common/scalars.h\n+++ b/ydb/core/tx/columnshard/common/scalars.h\n@@ -1,6 +1,6 @@\n #pragma once\n \n-#include <ydb/core/formats/arrow/protos/ssa.pb.h>\n+#include <ydb/library/formats/arrow/protos/ssa.pb.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <memory>\ndiff --git a/ydb/core/tx/columnshard/common/snapshot.cpp b/ydb/core/tx/columnshard/common/snapshot.cpp\nindex 6ca80d818986..eb6e62ccac0c 100644\n--- a/ydb/core/tx/columnshard/common/snapshot.cpp\n+++ b/ydb/core/tx/columnshard/common/snapshot.cpp\n@@ -35,4 +35,12 @@ TString TSnapshot::SerializeToString() const {\n     return SerializeToProto().SerializeAsString();\n }\n \n+NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanStep(const ui64 planStep) noexcept {\n+    return TSnapshot(planStep, ::Max<ui64>());\n+}\n+\n+NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanInstant(const TInstant planInstant) noexcept {\n+    return TSnapshot(planInstant.MilliSeconds(), ::Max<ui64>());\n+}\n+\n };\ndiff --git a/ydb/core/tx/columnshard/common/snapshot.h b/ydb/core/tx/columnshard/common/snapshot.h\nindex ffa48670371e..4bc99d268420 100644\n--- a/ydb/core/tx/columnshard/common/snapshot.h\n+++ b/ydb/core/tx/columnshard/common/snapshot.h\n@@ -54,6 +54,10 @@ class TSnapshot {\n         return TSnapshot(-1ll, -1ll);\n     }\n \n+    static TSnapshot MaxForPlanInstant(const TInstant planInstant) noexcept;\n+\n+    static TSnapshot MaxForPlanStep(const ui64 planStep) noexcept;\n+\n     constexpr bool operator==(const TSnapshot&) const noexcept = default;\n \n     constexpr auto operator<=>(const TSnapshot&) const noexcept = default;\ndiff --git a/ydb/core/tx/columnshard/common/ya.make b/ydb/core/tx/columnshard/common/ya.make\nindex 87bd2c16b26b..c7d8a27bf3ee 100644\n--- a/ydb/core/tx/columnshard/common/ya.make\n+++ b/ydb/core/tx/columnshard/common/ya.make\n@@ -1,7 +1,7 @@\n LIBRARY()\n \n SRCS(\n-    limits.h\n+    limits.cpp\n     reverse_accessor.cpp\n     scalars.cpp\n     snapshot.cpp\n@@ -11,7 +11,7 @@ SRCS(\n )\n \n PEERDIR(\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n     contrib/libs/apache/arrow\n     ydb/core/formats/arrow\n     ydb/core/tx/columnshard/common/protos\ndiff --git a/ydb/core/tx/columnshard/counters/aggregation/table_stats.h b/ydb/core/tx/columnshard/counters/aggregation/table_stats.h\nnew file mode 100644\nindex 000000000000..68f39a4191de\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/aggregation/table_stats.h\n@@ -0,0 +1,47 @@\n+#pragma once\n+\n+#include <ydb/core/protos/table_stats.pb.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executor.h>\n+#include <ydb/core/tx/columnshard/counters/counters_manager.h>\n+#include <ydb/core/tx/columnshard/engines/column_engine.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TTableStatsBuilder {\n+private:\n+    TCountersManager& Counters;\n+    const NTabletFlatExecutor::NFlatExecutorSetup::IExecutor& Executor;\n+    NOlap::IColumnEngine& ColumnEngine;\n+\n+public:\n+    TTableStatsBuilder(\n+        TCountersManager& counters, const NTabletFlatExecutor::NFlatExecutorSetup::IExecutor* executor, NOlap::IColumnEngine& columnEngine)\n+        : Counters(counters)\n+        , Executor(*executor)\n+        , ColumnEngine(columnEngine) {\n+    }\n+\n+    void FillTableStats(ui64 pathId, ::NKikimrTableStats::TTableStats& tableStats) {\n+        Counters.FillTableStats(pathId, tableStats);\n+\n+        auto columnEngineStats = ColumnEngine.GetStats().FindPtr(pathId);\n+        if (columnEngineStats && *columnEngineStats) {\n+            auto activeStats = (*columnEngineStats)->Active();\n+            tableStats.SetRowCount(activeStats.Rows);\n+            tableStats.SetDataSize(activeStats.Bytes);\n+        }\n+    }\n+\n+    void FillTotalTableStats(::NKikimrTableStats::TTableStats& tableStats) {\n+        Counters.FillTotalTableStats(tableStats);\n+\n+        tableStats.SetInFlightTxCount(Executor.GetStats().TxInFly);\n+        tableStats.SetHasLoanedParts(Executor.HasLoanedParts());\n+\n+        auto activeStats = ColumnEngine.GetTotalStats().Active();\n+        tableStats.SetRowCount(activeStats.Rows);\n+        tableStats.SetDataSize(activeStats.Bytes);\n+    }\n+};\n+\n+} // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/aggregation/ya.make b/ydb/core/tx/columnshard/counters/aggregation/ya.make\nnew file mode 100644\nindex 000000000000..95687733d093\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/aggregation/ya.make\n@@ -0,0 +1,10 @@\n+LIBRARY()\n+\n+SRCS()\n+\n+PEERDIR(\n+    ydb/core/protos\n+    ydb/core/base\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/counters/background_controller.cpp b/ydb/core/tx/columnshard/counters/background_controller.cpp\nnew file mode 100644\nindex 000000000000..fcc89f6ee940\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/background_controller.cpp\n@@ -0,0 +1,18 @@\n+#include \"background_controller.h\"\n+\n+#include <ydb/core/base/appdata_fwd.h>\n+#include <library/cpp/time_provider/time_provider.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+void TBackgroundControllerCounters::OnCompactionFinish(ui64 pathId) {\n+    TInstant now = TAppData::TimeProvider->Now();\n+    TInstant& lastFinish = LastCompactionFinishByPathId[pathId];\n+    lastFinish = std::max(lastFinish, now);\n+\n+    if (LastCompactionFinish < now) {\n+        LastCompactionFinish = now;\n+    }\n+}\n+\n+} // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/background_controller.h b/ydb/core/tx/columnshard/counters/background_controller.h\nnew file mode 100644\nindex 000000000000..d46d7cdacf91\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/background_controller.h\n@@ -0,0 +1,35 @@\n+#pragma once\n+\n+#include <ydb/core/protos/table_stats.pb.h>\n+#include <util/datetime/base.h>\n+#include <util/generic/hash.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TBackgroundControllerCounters {\n+private:\n+    THashMap<ui64, TInstant> LastCompactionFinishByPathId;\n+    TInstant LastCompactionFinish;\n+\n+public:\n+    void OnCompactionFinish(ui64 pathId);\n+\n+    void FillStats(ui64 pathId, ::NKikimrTableStats::TTableStats& output) const {\n+        output.SetLastFullCompactionTs(GetLastCompactionFinishInstant(pathId).value_or(TInstant::Zero()).Seconds());\n+    }\n+\n+    void FillTotalStats(::NKikimrTableStats::TTableStats& output) const {\n+        output.SetLastFullCompactionTs(LastCompactionFinish.Seconds());\n+    }\n+\n+private:\n+    std::optional<TInstant> GetLastCompactionFinishInstant(const ui64 pathId) const {\n+        auto findInstant = LastCompactionFinishByPathId.FindPtr(pathId);\n+        if (!findInstant) {\n+            return std::nullopt;\n+        }\n+        return *findInstant;\n+    }\n+};\n+\n+} // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/column_tables.cpp b/ydb/core/tx/columnshard/counters/column_tables.cpp\nnew file mode 100644\nindex 000000000000..51b9ecf6283e\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/column_tables.cpp\n@@ -0,0 +1,13 @@\n+#include \"column_tables.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+std::shared_ptr<TSingleColumnTableCounters> TColumnTablesCounters::GetPathIdCounter(ui64 pathId) {\n+    auto findCounter = PathIdCounters.FindPtr(pathId);\n+    if (findCounter) {\n+        return *findCounter;\n+    }\n+    return PathIdCounters.emplace(pathId, std::make_shared<TSingleColumnTableCounters>(*this)).first->second;\n+}\n+\n+} // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/column_tables.h b/ydb/core/tx/columnshard/counters/column_tables.h\nnew file mode 100644\nindex 000000000000..db00069218fb\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/column_tables.h\n@@ -0,0 +1,85 @@\n+#pragma once\n+\n+#include <ydb/core/protos/table_stats.pb.h>\n+#include <util/datetime/base.h>\n+#include <ydb/core/base/appdata_fwd.h>\n+#include <library/cpp/time_provider/time_provider.h>\n+#include <ydb/library/accessor/accessor.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TSingleColumnTableCounters;\n+\n+class TColumnTablesCounters {\n+private:\n+    YDB_READONLY_CONST(std::shared_ptr<TInstant>, LastAccessTime);\n+    YDB_READONLY_CONST(std::shared_ptr<TInstant>, LastUpdateTime);\n+\n+    THashMap<ui64, std::shared_ptr<TSingleColumnTableCounters>> PathIdCounters;\n+\n+    friend class TSingleColumnTableCounters;\n+\n+public:\n+    TColumnTablesCounters()\n+        : LastAccessTime(std::make_shared<TInstant>())\n+        , LastUpdateTime(std::make_shared<TInstant>()) {\n+    }\n+\n+    void FillStats(::NKikimrTableStats::TTableStats& output) const {\n+        output.SetLastAccessTime(LastAccessTime->MilliSeconds());\n+        output.SetLastUpdateTime(LastUpdateTime->MilliSeconds());\n+    }\n+\n+    std::shared_ptr<TSingleColumnTableCounters> GetPathIdCounter(ui64 pathId);\n+};\n+\n+class TSingleColumnTableCounters {\n+private:\n+    YDB_READONLY(TInstant, PathIdLastAccessTime, TInstant::Zero());\n+    YDB_READONLY(TInstant, PathIdLastUpdateTime, TInstant::Zero());\n+\n+    const std::shared_ptr<TInstant> TotalLastAccessTime;\n+    const std::shared_ptr<TInstant> TotalLastUpdateTime;\n+\n+public:\n+    TSingleColumnTableCounters(TColumnTablesCounters& owner)\n+        : TotalLastAccessTime(owner.LastAccessTime)\n+        , TotalLastUpdateTime(owner.LastUpdateTime) {\n+    }\n+\n+    void OnReadEvent() {\n+        UpdateLastAccessTime(TAppData::TimeProvider->Now());\n+    }\n+\n+    void OnWriteEvent() {\n+        TInstant now = TAppData::TimeProvider->Now();\n+        UpdateLastUpdateTime(now);\n+        UpdateLastAccessTime(now);\n+    }\n+\n+    void FillStats(::NKikimrTableStats::TTableStats& output) const {\n+        output.SetLastAccessTime(PathIdLastAccessTime.MilliSeconds());\n+        output.SetLastUpdateTime(PathIdLastUpdateTime.MilliSeconds());\n+    }\n+\n+private:\n+    void UpdateLastAccessTime(TInstant value) {\n+        if (PathIdLastAccessTime < value) {\n+            PathIdLastAccessTime = value;\n+        }\n+        if (*TotalLastAccessTime < value) {\n+            *TotalLastAccessTime = value;\n+        }\n+    }\n+\n+    void UpdateLastUpdateTime(TInstant value) {\n+        if (PathIdLastUpdateTime < value) {\n+            PathIdLastUpdateTime = value;\n+        }\n+        if (*TotalLastUpdateTime < value) {\n+            *TotalLastUpdateTime = value;\n+        }\n+    }\n+};\n+\n+} // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/columnshard.cpp b/ydb/core/tx/columnshard/counters/columnshard.cpp\nindex 64c7e2931c5f..67c569e1313b 100644\n--- a/ydb/core/tx/columnshard/counters/columnshard.cpp\n+++ b/ydb/core/tx/columnshard/counters/columnshard.cpp\n@@ -8,7 +8,9 @@ namespace NKikimr::NColumnShard {\n \n TCSCounters::TCSCounters()\n     : TBase(\"CS\")\n-{\n+    , WritingCounters(std::make_shared<TWriteCounters>(*this))\n+    , Initialization(*this)\n+    , TxProgress(*this) {\n     StartBackgroundCount = TBase::GetDeriviative(\"StartBackground/Count\");\n     TooEarlyBackgroundCount = TBase::GetDeriviative(\"TooEarlyBackground/Count\");\n     SetupCompactionCount = TBase::GetDeriviative(\"SetupCompaction/Count\");\n@@ -52,6 +54,7 @@ TCSCounters::TCSCounters()\n     HistogramSuccessWriteMiddle6PutBlobsDurationMs = TBase::GetHistogram(\"SuccessWriteMiddle6PutBlobsDurationMs\", NMonitoring::ExponentialHistogram(18, 2, 5));\n     HistogramFailedWritePutBlobsDurationMs = TBase::GetHistogram(\"FailedWritePutBlobsDurationMs\", NMonitoring::ExponentialHistogram(18, 2, 5));\n     HistogramWriteTxCompleteDurationMs = TBase::GetHistogram(\"WriteTxCompleteDurationMs\", NMonitoring::ExponentialHistogram(18, 2, 5));\n+\n     WritePutBlobsCount = TBase::GetValue(\"WritePutBlobs\");\n     WriteRequests = TBase::GetValue(\"WriteRequests\");\n \ndiff --git a/ydb/core/tx/columnshard/counters/columnshard.h b/ydb/core/tx/columnshard/counters/columnshard.h\nindex 6bada377df17..81df8b300eb8 100644\n--- a/ydb/core/tx/columnshard/counters/columnshard.h\n+++ b/ydb/core/tx/columnshard/counters/columnshard.h\n@@ -1,8 +1,11 @@\n #pragma once\n #include \"common/owner.h\"\n+#include \"initialization.h\"\n+#include \"tx_progress.h\"\n \n-#include <library/cpp/monlib/dynamic_counters/counters.h>\n+#include <ydb/core/tx/columnshard/counters/tablet_counters.h>\n \n+#include <library/cpp/monlib/dynamic_counters/counters.h>\n #include <util/generic/hash_set.h>\n \n namespace NKikimr::NColumnShard {\n@@ -13,7 +16,32 @@ enum class EWriteFailReason {\n     LongTxDuplication /* \"long_tx_duplication\" */,\n     NoTable /* \"no_table\" */,\n     IncorrectSchema /* \"incorrect_schema\" */,\n-    Overload /* \"overload\" */\n+    Overload /* \"overload\" */,\n+    OverlimitReadRawMemory /* \"overlimit_read_raw_memory\" */,\n+    OverlimitReadBlobMemory /* \"overlimit_read_blob_memory\" */\n+};\n+\n+class TWriteCounters: public TCommonCountersOwner {\n+private:\n+    using TBase = TCommonCountersOwner;\n+    NMonitoring::TDynamicCounters::TCounterPtr VolumeWriteData;\n+    NMonitoring::THistogramPtr HistogramBytesWriteDataCount;\n+    NMonitoring::THistogramPtr HistogramBytesWriteDataBytes;\n+\n+public:\n+    TWriteCounters(TCommonCountersOwner& owner)\n+        : TBase(owner, \"activity\", \"writing\")\n+    {\n+        VolumeWriteData = TBase::GetDeriviative(\"Write/Incoming/Bytes\");\n+        HistogramBytesWriteDataCount = TBase::GetHistogram(\"Write/Incoming/ByBytes/Count\", NMonitoring::ExponentialHistogram(18, 2, 100));\n+        HistogramBytesWriteDataBytes = TBase::GetHistogram(\"Write/Incoming/ByBytes/Bytes\", NMonitoring::ExponentialHistogram(18, 2, 100));\n+    }\n+\n+    void OnIncomingData(const ui64 dataSize) const {\n+        VolumeWriteData->Add(dataSize);\n+        HistogramBytesWriteDataCount->Collect((i64)dataSize, 1);\n+        HistogramBytesWriteDataBytes->Collect((i64)dataSize, dataSize);\n+    }\n };\n \n class TCSCounters: public TCommonCountersOwner {\n@@ -62,11 +90,17 @@ class TCSCounters: public TCommonCountersOwner {\n     NMonitoring::THistogramPtr HistogramSuccessWriteMiddle6PutBlobsDurationMs;\n     NMonitoring::THistogramPtr HistogramFailedWritePutBlobsDurationMs;\n     NMonitoring::THistogramPtr HistogramWriteTxCompleteDurationMs;\n+\n     NMonitoring::TDynamicCounters::TCounterPtr WritePutBlobsCount;\n     NMonitoring::TDynamicCounters::TCounterPtr WriteRequests;\n     THashMap<EWriteFailReason, NMonitoring::TDynamicCounters::TCounterPtr> FailedWriteRequests;\n     NMonitoring::TDynamicCounters::TCounterPtr SuccessWriteRequests;\n+\n public:\n+    const std::shared_ptr<TWriteCounters> WritingCounters;\n+    const TCSInitialization Initialization;\n+    TTxProgressCounters TxProgress;\n+\n     void OnStartWriteRequest() const {\n         WriteRequests->Add(1);\n     }\n@@ -80,7 +114,6 @@ class TCSCounters: public TCommonCountersOwner {\n \n     void OnWritePutBlobsSuccess(const TDuration d) const {\n         HistogramSuccessWritePutBlobsDurationMs->Collect(d.MilliSeconds());\n-        WritePutBlobsCount->Sub(1);\n     }\n \n     void OnWriteMiddle1PutBlobsSuccess(const TDuration d) const {\n@@ -109,11 +142,6 @@ class TCSCounters: public TCommonCountersOwner {\n \n     void OnWritePutBlobsFail(const TDuration d) const {\n         HistogramFailedWritePutBlobsDurationMs->Collect(d.MilliSeconds());\n-        WritePutBlobsCount->Sub(1);\n-    }\n-\n-    void OnWritePutBlobsStart() const {\n-        WritePutBlobsCount->Add(1);\n     }\n \n     void OnWriteTxComplete(const TDuration d) const {\n@@ -130,27 +158,27 @@ class TCSCounters: public TCommonCountersOwner {\n         SplitCompactionGranulePortionsCount->SetValue(portionsCount);\n     }\n \n-    void OnOverloadInsertTable(const ui64 size) const {\n+    void OnWriteOverloadInsertTable(const ui64 size) const {\n         OverloadInsertTableBytes->Add(size);\n         OverloadInsertTableCount->Add(1);\n     }\n \n-    void OnOverloadMetadata(const ui64 size) const {\n+    void OnWriteOverloadMetadata(const ui64 size) const {\n         OverloadMetadataBytes->Add(size);\n         OverloadMetadataCount->Add(1);\n     }\n \n-    void OnOverloadShardTx(const ui64 size) const {\n+    void OnWriteOverloadShardTx(const ui64 size) const {\n         OverloadShardTxBytes->Add(size);\n         OverloadShardTxCount->Add(1);\n     }\n \n-    void OnOverloadShardWrites(const ui64 size) const {\n+    void OnWriteOverloadShardWrites(const ui64 size) const {\n         OverloadShardWritesBytes->Add(size);\n         OverloadShardWritesCount->Add(1);\n     }\n \n-    void OnOverloadShardWritesSize(const ui64 size) const {\n+    void OnWriteOverloadShardWritesSize(const ui64 size) const {\n         OverloadShardWritesSizeBytes->Add(size);\n         OverloadShardWritesSizeCount->Add(1);\n     }\ndiff --git a/ydb/core/tx/columnshard/counters/counters_manager.cpp b/ydb/core/tx/columnshard/counters/counters_manager.cpp\nnew file mode 100644\nindex 000000000000..11b18888bc31\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/counters_manager.cpp\n@@ -0,0 +1,5 @@\n+#include \"counters_manager.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/counters_manager.h b/ydb/core/tx/columnshard/counters/counters_manager.h\nnew file mode 100644\nindex 000000000000..17336ca3410d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/counters_manager.h\n@@ -0,0 +1,97 @@\n+#pragma once\n+\n+#include \"background_controller.h\"\n+#include \"column_tables.h\"\n+#include \"columnshard.h\"\n+#include \"indexation.h\"\n+#include \"req_tracer.h\"\n+#include \"scan.h\"\n+#include \"tablet_counters.h\"\n+#include \"writes_monitor.h\"\n+\n+#include <ydb/core/base/appdata_fwd.h>\n+#include <ydb/core/protos/counters_columnshard.pb.h>\n+#include <ydb/core/protos/counters_datashard.pb.h>\n+#include <ydb/core/protos/table_stats.pb.h>\n+#include <ydb/core/tablet/tablet_counters.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executor.h>\n+#include <ydb/core/tx/columnshard/engines/column_engine.h>\n+\n+#include <library/cpp/time_provider/time_provider.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TCountersManager {\n+private:\n+    YDB_READONLY_DEF(std::shared_ptr<const TTabletCountersHandle>, TabletCounters);\n+    YDB_READONLY_DEF(std::shared_ptr<TWritesMonitor>, WritesMonitor);\n+\n+    YDB_READONLY_DEF(std::shared_ptr<TBackgroundControllerCounters>, BackgroundControllerCounters);\n+    YDB_READONLY_DEF(std::shared_ptr<TColumnTablesCounters>, ColumnTablesCounters);\n+\n+    YDB_READONLY(TCSCounters, CSCounters, TCSCounters());\n+    YDB_READONLY(TIndexationCounters, EvictionCounters, TIndexationCounters(\"Eviction\"));\n+    YDB_READONLY(TIndexationCounters, IndexationCounters, TIndexationCounters(\"Indexation\"));\n+    YDB_READONLY(TIndexationCounters, CompactionCounters, TIndexationCounters(\"GeneralCompaction\"));\n+    YDB_READONLY(TScanCounters, ScanCounters, TScanCounters(\"Scan\"));\n+    YDB_READONLY_DEF(std::shared_ptr<TRequestsTracerCounters>, RequestsTracingCounters);\n+    YDB_READONLY_DEF(std::shared_ptr<NOlap::NResourceBroker::NSubscribe::TSubscriberCounters>, SubscribeCounters);\n+\n+public:\n+    TCountersManager(TTabletCountersBase& tabletCounters)\n+        : TabletCounters(std::make_shared<const TTabletCountersHandle>(tabletCounters))\n+        , WritesMonitor(std::make_shared<TWritesMonitor>(tabletCounters))\n+        , BackgroundControllerCounters(std::make_shared<TBackgroundControllerCounters>())\n+        , ColumnTablesCounters(std::make_shared<TColumnTablesCounters>())\n+        , RequestsTracingCounters(std::make_shared<TRequestsTracerCounters>())\n+        , SubscribeCounters(std::make_shared<NOlap::NResourceBroker::NSubscribe::TSubscriberCounters>()) {\n+    }\n+\n+    void OnWriteOverloadDisk() const {\n+        TabletCounters->IncCounter(COUNTER_OUT_OF_SPACE);\n+    }\n+\n+    void OnWriteOverloadInsertTable(const ui64 size) const {\n+        TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);\n+        CSCounters.OnWriteOverloadInsertTable(size);\n+    }\n+\n+    void OnWriteOverloadMetadata(const ui64 size) const {\n+        TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);\n+        CSCounters.OnWriteOverloadMetadata(size);\n+    }\n+\n+    void OnWriteOverloadShardTx(const ui64 size) const {\n+        TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);\n+        CSCounters.OnWriteOverloadShardTx(size);\n+    }\n+\n+    void OnWriteOverloadShardWrites(const ui64 size) const {\n+        TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);\n+        CSCounters.OnWriteOverloadShardWrites(size);\n+    }\n+\n+    void OnWriteOverloadShardWritesSize(const ui64 size) const {\n+        TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);\n+        CSCounters.OnWriteOverloadShardWritesSize(size);\n+    }\n+\n+    void FillTableStats(ui64 pathId, ::NKikimrTableStats::TTableStats& tableStats) {\n+        ColumnTablesCounters->GetPathIdCounter(pathId)->FillStats(tableStats);\n+        BackgroundControllerCounters->FillStats(pathId, tableStats);\n+    }\n+\n+    void FillTotalTableStats(::NKikimrTableStats::TTableStats& tableStats) {\n+        ColumnTablesCounters->FillStats(tableStats);\n+        TabletCounters->FillStats(tableStats);\n+        BackgroundControllerCounters->FillTotalStats(tableStats);\n+        ScanCounters.FillStats(tableStats);\n+    }\n+\n+    void OnWritePutBlobsSuccess(const TDuration d, const ui64 rowsWritten) const {\n+        TabletCounters->OnWritePutBlobsSuccess(rowsWritten);\n+        CSCounters.OnWritePutBlobsSuccess(d);\n+    }\n+};\n+\n+} // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/counters/engine_logs.h b/ydb/core/tx/columnshard/counters/engine_logs.h\nindex 97a4716652c3..2cbaf7fa234e 100644\n--- a/ydb/core/tx/columnshard/counters/engine_logs.h\n+++ b/ydb/core/tx/columnshard/counters/engine_logs.h\n@@ -85,17 +85,44 @@ class TAgentDataClassCounters: public TCommonCountersOwner {\n     }\n };\n \n+class TIntervalMemoryCounters {\n+public:\n+    const std::shared_ptr<TValueAggregationClient> MinReadBytes;\n+    TIntervalMemoryCounters(const std::shared_ptr<TValueAggregationClient>& minReadBytes)\n+        : MinReadBytes(minReadBytes)\n+    {\n+\n+    }\n+};\n+\n+class TPortionsIndexCounters {\n+public:\n+    const TIntervalMemoryCounters RawBytes;\n+    const TIntervalMemoryCounters BlobBytes;\n+    TPortionsIndexCounters(TIntervalMemoryCounters&& rawBytes, TIntervalMemoryCounters&& blobBytes)\n+        : RawBytes(std::move(rawBytes))\n+        , BlobBytes(std::move(blobBytes)) {\n+    }\n+};\n+\n class TGranuleDataCounters {\n private:\n     const TDataClassCounters InsertedData;\n     const TDataClassCounters CompactedData;\n     const TDataClassCounters FullData;\n+    const TPortionsIndexCounters PortionsIndexCounters;\n+\n public:\n-    TGranuleDataCounters(const TDataClassCounters& insertedData, const TDataClassCounters& compactedData, const TDataClassCounters& fullData)\n+    const TPortionsIndexCounters& GetPortionsIndexCounters() const {\n+        return PortionsIndexCounters;\n+    }\n+\n+    TGranuleDataCounters(const TDataClassCounters& insertedData, const TDataClassCounters& compactedData, const TDataClassCounters& fullData,\n+        TPortionsIndexCounters&& portionsIndexCounters)\n         : InsertedData(insertedData)\n         , CompactedData(compactedData)\n         , FullData(fullData)\n-    {\n+        , PortionsIndexCounters(std::move(portionsIndexCounters)) {\n     }\n \n     void OnPortionsDataRefresh(const TBaseGranuleDataClassSummary& inserted, const TBaseGranuleDataClassSummary& compacted) const {\n@@ -105,20 +132,60 @@ class TGranuleDataCounters {\n     }\n };\n \n+class TIntervalMemoryAgentCounters: public TCommonCountersOwner {\n+private:\n+    using TBase = TCommonCountersOwner;\n+    const std::shared_ptr<TValueAggregationAgent> ReadBytes;\n+public:\n+    TIntervalMemoryAgentCounters(const TCommonCountersOwner& base, const TString& memoryType)\n+        : TBase(base, \"memory\", memoryType)\n+        , ReadBytes(TBase::GetValueAutoAggregations(\"Bytes\")) {\n+    }\n+\n+    TIntervalMemoryCounters GetClient() const {\n+        return TIntervalMemoryCounters(ReadBytes->GetClient());\n+    }\n+};\n+\n+class TPortionsIndexAgentsCounters: public TCommonCountersOwner {\n+private:\n+    using TBase = TCommonCountersOwner;\n+    TIntervalMemoryAgentCounters ReadRawBytes;\n+    TIntervalMemoryAgentCounters ReadBlobBytes;\n+\n+public:\n+\n+    TPortionsIndexAgentsCounters(const TString& baseName)\n+        : TBase(baseName)\n+        , ReadRawBytes(TBase::CreateSubGroup(\"control\", \"read_memory\"), \"raw\")\n+        , ReadBlobBytes(TBase::CreateSubGroup(\"control\", \"read_memory\"), \"blob\")\n+    {\n+    }\n+\n+    TPortionsIndexCounters BuildCounters() const {\n+        return TPortionsIndexCounters(ReadRawBytes.GetClient(), ReadBlobBytes.GetClient());\n+    }\n+};\n+\n class TAgentGranuleDataCounters {\n private:\n     TAgentDataClassCounters InsertedData;\n     TAgentDataClassCounters CompactedData;\n     TAgentDataClassCounters FullData;\n+    TPortionsIndexAgentsCounters PortionsIndex;\n+\n public:\n     TAgentGranuleDataCounters(const TString& ownerId)\n         : InsertedData(ownerId, \"ByGranule/Inserted\")\n         , CompactedData(ownerId, \"ByGranule/Compacted\")\n-        , FullData(ownerId, \"ByGranule/Full\") {\n+        , FullData(ownerId, \"ByGranule/Full\")\n+        , PortionsIndex(\"ByGranule/PortionsIndex\")\n+    {\n     }\n \n     TGranuleDataCounters RegisterClient() const {\n-        return TGranuleDataCounters(InsertedData.RegisterClient(), CompactedData.RegisterClient(), FullData.RegisterClient());\n+        return TGranuleDataCounters(\n+            InsertedData.RegisterClient(), CompactedData.RegisterClient(), FullData.RegisterClient(), PortionsIndex.BuildCounters());\n     }\n };\n \ndiff --git a/ydb/core/tx/columnshard/counters/initialization.h b/ydb/core/tx/columnshard/counters/initialization.h\nnew file mode 100644\nindex 000000000000..2a6b432d6135\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/initialization.h\n@@ -0,0 +1,56 @@\n+#pragma once\n+#include \"common/owner.h\"\n+\n+#include <library/cpp/monlib/dynamic_counters/counters.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TCSInitialization: public TCommonCountersOwner {\n+private:\n+    using TBase = TCommonCountersOwner;\n+\n+    const NMonitoring::THistogramPtr HistogramTabletInitializationMs;\n+    const NMonitoring::THistogramPtr HistogramTxInitDurationMs;\n+    const NMonitoring::THistogramPtr HistogramTxUpdateSchemaDurationMs;\n+    const NMonitoring::THistogramPtr HistogramTxInitSchemaDurationMs;\n+    const NMonitoring::THistogramPtr HistogramActivateExecutorFromActivationDurationMs;\n+    const NMonitoring::THistogramPtr HistogramSwitchToWorkFromActivationDurationMs;\n+    const NMonitoring::THistogramPtr HistogramSwitchToWorkFromCreateDurationMs;\n+\n+public:\n+    void OnTxInitFinished(const TDuration d) const {\n+        HistogramTxInitDurationMs->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnTxUpdateSchemaFinished(const TDuration d) const {\n+        HistogramTxUpdateSchemaDurationMs->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnTxInitSchemaFinished(const TDuration d) const {\n+        HistogramTxInitSchemaDurationMs->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnActivateExecutor(const TDuration fromCreate) const {\n+        HistogramActivateExecutorFromActivationDurationMs->Collect(fromCreate.MilliSeconds());\n+    }\n+    void OnSwitchToWork(const TDuration fromStart, const TDuration fromCreate) const {\n+        HistogramSwitchToWorkFromActivationDurationMs->Collect(fromStart.MilliSeconds());\n+        HistogramSwitchToWorkFromCreateDurationMs->Collect(fromCreate.MilliSeconds());\n+    }\n+\n+    TCSInitialization(TCommonCountersOwner& owner)\n+        : TBase(owner, \"stage\", \"initialization\")\n+        , HistogramTabletInitializationMs(TBase::GetHistogram(\"TabletInitializationMs\", NMonitoring::ExponentialHistogram(15, 2, 32)))\n+        , HistogramTxInitDurationMs(TBase::GetHistogram(\"TxInitDurationMs\", NMonitoring::ExponentialHistogram(15, 2, 32)))\n+        , HistogramTxUpdateSchemaDurationMs(TBase::GetHistogram(\"TxInitDurationMs\", NMonitoring::ExponentialHistogram(15, 2, 32)))\n+        , HistogramTxInitSchemaDurationMs(TBase::GetHistogram(\"TxInitSchemaDurationMs\", NMonitoring::ExponentialHistogram(15, 2, 32)))\n+        , HistogramActivateExecutorFromActivationDurationMs(\n+              TBase::GetHistogram(\"ActivateExecutorFromActivationDurationMs\", NMonitoring::ExponentialHistogram(15, 2, 32)))\n+        , HistogramSwitchToWorkFromActivationDurationMs(\n+              TBase::GetHistogram(\"SwitchToWorkFromActivationDurationMs\", NMonitoring::ExponentialHistogram(15, 2, 32)))\n+        , HistogramSwitchToWorkFromCreateDurationMs(\n+              TBase::GetHistogram(\"SwitchToWorkFromCreateDurationMs\", NMonitoring::ExponentialHistogram(15, 2, 32))) {\n+    }\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write.cpp b/ydb/core/tx/columnshard/counters/req_tracer.cpp\nsimilarity index 59%\nrename from ydb/core/tx/columnshard/transactions/operators/ev_write.cpp\nrename to ydb/core/tx/columnshard/counters/req_tracer.cpp\nindex 3aa27316237f..e40342f21db1 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/ev_write.cpp\n+++ b/ydb/core/tx/columnshard/counters/req_tracer.cpp\n@@ -1,4 +1,5 @@\n-#include \"ev_write.h\"\n+#include \"req_tracer.h\"\n \n namespace NKikimr::NColumnShard {\n+\n }\ndiff --git a/ydb/core/tx/columnshard/counters/req_tracer.h b/ydb/core/tx/columnshard/counters/req_tracer.h\nnew file mode 100644\nindex 000000000000..f70cd02e4840\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/req_tracer.h\n@@ -0,0 +1,51 @@\n+#pragma once\n+#include \"common/owner.h\"\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TRequestsTracerCounters: public TCommonCountersOwner {\n+private:\n+    using TBase = TCommonCountersOwner;\n+    NMonitoring::TDynamicCounters::TCounterPtr RequestedMinSnapshotAge;\n+    NMonitoring::TDynamicCounters::TCounterPtr DefaultMinSnapshotAge;\n+    NMonitoring::TDynamicCounters::TCounterPtr SnapshotsCount;\n+    NMonitoring::TDynamicCounters::TCounterPtr SnapshotLock;\n+    NMonitoring::TDynamicCounters::TCounterPtr SnapshotUnlock;\n+\n+public:\n+\n+    TRequestsTracerCounters()\n+        : TBase(\"cs_requests_tracing\")\n+        , RequestedMinSnapshotAge(TBase::GetValue(\"Snapshots/RequestedAge/Seconds\"))\n+        , DefaultMinSnapshotAge(TBase::GetValue(\"Snapshots/DefaultAge/Seconds\"))\n+        , SnapshotsCount(TBase::GetValue(\"Snapshots/Count\"))\n+        , SnapshotLock(TBase::GetDeriviative(\"Snapshots/Lock\"))\n+        , SnapshotUnlock(TBase::GetDeriviative(\"Snapshots/Unlock\"))\n+    {\n+\n+    }\n+\n+    void OnDefaultMinSnapshotInstant(const TInstant instant) const {\n+        DefaultMinSnapshotAge->Set((TInstant::Now() - instant).Seconds());\n+    }\n+\n+    void OnSnapshotsInfo(const ui32 count, const std::optional<NOlap::TSnapshot> snapshotPlanStep) const {\n+        if (snapshotPlanStep) {\n+            RequestedMinSnapshotAge->Set((TInstant::Now() - snapshotPlanStep->GetPlanInstant()).Seconds());\n+        } else {\n+            RequestedMinSnapshotAge->Set(0);\n+        }\n+        SnapshotsCount->Set(count);\n+        \n+    }\n+\n+    void OnSnapshotLocked() const {\n+        SnapshotLock->Add(1);\n+    }\n+    void OnSnapshotUnlocked() const {\n+        SnapshotUnlock->Add(1);\n+    }\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/counters/scan.cpp b/ydb/core/tx/columnshard/counters/scan.cpp\nindex 075aa0e880ec..cdfd42aa9bc4 100644\n--- a/ydb/core/tx/columnshard/counters/scan.cpp\n+++ b/ydb/core/tx/columnshard/counters/scan.cpp\n@@ -88,12 +88,14 @@ TScanCounters::TScanCounters(const TString& module)\n     ScanIntervalState = std::make_shared<TScanIntervalState>(*this);\n     ResourcesSubscriberCounters = std::make_shared<NOlap::NResourceBroker::NSubscribe::TSubscriberCounters>();\n     ScanDurationByStatus.resize((ui32)EStatusFinish::COUNT);\n+    ScansFinishedByStatus.resize((ui32)EStatusFinish::COUNT);\n     ui32 idx = 0;\n     for (auto&& i : GetEnumAllValues<EStatusFinish>()) {\n         if (i == EStatusFinish::COUNT) {\n             continue;\n         }\n         ScanDurationByStatus[(ui32)i] = TBase::GetHistogram(\"ScanDuration/\" + ::ToString(i) + \"/Milliseconds\", NMonitoring::ExponentialHistogram(18, 2, 1));\n+        ScansFinishedByStatus[(ui32)i] = TBase::GetDeriviative(\"ScansFinished/\" + ::ToString(i));\n         AFL_VERIFY(idx == (ui32)i);\n         ++idx;\n     }\n@@ -103,4 +105,8 @@ NKikimr::NColumnShard::TScanAggregations TScanCounters::BuildAggregations() {\n     return TScanAggregations(GetModuleId());\n }\n \n+void TScanCounters::FillStats(::NKikimrTableStats::TTableStats& output) const {\n+    output.SetRangeReads(ScansFinishedByStatus[(ui32)EStatusFinish::Success]->Val());\n+}\n+\n }\ndiff --git a/ydb/core/tx/columnshard/counters/scan.h b/ydb/core/tx/columnshard/counters/scan.h\nindex efaec82c563e..6d1202288514 100644\n--- a/ydb/core/tx/columnshard/counters/scan.h\n+++ b/ydb/core/tx/columnshard/counters/scan.h\n@@ -1,6 +1,7 @@\n #pragma once\n #include \"common/owner.h\"\n #include \"common/histogram.h\"\n+#include <ydb/core/protos/table_stats.pb.h>\n #include <ydb/core/tx/columnshard/resources/memory.h>\n #include <ydb/core/tx/columnshard/resource_subscriber/counters.h>\n #include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n@@ -127,6 +128,7 @@ class TScanCounters: public TCommonCountersOwner {\n     NMonitoring::TDynamicCounters::TCounterPtr AckWaitingDuration;\n \n     std::vector<NMonitoring::THistogramPtr> ScanDurationByStatus;\n+    std::vector<NMonitoring::TDynamicCounters::TCounterPtr> ScansFinishedByStatus;\n \n     NMonitoring::TDynamicCounters::TCounterPtr NoScanRecords;\n     NMonitoring::TDynamicCounters::TCounterPtr NoScanIntervals;\n@@ -212,9 +214,10 @@ class TScanCounters: public TCommonCountersOwner {\n         LogScanIntervals->Add(1);\n     }\n \n-    void OnScanDuration(const EStatusFinish status, const TDuration d) const {\n+    void OnScanFinished(const EStatusFinish status, const TDuration d) const {\n         AFL_VERIFY((ui32)status < ScanDurationByStatus.size());\n         ScanDurationByStatus[(ui32)status]->Collect(d.MilliSeconds());\n+        ScansFinishedByStatus[(ui32)status]->Add(1);\n     }\n \n     void AckWaitingInfo(const TDuration d) const {\n@@ -257,6 +260,8 @@ class TScanCounters: public TCommonCountersOwner {\n     }\n \n     TScanAggregations BuildAggregations();\n+\n+    void FillStats(::NKikimrTableStats::TTableStats& output) const;\n };\n \n class TCounterGuard: TNonCopyable {\n@@ -282,40 +287,9 @@ class TCounterGuard: TNonCopyable {\n \n };\n \n-class TReaderResourcesGuard {\n-private:\n-    std::shared_ptr<NOlap::NResourceBroker::NSubscribe::TResourcesGuard> Allocated;\n-    std::shared_ptr<TAtomicCounter> Requested;\n-    const std::shared_ptr<NOlap::TMemoryAggregation> SignalCounter;\n-    const ui64 Volume;\n-\n-public:\n-    TReaderResourcesGuard(const ui64 volume, const std::shared_ptr<TAtomicCounter>& requested, const std::shared_ptr<NOlap::TMemoryAggregation>& signalWatcher)\n-        : Requested(requested)\n-        , SignalCounter(signalWatcher)\n-        , Volume(volume)\n-    {\n-        AFL_VERIFY(Requested);\n-        Requested->Add(Volume);\n-        SignalCounter->AddBytes(volume);\n-    }\n-\n-    void InitResources(const std::shared_ptr<NOlap::NResourceBroker::NSubscribe::TResourcesGuard>& g) {\n-        AFL_VERIFY(!Allocated);\n-        AFL_VERIFY(g->GetMemory() == Volume)(\"volume\", Volume)(\"allocated\", g->GetMemory());\n-        Allocated = g;\n-    }\n-\n-    ~TReaderResourcesGuard() {\n-        SignalCounter->RemoveBytes(Volume);\n-        AFL_VERIFY(Requested->Sub(Volume) >= 0);\n-    }\n-};\n-\n class TConcreteScanCounters: public TScanCounters {\n private:\n     using TBase = TScanCounters;\n-    std::shared_ptr<TAtomicCounter> RequestedResourcesBytes;\n     std::shared_ptr<TAtomicCounter> MergeTasksCount;\n     std::shared_ptr<TAtomicCounter> AssembleTasksCount;\n     std::shared_ptr<TAtomicCounter> ReadTasksCount;\n@@ -323,14 +297,6 @@ class TConcreteScanCounters: public TScanCounters {\n public:\n     TScanAggregations Aggregations;\n \n-    ui64 GetRequestedMemoryBytes() const {\n-        return RequestedResourcesBytes->Val();\n-    }\n-\n-    std::shared_ptr<TReaderResourcesGuard> BuildRequestedResourcesGuard(const ui64 volume) const {\n-        return std::make_shared<TReaderResourcesGuard>(volume, RequestedResourcesBytes, Aggregations.GetRequestedResourcesMemory());\n-    }\n-\n     TCounterGuard GetMergeTasksGuard() const {\n         return TCounterGuard(MergeTasksCount);\n     }\n@@ -358,7 +324,6 @@ class TConcreteScanCounters: public TScanCounters {\n \n     TConcreteScanCounters(const TScanCounters& counters)\n         : TBase(counters)\n-        , RequestedResourcesBytes(std::make_shared<TAtomicCounter>())\n         , MergeTasksCount(std::make_shared<TAtomicCounter>())\n         , AssembleTasksCount(std::make_shared<TAtomicCounter>())\n         , ReadTasksCount(std::make_shared<TAtomicCounter>())\ndiff --git a/ydb/core/tx/columnshard/counters/tablet_counters.h b/ydb/core/tx/columnshard/counters/tablet_counters.h\nnew file mode 100644\nindex 000000000000..99292c4f73b8\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/tablet_counters.h\n@@ -0,0 +1,132 @@\n+#pragma once\n+\n+#include <ydb/core/tablet/tablet_counters.h>\n+#include <ydb/core/protos/table_stats.pb.h>\n+#include <ydb/core/protos/counters_columnshard.pb.h>\n+#include <ydb/core/protos/counters_datashard.pb.h>\n+#include <ydb/core/tx/columnshard/engines/column_engine.h>\n+#include <ydb/core/tx/columnshard/engines/insert_table/rt_insertion.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TTabletCountersHandle {\n+private:\n+    TTabletCountersBase& TabletCounters;\n+\n+public:\n+    TTabletCountersHandle(TTabletCountersBase& stats)\n+        : TabletCounters(stats) {\n+    }\n+\n+    void SetCounter(NColumnShard::ESimpleCounters counter, ui64 num) const {\n+        TabletCounters.Simple()[counter].Set(num);\n+    }\n+\n+    void IncCounter(NColumnShard::ECumulativeCounters counter, ui64 num = 1) const {\n+        TabletCounters.Cumulative()[counter].Increment(num);\n+    }\n+\n+    void IncCounter(NColumnShard::EPercentileCounters counter, const TDuration& latency) const {\n+        TabletCounters.Percentile()[counter].IncrementFor(latency.MicroSeconds());\n+    }\n+\n+    void IncCounter(NDataShard::ESimpleCounters counter, ui64 num = 1) const {\n+        TabletCounters.Simple()[counter].Add(num);\n+    }\n+\n+    void IncCounter(NDataShard::ECumulativeCounters counter, ui64 num = 1) const {\n+        TabletCounters.Cumulative()[counter].Increment(num);\n+    }\n+\n+    void IncCounter(NDataShard::EPercentileCounters counter, ui64 num) const {\n+        TabletCounters.Percentile()[counter].IncrementFor(num);\n+    }\n+\n+    void IncCounter(NDataShard::EPercentileCounters counter, const TDuration& latency) const {\n+        TabletCounters.Percentile()[counter].IncrementFor(latency.MilliSeconds());\n+    }\n+\n+    ui64 GetValue(NColumnShard::ESimpleCounters counter) const {\n+        return TabletCounters.Simple()[counter].Get();\n+    }\n+\n+    ui64 GetValue(NColumnShard::ECumulativeCounters counter) const {\n+        return TabletCounters.Cumulative()[counter].Get();\n+    }\n+\n+    const TTabletPercentileCounter& GetValue(NColumnShard::EPercentileCounters counter) const {\n+        return TabletCounters.Percentile()[counter];\n+    }\n+\n+    ui64 GetValue(NDataShard::ESimpleCounters counter) const {\n+        return TabletCounters.Simple()[counter].Get();\n+    }\n+\n+    ui64 GetValue(NDataShard::ECumulativeCounters counter) const {\n+        return TabletCounters.Cumulative()[counter].Get();\n+    }\n+\n+    const TTabletPercentileCounter& GetCounter(NDataShard::EPercentileCounters counter) const {\n+        return TabletCounters.Percentile()[counter];\n+    }\n+\n+    void OnWriteSuccess(const ui64 blobsWritten, const ui64 bytesWritten) const {\n+        IncCounter(NColumnShard::COUNTER_OPERATIONS_BLOBS_WRITTEN, blobsWritten);\n+        IncCounter(NColumnShard::COUNTER_OPERATIONS_BYTES_WRITTEN, bytesWritten);\n+        IncCounter(NColumnShard::COUNTER_WRITE_SUCCESS);\n+    }\n+\n+    void OnWriteFailure() const {\n+        IncCounter(NColumnShard::COUNTER_WRITE_FAIL);\n+    }\n+\n+    void OnScanStarted(const NOlap::TSelectInfo::TStats& countersDelta) const {\n+        IncCounter(NColumnShard::COUNTER_READ_INDEX_PORTIONS, countersDelta.Portions);\n+        IncCounter(NColumnShard::COUNTER_READ_INDEX_BLOBS, countersDelta.Blobs);\n+        IncCounter(NColumnShard::COUNTER_READ_INDEX_ROWS, countersDelta.Rows);\n+        IncCounter(NColumnShard::COUNTER_READ_INDEX_BYTES, countersDelta.Bytes);\n+    }\n+\n+    void OnWriteCommitted(const NOlap::TInsertionSummary::TCounters& countersDelta) const {\n+        IncCounter(COUNTER_BLOBS_COMMITTED, countersDelta.Rows);\n+        IncCounter(COUNTER_BYTES_COMMITTED, countersDelta.Bytes);\n+        IncCounter(COUNTER_RAW_BYTES_COMMITTED, countersDelta.RawBytes);\n+    }\n+\n+    void OnCompactionWriteIndexCompleted(bool success, const ui64 blobsWritten, const ui64 bytesWritten) const {\n+        IncCounter(success ? NColumnShard::COUNTER_SPLIT_COMPACTION_SUCCESS : NColumnShard::COUNTER_SPLIT_COMPACTION_FAIL);\n+        IncCounter(NColumnShard::COUNTER_SPLIT_COMPACTION_BLOBS_WRITTEN, blobsWritten);\n+        IncCounter(NColumnShard::COUNTER_SPLIT_COMPACTION_BYTES_WRITTEN, bytesWritten);\n+    }\n+\n+    void OnInsertionWriteIndexCompleted(const ui64 blobsWritten, const ui64 bytesWritten, const TDuration duration) const {\n+        IncCounter(NColumnShard::COUNTER_INDEXING_BLOBS_WRITTEN, blobsWritten);\n+        IncCounter(NColumnShard::COUNTER_INDEXING_BYTES_WRITTEN, bytesWritten);\n+        IncCounter(NColumnShard::COUNTER_INDEXING_TIME, duration.MilliSeconds());\n+    }\n+\n+    void OnWritePutBlobsSuccess(const ui64 rowsWritten) const {\n+        IncCounter(NColumnShard::COUNTER_OPERATIONS_ROWS_WRITTEN, rowsWritten);\n+    }\n+\n+    void OnDropPortionEvent(const ui64 rawBytes, const ui64 blobBytes, const ui64 rows) const {\n+        IncCounter(NColumnShard::COUNTER_RAW_BYTES_ERASED, rawBytes);\n+        IncCounter(NColumnShard::COUNTER_BYTES_ERASED, blobBytes);\n+        IncCounter(NColumnShard::COUNTER_ROWS_ERASED, rows);\n+    }\n+\n+    void FillStats(::NKikimrTableStats::TTableStats& output) const {\n+        output.SetRowUpdates(GetValue(COUNTER_OPERATIONS_ROWS_WRITTEN));\n+        output.SetRowDeletes(GetValue(COUNTER_ROWS_ERASED));\n+        output.SetRowReads(0);   // all reads are range reads\n+        output.SetRangeReadRows(GetValue(COUNTER_READ_INDEX_ROWS));\n+\n+        output.SetImmediateTxCompleted(GetValue(COUNTER_IMMEDIATE_TX_COMPLETED));\n+        output.SetTxRejectedByOverload(GetValue(COUNTER_WRITE_OVERLOAD));\n+        output.SetTxRejectedBySpace(GetValue(COUNTER_OUT_OF_SPACE));\n+        output.SetPlannedTxCompleted(GetValue(COUNTER_PLANNED_TX_COMPLETED));\n+        output.SetTxCompleteLagMsec(GetValue(COUNTER_TX_COMPLETE_LAG));\n+    }\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/counters/tx_progress.h b/ydb/core/tx/columnshard/counters/tx_progress.h\nnew file mode 100644\nindex 000000000000..24319a3ab748\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/tx_progress.h\n@@ -0,0 +1,110 @@\n+#pragma once\n+#include \"common/owner.h\"\n+\n+#include <library/cpp/monlib/dynamic_counters/counters.h>\n+#include <util/generic/hash.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TTxProgressCounters: public TCommonCountersOwner {\n+private:\n+    using TBase = TCommonCountersOwner;\n+    using TOpType = TString;\n+\n+    class TProgressCounters: public TCommonCountersOwner {\n+    private:\n+        using TBase = TCommonCountersOwner;\n+\n+    public:\n+        NMonitoring::TDynamicCounters::TCounterPtr RegisterTx;\n+        NMonitoring::TDynamicCounters::TCounterPtr RegisterTxWithDeadline;\n+        NMonitoring::TDynamicCounters::TCounterPtr StartProposeOnExecute;\n+        NMonitoring::TDynamicCounters::TCounterPtr StartProposeOnComplete;\n+        NMonitoring::TDynamicCounters::TCounterPtr FinishProposeOnExecute;\n+        NMonitoring::TDynamicCounters::TCounterPtr FinishProposeOnComplete;\n+        NMonitoring::TDynamicCounters::TCounterPtr FinishPlannedTx;\n+        NMonitoring::TDynamicCounters::TCounterPtr AbortTx;\n+        NMonitoring::THistogramPtr HistogramTxExecuteDuration;\n+        NMonitoring::THistogramPtr HistogramTxLiveDuration;\n+        NMonitoring::THistogramPtr HistogramTxProgressLag;\n+\n+        TProgressCounters(const TCommonCountersOwner& owner)\n+            : TBase(owner)\n+            , RegisterTx(TBase::GetDeriviative(\"RegisterTx\"))\n+            , RegisterTxWithDeadline(TBase::GetDeriviative(\"RegisterTxWithDeadline\"))\n+            , StartProposeOnExecute(TBase::GetDeriviative(\"StartProposeOnExecute\"))\n+            , StartProposeOnComplete(TBase::GetDeriviative(\"StartProposeOnComplete\"))\n+            , FinishProposeOnExecute(TBase::GetDeriviative(\"FinishProposeOnExecute\"))\n+            , FinishProposeOnComplete(TBase::GetDeriviative(\"FinishProposeOnComplete\"))\n+            , FinishPlannedTx(TBase::GetDeriviative(\"FinishPlannedTx\"))\n+            , AbortTx(TBase::GetDeriviative(\"AbortTx\"))\n+            , HistogramTxExecuteDuration(TBase::GetHistogram(\"TxProgress/Execution/DurationMs\", NMonitoring::ExponentialHistogram(18, 2, 5)))\n+            , HistogramTxLiveDuration(TBase::GetHistogram(\"TxProgress/Live/DurationMs\", NMonitoring::ExponentialHistogram(18, 2, 5)))\n+            , HistogramTxProgressLag(TBase::GetHistogram(\"TxProgress/LagOnComplete/DurationMs\", NMonitoring::ExponentialHistogram(18, 2, 5))) {\n+        }\n+    };\n+\n+    THashMap<TOpType, TProgressCounters> CountersByOpType;\n+\n+public:\n+    void OnTxExecuteDuration(const TString& opType, const TDuration d) {\n+        GetSubGroup(opType).HistogramTxExecuteDuration->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnTxLiveDuration(const TString& opType, const TDuration d) {\n+        GetSubGroup(opType).HistogramTxLiveDuration->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnTxProgressLag(const TString& opType, const TDuration d) {\n+        GetSubGroup(opType).HistogramTxProgressLag->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnRegisterTx(const TOpType& opType) {\n+        GetSubGroup(opType).RegisterTx->Add(1);\n+    }\n+\n+    void OnRegisterTxWithDeadline(const TOpType& opType) {\n+        GetSubGroup(opType).RegisterTxWithDeadline->Add(1);\n+    }\n+\n+    void OnStartProposeOnExecute(const TOpType& opType) {\n+        GetSubGroup(opType).StartProposeOnExecute->Add(1);\n+    }\n+\n+    void OnStartProposeOnComplete(const TOpType& opType) {\n+        GetSubGroup(opType).StartProposeOnComplete->Add(1);\n+    }\n+\n+    void OnFinishProposeOnExecute(const TOpType& opType) {\n+        GetSubGroup(opType).FinishProposeOnExecute->Add(1);\n+    }\n+\n+    void OnFinishProposeOnComplete(const TOpType& opType) {\n+        GetSubGroup(opType).FinishProposeOnComplete->Add(1);\n+    }\n+\n+    void OnFinishPlannedTx(const TOpType& opType) {\n+        GetSubGroup(opType).FinishPlannedTx->Add(1);\n+    }\n+\n+    void OnAbortTx(const TOpType& opType) {\n+        GetSubGroup(opType).AbortTx->Add(1);\n+    }\n+\n+    TTxProgressCounters(TCommonCountersOwner& owner)\n+        : TBase(owner, \"TxProgress\") {\n+    }\n+\n+private:\n+    TProgressCounters& GetSubGroup(const TOpType& opType) {\n+        auto findSubGroup = CountersByOpType.FindPtr(opType);\n+        if (findSubGroup) {\n+            return *findSubGroup;\n+        }\n+\n+        auto subGroup = TBase::CreateSubGroup(\"operation\", opType);\n+        return CountersByOpType.emplace(opType, subGroup).first->second;\n+    }\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/counters/writes_monitor.h b/ydb/core/tx/columnshard/counters/writes_monitor.h\nnew file mode 100644\nindex 000000000000..ad8ad6e474cc\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/counters/writes_monitor.h\n@@ -0,0 +1,46 @@\n+#pragma once\n+\n+#include <ydb/core/protos/counters_columnshard.pb.h>\n+#include <ydb/core/tablet/tablet_counters.h>\n+#include <ydb/library/accessor/accessor.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TWritesMonitor {\n+private:\n+    TTabletCountersBase& Stats;\n+    \n+    YDB_READONLY(ui64, WritesInFlight, 0);\n+    YDB_READONLY(ui64, WritesSizeInFlight, 0);\n+\n+public:\n+    TWritesMonitor(TTabletCountersBase& stats)\n+        : Stats(stats) {\n+    }\n+\n+    void OnStartWrite(const ui64 dataSize) {\n+        ++WritesInFlight;\n+        WritesSizeInFlight += dataSize;\n+        UpdateTabletCounters();\n+    }\n+\n+    void OnFinishWrite(const ui64 dataSize, const ui32 writesCount = 1) {\n+        Y_ABORT_UNLESS(WritesInFlight > 0);\n+        Y_ABORT_UNLESS(WritesSizeInFlight >= dataSize);\n+        WritesInFlight -= writesCount;\n+        WritesSizeInFlight -= dataSize;\n+        UpdateTabletCounters();\n+    }\n+\n+    TString DebugString() const {\n+        return TStringBuilder() << \"{object=write_monitor;count=\" << WritesInFlight << \";size=\" << WritesSizeInFlight\n+                                << \"}\";\n+    }\n+\n+private:\n+    void UpdateTabletCounters() {\n+        Stats.Simple()[COUNTER_WRITES_IN_FLY].Set(WritesInFlight);\n+    }\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/counters/ya.make b/ydb/core/tx/columnshard/counters/ya.make\nindex 65797cb34752..8707d6080e30 100644\n--- a/ydb/core/tx/columnshard/counters/ya.make\n+++ b/ydb/core/tx/columnshard/counters/ya.make\n@@ -1,18 +1,23 @@\n LIBRARY()\n \n SRCS(\n-    indexation.cpp\n-    scan.cpp\n-    engine_logs.cpp\n+    background_controller.cpp\n+    counters_manager.cpp\n     blobs_manager.cpp\n+    column_tables.cpp\n     columnshard.cpp\n-    insert_table.cpp\n     common_data.cpp\n+    engine_logs.cpp\n+    indexation.cpp\n+    insert_table.cpp\n+    req_tracer.cpp\n+    scan.cpp\n     splitter.cpp\n )\n \n PEERDIR(\n     library/cpp/monlib/dynamic_counters\n+    ydb/core/tx/columnshard/counters/aggregation\n     ydb/core/tx/columnshard/counters/common\n     ydb/core/base\n )\ndiff --git a/ydb/core/tx/columnshard/data_sharing/common/transactions/tx_extension.h b/ydb/core/tx/columnshard/data_sharing/common/transactions/tx_extension.h\nindex 055081e37173..ea9c99c7fd9d 100644\n--- a/ydb/core/tx/columnshard/data_sharing/common/transactions/tx_extension.h\n+++ b/ydb/core/tx/columnshard/data_sharing/common/transactions/tx_extension.h\n@@ -15,11 +15,11 @@ class TExtendedTransactionBase: public NTabletFlatExecutor::TTransactionBase<TSh\n \n public:\n     virtual bool Execute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& ctx) override final {\n-        NActors::TLogContextGuard logGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", TBase::Self->TabletID())(\"tx_no\", TabletTxNo)(\"tx_info\", TxInfo);\n+        NActors::TLogContextGuard logGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", TBase::Self->TabletID())(\"local_tx_no\", TabletTxNo)(\"tx_info\", TxInfo);\n         return DoExecute(txc, ctx);\n     }\n     virtual void Complete(const NActors::TActorContext& ctx) override final {\n-        NActors::TLogContextGuard logGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", TBase::Self->TabletID())(\"tx_no\", TabletTxNo)(\"tx_info\", TxInfo);\n+        NActors::TLogContextGuard logGuard = NActors::TLogContextBuilder::Build()(\"tablet_id\", TBase::Self->TabletID())(\"local_tx_no\", TabletTxNo)(\"tx_info\", TxInfo);\n         return DoComplete(ctx);\n     }\n \ndiff --git a/ydb/core/tx/columnshard/data_sharing/source/session/cursor.cpp b/ydb/core/tx/columnshard/data_sharing/source/session/cursor.cpp\nindex 1072d6ff1cb6..5bc37cd29122 100644\n--- a/ydb/core/tx/columnshard/data_sharing/source/session/cursor.cpp\n+++ b/ydb/core/tx/columnshard/data_sharing/source/session/cursor.cpp\n@@ -1,7 +1,7 @@\n #include \"source.h\"\n #include <ydb/core/tx/columnshard/engines/column_engine_logs.h>\n #include <ydb/core/tx/columnshard/data_sharing/destination/events/transfer.h>\n-#include <ydb/core/formats/arrow/hash/xx_hash.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n \n namespace NKikimr::NOlap::NDataSharing {\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/abstract/abstract.cpp b/ydb/core/tx/columnshard/engines/changes/abstract/abstract.cpp\nindex 7dfe36689d48..7d37981a9039 100644\n--- a/ydb/core/tx/columnshard/engines/changes/abstract/abstract.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/abstract/abstract.cpp\n@@ -46,7 +46,7 @@ void TColumnEngineChanges::WriteIndexOnComplete(NColumnShard::TColumnShard* self\n     DoWriteIndexOnComplete(self, context);\n     if (self) {\n         OnFinish(*self, context);\n-        self->IncCounter(GetCounterIndex(context.FinishedSuccessfully));\n+        self->Counters.GetTabletCounters()->IncCounter(GetCounterIndex(context.FinishedSuccessfully));\n     }\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/changes/cleanup_portions.cpp b/ydb/core/tx/columnshard/engines/changes/cleanup_portions.cpp\nindex 3aa29ed01a13..7917b77682b9 100644\n--- a/ydb/core/tx/columnshard/engines/changes/cleanup_portions.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/cleanup_portions.cpp\n@@ -17,19 +17,19 @@ void TCleanupPortionsColumnEngineChanges::DoDebugString(TStringOutput& out) cons\n \n void TCleanupPortionsColumnEngineChanges::DoWriteIndexOnExecute(NColumnShard::TColumnShard* self, TWriteIndexContext& context) {\n     THashSet<ui64> pathIds;\n-    if (self) {\n-        THashMap<TString, THashSet<TUnifiedBlobId>> blobIdsByStorage;\n-        for (auto&& p : PortionsToDrop) {\n-            p.RemoveFromDatabase(context.DBWrapper);\n-\n-            p.FillBlobIdsByStorage(blobIdsByStorage, context.EngineLogs.GetVersionedIndex());\n-            pathIds.emplace(p.GetPathId());\n-        }\n-        for (auto&& i : blobIdsByStorage) {\n-            auto action = BlobsAction.GetRemoving(i.first);\n-            for (auto&& b : i.second) {\n-                action->DeclareRemove((TTabletId)self->TabletID(), b);\n-            }\n+    if (!self) {\n+        return;\n+    }\n+    THashMap<TString, THashSet<TUnifiedBlobId>> blobIdsByStorage;\n+    for (auto&& p : PortionsToDrop) {\n+        p.RemoveFromDatabase(context.DBWrapper);\n+        p.FillBlobIdsByStorage(blobIdsByStorage, context.EngineLogs.GetVersionedIndex());\n+        pathIds.emplace(p.GetPathId());\n+    }\n+    for (auto&& i : blobIdsByStorage) {\n+        auto action = BlobsAction.GetRemoving(i.first);\n+        for (auto&& b : i.second) {\n+            action->DeclareRemove((TTabletId)self->TabletID(), b);\n         }\n     }\n }\n@@ -41,9 +41,9 @@ void TCleanupPortionsColumnEngineChanges::DoWriteIndexOnComplete(NColumnShard::T\n         }\n     }\n     if (self) {\n-        self->IncCounter(NColumnShard::COUNTER_PORTIONS_ERASED, PortionsToDrop.size());\n+        self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_PORTIONS_ERASED, PortionsToDrop.size());\n         for (auto&& p : PortionsToDrop) {\n-            self->IncCounter(NColumnShard::COUNTER_RAW_BYTES_ERASED, p.GetTotalRawBytes());\n+            self->Counters.GetTabletCounters()->OnDropPortionEvent(p.GetTotalRawBytes(), p.GetTotalBlobBytes(), p.NumRows());\n         }\n     }\n }\ndiff --git a/ydb/core/tx/columnshard/engines/changes/cleanup_tables.cpp b/ydb/core/tx/columnshard/engines/changes/cleanup_tables.cpp\nindex 3bd8cb6bc333..34d7354b5124 100644\n--- a/ydb/core/tx/columnshard/engines/changes/cleanup_tables.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/cleanup_tables.cpp\n@@ -17,13 +17,15 @@ void TCleanupTablesColumnEngineChanges::DoDebugString(TStringOutput& out) const\n void TCleanupTablesColumnEngineChanges::DoWriteIndexOnExecute(NColumnShard::TColumnShard* self, TWriteIndexContext& context) {\n     if (self && context.DB) {\n         for (auto&& t : TablesToDrop) {\n-            self->TablesManager.TryFinalizeDropPathOnExecute(*context.DB, t);\n+            AFL_VERIFY(!self->InsertTable->HasDataInPathId(t));\n+            AFL_VERIFY(self->TablesManager.TryFinalizeDropPathOnExecute(*context.DB, t));\n         }\n     }\n }\n \n void TCleanupTablesColumnEngineChanges::DoWriteIndexOnComplete(NColumnShard::TColumnShard* self, TWriteIndexCompleteContext& /*context*/) {\n     for (auto&& t : TablesToDrop) {\n+        self->InsertTable->ErasePath(t);\n         self->TablesManager.TryFinalizeDropPathOnComplete(t);\n     }\n     self->Subscribers->OnEvent(std::make_shared<NColumnShard::NSubscriber::TEventTablesErased>(TablesToDrop));\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction.cpp b/ydb/core/tx/columnshard/engines/changes/compaction.cpp\nindex a94d160158e6..2441ce4248b8 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction.cpp\n@@ -53,7 +53,7 @@ void TCompactColumnEngineChanges::DoStart(NColumnShard::TColumnShard& self) {\n void TCompactColumnEngineChanges::DoWriteIndexOnComplete(NColumnShard::TColumnShard* self, TWriteIndexCompleteContext& context) {\n     TBase::DoWriteIndexOnComplete(self, context);\n     if (self) {\n-        self->IncCounter(NColumnShard::COUNTER_COMPACTION_TIME, context.Duration.MilliSeconds());\n+        self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_COMPACTION_TIME, context.Duration.MilliSeconds());\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.cpp\nindex 57a26422d8ca..9977ef51219c 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.cpp\n@@ -2,14 +2,30 @@\n \n namespace NKikimr::NOlap::NCompaction {\n \n-void IColumnMerger::Start(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input) {\n+void IColumnMerger::Start(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& mergeContext) {\n     AFL_VERIFY(!Started);\n     Started = true;\n-    // for (auto&& i : input) {\n-    //     AFL_VERIFY(i->GetDataType()->id() == Context.GetResultField()->type()->id())(\"input\", i->GetDataType()->ToString())(\n-    //                                              \"result\", Context.GetResultField()->ToString());\n-    // }\n-    return DoStart(input);\n+    for (auto&& i : input) {\n+        if (!i) {\n+            continue;\n+        }\n+        AFL_VERIFY(i->GetDataType()->Equals(*Context.GetResultField()->type()))(\"input\", i->GetDataType()->ToString())(\n+                                                 \"result\", Context.GetResultField()->ToString());\n+    }\n+    return DoStart(input, mergeContext);\n }\n \n+ TMergingChunkContext::TMergingChunkContext(const std::shared_ptr<arrow::RecordBatch>& pkAndAddresses) {\n+    auto columnPortionIdx = pkAndAddresses->GetColumnByName(IColumnMerger::PortionIdFieldName);\n+    auto columnPortionRecordIdx = pkAndAddresses->GetColumnByName(IColumnMerger::PortionRecordIndexFieldName);\n+    Y_ABORT_UNLESS(columnPortionIdx && columnPortionRecordIdx);\n+    Y_ABORT_UNLESS(columnPortionIdx->type_id() == arrow::UInt16Type::type_id);\n+    Y_ABORT_UNLESS(columnPortionRecordIdx->type_id() == arrow::UInt32Type::type_id);\n+    IdxArray = static_pointer_cast<arrow::UInt16Array>(columnPortionIdx);\n+    RecordIdxArray = static_pointer_cast<arrow::UInt32Array>(columnPortionRecordIdx);\n+\n+    AFL_VERIFY(pkAndAddresses->num_rows() == IdxArray->length());\n+    AFL_VERIFY(pkAndAddresses->num_rows() == RecordIdxArray->length());\n }\n+\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.h b/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.h\nindex dc547e69dcef..bf8da708f36b 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.h\n@@ -1,15 +1,124 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/engines/changes/compaction/common/result.h>\n #include <ydb/core/tx/columnshard/engines/changes/compaction/common/context.h>\n+#include <ydb/core/tx/columnshard/engines/changes/compaction/common/result.h>\n \n namespace NKikimr::NOlap::NCompaction {\n+\n+class TMergingChunkContext {\n+private:\n+    std::shared_ptr<arrow::UInt16Array> IdxArray;\n+    std::shared_ptr<arrow::UInt32Array> RecordIdxArray;\n+\n+public:\n+    const arrow::UInt16Array& GetIdxArray() const {\n+        return *IdxArray;\n+    }\n+    const arrow::UInt32Array& GetRecordIdxArray() const {\n+        return *RecordIdxArray;\n+    }\n+\n+    TMergingChunkContext(const std::shared_ptr<arrow::RecordBatch>& pkAndAddresses);\n+};\n+\n+class TMergingContext {\n+public:\n+    class TAddress {\n+    private:\n+        YDB_ACCESSOR(i32, ChunkIdx, -1);\n+        YDB_ACCESSOR(i32, GlobalPosition, -1);\n+\n+    public:\n+        TAddress() = default;\n+        bool operator<(const TAddress& item) const {\n+            if (ChunkIdx < item.ChunkIdx) {\n+                return true;\n+            } else if (item.ChunkIdx < ChunkIdx) {\n+                return false;\n+            } else {\n+                return GlobalPosition < item.GlobalPosition;\n+            }\n+        }\n+\n+        bool IsValid() const {\n+            return ChunkIdx >= 0 && GlobalPosition >= 0;\n+        }\n+    };\n+\n+private:\n+    YDB_READONLY_DEF(std::vector<TMergingChunkContext>, Chunks);\n+    std::vector<std::shared_ptr<NArrow::TGeneralContainer>> InputContainers;\n+\n+    std::optional<std::vector<std::vector<TAddress>>> RemapPortionIndexToResultIndex;\n+\n+public:\n+    const TMergingChunkContext& GetChunk(const ui32 idx) const {\n+        AFL_VERIFY(idx < Chunks.size());\n+        return Chunks[idx];\n+    }\n+\n+    bool HasRemapInfo(const ui32 idx) {\n+        return GetRemapPortionIndexToResultIndex(idx).size();\n+    }\n+\n+    const std::vector<std::vector<TAddress>>& GetRemapPortionIndexToResultIndex() {\n+        if (!RemapPortionIndexToResultIndex) {\n+            std::vector<std::vector<TAddress>> result;\n+            result.resize(InputContainers.size());\n+            {\n+                ui32 idx = 0;\n+                for (auto&& p : InputContainers) {\n+                    if (p) {\n+                        result[idx].resize(p->GetRecordsCount());\n+                    }\n+                    ++idx;\n+                }\n+            }\n+            ui32 chunkIdx = 0;\n+            for (auto&& i : Chunks) {\n+                auto& pIdxArray = i.GetIdxArray();\n+                auto& pRecordIdxArray = i.GetRecordIdxArray();\n+                for (ui32 recordIdx = 0; recordIdx < i.GetIdxArray().length(); ++recordIdx) {\n+                    auto& sourceRemap = result[pIdxArray.Value(recordIdx)];\n+                    if (sourceRemap.size()) {\n+                        sourceRemap[pRecordIdxArray.Value(recordIdx)].SetChunkIdx(chunkIdx);\n+                        sourceRemap[pRecordIdxArray.Value(recordIdx)].SetGlobalPosition(recordIdx);\n+                    }\n+                }\n+                ++chunkIdx;\n+            }\n+            RemapPortionIndexToResultIndex = std::move(result);\n+        }\n+        return *RemapPortionIndexToResultIndex;\n+    }\n+\n+    const std::vector<TAddress>& GetRemapPortionIndexToResultIndex(const ui32 idx) {\n+        auto& result = GetRemapPortionIndexToResultIndex();\n+        AFL_VERIFY(idx < result.size());\n+        return result[idx];\n+    }\n+\n+    TMergingContext(const std::vector<std::shared_ptr<arrow::RecordBatch>>& pkAndAddresses,\n+        const std::vector<std::shared_ptr<NArrow::TGeneralContainer>>& inputContainers)\n+        : InputContainers(inputContainers)\n+    {\n+        for (auto&& i : pkAndAddresses) {\n+            Chunks.emplace_back(i);\n+        }\n+    }\n+};\n+\n class IColumnMerger {\n+public:\n+    using TFactory = NObjectFactory::TParametrizedObjectFactory<IColumnMerger, TString, const TColumnMergeContext&>;\n+\n private:\n     bool Started = false;\n \n-    virtual std::vector<TColumnPortionResult> DoExecute(\n-        const NCompaction::TColumnMergeContext& context, const arrow::UInt16Array& pIdxArray, const arrow::UInt32Array& pRecordIdxArray) = 0;\n-    virtual void DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input) = 0;\n+    virtual std::vector<TColumnPortionResult> DoExecute(const TChunkMergeContext& context, TMergingContext& mergeContext) = 0;\n+    virtual void DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& mergeContext) = 0;\n+\n+protected:\n+    const TColumnMergeContext& Context;\n \n public:\n     static inline const TString PortionIdFieldName = \"$$__portion_id\";\n@@ -19,25 +128,15 @@ class IColumnMerger {\n     static inline const std::shared_ptr<arrow::Field> PortionRecordIndexField =\n         std::make_shared<arrow::Field>(PortionRecordIndexFieldName, std::make_shared<arrow::UInt32Type>());\n \n+    IColumnMerger(const TColumnMergeContext& context)\n+        : Context(context) {\n+    }\n     virtual ~IColumnMerger() = default;\n \n-    void Start(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input);\n-\n-    std::vector<TColumnPortionResult> Execute(\n-        const NCompaction::TColumnMergeContext& context, const std::shared_ptr<arrow::RecordBatch>& remap) {\n-\n-        auto columnPortionIdx = remap->GetColumnByName(IColumnMerger::PortionIdFieldName);\n-        auto columnPortionRecordIdx = remap->GetColumnByName(IColumnMerger::PortionRecordIndexFieldName);\n-        Y_ABORT_UNLESS(columnPortionIdx && columnPortionRecordIdx);\n-        Y_ABORT_UNLESS(columnPortionIdx->type_id() == arrow::UInt16Type::type_id);\n-        Y_ABORT_UNLESS(columnPortionRecordIdx->type_id() == arrow::UInt32Type::type_id);\n-        const arrow::UInt16Array& pIdxArray = static_cast<const arrow::UInt16Array&>(*columnPortionIdx);\n-        const arrow::UInt32Array& pRecordIdxArray = static_cast<const arrow::UInt32Array&>(*columnPortionRecordIdx);\n-\n-        AFL_VERIFY(remap->num_rows() == pIdxArray.length());\n-        AFL_VERIFY(remap->num_rows() == pRecordIdxArray.length());\n+    void Start(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& mergeContext);\n \n-        return DoExecute(context, pIdxArray, pRecordIdxArray);\n+    std::vector<TColumnPortionResult> Execute(const TChunkMergeContext& context, TMergingContext& mergeContext) {\n+        return DoExecute(context, mergeContext);\n     }\n };\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/common/context.h b/ydb/core/tx/columnshard/engines/changes/compaction/common/context.h\nindex 80356224909f..73117725614d 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/common/context.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/common/context.h\n@@ -1,8 +1,8 @@\n #pragma once\n+#include <ydb/library/formats/arrow/splitter/stats.h>\n #include <ydb/core/tx/columnshard/engines/scheme/abstract_scheme.h>\n #include <ydb/core/tx/columnshard/engines/scheme/column_features.h>\n #include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n-#include <ydb/core/tx/columnshard/splitter/stats.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \n@@ -12,25 +12,29 @@ class TColumnMergeContext {\n private:\n     YDB_READONLY(ui32, ColumnId, 0);\n     ISnapshotSchema::TPtr SchemaInfo;\n-    YDB_READONLY_DEF(TColumnSaver, Saver);\n+    YDB_ACCESSOR_DEF(TColumnSaver, Saver);\n     YDB_READONLY_DEF(std::shared_ptr<TColumnLoader>, Loader);\n     YDB_READONLY_DEF(std::shared_ptr<arrow::Field>, ResultField);\n-    YDB_READONLY(ui32, PortionRowsCountLimit, 10000);\n     YDB_READONLY(ui64, ChunkPackedBytesLimit, 7 * 1024 * 1024);\n     YDB_READONLY(ui64, ExpectedBlobPackedBytes, 4 * 1024 * 1024);\n     YDB_READONLY(ui64, ChunkRawBytesLimit, 50 * 1024 * 1024);\n     YDB_READONLY(ui64, StorePackedChunkSizeLimit, 512 * 1024);\n     YDB_READONLY(bool, UseWholeChunksOptimization, true);\n \n-    std::optional<TColumnSerializationStat> ColumnStat;\n+    std::optional<NArrow::NSplitter::TColumnSerializationStat> ColumnStat;\n \n     const TIndexInfo& IndexInfo;\n+\n public:\n+    std::shared_ptr<arrow::Scalar> GetDefaultValue() const {\n+        return Loader->GetDefaultValue();\n+    }\n+\n     ISnapshotSchema::TPtr GetSchemaInfo() const {\n         return SchemaInfo;\n     }\n \n-    const std::optional<TColumnSerializationStat>& GetColumnStat() const {\n+    const std::optional<NArrow::NSplitter::TColumnSerializationStat>& GetColumnStat() const {\n         return ColumnStat;\n     }\n \n@@ -42,25 +46,35 @@ class TColumnMergeContext {\n         return IndexInfo;\n     }\n \n-    TColumnMergeContext(const ui32 columnId, const ISnapshotSchema::TPtr& schema, const ui32 portionRowsCountLimit,\n-        const ui32 chunkRawBytesLimit, const std::optional<TColumnSerializationStat>& columnStat,\n-        const NArrow::NSerialization::TSerializerContainer& overrideSerializer)\n+    TColumnMergeContext(const ui32 columnId, const ISnapshotSchema::TPtr& schema, const ui32 chunkRawBytesLimit,\n+        const std::optional<NArrow::NSplitter::TColumnSerializationStat>& columnStat)\n         : ColumnId(columnId)\n         , SchemaInfo(schema)\n         , Saver(schema->GetColumnSaver(columnId))\n         , Loader(schema->GetColumnLoaderOptional(columnId))\n         , ResultField(schema->GetIndexInfo().GetColumnFieldVerified(columnId))\n-        , PortionRowsCountLimit(portionRowsCountLimit)\n         , ChunkRawBytesLimit(chunkRawBytesLimit)\n         , UseWholeChunksOptimization(!schema->GetIndexInfo().GetReplaceKey()->GetFieldByName(ResultField->name()))\n         , ColumnStat(columnStat)\n         , IndexInfo(schema->GetIndexInfo()) {\n-        Y_ABORT_UNLESS(PortionRowsCountLimit);\n         Y_ABORT_UNLESS(ChunkRawBytesLimit);\n-        if (!!overrideSerializer) {\n-            Saver.ResetSerializer(overrideSerializer);\n-        }\n     }\n };\n \n-}\n+class TChunkMergeContext {\n+private:\n+    YDB_READONLY(ui32, PortionRowsCountLimit, 10000);\n+    YDB_READONLY(ui32, BatchIdx, 0);\n+    YDB_READONLY(ui32, RecordsCount, 0);\n+\n+public:\n+    TChunkMergeContext(const ui32 portionRowsCountLimit, const ui32 batchIdx, const ui32 recordsCount)\n+        : PortionRowsCountLimit(portionRowsCountLimit)\n+        , BatchIdx(batchIdx)\n+        , RecordsCount(recordsCount)\n+    {\n+        AFL_VERIFY(RecordsCount);\n+        AFL_VERIFY(PortionRowsCountLimit);\n+    }\n+};\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/merger.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/merger.cpp\nindex 599b1b2d3159..439426439867 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/merger.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/merger.cpp\n@@ -2,16 +2,17 @@\n \n #include \"abstract/merger.h\"\n #include \"plain/logic.h\"\n+#include \"sparsed/logic.h\"\n \n #include <ydb/core/formats/arrow/reader/merger.h>\n #include <ydb/core/formats/arrow/serializer/native.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n #include <ydb/core/tx/columnshard/splitter/batch_slice.h>\n \n namespace NKikimr::NOlap::NCompaction {\n \n-std::vector<NKikimr::NOlap::TWritePortionInfoWithBlobsResult> TMerger::Execute(const std::shared_ptr<TSerializationStats>& stats,\n+std::vector<TWritePortionInfoWithBlobsResult> TMerger::Execute(const std::shared_ptr<NArrow::NSplitter::TSerializationStats>& stats,\n     const NArrow::NMerger::TIntervalPositions& checkPoints, const std::shared_ptr<TFilteredSnapshotSchema>& resultFiltered, const ui64 pathId,\n     const std::optional<ui64> shardingActualVersion) {\n     AFL_VERIFY(Batches.size() == Filters.size());\n@@ -30,8 +31,6 @@ std::vector<NKikimr::NOlap::TWritePortionInfoWithBlobsResult> TMerger::Execute(c\n \n         ui32 idx = 0;\n         for (auto&& batch : Batches) {\n-            AFL_VERIFY(batch->GetColumnsCount() == resultFiltered->GetColumnsCount())(\"data\", batch->GetColumnsCount())(\n-                                                       \"schema\", resultFiltered->GetColumnsCount());\n             {\n                 NArrow::NConstruction::IArrayBuilder::TPtr column =\n                     std::make_shared<NArrow::NConstruction::TSimpleArrayConstructor<NArrow::NConstruction::TIntConstFiller<arrow::UInt16Type>>>(\n@@ -52,43 +51,57 @@ std::vector<NKikimr::NOlap::TWritePortionInfoWithBlobsResult> TMerger::Execute(c\n \n     std::vector<std::map<ui32, std::vector<TColumnPortionResult>>> chunkGroups;\n     chunkGroups.resize(batchResults.size());\n-    for (auto&& columnId : resultFiltered->GetColumnIds()) {\n-        NActors::TLogContextGuard logGuard(\n-            NActors::TLogContextBuilder::Build()(\"field_name\", resultFiltered->GetIndexInfo().GetColumnName(columnId)));\n-        auto columnInfo = stats->GetColumnInfo(columnId);\n-        std::shared_ptr<IColumnMerger> merger = std::make_shared<TPlainMerger>();\n-        //        resultFiltered->BuildColumnMergerVerified(columnId);\n \n-        {\n-            std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> parts;\n-            for (auto&& p : Batches) {\n-                parts.emplace_back(p->GetColumnVerified(resultFiltered->GetFieldIndex(columnId)));\n+    using TColumnData = std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>;\n+    THashMap<ui32, TColumnData> columnsData;\n+    {\n+        ui32 batchIdx = 0;\n+        for (auto&& p : Batches) {\n+            ui32 columnIdx = 0;\n+            for (auto&& i : p->GetSchema()->GetFields()) {\n+                const std::optional<ui32> columnId = resultFiltered->GetIndexInfo().GetColumnIdOptional(i->name());\n+                if (columnId) {\n+                    auto it = columnsData.find(*columnId);\n+                    if (it == columnsData.end()) {\n+                        it = columnsData.emplace(*columnId, TColumnData(Batches.size())).first;\n+                    }\n+                    it->second[batchIdx] = p->GetColumnVerified(columnIdx);\n+                }\n+                ++columnIdx;\n             }\n+            ++batchIdx;\n+        }\n+    }\n+\n+    TMergingContext mergingContext(batchResults, Batches);\n \n-            merger->Start(parts);\n+    for (auto&& [columnId, columnData] : columnsData) {\n+        const TString& columnName = resultFiltered->GetIndexInfo().GetColumnName(columnId);\n+        NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()(\"field_name\", columnName));\n+        auto columnInfo = stats->GetColumnInfo(columnId);\n+\n+        TColumnMergeContext commonContext(\n+            columnId, resultFiltered, NSplitter::TSplitSettings().GetExpectedUnpackColumnChunkRawSize(), columnInfo);\n+        if (OptimizationWritingPackMode) {\n+            commonContext.MutableSaver().AddSerializerWithBorder(\n+                100, std::make_shared<NArrow::NSerialization::TNativeSerializer>(arrow::Compression::type::UNCOMPRESSED));\n+            commonContext.MutableSaver().AddSerializerWithBorder(\n+                Max<ui32>(), std::make_shared<NArrow::NSerialization::TNativeSerializer>(arrow::Compression::type::LZ4_FRAME));\n         }\n \n-        std::map<std::string, std::vector<NCompaction::TColumnPortionResult>> columnChunks;\n+        THolder<IColumnMerger> merger =\n+            IColumnMerger::TFactory::MakeHolder(commonContext.GetLoader()->GetAccessorConstructor().GetClassName(), commonContext);\n+        AFL_VERIFY(!!merger)(\"problem\", \"cannot create merger\")(\n+            \"class_name\", commonContext.GetLoader()->GetAccessorConstructor().GetClassName());\n+        merger->Start(columnData, mergingContext);\n+\n         ui32 batchIdx = 0;\n         for (auto&& batchResult : batchResults) {\n             const ui32 portionRecordsCountLimit =\n                 batchResult->num_rows() / (batchResult->num_rows() / NSplitter::TSplitSettings().GetExpectedRecordsCountOnPage() + 1) + 1;\n \n-            NArrow::NSerialization::TSerializerContainer externalSaver;\n-            if (OptimizationWritingPackMode) {\n-                if (batchResult->num_rows() < 100) {\n-                    externalSaver = NArrow::NSerialization::TSerializerContainer(\n-                        std::make_shared<NArrow::NSerialization::TNativeSerializer>(arrow::Compression::type::UNCOMPRESSED));\n-                } else {\n-                    externalSaver = NArrow::NSerialization::TSerializerContainer(\n-                        std::make_shared<NArrow::NSerialization::TNativeSerializer>(arrow::Compression::type::LZ4_FRAME));\n-                }\n-            }\n-\n-            NCompaction::TColumnMergeContext context(columnId, resultFiltered, portionRecordsCountLimit,\n-                NSplitter::TSplitSettings().GetExpectedUnpackColumnChunkRawSize(), columnInfo, externalSaver);\n-\n-            chunkGroups[batchIdx][columnId] = merger->Execute(context, batchResult);\n+            TChunkMergeContext context(portionRecordsCountLimit, batchIdx, batchResult->num_rows());\n+            chunkGroups[batchIdx][columnId] = merger->Execute(context, mergingContext);\n             ++batchIdx;\n         }\n     }\n@@ -129,7 +142,7 @@ std::vector<NKikimr::NOlap::TWritePortionInfoWithBlobsResult> TMerger::Execute(c\n             }\n             batchSlices.emplace_back(portionColumns, schemaDetails, Context.Counters.SplitterCounters);\n         }\n-        TSimilarPacker slicer(NSplitter::TSplitSettings().GetExpectedPortionSize());\n+        NArrow::NSplitter::TSimilarPacker slicer(NSplitter::TSplitSettings().GetExpectedPortionSize());\n         auto packs = slicer.Split(batchSlices);\n \n         ui32 recordIdx = 0;\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/merger.h b/ydb/core/tx/columnshard/engines/changes/compaction/merger.h\nindex be9beae47584..9c84799fe8ad 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/merger.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/merger.h\n@@ -1,8 +1,8 @@\n #pragma once\n-#include <ydb/core/formats/arrow/common/container.h>\n #include <ydb/core/formats/arrow/arrow_filter.h>\n+#include <ydb/core/formats/arrow/common/container.h>\n #include <ydb/core/formats/arrow/reader/position.h>\n-#include <ydb/core/tx/columnshard/splitter/stats.h>\n+#include <ydb/library/formats/arrow/splitter/stats.h>\n #include <ydb/core/tx/columnshard/engines/changes/abstract/abstract.h>\n #include <ydb/core/tx/columnshard/engines/portions/write_with_blobs.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.h>\n@@ -25,14 +25,11 @@ class TMerger {\n \n     TMerger(const TConstructionContext& context, const TSaverContext& saverContext)\n         : Context(context)\n-        , SaverContext(saverContext)\n-    {\n-    \n+        , SaverContext(saverContext) {\n     }\n \n     TMerger(const TConstructionContext& context, const TSaverContext& saverContext,\n-        std::vector<std::shared_ptr<NArrow::TGeneralContainer>>&& batches,\n-        std::vector<std::shared_ptr<NArrow::TColumnFilter>>&& filters)\n+        std::vector<std::shared_ptr<NArrow::TGeneralContainer>>&& batches, std::vector<std::shared_ptr<NArrow::TColumnFilter>>&& filters)\n         : Batches(std::move(batches))\n         , Filters(std::move(filters))\n         , Context(context)\n@@ -40,9 +37,8 @@ class TMerger {\n         AFL_VERIFY(Batches.size() == Filters.size());\n     }\n \n-    std::vector<NKikimr::NOlap::TWritePortionInfoWithBlobsResult> Execute(\n-        const std::shared_ptr<TSerializationStats>& stats,\n-        const NArrow::NMerger::TIntervalPositions& checkPoints,\n-        const std::shared_ptr<TFilteredSnapshotSchema>& resultFiltered, const ui64 pathId, const std::optional<ui64> shardingActualVersion);\n+    std::vector<TWritePortionInfoWithBlobsResult> Execute(const std::shared_ptr<NArrow::NSplitter::TSerializationStats>& stats,\n+        const NArrow::NMerger::TIntervalPositions& checkPoints, const std::shared_ptr<TFilteredSnapshotSchema>& resultFiltered,\n+        const ui64 pathId, const std::optional<ui64> shardingActualVersion);\n };\n-}\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.cpp\nindex 65412522c879..9fd0c4d301e1 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.cpp\n@@ -1,37 +1,44 @@\n #include \"column_cursor.h\"\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n \n namespace NKikimr::NOlap::NCompaction {\n \n bool TPortionColumnCursor::Fetch(TMergedColumn& column) {\n     Y_ABORT_UNLESS(RecordIndexStart);\n-    if (CurrentChunk && CurrentChunk->GetStartPosition() <= *RecordIndexStart && *RecordIndexStart < CurrentChunk->GetFinishPosition()) {\n-        \n+    if (!BlobChunks) {\n+        if (!DefaultArray || DefaultArray->length() < RecordIndexFinish - *RecordIndexStart) {\n+            DefaultArray = NArrow::TThreadSimpleArraysCache::Get(DataType, DefaultValue, RecordIndexFinish - *RecordIndexStart);\n+        }\n+        column.AppendSlice(DefaultArray, 0, RecordIndexFinish - *RecordIndexStart);\n     } else {\n-        CurrentChunk = BlobChunks->GetChunk(CurrentChunk, *RecordIndexStart);\n-    }\n-\n-    ui32 currentStart = *RecordIndexStart;\n-    while (RecordIndexFinish >= CurrentChunk->GetFinishPosition()) {\n-        column.AppendSlice(\n-            CurrentChunk->GetArray(), currentStart - CurrentChunk->GetStartPosition(), CurrentChunk->GetFinishPosition() - currentStart);\n-        currentStart = CurrentChunk->GetFinishPosition();\n-        if (currentStart < BlobChunks->GetRecordsCount()) {\n-            CurrentChunk = BlobChunks->GetChunk(CurrentChunk, currentStart);\n+        if (CurrentChunk && CurrentChunk->GetAddress().Contains(*RecordIndexStart)) {\n         } else {\n-            CurrentChunk.reset();\n-            break;\n+            CurrentChunk = BlobChunks->GetChunk(CurrentChunk, *RecordIndexStart);\n         }\n-    }\n \n-    if (currentStart < RecordIndexFinish) {\n-        AFL_VERIFY(CurrentChunk);\n-        Y_ABORT_UNLESS(RecordIndexFinish < CurrentChunk->GetFinishPosition());\n-        column.AppendSlice(CurrentChunk->GetArray(), currentStart - CurrentChunk->GetStartPosition(), RecordIndexFinish - currentStart);\n-    }\n+        ui32 currentStart = *RecordIndexStart;\n+        while (CurrentChunk->GetAddress().GetGlobalFinishPosition() <= RecordIndexFinish) {\n+            column.AppendSlice(CurrentChunk->GetArray(), CurrentChunk->GetAddress().GetLocalIndex(currentStart),\n+                CurrentChunk->GetAddress().GetGlobalFinishPosition() - currentStart);\n+            currentStart = CurrentChunk->GetAddress().GetGlobalFinishPosition();\n+            if (currentStart < BlobChunks->GetRecordsCount()) {\n+                CurrentChunk = BlobChunks->GetChunk(CurrentChunk, currentStart);\n+            } else {\n+                CurrentChunk.reset();\n+                break;\n+            }\n+        }\n \n+        if (currentStart < RecordIndexFinish) {\n+            AFL_VERIFY(CurrentChunk);\n+            Y_ABORT_UNLESS(RecordIndexFinish < CurrentChunk->GetAddress().GetGlobalFinishPosition());\n+            column.AppendSlice(\n+                CurrentChunk->GetArray(), CurrentChunk->GetAddress().GetLocalIndex(currentStart), RecordIndexFinish - currentStart);\n+        }\n+    }\n     RecordIndexStart.reset();\n     RecordIndexFinish = 0;\n+\n     return true;\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.h b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.h\nindex 0e54ade2b372..4180444c9487 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_cursor.h\n@@ -1,18 +1,24 @@\n #pragma once\n #include \"merged_column.h\"\n-#include <ydb/core/tx/columnshard/splitter/chunks.h>\n+\n #include <ydb/core/tx/columnshard/engines/portions/column_record.h>\n #include <ydb/core/tx/columnshard/engines/scheme/column_features.h>\n+#include <ydb/core/tx/columnshard/splitter/chunks.h>\n+\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n \n namespace NKikimr::NOlap::NCompaction {\n \n class TPortionColumnCursor {\n private:\n-    std::optional<NArrow::NAccessor::IChunkedArray::TCurrentChunkAddress> CurrentChunk;\n+    std::optional<NArrow::NAccessor::IChunkedArray::TFullDataAddress> CurrentChunk;\n     std::shared_ptr<NArrow::NAccessor::IChunkedArray> BlobChunks;\n+    std::shared_ptr<arrow::Array> DefaultArray;\n     std::optional<ui32> RecordIndexStart;\n+    std::shared_ptr<arrow::DataType> DataType;\n+    std::shared_ptr<arrow::Scalar> DefaultValue;\n     YDB_READONLY(ui32, RecordIndexFinish, 0);\n+\n public:\n     ~TPortionColumnCursor() {\n         AFL_VERIFY(!RecordIndexStart)(\"start\", RecordIndexStart)(\"finish\", RecordIndexFinish);\n@@ -24,7 +30,14 @@ class TPortionColumnCursor {\n \n     TPortionColumnCursor(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& columnChunks)\n         : BlobChunks(columnChunks) {\n+        AFL_VERIFY(BlobChunks);\n+    }\n+\n+    TPortionColumnCursor(const std::shared_ptr<arrow::DataType>& dataType, const std::shared_ptr<arrow::Scalar>& defaultValue)\n+        : DataType(dataType)\n+        , DefaultValue(defaultValue) {\n+        AFL_VERIFY(DataType);\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.cpp\nindex 1cd921676f01..3db4127653b8 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.cpp\n@@ -1,52 +1,27 @@\n #include \"column_portion_chunk.h\"\n-#include <ydb/core/formats/arrow/common/validation.h>\n-#include <ydb/core/tx/columnshard/splitter/simple.h>\n+\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <ydb/core/tx/columnshard/engines/changes/counters/general.h>\n #include <ydb/core/tx/columnshard/engines/storage/chunks/column.h>\n \n namespace NKikimr::NOlap::NCompaction {\n \n-std::shared_ptr<arrow::Array> TColumnPortion::AppendBlob(const TString& data, const TColumnRecord& columnChunk, ui32& remained) {\n-//    if (CurrentPortionRecords + columnChunk.GetMeta().GetNumRows() <= Context.GetPortionRowsCountLimit() &&\n-//        columnChunk.GetMeta().GetRawBytes() < Context.GetChunkRawBytesLimit() &&\n-//        data.size() < Context.GetChunkPackedBytesLimit() &&\n-//        columnChunk.GetMeta().GetRawBytes() > Context.GetStorePackedChunkSizeLimit() && Context.GetSaver().IsHardPacker() &&\n-//        Context.GetUseWholeChunksOptimization())\n-//    {\n-//        NChanges::TGeneralCompactionCounters::OnFullBlobAppend(columnChunk.BlobRange.GetBlobSize());\n-//        FlushBuffer();\n-//        Chunks.emplace_back(std::make_shared<TChunkPreparation>(data, columnChunk, Context.GetSchemaInfo()));\n-//        PackedSize += Chunks.back()->GetPackedSize();\n-//        CurrentPortionRecords += columnChunk.GetMeta().GetNumRows();\n-//        return nullptr;\n-//    } else {\n-        NChanges::TGeneralCompactionCounters::OnSplittedBlobAppend(columnChunk.BlobRange.GetSize());\n-        auto batch = NArrow::TStatusValidator::GetValid(Context.GetLoader()->Apply(data));\n-        AFL_VERIFY(batch->num_columns() == 1);\n-        auto batchArray = batch->column(0);\n-        remained = AppendSlice(batchArray, 0, batch->num_rows());\n-        if (remained) {\n-            return batchArray;\n-        } else {\n-            return nullptr;\n-        }\n-//    }\n-}\n-\n ui32 TColumnPortion::AppendSlice(const std::shared_ptr<arrow::Array>& a, const ui32 startIndex, const ui32 length) {\n     Y_ABORT_UNLESS(a);\n     Y_ABORT_UNLESS(length);\n-    Y_ABORT_UNLESS(CurrentPortionRecords < Context.GetPortionRowsCountLimit());\n+    Y_ABORT_UNLESS(CurrentPortionRecords < ChunkContext.GetPortionRowsCountLimit());\n     Y_ABORT_UNLESS(startIndex + length <= a->length());\n     AFL_VERIFY(Type->id() == a->type_id())(\"own\", Type->ToString())(\"a\", a->type()->ToString());\n     ui32 i = startIndex;\n     const ui32 packedRecordSize = Context.GetColumnStat() ? Context.GetColumnStat()->GetPackedRecordSize() : 0;\n     for (; i < startIndex + length; ++i) {\n         ui64 recordSize = 0;\n-        AFL_VERIFY(NArrow::Append(*Builder, *a, i, &recordSize))(\"a\", a->ToString())(\"a_type\", a->type()->ToString())(\"builder_type\", Builder->type()->ToString());\n+        AFL_VERIFY(NArrow::Append(*Builder, *a, i, &recordSize))(\"a\", a->ToString())(\"a_type\", a->type()->ToString())(\n+            \"builder_type\", Builder->type()->ToString());\n         CurrentChunkRawSize += recordSize;\n         PredictedPackedBytes += packedRecordSize ? packedRecordSize : (recordSize / 2);\n-        if (++CurrentPortionRecords == Context.GetPortionRowsCountLimit()) {\n+        if (++CurrentPortionRecords == ChunkContext.GetPortionRowsCountLimit()) {\n             FlushBuffer();\n             ++i;\n             break;\n@@ -59,17 +34,17 @@ ui32 TColumnPortion::AppendSlice(const std::shared_ptr<arrow::Array>& a, const u\n }\n \n bool TColumnPortion::FlushBuffer() {\n-    if (Builder->length()) {\n-        auto newArrayChunk = NArrow::TStatusValidator::GetValid(Builder->Finish());\n-        Chunks.emplace_back(std::make_shared<NChunks::TChunkPreparation>(Context.GetSaver().Apply(newArrayChunk, Context.GetResultField()), newArrayChunk, TChunkAddress(Context.GetColumnId(), 0), ColumnInfo));\n-        Builder = Context.MakeBuilder();\n-        CurrentChunkRawSize = 0;\n-        PredictedPackedBytes = 0;\n-        PackedSize += Chunks.back()->GetPackedSize();\n-        return true;\n-    } else {\n+    if (!Builder->length()) {\n         return false;\n     }\n+    auto newArrayChunk = NArrow::TStatusValidator::GetValid(Builder->Finish());\n+    Chunks.emplace_back(std::make_shared<NChunks::TChunkPreparation>(Context.GetSaver().Apply(newArrayChunk, Context.GetResultField()),\n+        std::make_shared<NArrow::NAccessor::TTrivialArray>(newArrayChunk), TChunkAddress(Context.GetColumnId(), 0), ColumnInfo));\n+    Builder = Context.MakeBuilder();\n+    CurrentChunkRawSize = 0;\n+    PredictedPackedBytes = 0;\n+    PackedSize += Chunks.back()->GetPackedSize();\n+    return true;\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.h b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.h\nindex 98fe703f7e1a..59c6a3b460da 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/column_portion_chunk.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n #include <ydb/core/tx/columnshard/counters/splitter.h>\n #include <ydb/core/tx/columnshard/engines/changes/compaction/common/context.h>\n #include <ydb/core/tx/columnshard/engines/changes/compaction/common/result.h>\n@@ -17,6 +17,7 @@ class TColumnPortion: public TColumnPortionResult {\n     std::unique_ptr<arrow::ArrayBuilder> Builder;\n     std::shared_ptr<arrow::DataType> Type;\n     const TColumnMergeContext& Context;\n+    const TChunkMergeContext& ChunkContext;\n     YDB_READONLY(ui64, CurrentChunkRawSize, 0);\n     double PredictedPackedBytes = 0;\n     const TSimpleColumnInfo ColumnInfo;\n@@ -24,22 +25,22 @@ class TColumnPortion: public TColumnPortionResult {\n     ui64 CurrentPortionRecords = 0;\n \n public:\n-    TColumnPortion(const TColumnMergeContext& context)\n+    TColumnPortion(const TColumnMergeContext& context, const TChunkMergeContext& chunkContext)\n         : TBase(context.GetColumnId())\n         , Context(context)\n+        , ChunkContext(chunkContext)\n         , ColumnInfo(Context.GetIndexInfo().GetColumnFeaturesVerified(context.GetColumnId())) {\n         Builder = Context.MakeBuilder();\n         Type = Builder->type();\n     }\n \n     bool IsFullPortion() const {\n-        Y_ABORT_UNLESS(CurrentPortionRecords <= Context.GetPortionRowsCountLimit());\n-        return CurrentPortionRecords == Context.GetPortionRowsCountLimit();\n+        Y_ABORT_UNLESS(CurrentPortionRecords <= ChunkContext.GetPortionRowsCountLimit());\n+        return CurrentPortionRecords == ChunkContext.GetPortionRowsCountLimit();\n     }\n \n     bool FlushBuffer();\n \n-    std::shared_ptr<arrow::Array> AppendBlob(const TString& data, const TColumnRecord& columnChunk, ui32& remained);\n     ui32 AppendSlice(const std::shared_ptr<arrow::Array>& a, const ui32 startIndex, const ui32 length);\n };\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.cpp\nindex ac8cb351c572..0081d33d01b5 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.cpp\n@@ -2,31 +2,37 @@\n \n namespace NKikimr::NOlap::NCompaction {\n \n-void TPlainMerger::DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input) {\n+void TPlainMerger::DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& /*mContext*/) {\n     for (auto&& p : input) {\n-        Cursors.emplace_back(NCompaction::TPortionColumnCursor(p));\n+        if (p) {\n+            Cursors.emplace_back(NCompaction::TPortionColumnCursor(p));\n+        } else {\n+            Cursors.emplace_back(\n+                NCompaction::TPortionColumnCursor(Context.GetLoader()->GetResultField()->type(), Context.GetLoader()->GetDefaultValue()));\n+        }\n+        \n     }\n }\n \n std::vector<NKikimr::NOlap::NCompaction::TColumnPortionResult> TPlainMerger::DoExecute(\n-    const NCompaction::TColumnMergeContext& context, const arrow::UInt16Array& pIdxArray, const arrow::UInt32Array& pRecordIdxArray) {\n-    NCompaction::TMergedColumn mColumn(context);\n-\n+    const TChunkMergeContext& chunkContext, TMergingContext& mContext) {\n+    NCompaction::TMergedColumn mColumn(Context, chunkContext);\n+    auto& chunkInfo = mContext.GetChunk(chunkContext.GetBatchIdx());\n     std::optional<ui16> predPortionIdx;\n-    for (ui32 idx = 0; idx < pIdxArray.length(); ++idx) {\n-        const ui16 portionIdx = pIdxArray.Value(idx);\n-        const ui32 portionRecordIdx = pRecordIdxArray.Value(idx);\n+    for (ui32 idx = 0; idx < chunkInfo.GetIdxArray().length(); ++idx) {\n+        const ui16 portionIdx = chunkInfo.GetIdxArray().Value(idx);\n+        const ui32 portionRecordIdx = chunkInfo.GetRecordIdxArray().Value(idx);\n         auto& cursor = Cursors[portionIdx];\n         cursor.Next(portionRecordIdx, mColumn);\n         if (predPortionIdx && portionIdx != *predPortionIdx) {\n             Cursors[*predPortionIdx].Fetch(mColumn);\n         }\n-        if (idx + 1 == pIdxArray.length()) {\n+        if (idx + 1 == chunkInfo.GetIdxArray().length()) {\n             cursor.Fetch(mColumn);\n         }\n         predPortionIdx = portionIdx;\n     }\n-    AFL_VERIFY(pIdxArray.length() == mColumn.GetRecordsCount());\n+    AFL_VERIFY(chunkInfo.GetIdxArray().length() == mColumn.GetRecordsCount());\n     return mColumn.BuildResult();\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.h b/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.h\nindex 995cd1c33a72..5b3c53f2eec9 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/logic.h\n@@ -1,19 +1,22 @@\n #pragma once\n #include \"column_cursor.h\"\n \n-#include <ydb/core/formats/arrow/common/accessor.h>\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n #include <ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.h>\n \n namespace NKikimr::NOlap::NCompaction {\n class TPlainMerger: public IColumnMerger {\n private:\n+    static inline auto Registrator = TFactory::TRegistrator<TPlainMerger>(NArrow::NAccessor::TGlobalConst::PlainDataAccessorName);\n+    using TBase = IColumnMerger;\n     std::vector<NCompaction::TPortionColumnCursor> Cursors;\n-    virtual void DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input) override;\n+    virtual void DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& mergeContext) override;\n \n-    virtual std::vector<TColumnPortionResult> DoExecute(const NCompaction::TColumnMergeContext& context, const arrow::UInt16Array& pIdxArray,\n-        const arrow::UInt32Array& pRecordIdxArray) override;\n+    virtual std::vector<TColumnPortionResult> DoExecute(const TChunkMergeContext& context, TMergingContext& mergeContext) override;\n \n public:\n+    using TBase::TBase;\n };\n \n }   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.cpp\nindex 5f638a30f155..84dd8608ffc4 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.cpp\n@@ -2,20 +2,6 @@\n \n namespace NKikimr::NOlap::NCompaction {\n \n-void TMergedColumn::AppendBlob(const TString& data, const TColumnRecord& columnChunk) {\n-    RecordsCount += columnChunk.GetMeta().GetNumRows();\n-    ui32 remained;\n-    std::shared_ptr<arrow::Array> dataArray = Portions.back().AppendBlob(data, columnChunk, remained);\n-    while (remained) {\n-        Y_ABORT_UNLESS(Portions.back().IsFullPortion());\n-        NewPortion();\n-        remained = Portions.back().AppendSlice(dataArray, dataArray->length() - remained, remained);\n-    }\n-    if (Portions.back().IsFullPortion()) {\n-        NewPortion();\n-    }\n-}\n-\n void TMergedColumn::AppendSlice(const std::shared_ptr<arrow::Array>& data, const ui32 startIndex, const ui32 length) {\n     RecordsCount += length;\n     Y_ABORT_UNLESS(data);\n@@ -44,7 +30,7 @@ void TMergedColumn::NewPortion() {\n     if (Portions.size()) {\n         Portions.back().FlushBuffer();\n     }\n-    Portions.emplace_back(TColumnPortion(Context));\n+    Portions.emplace_back(TColumnPortion(Context, ChunkContext));\n }\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.h b/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.h\nindex 9dee31b84215..2433bb8f4862 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.h\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/merged_column.h\n@@ -9,18 +9,20 @@ namespace NKikimr::NOlap::NCompaction {\n class TMergedColumn {\n private:\n     TColumnMergeContext Context;\n+    TChunkMergeContext ChunkContext;\n     YDB_READONLY_DEF(std::vector<TColumnPortion>, Portions);\n     YDB_READONLY(ui32, RecordsCount, 0);\n \n     void NewPortion();\n \n public:\n-    TMergedColumn(const TColumnMergeContext& context)\n-        : Context(context) {\n+    TMergedColumn(const TColumnMergeContext& context, const TChunkMergeContext& chunkContext)\n+        : Context(context)\n+        , ChunkContext(chunkContext)\n+    {\n         NewPortion();\n     }\n \n-    void AppendBlob(const TString& data, const TColumnRecord& columnChunk);\n     void AppendSlice(const std::shared_ptr<arrow::Array>& data, const ui32 startIndex, const ui32 length);\n \n     std::vector<TColumnPortionResult> BuildResult();\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/plain/ya.make b/ydb/core/tx/columnshard/engines/changes/compaction/plain/ya.make\nindex 64de6caea075..91991ea51097 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/plain/ya.make\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/plain/ya.make\n@@ -4,7 +4,7 @@ SRCS(\n     column_cursor.cpp\n     column_portion_chunk.cpp\n     merged_column.cpp\n-    logic.cpp\n+    GLOBAL logic.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/logic.cpp b/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/logic.cpp\nnew file mode 100644\nindex 000000000000..d2c4e14f0664\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/logic.cpp\n@@ -0,0 +1,171 @@\n+#include \"logic.h\"\n+\n+#include <ydb/core/formats/arrow/switch/switch_type.h>\n+#include <ydb/core/tx/columnshard/engines/storage/chunks/column.h>\n+\n+namespace NKikimr::NOlap::NCompaction {\n+\n+void TSparsedMerger::DoStart(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& mergingContext) {\n+    ui32 idx = 0;\n+    for (auto&& p : input) {\n+        if (p) {\n+            Cursors.emplace_back(p, Context);\n+            if (mergingContext.HasRemapInfo(idx)) {\n+                CursorPositions.emplace_back(TCursorPosition(&Cursors.back(), mergingContext.GetRemapPortionIndexToResultIndex(idx)));\n+                if (CursorPositions.back().IsFinished()) {\n+                    CursorPositions.pop_back();\n+                }\n+            }\n+        }\n+        ++idx;\n+    }\n+}\n+\n+std::vector<TColumnPortionResult> TSparsedMerger::DoExecute(const TChunkMergeContext& chunkContext, TMergingContext& /*mergeContext*/) {\n+    std::vector<TColumnPortionResult> result;\n+    std::shared_ptr<TWriter> writer = std::make_shared<TWriter>(Context);\n+    const auto addSkipsToWriter = [&](i64 delta) {\n+        if (!delta) {\n+            return;\n+        }\n+        AFL_VERIFY(delta >= 0);\n+        if (chunkContext.GetPortionRowsCountLimit() <= writer->GetCurrentSize() + delta) {\n+            const i64 diff = chunkContext.GetPortionRowsCountLimit() - writer->GetCurrentSize();\n+            writer->AddPositions(diff);\n+            result.emplace_back(writer->Flush());\n+            writer = std::make_shared<TWriter>(Context);\n+            delta -= diff;\n+        }\n+        while (chunkContext.GetPortionRowsCountLimit() <= delta) {\n+            writer->AddPositions(chunkContext.GetPortionRowsCountLimit());\n+            result.emplace_back(writer->Flush());\n+            writer = std::make_shared<TWriter>(Context);\n+            delta -= chunkContext.GetPortionRowsCountLimit();\n+        }\n+        if (delta) {\n+            writer->AddPositions(delta);\n+        }\n+    };\n+\n+    std::vector<TCursorPosition> heap;\n+    for (auto it = CursorPositions.begin(); it != CursorPositions.end();) {\n+        AFL_VERIFY(chunkContext.GetBatchIdx() <= it->GetCurrentGlobalChunkIdx());\n+        if (it->GetCurrentGlobalChunkIdx() == chunkContext.GetBatchIdx()) {\n+            heap.emplace_back(std::move(*it));\n+            it = CursorPositions.erase(it);\n+        } else {\n+            ++it;\n+        }\n+    }\n+    std::make_heap(heap.begin(), heap.end());\n+    ui32 nextGlobalPosition = 0;\n+    while (heap.size()) {\n+        std::pop_heap(heap.begin(), heap.end());\n+        while (heap.size() == 1 || (heap.size() > 1 && heap.front() < heap.back())) {\n+            {\n+                auto& address = heap.back().GetCurrentAddress();\n+                AFL_VERIFY(nextGlobalPosition <= (ui32)address.GetGlobalPosition());\n+                addSkipsToWriter(address.GetGlobalPosition() - nextGlobalPosition);\n+\n+                heap.back().AddIndexTo(*writer);\n+                if (chunkContext.GetPortionRowsCountLimit() == writer->GetCurrentSize()) {\n+                    result.emplace_back(writer->Flush());\n+                    writer = std::make_shared<TWriter>(Context);\n+                }\n+                nextGlobalPosition = address.GetGlobalPosition() + 1;\n+            }\n+            if (!heap.back().Next()) {\n+                heap.pop_back();\n+                break;\n+            } else if (heap.back().GetCurrentGlobalChunkIdx() != chunkContext.GetBatchIdx()) {\n+                CursorPositions.emplace_back(std::move(heap.back()));\n+                heap.pop_back();\n+                break;\n+            }\n+        }\n+        std::push_heap(heap.begin(), heap.end());\n+    }\n+    AFL_VERIFY(nextGlobalPosition <= chunkContext.GetRecordsCount());\n+    addSkipsToWriter(chunkContext.GetRecordsCount() - nextGlobalPosition);\n+    if (writer->HasData()) {\n+        result.emplace_back(writer->Flush());\n+    }\n+    return result;\n+}\n+\n+void TSparsedMerger::TWriter::AddRealData(const std::shared_ptr<arrow::Array>& arr, const ui32 index) {\n+    AFL_VERIFY(arr);\n+    AFL_VERIFY(NArrow::Append(*ValueBuilder, *arr, index));\n+    NArrow::TStatusValidator::Validate(IndexBuilderImpl->Append(CurrentRecordIdx));\n+    ++UsefulRecordsCount;\n+    ++CurrentRecordIdx;\n+}\n+\n+TColumnPortionResult TSparsedMerger::TWriter::Flush() {\n+    std::vector<std::shared_ptr<arrow::Field>> fields = { std::make_shared<arrow::Field>(\"index\", arrow::uint32()),\n+        std::make_shared<arrow::Field>(\"value\", DataType) };\n+    auto schema = std::make_shared<arrow::Schema>(fields);\n+    std::vector<std::shared_ptr<arrow::Array>> columns = { NArrow::TStatusValidator::GetValid(IndexBuilder->Finish()),\n+        NArrow::TStatusValidator::GetValid(ValueBuilder->Finish()) };\n+\n+    auto recordBatch = arrow::RecordBatch::Make(schema, UsefulRecordsCount, columns);\n+    NArrow::NAccessor::TSparsedArray::TBuilder builder(\n+        Context.GetIndexInfo().GetColumnFeaturesVerified(Context.GetColumnId()).GetDefaultValue().GetValue(), Context.GetResultField()->type());\n+    builder.AddChunk(CurrentRecordIdx, recordBatch);\n+    Chunks.emplace_back(std::make_shared<NChunks::TChunkPreparation>(Context.GetSaver().Apply(recordBatch), builder.Finish(),\n+        TChunkAddress(ColumnId, 0), Context.GetIndexInfo().GetColumnFeaturesVerified(ColumnId)));\n+    return *this;\n+}\n+\n+TSparsedMerger::TWriter::TWriter(const TColumnMergeContext& context)\n+    : TBase(context.GetColumnId())\n+    , DataType(context.GetResultField()->type())\n+    , Context(context) {\n+    IndexBuilder = NArrow::MakeBuilder(arrow::uint32());\n+    ValueBuilder = NArrow::MakeBuilder(DataType);\n+    IndexBuilderImpl = (arrow::UInt32Builder*)(IndexBuilder.get());\n+}\n+\n+bool TSparsedMerger::TPlainChunkCursor::AddIndexTo(const ui32 index, TWriter& writer) {\n+    AFL_VERIFY(ChunkStartPosition <= index);\n+    writer.AddRealData(ChunkAddress->GetArray(), index - ChunkStartPosition);\n+    return true;\n+}\n+\n+bool TSparsedMerger::TSparsedChunkCursor::AddIndexTo(const ui32 index, TWriter& writer) {\n+    AFL_VERIFY(ChunkStartGlobalPosition <= index);\n+    AFL_VERIFY(index == NextGlobalPosition)(\"index\", index)(\"next\", NextGlobalPosition);\n+    writer.AddRealData(Chunk->GetColValue(), NextLocalPosition);\n+    return true;\n+}\n+\n+bool TSparsedMerger::TCursor::AddIndexTo(const ui32 index, TWriter& writer) {\n+    if (FinishGlobalPosition <= index) {\n+        InitArrays(index);\n+    }\n+    if (SparsedCursor) {\n+        return SparsedCursor->AddIndexTo(index, writer);\n+    } else if (PlainCursor) {\n+        return PlainCursor->AddIndexTo(index, writer);\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void TSparsedMerger::TCursor::InitArrays(const ui32 position) {\n+    AFL_VERIFY(!CurrentOwnedArray || !CurrentOwnedArray->GetAddress().Contains(position));\n+    CurrentOwnedArray = Array->GetArray(CurrentOwnedArray, position, Array);\n+    if (CurrentOwnedArray->GetArray()->GetType() == NArrow::NAccessor::IChunkedArray::EType::SparsedArray) {\n+        auto sparsedArray = static_pointer_cast<NArrow::NAccessor::TSparsedArray>(CurrentOwnedArray->GetArray());\n+        SparsedCursor = std::make_shared<TSparsedChunkCursor>(sparsedArray, &*CurrentOwnedArray);\n+        PlainCursor = nullptr;\n+    } else {\n+        PlainCursor = make_shared<TPlainChunkCursor>(CurrentOwnedArray->GetArray(), &*CurrentOwnedArray);\n+        SparsedCursor = nullptr;\n+    }\n+    AFL_VERIFY(CurrentOwnedArray->GetAddress().GetGlobalStartPosition() <= position);\n+    FinishGlobalPosition = CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + CurrentOwnedArray->GetArray()->GetRecordsCount();\n+    AFL_VERIFY(position < FinishGlobalPosition);\n+}\n+\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/logic.h b/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/logic.h\nnew file mode 100644\nindex 000000000000..9fc64606a092\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/logic.h\n@@ -0,0 +1,286 @@\n+#pragma once\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n+#include <ydb/core/formats/arrow/accessor/sparsed/accessor.h>\n+#include <ydb/core/tx/columnshard/engines/changes/compaction/abstract/merger.h>\n+\n+namespace NKikimr::NOlap::NCompaction {\n+\n+class TSparsedMerger: public IColumnMerger {\n+private:\n+    static inline auto Registrator = TFactory::TRegistrator<TSparsedMerger>(NArrow::NAccessor::TGlobalConst::SparsedDataAccessorName);\n+\n+    using TBase = IColumnMerger;\n+    class TWriter: public TColumnPortionResult {\n+    private:\n+        using TBase = TColumnPortionResult;\n+        const std::shared_ptr<arrow::DataType> DataType;\n+        const TColumnMergeContext& Context;\n+        std::unique_ptr<arrow::ArrayBuilder> IndexBuilder;\n+        std::unique_ptr<arrow::ArrayBuilder> ValueBuilder;\n+        arrow::UInt32Builder* IndexBuilderImpl = nullptr;\n+        ui32 CurrentRecordIdx = 0;\n+        ui32 UsefulRecordsCount = 0;\n+\n+    public:\n+        TWriter(const TColumnMergeContext& context);\n+\n+        bool HasData() const {\n+            return CurrentRecordIdx;\n+        }\n+\n+        ui32 GetCurrentSize() const {\n+            return CurrentRecordIdx;\n+        }\n+\n+        bool HasUsefulData() const {\n+            return UsefulRecordsCount;\n+        }\n+\n+        ui32 AddPositions(const i32 delta) {\n+            AFL_VERIFY(delta > 0);\n+            CurrentRecordIdx += delta;\n+            return CurrentRecordIdx;\n+        }\n+\n+        void AddRealData(const std::shared_ptr<arrow::Array>& arr, const ui32 index);\n+\n+        TColumnPortionResult Flush();\n+    };\n+\n+    class TPlainChunkCursor {\n+    private:\n+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> CurrentChunkedArray;\n+        std::optional<NArrow::NAccessor::IChunkedArray::TFullDataAddress> ChunkAddress;\n+        const NArrow::NAccessor::IChunkedArray::TFullChunkedArrayAddress* CurrentOwnedArray;\n+        ui32 ChunkStartPosition = 0;\n+        ui32 ChunkFinishPosition = 0;\n+\n+        void InitArrays(const ui32 position) {\n+            AFL_VERIFY(!ChunkAddress || ChunkFinishPosition <= position);\n+            AFL_VERIFY(CurrentOwnedArray->GetAddress().GetGlobalStartPosition() <= position)(\"pos\", position)(\n+                \"global\", CurrentOwnedArray->GetAddress().GetGlobalStartPosition());\n+            ChunkAddress = CurrentChunkedArray->GetChunk(ChunkAddress, position - CurrentOwnedArray->GetAddress().GetGlobalStartPosition());\n+            AFL_VERIFY(ChunkAddress);\n+            ChunkStartPosition = CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + ChunkAddress->GetAddress().GetGlobalStartPosition();\n+            ChunkFinishPosition =\n+                CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + ChunkAddress->GetAddress().GetGlobalFinishPosition();\n+            AFL_VERIFY(position < ChunkFinishPosition)(\"finish\", ChunkFinishPosition)(\"pos\", position);\n+            AFL_VERIFY(ChunkStartPosition <= position)(\"start\", ChunkStartPosition)(\"pos\", position);\n+        }\n+\n+    public:\n+        TPlainChunkCursor(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& chunked,\n+            const NArrow::NAccessor::IChunkedArray::TFullChunkedArrayAddress* currentOwnedArray)\n+            : CurrentChunkedArray(chunked)\n+            , CurrentOwnedArray(currentOwnedArray) {\n+            AFL_VERIFY(CurrentChunkedArray);\n+            AFL_VERIFY(CurrentOwnedArray);\n+            InitArrays(CurrentOwnedArray->GetAddress().GetGlobalStartPosition());\n+        }\n+        bool AddIndexTo(const ui32 index, TWriter& writer);\n+        std::optional<ui32> MoveToSignificant(const ui32 currentGlobalPosition, const TColumnMergeContext& context) {\n+            AFL_VERIFY(ChunkStartPosition <= currentGlobalPosition)(\"start\", ChunkStartPosition)(\"pos\", currentGlobalPosition)(\n+                \"global_start\", CurrentOwnedArray->GetAddress().GetGlobalStartPosition());\n+            ui32 currentIndex = currentGlobalPosition;\n+            while (true) {\n+                if (CurrentOwnedArray->GetAddress().GetGlobalFinishPosition() <= currentIndex) {\n+                    return {};\n+                }\n+                if (ChunkFinishPosition <= currentIndex) {\n+                    InitArrays(currentIndex);\n+                    continue;\n+                }\n+                for (; currentIndex < ChunkFinishPosition; ++currentIndex) {\n+                    if (!NArrow::ColumnEqualsScalar(\n+                            ChunkAddress->GetArray(), currentIndex - ChunkStartPosition, context.GetLoader()->GetDefaultValue())) {\n+                        return currentIndex;\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    class TSparsedChunkCursor {\n+    private:\n+        std::shared_ptr<NArrow::NAccessor::TSparsedArray> CurrentSparsedArray;\n+        const NArrow::NAccessor::TSparsedArrayChunk* Chunk = nullptr;\n+        const NArrow::NAccessor::IChunkedArray::TFullChunkedArrayAddress* CurrentOwnedArray;\n+        ui32 ChunkStartGlobalPosition = 0;\n+        ui32 NextGlobalPosition = 0;\n+        ui32 NextLocalPosition = 0;\n+        ui32 FinishGlobalPosition = 0;\n+        void InitArrays(const ui32 position) {\n+            AFL_VERIFY(!Chunk || CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + Chunk->GetFinishPosition() <= position);\n+            Chunk = &CurrentSparsedArray->GetSparsedChunk(CurrentOwnedArray->GetAddress().GetLocalIndex(position));\n+            AFL_VERIFY(Chunk->GetRecordsCount());\n+            AFL_VERIFY(CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + Chunk->GetStartPosition() <= position && \n+                    position < CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + Chunk->GetFinishPosition())\n+            (\"pos\", position)(\"start\", Chunk->GetStartPosition())(\"finish\", Chunk->GetFinishPosition())(\n+                \"shift\", CurrentOwnedArray->GetAddress().GetGlobalStartPosition());\n+            ChunkStartGlobalPosition = CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + Chunk->GetStartPosition();\n+            NextGlobalPosition = CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + Chunk->GetFirstIndexNotDefault();\n+            NextLocalPosition = 0;\n+            FinishGlobalPosition = CurrentOwnedArray->GetAddress().GetGlobalStartPosition() + Chunk->GetFinishPosition();\n+        }\n+\n+    public:\n+        std::optional<ui32> MoveToSignificant(const ui32 currentGlobalPosition, const TColumnMergeContext& /*context*/) {\n+            while (true) {\n+                if (NextGlobalPosition == CurrentOwnedArray->GetAddress().GetGlobalFinishPosition()) {\n+                    return {};\n+                }\n+                if (NextGlobalPosition == FinishGlobalPosition) {\n+                    InitArrays(NextGlobalPosition);\n+                    continue;\n+                }\n+                if (currentGlobalPosition == NextGlobalPosition) {\n+                    return NextGlobalPosition;\n+                }\n+                for (; NextLocalPosition < Chunk->GetNotDefaultRecordsCount(); ++NextLocalPosition) {\n+                    NextGlobalPosition = ChunkStartGlobalPosition + Chunk->GetIndexUnsafeFast(NextLocalPosition);\n+                    if (currentGlobalPosition <= NextGlobalPosition) {\n+                        return NextGlobalPosition;\n+                    }\n+                }\n+                NextGlobalPosition = FinishGlobalPosition;\n+            }\n+        }\n+        bool AddIndexTo(const ui32 index, TWriter& writer);\n+        TSparsedChunkCursor(const std::shared_ptr<NArrow::NAccessor::TSparsedArray>& sparsed,\n+            const NArrow::NAccessor::IChunkedArray::TFullChunkedArrayAddress* currentOwnedArray)\n+            : CurrentSparsedArray(sparsed)\n+            , CurrentOwnedArray(currentOwnedArray) {\n+            AFL_VERIFY(sparsed);\n+            AFL_VERIFY(currentOwnedArray);\n+            InitArrays(CurrentOwnedArray->GetAddress().GetGlobalStartPosition());\n+        }\n+    };\n+\n+    class TCursor {\n+    private:\n+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> Array;\n+        std::optional<NArrow::NAccessor::IChunkedArray::TFullChunkedArrayAddress> CurrentOwnedArray;\n+        std::shared_ptr<TSparsedChunkCursor> SparsedCursor;\n+        std::shared_ptr<TPlainChunkCursor> PlainCursor;\n+        ui32 FinishGlobalPosition = 0;\n+        const TColumnMergeContext& Context;\n+        void InitArrays(const ui32 position);\n+\n+    public:\n+        TCursor(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& array, const TColumnMergeContext& context)\n+            : Array(array)\n+            , Context(context) {\n+            AFL_VERIFY(Array);\n+            AFL_VERIFY(Array->GetRecordsCount());\n+            InitArrays(0);\n+        }\n+\n+        ui32 GetRecordsCount() const {\n+            return Array->GetRecordsCount();\n+        }\n+\n+        ui32 MoveToSignificant(const ui32 start) {\n+            ui32 currentPosition = start;\n+            while (true) {\n+                std::optional<ui32> significantIndex;\n+                if (SparsedCursor) {\n+                    significantIndex = SparsedCursor->MoveToSignificant(currentPosition, Context);\n+                } else if (PlainCursor) {\n+                    significantIndex = PlainCursor->MoveToSignificant(currentPosition, Context);\n+                }\n+                if (significantIndex) {\n+                    return *significantIndex;\n+                }\n+                if (FinishGlobalPosition == Array->GetRecordsCount()) {\n+                    return FinishGlobalPosition;\n+                } else {\n+                    currentPosition = FinishGlobalPosition;\n+                    InitArrays(FinishGlobalPosition);\n+                }\n+            }\n+        }\n+\n+        bool AddIndexTo(const ui32 index, TWriter& writer);\n+    };\n+\n+    class TCursorPosition: TMoveOnly {\n+    private:\n+        TCursor* Cursor;\n+        ui32 CurrentIndex = 0;\n+        const std::vector<TMergingContext::TAddress>* GlobalSequence = nullptr;\n+        TMergingContext::TAddress CurrentAddress;\n+\n+        bool InitPosition(const ui32 start) {\n+            CurrentIndex = start;\n+            while (true) {\n+                CurrentIndex = Cursor->MoveToSignificant(CurrentIndex);\n+                if (CurrentIndex == GlobalSequence->size()) {\n+                    return false;\n+                }\n+                auto& addr = (*GlobalSequence)[CurrentIndex];\n+                if (addr.GetGlobalPosition() != -1) {\n+                    CurrentAddress = addr;\n+                    return true;\n+                }\n+                if (++CurrentIndex == GlobalSequence->size()) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+    public:\n+        TCursor* operator->() {\n+            return Cursor;\n+        }\n+\n+        void AddIndexTo(TWriter& writer) const {\n+            AFL_VERIFY(Cursor->AddIndexTo(CurrentIndex, writer));\n+        }\n+\n+        TCursorPosition(TCursor* cursor, const std::vector<TMergingContext::TAddress>& globalSequence)\n+            : Cursor(cursor)\n+            , GlobalSequence(&globalSequence) {\n+            AFL_VERIFY(GlobalSequence->size() == cursor->GetRecordsCount());\n+            InitPosition(0);\n+        }\n+\n+        bool IsFinished() const {\n+            AFL_VERIFY(CurrentIndex <= GlobalSequence->size());\n+            return CurrentIndex == GlobalSequence->size();\n+        }\n+\n+        ui32 GetCurrentGlobalPosition() const {\n+            return CurrentAddress.GetGlobalPosition();\n+        }\n+\n+        ui32 GetCurrentGlobalChunkIdx() const {\n+            return CurrentAddress.GetChunkIdx();\n+        }\n+\n+        const TMergingContext::TAddress& GetCurrentAddress() const {\n+            return CurrentAddress;\n+        }\n+\n+        bool operator<(const TCursorPosition& item) const {\n+            return item.GetCurrentAddress() < GetCurrentAddress();\n+        }\n+\n+        [[nodiscard]] bool Next() {\n+            return InitPosition(++CurrentIndex);\n+        }\n+    };\n+\n+    std::deque<TCursor> Cursors;\n+    std::list<TCursorPosition> CursorPositions;\n+\n+    virtual void DoStart(\n+        const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& input, TMergingContext& mergeContext) override;\n+\n+    virtual std::vector<TColumnPortionResult> DoExecute(const TChunkMergeContext& context, TMergingContext& mergeContext) override;\n+\n+public:\n+    using TBase::TBase;\n+};\n+\n+}   // namespace NKikimr::NOlap::NCompaction\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/ya.make b/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/ya.make\nnew file mode 100644\nindex 000000000000..e24e8341aa7d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/sparsed/ya.make\n@@ -0,0 +1,11 @@\n+LIBRARY()\n+\n+SRCS(\n+    GLOBAL logic.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/tx/columnshard/engines/changes/compaction/common\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/ya.make b/ydb/core/tx/columnshard/engines/changes/compaction/ya.make\nindex c6a7bc101f9a..5e76aa0d8971 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/ya.make\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/ya.make\n@@ -7,8 +7,9 @@ SRCS(\n PEERDIR(\n     ydb/core/tx/tiering\n     ydb/core/tx/columnshard/engines/changes/compaction/abstract\n-    ydb/core/tx/columnshard/engines/changes/compaction/plain\n     ydb/core/tx/columnshard/engines/changes/compaction/common\n+    ydb/core/tx/columnshard/engines/changes/compaction/plain\n+    ydb/core/tx/columnshard/engines/changes/compaction/sparsed\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/engines/changes/general_compaction.cpp b/ydb/core/tx/columnshard/engines/changes/general_compaction.cpp\nindex a3db1b8f3eb2..ea7b6ddc2eb4 100644\n--- a/ydb/core/tx/columnshard/engines/changes/general_compaction.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/general_compaction.cpp\n@@ -81,7 +81,7 @@ void TGeneralCompactColumnEngineChanges::BuildAppendedPortionsByChunks(\n     auto resultSchema = context.SchemaVersions.GetLastSchema();\n     auto shardingActual = context.SchemaVersions.GetShardingInfoActual(GranuleMeta->GetPathId());\n \n-    std::shared_ptr<TSerializationStats> stats = std::make_shared<TSerializationStats>();\n+    std::shared_ptr<NArrow::NSplitter::TSerializationStats> stats = std::make_shared<NArrow::NSplitter::TSerializationStats>();\n     std::shared_ptr<TFilteredSnapshotSchema> resultFiltered;\n     NCompaction::TMerger merger(context, SaverContext);\n     {\n@@ -115,12 +115,11 @@ void TGeneralCompactColumnEngineChanges::BuildAppendedPortionsByChunks(\n                 pkColumnIds.emplace((ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG);\n             }\n         }\n-\n         resultFiltered = std::make_shared<TFilteredSnapshotSchema>(resultSchema, dataColumnIds);\n         {\n             auto seqDataColumnIds = dataColumnIds;\n             for (auto&& i : pkColumnIds) {\n-                AFL_VERIFY(seqDataColumnIds.erase(i));\n+                AFL_VERIFY(seqDataColumnIds.erase(i))(\"id\", i);\n             }\n             THashSet<ui64> usedPortionIds;\n             for (auto&& i : portions) {\n@@ -196,17 +195,15 @@ TConclusionStatus TGeneralCompactColumnEngineChanges::DoConstructBlobs(TConstruc\n void TGeneralCompactColumnEngineChanges::DoWriteIndexOnComplete(NColumnShard::TColumnShard* self, TWriteIndexCompleteContext& context) {\n     TBase::DoWriteIndexOnComplete(self, context);\n     if (self) {\n-        self->IncCounter(\n-            context.FinishedSuccessfully ? NColumnShard::COUNTER_SPLIT_COMPACTION_SUCCESS : NColumnShard::COUNTER_SPLIT_COMPACTION_FAIL);\n-        self->IncCounter(NColumnShard::COUNTER_SPLIT_COMPACTION_BLOBS_WRITTEN, context.BlobsWritten);\n-        self->IncCounter(NColumnShard::COUNTER_SPLIT_COMPACTION_BYTES_WRITTEN, context.BytesWritten);\n+        self->Counters.GetTabletCounters()->OnCompactionWriteIndexCompleted(\n+            context.FinishedSuccessfully, context.BlobsWritten, context.BytesWritten);\n     }\n }\n \n void TGeneralCompactColumnEngineChanges::DoStart(NColumnShard::TColumnShard& self) {\n     TBase::DoStart(self);\n     auto& g = *GranuleMeta;\n-    self.CSCounters.OnSplitCompactionInfo(\n+    self.Counters.GetCSCounters().OnSplitCompactionInfo(\n         g.GetAdditiveSummary().GetCompacted().GetTotalPortionsSize(), g.GetAdditiveSummary().GetCompacted().GetPortionsCount());\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/indexation.cpp b/ydb/core/tx/columnshard/engines/changes/indexation.cpp\nindex bca7277947ca..22ca7fd2c738 100644\n--- a/ydb/core/tx/columnshard/engines/changes/indexation.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/indexation.cpp\n@@ -1,6 +1,7 @@\n #include \"indexation.h\"\n \n #include \"compaction/merger.h\"\n+\n #include <ydb/core/tx/columnshard/columnshard_impl.h>\n \n namespace NKikimr::NOlap {\n@@ -35,9 +36,7 @@ void TInsertColumnEngineChanges::DoWriteIndexOnComplete(NColumnShard::TColumnSha\n         if (!DataToIndex.empty()) {\n             self->UpdateInsertTableCounters();\n         }\n-        self->IncCounter(NColumnShard::COUNTER_INDEXING_BLOBS_WRITTEN, context.BlobsWritten);\n-        self->IncCounter(NColumnShard::COUNTER_INDEXING_BYTES_WRITTEN, context.BytesWritten);\n-        self->IncCounter(NColumnShard::COUNTER_INDEXING_TIME, context.Duration.MilliSeconds());\n+        self->Counters.GetTabletCounters()->OnInsertionWriteIndexCompleted(context.BlobsWritten, context.BytesWritten, context.Duration);\n     }\n }\n \n@@ -50,17 +49,69 @@ namespace {\n class TBatchInfo {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TGeneralContainer>, Batch);\n-    const NEvWrite::EModificationType ModificationType;\n+\n+public:\n+    TBatchInfo(const std::shared_ptr<NArrow::TGeneralContainer>& batch, const NEvWrite::EModificationType /*modificationType*/)\n+        : Batch(batch) {\n+    }\n+};\n+\n+class TPathFieldsInfo {\n+private:\n+    std::set<ui32> UsageColumnIds;\n+    const ISnapshotSchema::TPtr ResultSchema;\n+    THashMap<ui64, ISnapshotSchema::TPtr> Schemas;\n+    bool Finished = false;\n+    const ui32 FullColumnsCount;\n+\n public:\n-    TBatchInfo(const std::shared_ptr<NArrow::TGeneralContainer>& batch, const NEvWrite::EModificationType modificationType)\n-        : Batch(batch)\n-        , ModificationType(modificationType)\n+    TPathFieldsInfo(const ISnapshotSchema::TPtr& resultSchema)\n+        : UsageColumnIds(IIndexInfo::GetNecessarySystemColumnIdsSet())\n+        , ResultSchema(resultSchema)\n+        , FullColumnsCount(ResultSchema->GetIndexInfo().GetColumnIds(true).size())\n     {\n+        AFL_VERIFY(FullColumnsCount);\n+    }\n+\n+    bool IsFinished() const {\n+        return Finished;\n+    }\n \n+    bool HasDeletion() const {\n+        AFL_VERIFY(Finished);\n+        return UsageColumnIds.contains((ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG);\n+    }\n+\n+    void Finish() {\n+        AFL_VERIFY(UsageColumnIds.size());\n+        AFL_VERIFY(!Finished);\n+        Finished = true;\n+        if (UsageColumnIds.size() == FullColumnsCount) {\n+            return;\n+        }\n+        auto defaultDiffs = ISnapshotSchema::GetColumnsWithDifferentDefaults(Schemas, ResultSchema);\n+        UsageColumnIds.insert(defaultDiffs.begin(), defaultDiffs.end());\n     }\n \n-    bool GetIsDeletion() const {\n-        return ModificationType == NEvWrite::EModificationType::Delete;\n+    const std::set<ui32>& GetUsageColumnIds() const {\n+        AFL_VERIFY(Finished);\n+        return UsageColumnIds;\n+    }\n+\n+    void AddChunkInfo(const TCommittedData& data, const TConstructionContext& context) {\n+        AFL_VERIFY(!Finished);\n+        if (UsageColumnIds.size() == FullColumnsCount) {\n+            return;\n+        }\n+        auto blobSchema = context.SchemaVersions.GetSchemaVerified(data.GetSchemaVersion());\n+        if (!Schemas.contains(data.GetSchemaVersion())) {\n+            Schemas.emplace(data.GetSchemaVersion(), blobSchema);\n+        }\n+        std::vector<ui32> filteredIds = data.GetMeta().GetSchemaSubset().Apply(blobSchema->GetIndexInfo().GetColumnIds(false));\n+        if (data.GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete) {\n+            filteredIds.emplace_back((ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG);\n+        }\n+        UsageColumnIds.insert(filteredIds.begin(), filteredIds.end());\n     }\n };\n \n@@ -68,12 +119,20 @@ class TPathData {\n private:\n     std::vector<TBatchInfo> Batches;\n     YDB_READONLY_DEF(std::optional<TGranuleShardingInfo>, ShardingInfo);\n-    bool HasDeletionFlag = false;\n+    TPathFieldsInfo ColumnsInfo;\n+\n public:\n-    TPathData(const std::optional<TGranuleShardingInfo>& shardingInfo)\n+    TPathData(const std::optional<TGranuleShardingInfo>& shardingInfo, const ISnapshotSchema::TPtr& resultSchema)\n         : ShardingInfo(shardingInfo)\n-    {\n-    \n+        , ColumnsInfo(resultSchema) {\n+    }\n+\n+    const TPathFieldsInfo& GetColumnsInfo() const {\n+        return ColumnsInfo;\n+    }\n+\n+    void FinishChunksInfo() {\n+        ColumnsInfo.Finish();\n     }\n \n     std::vector<std::shared_ptr<NArrow::TGeneralContainer>> GetGeneralContainers() const {\n@@ -84,14 +143,16 @@ class TPathData {\n         return result;\n     }\n \n+    void AddChunkInfo(const NOlap::TCommittedData& data, const TConstructionContext& context) {\n+        ColumnsInfo.AddChunkInfo(data, context);\n+    }\n+\n     bool HasDeletion() {\n-        return HasDeletionFlag;\n+        return ColumnsInfo.HasDeletion();\n     }\n \n-    void AddBatch(const NOlap::TInsertedData& data, const std::shared_ptr<NArrow::TGeneralContainer>& batch) {\n-        if (data.GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete) {\n-            HasDeletionFlag = true;\n-        }\n+    void AddBatch(const NOlap::TCommittedData& data, const std::shared_ptr<NArrow::TGeneralContainer>& batch) {\n+        AFL_VERIFY(ColumnsInfo.IsFinished());\n         AFL_VERIFY(batch);\n         Batches.emplace_back(batch, data.GetMeta().GetModificationType());\n     }\n@@ -108,23 +169,47 @@ class TPathData {\n class TPathesData {\n private:\n     THashMap<ui64, TPathData> Data;\n+    const ISnapshotSchema::TPtr ResultSchema;\n \n public:\n+    TPathesData(const ISnapshotSchema::TPtr& resultSchema)\n+        : ResultSchema(resultSchema) {\n+    }\n+\n+    void FinishChunksInfo() {\n+        for (auto&& i : Data) {\n+            i.second.FinishChunksInfo();\n+        }\n+    }\n+\n     const THashMap<ui64, TPathData>& GetData() const {\n         return Data;\n     }\n \n-    void Add(const NOlap::TInsertedData& inserted, const std::optional<TGranuleShardingInfo>& info,\n-        const std::shared_ptr<NArrow::TGeneralContainer>& batch) {\n-        auto it = Data.find(inserted.PathId);\n+    void AddChunkInfo(const NOlap::TCommittedData& inserted, const TConstructionContext& context) {\n+        auto shardingFilterCommit = context.SchemaVersions.GetShardingInfoOptional(inserted.GetPathId(), inserted.GetSnapshot());\n+        auto it = Data.find(inserted.GetPathId());\n         if (it == Data.end()) {\n-            it = Data.emplace(inserted.PathId, info).first;\n+            it = Data.emplace(inserted.GetPathId(), TPathData(shardingFilterCommit, ResultSchema)).first;\n         }\n-        it->second.AddShardingInfo(info);\n+        it->second.AddChunkInfo(inserted, context);\n+        it->second.AddShardingInfo(shardingFilterCommit);\n+    }\n+\n+    void AddBatch(const NOlap::TCommittedData& inserted, const std::shared_ptr<NArrow::TGeneralContainer>& batch) {\n+        auto it = Data.find(inserted.GetPathId());\n+        AFL_VERIFY(it != Data.end());\n         it->second.AddBatch(inserted, batch);\n     }\n+\n+    const TPathFieldsInfo& GetPathInfo(const ui64 pathId) const {\n+        auto it = Data.find(pathId);\n+        AFL_VERIFY(it != Data.end());\n+        return it->second.GetColumnsInfo();\n+    }\n };\n-}\n+\n+}   // namespace\n \n TConclusionStatus TInsertColumnEngineChanges::DoConstructBlobs(TConstructionContext& context) noexcept {\n     Y_ABORT_UNLESS(!DataToIndex.empty());\n@@ -133,34 +218,22 @@ TConclusionStatus TInsertColumnEngineChanges::DoConstructBlobs(TConstructionCont\n     auto resultSchema = context.SchemaVersions.GetLastSchema();\n     Y_ABORT_UNLESS(resultSchema->GetIndexInfo().IsSorted());\n \n-    TPathesData pathBatches;\n-    std::set<ui32> usageColumnIds;\n-    {\n-        THashMap<ui64, ISnapshotSchema::TPtr> schemas;\n-        for (auto& inserted : DataToIndex) {\n-            if (schemas.contains(inserted.GetSchemaVersion())) {\n-                continue;\n-            }\n-            schemas.emplace(inserted.GetSchemaVersion(), context.SchemaVersions.GetSchemaVerified(inserted.GetSchemaVersion()));\n-        }\n-        usageColumnIds = ISnapshotSchema::GetColumnsWithDifferentDefaults(schemas, resultSchema);\n-    }\n-\n+    TPathesData pathBatches(resultSchema);\n     for (auto& inserted : DataToIndex) {\n-        auto blobSchema = context.SchemaVersions.GetSchemaVerified(inserted.GetSchemaVersion());\n-        std::vector<ui32> filteredIds = inserted.GetMeta().GetSchemaSubset().Apply(blobSchema->GetIndexInfo().GetColumnIds(false));\n-        usageColumnIds.insert(filteredIds.begin(), filteredIds.end());\n-        if (inserted.GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete) {\n-            usageColumnIds.emplace((ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG);\n-        }\n-        if (usageColumnIds.size() == resultSchema->GetIndexInfo().GetColumnIds(true).size()) {\n-            break;\n+        if (inserted.GetRemove()) {\n+            continue;\n         }\n+        pathBatches.AddChunkInfo(inserted, context);\n     }\n \n+    pathBatches.FinishChunksInfo();\n+\n     for (auto& inserted : DataToIndex) {\n         const TBlobRange& blobRange = inserted.GetBlobRange();\n-        auto shardingFilterCommit = context.SchemaVersions.GetShardingInfoOptional(inserted.PathId, inserted.GetSnapshot());\n+        if (inserted.GetRemove()) {\n+            Blobs.Extract(IStoragesManager::DefaultStorageId, blobRange);\n+            continue;\n+        }\n         auto blobSchema = context.SchemaVersions.GetSchemaVerified(inserted.GetSchemaVersion());\n \n         std::shared_ptr<NArrow::TGeneralContainer> batch;\n@@ -169,23 +242,24 @@ TConclusionStatus TInsertColumnEngineChanges::DoConstructBlobs(TConstructionCont\n             auto batchSchema =\n                 std::make_shared<arrow::Schema>(inserted.GetMeta().GetSchemaSubset().Apply(blobSchema->GetIndexInfo().ArrowSchema()->fields()));\n             batch = std::make_shared<NArrow::TGeneralContainer>(NArrow::DeserializeBatch(blobData, batchSchema));\n+            blobSchema->AdaptBatchToSchema(*batch, resultSchema);\n         }\n-\n         IIndexInfo::AddSnapshotColumns(*batch, inserted.GetSnapshot());\n-        if (usageColumnIds.contains((ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG)) {\n+\n+        auto& pathInfo = pathBatches.GetPathInfo(inserted.GetPathId());\n+\n+        if (pathInfo.HasDeletion()) {\n             IIndexInfo::AddDeleteFlagsColumn(*batch, inserted.GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete);\n         }\n-        usageColumnIds.insert(IIndexInfo::GetSnapshotColumnIds().begin(), IIndexInfo::GetSnapshotColumnIds().end());\n \n-        batch = resultSchema->NormalizeBatch(*blobSchema, batch, usageColumnIds).DetachResult();\n-        pathBatches.Add(inserted, shardingFilterCommit, batch);\n+        pathBatches.AddBatch(inserted, batch);\n     }\n \n     Y_ABORT_UNLESS(Blobs.IsEmpty());\n-    auto filteredSnapshot = std::make_shared<TFilteredSnapshotSchema>(resultSchema, usageColumnIds);\n-    auto stats = std::make_shared<TSerializationStats>();\n+    auto stats = std::make_shared<NArrow::NSplitter::TSerializationStats>();\n     std::vector<std::shared_ptr<NArrow::TColumnFilter>> filters;\n     for (auto& [pathId, pathInfo] : pathBatches.GetData()) {\n+        auto filteredSnapshot = std::make_shared<TFilteredSnapshotSchema>(resultSchema, pathInfo.GetColumnsInfo().GetUsageColumnIds());\n         std::optional<ui64> shardingVersion;\n         if (pathInfo.GetShardingInfo()) {\n             shardingVersion = pathInfo.GetShardingInfo()->GetSnapshotVersion();\n@@ -194,7 +268,7 @@ TConclusionStatus TInsertColumnEngineChanges::DoConstructBlobs(TConstructionCont\n         filters.resize(batches.size());\n \n         auto itGranule = PathToGranule.find(pathId);\n-        AFL_VERIFY(itGranule != PathToGranule.end());\n+        AFL_VERIFY(itGranule != PathToGranule.end())(\"path_id\", pathId);\n         NCompaction::TMerger merger(context, SaverContext, std::move(batches), std::move(filters));\n         merger.SetOptimizationWritingPackMode(true);\n         auto localAppended = merger.Execute(stats, itGranule->second, filteredSnapshot, pathId, shardingVersion);\n@@ -212,4 +286,4 @@ NColumnShard::ECumulativeCounters TInsertColumnEngineChanges::GetCounterIndex(co\n     return isSuccess ? NColumnShard::COUNTER_INDEXING_SUCCESS : NColumnShard::COUNTER_INDEXING_FAIL;\n }\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/changes/indexation.h b/ydb/core/tx/columnshard/engines/changes/indexation.h\nindex d130612b7451..4c7f8602a6f5 100644\n--- a/ydb/core/tx/columnshard/engines/changes/indexation.h\n+++ b/ydb/core/tx/columnshard/engines/changes/indexation.h\n@@ -1,16 +1,21 @@\n #pragma once\n-#include \"abstract/abstract.h\"\n #include \"with_appended.h\"\n-#include <ydb/core/tx/columnshard/engines/insert_table/data.h>\n-#include <util/generic/hash.h>\n+\n+#include \"abstract/abstract.h\"\n+\n #include <ydb/core/formats/arrow/reader/position.h>\n+#include <ydb/core/tx/columnshard/engines/insert_table/committed.h>\n+#include <ydb/core/tx/columnshard/engines/insert_table/inserted.h>\n+\n+#include <util/generic/hash.h>\n \n namespace NKikimr::NOlap {\n \n class TInsertColumnEngineChanges: public TChangesWithAppend {\n private:\n     using TBase = TChangesWithAppend;\n-    std::vector<NOlap::TInsertedData> DataToIndex;\n+    std::vector<TCommittedData> DataToIndex;\n+\n protected:\n     virtual void DoWriteIndexOnComplete(NColumnShard::TColumnShard* self, TWriteIndexCompleteContext& context) override;\n     virtual void DoWriteIndexOnExecute(NColumnShard::TColumnShard* self, TWriteIndexContext& context) override;\n@@ -34,13 +39,12 @@ class TInsertColumnEngineChanges: public TChangesWithAppend {\n public:\n     THashMap<ui64, NArrow::NMerger::TIntervalPositions> PathToGranule;   // pathId -> positions (sorted by pk)\n public:\n-    TInsertColumnEngineChanges(std::vector<NOlap::TInsertedData>&& dataToIndex, const TSaverContext& saverContext)\n+    TInsertColumnEngineChanges(std::vector<NOlap::TCommittedData>&& dataToIndex, const TSaverContext& saverContext)\n         : TBase(saverContext, NBlobOperations::EConsumer::INDEXATION)\n-        , DataToIndex(std::move(dataToIndex))\n-    {\n+        , DataToIndex(std::move(dataToIndex)) {\n     }\n \n-    const std::vector<NOlap::TInsertedData>& GetDataToIndex() const {\n+    const std::vector<NOlap::TCommittedData>& GetDataToIndex() const {\n         return DataToIndex;\n     }\n \n@@ -52,7 +56,6 @@ class TInsertColumnEngineChanges: public TChangesWithAppend {\n         return StaticTypeName();\n     }\n     std::optional<ui64> AddPathIfNotExists(ui64 pathId);\n-\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/changes/with_appended.cpp b/ydb/core/tx/columnshard/engines/changes/with_appended.cpp\nindex 5b3d988abfba..24d44eb34587 100644\n--- a/ydb/core/tx/columnshard/engines/changes/with_appended.cpp\n+++ b/ydb/core/tx/columnshard/engines/changes/with_appended.cpp\n@@ -19,7 +19,7 @@ void TChangesWithAppend::DoWriteIndexOnExecute(NColumnShard::TColumnShard* self,\n     }\n     const auto predRemoveDroppedTable = [self](const TWritePortionInfoWithBlobsResult& item) {\n         auto& portionInfo = item.GetPortionResult();\n-        if (!!self && (!self->TablesManager.HasTable(portionInfo.GetPathId()) || self->TablesManager.GetTable(portionInfo.GetPathId()).IsDropped())) {\n+        if (!!self && !self->TablesManager.HasTable(portionInfo.GetPathId(), false)) {\n             AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_inserted_data\")(\"reason\", \"table_removed\")(\"path_id\", portionInfo.GetPathId());\n             return true;\n         } else {\n@@ -42,13 +42,13 @@ void TChangesWithAppend::DoWriteIndexOnComplete(NColumnShard::TColumnShard* self\n                 case NOlap::TPortionMeta::EProduced::UNSPECIFIED:\n                     Y_ABORT_UNLESS(false);   // unexpected\n                 case NOlap::TPortionMeta::EProduced::INSERTED:\n-                    self->IncCounter(NColumnShard::COUNTER_INDEXING_PORTIONS_WRITTEN);\n+                    self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_INDEXING_PORTIONS_WRITTEN);\n                     break;\n                 case NOlap::TPortionMeta::EProduced::COMPACTED:\n-                    self->IncCounter(NColumnShard::COUNTER_COMPACTION_PORTIONS_WRITTEN);\n+                    self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_COMPACTION_PORTIONS_WRITTEN);\n                     break;\n                 case NOlap::TPortionMeta::EProduced::SPLIT_COMPACTED:\n-                    self->IncCounter(NColumnShard::COUNTER_SPLIT_COMPACTION_PORTIONS_WRITTEN);\n+                    self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_SPLIT_COMPACTION_PORTIONS_WRITTEN);\n                     break;\n                 case NOlap::TPortionMeta::EProduced::EVICTED:\n                     Y_ABORT(\"Unexpected evicted case\");\n@@ -58,19 +58,19 @@ void TChangesWithAppend::DoWriteIndexOnComplete(NColumnShard::TColumnShard* self\n                     break;\n             }\n         }\n-        self->IncCounter(NColumnShard::COUNTER_PORTIONS_DEACTIVATED, PortionsToRemove.size());\n+        self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_PORTIONS_DEACTIVATED, PortionsToRemove.size());\n \n         THashSet<TUnifiedBlobId> blobsDeactivated;\n         for (auto& [_, portionInfo] : PortionsToRemove) {\n             for (auto& rec : portionInfo.Records) {\n                 blobsDeactivated.emplace(portionInfo.GetBlobId(rec.BlobRange.GetBlobIdxVerified()));\n             }\n-            self->IncCounter(NColumnShard::COUNTER_RAW_BYTES_DEACTIVATED, portionInfo.GetTotalRawBytes());\n+            self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_RAW_BYTES_DEACTIVATED, portionInfo.GetTotalRawBytes());\n         }\n \n-        self->IncCounter(NColumnShard::COUNTER_BLOBS_DEACTIVATED, blobsDeactivated.size());\n+        self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_BLOBS_DEACTIVATED, blobsDeactivated.size());\n         for (auto& blobId : blobsDeactivated) {\n-            self->IncCounter(NColumnShard::COUNTER_BYTES_DEACTIVATED, blobId.BlobSize());\n+            self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_BYTES_DEACTIVATED, blobId.BlobSize());\n         }\n     }\n     {\ndiff --git a/ydb/core/tx/columnshard/engines/column_engine.h b/ydb/core/tx/columnshard/engines/column_engine.h\nindex 912223f8cf1b..2c616c06e32d 100644\n--- a/ydb/core/tx/columnshard/engines/column_engine.h\n+++ b/ydb/core/tx/columnshard/engines/column_engine.h\n@@ -46,10 +46,6 @@ struct TSelectInfo {\n \n     std::vector<std::shared_ptr<TPortionInfo>> PortionsOrderedPK;\n \n-    NColumnShard::TContainerAccessorWithDirection<std::vector<std::shared_ptr<TPortionInfo>>> GetPortionsOrdered(const bool reverse) const {\n-        return NColumnShard::TContainerAccessorWithDirection<std::vector<std::shared_ptr<TPortionInfo>>>(PortionsOrderedPK, reverse);\n-    }\n-\n     size_t NumChunks() const;\n \n     TStats Stats() const;\n@@ -284,7 +280,7 @@ class IColumnEngine {\n     }\n     virtual bool IsOverloadedByMetadata(const ui64 limit) const = 0;\n     virtual std::shared_ptr<TSelectInfo> Select(ui64 pathId, TSnapshot snapshot, const TPKRangesFilter& pkRangesFilter) const = 0;\n-    virtual std::shared_ptr<TInsertColumnEngineChanges> StartInsert(std::vector<TInsertedData>&& dataToIndex) noexcept = 0;\n+    virtual std::shared_ptr<TInsertColumnEngineChanges> StartInsert(std::vector<TCommittedData>&& dataToIndex) noexcept = 0;\n     virtual std::shared_ptr<TColumnEngineChanges> StartCompaction(const std::shared_ptr<NDataLocks::TManager>& dataLocksManager) noexcept = 0;\n     virtual std::shared_ptr<TCleanupPortionsColumnEngineChanges> StartCleanupPortions(const TSnapshot& snapshot, const THashSet<ui64>& pathsToDrop, const std::shared_ptr<NDataLocks::TManager>& dataLocksManager) noexcept = 0;\n     virtual std::shared_ptr<TCleanupTablesColumnEngineChanges> StartCleanupTables(const THashSet<ui64>& pathsToDrop) noexcept = 0;\ndiff --git a/ydb/core/tx/columnshard/engines/column_engine_logs.cpp b/ydb/core/tx/columnshard/engines/column_engine_logs.cpp\nindex e7fda23311ae..4218fc19cf5e 100644\n--- a/ydb/core/tx/columnshard/engines/column_engine_logs.cpp\n+++ b/ydb/core/tx/columnshard/engines/column_engine_logs.cpp\n@@ -157,10 +157,9 @@ void TColumnEngineForLogs::RegisterSchemaVersion(const TSnapshot& snapshot, TInd\n }\n \n void TColumnEngineForLogs::RegisterSchemaVersion(const TSnapshot& snapshot, const NKikimrSchemeOp::TColumnTableSchema& schema) {\n-    std::optional<NOlap::TIndexInfo> indexInfoOptional = NOlap::TIndexInfo::BuildFromProto(schema, StoragesManager);\n+    std::optional<NOlap::TIndexInfo> indexInfoOptional = NOlap::TIndexInfo::BuildFromProto(schema, StoragesManager, SchemaObjectsCache);\n     AFL_VERIFY(indexInfoOptional);\n     NOlap::TIndexInfo indexInfo = std::move(*indexInfoOptional);\n-    indexInfo.SetAllKeys(StoragesManager);\n     RegisterSchemaVersion(snapshot, std::move(indexInfo));\n }\n \n@@ -272,7 +271,7 @@ bool TColumnEngineForLogs::LoadCounters(IDbWrapper& db) {\n     return db.LoadCounters(callback);\n }\n \n-std::shared_ptr<TInsertColumnEngineChanges> TColumnEngineForLogs::StartInsert(std::vector<TInsertedData>&& dataToIndex) noexcept {\n+std::shared_ptr<TInsertColumnEngineChanges> TColumnEngineForLogs::StartInsert(std::vector<TCommittedData>&& dataToIndex) noexcept {\n     Y_ABORT_UNLESS(dataToIndex.size());\n \n     TSaverContext saverContext(StoragesManager);\n@@ -280,12 +279,15 @@ std::shared_ptr<TInsertColumnEngineChanges> TColumnEngineForLogs::StartInsert(st\n     auto pkSchema = VersionedIndex.GetLastSchema()->GetIndexInfo().GetReplaceKey();\n \n     for (const auto& data : changes->GetDataToIndex()) {\n-        const ui64 pathId = data.PathId;\n+        const ui64 pathId = data.GetPathId();\n \n         if (changes->PathToGranule.contains(pathId)) {\n             continue;\n         }\n-        AFL_VERIFY(changes->PathToGranule.emplace(pathId, GetGranulePtrVerified(pathId)->GetBucketPositions()).second);\n+        if (!data.GetRemove()) {\n+            AFL_VERIFY(changes->PathToGranule.emplace(pathId, GetGranulePtrVerified(pathId)->GetBucketPositions()).second);\n+        }\n+        \n     }\n \n     return changes;\n@@ -341,7 +343,6 @@ std::shared_ptr<TCleanupPortionsColumnEngineChanges> TColumnEngineForLogs::Start\n     ui32 skipLocked = 0;\n     ui32 portionsFromDrop = 0;\n     bool limitExceeded = false;\n-    THashSet<TPortionAddress> uniquePortions;\n     for (ui64 pathId : pathsToDrop) {\n         auto g = GranulesStorage->GetGranuleOptional(pathId);\n         if (!g) {\n@@ -349,6 +350,9 @@ std::shared_ptr<TCleanupPortionsColumnEngineChanges> TColumnEngineForLogs::Start\n         }\n \n         for (auto& [portion, info] : g->GetPortions()) {\n+            if (info->CheckForCleanup()) {\n+                continue;\n+            }\n             if (dataLocksManager->IsLocked(*info)) {\n                 ++skipLocked;\n                 continue;\n@@ -359,8 +363,6 @@ std::shared_ptr<TCleanupPortionsColumnEngineChanges> TColumnEngineForLogs::Start\n                 limitExceeded = true;\n                 break;\n             }\n-            const auto inserted = uniquePortions.emplace(info->GetAddress()).second;\n-            Y_ABORT_UNLESS(inserted);\n             changes->PortionsToDrop.push_back(*info);\n             ++portionsFromDrop;\n         }\n@@ -379,17 +381,14 @@ std::shared_ptr<TCleanupPortionsColumnEngineChanges> TColumnEngineForLogs::Start\n                 ++i;\n                 continue;\n             }\n-            const auto inserted = uniquePortions.emplace(it->second[i].GetAddress()).second;\n-            if (inserted) {\n-                Y_ABORT_UNLESS(it->second[i].CheckForCleanup(snapshot));\n-                if (txSize + it->second[i].GetTxVolume() < txSizeLimit || changes->PortionsToDrop.empty()) {\n-                    txSize += it->second[i].GetTxVolume();\n-                } else {\n-                    limitExceeded = true;\n-                    break;\n-                }\n-                changes->PortionsToDrop.push_back(std::move(it->second[i]));\n+            AFL_VERIFY(it->second[i].CheckForCleanup(snapshot))(\"p_snapshot\", it->second[i].GetRemoveSnapshotOptional())(\"snapshot\", snapshot);\n+            if (txSize + it->second[i].GetTxVolume() < txSizeLimit || changes->PortionsToDrop.empty()) {\n+                txSize += it->second[i].GetTxVolume();\n+            } else {\n+                limitExceeded = true;\n+                break;\n             }\n+            changes->PortionsToDrop.push_back(std::move(it->second[i]));\n             if (i + 1 < it->second.size()) {\n                 it->second[i] = std::move(it->second.back());\n             }\n@@ -421,7 +420,7 @@ std::vector<std::shared_ptr<TTTLColumnEngineChanges>> TColumnEngineForLogs::Star\n \n     TSaverContext saverContext(StoragesManager);\n     NActualizer::TTieringProcessContext context(memoryUsageLimit, saverContext, dataLocksManager, SignalCounters, ActualizationController);\n-    const TDuration actualizationLag = NYDBTest::TControllers::GetColumnShardController()->GetActualizationTasksLag(TDuration::Seconds(1));\n+    const TDuration actualizationLag = NYDBTest::TControllers::GetColumnShardController()->GetActualizationTasksLag();\n     for (auto&& i : pathEviction) {\n         auto g = GetGranuleOptional(i.first);\n         if (g) {\n@@ -486,9 +485,8 @@ void TColumnEngineForLogs::UpsertPortion(const TPortionInfo& portionInfo, const\n bool TColumnEngineForLogs::ErasePortion(const TPortionInfo& portionInfo, bool updateStats) {\n     Y_ABORT_UNLESS(!portionInfo.Empty());\n     const ui64 portion = portionInfo.GetPortion();\n-    auto spg = GetGranulePtrVerified(portionInfo.GetPathId());\n-    Y_ABORT_UNLESS(spg);\n-    auto p = spg->GetPortionOptional(portion);\n+    auto& spg = MutableGranuleVerified(portionInfo.GetPathId());\n+    auto p = spg.GetPortionOptional(portion);\n \n     if (!p) {\n         LOG_S_WARN(\"Portion erased already \" << portionInfo << \" at tablet \" << TabletId);\n@@ -497,7 +495,7 @@ bool TColumnEngineForLogs::ErasePortion(const TPortionInfo& portionInfo, bool up\n         if (updateStats) {\n             UpdatePortionStats(*p, EStatsUpdateType::ERASE);\n         }\n-        Y_ABORT_UNLESS(spg->ErasePortion(portion));\n+        Y_ABORT_UNLESS(spg.ErasePortion(portion));\n         return true;\n     }\n }\n@@ -510,20 +508,18 @@ std::shared_ptr<TSelectInfo> TColumnEngineForLogs::Select(ui64 pathId, TSnapshot\n         return out;\n     }\n \n-    for (const auto& [indexKey, keyPortions] : spg->GetPortionsIndex().GetPoints()) {\n-        for (auto&& [_, portionInfo] : keyPortions.GetStart()) {\n-            if (!portionInfo->IsVisible(snapshot)) {\n-                continue;\n-            }\n-            Y_ABORT_UNLESS(portionInfo->Produced());\n-            const bool skipPortion = !pkRangesFilter.IsPortionInUsage(*portionInfo, VersionedIndex.GetLastSchema()->GetIndexInfo());\n-            AFL_TRACE(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", skipPortion ? \"portion_skipped\" : \"portion_selected\")\n-                (\"pathId\", pathId)(\"portion\", portionInfo->DebugString());\n-            if (skipPortion) {\n-                continue;\n-            }\n-            out->PortionsOrderedPK.emplace_back(portionInfo);\n+    for (const auto& [_, portionInfo] : spg->GetPortions()) {\n+        if (!portionInfo->IsVisible(snapshot)) {\n+            continue;\n+        }\n+        Y_ABORT_UNLESS(portionInfo->Produced());\n+        const bool skipPortion = !pkRangesFilter.IsPortionInUsage(*portionInfo);\n+        AFL_TRACE(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", skipPortion ? \"portion_skipped\" : \"portion_selected\")(\"pathId\", pathId)(\n+            \"portion\", portionInfo->DebugString());\n+        if (skipPortion) {\n+            continue;\n         }\n+        out->PortionsOrderedPK.emplace_back(portionInfo);\n     }\n \n     return out;\n@@ -575,12 +571,4 @@ void TColumnEngineForLogs::DoRegisterTable(const ui64 pathId) {\n     }\n }\n \n-TDuration TColumnEngineForLogs::GetRemovedPortionLivetime() {\n-    TDuration result = TDuration::Minutes(10);\n-    if (HasAppData() && AppDataVerified().ColumnShardConfig.HasRemovedPortionLivetimeSeconds()) {\n-        result = TDuration::Seconds(AppDataVerified().ColumnShardConfig.GetRemovedPortionLivetimeSeconds());\n-    }\n-    return NYDBTest::TControllers::GetColumnShardController()->GetRemovedPortionLivetime(result);\n-}\n-\n } // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/column_engine_logs.h b/ydb/core/tx/columnshard/engines/column_engine_logs.h\nindex a48fb9cda9e0..7b515c26f40c 100644\n--- a/ydb/core/tx/columnshard/engines/column_engine_logs.h\n+++ b/ydb/core/tx/columnshard/engines/column_engine_logs.h\n@@ -53,10 +53,7 @@ class TColumnEngineForLogs : public IColumnEngine {\n     std::shared_ptr<IStoragesManager> StoragesManager;\n \n     std::shared_ptr<NActualizer::TController> ActualizationController;\n-\n-    static TDuration GetRemovedPortionLivetime();\n-\n-    const TDuration RemovedPortionLivetime = GetRemovedPortionLivetime();\n+    std::shared_ptr<TSchemaObjectsCache> SchemaObjectsCache = std::make_shared<TSchemaObjectsCache>();\n \n public:\n     const std::shared_ptr<NActualizer::TController>& GetActualizationController() const {\n@@ -112,7 +109,7 @@ class TColumnEngineForLogs : public IColumnEngine {\n         return limit < TGranulesStat::GetSumMetadataMemoryPortionsSize();\n     }\n \n-    std::shared_ptr<TInsertColumnEngineChanges> StartInsert(std::vector<TInsertedData>&& dataToIndex) noexcept override;\n+    std::shared_ptr<TInsertColumnEngineChanges> StartInsert(std::vector<TCommittedData>&& dataToIndex) noexcept override;\n     std::shared_ptr<TColumnEngineChanges> StartCompaction(const std::shared_ptr<NDataLocks::TManager>& dataLocksManager) noexcept override;\n     std::shared_ptr<TCleanupPortionsColumnEngineChanges> StartCleanupPortions(const TSnapshot& snapshot, const THashSet<ui64>& pathsToDrop, const std::shared_ptr<NDataLocks::TManager>& dataLocksManager) noexcept override;\n     std::shared_ptr<TCleanupTablesColumnEngineChanges> StartCleanupTables(const THashSet<ui64>& pathsToDrop) noexcept override;\n@@ -154,6 +151,10 @@ class TColumnEngineForLogs : public IColumnEngine {\n         return *GetGranulePtrVerified(pathId);\n     }\n \n+    TGranuleMeta& MutableGranuleVerified(const ui64 pathId) const {\n+        return *GetGranulePtrVerified(pathId);\n+    }\n+\n     std::shared_ptr<TGranuleMeta> GetGranulePtrVerified(const ui64 pathId) const {\n         auto result = GetGranuleOptional(pathId);\n         AFL_VERIFY(result)(\"path_id\", pathId);\n@@ -173,7 +174,7 @@ class TColumnEngineForLogs : public IColumnEngine {\n     }\n \n     void AddCleanupPortion(const TPortionInfo& info) {\n-        CleanupPortions[info.GetRemoveSnapshotVerified().GetPlanInstant() + RemovedPortionLivetime].emplace_back(info);\n+        CleanupPortions[info.GetRemoveSnapshotVerified().GetPlanInstant()].emplace_back(info);\n     }\n     void AddShardingInfo(const TGranuleShardingInfo& shardingInfo) {\n         VersionedIndex.AddShardingInfo(shardingInfo);\ndiff --git a/ydb/core/tx/columnshard/engines/db_wrapper.cpp b/ydb/core/tx/columnshard/engines/db_wrapper.cpp\nindex d38cdc53c1ae..b5c8e5e4ea58 100644\n--- a/ydb/core/tx/columnshard/engines/db_wrapper.cpp\n+++ b/ydb/core/tx/columnshard/engines/db_wrapper.cpp\n@@ -12,7 +12,7 @@ void TDbWrapper::Insert(const TInsertedData& data) {\n     NColumnShard::Schema::InsertTable_Insert(db, data);\n }\n \n-void TDbWrapper::Commit(const TInsertedData& data) {\n+void TDbWrapper::Commit(const TCommittedData& data) {\n     NIceDb::TNiceDb db(Database);\n     NColumnShard::Schema::InsertTable_Commit(db, data);\n }\n@@ -27,7 +27,7 @@ void TDbWrapper::EraseInserted(const TInsertedData& data) {\n     NColumnShard::Schema::InsertTable_EraseInserted(db, data);\n }\n \n-void TDbWrapper::EraseCommitted(const TInsertedData& data) {\n+void TDbWrapper::EraseCommitted(const TCommittedData& data) {\n     NIceDb::TNiceDb db(Database);\n     NColumnShard::Schema::InsertTable_EraseCommitted(db, data);\n }\ndiff --git a/ydb/core/tx/columnshard/engines/db_wrapper.h b/ydb/core/tx/columnshard/engines/db_wrapper.h\nindex 39536cb9c987..50958b6fca29 100644\n--- a/ydb/core/tx/columnshard/engines/db_wrapper.h\n+++ b/ydb/core/tx/columnshard/engines/db_wrapper.h\n@@ -16,7 +16,8 @@ namespace NKikimr::NOlap {\n \n class TColumnChunkLoadContext;\n class TIndexChunkLoadContext;\n-struct TInsertedData;\n+class TInsertedData;\n+class TCommittedData;\n class TInsertTableAccessor;\n class TColumnRecord;\n class TIndexChunk;\n@@ -30,10 +31,10 @@ class IDbWrapper {\n     virtual ~IDbWrapper() = default;\n \n     virtual void Insert(const TInsertedData& data) = 0;\n-    virtual void Commit(const TInsertedData& data) = 0;\n+    virtual void Commit(const TCommittedData& data) = 0;\n     virtual void Abort(const TInsertedData& data) = 0;\n     virtual void EraseInserted(const TInsertedData& data) = 0;\n-    virtual void EraseCommitted(const TInsertedData& data) = 0;\n+    virtual void EraseCommitted(const TCommittedData& data) = 0;\n     virtual void EraseAborted(const TInsertedData& data) = 0;\n \n     virtual bool Load(TInsertTableAccessor& insertTable, const TInstant& loadTime) = 0;\n@@ -63,10 +64,10 @@ class TDbWrapper : public IDbWrapper {\n     {}\n \n     void Insert(const TInsertedData& data) override;\n-    void Commit(const TInsertedData& data) override;\n+    void Commit(const TCommittedData& data) override;\n     void Abort(const TInsertedData& data) override;\n     void EraseInserted(const TInsertedData& data) override;\n-    void EraseCommitted(const TInsertedData& data) override;\n+    void EraseCommitted(const TCommittedData& data) override;\n     void EraseAborted(const TInsertedData& data) override;\n \n     bool Load(TInsertTableAccessor& insertTable, const TInstant& loadTime) override;\ndiff --git a/ydb/core/tx/columnshard/engines/defs.cpp b/ydb/core/tx/columnshard/engines/defs.cpp\nnew file mode 100644\nindex 000000000000..2c50c99d1d3c\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/defs.cpp\n@@ -0,0 +1,11 @@\n+#include \"defs.h\"\n+\n+template <>\n+void Out<NKikimr::NOlap::TOperationWriteId>(IOutputStream& os, TTypeTraits<NKikimr::NOlap::TOperationWriteId>::TFuncParam val) {\n+    os << (ui64)val;\n+}\n+\n+template <>\n+void Out<NKikimr::NOlap::TInsertWriteId>(IOutputStream& os, TTypeTraits<NKikimr::NOlap::TInsertWriteId>::TFuncParam val) {\n+    os << (ui64)val;\n+}\ndiff --git a/ydb/core/tx/columnshard/engines/defs.h b/ydb/core/tx/columnshard/engines/defs.h\nindex a01edc7ef767..efe1f1c744a8 100644\n--- a/ydb/core/tx/columnshard/engines/defs.h\n+++ b/ydb/core/tx/columnshard/engines/defs.h\n@@ -8,18 +8,33 @@ namespace NKikimr::NOlap {\n \n using TLogThis = TCtorLogger<NKikimrServices::TX_COLUMNSHARD>;\n \n-enum class TWriteId : ui64 {};\n+enum class TOperationWriteId : ui64 {\n+};\n+enum class TInsertWriteId : ui64 {\n+};\n+\n+inline TOperationWriteId operator++(TOperationWriteId& w) noexcept {\n+    w = TOperationWriteId{ ui64(w) + 1 };\n+    return w;\n+}\n \n-inline TWriteId operator++(TWriteId& w) noexcept {\n-    w = TWriteId{ui64(w) + 1};\n+inline TInsertWriteId operator++(TInsertWriteId& w) noexcept {\n+    w = TInsertWriteId{ ui64(w) + 1 };\n     return w;\n }\n \n-} // namespace NKikimr::NOlap\n+}   // namespace NKikimr::NOlap\n+\n+template <>\n+struct THash<NKikimr::NOlap::TInsertWriteId> {\n+    inline size_t operator()(const NKikimr::NOlap::TInsertWriteId x) const noexcept {\n+        return THash<ui64>()(ui64(x));\n+    }\n+};\n \n template <>\n-struct THash<NKikimr::NOlap::TWriteId> {\n-    inline size_t operator()(const NKikimr::NOlap::TWriteId x) const noexcept {\n+struct THash<NKikimr::NOlap::TOperationWriteId> {\n+    inline size_t operator()(const NKikimr::NOlap::TOperationWriteId x) const noexcept {\n         return THash<ui64>()(ui64(x));\n     }\n };\ndiff --git a/ydb/core/tx/columnshard/engines/filter.h b/ydb/core/tx/columnshard/engines/filter.h\nindex 7670b0eab1d3..39167306b993 100644\n--- a/ydb/core/tx/columnshard/engines/filter.h\n+++ b/ydb/core/tx/columnshard/engines/filter.h\n@@ -2,7 +2,7 @@\n \n #include \"defs.h\"\n #include <ydb/core/formats/arrow/program.h>\n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n \n namespace NKikimr::NOlap {\ndiff --git a/ydb/core/tx/columnshard/splitter/similar_packer.cpp b/ydb/core/tx/columnshard/engines/insert_table/committed.cpp\nsimilarity index 52%\nrename from ydb/core/tx/columnshard/splitter/similar_packer.cpp\nrename to ydb/core/tx/columnshard/engines/insert_table/committed.cpp\nindex 9d22b3a6b255..bd4bb9ff6c06 100644\n--- a/ydb/core/tx/columnshard/splitter/similar_packer.cpp\n+++ b/ydb/core/tx/columnshard/engines/insert_table/committed.cpp\n@@ -1,4 +1,4 @@\n-#include \"similar_packer.h\"\n+#include \"committed.h\"\n \n namespace NKikimr::NOlap {\n \ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/committed.h b/ydb/core/tx/columnshard/engines/insert_table/committed.h\nnew file mode 100644\nindex 000000000000..bd633647b5ec\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/insert_table/committed.h\n@@ -0,0 +1,161 @@\n+#pragma once\n+#include \"user_data.h\"\n+\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n+\n+namespace NKikimr::NOlap {\n+\n+class TCommittedData: public TUserDataContainer {\n+private:\n+    using TBase = TUserDataContainer;\n+    YDB_READONLY(TSnapshot, Snapshot, NOlap::TSnapshot::Zero());\n+    YDB_READONLY_DEF(TString, DedupId);\n+    YDB_READONLY(bool, Remove, false);\n+\n+public:\n+    TCommittedData(const std::shared_ptr<TUserData>& userData, const ui64 planStep, const ui64 txId, const TInsertWriteId insertWriteId)\n+        : TBase(userData)\n+        , Snapshot(planStep, txId)\n+        , DedupId(ToString(planStep) + \":\" + ToString((ui64)insertWriteId)) {\n+    }\n+\n+    TCommittedData(const std::shared_ptr<TUserData>& userData, const ui64 planStep, const ui64 txId, const TString& dedupId)\n+        : TBase(userData)\n+        , Snapshot(planStep, txId)\n+        , DedupId(dedupId) {\n+    }\n+\n+    TCommittedData(const std::shared_ptr<TUserData>& userData, const TSnapshot& ss, const TInsertWriteId insertWriteId)\n+        : TBase(userData)\n+        , Snapshot(ss)\n+        , DedupId(ToString(ss.GetPlanStep()) + \":\" + ToString((ui64)insertWriteId)) {\n+    }\n+\n+    void SetRemove() {\n+        AFL_VERIFY(!Remove);\n+        Remove = true;\n+    }\n+\n+    bool operator<(const TCommittedData& key) const {\n+        if (Snapshot == key.Snapshot) {\n+            if (UserData->GetPathId() == key.UserData->GetPathId()) {\n+                return DedupId < key.DedupId;\n+            } else {\n+                return UserData->GetPathId() < key.UserData->GetPathId();\n+            }\n+        } else {\n+            return Snapshot < key.Snapshot;\n+        }\n+    }\n+};\n+\n+class TCommittedBlob {\n+private:\n+    TBlobRange BlobRange;\n+    std::variant<TSnapshot, TInsertWriteId> WriteInfo;\n+    YDB_READONLY(ui64, SchemaVersion, 0);\n+    YDB_READONLY(ui64, RecordsCount, 0);\n+    YDB_READONLY(bool, IsDelete, false);\n+    NArrow::TReplaceKey First;\n+    NArrow::TReplaceKey Last;\n+    YDB_READONLY_DEF(NArrow::TSchemaSubset, SchemaSubset);\n+\n+public:\n+    const NArrow::TReplaceKey& GetFirst() const {\n+        return First;\n+    }\n+    const NArrow::TReplaceKey& GetLast() const {\n+        return Last;\n+    }\n+\n+    ui64 GetSize() const {\n+        return BlobRange.Size;\n+    }\n+\n+    TCommittedBlob(const TBlobRange& blobRange, const TSnapshot& snapshot, const ui64 schemaVersion, const ui64 recordsCount,\n+        const NArrow::TReplaceKey& first, const NArrow::TReplaceKey& last, const bool isDelete,\n+        const NArrow::TSchemaSubset& subset)\n+        : BlobRange(blobRange)\n+        , WriteInfo(snapshot)\n+        , SchemaVersion(schemaVersion)\n+        , RecordsCount(recordsCount)\n+        , IsDelete(isDelete)\n+        , First(first)\n+        , Last(last)\n+        , SchemaSubset(subset) {\n+    }\n+\n+    TCommittedBlob(const TBlobRange& blobRange, const TInsertWriteId writeId, const ui64 schemaVersion, const ui64 recordsCount,\n+        const NArrow::TReplaceKey& first, const NArrow::TReplaceKey& last, const bool isDelete,\n+        const NArrow::TSchemaSubset& subset)\n+        : BlobRange(blobRange)\n+        , WriteInfo(writeId)\n+        , SchemaVersion(schemaVersion)\n+        , RecordsCount(recordsCount)\n+        , IsDelete(isDelete)\n+        , First(first)\n+        , Last(last)\n+        , SchemaSubset(subset) {\n+    }\n+\n+    /// It uses trick then we place key with planStep:txId in container and find them later by BlobId only.\n+    /// So hash() and equality should depend on BlobId only.\n+    bool operator==(const TCommittedBlob& key) const {\n+        return BlobRange == key.BlobRange;\n+    }\n+    ui64 Hash() const noexcept {\n+        return BlobRange.Hash();\n+    }\n+    TString DebugString() const {\n+        if (auto* ss = GetSnapshotOptional()) {\n+            return TStringBuilder() << BlobRange << \";snapshot=\" << ss->DebugString();\n+        } else {\n+            return TStringBuilder() << BlobRange << \";write_id=\" << (ui64)GetWriteIdVerified();\n+        }\n+    }\n+\n+    bool HasSnapshot() const {\n+        return GetSnapshotOptional();\n+    }\n+\n+    const TSnapshot& GetSnapshotDef(const TSnapshot& def) const {\n+        if (auto* snapshot = GetSnapshotOptional()) {\n+            return *snapshot;\n+        } else {\n+            return def;\n+        }\n+    }\n+\n+    const TSnapshot* GetSnapshotOptional() const {\n+        return std::get_if<TSnapshot>(&WriteInfo);\n+    }\n+\n+    const TSnapshot& GetSnapshotVerified() const {\n+        auto* result = GetSnapshotOptional();\n+        AFL_VERIFY(result);\n+        return *result;\n+    }\n+\n+    const TInsertWriteId* GetWriteIdOptional() const {\n+        return std::get_if<TInsertWriteId>(&WriteInfo);\n+    }\n+\n+    TInsertWriteId GetWriteIdVerified() const {\n+        auto* result = GetWriteIdOptional();\n+        AFL_VERIFY(result);\n+        return *result;\n+    }\n+\n+    const TBlobRange& GetBlobRange() const {\n+        return BlobRange;\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap\n+\n+template <>\n+struct THash<NKikimr::NOlap::TCommittedBlob> {\n+    inline size_t operator()(const NKikimr::NOlap::TCommittedBlob& key) const {\n+        return key.Hash();\n+    }\n+};\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/data.h b/ydb/core/tx/columnshard/engines/insert_table/data.h\ndeleted file mode 100644\nindex e804fec66ec9..000000000000\n--- a/ydb/core/tx/columnshard/engines/insert_table/data.h\n+++ /dev/null\n@@ -1,199 +0,0 @@\n-#pragma once\n-#include \"meta.h\"\n-#include <ydb/core/tx/columnshard/blob.h>\n-#include <ydb/core/tx/columnshard/engines/defs.h>\n-#include <ydb/core/tx/columnshard/common/snapshot.h>\n-#include <ydb/core/protos/tx_columnshard.pb.h>\n-\n-namespace NKikimr::NOlap {\n-\n-struct TInsertedData {\n-private:\n-    TInsertedDataMeta Meta;\n-    YDB_READONLY_DEF(TBlobRange, BlobRange);\n-    class TBlobStorageGuard {\n-    private:\n-        YDB_READONLY_DEF(TString, Data);\n-    public:\n-        TBlobStorageGuard(const TString& data)\n-            : Data(data)\n-        {\n-\n-        }\n-        ~TBlobStorageGuard();\n-    };\n-\n-    std::shared_ptr<TBlobStorageGuard> BlobDataGuard;\n-\n-public:\n-    ui64 PlanStep = 0;\n-    ui64 WriteTxId = 0;\n-    ui64 PathId = 0;\n-    TString DedupId;\n-\n-private:\n-    YDB_READONLY(ui64, SchemaVersion, 0);\n-    YDB_READONLY_FLAG(NotAbortable, false);\n-\n-public:\n-    void MarkAsNotAbortable() {\n-        NotAbortableFlag = true;\n-    }\n-\n-    std::optional<TString> GetBlobData() const {\n-        if (BlobDataGuard) {\n-            return BlobDataGuard->GetData();\n-        } else {\n-            return {};\n-        }\n-    }\n-\n-    ui64 GetTxVolume() const {\n-        return Meta.GetTxVolume() + sizeof(TBlobRange);\n-    }\n-\n-    const TInsertedDataMeta& GetMeta() const {\n-        return Meta;\n-    }\n-\n-    TInsertedData() = delete; // avoid invalid TInsertedData anywhere\n-\n-    TInsertedData(ui64 planStep, ui64 writeTxId, ui64 pathId, TString dedupId, const TBlobRange& blobRange,\n-        const NKikimrTxColumnShard::TLogicalMetadata& proto, const ui64 schemaVersion, const std::optional<TString>& blobData);\n-\n-    TInsertedData(ui64 writeTxId, ui64 pathId, TString dedupId, const TBlobRange& blobRange, const NKikimrTxColumnShard::TLogicalMetadata& proto,\n-        const ui64 schemaVersion, const std::optional<TString>& blobData)\n-        : TInsertedData(0, writeTxId, pathId, dedupId, blobRange, proto, schemaVersion, blobData)\n-    {}\n-\n-    TInsertedData(ui64 writeTxId, ui64 pathId, TString dedupId, const TUnifiedBlobId& blobId,\n-        const NKikimrTxColumnShard::TLogicalMetadata& proto, const ui64 schemaVersion, const std::optional<TString>& blobData)\n-        : TInsertedData(0, writeTxId, pathId, dedupId, TBlobRange(blobId, 0, blobId.BlobSize()), proto, schemaVersion, blobData)\n-    {\n-    }\n-\n-    ~TInsertedData();\n-\n-    bool operator < (const TInsertedData& key) const {\n-        if (PlanStep < key.PlanStep) {\n-            return true;\n-        } else if (PlanStep > key.PlanStep) {\n-            return false;\n-        }\n-\n-        // PlanStep == key.PlanStep\n-        if (WriteTxId < key.WriteTxId) {\n-            return true;\n-        } else if (WriteTxId > key.WriteTxId) {\n-            return false;\n-        }\n-\n-        // PlanStep == key.PlanStep && WriteTxId == key.WriteTxId\n-        if (PathId < key.PathId) {\n-            return true;\n-        } else if (PathId > key.PathId) {\n-            return false;\n-        }\n-\n-        return DedupId < key.DedupId;\n-    }\n-\n-    bool operator == (const TInsertedData& key) const {\n-        return (PlanStep == key.PlanStep) &&\n-            (WriteTxId == key.WriteTxId) &&\n-            (PathId == key.PathId) &&\n-            (DedupId == key.DedupId);\n-    }\n-\n-    /// We commit many writeIds in one txId. There could be several blobs with same WriteId and different DedupId.\n-    /// One of them wins and becomes committed. Original DedupId would be lost then.\n-    /// After commit we use original Initiator:WriteId as DedupId of inserted blob inside {PlanStep, TxId}.\n-    /// pathId, initiator, {writeId}, {dedupId} -> pathId, planStep, txId, {dedupId}\n-    void Commit(const ui64 planStep, const ui64 txId) {\n-        DedupId = ToString(PlanStep) + \":\" + ToString((ui64)WriteTxId);\n-        PlanStep = planStep;\n-        WriteTxId = txId;\n-    }\n-\n-    /// Undo Commit() operation. Restore Initiator:WriteId from DedupId.\n-    void Undo() {\n-        TVector<TString> tokens;\n-        size_t numTokens = Split(DedupId, \":\", tokens);\n-        Y_ABORT_UNLESS(numTokens == 2);\n-\n-        PlanStep = FromString<ui64>(tokens[0]);\n-        WriteTxId = FromString<ui64>(tokens[1]);\n-        DedupId.clear();\n-    }\n-\n-    TSnapshot GetSnapshot() const {\n-        return TSnapshot(PlanStep, WriteTxId);\n-    }\n-\n-    ui32 BlobSize() const { return BlobRange.GetBlobSize(); }\n-\n-};\n-\n-class TCommittedBlob {\n-private:\n-    TBlobRange BlobRange;\n-    TSnapshot CommitSnapshot;\n-    YDB_READONLY(ui64, SchemaVersion, 0);\n-    YDB_READONLY(ui64, RecordsCount, 0);\n-    YDB_READONLY(bool, IsDelete, false);\n-    YDB_READONLY_DEF(std::optional<NArrow::TReplaceKey>, First);\n-    YDB_READONLY_DEF(std::optional<NArrow::TReplaceKey>, Last);\n-    YDB_READONLY_DEF(NArrow::TSchemaSubset, SchemaSubset);\n-\n-public:\n-    ui64 GetSize() const {\n-        return BlobRange.Size;\n-    }\n-\n-    const NArrow::TReplaceKey& GetFirstVerified() const {\n-        Y_ABORT_UNLESS(First);\n-        return *First;\n-    }\n-\n-    const NArrow::TReplaceKey& GetLastVerified() const {\n-        Y_ABORT_UNLESS(Last);\n-        return *Last;\n-    }\n-\n-    TCommittedBlob(const TBlobRange& blobRange, const TSnapshot& snapshot, const ui64 schemaVersion, const ui64 recordsCount, const std::optional<NArrow::TReplaceKey>& first, \n-        const std::optional<NArrow::TReplaceKey>& last, const bool isDelete, const NArrow::TSchemaSubset& subset)\n-        : BlobRange(blobRange)\n-        , CommitSnapshot(snapshot)\n-        , SchemaVersion(schemaVersion)\n-        , RecordsCount(recordsCount)\n-        , IsDelete(isDelete)\n-        , First(first)\n-        , Last(last)\n-        , SchemaSubset(subset)\n-    {}\n-\n-    /// It uses trick then we place key with planStep:txId in container and find them later by BlobId only.\n-    /// So hash() and equality should depend on BlobId only.\n-    bool operator == (const TCommittedBlob& key) const { return BlobRange == key.BlobRange; }\n-    ui64 Hash() const noexcept { return BlobRange.Hash(); }\n-    TString DebugString() const {\n-        return TStringBuilder() << BlobRange << \";ps=\" << CommitSnapshot.GetPlanStep() << \";ti=\" << CommitSnapshot.GetTxId();\n-    }\n-\n-    const TSnapshot& GetSnapshot() const {\n-        return CommitSnapshot;\n-    }\n-\n-    const TBlobRange& GetBlobRange() const {\n-        return BlobRange;\n-    }\n-};\n-\n-}\n-\n-template <>\n-struct THash<NKikimr::NOlap::TCommittedBlob> {\n-    inline size_t operator() (const NKikimr::NOlap::TCommittedBlob& key) const {\n-        return key.Hash();\n-    }\n-};\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/insert_table.cpp b/ydb/core/tx/columnshard/engines/insert_table/insert_table.cpp\nindex 63e2d0905b99..980882ad8eca 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/insert_table.cpp\n+++ b/ydb/core/tx/columnshard/engines/insert_table/insert_table.cpp\n@@ -1,7 +1,9 @@\n #include \"insert_table.h\"\n+\n #include <ydb/core/protos/tx_columnshard.pb.h>\n-#include <ydb/core/tx/columnshard/engines/db_wrapper.h>\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n #include <ydb/core/tx/columnshard/engines/column_engine.h>\n+#include <ydb/core/tx/columnshard/engines/db_wrapper.h>\n \n namespace NKikimr::NOlap {\n \n@@ -11,12 +13,13 @@ bool TInsertTable::Insert(IDbWrapper& dbTable, TInsertedData&& data) {\n         dbTable.Insert(*dataPtr);\n         return true;\n     } else {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_insertion\");\n         return false;\n     }\n }\n \n-TInsertionSummary::TCounters TInsertTable::Commit(IDbWrapper& dbTable, ui64 planStep, ui64 txId,\n-                                             const THashSet<TWriteId>& writeIds, std::function<bool(ui64)> pathExists) {\n+TInsertionSummary::TCounters TInsertTable::Commit(\n+    IDbWrapper& dbTable, ui64 planStep, ui64 txId, const THashSet<TInsertWriteId>& writeIds, std::function<bool(ui64)> pathExists) {\n     Y_ABORT_UNLESS(!writeIds.empty());\n \n     TInsertionSummary::TCounters counters;\n@@ -33,15 +36,19 @@ TInsertionSummary::TCounters TInsertTable::Commit(IDbWrapper& dbTable, ui64 plan\n \n         dbTable.EraseInserted(*data);\n \n-        const ui64 pathId = data->PathId;\n+        const ui64 pathId = data->GetPathId();\n         auto* pathInfo = Summary.GetPathInfoOptional(pathId);\n         // There could be commit after drop: propose, drop, plan\n         if (pathInfo && pathExists(pathId)) {\n-            data->Commit(planStep, txId);\n-            dbTable.Commit(*data);\n+            AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"commit_insertion\")(\"path_id\", data->GetPathId())(\n+                \"blob_range\", data->GetBlobRange().ToString());\n+            auto committed = data->Commit(planStep, txId);\n+            dbTable.Commit(committed);\n \n-            pathInfo->AddCommitted(std::move(*data));\n+            pathInfo->AddCommitted(std::move(committed));\n         } else {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"abort_insertion\")(\"path_id\", data->GetPathId())(\n+                \"blob_range\", data->GetBlobRange().ToString());\n             dbTable.Abort(*data);\n             Summary.AddAborted(std::move(*data));\n         }\n@@ -50,12 +57,14 @@ TInsertionSummary::TCounters TInsertTable::Commit(IDbWrapper& dbTable, ui64 plan\n     return counters;\n }\n \n-void TInsertTable::Abort(IDbWrapper& dbTable, const THashSet<TWriteId>& writeIds) {\n+void TInsertTable::Abort(IDbWrapper& dbTable, const THashSet<TInsertWriteId>& writeIds) {\n     Y_ABORT_UNLESS(!writeIds.empty());\n \n     for (auto writeId : writeIds) {\n         // There could be inconsistency with txs and writes in case of bugs. So we could find no record for writeId.\n         if (std::optional<TInsertedData> data = Summary.ExtractInserted(writeId)) {\n+            AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"abort_insertion\")(\"path_id\", data->GetPathId())(\n+                \"blob_range\", data->GetBlobRange().ToString())(\"write_id\", writeId);\n             dbTable.EraseInserted(*data);\n             dbTable.Abort(*data);\n             Summary.AddAborted(std::move(*data));\n@@ -63,88 +72,100 @@ void TInsertTable::Abort(IDbWrapper& dbTable, const THashSet<TWriteId>& writeIds\n     }\n }\n \n-THashSet<TWriteId> TInsertTable::OldWritesToAbort(const TInstant& now) const {\n+THashSet<TInsertWriteId> TInsertTable::OldWritesToAbort(const TInstant& now) const {\n     return Summary.GetExpiredInsertions(now - WaitCommitDelay, CleanupPackageSize);\n }\n \n-THashSet<TWriteId> TInsertTable::DropPath(IDbWrapper& dbTable, ui64 pathId) {\n-    auto pathInfo = Summary.ExtractPathInfo(pathId);\n-    if (!!pathInfo) {\n-        for (auto& data : pathInfo->GetCommitted()) {\n-            dbTable.EraseCommitted(data);\n-            TInsertedData copy = data;\n-            copy.Undo();\n-            dbTable.Abort(copy);\n-            Summary.AddAborted(std::move(copy));\n-        }\n-    }\n-\n-    return Summary.GetInsertedByPathId(pathId);\n-}\n-\n-void TInsertTable::EraseCommittedOnExecute(IDbWrapper& dbTable, const TInsertedData& data, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction) {\n+void TInsertTable::EraseCommittedOnExecute(\n+    IDbWrapper& dbTable, const TCommittedData& data, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction) {\n     if (Summary.HasCommitted(data)) {\n         dbTable.EraseCommitted(data);\n         RemoveBlobLinkOnExecute(data.GetBlobRange().BlobId, blobsAction);\n     }\n }\n \n-void TInsertTable::EraseCommittedOnComplete(const TInsertedData& data) {\n+void TInsertTable::EraseCommittedOnComplete(const TCommittedData& data) {\n     if (Summary.EraseCommitted(data)) {\n         RemoveBlobLinkOnComplete(data.GetBlobRange().BlobId);\n     }\n }\n \n-void TInsertTable::EraseAbortedOnExecute(IDbWrapper& dbTable, const TInsertedData& data, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction) {\n-    if (Summary.HasAborted((TWriteId)data.WriteTxId)) {\n+void TInsertTable::EraseAbortedOnExecute(\n+    IDbWrapper& dbTable, const TInsertedData& data, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction) {\n+    if (Summary.HasAborted(data.GetInsertWriteId())) {\n         dbTable.EraseAborted(data);\n         RemoveBlobLinkOnExecute(data.GetBlobRange().BlobId, blobsAction);\n     }\n }\n \n void TInsertTable::EraseAbortedOnComplete(const TInsertedData& data) {\n-    if (Summary.EraseAborted((TWriteId)data.WriteTxId)) {\n+    if (Summary.EraseAborted(data.GetInsertWriteId())) {\n         RemoveBlobLinkOnComplete(data.GetBlobRange().BlobId);\n     }\n }\n \n-bool TInsertTable::Load(IDbWrapper& dbTable, const TInstant loadTime) {\n+bool TInsertTable::Load(NIceDb::TNiceDb& db, IDbWrapper& dbTable, const TInstant loadTime) {\n     Y_ABORT_UNLESS(!Loaded);\n     Loaded = true;\n+    LastWriteId = (TInsertWriteId)0;\n+    if (!NColumnShard::Schema::GetSpecialValueOpt(db, NColumnShard::Schema::EValueIds::LastWriteId, LastWriteId)) {\n+        return false;\n+    }\n+\n     return dbTable.Load(*this, loadTime);\n }\n \n-std::vector<TCommittedBlob> TInsertTable::Read(ui64 pathId, const TSnapshot& snapshot, const std::shared_ptr<arrow::Schema>& pkSchema) const {\n+std::vector<TCommittedBlob> TInsertTable::Read(ui64 pathId, const std::optional<ui64> lockId, const TSnapshot& reqSnapshot,\n+    const std::shared_ptr<arrow::Schema>& pkSchema, const TPKRangesFilter* pkRangesFilter) const {\n     const TPathInfo* pInfo = Summary.GetPathInfoOptional(pathId);\n     if (!pInfo) {\n         return {};\n     }\n \n-    std::vector<const TInsertedData*> ret;\n-    ret.reserve(pInfo->GetCommitted().size());\n+    std::vector<TCommittedBlob> result;\n+    result.reserve(pInfo->GetCommitted().size() + Summary.GetInserted().size());\n \n     for (const auto& data : pInfo->GetCommitted()) {\n-        if (std::less_equal<TSnapshot>()(data.GetSnapshot(), snapshot)) {\n-            ret.emplace_back(&data);\n+        if (lockId || data.GetSnapshot() <= reqSnapshot) {\n+            auto start = data.GetMeta().GetFirstPK(pkSchema);\n+            auto finish = data.GetMeta().GetLastPK(pkSchema);\n+            if (pkRangesFilter && pkRangesFilter->IsPortionInPartialUsage(start, finish) == TPKRangeFilter::EUsageClass::DontUsage) {\n+                continue;\n+            }\n+            result.emplace_back(TCommittedBlob(data.GetBlobRange(), data.GetSnapshot(), data.GetSchemaVersion(), data.GetMeta().GetNumRows(),\n+                start, finish, data.GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete, data.GetMeta().GetSchemaSubset()));\n         }\n     }\n-    const auto pred = [pkSchema](const TInsertedData* l, const TInsertedData* r) {\n-        return l->GetMeta().GetFirstPK(pkSchema) < r->GetMeta().GetFirstPK(pkSchema);\n-    };\n-    std::sort(ret.begin(), ret.end(), pred);\n-\n-    std::vector<TCommittedBlob> result;\n-    result.reserve(ret.size());\n-    for (auto&& i : ret) {\n-        result.emplace_back(TCommittedBlob(\n-            i->GetBlobRange(), i->GetSnapshot(), i->GetSchemaVersion(), i->GetMeta().GetNumRows(), i->GetMeta().GetFirstPK(pkSchema), i->GetMeta().GetLastPK(pkSchema)\n-        , i->GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete, i->GetMeta().GetSchemaSubset()));\n+    if (lockId) {\n+        for (const auto& [writeId, data] : Summary.GetInserted()) {\n+            if (data.GetPathId() != pathId) {\n+                continue;\n+            }\n+            auto start = data.GetMeta().GetFirstPK(pkSchema);\n+            auto finish = data.GetMeta().GetLastPK(pkSchema);\n+            if (pkRangesFilter && pkRangesFilter->IsPortionInPartialUsage(start, finish) == TPKRangeFilter::EUsageClass::DontUsage) {\n+                continue;\n+            }\n+            result.emplace_back(TCommittedBlob(data.GetBlobRange(), writeId, data.GetSchemaVersion(), data.GetMeta().GetNumRows(), start, finish,\n+                data.GetMeta().GetModificationType() == NEvWrite::EModificationType::Delete, data.GetMeta().GetSchemaSubset()));\n+        }\n     }\n-\n     return result;\n }\n \n-bool TInsertTableAccessor::RemoveBlobLinkOnExecute(const TUnifiedBlobId& blobId, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction) {\n+TInsertWriteId TInsertTable::BuildNextWriteId(NTabletFlatExecutor::TTransactionContext& txc) {\n+    NIceDb::TNiceDb db(txc.DB);\n+    return BuildNextWriteId(db);\n+}\n+\n+TInsertWriteId TInsertTable::BuildNextWriteId(NIceDb::TNiceDb& db) {\n+    TInsertWriteId writeId = ++LastWriteId;\n+    NColumnShard::Schema::SaveSpecialValue(db, NColumnShard::Schema::EValueIds::LastWriteId, (ui64)writeId);\n+    return writeId;\n+}\n+\n+bool TInsertTableAccessor::RemoveBlobLinkOnExecute(\n+    const TUnifiedBlobId& blobId, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction) {\n     AFL_VERIFY(blobsAction);\n     auto itBlob = BlobLinks.find(blobId);\n     AFL_VERIFY(itBlob != BlobLinks.end());\n@@ -170,4 +191,4 @@ bool TInsertTableAccessor::RemoveBlobLinkOnComplete(const TUnifiedBlobId& blobId\n     }\n }\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/insert_table.h b/ydb/core/tx/columnshard/engines/insert_table/insert_table.h\nindex 27762ebf5c66..4f7544e10184 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/insert_table.h\n+++ b/ydb/core/tx/columnshard/engines/insert_table/insert_table.h\n@@ -1,17 +1,17 @@\n #pragma once\n-#include \"data.h\"\n-#include \"rt_insertion.h\"\n+#include \"committed.h\"\n+#include \"inserted.h\"\n #include \"path_info.h\"\n+#include \"rt_insertion.h\"\n+\n+#include <ydb/core/tablet_flat/flat_cxx_database.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executor.h>\n #include <ydb/core/tx/columnshard/counters/insert_table.h>\n \n namespace NKikimr::NOlap {\n-\n+class TPKRangesFilter;\n class IDbWrapper;\n \n-/// Use one table for inserted and committed blobs:\n-/// !Commited => {PlanStep, WriteTxId} are {0, WriteId}\n-///  Commited => {PlanStep, WriteTxId} are {PlanStep, TxId}\n-\n class TInsertTableAccessor {\n protected:\n     TInsertionSummary Summary;\n@@ -23,7 +23,14 @@ class TInsertTableAccessor {\n \n     bool RemoveBlobLinkOnExecute(const TUnifiedBlobId& blobId, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction);\n     bool RemoveBlobLinkOnComplete(const TUnifiedBlobId& blobId);\n+\n public:\n+    void ErasePath(const ui64 pathId) {\n+        Summary.ErasePath(pathId);\n+    }\n+    bool HasDataInPathId(const ui64 pathId) const {\n+        return Summary.HasPathIdData(pathId);\n+    }\n     const std::map<TPathInfoIndexPriority, std::set<const TPathInfo*>>& GetPathPriorities() const {\n         return Summary.GetPathPriorities();\n     }\n@@ -46,20 +53,28 @@ class TInsertTableAccessor {\n         return Summary.AddInserted(std::move(data), load);\n     }\n     bool AddAborted(TInsertedData&& data, const bool load) {\n+        AFL_VERIFY_DEBUG(!Summary.ExtractInserted(data.GetInsertWriteId()));\n         if (load) {\n             AddBlobLink(data.GetBlobRange().BlobId);\n         }\n         return Summary.AddAborted(std::move(data), load);\n     }\n-    bool AddCommitted(TInsertedData&& data, const bool load) {\n+    bool AddCommitted(TCommittedData&& data, const bool load) {\n         if (load) {\n             AddBlobLink(data.GetBlobRange().BlobId);\n         }\n-        const ui64 pathId = data.PathId;\n+        const ui64 pathId = data.GetPathId();\n         return Summary.GetPathInfo(pathId).AddCommitted(std::move(data), load);\n     }\n-    const THashMap<TWriteId, TInsertedData>& GetAborted() const { return Summary.GetAborted(); }\n-    const THashMap<TWriteId, TInsertedData>& GetInserted() const { return Summary.GetInserted(); }\n+    bool HasPathIdData(const ui64 pathId) const {\n+        return Summary.HasPathIdData(pathId);\n+    }\n+    const THashMap<TInsertWriteId, TInsertedData>& GetAborted() const {\n+        return Summary.GetAborted();\n+    }\n+    const TInsertedContainer& GetInserted() const {\n+        return Summary.GetInserted();\n+    }\n     const TInsertionSummary::TCounters& GetCountersPrepared() const {\n         return Summary.GetCountersPrepared();\n     }\n@@ -74,28 +89,34 @@ class TInsertTableAccessor {\n class TInsertTable: public TInsertTableAccessor {\n private:\n     bool Loaded = false;\n+    TInsertWriteId LastWriteId = TInsertWriteId{ 0 };\n+\n public:\n     static constexpr const TDuration WaitCommitDelay = TDuration::Minutes(10);\n     static constexpr ui64 CleanupPackageSize = 10000;\n \n     bool Insert(IDbWrapper& dbTable, TInsertedData&& data);\n-    TInsertionSummary::TCounters Commit(IDbWrapper& dbTable, ui64 planStep, ui64 txId,\n-                     const THashSet<TWriteId>& writeIds, std::function<bool(ui64)> pathExists);\n-    void Abort(IDbWrapper& dbTable, const THashSet<TWriteId>& writeIds);\n-    void MarkAsNotAbortable(const TWriteId writeId) {\n+    TInsertionSummary::TCounters Commit(\n+        IDbWrapper& dbTable, ui64 planStep, ui64 txId, const THashSet<TInsertWriteId>& writeIds, std::function<bool(ui64)> pathExists);\n+    void Abort(IDbWrapper& dbTable, const THashSet<TInsertWriteId>& writeIds);\n+    void MarkAsNotAbortable(const TInsertWriteId writeId) {\n         Summary.MarkAsNotAbortable(writeId);\n     }\n-    THashSet<TWriteId> OldWritesToAbort(const TInstant& now) const;\n-    THashSet<TWriteId> DropPath(IDbWrapper& dbTable, ui64 pathId);\n+    THashSet<TInsertWriteId> OldWritesToAbort(const TInstant& now) const;\n \n-    void EraseCommittedOnExecute(IDbWrapper& dbTable, const TInsertedData& key, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction);\n-    void EraseCommittedOnComplete(const TInsertedData& key);\n+    void EraseCommittedOnExecute(\n+        IDbWrapper& dbTable, const TCommittedData& key, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction);\n+    void EraseCommittedOnComplete(const TCommittedData& key);\n \n     void EraseAbortedOnExecute(IDbWrapper& dbTable, const TInsertedData& key, const std::shared_ptr<IBlobsDeclareRemovingAction>& blobsAction);\n     void EraseAbortedOnComplete(const TInsertedData& key);\n \n-    std::vector<TCommittedBlob> Read(ui64 pathId, const TSnapshot& snapshot, const std::shared_ptr<arrow::Schema>& pkSchema) const;\n-    bool Load(IDbWrapper& dbTable, const TInstant loadTime);\n+    std::vector<TCommittedBlob> Read(ui64 pathId, const std::optional<ui64> lockId, const TSnapshot& reqSnapshot,\n+        const std::shared_ptr<arrow::Schema>& pkSchema, const TPKRangesFilter* pkRangesFilter) const;\n+    bool Load(NIceDb::TNiceDb& db, IDbWrapper& dbTable, const TInstant loadTime);\n+\n+    TInsertWriteId BuildNextWriteId(NTabletFlatExecutor::TTransactionContext& txc);\n+    TInsertWriteId BuildNextWriteId(NIceDb::TNiceDb& db);\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/inserted.cpp b/ydb/core/tx/columnshard/engines/insert_table/inserted.cpp\nnew file mode 100644\nindex 000000000000..2986fc0b4c35\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/insert_table/inserted.cpp\n@@ -0,0 +1,12 @@\n+#include \"committed.h\"\n+#include \"inserted.h\"\n+\n+#include <ydb/library/actors/core/log.h>\n+\n+namespace NKikimr::NOlap {\n+\n+TCommittedData TInsertedData::Commit(const ui64 planStep, const ui64 txId) {\n+    return TCommittedData(UserData, planStep, txId, InsertWriteId);\n+}\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/inserted.h b/ydb/core/tx/columnshard/engines/insert_table/inserted.h\nnew file mode 100644\nindex 000000000000..e124edeb57e5\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/insert_table/inserted.h\n@@ -0,0 +1,35 @@\n+#pragma once\n+#include \"user_data.h\"\n+\n+#include <ydb/core/tx/columnshard/engines/defs.h>\n+\n+namespace NKikimr::NOlap {\n+\n+class TCommittedData;\n+\n+class TInsertedData: public TUserDataContainer {\n+private:\n+    using TBase = TUserDataContainer;\n+    YDB_READONLY(TInsertWriteId, InsertWriteId, TInsertWriteId(0));\n+    YDB_READONLY_FLAG(NotAbortable, false);\n+\n+public:\n+    void MarkAsNotAbortable() {\n+        NotAbortableFlag = true;\n+    }\n+\n+    TInsertedData() = delete;   // avoid invalid TInsertedData anywhere\n+\n+    TInsertedData(const TInsertWriteId writeId, const std::shared_ptr<TUserData>& userData)\n+        : TBase(userData)\n+        , InsertWriteId(writeId) {\n+    }\n+\n+    /// We commit many writeIds in one txId. There could be several blobs with same WriteId and different DedupId.\n+    /// One of them wins and becomes committed. Original DedupId would be lost then.\n+    /// After commit we use original Initiator:WriteId as DedupId of inserted blob inside {PlanStep, TxId}.\n+    /// pathId, initiator, {writeId}, {dedupId} -> pathId, planStep, txId, {dedupId}\n+    [[nodiscard]] TCommittedData Commit(const ui64 planStep, const ui64 txId);\n+};\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/meta.cpp b/ydb/core/tx/columnshard/engines/insert_table/meta.cpp\nindex caed6b91ac0d..eee7b2444b2e 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/insert_table/meta.cpp\n@@ -6,14 +6,23 @@ NKikimrTxColumnShard::TLogicalMetadata TInsertedDataMeta::SerializeToProto() con\n     return OriginalProto;\n }\n \n-const std::optional<NKikimr::NArrow::TFirstLastSpecialKeys>& TInsertedDataMeta::GetSpecialKeys() const {\n-    if (!KeysParsed) {\n-        if (OriginalProto.HasSpecialKeysRawData()) {\n-            SpecialKeysParsed = NArrow::TFirstLastSpecialKeys(OriginalProto.GetSpecialKeysRawData());\n-        }\n-        KeysParsed = true;\n+std::shared_ptr<NArrow::TFirstLastSpecialKeys> TInsertedDataMeta::GetSpecialKeys(const std::shared_ptr<arrow::Schema>& schema) const {\n+    if (KeyInitialized.Val()) {\n+        return SpecialKeysParsed;\n     }\n-    return SpecialKeysParsed;\n+    std::shared_ptr<NArrow::TFirstLastSpecialKeys> result;\n+    if (OriginalProto.HasSpecialKeysPayloadData()) {\n+        result = std::make_shared<NArrow::TFirstLastSpecialKeys>(OriginalProto.GetSpecialKeysPayloadData(), schema);\n+    } else if (OriginalProto.HasSpecialKeysRawData()) {\n+        result = std::make_shared<NArrow::TFirstLastSpecialKeys>(OriginalProto.GetSpecialKeysRawData());\n+    } else {\n+        AFL_VERIFY(false);\n+    }\n+    if (AtomicCas(&KeyInitialization, 1, 0)) {\n+        SpecialKeysParsed = result;\n+        KeyInitialized = 1;\n+    }\n+    return result;\n }\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/meta.h b/ydb/core/tx/columnshard/engines/insert_table/meta.h\nindex 085e326d5247..a913e88c973a 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/meta.h\n+++ b/ydb/core/tx/columnshard/engines/insert_table/meta.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <ydb/core/formats/arrow/special_keys.h>\n-#include <ydb/core/formats/arrow/modifier/subset.h>\n+#include <ydb/library/formats/arrow/modifier/subset.h>\n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/engines/defs.h>\n #include <ydb/core/tx/data_events/common/modification_type.h>\n@@ -17,12 +17,12 @@ class TInsertedDataMeta {\n     YDB_READONLY(NEvWrite::EModificationType, ModificationType, NEvWrite::EModificationType::Upsert);\n     YDB_READONLY_DEF(NArrow::TSchemaSubset, SchemaSubset);\n \n-    mutable bool KeysParsed = false;\n-    mutable std::optional<NArrow::TFirstLastSpecialKeys> SpecialKeysParsed;\n-\n+    mutable TAtomicCounter KeyInitialized = 0;\n+    mutable TAtomic KeyInitialization = 0;\n+    mutable std::shared_ptr<NArrow::TFirstLastSpecialKeys> SpecialKeysParsed;\n     NKikimrTxColumnShard::TLogicalMetadata OriginalProto;\n+    std::shared_ptr<NArrow::TFirstLastSpecialKeys> GetSpecialKeys(const std::shared_ptr<arrow::Schema>& schema) const;\n \n-    const std::optional<NArrow::TFirstLastSpecialKeys>& GetSpecialKeys() const;\n public:\n     ui64 GetTxVolume() const {\n         return 2 * sizeof(ui64) + sizeof(ui32) + sizeof(OriginalProto) + (SpecialKeysParsed ? SpecialKeysParsed->GetMemoryBytes() : 0);\n@@ -43,19 +43,13 @@ class TInsertedDataMeta {\n         }\n     }\n \n-    std::optional<NArrow::TReplaceKey> GetFirstPK(const std::shared_ptr<arrow::Schema>& schema) const {\n-        if (GetSpecialKeys()) {\n-            return GetSpecialKeys()->GetFirst(schema);\n-        } else {\n-            return {};\n-        }\n+    NArrow::TReplaceKey GetFirstPK(const std::shared_ptr<arrow::Schema>& schema) const {\n+        AFL_VERIFY(schema);\n+        return GetSpecialKeys(schema)->GetFirst();\n     }\n-    std::optional<NArrow::TReplaceKey> GetLastPK(const std::shared_ptr<arrow::Schema>& schema) const {\n-        if (GetSpecialKeys()) {\n-            return GetSpecialKeys()->GetLast(schema);\n-        } else {\n-            return {};\n-        }\n+    NArrow::TReplaceKey GetLastPK(const std::shared_ptr<arrow::Schema>& schema) const {\n+        AFL_VERIFY(schema);\n+        return GetSpecialKeys(schema)->GetLast();\n     }\n \n     NKikimrTxColumnShard::TLogicalMetadata SerializeToProto() const;\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/path_info.cpp b/ydb/core/tx/columnshard/engines/insert_table/path_info.cpp\nindex 31be2b8a8fa3..d4530b55c481 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/path_info.cpp\n+++ b/ydb/core/tx/columnshard/engines/insert_table/path_info.cpp\n@@ -29,7 +29,7 @@ void TPathInfo::AddInsertedSize(const i64 size, const ui64 overloadLimit) {\n     SetInsertedOverload((ui64)InsertedSize > overloadLimit);\n }\n \n-bool TPathInfo::EraseCommitted(const TInsertedData& data) {\n+bool TPathInfo::EraseCommitted(const TCommittedData& data) {\n     Summary->RemovePriority(*this);\n     const bool result = Committed.erase(data);\n     AddCommittedSize(-1 * (i64)data.BlobSize(), TCompactionLimits::OVERLOAD_INSERT_TABLE_SIZE_BY_PATH_ID);\n@@ -39,11 +39,11 @@ bool TPathInfo::EraseCommitted(const TInsertedData& data) {\n     return result;\n }\n \n-bool TPathInfo::HasCommitted(const TInsertedData& data) {\n+bool TPathInfo::HasCommitted(const TCommittedData& data) {\n     return Committed.contains(data);\n }\n \n-bool TPathInfo::AddCommitted(TInsertedData&& data, const bool load) {\n+bool TPathInfo::AddCommitted(TCommittedData&& data, const bool load) {\n     const ui64 dataSize = data.BlobSize();\n     Summary->RemovePriority(*this);\n     AddCommittedSize(data.BlobSize(), TCompactionLimits::OVERLOAD_INSERT_TABLE_SIZE_BY_PATH_ID);\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/path_info.h b/ydb/core/tx/columnshard/engines/insert_table/path_info.h\nindex 5e44929307c4..8675a05a7d1b 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/path_info.h\n+++ b/ydb/core/tx/columnshard/engines/insert_table/path_info.h\n@@ -1,7 +1,10 @@\n #pragma once\n+#include \"committed.h\"\n+#include \"inserted.h\"\n+\n #include <ydb/core/tx/columnshard/counters/insert_table.h>\n+\n #include <util/generic/noncopyable.h>\n-#include \"data.h\"\n \n namespace NKikimr::NOlap {\n class TInsertionSummary;\n@@ -17,12 +20,11 @@ class TPathInfoIndexPriority {\n private:\n     YDB_READONLY(EIndexationPriority, Category, EIndexationPriority::NoPriority);\n     const ui32 Weight;\n+\n public:\n     TPathInfoIndexPriority(const EIndexationPriority category, const ui32 weight)\n         : Category(category)\n-        , Weight(weight)\n-    {\n-\n+        , Weight(weight) {\n     }\n \n     bool operator!() const {\n@@ -37,7 +39,7 @@ class TPathInfoIndexPriority {\n class TPathInfo: public TMoveOnly {\n private:\n     const ui64 PathId = 0;\n-    TSet<TInsertedData> Committed;\n+    TSet<TCommittedData> Committed;\n     YDB_READONLY(i64, CommittedSize, 0);\n     YDB_READONLY(i64, InsertedSize, 0);\n     bool CommittedOverload = false;\n@@ -51,6 +53,10 @@ class TPathInfo: public TMoveOnly {\n     void AddCommittedSize(const i64 size, const ui64 overloadLimit);\n \n public:\n+    bool IsEmpty() const {\n+        return Committed.empty() && !InsertedSize;\n+    }\n+\n     void AddInsertedSize(const i64 size, const ui64 overloadLimit);\n \n     explicit TPathInfo(TInsertionSummary& summary, const ui64 pathId);\n@@ -61,18 +67,18 @@ class TPathInfo: public TMoveOnly {\n \n     TPathInfoIndexPriority GetIndexationPriority() const;\n \n-    bool EraseCommitted(const TInsertedData& data);\n-    bool HasCommitted(const TInsertedData& data);\n+    bool EraseCommitted(const TCommittedData& data);\n+    bool HasCommitted(const TCommittedData& data);\n \n-    const TSet<TInsertedData>& GetCommitted() const {\n+    const TSet<TCommittedData>& GetCommitted() const {\n         return Committed;\n     }\n \n-    bool AddCommitted(TInsertedData&& data, const bool load = false);\n+    bool AddCommitted(TCommittedData&& data, const bool load = false);\n \n     bool IsOverloaded() const {\n         return CommittedOverload || InsertedOverload;\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.cpp b/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.cpp\nindex cf5c0ceea3f0..6cc6e4872da3 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.cpp\n+++ b/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.cpp\n@@ -23,9 +23,10 @@ void TInsertionSummary::RemovePriority(const TPathInfo& pathInfo) noexcept {\n     const auto priority = pathInfo.GetIndexationPriority();\n     auto it = Priorities.find(priority);\n     if (it == Priorities.end()) {\n-        Y_ABORT_UNLESS(!priority);\n+        AFL_VERIFY(!priority);\n         return;\n     }\n+    AFL_VERIFY(!!priority);\n     Y_ABORT_UNLESS(it->second.erase(&pathInfo) || !priority);\n     if (it->second.empty()) {\n         Priorities.erase(it);\n@@ -33,7 +34,9 @@ void TInsertionSummary::RemovePriority(const TPathInfo& pathInfo) noexcept {\n }\n \n void TInsertionSummary::AddPriority(const TPathInfo& pathInfo) noexcept {\n-    Y_ABORT_UNLESS(Priorities[pathInfo.GetIndexationPriority()].emplace(&pathInfo).second);\n+    if (!!pathInfo.GetIndexationPriority()) {\n+        Y_ABORT_UNLESS(Priorities[pathInfo.GetIndexationPriority()].emplace(&pathInfo).second);\n+    }\n }\n \n NKikimr::NOlap::TPathInfo& TInsertionSummary::GetPathInfo(const ui64 pathId) {\n@@ -44,20 +47,6 @@ NKikimr::NOlap::TPathInfo& TInsertionSummary::GetPathInfo(const ui64 pathId) {\n     return it->second;\n }\n \n-std::optional<NKikimr::NOlap::TPathInfo> TInsertionSummary::ExtractPathInfo(const ui64 pathId) {\n-    auto it = PathInfo.find(pathId);\n-    if (it == PathInfo.end()) {\n-        return {};\n-    }\n-    RemovePriority(it->second);\n-    std::optional<TPathInfo> result = std::move(it->second);\n-    PathInfo.erase(it);\n-    for (auto&& i : result->GetCommitted()) {\n-        OnEraseCommitted(*result, i.BlobSize());\n-    }\n-    return result;\n-}\n-\n NKikimr::NOlap::TPathInfo* TInsertionSummary::GetPathInfoOptional(const ui64 pathId) {\n     auto it = PathInfo.find(pathId);\n     if (it == PathInfo.end()) {\n@@ -100,40 +89,11 @@ void TInsertionSummary::OnEraseInserted(TPathInfo& pathInfo, const ui64 dataSize\n     AFL_VERIFY(Counters.Inserted.GetDataSize() == (i64)StatsPrepared.Bytes);\n }\n \n-THashSet<NKikimr::NOlap::TWriteId> TInsertionSummary::GetInsertedByPathId(const ui64 pathId) const {\n-    THashSet<TWriteId> result;\n-    for (auto& [writeId, data] : Inserted) {\n-        if (data.PathId == pathId) {\n-            result.insert(writeId);\n-        }\n-    }\n-\n-    return result;\n-}\n-\n-THashSet<NKikimr::NOlap::TWriteId> TInsertionSummary::GetExpiredInsertions(const TInstant timeBorder, const ui64 limit) const {\n-    if (timeBorder < MinInsertedTs) {\n-        return {};\n-    }\n-\n-    THashSet<TWriteId> toAbort;\n-    TInstant newMin = TInstant::Max();\n-    for (auto& [writeId, data] : Inserted) {\n-        const TInstant dataInsertTs = data.GetMeta().GetDirtyWriteTime();\n-        if (data.IsNotAbortable()) {\n-            continue;\n-        }\n-        if (dataInsertTs < timeBorder && toAbort.size() < limit) {\n-            toAbort.insert(writeId);\n-        } else {\n-            newMin = Min(newMin, dataInsertTs);\n-        }\n-    }\n-    MinInsertedTs = (toAbort.size() == Inserted.size()) ? TInstant::Zero() : newMin;\n-    return toAbort;\n+THashSet<TInsertWriteId> TInsertionSummary::GetExpiredInsertions(const TInstant timeBorder, const ui64 limit) const {\n+    return Inserted.GetExpired(timeBorder, limit);\n }\n \n-bool TInsertionSummary::EraseAborted(const TWriteId writeId) {\n+bool TInsertionSummary::EraseAborted(const TInsertWriteId writeId) {\n     auto it = Aborted.find(writeId);\n     if (it == Aborted.end()) {\n         return false;\n@@ -143,7 +103,7 @@ bool TInsertionSummary::EraseAborted(const TWriteId writeId) {\n     return true;\n }\n \n-bool TInsertionSummary::HasAborted(const TWriteId writeId) {\n+bool TInsertionSummary::HasAborted(const TInsertWriteId writeId) {\n     auto it = Aborted.find(writeId);\n     if (it == Aborted.end()) {\n         return false;\n@@ -151,8 +111,8 @@ bool TInsertionSummary::HasAborted(const TWriteId writeId) {\n     return true;\n }\n \n-bool TInsertionSummary::EraseCommitted(const TInsertedData& data) {\n-    TPathInfo* pathInfo = GetPathInfoOptional(data.PathId);\n+bool TInsertionSummary::EraseCommitted(const TCommittedData& data) {\n+    TPathInfo* pathInfo = GetPathInfoOptional(data.GetPathId());\n     if (!pathInfo) {\n         Counters.Committed.SkipErase(data.BlobSize());\n         return false;\n@@ -166,8 +126,8 @@ bool TInsertionSummary::EraseCommitted(const TInsertedData& data) {\n     }\n }\n \n-bool TInsertionSummary::HasCommitted(const TInsertedData& data) {\n-    TPathInfo* pathInfo = GetPathInfoOptional(data.PathId);\n+bool TInsertionSummary::HasCommitted(const TCommittedData& data) {\n+    TPathInfo* pathInfo = GetPathInfoOptional(data.GetPathId());\n     if (!pathInfo) {\n         return false;\n     }\n@@ -175,40 +135,30 @@ bool TInsertionSummary::HasCommitted(const TInsertedData& data) {\n }\n \n const NKikimr::NOlap::TInsertedData* TInsertionSummary::AddAborted(TInsertedData&& data, const bool load /*= false*/) {\n-    const TWriteId writeId((TWriteId)data.WriteTxId);\n+    const TInsertWriteId writeId = data.GetInsertWriteId();\n     Counters.Aborted.Add(data.BlobSize(), load);\n+    AFL_VERIFY_DEBUG(!Inserted.contains(writeId));\n     auto insertInfo = Aborted.emplace(writeId, std::move(data));\n-    Y_ABORT_UNLESS(insertInfo.second);\n+    AFL_VERIFY(insertInfo.second)(\"write_id\", writeId);\n     return &insertInfo.first->second;\n }\n \n-std::optional<NKikimr::NOlap::TInsertedData> TInsertionSummary::ExtractInserted(const TWriteId id) {\n-    auto it = Inserted.find(id);\n-    if (it == Inserted.end()) {\n-        return {};\n-    } else {\n-        auto pathInfo = GetPathInfoOptional(it->second.PathId);\n+std::optional<NKikimr::NOlap::TInsertedData> TInsertionSummary::ExtractInserted(const TInsertWriteId id) {\n+    auto result = Inserted.ExtractOptional(id);\n+    if (result) {\n+        auto pathInfo = GetPathInfoOptional(result->GetPathId());\n         if (pathInfo) {\n-            OnEraseInserted(*pathInfo, it->second.BlobSize());\n+            OnEraseInserted(*pathInfo, result->BlobSize());\n         }\n-        std::optional<TInsertedData> result = std::move(it->second);\n-        Inserted.erase(it);\n-        return result;\n     }\n+    return result;\n }\n \n const NKikimr::NOlap::TInsertedData* TInsertionSummary::AddInserted(TInsertedData&& data, const bool load /*= false*/) {\n-    TWriteId writeId{ data.WriteTxId };\n-    const ui32 dataSize = data.BlobSize();\n-    const ui64 pathId = data.PathId;\n-    auto insertInfo = Inserted.emplace(writeId, std::move(data));\n-    if (insertInfo.second) {\n-        OnNewInserted(GetPathInfo(pathId), dataSize, load);\n-        return &insertInfo.first->second;\n-    } else {\n-        Counters.Inserted.SkipAdd(dataSize);\n-        return nullptr;\n-    }\n+    auto* insertInfo = Inserted.AddVerified(std::move(data));\n+    AFL_VERIFY_DEBUG(!Aborted.contains(insertInfo->GetInsertWriteId()));\n+    OnNewInserted(GetPathInfo(insertInfo->GetPathId()), insertInfo->BlobSize(), load);\n+    return insertInfo;\n }\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.h b/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.h\nindex 880def7bc45f..67e8034628c8 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.h\n+++ b/ydb/core/tx/columnshard/engines/insert_table/rt_insertion.h\n@@ -1,10 +1,121 @@\n #pragma once\n+#include \"inserted.h\"\n+#include \"path_info.h\"\n+\n #include <ydb/core/tx/columnshard/counters/insert_table.h>\n+\n #include <ydb/library/accessor/accessor.h>\n-#include \"path_info.h\"\n \n namespace NKikimr::NOlap {\n class IBlobsDeclareRemovingAction;\n+\n+class TInsertedDataInstant {\n+private:\n+    const TInsertedData* Data;\n+    const TInstant WriteTime;\n+\n+public:\n+    TInsertedDataInstant(const TInsertedData& data)\n+        : Data(&data)\n+        , WriteTime(Data->GetMeta().GetDirtyWriteTime())\n+    {\n+\n+    }\n+\n+    const TInsertedData& GetData() const {\n+        return *Data;\n+    }\n+    TInstant GetWriteTime() const {\n+        return WriteTime;\n+    }\n+\n+    bool operator<(const TInsertedDataInstant& item) const {\n+        if (WriteTime == item.WriteTime) {\n+            return Data->GetInsertWriteId() < item.Data->GetInsertWriteId();\n+        } else {\n+            return WriteTime < item.WriteTime;\n+        }\n+    }\n+};\n+\n+class TInsertedContainer {\n+private:\n+    THashMap<TInsertWriteId, TInsertedData> Inserted;\n+    std::set<TInsertedDataInstant> InsertedByWriteTime;\n+\n+public:\n+    size_t size() const {\n+        return Inserted.size();\n+    }\n+\n+    bool contains(const TInsertWriteId id) const {\n+        return Inserted.contains(id);\n+    }\n+\n+    THashMap<TInsertWriteId, TInsertedData>::const_iterator begin() const {\n+        return Inserted.begin();\n+    }\n+\n+    THashMap<TInsertWriteId, TInsertedData>::const_iterator end() const {\n+        return Inserted.end();\n+    }\n+\n+    THashSet<TInsertWriteId> GetExpired(const TInstant timeBorder, const ui64 limit) const {\n+        THashSet<TInsertWriteId> result;\n+        for (auto& data : InsertedByWriteTime) {\n+            if (timeBorder < data.GetWriteTime()) {\n+                break;\n+            }\n+            if (data.GetData().IsNotAbortable()) {\n+                continue;\n+            }\n+            result.emplace(data.GetData().GetInsertWriteId());\n+            if (limit <= result.size()) {\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    TInsertedData* AddVerified(TInsertedData&& data) {\n+        const TInsertWriteId writeId = data.GetInsertWriteId();\n+        auto itInsertion = Inserted.emplace(writeId, std::move(data));\n+        AFL_VERIFY(itInsertion.second);\n+        auto* dataPtr = &itInsertion.first->second;\n+        InsertedByWriteTime.emplace(TInsertedDataInstant(*dataPtr));\n+        return dataPtr;\n+    }\n+\n+    const TInsertedData* GetOptional(const TInsertWriteId id) const {\n+        auto it = Inserted.find(id);\n+        if (it == Inserted.end()) {\n+            return nullptr;\n+        } else {\n+            return &it->second;\n+        }\n+    }\n+\n+    TInsertedData* MutableOptional(const TInsertWriteId id) {\n+        auto it = Inserted.find(id);\n+        if (it == Inserted.end()) {\n+            return nullptr;\n+        } else {\n+            return &it->second;\n+        }\n+    }\n+\n+    std::optional<TInsertedData> ExtractOptional(const TInsertWriteId id) {\n+        auto it = Inserted.find(id);\n+        if (it == Inserted.end()) {\n+            return std::nullopt;\n+        }\n+        AFL_VERIFY(InsertedByWriteTime.erase(TInsertedDataInstant(it->second)));\n+        TInsertedData result = std::move(it->second);\n+        Inserted.erase(it);\n+        return result;\n+    }\n+};\n+\n class TInsertionSummary {\n public:\n     struct TCounters {\n@@ -19,9 +130,8 @@ class TInsertionSummary {\n     TCounters StatsCommitted;\n     const NColumnShard::TInsertTableCounters Counters;\n \n-    THashMap<TWriteId, TInsertedData> Inserted;\n-    THashMap<TWriteId, TInsertedData> Aborted;\n-    mutable TInstant MinInsertedTs = TInstant::Zero();\n+    TInsertedContainer Inserted;\n+    THashMap<TInsertWriteId, TInsertedData> Aborted;\n \n     std::map<TPathInfoIndexPriority, std::set<const TPathInfo*>> Priorities;\n     THashMap<ui64, TPathInfo> PathInfo;\n@@ -33,43 +143,63 @@ class TInsertionSummary {\n     void OnNewInserted(TPathInfo& pathInfo, const ui64 dataSize, const bool load) noexcept;\n     void OnEraseInserted(TPathInfo& pathInfo, const ui64 dataSize) noexcept;\n     static TAtomicCounter CriticalInserted;\n+\n public:\n-    void MarkAsNotAbortable(const TWriteId writeId) {\n-        auto it = Inserted.find(writeId);\n-        if (it == Inserted.end()) {\n+    bool HasPathIdData(const ui64 pathId) const {\n+        auto it = PathInfo.find(pathId);\n+        if (it == PathInfo.end()) {\n+            return false;\n+        }\n+        return !it->second.IsEmpty();\n+    }\n+\n+    void ErasePath(const ui64 pathId) {\n+        auto it = PathInfo.find(pathId);\n+        if (it == PathInfo.end()) {\n             return;\n         }\n-        it->second.MarkAsNotAbortable();\n+        RemovePriority(it->second);\n+        AFL_VERIFY(it->second.IsEmpty());\n+        PathInfo.erase(it);\n     }\n \n-    THashSet<TWriteId> GetInsertedByPathId(const ui64 pathId) const;\n+    void MarkAsNotAbortable(const TInsertWriteId writeId) {\n+        auto* data = Inserted.MutableOptional(writeId);\n+        if (!data) {\n+            return;\n+        }\n+        data->MarkAsNotAbortable();\n+    }\n \n-    THashSet<TWriteId> GetExpiredInsertions(const TInstant timeBorder, const ui64 limit) const;\n+    THashSet<TInsertWriteId> GetExpiredInsertions(const TInstant timeBorder, const ui64 limit) const;\n \n-    const THashMap<TWriteId, TInsertedData>& GetInserted() const {\n+    const TInsertedContainer& GetInserted() const {\n         return Inserted;\n     }\n-    const THashMap<TWriteId, TInsertedData>& GetAborted() const {\n+    const THashMap<TInsertWriteId, TInsertedData>& GetAborted() const {\n         return Aborted;\n     }\n \n     const TInsertedData* AddAborted(TInsertedData&& data, const bool load = false);\n-    bool EraseAborted(const TWriteId writeId);\n-    bool HasAborted(const TWriteId writeId);\n+    bool EraseAborted(const TInsertWriteId writeId);\n+    bool HasAborted(const TInsertWriteId writeId);\n \n-    bool EraseCommitted(const TInsertedData& data);\n-    bool HasCommitted(const TInsertedData& data);\n+    bool EraseCommitted(const TCommittedData& data);\n+    bool HasCommitted(const TCommittedData& data);\n \n     const TInsertedData* AddInserted(TInsertedData&& data, const bool load = false);\n-    std::optional<TInsertedData> ExtractInserted(const TWriteId id);\n+    std::optional<TInsertedData> ExtractInserted(const TInsertWriteId id);\n \n-    const TCounters& GetCountersPrepared() const { return StatsPrepared; }\n-    const TCounters& GetCountersCommitted() const { return StatsCommitted; }\n+    const TCounters& GetCountersPrepared() const {\n+        return StatsPrepared;\n+    }\n+    const TCounters& GetCountersCommitted() const {\n+        return StatsCommitted;\n+    }\n     const NColumnShard::TInsertTableCounters& GetCounters() const {\n         return Counters;\n     }\n     NKikimr::NOlap::TPathInfo& GetPathInfo(const ui64 pathId);\n-    std::optional<TPathInfo> ExtractPathInfo(const ui64 pathId);\n     TPathInfo* GetPathInfoOptional(const ui64 pathId);\n     const TPathInfo* GetPathInfoOptional(const ui64 pathId) const;\n \n@@ -84,4 +214,4 @@ class TInsertionSummary {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/data.cpp b/ydb/core/tx/columnshard/engines/insert_table/user_data.cpp\nsimilarity index 55%\nrename from ydb/core/tx/columnshard/engines/insert_table/data.cpp\nrename to ydb/core/tx/columnshard/engines/insert_table/user_data.cpp\nindex 36c17ba89779..f5d3db9d71d7 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/data.cpp\n+++ b/ydb/core/tx/columnshard/engines/insert_table/user_data.cpp\n@@ -1,4 +1,4 @@\n-#include \"data.h\"\n+#include \"user_data.h\"\n #include <ydb/library/actors/core/log.h>\n \n namespace NKikimr::NOlap {\n@@ -27,27 +27,18 @@ class TInsertTableCacheController {\n \n }\n \n-TInsertedData::TBlobStorageGuard::~TBlobStorageGuard() {\n+TUserData::TBlobStorageGuard::~TBlobStorageGuard() {\n     Singleton<TInsertTableCacheController>()->Return(Data.size());\n }\n \n-TInsertedData::~TInsertedData() {\n-}\n-\n-TInsertedData::TInsertedData(ui64 planStep, ui64 writeTxId, ui64 pathId, TString dedupId, const TBlobRange& blobRange,\n-    const NKikimrTxColumnShard::TLogicalMetadata& proto, const ui64 schemaVersion, const std::optional<TString>& blobData)\n+ TUserData::TUserData(const ui64 pathId, const TBlobRange& blobRange, const NKikimrTxColumnShard::TLogicalMetadata& proto,\n+    const ui64 schemaVersion, const std::optional<TString>& blobData)\n     : Meta(proto)\n     , BlobRange(blobRange)\n-    , PlanStep(planStep)\n-    , WriteTxId(writeTxId)\n     , PathId(pathId)\n-    , DedupId(dedupId)\n     , SchemaVersion(schemaVersion) {\n-    if (blobData) {\n-        AFL_VERIFY(blobData->size() == BlobRange.Size);\n-        if (Singleton<TInsertTableCacheController>()->Take(blobData->size())) {\n-            BlobDataGuard = std::make_shared<TBlobStorageGuard>(*blobData);\n-        }\n+    if (blobData && Singleton<TInsertTableCacheController>()->Take(blobData->size())) {\n+        BlobDataGuard = std::make_shared<TBlobStorageGuard>(*blobData);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/user_data.h b/ydb/core/tx/columnshard/engines/insert_table/user_data.h\nnew file mode 100644\nindex 000000000000..d734d90524eb\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/insert_table/user_data.h\n@@ -0,0 +1,100 @@\n+#pragma once\n+#include \"meta.h\"\n+\n+#include <ydb/core/tx/columnshard/common/blob.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+\n+namespace NKikimr::NOlap {\n+\n+class TUserData {\n+private:\n+    TInsertedDataMeta Meta;\n+    YDB_READONLY_DEF(TBlobRange, BlobRange);\n+    class TBlobStorageGuard {\n+    private:\n+        YDB_READONLY_DEF(TString, Data);\n+\n+    public:\n+        TBlobStorageGuard(const TString& data)\n+            : Data(data) {\n+        }\n+        ~TBlobStorageGuard();\n+    };\n+\n+    std::shared_ptr<TBlobStorageGuard> BlobDataGuard;\n+    YDB_READONLY(ui64, PathId, 0);\n+    YDB_READONLY(ui64, SchemaVersion, 0);\n+\n+public:\n+    TUserData() = delete;\n+    TUserData(const ui64 pathId, const TBlobRange& blobRange, const NKikimrTxColumnShard::TLogicalMetadata& proto, const ui64 schemaVersion,\n+        const std::optional<TString>& blobData);\n+\n+    static std::shared_ptr<TUserData> Build(const ui64 pathId, const TBlobRange& blobRange, const NKikimrTxColumnShard::TLogicalMetadata& proto, const ui64 schemaVersion,\n+        const std::optional<TString>& blobData) {\n+        return std::make_shared<TUserData>(pathId, blobRange, proto, schemaVersion, blobData);\n+    }\n+\n+    static std::shared_ptr<TUserData> Build(const ui64 pathId, const TUnifiedBlobId& blobId, const NKikimrTxColumnShard::TLogicalMetadata& proto, const ui64 schemaVersion,\n+        const std::optional<TString>& blobData) {\n+        return std::make_shared<TUserData>(pathId, TBlobRange(blobId), proto, schemaVersion, blobData);\n+    }\n+\n+    std::optional<TString> GetBlobData() const {\n+        if (BlobDataGuard) {\n+            return BlobDataGuard->GetData();\n+        } else {\n+            return std::nullopt;\n+        }\n+    }\n+\n+    ui64 GetTxVolume() const {\n+        return Meta.GetTxVolume() + sizeof(TBlobRange);\n+    }\n+\n+    const TInsertedDataMeta& GetMeta() const {\n+        return Meta;\n+    }\n+};\n+\n+class TUserDataContainer {\n+protected:\n+    std::shared_ptr<TUserData> UserData;\n+\n+public:\n+    TUserDataContainer(const std::shared_ptr<TUserData>& userData)\n+        : UserData(userData) {\n+        AFL_VERIFY(UserData);\n+    }\n+\n+    ui64 GetSchemaVersion() const {\n+        return UserData->GetSchemaVersion();\n+    }\n+\n+    ui32 BlobSize() const {\n+        return GetBlobRange().Size;\n+    }\n+\n+    ui32 GetTxVolume() const {\n+        return UserData->GetTxVolume();\n+    }\n+\n+    ui64 GetPathId() const {\n+        return UserData->GetPathId();\n+    }\n+\n+    const TBlobRange& GetBlobRange() const {\n+        return UserData->GetBlobRange();\n+    }\n+\n+    std::optional<TString> GetBlobData() const {\n+        return UserData->GetBlobData();\n+    }\n+\n+    const TInsertedDataMeta& GetMeta() const {\n+        return UserData->GetMeta();\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/insert_table/ya.make b/ydb/core/tx/columnshard/engines/insert_table/ya.make\nindex fd56354b62e6..e6fde75077d5 100644\n--- a/ydb/core/tx/columnshard/engines/insert_table/ya.make\n+++ b/ydb/core/tx/columnshard/engines/insert_table/ya.make\n@@ -3,14 +3,16 @@ LIBRARY()\n SRCS(\n     insert_table.cpp\n     rt_insertion.cpp\n-    data.cpp\n+    user_data.cpp\n+    inserted.cpp\n+    committed.cpp\n     path_info.cpp\n     meta.cpp\n )\n \n PEERDIR(\n     contrib/libs/apache/arrow\n-    ydb/core/formats/arrow/modifier\n+    ydb/library/formats/arrow/modifier\n     ydb/core/protos\n     ydb/core/formats/arrow\n     ydb/core/tablet_flat\ndiff --git a/ydb/core/tx/columnshard/engines/portions/column_record.cpp b/ydb/core/tx/columnshard/engines/portions/column_record.cpp\nindex e4fbef70c5fc..6127ad439326 100644\n--- a/ydb/core/tx/columnshard/engines/portions/column_record.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/column_record.cpp\n@@ -28,7 +28,7 @@ TChunkMeta::TChunkMeta(const TColumnChunkLoadContext& context, const TSimpleColu\n     DeserializeFromProto(context.GetAddress(), context.GetMetaProto(), columnInfo).Validate();\n }\n \n-TChunkMeta::TChunkMeta(const std::shared_ptr<arrow::Array>& column, const TSimpleColumnInfo& columnInfo)\n+TChunkMeta::TChunkMeta(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const TSimpleColumnInfo& columnInfo)\n     : TBase(column, columnInfo.GetNeedMinMax(), columnInfo.GetIsSorted())\n {\n }\n@@ -52,7 +52,8 @@ TColumnRecord::TColumnRecord(const TBlobRangeLink16::TLinkId blobLinkId, const T\n {\n }\n \n-TColumnRecord::TColumnRecord(const TChunkAddress& address, const std::shared_ptr<arrow::Array>& column, const TSimpleColumnInfo& columnInfo)\n+TColumnRecord::TColumnRecord(\n+    const TChunkAddress& address, const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const TSimpleColumnInfo& columnInfo)\n     : Meta(column, columnInfo)\n     , ColumnId(address.GetColumnId())\n     , Chunk(address.GetChunk())\ndiff --git a/ydb/core/tx/columnshard/engines/portions/column_record.h b/ydb/core/tx/columnshard/engines/portions/column_record.h\nindex 0109b372f302..18fd0984d61b 100644\n--- a/ydb/core/tx/columnshard/engines/portions/column_record.h\n+++ b/ydb/core/tx/columnshard/engines/portions/column_record.h\n@@ -2,20 +2,19 @@\n \n #include \"common.h\"\n \n-#include <ydb/core/tx/columnshard/engines/protos/portion_info.pb.h>\n-\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/formats/arrow/splitter/stats.h>\n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n-#include <ydb/core/tx/columnshard/splitter/stats.h>\n-#include <ydb/core/tx/columnshard/splitter/chunks.h>\n+#include <ydb/core/tx/columnshard/engines/protos/portion_info.pb.h>\n #include <ydb/core/tx/columnshard/splitter/chunk_meta.h>\n+#include <ydb/core/tx/columnshard/splitter/chunks.h>\n \n #include <ydb/library/accessor/accessor.h>\n \n-#include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n-\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n #include <util/string/builder.h>\n \n namespace NKikimrColumnShardDataSharingProto {\n@@ -31,16 +30,17 @@ struct TChunkMeta: public TSimpleChunkMeta {\n private:\n     using TBase = TSimpleChunkMeta;\n     TChunkMeta() = default;\n-    [[nodiscard]] TConclusionStatus DeserializeFromProto(const TChunkAddress& address, const NKikimrTxColumnShard::TIndexColumnMeta& proto, const TSimpleColumnInfo& columnInfo);\n+    [[nodiscard]] TConclusionStatus DeserializeFromProto(\n+        const TChunkAddress& address, const NKikimrTxColumnShard::TIndexColumnMeta& proto, const TSimpleColumnInfo& columnInfo);\n     friend class TColumnRecord;\n+\n public:\n     TChunkMeta(TSimpleChunkMeta&& baseMeta)\n-        : TBase(baseMeta)\n-    {\n-\n+        : TBase(baseMeta) {\n     }\n \n-    [[nodiscard]] static TConclusion<TChunkMeta> BuildFromProto(const TChunkAddress& address, const NKikimrTxColumnShard::TIndexColumnMeta& proto, const TSimpleColumnInfo& columnInfo) {\n+    [[nodiscard]] static TConclusion<TChunkMeta> BuildFromProto(\n+        const TChunkAddress& address, const NKikimrTxColumnShard::TIndexColumnMeta& proto, const TSimpleColumnInfo& columnInfo) {\n         TChunkMeta result;\n         auto parse = result.DeserializeFromProto(address, proto, columnInfo);\n         if (!parse) {\n@@ -63,20 +63,19 @@ struct TChunkMeta: public TSimpleChunkMeta {\n \n     TChunkMeta(const TColumnChunkLoadContext& context, const TSimpleColumnInfo& columnInfo);\n \n-    TChunkMeta(const std::shared_ptr<arrow::Array>& column, const TSimpleColumnInfo& columnInfo);\n+    TChunkMeta(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const TSimpleColumnInfo& columnInfo);\n };\n \n class TColumnRecord {\n private:\n     TChunkMeta Meta;\n     TColumnRecord(TChunkMeta&& meta)\n-        : Meta(std::move(meta))\n-    {\n-\n+        : Meta(std::move(meta)) {\n     }\n \n     TColumnRecord() = default;\n     TConclusionStatus DeserializeFromProto(const NKikimrColumnShardDataSharingProto::TColumnRecord& proto, const TSimpleColumnInfo& columnInfo);\n+\n public:\n     ui32 ColumnId = 0;\n     ui16 Chunk = 0;\n@@ -99,9 +98,7 @@ class TColumnRecord {\n         : Meta(std::move(meta))\n         , ColumnId(address.GetColumnId())\n         , Chunk(address.GetChunk())\n-        , BlobRange(range)\n-    {\n-\n+        , BlobRange(range) {\n     }\n \n     class TTestInstanceBuilder {\n@@ -116,7 +113,7 @@ class TColumnRecord {\n         }\n     };\n \n-    ui32 GetColumnId() const { \n+    ui32 GetColumnId() const {\n         return ColumnId;\n     }\n     ui16 GetChunkIdx() const {\n@@ -127,7 +124,8 @@ class TColumnRecord {\n     }\n \n     NKikimrColumnShardDataSharingProto::TColumnRecord SerializeToProto() const;\n-    static TConclusion<TColumnRecord> BuildFromProto(const NKikimrColumnShardDataSharingProto::TColumnRecord& proto, const TSimpleColumnInfo& columnInfo) {\n+    static TConclusion<TColumnRecord> BuildFromProto(\n+        const NKikimrColumnShardDataSharingProto::TColumnRecord& proto, const TSimpleColumnInfo& columnInfo) {\n         TColumnRecord result;\n         auto parse = result.DeserializeFromProto(proto, columnInfo);\n         if (!parse) {\n@@ -136,14 +134,14 @@ class TColumnRecord {\n         return result;\n     }\n \n-    TColumnSerializationStat GetSerializationStat(const std::string& columnName) const {\n-        TColumnSerializationStat result(ColumnId, columnName);\n+    NArrow::NSplitter::TColumnSerializationStat GetSerializationStat(const std::string& columnName) const {\n+        NArrow::NSplitter::TColumnSerializationStat result(ColumnId, columnName);\n         result.Merge(GetSerializationStat());\n         return result;\n     }\n \n-    TSimpleSerializationStat GetSerializationStat() const {\n-        return TSimpleSerializationStat(BlobRange.Size, Meta.GetNumRows(), Meta.GetRawBytes());\n+    NArrow::NSplitter::TSimpleSerializationStat GetSerializationStat() const {\n+        return NArrow::NSplitter::TSimpleSerializationStat(BlobRange.Size, Meta.GetNumRows(), Meta.GetRawBytes());\n     }\n \n     const TChunkMeta& GetMeta() const {\n@@ -163,18 +161,17 @@ class TColumnRecord {\n     }\n \n     TString DebugString() const {\n-        return TStringBuilder()\n-            << \"column_id:\" << ColumnId << \";\"\n-            << \"chunk_idx:\" << Chunk << \";\"\n-            << \"blob_range:\" << BlobRange.ToString() << \";\"\n-            ;\n+        return TStringBuilder() << \"column_id:\" << ColumnId << \";\"\n+                                << \"chunk_idx:\" << Chunk << \";\"\n+                                << \"blob_range:\" << BlobRange.ToString() << \";\";\n     }\n \n-    TColumnRecord(const TChunkAddress& address, const std::shared_ptr<arrow::Array>& column, const TSimpleColumnInfo& columnInfo);\n+    TColumnRecord(\n+        const TChunkAddress& address, const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const TSimpleColumnInfo& columnInfo);\n \n     TColumnRecord(const TBlobRangeLink16::TLinkId blobLinkId, const TColumnChunkLoadContext& loadContext, const TSimpleColumnInfo& columnInfo);\n \n-    friend IOutputStream& operator << (IOutputStream& out, const TColumnRecord& rec) {\n+    friend IOutputStream& operator<<(IOutputStream& out, const TColumnRecord& rec) {\n         out << '{';\n         if (rec.Chunk) {\n             out << 'n' << rec.Chunk;\n@@ -186,52 +183,4 @@ class TColumnRecord {\n     }\n };\n \n-class TSimpleOrderedColumnChunk: public IPortionColumnChunk {\n-private:\n-    using TBase = IPortionColumnChunk;\n-    const TColumnRecord ColumnRecord;\n-    YDB_READONLY_DEF(TString, Data);\n-protected:\n-    virtual TString DoDebugString() const override {\n-        TStringBuilder sb;\n-        sb << \"column_id=\" << GetColumnId() << \";data_size=\" << Data.size() << \";\";\n-        if (GetChunkIdxOptional()) {\n-            sb << \"chunk=\" << GetChunkIdxVerified() << \";\";\n-        } else {\n-            sb << \"chunk=NO_INITIALIZED;\";\n-        }\n-        return sb;\n-    }\n-\n-    virtual const TString& DoGetData() const override {\n-        return Data;\n-    }\n-    virtual ui64 DoGetRawBytesImpl() const override {\n-        return ColumnRecord.GetMeta().GetRawBytes();\n-    }\n-    virtual ui32 DoGetRecordsCountImpl() const override {\n-        return ColumnRecord.GetMeta().GetNumRows();\n-    }\n-    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplitImpl(const TColumnSaver& /*saver*/, const std::shared_ptr<NColumnShard::TSplitterCounters>& /*counters*/,\n-                                                                                const std::vector<ui64>& /*splitSizes*/) const override {\n-        Y_ABORT_UNLESS(false);\n-        return {};\n-    }\n-    virtual TSimpleChunkMeta DoBuildSimpleChunkMeta() const override {\n-        return ColumnRecord.GetMeta();\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetFirstScalar() const override {\n-        return nullptr;\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetLastScalar() const override {\n-        return nullptr;\n-    }\n-public:\n-    TSimpleOrderedColumnChunk(const TColumnRecord& cRecord, const TString& data)\n-        : TBase(cRecord.ColumnId, cRecord.Chunk)\n-        , ColumnRecord(cRecord)\n-        , Data(data) {\n-    }\n-};\n-\n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/portions/common.h b/ydb/core/tx/columnshard/engines/portions/common.h\nindex 1231a1e9f5f3..3702887ccc81 100644\n--- a/ydb/core/tx/columnshard/engines/portions/common.h\n+++ b/ydb/core/tx/columnshard/engines/portions/common.h\n@@ -1,7 +1,9 @@\n #pragma once\n #include <ydb/library/accessor/accessor.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n \n namespace NKikimr::NOlap {\n+using TColumnSaver = NArrow::NAccessor::TColumnSaver;\n \n class TChunkAddress {\n private:\ndiff --git a/ydb/core/tx/columnshard/engines/portions/constructor.cpp b/ydb/core/tx/columnshard/engines/portions/constructor.cpp\nindex 56575c60d54b..39cd0fe983dc 100644\n--- a/ydb/core/tx/columnshard/engines/portions/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/constructor.cpp\n@@ -67,22 +67,6 @@ void TPortionInfoConstructor::LoadIndex(const TIndexChunkLoadContext& loadContex\n \n const NKikimr::NOlap::TColumnRecord& TPortionInfoConstructor::AppendOneChunkColumn(TColumnRecord&& record) {\n     Y_ABORT_UNLESS(record.ColumnId);\n-    std::optional<ui32> maxChunk;\n-    for (auto&& i : Records) {\n-        if (i.ColumnId == record.ColumnId) {\n-            if (!maxChunk) {\n-                maxChunk = i.Chunk;\n-            } else {\n-                Y_ABORT_UNLESS(*maxChunk + 1 == i.Chunk);\n-                maxChunk = i.Chunk;\n-            }\n-        }\n-    }\n-    if (maxChunk) {\n-        AFL_VERIFY(*maxChunk + 1 == record.Chunk)(\"max\", *maxChunk)(\"record\", record.Chunk);\n-    } else {\n-        AFL_VERIFY(0 == record.Chunk)(\"record\", record.Chunk);\n-    }\n     Records.emplace_back(std::move(record));\n     return Records.back();\n }\ndiff --git a/ydb/core/tx/columnshard/engines/portions/constructor_meta.cpp b/ydb/core/tx/columnshard/engines/portions/constructor_meta.cpp\nindex 8c6c375305ca..fa21c6feeeb6 100644\n--- a/ydb/core/tx/columnshard/engines/portions/constructor_meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/constructor_meta.cpp\n@@ -51,7 +51,7 @@ TPortionMeta TPortionMetaConstructor::Build() {\n \n bool TPortionMetaConstructor::LoadMetadata(const NKikimrTxColumnShard::TIndexPortionMeta& portionMeta, const TIndexInfo& indexInfo) {\n     if (!!Produced) {\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"DeserializeFromProto\")(\"error\", \"parsing duplication\");\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"DeserializeFromProto\")(\"error\", \"parsing duplication\");\n         return true;\n     }\n     if (portionMeta.GetTierName()) {\ndiff --git a/ydb/core/tx/columnshard/engines/portions/index_chunk.h b/ydb/core/tx/columnshard/engines/portions/index_chunk.h\nindex 1fe92adfb539..65e0855d5eef 100644\n--- a/ydb/core/tx/columnshard/engines/portions/index_chunk.h\n+++ b/ydb/core/tx/columnshard/engines/portions/index_chunk.h\n@@ -6,7 +6,6 @@\n \n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n-#include <ydb/core/tx/columnshard/splitter/stats.h>\n #include <ydb/core/tx/columnshard/splitter/chunks.h>\n \n #include <ydb/library/accessor/accessor.h>\ndiff --git a/ydb/core/tx/columnshard/engines/portions/meta.cpp b/ydb/core/tx/columnshard/engines/portions/meta.cpp\nindex e585d6a88baf..9d7e374ec8f1 100644\n--- a/ydb/core/tx/columnshard/engines/portions/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/meta.cpp\n@@ -33,7 +33,7 @@ NKikimrTxColumnShard::TIndexPortionMeta TPortionMeta::SerializeToProto() const {\n             break;\n     }\n \n-    portionMeta.SetPrimaryKeyBorders(ReplaceKeyEdges.SerializeToStringDataOnlyNoCompression());\n+    portionMeta.SetPrimaryKeyBorders(ReplaceKeyEdges.SerializePayloadToString());\n \n     RecordSnapshotMin.SerializeToProto(*portionMeta.MutableRecordSnapshotMin());\n     RecordSnapshotMax.SerializeToProto(*portionMeta.MutableRecordSnapshotMax());\ndiff --git a/ydb/core/tx/columnshard/engines/portions/meta.h b/ydb/core/tx/columnshard/engines/portions/meta.h\nindex 9c2e5cd332d3..ad57ef1325c3 100644\n--- a/ydb/core/tx/columnshard/engines/portions/meta.h\n+++ b/ydb/core/tx/columnshard/engines/portions/meta.h\n@@ -2,7 +2,7 @@\n #include <ydb/core/tx/columnshard/common/portion.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/engines/protos/portion_info.pb.h>\n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/core/formats/arrow/special_keys.h>\n #include <ydb/library/accessor/accessor.h>\n #include <util/stream/output.h>\ndiff --git a/ydb/core/tx/columnshard/engines/portions/portion_info.cpp b/ydb/core/tx/columnshard/engines/portions/portion_info.cpp\nindex b89b63e97b5c..6652bf9c4c5f 100644\n--- a/ydb/core/tx/columnshard/engines/portions/portion_info.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/portion_info.cpp\n@@ -7,9 +7,11 @@\n #include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n #include <ydb/core/tx/columnshard/engines/storage/chunks/column.h>\n #include <ydb/core/tx/columnshard/engines/storage/chunks/data.h>\n+#include <ydb/library/formats/arrow/accessor/composite/accessor.h>\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n #include <ydb/core/formats/arrow/arrow_filter.h>\n #include <ydb/core/formats/arrow/size_calcer.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n \n #include <util/system/tls.h>\n \n@@ -30,38 +32,57 @@ std::shared_ptr<arrow::Scalar> TPortionInfo::MaxValue(ui32 columnId) const {\n     return result;\n }\n \n-ui64 TPortionInfo::GetColumnRawBytes(const std::vector<ui32>& columnIds, const bool validation) const {\n-    return GetColumnRawBytes(std::set<ui32>(columnIds.begin(), columnIds.end()), validation);\n+ui64 TPortionInfo::GetColumnRawBytes(const std::set<ui32>& entityIds, const bool validation) const {\n+    ui64 sum = 0;\n+    const auto aggr = [&](const TColumnRecord& r) {\n+        sum += r.GetMeta().GetRawBytes();\n+    };\n+    AggregateIndexChunksData(aggr, Records, &entityIds, validation);\n+    return sum;\n }\n \n-ui64 TPortionInfo::GetColumnRawBytes(const std::optional<std::set<ui32>>& entityIds, const bool validation) const {\n+ui64 TPortionInfo::GetColumnBlobBytes(const std::set<ui32>& entityIds, const bool validation) const {\n+    ui64 sum = 0;\n+    const auto aggr = [&](const TColumnRecord& r) {\n+        sum += r.GetBlobRange().GetSize();\n+    };\n+    AggregateIndexChunksData(aggr, Records, &entityIds, validation);\n+    return sum;\n+}\n+\n+ui64 TPortionInfo::GetColumnRawBytes(const bool validation) const {\n     ui64 sum = 0;\n     const auto aggr = [&](const TColumnRecord& r) {\n         sum += r.GetMeta().GetRawBytes();\n     };\n-    AggregateIndexChunksData(aggr, Records, entityIds, validation);\n+    AggregateIndexChunksData(aggr, Records, nullptr, validation);\n     return sum;\n }\n \n-ui64 TPortionInfo::GetColumnBlobBytes(const std::optional<std::set<ui32>>& entityIds, const bool validation) const {\n+ui64 TPortionInfo::GetColumnBlobBytes(const bool validation) const {\n     ui64 sum = 0;\n     const auto aggr = [&](const TColumnRecord& r) {\n         sum += r.GetBlobRange().GetSize();\n     };\n-    AggregateIndexChunksData(aggr, Records, entityIds, validation);\n+    AggregateIndexChunksData(aggr, Records, nullptr, validation);\n     return sum;\n }\n \n-ui64 TPortionInfo::GetColumnBlobBytes(const std::vector<ui32>& columnIds, const bool validation) const {\n-    return GetColumnBlobBytes(std::set<ui32>(columnIds.begin(), columnIds.end()), validation);\n+ui64 TPortionInfo::GetIndexRawBytes(const std::set<ui32>& entityIds, const bool validation) const {\n+    ui64 sum = 0;\n+    const auto aggr = [&](const TIndexChunk& r) {\n+        sum += r.GetRawBytes();\n+    };\n+    AggregateIndexChunksData(aggr, Indexes, &entityIds, validation);\n+    return sum;\n }\n \n-ui64 TPortionInfo::GetIndexRawBytes(const std::optional<std::set<ui32>>& entityIds, const bool validation) const {\n+ui64 TPortionInfo::GetIndexRawBytes(const bool validation) const {\n     ui64 sum = 0;\n     const auto aggr = [&](const TIndexChunk& r) {\n         sum += r.GetRawBytes();\n     };\n-    AggregateIndexChunksData(aggr, Indexes, entityIds, validation);\n+    AggregateIndexChunksData(aggr, Indexes, nullptr, validation);\n     return sum;\n }\n \n@@ -590,11 +611,10 @@ template <class TExternalBlobInfo>\n TPortionInfo::TPreparedBatchData PrepareForAssembleImpl(const TPortionInfo& portion, const ISnapshotSchema& dataSchema, const ISnapshotSchema& resultSchema,\n     THashMap<TChunkAddress, TExternalBlobInfo>& blobsData) {\n     std::vector<TPortionInfo::TColumnAssemblingInfo> columns;\n-    auto arrowResultSchema = resultSchema.GetSchema();\n-    columns.reserve(arrowResultSchema->num_fields());\n+    columns.reserve(resultSchema.GetColumnIds().size());\n     const ui32 rowsCount = portion.GetRecordsCount();\n-    for (auto&& i : arrowResultSchema->fields()) {\n-        columns.emplace_back(rowsCount, dataSchema.GetColumnLoaderOptional(i->name()), resultSchema.GetColumnLoaderOptional(i->name()));\n+    for (auto&& i : resultSchema.GetColumnIds()) {\n+        columns.emplace_back(rowsCount, dataSchema.GetColumnLoaderOptional(i), resultSchema.GetColumnLoaderVerified(i));\n     }\n     {\n         int skipColumnId = -1;\n@@ -626,35 +646,11 @@ TPortionInfo::TPreparedBatchData PrepareForAssembleImpl(const TPortionInfo& port\n         preparedColumns.emplace_back(c.Compile());\n     }\n \n-    return TPortionInfo::TPreparedBatchData(std::move(preparedColumns), arrowResultSchema, rowsCount);\n+    return TPortionInfo::TPreparedBatchData(std::move(preparedColumns), rowsCount);\n }\n \n }\n \n-namespace {\n-class TChunkAccessor {\n-private:\n-    const std::vector<TDeserializeChunkedArray::TChunk>& Chunks;\n-    const std::shared_ptr<TColumnLoader> Loader;\n-public:\n-    TChunkAccessor(const std::vector<TDeserializeChunkedArray::TChunk>& chunks, const std::shared_ptr<TColumnLoader>& loader)\n-        : Chunks(chunks)\n-        , Loader(loader)\n-    {\n-\n-    }\n-    ui64 GetChunksCount() const {\n-        return Chunks.size();\n-    }\n-    ui64 GetChunkLength(const ui32 idx) const {\n-        return Chunks[idx].GetRecordsCount();\n-    }\n-    std::shared_ptr<arrow::Array> GetArray(const ui32 idx) const {\n-        return Chunks[idx].GetArrayVerified(Loader);\n-    }\n-};\n-}\n-\n ISnapshotSchema::TPtr TPortionInfo::TSchemaCursor::GetSchema(const TPortionInfoConstructor& portion) {\n     if (!CurrentSchema || portion.GetMinSnapshotDeprecatedVerified() != LastSnapshot) {\n         CurrentSchema = portion.GetSchema(VersionedIndex);\n@@ -664,12 +660,8 @@ ISnapshotSchema::TPtr TPortionInfo::TSchemaCursor::GetSchema(const TPortionInfoC\n     return CurrentSchema;\n }\n \n-NArrow::NAccessor::IChunkedArray::TCurrentChunkAddress TDeserializeChunkedArray::DoGetChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position) const {\n-    TChunkAccessor accessor(Chunks, Loader);\n-    return SelectChunk(chunkCurrent, position, accessor);\n-}\n-\n-TPortionInfo::TPreparedBatchData TPortionInfo::PrepareForAssemble(const ISnapshotSchema& dataSchema, const ISnapshotSchema& resultSchema, THashMap<TChunkAddress, TString>& blobsData) const {\n+TPortionInfo::TPreparedBatchData TPortionInfo::PrepareForAssemble(\n+    const ISnapshotSchema& dataSchema, const ISnapshotSchema& resultSchema, THashMap<TChunkAddress, TString>& blobsData) const {\n     return PrepareForAssembleImpl(*this, dataSchema, resultSchema, blobsData);\n }\n \n@@ -687,25 +679,18 @@ bool TPortionInfo::NeedShardingFilter(const TGranuleShardingInfo& shardingInfo)\n std::shared_ptr<NArrow::NAccessor::IChunkedArray> TPortionInfo::TPreparedColumn::AssembleAccessor() const {\n     Y_ABORT_UNLESS(!Blobs.empty());\n \n-    std::vector<std::shared_ptr<arrow::Array>> chunks;\n-    chunks.reserve(Blobs.size());\n+    NArrow::NAccessor::TCompositeChunkedArray::TBuilder builder(GetField()->type());\n     for (auto& blob : Blobs) {\n-        auto batch = blob.BuildRecordBatch(*Loader);\n-        Y_ABORT_UNLESS(batch);\n-        AFL_VERIFY(batch->num_columns() == 1);\n-        chunks.emplace_back(batch->column(0));\n-    }\n-    if (chunks.size() > 1) {\n-        return std::make_shared<NArrow::NAccessor::TTrivialChunkedArray>(NArrow::TStatusValidator::GetValid(arrow::ChunkedArray::Make(chunks)));\n-    } else {\n-        return std::make_shared<NArrow::NAccessor::TTrivialArray>(chunks.front());\n+        auto chunkedArray = blob.BuildRecordBatch(*Loader);\n+        builder.AddChunk(chunkedArray);\n     }\n+    return builder.Finish();\n }\n \n-std::shared_ptr<TDeserializeChunkedArray> TPortionInfo::TPreparedColumn::AssembleForSeqAccess() const {\n+std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> TPortionInfo::TPreparedColumn::AssembleForSeqAccess() const {\n     Y_ABORT_UNLESS(!Blobs.empty());\n \n-    std::vector<TDeserializeChunkedArray::TChunk> chunks;\n+    std::vector<NArrow::NAccessor::TDeserializeChunkedArray::TChunk> chunks;\n     chunks.reserve(Blobs.size());\n     ui64 recordsCount = 0;\n     for (auto& blob : Blobs) {\n@@ -717,64 +702,31 @@ std::shared_ptr<TDeserializeChunkedArray> TPortionInfo::TPreparedColumn::Assembl\n         }\n     }\n \n-    return std::make_shared<TDeserializeChunkedArray>(recordsCount, Loader, std::move(chunks));\n-}\n-\n-std::shared_ptr<arrow::ChunkedArray> TPortionInfo::TPreparedColumn::Assemble() const {\n-    Y_ABORT_UNLESS(!Blobs.empty());\n-\n-    std::vector<std::shared_ptr<arrow::Array>> chunks;\n-    chunks.reserve(Blobs.size());\n-    for (auto& blob : Blobs) {\n-        auto batch = blob.BuildRecordBatch(*Loader);\n-        Y_ABORT_UNLESS(batch);\n-        Y_ABORT_UNLESS(batch->num_columns() == 1);\n-        chunks.emplace_back(batch->column(0));\n-    }\n-\n-    return NArrow::TStatusValidator::GetValid(arrow::ChunkedArray::Make(chunks));\n+    return std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(recordsCount, Loader, std::move(chunks));\n }\n \n-TDeserializeChunkedArray::TChunk TPortionInfo::TAssembleBlobInfo::BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const {\n+NArrow::NAccessor::TDeserializeChunkedArray::TChunk TPortionInfo::TAssembleBlobInfo::BuildDeserializeChunk(\n+    const std::shared_ptr<TColumnLoader>& loader) const {\n     if (DefaultRowsCount) {\n         Y_ABORT_UNLESS(!Data);\n-        AFL_VERIFY(loader->GetExpectedSchema()->num_fields() == 1);\n-        auto col = NArrow::TThreadSimpleArraysCache::Get(loader->GetExpectedSchema()->field(0)->type(), DefaultValue, DefaultRowsCount);\n-        return TDeserializeChunkedArray::TChunk(col);\n+        auto col = std::make_shared<NArrow::NAccessor::TTrivialArray>(\n+            NArrow::TThreadSimpleArraysCache::Get(loader->GetField()->type(), DefaultValue, DefaultRowsCount));\n+        return NArrow::NAccessor::TDeserializeChunkedArray::TChunk(col);\n     } else {\n         AFL_VERIFY(ExpectedRowsCount);\n-        return TDeserializeChunkedArray::TChunk(*ExpectedRowsCount, Data);\n+        return NArrow::NAccessor::TDeserializeChunkedArray::TChunk(*ExpectedRowsCount, Data);\n     }\n }\n \n-std::shared_ptr<arrow::RecordBatch> TPortionInfo::TAssembleBlobInfo::BuildRecordBatch(const TColumnLoader& loader) const {\n+std::shared_ptr<NArrow::NAccessor::IChunkedArray> TPortionInfo::TAssembleBlobInfo::BuildRecordBatch(const TColumnLoader& loader) const {\n     if (DefaultRowsCount) {\n         Y_ABORT_UNLESS(!Data);\n-        AFL_VERIFY(loader.GetExpectedSchema()->num_fields() == 1);\n-        return arrow::RecordBatch::Make(loader.GetExpectedSchema(), DefaultRowsCount,\n-            { NArrow::TThreadSimpleArraysCache::Get(loader.GetExpectedSchema()->field(0)->type(), DefaultValue, DefaultRowsCount) });\n+        return std::make_shared<NArrow::NAccessor::TTrivialArray>(\n+            NArrow::TThreadSimpleArraysCache::Get(loader.GetField()->type(), DefaultValue, DefaultRowsCount));\n     } else {\n-        auto result = loader.Apply(Data);\n-        if (!result.ok()) {\n-            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"cannot unpack batch\")(\"error\", result.status().ToString())(\"loader\", loader.DebugString());\n-            return nullptr;\n-        }\n-        if (ExpectedRowsCount) {\n-            AFL_VERIFY((*result)->num_rows() == ExpectedRowsCount)(\"real\", (*result)->num_rows())(\"expected\", ExpectedRowsCount);\n-        }\n-        return *result;\n-    }\n-}\n-\n-std::shared_ptr<NArrow::TGeneralContainer> TPortionInfo::TPreparedBatchData::AssembleForSeqAccess() const {\n-    std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> columns;\n-    std::vector<std::shared_ptr<arrow::Field>> fields;\n-    for (auto&& i : Columns) {\n-        columns.emplace_back(i.AssembleForSeqAccess());\n-        fields.emplace_back(i.GetField());\n+        AFL_VERIFY(ExpectedRowsCount);\n+        return loader.ApplyVerified(Data, *ExpectedRowsCount);\n     }\n-\n-    return std::make_shared<NArrow::TGeneralContainer>(fields, std::move(columns));\n }\n \n std::shared_ptr<NArrow::TGeneralContainer> TPortionInfo::TPreparedBatchData::AssembleToGeneralContainer(\n@@ -782,6 +734,7 @@ std::shared_ptr<NArrow::TGeneralContainer> TPortionInfo::TPreparedBatchData::Ass\n     std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> columns;\n     std::vector<std::shared_ptr<arrow::Field>> fields;\n     for (auto&& i : Columns) {\n+        NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"column\", i.GetField()->ToString())(\"id\", i.GetColumnId());\n         if (sequentialColumnIds.contains(i.GetColumnId())) {\n             columns.emplace_back(i.AssembleForSeqAccess());\n         } else {\ndiff --git a/ydb/core/tx/columnshard/engines/portions/portion_info.h b/ydb/core/tx/columnshard/engines/portions/portion_info.h\nindex b7b89c2f187d..6fa105745b05 100644\n--- a/ydb/core/tx/columnshard/engines/portions/portion_info.h\n+++ b/ydb/core/tx/columnshard/engines/portions/portion_info.h\n@@ -3,9 +3,11 @@\n #include \"index_chunk.h\"\n #include \"meta.h\"\n \n+#include <ydb/core/formats/arrow/accessor/composite_serial/accessor.h>\n #include <ydb/core/formats/arrow/special_keys.h>\n-#include <ydb/core/formats/arrow/common/accessor.h>\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n #include <ydb/core/formats/arrow/common/container.h>\n+#include <ydb/library/formats/arrow/splitter/stats.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/storage.h>\n #include <ydb/core/tx/columnshard/engines/scheme/abstract_scheme.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n@@ -28,60 +30,6 @@ struct TIndexInfo;\n class TVersionedIndex;\n class IDbWrapper;\n \n-class TDeserializeChunkedArray: public NArrow::NAccessor::IChunkedArray {\n-private:\n-    using TBase = NArrow::NAccessor::IChunkedArray;\n-public:\n-    class TChunk {\n-    private:\n-        YDB_READONLY(ui32, RecordsCount, 0);\n-        std::shared_ptr<arrow::Array> PredefinedArray;\n-        const TString Data;\n-    public:\n-        TChunk(const std::shared_ptr<arrow::Array>& predefinedArray)\n-            : PredefinedArray(predefinedArray) {\n-            AFL_VERIFY(PredefinedArray);\n-            RecordsCount = PredefinedArray->length();\n-        }\n-\n-        TChunk(const ui32 recordsCount, const TString& data)\n-            : RecordsCount(recordsCount)\n-            , Data(data) {\n-\n-        }\n-\n-        std::shared_ptr<arrow::Array> GetArrayVerified(const std::shared_ptr<TColumnLoader>& loader) const {\n-            if (PredefinedArray) {\n-                return PredefinedArray;\n-            }\n-            auto result = loader->ApplyVerified(Data);\n-            AFL_VERIFY(result);\n-            AFL_VERIFY(result->num_columns() == 1);\n-            AFL_VERIFY(result->num_rows() == RecordsCount)(\"length\", result->num_rows())(\"records_count\", RecordsCount);\n-            return result->column(0);\n-        }\n-    };\n-\n-    std::shared_ptr<TColumnLoader> Loader;\n-    std::vector<TChunk> Chunks;\n-protected:\n-    virtual std::optional<ui64> DoGetRawSize() const override {\n-        return {};\n-    }\n-    virtual TCurrentChunkAddress DoGetChunk(const std::optional<TCurrentChunkAddress>& chunkCurrent, const ui64 position) const override;\n-    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override {\n-        AFL_VERIFY(false);\n-        return nullptr;\n-    }\n-public:\n-    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, std::vector<TChunk>&& chunks)\n-        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())\n-        , Loader(loader)\n-        , Chunks(std::move(chunks)) {\n-        AFL_VERIFY(Loader);\n-    }\n-};\n-\n class TEntityChunk {\n private:\n     TChunkAddress Address;\n@@ -150,7 +98,7 @@ class TPortionInfo {\n     }\n \n     template <class TAggregator, class TChunkInfo>\n-    static void AggregateIndexChunksData(const TAggregator& aggr, const std::vector<TChunkInfo>& chunks, const std::optional<std::set<ui32>>& columnIds, const bool validation) {\n+    static void AggregateIndexChunksData(const TAggregator& aggr, const std::vector<TChunkInfo>& chunks, const std::set<ui32>* columnIds, const bool validation) {\n         if (columnIds) {\n             auto itColumn = columnIds->begin();\n             auto itRecord = chunks.begin();\n@@ -371,8 +319,8 @@ class TPortionInfo {\n         return result;\n     }\n \n-    TSerializationStats GetSerializationStat(const ISnapshotSchema& schema) const {\n-        TSerializationStats result;\n+    NArrow::NSplitter::TSerializationStats GetSerializationStat(const ISnapshotSchema& schema) const {\n+        NArrow::NSplitter::TSerializationStats result;\n         for (auto&& i : Records) {\n             if (schema.GetFieldByColumnIdOptional(i.ColumnId)) {\n                 result.AddStat(i.GetSerializationStat(schema.GetFieldByColumnIdVerified(i.ColumnId)->name()));\n@@ -390,22 +338,29 @@ class TPortionInfo {\n     }\n \n     const TColumnRecord* GetRecordPointer(const TChunkAddress& address) const {\n-        for (auto&& i : Records) {\n-            if (i.GetAddress() == address) {\n-                return &i;\n-            }\n+        auto it = std::lower_bound(Records.begin(), Records.end(), address, [](const TColumnRecord& item, const TChunkAddress& address) {\n+            return item.GetAddress() < address;\n+        });\n+        if (it != Records.end() && it->GetAddress() == address) {\n+            return &*it;\n         }\n         return nullptr;\n     }\n \n     bool HasEntityAddress(const TChunkAddress& address) const {\n-        for (auto&& c : GetRecords()) {\n-            if (c.GetAddress() == address) {\n+        {\n+            auto it = std::lower_bound(Records.begin(), Records.end(), address, [](const TColumnRecord& item, const TChunkAddress& address) {\n+                return item.GetAddress() < address;\n+            });\n+            if (it != Records.end() && it->GetAddress() == address) {\n                 return true;\n             }\n         }\n-        for (auto&& c : GetIndexes()) {\n-            if (c.GetAddress() == address) {\n+        {\n+            auto it = std::lower_bound(Indexes.begin(), Indexes.end(), address, [](const TIndexChunk& item, const TChunkAddress& address) {\n+                return item.GetAddress() < address;\n+            });\n+            if (it != Indexes.end() && it->GetAddress() == address) {\n                 return true;\n             }\n         }\n@@ -496,10 +451,7 @@ class TPortionInfo {\n             return false;\n         }\n \n-        bool visible = (Meta.RecordSnapshotMin <= snapshot);\n-        if (visible && RemoveSnapshot.Valid()) {\n-            visible = snapshot < RemoveSnapshot;\n-        }\n+        const bool visible = (Meta.RecordSnapshotMin <= snapshot) && (!RemoveSnapshot.Valid() || snapshot < RemoveSnapshot);\n \n         AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"IsVisible\")(\"analyze_portion\", DebugString())(\"visible\", visible)(\"snapshot\", snapshot.DebugString());\n         return visible;\n@@ -585,7 +537,8 @@ class TPortionInfo {\n         return result;\n     }\n \n-    ui64 GetIndexRawBytes(const std::optional<std::set<ui32>>& columnIds = {}, const bool validation = true) const;\n+    ui64 GetIndexRawBytes(const std::set<ui32>& columnIds, const bool validation = true) const;\n+    ui64 GetIndexRawBytes(const bool validation = true) const;\n     ui64 GetIndexBlobBytes() const noexcept {\n         ui64 sum = 0;\n         for (const auto& rec : Indexes) {\n@@ -594,11 +547,11 @@ class TPortionInfo {\n         return sum;\n     }\n \n-    ui64 GetColumnRawBytes(const std::vector<ui32>& columnIds, const bool validation = true) const;\n-    ui64 GetColumnRawBytes(const std::optional<std::set<ui32>>& columnIds = {}, const bool validation = true) const;\n+    ui64 GetColumnRawBytes(const std::set<ui32>& columnIds, const bool validation = true) const;\n+    ui64 GetColumnRawBytes(const bool validation = true) const;\n \n-    ui64 GetColumnBlobBytes(const std::vector<ui32>& columnIds, const bool validation = true) const;\n-    ui64 GetColumnBlobBytes(const std::optional<std::set<ui32>>& columnIds = {}, const bool validation = true) const;\n+    ui64 GetColumnBlobBytes(const std::set<ui32>& columnIds, const bool validation = true) const;\n+    ui64 GetColumnBlobBytes(const bool validation = true) const;\n \n     ui64 GetTotalBlobBytes() const noexcept {\n         return GetIndexBlobBytes() + GetColumnBlobBytes();\n@@ -656,8 +609,8 @@ class TPortionInfo {\n             return DefaultRowsCount && !Data;\n         }\n \n-        std::shared_ptr<arrow::RecordBatch> BuildRecordBatch(const TColumnLoader& loader) const;\n-        TDeserializeChunkedArray::TChunk BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const;\n+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> BuildRecordBatch(const TColumnLoader& loader) const;\n+        NArrow::NAccessor::TDeserializeChunkedArray::TChunk BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const;\n     };\n \n     class TPreparedColumn {\n@@ -670,29 +623,26 @@ class TPortionInfo {\n         }\n \n         const std::string& GetName() const {\n-            return Loader->GetExpectedSchema()->field(0)->name();\n+            return Loader->GetField()->name();\n         }\n \n         std::shared_ptr<arrow::Field> GetField() const {\n-            return Loader->GetExpectedSchema()->field(0);\n+            return Loader->GetField();\n         }\n \n         TPreparedColumn(std::vector<TAssembleBlobInfo>&& blobs, const std::shared_ptr<TColumnLoader>& loader)\n             : Loader(loader)\n             , Blobs(std::move(blobs)) {\n-            Y_ABORT_UNLESS(Loader);\n-            Y_ABORT_UNLESS(Loader->GetExpectedSchema()->num_fields() == 1);\n+            AFL_VERIFY(Loader);\n         }\n \n-        std::shared_ptr<arrow::ChunkedArray> Assemble() const;\n-        std::shared_ptr<TDeserializeChunkedArray> AssembleForSeqAccess() const;\n+        std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> AssembleForSeqAccess() const;\n         std::shared_ptr<NArrow::NAccessor::IChunkedArray> AssembleAccessor() const;\n     };\n \n     class TPreparedBatchData {\n     private:\n         std::vector<TPreparedColumn> Columns;\n-        std::shared_ptr<arrow::Schema> Schema;\n         size_t RowsCount = 0;\n     public:\n         struct TAssembleOptions {\n@@ -733,10 +683,6 @@ class TPortionInfo {\n             return nullptr;\n         }\n \n-        std::vector<std::string> GetSchemaColumnNames() const {\n-            return Schema->field_names();\n-        }\n-\n         size_t GetColumnsCount() const {\n             return Columns.size();\n         }\n@@ -745,14 +691,12 @@ class TPortionInfo {\n             return RowsCount;\n         }\n \n-        TPreparedBatchData(std::vector<TPreparedColumn>&& columns, std::shared_ptr<arrow::Schema> schema, const size_t rowsCount)\n+        TPreparedBatchData(std::vector<TPreparedColumn>&& columns, const size_t rowsCount)\n             : Columns(std::move(columns))\n-            , Schema(schema)\n             , RowsCount(rowsCount) {\n         }\n \n         std::shared_ptr<NArrow::TGeneralContainer> AssembleToGeneralContainer(const std::set<ui32>& sequentialColumnIds) const;\n-        std::shared_ptr<NArrow::TGeneralContainer> AssembleForSeqAccess() const;\n     };\n \n     class TColumnAssemblingInfo {\ndiff --git a/ydb/core/tx/columnshard/engines/portions/read_with_blobs.cpp b/ydb/core/tx/columnshard/engines/portions/read_with_blobs.cpp\nindex 14fa9f854dcc..ae85ef59842c 100644\n--- a/ydb/core/tx/columnshard/engines/portions/read_with_blobs.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/read_with_blobs.cpp\n@@ -104,8 +104,8 @@ std::optional<TWritePortionInfoWithBlobsResult> TReadPortionInfoWithBlobs::SyncP\n         std::vector<std::shared_ptr<IPortionDataChunk>> newChunks;\n         if (it != columnChunks.end()) {\n             newChunks = to->GetIndexInfo().ActualizeColumnData(it->second, from->GetIndexInfo(), i);\n+            AFL_VERIFY(entityChunksNew.emplace(i, std::move(newChunks)).second);\n         }\n-        AFL_VERIFY(entityChunksNew.emplace(i, std::move(newChunks)).second);\n     }\n \n     TPortionInfoConstructor constructor(source.PortionInfo, false, true);\n@@ -120,7 +120,7 @@ std::optional<TWritePortionInfoWithBlobsResult> TReadPortionInfoWithBlobs::SyncP\n     }\n \n     const NSplitter::TEntityGroups groups = to->GetIndexInfo().GetEntityGroupsByStorageId(targetTier, *storages);\n-    auto schemaTo = std::make_shared<TDefaultSchemaDetails>(to, std::make_shared<TSerializationStats>());\n+    auto schemaTo = std::make_shared<TDefaultSchemaDetails>(to, std::make_shared<NArrow::NSplitter::TSerializationStats>());\n     TGeneralSerializedSlice slice(secondaryData.GetExternalData(), schemaTo, counters);\n \n     return TWritePortionInfoWithBlobsConstructor::BuildByBlobs(\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/container.cpp b/ydb/core/tx/columnshard/engines/predicate/container.cpp\nindex 0f27c3538293..8afcc1895e4d 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/container.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/container.cpp\n@@ -115,51 +115,53 @@ bool TPredicateContainer::CrossRanges(const TPredicateContainer& ext) {\n     }\n }\n \n-std::optional<NKikimr::NOlap::TPredicateContainer> TPredicateContainer::BuildPredicateFrom(std::shared_ptr<NOlap::TPredicate> object, const TIndexInfo* indexInfo) {\n+TConclusion<NKikimr::NOlap::TPredicateContainer> TPredicateContainer::BuildPredicateFrom(\n+    std::shared_ptr<NOlap::TPredicate> object, const std::shared_ptr<arrow::Schema>& pkSchema) {\n     if (!object || object->Empty()) {\n         return TPredicateContainer(NArrow::ECompareType::GREATER_OR_EQUAL);\n     } else {\n         if (!object->Good()) {\n             AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not good 'from' predicate\");\n-            return {};\n+            return TConclusionStatus::Fail(\"not good 'from' predicate\");\n         }\n         if (!object->IsFrom()) {\n             AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"'from' predicate not is from\");\n-            return {};\n+            return TConclusionStatus::Fail(\"'from' predicate not is from\");\n         }\n-        if (indexInfo) {\n+        if (pkSchema) {\n             auto cNames = object->ColumnNames();\n             i32 countSortingFields = 0;\n-            for (i32 i = 0; i < indexInfo->GetReplaceKey()->num_fields(); ++i) {\n-                if (i < (int)cNames.size() && cNames[i] == indexInfo->GetReplaceKey()->field(i)->name()) {\n+            for (i32 i = 0; i < pkSchema->num_fields(); ++i) {\n+                if (i < (int)cNames.size() && cNames[i] == pkSchema->field(i)->name()) {\n                     ++countSortingFields;\n                 } else {\n                     break;\n                 }\n             }\n-            Y_ABORT_UNLESS(countSortingFields == object->Batch->num_columns());\n+            AFL_VERIFY(countSortingFields == object->Batch->num_columns())(\"count\", countSortingFields)(\"object\", object->Batch->num_columns());\n         }\n-        return TPredicateContainer(object);\n+        return TPredicateContainer(object, pkSchema ? ExtractKey(*object, pkSchema) : nullptr);\n     }\n }\n \n-std::optional<NKikimr::NOlap::TPredicateContainer> TPredicateContainer::BuildPredicateTo(std::shared_ptr<NOlap::TPredicate> object, const TIndexInfo* indexInfo) {\n+TConclusion<TPredicateContainer> TPredicateContainer::BuildPredicateTo(\n+    std::shared_ptr<TPredicate> object, const std::shared_ptr<arrow::Schema>& pkSchema) {\n     if (!object || object->Empty()) {\n         return TPredicateContainer(NArrow::ECompareType::LESS_OR_EQUAL);\n     } else {\n         if (!object->Good()) {\n             AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not good 'to' predicate\");\n-            return {};\n+            return TConclusionStatus::Fail(\"not good 'to' predicate\");\n         }\n         if (!object->IsTo()) {\n             AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"'to' predicate not is to\");\n-            return {};\n+            return TConclusionStatus::Fail(\"'to' predicate not is to\");\n         }\n-        if (indexInfo) {\n+        if (pkSchema) {\n             auto cNames = object->ColumnNames();\n             i32 countSortingFields = 0;\n-            for (i32 i = 0; i < indexInfo->GetReplaceKey()->num_fields(); ++i) {\n-                if (i < (int)cNames.size() && cNames[i] == indexInfo->GetReplaceKey()->field(i)->name()) {\n+            for (i32 i = 0; i < pkSchema->num_fields(); ++i) {\n+                if (i < (int)cNames.size() && cNames[i] == pkSchema->field(i)->name()) {\n                     ++countSortingFields;\n                 } else {\n                     break;\n@@ -167,7 +169,7 @@ std::optional<NKikimr::NOlap::TPredicateContainer> TPredicateContainer::BuildPre\n             }\n             Y_ABORT_UNLESS(countSortingFields == object->Batch->num_columns());\n         }\n-        return TPredicateContainer(object);\n+        return TPredicateContainer(object, pkSchema ? TPredicateContainer::ExtractKey(*object, pkSchema) : nullptr);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/predicate/container.h b/ydb/core/tx/columnshard/engines/predicate/container.h\nindex 5cff2cbefea5..7d969cf9a759 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/container.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/container.h\n@@ -1,9 +1,13 @@\n #pragma once\n #include \"predicate.h\"\n+\n #include <ydb/core/formats/arrow/arrow_filter.h>\n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n+\n #include <ydb/library/accessor/accessor.h>\n+\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n+\n #include <optional>\n \n namespace NKikimr::NOlap {\n@@ -15,10 +19,12 @@ class TPredicateContainer {\n     std::shared_ptr<NOlap::TPredicate> Object;\n     NArrow::ECompareType CompareType;\n     mutable std::optional<std::vector<TString>> ColumnNames;\n+    std::shared_ptr<NArrow::TReplaceKey> ReplaceKey;\n \n-    TPredicateContainer(std::shared_ptr<NOlap::TPredicate> object)\n+    TPredicateContainer(std::shared_ptr<NOlap::TPredicate> object, const std::shared_ptr<NArrow::TReplaceKey>& replaceKey)\n         : Object(object)\n-        , CompareType(Object->GetCompareType()) {\n+        , CompareType(Object->GetCompareType())\n+        , ReplaceKey(replaceKey) {\n     }\n \n     TPredicateContainer(const NArrow::ECompareType compareType)\n@@ -27,15 +33,37 @@ class TPredicateContainer {\n \n     static std::partial_ordering ComparePredicatesSamePrefix(const NOlap::TPredicate& l, const NOlap::TPredicate& r);\n \n+    static std::shared_ptr<NArrow::TReplaceKey> ExtractKey(const NOlap::TPredicate& predicate, const std::shared_ptr<arrow::Schema>& key) {\n+        AFL_VERIFY(predicate.Batch);\n+        const auto& batchFields = predicate.Batch->schema()->fields();\n+        const auto& keyFields = key->fields();\n+        size_t minSize = std::min(batchFields.size(), keyFields.size());\n+        for (size_t i = 0; i < minSize; ++i) {\n+            Y_DEBUG_ABORT_UNLESS(batchFields[i]->type()->Equals(*keyFields[i]->type()));\n+        }\n+        if (batchFields.size() <= keyFields.size()) {\n+            return std::make_shared<NArrow::TReplaceKey>(NArrow::TReplaceKey::FromBatch(predicate.Batch, predicate.Batch->schema(), 0));\n+        } else {\n+            return std::make_shared<NArrow::TReplaceKey>(NArrow::TReplaceKey::FromBatch(predicate.Batch, key, 0));\n+        }\n+    }\n+\n public:\n+    NArrow::ECompareType GetCompareType() const {\n+        return CompareType;\n+    }\n+\n+    const std::shared_ptr<NArrow::TReplaceKey>& GetReplaceKey() const {\n+        return ReplaceKey;\n+    }\n \n     bool IsEmpty() const {\n         return !Object;\n     }\n \n     template <class TArrayColumn>\n-    std::optional<typename TArrayColumn::value_type> Get(const ui32 colIndex, const ui32 rowIndex,\n-        const std::optional<typename TArrayColumn::value_type> defaultValue = {}) const {\n+    std::optional<typename TArrayColumn::value_type> Get(\n+        const ui32 colIndex, const ui32 rowIndex, const std::optional<typename TArrayColumn::value_type> defaultValue = {}) const {\n         if (!Object) {\n             return defaultValue;\n         } else {\n@@ -59,13 +87,15 @@ class TPredicateContainer {\n         return TPredicateContainer(NArrow::ECompareType::GREATER_OR_EQUAL);\n     }\n \n-    static std::optional<TPredicateContainer> BuildPredicateFrom(std::shared_ptr<NOlap::TPredicate> object, const TIndexInfo* indexInfo);\n+    static TConclusion<TPredicateContainer> BuildPredicateFrom(\n+        std::shared_ptr<NOlap::TPredicate> object, const std::shared_ptr<arrow::Schema>& pkSchema);\n \n     static TPredicateContainer BuildNullPredicateTo() {\n         return TPredicateContainer(NArrow::ECompareType::LESS_OR_EQUAL);\n     }\n \n-    static std::optional<TPredicateContainer> BuildPredicateTo(std::shared_ptr<NOlap::TPredicate> object, const TIndexInfo* indexInfo);\n+    static TConclusion<TPredicateContainer> BuildPredicateTo(\n+        std::shared_ptr<NOlap::TPredicate> object, const std::shared_ptr<arrow::Schema>& pkSchema);\n \n     NKikimr::NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const {\n         if (!Object) {\n@@ -73,23 +103,6 @@ class TPredicateContainer {\n         }\n         return NArrow::TColumnFilter::MakePredicateFilter(data, Object->Batch, CompareType);\n     }\n-\n-    std::optional<NArrow::TReplaceKey> ExtractKey(const std::shared_ptr<arrow::Schema>& key) const {\n-        if (Object) {\n-            const auto& batchFields = Object->Batch->schema()->fields();\n-            const auto& keyFields = key->fields();\n-            size_t minSize = std::min(batchFields.size(), keyFields.size());\n-            for (size_t i = 0; i < minSize; ++i) {\n-                Y_DEBUG_ABORT_UNLESS(batchFields[i]->type()->Equals(*keyFields[i]->type()));\n-            }\n-            if (batchFields.size() <= keyFields.size()) {\n-                return NArrow::TReplaceKey::FromBatch(Object->Batch, Object->Batch->schema(), 0);\n-            } else {\n-                return NArrow::TReplaceKey::FromBatch(Object->Batch, key, 0);\n-            }\n-        }\n-        return {};\n-    }\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/filter.cpp b/ydb/core/tx/columnshard/engines/predicate/filter.cpp\nindex 10d66a832c1a..085eaa798f07 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/filter.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/filter.cpp\n@@ -1,4 +1,7 @@\n #include \"filter.h\"\n+\n+#include <ydb/core/formats/arrow/serializer/native.h>\n+\n #include <ydb/library/actors/core/log.h>\n \n namespace NKikimr::NOlap {\n@@ -14,43 +17,50 @@ NKikimr::NArrow::TColumnFilter TPKRangesFilter::BuildFilter(const arrow::Datum&\n     return result;\n }\n \n-bool TPKRangesFilter::Add(std::shared_ptr<NOlap::TPredicate> f, std::shared_ptr<NOlap::TPredicate> t, const TIndexInfo* indexInfo) {\n+TConclusionStatus TPKRangesFilter::Add(\n+    std::shared_ptr<NOlap::TPredicate> f, std::shared_ptr<NOlap::TPredicate> t, const std::shared_ptr<arrow::Schema>& pkSchema) {\n     if ((!f || f->Empty()) && (!t || t->Empty())) {\n-        return true;\n+        return TConclusionStatus::Success();\n+    }\n+    auto fromContainerConclusion = TPredicateContainer::BuildPredicateFrom(f, pkSchema);\n+    if (fromContainerConclusion.IsFail()) {\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"incorrect from container\")(\n+            \"from\", fromContainerConclusion.GetErrorMessage());\n+        return fromContainerConclusion;\n     }\n-    auto fromContainer = TPredicateContainer::BuildPredicateFrom(f, indexInfo);\n-    auto toContainer = TPredicateContainer::BuildPredicateTo(t, indexInfo);\n-    if (!fromContainer || !toContainer) {\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"incorrect from/to containers\")(\"from\", !!fromContainer)(\"to\", !!toContainer);\n-        return false;\n+    auto toContainerConclusion = TPredicateContainer::BuildPredicateTo(t, pkSchema);\n+    if (toContainerConclusion.IsFail()) {\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"incorrect to container\")(\n+            \"from\", toContainerConclusion.GetErrorMessage());\n+        return toContainerConclusion;\n     }\n     if (SortedRanges.size() && !FakeRanges) {\n         if (ReverseFlag) {\n-            if (fromContainer->CrossRanges(SortedRanges.front().GetPredicateTo())) {\n+            if (fromContainerConclusion->CrossRanges(SortedRanges.front().GetPredicateTo())) {\n                 AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not sorted sequence\");\n-                return false;\n+                return TConclusionStatus::Fail(\"not sorted sequence\");\n             }\n         } else {\n-            if (fromContainer->CrossRanges(SortedRanges.back().GetPredicateTo())) {\n+            if (fromContainerConclusion->CrossRanges(SortedRanges.back().GetPredicateTo())) {\n                 AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not sorted sequence\");\n-                return false;\n+                return TConclusionStatus::Fail(\"not sorted sequence\");\n             }\n         }\n     }\n-    auto pkRangeFilter = TPKRangeFilter::Build(std::move(*fromContainer), std::move(*toContainer));\n-    if (!pkRangeFilter) {\n-        return false;\n+    auto pkRangeFilterConclusion = TPKRangeFilter::Build(fromContainerConclusion.DetachResult(), toContainerConclusion.DetachResult());\n+    if (pkRangeFilterConclusion.IsFail()) {\n+        return pkRangeFilterConclusion;\n     }\n     if (FakeRanges) {\n         FakeRanges = false;\n         SortedRanges.clear();\n     }\n     if (ReverseFlag) {\n-        SortedRanges.emplace_front(std::move(*pkRangeFilter));\n+        SortedRanges.emplace_front(pkRangeFilterConclusion.DetachResult());\n     } else {\n-        SortedRanges.emplace_back(std::move(*pkRangeFilter));\n+        SortedRanges.emplace_back(pkRangeFilterConclusion.DetachResult());\n     }\n-    return true;\n+    return TConclusionStatus::Success();\n }\n \n TString TPKRangesFilter::DebugString() const {\n@@ -75,30 +85,134 @@ std::set<ui32> TPKRangesFilter::GetColumnIds(const TIndexInfo& indexInfo) const\n     return result;\n }\n \n-bool TPKRangesFilter::IsPortionInUsage(const TPortionInfo& info, const TIndexInfo& indexInfo) const {\n+bool TPKRangesFilter::IsPortionInUsage(const TPortionInfo& info) const {\n     for (auto&& i : SortedRanges) {\n-        if (i.IsPortionInUsage(info, indexInfo)) {\n+        if (i.IsPortionInUsage(info)) {\n             return true;\n         }\n     }\n     return SortedRanges.empty();\n }\n \n-bool TPKRangesFilter::IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end, const TIndexInfo& indexInfo) const {\n+bool TPKRangesFilter::CheckPoint(const NArrow::TReplaceKey& point) const {\n     for (auto&& i : SortedRanges) {\n-        if (i.IsPortionInPartialUsage(start, end, indexInfo)) {\n+        if (i.CheckPoint(point)) {\n             return true;\n         }\n     }\n-    return false;\n+    return SortedRanges.empty();\n+}\n+\n+TPKRangeFilter::EUsageClass TPKRangesFilter::IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end) const {\n+    for (auto&& i : SortedRanges) {\n+        switch (i.IsPortionInPartialUsage(start, end)) {\n+            case TPKRangeFilter::EUsageClass::FullUsage:\n+                return TPKRangeFilter::EUsageClass::FullUsage;\n+            case TPKRangeFilter::EUsageClass::PartialUsage:\n+                return TPKRangeFilter::EUsageClass::PartialUsage;\n+            case TPKRangeFilter::EUsageClass::DontUsage:\n+                break;\n+        }\n+    }\n+    return TPKRangeFilter::EUsageClass::DontUsage;\n }\n \n TPKRangesFilter::TPKRangesFilter(const bool reverse)\n-    : ReverseFlag(reverse)\n-{\n+    : ReverseFlag(reverse) {\n     auto range = TPKRangeFilter::Build(TPredicateContainer::BuildNullPredicateFrom(), TPredicateContainer::BuildNullPredicateTo());\n     Y_ABORT_UNLESS(range);\n     SortedRanges.emplace_back(*range);\n }\n \n+std::shared_ptr<arrow::RecordBatch> TPKRangesFilter::SerializeToRecordBatch(const std::shared_ptr<arrow::Schema>& pkSchema) const {\n+    auto fullSchema = NArrow::TStatusValidator::GetValid(\n+        pkSchema->AddField(pkSchema->num_fields(), std::make_shared<arrow::Field>(\".ydb_operation_type\", arrow::uint32())));\n+    auto builders = NArrow::MakeBuilders(fullSchema, SortedRanges.size() * 2);\n+    for (auto&& i : SortedRanges) {\n+        for (ui32 idx = 0; idx < (ui32)pkSchema->num_fields(); ++idx) {\n+            if (idx < i.GetPredicateFrom().GetReplaceKey()->Size()) {\n+                AFL_VERIFY(NArrow::Append(\n+                    *builders[idx], i.GetPredicateFrom().GetReplaceKey()->Column(idx), i.GetPredicateFrom().GetReplaceKey()->GetPosition()));\n+            } else {\n+                NArrow::TStatusValidator::Validate(builders[idx]->AppendNull());\n+            }\n+        }\n+        NArrow::Append<arrow::UInt32Type>(*builders[pkSchema->num_fields()], (ui32)i.GetPredicateFrom().GetCompareType());\n+\n+        for (ui32 idx = 0; idx < (ui32)pkSchema->num_fields(); ++idx) {\n+            if (idx < i.GetPredicateTo().GetReplaceKey()->Size()) {\n+                AFL_VERIFY(NArrow::Append(\n+                    *builders[idx], i.GetPredicateTo().GetReplaceKey()->Column(idx), i.GetPredicateTo().GetReplaceKey()->GetPosition()));\n+            } else {\n+                NArrow::TStatusValidator::Validate(builders[idx]->AppendNull());\n+            }\n+        }\n+        NArrow::Append<arrow::UInt32Type>(*builders[pkSchema->num_fields()], (ui32)i.GetPredicateTo().GetCompareType());\n+    }\n+    return arrow::RecordBatch::Make(fullSchema, SortedRanges.size() * 2, NArrow::Finish(std::move(builders)));\n+}\n+\n+std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecordBatchLines(\n+    const std::shared_ptr<arrow::RecordBatch>& batch, const bool reverse) {\n+    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>(reverse);\n+    for (ui32 i = 0; i < batch->num_rows(); ++i) {\n+        auto batchRow = batch->Slice(i, 1);\n+        auto pFrom = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::GreaterEqual, batchRow);\n+        auto pTo = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::LessEqual, batchRow);\n+        result->Add(pFrom, pTo, batch->schema()).Validate();\n+    }\n+    return result;\n }\n+\n+std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecordBatchFull(\n+    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse) {\n+    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>(reverse);\n+    auto pkBatch = NArrow::TColumnOperator().Adapt(batch, pkSchema).DetachResult();\n+    auto c = batch->GetColumnByName(\".ydb_operation_type\");\n+    AFL_VERIFY(c);\n+    AFL_VERIFY(c->type_id() == arrow::Type::UINT32);\n+    auto cUi32 = static_pointer_cast<arrow::UInt32Array>(c);\n+    for (ui32 i = 0; i < batch->num_rows();) {\n+        std::shared_ptr<NOlap::TPredicate> pFrom;\n+        std::shared_ptr<NOlap::TPredicate> pTo;\n+        {\n+            auto batchRow = TPredicate::CutNulls(batch->Slice(i, 1));\n+            NKernels::EOperation op = (NKernels::EOperation)cUi32->Value(i);\n+            if (op == NKernels::EOperation::GreaterEqual || op == NKernels::EOperation::Greater) {\n+                pFrom = std::make_shared<NOlap::TPredicate>(op, batchRow);\n+            } else if (op == NKernels::EOperation::Equal) {\n+                pFrom = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::GreaterEqual, batchRow);\n+            } else {\n+                AFL_VERIFY(false);\n+            }\n+            if (op != NKernels::EOperation::Equal) {\n+                ++i;\n+            }\n+        }\n+        {\n+            auto batchRow = TPredicate::CutNulls(batch->Slice(i, 1));\n+            NKernels::EOperation op = (NKernels::EOperation)cUi32->Value(i);\n+            if (op == NKernels::EOperation::LessEqual || op == NKernels::EOperation::Less) {\n+                pTo = std::make_shared<NOlap::TPredicate>(op, batchRow);\n+            } else if (op == NKernels::EOperation::Equal) {\n+                pTo = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::LessEqual, batchRow);\n+            } else {\n+                AFL_VERIFY(false);\n+            }\n+        }\n+        result->Add(pFrom, pTo, pkSchema).Validate();\n+    }\n+    return result;\n+}\n+\n+std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromString(\n+    const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse) {\n+    auto batch = NArrow::TStatusValidator::GetValid(NArrow::NSerialization::TNativeSerializer().Deserialize(data));\n+    return BuildFromRecordBatchFull(batch, pkSchema, reverse);\n+}\n+\n+TString TPKRangesFilter::SerializeToString(const std::shared_ptr<arrow::Schema>& pkSchema) const {\n+    return NArrow::NSerialization::TNativeSerializer().SerializeFull(SerializeToRecordBatch(pkSchema));\n+}\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/filter.h b/ydb/core/tx/columnshard/engines/predicate/filter.h\nindex 20e7a039b273..bbc70b5ff584 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/filter.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/filter.h\n@@ -9,9 +9,15 @@ class TPKRangesFilter {\n     bool FakeRanges = true;\n     std::deque<TPKRangeFilter> SortedRanges;\n     bool ReverseFlag = false;\n+\n public:\n     TPKRangesFilter(const bool reverse);\n \n+    [[nodiscard]] TConclusionStatus Add(\n+        std::shared_ptr<NOlap::TPredicate> f, std::shared_ptr<NOlap::TPredicate> t, const std::shared_ptr<arrow::Schema>& pkSchema);\n+    std::shared_ptr<arrow::RecordBatch> SerializeToRecordBatch(const std::shared_ptr<arrow::Schema>& pkSchema) const;\n+    TString SerializeToString(const std::shared_ptr<arrow::Schema>& pkSchema) const;\n+\n     bool IsEmpty() const {\n         return SortedRanges.empty() || FakeRanges;\n     }\n@@ -37,13 +43,12 @@ class TPKRangesFilter {\n         return SortedRanges.end();\n     }\n \n-    bool IsPortionInUsage(const TPortionInfo& info, const TIndexInfo& indexInfo) const;\n-    bool IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end, const TIndexInfo& indexInfo) const;\n+    bool IsPortionInUsage(const TPortionInfo& info) const;\n+    TPKRangeFilter::EUsageClass IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end) const;\n+    bool CheckPoint(const NArrow::TReplaceKey& point) const;\n \n     NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;\n \n-    [[nodiscard]] bool Add(std::shared_ptr<NOlap::TPredicate> f, std::shared_ptr<NOlap::TPredicate> t, const TIndexInfo* indexInfo);\n-\n     std::set<std::string> GetColumnNames() const {\n         std::set<std::string> result;\n         for (auto&& i : SortedRanges) {\n@@ -57,6 +62,30 @@ class TPKRangesFilter {\n     TString DebugString() const;\n \n     std::set<ui32> GetColumnIds(const TIndexInfo& indexInfo) const;\n+\n+    static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchLines(const std::shared_ptr<arrow::RecordBatch>& batch, const bool reverse);\n+\n+    static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchFull(\n+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse);\n+    static std::shared_ptr<TPKRangesFilter> BuildFromString(\n+        const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse);\n+\n+    template <class TProto>\n+    static TConclusion<TPKRangesFilter> BuildFromProto(const TProto& proto, const bool reverse, const std::vector<TNameTypeInfo>& ydbPk) {\n+        TPKRangesFilter result(reverse);\n+        for (auto& protoRange : proto.GetRanges()) {\n+            TSerializedTableRange range(protoRange);\n+            auto fromPredicate = std::make_shared<TPredicate>();\n+            auto toPredicate = std::make_shared<TPredicate>();\n+            TSerializedTableRange serializedRange(protoRange);\n+            std::tie(*fromPredicate, *toPredicate) = TPredicate::DeserializePredicatesRange(serializedRange, ydbPk);\n+            auto status = result.Add(fromPredicate, toPredicate, NArrow::TStatusValidator::GetValid(NArrow::MakeArrowSchema(ydbPk)));\n+            if (status.IsFail()) {\n+                return status;\n+            }\n+        }\n+        return result;\n+    }\n };\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/predicate.cpp b/ydb/core/tx/columnshard/engines/predicate/predicate.cpp\nindex 7a4ee282f0cc..a6831ca2ad50 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/predicate.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/predicate.cpp\n@@ -1,20 +1,21 @@\n #include \"predicate.h\"\n \n+#include <ydb/core/formats/arrow/arrow_batch_builder.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/switch_type.h>\n+#include <ydb/library/formats/arrow/switch_type.h>\n+\n+#include <ydb/library/actors/core/log.h>\n \n namespace NKikimr::NOlap {\n \n TPredicate::TPredicate(EOperation op, std::shared_ptr<arrow::RecordBatch> batch) noexcept\n     : Operation(op)\n-    , Batch(std::move(batch))\n-{\n+    , Batch(std::move(batch)) {\n     Y_ABORT_UNLESS(IsFrom() || IsTo());\n }\n \n TPredicate::TPredicate(EOperation op, const TString& serializedBatch, const std::shared_ptr<arrow::Schema>& schema)\n-    : Operation(op)\n-{\n+    : Operation(op) {\n     Y_ABORT_UNLESS(IsFrom() || IsTo());\n     if (!serializedBatch.empty()) {\n         Batch = NArrow::DeserializeBatch(serializedBatch, schema);\n@@ -31,7 +32,112 @@ std::vector<TString> TPredicate::ColumnNames() const {\n     return out;\n }\n \n-IOutputStream& operator << (IOutputStream& out, const TPredicate& pred) {\n+std::vector<NScheme::TTypeInfo> ExtractTypes(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns) {\n+    std::vector<NScheme::TTypeInfo> types;\n+    types.reserve(columns.size());\n+    for (auto& [name, type] : columns) {\n+        types.push_back(type);\n+    }\n+    return types;\n+}\n+\n+TString FromCells(const TConstArrayRef<TCell>& cells, const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns) {\n+    Y_ABORT_UNLESS(cells.size() == columns.size());\n+    if (cells.empty()) {\n+        return {};\n+    }\n+\n+    std::vector<NScheme::TTypeInfo> types = ExtractTypes(columns);\n+\n+    NArrow::TArrowBatchBuilder batchBuilder;\n+    batchBuilder.Reserve(1);\n+    auto startStatus = batchBuilder.Start(columns);\n+    Y_ABORT_UNLESS(startStatus.ok(), \"%s\", startStatus.ToString().c_str());\n+\n+    batchBuilder.AddRow(NKikimr::TDbTupleRef(), NKikimr::TDbTupleRef(types.data(), cells.data(), cells.size()));\n+\n+    auto batch = batchBuilder.FlushBatch(false);\n+    Y_ABORT_UNLESS(batch);\n+    Y_ABORT_UNLESS(batch->num_columns() == (int)cells.size());\n+    Y_ABORT_UNLESS(batch->num_rows() == 1);\n+    return NArrow::SerializeBatchNoCompression(batch);\n+}\n+\n+std::pair<NKikimr::NOlap::TPredicate, NKikimr::NOlap::TPredicate> TPredicate::DeserializePredicatesRange(\n+    const TSerializedTableRange& range, const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns) {\n+    std::vector<TCell> leftCells;\n+    std::vector<std::pair<TString, NScheme::TTypeInfo>> leftColumns;\n+    bool leftTrailingNull = false;\n+    {\n+        TConstArrayRef<TCell> cells = range.From.GetCells();\n+        const size_t size = cells.size();\n+        Y_ASSERT(size <= columns.size());\n+        leftCells.reserve(size);\n+        leftColumns.reserve(size);\n+        for (size_t i = 0; i < size; ++i) {\n+            if (!cells[i].IsNull()) {\n+                leftCells.push_back(cells[i]);\n+                leftColumns.push_back(columns[i]);\n+                leftTrailingNull = false;\n+            } else {\n+                leftTrailingNull = true;\n+            }\n+        }\n+    }\n+\n+    std::vector<TCell> rightCells;\n+    std::vector<std::pair<TString, NScheme::TTypeInfo>> rightColumns;\n+    bool rightTrailingNull = false;\n+    {\n+        TConstArrayRef<TCell> cells = range.To.GetCells();\n+        const size_t size = cells.size();\n+        Y_ASSERT(size <= columns.size());\n+        rightCells.reserve(size);\n+        rightColumns.reserve(size);\n+        for (size_t i = 0; i < size; ++i) {\n+            if (!cells[i].IsNull()) {\n+                rightCells.push_back(cells[i]);\n+                rightColumns.push_back(columns[i]);\n+                rightTrailingNull = false;\n+            } else {\n+                rightTrailingNull = true;\n+            }\n+        }\n+    }\n+\n+    const bool fromInclusive = range.FromInclusive || leftTrailingNull;\n+    const bool toInclusive = range.ToInclusive && !rightTrailingNull;\n+\n+    TString leftBorder = FromCells(leftCells, leftColumns);\n+    TString rightBorder = FromCells(rightCells, rightColumns);\n+    auto leftSchema = NArrow::MakeArrowSchema(leftColumns);\n+    Y_ASSERT(leftSchema.ok());\n+    auto rightSchema = NArrow::MakeArrowSchema(rightColumns);\n+    Y_ASSERT(rightSchema.ok());\n+    return std::make_pair(\n+        TPredicate(fromInclusive ? NKernels::EOperation::GreaterEqual : NKernels::EOperation::Greater, leftBorder, leftSchema.ValueUnsafe()),\n+        TPredicate(toInclusive ? NKernels::EOperation::LessEqual : NKernels::EOperation::Less, rightBorder, rightSchema.ValueUnsafe()));\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> TPredicate::CutNulls(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    AFL_VERIFY(batch->num_rows() == 1)(\"count\", batch->num_rows());\n+    AFL_VERIFY(batch->num_columns());\n+    std::vector<std::shared_ptr<arrow::Array>> colsNotNull;\n+    std::vector<std::shared_ptr<arrow::Field>> fieldsNotNull;\n+    ui32 idx = 0;\n+    for (auto&& i : batch->columns()) {\n+        if (i->IsNull(0)) {\n+            break;\n+        }\n+        colsNotNull.emplace_back(i);\n+        fieldsNotNull.emplace_back(batch->schema()->field(idx));\n+        ++idx;\n+    }\n+    AFL_VERIFY(colsNotNull.size());\n+    return arrow::RecordBatch::Make(std::make_shared<arrow::Schema>(fieldsNotNull), 1, colsNotNull);\n+}\n+\n+IOutputStream& operator<<(IOutputStream& out, const TPredicate& pred) {\n     out << NSsa::GetFunctionName(pred.Operation);\n \n     for (i32 i = 0; i < pred.Batch->num_columns(); ++i) {\n@@ -61,4 +167,4 @@ IOutputStream& operator << (IOutputStream& out, const TPredicate& pred) {\n     return out;\n }\n \n-} // namespace NKikimr::NOlap\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/predicate.h b/ydb/core/tx/columnshard/engines/predicate/predicate.h\nindex 0b856894e65f..8365971ea29e 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/predicate.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/predicate.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <ydb/core/formats/arrow/program.h>\n+#include <ydb/core/scheme/scheme_tabledefs.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n \n@@ -10,7 +11,9 @@ struct TPredicate {\n private:\n     using EOperation = NArrow::EOperation;\n     EOperation Operation{ EOperation::Unspecified };\n+\n public:\n+    static std::shared_ptr<arrow::RecordBatch> CutNulls(const std::shared_ptr<arrow::RecordBatch>& batch);\n \n     std::shared_ptr<arrow::RecordBatch> Batch;\n \n@@ -29,8 +32,8 @@ struct TPredicate {\n     }\n \n     template <class TArrayColumn>\n-    std::optional<typename TArrayColumn::value_type> Get(const ui32 colIndex, const ui32 rowIndex,\n-        const std::optional<typename TArrayColumn::value_type> defaultValue = {}) const {\n+    std::optional<typename TArrayColumn::value_type> Get(\n+        const ui32 colIndex, const ui32 rowIndex, const std::optional<typename TArrayColumn::value_type> defaultValue = {}) const {\n         auto column = Batch->column(colIndex);\n         if (!column) {\n             return defaultValue;\n@@ -42,10 +45,18 @@ struct TPredicate {\n         }\n     }\n \n-    bool Empty() const noexcept { return Batch.get() == nullptr; }\n-    bool Good() const { return !Empty() && Batch->num_columns() && Batch->num_rows() == 1; }\n-    bool IsFrom() const noexcept { return Operation == EOperation::Greater || Operation == EOperation::GreaterEqual; }\n-    bool IsTo() const noexcept { return Operation == EOperation::Less || Operation == EOperation::LessEqual; }\n+    bool Empty() const noexcept {\n+        return Batch.get() == nullptr;\n+    }\n+    bool Good() const {\n+        return !Empty() && Batch->num_columns() && Batch->num_rows() == 1;\n+    }\n+    bool IsFrom() const noexcept {\n+        return Operation == EOperation::Greater || Operation == EOperation::GreaterEqual;\n+    }\n+    bool IsTo() const noexcept {\n+        return Operation == EOperation::Less || Operation == EOperation::LessEqual;\n+    }\n     bool IsInclusive() const {\n         return Operation == EOperation::GreaterEqual || Operation == EOperation::LessEqual;\n     }\n@@ -56,13 +67,16 @@ struct TPredicate {\n         return Empty() ? \"()\" : Batch->schema()->ToString();\n     }\n \n+    static std::pair<TPredicate, TPredicate> DeserializePredicatesRange(\n+        const TSerializedTableRange& range, const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns);\n+\n     constexpr TPredicate() noexcept = default;\n \n     TPredicate(EOperation op, std::shared_ptr<arrow::RecordBatch> batch) noexcept;\n \n     TPredicate(EOperation op, const TString& serializedBatch, const std::shared_ptr<arrow::Schema>& schema);\n \n-    friend IOutputStream& operator << (IOutputStream& out, const TPredicate& pred);\n+    friend IOutputStream& operator<<(IOutputStream& out, const TPredicate& pred);\n };\n \n-} // namespace NKikimr::NOlap\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/range.cpp b/ydb/core/tx/columnshard/engines/predicate/range.cpp\nindex 3a073fcb8fec..83c6602d242d 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/range.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/range.cpp\n@@ -6,11 +6,11 @@ namespace NKikimr::NOlap {\n std::set<ui32> TPKRangeFilter::GetColumnIds(const TIndexInfo& indexInfo) const {\n     std::set<ui32> result;\n     for (auto&& i : PredicateFrom.GetColumnNames()) {\n-        result.emplace(indexInfo.GetColumnId(i));\n+        result.emplace(indexInfo.GetColumnIdVerified(i));\n         AFL_TRACE(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"predicate_column\", i);\n     }\n     for (auto&& i : PredicateTo.GetColumnNames()) {\n-        result.emplace(indexInfo.GetColumnId(i));\n+        result.emplace(indexInfo.GetColumnIdVerified(i));\n         AFL_TRACE(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"predicate_column\", i);\n     }\n     return result;\n@@ -39,63 +39,84 @@ NKikimr::NArrow::TColumnFilter TPKRangeFilter::BuildFilter(const arrow::Datum& d\n     return result.And(PredicateFrom.BuildFilter(data));\n }\n \n-bool TPKRangeFilter::IsPortionInUsage(const TPortionInfo& info, const TIndexInfo& indexInfo) const {\n-    if (auto from = PredicateFrom.ExtractKey(indexInfo.GetPrimaryKey())) {\n-        const auto& portionEnd = info.IndexKeyEnd();\n-        const int commonSize = std::min(from->Size(), portionEnd.Size());\n-        if (std::is_gt(from->ComparePartNotNull(portionEnd, commonSize))) {\n-            return false;\n-        }\n-    }\n+bool TPKRangeFilter::IsPortionInUsage(const TPortionInfo& info) const {\n+    return IsPortionInPartialUsage(info.IndexKeyStart(), info.IndexKeyEnd()) != TPKRangeFilter::EUsageClass::DontUsage;\n+}\n \n-    if (auto to = PredicateTo.ExtractKey(indexInfo.GetPrimaryKey())) {\n-        const auto& portionStart = info.IndexKeyStart();\n-        const int commonSize = std::min(to->Size(), portionStart.Size());\n-        if (std::is_lt(to->ComparePartNotNull(portionStart, commonSize))) {\n-            return false;\n+TPKRangeFilter::EUsageClass TPKRangeFilter::IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end) const {\n+    {\n+        std::partial_ordering equalityStartWithFrom = std::partial_ordering::greater;\n+        if (const auto& from = PredicateFrom.GetReplaceKey()) {\n+            equalityStartWithFrom = start.ComparePartNotNull(*from, from->Size());\n+        }\n+        std::partial_ordering equalityEndWithTo = std::partial_ordering::less;\n+        if (const auto& to = PredicateTo.GetReplaceKey()) {\n+            equalityEndWithTo = end.ComparePartNotNull(*to, to->Size());\n+        }\n+        const bool startInternal = (equalityStartWithFrom == std::partial_ordering::equivalent && PredicateFrom.IsInclude()) ||\n+                                   (equalityStartWithFrom == std::partial_ordering::greater);\n+        const bool endInternal = (equalityEndWithTo == std::partial_ordering::equivalent && PredicateTo.IsInclude()) ||\n+                                 (equalityEndWithTo == std::partial_ordering::less);\n+        if (startInternal && endInternal) {\n+            return EUsageClass::FullUsage;\n         }\n     }\n+    \n \n-    return true;\n-}\n-\n-bool TPKRangeFilter::IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end, const TIndexInfo& indexInfo) const {\n-    bool startUsage = false;\n-    bool endUsage = false;\n-    if (auto from = PredicateFrom.ExtractKey(indexInfo.GetPrimaryKey())) {\n-        AFL_VERIFY(from->Size() <= start.Size());\n-        if (PredicateFrom.IsInclude()) {\n-            startUsage = std::is_lt(start.ComparePartNotNull(*from, from->Size()));\n-        } else {\n-            startUsage = std::is_lteq(start.ComparePartNotNull(*from, from->Size()));\n+    if (const auto& from = PredicateFrom.GetReplaceKey()) {\n+        const std::partial_ordering equalityEndWithFrom = end.ComparePartNotNull(*from, from->Size());\n+        if (equalityEndWithFrom == std::partial_ordering::less) {\n+            return EUsageClass::DontUsage;\n+        } else if (equalityEndWithFrom == std::partial_ordering::equivalent) {\n+            if (PredicateFrom.IsInclude()) {\n+                return EUsageClass::PartialUsage;\n+            } else {\n+                return EUsageClass::DontUsage;\n+            }\n         }\n-    } else {\n-        startUsage = true;\n     }\n \n-    if (auto to = PredicateTo.ExtractKey(indexInfo.GetPrimaryKey())) {\n-        AFL_VERIFY(to->Size() <= end.Size());\n-        if (PredicateTo.IsInclude()) {\n-            endUsage = std::is_gt(end.ComparePartNotNull(*to, to->Size()));\n-        } else {\n-            endUsage = std::is_gteq(end.ComparePartNotNull(*to, to->Size()));\n+    if (const auto& to = PredicateTo.GetReplaceKey()) {\n+        const std::partial_ordering equalityStartWithTo = start.ComparePartNotNull(*to, to->Size());\n+        if (equalityStartWithTo == std::partial_ordering::greater) {\n+            return EUsageClass::DontUsage;\n+        } else if (equalityStartWithTo == std::partial_ordering::equivalent) {\n+            if (PredicateTo.IsInclude()) {\n+                return EUsageClass::PartialUsage;\n+            } else {\n+                return EUsageClass::DontUsage;\n+            }\n         }\n-    } else {\n-        endUsage = true;\n     }\n \n-//    AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"start\", start.DebugString())(\"end\", end.DebugString())(\"from\", PredicateFrom.DebugString())(\"to\", PredicateTo.DebugString())\n-//        (\"start_usage\", startUsage)(\"end_usage\", endUsage);\n+//    AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"start\", start.DebugString())(\"end\", end.DebugString())(\"from\", PredicateFrom.DebugString())(\n+//        \"to\", PredicateTo.DebugString());\n \n-    return endUsage || startUsage;\n+    return EUsageClass::PartialUsage;\n }\n \n-std::optional<NKikimr::NOlap::TPKRangeFilter> TPKRangeFilter::Build(TPredicateContainer&& from, TPredicateContainer&& to) {\n+TConclusion<TPKRangeFilter> TPKRangeFilter::Build(TPredicateContainer&& from, TPredicateContainer&& to) {\n     if (!from.CrossRanges(to)) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"cannot_build_predicate_range\")(\"error\", \"predicates from/to not intersected\");\n-        return {};\n+        return TConclusionStatus::Fail(\"predicates from/to not intersected\");\n     }\n     return TPKRangeFilter(std::move(from), std::move(to));\n }\n \n+bool TPKRangeFilter::CheckPoint(const NArrow::TReplaceKey& point) const {\n+    std::partial_ordering equalityWithFrom = std::partial_ordering::greater;\n+    if (const auto& from = PredicateFrom.GetReplaceKey()) {\n+        equalityWithFrom = point.ComparePartNotNull(*from, from->Size());\n+    }\n+    std::partial_ordering equalityWithTo = std::partial_ordering::less;\n+    if (const auto& to = PredicateTo.GetReplaceKey()) {\n+        equalityWithTo = point.ComparePartNotNull(*to, to->Size());\n+    }\n+    const bool startInternal = (equalityWithFrom == std::partial_ordering::equivalent && PredicateFrom.IsInclude()) ||\n+                               (equalityWithFrom == std::partial_ordering::greater);\n+    const bool endInternal = (equalityWithTo == std::partial_ordering::equivalent && PredicateTo.IsInclude()) ||\n+                             (equalityWithTo == std::partial_ordering::less);\n+    return startInternal && endInternal;\n+}\n+\n }\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/range.h b/ydb/core/tx/columnshard/engines/predicate/range.h\nindex ff84f35408a3..6f9f264b7d70 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/range.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/range.h\n@@ -28,20 +28,20 @@ class TPKRangeFilter {\n         return PredicateTo;\n     }\n \n-    std::optional<NArrow::TReplaceKey> KeyFrom(const std::shared_ptr<arrow::Schema>& key) const {\n-        return PredicateFrom.ExtractKey(key);\n-    }\n+    static TConclusion<TPKRangeFilter> Build(TPredicateContainer&& from, TPredicateContainer&& to);\n \n-    std::optional<NArrow::TReplaceKey> KeyTo(const std::shared_ptr<arrow::Schema>& key) const {\n-        return PredicateTo.ExtractKey(key);\n-    }\n+    NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;\n \n-    static std::optional<TPKRangeFilter> Build(TPredicateContainer&& from, TPredicateContainer&& to);\n+    bool IsPortionInUsage(const TPortionInfo& info) const;\n+    bool CheckPoint(const NArrow::TReplaceKey& point) const;\n \n-    NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;\n+    enum class EUsageClass {\n+        DontUsage,\n+        PartialUsage,\n+        FullUsage\n+    };\n \n-    bool IsPortionInUsage(const TPortionInfo& info, const TIndexInfo& indexInfo) const;\n-    bool IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end, const TIndexInfo& indexInfo) const;\n+    EUsageClass IsPortionInPartialUsage(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end) const;\n \n     std::set<ui32> GetColumnIds(const TIndexInfo& indexInfo) const;\n     TString DebugString() const;\ndiff --git a/ydb/core/tx/columnshard/engines/protos/portion_info.proto b/ydb/core/tx/columnshard/engines/protos/portion_info.proto\nindex dc599633eb7a..f7f38bb96ed7 100644\n--- a/ydb/core/tx/columnshard/engines/protos/portion_info.proto\n+++ b/ydb/core/tx/columnshard/engines/protos/portion_info.proto\n@@ -1,4 +1,4 @@\n-import \"ydb/core/formats/arrow/protos/ssa.proto\";\n+import \"ydb/library/formats/arrow/protos/ssa.proto\";\n \n package NKikimrTxColumnShard;\n \ndiff --git a/ydb/core/tx/columnshard/engines/protos/ya.make b/ydb/core/tx/columnshard/engines/protos/ya.make\nindex ad664077a031..5719eb76af10 100644\n--- a/ydb/core/tx/columnshard/engines/protos/ya.make\n+++ b/ydb/core/tx/columnshard/engines/protos/ya.make\n@@ -5,7 +5,7 @@ SRCS(\n )\n \n PEERDIR(\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n \n )\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h b/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h\nindex 35269dc16598..37ba57b89985 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h\n@@ -31,7 +31,7 @@ class TScanIteratorBase {\n         return {};\n     }\n     virtual bool Finished() const = 0;\n-    virtual TConclusion<std::optional<TPartialReadResult>> GetBatch() = 0;\n+    virtual TConclusion<std::shared_ptr<TPartialReadResult>> GetBatch() = 0;\n     virtual void PrepareResults() {\n \n     }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h b/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h\nindex fbcdab4d8622..3b1d545094ac 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h\n@@ -1,10 +1,12 @@\n #pragma once\n #include \"read_metadata.h\"\n+\n #include <ydb/core/protos/tx_datashard.pb.h>\n-#include <ydb/core/tx/columnshard/counters/scan.h>\n-#include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/storages_manager.h>\n+#include <ydb/core/tx/columnshard/counters/scan.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/result.h>\n+#include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n+\n #include <ydb/library/accessor/accessor.h>\n \n namespace NKikimr::NOlap::NReader {\n@@ -13,6 +15,7 @@ class TComputeShardingPolicy {\n private:\n     YDB_READONLY(ui32, ShardsCount, 0);\n     YDB_READONLY_DEF(std::vector<std::string>, ColumnNames);\n+\n public:\n     TString DebugString() const {\n         return TStringBuilder() << \"shards_count:\" << ShardsCount << \";columns=\" << JoinSeq(\",\", ColumnNames) << \";\";\n@@ -42,10 +45,12 @@ class TReadContext {\n     const NColumnShard::TConcreteScanCounters Counters;\n     TReadMetadataBase::TConstPtr ReadMetadata;\n     NResourceBroker::NSubscribe::TTaskContext ResourcesTaskContext;\n+    const ui64 ScanId;\n     const TActorId ScanActorId;\n     const TActorId ResourceSubscribeActorId;\n     const TActorId ReadCoordinatorActorId;\n     const TComputeShardingPolicy ComputeShardingPolicy;\n+\n public:\n     template <class T>\n     std::shared_ptr<const T> GetReadMetadataPtrVerifiedAs() const {\n@@ -74,6 +79,14 @@ class TReadContext {\n         return ScanActorId;\n     }\n \n+    ui64 GetScanId() const {\n+        return ScanId;\n+    }\n+\n+    bool HasLock() const {\n+        return !!ReadMetadata->GetLockId();\n+    }\n+\n     const TReadMetadataBase::TConstPtr& GetReadMetadata() const {\n         return ReadMetadata;\n     }\n@@ -86,17 +99,18 @@ class TReadContext {\n         return ResourcesTaskContext;\n     }\n \n-    TReadContext(const std::shared_ptr<IStoragesManager>& storagesManager, const NColumnShard::TConcreteScanCounters& counters, const TReadMetadataBase::TConstPtr& readMetadata,\n-        const TActorId& scanActorId, const TActorId& resourceSubscribeActorId, const TActorId& readCoordinatorActorId, const TComputeShardingPolicy& computeShardingPolicy)\n+    TReadContext(const std::shared_ptr<IStoragesManager>& storagesManager, const NColumnShard::TConcreteScanCounters& counters,\n+        const TReadMetadataBase::TConstPtr& readMetadata, const TActorId& scanActorId, const TActorId& resourceSubscribeActorId,\n+        const TActorId& readCoordinatorActorId, const TComputeShardingPolicy& computeShardingPolicy, const ui64 scanId)\n         : StoragesManager(storagesManager)\n         , Counters(counters)\n         , ReadMetadata(readMetadata)\n         , ResourcesTaskContext(\"CS::SCAN_READ\", counters.ResourcesSubscriberCounters)\n+        , ScanId(scanId)\n         , ScanActorId(scanActorId)\n         , ResourceSubscribeActorId(resourceSubscribeActorId)\n         , ReadCoordinatorActorId(readCoordinatorActorId)\n-        , ComputeShardingPolicy(computeShardingPolicy)\n-    {\n+        , ComputeShardingPolicy(computeShardingPolicy) {\n         Y_ABORT_UNLESS(ReadMetadata);\n     }\n };\n@@ -109,8 +123,9 @@ class IDataReader {\n     virtual TString DoDebugString(const bool verbose) const = 0;\n     virtual void DoAbort() = 0;\n     virtual bool DoIsFinished() const = 0;\n-    virtual std::vector<TPartialReadResult> DoExtractReadyResults(const int64_t maxRowsInBatch) = 0;\n+    virtual std::vector<std::shared_ptr<TPartialReadResult>> DoExtractReadyResults(const int64_t maxRowsInBatch) = 0;\n     virtual TConclusion<bool> DoReadNextInterval() = 0;\n+\n public:\n     IDataReader(const std::shared_ptr<TReadContext>& context);\n     virtual ~IDataReader() = default;\n@@ -153,7 +168,7 @@ class IDataReader {\n         return *result;\n     }\n \n-    std::vector<TPartialReadResult> ExtractReadyResults(const int64_t maxRowsInBatch) {\n+    std::vector<std::shared_ptr<TPartialReadResult>> ExtractReadyResults(const int64_t maxRowsInBatch) {\n         return DoExtractReadyResults(maxRowsInBatch);\n     }\n \n@@ -171,4 +186,4 @@ class IDataReader {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.cpp b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.cpp\nindex e6fc29578f1c..88416a4d214f 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.cpp\n@@ -1,21 +1,20 @@\n #include \"read_metadata.h\"\n+\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n \n namespace NKikimr::NOlap::NReader {\n \n-TDataStorageAccessor::TDataStorageAccessor(const std::unique_ptr<TInsertTable>& insertTable,\n-                                const std::unique_ptr<IColumnEngine>& index)\n+TDataStorageAccessor::TDataStorageAccessor(const std::unique_ptr<TInsertTable>& insertTable, const std::unique_ptr<IColumnEngine>& index)\n     : InsertTable(insertTable)\n-    , Index(index)\n-{}\n+    , Index(index) {\n+}\n \n std::shared_ptr<TSelectInfo> TDataStorageAccessor::Select(const TReadDescription& readDescription) const {\n     if (readDescription.ReadNothing) {\n         return std::make_shared<TSelectInfo>();\n     }\n-    return Index->Select(readDescription.PathId,\n-                            readDescription.GetSnapshot(),\n-                            readDescription.PKRangesFilter);\n+    AFL_VERIFY(readDescription.PKRangesFilter);\n+    return Index->Select(readDescription.PathId, readDescription.GetSnapshot(), *readDescription.PKRangesFilter);\n }\n \n ISnapshotSchema::TPtr TReadMetadataBase::GetLoadSchemaVerified(const TPortionInfo& portion) const {\n@@ -24,8 +23,10 @@ ISnapshotSchema::TPtr TReadMetadataBase::GetLoadSchemaVerified(const TPortionInf\n     return schema;\n }\n \n-std::vector<TCommittedBlob> TDataStorageAccessor::GetCommitedBlobs(const TReadDescription& readDescription, const std::shared_ptr<arrow::Schema>& pkSchema) const {\n-    return std::move(InsertTable->Read(readDescription.PathId, readDescription.GetSnapshot(), pkSchema));\n+std::vector<TCommittedBlob> TDataStorageAccessor::GetCommitedBlobs(const TReadDescription& readDescription,\n+    const std::shared_ptr<arrow::Schema>& pkSchema, const std::optional<ui64> lockId, const TSnapshot& reqSnapshot) const {\n+    AFL_VERIFY(readDescription.PKRangesFilter);\n+    return std::move(InsertTable->Read(readDescription.PathId, lockId, reqSnapshot, pkSchema, &*readDescription.PKRangesFilter));\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h\nindex b03982775fce..d87fcf02868e 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h\n@@ -1,12 +1,17 @@\n #pragma once\n+#include <ydb/core/tx/columnshard/engines/column_engine.h>\n+#include <ydb/core/tx/columnshard/engines/insert_table/insert_table.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/description.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h>\n-#include <ydb/core/tx/columnshard/engines/insert_table/insert_table.h>\n-#include <ydb/core/tx/columnshard/engines/column_engine.h>\n \n namespace NKikimr::NOlap {\n-    class TPortionInfo;\n+class TPortionInfo;\n }\n+\n+namespace NKikimr::NKqp::NInternalImplementation {\n+struct TEvScanData;\n+}\n+\n namespace NKikimr::NOlap::NReader {\n \n class TScanIteratorBase;\n@@ -18,10 +23,10 @@ class TDataStorageAccessor {\n     const std::unique_ptr<NOlap::IColumnEngine>& Index;\n \n public:\n-    TDataStorageAccessor(const std::unique_ptr<TInsertTable>& insertTable,\n-                                 const std::unique_ptr<IColumnEngine>& index);\n+    TDataStorageAccessor(const std::unique_ptr<TInsertTable>& insertTable, const std::unique_ptr<IColumnEngine>& index);\n     std::shared_ptr<NOlap::TSelectInfo> Select(const TReadDescription& readDescription) const;\n-    std::vector<NOlap::TCommittedBlob> GetCommitedBlobs(const TReadDescription& readDescription, const std::shared_ptr<arrow::Schema>& pkSchema) const;\n+    std::vector<NOlap::TCommittedBlob> GetCommitedBlobs(const TReadDescription& readDescription, const std::shared_ptr<arrow::Schema>& pkSchema,\n+        const std::optional<ui64> lockId, const TSnapshot& reqSnapshot) const;\n };\n \n // Holds all metadata that is needed to perform read/scan\n@@ -32,19 +37,49 @@ struct TReadMetadataBase {\n         ASC /* \"ascending\" */,\n         DESC /* \"descending\" */,\n     };\n+\n private:\n-    const ESorting Sorting = ESorting::ASC; // Sorting inside returned batches\n-    std::optional<TPKRangesFilter> PKRangesFilter;\n+    const ESorting Sorting = ESorting::ASC;   // Sorting inside returned batches\n+    std::shared_ptr<TPKRangesFilter> PKRangesFilter;\n     TProgramContainer Program;\n     std::shared_ptr<TVersionedIndex> IndexVersionsPointer;\n     TSnapshot RequestSnapshot;\n     std::optional<TGranuleShardingInfo> RequestShardingInfo;\n+    virtual void DoOnReadFinished(NColumnShard::TColumnShard& /*owner*/) const {\n+    }\n+    virtual void DoOnBeforeStartReading(NColumnShard::TColumnShard& /*owner*/) const {\n+    }\n+    virtual void DoOnReplyConstruction(const ui64 /*tabletId*/, NKqp::NInternalImplementation::TEvScanData& /*scanData*/) const {\n+    }\n \n protected:\n     std::shared_ptr<ISnapshotSchema> ResultIndexSchema;\n+    ui64 TxId = 0;\n+    std::optional<ui64> LockId;\n+\n public:\n     using TConstPtr = std::shared_ptr<const TReadMetadataBase>;\n \n+    void OnReplyConstruction(const ui64 tabletId, NKqp::NInternalImplementation::TEvScanData& scanData) const {\n+        DoOnReplyConstruction(tabletId, scanData);\n+    }\n+\n+    ui64 GetTxId() const {\n+        return TxId;\n+    }\n+\n+    std::optional<ui64> GetLockId() const {\n+        return LockId;\n+    }\n+\n+    void OnReadFinished(NColumnShard::TColumnShard& owner) const {\n+        DoOnReadFinished(owner);\n+    }\n+\n+    void OnBeforeStartReading(NColumnShard::TColumnShard& owner) const {\n+        DoOnBeforeStartReading(owner);\n+    }\n+\n     const TVersionedIndex& GetIndexVersions() const {\n         AFL_VERIFY(IndexVersionsPointer);\n         return *IndexVersionsPointer;\n@@ -54,8 +89,9 @@ struct TReadMetadataBase {\n         return RequestShardingInfo;\n     }\n \n-    void SetPKRangesFilter(const TPKRangesFilter& value) {\n-        Y_ABORT_UNLESS(IsSorted() && value.IsReverse() == IsDescSorted());\n+    void SetPKRangesFilter(const std::shared_ptr<TPKRangesFilter>& value) {\n+        AFL_VERIFY(value);\n+        Y_ABORT_UNLESS(IsSorted() && value->IsReverse() == IsDescSorted());\n         Y_ABORT_UNLESS(!PKRangesFilter);\n         PKRangesFilter = value;\n     }\n@@ -65,6 +101,11 @@ struct TReadMetadataBase {\n         return *PKRangesFilter;\n     }\n \n+    const std::shared_ptr<TPKRangesFilter>& GetPKRangesFilterPtr() const {\n+        Y_ABORT_UNLESS(!!PKRangesFilter);\n+        return PKRangesFilter;\n+    }\n+\n     ISnapshotSchema::TPtr GetResultSchema() const {\n         return ResultIndexSchema;\n     }\n@@ -75,7 +116,7 @@ struct TReadMetadataBase {\n \n     ISnapshotSchema::TPtr GetLoadSchemaVerified(const TPortionInfo& porition) const;\n \n-    std::shared_ptr<arrow::Schema> GetBlobSchema(const ui64 version) const {\n+    const std::shared_ptr<NArrow::TSchemaLite>& GetBlobSchema(const ui64 version) const {\n         return GetIndexVersions().GetSchema(version)->GetIndexInfo().ArrowSchema();\n     }\n \n@@ -91,13 +132,13 @@ struct TReadMetadataBase {\n         RequestShardingInfo = IndexVersionsPointer->GetShardingInfoOptional(pathId, RequestSnapshot);\n     }\n \n-    TReadMetadataBase(const std::shared_ptr<TVersionedIndex> index, const ESorting sorting, const TProgramContainer& ssaProgram, const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot)\n+    TReadMetadataBase(const std::shared_ptr<TVersionedIndex> index, const ESorting sorting, const TProgramContainer& ssaProgram,\n+        const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot)\n         : Sorting(sorting)\n         , Program(ssaProgram)\n         , IndexVersionsPointer(index)\n         , RequestSnapshot(requestSnapshot)\n-        , ResultIndexSchema(schema)\n-    {\n+        , ResultIndexSchema(schema) {\n     }\n     virtual ~TReadMetadataBase() = default;\n \n@@ -111,19 +152,25 @@ struct TReadMetadataBase {\n     std::set<ui32> GetProcessingColumnIds() const {\n         std::set<ui32> result;\n         for (auto&& i : GetProgram().GetProcessingColumns()) {\n-            result.emplace(ResultIndexSchema->GetIndexInfo().GetColumnId(i));\n+            result.emplace(ResultIndexSchema->GetIndexInfo().GetColumnIdVerified(i));\n         }\n         return result;\n     }\n-    bool IsAscSorted() const { return Sorting == ESorting::ASC; }\n-    bool IsDescSorted() const { return Sorting == ESorting::DESC; }\n-    bool IsSorted() const { return IsAscSorted() || IsDescSorted(); }\n+    bool IsAscSorted() const {\n+        return Sorting == ESorting::ASC;\n+    }\n+    bool IsDescSorted() const {\n+        return Sorting == ESorting::DESC;\n+    }\n+    bool IsSorted() const {\n+        return IsAscSorted() || IsDescSorted();\n+    }\n \n     virtual std::unique_ptr<TScanIteratorBase> StartScan(const std::shared_ptr<TReadContext>& readContext) const = 0;\n     virtual std::vector<TNameTypeInfo> GetKeyYqlSchema() const = 0;\n \n     // TODO:  can this only be done for base class?\n-    friend IOutputStream& operator << (IOutputStream& out, const TReadMetadataBase& meta) {\n+    friend IOutputStream& operator<<(IOutputStream& out, const TReadMetadataBase& meta) {\n         meta.Dump(out);\n         return out;\n     }\n@@ -161,7 +208,6 @@ struct TReadMetadataBase {\n         }\n         return ResultIndexSchema->GetIndexInfo().GetIndexNameOptional(entityId);\n     }\n-\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp b/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp\nindex c88a69aabc9c..00ab74fa9921 100644\n--- a/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp\n@@ -61,8 +61,7 @@ TColumnShardScan::TColumnShardScan(const TActorId& columnShardActorId, const TAc\n     , Deadline(TInstant::Now() + (timeout ? timeout + SCAN_HARD_TIMEOUT_GAP : SCAN_HARD_TIMEOUT))\n     , ScanCountersPool(scanCountersPool)\n     , Stats(NTracing::TTraceClient::GetLocalClient(\"SHARD\", ::ToString(TabletId)/*, \"SCAN_TXID:\" + ::ToString(TxId)*/))\n-    , ComputeShardingPolicy(computeShardingPolicy)\n-{\n+    , ComputeShardingPolicy(computeShardingPolicy) {\n     AFL_VERIFY(ReadMetadataRange);\n     KeyYqlSchema = ReadMetadataRange->GetKeyYqlSchema();\n }\n@@ -80,7 +79,7 @@ void TColumnShardScan::Bootstrap(const TActorContext& ctx) {\n     ReadCoordinatorActorId = ctx.Register(new NBlobOperations::NRead::TReadCoordinatorActor(TabletId, SelfId()));\n \n     std::shared_ptr<TReadContext> context = std::make_shared<TReadContext>(StoragesManager, ScanCountersPool,\n-        ReadMetadataRange, SelfId(), ResourceSubscribeActorId, ReadCoordinatorActorId, ComputeShardingPolicy);\n+        ReadMetadataRange, SelfId(), ResourceSubscribeActorId, ReadCoordinatorActorId, ComputeShardingPolicy, ScanId);\n     ScanIterator = ReadMetadataRange->StartScan(context);\n     auto startResult = ScanIterator->Start();\n     StartInstant = TMonotonic::Now();\n@@ -209,7 +208,7 @@ bool TColumnShardScan::ProduceResults() noexcept {\n         return false;\n     }\n \n-    std::optional<TPartialReadResult> resultOpt = resultConclusion.DetachResult();\n+    std::shared_ptr<TPartialReadResult> resultOpt = resultConclusion.DetachResult();\n     if (!resultOpt) {\n         ACFL_DEBUG(\"stage\", \"no data is ready yet\")(\"iterator\", ScanIterator->DebugString());\n         return false;\n@@ -243,6 +242,7 @@ bool TColumnShardScan::ProduceResults() noexcept {\n         Result->ArrowBatch = shardedBatch.GetRecordBatch();\n         Rows += batch->num_rows();\n         Bytes += NArrow::GetTableDataSize(Result->ArrowBatch);\n+        \n         ACFL_DEBUG(\"stage\", \"data_format\")(\"batch_size\", NArrow::GetTableDataSize(Result->ArrowBatch))(\"num_rows\", numRows)(\"batch_columns\", JoinSeq(\",\", batch->schema()->field_names()));\n     }\n     if (CurrentLastReadKey) {\n@@ -274,9 +274,9 @@ void TColumnShardScan::ContinueProcessing() {\n             if (ChunksLimiter.HasMore()) {\n                 auto g = Stats->MakeGuard(\"Finish\");\n                 MakeResult();\n+                Finish(NColumnShard::TScanCounters::EStatusFinish::Success);\n                 SendResult(false, true);\n                 ScanIterator.reset();\n-                Finish(NColumnShard::TScanCounters::EStatusFinish::Success);\n             }\n         } else {\n             while (true) {\n@@ -375,6 +375,7 @@ bool TColumnShardScan::SendResult(bool pageFault, bool lastBatch) {\n         Y_ABORT_UNLESS(AckReceivedInstant);\n         ScanCountersPool.AckWaitingInfo(TMonotonic::Now() - *AckReceivedInstant);\n     }\n+    ReadMetadataRange->OnReplyConstruction(TabletId, *Result);\n     AckReceivedInstant.reset();\n \n     Send(ScanComputeActorId, Result.Release(), IEventHandle::FlagTrackDelivery); // TODO: FlagSubscribeOnSession ?\n@@ -402,7 +403,7 @@ void TColumnShardScan::Finish(const NColumnShard::TScanCounters::EStatusFinish s\n \n     Send(ColumnShardActorId, new NColumnShard::TEvPrivate::TEvReadFinished(RequestCookie, TxId));\n     AFL_VERIFY(StartInstant);\n-    ScanCountersPool.OnScanDuration(status, TMonotonic::Now() - *StartInstant);\n+    ScanCountersPool.OnScanFinished(status, TMonotonic::Now() - *StartInstant);\n     ReportStats();\n     PassAway();\n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/description.h b/ydb/core/tx/columnshard/engines/reader/common/description.h\nindex 704b4bd101a9..c180dcc8d067 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/description.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common/description.h\n@@ -13,13 +13,15 @@ struct TReadDescription {\n     TProgramContainer Program;\n public:\n     // Table\n+    ui64 TxId = 0;\n+    std::optional<ui64> LockId;\n     ui64 PathId = 0;\n     TString TableName;\n     bool ReadNothing = false;\n     // Less[OrEqual], Greater[OrEqual] or both\n     // There's complex logic in NKikimr::TTableRange comparison that could be emulated only with separated compare\n     // operations with potentially different columns. We have to remove columns to support -Inf (Null) and +Inf.\n-    NOlap::TPKRangesFilter PKRangesFilter;\n+    std::shared_ptr<NOlap::TPKRangesFilter> PKRangesFilter;\n     NYql::NDqProto::EDqStatsMode StatsMode = NYql::NDqProto::EDqStatsMode::DQ_STATS_MODE_NONE;\n \n     // List of columns\n@@ -28,7 +30,7 @@ struct TReadDescription {\n     \n     TReadDescription(const TSnapshot& snapshot, const bool isReverse)\n         : Snapshot(snapshot)\n-        , PKRangesFilter(isReverse) {\n+        , PKRangesFilter(std::make_shared<NOlap::TPKRangesFilter>(isReverse)) {\n     }\n \n     void SetProgram(TProgramContainer&& value) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/result.cpp b/ydb/core/tx/columnshard/engines/reader/common/result.cpp\nindex 484165c67b54..e81e86bfc9d0 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/result.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common/result.cpp\n@@ -4,19 +4,19 @@ namespace NKikimr::NOlap::NReader {\n \n class TCurrentBatch {\n private:\n-    std::vector<TPartialReadResult> Results;\n+    std::vector<std::shared_ptr<TPartialReadResult>> Results;\n     ui64 RecordsCount = 0;\n public:\n     ui64 GetRecordsCount() const {\n         return RecordsCount;\n     }\n \n-    void AddChunk(TPartialReadResult&& res) {\n-        RecordsCount += res.GetRecordsCount();\n+    void AddChunk(std::shared_ptr<TPartialReadResult>&& res) {\n+        RecordsCount += res->GetRecordsCount();\n         Results.emplace_back(std::move(res));\n     }\n \n-    void FillResult(std::vector<TPartialReadResult>& result) const {\n+    void FillResult(std::vector<std::shared_ptr<TPartialReadResult>>& result) const {\n         if (Results.empty()) {\n             return;\n         }\n@@ -26,11 +26,12 @@ class TCurrentBatch {\n     }\n };\n \n-std::vector<TPartialReadResult> TPartialReadResult::SplitResults(std::vector<TPartialReadResult>&& resultsExt, const ui32 maxRecordsInResult) {\n+std::vector<std::shared_ptr<TPartialReadResult>> TPartialReadResult::SplitResults(\n+    std::vector<std::shared_ptr<TPartialReadResult>>&& resultsExt, const ui32 maxRecordsInResult) {\n     std::vector<TCurrentBatch> resultBatches;\n     TCurrentBatch currentBatch;\n     for (auto&& i : resultsExt) {\n-        AFL_VERIFY(i.GetRecordsCount());\n+        AFL_VERIFY(i->GetRecordsCount());\n         currentBatch.AddChunk(std::move(i));\n         if (currentBatch.GetRecordsCount() >= maxRecordsInResult) {\n             resultBatches.emplace_back(std::move(currentBatch));\n@@ -41,7 +42,7 @@ std::vector<TPartialReadResult> TPartialReadResult::SplitResults(std::vector<TPa\n         resultBatches.emplace_back(std::move(currentBatch));\n     }\n \n-    std::vector<TPartialReadResult> result;\n+    std::vector<std::shared_ptr<TPartialReadResult>> result;\n     for (auto&& i : resultBatches) {\n         i.FillResult(result);\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/result.h b/ydb/core/tx/columnshard/engines/reader/common/result.h\nindex 5780c0f2fc24..e3028b01b5ad 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/result.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common/result.h\n@@ -3,15 +3,17 @@\n #include <ydb/core/tx/columnshard/counters/scan.h>\n #include <ydb/core/tx/columnshard/engines/predicate/filter.h>\n #include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n #include <ydb/core/tx/program/program.h>\n \n #include <ydb/library/yql/dq/actors/protos/dq_stats.pb.h>\n namespace NKikimr::NOlap::NReader {\n \n // Represents a batch of rows produced by ASC or DESC scan with applied filters and partial aggregation\n-class TPartialReadResult {\n+class TPartialReadResult: public TNonCopyable {\n private:\n-    YDB_READONLY_DEF(std::vector<std::shared_ptr<NColumnShard::TReaderResourcesGuard>>, ResourcesGuards);\n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>, ResourcesGuard);\n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TGroupGuard>, GroupGuard);\n     NArrow::TShardedRecordBatch ResultBatch;\n \n     // This 1-row batch contains the last key that was read while producing the ResultBatch.\n@@ -33,12 +35,6 @@ class TPartialReadResult {\n         return ResultBatch.GetRecordBatch();\n     }\n \n-    const std::shared_ptr<NColumnShard::TReaderResourcesGuard>& GetResourcesGuardOnly() const {\n-        AFL_VERIFY(ResourcesGuards.size() == 1);\n-        AFL_VERIFY(!!ResourcesGuards.front());\n-        return ResourcesGuards.front();\n-    }\n-\n     ui64 GetMemorySize() const {\n         return ResultBatch.GetMemorySize();\n     }\n@@ -47,7 +43,8 @@ class TPartialReadResult {\n         return ResultBatch.GetRecordsCount();\n     }\n \n-    static std::vector<TPartialReadResult> SplitResults(std::vector<TPartialReadResult>&& resultsExt, const ui32 maxRecordsInResult);\n+    static std::vector<std::shared_ptr<TPartialReadResult>> SplitResults(\n+        std::vector<std::shared_ptr<TPartialReadResult>>&& resultsExt, const ui32 maxRecordsInResult);\n \n     const NArrow::TShardedRecordBatch& GetShardedBatch() const {\n         return ResultBatch;\n@@ -57,30 +54,22 @@ class TPartialReadResult {\n         return LastReadKey;\n     }\n \n-    explicit TPartialReadResult(const std::vector<std::shared_ptr<NColumnShard::TReaderResourcesGuard>>& resourcesGuards,\n-        const NArrow::TShardedRecordBatch& batch, std::shared_ptr<arrow::RecordBatch> lastKey, const std::optional<ui32> notFinishedIntervalIdx)\n-        : ResourcesGuards(resourcesGuards)\n+    explicit TPartialReadResult(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& resourcesGuard,\n+        std::shared_ptr<NGroupedMemoryManager::TGroupGuard>&& gGuard, const NArrow::TShardedRecordBatch& batch,\n+        std::shared_ptr<arrow::RecordBatch> lastKey, const std::optional<ui32> notFinishedIntervalIdx)\n+        : ResourcesGuard(std::move(resourcesGuard))\n+        , GroupGuard(std::move(gGuard))\n         , ResultBatch(batch)\n         , LastReadKey(lastKey)\n         , NotFinishedIntervalIdx(notFinishedIntervalIdx) {\n-        for (auto&& i : ResourcesGuards) {\n-            AFL_VERIFY(i);\n-        }\n         Y_ABORT_UNLESS(ResultBatch.GetRecordsCount());\n         Y_ABORT_UNLESS(LastReadKey);\n         Y_ABORT_UNLESS(LastReadKey->num_rows() == 1);\n     }\n \n-    explicit TPartialReadResult(const std::shared_ptr<NColumnShard::TReaderResourcesGuard>& resourcesGuards,\n-        const NArrow::TShardedRecordBatch& batch, std::shared_ptr<arrow::RecordBatch> lastKey, const std::optional<ui32> notFinishedIntervalIdx)\n-        : TPartialReadResult(\n-              std::vector<std::shared_ptr<NColumnShard::TReaderResourcesGuard>>({ resourcesGuards }), batch, lastKey, notFinishedIntervalIdx) {\n-        AFL_VERIFY(resourcesGuards);\n-    }\n-\n     explicit TPartialReadResult(\n         const NArrow::TShardedRecordBatch& batch, std::shared_ptr<arrow::RecordBatch> lastKey, const std::optional<ui32> notFinishedIntervalIdx)\n-        : TPartialReadResult(std::vector<std::shared_ptr<NColumnShard::TReaderResourcesGuard>>(), batch, lastKey, notFinishedIntervalIdx) {\n+        : TPartialReadResult(nullptr, nullptr, batch, lastKey, notFinishedIntervalIdx) {\n     }\n };\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp\nindex 87315949329a..ae28340c9932 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp\n@@ -1,11 +1,13 @@\n #include \"constructor.h\"\n-#include \"resolver.h\"\n #include \"read_metadata.h\"\n+#include \"resolver.h\"\n+\n #include <ydb/core/tx/columnshard/columnshard_impl.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n-NKikimr::TConclusionStatus TIndexScannerConstructor::ParseProgram(const TVersionedIndex* vIndex, const NKikimrTxDataShard::TEvKqpScan& proto, TReadDescription& read) const {\n+NKikimr::TConclusionStatus TIndexScannerConstructor::ParseProgram(\n+    const TVersionedIndex* vIndex, const NKikimrTxDataShard::TEvKqpScan& proto, TReadDescription& read) const {\n     AFL_VERIFY(vIndex);\n     auto& indexInfo = vIndex->GetSchema(Snapshot)->GetIndexInfo();\n     TIndexColumnResolver columnResolver(indexInfo);\n@@ -17,26 +19,29 @@ std::vector<TNameTypeInfo> TIndexScannerConstructor::GetPrimaryKeyScheme(const N\n     return indexInfo.GetPrimaryKeyColumns();\n }\n \n-NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> TIndexScannerConstructor::DoBuildReadMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n+NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> TIndexScannerConstructor::DoBuildReadMetadata(\n+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n     auto& insertTable = self->InsertTable;\n     auto& index = self->TablesManager.GetPrimaryIndex();\n     if (!insertTable || !index) {\n         return std::shared_ptr<TReadMetadataBase>();\n     }\n \n-    if (read.GetSnapshot().GetPlanStep() < self->GetMinReadStep()) {\n-        return TConclusionStatus::Fail(TStringBuilder() << \"Snapshot too old: \" << read.GetSnapshot());\n+    if (read.GetSnapshot().GetPlanInstant() < self->GetMinReadSnapshot().GetPlanInstant()) {\n+        return TConclusionStatus::Fail(TStringBuilder() << \"Snapshot too old: \" << read.GetSnapshot() << \". CS min read snapshot: \"\n+                                                        << self->GetMinReadSnapshot() << \". now: \" << TInstant::Now());\n     }\n \n     TDataStorageAccessor dataAccessor(insertTable, index);\n-    auto readMetadata = std::make_shared<TReadMetadata>(index->CopyVersionedIndexPtr(), read.GetSnapshot(),\n+    AFL_VERIFY(read.PathId);\n+    auto readMetadata = std::make_shared<TReadMetadata>(read.PathId, index->CopyVersionedIndexPtr(), read.GetSnapshot(),\n         IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC, read.GetProgram());\n \n-    auto initResult = readMetadata->Init(read, dataAccessor);\n+    auto initResult = readMetadata->Init(self, read, dataAccessor);\n     if (!initResult) {\n         return initResult;\n     }\n-    return dynamic_pointer_cast<TReadMetadataBase>(readMetadata);\n+    return static_pointer_cast<TReadMetadataBase>(readMetadata);\n }\n \n-}\n\\ No newline at end of file\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.cpp\nindex 076b69c7f49a..c24fbe0577a7 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.cpp\n@@ -1,6 +1,11 @@\n #include \"read_metadata.h\"\n+\n+#include <ydb/core/kqp/compute_actor/kqp_compute_events.h>\n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n #include <ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.h>\n #include <ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h>\n+#include <ydb/core/tx/columnshard/transactions/locks/read_finished.h>\n+#include <ydb/core/tx/columnshard/transactions/locks/read_start.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n@@ -8,16 +13,36 @@ std::unique_ptr<TScanIteratorBase> TReadMetadata::StartScan(const std::shared_pt\n     return std::make_unique<TColumnShardScanIterator>(readContext, readContext->GetReadMetadataPtrVerifiedAs<TReadMetadata>());\n }\n \n-TConclusionStatus TReadMetadata::Init(const TReadDescription& readDescription, const TDataStorageAccessor& dataAccessor) {\n+TConclusionStatus TReadMetadata::Init(\n+    const NColumnShard::TColumnShard* owner, const TReadDescription& readDescription, const TDataStorageAccessor& dataAccessor) {\n     SetPKRangesFilter(readDescription.PKRangesFilter);\n     InitShardingInfo(readDescription.PathId);\n+    TxId = readDescription.TxId;\n+    LockId = readDescription.LockId;\n+    if (LockId) {\n+        owner->GetOperationsManager().RegisterLock(*LockId, owner->Generation());\n+        LockSharingInfo = owner->GetOperationsManager().GetLockVerified(*LockId).GetSharingInfo();\n+    }\n \n     /// @note We could have column name changes between schema versions:\n     /// Add '1:foo', Drop '1:foo', Add '2:foo'. Drop should hide '1:foo' from reads.\n     /// It's expected that we have only one version on 'foo' in blob and could split them by schema {planStep:txId}.\n     /// So '1:foo' would be omitted in blob records for the column in new snapshots. And '2:foo' - in old ones.\n     /// It's not possible for blobs with several columns. There should be a special logic for them.\n-    CommittedBlobs = dataAccessor.GetCommitedBlobs(readDescription, ResultIndexSchema->GetIndexInfo().GetReplaceKey());\n+    CommittedBlobs =\n+        dataAccessor.GetCommitedBlobs(readDescription, ResultIndexSchema->GetIndexInfo().GetReplaceKey(), LockId, GetRequestSnapshot());\n+\n+    if (LockId) {\n+        for (auto&& i : CommittedBlobs) {\n+            if (auto writeId = i.GetWriteIdOptional()) {\n+                if (owner->HasLongTxWrites(*writeId)) {\n+                } else {\n+                    auto op = owner->GetOperationsManager().GetOperationByInsertWriteIdVerified(*writeId);\n+                    AddWriteIdToCheck(*writeId, op->GetLockId());\n+                }\n+            }\n+        }\n+    }\n \n     SelectInfo = dataAccessor.Select(readDescription);\n     StatsMode = readDescription.StatsMode;\n@@ -41,7 +66,7 @@ std::set<ui32> TReadMetadata::GetPKColumnIds() const {\n     std::set<ui32> result;\n     auto& indexInfo = ResultIndexSchema->GetIndexInfo();\n     for (auto&& i : indexInfo.GetPrimaryKeyColumns()) {\n-        Y_ABORT_UNLESS(result.emplace(indexInfo.GetColumnId(i.first)).second);\n+        Y_ABORT_UNLESS(result.emplace(indexInfo.GetColumnIdVerified(i.first)).second);\n     }\n     return result;\n }\n@@ -51,8 +76,57 @@ std::shared_ptr<IDataReader> TReadMetadata::BuildReader(const std::shared_ptr<TR\n }\n \n NArrow::NMerger::TSortableBatchPosition TReadMetadata::BuildSortedPosition(const NArrow::TReplaceKey& key) const {\n-    return NArrow::NMerger::TSortableBatchPosition(key.ToBatch(GetReplaceKey()), 0,\n-        GetReplaceKey()->field_names(), {}, IsDescSorted());\n+    return NArrow::NMerger::TSortableBatchPosition(key.ToBatch(GetReplaceKey()), 0, GetReplaceKey()->field_names(), {}, IsDescSorted());\n+}\n+\n+void TReadMetadata::DoOnReadFinished(NColumnShard::TColumnShard& owner) const {\n+    if (!GetLockId()) {\n+        return;\n+    }\n+    const ui64 lock = *GetLockId();\n+    if (GetBrokenWithCommitted()) {\n+        owner.GetOperationsManager().GetLockVerified(lock).SetBroken();\n+    } else {\n+        NOlap::NTxInteractions::TTxConflicts conflicts;\n+        for (auto&& i : GetConflictableLockIds()) {\n+            conflicts.Add(i, lock);\n+        }\n+        auto writer = std::make_shared<NOlap::NTxInteractions::TEvReadFinishedWriter>(PathId, conflicts);\n+        owner.GetOperationsManager().AddEventForLock(owner, lock, writer);\n+    }\n }\n \n+void TReadMetadata::DoOnBeforeStartReading(NColumnShard::TColumnShard& owner) const {\n+    if (!LockId) {\n+        return;\n+    }\n+    auto evWriter = std::make_shared<NOlap::NTxInteractions::TEvReadStartWriter>(\n+        PathId, GetResultSchema()->GetIndexInfo().GetPrimaryKey(), GetPKRangesFilterPtr(), GetConflictableLockIds());\n+    owner.GetOperationsManager().AddEventForLock(owner, *LockId, evWriter);\n }\n+\n+void TReadMetadata::DoOnReplyConstruction(const ui64 tabletId, NKqp::NInternalImplementation::TEvScanData& scanData) const {\n+    if (LockSharingInfo) {\n+        NKikimrDataEvents::TLock lockInfo;\n+        lockInfo.SetLockId(LockSharingInfo->GetLockId());\n+        lockInfo.SetGeneration(LockSharingInfo->GetGeneration());\n+        lockInfo.SetDataShard(tabletId);\n+        lockInfo.SetCounter(LockSharingInfo->GetCounter());\n+        lockInfo.SetPathId(PathId);\n+        lockInfo.SetHasWrites(LockSharingInfo->HasWrites());\n+        if (LockSharingInfo->IsBroken()) {\n+            scanData.LocksInfo.BrokenLocks.emplace_back(std::move(lockInfo));\n+        } else {\n+            scanData.LocksInfo.Locks.emplace_back(std::move(lockInfo));\n+        }\n+    }\n+}\n+\n+bool TReadMetadata::IsMyUncommitted(const TInsertWriteId writeId) const {\n+    AFL_VERIFY(LockSharingInfo);\n+    auto it = ConflictedWriteIds.find(writeId);\n+    AFL_VERIFY(it != ConflictedWriteIds.end());\n+    return it->second.GetLockId() == LockSharingInfo->GetLockId();\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.h\nindex 371a09d73102..5f5ad70db296 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.h\n@@ -1,18 +1,104 @@\n #pragma once\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>\n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/stats.h>\n #include <ydb/core/formats/arrow/reader/position.h>\n \n+namespace NKikimr::NColumnShard {\n+class TLockSharingInfo;\n+}\n+\n namespace NKikimr::NOlap::NReader::NPlain {\n \n // Holds all metadata that is needed to perform read/scan\n struct TReadMetadata : public TReadMetadataBase {\n     using TBase = TReadMetadataBase;\n+\n+private:\n+    const ui64 PathId;\n+    std::shared_ptr<TAtomicCounter> BrokenWithCommitted = std::make_shared<TAtomicCounter>();\n+    std::shared_ptr<NColumnShard::TLockSharingInfo> LockSharingInfo;\n+\n+    class TWriteIdInfo {\n+    private:\n+        const ui64 LockId;\n+        std::shared_ptr<TAtomicCounter> Conflicts;\n+\n+    public:\n+        TWriteIdInfo(const ui64 lockId, const std::shared_ptr<TAtomicCounter>& counter)\n+            : LockId(lockId)\n+            , Conflicts(counter) {\n+        }\n+\n+        ui64 GetLockId() const {\n+            return LockId;\n+        }\n+\n+        void MarkAsConflictable() const {\n+            Conflicts->Inc();\n+        }\n+\n+        bool IsConflictable() const {\n+            return Conflicts->Val();\n+        }\n+    };\n+\n+    THashMap<ui64, std::shared_ptr<TAtomicCounter>> LockConflictCounters;\n+    THashMap<TInsertWriteId, TWriteIdInfo> ConflictedWriteIds;\n+\n+    virtual void DoOnReadFinished(NColumnShard::TColumnShard& owner) const override;\n+    virtual void DoOnBeforeStartReading(NColumnShard::TColumnShard& owner) const override;\n+    virtual void DoOnReplyConstruction(const ui64 tabletId, NKqp::NInternalImplementation::TEvScanData& scanData) const override;\n+\n public:\n     using TConstPtr = std::shared_ptr<const TReadMetadata>;\n \n+    bool GetBrokenWithCommitted() const {\n+        return BrokenWithCommitted->Val();\n+    }\n+    THashSet<ui64> GetConflictableLockIds() const {\n+        THashSet<ui64> result;\n+        for (auto&& i : ConflictedWriteIds) {\n+            if (i.second.IsConflictable()) {\n+                result.emplace(i.second.GetLockId());\n+            }\n+        }\n+        return result;\n+    }\n+\n+    bool IsLockConflictable(const ui64 lockId) const {\n+        auto it = LockConflictCounters.find(lockId);\n+        AFL_VERIFY(it != LockConflictCounters.end());\n+        return it->second->Val();\n+    }\n+\n+    bool IsWriteConflictable(const TInsertWriteId writeId) const {\n+        auto it = ConflictedWriteIds.find(writeId);\n+        AFL_VERIFY(it != ConflictedWriteIds.end());\n+        return it->second.IsConflictable();\n+    }\n+\n+    void AddWriteIdToCheck(const TInsertWriteId writeId, const ui64 lockId) {\n+        auto it = LockConflictCounters.find(lockId);\n+        if (it == LockConflictCounters.end()) {\n+            it = LockConflictCounters.emplace(lockId, std::make_shared<TAtomicCounter>()).first;\n+        }\n+        AFL_VERIFY(ConflictedWriteIds.emplace(writeId, TWriteIdInfo(lockId, it->second)).second);\n+    }\n+\n+    [[nodiscard]] bool IsMyUncommitted(const TInsertWriteId writeId) const;\n+\n+    void SetConflictedWriteId(const TInsertWriteId writeId) const {\n+        auto it = ConflictedWriteIds.find(writeId);\n+        AFL_VERIFY(it != ConflictedWriteIds.end());\n+        it->second.MarkAsConflictable();\n+    }\n+\n+    void SetBrokenWithCommitted() const {\n+        BrokenWithCommitted->Inc();\n+    }\n+\n     NArrow::NMerger::TSortableBatchPosition BuildSortedPosition(const NArrow::TReplaceKey& key) const;\n     std::shared_ptr<IDataReader> BuildReader(const std::shared_ptr<TReadContext>& context) const;\n \n@@ -20,13 +106,18 @@ struct TReadMetadata : public TReadMetadataBase {\n         return GetProgram().HasProcessingColumnIds();\n     }\n \n+    ui64 GetPathId() const {\n+        return PathId;\n+    }\n+\n     std::shared_ptr<TSelectInfo> SelectInfo;\n     NYql::NDqProto::EDqStatsMode StatsMode = NYql::NDqProto::EDqStatsMode::DQ_STATS_MODE_NONE;\n     std::vector<TCommittedBlob> CommittedBlobs;\n     std::shared_ptr<TReadStats> ReadStats;\n \n-    TReadMetadata(const std::shared_ptr<TVersionedIndex> info, const TSnapshot& snapshot, const ESorting sorting, const TProgramContainer& ssaProgram)\n+    TReadMetadata(const ui64 pathId, const std::shared_ptr<TVersionedIndex> info, const TSnapshot& snapshot, const ESorting sorting, const TProgramContainer& ssaProgram)\n         : TBase(info, sorting, ssaProgram, info->GetSchema(snapshot), snapshot)\n+        , PathId(pathId)\n         , ReadStats(std::make_shared<TReadStats>())\n     {\n     }\n@@ -35,7 +126,7 @@ struct TReadMetadata : public TReadMetadataBase {\n         return GetResultSchema()->GetIndexInfo().GetPrimaryKeyColumns();\n     }\n \n-    TConclusionStatus Init(const TReadDescription& readDescription, const TDataStorageAccessor& dataAccessor);\n+    TConclusionStatus Init(const NColumnShard::TColumnShard* owner, const TReadDescription& readDescription, const TDataStorageAccessor& dataAccessor);\n \n     std::vector<std::string> GetColumnsOrder() const {\n         auto schema = GetResultSchema();\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/resolver.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/resolver.h\nindex c5a2998a54c1..3890edc6c361 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/resolver.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/resolver.h\n@@ -20,10 +20,6 @@ class TIndexColumnResolver: public IColumnResolver {\n         return IndexInfo.GetColumnName(id, required);\n     }\n \n-    const NTable::TScheme::TTableSchema& GetSchema() const override {\n-        return IndexInfo;\n-    }\n-\n     NSsa::TColumnInfo GetDefaultColumn() const override {\n         return NSsa::TColumnInfo::Original((ui32)NOlap::TIndexInfo::ESpecialColumn::PLAN_STEP, NOlap::TIndexInfo::SPEC_COL_PLAN_STEP);\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/ya.make b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/ya.make\nindex b91efa4346d8..1ab826414813 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/ya.make\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/ya.make\n@@ -8,6 +8,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/tx/columnshard/engines/reader/abstract\n+    ydb/core/kqp/compute_actor\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.cpp\nindex f100c8f89041..24ef9a452e4c 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.cpp\n@@ -11,7 +11,7 @@ TString TColumnsSet::DebugString() const {\n         << \");\";\n }\n \n-NKikimr::NOlap::NReader::NPlain::TColumnsSet TColumnsSet::operator-(const TColumnsSet& external) const {\n+TColumnsSet TColumnsSet::operator-(const TColumnsSet& external) const {\n     if (external.IsEmpty() || IsEmpty()) {\n         return *this;\n     }\n@@ -30,7 +30,7 @@ NKikimr::NOlap::NReader::NPlain::TColumnsSet TColumnsSet::operator-(const TColum\n     return result;\n }\n \n-NKikimr::NOlap::NReader::NPlain::TColumnsSet TColumnsSet::operator+(const TColumnsSet& external) const {\n+TColumnsSet TColumnsSet::operator+(const TColumnsSet& external) const {\n     if (external.IsEmpty()) {\n         return *this;\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.h\nindex 08d7ac103d80..98e77f4971e9 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/columns_set.h\n@@ -1,15 +1,24 @@\n #pragma once\n-#include <ydb/library/accessor/accessor.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n #include <ydb/core/tx/columnshard/engines/scheme/abstract_scheme.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+\n #include <util/string/join.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n+enum class EStageFeaturesIndexes {\n+    Filter = 0,\n+    Fetching = 1,\n+    Merge = 2\n+};\n+\n class TIndexesSet {\n private:\n     YDB_READONLY_DEF(std::vector<ui32>, IndexIds);\n     YDB_READONLY_DEF(std::set<ui32>, IndexIdsSet);\n+\n public:\n     TIndexesSet(const std::set<ui32>& indexIds)\n         : IndexIds(indexIds.begin(), indexIds.end())\n@@ -18,8 +27,8 @@ class TIndexesSet {\n     }\n \n     TIndexesSet(const ui32& indexId)\n-        : IndexIds({indexId})\n-        , IndexIdsSet({indexId}) {\n+        : IndexIds({ indexId })\n+        , IndexIdsSet({ indexId }) {\n     }\n \n     ui32 GetIndexesCount() const {\n@@ -31,78 +40,70 @@ class TIndexesSet {\n     }\n };\n \n-class TColumnsSet {\n-private:\n-    YDB_READONLY_DEF(std::set<ui32>, ColumnIds);\n-    YDB_READONLY_DEF(std::set<TString>, ColumnNames);\n-    std::vector<TString> ColumnNamesVector;\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::Schema>, Schema);\n-    ISnapshotSchema::TPtr FullReadSchema;\n-    YDB_READONLY_DEF(ISnapshotSchema::TPtr, FilteredSchema);\n-\n-    void Rebuild();\n+class TColumnsSetIds {\n+protected:\n+    std::set<ui32> ColumnIds;\n \n public:\n-    TColumnsSet() = default;\n-    bool IsEmpty() const {\n-        return ColumnIds.empty();\n+    const std::set<ui32>& GetColumnIds() const {\n+        return ColumnIds;\n     }\n \n-    bool operator!() const {\n-        return IsEmpty();\n+    TString DebugString() const {\n+        return JoinSeq(\",\", ColumnIds);\n     }\n \n-    const std::vector<TString>& GetColumnNamesVector() const {\n-        return ColumnNamesVector;\n+    TColumnsSetIds(const std::set<ui32>& ids)\n+        : ColumnIds(ids) {\n     }\n-\n-    ui32 GetColumnsCount() const {\n-        return ColumnIds.size();\n+    TColumnsSetIds() = default;\n+    TColumnsSetIds(std::set<ui32>&& ids)\n+        : ColumnIds(std::move(ids)) {\n     }\n \n-    bool ColumnsOnly(const std::vector<std::string>& fieldNames) const;\n-\n-    TColumnsSet(const std::set<ui32>& columnIds, const TIndexInfo& indexInfo, const ISnapshotSchema::TPtr& fullReadSchema)\n-        : ColumnIds(columnIds)\n-        , FullReadSchema(fullReadSchema)\n-    {\n-        Schema = indexInfo.GetColumnsSchema(ColumnIds);\n-        Rebuild();\n+    TColumnsSetIds(const std::vector<ui32>& ids)\n+        : ColumnIds(ids.begin(), ids.end()) {\n     }\n \n-    TColumnsSet(const std::vector<ui32>& columnIds, const TIndexInfo& indexInfo, const ISnapshotSchema::TPtr& fullReadSchema)\n-        : ColumnIds(columnIds.begin(), columnIds.end())\n-        , FullReadSchema(fullReadSchema)\n-    {\n-        Schema = indexInfo.GetColumnsSchema(ColumnIds);\n-        Rebuild();\n+    TColumnsSetIds operator+(const TColumnsSetIds& external) const {\n+        TColumnsSetIds result = *this;\n+        result.ColumnIds.insert(external.ColumnIds.begin(), external.ColumnIds.end());\n+        return result;\n     }\n \n-    const ISnapshotSchema& GetFilteredSchemaVerified() const {\n-        AFL_VERIFY(FilteredSchema);\n-        return *FilteredSchema;\n+    TColumnsSetIds operator-(const TColumnsSetIds& external) const {\n+        TColumnsSetIds result = *this;\n+        for (auto&& i : external.ColumnIds) {\n+            result.ColumnIds.erase(i);\n+        }\n+        return result;\n+    }\n+    bool IsEmpty() const {\n+        return ColumnIds.empty();\n     }\n \n-    const std::shared_ptr<ISnapshotSchema>& GetFilteredSchemaPtrVerified() const {\n-        AFL_VERIFY(FilteredSchema);\n-        return FilteredSchema;\n+    bool operator!() const {\n+        return IsEmpty();\n+    }\n+    ui32 GetColumnsCount() const {\n+        return ColumnIds.size();\n     }\n \n-    bool Contains(const std::shared_ptr<TColumnsSet>& columnsSet) const {\n+    bool Contains(const std::shared_ptr<TColumnsSetIds>& columnsSet) const {\n         if (!columnsSet) {\n             return true;\n         }\n         return Contains(*columnsSet);\n     }\n \n-    bool IsEqual(const std::shared_ptr<TColumnsSet>& columnsSet) const {\n+    bool IsEqual(const std::shared_ptr<TColumnsSetIds>& columnsSet) const {\n         if (!columnsSet) {\n             return false;\n         }\n         return IsEqual(*columnsSet);\n     }\n \n-    bool Contains(const TColumnsSet& columnsSet) const {\n+    bool Contains(const TColumnsSetIds& columnsSet) const {\n         for (auto&& i : columnsSet.ColumnIds) {\n             if (!ColumnIds.contains(i)) {\n                 return false;\n@@ -111,7 +112,7 @@ class TColumnsSet {\n         return true;\n     }\n \n-    bool Cross(const TColumnsSet& columnsSet) const {\n+    bool Cross(const TColumnsSetIds& columnsSet) const {\n         for (auto&& i : columnsSet.ColumnIds) {\n             if (ColumnIds.contains(i)) {\n                 return true;\n@@ -120,7 +121,7 @@ class TColumnsSet {\n         return false;\n     }\n \n-    std::set<ui32> Intersect(const TColumnsSet& columnsSet) const {\n+    std::set<ui32> Intersect(const TColumnsSetIds& columnsSet) const {\n         std::set<ui32> result;\n         for (auto&& i : columnsSet.ColumnIds) {\n             if (ColumnIds.contains(i)) {\n@@ -130,7 +131,7 @@ class TColumnsSet {\n         return result;\n     }\n \n-    bool IsEqual(const TColumnsSet& columnsSet) const {\n+    bool IsEqual(const TColumnsSetIds& columnsSet) const {\n         if (columnsSet.GetColumnIds().size() != ColumnIds.size()) {\n             return false;\n         }\n@@ -145,6 +146,56 @@ class TColumnsSet {\n         }\n         return true;\n     }\n+};\n+\n+class TColumnsSet: public TColumnsSetIds {\n+private:\n+    using TBase = TColumnsSetIds;\n+    YDB_READONLY_DEF(std::set<TString>, ColumnNames);\n+    std::vector<TString> ColumnNamesVector;\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Schema>, Schema);\n+    ISnapshotSchema::TPtr FullReadSchema;\n+    YDB_READONLY_DEF(ISnapshotSchema::TPtr, FilteredSchema);\n+\n+    void Rebuild();\n+\n+public:\n+    TColumnsSet() = default;\n+    const std::vector<TString>& GetColumnNamesVector() const {\n+        return ColumnNamesVector;\n+    }\n+\n+    bool ColumnsOnly(const std::vector<std::string>& fieldNames) const;\n+\n+    std::shared_ptr<TColumnsSet> BuildSamePtr(const std::set<ui32>& columnIds) const {\n+        return std::make_shared<TColumnsSet>(columnIds, FullReadSchema);\n+    }\n+\n+    TColumnsSet(const std::set<ui32>& columnIds, const ISnapshotSchema::TPtr& fullReadSchema)\n+        : TBase(columnIds)\n+        , FullReadSchema(fullReadSchema) {\n+        AFL_VERIFY(!!FullReadSchema);\n+        Schema = FullReadSchema->GetIndexInfo().GetColumnsSchema(ColumnIds);\n+        Rebuild();\n+    }\n+\n+    TColumnsSet(const std::vector<ui32>& columnIds, const ISnapshotSchema::TPtr& fullReadSchema)\n+        : TBase(columnIds)\n+        , FullReadSchema(fullReadSchema) {\n+        AFL_VERIFY(!!FullReadSchema);\n+        Schema = FullReadSchema->GetIndexInfo().GetColumnsSchema(ColumnIds);\n+        Rebuild();\n+    }\n+\n+    const ISnapshotSchema& GetFilteredSchemaVerified() const {\n+        AFL_VERIFY(FilteredSchema);\n+        return *FilteredSchema;\n+    }\n+\n+    const std::shared_ptr<ISnapshotSchema>& GetFilteredSchemaPtrVerified() const {\n+        AFL_VERIFY(FilteredSchema);\n+        return FilteredSchema;\n+    }\n \n     TString DebugString() const;\n \n@@ -153,4 +204,4 @@ class TColumnsSet {\n     TColumnsSet operator-(const TColumnsSet& external) const;\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp\nindex 098e60b9626b..0efd8bfbb9d2 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp\n@@ -1,20 +1,22 @@\n #include \"context.h\"\n #include \"source.h\"\n \n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n+\n namespace NKikimr::NOlap::NReader::NPlain {\n \n std::unique_ptr<NArrow::NMerger::TMergePartialStream> TSpecialReadContext::BuildMerger() const {\n-    return std::make_unique<NArrow::NMerger::TMergePartialStream>(ReadMetadata->GetReplaceKey(), ProgramInputColumns->GetSchema(), CommonContext->IsReverse(), \n-        IIndexInfo::GetSnapshotColumnNames());\n+    return std::make_unique<NArrow::NMerger::TMergePartialStream>(\n+        ReadMetadata->GetReplaceKey(), ProgramInputColumns->GetSchema(), CommonContext->IsReverse(), IIndexInfo::GetSnapshotColumnNames());\n }\n \n-ui64 TSpecialReadContext::GetMemoryForSources(const THashMap<ui32, std::shared_ptr<IDataSource>>& sources, const bool isExclusive) {\n+ui64 TSpecialReadContext::GetMemoryForSources(const THashMap<ui32, std::shared_ptr<IDataSource>>& sources) {\n     ui64 result = 0;\n     bool hasSequentialReadSources = false;\n     for (auto&& i : sources) {\n         auto fetchingPlan = GetColumnsFetchingPlan(i.second);\n         AFL_VERIFY(i.second->GetIntervalsCount());\n-        const ui64 sourceMemory = std::max<ui64>(1, fetchingPlan->PredictRawBytes(i.second) / i.second->GetIntervalsCount());\n+        const ui64 sourceMemory = std::max<ui64>(1, i.second->GetResourceGuardsMemory() / i.second->GetIntervalsCount());\n         if (!i.second->IsSourceInMemory()) {\n             hasSequentialReadSources = true;\n         }\n@@ -23,17 +25,23 @@ ui64 TSpecialReadContext::GetMemoryForSources(const THashMap<ui32, std::shared_p\n     AFL_VERIFY(result);\n     if (hasSequentialReadSources) {\n         result += ReadSequentiallyBufferSize;\n-    } else {\n-        if (!isExclusive && !CommonContext->IsReverse()) {\n-            result = 2 * result;   // due to in time we will have data in original portion + data in merged(or reversed) interval\n-        }\n     }\n     return result;\n }\n \n-std::shared_ptr<TFetchingScript> TSpecialReadContext::GetColumnsFetchingPlan(const std::shared_ptr<IDataSource>& source) const {\n-    const bool needSnapshots = !source->GetExclusiveIntervalOnly() || ReadMetadata->GetRequestSnapshot() < source->GetRecordSnapshotMax() || !source->IsSourceInMemory();\n-    const bool partialUsageByPK = ReadMetadata->GetPKRangesFilter().IsPortionInPartialUsage(source->GetStartReplaceKey(), source->GetFinishReplaceKey(), ReadMetadata->GetIndexInfo());\n+std::shared_ptr<TFetchingScript> TSpecialReadContext::GetColumnsFetchingPlan(const std::shared_ptr<IDataSource>& source) {\n+    const bool needSnapshots = !source->GetExclusiveIntervalOnly() || ReadMetadata->GetRequestSnapshot() < source->GetRecordSnapshotMax() ||\n+                               !source->IsSourceInMemory();\n+    const bool partialUsageByPK = [&]() {\n+        switch (source->GetUsageClass()) {\n+            case TPKRangeFilter::EUsageClass::PartialUsage:\n+                return true;\n+            case TPKRangeFilter::EUsageClass::DontUsage:\n+                return true;\n+            case TPKRangeFilter::EUsageClass::FullUsage:\n+                return false;\n+        }\n+    }();\n     const bool useIndexes = (IndexChecker ? source->HasIndexes(IndexChecker->GetIndexIds()) : false);\n     const bool isWholeExclusiveSource = source->GetExclusiveIntervalOnly() && source->IsSourceInMemory();\n     const bool hasDeletions = source->GetHasDeletions();\n@@ -44,16 +52,18 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::GetColumnsFetchingPlan(con\n             needShardingFilter = true;\n         }\n     }\n-    if (auto result = CacheFetchingScripts\n-        [needSnapshots ? 1 : 0][isWholeExclusiveSource ? 1 : 0]\n-        [partialUsageByPK ? 1 : 0][useIndexes ? 1 : 0]\n-        [needShardingFilter ? 1 : 0][hasDeletions ? 1 : 0]) {\n-//        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"SS\", needSnapshots)(\"PK\", partialUsageByPK)(\"IDX\", useIndexes)(\"SHARDING\", needShardingFilter)\n-//            (\"EXCL\", source->GetExclusiveIntervalOnly())(\"MEM\", source->IsSourceInMemory())(\"result\", result->DebugString());\n-        return result;\n+    auto result = CacheFetchingScripts[needSnapshots ? 1 : 0][isWholeExclusiveSource ? 1 : 0][partialUsageByPK ? 1 : 0][useIndexes ? 1 : 0]\n+                                      [needShardingFilter ? 1 : 0][hasDeletions ? 1 : 0];\n+    if (!result) {\n+        result = BuildColumnsFetchingPlan(needSnapshots, isWholeExclusiveSource, partialUsageByPK, useIndexes, needShardingFilter, hasDeletions);\n+        CacheFetchingScripts[needSnapshots ? 1 : 0][isWholeExclusiveSource ? 1 : 0][partialUsageByPK ? 1 : 0][useIndexes ? 1 : 0]\n+                            [needShardingFilter ? 1 : 0][hasDeletions ? 1 : 0] = result;\n     }\n-    {\n-        std::shared_ptr<TFetchingScript> result = std::make_shared<TFetchingScript>();\n+    AFL_VERIFY(result);\n+    if (*result) {\n+        return *result;\n+    } else {\n+        std::shared_ptr<TFetchingScript> result = std::make_shared<TFetchingScript>(*this);\n         result->SetBranchName(\"FAKE\");\n         result->AddStep(std::make_shared<TBuildFakeSpec>(source->GetRecordsCount()));\n         return result;\n@@ -62,27 +72,42 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::GetColumnsFetchingPlan(con\n \n class TColumnsAccumulator {\n private:\n-    TColumnsSet FetchingReadyColumns;\n-    TColumnsSet AssemblerReadyColumns;\n+    TColumnsSetIds FetchingReadyColumns;\n+    TColumnsSetIds AssemblerReadyColumns;\n+    ISnapshotSchema::TPtr FullSchema;\n+    std::shared_ptr<TColumnsSetIds> GuaranteeNotOptional;\n \n public:\n-    bool AddFetchingStep(TFetchingScript& script, const TColumnsSet& columns) {\n-        auto actualColumns = columns - FetchingReadyColumns;\n-        FetchingReadyColumns = FetchingReadyColumns + columns;\n+    TColumnsAccumulator(const std::shared_ptr<TColumnsSetIds>& guaranteeNotOptional, const ISnapshotSchema::TPtr& fullSchema)\n+        : FullSchema(fullSchema)\n+        , GuaranteeNotOptional(guaranteeNotOptional) {\n+    }\n+\n+    bool AddFetchingStep(TFetchingScript& script, const TColumnsSetIds& columns, const EStageFeaturesIndexes& stage) {\n+        auto actualColumns = (TColumnsSetIds)columns - FetchingReadyColumns;\n+        FetchingReadyColumns = FetchingReadyColumns + (TColumnsSetIds)columns;\n         if (!actualColumns.IsEmpty()) {\n-            auto actualSet = std::make_shared<TColumnsSet>(actualColumns);\n-            script.AddStep(std::make_shared<TColumnBlobsFetchingStep>(actualSet));\n+            script.AddStep(std::make_shared<TAllocateMemoryStep>(actualColumns, stage));\n+            script.AddStep(std::make_shared<TColumnBlobsFetchingStep>(actualColumns));\n             return true;\n         }\n         return false;\n     }\n-    bool AddAssembleStep(TFetchingScript& script, const TColumnsSet& columns, const TString& purposeId, const bool optional) {\n-        auto actualColumns = columns - AssemblerReadyColumns;\n+    bool AddAssembleStep(TFetchingScript& script, const TColumnsSetIds& columns, const TString& purposeId, const bool optional) {\n+        auto actualColumns = (TColumnsSetIds)columns - AssemblerReadyColumns;\n         AssemblerReadyColumns = AssemblerReadyColumns + columns;\n         if (!actualColumns.IsEmpty()) {\n-            auto actualSet = std::make_shared<TColumnsSet>(actualColumns);\n+            auto actualSet = std::make_shared<TColumnsSet>(actualColumns.GetColumnIds(), FullSchema);\n             if (optional) {\n-                script.AddStep(std::make_shared<TOptionalAssemblerStep>(actualSet, purposeId));\n+                const auto notOptionalColumnIds = GuaranteeNotOptional->Intersect(*actualSet);\n+                if (notOptionalColumnIds.size()) {\n+                    std::shared_ptr<TColumnsSet> cross = actualSet->BuildSamePtr(notOptionalColumnIds);\n+                    script.AddStep(std::make_shared<TAssemblerStep>(cross, purposeId));\n+                    *actualSet = *actualSet - *cross;\n+                }\n+                if (!actualSet->IsEmpty()) {\n+                    script.AddStep(std::make_shared<TOptionalAssemblerStep>(actualSet, purposeId));\n+                }\n             } else {\n                 script.AddStep(std::make_shared<TAssemblerStep>(actualSet, purposeId));\n             }\n@@ -92,25 +117,29 @@ class TColumnsAccumulator {\n     }\n };\n \n-std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(const bool needSnapshots, const bool exclusiveSource, const bool partialUsageByPredicateExt, const bool useIndexes,\n-                                                                               const bool needFilterSharding, const bool needFilterDeletion) const {\n-    std::shared_ptr<TFetchingScript> result = std::make_shared<TFetchingScript>();\n+std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(const bool needSnapshots, const bool exclusiveSource,\n+    const bool partialUsageByPredicateExt, const bool useIndexes, const bool needFilterSharding, const bool needFilterDeletion) const {\n+    std::shared_ptr<TFetchingScript> result = std::make_shared<TFetchingScript>(*this);\n     const bool partialUsageByPredicate = partialUsageByPredicateExt && PredicateColumns->GetColumnsCount();\n     if (!!IndexChecker && useIndexes && exclusiveSource) {\n         result->AddStep(std::make_shared<TIndexBlobsFetchingStep>(std::make_shared<TIndexesSet>(IndexChecker->GetIndexIds())));\n         result->AddStep(std::make_shared<TApplyIndexStep>(IndexChecker));\n     }\n     bool hasFilterSharding = false;\n-    TColumnsAccumulator acc;\n+    TColumnsAccumulator acc(MergeColumns, ReadMetadata->GetResultSchema());\n     if (needFilterSharding && !ShardingColumns->IsEmpty()) {\n         hasFilterSharding = true;\n-        acc.AddFetchingStep(*result, *ShardingColumns);\n-        acc.AddAssembleStep(*result, *ShardingColumns, \"SPEC_SHARDING\", false);\n+        TColumnsSetIds columnsFetch = *ShardingColumns;\n+        if (!exclusiveSource) {\n+            columnsFetch = columnsFetch + *PKColumns + *SpecColumns;\n+        }\n+        acc.AddFetchingStep(*result, columnsFetch, EStageFeaturesIndexes::Filter);\n+        acc.AddAssembleStep(*result, columnsFetch, \"SPEC_SHARDING\", false);\n         result->AddStep(std::make_shared<TShardingFilter>());\n     }\n     if (!EFColumns->GetColumnsCount() && !partialUsageByPredicate) {\n         result->SetBranchName(\"simple\");\n-        TColumnsSet columnsFetch = *FFColumns;\n+        TColumnsSetIds columnsFetch = *FFColumns;\n         if (needFilterDeletion) {\n             columnsFetch = columnsFetch + *DeletionColumns;\n         }\n@@ -118,21 +147,25 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n             columnsFetch = columnsFetch + *SpecColumns;\n         }\n         if (!exclusiveSource) {\n-            columnsFetch = columnsFetch + *PKColumns + *SpecColumns;\n+            columnsFetch = columnsFetch + *MergeColumns;\n         } else {\n             if (columnsFetch.GetColumnsCount() == 1 && SpecColumns->Contains(columnsFetch) && !hasFilterSharding) {\n                 return nullptr;\n             }\n         }\n         if (columnsFetch.GetColumnsCount() || hasFilterSharding || needFilterDeletion) {\n-            acc.AddFetchingStep(*result, columnsFetch);\n+            acc.AddFetchingStep(*result, columnsFetch, EStageFeaturesIndexes::Fetching);\n+            if (needSnapshots) {\n+                acc.AddAssembleStep(*result, *SpecColumns, \"SPEC\", false);\n+                result->AddStep(std::make_shared<TSnapshotFilter>());\n+            }\n+            if (!exclusiveSource) {\n+                acc.AddAssembleStep(*result, *MergeColumns, \"LAST_PK\", false);\n+            }\n             if (needFilterDeletion) {\n                 acc.AddAssembleStep(*result, *DeletionColumns, \"SPEC_DELETION\", false);\n                 result->AddStep(std::make_shared<TDeletionFilter>());\n             }\n-            if (!exclusiveSource) {\n-                acc.AddAssembleStep(*result, *PKColumns + *SpecColumns, \"LAST_PK\", false);\n-            }\n             acc.AddAssembleStep(*result, columnsFetch, \"LAST\", true);\n         } else {\n             return nullptr;\n@@ -151,32 +184,35 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n         }\n \n         AFL_VERIFY(columnsFetch.GetColumnsCount());\n-        acc.AddFetchingStep(*result, columnsFetch);\n+        acc.AddFetchingStep(*result, columnsFetch, EStageFeaturesIndexes::Filter);\n \n         if (needFilterDeletion) {\n             acc.AddAssembleStep(*result, *DeletionColumns, \"SPEC_DELETION\", false);\n             result->AddStep(std::make_shared<TDeletionFilter>());\n         }\n-        if (needSnapshots || FFColumns->Cross(*SpecColumns)) {\n-            acc.AddAssembleStep(*result, *SpecColumns, \"SPEC\", false);\n-            result->AddStep(std::make_shared<TSnapshotFilter>());\n-        }\n         if (partialUsageByPredicate) {\n             acc.AddAssembleStep(*result, *PredicateColumns, \"PREDICATE\", false);\n             result->AddStep(std::make_shared<TPredicateFilter>());\n         }\n+        if (needSnapshots || FFColumns->Cross(*SpecColumns)) {\n+            acc.AddAssembleStep(*result, *SpecColumns, \"SPEC\", false);\n+            result->AddStep(std::make_shared<TSnapshotFilter>());\n+        }\n         for (auto&& i : ReadMetadata->GetProgram().GetSteps()) {\n             if (i->GetFilterOriginalColumnIds().empty()) {\n                 break;\n             }\n-            TColumnsSet stepColumnIds(i->GetFilterOriginalColumnIds(), ReadMetadata->GetIndexInfo(), ReadMetadata->GetResultSchema());\n+            TColumnsSet stepColumnIds(i->GetFilterOriginalColumnIds(), ReadMetadata->GetResultSchema());\n             acc.AddAssembleStep(*result, stepColumnIds, \"EF\", true);\n             result->AddStep(std::make_shared<TFilterProgramStep>(i));\n             if (!i->IsFilterOnly()) {\n                 break;\n             }\n         }\n-        acc.AddFetchingStep(*result, *FFColumns);\n+        if (GetReadMetadata()->Limit) {\n+            result->AddStep(std::make_shared<TFilterCutLimit>(GetReadMetadata()->Limit, GetReadMetadata()->IsDescSorted()));\n+        }\n+        acc.AddFetchingStep(*result, *FFColumns, EStageFeaturesIndexes::Fetching);\n         acc.AddAssembleStep(*result, *FFColumns, \"LAST\", true);\n     } else {\n         result->SetBranchName(\"merge\");\n@@ -185,17 +221,17 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n             columnsFetch = columnsFetch + *DeletionColumns;\n         }\n         AFL_VERIFY(columnsFetch.GetColumnsCount());\n-        acc.AddFetchingStep(*result, columnsFetch);\n+        acc.AddFetchingStep(*result, columnsFetch, EStageFeaturesIndexes::Filter);\n \n-        if (needFilterDeletion) {\n-            acc.AddAssembleStep(*result, *DeletionColumns, \"SPEC_DELETION\", false);\n-            result->AddStep(std::make_shared<TDeletionFilter>());\n-        }\n         acc.AddAssembleStep(*result, *SpecColumns, \"SPEC\", false);\n+        acc.AddAssembleStep(*result, *PKColumns, \"PK\", false);\n         if (needSnapshots) {\n             result->AddStep(std::make_shared<TSnapshotFilter>());\n         }\n-        acc.AddAssembleStep(*result, *PKColumns, \"PK\", false);\n+        if (needFilterDeletion) {\n+            acc.AddAssembleStep(*result, *DeletionColumns, \"SPEC_DELETION\", false);\n+            result->AddStep(std::make_shared<TDeletionFilter>());\n+        }\n         if (partialUsageByPredicate) {\n             result->AddStep(std::make_shared<TPredicateFilter>());\n         }\n@@ -203,14 +239,14 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n             if (i->GetFilterOriginalColumnIds().empty()) {\n                 break;\n             }\n-            TColumnsSet stepColumnIds(i->GetFilterOriginalColumnIds(), ReadMetadata->GetIndexInfo(), ReadMetadata->GetResultSchema());\n+            TColumnsSet stepColumnIds(i->GetFilterOriginalColumnIds(), ReadMetadata->GetResultSchema());\n             acc.AddAssembleStep(*result, stepColumnIds, \"EF\", true);\n             result->AddStep(std::make_shared<TFilterProgramStep>(i));\n             if (!i->IsFilterOnly()) {\n                 break;\n             }\n         }\n-        acc.AddFetchingStep(*result, *FFColumns);\n+        acc.AddFetchingStep(*result, *FFColumns, EStageFeaturesIndexes::Fetching);\n         acc.AddAssembleStep(*result, *FFColumns, \"LAST\", true);\n     }\n     return result;\n@@ -218,42 +254,72 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n \n TSpecialReadContext::TSpecialReadContext(const std::shared_ptr<TReadContext>& commonContext)\n     : CommonContext(commonContext) {\n+\n     ReadMetadata = dynamic_pointer_cast<const TReadMetadata>(CommonContext->GetReadMetadata());\n     Y_ABORT_UNLESS(ReadMetadata);\n     Y_ABORT_UNLESS(ReadMetadata->SelectInfo);\n \n+    double kffFilter = 0.45;\n+    double kffFetching = 0.45;\n+    double kffMerge = 0.10;\n+    TString stagePrefix;\n+    if (ReadMetadata->GetEarlyFilterColumnIds().size()) {\n+        stagePrefix = \"EF\";\n+        kffFilter = 0.7;\n+        kffFetching = 0.15;\n+        kffMerge = 0.15;\n+    } else {\n+        stagePrefix = \"FO\";\n+        kffFilter = 0.1;\n+        kffFetching = 0.75;\n+        kffMerge = 0.15;\n+    }\n+\n+    std::vector<std::shared_ptr<NGroupedMemoryManager::TStageFeatures>> stages = { \n+        NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildStageFeatures(\n+            stagePrefix + \"::FILTER\", kffFilter * TGlobalLimits::ScanMemoryLimit),\n+        NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildStageFeatures(\n+            stagePrefix + \"::FETCHING\", kffFetching * TGlobalLimits::ScanMemoryLimit),\n+        NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildStageFeatures(stagePrefix + \"::MERGE\", kffMerge * TGlobalLimits::ScanMemoryLimit)\n+    };\n+    ProcessMemoryGuard =\n+        NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildProcessGuard(CommonContext->GetReadMetadata()->GetTxId(), stages);\n+    ProcessScopeGuard =\n+        NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildScopeGuard(CommonContext->GetReadMetadata()->GetTxId(), GetCommonContext()->GetScanId());\n+\n     auto readSchema = ReadMetadata->GetResultSchema();\n-    SpecColumns = std::make_shared<TColumnsSet>(TIndexInfo::GetSnapshotColumnIdsSet(), ReadMetadata->GetIndexInfo(), readSchema);\n+    SpecColumns = std::make_shared<TColumnsSet>(TIndexInfo::GetSnapshotColumnIdsSet(), readSchema);\n     IndexChecker = ReadMetadata->GetProgram().GetIndexChecker();\n     {\n         auto predicateColumns = ReadMetadata->GetPKRangesFilter().GetColumnIds(ReadMetadata->GetIndexInfo());\n         if (predicateColumns.size()) {\n-            PredicateColumns = std::make_shared<TColumnsSet>(predicateColumns, ReadMetadata->GetIndexInfo(), readSchema);\n+            PredicateColumns = std::make_shared<TColumnsSet>(predicateColumns, readSchema);\n         } else {\n             PredicateColumns = std::make_shared<TColumnsSet>();\n         }\n     }\n     {\n-        std::set<ui32> columnIds = {NPortion::TSpecialColumns::SPEC_COL_DELETE_FLAG_INDEX};\n-        DeletionColumns = std::make_shared<TColumnsSet>(columnIds, ReadMetadata->GetIndexInfo(), ReadMetadata->GetResultSchema());\n+        std::set<ui32> columnIds = { NPortion::TSpecialColumns::SPEC_COL_DELETE_FLAG_INDEX };\n+        DeletionColumns = std::make_shared<TColumnsSet>(columnIds, ReadMetadata->GetResultSchema());\n     }\n \n     if (!!ReadMetadata->GetRequestShardingInfo()) {\n-        auto shardingColumnIds = ReadMetadata->GetIndexInfo().GetColumnIdsVerified(ReadMetadata->GetRequestShardingInfo()->GetShardingInfo()->GetColumnNames());\n-        ShardingColumns = std::make_shared<TColumnsSet>(shardingColumnIds, ReadMetadata->GetIndexInfo(), ReadMetadata->GetResultSchema());\n+        auto shardingColumnIds =\n+            ReadMetadata->GetIndexInfo().GetColumnIdsVerified(ReadMetadata->GetRequestShardingInfo()->GetShardingInfo()->GetColumnNames());\n+        ShardingColumns = std::make_shared<TColumnsSet>(shardingColumnIds, ReadMetadata->GetResultSchema());\n     } else {\n         ShardingColumns = std::make_shared<TColumnsSet>();\n     }\n     {\n         auto efColumns = ReadMetadata->GetEarlyFilterColumnIds();\n         if (efColumns.size()) {\n-            EFColumns = std::make_shared<TColumnsSet>(efColumns, ReadMetadata->GetIndexInfo(), readSchema);\n+            EFColumns = std::make_shared<TColumnsSet>(efColumns, readSchema);\n         } else {\n             EFColumns = std::make_shared<TColumnsSet>();\n         }\n     }\n     if (ReadMetadata->HasProcessingColumnIds()) {\n-        FFColumns = std::make_shared<TColumnsSet>(ReadMetadata->GetProcessingColumnIds(), ReadMetadata->GetIndexInfo(), readSchema);\n+        FFColumns = std::make_shared<TColumnsSet>(ReadMetadata->GetProcessingColumnIds(), readSchema);\n         if (SpecColumns->Contains(*FFColumns) && !EFColumns->IsEmpty()) {\n             FFColumns = std::make_shared<TColumnsSet>(*EFColumns + *SpecColumns);\n             AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"ff_modified\", FFColumns->DebugString());\n@@ -270,18 +336,35 @@ TSpecialReadContext::TSpecialReadContext(const std::shared_ptr<TReadContext>& co\n         ProgramInputColumns = FFColumns;\n     }\n \n-    PKColumns = std::make_shared<TColumnsSet>(ReadMetadata->GetPKColumnIds(), ReadMetadata->GetIndexInfo(), readSchema);\n+    PKColumns = std::make_shared<TColumnsSet>(ReadMetadata->GetPKColumnIds(), readSchema);\n     MergeColumns = std::make_shared<TColumnsSet>(*PKColumns + *SpecColumns);\n \n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"columns_context_info\", DebugString());\n+}\n+\n+TString TSpecialReadContext::DebugString() const {\n+    TStringBuilder sb;\n+    sb << \"ef=\" << EFColumns->DebugString() << \";\"\n+       << \"sharding=\" << ShardingColumns->DebugString() << \";\"\n+       << \"pk=\" << PKColumns->DebugString() << \";\"\n+       << \"ff=\" << FFColumns->DebugString() << \";\"\n+       << \"program_input=\" << ProgramInputColumns->DebugString() << \";\";\n+    return sb;\n+}\n+\n+TString TSpecialReadContext::ProfileDebugString() const {\n+    TStringBuilder sb;\n     const auto GetBit = [](const ui32 val, const ui32 pos) -> ui32 {\n         return (val & (1 << pos)) ? 1 : 0;\n     };\n \n-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"columns_context_info\", DebugString());\n-    for (ui32 i = 0; i < (1 << 7); ++i) {\n-        CacheFetchingScripts[GetBit(i, 0)][GetBit(i, 1)][GetBit(i, 2)][GetBit(i, 3)][GetBit(i, 4)][GetBit(i, 5)]\n-            = BuildColumnsFetchingPlan(GetBit(i, 0), GetBit(i, 1), GetBit(i, 2), GetBit(i, 3), GetBit(i, 4), GetBit(i, 5));\n+    for (ui32 i = 0; i < (1 << 6); ++i) {\n+        auto script = CacheFetchingScripts[GetBit(i, 0)][GetBit(i, 1)][GetBit(i, 2)][GetBit(i, 3)][GetBit(i, 4)][GetBit(i, 5)];\n+        if (script && *script) {\n+            sb << (*script)->DebugString() << \";\";\n+        }\n     }\n+    return sb;\n }\n \n }   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h\nindex 5a869c5fc78e..1ae41c039808 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h\n@@ -1,6 +1,7 @@\n #pragma once\n #include \"columns_set.h\"\n #include \"fetching.h\"\n+#include <ydb/core/tx/columnshard/common/limits.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>\n #include <ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/read_metadata.h>\n #include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n@@ -13,6 +14,8 @@ class IDataSource;\n class TSpecialReadContext {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<TReadContext>, CommonContext);\n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TProcessGuard>, ProcessMemoryGuard);\n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TScopeGuard>, ProcessScopeGuard);\n \n     YDB_READONLY_DEF(std::shared_ptr<TColumnsSet>, SpecColumns);\n     YDB_READONLY_DEF(std::shared_ptr<TColumnsSet>, MergeColumns);\n@@ -24,41 +27,58 @@ class TSpecialReadContext {\n     YDB_READONLY_DEF(std::shared_ptr<TColumnsSet>, FFColumns);\n     YDB_READONLY_DEF(std::shared_ptr<TColumnsSet>, ProgramInputColumns);\n \n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TStageFeatures>, MergeStageMemory);\n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TStageFeatures>, FilterStageMemory);\n+    YDB_READONLY_DEF(std::shared_ptr<NGroupedMemoryManager::TStageFeatures>, FetchingStageMemory);\n+\n+    TAtomic AbortFlag = 0;\n     NIndexes::TIndexCheckerContainer IndexChecker;\n     TReadMetadata::TConstPtr ReadMetadata;\n     std::shared_ptr<TColumnsSet> EmptyColumns = std::make_shared<TColumnsSet>();\n     std::shared_ptr<TFetchingScript> BuildColumnsFetchingPlan(const bool needSnapshotsFilter, const bool exclusiveSource, \n         const bool partialUsageByPredicate, const bool useIndexes, const bool needFilterSharding, const bool needFilterDeletion) const;\n-    std::array<std::array<std::array<std::array<std::array<std::array<std::shared_ptr<TFetchingScript>, 2>, 2>, 2>, 2>, 2>, 2> CacheFetchingScripts;\n+    std::array<std::array<std::array<std::array<std::array<std::array<std::optional<std::shared_ptr<TFetchingScript>>, 2>, 2>, 2>, 2>, 2>, 2>\n+        CacheFetchingScripts;\n \n public:\n-    static const inline ui64 DefaultRejectMemoryIntervalLimit = ((ui64)3) << 30;\n-    static const inline ui64 DefaultReduceMemoryIntervalLimit = DefaultRejectMemoryIntervalLimit;\n-    static const inline ui64 DefaultReadSequentiallyBufferSize = ((ui64)8) << 20;\n-\n-    const ui64 ReduceMemoryIntervalLimit = NYDBTest::TControllers::GetColumnShardController()->GetReduceMemoryIntervalLimit(DefaultReduceMemoryIntervalLimit);\n-    const ui64 RejectMemoryIntervalLimit = NYDBTest::TControllers::GetColumnShardController()->GetRejectMemoryIntervalLimit(DefaultRejectMemoryIntervalLimit);\n-    const ui64 ReadSequentiallyBufferSize = DefaultReadSequentiallyBufferSize;\n+    const ui64 ReduceMemoryIntervalLimit = NYDBTest::TControllers::GetColumnShardController()->GetReduceMemoryIntervalLimit();\n+    const ui64 RejectMemoryIntervalLimit = NYDBTest::TControllers::GetColumnShardController()->GetRejectMemoryIntervalLimit();\n+    const ui64 ReadSequentiallyBufferSize = TGlobalLimits::DefaultReadSequentiallyBufferSize;\n \n-    ui64 GetMemoryForSources(const THashMap<ui32, std::shared_ptr<IDataSource>>& sources, const bool isExclusive);\n+    ui64 GetProcessMemoryControlId() const {\n+        AFL_VERIFY(ProcessMemoryGuard);\n+        return ProcessMemoryGuard->GetProcessId();\n+    }\n+    ui64 GetMemoryForSources(const THashMap<ui32, std::shared_ptr<IDataSource>>& sources);\n+    ui64 GetRequestedMemoryBytes() const {\n+        return MergeStageMemory->GetFullMemory() + FilterStageMemory->GetFullMemory() + FetchingStageMemory->GetFullMemory();\n+    }\n \n     const TReadMetadata::TConstPtr& GetReadMetadata() const {\n         return ReadMetadata;\n     }\n \n-    std::unique_ptr<NArrow::NMerger::TMergePartialStream> BuildMerger() const;\n+    bool IsAborted() const {\n+        return AtomicGet(AbortFlag);\n+    }\n \n-    TString DebugString() const {\n-        return TStringBuilder() << \"ef=\" << EFColumns->DebugString() << \";\"\n-                                << \"sharding=\" << ShardingColumns->DebugString() << \";\"\n-                                << \"pk=\" << PKColumns->DebugString() << \";\"\n-                                << \"ff=\" << FFColumns->DebugString() << \";\"\n-                                << \"program_input=\" << ProgramInputColumns->DebugString();\n+    void Abort() {\n+        AtomicSet(AbortFlag, 1);\n     }\n \n+    ~TSpecialReadContext() {\n+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"profile\", ProfileDebugString());\n+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"fetching\", DebugString());\n+    }\n+\n+    std::unique_ptr<NArrow::NMerger::TMergePartialStream> BuildMerger() const;\n+\n+    TString DebugString() const;\n+    TString ProfileDebugString() const;\n+\n     TSpecialReadContext(const std::shared_ptr<TReadContext>& commonContext);\n \n-    std::shared_ptr<TFetchingScript> GetColumnsFetchingPlan(const std::shared_ptr<IDataSource>& source) const;\n+    std::shared_ptr<TFetchingScript> GetColumnsFetchingPlan(const std::shared_ptr<IDataSource>& source);\n };\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.cpp\nindex e647c77313e7..bf38c466b75b 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.cpp\n@@ -1,7 +1,8 @@\n #include \"fetched_data.h\"\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n-#include <ydb/core/formats/arrow/common/accessor.h>\n+\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n \n namespace NKikimr::NOlap {\n \n@@ -11,10 +12,10 @@ void TFetchedData::SyncTableColumns(const std::vector<std::shared_ptr<arrow::Fie\n             continue;\n         }\n         Table\n-            ->AddField(i, std::make_shared<NArrow::NAccessor::TTrivialArray>(\n-                              NArrow::TThreadSimpleArraysCache::Get(i->type(), schema.GetExternalDefaultValueVerified(i->name()), Table->num_rows())))\n+            ->AddField(i, std::make_shared<NArrow::NAccessor::TTrivialArray>(NArrow::TThreadSimpleArraysCache::Get(\n+                              i->type(), schema.GetExternalDefaultValueVerified(i->name()), Table->num_rows())))\n             .Validate();\n     }\n }\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.h\nindex adde885f1468..b535c2bc4673 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetched_data.h\n@@ -1,14 +1,17 @@\n #pragma once\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/table.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n #include <ydb/core/formats/arrow/arrow_filter.h>\n #include <ydb/core/formats/arrow/common/container.h>\n+#include <ydb/core/formats/arrow/size_calcer.h>\n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/blobs_reader/task.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n+\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/actors/core/log.h>\n \n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/table.h>\n+\n namespace NKikimr::NOlap {\n \n class TFetchedData {\n@@ -18,11 +21,17 @@ class TFetchedData {\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TGeneralContainer>, Table);\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TColumnFilter>, Filter);\n     YDB_READONLY(bool, UseFilter, false);\n+\n public:\n     TFetchedData(const bool useFilter)\n-        : UseFilter(useFilter)\n-    {\n+        : UseFilter(useFilter) {\n+    }\n \n+    ui32 GetFilteredCount(const ui32 recordsCount, const ui32 defLimit) const {\n+        if (!Filter) {\n+            return std::min(defLimit, recordsCount);\n+        }\n+        return Filter->GetFilteredCount().value_or(recordsCount);\n     }\n \n     void SyncTableColumns(const std::vector<std::shared_ptr<arrow::Field>>& fields, const ISnapshotSchema& schema);\n@@ -60,6 +69,11 @@ class TFetchedData {\n         return (Filter && Filter->IsTotalDenyFilter()) || (Table && !Table->num_rows());\n     }\n \n+    void Clear() {\n+        Filter = std::make_shared<NArrow::TColumnFilter>(NArrow::TColumnFilter::BuildDenyFilter());\n+        Table = nullptr;\n+    }\n+\n     void AddFilter(const std::shared_ptr<NArrow::TColumnFilter>& filter) {\n         if (!filter) {\n             return;\n@@ -67,6 +81,31 @@ class TFetchedData {\n         return AddFilter(*filter);\n     }\n \n+    void CutFilter(const ui32 recordsCount, const ui32 limit, const bool reverse) {\n+        auto filter = std::make_shared<NArrow::TColumnFilter>(NArrow::TColumnFilter::BuildAllowFilter());\n+        ui32 recordsCountImpl = Filter ? Filter->GetFilteredCount().value_or(recordsCount) : recordsCount;\n+        if (recordsCountImpl < limit) {\n+            return;\n+        }\n+        if (reverse) {\n+            filter->Add(false, recordsCountImpl - limit);\n+            filter->Add(true, limit);\n+        } else {\n+            filter->Add(true, limit);\n+            filter->Add(false, recordsCountImpl - limit);\n+        }\n+        if (Filter) {\n+            if (UseFilter) {\n+                AddFilter(*filter);\n+            } else {\n+                AddFilter(Filter->CombineSequentialAnd(*filter));\n+            }\n+        } else {\n+            AddFilter(*filter);\n+        }\n+        \n+    }\n+\n     void AddFilter(const NArrow::TColumnFilter& filter) {\n         if (UseFilter && Table) {\n             AFL_VERIFY(filter.Apply(Table));\n@@ -106,13 +145,13 @@ class TFetchedData {\n             AFL_VERIFY(mergeResult.IsSuccess())(\"error\", mergeResult.GetErrorMessage());\n         }\n     }\n-\n };\n \n class TFetchedResult {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TGeneralContainer>, Batch);\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TColumnFilter>, NotAppliedFilter);\n+\n public:\n     TFetchedResult(std::unique_ptr<TFetchedData>&& data)\n         : Batch(data->GetTable())\n@@ -124,4 +163,4 @@ class TFetchedResult {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp\nindex 7ce1bc9b6595..2d0ec349aa6a 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp\n@@ -1,7 +1,10 @@\n #include \"fetching.h\"\n #include \"source.h\"\n+\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n #include <ydb/core/tx/columnshard/engines/filter.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/core/tx/conveyor/usage/service.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n \n #include <ydb/library/yql/minikql/mkql_terminator.h>\n \n@@ -16,7 +19,7 @@ bool TStepAction::DoApply(IDataReader& /*owner*/) const {\n }\n \n TConclusionStatus TStepAction::DoExecuteImpl() {\n-    if (Source->IsAborted()) {\n+    if (Source->GetContext()->IsAborted()) {\n         return TConclusionStatus::Success();\n     }\n     auto executeResult = Cursor.Execute(Source);\n@@ -30,20 +33,31 @@ TConclusionStatus TStepAction::DoExecuteImpl() {\n     return TConclusionStatus::Success();\n }\n \n-TConclusion<bool> TColumnBlobsFetchingStep::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const {\n+TConclusion<bool> TColumnBlobsFetchingStep::DoExecuteInplace(\n+    const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const {\n     return !source->StartFetchingColumns(source, step, Columns);\n }\n \n ui64 TColumnBlobsFetchingStep::DoPredictRawBytes(const std::shared_ptr<IDataSource>& source) const {\n-    const ui64 result = source->GetColumnRawBytes(Columns->GetColumnIds());\n+    ui64 result = source->GetColumnRawBytes(Columns.GetColumnIds());\n+    if (source->GetContext()->GetReadMetadata()->Limit && source->GetExclusiveIntervalOnly()) {\n+        result = std::max<ui64>(result * 1.0 * source->GetContext()->GetReadMetadata()->Limit / source->GetRecordsCount(),\n+            source->GetColumnBlobBytes(Columns.GetColumnIds()));\n+    }\n     if (!result) {\n-        return Columns->GetColumnIds().size() * source->GetRecordsCount() * sizeof(ui32); // null for all records for all columns in future will be\n+        return Columns.GetColumnIds().size() * source->GetRecordsCount() *\n+               sizeof(ui32);   // null for all records for all columns in future will be\n     } else {\n         return result;\n     }\n }\n \n-TConclusion<bool> TIndexBlobsFetchingStep::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const {\n+ui64 TColumnBlobsFetchingStep::GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const {\n+    return source->GetColumnBlobBytes(Columns.GetColumnIds());\n+}\n+\n+TConclusion<bool> TIndexBlobsFetchingStep::DoExecuteInplace(\n+    const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const {\n     return !source->StartFetchingIndexes(source, step, Indexes);\n }\n \n@@ -56,7 +70,12 @@ TConclusion<bool> TAssemblerStep::DoExecuteInplace(const std::shared_ptr<IDataSo\n     return true;\n }\n \n-TConclusion<bool> TOptionalAssemblerStep::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n+ui64 TAssemblerStep::GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const {\n+    return source->GetColumnRawBytes(Columns->GetColumnIds());\n+}\n+\n+TConclusion<bool> TOptionalAssemblerStep::DoExecuteInplace(\n+    const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     source->AssembleColumns(Columns);\n     return true;\n }\n@@ -70,6 +89,10 @@ bool TOptionalAssemblerStep::DoInitSourceSeqColumnIds(const std::shared_ptr<IDat\n     return false;\n }\n \n+ui64 TOptionalAssemblerStep::GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const {\n+    return source->GetColumnRawBytes(Columns->GetColumnIds());\n+}\n+\n TConclusion<bool> TFilterProgramStep::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     AFL_VERIFY(source);\n     AFL_VERIFY(Step);\n@@ -89,7 +112,8 @@ ui64 TFilterProgramStep::DoPredictRawBytes(const std::shared_ptr<IDataSource>& s\n }\n \n TConclusion<bool> TPredicateFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n-    auto filter = source->GetContext()->GetReadMetadata()->GetPKRangesFilter().BuildFilter(source->GetStageData().GetTable()->BuildTableVerified());\n+    auto filter =\n+        source->GetContext()->GetReadMetadata()->GetPKRangesFilter().BuildFilter(source->GetStageData().GetTable()->BuildTableVerified());\n     source->MutableStageData().AddFilter(filter);\n     return true;\n }\n@@ -97,6 +121,11 @@ TConclusion<bool> TPredicateFilter::DoExecuteInplace(const std::shared_ptr<IData\n TConclusion<bool> TSnapshotFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     auto filter = MakeSnapshotFilter(\n         source->GetStageData().GetTable()->BuildTableVerified(), source->GetContext()->GetReadMetadata()->GetRequestSnapshot());\n+    if (filter.GetFilteredCount().value_or(source->GetRecordsCount()) != source->GetRecordsCount()) {\n+        if (source->AddTxConflict()) {\n+            return true;\n+        }\n+    }\n     source->MutableStageData().AddFilter(filter);\n     return true;\n }\n@@ -120,8 +149,8 @@ TConclusion<bool> TDeletionFilter::DoExecuteInplace(const std::shared_ptr<IDataS\n \n TConclusion<bool> TShardingFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     NYDBTest::TControllers::GetColumnShardController()->OnSelectShardingFilter();\n-    auto filter = source->GetContext()->GetReadMetadata()->GetRequestShardingInfo()->GetShardingInfo()->GetFilter(\n-        source->GetStageData().GetTable()->BuildTableVerified());\n+    const auto& shardingInfo = source->GetContext()->GetReadMetadata()->GetRequestShardingInfo()->GetShardingInfo();\n+    auto filter = shardingInfo->GetFilter(source->GetStageData().GetTable()->BuildTableVerified());\n     source->MutableStageData().AddFilter(filter);\n     return true;\n }\n@@ -131,7 +160,8 @@ TConclusion<bool> TBuildFakeSpec::DoExecuteInplace(const std::shared_ptr<IDataSo\n     for (auto&& f : IIndexInfo::ArrowSchemaSnapshot()->fields()) {\n         columns.emplace_back(NArrow::TThreadSimpleArraysCache::GetConst(f->type(), NArrow::DefaultScalar(f->type()), Count));\n     }\n-    source->MutableStageData().AddBatch(std::make_shared<NArrow::TGeneralContainer>(arrow::RecordBatch::Make(TIndexInfo::ArrowSchemaSnapshot(), Count, columns)));\n+    source->MutableStageData().AddBatch(\n+        std::make_shared<NArrow::TGeneralContainer>(arrow::RecordBatch::Make(TIndexInfo::ArrowSchemaSnapshot(), Count, columns)));\n     return true;\n }\n \n@@ -143,14 +173,21 @@ TConclusion<bool> TApplyIndexStep::DoExecuteInplace(const std::shared_ptr<IDataS\n TConclusion<bool> TFetchingScriptCursor::Execute(const std::shared_ptr<IDataSource>& source) {\n     AFL_VERIFY(source);\n     NMiniKQL::TThrowingBindTerminator bind;\n+    Script->OnExecute();\n     AFL_VERIFY(!Script->IsFinished(CurrentStepIdx));\n     while (!Script->IsFinished(CurrentStepIdx)) {\n         if (source->GetStageData().IsEmpty()) {\n+            source->OnEmptyStageData();\n             break;\n         }\n         auto step = Script->GetStep(CurrentStepIdx);\n-        TMemoryProfileGuard mGuard(\"SCAN_PROFILE::FETCHING::\" + step->GetName() + \"::\" + Script->GetBranchName(), IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n+        TMemoryProfileGuard mGuard(\"SCAN_PROFILE::FETCHING::\" + step->GetName() + \"::\" + Script->GetBranchName(),\n+            IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"scan_step\", step->DebugString())(\"scan_step_idx\", CurrentStepIdx);\n+        AFL_VERIFY(!CurrentStartInstant);\n+        CurrentStartInstant = TMonotonic::Now();\n+        AFL_VERIFY(!CurrentStartDataSize);\n+        CurrentStartDataSize = step->GetProcessingDataSize(source);\n         const TConclusion<bool> resultStep = step->ExecuteInplace(source, *this);\n         if (!resultStep) {\n             return resultStep;\n@@ -158,9 +195,83 @@ TConclusion<bool> TFetchingScriptCursor::Execute(const std::shared_ptr<IDataSour\n         if (!*resultStep) {\n             return false;\n         }\n+        FlushDuration();\n         ++CurrentStepIdx;\n     }\n     return true;\n }\n \n+bool TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,\n+    const std::shared_ptr<NGroupedMemoryManager::IAllocation>& /*allocation*/) {\n+    auto data = Source.lock();\n+    if (!data || data->GetContext()->IsAborted()) {\n+        guard->Release();\n+        return false;\n+    }\n+    data->RegisterAllocationGuard(std::move(guard));\n+    Step.Next();\n+    auto task = std::make_shared<TStepAction>(data, std::move(Step), data->GetContext()->GetCommonContext()->GetScanActorId());\n+    NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n+    return true;\n+}\n+\n+TAllocateMemoryStep::TFetchingStepAllocation::TFetchingStepAllocation(\n+    const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step)\n+    : TBase(mem)\n+    , Source(source)\n+    , Step(step)\n+    , TasksGuard(source->GetContext()->GetCommonContext()->GetCounters().GetResourcesAllocationTasksGuard()) {\n+}\n+\n+TConclusion<bool> TAllocateMemoryStep::DoExecuteInplace(\n+    const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const {\n+\n+    auto allocation = std::make_shared<TFetchingStepAllocation>(source, GetProcessingDataSize(source), step);\n+    NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(source->GetContext()->GetProcessMemoryControlId(),\n+        source->GetContext()->GetCommonContext()->GetScanId(), source->GetFirstIntervalId(), { allocation }, (ui32)StageIndex);\n+    return false;\n }\n+\n+ui64 TAllocateMemoryStep::GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const {\n+    ui64 size = source->GetColumnRawBytes(Columns.GetColumnIds());\n+\n+    if (source->GetStageData().GetUseFilter() && source->GetContext()->GetReadMetadata()->Limit) {\n+        const ui32 filtered = source->GetStageData().GetFilteredCount(source->GetRecordsCount(), source->GetContext()->GetReadMetadata()->Limit);\n+        if (filtered < source->GetRecordsCount()) {\n+            size = std::max<ui64>(size * 1.0 * filtered / source->GetRecordsCount(), source->GetColumnBlobBytes(Columns.GetColumnIds()));\n+        }\n+    }\n+    return size;\n+}\n+\n+TString TFetchingScript::DebugString() const {\n+    TStringBuilder sb;\n+    TStringBuilder sbBranch;\n+    for (auto&& i : Steps) {\n+        if (i->GetSumDuration() > TDuration::MilliSeconds(10)) {\n+            sbBranch << \"{\" << i->DebugString() << \"};\";\n+        }\n+    }\n+    if (!sbBranch) {\n+        return \"\";\n+    }\n+    sb << \"{branch:\" << BranchName << \";limit:\" << Limit << \";\";\n+    if (FinishInstant && StartInstant) {\n+        sb << \"duration:\" << *FinishInstant - *StartInstant << \";\";\n+    }\n+\n+    sb << \"steps_10Ms:[\" << sbBranch << \"]}\";\n+    return sb;\n+}\n+\n+TFetchingScript::TFetchingScript(const TSpecialReadContext& context)\n+    : Limit(context.GetReadMetadata()->Limit) {\n+}\n+\n+NKikimr::TConclusion<bool> TFilterCutLimit::DoExecuteInplace(\n+    const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n+    source->MutableStageData().CutFilter(source->GetRecordsCount(), Limit, Reverse);\n+    return true;\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h\nindex dd11275dedf8..133aa4db3669 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h\n@@ -1,23 +1,38 @@\n #pragma once\n #include \"columns_set.h\"\n-#include <ydb/library/accessor/accessor.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/abstract_scheme.h>\n+\n+#include <ydb/core/tx/columnshard/counters/scan.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/abstract_scheme.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n class IDataSource;\n class TFetchingScriptCursor;\n+class TSpecialReadContext;\n class IFetchingStep {\n private:\n     YDB_READONLY_DEF(TString, Name);\n+    YDB_READONLY(TDuration, SumDuration, TDuration::Zero());\n+    YDB_READONLY(ui64, SumSize, 0);\n+\n protected:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const = 0;\n     virtual TString DoDebugString() const {\n         return \"\";\n     }\n+\n public:\n+    void AddDuration(const TDuration d) {\n+        SumDuration += d;\n+    }\n+    void AddDataSize(const ui64 size) {\n+        SumSize += size;\n+    }\n     virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& /*source*/) const {\n         return 0;\n     }\n@@ -31,15 +46,18 @@ class IFetchingStep {\n         return DoExecuteInplace(source, step);\n     }\n \n-    IFetchingStep(const TString& name)\n-        : Name(name)\n-    {\n+    virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& /*source*/) const {\n+        return 0;\n+    }\n \n+    IFetchingStep(const TString& name)\n+        : Name(name) {\n     }\n \n     TString DebugString() const {\n         TStringBuilder sb;\n-        sb << \"name=\" << Name << \";details={\" << DoDebugString() << \"};\";\n+        sb << \"name=\" << Name << \";duration=\" << SumDuration << \";\"\n+           << \"size=\" << 1e-9 * SumSize << \";details={\" << DoDebugString() << \"};\";\n         return sb;\n     }\n };\n@@ -48,19 +66,30 @@ class TFetchingScript {\n private:\n     YDB_ACCESSOR(TString, BranchName, \"UNDEFINED\");\n     std::vector<std::shared_ptr<IFetchingStep>> Steps;\n+    std::optional<TMonotonic> StartInstant;\n+    std::optional<TMonotonic> FinishInstant;\n+    const ui32 Limit;\n+\n public:\n-    TFetchingScript() = default;\n+    TFetchingScript(const TSpecialReadContext& context);\n \n-    TString DebugString() const {\n-        TStringBuilder sb;\n-        sb << \"[\";\n-        for (auto&& i : Steps) {\n-            sb << \"{\" << i->DebugString() << \"};\";\n+    void AddStepDataSize(const ui32 index, const ui64 size) {\n+        GetStep(index)->AddDataSize(size);\n+    }\n+\n+    void AddStepDuration(const ui32 index, const TDuration d) {\n+        FinishInstant = TMonotonic::Now();\n+        GetStep(index)->AddDuration(d);\n+    }\n+\n+    void OnExecute() {\n+        if (!StartInstant) {\n+            StartInstant = TMonotonic::Now();\n         }\n-        sb << \"]\";\n-        return sb;\n     }\n \n+    TString DebugString() const;\n+\n     const std::shared_ptr<IFetchingStep>& GetStep(const ui32 index) const {\n         AFL_VERIFY(index < Steps.size());\n         return Steps[index];\n@@ -68,7 +97,7 @@ class TFetchingScript {\n \n     ui64 PredictRawBytes(const std::shared_ptr<IDataSource>& source) const {\n         ui64 result = 0;\n-        for (auto&& current: Steps) {\n+        for (auto&& current : Steps) {\n             result += current->DoPredictRawBytes(source);\n         }\n         return result;\n@@ -98,14 +127,23 @@ class TFetchingScript {\n \n class TFetchingScriptCursor {\n private:\n+    std::optional<TMonotonic> CurrentStartInstant;\n+    std::optional<ui64> CurrentStartDataSize;\n     ui32 CurrentStepIdx = 0;\n     std::shared_ptr<TFetchingScript> Script;\n+    void FlushDuration() {\n+        AFL_VERIFY(CurrentStartInstant);\n+        AFL_VERIFY(CurrentStartDataSize);\n+        Script->AddStepDuration(CurrentStepIdx, TMonotonic::Now() - *CurrentStartInstant);\n+        Script->AddStepDataSize(CurrentStepIdx, *CurrentStartDataSize);\n+        CurrentStartInstant.reset();\n+        CurrentStartDataSize.reset();\n+    }\n+\n public:\n     TFetchingScriptCursor(const std::shared_ptr<TFetchingScript>& script, const ui32 index)\n         : CurrentStepIdx(index)\n-        , Script(script)\n-    {\n-\n+        , Script(script) {\n     }\n \n     const TString& GetName() const {\n@@ -117,6 +155,7 @@ class TFetchingScriptCursor {\n     }\n \n     bool Next() {\n+        FlushDuration();\n         return !Script->IsFinished(++CurrentStepIdx);\n     }\n \n@@ -129,6 +168,7 @@ class TStepAction: public IDataTasksProcessor::ITask {\n     std::shared_ptr<IDataSource> Source;\n     TFetchingScriptCursor Cursor;\n     bool FinishedFlag = false;\n+\n protected:\n     virtual bool DoApply(IDataReader& owner) const override;\n     virtual TConclusionStatus DoExecuteImpl() override;\n@@ -141,9 +181,7 @@ class TStepAction: public IDataTasksProcessor::ITask {\n     TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId)\n         : TBase(ownerActorId)\n         , Source(source)\n-        , Cursor(std::move(cursor))\n-    {\n-\n+        , Cursor(std::move(cursor)) {\n     }\n };\n \n@@ -151,16 +189,17 @@ class TBuildFakeSpec: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n     const ui32 Count = 0;\n+\n protected:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& /*source*/) const override {\n         return TIndexInfo::GetSpecialColumnsRecordSize() * Count;\n     }\n+\n public:\n     TBuildFakeSpec(const ui32 count)\n         : TBase(\"FAKE_SPEC\")\n-        , Count(count)\n-    {\n+        , Count(count) {\n         AFL_VERIFY(Count);\n     }\n };\n@@ -169,33 +208,73 @@ class TApplyIndexStep: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n     const NIndexes::TIndexCheckerContainer IndexChecker;\n+\n protected:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n+\n public:\n     TApplyIndexStep(const NIndexes::TIndexCheckerContainer& indexChecker)\n         : TBase(\"APPLY_INDEX\")\n-        , IndexChecker(indexChecker)\n-    {\n+        , IndexChecker(indexChecker) {\n+    }\n+};\n+\n+class TAllocateMemoryStep: public IFetchingStep {\n+private:\n+    using TBase = IFetchingStep;\n+    TColumnsSetIds Columns;\n+    const EStageFeaturesIndexes StageIndex;\n \n+protected:\n+    class TFetchingStepAllocation: public NGroupedMemoryManager::IAllocation {\n+    private:\n+        using TBase = NGroupedMemoryManager::IAllocation;\n+        std::weak_ptr<IDataSource> Source;\n+        TFetchingScriptCursor Step;\n+        NColumnShard::TCounterGuard TasksGuard;\n+        virtual bool DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,\n+            const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) override;\n+\n+    public:\n+        TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step);\n+    };\n+\n+    virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n+    virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const override;\n+    virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& /*source*/) const override {\n+        return 0;\n+    }\n+    virtual TString DoDebugString() const override {\n+        return TStringBuilder() << \"columns=\" << Columns.DebugString() << \";stage=\" << StageIndex << \";\";\n+    }\n+\n+public:\n+    TAllocateMemoryStep(const TColumnsSetIds& columns, const EStageFeaturesIndexes stageIndex)\n+        : TBase(\"ALLOCATE_MEMORY::\" + ::ToString(stageIndex))\n+        , Columns(columns)\n+        , StageIndex(stageIndex) {\n+        AFL_VERIFY(Columns.GetColumnsCount());\n     }\n };\n \n class TColumnBlobsFetchingStep: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n-    std::shared_ptr<TColumnsSet> Columns;\n+    TColumnsSetIds Columns;\n+\n protected:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& source) const override;\n     virtual TString DoDebugString() const override {\n-        return TStringBuilder() << \"columns=\" << Columns->DebugString() << \";\";\n+        return TStringBuilder() << \"columns=\" << Columns.DebugString() << \";\";\n     }\n+\n public:\n-    TColumnBlobsFetchingStep(const std::shared_ptr<TColumnsSet>& columns)\n+    virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const override;\n+    TColumnBlobsFetchingStep(const TColumnsSetIds& columns)\n         : TBase(\"FETCHING_COLUMNS\")\n         , Columns(columns) {\n-        AFL_VERIFY(Columns);\n-        AFL_VERIFY(Columns->GetColumnsCount());\n+        AFL_VERIFY(Columns.GetColumnsCount());\n     }\n };\n \n@@ -203,12 +282,14 @@ class TIndexBlobsFetchingStep: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n     std::shared_ptr<TIndexesSet> Indexes;\n+\n protected:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& source) const override;\n     virtual TString DoDebugString() const override {\n         return TStringBuilder() << \"indexes=\" << Indexes->DebugString() << \";\";\n     }\n+\n public:\n     TIndexBlobsFetchingStep(const std::shared_ptr<TIndexesSet>& indexes)\n         : TBase(\"FETCHING_INDEXES\")\n@@ -225,12 +306,13 @@ class TAssemblerStep: public IFetchingStep {\n     virtual TString DoDebugString() const override {\n         return TStringBuilder() << \"columns=\" << Columns->DebugString() << \";\";\n     }\n+\n public:\n+    virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const override;\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     TAssemblerStep(const std::shared_ptr<TColumnsSet>& columns, const TString& specName = Default<TString>())\n         : TBase(\"ASSEMBLER\" + (specName ? \"::\" + specName : \"\"))\n-        , Columns(columns)\n-    {\n+        , Columns(columns) {\n         AFL_VERIFY(Columns);\n         AFL_VERIFY(Columns->GetColumnsCount());\n     }\n@@ -243,9 +325,13 @@ class TOptionalAssemblerStep: public IFetchingStep {\n     virtual TString DoDebugString() const override {\n         return TStringBuilder() << \"columns=\" << Columns->DebugString() << \";\";\n     }\n+\n protected:\n     virtual bool DoInitSourceSeqColumnIds(const std::shared_ptr<IDataSource>& source) const override;\n+\n public:\n+    virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const override;\n+\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     TOptionalAssemblerStep(const std::shared_ptr<TColumnsSet>& columns, const TString& specName = Default<TString>())\n         : TBase(\"OPTIONAL_ASSEMBLER\" + (specName ? \"::\" + specName : \"\"))\n@@ -259,13 +345,35 @@ class TFilterProgramStep: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n     std::shared_ptr<NSsa::TProgramStep> Step;\n+\n protected:\n     virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& source) const override;\n+\n public:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     TFilterProgramStep(const std::shared_ptr<NSsa::TProgramStep>& step)\n         : TBase(\"PROGRAM\")\n-        , Step(step)\n+        , Step(step) {\n+    }\n+};\n+\n+class TFilterCutLimit: public IFetchingStep {\n+private:\n+    using TBase = IFetchingStep;\n+    const ui32 Limit;\n+    const bool Reverse;\n+\n+protected:\n+    virtual ui64 DoPredictRawBytes(const std::shared_ptr<IDataSource>& /*source*/) const override {\n+        return 0;\n+    }\n+\n+public:\n+    virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n+    TFilterCutLimit(const ui32 limit, const bool reverse)\n+        : TBase(\"LIMIT\")\n+        , Limit(limit)\n+        , Reverse(reverse)\n     {\n     }\n };\n@@ -273,15 +381,15 @@ class TFilterProgramStep: public IFetchingStep {\n class TPredicateFilter: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n+\n public:\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     TPredicateFilter()\n         : TBase(\"PREDICATE\") {\n-\n     }\n };\n \n-class TSnapshotFilter : public IFetchingStep {\n+class TSnapshotFilter: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n \n@@ -303,7 +411,7 @@ class TDeletionFilter: public IFetchingStep {\n     }\n };\n \n-class TShardingFilter : public IFetchingStep {\n+class TShardingFilter: public IFetchingStep {\n private:\n     using TBase = IFetchingStep;\n \n@@ -314,5 +422,4 @@ class TShardingFilter : public IFetchingStep {\n     }\n };\n \n-\n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp\nindex 311a3c45f61d..9da043a366c1 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp\n@@ -1,20 +1,29 @@\n #include \"interval.h\"\n+\n #include <ydb/core/tx/conveyor/usage/service.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n void TFetchingInterval::ConstructResult() {\n-    if (ReadySourcesCount.Val() != WaitSourcesCount || !ReadyGuards.Val()) {\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"skip_construct_result\")(\"interval_idx\", IntervalIdx);\n+    const ui32 ready = ReadySourcesCount.Val();\n+    if (ready != WaitSourcesCount) {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"skip_construct_result\")(\"interval_idx\", IntervalIdx)(\n+            \"count\", WaitSourcesCount)(\"ready\", ready)(\"interval_id\", GetIntervalId());\n         return;\n     } else {\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"start_construct_result\")(\"interval_idx\", IntervalIdx);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"start_construct_result\")(\"interval_idx\", IntervalIdx)(\n+            \"interval_id\", GetIntervalId());\n     }\n     if (AtomicCas(&SourcesFinalized, 1, 0)) {\n         IntervalStateGuard.SetStatus(NColumnShard::TScanCounters::EIntervalStatus::WaitMergerStart);\n+\n+        MergingContext->SetIntervalChunkMemory(Context->GetMemoryForSources(Sources));\n+\n         auto task = std::make_shared<TStartMergeTask>(MergingContext, Context, std::move(Sources));\n         task->SetPriority(NConveyor::ITask::EPriority::High);\n-        NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n+        NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(Context->GetProcessMemoryControlId(),\n+            Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)EStageFeaturesIndexes::Merge);\n     }\n }\n \n@@ -27,35 +36,26 @@ void TFetchingInterval::OnSourceFetchStageReady(const ui32 /*sourceIdx*/) {\n TFetchingInterval::TFetchingInterval(const NArrow::NMerger::TSortableBatchPosition& start, const NArrow::NMerger::TSortableBatchPosition& finish,\n     const ui32 intervalIdx, const THashMap<ui32, std::shared_ptr<IDataSource>>& sources, const std::shared_ptr<TSpecialReadContext>& context,\n     const bool includeFinish, const bool includeStart, const bool isExclusiveInterval)\n-    : TTaskBase(0, context->GetMemoryForSources(sources, isExclusiveInterval), \"\", context->GetCommonContext()->GetResourcesTaskContext())\n-    , MergingContext(std::make_shared<TMergingContext>(start, finish, intervalIdx, includeFinish, includeStart, isExclusiveInterval))\n+    : MergingContext(std::make_shared<TMergingContext>(start, finish, intervalIdx, includeFinish, includeStart, isExclusiveInterval))\n     , Context(context)\n     , TaskGuard(Context->GetCommonContext()->GetCounters().GetResourcesAllocationTasksGuard())\n     , Sources(sources)\n-    , ResourcesGuard(Context->GetCommonContext()->GetCounters().BuildRequestedResourcesGuard(GetMemoryAllocation()))\n     , IntervalIdx(intervalIdx)\n-    , IntervalStateGuard(Context->GetCommonContext()->GetCounters().CreateIntervalStateGuard())\n-{\n-    Y_ABORT_UNLESS(Sources.size());\n+    , IntervalGroupGuard(NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildGroupGuard(\n+          Context->GetProcessMemoryControlId(), context->GetCommonContext()->GetScanId()))\n+    , IntervalStateGuard(Context->GetCommonContext()->GetCounters().CreateIntervalStateGuard()) {\n+    AFL_VERIFY(Sources.size());\n     for (auto&& [_, i] : Sources) {\n         if (!i->IsDataReady()) {\n             ++WaitSourcesCount;\n+        } else {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"ready_source\")(\"interval_idx\", IntervalIdx)(\n+                \"interval_id\", GetIntervalId());\n         }\n-        i->RegisterInterval(*this);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"register_source\")(\"interval_idx\", IntervalIdx)(\"interval_id\", GetIntervalId());\n+        i->RegisterInterval(*this, i);\n     }\n     IntervalStateGuard.SetStatus(NColumnShard::TScanCounters::EIntervalStatus::WaitResources);\n-}\n-\n-void TFetchingInterval::DoOnAllocationSuccess(const std::shared_ptr<NResourceBroker::NSubscribe::TResourcesGuard>& guard) {\n-    AFL_VERIFY(guard);\n-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"interval_idx\", IntervalIdx)(\"event\", \"resources_allocated\")\n-        (\"resources\", guard->DebugString())(\"start\", MergingContext->GetIncludeStart())(\"finish\", MergingContext->GetIncludeFinish())(\"sources\", Sources.size());\n-    IntervalStateGuard.SetStatus(NColumnShard::TScanCounters::EIntervalStatus::WaitSources);\n-    ResourcesGuard->InitResources(guard);\n-    for (auto&& i : Sources) {\n-        i.second->OnInitResourcesGuard(i.second);\n-    }\n-    AFL_VERIFY(ReadyGuards.Inc() <= 1);\n     ConstructResult();\n }\n \n@@ -76,13 +76,15 @@ void TFetchingInterval::OnPartSendingComplete() {\n     AFL_VERIFY(Merger);\n     AFL_VERIFY(AtomicCas(&PartSendingWait, 0, 1));\n     AFL_VERIFY(AtomicGet(SourcesFinalized) == 1);\n-    if (AbortedFlag) {\n+    if (Context->IsAborted()) {\n         return;\n     }\n     IntervalStateGuard.SetStatus(NColumnShard::TScanCounters::EIntervalStatus::WaitMergerContinue);\n+\n     auto task = std::make_shared<TContinueMergeTask>(MergingContext, Context, std::move(Merger));\n     task->SetPriority(NConveyor::ITask::EPriority::High);\n-    NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n+    NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(Context->GetProcessMemoryControlId(),\n+        Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)EStageFeaturesIndexes::Merge);\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.h\nindex 6956303a48c9..86c3f1aa0510 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.h\n@@ -6,11 +6,9 @@\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n-class TFetchingInterval: public TNonCopyable, public NResourceBroker::NSubscribe::ITask {\n+class TFetchingInterval: public TNonCopyable {\n private:\n-    using TTaskBase = NResourceBroker::NSubscribe::ITask;\n     std::shared_ptr<TMergingContext> MergingContext;\n-    bool AbortedFlag = false;\n     TAtomic SourcesFinalized = 0;\n     TAtomic PartSendingWait = 0;\n     std::unique_ptr<NArrow::NMerger::TMergePartialStream> Merger;\n@@ -20,14 +18,11 @@ class TFetchingInterval: public TNonCopyable, public NResourceBroker::NSubscribe\n \n     void ConstructResult();\n \n-    std::shared_ptr<NColumnShard::TReaderResourcesGuard> ResourcesGuard;\n     const ui32 IntervalIdx;\n+    const std::shared_ptr<NGroupedMemoryManager::TGroupGuard> IntervalGroupGuard;\n     TAtomicCounter ReadySourcesCount = 0;\n-    TAtomicCounter ReadyGuards = 0;\n     ui32 WaitSourcesCount = 0;\n     NColumnShard::TConcreteScanCounters::TScanIntervalStateGuard IntervalStateGuard;\n-protected:\n-    virtual void DoOnAllocationSuccess(const std::shared_ptr<NResourceBroker::NSubscribe::TResourcesGuard>& guard) override;\n \n public:\n     std::set<ui64> GetPathIds() const {\n@@ -42,16 +37,16 @@ class TFetchingInterval: public TNonCopyable, public NResourceBroker::NSubscribe\n         return IntervalIdx;\n     }\n \n-    const THashMap<ui32, std::shared_ptr<IDataSource>>& GetSources() const {\n-        return Sources;\n+    ui32 GetIntervalId() const {\n+        AFL_VERIFY(IntervalGroupGuard);\n+        return IntervalGroupGuard->GetGroupId();\n     }\n \n-    const std::shared_ptr<NColumnShard::TReaderResourcesGuard>& GetResourcesGuard() const {\n-        return ResourcesGuard;\n+    const THashMap<ui32, std::shared_ptr<IDataSource>>& GetSources() const {\n+        return Sources;\n     }\n \n     void Abort() {\n-        AbortedFlag = true;\n         if (AtomicCas(&SourcesFinalized, 1, 0)) {\n             for (auto&& i : Sources) {\n                 i.second->Abort();\n@@ -82,10 +77,16 @@ class TFetchingInterval: public TNonCopyable, public NResourceBroker::NSubscribe\n     void OnPartSendingComplete();\n     void SetMerger(std::unique_ptr<NArrow::NMerger::TMergePartialStream>&& merger);\n     bool HasMerger() const;\n+    std::shared_ptr<NGroupedMemoryManager::TGroupGuard> GetGroupGuard() const {\n+        return IntervalGroupGuard;\n+    }\n \n     TFetchingInterval(const NArrow::NMerger::TSortableBatchPosition& start, const NArrow::NMerger::TSortableBatchPosition& finish,\n         const ui32 intervalIdx, const THashMap<ui32, std::shared_ptr<IDataSource>>& sources, const std::shared_ptr<TSpecialReadContext>& context,\n         const bool includeFinish, const bool includeStart, const bool isExclusiveInterval);\n+    \n+    ~TFetchingInterval() {\n+    }\n };\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.cpp\nindex 2b03ac222e76..f705deb4501c 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.cpp\n@@ -11,7 +11,7 @@ TColumnShardScanIterator::TColumnShardScanIterator(const std::shared_ptr<TReadCo\n     Y_ABORT_UNLESS(Context->GetReadMetadata()->IsSorted());\n }\n \n-TConclusion<std::optional<TPartialReadResult>> TColumnShardScanIterator::GetBatch() {\n+TConclusion<std::shared_ptr<TPartialReadResult>> TColumnShardScanIterator::GetBatch() {\n     FillReadyResults();\n     return ReadyResults.pop_front();\n }\n@@ -33,11 +33,11 @@ void TColumnShardScanIterator::FillReadyResults() {\n     i64 limitLeft = Context->GetReadMetadata()->Limit == 0 ? INT64_MAX : Context->GetReadMetadata()->Limit - ItemsRead;\n     for (size_t i = 0; i < ready.size() && limitLeft; ++i) {\n         auto& batch = ReadyResults.emplace_back(std::move(ready[i]));\n-        if (batch.GetResultBatch().num_rows() > limitLeft) {\n-            batch.Cut(limitLeft);\n+        if (batch->GetResultBatch().num_rows() > limitLeft) {\n+            batch->Cut(limitLeft);\n         }\n-        limitLeft -= batch.GetResultBatch().num_rows();\n-        ItemsRead += batch.GetResultBatch().num_rows();\n+        limitLeft -= batch->GetResultBatch().num_rows();\n+        ItemsRead += batch->GetResultBatch().num_rows();\n     }\n \n     if (limitLeft == 0) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.h\nindex 8421e697c807..38b1fcc29882 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/iterator.h\n@@ -9,7 +9,7 @@ namespace NKikimr::NOlap::NReader::NPlain {\n class TReadyResults {\n private:\n     const NColumnShard::TConcreteScanCounters Counters;\n-    std::deque<TPartialReadResult> Data;\n+    std::deque<std::shared_ptr<TPartialReadResult>> Data;\n     i64 RecordsCount = 0;\n public:\n     TString DebugString() const {\n@@ -19,7 +19,7 @@ class TReadyResults {\n             << \"records_count:\" << RecordsCount << \";\"\n             ;\n         if (Data.size()) {\n-            sb << \"schema=\" << Data.front().GetResultBatch().schema()->ToString() << \";\";\n+            sb << \"schema=\" << Data.front()->GetResultBatch().schema()->ToString() << \";\";\n         }\n         return sb;\n     }\n@@ -28,17 +28,19 @@ class TReadyResults {\n     {\n \n     }\n-    TPartialReadResult& emplace_back(TPartialReadResult&& v) {\n-        RecordsCount += v.GetResultBatch().num_rows();\n+    const std::shared_ptr<TPartialReadResult>& emplace_back(std::shared_ptr<TPartialReadResult>&& v) {\n+        AFL_VERIFY(!!v);\n+        RecordsCount += v->GetResultBatch().num_rows();\n         Data.emplace_back(std::move(v));\n         return Data.back();\n     }\n-    std::optional<TPartialReadResult> pop_front() {\n+    std::shared_ptr<TPartialReadResult> pop_front() {\n         if (Data.empty()) {\n             return {};\n         }\n         auto result = std::move(Data.front());\n-        RecordsCount -= result.GetResultBatch().num_rows();\n+        AFL_VERIFY(RecordsCount >= result->GetResultBatch().num_rows());\n+        RecordsCount -= result->GetResultBatch().num_rows();\n         Data.pop_front();\n         return result;\n     }\n@@ -90,7 +92,7 @@ class TColumnShardScanIterator: public TScanIteratorBase {\n         return IndexedData->IsFinished() && ReadyResults.empty();\n     }\n \n-    TConclusion<std::optional<TPartialReadResult>> GetBatch() override;\n+    virtual TConclusion<std::shared_ptr<TPartialReadResult>> GetBatch() override;\n     virtual void PrepareResults() override;\n \n     virtual TConclusion<bool> ReadNextInterval() override;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp\nindex dfeaec1b7aca..1981faaa4314 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp\n@@ -2,6 +2,9 @@\n #include \"plain_read_data.h\"\n #include \"source.h\"\n \n+#include <ydb/core/formats/arrow/serializer/native.h>\n+#include <ydb/core/tx/conveyor/usage/service.h>\n+\n namespace NKikimr::NOlap::NReader::NPlain {\n \n std::optional<NArrow::NMerger::TCursor> TBaseMergeTask::DrainMergerLinearScan(const std::optional<ui32> resultBufferLimit) {\n@@ -19,12 +22,13 @@ std::optional<NArrow::NMerger::TCursor> TBaseMergeTask::DrainMergerLinearScan(co\n         Merger = nullptr;\n     }\n     Context->GetCommonContext()->GetCounters().OnLinearScanInterval(rbBuilder->GetRecordsCount());\n-    ResultBatch = NArrow::TStatusValidator::GetValid(arrow::Table::FromRecordBatches({rbBuilder->Finalize()}));\n+    ResultBatch = NArrow::TStatusValidator::GetValid(arrow::Table::FromRecordBatches({ rbBuilder->Finalize() }));\n     return lastResultPosition;\n }\n \n void TBaseMergeTask::PrepareResultBatch() {\n     if (!ResultBatch || ResultBatch->num_rows() == 0) {\n+        AllocationGuard = nullptr;\n         ResultBatch = nullptr;\n         LastPK = nullptr;\n         return;\n@@ -41,8 +45,10 @@ void TBaseMergeTask::PrepareResultBatch() {\n         } else {\n             ShardedBatch = NArrow::TShardedRecordBatch(ResultBatch);\n         }\n+        AllocationGuard->Update(NArrow::GetTableMemorySize(ResultBatch));\n         AFL_VERIFY(!!LastPK == !!ShardedBatch->GetRecordsCount())(\"lpk\", !!LastPK)(\"sb\", ShardedBatch->GetRecordsCount());\n     } else {\n+        AllocationGuard = nullptr;\n         ResultBatch = nullptr;\n         LastPK = nullptr;\n     }\n@@ -51,7 +57,19 @@ void TBaseMergeTask::PrepareResultBatch() {\n bool TBaseMergeTask::DoApply(IDataReader& indexedDataRead) const {\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"DoApply\")(\"interval_idx\", MergingContext->GetIntervalIdx());\n     auto& reader = static_cast<TPlainReadData&>(indexedDataRead);\n-    reader.MutableScanner().OnIntervalResult(ShardedBatch, LastPK, std::move(Merger), IntervalIdx, reader);\n+    auto copy = AllocationGuard;\n+    reader.MutableScanner().OnIntervalResult(std::move(copy), ShardedBatch, LastPK, std::move(Merger), IntervalIdx, reader);\n+    return true;\n+}\n+\n+bool TBaseMergeTask::DoOnAllocated(\n+    std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard, const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) {\n+    if (Context->IsAborted()) {\n+        guard->Release();\n+        return false;\n+    }\n+    AllocationGuard = std::move(guard);\n+    NConveyor::TScanServiceOperator::SendTaskToExecute(static_pointer_cast<TBaseMergeTask>(allocation));\n     return true;\n }\n \n@@ -73,7 +91,8 @@ TConclusionStatus TStartMergeTask::DoExecuteImpl() {\n         if (container && container->num_rows()) {\n             ResultBatch = container->BuildTableVerified();\n             LastPK = Sources.begin()->second->GetLastPK();\n-            ResultBatch = NArrow::TColumnOperator().VerifyIfAbsent().Extract(ResultBatch, Context->GetProgramInputColumns()->GetColumnNamesVector());\n+            ResultBatch =\n+                NArrow::TColumnOperator().VerifyIfAbsent().Extract(ResultBatch, Context->GetProgramInputColumns()->GetColumnNamesVector());\n             Context->GetCommonContext()->GetCounters().OnNoScanInterval(ResultBatch->num_rows());\n             if (Context->GetCommonContext()->IsReverse()) {\n                 ResultBatch = NArrow::ReverseRecords(ResultBatch);\n@@ -103,7 +122,7 @@ TConclusionStatus TStartMergeTask::DoExecuteImpl() {\n             return TConclusionStatus::Success();\n         }\n     }\n-    Merger->PutControlPoint(MergingContext->GetFinish());\n+    Merger->PutControlPoint(MergingContext->GetFinish(), false);\n     Merger->SkipToLowerBound(MergingContext->GetStart(), MergingContext->GetIncludeStart());\n     const ui32 originalSourcesCount = Sources.size();\n     Sources.clear();\n@@ -115,10 +134,12 @@ TConclusionStatus TStartMergeTask::DoExecuteImpl() {\n         ResultBatch = Merger->SingleSourceDrain(MergingContext->GetFinish(), MergingContext->GetIncludeFinish(), &lastResultPosition);\n         if (ResultBatch) {\n             Context->GetCommonContext()->GetCounters().OnLogScanInterval(ResultBatch->num_rows());\n-            AFL_VERIFY(ResultBatch->schema()->Equals(Context->GetProgramInputColumns()->GetSchema()))(\"res\", ResultBatch->schema()->ToString())(\"ctx\", Context->GetProgramInputColumns()->GetSchema()->ToString());\n+            AFL_VERIFY(ResultBatch->schema()->Equals(Context->GetProgramInputColumns()->GetSchema()))(\"res\", ResultBatch->schema()->ToString())(\n+                \"ctx\", Context->GetProgramInputColumns()->GetSchema()->ToString());\n         }\n         if (MergingContext->GetIncludeFinish() && originalSourcesCount == 1) {\n-            AFL_VERIFY(Merger->IsEmpty())(\"merging_context_finish\", MergingContext->GetFinish().DebugJson().GetStringRobust())(\"merger\", Merger->DebugString());\n+            AFL_VERIFY(Merger->IsEmpty())(\"merging_context_finish\", MergingContext->GetFinish().DebugJson().GetStringRobust())(\n+                \"merger\", Merger->DebugString());\n         }\n     } else {\n         TMemoryProfileGuard mGuard(\"SCAN_PROFILE::MERGE::MANY\", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n@@ -133,10 +154,10 @@ TConclusionStatus TStartMergeTask::DoExecuteImpl() {\n     return TConclusionStatus::Success();\n }\n \n-TStartMergeTask::TStartMergeTask(const std::shared_ptr<TMergingContext>& mergingContext, const std::shared_ptr<TSpecialReadContext>& readContext, THashMap<ui32, std::shared_ptr<IDataSource>>&& sources)\n+TStartMergeTask::TStartMergeTask(const std::shared_ptr<TMergingContext>& mergingContext, const std::shared_ptr<TSpecialReadContext>& readContext,\n+    THashMap<ui32, std::shared_ptr<IDataSource>>&& sources)\n     : TBase(mergingContext, readContext)\n-    , Sources(std::move(sources))\n-{\n+    , Sources(std::move(sources)) {\n     for (auto&& s : Sources) {\n         AFL_VERIFY(s.second->IsDataReady());\n     }\n@@ -158,4 +179,4 @@ TConclusionStatus TContinueMergeTask::DoExecuteImpl() {\n     return TConclusionStatus::Success();\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.h\nindex daf151cd5ce7..bbe2d11ccb3a 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.h\n@@ -1,10 +1,11 @@\n #pragma once\n #include \"context.h\"\n+\n #include <ydb/core/formats/arrow/reader/merger.h>\n #include <ydb/core/formats/arrow/reader/position.h>\n-\n-#include <ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h>\n #include <ydb/core/tx/columnshard/counters/scan.h>\n+#include <ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n@@ -16,6 +17,8 @@ class TMergingContext {\n     YDB_READONLY(bool, IncludeStart, false);\n     YDB_READONLY(ui32, IntervalIdx, 0);\n     bool IsExclusiveIntervalFlag = false;\n+    std::optional<ui64> IntervalChunkMemory;\n+\n public:\n     TMergingContext(const NArrow::NMerger::TSortableBatchPosition& start, const NArrow::NMerger::TSortableBatchPosition& finish,\n         const ui32 intervalIdx, const bool includeFinish, const bool includeStart, const bool isExclusiveInterval)\n@@ -24,9 +27,16 @@ class TMergingContext {\n         , IncludeFinish(includeFinish)\n         , IncludeStart(includeStart)\n         , IntervalIdx(intervalIdx)\n-        , IsExclusiveIntervalFlag(isExclusiveInterval)\n-    {\n+        , IsExclusiveIntervalFlag(isExclusiveInterval) {\n+    }\n+\n+    void SetIntervalChunkMemory(const ui64 value) {\n+        IntervalChunkMemory = value;\n+    }\n \n+    ui64 GetIntervalChunkMemory() const {\n+        AFL_VERIFY(IntervalChunkMemory);\n+        return *IntervalChunkMemory;\n     }\n \n     bool IsExclusiveInterval() const {\n@@ -42,12 +52,12 @@ class TMergingContext {\n         result.InsertValue(\"exclusive\", IsExclusiveIntervalFlag);\n         return result;\n     }\n-\n };\n \n-class TBaseMergeTask: public IDataTasksProcessor::ITask {\n+class TBaseMergeTask: public IDataTasksProcessor::ITask, public NGroupedMemoryManager::IAllocation {\n private:\n     using TBase = IDataTasksProcessor::ITask;\n+\n protected:\n     std::shared_ptr<arrow::Table> ResultBatch;\n     std::shared_ptr<arrow::RecordBatch> LastPK;\n@@ -57,20 +67,25 @@ class TBaseMergeTask: public IDataTasksProcessor::ITask {\n     std::shared_ptr<TMergingContext> MergingContext;\n     const ui32 IntervalIdx;\n     std::optional<NArrow::TShardedRecordBatch> ShardedBatch;\n+    std::shared_ptr<NGroupedMemoryManager::TAllocationGuard> AllocationGuard;\n \n     [[nodiscard]] std::optional<NArrow::NMerger::TCursor> DrainMergerLinearScan(const std::optional<ui32> resultBufferLimit);\n \n     void PrepareResultBatch();\n+\n private:\n     virtual bool DoApply(IDataReader& indexedDataRead) const override;\n+    virtual bool DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,\n+        const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) override;\n+\n public:\n     TBaseMergeTask(const std::shared_ptr<TMergingContext>& mergingContext, const std::shared_ptr<TSpecialReadContext>& readContext)\n         : TBase(readContext->GetCommonContext()->GetScanActorId())\n+        , IAllocation(TValidator::CheckNotNull(mergingContext)->GetIntervalChunkMemory())\n         , Guard(readContext->GetCommonContext()->GetCounters().GetMergeTasksGuard())\n         , Context(readContext)\n         , MergingContext(mergingContext)\n         , IntervalIdx(MergingContext->GetIntervalIdx()) {\n-\n     }\n };\n \n@@ -79,6 +94,7 @@ class TStartMergeTask: public TBaseMergeTask {\n     using TBase = TBaseMergeTask;\n     bool OnlyEmptySources = true;\n     THashMap<ui32, std::shared_ptr<IDataSource>> Sources;\n+\n protected:\n     virtual TConclusionStatus DoExecuteImpl() override;\n \n@@ -87,13 +103,14 @@ class TStartMergeTask: public TBaseMergeTask {\n         return \"CS::MERGE_START\";\n     }\n \n-    TStartMergeTask(const std::shared_ptr<TMergingContext>& mergingContext,\n-        const std::shared_ptr<TSpecialReadContext>& readContext, THashMap<ui32, std::shared_ptr<IDataSource>>&& sources);\n+    TStartMergeTask(const std::shared_ptr<TMergingContext>& mergingContext, const std::shared_ptr<TSpecialReadContext>& readContext,\n+        THashMap<ui32, std::shared_ptr<IDataSource>>&& sources);\n };\n \n class TContinueMergeTask: public TBaseMergeTask {\n private:\n     using TBase = TBaseMergeTask;\n+\n protected:\n     virtual TConclusionStatus DoExecuteImpl() override;\n \n@@ -102,11 +119,12 @@ class TContinueMergeTask: public TBaseMergeTask {\n         return \"CS::MERGE_CONTINUE\";\n     }\n \n-    TContinueMergeTask(const std::shared_ptr<TMergingContext>& mergingContext, const std::shared_ptr<TSpecialReadContext>& readContext, std::unique_ptr<NArrow::NMerger::TMergePartialStream>&& merger)\n+    TContinueMergeTask(const std::shared_ptr<TMergingContext>& mergingContext, const std::shared_ptr<TSpecialReadContext>& readContext,\n+        std::unique_ptr<NArrow::NMerger::TMergePartialStream>&& merger)\n         : TBase(mergingContext, readContext) {\n         AFL_VERIFY(merger);\n         Merger = std::move(merger);\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.cpp\nindex 9def8738cab9..04ed0d1c6f26 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.cpp\n@@ -8,38 +8,43 @@ TPlainReadData::TPlainReadData(const std::shared_ptr<TReadContext>& context)\n {\n     ui32 sourceIdx = 0;\n     std::deque<std::shared_ptr<IDataSource>> sources;\n-    const auto& portionsOrdered = GetReadMetadata()->SelectInfo->GetPortionsOrdered(GetReadMetadata()->IsDescSorted());\n+    const auto& portions = GetReadMetadata()->SelectInfo->PortionsOrderedPK;\n     const auto& committed = GetReadMetadata()->CommittedBlobs;\n-    auto itCommitted = committed.begin();\n-    auto itPortion = portionsOrdered.begin();\n-    ui64 committedPortionsBytes = 0;\n-    ui64 insertedPortionsBytes = 0;\n     ui64 compactedPortionsBytes = 0;\n-    while (itCommitted != committed.end() || itPortion != portionsOrdered.end()) {\n-        bool movePortion = false;\n-        if (itCommitted == committed.end()) {\n-            movePortion = true;\n-        } else if (itPortion == portionsOrdered.end()) {\n-            movePortion = false;\n-        } else if (itCommitted->GetFirstVerified() < (*itPortion)->IndexKeyStart()) {\n-            movePortion = false;\n+    ui64 insertedPortionsBytes = 0;\n+    ui64 committedPortionsBytes = 0;\n+    for (auto&& i : portions) {\n+        if (i->GetMeta().GetProduced() == NPortion::EProduced::COMPACTED || i->GetMeta().GetProduced() == NPortion::EProduced::SPLIT_COMPACTED) {\n+            compactedPortionsBytes += i->GetTotalBlobBytes();\n         } else {\n-            movePortion = true;\n+            insertedPortionsBytes += i->GetTotalBlobBytes();\n+        }\n+        sources.emplace_back(std::make_shared<TPortionDataSource>(sourceIdx++, i, SpecialReadContext));\n+    }\n+    for (auto&& i : committed) {\n+        if (i.HasSnapshot()) {\n+            continue;\n+        }\n+        if (GetReadMetadata()->IsMyUncommitted(i.GetWriteIdVerified())) {\n+            continue;\n         }\n+        if (GetReadMetadata()->GetPKRangesFilter().CheckPoint(i.GetFirst()) ||\n+            GetReadMetadata()->GetPKRangesFilter().CheckPoint(i.GetLast())) {\n+            GetReadMetadata()->SetConflictedWriteId(i.GetWriteIdVerified());\n+        }\n+    }\n \n-        if (movePortion) {\n-            if ((*itPortion)->GetMeta().GetProduced() == NPortion::EProduced::COMPACTED || (*itPortion)->GetMeta().GetProduced() == NPortion::EProduced::SPLIT_COMPACTED) {\n-                compactedPortionsBytes += (*itPortion)->GetTotalBlobBytes();\n-            } else {\n-                insertedPortionsBytes += (*itPortion)->GetTotalBlobBytes();\n+    for (auto&& i : committed) {\n+        if (!i.HasSnapshot()) {\n+            if (GetReadMetadata()->IsWriteConflictable(i.GetWriteIdVerified())) {\n+                continue;\n             }\n-            sources.emplace_back(std::make_shared<TPortionDataSource>(sourceIdx++, *itPortion, SpecialReadContext, (*itPortion)->IndexKeyStart(), (*itPortion)->IndexKeyEnd()));\n-            ++itPortion;\n-        } else {\n-            sources.emplace_back(std::make_shared<TCommittedDataSource>(sourceIdx++, *itCommitted, SpecialReadContext, itCommitted->GetFirstVerified(), itCommitted->GetLastVerified()));\n-            committedPortionsBytes += itCommitted->GetSize();\n-            ++itCommitted;\n+        } else if (GetReadMetadata()->GetPKRangesFilter().IsPortionInPartialUsage(i.GetFirst(), i.GetLast()) ==\n+                   TPKRangeFilter::EUsageClass::DontUsage) {\n+            continue;\n         }\n+        sources.emplace_back(std::make_shared<TCommittedDataSource>(sourceIdx++, i, SpecialReadContext));\n+        committedPortionsBytes += i.GetSize();\n     }\n     Scanner = std::make_shared<TScanHead>(std::move(sources), SpecialReadContext);\n \n@@ -54,16 +59,16 @@ TPlainReadData::TPlainReadData(const std::shared_ptr<TReadContext>& context)\n \n }\n \n-std::vector<TPartialReadResult> TPlainReadData::DoExtractReadyResults(const int64_t maxRowsInBatch) {\n-    auto result = TPartialReadResult::SplitResults(std::move(PartialResults), maxRowsInBatch);\n+std::vector<std::shared_ptr<TPartialReadResult>> TPlainReadData::DoExtractReadyResults(const int64_t /*maxRowsInBatch*/) {\n+    auto result = std::move(PartialResults);\n+    PartialResults.clear();\n+//    auto result = TPartialReadResult::SplitResults(std::move(PartialResults), maxRowsInBatch);\n     ui32 count = 0;\n     for (auto&& r: result) {\n-        count += r.GetRecordsCount();\n+        count += r->GetRecordsCount();\n     }\n     AFL_VERIFY(count == ReadyResultsCount);\n-\n     ReadyResultsCount = 0;\n-    PartialResults.clear();\n \n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"DoExtractReadyResults\")(\"result\", result.size())(\"count\", count)(\"finished\", Scanner->IsFinished());\n     return result;\n@@ -76,7 +81,7 @@ TConclusion<bool> TPlainReadData::DoReadNextInterval() {\n void TPlainReadData::OnIntervalResult(const std::shared_ptr<TPartialReadResult>& result) {\n //    result->GetResourcesGuardOnly()->Update(result->GetMemorySize());\n     ReadyResultsCount += result->GetRecordsCount();\n-    PartialResults.emplace_back(std::move(*result));\n+    PartialResults.emplace_back(result);\n }\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h\nindex 39d993b156d6..93d2a56bad14 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h\n@@ -14,9 +14,8 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin\n     using TBase = IDataReader;\n     std::shared_ptr<TScanHead> Scanner;\n     std::shared_ptr<TSpecialReadContext> SpecialReadContext;\n-    std::vector<TPartialReadResult> PartialResults;\n+    std::vector<std::shared_ptr<TPartialReadResult>> PartialResults;\n     ui32 ReadyResultsCount = 0;\n-    bool AbortedFlag = false;\n protected:\n     virtual TConclusionStatus DoStart() override {\n         return Scanner->Start();\n@@ -31,11 +30,11 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin\n         return sb;\n     }\n \n-    virtual std::vector<TPartialReadResult> DoExtractReadyResults(const int64_t maxRowsInBatch) override;\n+    virtual std::vector<std::shared_ptr<TPartialReadResult>> DoExtractReadyResults(const int64_t maxRowsInBatch) override;\n     virtual TConclusion<bool> DoReadNextInterval() override;\n \n     virtual void DoAbort() override {\n-        AbortedFlag = true;\n+        SpecialReadContext->Abort();\n         Scanner->Abort();\n         PartialResults.clear();\n         Y_ABORT_UNLESS(IsFinished());\n@@ -68,7 +67,7 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin\n \n     TPlainReadData(const std::shared_ptr<TReadContext>& context);\n     ~TPlainReadData() {\n-        if (!AbortedFlag) {\n+        if (!SpecialReadContext->IsAborted()) {\n             Abort(\"unexpected on destructor\");\n         }\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp\nindex e8570ed328e5..87de386beda9 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp\n@@ -1,27 +1,33 @@\n-#include \"scanner.h\"\n #include \"plain_read_data.h\"\n+#include \"scanner.h\"\n+\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h>\n+\n #include <ydb/library/actors/core/log.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n-void TScanHead::OnIntervalResult(const std::optional<NArrow::TShardedRecordBatch>& newBatch, const std::shared_ptr<arrow::RecordBatch>& lastPK,\n+void TScanHead::OnIntervalResult(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& allocationGuard,\n+    const std::optional<NArrow::TShardedRecordBatch>& newBatch, const std::shared_ptr<arrow::RecordBatch>& lastPK,\n     std::unique_ptr<NArrow::NMerger::TMergePartialStream>&& merger, const ui32 intervalIdx, TPlainReadData& reader) {\n-    if (Context->GetReadMetadata()->Limit && (!newBatch || newBatch->GetRecordsCount() == 0) && InFlightLimit < 1000) {\n-        if (++ZeroCount == std::max<ui64>(16, InFlightLimit)) {\n-            InFlightLimit = std::min<ui32>(MaxInFlight, InFlightLimit * 2);\n-            ZeroCount = 0;\n-        }\n-    } else {\n-        ZeroCount = 0;\n+    if (Context->GetReadMetadata()->Limit && (!newBatch || newBatch->GetRecordsCount() == 0) && InFlightLimit < MaxInFlight) {\n+        InFlightLimit = std::min<ui32>(MaxInFlight, InFlightLimit * 4);\n     }\n     auto itInterval = FetchingIntervals.find(intervalIdx);\n     AFL_VERIFY(itInterval != FetchingIntervals.end());\n     itInterval->second->SetMerger(std::move(merger));\n     AFL_VERIFY(Context->GetCommonContext()->GetReadMetadata()->IsSorted());\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"interval_result_received\")(\"interval_idx\", intervalIdx)(\n+        \"intervalId\", itInterval->second->GetIntervalId());\n     if (newBatch && newBatch->GetRecordsCount()) {\n-        const std::optional<ui32> callbackIdxSubscriver = itInterval->second->HasMerger() ? std::optional<ui32>(intervalIdx) : std::nullopt;\n-        AFL_VERIFY(ReadyIntervals.emplace(intervalIdx, std::make_shared<TPartialReadResult>(itInterval->second->GetResourcesGuard(), *newBatch, lastPK, callbackIdxSubscriver)).second);\n+        std::optional<ui32> callbackIdxSubscriver;\n+        std::shared_ptr<NGroupedMemoryManager::TGroupGuard> gGuard;\n+        if (itInterval->second->HasMerger()) {\n+            callbackIdxSubscriver = intervalIdx;\n+        } else {\n+            gGuard = itInterval->second->GetGroupGuard();\n+        }\n+        AFL_VERIFY(ReadyIntervals.emplace(intervalIdx, std::make_shared<TPartialReadResult>(std::move(allocationGuard), std::move(gGuard), *newBatch, lastPK, callbackIdxSubscriver)).second);\n     } else {\n         AFL_VERIFY(ReadyIntervals.emplace(intervalIdx, nullptr).second);\n     }\n@@ -31,9 +37,13 @@ void TScanHead::OnIntervalResult(const std::optional<NArrow::TShardedRecordBatch\n         const ui32 intervalIdx = interval->GetIntervalIdx();\n         auto it = ReadyIntervals.find(intervalIdx);\n         if (it == ReadyIntervals.end()) {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"interval_result_absent\")(\"interval_idx\", intervalIdx)(\n+                \"merger\", interval->HasMerger())(\"interval_id\", interval->GetIntervalId());\n             break;\n+        } else {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"interval_result\")(\"interval_idx\", intervalIdx)(\"count\",\n+                it->second ? it->second->GetRecordsCount() : 0)(\"merger\", interval->HasMerger())(\"interval_id\", interval->GetIntervalId());\n         }\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"interval_result\")(\"interval_idx\", intervalIdx)(\"count\", it->second ? it->second->GetRecordsCount() : 0);\n         auto result = it->second;\n         ReadyIntervals.erase(it);\n         if (result) {\n@@ -51,7 +61,8 @@ void TScanHead::OnIntervalResult(const std::optional<NArrow::TShardedRecordBatch\n         AFL_VERIFY(ReadyIntervals.empty());\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"intervals_finished\");\n     } else {\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"wait_interval\")(\"remained\", FetchingIntervals.size())(\"interval_idx\", FetchingIntervals.begin()->first);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"wait_interval\")(\"remained\", FetchingIntervals.size())(\n+            \"interval_idx\", FetchingIntervals.begin()->first);\n     }\n }\n \n@@ -67,7 +78,8 @@ TConclusionStatus TScanHead::Start() {\n                 i.second->IncIntervalsCount();\n             }\n             if (!detectorResult) {\n-                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"scanner_initializer_aborted\")(\"reason\", detectorResult.GetErrorMessage());\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"scanner_initializer_aborted\")(\n+                    \"reason\", detectorResult.GetErrorMessage());\n                 Abort();\n                 return detectorResult;\n             }\n@@ -83,9 +95,11 @@ TConclusionStatus TScanHead::Start() {\n             for (auto&& i : context.GetCurrentSources()) {\n                 i.second->IncIntervalsCount();\n             }\n-            auto detectorResult = DetectSourcesFeatureInContextIntervalScan(context.GetCurrentSources(), guaranteeExclusivePK || context.GetIsExclusiveInterval());\n+            auto detectorResult =\n+                DetectSourcesFeatureInContextIntervalScan(context.GetCurrentSources(), guaranteeExclusivePK || context.GetIsExclusiveInterval());\n             if (!detectorResult) {\n-                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"scanner_initializer_aborted\")(\"reason\", detectorResult.GetErrorMessage());\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"scanner_initializer_aborted\")(\n+                    \"reason\", detectorResult.GetErrorMessage());\n                 Abort();\n                 return detectorResult;\n             }\n@@ -95,14 +109,8 @@ TConclusionStatus TScanHead::Start() {\n }\n \n TScanHead::TScanHead(std::deque<std::shared_ptr<IDataSource>>&& sources, const std::shared_ptr<TSpecialReadContext>& context)\n-    : Context(context)\n-{\n-    \n+    : Context(context) {\n     if (HasAppData()) {\n-        if (AppDataVerified().ColumnShardConfig.HasMaxInFlightMemoryOnRequest()) {\n-            MaxInFlightMemory = AppDataVerified().ColumnShardConfig.GetMaxInFlightMemoryOnRequest();\n-        }\n-\n         if (AppDataVerified().ColumnShardConfig.HasMaxInFlightIntervalsOnRequest()) {\n             MaxInFlight = AppDataVerified().ColumnShardConfig.GetMaxInFlightIntervalsOnRequest();\n         }\n@@ -125,88 +133,89 @@ class TSourcesStorageForMemoryOptimization {\n private:\n     class TSourceInfo {\n     private:\n+        YDB_READONLY(ui64, Memory, 0);\n         YDB_READONLY_DEF(std::shared_ptr<IDataSource>, Source);\n         YDB_READONLY_DEF(std::shared_ptr<TFetchingScript>, FetchingInfo);\n+\n     public:\n         TSourceInfo(const std::shared_ptr<IDataSource>& source, const std::shared_ptr<TFetchingScript>& fetchingInfo)\n             : Source(source)\n-            , FetchingInfo(fetchingInfo)\n-        {\n-\n+            , FetchingInfo(fetchingInfo) {\n+            Memory = FetchingInfo->PredictRawBytes(Source);\n         }\n \n         NJson::TJsonValue DebugJson() const {\n             NJson::TJsonValue result = NJson::JSON_MAP;\n             result.InsertValue(\"source\", Source->DebugJsonForMemory());\n-//            result.InsertValue(\"fetching\", Fetching->DebugJsonForMemory());\n+            result.InsertValue(\"memory\", Memory);\n+            //            result.InsertValue(\"FetchingInfo\", FetchingInfo->DebugJsonForMemory());\n+            return result;\n+        }\n+\n+        bool ReduceMemory() {\n+            const bool result = FetchingInfo->InitSourceSeqColumnIds(Source);\n+            if (result) {\n+                Memory = FetchingInfo->PredictRawBytes(Source);\n+            }\n             return result;\n         }\n+\n+        bool operator<(const TSourceInfo& item) const {\n+            return Memory < item.Memory;\n+        }\n+\n     };\n \n-    std::map<ui64, THashMap<ui32, TSourceInfo>> Sources;\n+    std::vector<TSourceInfo> Sources;\n     YDB_READONLY(ui64, MemorySum, 0);\n-    YDB_READONLY_DEF(std::set<ui64>, PathIds);\n+\n public:\n     TString DebugString() const {\n         NJson::TJsonValue resultJson;\n         auto& memorySourcesArr = resultJson.InsertValue(\"sources_by_memory\", NJson::JSON_ARRAY);\n         resultJson.InsertValue(\"sources_by_memory_count\", Sources.size());\n-        for (auto it = Sources.rbegin(); it != Sources.rend(); ++it) {\n+        for (auto&& it: Sources) {\n             auto& sourceMap = memorySourcesArr.AppendValue(NJson::JSON_MAP);\n-            sourceMap.InsertValue(\"memory\", it->first);\n             auto& sourcesArr = sourceMap.InsertValue(\"sources\", NJson::JSON_ARRAY);\n-            for (auto&& s : it->second) {\n-                sourcesArr.AppendValue(s.second.DebugJson());\n-            }\n+            sourcesArr.AppendValue(it.DebugJson());\n         }\n         return resultJson.GetStringRobust();\n     }\n \n-    void UpdateSource(const ui64 oldMemoryInfo, const ui32 sourceIdx) {\n-        auto it = Sources.find(oldMemoryInfo);\n-        AFL_VERIFY(it != Sources.end());\n-        auto itSource = it->second.find(sourceIdx);\n-        AFL_VERIFY(itSource != it->second.end());\n-        auto sourceInfo = itSource->second;\n-        it->second.erase(itSource);\n-        if (it->second.empty()) {\n-            Sources.erase(it);\n-        }\n-        AFL_VERIFY(MemorySum >= oldMemoryInfo);\n-        MemorySum -= oldMemoryInfo;\n-        AddSource(sourceInfo.GetSource(), sourceInfo.GetFetchingInfo());\n-    }\n-\n     void AddSource(const std::shared_ptr<IDataSource>& source, const std::shared_ptr<TFetchingScript>& fetching) {\n-        const ui64 sourceMemory = fetching->PredictRawBytes(source);\n-        MemorySum += sourceMemory;\n-        AFL_VERIFY(Sources[sourceMemory].emplace(source->GetSourceIdx(), TSourceInfo(source, fetching)).second);\n-        PathIds.emplace(source->GetPathId());\n+        Sources.emplace_back(TSourceInfo(source, fetching));\n+        MemorySum += Sources.back().GetMemory();\n     }\n \n     bool Optimize(const ui64 memoryLimit) {\n-        bool modified = true;\n-        while (MemorySum > memoryLimit && modified) {\n-            modified = false;\n-            for (auto it = Sources.rbegin(); it != Sources.rend(); ++it) {\n-                for (auto&& [sourceIdx, sourceInfo] : it->second) {\n-                    if (!sourceInfo.GetFetchingInfo()->InitSourceSeqColumnIds(sourceInfo.GetSource())) {\n-                        continue;\n-                    }\n-                    modified = true;\n-                    UpdateSource(it->first, sourceIdx);\n-                    break;\n-                }\n-                if (modified) {\n-                    break;\n+        if (MemorySum <= memoryLimit) {\n+            return true;\n+        }\n+        std::sort(Sources.begin(), Sources.end());\n+        while (true) {\n+            std::vector<TSourceInfo> nextSources;\n+            while (memoryLimit < MemorySum && Sources.size()) {\n+                const ui64 currentMemory = Sources.back().GetMemory();\n+                if (Sources.back().ReduceMemory()) {\n+                    AFL_VERIFY(currentMemory <= MemorySum);\n+                    MemorySum -= currentMemory;\n+                    MemorySum += Sources.back().GetMemory();\n+                    nextSources.emplace_back(std::move(Sources.back()));\n                 }\n+                Sources.pop_back();\n             }\n+            if (nextSources.empty() || MemorySum <= memoryLimit) {\n+                break;\n+            }\n+            std::sort(nextSources.begin(), nextSources.end());\n+            std::swap(nextSources, Sources);\n         }\n-        return MemorySum < memoryLimit;\n+        return MemorySum <= memoryLimit;\n     }\n };\n \n-TConclusionStatus TScanHead::DetectSourcesFeatureInContextIntervalScan(const THashMap<ui32, std::shared_ptr<IDataSource>>& intervalSources, const bool isExclusiveInterval) const {\n+TConclusionStatus TScanHead::DetectSourcesFeatureInContextIntervalScan(\n+    const THashMap<ui32, std::shared_ptr<IDataSource>>& intervalSources, const bool isExclusiveInterval) const {\n     TSourcesStorageForMemoryOptimization optimizer;\n     for (auto&& i : intervalSources) {\n         if (!isExclusiveInterval) {\n@@ -217,23 +226,18 @@ TConclusionStatus TScanHead::DetectSourcesFeatureInContextIntervalScan(const THa\n     }\n     const ui64 startMemory = optimizer.GetMemorySum();\n     if (!optimizer.Optimize(Context->ReduceMemoryIntervalLimit) && Context->RejectMemoryIntervalLimit < optimizer.GetMemorySum()) {\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"next_internal_broken\")\n-            (\"reason\", \"a lot of memory need\")(\"start\", startMemory)\n-            (\"reduce_limit\", Context->ReduceMemoryIntervalLimit)\n-            (\"reject_limit\", Context->RejectMemoryIntervalLimit)\n-            (\"need\", optimizer.GetMemorySum())\n-            (\"path_ids\", JoinSeq(\",\", optimizer.GetPathIds()))\n-            (\"details\", IS_LOG_PRIORITY_ENABLED(NActors::NLog::PRI_DEBUG, NKikimrServices::TX_COLUMNSHARD_SCAN) ? optimizer.DebugString() : \"NEED_DEBUG_LEVEL\");\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"next_internal_broken\")(\"reason\", \"a lot of memory need\")(\"start\", startMemory)(\n+            \"reduce_limit\", Context->ReduceMemoryIntervalLimit)(\"reject_limit\", Context->RejectMemoryIntervalLimit)(\n+            \"need\", optimizer.GetMemorySum())(\"path_id\", Context->GetReadMetadata()->GetPathId())(\n+            \"details\", IS_LOG_PRIORITY_ENABLED(NActors::NLog::PRI_DEBUG, NKikimrServices::TX_COLUMNSHARD_SCAN) ? optimizer.DebugString()\n+                                                                                                               : \"NEED_DEBUG_LEVEL\");\n         Context->GetCommonContext()->GetCounters().OnOptimizedIntervalMemoryFailed(optimizer.GetMemorySum());\n-        return TConclusionStatus::Fail(\"We need a lot of memory in time for interval scanner: \" +\n-            ::ToString(optimizer.GetMemorySum()) + \" path_ids: \" + JoinSeq(\",\", optimizer.GetPathIds()) + \". We need wait compaction processing. Sorry.\");\n+        return TConclusionStatus::Fail(\"We need a lot of memory in time for interval scanner: \" + ::ToString(optimizer.GetMemorySum()) +\n+                                       \" path_id: \" + Context->GetReadMetadata()->GetPathId() + \". We need wait compaction processing. Sorry.\");\n     } else if (optimizer.GetMemorySum() < startMemory) {\n-        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"memory_reduce_active\")\n-            (\"reason\", \"need reduce memory\")(\"start\", startMemory)\n-            (\"reduce_limit\", Context->ReduceMemoryIntervalLimit)\n-            (\"reject_limit\", Context->RejectMemoryIntervalLimit)\n-            (\"need\", optimizer.GetMemorySum())\n-            (\"path_ids\", JoinSeq(\",\", optimizer.GetPathIds()));\n+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"memory_reduce_active\")(\"reason\", \"need reduce memory\")(\"start\", startMemory)(\n+            \"reduce_limit\", Context->ReduceMemoryIntervalLimit)(\"reject_limit\", Context->RejectMemoryIntervalLimit)(\n+            \"need\", optimizer.GetMemorySum())(\"path_id\", Context->GetReadMetadata()->GetPathId());\n         Context->GetCommonContext()->GetCounters().OnOptimizedIntervalMemoryReduced(startMemory - optimizer.GetMemorySum());\n     }\n     Context->GetCommonContext()->GetCounters().OnOptimizedIntervalMemoryRequired(optimizer.GetMemorySum());\n@@ -241,7 +245,7 @@ TConclusionStatus TScanHead::DetectSourcesFeatureInContextIntervalScan(const THa\n }\n \n TConclusion<bool> TScanHead::BuildNextInterval() {\n-    if (AbortFlag) {\n+    if (Context->IsAborted()) {\n         return false;\n     }\n     while (BorderPoints.size()) {\n@@ -251,11 +255,6 @@ TConclusion<bool> TScanHead::BuildNextInterval() {\n                     \"count\", FetchingIntervals.size())(\"limit\", InFlightLimit);\n                 return false;\n             }\n-            if (Context->GetCommonContext()->GetCounters().GetRequestedMemoryBytes() >= MaxInFlightMemory) {\n-                AFL_TRACE(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"skip_next_interval\")(\"reason\", \"a lot of memory in usage\")(\n-                    \"volume\", Context->GetCommonContext()->GetCounters().GetRequestedMemoryBytes())(\"limit\", MaxInFlightMemory);\n-                return false;\n-            }\n         }\n         auto firstBorderPointInfo = std::move(BorderPoints.begin()->second);\n         CurrentState.OnStartPoint(firstBorderPointInfo);\n@@ -266,7 +265,6 @@ TConclusion<bool> TScanHead::BuildNextInterval() {\n                 CurrentState.GetCurrentSources(), Context, true, true, false);\n             FetchingIntervals.emplace(intervalIdx, interval);\n             IntervalStats.emplace_back(CurrentState.GetCurrentSources().size(), true);\n-            NResourceBroker::NSubscribe::ITask::StartResourceSubscription(Context->GetCommonContext()->GetResourceSubscribeActorId(), interval);\n             AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"new_interval\")(\"interval_idx\", intervalIdx)(\n                 \"interval\", interval->DebugJson());\n         }\n@@ -286,7 +284,6 @@ TConclusion<bool> TScanHead::BuildNextInterval() {\n             IntervalStats.emplace_back(CurrentState.GetCurrentSources().size(), false);\n             AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"new_interval\")(\"interval_idx\", intervalIdx)(\n                 \"interval\", interval->DebugJson());\n-            NResourceBroker::NSubscribe::ITask::StartResourceSubscription(Context->GetCommonContext()->GetResourceSubscribeActorId(), interval);\n             return true;\n         } else {\n             IntervalStats.emplace_back(CurrentState.GetCurrentSources().size(), false);\n@@ -304,7 +301,7 @@ bool TScanHead::IsReverse() const {\n }\n \n void TScanHead::Abort() {\n-    AbortFlag = true;\n+    AFL_VERIFY(Context->IsAborted());\n     THashSet<ui32> sourceIds;\n     for (auto&& i : FetchingIntervals) {\n         for (auto&& s : i.second->GetSources()) {\n@@ -329,4 +326,4 @@ void TScanHead::Abort() {\n     Y_ABORT_UNLESS(IsFinished());\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h\nindex d03680a821a0..09649e788147 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h\n@@ -80,14 +80,12 @@ class TScanHead {\n     std::vector<TIntervalStat> IntervalStats;\n     ui64 InFlightLimit = 1;\n     ui64 MaxInFlight = 256;\n-    ui64 MaxInFlightMemory = TGlobalLimits::ScanMemoryLimit;\n     ui64 ZeroCount = 0;\n-    bool AbortFlag = false;\n     void DrainSources();\n     [[nodiscard]] TConclusionStatus DetectSourcesFeatureInContextIntervalScan(const THashMap<ui32, std::shared_ptr<IDataSource>>& intervalSources, const bool isExclusiveInterval) const;\n public:\n     void OnSentDataFromInterval(const ui32 intervalIdx) const {\n-        if (AbortFlag) {\n+        if (Context->IsAborted()) {\n             return;\n         }\n         auto it = FetchingIntervals.find(intervalIdx);\n@@ -112,8 +110,10 @@ class TScanHead {\n         return sb;\n     }\n \n-    void OnIntervalResult(const std::optional<NArrow::TShardedRecordBatch>& batch, const std::shared_ptr<arrow::RecordBatch>& lastPK, \n-        std::unique_ptr<NArrow::NMerger::TMergePartialStream>&& merger, const ui32 intervalIdx, TPlainReadData& reader);\n+    void OnIntervalResult(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& allocationGuard,\n+        const std::optional<NArrow::TShardedRecordBatch>& batch,\n+        const std::shared_ptr<arrow::RecordBatch>& lastPK, std::unique_ptr<NArrow::NMerger::TMergePartialStream>&& merger,\n+        const ui32 intervalIdx, TPlainReadData& reader);\n \n     TConclusionStatus Start();\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp\nindex b5927acc8d1a..bef10d38f6b1 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp\n@@ -1,15 +1,15 @@\n-#include \"source.h\"\n-\n #include \"constructor.h\"\n #include \"fetched_data.h\"\n #include \"interval.h\"\n #include \"plain_read_data.h\"\n+#include \"source.h\"\n \n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n #include <ydb/core/tx/columnshard/blobs_reader/actor.h>\n #include <ydb/core/tx/columnshard/blobs_reader/events.h>\n #include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n #include <ydb/core/tx/conveyor/usage/service.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n \n namespace NKikimr::NOlap::NReader::NPlain {\n \n@@ -19,30 +19,19 @@ void IDataSource::InitFetchingPlan(const std::shared_ptr<TFetchingScript>& fetch\n     FetchingPlan = fetching;\n }\n \n-void IDataSource::RegisterInterval(TFetchingInterval& interval) {\n+void IDataSource::RegisterInterval(TFetchingInterval& interval, const std::shared_ptr<IDataSource>& sourcePtr) {\n     AFL_VERIFY(FetchingPlan);\n+    AFL_VERIFY(!Context->IsAborted());\n     if (!IsReadyFlag) {\n         AFL_VERIFY(Intervals.emplace(interval.GetIntervalIdx(), &interval).second);\n     }\n-}\n-\n-void IDataSource::SetIsReady() {\n-    AFL_VERIFY(!IsReadyFlag);\n-    IsReadyFlag = true;\n-    for (auto&& i : Intervals) {\n-        i.second->OnSourceFetchStageReady(SourceIdx);\n-    }\n-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"source_ready\")(\"intervals_count\", Intervals.size())(\"source_idx\", SourceIdx);\n-    Intervals.clear();\n-}\n-\n-void IDataSource::OnInitResourcesGuard(const std::shared_ptr<IDataSource>& sourcePtr) {\n-    AFL_VERIFY(FetchingPlan);\n-    if (AtomicCas(&FilterStageFlag, 1, 0)) {\n+    if (AtomicCas(&SourceStartedFlag, 1, 0)) {\n+        SetFirstIntervalId(interval.GetIntervalId());\n+        AFL_VERIFY(FetchingPlan);\n         StageData = std::make_unique<TFetchedData>(GetExclusiveIntervalOnly() && IsSourceInMemory());\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"InitFetchingPlan\", FetchingPlan->DebugString())(\"source_idx\", SourceIdx);\n         NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()(\"source\", SourceIdx)(\"method\", \"InitFetchingPlan\"));\n-        if (IsAborted()) {\n+        if (Context->IsAborted()) {\n             AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"InitFetchingPlanAborted\");\n             return;\n         }\n@@ -52,6 +41,16 @@ void IDataSource::OnInitResourcesGuard(const std::shared_ptr<IDataSource>& sourc\n     }\n }\n \n+void IDataSource::SetIsReady() {\n+    AFL_VERIFY(!IsReadyFlag);\n+    IsReadyFlag = true;\n+    for (auto&& i : Intervals) {\n+        i.second->OnSourceFetchStageReady(SourceIdx);\n+    }\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"source_ready\")(\"intervals_count\", Intervals.size())(\"source_idx\", SourceIdx);\n+    Intervals.clear();\n+}\n+\n void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlobsAction& blobsAction,\n     THashMap<TChunkAddress, TPortionInfo::TAssembleBlobInfo>& defaultBlocks, const std::shared_ptr<NArrow::TColumnFilter>& filter) {\n     const NArrow::TColumnFilter& cFilter = filter ? *filter : NArrow::TColumnFilter::BuildAllowFilter();\n@@ -65,9 +64,10 @@ void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlob\n         auto itFilter = cFilter.GetIterator(false, Portion->NumRows(i));\n         bool itFinished = false;\n         for (auto&& c : columnChunks) {\n-            Y_ABORT_UNLESS(!itFinished);\n+            AFL_VERIFY(!itFinished);\n             if (!itFilter.IsBatchForSkip(c->GetMeta().GetNumRows())) {\n-                auto reading = blobsAction.GetReading(Schema->GetIndexInfo().GetColumnStorageId(c->GetColumnId(), Portion->GetMeta().GetTierName()));\n+                auto reading =\n+                    blobsAction.GetReading(Schema->GetIndexInfo().GetColumnStorageId(c->GetColumnId(), Portion->GetMeta().GetTierName()));\n                 reading->SetIsBackgroundProcess(false);\n                 reading->AddRange(Portion->RestoreBlobRange(c->BlobRange));\n                 ++fetchedChunks;\n@@ -80,15 +80,16 @@ void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlob\n         }\n         AFL_VERIFY(itFinished)(\"filter\", itFilter.DebugString())(\"count\", Portion->NumRows(i));\n     }\n-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"chunks_stats\")(\"fetch\", fetchedChunks)(\"null\", nullChunks)\n-        (\"reading_actions\", blobsAction.GetStorageIds())(\"columns\", columnIds.size());\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"chunks_stats\")(\"fetch\", fetchedChunks)(\"null\", nullChunks)(\n+        \"reading_actions\", blobsAction.GetStorageIds())(\"columns\", columnIds.size());\n }\n \n-bool TPortionDataSource::DoStartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TColumnsSet>& columns) {\n+bool TPortionDataSource::DoStartFetchingColumns(\n+    const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) {\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName());\n-    AFL_VERIFY(columns->GetColumnsCount());\n+    AFL_VERIFY(columns.GetColumnsCount());\n     AFL_VERIFY(!StageData->GetAppliedFilter() || !StageData->GetAppliedFilter()->IsTotalDenyFilter());\n-    auto& columnIds = columns->GetColumnIds();\n+    auto& columnIds = columns.GetColumnIds();\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName())(\"fetching_info\", step.DebugString());\n \n     TBlobsAction action(GetContext()->GetCommonContext()->GetStoragesManager(), NBlobOperations::EConsumer::SCAN);\n@@ -108,9 +109,10 @@ bool TPortionDataSource::DoStartFetchingColumns(const std::shared_ptr<IDataSourc\n     return true;\n }\n \n-bool TPortionDataSource::DoStartFetchingIndexes(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) {\n+bool TPortionDataSource::DoStartFetchingIndexes(\n+    const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) {\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName());\n-    Y_ABORT_UNLESS(indexes->GetIndexesCount());\n+    AFL_VERIFY(indexes->GetIndexesCount());\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName())(\"fetching_info\", step.DebugString());\n \n     TBlobsAction action(GetContext()->GetCommonContext()->GetStoragesManager(), NBlobOperations::EConsumer::SCAN);\n@@ -191,7 +193,8 @@ void TPortionDataSource::DoAssembleColumns(const std::shared_ptr<TColumnsSet>& c\n                                     .AssembleToGeneralContainer(SequentialEntityIds));\n }\n \n-bool TCommittedDataSource::DoStartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TColumnsSet>& /*columns*/) {\n+bool TCommittedDataSource::DoStartFetchingColumns(\n+    const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& /*columns*/) {\n     if (ReadStarted) {\n         return false;\n     }\n@@ -204,7 +207,7 @@ bool TCommittedDataSource::DoStartFetchingColumns(const std::shared_ptr<IDataSou\n     readAction->SetIsBackgroundProcess(false);\n     readAction->AddRange(CommittedBlob.GetBlobRange());\n \n-    std::vector<std::shared_ptr<IBlobsReadingAction>> actions = {readAction};\n+    std::vector<std::shared_ptr<IBlobsReadingAction>> actions = { readAction };\n     auto constructor = std::make_shared<TBlobsFetcherTask>(actions, sourcePtr, step, GetContext(), \"CS::READ::\" + step.GetName(), \"\");\n     NActors::TActivationContext::AsActorContext().Register(new NOlap::NBlobOperations::NRead::TActor(constructor));\n     return true;\n@@ -212,6 +215,8 @@ bool TCommittedDataSource::DoStartFetchingColumns(const std::shared_ptr<IDataSou\n \n void TCommittedDataSource::DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns) {\n     TMemoryProfileGuard mGuard(\"SCAN_PROFILE::ASSEMBLER::COMMITTED\", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n+    const ISnapshotSchema::TPtr batchSchema = GetContext()->GetReadMetadata()->GetIndexVersions().GetSchemaVerified(GetCommitted().GetSchemaVersion());\n+    const ISnapshotSchema::TPtr resultSchema = GetContext()->GetReadMetadata()->GetResultSchema();\n     if (!GetStageData().GetTable()) {\n         AFL_VERIFY(GetStageData().GetBlobs().size() == 1);\n         auto bData = MutableStageData().ExtractBlob(GetStageData().GetBlobs().begin()->first);\n@@ -219,11 +224,12 @@ void TCommittedDataSource::DoAssembleColumns(const std::shared_ptr<TColumnsSet>&\n         auto rBatch = NArrow::DeserializeBatch(bData, std::make_shared<arrow::Schema>(CommittedBlob.GetSchemaSubset().Apply(schema->fields())));\n         AFL_VERIFY(rBatch)(\"schema\", schema->ToString());\n         auto batch = std::make_shared<NArrow::TGeneralContainer>(rBatch);\n-        GetContext()->GetReadMetadata()->GetIndexInfo().AddSnapshotColumns(*batch, CommittedBlob.GetSnapshot());\n+        batchSchema->AdaptBatchToSchema(*batch, resultSchema);\n+        GetContext()->GetReadMetadata()->GetIndexInfo().AddSnapshotColumns(*batch, CommittedBlob.GetSnapshotDef(TSnapshot::Zero()));\n         GetContext()->GetReadMetadata()->GetIndexInfo().AddDeleteFlagsColumn(*batch, CommittedBlob.GetIsDelete());\n         MutableStageData().AddBatch(batch);\n     }\n-    MutableStageData().SyncTableColumns(columns->GetSchema()->fields(), *GetContext()->GetReadMetadata()->GetResultSchema());\n+    MutableStageData().SyncTableColumns(columns->GetSchema()->fields(), *resultSchema);\n }\n \n }   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h\nindex 30e7fe04bf52..889f9fe5e7d4 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h\n@@ -1,16 +1,18 @@\n #pragma once\n-#include \"context.h\"\n #include \"columns_set.h\"\n+#include \"context.h\"\n #include \"fetched_data.h\"\n+\n+#include <ydb/core/formats/arrow/arrow_helpers.h>\n+#include <ydb/core/formats/arrow/reader/position.h>\n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/action.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n-#include <ydb/core/tx/columnshard/engines/insert_table/data.h>\n-#include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.h>\n-#include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/reader/position.h>\n+#include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n+\n #include <util/string/join.h>\n \n namespace NKikimr::NOlap {\n@@ -41,8 +43,13 @@ class IDataSource {\n     YDB_READONLY(ui32, IntervalsCount, 0);\n     virtual NJson::TJsonValue DoDebugJson() const = 0;\n     bool MergingStartedFlag = false;\n-    bool AbortedFlag = false;\n+    TAtomic SourceStartedFlag = 0;\n     std::shared_ptr<TFetchingScript> FetchingPlan;\n+    std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>> ResourceGuards;\n+    std::optional<ui64> FirstIntervalId;\n+    ui32 CurrentPlanStepIndex = 0;\n+    YDB_READONLY(TPKRangeFilter::EUsageClass, UsageClass, TPKRangeFilter::EUsageClass::PartialUsage);\n+\n protected:\n     bool IsSourceInMemoryFlag = true;\n     THashMap<ui32, TFetchingInterval*> Intervals;\n@@ -53,8 +60,10 @@ class IDataSource {\n     TAtomic FilterStageFlag = 0;\n     bool IsReadyFlag = false;\n \n-    virtual bool DoStartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TColumnsSet>& columns) = 0;\n-    virtual bool DoStartFetchingIndexes(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) = 0;\n+    virtual bool DoStartFetchingColumns(\n+        const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) = 0;\n+    virtual bool DoStartFetchingIndexes(\n+        const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) = 0;\n     virtual void DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns) = 0;\n     virtual void DoAbort() = 0;\n     virtual void DoApplyIndex(const NIndexes::TIndexCheckerContainer& indexMeta) = 0;\n@@ -62,15 +71,43 @@ class IDataSource {\n     virtual NJson::TJsonValue DoDebugJsonForMemory() const {\n         return NJson::JSON_MAP;\n     }\n+    virtual bool DoAddTxConflict() = 0;\n+\n public:\n-    void OnInitResourcesGuard(const std::shared_ptr<IDataSource>& sourcePtr);\n+    bool AddTxConflict() {\n+        if (!Context->GetCommonContext()->HasLock()) {\n+            return false;\n+        }\n+        if (DoAddTxConflict()) {\n+            StageData->Clear();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    ui64 GetResourceGuardsMemory() const {\n+        ui64 result = 0;\n+        for (auto&& i : ResourceGuards) {\n+            result += i->GetMemory();\n+        }\n+        return result;\n+    }\n \n-    bool IsAborted() const {\n-        return AbortedFlag;\n+    void RegisterAllocationGuard(const std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>& guard) {\n+        ResourceGuards.emplace_back(guard);\n     }\n+\n     bool IsSourceInMemory() const {\n         return IsSourceInMemoryFlag;\n     }\n+    void SetFirstIntervalId(const ui64 value) {\n+        AFL_VERIFY(!FirstIntervalId);\n+        FirstIntervalId = value;\n+    }\n+    ui64 GetFirstIntervalId() const {\n+        AFL_VERIFY(!!FirstIntervalId);\n+        return *FirstIntervalId;\n+    }\n     virtual bool IsSourceInMemory(const std::set<ui32>& fieldIds) const = 0;\n     bool AddSequentialEntityIds(const ui32 entityId) {\n         if (DoAddSequentialEntityIds(entityId)) {\n@@ -114,12 +151,12 @@ class IDataSource {\n         DoAssembleColumns(columns);\n     }\n \n-    bool StartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TColumnsSet>& columns) {\n-        AFL_VERIFY(columns);\n+    bool StartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) {\n         return DoStartFetchingColumns(sourcePtr, step, columns);\n     }\n \n-    bool StartFetchingIndexes(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) {\n+    bool StartFetchingIndexes(\n+        const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) {\n         AFL_VERIFY(indexes);\n         return DoStartFetchingIndexes(sourcePtr, step, indexes);\n     }\n@@ -134,18 +171,18 @@ class IDataSource {\n \n     virtual ui64 GetColumnRawBytes(const std::set<ui32>& columnIds) const = 0;\n     virtual ui64 GetIndexRawBytes(const std::set<ui32>& indexIds) const = 0;\n+    virtual ui64 GetColumnBlobBytes(const std::set<ui32>& columnsIds) const = 0;\n \n     bool IsMergingStarted() const {\n         return MergingStartedFlag;\n     }\n \n     void StartMerging() {\n-        Y_ABORT_UNLESS(!MergingStartedFlag);\n+        AFL_VERIFY(!MergingStartedFlag);\n         MergingStartedFlag = true;\n     }\n \n     void Abort() {\n-        AbortedFlag = true;\n         Intervals.clear();\n         DoAbort();\n     }\n@@ -172,6 +209,17 @@ class IDataSource {\n         return IsReadyFlag;\n     }\n \n+    void OnEmptyStageData() {\n+        if (!ResourceGuards.size()) {\n+            return;\n+        }\n+        if (ExclusiveIntervalOnly) {\n+            ResourceGuards.back()->Update(0);\n+        } else {\n+            ResourceGuards.back()->Update(GetColumnRawBytes(Context->GetPKColumns()->GetColumnIds()));\n+        }\n+    }\n+\n     const TFetchedData& GetStageData() const {\n         AFL_VERIFY(StageData);\n         return *StageData;\n@@ -182,11 +230,11 @@ class IDataSource {\n         return *StageData;\n     }\n \n-    void RegisterInterval(TFetchingInterval& interval);\n+    void RegisterInterval(TFetchingInterval& interval, const std::shared_ptr<IDataSource>& sourcePtr);\n \n-    IDataSource(const ui32 sourceIdx, const std::shared_ptr<TSpecialReadContext>& context,\n-        const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& finish, const TSnapshot& recordSnapshotMin, const TSnapshot& recordSnapshotMax,\n-                const ui32 recordsCount, const std::optional<ui64> shardingVersion, const bool hasDeletions)\n+    IDataSource(const ui32 sourceIdx, const std::shared_ptr<TSpecialReadContext>& context, const NArrow::TReplaceKey& start,\n+        const NArrow::TReplaceKey& finish, const TSnapshot& recordSnapshotMin, const TSnapshot& recordSnapshotMax, const ui32 recordsCount,\n+        const std::optional<ui64> shardingVersion, const bool hasDeletions)\n         : SourceIdx(sourceIdx)\n         , Start(context->GetReadMetadata()->BuildSortedPosition(start))\n         , Finish(context->GetReadMetadata()->BuildSortedPosition(finish))\n@@ -197,8 +245,9 @@ class IDataSource {\n         , RecordSnapshotMax(recordSnapshotMax)\n         , RecordsCount(recordsCount)\n         , ShardingVersionOptional(shardingVersion)\n-        , HasDeletions(hasDeletions)\n-    {\n+        , HasDeletions(hasDeletions) {\n+        UsageClass = Context->GetReadMetadata()->GetPKRangesFilter().IsPortionInPartialUsage(GetStartReplaceKey(), GetFinishReplaceKey());\n+        AFL_VERIFY(UsageClass != TPKRangeFilter::EUsageClass::DontUsage);\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"portions_for_merge\")(\"start\", Start.DebugJson())(\"finish\", Finish.DebugJson());\n         if (Start.IsReverseSort()) {\n             std::swap(Start, Finish);\n@@ -207,7 +256,7 @@ class IDataSource {\n     }\n \n     virtual ~IDataSource() {\n-        Y_ABORT_UNLESS(AbortedFlag || Intervals.empty());\n+        AFL_VERIFY(Intervals.empty());\n     }\n };\n \n@@ -217,14 +266,16 @@ class TPortionDataSource: public IDataSource {\n     std::set<ui32> SequentialEntityIds;\n     std::shared_ptr<TPortionInfo> Portion;\n     std::shared_ptr<ISnapshotSchema> Schema;\n+    mutable THashMap<ui64, ui64> FingerprintedData;\n \n-    void NeedFetchColumns(const std::set<ui32>& columnIds,\n-        TBlobsAction& blobsAction, THashMap<TChunkAddress, TPortionInfo::TAssembleBlobInfo>& nullBlocks,\n-        const std::shared_ptr<NArrow::TColumnFilter>& filter);\n+    void NeedFetchColumns(const std::set<ui32>& columnIds, TBlobsAction& blobsAction,\n+        THashMap<TChunkAddress, TPortionInfo::TAssembleBlobInfo>& nullBlocks, const std::shared_ptr<NArrow::TColumnFilter>& filter);\n \n     virtual void DoApplyIndex(const NIndexes::TIndexCheckerContainer& indexChecker) override;\n-    virtual bool DoStartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TColumnsSet>& columns) override;\n-    virtual bool DoStartFetchingIndexes(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) override;\n+    virtual bool DoStartFetchingColumns(\n+        const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) override;\n+    virtual bool DoStartFetchingIndexes(\n+        const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TIndexesSet>& indexes) override;\n     virtual void DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns) override;\n     virtual NJson::TJsonValue DoDebugJson() const override {\n         NJson::TJsonValue result = NJson::JSON_MAP;\n@@ -239,7 +290,7 @@ class TPortionDataSource: public IDataSource {\n         for (auto&& i : SequentialEntityIds) {\n             AFL_VERIFY(columns.erase(i));\n         }\n-//        result.InsertValue(\"sequential_columns\", JoinSeq(\",\", SequentialEntityIds));\n+        //        result.InsertValue(\"sequential_columns\", JoinSeq(\",\", SequentialEntityIds));\n         if (SequentialEntityIds.size()) {\n             result.InsertValue(\"min_memory_seq\", Portion->GetMinMemoryForReadColumns(SequentialEntityIds));\n             result.InsertValue(\"min_memory_seq_blobs\", Portion->GetColumnBlobBytes(SequentialEntityIds));\n@@ -257,10 +308,16 @@ class TPortionDataSource: public IDataSource {\n         return Portion->GetPathId();\n     }\n     virtual bool DoAddSequentialEntityIds(const ui32 entityId) override {\n+        FingerprintedData.clear();\n         return SequentialEntityIds.emplace(entityId).second;\n     }\n \n public:\n+    virtual bool DoAddTxConflict() override {\n+        GetContext()->GetReadMetadata()->SetBrokenWithCommitted();\n+        return false;\n+    }\n+\n     virtual bool HasIndexes(const std::set<ui32>& indexIds) const override {\n         return Portion->HasIndexes(indexIds);\n     }\n@@ -279,6 +336,13 @@ class TPortionDataSource: public IDataSource {\n     }\n \n     virtual ui64 GetColumnRawBytes(const std::set<ui32>& columnsIds) const override {\n+        AFL_VERIFY(columnsIds.size());\n+        const ui64 fp = CombineHashes(*columnsIds.begin(), *columnsIds.rbegin());\n+        auto it = FingerprintedData.find(fp);\n+        if (it != FingerprintedData.end()) {\n+            return it->second;\n+        }\n+        ui64 result = 0;\n         if (SequentialEntityIds.size()) {\n             std::set<ui32> selectedSeq;\n             std::set<ui32> selectedInMem;\n@@ -289,12 +353,17 @@ class TPortionDataSource: public IDataSource {\n                     selectedInMem.emplace(i);\n                 }\n             }\n-            return Portion->GetMinMemoryForReadColumns(selectedSeq)\n-                + Portion->GetColumnBlobBytes(selectedSeq)\n-                + Portion->GetColumnRawBytes(selectedInMem, false);\n+            result = Portion->GetMinMemoryForReadColumns(selectedSeq) + Portion->GetColumnBlobBytes(selectedSeq) +\n+                   Portion->GetColumnRawBytes(selectedInMem, false);\n         } else {\n-            return Portion->GetColumnRawBytes(columnsIds, false);\n+            result = Portion->GetColumnRawBytes(columnsIds, false);\n         }\n+        FingerprintedData.emplace(fp, result);\n+        return result;\n+    }\n+\n+    virtual ui64 GetColumnBlobBytes(const std::set<ui32>& columnsIds) const override {\n+        return Portion->GetColumnBlobBytes(columnsIds, false);\n     }\n \n     virtual ui64 GetIndexRawBytes(const std::set<ui32>& indexIds) const override {\n@@ -309,13 +378,11 @@ class TPortionDataSource: public IDataSource {\n         return Portion;\n     }\n \n-    TPortionDataSource(const ui32 sourceIdx, const std::shared_ptr<TPortionInfo>& portion, const std::shared_ptr<TSpecialReadContext>& context,\n-        const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& finish)\n-        : TBase(sourceIdx, context, start, finish, portion->RecordSnapshotMin(), portion->RecordSnapshotMax(), portion->GetRecordsCount(), portion->GetShardingVersionOptional(),\n-            portion->GetMeta().GetDeletionsCount())\n+    TPortionDataSource(const ui32 sourceIdx, const std::shared_ptr<TPortionInfo>& portion, const std::shared_ptr<TSpecialReadContext>& context)\n+        : TBase(sourceIdx, context, portion->IndexKeyStart(), portion->IndexKeyEnd(), portion->RecordSnapshotMin(), portion->RecordSnapshotMax(),\n+              portion->GetRecordsCount(), portion->GetShardingVersionOptional(), portion->GetMeta().GetDeletionsCount())\n         , Portion(portion)\n-        , Schema(GetContext()->GetReadMetadata()->GetLoadSchemaVerified(*Portion))\n-    {\n+        , Schema(GetContext()->GetReadMetadata()->GetLoadSchemaVerified(*Portion)) {\n     }\n };\n \n@@ -326,11 +393,12 @@ class TCommittedDataSource: public IDataSource {\n     bool ReadStarted = false;\n \n     virtual void DoAbort() override {\n-\n     }\n \n-    virtual bool DoStartFetchingColumns(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const std::shared_ptr<TColumnsSet>& columns) override;\n-    virtual bool DoStartFetchingIndexes(const std::shared_ptr<IDataSource>& /*sourcePtr*/, const TFetchingScriptCursor& /*step*/, const std::shared_ptr<TIndexesSet>& /*indexes*/) override {\n+    virtual bool DoStartFetchingColumns(\n+        const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) override;\n+    virtual bool DoStartFetchingIndexes(const std::shared_ptr<IDataSource>& /*sourcePtr*/, const TFetchingScriptCursor& /*step*/,\n+        const std::shared_ptr<TIndexesSet>& /*indexes*/) override {\n         return false;\n     }\n     virtual void DoApplyIndex(const NIndexes::TIndexCheckerContainer& /*indexMeta*/) override {\n@@ -350,6 +418,18 @@ class TCommittedDataSource: public IDataSource {\n     virtual bool DoAddSequentialEntityIds(const ui32 /*entityId*/) override {\n         return false;\n     }\n+\n+    virtual bool DoAddTxConflict() override {\n+        if (CommittedBlob.HasSnapshot()) {\n+            GetContext()->GetReadMetadata()->SetBrokenWithCommitted();\n+            return true;\n+        } else if (!GetContext()->GetReadMetadata()->IsMyUncommitted(CommittedBlob.GetWriteIdVerified())) {\n+            GetContext()->GetReadMetadata()->SetConflictedWriteId(CommittedBlob.GetWriteIdVerified());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n public:\n     virtual THashMap<TChunkAddress, TString> DecodeBlobAddresses(NBlobOperations::NRead::TCompositeReadBlobs&& blobsOriginal) const override {\n         THashMap<TChunkAddress, TString> result;\n@@ -373,6 +453,10 @@ class TCommittedDataSource: public IDataSource {\n         return CommittedBlob.GetBlobRange().Size;\n     }\n \n+    virtual ui64 GetColumnBlobBytes(const std::set<ui32>& /*columnsIds*/) const override {\n+        return CommittedBlob.GetBlobRange().Size;\n+    }\n+\n     virtual ui64 GetIndexRawBytes(const std::set<ui32>& /*columnIds*/) const override {\n         AFL_VERIFY(false);\n         return 0;\n@@ -382,13 +466,11 @@ class TCommittedDataSource: public IDataSource {\n         return CommittedBlob;\n     }\n \n-    TCommittedDataSource(const ui32 sourceIdx, const TCommittedBlob& committed, const std::shared_ptr<TSpecialReadContext>& context,\n-        const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& finish)\n-        : TBase(sourceIdx, context, start, finish, committed.GetSnapshot(), committed.GetSnapshot(), committed.GetRecordsCount(), {},\n-            committed.GetIsDelete())\n+    TCommittedDataSource(const ui32 sourceIdx, const TCommittedBlob& committed, const std::shared_ptr<TSpecialReadContext>& context)\n+        : TBase(sourceIdx, context, committed.GetFirst(), committed.GetLast(), committed.GetSnapshotDef(TSnapshot::Zero()),\n+              committed.GetSnapshotDef(TSnapshot::Zero()), committed.GetRecordsCount(), {}, committed.GetIsDelete())\n         , CommittedBlob(committed) {\n-\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/ya.make b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/ya.make\nindex cfa691a22e84..93ba27575ade 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/ya.make\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/ya.make\n@@ -18,6 +18,9 @@ PEERDIR(\n     ydb/core/formats/arrow\n     ydb/core/tx/columnshard/blobs_action\n     ydb/core/tx/conveyor/usage\n+    ydb/core/tx/limiter/grouped_memory/usage\n )\n \n+GENERATE_ENUM_SERIALIZATION(columns_set.h)\n+\n END()\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/filler.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/filler.cpp\nindex 076f8f11adc7..2a23b12c3fae 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/filler.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/filler.cpp\n@@ -16,7 +16,8 @@ NKikimr::TConclusionStatus TMetadataFromStore::DoFillMetadata(const NColumnShard\n     }\n \n     THashSet<ui64> pathIds;\n-    for (auto&& filter : read.PKRangesFilter) {\n+    AFL_VERIFY(read.PKRangesFilter);\n+    for (auto&& filter : *read.PKRangesFilter) {\n         const ui64 fromPathId = *filter.GetPredicateFrom().Get<arrow::UInt64Array>(0, 0, 1);\n         const ui64 toPathId = *filter.GetPredicateTo().Get<arrow::UInt64Array>(0, 0, Max<ui64>());\n         auto pathInfos = logsIndex->GetTables(fromPathId, toPathId);\n@@ -42,7 +43,8 @@ NKikimr::TConclusionStatus TMetadataFromTable::DoFillMetadata(const NColumnShard\n     if (!logsIndex) {\n         return TConclusionStatus::Success();\n     }\n-    for (auto&& filter : read.PKRangesFilter) {\n+    AFL_VERIFY(read.PKRangesFilter);\n+    for (auto&& filter : *read.PKRangesFilter) {\n         const ui64 fromPathId = *filter.GetPredicateFrom().Get<arrow::UInt64Array>(0, 0, 1);\n         const ui64 toPathId = *filter.GetPredicateTo().Get<arrow::UInt64Array>(0, 0, Max<ui64>());\n         if (fromPathId <= read.PathId && read.PathId <= toPathId) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.h b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.h\nindex 08f4d78e0c08..33be2ac027b1 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.h\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.h\n@@ -29,12 +29,12 @@ class TStatsIteratorBase: public TScanIteratorBase {\n         return IndexGranules.empty();\n     }\n \n-    virtual TConclusion<std::optional<TPartialReadResult>> GetBatch() override {\n+    virtual TConclusion<std::shared_ptr<TPartialReadResult>> GetBatch() override {\n         while (!Finished()) {\n             auto batchOpt = ExtractStatsBatch();\n             if (!batchOpt) {\n                 AFL_VERIFY(Finished());\n-                return std::nullopt;\n+                return std::shared_ptr<TPartialReadResult>();\n             }\n             auto originalBatch = *batchOpt;\n             if (originalBatch->num_rows() == 0) {\n@@ -55,10 +55,9 @@ class TStatsIteratorBase: public TScanIteratorBase {\n                 continue;\n             }\n             auto table = NArrow::TStatusValidator::GetValid(arrow::Table::FromRecordBatches({resultBatch}));\n-            TPartialReadResult out(table, lastKey, std::nullopt);\n-            return std::move(out);\n+            return std::make_shared<TPartialReadResult>(table, lastKey, std::nullopt);\n         }\n-        return std::nullopt;\n+        return std::shared_ptr<TPartialReadResult>();\n     }\n \n     std::optional<std::shared_ptr<arrow::RecordBatch>> ExtractStatsBatch() {\n@@ -136,10 +135,6 @@ class TStatsIterator : public TStatsIteratorBase {\n             }\n         }\n \n-        const NTable::TScheme::TTableSchema& GetSchema() const override {\n-            return StatsSchema;\n-        }\n-\n         NSsa::TColumnInfo GetDefaultColumn() const override {\n             return NSsa::TColumnInfo::Original(1, \"PathId\");\n         }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp\nindex 79e3dfeaf248..da3cc74f8e92 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp\n@@ -6,8 +6,19 @@ namespace NKikimr::NOlap::NReader::NSysView::NChunks {\n \n void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, const TPortionInfo& portion) const {\n     auto portionSchema = ReadMetadata->GetLoadSchemaVerified(portion);\n-    const std::string prod = ::ToString(portion.GetMeta().Produced);\n+    auto it = PortionType.find(portion.GetMeta().Produced);\n+    if (it == PortionType.end()) {\n+        it = PortionType.emplace(portion.GetMeta().Produced, ::ToString(portion.GetMeta().Produced)).first;\n+    }\n+    const arrow::util::string_view prodView = it->second.GetView();\n     const bool activity = !portion.IsRemovedFor(ReadMetadata->GetRequestSnapshot());\n+    static const TString ConstantEntityIsColumn = \"COL\";\n+    static const arrow::util::string_view ConstantEntityIsColumnView =\n+        arrow::util::string_view(ConstantEntityIsColumn.data(), ConstantEntityIsColumn.size());\n+    static const TString ConstantEntityIsIndex = \"IDX\";\n+    static const arrow::util::string_view ConstantEntityIsIndexView =\n+        arrow::util::string_view(ConstantEntityIsIndex.data(), ConstantEntityIsIndex.size());\n+    auto& entityStorages = EntityStorageNames[portion.GetMeta().GetTierName()];\n     {\n         std::vector<const TColumnRecord*> records;\n         for (auto&& r : portion.Records) {\n@@ -16,26 +27,54 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB\n         if (Reverse) {\n             std::reverse(records.begin(), records.end());\n         }\n+        THashMap<ui32, TString> blobsIds;\n+        std::optional<ui32> lastColumnId;\n+        arrow::util::string_view lastColumnName;\n+        arrow::util::string_view lastTierName;\n         for (auto&& r : records) {\n             NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId());\n-            NArrow::Append<arrow::StringType>(*builders[1], prod);\n+            NArrow::Append<arrow::StringType>(*builders[1], prodView);\n             NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);\n             NArrow::Append<arrow::UInt64Type>(*builders[3], r->GetMeta().GetNumRows());\n             NArrow::Append<arrow::UInt64Type>(*builders[4], r->GetMeta().GetRawBytes());\n             NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetPortionId());\n             NArrow::Append<arrow::UInt64Type>(*builders[6], r->GetChunkIdx());\n-            NArrow::Append<arrow::StringType>(*builders[7], ReadMetadata->GetColumnNameDef(r->GetColumnId()).value_or(\"undefined\"));\n+            if (!lastColumnId || *lastColumnId != r->GetColumnId()) {\n+                {\n+                    auto it = ColumnNamesById.find(r->GetColumnId());\n+                    if (it == ColumnNamesById.end()) {\n+                        it =\n+                            ColumnNamesById.emplace(r->GetColumnId(), portionSchema->GetFieldByColumnIdVerified(r->GetColumnId())->name()).first;\n+                    }\n+                    lastColumnName = it->second.GetView();\n+                }\n+                {\n+                    auto it = entityStorages.find(r->GetColumnId());\n+                    if (it == entityStorages.end()) {\n+                        it = entityStorages.emplace(r->GetColumnId(),\n+                            portionSchema->GetIndexInfo().GetEntityStorageId(r->GetColumnId(), portion.GetMeta().GetTierName())).first;\n+                    }\n+                    lastTierName = it->second.GetView();\n+                }\n+                lastColumnId = r->GetColumnId();\n+            }\n+            NArrow::Append<arrow::StringType>(*builders[7], lastColumnName);\n             NArrow::Append<arrow::UInt32Type>(*builders[8], r->GetColumnId());\n-            std::string blobIdString = portion.GetBlobId(r->GetBlobRange().GetBlobIdxVerified()).ToStringLegacy();\n-            NArrow::Append<arrow::StringType>(*builders[9], blobIdString);\n+            {\n+                auto itBlobIdString = blobsIds.find(r->GetBlobRange().GetBlobIdxVerified());\n+                if (itBlobIdString == blobsIds.end()) {\n+                    itBlobIdString = blobsIds.emplace(\n+                        r->GetBlobRange().GetBlobIdxVerified(), portion.GetBlobId(r->GetBlobRange().GetBlobIdxVerified()).ToStringLegacy()).first;\n+                }\n+                NArrow::Append<arrow::StringType>(\n+                    *builders[9], arrow::util::string_view(itBlobIdString->second.data(), itBlobIdString->second.size()));\n+            }\n             NArrow::Append<arrow::UInt64Type>(*builders[10], r->BlobRange.Offset);\n             NArrow::Append<arrow::UInt64Type>(*builders[11], r->BlobRange.Size);\n-            NArrow::Append<arrow::BooleanType>(*builders[12], activity);\n+            NArrow::Append<arrow::UInt8Type>(*builders[12], activity);\n \n-            const auto tierName = portionSchema->GetIndexInfo().GetEntityStorageId(r->GetColumnId(), portion.GetMeta().GetTierName());\n-            std::string strTierName(tierName.data(), tierName.size());\n-            NArrow::Append<arrow::StringType>(*builders[13], strTierName);\n-            NArrow::Append<arrow::StringType>(*builders[14], \"COL\");\n+            NArrow::Append<arrow::StringType>(*builders[13], arrow::util::string_view(lastTierName.data(), lastTierName.size()));\n+            NArrow::Append<arrow::StringType>(*builders[14], ConstantEntityIsColumnView);\n         }\n     }\n     {\n@@ -48,7 +87,7 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB\n         }\n         for (auto&& r : indexes) {\n             NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId());\n-            NArrow::Append<arrow::StringType>(*builders[1], prod);\n+            NArrow::Append<arrow::StringType>(*builders[1], prodView);\n             NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);\n             NArrow::Append<arrow::UInt64Type>(*builders[3], r->GetRecordsCount());\n             NArrow::Append<arrow::UInt64Type>(*builders[4], r->GetRawBytes());\n@@ -66,11 +105,11 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB\n                 NArrow::Append<arrow::UInt64Type>(*builders[10], 0);\n                 NArrow::Append<arrow::UInt64Type>(*builders[11], bData->size());\n             }\n-            NArrow::Append<arrow::BooleanType>(*builders[12], activity);\n+            NArrow::Append<arrow::UInt8Type>(*builders[12], activity);\n             const auto tierName = portionSchema->GetIndexInfo().GetEntityStorageId(r->GetIndexId(), portion.GetMeta().GetTierName());\n             std::string strTierName(tierName.data(), tierName.size());\n             NArrow::Append<arrow::StringType>(*builders[13], strTierName);\n-            NArrow::Append<arrow::StringType>(*builders[14], \"IDX\");\n+            NArrow::Append<arrow::StringType>(*builders[14], ConstantEntityIsIndexView);\n         }\n     }\n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.h b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.h\nindex c881d4f161bf..6fb758f46911 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.h\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.h\n@@ -28,6 +28,32 @@ class TReadStatsMetadata: public NAbstract::TReadStatsMetadata, std::enable_shar\n \n class TStatsIterator: public NAbstract::TStatsIterator<NKikimr::NSysView::Schema::PrimaryIndexStats> {\n private:\n+    class TViewContainer {\n+    private:\n+        TString Data;\n+        std::string STLData;\n+        arrow::util::string_view View;\n+\n+    public:\n+        const arrow::util::string_view& GetView() const {\n+            return View;\n+        }\n+\n+        TViewContainer(const TString& data)\n+            : Data(data)\n+            , View(arrow::util::string_view(Data.data(), Data.size())) {\n+        }\n+\n+        TViewContainer(const std::string& data)\n+            : STLData(data)\n+            , View(arrow::util::string_view(STLData.data(), STLData.size())) {\n+        }\n+    };\n+\n+    mutable THashMap<ui32, TViewContainer> ColumnNamesById;\n+    mutable THashMap<NPortion::EProduced, TViewContainer> PortionType;\n+    mutable THashMap<TString, THashMap<ui32, TViewContainer>> EntityStorageNames;\n+\n     using TBase = NAbstract::TStatsIterator<NKikimr::NSysView::Schema::PrimaryIndexStats>;\n     virtual bool AppendStats(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, NAbstract::TGranuleMetaView& granule) const override;\n     virtual ui32 PredictRecordsCount(const NAbstract::TGranuleMetaView& granule) const override;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp\nindex b79da31a64ee..83b2306a1bff 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp\n@@ -16,7 +16,7 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB\n     NArrow::Append<arrow::UInt64Type>(*builders[6], portion.GetColumnBlobBytes());\n     NArrow::Append<arrow::UInt64Type>(*builders[7], portion.GetIndexBlobBytes());\n     NArrow::Append<arrow::UInt64Type>(*builders[8], portion.GetPortionId());\n-    NArrow::Append<arrow::BooleanType>(*builders[9], !portion.IsRemovedFor(ReadMetadata->GetRequestSnapshot()));\n+    NArrow::Append<arrow::UInt8Type>(*builders[9], !portion.IsRemovedFor(ReadMetadata->GetRequestSnapshot()));\n \n     auto tierName = portion.GetTierNameDef(NBlobOperations::TGlobal::DefaultStorageId);\n     NArrow::Append<arrow::StringType>(*builders[10], arrow::util::string_view(tierName.data(), tierName.size()));\n@@ -31,6 +31,8 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB\n     }\n     auto statInfo = statReport.GetStringRobust();\n     NArrow::Append<arrow::StringType>(*builders[11], arrow::util::string_view(statInfo.data(), statInfo.size()));\n+\n+    NArrow::Append<arrow::UInt8Type>(*builders[12], portion.HasRuntimeFeature(TPortionInfo::ERuntimeFeature::Optimized));\n }\n \n ui32 TStatsIterator::PredictRecordsCount(const NAbstract::TGranuleMetaView& granule) const {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp\nindex 5decb79c2203..55d28a5a61f4 100644\n--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp\n@@ -1,94 +1,91 @@\n #include \"tx_internal_scan.h\"\n-#include <ydb/core/tx/columnshard/engines/reader/actor/actor.h>\n-#include <ydb/core/tx/columnshard/engines/reader/sys_view/constructor/constructor.h>\n-#include <ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.h>\n+\n #include <ydb/core/formats/arrow/arrow_batch_builder.h>\n #include <ydb/core/sys_view/common/schema.h>\n+#include <ydb/core/tx/columnshard/engines/reader/actor/actor.h>\n+#include <ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.h>\n #include <ydb/core/tx/columnshard/engines/reader/sys_view/abstract/policy.h>\n+#include <ydb/core/tx/columnshard/engines/reader/sys_view/constructor/constructor.h>\n+#include <ydb/core/tx/columnshard/transactions/locks/read_start.h>\n \n namespace NKikimr::NOlap::NReader {\n \n-bool TTxInternalScan::Execute(TTransactionContext& /*txc*/, const TActorContext& /*ctx*/) {\n-    TMemoryProfileGuard mpg(\"TTxInternalScan::Execute\");\n+void TTxInternalScan::SendError(const TString& problem, const TString& details, const TActorContext& ctx) const {\n+    AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan failed\")(\"problem\", problem)(\"details\", details);\n     auto& request = *InternalScanEvent->Get();\n-    const TSnapshot snapshot = request.ReadToSnapshot.value_or(NOlap::TSnapshot(Self->LastPlannedStep, Self->LastPlannedTxId));\n+    auto scanComputeActor = InternalScanEvent->Sender;\n \n-    TReadDescription read(snapshot, request.GetReverse());\n-    read.PathId = request.GetPathId();\n-    read.ReadNothing = !Self->TablesManager.HasTable(read.PathId);\n-    std::unique_ptr<IScannerConstructor> scannerConstructor(new NPlain::TIndexScannerConstructor(snapshot, request.GetItemsLimit(), request.GetReverse()));\n-    read.ColumnIds = request.GetColumnIds();\n-    read.ColumnNames = request.GetColumnNames();\n-    if (request.RangesFilter) {\n-        read.PKRangesFilter = std::move(*request.RangesFilter);\n-    }\n+    auto ev = MakeHolder<NKqp::TEvKqpCompute::TEvScanError>(ScanGen, Self->TabletID());\n+    ev->Record.SetStatus(Ydb::StatusIds::BAD_REQUEST);\n+    auto issue = NYql::YqlIssue({}, NYql::TIssuesIds::KIKIMR_BAD_REQUEST,\n+        TStringBuilder() << \"Table \" << request.GetPathId() << \" (shard \" << Self->TabletID() << \") scan failed, reason: \" << problem << \"/\"\n+                         << details);\n+    NYql::IssueToMessage(issue, ev->Record.MutableIssues()->Add());\n \n-    const TVersionedIndex* vIndex = Self->GetIndexOptional() ? &Self->GetIndexOptional()->GetVersionedIndex() : nullptr;\n-    AFL_VERIFY(vIndex);\n-    {\n-        TProgramContainer pContainer;\n-        pContainer.OverrideProcessingColumns(read.ColumnNames);\n-        read.SetProgram(std::move(pContainer));\n-    }\n+    ctx.Send(scanComputeActor, ev.Release());\n+}\n \n-    {\n-        auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n-        if (!newRange) {\n-            ErrorDescription = newRange.GetErrorMessage();\n-            ReadMetadataRange = nullptr;\n-            return true;\n-        }\n-        ReadMetadataRange = newRange.DetachResult();\n-    }\n-    AFL_VERIFY(ReadMetadataRange);\n+bool TTxInternalScan::Execute(TTransactionContext& /*txc*/, const TActorContext& /*ctx*/) {\n     return true;\n }\n \n void TTxInternalScan::Complete(const TActorContext& ctx) {\n     TMemoryProfileGuard mpg(\"TTxInternalScan::Complete\");\n+\n     auto& request = *InternalScanEvent->Get();\n     auto scanComputeActor = InternalScanEvent->Sender;\n-    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()(\"tablet\", Self->TabletID());\n-\n-    if (!ReadMetadataRange) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan failed\")(\"reason\", \"no metadata\")(\"error\", ErrorDescription);\n+    const TSnapshot snapshot = request.ReadToSnapshot.value_or(NOlap::TSnapshot(Self->LastPlannedStep, Self->LastPlannedTxId));\n+    const NActors::TLogContextGuard gLogging =\n+        NActors::TLogContextBuilder::Build()(\"tablet\", Self->TabletID())(\"snapshot\", snapshot.DebugString());\n+    TReadMetadataPtr readMetadataRange;\n+    {\n+        TReadDescription read(snapshot, request.GetReverse());\n+        read.PathId = request.GetPathId();\n+        read.LockId = LockId;\n+        read.ReadNothing = !Self->TablesManager.HasTable(read.PathId);\n+        std::unique_ptr<IScannerConstructor> scannerConstructor(\n+            new NPlain::TIndexScannerConstructor(snapshot, request.GetItemsLimit(), request.GetReverse()));\n+        read.ColumnIds = request.GetColumnIds();\n+        read.ColumnNames = request.GetColumnNames();\n+        if (request.RangesFilter) {\n+            read.PKRangesFilter = request.RangesFilter;\n+        }\n \n-        auto ev = MakeHolder<NKqp::TEvKqpCompute::TEvScanError>(ScanGen, Self->TabletID());\n-        ev->Record.SetStatus(Ydb::StatusIds::BAD_REQUEST);\n-        auto issue = NYql::YqlIssue({}, NYql::TIssuesIds::KIKIMR_BAD_REQUEST, TStringBuilder()\n-            << \"Table \" << request.GetPathId() << \" (shard \" << Self->TabletID() << \") scan failed, reason: \" << ErrorDescription ? ErrorDescription : \"no metadata ranges\");\n-        NYql::IssueToMessage(issue, ev->Record.MutableIssues()->Add());\n+        const TVersionedIndex* vIndex = Self->GetIndexOptional() ? &Self->GetIndexOptional()->GetVersionedIndex() : nullptr;\n+        AFL_VERIFY(vIndex);\n+        {\n+            TProgramContainer pContainer;\n+            pContainer.OverrideProcessingColumns(read.ColumnNames);\n+            read.SetProgram(std::move(pContainer));\n+        }\n \n-        ctx.Send(scanComputeActor, ev.Release());\n-        return;\n+        {\n+            auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n+            if (!newRange) {\n+                return SendError(\"cannot create read metadata\", newRange.GetErrorMessage(), ctx);\n+            }\n+            readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());\n+        }\n     }\n+\n     TStringBuilder detailedInfo;\n     if (IS_LOG_PRIORITY_ENABLED(NActors::NLog::PRI_TRACE, NKikimrServices::TX_COLUMNSHARD)) {\n-        detailedInfo << \" read metadata: (\" << *ReadMetadataRange << \")\";\n+        detailedInfo << \" read metadata: (\" << *readMetadataRange << \")\";\n     }\n \n     const TVersionedIndex* index = nullptr;\n     if (Self->HasIndex()) {\n         index = &Self->GetIndexAs<TColumnEngineForLogs>().GetVersionedIndex();\n     }\n-    const TConclusion<ui64> requestCookie = Self->InFlightReadsTracker.AddInFlightRequest(ReadMetadataRange, index);\n-    if (!requestCookie) {\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan failed\")(\"reason\", requestCookie.GetErrorMessage())(\"trace_details\", detailedInfo);\n-        auto ev = MakeHolder<NKqp::TEvKqpCompute::TEvScanError>(ScanGen, Self->TabletID());\n+    readMetadataRange->OnBeforeStartReading(*Self);\n \n-        ev->Record.SetStatus(Ydb::StatusIds::INTERNAL_ERROR);\n-        auto issue = NYql::YqlIssue({}, NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE, TStringBuilder()\n-            << \"Table \" << request.GetPathId() << \" (shard \" << Self->TabletID() << \") scan failed, reason: \" << requestCookie.GetErrorMessage());\n-        NYql::IssueToMessage(issue, ev->Record.MutableIssues()->Add());\n-        Self->ScanCounters.OnScanDuration(NColumnShard::TScanCounters::EStatusFinish::CannotAddInFlight, TDuration::Zero());\n-        ctx.Send(scanComputeActor, ev.Release());\n-        return;\n-    }\n-    auto scanActor = ctx.Register(new TColumnShardScan(Self->SelfId(), scanComputeActor, Self->GetStoragesManager(),\n-        TComputeShardingPolicy(), ScanId, TxId, ScanGen, *requestCookie, Self->TabletID(), TDuration::Max(), ReadMetadataRange,\n-        NKikimrDataEvents::FORMAT_ARROW, Self->ScanCounters));\n+    const ui64 requestCookie = Self->InFlightReadsTracker.AddInFlightRequest(readMetadataRange, index);\n+    auto scanActor = ctx.Register(new TColumnShardScan(Self->SelfId(), scanComputeActor, Self->GetStoragesManager(), TComputeShardingPolicy(),\n+        ScanId, LockId.value_or(0), ScanGen, requestCookie, Self->TabletID(), TDuration::Max(), readMetadataRange,\n+        NKikimrDataEvents::FORMAT_ARROW,\n+        Self->Counters.GetScanCounters()));\n \n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxInternalScan started\")(\"actor_id\", scanActor)(\"trace_detailed\", detailedInfo);\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.h b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.h\nindex 3e20c23a7c10..413d33714867 100644\n--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.h\n+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.h\n@@ -7,25 +7,26 @@ namespace NKikimr::NOlap::NReader {\n class TTxInternalScan: public NTabletFlatExecutor::TTransactionBase<NColumnShard::TColumnShard> {\n private:\n     using TBase = NTabletFlatExecutor::TTransactionBase<NColumnShard::TColumnShard>;\n+    TEvColumnShard::TEvInternalScan::TPtr InternalScanEvent;\n     const ui32 ScanGen = 1;\n-    const ui32 TxId = 1;\n     const ui32 ScanId = 1;\n+    const std::optional<ui64> LockId;\n+    void SendError(const TString& problem, const TString& details, const TActorContext& ctx) const;\n+\n public:\n     using TReadMetadataPtr = TReadMetadataBase::TConstPtr;\n \n     TTxInternalScan(NColumnShard::TColumnShard* self, TEvColumnShard::TEvInternalScan::TPtr& ev)\n         : TBase(self)\n-        , InternalScanEvent(ev) {\n+        , InternalScanEvent(ev)\n+        , LockId(InternalScanEvent->Get()->GetLockId())\n+    {\n     }\n \n     bool Execute(TTransactionContext& txc, const TActorContext& ctx) override;\n     void Complete(const TActorContext& ctx) override;\n     TTxType GetTxType() const override { return NColumnShard::TXTYPE_START_INTERNAL_SCAN; }\n \n-private:\n-    TString ErrorDescription;\n-    TEvColumnShard::TEvInternalScan::TPtr InternalScanEvent;\n-    TReadMetadataPtr ReadMetadataRange;\n };\n \n }\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp\nindex ab0d41db1931..74f09deb0197 100644\n--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp\n@@ -1,181 +1,32 @@\n #include \"tx_scan.h\"\n-#include <ydb/core/tx/columnshard/engines/reader/actor/actor.h>\n-#include <ydb/core/tx/columnshard/engines/reader/sys_view/constructor/constructor.h>\n-#include <ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.h>\n+\n #include <ydb/core/formats/arrow/arrow_batch_builder.h>\n #include <ydb/core/sys_view/common/schema.h>\n+#include <ydb/core/tx/columnshard/engines/reader/actor/actor.h>\n+#include <ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.h>\n #include <ydb/core/tx/columnshard/engines/reader/sys_view/abstract/policy.h>\n+#include <ydb/core/tx/columnshard/engines/reader/sys_view/constructor/constructor.h>\n+#include <ydb/core/tx/columnshard/transactions/locks/read_start.h>\n \n namespace NKikimr::NOlap::NReader {\n \n-std::vector<NScheme::TTypeInfo> ExtractTypes(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns) {\n-    std::vector<NScheme::TTypeInfo> types;\n-    types.reserve(columns.size());\n-    for (auto& [name, type] : columns) {\n-        types.push_back(type);\n-    }\n-    return types;\n-}\n-\n-TString FromCells(const TConstArrayRef<TCell>& cells, const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns) {\n-    Y_ABORT_UNLESS(cells.size() == columns.size());\n-    if (cells.empty()) {\n-        return {};\n-    }\n-\n-    std::vector<NScheme::TTypeInfo> types = ExtractTypes(columns);\n-\n-    NArrow::TArrowBatchBuilder batchBuilder;\n-    batchBuilder.Reserve(1);\n-    auto startStatus = batchBuilder.Start(columns);\n-    Y_ABORT_UNLESS(startStatus.ok(), \"%s\", startStatus.ToString().c_str());\n-\n-    batchBuilder.AddRow(NKikimr::TDbTupleRef(), NKikimr::TDbTupleRef(types.data(), cells.data(), cells.size()));\n-\n-    auto batch = batchBuilder.FlushBatch(false);\n-    Y_ABORT_UNLESS(batch);\n-    Y_ABORT_UNLESS(batch->num_columns() == (int)cells.size());\n-    Y_ABORT_UNLESS(batch->num_rows() == 1);\n-    return NArrow::SerializeBatchNoCompression(batch);\n-}\n-\n-std::pair<TPredicate, TPredicate> RangePredicates(const TSerializedTableRange& range, const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns) {\n-    std::vector<TCell> leftCells;\n-    std::vector<std::pair<TString, NScheme::TTypeInfo>> leftColumns;\n-    bool leftTrailingNull = false;\n-    {\n-        TConstArrayRef<TCell> cells = range.From.GetCells();\n-        const size_t size = cells.size();\n-        Y_ASSERT(size <= columns.size());\n-        leftCells.reserve(size);\n-        leftColumns.reserve(size);\n-        for (size_t i = 0; i < size; ++i) {\n-            if (!cells[i].IsNull()) {\n-                leftCells.push_back(cells[i]);\n-                leftColumns.push_back(columns[i]);\n-                leftTrailingNull = false;\n-            } else {\n-                leftTrailingNull = true;\n-            }\n-        }\n-    }\n-\n-    std::vector<TCell> rightCells;\n-    std::vector<std::pair<TString, NScheme::TTypeInfo>> rightColumns;\n-    bool rightTrailingNull = false;\n-    {\n-        TConstArrayRef<TCell> cells = range.To.GetCells();\n-        const size_t size = cells.size();\n-        Y_ASSERT(size <= columns.size());\n-        rightCells.reserve(size);\n-        rightColumns.reserve(size);\n-        for (size_t i = 0; i < size; ++i) {\n-            if (!cells[i].IsNull()) {\n-                rightCells.push_back(cells[i]);\n-                rightColumns.push_back(columns[i]);\n-                rightTrailingNull = false;\n-            } else {\n-                rightTrailingNull = true;\n-            }\n-        }\n-    }\n+void TTxScan::SendError(const TString& problem, const TString& details, const TActorContext& ctx) const {\n+    AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan failed\")(\"problem\", problem)(\"details\", details);\n+    const auto& request = Ev->Get()->Record;\n+    const TString table = request.GetTablePath();\n+    const ui32 scanGen = request.GetGeneration();\n+    const auto scanComputeActor = Ev->Sender;\n \n-    const bool fromInclusive = range.FromInclusive || leftTrailingNull;\n-    const bool toInclusive = range.ToInclusive && !rightTrailingNull;\n-\n-    TString leftBorder = FromCells(leftCells, leftColumns);\n-    TString rightBorder = FromCells(rightCells, rightColumns);\n-    auto leftSchema = NArrow::MakeArrowSchema(leftColumns);\n-    Y_ASSERT(leftSchema.ok());\n-    auto rightSchema = NArrow::MakeArrowSchema(rightColumns);\n-    Y_ASSERT(rightSchema.ok());\n-    return std::make_pair(\n-        TPredicate(fromInclusive ? NKernels::EOperation::GreaterEqual : NKernels::EOperation::Greater, leftBorder, leftSchema.ValueUnsafe()),\n-        TPredicate(toInclusive ? NKernels::EOperation::LessEqual : NKernels::EOperation::Less, rightBorder, rightSchema.ValueUnsafe()));\n-}\n+    auto ev = MakeHolder<NKqp::TEvKqpCompute::TEvScanError>(scanGen, Self->TabletID());\n+    ev->Record.SetStatus(Ydb::StatusIds::BAD_REQUEST);\n+    auto issue = NYql::YqlIssue({}, NYql::TIssuesIds::KIKIMR_BAD_REQUEST,\n+        TStringBuilder() << \"Table \" << table << \" (shard \" << Self->TabletID() << \") scan failed, reason: \" << problem << \"/\" << details);\n+    NYql::IssueToMessage(issue, ev->Record.MutableIssues()->Add());\n \n-static bool FillPredicatesFromRange(TReadDescription& read, const ::NKikimrTx::TKeyRange& keyRange,\n-    const std::vector<std::pair<TString, NScheme::TTypeInfo>>& ydbPk, ui64 tabletId, const TIndexInfo* indexInfo, TString& error) {\n-    TSerializedTableRange range(keyRange);\n-    auto fromPredicate = std::make_shared<TPredicate>();\n-    auto toPredicate = std::make_shared<TPredicate>();\n-    std::tie(*fromPredicate, *toPredicate) = RangePredicates(range, ydbPk);\n-\n-    LOG_S_DEBUG(\"TTxScan range predicate. From key size: \" << range.From.GetCells().size()\n-        << \" To key size: \" << range.To.GetCells().size()\n-        << \" greater predicate over columns: \" << fromPredicate->ToString()\n-        << \" less predicate over columns: \" << toPredicate->ToString()\n-        << \" at tablet \" << tabletId);\n-\n-    if (!read.PKRangesFilter.Add(fromPredicate, toPredicate, indexInfo)) {\n-        error = \"Error building filter\";\n-        return false;\n-    }\n-    return true;\n+    ctx.Send(scanComputeActor, ev.Release());\n }\n \n bool TTxScan::Execute(TTransactionContext& /*txc*/, const TActorContext& /*ctx*/) {\n-    TMemoryProfileGuard mpg(\"TTxScan::Execute\");\n-    auto& record = Ev->Get()->Record;\n-    TSnapshot snapshot(record.GetSnapshot().GetStep(), record.GetSnapshot().GetTxId());\n-    const auto scanId = record.GetScanId();\n-    const ui64 txId = record.GetTxId();\n-\n-    LOG_S_DEBUG(\"TTxScan prepare txId: \" << txId << \" scanId: \" << scanId << \" at tablet \" << Self->TabletID());\n-\n-    TReadDescription read(snapshot, record.GetReverse());\n-    read.PathId = record.GetLocalPathId();\n-    read.ReadNothing = !Self->TablesManager.HasTable(read.PathId);\n-    read.TableName = record.GetTablePath();\n-    bool isIndex = false;\n-    std::unique_ptr<IScannerConstructor> scannerConstructor = [&]() {\n-        const ui64 itemsLimit = record.HasItemsLimit() ? record.GetItemsLimit() : 0;\n-        auto sysViewPolicy = NSysView::NAbstract::ISysViewPolicy::BuildByPath(read.TableName);\n-        isIndex = !sysViewPolicy;\n-        if (!sysViewPolicy) {\n-            return std::unique_ptr<IScannerConstructor>(new NPlain::TIndexScannerConstructor(snapshot, itemsLimit, record.GetReverse()));\n-        } else {\n-            return sysViewPolicy->CreateConstructor(snapshot, itemsLimit, record.GetReverse());\n-        }\n-    }();\n-    read.ColumnIds.assign(record.GetColumnTags().begin(), record.GetColumnTags().end());\n-    read.StatsMode = record.GetStatsMode();\n-\n-    const TVersionedIndex* vIndex = Self->GetIndexOptional() ? &Self->GetIndexOptional()->GetVersionedIndex() : nullptr;\n-    auto parseResult = scannerConstructor->ParseProgram(vIndex, record, read);\n-    if (!parseResult) {\n-        ErrorDescription = parseResult.GetErrorMessage();\n-        return true;\n-    }\n-\n-    if (!record.RangesSize()) {\n-        auto range = scannerConstructor->BuildReadMetadata(Self, read);\n-        if (range.IsSuccess()) {\n-            ReadMetadataRange = range.DetachResult();\n-        } else {\n-            ErrorDescription = range.GetErrorMessage();\n-        }\n-        return true;\n-    }\n-\n-    auto ydbKey = scannerConstructor->GetPrimaryKeyScheme(Self);\n-    auto* indexInfo = (vIndex && isIndex) ? &vIndex->GetSchema(snapshot)->GetIndexInfo() : nullptr;\n-    for (auto& range : record.GetRanges()) {\n-        if (!FillPredicatesFromRange(read, range, ydbKey, Self->TabletID(), indexInfo, ErrorDescription)) {\n-            ReadMetadataRange = nullptr;\n-            return true;\n-        }\n-    }\n-    {\n-        auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n-        if (!newRange) {\n-            ErrorDescription = newRange.GetErrorMessage();\n-            ReadMetadataRange = nullptr;\n-            return true;\n-        }\n-        ReadMetadataRange = newRange.DetachResult();\n-    }\n-    AFL_VERIFY(ReadMetadataRange);\n     return true;\n }\n \n@@ -183,67 +34,101 @@ void TTxScan::Complete(const TActorContext& ctx) {\n     TMemoryProfileGuard mpg(\"TTxScan::Complete\");\n     auto& request = Ev->Get()->Record;\n     auto scanComputeActor = Ev->Sender;\n-    const auto& snapshot = request.GetSnapshot();\n+    TSnapshot snapshot = TSnapshot(request.GetSnapshot().GetStep(), request.GetSnapshot().GetTxId());\n+    if (snapshot.IsZero()) {\n+        snapshot = Self->GetLastTxSnapshot();\n+    }\n     const auto scanId = request.GetScanId();\n     const ui64 txId = request.GetTxId();\n     const ui32 scanGen = request.GetGeneration();\n-    TString table = request.GetTablePath();\n-    auto dataFormat = request.GetDataFormat();\n+    const TString table = request.GetTablePath();\n+    const auto dataFormat = request.GetDataFormat();\n     const TDuration timeout = TDuration::MilliSeconds(request.GetTimeoutMs());\n     if (scanGen > 1) {\n-        Self->IncCounter(NColumnShard::COUNTER_SCAN_RESTARTED);\n+        Self->Counters.GetTabletCounters()->IncCounter(NColumnShard::COUNTER_SCAN_RESTARTED);\n     }\n-    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()\n-        (\"tx_id\", txId)(\"scan_id\", scanId)(\"gen\", scanGen)(\"table\", table)(\"snapshot\", snapshot)(\"tablet\", Self->TabletID())(\"timeout\", timeout);\n+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build() (\"tx_id\", txId)(\"scan_id\", scanId)(\"gen\", scanGen)(\n+        \"table\", table)(\"snapshot\", snapshot)(\"tablet\", Self->TabletID())(\"timeout\", timeout);\n \n-    if (!ReadMetadataRange) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan failed\")(\"reason\", \"no metadata\")(\"error\", ErrorDescription);\n+    TReadMetadataPtr readMetadataRange;\n+    {\n+        LOG_S_DEBUG(\"TTxScan prepare txId: \" << txId << \" scanId: \" << scanId << \" at tablet \" << Self->TabletID());\n \n-        auto ev = MakeHolder<NKqp::TEvKqpCompute::TEvScanError>(scanGen, Self->TabletID());\n-        ev->Record.SetStatus(Ydb::StatusIds::BAD_REQUEST);\n-        auto issue = NYql::YqlIssue({}, NYql::TIssuesIds::KIKIMR_BAD_REQUEST, TStringBuilder()\n-            << \"Table \" << table << \" (shard \" << Self->TabletID() << \") scan failed, reason: \" << ErrorDescription ? ErrorDescription : \"no metadata ranges\");\n-        NYql::IssueToMessage(issue, ev->Record.MutableIssues()->Add());\n+        TReadDescription read(snapshot, request.GetReverse());\n+        read.TxId = txId;\n+        if (request.HasLockTxId()) {\n+            read.LockId = request.GetLockTxId();\n+        }\n+        read.PathId = request.GetLocalPathId();\n+        read.ReadNothing = !Self->TablesManager.HasTable(read.PathId);\n+        read.TableName = table;\n+        bool isIndex = false;\n+        std::unique_ptr<IScannerConstructor> scannerConstructor = [&]() {\n+            const ui64 itemsLimit = request.HasItemsLimit() ? request.GetItemsLimit() : 0;\n+            auto sysViewPolicy = NSysView::NAbstract::ISysViewPolicy::BuildByPath(read.TableName);\n+            isIndex = !sysViewPolicy;\n+            if (!sysViewPolicy) {\n+                return std::unique_ptr<IScannerConstructor>(new NPlain::TIndexScannerConstructor(snapshot, itemsLimit, request.GetReverse()));\n+            } else {\n+                return sysViewPolicy->CreateConstructor(snapshot, itemsLimit, request.GetReverse());\n+            }\n+        }();\n+        read.ColumnIds.assign(request.GetColumnTags().begin(), request.GetColumnTags().end());\n+        read.StatsMode = request.GetStatsMode();\n+\n+        const TVersionedIndex* vIndex = Self->GetIndexOptional() ? &Self->GetIndexOptional()->GetVersionedIndex() : nullptr;\n+        auto parseResult = scannerConstructor->ParseProgram(vIndex, request, read);\n+        if (!parseResult) {\n+            return SendError(\"cannot parse program\", parseResult.GetErrorMessage(), ctx);\n+        }\n \n-        ctx.Send(scanComputeActor, ev.Release());\n-        return;\n+        if (!request.RangesSize()) {\n+            auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n+            if (newRange.IsSuccess()) {\n+                readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());\n+            } else {\n+                return SendError(\"cannot build metadata withno ranges\", newRange.GetErrorMessage(), ctx);\n+            }\n+        } else {\n+            auto ydbKey = scannerConstructor->GetPrimaryKeyScheme(Self);\n+            {\n+                auto filterConclusion = NOlap::TPKRangesFilter::BuildFromProto(request, request.GetReverse(), ydbKey);\n+                if (filterConclusion.IsFail()) {\n+                    return SendError(\"cannot build ranges filter\", filterConclusion.GetErrorMessage(), ctx);\n+                }\n+                read.PKRangesFilter = std::make_shared<NOlap::TPKRangesFilter>(filterConclusion.DetachResult());\n+            }\n+            auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n+            if (!newRange) {\n+                return SendError(\"cannot build metadata\", newRange.GetErrorMessage(), ctx);\n+            }\n+            readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());\n+        }\n     }\n+    AFL_VERIFY(readMetadataRange);\n+    readMetadataRange->OnBeforeStartReading(*Self);\n+\n     TStringBuilder detailedInfo;\n     if (IS_LOG_PRIORITY_ENABLED(NActors::NLog::PRI_TRACE, NKikimrServices::TX_COLUMNSHARD)) {\n-        detailedInfo << \" read metadata: (\" << *ReadMetadataRange << \")\" << \" req: \" << request;\n+        detailedInfo << \" read metadata: (\" << *readMetadataRange << \")\"\n+                     << \" req: \" << request;\n     }\n \n     const TVersionedIndex* index = nullptr;\n     if (Self->HasIndex()) {\n         index = &Self->GetIndexAs<TColumnEngineForLogs>().GetVersionedIndex();\n     }\n-    const TConclusion<ui64> requestCookie = Self->InFlightReadsTracker.AddInFlightRequest(ReadMetadataRange, index);\n-    if (!requestCookie) {\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan failed\")(\"reason\", requestCookie.GetErrorMessage())(\"trace_details\", detailedInfo);\n-        auto ev = MakeHolder<NKqp::TEvKqpCompute::TEvScanError>(scanGen, Self->TabletID());\n-\n-        ev->Record.SetStatus(Ydb::StatusIds::INTERNAL_ERROR);\n-        auto issue = NYql::YqlIssue({}, NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE, TStringBuilder()\n-            << \"Table \" << table << \" (shard \" << Self->TabletID() << \") scan failed, reason: \" << requestCookie.GetErrorMessage());\n-        NYql::IssueToMessage(issue, ev->Record.MutableIssues()->Add());\n-        Self->ScanCounters.OnScanDuration(NColumnShard::TScanCounters::EStatusFinish::CannotAddInFlight, TDuration::Zero());\n-        ctx.Send(scanComputeActor, ev.Release());\n-        return;\n-    }\n-    auto statsDelta = Self->InFlightReadsTracker.GetSelectStatsDelta();\n+    const ui64 requestCookie = Self->InFlightReadsTracker.AddInFlightRequest(readMetadataRange, index);\n \n-    Self->IncCounter(NColumnShard::COUNTER_READ_INDEX_PORTIONS, statsDelta.Portions);\n-    Self->IncCounter(NColumnShard::COUNTER_READ_INDEX_BLOBS, statsDelta.Blobs);\n-    Self->IncCounter(NColumnShard::COUNTER_READ_INDEX_ROWS, statsDelta.Rows);\n-    Self->IncCounter(NColumnShard::COUNTER_READ_INDEX_BYTES, statsDelta.Bytes);\n+    Self->Counters.GetTabletCounters()->OnScanStarted(Self->InFlightReadsTracker.GetSelectStatsDelta());\n \n     TComputeShardingPolicy shardingPolicy;\n     AFL_VERIFY(shardingPolicy.DeserializeFromProto(request.GetComputeShardingPolicy()));\n \n-    auto scanActor = ctx.Register(new TColumnShardScan(Self->SelfId(), scanComputeActor, Self->GetStoragesManager(),\n-        shardingPolicy, scanId, txId, scanGen, *requestCookie, Self->TabletID(), timeout, ReadMetadataRange, dataFormat, Self->ScanCounters));\n+    auto scanActor = ctx.Register(new TColumnShardScan(Self->SelfId(), scanComputeActor, Self->GetStoragesManager(), shardingPolicy, scanId,\n+        txId, scanGen, requestCookie, Self->TabletID(), timeout, readMetadataRange, dataFormat, Self->Counters.GetScanCounters()));\n \n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TTxScan started\")(\"actor_id\", scanActor)(\"trace_detailed\", detailedInfo);\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.h b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.h\nindex 2d9eb9619a64..347def3dea14 100644\n--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.h\n+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.h\n@@ -7,6 +7,8 @@ namespace NKikimr::NOlap::NReader {\n class TTxScan: public NTabletFlatExecutor::TTransactionBase<NColumnShard::TColumnShard> {\n private:\n     using TBase = NTabletFlatExecutor::TTransactionBase<NColumnShard::TColumnShard>;\n+    void SendError(const TString& problem, const TString& details, const TActorContext& ctx) const;\n+\n public:\n     using TReadMetadataPtr = TReadMetadataBase::TConstPtr;\n \n@@ -17,12 +19,12 @@ class TTxScan: public NTabletFlatExecutor::TTransactionBase<NColumnShard::TColum\n \n     bool Execute(TTransactionContext& txc, const TActorContext& ctx) override;\n     void Complete(const TActorContext& ctx) override;\n-    TTxType GetTxType() const override { return NColumnShard::TXTYPE_START_SCAN; }\n+    TTxType GetTxType() const override {\n+        return NColumnShard::TXTYPE_START_SCAN;\n+    }\n \n private:\n-    TString ErrorDescription;\n     TEvColumnShard::TEvScan::TPtr Ev;\n-    TReadMetadataPtr ReadMetadataRange;\n };\n \n-}\n\\ No newline at end of file\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.cpp b/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.cpp\nindex f5473eaab885..974cf998d957 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.cpp\n@@ -1,7 +1,7 @@\n #include \"index_info.h\"\n #include <ydb/core/sys_view/common/path.h>\n #include <ydb/core/sys_view/common/schema.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h b/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h\nindex 15a9a533ada7..b630b5780fbd 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h\n@@ -1,15 +1,19 @@\n #pragma once\n-#include \"loader.h\"\n \n #include <ydb/core/formats/arrow/common/container.h>\n+#include <ydb/core/formats/arrow/save_load/loader.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n #include <ydb/core/tx/columnshard/common/portion.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n \n namespace NKikimr::NOlap {\n \n+using TColumnLoader = NArrow::NAccessor::TColumnLoader;\n+using TColumnSaver = NArrow::NAccessor::TColumnSaver;\n+\n class IIndexInfo {\n public:\n-    enum class ESpecialColumn: ui32 {\n+    enum class ESpecialColumn : ui32 {\n         PLAN_STEP = NOlap::NPortion::TSpecialColumns::SPEC_COL_PLAN_STEP_INDEX,\n         TX_ID = NOlap::NPortion::TSpecialColumns::SPEC_COL_TX_ID_INDEX,\n         DELETE_FLAG = NOlap::NPortion::TSpecialColumns::SPEC_COL_DELETE_FLAG_INDEX\n@@ -17,7 +21,7 @@ class IIndexInfo {\n \n     using TSystemColumnsSet = ui64;\n \n-    enum class ESystemColumnsSet: ui64 {\n+    enum class ESystemColumnsSet : ui64 {\n         Snapshot = 1,\n         Deletion = 1 << 1,\n     };\n@@ -30,6 +34,11 @@ class IIndexInfo {\n         return SPEC_COL_DELETE_FLAG;\n     }\n \n+    static const std::set<ui32>& GetNecessarySystemColumnIdsSet() {\n+        static const std::set<ui32> result = { (ui32)ESpecialColumn::PLAN_STEP, (ui32)ESpecialColumn::TX_ID };\n+        return result;\n+    }\n+\n     static const std::vector<std::string>& GetSnapshotColumnNames() {\n         static const std::vector<std::string> result = { std::string(SPEC_COL_PLAN_STEP), std::string(SPEC_COL_TX_ID) };\n         return result;\n@@ -64,7 +73,8 @@ class IIndexInfo {\n \n     static void AddSpecialFields(std::vector<std::shared_ptr<arrow::Field>>& fields) {\n         AddSnapshotFields(fields);\n-        fields.push_back(arrow::field(SPEC_COL_DELETE_FLAG, arrow::boolean()));\n+        static const std::shared_ptr<arrow::Field> f = arrow::field(SPEC_COL_DELETE_FLAG, arrow::boolean());\n+        fields.push_back(f);\n     }\n \n     static const std::vector<std::string>& SnapshotColumnNames() {\n@@ -73,8 +83,10 @@ class IIndexInfo {\n     }\n \n     static void AddSnapshotFields(std::vector<std::shared_ptr<arrow::Field>>& fields) {\n-        fields.push_back(arrow::field(SPEC_COL_PLAN_STEP, arrow::uint64()));\n-        fields.push_back(arrow::field(SPEC_COL_TX_ID, arrow::uint64()));\n+        static const std::shared_ptr<arrow::Field> ps = arrow::field(SPEC_COL_PLAN_STEP, arrow::uint64());\n+        static const std::shared_ptr<arrow::Field> txid = arrow::field(SPEC_COL_TX_ID, arrow::uint64());\n+        fields.push_back(ps);\n+        fields.push_back(txid);\n     }\n \n     static void AddDeleteFields(std::vector<std::shared_ptr<arrow::Field>>& fields) {\n@@ -87,20 +99,28 @@ class IIndexInfo {\n     }\n \n     static const std::vector<std::string>& GetSystemColumnNames() {\n-        static const std::vector<std::string> result = { std::string(SPEC_COL_PLAN_STEP), std::string(SPEC_COL_TX_ID), std::string(SPEC_COL_DELETE_FLAG) };\n+        static const std::vector<std::string> result = { std::string(SPEC_COL_PLAN_STEP), std::string(SPEC_COL_TX_ID),\n+            std::string(SPEC_COL_DELETE_FLAG) };\n         return result;\n     }\n \n     static const std::vector<ui32>& GetSystemColumnIds() {\n-        static const std::vector<ui32> result = { (ui32)ESpecialColumn::PLAN_STEP, (ui32)ESpecialColumn::TX_ID, (ui32)ESpecialColumn::DELETE_FLAG };\n+        static const std::vector<ui32> result = { (ui32)ESpecialColumn::PLAN_STEP, (ui32)ESpecialColumn::TX_ID,\n+            (ui32)ESpecialColumn::DELETE_FLAG };\n         return result;\n     }\n \n     [[nodiscard]] static std::vector<ui32> AddSpecialFieldIds(const std::vector<ui32>& baseColumnIds) {\n         std::vector<ui32> result = baseColumnIds;\n-        for (auto&& i : GetSystemColumnIds()) {\n-            result.emplace_back(i);\n-        }\n+        const auto& cIds = GetSystemColumnIds();\n+        result.insert(result.end(), cIds.begin(), cIds.end());\n+        return result;\n+    }\n+\n+    [[nodiscard]] static std::set<ui32> AddSpecialFieldIds(const std::set<ui32>& baseColumnIds) {\n+        std::set<ui32> result = baseColumnIds;\n+        const auto& cIds = GetSystemColumnIds();\n+        result.insert(cIds.begin(), cIds.end());\n         return result;\n     }\n \n@@ -130,17 +150,14 @@ class IIndexInfo {\n     }\n \n     static std::shared_ptr<arrow::Schema> ArrowSchemaSnapshot() {\n-        static std::shared_ptr<arrow::Schema> result = std::make_shared<arrow::Schema>(arrow::FieldVector{\n-                arrow::field(SPEC_COL_PLAN_STEP, arrow::uint64()),\n-                arrow::field(SPEC_COL_TX_ID, arrow::uint64())\n-            });\n+        static std::shared_ptr<arrow::Schema> result = std::make_shared<arrow::Schema>(\n+            arrow::FieldVector{ arrow::field(SPEC_COL_PLAN_STEP, arrow::uint64()), arrow::field(SPEC_COL_TX_ID, arrow::uint64()) });\n         return result;\n     }\n \n     static std::shared_ptr<arrow::Schema> ArrowSchemaDeletion() {\n-        static std::shared_ptr<arrow::Schema> result = std::make_shared<arrow::Schema>(arrow::FieldVector{\n-                arrow::field(SPEC_COL_DELETE_FLAG, arrow::boolean())\n-            });\n+        static std::shared_ptr<arrow::Schema> result =\n+            std::make_shared<arrow::Schema>(arrow::FieldVector{ arrow::field(SPEC_COL_DELETE_FLAG, arrow::boolean()) });\n         return result;\n     }\n \n@@ -149,19 +166,15 @@ class IIndexInfo {\n     }\n \n     static bool IsSpecialColumn(const std::string& fieldName) {\n-        return fieldName == SPEC_COL_PLAN_STEP\n-            || fieldName == SPEC_COL_TX_ID\n-            || fieldName == SPEC_COL_DELETE_FLAG;\n+        return fieldName == SPEC_COL_PLAN_STEP || fieldName == SPEC_COL_TX_ID || fieldName == SPEC_COL_DELETE_FLAG;\n     }\n \n     static bool IsSpecialColumn(const ui32 fieldId) {\n-        return fieldId == (ui32)ESpecialColumn::PLAN_STEP\n-            || fieldId == (ui32)ESpecialColumn::TX_ID\n-            || fieldId == (ui32)ESpecialColumn::DELETE_FLAG;\n+        return fieldId == (ui32)ESpecialColumn::PLAN_STEP || fieldId == (ui32)ESpecialColumn::TX_ID ||\n+               fieldId == (ui32)ESpecialColumn::DELETE_FLAG;\n     }\n \n-    static bool IsNullableVerified(const ui32 fieldId) {\n-        Y_UNUSED(fieldId);\n+    static bool IsNullableVerified(const ui32 /*fieldId*/) {\n         return false;\n     }\n \n@@ -183,4 +196,4 @@ class IIndexInfo {\n     virtual ~IIndexInfo() = default;\n };\n \n-} // namespace NKikimr::NOlap\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/loader.cpp b/ydb/core/tx/columnshard/engines/scheme/abstract/loader.cpp\ndeleted file mode 100644\nindex d74dc491519d..000000000000\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/loader.cpp\n+++ /dev/null\n@@ -1,61 +0,0 @@\n-#include \"loader.h\"\n-#include <ydb/core/formats/arrow/common/validation.h>\n-\n-namespace NKikimr::NOlap {\n-\n-TString TColumnLoader::DebugString() const {\n-    TStringBuilder result;\n-    if (ExpectedSchema) {\n-        result << \"schema:\" << ExpectedSchema->ToString() << \";\";\n-    }\n-    if (Transformer) {\n-        result << \"transformer:\" << Transformer->DebugString() << \";\";\n-    }\n-    if (Serializer) {\n-        result << \"serializer:\" << Serializer->DebugString() << \";\";\n-    }\n-    return result;\n-}\n-\n-TColumnLoader::TColumnLoader(NArrow::NTransformation::ITransformer::TPtr transformer, const NArrow::NSerialization::TSerializerContainer& serializer,\n-    const std::shared_ptr<arrow::Schema>& expectedSchema, const std::shared_ptr<arrow::Scalar>& defaultValue, const ui32 columnId)\n-    : Transformer(transformer)\n-    , Serializer(serializer)\n-    , ExpectedSchema(expectedSchema)\n-    , DefaultValue(defaultValue)\n-    , ColumnId(columnId) {\n-    Y_ABORT_UNLESS(ExpectedSchema);\n-    auto fieldsCountStr = ::ToString(ExpectedSchema->num_fields());\n-    Y_ABORT_UNLESS(ExpectedSchema->num_fields() == 1, \"%s\", fieldsCountStr.data());\n-    Y_ABORT_UNLESS(Serializer);\n-}\n-\n-const std::shared_ptr<arrow::Field>& TColumnLoader::GetField() const {\n-    return ExpectedSchema->field(0);\n-}\n-\n-arrow::Result<std::shared_ptr<arrow::RecordBatch>> TColumnLoader::Apply(const TString& data) const {\n-    Y_ABORT_UNLESS(Serializer);\n-    arrow::Result<std::shared_ptr<arrow::RecordBatch>> columnArray =\n-        Transformer ? Serializer->Deserialize(data) : Serializer->Deserialize(data, ExpectedSchema);\n-    if (!columnArray.ok()) {\n-        return columnArray;\n-    }\n-    if (Transformer) {\n-        return Transformer->Transform(*columnArray);\n-    } else {\n-        return columnArray;\n-    }\n-}\n-\n-std::shared_ptr<arrow::RecordBatch> TColumnLoader::ApplyVerified(const TString& data) const {\n-    return NArrow::TStatusValidator::GetValid(Apply(data));\n-}\n-\n-std::shared_ptr<arrow::Array> TColumnLoader::ApplyVerifiedColumn(const TString& data) const {\n-    auto rb = ApplyVerified(data);\n-    AFL_VERIFY(rb->num_columns() == 1)(\"schema\", rb->schema()->ToString());\n-    return rb->column(0);\n-}\n-\n-}\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/loader.h b/ydb/core/tx/columnshard/engines/scheme/abstract/loader.h\ndeleted file mode 100644\nindex d128caaecb58..000000000000\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/loader.h\n+++ /dev/null\n@@ -1,47 +0,0 @@\n-#pragma once\n-#include <ydb/core/formats/arrow/transformer/abstract.h>\n-#include <ydb/core/formats/arrow/serializer/abstract.h>\n-#include <ydb/library/accessor/accessor.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n-\n-namespace NKikimr::NOlap {\n-\n-class TColumnLoader {\n-private:\n-    NArrow::NTransformation::ITransformer::TPtr Transformer;\n-    NArrow::NSerialization::TSerializerContainer Serializer;\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::Schema>, ExpectedSchema);\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::Scalar>, DefaultValue);\n-    const ui32 ColumnId;\n-public:\n-    bool IsEqualTo(const TColumnLoader& item) const {\n-        if (!!Transformer != !!item.Transformer) {\n-            return false;\n-        } else if (!!Transformer && !Transformer->IsEqualTo(*item.Transformer)) {\n-            return false;\n-        }\n-        if (!Serializer.IsEqualTo(item.Serializer)) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    TString DebugString() const;\n-\n-    TColumnLoader(NArrow::NTransformation::ITransformer::TPtr transformer, const NArrow::NSerialization::TSerializerContainer& serializer,\n-        const std::shared_ptr<arrow::Schema>& expectedSchema, const std::shared_ptr<arrow::Scalar>& defaultValue, const ui32 columnId);\n-\n-    ui32 GetColumnId() const {\n-        return ColumnId;\n-    }\n-\n-    const std::shared_ptr<arrow::Field>& GetField() const;\n-\n-    arrow::Result<std::shared_ptr<arrow::RecordBatch>> Apply(const TString& data) const;\n-\n-    std::shared_ptr<arrow::RecordBatch> ApplyVerified(const TString& data) const;\n-\n-    std::shared_ptr<arrow::Array> ApplyVerifiedColumn(const TString& data) const;\n-};\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/abstract/ya.make b/ydb/core/tx/columnshard/engines/scheme/abstract/ya.make\nindex b830415daae1..79b12f94389e 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/abstract/ya.make\n+++ b/ydb/core/tx/columnshard/engines/scheme/abstract/ya.make\n@@ -1,15 +1,12 @@\n LIBRARY()\n \n SRCS(\n-    saver.cpp\n     index_info.cpp\n-    loader.cpp\n )\n \n PEERDIR(\n     ydb/library/actors/core\n-    ydb/core/formats/arrow/transformer\n-    ydb/core/formats/arrow/serializer\n+    ydb/core/formats/arrow/save_load\n )\n \n YQL_LAST_ABI_VERSION()\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/column/info.cpp b/ydb/core/tx/columnshard/engines/scheme/column/info.cpp\nindex b9473398fdf3..b4fae5cf09ab 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/column/info.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/column/info.cpp\n@@ -19,8 +19,7 @@ NArrow::NTransformation::ITransformer::TPtr TSimpleColumnInfo::GetLoadTransforme\n     return transformer;\n }\n \n-TConclusionStatus TSimpleColumnInfo::DeserializeFromProto(const NKikimrSchemeOp::TOlapColumnDescription& columnInfo)\n-{\n+TConclusionStatus TSimpleColumnInfo::DeserializeFromProto(const NKikimrSchemeOp::TOlapColumnDescription& columnInfo) {\n     AFL_VERIFY(columnInfo.GetId() == ColumnId);\n     if (columnInfo.HasSerializer()) {\n         AFL_VERIFY(Serializer.DeserializeFromProto(columnInfo.GetSerializer()));\n@@ -30,29 +29,34 @@ TConclusionStatus TSimpleColumnInfo::DeserializeFromProto(const NKikimrSchemeOp:\n     if (columnInfo.HasDefaultValue()) {\n         DefaultValue.DeserializeFromProto(columnInfo.GetDefaultValue()).Validate();\n     }\n+    if (columnInfo.HasDataAccessorConstructor()) {\n+        AFL_VERIFY(DataAccessorConstructor.DeserializeFromProto(columnInfo.GetDataAccessorConstructor()));\n+    }\n+    IsNullable = columnInfo.HasNotNull() ? !columnInfo.GetNotNull() : true;\n     AFL_VERIFY(Serializer);\n     if (columnInfo.HasDictionaryEncoding()) {\n         auto settings = NArrow::NDictionary::TEncodingSettings::BuildFromProto(columnInfo.GetDictionaryEncoding());\n         Y_ABORT_UNLESS(settings.IsSuccess());\n         DictionaryEncoding = *settings;\n     }\n-    Loader = std::make_shared<TColumnLoader>(GetLoadTransformer(), Serializer, ArrowSchema, DefaultValue.GetValue(), ColumnId);\n+    Loader = std::make_shared<TColumnLoader>(GetLoadTransformer(), Serializer, DataAccessorConstructor, ArrowField, DefaultValue.GetValue(), ColumnId);\n     return TConclusionStatus::Success();\n }\n \n-TSimpleColumnInfo::TSimpleColumnInfo(const ui32 columnId, const std::shared_ptr<arrow::Field>& arrowField, const NArrow::NSerialization::TSerializerContainer& serializer,\n-    const bool needMinMax, const bool isSorted,\n+TSimpleColumnInfo::TSimpleColumnInfo(const ui32 columnId, const std::shared_ptr<arrow::Field>& arrowField,\n+    const NArrow::NSerialization::TSerializerContainer& serializer, const bool needMinMax, const bool isSorted, const bool isNullable,\n     const std::shared_ptr<arrow::Scalar>& defaultValue)\n     : ColumnId(columnId)\n     , ArrowField(arrowField)\n-    , ArrowSchema(std::make_shared<arrow::Schema>(arrow::FieldVector({arrowField})))\n     , Serializer(serializer)\n     , NeedMinMax(needMinMax)\n     , IsSorted(isSorted)\n+    , IsNullable(isNullable)\n     , DefaultValue(defaultValue)\n {\n     ColumnName = ArrowField->name();\n-    Loader = std::make_shared<TColumnLoader>(GetLoadTransformer(), Serializer, ArrowSchema, DefaultValue.GetValue(), ColumnId);\n+    Loader = std::make_shared<TColumnLoader>(\n+        GetLoadTransformer(), Serializer, DataAccessorConstructor, ArrowField, DefaultValue.GetValue(), ColumnId);\n }\n \n std::vector<std::shared_ptr<NKikimr::NOlap::IPortionDataChunk>> TSimpleColumnInfo::ActualizeColumnData(const std::vector<std::shared_ptr<IPortionDataChunk>>& source, const TSimpleColumnInfo& sourceColumnFeatures) const {\n@@ -86,7 +90,7 @@ std::vector<std::shared_ptr<NKikimr::NOlap::IPortionDataChunk>> TSimpleColumnInf\n     }\n     std::vector<std::shared_ptr<IPortionDataChunk>> result;\n     for (auto&& s : source) {\n-        auto data = NArrow::TStatusValidator::GetValid(sourceColumnFeatures.Loader->Apply(s->GetData()));\n+        auto data = sourceColumnFeatures.Loader->ApplyRawVerified(s->GetData());\n         result.emplace_back(s->CopyWithAnotherBlob(GetColumnSaver().Apply(data), *this));\n     }\n     return result;\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/column/info.h b/ydb/core/tx/columnshard/engines/scheme/column/info.h\nindex 6db21f1fe876..ef47445bf665 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/column/info.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/column/info.h\n@@ -1,17 +1,18 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/engines/scheme/abstract/loader.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/abstract/saver.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/defaults/common/scalar.h>\n-\n+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <ydb/core/formats/arrow/dictionary/object.h>\n+#include <ydb/core/formats/arrow/save_load/loader.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n-#include <ydb/core/formats/arrow/transformer/abstract.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/defaults/common/scalar.h>\n \n #include <ydb/library/accessor/accessor.h>\n \n-#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \n namespace NKikimr::NOlap {\n \n@@ -22,19 +23,19 @@ class TSimpleColumnInfo {\n     YDB_READONLY(ui32, ColumnId, 0);\n     YDB_READONLY_DEF(TString, ColumnName);\n     YDB_READONLY_DEF(std::shared_ptr<arrow::Field>, ArrowField);\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::Schema>, ArrowSchema);\n     YDB_READONLY(NArrow::NSerialization::TSerializerContainer, Serializer, NArrow::NSerialization::TSerializerContainer::GetDefaultSerializer());\n+    YDB_READONLY(NArrow::NAccessor::TConstructorContainer, DataAccessorConstructor, NArrow::NAccessor::TConstructorContainer::GetDefaultConstructor());\n     YDB_READONLY(bool, NeedMinMax, false);\n     YDB_READONLY(bool, IsSorted, false);\n+    YDB_READONLY(bool, IsNullable, false);\n     YDB_READONLY_DEF(TColumnDefaultScalarValue, DefaultValue);\n     std::optional<NArrow::NDictionary::TEncodingSettings> DictionaryEncoding;\n     std::shared_ptr<TColumnLoader> Loader;\n     NArrow::NTransformation::ITransformer::TPtr GetLoadTransformer() const;\n \n public:\n-\n-    TSimpleColumnInfo(const ui32 columnId, const std::shared_ptr<arrow::Field>& arrowField, \n-        const NArrow::NSerialization::TSerializerContainer& serializer, const bool needMinMax, const bool isSorted,\n+    TSimpleColumnInfo(const ui32 columnId, const std::shared_ptr<arrow::Field>& arrowField,\n+        const NArrow::NSerialization::TSerializerContainer& serializer, const bool needMinMax, const bool isSorted, const bool isNullable,\n         const std::shared_ptr<arrow::Scalar>& defaultValue);\n \n     TColumnSaver GetColumnSaver() const {\n@@ -43,7 +44,8 @@ class TSimpleColumnInfo {\n         return TColumnSaver(transformer, Serializer);\n     }\n \n-    std::vector<std::shared_ptr<IPortionDataChunk>> ActualizeColumnData(const std::vector<std::shared_ptr<IPortionDataChunk>>& source, const TSimpleColumnInfo& sourceColumnFeatures) const;\n+    std::vector<std::shared_ptr<IPortionDataChunk>> ActualizeColumnData(\n+        const std::vector<std::shared_ptr<IPortionDataChunk>>& source, const TSimpleColumnInfo& sourceColumnFeatures) const;\n \n     TString DebugString() const {\n         TStringBuilder sb;\n@@ -62,4 +64,4 @@ class TSimpleColumnInfo {\n     }\n };\n \n-} // namespace NKikimr::NOlap\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/column_features.h b/ydb/core/tx/columnshard/engines/scheme/column_features.h\nindex 671b35e57734..c31c2a970a00 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/column_features.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/column_features.h\n@@ -1,15 +1,14 @@\n #pragma once\n-#include \"abstract/loader.h\"\n-#include \"abstract/saver.h\"\n #include \"column/info.h\"\n \n #include <ydb/core/formats/arrow/dictionary/object.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n-#include <ydb/core/formats/arrow/transformer/abstract.h>\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/storage.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/storages_manager.h>\n #include <ydb/core/tx/columnshard/splitter/abstract/chunks.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n@@ -34,9 +33,9 @@ class TColumnFeatures: public TSimpleColumnInfo {\n     YDB_READONLY_DEF(std::shared_ptr<IBlobsStorageOperator>, Operator);\n public:\n     TColumnFeatures(const ui32 columnId, const std::shared_ptr<arrow::Field>& arrowField, const NArrow::NSerialization::TSerializerContainer& serializer,\n-        const std::shared_ptr<IBlobsStorageOperator>& bOperator, const bool needMinMax, const bool isSorted,\n+        const std::shared_ptr<IBlobsStorageOperator>& bOperator, const bool needMinMax, const bool isSorted, const bool isNullable,\n         const std::shared_ptr<arrow::Scalar>& defaultValue)\n-        : TBase(columnId, arrowField, serializer, needMinMax, isSorted, defaultValue)\n+        : TBase(columnId, arrowField, serializer, needMinMax, isSorted, isNullable, defaultValue)\n         , Operator(bOperator)\n     {\n         AFL_VERIFY(Operator);\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/index_info.cpp b/ydb/core/tx/columnshard/engines/scheme/index_info.cpp\nindex 5bdfc2838eb9..25c2f4e1d22d 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/index_info.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/index_info.cpp\n@@ -1,36 +1,24 @@\n #include \"index_info.h\"\n \n-#include <ydb/core/tx/columnshard/engines/storage/chunks/column.h>\n-#include <ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h>\n-#include <ydb/core/tx/columnshard/engines/storage/indexes/max/meta.h>\n-\n #include <ydb/core/base/appdata.h>\n #include <ydb/core/formats/arrow/arrow_batch_builder.h>\n #include <ydb/core/formats/arrow/serializer/native.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n #include <ydb/core/formats/arrow/transformer/dictionary.h>\n #include <ydb/core/sys_view/common/schema.h>\n+#include <ydb/core/tx/columnshard/engines/storage/chunks/column.h>\n+#include <ydb/core/tx/columnshard/engines/storage/indexes/max/meta.h>\n+#include <ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h>\n \n namespace NKikimr::NOlap {\n \n-static std::vector<TString> NamesOnly(const std::vector<TNameTypeInfo>& columns) {\n-    std::vector<TString> out;\n-    out.reserve(columns.size());\n-    for (const auto& [name, _] : columns) {\n-        out.push_back(name);\n-    }\n-    return out;\n-}\n-\n TIndexInfo::TIndexInfo(const TString& name)\n-    : NTable::TScheme::TTableSchema()\n-    , Name(name)\n-{\n+    : Name(name) {\n     CompactionPlannerConstructor = NStorageOptimizer::IOptimizerPlannerConstructor::BuildDefault();\n }\n \n bool TIndexInfo::CheckCompatible(const TIndexInfo& other) const {\n-    if (!other.GetPrimaryKey()->Equals(GetPrimaryKey())) {\n+    if (!other.GetPrimaryKey()->Equals(PrimaryKey)) {\n         return false;\n     }\n     return true;\n@@ -43,22 +31,24 @@ ui32 TIndexInfo::GetColumnIdVerified(const std::string& name) const {\n }\n \n std::optional<ui32> TIndexInfo::GetColumnIdOptional(const std::string& name) const {\n-    const auto ni = ColumnNames.find(name);\n-\n-    if (ni != ColumnNames.end()) {\n-        return ni->second;\n+    const auto pred = [](const TNameInfo& item, const std::string& value) {\n+        return item.GetName() < value;\n+    };\n+    auto it = std::lower_bound(ColumnNames.begin(), ColumnNames.end(), name, pred);\n+    if (it != ColumnNames.end() && it->GetName() == name) {\n+        return it->GetColumnId();\n     }\n     return IIndexInfo::GetColumnIdOptional(name);\n }\n \n-TString TIndexInfo::GetColumnName(ui32 id, bool required) const {\n-    const auto ci = Columns.find(id);\n-\n-    if (ci != Columns.end()) {\n-        return ci->second.Name;\n+TString TIndexInfo::GetColumnName(const ui32 id, bool required) const {\n+    const auto& f = GetColumnFeaturesOptional(id);\n+    if (!f) {\n+        AFL_VERIFY(!required);\n+        return \"\";\n+    } else {\n+        return f->GetColumnName();\n     }\n-\n-    return IIndexInfo::GetColumnName(id, required);\n }\n \n const std::vector<ui32>& TIndexInfo::GetColumnIds(const bool withSpecial) const {\n@@ -73,9 +63,7 @@ std::vector<TString> TIndexInfo::GetColumnNames(const std::vector<ui32>& ids) co\n     std::vector<TString> out;\n     out.reserve(ids.size());\n     for (ui32 id : ids) {\n-        const auto ci = Columns.find(id);\n-        Y_ABORT_UNLESS(ci != Columns.end());\n-        out.push_back(ci->second.Name);\n+        out.push_back(GetColumnName(id));\n     }\n     return out;\n }\n@@ -84,46 +72,21 @@ std::vector<std::string> TIndexInfo::GetColumnSTLNames(const std::vector<ui32>&\n     std::vector<std::string> out;\n     out.reserve(ids.size());\n     for (ui32 id : ids) {\n-        const auto ci = Columns.find(id);\n-        Y_ABORT_UNLESS(ci != Columns.end());\n-        out.push_back(ci->second.Name);\n+        out.push_back(GetColumnName(id));\n     }\n     return out;\n }\n \n-std::vector<TNameTypeInfo> TIndexInfo::GetColumns(const std::vector<ui32>& ids) const {\n-    return NOlap::GetColumns(*this, ids);\n-}\n-\n-std::shared_ptr<arrow::Schema> TIndexInfo::ArrowSchema() const {\n+const std::shared_ptr<NArrow::TSchemaLite>& TIndexInfo::ArrowSchema() const {\n     AFL_VERIFY(Schema);\n     return Schema;\n }\n \n-std::shared_ptr<arrow::Schema> TIndexInfo::ArrowSchemaWithSpecials() const {\n+const std::shared_ptr<NArrow::TSchemaLite>& TIndexInfo::ArrowSchemaWithSpecials() const {\n     AFL_VERIFY(SchemaWithSpecials);\n     return SchemaWithSpecials;\n }\n \n-std::shared_ptr<arrow::Schema> TIndexInfo::AddColumns(\n-    const std::shared_ptr<arrow::Schema>& src,\n-    const std::vector<TString>& columns) const {\n-    std::shared_ptr<arrow::Schema> all = ArrowSchemaWithSpecials();\n-    auto fields = src->fields();\n-\n-    for (const auto& col : columns) {\n-        const std::string name(col.data(), col.size());\n-        if (!src->GetFieldByName(name)) {\n-            auto field = all->GetFieldByName(name);\n-            if (!field) {\n-                return {};\n-            }\n-            fields.push_back(field);\n-        }\n-    }\n-    return std::make_shared<arrow::Schema>(std::move(fields));\n-}\n-\n std::vector<ui32> TIndexInfo::GetColumnIds(const std::vector<TString>& columnNames) const {\n     std::vector<ui32> ids;\n     ids.reserve(columnNames.size());\n@@ -137,34 +100,20 @@ std::vector<ui32> TIndexInfo::GetColumnIds(const std::vector<TString>& columnNam\n     return ids;\n }\n \n-std::shared_ptr<arrow::Field> TIndexInfo::ArrowColumnFieldVerified(const ui32 columnId) const {\n-    auto result = ArrowColumnFieldOptional(columnId);\n-    AFL_VERIFY(result);\n-    return result;\n-}\n-\n-std::shared_ptr<arrow::Field> TIndexInfo::ArrowColumnFieldOptional(const ui32 columnId) const {\n-    auto it = ArrowColumnByColumnIdCache.find(columnId);\n-    if (it == ArrowColumnByColumnIdCache.end()) {\n-        return nullptr;\n-    } else {\n-        return it->second;\n-    }\n-}\n-\n-void TIndexInfo::SetAllKeys(const std::shared_ptr<IStoragesManager>& operators) {\n+void TIndexInfo::SetAllKeys(const std::shared_ptr<IStoragesManager>& operators, const THashMap<ui32, NTable::TColumn>& columns) {\n     /// @note Setting replace and sorting key to PK we are able to:\n     /// * apply REPLACE by MergeSort\n     /// * apply PK predicate before REPLACE\n-    {\n-        AFL_VERIFY(PKColumnIds.empty());\n-        const auto& primaryKeyNames = NamesOnly(GetPrimaryKeyColumns());\n-        PKColumnIds = GetColumnIds(primaryKeyNames);\n-        AFL_VERIFY(PKColumnIds.size());\n-        PrimaryKey = MakeArrowSchema(Columns, PKColumnIds);\n+    PrimaryKey = MakeArrowSchema(columns, PKColumnIds, nullptr);\n+\n+    AFL_VERIFY(PKColumns.empty());\n+    for (auto&& i : PKColumnIds) {\n+        auto it = columns.find(i);\n+        AFL_VERIFY(it != columns.end());\n+        PKColumns.emplace_back(TNameTypeInfo(it->second.Name, it->second.PType));\n     }\n \n-    for (const auto& [colId, column] : Columns) {\n+    for (const auto& [colId, column] : columns) {\n         if (NArrow::IsPrimitiveYqlType(column.PType)) {\n             MinMaxIdxColumnsIds.insert(colId);\n         }\n@@ -172,38 +121,39 @@ void TIndexInfo::SetAllKeys(const std::shared_ptr<IStoragesManager>& operators)\n     MinMaxIdxColumnsIds.insert(GetPKFirstColumnId());\n     if (!Schema) {\n         AFL_VERIFY(!SchemaWithSpecials);\n-        InitializeCaches(operators);\n+        InitializeCaches(operators, columns, nullptr);\n     }\n }\n \n TColumnSaver TIndexInfo::GetColumnSaver(const ui32 columnId) const {\n-    auto it = ColumnFeatures.find(columnId);\n-    AFL_VERIFY(it != ColumnFeatures.end());\n-    return it->second.GetColumnSaver();\n+    return GetColumnFeaturesVerified(columnId).GetColumnSaver();\n }\n \n std::shared_ptr<TColumnLoader> TIndexInfo::GetColumnLoaderOptional(const ui32 columnId) const {\n-    auto it = ColumnFeatures.find(columnId);\n-    if (it == ColumnFeatures.end()) {\n+    const auto& cFeatures = GetColumnFeaturesOptional(columnId);\n+    if (!cFeatures) {\n         return nullptr;\n     } else {\n-        return it->second.GetLoader();\n+        return cFeatures->GetLoader();\n     }\n }\n \n-std::shared_ptr<arrow::Field> TIndexInfo::GetColumnFieldOptional(const ui32 columnId) const {\n-    std::shared_ptr<arrow::Schema> schema;\n-    if (IsSpecialColumn(columnId)) {\n-        return IIndexInfo::GetColumnFieldOptional(columnId);\n+std::optional<ui32> TIndexInfo::GetColumnIndexOptional(const ui32 id) const {\n+    auto it = std::lower_bound(SchemaColumnIdsWithSpecials.begin(), SchemaColumnIdsWithSpecials.end(), id);\n+    if (it == SchemaColumnIdsWithSpecials.end() || *it != id) {\n+        return std::nullopt;\n     } else {\n-        schema = ArrowSchema();\n+        return it - SchemaColumnIdsWithSpecials.begin();\n     }\n-    if (const TString columnName = GetColumnName(columnId, false)) {\n-        return schema->GetFieldByName(columnName);\n-    } else {\n+}\n+\n+std::shared_ptr<arrow::Field> TIndexInfo::GetColumnFieldOptional(const ui32 columnId) const {\n+    const std::optional<ui32> index = GetColumnIndexOptional(columnId);\n+    if (!index) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"column_id\", columnId)(\"event\", \"incorrect_column_id\");\n         return nullptr;\n     }\n+    return ArrowSchemaWithSpecials()->GetFieldByIndexVerified(*index);\n }\n \n std::shared_ptr<arrow::Field> TIndexInfo::GetColumnFieldVerified(const ui32 columnId) const {\n@@ -222,20 +172,24 @@ std::shared_ptr<arrow::Schema> TIndexInfo::GetColumnsSchema(const std::set<ui32>\n }\n \n std::shared_ptr<arrow::Schema> TIndexInfo::GetColumnSchema(const ui32 columnId) const {\n-    return GetColumnsSchema({columnId});\n+    return GetColumnsSchema({ columnId });\n }\n \n-bool TIndexInfo::DeserializeFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema, const std::shared_ptr<IStoragesManager>& operators) {\n+bool TIndexInfo::DeserializeFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema, const std::shared_ptr<IStoragesManager>& operators,\n+    const std::shared_ptr<TSchemaObjectsCache>& cache) {\n     if (schema.GetEngine() != NKikimrSchemeOp::COLUMN_ENGINE_REPLACING_TIMESERIES) {\n         AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_parse_index_info\")(\"reason\", \"incorrect_engine_in_schema\");\n         return false;\n     }\n+    AFL_VERIFY(cache);\n \n     {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::Optimizer\");\n         SchemeNeedActualization = schema.GetOptions().GetSchemeNeedActualization();\n         ExternalGuaranteeExclusivePK = schema.GetOptions().GetExternalGuaranteeExclusivePK();\n         if (schema.GetOptions().HasCompactionPlannerConstructor()) {\n-            auto container = NStorageOptimizer::TOptimizerPlannerConstructorContainer::BuildFromProto(schema.GetOptions().GetCompactionPlannerConstructor());\n+            auto container =\n+                NStorageOptimizer::TOptimizerPlannerConstructorContainer::BuildFromProto(schema.GetOptions().GetCompactionPlannerConstructor());\n             CompactionPlannerConstructor = container.DetachResult().GetObjectPtrVerified();\n         } else {\n             AFL_VERIFY(!!CompactionPlannerConstructor);\n@@ -243,6 +197,7 @@ bool TIndexInfo::DeserializeFromProto(const NKikimrSchemeOp::TColumnTableSchema&\n     }\n \n     if (schema.HasDefaultCompression()) {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::Serializer\");\n         NArrow::NSerialization::TSerializerContainer container;\n         if (!container.DeserializeFromProto(schema.GetDefaultCompression())) {\n             AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_parse_index_info\")(\"reason\", \"cannot_parse_default_serializer\");\n@@ -250,36 +205,68 @@ bool TIndexInfo::DeserializeFromProto(const NKikimrSchemeOp::TColumnTableSchema&\n         }\n         DefaultSerializer = container;\n     }\n-\n-    for (const auto& idx : schema.GetIndexes()) {\n-        NIndexes::TIndexMetaContainer meta;\n-        AFL_VERIFY(meta.DeserializeFromProto(idx));\n-        Indexes.emplace(meta->GetIndexId(), meta);\n+    {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::Indexes\");\n+        for (const auto& idx : schema.GetIndexes()) {\n+            NIndexes::TIndexMetaContainer meta;\n+            AFL_VERIFY(meta.DeserializeFromProto(idx));\n+            Indexes.emplace(meta->GetIndexId(), meta);\n+        }\n     }\n-    for (const auto& col : schema.GetColumns()) {\n-        const ui32 id = col.GetId();\n-        const TString& name = col.GetName();\n-        const bool notNull = col.HasNotNull() ? col.GetNotNull() : false;\n-        auto typeInfoMod = NScheme::TypeInfoModFromProtoColumnType(col.GetTypeId(), col.HasTypeInfo() ? &col.GetTypeInfo() : nullptr);\n-        Columns[id] = NTable::TColumn(name, id, typeInfoMod.TypeInfo, typeInfoMod.TypeMod, notNull);\n-        ColumnNames[name] = id;\n+    THashMap<ui32, NTable::TColumn> columns;\n+    {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::Columns\");\n+        ColumnNames.clear();\n+        for (const auto& col : schema.GetColumns()) {\n+            const ui32 id = col.GetId();\n+            const TString& name = cache->GetStringCache(col.GetName());\n+            const bool notNull = col.HasNotNull() ? col.GetNotNull() : false;\n+            auto typeInfoMod = NScheme::TypeInfoModFromProtoColumnType(col.GetTypeId(), col.HasTypeInfo() ? &col.GetTypeInfo() : nullptr);\n+            columns[id] = NTable::TColumn(name, id, typeInfoMod.TypeInfo, cache->GetStringCache(typeInfoMod.TypeMod), notNull);\n+            ColumnNames.emplace_back(name, id);\n+        }\n+        std::sort(ColumnNames.begin(), ColumnNames.end());\n     }\n     for (const auto& keyName : schema.GetKeyColumnNames()) {\n-        Y_ABORT_UNLESS(ColumnNames.contains(keyName));\n-        KeyColumns.push_back(ColumnNames[keyName]);\n-    }\n-    InitializeCaches(operators);\n-    for (const auto& col : schema.GetColumns()) {\n-        auto it = ColumnFeatures.find(col.GetId());\n-        AFL_VERIFY(it != ColumnFeatures.end());\n-        auto parsed = it->second.DeserializeFromProto(col, operators);\n-        if (!parsed) {\n-            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_parse_column_feature\")(\"reason\", parsed.GetErrorMessage());\n-            return false;\n+        PKColumnIds.push_back(GetColumnIdVerified(keyName));\n+    }\n+    InitializeCaches(operators, columns, cache, false);\n+    SetAllKeys(operators, columns);\n+    {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::Columns::Features\");\n+        for (const auto& col : schema.GetColumns()) {\n+            THashMap<ui32, std::shared_ptr<TColumnFeatures>> it;\n+            const TString fingerprint = cache ? (\"C:\" + col.SerializeAsString()) : Default<TString>();\n+            const auto createPred = [&]() -> TConclusion<std::shared_ptr<TColumnFeatures>> {\n+                auto f = BuildDefaultColumnFeatures(col.GetId(), columns, operators);\n+                auto parsed = f->DeserializeFromProto(col, operators);\n+                if (parsed.IsFail()) {\n+                    return parsed;\n+                }\n+                return f;\n+            };\n+            auto fConclusion = cache->GetOrCreateColumnFeatures(fingerprint, createPred);\n+            if (fConclusion.IsFail()) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot_parse_column_feature\")(\"reason\", fConclusion.GetErrorMessage());\n+                return false;\n+            }\n+            ColumnFeatures.emplace_back(fConclusion.DetachResult());\n+        }\n+        for (auto&& cId : GetSystemColumnIds()) {\n+            THashMap<ui32, std::shared_ptr<TColumnFeatures>> it;\n+            const TString fingerprint = \"SC:\" + ::ToString(cId);\n+            const auto createPred = [&]() -> TConclusion<std::shared_ptr<TColumnFeatures>> {\n+                return BuildDefaultColumnFeatures(cId, {}, operators);\n+            };\n+            auto fConclusion = cache->GetOrCreateColumnFeatures(fingerprint, createPred);\n+            ColumnFeatures.emplace_back(fConclusion.DetachResult());\n         }\n+        const auto pred = [](const std::shared_ptr<TColumnFeatures>& l, const std::shared_ptr<TColumnFeatures>& r) {\n+            return l->GetColumnId() < r->GetColumnId();\n+        };\n+        std::sort(ColumnFeatures.begin(), ColumnFeatures.end(), pred);\n     }\n \n-\n     Version = schema.GetVersion();\n     return true;\n }\n@@ -295,15 +282,17 @@ std::vector<TNameTypeInfo> GetColumns(const NTable::TScheme::TTableSchema& table\n     return out;\n }\n \n-std::optional<TIndexInfo> TIndexInfo::BuildFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema, const std::shared_ptr<IStoragesManager>& operators) {\n+std::optional<TIndexInfo> TIndexInfo::BuildFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema,\n+    const std::shared_ptr<IStoragesManager>& operators, const std::shared_ptr<TSchemaObjectsCache>& cache) {\n     TIndexInfo result(\"\");\n-    if (!result.DeserializeFromProto(schema, operators)) {\n+    if (!result.DeserializeFromProto(schema, operators, cache)) {\n         return std::nullopt;\n     }\n     return result;\n }\n \n-std::shared_ptr<arrow::Schema> MakeArrowSchema(const NTable::TScheme::TTableSchema::TColumns& columns, const std::vector<ui32>& ids) {\n+std::vector<std::shared_ptr<arrow::Field>> MakeArrowFields(const NTable::TScheme::TTableSchema::TColumns& columns, const std::vector<ui32>& ids,\n+    const std::shared_ptr<TSchemaObjectsCache>& cache) {\n     std::vector<std::shared_ptr<arrow::Field>> fields;\n     for (const ui32 id : ids) {\n         AFL_VERIFY(!TIndexInfo::IsSpecialColumn(id));\n@@ -314,52 +303,64 @@ std::shared_ptr<arrow::Schema> MakeArrowSchema(const NTable::TScheme::TTableSche\n         std::string colName(column.Name.data(), column.Name.size());\n         auto arrowType = NArrow::GetArrowType(column.PType);\n         AFL_VERIFY(arrowType.ok());\n-        fields.emplace_back(std::make_shared<arrow::Field>(colName, arrowType.ValueUnsafe(), !column.NotNull));\n+        auto f = std::make_shared<arrow::Field>(colName, arrowType.ValueUnsafe(), !column.NotNull);\n+        if (cache) {\n+            auto fFound = cache->GetField(f->ToString(true));\n+            if (!fFound) {\n+                cache->RegisterField(f->ToString(true), f);\n+                fields.emplace_back(f);\n+            } else {\n+                fields.emplace_back(fFound);\n+            }\n+        } else {\n+            fields.emplace_back(f);\n+        }\n     }\n \n-    return std::make_shared<arrow::Schema>(std::move(fields));\n+    return fields;\n+}\n+\n+std::shared_ptr<arrow::Schema> MakeArrowSchema(\n+    const NTable::TScheme::TTableSchema::TColumns& columns, const std::vector<ui32>& ids, const std::shared_ptr<TSchemaObjectsCache>& cache) {\n+    return std::make_shared<arrow::Schema>(MakeArrowFields(columns, ids, cache));\n }\n \n-void TIndexInfo::InitializeCaches(const std::shared_ptr<IStoragesManager>& operators) {\n+void TIndexInfo::InitializeCaches(const std::shared_ptr<IStoragesManager>& operators, const THashMap<ui32, NTable::TColumn>& columns, const std::shared_ptr<TSchemaObjectsCache>& cache,\n+    const bool withColumnFeatures) {\n     {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::InitializeCaches::Schema\");\n         AFL_VERIFY(!Schema);\n-        SchemaColumnIds.reserve(Columns.size());\n-        for (const auto& [id, _] : Columns) {\n+        SchemaColumnIds.reserve(columns.size());\n+        for (const auto& [id, _] : columns) {\n             SchemaColumnIds.push_back(id);\n         }\n \n         std::sort(SchemaColumnIds.begin(), SchemaColumnIds.end());\n-        Schema = MakeArrowSchema(Columns, SchemaColumnIds);\n+        auto originalFields = MakeArrowFields(columns, SchemaColumnIds, cache);\n+        Schema = std::make_shared<NArrow::TSchemaLite>(originalFields);\n+        IIndexInfo::AddSpecialFields(originalFields);\n+        SchemaWithSpecials = std::make_shared<NArrow::TSchemaLite>(originalFields);\n     }\n-    SchemaWithSpecials = IIndexInfo::AddSpecialFields(Schema);\n-    SchemaColumnIdsWithSpecials = IIndexInfo::AddSpecialFieldIds(SchemaColumnIds);\n-\n-    for (auto&& c : Columns) {\n-        AFL_VERIFY(ArrowColumnByColumnIdCache.emplace(c.first, GetColumnFieldVerified(c.first)).second);\n-        AFL_VERIFY(ColumnFeatures.emplace(c.first, TColumnFeatures(c.first, GetColumnFieldVerified(c.first), DefaultSerializer, operators->GetDefaultOperator(), \n-            NArrow::IsPrimitiveYqlType(c.second.PType), c.first == GetPKFirstColumnId(), nullptr)).second);\n-    }\n-    for (auto&& cId : GetSystemColumnIds()) {\n-        AFL_VERIFY(ArrowColumnByColumnIdCache.emplace(cId, GetColumnFieldVerified(cId)).second);\n-        AFL_VERIFY(ColumnFeatures.emplace(cId, TColumnFeatures(cId, GetColumnFieldVerified(cId), DefaultSerializer, operators->GetDefaultOperator(),\n-            false, false, IIndexInfo::DefaultColumnValue(cId))).second);\n+    {\n+        TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::InitializeCaches::SchemaFields\");\n+        SchemaColumnIdsWithSpecials = IIndexInfo::AddSpecialFieldIds(SchemaColumnIds);\n+    }\n+    if (withColumnFeatures) {\n+        {\n+            TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::InitializeCaches::Columns\");\n+            for (auto&& c : columns) {\n+                ColumnFeatures.emplace_back(BuildDefaultColumnFeatures(c.first, columns, operators));\n+            }\n+        }\n+        {\n+            TMemoryProfileGuard g(\"TIndexInfo::DeserializeFromProto::InitializeCaches::SysColumns\");\n+            for (auto&& cId : GetSystemColumnIds()) {\n+                ColumnFeatures.emplace_back(BuildDefaultColumnFeatures(cId, columns, operators));\n+            }\n+        }\n     }\n }\n \n-std::vector<std::shared_ptr<NKikimr::NOlap::IPortionDataChunk>> TIndexInfo::MakeEmptyChunks(const ui32 columnId, const std::vector<ui32>& pages, const TSimpleColumnInfo& columnInfo) const {\n-    std::vector<std::shared_ptr<IPortionDataChunk>> result;\n-    auto columnArrowSchema = GetColumnSchema(columnId);\n-    TColumnSaver saver = GetColumnSaver(columnId);\n-    ui32 idx = 0;\n-    for (auto p : pages) {\n-        auto arr = NArrow::MakeEmptyBatch(columnArrowSchema, p);\n-        AFL_VERIFY(arr->num_columns() == 1)(\"count\", arr->num_columns());\n-        result.emplace_back(std::make_shared<NChunks::TChunkPreparation>(saver.Apply(arr), arr->column(0), TChunkAddress(columnId, idx), columnInfo));\n-        ++idx;\n-    }\n-    return result;\n-}\n-\n NSplitter::TEntityGroups TIndexInfo::GetEntityGroupsByStorageId(const TString& specialTier, const IStoragesManager& storages) const {\n     NSplitter::TEntityGroups groups(storages.GetDefaultOperator()->GetBlobSplitSettings(), IStoragesManager::DefaultStorageId);\n     for (auto&& i : GetEntityIds()) {\n@@ -384,9 +385,6 @@ std::shared_ptr<arrow::Scalar> TIndexInfo::GetColumnExternalDefaultValueVerified\n }\n \n std::shared_ptr<arrow::Scalar> TIndexInfo::GetColumnExternalDefaultValueVerified(const ui32 columnId) const {\n-    if (IIndexInfo::IsSpecialColumn(columnId)) {\n-        return IIndexInfo::DefaultColumnValue(columnId);\n-    }\n     return GetColumnFeaturesVerified(columnId).GetDefaultValue().GetValue();\n }\n \n@@ -430,4 +428,22 @@ std::vector<ui32> TIndexInfo::GetEntityIds() const {\n     return result;\n }\n \n-} // namespace NKikimr::NOlap\n+std::shared_ptr<NKikimr::NOlap::TColumnFeatures> TIndexInfo::BuildDefaultColumnFeatures(\n+    const ui32 columnId, const THashMap<ui32, NTable::TColumn>& columns, const std::shared_ptr<IStoragesManager>& operators) const {\n+    if (IsSpecialColumn(columnId)) {\n+        return std::make_shared<TColumnFeatures>(columnId, GetColumnFieldVerified(columnId), DefaultSerializer, operators->GetDefaultOperator(),\n+            false, false, false, IIndexInfo::DefaultColumnValue(columnId));\n+    } else {\n+        auto itC = columns.find(columnId);\n+        AFL_VERIFY(itC != columns.end());\n+        return std::make_shared<TColumnFeatures>(columnId, GetColumnFieldVerified(columnId), DefaultSerializer, operators->GetDefaultOperator(),\n+            NArrow::IsPrimitiveYqlType(itC->second.PType), columnId == GetPKFirstColumnId(), false, nullptr);\n+    }\n+}\n+\n+std::shared_ptr<arrow::Scalar> TIndexInfo::GetColumnExternalDefaultValueByIndexVerified(const ui32 colIndex) const {\n+    AFL_VERIFY(colIndex < ColumnFeatures.size())(\"index\", colIndex)(\"size\", ColumnFeatures.size());\n+    return ColumnFeatures[colIndex]->GetDefaultValue().GetValue();\n+}\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/index_info.h b/ydb/core/tx/columnshard/engines/scheme/index_info.h\nindex 622f8c741050..d2fef0f4060c 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/index_info.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/index_info.h\n@@ -6,21 +6,22 @@\n #include \"abstract/index_info.h\"\n #include \"indexes/abstract/meta.h\"\n \n-#include <ydb/core/tx/columnshard/common/snapshot.h>\n-\n-#include <ydb/core/sys_view/common/schema.h>\n-#include <ydb/core/tx/columnshard/common/scalars.h>\n-#include <ydb/core/tx/columnshard/common/portion.h>\n #include <ydb/core/formats/arrow/dictionary/object.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n-#include <ydb/core/formats/arrow/transformer/abstract.h>\n+#include <ydb/library/formats/arrow/transformer/abstract.h>\n #include <ydb/core/scheme/scheme_types_proto.h>\n+#include <ydb/core/sys_view/common/schema.h>\n+#include <ydb/core/tx/columnshard/common/portion.h>\n+#include <ydb/core/tx/columnshard/common/scalars.h>\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n+\n+#include <library/cpp/string_utils/quote/quote.h>\n \n namespace arrow {\n-    class Array;\n-    class Field;\n-    class Schema;\n-}\n+class Array;\n+class Field;\n+class Schema;\n+}   // namespace arrow\n \n namespace NKikimr::NOlap {\n \n@@ -32,51 +33,141 @@ namespace NStorageOptimizer {\n class IOptimizerPlannerConstructor;\n }\n class TPortionInfoWithBlobs;\n-struct TInsertedData;\n class TSnapshotColumnInfo;\n class ISnapshotSchema;\n using TNameTypeInfo = std::pair<TString, NScheme::TTypeInfo>;\n \n+class TSchemaObjectsCache {\n+private:\n+    THashMap<TString, std::shared_ptr<arrow::Field>> Fields;\n+    THashMap<TString, std::shared_ptr<TColumnFeatures>> ColumnFeatures;\n+    THashSet<TString> StringsCache;\n+    mutable ui64 AcceptionFieldsCount = 0;\n+    mutable ui64 AcceptionFeaturesCount = 0;\n+\n+public:\n+    const TString& GetStringCache(const TString& original) {\n+        auto it = StringsCache.find(original);\n+        if (it == StringsCache.end()) {\n+            it = StringsCache.emplace(original).first;\n+        }\n+        return *it;\n+    }\n+\n+    void RegisterField(const TString& fingerprint, const std::shared_ptr<arrow::Field>& f) {\n+        AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"register_field\")(\"fp\", fingerprint)(\"f\", f->ToString());\n+        AFL_VERIFY(Fields.emplace(fingerprint, f).second);\n+    }\n+    void RegisterColumnFeatures(const TString& fingerprint, const std::shared_ptr<TColumnFeatures>& f) {\n+        AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"register_column_features\")(\"fp\", fingerprint)(\"info\", f->DebugString());\n+        AFL_VERIFY(ColumnFeatures.emplace(fingerprint, f).second);\n+    }\n+    std::shared_ptr<arrow::Field> GetField(const TString& fingerprint) const {\n+        auto it = Fields.find(fingerprint);\n+        if (it == Fields.end()) {\n+            AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"get_field_miss\")(\"fp\", fingerprint)(\"count\", Fields.size())(\n+                \"acc\", AcceptionFieldsCount);\n+            return nullptr;\n+        }\n+        if (++AcceptionFieldsCount % 1000 == 0) {\n+            AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"get_field_accept\")(\"fp\", fingerprint)(\"count\", Fields.size())(\n+                \"acc\", AcceptionFieldsCount);\n+        }\n+        return it->second;\n+    }\n+    template <class TConstructor>\n+    TConclusion<std::shared_ptr<TColumnFeatures>> GetOrCreateColumnFeatures(const TString& fingerprint, const TConstructor& constructor) {\n+        auto it = ColumnFeatures.find(fingerprint);\n+        if (it == ColumnFeatures.end()) {\n+            AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"get_column_features_miss\")(\"fp\", UrlEscapeRet(fingerprint))(\n+                \"count\", ColumnFeatures.size())(\"acc\", AcceptionFeaturesCount);\n+            TConclusion<std::shared_ptr<TColumnFeatures>> resultConclusion = constructor();\n+            if (resultConclusion.IsFail()) {\n+                return resultConclusion;\n+            }\n+            it = ColumnFeatures.emplace(fingerprint, resultConclusion.DetachResult()).first;\n+            AFL_VERIFY(it->second);\n+        } else {\n+            if (++AcceptionFeaturesCount % 1000 == 0) {\n+                AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"get_column_features_accept\")(\"fp\", UrlEscapeRet(fingerprint))(\n+                    \"count\", ColumnFeatures.size())(\"acc\", AcceptionFeaturesCount);\n+            }\n+        }\n+        return it->second;\n+    }\n+};\n+\n /// Column engine index description in terms of tablet's local table.\n /// We have to use YDB types for keys here.\n-struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n+struct TIndexInfo: public IIndexInfo {\n private:\n-    THashMap<ui32, TColumnFeatures> ColumnFeatures;\n-    THashMap<ui32, std::shared_ptr<arrow::Field>> ArrowColumnByColumnIdCache;\n+    using TColumns = THashMap<ui32, NTable::TColumn>;\n+\n+    class TNameInfo {\n+    private:\n+        YDB_READONLY_DEF(TString, Name);\n+        YDB_READONLY(ui32, ColumnId, 0);\n+\n+    public:\n+        TNameInfo(const TString& name, const ui32 columnId)\n+            : Name(name)\n+            , ColumnId(columnId)\n+        {\n+\n+        }\n+\n+        bool operator<(const TNameInfo& item) const {\n+            return Name < item.Name;\n+        }\n+    };\n+\n+    std::vector<TNameInfo> ColumnNames;\n+    std::vector<ui32> PKColumnIds;\n+    std::vector<TNameTypeInfo> PKColumns;\n+\n+    std::vector<std::shared_ptr<TColumnFeatures>> ColumnFeatures;\n     THashMap<ui32, NIndexes::TIndexMetaContainer> Indexes;\n     TIndexInfo(const TString& name);\n     bool SchemeNeedActualization = false;\n     std::shared_ptr<NStorageOptimizer::IOptimizerPlannerConstructor> CompactionPlannerConstructor;\n     bool ExternalGuaranteeExclusivePK = false;\n-    bool DeserializeFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema, const std::shared_ptr<IStoragesManager>& operators);\n-    void InitializeCaches(const std::shared_ptr<IStoragesManager>& operators);\n+    bool DeserializeFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema, const std::shared_ptr<IStoragesManager>& operators,\n+        const std::shared_ptr<TSchemaObjectsCache>& cache);\n+    void InitializeCaches(const std::shared_ptr<IStoragesManager>& operators, const THashMap<ui32, NTable::TColumn>& columns,\n+        const std::shared_ptr<TSchemaObjectsCache>& cache, const bool withColumnFeatures = true);\n+    std::shared_ptr<TColumnFeatures> BuildDefaultColumnFeatures(\n+        const ui32 columnId, const THashMap<ui32, NTable::TColumn>& columns, const std::shared_ptr<IStoragesManager>& operators) const;\n+\n public:\n     std::shared_ptr<NStorageOptimizer::IOptimizerPlannerConstructor> GetCompactionPlannerConstructor() const;\n-\n-    bool IsNullableVerified(const std::string& fName) const {\n-        return IsNullableVerified(GetColumnIdVerified(fName));\n+    bool IsNullableVerifiedByIndex(const ui32 colIndex) const {\n+        AFL_VERIFY(colIndex < ColumnFeatures.size());\n+        return ColumnFeatures[colIndex]->GetIsNullable();\n     }\n \n     bool IsNullableVerified(const ui32 colId) const {\n-        auto it = Columns.find(colId);\n-        if (it == Columns.end()) {\n-            AFL_VERIFY(IIndexInfo::IsSpecialColumn(colId));\n-            return IIndexInfo::IsNullableVerified(colId);\n-        }\n-        return !it->second.NotNull;\n+        return GetColumnFeaturesVerified(colId).GetIsNullable();\n     }\n \n     std::shared_ptr<arrow::Scalar> GetColumnExternalDefaultValueVerified(const std::string& colName) const;\n     std::shared_ptr<arrow::Scalar> GetColumnExternalDefaultValueVerified(const ui32 colId) const;\n+    std::shared_ptr<arrow::Scalar> GetColumnExternalDefaultValueByIndexVerified(const ui32 colIndex) const;\n+\n \n     bool GetExternalGuaranteeExclusivePK() const {\n         return ExternalGuaranteeExclusivePK;\n     }\n \n     const TColumnFeatures& GetColumnFeaturesVerified(const ui32 columnId) const {\n-        auto it = ColumnFeatures.find(columnId);\n-        AFL_VERIFY(it != ColumnFeatures.end());\n-        return it->second;\n+        return *ColumnFeatures[GetColumnIndexVerified(columnId)];\n+    }\n+\n+    const std::shared_ptr<TColumnFeatures>& GetColumnFeaturesOptional(const ui32 columnId) const {\n+        if (auto idx = GetColumnIndexOptional(columnId)) {\n+            return ColumnFeatures[*idx];\n+        } else {\n+            return Default<std::shared_ptr<TColumnFeatures>>();\n+        }\n     }\n \n     NSplitter::TEntityGroups GetEntityGroupsByStorageId(const TString& specialTier, const IStoragesManager& storages) const;\n@@ -91,14 +182,12 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n             result.emplace(portionTierName);\n         } else {\n             for (auto&& i : ColumnFeatures) {\n-                result.emplace(i.second.GetOperator()->GetStorageId());\n+                result.emplace(i->GetOperator()->GetStorageId());\n             }\n         }\n         return result;\n     }\n \n-    std::vector<std::shared_ptr<IPortionDataChunk>> MakeEmptyChunks(const ui32 columnId, const std::vector<ui32>& pages, const TSimpleColumnInfo& columnInfo) const;\n-\n     const THashMap<ui32, NIndexes::TIndexMetaContainer>& GetIndexes() const {\n         return Indexes;\n     }\n@@ -113,9 +202,7 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n         if (specialTier && specialTier != IStoragesManager::DefaultStorageId) {\n             return specialTier;\n         } else {\n-            auto it = ColumnFeatures.find(columnId);\n-            AFL_VERIFY(it != ColumnFeatures.end());\n-            return it->second.GetOperator()->GetStorageId();\n+            return GetColumnFeaturesVerified(columnId).GetOperator()->GetStorageId();\n         }\n     }\n \n@@ -130,33 +217,48 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n     TString DebugString() const {\n         TStringBuilder sb;\n         sb << \"(\"\n-            << \"version=\" << Version << \";\"\n-            << \"name=\" << Name << \";\"\n-            << \")\";\n+           << \"version=\" << Version << \";\"\n+           << \"name=\" << Name << \";\"\n+           << \")\";\n         for (auto&& i : ColumnFeatures) {\n-            sb << GetColumnName(i.first) << \":\" << i.second.DebugString() << \";\";\n+            sb << i->GetColumnName() << \":\" << i->DebugString() << \";\";\n         }\n         return sb;\n     }\n \n+    void SetAllKeys(const std::shared_ptr<IStoragesManager>& operators, const THashMap<ui32, NTable::TColumn>& columns);\n+\n public:\n     static TIndexInfo BuildDefault() {\n         TIndexInfo result(\"dummy\");\n         return result;\n     }\n \n-    std::vector<std::shared_ptr<IPortionDataChunk>> ActualizeColumnData(const std::vector<std::shared_ptr<IPortionDataChunk>>& source, const TIndexInfo& sourceIndexInfo, const ui32 columnId) const {\n-        auto itCurrent = ColumnFeatures.find(columnId);\n-        auto itPred = sourceIndexInfo.ColumnFeatures.find(columnId);\n-        AFL_VERIFY(itCurrent != ColumnFeatures.end());\n-        AFL_VERIFY(itPred != sourceIndexInfo.ColumnFeatures.end());\n-        return itCurrent->second.ActualizeColumnData(source, itPred->second);\n+    static TIndexInfo BuildDefault(\n+        const std::shared_ptr<IStoragesManager>& operators, const TColumns& columns, const std::vector<TString>& pkNames) {\n+        TIndexInfo result = BuildDefault();\n+        for (auto&& i : columns) {\n+            result.ColumnNames.emplace_back(i.second.Name, i.first);\n+        }\n+        std::sort(result.ColumnNames.begin(), result.ColumnNames.end());\n+        for (auto&& i : pkNames) {\n+            const ui32 columnId = result.GetColumnIdVerified(i);\n+            result.PKColumnIds.emplace_back(columnId);\n+        }\n+        result.SetAllKeys(operators, columns);\n+        return result;\n     }\n \n-    static std::optional<TIndexInfo> BuildFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema, const std::shared_ptr<IStoragesManager>& operators);\n+    std::vector<std::shared_ptr<IPortionDataChunk>> ActualizeColumnData(\n+        const std::vector<std::shared_ptr<IPortionDataChunk>>& source, const TIndexInfo& sourceIndexInfo, const ui32 columnId) const {\n+        return GetColumnFeaturesVerified(columnId).ActualizeColumnData(source, sourceIndexInfo.GetColumnFeaturesVerified(columnId));\n+    }\n+\n+    static std::optional<TIndexInfo> BuildFromProto(const NKikimrSchemeOp::TColumnTableSchema& schema,\n+        const std::shared_ptr<IStoragesManager>& operators, const std::shared_ptr<TSchemaObjectsCache>& cache);\n \n     bool HasColumnId(const ui32 columnId) const {\n-        return ColumnFeatures.contains(columnId);\n+        return !!GetColumnIndexOptional(columnId);\n     }\n \n     bool HasColumnName(const std::string& columnName) const {\n@@ -167,6 +269,12 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n         return Indexes.contains(indexId);\n     }\n \n+    std::optional<ui32> GetColumnIndexOptional(const ui32 id) const;\n+    ui32 GetColumnIndexVerified(const ui32 id) const {\n+        auto result = GetColumnIndexOptional(id);\n+        AFL_VERIFY(result);\n+        return *result;\n+    }\n     std::shared_ptr<arrow::Field> GetColumnFieldOptional(const ui32 columnId) const;\n     std::shared_ptr<arrow::Field> GetColumnFieldVerified(const ui32 columnId) const;\n     std::shared_ptr<arrow::Schema> GetColumnSchema(const ui32 columnId) const;\n@@ -209,6 +317,7 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n         YDB_ACCESSOR_DEF(TStorageData, SecondaryInplaceData);\n         using TPrimaryStorageData = THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>;\n         YDB_ACCESSOR_DEF(TPrimaryStorageData, ExternalData);\n+\n     public:\n         TSecondaryData() = default;\n     };\n@@ -228,14 +337,11 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n \n     std::shared_ptr<NIndexes::NMax::TIndexMeta> GetIndexMax(const ui32 columnId) const;\n \n-    [[nodiscard]] TConclusionStatus AppendIndex(const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& originalData, const ui32 indexId,\n-        const std::shared_ptr<IStoragesManager>& operators, TSecondaryData& result) const;\n+    [[nodiscard]] TConclusionStatus AppendIndex(const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& originalData,\n+        const ui32 indexId, const std::shared_ptr<IStoragesManager>& operators, TSecondaryData& result) const;\n \n     /// Returns an id of the column located by name. The name should exists in the schema.\n     ui32 GetColumnIdVerified(const std::string& name) const;\n-    ui32 GetColumnId(const std::string& name) const {\n-        return GetColumnIdVerified(name);\n-    }\n     std::set<ui32> GetColumnIdsVerified(const std::set<TString>& names) const {\n         std::set<ui32> result;\n         for (auto&& i : names) {\n@@ -246,7 +352,7 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n     std::optional<ui32> GetColumnIdOptional(const std::string& name) const;\n \n     /// Returns a name of the column located by id.\n-    TString GetColumnName(ui32 id, bool required = true) const;\n+    TString GetColumnName(const ui32 id, bool required = true) const;\n \n     /// Returns names of columns defined by the specific ids.\n     std::vector<TString> GetColumnNames(const std::vector<ui32>& ids) const;\n@@ -258,44 +364,29 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n     }\n     std::vector<ui32> GetEntityIds() const;\n \n-    /// Returns info of columns defined by specific ids.\n-    std::vector<TNameTypeInfo> GetColumns(const std::vector<ui32>& ids) const;\n-\n     /// Traditional Primary Key (includes uniqueness, search and sorting logic)\n-    std::vector<TNameTypeInfo> GetPrimaryKeyColumns() const {\n-        return GetColumns(KeyColumns);\n+    const std::vector<TNameTypeInfo>& GetPrimaryKeyColumns() const {\n+        return PKColumns;\n     }\n \n     /// Returns id of the first column of the primary key.\n     ui32 GetPKFirstColumnId() const {\n-        Y_ABORT_UNLESS(KeyColumns.size());\n-        return KeyColumns[0];\n+        Y_ABORT_UNLESS(PKColumnIds.size());\n+        return PKColumnIds[0];\n     }\n \n     const std::shared_ptr<arrow::Schema>& GetReplaceKey() const { return PrimaryKey; }\n     const std::shared_ptr<arrow::Schema>& GetPrimaryKey() const { return PrimaryKey; }\n \n-    /// Initializes sorting, replace, index and extended keys.\n-    void SetAllKeys(const std::shared_ptr<IStoragesManager>& operators);\n-\n     void CheckTtlColumn(const TString& ttlColumn) const {\n         Y_ABORT_UNLESS(!ttlColumn.empty());\n-        Y_ABORT_UNLESS(MinMaxIdxColumnsIds.contains(GetColumnId(ttlColumn)));\n+        Y_ABORT_UNLESS(MinMaxIdxColumnsIds.contains(GetColumnIdVerified(ttlColumn)));\n     }\n \n     std::vector<ui32> GetColumnIds(const std::vector<TString>& columnNames) const;\n \n-    std::shared_ptr<arrow::Schema> ArrowSchema() const;\n-    std::shared_ptr<arrow::Schema> ArrowSchemaWithSpecials() const;\n-    std::shared_ptr<arrow::Schema> AddColumns(const std::shared_ptr<arrow::Schema>& schema,\n-                                              const std::vector<TString>& columns) const;\n-\n-    std::shared_ptr<arrow::Field> ArrowColumnFieldOptional(const ui32 columnId) const;\n-    std::shared_ptr<arrow::Field> ArrowColumnFieldVerified(const ui32 columnId) const;\n-\n-    const THashSet<TString>& GetRequiredColumns() const {\n-        return RequiredColumns;\n-    }\n+    const std::shared_ptr<NArrow::TSchemaLite>& ArrowSchema() const;\n+    const std::shared_ptr<NArrow::TSchemaLite>& ArrowSchemaWithSpecials() const;\n \n     const THashSet<ui32>& GetMinMaxIdxColumns() const {\n         return MinMaxIdxColumnsIds;\n@@ -304,8 +395,12 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n     bool AllowTtlOverColumn(const TString& name) const;\n \n     /// Returns whether the sorting keys defined.\n-    bool IsSorted() const { return true; }\n-    bool IsSortedColumn(const ui32 columnId) const { return GetPKFirstColumnId() == columnId; }\n+    bool IsSorted() const {\n+        return true;\n+    }\n+    bool IsSortedColumn(const ui32 columnId) const {\n+        return GetPKFirstColumnId() == columnId;\n+    }\n \n     ui64 GetVersion() const {\n         return Version;\n@@ -321,18 +416,19 @@ struct TIndexInfo : public NTable::TScheme::TTableSchema, public IIndexInfo {\n     TString Name;\n     std::vector<ui32> SchemaColumnIds;\n     std::vector<ui32> SchemaColumnIdsWithSpecials;\n-    std::vector<ui32> PKColumnIds;\n-    std::shared_ptr<arrow::Schema> Schema;\n-    std::shared_ptr<arrow::Schema> SchemaWithSpecials;\n+    std::shared_ptr<NArrow::TSchemaLite> SchemaWithSpecials;\n+    std::shared_ptr<NArrow::TSchemaLite> Schema;\n     std::shared_ptr<arrow::Schema> PrimaryKey;\n-    THashSet<TString> RequiredColumns;\n     THashSet<ui32> MinMaxIdxColumnsIds;\n     NArrow::NSerialization::TSerializerContainer DefaultSerializer = NArrow::NSerialization::TSerializerContainer::GetDefaultSerializer();\n };\n \n-std::shared_ptr<arrow::Schema> MakeArrowSchema(const NTable::TScheme::TTableSchema::TColumns& columns, const std::vector<ui32>& ids);\n+std::shared_ptr<arrow::Schema> MakeArrowSchema(const NTable::TScheme::TTableSchema::TColumns& columns, const std::vector<ui32>& ids,\n+    const std::shared_ptr<TSchemaObjectsCache>& cache = nullptr);\n+std::vector<std::shared_ptr<arrow::Field>> MakeArrowFields(const NTable::TScheme::TTableSchema::TColumns& columns, const std::vector<ui32>& ids,\n+    const std::shared_ptr<TSchemaObjectsCache>& cache = nullptr);\n \n /// Extracts columns with the specific ids from the schema.\n std::vector<TNameTypeInfo> GetColumns(const NTable::TScheme::TTableSchema& tableSchema, const std::vector<ui32>& ids);\n \n-} // namespace NKikimr::NOlap\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/checker.h b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/checker.h\nindex a67a72df8e2f..88815c374eb2 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/checker.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/checker.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/formats/arrow/protos/ssa.pb.h>\n+#include <ydb/library/formats/arrow/protos/ssa.pb.h>\n #include <ydb/services/bg_tasks/abstract/interface.h>\n #include <ydb/library/accessor/accessor.h>\n #include <library/cpp/object_factory/object_factory.h>\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/program.cpp b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/program.cpp\nindex d16f5fcfb33f..d6a3e9b800e5 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/program.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/program.cpp\n@@ -401,12 +401,15 @@ class TNormalForm {\n public:\n     TNormalForm() = default;\n \n-    bool Add(const NSsa::TAssign& assign) {\n+    bool Add(const NSsa::TAssign& assign, const TProgramContainer& program) {\n         std::vector<std::shared_ptr<IRequestNode>> argNodes;\n         for (auto&& arg : assign.GetArguments()) {\n             if (arg.IsGenerated()) {\n                 auto it = Nodes.find(arg.GetColumnName());\n-                AFL_VERIFY(it != Nodes.end());\n+                if (it == Nodes.end()) {\n+                    AFL_CRIT(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"program_arg_is_missing\")(\"program\", program.DebugString());\n+                    return false;\n+                }\n                 argNodes.emplace_back(it->second);\n             } else {\n                 argNodes.emplace_back(std::make_shared<TOriginalColumn>(arg.GetColumnName()));\n@@ -443,7 +446,7 @@ std::shared_ptr<TDataForIndexesCheckers> TDataForIndexesCheckers::Build(const TP\n     auto fStep = program.GetSteps().front();\n     TNormalForm nForm;\n     for (auto&& s : fStep->GetAssignes()) {\n-        if (!nForm.Add(s)) {\n+        if (!nForm.Add(s, program)) {\n             return nullptr;\n         }\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/ya.make b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/ya.make\nindex e758f9ecc430..a9991e37e26a 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/ya.make\n+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/ya.make\n@@ -11,7 +11,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/formats/arrow\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n )\n \n YQL_LAST_ABI_VERSION()\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/tiering/tier_info.h b/ydb/core/tx/columnshard/engines/scheme/tiering/tier_info.h\nindex c65cb1703ad0..8d290a8adcf2 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/tiering/tier_info.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/tiering/tier_info.h\n@@ -2,7 +2,7 @@\n #include \"common.h\"\n \n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n #include <ydb/core/tx/columnshard/common/scalars.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/util/compression.h>\n@@ -109,7 +109,7 @@ class TTiering {\n     using TTiersMap = THashMap<TString, std::shared_ptr<TTierInfo>>;\n     TTiersMap TierByName;\n     TSet<TTierRef> OrderedTiers;\n-    TString TTLColumnName;\n+    std::optional<TString> TTLColumnName;\n public:\n \n     class TTieringContext {\n@@ -174,9 +174,14 @@ class TTiering {\n     [[nodiscard]] bool Add(const std::shared_ptr<TTierInfo>& tier) {\n         AFL_VERIFY(tier);\n         if (!TTLColumnName) {\n+            if (tier->GetEvictColumnName().Empty()) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"problem\", \"empty_evict_column_name\");\n+                return false;\n+            }\n             TTLColumnName = tier->GetEvictColumnName();\n-        } else if (TTLColumnName != tier->GetEvictColumnName()) {\n-            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"problem\", \"incorrect_tiering_metadata\")(\"column_before\", TTLColumnName)(\"column_new\", tier->GetEvictColumnName());\n+        } else if (*TTLColumnName != tier->GetEvictColumnName()) {\n+            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"problem\", \"incorrect_tiering_metadata\")(\"column_before\", *TTLColumnName)\n+                (\"column_new\", tier->GetEvictColumnName());\n             return false;\n         }\n \n@@ -194,13 +199,9 @@ class TTiering {\n         return {};\n     }\n \n-    const TString& GetTtlColumn() const {\n-        AFL_VERIFY(TTLColumnName);\n-        return TTLColumnName;\n-    }\n-\n     const TString& GetEvictColumnName() const {\n-        return TTLColumnName;\n+        AFL_VERIFY(TTLColumnName);\n+        return *TTLColumnName;\n     }\n \n     TString GetDebugString() const {\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp\nindex d0fd1151d223..8143c27a82ef 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp\n@@ -2,7 +2,7 @@\n \n #include <ydb/core/tx/columnshard/engines/index_info.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n #include <util/string/join.h>\n \n namespace NKikimr::NOlap {\n@@ -35,12 +35,12 @@ TConclusion<std::shared_ptr<NArrow::TGeneralContainer>> ISnapshotSchema::Normali\n             return batch;\n         }\n     }\n-    const std::shared_ptr<arrow::Schema>& resultArrowSchema = GetSchema();\n+    const std::shared_ptr<NArrow::TSchemaLite>& resultArrowSchema = GetSchema();\n \n     std::shared_ptr<NArrow::TGeneralContainer> result = std::make_shared<NArrow::TGeneralContainer>(batch->GetRecordsCount());\n     for (size_t i = 0; i < resultArrowSchema->fields().size(); ++i) {\n         auto& resultField = resultArrowSchema->fields()[i];\n-        auto columnId = GetIndexInfo().GetColumnId(resultField->name());\n+        auto columnId = GetIndexInfo().GetColumnIdVerified(resultField->name());\n         auto oldField = dataSchema.GetFieldByColumnIdOptional(columnId);\n         if (oldField) {\n             auto fAccessor = batch->GetAccessorByNameOptional(oldField->name());\n@@ -55,9 +55,7 @@ TConclusion<std::shared_ptr<NArrow::TGeneralContainer>> ISnapshotSchema::Normali\n         if (restoreColumnIds.contains(columnId)) {\n             AFL_VERIFY(!!GetExternalDefaultValueVerified(columnId) || GetIndexInfo().IsNullableVerified(columnId))(\"column_name\",\n                                                                           GetIndexInfo().GetColumnName(columnId, false))(\"id\", columnId);\n-            result->AddField(resultField,\n-                    NArrow::TThreadSimpleArraysCache::Get(resultField->type(), GetExternalDefaultValueVerified(columnId), batch->num_rows()))\n-                .Validate();\n+            result->AddField(resultField, GetColumnLoaderVerified(columnId)->BuildDefaultAccessor(batch->num_rows())).Validate();\n         }\n     }\n     return result;\n@@ -80,16 +78,18 @@ TConclusion<std::shared_ptr<arrow::RecordBatch>> ISnapshotSchema::PrepareForModi\n         return TConclusionStatus::Fail(\"not valid incoming batch: \" + status.ToString());\n     }\n \n-    const std::shared_ptr<arrow::Schema> dstSchema = GetIndexInfo().ArrowSchema();\n+    const std::shared_ptr<NArrow::TSchemaLite> dstSchema = GetIndexInfo().ArrowSchema();\n \n-    auto batch = NArrow::TColumnOperator().SkipIfAbsent().Extract(incomingBatch, dstSchema->field_names());\n+    auto batch = NArrow::TColumnOperator().SkipIfAbsent().Extract(incomingBatch, dstSchema->fields());\n \n     for (auto&& i : batch->schema()->fields()) {\n-        AFL_VERIFY(GetIndexInfo().HasColumnName(i->name()));\n-        if (!dstSchema->GetFieldByName(i->name())->Equals(i)) {\n-            return TConclusionStatus::Fail(\"not equal field types for column '\" + i->name() + \"'\");\n+        const ui32 columnId = GetIndexInfo().GetColumnIdVerified(i->name());\n+        auto fSchema = GetIndexInfo().GetColumnFieldVerified(columnId);\n+        if (!fSchema->Equals(i)) {\n+            return TConclusionStatus::Fail(\n+                \"not equal field types for column '\" + i->name() + \"': \" + i->ToString() + \" vs \" + fSchema->ToString());\n         }\n-        if (GetIndexInfo().IsNullableVerified(i->name())) {\n+        if (GetIndexInfo().IsNullableVerified(columnId)) {\n             continue;\n         }\n         if (NArrow::HasNulls(batch->GetColumnByName(i->name()))) {\n@@ -118,18 +118,19 @@ TConclusion<std::shared_ptr<arrow::RecordBatch>> ISnapshotSchema::PrepareForModi\n     switch (mType) {\n         case NEvWrite::EModificationType::Replace:\n         case NEvWrite::EModificationType::Upsert: {\n-                AFL_VERIFY(batch->num_columns() <= dstSchema->num_fields());\n+            AFL_VERIFY(batch->num_columns() <= dstSchema->num_fields());\n             if (batch->num_columns() < dstSchema->num_fields()) {\n-                for (auto&& f : dstSchema->fields()) {\n-                    if (GetIndexInfo().IsNullableVerified(f->name())) {\n+                for (ui32 idx = 0; idx < (ui32)dstSchema->num_fields(); ++idx) {\n+                    if (GetIndexInfo().IsNullableVerifiedByIndex(idx)) {\n                         continue;\n                     }\n-                    if (batch->GetColumnByName(f->name())) {\n+                    if (GetIndexInfo().GetColumnExternalDefaultValueByIndexVerified(idx)) {\n                         continue;\n                     }\n-                    if (!GetIndexInfo().GetColumnExternalDefaultValueVerified(f->name())) {\n-                        return TConclusionStatus::Fail(\"empty field for non-default column: '\" + f->name() + \"'\");\n+                    if (batch->GetColumnByName(dstSchema->field(idx)->name())) {\n+                        continue;\n                     }\n+                    return TConclusionStatus::Fail(\"empty field for non-default column: '\" + dstSchema->field(idx)->name() + \"'\");\n                 }\n             }\n             return batch;\n@@ -141,6 +142,22 @@ TConclusion<std::shared_ptr<arrow::RecordBatch>> ISnapshotSchema::PrepareForModi\n     }\n }\n \n+void ISnapshotSchema::AdaptBatchToSchema(NArrow::TGeneralContainer& batch, const ISnapshotSchema::TPtr& targetSchema) const {\n+    if (targetSchema->GetVersion() != GetVersion()) {\n+        std::vector<ui32> columnIdxToDelete;\n+        for (size_t columnIdx = 0; columnIdx < batch.GetSchema()->GetFields().size(); ++columnIdx) {\n+            const std::optional<ui32> targetColumnId = targetSchema->GetColumnIdOptional(batch.GetSchema()->field(columnIdx)->name());\n+            const ui32 batchColumnId = GetColumnIdVerified(GetFieldByIndex(columnIdx)->name());\n+            if (!targetColumnId || *targetColumnId != batchColumnId) {\n+                columnIdxToDelete.emplace_back(columnIdx);\n+            }\n+        }\n+        if (!columnIdxToDelete.empty()) {\n+            batch.DeleteFieldsByIndex(columnIdxToDelete);\n+        }\n+    }\n+}\n+\n ui32 ISnapshotSchema::GetColumnId(const std::string& columnName) const {\n     auto id = GetColumnIdOptional(columnName);\n     AFL_VERIFY(id)(\"column_name\", columnName)(\"schema\", JoinSeq(\",\", GetSchema()->field_names()));\n@@ -153,19 +170,19 @@ std::shared_ptr<arrow::Field> ISnapshotSchema::GetFieldByColumnIdVerified(const\n     return result;\n }\n \n-std::shared_ptr<NKikimr::NOlap::TColumnLoader> ISnapshotSchema::GetColumnLoaderVerified(const ui32 columnId) const {\n+std::shared_ptr<NArrow::NAccessor::TColumnLoader> ISnapshotSchema::GetColumnLoaderVerified(const ui32 columnId) const {\n     auto result = GetColumnLoaderOptional(columnId);\n     AFL_VERIFY(result);\n     return result;\n }\n \n-std::shared_ptr<NKikimr::NOlap::TColumnLoader> ISnapshotSchema::GetColumnLoaderVerified(const std::string& columnName) const {\n+std::shared_ptr<NArrow::NAccessor::TColumnLoader> ISnapshotSchema::GetColumnLoaderVerified(const std::string& columnName) const {\n     auto result = GetColumnLoaderOptional(columnName);\n     AFL_VERIFY(result);\n     return result;\n }\n \n-std::shared_ptr<NKikimr::NOlap::TColumnLoader> ISnapshotSchema::GetColumnLoaderOptional(const std::string& columnName) const {\n+std::shared_ptr<NArrow::NAccessor::TColumnLoader> ISnapshotSchema::GetColumnLoaderOptional(const std::string& columnName) const {\n     const std::optional<ui32> id = GetColumnIdOptional(columnName);\n     if (id) {\n         return GetColumnLoaderOptional(*id);\n@@ -190,8 +207,9 @@ std::vector<std::shared_ptr<arrow::Field>> ISnapshotSchema::GetAbsentFields(cons\n \n TConclusionStatus ISnapshotSchema::CheckColumnsDefault(const std::vector<std::shared_ptr<arrow::Field>>& fields) const {\n     for (auto&& i : fields) {\n-        auto defaultValue = GetExternalDefaultValueVerified(i->name());\n-        if (!defaultValue && !GetIndexInfo().IsNullableVerified(i->name())) {\n+        const ui32 colId = GetColumnIdVerified(i->name());\n+        auto defaultValue = GetExternalDefaultValueVerified(colId);\n+        if (!defaultValue && !GetIndexInfo().IsNullableVerified(colId)) {\n             return TConclusionStatus::Fail(\"not nullable field with no default: \" + i->name());\n         }\n     }\n@@ -202,8 +220,9 @@ TConclusion<std::shared_ptr<arrow::RecordBatch>> ISnapshotSchema::BuildDefaultBa\n     const std::vector<std::shared_ptr<arrow::Field>>& fields, const ui32 rowsCount, const bool force) const {\n     std::vector<std::shared_ptr<arrow::Array>> columns;\n     for (auto&& i : fields) {\n-        auto defaultValue = GetExternalDefaultValueVerified(i->name());\n-        if (!defaultValue && !GetIndexInfo().IsNullableVerified(i->name())) {\n+        const ui32 columnId = GetColumnIdVerified(i->name());\n+        auto defaultValue = GetExternalDefaultValueVerified(columnId);\n+        if (!defaultValue && !GetIndexInfo().IsNullableVerified(columnId)) {\n             if (force) {\n                 defaultValue = NArrow::DefaultScalar(i->type());\n             } else {\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h\nindex a2a4cefd9215..962989d75fb2 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h\n@@ -1,8 +1,8 @@\n #pragma once\n #include <ydb/core/formats/arrow/common/container.h>\n \n-#include <ydb/core/tx/columnshard/engines/scheme/abstract/saver.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/abstract/loader.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n+#include <ydb/core/formats/arrow/save_load/loader.h>\n #include <ydb/core/tx/data_events/common/modification_type.h>\n \n #include <ydb/core/tx/columnshard/common/snapshot.h>\n@@ -21,18 +21,19 @@ class ISnapshotSchema {\n     using TPtr = std::shared_ptr<ISnapshotSchema>;\n \n     virtual ~ISnapshotSchema() {}\n-    virtual std::shared_ptr<TColumnLoader> GetColumnLoaderOptional(const ui32 columnId) const = 0;\n-    std::shared_ptr<TColumnLoader> GetColumnLoaderVerified(const ui32 columnId) const;\n-    std::shared_ptr<TColumnLoader> GetColumnLoaderOptional(const std::string& columnName) const;\n-    std::shared_ptr<TColumnLoader> GetColumnLoaderVerified(const std::string& columnName) const;\n+    virtual std::shared_ptr<NArrow::NAccessor::TColumnLoader> GetColumnLoaderOptional(const ui32 columnId) const = 0;\n+    std::shared_ptr<NArrow::NAccessor::TColumnLoader> GetColumnLoaderVerified(const ui32 columnId) const;\n+    std::shared_ptr<NArrow::NAccessor::TColumnLoader> GetColumnLoaderOptional(const std::string& columnName) const;\n+    std::shared_ptr<NArrow::NAccessor::TColumnLoader> GetColumnLoaderVerified(const std::string& columnName) const;\n \n     bool IsSpecialColumnId(const ui32 columnId) const;\n+    virtual const std::vector<ui32>& GetColumnIds() const = 0;\n \n-    virtual TColumnSaver GetColumnSaver(const ui32 columnId) const = 0;\n-    TColumnSaver GetColumnSaver(const TString& columnName) const {\n+    virtual NArrow::NAccessor::TColumnSaver GetColumnSaver(const ui32 columnId) const = 0;\n+    NArrow::NAccessor::TColumnSaver GetColumnSaver(const TString& columnName) const {\n         return GetColumnSaver(GetColumnId(columnName));\n     }\n-    TColumnSaver GetColumnSaver(const std::string& columnName) const {\n+    NArrow::NAccessor::TColumnSaver GetColumnSaver(const std::string& columnName) const {\n         return GetColumnSaver(TString(columnName.data(), columnName.size()));\n     }\n \n@@ -48,6 +49,7 @@ class ISnapshotSchema {\n     std::vector<std::string> GetPKColumnNames() const;\n \n     virtual std::optional<ui32> GetColumnIdOptional(const std::string& columnName) const = 0;\n+    virtual ui32 GetColumnIdVerified(const std::string& columnName) const = 0;\n     virtual int GetFieldIndex(const ui32 columnId) const = 0;\n     bool HasColumnId(const ui32 columnId) const {\n         return GetFieldIndex(columnId) >= 0;\n@@ -61,7 +63,7 @@ class ISnapshotSchema {\n     TString DebugString() const {\n         return DoDebugString();\n     }\n-    virtual const std::shared_ptr<arrow::Schema>& GetSchema() const = 0;\n+    virtual const std::shared_ptr<NArrow::TSchemaLite>& GetSchema() const = 0;\n     virtual const TIndexInfo& GetIndexInfo() const = 0;\n     virtual const TSnapshot& GetSnapshot() const = 0;\n     virtual ui64 GetVersion() const = 0;\n@@ -75,6 +77,7 @@ class ISnapshotSchema {\n         const ISnapshotSchema& dataSchema, const std::shared_ptr<NArrow::TGeneralContainer>& batch, const std::set<ui32>& restoreColumnIds) const;\n     [[nodiscard]] TConclusion<std::shared_ptr<arrow::RecordBatch>> PrepareForModification(\n         const std::shared_ptr<arrow::RecordBatch>& incomingBatch, const NEvWrite::EModificationType mType) const;\n+    void AdaptBatchToSchema(NArrow::TGeneralContainer& batch, const ISnapshotSchema::TPtr& targetSchema) const;\n };\n \n } // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.cpp b/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.cpp\nindex 8832e7eb0ec8..a371806b2349 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.cpp\n@@ -4,66 +4,58 @@\n \n namespace NKikimr::NOlap {\n \n-TFilteredSnapshotSchema::TFilteredSnapshotSchema(ISnapshotSchema::TPtr originalSnapshot, const std::vector<ui32>& columnIds)\n-    : TFilteredSnapshotSchema(originalSnapshot, std::set(columnIds.begin(), columnIds.end()))\n-{}\n+TFilteredSnapshotSchema::TFilteredSnapshotSchema(const ISnapshotSchema::TPtr& originalSnapshot, const std::set<ui32>& columnIds)\n+    : TFilteredSnapshotSchema(originalSnapshot, std::vector(columnIds.begin(), columnIds.end())) {\n+}\n \n-TFilteredSnapshotSchema::TFilteredSnapshotSchema(ISnapshotSchema::TPtr originalSnapshot, const std::set<ui32>& columnIds)\n+TFilteredSnapshotSchema::TFilteredSnapshotSchema(const ISnapshotSchema::TPtr& originalSnapshot, const std::vector<ui32>& columnIds)\n     : OriginalSnapshot(originalSnapshot)\n     , ColumnIds(columnIds)\n {\n     std::vector<std::shared_ptr<arrow::Field>> schemaFields;\n-    for (auto&& i : OriginalSnapshot->GetSchema()->fields()) {\n-        if (!ColumnIds.contains(OriginalSnapshot->GetIndexInfo().GetColumnId(i->name()))) {\n-            continue;\n-        }\n-        schemaFields.emplace_back(i);\n-    }\n-    Schema = std::make_shared<arrow::Schema>(schemaFields);\n-}\n-\n-TFilteredSnapshotSchema::TFilteredSnapshotSchema(ISnapshotSchema::TPtr originalSnapshot, const std::set<std::string>& columnNames)\n-    : OriginalSnapshot(originalSnapshot) {\n-    for (auto&& i : columnNames) {\n-        ColumnIds.emplace(OriginalSnapshot->GetColumnId(i));\n-    }\n-    std::vector<std::shared_ptr<arrow::Field>> schemaFields;\n-    for (auto&& i : OriginalSnapshot->GetSchema()->fields()) {\n-        if (!columnNames.contains(i->name())) {\n-            continue;\n-        }\n-        schemaFields.emplace_back(i);\n+    for (auto&& i : columnIds) {\n+        IdIntoIndex.emplace(i, schemaFields.size());\n+        schemaFields.emplace_back(originalSnapshot->GetFieldByColumnIdVerified(i));\n     }\n-    Schema = std::make_shared<arrow::Schema>(schemaFields);\n+    Schema = std::make_shared<NArrow::TSchemaLite>(schemaFields);\n }\n \n TColumnSaver TFilteredSnapshotSchema::GetColumnSaver(const ui32 columnId) const {\n-    Y_ABORT_UNLESS(ColumnIds.contains(columnId));\n+    AFL_VERIFY(IdIntoIndex.contains(columnId));\n     return OriginalSnapshot->GetColumnSaver(columnId);\n }\n \n std::shared_ptr<TColumnLoader> TFilteredSnapshotSchema::GetColumnLoaderOptional(const ui32 columnId) const {\n-    Y_ABORT_UNLESS(ColumnIds.contains(columnId));\n+    AFL_VERIFY(IdIntoIndex.contains(columnId));\n     return OriginalSnapshot->GetColumnLoaderOptional(columnId);\n }\n \n std::optional<ui32> TFilteredSnapshotSchema::GetColumnIdOptional(const std::string& columnName) const {\n-    return OriginalSnapshot->GetColumnIdOptional(columnName);\n+    auto result = OriginalSnapshot->GetColumnIdOptional(columnName);\n+    if (!result) {\n+        return result;\n+    }\n+    if (!IdIntoIndex.contains(*result)) {\n+        return std::nullopt;\n+    }\n+    return result;\n+}\n+\n+ui32 TFilteredSnapshotSchema::GetColumnIdVerified(const std::string& columnName) const {\n+    auto result = OriginalSnapshot->GetColumnIdVerified(columnName);\n+    AFL_VERIFY(IdIntoIndex.contains(result));\n+    return result;\n }\n \n int TFilteredSnapshotSchema::GetFieldIndex(const ui32 columnId) const {\n-    if (!ColumnIds.contains(columnId)) {\n-        return -1;\n-    }\n-    TString columnName = OriginalSnapshot->GetIndexInfo().GetColumnName(columnId, false);\n-    if (!columnName) {\n+    auto it = IdIntoIndex.find(columnId);\n+    if (it == IdIntoIndex.end()) {\n         return -1;\n     }\n-    std::string name(columnName.data(), columnName.size());\n-    return Schema->GetFieldIndex(name);\n+    return it->second;\n }\n \n-const std::shared_ptr<arrow::Schema>& TFilteredSnapshotSchema::GetSchema() const {\n+const std::shared_ptr<NArrow::TSchemaLite>& TFilteredSnapshotSchema::GetSchema() const {\n     return Schema;\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.h b/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.h\nindex 1b515d5bb9cf..8fc82ee6a304 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/filtered_scheme.h\n@@ -8,21 +8,26 @@ namespace NKikimr::NOlap {\n \n class TFilteredSnapshotSchema: public ISnapshotSchema {\n     ISnapshotSchema::TPtr OriginalSnapshot;\n-    std::shared_ptr<arrow::Schema> Schema;\n-    YDB_READONLY_DEF(std::set<ui32>, ColumnIds);\n+    std::shared_ptr<NArrow::TSchemaLite> Schema;\n+    std::vector<ui32> ColumnIds;\n+    THashMap<ui32, ui32> IdIntoIndex;\n+\n protected:\n     virtual TString DoDebugString() const override;\n public:\n-    TFilteredSnapshotSchema(ISnapshotSchema::TPtr originalSnapshot, const std::vector<ui32>& columnIds);\n-    TFilteredSnapshotSchema(ISnapshotSchema::TPtr originalSnapshot, const std::set<ui32>& columnIds);\n-    TFilteredSnapshotSchema(ISnapshotSchema::TPtr originalSnapshot, const std::set<std::string>& columnNames);\n+    TFilteredSnapshotSchema(const ISnapshotSchema::TPtr& originalSnapshot, const std::vector<ui32>& columnIds);\n+    TFilteredSnapshotSchema(const ISnapshotSchema::TPtr& originalSnapshot, const std::set<ui32>& columnIds);\n \n+    virtual const std::vector<ui32>& GetColumnIds() const override {\n+        return ColumnIds;\n+    }\n     TColumnSaver GetColumnSaver(const ui32 columnId) const override;\n     std::shared_ptr<TColumnLoader> GetColumnLoaderOptional(const ui32 columnId) const override;\n     std::optional<ui32> GetColumnIdOptional(const std::string& columnName) const override;\n+    ui32 GetColumnIdVerified(const std::string& columnName) const override;\n     int GetFieldIndex(const ui32 columnId) const override;\n \n-    const std::shared_ptr<arrow::Schema>& GetSchema() const override;\n+    const std::shared_ptr<NArrow::TSchemaLite>& GetSchema() const override;\n     const TIndexInfo& GetIndexInfo() const override;\n     const TSnapshot& GetSnapshot() const override;\n     ui32 GetColumnsCount() const override;\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.cpp b/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.cpp\nindex 1fe6820cf547..05277b7b8967 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.cpp\n@@ -21,16 +21,15 @@ std::optional<ui32> TSnapshotSchema::GetColumnIdOptional(const std::string& colu\n     return IndexInfo.GetColumnIdOptional(columnName);\n }\n \n+ui32 TSnapshotSchema::GetColumnIdVerified(const std::string& columnName) const {\n+    return IndexInfo.GetColumnIdVerified(columnName);\n+}\n+\n int TSnapshotSchema::GetFieldIndex(const ui32 columnId) const {\n-    const TString& columnName = IndexInfo.GetColumnName(columnId, false);\n-    if (!columnName) {\n-        return -1;\n-    }\n-    std::string name(columnName.data(), columnName.size());\n-    return Schema->GetFieldIndex(name);\n+    return IndexInfo.GetColumnIndexOptional(columnId).value_or(-1);\n }\n \n-const std::shared_ptr<arrow::Schema>& TSnapshotSchema::GetSchema() const {\n+const std::shared_ptr<NArrow::TSchemaLite>& TSnapshotSchema::GetSchema() const {\n     return Schema;\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.h b/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.h\nindex 539d8f99a02c..5fa3c4ef7551 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/snapshot_scheme.h\n@@ -9,7 +9,7 @@ namespace NKikimr::NOlap {\n class TSnapshotSchema: public ISnapshotSchema {\n private:\n     TIndexInfo IndexInfo;\n-    std::shared_ptr<arrow::Schema> Schema;\n+    std::shared_ptr<NArrow::TSchemaLite> Schema;\n     TSnapshot Snapshot;\n protected:\n     virtual TString DoDebugString() const override {\n@@ -23,12 +23,17 @@ class TSnapshotSchema: public ISnapshotSchema {\n public:\n     TSnapshotSchema(TIndexInfo&& indexInfo, const TSnapshot& snapshot);\n \n+    virtual const std::vector<ui32>& GetColumnIds() const override {\n+        return IndexInfo.GetColumnIds();\n+    }\n+\n     TColumnSaver GetColumnSaver(const ui32 columnId) const override;\n     std::shared_ptr<TColumnLoader> GetColumnLoaderOptional(const ui32 columnId) const override;\n     std::optional<ui32> GetColumnIdOptional(const std::string& columnName) const override;\n+    ui32 GetColumnIdVerified(const std::string& columnName) const override;\n     int GetFieldIndex(const ui32 columnId) const override;\n \n-    const std::shared_ptr<arrow::Schema>& GetSchema() const override;\n+    const std::shared_ptr<NArrow::TSchemaLite>& GetSchema() const override;\n     const TIndexInfo& GetIndexInfo() const override;\n     const TSnapshot& GetSnapshot() const override;\n     ui32 GetColumnsCount() const override;\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h b/ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h\nindex 70cf8830b051..fe554a790d8f 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h\n@@ -91,7 +91,7 @@ class TVersionedIndex {\n             }\n         }\n         Y_ABORT_UNLESS(!Snapshots.empty());\n-        Y_ABORT_UNLESS(version.IsZero());\n+//        Y_ABORT_UNLESS(version.IsZero());\n         return Snapshots.begin()->second;\n     }\n \ndiff --git a/ydb/core/tx/columnshard/engines/scheme/ya.make b/ydb/core/tx/columnshard/engines/scheme/ya.make\nindex 8e41573bf419..744458ff4dcb 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/ya.make\n+++ b/ydb/core/tx/columnshard/engines/scheme/ya.make\n@@ -20,6 +20,7 @@ PEERDIR(\n     ydb/core/tx/columnshard/engines/scheme/tiering\n     ydb/core/tx/columnshard/engines/scheme/column\n     ydb/core/tx/columnshard/engines/scheme/defaults\n+    ydb/core/formats/arrow/accessor\n     ydb/core/tx/columnshard/blobs_action/abstract\n )\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/scheme/counters.h b/ydb/core/tx/columnshard/engines/storage/actualizer/scheme/counters.h\nindex 8f5ab2ff4311..95aa18603f46 100644\n--- a/ydb/core/tx/columnshard/engines/storage/actualizer/scheme/counters.h\n+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/scheme/counters.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h>\n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/core/tx/columnshard/splitter/settings.h>\n #include <ydb/core/tx/columnshard/counters/engine_logs.h>\ndiff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/counters.h b/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/counters.h\nindex 7d7a1cc3d830..a5c278799fdd 100644\n--- a/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/counters.h\n+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/counters.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h>\n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/core/tx/columnshard/splitter/settings.h>\n #include <ydb/core/tx/columnshard/counters/engine_logs.h>\ndiff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/tiering.cpp b/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/tiering.cpp\nindex 87fecc13e472..55882102eee9 100644\n--- a/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/tiering.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/tiering/tiering.cpp\n@@ -174,7 +174,7 @@ void TTieringActualizer::DoExtractTasks(TTieringProcessContext& tasksContext, co\n void TTieringActualizer::Refresh(const std::optional<TTiering>& info, const TAddExternalContext& externalContext) {\n     Tiering = info;\n     if (Tiering) {\n-        TieringColumnId = VersionedIndex.GetLastSchema()->GetColumnId(Tiering->GetTtlColumn());\n+        TieringColumnId = VersionedIndex.GetLastSchema()->GetColumnId(Tiering->GetEvictColumnName());\n     } else {\n         TieringColumnId = {};\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/column.cpp b/ydb/core/tx/columnshard/engines/storage/chunks/column.cpp\nindex 485802b0e3c1..4a527f913fc7 100644\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/column.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/chunks/column.cpp\n@@ -1,18 +1,20 @@\n #include \"column.h\"\n-#include <ydb/core/tx/columnshard/splitter/simple.h>\n+#include <ydb/core/formats/arrow/splitter/simple.h>\n \n namespace NKikimr::NOlap::NChunks {\n \n-std::vector<std::shared_ptr<IPortionDataChunk>> TChunkPreparation::DoInternalSplitImpl(const TColumnSaver& saver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const {\n-    auto rb = NArrow::TStatusValidator::GetValid(ColumnInfo.GetLoader()->Apply(Data));\n+std::vector<std::shared_ptr<IPortionDataChunk>> TChunkPreparation::DoInternalSplitImpl(\n+    const TColumnSaver& saver, const std::shared_ptr<NColumnShard::TSplitterCounters>& /*counters*/, const std::vector<ui64>& splitSizes) const {\n+    auto accessor = ColumnInfo.GetLoader()->ApplyVerified(Data, GetRecordsCountVerified());\n+    std::vector<NArrow::NAccessor::TChunkedArraySerialized> chunks = accessor->SplitBySizes(saver, Data, splitSizes);\n \n-    auto chunks = TSimpleSplitter(saver, counters).SplitBySizes(rb, Data, splitSizes);\n     std::vector<std::shared_ptr<IPortionDataChunk>> newChunks;\n     for (auto&& i : chunks) {\n-        Y_ABORT_UNLESS(i.GetSlicedBatch()->num_columns() == 1);\n-        newChunks.emplace_back(std::make_shared<TChunkPreparation>(saver.Apply(i.GetSlicedBatch()), i.GetSlicedBatch()->column(0), TChunkAddress(GetColumnId(), GetChunkIdxOptional().value_or(0)), ColumnInfo));\n+        newChunks.emplace_back(std::make_shared<TChunkPreparation>(\n+            i.GetSerializedData(), i.GetArray(), TChunkAddress(GetColumnId(), GetChunkIdxOptional().value_or(0)), ColumnInfo));\n     }\n+\n     return newChunks;\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NChunks\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/column.h b/ydb/core/tx/columnshard/engines/storage/chunks/column.h\nindex a8c4be1ae3de..9de818c49fb6 100644\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/column.h\n+++ b/ydb/core/tx/columnshard/engines/storage/chunks/column.h\n@@ -56,14 +56,14 @@ class TChunkPreparation: public IPortionColumnChunk {\n         AFL_VERIFY(Data.size() == Record.BlobRange.Size || Record.BlobRange.Size == 0)(\"data\", Data.size())(\"record\", Record.BlobRange.Size);\n     }\n \n-    TChunkPreparation(const TString& data, const std::shared_ptr<arrow::Array>& column, const TChunkAddress& address, const TSimpleColumnInfo& columnInfo)\n+    TChunkPreparation(const TString& data, const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const TChunkAddress& address, const TSimpleColumnInfo& columnInfo)\n         : TBase(address.GetColumnId())\n         , Data(data)\n         , Record(address, column, columnInfo)\n         , ColumnInfo(columnInfo) {\n-        Y_ABORT_UNLESS(column->length());\n-        First = NArrow::TStatusValidator::GetValid(column->GetScalar(0));\n-        Last = NArrow::TStatusValidator::GetValid(column->GetScalar(column->length() - 1));\n+        Y_ABORT_UNLESS(column->GetRecordsCount());\n+        First = column->GetScalar(0);\n+        Last = column->GetScalar(column->GetRecordsCount() - 1);\n         Record.BlobRange.Size = data.size();\n     }\n };\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/data.cpp b/ydb/core/tx/columnshard/engines/storage/chunks/data.cpp\nindex 79613b5b9798..007dff83e914 100644\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/data.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/chunks/data.cpp\n@@ -9,4 +9,13 @@ void TPortionIndexChunk::DoAddIntoPortionBeforeBlob(const TBlobRangeLink16& bRan\n     portionInfo.AddIndex(TIndexChunk(GetEntityId(), GetChunkIdxVerified(), RecordsCount, RawBytes, bRange));\n }\n \n+std::shared_ptr<IPortionDataChunk> TPortionIndexChunk::DoCopyWithAnotherBlob(\n+    TString&& data, const TSimpleColumnInfo& /*columnInfo*/) const {\n+    return std::make_shared<TPortionIndexChunk>(GetChunkAddressVerified(), RecordsCount, RawBytes, std::move(data));\n+}\n+\n+void TPortionIndexChunk::DoAddInplaceIntoPortion(TPortionInfoConstructor& portionInfo) const {\n+    portionInfo.AddIndex(TIndexChunk(GetEntityId(), GetChunkIdxVerified(), RecordsCount, RawBytes, GetData()));\n+}\n+\n }   // namespace NKikimr::NOlap::NIndexes\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/data.h b/ydb/core/tx/columnshard/engines/storage/chunks/data.h\nindex 8409243df347..e3f22ae2ed9d 100644\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/data.h\n+++ b/ydb/core/tx/columnshard/engines/storage/chunks/data.h\n@@ -36,9 +36,9 @@ class TPortionIndexChunk: public IPortionDataChunk {\n         return nullptr;\n     }\n     virtual void DoAddIntoPortionBeforeBlob(const TBlobRangeLink16& bRange, TPortionInfoConstructor& portionInfo) const override;\n-    virtual std::shared_ptr<IPortionDataChunk> DoCopyWithAnotherBlob(TString&& data, const TSimpleColumnInfo& /*columnInfo*/) const override {\n-        return std::make_shared<TPortionIndexChunk>(GetChunkAddressVerified(), RecordsCount, RawBytes, std::move(data));\n-    }\n+    virtual std::shared_ptr<IPortionDataChunk> DoCopyWithAnotherBlob(TString&& data, const TSimpleColumnInfo& /*columnInfo*/) const override;\n+    virtual void DoAddInplaceIntoPortion(TPortionInfoConstructor& portionInfo) const override;\n+\n public:\n     TPortionIndexChunk(const TChunkAddress& address, const ui32 recordsCount, const ui64 rawBytes, const TString& data)\n         : TBase(address.GetColumnId(), address.GetChunkIdx())\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/null_column.cpp b/ydb/core/tx/columnshard/engines/storage/chunks/null_column.cpp\ndeleted file mode 100644\nindex 9aa56e56eda3..000000000000\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/null_column.cpp\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-#include \"null_column.h\"\n-\n-namespace NKikimr::NOlap::NChunks {\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/null_column.h b/ydb/core/tx/columnshard/engines/storage/chunks/null_column.h\ndeleted file mode 100644\nindex 3b2420f0c223..000000000000\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/null_column.h\n+++ /dev/null\n@@ -1,60 +0,0 @@\n-#pragma once\n-#include <ydb/core/tx/columnshard/splitter/chunks.h>\n-#include <ydb/core/tx/columnshard/counters/splitter.h>\n-#include <ydb/core/tx/columnshard/splitter/abstract/chunk_meta.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n-\n-namespace NKikimr::NOlap::NChunks {\n-\n-class TDefaultChunkPreparation: public IPortionColumnChunk {\n-private:\n-    using TBase = IPortionColumnChunk;\n-    const std::shared_ptr<arrow::Scalar> DefaultValue;\n-    const ui32 RecordsCount;\n-    ui64 RawBytes = 0;\n-    TString Data;\n-protected:\n-    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplitImpl(const TColumnSaver& /*saver*/, const std::shared_ptr<NColumnShard::TSplitterCounters>& /*counters*/,\n-                                                                                const std::vector<ui64>& /*splitSizes*/) const override {\n-        AFL_VERIFY(false);\n-        return {};\n-    }\n-    virtual const TString& DoGetData() const override {\n-        return Data;\n-    }\n-    virtual ui32 DoGetRecordsCountImpl() const override {\n-        return RecordsCount;\n-    }\n-    virtual ui64 DoGetRawBytesImpl() const override {\n-        return RawBytes;\n-    }\n-    virtual TString DoDebugString() const override {\n-        return TStringBuilder() << \"rc=\" << RecordsCount << \";data_size=\" << Data.size() << \";\";\n-    }\n-    virtual TSimpleChunkMeta DoBuildSimpleChunkMeta() const override {\n-        AFL_VERIFY(false);\n-        return TSimpleChunkMeta(nullptr, false, false);\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetFirstScalar() const override {\n-        return DefaultValue;\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetLastScalar() const override {\n-        return DefaultValue;\n-    }\n-\n-public:\n-    TDefaultChunkPreparation(const ui32 columnId, const ui32 recordsCount, const std::shared_ptr<arrow::Field>& f, \n-        const std::shared_ptr<arrow::Scalar>& defaultValue, const TColumnSaver& saver)\n-        : TBase(columnId)\n-        , DefaultValue(defaultValue)\n-        , RecordsCount(recordsCount)\n-    {\n-        Y_ABORT_UNLESS(RecordsCount);\n-        auto arrowData = NArrow::TThreadSimpleArraysCache::Get(f->type(), defaultValue, RecordsCount);\n-        RawBytes = NArrow::GetArrayDataSize(arrowData);\n-        Data = saver.Apply(arrowData, f);\n-        SetChunkIdx(0);\n-    }\n-};\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/engines/storage/chunks/ya.make b/ydb/core/tx/columnshard/engines/storage/chunks/ya.make\nindex d61554bd6f0c..cff5b9f40b53 100644\n--- a/ydb/core/tx/columnshard/engines/storage/chunks/ya.make\n+++ b/ydb/core/tx/columnshard/engines/storage/chunks/ya.make\n@@ -3,7 +3,6 @@ LIBRARY()\n SRCS(\n     data.cpp\n     column.cpp\n-    null_column.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/core/tx/columnshard/engines/storage/granule/granule.cpp b/ydb/core/tx/columnshard/engines/storage/granule/granule.cpp\nindex d38851486e3d..ebb2b9acde63 100644\n--- a/ydb/core/tx/columnshard/engines/storage/granule/granule.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/granule/granule.cpp\n@@ -47,10 +47,9 @@ bool TGranuleMeta::ErasePortion(const ui64 portion) {\n \n void TGranuleMeta::OnAfterChangePortion(const std::shared_ptr<TPortionInfo> portionAfter, NStorageOptimizer::IOptimizerPlanner::TModificationGuard* modificationGuard) {\n     if (portionAfter) {\n-        PortionsIndex.AddPortion(portionAfter);\n-\n         PortionInfoGuard.OnNewPortion(portionAfter);\n         if (!portionAfter->HasRemoveSnapshot()) {\n+            PortionsIndex.AddPortion(portionAfter);\n             if (modificationGuard) {\n                 modificationGuard->AddPortion(portionAfter);\n             } else {\n@@ -74,10 +73,9 @@ void TGranuleMeta::OnAfterChangePortion(const std::shared_ptr<TPortionInfo> port\n \n void TGranuleMeta::OnBeforeChangePortion(const std::shared_ptr<TPortionInfo> portionBefore) {\n     if (portionBefore) {\n-        PortionsIndex.RemovePortion(portionBefore);\n-\n         PortionInfoGuard.OnDropPortion(portionBefore);\n         if (!portionBefore->HasRemoveSnapshot()) {\n+            PortionsIndex.RemovePortion(portionBefore);\n             OptimizerPlanner->StartModificationGuard().RemovePortion(portionBefore);\n             ActualizationIndex->RemovePortion(portionBefore);\n         }\n@@ -138,8 +136,7 @@ TGranuleMeta::TGranuleMeta(const ui64 pathId, const TGranulesStorage& owner, con\n     , PortionInfoGuard(owner.GetCounters().BuildPortionBlobsGuard())\n     , Stats(owner.GetStats())\n     , StoragesManager(owner.GetStoragesManager())\n-    , PortionsIndex(*this)\n-{\n+    , PortionsIndex(*this, Counters.GetPortionsIndexCounters()) {\n     NStorageOptimizer::IOptimizerPlannerConstructor::TBuildContext context(PathId, owner.GetStoragesManager(), versionedIndex.GetLastSchema()->GetIndexInfo().GetPrimaryKey());\n     OptimizerPlanner = versionedIndex.GetLastSchema()->GetIndexInfo().GetCompactionPlannerConstructor()->BuildPlanner(context).DetachResult();\n     AFL_VERIFY(!!OptimizerPlanner);\ndiff --git a/ydb/core/tx/columnshard/engines/storage/granule/granule.h b/ydb/core/tx/columnshard/engines/storage/granule/granule.h\nindex c8b3e302f1e7..d79ef50e1883 100644\n--- a/ydb/core/tx/columnshard/engines/storage/granule/granule.h\n+++ b/ydb/core/tx/columnshard/engines/storage/granule/granule.h\n@@ -21,9 +21,10 @@ class TColumnChunkLoadContext;\n class TDataClassSummary: public NColumnShard::TBaseGranuleDataClassSummary {\n private:\n     friend class TGranuleMeta;\n-    THashMap<ui32, TSimpleSerializationStat> ColumnStats;\n+    THashMap<ui32, NArrow::NSplitter::TSimpleSerializationStat> ColumnStats;\n+\n public:\n-    const THashMap<ui32, TSimpleSerializationStat>& GetColumnStats() const {\n+    const THashMap<ui32, NArrow::NSplitter::TSimpleSerializationStat>& GetColumnStats() const {\n         return ColumnStats;\n     }\n \n@@ -231,11 +232,11 @@ class TGranuleMeta: TNonCopyable {\n         }\n     }\n \n-    std::shared_ptr<NOlap::TSerializationStats> BuildSerializationStats(ISnapshotSchema::TPtr schema) const {\n-        auto result = std::make_shared<NOlap::TSerializationStats>();\n+    std::shared_ptr<NArrow::NSplitter::TSerializationStats> BuildSerializationStats(ISnapshotSchema::TPtr schema) const {\n+        auto result = std::make_shared<NArrow::NSplitter::TSerializationStats>();\n         for (auto&& i : GetAdditiveSummary().GetCompacted().GetColumnStats()) {\n             auto field = schema->GetFieldByColumnIdVerified(i.first);\n-            NOlap::TColumnSerializationStat columnInfo(i.first, field->name());\n+            NArrow::NSplitter::TColumnSerializationStat columnInfo(i.first, field->name());\n             columnInfo.Merge(i.second);\n             result->AddStat(columnInfo);\n         }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/granule/portions_index.cpp b/ydb/core/tx/columnshard/engines/storage/granule/portions_index.cpp\nindex 676d40ea1c48..e56487e5f8ef 100644\n--- a/ydb/core/tx/columnshard/engines/storage/granule/portions_index.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/granule/portions_index.cpp\n@@ -11,7 +11,7 @@ TPortionsIndex::TPortionIntervals TPortionsIndex::GetIntervalFeatures(const TPor\n     TPortionIntervals portionExcludeIntervals;\n     while (true) {\n         std::optional<NArrow::TReplaceKey> nextKey;\n-        for (auto&& p : itFrom->second.GetPortionIds()) {\n+        for (auto&& [p, _] : itFrom->second.GetPortionIds()) {\n             if (skipPortions.contains(p)) {\n                 continue;\n             }\n@@ -55,9 +55,13 @@ void TPortionsIndex::RemovePortion(const std::shared_ptr<TPortionInfo>& p) {\n     auto itTo = Points.find(p->IndexKeyEnd());\n     AFL_VERIFY(itTo != Points.end());\n     {\n+        const TPortionInfoStat stat(p);\n         auto it = itFrom;\n         while (true) {\n-            it->second.RemoveContained(p->GetPortionId());\n+            RemoveFromMemoryUsageControl(it->second.GetIntervalStats());\n+            it->second.RemoveContained(stat);\n+            RawMemoryUsage.Add(it->second.GetIntervalStats().GetMinRawBytes());\n+            BlobMemoryUsage.Add(it->second.GetIntervalStats().GetBlobBytes());\n             if (it == itTo) {\n                 break;\n             }\n@@ -67,19 +71,24 @@ void TPortionsIndex::RemovePortion(const std::shared_ptr<TPortionInfo>& p) {\n     if (itFrom != itTo) {\n         itFrom->second.RemoveStart(p);\n         if (itFrom->second.IsEmpty()) {\n+            RemoveFromMemoryUsageControl(itFrom->second.GetIntervalStats());\n             Points.erase(itFrom);\n         }\n         itTo->second.RemoveFinish(p);\n         if (itTo->second.IsEmpty()) {\n+            RemoveFromMemoryUsageControl(itTo->second.GetIntervalStats());\n             Points.erase(itTo);\n         }\n     } else {\n         itTo->second.RemoveStart(p);\n         itTo->second.RemoveFinish(p);\n         if (itTo->second.IsEmpty()) {\n+            RemoveFromMemoryUsageControl(itTo->second.GetIntervalStats());\n             Points.erase(itTo);\n         }\n     }\n+    RawMemoryUsage.FlushCounters();\n+    BlobMemoryUsage.FlushCounters();\n }\n \n void TPortionsIndex::AddPortion(const std::shared_ptr<TPortionInfo>& p) {\n@@ -89,13 +98,19 @@ void TPortionsIndex::AddPortion(const std::shared_ptr<TPortionInfo>& p) {\n     itTo->second.AddFinish(p);\n \n     auto it = itFrom;\n+    const TPortionInfoStat stat(p);\n     while (true) {\n-        it->second.AddContained(p->GetPortionId());\n+        RemoveFromMemoryUsageControl(it->second.GetIntervalStats());\n+        it->second.AddContained(stat);\n+        RawMemoryUsage.Add(it->second.GetIntervalStats().GetMinRawBytes());\n+        BlobMemoryUsage.Add(it->second.GetIntervalStats().GetBlobBytes());\n         if (it == itTo) {\n             break;\n         }\n         AFL_VERIFY(++it != Points.end());\n     }\n+    RawMemoryUsage.FlushCounters();\n+    BlobMemoryUsage.FlushCounters();\n }\n \n }\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/engines/storage/granule/portions_index.h b/ydb/core/tx/columnshard/engines/storage/granule/portions_index.h\nindex 09ca2d65e7c0..981943dc4dab 100644\n--- a/ydb/core/tx/columnshard/engines/storage/granule/portions_index.h\n+++ b/ydb/core/tx/columnshard/engines/storage/granule/portions_index.h\n@@ -1,4 +1,5 @@\n #pragma once\n+#include <ydb/core/tx/columnshard/counters/engine_logs.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n \n namespace NKikimr::NOlap {\n@@ -7,26 +8,74 @@ class TGranuleMeta;\n \n namespace NKikimr::NOlap::NGranule::NPortionsIndex {\n \n+class TPortionInfoStat {\n+private:\n+    std::shared_ptr<TPortionInfo> PortionInfo;\n+    YDB_READONLY(ui64, MinRawBytes, 0);\n+    YDB_READONLY(ui64, BlobBytes, 0);\n+\n+public:\n+    TPortionInfoStat(const std::shared_ptr<TPortionInfo>& portionInfo)\n+        : PortionInfo(portionInfo)\n+        , MinRawBytes(PortionInfo->GetMinMemoryForReadColumns({}))\n+        , BlobBytes(PortionInfo->GetTotalBlobBytes())\n+    {\n+\n+    }\n+\n+    const TPortionInfo& GetPortionInfoVerified() const {\n+        AFL_VERIFY(PortionInfo);\n+        return *PortionInfo;\n+    }\n+};\n+\n+class TIntervalInfoStat {\n+private:\n+    YDB_READONLY(ui64, MinRawBytes, 0);\n+    YDB_READONLY(ui64, BlobBytes, 0);\n+\n+public:\n+    void Add(const TPortionInfoStat& source) {\n+        MinRawBytes += source.GetMinRawBytes();\n+        BlobBytes += source.GetBlobBytes();\n+    }\n+\n+    void Sub(const TPortionInfoStat& source) {\n+        AFL_VERIFY(MinRawBytes >= source.GetMinRawBytes());\n+        MinRawBytes -= source.GetMinRawBytes();\n+        AFL_VERIFY(BlobBytes >= source.GetBlobBytes());\n+        BlobBytes -= source.GetBlobBytes();\n+        AFL_VERIFY(!!BlobBytes == !!MinRawBytes);\n+    }\n+\n+    bool operator!() const {\n+        return !BlobBytes && !MinRawBytes;\n+    }\n+};\n+\n class TPortionsPKPoint {\n private:\n     THashMap<ui64, std::shared_ptr<TPortionInfo>> Start;\n     THashMap<ui64, std::shared_ptr<TPortionInfo>> Finish;\n-    THashSet<ui64> PortionIds;\n+    THashMap<ui64, TPortionInfoStat> PortionIds;\n+    YDB_READONLY_DEF(TIntervalInfoStat, IntervalStats);\n+\n public:\n     const THashMap<ui64, std::shared_ptr<TPortionInfo>>& GetStart() const {\n         return Start;\n     }\n \n     void ProvidePortions(const TPortionsPKPoint& source) {\n-        for (auto&& i : source.PortionIds) {\n+        IntervalStats = TIntervalInfoStat();\n+        for (auto&& [i, stat] : source.PortionIds) {\n             if (source.Finish.contains(i)) {\n                 continue;\n             }\n-            AFL_VERIFY(PortionIds.emplace(i).second);\n+            AddContained(stat);\n         }\n     }\n \n-    const THashSet<ui64>& GetPortionIds() const {\n+    const THashMap<ui64, TPortionInfoStat>& GetPortionIds() const {\n         return PortionIds;\n     }\n \n@@ -34,12 +83,19 @@ class TPortionsPKPoint {\n         return Start.empty() && Finish.empty();\n     }\n \n-    void AddContained(const ui64 portionId) {\n-        AFL_VERIFY(PortionIds.emplace(portionId).second);\n+    void AddContained(const TPortionInfoStat& stat) {\n+        if (!stat.GetPortionInfoVerified().HasRemoveSnapshot()) {\n+            IntervalStats.Add(stat);\n+        }\n+        AFL_VERIFY(PortionIds.emplace(stat.GetPortionInfoVerified().GetPortionId(), stat).second);\n     }\n \n-    void RemoveContained(const ui64 portionId) {\n-        AFL_VERIFY(PortionIds.erase(portionId));\n+    void RemoveContained(const TPortionInfoStat& stat) {\n+        if (!stat.GetPortionInfoVerified().HasRemoveSnapshot()) {\n+            IntervalStats.Sub(stat);\n+        }\n+        AFL_VERIFY(PortionIds.erase(stat.GetPortionInfoVerified().GetPortionId()));\n+        AFL_VERIFY(PortionIds.size() || !IntervalStats);\n     }\n \n     void RemoveStart(const std::shared_ptr<TPortionInfo>& p) {\n@@ -61,9 +117,48 @@ class TPortionsPKPoint {\n     }\n };\n \n+class TIntervalMemoryMonitoring {\n+private:\n+    std::map<ui64, i32> CountMemoryUsages;\n+    const NColumnShard::TIntervalMemoryCounters& Counters;\n+\n+public:\n+    void Add(const ui64 mem) {\n+        ++CountMemoryUsages[mem];\n+    }\n+\n+    void Remove(const ui64 mem) {\n+        auto it = CountMemoryUsages.find(mem);\n+        AFL_VERIFY(it != CountMemoryUsages.end())(\"mem\", mem);\n+        if (!--it->second) {\n+            CountMemoryUsages.erase(it);\n+        }\n+    }\n+\n+    TIntervalMemoryMonitoring(const NColumnShard::TIntervalMemoryCounters& counters)\n+        : Counters(counters)\n+    {\n+    \n+    }\n+\n+    ui64 GetMax() const {\n+        if (CountMemoryUsages.size()) {\n+            return CountMemoryUsages.rbegin()->first;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    void FlushCounters() const {\n+        Counters.MinReadBytes->SetValue(GetMax());\n+    }\n+};\n+\n class TPortionsIndex {\n private:\n     std::map<NArrow::TReplaceKey, TPortionsPKPoint> Points;\n+    TIntervalMemoryMonitoring RawMemoryUsage;\n+    TIntervalMemoryMonitoring BlobMemoryUsage;\n     const TGranuleMeta& Owner;\n \n     std::map<NArrow::TReplaceKey, TPortionsPKPoint>::iterator InsertPoint(const NArrow::TReplaceKey& key) {\n@@ -75,17 +170,34 @@ class TPortionsIndex {\n                 --itPred;\n                 it->second.ProvidePortions(itPred->second);\n             }\n+            RawMemoryUsage.Add(it->second.GetIntervalStats().GetMinRawBytes());\n+            BlobMemoryUsage.Add(it->second.GetIntervalStats().GetBlobBytes());\n         }\n         return it;\n     }\n \n+    void RemoveFromMemoryUsageControl(const TIntervalInfoStat& stat) {\n+        RawMemoryUsage.Remove(stat.GetMinRawBytes());\n+        BlobMemoryUsage.Remove(stat.GetBlobBytes());\n+    }\n+\n public:\n-    TPortionsIndex(const TGranuleMeta& owner)\n-        : Owner(owner)\n+    TPortionsIndex(const TGranuleMeta& owner, const NColumnShard::TPortionsIndexCounters& counters)\n+        : RawMemoryUsage(counters.RawBytes)\n+        , BlobMemoryUsage(counters.BlobBytes)\n+        , Owner(owner)\n     {\n \n     }\n \n+    ui64 GetMinRawMemoryRead() const {\n+        return RawMemoryUsage.GetMax();\n+    }\n+\n+    ui64 GetMinBlobMemoryRead() const {\n+        return BlobMemoryUsage.GetMax();\n+    }\n+\n     const std::map<NArrow::TReplaceKey, TPortionsPKPoint>& GetPoints() const {\n         return Points;\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/granule/storage.cpp b/ydb/core/tx/columnshard/engines/storage/granule/storage.cpp\nindex 385f9d818d23..b017464eefeb 100644\n--- a/ydb/core/tx/columnshard/engines/storage/granule/storage.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/granule/storage.cpp\n@@ -8,7 +8,7 @@ std::shared_ptr<NKikimr::NOlap::TGranuleMeta> TGranulesStorage::GetGranuleForCom\n     std::map<NStorageOptimizer::TOptimizationPriority, std::shared_ptr<TGranuleMeta>> granulesSorted;\n     ui32 countChecker = 0;\n     std::optional<NStorageOptimizer::TOptimizationPriority> priorityChecker;\n-    const TDuration actualizationLag = NYDBTest::TControllers::GetColumnShardController()->GetCompactionActualizationLag(TDuration::Seconds(1));\n+    const TDuration actualizationLag = NYDBTest::TControllers::GetColumnShardController()->GetCompactionActualizationLag();\n     for (auto&& i : Tables) {\n         NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"path_id\", i.first);\n         i.second->ActualizeOptimizer(now, actualizationLag);\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/checker.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/checker.cpp\nindex aad793c858c2..1613bd10e7d0 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/checker.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/checker.cpp\n@@ -1,6 +1,6 @@\n #include \"checker.h\"\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n-#include <ydb/core/formats/arrow/common/validation.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_primitive.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp\nindex 19d283d7f9e5..6d761daf9eab 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp\n@@ -1,6 +1,6 @@\n #include \"meta.h\"\n #include \"checker.h\"\n-#include <ydb/core/formats/arrow/hash/xx_hash.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n #include <ydb/core/formats/arrow/hash/calcer.h>\n #include <ydb/core/tx/program/program.h>\n #include <ydb/core/tx/schemeshard/olap/schema/schema.h>\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/count_min_sketch/checker.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/count_min_sketch/checker.cpp\nnew file mode 100644\nindex 000000000000..aa40668897d4\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/count_min_sketch/checker.cpp\n@@ -0,0 +1,22 @@\n+#include \"checker.h\"\n+#include <ydb/core/formats/arrow/serializer/abstract.h>\n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_primitive.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n+\n+namespace NKikimr::NOlap::NIndexes::NCountMinSketch {\n+\n+void TCountMinSketchChecker::DoSerializeToProtoImpl(NKikimrSSA::TProgram::TOlapIndexChecker& proto) const {\n+    proto.MutableCountMinSketch();\n+}\n+\n+bool TCountMinSketchChecker::DoCheckImpl(const std::vector<TString>& blobs) const {\n+    Y_UNUSED(blobs);\n+    return true;\n+}\n+\n+bool TCountMinSketchChecker::DoDeserializeFromProtoImpl(const NKikimrSSA::TProgram::TOlapIndexChecker& proto) {\n+    return proto.HasCountMinSketch();\n+}\n+\n+}   // namespace NKikimr::NOlap::NIndexes\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/count_min_sketch/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/count_min_sketch/meta.cpp\nnew file mode 100644\nindex 000000000000..80d154a751be\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/count_min_sketch/meta.cpp\n@@ -0,0 +1,56 @@\n+#include \"meta.h\"\n+#include \"checker.h\"\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n+#include <ydb/core/formats/arrow/hash/calcer.h>\n+#include <ydb/core/tx/program/program.h>\n+#include <ydb/core/tx/schemeshard/olap/schema/schema.h>\n+#include <ydb/library/minsketch/count_min_sketch.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_primitive.h>\n+#include <library/cpp/deprecated/atomic/atomic.h>\n+\n+namespace NKikimr::NOlap::NIndexes::NCountMinSketch {\n+\n+TString TIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader) const {\n+    auto sketch = std::unique_ptr<TCountMinSketch>(TCountMinSketch::Create());\n+\n+    for (auto& colReader : reader) {\n+        for (colReader.Start(); colReader.IsCorrect(); colReader.ReadNextChunk()) {\n+            auto array = colReader.GetCurrentChunk();\n+\n+            NArrow::SwitchType(array->type_id(), [&](const auto& type) {\n+                using TWrap = std::decay_t<decltype(type)>;\n+                using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+\n+                const TArray& arrTyped = static_cast<const TArray&>(*array);\n+                if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n+                    for (int64_t i = 0; i < arrTyped.length(); ++i) {\n+                        auto cell = TCell::Make(arrTyped.Value(i));\n+                        sketch->Count(cell.Data(), cell.Size());\n+                    }\n+                    return true;\n+                }\n+                if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+                    for (int64_t i = 0; i < arrTyped.length(); ++i) {\n+                        auto view = arrTyped.GetView(i);\n+                        sketch->Count(view.data(), view.size());\n+                    }\n+                    return true;\n+                }\n+                AFL_VERIFY(false)(\"message\", \"Unsupported arrow type for building an index\");\n+                return false;\n+            });\n+        }\n+    }\n+\n+    TString result(sketch->AsStringBuf());\n+    return result;\n+}\n+\n+void TIndexMeta::DoFillIndexCheckers(const std::shared_ptr<NRequest::TDataForIndexesCheckers>& info, const NSchemeShard::TOlapSchema& /*schema*/) const {\n+    for (auto&& branch : info->GetBranches()) {\n+        branch->MutableIndexes().emplace_back(std::make_shared<TCountMinSketchChecker>(GetIndexId()));\n+    }\n+}\n+\n+}   // namespace NKikimr::NOlap::NIndexes\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/max/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/max/meta.cpp\nindex 3556cb3d1a9d..b672f278e017 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/max/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/max/meta.cpp\n@@ -1,6 +1,6 @@\n #include \"meta.h\"\n \n-#include <ydb/core/formats/arrow/scalar/serialization.h>\n+#include <ydb/library/formats/arrow/scalar/serialization.h>\n #include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n #include <ydb/core/tx/program/program.h>\n #include <ydb/core/tx/schemeshard/olap/schema/schema.h>\n@@ -16,8 +16,8 @@ TString TIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader) const {\n     {\n         TChunkedColumnReader cReader = *reader.begin();\n         for (reader.Start(); cReader.IsCorrect(); cReader.ReadNextChunk()) {\n-            auto minMax = NArrow::FindMinMaxPosition(cReader.GetCurrentChunk());\n-            auto currentScalar = NArrow::GetScalar(cReader.GetCurrentChunk(), minMax.second);\n+            auto currentScalar = cReader.GetCurrentAccessor()->GetMaxScalar();\n+            AFL_VERIFY(currentScalar);\n             if (!result || NArrow::ScalarCompare(*result, *currentScalar) == -1) {\n                 result = currentScalar;\n             }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.cpp\nindex cd5f4f3c51cc..e62bc99d0a7f 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.cpp\n@@ -6,16 +6,6 @@\n \n namespace NKikimr::NOlap::NIndexes {\n \n-void TPortionIndexChunk::DoAddIntoPortionBeforeBlob(\n-    const TBlobRangeLink16& bRange, TPortionInfoConstructor& portionInfo) const {\n-    AFL_VERIFY(!bRange.IsValid());\n-    portionInfo.AddIndex(TIndexChunk(GetEntityId(), GetChunkIdxVerified(), RecordsCount, RawBytes, bRange));\n-}\n-\n-void TPortionIndexChunk::DoAddInplaceIntoPortion(TPortionInfoConstructor& portionInfo) const {\n-    portionInfo.AddIndex(TIndexChunk(GetEntityId(), GetChunkIdxVerified(), RecordsCount, RawBytes, GetData()));\n-}\n-\n std::shared_ptr<NKikimr::NOlap::IPortionDataChunk> TIndexByColumns::DoBuildIndex(\n     const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& data, const TIndexInfo& indexInfo) const {\n     AFL_VERIFY(Serializer);\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.h\nindex 3f2f5dfb872f..427ee98d99d2 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.h\n@@ -1,56 +1,10 @@\n #pragma once\n #include <ydb/core/tx/columnshard/splitter/abstract/chunks.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/abstract/saver.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/abstract/index_info.h>\n #include <ydb/core/tx/columnshard/engines/scheme/indexes/abstract/meta.h>\n \n namespace NKikimr::NOlap::NIndexes {\n \n-class TPortionIndexChunk: public IPortionDataChunk {\n-private:\n-    using TBase = IPortionDataChunk;\n-    const ui32 RecordsCount;\n-    const ui64 RawBytes;\n-    const TString Data;\n-protected:\n-    virtual const TString& DoGetData() const override {\n-        return Data;\n-    }\n-    virtual TString DoDebugString() const override {\n-        return \"\";\n-    }\n-    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplit(const TColumnSaver& /*saver*/, const std::shared_ptr<NColumnShard::TSplitterCounters>& /*counters*/, const std::vector<ui64>& /*splitSizes*/) const override {\n-        AFL_VERIFY(false);\n-        return {};\n-    }\n-    virtual bool DoIsSplittable() const override {\n-        return false;\n-    }\n-    virtual std::optional<ui32> DoGetRecordsCount() const override {\n-        return RecordsCount;\n-    }\n-    virtual std::optional<ui64> DoGetRawBytes() const override {\n-        return RawBytes;\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetFirstScalar() const override {\n-        return nullptr;\n-    }\n-    virtual std::shared_ptr<arrow::Scalar> DoGetLastScalar() const override {\n-        return nullptr;\n-    }\n-    virtual void DoAddIntoPortionBeforeBlob(const TBlobRangeLink16& bRange, TPortionInfoConstructor& portionInfo) const override;\n-    virtual void DoAddInplaceIntoPortion(TPortionInfoConstructor& portionInfo) const override;\n-\n-public:\n-    TPortionIndexChunk(const TChunkAddress& address, const ui32 recordsCount, const ui64 rawBytes, const TString& data)\n-        : TBase(address.GetColumnId(), address.GetChunkIdx())\n-        , RecordsCount(recordsCount)\n-        , RawBytes(rawBytes)\n-        , Data(data)\n-    {\n-    }\n-\n-};\n-\n class TIndexByColumns: public IIndexMeta {\n private:\n     using TBase = IIndexMeta;\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/ya.make b/ydb/core/tx/columnshard/engines/storage/indexes/portions/ya.make\nindex 076d439d54af..0ce6d8f9987f 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/ya.make\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/ya.make\n@@ -7,7 +7,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/formats/arrow\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n     ydb/core/tx/columnshard/engines/storage/chunks\n     ydb/core/tx/columnshard/engines/scheme/indexes/abstract\n     ydb/core/tx/columnshard/engines/portions\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.cpp\nindex a36e976ed351..36f467a03133 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.cpp\n@@ -3,8 +3,7 @@\n namespace NKikimr::NOlap::NStorageOptimizer::NLBuckets {\n \n TDuration GetCommonFreshnessCheckDuration() {\n-    static const TDuration CommonFreshnessCheckDuration = TDuration::Seconds(300);\n-    return NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration(CommonFreshnessCheckDuration);\n+    return NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration();\n }\n \n }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.h\nindex f83183c04e39..d686fc719112 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lbuckets/planner/optimizer.h\n@@ -19,8 +19,6 @@\n \n namespace NKikimr::NOlap::NStorageOptimizer::NLBuckets {\n \n-static const ui64 SmallPortionDetectSizeLimit = 1 << 20;\n-\n TDuration GetCommonFreshnessCheckDuration();\n \n class TSimplePortionsGroupInfo {\n@@ -683,7 +681,7 @@ class TPortionsBucket: public TMoveOnly {\n             return;\n         }\n         MainPortion->InitRuntimeFeature(TPortionInfo::ERuntimeFeature::Optimized, Others.IsEmpty() && currentInstant > MainPortion->RecordSnapshotMax().GetPlanInstant() +\n-            NYDBTest::TControllers::GetColumnShardController()->GetLagForCompactionBeforeTierings(TDuration::Minutes(60)));\n+            NYDBTest::TControllers::GetColumnShardController()->GetLagForCompactionBeforeTierings());\n     }\n public:\n     TTaskDescription GetTaskDescription() const {\n@@ -1104,7 +1102,7 @@ class TPortionBuckets {\n     }\n \n     void RemovePortion(const std::shared_ptr<TPortionInfo>& portion) {\n-        if (portion->GetTotalBlobBytes() < NYDBTest::TControllers::GetColumnShardController()->GetSmallPortionSizeDetector(SmallPortionDetectSizeLimit)) {\n+        if (portion->GetTotalBlobBytes() < NYDBTest::TControllers::GetColumnShardController()->GetSmallPortionSizeDetector()) {\n             Counters->SmallPortions->RemovePortion(portion);\n         }\n         if (!RemoveBucket(portion)) {\n@@ -1146,7 +1144,7 @@ class TPortionBuckets {\n     }\n \n     void AddPortion(const std::shared_ptr<TPortionInfo>& portion, const TInstant now) {\n-        if (portion->GetTotalBlobBytes() < NYDBTest::TControllers::GetColumnShardController()->GetSmallPortionSizeDetector(SmallPortionDetectSizeLimit)) {\n+        if (portion->GetTotalBlobBytes() < NYDBTest::TControllers::GetColumnShardController()->GetSmallPortionSizeDetector()) {\n             Counters->SmallPortions->AddPortion(portion);\n             AddOther(portion, now);\n             return;\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/common/optimizer.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/common/optimizer.cpp\nindex baf229b3d1fd..2fe68710d805 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/common/optimizer.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/common/optimizer.cpp\n@@ -4,8 +4,7 @@\n namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {\n \n TDuration GetCommonFreshnessCheckDuration() {\n-    static const TDuration CommonFreshnessCheckDuration = TDuration::Seconds(300);\n-    return NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration(CommonFreshnessCheckDuration);\n+    return NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration();\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.cpp\nindex 9e8d21bb9357..bc007d0fff10 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.cpp\n@@ -2,12 +2,11 @@\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/optimizer/optimizer.h>\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/one_head/logic.h>\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/slices/logic.h>\n-#include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n \n namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {\n \n std::shared_ptr<IOptimizationLogic> TOptimizerPlannerConstructor::BuildLogic() const {\n-    const TDuration freshnessCheckDuration = NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration(FreshnessCheckDuration);\n+    const TDuration freshnessCheckDuration = NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration();\n     std::shared_ptr<IOptimizationLogic> logic;\n     if (LogicName == \"one_head\") {\n         logic = std::make_shared<TOneHeadLogic>(freshnessCheckDuration);\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.h b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.h\nindex 8b85a25c0877..cabe72ccc2a9 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/constructor/constructor.h\n@@ -1,13 +1,16 @@\n #pragma once\n+#include <ydb/core/protos/config.pb.h>\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h>\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/abstract/logic.h>\n+#include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n \n namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {\n \n class TOptimizerPlannerConstructor: public IOptimizerPlannerConstructor {\n private:\n     YDB_READONLY_DEF(TString, LogicName);\n-    YDB_READONLY(TDuration, FreshnessCheckDuration, TDuration::Seconds(300));\n+    YDB_READONLY(TDuration, FreshnessCheckDuration, NYDBTest::TControllers::GetColumnShardController()->GetOptimizerFreshnessCheckDuration());\n+\n public:\n     static TString GetClassNameStatic() {\n         return \"s-buckets\";\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/index/bucket.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/index/bucket.cpp\nindex 5c70d26a38a3..ec344a674fd7 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/index/bucket.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/index/bucket.cpp\n@@ -9,7 +9,7 @@ namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {\n void TPortionsBucket::RebuildOptimizedFeature(const TInstant currentInstant) const {\n     for (auto&& [_, p] : Portions) {\n         p.MutablePortionInfo().InitRuntimeFeature(TPortionInfo::ERuntimeFeature::Optimized, Portions.size() == 1 && currentInstant > p->RecordSnapshotMax().GetPlanInstant() +\n-            NYDBTest::TControllers::GetColumnShardController()->GetLagForCompactionBeforeTierings(TDuration::Minutes(60))\n+            NYDBTest::TControllers::GetColumnShardController()->GetLagForCompactionBeforeTierings()\n         );\n     }\n }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/abstract/logic.h b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/abstract/logic.h\nindex 3e4cef0f2970..b2d169db8698 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/abstract/logic.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/abstract/logic.h\n@@ -2,7 +2,7 @@\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/common/optimizer.h>\n \n-#include <ydb/core/formats/arrow/replace_key.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n \n namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/slices/logic.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/slices/logic.cpp\nindex 465e19e8379b..28d2914ed392 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/slices/logic.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/logic/slices/logic.cpp\n@@ -67,7 +67,7 @@ NKikimr::NOlap::NStorageOptimizer::NSBuckets::TCompactionTaskResult TTimeSliceLo\n \n NKikimr::NOlap::NStorageOptimizer::NSBuckets::TCalcWeightResult TTimeSliceLogic::DoCalcWeight(const TInstant /*now*/, const TBucketInfo& bucket) const {\n     ui64 size = 0;\n-    ui32 count = 0;\n+    ui64 count = 0;\n     for (auto&& [maxInstant, portions] : bucket.GetSnapshotPortions()) {\n         for (auto&& [_, p] : portions) {\n             if (p.GetTotalBlobBytes() > compactedDetector) {\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/ut/ut_optimizer.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/ut/ut_optimizer.cpp\nindex c4aec7dd234e..420a9e5901e9 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/ut/ut_optimizer.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/ut/ut_optimizer.cpp\n@@ -3,8 +3,8 @@\n #include <ydb/core/tx/columnshard/counters/indexation.h>\n #include <ydb/core/tx/columnshard/engines/storage/optimizer/intervals/optimizer.h>\n #include <ydb/core/formats/arrow/serializer/batch_only.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n #include <ydb/core/formats/arrow/serializer/full.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \ndiff --git a/ydb/core/tx/columnshard/engines/ut/helper.cpp b/ydb/core/tx/columnshard/engines/ut/helper.cpp\nindex eee9159edea7..56a5c26ba492 100644\n--- a/ydb/core/tx/columnshard/engines/ut/helper.cpp\n+++ b/ydb/core/tx/columnshard/engines/ut/helper.cpp\n@@ -1,10 +1,25 @@\n #include \"helper.h\"\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n \n namespace  NKikimr::NOlap::NEngines::NTest {\n \n+std::shared_ptr<arrow::Schema> TLocalHelper::GetMetaSchema() {\n+    return std::make_shared<arrow::Schema>(arrow::FieldVector({ std::make_shared<arrow::Field>(\"1\", arrow::uint64()) }));\n+}\n+\n NKikimrTxColumnShard::TLogicalMetadata TLocalHelper::GetMetaProto() {\n     NKikimrTxColumnShard::TLogicalMetadata result;\n     result.SetDirtyWriteTimeSeconds(TInstant::Now().Seconds());\n+\n+    std::vector<std::shared_ptr<arrow::Array>> columns;\n+    auto schema = GetMetaSchema();\n+    for (auto&& i : schema->fields()) {\n+        columns.emplace_back(NArrow::TThreadSimpleArraysCache::Get(i->type(), NArrow::DefaultScalar(i->type()), 1));\n+    }\n+    auto batch = arrow::RecordBatch::Make(schema, 1, columns);\n+\n+    NArrow::TFirstLastSpecialKeys flKeys = NArrow::TFirstLastSpecialKeys(batch);\n+    result.SetSpecialKeysPayloadData(flKeys.SerializePayloadToString());\n     return result;\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/ut/helper.h b/ydb/core/tx/columnshard/engines/ut/helper.h\nindex 8e17730a21c6..c7072c13af91 100644\n--- a/ydb/core/tx/columnshard/engines/ut/helper.h\n+++ b/ydb/core/tx/columnshard/engines/ut/helper.h\n@@ -6,6 +6,7 @@ namespace NKikimr::NOlap::NEngines::NTest {\n class TLocalHelper {\n public:\n     static NKikimrTxColumnShard::TLogicalMetadata GetMetaProto();\n+    static std::shared_ptr<arrow::Schema> GetMetaSchema();\n };\n \n };\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/engines/ut/ut_insert_table.cpp b/ydb/core/tx/columnshard/engines/ut/ut_insert_table.cpp\nindex 946b657400ca..d840a5a64f37 100644\n--- a/ydb/core/tx/columnshard/engines/ut/ut_insert_table.cpp\n+++ b/ydb/core/tx/columnshard/engines/ut/ut_insert_table.cpp\n@@ -18,13 +18,13 @@ class TTestInsertTableDB : public IDbWrapper {\n public:\n     void Insert(const TInsertedData&) override {\n     }\n-    void Commit(const TInsertedData&) override {\n+    void Commit(const TCommittedData&) override {\n     }\n     void Abort(const TInsertedData&) override {\n     }\n     void EraseInserted(const TInsertedData&) override {\n     }\n-    void EraseCommitted(const TInsertedData&) override {\n+    void EraseCommitted(const TCommittedData&) override {\n     }\n     void EraseAborted(const TInsertedData&) override {\n     }\n@@ -73,7 +73,7 @@ class TTestInsertTableDB : public IDbWrapper {\n \n Y_UNIT_TEST_SUITE(TColumnEngineTestInsertTable) {\n     Y_UNIT_TEST(TestInsertCommit) {\n-        ui64 writeId = 0;\n+        TInsertWriteId writeId = (TInsertWriteId)0;\n         ui64 tableId = 0;\n         TString dedupId = \"0\";\n         TUnifiedBlobId blobId1(2222, 1, 1, 100, 2, 0, 1);\n@@ -81,47 +81,38 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestInsertTable) {\n         TTestInsertTableDB dbTable;\n         TInsertTable insertTable;\n         ui64 indexSnapshot = 0;\n-\n+        \n         // insert, not commited\n-        bool ok = insertTable.Insert(dbTable, TInsertedData(writeId, tableId, dedupId, blobId1, TLocalHelper::GetMetaProto(), indexSnapshot, {}));\n+        auto userData1 = std::make_shared<TUserData>(tableId, TBlobRange(blobId1), TLocalHelper::GetMetaProto(), indexSnapshot, std::nullopt);\n+        bool ok = insertTable.Insert(dbTable, TInsertedData(writeId, userData1));\n         UNIT_ASSERT(ok);\n \n-        // insert the same blobId1 again\n-        ok = insertTable.Insert(dbTable, TInsertedData(writeId, tableId, dedupId, blobId1, TLocalHelper::GetMetaProto(), indexSnapshot, {}));\n-        UNIT_ASSERT(!ok);\n-\n-        // insert different blodId with the same writeId and dedupId\n-        TUnifiedBlobId blobId2(2222, 1, 2, 100, 2, 0, 1);\n-        ok = insertTable.Insert(dbTable, TInsertedData(writeId, tableId, dedupId, blobId2, TLocalHelper::GetMetaProto(), indexSnapshot, {}));\n-        UNIT_ASSERT(!ok);\n-\n         // read nothing\n-        auto blobs = insertTable.Read(tableId, TSnapshot::Zero(), nullptr);\n+        auto blobs = insertTable.Read(tableId, {}, TSnapshot::Zero(), TLocalHelper::GetMetaSchema(), nullptr);\n         UNIT_ASSERT_EQUAL(blobs.size(), 0);\n-        blobs = insertTable.Read(tableId + 1, TSnapshot::Zero(), nullptr);\n+        blobs = insertTable.Read(tableId + 1, {}, TSnapshot::Zero(), TLocalHelper::GetMetaSchema(), nullptr);\n         UNIT_ASSERT_EQUAL(blobs.size(), 0);\n \n         // commit\n         ui64 planStep = 100;\n         ui64 txId = 42;\n-        insertTable.Commit(dbTable, planStep, txId, {TWriteId{writeId}}, [](ui64) {\n+        insertTable.Commit(dbTable, planStep, txId, { writeId }, [](ui64) {\n             return true;\n         });\n-\n-        UNIT_ASSERT_EQUAL(insertTable.GetPathPriorities().size(), 1);\n-        UNIT_ASSERT_EQUAL(insertTable.GetPathPriorities().begin()->second.size(), 1);\n-        UNIT_ASSERT_EQUAL((*insertTable.GetPathPriorities().begin()->second.begin())->GetCommitted().size(), 1);\n+//        UNIT_ASSERT_EQUAL(insertTable.GetPathPriorities().size(), 1);\n+//        UNIT_ASSERT_EQUAL(insertTable.GetPathPriorities().begin()->second.size(), 1);\n+//        UNIT_ASSERT_EQUAL((*insertTable.GetPathPriorities().begin()->second.begin())->GetCommitted().size(), 1);\n \n         // read old snapshot\n-        blobs = insertTable.Read(tableId, TSnapshot::Zero(), nullptr);\n+        blobs = insertTable.Read(tableId, {}, TSnapshot::Zero(), TLocalHelper::GetMetaSchema(), nullptr);\n         UNIT_ASSERT_EQUAL(blobs.size(), 0);\n-        blobs = insertTable.Read(tableId + 1, TSnapshot::Zero(), nullptr);\n+        blobs = insertTable.Read(tableId + 1, {}, TSnapshot::Zero(), TLocalHelper::GetMetaSchema(), nullptr);\n         UNIT_ASSERT_EQUAL(blobs.size(), 0);\n \n         // read new snapshot\n-        blobs = insertTable.Read(tableId, TSnapshot(planStep, txId), nullptr);\n+        blobs = insertTable.Read(tableId, {}, TSnapshot(planStep, txId), TLocalHelper::GetMetaSchema(), nullptr);\n         UNIT_ASSERT_EQUAL(blobs.size(), 1);\n-        blobs = insertTable.Read(tableId + 1, TSnapshot::Zero(), nullptr);\n+        blobs = insertTable.Read(tableId + 1, {}, TSnapshot::Zero(), TLocalHelper::GetMetaSchema(), nullptr);\n         UNIT_ASSERT_EQUAL(blobs.size(), 0);\n     }\n }\ndiff --git a/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp b/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp\nindex 10a1891c4102..ecde3aa56673 100644\n--- a/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp\n+++ b/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp\n@@ -48,27 +48,27 @@ class TTestDbWrapper : public IDbWrapper {\n     }\n \n     void Insert(const TInsertedData& data) override {\n-        Inserted.emplace(TWriteId{data.WriteTxId}, data);\n+        Inserted.emplace(data.GetInsertWriteId(), data);\n     }\n \n-    void Commit(const TInsertedData& data) override {\n-        Committed[data.PathId].emplace(data);\n+    void Commit(const TCommittedData& data) override {\n+        Committed[data.GetPathId()].emplace(data);\n     }\n \n     void Abort(const TInsertedData& data) override {\n-        Aborted.emplace(TWriteId{data.WriteTxId}, data);\n+        Aborted.emplace(data.GetInsertWriteId(), data);\n     }\n \n     void EraseInserted(const TInsertedData& data) override {\n-        Inserted.erase(TWriteId{data.WriteTxId});\n+        Inserted.erase(data.GetInsertWriteId());\n     }\n \n-    void EraseCommitted(const TInsertedData& data) override {\n-        Committed[data.PathId].erase(data);\n+    void EraseCommitted(const TCommittedData& data) override {\n+        Committed[data.GetPathId()].erase(data);\n     }\n \n     void EraseAborted(const TInsertedData& data) override {\n-        Aborted.erase(TWriteId{data.WriteTxId});\n+        Aborted.erase(data.GetInsertWriteId());\n     }\n \n     bool Load(TInsertTableAccessor& accessor,\n@@ -189,9 +189,9 @@ class TTestDbWrapper : public IDbWrapper {\n     }\n \n private:\n-    THashMap<TWriteId, TInsertedData> Inserted;\n-    THashMap<ui64, TSet<TInsertedData>> Committed;\n-    THashMap<TWriteId, TInsertedData> Aborted;\n+    THashMap<TInsertWriteId, TInsertedData> Inserted;\n+    THashMap<ui64, TSet<TCommittedData>> Committed;\n+    THashMap<TInsertWriteId, TInsertedData> Aborted;\n     THashMap<ui32, TIndex> Indices;\n };\n \n@@ -294,12 +294,8 @@ void AddIdsToBlobs(std::vector<TWritePortionInfoWithBlobsResult>& portions, NBlo\n     }\n }\n \n-bool Insert(TColumnEngineForLogs& engine, TTestDbWrapper& db, TSnapshot snap, std::vector<TInsertedData>&& dataToIndex,\n+bool Insert(TColumnEngineForLogs& engine, TTestDbWrapper& db, TSnapshot snap, std::vector<TCommittedData>&& dataToIndex,\n     NBlobOperations::NRead::TCompositeReadBlobs& blobs, ui32& step) {\n-    for (ui32 i = 0; i < dataToIndex.size(); ++i) {\n-        // Commited data always has nonzero planstep (for WriteLoadRead tests)\n-        dataToIndex[i].PlanStep = i + 1;\n-    };\n     std::shared_ptr<TInsertColumnEngineChanges> changes = engine.StartInsert(std::move(dataToIndex));\n     if (!changes) {\n         return false;\n@@ -433,6 +429,7 @@ std::shared_ptr<NKikimr::NOlap::IStoragesManager> CommonStoragesManager = Initia\n Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n     void WriteLoadRead(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,\n                        const std::vector<NArrow::NTest::TTestColumn>& key) {\n+        TTestBasicRuntime runtime;\n         TTestDbWrapper db;\n         TIndexInfo tableInfo = NColumnShard::BuildTableInfo(ydbSchema, key);\n \n@@ -446,16 +443,16 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n         // PlanStep, TxId, PathId, DedupId, BlobId, Data, [Metadata]\n         // load\n-        TSnapshot indexSnaphot(1, 1);\n-        TColumnEngineForLogs engine(0, CommonStoragesManager, indexSnaphot, TIndexInfo(tableInfo));\n+        TSnapshot indexSnapshot(1, 1);\n+        TColumnEngineForLogs engine(0, CommonStoragesManager, indexSnapshot, TIndexInfo(tableInfo));\n         for (auto&& i : paths) {\n             engine.RegisterTable(i);\n         }\n         engine.Load(db);\n \n-        std::vector<TInsertedData> dataToIndex = {\n-            TInsertedData(2, paths[0], \"\", blobRanges[0].BlobId, TLocalHelper::GetMetaProto(), 0, {}),\n-            TInsertedData(1, paths[0], \"\", blobRanges[1].BlobId, TLocalHelper::GetMetaProto(), 0, {})\n+        std::vector<TCommittedData> dataToIndex = {\n+            TCommittedData(TUserData::Build(paths[0], blobRanges[0], TLocalHelper::GetMetaProto(), 0, {}), TSnapshot(1, 2), (TInsertWriteId)2),\n+            TCommittedData(TUserData::Build(paths[0], blobRanges[1], TLocalHelper::GetMetaProto(), 0, {}), TSnapshot(2, 1), (TInsertWriteId)1)\n         };\n \n         // write\n@@ -473,12 +470,12 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n         // selects\n \n         auto lastSchema = engine.GetVersionedIndex().GetLastSchema();\n-        UNIT_ASSERT_EQUAL(lastSchema->GetSnapshot(), indexSnaphot);\n+        UNIT_ASSERT_EQUAL(lastSchema->GetSnapshot(), indexSnapshot);\n         const TIndexInfo& indexInfo = lastSchema->GetIndexInfo();\n-        THashSet<ui32> oneColumnId = { indexInfo.GetColumnId(testColumns[0].GetName()) };\n+        THashSet<ui32> oneColumnId = { indexInfo.GetColumnIdVerified(testColumns[0].GetName()) };\n         THashSet<ui32> columnIds;\n         for (auto& c : testColumns) {\n-            columnIds.insert(indexInfo.GetColumnId(c.GetName()));\n+            columnIds.insert(indexInfo.GetColumnIdVerified(c.GetName()));\n         }\n \n         { // select from snap before insert\n@@ -528,6 +525,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n     void ReadWithPredicates(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,\n                             const std::vector<NArrow::NTest::TTestColumn>& key) {\n+        TTestBasicRuntime runtime;\n         TTestDbWrapper db;\n         TIndexInfo tableInfo = NColumnShard::BuildTableInfo(ydbSchema, key);\n \n@@ -552,11 +550,12 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             blobs.Add(IStoragesManager::DefaultStorageId, blobRange, std::move(str1));\n \n             // PlanStep, TxId, PathId, DedupId, BlobId, Data, [Metadata]\n-            std::vector<TInsertedData> dataToIndex;\n+            std::vector<TCommittedData> dataToIndex;\n+            TSnapshot ss(planStep, txId);\n             dataToIndex.push_back(\n-                TInsertedData(txId, pathId, \"\", blobRange.BlobId, TLocalHelper::GetMetaProto(), 0, {}));\n+                TCommittedData(TUserData::Build(pathId, blobRange, TLocalHelper::GetMetaProto(), 0, {}), ss, (TInsertWriteId)txId));\n \n-            bool ok = Insert(engine, db, TSnapshot(planStep, txId), std::move(dataToIndex), blobs, step);\n+            bool ok = Insert(engine, db, ss, std::move(dataToIndex), blobs, step);\n             UNIT_ASSERT(ok);\n         }\n \n@@ -573,7 +572,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n         planStep = 3;\n \n         const TIndexInfo& indexInfo = engine.GetVersionedIndex().GetLastSchema()->GetIndexInfo();\n-        THashSet<ui32> oneColumnId = { indexInfo.GetColumnId(key[0].GetName()) };\n+        THashSet<ui32> oneColumnId = { indexInfo.GetColumnIdVerified(key[0].GetName()) };\n \n         { // full scan\n             ui64 txId = 1;\n@@ -590,7 +589,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n                 gt10k = MakeStrPredicate(\"10000\", NArrow::EOperation::Greater);\n             }\n             NOlap::TPKRangesFilter pkFilter(false);\n-            Y_ABORT_UNLESS(pkFilter.Add(gt10k, nullptr, nullptr));\n+            Y_ABORT_UNLESS(pkFilter.Add(gt10k, nullptr, indexInfo.GetReplaceKey()));\n             auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), pkFilter);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->PortionsOrderedPK.size(), 10);\n         }\n@@ -602,7 +601,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n                 lt10k = MakeStrPredicate(\"08999\", NArrow::EOperation::Less);\n             }\n             NOlap::TPKRangesFilter pkFilter(false);\n-            Y_ABORT_UNLESS(pkFilter.Add(nullptr, lt10k, nullptr));\n+            Y_ABORT_UNLESS(pkFilter.Add(nullptr, lt10k, indexInfo.GetReplaceKey()));\n             auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), pkFilter);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->PortionsOrderedPK.size(), 9);\n         }\n@@ -624,6 +623,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n     }\n \n     Y_UNIT_TEST(IndexWriteOverload) {\n+        TTestBasicRuntime runtime;\n         TTestDbWrapper db;\n         auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();\n         TIndexInfo tableInfo = NColumnShard::BuildTableInfo(testColumns, testKey);;\n@@ -649,11 +649,11 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             blobs.Add(IStoragesManager::DefaultStorageId, blobRange, std::move(testBlob));\n \n             // PlanStep, TxId, PathId, DedupId, BlobId, Data, [Metadata]\n-            std::vector<TInsertedData> dataToIndex;\n-            dataToIndex.push_back(\n-                TInsertedData(txId, pathId, \"\", blobRange.BlobId, TLocalHelper::GetMetaProto(), 0, {}));\n+            std::vector<TCommittedData> dataToIndex;\n+            TSnapshot ss(planStep, txId);\n+            dataToIndex.push_back(TCommittedData(TUserData::Build(pathId, blobRange, TLocalHelper::GetMetaProto(), 0, {}), ss, (TInsertWriteId)txId));\n \n-            bool ok = Insert(engine, db, TSnapshot(planStep, txId), std::move(dataToIndex), blobs, step);\n+            bool ok = Insert(engine, db, ss, std::move(dataToIndex), blobs, step);\n             blobsAll.Merge(std::move(blobs));\n             UNIT_ASSERT(ok);\n         }\n@@ -680,11 +680,11 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             blobs.Add(IStoragesManager::DefaultStorageId, blobRange, std::move(testBlob));\n \n             // PlanStep, TxId, PathId, DedupId, BlobId, Data, [Metadata]\n-            std::vector<TInsertedData> dataToIndex;\n-            dataToIndex.push_back(\n-                TInsertedData(txId, pathId, \"\", blobRange.BlobId, TLocalHelper::GetMetaProto(), 0, {}));\n+            std::vector<TCommittedData> dataToIndex;\n+            TSnapshot ss(planStep, txId);\n+            dataToIndex.push_back(TCommittedData(TUserData::Build(pathId, blobRange, TLocalHelper::GetMetaProto(), 0, {}), ss, TInsertWriteId(txId)));\n \n-            bool ok = Insert(engine, db, TSnapshot(planStep, txId), std::move(dataToIndex), blobs, step);\n+            bool ok = Insert(engine, db, ss, std::move(dataToIndex), blobs, step);\n             UNIT_ASSERT(ok);\n         }\n \n@@ -696,10 +696,11 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n     }\n \n     Y_UNIT_TEST(IndexTtl) {\n+        TTestBasicRuntime runtime;\n         TTestDbWrapper db;\n         TIndexInfo tableInfo = NColumnShard::BuildTableInfo(testColumns, testKey);\n         auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();\n-        csDefaultControllerGuard->SetTasksActualizationLag(TDuration::Zero());\n+        csDefaultControllerGuard->SetOverrideTasksActualizationLag(TDuration::Zero());\n \n         ui64 pathId = 1;\n         ui32 step = 1000;\n@@ -726,11 +727,12 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n                 blobs.Add(IStoragesManager::DefaultStorageId, blobRange, std::move(str1));\n \n                 // PlanStep, TxId, PathId, DedupId, BlobId, Data, [Metadata]\n-                std::vector<TInsertedData> dataToIndex;\n+                TSnapshot ss(planStep, txId);\n+                std::vector<TCommittedData> dataToIndex;\n                 dataToIndex.push_back(\n-                    TInsertedData(txId, pathId, \"\", blobRange.BlobId, TLocalHelper::GetMetaProto(), 0, {}));\n+                    TCommittedData(TUserData::Build(pathId, blobRange, TLocalHelper::GetMetaProto(), 0, {}), ss, TInsertWriteId(txId)));\n \n-                bool ok = Insert(engine, db, TSnapshot(planStep, txId), std::move(dataToIndex), blobs, step);\n+                bool ok = Insert(engine, db, ss, std::move(dataToIndex), blobs, step);\n                 UNIT_ASSERT(ok);\n                 blobStartTs += blobTsRange;\n                 if (txId == txCount / 2) { \n@@ -750,7 +752,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             planStep = 3;\n \n             const TIndexInfo& indexInfo = engine.GetVersionedIndex().GetLastSchema()->GetIndexInfo();\n-            THashSet<ui32> oneColumnId = {indexInfo.GetColumnId(testColumns[0].GetName())};\n+            THashSet<ui32> oneColumnId = {indexInfo.GetColumnIdVerified(testColumns[0].GetName())};\n \n             { // full scan\n                 ui64 txId = 1;\n@@ -790,7 +792,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             engine.Load(db);\n \n             const TIndexInfo& indexInfo = engine.GetVersionedIndex().GetLastSchema()->GetIndexInfo();\n-            THashSet<ui32> oneColumnId = {indexInfo.GetColumnId(testColumns[0].GetName())};\n+            THashSet<ui32> oneColumnId = { indexInfo.GetColumnIdVerified(testColumns[0].GetName()) };\n \n             { // full scan\n                 ui64 txId = 1;\ndiff --git a/ydb/core/tx/columnshard/engines/ut/ut_program.cpp b/ydb/core/tx/columnshard/engines/ut/ut_program.cpp\nindex 798ba6ec505d..f957cfea5592 100644\n--- a/ydb/core/tx/columnshard/engines/ut/ut_program.cpp\n+++ b/ydb/core/tx/columnshard/engines/ut/ut_program.cpp\n@@ -852,4 +852,64 @@ Y_UNIT_TEST_SUITE(TestProgram) {\n         auto expected = result.BuildArrow();\n         UNIT_ASSERT_VALUES_EQUAL(batch->ToString(), expected->ToString());\n     }\n+\n+    Y_UNIT_TEST(CountWithNulls) {\n+        TIndexInfo indexInfo = BuildTableInfo(testColumns, testKey);\n+        ;\n+        NReader::NPlain::TIndexColumnResolver columnResolver(indexInfo);\n+\n+        NKikimrSSA::TProgram programProto;\n+        {\n+            auto* command = programProto.AddCommand();\n+            auto* functionProto = command->MutableAssign()->MutableFunction();\n+            auto* column = command->MutableAssign()->MutableColumn();\n+            column->SetName(\"0\");\n+            auto* funcArg = functionProto->AddArguments();\n+            funcArg->SetName(\"uid\");\n+            functionProto->SetId(NKikimrSSA::TProgram::TAssignment::EFunction::TProgram_TAssignment_EFunction_FUNC_IS_NULL);\n+        }\n+        {\n+            auto* command = programProto.AddCommand();\n+            auto* filter = command->MutableFilter();\n+            auto* predicate = filter->MutablePredicate();\n+            predicate->SetName(\"0\");\n+        }\n+        {\n+            auto* command = programProto.AddCommand();\n+            auto* groupBy = command->MutableGroupBy();\n+            auto* aggregate = groupBy->AddAggregates();\n+            aggregate->MutableFunction()->SetId(static_cast<ui32>(NArrow::EAggregate::Count));\n+            aggregate->MutableColumn()->SetName(\"1\");\n+        }\n+        {\n+            auto* command = programProto.AddCommand();\n+            auto* projectionProto = command->MutableProjection();\n+            auto* column = projectionProto->AddColumns();\n+            column->SetName(\"1\");\n+        }\n+        const auto programSerialized = SerializeProgram(programProto);\n+\n+        TProgramContainer program;\n+        TString errors;\n+        UNIT_ASSERT_C(\n+            program.Init(columnResolver, NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS, programSerialized, errors),\n+            errors);\n+\n+        TTableUpdatesBuilder updates(NArrow::MakeArrowSchema({ std::make_pair(\"uid\", TTypeInfo(NTypeIds::Utf8)) }));\n+        updates.AddRow().Add(\"a\");\n+        updates.AddRow().AddNull();\n+        updates.AddRow().Add(\"bbb\");\n+        updates.AddRow().AddNull();\n+        updates.AddRow().AddNull();\n+\n+        auto batch = updates.BuildArrow();\n+        auto res = program.ApplyProgram(batch);\n+        UNIT_ASSERT_C(res.ok(), res.ToString());\n+\n+        TTableUpdatesBuilder result(NArrow::MakeArrowSchema({ std::make_pair(\"1\", TTypeInfo(NTypeIds::Uint64)) }));\n+        result.AddRow().Add<uint64_t>(3);\n+\n+        auto expected = result.BuildArrow();\n+        UNIT_ASSERT_VALUES_EQUAL(batch->ToString(), expected->ToString());\n+    }\n }\ndiff --git a/ydb/core/tx/columnshard/engines/writer/buffer/actor.cpp b/ydb/core/tx/columnshard/engines/writer/buffer/actor.cpp\nindex cb243ef6c33a..eeb6242103d1 100644\n--- a/ydb/core/tx/columnshard/engines/writer/buffer/actor.cpp\n+++ b/ydb/core/tx/columnshard/engines/writer/buffer/actor.cpp\n@@ -48,7 +48,8 @@ void TActor::Handle(TEvAddInsertedDataToBuffer::TPtr& ev) {\n     auto* evBase = ev->Get();\r\n     AFL_VERIFY(evBase->GetWriteData()->GetBlobsAction()->GetStorageId() == NOlap::IStoragesManager::DefaultStorageId);\r\n     SumSize += evBase->GetWriteData()->GetSize();\r\n-    Aggregations.emplace_back(std::make_shared<NOlap::TWriteAggregation>(*evBase->GetWriteData(), std::move(evBase->MutableBlobsToWrite())));\r\n+    Aggregations.emplace_back(\r\n+        std::make_shared<NOlap::TWriteAggregation>(*evBase->GetWriteData(), std::move(evBase->MutableBlobsToWrite()), evBase->GetRecordBatch()));\r\n     if (SumSize > 4 * 1024 * 1024 || Aggregations.size() > 750 || !FlushDuration) {\r\n         Flush();\r\n     }\r\ndiff --git a/ydb/core/tx/columnshard/engines/writer/buffer/events.h b/ydb/core/tx/columnshard/engines/writer/buffer/events.h\nindex ee750ad69bcf..d2a4b4453b04 100644\n--- a/ydb/core/tx/columnshard/engines/writer/buffer/events.h\n+++ b/ydb/core/tx/columnshard/engines/writer/buffer/events.h\n@@ -11,11 +11,15 @@ namespace NKikimr::NColumnShard::NWriting {\n class TEvAddInsertedDataToBuffer: public NActors::TEventLocal<TEvAddInsertedDataToBuffer, NColumnShard::TEvPrivate::EEv::EvWritingAddDataToBuffer> {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<NEvWrite::TWriteData>, WriteData);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, RecordBatch);\n     YDB_ACCESSOR_DEF(std::vector<NArrow::TSerializedBatch>, BlobsToWrite);\n+\n public:\n \n-    explicit TEvAddInsertedDataToBuffer(const std::shared_ptr<NEvWrite::TWriteData>& writeData, std::vector<NArrow::TSerializedBatch>&& blobs)\n+    explicit TEvAddInsertedDataToBuffer(const std::shared_ptr<NEvWrite::TWriteData>& writeData, std::vector<NArrow::TSerializedBatch>&& blobs,\n+        const std::shared_ptr<arrow::RecordBatch>& recordBatch)\n         : WriteData(writeData)\n+        , RecordBatch(recordBatch)\n         , BlobsToWrite(blobs) {\n     }\n \ndiff --git a/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h b/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h\nindex 22b6ee9b897d..92e59e9b197c 100644\n--- a/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h\n+++ b/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h\n@@ -89,12 +89,19 @@ class TWriteAggregation {\n     NEvWrite::TWriteMeta WriteMeta;\n     YDB_READONLY(ui64, SchemaVersion, 0);\n     YDB_READONLY(ui64, Size, 0);\n+    YDB_READONLY(ui64, Rows, 0);\n     YDB_ACCESSOR_DEF(std::vector<TWideSerializedBatch>, SplittedBlobs);\n-    YDB_READONLY_DEF(TVector<TWriteId>, WriteIds);\n+    YDB_READONLY_DEF(TVector<TInsertWriteId>, InsertWriteIds);\n     YDB_READONLY_DEF(std::shared_ptr<NOlap::IBlobsWritingAction>, BlobsAction);\n     YDB_READONLY_DEF(NArrow::TSchemaSubset, SchemaSubset);\n+    std::shared_ptr<arrow::RecordBatch> RecordBatch;\n \n public:\n+    const std::shared_ptr<arrow::RecordBatch>& GetRecordBatch() const {\n+        AFL_VERIFY(RecordBatch);\n+        return RecordBatch;\n+    }\n+\n     const NEvWrite::TWriteMeta& GetWriteMeta() const {\n         return WriteMeta;\n     }\n@@ -103,20 +110,24 @@ class TWriteAggregation {\n         return WriteMeta;\n     }\n \n-    void AddWriteId(const TWriteId& id) {\n-        WriteIds.emplace_back(id);\n+    void AddInsertWriteId(const TInsertWriteId id) {\n+        InsertWriteIds.emplace_back(id);\n     }\n \n-    TWriteAggregation(const NEvWrite::TWriteData& writeData, std::vector<NArrow::TSerializedBatch>&& splittedBlobs)\n+    TWriteAggregation(const NEvWrite::TWriteData& writeData, std::vector<NArrow::TSerializedBatch>&& splittedBlobs, const std::shared_ptr<arrow::RecordBatch>& batch)\n         : WriteMeta(writeData.GetWriteMeta())\n         , SchemaVersion(writeData.GetData()->GetSchemaVersion())\n         , Size(writeData.GetSize())\n         , BlobsAction(writeData.GetBlobsAction())\n         , SchemaSubset(writeData.GetSchemaSubsetVerified())\n+        , RecordBatch(batch)\n     {\n         for (auto&& s : splittedBlobs) {\n             SplittedBlobs.emplace_back(std::move(s), *this);\n         }\n+        for (const auto& batch : SplittedBlobs) {\n+            Rows += batch->GetRowsCount();\n+        }\n     }\n \n     TWriteAggregation(const NEvWrite::TWriteData& writeData)\ndiff --git a/ydb/core/tx/columnshard/engines/ya.make b/ydb/core/tx/columnshard/engines/ya.make\nindex 4772008f14f1..66b72ec25122 100644\n--- a/ydb/core/tx/columnshard/engines/ya.make\n+++ b/ydb/core/tx/columnshard/engines/ya.make\n@@ -13,6 +13,7 @@ SRCS(\n     filter.cpp\n     portion_info.cpp\n     tier_info.cpp\n+    defs.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/core/tx/columnshard/hooks/abstract/abstract.cpp b/ydb/core/tx/columnshard/hooks/abstract/abstract.cpp\nindex a4d916545eac..b275e17f2fdb 100644\n--- a/ydb/core/tx/columnshard/hooks/abstract/abstract.cpp\n+++ b/ydb/core/tx/columnshard/hooks/abstract/abstract.cpp\n@@ -1,4 +1,26 @@\n #include \"abstract.h\"\n \n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n+\n namespace NKikimr::NYDBTest {\n+\n+TDuration ICSController::GetGuaranteeIndexationInterval() const {\n+    const TDuration defaultValue = NColumnShard::TSettings::GuaranteeIndexationInterval;\n+    return DoGetGuaranteeIndexationInterval(defaultValue);\n+}\n+\n+TDuration ICSController::GetPeriodicWakeupActivationPeriod() const {\n+    const TDuration defaultValue = NColumnShard::TSettings::DefaultPeriodicWakeupActivationPeriod;\n+    return DoGetPeriodicWakeupActivationPeriod(defaultValue);\n+}\n+\n+TDuration ICSController::GetStatsReportInterval() const {\n+    const TDuration defaultValue = NColumnShard::TSettings::DefaultStatsReportInterval;\n+    return DoGetStatsReportInterval(defaultValue);\n+}\n+\n+ui64 ICSController::GetGuaranteeIndexationStartBytesLimit() const {\n+    const ui64 defaultValue = NColumnShard::TSettings::GuaranteeIndexationStartBytesLimit;\n+    return DoGetGuaranteeIndexationStartBytesLimit(defaultValue);\n+}\n }\ndiff --git a/ydb/core/tx/columnshard/hooks/abstract/abstract.h b/ydb/core/tx/columnshard/hooks/abstract/abstract.h\nindex c231ce94496c..c104590235d3 100644\n--- a/ydb/core/tx/columnshard/hooks/abstract/abstract.h\n+++ b/ydb/core/tx/columnshard/hooks/abstract/abstract.h\n@@ -1,21 +1,24 @@\n #pragma once\n \n #include <ydb/core/tablet_flat/tablet_flat_executor.h>\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/engines/writer/write_controller.h>\n-\n-#include <ydb/services/metadata/abstract/fetcher.h>\n #include <ydb/core/tx/tiering/snapshot.h>\n+#include <ydb/core/tx/columnshard/common/limits.h>\n \n #include <ydb/library/accessor/accessor.h>\n-#include <util/generic/singleton.h>\n-#include <util/generic/refcount.h>\n+#include <ydb/services/metadata/abstract/fetcher.h>\n+\n #include <util/datetime/base.h>\n+#include <util/generic/refcount.h>\n+#include <util/generic/singleton.h>\n+\n #include <memory>\n \n namespace NKikimr::NColumnShard {\n class TTiersManager;\n class TColumnShard;\n-}\n+}   // namespace NKikimr::NColumnShard\n \n namespace NKikimr::NOlap {\n class TColumnEngineChanges;\n@@ -24,7 +27,7 @@ class TPortionInfo;\n namespace NIndexes {\n class TIndexMetaContainer;\n }\n-}\n+}   // namespace NKikimr::NOlap\n namespace arrow {\n class RecordBatch;\n }\n@@ -41,7 +44,8 @@ class ILocalDBModifier {\n public:\n     using TPtr = std::shared_ptr<ILocalDBModifier>;\n \n-    virtual ~ILocalDBModifier() {}\n+    virtual ~ILocalDBModifier() {\n+    }\n \n     virtual void Apply(NTabletFlatExecutor::TTransactionContext& txc) const = 0;\n };\n@@ -55,6 +59,7 @@ class ICSController {\n         Cleanup,\n         GC\n     };\n+\n protected:\n     virtual void DoOnTabletInitCompleted(const ::NKikimr::NColumnShard::TColumnShard& /*shard*/) {\n         return;\n@@ -77,10 +82,75 @@ class ICSController {\n     }\n     virtual void DoOnDataSharingFinished(const ui64 /*tabletId*/, const TString& /*sessionId*/) {\n     }\n-    virtual void DoOnDataSharingStarted(const ui64 /*tabletId*/, const TString & /*sessionId*/) {\n+    virtual void DoOnDataSharingStarted(const ui64 /*tabletId*/, const TString& /*sessionId*/) {\n+    }\n+\n+    virtual TDuration DoGetPingCheckPeriod(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetOverridenGCPeriod(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetCompactionActualizationLag(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetActualizationTasksLag(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual ui64 DoGetReduceMemoryIntervalLimit(const ui64 defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual ui64 DoGetRejectMemoryIntervalLimit(const ui64 defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual ui64 DoGetReadSequentiallyBufferSize(const ui64 defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual ui64 DoGetSmallPortionSizeDetector(const ui64 defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetReadTimeoutClean(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetGuaranteeIndexationInterval(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetPeriodicWakeupActivationPeriod(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetStatsReportInterval(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual ui64 DoGetGuaranteeIndexationStartBytesLimit(const ui64 defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetOptimizerFreshnessCheckDuration(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+    virtual TDuration DoGetLagForCompactionBeforeTierings(const TDuration defaultValue) const {\n+        return defaultValue;\n+    }\n+\n+private:\n+    inline static const NKikimrConfig::TColumnShardConfig DefaultConfig = {};\n+\n+    static const NKikimrConfig::TColumnShardConfig& GetConfig() {\n+        if (HasAppData()) {\n+            return AppDataVerified().ColumnShardConfig;\n+        }\n+        return DefaultConfig;\n     }\n \n public:\n+    virtual void OnRequestTracingChanges(\n+        const std::set<NOlap::TSnapshot>& /*snapshotsToSave*/, const std::set<NOlap::TSnapshot>& /*snapshotsToRemove*/) {\n+    }\n+\n+    TDuration GetPingCheckPeriod() const {\n+        const TDuration defaultValue = 0.6 * GetReadTimeoutClean();\n+        return DoGetPingCheckPeriod(defaultValue);\n+    }\n+\n     virtual bool IsBackgroundEnabled(const EBackground /*id*/) const {\n         return true;\n     }\n@@ -88,53 +158,51 @@ class ICSController {\n     using TPtr = std::shared_ptr<ICSController>;\n     virtual ~ICSController() = default;\n \n-    virtual TDuration GetOverridenGCPeriod(const TDuration def) const {\n-        return def;\n+    TDuration GetOverridenGCPeriod() const {\n+        const TDuration defaultValue = TDuration::MilliSeconds(GetConfig().GetGCIntervalMs());\n+        return DoGetOverridenGCPeriod(defaultValue);\n     }\n \n     virtual void OnSelectShardingFilter() {\n-    \n     }\n \n-    virtual TDuration GetCompactionActualizationLag(const TDuration def) const {\n-        return def;\n+    TDuration GetCompactionActualizationLag() const {\n+        const TDuration defaultValue = TDuration::MilliSeconds(GetConfig().GetCompactionActualizationLagMs());\n+        return DoGetCompactionActualizationLag(defaultValue);\n     }\n \n-    virtual NColumnShard::TBlobPutResult::TPtr OverrideBlobPutResultOnCompaction(const NColumnShard::TBlobPutResult::TPtr original, const NOlap::TWriteActionsCollection& /*actions*/) const {\n+    virtual NColumnShard::TBlobPutResult::TPtr OverrideBlobPutResultOnCompaction(\n+        const NColumnShard::TBlobPutResult::TPtr original, const NOlap::TWriteActionsCollection& /*actions*/) const {\n         return original;\n     }\n \n-    virtual TDuration GetRemovedPortionLivetime(const TDuration def) const {\n-        return def;\n+    TDuration GetActualizationTasksLag() const {\n+        const TDuration defaultValue = TDuration::MilliSeconds(GetConfig().GetActualizationTasksLagMs());\n+        return DoGetActualizationTasksLag(defaultValue);\n     }\n \n-    virtual TDuration GetActualizationTasksLag(const TDuration d) const {\n-        return d;\n+    ui64 GetReduceMemoryIntervalLimit() const {\n+        const ui64 defaultValue = NOlap::TGlobalLimits::DefaultReduceMemoryIntervalLimit;\n+        return DoGetReduceMemoryIntervalLimit(defaultValue);\n     }\n-\n-    virtual ui64 GetReduceMemoryIntervalLimit(const ui64 def) const {\n-        return def;\n-    }\n-    virtual ui64 GetRejectMemoryIntervalLimit(const ui64 def) const {\n-        return def;\n+    ui64 GetRejectMemoryIntervalLimit() const {\n+        const ui64 defaultValue = NOlap::TGlobalLimits::DefaultRejectMemoryIntervalLimit;\n+        return DoGetRejectMemoryIntervalLimit(defaultValue);\n     }\n     virtual bool NeedForceCompactionBacketsConstruction() const {\n         return false;\n     }\n-    virtual ui64 GetSmallPortionSizeDetector(const ui64 def) const {\n-        return def;\n+    ui64 GetSmallPortionSizeDetector() const {\n+        const ui64 defaultValue = GetConfig().GetSmallPortionDetectSizeLimit();\n+        return DoGetSmallPortionSizeDetector(defaultValue);\n     }\n     virtual void OnExportFinished() {\n-\n     }\n     virtual void OnActualizationRefreshScheme() {\n-\n     }\n     virtual void OnActualizationRefreshTiering() {\n-\n     }\n     virtual void AddPortionForActualizer(const i32 /*portionsCount*/) {\n-\n     }\n \n     void OnDataSharingFinished(const ui64 tabletId, const TString& sessionId) {\n@@ -144,16 +212,15 @@ class ICSController {\n         return DoOnDataSharingStarted(tabletId, sessionId);\n     }\n     virtual void OnStatisticsUsage(const NOlap::NIndexes::TIndexMetaContainer& /*statOperator*/) {\n-\n     }\n     virtual void OnPortionActualization(const NOlap::TPortionInfo& /*info*/) {\n-\n     }\n     virtual void OnMaxValueUsage() {\n     }\n \n-    virtual TDuration GetLagForCompactionBeforeTierings(const TDuration def) const {\n-        return def;\n+    virtual TDuration GetLagForCompactionBeforeTierings() const {\n+        const TDuration defaultValue = TDuration::MilliSeconds(GetConfig().GetLagForCompactionBeforeTieringsMs());\n+        return DoGetLagForCompactionBeforeTierings(defaultValue);\n     }\n \n     void OnTabletInitCompleted(const NColumnShard::TColumnShard& shard) {\n@@ -182,29 +249,20 @@ class ICSController {\n     }\n     virtual void OnIndexSelectProcessed(const std::optional<bool> /*result*/) {\n     }\n-    virtual TDuration GetReadTimeoutClean(const TDuration def) {\n-        return def;\n+    TDuration GetReadTimeoutClean() const {\n+        const TDuration defaultValue = TDuration::MilliSeconds(GetConfig().GetMaxReadStaleness_ms());\n+        return DoGetReadTimeoutClean(defaultValue);\n     }\n     virtual EOptimizerCompactionWeightControl GetCompactionControl() const {\n         return EOptimizerCompactionWeightControl::Force;\n     }\n-    virtual TDuration GetTTLDefaultWaitingDuration(const TDuration defaultValue) const {\n-        return defaultValue;\n-    }\n-    virtual TDuration GetGuaranteeIndexationInterval(const TDuration defaultValue) const {\n-        return defaultValue;\n-    }\n-    virtual TDuration GetPeriodicWakeupActivationPeriod(const TDuration defaultValue) const {\n-        return defaultValue;\n-    }\n-    virtual TDuration GetStatsReportInterval(const TDuration defaultValue) const {\n-        return defaultValue;\n-    }\n-    virtual ui64 GetGuaranteeIndexationStartBytesLimit(const ui64 defaultValue) const {\n-        return defaultValue;\n-    }\n-    virtual TDuration GetOptimizerFreshnessCheckDuration(const TDuration defaultValue) const {\n-        return defaultValue;\n+    TDuration GetGuaranteeIndexationInterval() const;\n+    TDuration GetPeriodicWakeupActivationPeriod() const;\n+    TDuration GetStatsReportInterval() const;\n+    ui64 GetGuaranteeIndexationStartBytesLimit() const;\n+    TDuration GetOptimizerFreshnessCheckDuration() const {\n+        const TDuration defaultValue = TDuration::MilliSeconds(GetConfig().GetOptimizerFreshnessCheckDurationMs());\n+        return DoGetOptimizerFreshnessCheckDuration(defaultValue);\n     }\n \n     virtual void OnTieringModified(const std::shared_ptr<NColumnShard::TTiersManager>& /*tiers*/) {\n@@ -215,7 +273,8 @@ class ICSController {\n     }\n \n     virtual NMetadata::NFetcher::ISnapshot::TPtr GetFallbackTiersSnapshot() const {\n-        static std::shared_ptr<NColumnShard::NTiers::TConfigsSnapshot> result = std::make_shared<NColumnShard::NTiers::TConfigsSnapshot>(TInstant::Now());\n+        static std::shared_ptr<NColumnShard::NTiers::TConfigsSnapshot> result =\n+            std::make_shared<NColumnShard::NTiers::TConfigsSnapshot>(TInstant::Now());\n         return result;\n     }\n \n@@ -231,15 +290,16 @@ class ICSController {\n class TControllers {\n private:\n     ICSController::TPtr CSController = std::make_shared<ICSController>();\n+\n public:\n     template <class TController>\n     class TGuard: TNonCopyable {\n     private:\n         std::shared_ptr<TController> Controller;\n+\n     public:\n         TGuard(std::shared_ptr<TController> controller)\n-            : Controller(controller)\n-        {\n+            : Controller(controller) {\n             Y_ABORT_UNLESS(Controller);\n         }\n \n@@ -270,4 +330,4 @@ class TControllers {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NYDBTest\ndiff --git a/ydb/core/tx/columnshard/inflight_request_tracker.cpp b/ydb/core/tx/columnshard/inflight_request_tracker.cpp\nindex 98ca6d7ab6da..6b7830b26cb0 100644\n--- a/ydb/core/tx/columnshard/inflight_request_tracker.cpp\n+++ b/ydb/core/tx/columnshard/inflight_request_tracker.cpp\n@@ -1,90 +1,155 @@\n+#include \"columnshard_impl.h\"\n+#include \"columnshard_schema.h\"\n #include \"inflight_request_tracker.h\"\n+\n+#include \"data_sharing/common/transactions/tx_extension.h\"\n #include \"engines/column_engine.h\"\n #include \"engines/reader/plain_reader/constructor/read_metadata.h\"\n+#include \"hooks/abstract/abstract.h\"\n \n namespace NKikimr::NColumnShard {\n \n-void TInFlightReadsTracker::RemoveInFlightRequest(ui64 cookie, const NOlap::TVersionedIndex* index) {\n-    Y_ABORT_UNLESS(RequestsMeta.contains(cookie), \"Unknown request cookie %\" PRIu64, cookie);\n-    const auto& readMetaList = RequestsMeta[cookie];\n-\n-    for (const auto& readMetaBase : readMetaList) {\n-        NOlap::NReader::NPlain::TReadMetadata::TConstPtr readMeta = std::dynamic_pointer_cast<const NOlap::NReader::NPlain::TReadMetadata>(readMetaBase);\n-\n-        if (!readMeta) {\n-            continue;\n-        }\n-\n-        THashMap<TString, THashSet<NOlap::TUnifiedBlobId>> portionBlobIds;\n-        for (const auto& portion : readMeta->SelectInfo->PortionsOrderedPK) {\n-            const ui64 portionId = portion->GetPortion();\n-            AFL_VERIFY(index);\n-            portion->FillBlobIdsByStorage(portionBlobIds, *index);\n-            auto it = PortionUseCount.find(portionId);\n-            Y_ABORT_UNLESS(it != PortionUseCount.end(), \"Portion id %\" PRIu64 \" not found in request %\" PRIu64, portionId, cookie);\n-            if (it->second == 1) {\n-                PortionUseCount.erase(it);\n-            } else {\n-                it->second--;\n+NOlap::NReader::TReadMetadataBase::TConstPtr TInFlightReadsTracker::ExtractInFlightRequest(\n+    ui64 cookie, const NOlap::TVersionedIndex* /*index*/, const TInstant now) {\n+    auto it = RequestsMeta.find(cookie);\n+    AFL_VERIFY(it != RequestsMeta.end())(\"cookie\", cookie);\n+    const NOlap::NReader::TReadMetadataBase::TConstPtr readMetaBase = it->second;\n+\n+    {\n+        {\n+            auto it = SnapshotsLive.find(readMetaBase->GetRequestSnapshot());\n+            AFL_VERIFY(it != SnapshotsLive.end());\n+            if (it->second.DelRequest(cookie, now)) {\n+                SnapshotsLive.erase(it);\n             }\n         }\n \n-        for (auto&& i : portionBlobIds) {\n-            auto storage = StoragesManager->GetOperatorVerified(i.first);\n-            auto tracker = storage->GetBlobsTracker();\n-            for (auto& blobId : i.second) {\n-                tracker->FreeBlob(blobId);\n+        if (NOlap::NReader::NPlain::TReadMetadata::TConstPtr readMeta =\n+                std::dynamic_pointer_cast<const NOlap::NReader::NPlain::TReadMetadata>(readMetaBase)) {\n+            auto insertStorage = StoragesManager->GetInsertOperator();\n+            auto tracker = insertStorage->GetBlobsTracker();\n+            for (const auto& committedBlob : readMeta->CommittedBlobs) {\n+                tracker->FreeBlob(committedBlob.GetBlobRange().GetBlobId());\n             }\n         }\n-\n-        auto insertStorage = StoragesManager->GetInsertOperator();\n-        auto tracker = insertStorage->GetBlobsTracker();\n-        for (const auto& committedBlob : readMeta->CommittedBlobs) {\n-            tracker->FreeBlob(committedBlob.GetBlobRange().GetBlobId());\n-        }\n     }\n+    Counters->OnSnapshotsInfo(SnapshotsLive.size(), GetSnapshotToClean());\n \n     RequestsMeta.erase(cookie);\n+    return readMetaBase;\n }\n \n-TConclusionStatus TInFlightReadsTracker::AddToInFlightRequest(const ui64 cookie, NOlap::NReader::TReadMetadataBase::TConstPtr readMetaBase, const NOlap::TVersionedIndex* index) {\n-    RequestsMeta[cookie].push_back(readMetaBase);\n+void TInFlightReadsTracker::AddToInFlightRequest(\n+    const ui64 cookie, NOlap::NReader::TReadMetadataBase::TConstPtr readMetaBase, const NOlap::TVersionedIndex* /*index*/) {\n+    AFL_VERIFY(RequestsMeta.emplace(cookie, readMetaBase).second);\n \n     auto readMeta = std::dynamic_pointer_cast<const NOlap::NReader::NPlain::TReadMetadata>(readMetaBase);\n \n     if (!readMeta) {\n-        return TConclusionStatus::Success();\n+        return;\n     }\n \n     auto selectInfo = readMeta->SelectInfo;\n     Y_ABORT_UNLESS(selectInfo);\n     SelectStatsDelta += selectInfo->Stats();\n \n-    THashMap<TString, THashSet<NOlap::TUnifiedBlobId>> portionBlobIds;\n-    for (const auto& portion : readMeta->SelectInfo->PortionsOrderedPK) {\n-        const ui64 portionId = portion->GetPortion();\n-        PortionUseCount[portionId]++;\n-        AFL_VERIFY(index);\n-        portion->FillBlobIdsByStorage(portionBlobIds, *index);\n+    auto insertStorage = StoragesManager->GetInsertOperator();\n+    auto tracker = insertStorage->GetBlobsTracker();\n+    for (const auto& committedBlob : readMeta->CommittedBlobs) {\n+        tracker->UseBlob(committedBlob.GetBlobRange().GetBlobId());\n     }\n+}\n \n-    for (auto&& i : portionBlobIds) {\n-        auto storage = StoragesManager->GetOperatorOptional(i.first);\n-        if (!storage) {\n-            return TConclusionStatus::Fail(\"blobs storage info not ready for '\" + i.first + \"'\");\n+namespace {\n+class TTransactionSavePersistentSnapshots: public NOlap::NDataSharing::TExtendedTransactionBase<NColumnShard::TColumnShard> {\n+private:\n+    using TBase = NOlap::NDataSharing::TExtendedTransactionBase<NColumnShard::TColumnShard>;\n+    const std::set<NOlap::TSnapshot> SaveSnapshots;\n+    const std::set<NOlap::TSnapshot> RemoveSnapshots;\n+    virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const TActorContext& /*ctx*/) override {\n+        using namespace NColumnShard;\n+        NIceDb::TNiceDb db(txc.DB);\n+        for (auto&& i : SaveSnapshots) {\n+            db.Table<Schema::InFlightSnapshots>().Key(i.GetPlanStep(), i.GetTxId()).Update();\n         }\n-        auto tracker = storage->GetBlobsTracker();\n-        for (auto& blobId : i.second) {\n-            tracker->UseBlob(blobId);\n+        for (auto&& i : RemoveSnapshots) {\n+            db.Table<Schema::InFlightSnapshots>().Key(i.GetPlanStep(), i.GetTxId()).Delete();\n         }\n+        return true;\n     }\n \n-    auto insertStorage = StoragesManager->GetInsertOperator();\n-    auto tracker = insertStorage->GetBlobsTracker();\n-    for (const auto& committedBlob : readMeta->CommittedBlobs) {\n-        tracker->UseBlob(committedBlob.GetBlobRange().GetBlobId());\n+    virtual void DoComplete(const TActorContext& /*ctx*/) override {\n+    }\n+\n+public:\n+    TTransactionSavePersistentSnapshots(\n+        NColumnShard::TColumnShard* self, std::set<NOlap::TSnapshot>&& saveSnapshots, std::set<NOlap::TSnapshot>&& removeSnapshots)\n+        : TBase(self)\n+        , SaveSnapshots(std::move(saveSnapshots))\n+        , RemoveSnapshots(std::move(removeSnapshots)) {\n+        AFL_VERIFY(SaveSnapshots.size() || RemoveSnapshots.size());\n+    }\n+};\n+}   // namespace\n+\n+std::unique_ptr<NTabletFlatExecutor::ITransaction> TInFlightReadsTracker::Ping(\n+    TColumnShard* self, const TDuration critDuration, const TInstant now) {\n+    std::set<NOlap::TSnapshot> snapshotsToSave;\n+    std::set<NOlap::TSnapshot> snapshotsToFree;\n+    for (auto&& i : SnapshotsLive) {\n+        if (i.second.Ping(critDuration, now)) {\n+            if (i.second.GetIsLock()) {\n+                Counters->OnSnapshotLocked();\n+                snapshotsToSave.emplace(i.first);\n+            } else {\n+                Counters->OnSnapshotUnlocked();\n+                snapshotsToFree.emplace(i.first);\n+            }\n+        }\n+    }\n+    for (auto&& i : snapshotsToFree) {\n+        SnapshotsLive.erase(i);\n+    }\n+    Counters->OnSnapshotsInfo(SnapshotsLive.size(), GetSnapshotToClean());\n+    if (snapshotsToFree.size() || snapshotsToSave.size()) {\n+        NYDBTest::TControllers::GetColumnShardController()->OnRequestTracingChanges(snapshotsToSave, snapshotsToFree);\n+        return std::make_unique<TTransactionSavePersistentSnapshots>(self, std::move(snapshotsToSave), std::move(snapshotsToFree));\n+    } else {\n+        return nullptr;\n     }\n-    return TConclusionStatus::Success();\n }\n \n+bool TInFlightReadsTracker::LoadFromDatabase(NTable::TDatabase& tableDB) {\n+    NIceDb::TNiceDb db(tableDB);\n+    auto rowset = db.Table<Schema::InFlightSnapshots>().Select();\n+    if (!rowset.IsReady()) {\n+        return false;\n+    }\n+\n+    while (!rowset.EndOfSet()) {\n+        const NOlap::TSnapshot snapshot(\n+            rowset.GetValue<Schema::InFlightSnapshots::PlanStep>(), rowset.GetValue<Schema::InFlightSnapshots::TxId>());\n+        AFL_VERIFY(SnapshotsLive.emplace(snapshot, TSnapshotLiveInfo::BuildFromDatabase(snapshot)).second);\n+\n+        if (!rowset.Next()) {\n+            return false;\n+        }\n+    }\n+    Counters->OnSnapshotsInfo(SnapshotsLive.size(), GetSnapshotToClean());\n+    return true;\n }\n+\n+ui64 TInFlightReadsTracker::AddInFlightRequest(\n+    NOlap::NReader::TReadMetadataBase::TConstPtr readMeta, const NOlap::TVersionedIndex* index) {\n+    const ui64 cookie = NextCookie++;\n+    auto it = SnapshotsLive.find(readMeta->GetRequestSnapshot());\n+    if (it == SnapshotsLive.end()) {\n+        it = SnapshotsLive.emplace(readMeta->GetRequestSnapshot(), TSnapshotLiveInfo::BuildFromRequest(readMeta->GetRequestSnapshot())).first;\n+        Counters->OnSnapshotsInfo(SnapshotsLive.size(), GetSnapshotToClean());\n+    }\n+    it->second.AddRequest(cookie);\n+    AddToInFlightRequest(cookie, readMeta, index);\n+    return cookie;\n+}\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/inflight_request_tracker.h b/ydb/core/tx/columnshard/inflight_request_tracker.h\nindex d530c11d7a4f..0aeec5acddbe 100644\n--- a/ydb/core/tx/columnshard/inflight_request_tracker.h\n+++ b/ydb/core/tx/columnshard/inflight_request_tracker.h\n@@ -1,6 +1,9 @@\n #pragma once\n \n #include \"blob.h\"\n+\n+#include \"counters/req_tracer.h\"\n+\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h>\n \n namespace NKikimr::NOlap {\n@@ -8,49 +11,111 @@ class TVersionedIndex;\n }\n \n namespace NKikimr::NColumnShard {\n-\n+class TColumnShard;\n using NOlap::IBlobInUseTracker;\n \n-class TInFlightReadsTracker {\n+class TSnapshotLiveInfo {\n+private:\n+    const NOlap::TSnapshot Snapshot;\n+    std::optional<TInstant> LastPingInstant;\n+    std::optional<TInstant> LastRequestFinishedInstant;\n+    THashSet<ui32> Requests;\n+    YDB_READONLY(bool, IsLock, false);\n+\n+    TSnapshotLiveInfo(const NOlap::TSnapshot& snapshot)\n+        : Snapshot(snapshot) {\n+    }\n+\n public:\n-    // Returns a unique cookie associated with this request\n-    [[nodiscard]] TConclusion<ui64> AddInFlightRequest(NOlap::NReader::TReadMetadataBase::TConstPtr readMeta, const NOlap::TVersionedIndex* index) {\n-        const ui64 cookie = NextCookie++;\n-        auto status = AddToInFlightRequest(cookie, readMeta, index);\n-        if (!status) {\n-            return status;\n+    void AddRequest(const ui32 cookie) {\n+        AFL_VERIFY(Requests.emplace(cookie).second);\n+    }\n+\n+    [[nodiscard]] bool DelRequest(const ui32 cookie, const TInstant now) {\n+        AFL_VERIFY(Requests.erase(cookie));\n+        if (Requests.empty()) {\n+            LastRequestFinishedInstant = now;\n+        }\n+        if (!IsLock && Requests.empty()) {\n+            return true;\n         }\n-        return cookie;\n+        return false;\n     }\n \n-    void RemoveInFlightRequest(ui64 cookie, const NOlap::TVersionedIndex* index);\n+    static TSnapshotLiveInfo BuildFromRequest(const NOlap::TSnapshot& reqSnapshot) {\n+        return TSnapshotLiveInfo(reqSnapshot);\n+    }\n \n-    // Checks if the portion is in use by any in-flight request\n-    bool IsPortionUsed(ui64 portionId) const {\n-        return PortionUseCount.contains(portionId);\n+    static TSnapshotLiveInfo BuildFromDatabase(const NOlap::TSnapshot& reqSnapshot) {\n+        TSnapshotLiveInfo result(reqSnapshot);\n+        result.LastPingInstant = TInstant::Now();\n+        result.LastRequestFinishedInstant = result.LastPingInstant;\n+        result.IsLock = true;\n+        return result;\n     }\n \n+    bool Ping(const TDuration critDuration, const TInstant now) {\n+        LastPingInstant = now;\n+        if (Requests.empty()) {\n+            AFL_VERIFY(LastRequestFinishedInstant);\n+            if (critDuration < *LastPingInstant - *LastRequestFinishedInstant && IsLock) {\n+                IsLock = false;\n+                return true;\n+            }\n+        } else {\n+            if (critDuration < *LastPingInstant - Snapshot.GetPlanInstant() && !IsLock) {\n+                IsLock = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+};\n+\n+class TInFlightReadsTracker {\n+private:\n+    std::map<NOlap::TSnapshot, TSnapshotLiveInfo> SnapshotsLive;\n+    std::shared_ptr<TRequestsTracerCounters> Counters;\n+\n+public:\n+    std::optional<NOlap::TSnapshot> GetSnapshotToClean() const {\n+        if (SnapshotsLive.empty()) {\n+            return std::nullopt;\n+        } else {\n+            return SnapshotsLive.begin()->first;\n+        }\n+    }\n+\n+    bool LoadFromDatabase(NTable::TDatabase& db);\n+\n+    [[nodiscard]] std::unique_ptr<NTabletFlatExecutor::ITransaction> Ping(TColumnShard* self, const TDuration critDuration, const TInstant now);\n+\n+    // Returns a unique cookie associated with this request\n+    [[nodiscard]] ui64 AddInFlightRequest(\n+        NOlap::NReader::TReadMetadataBase::TConstPtr readMeta, const NOlap::TVersionedIndex* index);\n+\n+    [[nodiscard]] NOlap::NReader::TReadMetadataBase::TConstPtr ExtractInFlightRequest(ui64 cookie, const NOlap::TVersionedIndex* index, const TInstant now);\n+\n     NOlap::TSelectInfo::TStats GetSelectStatsDelta() {\n         auto delta = SelectStatsDelta;\n         SelectStatsDelta = NOlap::TSelectInfo::TStats();\n         return delta;\n     }\n \n-    TInFlightReadsTracker(const std::shared_ptr<NOlap::IStoragesManager>& storagesManager)\n-        : StoragesManager(storagesManager)\n-    {\n-\n+    TInFlightReadsTracker(const std::shared_ptr<NOlap::IStoragesManager>& storagesManager, const std::shared_ptr<TRequestsTracerCounters>& counters)\n+        : Counters(counters)\n+        , StoragesManager(storagesManager) {\n     }\n \n private:\n-    [[nodiscard]] TConclusionStatus AddToInFlightRequest(const ui64 cookie, NOlap::NReader::TReadMetadataBase::TConstPtr readMetaBase, const NOlap::TVersionedIndex* index);\n+    void AddToInFlightRequest(\n+        const ui64 cookie, NOlap::NReader::TReadMetadataBase::TConstPtr readMetaBase, const NOlap::TVersionedIndex* index);\n \n private:\n     std::shared_ptr<NOlap::IStoragesManager> StoragesManager;\n-    ui64 NextCookie{1};\n-    THashMap<ui64, TList<NOlap::NReader::TReadMetadataBase::TConstPtr>> RequestsMeta;\n-    THashMap<ui64, ui64> PortionUseCount;\n+    ui64 NextCookie = 1;\n+    THashMap<ui64, NOlap::NReader::TReadMetadataBase::TConstPtr> RequestsMeta;\n     NOlap::TSelectInfo::TStats SelectStatsDelta;\n };\n \n-}\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/normalizer/abstract/abstract.h b/ydb/core/tx/columnshard/normalizer/abstract/abstract.h\nindex 55b0da0e6b92..e75099ecd9ba 100644\n--- a/ydb/core/tx/columnshard/normalizer/abstract/abstract.h\n+++ b/ydb/core/tx/columnshard/normalizer/abstract/abstract.h\n@@ -57,6 +57,8 @@ enum class ENormalizerSequentialId: ui32 {\n     PortionsMetadata,\n     CleanGranuleId,\n     EmptyPortionsCleaner,\n+    CleanInsertionDedup,\n+    GCCountersNormalizer,\n \n     MAX\n };\ndiff --git a/ydb/core/tx/columnshard/normalizer/insert_table/broken_dedup.cpp b/ydb/core/tx/columnshard/normalizer/insert_table/broken_dedup.cpp\nnew file mode 100644\nindex 000000000000..5a0934261879\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/normalizer/insert_table/broken_dedup.cpp\n@@ -0,0 +1,151 @@\n+#include \"broken_dedup.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_private_events.h>\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+\n+namespace NKikimr::NOlap::NInsertionDedup {\n+\n+class TNormalizerRemoveChanges: public INormalizerChanges {\n+private:\n+    std::vector<TInsertTableRecordLoadContext> Insertions;\n+public:\n+    virtual bool ApplyOnExecute(NTabletFlatExecutor::TTransactionContext& txc, const TNormalizationController& /*normalizationContext*/) const override {\n+        NIceDb::TNiceDb db(txc.DB);\n+        for (auto&& i : Insertions) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"remove_aborted_record\")(\"write_id\", i.GetInsertWriteId());\n+            i.Remove(db);\n+        }\n+        return true;\n+    }\n+    virtual void ApplyOnComplete(const TNormalizationController& /*normalizationContext*/) const override {\n+\n+    }\n+\n+    virtual ui64 GetSize() const override {\n+        return Insertions.size();\n+    }\n+\n+    TNormalizerRemoveChanges(const std::vector<TInsertTableRecordLoadContext>& insertions)\n+        : Insertions(insertions)\n+    {\n+\n+    }\n+};\n+\n+class TNormalizerCleanDedupChanges: public INormalizerChanges {\n+private:\n+    mutable std::vector<TInsertTableRecordLoadContext> Insertions;\n+\n+public:\n+    virtual bool ApplyOnExecute(\n+        NTabletFlatExecutor::TTransactionContext& txc, const TNormalizationController& /*normalizationContext*/) const override {\n+        NIceDb::TNiceDb db(txc.DB);\n+        for (auto&& i : Insertions) {\n+            AFL_VERIFY(i.GetDedupId());\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"correct_record\")(\"dedup\", i.GetDedupId());\n+            i.Remove(db);\n+            i.SetDedupId(\"\");\n+            i.Upsert(db);\n+        }\n+        return true;\n+    }\n+    virtual void ApplyOnComplete(const TNormalizationController& /*normalizationContext*/) const override {\n+    }\n+\n+    virtual ui64 GetSize() const override {\n+        return Insertions.size();\n+    }\n+\n+    TNormalizerCleanDedupChanges(const std::vector<TInsertTableRecordLoadContext>& insertions)\n+        : Insertions(insertions) {\n+    }\n+};\n+\n+\n+class TCollectionStates {\n+private:\n+    YDB_READONLY_DEF(std::optional<TInsertTableRecordLoadContext>, Inserted);\n+    YDB_READONLY_DEF(std::optional<TInsertTableRecordLoadContext>, Aborted);\n+public:\n+    void SetInserted(const TInsertTableRecordLoadContext& context) {\n+        AFL_VERIFY(!Inserted);\n+        Inserted = context;\n+    }\n+    void SetAborted(const TInsertTableRecordLoadContext& context) {\n+        AFL_VERIFY(!Aborted);\n+        Aborted = context;\n+    }\n+};\n+\n+TConclusion<std::vector<INormalizerTask::TPtr>> TInsertionsDedupNormalizer::DoInit(\n+    const TNormalizationController& /*controller*/, NTabletFlatExecutor::TTransactionContext& txc) {\n+    NIceDb::TNiceDb db(txc.DB);\n+\n+    using namespace NColumnShard;\n+    auto rowset = db.Table<NColumnShard::Schema::InsertTable>().Select();\n+    if (!rowset.IsReady()) {\n+        return TConclusionStatus::Fail(\"cannot read insertion info\");\n+    }\n+    THashMap<TInsertWriteId, TCollectionStates> insertions;\n+    while (!rowset.EndOfSet()) {\n+        TInsertTableRecordLoadContext constructor;\n+        constructor.ParseFromDatabase(rowset);\n+        if (constructor.GetRecType() == NColumnShard::Schema::EInsertTableIds::Committed) {\n+            AFL_VERIFY(constructor.GetPlanStep());\n+        } else {\n+            AFL_VERIFY(!constructor.GetPlanStep());\n+            if (constructor.GetRecType() == NColumnShard::Schema::EInsertTableIds::Aborted) {\n+                insertions[constructor.GetInsertWriteId()].SetAborted(constructor);\n+            } else if (constructor.GetRecType() == NColumnShard::Schema::EInsertTableIds::Inserted) {\n+                insertions[constructor.GetInsertWriteId()].SetInserted(constructor);\n+            } else {\n+                AFL_VERIFY(false);\n+            }\n+        }\n+        if (!rowset.Next()) {\n+            return TConclusionStatus::Fail(\"cannot read insertion info\");\n+        }\n+    }\n+\n+    std::vector<INormalizerTask::TPtr> result;\n+    std::vector<TInsertTableRecordLoadContext> toRemove;\n+    std::vector<TInsertTableRecordLoadContext> toCleanDedup;\n+    for (auto&& [id, i] : insertions) {\n+        if (i.GetInserted() && i.GetAborted()) {\n+            toRemove.emplace_back(*i.GetInserted());\n+            if (i.GetAborted()->GetDedupId()) {\n+                toCleanDedup.emplace_back(*i.GetAborted());\n+            }\n+        } else if (i.GetAborted()) {\n+            if (i.GetAborted()->GetDedupId()) {\n+                toCleanDedup.emplace_back(*i.GetAborted());\n+            }\n+        } else if (i.GetInserted()) {\n+            if (i.GetInserted()->GetDedupId()) {\n+                toCleanDedup.emplace_back(*i.GetInserted());\n+            }\n+        } else {\n+            AFL_VERIFY(false);\n+        }\n+        if (toCleanDedup.size() == 1000) {\n+            result.emplace_back(std::make_shared<TTrivialNormalizerTask>(std::make_shared<TNormalizerCleanDedupChanges>(toCleanDedup)));\n+            toCleanDedup.clear();\n+        }\n+        if (toRemove.size() == 1000) {\n+            result.emplace_back(std::make_shared<TTrivialNormalizerTask>(std::make_shared<TNormalizerRemoveChanges>(toRemove)));\n+            toRemove.clear();\n+        }\n+    }\n+    if (toCleanDedup.size()) {\n+        result.emplace_back(std::make_shared<TTrivialNormalizerTask>(std::make_shared<TNormalizerCleanDedupChanges>(toCleanDedup)));\n+        toCleanDedup.clear();\n+    }\n+    if (toRemove.size()) {\n+        result.emplace_back(std::make_shared<TTrivialNormalizerTask>(std::make_shared<TNormalizerRemoveChanges>(toRemove)));\n+        toRemove.clear();\n+    }\n+\n+    return result;\n+}\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/normalizer/insert_table/broken_dedup.h b/ydb/core/tx/columnshard/normalizer/insert_table/broken_dedup.h\nnew file mode 100644\nindex 000000000000..c9a935e24371\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/normalizer/insert_table/broken_dedup.h\n@@ -0,0 +1,35 @@\n+#pragma once\n+\n+#include <ydb/core/tx/columnshard/normalizer/abstract/abstract.h>\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+\n+\n+namespace NKikimr::NOlap::NInsertionDedup {\n+\n+class TInsertionsDedupNormalizer: public TNormalizationController::INormalizerComponent {\n+public:\n+    static TString GetClassNameStatic() {\n+        return \"CleanInsertionDedup\";\n+    }\n+private:\n+    class TNormalizerResult;\n+\n+    static const inline INormalizerComponent::TFactory::TRegistrator<TInsertionsDedupNormalizer> Registrator =\n+        INormalizerComponent::TFactory::TRegistrator<TInsertionsDedupNormalizer>(GetClassNameStatic());\n+\n+public:\n+    TInsertionsDedupNormalizer(const TNormalizationController::TInitContext&) {\n+    }\n+\n+    virtual std::optional<ENormalizerSequentialId> DoGetEnumSequentialId() const override {\n+        return ENormalizerSequentialId::CleanInsertionDedup;\n+    }\n+\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+\n+    virtual TConclusion<std::vector<INormalizerTask::TPtr>> DoInit(const TNormalizationController& controller, NTabletFlatExecutor::TTransactionContext& txc) override;\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/normalizer/insert_table/ya.make b/ydb/core/tx/columnshard/normalizer/insert_table/ya.make\nnew file mode 100644\nindex 000000000000..99cdc40cfaf4\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/normalizer/insert_table/ya.make\n@@ -0,0 +1,11 @@\n+LIBRARY()\n+\n+SRCS(\n+    GLOBAL broken_dedup.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/tx/columnshard/normalizer/abstract\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp b/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp\nindex d7981d98d629..f42f38061e45 100644\n--- a/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp\n+++ b/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp\n@@ -59,11 +59,12 @@ class TRowsAndBytesChangesTask: public NConveyor::ITask {\n             Y_ABORT_UNLESS(!!columnLoader);\n \n             TPortionInfo::TAssembleBlobInfo assembleBlob(blobData);\n+            assembleBlob.SetExpectedRecordsCount(chunkInfo.GetRecordsCount());\n             auto batch = assembleBlob.BuildRecordBatch(*columnLoader);\n             Y_ABORT_UNLESS(!!batch);\n \n-            chunkInfo.MutableUpdate().SetNumRows(batch->num_rows());\n-            chunkInfo.MutableUpdate().SetRawBytes(NArrow::GetBatchDataSize(batch));\n+            chunkInfo.MutableUpdate().SetNumRows(batch->GetRecordsCount());\n+            chunkInfo.MutableUpdate().SetRawBytes(batch->GetRawSizeVerified());\n         }\n \n         auto changes = std::make_shared<TChunksNormalizer::TNormalizerResult>(std::move(Chunks));\ndiff --git a/ydb/core/tx/columnshard/normalizer/portion/chunks.h b/ydb/core/tx/columnshard/normalizer/portion/chunks.h\nindex 59fbfe57da0c..c8a09669c7b8 100644\n--- a/ydb/core/tx/columnshard/normalizer/portion/chunks.h\n+++ b/ydb/core/tx/columnshard/normalizer/portion/chunks.h\n@@ -74,6 +74,10 @@ namespace NKikimr::NOlap {\n                 , CLContext(rowset, dsGroupSelector)\n             {}\n \n+            ui32 GetRecordsCount() const {\n+                return CLContext.GetMetaProto().GetNumRows();\n+            }\n+\n             const TBlobRange& GetBlobRange() const {\n                 return CLContext.GetBlobRange();\n             }\ndiff --git a/ydb/core/tx/columnshard/normalizer/tablet/broken_txs.cpp b/ydb/core/tx/columnshard/normalizer/tablet/broken_txs.cpp\nnew file mode 100644\nindex 000000000000..1b41c455217b\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/normalizer/tablet/broken_txs.cpp\n@@ -0,0 +1,31 @@\n+#include \"broken_txs.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_private_events.h>\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+\n+namespace NKikimr::NOlap {\n+\n+TConclusion<std::vector<INormalizerTask::TPtr>> TBrokenTxsNormalizer::DoInit(\n+    const TNormalizationController& /*controller*/, NTabletFlatExecutor::TTransactionContext& txc) {\n+    NIceDb::TNiceDb db(txc.DB);\n+\n+    using namespace NColumnShard;\n+    auto rowset = db.Table<Schema::TxInfo>().GreaterOrEqual(0).Select();\n+    if (!rowset.IsReady()) {\n+        return TConclusionStatus::Fail(\"cannot read TxInfo\");\n+    }\n+    while (!rowset.EndOfSet()) {\n+        const ui64 txId = rowset.GetValue<Schema::TxInfo::TxId>();\n+        if (!rowset.HaveValue<Schema::TxInfo::TxKind>()) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"tx_id\", txId)(\"event\", \"removed_by_normalizer\")(\"condition\", \"no_kind\");\n+            Schema::EraseTxInfo(db, txId);\n+        }\n+\n+        if (!rowset.Next()) {\n+            return TConclusionStatus::Fail(\"cannot read TxInfo\");\n+        }\n+    }\n+    return std::vector<INormalizerTask::TPtr>();\n+}\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/normalizer/tablet/broken_txs.h b/ydb/core/tx/columnshard/normalizer/tablet/broken_txs.h\nnew file mode 100644\nindex 000000000000..1ff68530bf35\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/normalizer/tablet/broken_txs.h\n@@ -0,0 +1,35 @@\n+#pragma once\n+\n+#include <ydb/core/tx/columnshard/normalizer/abstract/abstract.h>\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+\n+\n+namespace NKikimr::NOlap {\n+\n+class TBrokenTxsNormalizer: public TNormalizationController::INormalizerComponent {\n+public:\n+    static TString GetClassNameStatic() {\n+        return \"BrokenTxsNormalizer\";\n+    }\n+private:\n+    class TNormalizerResult;\n+\n+    static const inline INormalizerComponent::TFactory::TRegistrator<TBrokenTxsNormalizer> Registrator = \n+        INormalizerComponent::TFactory::TRegistrator<TBrokenTxsNormalizer>(GetClassNameStatic());\n+\n+public:\n+    TBrokenTxsNormalizer(const TNormalizationController::TInitContext&) {\n+    }\n+\n+    virtual std::optional<ENormalizerSequentialId> DoGetEnumSequentialId() const override {\n+        return {};\n+    }\n+\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+\n+    virtual TConclusion<std::vector<INormalizerTask::TPtr>> DoInit(const TNormalizationController& controller, NTabletFlatExecutor::TTransactionContext& txc) override;\n+};\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/normalizer/tablet/gc_counters.h b/ydb/core/tx/columnshard/normalizer/tablet/gc_counters.h\nindex 80b56c080071..8787da559489 100644\n--- a/ydb/core/tx/columnshard/normalizer/tablet/gc_counters.h\n+++ b/ydb/core/tx/columnshard/normalizer/tablet/gc_counters.h\n@@ -21,7 +21,7 @@ class TGCCountersNormalizer: public TNormalizationController::INormalizerCompone\n     }\n \n     virtual std::optional<ENormalizerSequentialId> DoGetEnumSequentialId() const override {\n-        return {};\n+        return ENormalizerSequentialId::GCCountersNormalizer;\n     }\n \n     virtual TString GetClassName() const override {\ndiff --git a/ydb/core/tx/columnshard/normalizer/tablet/ya.make b/ydb/core/tx/columnshard/normalizer/tablet/ya.make\nindex 9be6336eede5..0b39efc35b5b 100644\n--- a/ydb/core/tx/columnshard/normalizer/tablet/ya.make\n+++ b/ydb/core/tx/columnshard/normalizer/tablet/ya.make\n@@ -2,6 +2,7 @@ LIBRARY()\n \n SRCS(\n     GLOBAL gc_counters.cpp\n+    GLOBAL broken_txs.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/core/tx/columnshard/normalizer/ya.make b/ydb/core/tx/columnshard/normalizer/ya.make\nindex 46f7baeaea98..ced78fd812af 100644\n--- a/ydb/core/tx/columnshard/normalizer/ya.make\n+++ b/ydb/core/tx/columnshard/normalizer/ya.make\n@@ -6,6 +6,7 @@ PEERDIR(\n     ydb/core/tx/columnshard/normalizer/tablet\n     ydb/core/tx/columnshard/normalizer/tables\n     ydb/core/tx/columnshard/normalizer/portion\n+    ydb/core/tx/columnshard/normalizer/insert_table\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp b/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp\nindex 232d3b556e95..39aa61a9a008 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp\n@@ -10,31 +10,36 @@\n \n namespace NKikimr::NOlap {\n \n-void TBuildBatchesTask::ReplyError(const TString& message) {\n+void TBuildBatchesTask::ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass) {\n+    AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"problem\", \"cannot build batch for insert\")(\"reason\", message)(\"data\", WriteData.GetWriteMeta().GetLongTxIdOptional());\n     auto writeDataPtr = std::make_shared<NEvWrite::TWriteData>(std::move(WriteData));\n     TWritingBuffer buffer(writeDataPtr->GetBlobsAction(), { std::make_shared<TWriteAggregation>(*writeDataPtr) });\n-    auto result = NColumnShard::TEvPrivate::TEvWriteBlobsResult::Error(NKikimrProto::EReplyStatus::CORRUPTED, std::move(buffer), message);\n+    auto result =\n+        NColumnShard::TEvPrivate::TEvWriteBlobsResult::Error(NKikimrProto::EReplyStatus::CORRUPTED, std::move(buffer), message, errorClass);\n     TActorContext::AsActorContext().Send(ParentActorId, result.release());\n }\n \n TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n     TConclusion<std::shared_ptr<arrow::RecordBatch>> batchConclusion = WriteData.GetData()->ExtractBatch();\n     if (batchConclusion.IsFail()) {\n-        ReplyError(\"cannot extract incoming batch: \" + batchConclusion.GetErrorMessage());\n+        ReplyError(\n+            \"cannot extract incoming batch: \" + batchConclusion.GetErrorMessage(), NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n         return TConclusionStatus::Fail(\"cannot extract incoming batch: \" + batchConclusion.GetErrorMessage());\n     }\n+    WritingCounters->OnIncomingData(NArrow::GetBatchDataSize(*batchConclusion));\n \n     auto preparedConclusion =\n         ActualSchema->PrepareForModification(batchConclusion.DetachResult(), WriteData.GetWriteMeta().GetModificationType());\n     if (preparedConclusion.IsFail()) {\n-        ReplyError(\"cannot prepare incoming batch: \" + preparedConclusion.GetErrorMessage());\n+        ReplyError(\"cannot prepare incoming batch: \" + preparedConclusion.GetErrorMessage(),\n+            NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n         return TConclusionStatus::Fail(\"cannot prepare incoming batch: \" + preparedConclusion.GetErrorMessage());\n     }\n     auto batch = preparedConclusion.DetachResult();\n-    const std::vector<std::shared_ptr<arrow::Field>> defaultFields = ActualSchema->GetAbsentFields(batch->schema());\n     std::shared_ptr<IMerger> merger;\n     switch (WriteData.GetWriteMeta().GetModificationType()) {\n         case NEvWrite::EModificationType::Upsert: {\n+            const std::vector<std::shared_ptr<arrow::Field>> defaultFields = ActualSchema->GetAbsentFields(batch->schema());\n             if (defaultFields.empty()) {\n                 std::shared_ptr<NConveyor::ITask> task =\n                     std::make_shared<NOlap::TBuildSlicesTask>(TabletId, ParentActorId, BufferActorId, std::move(WriteData), batch, ActualSchema);\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/builder.h b/ydb/core/tx/columnshard/operations/batch_builder/builder.h\nindex aba480a398f9..31ca0ac7ac43 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/builder.h\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/builder.h\n@@ -1,5 +1,7 @@\n #pragma once\n+#include <ydb/core/tx/columnshard/columnshard_private_events.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n+#include <ydb/core/tx/columnshard/counters/columnshard.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n #include <ydb/core/tx/conveyor/usage/abstract.h>\n #include <ydb/core/tx/data_events/write_data.h>\n@@ -14,7 +16,9 @@ class TBuildBatchesTask: public NConveyor::ITask {\n     const NActors::TActorId BufferActorId;\n     const std::shared_ptr<ISnapshotSchema> ActualSchema;\n     const TSnapshot ActualSnapshot;\n-    void ReplyError(const TString& message);\n+    const std::shared_ptr<NColumnShard::TWriteCounters> WritingCounters;\n+    void ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);\n+\n protected:\n     virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n \n@@ -23,16 +27,16 @@ class TBuildBatchesTask: public NConveyor::ITask {\n         return \"Write::ConstructBatches\";\n     }\n \n-    TBuildBatchesTask(const ui64 tabletId, const NActors::TActorId parentActorId,\n-        const NActors::TActorId bufferActorId, NEvWrite::TWriteData&& writeData, const std::shared_ptr<ISnapshotSchema>& actualSchema,\n-        const TSnapshot& actualSnapshot)\n+    TBuildBatchesTask(const ui64 tabletId, const NActors::TActorId parentActorId, const NActors::TActorId bufferActorId,\n+        NEvWrite::TWriteData&& writeData, const std::shared_ptr<ISnapshotSchema>& actualSchema, const TSnapshot& actualSnapshot,\n+        const std::shared_ptr<NColumnShard::TWriteCounters>& writingCounters)\n         : WriteData(std::move(writeData))\n         , TabletId(tabletId)\n         , ParentActorId(parentActorId)\n         , BufferActorId(bufferActorId)\n         , ActualSchema(actualSchema)\n         , ActualSnapshot(actualSnapshot)\n-    {\n+        , WritingCounters(writingCounters) {\n     }\n };\n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/merger.cpp b/ydb/core/tx/columnshard/operations/batch_builder/merger.cpp\nindex 713a397c7a4e..823f6ac1cf3d 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/merger.cpp\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/merger.cpp\n@@ -1,6 +1,6 @@\n #include \"merger.h\"\n #include <ydb/core/tx/columnshard/engines/scheme/index_info.h>\n-#include <ydb/core/formats/arrow/simple_arrays_cache.h>\n+#include <ydb/library/formats/arrow/simple_arrays_cache.h>\n \n namespace NKikimr::NOlap {\n \n@@ -67,12 +67,12 @@ TUpdateMerger::TUpdateMerger(const std::shared_ptr<arrow::RecordBatch>& incoming\n     , DefaultExists(defaultExists)\n     , InsertDenyReason(insertDenyReason)\n {\n-    for (auto&& i : actualSchema->GetIndexInfo().ArrowSchema()->field_names()) {\n-        auto fIdx = IncomingData->schema()->GetFieldIndex(i);\n+    for (auto&& f : actualSchema->GetIndexInfo().ArrowSchema()->fields()) {\n+        auto fIdx = IncomingData->schema()->GetFieldIndex(f->name());\n         if (fIdx == -1) {\n             IncomingColumnRemap.emplace_back();\n         } else {\n-            auto fExistsIdx = IncomingData->schema()->GetFieldIndex(\"$$EXISTS::\" + i);\n+            auto fExistsIdx = IncomingData->schema()->GetFieldIndex(\"$$EXISTS::\" + f->name());\n             std::shared_ptr<arrow::Array> flagsArray;\n             if (fExistsIdx != -1) {\n                 AFL_VERIFY(IncomingData->column(fExistsIdx)->type_id() == arrow::Type::BOOL);\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp b/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp\nindex 265d70a6029f..e13c7fc74eaf 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp\n@@ -6,16 +6,10 @@\n namespace NKikimr::NOlap {\n \n std::unique_ptr<NKikimr::TEvColumnShard::TEvInternalScan> TModificationRestoreTask::DoBuildRequestInitiator() const {\n-    auto request = std::make_unique<TEvColumnShard::TEvInternalScan>(LocalPathId);\n+    auto request = std::make_unique<TEvColumnShard::TEvInternalScan>(LocalPathId, WriteData.GetWriteMeta().GetLockIdOptional());\n     request->ReadToSnapshot = Snapshot;\n-    request->RangesFilter = std::make_shared<TPKRangesFilter>(false);\n     auto pkData = NArrow::TColumnOperator().VerifyIfAbsent().Extract(IncomingData, ActualSchema->GetPKColumnNames());\n-    for (ui32 i = 0; i < pkData->num_rows(); ++i) {\n-        auto batch = pkData->Slice(i, 1);\n-        auto pFrom = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::GreaterEqual, batch);\n-        auto pTo = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::LessEqual, batch);\n-        AFL_VERIFY(request->RangesFilter->Add(pFrom, pTo, &ActualSchema->GetIndexInfo()));\n-    }\n+    request->RangesFilter = TPKRangesFilter::BuildFromRecordBatchLines(pkData, false);\n     for (auto&& i : ActualSchema->GetIndexInfo().GetColumnIds(false)) {\n         request->AddColumn(i, ActualSchema->GetIndexInfo().GetColumnName(i));\n     }\n@@ -27,7 +21,7 @@ NKikimr::TConclusionStatus TModificationRestoreTask::DoOnDataChunk(const std::sh\n     if (result.IsFail()) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"merge_data_problems\")\n             (\"write_id\", WriteData.GetWriteMeta().GetWriteId())(\"tablet_id\", TabletId)(\"message\", result.GetErrorMessage());\n-        SendErrorMessage(result.GetErrorMessage());\n+        SendErrorMessage(result.GetErrorMessage(), NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Request);\n     }\n     return result;\n }\n@@ -35,7 +29,7 @@ NKikimr::TConclusionStatus TModificationRestoreTask::DoOnDataChunk(const std::sh\n void TModificationRestoreTask::DoOnError(const TString& errorMessage) {\n     AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"restore_data_problems\")(\"write_id\", WriteData.GetWriteMeta().GetWriteId())(\n         \"tablet_id\", TabletId)(\"message\", errorMessage);\n-    SendErrorMessage(errorMessage);\n+    SendErrorMessage(errorMessage, NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n }\n \n NKikimr::TConclusionStatus TModificationRestoreTask::DoOnFinished() {\n@@ -67,10 +61,10 @@ TModificationRestoreTask::TModificationRestoreTask(const ui64 tabletId, const NA\n \n }\n \n-void TModificationRestoreTask::SendErrorMessage(const TString& errorMessage) {\n+void TModificationRestoreTask::SendErrorMessage(const TString& errorMessage, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass) {\n     auto writeDataPtr = std::make_shared<NEvWrite::TWriteData>(std::move(WriteData));\n     TWritingBuffer buffer(writeDataPtr->GetBlobsAction(), { std::make_shared<TWriteAggregation>(*writeDataPtr) });\n-    auto evResult = NColumnShard::TEvPrivate::TEvWriteBlobsResult::Error(NKikimrProto::EReplyStatus::CORRUPTED, std::move(buffer), errorMessage);\n+    auto evResult = NColumnShard::TEvPrivate::TEvWriteBlobsResult::Error(NKikimrProto::EReplyStatus::CORRUPTED, std::move(buffer), errorMessage, errorClass);\n     TActorContext::AsActorContext().Send(ParentActorId, evResult.release());\n }\n \ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/restore.h b/ydb/core/tx/columnshard/operations/batch_builder/restore.h\nindex cab283c4f1a2..b69a856a8a58 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/restore.h\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/restore.h\n@@ -1,6 +1,7 @@\n #pragma once\n #include \"merger.h\"\n \n+#include <ydb/core/tx/columnshard/columnshard_private_events.h>\n #include <ydb/core/tx/columnshard/data_reader/actor.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n \n@@ -23,12 +24,12 @@ class TModificationRestoreTask: public NDataReader::IRestoreTask {\n     virtual TConclusionStatus DoOnDataChunk(const std::shared_ptr<arrow::Table>& data) override;\n     virtual TConclusionStatus DoOnFinished() override;\n     virtual void DoOnError(const TString& errorMessage) override;\n-    void SendErrorMessage(const TString& errorMessage);\n+    void SendErrorMessage(const TString& errorMessage, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);\n \n public:\n-    TModificationRestoreTask(const ui64 tabletId, const NActors::TActorId parentActorId,\n-        const NActors::TActorId bufferActorId, NEvWrite::TWriteData&& writeData, const std::shared_ptr<IMerger>& merger,\n-        const std::shared_ptr<ISnapshotSchema>& actualSchema, const TSnapshot actualSnapshot, const std::shared_ptr<arrow::RecordBatch>& incomingData);\n+    TModificationRestoreTask(const ui64 tabletId, const NActors::TActorId parentActorId, const NActors::TActorId bufferActorId,\n+        NEvWrite::TWriteData&& writeData, const std::shared_ptr<IMerger>& merger, const std::shared_ptr<ISnapshotSchema>& actualSchema,\n+        const TSnapshot actualSnapshot, const std::shared_ptr<arrow::RecordBatch>& incomingData);\n };\n \n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/operations/manager.cpp b/ydb/core/tx/columnshard/operations/manager.cpp\nnew file mode 100644\nindex 000000000000..1527ec5d028d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/operations/manager.cpp\n@@ -0,0 +1,296 @@\n+#include \"manager.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+bool TOperationsManager::Load(NTabletFlatExecutor::TTransactionContext& txc) {\n+    NIceDb::TNiceDb db(txc.DB);\n+    {\n+        auto rowset = db.Table<Schema::Operations>().Select();\n+        if (!rowset.IsReady()) {\n+            return false;\n+        }\n+\n+        while (!rowset.EndOfSet()) {\n+            const TOperationWriteId writeId = (TOperationWriteId)rowset.GetValue<Schema::Operations::WriteId>();\n+            const ui64 createdAtSec = rowset.GetValue<Schema::Operations::CreatedAt>();\n+            const ui64 lockId = rowset.GetValue<Schema::Operations::LockId>();\n+            const ui64 cookie = rowset.GetValueOrDefault<Schema::Operations::Cookie>(0);\n+            const TString metadata = rowset.GetValue<Schema::Operations::Metadata>();\n+            const EOperationStatus status = (EOperationStatus)rowset.GetValue<Schema::Operations::Status>();\n+            std::optional<ui32> granuleShardingVersionId;\n+            if (rowset.HaveValue<Schema::Operations::GranuleShardingVersionId>() &&\n+                rowset.GetValue<Schema::Operations::GranuleShardingVersionId>()) {\n+                granuleShardingVersionId = rowset.GetValue<Schema::Operations::GranuleShardingVersionId>();\n+            }\n+\n+            NKikimrTxColumnShard::TInternalOperationData metaProto;\n+            Y_ABORT_UNLESS(metaProto.ParseFromString(metadata));\n+\n+            auto operation = std::make_shared<TWriteOperation>(\n+                writeId, lockId, cookie, status, TInstant::Seconds(createdAtSec), granuleShardingVersionId, NEvWrite::EModificationType::Upsert);\n+            operation->FromProto(metaProto);\n+            LinkInsertWriteIdToOperationWriteId(operation->GetInsertWriteIds(), operation->GetWriteId());\n+            AFL_VERIFY(operation->GetStatus() != EOperationStatus::Draft);\n+\n+            AFL_VERIFY(Operations.emplace(operation->GetWriteId(), operation).second);\n+            auto it = LockFeatures.find(lockId);\n+            if (it == LockFeatures.end()) {\n+                it = LockFeatures.emplace(lockId, TLockFeatures(lockId, 0)).first;\n+            }\n+            it->second.MutableWriteOperations().emplace_back(operation);\n+            LastWriteId = std::max(LastWriteId, operation->GetWriteId());\n+            if (!rowset.Next()) {\n+                return false;\n+            }\n+        }\n+    }\n+    {\n+        auto rowset = db.Table<Schema::OperationTxIds>().Select();\n+        if (!rowset.IsReady()) {\n+            return false;\n+        }\n+\n+        while (!rowset.EndOfSet()) {\n+            const ui64 lockId = rowset.GetValue<Schema::OperationTxIds::LockId>();\n+            const ui64 txId = rowset.GetValue<Schema::OperationTxIds::TxId>();\n+            AFL_VERIFY(LockFeatures.contains(lockId))(\"lock_id\", lockId);\n+            AFL_VERIFY(Tx2Lock.emplace(txId, lockId).second);\n+            if (!rowset.Next()) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+void TOperationsManager::CommitTransactionOnExecute(\n+    TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot) {\n+    auto& lock = GetLockFeaturesForTxVerified(txId);\n+    TLogContextGuard gLogging(\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"commit_tx_id\", txId)(\"commit_lock_id\", lock.GetLockId()));\n+    TVector<TWriteOperation::TPtr> commited;\n+    for (auto&& opPtr : lock.GetWriteOperations()) {\n+        opPtr->CommitOnExecute(owner, txc, snapshot);\n+        commited.emplace_back(opPtr);\n+    }\n+    OnTransactionFinishOnExecute(commited, lock, txId, txc);\n+}\n+\n+void TOperationsManager::CommitTransactionOnComplete(\n+    TColumnShard& owner, const ui64 txId, const NOlap::TSnapshot& snapshot) {\n+    auto& lock = GetLockFeaturesForTxVerified(txId);\n+    TLogContextGuard gLogging(\n+        NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"commit_tx_id\", txId)(\"commit_lock_id\", lock.GetLockId()));\n+    for (auto&& i : lock.GetBrokeOnCommit()) {\n+        if (auto lockNotify = GetLockOptional(i)) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"broken_lock_id\", i);\n+            lockNotify->SetBroken();\n+        }\n+    }\n+\n+    for (auto&& i : lock.GetNotifyOnCommit()) {\n+        if (auto lockNotify = GetLockOptional(i)) {\n+            lockNotify->AddNotifyCommit(lock.GetLockId());\n+        }\n+    }\n+\n+    TVector<TWriteOperation::TPtr> commited;\n+    for (auto&& opPtr : lock.GetWriteOperations()) {\n+        opPtr->CommitOnComplete(owner, snapshot);\n+        commited.emplace_back(opPtr);\n+    }\n+    OnTransactionFinishOnComplete(commited, lock, txId);\n+}\n+\n+void TOperationsManager::AbortTransactionOnExecute(TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n+    auto* lock = GetLockFeaturesForTxOptional(txId);\n+    if (!lock) {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"abort\")(\"tx_id\", txId)(\"problem\", \"finished\");\n+        return;\n+    }\n+    TLogContextGuard gLogging(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tx_id\", txId)(\"lock_id\", lock->GetLockId()));\n+\n+    TVector<TWriteOperation::TPtr> aborted;\n+    for (auto&& opPtr : lock->GetWriteOperations()) {\n+        opPtr->AbortOnExecute(owner, txc);\n+        aborted.emplace_back(opPtr);\n+    }\n+\n+    OnTransactionFinishOnExecute(aborted, *lock, txId, txc);\n+}\n+\n+void TOperationsManager::AbortTransactionOnComplete(TColumnShard& owner, const ui64 txId) {\n+    auto* lock = GetLockFeaturesForTxOptional(txId);\n+    if (!lock) {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"abort\")(\"tx_id\", txId)(\"problem\", \"finished\");\n+        return;\n+    }\n+    TLogContextGuard gLogging(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tx_id\", txId)(\"lock_id\", lock->GetLockId()));\n+\n+    TVector<TWriteOperation::TPtr> aborted;\n+    for (auto&& opPtr : lock->GetWriteOperations()) {\n+        opPtr->AbortOnComplete(owner);\n+        aborted.emplace_back(opPtr);\n+    }\n+\n+    OnTransactionFinishOnComplete(aborted, *lock, txId);\n+}\n+\n+TWriteOperation::TPtr TOperationsManager::GetOperation(const TOperationWriteId writeId) const {\n+    auto it = Operations.find(writeId);\n+    if (it == Operations.end()) {\n+        return nullptr;\n+    }\n+    return it->second;\n+}\n+\n+void TOperationsManager::OnTransactionFinishOnExecute(\n+    const TVector<TWriteOperation::TPtr>& operations, const TLockFeatures& lock, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n+    for (auto&& op : operations) {\n+        RemoveOperationOnExecute(op, txc);\n+    }\n+    NIceDb::TNiceDb db(txc.DB);\n+    db.Table<Schema::OperationTxIds>().Key(txId, lock.GetLockId()).Delete();\n+}\n+\n+void TOperationsManager::OnTransactionFinishOnComplete(\n+    const TVector<TWriteOperation::TPtr>& operations, const TLockFeatures& lock, const ui64 txId) {\n+    {\n+        lock.RemoveInteractions(InteractionsContext);\n+        LockFeatures.erase(lock.GetLockId());\n+    }\n+    Tx2Lock.erase(txId);\n+    for (auto&& op : operations) {\n+        RemoveOperationOnComplete(op);\n+    }\n+}\n+\n+void TOperationsManager::RemoveOperationOnExecute(const TWriteOperation::TPtr& op, NTabletFlatExecutor::TTransactionContext& txc) {\n+    NIceDb::TNiceDb db(txc.DB);\n+    db.Table<Schema::Operations>().Key((ui64)op->GetWriteId()).Delete();\n+}\n+\n+void TOperationsManager::RemoveOperationOnComplete(const TWriteOperation::TPtr& op) {\n+    for (auto&& i : op->GetInsertWriteIds()) {\n+        AFL_VERIFY(InsertWriteIdToOpWriteId.erase(i));\n+    }\n+    Operations.erase(op->GetWriteId());\n+}\n+\n+TOperationWriteId TOperationsManager::BuildNextOperationWriteId() {\n+    return ++LastWriteId;\n+}\n+\n+std::optional<ui64> TOperationsManager::GetLockForTx(const ui64 txId) const {\n+    auto lockIt = Tx2Lock.find(txId);\n+    if (lockIt != Tx2Lock.end()) {\n+        return lockIt->second;\n+    }\n+    return std::nullopt;\n+}\n+\n+void TOperationsManager::LinkTransactionOnExecute(const ui64 lockId, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n+    NIceDb::TNiceDb db(txc.DB);\n+    db.Table<Schema::OperationTxIds>().Key(txId, lockId).Update();\n+    Tx2Lock[txId] = lockId;\n+}\n+\n+void TOperationsManager::LinkTransactionOnComplete(const ui64 /*lockId*/, const ui64 /*txId*/) {\n+}\n+\n+TWriteOperation::TPtr TOperationsManager::RegisterOperation(\n+    const ui64 lockId, const ui64 cookie, const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType) {\n+    auto writeId = BuildNextOperationWriteId();\n+    auto operation = std::make_shared<TWriteOperation>(\n+        writeId, lockId, cookie, EOperationStatus::Draft, AppData()->TimeProvider->Now(), granuleShardingVersionId, mType);\n+    Y_ABORT_UNLESS(Operations.emplace(operation->GetWriteId(), operation).second);\n+    GetLockVerified(operation->GetLockId()).MutableWriteOperations().emplace_back(operation);\n+    GetLockVerified(operation->GetLockId()).AddWrite();\n+    return operation;\n+}\n+\n+TConclusion<EOperationBehaviour> TOperationsManager::GetBehaviour(const NEvents::TDataEvents::TEvWrite& evWrite) {\n+    if (evWrite.Record.HasTxId() && evWrite.Record.HasLocks()) {\n+        if (evWrite.Record.GetLocks().GetLocks().size() < 1) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"proto\", evWrite.Record.DebugString())(\"event\", \"undefined behaviour\");\n+            return TConclusionStatus::Fail(\"no locks in case tx/locks\");\n+        }\n+        auto& baseLock = evWrite.Record.GetLocks().GetLocks()[0];\n+        for (auto&& i : evWrite.Record.GetLocks().GetLocks()) {\n+            if (i.GetLockId() != baseLock.GetLockId()) {\n+                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"proto\", evWrite.Record.DebugString())(\"event\", \"undefined behaviour\");\n+                return TConclusionStatus::Fail(\"different lock ids in operation\");\n+            }\n+            if (i.GetGeneration() != baseLock.GetGeneration()) {\n+                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"proto\", evWrite.Record.DebugString())(\"event\", \"undefined behaviour\");\n+                return TConclusionStatus::Fail(\"different lock generations in operation\");\n+            }\n+            if (i.GetCounter() != baseLock.GetCounter()) {\n+                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"proto\", evWrite.Record.DebugString())(\"event\", \"undefined behaviour\");\n+                return TConclusionStatus::Fail(\"different lock generation counters in operation\");\n+            }\n+        }\n+        if (evWrite.Record.GetLocks().GetOp() == NKikimrDataEvents::TKqpLocks::Commit) {\n+            return EOperationBehaviour::CommitWriteLock;\n+        }\n+        if (evWrite.Record.GetLocks().GetOp() == NKikimrDataEvents::TKqpLocks::Rollback) {\n+            return EOperationBehaviour::AbortWriteLock;\n+        }\n+    }\n+\n+    if (evWrite.Record.HasLockTxId() && evWrite.Record.HasLockNodeId()) {\n+        if (evWrite.Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE) {\n+            return EOperationBehaviour::WriteWithLock;\n+        }\n+\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"proto\", evWrite.Record.DebugString())(\"event\", \"undefined behaviour\");\n+        return TConclusionStatus::Fail(\"mode not IMMEDIATE for LockTxId + LockNodeId\");\n+    }\n+\n+    if (!evWrite.Record.HasLockTxId() && !evWrite.Record.HasLockNodeId() &&\n+        evWrite.Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE) {\n+        return EOperationBehaviour::NoTxWrite;\n+    }\n+\n+    if (evWrite.Record.HasTxId() && evWrite.Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_PREPARE) {\n+        return EOperationBehaviour::InTxWrite;\n+    }\n+    AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"proto\", evWrite.Record.DebugString())(\"event\", \"undefined behaviour\");\n+    return TConclusionStatus::Fail(\"undefined request for detect tx type\");\n+}\n+\n+TOperationsManager::TOperationsManager() {\n+}\n+\n+void TOperationsManager::AddEventForTx(TColumnShard& owner, const ui64 txId, const std::shared_ptr<NOlap::NTxInteractions::ITxEventWriter>& writer) {\n+    return AddEventForLock(owner, GetLockForTxVerified(txId), writer);\n+}\n+\n+void TOperationsManager::AddEventForLock(\n+    TColumnShard& /*owner*/, const ui64 lockId, const std::shared_ptr<NOlap::NTxInteractions::ITxEventWriter>& writer) {\n+    AFL_VERIFY(writer);\n+    NOlap::NTxInteractions::TTxConflicts txNotifications;\n+    NOlap::NTxInteractions::TTxConflicts txConflicts;\n+    auto& txLock = GetLockVerified(lockId);\n+    writer->CheckInteraction(lockId, InteractionsContext, txConflicts, txNotifications);\n+    for (auto&& i : txConflicts) {\n+        if (auto lock = GetLockOptional(i.first)) {\n+            GetLockVerified(i.first).AddBrokeOnCommit(i.second);\n+        } else if (txLock.IsCommitted(i.first)) {\n+            txLock.SetBroken();\n+        }\n+    }\n+    for (auto&& i : txNotifications) {\n+        GetLockVerified(i.first).AddNotificationsOnCommit(i.second);\n+    }\n+    if (auto txEvent = writer->BuildEvent()) {\n+        NOlap::NTxInteractions::TTxEventContainer container(lockId, txEvent);\n+        container.AddToInteraction(InteractionsContext);\n+        txLock.MutableEvents().emplace_back(std::move(container));\n+    }\n+}\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/operations/manager.h b/ydb/core/tx/columnshard/operations/manager.h\nnew file mode 100644\nindex 000000000000..9e2651e24da0\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/operations/manager.h\n@@ -0,0 +1,221 @@\n+#pragma once\n+#include \"write.h\"\n+\n+#include <ydb/core/tx/columnshard/transactions/locks/abstract.h>\n+#include <ydb/core/tx/locks/sys_tables.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+class TManager;\n+class TTxEventContainer;\n+class TInteractionsContext;\n+class ITxEventWriter;\n+}   // namespace NKikimr::NOlap::NTxInteractions\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TColumnShard;\n+class TLockFeatures;\n+\n+class TLockSharingInfo {\n+private:\n+    const ui64 LockId;\n+    const ui64 Generation;\n+    TAtomicCounter InternalGenerationCounter = 0;\n+    TAtomicCounter Broken = 0;\n+    TAtomicCounter WritesCounter = 0;\n+    friend class TLockFeatures;\n+\n+public:\n+    ui64 GetLockId() const {\n+        return LockId;\n+    }\n+    ui64 GetGeneration() const {\n+        return Generation;\n+    }\n+\n+    TLockSharingInfo(const ui64 lockId, const ui64 generation)\n+        : LockId(lockId)\n+        , Generation(generation) {\n+    }\n+\n+    bool HasWrites() const {\n+        return WritesCounter.Val();\n+    }\n+\n+    bool IsBroken() const {\n+        return Broken.Val();\n+    }\n+\n+    ui64 GetCounter() const {\n+        return InternalGenerationCounter.Val();\n+    }\n+};\n+\n+class TLockFeatures: TMoveOnly {\n+private:\n+    YDB_ACCESSOR_DEF(std::vector<TWriteOperation::TPtr>, WriteOperations);\n+    YDB_ACCESSOR_DEF(std::vector<NOlap::NTxInteractions::TTxEventContainer>, Events);\n+    YDB_ACCESSOR(ui64, LockId, 0);\n+    YDB_ACCESSOR(ui64, Generation, 0);\n+    std::shared_ptr<TLockSharingInfo> SharingInfo;\n+\n+    YDB_READONLY_DEF(THashSet<ui64>, BrokeOnCommit);\n+    YDB_READONLY_DEF(THashSet<ui64>, NotifyOnCommit);\n+    YDB_READONLY_DEF(THashSet<ui64>, Committed);\n+\n+public:\n+    const std::shared_ptr<TLockSharingInfo>& GetSharingInfo() const {\n+        return SharingInfo;\n+    }\n+\n+    ui64 GetInternalGenerationCounter() const {\n+        return SharingInfo->GetCounter();\n+    }\n+\n+    void AddWrite() {\n+        SharingInfo->WritesCounter.Inc();\n+    }\n+\n+    void SetBroken() {\n+        SharingInfo->Broken = 1;\n+        SharingInfo->InternalGenerationCounter = (i64)TSysTables::TLocksTable::TLock::ESetErrors::ErrorBroken;\n+    }\n+\n+    bool IsBroken() const {\n+        return SharingInfo->IsBroken();\n+    }\n+\n+    bool IsCommitted(const ui64 lockId) const {\n+        return Committed.contains(lockId);\n+    }\n+\n+    void AddNotifyCommit(const ui64 lockId) {\n+        AFL_VERIFY(NotifyOnCommit.erase(lockId));\n+        Committed.emplace(lockId);\n+    }\n+\n+    void AddBrokeOnCommit(const THashSet<ui64>& lockIds) {\n+        BrokeOnCommit.insert(lockIds.begin(), lockIds.end());\n+    }\n+\n+    void AddNotificationsOnCommit(const THashSet<ui64>& lockIds) {\n+        NotifyOnCommit.insert(lockIds.begin(), lockIds.end());\n+    }\n+\n+    void RemoveInteractions(NOlap::NTxInteractions::TInteractionsContext& context) const {\n+        for (auto&& i : Events) {\n+            i.RemoveFromInteraction(context);\n+        }\n+    }\n+\n+    TLockFeatures(const ui64 lockId, const ui64 gen)\n+        : LockId(lockId)\n+        , Generation(gen) {\n+        SharingInfo = std::make_shared<TLockSharingInfo>(lockId, gen);\n+    }\n+};\n+\n+class TOperationsManager {\n+    NOlap::NTxInteractions::TInteractionsContext InteractionsContext;\n+\n+    THashMap<ui64, ui64> Tx2Lock;\n+    THashMap<TInsertWriteId, TOperationWriteId> InsertWriteIdToOpWriteId;\n+    THashMap<ui64, TLockFeatures> LockFeatures;\n+    THashMap<TOperationWriteId, TWriteOperation::TPtr> Operations;\n+    TOperationWriteId LastWriteId = TOperationWriteId(0);\n+\n+public:\n+\n+    TWriteOperation::TPtr GetOperationByInsertWriteIdVerified(const TInsertWriteId insertWriteId) const {\n+        auto it = InsertWriteIdToOpWriteId.find(insertWriteId);\n+        AFL_VERIFY(it != InsertWriteIdToOpWriteId.end());\n+        return GetOperationVerified(it->second);\n+    }\n+\n+    void LinkInsertWriteIdToOperationWriteId(const std::vector<TInsertWriteId>& insertions, const TOperationWriteId operationId) {\n+        for (auto&& i : insertions) {\n+            InsertWriteIdToOpWriteId.emplace(i, operationId);\n+        }\n+    }\n+    bool Load(NTabletFlatExecutor::TTransactionContext& txc);\n+    void AddEventForTx(TColumnShard& owner, const ui64 txId, const std::shared_ptr<NOlap::NTxInteractions::ITxEventWriter>& writer);\n+    void AddEventForLock(TColumnShard& owner, const ui64 lockId, const std::shared_ptr<NOlap::NTxInteractions::ITxEventWriter>& writer);\n+\n+    TWriteOperation::TPtr GetOperation(const TOperationWriteId writeId) const;\n+    TWriteOperation::TPtr GetOperationVerified(const TOperationWriteId writeId) const {\n+        return TValidator::CheckNotNull(GetOperationOptional(writeId));\n+    }\n+    TWriteOperation::TPtr GetOperationOptional(const TOperationWriteId writeId) const {\n+        return GetOperation(writeId);\n+    }\n+    void CommitTransactionOnExecute(\n+        TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot);\n+    void CommitTransactionOnComplete(\n+        TColumnShard& owner, const ui64 txId, const NOlap::TSnapshot& snapshot);\n+    void AddTemporaryTxLink(const ui64 lockId) {\n+        AFL_VERIFY(Tx2Lock.emplace(lockId, lockId).second);\n+    }\n+    void LinkTransactionOnExecute(const ui64 lockId, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n+    void LinkTransactionOnComplete(const ui64 lockId, const ui64 txId);\n+    void AbortTransactionOnExecute(TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n+    void AbortTransactionOnComplete(TColumnShard& owner, const ui64 txId);\n+\n+    std::optional<ui64> GetLockForTx(const ui64 txId) const;\n+    std::optional<ui64> GetLockForTxOptional(const ui64 txId) const {\n+        return GetLockForTx(txId);\n+    }\n+    TLockFeatures* GetLockFeaturesForTxOptional(const ui64 txId) {\n+        auto lockId = GetLockForTxOptional(txId);\n+        if (!lockId) {\n+            return nullptr;\n+        }\n+        return &GetLockVerified(*lockId);\n+    }\n+    TLockFeatures& GetLockFeaturesForTxVerified(const ui64 txId) {\n+        auto lockId = GetLockForTxOptional(txId);\n+        AFL_VERIFY(lockId);\n+        return GetLockVerified(*lockId);\n+    }\n+    ui64 GetLockForTxVerified(const ui64 txId) const {\n+        auto result = GetLockForTxOptional(txId);\n+        AFL_VERIFY(result)(\"tx_id\", txId);\n+        return *result;\n+    }\n+\n+    TWriteOperation::TPtr RegisterOperation(\n+        const ui64 lockId, const ui64 cookie, const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType);\n+    bool RegisterLock(const ui64 lockId, const ui64 generationId) {\n+        if (LockFeatures.contains(lockId)) {\n+            return false;\n+        } else {\n+            LockFeatures.emplace(lockId, TLockFeatures(lockId, generationId));\n+            return true;\n+        }\n+    }\n+    static TConclusion<EOperationBehaviour> GetBehaviour(const NEvents::TDataEvents::TEvWrite& evWrite);\n+    TLockFeatures& GetLockVerified(const ui64 lockId) {\n+        auto result = GetLockOptional(lockId);\n+        AFL_VERIFY(result)(\"lock_id\", lockId);\n+        return *result;\n+    }\n+\n+    TLockFeatures* GetLockOptional(const ui64 lockId) {\n+        auto it = LockFeatures.find(lockId);\n+        if (it != LockFeatures.end()) {\n+            return &it->second;\n+        } else {\n+            return nullptr;\n+        }\n+    }\n+\n+    TOperationsManager();\n+\n+private:\n+    TOperationWriteId BuildNextOperationWriteId();\n+    void RemoveOperationOnExecute(const TWriteOperation::TPtr& op, NTabletFlatExecutor::TTransactionContext& txc);\n+    void RemoveOperationOnComplete(const TWriteOperation::TPtr& op);\n+    void OnTransactionFinishOnExecute(const TVector<TWriteOperation::TPtr>& operations, const TLockFeatures& lock, const ui64 txId,\n+        NTabletFlatExecutor::TTransactionContext& txc);\n+    void OnTransactionFinishOnComplete(const TVector<TWriteOperation::TPtr>& operations, const TLockFeatures& lock, const ui64 txId);\n+};\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp b/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp\nindex a5daa4f5d281..2a9d42b00283 100644\n--- a/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp\n+++ b/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp\n@@ -27,11 +27,11 @@ std::optional<std::vector<NKikimr::NArrow::TSerializedBatch>> TBuildSlicesTask::\n     return result;\n }\n \n-void TBuildSlicesTask::ReplyError(const TString& message) {\n+void TBuildSlicesTask::ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass) {\n     auto writeDataPtr = std::make_shared<NEvWrite::TWriteData>(std::move(WriteData));\n     TWritingBuffer buffer(writeDataPtr->GetBlobsAction(), { std::make_shared<TWriteAggregation>(*writeDataPtr) });\n     auto result = NColumnShard::TEvPrivate::TEvWriteBlobsResult::Error(\n-        NKikimrProto::EReplyStatus::CORRUPTED, std::move(buffer), message);\n+        NKikimrProto::EReplyStatus::CORRUPTED, std::move(buffer), message, errorClass);\n     TActorContext::AsActorContext().Send(ParentActorId, result.release());\n }\n \n@@ -39,19 +39,21 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta\n     NActors::TLogContextGuard g(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletId)(\"parent_id\", ParentActorId));\n     if (!OriginalBatch) {\n         AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"ev_write_bad_data\")(\"write_id\", WriteData.GetWriteMeta().GetWriteId())(\"table_id\", WriteData.GetWriteMeta().GetTableId());\n-        ReplyError(\"no data in batch\");\n+        ReplyError(\"no data in batch\", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n         return TConclusionStatus::Fail(\"no data in batch\");\n     }\n     const auto& indexSchema = ActualSchema->GetIndexInfo().ArrowSchema();\n-    NArrow::TSchemaSubset subset;\n-    auto reorderConclusion = NArrow::TColumnOperator().Adapt(OriginalBatch, indexSchema, &subset);\n-    if (reorderConclusion.IsFail()) {\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"unadaptable schemas\")(\"index\", indexSchema->ToString())(\"problem\", reorderConclusion.GetErrorMessage());\n-        ReplyError(\"cannot reorder schema: \" + reorderConclusion.GetErrorMessage());\n-        return TConclusionStatus::Fail(\"cannot reorder schema: \" + reorderConclusion.GetErrorMessage());\n-    } else {\n-        OriginalBatch = reorderConclusion.DetachResult();\n+    auto subsetConclusion = NArrow::TColumnOperator().BuildSequentialSubset(OriginalBatch, indexSchema);\n+    if (subsetConclusion.IsFail()) {\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"unadaptable schemas\")(\"index\", indexSchema->ToString())(\n+            \"problem\", subsetConclusion.GetErrorMessage());\n+        ReplyError(\n+            \"unadaptable schema: \" + subsetConclusion.GetErrorMessage(),\n+            NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n+        return TConclusionStatus::Fail(\"cannot reorder schema: \" + subsetConclusion.GetErrorMessage());\n     }\n+    NArrow::TSchemaSubset subset = subsetConclusion.DetachResult();\n+\n     if (OriginalBatch->num_columns() != indexSchema->num_fields()) {\n         AFL_VERIFY(OriginalBatch->num_columns() < indexSchema->num_fields())(\"original\", OriginalBatch->num_columns())(\n                                                       \"index\", indexSchema->num_fields());\n@@ -70,10 +72,14 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta\n     if (batches) {\n         auto writeDataPtr = std::make_shared<NEvWrite::TWriteData>(std::move(WriteData));\n         writeDataPtr->SetSchemaSubset(std::move(subset));\n-        auto result = std::make_unique<NColumnShard::NWriting::TEvAddInsertedDataToBuffer>(writeDataPtr, std::move(*batches));\n+        std::shared_ptr<arrow::RecordBatch> pkBatch;\n+        if (!writeDataPtr->GetWriteMeta().HasLongTxId()) {\n+            pkBatch = NArrow::TColumnOperator().Extract(OriginalBatch, ActualSchema->GetIndexInfo().GetPrimaryKey()->fields());\n+        }\n+        auto result = std::make_unique<NColumnShard::NWriting::TEvAddInsertedDataToBuffer>(writeDataPtr, std::move(*batches), pkBatch);\n         TActorContext::AsActorContext().Send(BufferActorId, result.release());\n     } else {\n-        ReplyError(\"Cannot slice input to batches\");\n+        ReplyError(\"Cannot slice input to batches\", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n         return TConclusionStatus::Fail(\"Cannot slice input to batches\");\n     }\n \ndiff --git a/ydb/core/tx/columnshard/operations/slice_builder/builder.h b/ydb/core/tx/columnshard/operations/slice_builder/builder.h\nindex bd5c59064265..a22b0c7d6ca7 100644\n--- a/ydb/core/tx/columnshard/operations/slice_builder/builder.h\n+++ b/ydb/core/tx/columnshard/operations/slice_builder/builder.h\n@@ -1,8 +1,9 @@\n #pragma once\n+#include <ydb/core/formats/arrow/size_calcer.h>\n+#include <ydb/core/tx/columnshard/columnshard_private_events.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n #include <ydb/core/tx/conveyor/usage/abstract.h>\n #include <ydb/core/tx/data_events/write_data.h>\n-#include <ydb/core/formats/arrow/size_calcer.h>\n \n namespace NKikimr::NOlap {\n \n@@ -15,7 +16,8 @@ class TBuildSlicesTask: public NConveyor::ITask {\n     std::shared_ptr<arrow::RecordBatch> OriginalBatch;\n     std::optional<std::vector<NArrow::TSerializedBatch>> BuildSlices();\n     const std::shared_ptr<ISnapshotSchema> ActualSchema;\n-    void ReplyError(const TString& message);\n+    void ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);\n+\n protected:\n     virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n \n@@ -24,16 +26,14 @@ class TBuildSlicesTask: public NConveyor::ITask {\n         return \"Write::ConstructBlobs::Slices\";\n     }\n \n-    TBuildSlicesTask(const ui64 tabletId, const NActors::TActorId parentActorId,\n-        const NActors::TActorId bufferActorId, NEvWrite::TWriteData&& writeData, const std::shared_ptr<arrow::RecordBatch>& batch,\n-        const std::shared_ptr<ISnapshotSchema>& actualSchema)\n+    TBuildSlicesTask(const ui64 tabletId, const NActors::TActorId parentActorId, const NActors::TActorId bufferActorId,\n+        NEvWrite::TWriteData&& writeData, const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<ISnapshotSchema>& actualSchema)\n         : WriteData(std::move(writeData))\n         , TabletId(tabletId)\n         , ParentActorId(parentActorId)\n         , BufferActorId(bufferActorId)\n         , OriginalBatch(batch)\n-        , ActualSchema(actualSchema)\n-    {\n+        , ActualSchema(actualSchema) {\n     }\n };\n-}\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/operations/write.cpp b/ydb/core/tx/columnshard/operations/write.cpp\nindex 4ff54d395e73..06b7701cd7bd 100644\n--- a/ydb/core/tx/columnshard/operations/write.cpp\n+++ b/ydb/core/tx/columnshard/operations/write.cpp\n@@ -1,6 +1,7 @@\n-#include \"batch_builder/builder.h\"\n #include \"write.h\"\n \n+#include \"batch_builder/builder.h\"\n+\n #include <ydb/core/tablet_flat/tablet_flat_executor.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/storages_manager.h>\n #include <ydb/core/tx/columnshard/blobs_action/blob_manager_db.h>\n@@ -11,272 +12,111 @@\n \n namespace NKikimr::NColumnShard {\n \n-    TWriteOperation::TWriteOperation(const TWriteId writeId, const ui64 lockId, const ui64 cookie, const EOperationStatus& status, const TInstant createdAt,\n-        const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType)\n-        : Status(status)\n-        , CreatedAt(createdAt)\n-        , WriteId(writeId)\n-        , LockId(lockId)\n-        , Cookie(cookie)\n-        , GranuleShardingVersionId(granuleShardingVersionId)\n-        , ModificationType(mType)\n-    {\n-    }\n-\n-    void TWriteOperation::Start(TColumnShard& owner, const ui64 tableId, const NEvWrite::IDataContainer::TPtr& data,\n-        const NActors::TActorId& source, const std::shared_ptr<NOlap::ISnapshotSchema>& schema, const TActorContext& ctx) {\n-        Y_ABORT_UNLESS(Status == EOperationStatus::Draft);\n-\n-        NEvWrite::TWriteMeta writeMeta((ui64)WriteId, tableId, source, GranuleShardingVersionId);\n-        writeMeta.SetModificationType(ModificationType);\n-        std::shared_ptr<NConveyor::ITask> task = std::make_shared<NOlap::TBuildBatchesTask>(owner.TabletID(), ctx.SelfID, owner.BufferizationWriteActorId,\n+TWriteOperation::TWriteOperation(const TOperationWriteId writeId, const ui64 lockId, const ui64 cookie, const EOperationStatus& status,\n+    const TInstant createdAt, const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType)\n+    : Status(status)\n+    , CreatedAt(createdAt)\n+    , WriteId(writeId)\n+    , LockId(lockId)\n+    , Cookie(cookie)\n+    , GranuleShardingVersionId(granuleShardingVersionId)\n+    , ModificationType(mType) {\n+}\n+\n+void TWriteOperation::Start(TColumnShard& owner, const ui64 tableId, const NEvWrite::IDataContainer::TPtr& data, const NActors::TActorId& source,\n+    const std::shared_ptr<NOlap::ISnapshotSchema>& schema, const TActorContext& ctx) {\n+    Y_ABORT_UNLESS(Status == EOperationStatus::Draft);\n+\n+    NEvWrite::TWriteMeta writeMeta((ui64)WriteId, tableId, source, GranuleShardingVersionId);\n+    writeMeta.SetLockId(LockId);\n+    writeMeta.SetModificationType(ModificationType);\n+    std::shared_ptr<NConveyor::ITask> task =\n+        std::make_shared<NOlap::TBuildBatchesTask>(owner.TabletID(), ctx.SelfID, owner.BufferizationWriteActorId,\n             NEvWrite::TWriteData(writeMeta, data, owner.TablesManager.GetPrimaryIndex()->GetReplaceKey(),\n                 owner.StoragesManager->GetInsertOperator()->StartWritingAction(NOlap::NBlobOperations::EConsumer::WRITING_OPERATOR)),\n-            schema, owner.GetLastTxSnapshot());\n-        NConveyor::TCompServiceOperator::SendTaskToExecute(task);\n-\n-        Status = EOperationStatus::Started;\n-    }\n-\n-    void TWriteOperation::Commit(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot) const {\n-        Y_ABORT_UNLESS(Status == EOperationStatus::Prepared);\n-\n-        TBlobGroupSelector dsGroupSelector(owner.Info());\n-        NOlap::TDbWrapper dbTable(txc.DB, &dsGroupSelector);\n-\n-        for (auto gWriteId : GlobalWriteIds) {\n-            auto pathExists = [&](ui64 pathId) {\n-                return owner.TablesManager.HasTable(pathId);\n-            };\n-\n-            auto counters = owner.InsertTable->Commit(dbTable, snapshot.GetPlanStep(), snapshot.GetTxId(), { gWriteId },\n-                                                      pathExists);\n-\n-            owner.IncCounter(COUNTER_BLOBS_COMMITTED, counters.Rows);\n-            owner.IncCounter(COUNTER_BYTES_COMMITTED, counters.Bytes);\n-            owner.IncCounter(COUNTER_RAW_BYTES_COMMITTED, counters.RawBytes);\n-        }\n-        owner.UpdateInsertTableCounters();\n-    }\n-\n-    void TWriteOperation::OnWriteFinish(NTabletFlatExecutor::TTransactionContext& txc, const TVector<TWriteId>& globalWriteIds) {\n-        Y_ABORT_UNLESS(Status == EOperationStatus::Started);\n-        Status = EOperationStatus::Prepared;\n-        GlobalWriteIds = globalWriteIds;\n-\n-        NIceDb::TNiceDb db(txc.DB);\n-        NKikimrTxColumnShard::TInternalOperationData proto;\n-        ToProto(proto);\n-\n-        TString metadata;\n-        Y_ABORT_UNLESS(proto.SerializeToString(&metadata));\n-\n-        db.Table<Schema::Operations>().Key((ui64)WriteId).Update(\n-            NIceDb::TUpdate<Schema::Operations::Status>((ui32)Status),\n-            NIceDb::TUpdate<Schema::Operations::CreatedAt>(CreatedAt.Seconds()),\n-            NIceDb::TUpdate<Schema::Operations::Metadata>(metadata),\n-            NIceDb::TUpdate<Schema::Operations::LockId>(LockId),\n-            NIceDb::TUpdate<Schema::Operations::Cookie>(Cookie),\n-            NIceDb::TUpdate<Schema::Operations::GranuleShardingVersionId>(GranuleShardingVersionId.value_or(0)));\n-    }\n+            schema, owner.GetLastTxSnapshot(), owner.Counters.GetCSCounters().WritingCounters);\n+    NConveyor::TCompServiceOperator::SendTaskToExecute(task);\n \n-    void TWriteOperation::ToProto(NKikimrTxColumnShard::TInternalOperationData& proto) const {\n-        for (auto&& writeId : GlobalWriteIds) {\n-            proto.AddInternalWriteIds((ui64)writeId);\n-        }\n-        proto.SetModificationType((ui32)ModificationType);\n-    }\n+    Status = EOperationStatus::Started;\n+}\n \n-    void TWriteOperation::FromProto(const NKikimrTxColumnShard::TInternalOperationData& proto) {\n-        for (auto&& writeId : proto.GetInternalWriteIds()) {\n-            GlobalWriteIds.push_back(TWriteId(writeId));\n-        }\n-        if (proto.HasModificationType()) {\n-            ModificationType = (NEvWrite::EModificationType)proto.GetModificationType();\n-        } else {\n-            ModificationType = NEvWrite::EModificationType::Replace;\n-        }\n-    }\n+void TWriteOperation::CommitOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot) const {\n+    Y_ABORT_UNLESS(Status == EOperationStatus::Prepared);\n \n-    void TWriteOperation::Abort(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) const {\n-        Y_ABORT_UNLESS(Status == EOperationStatus::Prepared);\n+    TBlobGroupSelector dsGroupSelector(owner.Info());\n+    NOlap::TDbWrapper dbTable(txc.DB, &dsGroupSelector);\n \n-        TBlobGroupSelector dsGroupSelector(owner.Info());\n-        NOlap::TDbWrapper dbTable(txc.DB, &dsGroupSelector);\n+    for (auto gWriteId : InsertWriteIds) {\n+        auto pathExists = [&](ui64 pathId) {\n+            return owner.TablesManager.HasTable(pathId);\n+        };\n \n-        THashSet<TWriteId> writeIds;\n-        writeIds.insert(GlobalWriteIds.begin(), GlobalWriteIds.end());\n-        owner.InsertTable->Abort(dbTable, writeIds);\n+        const auto counters = owner.InsertTable->Commit(dbTable, snapshot.GetPlanStep(), snapshot.GetTxId(), { gWriteId }, pathExists);\n+        owner.Counters.GetTabletCounters()->OnWriteCommitted(counters);\n     }\n+}\n \n-    bool TOperationsManager::Load(NTabletFlatExecutor::TTransactionContext& txc) {\n-        NIceDb::TNiceDb db(txc.DB);\n-        {\n-            auto rowset = db.Table<Schema::Operations>().Select();\n-            if (!rowset.IsReady()) {\n-                return false;\n-            }\n-\n-            while (!rowset.EndOfSet()) {\n-                const TWriteId writeId = (TWriteId)rowset.GetValue<Schema::Operations::WriteId>();\n-                const ui64 createdAtSec = rowset.GetValue<Schema::Operations::CreatedAt>();\n-                const ui64 lockId = rowset.GetValue<Schema::Operations::LockId>();\n-                const ui64 cookie = rowset.GetValueOrDefault<Schema::Operations::Cookie>(0);\n-                const TString metadata = rowset.GetValue<Schema::Operations::Metadata>();\n-                const EOperationStatus status = (EOperationStatus)rowset.GetValue<Schema::Operations::Status>();\n-                std::optional<ui32> granuleShardingVersionId;\n-                if (rowset.HaveValue<Schema::Operations::GranuleShardingVersionId>() && rowset.GetValue<Schema::Operations::GranuleShardingVersionId>()) {\n-                    granuleShardingVersionId = rowset.GetValue<Schema::Operations::GranuleShardingVersionId>();\n-                }\n+void TWriteOperation::CommitOnComplete(TColumnShard& owner, const NOlap::TSnapshot& /*snapshot*/) const {\n+    Y_ABORT_UNLESS(Status == EOperationStatus::Prepared);\n+    owner.UpdateInsertTableCounters();\n+}\n \n-                NKikimrTxColumnShard::TInternalOperationData metaProto;\n-                Y_ABORT_UNLESS(metaProto.ParseFromString(metadata));\n+void TWriteOperation::OnWriteFinish(\n+    NTabletFlatExecutor::TTransactionContext& txc, const std::vector<TInsertWriteId>& insertWriteIds, const bool ephemeralFlag) {\n+    Y_ABORT_UNLESS(Status == EOperationStatus::Started);\n+    Status = EOperationStatus::Prepared;\n+    InsertWriteIds = insertWriteIds;\n \n-                auto operation = std::make_shared<TWriteOperation>(writeId, lockId, cookie, status, TInstant::Seconds(createdAtSec), granuleShardingVersionId, NEvWrite::EModificationType::Upsert);\n-                operation->FromProto(metaProto);\n-                AFL_VERIFY(operation->GetStatus() != EOperationStatus::Draft);\n-\n-                auto [_, isOk] = Operations.emplace(operation->GetWriteId(), operation);\n-                if (!isOk) {\n-                    AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"duplicated_operation\")(\"operation\", *operation);\n-                    return false;\n-                }\n-                Locks[lockId].push_back(operation->GetWriteId());\n-                LastWriteId = std::max(LastWriteId, operation->GetWriteId());\n-                if (!rowset.Next()) {\n-                    return false;\n-                }\n-            }\n-        }\n-        {\n-            auto rowset = db.Table<Schema::OperationTxIds>().Select();\n-            if (!rowset.IsReady()) {\n-                return false;\n-            }\n-\n-            while (!rowset.EndOfSet()) {\n-                const ui64 lockId = rowset.GetValue<Schema::OperationTxIds::LockId>();\n-                const ui64 txId = rowset.GetValue<Schema::OperationTxIds::TxId>();\n-                AFL_VERIFY(Locks.contains(lockId))(\"lock_id\", lockId);\n-                Tx2Lock[txId] = lockId;\n-                if (!rowset.Next()) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n+    if (ephemeralFlag) {\n+        return;\n     }\n \n-    bool TOperationsManager::CommitTransaction(TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot) {\n-        TLogContextGuard gLogging(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tx_id\", txId));\n-        auto lockId = GetLockForTx(txId);\n-        if (!lockId) {\n-            ACFL_ERROR(\"details\", \"unknown_transaction\");\n-            return true;\n-        }\n-        auto tIt = Locks.find(*lockId);\n-        AFL_VERIFY(tIt != Locks.end())(\"tx_id\", txId)(\"lock_id\", *lockId);\n+    NIceDb::TNiceDb db(txc.DB);\n+    NKikimrTxColumnShard::TInternalOperationData proto;\n+    ToProto(proto);\n \n-        TVector<TWriteOperation::TPtr> commited;\n-        for (auto&& opId : tIt->second) {\n-            auto opPtr = Operations.FindPtr(opId);\n-            (*opPtr)->Commit(owner, txc, snapshot);\n-            commited.emplace_back(*opPtr);\n-        }\n-        OnTransactionFinish(commited, txId, txc);\n-        return true;\n-    }\n-\n-    bool TOperationsManager::AbortTransaction(TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n-        TLogContextGuard gLogging(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tx_id\", txId));\n-\n-        auto lockId = GetLockForTx(txId);\n-        if (!lockId) {\n-            ACFL_ERROR(\"details\", \"unknown_transaction\");\n-            return true;\n-        }\n-        auto tIt = Locks.find(*lockId);\n-        AFL_VERIFY(tIt != Locks.end())(\"tx_id\", txId)(\"lock_id\", *lockId);\n-\n-        TVector<TWriteOperation::TPtr> aborted;\n-        for (auto&& opId : tIt->second) {\n-            auto opPtr = Operations.FindPtr(opId);\n-            (*opPtr)->Abort(owner, txc);\n-            aborted.emplace_back(*opPtr);\n-        }\n-\n-        OnTransactionFinish(aborted, txId, txc);\n-        return true;\n-    }\n+    TString metadata;\n+    Y_ABORT_UNLESS(proto.SerializeToString(&metadata));\n \n-    TWriteOperation::TPtr TOperationsManager::GetOperation(const TWriteId writeId) const {\n-        auto it = Operations.find(writeId);\n-        if (it == Operations.end()) {\n-            return nullptr;\n-        }\n-        return it->second;\n-    }\n-\n-    void TOperationsManager::OnTransactionFinish(const TVector<TWriteOperation::TPtr>& operations, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n-        auto lockId = GetLockForTx(txId);\n-        AFL_VERIFY(!!lockId)(\"tx_id\", txId);\n-        Locks.erase(*lockId);\n-        Tx2Lock.erase(txId);\n-        for (auto&& op : operations) {\n-            RemoveOperation(op, txc);\n-        }\n-        NIceDb::TNiceDb db(txc.DB);\n-        db.Table<Schema::OperationTxIds>().Key(txId, *lockId).Delete();\n-    }\n-\n-    void TOperationsManager::RemoveOperation(const TWriteOperation::TPtr& op, NTabletFlatExecutor::TTransactionContext& txc) {\n-        Operations.erase(op->GetWriteId());\n-        NIceDb::TNiceDb db(txc.DB);\n-        db.Table<Schema::Operations>().Key((ui64)op->GetWriteId()).Delete();\n-    }\n+    db.Table<Schema::Operations>()\n+        .Key((ui64)WriteId)\n+        .Update(NIceDb::TUpdate<Schema::Operations::Status>((ui32)Status), NIceDb::TUpdate<Schema::Operations::CreatedAt>(CreatedAt.Seconds()),\n+            NIceDb::TUpdate<Schema::Operations::Metadata>(metadata), NIceDb::TUpdate<Schema::Operations::LockId>(LockId),\n+            NIceDb::TUpdate<Schema::Operations::Cookie>(Cookie),\n+            NIceDb::TUpdate<Schema::Operations::GranuleShardingVersionId>(GranuleShardingVersionId.value_or(0)));\n+}\n \n-    TWriteId TOperationsManager::BuildNextWriteId() {\n-        return ++LastWriteId;\n+void TWriteOperation::ToProto(NKikimrTxColumnShard::TInternalOperationData& proto) const {\n+    for (auto&& writeId : InsertWriteIds) {\n+        proto.AddInternalWriteIds((ui64)writeId);\n     }\n+    proto.SetModificationType((ui32)ModificationType);\n+}\n \n-    std::optional<ui64> TOperationsManager::GetLockForTx(const ui64 txId) const {\n-        auto lockIt = Tx2Lock.find(txId);\n-        if (lockIt != Tx2Lock.end()) {\n-            return lockIt->second;\n-        }\n-        return std::nullopt;\n+void TWriteOperation::FromProto(const NKikimrTxColumnShard::TInternalOperationData& proto) {\n+    for (auto&& writeId : proto.GetInternalWriteIds()) {\n+        InsertWriteIds.push_back(TInsertWriteId(writeId));\n     }\n-\n-    void TOperationsManager::LinkTransaction(const ui64 lockId, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n-        Tx2Lock[txId] = lockId;\n-        NIceDb::TNiceDb db(txc.DB);\n-        db.Table<Schema::OperationTxIds>().Key(txId, lockId).Update();\n+    if (proto.HasModificationType()) {\n+        ModificationType = (NEvWrite::EModificationType)proto.GetModificationType();\n+    } else {\n+        ModificationType = NEvWrite::EModificationType::Replace;\n     }\n+}\n \n-    TWriteOperation::TPtr TOperationsManager::RegisterOperation(const ui64 lockId, const ui64 cookie, const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType) {\n-        auto writeId = BuildNextWriteId();\n-        auto operation = std::make_shared<TWriteOperation>(writeId, lockId, cookie, EOperationStatus::Draft, AppData()->TimeProvider->Now(), granuleShardingVersionId, mType);\n-        Y_ABORT_UNLESS(Operations.emplace(operation->GetWriteId(), operation).second);\n-        Locks[operation->GetLockId()].push_back(operation->GetWriteId());\n-        return operation;\n-    }\n+void TWriteOperation::AbortOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) const {\n+    Y_ABORT_UNLESS(Status == EOperationStatus::Prepared);\n \n-    EOperationBehaviour TOperationsManager::GetBehaviour(const NEvents::TDataEvents::TEvWrite& evWrite) {\n-        if (evWrite.Record.HasTxId() && evWrite.Record.HasLocks() && evWrite.Record.GetLocks().GetOp() == NKikimrDataEvents::TKqpLocks::Commit) {\n-            return EOperationBehaviour::CommitWriteLock;\n-        }\n+    TBlobGroupSelector dsGroupSelector(owner.Info());\n+    NOlap::TDbWrapper dbTable(txc.DB, &dsGroupSelector);\n \n-        if (evWrite.Record.HasLockTxId() && evWrite.Record.HasLockNodeId()) {\n-            if (evWrite.Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE) {\n-                return EOperationBehaviour::WriteWithLock;\n-            }\n+    THashSet<TInsertWriteId> writeIds;\n+    writeIds.insert(InsertWriteIds.begin(), InsertWriteIds.end());\n+    owner.InsertTable->Abort(dbTable, writeIds);\n+}\n \n-            return EOperationBehaviour::Undefined;\n-        }\n+void TWriteOperation::AbortOnComplete(TColumnShard& /*owner*/) const {\n+    Y_ABORT_UNLESS(Status == EOperationStatus::Prepared);\n+}\n \n-        if (evWrite.Record.HasTxId() && evWrite.Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_PREPARE) {\n-            return EOperationBehaviour::InTxWrite;\n-        }\n-        return EOperationBehaviour::Undefined;\n-    }\n }   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/operations/write.h b/ydb/core/tx/columnshard/operations/write.h\nindex b72827af6c58..ad22caa651d4 100644\n--- a/ydb/core/tx/columnshard/operations/write.h\n+++ b/ydb/core/tx/columnshard/operations/write.h\n@@ -1,95 +1,83 @@\n #pragma once\n \n-#include <ydb/core/tx/data_events/write_data.h>\n-#include <ydb/core/tx/data_events/events.h>\n+#include <ydb/core/protos/tx_columnshard.pb.h>\n+#include <ydb/core/tablet_flat/flat_cxx_database.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n #include <ydb/core/tx/columnshard/engines/defs.h>\n-#include <ydb/core/protos/tx_columnshard.pb.h>\n+#include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n+#include <ydb/core/tx/data_events/events.h>\n+#include <ydb/core/tx/data_events/write_data.h>\n \n-#include <ydb/core/tablet_flat/flat_cxx_database.h>\n #include <ydb/library/accessor/accessor.h>\n \n #include <util/generic/map.h>\n-#include <tuple>\n \n+#include <tuple>\n \n namespace NKikimr::NTabletFlatExecutor {\n-    class TTransactionContext;\n+class TTransactionContext;\n+}\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+class TManager;\n }\n \n namespace NKikimr::NColumnShard {\n \n-    class TColumnShard;\n-\n-    using TWriteId = NOlap::TWriteId;\n-\n-    enum class EOperationStatus : ui32 {\n-        Draft = 1,\n-        Started = 2,\n-        Prepared = 3\n-    };\n-\n-     enum class EOperationBehaviour : ui32 {\n-        Undefined = 1,\n-        InTxWrite = 2,\n-        WriteWithLock = 3,\n-        CommitWriteLock = 4\n-    };\n-\n-    class TWriteOperation {\n-        YDB_READONLY(EOperationStatus, Status, EOperationStatus::Draft);\n-        YDB_READONLY_DEF(TInstant, CreatedAt);\n-        YDB_READONLY_DEF(TWriteId, WriteId);\n-        YDB_READONLY(ui64, LockId, 0);\n-        YDB_READONLY(ui64, Cookie, 0);\n-        YDB_READONLY_DEF(TVector<TWriteId>, GlobalWriteIds);\n-        YDB_ACCESSOR(EOperationBehaviour, Behaviour, EOperationBehaviour::Undefined);\n-        YDB_READONLY_DEF(std::optional<ui32>, GranuleShardingVersionId);\n-        YDB_READONLY(NEvWrite::EModificationType, ModificationType, NEvWrite::EModificationType::Upsert);\n-    public:\n-        using TPtr = std::shared_ptr<TWriteOperation>;\n-\n-        TWriteOperation(const TWriteId writeId, const ui64 lockId, const ui64 cookie, const EOperationStatus& status, const TInstant createdAt, const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType);\n-\n-        void Start(TColumnShard& owner, const ui64 tableId, const NEvWrite::IDataContainer::TPtr& data, \n-            const NActors::TActorId& source, const std::shared_ptr<NOlap::ISnapshotSchema>& schema, const TActorContext& ctx);\n-        void OnWriteFinish(NTabletFlatExecutor::TTransactionContext& txc, const TVector<TWriteId>& globalWriteIds);\n-        void Commit(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot) const;\n-        void Abort(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) const;\n-\n-        void Out(IOutputStream& out) const {\n-            out << \"write_id=\" << (ui64) WriteId << \";lock_id=\" << LockId;\n-        }\n-\n-        void ToProto(NKikimrTxColumnShard::TInternalOperationData& proto) const;\n-        void FromProto(const NKikimrTxColumnShard::TInternalOperationData& proto);\n-    };\n-\n-    class TOperationsManager {\n-        TMap<ui64, TVector<TWriteId>> Locks;\n-        TMap<ui64, ui64> Tx2Lock;\n-        TMap<TWriteId, TWriteOperation::TPtr> Operations;\n-        TWriteId LastWriteId = TWriteId(0);\n-\n-    public:\n-        bool Load(NTabletFlatExecutor::TTransactionContext& txc);\n-\n-        TWriteOperation::TPtr GetOperation(const TWriteId writeId) const;\n-        bool CommitTransaction(TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot);\n-        bool AbortTransaction(TColumnShard& owner, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n-        void LinkTransaction(const ui64 lockId, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n-        std::optional<ui64> GetLockForTx(const ui64 lockId) const;\n-\n-        TWriteOperation::TPtr RegisterOperation(const ui64 lockId, const ui64 cookie, const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType);\n-        static EOperationBehaviour GetBehaviour(const NEvents::TDataEvents::TEvWrite& evWrite);\n-\n-    private:\n-        TWriteId BuildNextWriteId();\n-        void RemoveOperation(const TWriteOperation::TPtr& op, NTabletFlatExecutor::TTransactionContext& txc);\n-        void OnTransactionFinish(const TVector<TWriteOperation::TPtr>& operations, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n-    };\n-}\n+class TColumnShard;\n+\n+using TOperationWriteId = NOlap::TOperationWriteId;\n+using TInsertWriteId = NOlap::TInsertWriteId;\n+\n+enum class EOperationStatus : ui32 {\n+    Draft = 1,\n+    Started = 2,\n+    Prepared = 3\n+};\n+\n+enum class EOperationBehaviour : ui32 {\n+    Undefined = 1,\n+    InTxWrite = 2,\n+    WriteWithLock = 3,\n+    CommitWriteLock = 4,\n+    AbortWriteLock = 5,\n+    NoTxWrite = 6\n+};\n+\n+class TWriteOperation {\n+    YDB_READONLY(EOperationStatus, Status, EOperationStatus::Draft);\n+    YDB_READONLY_DEF(TInstant, CreatedAt);\n+    YDB_READONLY_DEF(TOperationWriteId, WriteId);\n+    YDB_READONLY(ui64, LockId, 0);\n+    YDB_READONLY(ui64, Cookie, 0);\n+    YDB_READONLY_DEF(std::vector<TInsertWriteId>, InsertWriteIds);\n+    YDB_ACCESSOR(EOperationBehaviour, Behaviour, EOperationBehaviour::Undefined);\n+    YDB_READONLY_DEF(std::optional<ui32>, GranuleShardingVersionId);\n+    YDB_READONLY(NEvWrite::EModificationType, ModificationType, NEvWrite::EModificationType::Upsert);\n+\n+public:\n+    using TPtr = std::shared_ptr<TWriteOperation>;\n+\n+    TWriteOperation(const TOperationWriteId writeId, const ui64 lockId, const ui64 cookie, const EOperationStatus& status, const TInstant createdAt,\n+        const std::optional<ui32> granuleShardingVersionId, const NEvWrite::EModificationType mType);\n+\n+    void Start(TColumnShard& owner, const ui64 tableId, const NEvWrite::IDataContainer::TPtr& data, const NActors::TActorId& source,\n+        const std::shared_ptr<NOlap::ISnapshotSchema>& schema, const TActorContext& ctx);\n+    void OnWriteFinish(NTabletFlatExecutor::TTransactionContext& txc, const std::vector<TInsertWriteId>& insertWriteIds, const bool ephemeralFlag);\n+    void CommitOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc, const NOlap::TSnapshot& snapshot) const;\n+    void CommitOnComplete(TColumnShard& owner, const NOlap::TSnapshot& snapshot) const;\n+    void AbortOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) const;\n+    void AbortOnComplete(TColumnShard& owner) const;\n+\n+    void Out(IOutputStream& out) const {\n+        out << \"write_id=\" << (ui64)WriteId << \";lock_id=\" << LockId;\n+    }\n+\n+    void ToProto(NKikimrTxColumnShard::TInternalOperationData& proto) const;\n+    void FromProto(const NKikimrTxColumnShard::TInternalOperationData& proto);\n+};\n+\n+}   // namespace NKikimr::NColumnShard\n \n template <>\n inline void Out<NKikimr::NColumnShard::TWriteOperation>(IOutputStream& o, const NKikimr::NColumnShard::TWriteOperation& x) {\ndiff --git a/ydb/core/tx/columnshard/operations/write_data.cpp b/ydb/core/tx/columnshard/operations/write_data.cpp\nindex a0cd6450f534..56a0ad5e16cb 100644\n--- a/ydb/core/tx/columnshard/operations/write_data.cpp\n+++ b/ydb/core/tx/columnshard/operations/write_data.cpp\n@@ -31,7 +31,7 @@ bool TArrowData::Parse(const NKikimrDataEvents::TEvWrite_TOperation& proto, cons\n \n TConclusion<std::shared_ptr<arrow::RecordBatch>> TArrowData::ExtractBatch() {\n     Y_ABORT_UNLESS(!!IncomingData);\n-    auto result = NArrow::DeserializeBatch(IncomingData, BatchSchema->GetSchema());\n+    auto result = NArrow::DeserializeBatch(IncomingData, std::make_shared<arrow::Schema>(BatchSchema->GetSchema()->fields()));\n     IncomingData = \"\";\n     return result;\n }\ndiff --git a/ydb/core/tx/columnshard/operations/ya.make b/ydb/core/tx/columnshard/operations/ya.make\nindex c626a22b508b..c0bd3f234b78 100644\n--- a/ydb/core/tx/columnshard/operations/ya.make\n+++ b/ydb/core/tx/columnshard/operations/ya.make\n@@ -3,6 +3,7 @@ LIBRARY()\n SRCS(\n     write.cpp\n     write_data.cpp\n+    manager.cpp\n )\n \n PEERDIR(\n@@ -11,6 +12,7 @@ PEERDIR(\n     ydb/services/metadata\n     ydb/core/tx/columnshard/data_sharing/destination/events\n     ydb/core/tx/columnshard/data_reader\n+    ydb/core/tx/columnshard/transactions/locks\n     ydb/core/tx/columnshard/operations/batch_builder\n     ydb/core/tx/columnshard/operations/slice_builder\n )\ndiff --git a/ydb/core/tx/columnshard/resource_subscriber/counters.cpp b/ydb/core/tx/columnshard/resource_subscriber/counters.cpp\nindex 785ca04ba8f9..45f785c10223 100644\n--- a/ydb/core/tx/columnshard/resource_subscriber/counters.cpp\n+++ b/ydb/core/tx/columnshard/resource_subscriber/counters.cpp\n@@ -1,9 +1,12 @@\n #include \"counters.h\"\n \n+#include <util/system/guard.h>\n+\n namespace NKikimr::NOlap::NResourceBroker::NSubscribe {\n \n \n std::shared_ptr<TSubscriberTypeCounters> TSubscriberCounters::GetTypeCounters(const TString& resourceType) {\n+    TGuard lock(Mutex);\n     auto it = ResourceTypeCounters.find(resourceType);\n     if (it == ResourceTypeCounters.end()) {\n         it = ResourceTypeCounters.emplace(resourceType, std::make_shared<TSubscriberTypeCounters>(*this, resourceType)).first;\ndiff --git a/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.cpp b/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.cpp\nindex 646a458638dd..1e66bfb46e07 100644\n--- a/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.cpp\n+++ b/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.cpp\n@@ -4,23 +4,20 @@\n \n namespace NKikimr::NOlap {\n \n-TSimpleChunkMeta::TSimpleChunkMeta(const std::shared_ptr<arrow::Array>& column, const bool needMax, const bool isSortedColumn) {\n+TSimpleChunkMeta::TSimpleChunkMeta(\n+    const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const bool needMax, const bool isSortedColumn) {\n     Y_ABORT_UNLESS(column);\n-    Y_ABORT_UNLESS(column->length());\n-    NumRows = column->length();\n-    RawBytes = NArrow::GetArrayDataSize(column);\n+    Y_ABORT_UNLESS(column->GetRecordsCount());\n+    NumRows = column->GetRecordsCount();\n+    RawBytes = column->GetRawSizeVerified();\n \n     if (needMax) {\n-        std::pair<i32, i32> minMaxPos = {0, (column->length() - 1)};\n         if (!isSortedColumn) {\n-            minMaxPos = NArrow::FindMinMaxPosition(column);\n-            Y_ABORT_UNLESS(minMaxPos.first >= 0);\n-            Y_ABORT_UNLESS(minMaxPos.second >= 0);\n+            Max = column->GetMaxScalar();\n+        } else {\n+            Max = column->GetScalar(column->GetRecordsCount() - 1);\n         }\n-\n-        Max = NArrow::GetScalar(column, minMaxPos.second);\n-\n-        Y_ABORT_UNLESS(Max);\n+//        AFL_VERIFY(Max);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.h b/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.h\nindex 8f8f902e4095..526a2a037967 100644\n--- a/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.h\n+++ b/ydb/core/tx/columnshard/splitter/abstract/chunk_meta.h\n@@ -1,4 +1,6 @@\n #pragma once\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+\n #include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n \n@@ -17,7 +19,7 @@ class TSimpleChunkMeta {\n     ui32 RawBytes = 0;\n     TSimpleChunkMeta() = default;\n public:\n-    TSimpleChunkMeta(const std::shared_ptr<arrow::Array>& column, const bool needMinMax, const bool isSortedColumn);\n+    TSimpleChunkMeta(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& column, const bool needMinMax, const bool isSortedColumn);\n \n     ui64 GetMetadataSize() const {\n         return sizeof(ui32) + sizeof(ui32) + 8 * 3 * 2;\ndiff --git a/ydb/core/tx/columnshard/splitter/abstract/chunks.h b/ydb/core/tx/columnshard/splitter/abstract/chunks.h\nindex 3463fcea0374..d0300915f098 100644\n--- a/ydb/core/tx/columnshard/splitter/abstract/chunks.h\n+++ b/ydb/core/tx/columnshard/splitter/abstract/chunks.h\n@@ -15,7 +15,6 @@ namespace NKikimr::NOlap {\n class TPortionInfo;\n class TPortionInfoConstructor;\n class TSimpleColumnInfo;\n-class TColumnSaver;\n \n class IPortionDataChunk {\n private:\ndiff --git a/ydb/core/tx/columnshard/splitter/batch_slice.cpp b/ydb/core/tx/columnshard/splitter/batch_slice.cpp\nindex 15fd2506e3ba..7f6cc05c1e7b 100644\n--- a/ydb/core/tx/columnshard/splitter/batch_slice.cpp\n+++ b/ydb/core/tx/columnshard/splitter/batch_slice.cpp\n@@ -1,5 +1,4 @@\n #include \"batch_slice.h\"\n-#include \"simple.h\"\n #include <ydb/library/accessor/validator.h>\n \n namespace NKikimr::NOlap {\n@@ -148,7 +147,8 @@ bool TGeneralSerializedSlice::GroupBlobsImpl(const NSplitter::TGroupFeatures& fe\n     return true;\n }\n \n-TGeneralSerializedSlice::TGeneralSerializedSlice(const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& data, ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters)\n+TGeneralSerializedSlice::TGeneralSerializedSlice(const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& data,\n+    NArrow::NSplitter::ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters)\n     : Schema(schema)\n     , Counters(counters) {\n     std::optional<ui32> recordsCount;\n@@ -169,60 +169,14 @@ TGeneralSerializedSlice::TGeneralSerializedSlice(const THashMap<ui32, std::vecto\n     RecordsCount = *recordsCount;\n }\n \n-TGeneralSerializedSlice::TGeneralSerializedSlice(const ui32 recordsCount, ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters)\n+TGeneralSerializedSlice::TGeneralSerializedSlice(\n+    const ui32 recordsCount, NArrow::NSplitter::ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters)\n     : RecordsCount(recordsCount)\n     , Schema(schema)\n     , Counters(counters)\n {\n }\n \n-TBatchSerializedSlice::TBatchSerializedSlice(const std::shared_ptr<arrow::RecordBatch>& batch, ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters,\n-    const NSplitter::TSplitSettings& settings)\n-    : TBase(TValidator::CheckNotNull(batch)->num_rows(), schema, counters)\n-    , Batch(batch)\n-{\n-    Y_ABORT_UNLESS(batch);\n-    Data.reserve(batch->num_columns());\n-    for (auto&& i : batch->schema()->fields()) {\n-        TSplittedEntity c(schema->GetColumnId(i->name()));\n-        Data.emplace_back(std::move(c));\n-    }\n-\n-    ui32 idx = 0;\n-    for (auto&& i : batch->columns()) {\n-        auto& c = Data[idx];\n-        auto columnSaver = schema->GetColumnSaver(c.GetEntityId());\n-        auto stats = schema->GetColumnSerializationStats(c.GetEntityId());\n-        TSimpleSplitter splitter(columnSaver, Counters);\n-        splitter.SetStats(stats);\n-        std::vector<std::shared_ptr<IPortionDataChunk>> chunks;\n-        for (auto&& i : splitter.Split(i, Schema->GetField(c.GetEntityId()), settings.GetMaxBlobSize())) {\n-            chunks.emplace_back(std::make_shared<TSplittedColumnChunk>(c.GetEntityId(), i, Schema));\n-        }\n-        c.SetChunks(chunks);\n-        Size += c.GetSize();\n-        ++idx;\n-    }\n-}\n-\n-std::vector<NKikimr::NOlap::TBatchSerializedSlice> TBatchSerializedSlice::BuildSimpleSlices(const std::shared_ptr<arrow::RecordBatch>& batch, const NSplitter::TSplitSettings& settings, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const ISchemaDetailInfo::TPtr& schemaInfo) {\n-    std::vector<TBatchSerializedSlice> slices;\n-    auto stats = schemaInfo->GetBatchSerializationStats(batch);\n-    ui32 recordsCount = settings.GetMinRecordsCount();\n-    if (stats) {\n-        const ui32 recordsCountForMinSize = stats->PredictOptimalPackRecordsCount(batch->num_rows(), settings.GetMinBlobSize()).value_or(recordsCount);\n-        const ui32 recordsCountForMaxPortionSize = stats->PredictOptimalPackRecordsCount(batch->num_rows(), settings.GetMaxPortionSize()).value_or(recordsCount);\n-        recordsCount = std::min(recordsCountForMaxPortionSize, std::max(recordsCount, recordsCountForMinSize));\n-    }\n-    auto linearSplitInfo = TSimpleSplitter::GetOptimalLinearSplitting(batch->num_rows(), recordsCount);\n-    for (auto it = linearSplitInfo.StartIterator(); it.IsValid(); it.Next()) {\n-        std::shared_ptr<arrow::RecordBatch> current = batch->Slice(it.GetPosition(), it.GetCurrentPackSize());\n-        TBatchSerializedSlice slice(current, schemaInfo, counters, settings);\n-        slices.emplace_back(std::move(slice));\n-    }\n-    return slices;\n-}\n-\n void TGeneralSerializedSlice::MergeSlice(TGeneralSerializedSlice&& slice) {\n     Y_ABORT_UNLESS(Data.size() == slice.Data.size());\n     RecordsCount += slice.GetRecordsCount();\ndiff --git a/ydb/core/tx/columnshard/splitter/batch_slice.h b/ydb/core/tx/columnshard/splitter/batch_slice.h\nindex 00a27a3d4739..f1b019544d8c 100644\n--- a/ydb/core/tx/columnshard/splitter/batch_slice.h\n+++ b/ydb/core/tx/columnshard/splitter/batch_slice.h\n@@ -1,10 +1,10 @@\n #pragma once\n #include \"chunks.h\"\n-#include \"stats.h\"\n-#include \"scheme_info.h\"\n #include \"column_info.h\"\n #include \"blob_info.h\"\n-#include \"similar_packer.h\"\n+#include <ydb/core/formats/arrow/splitter/scheme_info.h>\n+#include <ydb/library/formats/arrow/splitter/stats.h>\n+#include <ydb/library/formats/arrow/splitter/similar_packer.h>\n #include <ydb/core/tx/columnshard/counters/indexation.h>\n #include <ydb/core/tx/columnshard/engines/scheme/column_features.h>\n #include <ydb/core/tx/columnshard/engines/scheme/abstract_scheme.h>\n@@ -14,16 +14,17 @@\n \n namespace NKikimr::NOlap {\n \n-class TDefaultSchemaDetails: public ISchemaDetailInfo {\n+class TDefaultSchemaDetails: public NArrow::NSplitter::ISchemaDetailInfo {\n private:\n     ISnapshotSchema::TPtr Schema;\n-    std::shared_ptr<TSerializationStats> Stats;\n+    std::shared_ptr<NArrow::NSplitter::TSerializationStats> Stats;\n+\n protected:\n     virtual TColumnSaver DoGetColumnSaver(const ui32 columnId) const override {\n         return Schema->GetColumnSaver(columnId);\n     }\n public:\n-    TDefaultSchemaDetails(ISnapshotSchema::TPtr schema, const std::shared_ptr<TSerializationStats>& stats)\n+    TDefaultSchemaDetails(ISnapshotSchema::TPtr schema, const std::shared_ptr<NArrow::NSplitter::TSerializationStats>& stats)\n         : Schema(schema)\n         , Stats(stats)\n     {\n@@ -39,14 +40,15 @@ class TDefaultSchemaDetails: public ISchemaDetailInfo {\n         return Schema->GetIndexInfo().IsSortedColumn(columnId);\n     }\n \n-    virtual std::optional<TColumnSerializationStat> GetColumnSerializationStats(const ui32 columnId) const override {\n+    virtual std::optional<NArrow::NSplitter::TColumnSerializationStat> GetColumnSerializationStats(const ui32 columnId) const override {\n         auto stats = Stats->GetColumnInfo(columnId);\n         if (stats && stats->GetRecordsCount() != 0) {\n             return stats;\n         }\n         return std::nullopt;\n     }\n-    virtual std::optional<TBatchSerializationStat> GetBatchSerializationStats(const std::shared_ptr<arrow::RecordBatch>& rb) const override {\n+    virtual std::optional<NArrow::NSplitter::TBatchSerializationStat> GetBatchSerializationStats(\n+        const std::shared_ptr<arrow::RecordBatch>& rb) const override {\n         return Stats->GetStatsForRecordBatch(rb);\n     }\n     virtual ui32 GetColumnId(const std::string& fieldName) const override {\n@@ -61,7 +63,7 @@ class TGeneralSerializedSlice {\n protected:\n     std::vector<TSplittedEntity> Data;\n     ui64 Size = 0;\n-    ISchemaDetailInfo::TPtr Schema;\n+    NArrow::NSplitter::ISchemaDetailInfo::TPtr Schema;\n     std::shared_ptr<NColumnShard::TSplitterCounters> Counters;\n     TGeneralSerializedSlice() = default;\n \n@@ -116,15 +118,17 @@ class TGeneralSerializedSlice {\n         return blobs;\n     }\n \n-    explicit TGeneralSerializedSlice(TVectorView<TGeneralSerializedSlice>&& objects) {\n+    explicit TGeneralSerializedSlice(NArrow::NSplitter::TVectorView<TGeneralSerializedSlice>&& objects) {\n         Y_ABORT_UNLESS(objects.size());\n         std::swap(*this, objects.front());\n         for (ui32 i = 1; i < objects.size(); ++i) {\n             MergeSlice(std::move(objects[i]));\n         }\n     }\n-    TGeneralSerializedSlice(const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& data, ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters);\n-    TGeneralSerializedSlice(const ui32 recordsCount, ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters);\n+    TGeneralSerializedSlice(const THashMap<ui32, std::vector<std::shared_ptr<IPortionDataChunk>>>& data,\n+        NArrow::NSplitter::ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters);\n+    TGeneralSerializedSlice(\n+        const ui32 recordsCount, NArrow::NSplitter::ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters);\n \n     void MergeSlice(TGeneralSerializedSlice&& slice);\n \n@@ -135,28 +139,4 @@ class TGeneralSerializedSlice {\n     }\n };\n \n-class TBatchSerializedSlice: public TGeneralSerializedSlice {\n-private:\n-    using TBase = TGeneralSerializedSlice;\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, Batch);\n-public:\n-    TBatchSerializedSlice(const std::shared_ptr<arrow::RecordBatch>& batch, ISchemaDetailInfo::TPtr schema, std::shared_ptr<NColumnShard::TSplitterCounters> counters, const NSplitter::TSplitSettings& settings);\n-\n-    explicit TBatchSerializedSlice(TVectorView<TBatchSerializedSlice>&& objects) {\n-        Y_ABORT_UNLESS(objects.size());\n-        std::swap(*this, objects.front());\n-        for (ui32 i = 1; i < objects.size(); ++i) {\n-            MergeSlice(std::move(objects[i]));\n-        }\n-    }\n-    void MergeSlice(TBatchSerializedSlice&& slice) {\n-        Batch = NArrow::CombineBatches({Batch, slice.Batch});\n-        TBase::MergeSlice(std::move(slice));\n-    }\n-\n-    static std::vector<TBatchSerializedSlice> BuildSimpleSlices(const std::shared_ptr<arrow::RecordBatch>& batch, const NSplitter::TSplitSettings& settings,\n-        const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const ISchemaDetailInfo::TPtr& schemaInfo);\n-\n-};\n-\n }\ndiff --git a/ydb/core/tx/columnshard/splitter/chunks.h b/ydb/core/tx/columnshard/splitter/chunks.h\nindex 280f47d8c238..e86806da299a 100644\n--- a/ydb/core/tx/columnshard/splitter/chunks.h\n+++ b/ydb/core/tx/columnshard/splitter/chunks.h\n@@ -27,8 +27,10 @@ class IPortionColumnChunk : public IPortionDataChunk {\n \n     virtual void DoAddIntoPortionBeforeBlob(const TBlobRangeLink16& bRange, TPortionInfoConstructor& portionInfo) const override;\n \n-    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplitImpl(const TColumnSaver& saver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const = 0;\n-    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplit(const TColumnSaver& saver, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const override;\n+    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplitImpl(const TColumnSaver& saver,\n+        const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const = 0;\n+    virtual std::vector<std::shared_ptr<IPortionDataChunk>> DoInternalSplit(const TColumnSaver& saver,\n+        const std::shared_ptr<NColumnShard::TSplitterCounters>& counters, const std::vector<ui64>& splitSizes) const override;\n     virtual bool DoIsSplittable() const override {\n         return GetRecordsCount() > 1;\n     }\n@@ -53,7 +55,8 @@ class TChunkedColumnReader {\n     std::vector<std::shared_ptr<IPortionDataChunk>> Chunks;\n     std::shared_ptr<TColumnLoader> Loader;\n \n-    std::shared_ptr<arrow::Array> CurrentChunk;\n+    std::shared_ptr<NArrow::NAccessor::IChunkedArray> CurrentChunk;\n+    std::optional<NArrow::NAccessor::IChunkedArray::TFullDataAddress> CurrentChunkArray;\n     ui32 CurrentChunkIndex = 0;\n     ui32 CurrentRecordIndex = 0;\n public:\n@@ -68,16 +71,29 @@ class TChunkedColumnReader {\n         CurrentChunkIndex = 0;\n         CurrentRecordIndex = 0;\n         if (Chunks.size()) {\n-            CurrentChunk = Loader->ApplyVerifiedColumn(Chunks.front()->GetData());\n+            CurrentChunk = Loader->ApplyVerified(Chunks.front()->GetData(), Chunks.front()->GetRecordsCountVerified());\n+            CurrentChunkArray.reset();\n         }\n     }\n \n-    const std::shared_ptr<arrow::Array>& GetCurrentChunk() const {\n+    const std::shared_ptr<arrow::Array>& GetCurrentChunk() {\n+        if (!CurrentChunkArray || !CurrentChunkArray->GetAddress().Contains(CurrentRecordIndex)) {\n+            CurrentChunkArray = CurrentChunk->GetChunk(CurrentChunkArray, CurrentRecordIndex);\n+        }\n+        AFL_VERIFY(CurrentChunkArray);\n+        return CurrentChunkArray->GetArray();\n+    }\n+\n+    const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& GetCurrentAccessor() const {\n+        AFL_VERIFY(CurrentChunk);\n         return CurrentChunk;\n     }\n \n-    ui32 GetCurrentRecordIndex() const {\n-        return CurrentRecordIndex;\n+    ui32 GetCurrentRecordIndex() {\n+        if (!CurrentChunkArray || !CurrentChunkArray->GetAddress().Contains(CurrentRecordIndex)) {\n+            CurrentChunkArray = CurrentChunk->GetChunk(CurrentChunkArray->GetAddress(), CurrentRecordIndex);\n+        }\n+        return CurrentChunkArray->GetAddress().GetLocalIndex(CurrentRecordIndex);\n     }\n \n     bool IsCorrect() const {\n@@ -86,19 +102,21 @@ class TChunkedColumnReader {\n \n     bool ReadNextChunk() {\n         while (++CurrentChunkIndex < Chunks.size()) {\n-            CurrentChunk = Loader->ApplyVerifiedColumn(Chunks[CurrentChunkIndex]->GetData());\n+            CurrentChunk = Loader->ApplyVerified(Chunks[CurrentChunkIndex]->GetData(), Chunks[CurrentChunkIndex]->GetRecordsCountVerified());\n+            CurrentChunkArray.reset();\n             CurrentRecordIndex = 0;\n-            if (CurrentRecordIndex < CurrentChunk->length()) {\n+            if (CurrentRecordIndex < CurrentChunk->GetRecordsCount()) {\n                 return true;\n             }\n         }\n+        CurrentChunkArray.reset();\n         CurrentChunk = nullptr;\n         return false;\n     }\n \n     bool ReadNext() {\n         AFL_VERIFY(!!CurrentChunk);\n-        if (++CurrentRecordIndex < CurrentChunk->length()) {\n+        if (++CurrentRecordIndex < CurrentChunk->GetRecordsCount()) {\n             return true;\n         }\n         return ReadNextChunk();\n@@ -156,6 +174,14 @@ class TChunkedBatchReader {\n     std::vector<TChunkedColumnReader>::const_iterator end() const {\n         return Columns.end();\n     }\n+\n+    std::vector<TChunkedColumnReader>::iterator begin() {\n+        return Columns.begin();\n+    }\n+\n+    std::vector<TChunkedColumnReader>::iterator end() {\n+        return Columns.end();\n+    }\n };\n \n }\ndiff --git a/ydb/core/tx/columnshard/splitter/scheme_info.cpp b/ydb/core/tx/columnshard/splitter/scheme_info.cpp\ndeleted file mode 100644\nindex fe4a65604e11..000000000000\n--- a/ydb/core/tx/columnshard/splitter/scheme_info.cpp\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-#include \"scheme_info.h\"\n-\n-namespace NKikimr::NOlap {\n-\n-NKikimr::NOlap::TColumnSaver ISchemaDetailInfo::GetColumnSaver(const ui32 columnId) const {\n-    auto saver = DoGetColumnSaver(columnId);\n-    if (OverrideSerializer) {\n-        saver.ResetSerializer(*OverrideSerializer);\n-    }\n-    return saver;\n-}\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/splitter/ut/batch_slice.cpp b/ydb/core/tx/columnshard/splitter/ut/batch_slice.cpp\nnew file mode 100644\nindex 000000000000..880881238fa1\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/splitter/ut/batch_slice.cpp\n@@ -0,0 +1,65 @@\n+#include \"batch_slice.h\"\n+\n+#include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n+#include <ydb/core/formats/arrow/splitter/simple.h>\n+#include <ydb/core/tx/columnshard/engines/storage/chunks/column.h>\n+\n+#include <ydb/library/accessor/validator.h>\n+\n+namespace NKikimr::NOlap {\n+\n+TBatchSerializedSlice::TBatchSerializedSlice(const std::shared_ptr<arrow::RecordBatch>& batch, NArrow::NSplitter::ISchemaDetailInfo::TPtr schema,\n+    std::shared_ptr<NColumnShard::TSplitterCounters> counters, const NSplitter::TSplitSettings& settings)\n+    : TBase(TValidator::CheckNotNull(batch)->num_rows(), schema, counters)\n+    , Batch(batch) {\n+    Y_ABORT_UNLESS(batch);\n+    Data.reserve(batch->num_columns());\n+    for (auto&& i : batch->schema()->fields()) {\n+        TSplittedEntity c(schema->GetColumnId(i->name()));\n+        Data.emplace_back(std::move(c));\n+    }\n+\n+    ui32 idx = 0;\n+    for (auto&& i : batch->columns()) {\n+        auto& c = Data[idx];\n+        auto columnSaver = schema->GetColumnSaver(c.GetEntityId());\n+        auto stats = schema->GetColumnSerializationStats(c.GetEntityId());\n+        NKikimr::NArrow::NSplitter::TSimpleSplitter splitter(columnSaver);\n+        splitter.SetStats(stats);\n+        std::vector<std::shared_ptr<IPortionDataChunk>> chunks;\n+        for (auto&& i : splitter.Split(i, Schema->GetField(c.GetEntityId()), settings.GetMaxBlobSize())) {\n+            NOlap::TSimpleColumnInfo columnInfo(c.GetEntityId(), Schema->GetField(c.GetEntityId()),\n+                Schema->GetColumnSaver(c.GetEntityId()).GetSerializer(), true, false, true, nullptr);\n+            chunks.emplace_back(std::make_shared<NOlap::NChunks::TChunkPreparation>(i.GetSerializedChunk(),\n+                std::make_shared<NArrow::NAccessor::TTrivialArray>(i.GetSlicedBatch()->column(0)), TChunkAddress(c.GetEntityId(), 0),\n+                columnInfo));\n+        }\n+        c.SetChunks(chunks);\n+        Size += c.GetSize();\n+        ++idx;\n+    }\n+}\n+\n+std::vector<TBatchSerializedSlice> TBatchSerializedSlice::BuildSimpleSlices(const std::shared_ptr<arrow::RecordBatch>& batch,\n+    const NSplitter::TSplitSettings& settings, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters,\n+    const NArrow::NSplitter::ISchemaDetailInfo::TPtr& schemaInfo) {\n+    std::vector<TBatchSerializedSlice> slices;\n+    auto stats = schemaInfo->GetBatchSerializationStats(batch);\n+    ui32 recordsCount = settings.GetMinRecordsCount();\n+    if (stats) {\n+        const ui32 recordsCountForMinSize =\n+            stats->PredictOptimalPackRecordsCount(batch->num_rows(), settings.GetMinBlobSize()).value_or(recordsCount);\n+        const ui32 recordsCountForMaxPortionSize =\n+            stats->PredictOptimalPackRecordsCount(batch->num_rows(), settings.GetMaxPortionSize()).value_or(recordsCount);\n+        recordsCount = std::min(recordsCountForMaxPortionSize, std::max(recordsCount, recordsCountForMinSize));\n+    }\n+    auto linearSplitInfo = NKikimr::NArrow::NSplitter::TSimpleSplitter::GetOptimalLinearSplitting(batch->num_rows(), recordsCount);\n+    for (auto it = linearSplitInfo.StartIterator(); it.IsValid(); it.Next()) {\n+        std::shared_ptr<arrow::RecordBatch> current = batch->Slice(it.GetPosition(), it.GetCurrentPackSize());\n+        TBatchSerializedSlice slice(current, schemaInfo, counters, settings);\n+        slices.emplace_back(std::move(slice));\n+    }\n+    return slices;\n+}\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/splitter/ut/batch_slice.h b/ydb/core/tx/columnshard/splitter/ut/batch_slice.h\nnew file mode 100644\nindex 000000000000..c085eb1568ce\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/splitter/ut/batch_slice.h\n@@ -0,0 +1,31 @@\n+#pragma once\n+#include <ydb/core/tx/columnshard/splitter/batch_slice.h>\n+\n+namespace NKikimr::NOlap {\n+\n+class TBatchSerializedSlice: public TGeneralSerializedSlice {\n+private:\n+    using TBase = TGeneralSerializedSlice;\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, Batch);\n+\n+public:\n+    TBatchSerializedSlice(const std::shared_ptr<arrow::RecordBatch>& batch, NArrow::NSplitter::ISchemaDetailInfo::TPtr schema,\n+        std::shared_ptr<NColumnShard::TSplitterCounters> counters, const NSplitter::TSplitSettings& settings);\n+\n+    explicit TBatchSerializedSlice(NArrow::NSplitter::TVectorView<TBatchSerializedSlice>&& objects) {\n+        Y_ABORT_UNLESS(objects.size());\n+        std::swap(*this, objects.front());\n+        for (ui32 i = 1; i < objects.size(); ++i) {\n+            MergeSlice(std::move(objects[i]));\n+        }\n+    }\n+    void MergeSlice(TBatchSerializedSlice&& slice) {\n+        Batch = NArrow::CombineBatches({ Batch, slice.Batch });\n+        TBase::MergeSlice(std::move(slice));\n+    }\n+\n+    static std::vector<TBatchSerializedSlice> BuildSimpleSlices(const std::shared_ptr<arrow::RecordBatch>& batch,\n+        const NSplitter::TSplitSettings& settings, const std::shared_ptr<NColumnShard::TSplitterCounters>& counters,\n+        const NArrow::NSplitter::ISchemaDetailInfo::TPtr& schemaInfo);\n+};\n+}\ndiff --git a/ydb/core/tx/columnshard/splitter/ut/ut_splitter.cpp b/ydb/core/tx/columnshard/splitter/ut/ut_splitter.cpp\nindex f2f942dbbab3..7ca04ee36933 100644\n--- a/ydb/core/tx/columnshard/splitter/ut/ut_splitter.cpp\n+++ b/ydb/core/tx/columnshard/splitter/ut/ut_splitter.cpp\n@@ -1,29 +1,32 @@\n-#include <ydb/core/tx/columnshard/splitter/batch_slice.h>\n-#include <ydb/core/tx/columnshard/splitter/settings.h>\n-#include <ydb/core/tx/columnshard/splitter/scheme_info.h>\n-#include <ydb/core/tx/columnshard/splitter/similar_packer.h>\n-#include <ydb/core/tx/columnshard/counters/indexation.h>\n-#include <ydb/core/tx/columnshard/engines/scheme/abstract/saver.h>\n+#include \"batch_slice.h\"\n \n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>\n+#include <ydb/core/formats/arrow/save_load/loader.h>\n+#include <ydb/core/formats/arrow/save_load/saver.h>\n #include <ydb/core/formats/arrow/serializer/native.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-\n-#include <library/cpp/testing/unittest/registar.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n+#include <ydb/core/formats/arrow/splitter/scheme_info.h>\n+#include <ydb/library/formats/arrow/splitter/similar_packer.h>\n+#include <ydb/core/tx/columnshard/counters/indexation.h>\n+#include <ydb/core/tx/columnshard/splitter/batch_slice.h>\n+#include <ydb/core/tx/columnshard/splitter/settings.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <library/cpp/testing/unittest/registar.h>\n \n Y_UNIT_TEST_SUITE(Splitter) {\n-\n     using namespace NKikimr::NArrow;\n \n-    class TTestSnapshotSchema: public NKikimr::NOlap::ISchemaDetailInfo {\n+    class TTestSnapshotSchema: public NKikimr::NArrow::NSplitter::ISchemaDetailInfo {\n     private:\n         mutable std::map<std::string, ui32> Decoder;\n+\n     protected:\n-        virtual NKikimr::NOlap::TColumnSaver DoGetColumnSaver(const ui32 columnId) const override {\n-            return NKikimr::NOlap::TColumnSaver(nullptr, std::make_shared<NSerialization::TNativeSerializer>(arrow::ipc::IpcOptions::Defaults()));\n+        virtual NKikimr::NArrow::NAccessor::TColumnSaver DoGetColumnSaver(const ui32 columnId) const override {\n+            return NKikimr::NArrow::NAccessor::TColumnSaver(\n+                nullptr, std::make_shared<NSerialization::TNativeSerializer>(arrow::ipc::IpcOptions::Defaults()));\n         }\n \n     public:\n@@ -34,17 +37,18 @@ Y_UNIT_TEST_SUITE(Splitter) {\n             return false;\n         }\n \n-        virtual std::optional<NKikimr::NOlap::TColumnSerializationStat> GetColumnSerializationStats(const ui32 /*columnId*/) const override {\n+        virtual std::optional<NKikimr::NArrow::NSplitter::TColumnSerializationStat> GetColumnSerializationStats(\n+            const ui32 /*columnId*/) const override {\n             return {};\n         }\n-        virtual std::optional<NKikimr::NOlap::TBatchSerializationStat> GetBatchSerializationStats(const std::shared_ptr<arrow::RecordBatch>& /*rb*/) const override {\n+        virtual std::optional<NKikimr::NArrow::NSplitter::TBatchSerializationStat> GetBatchSerializationStats(\n+            const std::shared_ptr<arrow::RecordBatch>& /*rb*/) const override {\n             return {};\n         }\n \n-        NKikimr::NOlap::TColumnLoader GetColumnLoader(const ui32 columnId) const {\n-            arrow::FieldVector v = {std::make_shared<arrow::Field>(GetColumnName(columnId), std::make_shared<arrow::StringType>())};\n-            auto schema = std::make_shared<arrow::Schema>(v);\n-            return NKikimr::NOlap::TColumnLoader(nullptr, NSerialization::TSerializerContainer::GetDefaultSerializer(), schema, nullptr, columnId);\n+        NKikimr::NArrow::NAccessor::TColumnLoader GetColumnLoader(const ui32 columnId) const {\n+            return NKikimr::NArrow::NAccessor::TColumnLoader(nullptr, NSerialization::TSerializerContainer::GetDefaultSerializer(),\n+                NKikimr::NArrow::NAccessor::TConstructorContainer::GetDefaultConstructor(), GetField(columnId), nullptr, columnId);\n         }\n \n         virtual std::shared_ptr<arrow::Field> GetField(const ui32 columnId) const override {\n@@ -80,9 +84,8 @@ Y_UNIT_TEST_SUITE(Splitter) {\n         YDB_ACCESSOR(std::optional<ui32>, ExpectedInternalSplitsCount, 0);\n \n     public:\n-        void Execute(std::shared_ptr<arrow::RecordBatch> batch, \n-            const NKikimr::NOlap::NSplitter::TSplitSettings& settings = NKikimr::NOlap::NSplitter::TSplitSettings()\n-            ) {\n+        void Execute(std::shared_ptr<arrow::RecordBatch> batch,\n+            const NKikimr::NOlap::NSplitter::TSplitSettings& settings = NKikimr::NOlap::NSplitter::TSplitSettings()) {\n             using namespace NKikimr::NOlap;\n             NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n             std::vector<TGeneralSerializedSlice> generalSlices;\n@@ -93,9 +96,9 @@ Y_UNIT_TEST_SUITE(Splitter) {\n                 }\n             }\n \n-            TSimilarPacker packer(settings.GetExpectedPortionSize());\n+            NKikimr::NArrow::NSplitter::TSimilarPacker packer(settings.GetExpectedPortionSize());\n             auto packs = packer.Split(generalSlices);\n-            const NSplitter::TEntityGroups groups(settings, \"default\");\n+            const NKikimr::NOlap::NSplitter::TEntityGroups groups(settings, \"default\");\n             const ui32 portionsCount = packs.size();\n             ui32 blobsCount = 0;\n             ui32 chunksCount = 0;\n@@ -129,9 +132,11 @@ Y_UNIT_TEST_SUITE(Splitter) {\n                     }\n                     portionSize += bSize;\n                     AFL_VERIFY(bSize < (ui64)settings.GetMaxBlobSize());\n-                    AFL_VERIFY(bSize * 1.01 > (ui64)settings.GetMinBlobSize() || (packs.size() == 1 && blobsLocal.size() == 1))(\"blob_size\", bSize);\n+                    AFL_VERIFY(bSize * 1.01 > (ui64)settings.GetMinBlobSize() || (packs.size() == 1 && blobsLocal.size() == 1))(\n+                                                                                                           \"blob_size\", bSize);\n                 }\n-                AFL_VERIFY(portionSize >= settings.GetExpectedPortionSize() || packs.size() == 1)(\"size\", portionSize)(\"limit\", settings.GetMaxPortionSize());\n+                AFL_VERIFY(portionSize >= settings.GetExpectedPortionSize() || packs.size() == 1)(\"size\", portionSize)(\n+                                                                                   \"limit\", settings.GetMaxPortionSize());\n \n                 THashMap<ui32, std::set<ui32>> entitiesByRecordsCount;\n                 ui32 pagesRestore = 0;\n@@ -141,7 +146,7 @@ Y_UNIT_TEST_SUITE(Splitter) {\n                     ui32 count = 0;\n                     for (auto&& c : e.second) {\n                         auto slice = arr->Slice(count + portionShift, c->GetRecordsCountVerified());\n-                        auto readBatch = *Schema->GetColumnLoader(e.first).Apply(c->GetData());\n+                        auto readBatch = Schema->GetColumnLoader(e.first).ApplyRawVerified(c->GetData());\n                         AFL_VERIFY(slice->length() == readBatch->num_rows());\n                         Y_ABORT_UNLESS(readBatch->column(0)->RangeEquals(*slice, 0, readBatch->num_rows(), 0, arrow::EqualOptions::Defaults()));\n                         count += c->GetRecordsCountVerified();\n@@ -161,91 +166,107 @@ Y_UNIT_TEST_SUITE(Splitter) {\n             }\n             AFL_VERIFY(portionShift = batch->num_rows());\n             AFL_VERIFY(pagesSum == generalSlices.size())(\"sum\", pagesSum)(\"general_slices\", generalSlices.size());\n-            AFL_VERIFY(internalSplitsCount == ExpectedInternalSplitsCount.value_or(internalSplitsCount))(\"expected\", *ExpectedInternalSplitsCount)(\"real\", internalSplitsCount);\n+            AFL_VERIFY(internalSplitsCount == ExpectedInternalSplitsCount.value_or(internalSplitsCount))(\n+                                                  \"expected\", *ExpectedInternalSplitsCount)(\"real\", internalSplitsCount);\n             AFL_VERIFY(blobsCount == ExpectBlobsCount.value_or(blobsCount))(\"blobs_count\", blobsCount)(\"expected\", *ExpectBlobsCount);\n             AFL_VERIFY(pagesSum == ExpectSlicesCount.value_or(pagesSum))(\"sum\", pagesSum)(\"expected\", *ExpectSlicesCount);\n-            AFL_VERIFY(portionsCount == ExpectPortionsCount.value_or(portionsCount))(\"portions_count\", portionsCount)(\"expected\", *ExpectPortionsCount);\n+            AFL_VERIFY(portionsCount == ExpectPortionsCount.value_or(portionsCount))(\"portions_count\", portionsCount)(\n+                                            \"expected\", *ExpectPortionsCount);\n             AFL_VERIFY(chunksCount == ExpectChunksCount.value_or(chunksCount))(\"chunks_count\", chunksCount)(\"expected\", *ExpectChunksCount);\n-            \n         }\n     };\n \n     Y_UNIT_TEST(Simple) {\n-        NConstruction::IArrayBuilder::TPtr column = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({column}).BuildBatch(80048);\n+        NConstruction::IArrayBuilder::TPtr column =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n+        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ column }).BuildBatch(80048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n         TSplitTester().SetExpectBlobsCount(8).SetExpectSlicesCount(8).Execute(batch);\n     }\n \n     Y_UNIT_TEST(Small) {\n-        NConstruction::IArrayBuilder::TPtr column = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 24));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({column}).BuildBatch(80048);\n+        NConstruction::IArrayBuilder::TPtr column =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 24));\n+        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ column }).BuildBatch(80048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n         TSplitTester().SetExpectBlobsCount(1).SetExpectSlicesCount(8).Execute(batch);\n     }\n \n     Y_UNIT_TEST(Minimal) {\n-        NConstruction::IArrayBuilder::TPtr column = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({column}).BuildBatch(4048);\n+        NConstruction::IArrayBuilder::TPtr column =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n+        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ column }).BuildBatch(4048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n         TSplitTester().SetExpectBlobsCount(1).SetExpectSlicesCount(1).Execute(batch);\n     }\n \n     Y_UNIT_TEST(Trivial) {\n-        NConstruction::IArrayBuilder::TPtr column = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({column}).BuildBatch(10048);\n+        NConstruction::IArrayBuilder::TPtr column =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n+        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ column }).BuildBatch(10048);\n \n         TSplitTester().SetExpectBlobsCount(1).SetExpectSlicesCount(1).Execute(batch);\n     }\n \n     Y_UNIT_TEST(BigAndSmall) {\n-        NConstruction::IArrayBuilder::TPtr columnBig = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n-        NConstruction::IArrayBuilder::TPtr columnSmall = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field2\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 1));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({columnBig, columnSmall}).BuildBatch(80048);\n+        NConstruction::IArrayBuilder::TPtr columnBig =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 512));\n+        NConstruction::IArrayBuilder::TPtr columnSmall =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field2\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 1));\n+        std::shared_ptr<arrow::RecordBatch> batch =\n+            NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ columnBig, columnSmall }).BuildBatch(80048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n         TSplitTester().SetExpectBlobsCount(8).SetExpectSlicesCount(8).Execute(batch);\n     }\n \n     Y_UNIT_TEST(CritSmallPortions) {\n-        NConstruction::IArrayBuilder::TPtr columnBig = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 7120));\n-        NConstruction::IArrayBuilder::TPtr columnSmall = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field2\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 128));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({columnBig, columnSmall}).BuildBatch(80048);\n+        NConstruction::IArrayBuilder::TPtr columnBig =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 7120));\n+        NConstruction::IArrayBuilder::TPtr columnSmall =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field2\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 128));\n+        std::shared_ptr<arrow::RecordBatch> batch =\n+            NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ columnBig, columnSmall }).BuildBatch(80048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n-        TSplitTester().SetExpectBlobsCount(80).SetExpectSlicesCount(80).SetExpectedInternalSplitsCount(0).SetExpectPortionsCount(40)\n-            .Execute(batch, NKikimr::NOlap::NSplitter::TSplitSettings().SetMinRecordsCount(1000).SetMaxPortionSize(8000000));\n+        TSplitTester().SetExpectBlobsCount(80).SetExpectSlicesCount(80).SetExpectedInternalSplitsCount(0).SetExpectPortionsCount(40).Execute(\n+            batch, NKikimr::NOlap::NSplitter::TSplitSettings().SetMinRecordsCount(1000).SetMaxPortionSize(8000000));\n     }\n \n     Y_UNIT_TEST(Crit) {\n-        NConstruction::IArrayBuilder::TPtr columnBig = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 7120));\n-        NConstruction::IArrayBuilder::TPtr columnSmall = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field2\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 128));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({columnBig, columnSmall}).BuildBatch(80048);\n+        NConstruction::IArrayBuilder::TPtr columnBig =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 7120));\n+        NConstruction::IArrayBuilder::TPtr columnSmall =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field2\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 128));\n+        std::shared_ptr<arrow::RecordBatch> batch =\n+            NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ columnBig, columnSmall }).BuildBatch(80048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n-        TSplitTester().SetExpectBlobsCount(80).SetExpectSlicesCount(8).SetExpectedInternalSplitsCount(8).SetExpectPortionsCount(8).Execute(batch);\n+        TSplitTester().SetExpectBlobsCount(80).SetExpectSlicesCount(8).SetExpectedInternalSplitsCount(8).SetExpectPortionsCount(8).Execute(\n+            batch);\n     }\n \n     Y_UNIT_TEST(CritSimple) {\n-        NConstruction::IArrayBuilder::TPtr columnBig = std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n-            \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 7120));\n-        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({columnBig}).BuildBatch(80048);\n+        NConstruction::IArrayBuilder::TPtr columnBig =\n+            std::make_shared<NKikimr::NArrow::NConstruction::TSimpleArrayConstructor<NKikimr::NArrow::NConstruction::TStringPoolFiller>>(\n+                \"field1\", NKikimr::NArrow::NConstruction::TStringPoolFiller(8, 7120));\n+        std::shared_ptr<arrow::RecordBatch> batch = NKikimr::NArrow::NConstruction::TRecordBatchConstructor({ columnBig }).BuildBatch(80048);\n         NKikimr::NColumnShard::TIndexationCounters counters(\"test\");\n \n-        TSplitTester().SetExpectBlobsCount(72).SetExpectSlicesCount(8).SetExpectedInternalSplitsCount(0).SetExpectPortionsCount(8).Execute(batch);\n+        TSplitTester().SetExpectBlobsCount(72).SetExpectSlicesCount(8).SetExpectedInternalSplitsCount(0).SetExpectPortionsCount(8).Execute(\n+            batch);\n     }\n-\n };\ndiff --git a/ydb/core/tx/columnshard/splitter/ut/ya.make b/ydb/core/tx/columnshard/splitter/ut/ya.make\nindex 24d266bffa8e..3f49857ce07a 100644\n--- a/ydb/core/tx/columnshard/splitter/ut/ya.make\n+++ b/ydb/core/tx/columnshard/splitter/ut/ya.make\n@@ -18,6 +18,7 @@ PEERDIR(\n     ydb/core/kqp/session_actor\n     ydb/core/tx/tx_proxy\n     ydb/core/tx/columnshard/engines/storage/chunks\n+    ydb/core/tx/columnshard/engines/storage/indexes/max\n     ydb/core/tx\n     ydb/core/mind\n     ydb/library/yql/minikql/comp_nodes/llvm14\n@@ -40,6 +41,7 @@ CFLAGS(\n \n SRCS(\n     ut_splitter.cpp\n+    batch_slice.cpp\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/splitter/ya.make b/ydb/core/tx/columnshard/splitter/ya.make\nindex 5f6c60cdf1ff..380d51bca325 100644\n--- a/ydb/core/tx/columnshard/splitter/ya.make\n+++ b/ydb/core/tx/columnshard/splitter/ya.make\n@@ -3,12 +3,8 @@ LIBRARY()\n SRCS(\n     batch_slice.cpp\n     chunks.cpp\n-    simple.cpp\n-    similar_packer.cpp\n-    stats.cpp\n     column_info.cpp\n     settings.cpp\n-    scheme_info.cpp\n     blob_info.cpp\n     chunk_meta.cpp\n )\n@@ -17,6 +13,7 @@ PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/core/tx/columnshard/splitter/abstract\n     ydb/core/tx/columnshard/engines/scheme\n+    ydb/core/formats/arrow/splitter\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/abstract.cpp b/ydb/core/tx/columnshard/transactions/locks/abstract.cpp\nnew file mode 100644\nindex 000000000000..927b73dcdd23\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/abstract.cpp\n@@ -0,0 +1,6 @@\n+#include \"abstract.h\"\n+#include <ydb/core/tx/columnshard/transactions/protos/tx_event.pb.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/abstract.h b/ydb/core/tx/columnshard/transactions/locks/abstract.h\nnew file mode 100644\nindex 000000000000..5699d13d9705\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/abstract.h\n@@ -0,0 +1,105 @@\n+#pragma once\n+#include \"dependencies.h\"\n+#include \"interaction.h\"\n+\n+#include <ydb/services/bg_tasks/abstract/interface.h>\n+\n+#include <library/cpp/object_factory/object_factory.h>\n+\n+namespace NKikimr::NColumnShard {\n+class TColumnShard;\n+}\n+\n+namespace NKikimrColumnShardTxProto {\n+class TEvent;\n+}\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+class ITxEvent {\n+public:\n+    using TFactory = NObjectFactory::TParametrizedObjectFactory<ITxEvent, TString>;\n+    using TProto = NKikimrColumnShardTxProto::TEvent;\n+\n+protected:\n+    virtual void DoAddToInteraction(const ui64 txId, TInteractionsContext& context) const = 0;\n+    virtual void DoRemoveFromInteraction(const ui64 txId, TInteractionsContext& context) const = 0;\n+    virtual bool DoDeserializeFromProto(const NKikimrColumnShardTxProto::TEvent& proto) = 0;\n+    virtual void DoSerializeToProto(NKikimrColumnShardTxProto::TEvent& proto) const = 0;\n+\n+public:\n+    ITxEvent() = default;\n+    virtual ~ITxEvent() = default;\n+\n+    virtual TString GetClassName() const = 0;\n+\n+    bool DeserializeFromProto(const TProto& proto) {\n+        return DoDeserializeFromProto(proto);\n+    }\n+\n+    void SerializeToProto(TProto& proto) const {\n+        DoSerializeToProto(proto);\n+    }\n+\n+    void AddToInteraction(const ui64 txId, TInteractionsContext& context) const {\n+        return DoAddToInteraction(txId, context);\n+    }\n+\n+    void RemoveFromInteraction(const ui64 txId, TInteractionsContext& context) const {\n+        return DoRemoveFromInteraction(txId, context);\n+    }\n+};\n+\n+class TTxEventContainer: public NBackgroundTasks::TInterfaceProtoContainer<ITxEvent> {\n+private:\n+    using TBase = NBackgroundTasks::TInterfaceProtoContainer<ITxEvent>;\n+    YDB_READONLY(ui64, TxId, 0);\n+\n+public:\n+    void AddToInteraction(TInteractionsContext& context) const {\n+        return GetObjectVerified().AddToInteraction(TxId, context);\n+    }\n+\n+    void RemoveFromInteraction(TInteractionsContext& context) const {\n+        return GetObjectVerified().RemoveFromInteraction(TxId, context);\n+    }\n+\n+    TTxEventContainer(const ui64 txId, const std::shared_ptr<ITxEvent>& txEvent)\n+        : TBase(txEvent)\n+        , TxId(txId) {\n+    }\n+\n+    TTxEventContainer(const ui64 txId)\n+        : TxId(txId) {\n+    }\n+\n+    bool operator<(const TTxEventContainer& item) const {\n+        return TxId < item.TxId;\n+    }\n+};\n+\n+class ITxEventWriter {\n+protected:\n+    virtual bool DoCheckInteraction(\n+        const ui64 selfTxId, TInteractionsContext& context, TTxConflicts& conflicts, TTxConflicts& notifications) const = 0;\n+    virtual std::shared_ptr<ITxEvent> DoBuildEvent() = 0;\n+\n+public:\n+    ITxEventWriter() = default;\n+    virtual ~ITxEventWriter() = default;\n+\n+    bool CheckInteraction(const ui64 selfTxId, TInteractionsContext& context, TTxConflicts& conflicts, TTxConflicts& notifications) const {\n+        TTxConflicts conflictsResult;\n+        TTxConflicts notificationsResult;\n+        const bool result = DoCheckInteraction(selfTxId, context, conflictsResult, notificationsResult);\n+        std::swap(conflictsResult, conflicts);\n+        std::swap(notificationsResult, notifications);\n+        return result;\n+    }\n+\n+    std::shared_ptr<ITxEvent> BuildEvent() {\n+        return DoBuildEvent();\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/dependencies.cpp b/ydb/core/tx/columnshard/transactions/locks/dependencies.cpp\nnew file mode 100644\nindex 000000000000..921a024ce651\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/dependencies.cpp\n@@ -0,0 +1,48 @@\n+#include \"dependencies.h\"\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+bool TTxConflicts::LoadFromDatabase(NIceDb::TNiceDb& db) {\n+    using namespace NColumnShard;\n+    auto rowset = db.Table<Schema::TxDependencies>().Select();\n+    if (!rowset.IsReady()) {\n+        return false;\n+    }\n+\n+    THashMap<ui64, THashSet<ui64>> local;\n+    while (!rowset.EndOfSet()) {\n+        const ui64 txId = rowset.GetValue<Schema::TxDependencies::CommitTxId>();\n+        local[txId].emplace(rowset.GetValue<Schema::TxDependencies::BrokenTxId>());\n+        if (!rowset.Next()) {\n+            return false;\n+        }\n+    }\n+    std::swap(local, TxIdsFromCommitToBroken);\n+    return true;\n+}\n+\n+void TTxConflicts::AddOnExecute(NTabletFlatExecutor::TTransactionContext& txc) const {\n+    using namespace NColumnShard;\n+    NIceDb::TNiceDb db(txc.DB);\n+    for (auto&& [commitTxId, brokeTxIds] : TxIdsFromCommitToBroken) {\n+        for (auto&& brokeTxId : brokeTxIds) {\n+            db.Table<Schema::TxDependencies>().Key(commitTxId, brokeTxId).Update();\n+        }\n+    }\n+}\n+\n+bool TTxConflicts::RemoveOnExecute(NTabletFlatExecutor::TTransactionContext& txc, const ui64 txId) const {\n+    using namespace NColumnShard;\n+    NIceDb::TNiceDb db(txc.DB);\n+    auto it = TxIdsFromCommitToBroken.find(txId);\n+    if (it == TxIdsFromCommitToBroken.end()) {\n+        return false;\n+    }\n+    for (auto&& brokeTxId : it->second) {\n+        db.Table<Schema::TxDependencies>().Key(txId, brokeTxId).Delete();\n+    }\n+    return true;\n+}\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/dependencies.h b/ydb/core/tx/columnshard/transactions/locks/dependencies.h\nnew file mode 100644\nindex 000000000000..d749ed1db87e\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/dependencies.h\n@@ -0,0 +1,55 @@\n+#pragma once\n+#include <util/generic/hash_set.h>\n+#include <ydb/core/tablet_flat/flat_cxx_database.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executor.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+class TTxConflicts {\n+private:\n+    THashMap<ui64, THashSet<ui64>> TxIdsFromCommitToBroken;\n+\n+public:\n+    THashMap<ui64, THashSet<ui64>>::const_iterator begin() const {\n+        return TxIdsFromCommitToBroken.begin();\n+    }\n+\n+    THashMap<ui64, THashSet<ui64>>::const_iterator end() const {\n+        return TxIdsFromCommitToBroken.end();\n+    }\n+\n+    bool Add(const ui64 commitTxId, const ui64 brokenTxId) {\n+        return TxIdsFromCommitToBroken[commitTxId].emplace(brokenTxId).second;\n+    }\n+\n+    THashSet<ui64> GetBrokenTxIds(const ui64 txId) const {\n+        auto it = TxIdsFromCommitToBroken.find(txId);\n+        if (it == TxIdsFromCommitToBroken.end()) {\n+            return Default<THashSet<ui64>>();\n+        }\n+        return it->second;\n+    }\n+\n+    bool LoadFromDatabase(NIceDb::TNiceDb& db);\n+\n+    bool RemoveOnExecute(NTabletFlatExecutor::TTransactionContext& txc, const ui64 txId) const;\n+\n+    [[nodiscard]] bool RemoveOnComplete(const ui64 txId) {\n+        return TxIdsFromCommitToBroken.erase(txId);\n+    }\n+\n+    void AddOnExecute(NTabletFlatExecutor::TTransactionContext& txc) const;\n+\n+    void MergeTo(TTxConflicts& dest) const {\n+        for (auto&& i : TxIdsFromCommitToBroken) {\n+            auto it = dest.TxIdsFromCommitToBroken.find(i.first);\n+            if (it == dest.TxIdsFromCommitToBroken.end()) {\n+                dest.TxIdsFromCommitToBroken.emplace(i.first, i.second);\n+            } else {\n+                it->second.insert(i.second.begin(), i.second.end());\n+            }\n+        }\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/interaction.cpp b/ydb/core/tx/columnshard/transactions/locks/interaction.cpp\nnew file mode 100644\nindex 000000000000..0dd52a2a79ba\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/interaction.cpp\n@@ -0,0 +1,26 @@\n+#include \"interaction.h\"\n+#include <ydb/core/tx/columnshard/engines/predicate/container.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+TIntervalPoint TIntervalPoint::From(\n+    const TPredicateContainer& container, const std::shared_ptr<arrow::Schema>& pkSchema) {\n+    i32 shift = container.IsInclude() ? 0 : 1;\n+    if (!container.GetReplaceKey()) {\n+        shift = -1;\n+    } else if (container.GetReplaceKey()->Size() < (ui32)pkSchema->num_fields()) {\n+        shift = 1;\n+    }\n+    return TIntervalPoint(container.GetReplaceKey(), shift);\n+}\n+\n+TIntervalPoint TIntervalPoint::To(\n+    const TPredicateContainer& container, const std::shared_ptr<arrow::Schema>& pkSchema) {\n+    i32 shift = container.IsInclude() ? 0 : -1;\n+    if (!container.GetReplaceKey() || container.GetReplaceKey()->Size() < (ui32)pkSchema->num_fields()) {\n+        shift = Max<i32>();\n+    }\n+\n+    return TIntervalPoint(container.GetReplaceKey(), shift);\n+}\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/interaction.h b/ydb/core/tx/columnshard/transactions/locks/interaction.h\nnew file mode 100644\nindex 000000000000..abd9ef92f6d5\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/interaction.h\n@@ -0,0 +1,459 @@\n+#pragma once\n+#include <ydb/core/formats/arrow/process_columns.h>\n+#include <ydb/library/formats/arrow/replace_key.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/accessor/validator.h>\n+\n+#include <util/generic/hash.h>\n+\n+namespace NKikimr::NOlap {\n+class TPredicateContainer;\n+}\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+class TPointTxCounters {\n+private:\n+    YDB_READONLY(ui32, CountIncludes, 0);\n+    YDB_READONLY(ui32, CountNotIncludes, 0);\n+\n+public:\n+    void Inc(const bool include) {\n+        if (include) {\n+            IncInclude();\n+        } else {\n+            IncNotInclude();\n+        }\n+    }\n+    bool Dec(const bool include) {\n+        if (include) {\n+            return DecInclude();\n+        } else {\n+            return DecNotInclude();\n+        }\n+    }\n+    void IncInclude() {\n+        ++CountIncludes;\n+    }\n+    [[nodiscard]] bool DecInclude() {\n+        AFL_VERIFY(CountIncludes);\n+        return --CountIncludes == 0;\n+    }\n+    void IncNotInclude() {\n+        ++CountNotIncludes;\n+    }\n+    [[nodiscard]] bool DecNotInclude() {\n+        AFL_VERIFY(CountNotIncludes);\n+        return --CountNotIncludes == 0;\n+    }\n+    bool IsEmpty() const {\n+        return !CountIncludes && !CountNotIncludes;\n+    }\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        if (CountIncludes) {\n+            result.InsertValue(\"count_include\", CountIncludes);\n+        }\n+        if (CountNotIncludes) {\n+            result.InsertValue(\"count_not_include\", CountNotIncludes);\n+        }\n+        return result;\n+    }\n+    ui32 GetCountSum() const {\n+        return CountIncludes + CountNotIncludes;\n+    }\n+};\n+\n+class TIntervalTxCounters {\n+private:\n+    YDB_READONLY(ui32, Count, 0);\n+\n+public:\n+    void Inc(const ui32 count = 1) {\n+        Count += count;\n+    }\n+    [[nodiscard]] bool Dec(const ui32 count = 1) {\n+        AFL_VERIFY(Count);\n+        Count -= count;\n+        return Count == 0;\n+    }\n+    bool IsEmpty() const {\n+        return !Count;\n+    }\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        result.InsertValue(\"count\", Count);\n+        return result;\n+    }\n+\n+    void ProvideFrom(const TIntervalTxCounters& counters) {\n+        Count += counters.Count;\n+        AFL_VERIFY(counters.Count);\n+    }\n+};\n+\n+class TPointInfo {\n+private:\n+    THashMap<ui64, TPointTxCounters> StartTxIds;\n+    THashMap<ui64, TPointTxCounters> FinishTxIds;\n+    THashMap<ui64, TIntervalTxCounters> IntervalTxIds;\n+\n+public:\n+    void InsertCurrentTxs(THashSet<ui64>& txIds, const bool includePoint) const {\n+        for (auto&& i : IntervalTxIds) {\n+            txIds.emplace(i.first);\n+        }\n+        if (includePoint) {\n+            for (auto&& i : FinishTxIds) {\n+                if (!i.second.GetCountIncludes()) {\n+                    continue;\n+                }\n+                auto it = StartTxIds.find(i.first);\n+                if (it != StartTxIds.end() && it->second.GetCountIncludes()) {\n+                    txIds.emplace(i.first);\n+                }\n+            }\n+        }\n+    }\n+\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        auto& starts = result.InsertValue(\"starts\", NJson::JSON_ARRAY);\n+        for (auto&& i : StartTxIds) {\n+            auto& data = starts.AppendValue(NJson::JSON_MAP);\n+            data.InsertValue(\"id\", i.first);\n+            data.InsertValue(\"inc\", i.second.DebugJson());\n+        }\n+        auto& finish = result.InsertValue(\"finishes\", NJson::JSON_ARRAY);\n+        for (auto&& i : FinishTxIds) {\n+            auto& data = finish.AppendValue(NJson::JSON_MAP);\n+            data.InsertValue(\"id\", i.first);\n+            data.InsertValue(\"inc\", i.second.DebugJson());\n+        }\n+        auto& txs = result.InsertValue(\"txs\", NJson::JSON_ARRAY);\n+        for (auto&& i : IntervalTxIds) {\n+            auto& data = txs.AppendValue(NJson::JSON_MAP);\n+            data.InsertValue(\"id\", i.first);\n+            data.InsertValue(\"inc\", i.second.DebugJson());\n+        }\n+        return result;\n+    }\n+\n+    void AddStart(const ui64 txId, const bool include) {\n+        StartTxIds[txId].Inc(include);\n+    }\n+    void RemoveStart(const ui64 txId, const bool include) {\n+        if (StartTxIds[txId].Dec(include)) {\n+            StartTxIds.erase(txId);\n+        }\n+    }\n+    void AddFinish(const ui64 txId, const bool include) {\n+        FinishTxIds[txId].Inc(include);\n+    }\n+    void RemoveFinish(const ui64 txId, const bool include) {\n+        if (FinishTxIds[txId].Dec(include)) {\n+            FinishTxIds.erase(txId);\n+        }\n+    }\n+    void AddIntervalTx(const ui64 txId) {\n+        IntervalTxIds[txId].Inc();\n+    }\n+    void RemoveIntervalTx(const ui64 txId) {\n+        if (IntervalTxIds[txId].Dec()) {\n+            IntervalTxIds.erase(txId);\n+        }\n+    }\n+    bool TryRemoveTx(const ui64 txId, const bool include) {\n+        bool result = false;\n+        if (StartTxIds[txId].Dec(include)) {\n+            StartTxIds.erase(txId);\n+            result = true;\n+        }\n+        if (FinishTxIds[txId].Dec(include)) {\n+            FinishTxIds.erase(txId);\n+            result = true;\n+        }\n+        if (IntervalTxIds[txId].Dec(txId)) {\n+            IntervalTxIds.erase(txId);\n+            result = true;\n+        }\n+        return result;\n+    }\n+\n+    bool IsEmpty() const {\n+        return StartTxIds.empty() && FinishTxIds.empty() && IntervalTxIds.empty();\n+    }\n+\n+    void ProvideTxIdsFrom(const TPointInfo& previouse) {\n+        for (auto&& i : previouse.IntervalTxIds) {\n+            auto provided = i.second;\n+            {\n+                auto it = StartTxIds.find(i.first);\n+                if (it != StartTxIds.end()) {\n+                    provided.Inc(it->second.GetCountSum());\n+                }\n+            }\n+            {\n+                auto it = FinishTxIds.find(i.first);\n+                if (it != FinishTxIds.end()) {\n+                    if (provided.Dec(it->second.GetCountSum())) {\n+                        return;\n+                    }\n+                }\n+            }\n+            IntervalTxIds[i.first].ProvideFrom(provided);\n+        }\n+    }\n+};\n+\n+class TIntervalPoint {\n+private:\n+    i32 IncludeState = 0;\n+    std::optional<NArrow::TReplaceKey> PrimaryKey;\n+\n+    TIntervalPoint(const NArrow::TReplaceKey& primaryKey, const int includeState)\n+        : IncludeState(includeState)\n+        , PrimaryKey(primaryKey) {\n+    }\n+\n+    TIntervalPoint(const std::shared_ptr<NArrow::TReplaceKey>& primaryKey, const int includeState)\n+        : IncludeState(includeState) {\n+        if (primaryKey) {\n+            PrimaryKey = *primaryKey;\n+        }\n+    }\n+\n+public:\n+    static TIntervalPoint Equal(const NArrow::TReplaceKey& replaceKey) {\n+        return TIntervalPoint(replaceKey, 0);\n+    }\n+    static TIntervalPoint From(const TPredicateContainer& container, const std::shared_ptr<arrow::Schema>& pkSchema);\n+    static TIntervalPoint To(const TPredicateContainer& container, const std::shared_ptr<arrow::Schema>& pkSchema);\n+\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        result.InsertValue(\"include\", IncludeState);\n+        if (PrimaryKey) {\n+            result.InsertValue(\"pk\", PrimaryKey->DebugString());\n+        }\n+        return result;\n+    }\n+\n+    bool IsIncluded() const {\n+        return IncludeState == 0;\n+    }\n+\n+    bool operator==(const TIntervalPoint& item) const {\n+        if (!PrimaryKey && !item.PrimaryKey) {\n+            return IncludeState == item.IncludeState;\n+        } else if (!PrimaryKey && item.PrimaryKey) {\n+            return false;\n+        } else if (PrimaryKey && !item.PrimaryKey) {\n+            return false;\n+        } else if (IncludeState == item.IncludeState) {\n+            if (PrimaryKey->Size() != item.PrimaryKey->Size()) {\n+                return false;\n+            }\n+            return *PrimaryKey == *item.PrimaryKey;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    bool operator<=(const TIntervalPoint& point) const {\n+        return !(point < *this);\n+    }\n+\n+    bool operator<(const TIntervalPoint& point) const {\n+        if (!PrimaryKey && !point.PrimaryKey) {\n+            return IncludeState < point.IncludeState;\n+        } else if (!PrimaryKey && point.PrimaryKey) {\n+            return IncludeState < 0;\n+        } else if (PrimaryKey && !point.PrimaryKey) {\n+            return 0 < point.IncludeState;\n+        } else {\n+            const ui32 sizeMin = std::min<ui32>(PrimaryKey->Size(), point.PrimaryKey->Size());\n+            const std::partial_ordering compareResult = PrimaryKey->ComparePartNotNull(*point.PrimaryKey, sizeMin);\n+            if (compareResult == std::partial_ordering::less) {\n+                return true;\n+            } else if (compareResult == std::partial_ordering::greater) {\n+                return false;\n+            } else {\n+                AFL_VERIFY(compareResult == std::partial_ordering::equivalent);\n+                if (PrimaryKey->Size() == point.PrimaryKey->Size()) {\n+                    return IncludeState < point.IncludeState;\n+                } else if (PrimaryKey->Size() < point.PrimaryKey->Size()) {\n+                    if (IncludeState <= 1) {\n+                        return true;\n+                    } else {\n+                        return false;\n+                    }\n+                } else {\n+                    if (point.IncludeState <= 1) {\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+        }\n+    }\n+};\n+\n+class TReadIntervals {\n+private:\n+    std::map<TIntervalPoint, TPointInfo> IntervalsInfo;\n+\n+public:\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        auto& jsonIntervals = result.InsertValue(\"intervals\", NJson::JSON_ARRAY);\n+        for (auto&& i : IntervalsInfo) {\n+            auto& pointInfo = jsonIntervals.AppendValue(NJson::JSON_MAP);\n+            pointInfo.InsertValue(\"p\", i.first.DebugJson());\n+            pointInfo.InsertValue(\"i\", i.second.DebugJson());\n+        }\n+        return result;\n+    }\n+\n+    bool IsEmpty() const {\n+        return IntervalsInfo.empty();\n+    }\n+\n+    std::map<TIntervalPoint, TPointInfo>::iterator Erase(const std::map<TIntervalPoint, TPointInfo>::iterator& it) {\n+        return IntervalsInfo.erase(it);\n+    }\n+\n+    std::map<TIntervalPoint, TPointInfo>::iterator GetPointIterator(const TIntervalPoint& intervalPoint) {\n+        auto it = IntervalsInfo.find(intervalPoint);\n+        AFL_VERIFY(it != IntervalsInfo.end());\n+        return it;\n+    }\n+\n+    std::map<TIntervalPoint, TPointInfo>::iterator InsertPoint(const TIntervalPoint& intervalPoint) {\n+        auto it = IntervalsInfo.lower_bound(intervalPoint);\n+        if (it == IntervalsInfo.end() || it == IntervalsInfo.begin()) {\n+            return IntervalsInfo.emplace(intervalPoint, TPointInfo()).first;\n+        } else if (it->first == intervalPoint) {\n+            return it;\n+        } else {\n+            --it;\n+            auto result = IntervalsInfo.emplace(intervalPoint, TPointInfo()).first;\n+            result->second.ProvideTxIdsFrom(it->second);\n+            return result;\n+        }\n+    }\n+\n+    THashSet<ui64> GetAffectedTxIds(const std::shared_ptr<arrow::RecordBatch>& writtenPrimaryKeys) const {\n+        AFL_VERIFY(writtenPrimaryKeys);\n+        auto it = IntervalsInfo.begin();\n+        THashSet<ui64> affectedTxIds;\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"batch\", writtenPrimaryKeys->ToString())(\"info\", DebugJson().GetStringRobust());\n+        for (ui32 i = 0; i < writtenPrimaryKeys->num_rows();) {\n+            if (it == IntervalsInfo.end()) {\n+                return affectedTxIds;\n+            }\n+            auto rKey = NArrow::TReplaceKey::FromBatch(writtenPrimaryKeys, writtenPrimaryKeys->schema(), i);\n+            auto pkIntervalPoint = TIntervalPoint::Equal(rKey);\n+            while (it != IntervalsInfo.end() && it->first < pkIntervalPoint) {\n+                ++it;\n+            }\n+            if (it == IntervalsInfo.end()) {\n+                return affectedTxIds;\n+            }\n+            auto itPred = it;\n+            bool equal = false;\n+            if (pkIntervalPoint < it->first) {\n+                if (it == IntervalsInfo.begin()) {\n+                    ++i;\n+                    continue;\n+                }\n+                if (pkIntervalPoint < it->first) {\n+                    --itPred;\n+                }\n+            } else {\n+                equal = true;\n+                ++it;\n+            }\n+\n+            itPred->second.InsertCurrentTxs(affectedTxIds, equal);\n+            if (it == IntervalsInfo.end()) {\n+                return affectedTxIds;\n+            }\n+            while (i < writtenPrimaryKeys->num_rows()) {\n+                auto rKey = NArrow::TReplaceKey::FromBatch(writtenPrimaryKeys, writtenPrimaryKeys->schema(), i);\n+                if (TIntervalPoint::Equal(rKey) < it->first) {\n+                    ++i;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return affectedTxIds;\n+    }\n+};\n+\n+class TInteractionsContext {\n+private:\n+    THashMap<ui64, TReadIntervals> ReadIntervalsByPathId;\n+\n+public:\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        for (auto&& i : ReadIntervalsByPathId) {\n+            result.InsertValue(::ToString(i.first), i.second.DebugJson());\n+        }\n+        return result;\n+    }\n+\n+    THashSet<ui64> GetAffectedTxIds(const ui64 pathId, const std::shared_ptr<arrow::RecordBatch>& batch) const {\n+        auto it = ReadIntervalsByPathId.find(pathId);\n+        if (it == ReadIntervalsByPathId.end()) {\n+            return {};\n+        }\n+        return it->second.GetAffectedTxIds(batch);\n+    }\n+\n+    void AddInterval(const ui64 txId, const ui64 pathId, const TIntervalPoint& from, const TIntervalPoint& to) {\n+        auto& intervals = ReadIntervalsByPathId[pathId];\n+        auto itFrom = intervals.InsertPoint(from);\n+        auto itTo = intervals.InsertPoint(to);\n+        itFrom->second.AddStart(txId, from.IsIncluded());\n+        for (auto it = itFrom; it != itTo; ++it) {\n+            it->second.AddIntervalTx(txId);\n+        }\n+        itTo->second.AddFinish(txId, to.IsIncluded());\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"add_interval\")(\"interactions_info\", DebugJson().GetStringRobust());\n+    }\n+\n+    void RemoveInterval(const ui64 txId, const ui64 pathId, const TIntervalPoint& from, const TIntervalPoint& to) {\n+        auto itIntervals = ReadIntervalsByPathId.find(pathId);\n+        AFL_VERIFY(itIntervals != ReadIntervalsByPathId.end())(\"path_id\", pathId);\n+        auto& intervals = itIntervals->second;\n+        auto itFrom = intervals.GetPointIterator(from);\n+        auto itTo = intervals.GetPointIterator(to);\n+        itFrom->second.RemoveStart(txId, from.IsIncluded());\n+        for (auto it = itFrom; it != itTo; ++it) {\n+            it->second.RemoveIntervalTx(txId);\n+        }\n+        itTo->second.RemoveFinish(txId, to.IsIncluded());\n+        for (auto&& it = itFrom; it != itTo;) {\n+            if (it->second.IsEmpty()) {\n+                it = intervals.Erase(it);\n+            } else {\n+                ++it;\n+            }\n+        }\n+        if (itTo->second.IsEmpty()) {\n+            intervals.Erase(itTo);\n+        }\n+        if (intervals.IsEmpty()) {\n+            ReadIntervalsByPathId.erase(itIntervals);\n+        }\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"remove_interval\")(\"interactions_info\", DebugJson().GetStringRobust());\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/read_finished.cpp b/ydb/core/tx/columnshard/transactions/locks/read_finished.cpp\nnew file mode 100644\nindex 000000000000..159b5d269533\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/read_finished.cpp\n@@ -0,0 +1,5 @@\n+#include \"read_finished.h\"\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/read_finished.h b/ydb/core/tx/columnshard/transactions/locks/read_finished.h\nnew file mode 100644\nindex 000000000000..895123e5097b\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/read_finished.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+class TEvReadFinishedWriter: public ITxEventWriter {\n+private:\n+    YDB_READONLY(ui64, PathId, 0);\n+    TTxConflicts Conflicts;\n+\n+    virtual bool DoCheckInteraction(\n+        const ui64 /*selfTxId*/, TInteractionsContext& /*context*/, TTxConflicts& conflicts, TTxConflicts& /*notifications*/) const override {\n+        conflicts = Conflicts;\n+        return true;\n+    }\n+\n+    virtual std::shared_ptr<ITxEvent> DoBuildEvent() override {\n+        return nullptr;\n+    }\n+\n+public:\n+    TEvReadFinishedWriter(const ui64 pathId, const TTxConflicts& conflicts)\n+        : PathId(pathId)\n+        , Conflicts(conflicts)\n+    {\n+        AFL_VERIFY(PathId);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/read_start.cpp b/ydb/core/tx/columnshard/transactions/locks/read_start.cpp\nnew file mode 100644\nindex 000000000000..963c47b068a9\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/read_start.cpp\n@@ -0,0 +1,47 @@\n+#include \"read_start.h\"\n+#include <ydb/core/tx/columnshard/transactions/protos/tx_event.pb.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+std::shared_ptr<NKikimr::NOlap::NTxInteractions::ITxEvent> TEvReadStartWriter::DoBuildEvent() {\n+    return std::make_shared<TEvReadStart>(PathId, Schema, Filter);\n+}\n+\n+bool TEvReadStart::DoDeserializeFromProto(const NKikimrColumnShardTxProto::TEvent& proto) {\n+    if (!proto.HasRead()) {\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot_parse_TEvReadStart\")(\"reason\", \"have not 'read' in proto\");\n+        return false;\n+    }\n+    Schema = NArrow::DeserializeSchema(proto.GetRead().GetSchema());\n+    if (!Schema) {\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot_parse_TEvReadStart\")(\"reason\", \"cannot_parse_schema\");\n+        return false;\n+    }\n+    Filter = TPKRangesFilter::BuildFromString(proto.GetRead().GetFilter(), Schema, false);\n+    if (!Filter) {\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot_parse_TEvReadStart\")(\"reason\", \"cannot_parse_filter\");\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void TEvReadStart::DoSerializeToProto(NKikimrColumnShardTxProto::TEvent& proto) const {\n+    AFL_VERIFY(!!Filter);\n+    AFL_VERIFY(!!Schema);\n+    *proto.MutableRead()->MutableFilter() = Filter->SerializeToString(Schema);\n+    *proto.MutableRead()->MutableSchema() = NArrow::SerializeSchema(*Schema);\n+}\n+\n+void TEvReadStart::DoAddToInteraction(const ui64 txId, TInteractionsContext& context) const {\n+    for (auto&& i : *Filter) {\n+        context.AddInterval(txId, PathId, TIntervalPoint::From(i.GetPredicateFrom(), Schema), TIntervalPoint::To(i.GetPredicateTo(), Schema));\n+    }\n+}\n+\n+void TEvReadStart::DoRemoveFromInteraction(const ui64 txId, TInteractionsContext& context) const {\n+    for (auto&& i : *Filter) {\n+        context.RemoveInterval(txId, PathId, TIntervalPoint::From(i.GetPredicateFrom(), Schema), TIntervalPoint::To(i.GetPredicateTo(), Schema));\n+    }\n+}\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/read_start.h b/ydb/core/tx/columnshard/transactions/locks/read_start.h\nnew file mode 100644\nindex 000000000000..6587dfea5bda\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/read_start.h\n@@ -0,0 +1,71 @@\n+#pragma once\n+#include \"abstract.h\"\n+#include <ydb/core/tx/columnshard/engines/predicate/filter.h>\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+class TEvReadStartWriter: public ITxEventWriter {\n+private:\n+    YDB_READONLY(ui64, PathId, 0);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Schema>, Schema);\n+    YDB_READONLY_DEF(std::shared_ptr<TPKRangesFilter>, Filter);\n+    YDB_READONLY_DEF(THashSet<ui64>, LockIdsForCheck);\n+\n+    virtual bool DoCheckInteraction(\n+        const ui64 selfTxId, TInteractionsContext& /*context*/, TTxConflicts& /*conflicts*/, TTxConflicts& notifications) const override {\n+        for (auto&& i : LockIdsForCheck) {\n+            notifications.Add(i, selfTxId);\n+        }\n+        return true;\n+    }\n+\n+    virtual std::shared_ptr<ITxEvent> DoBuildEvent() override;\n+\n+public:\n+    TEvReadStartWriter(const ui64 pathId, const std::shared_ptr<arrow::Schema>& schema, const std::shared_ptr<TPKRangesFilter>& filter,\n+        const THashSet<ui64>& lockIdsForCheck)\n+        : PathId(pathId)\n+        , Schema(schema)\n+        , Filter(filter)\n+        , LockIdsForCheck(lockIdsForCheck)\n+    {\n+        AFL_VERIFY(PathId);\n+        AFL_VERIFY(Schema);\n+        AFL_VERIFY(Filter);\n+    }\n+};\n+\n+class TEvReadStart: public ITxEvent {\n+public:\n+    static TString GetClassNameStatic() {\n+        return \"READ_START\";\n+    }\n+\n+private:\n+    YDB_READONLY(ui64, PathId, 0);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Schema>, Schema);\n+    YDB_READONLY_DEF(std::shared_ptr<TPKRangesFilter>, Filter);\n+\n+    virtual bool DoDeserializeFromProto(const NKikimrColumnShardTxProto::TEvent& proto) override;\n+    virtual void DoSerializeToProto(NKikimrColumnShardTxProto::TEvent& proto) const override;\n+    virtual void DoAddToInteraction(const ui64 txId, TInteractionsContext& context) const override;\n+    virtual void DoRemoveFromInteraction(const ui64 txId, TInteractionsContext& context) const override;\n+    static inline const TFactory::TRegistrator<TEvReadStart> Registrator = TFactory::TRegistrator<TEvReadStart>(GetClassNameStatic());\n+\n+public:\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+\n+    TEvReadStart() = default;\n+    TEvReadStart(const ui64 pathId, const std::shared_ptr<arrow::Schema>& schema, const std::shared_ptr<TPKRangesFilter>& filter)\n+        : PathId(pathId)\n+        , Schema(schema)\n+        , Filter(filter) {\n+        AFL_VERIFY(PathId);\n+        AFL_VERIFY(Schema);\n+        AFL_VERIFY(Filter);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/write.cpp b/ydb/core/tx/columnshard/transactions/locks/write.cpp\nnew file mode 100644\nindex 000000000000..19ff258fe7c6\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/write.cpp\n@@ -0,0 +1,5 @@\n+#include \"write.h\"\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+}\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/write.h b/ydb/core/tx/columnshard/transactions/locks/write.h\nnew file mode 100644\nindex 000000000000..78ba8baf7e0e\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/write.h\n@@ -0,0 +1,36 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+namespace NKikimr::NOlap::NTxInteractions {\n+\n+class TEvWriteWriter: public ITxEventWriter {\n+private:\n+    YDB_READONLY(ui64, PathId, 0);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, RecordBatch);\n+\n+    virtual bool DoCheckInteraction(\n+        const ui64 selfTxId, TInteractionsContext& context, TTxConflicts& conflicts, TTxConflicts& /*notifications*/) const override {\n+        THashSet<ui64> txIds = context.GetAffectedTxIds(PathId, RecordBatch);\n+        txIds.erase(selfTxId);\n+        TTxConflicts result;\n+        for (auto&& i : txIds) {\n+            result.Add(selfTxId, i);\n+        }\n+        std::swap(result, conflicts);\n+        return true;\n+    }\n+\n+    virtual std::shared_ptr<ITxEvent> DoBuildEvent() override {\n+        return nullptr;\n+    }\n+\n+public:\n+    TEvWriteWriter(const ui64 pathId, const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema)\n+        : PathId(pathId)\n+        , RecordBatch(NArrow::TColumnOperator().Extract(batch, pkSchema->field_names())) {\n+        AFL_VERIFY(PathId);\n+        AFL_VERIFY(RecordBatch);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NTxInteractions\ndiff --git a/ydb/core/tx/columnshard/transactions/locks/ya.make b/ydb/core/tx/columnshard/transactions/locks/ya.make\nnew file mode 100644\nindex 000000000000..a7ad6b27ab0e\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/locks/ya.make\n@@ -0,0 +1,19 @@\n+LIBRARY()\n+\n+SRCS(\n+    dependencies.cpp\n+    interaction.cpp\n+    abstract.cpp\n+    GLOBAL read_start.cpp\n+    GLOBAL read_finished.cpp\n+    GLOBAL write.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/tx/columnshard/transactions/protos\n+    ydb/core/tx/columnshard/engines/predicate\n+    ydb/core/tx/columnshard/blobs_action/events\n+    ydb/core/tx/columnshard/data_sharing/destination/events\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/backup.h b/ydb/core/tx/columnshard/transactions/operators/backup.h\nindex 9e1e657ad138..cd9d5785dd9c 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/backup.h\n+++ b/ydb/core/tx/columnshard/transactions/operators/backup.h\n@@ -24,6 +24,9 @@ class TBackupTransactionOperator: public IProposeTxOperator, public TMonitoringO\n     }\n     virtual void DoFinishProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n     }\n+    virtual TString DoGetOpType() const override {\n+        return \"Backup\";\n+    }\n     virtual bool DoIsAsync() const override {\n         return true;\n     }\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write.h b/ydb/core/tx/columnshard/transactions/operators/ev_write.h\ndeleted file mode 100644\nindex 15bc4e5f3ae2..000000000000\n--- a/ydb/core/tx/columnshard/transactions/operators/ev_write.h\n+++ /dev/null\n@@ -1,77 +0,0 @@\n-#pragma once\n-\n-#include <ydb/core/tx/columnshard/columnshard_impl.h>\n-\n-namespace NKikimr::NColumnShard {\n-\n-    class TEvWriteTransactionOperator: public TTxController::ITransactionOperator, public TMonitoringObjectsCounter<TEvWriteTransactionOperator> {\n-        using TBase = TTxController::ITransactionOperator;\n-        using TProposeResult = TTxController::TProposeResult;\n-        static inline auto Registrator = TFactory::TRegistrator<TEvWriteTransactionOperator>(NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE);\n-    private:\n-        virtual TProposeResult DoStartProposeOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) override {\n-            owner.OperationsManager->LinkTransaction(LockId, GetTxId(), txc);\n-            return TProposeResult();\n-        }\n-        virtual void DoStartProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n-\n-        }\n-        virtual void DoFinishProposeOnExecute(TColumnShard& /*owner*/, NTabletFlatExecutor::TTransactionContext& /*txc*/) override {\n-        }\n-        virtual void DoFinishProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n-        }\n-        virtual bool DoIsAsync() const override {\n-            return false;\n-        }\n-        virtual bool DoCheckAllowUpdate(const TFullTxInfo& currentTxInfo) const override {\n-            return (currentTxInfo.Source == GetTxInfo().Source && currentTxInfo.Cookie == GetTxInfo().Cookie);\n-        }\n-        virtual TString DoDebugString() const override {\n-            return \"EV_WRITE\";\n-        }\n-        virtual void DoSendReply(TColumnShard& owner, const TActorContext& ctx) override {\n-            const auto& txInfo = GetTxInfo();\n-            std::unique_ptr<NActors::IEventBase> evResult;\n-            if (IsFail()) {\n-                evResult = NEvents::TDataEvents::TEvWriteResult::BuildError(owner.TabletID(), txInfo.GetTxId(), NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, GetProposeStartInfoVerified().GetStatusMessage());\n-            } else {\n-                evResult = NEvents::TDataEvents::TEvWriteResult::BuildPrepared(owner.TabletID(), txInfo.GetTxId(), owner.GetProgressTxController().BuildCoordinatorInfo(txInfo));\n-            }\n-            ctx.Send(txInfo.Source, evResult.release(), 0, txInfo.Cookie);\n-        }\n-\n-        virtual bool DoParse(TColumnShard& /*owner*/, const TString& data) override {\n-            NKikimrTxColumnShard::TCommitWriteTxBody commitTxBody;\n-            if (!commitTxBody.ParseFromString(data)) {\n-                return false;\n-            }\n-            LockId = commitTxBody.GetLockId();\n-            return !!LockId;\n-        }\n-\n-    public:\n-        using TBase::TBase;\n-\n-        virtual bool ProgressOnExecute(\n-            TColumnShard& owner, const NOlap::TSnapshot& version, NTabletFlatExecutor::TTransactionContext& txc) override {\n-            return owner.OperationsManager->CommitTransaction(owner, GetTxId(), txc, version);\n-        }\n-\n-        virtual bool ProgressOnComplete(TColumnShard& owner, const TActorContext& ctx) override {\n-            auto result = NEvents::TDataEvents::TEvWriteResult::BuildCompleted(owner.TabletID(), GetTxId());\n-            ctx.Send(TxInfo.Source, result.release(), 0, TxInfo.Cookie);\n-            return true;\n-        }\n-\n-        virtual bool ExecuteOnAbort(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) override {\n-            return owner.OperationsManager->AbortTransaction(owner, GetTxId(), txc);\n-        }\n-        virtual bool CompleteOnAbort(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n-            return true;\n-        }\n-\n-    private:\n-        ui64 LockId = 0;\n-    };\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/abstract.cpp b/ydb/core/tx/columnshard/transactions/operators/ev_write/abstract.cpp\nnew file mode 100644\nindex 000000000000..1217abd09701\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/abstract.cpp\n@@ -0,0 +1,5 @@\n+#include \"abstract.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/abstract.h b/ydb/core/tx/columnshard/transactions/operators/ev_write/abstract.h\nnew file mode 100644\nindex 000000000000..5be836f1d520\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/abstract.h\n@@ -0,0 +1,113 @@\n+#pragma once\n+\n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TBaseEvWriteTransactionOperator: public TTxController::ITransactionOperator {\n+private:\n+    using TBase = TTxController::ITransactionOperator;\n+    using TProposeResult = TTxController::TProposeResult;\n+\n+protected:\n+    ui64 LockId = 0;\n+\n+private:\n+    virtual bool DoParseImpl(TColumnShard& owner, const NKikimrTxColumnShard::TCommitWriteTxBody& commitTxBody) = 0;\n+    virtual TProposeResult DoStartProposeOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) override final {\n+        owner.GetOperationsManager().LinkTransactionOnExecute(LockId, GetTxId(), txc);\n+        return TProposeResult();\n+    }\n+    virtual void DoStartProposeOnComplete(TColumnShard& owner, const TActorContext& /*ctx*/) override final {\n+        owner.GetOperationsManager().LinkTransactionOnComplete(LockId, GetTxId());\n+    }\n+    virtual void DoFinishProposeOnExecute(TColumnShard& /*owner*/, NTabletFlatExecutor::TTransactionContext& /*txc*/) override final {\n+    }\n+    virtual void DoFinishProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override final {\n+    }\n+    virtual bool DoCheckAllowUpdate(const TFullTxInfo& currentTxInfo) const override final {\n+        return (currentTxInfo.Source == GetTxInfo().Source && currentTxInfo.Cookie == GetTxInfo().Cookie);\n+    }\n+    virtual bool DoParse(TColumnShard& owner, const TString& data) override final {\n+        NKikimrTxColumnShard::TCommitWriteTxBody commitTxBody;\n+        if (!commitTxBody.ParseFromString(data)) {\n+            return false;\n+        }\n+        LockId = commitTxBody.GetLockId();\n+        return DoParseImpl(owner, commitTxBody);\n+    }\n+\n+    virtual bool DoIsAsync() const override final {\n+        return false;\n+    }\n+\n+    virtual void DoSendReply(TColumnShard& owner, const TActorContext& ctx) override {\n+        const auto& txInfo = GetTxInfo();\n+        std::unique_ptr<NActors::IEventBase> evResult;\n+        TLogContextGuard gLogging(\n+            NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"send_reply_tx_id\", GetTxId())(\"send_reply_lock_id\", LockId));\n+        if (IsFail()) {\n+            evResult = NEvents::TDataEvents::TEvWriteResult::BuildError(owner.TabletID(), txInfo.GetTxId(),\n+                NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, GetProposeStartInfoVerified().GetStatusMessage());\n+        } else {\n+            evResult = NEvents::TDataEvents::TEvWriteResult::BuildPrepared(\n+                owner.TabletID(), txInfo.GetTxId(), owner.GetProgressTxController().BuildCoordinatorInfo(txInfo));\n+        }\n+        ctx.Send(txInfo.Source, evResult.release(), 0, txInfo.Cookie);\n+    }\n+    std::optional<NOlap::TSnapshot> Version;\n+\n+public:\n+    using TBase::TBase;\n+    TBaseEvWriteTransactionOperator(const TFullTxInfo& txInfo, const ui64 lockId)\n+        : TBase(txInfo)\n+        , LockId(lockId) {\n+    }\n+\n+    virtual bool IsTxBroken() const {\n+        return false;\n+    }\n+\n+    ui64 GetLockId() const {\n+        return LockId;\n+    }\n+\n+    virtual bool ProgressOnExecute(\n+        TColumnShard& owner, const NOlap::TSnapshot& version, NTabletFlatExecutor::TTransactionContext& txc) override {\n+        Version = version;\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"progress_tx_id\", GetTxId())(\"lock_id\", LockId)(\"broken\", IsTxBroken());\n+        if (IsTxBroken()) {\n+            owner.GetOperationsManager().AbortTransactionOnExecute(owner, GetTxId(), txc);\n+        } else {\n+            owner.GetOperationsManager().CommitTransactionOnExecute(owner, GetTxId(), txc, version);\n+        }\n+        return true;\n+    }\n+\n+    virtual bool ProgressOnComplete(TColumnShard& owner, const TActorContext& ctx) override {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"progress_tx_id\", GetTxId())(\"lock_id\", LockId)(\"broken\", IsTxBroken());\n+        AFL_VERIFY(Version);\n+        if (IsTxBroken()) {\n+            owner.GetOperationsManager().AbortTransactionOnComplete(owner, GetTxId());\n+            auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(\n+                owner.TabletID(), GetTxId(), NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN, \"lock invalidated\");\n+            ctx.Send(TxInfo.Source, result.release(), 0, TxInfo.Cookie);\n+        } else {\n+            owner.GetOperationsManager().CommitTransactionOnComplete(owner, GetTxId(), *Version);\n+            auto result = NEvents::TDataEvents::TEvWriteResult::BuildCompleted(owner.TabletID(), GetTxId());\n+            ctx.Send(TxInfo.Source, result.release(), 0, TxInfo.Cookie);\n+        }\n+        return true;\n+    }\n+\n+    virtual bool ExecuteOnAbort(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) override {\n+        owner.GetOperationsManager().AbortTransactionOnExecute(owner, GetTxId(), txc);\n+        return true;\n+    }\n+    virtual bool CompleteOnAbort(TColumnShard& owner, const TActorContext& /*ctx*/) override {\n+        owner.GetOperationsManager().AbortTransactionOnComplete(owner, GetTxId());\n+        return true;\n+    }\n+};\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/primary.cpp b/ydb/core/tx/columnshard/transactions/operators/ev_write/primary.cpp\nnew file mode 100644\nindex 000000000000..9e33c29d2053\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/primary.cpp\n@@ -0,0 +1,5 @@\n+#include \"primary.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/primary.h b/ydb/core/tx/columnshard/transactions/operators/ev_write/primary.h\nnew file mode 100644\nindex 000000000000..9073e7458ae3\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/primary.h\n@@ -0,0 +1,287 @@\n+#pragma once\n+\n+#include \"sync.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n+#include <ydb/core/tx/columnshard/data_sharing/common/transactions/tx_extension.h>\n+\n+#include <util/string/join.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TEvWriteCommitPrimaryTransactionOperator: public TEvWriteCommitSyncTransactionOperator,\n+                                                public TMonitoringObjectsCounter<TEvWriteCommitPrimaryTransactionOperator> {\n+private:\n+    using TBase = TEvWriteCommitSyncTransactionOperator;\n+    using TProposeResult = TTxController::TProposeResult;\n+    static inline auto Registrator =\n+        TFactory::TRegistrator<TEvWriteCommitPrimaryTransactionOperator>(NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE_PRIMARY);\n+\n+private:\n+    std::set<ui64> ReceivingShards;\n+    std::set<ui64> SendingShards;\n+    std::set<ui64> WaitShardsBrokenFlags;\n+    std::set<ui64> WaitShardsResultAck;\n+    std::optional<bool> TxBroken;\n+    mutable TAtomicCounter ControlCounter = 0;\n+\n+    virtual NKikimrTxColumnShard::TCommitWriteTxBody SerializeToProto() const override {\n+        NKikimrTxColumnShard::TCommitWriteTxBody result;\n+        auto& data = *result.MutablePrimaryTabletData();\n+        if (TxBroken) {\n+            data.SetTxBroken(*TxBroken);\n+        }\n+        for (auto&& i : ReceivingShards) {\n+            data.AddReceivingShards(i);\n+        }\n+        for (auto&& i : SendingShards) {\n+            data.AddSendingShards(i);\n+        }\n+        for (auto&& i : WaitShardsBrokenFlags) {\n+            data.AddWaitShardsBrokenFlags(i);\n+        }\n+        for (auto&& i : WaitShardsResultAck) {\n+            data.AddWaitShardsResultAck(i);\n+        }\n+        return result;\n+    }\n+\n+    virtual bool DoParseImpl(TColumnShard& /*owner*/, const NKikimrTxColumnShard::TCommitWriteTxBody& commitTxBody) override {\n+        if (!commitTxBody.HasPrimaryTabletData()) {\n+            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot read proto\")(\"proto\", commitTxBody.DebugString());\n+            return false;\n+        }\n+        auto& protoData = commitTxBody.GetPrimaryTabletData();\n+        for (auto&& i : protoData.GetReceivingShards()) {\n+            ReceivingShards.emplace(i);\n+        }\n+        for (auto&& i : protoData.GetSendingShards()) {\n+            SendingShards.emplace(i);\n+        }\n+        for (auto&& i : protoData.GetWaitShardsBrokenFlags()) {\n+            WaitShardsBrokenFlags.emplace(i);\n+        }\n+        for (auto&& i : protoData.GetWaitShardsResultAck()) {\n+            WaitShardsResultAck.emplace(i);\n+        }\n+        AFL_VERIFY(ReceivingShards.empty() == SendingShards.empty());\n+        if (protoData.HasTxBroken()) {\n+            TxBroken = protoData.GetTxBroken();\n+        }\n+        return true;\n+    }\n+\n+private:\n+    virtual TString DoGetOpType() const override {\n+        return \"EvWritePrimary\";\n+    }\n+    virtual TString DoDebugString() const override {\n+        return \"EV_WRITE_PRIMARY\";\n+    }\n+    class TTxWriteReceivedBrokenFlag: public NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard> {\n+    private:\n+        using TBase = NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard>;\n+        const ui64 TxId;\n+        const ui64 TabletId;\n+        const bool BrokenFlag;\n+\n+        virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& /*ctx*/) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitPrimaryTransactionOperator>(TxId);\n+            auto copy = *op;\n+            if (copy.WaitShardsBrokenFlags.erase(TabletId)) {\n+                copy.TxBroken = copy.TxBroken.value_or(false) || BrokenFlag;\n+                Self->GetProgressTxController().WriteTxOperatorInfo(txc, TxId, copy.SerializeToProto().SerializeAsString());\n+            } else {\n+                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"repeated shard broken_flag info\")(\"shard_id\", TabletId);\n+            }\n+            return true;\n+        }\n+        virtual void DoComplete(const NActors::TActorContext& /*ctx*/) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitPrimaryTransactionOperator>(TxId);\n+            if (op->WaitShardsBrokenFlags.erase(TabletId)) {\n+                op->TxBroken = op->TxBroken.value_or(false) || BrokenFlag;\n+                op->SendBrokenFlagAck(*Self, TabletId);\n+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"remove_tablet_id\")(\"wait\", JoinSeq(\",\", op->WaitShardsBrokenFlags))(\n+                    \"receive\", TabletId);\n+                op->InitializeRequests(*Self);\n+            } else {\n+                AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"repeated shard broken_flag info\")(\"shard_id\", TabletId);\n+            }\n+        }\n+\n+    public:\n+        TTxWriteReceivedBrokenFlag(TColumnShard& owner, const ui64 txId, const ui64 tabletId, const bool broken)\n+            : TBase(&owner, ::ToString(txId))\n+            , TxId(txId)\n+            , TabletId(tabletId)\n+            , BrokenFlag(broken) {\n+        }\n+    };\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> CreateReceiveBrokenFlagTx(\n+        TColumnShard& owner, const ui64 sendTabletId, const bool broken) const override {\n+        return std::make_unique<TTxWriteReceivedBrokenFlag>(owner, GetTxId(), sendTabletId, broken);\n+    }\n+\n+    class TTxWriteReceivedResultAck: public NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard> {\n+    private:\n+        using TBase = NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard>;\n+        const ui64 TxId;\n+        const ui64 TabletId;\n+\n+        virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& /*ctx*/) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitPrimaryTransactionOperator>(TxId);\n+            auto copy = *op;\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"ack_tablet\")(\"wait\", JoinSeq(\",\", op->WaitShardsResultAck))(\"receive\", TabletId);\n+            AFL_VERIFY(copy.WaitShardsResultAck.erase(TabletId));\n+            Self->GetProgressTxController().WriteTxOperatorInfo(txc, TxId, copy.SerializeToProto().SerializeAsString());\n+            return true;\n+        }\n+        virtual void DoComplete(const NActors::TActorContext& /*ctx*/) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitPrimaryTransactionOperator>(TxId);\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"ack_tablet\")(\"wait\", JoinSeq(\",\", op->WaitShardsResultAck))(\n+                \"receive\", TabletId);\n+            AFL_VERIFY(op->WaitShardsResultAck.erase(TabletId));\n+            op->CheckFinished(*Self);\n+        }\n+\n+    public:\n+        TTxWriteReceivedResultAck(TColumnShard& owner, const ui64 txId, const ui64 tabletId)\n+            : TBase(&owner)\n+            , TxId(txId)\n+            , TabletId(tabletId) {\n+        }\n+    };\n+\n+    virtual bool IsTxBroken() const override {\n+        AFL_VERIFY(TxBroken);\n+        return *TxBroken;\n+    }\n+\n+    void InitializeRequests(TColumnShard& owner) {\n+        if (WaitShardsBrokenFlags.empty()) {\n+            WaitShardsResultAck.erase(owner.TabletID());\n+            if (WaitShardsResultAck.size()) {\n+                SendResult(owner);\n+            } else {\n+                CheckFinished(owner);\n+            }\n+        }\n+    }\n+\n+    void CheckFinished(TColumnShard& owner) {\n+        if (WaitShardsResultAck.empty()) {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"finished\");\n+            owner.EnqueueProgressTx(NActors::TActivationContext::AsActorContext(), GetTxId());\n+        }\n+    }\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> CreateReceiveResultAckTx(\n+        TColumnShard& owner, const ui64 recvTabletId) const override\n+    {\n+        return std::make_unique<TTxWriteReceivedResultAck>(owner, GetTxId(), recvTabletId);\n+    }\n+\n+    void SendBrokenFlagAck(TColumnShard& owner, const std::optional<ui64> tabletId = {}) {\n+        for (auto&& i : SendingShards) {\n+            if (!WaitShardsBrokenFlags.contains(i)) {\n+                if (tabletId && *tabletId != i) {\n+                    continue;\n+                }\n+                NActors::TActivationContext::AsActorContext().Send(MakePipePerNodeCacheID(EPipePerNodeCache::Persistent),\n+                    new TEvPipeCache::TEvForward(\n+                        new TEvTxProcessing::TEvReadSetAck(0, GetTxId(), owner.TabletID(), i, owner.TabletID(), 0), i, true),\n+                    IEventHandle::FlagTrackDelivery, GetTxId());\n+            }\n+        }\n+    }\n+\n+    void SendResult(TColumnShard& owner) {\n+        AFL_VERIFY(!!TxBroken);\n+        NKikimrTx::TReadSetData readSetData;\n+        readSetData.SetDecision(*TxBroken ? NKikimrTx::TReadSetData::DECISION_ABORT : NKikimrTx::TReadSetData::DECISION_COMMIT);\n+        for (auto&& i : ReceivingShards) {\n+            if (WaitShardsResultAck.contains(i)) {\n+                NActors::TActivationContext::AsActorContext().Send(MakePipePerNodeCacheID(EPipePerNodeCache::Persistent),\n+                    new TEvPipeCache::TEvForward(\n+                        new TEvTxProcessing::TEvReadSet(0, GetTxId(), owner.TabletID(), i, owner.TabletID(), readSetData.SerializeAsString()), i,\n+                        true),\n+                    IEventHandle::FlagTrackDelivery, GetTxId());\n+            }\n+        }\n+    }\n+\n+    virtual void DoOnTabletInit(TColumnShard& owner) override {\n+        InitializeRequests(owner);\n+        CheckFinished(owner);\n+    }\n+\n+    class TTxStartPreparation: public NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard> {\n+    private:\n+        using TBase = NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard>;\n+        const ui64 TxId;\n+\n+        virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& /*ctx*/) override {\n+            auto& lock = Self->GetOperationsManager().GetLockVerified(Self->GetOperationsManager().GetLockForTxVerified(TxId));\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitPrimaryTransactionOperator>(TxId);\n+            if (op->WaitShardsBrokenFlags.contains(Self->TabletID())) {\n+                auto copy = *op;\n+                copy.TxBroken = lock.IsBroken();\n+                AFL_VERIFY(copy.WaitShardsBrokenFlags.erase(Self->TabletID()));\n+                if (copy.WaitShardsBrokenFlags.empty()) {\n+                    AFL_VERIFY(copy.WaitShardsResultAck.erase(Self->TabletID()));\n+                }\n+                \n+                Self->GetProgressTxController().WriteTxOperatorInfo(txc, TxId, copy.SerializeToProto().SerializeAsString());\n+            }\n+            return true;\n+        }\n+        virtual void DoComplete(const NActors::TActorContext& /*ctx*/) override {\n+            auto& lock = Self->GetOperationsManager().GetLockVerified(Self->GetOperationsManager().GetLockForTxVerified(TxId));\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitPrimaryTransactionOperator>(TxId);\n+            if (op->WaitShardsBrokenFlags.contains(Self->TabletID())) {\n+                op->TxBroken = lock.IsBroken();\n+                AFL_VERIFY(op->WaitShardsBrokenFlags.erase(Self->TabletID()));\n+                if (op->WaitShardsBrokenFlags.empty()) {\n+                    AFL_VERIFY(op->WaitShardsResultAck.erase(Self->TabletID()));\n+                }\n+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"remove_tablet_id\")(\"wait\", JoinSeq(\",\", op->WaitShardsBrokenFlags))(\n+                    \"receive\", Self->TabletID());\n+                op->CheckFinished(*Self);\n+            }\n+        }\n+\n+    public:\n+        TTxStartPreparation(TColumnShard* owner, const ui64 txId)\n+            : TBase(owner)\n+            , TxId(txId) {\n+        }\n+    };\n+\n+    virtual void OnTimeout(TColumnShard& owner) override {\n+        InitializeRequests(owner);\n+    }\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> DoBuildTxPrepareForProgress(TColumnShard* owner) const override {\n+        if (WaitShardsResultAck.empty()) {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_prepare_for_progress\")(\"lock_id\", LockId);\n+            return nullptr;\n+        }\n+        AFL_VERIFY(ControlCounter.Inc() <= 1);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"prepare_for_progress_started\")(\"lock_id\", LockId);\n+        return std::make_unique<TTxStartPreparation>(owner, GetTxId());\n+    }\n+\n+public:\n+    using TBase::TBase;\n+    TEvWriteCommitPrimaryTransactionOperator(\n+        const TFullTxInfo& txInfo, const ui64 lockId, const std::set<ui64>& receivingShards, const std::set<ui64>& sendingShards)\n+        : TBase(txInfo, lockId)\n+        , ReceivingShards(receivingShards)\n+        , SendingShards(sendingShards) {\n+        WaitShardsBrokenFlags = SendingShards;\n+        WaitShardsResultAck = ReceivingShards;\n+    }\n+};\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/secondary.cpp b/ydb/core/tx/columnshard/transactions/operators/ev_write/secondary.cpp\nnew file mode 100644\nindex 000000000000..30f6078321e9\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/secondary.cpp\n@@ -0,0 +1,5 @@\n+#include \"secondary.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/secondary.h b/ydb/core/tx/columnshard/transactions/operators/ev_write/secondary.h\nnew file mode 100644\nindex 000000000000..ae0224057b46\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/secondary.h\n@@ -0,0 +1,219 @@\n+#pragma once\n+\n+#include \"sync.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n+#include <ydb/core/tx/columnshard/data_sharing/common/transactions/tx_extension.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TEvWriteCommitSecondaryTransactionOperator: public TEvWriteCommitSyncTransactionOperator,\n+                                                  public TMonitoringObjectsCounter<TEvWriteCommitSecondaryTransactionOperator> {\n+private:\n+    using TBase = TEvWriteCommitSyncTransactionOperator;\n+    using TProposeResult = TTxController::TProposeResult;\n+    static inline auto Registrator =\n+        TFactory::TRegistrator<TEvWriteCommitSecondaryTransactionOperator>(NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE_SECONDARY);\n+\n+private:\n+    ui64 ArbiterTabletId;\n+    bool NeedReceiveBroken = false;\n+    bool ReceiveAck = false;\n+    bool SelfBroken = false;\n+    mutable TAtomicCounter ControlCounter = 0;\n+    std::optional<bool> TxBroken;\n+\n+    virtual NKikimrTxColumnShard::TCommitWriteTxBody SerializeToProto() const override {\n+        NKikimrTxColumnShard::TCommitWriteTxBody result;\n+        auto& data = *result.MutableSecondaryTabletData();\n+        if (TxBroken) {\n+            data.SetTxBroken(*TxBroken);\n+        }\n+        data.SetSelfBroken(SelfBroken);\n+        data.SetNeedReceiveBroken(NeedReceiveBroken);\n+        data.SetReceiveAck(ReceiveAck);\n+        data.SetArbiterTabletId(ArbiterTabletId);\n+        return result;\n+    }\n+\n+    virtual bool DoParseImpl(TColumnShard& /*owner*/, const NKikimrTxColumnShard::TCommitWriteTxBody& commitTxBody) override {\n+        if (!commitTxBody.HasSecondaryTabletData()) {\n+            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot read proto\")(\"proto\", commitTxBody.DebugString());\n+            return false;\n+        }\n+        auto& protoData = commitTxBody.GetSecondaryTabletData();\n+        SelfBroken = protoData.GetSelfBroken();\n+        ArbiterTabletId = protoData.GetArbiterTabletId();\n+        NeedReceiveBroken = protoData.GetNeedReceiveBroken();\n+        ReceiveAck = protoData.GetReceiveAck();\n+        if (protoData.HasTxBroken()) {\n+            TxBroken = protoData.GetTxBroken();\n+        }\n+        return true;\n+    }\n+\n+private:\n+    virtual TString DoGetOpType() const override {\n+        return \"EvWriteSecondary\";\n+    }\n+    virtual TString DoDebugString() const override {\n+        return \"EV_WRITE_SECONDARY\";\n+    }\n+    class TTxWriteReceivedAck: public NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard> {\n+    private:\n+        using TBase = NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard>;\n+        const ui64 TxId;\n+\n+        virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& /*ctx*/) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSecondaryTransactionOperator>(TxId);\n+            auto copy = *op;\n+            copy.ReceiveAck = true;\n+            auto proto = copy.SerializeToProto();\n+            Self->GetProgressTxController().WriteTxOperatorInfo(txc, TxId, proto.SerializeAsString());\n+            return true;\n+        }\n+        virtual void DoComplete(const NActors::TActorContext& ctx) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSecondaryTransactionOperator>(TxId);\n+            op->ReceiveAck = true;\n+            if (!op->NeedReceiveBroken) {\n+                op->TxBroken = false;\n+                Self->EnqueueProgressTx(ctx, TxId);\n+            }\n+        }\n+\n+    public:\n+        TTxWriteReceivedAck(TColumnShard& owner, const ui64 txId)\n+            : TBase(&owner)\n+            , TxId(txId) {\n+        }\n+    };\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> CreateReceiveResultAckTx(\n+        TColumnShard& owner, const ui64 recvTabletId) const override {\n+        AFL_VERIFY(recvTabletId == ArbiterTabletId)(\"recv\", recvTabletId)(\"arbiter\", ArbiterTabletId);\n+        return std::make_unique<TTxWriteReceivedAck>(owner, GetTxId());\n+    }\n+\n+    class TTxWriteReceivedBrokenFlag: public NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard> {\n+    private:\n+        using TBase = NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard>;\n+        const ui64 TxId;\n+        const bool BrokenFlag;\n+\n+        virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& /*ctx*/) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSecondaryTransactionOperator>(TxId);\n+            auto copy = *op;\n+            copy.TxBroken = BrokenFlag;\n+            auto proto = copy.SerializeToProto();\n+            Self->GetProgressTxController().WriteTxOperatorInfo(txc, TxId, proto.SerializeAsString());\n+            if (BrokenFlag) {\n+                Self->GetProgressTxController().ExecuteOnCancel(TxId, txc);\n+            }\n+            return true;\n+        }\n+        virtual void DoComplete(const NActors::TActorContext& ctx) override {\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSecondaryTransactionOperator>(TxId);\n+            op->TxBroken = BrokenFlag;\n+            op->SendBrokenFlagAck(*Self);\n+            if (BrokenFlag) {\n+                Self->GetProgressTxController().CompleteOnCancel(TxId, ctx);\n+            }\n+            Self->EnqueueProgressTx(ctx, TxId);\n+        }\n+\n+    public:\n+        TTxWriteReceivedBrokenFlag(TColumnShard* owner, const ui64 txId, const bool broken)\n+            : TBase(owner)\n+            , TxId(txId)\n+            , BrokenFlag(broken) {\n+        }\n+    };\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> CreateReceiveBrokenFlagTx(\n+        TColumnShard& owner, const ui64 sendTabletId, const bool broken) const override {\n+        AFL_VERIFY(ArbiterTabletId == sendTabletId);\n+        return std::make_unique<TTxWriteReceivedBrokenFlag>(&owner, GetTxId(), broken);\n+    }\n+\n+    void SendBrokenFlagAck(TColumnShard& owner) {\n+        NActors::TActivationContext::AsActorContext().Send(MakePipePerNodeCacheID(EPipePerNodeCache::Persistent),\n+            new TEvPipeCache::TEvForward(\n+                new TEvTxProcessing::TEvReadSetAck(0, GetTxId(), owner.TabletID(), ArbiterTabletId, owner.TabletID(), 0), ArbiterTabletId, true),\n+            IEventHandle::FlagTrackDelivery, GetTxId());\n+    }\n+\n+    void SendResult(TColumnShard& owner) {\n+        NKikimrTx::TReadSetData readSetData;\n+        readSetData.SetDecision(SelfBroken ? NKikimrTx::TReadSetData::DECISION_ABORT : NKikimrTx::TReadSetData::DECISION_COMMIT);\n+        NActors::TActivationContext::AsActorContext().Send(MakePipePerNodeCacheID(EPipePerNodeCache::Persistent),\n+            new TEvPipeCache::TEvForward(new TEvTxProcessing::TEvReadSet(\n+                                             0, GetTxId(), owner.TabletID(), ArbiterTabletId, owner.TabletID(), readSetData.SerializeAsString()),\n+                ArbiterTabletId, true),\n+            IEventHandle::FlagTrackDelivery, GetTxId());\n+    }\n+\n+    virtual void DoOnTabletInit(TColumnShard& owner) override {\n+        if (TxBroken || (ReceiveAck && !NeedReceiveBroken)) {\n+            owner.EnqueueProgressTx(NActors::TActivationContext::AsActorContext(), GetTxId());\n+        } else if (!ReceiveAck) {\n+            SendResult(owner);\n+        }\n+    }\n+\n+    class TTxStartPreparation: public NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard> {\n+    private:\n+        using TBase = NOlap::NDataSharing::TExtendedTransactionBase<TColumnShard>;\n+        const ui64 TxId;\n+\n+        virtual bool DoExecute(NTabletFlatExecutor::TTransactionContext& txc, const NActors::TActorContext& /*ctx*/) override {\n+            auto& lock = Self->GetOperationsManager().GetLockVerified(Self->GetOperationsManager().GetLockForTxVerified(TxId));\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSecondaryTransactionOperator>(TxId);\n+            auto copy = *op;\n+            copy.SelfBroken = lock.IsBroken();\n+            Self->GetProgressTxController().WriteTxOperatorInfo(txc, TxId, copy.SerializeToProto().SerializeAsString());\n+            return true;\n+        }\n+        virtual void DoComplete(const NActors::TActorContext& /*ctx*/) override {\n+            auto& lock = Self->GetOperationsManager().GetLockVerified(Self->GetOperationsManager().GetLockForTxVerified(TxId));\n+            auto op = Self->GetProgressTxController().GetTxOperatorVerifiedAs<TEvWriteCommitSecondaryTransactionOperator>(TxId);\n+            op->SelfBroken = lock.IsBroken();\n+            op->SendResult(*Self);\n+        }\n+\n+    public:\n+        TTxStartPreparation(TColumnShard* owner, const ui64 txId)\n+            : TBase(owner)\n+            , TxId(txId) {\n+        }\n+    };\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> DoBuildTxPrepareForProgress(TColumnShard* owner) const override {\n+        if (TxBroken || (!NeedReceiveBroken && ReceiveAck)) {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_prepare_for_progress\")(\"lock_id\", LockId);\n+            return nullptr;\n+        }\n+        AFL_VERIFY(ControlCounter.Inc() <= 1);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"prepare_for_progress_started\")(\"lock_id\", LockId);\n+        return std::make_unique<TTxStartPreparation>(owner, GetTxId());\n+    }\n+\n+    virtual void OnTimeout(TColumnShard& owner) override {\n+        SendResult(owner);\n+    }\n+\n+public:\n+    using TBase::TBase;\n+    virtual bool IsTxBroken() const override {\n+        AFL_VERIFY(TxBroken);\n+        return *TxBroken;\n+    }\n+\n+    TEvWriteCommitSecondaryTransactionOperator(\n+        const TFullTxInfo& txInfo, const ui64 lockId, const ui64 arbiterTabletId, const bool needReceiveBroken)\n+        : TBase(txInfo, lockId)\n+        , ArbiterTabletId(arbiterTabletId)\n+        , NeedReceiveBroken(needReceiveBroken) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/simple.cpp b/ydb/core/tx/columnshard/transactions/operators/ev_write/simple.cpp\nnew file mode 100644\nindex 000000000000..a6c51118a30e\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/simple.cpp\n@@ -0,0 +1,5 @@\n+#include \"simple.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/simple.h b/ydb/core/tx/columnshard/transactions/operators/ev_write/simple.h\nnew file mode 100644\nindex 000000000000..e3301117bb48\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/simple.h\n@@ -0,0 +1,28 @@\n+#pragma once\n+\n+#include \"abstract.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TEvWriteSimpleCommitTransactionOperator: public TBaseEvWriteTransactionOperator,\n+                                               public TMonitoringObjectsCounter<TEvWriteSimpleCommitTransactionOperator> {\n+private:\n+    using TBase = TBaseEvWriteTransactionOperator;\n+    virtual bool DoParseImpl(TColumnShard& /*owner*/, const NKikimrTxColumnShard::TCommitWriteTxBody& /*commitTxBody*/) override {\n+        return true;\n+    }\n+    static inline auto Registrator = TFactory::TRegistrator<TEvWriteSimpleCommitTransactionOperator>(NKikimrTxColumnShard::TX_KIND_COMMIT_WRITE);\n+\n+public:\n+    using TBase::TBase;\n+    virtual TString DoGetOpType() const override {\n+        return \"EvWriteSimple\";\n+    }\n+    virtual TString DoDebugString() const override {\n+        return \"EV_WRITE_SIMPLE\";\n+    }\n+};\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/sync.cpp b/ydb/core/tx/columnshard/transactions/operators/ev_write/sync.cpp\nnew file mode 100644\nindex 000000000000..a8a75f586177\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/sync.cpp\n@@ -0,0 +1,5 @@\n+#include \"sync.h\"\n+\n+namespace NKikimr::NColumnShard {\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/sync.h b/ydb/core/tx/columnshard/transactions/operators/ev_write/sync.h\nnew file mode 100644\nindex 000000000000..8d149cca8100\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/sync.h\n@@ -0,0 +1,37 @@\n+#pragma once\n+\n+#include \"abstract.h\"\n+\n+#include <ydb/core/tx/columnshard/columnshard_impl.h>\n+\n+namespace NKikimr::NColumnShard {\n+\n+class TEvWriteCommitSyncTransactionOperator: public TBaseEvWriteTransactionOperator {\n+private:\n+    using TBase = TBaseEvWriteTransactionOperator;\n+    mutable std::optional<TMonotonic> DeadlockControlInstant;\n+    virtual void OnTimeout(TColumnShard& owner) = 0;\n+\n+    virtual bool DoPingTimeout(TColumnShard& owner, const TMonotonic now) override final {\n+        if (!DeadlockControlInstant) {\n+            DeadlockControlInstant = now;\n+        } else if (now - *DeadlockControlInstant > TDuration::Seconds(2)) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"tx_timeout\")(\"lock\", LockId)(\"tx_id\", GetTxId())(\n+                \"d\", now - *DeadlockControlInstant);\n+            DeadlockControlInstant = now;\n+            OnTimeout(owner);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    using TBase::TBase;\n+\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> CreateReceiveResultAckTx(TColumnShard& owner, const ui64 recvTabletId) const = 0;\n+    virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> CreateReceiveBrokenFlagTx(\n+        TColumnShard& owner, const ui64 sendTabletId, const bool broken) const = 0;\n+    virtual NKikimrTxColumnShard::TCommitWriteTxBody SerializeToProto() const = 0;\n+};\n+\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ev_write/ya.make b/ydb/core/tx/columnshard/transactions/operators/ev_write/ya.make\nnew file mode 100644\nindex 000000000000..c7283c74fa3d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/operators/ev_write/ya.make\n@@ -0,0 +1,18 @@\n+LIBRARY()\n+\n+SRCS(\n+    GLOBAL secondary.cpp\n+    GLOBAL simple.cpp\n+    GLOBAL primary.cpp\n+    abstract.cpp\n+    sync.cpp\n+)\n+\n+PEERDIR(\n+    ydb/services/metadata/abstract\n+    ydb/core/tx/columnshard/blobs_action/events\n+    ydb/core/tx/columnshard/data_sharing/destination/events\n+    ydb/core/tx/columnshard/transactions/locks\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/long_tx_write.cpp b/ydb/core/tx/columnshard/transactions/operators/long_tx_write.cpp\nindex 3c04dcdff64a..99298434b88b 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/long_tx_write.cpp\n+++ b/ydb/core/tx/columnshard/transactions/operators/long_tx_write.cpp\n@@ -20,9 +20,9 @@ TLongTxTransactionOperator::TProposeResult TLongTxTransactionOperator::DoStartPr\n                 TStringBuilder() << \"Commit TxId# \" << GetTxId() << \" references WriteId# \" << (ui64)writeId << \" that is already locked by TxId# \" << lw.PreparedTxId);\n         }\n \n-        auto it = owner.InsertTable->GetInserted().find(writeId);\n-        if (it != owner.InsertTable->GetInserted().end()) {\n-            auto granuleShardingInfo = owner.GetIndexAs<NOlap::TColumnEngineForLogs>().GetVersionedIndex().GetShardingInfoActual(it->second.PathId);\n+        if (auto* inserted = owner.InsertTable->GetInserted().GetOptional(writeId)) {\n+            auto granuleShardingInfo =\n+                owner.GetIndexAs<NOlap::TColumnEngineForLogs>().GetVersionedIndex().GetShardingInfoActual(inserted->GetPathId());\n             if (granuleShardingInfo && lw.GranuleShardingVersionId && *lw.GranuleShardingVersionId != granuleShardingInfo->GetSnapshotVersion()) {\n                 return TProposeResult(NKikimrTxColumnShard::EResultStatus::ERROR,\n                     TStringBuilder() << \"Commit TxId# \" << GetTxId() << \" references WriteId# \" << (ui64)writeId << \" declined through sharding deprecated\");\n@@ -43,9 +43,14 @@ bool TLongTxTransactionOperator::DoParse(TColumnShard& /*owner*/, const TString&\n     }\n \n     for (auto& id : commitTxBody.GetWriteIds()) {\n-        WriteIds.insert(TWriteId{ id });\n+        WriteIds.insert(TInsertWriteId{ id });\n     }\n     return true;\n }\n \n+void TLongTxTransactionOperator::DoSendReply(TColumnShard& owner, const TActorContext& ctx) {\n+    const auto& txInfo = GetTxInfo();\n+    ctx.Send(txInfo.Source, BuildProposeResultEvent(owner).release());\n+}\n+\n }\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/long_tx_write.h b/ydb/core/tx/columnshard/transactions/operators/long_tx_write.h\nindex 35adecab6092..45b642c8e98a 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/long_tx_write.h\n+++ b/ydb/core/tx/columnshard/transactions/operators/long_tx_write.h\n@@ -24,10 +24,15 @@ namespace NKikimr::NColumnShard {\n         virtual void DoStartProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n \n         }\n+        virtual void DoSendReply(TColumnShard& owner, const TActorContext& ctx) override;\n+\n         virtual void DoFinishProposeOnExecute(TColumnShard& /*owner*/, NTabletFlatExecutor::TTransactionContext& /*txc*/) override {\n         }\n         virtual void DoFinishProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n         }\n+        virtual TString DoGetOpType() const override {\n+            return \"LongTxWrite\";\n+        }\n         virtual bool DoIsAsync() const override {\n             return false;\n         }\n@@ -41,7 +46,7 @@ namespace NKikimr::NColumnShard {\n     public:\n         using TBase::TBase;\n \n-        void OnTabletInit(TColumnShard& owner) override {\n+        virtual void DoOnTabletInit(TColumnShard& owner) override {\n             for (auto&& writeId : WriteIds) {\n                 AFL_VERIFY(owner.LongTxWrites.contains(writeId))(\"problem\", \"ltx_not_exists_for_write_id\")(\"txId\", GetTxId())(\"writeId\", (ui64)writeId);\n                 owner.AddLongTxWrite(writeId, GetTxId());\n@@ -58,12 +63,12 @@ namespace NKikimr::NColumnShard {\n \n             auto counters = owner.InsertTable->Commit(dbTable, version.GetPlanStep(), version.GetTxId(), WriteIds, pathExists);\n \n-            owner.IncCounter(COUNTER_BLOBS_COMMITTED, counters.Rows);\n-            owner.IncCounter(COUNTER_BYTES_COMMITTED, counters.Bytes);\n-            owner.IncCounter(COUNTER_RAW_BYTES_COMMITTED, counters.RawBytes);\n+            owner.Counters.GetTabletCounters()->IncCounter(COUNTER_BLOBS_COMMITTED, counters.Rows);\n+            owner.Counters.GetTabletCounters()->IncCounter(COUNTER_BYTES_COMMITTED, counters.Bytes);\n+            owner.Counters.GetTabletCounters()->IncCounter(COUNTER_RAW_BYTES_COMMITTED, counters.RawBytes);\n \n             NIceDb::TNiceDb db(txc.DB);\n-            for (TWriteId writeId : WriteIds) {\n+            for (TInsertWriteId writeId : WriteIds) {\n                 AFL_VERIFY(owner.RemoveLongTxWrite(db, writeId, GetTxId()));\n             }\n             owner.UpdateInsertTableCounters();\n@@ -79,7 +84,7 @@ namespace NKikimr::NColumnShard {\n \n         virtual bool ExecuteOnAbort(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) override {\n             NIceDb::TNiceDb db(txc.DB);\n-            for (TWriteId writeId : WriteIds) {\n+            for (TInsertWriteId writeId : WriteIds) {\n                 AFL_VERIFY(owner.RemoveLongTxWrite(db, writeId, GetTxId()));\n             }\n             TBlobGroupSelector dsGroupSelector(owner.Info());\n@@ -92,7 +97,7 @@ namespace NKikimr::NColumnShard {\n         }\n \n     private:\n-        THashSet<TWriteId> WriteIds;\n+        THashSet<TInsertWriteId> WriteIds;\n     };\n \n }   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/propose_tx.cpp b/ydb/core/tx/columnshard/transactions/operators/propose_tx.cpp\nindex c7d39da52740..2a48ca49a279 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/propose_tx.cpp\n+++ b/ydb/core/tx/columnshard/transactions/operators/propose_tx.cpp\n@@ -3,21 +3,36 @@\n namespace NKikimr::NColumnShard {\n \n void IProposeTxOperator::DoSendReply(TColumnShard& owner, const TActorContext& ctx) {\n+    if (owner.CurrentSchemeShardId) {\n+        AFL_VERIFY(owner.CurrentSchemeShardId);\n+        ctx.Send(MakePipePerNodeCacheID(false),\n+            new TEvPipeCache::TEvForward(BuildProposeResultEvent(owner).release(), (ui64)owner.CurrentSchemeShardId, true));\n+    } else {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"scheme_shard_tablet_not_initialized\")(\"source\", GetTxInfo().Source);\n+        ctx.Send(GetTxInfo().Source, BuildProposeResultEvent(owner).release());\n+    }\n+}\n+\n+std::unique_ptr<NKikimr::TEvColumnShard::TEvProposeTransactionResult> IProposeTxOperator::BuildProposeResultEvent(const TColumnShard& owner) const {\n     const auto& txInfo = GetTxInfo();\n-    std::unique_ptr<TEvColumnShard::TEvProposeTransactionResult> evResult = std::make_unique<TEvColumnShard::TEvProposeTransactionResult>(\n-        owner.TabletID(), txInfo.TxKind, txInfo.TxId, GetProposeStartInfoVerified().GetStatus(), GetProposeStartInfoVerified().GetStatusMessage());\n+    std::unique_ptr<TEvColumnShard::TEvProposeTransactionResult> evResult =\n+        std::make_unique<TEvColumnShard::TEvProposeTransactionResult>(owner.TabletID(), txInfo.TxKind, txInfo.TxId,\n+            GetProposeStartInfoVerified().GetStatus(), GetProposeStartInfoVerified().GetStatusMessage());\n     if (IsFail()) {\n-        owner.IncCounter(COUNTER_PREPARE_ERROR);\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"message\", GetProposeStartInfoVerified().GetStatusMessage())(\"tablet_id\", owner.TabletID())(\"tx_id\", txInfo.TxId);\n+        owner.Counters.GetTabletCounters()->IncCounter(COUNTER_PREPARE_ERROR);\n+        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"message\", GetProposeStartInfoVerified().GetStatusMessage())(\"tablet_id\", owner.TabletID())(\n+            \"tx_id\", txInfo.TxId);\n     } else {\n         evResult->Record.SetMinStep(txInfo.MinStep);\n         evResult->Record.SetMaxStep(txInfo.MaxStep);\n         if (owner.ProcessingParams) {\n             evResult->Record.MutableDomainCoordinators()->CopyFrom(owner.ProcessingParams->GetCoordinators());\n         }\n-        owner.IncCounter(COUNTER_PREPARE_SUCCESS);\n+        owner.Counters.GetTabletCounters()->IncCounter(COUNTER_PREPARE_SUCCESS);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"message\", GetProposeStartInfoVerified().GetStatusMessage())(\"tablet_id\", owner.TabletID())(\n+            \"tx_id\", txInfo.TxId);\n     }\n-    ctx.Send(txInfo.Source, evResult.release());\n+    return evResult;\n }\n \n }\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/propose_tx.h b/ydb/core/tx/columnshard/transactions/operators/propose_tx.h\nindex 84b2f7e8db66..d867e71bad9b 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/propose_tx.h\n+++ b/ydb/core/tx/columnshard/transactions/operators/propose_tx.h\n@@ -12,6 +12,7 @@ class IProposeTxOperator: public TTxController::ITransactionOperator {\n     virtual bool DoCheckTxInfoForReply(const TFullTxInfo& originalTxInfo) const override {\n         return GetTxInfo() == originalTxInfo;\n     }\n+    std::unique_ptr<TEvColumnShard::TEvProposeTransactionResult> BuildProposeResultEvent(const TColumnShard& owner) const;\n     virtual void DoSendReply(TColumnShard& owner, const TActorContext& ctx) override;\n     virtual bool DoCheckAllowUpdate(const TFullTxInfo& currentTxInfo) const override {\n         if (!currentTxInfo.SeqNo || !GetTxInfo().SeqNo) {\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/schema.cpp b/ydb/core/tx/columnshard/transactions/operators/schema.cpp\nindex 13f854e277b5..d4019542bf1e 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/schema.cpp\n+++ b/ydb/core/tx/columnshard/transactions/operators/schema.cpp\n@@ -40,7 +40,17 @@ class TWaitEraseTablesTxSubscriber: public NSubscriber::ISubscriber {\n     }\n };\n \n-NKikimr::NColumnShard::TTxController::TProposeResult TSchemaTransactionOperator::DoStartProposeOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) {\n+TTxController::TProposeResult TSchemaTransactionOperator::DoStartProposeOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) {\n+    auto seqNo = SeqNoFromProto(SchemaTxBody.GetSeqNo());\n+    auto lastSeqNo = owner.LastSchemaSeqNo;\n+\n+    // Check if proposal is outdated\n+    if (seqNo < lastSeqNo) {\n+        auto errorMessage = TStringBuilder() << \"Ignoring outdated schema tx proposal at tablet \" << owner.TabletID() << \" txId \" << GetTxId()\n+                                             << \" ssId \" << owner.CurrentSchemeShardId << \" seqNo \" << seqNo << \" lastSeqNo \" << lastSeqNo;\n+        return TProposeResult(NKikimrTxColumnShard::EResultStatus::SCHEMA_CHANGED, errorMessage);\n+    }\n+\n     switch (SchemaTxBody.TxBody_case()) {\n         case NKikimrTxColumnShard::TSchemaTxBody::kInitShard:\n         {\n@@ -67,21 +77,6 @@ NKikimr::NColumnShard::TTxController::TProposeResult TSchemaTransactionOperator:\n             break;\n     }\n \n-    auto seqNo = SeqNoFromProto(SchemaTxBody.GetSeqNo());\n-    auto lastSeqNo = owner.LastSchemaSeqNo;\n-\n-    // Check if proposal is outdated\n-    if (seqNo < lastSeqNo) {\n-        auto errorMessage = TStringBuilder()\n-            << \"Ignoring outdated schema tx proposal at tablet \"\n-            << owner.TabletID()\n-            << \" txId \" << GetTxId()\n-            << \" ssId \" << owner.CurrentSchemeShardId\n-            << \" seqNo \" << seqNo\n-            << \" lastSeqNo \" << lastSeqNo;\n-        return TProposeResult(NKikimrTxColumnShard::EResultStatus::SCHEMA_CHANGED, errorMessage);\n-    }\n-\n     owner.UpdateSchemaSeqNo(seqNo, txc);\n     return TProposeResult();\n }\n@@ -166,7 +161,7 @@ NKikimr::TConclusionStatus TSchemaTransactionOperator::ValidateTables(::google::\n     } return TConclusionStatus::Success();\n }\n \n-bool TSchemaTransactionOperator::DoOnStartAsync(TColumnShard& owner) {\n+void TSchemaTransactionOperator::DoOnTabletInit(TColumnShard& owner) {\n     AFL_VERIFY(WaitPathIdsToErase.empty());\n     switch (SchemaTxBody.TxBody_case()) {\n         case NKikimrTxColumnShard::TSchemaTxBody::kInitShard:\n@@ -190,11 +185,9 @@ bool TSchemaTransactionOperator::DoOnStartAsync(TColumnShard& owner) {\n     if (WaitPathIdsToErase.size()) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"wait_remove_path_id\")(\"pathes\", JoinSeq(\",\", WaitPathIdsToErase))(\"tx_id\", GetTxId());\n         owner.Subscribers->RegisterSubscriber(std::make_shared<TWaitEraseTablesTxSubscriber>(WaitPathIdsToErase, GetTxId()));\n-        return true;\n     } else {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"remove_pathes_cleaned\")(\"tx_id\", GetTxId());\n         owner.Execute(new TTxFinishAsyncTransaction(owner, GetTxId()));\n-        return false;\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/transactions/operators/schema.h b/ydb/core/tx/columnshard/transactions/operators/schema.h\nindex f79e10fac2ca..8b7575cc3cc4 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/schema.h\n+++ b/ydb/core/tx/columnshard/transactions/operators/schema.h\n@@ -18,7 +18,7 @@ class TSchemaTransactionOperator: public IProposeTxOperator, public TMonitoringO\n     THashSet<TActorId> NotifySubscribers;\n     THashSet<ui64> WaitPathIdsToErase;\n \n-    virtual bool DoOnStartAsync(TColumnShard& owner) override;\n+    virtual void DoOnTabletInit(TColumnShard& owner) override;\n \n     template <class TInfoProto>\n     THashSet<ui64> GetNotErasedTableIds(const TColumnShard& owner, const TInfoProto& tables) const {\n@@ -43,6 +43,22 @@ class TSchemaTransactionOperator: public IProposeTxOperator, public TMonitoringO\n     }\n     virtual void DoFinishProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n     }\n+    virtual TString DoGetOpType() const override {\n+        switch (SchemaTxBody.TxBody_case()) {\n+            case NKikimrTxColumnShard::TSchemaTxBody::kInitShard:\n+                return \"Scheme:InitShard\";\n+            case NKikimrTxColumnShard::TSchemaTxBody::kEnsureTables:\n+                return \"Scheme:EnsureTables\";\n+            case NKikimrTxColumnShard::TSchemaTxBody::kAlterTable:\n+                return \"Scheme:AlterTable\";\n+            case NKikimrTxColumnShard::TSchemaTxBody::kAlterStore:\n+                return \"Scheme:AlterStore\";\n+            case NKikimrTxColumnShard::TSchemaTxBody::kDropTable:\n+                return \"Scheme:DropTable\";\n+            case NKikimrTxColumnShard::TSchemaTxBody::TXBODY_NOT_SET:\n+                return \"Scheme:TXBODY_NOT_SET\";\n+        }\n+    }\n     virtual bool DoIsAsync() const override {\n         return WaitPathIdsToErase.size();\n     }\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/sharing.h b/ydb/core/tx/columnshard/transactions/operators/sharing.h\nindex acf02304d878..13c7df7cad0e 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/sharing.h\n+++ b/ydb/core/tx/columnshard/transactions/operators/sharing.h\n@@ -25,6 +25,9 @@ class TSharingTransactionOperator: public IProposeTxOperator, public TMonitoring\n     }\n     virtual void DoFinishProposeOnComplete(TColumnShard& /*owner*/, const TActorContext& /*ctx*/) override {\n     }\n+    virtual TString DoGetOpType() const override {\n+        return \"Sharing\";\n+    }\n     virtual bool DoIsAsync() const override {\n         AFL_VERIFY(SharingTask);\n         return !SharingTask->IsFinished();\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ss_operation.cpp b/ydb/core/tx/columnshard/transactions/operators/ss_operation.cpp\ndeleted file mode 100644\nindex 1bf60d44d373..000000000000\n--- a/ydb/core/tx/columnshard/transactions/operators/ss_operation.cpp\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-#include \"ss_operation.h\"\n-\n-namespace NKikimr::NColumnShard {\n-\n-void ISSTransactionOperator::DoSendReply(TColumnShard& owner, const TActorContext& ctx) {\n-    const auto& txInfo = GetTxInfo();\n-    std::unique_ptr<TEvColumnShard::TEvProposeTransactionResult> evResult = std::make_unique<TEvColumnShard::TEvProposeTransactionResult>(\n-        owner.TabletID(), txInfo.TxKind, txInfo.TxId, GetProposeStartInfoVerified().GetStatus(), GetProposeStartInfoVerified().GetStatusMessage());\n-    if (IsFail()) {\n-        owner.IncCounter(COUNTER_PREPARE_ERROR);\n-        AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"message\", GetProposeStartInfoVerified().GetStatusMessage())(\"tablet_id\", owner.TabletID())(\"tx_id\", txInfo.TxId);\n-    } else {\n-        evResult->Record.SetMinStep(txInfo.MinStep);\n-        evResult->Record.SetMaxStep(txInfo.MaxStep);\n-        if (owner.ProcessingParams) {\n-            evResult->Record.MutableDomainCoordinators()->CopyFrom(owner.ProcessingParams->GetCoordinators());\n-        }\n-        owner.IncCounter(COUNTER_PREPARE_SUCCESS);\n-    }\n-    ctx.Send(txInfo.Source, evResult.release());\n-}\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ss_operation.h b/ydb/core/tx/columnshard/transactions/operators/ss_operation.h\ndeleted file mode 100644\nindex feff6af77225..000000000000\n--- a/ydb/core/tx/columnshard/transactions/operators/ss_operation.h\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-#pragma once\n-\n-#include <ydb/core/tx/columnshard/columnshard_impl.h>\n-#include <ydb/core/tx/columnshard/transactions/tx_controller.h>\n-\n-namespace NKikimr::NColumnShard {\n-\n-class ISSTransactionOperator: public TTxController::ITransactionOperator {\n-private:\n-    using TBase = TTxController::ITransactionOperator;\n-protected:\n-    virtual void DoSendReply(TColumnShard& owner, const TActorContext& ctx) override;\n-public:\n-    using TBase::TBase;\n-};\n-\n-}\ndiff --git a/ydb/core/tx/columnshard/transactions/operators/ya.make b/ydb/core/tx/columnshard/transactions/operators/ya.make\nindex 579b0d07679c..e96323b51b44 100644\n--- a/ydb/core/tx/columnshard/transactions/operators/ya.make\n+++ b/ydb/core/tx/columnshard/transactions/operators/ya.make\n@@ -3,7 +3,6 @@ LIBRARY()\n SRCS(\n     GLOBAL schema.cpp\n     GLOBAL long_tx_write.cpp\n-    GLOBAL ev_write.cpp\n     GLOBAL backup.cpp\n     GLOBAL sharing.cpp\n     propose_tx.cpp\n@@ -11,6 +10,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/tx/columnshard/data_sharing/destination/events\n+    ydb/core/tx/columnshard/transactions/operators/ev_write\n     ydb/core/tx/columnshard/export/session\n )\n \ndiff --git a/ydb/core/tx/columnshard/transactions/protos/tx_event.proto b/ydb/core/tx/columnshard/transactions/protos/tx_event.proto\nnew file mode 100644\nindex 000000000000..6e64dde46e4d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/protos/tx_event.proto\n@@ -0,0 +1,19 @@\n+package NKikimrColumnShardTxProto;\n+\n+message TEvent {\n+    optional uint64 PathId = 1;\n+    optional string ClassName = 2;\n+\n+    message TReadEvent {\n+        optional string Filter = 1;\n+        optional string Schema = 2;\n+    }\n+\n+    message TWriteEvent {\n+    }\n+\n+    oneof Implementation {\n+        TReadEvent Read = 20;\n+        TWriteEvent Write = 21;\n+    }\n+}\ndiff --git a/ydb/core/tx/columnshard/transactions/protos/ya.make b/ydb/core/tx/columnshard/transactions/protos/ya.make\nnew file mode 100644\nindex 000000000000..7a54fdc3404d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/transactions/protos/ya.make\n@@ -0,0 +1,12 @@\n+PROTO_LIBRARY()\n+\n+SRCS(\n+    tx_event.proto\n+)\n+\n+PEERDIR(\n+    ydb/core/tx/columnshard/common/protos\n+    ydb/core/protos\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/transactions/tx_controller.cpp b/ydb/core/tx/columnshard/transactions/tx_controller.cpp\nindex d9b6e1451a17..afb1e8a33d50 100644\n--- a/ydb/core/tx/columnshard/transactions/tx_controller.cpp\n+++ b/ydb/core/tx/columnshard/transactions/tx_controller.cpp\n@@ -1,4 +1,5 @@\n #include \"tx_controller.h\"\n+\n #include \"transactions/tx_finish_async.h\"\n \n #include <ydb/core/tx/columnshard/columnshard_impl.h>\n@@ -6,7 +7,8 @@\n namespace NKikimr::NColumnShard {\n \n TTxController::TTxController(TColumnShard& owner)\n-    : Owner(owner) {\n+    : Owner(owner)\n+    , Counters(owner.Counters.GetCSCounters().TxProgress) {\n }\n \n bool TTxController::HaveOutdatedTxs() const {\n@@ -52,9 +54,9 @@ bool TTxController::Load(NTabletFlatExecutor::TTransactionContext& txc) {\n         const ui64 txId = rowset.GetValue<Schema::TxInfo::TxId>();\n         const NKikimrTxColumnShard::ETransactionKind txKind = rowset.GetValue<Schema::TxInfo::TxKind>();\n         ITransactionOperator::TPtr txOperator(ITransactionOperator::TFactory::Construct(txKind, TTxInfo(txKind, txId)));\n-        Y_ABORT_UNLESS(!!txOperator);\n+        AFL_VERIFY(!!txOperator)(\"kind\", txKind);\n         const TString txBody = rowset.GetValue<Schema::TxInfo::TxBody>();\n-        Y_ABORT_UNLESS(txOperator->Parse(Owner, txBody, true));\n+        AFL_VERIFY(txOperator->Parse(Owner, txBody, true));\n \n         auto& txInfo = txOperator->MutableTxInfo();\n         txInfo.MaxStep = rowset.GetValue<Schema::TxInfo::MaxStep>();\n@@ -89,22 +91,9 @@ bool TTxController::Load(NTabletFlatExecutor::TTransactionContext& txc) {\n     return true;\n }\n \n-TTxController::ITransactionOperator::TPtr TTxController::GetTxOperator(const ui64 txId) const {\n-    auto it = Operators.find(txId);\n-    if (it == Operators.end()) {\n-        return nullptr;\n-    }\n-    return it->second;\n-}\n-\n-TTxController::ITransactionOperator::TPtr TTxController::GetVerifiedTxOperator(const ui64 txId) const {\n-    auto it = Operators.find(txId);\n-    AFL_VERIFY(it != Operators.end())(\"tx_id\", txId);\n-    return it->second;\n-}\n-\n-std::shared_ptr<TTxController::ITransactionOperator> TTxController::UpdateTxSourceInfo(const TFullTxInfo& tx, NTabletFlatExecutor::TTransactionContext& txc) {\n-    auto op = GetVerifiedTxOperator(tx.GetTxId());\n+std::shared_ptr<TTxController::ITransactionOperator> TTxController::UpdateTxSourceInfo(\n+    const TFullTxInfo& tx, NTabletFlatExecutor::TTransactionContext& txc) {\n+    auto op = GetTxOperatorVerified(tx.GetTxId());\n     op->ResetStatusOnUpdate();\n     auto& txInfo = op->MutableTxInfo();\n     txInfo.Source = tx.Source;\n@@ -116,17 +105,20 @@ std::shared_ptr<TTxController::ITransactionOperator> TTxController::UpdateTxSour\n     return op;\n }\n \n-TTxController::TTxInfo TTxController::RegisterTx(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc) {\n+TTxController::TTxInfo TTxController::RegisterTx(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody,\n+    NTabletFlatExecutor::TTransactionContext& txc) {\n     NIceDb::TNiceDb db(txc.DB);\n     auto& txInfo = txOperator->GetTxInfo();\n     AFL_VERIFY(txInfo.MaxStep == Max<ui64>());\n     AFL_VERIFY(Operators.emplace(txInfo.TxId, txOperator).second);\n \n     Schema::SaveTxInfo(db, txInfo, txBody);\n+    Counters.OnRegisterTx(txOperator->GetOpType());\n     return txInfo;\n }\n \n-TTxController::TTxInfo TTxController::RegisterTxWithDeadline(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc) {\n+TTxController::TTxInfo TTxController::RegisterTxWithDeadline(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator,\n+    const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc) {\n     NIceDb::TNiceDb db(txc.DB);\n \n     auto& txInfo = txOperator->MutableTxInfo();\n@@ -137,22 +129,22 @@ TTxController::TTxInfo TTxController::RegisterTxWithDeadline(const std::shared_p\n \n     Schema::SaveTxInfo(db, txInfo, txBody);\n     DeadlineQueue.emplace(txInfo.MaxStep, txOperator->GetTxId());\n+    Counters.OnRegisterTx(txOperator->GetOpType());\n     return txInfo;\n }\n \n-bool TTxController::AbortTx(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n-    auto opIt = Operators.find(txId);\n+bool TTxController::AbortTx(const TPlanQueueItem planQueueItem, NTabletFlatExecutor::TTransactionContext& txc) {\n+    auto opIt = Operators.find(planQueueItem.TxId);\n     Y_ABORT_UNLESS(opIt != Operators.end());\n     Y_ABORT_UNLESS(opIt->second->GetTxInfo().PlanStep == 0);\n     opIt->second->ExecuteOnAbort(Owner, txc);\n     opIt->second->CompleteOnAbort(Owner, NActors::TActivationContext::AsActorContext());\n+    Counters.OnAbortTx(opIt->second->GetOpType());\n \n-    if (opIt->second->GetTxInfo().MaxStep != Max<ui64>()) {\n-        DeadlineQueue.erase(TPlanQueueItem(opIt->second->GetTxInfo().MaxStep, txId));\n-    }\n-    Operators.erase(txId);\n+    AFL_VERIFY(Operators.erase(planQueueItem.TxId));\n+    AFL_VERIFY(DeadlineQueue.erase(planQueueItem));\n     NIceDb::TNiceDb db(txc.DB);\n-    Schema::EraseTxInfo(db, txId);\n+    Schema::EraseTxInfo(db, planQueueItem.TxId);\n     return true;\n }\n \n@@ -191,7 +183,14 @@ bool TTxController::ExecuteOnCancel(const ui64 txId, NTabletFlatExecutor::TTrans\n     return true;\n }\n \n-std::optional<TTxController::TTxInfo> TTxController::StartPlannedTx() {\n+std::optional<TTxController::TTxInfo> TTxController::GetFirstPlannedTx() const {\n+    if (!PlanQueue.empty()) {\n+        return GetTxInfoVerified(PlanQueue.begin()->TxId);\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<TTxController::TTxInfo> TTxController::PopFirstPlannedTx() {\n     if (!PlanQueue.empty()) {\n         auto node = PlanQueue.extract(PlanQueue.begin());\n         auto& item = node.value();\n@@ -202,13 +201,16 @@ std::optional<TTxController::TTxInfo> TTxController::StartPlannedTx() {\n     return std::nullopt;\n }\n \n-void TTxController::FinishPlannedTx(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n+void TTxController::ProgressOnExecute(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n     NIceDb::TNiceDb db(txc.DB);\n+    auto opIt = Operators.find(txId);\n+    AFL_VERIFY(opIt != Operators.end())(\"tx_id\", txId);\n+    Counters.OnFinishPlannedTx(opIt->second->GetOpType());\n+    AFL_VERIFY(Operators.erase(txId));\n     Schema::EraseTxInfo(db, txId);\n }\n \n-void TTxController::CompleteRunningTx(const TPlanQueueItem& txItem) {\n-    AFL_VERIFY(Operators.erase(txItem.TxId));\n+void TTxController::ProgressOnComplete(const TPlanQueueItem& txItem) {\n     AFL_VERIFY(RunningQueue.erase(txItem))(\"info\", txItem.DebugString());\n }\n \n@@ -252,7 +254,7 @@ size_t TTxController::CleanExpiredTxs(NTabletFlatExecutor::TTransactionContext&\n             }\n             ui64 txId = it->TxId;\n             LOG_S_DEBUG(TStringBuilder() << \"Removing outdated txId \" << txId << \" max step \" << it->Step << \" outdated step \");\n-            AbortTx(txId, txc);\n+            AbortTx(*it, txc);\n             ++removedCount;\n         }\n     }\n@@ -275,7 +277,10 @@ TDuration TTxController::GetTxCompleteLag(ui64 timecastStep) const {\n TTxController::EPlanResult TTxController::PlanTx(const ui64 planStep, const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n     auto it = Operators.find(txId);\n     if (it == Operators.end()) {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_plan_tx\")(\"tx_id\", txId);\n         return EPlanResult::Skipped;\n+    } else {\n+        AFL_TRACE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"plan_tx\")(\"tx_id\", txId)(\"plan_step\", it->second->MutableTxInfo().PlanStep);\n     }\n     auto& txInfo = it->second->MutableTxInfo();\n     if (txInfo.PlanStep == 0) {\n@@ -292,6 +297,8 @@ TTxController::EPlanResult TTxController::PlanTx(const ui64 planStep, const ui64\n }\n \n void TTxController::OnTabletInit() {\n+    AFL_VERIFY(!StartedFlag);\n+    StartedFlag = true;\n     for (auto&& txOperator : Operators) {\n         txOperator.second->OnTabletInit(Owner);\n     }\n@@ -299,22 +306,24 @@ void TTxController::OnTabletInit() {\n \n std::shared_ptr<TTxController::ITransactionOperator> TTxController::StartProposeOnExecute(\n     const TTxController::TTxInfo& txInfo, const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc) {\n-    NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::StartProposeOnExecute\")(\n-        \"tx_info\", txInfo.DebugString())(\"tx_info\", txInfo.DebugString());\n+    NActors::TLogContextGuard lGuard =\n+        NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::StartProposeOnExecute\")(\"tx_info\", txInfo.DebugString());\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start\");\n-    std::shared_ptr<TTxController::ITransactionOperator> txOperator(TTxController::ITransactionOperator::TFactory::Construct(txInfo.TxKind, txInfo));\n+    std::shared_ptr<TTxController::ITransactionOperator> txOperator(\n+        TTxController::ITransactionOperator::TFactory::Construct(txInfo.TxKind, txInfo));\n     AFL_VERIFY(!!txOperator);\n     if (!txOperator->Parse(Owner, txBody)) {\n         AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot parse txOperator\");\n         return txOperator;\n     }\n+    Counters.OnStartProposeOnExecute(txOperator->GetOpType());\n \n     auto txInfoPtr = GetTxInfo(txInfo.TxId);\n     if (!!txInfoPtr) {\n         if (!txOperator->CheckAllowUpdate(*txInfoPtr)) {\n             AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"incorrect duplication\")(\"actual_tx\", txInfoPtr->DebugString());\n-            TTxController::TProposeResult proposeResult(\n-                NKikimrTxColumnShard::EResultStatus::ERROR, TStringBuilder() << \"Another commit TxId# \" << txInfo.TxId << \" has already been proposed\");\n+            TTxController::TProposeResult proposeResult(NKikimrTxColumnShard::EResultStatus::ERROR,\n+                TStringBuilder() << \"Another commit TxId# \" << txInfo.TxId << \" has already been proposed\");\n             txOperator->SetProposeStartInfo(proposeResult);\n             return txOperator;\n         } else {\n@@ -337,52 +346,48 @@ std::shared_ptr<TTxController::ITransactionOperator> TTxController::StartPropose\n     }\n }\n \n-void TTxController::StartProposeOnComplete(const ui64 txId, const TActorContext& ctx) {\n-    NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::StartProposeOnComplete\")(\"tx_id\", txId);\n-    auto txOperator = GetTxOperator(txId);\n-    if (!txOperator) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot found txOperator in propose transaction base\")(\"tx_id\", txId);\n-    } else {\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start\");\n-        txOperator->StartProposeOnComplete(Owner, ctx);\n-    }\n+void TTxController::StartProposeOnComplete(ITransactionOperator& txOperator, const TActorContext& ctx) {\n+    NActors::TLogContextGuard lGuard =\n+        NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::StartProposeOnComplete\")(\"tx_id\", txOperator.GetTxId());\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start\");\n+    txOperator.StartProposeOnComplete(Owner, ctx);\n+    Counters.OnStartProposeOnComplete(txOperator.GetOpType());\n }\n \n void TTxController::FinishProposeOnExecute(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc) {\n     NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::FinishProposeOnExecute\")(\"tx_id\", txId);\n-    auto txOperator = GetTxOperator(txId);\n-    if (!txOperator) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot found txOperator in propose transaction base\")(\"tx_id\", txId);\n-    } else {\n+    if (auto txOperator = GetTxOperatorOptional(txId)) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start\");\n         txOperator->FinishProposeOnExecute(Owner, txc);\n+        Counters.OnFinishProposeOnExecute(txOperator->GetOpType());\n+    } else {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot found txOperator in propose transaction base\")(\"tx_id\", txId);\n     }\n }\n \n+void TTxController::FinishProposeOnComplete(ITransactionOperator& txOperator, const TActorContext& ctx) {\n+    NActors::TLogContextGuard lGuard =\n+        NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::FinishProposeOnComplete\")(\"tx_id\", txOperator.GetTxId());\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start\")(\"tx_info\", txOperator.GetTxInfo().DebugString());\n+    TTxController::TProposeResult proposeResult = txOperator.GetProposeStartInfoVerified();\n+    AFL_VERIFY(!txOperator.IsFail());\n+    txOperator.FinishProposeOnComplete(Owner, ctx);\n+    txOperator.SendReply(Owner, ctx);\n+    Counters.OnFinishProposeOnComplete(txOperator.GetOpType());\n+}\n+\n void TTxController::FinishProposeOnComplete(const ui64 txId, const TActorContext& ctx) {\n-    NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"method\", \"TTxController::FinishProposeOnComplete\")(\"tx_id\", txId);\n-    auto txOperator = GetTxOperator(txId);\n+    auto txOperator = GetTxOperatorOptional(txId);\n     if (!txOperator) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot found txOperator in propose transaction finish\")(\"tx_id\", txId);\n         return;\n     }\n-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"start\")(\"tx_info\", txOperator->GetTxInfo().DebugString());\n-    TTxController::TProposeResult proposeResult = txOperator->GetProposeStartInfoVerified();\n-    AFL_VERIFY(!txOperator->IsFail());\n-    txOperator->FinishProposeOnComplete(Owner, ctx);\n-    txOperator->SendReply(Owner, ctx);\n-}\n-\n-void TTxController::StartOperators() {\n-    AFL_VERIFY(!StartedFlag);\n-    StartedFlag = true;\n-    for (auto&& i : Operators) {\n-        Y_UNUSED(i.second->OnStartAsync(Owner));\n-    }\n+    return FinishProposeOnComplete(*txOperator, ctx);\n }\n \n void TTxController::ITransactionOperator::SwitchStateVerified(const EStatus from, const EStatus to) {\n-    AFL_VERIFY(!Status || *Status == from)(\"error\", \"incorrect expected status\")(\"real_state\", *Status)(\"expected\", from)(\"details\", DebugString());\n+    AFL_VERIFY(!Status || *Status == from)(\"error\", \"incorrect expected status\")(\"real_state\", *Status)(\"expected\", from)(\n+                              \"details\", DebugString());\n     Status = to;\n }\n \ndiff --git a/ydb/core/tx/columnshard/transactions/tx_controller.h b/ydb/core/tx/columnshard/transactions/tx_controller.h\nindex 40cef7c84099..e48f10d3796d 100644\n--- a/ydb/core/tx/columnshard/transactions/tx_controller.h\n+++ b/ydb/core/tx/columnshard/transactions/tx_controller.h\n@@ -1,11 +1,14 @@\n #pragma once\n \n-#include <ydb/core/tx/columnshard/columnshard_schema.h>\n-\n #include <ydb/core/tablet_flat/tablet_flat_executed.h>\n+#include <ydb/core/tx/columnshard/columnshard_schema.h>\n+#include <ydb/core/tx/columnshard/counters/columnshard.h>\n #include <ydb/core/tx/data_events/events.h>\n #include <ydb/core/tx/message_seqno.h>\n \n+namespace NKikimr::NOlap::NTxInteractions {\n+class TManager;\n+}\n \n namespace NKikimr::NColumnShard {\n \n@@ -14,10 +17,12 @@ class TColumnShard;\n struct TBasicTxInfo {\n     const NKikimrTxColumnShard::ETransactionKind TxKind;\n     const ui64 TxId;\n+\n public:\n     TBasicTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId)\n         : TxKind(txKind)\n         , TxId(txId) {\n+        AFL_VERIFY(txKind != NKikimrTxColumnShard::TX_KIND_NONE);\n     }\n \n     bool operator==(const TBasicTxInfo& item) const = default;\n@@ -42,12 +47,18 @@ struct TFullTxInfo: public TBasicTxInfo {\n     TActorId Source;\n     ui64 Cookie = 0;\n     std::optional<TMessageSeqNo> SeqNo;\n+\n public:\n+    static TFullTxInfo BuildFake(const NKikimrTxColumnShard::ETransactionKind kind) {\n+        return TFullTxInfo(kind, 0, NActors::TActorId(), 0, {});\n+    }\n+\n     bool operator==(const TFullTxInfo& item) const = default;\n \n     TString DebugString() const {\n         TStringBuilder sb;\n-        sb << TBase::DebugString() << \";min=\" << MinStep << \";max=\" << MaxStep << \";plan=\" << PlanStep << \";src=\" << Source << \";cookie=\" << Cookie;\n+        sb << TBase::DebugString() << \";min=\" << MinStep << \";max=\" << MaxStep << \";plan=\" << PlanStep << \";src=\" << Source\n+           << \";cookie=\" << Cookie;\n         if (SeqNo) {\n             sb << *SeqNo << \";\";\n         }\n@@ -75,12 +86,12 @@ struct TFullTxInfo: public TBasicTxInfo {\n         : TBasicTxInfo(txKind, txId) {\n     }\n \n-    TFullTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId, const TActorId& source, const ui64 cookie, const std::optional<TMessageSeqNo>& seqNo)\n+    TFullTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId, const TActorId& source, const ui64 cookie,\n+        const std::optional<TMessageSeqNo>& seqNo)\n         : TBasicTxInfo(txKind, txId)\n         , Source(source)\n         , Cookie(cookie)\n-        , SeqNo(seqNo)\n-    {\n+        , SeqNo(seqNo) {\n     }\n };\n \n@@ -89,6 +100,7 @@ class TTxProposeResult {\n     class TProposeResult {\n         YDB_READONLY(NKikimrTxColumnShard::EResultStatus, Status, NKikimrTxColumnShard::EResultStatus::PREPARED);\n         YDB_READONLY_DEF(TString, StatusMessage);\n+\n     public:\n         TProposeResult() = default;\n         TProposeResult(NKikimrTxColumnShard::EResultStatus status, const TString& statusMessage)\n@@ -109,16 +121,15 @@ class TTxProposeResult {\n     std::optional<TBasicTxInfo> BaseTxInfo;\n     std::optional<TFullTxInfo> FullTxInfo;\n     TProposeResult ProposeResult;\n+\n public:\n     TTxProposeResult(const TBasicTxInfo& txInfo, TProposeResult&& result)\n         : BaseTxInfo(txInfo)\n         , ProposeResult(std::move(result)) {\n-\n     }\n     TTxProposeResult(const TFullTxInfo& txInfo, TProposeResult&& result)\n         : FullTxInfo(txInfo)\n         , ProposeResult(std::move(result)) {\n-\n     }\n \n     ui64 GetTxId() const noexcept {\n@@ -152,8 +163,8 @@ class TTxController {\n \n         TPlanQueueItem(const ui64 step, const ui64 txId)\n             : Step(step)\n-            , TxId(txId)\n-        {}\n+            , TxId(txId) {\n+        }\n \n         inline bool operator<(const TPlanQueueItem& rhs) const {\n             return Step < rhs.Step || (Step == rhs.Step && TxId < rhs.TxId);\n@@ -180,10 +191,12 @@ class TTxController {\n             ReplySent,\n             Failed\n         };\n+\n     protected:\n         TTxInfo TxInfo;\n         YDB_READONLY_DEF(std::optional<TTxController::TProposeResult>, ProposeStartInfo);\n         std::optional<EStatus> Status = EStatus::Created;\n+\n     private:\n         friend class TTxController;\n         virtual bool DoParse(TColumnShard& owner, const TString& data) = 0;\n@@ -191,41 +204,48 @@ class TTxController {\n         virtual void DoStartProposeOnComplete(TColumnShard& owner, const TActorContext& ctx) = 0;\n         virtual void DoFinishProposeOnExecute(TColumnShard& owner, NTabletFlatExecutor::TTransactionContext& txc) = 0;\n         virtual void DoFinishProposeOnComplete(TColumnShard& owner, const TActorContext& ctx) = 0;\n+        virtual TString DoGetOpType() const = 0;\n         virtual bool DoIsAsync() const = 0;\n         virtual void DoSendReply(TColumnShard& owner, const TActorContext& ctx) = 0;\n         virtual bool DoCheckAllowUpdate(const TFullTxInfo& currentTxInfo) const = 0;\n         virtual bool DoCheckTxInfoForReply(const TFullTxInfo& /*originalTxInfo*/) const {\n             return true;\n         }\n+        virtual bool DoPingTimeout(TColumnShard& /*owner*/, const TMonotonic /*now*/) {\n+            return false;\n+        }\n+\n+        virtual std::unique_ptr<NTabletFlatExecutor::ITransaction> DoBuildTxPrepareForProgress(TColumnShard* /*owner*/) const {\n+            return nullptr;\n+        }\n \n         void SwitchStateVerified(const EStatus from, const EStatus to);\n         TTxInfo& MutableTxInfo() {\n             return TxInfo;\n         }\n \n+        virtual void DoOnTabletInit(TColumnShard& /*owner*/) {\n+        }\n+\n         void ResetStatusOnUpdate() {\n             Status = {};\n         }\n \n         virtual TString DoDebugString() const = 0;\n-        virtual bool DoOnStartAsync(TColumnShard& /*owner*/) {\n-            return false;\n-        }\n \n         std::optional<bool> StartedAsync;\n \n     public:\n         using TPtr = std::shared_ptr<ITransactionOperator>;\n         using TFactory = NObjectFactory::TParametrizedObjectFactory<ITransactionOperator, NKikimrTxColumnShard::ETransactionKind, TTxInfo>;\n+        using OpType = TString;\n \n-        bool CheckTxInfoForReply(const TFullTxInfo& originalTxInfo) const {\n-            return DoCheckTxInfoForReply(originalTxInfo);\n+        bool PingTimeout(TColumnShard& owner, const TMonotonic now) {\n+            return DoPingTimeout(owner, now);\n         }\n \n-        [[nodiscard]] bool OnStartAsync(TColumnShard& owner) {\n-            AFL_VERIFY(!StartedAsync);\n-            StartedAsync = DoOnStartAsync(owner);\n-            return *StartedAsync;\n+        bool CheckTxInfoForReply(const TFullTxInfo& originalTxInfo) const {\n+            return DoCheckTxInfoForReply(originalTxInfo);\n         }\n \n         TString DebugString() const {\n@@ -236,6 +256,10 @@ class TTxController {\n             return DoCheckAllowUpdate(currentTxInfo);\n         }\n \n+        std::unique_ptr<NTabletFlatExecutor::ITransaction> BuildTxPrepareForProgress(TColumnShard* owner) const {\n+            return DoBuildTxPrepareForProgress(owner);\n+        }\n+\n         bool IsFail() const {\n             return ProposeStartInfo && ProposeStartInfo->IsFail();\n         }\n@@ -258,18 +282,23 @@ class TTxController {\n         }\n \n         ITransactionOperator(const TTxInfo& txInfo)\n-            : TxInfo(txInfo)\n-        {}\n+            : TxInfo(txInfo) {\n+        }\n \n         ui64 GetTxId() const {\n             return TxInfo.TxId;\n         }\n \n+        OpType GetOpType() const {\n+            return DoGetOpType();\n+        }\n+\n         bool IsAsync() const {\n             return DoIsAsync() && Status != EStatus::Failed && Status != EStatus::ReplySent;\n         }\n \n-        virtual ~ITransactionOperator() {}\n+        virtual ~ITransactionOperator() {\n+        }\n \n         virtual bool TxWithDeadline() const {\n             return true;\n@@ -279,14 +308,15 @@ class TTxController {\n             const bool result = DoParse(owner, data);\n             if (!result) {\n                 AFL_VERIFY(!onLoad);\n-                ProposeStartInfo = TTxController::TProposeResult(NKikimrTxColumnShard::EResultStatus::ERROR, TStringBuilder() << \"Error processing commit TxId# \" << TxInfo.TxId\n-                    << \". Parsing error\");\n+                ProposeStartInfo = TTxController::TProposeResult(NKikimrTxColumnShard::EResultStatus::ERROR,\n+                    TStringBuilder() << \"Error processing commit TxId# \" << TxInfo.TxId << \". Parsing error\");\n                 SwitchStateVerified(EStatus::Created, EStatus::Failed);\n             } else {\n                 SwitchStateVerified(EStatus::Created, EStatus::Parsed);\n             }\n             if (onLoad) {\n-                ProposeStartInfo = TTxController::TProposeResult(NKikimrTxColumnShard::EResultStatus::PREPARED, \"success on iteration before restart\");\n+                ProposeStartInfo =\n+                    TTxController::TProposeResult(NKikimrTxColumnShard::EResultStatus::PREPARED, \"success on iteration before restart\");\n                 Status = {};\n             }\n             return result;\n@@ -345,8 +375,15 @@ class TTxController {\n         virtual void RegisterSubscriber(const TActorId&) {\n             AFL_VERIFY(false)(\"message\", \"Not implemented\");\n         };\n-        virtual void OnTabletInit(TColumnShard& /*owner*/) {}\n+        void OnTabletInit(TColumnShard& owner) {\n+            AFL_VERIFY(!StartedAsync);\n+            StartedAsync = true;\n+            DoOnTabletInit(owner);\n+        }\n     };\n+    TTxProgressCounters& GetCounters() {\n+        return Counters;\n+    }\n \n private:\n     const TDuration MaxCommitTxDelay = TDuration::Seconds(30);\n@@ -354,44 +391,75 @@ class TTxController {\n     std::set<TPlanQueueItem> DeadlineQueue;\n     std::set<TPlanQueueItem> PlanQueue;\n     std::set<TPlanQueueItem> RunningQueue;\n+    TTxProgressCounters Counters;\n \n     THashMap<ui64, ITransactionOperator::TPtr> Operators;\n-\n private:\n     ui64 GetAllowedStep() const;\n-    bool AbortTx(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n+    bool AbortTx(const TPlanQueueItem planQueueItem, NTabletFlatExecutor::TTransactionContext& txc);\n \n-    TTxInfo RegisterTx(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc);\n-    TTxInfo RegisterTxWithDeadline(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc);\n+    TTxInfo RegisterTx(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody,\n+        NTabletFlatExecutor::TTransactionContext& txc);\n+    TTxInfo RegisterTxWithDeadline(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody,\n+        NTabletFlatExecutor::TTransactionContext& txc);\n     bool StartedFlag = false;\n+\n public:\n     TTxController(TColumnShard& owner);\n \n-    ITransactionOperator::TPtr GetTxOperator(const ui64 txId) const;\n-    ITransactionOperator::TPtr GetVerifiedTxOperator(const ui64 txId) const;\n-    void StartOperators();\n+    ITransactionOperator::TPtr GetTxOperatorOptional(const ui64 txId) const {\n+        auto it = Operators.find(txId);\n+        if (it == Operators.end()) {\n+            return nullptr;\n+        }\n+        return it->second;\n+    }\n+    ITransactionOperator::TPtr GetTxOperatorVerified(const ui64 txId) const {\n+        return TValidator::CheckNotNull(GetTxOperatorOptional(txId));\n+    }\n+    template <class TExpectedTransactionOperator>\n+    std::shared_ptr<TExpectedTransactionOperator> GetTxOperatorVerifiedAs(const ui64 txId) const {\n+        auto result = GetTxOperatorOptional(txId);\n+        AFL_VERIFY(result);\n+        auto resultClass = dynamic_pointer_cast<TExpectedTransactionOperator>(result);\n+        AFL_VERIFY(resultClass);\n+        return resultClass;\n+    }\n+\n+    void PingTimeouts(const TMonotonic now) {\n+        auto txInfo = GetFirstPlannedTx();\n+        if (!txInfo) {\n+            return;\n+        }\n+        GetTxOperatorVerified(txInfo->GetTxId())->PingTimeout(Owner, now);\n+    }\n \n     ui64 GetMemoryUsage() const;\n     bool HaveOutdatedTxs() const;\n \n     bool Load(NTabletFlatExecutor::TTransactionContext& txc);\n \n-    [[nodiscard]] std::shared_ptr<TTxController::ITransactionOperator> UpdateTxSourceInfo(const TFullTxInfo& tx, NTabletFlatExecutor::TTransactionContext& txc);\n+    [[nodiscard]] std::shared_ptr<TTxController::ITransactionOperator> UpdateTxSourceInfo(\n+        const TFullTxInfo& tx, NTabletFlatExecutor::TTransactionContext& txc);\n \n     [[nodiscard]] std::shared_ptr<TTxController::ITransactionOperator> StartProposeOnExecute(\n         const TTxController::TTxInfo& txInfo, const TString& txBody, NTabletFlatExecutor::TTransactionContext& txc);\n-    void StartProposeOnComplete(const ui64 txId, const TActorContext& ctx);\n-\n+    void StartProposeOnComplete(ITransactionOperator& txOperator, const TActorContext& ctx);\n     void FinishProposeOnExecute(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n-\n+    void FinishProposeOnComplete(ITransactionOperator& txOperator, const TActorContext& ctx);\n     void FinishProposeOnComplete(const ui64 txId, const TActorContext& ctx);\n \n+    void WriteTxOperatorInfo(NTabletFlatExecutor::TTransactionContext& txc, const ui64 txId, const TString& data) {\n+        NIceDb::TNiceDb db(txc.DB);\n+        NColumnShard::Schema::UpdateTxInfoBody(db, txId, data);\n+    }\n     bool ExecuteOnCancel(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n     bool CompleteOnCancel(const ui64 txId, const TActorContext& ctx);\n \n-    std::optional<TTxInfo> StartPlannedTx();\n-    void FinishPlannedTx(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n-    void CompleteRunningTx(const TPlanQueueItem& tx);\n+    std::optional<TTxInfo> GetFirstPlannedTx() const;\n+    std::optional<TTxInfo> PopFirstPlannedTx();\n+    void ProgressOnExecute(const ui64 txId, NTabletFlatExecutor::TTransactionContext& txc);\n+    void ProgressOnComplete(const TPlanQueueItem& tx);\n \n     std::optional<TPlanQueueItem> GetPlannedTx() const;\n     TPlanQueueItem GetFrontTx() const;\n@@ -412,5 +480,4 @@ class TTxController {\n     void OnTabletInit();\n };\n \n-}\n-\n+}   // namespace NKikimr::NColumnShard\ndiff --git a/ydb/core/tx/columnshard/transactions/ya.make b/ydb/core/tx/columnshard/transactions/ya.make\nindex 8479005c4d67..c6509a2a6473 100644\n--- a/ydb/core/tx/columnshard/transactions/ya.make\n+++ b/ydb/core/tx/columnshard/transactions/ya.make\n@@ -11,6 +11,7 @@ PEERDIR(\n     ydb/core/tx/columnshard/data_sharing/destination/events\n     ydb/core/tx/columnshard/transactions/operators\n     ydb/core/tx/columnshard/transactions/transactions\n+    ydb/core/tx/columnshard/transactions/locks\n )\n \n YQL_LAST_ABI_VERSION()\ndiff --git a/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp b/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp\nindex 700ed7157f15..ad5ec1f688fd 100644\n--- a/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp\n+++ b/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp\n@@ -14,11 +14,11 @@\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n #include <ydb/core/tx/columnshard/test_helper/controllers.h>\n-#include <ydb/core/tx/columnshard/common/tests/shard_reader.h>\n+#include <ydb/core/tx/columnshard/test_helper/shard_reader.h>\n #include <ydb/library/actors/protos/unittests.pb.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n #include <util/string/join.h>\n \n namespace NKikimr {\n@@ -35,12 +35,6 @@ using TTypeId = NScheme::TTypeId;\n using TTypeInfo = NScheme::TTypeInfo;\n \n using TDefaultTestsController = NKikimr::NYDBTest::NColumnShard::TController;\n-class TDisableCompactionController: public NKikimr::NYDBTest::NColumnShard::TController {\n-public:\n-    TDisableCompactionController() {\n-        DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n-    }\n-};\n \n template <typename TKey = ui64>\n bool DataHas(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, std::pair<ui64, ui64> range,\n@@ -538,7 +532,7 @@ void TestWriteReadDup(const TestTableDescription& table = {}) {\n \n         // read\n         if (planStep != initPlanStep) {\n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n             reader.SetReplyColumns({\"timestamp\"});\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -597,7 +591,7 @@ void TestWriteReadLongTxDup() {\n     // read\n     TAutoPtr<IEventHandle> handle;\n     {\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -612,7 +606,9 @@ void TestWriteReadLongTxDup() {\n }\n \n void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString codec = \"\") {\n-    auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDisableCompactionController>();\n+    auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();\n+    csControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+    csControllerGuard->SetOverrideReadTimeoutClean(TDuration::Max());\n     TTestBasicRuntime runtime;\n     TTester::Setup(runtime);\n \n@@ -681,7 +677,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 1);\n \n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(0, 0));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(0, 1));\n         reader.SetReplyColumns({\"resource_type\"});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -698,7 +694,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 2);\n \n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(0, 0));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(0, 1));\n         reader.SetReplyColumns({\"resource_type\"});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -708,7 +704,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 3 (committed)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 3);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -723,7 +719,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 4 (column by id)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 4);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumnIds({1});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -738,7 +734,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n \n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 5);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumns({\"timestamp\", \"message\"});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -776,7 +772,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 6, planstep 0\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 6);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(0, 0));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(0, 1));\n         reader.SetReplyColumns({\"timestamp\", \"message\"});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(!rb);\n@@ -786,7 +782,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 7, planstep 21 (part of index)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 7);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(21, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(21, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -803,7 +799,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 8, planstep 22 (full index)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 8);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(22, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(22, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -833,7 +829,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 9 (committed, indexed)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 9);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(23, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(23, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -858,7 +854,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 10\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 10);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -878,8 +874,8 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n         const ui64 committedBytes = reader.GetReadStat(\"committed_bytes\");\n         Cerr << codec << \"/\" << compactedBytes << \"/\" << insertedBytes << \"/\" << committedBytes << Endl;\n         if (insertedBytes) {\n-            UNIT_ASSERT_GE(insertedBytes / 100000, 40);\n-            UNIT_ASSERT_LE(insertedBytes / 100000, 50);\n+            UNIT_ASSERT_GE(insertedBytes / 100000, 50);\n+            UNIT_ASSERT_LE(insertedBytes / 100000, 60);\n         }\n         if (committedBytes) {\n             UNIT_ASSERT_LE(committedBytes / 100000, 1);\n@@ -904,7 +900,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 11 (range predicate: closed interval)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 11);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         reader.AddRange(MakeTestRange({10, 42}, true, true, testYdbPk));\n         auto rb = reader.ReadAll();\n@@ -921,7 +917,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 12 (range predicate: open interval)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 11);\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n         reader.SetReplyColumns(TTestSchema::ExtractNames(ydbSchema));\n         reader.AddRange(MakeTestRange({10, 42}, false, false, testYdbPk));\n         auto rb = reader.ReadAll();\n@@ -1034,7 +1030,7 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table\n     --txId;\n \n     for (ui32 i = 0; i < 2; ++i) {\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumns({\"timestamp\", \"message\"});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -1279,7 +1275,7 @@ void TestReadWithProgram(const TestTableDescription& table = {})\n \n     ui32 i = 0;\n     for (auto& programText : programs) {\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetProgram(programText);\n         auto rb = reader.ReadAll();\n         if (i < numWrong) {\n@@ -1348,7 +1344,7 @@ void TestReadWithProgramLike(const TestTableDescription& table = {}) {\n \n     ui32 i = 0;\n     for (auto& ssa : ssas) {\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetProgram(ssa);\n         auto rb = reader.ReadAll();\n \n@@ -1420,7 +1416,7 @@ void TestSomePrograms(const TestTableDescription& table) {\n     // TODO: add programs with bugs here\n \n     for (auto& ssaText : programs) {\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetProgram(ssaText);\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsError());\n@@ -1530,7 +1526,7 @@ void TestReadAggregate(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,\n     for (auto& programText : programs) {\n         Cerr << \"-- select program: \" << prog << \" is filtered: \" << (int)isFiltered.count(prog) << \"\\n\";\n \n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetProgram(programText);\n         auto batch = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -1890,7 +1886,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n             reader.SetReplyColumns({ \"timestamp\" });\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -1905,7 +1901,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n             reader.SetReplyColumns({ \"timestamp\" });\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -1921,7 +1917,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n             reader.SetReplyColumns({ \"timestamp\" });\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -1937,7 +1933,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n             reader.SetReplyColumns({ \"timestamp\" });\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -1958,7 +1954,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n             reader.SetReplyColumns({ \"timestamp\" });\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -2239,7 +2235,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n                 const ui64 tableId = 1;\n                 std::set<TString> useFields = {\"timestamp\", \"message\"};\n                 { // read with predicate (FROM)\n-                    NOlap::NTests::TShardReader reader(Owner.Runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(Owner.PlanStep, Owner.TxId));\n+                    TShardReader reader(Owner.Runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(Owner.PlanStep, Owner.TxId));\n                     reader.SetReplyColumns({\"timestamp\", \"message\"});\n                     reader.AddRange(MakeRange(Owner.YdbPk));\n                     auto rb = reader.ReadAll();\n@@ -2334,7 +2330,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n \n         for (ui32 i = 0; i < 2; ++i) {\n             {\n-                NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+                TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n                 reader.SetReplyColumns({\"timestamp\", \"message\"});\n                 auto rb = reader.ReadAll();\n                 UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -2440,7 +2436,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n                     ui64 numRows = static_cast<arrow::UInt64Array&>(*rows).Value(i);\n                     ui64 numBytes = static_cast<arrow::UInt64Array&>(*bytes).Value(i);\n                     ui64 numRawBytes = static_cast<arrow::UInt64Array&>(*rawBytes).Value(i);\n-                    bool activity = static_cast<arrow::BooleanArray&>(*activities).Value(i);\n+                    bool activity = static_cast<arrow::UInt8Array&>(*activities).Value(i);\n                     if (!activity) {\n                         continue;\n                     }\n@@ -2584,7 +2580,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n \n         // Try to read snapshot that is too old\n         {\n-            NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - staleness.MilliSeconds(), Max<ui64>()));\n+            TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - staleness.MilliSeconds(), Max<ui64>()));\n             reader.SetReplyColumns({\"timestamp\", \"message\"});\n             reader.ReadAll();\n             UNIT_ASSERT(reader.IsError());\n@@ -2594,8 +2590,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n \n     void TestCompactionGC() {\n         TTestBasicRuntime runtime;\n-        TTester::Setup(runtime);\n         auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();\n+        csDefaultControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n+        csDefaultControllerGuard->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        TTester::Setup(runtime);\n \n         runtime.SetLogPriority(NKikimrServices::BLOB_CACHE, NActors::NLog::PRI_INFO);\n \n@@ -2753,7 +2751,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         --planStep;\n         --txId;\n         Cerr << compactionsHappened << Endl;\n-        UNIT_ASSERT_GE(compactionsHappened, 3); // we catch it three times per action\n+//        UNIT_ASSERT_GE(compactionsHappened, 3); // we catch it three times per action\n \n         ui64 previousCompactionsHappened = compactionsHappened;\n         ui64 previousCleanupsHappened = cleanupsHappened;\n@@ -2761,12 +2759,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         // Send a request that reads the latest version\n         // This request is expected to read at least 1 committed blob and several index portions\n         // These committed blob and portions must not be deleted by the BlobManager until the read request finishes\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n         reader.SetReplyColumns({\"timestamp\", \"message\"});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n         UNIT_ASSERT(CheckOrdered(rb));\n         UNIT_ASSERT(reader.GetIterationsCount() < 10);\n+        csDefaultControllerGuard->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Indexation);\n \n         // We captured EvReadFinished event and dropped is so the columnshard still thinks that\n         // read request is in progress and keeps the portions\n@@ -2782,15 +2781,21 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n+        {\n+            auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();\n+            ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());\n+        }\n \n-        Cerr << \"Compactions happened: \" << compactionsHappened << Endl;\n-        Cerr << \"Cleanups happened: \" << cleanupsHappened << Endl;\n+        Cerr << \"Compactions happened: \" << csDefaultControllerGuard->GetCompactionStartedCounter().Val() << Endl;\n+        Cerr << \"Indexations happened: \" << csDefaultControllerGuard->GetInsertStartedCounter().Val() << Endl;\n+        Cerr << \"Cleanups happened: \" << csDefaultControllerGuard->GetCleaningStartedCounter().Val() << Endl;\n         Cerr << \"Old portions: \" << JoinStrings(oldPortions.begin(), oldPortions.end(), \" \") << Endl;\n         Cerr << \"Cleaned up portions: \" << JoinStrings(deletedPortions.begin(), deletedPortions.end(), \" \") << Endl;\n+        Cerr << \"delayedBlobs: \" << JoinStrings(delayedBlobs.begin(), delayedBlobs.end(), \" \") << Endl;\n \n         // Check that GC happened but it didn't collect some old portions\n         UNIT_ASSERT_GT(compactionsHappened, previousCompactionsHappened);\n-        UNIT_ASSERT_GT(cleanupsHappened, previousCleanupsHappened);\n+        UNIT_ASSERT_EQUAL(cleanupsHappened, 0);\n         UNIT_ASSERT_GT_C(oldPortions.size(), deletedPortions.size(), \"Some old portions must not be deleted because the are in use by read\");\n         UNIT_ASSERT_GT_C(delayedBlobs.size(), 0, \"Read request is expected to have at least one committed blob, which deletion must be delayed\");\n         previousCompactionsHappened = compactionsHappened;\n@@ -2805,9 +2810,25 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         }\n \n         // Advance the time and trigger some more cleanups withno compactions\n-        auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDisableCompactionController>();\n-        planStep += 2 * delay.MilliSeconds();\n-        numWrites = 2;\n+        csDefaultControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n+        {\n+            auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();\n+            ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());\n+        }\n+        planStep += (2 * delay).MilliSeconds();\n+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+            std::vector<ui64> writeIds;\n+            UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n+\n+            ProposeCommit(runtime, sender, txId, writeIds);\n+            PlanCommit(runtime, sender, planStep, txId);\n+        }\n+        UNIT_ASSERT_EQUAL(cleanupsHappened, 0);\n+        csDefaultControllerGuard->SetOverrideRequestsTracePingCheckPeriod(TDuration::Zero());\n+        {\n+            auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();\n+            ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());\n+        }\n         for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n@@ -2815,9 +2836,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n+        AFL_VERIFY(csDefaultControllerGuard->GetRequestTracingSnapshotsSave().Val() == 1);\n+        AFL_VERIFY(csDefaultControllerGuard->GetRequestTracingSnapshotsRemove().Val() == 1);\n \n-        Cerr << \"Compactions happened: \" << compactionsHappened << Endl;\n-        Cerr << \"Cleanups happened: \" << cleanupsHappened << Endl;\n+        Cerr << \"Compactions happened: \" << csDefaultControllerGuard->GetCompactionStartedCounter().Val() << Endl;\n+        Cerr << \"Indexations happened: \" << csDefaultControllerGuard->GetInsertStartedCounter().Val() << Endl;\n+        Cerr << \"Cleanups happened: \" << csDefaultControllerGuard->GetCleaningStartedCounter().Val() << Endl;\n         Cerr << \"Old portions: \" << JoinStrings(oldPortions.begin(), oldPortions.end(), \" \") << Endl;\n         Cerr << \"Cleaned up portions: \" << JoinStrings(deletedPortions.begin(), deletedPortions.end(), \" \") << Endl;\n \n@@ -2825,7 +2849,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         UNIT_ASSERT_GE(compactionsHappened, previousCompactionsHappened);\n         UNIT_ASSERT_GT(cleanupsHappened, previousCleanupsHappened);\n         UNIT_ASSERT_VALUES_EQUAL_C(oldPortions.size(), deletedPortions.size(), \"All old portions must be deleted after read has finished\");\n-        UNIT_ASSERT_VALUES_EQUAL_C(delayedBlobs.size(), 0, \"All previously delayed deletions must now happen \" + JoinSeq(\",\", delayedBlobs));\n     }\n \n     Y_UNIT_TEST(CompactionGC) {\ndiff --git a/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp b/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp\nindex 68eecd9f7b73..734047952707 100644\n--- a/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp\n+++ b/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp\n@@ -7,9 +7,9 @@\n \n #include <ydb/core/tx/columnshard/operations/write_data.h>\n \n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n \n \n namespace NKikimr {\ndiff --git a/ydb/core/tx/columnshard/ut_rw/ya.make b/ydb/core/tx/columnshard/ut_rw/ya.make\nindex d03099069b75..7cf343aad4c6 100644\n--- a/ydb/core/tx/columnshard/ut_rw/ya.make\n+++ b/ydb/core/tx/columnshard/ut_rw/ya.make\n@@ -22,8 +22,6 @@ PEERDIR(\n     ydb/core/tx/columnshard/test_helper\n     ydb/core/tx/columnshard/hooks/abstract\n     ydb/core/tx/columnshard/hooks/testing\n-    ydb/core/tx/columnshard/common/tests\n-    ydb/core/tx/columnshard/test_helper\n     ydb/services/metadata\n     ydb/core/tx\n     ydb/public/lib/yson_value\ndiff --git a/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp b/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp\nindex cfc9ea9526b5..39673d15b071 100644\n--- a/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp\n+++ b/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp\n@@ -5,7 +5,7 @@\n #include <ydb/core/cms/console/configs_dispatcher.h>\n #include <ydb/core/tx/tx_proxy/proxy.h>\n #include <ydb/core/tx/schemeshard/schemeshard.h>\n-#include <ydb/core/tx/columnshard/common/tests/shard_reader.h>\n+#include <ydb/core/tx/columnshard/test_helper/shard_reader.h>\n #include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n #include <ydb/core/tx/columnshard/blobs_reader/actor.h>\n@@ -161,7 +161,7 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n {\n     auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n     csControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n-    csControllerGuard->SetTasksActualizationLag(TDuration::Zero());\n+    csControllerGuard->SetOverrideTasksActualizationLag(TDuration::Zero());\n     std::vector<ui64> ts = {1600000000, 1620000000};\n \n     ui32 ttlIncSeconds = 1;\n@@ -246,7 +246,7 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n \n     {\n         --planStep;\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n         reader.SetReplyColumns({spec.TtlColumn});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -278,7 +278,7 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n \n     {\n         --planStep;\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n         reader.SetReplyColumns({spec.TtlColumn, NOlap::TIndexInfo::SPEC_COL_PLAN_STEP});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -312,7 +312,7 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n \n     {\n         --planStep;\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n         reader.SetReplyColumns({spec.TtlColumn});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n@@ -513,7 +513,7 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt\n \n     auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n     csControllerGuard->DisableBackground(NYDBTest::ICSController::EBackground::TTL);\n-    csControllerGuard->SetTasksActualizationLag(TDuration::Zero());\n+    csControllerGuard->SetOverrideTasksActualizationLag(TDuration::Zero());\n     TTestBasicRuntime runtime;\n     TTester::Setup(runtime);\n \n@@ -621,9 +621,9 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt\n \n         // Read crossed with eviction (start)\n         {\n-            std::unique_ptr<NOlap::NTests::TShardReader> reader;\n+            std::unique_ptr<TShardReader> reader;\n             if (!misconfig) {\n-                reader = std::make_unique<NOlap::NTests::TShardReader>(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n+                reader = std::make_unique<TShardReader>(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n                 reader->SetReplyColumns({specs[i].TtlColumn});\n                 counter.CaptureReadEvents = specs[i].WaitEmptyAfter ? 0 : 1; // TODO: we need affected by tiering blob here\n                 counter.WaitReadsCaptured(runtime);\n@@ -662,7 +662,7 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt\n         // Read data after eviction\n         TString columnToRead = specs[i].TtlColumn;\n \n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n         reader.SetReplyColumns({columnToRead});\n         auto rb = reader.ReadAll();\n         if (expectedReadResult == EExpectedResult::ERROR) {\n@@ -981,7 +981,7 @@ void TestDrop(bool reboots) {\n     TAutoPtr<IEventHandle> handle;\n     {\n         --planStep;\n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n         reader.SetReplyColumns({TTestSchema::DefaultTtlColumn});\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\ndiff --git a/ydb/core/tx/columnshard/ya.make b/ydb/core/tx/columnshard/ya.make\nindex 716b6eae6174..f1f4df107ffe 100644\n--- a/ydb/core/tx/columnshard/ya.make\n+++ b/ydb/core/tx/columnshard/ya.make\n@@ -16,7 +16,6 @@ SRCS(\n     columnshard__write_index.cpp\n     columnshard.cpp\n     columnshard_impl.cpp\n-    columnshard_common.cpp\n     columnshard_private_events.cpp\n     columnshard_schema.cpp\n     columnshard_view.cpp\ndiff --git a/ydb/core/tx/data_events/columnshard_splitter.cpp b/ydb/core/tx/data_events/columnshard_splitter.cpp\nindex 5b435a0f9198..19a787167270 100644\n--- a/ydb/core/tx/data_events/columnshard_splitter.cpp\n+++ b/ydb/core/tx/data_events/columnshard_splitter.cpp\n@@ -66,9 +66,10 @@ NKikimr::NEvWrite::IShardsSplitter::TYdbConclusionStatus TColumnShardShardsSplit\n     }\n \n     TFullSplitData result(sharding->GetShardsCount());\n+    const TString schemaString = NArrow::SerializeSchema(*batch->schema());\n     for (auto&& [shardId, chunks] : split.GetResult()) {\n         for (auto&& c : chunks) {\n-            result.AddShardInfo(shardId, std::make_shared<TShardInfo>(c.GetSchemaData(), c.GetData(), c.GetRowsCount(), sharding->GetShardInfoVerified(shardId).GetShardingVersion()));\n+            result.AddShardInfo(shardId, std::make_shared<TShardInfo>(schemaString, c.GetData(), c.GetRowsCount(), sharding->GetShardInfoVerified(shardId).GetShardingVersion()));\n         }\n     }\n \ndiff --git a/ydb/core/tx/data_events/events.h b/ydb/core/tx/data_events/events.h\nindex d9f17beceec4..bd4f06284e9d 100644\n--- a/ydb/core/tx/data_events/events.h\n+++ b/ydb/core/tx/data_events/events.h\n@@ -103,6 +103,13 @@ struct TDataEvents {\n             return result;\n         }\n \n+        static std::unique_ptr<TEvWriteResult> BuildCompleted(const ui64 origin) {\n+            auto result = std::make_unique<TEvWriteResult>();\n+            result->Record.SetOrigin(origin);\n+            result->Record.SetStatus(NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n+            return result;\n+        }\n+\n         static std::unique_ptr<TEvWriteResult> BuildCompleted(const ui64 origin, const ui64 txId) {\n             auto result = std::make_unique<TEvWriteResult>();\n             result->Record.SetOrigin(origin);\n@@ -116,7 +123,9 @@ struct TDataEvents {\n             result->Record.SetOrigin(origin);\n             result->Record.SetTxId(txId);\n             result->Record.SetStatus(NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n-            *result->Record.AddTxLocks() = lock;\n+            auto& lockResult = *result->Record.AddTxLocks();\n+            lockResult = lock;\n+            lockResult.SetHasWrites(true);\n             return result;\n         }\n \ndiff --git a/ydb/core/tx/data_events/shard_writer.cpp b/ydb/core/tx/data_events/shard_writer.cpp\nindex 0158527fee49..7f935f5270cc 100644\n--- a/ydb/core/tx/data_events/shard_writer.cpp\n+++ b/ydb/core/tx/data_events/shard_writer.cpp\n@@ -18,19 +18,25 @@ namespace NKikimr::NEvWrite {\n \n     void TWritersController::OnSuccess(const ui64 shardId, const ui64 writeId, const ui32 writePartId) {\n         WriteIds[WritesIndex.Inc() - 1] = TWriteIdForShard(shardId, writeId, writePartId);\n+        Counters->OnCSReply(TMonotonic::Now() - StartInstant);\n         if (!WritesCount.Dec()) {\n-            auto req = MakeHolder<NLongTxService::TEvLongTxService::TEvAttachColumnShardWrites>(LongTxId);\n-            for (auto&& i : WriteIds) {\n-                req->AddWrite(i.GetShardId(), i.GetWriteId());\n-            }\n-            LongTxActorId.Send(NLongTxService::MakeLongTxServiceID(LongTxActorId.NodeId()), req.Release());\n+            SendReply();\n         }\n     }\n \n     void TWritersController::OnFail(const Ydb::StatusIds::StatusCode code, const TString& message) {\n-        NYql::TIssues issues;\n-        issues.AddIssue(message);\n-        LongTxActorId.Send(LongTxActorId, new TEvPrivate::TEvShardsWriteResult(code, issues));\n+        Counters->OnCSFailed(code);\n+        FailsCount.Inc();\n+        if (!Code) {\n+            TGuard<TMutex> g(Mutex);\n+            if (!Code) {\n+                Issues.AddIssue(message);\n+                Code = code;\n+            }\n+        }\n+        if (!WritesCount.Dec()) {\n+            SendReply();\n+        }\n     }\n \n     TShardWriter::TShardWriter(const ui64 shardId, const ui64 tableId, const TString& dedupId, const IShardInfo::TPtr& data,\n@@ -60,7 +66,7 @@ namespace NKikimr::NEvWrite {\n \n         const auto ydbStatus = msg->GetYdbStatus();\n         if (ydbStatus == Ydb::StatusIds::OVERLOADED) {\n-            if (RetryWriteRequest()) {\n+            if (RetryWriteRequest(true)) {\n                 return;\n             }\n         }\n@@ -81,7 +87,7 @@ namespace NKikimr::NEvWrite {\n         const auto* msg = ev->Get();\n         Y_ABORT_UNLESS(msg->TabletId == ShardId);\n \n-        if (RetryWriteRequest()) {\n+        if (RetryWriteRequest(true)) {\n             return;\n         }\n \n@@ -99,7 +105,7 @@ namespace NKikimr::NEvWrite {\n         RetryWriteRequest(false);\n     }\n \n-    bool TShardWriter::RetryWriteRequest(bool delayed) {\n+    bool TShardWriter::RetryWriteRequest(const bool delayed) {\n         if (NumRetries >= MaxRetriesPerShard) {\n             return false;\n         }\ndiff --git a/ydb/core/tx/data_events/shard_writer.h b/ydb/core/tx/data_events/shard_writer.h\nindex d7abe2e2a3ed..0a649a4dd3b9 100644\n--- a/ydb/core/tx/data_events/shard_writer.h\n+++ b/ydb/core/tx/data_events/shard_writer.h\n@@ -8,6 +8,7 @@\n #include <ydb/core/tx/long_tx_service/public/events.h>\n #include <ydb/library/actors/core/actor_bootstrapped.h>\n #include <ydb/library/actors/wilson/wilson_profile_span.h>\n+#include <ydb/core/tx/columnshard/counters/common/owner.h>\n \n \n namespace NKikimr::NEvWrite {\n@@ -22,19 +23,88 @@ class TWriteIdForShard {\n     TWriteIdForShard(const ui64 shardId, const ui64 writeId, const ui32 writePartId)\n         : ShardId(shardId)\n         , WriteId(writeId)\n-        , WritePartId(writePartId)\n-    {\n+        , WritePartId(writePartId) {\n+    }\n+};\n+\n+class TCSUploadCounters: public NColumnShard::TCommonCountersOwner {\n+private:\n+    using TBase = NColumnShard::TCommonCountersOwner;\n+    NMonitoring::TDynamicCounters::TCounterPtr RequestsCount;\n+    NMonitoring::THistogramPtr CSReplyDuration;\n+    NMonitoring::THistogramPtr SucceedFullReplyDuration;\n+    NMonitoring::THistogramPtr FailedFullReplyDuration;\n+    NMonitoring::THistogramPtr BytesDistribution;\n+    NMonitoring::THistogramPtr RowsDistribution;\n+    NMonitoring::TDynamicCounters::TCounterPtr RowsCount;\n+    NMonitoring::TDynamicCounters::TCounterPtr BytesCount;\n+    NMonitoring::TDynamicCounters::TCounterPtr FailsCount;\n+public:\n+    TCSUploadCounters()\n+        : TBase(\"CSUpload\")\n+        , RequestsCount(TBase::GetDeriviative(\"Requests\"))\n+        , CSReplyDuration(TBase::GetHistogram(\"Replies/Shard/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10)))\n+        , SucceedFullReplyDuration(TBase::GetHistogram(\"Replies/Success/Full/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10)))\n+        , FailedFullReplyDuration(TBase::GetHistogram(\"Replies/Failed/Full/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10)))\n+        , BytesDistribution(TBase::GetHistogram(\"Requests/Bytes\", NMonitoring::ExponentialHistogram(15, 2, 1024)))\n+        , RowsDistribution(TBase::GetHistogram(\"Requests/Rows\", NMonitoring::ExponentialHistogram(15, 2, 16)))\n+        , RowsCount(TBase::GetDeriviative(\"Rows\"))\n+        , BytesCount(TBase::GetDeriviative(\"Bytes\"))\n+        , FailsCount(TBase::GetDeriviative(\"Fails\")) {\n+\n     }\n-};    \n \n+    void OnRequest(const ui64 rows, const ui64 bytes) const {\n+        BytesDistribution->Collect(bytes);\n+        RowsDistribution->Collect(rows);\n+        BytesCount->Add(bytes);\n+        RowsCount->Add(rows);\n+    }\n+\n+    void OnCSFailed(const Ydb::StatusIds::StatusCode /*code*/) {\n+        FailsCount->Add(1);\n+    }\n+\n+    void OnCSReply(const TDuration d) const {\n+        CSReplyDuration->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnSucceedFullReply(const TDuration d) const {\n+        SucceedFullReplyDuration->Collect(d.MilliSeconds());\n+    }\n+\n+    void OnFailedFullReply(const TDuration d) const {\n+        FailedFullReplyDuration->Collect(d.MilliSeconds());\n+    }\n+};\n // External transaction controller class\n class TWritersController {\n private:\n     TAtomicCounter WritesCount = 0;\n     TAtomicCounter WritesIndex = 0;\n+    TAtomicCounter FailsCount = 0;\n+    TMutex Mutex;\n+    NYql::TIssues Issues;\n+    std::optional<Ydb::StatusIds::StatusCode> Code;\n     NActors::TActorIdentity LongTxActorId;\n     std::vector<TWriteIdForShard> WriteIds;\n+    const TMonotonic StartInstant = TMonotonic::Now();\n     YDB_READONLY_DEF(NLongTxService::TLongTxId, LongTxId);\n+    YDB_READONLY(std::shared_ptr<TCSUploadCounters>, Counters, std::make_shared<TCSUploadCounters>());\n+    void SendReply() {\n+        if (FailsCount.Val()) {\n+            Counters->OnFailedFullReply(TMonotonic::Now() - StartInstant);\n+            AFL_VERIFY(Code);\n+            LongTxActorId.Send(LongTxActorId, new TEvPrivate::TEvShardsWriteResult(*Code, Issues));\n+        } else {\n+            Counters->OnSucceedFullReply(TMonotonic::Now() - StartInstant);\n+            auto req = MakeHolder<NLongTxService::TEvLongTxService::TEvAttachColumnShardWrites>(LongTxId);\n+            for (auto&& i : WriteIds) {\n+                req->AddWrite(i.GetShardId(), i.GetWriteId());\n+            }\n+            LongTxActorId.Send(NLongTxService::MakeLongTxServiceID(LongTxActorId.NodeId()), req.Release());\n+        }\n+    }\n public:\n     using TPtr = std::shared_ptr<TWritersController>;\n \n@@ -94,10 +164,6 @@ class TShardWriter: public NActors::TActorBootstrapped<TShardWriter> {\n         TBase::PassAway();\n     }\n public:\n-    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n-        return NKikimrServices::TActivity::GRPC_REQ_SHARD_WRITER;\n-    }\n-\n     TShardWriter(const ui64 shardId, const ui64 tableId, const TString& dedupId, const IShardInfo::TPtr& data,\n         const NWilson::TProfileSpan& parentSpan, TWritersController::TPtr externalController, const ui32 writePartIdx, const EModificationType mType);\n \n@@ -115,6 +181,6 @@ class TShardWriter: public NActors::TActorBootstrapped<TShardWriter> {\n     void Handle(TEvPipeCache::TEvDeliveryProblem::TPtr& ev);\n     void HandleTimeout(const TActorContext& ctx);\n private:\n-    bool RetryWriteRequest(bool delayed = true);\n+    bool RetryWriteRequest(const bool delayed = true);\n };\n }\ndiff --git a/ydb/core/tx/data_events/shards_splitter.h b/ydb/core/tx/data_events/shards_splitter.h\nindex bed95ce29d03..77c04e1160e9 100644\n--- a/ydb/core/tx/data_events/shards_splitter.h\n+++ b/ydb/core/tx/data_events/shards_splitter.h\n@@ -3,7 +3,6 @@\n #include <ydb/library/conclusion/status.h>\n #include <ydb/public/api/protos/ydb_status_codes.pb.h>\n \n-\n #include <ydb/core/tx/scheme_cache/scheme_cache.h>\n #include <ydb/core/tx/columnshard/columnshard.h>\n \n@@ -21,6 +20,8 @@ class IShardsSplitter {\n     using TYdbConclusionStatus = TConclusionSpecialStatus<Ydb::StatusIds::StatusCode, Ydb::StatusIds::SUCCESS, Ydb::StatusIds::SCHEME_ERROR>;\n \n     class IEvWriteDataAccessor {\n+    private:\n+        YDB_READONLY(ui64, Size, 0);\n     public:\n         using TPtr = std::shared_ptr<IEvWriteDataAccessor>;\n \n@@ -29,6 +30,11 @@ class IShardsSplitter {\n         }\n         virtual std::shared_ptr<arrow::RecordBatch> GetDeserializedBatch() const = 0;\n         virtual TString GetSerializedData() const = 0;\n+        IEvWriteDataAccessor(const ui64 size)\n+            : Size(size)\n+        {\n+\n+        }\n         virtual ~IEvWriteDataAccessor() {}\n     };\n \ndiff --git a/ydb/core/tx/data_events/write_data.h b/ydb/core/tx/data_events/write_data.h\nindex 5fc92bf185b3..0acbec1bcf98 100644\n--- a/ydb/core/tx/data_events/write_data.h\n+++ b/ydb/core/tx/data_events/write_data.h\n@@ -3,7 +3,7 @@\n \n #include <ydb/core/tx/long_tx_service/public/types.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/modifier/subset.h>\n+#include <ydb/library/formats/arrow/modifier/subset.h>\n #include <ydb/library/accessor/accessor.h>\n \n #include <ydb/library/actors/core/monotonic.h>\n@@ -46,7 +46,21 @@ class TWriteMeta {\n     YDB_ACCESSOR(TMonotonic, WriteMiddle4StartInstant, TMonotonic::Now());\n     YDB_ACCESSOR(TMonotonic, WriteMiddle5StartInstant, TMonotonic::Now());\n     YDB_ACCESSOR(TMonotonic, WriteMiddle6StartInstant, TMonotonic::Now());\n+    std::optional<ui64> LockId;\n public:\n+    void SetLockId(const ui64 lockId) {\n+        LockId = lockId;\n+    }\n+\n+    ui64 GetLockIdVerified() const {\n+        AFL_VERIFY(LockId);\n+        return *LockId;\n+    }\n+\n+    std::optional<ui64> GetLockIdOptional() const {\n+        return LockId;\n+    }\n+\n     bool IsGuaranteeWriter() const {\n         switch (ModificationType) {\n             case EModificationType::Delete:\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/actor.cpp b/ydb/core/tx/limiter/grouped_memory/service/actor.cpp\nnew file mode 100644\nindex 000000000000..e7573c23612e\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/actor.cpp\n@@ -0,0 +1,50 @@\n+#include \"actor.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+void TMemoryLimiterActor::Bootstrap() {\n+    Manager = std::make_shared<TManager>(SelfId(), Config, Name, Signals, DefaultStage);\n+    Become(&TThis::StateWait);\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvStartTask::TPtr& ev) {\n+    for (auto&& i : ev->Get()->GetAllocations()) {\n+        Manager->RegisterAllocation(ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId(), ev->Get()->GetExternalGroupId(), i,\n+            ev->Get()->GetStageFeaturesIdx());\n+    }\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvFinishTask::TPtr& ev) {\n+    Manager->UnregisterAllocation(ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId(), ev->Get()->GetAllocationId());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvUpdateTask::TPtr& ev) {\n+    Manager->UpdateAllocation(\n+        ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId(), ev->Get()->GetAllocationId(), ev->Get()->GetVolume());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvFinishGroup::TPtr& ev) {\n+    Manager->UnregisterGroup(ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId(), ev->Get()->GetExternalGroupId());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvStartGroup::TPtr& ev) {\n+    Manager->RegisterGroup(ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId(), ev->Get()->GetExternalGroupId());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvFinishProcess::TPtr& ev) {\n+    Manager->UnregisterProcess(ev->Get()->GetExternalProcessId());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvStartProcess::TPtr& ev) {\n+    Manager->RegisterProcess(ev->Get()->GetExternalProcessId(), ev->Get()->GetStages());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvFinishProcessScope::TPtr& ev) {\n+    Manager->UnregisterProcessScope(ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId());\n+}\n+\n+void TMemoryLimiterActor::Handle(NEvents::TEvExternal::TEvStartProcessScope::TPtr& ev) {\n+    Manager->RegisterProcessScope(ev->Get()->GetExternalProcessId(), ev->Get()->GetExternalScopeId());\n+}\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/actor.h b/ydb/core/tx/limiter/grouped_memory/service/actor.h\nnew file mode 100644\nindex 000000000000..4b4506ba5b99\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/actor.h\n@@ -0,0 +1,59 @@\n+#pragma once\n+#include \"counters.h\"\n+#include \"manager.h\"\n+\n+#include <ydb/core/tx/limiter/grouped_memory/usage/config.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/events.h>\n+\n+#include <ydb/library/actors/core/actor.h>\n+#include <ydb/library/actors/core/actor_bootstrapped.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+class TManager;\n+class TMemoryLimiterActor: public NActors::TActorBootstrapped<TMemoryLimiterActor> {\n+private:\n+    std::shared_ptr<TManager> Manager;\n+    const TConfig Config;\n+    const TString Name;\n+    const std::shared_ptr<TCounters> Signals;\n+    const std::shared_ptr<TStageFeatures> DefaultStage;\n+\n+public:\n+    TMemoryLimiterActor(const TConfig& config, const TString& name, const std::shared_ptr<TCounters>& signals,\n+        const std::shared_ptr<TStageFeatures>& defaultStage)\n+        : Config(config)\n+        , Name(name)\n+        , Signals(signals)\n+        , DefaultStage(defaultStage) {\n+    }\n+\n+    void Handle(NEvents::TEvExternal::TEvStartTask::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvFinishTask::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvUpdateTask::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvStartGroup::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvFinishGroup::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvStartProcess::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvFinishProcess::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvStartProcessScope::TPtr& ev);\n+    void Handle(NEvents::TEvExternal::TEvFinishProcessScope::TPtr& ev);\n+\n+    void Bootstrap();\n+\n+    STFUNC(StateWait) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(NEvents::TEvExternal::TEvStartTask, Handle);\n+            hFunc(NEvents::TEvExternal::TEvFinishTask, Handle);\n+            hFunc(NEvents::TEvExternal::TEvUpdateTask, Handle);\n+            hFunc(NEvents::TEvExternal::TEvStartGroup, Handle);\n+            hFunc(NEvents::TEvExternal::TEvFinishGroup, Handle);\n+            hFunc(NEvents::TEvExternal::TEvStartProcess, Handle);\n+            hFunc(NEvents::TEvExternal::TEvFinishProcess, Handle);\n+            hFunc(NEvents::TEvExternal::TEvStartProcessScope, Handle);\n+            hFunc(NEvents::TEvExternal::TEvFinishProcessScope, Handle);\n+            default:\n+                AFL_VERIFY(false)(\"ev_type\", ev->GetTypeName());\n+        }\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/allocation.cpp b/ydb/core/tx/limiter/grouped_memory/service/allocation.cpp\nnew file mode 100644\nindex 000000000000..2d04be2c9cef\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/allocation.cpp\n@@ -0,0 +1,26 @@\n+#include \"allocation.h\"\n+#include <ydb/library/accessor/validator.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+TAllocationInfo::TAllocationInfo(const ui64 processId, const ui64 scopeId, const ui64 allocationInternalGroupId,\n+    const std::shared_ptr<IAllocation>& allocation,\n+    const std::shared_ptr<TStageFeatures>& stage)\n+    : Allocation(allocation)\n+    , AllocationInternalGroupId(allocationInternalGroupId)\n+    , Identifier(TValidator::CheckNotNull(Allocation)->GetIdentifier())\n+    , ProcessId(processId)\n+    , ScopeId(scopeId)\n+    , Stage(stage) {\n+    AFL_VERIFY(Stage);\n+    AFL_VERIFY(Allocation);\n+    AFL_INFO(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"add\")(\"id\", Allocation->GetIdentifier())(\"stage\", Stage->GetName());\n+    AllocatedVolume = Allocation->GetMemory();\n+    Stage->Add(AllocatedVolume, Allocation->IsAllocated());\n+    if (allocation->IsAllocated()) {\n+        AFL_INFO(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"allocated_on_add\")(\"allocation_id\", Identifier)(\"stage\", Stage->GetName());\n+        Allocation = nullptr;\n+    }\n+}\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/allocation.h b/ydb/core/tx/limiter/grouped_memory/service/allocation.h\nnew file mode 100644\nindex 000000000000..47d5043188d0\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/allocation.h\n@@ -0,0 +1,76 @@\n+#pragma once\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+enum class EAllocationStatus {\n+    Allocated,\n+    Waiting,\n+    Failed\n+};\n+\n+class TAllocationInfo {\n+private:\n+    std::shared_ptr<IAllocation> Allocation;\n+    YDB_READONLY(ui64, AllocationInternalGroupId, 0);\n+    ui64 AllocatedVolume = 0;\n+    YDB_READONLY(ui64, Identifier, 0);\n+    YDB_READONLY(ui64, ProcessId, 0);\n+    YDB_READONLY(ui64, ScopeId, 0);\n+    const std::shared_ptr<TStageFeatures> Stage;\n+    bool AllocationFailed = false;\n+\n+public:\n+    ~TAllocationInfo() {\n+        if (GetAllocationStatus() != EAllocationStatus::Failed) {\n+            Stage->Free(AllocatedVolume, GetAllocationStatus() == EAllocationStatus::Allocated);\n+        }\n+        \n+        AFL_TRACE(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"destroy\")(\"allocation_id\", Identifier)(\"stage\", Stage->GetName());\n+    }\n+\n+    bool IsAllocatable(const ui64 additional) const {\n+        return Stage->IsAllocatable(AllocatedVolume, additional);\n+    }\n+\n+    void SetAllocatedVolume(const ui64 value) {\n+        AFL_VERIFY(GetAllocationStatus() != EAllocationStatus::Failed);\n+        Stage->UpdateVolume(AllocatedVolume, value, GetAllocationStatus() == EAllocationStatus::Allocated);\n+        AllocatedVolume = value;\n+    }\n+\n+    ui64 GetAllocatedVolume() const {\n+        return AllocatedVolume;\n+    }\n+\n+    [[nodiscard]] bool Allocate(const NActors::TActorId& ownerId) {\n+        AFL_TRACE(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"allocated\")(\"allocation_id\", Identifier)(\"stage\", Stage->GetName());\n+        AFL_VERIFY(Allocation)(\"status\", GetAllocationStatus())(\"volume\", AllocatedVolume)(\"id\", Identifier)(\"stage\", Stage->GetName())(\n+            \"allocation_internal_group_id\", AllocationInternalGroupId);\n+        const bool result = Allocation->OnAllocated(\n+            std::make_shared<TAllocationGuard>(ProcessId, ScopeId, Allocation->GetIdentifier(), ownerId, Allocation->GetMemory()), Allocation);\n+        if (result) {\n+            Stage->Allocate(AllocatedVolume);\n+        } else {\n+            Stage->Free(AllocatedVolume, false);\n+            AllocationFailed = true;\n+        }\n+        Allocation = nullptr;\n+        return result;\n+    }\n+\n+    EAllocationStatus GetAllocationStatus() const {\n+        if (AllocationFailed) {\n+            return EAllocationStatus::Failed;\n+        } else if (Allocation) {\n+            return EAllocationStatus::Waiting;\n+        } else {\n+            return EAllocationStatus::Allocated;\n+        }\n+    }\n+\n+    TAllocationInfo(const ui64 processId, const ui64 scopeId, const ui64 allocationInternalGroupId, const std::shared_ptr<IAllocation>& allocation,\n+        const std::shared_ptr<TStageFeatures>& stage);\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/counters.cpp b/ydb/core/tx/limiter/grouped_memory/service/counters.cpp\nnew file mode 100644\nindex 000000000000..d780bfd499d2\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/counters.cpp\n@@ -0,0 +1,5 @@\n+#include \"counters.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+}\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/counters.h b/ydb/core/tx/limiter/grouped_memory/service/counters.h\nnew file mode 100644\nindex 000000000000..3c96b3b8b9a4\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/counters.h\n@@ -0,0 +1,62 @@\n+#pragma once\n+#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TStageCounters: public NColumnShard::TCommonCountersOwner {\n+private:\n+    using TBase = NColumnShard::TCommonCountersOwner;\n+    NMonitoring::TDynamicCounters::TCounterPtr AllocatedBytes;\n+    NMonitoring::TDynamicCounters::TCounterPtr AllocatedChunks;\n+    NMonitoring::TDynamicCounters::TCounterPtr WaitingBytes;\n+    NMonitoring::TDynamicCounters::TCounterPtr WaitingChunks;\n+\n+public:\n+    TStageCounters(const TCommonCountersOwner& owner, const TString& name)\n+        : TBase(owner, \"stage\", name)\n+        , AllocatedBytes(TBase::GetValue(\"Allocated/Bytes\"))\n+        , AllocatedChunks(TBase::GetValue(\"Allocated/Count\"))\n+        , WaitingBytes(TBase::GetValue(\"Waiting/Bytes\"))\n+        , WaitingChunks(TBase::GetValue(\"Waiting/Count\")) {\n+    }\n+\n+    void Add(const ui64 volume, const bool allocated) {\n+        if (allocated) {\n+            AllocatedBytes->Add(volume);\n+            AllocatedChunks->Add(1);\n+        } else {\n+            WaitingBytes->Add(volume);\n+            WaitingChunks->Add(1);\n+        }\n+    }\n+\n+    void Sub(const ui64 volume, const bool allocated) {\n+        if (allocated) {\n+            AllocatedBytes->Sub(volume);\n+            AllocatedChunks->Sub(1);\n+        } else {\n+            WaitingBytes->Sub(volume);\n+            WaitingChunks->Sub(1);\n+        }\n+    }\n+};\n+\n+class TCounters: public NColumnShard::TCommonCountersOwner {\n+private:\n+    using TBase = NColumnShard::TCommonCountersOwner;\n+\n+public:\n+    NMonitoring::TDynamicCounters::TCounterPtr GroupsCount;\n+    NMonitoring::TDynamicCounters::TCounterPtr ProcessesCount;\n+    TCounters(const TIntrusivePtr<::NMonitoring::TDynamicCounters>& counters, const TString& name)\n+        : TBase(NColumnShard::TCommonCountersOwner(\"grouped_memory_limiter\", counters), \"limiter_name\", name)\n+        , GroupsCount(TBase::GetValue(\"Groups/Count\"))\n+        , ProcessesCount(TBase::GetValue(\"Processes/Count\")) {\n+    }\n+\n+    std::shared_ptr<TStageCounters> BuildStageCounters(const TString& stageName) const {\n+        return std::make_shared<TStageCounters>(*this, stageName);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/group.cpp b/ydb/core/tx/limiter/grouped_memory/service/group.cpp\nnew file mode 100644\nindex 000000000000..3bf671ff76b9\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/group.cpp\n@@ -0,0 +1,68 @@\n+#include \"group.h\"\n+#include \"process.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+std::vector<std::shared_ptr<TAllocationInfo>> TGrouppedAllocations::AllocatePossible(const ui32 allocationsLimit) {\n+    std::vector<std::shared_ptr<TAllocationInfo>> result;\n+    ui64 allocationMemory = 0;\n+    ui32 allocationsCount = 0;\n+    for (auto&& [_, allocation] : Allocations) {\n+        if (allocation->IsAllocatable(allocationMemory)) {\n+            allocationMemory += allocation->GetAllocatedVolume();\n+            result.emplace_back(allocation);\n+            if (++allocationsCount == allocationsLimit) {\n+                return result;\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n+bool TAllocationGroups::Allocate(const bool isPriorityProcess, TProcessMemoryScope& process, const ui32 allocationsLimit) {\n+    AFL_DEBUG(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"try_allocation\")(\"limit\", allocationsLimit)(\n+        \"external_process_id\", process.ExternalProcessId)(\"forced_internal_group_id\", process.GroupIds.GetMinInternalIdOptional())(\n+        \"external_scope_id\", process.ExternalScopeId)(\"forced_external_group_id\", process.GroupIds.GetMinExternalIdOptional());\n+    ui32 allocationsCount = 0;\n+    while (true) {\n+        std::vector<ui64> toRemove;\n+        for (auto it = Groups.begin(); it != Groups.end();) {\n+            const ui64 internalGroupId = it->first;\n+            const bool forced = isPriorityProcess && internalGroupId == process.GroupIds.GetMinInternalIdVerified();\n+            std::vector<std::shared_ptr<TAllocationInfo>> allocated;\n+            if (forced) {\n+                allocated = it->second.ExtractAllocationsToVector();\n+            } else if (allocationsLimit) {\n+                allocated = it->second.AllocatePossible(allocationsLimit - allocationsCount);\n+            } else {\n+                break;\n+            }\n+            for (auto&& i : allocated) {\n+                if (!i->Allocate(process.OwnerActorId)) {\n+                    toRemove.emplace_back(i->GetIdentifier());\n+                } else if (!forced) {\n+                    AFL_VERIFY(++allocationsCount <= allocationsLimit)(\"count\", allocationsCount)(\"limit\", allocationsLimit);\n+                }\n+                if (!forced) {\n+                    AFL_VERIFY(it->second.Remove(i));\n+                }\n+            }\n+            if (!it->second.IsEmpty()) {\n+                break;\n+            }\n+            it = Groups.erase(it);\n+            if (!forced && allocationsCount == allocationsLimit) {\n+                break;\n+            }\n+        }\n+        for (auto&& i : toRemove) {\n+            process.UnregisterAllocation(i);\n+        }\n+        if (toRemove.empty() || allocationsCount == allocationsLimit) {\n+            break;\n+        }\n+    }\n+    return allocationsCount;\n+}\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/group.h b/ydb/core/tx/limiter/grouped_memory/service/group.h\nnew file mode 100644\nindex 000000000000..8f4434c886b8\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/group.h\n@@ -0,0 +1,90 @@\n+#pragma once\n+#include \"allocation.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TProcessMemoryScope;\n+\n+class TGrouppedAllocations {\n+private:\n+    THashMap<ui64, std::shared_ptr<TAllocationInfo>> Allocations;\n+\n+public:\n+    std::vector<std::shared_ptr<TAllocationInfo>> ExtractAllocationsToVector() {\n+        std::vector<std::shared_ptr<TAllocationInfo>> result;\n+        result.reserve(Allocations.size());\n+        for (auto&& i : Allocations) {\n+            result.emplace_back(std::move(i.second));\n+        }\n+        Allocations.clear();\n+        return result;\n+    }\n+\n+    const THashMap<ui64, std::shared_ptr<TAllocationInfo>>& GetAllocations() const {\n+        return Allocations;\n+    }\n+\n+    bool IsEmpty() const {\n+        return Allocations.empty();\n+    }\n+\n+    void AddAllocation(const std::shared_ptr<TAllocationInfo>& allocation) {\n+        AFL_VERIFY(Allocations.emplace(allocation->GetIdentifier(), allocation).second);\n+    }\n+\n+    [[nodiscard]] bool Remove(const std::shared_ptr<TAllocationInfo>& allocation) {\n+        return Allocations.erase(allocation->GetIdentifier());\n+    }\n+\n+    std::vector<std::shared_ptr<TAllocationInfo>> AllocatePossible(const ui32 allocationsLimit);\n+};\n+\n+class TAllocationGroups {\n+private:\n+    std::map<ui64, TGrouppedAllocations> Groups;\n+\n+public:\n+    bool IsEmpty() const {\n+        return Groups.empty();\n+    }\n+\n+    [[nodiscard]] bool Allocate(const bool isPriorityProcess, TProcessMemoryScope& process, const ui32 allocationsLimit);\n+\n+    [[nodiscard]] std::vector<std::shared_ptr<TAllocationInfo>> ExtractGroup(const ui64 id) {\n+        auto it = Groups.find(id);\n+        if (it == Groups.end()) {\n+            return {};\n+        }\n+        auto result = it->second.ExtractAllocationsToVector();\n+        Groups.erase(it);\n+        return result;\n+    }\n+\n+    std::optional<ui64> GetMinGroupId() const {\n+        if (Groups.size()) {\n+            return Groups.begin()->first;\n+        } else {\n+            return std::nullopt;\n+        }\n+    }\n+\n+    [[nodiscard]] bool RemoveAllocation(const ui64 internalGroupId, const std::shared_ptr<TAllocationInfo>& allocation) {\n+        auto groupIt = Groups.find(internalGroupId);\n+        if (groupIt == Groups.end()) {\n+            return false;\n+        }\n+        if (!groupIt->second.Remove(allocation)) {\n+            return false;\n+        }\n+        if (groupIt->second.IsEmpty()) {\n+            Groups.erase(groupIt);\n+        }\n+        return true;\n+    }\n+\n+    void AddAllocation(const ui64 internalGroupId, const std::shared_ptr<TAllocationInfo>& allocation) {\n+        Groups[internalGroupId].AddAllocation(allocation);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/ids.cpp b/ydb/core/tx/limiter/grouped_memory/service/ids.cpp\nnew file mode 100644\nindex 000000000000..163c90efcf12\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/ids.cpp\n@@ -0,0 +1,66 @@\n+#include \"ids.h\"\n+#include <ydb/library/actors/core/log.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+ui64 TIdsControl::ExtractInternalIdVerified(const ui64 externalId) {\n+    auto it = ExternalIdIntoInternalId.find(externalId);\n+    AFL_VERIFY(it != ExternalIdIntoInternalId.end())(\"external_id\", externalId);\n+    const ui64 result = it->second;\n+    InternalIdIntoExternalId.erase(result);\n+    ExternalIdIntoInternalId.erase(it);\n+    return result;\n+}\n+\n+std::optional<ui64> TIdsControl::GetInternalIdOptional(const ui64 externalId) const {\n+    auto it = ExternalIdIntoInternalId.find(externalId);\n+    if (it != ExternalIdIntoInternalId.end()) {\n+        return it->second;\n+    }\n+    return std::nullopt;\n+}\n+\n+ui64 TIdsControl::GetMinInternalIdVerified() const {\n+    AFL_VERIFY(InternalIdIntoExternalId.size());\n+    return InternalIdIntoExternalId.begin()->first;\n+}\n+\n+ui64 TIdsControl::GetInternalIdVerified(const ui64 externalId) const {\n+    auto it = ExternalIdIntoInternalId.find(externalId);\n+    AFL_VERIFY(it != ExternalIdIntoInternalId.end())(\"external_id\", externalId);\n+    return it->second;\n+}\n+\n+ui64 TIdsControl::RegisterExternalId(const ui64 externalId) {\n+    AFL_VERIFY(ExternalIdIntoInternalId.emplace(externalId, ++CurrentInternalId).second);\n+    InternalIdIntoExternalId.emplace(CurrentInternalId, externalId);\n+    return CurrentInternalId;\n+}\n+\n+ui64 TIdsControl::RegisterExternalIdOrGet(const ui64 externalId) {\n+    auto it = ExternalIdIntoInternalId.find(externalId);\n+    if (it != ExternalIdIntoInternalId.end()) {\n+        return it->second;\n+    }\n+    AFL_VERIFY(ExternalIdIntoInternalId.emplace(externalId, ++CurrentInternalId).second);\n+    InternalIdIntoExternalId.emplace(CurrentInternalId, externalId);\n+    return CurrentInternalId;\n+}\n+\n+bool TIdsControl::UnregisterExternalId(const ui64 externalId) {\n+    auto it = ExternalIdIntoInternalId.find(externalId);\n+    if (it == ExternalIdIntoInternalId.end()) {\n+        return false;\n+    }\n+    AFL_VERIFY(InternalIdIntoExternalId.erase(it->second));\n+    ExternalIdIntoInternalId.erase(it);\n+    return true;\n+}\n+\n+ui64 TIdsControl::GetExternalIdVerified(const ui64 internalId) const {\n+    auto it = InternalIdIntoExternalId.find(internalId);\n+    AFL_VERIFY(it != InternalIdIntoExternalId.end());\n+    return it->second;\n+}\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/ids.h b/ydb/core/tx/limiter/grouped_memory/service/ids.h\nnew file mode 100644\nindex 000000000000..acaa700411ab\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/ids.h\n@@ -0,0 +1,70 @@\n+#pragma once\n+#include <ydb/library/accessor/accessor.h>\n+\n+#include <util/generic/hash.h>\n+\n+#include <map>\n+#include <set>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TIdsControl {\n+private:\n+    THashMap<ui64, ui64> ExternalIdIntoInternalId;\n+    std::map<ui64, ui64> InternalIdIntoExternalId;\n+    ui64 CurrentInternalId = 0;\n+\n+public:\n+    void Clear() {\n+        ExternalIdIntoInternalId.clear();\n+        InternalIdIntoExternalId.clear();\n+    }\n+\n+    const std::map<ui64, ui64>& GetInternalIdToExternalIds() const {\n+        return InternalIdIntoExternalId;\n+    }\n+\n+    ui64 GetSize() const {\n+        return InternalIdIntoExternalId.size();\n+    }\n+\n+    [[nodiscard]] ui64 ExtractInternalIdVerified(const ui64 externalId);\n+\n+    ui64 GetMinInternalIdVerified() const;\n+    ui64 GetExternalIdVerified(const ui64 internalId) const;\n+\n+    std::optional<ui64> GetInternalIdOptional(const ui64 externalId) const;\n+\n+    ui64 GetInternalIdVerified(const ui64 externalId) const;\n+\n+    [[nodiscard]] ui64 RegisterExternalId(const ui64 externalId);\n+    [[nodiscard]] ui64 RegisterExternalIdOrGet(const ui64 externalId);\n+\n+    [[nodiscard]] bool UnregisterExternalId(const ui64 externalId);\n+\n+    std::optional<ui64> GetMinInternalIdOptional() const {\n+        if (InternalIdIntoExternalId.size()) {\n+            return InternalIdIntoExternalId.begin()->first;\n+        } else {\n+            return std::nullopt;\n+        }\n+    }\n+\n+    std::optional<ui64> GetMinExternalIdOptional() const {\n+        if (InternalIdIntoExternalId.size()) {\n+            return InternalIdIntoExternalId.begin()->second;\n+        } else {\n+            return std::nullopt;\n+        }\n+    }\n+\n+    ui64 GetMinInternalIdDef(const ui64 def) const {\n+        if (InternalIdIntoExternalId.size()) {\n+            return InternalIdIntoExternalId.begin()->first;\n+        } else {\n+            return def;\n+        }\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/manager.cpp b/ydb/core/tx/limiter/grouped_memory/service/manager.cpp\nnew file mode 100644\nindex 000000000000..96fe8bcefc17\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/manager.cpp\n@@ -0,0 +1,122 @@\n+#include \"manager.h\"\n+\n+#include <ydb/library/accessor/validator.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+TProcessMemory* TManager::GetProcessMemoryByExternalIdOptional(const ui64 externalProcessId) {\n+    auto internalId = ProcessIds.GetInternalIdOptional(externalProcessId);\n+    if (!internalId) {\n+        return nullptr;\n+    }\n+    return GetProcessMemoryOptional(*internalId);\n+}\n+\n+void TManager::RegisterGroup(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 externalGroupId) {\n+    AFL_DEBUG(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"register_group\")(\"external_process_id\", externalProcessId)(\n+        \"external_group_id\", externalGroupId)(\"size\", ProcessIds.GetSize())(\"external_scope_id\", externalScopeId);\n+    if (auto* process = GetProcessMemoryByExternalIdOptional(externalProcessId)) {\n+        process->RegisterGroup(externalScopeId, externalGroupId);\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::UnregisterGroup(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 externalGroupId) {\n+    AFL_DEBUG(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"unregister_group\")(\"external_process_id\", externalProcessId)(\n+        \"external_group_id\", externalGroupId)(\"size\", ProcessIds.GetSize());\n+    if (auto* process = GetProcessMemoryByExternalIdOptional(externalProcessId)) {\n+        process->UnregisterGroup(externalScopeId, externalGroupId);\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::UpdateAllocation(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 allocationId, const ui64 volume) {\n+    TProcessMemory& process = GetProcessMemoryVerified(ProcessIds.GetInternalIdVerified(externalProcessId));\n+    if (process.UpdateAllocation(externalScopeId, allocationId, volume)) {\n+        TryAllocateWaiting();\n+    }\n+\n+    RefreshSignals();\n+}\n+\n+void TManager::TryAllocateWaiting() {\n+    if (Processes.size()) {\n+        auto it = Processes.find(ProcessIds.GetMinInternalIdVerified());\n+        AFL_VERIFY(it != Processes.end());\n+        AFL_VERIFY(it->second.IsPriorityProcess());\n+        it->second.TryAllocateWaiting(0);\n+    }\n+    while (true) {\n+        bool found = false;\n+        for (auto&& i : Processes) {\n+            if (i.second.TryAllocateWaiting(1)) {\n+                found = true;\n+            }\n+        }\n+        if (!found) {\n+            break;\n+        }\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::UnregisterAllocation(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 allocationId) {\n+    if (auto* process = GetProcessMemoryByExternalIdOptional(externalProcessId)) {\n+        if (process->UnregisterAllocation(externalScopeId, allocationId)) {\n+            TryAllocateWaiting();\n+        }\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::RegisterAllocation(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 externalGroupId,\n+    const std::shared_ptr<IAllocation>& task, const std::optional<ui32>& stageIdx) {\n+    if (auto* process = GetProcessMemoryByExternalIdOptional(externalProcessId)) {\n+        process->RegisterAllocation(externalScopeId, externalGroupId, task, stageIdx);\n+    } else {\n+        AFL_VERIFY(!task->OnAllocated(std::make_shared<TAllocationGuard>(externalProcessId, externalScopeId, task->GetIdentifier(), OwnerActorId, task->GetMemory()), task))(\n+                                                                                  \"ext_group\", externalGroupId)(\"stage_idx\", stageIdx);\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::RegisterProcess(const ui64 externalProcessId, const std::vector<std::shared_ptr<TStageFeatures>>& stages) {\n+    auto internalId = ProcessIds.GetInternalIdOptional(externalProcessId);\n+    if (!internalId) {\n+        const ui64 internalProcessId = ProcessIds.RegisterExternalIdOrGet(externalProcessId);\n+        AFL_VERIFY(Processes.emplace(internalProcessId, TProcessMemory(externalProcessId, OwnerActorId, Processes.empty(), stages, DefaultStage)).second);\n+    } else {\n+        ++Processes.find(*internalId)->second.MutableLinksCount();\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::UnregisterProcess(const ui64 externalProcessId) {\n+    const ui64 internalProcessId = ProcessIds.GetInternalIdVerified(externalProcessId);\n+    auto it = Processes.find(internalProcessId);\n+    AFL_VERIFY(it != Processes.end());\n+    if (--it->second.MutableLinksCount()) {\n+        return;\n+    }\n+    Y_UNUSED(ProcessIds.ExtractInternalIdVerified(externalProcessId));\n+    it->second.Unregister();\n+    Processes.erase(it);\n+    const ui64 nextInternalProcessId = ProcessIds.GetMinInternalIdDef(internalProcessId);\n+    if (internalProcessId < nextInternalProcessId) {\n+        GetProcessMemoryVerified(nextInternalProcessId).SetPriorityProcess();\n+        TryAllocateWaiting();\n+    }\n+    RefreshSignals();\n+}\n+\n+void TManager::RegisterProcessScope(const ui64 externalProcessId, const ui64 externalProcessScopeId) {\n+    GetProcessMemoryVerified(ProcessIds.GetInternalIdVerified(externalProcessId)).RegisterScope(externalProcessScopeId);\n+    RefreshSignals();\n+}\n+\n+void TManager::UnregisterProcessScope(const ui64 externalProcessId, const ui64 externalProcessScopeId) {\n+    GetProcessMemoryVerified(ProcessIds.GetInternalIdVerified(externalProcessId)).UnregisterScope(externalProcessScopeId);\n+    RefreshSignals();\n+}\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/manager.h b/ydb/core/tx/limiter/grouped_memory/service/manager.h\nnew file mode 100644\nindex 000000000000..fd641a3f69b1\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/manager.h\n@@ -0,0 +1,79 @@\n+#pragma once\n+#include \"counters.h\"\n+#include \"process.h\"\n+\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/config.h>\n+\n+#include <ydb/library/accessor/validator.h>\n+#include <ydb/library/actors/core/log.h>\n+\n+#include <library/cpp/monlib/dynamic_counters/counters.h>\n+#include <util/generic/hash.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TManager {\n+private:\n+    const TConfig Config;\n+    const TString Name;\n+    const std::shared_ptr<TCounters> Signals;\n+    const NActors::TActorId OwnerActorId;\n+    THashMap<ui64, TProcessMemory> Processes;\n+    std::shared_ptr<TStageFeatures> DefaultStage;\n+    TIdsControl ProcessIds;\n+\n+    void TryAllocateWaiting();\n+    void RefreshSignals() const {\n+        Signals->ProcessesCount->Set(Processes.size());\n+    }\n+\n+    TProcessMemory& GetProcessMemoryVerified(const ui64 internalProcessId) {\n+        auto it = Processes.find(internalProcessId);\n+        AFL_VERIFY(it != Processes.end());\n+        return it->second;\n+    }\n+\n+    TProcessMemory* GetProcessMemoryByExternalIdOptional(const ui64 externalProcessId);\n+\n+    TProcessMemory* GetProcessMemoryOptional(const ui64 internalProcessId) {\n+        auto it = Processes.find(internalProcessId);\n+        if (it != Processes.end()) {\n+            return &it->second;\n+        } else {\n+            return nullptr;\n+        }\n+    }\n+\n+public:\n+    TManager(const NActors::TActorId& ownerActorId, const TConfig& config, const TString& name, const std::shared_ptr<TCounters>& signals,\n+        const std::shared_ptr<TStageFeatures>& defaultStage)\n+        : Config(config)\n+        , Name(name)\n+        , Signals(signals)\n+        , OwnerActorId(ownerActorId)\n+        , DefaultStage(defaultStage)\n+    {\n+    }\n+\n+    void RegisterGroup(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 externalGroupId);\n+    void UnregisterGroup(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 externalGroupId);\n+\n+    void RegisterProcessScope(const ui64 externalProcessId, const ui64 externalScopeId);\n+    void UnregisterProcessScope(const ui64 externalProcessId, const ui64 externalScopeId);\n+\n+    void RegisterProcess(const ui64 externalProcessId, const std::vector<std::shared_ptr<TStageFeatures>>& stages);\n+    void UnregisterProcess(const ui64 externalProcessId);\n+\n+    void RegisterAllocation(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 externalGroupId,\n+        const std::shared_ptr<IAllocation>& task,\n+        const std::optional<ui32>& stageIdx);\n+    void UnregisterAllocation(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 allocationId);\n+    void UpdateAllocation(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 allocationId, const ui64 volume);\n+\n+    bool IsEmpty() const {\n+        return Processes.empty();\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/process.cpp b/ydb/core/tx/limiter/grouped_memory/service/process.cpp\nnew file mode 100644\nindex 000000000000..bcde6532e797\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/process.cpp\n@@ -0,0 +1,5 @@\n+#include \"process.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/process.h b/ydb/core/tx/limiter/grouped_memory/service/process.h\nnew file mode 100644\nindex 000000000000..a1c13e091d59\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/process.h\n@@ -0,0 +1,262 @@\n+#pragma once\n+#include \"group.h\"\n+#include \"ids.h\"\n+\n+#include <ydb/library/accessor/validator.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TProcessMemoryScope {\n+private:\n+    const ui64 ExternalProcessId;\n+    const ui64 ExternalScopeId;\n+    TAllocationGroups WaitAllocations;\n+    THashMap<ui64, std::shared_ptr<TAllocationInfo>> AllocationInfo;\n+    TIdsControl GroupIds;\n+    ui32 Links = 1;\n+    const NActors::TActorId OwnerActorId;\n+\n+    TAllocationInfo& GetAllocationInfoVerified(const ui64 allocationId) const {\n+        auto it = AllocationInfo.find(allocationId);\n+        AFL_VERIFY(it != AllocationInfo.end());\n+        return *it->second;\n+    }\n+\n+    void UnregisterGroupImpl(const ui64 internalGroupId) {\n+        auto data = WaitAllocations.ExtractGroup(internalGroupId);\n+        for (auto&& allocation : data) {\n+            AFL_VERIFY(!allocation->Allocate(OwnerActorId));\n+        }\n+    }\n+\n+    const std::shared_ptr<TAllocationInfo>& RegisterAllocationImpl(\n+        const ui64 internalGroupId, const std::shared_ptr<IAllocation>& task, const std::shared_ptr<TStageFeatures>& stage) {\n+        auto it = AllocationInfo.find(task->GetIdentifier());\n+        if (it == AllocationInfo.end()) {\n+            it = AllocationInfo\n+                     .emplace(task->GetIdentifier(),\n+                         std::make_shared<TAllocationInfo>(ExternalProcessId, ExternalScopeId, internalGroupId, task, stage))\n+                     .first;\n+        }\n+        return it->second;\n+    }\n+\n+    friend class TAllocationGroups;\n+\n+public:\n+    TProcessMemoryScope(const ui64 externalProcessId, const ui64 externalScopeId, const NActors::TActorId& ownerActorId)\n+        : ExternalProcessId(externalProcessId)\n+        , ExternalScopeId(externalScopeId)\n+        , OwnerActorId(ownerActorId) {\n+    }\n+\n+    void Register() {\n+        ++Links;\n+    }\n+\n+    [[nodiscard]] bool Unregister() {\n+        if (--Links) {\n+            return false;\n+        }\n+        for (auto&& [i, _] : GroupIds.GetInternalIdToExternalIds()) {\n+            UnregisterGroupImpl(i);\n+        }\n+        GroupIds.Clear();\n+        AllocationInfo.clear();\n+        return true;\n+    }\n+\n+    void RegisterAllocation(const bool isPriorityProcess, const ui64 externalGroupId, const std::shared_ptr<IAllocation>& task,\n+        const std::shared_ptr<TStageFeatures>& stage) {\n+        AFL_VERIFY(task);\n+        AFL_VERIFY(stage);\n+        const std::optional<ui64> internalGroupIdOptional = GroupIds.GetInternalIdOptional(externalGroupId);\n+        if (!internalGroupIdOptional) {\n+            AFL_VERIFY(!task->OnAllocated(std::make_shared<TAllocationGuard>(ExternalProcessId, ExternalScopeId, task->GetIdentifier(), OwnerActorId, task->GetMemory()), task))(\n+                                                                   \"ext_group\", externalGroupId)(\n+                                                                   \"min_group\", GroupIds.GetMinInternalIdOptional())(\"stage\", stage->GetName());\n+            AFL_VERIFY(!AllocationInfo.contains(task->GetIdentifier()));\n+        } else {\n+            const ui64 internalGroupId = *internalGroupIdOptional;\n+            auto allocationInfo = RegisterAllocationImpl(internalGroupId, task, stage);\n+\n+            if (allocationInfo->GetAllocationStatus() != EAllocationStatus::Waiting) {\n+            } else if (WaitAllocations.GetMinGroupId().value_or(internalGroupId) < internalGroupId) {\n+                WaitAllocations.AddAllocation(internalGroupId, allocationInfo);\n+            } else if (allocationInfo->IsAllocatable(0) || (isPriorityProcess && internalGroupId == GroupIds.GetMinInternalIdVerified())) {\n+                Y_UNUSED(WaitAllocations.RemoveAllocation(internalGroupId, allocationInfo));\n+                if (!allocationInfo->Allocate(OwnerActorId)) {\n+                    UnregisterAllocation(allocationInfo->GetIdentifier());\n+                }\n+            } else {\n+                WaitAllocations.AddAllocation(internalGroupId, allocationInfo);\n+            }\n+        }\n+    }\n+\n+    bool UpdateAllocation(const ui64 allocationId, const ui64 volume) {\n+        GetAllocationInfoVerified(allocationId).SetAllocatedVolume(volume);\n+        return true;\n+    }\n+\n+    bool TryAllocateWaiting(const bool isPriorityProcess, const ui32 allocationsCountLimit) {\n+        return WaitAllocations.Allocate(isPriorityProcess, *this, allocationsCountLimit);\n+    }\n+\n+    bool UnregisterAllocation(const ui64 allocationId) {\n+        ui64 memoryAllocated = 0;\n+        auto it = AllocationInfo.find(allocationId);\n+        AFL_VERIFY(it != AllocationInfo.end());\n+        bool waitFlag = false;\n+        const ui64 internalGroupId = it->second->GetAllocationInternalGroupId();\n+        switch (it->second->GetAllocationStatus()) {\n+            case EAllocationStatus::Allocated:\n+            case EAllocationStatus::Failed:\n+                AFL_VERIFY(!WaitAllocations.RemoveAllocation(internalGroupId, it->second));\n+                break;\n+            case EAllocationStatus::Waiting:\n+                AFL_VERIFY(WaitAllocations.RemoveAllocation(internalGroupId, it->second));\n+                waitFlag = true;\n+                break;\n+        }\n+        AFL_DEBUG(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"allocation_unregister\")(\"allocation_id\", allocationId)(\"wait\", waitFlag)(\n+            \"internal_group_id\", internalGroupId)(\"allocation_status\", it->second->GetAllocationStatus());\n+        memoryAllocated = it->second->GetAllocatedVolume();\n+        AllocationInfo.erase(it);\n+        return !!memoryAllocated;\n+    }\n+\n+    void UnregisterGroup(const bool isPriorityProcess, const ui64 externalGroupId) {\n+        const ui64 internalGroupId = GroupIds.ExtractInternalIdVerified(externalGroupId);\n+        AFL_INFO(NKikimrServices::GROUPED_MEMORY_LIMITER)(\"event\", \"remove_group\")(\"external_group_id\", externalGroupId)(\n+            \"internal_group_id\", internalGroupId);\n+        UnregisterGroupImpl(internalGroupId);\n+        if (isPriorityProcess && (internalGroupId < GroupIds.GetMinInternalIdDef(internalGroupId))) {\n+            Y_UNUSED(TryAllocateWaiting(isPriorityProcess, 0));\n+        }\n+    }\n+\n+    void RegisterGroup(const ui64 externalGroupId) {\n+        Y_UNUSED(GroupIds.RegisterExternalId(externalGroupId));\n+    }\n+};\n+\n+class TProcessMemory {\n+private:\n+    const ui64 ExternalProcessId;\n+\n+    const NActors::TActorId OwnerActorId;\n+    bool PriorityProcessFlag = false;\n+\n+    YDB_ACCESSOR(ui32, LinksCount, 1);\n+    YDB_READONLY_DEF(std::vector<std::shared_ptr<TStageFeatures>>, Stages);\n+    const std::shared_ptr<TStageFeatures> DefaultStage;\n+    THashMap<ui64, std::shared_ptr<TProcessMemoryScope>> AllocationScopes;\n+\n+    TProcessMemoryScope* GetAllocationScopeOptional(const ui64 externalScopeId) const {\n+        auto it = AllocationScopes.find(externalScopeId);\n+        if (it == AllocationScopes.end()) {\n+            return nullptr;\n+        }\n+        return it->second.get();\n+    }\n+\n+    TProcessMemoryScope& GetAllocationScopeVerified(const ui64 externalScopeId) const {\n+        return *TValidator::CheckNotNull(GetAllocationScopeOptional(externalScopeId));\n+    }\n+\n+public:\n+    bool IsPriorityProcess() const {\n+        return PriorityProcessFlag;\n+    }\n+\n+    bool UpdateAllocation(const ui64 externalScopeId, const ui64 allocationId, const ui64 volume) {\n+        return GetAllocationScopeVerified(externalScopeId).UpdateAllocation(allocationId, volume);\n+    }\n+\n+    void RegisterAllocation(\n+        const ui64 externalScopeId, const ui64 externalGroupId, const std::shared_ptr<IAllocation>& task, const std::optional<ui32>& stageIdx) {\n+        AFL_VERIFY(task);\n+        std::shared_ptr<TStageFeatures> stage;\n+        if (Stages.empty()) {\n+            AFL_VERIFY(!stageIdx);\n+            stage = DefaultStage;\n+        } else {\n+            AFL_VERIFY(stageIdx);\n+            AFL_VERIFY(*stageIdx < Stages.size());\n+            stage = Stages[*stageIdx];\n+        }\n+        AFL_VERIFY(stage);\n+        auto& scope = GetAllocationScopeVerified(externalScopeId);\n+        scope.RegisterAllocation(IsPriorityProcess(), externalGroupId, task, stage);\n+    }\n+\n+    bool UnregisterAllocation(const ui64 externalScopeId, const ui64 allocationId) {\n+        if (auto* scope = GetAllocationScopeOptional(externalScopeId)) {\n+            return scope->UnregisterAllocation(allocationId);\n+        }\n+        return false;\n+    }\n+\n+    void UnregisterGroup(const ui64 externalScopeId, const ui64 externalGroupId) {\n+        if (auto* scope = GetAllocationScopeOptional(externalScopeId)) {\n+            scope->UnregisterGroup(IsPriorityProcess(), externalGroupId);\n+        }\n+    }\n+\n+    void RegisterGroup(const ui64 externalScopeId, const ui64 externalGroupId) {\n+        GetAllocationScopeVerified(externalScopeId).RegisterGroup(externalGroupId);\n+    }\n+\n+    void UnregisterScope(const ui64 externalScopeId) {\n+        auto it = AllocationScopes.find(externalScopeId);\n+        AFL_VERIFY(it != AllocationScopes.end());\n+        if (it->second->Unregister()) {\n+            AllocationScopes.erase(it);\n+        }\n+        \n+    }\n+\n+    void RegisterScope(const ui64 externalScopeId) {\n+        auto it = AllocationScopes.find(externalScopeId);\n+        if (it == AllocationScopes.end()) {\n+            AFL_VERIFY(AllocationScopes.emplace(externalScopeId, std::make_shared<TProcessMemoryScope>(ExternalProcessId, externalScopeId, OwnerActorId)).second);\n+        } else {\n+            it->second->Register();\n+        }\n+        \n+    }\n+\n+    void SetPriorityProcess() {\n+        AFL_VERIFY(!PriorityProcessFlag);\n+        PriorityProcessFlag = true;\n+    }\n+\n+    TProcessMemory(const ui64 externalProcessId, const NActors::TActorId& ownerActorId, const bool isPriority,\n+        const std::vector<std::shared_ptr<TStageFeatures>>& stages, const std::shared_ptr<TStageFeatures>& defaultStage)\n+        : ExternalProcessId(externalProcessId)\n+        , OwnerActorId(ownerActorId)\n+        , PriorityProcessFlag(isPriority)\n+        , Stages(stages)\n+        , DefaultStage(defaultStage) {\n+    }\n+\n+    bool TryAllocateWaiting(const ui32 allocationsCountLimit) {\n+        bool allocated = false;\n+        for (auto&& i : AllocationScopes) {\n+            if (i.second->TryAllocateWaiting(IsPriorityProcess(), allocationsCountLimit)) {\n+                allocated = true;\n+            }\n+        }\n+        return allocated;\n+    }\n+\n+    void Unregister() {\n+        for (auto&& i : AllocationScopes) {\n+            Y_UNUSED(i.second->Unregister());\n+        }\n+        AllocationScopes.clear();\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/ya.make b/ydb/core/tx/limiter/grouped_memory/service/ya.make\nnew file mode 100644\nindex 000000000000..d67332688426\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/service/ya.make\n@@ -0,0 +1,20 @@\n+LIBRARY()\n+\n+SRCS(\n+    actor.cpp\n+    manager.cpp\n+    counters.cpp\n+    group.cpp\n+    process.cpp\n+    allocation.cpp\n+    ids.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/protos\n+    ydb/core/tx/columnshard/counters/common\n+)\n+\n+GENERATE_ENUM_SERIALIZATION(allocation.h)\n+\n+END()\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/abstract.cpp b/ydb/core/tx/limiter/grouped_memory/usage/abstract.cpp\nnew file mode 100644\nindex 000000000000..2d72f0039846\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/abstract.cpp\n@@ -0,0 +1,79 @@\n+#include \"abstract.h\"\n+#include \"events.h\"\n+\n+#include <ydb/library/actors/core/log.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+TAllocationGuard::~TAllocationGuard() {\n+    if (TlsActivationContext && !Released) {\n+        NActors::TActivationContext::AsActorContext().Send(\n+            ActorId, std::make_unique<NEvents::TEvExternal::TEvFinishTask>(ProcessId, ScopeId, AllocationId));\n+    }\n+}\n+\n+void TAllocationGuard::Update(const ui64 newVolume) {\n+    AFL_VERIFY(!Released);\n+    Memory = newVolume;\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(\n+            ActorId, std::make_unique<NEvents::TEvExternal::TEvUpdateTask>(ProcessId, ScopeId, AllocationId, newVolume));\n+    }\n+}\n+\n+bool IAllocation::OnAllocated(std::shared_ptr<TAllocationGuard>&& guard, const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) {\n+    AFL_VERIFY(!Allocated);\n+    Allocated = true;\n+    AFL_VERIFY(allocation);\n+    AFL_VERIFY(guard);\n+    return DoOnAllocated(std::move(guard), allocation);\n+}\n+\n+TGroupGuard::~TGroupGuard() {\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(\n+            ActorId, std::make_unique<NEvents::TEvExternal::TEvFinishGroup>(ProcessId, ExternalScopeId, GroupId));\n+    }\n+}\n+\n+TGroupGuard::TGroupGuard(const NActors::TActorId& actorId, const ui64 processId, const ui64 externalScopeId, const ui64 groupId)\n+    : ActorId(actorId)\n+    , ProcessId(processId)\n+    , ExternalScopeId(externalScopeId)\n+    , GroupId(groupId) {\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(\n+            ActorId, std::make_unique<NEvents::TEvExternal::TEvStartGroup>(ProcessId, ExternalScopeId, GroupId));\n+    }\n+}\n+\n+TProcessGuard::~TProcessGuard() {\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(ActorId, std::make_unique<NEvents::TEvExternal::TEvFinishProcess>(ProcessId));\n+    }\n+}\n+\n+TProcessGuard::TProcessGuard(const NActors::TActorId& actorId, const ui64 processId, const std::vector<std::shared_ptr<TStageFeatures>>& stages)\n+    : ActorId(actorId)\n+    , ProcessId(processId) {\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(ActorId, std::make_unique<NEvents::TEvExternal::TEvStartProcess>(ProcessId, stages));\n+    }\n+}\n+\n+TScopeGuard::~TScopeGuard() {\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(ActorId, std::make_unique<NEvents::TEvExternal::TEvFinishProcessScope>(ProcessId, ScopeId));\n+    }\n+}\n+\n+TScopeGuard::TScopeGuard(const NActors::TActorId& actorId, const ui64 processId, const ui64 scopeId)\n+    : ActorId(actorId)\n+    , ProcessId(processId)\n+    , ScopeId(scopeId) {\n+    if (TlsActivationContext) {\n+        NActors::TActivationContext::AsActorContext().Send(ActorId, std::make_unique<NEvents::TEvExternal::TEvStartProcessScope>(ProcessId, ScopeId));\n+    }\n+}\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/abstract.h b/ydb/core/tx/limiter/grouped_memory/usage/abstract.h\nnew file mode 100644\nindex 000000000000..d92120f46fb6\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/abstract.h\n@@ -0,0 +1,223 @@\n+#pragma once\n+#include <ydb/core/tx/limiter/grouped_memory/service/counters.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/actors/core/actor.h>\n+#include <ydb/library/actors/core/actorid.h>\n+#include <ydb/library/actors/core/log.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TStageFeatures;\n+\n+class TGroupGuard {\n+private:\n+    const NActors::TActorId ActorId;\n+    YDB_READONLY(ui64, ProcessId, 0);\n+    YDB_READONLY(ui64, ExternalScopeId, 0);\n+    YDB_READONLY(ui64, GroupId, 0);\n+\n+public:\n+    TGroupGuard(const NActors::TActorId& actorId, const ui64 processId, const ui64 externalScopeId, const ui64 groupId);\n+\n+    ~TGroupGuard();\n+};\n+\n+class TProcessGuard {\n+private:\n+    const NActors::TActorId ActorId;\n+    YDB_READONLY(ui64, ProcessId, 0);\n+\n+public:\n+    TProcessGuard(const NActors::TActorId& actorId, const ui64 processId, const std::vector<std::shared_ptr<TStageFeatures>>& stages);\n+\n+    ~TProcessGuard();\n+};\n+\n+class TScopeGuard {\n+private:\n+    const NActors::TActorId ActorId;\n+    YDB_READONLY(ui64, ProcessId, 0);\n+    YDB_READONLY(ui64, ScopeId, 0);\n+\n+public:\n+    TScopeGuard(const NActors::TActorId& actorId, const ui64 processId, const ui64 scopeId);\n+\n+    ~TScopeGuard();\n+};\n+\n+class TAllocationGuard {\n+private:\n+    const NActors::TActorId ActorId;\n+    YDB_READONLY(ui64, ProcessId, 0)\n+    YDB_READONLY(ui64, ScopeId, 0)\n+    YDB_READONLY(ui64, AllocationId, 0)\n+    YDB_READONLY(ui64, Memory, 0)\n+    bool Released = false;\n+\n+public:\n+    TAllocationGuard(const ui64 processId, const ui64 scopeId, const ui64 allocationId, const NActors::TActorId actorId, const ui64 memory)\n+        : ActorId(actorId)\n+        , ProcessId(processId)\n+        , ScopeId(scopeId)\n+        , AllocationId(allocationId)\n+        , Memory(memory) {\n+    }\n+\n+    void Release() {\n+        AFL_VERIFY(!Released);\n+        Released = true;\n+    }\n+\n+    void Update(const ui64 newVolume);\n+\n+    ~TAllocationGuard();\n+};\n+\n+class TPositiveControlInteger {\n+private:\n+    ui64 Value = 0;\n+\n+public:\n+    void Add(const ui64 value) {\n+        Value += value;\n+    }\n+    void Sub(const ui64 value) {\n+        AFL_VERIFY(value <= Value);\n+        Value -= value;\n+    }\n+    ui64 Val() const {\n+        return Value;\n+    }\n+};\n+\n+class TStageFeatures {\n+private:\n+    YDB_READONLY_DEF(TString, Name);\n+    YDB_READONLY(ui64, Limit, 0);\n+    YDB_ACCESSOR_DEF(TPositiveControlInteger, Usage);\n+    YDB_ACCESSOR_DEF(TPositiveControlInteger, Waiting);\n+    std::shared_ptr<TStageFeatures> Owner;\n+    std::shared_ptr<TStageCounters> Counters;\n+\n+public:\n+    TString DebugString() const {\n+        TStringBuilder result;\n+        result << \"name=\" << Name << \";limit=\" << Limit << \";\";\n+        if (Owner) {\n+            result << \"owner=\" << Owner->DebugString() << \";\";\n+        }\n+        return result;\n+    }\n+\n+    ui64 GetFullMemory() const {\n+        return Usage.Val() + Waiting.Val();\n+    }\n+\n+    TStageFeatures(\n+        const TString& name, const ui64 limit, const std::shared_ptr<TStageFeatures>& owner, const std::shared_ptr<TStageCounters>& counters)\n+        : Name(name)\n+        , Limit(limit)\n+        , Owner(owner)\n+        , Counters(counters) {\n+    }\n+\n+    void Allocate(const ui64 volume) {\n+        Waiting.Sub(volume);\n+        Usage.Add(volume);\n+        if (Counters) {\n+            Counters->Add(volume, true);\n+            Counters->Sub(volume, false);\n+        }\n+        if (Owner) {\n+            Owner->Allocate(volume);\n+        }\n+    }\n+\n+    void Free(const ui64 volume, const bool allocated) {\n+        if (Counters) {\n+            Counters->Sub(volume, allocated);\n+        }\n+        if (allocated) {\n+            Usage.Sub(volume);\n+        } else {\n+            Waiting.Sub(volume);\n+        }\n+\n+        if (Owner) {\n+            Owner->Free(volume, allocated);\n+        }\n+    }\n+\n+    void UpdateVolume(const ui64 from, const ui64 to, const bool allocated) {\n+        if (Counters) {\n+            Counters->Sub(from, allocated);\n+            Counters->Add(to, allocated);\n+        }\n+        if (allocated) {\n+            Usage.Sub(from);\n+            Usage.Add(to);\n+        } else {\n+            Waiting.Sub(from);\n+            Waiting.Add(to);\n+        }\n+\n+        if (Owner) {\n+            Owner->UpdateVolume(from, to, allocated);\n+        }\n+    }\n+\n+    bool IsAllocatable(const ui64 volume, const ui64 additional) const {\n+        if (Limit < additional + Usage.Val() + volume) {\n+            return false;\n+        }\n+        if (Owner) {\n+            return Owner->IsAllocatable(volume, additional);\n+        }\n+        return true;\n+    }\n+\n+    void Add(const ui64 volume, const bool allocated) {\n+        if (Counters) {\n+            Counters->Add(volume, allocated);\n+        }\n+        if (allocated) {\n+            Usage.Add(volume);\n+        } else {\n+            Waiting.Add(volume);\n+        }\n+\n+        if (Owner) {\n+            Owner->Add(volume, allocated);\n+        }\n+    }\n+};\n+\n+class IAllocation {\n+private:\n+    static inline TAtomicCounter Counter = 0;\n+    YDB_READONLY(ui64, Identifier, Counter.Inc());\n+    YDB_READONLY(ui64, Memory, 0);\n+    bool Allocated = false;\n+    virtual bool DoOnAllocated(\n+        std::shared_ptr<TAllocationGuard>&& guard, const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) = 0;\n+\n+public:\n+    virtual ~IAllocation() = default;\n+    IAllocation(const ui64 mem)\n+        : Memory(mem) {\n+    }\n+\n+    void ResetAllocation() {\n+        Allocated = false;\n+    }\n+\n+    bool IsAllocated() const {\n+        return Allocated;\n+    }\n+\n+    [[nodiscard]] bool OnAllocated(\n+        std::shared_ptr<TAllocationGuard>&& guard, const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation);\n+};\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/config.cpp b/ydb/core/tx/limiter/grouped_memory/usage/config.cpp\nnew file mode 100644\nindex 000000000000..17fe55975744\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/config.cpp\n@@ -0,0 +1,20 @@\n+#include \"config.h\"\n+#include <util/string/builder.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+bool TConfig::DeserializeFromProto(const NKikimrConfig::TGroupedMemoryLimiterConfig& config) {\n+    if (config.HasMemoryLimit()) {\n+        MemoryLimit = config.GetMemoryLimit();\n+    }\n+    Enabled = config.GetEnabled();\n+    return true;\n+}\n+\n+TString TConfig::DebugString() const {\n+    TStringBuilder sb;\n+    sb << \"MemoryLimit=\" << MemoryLimit << \";Enabled=\" << Enabled << \";\";\n+    return sb;\n+}\n+\n+}\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/config.h b/ydb/core/tx/limiter/grouped_memory/usage/config.h\nnew file mode 100644\nindex 000000000000..91a9b5bc7afe\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/config.h\n@@ -0,0 +1,27 @@\n+#pragma once\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/core/protos/config.pb.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+class TConfig {\n+private:\n+    YDB_READONLY(bool, Enabled, true);\n+    YDB_READONLY(ui64, MemoryLimit, ui64(3) << 30);\n+\n+public:\n+\n+    static TConfig BuildDisabledConfig() {\n+        TConfig result;\n+        result.Enabled = false;\n+        return result;\n+    }\n+\n+    bool IsEnabled() const {\n+        return Enabled;\n+    }\n+    bool DeserializeFromProto(const NKikimrConfig::TGroupedMemoryLimiterConfig& config);\n+    TString DebugString() const;\n+};\n+\n+}\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/events.cpp b/ydb/core/tx/limiter/grouped_memory/usage/events.cpp\nnew file mode 100644\nindex 000000000000..cafd00f2bd82\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/events.cpp\n@@ -0,0 +1,5 @@\n+#include \"events.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager::NEvents {\n+\n+}\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/events.h b/ydb/core/tx/limiter/grouped_memory/usage/events.h\nnew file mode 100644\nindex 000000000000..d3a8200c584c\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/events.h\n@@ -0,0 +1,150 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+#include <ydb/core/base/events.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/actors/core/event_local.h>\n+#include <ydb/library/actors/core/events.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager::NEvents {\n+struct TEvExternal {\n+    enum EEv {\n+        EvStartAllocationTask = EventSpaceBegin(TKikimrEvents::ES_GROUPED_ALLOCATIONS_MANAGER),\n+        EvFinishAllocationTask,\n+        EvStartAllocationGroup,\n+        EvFinishAllocationGroup,\n+        EvUpdateAllocationTask,\n+        EvStartAllocationProcess,\n+        EvFinishAllocationProcess,\n+        EvStartAllocationProcessScope,\n+        EvFinishAllocationProcessScope,\n+        EvEnd\n+    };\n+\n+    class TEvStartTask: public NActors::TEventLocal<TEvStartTask, EvStartAllocationTask> {\n+    private:\n+        YDB_READONLY_DEF(std::vector<std::shared_ptr<IAllocation>>, Allocations);\n+        YDB_READONLY_DEF(std::optional<ui32>, StageFeaturesIdx);\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui64, ExternalScopeId, 0);\n+        YDB_READONLY(ui64, ExternalGroupId, 0);\n+\n+    public:\n+        explicit TEvStartTask(const ui64 externalProcessId, const ui64 externalScopeId,\n+            const ui64 externalGroupId, const std::vector<std::shared_ptr<IAllocation>>& allocations,\n+            const std::optional<ui32>& stageFeaturesIdx)\n+            : Allocations(allocations)\n+            , StageFeaturesIdx(stageFeaturesIdx)\n+            , ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId)\n+            , ExternalGroupId(externalGroupId) {\n+            AFL_VERIFY(Allocations.size());\n+        }\n+    };\n+\n+    class TEvFinishTask: public NActors::TEventLocal<TEvFinishTask, EvFinishAllocationTask> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui64, ExternalScopeId, 0);\n+        YDB_READONLY(ui64, AllocationId, 0);\n+\n+    public:\n+        explicit TEvFinishTask(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 allocationId)\n+            : ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId)\n+            , AllocationId(allocationId) {\n+        }\n+    };\n+\n+    class TEvUpdateTask: public NActors::TEventLocal<TEvUpdateTask, EvUpdateAllocationTask> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui64, ExternalScopeId, 0);\n+        YDB_READONLY(ui64, AllocationId, 0);\n+        YDB_READONLY(ui64, Volume, 0);\n+\n+    public:\n+        explicit TEvUpdateTask(const ui64 externalProcessId, const ui64 externalScopeId, const ui64 allocationId, const ui64 volume)\n+            : ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId)\n+            , AllocationId(allocationId)\n+            , Volume(volume) {\n+        }\n+    };\n+\n+    class TEvFinishGroup: public NActors::TEventLocal<TEvFinishGroup, EvFinishAllocationGroup> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui32, ExternalScopeId, 0);\n+        YDB_READONLY(ui64, ExternalGroupId, 0);\n+\n+    public:\n+        explicit TEvFinishGroup(const ui64 externalProcessId, const ui32 externalScopeId, const ui64 externalGroupId)\n+            : ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId)\n+            , ExternalGroupId(externalGroupId) {\n+        }\n+    };\n+\n+    class TEvStartGroup: public NActors::TEventLocal<TEvStartGroup, EvStartAllocationGroup> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui32, ExternalScopeId, 0);\n+        YDB_READONLY(ui64, ExternalGroupId, 0);\n+\n+    public:\n+        explicit TEvStartGroup(const ui64 externalProcessId, const ui32 externalScopeId, const ui64 externalGroupId)\n+            : ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId)\n+            , ExternalGroupId(externalGroupId) {\n+        }\n+    };\n+\n+    class TEvFinishProcess: public NActors::TEventLocal<TEvFinishProcess, EvFinishAllocationProcess> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+\n+    public:\n+        explicit TEvFinishProcess(const ui64 externalProcessId)\n+            : ExternalProcessId(externalProcessId) {\n+        }\n+    };\n+\n+    class TEvStartProcess: public NActors::TEventLocal<TEvStartProcess, EvStartAllocationProcess> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY_DEF(std::vector<std::shared_ptr<TStageFeatures>>, Stages);\n+    public:\n+        explicit TEvStartProcess(const ui64 externalProcessId, const std::vector<std::shared_ptr<TStageFeatures>>& stages)\n+            : ExternalProcessId(externalProcessId)\n+            , Stages(stages) {\n+        }\n+    };\n+\n+    class TEvFinishProcessScope: public NActors::TEventLocal<TEvFinishProcessScope, EvFinishAllocationProcessScope> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui64, ExternalScopeId, 0);\n+\n+    public:\n+        explicit TEvFinishProcessScope(const ui64 externalProcessId, const ui64 externalScopeId)\n+            : ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId)\n+        {\n+        }\n+    };\n+\n+    class TEvStartProcessScope: public NActors::TEventLocal<TEvStartProcessScope, EvStartAllocationProcessScope> {\n+    private:\n+        YDB_READONLY(ui64, ExternalProcessId, 0);\n+        YDB_READONLY(ui64, ExternalScopeId, 0);\n+\n+    public:\n+        explicit TEvStartProcessScope(const ui64 externalProcessId, const ui64 externalScopeId)\n+            : ExternalProcessId(externalProcessId)\n+            , ExternalScopeId(externalScopeId) {\n+        }\n+    };\n+};\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager::NEvents\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/service.cpp b/ydb/core/tx/limiter/grouped_memory/usage/service.cpp\nnew file mode 100644\nindex 000000000000..affe243f11bb\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/service.cpp\n@@ -0,0 +1,5 @@\n+#include \"service.h\"\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+}\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/service.h b/ydb/core/tx/limiter/grouped_memory/usage/service.h\nnew file mode 100644\nindex 000000000000..8192743218b1\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/service.h\n@@ -0,0 +1,102 @@\n+#pragma once\n+#include \"abstract.h\"\n+#include \"config.h\"\n+#include \"events.h\"\n+\n+#include <ydb/core/tx/limiter/grouped_memory/service/actor.h>\n+\n+#include <ydb/library/actors/core/actor.h>\n+#include <ydb/library/actors/core/actorid.h>\n+\n+namespace NKikimr::NOlap::NGroupedMemoryManager {\n+\n+template <class TMemoryLimiterPolicy>\n+class TServiceOperatorImpl {\n+private:\n+    TConfig ServiceConfig = TConfig::BuildDisabledConfig();\n+    std::shared_ptr<TCounters> Counters;\n+    std::shared_ptr<TStageFeatures> DefaultStageFeatures = std::make_shared<TStageFeatures>(\"DEFAULT\", ((ui64)3) << 30, nullptr, nullptr);\n+    using TSelf = TServiceOperatorImpl<TMemoryLimiterPolicy>;\n+    static void Register(const TConfig& serviceConfig, TIntrusivePtr<::NMonitoring::TDynamicCounters> counters) {\n+        Singleton<TSelf>()->Counters = std::make_shared<TCounters>(counters, TMemoryLimiterPolicy::Name);\n+        Singleton<TSelf>()->ServiceConfig = serviceConfig;\n+        Singleton<TSelf>()->DefaultStageFeatures = std::make_shared<TStageFeatures>(\n+            \"GLOBAL\", serviceConfig.GetMemoryLimit(), nullptr, Singleton<TSelf>()->Counters->BuildStageCounters(\"general\"));\n+    }\n+    static const TString& GetMemoryLimiterName() {\n+        Y_ABORT_UNLESS(TMemoryLimiterPolicy::Name.size() == 4);\n+        return TMemoryLimiterPolicy::Name;\n+    }\n+\n+public:\n+    static std::shared_ptr<TStageFeatures> BuildStageFeatures(const TString& name, const ui64 limit) {\n+        if (!IsEnabled()) {\n+            return Singleton<TSelf>()->DefaultStageFeatures;\n+        } else {\n+            AFL_VERIFY(Singleton<TSelf>()->DefaultStageFeatures);\n+            return std::make_shared<TStageFeatures>(\n+                name, limit, Singleton<TSelf>()->DefaultStageFeatures, Singleton<TSelf>()->Counters->BuildStageCounters(name));\n+        }\n+    }\n+\n+    static std::shared_ptr<TStageFeatures> GetDefaultStageFeatures() {\n+        AFL_VERIFY(Singleton<TSelf>()->DefaultStageFeatures);\n+        return Singleton<TSelf>()->DefaultStageFeatures;\n+    }\n+\n+    static std::shared_ptr<TGroupGuard> BuildGroupGuard(const ui64 processId, const ui32 scopeId) {\n+        static TAtomicCounter counter = 0;\n+        auto& context = NActors::TActorContext::AsActorContext();\n+        const NActors::TActorId& selfId = context.SelfID;\n+        return std::make_shared<TGroupGuard>(MakeServiceId(selfId.NodeId()), processId, scopeId, counter.Inc());\n+    }\n+\n+    static std::shared_ptr<TScopeGuard> BuildScopeGuard(const ui64 processId, const ui32 scopeId) {\n+        auto& context = NActors::TActorContext::AsActorContext();\n+        const NActors::TActorId& selfId = context.SelfID;\n+        return std::make_shared<TScopeGuard>(MakeServiceId(selfId.NodeId()), processId, scopeId);\n+    }\n+\n+    static std::shared_ptr<TProcessGuard> BuildProcessGuard(const ui64 processId, const std::vector<std::shared_ptr<TStageFeatures>>& stages) {\n+        auto& context = NActors::TActorContext::AsActorContext();\n+        const NActors::TActorId& selfId = context.SelfID;\n+        return std::make_shared<TProcessGuard>(MakeServiceId(selfId.NodeId()), processId, stages);\n+    }\n+\n+    static bool SendToAllocation(const ui64 processId, const ui64 scopeId, const ui64 groupId,\n+        const std::vector<std::shared_ptr<IAllocation>>& tasks,\n+        const std::optional<ui32>& stageIdx) {\n+        auto& context = NActors::TActorContext::AsActorContext();\n+        const NActors::TActorId& selfId = context.SelfID;\n+        if (TSelf::IsEnabled()) {\n+            context.Send(MakeServiceId(selfId.NodeId()), new NEvents::TEvExternal::TEvStartTask(processId, scopeId, groupId, tasks, stageIdx));\n+            return true;\n+        } else {\n+            for (auto&& i : tasks) {\n+                if (!i->IsAllocated()) {\n+                    AFL_VERIFY(i->OnAllocated(std::make_shared<TAllocationGuard>(0, 0, 0, NActors::TActorId(), i->GetMemory()), i));\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+    static bool IsEnabled() {\n+        return Singleton<TSelf>()->ServiceConfig.IsEnabled();\n+    }\n+    static NActors::TActorId MakeServiceId(const ui32 nodeId) {\n+        return NActors::TActorId(nodeId, \"SrvcMlmt\" + GetMemoryLimiterName());\n+    }\n+    static NActors::IActor* CreateService(const TConfig& config, TIntrusivePtr<::NMonitoring::TDynamicCounters> signals) {\n+        Register(config, signals);\n+        return new TMemoryLimiterActor(config, GetMemoryLimiterName(), Singleton<TSelf>()->Counters, Singleton<TSelf>()->DefaultStageFeatures);\n+    }\n+};\n+\n+class TScanMemoryLimiterPolicy {\n+public:\n+    static const inline TString Name = \"Scan\";\n+};\n+\n+using TScanMemoryLimiterOperator = TServiceOperatorImpl<TScanMemoryLimiterPolicy>;\n+\n+}   // namespace NKikimr::NOlap::NGroupedMemoryManager\ndiff --git a/ydb/core/tx/limiter/grouped_memory/usage/ya.make b/ydb/core/tx/limiter/grouped_memory/usage/ya.make\nnew file mode 100644\nindex 000000000000..4295b9f8cafe\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/usage/ya.make\n@@ -0,0 +1,16 @@\n+LIBRARY()\n+\n+SRCS(\n+    events.cpp\n+    config.cpp\n+    abstract.cpp\n+    service.cpp\n+)\n+\n+PEERDIR(\n+    ydb/library/actors/core\n+    ydb/services/metadata/request\n+    ydb/core/tx/limiter/grouped_memory/service\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/limiter/grouped_memory/ut/ut_manager.cpp b/ydb/core/tx/limiter/grouped_memory/ut/ut_manager.cpp\nnew file mode 100644\nindex 000000000000..277d62903205\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/ut/ut_manager.cpp\n@@ -0,0 +1,222 @@\n+#include <ydb/core/tx/limiter/grouped_memory/service/counters.h>\n+#include <ydb/core/tx/limiter/grouped_memory/service/manager.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/config.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n+\n+#include <ydb/library/actors/core/log.h>\n+\n+#include <library/cpp/monlib/dynamic_counters/counters.h>\n+#include <library/cpp/testing/unittest/registar.h>\n+#include <util/generic/object_counter.h>\n+\n+Y_UNIT_TEST_SUITE(GroupedMemoryLimiter) {\n+    using namespace NKikimr;\n+\n+    class TAllocation: public NOlap::NGroupedMemoryManager::IAllocation, public TObjectCounter<TAllocation> {\n+    private:\n+        using TBase = NOlap::NGroupedMemoryManager::IAllocation;\n+        virtual bool DoOnAllocated(std::shared_ptr<NOlap::NGroupedMemoryManager::TAllocationGuard>&& /*guard*/,\n+            const std::shared_ptr<NOlap::NGroupedMemoryManager::IAllocation>& /*allocation*/) override {\n+            return true;\n+        }\n+\n+    public:\n+        TAllocation(const ui64 mem)\n+            : TBase(mem) {\n+        }\n+    };\n+\n+    Y_UNIT_TEST(Simplest) {\n+        auto counters = std::make_shared<NOlap::NGroupedMemoryManager::TCounters>(MakeIntrusive<NMonitoring::TDynamicCounters>(), \"test\");\n+        NOlap::NGroupedMemoryManager::TConfig config;\n+        {\n+            NKikimrConfig::TGroupedMemoryLimiterConfig protoConfig;\n+            protoConfig.SetMemoryLimit(100);\n+            AFL_VERIFY(config.DeserializeFromProto(protoConfig));\n+        }\n+        std::unique_ptr<NActors::IActor> actor(\n+            NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::CreateService(config, MakeIntrusive<NMonitoring::TDynamicCounters>()));\n+        auto stage = NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::GetDefaultStageFeatures();\n+        auto manager = std::make_shared<NOlap::NGroupedMemoryManager::TManager>(NActors::TActorId(), config, \"test\", counters, stage);\n+        {\n+            auto alloc1 = std::make_shared<TAllocation>(50);\n+            manager->RegisterProcess(0, {});\n+            manager->RegisterProcessScope(0, 0);\n+            manager->RegisterGroup(0, 0, 1);\n+            manager->RegisterAllocation(0, 0, 1, alloc1, {});\n+            AFL_VERIFY(alloc1->IsAllocated());\n+            auto alloc1_1 = std::make_shared<TAllocation>(50);\n+            manager->RegisterAllocation(0, 0, 1, alloc1_1, {});\n+            AFL_VERIFY(alloc1_1->IsAllocated());\n+\n+            manager->RegisterGroup(0, 0, 2);\n+            auto alloc2 = std::make_shared<TAllocation>(50);\n+            manager->RegisterAllocation(0, 0, 2, alloc2, {});\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+\n+            manager->UnregisterAllocation(0, 0, alloc1->GetIdentifier());\n+            AFL_VERIFY(alloc2->IsAllocated());\n+            manager->UnregisterAllocation(0, 0, alloc2->GetIdentifier());\n+            manager->UnregisterAllocation(0, 0, alloc1_1->GetIdentifier());\n+            manager->UnregisterGroup(0, 0, 1);\n+            manager->UnregisterGroup(0, 0, 2);\n+            manager->UnregisterProcessScope(0, 0);\n+            manager->UnregisterProcess(0);\n+        }\n+        AFL_VERIFY(!stage->GetUsage().Val());\n+        AFL_VERIFY(manager->IsEmpty());\n+        AFL_VERIFY(!TObjectCounter<TAllocation>::ObjectCount());\n+    }\n+\n+    Y_UNIT_TEST(Simple) {\n+        auto counters = std::make_shared<NOlap::NGroupedMemoryManager::TCounters>(MakeIntrusive<NMonitoring::TDynamicCounters>(), \"test\");\n+        NOlap::NGroupedMemoryManager::TConfig config;\n+        {\n+            NKikimrConfig::TGroupedMemoryLimiterConfig protoConfig;\n+            protoConfig.SetMemoryLimit(100);\n+            AFL_VERIFY(config.DeserializeFromProto(protoConfig));\n+        }\n+        std::unique_ptr<NActors::IActor> actor(NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::CreateService(config, MakeIntrusive<NMonitoring::TDynamicCounters>()));\n+        auto stage = NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::GetDefaultStageFeatures();\n+        auto manager = std::make_shared<NOlap::NGroupedMemoryManager::TManager>(NActors::TActorId(), config, \"test\", counters, stage);\n+        {\n+            manager->RegisterProcess(0, {});\n+            manager->RegisterProcessScope(0, 0);\n+            auto alloc1 = std::make_shared<TAllocation>(10);\n+            manager->RegisterGroup(0, 0, 1);\n+            manager->RegisterAllocation(0, 0, 1, alloc1, {});\n+            AFL_VERIFY(alloc1->IsAllocated());\n+            auto alloc2 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterGroup(0, 0, 2);\n+            manager->RegisterAllocation(0, 0, 2, alloc2, {});\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+            auto alloc3 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterGroup(0, 0, 3);\n+            manager->RegisterAllocation(0, 0, 3, alloc3, {});\n+            AFL_VERIFY(alloc1->IsAllocated());\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+            AFL_VERIFY(!alloc3->IsAllocated());\n+            auto alloc1_1 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterAllocation(0, 0, 1, alloc1_1, {});\n+            AFL_VERIFY(alloc1_1->IsAllocated());\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+            manager->UnregisterAllocation(0, 0, alloc1_1->GetIdentifier());\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+            manager->UnregisterGroup(0, 0, 1);\n+            AFL_VERIFY(alloc2->IsAllocated());\n+\n+            manager->UnregisterAllocation(0, 0, alloc1->GetIdentifier());\n+            AFL_VERIFY(!alloc3->IsAllocated());\n+            manager->UnregisterGroup(0, 0, 2);\n+            manager->UnregisterAllocation(0, 0, alloc2->GetIdentifier());\n+            AFL_VERIFY(alloc3->IsAllocated());\n+            manager->UnregisterGroup(0, 0, 3);\n+            manager->UnregisterAllocation(0, 0, alloc3->GetIdentifier());\n+            manager->UnregisterProcessScope(0, 0);\n+            manager->UnregisterProcess(0);\n+        }\n+        AFL_VERIFY(!stage->GetUsage().Val());\n+        AFL_VERIFY(manager->IsEmpty());\n+        AFL_VERIFY(!TObjectCounter<TAllocation>::ObjectCount());\n+    }\n+\n+    Y_UNIT_TEST(CommonUsage) {\n+        auto counters = std::make_shared<NOlap::NGroupedMemoryManager::TCounters>(MakeIntrusive<NMonitoring::TDynamicCounters>(), \"test\");\n+        NOlap::NGroupedMemoryManager::TConfig config;\n+        {\n+            NKikimrConfig::TGroupedMemoryLimiterConfig protoConfig;\n+            protoConfig.SetMemoryLimit(100);\n+            AFL_VERIFY(config.DeserializeFromProto(protoConfig));\n+        }\n+        std::unique_ptr<NActors::IActor> actor(\n+            NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::CreateService(config, MakeIntrusive<NMonitoring::TDynamicCounters>()));\n+        auto stage = NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::GetDefaultStageFeatures();\n+        auto manager = std::make_shared<NOlap::NGroupedMemoryManager::TManager>(NActors::TActorId(), config, \"test\", counters, stage);\n+        {\n+            manager->RegisterProcess(0, {});\n+            manager->RegisterProcessScope(0, 0);\n+            manager->RegisterGroup(0, 0, 1);\n+            auto alloc0 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterAllocation(0, 0, 1, alloc0, {});\n+            auto alloc1 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterAllocation(0, 0, 1, alloc1, {});\n+            AFL_VERIFY(alloc0->IsAllocated());\n+            AFL_VERIFY(alloc1->IsAllocated());\n+\n+            manager->RegisterGroup(0, 0, 2);\n+            auto alloc2 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterAllocation(0, 0, 2, alloc0, {});\n+            manager->RegisterAllocation(0, 0, 2, alloc2, {});\n+            AFL_VERIFY(alloc0->IsAllocated());\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+\n+            auto alloc3 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterGroup(0, 0, 3);\n+            manager->RegisterAllocation(0, 0, 3, alloc0, {});\n+            manager->RegisterAllocation(0, 0, 3, alloc3, {});\n+            AFL_VERIFY(alloc0->IsAllocated());\n+            AFL_VERIFY(alloc1->IsAllocated());\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+            AFL_VERIFY(!alloc3->IsAllocated());\n+\n+            manager->UnregisterGroup(0, 0, 1);\n+            manager->UnregisterAllocation(0, 0, alloc1->GetIdentifier());\n+\n+            AFL_VERIFY(alloc0->IsAllocated());\n+            AFL_VERIFY(alloc2->IsAllocated());\n+            AFL_VERIFY(!alloc3->IsAllocated());\n+            manager->UnregisterGroup(0, 0, 2);\n+            manager->UnregisterAllocation(0, 0, alloc2->GetIdentifier());\n+            AFL_VERIFY(alloc0->IsAllocated());\n+            AFL_VERIFY(alloc3->IsAllocated());\n+\n+            manager->UnregisterGroup(0, 0, 3);\n+            manager->UnregisterAllocation(0, 0, alloc3->GetIdentifier());\n+            manager->UnregisterAllocation(0, 0, alloc0->GetIdentifier());\n+            manager->UnregisterProcess(0);\n+        }\n+        AFL_VERIFY(!stage->GetUsage().Val());\n+        AFL_VERIFY(manager->IsEmpty());\n+        AFL_VERIFY(!TObjectCounter<TAllocation>::ObjectCount());\n+    }\n+\n+    Y_UNIT_TEST(Update) {\n+        auto counters = std::make_shared<NOlap::NGroupedMemoryManager::TCounters>(MakeIntrusive<NMonitoring::TDynamicCounters>(), \"test\");\n+        NOlap::NGroupedMemoryManager::TConfig config;\n+        {\n+            NKikimrConfig::TGroupedMemoryLimiterConfig protoConfig;\n+            protoConfig.SetMemoryLimit(100);\n+            AFL_VERIFY(config.DeserializeFromProto(protoConfig));\n+        }\n+        std::unique_ptr<NActors::IActor> actor(\n+            NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::CreateService(config, MakeIntrusive<NMonitoring::TDynamicCounters>()));\n+        auto stage = NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::GetDefaultStageFeatures();\n+        auto manager = std::make_shared<NOlap::NGroupedMemoryManager::TManager>(NActors::TActorId(), config, \"test\", counters, stage);\n+        {\n+            manager->RegisterProcess(0, {});\n+            manager->RegisterProcessScope(0, 0);\n+            auto alloc1 = std::make_shared<TAllocation>(1000);\n+            manager->RegisterGroup(0, 0, 1);\n+            manager->RegisterAllocation(0, 0, 1, alloc1, {});\n+            AFL_VERIFY(alloc1->IsAllocated());\n+            auto alloc2 = std::make_shared<TAllocation>(10);\n+            manager->RegisterGroup(0, 0, 3);\n+            manager->RegisterAllocation(0, 0, 3, alloc2, {});\n+            AFL_VERIFY(!alloc2->IsAllocated());\n+\n+            manager->UpdateAllocation(0, 0, alloc1->GetIdentifier(), 10);\n+            AFL_VERIFY(alloc2->IsAllocated());\n+\n+            manager->UnregisterGroup(0, 0, 3);\n+            manager->UnregisterAllocation(0, 0, alloc2->GetIdentifier());\n+\n+            manager->UnregisterGroup(0, 0, 1);\n+            manager->UnregisterAllocation(0, 0, alloc1->GetIdentifier());\n+            manager->UnregisterProcess(0);\n+        }\n+        AFL_VERIFY(!stage->GetUsage().Val());\n+        AFL_VERIFY(manager->IsEmpty());\n+        AFL_VERIFY(!TObjectCounter<TAllocation>::ObjectCount());\n+    }\n+};\ndiff --git a/ydb/core/tx/limiter/grouped_memory/ut/ya.make b/ydb/core/tx/limiter/grouped_memory/ut/ya.make\nnew file mode 100644\nindex 000000000000..eeae3952e358\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/ut/ya.make\n@@ -0,0 +1,17 @@\n+UNITTEST_FOR(ydb/core/formats/arrow)\n+\n+SIZE(SMALL)\n+\n+PEERDIR(\n+    ydb/core/tx/limiter/grouped_memory/usage\n+    ydb/library/yql/public/udf/service/stub\n+    ydb/library/yql/parser/pg_wrapper\n+)\n+\n+SRCS(\n+    ut_manager.cpp\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+END()\ndiff --git a/ydb/core/tx/limiter/grouped_memory/ya.make b/ydb/core/tx/limiter/grouped_memory/ya.make\nnew file mode 100644\nindex 000000000000..2e071158a966\n--- /dev/null\n+++ b/ydb/core/tx/limiter/grouped_memory/ya.make\n@@ -0,0 +1,5 @@\n+RECURSE(\n+    ut\n+    service\n+    usage\n+)\ndiff --git a/ydb/core/tx/limiter/ya.make b/ydb/core/tx/limiter/ya.make\nnew file mode 100644\nindex 000000000000..c27ad41aa02b\n--- /dev/null\n+++ b/ydb/core/tx/limiter/ya.make\n@@ -0,0 +1,5 @@\n+RECURSE(\n+    grouped_memory\n+    service\n+    usage\n+)\ndiff --git a/ydb/core/tx/program/program.cpp b/ydb/core/tx/program/program.cpp\nindex a6dbce7fed75..a4ada441cd74 100644\n--- a/ydb/core/tx/program/program.cpp\n+++ b/ydb/core/tx/program/program.cpp\n@@ -330,7 +330,7 @@ NSsa::TAggregateAssign TProgramBuilder::MakeAggregate(const NSsa::TColumnInfo& n\n         }\n     } else if (func.ArgumentsSize() == 0 && func.GetId() == TId::AGG_COUNT) {\n         // COUNT(*) case\n-        return TAggregateAssign(name, EAggregate::Count);\n+        return TAggregateAssign(name, EAggregate::NumRows);\n     }\n     return TAggregateAssign(name); // !ok()\n }\n@@ -483,7 +483,7 @@ bool TProgramContainer::Init(const IColumnResolver& columnResolver, const NKikim\n     if (IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD)) {\n         TString out;\n         ::google::protobuf::TextFormat::PrintToString(programProto, &out);\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"program\", out);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"parse_program\")(\"program\", out);\n     }\n \n     if (programProto.HasKernels()) {\n@@ -496,6 +496,7 @@ bool TProgramContainer::Init(const IColumnResolver& columnResolver, const NKikim\n         }\n         return false;\n     }\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"program_parsed\")(\"result\", DebugString());\n \n     return true;\n }\ndiff --git a/ydb/core/tx/program/program.h b/ydb/core/tx/program/program.h\nindex 76fbe8702488..3ab18eccc9d1 100644\n--- a/ydb/core/tx/program/program.h\n+++ b/ydb/core/tx/program/program.h\n@@ -2,7 +2,7 @@\n \n #include \"registry.h\" \n #include <ydb/core/protos/flat_scheme_op.pb.h>\n-#include <ydb/core/formats/arrow/protos/ssa.pb.h>\n+#include <ydb/library/formats/arrow/protos/ssa.pb.h>\n #include <ydb/core/formats/arrow/program.h>\n #include <ydb/core/formats/arrow/custom_registry.h>\n #include <ydb/core/tablet_flat/flat_dbase_scheme.h>\n@@ -20,7 +20,6 @@ class IColumnResolver {\n     virtual ~IColumnResolver() = default;\n     virtual TString GetColumnName(ui32 id, bool required = true) const = 0;\n     virtual std::optional<ui32> GetColumnIdOptional(const TString& name) const = 0;\n-    virtual const NTable::TScheme::TTableSchema& GetSchema() const = 0;\n     virtual NSsa::TColumnInfo GetDefaultColumn() const = 0;\n };\n \n@@ -35,10 +34,6 @@ class TSchemaResolverColumnsOnly: public IColumnResolver {\n \n     virtual TString GetColumnName(ui32 id, bool required = true) const override;\n     virtual std::optional<ui32> GetColumnIdOptional(const TString& name) const override;\n-    virtual const NTable::TScheme::TTableSchema& GetSchema() const override {\n-        AFL_VERIFY(false);\n-        return Default<NTable::TScheme::TTableSchema>();\n-    }\n     virtual NSsa::TColumnInfo GetDefaultColumn() const override {\n         return NSsa::TColumnInfo::Original((ui32)NOlap::NPortion::TSpecialColumns::SPEC_COL_PLAN_STEP_INDEX, NOlap::NPortion::TSpecialColumns::SPEC_COL_PLAN_STEP);\n     }\ndiff --git a/ydb/core/tx/program/ya.make b/ydb/core/tx/program/ya.make\nindex 4e69528543a3..d8ef7ed60696 100644\n--- a/ydb/core/tx/program/ya.make\n+++ b/ydb/core/tx/program/ya.make\n@@ -8,7 +8,7 @@ SRCS(\n PEERDIR(\n     ydb/core/formats/arrow\n     ydb/core/protos\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/protos\n     ydb/core/tablet_flat\n     ydb/library/yql/minikql/comp_nodes\n     ydb/library/yql/core/arrow_kernels/registry\ndiff --git a/ydb/core/tx/schemeshard/olap/bg_tasks/tx_chain/session.h b/ydb/core/tx/schemeshard/olap/bg_tasks/tx_chain/session.h\nindex 1a56abe419e1..06c2b8939d22 100644\n--- a/ydb/core/tx/schemeshard/olap/bg_tasks/tx_chain/session.h\n+++ b/ydb/core/tx/schemeshard/olap/bg_tasks/tx_chain/session.h\n@@ -21,6 +21,9 @@ class TTxChainSession: public NKikimr::NOlap::NBackground::TSessionProtoAdapter<\n     YDB_READONLY_DEF(TTxChainData, TxData);\n     YDB_READONLY(ui32, StepForExecute, 0);\n     std::optional<ui64> CurrentTxId;\n+\n+    static const inline TFactory::TRegistrator<TTxChainSession> Registrator = TFactory::TRegistrator<TTxChainSession>(GetStaticClassName());\n+\n protected:\n     virtual TConclusion<std::unique_ptr<NActors::IActor>> DoCreateActor(const NKikimr::NOlap::NBackground::TStartContext& context) const override;\n     virtual TConclusionStatus DoDeserializeFromProto(const TProtoLogic& proto) override {\n@@ -48,6 +51,8 @@ class TTxChainSession: public NKikimr::NOlap::NBackground::TSessionProtoAdapter<\n         return result;\n     }\n public:\n+    TTxChainSession() = default;\n+\n     TTxChainSession(const TTxChainData& data)\n         : TxData(data)\n     {\ndiff --git a/ydb/core/tx/schemeshard/olap/columns/update.cpp b/ydb/core/tx/schemeshard/olap/columns/update.cpp\nindex 83e300176007..c66da237c712 100644\n--- a/ydb/core/tx/schemeshard/olap/columns/update.cpp\n+++ b/ydb/core/tx/schemeshard/olap/columns/update.cpp\n@@ -119,6 +119,11 @@ namespace NKikimr::NSchemeShard {\n             serializer.DeserializeFromProto(columnSchema.GetCompression()).Validate();\n             Serializer = serializer;\n         }\n+        if (columnSchema.HasDataAccessorConstructor()) {\n+            NArrow::NAccessor::TConstructorContainer container;\n+            AFL_VERIFY(container.DeserializeFromProto(columnSchema.GetDataAccessorConstructor()));\n+            AccessorConstructor = container;\n+        }\n         if (columnSchema.HasDictionaryEncoding()) {\n             auto settings = NArrow::NDictionary::TEncodingSettings::BuildFromProto(columnSchema.GetDictionaryEncoding());\n             Y_ABORT_UNLESS(settings.IsSuccess());\n@@ -140,6 +145,9 @@ namespace NKikimr::NSchemeShard {\n         if (Serializer) {\n             Serializer->SerializeToProto(*columnSchema.MutableSerializer());\n         }\n+        if (AccessorConstructor) {\n+            *columnSchema.MutableDataAccessorConstructor() = AccessorConstructor.SerializeToProto();\n+        }\n         if (DictionaryEncoding) {\n             *columnSchema.MutableDictionaryEncoding() = DictionaryEncoding->SerializeToProto();\n         }\n@@ -160,6 +168,14 @@ namespace NKikimr::NSchemeShard {\n                 return false;\n             }\n         }\n+        if (!!diffColumn.GetAccessorConstructor()) {\n+            auto conclusion = diffColumn.GetAccessorConstructor()->BuildConstructor();\n+            if (conclusion.IsFail()) {\n+                errors.AddError(conclusion.GetErrorMessage());\n+                return false;\n+            }\n+            AccessorConstructor = conclusion.DetachResult();\n+        }\n         if (diffColumn.GetStorageId()) {\n             StorageId = *diffColumn.GetStorageId();\n         }\ndiff --git a/ydb/core/tx/schemeshard/olap/columns/update.h b/ydb/core/tx/schemeshard/olap/columns/update.h\nindex ec463a69c7c2..84a728829d6e 100644\n--- a/ydb/core/tx/schemeshard/olap/columns/update.h\n+++ b/ydb/core/tx/schemeshard/olap/columns/update.h\n@@ -4,6 +4,7 @@\n #include <ydb/core/tx/schemeshard/olap/common/common.h>\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/core/scheme_types/scheme_type_info.h>\n+#include <ydb/core/formats/arrow/accessor/abstract/request.h>\n #include <ydb/core/formats/arrow/dictionary/object.h>\n #include <ydb/core/formats/arrow/serializer/abstract.h>\n #include <ydb/core/tx/columnshard/engines/scheme/defaults/common/scalar.h>\n@@ -17,6 +18,7 @@ class TOlapColumnDiff {\n     YDB_READONLY_DEF(NArrow::NDictionary::TEncodingDiff, DictionaryEncoding);\n     YDB_READONLY_DEF(std::optional<TString>, StorageId);\n     YDB_READONLY_DEF(std::optional<TString>, DefaultValue);\n+    YDB_READONLY_DEF(NArrow::NAccessor::TRequestedConstructorContainer, AccessorConstructor);\n public:\n     bool ParseFromRequest(const NKikimrSchemeOp::TOlapColumnDiff& columnSchema, IErrorCollector& errors) {\n         Name = columnSchema.GetName();\n@@ -30,6 +32,12 @@ class TOlapColumnDiff {\n         if (columnSchema.HasDefaultValue()) {\n             DefaultValue = columnSchema.GetDefaultValue();\n         }\n+        if (columnSchema.HasDataAccessorConstructor()) {\n+            if (!AccessorConstructor.DeserializeFromProto(columnSchema.GetDataAccessorConstructor())) {\n+                errors.AddError(\"cannot parse accessor constructor from proto\");\n+                return false;\n+            }\n+        }\n         if (columnSchema.HasSerializer()) {\n             if (!Serializer.DeserializeFromProto(columnSchema.GetSerializer())) {\n                 errors.AddError(\"cannot parse serializer diff from proto\");\n@@ -55,6 +63,7 @@ class TOlapColumnAdd {\n     YDB_READONLY_DEF(std::optional<NArrow::NSerialization::TSerializerContainer>, Serializer);\n     YDB_READONLY_DEF(std::optional<NArrow::NDictionary::TEncodingSettings>, DictionaryEncoding);\n     YDB_READONLY_DEF(NOlap::TColumnDefaultScalarValue, DefaultValue);\n+    YDB_READONLY_DEF(NArrow::NAccessor::TConstructorContainer, AccessorConstructor);\n public:\n     TOlapColumnAdd(const std::optional<ui32>& keyOrder)\n         : KeyOrder(keyOrder) {\ndiff --git a/ydb/core/tx/schemeshard/olap/layout/layout.h b/ydb/core/tx/schemeshard/olap/layout/layout.h\nindex b3e338af1014..087194ceb6c2 100644\n--- a/ydb/core/tx/schemeshard/olap/layout/layout.h\n+++ b/ydb/core/tx/schemeshard/olap/layout/layout.h\n@@ -15,48 +15,19 @@ template <class TSetElement, class THashCalcer>\n class TLayoutIdSet {\n private:\n     ui64 Hash = 0;\n-    std::set<TSetElement> Elements;\n+    THashSet<TSetElement> Elements;\n public:\n     TLayoutIdSet() = default;\n     TLayoutIdSet(const TSetElement elem) {\n         AddId(elem);\n     }\n \n-    typename std::set<TSetElement>::const_iterator begin() const {\n-        return Elements.begin();\n-    }\n-\n-    typename std::set<TSetElement>::const_iterator end() const {\n-        return Elements.end();\n-    }\n-\n     size_t Size() const {\n         return Elements.size();\n     }\n \n-    std::vector<TSetElement> GetIdsVector() const {\n-        return std::vector<TSetElement>(Elements.begin(), Elements.end());\n-    }\n-\n-    const std::set<TSetElement>& GetIds() const {\n-        return Elements;\n-    }\n-\n-    std::set<TSetElement> GetIds(const ui32 count) const {\n-        std::set<TSetElement> result;\n-        ui32 idx = 0;\n-        for (auto&& i : Elements) {\n-            if (++idx > count) {\n-                return result;\n-            }\n-            result.emplace(i);\n-        }\n-        return result;\n-    }\n-\n-    std::vector<TSetElement> GetIdsVector(const ui32 count) const {\n-        std::set<TSetElement> result = GetIds(count);\n-        return std::vector<TSetElement>(result.begin(), result.end());\n+    bool HasId(const TSetElement& id) const {\n+        return Elements.contains(id);\n     }\n \n     bool AddId(const TSetElement& id) {\n@@ -131,7 +102,7 @@ class TColumnTablesLayout {\n \n     void RemoveGroupsWithPathId(const TPathId& pathId) {\n         const auto pred = [&](const TTablesGroup& item) {\n-            return item.GetTableIds().GetIds().contains(pathId);\n+            return item.GetTableIds().HasId(pathId);\n         };\n         Groups.erase(std::remove_if(Groups.begin(), Groups.end(), pred), Groups.end());\n     }\ndiff --git a/ydb/core/tx/schemeshard/olap/manager/manager.cpp b/ydb/core/tx/schemeshard/olap/manager/manager.cpp\nindex 0f8b13cd0104..72a8c93c5f1c 100644\n--- a/ydb/core/tx/schemeshard/olap/manager/manager.cpp\n+++ b/ydb/core/tx/schemeshard/olap/manager/manager.cpp\n@@ -29,12 +29,12 @@ void TTablesStorage::OnRemoveObject(const TPathId& pathId, TColumnTableInfo::TPt\n     }\n }\n \n-const std::set<NKikimr::TPathId>& TTablesStorage::GetTablesWithTiering(const TString& tieringId) const {\n+const THashSet<TPathId>& TTablesStorage::GetTablesWithTiering(const TString& tieringId) const {\n     auto it = PathsByTieringId.find(tieringId);\n     if (it != PathsByTieringId.end()) {\n         return it->second;\n     } else {\n-        return Default<std::set<TPathId>>();\n+        return Default<THashSet<TPathId>>();\n     }\n }\n \ndiff --git a/ydb/core/tx/schemeshard/olap/manager/manager.h b/ydb/core/tx/schemeshard/olap/manager/manager.h\nindex 96ffc91204eb..0873a12da22d 100644\n--- a/ydb/core/tx/schemeshard/olap/manager/manager.h\n+++ b/ydb/core/tx/schemeshard/olap/manager/manager.h\n@@ -9,7 +9,7 @@ namespace NKikimr::NSchemeShard {\n class TTablesStorage {\n private:\n     THashMap<TPathId, TColumnTableInfo::TPtr> Tables;\n-    THashMap<TString, std::set<TPathId>> PathsByTieringId;\n+    THashMap<TString, THashSet<TPathId>> PathsByTieringId;\n     THashMap<ui64, TColumnTablesLayout::TTableIdsGroup> TablesByShard;\n \n     void OnAddObject(const TPathId& pathId, TColumnTableInfo::TPtr object);\n@@ -20,7 +20,7 @@ class TTablesStorage {\n \n     TColumnTablesLayout GetTablesLayout(const std::vector<ui64>& tabletIds) const;\n \n-    const std::set<TPathId>& GetTablesWithTiering(const TString& tieringId) const;\n+    const THashSet<TPathId>& GetTablesWithTiering(const TString& tieringId) const;\n \n     class TTableReadGuard {\n     protected:\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/alter/abstract/ya.make b/ydb/core/tx/schemeshard/olap/operations/alter/abstract/ya.make\nindex 66a40695a604..bb4459a412fd 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/alter/abstract/ya.make\n+++ b/ydb/core/tx/schemeshard/olap/operations/alter/abstract/ya.make\n@@ -12,6 +12,7 @@ PEERDIR(\n     ydb/library/accessor\n     ydb/core/protos\n     ydb/library/actors/wilson\n+    ydb/library/formats/arrow\n )\n \n YQL_LAST_ABI_VERSION()\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/alter/common/update.h b/ydb/core/tx/schemeshard/olap/operations/alter/common/update.h\nindex c33f18eb031b..fd10245bc284 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/alter/common/update.h\n+++ b/ydb/core/tx/schemeshard/olap/operations/alter/common/update.h\n@@ -2,6 +2,7 @@\n #include <ydb/core/tx/schemeshard/olap/operations/alter/abstract/update.h>\n #include <ydb/core/tx/schemeshard/olap/operations/alter/abstract/context.h>\n #include <ydb/core/tx/schemeshard/olap/table/table.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n \n namespace NKikimr::NSchemeShard::NOlap::NAlter {\n \n@@ -19,6 +20,16 @@ class TColumnTableUpdate: public ISSEntityUpdate {\n         return NKikimrTxColumnShard::ETransactionKind::TX_KIND_SCHEMA;\n     }\n     virtual TConclusionStatus DoInitializeImpl(const TUpdateInitializationContext& context) = 0;\n+\n+    bool IsAlterCompression(const TUpdateInitializationContext& context) const {\n+        for (const auto& alterColumn : context.GetModification()->GetAlterColumnTable().GetAlterSchema().GetAlterColumns()) {\n+            if (alterColumn.HasSerializer()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n protected:\n     virtual TConclusionStatus DoStartImpl(const TUpdateStartContext& /*context*/) {\n         return TConclusionStatus::Success();\n@@ -27,6 +38,9 @@ class TColumnTableUpdate: public ISSEntityUpdate {\n         return TConclusionStatus::Success();\n     }\n     virtual TConclusionStatus DoInitialize(const TUpdateInitializationContext& context) override final {\n+        if (!AppData()->FeatureFlags.GetEnableOlapCompression() && IsAlterCompression(context)) {\n+            return TConclusionStatus::Fail(\"Compression is disabled for OLAP tables\");\n+        }\n         if (!context.GetModification()->HasAlterColumnTable() && !context.GetModification()->HasAlterTable()) {\n             return TConclusionStatus::Fail(\"no update data\");\n         }\n@@ -52,6 +66,17 @@ class TColumnTableUpdate: public ISSEntityUpdate {\n         return result;\n     }\n \n+    bool CheckTargetSchema(const TOlapSchema& targetSchema) {\n+        if (!AppData()->FeatureFlags.GetEnableSparsedColumns()) {\n+            for (auto& [_, column]: targetSchema.GetColumns().GetColumns()) {\n+                if (column.GetDefaultValue().GetValue() || (column.GetAccessorConstructor().GetClassName() == NKikimr::NArrow::NAccessor::TGlobalConst::SparsedDataAccessorName)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n public:\n };\n \ndiff --git a/ydb/core/tx/schemeshard/olap/operations/alter/standalone/update.cpp b/ydb/core/tx/schemeshard/olap/operations/alter/standalone/update.cpp\nindex b94ff1888af2..2902534fbb24 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/alter/standalone/update.cpp\n+++ b/ydb/core/tx/schemeshard/olap/operations/alter/standalone/update.cpp\n@@ -1,6 +1,7 @@\n #include \"update.h\"\n #include <ydb/core/tx/schemeshard/olap/operations/alter/abstract/converter.h>\n #include <ydb/core/tx/schemeshard/olap/common/common.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n \n namespace NKikimr::NSchemeShard::NOlap::NAlter {\n \n@@ -36,6 +37,24 @@ NKikimr::TConclusionStatus TStandaloneSchemaUpdate::DoInitializeImpl(const TUpda\n             return TConclusionStatus::Fail(\"schema update error: \" + collector->GetErrorMessage() + \". in alter constructor STANDALONE_UPDATE\");\n         }\n     }\n+\n+    const TString& parentPathStr = context.GetModification()->GetWorkingDir();\n+    if (parentPathStr) { // Not empty only if called from Propose, not from ProgressState\n+        NSchemeShard::TPath parentPath = NSchemeShard::TPath::Resolve(parentPathStr, context.GetSSOperationContext()->SS);\n+        auto domainInfo = parentPath.DomainInfo();\n+        const TSchemeLimits& limits = domainInfo->GetSchemeLimits();\n+        if (targetSchema.GetColumns().GetColumns().size() > limits.MaxColumnTableColumns) {\n+            TString errStr = TStringBuilder()\n+                << \"Too many columns\"\n+                << \": new: \" << targetSchema.GetColumns().GetColumns().size()\n+                << \". Limit: \" << limits.MaxColumnTableColumns;\n+            return TConclusionStatus::Fail(errStr);\n+        }\n+    }\n+\n+    if (!CheckTargetSchema(targetSchema)) {\n+        return TConclusionStatus::Fail(\"schema update error: sparsed columns are disabled\");\n+    }\n     auto description = originalTable.GetTableInfoVerified().Description;\n     targetSchema.Serialize(*description.MutableSchema());\n     auto ttl = originalTable.GetTableTTLOptional() ? *originalTable.GetTableTTLOptional() : TOlapTTL();\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/alter_store.cpp b/ydb/core/tx/schemeshard/olap/operations/alter_store.cpp\nindex 446b43017821..57f05068b162 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/alter_store.cpp\n+++ b/ydb/core/tx/schemeshard/olap/operations/alter_store.cpp\n@@ -1,6 +1,9 @@\n #include <ydb/core/tx/schemeshard/schemeshard__operation_part.h>\n #include <ydb/core/tx/schemeshard/schemeshard__operation_common.h>\n #include <ydb/core/tx/schemeshard/schemeshard_impl.h>\n+#include <ydb/library/formats/arrow/accessor/common/const.h>\n+\n+#include \"checks.h\"\n \n namespace {\n \n@@ -434,6 +437,18 @@ class TAlterOlapStore: public TSubOperation {\n         }\n     }\n \n+    bool IsAlterCompression() const {\n+        const auto& alter = Transaction.GetAlterColumnStore();\n+        for (const auto& alterSchema : alter.GetAlterSchemaPresets()) {\n+            for (const auto& alterColumn : alterSchema.GetAlterSchema().GetAlterColumns()) {\n+                if (alterColumn.HasSerializer()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n public:\n     using TSubOperation::TSubOperation;\n \n@@ -458,7 +473,13 @@ class TAlterOlapStore: public TSubOperation {\n             return result;\n         }\n \n-        TPath path = TPath::Resolve(parentPathStr, context.SS).Dive(name);\n+        if (!AppData()->FeatureFlags.GetEnableOlapCompression() && IsAlterCompression()) {\n+            result->SetError(NKikimrScheme::StatusPreconditionFailed, \"Compression is disabled for OLAP tables\");\n+            return result;\n+        }\n+\n+        TPath parentPath = TPath::Resolve(parentPathStr, context.SS);\n+        TPath path = parentPath.Dive(name);\n         {\n             TPath::TChecker checks = path.Check();\n             checks\n@@ -504,6 +525,26 @@ class TAlterOlapStore: public TSubOperation {\n         if (!alterData) {\n             return result;\n         }\n+\n+        if (!AppData()->FeatureFlags.GetEnableSparsedColumns()) {\n+            for (auto& [_, preset]: alterData->SchemaPresets) {\n+                for (auto& [_, column]: preset.GetColumns().GetColumns()) {\n+                    if (column.GetDefaultValue().GetValue() || (column.GetAccessorConstructor().GetClassName() == NKikimr::NArrow::NAccessor::TGlobalConst::SparsedDataAccessorName)) {\n+                        result->SetError(NKikimrScheme::StatusSchemeError,\"schema update error: sparsed columns are disabled\");\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        auto domainInfo = parentPath.DomainInfo();\n+        const TSchemeLimits& limits = domainInfo->GetSchemeLimits();\n+\n+        if (!NKikimr::NSchemeShard::NOlap::CheckLimits(limits, alterData, errStr)) {\n+            result->SetError(NKikimrScheme::StatusSchemeError, errStr);\n+            return result;\n+        }\n+\n         storeInfo->AlterData = alterData;\n \n         NIceDb::TNiceDb db(context.GetDB());\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/alter_table.cpp b/ydb/core/tx/schemeshard/olap/operations/alter_table.cpp\nindex 6dff78961fff..4fb76b4a75a0 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/alter_table.cpp\n+++ b/ydb/core/tx/schemeshard/olap/operations/alter_table.cpp\n@@ -265,6 +265,19 @@ class TAlterColumnTable: public TSubOperation {\n \n         auto result = MakeHolder<TProposeResponse>(NKikimrScheme::StatusAccepted, ui64(OperationId.GetTxId()), ui64(ssId));\n \n+        const bool isAlterSharding = Transaction.HasAlterColumnTable() && Transaction.GetAlterColumnTable().HasReshardColumnTable();\n+        if (isAlterSharding && !AppData()->FeatureFlags.GetEnableAlterShardingInColumnShard()) {\n+            result->SetError(NKikimrScheme::StatusPreconditionFailed, \"Alter sharding is disabled for OLAP tables\");\n+            return result;\n+        }\n+\n+        const bool hasTiering = Transaction.HasAlterColumnTable() && Transaction.GetAlterColumnTable().HasAlterTtlSettings() &&\n+                                Transaction.GetAlterColumnTable().GetAlterTtlSettings().HasUseTiering();\n+        if (hasTiering && HasAppData() && !AppDataVerified().FeatureFlags.GetEnableTieringInColumnShard()) {\n+            result->SetError(NKikimrScheme::StatusPreconditionFailed, \"Tiering functionality is disabled for OLAP tables\");\n+            return result;\n+        }\n+\n         const TString& parentPathStr = Transaction.GetWorkingDir();\n         const TString& name = Transaction.HasAlterColumnTable() ? Transaction.GetAlterColumnTable().GetName() : Transaction.GetAlterTable().GetName();\n         LOG_NOTICE_S(context.Ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/checks.h b/ydb/core/tx/schemeshard/olap/operations/checks.h\nnew file mode 100644\nindex 000000000000..7a2e58fa807d\n--- /dev/null\n+++ b/ydb/core/tx/schemeshard/olap/operations/checks.h\n@@ -0,0 +1,19 @@\n+#pragma once\n+\n+namespace NKikimr::NSchemeShard::NOlap {\n+    inline bool CheckLimits(const TSchemeLimits& limits, TOlapStoreInfo::TPtr alterData, TString& errStr) {\n+        for (auto& [_, preset]: alterData->SchemaPresets) {\n+            ui64 columnCount = preset.GetColumns().GetColumns().size();\n+            if (columnCount > limits.MaxColumnTableColumns) {\n+                errStr = TStringBuilder()\n+                    << \"Too many columns\"\n+                    << \". new: \" << columnCount\n+                    << \". Limit: \" << limits.MaxColumnTableColumns;\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n+\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/create_store.cpp b/ydb/core/tx/schemeshard/olap/operations/create_store.cpp\nindex bc27020ddc45..d66f3bed7d44 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/create_store.cpp\n+++ b/ydb/core/tx/schemeshard/olap/operations/create_store.cpp\n@@ -7,6 +7,8 @@\n #include <ydb/core/tx/columnshard/columnshard.h>\n #include <ydb/core/mind/hive/hive.h>\n \n+#include \"checks.h\"\n+\n using namespace NKikimr;\n using namespace NKikimr::NSchemeShard;\n \n@@ -394,12 +396,20 @@ class TCreateOlapStore: public TSubOperation {\n             return result;\n         }\n \n+        auto domainInfo = parentPath.DomainInfo();\n+        const TSchemeLimits& limits = domainInfo->GetSchemeLimits();\n+\n         TProposeErrorCollector errors(*result);\n         TOlapStoreInfo::TPtr storeInfo = std::make_shared<TOlapStoreInfo>();\n         if (!storeInfo->ParseFromRequest(createDescription, errors)) {\n             return result;\n         }\n \n+        if (!NKikimr::NSchemeShard::NOlap::CheckLimits(limits, storeInfo, errStr)) {\n+            result->SetError(NKikimrScheme::StatusSchemeError, errStr);\n+            return result;\n+        }\n+\n         // Construct channels bindings for columnshards\n         TChannelsBindings channelsBindings;\n         if (!context.SS->GetOlapChannelsBindings(dstPath.GetPathIdForDomain(), storeInfo->GetStorageConfig(), channelsBindings, errStr)) {\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/create_table.cpp b/ydb/core/tx/schemeshard/olap/operations/create_table.cpp\nindex 7018d09e2ead..0c155d68d761 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/create_table.cpp\n+++ b/ydb/core/tx/schemeshard/olap/operations/create_table.cpp\n@@ -681,11 +681,23 @@ class TCreateColumnTable: public TSubOperation {\n         TProposeErrorCollector errors(*result);\n         TColumnTableInfo::TPtr tableInfo;\n         bool needUpdateObject = false;\n+        auto domainInfo = parentPath.DomainInfo();\n+        const TSchemeLimits& limits = domainInfo->GetSchemeLimits();\n+\n         if (storeInfo) {\n             TOlapPresetConstructor tableConstructor(*storeInfo);\n             tableInfo = tableConstructor.BuildTableInfo(createDescription, context, errors);\n             needUpdateObject = tableConstructor.GetNeedUpdateObject();\n         } else {\n+            ui64 columnCount = createDescription.schema().columns().size();\n+            if (columnCount > limits.MaxColumnTableColumns) {\n+                TString errStr = TStringBuilder()\n+                    << \"Too many columns\"\n+                    << \". new: \" << columnCount\n+                    << \". Limit: \" << limits.MaxColumnTableColumns;\n+                result->SetError(NKikimrScheme::StatusSchemeError, errStr);\n+                return result;\n+            }\n             TOlapTableConstructor tableConstructor;\n             tableInfo = tableConstructor.BuildTableInfo(createDescription, context, errors);\n         }\ndiff --git a/ydb/core/tx/schemeshard/olap/table/table.h b/ydb/core/tx/schemeshard/olap/table/table.h\nindex e37ede6c3eab..a092e175e25d 100644\n--- a/ydb/core/tx/schemeshard/olap/table/table.h\n+++ b/ydb/core/tx/schemeshard/olap/table/table.h\n@@ -99,8 +99,9 @@ struct TColumnTableInfo {\n         Stats.UpdateShardStats(shardIdx, newStats);\n     }\n \n-    void UpdateTableStats(const TPathId& pathId, const TPartitionStats& newStats) {\n-        Stats.UpdateTableStats(pathId, newStats);\n+    void UpdateTableStats(const TShardIdx shardIdx, const TPathId& pathId, const TPartitionStats& newStats) {\n+        Stats.TableStats[pathId].Aggregated.PartCount = GetColumnShards().size();\n+        Stats.UpdateTableStats(shardIdx, pathId, newStats);\n     }\n \n     TConclusion<std::shared_ptr<NOlap::NAlter::ISSEntity>> BuildEntity(const TPathId& pathId, const NOlap::NAlter::TEntityInitializationContext& iContext) const;\ndiff --git a/ydb/core/tx/schemeshard/olap/ttl/ya.make b/ydb/core/tx/schemeshard/olap/ttl/ya.make\nindex 0eb0e83c9a22..8aea246ebddf 100644\n--- a/ydb/core/tx/schemeshard/olap/ttl/ya.make\n+++ b/ydb/core/tx/schemeshard/olap/ttl/ya.make\n@@ -6,6 +6,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/core/base\n     ydb/core/protos\n )\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard__init.cpp b/ydb/core/tx/schemeshard/schemeshard__init.cpp\nindex f5f3cb1bbed3..5a6f2d0a7bf7 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__init.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__init.cpp\n@@ -1242,6 +1242,7 @@ struct TSchemeShard::TTxInit : public TTransactionBase<TSchemeShard> {\n             .MaxPathElementLength = rowSet.template GetValueOrDefault<Schema::SubDomains::PathElementLength>(defaults.MaxPathElementLength),\n             .ExtraPathSymbolsAllowed = rowSet.template GetValueOrDefault<Schema::SubDomains::ExtraPathSymbolsAllowed>(defaults.ExtraPathSymbolsAllowed),\n             .MaxTableColumns = rowSet.template GetValueOrDefault<Schema::SubDomains::TableColumnsLimit>(defaults.MaxTableColumns),\n+            .MaxColumnTableColumns = rowSet.template GetValueOrDefault<Schema::SubDomains::ColumnTableColumnsLimit>(defaults.MaxColumnTableColumns),\n             .MaxTableColumnNameLength = rowSet.template GetValueOrDefault<Schema::SubDomains::TableColumnNameLengthLimit>(defaults.MaxTableColumnNameLength),\n             .MaxTableKeyColumns = rowSet.template GetValueOrDefault<Schema::SubDomains::TableKeyColumnsLimit>(defaults.MaxTableKeyColumns),\n             .MaxTableIndices = rowSet.template GetValueOrDefault<Schema::SubDomains::TableIndicesLimit>(defaults.MaxTableIndices),\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__table_stats.cpp b/ydb/core/tx/schemeshard/schemeshard__table_stats.cpp\nindex 72e7b4a80379..99bb21401b0b 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__table_stats.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__table_stats.cpp\n@@ -321,11 +321,10 @@ bool TTxStoreTableStats::PersistSingleStats(const TPathId& pathId,\n             const TPathId tablePathId = TPathId(TOwnerId(pathId.OwnerId), TLocalPathId(table.GetTableLocalId()));\n \n             if (Self->ColumnTables.contains(tablePathId)) {\n-                LOG_DEBUG_S(ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\n+                LOG_TRACE_S(ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\n                             \"add stats for exists table with pathId=\" << tablePathId);\n \n-                auto columnTable = Self->ColumnTables.TakeVerified(tablePathId);\n-                columnTable->UpdateTableStats(tablePathId, newTableStats);\n+                Self->ColumnTables.GetVerifiedPtr(tablePathId)->UpdateTableStats(shardIdx, tablePathId, newTableStats);\n             } else {\n                 LOG_WARN_S(ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\n                            \"failed add stats for table with pathId=\" << tablePathId);\n@@ -336,7 +335,7 @@ bool TTxStoreTableStats::PersistSingleStats(const TPathId& pathId,\n         LOG_INFO_S(ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\n                    \"PersistSingleStats: ColumnTable rec.GetColumnTables() size=\" << rec.GetTables().size());\n \n-        auto columnTable = Self->ColumnTables.TakeVerified(pathId);\n+        auto columnTable = Self->ColumnTables.GetVerifiedPtr(pathId);\n         oldAggrStats = columnTable->GetStats().Aggregated;\n         columnTable->UpdateShardStats(shardIdx, newStats);\n         newAggrStats = columnTable->GetStats().Aggregated;\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\nindex 9ef8caa4a26d..8c8256d3f218 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\n@@ -1631,7 +1631,7 @@ void TTableInfo::UpdateShardStats(TShardIdx datashardIdx, const TPartitionStats&\n     Stats.UpdateShardStats(datashardIdx, newStats);\n }\n \n-void TAggregatedStats::UpdateShardStats(TShardIdx datashardIdx, const TPartitionStats& newStats) {\n+void TTableAggregatedStats::UpdateShardStats(TShardIdx datashardIdx, const TPartitionStats& newStats) {\n     // Ignore stats from unknown datashard (it could have been split)\n     if (!PartitionStats.contains(datashardIdx))\n         return;\n@@ -1720,33 +1720,10 @@ void TAggregatedStats::UpdateShardStats(TShardIdx datashardIdx, const TPartition\n     }\n }\n \n-void TAggregatedStats::UpdateTableStats(const TPathId& pathId, const TPartitionStats& newStats) {\n-    if (!TableStats.contains(pathId)) {\n-        TableStats[pathId] = newStats;\n-        return;\n-    }\n-\n-    TPartitionStats& oldStats = TableStats[pathId];\n-\n-    if (newStats.SeqNo <= oldStats.SeqNo) {\n-        // Ignore outdated message\n-        return;\n-    }\n-\n-    if (newStats.SeqNo.Generation > oldStats.SeqNo.Generation) {\n-        // Reset incremental counter baselines if tablet has restarted\n-        oldStats.ImmediateTxCompleted = 0;\n-        oldStats.PlannedTxCompleted = 0;\n-        oldStats.TxRejectedByOverload = 0;\n-        oldStats.TxRejectedBySpace = 0;\n-        oldStats.RowUpdates = 0;\n-        oldStats.RowDeletes = 0;\n-        oldStats.RowReads = 0;\n-        oldStats.RangeReads = 0;\n-        oldStats.RangeReadRows = 0;\n-    }\n-    TableStats[pathId].RowCount += (newStats.RowCount - oldStats.RowCount);\n-    TableStats[pathId].DataSize += (newStats.DataSize - oldStats.DataSize);\n+void TAggregatedStats::UpdateTableStats(TShardIdx shardIdx, const TPathId& pathId, const TPartitionStats& newStats) {\n+    auto& tableStats = TableStats[pathId];\n+    tableStats.PartitionStats[shardIdx]; // insert if none\n+    tableStats.UpdateShardStats(shardIdx, newStats);\n }\n \n void TTableInfo::RegisterSplitMergeOp(TOperationId opId, const TTxState& txState) {\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.h b/ydb/core/tx/schemeshard/schemeshard_info_types.h\nindex 890807a1e899..fc752993a471 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.h\n@@ -320,14 +320,18 @@ struct TPartitionStats {\n     ui64 CPU = 0;\n };\n \n-struct TAggregatedStats {\n+struct TTableAggregatedStats {\n     TPartitionStats Aggregated;\n     THashMap<TShardIdx, TPartitionStats> PartitionStats;\n-    THashMap<TPathId, TPartitionStats> TableStats;\n     size_t PartitionStatsUpdated = 0;\n \n     void UpdateShardStats(TShardIdx datashardIdx, const TPartitionStats& newStats);\n-    void UpdateTableStats(const TPathId& pathId, const TPartitionStats& newStats);\n+};\n+\n+struct TAggregatedStats : public TTableAggregatedStats {\n+    THashMap<TPathId, TTableAggregatedStats> TableStats;\n+\n+    void UpdateTableStats(TShardIdx datashardIdx, const TPathId& pathId, const TPartitionStats& newStats);\n };\n \n struct TSubDomainInfo;\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp b/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp\nindex 34ecf178b3bf..7b39e9113433 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp\n@@ -479,7 +479,9 @@ void TPathDescriber::DescribeColumnTable(TPathId pathId, TPathElement::TPtr path\n             description->MutableSchema()->SetVersion(description->GetSchema().GetVersion() + description->GetSchemaPresetVersionAdj());\n         }\n         if (tableInfo->GetStats().TableStats.contains(pathId)) {\n-            FillTableStats(*pathDescription, tableInfo->GetStats().TableStats.at(pathId));\n+            FillTableStats(*pathDescription, tableInfo->GetStats().TableStats.at(pathId).Aggregated);\n+        } else {\n+            FillTableStats(*pathDescription, TPartitionStats());\n         }\n     }\n }\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_schema.h b/ydb/core/tx/schemeshard/schemeshard_schema.h\nindex d36c6d4f6532..57ec8569d776 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_schema.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_schema.h\n@@ -761,6 +761,7 @@ struct Schema : NIceDb::Schema {\n         struct ImportsLimit : Column<29, NScheme::NTypeIds::Uint64> {};\n         struct AuditSettings : Column<30, NScheme::NTypeIds::String> {};\n         struct ServerlessComputeResourcesMode : Column<31, NScheme::NTypeIds::Uint32> { using Type = EServerlessComputeResourcesMode; };\n+        struct ColumnTableColumnsLimit : Column<32, NScheme::NTypeIds::Uint64> {};\n \n         using TKey = TableKey<PathId>;\n         using TColumns = TableColumns<\n@@ -794,7 +795,8 @@ struct Schema : NIceDb::Schema {\n             ExportsLimit,\n             ImportsLimit,\n             AuditSettings,\n-            ServerlessComputeResourcesMode\n+            ServerlessComputeResourcesMode,\n+            ColumnTableColumnsLimit\n         >;\n     };\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard_types.cpp b/ydb/core/tx/schemeshard/schemeshard_types.cpp\nindex 443cafd3e7ff..eaad291862a8 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_types.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_types.cpp\n@@ -20,6 +20,9 @@ TSchemeLimits TSchemeLimits::FromProto(const NKikimrScheme::TSchemeLimits& proto\n     if (proto.HasMaxTableColumns()) {\n         result.MaxTableColumns = proto.GetMaxTableColumns();\n     }\n+    if (proto.HasMaxColumnTableColumns()) {\n+        result.MaxColumnTableColumns = proto.GetMaxColumnTableColumns();\n+    }\n     if (proto.HasMaxTableColumnNameLength()) {\n         result.MaxTableColumnNameLength = proto.GetMaxTableColumnNameLength();\n     }\n@@ -69,6 +72,7 @@ NKikimrScheme::TSchemeLimits TSchemeLimits::AsProto() const {\n     result.SetMaxAclBytesSize(MaxAclBytesSize);\n \n     result.SetMaxTableColumns(MaxTableColumns);\n+    result.SetMaxColumnTableColumns(MaxColumnTableColumns);\n     result.SetMaxTableColumnNameLength(MaxTableColumnNameLength);\n     result.SetMaxTableKeyColumns(MaxTableKeyColumns);\n     result.SetMaxTableIndices(MaxTableIndices);\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_types.h b/ydb/core/tx/schemeshard/schemeshard_types.h\nindex 5e843c58a293..6afcdeedb1e2 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_types.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_types.h\n@@ -39,6 +39,7 @@ struct TSchemeLimits {\n \n     // table\n     ui64 MaxTableColumns = 200;\n+    ui64 MaxColumnTableColumns = 10000;\n     ui64 MaxTableColumnNameLength = 255;\n     ui64 MaxTableKeyColumns = 20;\n     ui64 MaxTableIndices = 20;\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\nindex 5886728811f3..98bf844479a3 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\n+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\n@@ -1506,6 +1506,7 @@ namespace NSchemeShardUT_Private {\n                                         (let child '('ChildrenLimit (Uint64 '%lu)))\n                                         (let acl '('AclByteSizeLimit (Uint64 '%lu)))\n                                         (let columns '('TableColumnsLimit (Uint64 '%lu)))\n+                                        (let columnColumns '('ColumnTableColumnsLimit (Uint64 '%lu)))\n                                         (let colName '('TableColumnNameLengthLimit (Uint64 '%lu)))\n                                         (let keyCols '('TableKeyColumnsLimit (Uint64 '%lu)))\n                                         (let indices '('TableIndicesLimit (Uint64 '%lu)))\n@@ -1518,11 +1519,11 @@ namespace NSchemeShardUT_Private {\n                                         (let pqPartitions '('PQPartitionsLimit (Uint64 '%lu)))\n                                         (let exports '('ExportsLimit (Uint64 '%lu)))\n                                         (let imports '('ImportsLimit (Uint64 '%lu)))\n-                                        (let ret (AsList (UpdateRow 'SubDomains key '(depth paths child acl columns colName keyCols indices streams shards pathShards consCopy maxPathLength extraSymbols pqPartitions exports imports))))\n+                                        (let ret (AsList (UpdateRow 'SubDomains key '(depth paths child acl columns columnColumns colName keyCols indices streams shards pathShards consCopy maxPathLength extraSymbols pqPartitions exports imports))))\n                                         (return ret)\n                                     )\n                                  )\", domainId, limits.MaxDepth, limits.MaxPaths, limits.MaxChildrenInDir, limits.MaxAclBytesSize,\n-                               limits.MaxTableColumns, limits.MaxTableColumnNameLength, limits.MaxTableKeyColumns,\n+                               limits.MaxTableColumns, limits.MaxColumnTableColumns, limits.MaxTableColumnNameLength, limits.MaxTableKeyColumns,\n                                limits.MaxTableIndices, limits.MaxTableCdcStreams,\n                                limits.MaxShards, limits.MaxShardsInPath, limits.MaxConsistentCopyTargets,\n                                limits.MaxPathElementLength, escapedStr.c_str(), limits.MaxPQPartitions,\ndiff --git a/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp b/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp\nindex c53fdeb58425..1a6a85e46e27 100644\n--- a/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp\n+++ b/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp\n@@ -1,6 +1,7 @@\n #include <ydb/core/tx/schemeshard/ut_helpers/helpers.h>\n #include <ydb/core/tx/columnshard/columnshard.h>\n #include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>\n+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n #include <ydb/core/formats/arrow/arrow_batch_builder.h>\n \n@@ -39,7 +40,7 @@ static const TString defaultTableSchema = R\"(\n )\";\n \n static const TVector<NArrow::NTest::TTestColumn> defaultYdbSchema = {\n-    NArrow::NTest::TTestColumn(\"timestamp\", TTypeInfo(NTypeIds::Timestamp) ),\n+    NArrow::NTest::TTestColumn(\"timestamp\", TTypeInfo(NTypeIds::Timestamp)).SetNullable(false),\n     NArrow::NTest::TTestColumn(\"data\", TTypeInfo(NTypeIds::Utf8) )\n };\n \n@@ -556,11 +557,24 @@ Y_UNIT_TEST_SUITE(TOlap) {\n                 }\n             }\n         )\", {NKikimrScheme::StatusAccepted});\n+\n+        env.TestWaitNotification(runtime, txId);\n+        TestAlterOlapStore(runtime, ++txId, \"/MyRoot\", R\"(\n+            Name: \"OlapStore\"\n+            AlterSchemaPresets {\n+                Name: \"default\"\n+                AlterSchema {\n+                    AlterColumns { Name: \"comment\" DefaultValue: \"10\" }\n+                }\n+            }\n+        )\", {NKikimrScheme::StatusSchemeError});\n     }\n \n     Y_UNIT_TEST(AlterTtl) {\n         TTestBasicRuntime runtime;\n-        TTestEnv env(runtime);\n+        TTestEnvOptions options;\n+        options.EnableTieringInColumnShard(true);\n+        TTestEnv env(runtime, options);\n         ui64 txId = 100;\n \n         TString olapSchema = R\"(\n@@ -634,17 +648,17 @@ Y_UNIT_TEST_SUITE(TOlap) {\n         env.TestWaitNotification(runtime, txId);\n     }\n \n-    // TODO: AlterTiers\n-    // negatives for store: disallow alters\n-    // negatives for table: wrong tiers count, wrong tiers, wrong eviction column, wrong eviction values,\n-    //      different TTL columns in tiers\n-#if 0\n     Y_UNIT_TEST(StoreStats) {\n         TTestBasicRuntime runtime;\n         TTestEnv env(runtime);\n         runtime.SetLogPriority(NKikimrServices::TX_COLUMNSHARD, NActors::NLog::PRI_DEBUG);\n         runtime.UpdateCurrentTime(TInstant::Now() - TDuration::Seconds(600));\n \n+        auto csController = NYDBTest::TControllers::RegisterCSControllerGuard<NYDBTest::NColumnShard::TController>();\n+        csController->SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        csController->SetOverrideLagForCompactionBeforeTierings(TDuration::Seconds(1));\n+        csController->SetOverrideReduceMemoryIntervalLimit(1LLU << 30);\n+\n         // disable stats batching\n         auto& appData = runtime.GetAppData();\n         appData.SchemeShardConfig.SetStatsBatchTimeoutMs(0);\n@@ -690,6 +704,16 @@ Y_UNIT_TEST_SUITE(TOlap) {\n         UNIT_ASSERT(shardId);\n         UNIT_ASSERT(pathId);\n         UNIT_ASSERT(planStep);\n+        {\n+            auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/OlapStore/ColumnTable\", true, true);\n+            Cerr << description.DebugString() << Endl;\n+            auto& tabletStats = description.GetPathDescription().GetTableStats();\n+\n+            UNIT_ASSERT(description.GetPathDescription().HasTableStats());\n+            UNIT_ASSERT_EQUAL(tabletStats.GetRowCount(), 0);\n+            UNIT_ASSERT_EQUAL(tabletStats.GetDataSize(), 0);\n+        }\n+\n \n         ui32 rowsInBatch = 100000;\n \n@@ -702,7 +726,7 @@ Y_UNIT_TEST_SUITE(TOlap) {\n             TSet<ui64> txIds;\n             for (ui32 i = 0; i < 10; ++i) {\n                 std::vector<ui64> writeIds;\n-                NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds);\n+                NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert);\n                 NTxUT::ProposeCommit(runtime, sender, shardId, ++txId, writeIds);\n                 txIds.insert(txId);\n             }\n@@ -714,16 +738,38 @@ Y_UNIT_TEST_SUITE(TOlap) {\n \n             // trigger periodic stats at shard (after timeout)\n             std::vector<ui64> writeIds;\n-            NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds);\n+            NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert);\n             NTxUT::ProposeCommit(runtime, sender, shardId, ++txId, writeIds);\n             NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, {txId});\n         }\n+        csController->WaitIndexation(TDuration::Seconds(5));\n+        {\n+            auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/OlapStore\", true, true);\n+            Cerr << description.DebugString() << Endl;\n+            auto& tabletStats = description.GetPathDescription().GetTableStats();\n+\n+            UNIT_ASSERT_GT(tabletStats.GetRowCount(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetDataSize(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetPartCount(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetRowUpdates(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetImmediateTxCompleted(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetPlannedTxCompleted(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetLastAccessTime(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetLastUpdateTime(), 0);\n+        }\n+\n+        {\n+            auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/OlapStore/ColumnTable\", true, true);\n+            Cerr << description.DebugString() << Endl;\n+            auto& tabletStats = description.GetPathDescription().GetTableStats();\n \n-        auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/OlapStore\", true, true);\n-        auto& tabletStats = description.GetPathDescription().GetTableStats();\n+            UNIT_ASSERT_GT(tabletStats.GetRowCount(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetDataSize(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetPartCount(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetLastAccessTime(), 0);\n+            UNIT_ASSERT_GT(tabletStats.GetLastUpdateTime(), 0);\n+        }\n \n-        UNIT_ASSERT_GT(tabletStats.GetRowCount(), 0);\n-        UNIT_ASSERT_GT(tabletStats.GetDataSize(), 0);\n #if 0\n         TestDropColumnTable(runtime, ++txId, \"/MyRoot/OlapStore\", \"ColumnTable\");\n         env.TestWaitNotification(runtime, txId);\n@@ -738,5 +784,4 @@ Y_UNIT_TEST_SUITE(TOlap) {\n         TestLsPathId(runtime, 2, NLs::PathStringEqual(\"\"));\n #endif\n     }\n-#endif\n }\ndiff --git a/ydb/core/tx/schemeshard/ut_subdomain/ut_subdomain.cpp b/ydb/core/tx/schemeshard/ut_subdomain/ut_subdomain.cpp\nindex 78db80f9f32c..8fc34d9edbe0 100644\n--- a/ydb/core/tx/schemeshard/ut_subdomain/ut_subdomain.cpp\n+++ b/ydb/core/tx/schemeshard/ut_subdomain/ut_subdomain.cpp\n@@ -2568,6 +2568,7 @@ Y_UNIT_TEST_SUITE(TSchemeShardSubDomainTest) {\n \n         }\n \n+\n         //clear subdomain\n         {\n             TestDescribeResult(DescribePath(runtime, \"/MyRoot\"),\n@@ -2585,6 +2586,155 @@ Y_UNIT_TEST_SUITE(TSchemeShardSubDomainTest) {\n         }\n     }\n \n+    Y_UNIT_TEST(ColumnSchemeLimitsRejects) {\n+        TTestBasicRuntime runtime;\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n+\n+        TSchemeLimits lowLimits;\n+        lowLimits.MaxDepth = 4;\n+        lowLimits.MaxPaths = 3;\n+        lowLimits.MaxChildrenInDir = 3;\n+        lowLimits.MaxAclBytesSize = 25;\n+        lowLimits.MaxTableColumns = 3;\n+        lowLimits.MaxColumnTableColumns = 3;\n+        lowLimits.MaxTableColumnNameLength = 10;\n+        lowLimits.MaxTableKeyColumns = 1;\n+        lowLimits.MaxShards = 6;\n+        lowLimits.MaxShardsInPath = 4;\n+        lowLimits.MaxPQPartitions = 20;\n+\n+\n+        //lowLimits.ExtraPathSymbolsAllowed = \"!\\\"#$%&'()*+,-.:;<=>?@[\\\\]^_`{|}~\";\n+        SetSchemeshardSchemaLimits(runtime, lowLimits);\n+        TestDescribeResult(DescribePath(runtime, \"/MyRoot\"),\n+                           {NLs::PathExist,\n+                            NLs::DomainLimitsIs(lowLimits.MaxPaths, lowLimits.MaxShards, lowLimits.MaxPQPartitions)});\n+\n+        {\n+            TestCreateSubDomain(runtime, txId++,  \"/MyRoot\",\n+                                \"PlanResolution: 50 \"\n+                                \"Coordinators: 1 \"\n+                                \"Mediators: 1 \"\n+                                \"TimeCastBucketsPerMediator: 2 \"\n+                                \"Name: \\\"USER_0\\\"\"\n+                                \" DatabaseQuotas {\"\n+                                \"    data_stream_shards_quota: 2\"\n+                                \"    data_stream_reserved_storage_quota: 200000\"\n+                                \"}\");\n+        }\n+\n+        //create column tables, column limits\n+        {\n+            TestMkDir(runtime, txId++, \"/MyRoot/USER_0\", \"C\");\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            // MaxColumnTableColumns\n+            TestCreateColumnTable(runtime, txId++, \"/MyRoot/USER_0/C\", R\"(\n+                            Name: \"C2\"\n+                            ColumnShardCount: 1\n+                            Schema {\n+                                Columns { Name: \"RowId\" Type: \"Uint64\", NotNull: true }\n+                                Columns { Name: \"Value0\" Type: \"Utf8\" }\n+                                Columns { Name: \"Value1\" Type: \"Utf8\" }\n+                                KeyColumnNames: \"RowId\"\n+                                Engine: COLUMN_ENGINE_REPLACING_TIMESERIES\n+                            }\n+                )\", {NKikimrScheme::StatusAccepted});\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            TestAlterColumnTable(runtime, txId++, \"/MyRoot/USER_0/C\", R\"(\n+                Name: \"C2\"\n+                AlterSchema {\n+                    DropColumns {Name: \"Value0\"}\n+                }\n+            )\", {NKikimrScheme::StatusAccepted});\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            TestAlterColumnTable(runtime, txId++, \"/MyRoot/USER_0/C\", R\"(\n+                Name: \"C2\"\n+                AlterSchema {\n+                    DropColumns {Name: \"Value1\"}\n+                    AddColumns { Name: \"Value2\" Type: \"Utf8\" }\n+                    AddColumns { Name: \"Value3\" Type: \"Utf8\" }\n+                    AddColumns { Name: \"Value4\" Type: \"Utf8\" }\n+                }\n+            )\", {NKikimrScheme::StatusSchemeError});\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            TestCreateColumnTable(runtime, txId++, \"/MyRoot/USER_0/C\", R\"(\n+                            Name: \"C1\"\n+                            ColumnShardCount: 1\n+                            Schema {\n+                                Columns { Name: \"RowId\" Type: \"Uint64\", NotNull: true }\n+                                Columns { Name: \"Value0\" Type: \"Utf8\" }\n+                                Columns { Name: \"Value1\" Type: \"Utf8\" }\n+                                Columns { Name: \"Value2\" Type: \"Utf8\" }\n+                                KeyColumnNames: \"RowId\"\n+                                Engine: COLUMN_ENGINE_REPLACING_TIMESERIES\n+                            }\n+                )\", {NKikimrScheme::StatusSchemeError});\n+\n+            TString olapSchema = R\"(\n+                Name: \"OlapStore1\"\n+                ColumnShardCount: 1\n+                SchemaPresets {\n+                    Name: \"default\"\n+                    Schema {\n+                        Columns { Name: \"timestamp\" Type: \"Timestamp\" NotNull: true }\n+                        Columns { Name: \"data\" Type: \"Utf8\" }\n+                        KeyColumnNames: \"timestamp\"\n+                        Engine: COLUMN_ENGINE_REPLACING_TIMESERIES\n+                    }\n+                }\n+            )\";\n+\n+            TestCreateOlapStore(runtime, txId++, \"/MyRoot\", olapSchema, {NKikimrScheme::StatusAccepted});\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            TString olapSchemaBig = R\"(\n+                Name: \"OlapStoreBig\"\n+                ColumnShardCount: 1\n+                SchemaPresets {\n+                    Name: \"default\"\n+                    Schema {\n+                        Columns { Name: \"timestamp\" Type: \"Timestamp\" NotNull: true }\n+                        Columns { Name: \"data\" Type: \"Utf8\" }\n+                        Columns { Name: \"data2\" Type: \"Utf8\" }\n+                        Columns { Name: \"data3\" Type: \"Utf8\" }\n+                        KeyColumnNames: \"timestamp\"\n+                        Engine: COLUMN_ENGINE_REPLACING_TIMESERIES\n+                    }\n+                }\n+            )\";\n+\n+            TestCreateOlapStore(runtime, txId++, \"/MyRoot\", olapSchemaBig, {NKikimrScheme::StatusSchemeError});\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            TestAlterOlapStore(runtime, txId++, \"/MyRoot\", R\"(\n+                Name: \"OlapStore1\"\n+                AlterSchemaPresets {\n+                    Name: \"default\"\n+                    AlterSchema {\n+                        AddColumns { Name: \"comment\" Type: \"Utf8\" }\n+                    }\n+                }\n+            )\", {NKikimrScheme::StatusAccepted});\n+            env.TestWaitNotification(runtime, txId - 1);\n+\n+            TestAlterOlapStore(runtime, txId++, \"/MyRoot\", R\"(\n+                Name: \"OlapStore1\"\n+                AlterSchemaPresets {\n+                    Name: \"default\"\n+                    AlterSchema {\n+                        AddColumns { Name: \"comment2\" Type: \"Utf8\" }\n+                    }\n+                }\n+            )\", {NKikimrScheme::StatusSchemeError});\n+            env.TestWaitNotification(runtime, txId - 1);\n+        }\n+    }\n+\n     Y_UNIT_TEST(SchemeLimitsRejectsWithIndexedTables) {\n         TTestBasicRuntime runtime;\n         TTestEnv env(runtime);\ndiff --git a/ydb/core/tx/schemeshard/ut_ttl/ut_ttl.cpp b/ydb/core/tx/schemeshard/ut_ttl/ut_ttl.cpp\nindex ce57f14992b3..1accb55c269b 100644\n--- a/ydb/core/tx/schemeshard/ut_ttl/ut_ttl.cpp\n+++ b/ydb/core/tx/schemeshard/ut_ttl/ut_ttl.cpp\n@@ -1150,6 +1150,7 @@ Y_UNIT_TEST_SUITE(TSchemeShardColumnTableTTL) {\n                 Columns { Name: \"key\" Type: \"Uint64\" NotNull: true }\n                 Columns { Name: \"modified_at\" Type: \"Timestamp\" }\n                 Columns { Name: \"saved_at\" Type: \"Datetime\" }\n+                Columns { Name: \"data\" Type: \"Utf8\" }\n                 KeyColumnNames: [\"key\"]\n             }\n         )\");\n@@ -1206,6 +1207,13 @@ Y_UNIT_TEST_SUITE(TSchemeShardColumnTableTTL) {\n                 }\n             }\n         );\n+        TestAlterColumnTable(runtime, ++txId, \"/MyRoot\", R\"(\n+            Name: \"TTLEnabledTable\"\n+            AlterSchema {\n+                AlterColumns {Name: \"data\" DefaultValue: \"10\"}\n+            }\n+        )\", {NKikimrScheme::StatusSchemeError});\n+        env.TestWaitNotification(runtime, txId);\n     }\n \n     Y_UNIT_TEST(AlterColumnTable_Negative) {\ndiff --git a/ydb/core/tx/sharding/unboxed_reader.h b/ydb/core/tx/sharding/unboxed_reader.h\nindex fed3e972e2b9..11a31d7e3597 100644\n--- a/ydb/core/tx/sharding/unboxed_reader.h\n+++ b/ydb/core/tx/sharding/unboxed_reader.h\n@@ -3,7 +3,7 @@\n #include <ydb/library/yql/public/udf/udf_value.h>\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/core/scheme_types/scheme_type_info.h>\n-#include <ydb/core/formats/arrow/hash/xx_hash.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n #include <util/generic/map.h>\n \n namespace NKikimr::NMiniKQL {\ndiff --git a/ydb/core/tx/sharding/ut/ut_sharding.cpp b/ydb/core/tx/sharding/ut/ut_sharding.cpp\nindex 14dd61a48560..dce5bc6e7500 100644\n--- a/ydb/core/tx/sharding/ut/ut_sharding.cpp\n+++ b/ydb/core/tx/sharding/ut/ut_sharding.cpp\n@@ -1,6 +1,6 @@\n #include <ydb/core/testlib/cs_helper.h>\n #include <ydb/core/tx/sharding/sharding.h>\n-#include <ydb/core/formats/arrow/hash/xx_hash.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n \n #include <ydb/library/actors/core/av_bootstrapped.h>\n #include <library/cpp/protobuf/json/proto2json.h>\ndiff --git a/ydb/core/tx/tiering/manager.cpp b/ydb/core/tx/tiering/manager.cpp\nindex 85dd6d60c10b..57462d745d3a 100644\n--- a/ydb/core/tx/tiering/manager.cpp\n+++ b/ydb/core/tx/tiering/manager.cpp\n@@ -199,19 +199,18 @@ THashMap<ui64, NKikimr::NOlap::TTiering> TTiersManager::GetTiering() const {\n     Y_ABORT_UNLESS(snapshotPtr);\n     auto& tierConfigs = snapshotPtr->GetTierConfigs();\n     for (auto&& i : PathIdTiering) {\n-        auto* tiering = snapshotPtr->GetTieringById(i.second);\n-        if (tiering) {\n+        auto* tieringRule = snapshotPtr->GetTieringById(i.second);\n+        if (tieringRule) {\n             AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"path_id\", i.first)(\"tiering_name\", i.second)(\"event\", \"activation\");\n-            result.emplace(i.first, tiering->BuildOlapTiers());\n-            for (auto& [pathId, pathTiering] : result) {\n-                for (auto& [name, tier] : pathTiering.GetTierByName()) {\n-                    AFL_VERIFY(name != NOlap::NTiering::NCommon::DeleteTierName);\n-                    auto it = tierConfigs.find(name);\n-                    if (it != tierConfigs.end()) {\n-                        tier->SetSerializer(NTiers::ConvertCompression(it->second.GetCompression()));\n-                    }\n+            NOlap::TTiering tiering = tieringRule->BuildOlapTiers();\n+            for (auto& [name, tier] : tiering.GetTierByName()) {\n+                AFL_VERIFY(name != NOlap::NTiering::NCommon::DeleteTierName);\n+                auto it = tierConfigs.find(name);\n+                if (it != tierConfigs.end()) {\n+                    tier->SetSerializer(NTiers::ConvertCompression(it->second.GetCompression()));\n                 }\n             }\n+            result.emplace(i.first, std::move(tiering));\n         } else {\n             AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"path_id\", i.first)(\"tiering_name\", i.second)(\"event\", \"not_found\");\n         }\ndiff --git a/ydb/core/tx/tiering/rule/manager.cpp b/ydb/core/tx/tiering/rule/manager.cpp\nindex c6ea9e9f6130..9dfdb4459d0b 100644\n--- a/ydb/core/tx/tiering/rule/manager.cpp\n+++ b/ydb/core/tx/tiering/rule/manager.cpp\n@@ -13,6 +13,10 @@ void TTieringRulesManager::DoPrepareObjectsBeforeModification(std::vector<TTieri\n NMetadata::NModifications::TOperationParsingResult TTieringRulesManager::DoBuildPatchFromSettings(\n     const NYql::TObjectSettingsImpl& settings,\n     TInternalModificationContext& /*context*/) const {\n+    if (HasAppData() && !AppDataVerified().FeatureFlags.GetEnableTieringInColumnShard()) {\n+        return TConclusionStatus::Fail(\"Tiering functionality is disabled for OLAP tables.\");\n+    }\n+\n     NMetadata::NInternal::TTableRecord result;\n     result.SetColumn(TTieringRule::TDecoder::TieringRuleId, NMetadata::NInternal::TYDBValue::Utf8(settings.GetObjectId()));\n     if (settings.GetObjectId().StartsWith(\"$\") || settings.GetObjectId().StartsWith(\"_\")) {\n@@ -21,6 +25,9 @@ NMetadata::NModifications::TOperationParsingResult TTieringRulesManager::DoBuild\n     {\n         auto fValue = settings.GetFeaturesExtractor().Extract(TTieringRule::TDecoder::DefaultColumn);\n         if (fValue) {\n+            if (fValue->Empty()) {\n+                return TConclusionStatus::Fail(\"defaultColumn cannot be empty\");\n+            }\n             result.SetColumn(TTieringRule::TDecoder::DefaultColumn, NMetadata::NInternal::TYDBValue::Utf8(*fValue));\n         }\n     }\ndiff --git a/ydb/core/tx/tiering/rule/object.cpp b/ydb/core/tx/tiering/rule/object.cpp\nindex 59d42bdb4c8e..a596b56890ca 100644\n--- a/ydb/core/tx/tiering/rule/object.cpp\n+++ b/ydb/core/tx/tiering/rule/object.cpp\n@@ -30,6 +30,10 @@ bool TTieringRule::DeserializeDescriptionFromJson(const NJson::TJsonValue& jsonI\n     if (!jsonInfo[\"rules\"].GetArrayPointer(&rules)) {\n         return false;\n     }\n+    if (rules->empty()) {\n+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"tiering_rule_deserialization_failed\")(\"reason\", \"empty_rules\");\n+        return false;\n+    }\n     for (auto&& i : *rules) {\n         TTieringInterval interval;\n         if (!interval.DeserializeFromJson(i)) {\n@@ -61,6 +65,9 @@ bool TTieringRule::DeserializeFromRecord(const TDecoder& decoder, const Ydb::Val\n     if (!decoder.Read(decoder.GetDefaultColumnIdx(), DefaultColumn, r)) {\n         return false;\n     }\n+    if (DefaultColumn.Empty()) {\n+        return false;\n+    }\n     NJson::TJsonValue jsonDescription;\n     if (!decoder.ReadJson(decoder.GetDescriptionIdx(), jsonDescription, r)) {\n         return false;\n@@ -72,6 +79,7 @@ bool TTieringRule::DeserializeFromRecord(const TDecoder& decoder, const Ydb::Val\n }\n \n NKikimr::NOlap::TTiering TTieringRule::BuildOlapTiers() const {\n+    AFL_VERIFY(!Intervals.empty());\n     NOlap::TTiering result;\n     for (auto&& r : Intervals) {\n         AFL_VERIFY(result.Add(std::make_shared<NOlap::TTierInfo>(r.GetTierName(), r.GetDurationForEvict(), GetDefaultColumn())));\ndiff --git a/ydb/core/tx/tiering/rule/ss_fetcher.cpp b/ydb/core/tx/tiering/rule/ss_fetcher.cpp\nindex 681e96780eb4..e822ace4c5a8 100644\n--- a/ydb/core/tx/tiering/rule/ss_fetcher.cpp\n+++ b/ydb/core/tx/tiering/rule/ss_fetcher.cpp\n@@ -17,7 +17,7 @@ void TFetcherCheckUserTieringPermissions::DoProcess(NSchemeShard::TSchemeShard&\n     } else {\n         bool denied = false;\n         for (auto&& i : TieringRuleIds) {\n-            const std::set<TPathId>& pathIds = schemeShard.ColumnTables.GetTablesWithTiering(i);\n+            const auto& pathIds = schemeShard.ColumnTables.GetTablesWithTiering(i);\n             for (auto&& pathId : pathIds) {\n                 auto path = NSchemeShard::TPath::Init(pathId, &schemeShard);\n                 if (!path.IsResolved() || path.IsUnderDeleting() || path.IsDeleted()) {\ndiff --git a/ydb/core/tx/tiering/tier/manager.cpp b/ydb/core/tx/tiering/tier/manager.cpp\nindex a64d2a7603ab..27005ca30a09 100644\n--- a/ydb/core/tx/tiering/tier/manager.cpp\n+++ b/ydb/core/tx/tiering/tier/manager.cpp\n@@ -8,6 +8,10 @@ NMetadata::NModifications::TOperationParsingResult TTiersManager::DoBuildPatchFr\n     const NYql::TObjectSettingsImpl& settings,\n     TInternalModificationContext& context) const\n {\n+    if (HasAppData() && !AppDataVerified().FeatureFlags.GetEnableTieringInColumnShard()) {\n+        return TConclusionStatus::Fail(\"Tiering functionality is disabled for OLAP tables.\");\n+    }\n+\n     NMetadata::NInternal::TTableRecord result;\n     result.SetColumn(TTierConfig::TDecoder::TierName, NMetadata::NInternal::TYDBValue::Utf8(settings.GetObjectId()));\n     if (settings.GetObjectId().StartsWith(\"$\") || settings.GetObjectId().StartsWith(\"_\")) {\ndiff --git a/ydb/core/tx/tiering/ut/ut_tiers.cpp b/ydb/core/tx/tiering/ut/ut_tiers.cpp\nindex 55fd3a3437e5..21fa01b29a6e 100644\n--- a/ydb/core/tx/tiering/ut/ut_tiers.cpp\n+++ b/ydb/core/tx/tiering/ut/ut_tiers.cpp\n@@ -32,21 +32,15 @@ class TFastTTLCompactionController: public NKikimr::NYDBTest::ICSController {\n     virtual bool NeedForceCompactionBacketsConstruction() const override {\n         return true;\n     }\n-    virtual TDuration GetRemovedPortionLivetime(const TDuration /*def*/) const override {\n-        return TDuration::Zero();\n-    }\n-    virtual ui64 GetSmallPortionSizeDetector(const ui64 /*def*/) const override {\n+    virtual ui64 DoGetSmallPortionSizeDetector(const ui64 /*def*/) const override {\n         return 0;\n     }\n-    virtual TDuration GetOptimizerFreshnessCheckDuration(const TDuration /*defaultValue*/) const override {\n+    virtual TDuration DoGetOptimizerFreshnessCheckDuration(const TDuration /*defaultValue*/) const override {\n         return TDuration::Zero();\n     }\n-    virtual TDuration GetLagForCompactionBeforeTierings(const TDuration /*def*/) const override {\n+    virtual TDuration DoGetLagForCompactionBeforeTierings(const TDuration /*def*/) const override {\n         return TDuration::Zero();\n     }\n-    virtual TDuration GetTTLDefaultWaitingDuration(const TDuration /*defaultValue*/) const override {\n-        return TDuration::Seconds(1);\n-    }\n \n };\n \n@@ -336,7 +330,8 @@ Y_UNIT_TEST_SUITE(ColumnShardTiers) {\n         serverSettings.GrpcPort = grpcPort;\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableMetadataProvider(true);\n+            .SetEnableMetadataProvider(true)\n+            .SetEnableTieringInColumnShard(true)\n         ;\n \n         Tests::TServer::TPtr server = new Tests::TServer(serverSettings);\n@@ -426,6 +421,7 @@ Y_UNIT_TEST_SUITE(ColumnShardTiers) {\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n             .SetEnableMetadataProvider(true)\n+            .SetEnableTieringInColumnShard(true)\n             .SetAppConfig(appConfig);\n \n         Tests::TServer::TPtr server = new Tests::TServer(serverSettings);\n@@ -556,6 +552,7 @@ Y_UNIT_TEST_SUITE(ColumnShardTiers) {\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n             .SetEnableMetadataProvider(true)\n+            .SetEnableTieringInColumnShard(true)\n         ;\n \n         Tests::TServer::TPtr server = new Tests::TServer(serverSettings);\ndiff --git a/ydb/core/tx/tx_processing.h b/ydb/core/tx/tx_processing.h\nindex d992dd71474d..1f9b86527225 100644\n--- a/ydb/core/tx/tx_processing.h\n+++ b/ydb/core/tx/tx_processing.h\n@@ -105,7 +105,7 @@ struct TEvTxProcessing {\n         }\n     };\n \n-    struct TEvReadSet : public TEventPB<TEvReadSet, NKikimrTx::TEvReadSet, EvReadSet> {\n+    struct TEvReadSet: public TEventPB<TEvReadSet, NKikimrTx::TEvReadSet, EvReadSet> {\n         TEvReadSet()\n         {}\n \ndiff --git a/ydb/core/tx/tx_proxy/global.cpp b/ydb/core/tx/tx_proxy/global.cpp\nnew file mode 100644\nindex 000000000000..66d88d8d824e\n--- /dev/null\n+++ b/ydb/core/tx/tx_proxy/global.cpp\n@@ -0,0 +1,5 @@\n+#include \"global.h\"\n+\n+namespace NKikimr::NTxProxy {\n+\n+}\ndiff --git a/ydb/core/tx/tx_proxy/global.h b/ydb/core/tx/tx_proxy/global.h\nnew file mode 100644\nindex 000000000000..00002b17e0ac\n--- /dev/null\n+++ b/ydb/core/tx/tx_proxy/global.h\n@@ -0,0 +1,9 @@\n+#pragma once\n+#include <util/system/types.h>\n+\n+namespace NKikimr::NTxProxy {\n+class TLimits {\n+public:\n+    static constexpr ui64 MemoryInFlightWriting = (ui64)1 << 30;\n+};\n+}\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/tx_proxy/rpc_long_tx.cpp b/ydb/core/tx/tx_proxy/rpc_long_tx.cpp\nindex f5b7c6b07cd5..557cf13c14cb 100644\n--- a/ydb/core/tx/tx_proxy/rpc_long_tx.cpp\n+++ b/ydb/core/tx/tx_proxy/rpc_long_tx.cpp\n@@ -1,10 +1,15 @@\n-#include <ydb/core/tx/schemeshard/schemeshard.h>\n-#include <ydb/core/tx/data_events/shard_writer.h>\n+#include \"global.h\"\n+\n+#include <ydb/core/formats/arrow/size_calcer.h>\n #include <ydb/core/tx/columnshard/columnshard.h>\n+#include <ydb/core/tx/data_events/shard_writer.h>\n #include <ydb/core/tx/long_tx_service/public/events.h>\n-#include <ydb/services/ext_index/common/service.h>\n+#include <ydb/core/tx/schemeshard/schemeshard.h>\n \n+#include <ydb/library/actors/prof/tag.h>\n #include <ydb/library/actors/wilson/wilson_profile_span.h>\n+#include <ydb/services/ext_index/common/service.h>\n+\n #include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api.h>\n \n namespace NKikimr {\n@@ -16,30 +21,29 @@ using namespace NLongTxService;\n // Common logic of LongTx Write that takes care of splitting the data according to the sharding scheme,\n // sending it to shards and collecting their responses\n template <class TLongTxWriteImpl>\n-class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n+class TLongTxWriteBase: public TActorBootstrapped<TLongTxWriteImpl> {\n     using TBase = TActorBootstrapped<TLongTxWriteImpl>;\n+    static inline TAtomicCounter MemoryInFlight = 0;\n+\n protected:\n     using TThis = typename TBase::TThis;\n \n public:\n-    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n-        return NKikimrServices::TActivity::GRPC_REQ;\n-    }\n-\n-    TLongTxWriteBase(const TString& databaseName, const TString& path, const TString& token,\n-        const TLongTxId& longTxId, const TString& dedupId)\n-        : TBase()\n-        , DatabaseName(databaseName)\n+    TLongTxWriteBase(const TString& databaseName, const TString& path, const TString& token, const TLongTxId& longTxId, const TString& dedupId)\n+        : DatabaseName(databaseName)\n         , Path(path)\n         , DedupId(dedupId)\n         , LongTxId(longTxId)\n-        , ActorSpan(0, NWilson::TTraceId::NewTraceId(0, Max<ui32>()), \"TLongTxWriteBase\")\n-    {\n+        , ActorSpan(0, NWilson::TTraceId::NewTraceId(0, Max<ui32>()), \"TLongTxWriteBase\") {\n         if (token) {\n             UserToken.emplace(token);\n         }\n     }\n \n+    virtual ~TLongTxWriteBase() {\n+        AFL_VERIFY(MemoryInFlight.Sub(InFlightSize) >= 0);\n+    }\n+\n protected:\n     void ProceedWithSchema(const NSchemeCache::TSchemeCacheNavigate& resp) {\n         NWilson::TProfileSpan pSpan = ActorSpan.BuildChildrenSpan(\"ProceedWithSchema\");\n@@ -53,17 +57,24 @@ class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n         if (UserToken && entry.SecurityObject) {\n             const ui32 access = NACLib::UpdateRow;\n             if (!entry.SecurityObject->CheckAccess(access, *UserToken)) {\n-                RaiseIssue(MakeIssue(NKikimrIssues::TIssuesIds::ACCESS_DENIED, TStringBuilder()\n-                    << \"User has no permission to perform writes to this table\"\n-                    << \" user: \" << UserToken->GetUserSID()\n-                    << \" path: \" << Path));\n+                RaiseIssue(MakeIssue(\n+                    NKikimrIssues::TIssuesIds::ACCESS_DENIED, TStringBuilder() << \"User has no permission to perform writes to this table\"\n+                                                                               << \" user: \" << UserToken->GetUserSID() << \" path: \" << Path));\n                 return ReplyError(Ydb::StatusIds::UNAUTHORIZED);\n             }\n         }\n \n+        auto accessor = ExtractDataAccessor();\n+        AFL_VERIFY(!InFlightSize);\n+        InFlightSize = accessor->GetSize();\n+        const i64 sizeInFlight = MemoryInFlight.Add(InFlightSize);\n+        if (TLimits::MemoryInFlightWriting < (ui64)sizeInFlight && sizeInFlight != InFlightSize) {\n+            return ReplyError(Ydb::StatusIds::OVERLOADED, \"a lot of memory in flight\");\n+        }\n         if (NCSIndex::TServiceOperator::IsEnabled()) {\n-            TBase::Send(NCSIndex::MakeServiceId(TBase::SelfId().NodeId()),\n-                new NCSIndex::TEvAddData(GetDataAccessor().GetDeserializedBatch(), Path, std::make_shared<NCSIndex::TNaiveDataUpsertController>(TBase::SelfId())));\n+            TBase::Send(\n+                NCSIndex::MakeServiceId(TBase::SelfId().NodeId()), new NCSIndex::TEvAddData(accessor->GetDeserializedBatch(), Path,\n+                                                                       std::make_shared<NCSIndex::TNaiveDataUpsertController>(TBase::SelfId())));\n         } else {\n             IndexReady = true;\n         }\n@@ -73,10 +84,11 @@ class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n             return ReplyError(Ydb::StatusIds::BAD_REQUEST, \"Shard splitter not implemented for table kind\");\n         }\n \n-        auto initStatus = shardsSplitter->SplitData(entry, GetDataAccessor());\n+        auto initStatus = shardsSplitter->SplitData(entry, *accessor);\n         if (!initStatus.Ok()) {\n             return ReplyError(initStatus.GetStatus(), initStatus.GetErrorMessage());\n         }\n+        accessor.reset();\n \n         const auto& splittedData = shardsSplitter->GetSplitData();\n         InternalController = std::make_shared<NEvWrite::TWritersController>(splittedData.GetShardRequestsCount(), this->SelfId(), LongTxId);\n@@ -85,24 +97,26 @@ class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n         ui32 writeIdx = 0;\n         for (auto& [shard, infos] : splittedData.GetShardsInfo()) {\n             for (auto&& shardInfo : infos) {\n+                InternalController->GetCounters()->OnRequest(shardInfo->GetRowsCount(), shardInfo->GetBytes());\n                 sumBytes += shardInfo->GetBytes();\n                 rowsCount += shardInfo->GetRowsCount();\n-                this->Register(new NEvWrite::TShardWriter(shard, shardsSplitter->GetTableId(), DedupId, shardInfo, ActorSpan, InternalController, ++writeIdx, NEvWrite::EModificationType::Replace));\n+                this->Register(new NEvWrite::TShardWriter(shard, shardsSplitter->GetTableId(), DedupId, shardInfo, ActorSpan, InternalController,\n+                    ++writeIdx, NEvWrite::EModificationType::Replace));\n             }\n         }\n         pSpan.Attribute(\"affected_shards_count\", (long)splittedData.GetShardsInfo().size());\n         pSpan.Attribute(\"bytes\", (long)sumBytes);\n         pSpan.Attribute(\"rows\", (long)rowsCount);\n         pSpan.Attribute(\"shards_count\", (long)splittedData.GetShardsCount());\n-        AFL_DEBUG(NKikimrServices::LONG_TX_SERVICE)(\"affected_shards_count\", splittedData.GetShardsInfo().size())(\"shards_count\", splittedData.GetShardsCount())\n-            (\"path\", Path)(\"shards_info\", splittedData.ShortLogString(32));\n+        AFL_DEBUG(NKikimrServices::LONG_TX_SERVICE)(\"affected_shards_count\", splittedData.GetShardsInfo().size())(\n+            \"shards_count\", splittedData.GetShardsCount())(\"path\", Path)(\"shards_info\", splittedData.ShortLogString(32));\n         this->Become(&TThis::StateMain);\n     }\n \n private:\n     STFUNC(StateMain) {\n         switch (ev->GetTypeRewrite()) {\n-            hFunc(NEvWrite::TWritersController::TEvPrivate::TEvShardsWriteResult, Handle)\n+            hFunc(NEvWrite::TWritersController::TEvPrivate::TEvShardsWriteResult, Handle);\n             hFunc(TEvLongTxService::TEvAttachColumnShardWritesResult, Handle);\n             hFunc(NCSIndex::TEvAddDataResult, Handle);\n         }\n@@ -150,11 +164,10 @@ class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n                 IndexReady = true;\n             }\n         }\n-\n     }\n \n protected:\n-    virtual NEvWrite::IShardsSplitter::IEvWriteDataAccessor& GetDataAccessor() const = 0;\n+    virtual std::unique_ptr<NEvWrite::IShardsSplitter::IEvWriteDataAccessor> ExtractDataAccessor() = 0;\n     virtual void RaiseIssue(const NYql::TIssue& issue) = 0;\n     virtual void ReplyError(Ydb::StatusIds::StatusCode status, const TString& message = TString()) = 0;\n     virtual void ReplySuccess() = 0;\n@@ -164,7 +177,9 @@ class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n     const TString Path;\n     const TString DedupId;\n     TLongTxId LongTxId;\n+\n private:\n+    i64 InFlightSize = 0;\n     std::optional<NACLib::TUserToken> UserToken;\n     NWilson::TProfileSpan ActorSpan;\n     NEvWrite::TWritersController::TPtr InternalController;\n@@ -174,15 +189,19 @@ class TLongTxWriteBase : public TActorBootstrapped<TLongTxWriteImpl> {\n \n // LongTx Write implementation called from the inside of YDB (e.g. as a part of BulkUpsert call)\n // NOTE: permission checks must have been done by the caller\n-class TLongTxWriteInternal : public TLongTxWriteBase<TLongTxWriteInternal> {\n+class TLongTxWriteInternal: public TLongTxWriteBase<TLongTxWriteInternal> {\n     using TBase = TLongTxWriteBase<TLongTxWriteInternal>;\n \n-    class TParsedBatchData : public NEvWrite::IShardsSplitter::IEvWriteDataAccessor {\n+    class TParsedBatchData: public NEvWrite::IShardsSplitter::IEvWriteDataAccessor {\n+    private:\n+        using TBase = NEvWrite::IShardsSplitter::IEvWriteDataAccessor;\n         std::shared_ptr<arrow::RecordBatch> Batch;\n+\n     public:\n         TParsedBatchData(std::shared_ptr<arrow::RecordBatch> batch)\n-            : Batch(batch)\n-        {}\n+            : TBase(NArrow::GetBatchMemorySize(batch))\n+            , Batch(batch) {\n+        }\n \n         std::shared_ptr<arrow::RecordBatch> GetDeserializedBatch() const override {\n             return Batch;\n@@ -193,25 +212,19 @@ class TLongTxWriteInternal : public TLongTxWriteBase<TLongTxWriteInternal> {\n         }\n     };\n \n-    NEvWrite::IShardsSplitter::IEvWriteDataAccessor::TPtr DataAccessor;\n-public:\n-    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n-        return NKikimrServices::TActivity::GRPC_REQ;\n-    }\n+    std::unique_ptr<NEvWrite::IShardsSplitter::IEvWriteDataAccessor> DataAccessor;\n \n-    explicit TLongTxWriteInternal(const TActorId& replyTo, const TLongTxId& longTxId, const TString& dedupId,\n-            const TString& databaseName, const TString& path,\n-            std::shared_ptr<const NSchemeCache::TSchemeCacheNavigate> navigateResult,\n-            std::shared_ptr<arrow::RecordBatch> batch,\n-            std::shared_ptr<NYql::TIssues> issues)\n+public:\n+    explicit TLongTxWriteInternal(const TActorId& replyTo, const TLongTxId& longTxId, const TString& dedupId, const TString& databaseName,\n+        const TString& path, std::shared_ptr<const NSchemeCache::TSchemeCacheNavigate> navigateResult, std::shared_ptr<arrow::RecordBatch> batch,\n+        std::shared_ptr<NYql::TIssues> issues)\n         : TBase(databaseName, path, TString(), longTxId, dedupId)\n         , ReplyTo(replyTo)\n         , NavigateResult(navigateResult)\n         , Batch(batch)\n-        , Issues(issues)\n-    {\n+        , Issues(issues) {\n         Y_ABORT_UNLESS(Issues);\n-        DataAccessor = std::make_shared<TParsedBatchData>(Batch);\n+        DataAccessor = std::make_unique<TParsedBatchData>(Batch);\n     }\n \n     void Bootstrap() {\n@@ -220,8 +233,9 @@ class TLongTxWriteInternal : public TLongTxWriteBase<TLongTxWriteInternal> {\n     }\n \n protected:\n-    NEvWrite::IShardsSplitter::IEvWriteDataAccessor& GetDataAccessor() const override {\n-        return *DataAccessor;\n+    std::unique_ptr<NEvWrite::IShardsSplitter::IEvWriteDataAccessor> ExtractDataAccessor() override {\n+        AFL_VERIFY(DataAccessor);\n+        return std::move(DataAccessor);\n     }\n \n     void RaiseIssue(const NYql::TIssue& issue) override {\n@@ -248,19 +262,14 @@ class TLongTxWriteInternal : public TLongTxWriteBase<TLongTxWriteInternal> {\n     std::shared_ptr<NYql::TIssues> Issues;\n };\n \n-\n-TActorId DoLongTxWriteSameMailbox(const TActorContext& ctx, const TActorId& replyTo,\n-    const NLongTxService::TLongTxId& longTxId, const TString& dedupId,\n-    const TString& databaseName, const TString& path,\n-    std::shared_ptr<const NSchemeCache::TSchemeCacheNavigate> navigateResult,\n-    std::shared_ptr<arrow::RecordBatch> batch, std::shared_ptr<NYql::TIssues> issues)\n-{\n-    return ctx.RegisterWithSameMailbox(\n-        new TLongTxWriteInternal(replyTo, longTxId, dedupId, databaseName, path, navigateResult, batch, issues));\n+TActorId DoLongTxWriteSameMailbox(const TActorContext& ctx, const TActorId& replyTo, const NLongTxService::TLongTxId& longTxId,\n+    const TString& dedupId, const TString& databaseName, const TString& path,\n+    std::shared_ptr<const NSchemeCache::TSchemeCacheNavigate> navigateResult, std::shared_ptr<arrow::RecordBatch> batch,\n+    std::shared_ptr<NYql::TIssues> issues) {\n+    return ctx.RegisterWithSameMailbox(new TLongTxWriteInternal(replyTo, longTxId, dedupId, databaseName, path, navigateResult, batch, issues));\n }\n \n //\n \n-\n-}\n-}\n+}   // namespace NTxProxy\n+}   // namespace NKikimr\ndiff --git a/ydb/core/tx/tx_proxy/upload_rows_common_impl.cpp b/ydb/core/tx/tx_proxy/upload_rows_common_impl.cpp\nindex 6d487a26016b..281d8bf05bc7 100644\n--- a/ydb/core/tx/tx_proxy/upload_rows_common_impl.cpp\n+++ b/ydb/core/tx/tx_proxy/upload_rows_common_impl.cpp\n@@ -7,10 +7,16 @@ namespace NKikimr {\n         : TBase(\"BulkUpsert\")\n     {\n         RequestsCount = TBase::GetDeriviative(\"Requests/Count\");\n-        ReplyDuration = TBase::GetHistogram(\"Replies/Duration\", NMonitoring::ExponentialHistogram(15, 2, 1));\n+        ReplyDuration = TBase::GetHistogram(\"Replies/Duration\", NMonitoring::ExponentialHistogram(15, 2, 10));\n \n         RowsCount = TBase::GetDeriviative(\"Rows/Count\");\n-        PackageSize = TBase::GetHistogram(\"Rows/PackageSize\", NMonitoring::ExponentialHistogram(15, 2, 10));\n+        PackageSizeRecordsByRecords = TBase::GetHistogram(\"ByRecords/PackageSize/Records\", NMonitoring::ExponentialHistogram(15, 2, 10));\n+        PackageSizeCountByRecords = TBase::GetHistogram(\"ByRecords/PackageSize/Count\", NMonitoring::ExponentialHistogram(15, 2, 10));\n+\n+        PreparingDuration = TBase::GetHistogram(\"Preparing/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10));\n+        WritingDuration = TBase::GetHistogram(\"Writing/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10));\n+        CommitDuration = TBase::GetHistogram(\"Commit/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10));\n+        PrepareReplyDuration = TBase::GetHistogram(\"ToReply/DurationMs\", NMonitoring::ExponentialHistogram(15, 2, 10));\n \n         const google::protobuf::EnumDescriptor* descriptor = ::Ydb::StatusIds::StatusCode_descriptor();\n         for (ui32 i = 0; i < (ui32)descriptor->value_count(); ++i) {\n@@ -19,12 +25,4 @@ namespace NKikimr {\n         }\n     }\n \n-    void TUploadCounters::OnReply(const TDuration d, const ::Ydb::StatusIds::StatusCode code) const {\n-        const TString name = ::Ydb::StatusIds::StatusCode_Name(code);\n-        auto it = CodesCount.find(name);\n-        Y_ABORT_UNLESS(it != CodesCount.end());\n-        it->second->Add(1);\n-        ReplyDuration->Collect(d.MilliSeconds());\n-    }\n-\n }\ndiff --git a/ydb/core/tx/tx_proxy/upload_rows_common_impl.h b/ydb/core/tx/tx_proxy/upload_rows_common_impl.h\nindex 599f9984b8ab..cbfaffaf23f4 100644\n--- a/ydb/core/tx/tx_proxy/upload_rows_common_impl.h\n+++ b/ydb/core/tx/tx_proxy/upload_rows_common_impl.h\n@@ -43,19 +43,77 @@ class TUploadCounters: public NColumnShard::TCommonCountersOwner {\n     NMonitoring::THistogramPtr ReplyDuration;\n \n     NMonitoring::TDynamicCounters::TCounterPtr RowsCount;\n-    NMonitoring::THistogramPtr PackageSize;\n+    NMonitoring::THistogramPtr PackageSizeRecordsByRecords;\n+    NMonitoring::THistogramPtr PackageSizeCountByRecords;\n+\n+    NMonitoring::THistogramPtr PreparingDuration;\n+    NMonitoring::THistogramPtr WritingDuration;\n+    NMonitoring::THistogramPtr CommitDuration;\n+    NMonitoring::THistogramPtr PrepareReplyDuration;\n \n     THashMap<TString, NMonitoring::TDynamicCounters::TCounterPtr> CodesCount;\n public:\n     TUploadCounters();\n \n+    class TGuard: TMoveOnly {\n+    private:\n+        TMonotonic Start = TMonotonic::Now();\n+        std::optional<TMonotonic> WritingStarted;\n+        std::optional<TMonotonic> CommitStarted;\n+        std::optional<TMonotonic> CommitFinished;\n+        std::optional<TMonotonic> ReplyFinished;\n+        TUploadCounters& Owner;\n+    public:\n+        TGuard(const TMonotonic start, TUploadCounters& owner)\n+            : Start(start)\n+            , Owner(owner)\n+        {\n+\n+        }\n+\n+        void OnWritingStarted() {\n+            WritingStarted = TMonotonic::Now();\n+            Owner.PreparingDuration->Collect((*WritingStarted - Start).MilliSeconds());\n+        }\n+\n+        void OnCommitStarted() {\n+            CommitStarted = TMonotonic::Now();\n+            AFL_VERIFY(WritingStarted);\n+            Owner.WritingDuration->Collect((*CommitStarted - *WritingStarted).MilliSeconds());\n+        }\n+\n+        void OnCommitFinished() {\n+            CommitFinished = TMonotonic::Now();\n+            AFL_VERIFY(CommitStarted);\n+            Owner.CommitDuration->Collect((*CommitFinished - *CommitStarted).MilliSeconds());\n+        }\n+\n+        void OnReply(const ::Ydb::StatusIds::StatusCode code) {\n+            ReplyFinished = TMonotonic::Now();\n+            if (CommitFinished) {\n+                Owner.PrepareReplyDuration->Collect((*ReplyFinished - *CommitFinished).MilliSeconds());\n+            }\n+            Owner.ReplyDuration->Collect((*ReplyFinished - Start).MilliSeconds());\n+\n+            const TString name = ::Ydb::StatusIds::StatusCode_Name(code);\n+            auto it = Owner.CodesCount.find(name);\n+            Y_ABORT_UNLESS(it != Owner.CodesCount.end());\n+            it->second->Add(1);\n+        }\n+    };\n+\n+    TGuard BuildGuard(const TMonotonic start) {\n+        return TGuard(start, *this);\n+    }\n+\n     void OnRequest(const ui64 rowsCount) const {\n         RequestsCount->Add(1);\n         RowsCount->Add(rowsCount);\n-        PackageSize->Collect(rowsCount);\n+        PackageSizeRecordsByRecords->Collect((i64)rowsCount, rowsCount);\n+        PackageSizeCountByRecords->Collect(rowsCount);\n     }\n \n-    void OnReply(const TDuration d, const ::Ydb::StatusIds::StatusCode code) const;\n+    void OnReply(const TDuration dFull, const TDuration dDelta, const ::Ydb::StatusIds::StatusCode code) const;\n };\n \n \n@@ -148,6 +206,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     TActorId LeaderPipeCache;\n     TDuration Timeout;\n     TInstant StartTime;\n+    std::optional<TInstant> StartCommitTime;\n     TActorId TimeoutTimerActorId;\n \n     TAutoPtr<NSchemeCache::TSchemeCacheRequest> ResolvePartitionsResult;\n@@ -164,7 +223,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     std::shared_ptr<NYql::TIssues> Issues = std::make_shared<NYql::TIssues>();\n     NLongTxService::TLongTxId LongTxId;\n     TUploadCounters UploadCounters;\n-\n+    TUploadCounters::TGuard UploadCountersGuard;\n protected:\n     enum class EUploadSource {\n         ProtoValues = 0,\n@@ -216,6 +275,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         , LeaderPipeCache(MakePipePerNodeCacheID(false))\n         , Timeout((timeout && timeout <= DEFAULT_TIMEOUT) ? timeout : DEFAULT_TIMEOUT)\n         , Status(Ydb::StatusIds::SUCCESS)\n+        , UploadCountersGuard(UploadCounters.BuildGuard(TMonotonic::Now()))\n         , DiskQuotaExceeded(diskQuotaExceeded)\n         , Span(std::move(span))\n     {}\n@@ -741,6 +801,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     }\n \n     void WriteToColumnTable(const NActors::TActorContext& ctx) {\n+        UploadCountersGuard.OnWritingStarted();\n         TString accessCheckError;\n         if (!CheckAccess(accessCheckError)) {\n             return ReplyWithError(Ydb::StatusIds::UNAUTHORIZED, LogPrefix() << accessCheckError, ctx);\n@@ -894,6 +955,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     }\n \n     void CommitLongTx(const TActorContext& ctx) {\n+        UploadCountersGuard.OnCommitStarted();\n         TActorId longTxServiceId = NLongTxService::MakeLongTxServiceID(ctx.SelfID.NodeId());\n         ctx.Send(longTxServiceId, new NLongTxService::TEvLongTxService::TEvCommitTx(LongTxId), 0, 0, Span.GetTraceId());\n         TBase::Become(&TThis::StateWaitCommitLongTx);\n@@ -908,6 +970,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     }\n \n     void Handle(NLongTxService::TEvLongTxService::TEvCommitTxResult::TPtr& ev, const NActors::TActorContext& ctx) {\n+        UploadCountersGuard.OnCommitFinished();\n         const auto* msg = ev->Get();\n \n         if (msg->Record.GetStatus() == Ydb::StatusIds::SUCCESS) {\n@@ -1263,7 +1326,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     }\n \n     void ReplyWithResult(::Ydb::StatusIds::StatusCode status, const TActorContext& ctx) {\n-        UploadCounters.OnReply(TAppData::TimeProvider->Now() - StartTime, status);\n+        UploadCountersGuard.OnReply(status);\n         SendResult(ctx, status);\n \n         LOG_DEBUG_S(ctx, NKikimrServices::RPC_REQUEST, LogPrefix() << \"completed with status \" << status);\ndiff --git a/ydb/core/tx/tx_proxy/ya.make b/ydb/core/tx/tx_proxy/ya.make\nindex fa746bd1e249..d592810a65b2 100644\n--- a/ydb/core/tx/tx_proxy/ya.make\n+++ b/ydb/core/tx/tx_proxy/ya.make\n@@ -14,6 +14,7 @@ SRCS(\n     commitreq.cpp\n     upload_rows_common_impl.cpp\n     upload_rows.cpp\n+    global.cpp\n )\n \n GENERATE_ENUM_SERIALIZATION(read_table_impl.h)\ndiff --git a/ydb/library/accessor/validator.h b/ydb/library/accessor/validator.h\nindex df81586f8759..6182b524bfa7 100644\n--- a/ydb/library/accessor/validator.h\n+++ b/ydb/library/accessor/validator.h\n@@ -9,4 +9,9 @@ class TValidator {\n         AFL_VERIFY(!!object);\n         return object;\n     }\n+    template <class T>\n+    static T& CheckNotNull(T& object) {\n+        AFL_VERIFY(!!object);\n+        return object;\n+    }\n };\n\\ No newline at end of file\ndiff --git a/ydb/library/arrow_clickhouse/AggregateFunctions/AggregateFunctionNumRows.h b/ydb/library/arrow_clickhouse/AggregateFunctions/AggregateFunctionNumRows.h\nnew file mode 100644\nindex 000000000000..80e5ff270b34\n--- /dev/null\n+++ b/ydb/library/arrow_clickhouse/AggregateFunctions/AggregateFunctionNumRows.h\n@@ -0,0 +1,79 @@\n+// The code in this file is based on original ClickHouse source code\n+// which is licensed under Apache license v2.0\n+// See: https://github.com/ClickHouse/ClickHouse/\n+\n+#pragma once\n+#include \"arrow_clickhouse_types.h\"\n+\n+#include <AggregateFunctions/IAggregateFunction.h>\n+#include <AggregateFunctions/AggregateFunctionWrapper.h>\n+#include <Columns/ColumnsCommon.h>\n+\n+#include <array>\n+\n+namespace CH\n+{\n+\n+\n+struct AggregateFunctionNumRowsData\n+{\n+    UInt64 count = 0;\n+};\n+\n+\n+/// Count rows.\n+class AggregateFunctionNumRows final\n+    : public IAggregateFunctionDataHelper<AggregateFunctionNumRowsData, AggregateFunctionNumRows, /*skip_nulls=*/false>\n+{\n+public:\n+    AggregateFunctionNumRows(const DataTypes & argument_types_)\n+        : IAggregateFunctionDataHelper(argument_types_, {})\n+    {}\n+\n+    DataTypePtr getReturnType() const override\n+    {\n+        return std::make_shared<DataTypeUInt64>();\n+    }\n+\n+    bool allocatesMemoryInArena() const override { return false; }\n+\n+    void add(AggregateDataPtr __restrict place, const IColumn **, size_t, Arena *) const override\n+    {\n+        ++data(place).count;\n+    }\n+\n+    void addBatchSinglePlace(\n+        size_t row_begin,\n+        size_t row_end,\n+        AggregateDataPtr __restrict place,\n+        const IColumn ** /*columns*/,\n+        Arena *) const override\n+    {\n+        data(place).count += row_end - row_begin;\n+    }\n+\n+    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override\n+    {\n+        data(place).count += data(rhs).count;\n+    }\n+\n+    void insertResultInto(AggregateDataPtr __restrict place, MutableColumn & to, Arena *) const override\n+    {\n+        assert_cast<MutableColumnUInt64 &>(to).Append(data(place).count).ok();\n+    }\n+};\n+\n+class WrappedNumRows final : public ArrowAggregateFunctionWrapper\n+{\n+public:\n+    WrappedNumRows(std::string name)\n+        : ArrowAggregateFunctionWrapper(std::move(name))\n+    {}\n+\n+    AggregateFunctionPtr getHouseFunction(const DataTypes & argument_types) const override\n+    {\n+        return std::make_shared<AggregateFunctionNumRows>(argument_types);\n+    }\n+};\n+\n+}\ndiff --git a/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.cpp b/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.cpp\nindex 87eccca5e419..9442b239798a 100644\n--- a/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.cpp\n+++ b/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.cpp\n@@ -3,6 +3,7 @@\n #include <AggregateFunctions/AggregateFunctionCount.h>\n #include <AggregateFunctions/AggregateFunctionSum.h>\n #include <AggregateFunctions/AggregateFunctionAvg.h>\n+#include <AggregateFunctions/AggregateFunctionNumRows.h>\n \n namespace CH\n {\n@@ -22,6 +23,8 @@ AggregateFunctionPtr GetAggregateFunction(AggFunctionId id, const DataTypes & ar\n             return WrappedSum(\"\").getHouseFunction(argument_types);\n         case AggFunctionId::AGG_AVG:\n             return WrappedAvg(\"\").getHouseFunction(argument_types);\n+        case AggFunctionId::AGG_NUM_ROWS:\n+            return WrappedNumRows(\"\").getHouseFunction(argument_types);\n         default:\n             break;\n     }\ndiff --git a/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.h b/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.h\nindex f4f21463a10e..8638da084af0 100644\n--- a/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.h\n+++ b/ydb/library/arrow_clickhouse/AggregateFunctions/IAggregateFunction.h\n@@ -181,7 +181,7 @@ class IAggregateFunction : public std::enable_shared_from_this<IAggregateFunctio\n \n \n /// Implement method to obtain an address of 'add' function.\n-template <typename Derived>\n+template <typename Derived, bool skip_nulls = true>\n class IAggregateFunctionHelper : public IAggregateFunction\n {\n private:\n@@ -204,7 +204,7 @@ class IAggregateFunctionHelper : public IAggregateFunction\n         const IColumn ** columns,\n         Arena * arena) const override\n     {\n-        if (columns && columns[0]->null_bitmap_data())\n+        if (skip_nulls && columns && columns[0]->null_bitmap_data())\n         {\n             for (size_t i = row_begin; i < row_end; ++i)\n             {\n@@ -240,7 +240,7 @@ class IAggregateFunctionHelper : public IAggregateFunction\n         const IColumn ** columns,\n         Arena * arena) const override\n     {\n-        if (columns && columns[0]->null_bitmap_data())\n+        if (skip_nulls && columns && columns[0]->null_bitmap_data())\n         {\n             for (size_t i = row_begin; i < row_end; ++i)\n             {\n@@ -340,9 +340,12 @@ class IAggregateFunctionHelper : public IAggregateFunction\n \n \n /// Implements several methods for manipulation with data. T - type of structure with data for aggregation.\n-template <typename T, typename Derived>\n-class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n+template <typename T, typename Derived, bool skip_nulls = true>\n+class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived, skip_nulls>\n {\n+private:\n+    using Base = IAggregateFunctionHelper<Derived, skip_nulls>;\n+\n protected:\n     using Data = T;\n \n@@ -354,7 +357,7 @@ class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n     static constexpr bool DateTime64Supported = true;\n \n     IAggregateFunctionDataHelper(const DataTypes & argument_types_, const Array & parameters_)\n-        : IAggregateFunctionHelper<Derived>(argument_types_, parameters_) {}\n+        : Base(argument_types_, parameters_) {}\n \n     void create(AggregateDataPtr __restrict place) const override /// NOLINT\n     {\n@@ -397,7 +400,7 @@ class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n \n         if (func.allocatesMemoryInArena() || sizeof(Data) > 16 || func.sizeOfData() != sizeof(Data))\n         {\n-            IAggregateFunctionHelper<Derived>::addBatchLookupTable8(row_begin, row_end, map, place_offset, init, key, columns, arena);\n+            Base::addBatchLookupTable8(row_begin, row_end, map, place_offset, init, key, columns, arena);\n             return;\n         }\n \n@@ -493,6 +496,7 @@ enum class AggFunctionId {\n     //AGG_QUANTILES = 14,\n     //AGG_TOP_COUNT = 15,\n     //AGG_TOP_SUM = 16,\n+    AGG_NUM_ROWS = 17,\n };\n \n struct GroupByOptions : public arrow::compute::ScalarAggregateOptions {\ndiff --git a/ydb/library/arrow_kernels/func_num_rows.h b/ydb/library/arrow_kernels/func_num_rows.h\nnew file mode 100644\nindex 000000000000..f9d353232ec9\n--- /dev/null\n+++ b/ydb/library/arrow_kernels/func_num_rows.h\n@@ -0,0 +1,20 @@\n+#pragma once\n+#include \"clickhouse_type_traits.h\"\n+#include \"func_common.h\"\n+\n+namespace NKikimr::NKernels {\n+\n+struct TNumRows: public arrow::compute::MetaFunction {\n+public:\n+    TNumRows(const TString name)\n+        : arrow::compute::MetaFunction(name.data(), arrow::compute::Arity::Unary(), nullptr) {\n+    }\n+\n+    arrow::Result<arrow::Datum> ExecuteImpl(const std::vector<arrow::Datum>& args, const arrow::compute::FunctionOptions* /*options*/,\n+        arrow::compute::ExecContext* /*ctx*/) const override {\n+        Y_ABORT_UNLESS(args.size() == 1);\n+        return arrow::Datum(std::make_shared<arrow::UInt64Scalar>(args[0].make_array()->length()));\n+    }\n+};\n+\n+}   // namespace NKikimr::NKernels\ndiff --git a/ydb/library/arrow_kernels/functions.h b/ydb/library/arrow_kernels/functions.h\nindex 2f4523a4fe20..10d45bfc7eec 100644\n--- a/ydb/library/arrow_kernels/functions.h\n+++ b/ydb/library/arrow_kernels/functions.h\n@@ -7,3 +7,4 @@\n #include \"func_modulo_or_zero.h\"\n #include \"func_math.h\"\n #include \"func_round.h\"\n+#include \"func_num_rows.h\"\ndiff --git a/ydb/library/conclusion/result.h b/ydb/library/conclusion/result.h\nindex 72aaf29f1a47..3e0cde0c7da2 100644\n--- a/ydb/library/conclusion/result.h\n+++ b/ydb/library/conclusion/result.h\n@@ -40,6 +40,11 @@ class TConclusion {\n         : Result(result) {\n     }\n \n+    template <class TResultArg>\n+    TConclusion(TResultArg& result)\n+        : Result(result) {\n+    }\n+\n     const TConclusionStatus& GetError() const {\n         auto result = std::get_if<TConclusionStatus>(&Result);\n         Y_ABORT_UNLESS(result, \"incorrect object for error request\");\ndiff --git a/ydb/library/formats/arrow/accessor/abstract/accessor.cpp b/ydb/library/formats/arrow/accessor/abstract/accessor.cpp\nnew file mode 100644\nindex 000000000000..c58ed0e28373\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/abstract/accessor.cpp\n@@ -0,0 +1,161 @@\n+#include \"accessor.h\"\n+\n+#include <ydb/library/formats/arrow/arrow_helpers.h>\n+#include <ydb/library/formats/arrow/permutations.h>\n+#include <ydb/library/formats/arrow/size_calcer.h>\n+#include <ydb/library/formats/arrow/switch/compare.h>\n+#include <ydb/library/formats/arrow/switch/switch_type.h>\n+\n+#include <ydb/library/actors/core/log.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+void IChunkedArray::TReader::AppendPositionTo(arrow::ArrayBuilder& builder, const ui64 position, ui64* recordSize) const {\n+    auto address = GetReadChunk(position);\n+    AFL_VERIFY(NArrow::Append(builder, *address.GetArray(), address.GetPosition(), recordSize));\n+}\n+\n+std::shared_ptr<arrow::Array> IChunkedArray::TReader::CopyRecord(const ui64 recordIndex) const {\n+    auto address = GetReadChunk(recordIndex);\n+    return NArrow::CopyRecords(address.GetArray(), { address.GetPosition() });\n+}\n+\n+std::shared_ptr<arrow::ChunkedArray> IChunkedArray::Slice(const ui32 offset, const ui32 count) const {\n+    AFL_VERIFY(offset + count <= (ui64)GetRecordsCount())(\"offset\", offset)(\"count\", count)(\"length\", GetRecordsCount());\n+    ui32 currentOffset = offset;\n+    ui32 countLeast = count;\n+    std::vector<std::shared_ptr<arrow::Array>> chunks;\n+    auto address = GetChunkSlow(offset);\n+    while (countLeast) {\n+        address = GetChunk(address.GetAddress(), currentOffset);\n+        const ui64 internalPos = address.GetAddress().GetLocalIndex(currentOffset);\n+        if (internalPos + countLeast <= (ui64)address.GetArray()->length()) {\n+            chunks.emplace_back(address.GetArray()->Slice(internalPos, countLeast));\n+            break;\n+        } else {\n+            const ui32 deltaCount = address.GetArray()->length() - internalPos;\n+            chunks.emplace_back(address.GetArray()->Slice(internalPos, deltaCount));\n+            AFL_VERIFY(countLeast >= deltaCount);\n+            countLeast -= deltaCount;\n+            currentOffset += deltaCount;\n+        }\n+    }\n+    return std::make_shared<arrow::ChunkedArray>(chunks, DataType);\n+}\n+\n+NKikimr::NArrow::NAccessor::IChunkedArray::TFullDataAddress IChunkedArray::GetChunk(\n+    const std::optional<TAddressChain>& chunkCurrent, const ui64 position) const {\n+    AFL_VERIFY(position < GetRecordsCount())(\"pos\", position)(\"records\", GetRecordsCount())(\"current\", chunkCurrent ? chunkCurrent->DebugString() : Default<TString>());\n+    std::optional<TCommonChunkAddress> address;\n+\n+    if (IsDataOwner()) {\n+        if (chunkCurrent) {\n+            AFL_VERIFY(chunkCurrent->GetSize() == 1)(\"size\", chunkCurrent->GetSize());\n+        }\n+        auto localAddress = GetLocalData(address, position);\n+        TAddressChain addressChain;\n+        addressChain.Add(localAddress.GetAddress());\n+        AFL_VERIFY(addressChain.Contains(position));\n+        return TFullDataAddress(localAddress.GetArray(), std::move(addressChain));\n+    } else {\n+        auto chunkedArrayAddress = GetArray(chunkCurrent, position, nullptr);\n+        if (chunkCurrent) {\n+            AFL_VERIFY(chunkCurrent->GetSize() == 1 + chunkedArrayAddress.GetAddress().GetSize())(\"current\", chunkCurrent->GetSize())(\n+                                                          \"chunked\", chunkedArrayAddress.GetAddress().GetSize());\n+        }\n+        auto localAddress = chunkedArrayAddress.GetArray()->GetLocalData(address, chunkedArrayAddress.GetAddress().GetLocalIndex(position));\n+        auto fullAddress = std::move(chunkedArrayAddress.MutableAddress());\n+        fullAddress.Add(localAddress.GetAddress());\n+        AFL_VERIFY(fullAddress.Contains(position));\n+        return TFullDataAddress(localAddress.GetArray(), std::move(fullAddress));\n+    }\n+}\n+\n+IChunkedArray::TFullChunkedArrayAddress IChunkedArray::GetArray(\n+    const std::optional<TAddressChain>& chunkCurrent, const ui64 position, const std::shared_ptr<IChunkedArray>& selfPtr) const {\n+    AFL_VERIFY(position < GetRecordsCount());\n+    if (IsDataOwner()) {\n+        AFL_VERIFY(selfPtr);\n+        TAddressChain chain;\n+        chain.Add(TCommonChunkAddress(0, GetRecordsCount(), 0));\n+        return IChunkedArray::TFullChunkedArrayAddress(selfPtr, std::move(chain));\n+    }\n+    TAddressChain addressChain;\n+\n+    auto* currentLevel = this;\n+    ui32 currentPosition = position;\n+    ui32 idx = 0;\n+    std::vector<std::shared_ptr<IChunkedArray>> chainForTemporarySave;\n+    while (!currentLevel->IsDataOwner()) {\n+        std::optional<TCommonChunkAddress> currentAddress;\n+        if (chunkCurrent) {\n+            currentAddress = chunkCurrent->GetAddress(idx);\n+        }\n+        auto nextChunkedArray = currentLevel->GetLocalChunkedArray(currentAddress, currentPosition);\n+        chainForTemporarySave.emplace_back(nextChunkedArray.GetArray());\n+        currentLevel = chainForTemporarySave.back().get();\n+        addressChain.Add(nextChunkedArray.GetAddress());\n+        AFL_VERIFY(nextChunkedArray.GetAddress().GetStartPosition() <= currentPosition);\n+        currentPosition -= nextChunkedArray.GetAddress().GetStartPosition();\n+        ++idx;\n+    }\n+    AFL_VERIFY(!chunkCurrent || chunkCurrent->GetSize() - idx <= 1)(\"idx\", idx)(\"size\", chunkCurrent->GetSize());\n+    return TFullChunkedArrayAddress(chainForTemporarySave.back(), std::move(addressChain));\n+}\n+\n+TString IChunkedArray::TReader::DebugString(const ui32 position) const {\n+    auto address = GetReadChunk(position);\n+    return NArrow::DebugString(address.GetArray(), address.GetPosition());\n+}\n+\n+std::partial_ordering IChunkedArray::TReader::CompareColumns(\n+    const std::vector<TReader>& l, const ui64 lPosition, const std::vector<TReader>& r, const ui64 rPosition) {\n+    AFL_VERIFY(l.size() == r.size());\n+    for (ui32 i = 0; i < l.size(); ++i) {\n+        const TAddress lAddress = l[i].GetReadChunk(lPosition);\n+        const TAddress rAddress = r[i].GetReadChunk(rPosition);\n+        auto cmp = lAddress.Compare(rAddress);\n+        if (std::is_neq(cmp)) {\n+            return cmp;\n+        }\n+    }\n+    return std::partial_ordering::equivalent;\n+}\n+\n+IChunkedArray::TAddress IChunkedArray::TReader::GetReadChunk(const ui64 position) const {\n+    AFL_VERIFY(position < ChunkedArray->GetRecordsCount());\n+    if (CurrentChunkAddress && CurrentChunkAddress->GetAddress().Contains(position)) {\n+    } else {\n+        CurrentChunkAddress = ChunkedArray->GetChunk(CurrentChunkAddress, position);\n+    }\n+    return IChunkedArray::TAddress(CurrentChunkAddress->GetArray(), CurrentChunkAddress->GetAddress().GetLocalIndex(position));\n+}\n+\n+const std::partial_ordering IChunkedArray::TAddress::Compare(const TAddress& item) const {\n+    return TComparator::TypedCompare<true>(*Array, Position, *item.Array, item.Position);\n+}\n+\n+TChunkedArraySerialized::TChunkedArraySerialized(const std::shared_ptr<IChunkedArray>& array, const TString& serializedData)\n+    : Array(array)\n+    , SerializedData(serializedData) {\n+    AFL_VERIFY(serializedData);\n+    AFL_VERIFY(Array);\n+    AFL_VERIFY(Array->GetRecordsCount());\n+}\n+\n+std::partial_ordering IChunkedArray::TFullDataAddress::Compare(\n+    const ui64 position, const TFullDataAddress& item, const ui64 itemPosition) const {\n+    AFL_VERIFY(Address.Contains(position))(\"pos\", position)(\"start\", Address.DebugString());\n+    AFL_VERIFY(item.Address.Contains(itemPosition))(\"pos\", itemPosition)(\"start\", item.Address.DebugString());\n+    return TComparator::TypedCompare<true>(*Array, Address.GetLocalIndex(position), *item.Array, item.Address.GetLocalIndex(itemPosition));\n+}\n+\n+std::shared_ptr<arrow::Array> IChunkedArray::TFullDataAddress::CopyRecord(const ui64 recordIndex) const {\n+    return NArrow::CopyRecords(Array, { Address.GetLocalIndex(recordIndex) });\n+}\n+\n+TString IChunkedArray::TFullDataAddress::DebugString(const ui64 position) const {\n+    return NArrow::DebugString(Array, Address.GetLocalIndex(position));\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/library/formats/arrow/accessor/abstract/accessor.h b/ydb/library/formats/arrow/accessor/abstract/accessor.h\nnew file mode 100644\nindex 000000000000..934ca2fddea4\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/abstract/accessor.h\n@@ -0,0 +1,401 @@\n+#pragma once\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/accessor/validator.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/chunked_array.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <util/string/builder.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TColumnSaver;\n+class IChunkedArray;\n+\n+class TChunkedArraySerialized {\n+private:\n+    YDB_READONLY_DEF(std::shared_ptr<IChunkedArray>, Array);\n+    YDB_READONLY_DEF(TString, SerializedData);\n+\n+public:\n+    TChunkedArraySerialized(const std::shared_ptr<IChunkedArray>& array, const TString& serializedData);\n+};\n+\n+class IChunkedArray {\n+public:\n+    enum class EType {\n+        Undefined,\n+        Array,\n+        ChunkedArray,\n+        SerializedChunkedArray,\n+        SparsedArray\n+    };\n+\n+    class TCommonChunkAddress {\n+    private:\n+        YDB_READONLY(ui64, StartPosition, 0);\n+        YDB_READONLY(ui64, FinishPosition, 0);\n+        YDB_READONLY(ui64, ChunkIndex, 0);\n+\n+    public:\n+        TString DebugString() const {\n+            return TStringBuilder() << \"start=\" << StartPosition << \";\"\n+                                    << \"chunk_index=\" << ChunkIndex << \";\"\n+                                    << \"finish=\" << FinishPosition << \";\"\n+                                    << \"size=\" << FinishPosition - StartPosition << \";\";\n+        }\n+\n+        ui64 GetLength() const {\n+            return FinishPosition - StartPosition;\n+        }\n+\n+        bool Contains(const ui64 position) const {\n+            return position >= StartPosition && position < FinishPosition;\n+        }\n+\n+        TCommonChunkAddress(const ui64 start, const ui64 finish, const ui64 index)\n+            : StartPosition(start)\n+            , FinishPosition(finish)\n+            , ChunkIndex(index) {\n+            AFL_VERIFY(FinishPosition > StartPosition);\n+        }\n+    };\n+\n+    class TAddressChain {\n+    private:\n+        YDB_READONLY_DEF(std::deque<TCommonChunkAddress>, Addresses);\n+        YDB_READONLY(ui32, GlobalStartPosition, 0);\n+        YDB_READONLY(ui32, GlobalFinishPosition, 0);\n+\n+    public:\n+        TAddressChain() = default;\n+\n+        ui32 GetSize() const {\n+            return Addresses.size();\n+        }\n+\n+        ui32 GetLocalIndex(const ui32 position) const {\n+            AFL_VERIFY(Contains(position))(\"pos\", position)(\"start\", GlobalStartPosition);\n+            return position - GlobalStartPosition;\n+        }\n+\n+        bool Contains(const ui32 position) const {\n+            return GlobalStartPosition <= position && position < GlobalFinishPosition;\n+        }\n+\n+        const TCommonChunkAddress& GetAddress(const ui32 index) const {\n+            AFL_VERIFY(index < Addresses.size());\n+            return Addresses[index];\n+        }\n+\n+        void Add(const TCommonChunkAddress& address) {\n+            if (Addresses.size()) {\n+                AFL_VERIFY(address.GetFinishPosition() <= Addresses.back().GetLength());\n+            }\n+            Addresses.emplace_back(address);\n+            GlobalStartPosition += address.GetStartPosition();\n+            GlobalFinishPosition = GlobalStartPosition + address.GetLength();\n+        }\n+\n+        const TCommonChunkAddress& GetLastAddress() const {\n+            AFL_VERIFY(Addresses.size());\n+            return Addresses.back();\n+        }\n+\n+        TString DebugString() const {\n+            TStringBuilder sb;\n+            sb << \"start=\" << GlobalStartPosition << \";finish=\" << GlobalFinishPosition\n+                << \";addresses_count=\" << Addresses.size() << \";\";\n+            for (auto&& i : Addresses) {\n+                sb << \"addresses=\" << i.DebugString() << \";\";\n+            }\n+            return sb;\n+        }\n+    };\n+\n+    class TFullChunkedArrayAddress {\n+    private:\n+        YDB_READONLY_DEF(std::shared_ptr<IChunkedArray>, Array);\n+        YDB_ACCESSOR_DEF(TAddressChain, Address);\n+\n+    public:\n+        TFullChunkedArrayAddress(const std::shared_ptr<IChunkedArray>& arr, TAddressChain&& address)\n+            : Array(arr)\n+            , Address(std::move(address))\n+        {\n+            AFL_VERIFY(Address.GetSize());\n+            AFL_VERIFY(Array);\n+            AFL_VERIFY(Array->GetRecordsCount());\n+        }\n+    };\n+\n+    class TLocalChunkedArrayAddress {\n+    private:\n+        YDB_READONLY_DEF(std::shared_ptr<IChunkedArray>, Array);\n+        TCommonChunkAddress Address;\n+\n+    public:\n+        const TCommonChunkAddress& GetAddress() const {\n+            return Address;\n+        }\n+\n+        TLocalChunkedArrayAddress(const std::shared_ptr<IChunkedArray>& arr, const TCommonChunkAddress& address)\n+            : Array(arr)\n+            , Address(address) {\n+            AFL_VERIFY(arr);\n+            AFL_VERIFY(address.GetLength() == (ui32)arr->GetRecordsCount());\n+        }\n+\n+        TLocalChunkedArrayAddress(const std::shared_ptr<IChunkedArray>& arr, const ui32 start, const ui32 chunkIdx)\n+            : Array(arr)\n+            , Address(TCommonChunkAddress(start, start + TValidator::CheckNotNull(arr)->GetRecordsCount(), chunkIdx)) {\n+        }\n+    };\n+\n+    class TFullDataAddress {\n+    private:\n+        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);\n+        YDB_ACCESSOR_DEF(TAddressChain, Address);\n+\n+    public:\n+        TString DebugString(const ui64 position) const;\n+\n+        std::shared_ptr<arrow::Array> CopyRecord(const ui64 recordIndex) const;\n+\n+        std::partial_ordering Compare(const ui64 position, const TFullDataAddress& item, const ui64 itemPosition) const;\n+\n+        TFullDataAddress(const std::shared_ptr<arrow::Array>& arr, TAddressChain&& address)\n+            : Array(arr)\n+            , Address(std::move(address))\n+        {\n+            AFL_VERIFY(Array);\n+            AFL_VERIFY(Address.GetSize());\n+        }\n+    };\n+\n+    class TLocalDataAddress {\n+    private:\n+        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);\n+        TCommonChunkAddress Address;\n+\n+    public:\n+        const TCommonChunkAddress& GetAddress() const {\n+            return Address;\n+        }\n+\n+        TLocalDataAddress(const std::shared_ptr<arrow::Array>& arr, const ui32 start, const ui32 chunkIdx)\n+            : Array(arr)\n+            , Address(start, start + TValidator::CheckNotNull(arr)->length(), chunkIdx)\n+        {\n+        }\n+\n+        TLocalDataAddress(const std::shared_ptr<arrow::Array>& arr, const TCommonChunkAddress& address)\n+            : Array(arr)\n+            , Address(address) {\n+            AFL_VERIFY(address.GetLength() == (ui32)arr->length());\n+        }\n+    };\n+\n+    class TAddress {\n+    private:\n+        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);\n+        YDB_READONLY(ui64, Position, 0);\n+\n+    public:\n+        bool NextPosition() {\n+            if (Position + 1 < (ui32)Array->length()) {\n+                ++Position;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        TAddress(const std::shared_ptr<arrow::Array>& arr, const ui64 position)\n+            : Array(arr)\n+            , Position(position)\n+        {\n+            AFL_VERIFY(!!Array);\n+            AFL_VERIFY(position < (ui32)Array->length());\n+        }\n+\n+        const std::partial_ordering Compare(const TAddress& item) const;\n+    };\n+\n+private:\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::DataType>, DataType);\n+    YDB_READONLY(ui64, RecordsCount, 0);\n+    YDB_READONLY(EType, Type, EType::Undefined);\n+    virtual std::optional<ui64> DoGetRawSize() const = 0;\n+    virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 index) const = 0;\n+\n+    virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const = 0;\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const = 0;\n+\n+protected:\n+    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const = 0;\n+    TLocalChunkedArrayAddress GetLocalChunkedArray(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {\n+        return DoGetLocalChunkedArray(chunkCurrent, position);\n+    }\n+    TLocalDataAddress GetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {\n+        return DoGetLocalData(chunkCurrent, position);\n+    }\n+    virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const = 0;\n+    virtual std::vector<TChunkedArraySerialized> DoSplitBySizes(\n+        const TColumnSaver& saver, const TString& fullSerializedData, const std::vector<ui64>& splitSizes) = 0;\n+\n+    template <class TCurrentPosition, class TChunkAccessor>\n+    void SelectChunk(const std::optional<TCurrentPosition>& chunkCurrent, const ui64 position, const TChunkAccessor& accessor) const {\n+        if (!chunkCurrent || chunkCurrent->GetStartPosition() <= position) {\n+            ui32 startIndex = 0;\n+            ui64 idx = 0;\n+            if (chunkCurrent) {\n+                if (position < chunkCurrent->GetFinishPosition()) {\n+                    return accessor.OnArray(\n+                        chunkCurrent->GetChunkIndex(), chunkCurrent->GetStartPosition());\n+                }\n+                AFL_VERIFY(chunkCurrent->GetChunkIndex() < accessor.GetChunksCount());\n+                startIndex = chunkCurrent->GetChunkIndex();\n+                idx = chunkCurrent->GetStartPosition();\n+            }\n+            for (ui32 i = startIndex; i < accessor.GetChunksCount(); ++i) {\n+                const ui64 nextIdx = idx + accessor.GetChunkLength(i);\n+                if (idx <= position && position < nextIdx) {\n+                    return accessor.OnArray(i, idx);\n+                }\n+                idx = nextIdx;\n+            }\n+        } else {\n+            AFL_VERIFY(chunkCurrent->GetChunkIndex() > 0);\n+            ui64 idx = chunkCurrent->GetStartPosition();\n+            for (i32 i = chunkCurrent->GetChunkIndex() - 1; i >= 0; --i) {\n+                AFL_VERIFY(idx >= accessor.GetChunkLength(i))(\"idx\", idx)(\"length\", accessor.GetChunkLength(i));\n+                const ui64 nextIdx = idx - accessor.GetChunkLength(i);\n+                if (nextIdx <= position && position < idx) {\n+                    return accessor.OnArray(i, nextIdx);\n+                }\n+                idx = nextIdx;\n+            }\n+        }\n+        TStringBuilder sb;\n+        ui64 recordsCountChunks = 0;\n+        for (ui32 i = 0; i < accessor.GetChunksCount(); ++i) {\n+            sb << accessor.GetChunkLength(i) << \",\";\n+            recordsCountChunks += accessor.GetChunkLength(i);\n+        }\n+        TStringBuilder chunkCurrentInfo;\n+        if (chunkCurrent) {\n+            chunkCurrentInfo << chunkCurrent->DebugString();\n+        }\n+        AFL_VERIFY(recordsCountChunks == GetRecordsCount())(\"pos\", position)(\"count\", GetRecordsCount())(\"chunks_map\", sb)(\n+            \"chunk_current\", chunkCurrentInfo);\n+        AFL_VERIFY(false)(\"pos\", position)(\"count\", GetRecordsCount())(\"chunks_map\", sb)(\"chunk_current\", chunkCurrentInfo);\n+    }\n+\n+public:\n+    class TReader {\n+    private:\n+        std::shared_ptr<IChunkedArray> ChunkedArray;\n+        mutable std::optional<TFullDataAddress> CurrentChunkAddress;\n+\n+    public:\n+        TReader(const std::shared_ptr<IChunkedArray>& data)\n+            : ChunkedArray(data) {\n+            AFL_VERIFY(ChunkedArray);\n+        }\n+\n+        ui64 GetRecordsCount() const {\n+            return ChunkedArray->GetRecordsCount();\n+        }\n+\n+        TAddress GetReadChunk(const ui64 position) const;\n+        static std::partial_ordering CompareColumns(\n+            const std::vector<TReader>& l, const ui64 lPosition, const std::vector<TReader>& r, const ui64 rPosition);\n+        void AppendPositionTo(arrow::ArrayBuilder& builder, const ui64 position, ui64* recordSize) const;\n+        std::shared_ptr<arrow::Array> CopyRecord(const ui64 recordIndex) const;\n+        TString DebugString(const ui32 position) const;\n+    };\n+\n+    std::shared_ptr<arrow::Scalar> GetScalar(const ui32 index) const {\n+        AFL_VERIFY(index < GetRecordsCount());\n+        return DoGetScalar(index);\n+    }\n+\n+    std::vector<TChunkedArraySerialized> SplitBySizes(\n+        const TColumnSaver& saver, const TString& fullSerializedData, const std::vector<ui64>& splitSizes) {\n+        return DoSplitBySizes(saver, fullSerializedData, splitSizes);\n+    }\n+\n+    std::shared_ptr<arrow::Scalar> GetMaxScalar() const {\n+        AFL_VERIFY(GetRecordsCount());\n+        return DoGetMaxScalar();\n+    }\n+\n+    std::optional<ui64> GetRawSize() const {\n+        return DoGetRawSize();\n+    }\n+\n+    ui64 GetRawSizeVerified() const {\n+        auto result = GetRawSize();\n+        AFL_VERIFY(result);\n+        return *result;\n+    }\n+\n+    std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const {\n+        return DoGetChunkedArray();\n+    }\n+    virtual ~IChunkedArray() = default;\n+\n+    std::shared_ptr<arrow::ChunkedArray> Slice(const ui32 offset, const ui32 count) const;\n+\n+    bool IsDataOwner() const {\n+        switch (Type) {\n+            case EType::SparsedArray:\n+            case EType::ChunkedArray:\n+            case EType::Array:\n+                return true;\n+            case EType::Undefined:\n+                AFL_VERIFY(false);\n+            case EType::SerializedChunkedArray:\n+                return false;\n+        };\n+    }\n+\n+    TFullChunkedArrayAddress GetArray(\n+        const std::optional<TAddressChain>& chunkCurrent, const ui64 position, const std::shared_ptr<IChunkedArray>& selfPtr) const;\n+\n+    TFullDataAddress GetChunk(const std::optional<TFullDataAddress>& chunkCurrent, const ui64 position) const {\n+        if (chunkCurrent) {\n+            return GetChunk(chunkCurrent->GetAddress(), position);\n+        } else {\n+            return GetChunk(std::optional<TAddressChain>(), position);\n+        }\n+    }\n+\n+    TFullDataAddress GetChunkSlow(const ui64 position) const {\n+        return GetChunk(std::optional<TAddressChain>(), position);\n+    }\n+\n+    TFullChunkedArrayAddress GetArray(\n+        const std::optional<TFullChunkedArrayAddress>& chunkCurrent, const ui64 position, const std::shared_ptr<IChunkedArray>& selfPtr) const {\n+        if (chunkCurrent) {\n+            return GetArray(chunkCurrent->GetAddress(), position, selfPtr);\n+        } else {\n+            return GetArray(std::optional<TAddressChain>(), position, selfPtr);\n+        }\n+    }\n+\n+    TFullChunkedArrayAddress GetArraySlow(const ui64 position, const std::shared_ptr<IChunkedArray>& selfPtr) const {\n+        return GetArray(std::optional<TAddressChain>(), position, selfPtr);\n+    }\n+\n+    TFullDataAddress GetChunk(const std::optional<TAddressChain>& chunkCurrent, const ui64 position) const;\n+\n+    IChunkedArray(const ui64 recordsCount, const EType type, const std::shared_ptr<arrow::DataType>& dataType)\n+        : DataType(dataType)\n+        , RecordsCount(recordsCount)\n+        , Type(type) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/library/formats/arrow/accessor/abstract/ya.make b/ydb/library/formats/arrow/accessor/abstract/ya.make\nnew file mode 100644\nindex 000000000000..c3ebb89dace4\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/abstract/ya.make\n@@ -0,0 +1,14 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    ydb/library/formats/arrow/protos\n+    ydb/library/formats/arrow/accessor/common\n+    contrib/libs/apache/arrow\n+    ydb/library/conclusion\n+)\n+\n+SRCS(\n+    accessor.cpp\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/arrow/accessor/common/chunk_data.cpp b/ydb/library/formats/arrow/accessor/common/chunk_data.cpp\nnew file mode 100644\nindex 000000000000..da03037ef321\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/common/chunk_data.cpp\n@@ -0,0 +1,5 @@\n+#include \"chunk_data.h\"\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+}\ndiff --git a/ydb/library/formats/arrow/accessor/common/chunk_data.h b/ydb/library/formats/arrow/accessor/common/chunk_data.h\nnew file mode 100644\nindex 000000000000..d10d27abb85b\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/common/chunk_data.h\n@@ -0,0 +1,23 @@\n+#pragma once\n+#include <ydb/library/accessor/accessor.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TChunkConstructionData {\n+private:\n+    YDB_READONLY(ui32, RecordsCount, 0);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Scalar>, DefaultValue);\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::DataType>, ColumnType);\n+\n+public:\n+    TChunkConstructionData(\n+        const ui32 recordsCount, const std::shared_ptr<arrow::Scalar>& defaultValue, const std::shared_ptr<arrow::DataType>& columnType)\n+        : RecordsCount(recordsCount)\n+        , DefaultValue(defaultValue)\n+        , ColumnType(columnType) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/library/formats/arrow/accessor/common/const.cpp b/ydb/library/formats/arrow/accessor/common/const.cpp\nnew file mode 100644\nindex 000000000000..926a9ca94deb\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/common/const.cpp\n@@ -0,0 +1,5 @@\n+#include \"const.h\"\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+}\ndiff --git a/ydb/library/formats/arrow/accessor/common/const.h b/ydb/library/formats/arrow/accessor/common/const.h\nnew file mode 100644\nindex 000000000000..192332854478\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/common/const.h\n@@ -0,0 +1,12 @@\n+#pragma once\n+#include <util/generic/string.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TGlobalConst {\n+public:\n+    static const inline TString SparsedDataAccessorName = \"SPARSED\";\n+    static const inline TString PlainDataAccessorName = \"PLAIN\";\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/library/formats/arrow/accessor/common/ya.make b/ydb/library/formats/arrow/accessor/common/ya.make\nnew file mode 100644\nindex 000000000000..28ef714226aa\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/common/ya.make\n@@ -0,0 +1,12 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+)\n+\n+SRCS(\n+    chunk_data.cpp\n+    const.cpp\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/arrow/accessor/composite/accessor.cpp b/ydb/library/formats/arrow/accessor/composite/accessor.cpp\nnew file mode 100644\nindex 000000000000..5660aaccc922\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/composite/accessor.cpp\n@@ -0,0 +1,57 @@\n+#include \"accessor.h\"\n+namespace NKikimr::NArrow::NAccessor {\n+\n+namespace {\n+class TCompositeChunkAccessor {\n+private:\n+    const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& Chunks;\n+    std::optional<IChunkedArray::TLocalChunkedArrayAddress>* ResultArrayAddress = nullptr;\n+\n+public:\n+    TCompositeChunkAccessor(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& chunks,\n+        std::optional<IChunkedArray::TLocalChunkedArrayAddress>& result)\n+        : Chunks(chunks)\n+        , ResultArrayAddress(&result) {\n+    }\n+    ui64 GetChunksCount() const {\n+        return Chunks.size();\n+    }\n+    ui64 GetChunkLength(const ui32 idx) const {\n+        return Chunks[idx]->GetRecordsCount();\n+    }\n+    void OnArray(const ui32 chunkIdx, const ui32 startPosition) const {\n+        if (ResultArrayAddress) {\n+            *ResultArrayAddress = NArrow::NAccessor::IChunkedArray::TLocalChunkedArrayAddress(Chunks[chunkIdx], startPosition, chunkIdx);\n+        }\n+    }\n+};\n+}   // namespace\n+\n+IChunkedArray::TLocalDataAddress TCompositeChunkedArray::DoGetLocalData(\n+    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {\n+    AFL_VERIFY(false);\n+    return IChunkedArray::TLocalDataAddress(nullptr, 0, 0);\n+}\n+\n+IChunkedArray::TLocalChunkedArrayAddress TCompositeChunkedArray::DoGetLocalChunkedArray(\n+    const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {\n+    std::optional<IChunkedArray::TLocalChunkedArrayAddress> result;\n+    TCompositeChunkAccessor accessor(Chunks, result);\n+    SelectChunk(chunkCurrent, position, accessor);\n+    AFL_VERIFY(result);\n+    return *result;\n+}\n+\n+std::shared_ptr<arrow::ChunkedArray> TCompositeChunkedArray::DoGetChunkedArray() const {\n+    std::vector<std::shared_ptr<arrow::Array>> chunks;\n+    for (auto&& i : Chunks) {\n+        auto arr = i->GetChunkedArray();\n+        AFL_VERIFY(arr->num_chunks());\n+        for (auto&& chunk : arr->chunks()) {\n+            chunks.emplace_back(chunk);\n+        }\n+    }\n+    return std::make_shared<arrow::ChunkedArray>(chunks);\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/library/formats/arrow/accessor/composite/accessor.h b/ydb/library/formats/arrow/accessor/composite/accessor.h\nnew file mode 100644\nindex 000000000000..a86c36025d61\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/composite/accessor.h\n@@ -0,0 +1,69 @@\n+#pragma once\n+#include <ydb/library/formats/arrow/accessor/abstract/accessor.h>\n+#include <ydb/library/accessor/accessor.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TCompositeChunkedArray: public NArrow::NAccessor::IChunkedArray {\n+private:\n+    using TBase = NArrow::NAccessor::IChunkedArray;\n+\n+private:\n+    std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> Chunks;\n+\n+protected:\n+    virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(\n+        const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n+\n+    virtual std::vector<NArrow::NAccessor::TChunkedArraySerialized> DoSplitBySizes(\n+        const TColumnSaver& /*saver*/, const TString& /*fullSerializedData*/, const std::vector<ui64>& /*splitSizes*/) override {\n+        AFL_VERIFY(false);\n+        return {};\n+    }\n+\n+    virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 /*index*/) const override {\n+        AFL_VERIFY(false)(\"problem\", \"cannot use method\");\n+        return nullptr;\n+    }\n+    virtual std::optional<ui64> DoGetRawSize() const override {\n+        return {};\n+    }\n+    virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override {\n+        AFL_VERIFY(false);\n+        return nullptr;\n+    }\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n+    virtual std::shared_ptr<arrow::ChunkedArray> DoGetChunkedArray() const override;\n+\n+    TCompositeChunkedArray(std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>&& chunks, const ui32 recordsCount,\n+        const std::shared_ptr<arrow::DataType>& type)\n+        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, type)\n+        , Chunks(std::move(chunks)) {\n+    }\n+\n+public:\n+    class TBuilder {\n+    private:\n+        ui32 RecordsCount = 0;\n+        std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> Chunks;\n+        const std::shared_ptr<arrow::DataType> Type;\n+\n+    public:\n+        TBuilder(const std::shared_ptr<arrow::DataType>& type)\n+            : Type(type) {\n+            AFL_VERIFY(Type);\n+        }\n+\n+        void AddChunk(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& arr) {\n+            AFL_VERIFY(arr->GetDataType()->id() == Type->id())(\"incoming\", arr->GetDataType()->ToString())(\"main\", Type->ToString());\n+            Chunks.emplace_back(arr);\n+            RecordsCount += arr->GetRecordsCount();\n+        }\n+\n+        std::shared_ptr<TCompositeChunkedArray> Finish() {\n+            return std::shared_ptr<TCompositeChunkedArray>(new TCompositeChunkedArray(std::move(Chunks), RecordsCount, Type));\n+        }\n+    };\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/library/formats/arrow/accessor/composite/ya.make b/ydb/library/formats/arrow/accessor/composite/ya.make\nnew file mode 100644\nindex 000000000000..ed407a50f688\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/composite/ya.make\n@@ -0,0 +1,12 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/formats/arrow/common\n+)\n+\n+SRCS(\n+    accessor.cpp\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/arrow/accessor/ya.make b/ydb/library/formats/arrow/accessor/ya.make\nnew file mode 100644\nindex 000000000000..17f8331064bf\n--- /dev/null\n+++ b/ydb/library/formats/arrow/accessor/ya.make\n@@ -0,0 +1,8 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    ydb/library/formats/arrow/accessor/abstract\n+    ydb/library/formats/arrow/accessor/composite\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/arrow/arrow_helpers.cpp b/ydb/library/formats/arrow/arrow_helpers.cpp\nnew file mode 100644\nindex 000000000000..d27b18af5bc9\n--- /dev/null\n+++ b/ydb/library/formats/arrow/arrow_helpers.cpp\n@@ -0,0 +1,807 @@\n+#include \"arrow_helpers.h\"\n+#include \"switch_type.h\"\n+#include \"common/validation.h\"\n+#include \"permutations.h\"\n+#include \"simple_arrays_cache.h\"\n+#include \"replace_key.h\"\n+\n+#include <ydb/library/yverify_stream/yverify_stream.h>\n+#include <ydb/library/services/services.pb.h>\n+\n+#include <util/system/yassert.h>\n+#include <util/string/join.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/io/memory.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/ipc/reader.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_primitive.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_primitive.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type_traits.h>\n+#include <library/cpp/containers/stack_vector/stack_vec.h>\n+#include <ydb/library/actors/core/log.h>\n+#include <memory>\n+\n+#define Y_VERIFY_OK(status) Y_ABORT_UNLESS(status.ok(), \"%s\", status.ToString().c_str())\n+\n+namespace NKikimr::NArrow {\n+\n+TString SerializeSchema(const arrow::Schema& schema) {\n+    auto buffer = TStatusValidator::GetValid(arrow::ipc::SerializeSchema(schema));\n+    return buffer->ToString();\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> MakeEmptyBatch(const std::shared_ptr<arrow::Schema>& schema, const ui32 rowsCount) {\n+    std::vector<std::shared_ptr<arrow::Array>> columns;\n+    columns.reserve(schema->num_fields());\n+\n+    for (auto& field : schema->fields()) {\n+        auto result = NArrow::TThreadSimpleArraysCache::GetNull(field->type(), rowsCount);\n+        columns.emplace_back(result);\n+        Y_ABORT_UNLESS(result);\n+    }\n+    return arrow::RecordBatch::Make(schema, rowsCount, columns);\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> CombineBatches(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches) {\n+    if (batches.empty()) {\n+        return nullptr;\n+    }\n+    auto table = TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batches));\n+    return table ? ToBatch(table, true) : nullptr;\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> ToBatch(const std::shared_ptr<arrow::Table>& tableExt, const bool combine) {\n+    if (!tableExt) {\n+        return nullptr;\n+    }\n+    std::shared_ptr<arrow::Table> table;\n+    if (combine) {\n+        auto res = tableExt->CombineChunks();\n+        Y_ABORT_UNLESS(res.ok());\n+        table = *res;\n+    } else {\n+        table = tableExt;\n+    }\n+    std::vector<std::shared_ptr<arrow::Array>> columns;\n+    columns.reserve(table->num_columns());\n+    for (auto& col : table->columns()) {\n+        AFL_VERIFY(col->num_chunks() == 1)(\"size\", col->num_chunks())(\"size_bytes\", GetTableDataSize(tableExt))\n+            (\"schema\", tableExt->schema()->ToString())(\"size_new\", GetTableDataSize(table));\n+        columns.push_back(col->chunk(0));\n+    }\n+    return arrow::RecordBatch::Make(table->schema(), table->num_rows(), columns);\n+}\n+\n+// Check if the permutation doesn't reorder anything\n+bool IsTrivial(const arrow::UInt64Array& permutation, const ui64 originalLength) {\n+    if ((ui64)permutation.length() != originalLength) {\n+        return false;\n+    }\n+    for (i64 i = 0; i < permutation.length(); ++i) {\n+        if (permutation.Value(i) != (ui64)i) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> Reorder(const std::shared_ptr<arrow::RecordBatch>& batch,\n+                                            const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove) {\n+    Y_ABORT_UNLESS(permutation->length() == batch->num_rows() || canRemove);\n+\n+    auto res = IsTrivial(*permutation, batch->num_rows()) ? batch : arrow::compute::Take(batch, permutation);\n+    Y_ABORT_UNLESS(res.ok());\n+    return (*res).record_batch();\n+}\n+\n+THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows) {\n+    AFL_VERIFY(batch);\n+    std::shared_ptr<arrow::UInt64Array> permutation;\n+    {\n+        arrow::UInt64Builder builder;\n+        Y_VERIFY_OK(builder.Reserve(batch->num_rows()));\n+\n+        for (auto&& [shardId, rowIdxs]: shardRows) {\n+            for (auto& row : rowIdxs) {\n+                Y_VERIFY_OK(builder.Append(row));\n+            }\n+        }\n+        Y_VERIFY_OK(builder.Finish(&permutation));\n+    }\n+\n+    auto reorderedBatch = Reorder(batch, permutation, false);\n+\n+    THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> out;\n+\n+    int offset = 0;\n+    for (auto&& [shardId, shardRowIdxs] : shardRows) {\n+        if (shardRowIdxs.empty()) {\n+            continue;\n+        }\n+        out.emplace(shardId, reorderedBatch->Slice(offset, shardRowIdxs.size()));\n+        offset += shardRowIdxs.size();\n+    }\n+\n+    Y_ABORT_UNLESS(offset == batch->num_rows());\n+    return out;\n+}\n+\n+std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::vector<ui32>>& shardRows, const ui32 numShards) {\n+    AFL_VERIFY(batch);\n+    std::shared_ptr<arrow::UInt64Array> permutation;\n+    {\n+        arrow::UInt64Builder builder;\n+        Y_VERIFY_OK(builder.Reserve(batch->num_rows()));\n+\n+        for (ui32 shardNo = 0; shardNo < numShards; ++shardNo) {\n+            for (auto& row : shardRows[shardNo]) {\n+                Y_VERIFY_OK(builder.Append(row));\n+            }\n+        }\n+        Y_VERIFY_OK(builder.Finish(&permutation));\n+    }\n+\n+    auto reorderedBatch = Reorder(batch, permutation, false);\n+\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> out(numShards);\n+\n+    int offset = 0;\n+    for (ui32 shardNo = 0; shardNo < numShards; ++shardNo) {\n+        int length = shardRows[shardNo].size();\n+        if (length) {\n+            out[shardNo] = reorderedBatch->Slice(offset, length);\n+            offset += length;\n+        }\n+    }\n+\n+    Y_ABORT_UNLESS(offset == batch->num_rows());\n+    return out;\n+}\n+\n+std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch,\n+                                                               const std::vector<ui32>& sharding, ui32 numShards) {\n+    AFL_VERIFY(batch);\n+    Y_ABORT_UNLESS((size_t)batch->num_rows() == sharding.size());\n+\n+    std::vector<std::vector<ui32>> shardRows(numShards);\n+    for (size_t row = 0; row < sharding.size(); ++row) {\n+        ui32 shardNo = sharding[row];\n+        Y_ABORT_UNLESS(shardNo < numShards);\n+        shardRows[shardNo].push_back(row);\n+    }\n+    return ShardingSplit(batch, shardRows, numShards);\n+}\n+\n+bool HasAllColumns(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& schema) {\n+    for (auto& field : schema->fields()) {\n+        if (batch->schema()->GetFieldIndex(field->name()) < 0) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+std::vector<std::unique_ptr<arrow::ArrayBuilder>> MakeBuilders(const std::shared_ptr<arrow::Schema>& schema,\n+                                                               size_t reserve, const std::map<std::string, ui64>& sizeByColumn) {\n+    std::vector<std::unique_ptr<arrow::ArrayBuilder>> builders;\n+    builders.reserve(schema->num_fields());\n+\n+    for (auto& field : schema->fields()) {\n+        std::unique_ptr<arrow::ArrayBuilder> builder;\n+        TStatusValidator::Validate(arrow::MakeBuilder(arrow::default_memory_pool(), field->type(), &builder));\n+        if (sizeByColumn.size()) {\n+            auto it = sizeByColumn.find(field->name());\n+            if (it != sizeByColumn.end()) {\n+                AFL_VERIFY(NArrow::ReserveData(*builder, it->second))(\"size\", it->second)(\"field\", field->name());\n+            }\n+        }\n+\n+        if (reserve) {\n+            TStatusValidator::Validate(builder->Reserve(reserve));\n+        }\n+\n+        builders.emplace_back(std::move(builder));\n+\n+    }\n+    return builders;\n+}\n+\n+std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::Field>& field) {\n+    AFL_VERIFY(field);\n+    return MakeBuilder(field->type());\n+}\n+\n+std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::DataType>& type) {\n+    AFL_VERIFY(type);\n+    std::unique_ptr<arrow::ArrayBuilder> builder;\n+    TStatusValidator::Validate(arrow::MakeBuilder(arrow::default_memory_pool(), type, &builder));\n+    return std::move(builder);\n+}\n+\n+std::vector<std::shared_ptr<arrow::Array>> Finish(std::vector<std::unique_ptr<arrow::ArrayBuilder>>&& builders) {\n+    std::vector<std::shared_ptr<arrow::Array>> out;\n+    for (auto& builder : builders) {\n+        std::shared_ptr<arrow::Array> array;\n+        TStatusValidator::Validate(builder->Finish(&array));\n+        out.emplace_back(array);\n+    }\n+    return out;\n+}\n+\n+std::vector<TString> ColumnNames(const std::shared_ptr<arrow::Schema>& schema) {\n+    std::vector<TString> out;\n+    out.reserve(schema->num_fields());\n+    for (int i = 0; i < schema->num_fields(); ++i) {\n+        auto& name = schema->field(i)->name();\n+        out.emplace_back(TString(name.data(), name.size()));\n+    }\n+    return out;\n+}\n+\n+std::shared_ptr<arrow::UInt64Array> MakeUI64Array(ui64 value, i64 size) {\n+    auto res = arrow::MakeArrayFromScalar(arrow::UInt64Scalar(value), size);\n+    Y_ABORT_UNLESS(res.ok());\n+    return std::static_pointer_cast<arrow::UInt64Array>(*res);\n+}\n+\n+std::pair<int, int> FindMinMaxPosition(const std::shared_ptr<arrow::Array>& array) {\n+    if (array->length() == 0) {\n+        return {-1, -1};\n+    }\n+\n+    int minPos = 0;\n+    int maxPos = 0;\n+    SwitchType(array->type_id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+\n+        auto& column = static_cast<const TArray&>(*array);\n+\n+        for (int i = 1; i < column.length(); ++i) {\n+            const auto& value = column.GetView(i);\n+            if (value < column.GetView(minPos)) {\n+                minPos = i;\n+            }\n+            if (value > column.GetView(maxPos)) {\n+                maxPos = i;\n+            }\n+        }\n+        return true;\n+    });\n+    return {minPos, maxPos};\n+}\n+\n+std::shared_ptr<arrow::Scalar> MinScalar(const std::shared_ptr<arrow::DataType>& type) {\n+    std::shared_ptr<arrow::Scalar> out;\n+    SwitchType(type->id(), [&](const auto& t) {\n+        using TWrap = std::decay_t<decltype(t)>;\n+        using T = typename TWrap::T;\n+        using TScalar = typename arrow::TypeTraits<T>::ScalarType;\n+\n+        if constexpr (std::is_same_v<T, arrow::StringType> ||\n+                      std::is_same_v<T, arrow::BinaryType> ||\n+                      std::is_same_v<T, arrow::LargeStringType> ||\n+                      std::is_same_v<T, arrow::LargeBinaryType>) {\n+            out = std::make_shared<TScalar>(arrow::Buffer::FromString(\"\"), type);\n+        } else if constexpr (std::is_same_v<T, arrow::FixedSizeBinaryType>) {\n+            std::string s(static_cast<arrow::FixedSizeBinaryType&>(*type).byte_width(), '\\0');\n+            out = std::make_shared<TScalar>(arrow::Buffer::FromString(s), type);\n+        } else if constexpr (std::is_same_v<T, arrow::HalfFloatType>) {\n+            return false;\n+        } else if constexpr (arrow::is_temporal_type<T>::value) {\n+            using TCType = typename arrow::TypeTraits<T>::CType;\n+            out = std::make_shared<TScalar>(Min<TCType>(), type);\n+        } else if constexpr (arrow::has_c_type<T>::value) {\n+            using TCType = typename arrow::TypeTraits<T>::CType;\n+            out = std::make_shared<TScalar>(Min<TCType>());\n+        } else {\n+            return false;\n+        }\n+        return true;\n+    });\n+    Y_ABORT_UNLESS(out);\n+    return out;\n+}\n+\n+namespace {\n+\n+template <class T>\n+class TDefaultScalarValue {\n+public:\n+    static constexpr T Value = 0;\n+};\n+\n+template <>\n+class TDefaultScalarValue<bool> {\n+public:\n+    static constexpr bool Value = false;\n+};\n+\n+}\n+\n+std::shared_ptr<arrow::Scalar> DefaultScalar(const std::shared_ptr<arrow::DataType>& type) {\n+    std::shared_ptr<arrow::Scalar> out;\n+    SwitchType(type->id(), [&](const auto& t) {\n+        using TWrap = std::decay_t<decltype(t)>;\n+        using T = typename TWrap::T;\n+        using TScalar = typename arrow::TypeTraits<T>::ScalarType;\n+\n+        if constexpr (std::is_same_v<T, arrow::StringType> ||\n+            std::is_same_v<T, arrow::BinaryType> ||\n+            std::is_same_v<T, arrow::LargeStringType> ||\n+            std::is_same_v<T, arrow::LargeBinaryType>) {\n+            out = std::make_shared<TScalar>(arrow::Buffer::FromString(\"\"), type);\n+        } else if constexpr (std::is_same_v<T, arrow::FixedSizeBinaryType>) {\n+            std::string s(static_cast<arrow::FixedSizeBinaryType&>(*type).byte_width(), '\\0');\n+            out = std::make_shared<TScalar>(arrow::Buffer::FromString(s), type);\n+        } else if constexpr (std::is_same_v<T, arrow::HalfFloatType>) {\n+            return false;\n+        } else if constexpr (arrow::is_temporal_type<T>::value) {\n+            using TCType = typename arrow::TypeTraits<T>::CType;\n+            out = std::make_shared<TScalar>(TDefaultScalarValue<TCType>::Value, type);\n+        } else if constexpr (arrow::has_c_type<T>::value) {\n+            using TCType = typename arrow::TypeTraits<T>::CType;\n+            out = std::make_shared<TScalar>(TDefaultScalarValue<TCType>::Value);\n+        } else {\n+            return false;\n+        }\n+        return true;\n+    });\n+    AFL_VERIFY(out)(\"type\", type->ToString());\n+    return out;\n+}\n+\n+std::shared_ptr<arrow::Scalar> GetScalar(const std::shared_ptr<arrow::Array>& array, int position) {\n+    auto res = array->GetScalar(position);\n+    Y_ABORT_UNLESS(res.ok());\n+    return *res;\n+}\n+\n+bool IsGoodScalar(const std::shared_ptr<arrow::Scalar>& x) {\n+    if (!x) {\n+        return false;\n+    }\n+\n+    return SwitchType(x->type->id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TScalar = typename arrow::TypeTraits<typename TWrap::T>::ScalarType;\n+        using TValue = std::decay_t<decltype(static_cast<const TScalar&>(*x).value)>;\n+\n+        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+            const auto& xval = static_cast<const TScalar&>(*x).value;\n+            return xval && xval->data();\n+        }\n+        if constexpr (std::is_arithmetic_v<TValue>) {\n+            return true;\n+        }\n+        return false;\n+    });\n+}\n+\n+bool ScalarLess(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y) {\n+    Y_ABORT_UNLESS(x);\n+    Y_ABORT_UNLESS(y);\n+    return ScalarLess(*x, *y);\n+}\n+\n+bool ScalarLess(const arrow::Scalar& x, const arrow::Scalar& y) {\n+    return ScalarCompare(x, y) < 0;\n+}\n+\n+bool ColumnEqualsScalar(\n+    const std::shared_ptr<arrow::Array>& c, const ui32 position, const std::shared_ptr<arrow::Scalar>& s) {\n+    AFL_VERIFY(c);\n+    if (!s) {\n+        return c->IsNull(position) ;\n+    }\n+    AFL_VERIFY(c->type()->Equals(s->type))(\"s\", s->type->ToString())(\"c\", c->type()->ToString());\n+\n+    return SwitchTypeImpl<bool, 0>(c->type()->id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TScalar = typename arrow::TypeTraits<typename TWrap::T>::ScalarType;\n+        using TArrayType = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+        using TValue = std::decay_t<decltype(static_cast<const TScalar&>(*s).value)>;\n+\n+        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+            const auto& cval = static_cast<const TArrayType&>(*c).GetView(position);\n+            const auto& sval = static_cast<const TScalar&>(*s).value;\n+            AFL_VERIFY(sval);\n+            TStringBuf cBuf(reinterpret_cast<const char*>(cval.data()), cval.size());\n+            TStringBuf sBuf(reinterpret_cast<const char*>(sval->data()), sval->size());\n+            return cBuf == sBuf;\n+        }\n+        if constexpr (std::is_arithmetic_v<TValue>) {\n+            const auto cval = static_cast<const TArrayType&>(*c).GetView(position);\n+            const auto sval = static_cast<const TScalar&>(*s).value;\n+            return (cval == sval);\n+        }\n+        Y_ABORT_UNLESS(false);   // TODO: non primitive types\n+        return false;\n+    });\n+}\n+\n+int ScalarCompare(const arrow::Scalar& x, const arrow::Scalar& y) {\n+    Y_VERIFY_S(x.type->Equals(y.type), x.type->ToString() + \" vs \" + y.type->ToString());\n+\n+    return SwitchTypeImpl<int, 0>(x.type->id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TScalar = typename arrow::TypeTraits<typename TWrap::T>::ScalarType;\n+        using TValue = std::decay_t<decltype(static_cast<const TScalar&>(x).value)>;\n+\n+        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+            const auto& xval = static_cast<const TScalar&>(x).value;\n+            const auto& yval = static_cast<const TScalar&>(y).value;\n+            Y_ABORT_UNLESS(xval);\n+            Y_ABORT_UNLESS(yval);\n+            TStringBuf xBuf(reinterpret_cast<const char*>(xval->data()), xval->size());\n+            TStringBuf yBuf(reinterpret_cast<const char*>(yval->data()), yval->size());\n+            if (xBuf < yBuf) {\n+                return -1;\n+            } else if (yBuf < xBuf) {\n+                return 1;\n+            } else {\n+                return 0;\n+            }\n+        }\n+        if constexpr (std::is_arithmetic_v<TValue>) {\n+            const auto& xval = static_cast<const TScalar&>(x).value;\n+            const auto& yval = static_cast<const TScalar&>(y).value;\n+            if (xval < yval) {\n+                return -1;\n+            } else if (yval < xval) {\n+                return 1;\n+            } else {\n+                return 0;\n+            }\n+        }\n+        Y_ABORT_UNLESS(false); // TODO: non primitive types\n+        return 0;\n+    });\n+}\n+\n+int ScalarCompare(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y) {\n+    Y_ABORT_UNLESS(x);\n+    Y_ABORT_UNLESS(y);\n+    return ScalarCompare(*x, *y);\n+}\n+\n+int ScalarCompareNullable(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y) {\n+    if (!x && !!y) {\n+        return -1;\n+    }\n+    if (!!x && !y) {\n+        return 1;\n+    }\n+    if (!x && !y) {\n+        return 0;\n+    }\n+    return ScalarCompare(*x, *y);\n+}\n+\n+std::shared_ptr<arrow::Array> BoolVecToArray(const std::vector<bool>& vec) {\n+    std::shared_ptr<arrow::Array> out;\n+    arrow::BooleanBuilder builder;\n+    for (const auto val : vec) {\n+        Y_ABORT_UNLESS(builder.Append(val).ok());\n+    }\n+    Y_ABORT_UNLESS(builder.Finish(&out).ok());\n+    return out;\n+}\n+\n+\n+bool ArrayScalarsEqual(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs) {\n+    bool res = lhs->length() == rhs->length();\n+    for (int64_t i = 0; i < lhs->length() && res; ++i) {\n+        res &= arrow::ScalarEquals(*lhs->GetScalar(i).ValueOrDie(), *rhs->GetScalar(i).ValueOrDie());\n+    }\n+    return res;\n+}\n+\n+bool ReserveData(arrow::ArrayBuilder& builder, const size_t size) {\n+    arrow::Status result = arrow::Status::OK();\n+    if (builder.type()->id() == arrow::Type::BINARY ||\n+        builder.type()->id() == arrow::Type::STRING)\n+    {\n+        static_assert(std::is_convertible_v<arrow::StringBuilder&, arrow::BaseBinaryBuilder<arrow::BinaryType>&>,\n+            \"Expected StringBuilder to be BaseBinaryBuilder<BinaryType>\");\n+        auto& bBuilder = static_cast<arrow::BaseBinaryBuilder<arrow::BinaryType>&>(builder);\n+        result = bBuilder.ReserveData(size);\n+    }\n+\n+    if (!result.ok()) {\n+        AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"ReserveData\")(\"error\", result.ToString());\n+    }\n+    return result.ok();\n+}\n+\n+template <class TData, class TColumn, class TBuilder>\n+bool MergeBatchColumnsImpl(const std::vector<std::shared_ptr<TData>>& batches, std::shared_ptr<TData>& result,\n+    const std::vector<std::string>& columnsOrder, const bool orderFieldsAreNecessary, const TBuilder& builder) {\n+    if (batches.empty()) {\n+        result = nullptr;\n+        return true;\n+    }\n+    if (batches.size() == 1) {\n+        result = batches.front();\n+        return true;\n+    }\n+    std::vector<std::shared_ptr<arrow::Field>> fields;\n+    std::vector<std::shared_ptr<TColumn>> columns;\n+    std::map<std::string, ui32> fieldNames;\n+    for (auto&& i : batches) {\n+        Y_ABORT_UNLESS(i);\n+        for (auto&& f : i->schema()->fields()) {\n+            if (!fieldNames.emplace(f->name(), fields.size()).second) {\n+                AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"duplicated column\")(\"name\", f->name());\n+                return false;\n+            }\n+            fields.emplace_back(f);\n+        }\n+        if (i->num_rows() != batches.front()->num_rows()) {\n+            AFL_ERROR(NKikimrServices::ARROW_HELPER)(\"event\", \"inconsistency record sizes\")(\"i\", i->num_rows())(\"front\", batches.front()->num_rows());\n+            return false;\n+        }\n+        for (auto&& c : i->columns()) {\n+            columns.emplace_back(c);\n+        }\n+    }\n+\n+    Y_ABORT_UNLESS(fields.size() == columns.size());\n+    if (columnsOrder.size()) {\n+        std::vector<std::shared_ptr<arrow::Field>> fieldsOrdered;\n+        std::vector<std::shared_ptr<TColumn>> columnsOrdered;\n+        for (auto&& i : columnsOrder) {\n+            auto it = fieldNames.find(i);\n+            if (orderFieldsAreNecessary) {\n+                Y_ABORT_UNLESS(it != fieldNames.end());\n+            } else if (it == fieldNames.end()) {\n+                continue;\n+            }\n+            fieldsOrdered.emplace_back(fields[it->second]);\n+            columnsOrdered.emplace_back(columns[it->second]);\n+        }\n+        std::swap(fieldsOrdered, fields);\n+        std::swap(columnsOrdered, columns);\n+    }\n+    result = builder(std::make_shared<arrow::Schema>(fields), batches.front()->num_rows(), std::move(columns));\n+    return true;\n+}\n+\n+bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::Table>>& batches, std::shared_ptr<arrow::Table>& result, const std::vector<std::string>& columnsOrder, const bool orderFieldsAreNecessary) {\n+    const auto builder = [](const std::shared_ptr<arrow::Schema>& schema, const ui32 recordsCount, std::vector<std::shared_ptr<arrow::ChunkedArray>>&& columns) {\n+        return arrow::Table::Make(schema, columns, recordsCount);\n+    };\n+\n+    return MergeBatchColumnsImpl<arrow::Table, arrow::ChunkedArray>(batches, result, columnsOrder, orderFieldsAreNecessary, builder);\n+}\n+\n+bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, std::shared_ptr<arrow::RecordBatch>& result, const std::vector<std::string>& columnsOrder, const bool orderFieldsAreNecessary) {\n+    const auto builder = [](const std::shared_ptr<arrow::Schema>& schema, const ui32 recordsCount, std::vector<std::shared_ptr<arrow::Array>>&& columns) {\n+        return arrow::RecordBatch::Make(schema, recordsCount, columns);\n+    };\n+\n+    return MergeBatchColumnsImpl<arrow::RecordBatch, arrow::Array>(batches, result, columnsOrder, orderFieldsAreNecessary, builder);\n+}\n+\n+std::partial_ordering ColumnsCompare(const std::vector<std::shared_ptr<arrow::Array>>& x, const ui32 xRow, const std::vector<std::shared_ptr<arrow::Array>>& y, const ui32 yRow) {\n+    return TRawReplaceKey(&x, xRow).CompareNotNull(TRawReplaceKey(&y, yRow));\n+}\n+\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> array, const ui32 position) {\n+    NJson::TJsonValue result = NJson::JSON_ARRAY;\n+    for (auto&& i : array->columns()) {\n+        result.AppendValue(DebugJson(i, position));\n+    }\n+    return result;\n+}\n+\n+TString DebugString(std::shared_ptr<arrow::Array> array, const ui32 position) {\n+    if (!array) {\n+        return \"_NO_DATA\";\n+    }\n+    Y_ABORT_UNLESS(position < array->length());\n+    TStringBuilder result;\n+    SwitchType(array->type_id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+\n+        auto& column = static_cast<const TArray&>(*array);\n+        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+            auto value = column.GetString(position);\n+            result << TString(value.data(), value.size());\n+        }\n+        if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n+            result << column.Value(position);\n+        }\n+        return true;\n+    });\n+    return result;\n+}\n+\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 position) {\n+    if (!array) {\n+        return NJson::JSON_NULL;\n+    }\n+    Y_ABORT_UNLESS(position < array->length());\n+    NJson::TJsonValue result = NJson::JSON_MAP;\n+    SwitchType(array->type_id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+\n+        auto& column = static_cast<const TArray&>(*array);\n+        result.InsertValue(\"type\", typeid(TArray).name());\n+        if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+            auto value = column.GetString(position);\n+            result.InsertValue(\"value\", TString(value.data(), value.size()));\n+        }\n+        if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n+            result.InsertValue(\"value\", column.Value(position));\n+        }\n+        return true;\n+    });\n+    return result;\n+}\n+\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 head, const ui32 tail) {\n+    if (!array) {\n+        return NJson::JSON_NULL;\n+    }\n+    NJson::TJsonValue resultFull = NJson::JSON_MAP;\n+    resultFull.InsertValue(\"length\", array->length());\n+    SwitchType(array->type_id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+\n+        auto& column = static_cast<const TArray&>(*array);\n+        resultFull.InsertValue(\"type\", typeid(TArray).name());\n+        resultFull.InsertValue(\"head\", head);\n+        resultFull.InsertValue(\"tail\", tail);\n+        auto& result = resultFull.InsertValue(\"data\", NJson::JSON_ARRAY);\n+        for (int i = 0; i < column.length(); ++i) {\n+            if (i >= (int)head && i + (int)tail < column.length()) {\n+                continue;\n+            }\n+            if constexpr (arrow::has_string_view<typename TWrap::T>()) {\n+                auto value = column.GetString(i);\n+                result.AppendValue(TString(value.data(), value.size()));\n+            }\n+            if constexpr (arrow::has_c_type<typename TWrap::T>()) {\n+                result.AppendValue(column.Value(i));\n+            }\n+        }\n+        return true;\n+        });\n+    return resultFull;\n+}\n+\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> batch, const ui32 head, const ui32 tail) {\n+    if (!batch) {\n+        return NJson::JSON_NULL;\n+    }\n+    NJson::TJsonValue result = NJson::JSON_ARRAY;\n+    ui32 idx = 0;\n+    for (auto&& i : batch->columns()) {\n+        auto& jsonColumn = result.AppendValue(NJson::JSON_MAP);\n+        jsonColumn.InsertValue(\"name\", batch->column_name(idx));\n+        jsonColumn.InsertValue(\"data\", DebugJson(i, head, tail));\n+        ++idx;\n+    }\n+    return result;\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> MergeColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches) {\n+    std::vector<std::shared_ptr<arrow::Array>> columns;\n+    std::vector<std::shared_ptr<arrow::Field>> fields;\n+    std::optional<ui32> recordsCount;\n+    std::set<std::string> columnNames;\n+    for (auto&& batch : batches) {\n+        if (!batch) {\n+            continue;\n+        }\n+        for (auto&& column : batch->columns()) {\n+            columns.emplace_back(column);\n+            if (!recordsCount) {\n+                recordsCount = column->length();\n+            } else {\n+                Y_ABORT_UNLESS(*recordsCount == column->length());\n+            }\n+        }\n+        for (auto&& field : batch->schema()->fields()) {\n+            AFL_VERIFY(columnNames.emplace(field->name()).second)(\"field_name\", field->name());\n+            fields.emplace_back(field);\n+        }\n+    }\n+    if (columns.empty()) {\n+        return nullptr;\n+    }\n+    auto schema = std::make_shared<arrow::Schema>(fields);\n+    return arrow::RecordBatch::Make(schema, *recordsCount, columns);\n+}\n+\n+std::vector<std::shared_ptr<arrow::RecordBatch>> SliceToRecordBatches(const std::shared_ptr<arrow::Table>& t) {\n+    if (!t->num_rows()) {\n+        return {};\n+    }\n+    std::vector<ui32> positions;\n+    {\n+        for (auto&& i : t->columns()) {\n+            ui32 pos = 0;\n+            for (auto&& arr : i->chunks()) {\n+                positions.emplace_back(pos);\n+                pos += arr->length();\n+            }\n+            AFL_VERIFY(pos == t->num_rows());\n+        }\n+        positions.emplace_back(t->num_rows());\n+    }\n+    std::sort(positions.begin(), positions.end());\n+    positions.erase(std::unique(positions.begin(), positions.end()), positions.end());\n+    AFL_VERIFY(positions.size() > 1)(\"size\", positions.size())(\"positions\", JoinSeq(\",\", positions));\n+    std::vector<std::vector<std::shared_ptr<arrow::Array>>> slicedData;\n+    slicedData.resize(positions.size() - 1);\n+    for (auto&& i : t->columns()) {\n+        ui32 currentPosition = 0;\n+        auto it = i->chunks().begin();\n+        ui32 length = 0;\n+        const auto initializeIt = [&length, &it, &i]() {\n+            for (; it != i->chunks().end() && !(*it)->length(); ++it) {\n+            }\n+            if (it != i->chunks().end()) {\n+                length = (*it)->length();\n+            }\n+        };\n+        initializeIt();\n+        for (ui32 idx = 0; idx + 1 < positions.size(); ++idx) {\n+            AFL_VERIFY(it != i->chunks().end());\n+            AFL_VERIFY(positions[idx + 1] - currentPosition <= length)(\"length\", length)(\"idx+1\", positions[idx + 1])(\"pos\", currentPosition);\n+            auto chunk = (*it)->Slice(positions[idx] - currentPosition, positions[idx + 1] - positions[idx]);\n+            AFL_VERIFY_DEBUG(chunk->length() == positions[idx + 1] - positions[idx])(\"length\", chunk->length())(\"expect\", positions[idx + 1] - positions[idx]);\n+            if (positions[idx + 1] - currentPosition == length) {\n+                ++it;\n+                initializeIt();\n+                currentPosition = positions[idx + 1];\n+            }\n+            slicedData[idx].emplace_back(chunk);\n+        }\n+    }\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> result;\n+    ui32 count = 0;\n+    for (auto&& i : slicedData) {\n+        AFL_VERIFY(i.size());\n+        AFL_VERIFY(i.front()->length());\n+        result.emplace_back(arrow::RecordBatch::Make(t->schema(), i.front()->length(), i));\n+        count += result.back()->num_rows();\n+    }\n+    AFL_VERIFY(count == t->num_rows())(\"count\", count)(\"t\", t->num_rows())(\"sd_size\", slicedData.size())(\"columns\", t->num_columns())(\n+                            \"schema\", t->schema()->ToString());\n+    return result;\n+}\n+\n+std::shared_ptr<arrow::Table> ToTable(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    if (!batch) {\n+        return nullptr;\n+    }\n+    return TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batch->schema(), {batch}));\n+}\n+\n+bool HasNulls(const std::shared_ptr<arrow::Array>& column) {\n+    AFL_VERIFY(column);\n+    return column->null_bitmap_data();\n+}\n+\n+std::vector<TString> ConvertStrings(const std::vector<std::string>& input) {\n+    std::vector<TString> result;\n+    for (auto&& i : input) {\n+        result.emplace_back(i);\n+    }\n+    return result;\n+}\n+\n+std::vector<std::string> ConvertStrings(const std::vector<TString>& input) {\n+    std::vector<std::string> result;\n+    for (auto&& i : input) {\n+        result.emplace_back(i);\n+    }\n+    return result;\n+}\n+\n+}\ndiff --git a/ydb/library/formats/arrow/arrow_helpers.h b/ydb/library/formats/arrow/arrow_helpers.h\nnew file mode 100644\nindex 000000000000..8bceee2d836e\n--- /dev/null\n+++ b/ydb/library/formats/arrow/arrow_helpers.h\n@@ -0,0 +1,101 @@\n+#pragma once\n+#include \"switch_type.h\"\n+#include <library/cpp/json/writer/json_value.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type_traits.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/ipc/writer.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/util/compression.h>\n+#include <ydb/library/accessor/accessor.h>\n+#include <map>\n+\n+namespace NKikimr::NArrow {\n+\n+using TArrayVec = std::vector<std::shared_ptr<arrow::Array>>;\n+\n+template <typename T>\n+inline bool ArrayEqualValue(const std::shared_ptr<arrow::Array>& x, const std::shared_ptr<arrow::Array>& y) {\n+    auto& arrX = static_cast<const T&>(*x);\n+    auto& arrY = static_cast<const T&>(*y);\n+    for (int i = 0; i < x->length(); ++i) {\n+        if (arrX.Value(i) != arrY.Value(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename T>\n+inline bool ArrayEqualView(const std::shared_ptr<arrow::Array>& x, const std::shared_ptr<arrow::Array>& y) {\n+    auto& arrX = static_cast<const T&>(*x);\n+    auto& arrY = static_cast<const T&>(*y);\n+    for (int i = 0; i < x->length(); ++i) {\n+        if (arrX.GetView(i) != arrY.GetView(i)) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+struct TSortDescription;\n+\n+TString SerializeSchema(const arrow::Schema& schema);\n+\n+std::shared_ptr<arrow::RecordBatch> MakeEmptyBatch(const std::shared_ptr<arrow::Schema>& schema, const ui32 rowsCount = 0);\n+std::shared_ptr<arrow::Table> ToTable(const std::shared_ptr<arrow::RecordBatch>& batch);\n+\n+std::shared_ptr<arrow::RecordBatch> ToBatch(const std::shared_ptr<arrow::Table>& combinedTable, const bool combine);\n+std::shared_ptr<arrow::RecordBatch> CombineBatches(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches);\n+std::shared_ptr<arrow::RecordBatch> MergeColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& rb);\n+std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<ui32>& sharding, ui32 numShards);\n+std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::vector<ui32>>& shardRows, const ui32 numShards);\n+THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows);\n+\n+std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::Field>& field);\n+std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(const std::shared_ptr<arrow::DataType>& type);\n+\n+std::vector<std::unique_ptr<arrow::ArrayBuilder>> MakeBuilders(const std::shared_ptr<arrow::Schema>& schema,\n+    size_t reserve = 0, const std::map<std::string, ui64>& sizeByColumn = {});\n+std::vector<std::shared_ptr<arrow::Array>> Finish(std::vector<std::unique_ptr<arrow::ArrayBuilder>>&& builders);\n+\n+std::shared_ptr<arrow::UInt64Array> MakeUI64Array(ui64 value, i64 size);\n+std::vector<TString> ColumnNames(const std::shared_ptr<arrow::Schema>& schema);\n+bool ReserveData(arrow::ArrayBuilder& builder, const size_t size);\n+bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, std::shared_ptr<arrow::RecordBatch>& result, const std::vector<std::string>& columnsOrder = {}, const bool orderFieldsAreNecessary = true);\n+bool MergeBatchColumns(const std::vector<std::shared_ptr<arrow::Table>>& batches, std::shared_ptr<arrow::Table>& result, const std::vector<std::string>& columnsOrder = {}, const bool orderFieldsAreNecessary = true);\n+\n+bool HasAllColumns(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& schema);\n+\n+std::pair<int, int> FindMinMaxPosition(const std::shared_ptr<arrow::Array>& column);\n+\n+std::shared_ptr<arrow::Scalar> DefaultScalar(const std::shared_ptr<arrow::DataType>& type);\n+std::shared_ptr<arrow::Scalar> MinScalar(const std::shared_ptr<arrow::DataType>& type);\n+std::shared_ptr<arrow::Scalar> GetScalar(const std::shared_ptr<arrow::Array>& array, int position);\n+bool IsGoodScalar(const std::shared_ptr<arrow::Scalar>& x);\n+int ScalarCompare(const arrow::Scalar& x, const arrow::Scalar& y);\n+int ScalarCompare(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y);\n+int ScalarCompareNullable(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y);\n+std::partial_ordering ColumnsCompare(\n+    const std::vector<std::shared_ptr<arrow::Array>>& x, const ui32 xRow, const std::vector<std::shared_ptr<arrow::Array>>& y, const ui32 yRow);\n+bool ColumnEqualsScalar(\n+    const std::shared_ptr<arrow::Array>& c, const ui32 position, const std::shared_ptr<arrow::Scalar>& s);\n+bool ScalarLess(const std::shared_ptr<arrow::Scalar>& x, const std::shared_ptr<arrow::Scalar>& y);\n+bool ScalarLess(const arrow::Scalar& x, const arrow::Scalar& y);\n+\n+bool HasNulls(const std::shared_ptr<arrow::Array>& column);\n+\n+std::vector<std::shared_ptr<arrow::RecordBatch>> SliceToRecordBatches(const std::shared_ptr<arrow::Table>& t);\n+\n+bool ArrayScalarsEqual(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs);\n+std::shared_ptr<arrow::Array> BoolVecToArray(const std::vector<bool>& vec);\n+\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 head, const ui32 tail);\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> batch, const ui32 head, const ui32 tail);\n+\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::Array> array, const ui32 position);\n+TString DebugString(std::shared_ptr<arrow::Array> array, const ui32 position);\n+NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> array, const ui32 position);\n+\n+std::shared_ptr<arrow::RecordBatch> Reorder(const std::shared_ptr<arrow::RecordBatch>& batch,\n+                                            const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove);\n+\n+}\ndiff --git a/ydb/library/formats/arrow/common/validation.h b/ydb/library/formats/arrow/common/validation.h\nnew file mode 100644\nindex 000000000000..171b50041db4\n--- /dev/null\n+++ b/ydb/library/formats/arrow/common/validation.h\n@@ -0,0 +1,3 @@\n+#pragma once\n+\n+#include <ydb/library/formats/arrow/validation/validation.h>\ndiff --git a/ydb/library/formats/arrow/common/vector_operations.h b/ydb/library/formats/arrow/common/vector_operations.h\nnew file mode 100644\nindex 000000000000..99642b8eeb7f\n--- /dev/null\n+++ b/ydb/library/formats/arrow/common/vector_operations.h\n@@ -0,0 +1,54 @@\n+#pragma once\n+\n+#include <ydb/library/actors/core/log.h>\n+\n+#include <util/system/types.h>\n+\n+#include <vector>\n+\n+namespace NKikimr::NArrow::NUtil {\n+\n+template <typename T>\n+class TDefaultErasePolicy {\n+public:\n+    void OnEraseItem(const T& /*item*/) const {\n+    }\n+    void OnMoveItem(const T& /*item*/, const ui64 /*new_index*/) const {\n+    }\n+};\n+\n+template <typename T, typename ErasePolicy = TDefaultErasePolicy<T>>\n+void EraseItems(std::vector<T>& container, const std::vector<ui32>& idxsToErase, const ErasePolicy& policy = TDefaultErasePolicy<T>()) {\n+    if (idxsToErase.empty()) {\n+        return;\n+    }\n+    AFL_VERIFY(idxsToErase.front() < container.size());\n+\n+    auto itNextEraseIdx = idxsToErase.begin();\n+    ui64 writeIdx = idxsToErase.front();\n+    ui64 readIdx = idxsToErase.front();\n+    while (readIdx != container.size()) {\n+        AFL_VERIFY(itNextEraseIdx != idxsToErase.end() && readIdx == *itNextEraseIdx);\n+\n+        policy.OnEraseItem(container[readIdx]);\n+        ++readIdx;\n+        ++itNextEraseIdx;\n+        if (itNextEraseIdx != idxsToErase.end()) {\n+            AFL_VERIFY(*itNextEraseIdx > *std::prev(itNextEraseIdx));\n+            AFL_VERIFY(*itNextEraseIdx < container.size());\n+        }\n+\n+        const ui64 nextReadIdx = itNextEraseIdx == idxsToErase.end() ? container.size() : *itNextEraseIdx;\n+        while (readIdx != nextReadIdx) {\n+            std::swap(container[writeIdx], container[readIdx]);\n+            policy.OnMoveItem(container[writeIdx], writeIdx);\n+            ++writeIdx;\n+            ++readIdx;\n+        }\n+    }\n+\n+    container.resize(writeIdx);\n+    AFL_VERIFY(itNextEraseIdx == idxsToErase.end());\n+}\n+\n+}   // namespace NKikimr::NArrow::NUtil\ndiff --git a/ydb/library/formats/arrow/common/ya.make b/ydb/library/formats/arrow/common/ya.make\nnew file mode 100644\nindex 000000000000..d2fa92cfc9f2\n--- /dev/null\n+++ b/ydb/library/formats/arrow/common/ya.make\n@@ -0,0 +1,12 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/formats/arrow/switch\n+    ydb/library/actors/core\n+    ydb/library/conclusion\n+    ydb/library/formats/arrow/splitter\n+    ydb/library/formats/arrow/validation\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/hash/xx_hash.cpp b/ydb/library/formats/arrow/hash/xx_hash.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/hash/xx_hash.cpp\nrename to ydb/library/formats/arrow/hash/xx_hash.cpp\ndiff --git a/ydb/core/formats/arrow/hash/xx_hash.h b/ydb/library/formats/arrow/hash/xx_hash.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/hash/xx_hash.h\nrename to ydb/library/formats/arrow/hash/xx_hash.h\ndiff --git a/ydb/library/formats/arrow/hash/ya.make b/ydb/library/formats/arrow/hash/ya.make\nnew file mode 100644\nindex 000000000000..f9a20aba9be8\n--- /dev/null\n+++ b/ydb/library/formats/arrow/hash/ya.make\n@@ -0,0 +1,17 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/formats/arrow/simple_builder\n+    ydb/library/formats/arrow/switch\n+    ydb/library/actors/core\n+    ydb/library/services\n+    ydb/library/actors/protos\n+)\n+\n+SRCS(\n+    xx_hash.cpp\n+)\n+\n+END()\n+\ndiff --git a/ydb/core/formats/arrow/input_stream.h b/ydb/library/formats/arrow/input_stream.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/input_stream.h\nrename to ydb/library/formats/arrow/input_stream.h\ndiff --git a/ydb/core/formats/arrow/modifier/schema.cpp b/ydb/library/formats/arrow/modifier/schema.cpp\nsimilarity index 88%\nrename from ydb/core/formats/arrow/modifier/schema.cpp\nrename to ydb/library/formats/arrow/modifier/schema.cpp\nindex 4cf792614802..87b7de842c2c 100644\n--- a/ydb/core/formats/arrow/modifier/schema.cpp\n+++ b/ydb/library/formats/arrow/modifier/schema.cpp\n@@ -1,5 +1,6 @@\n #include \"schema.h\"\n #include <util/string/builder.h>\n+#include <ydb/library/formats/arrow/common/vector_operations.h>\n #include <ydb/library/actors/core/log.h>\n \n namespace NKikimr::NArrow::NModifier {\n@@ -29,6 +30,12 @@ TConclusionStatus TSchema::AddField(const std::shared_ptr<arrow::Field>& f) {\n     return TConclusionStatus::Success();\n }\n \n+void TSchema::DeleteFieldsByIndex(const std::vector<ui32>& idxs) {\n+    AFL_VERIFY(Initialized);\n+    AFL_VERIFY(!Finished);\n+    NUtil::EraseItems(Fields, idxs, TFieldsErasePolicy(this));\n+}\n+\n TString TSchema::ToString() const {\n     TStringBuilder result;\n     for (auto&& i : Fields) {\ndiff --git a/ydb/library/formats/arrow/modifier/schema.h b/ydb/library/formats/arrow/modifier/schema.h\nnew file mode 100644\nindex 000000000000..1d90167c0979\n--- /dev/null\n+++ b/ydb/library/formats/arrow/modifier/schema.h\n@@ -0,0 +1,165 @@\n+#pragma once\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/actors/core/log.h>\n+#include <ydb/library/conclusion/status.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <util/generic/hash.h>\n+\n+namespace NKikimr::NArrow {\n+\n+class TSchemaLite {\n+private:\n+    YDB_READONLY_DEF(std::vector<std::shared_ptr<arrow::Field>>, Fields);\n+\n+public:\n+    TSchemaLite() = default;\n+    TSchemaLite(const std::shared_ptr<arrow::Schema>& schema) {\n+        AFL_VERIFY(schema);\n+        Fields = schema->fields();\n+    }\n+\n+    const std::shared_ptr<arrow::Field>& field(const ui32 index) const {\n+        return GetFieldByIndexVerified(index);\n+    }\n+\n+    bool Equals(const TSchemaLite& schema, const bool withMetadata = false) const {\n+        if (Fields.size() != schema.Fields.size()) {\n+            return false;\n+        }\n+        for (ui32 i = 0; i < Fields.size(); ++i) {\n+            if (!Fields[i]->Equals(schema.Fields[i], withMetadata)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    const std::vector<std::shared_ptr<arrow::Field>>& fields() const {\n+        return Fields;\n+    }\n+\n+    int num_fields() const {\n+        return Fields.size();\n+    }\n+\n+    std::vector<std::string> field_names() const {\n+        std::vector<std::string> result;\n+        result.reserve(Fields.size());\n+        for (auto&& f : Fields) {\n+            result.emplace_back(f->name());\n+        }\n+        return result;\n+    }\n+\n+    TString DebugString() const {\n+        TStringBuilder sb;\n+        sb << \"[\";\n+        for (auto&& f : Fields) {\n+            sb << f->ToString() << \";\";\n+        }\n+        sb << \"]\";\n+\n+        return sb;\n+    }\n+\n+    TString ToString() const {\n+        return DebugString();\n+    }\n+\n+    const std::shared_ptr<arrow::Field>& GetFieldByIndexVerified(const ui32 index) const {\n+        AFL_VERIFY(index < Fields.size());\n+        return Fields[index];\n+    }\n+\n+    const std::shared_ptr<arrow::Field>& GetFieldByIndexOptional(const ui32 index) const {\n+        if (index < Fields.size()) {\n+            return Fields[index];\n+        }\n+        return Default<std::shared_ptr<arrow::Field>>();\n+    }\n+\n+    TSchemaLite(std::vector<std::shared_ptr<arrow::Field>>&& fields)\n+        : Fields(std::move(fields)) {\n+    }\n+\n+    TSchemaLite(const std::vector<std::shared_ptr<arrow::Field>>& fields)\n+        : Fields(fields) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow\n+\n+namespace NKikimr::NArrow::NModifier {\n+class TSchema {\n+private:\n+    bool Initialized = false;\n+    THashMap<std::string, ui32> IndexByName;\n+    std::vector<std::shared_ptr<arrow::Field>> Fields;\n+    bool Finished = false;\n+\n+    void Initialize(const std::vector<std::shared_ptr<arrow::Field>>& fields);\n+\n+public:\n+    TSchema() = default;\n+    TSchema(const std::shared_ptr<TSchema>& schema);\n+\n+    TSchema(const std::shared_ptr<arrow::Schema>& schema);\n+\n+    TSchema(const std::vector<std::shared_ptr<arrow::Field>>& fields) {\n+        Initialize(fields);\n+    }\n+\n+    i32 GetFieldIndex(const std::string& fName) const {\n+        auto it = IndexByName.find(fName);\n+        if (it == IndexByName.end()) {\n+            return -1;\n+        }\n+        return it->second;\n+    }\n+\n+    const std::vector<std::shared_ptr<arrow::Field>>& GetFields() const {\n+        return Fields;\n+    }\n+\n+    TString ToString() const;\n+\n+    std::shared_ptr<arrow::Schema> Finish();\n+    [[nodiscard]] TConclusionStatus AddField(const std::shared_ptr<arrow::Field>& f);\n+    const std::shared_ptr<arrow::Field>& GetFieldByName(const std::string& name) const;\n+    void DeleteFieldsByIndex(const std::vector<ui32>& idxs);\n+\n+    bool HasField(const std::string& name) const {\n+        return IndexByName.contains(name);\n+    }\n+\n+    i32 num_fields() const {\n+        return Fields.size();\n+    }\n+\n+    const std::shared_ptr<arrow::Field>& GetFieldVerified(const ui32 index) const;\n+\n+    const std::shared_ptr<arrow::Field>& field(const ui32 index) const;\n+\n+private:\n+    class TFieldsErasePolicy {\n+    private:\n+        TSchema* const Owner;\n+\n+    public:\n+        TFieldsErasePolicy(TSchema* const owner)\n+            : Owner(owner) {\n+        }\n+\n+        void OnEraseItem(const std::shared_ptr<arrow::Field>& item) const {\n+            Owner->IndexByName.erase(item->name());\n+        }\n+\n+        void OnMoveItem(const std::shared_ptr<arrow::Field>& item, const ui64 new_index) const {\n+            auto* findField = Owner->IndexByName.FindPtr(item->name());\n+            AFL_VERIFY(findField);\n+            *findField = new_index;\n+        }\n+    };\n+};\n+}   // namespace NKikimr::NArrow::NModifier\ndiff --git a/ydb/core/formats/arrow/modifier/subset.cpp b/ydb/library/formats/arrow/modifier/subset.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/modifier/subset.cpp\nrename to ydb/library/formats/arrow/modifier/subset.cpp\ndiff --git a/ydb/core/formats/arrow/modifier/subset.h b/ydb/library/formats/arrow/modifier/subset.h\nsimilarity index 96%\nrename from ydb/core/formats/arrow/modifier/subset.h\nrename to ydb/library/formats/arrow/modifier/subset.h\nindex fc15d44e4fb8..23430af5524f 100644\n--- a/ydb/core/formats/arrow/modifier/subset.h\n+++ b/ydb/library/formats/arrow/modifier/subset.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/formats/arrow/protos/fields.pb.h>\n+#include <ydb/library/formats/arrow/protos/fields.pb.h>\n #include <ydb/library/conclusion/result.h>\n #include <ydb/library/actors/core/log.h>\n \ndiff --git a/ydb/core/formats/arrow/modifier/ya.make b/ydb/library/formats/arrow/modifier/ya.make\nsimilarity index 67%\nrename from ydb/core/formats/arrow/modifier/ya.make\nrename to ydb/library/formats/arrow/modifier/ya.make\nindex 4b2b53f5513a..4a509475a173 100644\n--- a/ydb/core/formats/arrow/modifier/ya.make\n+++ b/ydb/library/formats/arrow/modifier/ya.make\n@@ -3,8 +3,8 @@ LIBRARY()\n PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/library/conclusion\n-    ydb/core/formats/arrow/switch\n-    ydb/core/formats/arrow/protos\n+    ydb/library/formats/arrow/switch\n+    ydb/library/formats/arrow/protos\n     ydb/library/actors/core\n )\n \ndiff --git a/ydb/library/formats/arrow/permutations.cpp b/ydb/library/formats/arrow/permutations.cpp\nnew file mode 100644\nindex 000000000000..8eb270c2a424\n--- /dev/null\n+++ b/ydb/library/formats/arrow/permutations.cpp\n@@ -0,0 +1,214 @@\n+#include \"permutations.h\"\n+\n+#include \"arrow_helpers.h\"\n+#include \"replace_key.h\"\n+#include \"size_calcer.h\"\n+\n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <ydb/library/services/services.pb.h>\n+\n+#include <ydb/library/actors/core/log.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_primitive.h>\n+#include <contrib/libs/xxhash/xxhash.h>\n+\n+namespace NKikimr::NArrow {\n+\n+std::shared_ptr<arrow::UInt64Array> MakePermutation(const int size, const bool reverse) {\n+    arrow::UInt64Builder builder;\n+    TStatusValidator::Validate(builder.Reserve(size));\n+\n+    if (size) {\n+        if (reverse) {\n+            ui64 value = size - 1;\n+            for (i64 i = 0; i < size; ++i, --value) {\n+                TStatusValidator::Validate(builder.Append(value));\n+            }\n+        } else {\n+            for (i64 i = 0; i < size; ++i) {\n+                TStatusValidator::Validate(builder.Append(i));\n+            }\n+        }\n+    }\n+\n+    std::shared_ptr<arrow::UInt64Array> out;\n+    TStatusValidator::Validate(builder.Finish(&out));\n+    return out;\n+}\n+\n+template <class TIndex>\n+std::shared_ptr<arrow::UInt64Array> MakeFilterPermutationImpl(const std::vector<TIndex>& indexes) {\n+    if (indexes.empty()) {\n+        return {};\n+    }\n+\n+    arrow::UInt64Builder builder;\n+    if (!builder.Reserve(indexes.size()).ok()) {\n+        return {};\n+    }\n+\n+    for (auto&& i : indexes) {\n+        TStatusValidator::Validate(builder.Append(i));\n+    }\n+    std::shared_ptr<arrow::UInt64Array> out;\n+    TStatusValidator::Validate(builder.Finish(&out));\n+    return out;\n+}\n+\n+std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui32>& indexes) {\n+    return MakeFilterPermutationImpl(indexes);\n+}\n+\n+std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui64>& indexes) {\n+    return MakeFilterPermutationImpl(indexes);\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> CopyRecords(const std::shared_ptr<arrow::RecordBatch>& source, const std::vector<ui64>& indexes) {\n+    Y_ABORT_UNLESS(!!source);\n+    auto schema = source->schema();\n+    std::vector<std::shared_ptr<arrow::Array>> columns;\n+    for (auto&& i : source->columns()) {\n+        columns.emplace_back(CopyRecords(i, indexes));\n+    }\n+    return arrow::RecordBatch::Make(schema, indexes.size(), columns);\n+}\n+\n+std::shared_ptr<arrow::Array> CopyRecords(const std::shared_ptr<arrow::Array>& source, const std::vector<ui64>& indexes) {\n+    if (!source) {\n+        return source;\n+    }\n+    std::shared_ptr<arrow::Array> result;\n+    SwitchType(source->type_id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+        using TBuilder = typename arrow::TypeTraits<typename TWrap::T>::BuilderType;\n+        auto& column = static_cast<const TArray&>(*source);\n+\n+        std::unique_ptr<arrow::ArrayBuilder> builder;\n+        TStatusValidator::Validate(arrow::MakeBuilder(arrow::default_memory_pool(), source->type(), &builder));\n+        auto& builderImpl = static_cast<TBuilder&>(*builder);\n+\n+        if constexpr (arrow::has_string_view<typename TWrap::T>::value) {\n+            ui64 sumByIndexes = 0;\n+            for (auto&& idx : indexes) {\n+                Y_ABORT_UNLESS(idx < (ui64)column.length());\n+                sumByIndexes += column.GetView(idx).size();\n+            }\n+            TStatusValidator::Validate(builderImpl.ReserveData(sumByIndexes));\n+        }\n+\n+        TStatusValidator::Validate(builder->Reserve(indexes.size()));\n+\n+        {\n+            const ui32 arraySize = column.length();\n+            for (auto&& i : indexes) {\n+                Y_ABORT_UNLESS(i < arraySize);\n+                builderImpl.UnsafeAppend(column.GetView(i));\n+            }\n+        }\n+\n+        TStatusValidator::Validate(builder->Finish(&result));\n+        return true;\n+    });\n+    Y_ABORT_UNLESS(result);\n+    return result;\n+}\n+\n+ui64 TShardedRecordBatch::GetMemorySize() const {\n+    return NArrow::GetTableMemorySize(RecordBatch);\n+}\n+\n+TShardedRecordBatch::TShardedRecordBatch(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    AFL_VERIFY(batch);\n+    RecordBatch = TStatusValidator::GetValid(arrow::Table::FromRecordBatches(batch->schema(), {batch}));\n+}\n+\n+\n+TShardedRecordBatch::TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch)\n+    : RecordBatch(batch)\n+{\n+    AFL_VERIFY(RecordBatch);\n+}\n+\n+TShardedRecordBatch::TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch, std::vector<std::vector<ui32>>&& splittedByShards)\n+    : RecordBatch(batch)\n+    , SplittedByShards(std::move(splittedByShards))\n+{\n+    AFL_VERIFY(RecordBatch);\n+    AFL_VERIFY(SplittedByShards.size());\n+}\n+\n+std::vector<std::shared_ptr<arrow::Table>> TShardingSplitIndex::Apply(const std::shared_ptr<arrow::Table>& input) {\n+    AFL_VERIFY(input);\n+    AFL_VERIFY(input->num_rows() == RecordsCount);\n+    auto permutation = BuildPermutation();\n+    auto resultBatch = NArrow::TStatusValidator::GetValid(arrow::compute::Take(input, *permutation)).table();\n+    AFL_VERIFY(resultBatch->num_rows() == RecordsCount);\n+    std::vector<std::shared_ptr<arrow::Table>> result;\n+    ui64 startIndex = 0;\n+    for (auto&& i : Remapping) {\n+        result.emplace_back(resultBatch->Slice(startIndex, i.size()));\n+        startIndex += i.size();\n+    }\n+    AFL_VERIFY(startIndex == RecordsCount);\n+    return result;\n+}\n+\n+NKikimr::NArrow::TShardedRecordBatch TShardingSplitIndex::Apply(const ui32 shardsCount, const std::shared_ptr<arrow::Table>& input, const std::string& hashColumnName) {\n+    AFL_VERIFY(input);\n+    if (shardsCount == 1) {\n+        return TShardedRecordBatch(input);\n+    }\n+    auto hashColumn = input->GetColumnByName(hashColumnName);\n+    if (!hashColumn) {\n+        return TShardedRecordBatch(input);\n+    }\n+    std::optional<TShardingSplitIndex> splitter;\n+    if (hashColumn->type()->id() == arrow::Type::UINT64) {\n+        splitter = TShardingSplitIndex::Build<arrow::UInt64Array>(shardsCount, *hashColumn);\n+    } else if (hashColumn->type()->id() == arrow::Type::UINT32) {\n+        splitter = TShardingSplitIndex::Build<arrow::UInt32Array>(shardsCount, *hashColumn);\n+    } else if (hashColumn->type()->id() == arrow::Type::INT64) {\n+        splitter = TShardingSplitIndex::Build<arrow::Int64Array>(shardsCount, *hashColumn);\n+    } else if (hashColumn->type()->id() == arrow::Type::INT32) {\n+        splitter = TShardingSplitIndex::Build<arrow::Int32Array>(shardsCount, *hashColumn);\n+    } else {\n+        Y_ABORT_UNLESS(false);\n+    }\n+    auto resultBatch = NArrow::TStatusValidator::GetValid(input->RemoveColumn(input->schema()->GetFieldIndex(hashColumnName)));\n+    return TShardedRecordBatch(resultBatch, splitter->DetachRemapping());\n+}\n+\n+TShardedRecordBatch TShardingSplitIndex::Apply(const ui32 shardsCount, const std::shared_ptr<arrow::RecordBatch>& input, const std::string& hashColumnName) {\n+    return Apply(shardsCount, TStatusValidator::GetValid(arrow::Table::FromRecordBatches(input->schema(), {input}))\n+        , hashColumnName);\n+}\n+\n+std::shared_ptr<arrow::UInt64Array> TShardingSplitIndex::BuildPermutation() const {\n+    arrow::UInt64Builder builder;\n+    Y_ABORT_UNLESS(builder.Reserve(RecordsCount).ok());\n+\n+    for (auto&& i : Remapping) {\n+        for (auto&& idx : i) {\n+            TStatusValidator::Validate(builder.Append(idx));\n+        }\n+    }\n+\n+    std::shared_ptr<arrow::UInt64Array> out;\n+    Y_ABORT_UNLESS(builder.Finish(&out).ok());\n+    return out;\n+}\n+\n+std::shared_ptr<arrow::RecordBatch> ReverseRecords(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    AFL_VERIFY(batch);\n+    auto permutation = NArrow::MakePermutation(batch->num_rows(), true);\n+    return NArrow::TStatusValidator::GetValid(arrow::compute::Take(batch, permutation)).record_batch();\n+}\n+\n+std::shared_ptr<arrow::Table> ReverseRecords(const std::shared_ptr<arrow::Table>& batch) {\n+    AFL_VERIFY(batch);\n+    auto permutation = NArrow::MakePermutation(batch->num_rows(), true);\n+    return NArrow::TStatusValidator::GetValid(arrow::compute::Take(batch, permutation)).table();\n+}\n+\n+}\ndiff --git a/ydb/library/formats/arrow/permutations.h b/ydb/library/formats/arrow/permutations.h\nnew file mode 100644\nindex 000000000000..48dca1fa427d\n--- /dev/null\n+++ b/ydb/library/formats/arrow/permutations.h\n@@ -0,0 +1,149 @@\n+#pragma once\n+#include \"arrow_helpers.h\"\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <util/system/types.h>\n+\n+namespace NKikimr::NArrow {\n+\n+class TShardedRecordBatch {\n+private:\n+    YDB_READONLY_DEF(std::shared_ptr<arrow::Table>, RecordBatch);\n+    YDB_READONLY_DEF(std::vector<std::vector<ui32>>, SplittedByShards);\n+public:\n+    TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch);\n+    TShardedRecordBatch(const std::shared_ptr<arrow::RecordBatch>& batch);\n+\n+    void Cut(const ui32 limit) {\n+        RecordBatch = RecordBatch->Slice(0, limit);\n+        for (auto&& i : SplittedByShards) {\n+            auto it = std::lower_bound(i.begin(), i.end(), limit);\n+            if (it != i.end()) {\n+                i.erase(it, i.end());\n+            }\n+        }\n+    }\n+\n+    bool IsSharded() const {\n+        return SplittedByShards.size() > 1;\n+    }\n+\n+    TShardedRecordBatch(const std::shared_ptr<arrow::Table>& batch, std::vector<std::vector<ui32>>&& splittedByShards);\n+\n+    ui64 GetMemorySize() const;\n+\n+    ui64 GetRecordsCount() const {\n+        return RecordBatch->num_rows();\n+    }\n+};\n+\n+class TShardingSplitIndex {\n+private:\n+    ui32 ShardsCount = 0;\n+    std::vector<std::vector<ui32>> Remapping;\n+    ui32 RecordsCount = 0;\n+\n+    template <class TIterator>\n+    std::vector<ui32> MergeLists(const std::vector<ui32>& base, const TIterator itFrom, const TIterator itTo) {\n+        std::vector<ui32> result;\n+        result.reserve(base.size() + (itTo - itFrom));\n+        auto itBase = base.begin();\n+        auto itExt = itFrom;\n+        while (itBase != base.end() && itExt != itTo) {\n+            if (*itBase < *itExt) {\n+                result.emplace_back(*itBase);\n+                ++itBase;\n+            } else {\n+                result.emplace_back(*itExt);\n+                ++itExt;\n+            }\n+        }\n+        if (itBase == base.end()) {\n+            result.insert(result.end(), itExt, itTo);\n+        } else if (itExt == itTo) {\n+            result.insert(result.end(), itBase, base.end());\n+        }\n+        return result;\n+    }\n+\n+    template <class TIntArrowArray>\n+    void Initialize(const arrow::ChunkedArray& arrowHashArrayChunked) {\n+        Y_ABORT_UNLESS(ShardsCount);\n+        Remapping.resize(ShardsCount);\n+        const ui32 expectation = arrowHashArrayChunked.length() / ShardsCount + 1;\n+        for (auto&& i : Remapping) {\n+            i.reserve(2 * expectation);\n+        }\n+        for (auto&& arrowHashArrayAbstract : arrowHashArrayChunked.chunks()) {\n+            auto& arrowHashArray = static_cast<const TIntArrowArray&>(*arrowHashArrayAbstract);\n+            ui64 offset = 0;\n+            for (ui64 i = 0; i < (ui64)arrowHashArray.length(); ++i) {\n+                const i64 v = arrowHashArray.GetView(i);\n+                const ui32 idx = ((v < 0) ? (-v) : v) % ShardsCount;\n+                Remapping[idx].emplace_back(offset + i);\n+            }\n+            offset += (ui64)arrowHashArray.length();\n+        }\n+        std::deque<std::vector<ui32>*> sizeCorrection;\n+        for (auto&& i : Remapping) {\n+            sizeCorrection.emplace_back(&i);\n+        }\n+        const auto pred = [](const std::vector<ui32>* l, const std::vector<ui32>* r) {\n+            return l->size() < r->size();\n+        };\n+        std::sort(sizeCorrection.begin(), sizeCorrection.end(), pred);\n+        while (sizeCorrection.size() > 1 && sizeCorrection.back()->size() > expectation && sizeCorrection.front()->size() < expectation) {\n+            const ui32 uselessRecords = sizeCorrection.back()->size() - expectation;\n+            const ui32 needRecords = expectation - sizeCorrection.front()->size();\n+            const ui32 moveRecords = std::min<ui32>(needRecords, uselessRecords);\n+            if (moveRecords == 0) {\n+                break;\n+            }\n+            *sizeCorrection.front() = MergeLists(*sizeCorrection.front(), sizeCorrection.back()->end() - moveRecords, sizeCorrection.back()->end());\n+            sizeCorrection.back()->resize(sizeCorrection.back()->size() - moveRecords);\n+            if (sizeCorrection.back()->size() <= expectation) {\n+                sizeCorrection.pop_back();\n+            }\n+            if (sizeCorrection.front()->size() >= expectation) {\n+                sizeCorrection.pop_front();\n+            }\n+        }\n+    }\n+\n+    TShardingSplitIndex(const ui32 shardsCount, const arrow::ChunkedArray& arrowHashArray)\n+        : ShardsCount(shardsCount)\n+        , RecordsCount(arrowHashArray.length()) {\n+    }\n+\n+public:\n+\n+    std::vector<std::vector<ui32>> DetachRemapping() {\n+        return std::move(Remapping);\n+    }\n+\n+    template <class TArrayClass>\n+    static TShardingSplitIndex Build(const ui32 shardsCount, const arrow::ChunkedArray& arrowHashArray) {\n+        TShardingSplitIndex result(shardsCount, arrowHashArray);\n+        result.Initialize<TArrayClass>(arrowHashArray);\n+        return result;\n+    }\n+\n+    std::shared_ptr<arrow::UInt64Array> BuildPermutation() const;\n+\n+    std::vector<std::shared_ptr<arrow::Table>> Apply(const std::shared_ptr<arrow::Table>& input);\n+    static TShardedRecordBatch Apply(const ui32 shardsCount, const std::shared_ptr<arrow::Table>& input, const std::string& hashColumnName);\n+    static TShardedRecordBatch Apply(const ui32 shardsCount, const std::shared_ptr<arrow::RecordBatch>& input, const std::string& hashColumnName);\n+};\n+\n+std::shared_ptr<arrow::UInt64Array> MakePermutation(const int size, const bool reverse = false);\n+std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui64>& indexes);\n+std::shared_ptr<arrow::UInt64Array> MakeFilterPermutation(const std::vector<ui32>& indexes);\n+std::shared_ptr<arrow::RecordBatch> ReverseRecords(const std::shared_ptr<arrow::RecordBatch>& batch);\n+std::shared_ptr<arrow::Table> ReverseRecords(const std::shared_ptr<arrow::Table>& batch);\n+\n+std::shared_ptr<arrow::Array> CopyRecords(const std::shared_ptr<arrow::Array>& source, const std::vector<ui64>& indexes);\n+std::shared_ptr<arrow::RecordBatch> CopyRecords(const std::shared_ptr<arrow::RecordBatch>& source, const std::vector<ui64>& indexes);\n+\n+}\ndiff --git a/ydb/library/formats/arrow/protos/accessor.proto b/ydb/library/formats/arrow/protos/accessor.proto\nnew file mode 100644\nindex 000000000000..015ea0b7cf89\n--- /dev/null\n+++ b/ydb/library/formats/arrow/protos/accessor.proto\n@@ -0,0 +1,30 @@\n+package NKikimrArrowAccessorProto;\n+\n+message TRequestedConstructor {\n+    optional string ClassName = 1;\n+\n+    message TPlain {\n+    }\n+\n+    message TSparsed {\n+    }\n+\n+    oneof Implementation {\n+        TPlain Plain = 10;\n+        TSparsed Sparsed = 11;\n+    }\n+}\n+\n+message TConstructor {\n+    optional string ClassName = 1;\n+\n+    message TPlain {\n+    }\n+\n+    message TSparsed {\n+    }\n+    oneof Implementation {\n+        TPlain Plain = 10;\n+        TSparsed Sparsed = 11;\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/ydb/core/formats/arrow/protos/fields.proto b/ydb/library/formats/arrow/protos/fields.proto\nsimilarity index 100%\nrename from ydb/core/formats/arrow/protos/fields.proto\nrename to ydb/library/formats/arrow/protos/fields.proto\ndiff --git a/ydb/core/formats/arrow/protos/ssa.proto b/ydb/library/formats/arrow/protos/ssa.proto\nsimilarity index 100%\nrename from ydb/core/formats/arrow/protos/ssa.proto\nrename to ydb/library/formats/arrow/protos/ssa.proto\ndiff --git a/ydb/core/formats/arrow/protos/ya.make b/ydb/library/formats/arrow/protos/ya.make\nsimilarity index 80%\nrename from ydb/core/formats/arrow/protos/ya.make\nrename to ydb/library/formats/arrow/protos/ya.make\nindex 828b0aa0fb77..6fbf466a1771 100644\n--- a/ydb/core/formats/arrow/protos/ya.make\n+++ b/ydb/library/formats/arrow/protos/ya.make\n@@ -3,6 +3,7 @@ PROTO_LIBRARY()\n SRCS(\n     ssa.proto\n     fields.proto\n+    accessor.proto\n )\n \n PEERDIR(\ndiff --git a/ydb/core/formats/arrow/replace_key.cpp b/ydb/library/formats/arrow/replace_key.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/replace_key.cpp\nrename to ydb/library/formats/arrow/replace_key.cpp\ndiff --git a/ydb/core/formats/arrow/replace_key.h b/ydb/library/formats/arrow/replace_key.h\nsimilarity index 88%\nrename from ydb/core/formats/arrow/replace_key.h\nrename to ydb/library/formats/arrow/replace_key.h\nindex 8fb54a18dddd..20db01a98b9c 100644\n--- a/ydb/core/formats/arrow/replace_key.h\n+++ b/ydb/library/formats/arrow/replace_key.h\n@@ -5,8 +5,6 @@\n #include \"common/validation.h\"\n #include \"switch/compare.h\"\n \n-#include <ydb/core/base/defs.h>\n-\n #include <ydb/library/actors/core/log.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>\n@@ -278,5 +276,36 @@ class TReplaceKeyHelper {\n     static size_t LowerBound(const std::vector<TRawReplaceKey>& batchKeys, const TReplaceKey& key, size_t offset);\n };\n \n+template <bool desc, bool uniq>\n+static bool IsSelfSorted(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    if (batch->num_rows() < 2) {\n+        return true;\n+    }\n+    auto& columns = batch->columns();\n+\n+    for (int i = 1; i < batch->num_rows(); ++i) {\n+        TRawReplaceKey prev(&columns, i - 1);\n+        TRawReplaceKey current(&columns, i);\n+        if constexpr (desc) {\n+            if (prev < current) {\n+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"prev < current\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n+                return false;\n+            }\n+        } else {\n+            if (current < prev) {\n+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"current < prev\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n+                return false;\n+            }\n+        }\n+        if constexpr (uniq) {\n+            if (prev == current) {\n+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"equal\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n }\n \ndiff --git a/ydb/core/formats/arrow/scalar/serialization.cpp b/ydb/library/formats/arrow/scalar/serialization.cpp\nsimilarity index 97%\nrename from ydb/core/formats/arrow/scalar/serialization.cpp\nrename to ydb/library/formats/arrow/scalar/serialization.cpp\nindex 2b8fb74a92ab..e488dfabd687 100644\n--- a/ydb/core/formats/arrow/scalar/serialization.cpp\n+++ b/ydb/library/formats/arrow/scalar/serialization.cpp\n@@ -1,5 +1,5 @@\n #include \"serialization.h\"\n-#include <ydb/core/formats/arrow/switch/switch_type.h>\n+#include <ydb/library/formats/arrow/switch/switch_type.h>\n #include <ydb/library/actors/core/log.h>\n \n namespace NKikimr::NArrow::NScalar {\ndiff --git a/ydb/core/formats/arrow/scalar/serialization.h b/ydb/library/formats/arrow/scalar/serialization.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/scalar/serialization.h\nrename to ydb/library/formats/arrow/scalar/serialization.h\ndiff --git a/ydb/core/formats/arrow/scalar/ya.make b/ydb/library/formats/arrow/scalar/ya.make\nsimilarity index 79%\nrename from ydb/core/formats/arrow/scalar/ya.make\nrename to ydb/library/formats/arrow/scalar/ya.make\nindex d6284ba9ca44..41ca57bd3b7d 100644\n--- a/ydb/core/formats/arrow/scalar/ya.make\n+++ b/ydb/library/formats/arrow/scalar/ya.make\n@@ -3,7 +3,7 @@ LIBRARY()\n PEERDIR(\n     contrib/libs/apache/arrow\n     ydb/library/conclusion\n-    ydb/core/formats/arrow/switch\n+    ydb/library/formats/arrow/switch\n     ydb/library/actors/core\n )\n \ndiff --git a/ydb/core/formats/arrow/simple_arrays_cache.cpp b/ydb/library/formats/arrow/simple_arrays_cache.cpp\nsimilarity index 98%\nrename from ydb/core/formats/arrow/simple_arrays_cache.cpp\nrename to ydb/library/formats/arrow/simple_arrays_cache.cpp\nindex 5c06b061061f..e963f50607c3 100644\n--- a/ydb/core/formats/arrow/simple_arrays_cache.cpp\n+++ b/ydb/library/formats/arrow/simple_arrays_cache.cpp\n@@ -1,6 +1,8 @@\n #include \"simple_arrays_cache.h\"\n #include \"common/validation.h\"\n \n+#include <arrow/array/util.h>\n+\n namespace NKikimr::NArrow {\n \n std::shared_ptr<arrow::Array> TThreadSimpleArraysCache::GetNullImpl(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount) {\ndiff --git a/ydb/core/formats/arrow/simple_arrays_cache.h b/ydb/library/formats/arrow/simple_arrays_cache.h\nsimilarity index 74%\nrename from ydb/core/formats/arrow/simple_arrays_cache.h\nrename to ydb/library/formats/arrow/simple_arrays_cache.h\nindex e527e44a0b08..2d307171658f 100644\n--- a/ydb/core/formats/arrow/simple_arrays_cache.h\n+++ b/ydb/library/formats/arrow/simple_arrays_cache.h\n@@ -36,10 +36,14 @@ class TThreadSimpleArraysCache {\n     }\n \n     std::shared_ptr<arrow::Array> GetNullImpl(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);\n-    std::shared_ptr<arrow::Array> GetConstImpl(const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n+    std::shared_ptr<arrow::Array> GetConstImpl(\n+        const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n+\n public:\n     static std::shared_ptr<arrow::Array> GetNull(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);\n-    static std::shared_ptr<arrow::Array> GetConst(const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n-    static std::shared_ptr<arrow::Array> Get(const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n+    static std::shared_ptr<arrow::Array> GetConst(\n+        const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n+    static std::shared_ptr<arrow::Array> Get(\n+        const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n };\n-}\n+}   // namespace NKikimr::NArrow\ndiff --git a/ydb/core/formats/arrow/simple_builder/array.cpp b/ydb/library/formats/arrow/simple_builder/array.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/simple_builder/array.cpp\nrename to ydb/library/formats/arrow/simple_builder/array.cpp\ndiff --git a/ydb/core/formats/arrow/simple_builder/array.h b/ydb/library/formats/arrow/simple_builder/array.h\nsimilarity index 94%\nrename from ydb/core/formats/arrow/simple_builder/array.h\nrename to ydb/library/formats/arrow/simple_builder/array.h\nindex ec7680bc73b1..6803ff92e499 100644\n--- a/ydb/core/formats/arrow/simple_builder/array.h\n+++ b/ydb/library/formats/arrow/simple_builder/array.h\n@@ -52,10 +52,12 @@ class TSimpleArrayConstructor: public IArrayBuilder {\n     using TSelf = TSimpleArrayConstructor<TFiller>;\n     using TBuilder = typename arrow::TypeTraits<typename TFiller::TValue>::BuilderType;\n     const TFiller Filler;\n+    ui32 ShiftValue = 0;\n \n-    TSimpleArrayConstructor(const TString& fieldName, bool nullable, const TFiller& filler)\n+    TSimpleArrayConstructor(const TString& fieldName, bool nullable, const TFiller& filler, ui32 shiftValue = 0)\n         : TBase(fieldName, nullable)\n         , Filler(filler)\n+        , ShiftValue(shiftValue)\n     {\n     }\n protected:\n@@ -63,16 +65,17 @@ class TSimpleArrayConstructor: public IArrayBuilder {\n         TBuilder fBuilder = TFillerBuilderConstructor<typename TFiller::TValue>::Construct();\n         Y_ABORT_UNLESS(fBuilder.Reserve(recordsCount).ok());\n         for (ui32 i = 0; i < recordsCount; ++i) {\n-            Y_ABORT_UNLESS(fBuilder.Append(Filler.GetValue(i)).ok());\n+            Y_ABORT_UNLESS(fBuilder.Append(Filler.GetValue(i + ShiftValue)).ok());\n         }\n         return *fBuilder.Finish();\n     }\n \n-    \n+\n public:\n-    TSimpleArrayConstructor(const TString& fieldName, const TFiller& filler = TFiller())\n+    TSimpleArrayConstructor(const TString& fieldName, const TFiller& filler = TFiller(), ui32 shiftValue = 0)\n         : TBase(fieldName)\n         , Filler(filler)\n+        , ShiftValue(shiftValue)\n     {\n     }\n \ndiff --git a/ydb/core/formats/arrow/simple_builder/batch.cpp b/ydb/library/formats/arrow/simple_builder/batch.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/simple_builder/batch.cpp\nrename to ydb/library/formats/arrow/simple_builder/batch.cpp\ndiff --git a/ydb/core/formats/arrow/simple_builder/batch.h b/ydb/library/formats/arrow/simple_builder/batch.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/simple_builder/batch.h\nrename to ydb/library/formats/arrow/simple_builder/batch.h\ndiff --git a/ydb/core/formats/arrow/simple_builder/filler.cpp b/ydb/library/formats/arrow/simple_builder/filler.cpp\nsimilarity index 55%\nrename from ydb/core/formats/arrow/simple_builder/filler.cpp\nrename to ydb/library/formats/arrow/simple_builder/filler.cpp\nindex f6168701ddbe..337941bebe42 100644\n--- a/ydb/core/formats/arrow/simple_builder/filler.cpp\n+++ b/ydb/library/formats/arrow/simple_builder/filler.cpp\n@@ -1,11 +1,17 @@\n #include \"filler.h\"\n+\n #include <library/cpp/testing/unittest/registar.h>\n+#include <util/random/random.h>\n \n namespace NKikimr::NArrow::NConstruction {\n \n-TStringPoolFiller::TStringPoolFiller(const ui32 poolSize, const ui32 strLen) {\n+TStringPoolFiller::TStringPoolFiller(const ui32 poolSize, const ui32 strLen, const TString& defaultValue, const double defaultValueFrq) {\n     for (ui32 i = 0; i < poolSize; ++i) {\n-        Data.emplace_back(NUnitTest::RandomString(strLen, i));\n+        if (RandomNumber<double>() < defaultValueFrq) {\n+            Data.emplace_back(defaultValue);\n+        } else {\n+            Data.emplace_back(NUnitTest::RandomString(strLen, i));\n+        }\n     }\n }\n \n@@ -14,4 +20,4 @@ arrow::util::string_view TStringPoolFiller::GetValue(const ui32 idx) const {\n     return arrow::util::string_view(str.data(), str.size());\n }\n \n-}\n+}   // namespace NKikimr::NArrow::NConstruction\ndiff --git a/ydb/core/formats/arrow/simple_builder/filler.h b/ydb/library/formats/arrow/simple_builder/filler.h\nsimilarity index 60%\nrename from ydb/core/formats/arrow/simple_builder/filler.h\nrename to ydb/library/formats/arrow/simple_builder/filler.h\nindex e86e7a6c2139..c9c115933358 100644\n--- a/ydb/core/formats/arrow/simple_builder/filler.h\n+++ b/ydb/library/formats/arrow/simple_builder/filler.h\n@@ -1,9 +1,13 @@\n #pragma once\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/util/string_view.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type_traits.h>\n-#include <util/system/types.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/util/string_view.h>\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+\n #include <util/generic/string.h>\n+#include <util/system/types.h>\n+#include <util/random/random.h>\n \n namespace NKikimr::NArrow::NConstruction {\n \n@@ -11,16 +15,76 @@ template <class TArrowInt>\n class TIntSeqFiller {\n public:\n     using TValue = TArrowInt;\n+\n private:\n     using CType = typename TArrowInt::c_type;\n     const CType Delta;\n+\n public:\n     CType GetValue(const CType idx) const {\n         return Delta + idx;\n     }\n     TIntSeqFiller(const CType delta = 0)\n         : Delta(delta) {\n+    }\n+};\n \n+class TStringType : public arrow::StringType {\n+public:\n+    using c_type = TString;\n+};\n+\n+template <class TArrowType>\n+class TPoolFiller {\n+private:\n+    using CType = typename TArrowType::c_type;\n+\n+private:\n+    std::vector<CType> Data;\n+\n+public:\n+    using TValue = std::conditional_t<std::is_same_v<TArrowType, TStringType>, arrow::StringType, TArrowType>;\n+    using ValueType = std::conditional_t<std::is_same_v<TArrowType, TStringType>, arrow::util::string_view, CType>;\n+\n+    static CType GetRandomNumberNotEqDef(CType defaultValue) {\n+        CType result;\n+        do {\n+            result = RandomNumber<double>() * std::numeric_limits<CType>::max();\n+        } while (result == defaultValue);\n+        return result;\n+    }\n+\n+    TPoolFiller(const ui32 poolSize, const CType defaultValue, const double defaultValueFrq) {\n+        for (ui32 i = 0; i < poolSize; ++i) {\n+            if (RandomNumber<double>() < defaultValueFrq) {\n+                Data.emplace_back(defaultValue);\n+            } else {\n+                Data.emplace_back(GetRandomNumberNotEqDef(defaultValue));\n+            }\n+        }\n+    }\n+\n+    TPoolFiller(const ui32 poolSize, const ui32 strLen, const TString& defaultValue, const double defaultValueFrq) {\n+        for (ui32 i = 0; i < poolSize; ++i) {\n+            if (RandomNumber<double>() < defaultValueFrq) {\n+                Data.emplace_back(defaultValue);\n+            } else {\n+                Data.emplace_back(NUnitTest::RandomString(strLen, i));\n+            }\n+        }\n+    }\n+\n+    template<class Type>\n+    const ValueType Convert(const Type& v) const {\n+        return v;\n+    }\n+\n+    const ValueType Convert(const TString& str) const {\n+        return arrow::util::string_view(str.data(), str.size());\n+    }\n+\n+    ValueType GetValue(const ui32 idx) const {\n+        return Convert(Data[(2 + 7 * idx) % Data.size()]);\n     }\n };\n \n@@ -28,27 +92,29 @@ template <class TArrowInt>\n class TIntConstFiller {\n public:\n     using TValue = TArrowInt;\n+\n private:\n     using CType = typename TArrowInt::c_type;\n     const CType Value;\n+\n public:\n     CType GetValue(const CType /*idx*/) const {\n         return Value;\n     }\n     TIntConstFiller(const CType value)\n         : Value(value) {\n-\n     }\n };\n \n class TStringPoolFiller {\n private:\n     std::vector<TString> Data;\n+\n public:\n     using TValue = arrow::StringType;\n     arrow::util::string_view GetValue(const ui32 idx) const;\n \n-    TStringPoolFiller(const ui32 poolSize, const ui32 strLen);\n+    TStringPoolFiller(const ui32 poolSize, const ui32 strLen, const TString& defaultValue = \"\", const double defaultValueFrq = 0);\n };\n \n template <class TValueExt>\n@@ -56,6 +122,7 @@ class TLinearArrayAccessor {\n private:\n     using TArray = typename arrow::TypeTraits<TValueExt>::ArrayType;\n     const TArray& Data;\n+\n public:\n     using TValue = TValueExt;\n     auto GetValue(const ui32 idx) const {\n@@ -72,6 +139,7 @@ class TBinaryArrayAccessor {\n private:\n     using TArray = typename arrow::TypeTraits<TValueExt>::ArrayType;\n     const TArray& Data;\n+\n public:\n     using TValue = TValueExt;\n     const char* GetValueView(const ui32 idx) const {\n@@ -89,6 +157,7 @@ class TDictionaryArrayAccessor {\n     using TDictionary = typename arrow::TypeTraits<TDictionaryValue>::ArrayType;\n     const TDictionary& Dictionary;\n     const TIndices& Indices;\n+\n public:\n     using TValue = TDictionaryValue;\n     auto GetValue(const ui32 idx) const {\n@@ -108,6 +177,7 @@ class TBinaryDictionaryArrayAccessor {\n     const TDictionary& Dictionary;\n     const TIndices& Indices;\n     std::vector<TString> DictionaryStrings;\n+\n public:\n     using TValue = TDictionaryValue;\n     const char* GetValueView(const ui32 idx) const {\n@@ -116,8 +186,7 @@ class TBinaryDictionaryArrayAccessor {\n \n     TBinaryDictionaryArrayAccessor(const TDictionary& dictionary, const TIndices& indices)\n         : Dictionary(dictionary)\n-        , Indices(indices)\n-    {\n+        , Indices(indices) {\n         DictionaryStrings.reserve(Dictionary.length());\n         for (i64 idx = 0; idx < Dictionary.length(); ++idx) {\n             auto sView = Dictionary.Value(idx);\n@@ -126,4 +195,4 @@ class TBinaryDictionaryArrayAccessor {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NArrow::NConstruction\ndiff --git a/ydb/core/formats/arrow/simple_builder/ya.make b/ydb/library/formats/arrow/simple_builder/ya.make\nsimilarity index 100%\nrename from ydb/core/formats/arrow/simple_builder/ya.make\nrename to ydb/library/formats/arrow/simple_builder/ya.make\ndiff --git a/ydb/library/formats/arrow/size_calcer.cpp b/ydb/library/formats/arrow/size_calcer.cpp\nnew file mode 100644\nindex 000000000000..0f10f2e000fe\n--- /dev/null\n+++ b/ydb/library/formats/arrow/size_calcer.cpp\n@@ -0,0 +1,208 @@\n+#include \"size_calcer.h\"\n+#include \"switch_type.h\"\n+#include \"arrow_helpers.h\"\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <util/system/yassert.h>\n+#include <util/string/builder.h>\n+\n+namespace NKikimr::NArrow {\n+\n+ui32 TRowSizeCalculator::GetRowBitWidth(const ui32 row) const {\n+    Y_ABORT_UNLESS(Prepared);\n+    ui32 result = CommonSize;\n+    for (auto&& c : BinaryColumns) {\n+        result += GetBitWidthAligned(c->GetView(row).size() * 8);\n+    }\n+    for (auto&& c : StringColumns) {\n+        result += GetBitWidthAligned(c->GetView(row).size() * 8);\n+    }\n+    return result;\n+}\n+\n+bool TRowSizeCalculator::InitBatch(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    Batch = batch;\n+    CommonSize = 0;\n+    BinaryColumns.clear();\n+    StringColumns.clear();\n+    Prepared = false;\n+    for (ui32 i = 0; i < (ui32)Batch->num_columns(); ++i) {\n+        auto fSize = std::dynamic_pointer_cast<arrow::FixedWidthType>(Batch->column(i)->type());\n+        if (fSize) {\n+            CommonSize += GetBitWidthAligned(fSize->bit_width());\n+        } else {\n+            auto c = Batch->column(i);\n+            if (c->type()->id() == arrow::Type::BINARY) {\n+                const arrow::BinaryArray& viewArray = static_cast<const arrow::BinaryArray&>(*c);\n+                BinaryColumns.emplace_back(&viewArray);\n+            } else if (c->type()->id() == arrow::Type::STRING) {\n+                const arrow::StringArray& viewArray = static_cast<const arrow::StringArray&>(*c);\n+                StringColumns.emplace_back(&viewArray);\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+    Prepared = true;\n+    return true;\n+}\n+\n+ui32 TRowSizeCalculator::GetRowBytesSize(const ui32 row) const {\n+    const ui32 bitsWidth = GetRowBitWidth(row);\n+    ui32 result = bitsWidth / 8;\n+    if (bitsWidth % 8) {\n+        ++result;\n+    }\n+    return result;\n+}\n+\n+ui64 GetArrayMemorySize(const std::shared_ptr<arrow::ArrayData>& data) {\n+    if (!data) {\n+        return 0;\n+    }\n+    ui64 result = 0;\n+    for (auto&& i : data->buffers) {\n+        if (i) {\n+            result += i->capacity();\n+        }\n+    }\n+    for (auto&& i : data->child_data) {\n+        for (auto&& b : i->buffers) {\n+            if (b) {\n+                result += b->capacity();\n+            }\n+        }\n+    }\n+    if (data->dictionary) {\n+        for (auto&& b : data->dictionary->buffers) {\n+            if (b) {\n+                result += b->capacity();\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n+\n+ui64 GetBatchDataSize(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    if (!batch) {\n+        return 0;\n+    }\n+    ui64 bytes = 0;\n+    for (auto& column : batch->columns()) {\n+        bytes += GetArrayDataSize(column);\n+    }\n+    return bytes;\n+}\n+\n+ui64 GetBatchMemorySize(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    if (!batch) {\n+        return 0;\n+    }\n+    ui64 bytes = 0;\n+    for (auto& column : batch->column_data()) {\n+        bytes += GetArrayMemorySize(column);\n+    }\n+    return bytes;\n+}\n+\n+ui64 GetTableMemorySize(const std::shared_ptr<arrow::Table>& batch) {\n+    if (!batch) {\n+        return 0;\n+    }\n+    ui64 bytes = 0;\n+    for (auto& column : batch->columns()) {\n+        for (auto&& chunk : column->chunks()) {\n+            bytes += GetArrayMemorySize(chunk->data());\n+        }\n+    }\n+    return bytes;\n+}\n+\n+ui64 GetTableDataSize(const std::shared_ptr<arrow::Table>& batch) {\n+    if (!batch) {\n+        return 0;\n+    }\n+    ui64 bytes = 0;\n+    for (auto& column : batch->columns()) {\n+        for (auto&& chunk : column->chunks()) {\n+            bytes += GetArrayDataSize(chunk);\n+        }\n+    }\n+    return bytes;\n+}\n+\n+template <typename TType>\n+ui64 GetArrayDataSizeImpl(const std::shared_ptr<arrow::Array>& column) {\n+    return sizeof(typename TType::c_type) * column->length();\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::NullType>(const std::shared_ptr<arrow::Array>& column) {\n+    return column->length() * 8; // Special value for empty lines\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::StringType>(const std::shared_ptr<arrow::Array>& column) {\n+    auto typedColumn = std::static_pointer_cast<arrow::StringArray>(column);\n+    return typedColumn->total_values_length() + sizeof(arrow::StringArray::offset_type) * column->length();\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::LargeStringType>(const std::shared_ptr<arrow::Array>& column) {\n+    auto typedColumn = std::static_pointer_cast<arrow::LargeStringArray>(column);\n+    return typedColumn->total_values_length() + sizeof(arrow::LargeStringArray::offset_type) * column->length();\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::BinaryType>(const std::shared_ptr<arrow::Array>& column) {\n+    auto typedColumn = std::static_pointer_cast<arrow::BinaryArray>(column);\n+    return typedColumn->total_values_length() + sizeof(arrow::BinaryArray::offset_type) * column->length();\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::LargeBinaryType>(const std::shared_ptr<arrow::Array>& column) {\n+    auto typedColumn = std::static_pointer_cast<arrow::LargeBinaryArray>(column);\n+    return typedColumn->total_values_length() + sizeof(arrow::LargeBinaryArray::offset_type) * column->length();\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::FixedSizeBinaryType>(const std::shared_ptr<arrow::Array>& column) {\n+    auto typedColumn = std::static_pointer_cast<arrow::FixedSizeBinaryArray>(column);\n+    return typedColumn->byte_width() * typedColumn->length();\n+}\n+\n+template <>\n+ui64 GetArrayDataSizeImpl<arrow::Decimal128Type>(const std::shared_ptr<arrow::Array>& column) {\n+    return sizeof(ui64) * 2 * column->length();\n+}\n+\n+ui64 GetArrayDataSize(const std::shared_ptr<arrow::Array>& column) {\n+    auto type = column->type();\n+    if (type->id() == arrow::Type::DICTIONARY) {\n+        auto dictArray = static_pointer_cast<arrow::DictionaryArray>(column);\n+        return GetDictionarySize(dictArray);\n+    }\n+    ui64 bytes = 0;\n+    bool success = SwitchTypeWithNull(type->id(), [&]<typename TType>(TTypeWrapper<TType> typeHolder) {\n+        Y_UNUSED(typeHolder);\n+        bytes = GetArrayDataSizeImpl<TType>(column);\n+        return true;\n+    });\n+\n+    // Add null bit mask overhead if any.\n+    if (HasNulls(column)) {\n+        bytes += column->length() / 8 + 1;\n+    }\n+\n+    Y_DEBUG_ABORT_UNLESS(success, \"Unsupported arrow type %s\", type->ToString().data());\n+    return bytes;\n+}\n+\n+ui64 GetDictionarySize(const std::shared_ptr<arrow::DictionaryArray>& data) {\n+    if (!data) {\n+        return 0;\n+    }\n+    return GetArrayDataSize(data->dictionary()) + GetArrayDataSize(data->indices());\n+}\n+\n+}\ndiff --git a/ydb/library/formats/arrow/size_calcer.h b/ydb/library/formats/arrow/size_calcer.h\nnew file mode 100644\nindex 000000000000..4101e55da4af\n--- /dev/null\n+++ b/ydb/library/formats/arrow/size_calcer.h\n@@ -0,0 +1,63 @@\n+#pragma once\n+\n+#include <ydb/library/accessor/accessor.h>\n+#include <ydb/library/actors/core/log.h>\n+#include <ydb/library/conclusion/result.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_binary.h>\n+#include <util/system/types.h>\n+#include <util/generic/string.h>\n+\n+namespace NKikimr::NArrow {\n+\n+class TRowSizeCalculator {\n+private:\n+    std::shared_ptr<arrow::RecordBatch> Batch;\n+    ui32 CommonSize = 0;\n+    std::vector<const arrow::BinaryArray*> BinaryColumns;\n+    std::vector<const arrow::StringArray*> StringColumns;\n+    bool Prepared = false;\n+    const ui32 AlignBitsCount = 1;\n+\n+    ui32 GetBitWidthAligned(const ui32 bitWidth) const {\n+        if (AlignBitsCount == 1) {\n+            return bitWidth;\n+        }\n+        ui32 result = bitWidth / AlignBitsCount;\n+        if (bitWidth % AlignBitsCount) {\n+            result += 1;\n+        }\n+        result *= AlignBitsCount;\n+        return result;\n+    }\n+\n+public:\n+\n+    ui64 GetApproxSerializeSize(const ui64 dataSize) const {\n+        return Max<ui64>(dataSize * 1.05, dataSize + Batch->num_columns() * 8);\n+    }\n+\n+    TRowSizeCalculator(const ui32 alignBitsCount)\n+        : AlignBitsCount(alignBitsCount)\n+    {\n+\n+    }\n+    bool InitBatch(const std::shared_ptr<arrow::RecordBatch>& batch);\n+    ui32 GetRowBitWidth(const ui32 row) const;\n+    ui32 GetRowBytesSize(const ui32 row) const;\n+};\n+\n+// Return size in bytes including size of bitmap mask\n+ui64 GetBatchDataSize(const std::shared_ptr<arrow::RecordBatch>& batch);\n+ui64 GetTableDataSize(const std::shared_ptr<arrow::Table>& batch);\n+// Return size in bytes including size of bitmap mask\n+ui64 GetArrayMemorySize(const std::shared_ptr<arrow::ArrayData>& data);\n+ui64 GetBatchMemorySize(const std::shared_ptr<arrow::RecordBatch>&batch);\n+ui64 GetTableMemorySize(const std::shared_ptr<arrow::Table>& batch);\n+// Return size in bytes *not* including size of bitmap mask\n+ui64 GetArrayDataSize(const std::shared_ptr<arrow::Array>& column);\n+\n+ui64 GetDictionarySize(const std::shared_ptr<arrow::DictionaryArray>& data);\n+\n+}\ndiff --git a/ydb/library/formats/arrow/splitter/similar_packer.cpp b/ydb/library/formats/arrow/splitter/similar_packer.cpp\nnew file mode 100644\nindex 000000000000..94395e18c3ee\n--- /dev/null\n+++ b/ydb/library/formats/arrow/splitter/similar_packer.cpp\n@@ -0,0 +1,5 @@\n+#include \"similar_packer.h\"\n+\n+namespace NKikimr::NArrow::NSplitter {\n+\n+}\ndiff --git a/ydb/core/tx/columnshard/splitter/similar_packer.h b/ydb/library/formats/arrow/splitter/similar_packer.h\nsimilarity index 98%\nrename from ydb/core/tx/columnshard/splitter/similar_packer.h\nrename to ydb/library/formats/arrow/splitter/similar_packer.h\nindex 54abde2640fb..1fdfdf3e7a83 100644\n--- a/ydb/core/tx/columnshard/splitter/similar_packer.h\n+++ b/ydb/library/formats/arrow/splitter/similar_packer.h\n@@ -3,7 +3,7 @@\n \n #include <vector>\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NSplitter {\n \n template <class TContainer>\n class TArrayView {\ndiff --git a/ydb/core/tx/columnshard/splitter/stats.cpp b/ydb/library/formats/arrow/splitter/stats.cpp\nsimilarity index 95%\nrename from ydb/core/tx/columnshard/splitter/stats.cpp\nrename to ydb/library/formats/arrow/splitter/stats.cpp\nindex 3cb468bec5ad..c815485ada8e 100644\n--- a/ydb/core/tx/columnshard/splitter/stats.cpp\n+++ b/ydb/library/formats/arrow/splitter/stats.cpp\n@@ -1,7 +1,7 @@\n #include \"stats.h\"\n #include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NSplitter {\n \n std::optional<TBatchSerializationStat> TSerializationStats::GetStatsForRecordBatch(const std::shared_ptr<arrow::Schema>& schema) const {\n     std::optional<TBatchSerializationStat> result;\ndiff --git a/ydb/core/tx/columnshard/splitter/stats.h b/ydb/library/formats/arrow/splitter/stats.h\nsimilarity index 99%\nrename from ydb/core/tx/columnshard/splitter/stats.h\nrename to ydb/library/formats/arrow/splitter/stats.h\nindex 695a7ab32dd7..447e59b68ca0 100644\n--- a/ydb/core/tx/columnshard/splitter/stats.h\n+++ b/ydb/library/formats/arrow/splitter/stats.h\n@@ -11,7 +11,7 @@\n #include <string>\n #include <memory>\n \n-namespace NKikimr::NOlap {\n+namespace NKikimr::NArrow::NSplitter {\n \n class TSimpleSerializationStat {\n protected:\ndiff --git a/ydb/library/formats/arrow/splitter/ya.make b/ydb/library/formats/arrow/splitter/ya.make\nnew file mode 100644\nindex 000000000000..9720a4366b75\n--- /dev/null\n+++ b/ydb/library/formats/arrow/splitter/ya.make\n@@ -0,0 +1,14 @@\n+LIBRARY()\n+\n+SRCS(\n+    stats.cpp\n+    similar_packer.cpp\n+)\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/actors/core\n+    ydb/library/conclusion\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/switch/compare.cpp b/ydb/library/formats/arrow/switch/compare.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/switch/compare.cpp\nrename to ydb/library/formats/arrow/switch/compare.cpp\ndiff --git a/ydb/core/formats/arrow/switch/compare.h b/ydb/library/formats/arrow/switch/compare.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/switch/compare.h\nrename to ydb/library/formats/arrow/switch/compare.h\ndiff --git a/ydb/library/formats/arrow/switch/switch_type.cpp b/ydb/library/formats/arrow/switch/switch_type.cpp\nnew file mode 100644\nindex 000000000000..b8396151cb4e\n--- /dev/null\n+++ b/ydb/library/formats/arrow/switch/switch_type.cpp\n@@ -0,0 +1,5 @@\n+#include \"switch_type.h\"\n+\n+namespace NKikimr::NArrow {\n+\n+}\ndiff --git a/ydb/library/formats/arrow/switch/switch_type.h b/ydb/library/formats/arrow/switch/switch_type.h\nnew file mode 100644\nindex 000000000000..ab9f6aa1bbfe\n--- /dev/null\n+++ b/ydb/library/formats/arrow/switch/switch_type.h\n@@ -0,0 +1,184 @@\n+#pragma once\n+#include <ydb/library/formats/arrow/common/validation.h>\n+#include <ydb/library/yql/parser/pg_wrapper/interface/type_desc.h>\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>\n+#include <util/system/yassert.h>\n+\n+extern \"C\" {\n+#include <ydb/library/yql/parser/pg_wrapper/postgresql/src/include/catalog/pg_type_d.h>\n+}\n+\n+namespace NKikimr::NArrow {\n+\n+template <typename TType>\n+struct TTypeWrapper\n+{\n+    using T = TType;\n+};\n+\n+template <class TResult, TResult defaultValue, typename TFunc, bool EnableNull = false>\n+TResult SwitchTypeImpl(arrow::Type::type typeId, TFunc&& f) {\n+    switch (typeId) {\n+        case arrow::Type::NA: {\n+            if constexpr (EnableNull) {\n+                return f(TTypeWrapper<arrow::NullType>());\n+            }\n+            break;\n+        }\n+        case arrow::Type::BOOL:\n+            return f(TTypeWrapper<arrow::BooleanType>());\n+        case arrow::Type::UINT8:\n+            return f(TTypeWrapper<arrow::UInt8Type>());\n+        case arrow::Type::INT8:\n+            return f(TTypeWrapper<arrow::Int8Type>());\n+        case arrow::Type::UINT16:\n+            return f(TTypeWrapper<arrow::UInt16Type>());\n+        case arrow::Type::INT16:\n+            return f(TTypeWrapper<arrow::Int16Type>());\n+        case arrow::Type::UINT32:\n+            return f(TTypeWrapper<arrow::UInt32Type>());\n+        case arrow::Type::INT32:\n+            return f(TTypeWrapper<arrow::Int32Type>());\n+        case arrow::Type::UINT64:\n+            return f(TTypeWrapper<arrow::UInt64Type>());\n+        case arrow::Type::INT64:\n+            return f(TTypeWrapper<arrow::Int64Type>());\n+        case arrow::Type::HALF_FLOAT:\n+            return f(TTypeWrapper<arrow::HalfFloatType>());\n+        case arrow::Type::FLOAT:\n+            return f(TTypeWrapper<arrow::FloatType>());\n+        case arrow::Type::DOUBLE:\n+            return f(TTypeWrapper<arrow::DoubleType>());\n+        case arrow::Type::STRING:\n+            return f(TTypeWrapper<arrow::StringType>());\n+        case arrow::Type::BINARY:\n+            return f(TTypeWrapper<arrow::BinaryType>());\n+        case arrow::Type::FIXED_SIZE_BINARY:\n+            return f(TTypeWrapper<arrow::FixedSizeBinaryType>());\n+        case arrow::Type::DATE32:\n+            return f(TTypeWrapper<arrow::Date32Type>());\n+        case arrow::Type::DATE64:\n+            return f(TTypeWrapper<arrow::Date64Type>());\n+        case arrow::Type::TIMESTAMP:\n+            return f(TTypeWrapper<arrow::TimestampType>());\n+        case arrow::Type::TIME32:\n+            return f(TTypeWrapper<arrow::Time32Type>());\n+        case arrow::Type::TIME64:\n+            return f(TTypeWrapper<arrow::Time64Type>());\n+        case arrow::Type::INTERVAL_MONTHS:\n+            return f(TTypeWrapper<arrow::MonthIntervalType>());\n+        case arrow::Type::DECIMAL:\n+            return f(TTypeWrapper<arrow::Decimal128Type>());\n+        case arrow::Type::DURATION:\n+            return f(TTypeWrapper<arrow::DurationType>());\n+        case arrow::Type::LARGE_STRING:\n+            return f(TTypeWrapper<arrow::LargeStringType>());\n+        case arrow::Type::LARGE_BINARY:\n+            return f(TTypeWrapper<arrow::LargeBinaryType>());\n+        case arrow::Type::DECIMAL256:\n+        case arrow::Type::DENSE_UNION:\n+        case arrow::Type::DICTIONARY:\n+        case arrow::Type::EXTENSION:\n+        case arrow::Type::FIXED_SIZE_LIST:\n+        case arrow::Type::INTERVAL_DAY_TIME:\n+        case arrow::Type::LARGE_LIST:\n+        case arrow::Type::LIST:\n+        case arrow::Type::MAP:\n+        case arrow::Type::MAX_ID:\n+        case arrow::Type::SPARSE_UNION:\n+        case arrow::Type::STRUCT:\n+            break;\n+    }\n+\n+    return defaultValue;\n+}\n+\n+template <typename TFunc, bool EnableNull = false>\n+bool SwitchType(arrow::Type::type typeId, TFunc&& f) {\n+    return SwitchTypeImpl<bool, false, TFunc, EnableNull>(typeId, std::move(f));\n+}\n+\n+template <typename TFunc>\n+bool SwitchTypeWithNull(arrow::Type::type typeId, TFunc&& f) {\n+    return SwitchType<TFunc, true>(typeId, std::move(f));\n+}\n+\n+template <typename TFunc>\n+bool SwitchArrayType(const arrow::Datum& column, TFunc&& f) {\n+    auto type = column.type();\n+    Y_ABORT_UNLESS(type);\n+    return SwitchType(type->id(), std::forward<TFunc>(f));\n+}\n+\n+template <typename T>\n+bool Append(arrow::ArrayBuilder& builder, const typename T::c_type& value) {\n+    using TBuilder = typename arrow::TypeTraits<T>::BuilderType;\n+\n+    TStatusValidator::Validate(static_cast<TBuilder&>(builder).Append(value));\n+    return true;\n+}\n+\n+template <typename T>\n+bool Append(arrow::ArrayBuilder& builder, arrow::util::string_view value) {\n+    using TBuilder = typename arrow::TypeTraits<T>::BuilderType;\n+\n+    TStatusValidator::Validate(static_cast<TBuilder&>(builder).Append(value));\n+    return true;\n+}\n+\n+template <typename T>\n+bool Append(arrow::ArrayBuilder& builder, const typename T::c_type* values, size_t size) {\n+    using TBuilder = typename arrow::NumericBuilder<T>;\n+\n+    TStatusValidator::Validate(static_cast<TBuilder&>(builder).AppendValues(values, size));\n+    return true;\n+}\n+\n+template <typename T>\n+bool Append(arrow::ArrayBuilder& builder, const std::vector<typename T::c_type>& values) {\n+    using TBuilder = typename arrow::NumericBuilder<T>;\n+\n+    TStatusValidator::Validate(static_cast<TBuilder&>(builder).AppendValues(values.data(), values.size()));\n+    return true;\n+}\n+\n+template <typename T>\n+[[nodiscard]] bool Append(T& builder, const arrow::Array& array, int position, ui64* recordSize = nullptr) {\n+    Y_DEBUG_ABORT_UNLESS(builder.type()->id() == array.type_id());\n+    return SwitchType(array.type_id(), [&](const auto& type) {\n+        using TWrap = std::decay_t<decltype(type)>;\n+        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n+        using TBuilder = typename arrow::TypeTraits<typename TWrap::T>::BuilderType;\n+\n+        auto& typedArray = static_cast<const TArray&>(array);\n+        auto& typedBuilder = static_cast<TBuilder&>(builder);\n+\n+        if (typedArray.IsNull(position)) {\n+            TStatusValidator::Validate(typedBuilder.AppendNull());\n+            if (recordSize) {\n+                *recordSize += 4;\n+            }\n+            return true;\n+        } else {\n+            if constexpr (!arrow::has_string_view<typename TWrap::T>::value) {\n+                TStatusValidator::Validate(typedBuilder.Append(typedArray.GetView(position)));\n+                if (recordSize) {\n+                    *recordSize += sizeof(typedArray.GetView(position));\n+                }\n+                return true;\n+            }\n+            if constexpr (arrow::has_string_view<typename TWrap::T>::value) {\n+                TStatusValidator::Validate(typedBuilder.Append(typedArray.GetView(position)));\n+                if (recordSize) {\n+                    *recordSize += typedArray.GetView(position).size();\n+                }\n+                return true;\n+            }\n+        }\n+        Y_ABORT_UNLESS(false, \"unpredictable variant\");\n+        return false;\n+    });\n+}\n+\n+}\ndiff --git a/ydb/library/formats/arrow/switch/ya.make b/ydb/library/formats/arrow/switch/ya.make\nnew file mode 100644\nindex 000000000000..4a42fa96cacb\n--- /dev/null\n+++ b/ydb/library/formats/arrow/switch/ya.make\n@@ -0,0 +1,13 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/actors/core\n+)\n+\n+SRCS(\n+    switch_type.cpp\n+    compare.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/switch_type.h b/ydb/library/formats/arrow/switch_type.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/switch_type.h\nrename to ydb/library/formats/arrow/switch_type.h\ndiff --git a/ydb/core/formats/arrow/transformer/abstract.cpp b/ydb/library/formats/arrow/transformer/abstract.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/transformer/abstract.cpp\nrename to ydb/library/formats/arrow/transformer/abstract.cpp\ndiff --git a/ydb/core/formats/arrow/transformer/abstract.h b/ydb/library/formats/arrow/transformer/abstract.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/transformer/abstract.h\nrename to ydb/library/formats/arrow/transformer/abstract.h\ndiff --git a/ydb/core/formats/arrow/transformer/composite.cpp b/ydb/library/formats/arrow/transformer/composite.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/transformer/composite.cpp\nrename to ydb/library/formats/arrow/transformer/composite.cpp\ndiff --git a/ydb/core/formats/arrow/transformer/composite.h b/ydb/library/formats/arrow/transformer/composite.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/transformer/composite.h\nrename to ydb/library/formats/arrow/transformer/composite.h\ndiff --git a/ydb/library/formats/arrow/transformer/ya.make b/ydb/library/formats/arrow/transformer/ya.make\nnew file mode 100644\nindex 000000000000..601adb56ae18\n--- /dev/null\n+++ b/ydb/library/formats/arrow/transformer/ya.make\n@@ -0,0 +1,12 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+)\n+\n+SRCS(\n+    abstract.cpp\n+    composite.cpp\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/arrow/ut/ut_arrow.cpp b/ydb/library/formats/arrow/ut/ut_arrow.cpp\nnew file mode 100644\nindex 000000000000..22240b623530\n--- /dev/null\n+++ b/ydb/library/formats/arrow/ut/ut_arrow.cpp\n@@ -0,0 +1,302 @@\n+#include <ydb/library/formats/arrow/arrow_helpers.h>\n+#include <ydb/library/formats/arrow/permutations.h>\n+\n+#include <ydb/library/binary_json/write.h>\n+#include <library/cpp/testing/unittest/registar.h>\n+#include <util/string/printf.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api.h>\n+#include <util/random/shuffle.h>\n+\n+namespace NKikimr {\n+namespace {\n+\n+struct TDataRow {\n+    bool Bool;\n+    i8 Int8;\n+    i16 Int16;\n+    i32 Int32;\n+    i64 Int64;\n+    ui8 UInt8;\n+    ui16 UInt16;\n+    ui32 UInt32;\n+    ui64 UInt64;\n+    float Float32;\n+    double Float64;\n+    std::string String;\n+    std::string Utf8;\n+    std::string Json;\n+    std::string Yson;\n+    ui16 Date;\n+    ui32 Datetime;\n+    i64 Timestamp;\n+    i64 Interval;\n+    std::string JsonDocument;\n+    //ui64 Decimal[2];\n+\n+    bool operator == (const TDataRow& r) const {\n+        return (Bool == r.Bool) &&\n+            (Int8 == r.Int8) &&\n+            (Int16 == r.Int16) &&\n+            (Int32 == r.Int32) &&\n+            (Int64 == r.Int64) &&\n+            (UInt8 == r.UInt8) &&\n+            (UInt16 == r.UInt16) &&\n+            (UInt32 == r.UInt32) &&\n+            (UInt64 == r.UInt64) &&\n+            (Float32 == r.Float32) &&\n+            (Float64 == r.Float64) &&\n+            (String == r.String) &&\n+            (Utf8 == r.Utf8) &&\n+            (Json == r.Json) &&\n+            (Yson == r.Yson) &&\n+            (Date == r.Date) &&\n+            (Datetime == r.Datetime) &&\n+            (Timestamp == r.Timestamp) &&\n+            (Interval == r.Interval) &&\n+            (JsonDocument == r.JsonDocument);\n+            //(Decimal[0] == r.Decimal[0] && Decimal[1] == r.Decimal[1]);\n+    }\n+\n+    static std::shared_ptr<arrow::Schema> MakeArrowSchema() {\n+        std::vector<std::shared_ptr<arrow::Field>> fields = {\n+            arrow::field(\"bool\", arrow::boolean()),\n+            arrow::field(\"i8\", arrow::int8()),\n+            arrow::field(\"i16\", arrow::int16()),\n+            arrow::field(\"i32\", arrow::int32()),\n+            arrow::field(\"i64\", arrow::int64()),\n+            arrow::field(\"ui8\", arrow::uint8()),\n+            arrow::field(\"ui16\", arrow::uint16()),\n+            arrow::field(\"ui32\", arrow::uint32()),\n+            arrow::field(\"ui64\", arrow::uint64()),\n+            arrow::field(\"f32\", arrow::float32()),\n+            arrow::field(\"f64\", arrow::float64()),\n+            arrow::field(\"string\", arrow::binary()),\n+            arrow::field(\"utf8\", arrow::utf8()),\n+            arrow::field(\"json\", arrow::utf8()),\n+            arrow::field(\"yson\", arrow::binary()),\n+            arrow::field(\"date\", arrow::uint16()),\n+            arrow::field(\"datetime\", arrow::uint32()),\n+            arrow::field(\"ts\", arrow::timestamp(arrow::TimeUnit::TimeUnit::MICRO)),\n+            arrow::field(\"ival\", arrow::duration(arrow::TimeUnit::TimeUnit::MICRO)),\n+            arrow::field(\"json_doc\", arrow::binary()),\n+            //arrow::field(\"dec\", arrow::decimal(NScheme::DECIMAL_PRECISION, NScheme::DECIMAL_SCALE)),\n+        };\n+\n+        return std::make_shared<arrow::Schema>(std::move(fields));\n+    }\n+};\n+\n+\n+std::shared_ptr<arrow::Array> GetColumn(const arrow::Table& table, int i, int chunk = 0) {\n+    return table.column(i)->chunk(chunk);\n+}\n+\n+template <typename T>\n+std::vector<TDataRow> ToVector(const std::shared_ptr<T>& table) {\n+    std::vector<TDataRow> rows;\n+\n+    auto arbool = std::static_pointer_cast<arrow::BooleanArray>(GetColumn(*table, 0));\n+    auto ari8 = std::static_pointer_cast<arrow::Int8Array>(GetColumn(*table, 1));\n+    auto ari16 = std::static_pointer_cast<arrow::Int16Array>(GetColumn(*table, 2));\n+    auto ari32 = std::static_pointer_cast<arrow::Int32Array>(GetColumn(*table, 3));\n+    auto ari64 = std::static_pointer_cast<arrow::Int64Array>(GetColumn(*table, 4));\n+    auto aru8 = std::static_pointer_cast<arrow::UInt8Array>(GetColumn(*table, 5));\n+    auto aru16 = std::static_pointer_cast<arrow::UInt16Array>(GetColumn(*table, 6));\n+    auto aru32 = std::static_pointer_cast<arrow::UInt32Array>(GetColumn(*table, 7));\n+    auto aru64 = std::static_pointer_cast<arrow::UInt64Array>(GetColumn(*table, 8));\n+    auto arf32 = std::static_pointer_cast<arrow::FloatArray>(GetColumn(*table, 9));\n+    auto arf64 = std::static_pointer_cast<arrow::DoubleArray>(GetColumn(*table, 10));\n+\n+    auto arstr = std::static_pointer_cast<arrow::BinaryArray>(GetColumn(*table, 11));\n+    auto arutf = std::static_pointer_cast<arrow::StringArray>(GetColumn(*table, 12));\n+    auto arj = std::static_pointer_cast<arrow::BinaryArray>(GetColumn(*table, 13));\n+    auto ary = std::static_pointer_cast<arrow::BinaryArray>(GetColumn(*table, 14));\n+\n+    auto ard = std::static_pointer_cast<arrow::UInt16Array>(GetColumn(*table, 15));\n+    auto ardt = std::static_pointer_cast<arrow::UInt32Array>(GetColumn(*table, 16));\n+    auto arts = std::static_pointer_cast<arrow::TimestampArray>(GetColumn(*table, 17));\n+    auto arival = std::static_pointer_cast<arrow::DurationArray>(GetColumn(*table, 18));\n+\n+    auto arjd = std::static_pointer_cast<arrow::BinaryArray>(GetColumn(*table, 19));\n+    //auto ardec = std::static_pointer_cast<arrow::Decimal128Array>(GetColumn(*table, 19));\n+\n+    for (int64_t i = 0; i < table->num_rows(); ++i) {\n+        //ui64 dec[2];\n+        //memcpy(dec, ardec->Value(i), 16);\n+        TDataRow r{ arbool->Value(i),\n+            ari8->Value(i), ari16->Value(i), ari32->Value(i), ari64->Value(i),\n+            aru8->Value(i), aru16->Value(i), aru32->Value(i), aru64->Value(i),\n+            arf32->Value(i), arf64->Value(i),\n+            arstr->GetString(i), arutf->GetString(i), arj->GetString(i), ary->GetString(i),\n+            ard->Value(i), ardt->Value(i), arts->Value(i), arival->Value(i), arjd->GetString(i)\n+            //{dec[0], dec[1]}\n+        };\n+        rows.emplace_back(std::move(r));\n+    }\n+\n+    return rows;\n+}\n+\n+class TDataRowTableBuilder\n+{\n+public:\n+    TDataRowTableBuilder()\n+        : Bts(arrow::timestamp(arrow::TimeUnit::TimeUnit::MICRO), arrow::default_memory_pool())\n+        , Bival(arrow::duration(arrow::TimeUnit::TimeUnit::MICRO), arrow::default_memory_pool())\n+        //, Bdec(arrow::decimal(NScheme::DECIMAL_PRECISION, NScheme::DECIMAL_SCALE), arrow::default_memory_pool())\n+    {}\n+\n+    void AddRow(const TDataRow& row) {\n+        UNIT_ASSERT(Bbool.Append(row.Bool).ok());\n+        UNIT_ASSERT(Bi8.Append(row.Int8).ok());\n+        UNIT_ASSERT(Bi16.Append(row.Int16).ok());\n+        UNIT_ASSERT(Bi32.Append(row.Int32).ok());\n+        UNIT_ASSERT(Bi64.Append(row.Int64).ok());\n+        UNIT_ASSERT(Bu8.Append(row.UInt8).ok());\n+        UNIT_ASSERT(Bu16.Append(row.UInt16).ok());\n+        UNIT_ASSERT(Bu32.Append(row.UInt32).ok());\n+        UNIT_ASSERT(Bu64.Append(row.UInt64).ok());\n+        UNIT_ASSERT(Bf32.Append(row.Float32).ok());\n+        UNIT_ASSERT(Bf64.Append(row.Float64).ok());\n+\n+        UNIT_ASSERT(Bstr.Append(row.String).ok());\n+        UNIT_ASSERT(Butf.Append(row.Utf8).ok());\n+        UNIT_ASSERT(Bj.Append(row.Json).ok());\n+        UNIT_ASSERT(By.Append(row.Yson).ok());\n+\n+        UNIT_ASSERT(Bd.Append(row.Date).ok());\n+        UNIT_ASSERT(Bdt.Append(row.Datetime).ok());\n+        UNIT_ASSERT(Bts.Append(row.Timestamp).ok());\n+        UNIT_ASSERT(Bival.Append(row.Interval).ok());\n+\n+        UNIT_ASSERT(Bjd.Append(row.JsonDocument).ok());\n+        //UNIT_ASSERT(Bdec.Append((const char *)&row.Decimal).ok());\n+    }\n+\n+    std::shared_ptr<arrow::Table> Finish() {\n+        std::shared_ptr<arrow::BooleanArray> arbool;\n+        std::shared_ptr<arrow::Int8Array> ari8;\n+        std::shared_ptr<arrow::Int16Array> ari16;\n+        std::shared_ptr<arrow::Int32Array> ari32;\n+        std::shared_ptr<arrow::Int64Array> ari64;\n+        std::shared_ptr<arrow::UInt8Array> aru8;\n+        std::shared_ptr<arrow::UInt16Array> aru16;\n+        std::shared_ptr<arrow::UInt32Array> aru32;\n+        std::shared_ptr<arrow::UInt64Array> aru64;\n+        std::shared_ptr<arrow::FloatArray> arf32;\n+        std::shared_ptr<arrow::DoubleArray> arf64;\n+\n+        std::shared_ptr<arrow::BinaryArray> arstr;\n+        std::shared_ptr<arrow::StringArray> arutf;\n+        std::shared_ptr<arrow::BinaryArray> arj;\n+        std::shared_ptr<arrow::BinaryArray> ary;\n+\n+        std::shared_ptr<arrow::UInt16Array> ard;\n+        std::shared_ptr<arrow::UInt32Array> ardt;\n+        std::shared_ptr<arrow::TimestampArray> arts;\n+        std::shared_ptr<arrow::DurationArray> arival;\n+\n+        std::shared_ptr<arrow::BinaryArray> arjd;\n+        //std::shared_ptr<arrow::Decimal128Array> ardec;\n+\n+        UNIT_ASSERT(Bbool.Finish(&arbool).ok());\n+        UNIT_ASSERT(Bi8.Finish(&ari8).ok());\n+        UNIT_ASSERT(Bi16.Finish(&ari16).ok());\n+        UNIT_ASSERT(Bi32.Finish(&ari32).ok());\n+        UNIT_ASSERT(Bi64.Finish(&ari64).ok());\n+        UNIT_ASSERT(Bu8.Finish(&aru8).ok());\n+        UNIT_ASSERT(Bu16.Finish(&aru16).ok());\n+        UNIT_ASSERT(Bu32.Finish(&aru32).ok());\n+        UNIT_ASSERT(Bu64.Finish(&aru64).ok());\n+        UNIT_ASSERT(Bf32.Finish(&arf32).ok());\n+        UNIT_ASSERT(Bf64.Finish(&arf64).ok());\n+\n+        UNIT_ASSERT(Bstr.Finish(&arstr).ok());\n+        UNIT_ASSERT(Butf.Finish(&arutf).ok());\n+        UNIT_ASSERT(Bj.Finish(&arj).ok());\n+        UNIT_ASSERT(By.Finish(&ary).ok());\n+\n+        UNIT_ASSERT(Bd.Finish(&ard).ok());\n+        UNIT_ASSERT(Bdt.Finish(&ardt).ok());\n+        UNIT_ASSERT(Bts.Finish(&arts).ok());\n+        UNIT_ASSERT(Bival.Finish(&arival).ok());\n+\n+        UNIT_ASSERT(Bjd.Finish(&arjd).ok());\n+        //UNIT_ASSERT(Bdec.Finish(&ardec).ok());\n+\n+        std::shared_ptr<arrow::Schema> schema = TDataRow::MakeArrowSchema();\n+        return arrow::Table::Make(schema, {\n+            arbool,\n+            ari8, ari16, ari32, ari64,\n+            aru8, aru16, aru32, aru64,\n+            arf32, arf64,\n+            arstr, arutf, arj, ary,\n+            ard, ardt, arts, arival, arjd\n+            //ardec\n+        });\n+    }\n+\n+    static std::shared_ptr<arrow::Table> Build(const std::vector<struct TDataRow>& rows) {\n+        TDataRowTableBuilder builder;\n+        for (const TDataRow& row : rows) {\n+            builder.AddRow(row);\n+        }\n+        return builder.Finish();\n+    }\n+\n+private:\n+    arrow::BooleanBuilder Bbool;\n+    arrow::Int8Builder Bi8;\n+    arrow::Int16Builder Bi16;\n+    arrow::Int32Builder Bi32;\n+    arrow::Int64Builder Bi64;\n+    arrow::UInt8Builder Bu8;\n+    arrow::UInt16Builder Bu16;\n+    arrow::UInt32Builder Bu32;\n+    arrow::UInt64Builder Bu64;\n+    arrow::FloatBuilder Bf32;\n+    arrow::DoubleBuilder Bf64;\n+    arrow::BinaryBuilder Bstr;\n+    arrow::StringBuilder Butf;\n+    arrow::BinaryBuilder Bj;\n+    arrow::BinaryBuilder By;\n+    arrow::UInt16Builder Bd;\n+    arrow::UInt32Builder Bdt;\n+    arrow::TimestampBuilder Bts;\n+    arrow::DurationBuilder Bival;\n+    arrow::BinaryBuilder Bjd;\n+    //arrow::Decimal128Builder Bdec;\n+};\n+\n+std::vector<TDataRow> TestRows() {\n+    std::vector<TDataRow> rows = {\n+        {false, -1, -1, -1, -1, 1, 1, 1, 1, -1.0f, -1.0, \"s1\", \"u1\", \"{\\\"j\\\":1}\", \"{y:1}\", 0, 0, 0, 0, \"{\\\"jd\\\":1}\" },\n+        {false, 2, 2, 2, 2, 2, 2, 2, 2, 2.0f, 2.0, \"s2\", \"u2\", \"{\\\"j\\\":2}\", \"{y:2}\", 0, 0, 0, 0, \"{\\\"jd\\\":1}\" },\n+        {false, -3, -3, -3, -3, 3, 3, 3, 3, -3.0f, -3.0, \"s3\", \"u3\", \"{\\\"j\\\":3}\", \"{y:3}\", 0, 0, 0, 0, \"{\\\"jd\\\":1}\" },\n+        {false, -4, -4, -4, -4, 4, 4, 4, 4, 4.0f, 4.0, \"s4\", \"u4\", \"{\\\"j\\\":4}\", \"{y:4}\", 0, 0, 0, 0, \"{\\\"jd\\\":1}\" },\n+    };\n+    return rows;\n+}\n+\n+}\n+\n+Y_UNIT_TEST_SUITE(ArrowTest) {\n+    Y_UNIT_TEST(Basic) {\n+        std::vector<TDataRow> rows = TestRows();\n+\n+        std::shared_ptr<arrow::Table> table = TDataRowTableBuilder::Build(rows);\n+\n+        auto expectedSchema = TDataRow::MakeArrowSchema();\n+        UNIT_ASSERT_EQUAL(expectedSchema->Equals(*table->schema()), true);\n+\n+        std::vector<TDataRow> readRows = ToVector(table);\n+\n+        UNIT_ASSERT_EQUAL(rows.size(), readRows.size());\n+        for (size_t i = 0; i < rows.size(); ++i) {\n+            UNIT_ASSERT_EQUAL(rows[i], readRows[i]);\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/ydb/core/formats/arrow/ut/ut_size_calcer.cpp b/ydb/library/formats/arrow/ut/ut_size_calcer.cpp\nsimilarity index 91%\nrename from ydb/core/formats/arrow/ut/ut_size_calcer.cpp\nrename to ydb/library/formats/arrow/ut/ut_size_calcer.cpp\nindex 1db712f43c7a..be569d2d6bf3 100644\n--- a/ydb/core/formats/arrow/ut/ut_size_calcer.cpp\n+++ b/ydb/library/formats/arrow/ut/ut_size_calcer.cpp\n@@ -1,10 +1,9 @@\n #include <library/cpp/testing/unittest/registar.h>\n-#include <ydb/core/formats/arrow/arrow_helpers.h>\n-#include <ydb/core/formats/arrow/simple_builder/array.h>\n-#include <ydb/core/formats/arrow/simple_builder/batch.h>\n-#include <ydb/core/formats/arrow/simple_builder/filler.h>\n-#include <ydb/core/formats/arrow/size_calcer.h>\n-#include <ydb/core/formats/arrow/dictionary/conversion.h>\n+#include <ydb/library/formats/arrow/arrow_helpers.h>\n+#include <ydb/library/formats/arrow/simple_builder/array.h>\n+#include <ydb/library/formats/arrow/simple_builder/batch.h>\n+#include <ydb/library/formats/arrow/simple_builder/filler.h>\n+#include <ydb/library/formats/arrow/size_calcer.h>\n \n Y_UNIT_TEST_SUITE(SizeCalcer) {\n \ndiff --git a/ydb/library/formats/arrow/ut/ya.make b/ydb/library/formats/arrow/ut/ya.make\nnew file mode 100644\nindex 000000000000..ae8b7e80261f\n--- /dev/null\n+++ b/ydb/library/formats/arrow/ut/ya.make\n@@ -0,0 +1,29 @@\n+UNITTEST_FOR(ydb/library/formats/arrow)\n+\n+SIZE(SMALL)\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/arrow_kernels\n+\n+    # for NYql::NUdf alloc stuff used in binary_json\n+    ydb/library/yql/public/udf/service/exception_policy\n+    ydb/library/yql/sql/pg_dummy\n+)\n+\n+ADDINCL(\n+    ydb/library/arrow_clickhouse\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+CFLAGS(\n+    -Wno-unused-parameter\n+)\n+\n+SRCS(\n+    ut_arrow.cpp\n+    ut_size_calcer.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/formats/arrow/common/validation.cpp b/ydb/library/formats/arrow/validation/validation.cpp\nsimilarity index 100%\nrename from ydb/core/formats/arrow/common/validation.cpp\nrename to ydb/library/formats/arrow/validation/validation.cpp\ndiff --git a/ydb/core/formats/arrow/common/validation.h b/ydb/library/formats/arrow/validation/validation.h\nsimilarity index 100%\nrename from ydb/core/formats/arrow/common/validation.h\nrename to ydb/library/formats/arrow/validation/validation.h\ndiff --git a/ydb/library/formats/arrow/validation/ya.make b/ydb/library/formats/arrow/validation/ya.make\nnew file mode 100644\nindex 000000000000..e060fae10d8e\n--- /dev/null\n+++ b/ydb/library/formats/arrow/validation/ya.make\n@@ -0,0 +1,12 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/actors/core\n+)\n+\n+SRCS(\n+    validation.cpp\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/arrow/ya.make b/ydb/library/formats/arrow/ya.make\nnew file mode 100644\nindex 000000000000..c9b3d255c848\n--- /dev/null\n+++ b/ydb/library/formats/arrow/ya.make\n@@ -0,0 +1,49 @@\n+RECURSE_FOR_TESTS(\n+    ut\n+)\n+\n+LIBRARY()\n+\n+PEERDIR(\n+    contrib/libs/apache/arrow\n+    ydb/library/formats/arrow/accessor\n+    ydb/library/formats/arrow/simple_builder\n+    ydb/library/formats/arrow/transformer\n+    ydb/library/formats/arrow/splitter\n+    ydb/library/formats/arrow/modifier\n+    ydb/library/formats/arrow/scalar\n+    ydb/library/formats/arrow/hash\n+    ydb/library/actors/core\n+    ydb/library/arrow_kernels\n+    ydb/library/binary_json\n+    ydb/library/dynumber\n+    ydb/library/services\n+    ydb/library/yql/core/arrow_kernels/request\n+)\n+\n+IF (OS_WINDOWS)\n+    ADDINCL(\n+        ydb/library/yql/udfs/common/clickhouse/client/base\n+        ydb/library/arrow_clickhouse\n+    )\n+ELSE()\n+    PEERDIR(\n+        ydb/library/arrow_clickhouse\n+    )\n+    ADDINCL(\n+        ydb/library/arrow_clickhouse\n+    )\n+ENDIF()\n+\n+YQL_LAST_ABI_VERSION()\n+\n+SRCS(\n+    arrow_helpers.cpp\n+    input_stream.h\n+    permutations.cpp\n+    replace_key.cpp\n+    size_calcer.cpp\n+    simple_arrays_cache.cpp\n+)\n+\n+END()\ndiff --git a/ydb/library/formats/ya.make b/ydb/library/formats/ya.make\nnew file mode 100644\nindex 000000000000..82dc38d8e6b4\n--- /dev/null\n+++ b/ydb/library/formats/ya.make\n@@ -0,0 +1,9 @@\n+RECURSE(\n+    arrow\n+)\n+\n+LIBRARY()\n+\n+YQL_LAST_ABI_VERSION()\n+\n+END()\ndiff --git a/ydb/library/services/services.proto b/ydb/library/services/services.proto\nindex 3ac7f03bda68..f7a972cfc419 100644\n--- a/ydb/library/services/services.proto\n+++ b/ydb/library/services/services.proto\n@@ -393,6 +393,8 @@ enum EServiceKikimr {\n \n     // Distributed storage debugging\n     BS_REQUEST_COST = 2500;\n+\n+    GROUPED_MEMORY_LIMITER = 2700;\n };\n \n message TActivity {\ndiff --git a/ydb/library/ya.make b/ydb/library/ya.make\nindex 088658d02a7e..dad4d26c22dd 100644\n--- a/ydb/library/ya.make\n+++ b/ydb/library/ya.make\n@@ -11,6 +11,7 @@ RECURSE(\n     chunks_limiter\n     dynumber\n     folder_service\n+    formats\n     grpc\n     http_proxy\n     keys\ndiff --git a/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h b/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h\nindex 4baded583b14..0ef987fb700e 100644\n--- a/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h\n+++ b/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h\n@@ -523,6 +523,10 @@ class TDqComputeActorBase : public NActors::TActorBootstrapped<TDerived>\n         Terminate(success, TIssues({TIssue(message)}));\n     }\n \n+    virtual TMaybe<google::protobuf::Any> ExtraData() {\n+        return Nothing();\n+    }\n+\n     void FillExtraData(NDqProto::TEvComputeActorState& state) {\n         auto* extraData = state.MutableExtraData();\n         for (auto& [index, input] : SourcesMap) {\n@@ -552,6 +556,11 @@ class TDqComputeActorBase : public NActors::TActorBootstrapped<TDerived>\n                 }\n             }\n         }\n+\n+        if (auto data = static_cast<TDerived*>(this)->ExtraData()) {\n+            auto* entry = extraData->MutableComputeExtraData();\n+            entry->MutableData()->CopyFrom(*data);\n+        }\n     }\n \n     void ReportStateAndMaybeDie(NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssues& issues)\ndiff --git a/ydb/library/yql/dq/actors/protos/dq_events.proto b/ydb/library/yql/dq/actors/protos/dq_events.proto\nindex 22d49898ba7b..df08f7414012 100644\n--- a/ydb/library/yql/dq/actors/protos/dq_events.proto\n+++ b/ydb/library/yql/dq/actors/protos/dq_events.proto\n@@ -72,10 +72,15 @@ message TExtraOutputData {\n     optional google.protobuf.Any Data = 2;\n }\n \n+message TExtraComputeData {\n+    optional google.protobuf.Any Data = 1;\n+}\n+\n message TComputeActorExtraData {\n     repeated TExtraInputData SourcesExtraData = 1;\n     repeated TExtraInputData InputTransformsData = 2;\n     repeated TExtraOutputData SinksExtraData = 3;\n+    optional TExtraComputeData ComputeExtraData = 4;\n }\n \n message TEvComputeActorState {\ndiff --git a/ydb/library/yql/sql/v1/node.h b/ydb/library/yql/sql/v1/node.h\nindex d0606f571e04..4f6ec8591397 100644\n--- a/ydb/library/yql/sql/v1/node.h\n+++ b/ydb/library/yql/sql/v1/node.h\n@@ -1112,6 +1112,7 @@ namespace NSQLTranslationV1 {\n         TMaybe<TIdentifier> AutoPartitioningByLoad;\n         TNodePtr MinPartitions;\n         TNodePtr MaxPartitions;\n+        TNodePtr PartitionCount;\n         TNodePtr UniformPartitions;\n         TVector<TVector<TNodePtr>> PartitionAtKeys;\n         TMaybe<TIdentifier> KeyBloomFilter;\ndiff --git a/ydb/library/yql/sql/v1/query.cpp b/ydb/library/yql/sql/v1/query.cpp\nindex ebfaf98c1c3c..d806b83d196a 100644\n--- a/ydb/library/yql/sql/v1/query.cpp\n+++ b/ydb/library/yql/sql/v1/query.cpp\n@@ -222,6 +222,10 @@ static INode::TPtr CreateTableSettings(const TTableSettings& tableSettings, ETab\n     if (tableSettings.MaxPartitions) {\n         settings = L(settings, Q(Y(Q(\"maxPartitions\"), tableSettings.MaxPartitions)));\n     }\n+    if (tableSettings.PartitionCount) {\n+        settings = L(settings, Q(Y(Q(\"maxPartitions\"), tableSettings.PartitionCount)));\n+        settings = L(settings, Q(Y(Q(\"minPartitions\"), tableSettings.PartitionCount)));\n+    }\n     if (tableSettings.KeyBloomFilter) {\n         const auto& ref = tableSettings.KeyBloomFilter.GetRef();\n         settings = L(settings, Q(Y(Q(\"keyBloomFilter\"), BuildQuotedAtom(ref.Pos, ref.Name))));\ndiff --git a/ydb/library/yql/sql/v1/sql_translation.cpp b/ydb/library/yql/sql/v1/sql_translation.cpp\nindex e06f5521d428..cf1463efabac 100644\n--- a/ydb/library/yql/sql/v1/sql_translation.cpp\n+++ b/ydb/library/yql/sql/v1/sql_translation.cpp\n@@ -1892,6 +1892,17 @@ bool TSqlTranslation::StoreExternalTableSettingsEntry(const TIdentifier& id, con\n     return true;\n }\n \n+bool TSqlTranslation::ValidateTableSettings(const TTableSettings& settings) {\n+    if (settings.PartitionCount) {\n+        if (!settings.StoreType || to_lower(settings.StoreType->Name) != \"column\") {\n+            Ctx.Error() << \" PARTITION_COUNT can be used only with STORE=COLUMN\";\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool TSqlTranslation::StoreTableSettingsEntry(const TIdentifier& id, const TRule_table_setting_value* value,\n         TTableSettings& settings, bool alter, bool reset) {\n     YQL_ENSURE(value || reset);\n@@ -1950,6 +1961,16 @@ bool TSqlTranslation::StoreTableSettingsEntry(const TIdentifier& id, const TRule\n             Ctx.Error() << to_upper(id.Name) << \" value should be an integer\";\n             return false;\n         }\n+    } else if (to_lower(id.Name) == \"partition_count\") {\n+        if (reset) {\n+            Ctx.Error() << to_upper(id.Name) << \" reset is not supported\";\n+            return false;\n+        }\n+\n+        if (!StoreInt(*value, settings.PartitionCount, Ctx)) {\n+            Ctx.Error() << to_upper(id.Name) << \" value should be an integer\";\n+            return false;\n+        }\n     } else if (to_lower(id.Name) == \"uniform_partitions\") {\n         if (alter) {\n             Ctx.Error() << to_upper(id.Name) << \" alter is not supported\";\n@@ -2040,7 +2061,8 @@ bool TSqlTranslation::StoreTableSettingsEntry(const TIdentifier& id, const TRule\n         Ctx.Error() << \"Unknown table setting: \" << id.Name;\n         return false;\n     }\n-    return true;\n+\n+    return ValidateTableSettings(settings);\n }\n \n bool TSqlTranslation::StoreTableSettingsEntry(const TIdentifier& id, const TRule_table_setting_value& value,\ndiff --git a/ydb/library/yql/sql/v1/sql_translation.h b/ydb/library/yql/sql/v1/sql_translation.h\nindex 09e634511aa9..b614f1dbb2c6 100644\n--- a/ydb/library/yql/sql/v1/sql_translation.h\n+++ b/ydb/library/yql/sql/v1/sql_translation.h\n@@ -254,6 +254,8 @@ class TSqlTranslation: public TTranslation {\n \n     bool ClusterExpr(const TRule_cluster_expr& node, bool allowWildcard, bool allowBinding, TString& service, TDeferredAtom& cluster, bool& isBinding);\n     bool StructLiteralItem(TVector<TNodePtr>& labels, const TRule_expr& label, TVector<TNodePtr>& values, const TRule_expr& value);\n+    bool ValidateTableSettings(const TTableSettings& settings);\n+\n protected:\n     NSQLTranslation::ESqlMode Mode;\n };\ndiff --git a/ydb/library/yql/sql/v1/sql_ut.cpp b/ydb/library/yql/sql/v1/sql_ut.cpp\nindex 90dae8d2ea58..48135879988d 100644\n--- a/ydb/library/yql/sql/v1/sql_ut.cpp\n+++ b/ydb/library/yql/sql/v1/sql_ut.cpp\n@@ -6917,3 +6917,28 @@ Y_UNIT_TEST_SUITE(ResourcePool) {\n         UNIT_ASSERT_VALUES_EQUAL(1, elementStat[\"Write\"]);\n     }\n }\n+\n+Y_UNIT_TEST_SUITE(OlapPartitionCount) {\n+    Y_UNIT_TEST(CorrectUsage) {\n+        NYql::TAstParseResult res = SqlToYql(R\"sql(\n+            USE plato;\n+            CREATE TABLE `mytable` (id Uint32, PRIMARY KEY (id))\n+            PARTITION BY HASH(id)\n+            WITH (STORE = COLUMN, PARTITION_COUNT = 8);\n+        )sql\");\n+\n+        UNIT_ASSERT_C(res.IsOk(), res.Issues.ToString());\n+    }\n+\n+    Y_UNIT_TEST(UseWithoutColumnStore) {\n+        NYql::TAstParseResult res = SqlToYql(R\"sql(\n+            USE plato;\n+            CREATE TABLE `mytable` (id Uint32, PRIMARY KEY (id))\n+            WITH (PARTITION_COUNT = 8);\n+        )sql\");\n+\n+        UNIT_ASSERT(!res.IsOk());\n+        UNIT_ASSERT(res.Issues.Size() == 1);\n+        UNIT_ASSERT_STRING_CONTAINS(res.Issues.ToString(), \"PARTITION_COUNT can be used only with STORE=COLUMN\");\n+    }\n+}\ndiff --git a/ydb/services/ext_index/ut/ut_ext_index.cpp b/ydb/services/ext_index/ut/ut_ext_index.cpp\nindex bede1b70619b..ec67f99c8478 100644\n--- a/ydb/services/ext_index/ut/ut_ext_index.cpp\n+++ b/ydb/services/ext_index/ut/ut_ext_index.cpp\n@@ -7,7 +7,7 @@\n #include <ydb/core/wrappers/ut_helpers/s3_mock.h>\n #include <ydb/core/wrappers/s3_wrapper.h>\n #include <ydb/core/wrappers/fake_storage.h>\n-#include <ydb/core/formats/arrow/hash/xx_hash.h>\n+#include <ydb/library/formats/arrow/hash/xx_hash.h>\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/public/sdk/cpp/client/ydb_table/table.h>\n #include <ydb/services/metadata/manager/alter.h>\ndiff --git a/ydb/tools/cfg/static.py b/ydb/tools/cfg/static.py\nindex 345701921e90..f310546477f2 100644\n--- a/ydb/tools/cfg/static.py\n+++ b/ydb/tools/cfg/static.py\n@@ -275,6 +275,10 @@ def mbus_enabled(self):\n     def table_service_config(self):\n         return self.__cluster_details.get_service(\"table_service_config\")\n \n+    @property\n+    def column_shard_config(self):\n+        return self.__cluster_details.get_service(\"column_shard_config\")\n+\n     @property\n     def hive_config(self):\n         return self.__proto_config(\"hive\", config_pb2.THiveConfig, self.__cluster_details.get_service(\"hive_config\"))\n@@ -386,6 +390,9 @@ def get_normalized_config(self):\n         if self.table_service_config:\n             normalized_config[\"table_service_config\"] = self.table_service_config\n \n+        if self.column_shard_config:\n+            normalized_config[\"column_shard_config\"] = self.column_shard_config\n+\n         if self.__cluster_details.blob_storage_config is not None:\n             normalized_config[\"blob_storage_config\"] = self.__cluster_details.blob_storage_config\n         else:\ndiff --git a/ydb/tools/olap_workload/__main__.py b/ydb/tools/olap_workload/__main__.py\nnew file mode 100644\nindex 000000000000..02ee03f4f231\n--- /dev/null\n+++ b/ydb/tools/olap_workload/__main__.py\n@@ -0,0 +1,199 @@\n+# -*- coding: utf-8 -*-\n+import argparse\n+import ydb\n+import time\n+import os\n+import random\n+import string\n+\n+ydb.interceptor.monkey_patch_event_handler()\n+\n+\n+def timestamp():\n+    return int(1000 * time.time())\n+\n+\n+def table_name_with_timestamp():\n+    return os.path.join(\"column_table_\" + str(timestamp()))\n+\n+\n+def random_string(length):\n+    letters = string.ascii_lowercase\n+    return bytes(''.join(random.choice(letters) for i in range(length)), encoding='utf8')\n+\n+\n+def random_type():\n+    return random.choice([ydb.PrimitiveType.Int64, ydb.PrimitiveType.String])\n+\n+\n+def random_value(type):\n+    if isinstance(type, ydb.OptionalType):\n+        return random_value(type.item)\n+    if type == ydb.PrimitiveType.Int64:\n+        return random.randint(0, 1 << 31)\n+    if type == ydb.PrimitiveType.String:\n+        return random_string(random.randint(1, 32))\n+\n+\n+class Workload(object):\n+    def __init__(self, endpoint, database, duration, batch_size):\n+        self.database = database\n+        self.driver = ydb.Driver(ydb.DriverConfig(endpoint, database))\n+        self.pool = ydb.SessionPool(self.driver, size=200)\n+        self.duration = duration\n+        self.batch_size = batch_size\n+\n+    def __enter__(self):\n+        return self\n+\n+    def __exit__(self, exc_type, exc_val, exc_tb):\n+        self.pool.stop()\n+        self.driver.stop()\n+\n+    def run_query_ignore_errors(self, callee):\n+        try:\n+            self.pool.retry_operation_sync(callee)\n+        except Exception as e:\n+            print(type(e), e)\n+\n+    def create_table(self, table_name):\n+        print(f\"Create table {table_name}\")\n+\n+        def callee(session):\n+            session.execute_scheme(\n+                f\"\"\"\n+                CREATE TABLE {table_name} (\n+                id Int64 NOT NULL,\n+                i64Val Int64,\n+                PRIMARY KEY(id)\n+                )\n+                PARTITION BY HASH(id)\n+                WITH (\n+                    STORE = COLUMN\n+                )\n+            \"\"\"\n+            )\n+\n+        self.run_query_ignore_errors(callee)\n+\n+    def drop_table(self, table_name):\n+        print(f\"Drop table {table_name}\")\n+\n+        def callee(session):\n+            session.drop_table(self.database + \"/\" + table_name)\n+\n+        self.run_query_ignore_errors(callee)\n+\n+    def add_column(self, table_name, col_name, col_type):\n+        print(f\"Add column {table_name}.{col_name} {str(col_type)}\")\n+\n+        def callee(session):\n+            session.execute_scheme(f\"ALTER TABLE {table_name} ADD COLUMN {col_name} {str(col_type)}\")\n+\n+        self.run_query_ignore_errors(callee)\n+\n+    def drop_column(self, table_name, col_name):\n+        print(f\"Drop column {table_name}.{col_name}\")\n+\n+        def callee(session):\n+            session.execute_scheme(f\"ALTER TABLE {table_name} DROP COLUMN {col_name}\")\n+\n+        self.run_query_ignore_errors(callee)\n+\n+    def generate_batch(self, schema):\n+        data = []\n+\n+        for i in range(self.batch_size):\n+            data.append({c.name: random_value(c.type) for c in schema})\n+\n+        return data\n+\n+    def add_batch(self, table_name, schema):\n+        print(f\"Add batch {table_name}\")\n+\n+        column_types = ydb.BulkUpsertColumns()\n+\n+        for c in schema:\n+            column_types.add_column(c.name, c.type)\n+\n+        batch = self.generate_batch(schema)\n+\n+        self.driver.table_client.bulk_upsert(self.database + \"/\" + table_name, batch, column_types)\n+\n+    def list_tables(self):\n+        db = self.driver.scheme_client.list_directory(self.database)\n+        return [t.name for t in db.children if t.type == ydb.SchemeEntryType.COLUMN_TABLE]\n+\n+    def list_columns(self, table_name):\n+        path = self.database + \"/\" + table_name\n+\n+        def callee(session):\n+            return session.describe_table(path).columns\n+\n+        return self.pool.retry_operation_sync(callee)\n+\n+    def rows_count(self, table_name):\n+        return self.driver.table_client.scan_query(f\"SELECT count(*) FROM {table_name}\").next().result_set.rows[0][0]\n+\n+    def select_n(self, table_name, limit):\n+        print(f\"Select {limit} from {table_name}\")\n+        self.driver.table_client.scan_query(f\"SELECT * FROM {table_name} limit {limit}\").next()\n+\n+    def drop_all_tables(self):\n+        for t in self.list_tables():\n+            if t.startswith(\"column_table_\"):\n+                self.drop_table(t)\n+\n+    def drop_all_columns(self, table_name):\n+        for c in self.list_columns(table_name):\n+            if c.name != \"id\":\n+                self.drop_column(table_name, c.name)\n+\n+    def queries_while_alter(self):\n+        table_name = \"queries_while_alter\"\n+\n+        schema = self.list_columns(table_name)\n+\n+        self.select_n(table_name, 1000)\n+        self.add_batch(table_name, schema)\n+        self.select_n(table_name, 100)\n+        self.add_batch(table_name, schema)\n+        self.select_n(table_name, 300)\n+\n+        if len(schema) > 50:\n+            self.drop_all_columns(table_name)\n+\n+        if self.rows_count(table_name) > 100000:\n+            self.drop_table(table_name)\n+\n+        col = \"col_\" + str(timestamp())\n+        self.add_column(table_name, col, random_type())\n+\n+    def run(self):\n+        started_at = time.time()\n+\n+        while time.time() - started_at < self.duration:\n+            try:\n+                self.create_table(\"queries_while_alter\")\n+\n+                self.drop_all_tables()\n+\n+                self.queries_while_alter()\n+\n+                table_name = table_name_with_timestamp()\n+                self.create_table(table_name)\n+            except Exception as e:\n+                print(type(e), e)\n+\n+\n+if __name__ == '__main__':\n+    parser = argparse.ArgumentParser(\n+        description=\"olap stability workload\", formatter_class=argparse.RawDescriptionHelpFormatter\n+    )\n+    parser.add_argument('--endpoint', default='localhost:2135', help=\"An endpoint to be used\")\n+    parser.add_argument('--database', default=None, required=True, help='A database to connect')\n+    parser.add_argument('--duration', default=120, type=lambda x: int(x), help='A duration of workload in seconds.')\n+    parser.add_argument('--batch_size', default=1000, help='Batch size for bulk insert')\n+    args = parser.parse_args()\n+    with Workload(args.endpoint, args.database, args.duration, args.batch_size) as workload:\n+        workload.run()\ndiff --git a/ydb/tools/olap_workload/ya.make b/ydb/tools/olap_workload/ya.make\nnew file mode 100644\nindex 000000000000..939ecf1af94b\n--- /dev/null\n+++ b/ydb/tools/olap_workload/ya.make\n@@ -0,0 +1,12 @@\n+PY3_PROGRAM(olap_workload)\n+\n+PY_SRCS(\n+    __main__.py\n+)\n+\n+PEERDIR(\n+    ydb/public/sdk/python\n+    library/python/monlib\n+)\n+\n+END()\ndiff --git a/ydb/tools/ya.make b/ydb/tools/ya.make\nindex fc5e094eb2d9..375abee36446 100644\n--- a/ydb/tools/ya.make\n+++ b/ydb/tools/ya.make\n@@ -4,6 +4,7 @@ RECURSE(\n     query_replay\n     query_replay_yt\n     simple_queue\n+    olap_workload\n     tsserver\n     tstool\n     ydbd_slice\n",
  "test_patch": "diff --git a/ydb/core/testlib/basics/feature_flags.h b/ydb/core/testlib/basics/feature_flags.h\nindex 333cc96d597e..04395a54f3fd 100644\n--- a/ydb/core/testlib/basics/feature_flags.h\n+++ b/ydb/core/testlib/basics/feature_flags.h\n@@ -9,13 +9,13 @@ class TTestFeatureFlagsHolder {\n public:\n     TFeatureFlags FeatureFlags;\n \n-    #define FEATURE_FLAG_SETTER(name) \\\n-        TDerived& Set##name(std::optional<bool> value) { \\\n-            if (value) { \\\n-                FeatureFlags.Set##name(*value); \\\n-            } \\\n-            return *static_cast<TDerived*>(this); \\\n-        }\n+#define FEATURE_FLAG_SETTER(name)                    \\\n+    TDerived& Set##name(std::optional<bool> value) { \\\n+        if (value) {                                 \\\n+            FeatureFlags.Set##name(*value);          \\\n+        }                                            \\\n+        return *static_cast<TDerived*>(this);        \\\n+    }\n \n     FEATURE_FLAG_SETTER(AllowYdbRequestsWithoutDatabase)\n     FEATURE_FLAG_SETTER(EnableSystemViews)\n@@ -63,9 +63,10 @@ class TTestFeatureFlagsHolder {\n     FEATURE_FLAG_SETTER(EnableResourcePools)\n     FEATURE_FLAG_SETTER(EnableChangefeedsOnIndexTables)\n     FEATURE_FLAG_SETTER(EnablePgSyntax)\n-    FEATURE_FLAG_SETTER(EnableMetadataObjectsOnServerless)\n+    FEATURE_FLAG_SETTER(EnableTieringInColumnShard)\n+    FEATURE_FLAG_SETTER(EnableOlapCompression)\n \n-    #undef FEATURE_FLAG_SETTER\n+#undef FEATURE_FLAG_SETTER\n };\n \n-} // NKikimr\n+}   // namespace NKikimr\ndiff --git a/ydb/core/testlib/cs_helper.cpp b/ydb/core/testlib/cs_helper.cpp\nindex c6f05ec8c86f..dd26da35fa74 100644\n--- a/ydb/core/testlib/cs_helper.cpp\n+++ b/ydb/core/testlib/cs_helper.cpp\n@@ -183,7 +183,7 @@ std::shared_ptr<arrow::RecordBatch> THelper::TestArrowBatch(ui64 pathIdBegin, ui\n TString THelper::GetTestTableSchema() const {\n     TStringBuilder sb;\n     sb << R\"(Columns{ Name: \"timestamp\" Type : \"Timestamp\" NotNull : true })\";\n-    sb << R\"(Columns{ Name: \"resource_id\" Type : \"Utf8\" })\";\n+    sb << R\"(Columns{ Name: \"resource_id\" Type : \"Utf8\" DataAccessorConstructor{ ClassName: \"SPARSED\" } })\";\n     sb << \"Columns{ Name: \\\"uid\\\" Type : \\\"Utf8\\\" NotNull : true StorageId : \\\"\" + OptionalStorageId + \"\\\" }\";\n     sb << R\"(Columns{ Name: \"level\" Type : \"Int32\" })\";\n     sb << \"Columns{ Name: \\\"message\\\" Type : \\\"Utf8\\\" StorageId : \\\"\" + OptionalStorageId + \"\\\" }\";\n@@ -198,7 +198,7 @@ TString THelper::GetTestTableSchema() const {\n     return sb;\n }\n \n-void THelper::CreateOlapTableWithStore(TString tableName /*= \"olapTable\"*/, TString storeName /*= \"olapStore\"*/, ui32 storeShardsCount /*= 4*/, ui32 tableShardsCount /*= 3*/) {\n+void THelper::CreateSchemaOlapTablesWithStore(const TString tableSchema, TVector<TString> tableNames /*= \"olapTable\"*/, TString storeName /*= \"olapStore\"*/, ui32 storeShardsCount /*= 4*/, ui32 tableShardsCount /*= 3*/) {\n     TActorId sender = Server.GetRuntime()->AllocateEdgeActor();\n     CreateTestOlapStore(sender, Sprintf(R\"(\n             Name: \"%s\"\n@@ -209,19 +209,25 @@ void THelper::CreateOlapTableWithStore(TString tableName /*= \"olapTable\"*/, TStr\n                     %s\n                 }\n             }\n-        )\", storeName.c_str(), storeShardsCount, GetTestTableSchema().data()));\n+        )\", storeName.c_str(), storeShardsCount, tableSchema.data()));\n \n     const TString shardingColumns = \"[\\\"\" + JoinSeq(\"\\\",\\\"\", GetShardingColumns()) + \"\\\"]\";\n \n-    TBase::CreateTestOlapTable(sender, storeName, Sprintf(R\"(\n-        Name: \"%s\"\n-        ColumnShardCount: %d\n-        Sharding {\n-            HashSharding {\n-                Function: %s\n-                Columns: %s\n-            }\n-        })\", tableName.c_str(), tableShardsCount, ShardingMethod.data(), shardingColumns.c_str()));\n+    for (const TString& tableName : tableNames) {\n+        TBase::CreateTestOlapTable(sender, storeName, Sprintf(R\"(\n+            Name: \"%s\"\n+            ColumnShardCount: %d\n+            Sharding {\n+                HashSharding {\n+                    Function: %s\n+                    Columns: %s\n+                }\n+            })\", tableName.c_str(), tableShardsCount, ShardingMethod.data(), shardingColumns.c_str()));\n+    }\n+}\n+\n+void THelper::CreateOlapTablesWithStore(TVector<TString> tableNames /*= {\"olapTable\"}*/, TString storeName /*= \"olapStore\"*/, ui32 storeShardsCount /*= 4*/, ui32 tableShardsCount /*= 3*/) {\n+        CreateSchemaOlapTablesWithStore(GetTestTableSchema(), tableNames, storeName, storeShardsCount, tableShardsCount);\n }\n \n // Clickbench table\ndiff --git a/ydb/core/testlib/cs_helper.h b/ydb/core/testlib/cs_helper.h\nindex 7a9e3dad1bf3..95c8877b6ba6 100644\n--- a/ydb/core/testlib/cs_helper.h\n+++ b/ydb/core/testlib/cs_helper.h\n@@ -27,11 +27,16 @@ class THelper: public THelperSchemaless {\n     std::shared_ptr<arrow::Schema> GetArrowSchema() const;\n     YDB_FLAG_ACCESSOR(WithJsonDocument, false);\n     YDB_ACCESSOR(TString, OptionalStorageId, \"__MEMORY\");\n+protected:\n     TString ShardingMethod = \"HASH_FUNCTION_CONSISTENCY_64\";\n+private:\n     bool WithSomeNulls_ = false;\n protected:\n-    void CreateOlapTableWithStore(TString tableName = \"olapTable\", TString storeName = \"olapStore\",\n+    void CreateSchemaOlapTablesWithStore(const TString tableSchema, TVector<TString> tableName = {\"olapTable\"}, TString storeName = \"olapStore\",\n+        ui32 storeShardsCount = 4, ui32 tableShardsCount = 3);\n+    void CreateOlapTablesWithStore(TVector<TString> tableName = {\"olapTable\"}, TString storeName = \"olapStore\",\n         ui32 storeShardsCount = 4, ui32 tableShardsCount = 3);\n+\n public:\n     using TBase::TBase;\n \n@@ -43,9 +48,9 @@ class THelper: public THelperSchemaless {\n \n     static constexpr const char * PROTO_SCHEMA = R\"(\n         Columns { Name: \"timestamp\" Type: \"Timestamp\" NotNull: true }\n-        Columns { Name: \"resource_id\" Type: \"Utf8\" }\n+        Columns { Name: \"resource_id\" Type: \"Utf8\" DataAccessorConstructor{ ClassName: \"SPARSED\" }}\n         Columns { Name: \"uid\" Type: \"Utf8\" }\n-        Columns { Name: \"level\" Type: \"Int32\" }\n+        Columns { Name: \"level\" Type: \"Int32\" DataAccessorConstructor{ ClassName: \"SPARSED\" }}\n         Columns { Name: \"message\" Type: \"Utf8\" }\n         KeyColumnNames: \"timestamp\"\n         Engine: COLUMN_ENGINE_REPLACING_TIMESERIES\ndiff --git a/ydb/core/testlib/test_client.cpp b/ydb/core/testlib/test_client.cpp\nindex 8c8d35d0228e..7c25835169a3 100644\n--- a/ydb/core/testlib/test_client.cpp\n+++ b/ydb/core/testlib/test_client.cpp\n@@ -113,6 +113,7 @@\n #include <ydb/services/ext_index/service/executor.h>\n #include <ydb/core/tx/conveyor/service/service.h>\n #include <ydb/core/tx/conveyor/usage/service.h>\n+#include <ydb/core/tx/limiter/grouped_memory/usage/service.h>\n #include <ydb/library/folder_service/mock/mock_folder_service_adapter.h>\n \n #include <ydb/core/client/server/ic_nodes_cache_service.h>\n@@ -762,6 +763,11 @@ namespace Tests {\n             const auto aid = Runtime->Register(actor, nodeIdx, appData.SystemPoolId, TMailboxType::Revolving, 0);\n             Runtime->RegisterService(NCSIndex::MakeServiceId(Runtime->GetNodeId(nodeIdx)), aid, nodeIdx);\n         }\n+        {\n+            auto* actor = NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::CreateService(NOlap::NGroupedMemoryManager::TConfig(), new ::NMonitoring::TDynamicCounters());\n+            const auto aid = Runtime->Register(actor, nodeIdx, appData.UserPoolId, TMailboxType::Revolving, 0);\n+            Runtime->RegisterService(NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::MakeServiceId(Runtime->GetNodeId(nodeIdx)), aid, nodeIdx);\n+        }\n         {\n             auto* actor = NConveyor::TScanServiceOperator::CreateService(NConveyor::TConfig(), new ::NMonitoring::TDynamicCounters());\n             const auto aid = Runtime->Register(actor, nodeIdx, appData.UserPoolId, TMailboxType::Revolving, 0);\ndiff --git a/ydb/core/testlib/ya.make b/ydb/core/testlib/ya.make\nindex 58502dca6227..5a63f36a639f 100644\n--- a/ydb/core/testlib/ya.make\n+++ b/ydb/core/testlib/ya.make\n@@ -102,6 +102,7 @@ PEERDIR(\n     ydb/services/ext_index/service\n     ydb/services/ymq\n     ydb/core/tx/conveyor/service\n+    ydb/core/tx/limiter/grouped_memory/usage\n     ydb/services/fq\n     ydb/services/kesus\n     ydb/services/persqueue_cluster_discovery\ndiff --git a/ydb/core/tx/columnshard/common/tests/shard_reader.cpp b/ydb/core/tx/columnshard/common/tests/shard_reader.cpp\ndeleted file mode 100644\nindex 2789a63e38a8..000000000000\n--- a/ydb/core/tx/columnshard/common/tests/shard_reader.cpp\n+++ /dev/null\n@@ -1,4 +0,0 @@\n-#include \"shard_reader.h\"\n-\n-namespace NKikimr::NOlap::NTests {\n-}\ndiff --git a/ydb/core/tx/columnshard/common/tests/ya.make b/ydb/core/tx/columnshard/common/tests/ya.make\ndeleted file mode 100644\nindex 8b3c3809006b..000000000000\n--- a/ydb/core/tx/columnshard/common/tests/ya.make\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-LIBRARY()\n-\n-SRCS(\n-    shard_reader.cpp\n-)\n-\n-PEERDIR(\n-    ydb/core/formats/arrow/protos\n-    contrib/libs/apache/arrow\n-    ydb/core/formats/arrow\n-    ydb/core/kqp/compute_actor\n-)\n-\n-END()\ndiff --git a/ydb/core/tx/columnshard/hooks/testing/controller.h b/ydb/core/tx/columnshard/hooks/testing/controller.h\nindex bb011d168de4..a8e259877fd0 100644\n--- a/ydb/core/tx/columnshard/hooks/testing/controller.h\n+++ b/ydb/core/tx/columnshard/hooks/testing/controller.h\n@@ -12,20 +12,21 @@ namespace NKikimr::NYDBTest::NColumnShard {\n class TController: public TReadOnlyController {\n private:\n     using TBase = TReadOnlyController;\n-    YDB_ACCESSOR_DEF(std::optional<TDuration>, LagForCompactionBeforeTierings);\n-    YDB_ACCESSOR(std::optional<TDuration>, GuaranteeIndexationInterval, TDuration::Zero());\n-    YDB_ACCESSOR(std::optional<TDuration>, PeriodicWakeupActivationPeriod, std::nullopt);\n-    YDB_ACCESSOR(std::optional<TDuration>, StatsReportInterval, std::nullopt);\n-    YDB_ACCESSOR(std::optional<ui64>, GuaranteeIndexationStartBytesLimit, 0);\n-    YDB_ACCESSOR(std::optional<TDuration>, OptimizerFreshnessCheckDuration, TDuration::Zero());\n-    YDB_ACCESSOR_DEF(std::optional<TDuration>, CompactionActualizationLag);\n-    YDB_ACCESSOR_DEF(std::optional<TDuration>, TasksActualizationLag);\n+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideRequestsTracePingCheckPeriod);\n+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideLagForCompactionBeforeTierings);\n+    YDB_ACCESSOR(std::optional<TDuration>, OverrideGuaranteeIndexationInterval, TDuration::Zero());\n+    YDB_ACCESSOR(std::optional<TDuration>, OverridePeriodicWakeupActivationPeriod, std::nullopt);\n+    YDB_ACCESSOR(std::optional<TDuration>, OverrideStatsReportInterval, std::nullopt);\n+    YDB_ACCESSOR(std::optional<ui64>, OverrideGuaranteeIndexationStartBytesLimit, 0);\n+    YDB_ACCESSOR(std::optional<TDuration>, OverrideOptimizerFreshnessCheckDuration, TDuration::Zero());\n+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideCompactionActualizationLag);\n+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideTasksActualizationLag);\n+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideReadTimeoutClean);\n     EOptimizerCompactionWeightControl CompactionControl = EOptimizerCompactionWeightControl::Force;\n \n     YDB_ACCESSOR(std::optional<ui64>, OverrideReduceMemoryIntervalLimit, 1024);\n     YDB_ACCESSOR_DEF(std::optional<ui64>, OverrideRejectMemoryIntervalLimit);\n \n-    std::optional<TDuration> ReadTimeoutClean;\n     std::optional<ui32> ExpectedShardsCount;\n \n     THashMap<ui64, const ::NKikimr::NColumnShard::TColumnShard*> ShardActuals;\n@@ -129,12 +130,16 @@ class TController: public TReadOnlyController {\n     THashSet<TString> SharingIds;\n protected:\n     virtual ::NKikimr::NColumnShard::TBlobPutResult::TPtr OverrideBlobPutResultOnCompaction(const ::NKikimr::NColumnShard::TBlobPutResult::TPtr original, const NOlap::TWriteActionsCollection& actions) const override;\n-    virtual TDuration GetLagForCompactionBeforeTierings(const TDuration def) const override {\n-        return LagForCompactionBeforeTierings.value_or(def);\n+    virtual TDuration DoGetLagForCompactionBeforeTierings(const TDuration def) const override {\n+        return OverrideLagForCompactionBeforeTierings.value_or(def);\n     }\n \n-    virtual TDuration GetCompactionActualizationLag(const TDuration def) const override {\n-        return CompactionActualizationLag.value_or(def);\n+    virtual TDuration DoGetPingCheckPeriod(const TDuration def) const override {\n+        return OverrideRequestsTracePingCheckPeriod.value_or(def);\n+    }\n+\n+    virtual TDuration DoGetCompactionActualizationLag(const TDuration def) const override {\n+        return OverrideCompactionActualizationLag.value_or(def);\n     }\n \n \n@@ -143,8 +148,8 @@ class TController: public TReadOnlyController {\n         return !DisabledBackgrounds.contains(id);\n     }\n \n-    virtual TDuration GetActualizationTasksLag(const TDuration d) const override {\n-        return TasksActualizationLag.value_or(d);\n+    virtual TDuration DoGetActualizationTasksLag(const TDuration d) const override {\n+        return OverrideTasksActualizationLag.value_or(d);\n     }\n \n     virtual void DoOnTabletInitCompleted(const ::NKikimr::NColumnShard::TColumnShard& shard) override;\n@@ -152,23 +157,29 @@ class TController: public TReadOnlyController {\n     virtual void DoOnAfterGCAction(const ::NKikimr::NColumnShard::TColumnShard& shard, const NOlap::IBlobsGCAction& action) override;\n \n     virtual bool DoOnWriteIndexComplete(const NOlap::TColumnEngineChanges& changes, const ::NKikimr::NColumnShard::TColumnShard& shard) override;\n-    virtual TDuration GetGuaranteeIndexationInterval(const TDuration defaultValue) const override {\n-        return GuaranteeIndexationInterval.value_or(defaultValue);\n+    virtual TDuration DoGetGuaranteeIndexationInterval(const TDuration defaultValue) const override {\n+        return OverrideGuaranteeIndexationInterval.value_or(defaultValue);\n+    }\n+    virtual TDuration DoGetPeriodicWakeupActivationPeriod(const TDuration defaultValue) const override {\n+        return OverridePeriodicWakeupActivationPeriod.value_or(defaultValue);\n     }\n-    TDuration GetPeriodicWakeupActivationPeriod(const TDuration defaultValue) const override {\n-        return PeriodicWakeupActivationPeriod.value_or(defaultValue);\n+    virtual TDuration DoGetStatsReportInterval(const TDuration defaultValue) const override {\n+        return OverrideStatsReportInterval.value_or(defaultValue);\n     }\n-    TDuration GetStatsReportInterval(const TDuration defaultValue) const override {\n-        return StatsReportInterval.value_or(defaultValue);\n+    virtual ui64 DoGetGuaranteeIndexationStartBytesLimit(const ui64 defaultValue) const override {\n+        return OverrideGuaranteeIndexationStartBytesLimit.value_or(defaultValue);\n     }\n-    virtual ui64 GetGuaranteeIndexationStartBytesLimit(const ui64 defaultValue) const override {\n-        return GuaranteeIndexationStartBytesLimit.value_or(defaultValue);\n+    virtual TDuration DoGetOptimizerFreshnessCheckDuration(const TDuration defaultValue) const override {\n+        return OverrideOptimizerFreshnessCheckDuration.value_or(defaultValue);\n     }\n-    virtual TDuration GetOptimizerFreshnessCheckDuration(const TDuration defaultValue) const override {\n-        return OptimizerFreshnessCheckDuration.value_or(defaultValue);\n+    virtual TDuration DoGetReadTimeoutClean(const TDuration def) const override {\n+        return OverrideReadTimeoutClean.value_or(def);\n     }\n-    virtual TDuration GetReadTimeoutClean(const TDuration def) override {\n-        return ReadTimeoutClean.value_or(def);\n+    virtual ui64 DoGetReduceMemoryIntervalLimit(const ui64 def) const override {\n+        return OverrideReduceMemoryIntervalLimit.value_or(def);\n+    }\n+    virtual ui64 DoGetRejectMemoryIntervalLimit(const ui64 def) const override {\n+        return OverrideRejectMemoryIntervalLimit.value_or(def);\n     }\n     virtual EOptimizerCompactionWeightControl GetCompactionControl() const override {\n         return CompactionControl;\n@@ -185,18 +196,9 @@ class TController: public TReadOnlyController {\n     }\n \n public:\n-    virtual TDuration GetRemovedPortionLivetime(const TDuration /*def*/) const override {\n-        return TDuration::Zero();\n-    }\n     const TAtomicCounter& GetIndexWriteControllerBrokeCount() const {\n         return IndexWriteControllerBrokeCount;\n     }\n-    virtual ui64 GetReduceMemoryIntervalLimit(const ui64 def) const override {\n-        return OverrideReduceMemoryIntervalLimit.value_or(def);\n-    }\n-    virtual ui64 GetRejectMemoryIntervalLimit(const ui64 def) const override {\n-        return OverrideRejectMemoryIntervalLimit.value_or(def);\n-    }\n     bool IsTrivialLinks() const;\n     TCheckContext CheckInvariants() const;\n \n@@ -232,9 +234,6 @@ class TController: public TReadOnlyController {\n     void SetCompactionControl(const EOptimizerCompactionWeightControl value) {\n         CompactionControl = value;\n     }\n-    void SetReadTimeoutClean(const TDuration d) {\n-        ReadTimeoutClean = d;\n-    }\n \n     bool HasPKSortingOnly() const;\n \ndiff --git a/ydb/core/tx/columnshard/hooks/testing/ro_controller.h b/ydb/core/tx/columnshard/hooks/testing/ro_controller.h\nindex c271878ea838..c55be9455204 100644\n--- a/ydb/core/tx/columnshard/hooks/testing/ro_controller.h\n+++ b/ydb/core/tx/columnshard/hooks/testing/ro_controller.h\n@@ -31,9 +31,18 @@ class TReadOnlyController: public ICSController {\n     YDB_READONLY(TAtomicCounter, ActualizationRefreshTieringCount, 0);\n     YDB_READONLY(TAtomicCounter, ShardingFiltersCount, 0);\n \n+    YDB_READONLY(TAtomicCounter, RequestTracingSnapshotsSave, 0);\n+    YDB_READONLY(TAtomicCounter, RequestTracingSnapshotsRemove, 0);\n+\n     YDB_ACCESSOR(TAtomicCounter, CompactionsLimit, 10000000);\n \n protected:\n+    virtual void OnRequestTracingChanges(\n+        const std::set<NOlap::TSnapshot>& snapshotsToSave, const std::set<NOlap::TSnapshot>& snapshotsToRemove) override {\n+        RequestTracingSnapshotsSave.Add(snapshotsToSave.size());\n+        RequestTracingSnapshotsRemove.Add(snapshotsToRemove.size());\n+    }\n+\n     virtual void OnSelectShardingFilter() override {\n         ShardingFiltersCount.Inc();\n     }\n@@ -62,11 +71,11 @@ class TReadOnlyController: public ICSController {\n         return EOptimizerCompactionWeightControl::Force;\n     }\n \n-public:\n-    virtual TDuration GetOverridenGCPeriod(const TDuration /*def*/) const override {\n+    virtual TDuration DoGetOverridenGCPeriod(const TDuration /*def*/) const override {\n         return TDuration::Zero();\n     }\n \n+public:\n     void WaitCompactions(const TDuration d) const {\n         TInstant start = TInstant::Now();\n         ui32 compactionsStart = GetCompactionStartedCounter().Val();\n@@ -82,10 +91,10 @@ class TReadOnlyController: public ICSController {\n \n     void WaitIndexation(const TDuration d) const {\n         TInstant start = TInstant::Now();\n-        ui32 compactionsStart = GetInsertStartedCounter().Val();\n+        ui32 insertsStart = GetInsertStartedCounter().Val();\n         while (Now() - start < d) {\n-            if (compactionsStart != GetInsertStartedCounter().Val()) {\n-                compactionsStart = GetInsertStartedCounter().Val();\n+            if (insertsStart != GetInsertStartedCounter().Val()) {\n+                insertsStart = GetInsertStartedCounter().Val();\n                 start = TInstant::Now();\n             }\n             Cerr << \"WAIT_INDEXATION: \" << GetInsertStartedCounter().Val() << Endl;\ndiff --git a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp\nindex 4f8cfe4ce4b9..31de6ffef8a5 100644\n--- a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp\n+++ b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp\n@@ -1,6 +1,6 @@\n #include \"columnshard_ut_common.h\"\n+#include \"shard_reader.h\"\n \n-#include <ydb/core/tx/columnshard/common/tests/shard_reader.h>\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n #include <ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.h>\n #include <ydb/core/tx/columnshard/engines/storage/indexes/max/meta.h>\n@@ -125,22 +125,25 @@ bool WriteDataImpl(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shar\n }\n \n bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId, const ui64 writeId, const ui64 tableId, const TString& data,\n-                              const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType) {\n+    const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType) {\n     NLongTxService::TLongTxId longTxId;\n     UNIT_ASSERT(longTxId.ParseString(\"ydb://long-tx/01ezvvxjdk2hd4vdgjs68knvp8?node_id=1\"));\n-    return WriteDataImpl(runtime, sender, shardId, tableId, longTxId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), writeIds, mType);\n-\n+    return WriteDataImpl(\n+        runtime, sender, shardId, tableId, longTxId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), writeIds, mType);\n }\n \n bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 writeId, const ui64 tableId, const TString& data,\n-                              const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, bool waitResult, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType) {\n+    const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, bool waitResult, std::vector<ui64>* writeIds,\n+    const NEvWrite::EModificationType mType) {\n     NLongTxService::TLongTxId longTxId;\n     UNIT_ASSERT(longTxId.ParseString(\"ydb://long-tx/01ezvvxjdk2hd4vdgjs68knvp8?node_id=1\"));\n     if (writeIds) {\n-        return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, longTxId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), writeIds, mType);\n+        return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, longTxId, writeId, data,\n+            NArrow::MakeArrowSchema(ydbSchema), writeIds, mType);\n     }\n     std::vector<ui64> ids;\n-    return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, longTxId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), waitResult ? &ids : nullptr, mType);\n+    return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, longTxId, writeId, data,\n+        NArrow::MakeArrowSchema(ydbSchema), waitResult ? &ids : nullptr, mType);\n }\n \n std::optional<ui64> WriteData(TTestBasicRuntime& runtime, TActorId& sender, const NLongTxService::TLongTxId& longTxId,\n@@ -431,25 +434,20 @@ void TTestSchema::InitSchema(const std::vector<NArrow::NTest::TTestColumn>& colu\n namespace NKikimr::NColumnShard {\n     NOlap::TIndexInfo BuildTableInfo(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,\n                          const std::vector<NArrow::NTest::TTestColumn>& key) {\n-        NOlap::TIndexInfo indexInfo = NOlap::TIndexInfo::BuildDefault();\n-\n+        THashMap<ui32, NTable::TColumn> columns;\n         for (ui32 i = 0; i < ydbSchema.size(); ++i) {\n             ui32 id = i + 1;\n             auto& name = ydbSchema[i].GetName();\n             auto& type = ydbSchema[i].GetType();\n \n-            indexInfo.Columns[id] = NTable::TColumn(name, id, type, \"\");\n-            indexInfo.ColumnNames[name] = id;\n+            columns[id] = NTable::TColumn(name, id, type, \"\");\n         }\n \n+        std::vector<TString> pkNames;\n         for (const auto& c : key) {\n-            indexInfo.KeyColumns.push_back(indexInfo.ColumnNames[c.GetName()]);\n+            pkNames.push_back(c.GetName());\n         }\n-\n-        auto storage = std::make_shared<NOlap::TTestStoragesManager>();\n-        storage->Initialize(TInstant::Now().Seconds());\n-        indexInfo.SetAllKeys(NOlap::TTestStoragesManager::GetInstance());\n-        return indexInfo;\n+        return NOlap::TIndexInfo::BuildDefault(NOlap::TTestStoragesManager::GetInstance(), columns, pkNames);\n     }\n \n     void SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const NOlap::TSnapshot& snapshot, bool succeed) {\n@@ -519,7 +517,7 @@ namespace NKikimr::NColumnShard {\n             fields.emplace_back(f.GetName());\n         }\n \n-        NOlap::NTests::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, snapshot);\n+        NTxUT::TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, snapshot);\n         reader.SetReplyColumns(fields);\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\ndiff --git a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h\nindex 4306babbb1ed..7594be5da952 100644\n--- a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h\n+++ b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h\n@@ -1,20 +1,21 @@\n #pragma once\n \n-#include <ydb/core/tx/columnshard/blob_cache.h>\n-#include <ydb/core/tx/columnshard/common/snapshot.h>\n-\n #include <ydb/core/formats/arrow/arrow_batch_builder.h>\n-#include <ydb/core/tx/columnshard/test_helper/helper.h>\n+#include <ydb/core/protos/tx_columnshard.pb.h>\n #include <ydb/core/scheme/scheme_tabledefs.h>\n #include <ydb/core/scheme/scheme_types_proto.h>\n #include <ydb/core/testlib/tablet_helpers.h>\n #include <ydb/core/testlib/test_client.h>\n-#include <ydb/core/protos/tx_columnshard.pb.h>\n+#include <ydb/core/tx/columnshard/blob_cache.h>\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n+#include <ydb/core/tx/columnshard/test_helper/helper.h>\n+#include <ydb/core/tx/data_events/common/modification_type.h>\n+#include <ydb/core/tx/long_tx_service/public/types.h>\n+\n+#include <ydb/public/sdk/cpp/client/ydb_value/value.h>\n #include <ydb/services/metadata/abstract/fetcher.h>\n \n #include <library/cpp/testing/unittest/registar.h>\n-#include <ydb/core/tx/long_tx_service/public/types.h>\n-#include <ydb/core/tx/data_events/common/modification_type.h>\n \n namespace NKikimr::NOlap {\n struct TIndexInfo;\n@@ -167,7 +168,7 @@ struct TTestSchema {\n             // PK\n             firstKeyItem,\n             TTestColumn(\"resource_type\", TTypeInfo(NTypeIds::Utf8) ),\n-            TTestColumn(\"resource_id\", TTypeInfo(NTypeIds::Utf8) ),\n+            TTestColumn(\"resource_id\", TTypeInfo(NTypeIds::Utf8)).SetAccessorClassName(\"SPARSED\"),\n             TTestColumn(\"uid\", TTypeInfo(NTypeIds::Utf8) ).SetStorageId(\"__MEMORY\"),\n             TTestColumn(\"level\", TTypeInfo(NTypeIds::Int32) ),\n             TTestColumn(\"message\", TTypeInfo(NTypeIds::Utf8) ).SetStorageId(\"__MEMORY\"),\n@@ -183,7 +184,7 @@ struct TTestSchema {\n         std::vector<TTestColumn> schema = {\n             // PK\n             TTestColumn(\"timestamp\", TTypeInfo(NTypeIds::Timestamp) ),\n-            TTestColumn(\"resource_type\", TTypeInfo(NTypeIds::Utf8) ),\n+            TTestColumn(\"resource_type\", TTypeInfo(NTypeIds::Utf8)).SetAccessorClassName(\"SPARSED\"),\n             TTestColumn(\"resource_id\", TTypeInfo(NTypeIds::Utf8) ),\n             TTestColumn(\"uid\", TTypeInfo(NTypeIds::Utf8) ).SetStorageId(\"__MEMORY\"),\n             //\n@@ -192,7 +193,7 @@ struct TTestSchema {\n             TTestColumn(\"json_payload\", TTypeInfo(NTypeIds::JsonDocument) ),\n             TTestColumn(\"ingested_at\", TTypeInfo(NTypeIds::Timestamp) ),\n             TTestColumn(\"saved_at\", TTypeInfo(NTypeIds::Timestamp) ),\n-            TTestColumn(\"request_id\", TTypeInfo(NTypeIds::Yson) )\n+            TTestColumn(\"request_id\", TTypeInfo(NTypeIds::Yson)).SetAccessorClassName(\"SPARSED\")\n         };\n         return schema;\n     };\n@@ -201,7 +202,7 @@ struct TTestSchema {\n         std::vector<TTestColumn> schema = {\n             TTestColumn(\"timestamp\", TTypeInfo(NTypeIds::Timestamp) ),\n             TTestColumn(\"resource_type\", TTypeInfo(NTypeIds::Utf8) ).SetStorageId(\"__MEMORY\"),\n-            TTestColumn(\"resource_id\", TTypeInfo(NTypeIds::Utf8) ),\n+            TTestColumn(\"resource_id\", TTypeInfo(NTypeIds::Utf8)).SetAccessorClassName(\"SPARSED\"),\n             TTestColumn(\"uid\", TTypeInfo(NTypeIds::Utf8) ).SetStorageId(\"__MEMORY\")\n         };\n         return schema;\n@@ -406,10 +407,12 @@ void PlanSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot\n void PlanWriteTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot snap, bool waitResult = true);\n \n bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId, const ui64 writeId, const ui64 tableId, const TString& data,\n-                              const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert);\n+    const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds,\n+    const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert);\n \n bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 writeId, const ui64 tableId, const TString& data,\n-                              const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, bool waitResult = true, std::vector<ui64>* writeIds = nullptr, const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert);\n+    const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, bool waitResult = true, std::vector<ui64>* writeIds = nullptr,\n+    const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert);\n \n std::optional<ui64> WriteData(TTestBasicRuntime& runtime, TActorId& sender, const NLongTxService::TLongTxId& longTxId,\n                               ui64 tableId, const ui64 writePartId, const TString& data,\n@@ -474,11 +477,13 @@ namespace NKikimr::NColumnShard {\n                 auto& builder = Owner.Builders[Index];\n                 auto type = builder->type();\n \n-                NArrow::SwitchType(type->id(), [&](const auto& t) {\n+                Y_ABORT_UNLESS(NArrow::SwitchType(type->id(), [&](const auto& t) {\n                     using TWrap = std::decay_t<decltype(t)>;\n                     using T = typename TWrap::T;\n                     using TBuilder = typename arrow::TypeTraits<typename TWrap::T>::BuilderType;\n \n+                    AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)(\"T\", typeid(T).name());\n+\n                     auto& typedBuilder = static_cast<TBuilder&>(*builder);\n                     if constexpr (std::is_arithmetic<TData>::value) {\n                         if constexpr (arrow::has_c_type<T>::value) {\n@@ -493,9 +498,16 @@ namespace NKikimr::NColumnShard {\n                             return true;\n                         }\n                     }\n+\n+                    if constexpr (std::is_same<TData, NYdb::TDecimalValue>::value) {\n+                        if constexpr (arrow::is_decimal128_type<T>::value) {\n+                            Y_ABORT_UNLESS(typedBuilder.Append(arrow::Decimal128(data.Hi_, data.Low_)).ok());\n+                            return true;\n+                        }\n+                    }\n                     Y_ABORT(\"Unknown type combination\");\n                     return false;\n-                });\n+                }));\n                 return TRowBuilder(Index + 1, Owner);\n             }\n \ndiff --git a/ydb/core/tx/columnshard/test_helper/controllers.h b/ydb/core/tx/columnshard/test_helper/controllers.h\nindex 5b48f204e2bc..68cd6a1dc4ed 100644\n--- a/ydb/core/tx/columnshard/test_helper/controllers.h\n+++ b/ydb/core/tx/columnshard/test_helper/controllers.h\n@@ -21,24 +21,21 @@ class TWaitCompactionController: public NYDBTest::NColumnShard::TController {\n     virtual bool NeedForceCompactionBacketsConstruction() const override {\n         return true;\n     }\n-    virtual ui64 GetSmallPortionSizeDetector(const ui64 /*def*/) const override {\n+    virtual ui64 DoGetSmallPortionSizeDetector(const ui64 /*def*/) const override {\n         return SmallSizeDetector.value_or(0);\n     }\n-    virtual TDuration GetOptimizerFreshnessCheckDuration(const TDuration /*defaultValue*/) const override {\n+    virtual TDuration DoGetOptimizerFreshnessCheckDuration(const TDuration /*defaultValue*/) const override {\n         return TDuration::Zero();\n     }\n-    virtual TDuration GetLagForCompactionBeforeTierings(const TDuration /*def*/) const override {\n+    virtual TDuration DoGetLagForCompactionBeforeTierings(const TDuration /*def*/) const override {\n         return TDuration::Zero();\n     }\n-    virtual TDuration GetCompactionActualizationLag(const TDuration /*def*/) const override {\n+    virtual TDuration DoGetCompactionActualizationLag(const TDuration /*def*/) const override {\n         return TDuration::Zero();\n     }\n-    virtual TDuration GetTTLDefaultWaitingDuration(const TDuration /*defaultValue*/) const override {\n-        return TDuration::Seconds(1);\n-    }\n public:\n     TWaitCompactionController() {\n-        SetPeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n+        SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));\n     }\n \n     ui32 GetFinishedExportsCount() const {\ndiff --git a/ydb/core/tx/columnshard/test_helper/helper.cpp b/ydb/core/tx/columnshard/test_helper/helper.cpp\nindex a7aca5f114ca..d64003c5d525 100644\n--- a/ydb/core/tx/columnshard/test_helper/helper.cpp\n+++ b/ydb/core/tx/columnshard/test_helper/helper.cpp\n@@ -1,6 +1,7 @@\n #include \"helper.h\"\n \n #include <ydb/core/formats/arrow/arrow_helpers.h>\n+#include <ydb/library/formats/arrow/protos/accessor.pb.h>\n #include <ydb/core/protos/flat_scheme_op.pb.h>\n #include <ydb/core/scheme/scheme_types_proto.h>\n #include <ydb/core/tx/columnshard/blobs_action/bs/storage.h>\n@@ -25,6 +26,9 @@ NKikimrSchemeOp::TOlapColumnDescription TTestColumn::CreateColumn(const ui32 id)\n         col.SetStorageId(StorageId);\n     }\n     auto columnType = NScheme::ProtoColumnTypeFromTypeInfoMod(Type, \"\");\n+    if (AccessorClassName) {\n+        col.MutableDataAccessorConstructor()->SetClassName(AccessorClassName);\n+    }\n     col.SetTypeId(columnType.TypeId);\n     if (columnType.TypeInfo) {\n         *col.MutableTypeInfo() = *columnType.TypeInfo;\n@@ -32,6 +36,16 @@ NKikimrSchemeOp::TOlapColumnDescription TTestColumn::CreateColumn(const ui32 id)\n     return col;\n }\n \n+std::set<std::string> TTestColumn::GetNullableSet(const std::vector<TTestColumn>& columns) {\n+    std::set<std::string> result;\n+    for (auto&& i : columns) {\n+        if (!i.GetNullable()) {\n+            result.emplace(i.GetName());\n+        }\n+    }\n+    return result;\n+}\n+\n std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TTestColumn::ConvertToPairs(const std::vector<TTestColumn>& columns) {\n     std::vector<std::pair<TString, NScheme::TTypeInfo>> result;\n     for (auto&& i : columns) {\n@@ -66,15 +80,15 @@ std::vector<NKikimr::NArrow::NTest::TTestColumn> TTestColumn::CropSchema(const s\n \n namespace NKikimr::NArrow {\n \n-std::vector<std::shared_ptr<arrow::Field>> MakeArrowFields(\n-    const std::vector<NTest::TTestColumn>& columns, const std::set<std::string>& notNullColumns /*= {}*/) {\n+std::vector<std::shared_ptr<arrow::Field>> MakeArrowFields(const std::vector<NTest::TTestColumn>& columns) {\n+    std::set<std::string> notNullColumns = NTest::TTestColumn::GetNullableSet(columns);\n     auto result = MakeArrowFields(NTest::TTestColumn::ConvertToPairs(columns), notNullColumns);\n     UNIT_ASSERT_C(result.ok(), result.status().ToString());\n     return result.ValueUnsafe();\n }\n \n-std::shared_ptr<arrow::Schema> MakeArrowSchema(\n-    const std::vector<NTest::TTestColumn>& columns, const std::set<std::string>& notNullColumns /*= {}*/) {\n+std::shared_ptr<arrow::Schema> MakeArrowSchema(const std::vector<NTest::TTestColumn>& columns) {\n+    std::set<std::string> notNullColumns = NTest::TTestColumn::GetNullableSet(columns);\n     auto result = MakeArrowSchema(NTest::TTestColumn::ConvertToPairs(columns), notNullColumns);\n     UNIT_ASSERT_C(result.ok(), result.status().ToString());\n     return result.ValueUnsafe();\ndiff --git a/ydb/core/tx/columnshard/test_helper/helper.h b/ydb/core/tx/columnshard/test_helper/helper.h\nindex cf71657cf97c..98f9a09b526c 100644\n--- a/ydb/core/tx/columnshard/test_helper/helper.h\n+++ b/ydb/core/tx/columnshard/test_helper/helper.h\n@@ -51,6 +51,9 @@ class TTestColumn {\n     YDB_ACCESSOR_DEF(TString, Name);\n     YDB_ACCESSOR_DEF(NScheme::TTypeInfo, Type);\n     YDB_ACCESSOR_DEF(TString, StorageId);\n+    YDB_ACCESSOR_DEF(TString, AccessorClassName);\n+    YDB_ACCESSOR(bool, Nullable, true);\n+\n public:\n     explicit TTestColumn(const TString& name, const NScheme::TTypeInfo& type)\n         : Name(name)\n@@ -63,13 +66,14 @@ class TTestColumn {\n     static THashMap<TString, NScheme::TTypeInfo> ConvertToHash(const std::vector<TTestColumn>& columns);\n     static std::vector<TTestColumn> BuildFromPairs(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns);\n     static std::vector<TTestColumn> CropSchema(const std::vector<TTestColumn>& input, const ui32 size);\n+    static std::set<std::string> GetNullableSet(const std::vector<TTestColumn>& columns);\n };\n \n }\n \n namespace NKikimr::NArrow {\n \n-std::vector<std::shared_ptr<arrow::Field>> MakeArrowFields(const std::vector<NTest::TTestColumn>& columns, const std::set<std::string>& notNullColumns = {});\n-std::shared_ptr<arrow::Schema> MakeArrowSchema(const std::vector<NTest::TTestColumn>& columns, const std::set<std::string>& notNullColumns = {});\n+std::vector<std::shared_ptr<arrow::Field>> MakeArrowFields(const std::vector<NTest::TTestColumn>& columns);\n+std::shared_ptr<arrow::Schema> MakeArrowSchema(const std::vector<NTest::TTestColumn>& columns);\n \n }\ndiff --git a/ydb/core/tx/columnshard/common/tests/shard_reader.h b/ydb/core/tx/columnshard/test_helper/shard_reader.h\nsimilarity index 99%\nrename from ydb/core/tx/columnshard/common/tests/shard_reader.h\nrename to ydb/core/tx/columnshard/test_helper/shard_reader.h\nindex 1bb3ad353835..2beaa5a782d9 100644\n--- a/ydb/core/tx/columnshard/common/tests/shard_reader.h\n+++ b/ydb/core/tx/columnshard/test_helper/shard_reader.h\n@@ -10,7 +10,7 @@\n #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>\n #include <optional>\n \n-namespace NKikimr::NOlap::NTests {\n+namespace NKikimr::NTxUT {\n \n class TShardReader {\n private:\n@@ -267,4 +267,4 @@ class TShardReader {\n     }\n };\n \n-}\n+} //namespace NKikimr::NTxUT\ndiff --git a/ydb/core/tx/columnshard/test_helper/ya.make b/ydb/core/tx/columnshard/test_helper/ya.make\nindex a900deb266db..cab4937293dd 100644\n--- a/ydb/core/tx/columnshard/test_helper/ya.make\n+++ b/ydb/core/tx/columnshard/test_helper/ya.make\n@@ -2,6 +2,7 @@ LIBRARY()\n \n PEERDIR(\n     ydb/core/protos\n+    ydb/core/formats/arrow\n     contrib/libs/apache/arrow\n     ydb/library/actors/core\n     ydb/core/tx/columnshard/blobs_action/bs\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp b/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\nindex a4f0b3a544d7..9e5b7c8543f6 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\n@@ -542,6 +542,7 @@ NSchemeShardUT_Private::TTestEnv::TTestEnv(TTestActorRuntime& runtime, const TTe\n     app.SetEnableAddColumsWithDefaults(opts.EnableAddColumsWithDefaults_);\n     app.SetEnableReplaceIfExistsForExternalEntities(opts.EnableReplaceIfExistsForExternalEntities_);\n     app.SetEnableChangefeedsOnIndexTables(opts.EnableChangefeedsOnIndexTables_);\n+    app.SetEnableTieringInColumnShard(opts.EnableTieringInColumnShard_);\n \n     app.ColumnShardConfig.SetDisabledOnSchemeShard(false);\n \ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/test_env.h b/ydb/core/tx/schemeshard/ut_helpers/test_env.h\nindex 388b50caa579..c433855c9c76 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_env.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_env.h\n@@ -66,6 +66,7 @@ namespace NSchemeShardUT_Private {\n         OPTION(std::optional<bool>, EnableReplaceIfExistsForExternalEntities, std::nullopt);\n         OPTION(std::optional<TString>, GraphBackendType, std::nullopt);\n         OPTION(std::optional<bool>, EnableChangefeedsOnIndexTables, std::nullopt);\n+        OPTION(std::optional<bool>, EnableTieringInColumnShard, std::nullopt);\n \n         #undef OPTION\n     };\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-12 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-12\nindex 16b69fb8840b..1c7f8a39bfee 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-12\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-12\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.SearchPhrase\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -124,11 +114,33 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 108\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 40\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n                                                                                             {\n                                                                                                 \"Id\": 40\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 108\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -191,89 +203,98 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"item.SearchPhrase\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"SearchPhrase\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"SearchPhrase\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n+                                                                        },\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 40\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 107\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 107\n+                                                                                    \"Id\": 108\n                                                                                 },\n                                                                                 \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 40\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 106\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 12\n+                                                                                    \"Id\": 2\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 107\n-                                                                                }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 40\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 108\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-14 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-14\nindex 540a47da8afa..81c702c23b55 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-14\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-14\n@@ -60,18 +60,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -126,6 +116,28 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 108\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 39\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 40\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -134,6 +146,9 @@\n                                                                                             },\n                                                                                             {\n                                                                                                 \"Id\": 40\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 108\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -196,93 +211,105 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"SearchEngineID\",\n-                                                                    \"SearchPhrase\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"SearchEngineID\",\n+                                                            \"SearchPhrase\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n+                                                                        },\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 40\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 107\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 107\n+                                                                                    \"Id\": 108\n                                                                                 },\n                                                                                 \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 40\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 106\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 12\n-                                                                                }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 107\n+                                                                                    \"Id\": 2\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 39\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 40\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 39\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 40\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 39\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 108\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-15 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-15\nindex c9fb982c086a..bfc057c98171 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-15\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-15\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.UserID\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -87,11 +77,33 @@\n                                                                         \"Scan\": \"Parallel\",\n                                                                         \"SsaProgram\": {\n                                                                             \"Command\": [\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 106\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 10\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n                                                                                             {\n                                                                                                 \"Id\": 10\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 106\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -154,52 +166,61 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"item.UserID\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"UserID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 10\n-                                                                                    }\n-                                                                                ]\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"UserID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 106\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            }\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 10\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 10\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 106\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-16 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-16\nindex 3fb5e7befa7d..d08b757a0299 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-16\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-16\n@@ -60,18 +60,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -89,6 +79,28 @@\n                                                                         \"Scan\": \"Parallel\",\n                                                                         \"SsaProgram\": {\n                                                                             \"Command\": [\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 106\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 40\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 10\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -97,6 +109,9 @@\n                                                                                             },\n                                                                                             {\n                                                                                                 \"Id\": 10\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 106\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -159,56 +174,68 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"SearchPhrase\",\n-                                                                    \"UserID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 40\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 10\n-                                                                                    }\n-                                                                                ]\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"SearchPhrase\",\n+                                                            \"UserID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 106\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            }\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 10\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 10\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 106\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-17 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-17\nindex 94ef751b2c62..a56994b072f4 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-17\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-17\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -88,6 +78,28 @@\n                                                                         \"Scan\": \"Parallel\",\n                                                                         \"SsaProgram\": {\n                                                                             \"Command\": [\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 106\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 40\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 10\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -96,6 +108,9 @@\n                                                                                             },\n                                                                                             {\n                                                                                                 \"Id\": 10\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 106\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -154,56 +169,68 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"SearchPhrase\",\n-                                                                    \"UserID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 40\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 10\n-                                                                                    }\n-                                                                                ]\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"SearchPhrase\",\n+                                                            \"UserID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 106\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            }\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 10\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 10\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 106\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-21 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-21\nindex 7e17b759c25f..a3aad98b8615 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-21\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-21\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1),_yql_agg_1: MIN(item.URL,state._yql_agg_1)}\",\n-                                                                        \"GroupBy\": \"item.SearchPhrase\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -165,6 +155,38 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 110\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 111\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 14\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 3\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 40\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -172,7 +194,10 @@\n                                                                                                 \"Id\": 40\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 14\n+                                                                                                \"Id\": 110\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 111\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -235,133 +260,155 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1),_yql_agg_1: MIN(item.URL,state._yql_agg_1)}\",\n-                                                        \"GroupBy\": \"item.SearchPhrase\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"SearchPhrase\",\n-                                                                    \"URL\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n-                                                                                },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n-                                                                                }\n-                                                                            }\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"SearchPhrase\",\n+                                                            \"URL\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 107\n-                                                                                },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 40\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 106\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 12\n-                                                                                }\n-                                                                            }\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n                                                                         },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 107\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 40\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 107\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Projection\": {}\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 108\n                                                                         },\n-                                                                        {\n-                                                                            \"Projection\": {}\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"google\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 109\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 14\n+                                                                                },\n+                                                                                {\n                                                                                     \"Id\": 108\n+                                                                                }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 1,\n+                                                                            \"YqlOperationId\": 10\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 109\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 110\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"google\"\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            },\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 109\n+                                                                                    \"Id\": 111\n                                                                                 },\n                                                                                 \"Function\": {\n                                                                                     \"Arguments\": [\n                                                                                         {\n                                                                                             \"Id\": 14\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 108\n                                                                                         }\n                                                                                     ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 1,\n-                                                                                    \"YqlOperationId\": 10\n-                                                                                }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 109\n+                                                                                    \"Id\": 3\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 40\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 14\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 40\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 110\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 111\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-30 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-30\nindex 9bbc50a61991..cef01bba0a22 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-30\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-30\n@@ -60,18 +60,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_1: SUM(state._yql_agg_1,1),_yql_agg_2: SUM(item.IsRefresh,state._yql_agg_2)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -129,6 +119,67 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 108\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 21\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 5\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 109\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 21\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 110\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 111\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 16\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 5\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 8\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 39\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -136,13 +187,19 @@\n                                                                                                 \"Id\": 8\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 16\n+                                                                                                \"Id\": 39\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 21\n+                                                                                                \"Id\": 109\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 39\n+                                                                                                \"Id\": 108\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 110\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 111\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -205,102 +262,156 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_1: SUM(state._yql_agg_1,1),_yql_agg_2: SUM(item.IsRefresh,state._yql_agg_2)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"ClientIP\",\n-                                                                    \"IsRefresh\",\n-                                                                    \"ResolutionWidth\",\n-                                                                    \"SearchEngineID\",\n-                                                                    \"SearchPhrase\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"ClientIP\",\n+                                                            \"IsRefresh\",\n+                                                            \"ResolutionWidth\",\n+                                                            \"SearchEngineID\",\n+                                                            \"SearchPhrase\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n+                                                                        },\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 40\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 107\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 107\n+                                                                                    \"Id\": 108\n                                                                                 },\n                                                                                 \"Function\": {\n                                                                                     \"Arguments\": [\n                                                                                         {\n-                                                                                            \"Id\": 40\n-                                                                                        },\n+                                                                                            \"Id\": 21\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 5\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 109\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n                                                                                         {\n-                                                                                            \"Id\": 106\n+                                                                                            \"Id\": 21\n                                                                                         }\n                                                                                     ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 12\n+                                                                                    \"Id\": 2\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 107\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 110\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 111\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n+                                                                                        {\n+                                                                                            \"Id\": 16\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 5\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 8\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 16\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 21\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 39\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 8\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 39\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 8\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 39\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 109\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 108\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 110\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 111\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-31 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-31\nindex 40b8bbae3b1d..2dc49b273bcf 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-31\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-31\n@@ -60,18 +60,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_1: SUM(state._yql_agg_1,1),_yql_agg_2: SUM(item.IsRefresh,state._yql_agg_2)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -129,6 +119,67 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 108\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 21\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 5\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 109\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 21\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 110\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 111\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 16\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 5\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 8\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 1\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -136,13 +187,19 @@\n                                                                                                 \"Id\": 8\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 16\n+                                                                                                \"Id\": 1\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 21\n+                                                                                                \"Id\": 109\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 1\n+                                                                                                \"Id\": 108\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 110\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 111\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -205,102 +262,156 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_1: SUM(state._yql_agg_1,1),_yql_agg_2: SUM(item.IsRefresh,state._yql_agg_2)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"ClientIP\",\n-                                                                    \"IsRefresh\",\n-                                                                    \"ResolutionWidth\",\n-                                                                    \"SearchPhrase\",\n-                                                                    \"WatchID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"ClientIP\",\n+                                                            \"IsRefresh\",\n+                                                            \"ResolutionWidth\",\n+                                                            \"SearchPhrase\",\n+                                                            \"WatchID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n+                                                                        },\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 40\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 107\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 107\n+                                                                                    \"Id\": 108\n                                                                                 },\n                                                                                 \"Function\": {\n                                                                                     \"Arguments\": [\n                                                                                         {\n-                                                                                            \"Id\": 40\n-                                                                                        },\n+                                                                                            \"Id\": 21\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 5\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 109\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n                                                                                         {\n-                                                                                            \"Id\": 106\n+                                                                                            \"Id\": 21\n                                                                                         }\n                                                                                     ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 12\n+                                                                                    \"Id\": 2\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 107\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 110\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 111\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n+                                                                                        {\n+                                                                                            \"Id\": 16\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 5\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 8\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 16\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 21\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 1\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 8\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 1\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 8\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 1\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 109\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 108\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 110\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 111\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-32 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-32\nindex cdb74eef88cd..419e6c218a52 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-32\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-32\n@@ -60,18 +60,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_1: SUM(state._yql_agg_1,1),_yql_agg_2: SUM(item.IsRefresh,state._yql_agg_2)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -91,6 +81,67 @@\n                                                                         \"Scan\": \"Parallel\",\n                                                                         \"SsaProgram\": {\n                                                                             \"Command\": [\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 106\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 21\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 5\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 107\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 21\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 108\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 109\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Arguments\": [\n+                                                                                                        {\n+                                                                                                            \"Id\": 16\n+                                                                                                        }\n+                                                                                                    ],\n+                                                                                                    \"Id\": 5\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 8\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 1\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -98,13 +149,19 @@\n                                                                                                 \"Id\": 8\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 16\n+                                                                                                \"Id\": 1\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 21\n+                                                                                                \"Id\": 107\n                                                                                             },\n                                                                                             {\n-                                                                                                \"Id\": 1\n+                                                                                                \"Id\": 106\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 108\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 109\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -167,64 +224,118 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_1: SUM(state._yql_agg_1,1),_yql_agg_2: SUM(item.IsRefresh,state._yql_agg_2)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"ClientIP\",\n-                                                                    \"IsRefresh\",\n-                                                                    \"ResolutionWidth\",\n-                                                                    \"WatchID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 8\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 16\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 21\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 1\n-                                                                                    }\n-                                                                                ]\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"ClientIP\",\n+                                                            \"IsRefresh\",\n+                                                            \"ResolutionWidth\",\n+                                                            \"WatchID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 106\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n+                                                                                        {\n+                                                                                            \"Id\": 21\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 5\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 107\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n+                                                                                        {\n+                                                                                            \"Id\": 21\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 108\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            },\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 109\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Arguments\": [\n+                                                                                        {\n+                                                                                            \"Id\": 16\n+                                                                                        }\n+                                                                                    ],\n+                                                                                    \"Id\": 5\n+                                                                                }\n+                                                                            }\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 8\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 1\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 8\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 1\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 107\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 106\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 108\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 109\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-33 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-33\nindex b97bfa06e46c..3da7ae9fd6f2 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-33\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-33\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.URL\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -87,11 +77,33 @@\n                                                                         \"Scan\": \"Parallel\",\n                                                                         \"SsaProgram\": {\n                                                                             \"Command\": [\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 106\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 14\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n                                                                                             {\n                                                                                                 \"Id\": 14\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 106\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -154,52 +166,61 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"item.URL\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"URL\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 14\n-                                                                                    }\n-                                                                                ]\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"URL\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 106\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            }\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 14\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 14\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 106\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-34 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-34\nindex 589267a2ea09..b6764303856f 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-34\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-34\n@@ -60,18 +60,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -89,6 +79,28 @@\n                                                                         \"Scan\": \"Parallel\",\n                                                                         \"SsaProgram\": {\n                                                                             \"Command\": [\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 106\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 14\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 10\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n@@ -97,6 +109,9 @@\n                                                                                             },\n                                                                                             {\n                                                                                                 \"Id\": 10\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 106\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -159,56 +174,68 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"URL\",\n-                                                                    \"UserID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 14\n-                                                                                    },\n-                                                                                    {\n-                                                                                        \"Id\": 10\n-                                                                                    }\n-                                                                                ]\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"URL\",\n+                                                            \"UserID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n+                                                                                \"Column\": {\n+                                                                                    \"Id\": 106\n+                                                                                },\n+                                                                                \"Function\": {\n+                                                                                    \"Id\": 2\n+                                                                                }\n+                                                                            }\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 14\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 10\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 14\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 10\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 106\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-36 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-36\nindex 796d4e89a5ac..8ff3b5426a03 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-36\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-36\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableRangeScan\",\n+                                                                \"Node Type\": \"TableRangeScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.URL\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableRangeScan\",\n@@ -228,11 +218,33 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 114\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 14\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n                                                                                             {\n                                                                                                 \"Id\": 14\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 114\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -295,193 +307,202 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableRangeScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"item.URL\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableRangeScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableRangeScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"DontCountHits\",\n-                                                                    \"IsRefresh\",\n-                                                                    \"URL\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID [62, 62]\",\n-                                                                    \"EventDate [15887, 15917]\"\n-                                                                ],\n-                                                                \"ReadRangesExpectedSize\": 1,\n-                                                                \"ReadRangesKeys\": [\n-                                                                    \"CounterID\",\n-                                                                    \"EventDate\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n-                                                                                },\n-                                                                                \"Constant\": {\n-                                                                                    \"Int32\": 0\n-                                                                                }\n-                                                                            }\n+                                                        \"Name\": \"TableRangeScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"DontCountHits\",\n+                                                            \"IsRefresh\",\n+                                                            \"URL\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID [62, 62]\",\n+                                                            \"EventDate [15887, 15917]\"\n+                                                        ],\n+                                                        \"ReadRangesExpectedSize\": 1,\n+                                                        \"ReadRangesKeys\": [\n+                                                            \"CounterID\",\n+                                                            \"EventDate\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 107\n-                                                                                },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 62\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 106\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 11\n-                                                                                }\n-                                                                            }\n+                                                                        \"Constant\": {\n+                                                                            \"Int32\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 108\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 62\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Int32\": 0\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 11\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 108\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 109\n+                                                                        \"Constant\": {\n+                                                                            \"Int32\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 109\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 16\n                                                                                 },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 16\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 108\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 1,\n-                                                                                    \"YqlOperationId\": 11\n+                                                                                {\n+                                                                                    \"Id\": 108\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 1,\n+                                                                            \"YqlOperationId\": 11\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 110\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 110\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 111\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 14\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n+                                                                                {\n+                                                                                    \"Id\": 110\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 2,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 112\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 111\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 109\n                                                                                 },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 14\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 110\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 2,\n-                                                                                    \"YqlOperationId\": 12\n+                                                                                {\n+                                                                                    \"Id\": 111\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 3,\n+                                                                            \"YqlOperationId\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 113\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 112\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 107\n                                                                                 },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 109\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 111\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 3,\n-                                                                                    \"YqlOperationId\": 0\n+                                                                                {\n+                                                                                    \"Id\": 112\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 4,\n+                                                                            \"YqlOperationId\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 113\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 113\n+                                                                                    \"Id\": 114\n                                                                                 },\n                                                                                 \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 107\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 112\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 4,\n-                                                                                    \"YqlOperationId\": 0\n+                                                                                    \"Id\": 2\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 113\n-                                                                                }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 14\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 14\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 14\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 114\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-37 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-37\nindex 54add1a7092f..ed07bb8d72fb 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-37\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-37\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableRangeScan\",\n+                                                                \"Node Type\": \"TableRangeScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.Title\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableRangeScan\",\n@@ -228,11 +218,33 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 114\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 3\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n                                                                                             {\n                                                                                                 \"Id\": 3\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 114\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -295,193 +307,202 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableRangeScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"item.Title\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableRangeScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableRangeScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"DontCountHits\",\n-                                                                    \"IsRefresh\",\n-                                                                    \"Title\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID [62, 62]\",\n-                                                                    \"EventDate [15887, 15917]\"\n-                                                                ],\n-                                                                \"ReadRangesExpectedSize\": 1,\n-                                                                \"ReadRangesKeys\": [\n-                                                                    \"CounterID\",\n-                                                                    \"EventDate\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n-                                                                                },\n-                                                                                \"Constant\": {\n-                                                                                    \"Int32\": 0\n-                                                                                }\n-                                                                            }\n+                                                        \"Name\": \"TableRangeScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"DontCountHits\",\n+                                                            \"IsRefresh\",\n+                                                            \"Title\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID [62, 62]\",\n+                                                            \"EventDate [15887, 15917]\"\n+                                                        ],\n+                                                        \"ReadRangesExpectedSize\": 1,\n+                                                        \"ReadRangesKeys\": [\n+                                                            \"CounterID\",\n+                                                            \"EventDate\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 107\n-                                                                                },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 62\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 106\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 11\n-                                                                                }\n-                                                                            }\n+                                                                        \"Constant\": {\n+                                                                            \"Int32\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 108\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 62\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Int32\": 0\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 11\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 108\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 109\n+                                                                        \"Constant\": {\n+                                                                            \"Int32\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 109\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 16\n                                                                                 },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 16\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 108\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 1,\n-                                                                                    \"YqlOperationId\": 11\n+                                                                                {\n+                                                                                    \"Id\": 108\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 1,\n+                                                                            \"YqlOperationId\": 11\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 110\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 110\n+                                                                        \"Constant\": {\n+                                                                            \"Bytes\": \"\"\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 111\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 3\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Bytes\": \"\"\n+                                                                                {\n+                                                                                    \"Id\": 110\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 2,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 112\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 111\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 109\n                                                                                 },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 3\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 110\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 2,\n-                                                                                    \"YqlOperationId\": 12\n+                                                                                {\n+                                                                                    \"Id\": 111\n                                                                                 }\n-                                                                            }\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 3,\n+                                                                            \"YqlOperationId\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 113\n                                                                         },\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 112\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 107\n                                                                                 },\n-                                                                                \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 109\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 111\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 3,\n-                                                                                    \"YqlOperationId\": 0\n+                                                                                {\n+                                                                                    \"Id\": 112\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 4,\n+                                                                            \"YqlOperationId\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 113\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 113\n+                                                                                    \"Id\": 114\n                                                                                 },\n                                                                                 \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 107\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 112\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 4,\n-                                                                                    \"YqlOperationId\": 0\n+                                                                                    \"Id\": 2\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 113\n-                                                                                }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 3\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 3\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 3\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 114\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-38 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-38\nindex 7bb266311b0d..e3d91c1cb23c 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-38\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-38\n@@ -88,18 +88,8 @@\n                                                                         \"PlanNodeType\": \"Connection\",\n                                                                         \"Plans\": [\n                                                                             {\n-                                                                                \"Node Type\": \"Aggregate-TableRangeScan\",\n+                                                                                \"Node Type\": \"TableRangeScan\",\n                                                                                 \"Operators\": [\n-                                                                                    {\n-                                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                                        \"GroupBy\": \"item.URL\",\n-                                                                                        \"Inputs\": [\n-                                                                                            {\n-                                                                                                \"InternalOperatorId\": 1\n-                                                                                            }\n-                                                                                        ],\n-                                                                                        \"Name\": \"Aggregate\"\n-                                                                                    },\n                                                                                     {\n                                                                                         \"Inputs\": [],\n                                                                                         \"Name\": \"TableRangeScan\",\n@@ -258,11 +248,33 @@\n                                                                                                         }\n                                                                                                     }\n                                                                                                 },\n+                                                                                                {\n+                                                                                                    \"GroupBy\": {\n+                                                                                                        \"Aggregates\": [\n+                                                                                                            {\n+                                                                                                                \"Column\": {\n+                                                                                                                    \"Id\": 114\n+                                                                                                                },\n+                                                                                                                \"Function\": {\n+                                                                                                                    \"Id\": 2\n+                                                                                                                }\n+                                                                                                            }\n+                                                                                                        ],\n+                                                                                                        \"KeyColumns\": [\n+                                                                                                            {\n+                                                                                                                \"Id\": 14\n+                                                                                                            }\n+                                                                                                        ]\n+                                                                                                    }\n+                                                                                                },\n                                                                                                 {\n                                                                                                     \"Projection\": {\n                                                                                                         \"Columns\": [\n                                                                                                             {\n                                                                                                                 \"Id\": 14\n+                                                                                                            },\n+                                                                                                            {\n+                                                                                                                \"Id\": 114\n                                                                                                             }\n                                                                                                         ]\n                                                                                                     }\n@@ -349,194 +361,203 @@\n                                                         \"PlanNodeId\": 7,\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate\",\n+                                                                \"Node Type\": \"TableRangeScan\",\n                                                                 \"Operators\": [\n                                                                     {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.URL\",\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    }\n-                                                                ],\n-                                                                \"PlanNodeId\": 9,\n-                                                                \"Plans\": [\n-                                                                    {\n-                                                                        \"Node Type\": \"TableRangeScan\",\n-                                                                        \"Operators\": [\n-                                                                            {\n-                                                                                \"Name\": \"TableRangeScan\",\n-                                                                                \"ReadColumns\": [\n-                                                                                    \"IsDownload\",\n-                                                                                    \"IsLink\",\n-                                                                                    \"IsRefresh\",\n-                                                                                    \"URL\"\n-                                                                                ],\n-                                                                                \"ReadRanges\": [\n-                                                                                    \"CounterID [62, 62]\",\n-                                                                                    \"EventDate [15887, 15917]\"\n-                                                                                ],\n-                                                                                \"ReadRangesExpectedSize\": 1,\n-                                                                                \"ReadRangesKeys\": [\n-                                                                                    \"CounterID\",\n-                                                                                    \"EventDate\"\n-                                                                                ],\n-                                                                                \"Scan\": \"Parallel\",\n-                                                                                \"SsaProgram\": {\n-                                                                                    \"Command\": [\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 106\n-                                                                                                },\n-                                                                                                \"Constant\": {\n-                                                                                                    \"Int32\": 0\n-                                                                                                }\n-                                                                                            }\n+                                                                        \"Name\": \"TableRangeScan\",\n+                                                                        \"ReadColumns\": [\n+                                                                            \"IsDownload\",\n+                                                                            \"IsLink\",\n+                                                                            \"IsRefresh\",\n+                                                                            \"URL\"\n+                                                                        ],\n+                                                                        \"ReadRanges\": [\n+                                                                            \"CounterID [62, 62]\",\n+                                                                            \"EventDate [15887, 15917]\"\n+                                                                        ],\n+                                                                        \"ReadRangesExpectedSize\": 1,\n+                                                                        \"ReadRangesKeys\": [\n+                                                                            \"CounterID\",\n+                                                                            \"EventDate\"\n+                                                                        ],\n+                                                                        \"Scan\": \"Parallel\",\n+                                                                        \"SsaProgram\": {\n+                                                                            \"Command\": [\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 106\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 107\n-                                                                                                },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 16\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 106\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 0,\n-                                                                                                    \"YqlOperationId\": 11\n-                                                                                                }\n-                                                                                            }\n+                                                                                        \"Constant\": {\n+                                                                                            \"Int32\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 107\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 108\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 16\n                                                                                                 },\n-                                                                                                \"Constant\": {\n-                                                                                                    \"Int32\": 0\n+                                                                                                {\n+                                                                                                    \"Id\": 106\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 0,\n+                                                                                            \"YqlOperationId\": 11\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 108\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 109\n+                                                                                        \"Constant\": {\n+                                                                                            \"Int32\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 109\n+                                                                                        },\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 53\n                                                                                                 },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 53\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 108\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 1,\n-                                                                                                    \"YqlOperationId\": 12\n+                                                                                                {\n+                                                                                                    \"Id\": 108\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 1,\n+                                                                                            \"YqlOperationId\": 12\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 110\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 110\n+                                                                                        \"Constant\": {\n+                                                                                            \"Int32\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 111\n+                                                                                        },\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 54\n                                                                                                 },\n-                                                                                                \"Constant\": {\n-                                                                                                    \"Int32\": 0\n+                                                                                                {\n+                                                                                                    \"Id\": 110\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 2,\n+                                                                                            \"YqlOperationId\": 11\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 112\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 111\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 109\n                                                                                                 },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 54\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 110\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 2,\n-                                                                                                    \"YqlOperationId\": 11\n+                                                                                                {\n+                                                                                                    \"Id\": 111\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 3,\n+                                                                                            \"YqlOperationId\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 113\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 112\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 107\n                                                                                                 },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 109\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 111\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 3,\n-                                                                                                    \"YqlOperationId\": 0\n+                                                                                                {\n+                                                                                                    \"Id\": 112\n                                                                                                 }\n-                                                                                            }\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 4,\n+                                                                                            \"YqlOperationId\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Filter\": {\n+                                                                                        \"Predicate\": {\n+                                                                                            \"Id\": 113\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n                                                                                                 \"Column\": {\n-                                                                                                    \"Id\": 113\n+                                                                                                    \"Id\": 114\n                                                                                                 },\n                                                                                                 \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 107\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 112\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 4,\n-                                                                                                    \"YqlOperationId\": 0\n+                                                                                                    \"Id\": 2\n                                                                                                 }\n                                                                                             }\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Filter\": {\n-                                                                                                \"Predicate\": {\n-                                                                                                    \"Id\": 113\n-                                                                                                }\n-                                                                                            }\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Projection\": {\n-                                                                                                \"Columns\": [\n-                                                                                                    {\n-                                                                                                        \"Id\": 14\n-                                                                                                    }\n-                                                                                                ]\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 14\n                                                                                             }\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"Version\": 4\n+                                                                                        ]\n+                                                                                    }\n                                                                                 },\n-                                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                                            }\n-                                                                        ],\n-                                                                        \"PlanNodeId\": 10\n+                                                                                {\n+                                                                                    \"Projection\": {\n+                                                                                        \"Columns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 14\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 114\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                }\n+                                                                            ],\n+                                                                            \"Version\": 4\n+                                                                        },\n+                                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                                     }\n-                                                                ]\n+                                                                ],\n+                                                                \"PlanNodeId\": 9\n                                                             }\n                                                         ]\n                                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-41 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-41\nindex 4dce9155dc8a..dd89190d205b 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-41\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-41\n@@ -89,18 +89,8 @@\n                                                                         \"PlanNodeType\": \"Connection\",\n                                                                         \"Plans\": [\n                                                                             {\n-                                                                                \"Node Type\": \"Aggregate-TableRangeScan\",\n+                                                                                \"Node Type\": \"TableRangeScan\",\n                                                                                 \"Operators\": [\n-                                                                                    {\n-                                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                                        \"GroupBy\": \"\",\n-                                                                                        \"Inputs\": [\n-                                                                                            {\n-                                                                                                \"InternalOperatorId\": 1\n-                                                                                            }\n-                                                                                        ],\n-                                                                                        \"Name\": \"Aggregate\"\n-                                                                                    },\n                                                                                     {\n                                                                                         \"Inputs\": [],\n                                                                                         \"Name\": \"TableRangeScan\",\n@@ -260,6 +250,28 @@\n                                                                                                         }\n                                                                                                     }\n                                                                                                 },\n+                                                                                                {\n+                                                                                                    \"GroupBy\": {\n+                                                                                                        \"Aggregates\": [\n+                                                                                                            {\n+                                                                                                                \"Column\": {\n+                                                                                                                    \"Id\": 114\n+                                                                                                                },\n+                                                                                                                \"Function\": {\n+                                                                                                                    \"Id\": 2\n+                                                                                                                }\n+                                                                                                            }\n+                                                                                                        ],\n+                                                                                                        \"KeyColumns\": [\n+                                                                                                            {\n+                                                                                                                \"Id\": 44\n+                                                                                                            },\n+                                                                                                            {\n+                                                                                                                \"Id\": 43\n+                                                                                                            }\n+                                                                                                        ]\n+                                                                                                    }\n+                                                                                                },\n                                                                                                 {\n                                                                                                     \"Projection\": {\n                                                                                                         \"Columns\": [\n@@ -268,6 +280,9 @@\n                                                                                                             },\n                                                                                                             {\n                                                                                                                 \"Id\": 43\n+                                                                                                            },\n+                                                                                                            {\n+                                                                                                                \"Id\": 114\n                                                                                                             }\n                                                                                                         ]\n                                                                                                     }\n@@ -354,198 +369,210 @@\n                                                         \"PlanNodeId\": 7,\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate\",\n+                                                                \"Node Type\": \"TableRangeScan\",\n                                                                 \"Operators\": [\n                                                                     {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"\",\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    }\n-                                                                ],\n-                                                                \"PlanNodeId\": 9,\n-                                                                \"Plans\": [\n-                                                                    {\n-                                                                        \"Node Type\": \"TableRangeScan\",\n-                                                                        \"Operators\": [\n-                                                                            {\n-                                                                                \"Name\": \"TableRangeScan\",\n-                                                                                \"ReadColumns\": [\n-                                                                                    \"DontCountHits\",\n-                                                                                    \"IsRefresh\",\n-                                                                                    \"URLHash\",\n-                                                                                    \"WindowClientHeight\",\n-                                                                                    \"WindowClientWidth\"\n-                                                                                ],\n-                                                                                \"ReadRanges\": [\n-                                                                                    \"CounterID [62, 62]\",\n-                                                                                    \"EventDate [15887, 15917]\"\n-                                                                                ],\n-                                                                                \"ReadRangesExpectedSize\": 1,\n-                                                                                \"ReadRangesKeys\": [\n-                                                                                    \"CounterID\",\n-                                                                                    \"EventDate\"\n-                                                                                ],\n-                                                                                \"Scan\": \"Parallel\",\n-                                                                                \"SsaProgram\": {\n-                                                                                    \"Command\": [\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 106\n-                                                                                                },\n-                                                                                                \"Constant\": {\n-                                                                                                    \"Int32\": 0\n-                                                                                                }\n-                                                                                            }\n+                                                                        \"Name\": \"TableRangeScan\",\n+                                                                        \"ReadColumns\": [\n+                                                                            \"DontCountHits\",\n+                                                                            \"IsRefresh\",\n+                                                                            \"URLHash\",\n+                                                                            \"WindowClientHeight\",\n+                                                                            \"WindowClientWidth\"\n+                                                                        ],\n+                                                                        \"ReadRanges\": [\n+                                                                            \"CounterID [62, 62]\",\n+                                                                            \"EventDate [15887, 15917]\"\n+                                                                        ],\n+                                                                        \"ReadRangesExpectedSize\": 1,\n+                                                                        \"ReadRangesKeys\": [\n+                                                                            \"CounterID\",\n+                                                                            \"EventDate\"\n+                                                                        ],\n+                                                                        \"Scan\": \"Parallel\",\n+                                                                        \"SsaProgram\": {\n+                                                                            \"Command\": [\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 106\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 107\n-                                                                                                },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 16\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 106\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 0,\n-                                                                                                    \"YqlOperationId\": 11\n-                                                                                                }\n-                                                                                            }\n+                                                                                        \"Constant\": {\n+                                                                                            \"Int32\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 107\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 108\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 16\n                                                                                                 },\n-                                                                                                \"Constant\": {\n-                                                                                                    \"Int32\": 0\n+                                                                                                {\n+                                                                                                    \"Id\": 106\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 0,\n+                                                                                            \"YqlOperationId\": 11\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 108\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 109\n+                                                                                        \"Constant\": {\n+                                                                                            \"Int32\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 109\n+                                                                                        },\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 62\n                                                                                                 },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 62\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 108\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 1,\n-                                                                                                    \"YqlOperationId\": 11\n+                                                                                                {\n+                                                                                                    \"Id\": 108\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 1,\n+                                                                                            \"YqlOperationId\": 11\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 110\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 110\n+                                                                                        \"Constant\": {\n+                                                                                            \"Int64\": 2868770270353813622\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 111\n+                                                                                        },\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 104\n                                                                                                 },\n-                                                                                                \"Constant\": {\n-                                                                                                    \"Int64\": 2868770270353813622\n+                                                                                                {\n+                                                                                                    \"Id\": 110\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 2,\n+                                                                                            \"YqlOperationId\": 11\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 112\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 111\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 109\n                                                                                                 },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 104\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 110\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 2,\n-                                                                                                    \"YqlOperationId\": 11\n+                                                                                                {\n+                                                                                                    \"Id\": 111\n                                                                                                 }\n-                                                                                            }\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 3,\n+                                                                                            \"YqlOperationId\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Assign\": {\n+                                                                                        \"Column\": {\n+                                                                                            \"Id\": 113\n                                                                                         },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n-                                                                                                \"Column\": {\n-                                                                                                    \"Id\": 112\n+                                                                                        \"Function\": {\n+                                                                                            \"Arguments\": [\n+                                                                                                {\n+                                                                                                    \"Id\": 107\n                                                                                                 },\n-                                                                                                \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 109\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 111\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 3,\n-                                                                                                    \"YqlOperationId\": 0\n+                                                                                                {\n+                                                                                                    \"Id\": 112\n                                                                                                 }\n-                                                                                            }\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Assign\": {\n+                                                                                            ],\n+                                                                                            \"FunctionType\": 2,\n+                                                                                            \"KernelIdx\": 4,\n+                                                                                            \"YqlOperationId\": 0\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"Filter\": {\n+                                                                                        \"Predicate\": {\n+                                                                                            \"Id\": 113\n+                                                                                        }\n+                                                                                    }\n+                                                                                },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n                                                                                                 \"Column\": {\n-                                                                                                    \"Id\": 113\n+                                                                                                    \"Id\": 114\n                                                                                                 },\n                                                                                                 \"Function\": {\n-                                                                                                    \"Arguments\": [\n-                                                                                                        {\n-                                                                                                            \"Id\": 107\n-                                                                                                        },\n-                                                                                                        {\n-                                                                                                            \"Id\": 112\n-                                                                                                        }\n-                                                                                                    ],\n-                                                                                                    \"FunctionType\": 2,\n-                                                                                                    \"KernelIdx\": 4,\n-                                                                                                    \"YqlOperationId\": 0\n+                                                                                                    \"Id\": 2\n                                                                                                 }\n                                                                                             }\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Filter\": {\n-                                                                                                \"Predicate\": {\n-                                                                                                    \"Id\": 113\n-                                                                                                }\n-                                                                                            }\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Projection\": {\n-                                                                                                \"Columns\": [\n-                                                                                                    {\n-                                                                                                        \"Id\": 44\n-                                                                                                    },\n-                                                                                                    {\n-                                                                                                        \"Id\": 43\n-                                                                                                    }\n-                                                                                                ]\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 44\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 43\n                                                                                             }\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"Version\": 4\n+                                                                                        ]\n+                                                                                    }\n                                                                                 },\n-                                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                                            }\n-                                                                        ],\n-                                                                        \"PlanNodeId\": 10\n+                                                                                {\n+                                                                                    \"Projection\": {\n+                                                                                        \"Columns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 44\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 43\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 114\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                }\n+                                                                            ],\n+                                                                            \"Version\": 4\n+                                                                        },\n+                                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                                     }\n-                                                                ]\n+                                                                ],\n+                                                                \"PlanNodeId\": 9\n                                                             }\n                                                         ]\n                                                     }\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-7 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-7\nindex c875bd726155..49b95b51d14e 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-7\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-7\n@@ -59,18 +59,8 @@\n                                                         \"PlanNodeType\": \"Connection\",\n                                                         \"Plans\": [\n                                                             {\n-                                                                \"Node Type\": \"Aggregate-TableFullScan\",\n+                                                                \"Node Type\": \"TableFullScan\",\n                                                                 \"Operators\": [\n-                                                                    {\n-                                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                                        \"GroupBy\": \"item.AdvEngineID\",\n-                                                                        \"Inputs\": [\n-                                                                            {\n-                                                                                \"InternalOperatorId\": 1\n-                                                                            }\n-                                                                        ],\n-                                                                        \"Name\": \"Aggregate\"\n-                                                                    },\n                                                                     {\n                                                                         \"Inputs\": [],\n                                                                         \"Name\": \"TableFullScan\",\n@@ -124,11 +114,33 @@\n                                                                                         }\n                                                                                     }\n                                                                                 },\n+                                                                                {\n+                                                                                    \"GroupBy\": {\n+                                                                                        \"Aggregates\": [\n+                                                                                            {\n+                                                                                                \"Column\": {\n+                                                                                                    \"Id\": 108\n+                                                                                                },\n+                                                                                                \"Function\": {\n+                                                                                                    \"Id\": 2\n+                                                                                                }\n+                                                                                            }\n+                                                                                        ],\n+                                                                                        \"KeyColumns\": [\n+                                                                                            {\n+                                                                                                \"Id\": 41\n+                                                                                            }\n+                                                                                        ]\n+                                                                                    }\n+                                                                                },\n                                                                                 {\n                                                                                     \"Projection\": {\n                                                                                         \"Columns\": [\n                                                                                             {\n                                                                                                 \"Id\": 41\n+                                                                                            },\n+                                                                                            {\n+                                                                                                \"Id\": 108\n                                                                                             }\n                                                                                         ]\n                                                                                     }\n@@ -191,89 +203,98 @@\n                                         \"PlanNodeId\": 4,\n                                         \"Plans\": [\n                                             {\n-                                                \"Node Type\": \"Aggregate\",\n+                                                \"Node Type\": \"TableFullScan\",\n                                                 \"Operators\": [\n                                                     {\n-                                                        \"Aggregation\": \"{_yql_agg_0: SUM(state._yql_agg_0,1)}\",\n-                                                        \"GroupBy\": \"item.AdvEngineID\",\n-                                                        \"Name\": \"Aggregate\"\n-                                                    }\n-                                                ],\n-                                                \"PlanNodeId\": 6,\n-                                                \"Plans\": [\n-                                                    {\n-                                                        \"Node Type\": \"TableFullScan\",\n-                                                        \"Operators\": [\n-                                                            {\n-                                                                \"Name\": \"TableFullScan\",\n-                                                                \"ReadColumns\": [\n-                                                                    \"AdvEngineID\"\n-                                                                ],\n-                                                                \"ReadRanges\": [\n-                                                                    \"CounterID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventDate (-\\u221e, +\\u221e)\",\n-                                                                    \"UserID (-\\u221e, +\\u221e)\",\n-                                                                    \"EventTime (-\\u221e, +\\u221e)\",\n-                                                                    \"WatchID (-\\u221e, +\\u221e)\"\n-                                                                ],\n-                                                                \"Scan\": \"Parallel\",\n-                                                                \"SsaProgram\": {\n-                                                                    \"Command\": [\n-                                                                        {\n-                                                                            \"Assign\": {\n-                                                                                \"Column\": {\n-                                                                                    \"Id\": 106\n+                                                        \"Name\": \"TableFullScan\",\n+                                                        \"ReadColumns\": [\n+                                                            \"AdvEngineID\"\n+                                                        ],\n+                                                        \"ReadRanges\": [\n+                                                            \"CounterID (-\\u221e, +\\u221e)\",\n+                                                            \"EventDate (-\\u221e, +\\u221e)\",\n+                                                            \"UserID (-\\u221e, +\\u221e)\",\n+                                                            \"EventTime (-\\u221e, +\\u221e)\",\n+                                                            \"WatchID (-\\u221e, +\\u221e)\"\n+                                                        ],\n+                                                        \"Scan\": \"Parallel\",\n+                                                        \"SsaProgram\": {\n+                                                            \"Command\": [\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 106\n+                                                                        },\n+                                                                        \"Constant\": {\n+                                                                            \"Int32\": 0\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Assign\": {\n+                                                                        \"Column\": {\n+                                                                            \"Id\": 107\n+                                                                        },\n+                                                                        \"Function\": {\n+                                                                            \"Arguments\": [\n+                                                                                {\n+                                                                                    \"Id\": 41\n                                                                                 },\n-                                                                                \"Constant\": {\n-                                                                                    \"Int32\": 0\n+                                                                                {\n+                                                                                    \"Id\": 106\n                                                                                 }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Assign\": {\n+                                                                            ],\n+                                                                            \"FunctionType\": 2,\n+                                                                            \"KernelIdx\": 0,\n+                                                                            \"YqlOperationId\": 12\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"Filter\": {\n+                                                                        \"Predicate\": {\n+                                                                            \"Id\": 107\n+                                                                        }\n+                                                                    }\n+                                                                },\n+                                                                {\n+                                                                    \"GroupBy\": {\n+                                                                        \"Aggregates\": [\n+                                                                            {\n                                                                                 \"Column\": {\n-                                                                                    \"Id\": 107\n+                                                                                    \"Id\": 108\n                                                                                 },\n                                                                                 \"Function\": {\n-                                                                                    \"Arguments\": [\n-                                                                                        {\n-                                                                                            \"Id\": 41\n-                                                                                        },\n-                                                                                        {\n-                                                                                            \"Id\": 106\n-                                                                                        }\n-                                                                                    ],\n-                                                                                    \"FunctionType\": 2,\n-                                                                                    \"KernelIdx\": 0,\n-                                                                                    \"YqlOperationId\": 12\n+                                                                                    \"Id\": 2\n                                                                                 }\n                                                                             }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Filter\": {\n-                                                                                \"Predicate\": {\n-                                                                                    \"Id\": 107\n-                                                                                }\n-                                                                            }\n-                                                                        },\n-                                                                        {\n-                                                                            \"Projection\": {\n-                                                                                \"Columns\": [\n-                                                                                    {\n-                                                                                        \"Id\": 41\n-                                                                                    }\n-                                                                                ]\n+                                                                        ],\n+                                                                        \"KeyColumns\": [\n+                                                                            {\n+                                                                                \"Id\": 41\n                                                                             }\n-                                                                        }\n-                                                                    ],\n-                                                                    \"Version\": 4\n+                                                                        ]\n+                                                                    }\n                                                                 },\n-                                                                \"Table\": \"clickbench/plans/column/hits\"\n-                                                            }\n-                                                        ],\n-                                                        \"PlanNodeId\": 7\n+                                                                {\n+                                                                    \"Projection\": {\n+                                                                        \"Columns\": [\n+                                                                            {\n+                                                                                \"Id\": 41\n+                                                                            },\n+                                                                            {\n+                                                                                \"Id\": 108\n+                                                                            }\n+                                                                        ]\n+                                                                    }\n+                                                                }\n+                                                            ],\n+                                                            \"Version\": 4\n+                                                        },\n+                                                        \"Table\": \"clickbench/plans/column/hits\"\n                                                     }\n-                                                ]\n+                                                ],\n+                                                \"PlanNodeId\": 6\n                                             }\n                                         ]\n                                     }\ndiff --git a/ydb/tests/functional/clickbench/ya.make b/ydb/tests/functional/clickbench/ya.make\nindex b5a9a9fdc516..1ce9642b70df 100644\n--- a/ydb/tests/functional/clickbench/ya.make\n+++ b/ydb/tests/functional/clickbench/ya.make\n@@ -9,6 +9,7 @@ SIZE(MEDIUM)\n \n ENV(YDB_USE_IN_MEMORY_PDISKS=true)\n ENV(YDB_CLI_BINARY=\"ydb/apps/ydb/ydb\")\n+ENV(YDB_ENABLE_COLUMN_TABLES=\"true\")\n REQUIREMENTS(\n     ram:32\n     cpu:4\ndiff --git a/ydb/tests/functional/scheme_tests/canondata/tablet_scheme_tests.TestTabletSchemes.test_tablet_schemes_flat_schemeshard_/flat_schemeshard.schema b/ydb/tests/functional/scheme_tests/canondata/tablet_scheme_tests.TestTabletSchemes.test_tablet_schemes_flat_schemeshard_/flat_schemeshard.schema\nindex 804ca76f1716..02b8cd6f6188 100644\n--- a/ydb/tests/functional/scheme_tests/canondata/tablet_scheme_tests.TestTabletSchemes.test_tablet_schemes_flat_schemeshard_/flat_schemeshard.schema\n+++ b/ydb/tests/functional/scheme_tests/canondata/tablet_scheme_tests.TestTabletSchemes.test_tablet_schemes_flat_schemeshard_/flat_schemeshard.schema\n@@ -1448,6 +1448,11 @@\n                 \"ColumnId\": 31,\n                 \"ColumnName\": \"ServerlessComputeResourcesMode\",\n                 \"ColumnType\": \"Uint32\"\n+            },\n+            {\n+                \"ColumnId\": 32,\n+                \"ColumnName\": \"ColumnTableColumnsLimit\",\n+                \"ColumnType\": \"Uint64\"\n             }\n         ],\n         \"ColumnsDropped\": [],\n@@ -1484,7 +1489,8 @@\n                     28,\n                     29,\n                     30,\n-                    31\n+                    31,\n+                    32\n                 ],\n                 \"RoomID\": 0,\n                 \"Codec\": 0,\ndiff --git a/ydb/tests/functional/ydb_cli/ya.make b/ydb/tests/functional/ydb_cli/ya.make\nindex 678b5cd39f6e..1e4310e5e7fc 100644\n--- a/ydb/tests/functional/ydb_cli/ya.make\n+++ b/ydb/tests/functional/ydb_cli/ya.make\n@@ -10,6 +10,7 @@ TEST_SRCS(\n \n ENV(YDB_DRIVER_BINARY=\"ydb/apps/ydbd/ydbd\")\n ENV(YDB_CLI_BINARY=\"ydb/apps/ydb/ydb\")\n+ENV(YDB_ENABLE_COLUMN_TABLES=\"true\")\n TIMEOUT(600)\n SIZE(MEDIUM)\n \ndiff --git a/ydb/tests/library/harness/kikimr_config.py b/ydb/tests/library/harness/kikimr_config.py\nindex ff214228d453..3baa281fdd75 100644\n--- a/ydb/tests/library/harness/kikimr_config.py\n+++ b/ydb/tests/library/harness/kikimr_config.py\n@@ -83,6 +83,8 @@ def load_default_yaml(default_tablet_node_ids, ydb_domain_name, static_erasure,\n     yaml_dict[\"log_config\"][\"entry\"] = []\n     for log, level in six.iteritems(log_configs):\n         yaml_dict[\"log_config\"][\"entry\"].append({\"component\": log, \"level\": int(level)})\n+    if os.getenv(\"YDB_ENABLE_COLUMN_TABLES\", \"\") == \"true\":\n+        yaml_dict |= {\"column_shard_config\": {\"disabled_on_scheme_shard\": False}}\n     return yaml_dict\n \n \ndiff --git a/ydb/tests/library/harness/kikimr_runner.py b/ydb/tests/library/harness/kikimr_runner.py\nindex b6f6c5066037..df67478a78af 100644\n--- a/ydb/tests/library/harness/kikimr_runner.py\n+++ b/ydb/tests/library/harness/kikimr_runner.py\n@@ -613,33 +613,36 @@ def can_update(self):\n \n     def start(self):\n         if self.__slot_id is None:\n-            return self.ssh_command(\"sudo start kikimr\")\n-        return self.ssh_command(\n-            [\n-                \"sudo\", \"start\",\n-                \"kikimr-multi\",\n-                \"slot={}\".format(self.__slot_id),\n-                \"tenant=/Root/db1\",\n-                \"mbus={}\".format(self.__mbus_port),\n-                \"grpc={}\".format(self.__grpc_port),\n-                \"mon={}\".format(self.__mon_port),\n-                \"ic={}\".format(self.__ic_port),\n-            ]\n+            return self.ssh_command(\"sudo service kikimr start\")\n+\n+        slot_dir = \"/Berkanavt/kikimr_{slot}\".format(slot=self.__slot_id)\n+        slot_cfg = slot_dir + \"/slot_cfg\"\n+        env_txt = slot_dir + \"/env.txt\"\n+\n+        cfg = \"\"\"\\\n+tenant=/Root/db1\n+grpc={grpc}\n+mbus={mbus}\n+ic={ic}\n+mon={mon}\"\"\".format(\n+            mbus=self.__mbus_port,\n+            grpc=self.__grpc_port,\n+            mon=self.__mon_port,\n+            ic=self.__ic_port,\n         )\n \n+        self.ssh_command([\"sudo\", \"mkdir\", slot_dir])\n+        self.ssh_command([\"sudo\", \"touch\", env_txt])\n+        self.ssh_command([\"/bin/echo\", \"-e\", \"\\\"{}\\\"\".format(cfg),  \"|\", \"sudo\", \"tee\", slot_cfg])\n+\n+        return self.ssh_command([\"sudo\", \"systemctl\", \"start\", \"kikimr-multi@{}\".format(self.__slot_id)])\n+\n     def stop(self):\n         if self.__slot_id is None:\n-            return self.ssh_command(\"sudo stop kikimr\")\n+            return self.ssh_command(\"sudo service kikimr stop\")\n         return self.ssh_command(\n             [\n-                \"sudo\", \"stop\",\n-                \"kikimr-multi\",\n-                \"slot={}\".format(self.__slot_id),\n-                \"tenant=/Root/db1\",\n-                \"mbus={}\".format(self.__mbus_port),\n-                \"grpc={}\".format(self.__grpc_port),\n-                \"mon={}\".format(self.__mon_port),\n-                \"ic={}\".format(self.__ic_port),\n+                \"sudo\", \"systemctl\", \"start\", \"kikimr-multi@{}\".format(self.__slot_id),\n             ]\n         )\n \ndiff --git a/ydb/tests/library/harness/resources/default_yaml.yml b/ydb/tests/library/harness/resources/default_yaml.yml\nindex dc8eea16bf2e..7090fad7dedc 100644\n--- a/ydb/tests/library/harness/resources/default_yaml.yml\n+++ b/ydb/tests/library/harness/resources/default_yaml.yml\n@@ -256,5 +256,3 @@ federated_query_config:\n       uri: \"\"\n   pinger:\n     ping_period: \"30s\"\n-column_shard_config:\n-  disabled_on_scheme_shard: false\ndiff --git a/ydb/tests/olap/scenario/conftest.py b/ydb/tests/olap/scenario/conftest.py\nindex 51de3c62ada0..533375e989d4 100644\n--- a/ydb/tests/olap/scenario/conftest.py\n+++ b/ydb/tests/olap/scenario/conftest.py\n@@ -19,7 +19,8 @@ def get_suite_name(cls):\n \n     @classmethod\n     def setup_class(cls):\n-        ScenarioTestHelper(None).remove_path(cls.get_suite_name())\n+        if not external_param_is_true('reuse-tables'):\n+            ScenarioTestHelper(None).remove_path(cls.get_suite_name())\n \n     @classmethod\n     def teardown_class(cls):\ndiff --git a/ydb/tests/olap/scenario/helpers/data_generators.py b/ydb/tests/olap/scenario/helpers/data_generators.py\nindex 4945415a1085..286f4d8347a0 100644\n--- a/ydb/tests/olap/scenario/helpers/data_generators.py\n+++ b/ydb/tests/olap/scenario/helpers/data_generators.py\n@@ -42,14 +42,30 @@ def next_row(self) -> None:\n         pass\n \n \n-class ColumnValueGeneratorNull(IColumnValueGenerator):\n-    \"\"\"NULL column value generator.\n+class ColumnValueGeneratorConst(IColumnValueGenerator):\n+    \"\"\"Const column value generator.\n \n-    Allways generate NULL value.\"\"\"\n+    Allways generate specified value.\"\"\"\n+\n+    def __init__(self, value: Any) -> None:\n+        \"\"\"Constructor.\n+\n+         Args:\n+            value: Value to generate.\n+        Example:\n+            DataGeneratorPerColumn(\n+                self.schema2, 10,\n+                ColumnValueGeneratorDefault(init_value=10))\n+                    .with_column('not_level', ColumnValueGeneratorConst(42)\n+            )\n+        \"\"\"\n+\n+        super().__init__()\n+        self._value = value\n \n     @override\n-    def generate_value(column: ScenarioTestHelper.Column) -> Any:\n-        return None\n+    def generate_value(self, column: ScenarioTestHelper.Column) -> Any:\n+        return self._value\n \n \n class ColumnValueGeneratorRandom(IColumnValueGenerator):\ndiff --git a/ydb/tests/olap/scenario/helpers/table_helper.py b/ydb/tests/olap/scenario/helpers/table_helper.py\nindex ef2088ecd692..8b1963fd13e0 100644\n--- a/ydb/tests/olap/scenario/helpers/table_helper.py\n+++ b/ydb/tests/olap/scenario/helpers/table_helper.py\n@@ -218,6 +218,69 @@ def title(self) -> str:\n         return f'drop column `{self._column}`'\n \n \n+class SetSetting(AlterTableAction):\n+    \"\"\"Set a setting value for a table-like object.\n+\n+     Table-like objects are Tables and TableStore.\n+     See {AlterTableLikeObject}.\n+\n+    Example:\n+        sth = ScenarioTestHelper(ctx)\n+        sth.execute_scheme_query(\n+            AlterTable('testTable').action(SetSetting('TIERING', 'tiering1))\n+        )\n+    \"\"\"\n+\n+    def __init__(self, setting: str, value_literal: str) -> None:\n+        \"\"\"Constructor.\n+\n+        Args:\n+            column: Name of the column to be deleted.\"\"\"\n+\n+        super().__init__()\n+        self._setting = setting\n+        self._value = value_literal\n+\n+    @override\n+    def to_yql(self) -> str:\n+        return f'SET {self._setting} {self._value}'\n+\n+    @override\n+    def title(self) -> str:\n+        return f'set {self._setting} = {self._value}'\n+\n+\n+class ResetSetting(AlterTableAction):\n+    \"\"\"Reset value of a setting for a table-like object.\n+\n+     Table-like objects are Tables and TableStore.\n+     See {AlterTableLikeObject}.\n+\n+    Example:\n+        sth = ScenarioTestHelper(ctx)\n+        sth.execute_scheme_query(\n+            AlterTable('testTable').action(ResetSetting('TIERING'))\n+        )\n+    \"\"\"\n+\n+    def __init__(self, setting: str) -> None:\n+        \"\"\"Constructor.\n+\n+        Args:\n+            setting: Name of altered setting.\"\"\"\n+\n+        super().__init__()\n+        self._setting = setting\n+\n+    @override\n+    def to_yql(self) -> str:\n+        return f'RESET ({self._setting})'\n+\n+    @override\n+    def title(self) -> str:\n+        return f'reset {self._setting}'\n+\n+\n class AlterTableLikeObject(ScenarioTestHelper.IYqlble):\n     \"\"\"The base class for all requests to change table-like objects.\n \n@@ -277,6 +340,42 @@ def drop_column(self, column: str) -> AlterTableLikeObject:\n \n         return self(DropColumn(column))\n \n+    def set_tiering(self, tiering_rule: str) -> AlterTableLikeObject:\n+        \"\"\"Set a tiering policy.\n+\n+        The method is similar to calling {AlterTableLikeObject.action} with a {SetSetting} instance.\n+\n+        Args:\n+            tiering_rule: Name of a TIERING_RULE object.\n+\n+        Returns:\n+            self.\"\"\"\n+\n+        return self(SetSetting('TIERING', f'\"{tiering_rule}\"'))\n+\n+    def reset_tiering(self) -> AlterTableLikeObject:\n+        \"\"\"Remove a tiering policy.\n+\n+        The method is similar to calling {AlterTableLikeObject.action} with a {SetSetting} instance.\n+\n+        Returns:\n+            self.\"\"\"\n+\n+        return self(ResetSetting('TIERING'))\n+\n+    def set_ttl(self, interval: str, column: str) -> AlterTableLikeObject:\n+        \"\"\"Set TTL for rows.\n+\n+        The method is similar to calling {AlterTableLikeObject.action} with a {SetSetting} instance.\n+\n+        Args:\n+            tiering_rule: Name of a TIERING_RULE object.\n+\n+        Returns:\n+            self.\"\"\"\n+\n+        return self(SetSetting('TTL', f'Interval(\"{interval}\") ON `{column}`'))\n+\n     @override\n     def params(self) -> Dict[str, str]:\n         return {self._type(): self._name, 'actions': ', '.join([a.title() for a in self._actions])}\ndiff --git a/ydb/tests/olap/scenario/helpers/tiering_helper.py b/ydb/tests/olap/scenario/helpers/tiering_helper.py\nnew file mode 100644\nindex 000000000000..712aed66cac9\n--- /dev/null\n+++ b/ydb/tests/olap/scenario/helpers/tiering_helper.py\n@@ -0,0 +1,246 @@\n+from __future__ import annotations\n+from ydb.tests.olap.scenario.helpers.scenario_tests_helper import (\n+    ScenarioTestHelper,\n+    TestContext,\n+)\n+from abc import abstractmethod\n+\n+from typing import override, Dict\n+from dataclasses import dataclass\n+import json\n+\n+\n+@dataclass\n+class ObjectStorageParams:\n+    endpoint: str\n+    bucket: str\n+    access_key: str\n+    secret_key: str\n+    scheme: str = 'HTTP'\n+    verify_ssl: bool = False\n+\n+    def to_proto_str(self) -> str:\n+        return (\n+            f'Scheme: {self.scheme}\\n'\n+            f'VerifySSL: {str(self.verify_ssl).lower()}\\n'\n+            f'Endpoint: \"{self.endpoint}\"\\n'\n+            f'Bucket: \"{self.bucket}\"\\n'\n+            f'AccessKey: \"{self.access_key}\"\\n'\n+            f'SecretKey: \"{self.secret_key}\"\\n'\n+        )\n+\n+\n+@dataclass\n+class TieringRule:\n+    tier_name: str\n+    duration_for_evict: str\n+\n+    def to_dict(self):\n+        return {\n+            'tierName': self.tier_name,\n+            'durationForEvict': self.duration_for_evict,\n+        }\n+\n+\n+@dataclass\n+class TieringPolicy:\n+    rules: list[TieringRule]\n+\n+    def __init__(self):\n+        self.rules = []\n+\n+    def with_rule(self, rule: TieringRule):\n+        self.rules.append(rule)\n+        return self\n+\n+    def to_json(self) -> str:\n+        return json.dumps({'rules': list(map(lambda x: x.to_dict(), self.rules))})\n+\n+\n+@dataclass\n+class TierConfig:\n+    name: str\n+    s3_params: ObjectStorageParams\n+\n+    def to_proto_str(self) -> str:\n+        return (\n+            f'Name: \"{self.name}\"\\n'\n+            f'ObjectStorage: {{\\n{self.s3_params.to_proto_str()}\\n}}'\n+        )\n+\n+\n+class AlterTieringRule(ScenarioTestHelper.IYqlble):\n+    \"\"\"Alter a tiering rule.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    def __init__(self, name: str, default_column: str, config: TieringPolicy) -> None:\n+        \"\"\"Constructor.\n+\n+        Args:\n+            name: Name (relative path) of the altered object.\n+            default_column: Default column used for tiering.\n+            config: Tiering rules to apply.\"\"\"\n+\n+        super().__init__(name)\n+        self._default_column: str = default_column\n+        self._config: TieringPolicy = config\n+\n+    @override\n+    def params(self) -> Dict[str, str]:\n+        return {'tiering_rule': self._name, 'config': self._config.to_json()}\n+\n+    @override\n+    def title(self):\n+        return 'Alter tiering rule'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'ALTER OBJECT `{self._name}` (TYPE TIERING_RULE)' \\\n+               f' SET (defaultColumn = {self._default_column}, description = `{self._config.to_json()}`)'\n+\n+\n+class CreateTieringRule(AlterTieringRule):\n+    \"\"\"Create a tiering rule.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    @override\n+    def title(self):\n+        return 'Create tiering rule'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'CREATE OBJECT `{self._name}` (TYPE TIERING_RULE)' \\\n+               f' WITH (defaultColumn = {self._default_column}, description = `{self._config.to_json()}`)'\n+\n+\n+class CreateTieringRuleIfNotExists(AlterTieringRule):\n+    \"\"\"Create a tiering rule. If it exists, do nothing.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    @override\n+    def title(self):\n+        return 'Create tiering rule'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'CREATE OBJECT IF NOT EXISTS `{self._name}` (TYPE TIERING_RULE)' \\\n+               f' WITH (defaultColumn = {self._default_column}, description = `{self._config.to_json()}`)'\n+\n+\n+class AlterTier(ScenarioTestHelper.IYqlble):\n+    \"\"\"Alter a tier.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    def __init__(self, name: str, config: TierConfig) -> None:\n+        \"\"\"Constructor.\n+\n+        Args:\n+            name: Name (relative path) of the altered object.\n+            config: Tier configuration.\"\"\"\n+\n+        super().__init__(name)\n+        self._config: TierConfig = config\n+\n+    @override\n+    def params(self) -> Dict[str, str]:\n+        return {'tier': self._name, 'config': self._config.to_proto_str()}\n+\n+    @override\n+    def title(self):\n+        return 'Alter tier'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'ALTER OBJECT `{self._name}` (TYPE TIER) SET (tierConfig = `{self._config.to_proto_str()}`)'\n+\n+\n+class CreateTier(AlterTier):\n+    \"\"\"Create a tier.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    @override\n+    def title(self):\n+        return 'Create tier'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'CREATE OBJECT `{self._name}` (TYPE TIER) WITH (tierConfig = `{self._config.to_proto_str()}`)'\n+\n+\n+class CreateTierIfNotExists(AlterTier):\n+    \"\"\"Create a tier. If it exists, do nothing.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    @override\n+    def title(self):\n+        return 'Create tier'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'CREATE OBJECT IF NOT EXISTS `{self._name}` (TYPE TIER)' \\\n+               f' WITH (tierConfig = `{self._config.to_proto_str()}`)'\n+\n+\n+class DropObjectBase(ScenarioTestHelper.IYqlble):\n+    \"\"\"Drop a tier.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    def __init__(self, name: str) -> None:\n+        \"\"\"Constructor.\n+\n+        Args:\n+            name: Name (relative path) of the altered object.\"\"\"\n+\n+        super().__init__(name)\n+\n+    @override\n+    def params(self) -> Dict[str, str]:\n+        return {'object_type': self._object_type()}\n+\n+    @override\n+    def title(self):\n+        return f'Drop {self._object_type().lower()}'\n+\n+    @override\n+    def to_yql(self, ctx: TestContext) -> str:\n+        return f'DROP OBJECT `{self._name}` (TYPE {self._object_type()})'\n+\n+    @abstractmethod\n+    def _object_type(self) -> str:\n+        pass\n+\n+\n+class DropTier(DropObjectBase):\n+    \"\"\"Drop a tier.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    @override\n+    def _object_type(self):\n+        return 'TIER'\n+\n+\n+class DropTieringRule(DropObjectBase):\n+    \"\"\"Drop a tier.\n+\n+     See {ScenarioTestHelper.IYqlble}.\n+    \"\"\"\n+\n+    @override\n+    def _object_type(self):\n+        return 'TIERING_RULE'\ndiff --git a/ydb/tests/olap/scenario/test_alter_tiering.py b/ydb/tests/olap/scenario/test_alter_tiering.py\nnew file mode 100644\nindex 000000000000..d82087e7a217\n--- /dev/null\n+++ b/ydb/tests/olap/scenario/test_alter_tiering.py\n@@ -0,0 +1,152 @@\n+from conftest import BaseTestSet\n+from ydb.tests.olap.scenario.helpers import (\n+    ScenarioTestHelper,\n+    TestContext,\n+    CreateTable,\n+    CreateTableStore,\n+    DropTable,\n+)\n+from helpers.tiering_helper import (\n+    ObjectStorageParams,\n+    AlterTier,\n+    CreateTierIfNotExists,\n+    AlterTieringRule,\n+    CreateTieringRuleIfNotExists,\n+    TierConfig,\n+    TieringPolicy,\n+    TieringRule,\n+    DropTier,\n+    DropTieringRule,\n+)\n+import helpers.data_generators as dg\n+from helpers.table_helper import AlterTable\n+\n+from ydb.tests.olap.lib.utils import get_external_param\n+from ydb import PrimitiveType\n+import datetime\n+import random\n+import threading\n+from typing import Iterable\n+import time\n+\n+\n+class TestAlterTiering(BaseTestSet):\n+    schema1 = (\n+        ScenarioTestHelper.Schema()\n+        .with_column(name='timestamp', type=PrimitiveType.Timestamp, not_null=True)\n+        .with_column(name='writer', type=PrimitiveType.Uint32, not_null=True)\n+        .with_column(name='value', type=PrimitiveType.Uint64, not_null=True)\n+        .with_column(name='data', type=PrimitiveType.String, not_null=True)\n+        .with_key_columns('timestamp', 'writer', 'value')\n+    )\n+\n+    class TestThread(threading.Thread):\n+        def run(self) -> None:\n+            self.exc = None\n+            try:\n+                self.ret = self._target(*self._args, **self._kwargs)\n+            except BaseException as e:\n+                self.exc = e\n+\n+        def join(self, timeout=None):\n+            super().join(timeout)\n+            if self.exc:\n+                raise self.exc\n+            return self.ret\n+\n+    def _drop_tables(self, prefix: str, count: int, ctx: TestContext):\n+        sth = ScenarioTestHelper(ctx)\n+        for i in range(count):\n+            sth.execute_scheme_query(DropTable(f'store/{prefix}_{i}'))\n+\n+    def _upsert(self, ctx: TestContext, table: str, writer_id: int, duration: datetime.timedelta):\n+        deadline = datetime.datetime.now() + duration\n+        sth = ScenarioTestHelper(ctx)\n+        rows_written = 0\n+        i = 0\n+        while datetime.datetime.now() < deadline:\n+            sth.bulk_upsert(\n+                table,\n+                dg.DataGeneratorPerColumn(self.schema1, 1000)\n+                .with_column('timestamp', dg.ColumnValueGeneratorRandom(null_probability=0))\n+                .with_column('writer', dg.ColumnValueGeneratorConst(writer_id))\n+                .with_column('value', dg.ColumnValueGeneratorSequential(rows_written))\n+                .with_column('data', dg.ColumnValueGeneratorConst(random.randbytes(1024)))\n+            )\n+            rows_written += 1000\n+            i += 1\n+            if rows_written > 100000 and i % 10 == 0:\n+                scan_result = sth.execute_scan_query(f'SELECT COUNT(*) FROM `{sth.get_full_path(\"store/table\")}` WHERE writer == {writer_id}')\n+                assert scan_result.result_set.rows[0][0] == rows_written\n+\n+    def _change_tiering_rule(self, ctx: TestContext, table: str, tiering_rules: Iterable[str], duration: datetime.timedelta):\n+        deadline = datetime.datetime.now() + duration\n+        sth = ScenarioTestHelper(ctx)\n+        while datetime.datetime.now() < deadline:\n+            for tiering_rule in tiering_rules:\n+                sth.execute_scheme_query(AlterTable(table).set_tiering(tiering_rule))\n+            sth.execute_scheme_query(AlterTable(table).reset_tiering())\n+\n+    def scenario_alter_tiering_rule_while_writing(self, ctx: TestContext):\n+        test_duration = datetime.timedelta(seconds=400)\n+\n+        s3_endpoint = get_external_param('s3-endpoint', 'storage.yandexcloud.net')\n+        s3_access_key = get_external_param('s3-access-key', 'YCAJEM3Pg9fMyuX9ZUOJ_fake')\n+        s3_secret_key = get_external_param('s3-secret-key', 'YCM7Ovup55wDkymyEtO8pw5F10_L5jtVY8w_fake')\n+        s3_buckets = get_external_param('s3-buckets', 'ydb-tiering-test-1,ydb-tiering-test-2').split(',')\n+\n+        s3_configs = [\n+            ObjectStorageParams(\n+                scheme='HTTP',\n+                verify_ssl=False,\n+                endpoint=s3_endpoint,\n+                bucket=bucket,\n+                access_key=s3_access_key,\n+                secret_key=s3_secret_key\n+            ) for bucket in s3_buckets\n+        ]\n+\n+        sth = ScenarioTestHelper(ctx)\n+\n+        tiers: list[str] = []\n+        tiering_rules: list[str] = []\n+        for i, s3_config in enumerate(s3_configs):\n+            tiers.append(f'TestAlterTiering:tier{i}')\n+            tiering_rules.append(f'TestAlterTiering:tiering_rule{i}')\n+\n+            tier_config = TierConfig(tiers[-1], s3_config)\n+            tiering_config = TieringPolicy().with_rule(TieringRule(tiers[-1], '1s'))\n+\n+            sth.execute_scheme_query(CreateTierIfNotExists(tiers[-1], tier_config))\n+            sth.execute_scheme_query(CreateTieringRuleIfNotExists(tiering_rules[-1], 'timestamp', tiering_config))\n+\n+            sth.execute_scheme_query(AlterTier(tiers[-1], tier_config))\n+            sth.execute_scheme_query(AlterTieringRule(tiering_rules[-1], 'timestamp', tiering_config))\n+\n+        sth.execute_scheme_query(CreateTableStore('store').with_schema(self.schema1))\n+        sth.execute_scheme_query(CreateTable('store/table').with_schema(self.schema1))\n+\n+        threads = []\n+\n+        threads.append(self.TestThread(\n+            target=self._change_tiering_rule,\n+            args=[ctx, 'store/table', tiering_rules, test_duration]\n+        ))\n+        writer_id_offset = random.randint(0, 1 << 30)\n+        for i in range(4):\n+            threads.append(self.TestThread(target=self._upsert, args=[ctx, 'store/table', writer_id_offset + i, test_duration]))\n+\n+        for thread in threads:\n+            thread.start()\n+        for thread in threads:\n+            thread.join()\n+\n+        for tiering in tiering_rules:\n+            sth.execute_scheme_query(DropTieringRule(tiering))\n+        for tier in tiers:\n+            sth.execute_scheme_query(DropTier(tier))\n+\n+        sth.execute_scheme_query(AlterTable('store/table').set_ttl('P1D', 'timestamp'))\n+\n+        while sth.execute_scan_query(f'SELECT COUNT(*) FROM `{sth.get_full_path(\"store/table\")}`').result_set.rows[0][0]:\n+            time.sleep(10)\ndiff --git a/ydb/tests/olap/scenario/ya.make b/ydb/tests/olap/scenario/ya.make\nindex 49eee4306f26..58a33a89fdba 100644\n--- a/ydb/tests/olap/scenario/ya.make\n+++ b/ydb/tests/olap/scenario/ya.make\n@@ -11,6 +11,7 @@ PY3TEST()\n     TEST_SRCS(\n         test_simple.py\n         test_scheme_load.py\n+        test_alter_tiering.py\n     )\n \n     PEERDIR(\n",
  "problem_statement": "Integrate stable-24-3-9-cs-2 into stable-24-3\nstable-24-3-9-cs-2 git hash 602dfb0787d4b33a0577f9572a94858b6aca157f\n\n",
  "hints_text": "",
  "created_at": "2024-09-24T07:58:45Z"
}