{
  "repo": "ydb-platform/ydb",
  "pull_number": 4434,
  "instance_id": "ydb-platform__ydb-4434",
  "issue_numbers": [
    "3217"
  ],
  "base_commit": "c0f4520a09a5ede7e88480d6b35fd1e466019428",
  "patch": "diff --git a/ydb/core/client/object_storage_listing_ut.cpp b/ydb/core/client/object_storage_listing_ut.cpp\nnew file mode 100644\nindex 000000000000..31bd020e6e99\n--- /dev/null\n+++ b/ydb/core/client/object_storage_listing_ut.cpp\n@@ -0,0 +1,977 @@\n+#include \"flat_ut_client.h\"\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+#include <ydb/public/api/protos/draft/ydb_object_storage.pb.h>\n+#include <ydb/public/api/grpc/draft/ydb_object_storage_v1.grpc.pb.h>\n+#include <grpc++/client_context.h>\n+#include <grpc++/create_channel.h>\n+\n+namespace NKikimr {\n+namespace NFlatTests {\n+\n+using namespace Tests;\n+using NClient::TValue;\n+\n+Y_UNIT_TEST_SUITE(TObjectStorageListingTest) {\n+\n+    static int GRPC_PORT = 0;\n+\n+    void S3WriteRow(TFlatMsgBusClient& annoyingClient, ui64 hash, TString name, TString path, ui64 version, ui64 ts, TString data, TString table, bool someBool = true) {\n+        TString insertRowQuery =  R\"(\n+                    (\n+                    (let key '(\n+                        '('Hash (Uint64 '%llu))\n+                        '('Name (Utf8 '\"%s\"))\n+                        '('Path (Utf8 '\"%s\"))\n+                        '('Version (Uint64 '%llu))\n+                    ))\n+                    (let value '(\n+                        '('Timestamp (Uint64 '%llu))\n+                        '('Data (String '\"%s\"))\n+                        '('Int32Data (Null))\n+                        '('SomeBool (Bool '\"%s\"))\n+                    ))\n+                    (let ret_ (AsList\n+                        (UpdateRow '/dc-1/Dir/%s key value)\n+                    ))\n+                    (return ret_)\n+                    )\n+                )\";\n+\n+        annoyingClient.FlatQuery(Sprintf(insertRowQuery.data(), hash, name.data(), path.data(), version, ts, data.data(), someBool ? \"true\" : \"false\", table.data()));\n+    }\n+\n+    void S3DeleteRow(TFlatMsgBusClient& annoyingClient, ui64 hash, TString name, TString path, ui64 version, TString table) {\n+        TString eraseRowQuery =  R\"(\n+                    (\n+                    (let key '(\n+                        '('Hash (Uint64 '%llu))\n+                        '('Name (Utf8 '\"%s\"))\n+                        '('Path (Utf8 '\"%s\"))\n+                        '('Version (Uint64 '%llu))\n+                    ))\n+                    (let ret_ (AsList\n+                        (EraseRow '/dc-1/Dir/%s key)\n+                    ))\n+                    (return ret_)\n+                    )\n+                )\";\n+\n+        annoyingClient.FlatQuery(Sprintf(eraseRowQuery.data(), hash, name.data(), path.data(), version, table.data()));\n+    }\n+\n+    void CreateS3Table(TFlatMsgBusClient& annoyingClient) {\n+        annoyingClient.InitRoot();\n+        annoyingClient.MkDir(\"/dc-1\", \"Dir\");\n+        annoyingClient.CreateTable(\"/dc-1/Dir\",\n+            R\"(Name: \"Table\"\n+                Columns { Name: \"Hash\"      Type: \"Uint64\"}\n+                Columns { Name: \"Name\"      Type: \"Utf8\"}\n+                Columns { Name: \"Path\"      Type: \"Utf8\"}\n+                Columns { Name: \"Version\"   Type: \"Uint64\"}\n+                Columns { Name: \"Timestamp\" Type: \"Uint64\"}\n+                Columns { Name: \"Data\"      Type: \"String\"}\n+                Columns { Name: \"ExtraData\" Type: \"String\"}\n+                Columns { Name: \"Int32Data\" Type: \"Int32\"}\n+                Columns { Name: \"Unused1\"   Type: \"Uint32\"}\n+                Columns { Name: \"SomeBool\"  Type: \"Bool\"}\n+                KeyColumnNames: [\n+                    \"Hash\",\n+                    \"Name\",\n+                    \"Path\",\n+                    \"Version\"\n+                    ]\n+                SplitBoundary { KeyPrefix {\n+                    Tuple { Optional { Uint64 : 60 }}\n+                }}\n+                SplitBoundary { KeyPrefix {\n+                    Tuple { Optional { Uint64 : 100 }}\n+                    Tuple { Optional { Text : 'Bucket100' }}\n+                    Tuple { Optional { Text : '/Videos/Game of Thrones/Season 1/Episode 2' }}\n+                }}\n+                SplitBoundary { KeyPrefix {\n+                    Tuple { Optional { Uint64 : 100 }}\n+                    Tuple { Optional { Text : 'Bucket100' }}\n+                    Tuple { Optional { Text : '/Videos/Game of Thrones/Season 1/Episode 8' }}\n+                }}\n+                SplitBoundary { KeyPrefix {\n+                    Tuple { Optional { Uint64 : 100 }}\n+                    Tuple { Optional { Text : 'Bucket100' }}\n+                    Tuple { Optional { Text : '/Videos/Godfather 2.avi' }}\n+                }}\n+                PartitionConfig {\n+                    ExecutorCacheSize: 100\n+\n+                                        CompactionPolicy {\n+                                                InMemSizeToSnapshot: 2000\n+                                                InMemStepsToSnapshot: 1\n+                                                InMemForceStepsToSnapshot: 50\n+                                                InMemForceSizeToSnapshot: 16777216\n+                                                InMemCompactionBrokerQueue: 0\n+                                                ReadAheadHiThreshold: 1048576\n+                                                ReadAheadLoThreshold: 16384\n+                                                MinDataPageSize: 300\n+                                                SnapBrokerQueue: 0\n+\n+                                                LogOverheadSizeToSnapshot: 16777216\n+                                                LogOverheadCountToSnapshot: 500\n+                                                DroppedRowsPercentToCompact: 146\n+\n+                                                Generation {\n+                                                  GenerationId: 0\n+                                                  SizeToCompact: 0\n+                                                  CountToCompact: 2000\n+                                                  ForceCountToCompact: 4000\n+                                                  ForceSizeToCompact: 100000000\n+                                                  #CompactionBrokerQueue: 4294967295\n+                                                  KeepInCache: false\n+                                                  ResourceBrokerTask: \"compaction_gen1\"\n+                                                  ExtraCompactionPercent: 100\n+                                                  ExtraCompactionMinSize: 16384\n+                                                  ExtraCompactionExpPercent: 110\n+                                                  ExtraCompactionExpMaxSize: 0\n+                                                  UpliftPartSize: 0\n+                                                }\n+                                        }\n+\n+                }\n+            )\");\n+    }\n+\n+    void PrepareS3Data(TFlatMsgBusClient& annoyingClient) {\n+        CreateS3Table(annoyingClient);\n+\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Shoot to Thrill.mp3\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Thunderstruck.mp3\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/rock.m3u\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana/Smeels Like Teen Spirit.mp3\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana/In Bloom.mp3\", 1, 20, \"\", \"Table\");\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/face.jpg\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/facepalm.jpg\", 1, 20, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/palm.jpg\", 1, 30, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 1.avi\", 1, 100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 10.avi\", 1, 300, \"\", \"Table\");\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 2.avi\", 1, 200, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 3.avi\", 1, 300, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 4.avi\", 1, 300, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 5.avi\", 1, 300, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 6.avi\", 1, 300, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 7.avi\", 1, 300, \"\", \"Table\");\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 8.avi\", 1, 300, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 9.avi\", 1, 300, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 2/Episode 1.avi\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Godfather 2.avi\", 1, 500, \"\", \"Table\");\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Godfather.avi\", 1, 500, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Godmother.avi\", 1, 500, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/House of Cards/Season 1/Chapter 1.avi\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/House of Cards/Season 1/Chapter 2.avi\", 1, 1200, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Terminator 2.avi\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/XXX/1.avi\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/XXX/2.avi\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/XXX/3.avi\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/XXX/3d.avi\", 1, 1100, \"\", \"Table\");\n+\n+        S3WriteRow(annoyingClient, 333, \"Bucket333\", \"asdf\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 333, \"Bucket333\", \"boo/bar\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 333, \"Bucket333\", \"boo/baz/xyzzy\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 333, \"Bucket333\", \"cquux/thud\", 1, 1100, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 333, \"Bucket333\", \"cquux/bla\", 1, 1100, \"\", \"Table\");\n+\n+        S3DeleteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana/Smells Like Teen Spirit.mp3\", 1, \"Table\");\n+        S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/palm.jpg\", 1, \"Table\");\n+        S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 2.avi\", 1, \"Table\");\n+        S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/Game of Thrones/Season 1/Episode 5.avi\", 1, \"Table\");\n+        S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/Videos/House of Cards/Season 1/Chapter 2.avi\", 1, \"Table\");\n+    }\n+\n+    void DoListingBySelectRange(TFlatMsgBusClient& annoyingClient,\n+                                ui64 bucket, const TString& pathPrefix, const TString& pathDelimiter, const TString& startAfter, ui32 maxKeys,\n+                                TSet<TString>& commonPrefixes, TSet<TString>& contents)\n+    {\n+        // Read all rows from the bucket\n+        TString table = \"Table\";\n+        ui64 hash = bucket;\n+        TString name = \"Bucket\" + ToString(bucket);\n+        TString selectBucketQuery =  R\"(\n+                (\n+                    (let range '(\n+                        '('Hash (Uint64 '%llu) (Uint64 '%llu))\n+                        '('Name (Utf8 '\"%s\") (Utf8 '\"%s\"))\n+                        '('Path (Nothing (OptionalType (DataType 'Utf8))) (Void))\n+                        '('Version (Nothing (OptionalType (DataType 'Uint64))) (Void))\n+                    ))\n+                    (let columns '(\n+                        'Path\n+                    ))\n+                    (let res\n+                        (SelectRange '/dc-1/Dir/%s range columns '() )\n+                    )\n+                    (return (AsList (SetResult 'Objects res)))\n+                )\n+                )\";\n+\n+        TClient::TFlatQueryOptions opts;\n+        NKikimrMiniKQL::TResult res;\n+        annoyingClient.FlatQuery(Sprintf(selectBucketQuery.data(), hash, hash, name.data(), name.data(), table.data()), opts, res);\n+\n+        TValue value = TValue::Create(res.GetValue(), res.GetType());\n+        TValue objects = value[\"Objects\"];\n+        TValue l = objects[\"List\"];\n+        TVector<TString> paths;\n+        for (ui32 i = 0; i < l.Size(); ++i) {\n+            TValue ps = l[i];\n+            paths.emplace_back(ps[\"Path\"]);\n+        }\n+\n+        // Make a list of common prefixes and a list of full paths that match the parameter\n+        commonPrefixes.clear();\n+        contents.clear();\n+        for (const auto& p : paths) {\n+            if (commonPrefixes.size() + contents.size() == maxKeys)\n+                break;\n+\n+            if (!p.StartsWith(pathPrefix))\n+                continue;\n+\n+            if (p <= startAfter)\n+                continue;\n+\n+            size_t delimPos = p.find_first_of(pathDelimiter, pathPrefix.length());\n+            if (delimPos == TString::npos) {\n+                contents.insert(p);\n+            } else {\n+                TString prefix = p.substr(0, delimPos + pathDelimiter.length());\n+                if (prefix > startAfter) {\n+                    commonPrefixes.insert(prefix);\n+                }\n+            }\n+        }\n+    }\n+\n+    TString MakeTuplePb(const TVector<TString>& values) {\n+        TStringStream pbPrefixCols;\n+\n+        pbPrefixCols <<\n+            \"type {\"\n+            \"   tuple_type {\";\n+        for (size_t i = 0; i < values.size(); ++i) {\n+            pbPrefixCols <<\n+                \"       elements { type_id : UTF8 }\";\n+        }\n+        pbPrefixCols <<\n+            \"   }\"\n+            \"}\"\n+            \"value { \";\n+        for (const auto& pc : values) {\n+            pbPrefixCols <<\n+                \"   items { text_value : '\" << pc <<  \"' } \";\n+        }\n+        pbPrefixCols << \"}\";\n+\n+        return pbPrefixCols.Str();\n+    }\n+\n+    void S3Listing(const int grpcPort, const TString& table, const TString& pbPrefixCols,\n+                    const TString& pathPrefix, const TString& pathDelimiter,\n+                    const TString& pbStartAfterSuffixCols,\n+                    const TVector<TString>& columnsToReturn, ui32 maxKeys,\n+                    Ydb::ObjectStorage::ListingResponse& res) {\n+        TStringBuilder endpoint;\n+        endpoint << \"localhost:\" << grpcPort;\n+        std::shared_ptr<grpc::Channel> channel = grpc::CreateChannel(endpoint, grpc::InsecureChannelCredentials());\n+        auto stub = Ydb::ObjectStorage::V1::ObjectStorageService::NewStub(channel);\n+        \n+        TAutoPtr<Ydb::ObjectStorage::ListingRequest> request = new Ydb::ObjectStorage::ListingRequest();\n+        request->Setpath_column_prefix(pathPrefix);\n+        request->Settable_name(table);\n+        request->Setpath_column_delimiter(pathDelimiter);\n+        for (const TString& c : columnsToReturn) {\n+            request->Addcolumns_to_return(c);\n+        }\n+        request->set_max_keys(maxKeys);\n+\n+        bool parseOk = ::google::protobuf::TextFormat::ParseFromString(pbPrefixCols, request->mutable_key_prefix());\n+        UNIT_ASSERT(parseOk);\n+        parseOk = ::google::protobuf::TextFormat::ParseFromString(pbStartAfterSuffixCols, request->mutable_start_after_key_suffix());\n+        UNIT_ASSERT(parseOk);\n+        grpc::ClientContext rcontext;\n+        grpc::Status status = stub->List(&rcontext, *request, &res);\n+    }\n+\n+    TString DoS3Listing(ui16 grpcPort, ui64 bucket, const TString& pathPrefix, const TString& pathDelimiter, const TString& startAfter,\n+                    TString continuationToken,\n+                    const TVector<TString>& columnsToReturn, ui32 maxKeys,\n+                    TVector<TString>& commonPrefixes, TVector<TString>& contents, std::optional<Ydb::ObjectStorage::ListingRequest_EMatchType> filter = {}) {\n+        std::shared_ptr<grpc::Channel> channel;\n+        TStringBuilder endpoint;\n+        endpoint << \"localhost:\" <<  grpcPort;\n+        channel = grpc::CreateChannel(endpoint, grpc::InsecureChannelCredentials());\n+        std::unique_ptr<Ydb::ObjectStorage::V1::ObjectStorageService::Stub> stub;\n+        stub = Ydb::ObjectStorage::V1::ObjectStorageService::NewStub(channel);\n+\n+        TString keyPrefix = R\"(\n+            type {\n+                tuple_type {\n+                    elements {\n+                        type_id: UINT64\n+                    }\n+                    elements {\n+                        type_id: UTF8\n+                    }\n+                }\n+            }\n+            value {\n+                items {\n+                    uint64_value: )\" + ToString(bucket) + R\"(\n+                }\n+                items {\n+                    text_value: \"Bucket)\" + ToString(bucket) + R\"(\"\n+                }\n+            }\n+        )\";\n+\n+\n+        TString pbStartAfterSuffix;\n+        if (startAfter) {\n+            pbStartAfterSuffix = R\"(\n+                type {\n+                    tuple_type {\n+                        elements {\n+                            type_id: UTF8\n+                        }\n+                    }\n+                }\n+                value {\n+                    items {\n+                        text_value: \")\" + startAfter + R\"(\"\n+                    }\n+                }\n+            )\";\n+        }\n+\n+        TAutoPtr<Ydb::ObjectStorage::ListingRequest> request = new Ydb::ObjectStorage::ListingRequest();\n+        request->Setpath_column_prefix(pathPrefix);\n+        request->Settable_name(\"/dc-1/Dir/Table\");\n+        request->Setpath_column_delimiter(pathDelimiter);\n+        request->set_continuation_token(continuationToken);\n+        for (const TString& c : columnsToReturn) {\n+            request->Addcolumns_to_return(c);\n+        }\n+        request->set_max_keys(maxKeys);\n+\n+        if (filter) {\n+            auto* filterMsg = request->mutable_matching_filter();\n+\n+            ui32 eq = (ui32) filter.value();\n+\n+            TString filter = R\"(\n+                type {\n+                    tuple_type {\n+                        elements {\n+                            list_type {\n+                                item {\n+                                    type_id: STRING\n+                                }\n+                            }\n+                        }\n+                        elements {\n+                            list_type {\n+                                item {\n+                                    type_id: UINT32\n+                                }\n+                            }\n+                        }\n+                        elements {\n+                            tuple_type {\n+                                elements {\n+                                    type_id: BOOL\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                value {\n+                    items {\n+                        items {\n+                            text_value: \"SomeBool\"\n+                        }\n+                    }\n+                    items {\n+                        items {\n+                            uint32_value: )\" + ToString(eq) + R\"(\n+                        }\n+                    }\n+                    items {\n+                        items {\n+                            bool_value: )\" + ToString(true) + R\"(\n+                        }\n+                    }\n+                }\n+            )\";\n+\n+            bool parseOk = ::google::protobuf::TextFormat::ParseFromString(filter, filterMsg);\n+            UNIT_ASSERT(parseOk);\n+        }\n+\n+        bool parseOk = ::google::protobuf::TextFormat::ParseFromString(keyPrefix, request->mutable_key_prefix());\n+        UNIT_ASSERT(parseOk);\n+        parseOk = ::google::protobuf::TextFormat::ParseFromString(pbStartAfterSuffix, request->mutable_start_after_key_suffix());\n+        UNIT_ASSERT(parseOk);\n+        grpc::ClientContext rcontext;\n+        Ydb::ObjectStorage::ListingResponse response;\n+        grpc::Status status = stub->List(&rcontext, *request, &response);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(response.status(), Ydb::StatusIds::SUCCESS);\n+        \n+        commonPrefixes.clear();\n+        contents.clear();\n+\n+        if (response.common_prefixes_size() > 0) {\n+            auto &folders = response.common_prefixes();\n+            for (auto row : folders) {\n+                commonPrefixes.emplace_back(row);\n+            }\n+        }\n+        \n+        if (response.has_contents()) {\n+            auto &files = response.contents();\n+            for (auto row : files.rows()) {\n+                for (auto item : row.items()) {\n+                    if (item.has_text_value()) {\n+                        contents.emplace_back(item.text_value());\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (response.next_continuation_token().size()) {\n+            TString token = response.next_continuation_token();\n+\n+            return token;\n+        }\n+\n+        return \"\";\n+    }\n+\n+    void CompareS3Listing(TFlatMsgBusClient& annoyingClient, ui64 bucket, const TString& pathPrefix, const TString& pathDelimiter,\n+                       const TString& startAfter, ui32 maxKeys, const TVector<TString>& columnsToReturn)\n+    {\n+        TSet<TString> expectedCommonPrefixes;\n+        TSet<TString> expectedContents;\n+        DoListingBySelectRange(annoyingClient, bucket, pathPrefix, pathDelimiter, startAfter, maxKeys, expectedCommonPrefixes, expectedContents);\n+\n+        TVector<TString> commonPrefixes;\n+        TVector<TString> contents;\n+        DoS3Listing(GRPC_PORT, bucket, pathPrefix, pathDelimiter, startAfter, nullptr, columnsToReturn, maxKeys, commonPrefixes, contents);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(expectedCommonPrefixes.size(), commonPrefixes.size());\n+        ui32 i = 0;\n+        for (const auto& p : expectedCommonPrefixes) {\n+            UNIT_ASSERT_VALUES_EQUAL(p, commonPrefixes[i]);\n+            ++i;\n+        }\n+\n+        UNIT_ASSERT_VALUES_EQUAL(expectedContents.size(), contents.size());\n+        i = 0;\n+        for (const auto& p : expectedContents) {\n+            UNIT_ASSERT_VALUES_EQUAL(p, contents[i]);\n+            ++i;\n+        }\n+    }\n+\n+    void TestS3Listing(TFlatMsgBusClient& annoyingClient, ui64 bucket, const TString& pathPrefix, const TString& pathDelimiter,\n+                       ui32 maxKeys, const TVector<TString>& columnsToReturn) {\n+        Cout << Endl << \"---------------------------------------\" << Endl\n+             << \"Bucket\" << bucket << \" : \" << pathPrefix << Endl;\n+\n+        CompareS3Listing(annoyingClient, bucket, pathPrefix, pathDelimiter, \"\", maxKeys, columnsToReturn);\n+        CompareS3Listing(annoyingClient, bucket, pathPrefix, pathDelimiter, pathPrefix, maxKeys, columnsToReturn);\n+\n+        TSet<TString> expectedCommonPrefixes;\n+        TSet<TString> expectedContents;\n+        DoListingBySelectRange(annoyingClient, bucket, pathPrefix, pathDelimiter, \"\",  100500, expectedCommonPrefixes, expectedContents);\n+\n+        for (const TString& after : expectedCommonPrefixes) {\n+            CompareS3Listing(annoyingClient, bucket, pathPrefix, pathDelimiter, after, maxKeys, columnsToReturn);\n+        }\n+\n+        for (const TString& after : expectedContents) {\n+            CompareS3Listing(annoyingClient, bucket, pathPrefix, pathDelimiter, after, maxKeys, columnsToReturn);\n+        }\n+    }\n+\n+    Y_UNIT_TEST(Listing) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::MSGBUS_REQUEST, NActors::NLog::PRI_DEBUG);\n+//        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::TX_DATASHARD, NActors::NLog::PRI_TRACE);\n+\n+        TestS3Listing(annoyingClient, 50, \"\", \"\", 10, {});\n+        TestS3Listing(annoyingClient, 50, \"\", \"/\", 7, {});\n+        TestS3Listing(annoyingClient, 50, \"Music/\", \"/\", 9, {});\n+        TestS3Listing(annoyingClient, 50, \"Music/Nirvana\", \"/\", 11, {});\n+        TestS3Listing(annoyingClient, 50, \"Music/Nirvana/\", \"/\", 2, {});\n+        TestS3Listing(annoyingClient, 50, \"Photos/\", \"/\", 3, {});\n+\n+        TestS3Listing(annoyingClient, 100, \"\", \"\", 4, {});\n+        TestS3Listing(annoyingClient, 100, \"\", \"/\", 7, {});\n+        TestS3Listing(annoyingClient, 100, \"/\", \"\", 3, {});\n+        TestS3Listing(annoyingClient, 100, \"/\", \"/\", 1, {});\n+        TestS3Listing(annoyingClient, 100, \"/Photos/\", \"/\", 11, {});\n+        TestS3Listing(annoyingClient, 100, \"/Videos/\", \"/\", 18, {});\n+        TestS3Listing(annoyingClient, 100, \"/Videos\", \"/\", 3, {\"Path\", \"Timestamp\"});\n+        TestS3Listing(annoyingClient, 100, \"/Videos/Game \", \"/\", 5, {\"Path\", \"Timestamp\"});\n+        TestS3Listing(annoyingClient, 100, \"/Videos/Game of Thrones/Season 1/\", \"/\", 6, {\"Path\", \"Timestamp\"});\n+        TestS3Listing(annoyingClient, 100, \"/Videos/Game of Thr\", \" \", 4, {\"Path\", \"Timestamp\"});\n+\n+        TestS3Listing(annoyingClient, 20, \"\", \"/\", 8, {\"Path\", \"Timestamp\"});\n+        TestS3Listing(annoyingClient, 200, \"/\", \"/\", 3, {\"Path\", \"Timestamp\"});\n+\n+        // Request NULL columns\n+        TestS3Listing(annoyingClient, 50, \"Photos/\", \"/\", 7, {\"ExtraData\"});\n+        TestS3Listing(annoyingClient, 50, \"Photos/\", \"\", 2, {\"Unused1\"});\n+        TestS3Listing(annoyingClient, 50, \"Music/\", \"/\", 11, {\"ExtraData\"});\n+        TestS3Listing(annoyingClient, 50, \"/\", \"\", 8, {\"Unused1\"});\n+        TestS3Listing(annoyingClient, 50, \"Music/Nirvana\", \"/\", 11, {\"Int32Data\"});\n+\n+        TestS3Listing(annoyingClient, 333, \"\", \"\", 2, {});\n+        TestS3Listing(annoyingClient, 333, \"\", \"/\", 2, {});\n+        TestS3Listing(annoyingClient, 333, \"\", \"\", 3, {});\n+        TestS3Listing(annoyingClient, 333, \"\", \"/\", 3, {});\n+    }\n+\n+    Y_UNIT_TEST(MaxKeysAndSharding) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+        for (auto commonPrefix: {\"/\", \"/Videos\", \"/Videos/\", \"/W\", \"/X\",\n+                \"/Videos/Game of\", \"/Videos/Game of Thrones/\",\n+                \"/Videos/Game of Thrones/Season 1\",\n+                \"/Videos/Game of Thrones/Season 1/\"})\n+        {\n+            for (ui32 maxKeys = 1; maxKeys < 20; ++maxKeys) {\n+                TestS3Listing(annoyingClient, 100, commonPrefix, \"/\", maxKeys, {});\n+            }\n+        }\n+    }\n+\n+    void TestS3GenericListingRequest(const TVector<TString>& prefixColumns, const TString& pathPrefix, const TString& pathDelimiter,\n+                    const TVector<TString>& startAfterSuffixColumns,\n+                    const TVector<TString>& columnsToReturn, ui32 maxKeys,\n+                    Ydb::StatusIds_StatusCode expectedStatus = Ydb::StatusIds::SUCCESS,\n+                    const TString& expectedErrMessage = \"\")\n+    {\n+        TString pbPrefixCols = MakeTuplePb(prefixColumns);\n+\n+        TString pbStartAfterSuffixCols = MakeTuplePb(startAfterSuffixColumns);\n+\n+        Ydb::ObjectStorage::ListingResponse response;\n+        S3Listing(GRPC_PORT, \"/dc-1/Dir/Table\", pbPrefixCols, pathPrefix, pathDelimiter,\n+                    pbStartAfterSuffixCols, columnsToReturn, maxKeys, response);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(response.status(), expectedStatus);\n+        if (expectedErrMessage) {\n+            UNIT_ASSERT_VALUES_EQUAL(response.issues().size(), 1);\n+            auto &issueMessage = response.issues()[0];\n+            UNIT_ASSERT_VALUES_EQUAL(issueMessage.message(), expectedErrMessage);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(response.issues().size(), 0);\n+        }\n+    }\n+\n+    void TestS3ListingRequest(const TVector<TString>& prefixColumns, \n+                    const TString& pathPrefix, const TString& pathDelimiter,\n+                    const TString& startAfter, const TVector<TString>& columnsToReturn, ui32 maxKeys,\n+                    Ydb::StatusIds_StatusCode expectedStatus = Ydb::StatusIds::SUCCESS,\n+                    const TString& expectedErrMessage = \"\")\n+    {\n+        TVector<TString> startAfterSuffix;\n+        if (!startAfter.empty()) {\n+            startAfterSuffix.push_back(startAfter);\n+        }\n+        TestS3GenericListingRequest(prefixColumns, pathPrefix, pathDelimiter,\n+                                           startAfterSuffix,\n+                                           columnsToReturn, maxKeys,\n+                                           expectedStatus, expectedErrMessage);\n+    }\n+\n+    Y_UNIT_TEST(SchemaChecks) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::MSGBUS_REQUEST, NActors::NLog::PRI_DEBUG);\n+\n+        TestS3ListingRequest({}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Value for path column 'Hash' has type Uint64, expected Utf8\");\n+\n+        TestS3ListingRequest({\"\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Cannot parse value of type Uint64 from text '' in tuple at position 0\");\n+\n+        TestS3ListingRequest({\"AAA\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Cannot parse value of type Uint64 from text 'AAA' in tuple at position 0\");\n+\n+        TestS3ListingRequest({\"-1\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Cannot parse value of type Uint64 from text '-1' in tuple at position 0\");\n+\n+        TestS3ListingRequest({\"1\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::SUCCESS,\n+            \"\");\n+\n+        TestS3ListingRequest({\"1\", \"Bucket1\", \"/\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Value for path column 'Version' has type Uint64, expected Utf8\");\n+\n+        TestS3ListingRequest({\"1\", \"Bucket1\", \"/Photos\", \"1\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Tuple size 4 is greater that expected size 3\");\n+\n+        TestS3ListingRequest({\"1\", \"Bucket1\", \"/Photos\", \"/\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Tuple size 4 is greater that expected size 3\");\n+\n+        TestS3ListingRequest({\"1\", \"2\", \"3\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Value for path column 'Version' has type Uint64, expected Utf8\");\n+\n+        TestS3ListingRequest({\"1\", \"2\", \"3\", \"4\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Tuple size 4 is greater that expected size 3\");\n+\n+        TestS3ListingRequest({\"1\", \"2\", \"3\", \"4\", \"5\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Tuple size 5 is greater that expected size 3\");\n+\n+        TestS3ListingRequest({\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid KeyPrefix: Tuple size 10 is greater that expected size 3\");\n+\n+        TestS3ListingRequest({\"1\"}, \"/\", \"/\", \"\", {\"NonExistingColumn\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Unknown column 'NonExistingColumn'\");\n+\n+        TestS3ListingRequest({\"1\", \"Bucket1\"}, \"/\", \"/\", \"abc\", {\"Path\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid StartAfterKeySuffix: StartAfter parameter doesn't match PathPrefix\");\n+    }\n+\n+    Y_UNIT_TEST(Split) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+        SetSplitMergePartCountLimit(cleverServer.GetRuntime(), -1);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::MSGBUS_REQUEST, NActors::NLog::PRI_DEBUG);\n+//        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::TX_DATASHARD, NActors::NLog::PRI_DEBUG);\n+\n+        TestS3ListingRequest({\"100\", \"Bucket100\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::SUCCESS,\n+            \"\");\n+\n+        // Split shard #1 (where Bucket100 is stored)\n+        TVector<ui64> shards = annoyingClient.GetTablePartitions(\"/dc-1/Dir/Table\");\n+        annoyingClient.SplitTablePartition(\"/dc-1/Dir/Table\",\n+                \"SourceTabletId: \" + ToString(shards[1]) + \" \"\n+                \"SplitBoundary { KeyPrefix { \"\n+                \"   Tuple { Optional { Uint64: 100 } } \"\n+                \"   Tuple { Optional { Text: 'Bucket100' } } \"\n+                \"   Tuple { Optional { Text: '/Vid' } } \"\n+                \"} }\");\n+\n+        TVector<ui64> shardsAfter = annoyingClient.GetTablePartitions(\"/dc-1/Dir/Table\");\n+        UNIT_ASSERT_VALUES_EQUAL(shards.size() + 1, shardsAfter.size());\n+\n+        TestS3ListingRequest({\"100\", \"Bucket100\"}, \"/\", \"/\", \"\", {\"Path\"}, 10,\n+            Ydb::StatusIds::SUCCESS,\n+            \"\");\n+\n+        CompareS3Listing(annoyingClient, 100, \"/\", \"/\", \"\", 100500, {\"Path\"});\n+    }\n+\n+    Y_UNIT_TEST(SuffixColumns) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Shoot to Thrill.mp3\", 55, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Shoot to Thrill.mp3\", 66, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Shoot to Thrill.mp3\", 77, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Shoot to Thrill.mp3\", 88, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Shoot to Thrill.mp3\", 666, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/AC DC/Thunderstruck.mp3\", 66, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/rock.m3u\", 111, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/rock.m3u\", 222, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/rock.m3u\", 333, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana\", 112, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana/Smeels Like Teen Spirit.mp3\", 100, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 50, \"Bucket50\", \"Music/Nirvana/In Bloom.mp3\", 120, 20, \"\", \"Table\");\n+\n+        //\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::TX_DATASHARD, NActors::NLog::PRI_TRACE);\n+\n+        TestS3GenericListingRequest({\"50\", \"Bucket50\"}, \"Music/AC DC/\", \"/\", {\"Music/AC DC/Shoot to Thrill.mp3\", \"66\"}, {\"Path\", \"Version\", \"Data\"}, 10,\n+            Ydb::StatusIds::SUCCESS,\n+            \"\");\n+\n+        TestS3GenericListingRequest({\"50\", \"Bucket50\"}, \"Music/AC DC/\", \"/\", {\"Music/AC DC/Shoot to Thrill.mp3\"}, {\"Path\", \"Version\", \"Timestamp\"}, 10,\n+            Ydb::StatusIds::SUCCESS,\n+            \"\");\n+\n+        TestS3GenericListingRequest({\"50\", \"Bucket50\"}, \"Music/AC DC/\", \"/\", {\"Music/AC DC/Shoot to Thrill.mp3\", \"66\", \"abcd\"}, {\"Path\", \"Version\"}, 10,\n+            Ydb::StatusIds::BAD_REQUEST,\n+            \"Invalid StartAfterKeySuffix: Tuple size 3 is greater that expected size 2\");\n+    }\n+\n+    Y_UNIT_TEST(ManyDeletes) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServerSettings settings(port);\n+        settings.NodeCount = 1;\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        // Disable shared cache to trigger restarts\n+        TAtomic unused = 42;\n+        cleverServer.GetRuntime()->GetAppData().Icb->SetValue(\"SharedPageCache_Size\", 10, unused);\n+        cleverServer.GetRuntime()->GetAppData().Icb->SetValue(\"SharedPageCache_Size\", 10, unused);\n+        UNIT_ASSERT_VALUES_EQUAL(unused, 10);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+#ifdef NDEBUG\n+        const int N_ROWS = 10000;\n+#else\n+        const int N_ROWS = 5000;\n+#endif\n+\n+        TString bigData(300, 'a');\n+\n+        for (int i = 0; i < N_ROWS; ++i) {\n+            S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/A/Santa Barbara \" + ToString(i), 1, 1100, bigData, \"Table\");\n+            S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/B/Santa Barbara \" + ToString(i%4000), 1, 1100, bigData, \"Table\");\n+            S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/C/Santa Barbara \" + ToString(i), 1, 1100, bigData, \"Table\");\n+            S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/D/Santa Barbara \" + ToString(i), 1, 1100, bigData, \"Table\");\n+            if (i % 100 == 0)\n+                Cerr << \".\";\n+        }\n+        Cerr << \"\\n\";\n+\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::TX_DATASHARD, NActors::NLog::PRI_DEBUG);\n+\n+        CompareS3Listing(annoyingClient, 100, \"/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/A/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/B/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/P/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/Photos/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/Videos/\", \"/\", \"\", 1000, {});\n+\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::TX_DATASHARD, NActors::NLog::PRI_ERROR);\n+\n+        for (int i = 0; i < N_ROWS/2; ++i) {\n+            S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/A/Santa Barbara \" + ToString(i), 1, \"Table\");\n+            S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/B/Santa Barbara \" + ToString(i), 1, \"Table\");\n+            S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/C/Santa Barbara \" + ToString(i), 1, \"Table\");\n+            S3DeleteRow(annoyingClient, 100, \"Bucket100\", \"/D/Santa Barbara \" + ToString(i), 1, \"Table\");\n+            if (i % 100 == 0)\n+                Cerr << \".\";\n+        }\n+        Cerr << \"\\n\";\n+\n+        cleverServer.GetRuntime()->SetLogPriority(NKikimrServices::TX_DATASHARD, NActors::NLog::PRI_DEBUG);\n+\n+        CompareS3Listing(annoyingClient, 100, \"/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/A/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/B/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/P/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/Photos/\", \"/\", \"\", 1000, {});\n+        CompareS3Listing(annoyingClient, 100, \"/Videos/\", \"/\", \"\", 1000, {});\n+    }\n+\n+    Y_UNIT_TEST(CornerCases) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        PrepareS3Data(annoyingClient);\n+\n+        S3WriteRow(annoyingClient, 750, \"Bucket750\", \"foo/1.mp4\", 55, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 750, \"Bucket750\", \"foo/bar/1.mp3\", 55, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 750, \"Bucket750\", \"foo/bar0\", 55, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 750, \"Bucket750\", \"foo/cat.jpg\", 55, 10, \"\", \"Table\");\n+\n+        CompareS3Listing(annoyingClient, 750, \"foo/\", \"/\", \"\", 10, {});\n+        CompareS3Listing(annoyingClient, 750, \"foo/\", \"/\", \"foo/1.mp4\", 1, {});\n+        CompareS3Listing(annoyingClient, 750, \"foo/\", \"/\", \"foo/bar/\", 1, {});\n+        CompareS3Listing(annoyingClient, 750, \"foo/\", \"/\", \"foo/bar0\", 1, {});\n+\n+        TVector<TString> commonPrefixes;\n+        TVector<TString> contents;\n+\n+        auto continuationToken = DoS3Listing(GRPC_PORT, 750, \"foo/\", \"/\", \"\", \"\", {}, 1, commonPrefixes, contents);\n+        \n+        UNIT_ASSERT(continuationToken);\n+        UNIT_ASSERT_EQUAL(1, contents.size());\n+        UNIT_ASSERT_EQUAL(0, commonPrefixes.size());\n+        UNIT_ASSERT_STRINGS_EQUAL(\"foo/1.mp4\", contents[0]);\n+\n+        continuationToken = DoS3Listing(GRPC_PORT, 750, \"foo/\", \"/\", \"\", continuationToken, {}, 1, commonPrefixes, contents);\n+\n+        UNIT_ASSERT(continuationToken);\n+        UNIT_ASSERT_EQUAL(0, contents.size());\n+        UNIT_ASSERT_EQUAL(1, commonPrefixes.size());\n+        UNIT_ASSERT_STRINGS_EQUAL(\"foo/bar/\", commonPrefixes[0]);\n+\n+        continuationToken = DoS3Listing(GRPC_PORT, 750, \"foo/\", \"/\", \"\", continuationToken, {}, 1, commonPrefixes, contents);\n+\n+        UNIT_ASSERT(continuationToken);\n+        UNIT_ASSERT_EQUAL(1, contents.size());\n+        UNIT_ASSERT_EQUAL(0, commonPrefixes.size());\n+        UNIT_ASSERT_STRINGS_EQUAL(\"foo/bar0\", contents[0]);\n+\n+        continuationToken = DoS3Listing(GRPC_PORT, 750, \"foo/\", \"/\", \"\", continuationToken, {}, 1, commonPrefixes, contents);\n+\n+        UNIT_ASSERT(continuationToken);\n+        UNIT_ASSERT_EQUAL(1, contents.size());\n+        UNIT_ASSERT_EQUAL(0, commonPrefixes.size());\n+        UNIT_ASSERT_STRINGS_EQUAL(\"foo/cat.jpg\", contents[0]);\n+\n+        continuationToken = DoS3Listing(GRPC_PORT, 750, \"foo/\", \"/\", \"\", continuationToken, {}, 1, commonPrefixes, contents);\n+\n+        UNIT_ASSERT(!continuationToken);\n+        UNIT_ASSERT_EQUAL(0, contents.size());\n+        UNIT_ASSERT_EQUAL(0, commonPrefixes.size());\n+    }\n+\n+    Y_UNIT_TEST(TestFilter) {\n+        TPortManager pm;\n+        ui16 port = pm.GetPort(2134);\n+        TServer cleverServer = TServer(TServerSettings(port));\n+        GRPC_PORT = pm.GetPort(2135);\n+        cleverServer.EnableGRpc(GRPC_PORT);\n+\n+        TFlatMsgBusClient annoyingClient(port);\n+\n+        CreateS3Table(annoyingClient);\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/a.jpg\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/b.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/c.jpg\", 1, 10, \"\", \"Table\");\n+\n+        // This folder should not be shown, as boolean flag is false\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/folder/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/folder/b.jpg\", 1, 10, \"\", \"Table\", false);\n+\n+        // This folder should be shown\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/games/a.jpg\", 1, 10, \"\", \"Table\");\n+\n+        // This folder should be shown, as one file is hidden, and one is not\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/inner/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/inner/b.jpg\", 1, 10, \"\", \"Table\");\n+\n+        // This folder should be shown, as one file in nested folder is hidden, and one is not\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test/inner/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test/inner/b.jpg\", 1, 10, \"\", \"Table\");\n+\n+        // This folder should not be shown\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test2/inner/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test2/inner/b.jpg\", 1, 10, \"\", \"Table\", false);\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test3/inner/inner2/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test3/inner/inner2/b.jpg\", 1, 10, \"\", \"Table\");\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test4/inner/inner2/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test4/inner/inner2/b.jpg\", 1, 10, \"\", \"Table\", false);\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test5/inner/inner2/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test5/inner/inner2/b.jpg\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test5/inner/inner2/c.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test5/inner/inner2/d.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test5/inner/inner2/e.jpg\", 1, 10, \"\", \"Table\", false);\n+\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/b.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/inner/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/inner/b.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/inner/inner2/a.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/inner/inner2/b.jpg\", 1, 10, \"\", \"Table\");\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/inner/inner2/c.jpg\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/xyz.io\", 1, 10, \"\", \"Table\", false);\n+        S3WriteRow(annoyingClient, 100, \"Bucket100\", \"/Photos/test6/yyyyy.txt\", 1, 10, \"\", \"Table\", false);\n+\n+        {\n+            TVector<TString> folders;\n+            TVector<TString> files;\n+            DoS3Listing(GRPC_PORT, 100, \"/Photos/\", \"/\", nullptr, nullptr, {}, 1000, folders, files, Ydb::ObjectStorage::ListingRequest_EMatchType_EQUAL);\n+\n+            TVector<TString> expectedFolders = {\"/Photos/games/\", \"/Photos/inner/\", \"/Photos/test/\", \"/Photos/test3/\", \"/Photos/test5/\", \"/Photos/test6/\"};\n+            TVector<TString> expectedFiles = {\"/Photos/a.jpg\", \"/Photos/c.jpg\"};\n+\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFolders, folders);\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFiles, files);\n+        }\n+\n+        {\n+            TVector<TString> folders;\n+            TVector<TString> files;\n+            DoS3Listing(GRPC_PORT, 100, \"/Photos/\", \"/\", nullptr, nullptr, {}, 1000, folders, files, Ydb::ObjectStorage::ListingRequest_EMatchType_NOT_EQUAL);\n+\n+            TVector<TString> expectedFolders = {\"/Photos/folder/\", \"/Photos/inner/\", \"/Photos/test/\", \"/Photos/test2/\", \"/Photos/test3/\", \"/Photos/test4/\", \"/Photos/test5/\", \"/Photos/test6/\"};\n+            TVector<TString> expectedFiles = {\"/Photos/b.jpg\"};\n+            \n+            UNIT_ASSERT_VALUES_EQUAL(expectedFolders, folders);\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFiles, files);\n+        }\n+    }\n+}\n+\n+}}\ndiff --git a/ydb/core/client/ut/ya.make b/ydb/core/client/ut/ya.make\nindex dac55784f3ce..57d274344ed7 100644\n--- a/ydb/core/client/ut/ya.make\n+++ b/ydb/core/client/ut/ya.make\n@@ -40,6 +40,7 @@ SRCS(\n     flat_ut.cpp\n     locks_ut.cpp\n     query_stats_ut.cpp\n+    object_storage_listing_ut.cpp\n )\n \n END()\ndiff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp\nindex caa480601ddb..57805f87bfd1 100644\n--- a/ydb/core/driver_lib/run/run.cpp\n+++ b/ydb/core/driver_lib/run/run.cpp\n@@ -121,6 +121,7 @@\n #include <ydb/services/ydb/ydb_scheme.h>\n #include <ydb/services/ydb/ydb_scripting.h>\n #include <ydb/services/ydb/ydb_table.h>\n+#include <ydb/services/ydb/ydb_object_storage.h>\n \n #include <ydb/core/fq/libs/init/init.h>\n \n@@ -562,6 +563,8 @@ void TKikimrRunner::InitializeGRpc(const TKikimrRunConfig& runConfig) {\n         names[\"topic\"] = &hasTopic;\n         TServiceCfg hasPQCD = services.empty();\n         names[\"pqcd\"] = &hasPQCD;\n+        TServiceCfg hasObjectStorage = services.empty();\n+        names[\"object_storage\"] = &hasObjectStorage;\n         TServiceCfg hasClickhouseInternal = services.empty();\n         names[\"clickhouse_internal\"] = &hasClickhouseInternal;\n         TServiceCfg hasRateLimiter = false;\n@@ -724,6 +727,11 @@ void TKikimrRunner::InitializeGRpc(const TKikimrRunConfig& runConfig) {\n                 AppData->InFlightLimiterRegistry, grpcRequestProxies[0], hasClickhouseInternal.IsRlAllowed()));\n         }\n \n+        if (hasObjectStorage) {\n+            server.AddService(new NGRpcService::TGRpcYdbObjectStorageService(ActorSystem.Get(), Counters,\n+                grpcRequestProxies[0], hasObjectStorage.IsRlAllowed()));\n+        }\n+\n         if (hasScripting) {\n             server.AddService(new NGRpcService::TGRpcYdbScriptingService(ActorSystem.Get(), Counters,\n                 grpcRequestProxies[0], hasScripting.IsRlAllowed()));\ndiff --git a/ydb/core/grpc_services/rpc_calls.h b/ydb/core/grpc_services/rpc_calls.h\nindex bbf1ab148379..f0bfb3a3b9a3 100644\n--- a/ydb/core/grpc_services/rpc_calls.h\n+++ b/ydb/core/grpc_services/rpc_calls.h\n@@ -12,6 +12,8 @@\n #include <ydb/public/api/protos/ydb_discovery.pb.h>\n #include <ydb/public/api/protos/ydb_monitoring.pb.h>\n #include <ydb/public/api/protos/ydb_status_codes.pb.h>\n+#include <ydb/public/api/protos/ydb_table.pb.h>\n+#include <ydb/public/api/protos/draft/ydb_object_storage.pb.h>\n #include <ydb/public/api/protos/ydb_persqueue_cluster_discovery.pb.h>\n #include <ydb/public/api/protos/ydb_persqueue_v1.pb.h>\n #include <ydb/public/api/protos/ydb_federation_discovery.pb.h>\ndiff --git a/ydb/core/grpc_services/rpc_object_storage.cpp b/ydb/core/grpc_services/rpc_object_storage.cpp\nnew file mode 100644\nindex 000000000000..6f2ccde4edf4\n--- /dev/null\n+++ b/ydb/core/grpc_services/rpc_object_storage.cpp\n@@ -0,0 +1,940 @@\n+#include \"grpc_request_proxy.h\"\n+#include \"rpc_calls.h\"\n+\n+#include \"util/string/vector.h\"\n+#include \"ydb/library/yql/minikql/mkql_type_ops.h\"\n+#include <ydb/core/tx/scheme_cache/scheme_cache.h>\n+#include <ydb/core/tx/datashard/datashard.h>\n+#include <ydb/core/base/tablet_pipecache.h>\n+#include <ydb/core/base/path.h>\n+#include <ydb/core/engine/mkql_proto.h>\n+#include <ydb/core/actorlib_impl/long_timer.h>\n+#include <ydb/core/grpc_services/rpc_calls.h>\n+#include <ydb/core/ydb_convert/ydb_convert.h>\n+#include <ydb/core/kqp/common/kqp_types.h>\n+#include <ydb/core/scheme/scheme_type_info.h>\n+#include <util/system/unaligned_mem.h>\n+\n+#include <ydb/public/sdk/cpp/client/ydb_proto/accessor.h>\n+\n+namespace NKikimr {\n+namespace NGRpcService {\n+\n+using TEvObjectStorageListingRequest = TGrpcRequestOperationCall<Ydb::ObjectStorage::ListingRequest, Ydb::ObjectStorage::ListingResponse>;\n+\n+#define CHECK_OR_RETURN_ERROR(cond, descr) \\\n+    if (!(cond)) { \\\n+        errStr = descr; \\\n+        return false; \\\n+    }\n+\n+bool CellFromTuple(NScheme::TTypeInfo type,\n+                   const Ydb::Value& tupleValue,\n+                   ui32 position,\n+                   bool allowCastFromString,\n+                   TVector<TCell>& cells,\n+                   TString& errStr,\n+                   TVector<TString>& memoryOwner) {\n+    auto value_case = tupleValue.value_case();\n+\n+    CHECK_OR_RETURN_ERROR(value_case != Ydb::Value::VALUE_NOT_SET,\n+                            Sprintf(\"Data must be present at position %\" PRIu32, position));\n+\n+    CHECK_OR_RETURN_ERROR(tupleValue.itemsSize() == 0 &&\n+                            tupleValue.pairsSize() == 0,\n+                            Sprintf(\"Simple type is expected in tuple at position %\" PRIu32, position));\n+\n+    TCell c;\n+    auto typeId = type.GetTypeId();\n+    switch (typeId) {\n+\n+#define CASE_SIMPLE_TYPE(name, type, protoField) \\\n+    case NScheme::NTypeIds::name: \\\n+    { \\\n+        bool valuePresent = tupleValue.Has##protoField##_value(); \\\n+        if (valuePresent) { \\\n+            type val = tupleValue.Get##protoField##_value(); \\\n+            c = TCell((const char*)&val, sizeof(val)); \\\n+        } else if (allowCastFromString && tupleValue.Hastext_value()) { \\\n+            const auto slot = NUdf::GetDataSlot(typeId); \\\n+            const auto out = NMiniKQL::ValueFromString(slot, tupleValue.Gettext_value()); \\\n+            CHECK_OR_RETURN_ERROR(out, Sprintf(\"Cannot parse value of type \" #name \" from text '%s' in tuple at position %\" PRIu32, tupleValue.Gettext_value().data(), position)); \\\n+            const auto val = out.Get<type>(); \\\n+            c = TCell((const char*)&val, sizeof(val)); \\\n+        } else { \\\n+            CHECK_OR_RETURN_ERROR(false, Sprintf(\"Value of type \" #name \" expected in tuple at position %\" PRIu32, position)); \\\n+        } \\\n+        Y_ABORT_UNLESS(c.IsInline()); \\\n+        break; \\\n+    }\n+\n+    CASE_SIMPLE_TYPE(Bool,   bool,  bool);\n+    CASE_SIMPLE_TYPE(Int8,   i8,    int32);\n+    CASE_SIMPLE_TYPE(Uint8,  ui8,   uint32);\n+    CASE_SIMPLE_TYPE(Int16,  i16,   int32);\n+    CASE_SIMPLE_TYPE(Uint16, ui16,  uint32);\n+    CASE_SIMPLE_TYPE(Int32,  i32,   int32);\n+    CASE_SIMPLE_TYPE(Uint32, ui32,  uint32);\n+    CASE_SIMPLE_TYPE(Int64,  i64,   int64);\n+    CASE_SIMPLE_TYPE(Uint64, ui64,  uint64);\n+    CASE_SIMPLE_TYPE(Float,  float, float);\n+    CASE_SIMPLE_TYPE(Double, double, double);\n+    CASE_SIMPLE_TYPE(Date,   ui16,  uint32);\n+    CASE_SIMPLE_TYPE(Datetime, ui32, uint32);\n+    CASE_SIMPLE_TYPE(Timestamp, ui64, uint64);\n+    CASE_SIMPLE_TYPE(Interval, i64, int64);\n+\n+\n+#undef CASE_SIMPLE_TYPE\n+\n+    case NScheme::NTypeIds::Yson:\n+    case NScheme::NTypeIds::Json:\n+    case NScheme::NTypeIds::Utf8:\n+    {\n+        c = TCell(tupleValue.Gettext_value().data(), tupleValue.Gettext_value().size());\n+        break;\n+    }\n+    case NScheme::NTypeIds::JsonDocument:\n+    case NScheme::NTypeIds::DyNumber:\n+    {\n+        c = TCell(tupleValue.Getbytes_value().data(), tupleValue.Getbytes_value().size());\n+        break;\n+    }\n+    case NScheme::NTypeIds::String:\n+    {\n+        if (tupleValue.Hasbytes_value()) {\n+            c = TCell(tupleValue.Getbytes_value().data(), tupleValue.Getbytes_value().size());\n+        } else if (allowCastFromString && tupleValue.Hastext_value()) {\n+            c = TCell(tupleValue.Gettext_value().data(), tupleValue.Gettext_value().size());\n+        } else {\n+            CHECK_OR_RETURN_ERROR(false, Sprintf(\"Cannot parse value of type String in tuple at position %\" PRIu32, position));\n+        }\n+        break;\n+    }\n+    case NScheme::NTypeIds::Pg:\n+    {\n+        if (tupleValue.Hasbytes_value()) {\n+            c = TCell(tupleValue.Getbytes_value().data(), tupleValue.Getbytes_value().size());\n+        } else if (tupleValue.Hastext_value()) {\n+            auto typeDesc = type.GetTypeDesc();\n+            auto convert = NPg::PgNativeBinaryFromNativeText(tupleValue.Gettext_value(), NPg::PgTypeIdFromTypeDesc(typeDesc));\n+            if (convert.Error) {\n+                CHECK_OR_RETURN_ERROR(false, Sprintf(\"Cannot parse value of type Pg: %s in tuple at position %\" PRIu32, convert.Error->data(), position));\n+            } else {\n+                auto &data = memoryOwner.emplace_back(convert.Str);\n+                c = TCell(data);\n+            }\n+        } else {\n+            CHECK_OR_RETURN_ERROR(false, Sprintf(\"Cannot parse value of type Pg in tuple at position %\" PRIu32, position));\n+        }\n+        break;\n+    }\n+    case NScheme::NTypeIds::Uuid:\n+    {\n+        if (tupleValue.Haslow_128()) {\n+            auto &data = memoryOwner.emplace_back();\n+            data.resize(NUuid::UUID_LEN);\n+            NUuid::UuidHalfsToBytes(data.Detach(), data.size(), tupleValue.Gethigh_128(), tupleValue.Getlow_128());\n+            c = TCell(data);\n+        } else if (tupleValue.Hasbytes_value()) {\n+            Y_ABORT_UNLESS(tupleValue.Getbytes_value().size() == NUuid::UUID_LEN);\n+            c = TCell(tupleValue.Getbytes_value().data(), tupleValue.Getbytes_value().size());\n+        } else {\n+            CHECK_OR_RETURN_ERROR(false, Sprintf(\"Cannot parse value of type Uuid in tuple at position %\" PRIu32, position));\n+        }\n+        break;\n+    }\n+    default:\n+        CHECK_OR_RETURN_ERROR(false, Sprintf(\"Unsupported typeId %\" PRIu16 \" at index %\" PRIu32, typeId, position));\n+        break;\n+    }\n+\n+    CHECK_OR_RETURN_ERROR(!c.IsNull(), Sprintf(\"Invalid non-NULL value at index %\" PRIu32, position));\n+    cells.push_back(c);\n+\n+    return true;\n+}\n+\n+// NOTE: TCell's can reference memory from tupleValue\n+bool CellsFromTuple(const Ydb::Type* tupleType,\n+                    const Ydb::Value& tupleValue,\n+                    const TConstArrayRef<NScheme::TTypeInfo>& types,\n+                    bool allowCastFromString,\n+                    TVector<TCell>& key,\n+                    TString& errStr,\n+                    TVector<TString>& memoryOwner) {\n+    if (tupleType) {\n+        Ydb::Type::TypeCase typeCase = tupleType->type_case();\n+        CHECK_OR_RETURN_ERROR(typeCase == Ydb::Type::kTupleType ||\n+                              (typeCase == Ydb::Type::TYPE_NOT_SET && tupleType->tuple_type().elementsSize() == 0), \"Must be a tuple\");\n+        CHECK_OR_RETURN_ERROR(tupleType->tuple_type().elementsSize() <= types.size(),\n+            \"Tuple size \" + ToString(tupleType->tuple_type().elementsSize()) + \" is greater that expected size \" + ToString(types.size()));\n+\n+        for (size_t i = 0; i < tupleType->tuple_type().elementsSize(); ++i) {\n+            const auto& ti = tupleType->tuple_type().Getelements(i);\n+            CHECK_OR_RETURN_ERROR(ti.type_case() == Ydb::Type::kTypeId, \"Element at index \" + ToString(i) + \" in not a TypeId\");\n+            const auto& typeId = ti.Gettype_id();\n+            CHECK_OR_RETURN_ERROR(typeId == types[i].GetTypeId() ||\n+                allowCastFromString && (typeId == NScheme::NTypeIds::Utf8),\n+                \"Element at index \" + ToString(i) + \" has type \" + Type_PrimitiveTypeId_Name(typeId) + \" but expected type is \" + ToString(types[i].GetTypeId()));\n+        }\n+\n+        CHECK_OR_RETURN_ERROR(tupleType->Gettuple_type().elementsSize() == tupleValue.itemsSize(),\n+            Sprintf(\"Tuple value length %\" PRISZT \" doesn't match the length in type %\" PRISZT, tupleValue.itemsSize(), tupleType->Gettuple_type().elementsSize()));\n+    } else {\n+        CHECK_OR_RETURN_ERROR(types.size() >= tupleValue.itemsSize(),\n+            Sprintf(\"Tuple length %\" PRISZT \" is greater than key column count %\" PRISZT, tupleValue.itemsSize(), types.size()));\n+    }\n+\n+    for (ui32 i = 0; i < tupleValue.itemsSize(); ++i) {\n+        auto& v = tupleValue.Getitems(i);\n+\n+        bool parsed = CellFromTuple(types[i], v, i, allowCastFromString, key, errStr, memoryOwner);\n+\n+        if (!parsed) {\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+#undef CHECK_OR_RETURN_ERROR\n+\n+struct TFilter {\n+    TVector<ui32> ColumnIds;\n+    TSerializedCellVec FilterValues;\n+    TVector<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType> MatchTypes;\n+};\n+\n+class TObjectStorageListingRequestGrpc : public TActorBootstrapped<TObjectStorageListingRequestGrpc> {\n+private:\n+    typedef TActorBootstrapped<TThis> TBase;\n+\n+    static constexpr i32 DEFAULT_MAX_KEYS = 1001;\n+    static constexpr ui32 DEFAULT_TIMEOUT_SEC = 5*60;\n+\n+    std::unique_ptr<IRequestNoOpCtx> GrpcRequest;\n+    const Ydb::ObjectStorage::ListingRequest* Request;\n+    std::optional<NKikimrTxDataShard::TObjectStorageListingContinuationToken> ContinuationToken;\n+    THolder<const NACLib::TUserToken> UserToken;\n+    ui32 MaxKeys;\n+    TActorId SchemeCache;\n+    TActorId LeaderPipeCache;\n+    TDuration Timeout;\n+    TActorId TimeoutTimerActorId;\n+    TAutoPtr<TKeyDesc> KeyRange;\n+    bool WaitingResolveReply;\n+    bool Finished;\n+    TAutoPtr<NSchemeCache::TSchemeCacheNavigate> ResolveNamesResult;\n+    TVector<NScheme::TTypeInfo> KeyColumnTypes;\n+    TSysTables::TTableColumnInfo PathColumnInfo;\n+    TVector<TSysTables::TTableColumnInfo> CommonPrefixesColumns;\n+    TVector<TSysTables::TTableColumnInfo> ContentsColumns;\n+    TSerializedCellVec PrefixColumns;\n+    TSerializedCellVec StartAfterSuffixColumns;\n+    TSerializedCellVec KeyRangeFrom;\n+    TSerializedCellVec KeyRangeTo;\n+    TFilter Filter;\n+    ui32 CurrentShardIdx;\n+    TVector<TString> CommonPrefixesRows;\n+    TVector<TSerializedCellVec> ContentsRows;\n+\n+public:\n+    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n+        return NKikimrServices::TActivity::GRPC_REQ;\n+    }\n+\n+    TObjectStorageListingRequestGrpc(std::unique_ptr<IRequestNoOpCtx> request, TActorId schemeCache, THolder<const NACLib::TUserToken>&& userToken)\n+        : GrpcRequest(std::move(request))\n+        , Request(TEvObjectStorageListingRequest::GetProtoRequest(GrpcRequest.get()))\n+        , UserToken(std::move(userToken))\n+        , MaxKeys(DEFAULT_MAX_KEYS)\n+        , SchemeCache(schemeCache)\n+        , LeaderPipeCache(MakePipePeNodeCacheID(false))\n+        , Timeout(TDuration::Seconds(DEFAULT_TIMEOUT_SEC))\n+        , WaitingResolveReply(false)\n+        , Finished(false)\n+        , CurrentShardIdx(0)\n+    {\n+    }\n+\n+    void Bootstrap(const NActors::TActorContext& ctx) {\n+        TString errDescr;\n+        if (!Request) {\n+            return ReplyWithError(Ydb::StatusIds::BAD_REQUEST, errDescr, ctx);\n+        }\n+\n+        if (Request->Getmax_keys() > 0 && Request->Getmax_keys() <= DEFAULT_MAX_KEYS) {\n+            MaxKeys = Request->Getmax_keys();\n+        }\n+\n+        if (Request->continuation_token()) {\n+            NKikimrTxDataShard::TObjectStorageListingContinuationToken token;\n+            if (!token.ParseFromString(Request->continuation_token())) {\n+                return ReplyWithError(Ydb::StatusIds::BAD_REQUEST, \"Invalid ContinuationToken\", ctx);\n+            }\n+            ContinuationToken = std::move(token);\n+        }\n+\n+        // TODO: respect timeout parameter\n+        // ui32 userTimeoutMillisec = Request->GetTimeout();\n+        // if (userTimeoutMillisec > 0 && TDuration::MilliSeconds(userTimeoutMillisec) < Timeout) {\n+        //     Timeout = TDuration::MilliSeconds(userTimeoutMillisec);\n+        // }\n+\n+        ResolveTable(Request->Gettable_name(), ctx);\n+    }\n+\n+    void Die(const NActors::TActorContext& ctx) override {\n+        Y_VERIFY(Finished);\n+        Y_VERIFY(!WaitingResolveReply);\n+        ctx.Send(LeaderPipeCache, new TEvPipeCache::TEvUnlink(0));\n+        if (TimeoutTimerActorId) {\n+            ctx.Send(TimeoutTimerActorId, new TEvents::TEvPoisonPill());\n+        }\n+        TBase::Die(ctx);\n+    }\n+\n+private:\n+    STFUNC(StateWaitResolveTable) {\n+        switch (ev->GetTypeRewrite()) {\n+            HFunc(TEvTxProxySchemeCache::TEvNavigateKeySetResult, Handle);\n+            CFunc(TEvents::TSystem::Wakeup, HandleTimeout);\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    void ResolveTable(const TString& table, const NActors::TActorContext& ctx) {\n+        // TODO: check all params;\n+\n+        TAutoPtr<NSchemeCache::TSchemeCacheNavigate> request(new NSchemeCache::TSchemeCacheNavigate());\n+        NSchemeCache::TSchemeCacheNavigate::TEntry entry;\n+        entry.Path = NKikimr::SplitPath(table);\n+        if (entry.Path.empty()) {\n+            return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, \"Invalid table path specified\", ctx);\n+        }\n+        entry.Operation = NSchemeCache::TSchemeCacheNavigate::OpTable;\n+        request->ResultSet.emplace_back(entry);\n+        ctx.Send(SchemeCache, new TEvTxProxySchemeCache::TEvNavigateKeySet(request));\n+\n+        TimeoutTimerActorId = CreateLongTimer(ctx, Timeout,\n+            new IEventHandle(ctx.SelfID, ctx.SelfID, new TEvents::TEvWakeup()));\n+\n+        TBase::Become(&TThis::StateWaitResolveTable);\n+        WaitingResolveReply = true;\n+    }\n+\n+    Ydb::ObjectStorage::ListingResponse* CreateResponse() {\n+        return google::protobuf::Arena::CreateMessage<Ydb::ObjectStorage::ListingResponse>(Request->GetArena());\n+    }\n+\n+    void ReplyWithError(Ydb::StatusIds::StatusCode grpcStatus, const TString& message, const TActorContext& ctx) {\n+        auto* resp = CreateResponse();\n+        resp->set_status(grpcStatus);\n+\n+        if (!message.empty()) {\n+            const NYql::TIssue& issue = NYql::TIssue(message);\n+            auto* protoIssue = resp->add_issues();\n+            NYql::IssueToMessage(issue, protoIssue);\n+        }\n+\n+        GrpcRequest->Reply(resp, grpcStatus);\n+\n+        Finished = true;\n+\n+        // We cannot Die() while scheme cache request is in flight because that request has pointer to\n+        // KeyRange member so we must not destroy it before we get the response\n+        if (!WaitingResolveReply) {\n+            Die(ctx);\n+        }\n+    }\n+\n+    void HandleTimeout(const TActorContext& ctx) {\n+        return ReplyWithError(Ydb::StatusIds::TIMEOUT, \"Request timed out\", ctx);\n+    }\n+\n+    void Handle(TEvTxProxySchemeCache::TEvNavigateKeySetResult::TPtr& ev, const TActorContext& ctx) {\n+        WaitingResolveReply = false;\n+        if (Finished) {\n+            return Die(ctx);\n+        }\n+\n+        const NSchemeCache::TSchemeCacheNavigate& request = *ev->Get()->Request;\n+        Y_VERIFY(request.ResultSet.size() == 1);\n+        if (request.ResultSet.front().Status != NSchemeCache::TSchemeCacheNavigate::EStatus::Ok) {\n+            return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR,\n+                                  ToString(request.ResultSet.front().Status), ctx);\n+        }\n+        ResolveNamesResult = ev->Get()->Request;\n+\n+        if (!BuildSchema(ctx)) {\n+            return;\n+        }\n+\n+        if (!BuildKeyRange(ctx)) {\n+            return;\n+        }\n+\n+        ResolveShards(ctx);\n+    }\n+\n+    bool BuildSchema(const NActors::TActorContext& ctx) {\n+        Y_UNUSED(ctx);\n+\n+        auto& entry = ResolveNamesResult->ResultSet.front();\n+\n+        TVector<ui32> keyColumnIds;\n+        THashMap<TString, ui32> columnByName;\n+        for (const auto& ci : entry.Columns) {\n+            columnByName[ci.second.Name] = ci.second.Id;\n+            i32 keyOrder = ci.second.KeyOrder;\n+            if (keyOrder != -1) {\n+                Y_VERIFY(keyOrder >= 0);\n+                KeyColumnTypes.resize(Max<size_t>(KeyColumnTypes.size(), keyOrder + 1));\n+                KeyColumnTypes[keyOrder] = ci.second.PType;\n+                keyColumnIds.resize(Max<size_t>(keyColumnIds.size(), keyOrder + 1));\n+                keyColumnIds[keyOrder] = ci.second.Id;\n+            }\n+        }\n+\n+        TString errStr;\n+        TVector<TCell> prefixCells;\n+        TVector<TString> prefixMemoryOwner;\n+        TConstArrayRef<NScheme::TTypeInfo> prefixTypes(KeyColumnTypes.data(), KeyColumnTypes.size() - 1); // -1 for path column\n+        bool prefixParsedOk = CellsFromTuple(&Request->Getkey_prefix().Gettype(), Request->Getkey_prefix().Getvalue(),\n+                prefixTypes, true, prefixCells, errStr, prefixMemoryOwner);\n+\n+        if (!prefixParsedOk) {\n+            ReplyWithError(Ydb::StatusIds::BAD_REQUEST, \"Invalid KeyPrefix: \" + errStr, ctx);\n+            return false;\n+        }\n+\n+        PrefixColumns.Parse(TSerializedCellVec::Serialize(prefixCells));\n+\n+        // Check path column\n+        ui32 pathColPos = prefixCells.size();\n+        Y_VERIFY(pathColPos < KeyColumnTypes.size());\n+        PathColumnInfo = entry.Columns[keyColumnIds[pathColPos]];\n+        if (PathColumnInfo.PType.GetTypeId() != NScheme::NTypeIds::Utf8) {\n+            ReplyWithError(Ydb::StatusIds::BAD_REQUEST,\n+                           Sprintf(\"Value for path column '%s' has type %s, expected Utf8\",\n+                                   PathColumnInfo.Name.data(), NScheme::TypeName(PathColumnInfo.PType).c_str()), ctx);\n+            return false;\n+        }\n+\n+        CommonPrefixesColumns.push_back(PathColumnInfo);\n+\n+        TVector<TCell> suffixCells;\n+        TVector<TString> suffixMemoryOwner;\n+        TConstArrayRef<NScheme::TTypeInfo> suffixTypes(KeyColumnTypes.data() + pathColPos, KeyColumnTypes.size() - pathColPos); // starts at path column\n+        bool suffixParsedOk = CellsFromTuple(&Request->Getstart_after_key_suffix().Gettype(), Request->Getstart_after_key_suffix().Getvalue(),\n+                                 suffixTypes, true, suffixCells, errStr, suffixMemoryOwner);\n+        if (!suffixParsedOk) {\n+            ReplyWithError(Ydb::StatusIds::BAD_REQUEST,\n+                           \"Invalid StartAfterKeySuffix: \" + errStr, ctx);\n+            return false;\n+        }\n+\n+        StartAfterSuffixColumns.Parse(TSerializedCellVec::Serialize(suffixCells));\n+\n+        if (!StartAfterSuffixColumns.GetCells().empty()) {\n+            TString startAfterPath = TString(StartAfterSuffixColumns.GetCells()[0].Data(), StartAfterSuffixColumns.GetCells()[0].Size());\n+            if (!startAfterPath.StartsWith(Request->Getpath_column_prefix())) {\n+                ReplyWithError(Ydb::StatusIds::BAD_REQUEST,\n+                               \"Invalid StartAfterKeySuffix: StartAfter parameter doesn't match PathPrefix\", ctx);\n+                return false;\n+            }\n+        }\n+\n+        // Check ColumsToReturn\n+        TSet<TString> requestedColumns(Request->Getcolumns_to_return().begin(), Request->Getcolumns_to_return().end());\n+\n+        // Always request all suffix columns starting from path column\n+        for (size_t i = pathColPos; i < keyColumnIds.size(); ++i) {\n+            ui32 colId = keyColumnIds[i];\n+            requestedColumns.erase(entry.Columns[colId].Name);\n+            ContentsColumns.push_back(entry.Columns[colId]);\n+        }\n+\n+        for (const auto& name : requestedColumns) {\n+            if (!columnByName.contains(name)) {\n+                ReplyWithError(Ydb::StatusIds::BAD_REQUEST,\n+                               Sprintf(\"Unknown column '%s'\", name.data()), ctx);\n+                return false;\n+            }\n+            ContentsColumns.push_back(entry.Columns[columnByName[name]]);\n+        }\n+\n+        if (Request->has_matching_filter()) {\n+            THashMap<TString, ui32> columnToRequestIndex;\n+\n+            for (size_t i = 0; i < ContentsColumns.size(); i++) {\n+                columnToRequestIndex[ContentsColumns[i].Name] = i;\n+            }\n+\n+            const auto filter = Request->matching_filter();\n+\n+            const auto& filterValue = filter.value();\n+            const auto& filterType = filter.type().tuple_type().get_idx_elements(2);\n+\n+            if (filterValue.items_size() != 3) {\n+                ReplyWithError(Ydb::StatusIds::BAD_REQUEST, \"Wrong matching_filter format\", ctx);\n+                return false;\n+            }\n+\n+            const auto& columnNames = filterValue.get_idx_items(0);\n+            const auto& matcherTypes = filterValue.get_idx_items(1);\n+            const auto& columnValues = filterValue.get_idx_items(2);\n+\n+            if ((columnNames.items_size() != matcherTypes.items_size()) || (columnNames.items_size() != columnValues.items_size())) {\n+                ReplyWithError(Ydb::StatusIds::BAD_REQUEST, \"Wrong matching_filter format\", ctx);\n+                return false;\n+            }\n+\n+            TVector<NScheme::TTypeInfo> types;\n+\n+            for (int i = 0; i < columnNames.items_size(); i++) {\n+                const auto& colNameValue = columnNames.get_idx_items(i);\n+                const auto& colName = colNameValue.text_value();\n+\n+                const auto colIdIt = columnByName.find(colName);\n+\n+                if (colIdIt == columnByName.end()) {\n+                    ReplyWithError(Ydb::StatusIds::BAD_REQUEST,\n+                            Sprintf(\"Unknown filter column '%s'\", colName.data()), ctx);\n+                    return false;\n+                }\n+\n+                const auto& columnInfo = entry.Columns[colIdIt->second];\n+                const auto& type = columnInfo.PType;\n+\n+                types.push_back(type);\n+\n+                const auto [it, inserted] = columnToRequestIndex.try_emplace(colName, columnToRequestIndex.size());\n+\n+                if (inserted) {\n+                    ContentsColumns.push_back(columnInfo);\n+                }\n+\n+                Filter.ColumnIds.push_back(it->second);\n+\n+                ui32 matchType = matcherTypes.get_idx_items(i).uint32_value();\n+\n+                NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType dsMatchType;\n+\n+                switch (matchType) {\n+                    case Ydb::ObjectStorage::ListingRequest_EMatchType::ListingRequest_EMatchType_EQUAL:\n+                        dsMatchType = NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType::TObjectStorageListingFilter_EMatchType_EQUAL;\n+                        break;\n+                    case Ydb::ObjectStorage::ListingRequest_EMatchType::ListingRequest_EMatchType_NOT_EQUAL:\n+                        dsMatchType = NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType::TObjectStorageListingFilter_EMatchType_NOT_EQUAL;\n+                        break;\n+                    default:\n+                        ReplyWithError(Ydb::StatusIds::BAD_REQUEST, Sprintf(\"Wrong matching_filter match type %\" PRIu32, matchType), ctx);\n+                        return false;\n+                }\n+\n+                Filter.MatchTypes.push_back(dsMatchType);\n+            }\n+\n+            TConstArrayRef<NScheme::TTypeInfo> typesRef(types.data(), types.size());\n+\n+            TVector<TCell> cells;\n+            TVector<TString> owner;\n+\n+            TString err;\n+\n+            bool filterParsedOk = CellsFromTuple(&filterType, columnValues, typesRef, true, cells, err, owner);\n+            \n+            if (!filterParsedOk) {\n+                ReplyWithError(Ydb::StatusIds::BAD_REQUEST, Sprintf(\"Invalid filter: '%s'\", err.data()), ctx);\n+                return false;\n+            }\n+\n+            Filter.FilterValues.Parse(TSerializedCellVec::Serialize(cells));\n+        }\n+\n+        return true;\n+    }\n+\n+    bool BuildKeyRange(const NActors::TActorContext& ctx) {\n+        Y_UNUSED(ctx);\n+\n+        TVector<TCell> fromValues(PrefixColumns.GetCells().begin(), PrefixColumns.GetCells().end());\n+        TVector<TCell> toValues(PrefixColumns.GetCells().begin(), PrefixColumns.GetCells().end());\n+\n+        TString pathPrefix = Request->Getpath_column_prefix();\n+        TString endPathPrefix;\n+\n+        if (pathPrefix.empty()) {\n+            fromValues.resize(KeyColumnTypes.size());\n+        } else {\n+            // TODO: check for valid UTF-8\n+\n+            fromValues.push_back(TCell(pathPrefix.data(), pathPrefix.size()));\n+            fromValues.resize(KeyColumnTypes.size());\n+\n+            endPathPrefix = pathPrefix;\n+            // pathPrefix must be a valid Utf8 string, so it cannot contain 0xff byte and its safe to add 1\n+            // to make end of range key\n+            endPathPrefix.back() = endPathPrefix.back() + 1;\n+            toValues.push_back(TCell(endPathPrefix.data(), endPathPrefix.size()));\n+            toValues.resize(KeyColumnTypes.size());\n+        }\n+\n+        if (!StartAfterSuffixColumns.GetCells().empty()) {\n+            // TODO: check for valid UTF-8\n+            for (size_t i = 0; i < StartAfterSuffixColumns.GetCells().size(); ++i) {\n+                fromValues[PathColumnInfo.KeyOrder + i] = StartAfterSuffixColumns.GetCells()[i];\n+            }\n+        }\n+\n+        if (ContinuationToken) {\n+            TString lastPath = ContinuationToken->Getlast_path();\n+            fromValues[PathColumnInfo.KeyOrder] = TCell(lastPath.data(), lastPath.size());\n+        }\n+\n+        KeyRangeFrom.Parse(TSerializedCellVec::Serialize(fromValues));\n+        KeyRangeTo.Parse(TSerializedCellVec::Serialize(toValues));\n+\n+        TTableRange range(KeyRangeFrom.GetCells(), true,\n+                          KeyRangeTo.GetCells(), false,\n+                          false);\n+\n+        TVector<TKeyDesc::TColumnOp> columns;\n+        for (const auto& ci : ContentsColumns) {\n+            TKeyDesc::TColumnOp op = { ci.Id, TKeyDesc::EColumnOperation::Read, ci.PType, 0, 0 };\n+            columns.push_back(op);\n+        }\n+\n+        auto& entry = ResolveNamesResult->ResultSet.front();\n+\n+        KeyRange.Reset(new TKeyDesc(entry.TableId, range, TKeyDesc::ERowOperation::Read, KeyColumnTypes, columns));\n+        return true;\n+    }\n+\n+    void ResolveShards(const NActors::TActorContext& ctx) {\n+        TAutoPtr<NSchemeCache::TSchemeCacheRequest> request(new NSchemeCache::TSchemeCacheRequest());\n+\n+        request->ResultSet.emplace_back(std::move(KeyRange));\n+\n+        TAutoPtr<TEvTxProxySchemeCache::TEvResolveKeySet> resolveReq(new TEvTxProxySchemeCache::TEvResolveKeySet(request));\n+        ctx.Send(SchemeCache, resolveReq.Release());\n+\n+        TBase::Become(&TThis::StateWaitResolveShards);\n+        WaitingResolveReply = true;\n+    }\n+\n+    STFUNC(StateWaitResolveShards) {\n+        switch (ev->GetTypeRewrite()) {\n+            HFunc(TEvTxProxySchemeCache::TEvResolveKeySetResult, Handle);\n+            CFunc(TEvents::TSystem::Wakeup, HandleTimeout);\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    bool CheckAccess(TString& errorMessage) {\n+        const ui32 access = NACLib::EAccessRights::SelectRow;\n+        if (access != 0\n+                && UserToken != nullptr\n+                && KeyRange->Status == TKeyDesc::EStatus::Ok\n+                && KeyRange->SecurityObject != nullptr\n+                && !KeyRange->SecurityObject->CheckAccess(access, *UserToken))\n+        {\n+            TStringStream explanation;\n+            explanation << \"Access denied for \" << UserToken->GetUserSID()\n+                        << \" with access \" << NACLib::AccessRightsToString(access)\n+                        << \" to table [\" << Request->Gettable_name() << \"]\";\n+\n+            errorMessage = explanation.Str();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void Handle(TEvTxProxySchemeCache::TEvResolveKeySetResult::TPtr &ev, const TActorContext &ctx) {\n+        WaitingResolveReply = false;\n+        if (Finished) {\n+            return Die(ctx);\n+        }\n+\n+        TEvTxProxySchemeCache::TEvResolveKeySetResult *msg = ev->Get();\n+        Y_VERIFY(msg->Request->ResultSet.size() == 1);\n+        KeyRange = std::move(msg->Request->ResultSet[0].KeyDescription);\n+\n+        if (msg->Request->ErrorCount > 0) {\n+            return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR,\n+                                  Sprintf(\"Unknown table '%s'\", Request->Gettable_name().data()), ctx);\n+        }\n+\n+        TString accessCheckError;\n+        if (!CheckAccess(accessCheckError)) {\n+            return ReplyWithError(Ydb::StatusIds::UNAUTHORIZED, accessCheckError, ctx);\n+        }\n+\n+        auto getShardsString = [] (const TVector<TKeyDesc::TPartitionInfo>& partitions) {\n+            TVector<ui64> shards;\n+            shards.reserve(partitions.size());\n+            for (auto& partition : partitions) {\n+                shards.push_back(partition.ShardId);\n+            }\n+\n+            return JoinVectorIntoString(shards, \", \");\n+        };\n+\n+        LOG_DEBUG_S(ctx, NKikimrServices::RPC_REQUEST, \"Range shards: \"\n+            << getShardsString(KeyRange->GetPartitions()));\n+\n+        if (KeyRange->GetPartitions().size() > 0) {\n+            CurrentShardIdx = 0;\n+            MakeShardRequest(CurrentShardIdx, ctx);\n+        } else {\n+            ReplySuccess(ctx, false);\n+        }\n+    }\n+\n+    void MakeShardRequest(ui32 idx, const NActors::TActorContext& ctx) {\n+        ui64 shardId = KeyRange->GetPartitions()[idx].ShardId;\n+\n+        THolder<TEvDataShard::TEvObjectStorageListingRequest> ev(new TEvDataShard::TEvObjectStorageListingRequest());\n+        ev->Record.SetTableId(KeyRange->TableId.PathId.LocalPathId);\n+        ev->Record.SetSerializedKeyPrefix(PrefixColumns.GetBuffer());\n+        ev->Record.SetPathColumnPrefix(Request->Getpath_column_prefix());\n+        ev->Record.SetPathColumnDelimiter(Request->Getpath_column_delimiter());\n+        ev->Record.SetSerializedStartAfterKeySuffix(StartAfterSuffixColumns.GetBuffer());\n+        ev->Record.SetMaxKeys(MaxKeys - ContentsRows.size() - CommonPrefixesRows.size());\n+        \n+        if (!CommonPrefixesRows.empty()) {\n+            // Next shard might have the same common prefix, need to skip it\n+            ev->Record.SetLastCommonPrefix(CommonPrefixesRows.back());\n+        }\n+\n+        if (ContinuationToken) {\n+            ev->Record.SetLastPath(ContinuationToken->Getlast_path());\n+            if (CommonPrefixesRows.empty() && ContinuationToken->is_folder()) {\n+                ev->Record.SetLastCommonPrefix(ContinuationToken->Getlast_path());\n+            }\n+        }\n+\n+        for (const auto& ci : ContentsColumns) {\n+            ev->Record.AddColumnsToReturn(ci.Id);\n+        }\n+\n+        if (!Filter.ColumnIds.empty()) {\n+            auto* filter = ev->Record.mutable_filter();\n+            \n+            for (const auto& colId : Filter.ColumnIds) {\n+                filter->add_columns(colId);\n+            }\n+\n+            filter->set_values(Filter.FilterValues.GetBuffer());\n+\n+            for (const auto& matchType : Filter.MatchTypes) {\n+                filter->add_matchtypes(matchType);\n+            }\n+        }\n+\n+        LOG_DEBUG_S(ctx, NKikimrServices::RPC_REQUEST, \"Sending request to shards \" << shardId);\n+\n+        ctx.Send(LeaderPipeCache, new TEvPipeCache::TEvForward(ev.Release(), shardId, true), IEventHandle::FlagTrackDelivery);\n+\n+        TBase::Become(&TThis::StateWaitResults);\n+    }\n+\n+    void Handle(TEvents::TEvUndelivered::TPtr &ev, const TActorContext &ctx) {\n+        Y_UNUSED(ev);\n+        ReplyWithError(Ydb::StatusIds::INTERNAL_ERROR,\n+                       \"Internal error: pipe cache is not available, the cluster might not be configured properly\", ctx);\n+    }\n+\n+    void Handle(TEvPipeCache::TEvDeliveryProblem::TPtr &ev, const TActorContext &ctx) {\n+        Y_UNUSED(ev);\n+        // Invalidate scheme cache in case of partitioning change\n+        ctx.Send(SchemeCache, new TEvTxProxySchemeCache::TEvInvalidateTable(KeyRange->TableId, TActorId()));\n+        ReplyWithError(Ydb::StatusIds::UNAVAILABLE, \"Failed to connect to shard\", ctx);\n+    }\n+\n+    STFUNC(StateWaitResults) {\n+        switch (ev->GetTypeRewrite()) {\n+            HFunc(TEvDataShard::TEvObjectStorageListingResponse, Handle);\n+            HFunc(TEvents::TEvUndelivered, Handle);\n+            HFunc(TEvPipeCache::TEvDeliveryProblem, Handle);\n+            CFunc(TEvents::TSystem::Wakeup, HandleTimeout);\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    void Handle(TEvDataShard::TEvObjectStorageListingResponse::TPtr& ev, const NActors::TActorContext& ctx) {\n+        const auto& shardResponse = ev->Get()->Record;\n+\n+        // Notify the cache that we are done with the pipe\n+        ctx.Send(LeaderPipeCache, new TEvPipeCache::TEvUnlink(shardResponse.GetTabletID()));\n+\n+        if (shardResponse.GetStatus() == NKikimrTxDataShard::TError::WRONG_SHARD_STATE) {\n+            // Invalidate scheme cache in case of partitioning change\n+            ctx.Send(SchemeCache, new TEvTxProxySchemeCache::TEvInvalidateTable(KeyRange->TableId, TActorId()));\n+            ReplyWithError(Ydb::StatusIds::UNAVAILABLE, shardResponse.GetErrorDescription(), ctx);\n+            return;\n+        }\n+\n+        if (shardResponse.GetStatus() != NKikimrTxDataShard::TError::OK) {\n+            ReplyWithError(Ydb::StatusIds::GENERIC_ERROR, shardResponse.GetErrorDescription(), ctx);\n+            return;\n+        }\n+\n+        for (size_t i = 0; i < shardResponse.CommonPrefixesRowsSize(); ++i) {\n+            if (!CommonPrefixesRows.empty() && CommonPrefixesRows.back() == shardResponse.GetCommonPrefixesRows(i)) {\n+                LOG_ERROR_S(ctx, NKikimrServices::RPC_REQUEST, \"S3 listing got duplicate common prefix from shard \" << shardResponse.GetTabletID());\n+            }\n+            CommonPrefixesRows.emplace_back(shardResponse.GetCommonPrefixesRows(i));\n+        }\n+\n+        for (size_t i = 0; i < shardResponse.ContentsRowsSize(); ++i) {\n+            ContentsRows.emplace_back(shardResponse.GetContentsRows(i));\n+        }\n+\n+        bool hasMoreShards = CurrentShardIdx + 1 < KeyRange->GetPartitions().size();\n+        bool maxKeysExhausted = MaxKeys <= ContentsRows.size() + CommonPrefixesRows.size();\n+\n+        if (hasMoreShards &&\n+            !maxKeysExhausted &&\n+            shardResponse.GetMoreRows())\n+        {\n+            ++CurrentShardIdx;\n+            MakeShardRequest(CurrentShardIdx, ctx);\n+        } else {\n+            ReplySuccess(ctx, (hasMoreShards && shardResponse.GetMoreRows()) || maxKeysExhausted);\n+        }\n+    }\n+\n+    void FillResultRows(Ydb::ResultSet &resultSet, TVector<TSysTables::TTableColumnInfo> &columns, TVector<TSerializedCellVec> resultRows) {\n+        const auto getPgTypeFromColMeta = [](const auto &colMeta) {\n+            return NYdb::TPgType(NPg::PgTypeNameFromTypeDesc(colMeta.PType.GetTypeDesc()),\n+                                 colMeta.PTypeMod);\n+        };\n+\n+        const auto getTypeFromColMeta = [&](const auto &colMeta) {\n+            if (colMeta.PType.GetTypeId() == NScheme::NTypeIds::Pg) {\n+                return NYdb::TTypeBuilder().Pg(getPgTypeFromColMeta(colMeta)).Build();\n+            } else {\n+                return NYdb::TTypeBuilder()\n+                    .Primitive((NYdb::EPrimitiveType)colMeta.PType.GetTypeId())\n+                    .Build();\n+            }\n+        };\n+\n+        for (const auto& colMeta : columns) {\n+            const auto type = getTypeFromColMeta(colMeta);\n+            auto* col = resultSet.Addcolumns();\n+            \n+            *col->mutable_type()->mutable_optional_type()->mutable_item() = NYdb::TProtoAccessor::GetProto(type);\n+            *col->mutable_name() = colMeta.Name;\n+        }\n+\n+        for (auto& row : resultRows) {\n+            NYdb::TValueBuilder vb;\n+            vb.BeginStruct();\n+            for (size_t i = 0; i < columns.size(); ++i) {\n+                const auto& colMeta = columns[i];\n+\n+                const auto& cell = row.GetCells()[i];\n+                vb.AddMember(colMeta.Name);\n+                if (colMeta.PType.GetTypeId() == NScheme::NTypeIds::Pg) {\n+                    const NPg::TConvertResult& pgResult = NPg::PgNativeTextFromNativeBinary(cell.AsBuf(), colMeta.PType.GetTypeDesc());\n+                    if (pgResult.Error) {\n+                        LOG_DEBUG_S(TlsActivationContext->AsActorContext(), NKikimrServices::RPC_REQUEST, \"PgNativeTextFromNativeBinary error \" << *pgResult.Error);\n+                    }\n+                    const NYdb::TPgValue pgValue{cell.IsNull() ? NYdb::TPgValue::VK_NULL : NYdb::TPgValue::VK_TEXT, pgResult.Str, getPgTypeFromColMeta(colMeta)};\n+                    vb.Pg(pgValue);\n+                }\n+                else {\n+                    const NScheme::TTypeInfo& typeInfo = colMeta.PType;\n+\n+                    if (cell.IsNull()) {\n+                        vb.EmptyOptional((NYdb::EPrimitiveType)typeInfo.GetTypeId());\n+                    } else {\n+                        vb.BeginOptional();\n+                        ProtoValueFromCell(vb, typeInfo, cell);\n+                        vb.EndOptional();\n+                    }\n+                }\n+            }\n+            vb.EndStruct();\n+            auto proto = NYdb::TProtoAccessor::GetProto(vb.Build());\n+            *resultSet.add_rows() = std::move(proto);\n+        }\n+    }\n+\n+    void ReplySuccess(const NActors::TActorContext& ctx, bool isTruncated) {\n+        auto* resp = CreateResponse();\n+        resp->set_status(Ydb::StatusIds::SUCCESS);\n+\n+        resp->set_is_truncated(isTruncated);\n+\n+        for (auto commonPrefix : CommonPrefixesRows) {\n+            resp->add_common_prefixes(commonPrefix);\n+        }\n+\n+        auto &contents = *resp->mutable_contents();\n+        contents.set_truncated(false);\n+        FillResultRows(contents, ContentsColumns, ContentsRows);\n+\n+        TString lastFile;\n+        TString lastDirectory;\n+        if (ContentsRows.size() > 0) {\n+            // Path column is always first.\n+            TSerializedCellVec &row = ContentsRows[ContentsRows.size() - 1];\n+            const auto& cell = row.GetCells()[0];\n+            lastFile = TString(cell.AsBuf().data(), cell.AsBuf().size());\n+        }\n+\n+        if (CommonPrefixesRows.size() > 0) {\n+            lastDirectory = CommonPrefixesRows[CommonPrefixesRows.size() - 1];\n+        }\n+        \n+        if (isTruncated && (lastDirectory || lastFile)) {\n+            NKikimrTxDataShard::TObjectStorageListingContinuationToken token;\n+            \n+            if (lastDirectory > lastFile) {\n+                token.set_last_path(lastDirectory);\n+                token.set_is_folder(true);\n+            } else {\n+                token.set_last_path(lastFile);\n+                token.set_is_folder(false);\n+            }\n+\n+            TString serializedToken = token.SerializeAsString();\n+            \n+            resp->set_next_continuation_token(serializedToken);\n+        }\n+\n+        try {\n+            GrpcRequest->Reply(resp, Ydb::StatusIds::SUCCESS);\n+        } catch(std::exception ex) {\n+            GrpcRequest->RaiseIssue(NYql::ExceptionToIssue(ex));\n+            GrpcRequest->ReplyWithYdbStatus(Ydb::StatusIds::INTERNAL_ERROR);\n+        }\n+        \n+        Finished = true;\n+        Die(ctx);\n+    }\n+};\n+\n+IActor* CreateGrpcObjectStorageListingHandler(std::unique_ptr<IRequestNoOpCtx> request) {\n+    TActorId schemeCache = MakeSchemeCacheID();\n+    auto token = THolder<const NACLib::TUserToken>(request->GetInternalToken() ? new NACLib::TUserToken(request->GetSerializedToken()) : nullptr);\n+    return new TObjectStorageListingRequestGrpc(std::move(request), schemeCache, std::move(token));\n+}\n+\n+void DoObjectStorageListingRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f) {\n+    f.RegisterActor(CreateGrpcObjectStorageListingHandler(std::move(p)));\n+}\n+\n+} // namespace NKikimr\n+} // namespace NGRpcService\ndiff --git a/ydb/core/grpc_services/service_object_storage.h b/ydb/core/grpc_services/service_object_storage.h\nnew file mode 100644\nindex 000000000000..adf98fc8514d\n--- /dev/null\n+++ b/ydb/core/grpc_services/service_object_storage.h\n@@ -0,0 +1,14 @@\n+#pragma once\n+\n+#include <memory>\n+\n+namespace NKikimr {\n+namespace NGRpcService {\n+\n+class IRequestNoOpCtx;\n+class IFacilityProvider;\n+\n+void DoObjectStorageListingRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f);\n+\n+} // namespace NGRpcService\n+} // namespace NKikimr\ndiff --git a/ydb/core/grpc_services/ya.make b/ydb/core/grpc_services/ya.make\nindex 77fb715ad52b..673787da36cc 100644\n--- a/ydb/core/grpc_services/ya.make\n+++ b/ydb/core/grpc_services/ya.make\n@@ -72,6 +72,7 @@ SRCS(\n     rpc_stream_execute_scan_query.cpp\n     rpc_stream_execute_yql_script.cpp\n     rpc_whoami.cpp\n+    rpc_object_storage.cpp\n     table_settings.cpp\n \n     rpc_common/rpc_common_kqp_session.cpp\ndiff --git a/ydb/core/protos/tx_datashard.proto b/ydb/core/protos/tx_datashard.proto\nindex 40e0fd8a9038..eae6a4ea4ae7 100644\n--- a/ydb/core/protos/tx_datashard.proto\n+++ b/ydb/core/protos/tx_datashard.proto\n@@ -806,6 +806,48 @@ message TEvPeriodicTableStats {\n     repeated TEvPeriodicTableStats Tables = 14;\n }\n \n+message TObjectStorageListingFilter {\n+    enum EMatchType {\n+        EQUAL = 0;\n+        NOT_EQUAL = 1;\n+    }\n+    optional bytes Values = 1;\n+    repeated uint32 Columns = 2;\n+    repeated EMatchType MatchTypes = 3; \n+}\n+\n+message TEvObjectStorageListingRequest {\n+    optional uint64 TableId = 1;\n+    optional bytes SerializedKeyPrefix = 2;\n+\n+    optional string PathColumnPrefix = 3;\n+    optional string PathColumnDelimiter = 4;\n+\n+    optional bytes SerializedStartAfterKeySuffix = 5;\n+\n+    repeated uint32 ColumnsToReturn = 6;\n+    optional uint32 MaxKeys = 7;\n+\n+    optional string LastCommonPrefix = 8;\n+    optional string LastPath = 9;\n+\n+    optional TObjectStorageListingFilter Filter = 10;\n+}\n+\n+message TEvObjectStorageListingResponse {\n+    optional uint64 TabletID = 1;\n+    optional uint32 Status = 2;\n+    optional string ErrorDescription = 3;\n+    repeated string CommonPrefixesRows = 4;\n+    repeated bytes ContentsRows = 5;        // TSerializedCellVec\n+    optional bool MoreRows = 6;\n+}\n+\n+message TObjectStorageListingContinuationToken {\n+    optional string last_path = 1;\n+    optional bool is_folder = 2;\n+}\n+\n message TSerializedRowColumnsScheme {\n     repeated uint32 KeyColumnIds = 1;\n     repeated uint32 ValueColumnIds = 2;\ndiff --git a/ydb/core/tx/datashard/datashard.h b/ydb/core/tx/datashard/datashard.h\nindex fbd1c82d588f..129eb0125b04 100644\n--- a/ydb/core/tx/datashard/datashard.h\n+++ b/ydb/core/tx/datashard/datashard.h\n@@ -241,8 +241,8 @@ struct TEvDataShard {\n         EvGetTableStatsResult,\n         EvPeriodicTableStats,\n \n-        EvS3ListingRequest,\n-        EvS3ListingResponse,\n+        EvObjectStorageListingRequest,\n+        EvObjectStorageListingResponse,\n \n         EvUploadRowsRequest,\n         EvUploadRowsResponse,\n@@ -1383,6 +1383,25 @@ struct TEvDataShard {\n         }\n     };\n \n+    struct TEvObjectStorageListingRequest\n+        : public TEventPB<TEvObjectStorageListingRequest,\n+                            NKikimrTxDataShard::TEvObjectStorageListingRequest,\n+                            TEvDataShard::EvObjectStorageListingRequest> {\n+        TEvObjectStorageListingRequest() = default;\n+    };\n+\n+    struct TEvObjectStorageListingResponse\n+         : public TEventPB<TEvObjectStorageListingResponse,\n+                            NKikimrTxDataShard::TEvObjectStorageListingResponse,\n+                            TEvDataShard::EvObjectStorageListingResponse> {\n+        TEvObjectStorageListingResponse() = default;\n+\n+        explicit TEvObjectStorageListingResponse(ui64 tabletId, ui32 status = NKikimrTxDataShard::TError::OK) {\n+            Record.SetTabletID(tabletId);\n+            Record.SetStatus(status);\n+        }\n+    };\n+\n     struct TEvEraseRowsRequest\n         : public TEventPB<TEvEraseRowsRequest,\n                           NKikimrTxDataShard::TEvEraseRowsRequest,\ndiff --git a/ydb/core/tx/datashard/datashard__object_storage_listing.cpp b/ydb/core/tx/datashard/datashard__object_storage_listing.cpp\nnew file mode 100644\nindex 000000000000..8f374f5a11ba\n--- /dev/null\n+++ b/ydb/core/tx/datashard/datashard__object_storage_listing.cpp\n@@ -0,0 +1,427 @@\n+#include \"datashard_impl.h\"\n+#include <util/string/vector.h>\n+\n+namespace NKikimr {\n+namespace NDataShard {\n+\n+using namespace NTabletFlatExecutor;\n+\n+class TDataShard::TTxObjectStorageListing : public NTabletFlatExecutor::TTransactionBase<TDataShard> {\n+private:\n+    TEvDataShard::TEvObjectStorageListingRequest::TPtr Ev;\n+    TAutoPtr<TEvDataShard::TEvObjectStorageListingResponse> Result;\n+\n+    // Used to continue iteration from last known position instead of restarting from the beginning\n+    // This greatly improves performance for the cases with many deletion markers but sacrifices\n+    // consitency within the shard. This in not a big deal because listings are not consistent across shards.\n+    TString LastPath;\n+    TString LastCommonPath;\n+    ui32 RestartCount;\n+\n+public:\n+    TTxObjectStorageListing(TDataShard* ds, TEvDataShard::TEvObjectStorageListingRequest::TPtr ev)\n+        : TBase(ds)\n+        , Ev(ev)\n+        , RestartCount(0)\n+    {}\n+\n+    TTxType GetTxType() const override { return TXTYPE_S3_LISTING; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext& ctx) override {\n+        ++RestartCount;\n+\n+        if (!Result) {\n+            Result = new TEvDataShard::TEvObjectStorageListingResponse(Self->TabletID());\n+        }\n+\n+        if (Self->State != TShardState::Ready &&\n+            Self->State != TShardState::Readonly &&\n+            Self->State != TShardState::SplitSrcWaitForNoTxInFlight &&\n+            Self->State != TShardState::Frozen) {\n+            SetError(NKikimrTxDataShard::TError::WRONG_SHARD_STATE,\n+                        Sprintf(\"Wrong shard state: %\" PRIu32 \" tablet id: %\" PRIu64, Self->State, Self->TabletID()));\n+            return true;\n+        }\n+\n+        const ui64 tableId = Ev->Get()->Record.GetTableId();\n+        const ui64 maxKeys = Ev->Get()->Record.GetMaxKeys();\n+\n+        if (!Self->TableInfos.contains(tableId)) {\n+            SetError(NKikimrTxDataShard::TError::SCHEME_ERROR, Sprintf(\"Unknown table id %\" PRIu64, tableId));\n+            return true;\n+        }\n+\n+        const TUserTable& tableInfo = *Self->TableInfos[tableId];\n+        if (tableInfo.IsBackup) {\n+            SetError(NKikimrTxDataShard::TError::SCHEME_ERROR, \"Cannot read from a backup table\");\n+            return true;\n+        }\n+\n+        const ui32 localTableId = tableInfo.LocalTid;\n+\n+        TVector<TRawTypeValue> key;\n+        TVector<TRawTypeValue> endKey;\n+        bool endKeyInclusive = true;\n+\n+        // TODO: check prefix column count against key column count\n+        const TSerializedCellVec prefixColumns(Ev->Get()->Record.GetSerializedKeyPrefix());\n+        for (ui32 ki = 0; ki < prefixColumns.GetCells().size(); ++ki) {\n+            // TODO: check prefix column type\n+            auto &cell = prefixColumns.GetCells()[ki];\n+            auto &type = tableInfo.KeyColumnTypes[ki];\n+            key.emplace_back(cell.Data(), cell.Size(), type);\n+            endKey.emplace_back(cell.Data(), cell.Size(), type);\n+        }\n+        const ui32 pathColPos = prefixColumns.GetCells().size();\n+\n+        size_t columnCount = txc.DB.GetScheme().GetTableInfo(localTableId)->KeyColumns.size();\n+\n+        // TODO: check path column is present in schema and has Utf8 type\n+        const TString pathPrefix = Ev->Get()->Record.GetPathColumnPrefix();\n+        const TString pathSeparator = Ev->Get()->Record.GetPathColumnDelimiter();\n+\n+        TString startAfterPath;\n+        bool minKeyInclusive = false;\n+        TSerializedCellVec suffixColumns;\n+        if (Ev->Get()->Record.GetSerializedStartAfterKeySuffix().empty()) {\n+            if (Ev->Get()->Record.HasLastPath()) {\n+                TString reqLastPath = Ev->Get()->Record.GetLastPath();\n+\n+                key.emplace_back(reqLastPath, NScheme::TTypeInfo(NScheme::NTypeIds::Utf8));\n+\n+                startAfterPath = reqLastPath;\n+            } else {\n+                minKeyInclusive = true;\n+                key.emplace_back(pathPrefix.data(), pathPrefix.size(), NScheme::TTypeInfo(NScheme::NTypeIds::Utf8));\n+                key.resize(columnCount);\n+            }\n+        } else {\n+            suffixColumns.Parse(Ev->Get()->Record.GetSerializedStartAfterKeySuffix());\n+            size_t prefixSize = prefixColumns.GetCells().size();\n+\n+            if (Ev->Get()->Record.HasLastPath()) {\n+                TString reqLastPath = Ev->Get()->Record.GetLastPath();\n+                \n+                key.emplace_back(reqLastPath, tableInfo.KeyColumnTypes[prefixSize]);\n+\n+                for (size_t i = 1; i < suffixColumns.GetCells().size(); ++i) {\n+                    size_t ki = prefixSize + i;\n+                    key.emplace_back(suffixColumns.GetCells()[i].Data(), suffixColumns.GetCells()[i].Size(), tableInfo.KeyColumnTypes[ki]);\n+                }\n+                \n+                startAfterPath = reqLastPath;\n+            } else {\n+                for (size_t i = 0; i < suffixColumns.GetCells().size(); ++i) {\n+                    size_t ki = prefixSize + i;\n+                    key.emplace_back(suffixColumns.GetCells()[i].Data(), suffixColumns.GetCells()[i].Size(), tableInfo.KeyColumnTypes[ki]);\n+                }\n+                startAfterPath = TString(suffixColumns.GetCells()[0].Data(), suffixColumns.GetCells()[0].Size());\n+            }\n+        }\n+\n+        TString lastCommonPath; // we will skip a common prefix iff it has been already returned from the prevoius shard\n+        if (Ev->Get()->Record.HasLastCommonPrefix()) {\n+            lastCommonPath = Ev->Get()->Record.GetLastCommonPrefix();\n+        }\n+\n+        // If this trasaction has restarted we want to continue from the last seen key\n+        if (LastPath) {\n+            const size_t pathColIdx =  prefixColumns.GetCells().size();\n+            key.resize(pathColIdx);\n+            key.emplace_back(LastPath.data(), LastPath.size(), NScheme::TTypeInfo(NScheme::NTypeIds::Utf8));\n+            key.resize(columnCount);\n+\n+            lastCommonPath = LastCommonPath;\n+        } else {\n+            LastCommonPath = lastCommonPath;\n+        }\n+\n+        const TString pathEndPrefix = NextPrefix(pathPrefix);\n+        if (pathEndPrefix) {\n+            endKey.emplace_back(pathEndPrefix.data(), pathEndPrefix.size(), NScheme::TTypeInfo(NScheme::NTypeIds::Utf8));\n+            while (endKey.size() < tableInfo.KeyColumnTypes.size()) {\n+                endKey.emplace_back();\n+            }\n+            endKeyInclusive = false;\n+        }\n+\n+        LOG_DEBUG_S(ctx, NKikimrServices::TX_DATASHARD, Self->TabletID() << \" S3 Listing: start at key (\"\n+            << JoinVectorIntoString(key, \" \") << \"), end at key (\" << JoinVectorIntoString(endKey, \" \") << \")\"\n+            << \" restarted: \" << RestartCount-1 << \" last path: \\\"\" << LastPath << \"\\\"\"\n+            << \" contents: \" << Result->Record.ContentsRowsSize()\n+            << \" common prefixes: \" << Result->Record.CommonPrefixesRowsSize());\n+\n+        Result->Record.SetMoreRows(!IsKeyInRange(endKey, tableInfo));\n+\n+        if (!maxKeys) {\n+            // Nothing to return, don't bother searching\n+            return true;\n+        }\n+\n+        // Select path column and all user-requested columns\n+        const TVector<ui32> columnsToReturn(Ev->Get()->Record.GetColumnsToReturn().begin(), Ev->Get()->Record.GetColumnsToReturn().end());\n+\n+        NTable::TKeyRange keyRange;\n+        keyRange.MinKey = key;\n+        keyRange.MinInclusive = minKeyInclusive;\n+        keyRange.MaxKey = endKey;\n+        keyRange.MaxInclusive = endKeyInclusive;\n+\n+        if (LastPath) {\n+            // Don't include the last key in case of restart\n+            keyRange.MinInclusive = false;\n+        }\n+\n+        bool hasFilter = Ev->Get()->Record.has_filter();\n+        TSerializedCellVec filterColumnValues;\n+        TVector<ui32> filterColumnIds;\n+        TVector<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType> matchTypes;\n+\n+        if (hasFilter) {\n+            const auto& filter = Ev->Get()->Record.filter();\n+\n+            filterColumnValues.Parse(filter.values());\n+            for (const auto& colId : filter.columns()) {\n+                filterColumnIds.push_back(colId);\n+            }\n+            \n+            for (const auto& matchType : filter.matchtypes()) {\n+                if (!NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_IsValid(matchType)) {\n+                    SetError(NKikimrTxDataShard::TError::BAD_ARGUMENT, Sprintf(\"Unknown match type %\" PRIu32, matchType));\n+                    return true;\n+                }\n+                matchTypes.push_back(static_cast<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType>(matchType));\n+            }\n+        }\n+\n+        TAutoPtr<NTable::TTableIter> iter = txc.DB.IterateRange(localTableId, keyRange, columnsToReturn);\n+\n+        ui64 foundKeys = Result->Record.ContentsRowsSize() + Result->Record.CommonPrefixesRowsSize();\n+        while (iter->Next(NTable::ENext::All) == NTable::EReady::Data) {\n+            TDbTupleRef currentKey = iter->GetKey();\n+\n+            // Check all columns that prefix columns are in the current key are equal to the specified values\n+            Y_VERIFY(currentKey.Cells().size() > prefixColumns.GetCells().size());\n+            Y_VERIFY_DEBUG(\n+                0 == CompareTypedCellVectors(\n+                        prefixColumns.GetCells().data(),\n+                        currentKey.Cells().data(),\n+                        currentKey.Types,\n+                        prefixColumns.GetCells().size()),\n+                \"Unexpected out of range key returned from iterator\");\n+\n+            Y_VERIFY(currentKey.Types[pathColPos].GetTypeId() == NScheme::NTypeIds::Utf8);\n+            const TCell& pathCell = currentKey.Cells()[pathColPos];\n+            TString path = TString((const char*)pathCell.Data(), pathCell.Size());\n+\n+            LastPath = path;\n+\n+            // Explicitly skip erased rows after saving LastPath. This allows to continue exactly from\n+            // this key in case of restart\n+            if (iter->Row().GetRowState() == NTable::ERowOp::Erase) {\n+                continue;\n+            }\n+\n+            // Check that path begins with the specified prefix\n+            Y_VERIFY_DEBUG(path.StartsWith(pathPrefix),\n+                \"Unexpected out of range key returned from iterator\");\n+\n+            bool isLeafPath = true;\n+            if (!pathSeparator.empty()) {\n+                size_t separatorPos = path.find_first_of(pathSeparator, pathPrefix.length());\n+                if (separatorPos != TString::npos) {\n+                    path.resize(separatorPos + pathSeparator.length());\n+                    isLeafPath = false;\n+                }\n+            }\n+\n+            TDbTupleRef value = iter->GetValues();\n+            LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, Self->TabletID() << \" S3 Listing: \"\n+                \"\\\"\" << path << \"\\\"\" << (isLeafPath ? \" -> \" + DbgPrintTuple(value, *AppData(ctx)->TypeRegistry) : TString()));\n+\n+            if (isLeafPath) {\n+                Y_VERIFY(value.Cells()[0].Size() >= 1);\n+                Y_VERIFY(path == TStringBuf((const char*)value.Cells()[0].Data(), value.Cells()[0].Size()),\n+                    \"Path column must be requested at pos 0\");\n+\n+                TString newContentsRow = TSerializedCellVec::Serialize(value.Cells());\n+\n+                if (Result->Record.GetContentsRows().empty() ||\n+                    *Result->Record.GetContentsRows().rbegin() != newContentsRow) {\n+\n+                    if (hasFilter) {\n+                        bool matches = true;\n+\n+                        for (size_t i = 0; i < filterColumnIds.size(); i++) {\n+                            auto &columnId = filterColumnIds[i];\n+\n+                            Y_VERIFY(columnId < value.Cells().size());\n+\n+                            NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType matchType = matchTypes[i];\n+\n+                            switch (matchType) {\n+                                case NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_EQUAL:\n+                                    if (CompareTypedCells(value.Cells()[columnId], filterColumnValues.GetCells()[i], value.Types[columnId]) != 0) {\n+                                        matches = false;\n+                                    }\n+                                    break;\n+                                case NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_NOT_EQUAL: {\n+                                    int cmp = CompareTypedCells(value.Cells()[columnId], filterColumnValues.GetCells()[i], value.Types[columnId]);\n+\n+                                    if (cmp == 0) {\n+                                        matches = false;\n+                                    }\n+\n+                                    break;\n+                                }\n+                            }\n+\n+                            if (!matches) {\n+                                break;\n+                            }\n+                        }\n+\n+                        if (!matches) {\n+                            continue;\n+                        }\n+                    }\n+                    \n+                    // Add a row with path column and all columns requested by user\n+                    Result->Record.AddContentsRows(newContentsRow);\n+                    if (++foundKeys >= maxKeys) {\n+                        break;\n+                    }\n+                }\n+            } else {\n+                if (hasFilter) {\n+                    bool matches = true;\n+\n+                    for (size_t i = 0; i < filterColumnIds.size(); i++) {\n+                        auto &columnId = filterColumnIds[i];\n+\n+                        Y_VERIFY(columnId < value.Cells().size());\n+\n+                        NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType matchType;\n+                        \n+                        if (matchTypes.size() == filterColumnIds.size()) {\n+                            matchType = matchTypes[i];\n+                        } else {\n+                            matchType = NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_EQUAL;\n+                        }\n+\n+                        switch (matchType) {\n+                            case NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_EQUAL:\n+                                if (CompareTypedCells(value.Cells()[columnId], filterColumnValues.GetCells()[i], value.Types[columnId]) != 0) {\n+                                    matches = false;\n+                                }\n+                                break;\n+                            case NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_NOT_EQUAL: {\n+                                int cmp = CompareTypedCells(value.Cells()[columnId], filterColumnValues.GetCells()[i], value.Types[columnId]);\n+\n+                                if (cmp == 0) {\n+                                    matches = false;\n+                                }\n+\n+                                break;\n+                            }\n+                        }\n+\n+                        if (!matches) {\n+                            break;\n+                        }\n+                    }\n+\n+                    if (!matches) {\n+                        continue;\n+                    }\n+                }\n+                \n+                // For prefix save only path\n+                if (path > startAfterPath && path != lastCommonPath) {\n+                    LastCommonPath = path;\n+                    Result->Record.AddCommonPrefixesRows(path);\n+                    if (++foundKeys >= maxKeys)\n+                        break;\n+                }\n+\n+                TString lookup = NextPrefix(path);\n+                if (!lookup) {\n+                    // May only happen if path is equal to separator, which consists of only '\\xff'\n+                    // This would imply separator is not a valid UTF-8 string, but in any case no\n+                    // other path exists after the current prefix.\n+                    break;\n+                }\n+\n+                // Skip to the next key after path+separator\n+                key.resize(prefixColumns.GetCells().size());\n+                key.emplace_back(lookup.data(), lookup.size(), NScheme::TTypeInfo(NScheme::NTypeIds::Utf8));\n+                key.resize(columnCount);\n+\n+                if (!iter->SkipTo(key, /* inclusive = */ true)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return iter->Last() != NTable::EReady::Page;\n+    }\n+\n+    void Complete(const TActorContext& ctx) override {\n+        LOG_DEBUG_S(ctx, NKikimrServices::TX_DATASHARD, Self->TabletID() << \" S3 Listing: finished \"\n+                    << \" status: \" << Result->Record.GetStatus()\n+                    << \" description: \\\"\" << Result->Record.GetErrorDescription() << \"\\\"\"\n+                    << \" contents: \" << Result->Record.ContentsRowsSize()\n+                    << \" common prefixes: \" << Result->Record.CommonPrefixesRowsSize());\n+        ctx.Send(Ev->Sender, Result.Release());\n+    }\n+\n+private:\n+    void SetError(ui32 status, TString descr) {\n+        Result = new TEvDataShard::TEvObjectStorageListingResponse(Self->TabletID());\n+\n+        Result->Record.SetStatus(status);\n+        Result->Record.SetErrorDescription(descr);\n+    }\n+\n+    static bool IsKeyInRange(TArrayRef<const TRawTypeValue> key, const TUserTable& tableInfo) {\n+        if (!key) {\n+            return false;\n+        }\n+        auto range = tableInfo.GetTableRange();\n+        size_t prefixSize = Min(key.size(), range.To.size());\n+        for (size_t pos = 0; pos < prefixSize; ++pos) {\n+            if (int cmp = CompareTypedCells(TCell(&key[pos]), range.To[pos], tableInfo.KeyColumnTypes[pos])) {\n+                return cmp < 0;\n+            }\n+        }\n+        if (key.size() != range.To.size()) {\n+            return key.size() > range.To.size();\n+        }\n+        return range.InclusiveTo;\n+    }\n+\n+    /**\n+     * Given a prefix p will return the first prefix p' that is\n+     * lexicographically after all strings that have prefix p.\n+     * Will return an empty string if prefix p' does not exist.\n+     */\n+    static TString NextPrefix(TString p) {\n+        while (p) {\n+            if (char next = (char)(((unsigned char)p.back()) + 1)) {\n+                p.back() = next;\n+                break;\n+            } else {\n+                p.pop_back(); // overflow, move to the next character\n+            }\n+        }\n+\n+        return p;\n+    }\n+};\n+\n+void TDataShard::Handle(TEvDataShard::TEvObjectStorageListingRequest::TPtr& ev, const TActorContext& ctx) {\n+    Executor()->Execute(new TTxObjectStorageListing(this, ev), ctx);\n+}\n+\n+} // namespace NDataShard\n+} // namespace NKikimr\ndiff --git a/ydb/core/tx/datashard/datashard_impl.h b/ydb/core/tx/datashard/datashard_impl.h\nindex 7a4994e7c94c..e2850d132593 100644\n--- a/ydb/core/tx/datashard/datashard_impl.h\n+++ b/ydb/core/tx/datashard/datashard_impl.h\n@@ -224,6 +224,7 @@ class TDataShard\n     class TTxGetS3DownloadInfo;\n     class TTxStoreS3DownloadInfo;\n     class TTxS3UploadRows;\n+    class TTxObjectStorageListing;\n     class TTxExecuteMvccStateChange;\n     class TTxGetRemovedRowVersions;\n     class TTxCompactBorrowed;\n@@ -1311,6 +1312,7 @@ class TDataShard\n     void Handle(TEvDataShard::TEvGetS3DownloadInfo::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvStoreS3DownloadInfo::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvS3UploadRowsRequest::TPtr& ev, const TActorContext& ctx);\n+    void Handle(TEvDataShard::TEvObjectStorageListingRequest::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvBuildIndexCreateRequest::TPtr& ev, const TActorContext& ctx);\n     void HandleSafe(TEvDataShard::TEvBuildIndexCreateRequest::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvCdcStreamScanRequest::TPtr& ev, const TActorContext& ctx);\n@@ -2979,6 +2981,7 @@ class TDataShard\n             HFuncTraced(TEvDataShard::TEvGetS3DownloadInfo, Handle);\n             HFuncTraced(TEvDataShard::TEvStoreS3DownloadInfo, Handle);\n             HFuncTraced(TEvDataShard::TEvS3UploadRowsRequest, Handle);\n+            HFuncTraced(TEvDataShard::TEvObjectStorageListingRequest, Handle);\n             HFuncTraced(TEvDataShard::TEvMigrateSchemeShardRequest, Handle);\n             HFuncTraced(TEvTxProcessing::TEvPlanStep, Handle);\n             HFuncTraced(TEvTxProcessing::TEvReadSet, Handle);\ndiff --git a/ydb/core/tx/datashard/datashard_ut_object_storage_listing.cpp b/ydb/core/tx/datashard/datashard_ut_object_storage_listing.cpp\nnew file mode 100644\nindex 000000000000..3acaa0992ea9\n--- /dev/null\n+++ b/ydb/core/tx/datashard/datashard_ut_object_storage_listing.cpp\n@@ -0,0 +1,277 @@\n+#include \"defs.h\"\n+#include <ydb/core/tx/datashard/ut_common/datashard_ut_common.h>\n+#include \"datashard_ut_common_kqp.h\"\n+\n+#include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n+#include <ydb/core/tx/scheme_cache/scheme_cache.h>\n+#include <ydb/core/tx/tx_proxy/proxy.h>\n+#include <ydb/core/tx/tx.h>\n+\n+#include <util/generic/bitmap.h>\n+#include <util/string/printf.h>\n+#include <util/string/strip.h>\n+\n+namespace NKikimr {\n+\n+using namespace NDataShard::NKqpHelpers;\n+using namespace Tests;\n+\n+struct TProto {\n+    using TEvListingRequest = NKikimrTxDataShard::TEvObjectStorageListingRequest;\n+    using TEvListingResponse = NKikimrTxDataShard::TEvObjectStorageListingResponse;\n+};\n+\n+namespace {\n+\n+void CreateTable(TServer::TPtr server, const TActorId& sender, const TString& root, const TString& name) {\n+    auto opts = TShardedTableOptions()\n+        .Columns({\n+            {\"bucket\", \"Uint32\", true, false},\n+            {\"path\", \"Utf8\", true, false},\n+            {\"value\", \"Utf8\", false, false},\n+            {\"deleted\", \"Bool\", false, false}\n+        });\n+    CreateShardedTable(server, sender, root, name, opts);\n+}\n+\n+TProto::TEvListingRequest MakeListingRequest(const TTableId& tableId, const std::optional<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType> filterType) {\n+    TProto::TEvListingRequest request;\n+\n+    TVector<TCell> bucketPrefixCell = {TCell::Make(100)};\n+    TString prefix = TSerializedCellVec::Serialize(bucketPrefixCell);\n+\n+    request.SetTableId(tableId.PathId.LocalPathId);\n+    request.SetSerializedKeyPrefix(prefix);\n+    request.SetPathColumnPrefix(\"/test/\");\n+    request.SetPathColumnDelimiter(\"/\");\n+    request.SetMaxKeys(10);\n+\n+    request.add_columnstoreturn(2);\n+    request.add_columnstoreturn(3);\n+    request.add_columnstoreturn(4);\n+\n+    if (filterType) {\n+        TVector<TCell> filterCell = {TCell::Make(false)};\n+        auto* filter = request.mutable_filter();\n+\n+        filter->add_columns(2);\n+        filter->set_values(TSerializedCellVec::Serialize(filterCell));\n+        filter->add_matchtypes(filterType.value());\n+    }\n+\n+    return request;\n+}\n+\n+template <typename TEvResponse, typename TDerived>\n+class TRequestRunner: public TActorBootstrapped<TDerived> {\n+    void Handle(TEvTabletPipe::TEvClientConnected::TPtr& ev) {\n+        if (ev->Get()->Status == NKikimrProto::OK) {\n+            return;\n+        }\n+\n+        Bootstrap();\n+    }\n+\n+protected:\n+    void Reply(typename TEvResponse::TPtr& ev) {\n+        TlsActivationContext->AsActorContext().Send(ev->Forward(ReplyTo));\n+    }\n+\n+    virtual void Handle(typename TEvResponse::TPtr& ev) {\n+        Reply(ev);\n+        PassAway();\n+    }\n+\n+    void PassAway() override {\n+        if (Pipe) {\n+            NTabletPipe::CloseAndForgetClient(this->SelfId(), Pipe);\n+        }\n+\n+        IActor::PassAway();\n+    }\n+\n+    virtual IEventBase* MakeRequest() const = 0;\n+\n+public:\n+    explicit TRequestRunner(const TActorId& replyTo, ui64 tabletID)\n+        : ReplyTo(replyTo)\n+        , TabletID(tabletID)\n+    {\n+    }\n+\n+    void Bootstrap() {\n+        if (Pipe) {\n+            NTabletPipe::CloseAndForgetClient(this->SelfId(), Pipe);\n+        }\n+\n+        Pipe = this->Register(NTabletPipe::CreateClient(this->SelfId(), TabletID));\n+        NTabletPipe::SendData(this->SelfId(), Pipe, this->MakeRequest());\n+\n+        this->Become(&TDerived::StateWork);\n+    }\n+\n+    STATEFN(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(TEvTabletPipe::TEvClientConnected, Handle);\n+            cFunc(TEvTabletPipe::TEvClientDestroyed::EventType, Bootstrap);\n+            hFunc(TEvResponse, Handle);\n+        }\n+    }\n+\n+    using TBase = TRequestRunner<TEvResponse, TDerived>;\n+\n+private:\n+    const TActorId ReplyTo;\n+    const ui64 TabletID;\n+\n+    TActorId Pipe;\n+};\n+\n+std::pair<std::vector<std::string>, std::vector<std::string>> List(\n+        TServer::TPtr server, const TActorId& sender, const TString& path,\n+        const std::optional<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType> doFilter,\n+        ui32 status = NKikimrTxDataShard::TError::OK)\n+{\n+    using TEvRequest = TEvDataShard::TEvObjectStorageListingRequest;\n+    using TEvResponse = TEvDataShard::TEvObjectStorageListingResponse;\n+\n+    class TLister: public TRequestRunner<TEvResponse, TLister> {\n+    public:\n+        explicit TLister(\n+                const TActorId& replyTo, ui64 tabletID,\n+                const TTableId& tableId, const std::optional<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType> doFilter)\n+            : TBase(replyTo, tabletID)\n+            , TableId(tableId)\n+            , DoFilter(doFilter)\n+        {\n+        }\n+\n+        IEventBase* MakeRequest() const override {\n+            auto request = MakeHolder<TEvRequest>();\n+            request->Record = MakeListingRequest(TableId, DoFilter);\n+            return request.Release();\n+        }\n+\n+    private:\n+        const TTableId TableId;\n+        const std::optional<NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType> DoFilter;\n+    };\n+\n+    auto tableId = ResolveTableId(server, sender, path);\n+\n+    auto tabletIDs = GetTableShards(server, sender, path);\n+    UNIT_ASSERT_VALUES_EQUAL(tabletIDs.size(), 1);\n+    server->GetRuntime()->Register(new TLister(sender, tabletIDs[0], tableId, doFilter));\n+\n+    auto ev = server->GetRuntime()->GrabEdgeEventRethrow<TEvResponse>(sender);\n+\n+    auto& rec = ev->Get()->Record;\n+\n+    UNIT_ASSERT_VALUES_EQUAL(static_cast<ui32>(rec.GetStatus()), status);\n+\n+    std::vector<std::string> contents;\n+    std::vector<std::string> commonPrefixes;\n+\n+    if (rec.CommonPrefixesRowsSize() > 0) {\n+        auto& folders = rec.commonprefixesrows();\n+        for (auto row : folders) {\n+            commonPrefixes.emplace_back(row);\n+        }\n+    }\n+        \n+    if (rec.ContentsRowsSize() > 0) {\n+        auto& files = rec.contentsrows();\n+        for (auto row : files) {\n+            auto vec = TSerializedCellVec(row);\n+            const auto& cell = vec.GetCells()[0];\n+            contents.emplace_back(cell.AsBuf().data(), cell.AsBuf().size());\n+        }\n+    }\n+\n+    return std::make_pair(commonPrefixes, contents);\n+}\n+\n+} // anonymous\n+\n+Y_UNIT_TEST_SUITE(ObjectStorageListingTest) {\n+\n+    Y_UNIT_TEST(ListingNoFilter) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings\n+            .SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        const TActorId sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);\n+        InitRoot(server, sender);\n+\n+        CreateTable(server, sender, \"/Root\", \"table-1\");\n+        ExecSQL(server, sender, R\"(\n+            UPSERT INTO `/Root/table-1` (bucket, path, value, deleted) VALUES\n+            (100, \"/test/foo.txt\", \"foo\", false),\n+            (100, \"/test/visible/bar.txt\", \"bar\", false),\n+            (100, \"/test/deleted/baz.txt\", \"baz\", true),\n+            (100, \"/test/foobar.txt\", \"foobar\", false),\n+            (100, \"/test/deleted.txt\", \"foobar\", true)\n+        )\");\n+\n+        auto res = List(server, sender, \"/Root/table-1\", {});\n+\n+        std::vector<std::string> expectedFolders = {\"/test/deleted/\", \"/test/visible/\"};\n+        std::vector<std::string> expectedFiles = {\"/test/deleted.txt\", \"/test/foo.txt\", \"/test/foobar.txt\"};\n+\n+        UNIT_ASSERT_VALUES_EQUAL(expectedFolders, res.first);\n+        UNIT_ASSERT_VALUES_EQUAL(expectedFiles, res.second);\n+    }\n+\n+    Y_UNIT_TEST(FilterListing) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings\n+            .SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        const TActorId sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);\n+        InitRoot(server, sender);\n+\n+        CreateTable(server, sender, \"/Root\", \"table-1\");\n+        ExecSQL(server, sender, R\"(\n+            UPSERT INTO `/Root/table-1` (bucket, path, value, deleted) VALUES\n+            (100, \"/test/foo.txt\", \"foo\", false),\n+            (100, \"/test/visible/bar.txt\", \"bar\", false),\n+            (100, \"/test/deleted/baz.txt\", \"baz\", true),\n+            (100, \"/test/foobar.txt\", \"foobar\", false),\n+            (100, \"/test/deleted.txt\", \"foobar\", true)\n+        )\");\n+\n+        {\n+            auto res = List(server, sender, \"/Root/table-1\", NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_EQUAL);\n+\n+            std::vector<std::string> expectedFolders = {\"/test/visible/\"};\n+            std::vector<std::string> expectedFiles = {\"/test/foo.txt\", \"/test/foobar.txt\"};\n+\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFolders, res.first);\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFiles, res.second);\n+        }\n+\n+        {\n+            auto res = List(server, sender, \"/Root/table-1\", NKikimrTxDataShard::TObjectStorageListingFilter_EMatchType_NOT_EQUAL);\n+\n+            std::vector<std::string> expectedFolders = {\"/test/deleted/\"};\n+            std::vector<std::string> expectedFiles = {\"/test/deleted.txt\"};\n+\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFolders, res.first);\n+            UNIT_ASSERT_VALUES_EQUAL(expectedFiles, res.second);\n+        }\n+    }\n+}\n+\n+} // namespace NKikimr\ndiff --git a/ydb/core/tx/datashard/ut_object_storage_listing/ya.make b/ydb/core/tx/datashard/ut_object_storage_listing/ya.make\nnew file mode 100644\nindex 000000000000..4a35d295b494\n--- /dev/null\n+++ b/ydb/core/tx/datashard/ut_object_storage_listing/ya.make\n@@ -0,0 +1,38 @@\n+UNITTEST_FOR(ydb/core/tx/datashard)\n+\n+FORK_SUBTESTS()\n+\n+SPLIT_FACTOR(15)\n+\n+IF (SANITIZER_TYPE == \"thread\" OR WITH_VALGRIND)\n+    TIMEOUT(3600)\n+    SIZE(LARGE)\n+    TAG(ya:fat)\n+    REQUIREMENTS(ram:16)\n+ELSE()\n+    TIMEOUT(600)\n+    SIZE(MEDIUM)\n+ENDIF()\n+\n+PEERDIR(\n+    ydb/core/tx/datashard/ut_common\n+    library/cpp/getopt\n+    library/cpp/regex/pcre\n+    library/cpp/svnversion\n+    ydb/core/kqp/ut/common\n+    ydb/core/testlib/default\n+    ydb/core/tx\n+    ydb/library/yql/public/udf/service/exception_policy\n+    ydb/public/lib/yson_value\n+    ydb/public/sdk/cpp/client/ydb_result\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+SRCS(\n+    datashard_ut_object_storage_listing.cpp\n+)\n+\n+REQUIREMENTS(ram:32)\n+\n+END()\ndiff --git a/ydb/core/tx/datashard/ya.make b/ydb/core/tx/datashard/ya.make\nindex ff10fdef6e82..705acbdc4ceb 100644\n--- a/ydb/core/tx/datashard/ya.make\n+++ b/ydb/core/tx/datashard/ya.make\n@@ -68,6 +68,7 @@ SRCS(\n     datashard__read_columns.cpp\n     datashard__s3_download_txs.cpp\n     datashard__s3_upload_txs.cpp\n+    datashard__object_storage_listing.cpp\n     datashard__kqp_scan.cpp\n     datashard__snapshot_txs.cpp\n     datashard__stats.cpp\n@@ -300,6 +301,7 @@ RECURSE_FOR_TESTS(\n     ut_locks\n     ut_minikql\n     ut_minstep\n+    ut_object_storage_listing\n     ut_order\n     ut_range_ops\n     ut_read_iterator\n@@ -310,8 +312,8 @@ RECURSE_FOR_TESTS(\n     ut_sequence\n     ut_snapshot\n     ut_stats\n+    ut_trace\n     ut_upload_rows\n     ut_volatile\n     ut_write\n-    ut_trace\n )\ndiff --git a/ydb/core/ydb_convert/ydb_convert.cpp b/ydb/core/ydb_convert/ydb_convert.cpp\nindex 9337649c5588..54822c667232 100644\n--- a/ydb/core/ydb_convert/ydb_convert.cpp\n+++ b/ydb/core/ydb_convert/ydb_convert.cpp\n@@ -1329,11 +1329,15 @@ void ProtoValueFromCell(NYdb::TValueBuilder& vb, const NScheme::TTypeInfo& typeI\n     case EPrimitiveType::Json:\n         vb.Json(getString());\n         break;\n-    case EPrimitiveType::Uuid:\n-        vb.Uuid(getString());\n+    case EPrimitiveType::Uuid: {\n+        ui64 hi;\n+        ui64 lo;\n+        NUuid::UuidBytesToHalfs(cell.AsBuf().Data(), 16, hi, lo);\n+        vb.Uuid(TUuidValue(lo, hi));\n         break;\n+    }\n     case EPrimitiveType::JsonDocument:\n-        vb.JsonDocument(getString());\n+        vb.JsonDocument(NBinaryJson::SerializeToJson(getString()));\n         break;\n     case EPrimitiveType::DyNumber:\n         vb.DyNumber(getString());\ndiff --git a/ydb/public/api/grpc/draft/ya.make b/ydb/public/api/grpc/draft/ya.make\nindex 2e059cbf5f2a..d6c539409114 100644\n--- a/ydb/public/api/grpc/draft/ya.make\n+++ b/ydb/public/api/grpc/draft/ya.make\n@@ -14,6 +14,7 @@ SRCS(\n     ydb_logstore_v1.proto\n     ydb_maintenance_v1.proto\n     ydb_persqueue_v1.proto\n+    ydb_object_storage_v1.proto\n )\n \n PEERDIR(\ndiff --git a/ydb/public/api/grpc/draft/ydb_object_storage_v1.proto b/ydb/public/api/grpc/draft/ydb_object_storage_v1.proto\nnew file mode 100644\nindex 000000000000..de938468a607\n--- /dev/null\n+++ b/ydb/public/api/grpc/draft/ydb_object_storage_v1.proto\n@@ -0,0 +1,10 @@\n+syntax = \"proto3\";\n+\n+package Ydb.ObjectStorage.V1;\n+option java_package = \"com.yandex.ydb.object_storage.v1\";\n+\n+import \"ydb/public/api/protos/draft/ydb_object_storage.proto\";\n+\n+service ObjectStorageService {\n+    rpc List(ObjectStorage.ListingRequest) returns (ObjectStorage.ListingResponse);\n+}\ndiff --git a/ydb/public/api/protos/draft/ydb_object_storage.proto b/ydb/public/api/protos/draft/ydb_object_storage.proto\nnew file mode 100644\nindex 000000000000..07f5b5c87372\n--- /dev/null\n+++ b/ydb/public/api/protos/draft/ydb_object_storage.proto\n@@ -0,0 +1,36 @@\n+syntax = \"proto3\";\n+option cc_enable_arenas = true;\n+\n+package Ydb.ObjectStorage;\n+option java_package = \"com.yandex.ydb.object_storage\";\n+option java_outer_classname = \"ObjectStorageProtos\";\n+\n+import \"ydb/public/api/protos/ydb_issue_message.proto\";\n+import \"ydb/public/api/protos/ydb_value.proto\";\n+import \"ydb/public/api/protos/ydb_status_codes.proto\";\n+\n+message ListingRequest {\n+    enum EMatchType {\n+        EQUAL = 0;\n+        NOT_EQUAL = 1;\n+    }\n+    string table_name = 1;\n+    TypedValue key_prefix = 2; // A tuple representing all key columns that preceed path column\n+    string path_column_prefix = 3;\n+    string path_column_delimiter = 4;\n+    bytes continuation_token = 5;\n+    TypedValue start_after_key_suffix = 6; // A tuple representing key columns that succeed path column\n+    int32 max_keys = 7;\n+    repeated string columns_to_return = 8;\n+    reserved 9; // Deprecated filter\n+    TypedValue matching_filter = 10;\n+}\n+\n+message ListingResponse {\n+    StatusIds.StatusCode status = 1;\n+    repeated Ydb.Issue.IssueMessage issues = 2;\n+    repeated string common_prefixes = 3;    // Folders.\n+    Ydb.ResultSet contents = 4;           // Every Contents row starts with key suffix with KeySuffixSize columns\n+    bool is_truncated = 5;\n+    bytes next_continuation_token = 6;\n+}\ndiff --git a/ydb/public/api/protos/ya.make b/ydb/public/api/protos/ya.make\nindex 3bda0f8a4c68..35b19a053a0b 100644\n--- a/ydb/public/api/protos/ya.make\n+++ b/ydb/public/api/protos/ya.make\n@@ -15,6 +15,7 @@ SRCS(\n     draft/ydb_dynamic_config.proto\n     draft/ydb_logstore.proto\n     draft/ydb_maintenance.proto\n+    draft/ydb_object_storage.proto\n     ydb_federation_discovery.proto\n     persqueue_error_codes_v1.proto\n     ydb_auth.proto\ndiff --git a/ydb/public/lib/experimental/ya.make b/ydb/public/lib/experimental/ya.make\nindex 69e934169454..c70bfc809573 100644\n--- a/ydb/public/lib/experimental/ya.make\n+++ b/ydb/public/lib/experimental/ya.make\n@@ -3,6 +3,7 @@ LIBRARY()\n SRCS(\n     ydb_clickhouse_internal.cpp\n     ydb_logstore.cpp\n+    ydb_object_storage.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/public/lib/experimental/ydb_object_storage.cpp b/ydb/public/lib/experimental/ydb_object_storage.cpp\nnew file mode 100644\nindex 000000000000..3833d6a37d65\n--- /dev/null\n+++ b/ydb/public/lib/experimental/ydb_object_storage.cpp\n@@ -0,0 +1,136 @@\n+#include \"ydb_object_storage.h\"\n+\n+#define INCLUDE_YDB_INTERNAL_H\n+#include <ydb/public/sdk/cpp/client/impl/ydb_internal/make_request/make.h>\n+#undef INCLUDE_YDB_INTERNAL_H\n+\n+#include <ydb/public/api/grpc/draft/ydb_object_storage_v1.grpc.pb.h>\n+\n+#include <ydb/library/yql/public/issue/yql_issue.h>\n+#include <ydb/library/yql/public/issue/yql_issue_message.h>\n+\n+#include <ydb/public/sdk/cpp/client/ydb_proto/accessor.h>\n+#include <ydb/public/sdk/cpp/client/ydb_common_client/impl/client.h>\n+\n+namespace NYdb {\n+namespace NObjectStorage {\n+\n+TObjectStorageListingResult::TObjectStorageListingResult(std::vector<std::string>&& commonPrefixes, TResultSet&& contents, TString nextContinuationToken, bool isTruncated, TStatus&& status)\n+    : TStatus(std::move(status))\n+    , CommonPrefixes(std::move(commonPrefixes))\n+    , Contents(std::move(contents))\n+    , NextContinuationToken(nextContinuationToken)\n+    , IsTruncated(isTruncated)\n+{}\n+\n+const std::vector<std::string>& TObjectStorageListingResult::GetCommonPrefixes() const {\n+    return CommonPrefixes;\n+}\n+\n+const TResultSet& TObjectStorageListingResult::GetContents() const {\n+    return Contents;\n+}\n+\n+const TString& TObjectStorageListingResult::GetContinuationToken() const {\n+    return NextContinuationToken;\n+}\n+\n+bool TObjectStorageListingResult::GetIsTruncated() const {\n+    return IsTruncated;\n+}\n+\n+void SetProtoValue(Ydb::TypedValue& out, TValue&& in) {\n+    *out.mutable_type() = TProtoAccessor::GetProto(in.GetType());\n+    *out.mutable_value() = TProtoAccessor::GetProto(in);\n+}\n+\n+\n+class TObjectStorageClient::TImpl : public TClientImplCommon<TObjectStorageClient::TImpl> {\n+public:\n+    TImpl(std::shared_ptr<TGRpcConnectionsImpl>&& connections, const TCommonClientSettings& settings)\n+        : TClientImplCommon(std::move(connections), settings) {}\n+\n+    TAsyncObjectStorageListingResult List(const TString& tableName,\n+                           TValue&& keyPrefix,\n+                           const TString& pathColumnPrefix,\n+                           const TString& pathColumnDelimiter,\n+                           TString& continuationToken,\n+                           TValue&& startAfterKeySuffix,\n+                           ui32 maxKeys,\n+                           const TVector<TString> columnsToReturn,\n+                           const TObjectStorageListingSettings& settings)\n+    {\n+        auto request = MakeRequest<Ydb::ObjectStorage::ListingRequest>();\n+        request.set_table_name(tableName);\n+        SetProtoValue(*request.mutable_key_prefix(), std::move(keyPrefix));\n+        request.set_path_column_prefix(pathColumnPrefix);\n+        request.set_path_column_delimiter(pathColumnDelimiter);\n+        if (continuationToken) {\n+            request.Setcontinuation_token(continuationToken);\n+        }\n+        SetProtoValue(*request.mutable_start_after_key_suffix(), std::move(startAfterKeySuffix));\n+        request.set_max_keys(maxKeys);\n+        for (auto& c : columnsToReturn) {\n+            request.add_columns_to_return(c);\n+        }\n+\n+        auto promise = NThreading::NewPromise<TObjectStorageListingResult>();\n+\n+        auto extractor = [promise]\n+            (Ydb::ObjectStorage::ListingResponse* response, TPlainStatus status) mutable {\n+                std::vector<std::string> commonPrefixes;\n+                Ydb::ResultSet contents;\n+                if (response) {\n+                    Ydb::StatusIds::StatusCode msgStatus = response->status();\n+                    NYql::TIssues issues;\n+                    NYql::IssuesFromMessage(response->issues(), issues);\n+                    status = TPlainStatus(static_cast<EStatus>(msgStatus), std::move(issues));    \n+                    \n+                    for (auto commonPrefix : response->Getcommon_prefixes()) {\n+                        commonPrefixes.push_back(commonPrefix);\n+                    }\n+                    contents = std::move(response->Getcontents());\n+                }\n+\n+                TObjectStorageListingResult val(std::move(commonPrefixes), std::move(contents), response->next_continuation_token(), response->is_truncated(), TStatus(std::move(status)));\n+                promise.SetValue(std::move(val));\n+            };\n+\n+        Connections_->Run<Ydb::ObjectStorage::V1::ObjectStorageService, Ydb::ObjectStorage::ListingRequest, Ydb::ObjectStorage::ListingResponse>(\n+            std::move(request),\n+            extractor,\n+            &Ydb::ObjectStorage::V1::ObjectStorageService::Stub::AsyncList,\n+            DbDriverState_,\n+            TRpcRequestSettings::Make(settings));\n+\n+        return promise.GetFuture();\n+    }\n+};\n+\n+\n+TObjectStorageClient::TObjectStorageClient(const TDriver& driver, const TCommonClientSettings& settings)\n+    : Impl_(new TImpl(CreateInternalInterface(driver), settings))\n+{}\n+\n+TAsyncObjectStorageListingResult TObjectStorageClient::List(const TString& tableName,\n+                                          TValue&& keyPrefix,\n+                                          const TString& pathColumnPrefix,\n+                                          const TString& pathColumnDelimiter,\n+                                          TString continuationToken,\n+                                          TValue&& startAfterKeySuffix,\n+                                          ui32 maxKeys,\n+                                          const TVector<TString>& columnsToReturn,\n+                                          const TObjectStorageListingSettings& settings)\n+{\n+    return Impl_->List(tableName,\n+                            std::move(keyPrefix),\n+                            pathColumnPrefix,\n+                            pathColumnDelimiter,\n+                            continuationToken,\n+                            std::move(startAfterKeySuffix),\n+                            maxKeys,\n+                            columnsToReturn,\n+                            settings);\n+}\n+\n+}}\ndiff --git a/ydb/public/lib/experimental/ydb_object_storage.h b/ydb/public/lib/experimental/ydb_object_storage.h\nnew file mode 100644\nindex 000000000000..89a32af437d4\n--- /dev/null\n+++ b/ydb/public/lib/experimental/ydb_object_storage.h\n@@ -0,0 +1,53 @@\n+#pragma once\n+\n+#include <ydb/public/sdk/cpp/client/ydb_result/result.h>\n+#include <ydb/public/sdk/cpp/client/ydb_table/table.h>\n+\n+namespace NYdb {\n+namespace NObjectStorage {\n+\n+struct TObjectStorageListingSettings : public TOperationRequestSettings<TObjectStorageListingSettings> {};\n+\n+\n+class TObjectStorageListingResult : public TStatus {\n+    friend class TObjectStorageClient;\n+private:\n+    TObjectStorageListingResult(std::vector<std::string>&& commonPrefixes, TResultSet&& contents, TString nextContinuationToken, bool isTruncated, TStatus&& status);\n+\n+public:\n+    const std::vector<std::string>& GetCommonPrefixes() const;\n+    const TResultSet& GetContents() const;\n+    const TString& GetContinuationToken() const;\n+    bool GetIsTruncated() const;\n+\n+private:\n+    std::vector<std::string> CommonPrefixes;\n+    TResultSet Contents;\n+    TString NextContinuationToken;\n+    bool IsTruncated;\n+};\n+\n+using TAsyncObjectStorageListingResult = NThreading::TFuture<TObjectStorageListingResult>;\n+\n+\n+class TObjectStorageClient {\n+    class TImpl;\n+\n+public:\n+    TObjectStorageClient(const TDriver& driver, const TCommonClientSettings& settings = TCommonClientSettings());\n+\n+    TAsyncObjectStorageListingResult List(const TString& tableName,\n+                           TValue&& keyPrefix,\n+                           const TString& pathColumnPrefix,\n+                           const TString& pathColumnDelimiter,\n+                           TString continuationToken,\n+                           TValue&& startAfterKeySuffix,\n+                           ui32 maxKeys,\n+                           const TVector<TString> &columnsToReturn,\n+                           const TObjectStorageListingSettings& settings = TObjectStorageListingSettings());\n+\n+private:\n+    std::shared_ptr<TImpl> Impl_;\n+};\n+\n+}}\ndiff --git a/ydb/services/ydb/ut/ya.make b/ydb/services/ydb/ut/ya.make\nindex c8ad6c0b1e9d..2230ee58cc42 100644\n--- a/ydb/services/ydb/ut/ya.make\n+++ b/ydb/services/ydb/ut/ya.make\n@@ -28,6 +28,7 @@ SRCS(\n     cert_gen.cpp\n     ydb_query_ut.cpp\n     ydb_ldap_login_ut.cpp\n+    ydb_object_storage_ut.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/services/ydb/ya.make b/ydb/services/ydb/ya.make\nindex 5e223e11f925..9ee886195a6e 100644\n--- a/ydb/services/ydb/ya.make\n+++ b/ydb/services/ydb/ya.make\n@@ -11,6 +11,7 @@ SRCS(\n     ydb_scheme.cpp\n     ydb_scripting.cpp\n     ydb_table.cpp\n+    ydb_object_storage.cpp\n )\n \n PEERDIR(\ndiff --git a/ydb/services/ydb/ydb_object_storage.cpp b/ydb/services/ydb/ydb_object_storage.cpp\nnew file mode 100644\nindex 000000000000..677379d9e159\n--- /dev/null\n+++ b/ydb/services/ydb/ydb_object_storage.cpp\n@@ -0,0 +1,31 @@\n+#include \"ydb_object_storage.h\"\n+\n+#include <ydb/core/grpc_services/service_object_storage.h>\n+#include <ydb/core/grpc_services/grpc_helper.h>\n+#include <ydb/core/grpc_services/base/base.h>\n+\n+namespace NKikimr {\n+namespace NGRpcService {\n+\n+void TGRpcYdbObjectStorageService::SetupIncomingRequests(NYdbGrpc::TLoggerPtr logger) {\n+    auto getCounterBlock = CreateCounterCb(Counters_, ActorSystem_);\n+\n+#ifdef ADD_REQUEST\n+#error ADD_REQUEST macro already defined\n+#endif\n+#define ADD_REQUEST(NAME, IN, OUT, CB) \\\n+    MakeIntrusive<TGRpcRequest<Ydb::ObjectStorage::IN, Ydb::ObjectStorage::OUT, TGRpcYdbObjectStorageService>>(this, &Service_, CQ_, \\\n+        [this](NYdbGrpc::IRequestContextBase *ctx) { \\\n+            NGRpcService::ReportGrpcReqToMon(*ActorSystem_, ctx->GetPeer()); \\\n+            ActorSystem_->Send(GRpcRequestProxyId_, \\\n+                new NGRpcService::TGrpcRequestNoOperationCall<Ydb::ObjectStorage::IN, Ydb::ObjectStorage::OUT> \\\n+                    (ctx, &CB, NGRpcService::TRequestAuxSettings{NGRpcService::TRateLimiterMode::Off, nullptr})); \\\n+        }, &Ydb::ObjectStorage::V1::ObjectStorageService::AsyncService::Request ## NAME, \\\n+        #NAME, logger, getCounterBlock(\"object-storage-list\", #NAME))->Run();\n+\n+    ADD_REQUEST(List, ListingRequest, ListingResponse, DoObjectStorageListingRequest);\n+#undef ADD_REQUEST\n+}\n+\n+} // namespace NGRpcService\n+} // namespace NKikimr\ndiff --git a/ydb/services/ydb/ydb_object_storage.h b/ydb/services/ydb/ydb_object_storage.h\nnew file mode 100644\nindex 000000000000..f84736c83001\n--- /dev/null\n+++ b/ydb/services/ydb/ydb_object_storage.h\n@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include <ydb/library/actors/core/actorsystem.h>\n+#include <ydb/library/grpc/server/grpc_server.h>\n+#include <ydb/public/api/grpc/draft/ydb_object_storage_v1.grpc.pb.h>\n+#include <ydb/core/grpc_services/base/base_service.h>\n+\n+namespace NKikimr {\n+namespace NGRpcService {\n+\n+class TGRpcYdbObjectStorageService\n+    : public TGrpcServiceBase<Ydb::ObjectStorage::V1::ObjectStorageService>\n+{\n+public:\n+    using TGrpcServiceBase<Ydb::ObjectStorage::V1::ObjectStorageService>::TGrpcServiceBase;\n+\n+private:\n+    void SetupIncomingRequests(NYdbGrpc::TLoggerPtr logger);\n+};\n+\n+} // namespace NGRpcService\n+} // namespace NKikimr\ndiff --git a/ydb/services/ydb/ydb_object_storage_ut.cpp b/ydb/services/ydb/ydb_object_storage_ut.cpp\nnew file mode 100644\nindex 000000000000..3115d008b4bb\n--- /dev/null\n+++ b/ydb/services/ydb/ydb_object_storage_ut.cpp\n@@ -0,0 +1,286 @@\n+#include \"ydb_common_ut.h\"\n+\n+#include <ydb/public/lib/experimental/ydb_object_storage.h>\n+#include <ydb/public/sdk/cpp/client/ydb_result/result.h>\n+#include <ydb/public/sdk/cpp/client/ydb_scheme/scheme.h>\n+#include <ydb/public/sdk/cpp/client/ydb_table/table.h>\n+\n+using namespace NYdb;\n+\n+Y_UNIT_TEST_SUITE(YdbS3Internal) {\n+\n+    void PrepareData(TString location) {\n+        auto connection = NYdb::TDriver(TDriverConfig().SetEndpoint(location));\n+\n+        NYdb::NTable::TTableClient client(connection);\n+        auto session = client.GetSession().ExtractValueSync().GetSession();\n+\n+        {\n+            auto tableBuilder = client.GetTableBuilder();\n+            tableBuilder\n+                .AddNullableColumn(\"Hash\", EPrimitiveType::Uint64)\n+                .AddNullableColumn(\"Name\", EPrimitiveType::Utf8)\n+                .AddNullableColumn(\"Path\", EPrimitiveType::Utf8)\n+                .AddNullableColumn(\"Version\", EPrimitiveType::Uint64)\n+                .AddNullableColumn(\"Timestamp\", EPrimitiveType::Uint64)\n+                .AddNullableColumn(\"Data\", EPrimitiveType::String)\n+                .AddNullableColumn(\"ExtraData\", EPrimitiveType::String)\n+                .AddNullableColumn(\"Unused1\", EPrimitiveType::Uint32);\n+            tableBuilder.SetPrimaryKeyColumns({\"Hash\", \"Name\", \"Path\", \"Version\"});\n+            NYdb::NTable::TCreateTableSettings tableSettings;\n+            tableSettings.PartitioningPolicy(NYdb::NTable::TPartitioningPolicy().UniformPartitions(32));\n+            auto result = session.CreateTable(\"/Root/ListingObjects\", tableBuilder.Build(), tableSettings).ExtractValueSync();\n+\n+            UNIT_ASSERT_EQUAL(result.IsTransportError(), false);\n+            UNIT_ASSERT_EQUAL(result.GetStatus(), EStatus::SUCCESS);\n+        }\n+\n+        // Write some rows\n+        {\n+            auto res = session.ExecuteDataQuery(\n+                        \"REPLACE INTO `/Root/ListingObjects` (Hash, Name, Path, Version, Timestamp, Data) VALUES\\n\"\n+                        \"(50, 'bucket50', '/home/Music/Bohemian Rapshody.mp3', 1, 10, 'MP3'),\\n\"\n+                        \"(50, 'bucket50', '/home/.bashrc', 1, 10, '#bashrc')\\n\"\n+                        \";\",\n+                            NYdb::NTable::TTxControl::BeginTx().CommitTx()\n+                        ).ExtractValueSync();\n+\n+            UNIT_ASSERT_EQUAL(res.GetStatus(), EStatus::SUCCESS);\n+        }\n+    }\n+\n+    Y_UNIT_TEST(TestS3Listing) {\n+        TKikimrWithGrpcAndRootSchema server;\n+        ui16 grpc = server.GetPort();\n+        TString location = TStringBuilder() << \"localhost:\" << grpc;\n+\n+        PrepareData(location);\n+\n+        // List\n+        auto connection = NYdb::TDriver(TDriverConfig().SetEndpoint(location));\n+        NObjectStorage::TObjectStorageClient s3conn(connection);\n+\n+        TValueBuilder keyPrefix;\n+        keyPrefix.BeginTuple()\n+                .AddElement().Uint64(50)\n+                .AddElement().Utf8(\"bucket50\")\n+                .EndTuple();\n+        TValueBuilder suffix;\n+        suffix.BeginTuple().EndTuple();\n+        auto res = s3conn.List(\"/Root/ListingObjects\",\n+                                    keyPrefix.Build(),\n+                                    \"/home/\",\n+                                    \"/\",\n+                                    \"\",\n+                                    suffix.Build(),\n+                                    100,\n+                                    {\"Name\", \"Data\", \"Timestamp\"}\n+            ).GetValueSync();\n+\n+        Cerr << res.GetStatus() << Endl;\n+        UNIT_ASSERT_EQUAL(res.GetStatus(), EStatus::SUCCESS);\n+\n+        UNIT_ASSERT(!res.GetIsTruncated());\n+        UNIT_ASSERT(!res.GetContinuationToken());\n+\n+        {\n+            UNIT_ASSERT_VALUES_EQUAL(res.GetCommonPrefixes().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(res.GetCommonPrefixes()[0], \"/home/Music/\");\n+        }\n+\n+        {\n+            UNIT_ASSERT_VALUES_EQUAL(res.GetContents().RowsCount(), 1);\n+            TResultSetParser parser(res.GetContents());\n+            UNIT_ASSERT(parser.TryNextRow());\n+            UNIT_ASSERT_VALUES_EQUAL(parser.ColumnParser(\"Name\").GetOptionalUtf8().GetRef(), \"bucket50\");\n+            UNIT_ASSERT_VALUES_EQUAL(parser.ColumnParser(\"Path\").GetOptionalUtf8().GetRef(), \"/home/.bashrc\");\n+            UNIT_ASSERT_VALUES_EQUAL(parser.ColumnParser(\"Timestamp\").GetOptionalUint64().GetRef(), 10);\n+        }\n+    }\n+\n+    void SetPermissions(TString location) {\n+        auto connection = NYdb::TDriver(TDriverConfig().SetEndpoint(location));\n+        auto scheme = NYdb::NScheme::TSchemeClient(connection);\n+        auto status = scheme.ModifyPermissions(\"/Root/ListingObjects\",\n+                                               NYdb::NScheme::TModifyPermissionsSettings()\n+                                               .AddSetPermissions(\n+                                                   NYdb::NScheme::TPermissions(\"reader@builtin\", {\"ydb.tables.read\"})\n+                                                   )\n+                                               .AddSetPermissions(\n+                                                   NYdb::NScheme::TPermissions(\"generic_reader@builtin\", {\"ydb.generic.read\"})\n+                                                   )\n+                                               .AddSetPermissions(\n+                                                   NYdb::NScheme::TPermissions(\"writer@builtin\", {\"ydb.tables.modify\"})\n+                                                   )\n+                                               .AddSetPermissions(\n+                                                   NYdb::NScheme::TPermissions(\"generic_writer@builtin\", {\"ydb.generic.write\"})\n+                                                   )\n+                                               ).ExtractValueSync();\n+        UNIT_ASSERT_EQUAL(status.IsTransportError(), false);\n+        UNIT_ASSERT_EQUAL(status.GetStatus(), EStatus::SUCCESS);\n+    }\n+\n+    NYdb::EStatus MakeListingRequest(TString location, TString userToken) {\n+        auto connection = NYdb::TDriver(TDriverConfig().SetEndpoint(location).SetAuthToken(userToken));\n+        NObjectStorage::TObjectStorageClient s3conn(connection);\n+\n+        TValueBuilder keyPrefix;\n+        keyPrefix.BeginTuple()\n+                .AddElement().Uint64(50)\n+                .AddElement().Utf8(\"bucket50\")\n+                .EndTuple();\n+        TValueBuilder suffix;\n+        suffix.BeginTuple().EndTuple();\n+        auto res = s3conn.List(\"/Root/ListingObjects\",\n+                                    keyPrefix.Build(),\n+                                    \"/home/\",\n+                                    \"/\",\n+                                    \"\",\n+                                    suffix.Build(),\n+                                    100,\n+                                    {\"Name\", \"Data\", \"Timestamp\"}\n+            ).GetValueSync();\n+\n+        return res.GetStatus();\n+    }\n+\n+    Y_UNIT_TEST(TestAccessCheck) {\n+        TKikimrWithGrpcAndRootSchema server;\n+        ui16 grpc = server.GetPort();\n+        TString location = TStringBuilder() << \"localhost:\" << grpc;\n+\n+        PrepareData(location);\n+        SetPermissions(location);\n+        server.ResetSchemeCache(\"/Root/ListingObjects\");\n+\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"\"), EStatus::SUCCESS);\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"reader@builtin\"), EStatus::SUCCESS);\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"generic_reader@builtin\"), EStatus::SUCCESS);\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"root@builtin\"), EStatus::SUCCESS);\n+\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"writer@builtin\"), EStatus::UNAUTHORIZED);\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"generic_writer@builtin\"), EStatus::UNAUTHORIZED);\n+        UNIT_ASSERT_EQUAL(MakeListingRequest(location, \"badguy@builtin\"), EStatus::UNAUTHORIZED);\n+    }\n+\n+    NYdb::EStatus TestRequest(NObjectStorage::TObjectStorageClient s3conn, TValue&& keyPrefix, TValue&& suffix) {\n+        auto res = s3conn.List(\"/Root/ListingObjects\",\n+                                    std::move(keyPrefix),\n+                                    \"/home/\",\n+                                    \"/\",\n+                                    \"\",\n+                                    std::move(suffix),\n+                                    100,\n+                                    {\"Name\", \"Data\", \"Timestamp\"}\n+            ).GetValueSync();\n+\n+        return res.GetStatus();\n+    }\n+\n+    // Test request with good suffix\n+    NYdb::EStatus TestKeyPrefixRequest(NObjectStorage::TObjectStorageClient s3conn, TValue&& keyPrefix) {\n+        return TestRequest(s3conn,\n+                           std::move(keyPrefix),\n+                           TValueBuilder().BeginTuple().EndTuple().Build());\n+    }\n+\n+    // Test request with good keyPrefix\n+    NYdb::EStatus TestKeySuffixRequest(NObjectStorage::TObjectStorageClient s3conn, TValue&& keySuffix) {\n+        return TestRequest(s3conn,\n+                           TValueBuilder()\n+                              .BeginTuple()\n+                                  .AddElement().Uint64(1)\n+                                  .AddElement().Utf8(\"Bucket50\")\n+                              .EndTuple().Build(),\n+                           std::move(keySuffix));\n+    }\n+\n+    Y_UNIT_TEST(BadRequests) {\n+        TKikimrWithGrpcAndRootSchema server;\n+        ui16 grpc = server.GetPort();\n+        TString location = TStringBuilder() << \"localhost:\" << grpc;\n+\n+        PrepareData(location);\n+\n+        auto connection = NYdb::TDriver(TDriverConfig().SetEndpoint(location));\n+        NObjectStorage::TObjectStorageClient s3conn(connection);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                                      TValueBuilder()\n+                                                        .BeginTuple()\n+                                                            .AddElement().Uint64(1)\n+                                                            .AddElement().Utf8(\"Bucket50\")\n+                                                        .EndTuple().Build()),\n+                                 EStatus::SUCCESS);\n+\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                                      TValueBuilder().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                                      TValueBuilder()\n+                                                        .BeginTuple()\n+                                                            .AddElement().BeginList().EndList()\n+                                                            .AddElement().Utf8(\"Bucket50\")\n+                                                        .EndTuple().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                             TValueBuilder().BeginStruct().EndStruct().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                             TValueBuilder().BeginList().EndList().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                             TValueBuilder()\n+                                                .BeginList()\n+                                                    .AddListItem().Uint64(1)\n+                                                    .AddListItem().Uint64(22)\n+                                                .EndList().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                             TValueBuilder().Uint64(50).Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeyPrefixRequest(s3conn,\n+                                             TValueBuilder().Uint64(50).Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder().BeginTuple().EndTuple().Build()),\n+                                 EStatus::SUCCESS);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder().Build()),\n+                                 EStatus::SUCCESS);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder().BeginStruct().EndStruct().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder().BeginList().EndList().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder()\n+                                                      .BeginList()\n+                                                          .AddListItem().Uint64(1)\n+                                                          .AddListItem().Uint64(22)\n+                                                      .EndList().Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder().Uint64(50).Build()),\n+                                 EStatus::BAD_REQUEST);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(TestKeySuffixRequest(s3conn,\n+                                             TValueBuilder().Uint64(50).Build()),\n+                                 EStatus::BAD_REQUEST);\n+    }\n+}\n",
  "test_patch": "diff --git a/ydb/core/testlib/test_client.cpp b/ydb/core/testlib/test_client.cpp\nindex 923421410b7b..85c69635ef1f 100644\n--- a/ydb/core/testlib/test_client.cpp\n+++ b/ydb/core/testlib/test_client.cpp\n@@ -20,6 +20,7 @@\n #include <ydb/services/ydb/ydb_export.h>\n #include <ydb/services/ydb/ydb_import.h>\n #include <ydb/services/ydb/ydb_operation.h>\n+#include <ydb/services/ydb/ydb_object_storage.h>\n #include <ydb/services/ydb/ydb_query.h>\n #include <ydb/services/ydb/ydb_scheme.h>\n #include <ydb/services/ydb/ydb_scripting.h>\n@@ -383,6 +384,7 @@ namespace Tests {\n         }\n         GRpcServer->AddService(discoveryService);\n         GRpcServer->AddService(new NGRpcService::TGRpcYdbClickhouseInternalService(system, counters, appData.InFlightLimiterRegistry, grpcRequestProxies[0], true));\n+        GRpcServer->AddService(new NGRpcService::TGRpcYdbObjectStorageService(system, counters, grpcRequestProxies[0], true));\n         GRpcServer->AddService(new NQuoter::TRateLimiterGRpcService(system, counters, grpcRequestProxies[0]));\n         GRpcServer->AddService(new NGRpcService::TGRpcDataStreamsService(system, counters, grpcRequestProxies[0], true));\n         GRpcServer->AddService(new NGRpcService::TGRpcMonitoringService(system, counters, grpcRequestProxies[0], true));\n",
  "problem_statement": "S3 listing: filtering\n\n",
  "hints_text": "",
  "created_at": "2024-05-10T07:31:37Z",
  "modified_files": [
    "b/ydb/core/client/object_storage_listing_ut.cpp",
    "ydb/core/client/ut/ya.make",
    "ydb/core/driver_lib/run/run.cpp",
    "ydb/core/grpc_services/rpc_calls.h",
    "b/ydb/core/grpc_services/rpc_object_storage.cpp",
    "b/ydb/core/grpc_services/service_object_storage.h",
    "ydb/core/grpc_services/ya.make",
    "ydb/core/protos/tx_datashard.proto",
    "ydb/core/tx/datashard/datashard.h",
    "b/ydb/core/tx/datashard/datashard__object_storage_listing.cpp",
    "ydb/core/tx/datashard/datashard_impl.h",
    "b/ydb/core/tx/datashard/datashard_ut_object_storage_listing.cpp",
    "b/ydb/core/tx/datashard/ut_object_storage_listing/ya.make",
    "ydb/core/tx/datashard/ya.make",
    "ydb/core/ydb_convert/ydb_convert.cpp",
    "ydb/public/api/grpc/draft/ya.make",
    "b/ydb/public/api/grpc/draft/ydb_object_storage_v1.proto",
    "b/ydb/public/api/protos/draft/ydb_object_storage.proto",
    "ydb/public/api/protos/ya.make",
    "ydb/public/lib/experimental/ya.make",
    "b/ydb/public/lib/experimental/ydb_object_storage.cpp",
    "b/ydb/public/lib/experimental/ydb_object_storage.h",
    "ydb/services/ydb/ut/ya.make",
    "ydb/services/ydb/ya.make",
    "b/ydb/services/ydb/ydb_object_storage.cpp",
    "b/ydb/services/ydb/ydb_object_storage.h",
    "b/ydb/services/ydb/ydb_object_storage_ut.cpp"
  ],
  "modified_test_files": [
    "ydb/core/testlib/test_client.cpp"
  ]
}