diff --git a/ydb/core/kqp/host/kqp_host.cpp b/ydb/core/kqp/host/kqp_host.cpp
index 3064e13a12ef..bc13af0cccc6 100644
--- a/ydb/core/kqp/host/kqp_host.cpp
+++ b/ydb/core/kqp/host/kqp_host.cpp
@@ -1814,6 +1814,8 @@ class TKqpHost : public IKqpHost {
                 || settingName == "Warning"
                 || settingName == "UseBlocks"
                 || settingName == "BlockEngine"
+                || settingName == "FilterPushdownOverJoinOptionalSide"
+                || settingName == "DisableFilterPushdownOverJoinOptionalSide"
                 ;
         };
         auto configProvider = CreateConfigProvider(*TypesCtx, gatewaysConfig, {}, allowSettings);
diff --git a/ydb/core/kqp/ut/common/kqp_ut_common.cpp b/ydb/core/kqp/ut/common/kqp_ut_common.cpp
index 3542a52a2cdc..eeb915236757 100644
--- a/ydb/core/kqp/ut/common/kqp_ut_common.cpp
+++ b/ydb/core/kqp/ut/common/kqp_ut_common.cpp
@@ -495,7 +495,6 @@ void TKikimrRunner::Initialize(const TKikimrSettings& settings) {
     // --test-param KQP_LOG_FLAT_TX_SCHEMESHARD=debug
     SetupLogLevelFromTestParam(NKikimrServices::FLAT_TX_SCHEMESHARD);
     SetupLogLevelFromTestParam(NKikimrServices::KQP_YQL);
-    SetupLogLevelFromTestParam(NKikimrServices::KQP_YQL);
     SetupLogLevelFromTestParam(NKikimrServices::TX_DATASHARD);
     SetupLogLevelFromTestParam(NKikimrServices::TX_COORDINATOR);
     SetupLogLevelFromTestParam(NKikimrServices::KQP_COMPUTE);
diff --git a/ydb/core/kqp/ut/join/kqp_index_lookup_join_ut.cpp b/ydb/core/kqp/ut/join/kqp_index_lookup_join_ut.cpp
index 51937df2ee43..c659b1b0564f 100644
--- a/ydb/core/kqp/ut/join/kqp_index_lookup_join_ut.cpp
+++ b/ydb/core/kqp/ut/join/kqp_index_lookup_join_ut.cpp
@@ -528,7 +528,7 @@ Y_UNIT_TEST_TWIN(LeftJoinSkipNullFilter, StreamLookup) {
             LEFT JOIN `/Root/Right` AS r
                 ON l.Fk = r.Key
             WHERE r.Value IS NOT NULL
-            ORDER BY l.Value
+            ORDER BY l.Value, r.Value
         )",
         R"([
             [["Value1"];["Value21"]];
diff --git a/ydb/core/kqp/ut/join/kqp_join_ut.cpp b/ydb/core/kqp/ut/join/kqp_join_ut.cpp
index be6099e51a26..1360d4df206c 100644
--- a/ydb/core/kqp/ut/join/kqp_join_ut.cpp
+++ b/ydb/core/kqp/ut/join/kqp_join_ut.cpp
@@ -89,9 +89,55 @@ static void CreateSampleTables(TSession session) {
             ("Name1", 1001),
             ("Name2", 1002),
             ("Name4", 1004);
+
     )", TTxControl::BeginTx().CommitTx()).GetValueSync().IsSuccess());
 }
 
+
+static void CreateLeftJoinSampleTables(TSession session) {
+    auto res = session.ExecuteSchemeQuery(R"(
+        CREATE TABLE `/Root/Join1_1` (
+            Key1 Int32,
+            Key2 String,
+            Fk1 String,
+            Value String,
+            PRIMARY KEY (Key1, Key2)
+        );
+        CREATE TABLE `/Root/Join1_2` (
+            Key String,
+            Value Int32,
+            PRIMARY KEY (Key)
+        );
+
+        CREATE TABLE `/Root/Join1_3` (
+            Key String, Value Int32, PRIMARY KEY (Key)
+        )
+    )").ExtractValueSync();
+    UNIT_ASSERT_C(res.IsSuccess(), res.GetIssues().ToString());
+
+    auto res2 = session.ExecuteDataQuery(R"(
+        REPLACE INTO `/Root/Join1_1` (Key1, Key2, Fk1, Value) VALUES
+            (101, "One",    NULL,   "no_right_key_1"),
+            (102, "Two",   NULL,   "no_right_key_2"),
+            (103, "Three", "Name1", "Value1"),
+            (104, "One", "Name2", "Value2"),
+            (104, "Two", "Name2", "Value3"),
+            (105, "One", "Name3", "no_right_key_3"),
+            (106, "One", "Name4", NULL),
+            (106, "Two", "Name4", "Value4");
+
+        REPLACE INTO `/Root/Join1_2` (Key, Value) VALUES
+            ("Name1", 1001),
+            ("Name2", 1002),
+            ("Name4", NULL);
+
+        REPLACE INTO `/Root/Join1_3` (Key, Value) VALUES
+            ("Name2", 12345);
+
+    )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+    UNIT_ASSERT_C(res2.IsSuccess(), res2.GetIssues().ToString());
+}
+
 static void CreateRightSemiJoinSampleTables(TSession& session) {
     UNIT_ASSERT(session.ExecuteSchemeQuery(R"(
         CREATE TABLE `/Root/RSJ_SimpleKey_1` (
@@ -453,6 +499,157 @@ Y_UNIT_TEST_SUITE(KqpJoin) {
             FormatResultSetYson(result.GetResultSet(0)));
     }
 
+    Y_UNIT_TEST(LeftJoinPushdownPredicate_Simple) {
+        TKikimrRunner kikimr;
+        auto db = kikimr.GetTableClient();
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        CreateSampleTables(session);
+
+        auto result = session.ExecuteDataQuery(Q_(R"(
+            PRAGMA FilterPushdownOverJoinOptionalSide;
+
+            SELECT t2.*, t3.Key, t3.Value FROM `/Root/Join1_2` AS t2
+            LEFT JOIN `/Root/Join1_3` AS t3
+            ON t2.Fk3 = t3.Key
+            WHERE t3.Value == 1004;
+        )"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+        UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        CompareYson(
+            R"([
+                [["Name4"];[105];["Two"];["Value28"];["Name4"];[1004]]
+            ])",
+            FormatResultSetYson(result.GetResultSet(0))
+        );
+    }
+
+    Y_UNIT_TEST(LeftJoinPushdownPredicate_NoPushdown) {
+        TKikimrRunner kikimr;
+        auto db = kikimr.GetTableClient();
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        CreateLeftJoinSampleTables(session);
+
+        auto result = session.ExecuteDataQuery(Q_(R"(
+            PRAGMA FilterPushdownOverJoinOptionalSide;
+
+            SELECT t1.Key1, t1.Key2, t1.Fk1, t1.Value, t2.Key, t2.Value FROM `/Root/Join1_2` AS t2
+            RIGHT JOIN `/Root/Join1_1` AS t1
+            ON t2.Key = t1.Fk1
+            WHERE t1.Key1 > 104
+            ORDER BY t1.Key1, t1.Key2;
+        )"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+        UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        CompareYson(
+            R"([
+                [[105];["One"];["Name3"];["no_right_key_3"];#;#];
+                [[106];["One"];["Name4"];#;["Name4"];#];
+                [[106];["Two"];["Name4"];["Value4"];["Name4"];#]
+            ])",
+            FormatResultSetYson(result.GetResultSet(0))
+        );
+    }
+
+    Y_UNIT_TEST(LeftJoinPushdownPredicate_Nulls) {
+        TKikimrRunner kikimr;
+        auto db = kikimr.GetTableClient();
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        CreateLeftJoinSampleTables(session);
+        {
+            auto result = session.ExecuteDataQuery(Q_(R"(
+                PRAGMA FilterPushdownOverJoinOptionalSide;
+
+                SELECT t1.Key1, t1.Key2, t1.Fk1, t1.Value, t2.Key, t2.Value FROM `/Root/Join1_1` AS t1
+                LEFT JOIN `/Root/Join1_2` AS t2
+                ON t1.Fk1 = t2.Key
+                WHERE t2.Value > 1001
+                ORDER BY t1.Value;
+            )"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+            CompareYson(
+                R"([
+                    [[104];["One"];["Name2"];["Value2"];["Name2"];[1002]];
+                    [[104];["Two"];["Name2"];["Value3"];["Name2"];[1002]]
+                ])",
+                FormatResultSetYson(result.GetResultSet(0))
+            );
+        }
+        {
+            auto result = session.ExecuteDataQuery(Q_(R"(
+                SELECT t1.Fk1, t1.Key1, t1.Key2, t1.Value, t2.Key, t2.Value FROM `/Root/Join1_1` AS t1
+                LEFT JOIN `/Root/Join1_2` AS t2
+                ON t1.Fk1 = t2.Key
+                WHERE t2.Value IS NULL
+                ORDER BY t1.Key1, t1.Key2;
+            )"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+            CompareYson(
+                R"([
+                    [#;[101];["One"];["no_right_key_1"];#;#];
+                    [#;[102];["Two"];["no_right_key_2"];#;#];
+                    [["Name3"];[105];["One"];["no_right_key_3"];#;#];
+                    [["Name4"];[106];["One"];#;["Name4"];#];
+                    [["Name4"];[106];["Two"];["Value4"];["Name4"];#]
+                ])",
+                FormatResultSetYson(result.GetResultSet(0))
+            );
+        }
+    }
+
+     Y_UNIT_TEST(LeftJoinPushdownPredicate_NestedJoin) {
+        TKikimrRunner kikimr;
+        auto db = kikimr.GetTableClient();
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        CreateLeftJoinSampleTables(session);
+        {
+            auto result = session.ExecuteDataQuery(Q_(R"(
+                PRAGMA FilterPushdownOverJoinOptionalSide;
+
+                SELECT t1.Key1, t1.Key2, t1.Fk1, t1.Value, t2.Key, t2.Value, t3.Key, t3.Value
+                
+                FROM `/Root/Join1_1` AS t1
+                LEFT JOIN `/Root/Join1_2` AS t2
+                ON t1.Fk1 = t2.Key
+                INNER JOIN `/Root/Join1_3` AS t3
+                ON t1.Fk1 = t3.Key
+
+                WHERE t2.Value > 1001;
+            )"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+            CompareYson(
+                R"([
+                    [[104];["One"];["Name2"];["Value2"];["Name2"];[1002];["Name2"];[12345]];
+                    [[104];["Two"];["Name2"];["Value3"];["Name2"];[1002];["Name2"];[12345]]
+                ])",
+                FormatResultSetYson(result.GetResultSet(0))
+            );
+        }
+        {
+            auto result = session.ExecuteDataQuery(Q_(R"(
+                PRAGMA FilterPushdownOverJoinOptionalSide;
+
+                SELECT t1.Key1, t1.Key2, t1.Fk1, t1.Value, t2.Key, t2.Value, t3.Key, t3.Value
+
+                FROM `/Root/Join1_1` AS t1
+                CROSS JOIN `/Root/Join1_3` AS t3
+                LEFT JOIN `/Root/Join1_2` AS t2
+                ON t1.Fk1 = t2.Key
+                
+                WHERE t2.Value > 1001;
+            )"), TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+            CompareYson(
+                R"([
+                    [[104];["One"];["Name2"];["Value2"];["Name2"];[1002];["Name2"];[12345]];
+                    [[104];["Two"];["Name2"];["Value3"];["Name2"];[1002];["Name2"];[12345]]
+                ])",
+                FormatResultSetYson(result.GetResultSet(0))
+            );
+        }
+    }
+
     // join on not key column => Full Scan
     Y_UNIT_TEST(RightSemiJoin_FullScan) {
         TKikimrRunner kikimr(SyntaxV1Settings());
@@ -1333,12 +1530,12 @@ Y_UNIT_TEST_SUITE(KqpJoin) {
             auto result = session.ExecuteDataQuery(R"(
                 --!syntax_v1
 
-                REPLACE INTO left (Key, Value) VALUES 
+                REPLACE INTO left (Key, Value) VALUES
                     (1, 10),
                     (2, 20),
                     (3, 30);
 
-                REPLACE INTO right (Key, Value) VALUES 
+                REPLACE INTO right (Key, Value) VALUES
                     (1, 10),
                     (2, 200),
                     (3, 300),
@@ -1346,7 +1543,7 @@ Y_UNIT_TEST_SUITE(KqpJoin) {
             )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);
         }
-        
+
         {
             auto result = session.ExecuteDataQuery(R"(
                 --!syntax_v1
diff --git a/ydb/library/yql/core/common_opt/yql_co_finalizers.cpp b/ydb/library/yql/core/common_opt/yql_co_finalizers.cpp
index 83a6c47c96f6..a7365e8472d2 100644
--- a/ydb/library/yql/core/common_opt/yql_co_finalizers.cpp
+++ b/ydb/library/yql/core/common_opt/yql_co_finalizers.cpp
@@ -23,7 +23,7 @@ IGraphTransformer::TStatus MultiUsageFlatMapOverJoin(const TExprNode::TPtr& node
     for (auto parent : it->second) {
         if (auto maybeFlatMap = TMaybeNode<TCoFlatMapBase>(parent)) {
             auto flatMap = maybeFlatMap.Cast();
-            auto newParent = FlatMapOverEquiJoin(flatMap, ctx, *optCtx.ParentsMap, true);
+            auto newParent = FlatMapOverEquiJoin(flatMap, ctx, *optCtx.ParentsMap, true, optCtx.Types->FilterPushdownOverJoinOptionalSide);
             if (!newParent.Raw()) {
                 return IGraphTransformer::TStatus::Error;
             }
diff --git a/ydb/library/yql/core/common_opt/yql_co_flow2.cpp b/ydb/library/yql/core/common_opt/yql_co_flow2.cpp
index 32e19059bb6c..a0e04b88960a 100644
--- a/ydb/library/yql/core/common_opt/yql_co_flow2.cpp
+++ b/ydb/library/yql/core/common_opt/yql_co_flow2.cpp
@@ -1111,7 +1111,7 @@ void RegisterCoFlowCallables2(TCallableOptimizerMap& map) {
         TCoFlatMapBase self(node);
         if (optCtx.IsSingleUsage(self.Input().Ref())) {
             if (self.Input().Ref().IsCallable("EquiJoin")) {
-                auto ret = FlatMapOverEquiJoin(self, ctx, *optCtx.ParentsMap, false);
+                auto ret = FlatMapOverEquiJoin(self, ctx, *optCtx.ParentsMap, false, optCtx.Types->FilterPushdownOverJoinOptionalSide);
                 if (!ret.Raw()) {
                     return nullptr;
                 }
diff --git a/ydb/library/yql/core/common_opt/yql_flatmap_over_join.cpp b/ydb/library/yql/core/common_opt/yql_flatmap_over_join.cpp
index 031fc6b40287..8c0c540c7005 100644
--- a/ydb/library/yql/core/common_opt/yql_flatmap_over_join.cpp
+++ b/ydb/library/yql/core/common_opt/yql_flatmap_over_join.cpp
@@ -2,6 +2,7 @@
 #include "yql_co.h"
 
 #include <ydb/library/yql/core/yql_expr_optimize.h>
+#include <ydb/library/yql/core/yql_expr_type_annotation.h>
 #include <ydb/library/yql/core/yql_join.h>
 #include <ydb/library/yql/core/yql_opt_utils.h>
 
@@ -123,6 +124,81 @@ bool IsRequiredAndFilteredSide(const TExprNode::TPtr& joinTree, const TJoinLabel
     return isFiltered.Defined() && *isFiltered;
 }
 
+TExprNode::TPtr ApplyJoinPredicate(const TExprNode::TPtr& predicate, const TExprNode::TPtr& filterInput, 
+    const TExprNode::TPtr& args, const TJoinLabels& labels, const THashMap<ui32, THashMap<TString, TString>>& aliasedKeys,
+    const TMap<TStringBuf, TVector<TStringBuf>>& renameMap, bool onlyKeys, 
+    ui32 firstCandidate, ui32 inputIndex, bool ordered, bool substituteWithNulls, TExprContext& ctx
+) {
+    return ctx.Builder(predicate->Pos())
+    .Callable(ordered ? "OrderedFilter" : "Filter")
+        .Add(0, filterInput)
+        .Lambda(1)
+            .Param("row")
+            .ApplyPartial(args, predicate).With(0)
+                .Callable("AsStruct")
+                    .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
+                        ui32 index = 0;
+                        const auto& label = labels.Inputs[inputIndex];
+                        for (auto column : label.EnumerateAllColumns()) {
+                            TVector<TString> targetColumns;
+                            targetColumns.push_back(column);
+                            if (onlyKeys && inputIndex != firstCandidate) {
+                                if (auto aliasedKey = aliasedKeys.at(inputIndex).FindPtr(column)) {
+                                    targetColumns[0] = *aliasedKey;
+                                } else {
+                                    continue;
+                                }
+                            }
+
+                            TStringBuf part1;
+                            TStringBuf part2;
+                            SplitTableName(column, part1, part2);
+                            auto memberName = label.MemberName(part1, part2);
+                            auto memberType = label.FindColumn(part1, part2);
+                            Y_ENSURE(memberType);
+                            const TTypeAnnotationNode* optMemberType = ((*memberType)->IsOptionalOrNull()) ? *memberType : ctx.MakeType<TOptionalExprType>(*memberType);
+
+                            if (auto renamed = renameMap.FindPtr(targetColumns[0])) {
+                                if (renamed->empty()) {
+                                    continue;
+                                }
+
+                                targetColumns.clear();
+                                for (auto& r : *renamed) {
+                                    targetColumns.push_back(TString(r));
+                                }
+                            }
+
+                            for (auto targetColumn : targetColumns) {
+                                if (substituteWithNulls) {
+                                    auto typeNode = ExpandType(predicate->Pos(), *optMemberType, ctx);
+                                    parent.List(index++)
+                                        .Atom(0, targetColumn)
+                                        .Callable(1, "Nothing")
+                                            .Add(0, typeNode)
+                                        .Seal()
+                                    .Seal();
+                                } else {
+                                    parent.List(index++)
+                                        .Atom(0, targetColumn)
+                                        .Callable(1, "Member")
+                                            .Arg(0, "row")
+                                            .Atom(1, memberName)
+                                        .Seal()
+                                    .Seal();
+                                }
+                            }
+                        }
+
+                        return parent;
+                    })
+                .Seal()
+            .Done().Seal()
+        .Seal()
+    .Seal()
+    .Build();
+}
+
 TExprNode::TPtr SingleInputPredicatePushdownOverEquiJoin(TExprNode::TPtr equiJoin, TExprNode::TPtr predicate,
     const TSet<TStringBuf>& usedFields, TExprNode::TPtr args, const TJoinLabels& labels,
     ui32 firstCandidate, const TMap<TStringBuf, TVector<TStringBuf>>& renameMap, bool ordered, TExprContext& ctx)
@@ -207,62 +283,11 @@ TExprNode::TPtr SingleInputPredicatePushdownOverEquiJoin(TExprNode::TPtr equiJoi
         }
 
         // then apply predicate
-        newInput = ctx.Builder(predicate->Pos())
-            .Callable(ordered ? "OrderedFilter" : "Filter")
-                .Add(0, newInput)
-                .Lambda(1)
-                    .Param("row")
-                    .ApplyPartial(args, predicate).With(0)
-                        .Callable("AsStruct")
-                            .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
-                                ui32 index = 0;
-                                const auto& label = labels.Inputs[inputIndex];
-                                for (auto column : label.EnumerateAllColumns()) {
-                                    TVector<TString> targetColumns;
-                                    targetColumns.push_back(column);
-                                    if (onlyKeys && inputIndex != firstCandidate) {
-                                        if (auto aliasedKey = aliasedKeys[inputIndex].FindPtr(column)) {
-                                            targetColumns[0] = *aliasedKey;
-                                        } else {
-                                            continue;
-                                        }
-                                    }
-
-                                    TStringBuf part1;
-                                    TStringBuf part2;
-                                    SplitTableName(column, part1, part2);
-                                    auto memberName = label.MemberName(part1, part2);
-
-                                    if (auto renamed = renameMap.FindPtr(targetColumns[0])) {
-                                        if (renamed->empty()) {
-                                            continue;
-                                        }
-
-                                        targetColumns.clear();
-                                        for (auto& r : *renamed) {
-                                            targetColumns.push_back(TString(r));
-                                        }
-                                    }
-
-                                    for (auto targetColumn : targetColumns) {
-                                        parent.List(index++)
-                                                .Atom(0, targetColumn)
-                                                .Callable(1, "Member")
-                                                    .Arg(0, "row")
-                                                    .Atom(1, memberName)
-                                                .Seal()
-                                            .Seal();
-                                    }
-                                }
-
-                                return parent;
-                            })
-                        .Seal()
-                    .Done().Seal()
-                .Seal()
-            .Seal()
-            .Build();
-
+        newInput = ApplyJoinPredicate(
+            predicate, /*filterInput=*/newInput, args, labels, aliasedKeys, renameMap, onlyKeys,
+            firstCandidate, inputIndex, ordered, /*substituteWithNulls=*/false, ctx
+        );
+        
         // then return reassembled join
         ret->ChildRef(inputIndex) = ctx.ShallowCopy(*ret->Child(inputIndex));
         ret->Child(inputIndex)->ChildRef(0) = newInput;
@@ -271,6 +296,304 @@ TExprNode::TPtr SingleInputPredicatePushdownOverEquiJoin(TExprNode::TPtr equiJoi
     return ret;
 }
 
+void CountLabelsInputUsage(TExprNode::TPtr joinTree, THashMap<TString, int>& counters) {
+    if (joinTree->IsAtom()) {
+        counters[joinTree->Content()]++;
+    } else {
+        CountLabelsInputUsage(joinTree->ChildPtr(1), counters);
+        CountLabelsInputUsage(joinTree->ChildPtr(2), counters);
+    }
+}
+
+// returns the path to join child
+std::pair<TExprNode::TPtr, TExprNode::TPtr> IsRightSideForLeftJoin(
+    const TExprNode::TPtr& joinTree, const TJoinLabels& labels, ui32 inputIndex, const TExprNode::TPtr& parent = nullptr
+) {
+    auto joinType = joinTree->Child(0)->Content();
+    auto left = joinTree->ChildPtr(1);
+    auto right = joinTree->ChildPtr(2);
+    if (joinType == "Inner" || joinType == "Left" || joinType == "LeftOnly" || joinType == "LeftSemi" || joinType == "RightSemi" || joinType == "Cross") {
+        if (!left->IsAtom()) {
+            auto x = IsRightSideForLeftJoin(left, labels, inputIndex, joinTree);
+            if (x.first) {
+                return x;
+            }
+        }
+    }
+
+    if (joinType == "Inner" || joinType == "Right" || joinType == "RightOnly" || joinType == "RightSemi" || joinType == "LeftSemi" || joinType == "Cross" || joinType == "Left") {
+        if (!right->IsAtom()) {
+            auto x = IsRightSideForLeftJoin(right, labels, inputIndex, joinTree);
+            if (x.first) {
+                return x;
+            }
+        } else if (joinType == "Left") {
+            auto table = right->Content();
+            if (*labels.FindInputIndex(table) == inputIndex) {
+                return {joinTree, parent};
+            }
+        }
+    }
+
+    return {nullptr, nullptr};
+}
+
+TExprNode::TPtr FilterPushdownOverJoinOptionalSide(TExprNode::TPtr equiJoin, TExprNode::TPtr predicate,
+    const TSet<TStringBuf>& usedFields, TExprNode::TPtr args, const TJoinLabels& labels,
+    ui32 inputIndex, const TMap<TStringBuf, TVector<TStringBuf>>& renameMap, bool ordered, TExprContext& ctx,
+    const TPositionHandle& pos)
+{
+    auto inputsCount = equiJoin->ChildrenSize() - 2;
+    auto joinTree = equiJoin->Child(inputsCount);
+    
+    if (!IsRightSideForLeftJoin(joinTree, labels, inputIndex).first) {
+        return equiJoin;
+    }
+
+    YQL_ENSURE(args->ChildrenSize() == 1);
+    YQL_ENSURE(args->Head().IsArgument());
+    if (HasDependsOn(predicate, args->HeadPtr())) {
+        return equiJoin;
+    }
+
+    const bool isStrict = IsStrict(predicate);
+    if (!isStrict/* && IsRequiredAndFilteredSide(joinTree, labels, firstCandidate)*/) {
+        return equiJoin;
+    }
+
+    TMap<TString, TSet<TString>> aliases;
+    GatherKeyAliases(joinTree, aliases, labels);
+    MakeTransitiveClosure(aliases);
+
+    // check whether some used fields are not aliased
+    bool onlyKeys = true;
+    for (auto& x : usedFields) {
+        if (!aliases.contains(TString(x))) {
+            onlyKeys = false;
+            break;
+        }
+    }
+
+    if (onlyKeys) {
+        return equiJoin;
+    }
+
+    THashMap<TString, TExprNode::TPtr> equiJoinLabels;  
+    for (size_t i = 0; i < equiJoin->ChildrenSize() - 2; i++) {
+        auto label = equiJoin->Child(i);
+        equiJoinLabels.emplace(label->Child(1)->Content(), label->ChildPtr(0));
+    }
+
+    THashMap<TString, int> joinLabelCounters;
+    CountLabelsInputUsage(joinTree, joinLabelCounters);
+
+    auto [leftJoinTree, parentJoinPtr] = IsRightSideForLeftJoin(joinTree, labels, inputIndex);
+    YQL_ENSURE(leftJoinTree);
+    joinLabelCounters[leftJoinTree->Child(1)->Content()]--;
+    joinLabelCounters[leftJoinTree->Child(2)->Content()]--;
+
+    auto leftJoinSettings = equiJoin->ChildPtr(equiJoin->ChildrenSize() - 1);
+
+    auto innerJoinTree = ctx.ChangeChild(*leftJoinTree, 0, ctx.NewAtom(leftJoinTree->Pos(), "Inner"));
+    auto leftOnlyJoinTree = ctx.ChangeChild(*leftJoinTree, 0, ctx.NewAtom(leftJoinTree->Pos(), "LeftOnly"));
+
+    THashMap<TString, int> leftSideJoinLabels;
+    CountLabelsInputUsage(leftJoinTree->Child(1), leftSideJoinLabels);
+
+    YQL_ENSURE(leftJoinTree->Child(2)->IsAtom());
+    auto rightSideInput = equiJoinLabels.at(leftJoinTree->Child(2)->Content());
+
+    // skip null key columns
+    TSet<TString> optionalKeyColumns;
+    GatherOptionalKeyColumns(joinTree, labels, inputIndex, optionalKeyColumns);
+    rightSideInput = FilterOutNullJoinColumns(predicate->Pos(),
+        rightSideInput, labels.Inputs[inputIndex], optionalKeyColumns, ctx);
+
+    // then apply predicate
+    auto filteredInput = ApplyJoinPredicate(
+        predicate, /*filterInput=*/rightSideInput, args, labels, {}, renameMap, onlyKeys,
+        inputIndex, inputIndex, ordered, /*substituteWithNulls=*/false, ctx
+    );
+
+    // then create unionall of two joins.
+    //firstly, join same labels with inner join:
+
+    size_t i = 0;
+    auto innerJoin = ctx.Builder(pos)
+        .Callable("EquiJoin")
+            .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
+                for (const auto& [labelName, _] : leftSideJoinLabels) {
+                    parent.List(i++)
+                        .Add(0, equiJoinLabels.at(labelName))
+                        .Atom(1, labelName)
+                    .Seal();
+                }
+                return parent;
+            })
+            .List(i++)
+                .Add(0, filteredInput)
+                .Atom(1, innerJoinTree->ChildRef(2)->Content())
+            .Seal()
+            .Add(i++, innerJoinTree)
+            .Add(i++, leftJoinSettings)
+        .Seal()
+    .Build();
+
+    //then, do leftOnly join:
+
+    i = 0;
+    auto leftOnlyJoin = ctx.Builder(pos)
+        .Callable("EquiJoin")
+            .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
+                for (const auto& [labelName, _] : leftSideJoinLabels) {
+                    parent.List(i++)
+                        .Add(0, equiJoinLabels.at(labelName))
+                        .Atom(1, labelName)
+                    .Seal();
+                }
+                return parent;
+            })
+            .List(i++)
+                .Add(0, rightSideInput)
+                .Atom(1, leftOnlyJoinTree->ChildRef(2)->Content())
+            .Seal()
+            .Add(i++, leftOnlyJoinTree)
+            .Add(i++, leftJoinSettings)
+        .Seal()
+    .Build();
+
+
+    //extend left only join with nulls as left part and apply same predicate
+    auto nullPredicateFilter = ApplyJoinPredicate(
+        predicate, /*filterInput=*/leftOnlyJoin, args, labels, {}, renameMap, onlyKeys,
+        inputIndex, inputIndex, ordered, /*substituteWithNulls=*/true, ctx
+    );
+
+    //then unite the results;
+    auto unionAll = ctx.Builder(pos)
+        .Callable("UnionAll")
+            .Add(0, innerJoin)
+            .Add(1, nullPredicateFilter)
+        .Seal()
+        .Build();
+
+    if (!parentJoinPtr) {
+        return unionAll;
+    }
+
+    THashSet <TString> joinColumns;
+    for (const auto& [labelName, _] : leftSideJoinLabels) {
+        auto tableName = labels.FindInputIndex(labelName);
+        YQL_ENSURE(tableName);
+        for (auto column : labels.Inputs[*tableName].EnumerateAllColumns()) {
+            joinColumns.emplace(std::move(column));
+        }
+    }    
+    auto rightSideTableName = labels.FindInputIndex(innerJoinTree->Child(2)->Content());
+    YQL_ENSURE(rightSideTableName);
+    for (auto column : labels.Inputs[*rightSideTableName].EnumerateAllColumns()) {
+        joinColumns.emplace(std::move(column));
+    }
+
+    auto newJoinLabel = ctx.Builder(pos)
+        .Atom("__yql_right_side_pushdown_input_label")
+    .Build();
+
+
+    TExprNode::TPtr remJoinKeys;
+    bool changedLeftSide = false;
+    if (leftJoinTree == parentJoinPtr->ChildPtr(1)) {
+        changedLeftSide = true;
+        remJoinKeys = parentJoinPtr->ChildPtr(3);
+    } else {
+        remJoinKeys = parentJoinPtr->ChildPtr(4);
+    }
+
+    TExprNode::TListType newKeys;
+    newKeys.reserve(remJoinKeys->ChildrenSize());
+
+    for (ui32 i = 0; i < remJoinKeys->ChildrenSize(); i += 2) {
+        auto table = remJoinKeys->ChildPtr(i);
+        auto column = remJoinKeys->ChildPtr(i + 1);
+
+        YQL_ENSURE(table->IsAtom());
+        YQL_ENSURE(column->IsAtom());
+
+        auto fcn = FullColumnName(table->Content(), column->Content());
+
+        if (joinColumns.contains(fcn)) {
+        newKeys.push_back(newJoinLabel);
+        newKeys.push_back(ctx.NewAtom(column->Pos(), fcn));
+        } else {
+            newKeys.push_back(table);
+            newKeys.push_back(column);
+        } 
+    }
+
+    auto newKeysList = ctx.NewList(remJoinKeys->Pos(), std::move(newKeys));
+
+    auto newParentJoin = ctx.Builder(joinTree->Pos())
+        .List()
+            .Add(0, parentJoinPtr->ChildPtr(0))
+            .Add(1, changedLeftSide ? newJoinLabel : parentJoinPtr->ChildPtr(1))
+            .Add(2, !changedLeftSide ? newJoinLabel : parentJoinPtr->ChildPtr(2))
+            .Add(3, changedLeftSide ? newKeysList : parentJoinPtr->ChildPtr(3))
+            .Add(4, !changedLeftSide ? newKeysList : parentJoinPtr->ChildPtr(4))
+            .Add(5, parentJoinPtr->ChildPtr(5))
+        .Seal()
+        .Build();
+
+    auto newJoinTree = ctx.ReplaceNode(std::move(joinTree), *parentJoinPtr, newParentJoin);
+
+    i = 0;
+    auto newJoinSettings = ctx.Builder(pos)
+        .List()
+            .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
+                for (const auto& child : equiJoin->TailPtr()->ChildrenList()) {
+                    parent.Add(i++, child);
+                }
+                return parent;
+            })
+            .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
+                for (const auto& column : joinColumns) {
+                    parent.List(i++)
+                        .Atom(0, "rename")
+                        .Atom(1, FullColumnName("__yql_right_side_pushdown_input_label", column))
+                        .Atom(2, column)
+                    .Seal();
+                }
+                return parent;
+            })
+        .Seal()
+    .Build();
+
+    i = 0;
+    auto newEquiJoin = ctx.Builder(pos)
+        .Callable("EquiJoin")
+        .Do([&](TExprNodeBuilder& parent) -> TExprNodeBuilder& {
+            for (const auto& label : joinLabelCounters) {
+                if (label.second > 0) {
+                    auto equiJoinInput = equiJoinLabels.at(TString(label.first));
+                    parent.List(i++)
+                        .Add(0, equiJoinInput)
+                        .Atom(1, label.first)
+                    .Seal();
+                }
+            }
+            return parent;
+        })
+        .List(i++)
+            .Add(0, unionAll)
+            .Add(1, newJoinLabel)
+        .Seal()
+        .Add(i++, newJoinTree)
+        .Add(i++, newJoinSettings)
+        .Seal()
+    .Build();
+
+    return newEquiJoin;
+}
+
 class TJoinTreeRebuilder {
 public:
     TJoinTreeRebuilder(TExprNode::TPtr joinTree, TStringBuf label1, TStringBuf column1, TStringBuf label2, TStringBuf column2,
@@ -581,8 +904,15 @@ TExprNode::TPtr DecayCrossJoinIntoInner(TExprNode::TPtr equiJoin, const TExprNod
 
 } // namespace
 
-TExprBase FlatMapOverEquiJoin(const TCoFlatMapBase& node, TExprContext& ctx, const TParentsMap& parentsMap, bool multiUsage) {
+TExprBase FlatMapOverEquiJoin(
+    const TCoFlatMapBase& node, 
+    TExprContext& ctx, 
+    const TParentsMap& parentsMap, 
+    bool multiUsage, 
+    bool filterPushdownOverJoinOptionalSide
+) {
     auto equiJoin = node.Input();
+
     auto structType = equiJoin.Ref().GetTypeAnn()->Cast<TListExprType>()->GetItemType()
         ->Cast<TStructExprType>();
     if (structType->GetSize() == 0) {
@@ -737,6 +1067,16 @@ TExprBase FlatMapOverEquiJoin(const TCoFlatMapBase& node, TExprContext& ctx, con
                     ret = newJoin;
                     extraPredicate = FuseAndTerms(node.Pos(), andTerms, andTerm, isPg, ctx);
                     break;
+                } else if (filterPushdownOverJoinOptionalSide) {
+                    auto twoJoins = FilterPushdownOverJoinOptionalSide(equiJoin.Ptr(), andTerm, usedFields,
+                        node.Lambda().Args().Ptr(), labels, *inputs.begin(), renameMap, ordered, ctx, node.Pos());
+                    if (twoJoins != equiJoin.Ptr()) {
+                        YQL_CLOG(DEBUG, Core) << "RightSidePredicatePushdownOverLeftJoin";
+                        ret = twoJoins;
+                        extraPredicate = FuseAndTerms(node.Pos(), andTerms, andTerm, isPg, ctx);
+                        break;
+                    }
+                    
                 }
             }
 
diff --git a/ydb/library/yql/core/common_opt/yql_flatmap_over_join.h b/ydb/library/yql/core/common_opt/yql_flatmap_over_join.h
index 59777bf5337d..c6696ce68cb3 100644
--- a/ydb/library/yql/core/common_opt/yql_flatmap_over_join.h
+++ b/ydb/library/yql/core/common_opt/yql_flatmap_over_join.h
@@ -9,6 +9,11 @@
 
 namespace NYql {
 
-NNodes::TExprBase FlatMapOverEquiJoin(const NNodes::TCoFlatMapBase& node, TExprContext& ctx, const TParentsMap& parentsMap, bool multiUsage);
+NNodes::TExprBase FlatMapOverEquiJoin(
+    const NNodes::TCoFlatMapBase& node, 
+    TExprContext& ctx, 
+    const TParentsMap& parentsMap, 
+    bool multiUsage,
+    bool filterPushdownOverJoinOptionalSide);
 
 } // NYql
diff --git a/ydb/library/yql/core/yql_join.cpp b/ydb/library/yql/core/yql_join.cpp
index 4fcb4af4d672..544cd1fadf8f 100644
--- a/ydb/library/yql/core/yql_join.cpp
+++ b/ydb/library/yql/core/yql_join.cpp
@@ -1152,7 +1152,7 @@ std::pair<bool, bool> IsRequiredSide(const TExprNode::TPtr& joinTree, const TJoi
         else {
             auto table = right->Content();
             if (*labels.FindInputIndex(table) == inputIndex) {
-                return{ true, joinType == "Inner" || joinType == "RightSemi" };
+                return{ true, joinType == "Inner" || joinType == "RightSemi"};
             }
         }
     }
diff --git a/ydb/library/yql/core/yql_type_annotation.h b/ydb/library/yql/core/yql_type_annotation.h
index f17a3abaa537..711c618d2041 100644
--- a/ydb/library/yql/core/yql_type_annotation.h
+++ b/ydb/library/yql/core/yql_type_annotation.h
@@ -252,6 +252,7 @@ struct TTypeAnnotationContext: public TThrRefBase {
     ui32 EvaluateParallelForLimit = 5000;
     ui32 EvaluateOrderByColumnLimit = 100;
     bool PullUpFlatMapOverJoin = true;
+    bool FilterPushdownOverJoinOptionalSide = false;
     bool DeprecatedSQL = false;
     THashMap<std::tuple<TString, TString, const TTypeAnnotationNode*>, TUdfCachedInfo> UdfTypeCache; // (name,typecfg,type)->info
     bool UseTableMetaFromGraph = false;
diff --git a/ydb/library/yql/providers/config/yql_config_provider.cpp b/ydb/library/yql/providers/config/yql_config_provider.cpp
index c8bbe68aa170..c471f6fc0f01 100644
--- a/ydb/library/yql/providers/config/yql_config_provider.cpp
+++ b/ydb/library/yql/providers/config/yql_config_provider.cpp
@@ -674,6 +674,13 @@ namespace {
                 }
 
                 Types.PullUpFlatMapOverJoin = (name == "PullUpFlatMapOverJoin");
+            } else if (name == "DisableFilterPushdownOverJoinOptionalSide" || name == "FilterPushdownOverJoinOptionalSide") {
+                if (args.size() != 0) {
+                    ctx.AddError(TIssue(pos, TStringBuilder() << "Expected no arguments, but got " << args.size()));
+                    return false;
+                }
+
+                Types.FilterPushdownOverJoinOptionalSide = (name == "FilterPushdownOverJoinOptionalSide");
             }
             else if (name == "SQL") {
                 if (args.size() > 1) {
diff --git a/ydb/library/yql/sql/v1/context.cpp b/ydb/library/yql/sql/v1/context.cpp
index f34c24982b6e..295665cd085c 100644
--- a/ydb/library/yql/sql/v1/context.cpp
+++ b/ydb/library/yql/sql/v1/context.cpp
@@ -44,6 +44,7 @@ THashMap<TStringBuf, TPragmaField> CTX_PRAGMA_FIELDS = {
     {"AnsiOptionalAs", &TContext::AnsiOptionalAs},
     {"WarnOnAnsiAliasShadowing", &TContext::WarnOnAnsiAliasShadowing},
     {"PullUpFlatMapOverJoin", &TContext::PragmaPullUpFlatMapOverJoin},
+    {"FilterPushdownOverJoinOptionalSide", &TContext::FilterPushdownOverJoinOptionalSide},
     {"DqEngineEnable", &TContext::DqEngineEnable},
     {"DqEngineForce", &TContext::DqEngineForce},
     {"RegexUseRe2", &TContext::PragmaRegexUseRe2},
diff --git a/ydb/library/yql/sql/v1/context.h b/ydb/library/yql/sql/v1/context.h
index 75f98569ab97..bb788470d94a 100644
--- a/ydb/library/yql/sql/v1/context.h
+++ b/ydb/library/yql/sql/v1/context.h
@@ -262,6 +262,7 @@ namespace NSQLTranslationV1 {
         bool PragmaYsonStrict = true;
         bool PragmaRegexUseRe2 = true;
         bool PragmaPullUpFlatMapOverJoin = true;
+        bool FilterPushdownOverJoinOptionalSide = false;
         bool WarnUnnamedColumns = false;
         bool DiscoveryMode = false;
         bool EnableSystemColumns = true;
diff --git a/ydb/library/yql/sql/v1/query.cpp b/ydb/library/yql/sql/v1/query.cpp
index efbf77bbbce4..e8e92e3bfa64 100644
--- a/ydb/library/yql/sql/v1/query.cpp
+++ b/ydb/library/yql/sql/v1/query.cpp
@@ -2744,6 +2744,11 @@ class TYqlProgramNode: public TAstListNode {
                         BuildQuotedAtom(Pos, "DisablePullUpFlatMapOverJoin"))));
                 }
 
+                if (ctx.FilterPushdownOverJoinOptionalSide) {
+                    Add(Y("let", "world", Y(TString(ConfigureName), "world", configSource,
+                        BuildQuotedAtom(Pos, "FilterPushdownOverJoinOptionalSide"))));
+                }
+
                 if (ctx.DiscoveryMode) {
                     Add(Y("let", "world", Y(TString(ConfigureName), "world", configSource,
                         BuildQuotedAtom(Pos, "DiscoveryMode"))));
diff --git a/ydb/library/yql/sql/v1/sql_query.cpp b/ydb/library/yql/sql/v1/sql_query.cpp
index b4b110a9019b..4cdc20727fd6 100644
--- a/ydb/library/yql/sql/v1/sql_query.cpp
+++ b/ydb/library/yql/sql/v1/sql_query.cpp
@@ -2192,6 +2192,12 @@ TNodePtr TSqlQuery::PragmaStatement(const TRule_pragma_stmt& stmt, bool& success
         } else if (normalizedPragma == "disablepullupflatmapoverjoin") {
             Ctx.PragmaPullUpFlatMapOverJoin = false;
             Ctx.IncrementMonCounter("sql_pragma", "DisablePullUpFlatMapOverJoin");
+        } else if (normalizedPragma == "filterpushdownoverjoinoptionalside") {
+            Ctx.FilterPushdownOverJoinOptionalSide = true;
+            Ctx.IncrementMonCounter("sql_pragma", "FilterPushdownOverJoinOptionalSide");
+        } else if (normalizedPragma == "disablefilterpushdownoverjoinoptionalside") {
+            Ctx.FilterPushdownOverJoinOptionalSide = false;
+            Ctx.IncrementMonCounter("sql_pragma", "DisableFilterPushdownOverJoinOptionalSide");
         } else if (normalizedPragma == "allowunnamedcolumns") {
             Ctx.WarnUnnamedColumns = false;
             Ctx.IncrementMonCounter("sql_pragma", "AllowUnnamedColumns");
