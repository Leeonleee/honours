diff --git a/ydb/core/testlib/common_helper.cpp b/ydb/core/testlib/common_helper.cpp
index 8e92ccd15c1b..0f329d951717 100644
--- a/ydb/core/testlib/common_helper.cpp
+++ b/ydb/core/testlib/common_helper.cpp
@@ -53,7 +53,7 @@ void THelper::WaitForSchemeOperation(TActorId sender, ui64 txId) {
 
 void THelper::StartScanRequest(const TString& request, const bool expectSuccess, TVector<THashMap<TString, NYdb::TValue>>* result) const {
     NYdb::NTable::TTableClient tClient(Server.GetDriver(),
-        NYdb::NTable::TClientSettings().UseQueryCache(false).AuthToken("root@builtin"));
+        NYdb::NTable::TClientSettings().UseQueryCache(false).AuthToken(AuthToken));
     auto expectation = expectSuccess;
     bool resultReady = false;
     TVector<THashMap<TString, NYdb::TValue>> rows;
@@ -109,7 +109,7 @@ void THelper::StartScanRequest(const TString& request, const bool expectSuccess,
 
 void THelper::StartDataRequest(const TString& request, const bool expectSuccess, TString* result) const {
     NYdb::NTable::TTableClient tClient(Server.GetDriver(),
-        NYdb::NTable::TClientSettings().UseQueryCache(false).AuthToken("root@builtin"));
+        NYdb::NTable::TClientSettings().UseQueryCache(false).AuthToken(AuthToken));
     auto expectation = expectSuccess;
     bool resultReady = false;
     bool* rrPtr = &resultReady;
@@ -144,7 +144,7 @@ void THelper::StartDataRequest(const TString& request, const bool expectSuccess,
 
 void THelper::StartSchemaRequestTableServiceImpl(const TString& request, const bool expectation, const bool waiting) const {
     NYdb::NTable::TTableClient tClient(Server.GetDriver(),
-        NYdb::NTable::TClientSettings().UseQueryCache(false).AuthToken("root@builtin"));
+        NYdb::NTable::TClientSettings().UseQueryCache(false).AuthToken(AuthToken));
 
     std::shared_ptr<bool> rrPtr = std::make_shared<bool>(false);
     tClient.CreateSession().Subscribe([rrPtr, request, expectation](NThreading::TFuture<NYdb::NTable::TCreateSessionResult> f) {
@@ -171,7 +171,7 @@ void THelper::StartSchemaRequestTableServiceImpl(const TString& request, const b
 
 void THelper::StartSchemaRequestQueryServiceImpl(const TString& request, const bool expectation, const bool waiting) const {
     NYdb::NQuery::TQueryClient qClient(Server.GetDriver(),
-        NYdb::NQuery::TClientSettings().AuthToken("root@builtin"));
+        NYdb::NQuery::TClientSettings().AuthToken(AuthToken));
 
     std::shared_ptr<bool> rrPtr = std::make_shared<bool>(false);
     auto future = qClient.ExecuteQuery(request, NYdb::NQuery::TTxControl::NoTx());
diff --git a/ydb/core/testlib/common_helper.h b/ydb/core/testlib/common_helper.h
index 76b3eaf67938..cf1c1d1351d8 100644
--- a/ydb/core/testlib/common_helper.h
+++ b/ydb/core/testlib/common_helper.h
@@ -54,6 +54,10 @@ class TLoggerInit {
 };
 
 class THelper {
+private:
+    inline static const TString DefaultAuthToken = "root@builtin";
+    YDB_ACCESSOR(TString, AuthToken, DefaultAuthToken);
+
 protected:
     void WaitForSchemeOperation(TActorId sender, ui64 txId);
     void PrintResultSet(const NYdb::TResultSet& resultSet, NYson::TYsonWriter& writer) const;
@@ -73,6 +77,10 @@ class THelper {
         UseQueryService = use;
     }
 
+    void ResetAuthToken() {
+        AuthToken = DefaultAuthToken;
+    }
+
     void DropTable(const TString& tablePath);
 
     void StartScanRequest(const TString& request, const bool expectSuccess, TVector<THashMap<TString, NYdb::TValue>>* result) const;
diff --git a/ydb/core/testlib/cs_helper.cpp b/ydb/core/testlib/cs_helper.cpp
index dd26da35fa74..20ae84dba14a 100644
--- a/ydb/core/testlib/cs_helper.cpp
+++ b/ydb/core/testlib/cs_helper.cpp
@@ -193,7 +193,6 @@ TString THelper::GetTestTableSchema() const {
     sb << R"(
         KeyColumnNames: "timestamp"
         KeyColumnNames: "uid"
-        Engine : COLUMN_ENGINE_REPLACING_TIMESERIES
     )";
     return sb;
 }
@@ -230,6 +229,32 @@ void THelper::CreateOlapTablesWithStore(TVector<TString> tableNames /*= {"olapTa
         CreateSchemaOlapTablesWithStore(GetTestTableSchema(), tableNames, storeName, storeShardsCount, tableShardsCount);
 }
 
+void THelper::CreateSchemaOlapTables(const TString tableSchema, TVector<TString> tableNames, ui32 tableShardsCount) {
+    TActorId sender = Server.GetRuntime()->AllocateEdgeActor();
+
+    const TString shardingColumns = "[\"" + JoinSeq("\",\"", GetShardingColumns()) + "\"]";
+
+    for (const TString& tableName : tableNames) {
+        TBase::CreateTestOlapTable(sender, "", Sprintf(R"(
+            Name: "%s"
+            ColumnShardCount: %d
+            Sharding {
+                HashSharding {
+                    Function: %s
+                    Columns: %s
+                }
+            }
+            Schema {
+                %s
+            }
+        )", tableName.c_str(), tableShardsCount, ShardingMethod.data(), shardingColumns.c_str(), tableSchema.data()));
+    }
+}
+
+void THelper::CreateOlapTables(TVector<TString> tableNames /*= {"olapTable"}*/, ui32 tableShardsCount /*= 3*/) {
+        CreateSchemaOlapTables(GetTestTableSchema(), tableNames, tableShardsCount);
+}
+
 // Clickbench table
 
 std::shared_ptr<arrow::Schema> TCickBenchHelper::GetArrowSchema() const {
diff --git a/ydb/core/testlib/cs_helper.h b/ydb/core/testlib/cs_helper.h
index 95c8877b6ba6..b44a5188e3b6 100644
--- a/ydb/core/testlib/cs_helper.h
+++ b/ydb/core/testlib/cs_helper.h
@@ -15,7 +15,7 @@ class THelperSchemaless : public NCommon::THelper {
     void CreateTestOlapStore(TActorId sender, TString scheme);
     void CreateTestOlapTable(TActorId sender, TString storeOrDirName, TString scheme);
     void SendDataViaActorSystem(TString testTable, ui64 pathIdBegin, ui64 tsBegin, size_t rowCount, const ui32 tsStepUs = 1) const;
-    void SendDataViaActorSystem(TString testTable, std::shared_ptr<arrow::RecordBatch> batch, const Ydb::StatusIds_StatusCode& expectedStatus =  Ydb::StatusIds::SUCCESS) const;
+    void SendDataViaActorSystem(TString testTable, std::shared_ptr<arrow::RecordBatch> batch, const Ydb::StatusIds_StatusCode& expectedStatus = Ydb::StatusIds::SUCCESS) const;
 
     virtual std::shared_ptr<arrow::RecordBatch> TestArrowBatch(ui64 pathIdBegin, ui64 tsBegin, size_t rowCount, const ui32 tsStepUs = 1) const = 0;
 };
@@ -37,6 +37,10 @@ class THelper: public THelperSchemaless {
     void CreateOlapTablesWithStore(TVector<TString> tableName = {"olapTable"}, TString storeName = "olapStore",
         ui32 storeShardsCount = 4, ui32 tableShardsCount = 3);
 
+    void CreateSchemaOlapTables(const TString tableSchema, TVector<TString> tableNames = {"olapTable"},
+        ui32 tableShardsCount = 3);
+    void CreateOlapTables(TVector<TString> tableName = {"olapTable"}, ui32 tableShardsCount = 3);
+
 public:
     using TBase::TBase;
 
@@ -53,7 +57,6 @@ class THelper: public THelperSchemaless {
         Columns { Name: "level" Type: "Int32" DataAccessorConstructor{ ClassName: "SPARSED" }}
         Columns { Name: "message" Type: "Utf8" }
         KeyColumnNames: "timestamp"
-        Engine: COLUMN_ENGINE_REPLACING_TIMESERIES
     )";
 
     void WithSomeNulls() {
diff --git a/ydb/core/testlib/test_client.cpp b/ydb/core/testlib/test_client.cpp
index fbc0ed46e7db..1dbf1b31f44c 100644
--- a/ydb/core/testlib/test_client.cpp
+++ b/ydb/core/testlib/test_client.cpp
@@ -113,6 +113,7 @@
 #include <ydb/services/ext_index/service/executor.h>
 #include <ydb/core/tx/conveyor/service/service.h>
 #include <ydb/core/tx/conveyor/usage/service.h>
+#include <ydb/core/tx/priorities/usage/service.h>
 #include <ydb/core/tx/limiter/grouped_memory/usage/service.h>
 #include <ydb/library/folder_service/mock/mock_folder_service_adapter.h>
 
@@ -773,6 +774,11 @@ namespace Tests {
             const auto aid = Runtime->Register(actor, nodeIdx, appData.UserPoolId, TMailboxType::Revolving, 0);
             Runtime->RegisterService(NOlap::NGroupedMemoryManager::TScanMemoryLimiterOperator::MakeServiceId(Runtime->GetNodeId(nodeIdx)), aid, nodeIdx);
         }
+        {
+            auto* actor = NPrioritiesQueue::TCompServiceOperator::CreateService(NPrioritiesQueue::TConfig(), new ::NMonitoring::TDynamicCounters());
+            const auto aid = Runtime->Register(actor, nodeIdx, appData.UserPoolId, TMailboxType::Revolving, 0);
+            Runtime->RegisterService(NPrioritiesQueue::TCompServiceOperator::MakeServiceId(Runtime->GetNodeId(nodeIdx)), aid, nodeIdx);
+        }
         {
             auto* actor = NConveyor::TScanServiceOperator::CreateService(NConveyor::TConfig(), new ::NMonitoring::TDynamicCounters());
             const auto aid = Runtime->Register(actor, nodeIdx, appData.UserPoolId, TMailboxType::Revolving, 0);
diff --git a/ydb/core/testlib/test_client.h b/ydb/core/testlib/test_client.h
index 68b878f4de04..3e6762c2c100 100644
--- a/ydb/core/testlib/test_client.h
+++ b/ydb/core/testlib/test_client.h
@@ -252,6 +252,7 @@ namespace Tests {
             AppConfig->MutableHiveConfig()->SetObjectImbalanceToBalance(100);
             AppConfig->MutableColumnShardConfig()->SetDisabledOnSchemeShard(false);
             FeatureFlags.SetEnableSeparationComputeActorsFromRead(true);
+            FeatureFlags.SetEnableWritePortionsOnInsert(true);
         }
 
         TServerSettings(const TServerSettings& settings) = default;
diff --git a/ydb/core/testlib/ya.make b/ydb/core/testlib/ya.make
index 5a63f36a639f..3acfb09d3c6e 100644
--- a/ydb/core/testlib/ya.make
+++ b/ydb/core/testlib/ya.make
@@ -102,6 +102,7 @@ PEERDIR(
     ydb/services/ext_index/service
     ydb/services/ymq
     ydb/core/tx/conveyor/service
+    ydb/core/tx/priorities/service
     ydb/core/tx/limiter/grouped_memory/usage
     ydb/services/fq
     ydb/services/kesus
diff --git a/ydb/core/tx/columnshard/hooks/testing/controller.cpp b/ydb/core/tx/columnshard/hooks/testing/controller.cpp
index 9cf3a7e7e9b5..e048c11614ed 100644
--- a/ydb/core/tx/columnshard/hooks/testing/controller.cpp
+++ b/ydb/core/tx/columnshard/hooks/testing/controller.cpp
@@ -1,11 +1,14 @@
 #include "controller.h"
-#include <ydb/core/tx/columnshard/columnshard_impl.h>
+
 #include <ydb/core/tx/columnshard/blobs_action/abstract/gc.h>
-#include <ydb/core/tx/columnshard/engines/column_engine.h>
+#include <ydb/core/tx/columnshard/columnshard_impl.h>
 #include <ydb/core/tx/columnshard/engines/changes/compaction.h>
 #include <ydb/core/tx/columnshard/engines/changes/indexation.h>
 #include <ydb/core/tx/columnshard/engines/changes/ttl.h>
+#include <ydb/core/tx/columnshard/engines/column_engine.h>
 #include <ydb/core/tx/columnshard/engines/column_engine_logs.h>
+#include <ydb/core/tx/columnshard/engines/portions/data_accessor.h>
+
 #include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>
 
 namespace NKikimr::NYDBTest::NColumnShard {
@@ -22,16 +25,18 @@ void TController::DoOnAfterGCAction(const ::NKikimr::NColumnShard::TColumnShard&
     }
 }
 
-void TController::CheckInvariants(const ::NKikimr::NColumnShard::TColumnShard& shard, TCheckContext& context) const {
+void TController::CheckInvariants(const ::NKikimr::NColumnShard::TColumnShard& shard, TCheckContext& /*context*/) const {
     if (!shard.HasIndex()) {
         return;
     }
+    /*
     const auto& index = shard.GetIndexAs<NOlap::TColumnEngineForLogs>();
     std::vector<std::shared_ptr<NOlap::TGranuleMeta>> granules = index.GetTables({}, {});
     THashMap<TString, THashSet<NOlap::TUnifiedBlobId>> ids;
     for (auto&& i : granules) {
+        auto accessor = i->GetDataAccessorPtrVerifiedAs<NOlap::TMemDataAccessor>();
         for (auto&& p : i->GetPortions()) {
-            p.second->FillBlobIdsByStorage(ids, index.GetVersionedIndex());
+            accessor->BuildAccessor(p.second).FillBlobIdsByStorage(ids, index.GetVersionedIndex());
         }
     }
     for (auto&& i : ids) {
@@ -60,6 +65,7 @@ void TController::CheckInvariants(const ::NKikimr::NColumnShard::TColumnShard& s
         }
     }
     context.AddCategories(shard.TabletID(), std::move(shardBlobsCategories));
+    */
 }
 
 TController::TCheckContext TController::CheckInvariants() const {
@@ -118,7 +124,8 @@ bool TController::IsTrivialLinks() const {
     return true;
 }
 
-::NKikimr::NColumnShard::TBlobPutResult::TPtr TController::OverrideBlobPutResultOnCompaction(const ::NKikimr::NColumnShard::TBlobPutResult::TPtr original, const NOlap::TWriteActionsCollection& actions) const {
+::NKikimr::NColumnShard::TBlobPutResult::TPtr TController::OverrideBlobPutResultOnCompaction(
+    const ::NKikimr::NColumnShard::TBlobPutResult::TPtr original, const NOlap::TWriteActionsCollection& actions) const {
     if (IndexWriteControllerEnabled) {
         return original;
     }
@@ -138,4 +145,4 @@ ::NKikimr::NColumnShard::TBlobPutResult::TPtr TController::OverrideBlobPutResult
     return result;
 }
 
-}
+}   // namespace NKikimr::NYDBTest::NColumnShard
diff --git a/ydb/core/tx/columnshard/hooks/testing/controller.h b/ydb/core/tx/columnshard/hooks/testing/controller.h
index a8e259877fd0..47c17099f561 100644
--- a/ydb/core/tx/columnshard/hooks/testing/controller.h
+++ b/ydb/core/tx/columnshard/hooks/testing/controller.h
@@ -12,7 +12,8 @@ namespace NKikimr::NYDBTest::NColumnShard {
 class TController: public TReadOnlyController {
 private:
     using TBase = TReadOnlyController;
-    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideRequestsTracePingCheckPeriod);
+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideUsedSnapshotLivetime);
+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideStalenessLivetimePing);
     YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideLagForCompactionBeforeTierings);
     YDB_ACCESSOR(std::optional<TDuration>, OverrideGuaranteeIndexationInterval, TDuration::Zero());
     YDB_ACCESSOR(std::optional<TDuration>, OverridePeriodicWakeupActivationPeriod, std::nullopt);
@@ -21,7 +22,12 @@ class TController: public TReadOnlyController {
     YDB_ACCESSOR(std::optional<TDuration>, OverrideOptimizerFreshnessCheckDuration, TDuration::Zero());
     YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideCompactionActualizationLag);
     YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideTasksActualizationLag);
-    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideReadTimeoutClean);
+    YDB_ACCESSOR_DEF(std::optional<TDuration>, OverrideMaxReadStaleness);
+    YDB_ACCESSOR(std::optional<ui64>, OverrideMemoryLimitForPortionReading, 100);
+    YDB_ACCESSOR(std::optional<ui64>, OverrideLimitForPortionsMetadataAsk, 1);
+    
+    YDB_ACCESSOR_DEF(std::optional<NKikimrProto::EReplyStatus>, OverrideBlobPutResultOnWriteValue);
+
     EOptimizerCompactionWeightControl CompactionControl = EOptimizerCompactionWeightControl::Force;
 
     YDB_ACCESSOR(std::optional<ui64>, OverrideReduceMemoryIntervalLimit, 1024);
@@ -130,14 +136,26 @@ class TController: public TReadOnlyController {
     THashSet<TString> SharingIds;
 protected:
     virtual ::NKikimr::NColumnShard::TBlobPutResult::TPtr OverrideBlobPutResultOnCompaction(const ::NKikimr::NColumnShard::TBlobPutResult::TPtr original, const NOlap::TWriteActionsCollection& actions) const override;
+
+    virtual ui64 DoGetLimitForPortionsMetadataAsk(const ui64 defaultValue) const override {
+        return OverrideLimitForPortionsMetadataAsk.value_or(defaultValue);
+    }
+
+
+    virtual ui64 DoGetMemoryLimitScanPortion(const ui64 defaultValue) const override {
+        return OverrideMemoryLimitForPortionReading.value_or(defaultValue);
+    }
+
     virtual TDuration DoGetLagForCompactionBeforeTierings(const TDuration def) const override {
         return OverrideLagForCompactionBeforeTierings.value_or(def);
     }
 
-    virtual TDuration DoGetPingCheckPeriod(const TDuration def) const override {
-        return OverrideRequestsTracePingCheckPeriod.value_or(def);
+    virtual TDuration DoGetUsedSnapshotLivetime(const TDuration def) const override {
+        return OverrideUsedSnapshotLivetime.value_or(def);
+    }
+    virtual std::optional<TDuration> DoGetStalenessLivetimePing() const override {
+        return OverrideStalenessLivetimePing;
     }
-
     virtual TDuration DoGetCompactionActualizationLag(const TDuration def) const override {
         return OverrideCompactionActualizationLag.value_or(def);
     }
@@ -172,8 +190,8 @@ class TController: public TReadOnlyController {
     virtual TDuration DoGetOptimizerFreshnessCheckDuration(const TDuration defaultValue) const override {
         return OverrideOptimizerFreshnessCheckDuration.value_or(defaultValue);
     }
-    virtual TDuration DoGetReadTimeoutClean(const TDuration def) const override {
-        return OverrideReadTimeoutClean.value_or(def);
+    virtual TDuration DoGetMaxReadStaleness(const TDuration def) const override {
+        return OverrideMaxReadStaleness.value_or(def);
     }
     virtual ui64 DoGetReduceMemoryIntervalLimit(const ui64 def) const override {
         return OverrideReduceMemoryIntervalLimit.value_or(def);
@@ -181,6 +199,9 @@ class TController: public TReadOnlyController {
     virtual ui64 DoGetRejectMemoryIntervalLimit(const ui64 def) const override {
         return OverrideRejectMemoryIntervalLimit.value_or(def);
     }
+    virtual ui64 DoGetMetadataRequestSoftMemoryLimit(const ui64 /* def */) const override {
+        return 0;
+    }
     virtual EOptimizerCompactionWeightControl GetCompactionControl() const override {
         return CompactionControl;
     }
@@ -196,6 +217,10 @@ class TController: public TReadOnlyController {
     }
 
 public:
+    virtual NKikimrProto::EReplyStatus OverrideBlobPutResultOnWrite(const NKikimrProto::EReplyStatus originalStatus) const override {
+        return OverrideBlobPutResultOnWriteValue.value_or(originalStatus);
+    }
+
     const TAtomicCounter& GetIndexWriteControllerBrokeCount() const {
         return IndexWriteControllerBrokeCount;
     }
diff --git a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp
index 31de6ffef8a5..fb187b70a8bf 100644
--- a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp
+++ b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp
@@ -1,15 +1,18 @@
 #include "columnshard_ut_common.h"
 #include "shard_reader.h"
 
-#include <ydb/core/tx/columnshard/hooks/testing/controller.h>
-#include <ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.h>
-#include <ydb/core/tx/columnshard/engines/storage/indexes/max/meta.h>
-
 #include <ydb/core/base/tablet.h>
 #include <ydb/core/base/tablet_resolver.h>
+#include <ydb/core/protos/data_events.pb.h>
 #include <ydb/core/scheme/scheme_types_proto.h>
-#include <ydb/core/tx/tiering/snapshot.h>
+#include <ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.h>
+#include <ydb/core/tx/columnshard/engines/storage/indexes/max/meta.h>
+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>
+#include <ydb/core/tx/data_events/common/modification_type.h>
+#include <ydb/core/tx/data_events/payload_helper.h>
+#include <ydb/core/tx/tiering/manager.h>
 #include <ydb/core/tx/tiering/tier/object.h>
+
 #include <library/cpp/testing/unittest/registar.h>
 
 namespace NKikimr::NTxUT {
@@ -45,8 +48,8 @@ void TTester::Setup(TTestActorRuntime& runtime) {
     runtime.UpdateCurrentTime(TInstant::Now());
 }
 
-void ProvideTieringSnapshot(TTestBasicRuntime& runtime, const TActorId& sender, NMetadata::NFetcher::ISnapshot::TPtr snapshot) {
-    auto event = std::make_unique<NMetadata::NProvider::TEvRefreshSubscriberData>(snapshot);
+void RefreshTiering(TTestBasicRuntime& runtime, const TActorId& sender) {
+    auto event = std::make_unique<TEvPrivate::TEvTieringModified>();
 
     ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, event.release());
 }
@@ -63,7 +66,7 @@ bool ProposeSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, const TString
     return (res.GetStatus() == NKikimrTxColumnShard::PREPARED);
 }
 
-void PlanSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot snap) {
+void PlanSchemaTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap) {
     auto plan = std::make_unique<TEvTxProcessing::TEvPlanStep>(snap.GetPlanStep(), 0, TTestTxConfig::TxTablet0);
     auto tx = plan->Record.AddTransactions();
     tx->SetTxId(snap.GetTxId());
@@ -78,7 +81,7 @@ void PlanSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot
     UNIT_ASSERT_EQUAL(res.GetStatus(), NKikimrTxColumnShard::SUCCESS);
 }
 
-void PlanWriteTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot snap, bool waitResult) {
+void PlanWriteTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap, bool waitResult) {
     auto plan = std::make_unique<TEvTxProcessing::TEvPlanStep>(snap.GetPlanStep(), 0, TTestTxConfig::TxTablet0);
     auto tx = plan->Record.AddTransactions();
     tx->SetTxId(snap.GetTxId());
@@ -96,26 +99,29 @@ void PlanWriteTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot
 
 ui32 WaitWriteResult(TTestBasicRuntime& runtime, ui64 shardId, std::vector<ui64>* writeIds) {
     TAutoPtr<IEventHandle> handle;
-    auto event = runtime.GrabEdgeEvent<TEvColumnShard::TEvWriteResult>(handle);
+    auto event = runtime.GrabEdgeEvent<NEvents::TDataEvents::TEvWriteResult>(handle);
     UNIT_ASSERT(event);
 
-    auto& resWrite = Proto(event);
+    auto& resWrite = event->Record;
     UNIT_ASSERT_EQUAL(resWrite.GetOrigin(), shardId);
-    UNIT_ASSERT_EQUAL(resWrite.GetTxInitiator(), 0);
-    if (writeIds && resWrite.GetStatus() == NKikimrTxColumnShard::EResultStatus::SUCCESS) {
-        writeIds->push_back(resWrite.GetWriteId());
+    if (writeIds && resWrite.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED) {
+        writeIds->push_back(resWrite.GetTxId());
     }
     return resWrite.GetStatus();
 }
 
-bool WriteDataImpl(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId, const ui64 tableId,
-                    const NLongTxService::TLongTxId& longTxId, const ui64 writeId,
-                    const TString& data, const std::shared_ptr<arrow::Schema>& schema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType) {
+bool WriteDataImpl(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId, const ui64 tableId, const ui64 writeId,
+                    const TString& data, const std::shared_ptr<arrow::Schema>& schema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType, const ui64 lockId) {
     const TString dedupId = ToString(writeId);
 
-    auto write = std::make_unique<TEvColumnShard::TEvWrite>(sender, longTxId, tableId, dedupId, data, writeId, mType);
-    Y_ABORT_UNLESS(schema);
-    write->SetArrowSchema(NArrow::SerializeSchema(*schema));
+    auto write = std::make_unique<NEvents::TDataEvents::TEvWrite>(writeId, NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE);
+    write->SetLockId(lockId, 1);
+    auto& operation = write->AddOperation(TEnumOperator<NEvWrite::EModificationType>::SerializeToWriteProto(mType), TTableId(0, tableId, 1), {},
+        0, NKikimrDataEvents::FORMAT_ARROW);
+    *operation.MutablePayloadSchema() = NArrow::SerializeSchema(*schema);
+    NEvWrite::TPayloadWriter<NEvents::TDataEvents::TEvWrite> writer(*write);
+    auto dataCopy = data;
+    writer.AddDataToPayload(std::move(dataCopy));
     ForwardToTablet(runtime, shardId, sender, write.release());
 
     if (writeIds) {
@@ -125,25 +131,21 @@ bool WriteDataImpl(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shar
 }
 
 bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId, const ui64 writeId, const ui64 tableId, const TString& data,
-    const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType) {
-    NLongTxService::TLongTxId longTxId;
-    UNIT_ASSERT(longTxId.ParseString("ydb://long-tx/01ezvvxjdk2hd4vdgjs68knvp8?node_id=1"));
-    return WriteDataImpl(
-        runtime, sender, shardId, tableId, longTxId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), writeIds, mType);
+    const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds, const NEvWrite::EModificationType mType,
+    const ui64 lockId) {
+    return WriteDataImpl(runtime, sender, shardId, tableId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), writeIds, mType, lockId);
 }
 
 bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 writeId, const ui64 tableId, const TString& data,
     const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, bool waitResult, std::vector<ui64>* writeIds,
-    const NEvWrite::EModificationType mType) {
-    NLongTxService::TLongTxId longTxId;
-    UNIT_ASSERT(longTxId.ParseString("ydb://long-tx/01ezvvxjdk2hd4vdgjs68knvp8?node_id=1"));
+    const NEvWrite::EModificationType mType, const ui64 lockId) {
     if (writeIds) {
-        return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, longTxId, writeId, data,
-            NArrow::MakeArrowSchema(ydbSchema), writeIds, mType);
+        return WriteDataImpl(
+            runtime, sender, TTestTxConfig::TxTablet0, tableId, writeId, data, NArrow::MakeArrowSchema(ydbSchema), writeIds, mType, lockId);
     }
     std::vector<ui64> ids;
-    return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, longTxId, writeId, data,
-        NArrow::MakeArrowSchema(ydbSchema), waitResult ? &ids : nullptr, mType);
+    return WriteDataImpl(runtime, sender, TTestTxConfig::TxTablet0, tableId, writeId, data, NArrow::MakeArrowSchema(ydbSchema),
+        waitResult ? &ids : nullptr, mType, lockId);
 }
 
 std::optional<ui64> WriteData(TTestBasicRuntime& runtime, TActorId& sender, const NLongTxService::TLongTxId& longTxId,
@@ -205,31 +207,31 @@ void ScanIndexStats(TTestBasicRuntime& runtime, TActorId& sender, const std::vec
     ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, scan.release());
 }
 
-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds) {
-    NKikimrTxColumnShard::ETransactionKind txKind = NKikimrTxColumnShard::ETransactionKind::TX_KIND_COMMIT;
-    TString txBody = TTestSchema::CommitTxBody(0, writeIds);
+void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& /* writeIds */, const ui64 lockId) {
+    auto write = std::make_unique<NEvents::TDataEvents::TEvWrite>(txId, NKikimrDataEvents::TEvWrite::MODE_PREPARE);
+    auto* lock = write->Record.MutableLocks()->AddLocks();
+    lock->SetLockId(lockId);
+    write->Record.MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Commit);
 
-    ForwardToTablet(runtime, shardId, sender,
-                new TEvColumnShard::TEvProposeTransaction(txKind, sender, txId, txBody));
+    ForwardToTablet(runtime, shardId, sender, write.release());
     TAutoPtr<IEventHandle> handle;
-    auto event = runtime.GrabEdgeEvent<TEvColumnShard::TEvProposeTransactionResult>(handle);
+    auto event = runtime.GrabEdgeEvent<NEvents::TDataEvents::TEvWriteResult>(handle);
     UNIT_ASSERT(event);
 
-    auto& res = Proto(event);
-    UNIT_ASSERT_EQUAL(res.GetTxKind(), txKind);
-    UNIT_ASSERT_EQUAL(res.GetTxId(), txId);
-    UNIT_ASSERT_EQUAL(res.GetStatus(), NKikimrTxColumnShard::EResultStatus::PREPARED);
+    auto& res = event->Record;
+    AFL_VERIFY(res.GetTxId() == txId)("tx_id", txId)("res", res.GetTxId());
+    UNIT_ASSERT_EQUAL(res.GetStatus(), NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);
 }
 
-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {
-    ProposeCommit(runtime, sender, TTestTxConfig::TxTablet0, txId, writeIds);
+void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId) {
+    ProposeCommit(runtime, sender, TTestTxConfig::TxTablet0, txId, writeIds, lockId);
 }
 
 void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, const TSet<ui64>& txIds) {
     PlanCommit(runtime, sender, TTestTxConfig::TxTablet0, planStep, txIds);
 }
 
-void Wakeup(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId) {
+void Wakeup(TTestBasicRuntime& runtime, const TActorId& sender, const ui64 shardId) {
     auto wakeup = std::make_unique<TEvPrivate::TEvPeriodicWakeup>(true);
     ForwardToTablet(runtime, shardId, sender, wakeup.release());
 }
@@ -246,12 +248,12 @@ void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64
     TAutoPtr<IEventHandle> handle;
 
     for (ui32 i = 0; i < txIds.size(); ++i) {
-        auto event = runtime.GrabEdgeEvent<TEvColumnShard::TEvProposeTransactionResult>(handle);
+        auto event = runtime.GrabEdgeEvent<NEvents::TDataEvents::TEvWriteResult>(handle);
         UNIT_ASSERT(event);
 
-        auto& res = Proto(event);
+        auto& res = event->Record;
         UNIT_ASSERT(txIds.contains(res.GetTxId()));
-        UNIT_ASSERT_EQUAL(res.GetStatus(), NKikimrTxColumnShard::EResultStatus::SUCCESS);
+        UNIT_ASSERT_EQUAL(res.GetStatus(), NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
     }
     Wakeup(runtime, sender, shardId);
 }
@@ -369,44 +371,33 @@ TSerializedTableRange MakeTestRange(std::pair<ui64, ui64> range, bool inclusiveF
                                  TConstArrayRef<TCell>(cellsTo), inclusiveTo);
 }
 
-NMetadata::NFetcher::ISnapshot::TPtr TTestSchema::BuildSnapshot(const TTableSpecials& specials) {
-    std::unique_ptr<NColumnShard::NTiers::TConfigsSnapshot> cs(new NColumnShard::NTiers::TConfigsSnapshot(Now()));
+THashMap<TString, NColumnShard::NTiers::TTierConfig> TTestSchema::BuildSnapshot(const TTableSpecials& specials) {
     if (specials.Tiers.empty()) {
-        return cs;
+        return {};
     }
-    NColumnShard::NTiers::TTieringRule tRule;
-    tRule.SetTieringRuleId("Tiering1");
+    THashMap<TString, NColumnShard::NTiers::TTierConfig> tiers;
     for (auto&& tier : specials.Tiers) {
-        if (!tRule.GetDefaultColumn()) {
-            tRule.SetDefaultColumn(tier.TtlColumn);
-        }
-        UNIT_ASSERT(tRule.GetDefaultColumn() == tier.TtlColumn);
         {
-            NKikimrSchemeOp::TStorageTierConfig cProto;
-            cProto.SetName(tier.Name);
-            *cProto.MutableObjectStorage() = tier.S3;
+            NKikimrSchemeOp::TCompressionOptions compressionProto;
             if (tier.Codec) {
-                cProto.MutableCompression()->SetCodec(tier.GetCodecId());
+                compressionProto.SetCodec(tier.GetCodecId());
             }
             if (tier.CompressionLevel) {
-                cProto.MutableCompression()->SetLevel(*tier.CompressionLevel);
+                compressionProto.SetLevel(*tier.CompressionLevel);
             }
-            NColumnShard::NTiers::TTierConfig tConfig(tier.Name, cProto);
-            cs->MutableTierConfigs().emplace(tConfig.GetTierName(), tConfig);
+            NColumnShard::NTiers::TTierConfig tConfig(tier.S3, compressionProto);
+            tiers.emplace(tier.Name, tConfig);
         }
-        tRule.AddInterval(tier.Name, TDuration::Seconds((*tier.EvictAfter).Seconds()));
     }
-    cs->MutableTableTierings().emplace(tRule.GetTieringRuleId(), tRule);
-    return cs;
+    return tiers;
 }
 
 void TTestSchema::InitSchema(const std::vector<NArrow::NTest::TTestColumn>& columns, const std::vector<NArrow::NTest::TTestColumn>& pk,
     const TTableSpecials& specials, NKikimrSchemeOp::TColumnTableSchema* schema) {
-    schema->SetEngine(NKikimrSchemeOp::COLUMN_ENGINE_REPLACING_TIMESERIES);
 
     for (ui32 i = 0; i < columns.size(); ++i) {
         *schema->MutableColumns()->Add() = columns[i].CreateColumn(i + 1);
-        if (!specials.NeedTestStatistics()) {
+        if (!specials.NeedTestStatistics(pk)) {
             continue;
         }
         if (NOlap::NIndexes::NMax::TIndexMeta::IsAvailableType(columns[i].GetType())) {
@@ -435,19 +426,26 @@ namespace NKikimr::NColumnShard {
     NOlap::TIndexInfo BuildTableInfo(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,
                          const std::vector<NArrow::NTest::TTestColumn>& key) {
         THashMap<ui32, NTable::TColumn> columns;
+        THashMap<TString, ui32> columnIdByName;
         for (ui32 i = 0; i < ydbSchema.size(); ++i) {
             ui32 id = i + 1;
             auto& name = ydbSchema[i].GetName();
             auto& type = ydbSchema[i].GetType();
 
             columns[id] = NTable::TColumn(name, id, type, "");
+            AFL_VERIFY(columnIdByName.emplace(name, id).second);
         }
 
-        std::vector<TString> pkNames;
+        std::vector<ui32> pkIds;
+        ui32 idx = 0;
         for (const auto& c : key) {
-            pkNames.push_back(c.GetName());
+            auto it = columnIdByName.FindPtr(c.GetName());
+            AFL_VERIFY(it);
+            AFL_VERIFY(*it < columns.size());
+            columns[*it].KeyOrder = idx++;
+            pkIds.push_back(*it);
         }
-        return NOlap::TIndexInfo::BuildDefault(NOlap::TTestStoragesManager::GetInstance(), columns, pkNames);
+        return NOlap::TIndexInfo::BuildDefault(NOlap::TTestStoragesManager::GetInstance(), columns, pkIds);
     }
 
     void SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const NOlap::TSnapshot& snapshot, bool succeed) {
diff --git a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h
index 7594be5da952..611fc1e2a28d 100644
--- a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h
+++ b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h
@@ -11,6 +11,7 @@
 #include <ydb/core/tx/columnshard/test_helper/helper.h>
 #include <ydb/core/tx/data_events/common/modification_type.h>
 #include <ydb/core/tx/long_tx_service/public/types.h>
+#include <ydb/core/tx/tiering/manager.h>
 
 #include <ydb/public/sdk/cpp/client/ydb_value/value.h>
 #include <ydb/services/metadata/abstract/fetcher.h>
@@ -107,7 +108,7 @@ struct TTestSchema {
             s3Config.SetProxyPort(8080);
             s3Config.SetProxyScheme(NKikimrSchemeOp::TS3Settings::HTTP);
 #else
-            s3Config.SetEndpoint("fake");
+            s3Config.SetEndpoint("fake.fake");
             s3Config.SetSecretKey("fakeSecret");
 #endif
             s3Config.SetRequestTimeoutMs(10000);
@@ -118,20 +119,14 @@ struct TTestSchema {
     };
 
     struct TTableSpecials : public TStorageTier {
-    private:
-        bool NeedTestStatisticsFlag = true;
     public:
         std::vector<TStorageTier> Tiers;
         bool WaitEmptyAfter = false;
 
         TTableSpecials() noexcept = default;
 
-        bool NeedTestStatistics() const {
-            return NeedTestStatisticsFlag;
-        }
-
-        void SetNeedTestStatistics(const bool value) {
-            NeedTestStatisticsFlag = value;
+        bool NeedTestStatistics(const std::vector<NArrow::NTest::TTestColumn>& pk) const {
+            return GetTtlColumn() != pk.front().GetName();
         }
 
         bool HasTiers() const {
@@ -161,6 +156,13 @@ struct TTestSchema {
             result << ";TTL=" << TStorageTier::DebugString();
             return result;
         }
+
+        TString GetTtlColumn() const {
+            for (const auto& tier : Tiers) {
+                UNIT_ASSERT_VALUES_EQUAL(tier.TtlColumn, TtlColumn);
+            }
+            return TtlColumn;
+        }
     };
     using TTestColumn = NArrow::NTest::TTestColumn;
     static auto YdbSchema(const TTestColumn& firstKeyItem = TTestColumn("timestamp", TTypeInfo(NTypeIds::Timestamp))) {
@@ -246,22 +248,25 @@ struct TTestSchema {
                            const TTableSpecials& specials,
                            NKikimrSchemeOp::TColumnTableSchema* schema);
 
-    static void InitTtl(const TTableSpecials& specials, NKikimrSchemeOp::TColumnDataLifeCycle::TTtl* ttl) {
-        Y_ABORT_UNLESS(specials.HasTtl());
-        Y_ABORT_UNLESS(!specials.TtlColumn.empty());
-        ttl->SetColumnName(specials.TtlColumn);
-        ttl->SetExpireAfterSeconds((*specials.EvictAfter).Seconds());
-    }
-
     static bool InitTiersAndTtl(const TTableSpecials& specials, NKikimrSchemeOp::TColumnDataLifeCycle* ttlSettings) {
         ttlSettings->SetVersion(1);
-        if (specials.HasTiers()) {
-            ttlSettings->SetUseTiering("Tiering1");
+        if (!specials.HasTiers() && !specials.HasTtl()) {
+            return false;
+        }
+        ttlSettings->MutableEnabled()->SetColumnName(specials.TtlColumn);
+        for (const auto& tier : specials.Tiers) {
+            UNIT_ASSERT(tier.EvictAfter);
+            UNIT_ASSERT_EQUAL(specials.TtlColumn, tier.TtlColumn);
+            auto* tierSettings = ttlSettings->MutableEnabled()->AddTiers();
+            tierSettings->MutableEvictToExternalStorage()->SetStorage(tier.Name);
+            tierSettings->SetApplyAfterSeconds(tier.EvictAfter->Seconds());
         }
         if (specials.HasTtl()) {
-            InitTtl(specials, ttlSettings->MutableEnabled());
+            auto* tier = ttlSettings->MutableEnabled()->AddTiers();
+            tier->MutableDelete();
+            tier->SetApplyAfterSeconds((*specials.EvictAfter).Seconds());
         }
-        return specials.HasTiers() || specials.HasTtl();
+        return true;
     }
 
     static TString CreateTableTxBody(ui64 pathId, const std::vector<NArrow::NTest::TTestColumn>& columns,
@@ -355,7 +360,7 @@ struct TTestSchema {
         return out;
     }
 
-    static NMetadata::NFetcher::ISnapshot::TPtr BuildSnapshot(const TTableSpecials& specials);
+    static THashMap<TString, NColumnShard::NTiers::TTierConfig> BuildSnapshot(const TTableSpecials& specials);
 
     static TString CommitTxBody(ui64, const std::vector<ui64>& writeIds) {
         NKikimrTxColumnShard::TCommitTxBody proto;
@@ -400,19 +405,20 @@ struct TTestSchema {
     }
 };
 
+void RefreshTiering(TTestBasicRuntime& runtime, const TActorId& sender);
+
 bool ProposeSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, NOlap::TSnapshot snap);
-void ProvideTieringSnapshot(TTestBasicRuntime& runtime, const TActorId& sender, NMetadata::NFetcher::ISnapshot::TPtr snapshot);
-void PlanSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot snap);
+void PlanSchemaTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap);
 
-void PlanWriteTx(TTestBasicRuntime& runtime, TActorId& sender, NOlap::TSnapshot snap, bool waitResult = true);
+void PlanWriteTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap, bool waitResult = true);
 
 bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId, const ui64 writeId, const ui64 tableId, const TString& data,
     const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, std::vector<ui64>* writeIds,
-    const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert);
+    const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert, const ui64 lockId = 1);
 
 bool WriteData(TTestBasicRuntime& runtime, TActorId& sender, const ui64 writeId, const ui64 tableId, const TString& data,
     const std::vector<NArrow::NTest::TTestColumn>& ydbSchema, bool waitResult = true, std::vector<ui64>* writeIds = nullptr,
-    const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert);
+    const NEvWrite::EModificationType mType = NEvWrite::EModificationType::Upsert, const ui64 lockId = 1);
 
 std::optional<ui64> WriteData(TTestBasicRuntime& runtime, TActorId& sender, const NLongTxService::TLongTxId& longTxId,
                               ui64 tableId, const ui64 writePartId, const TString& data,
@@ -423,8 +429,8 @@ ui32 WaitWriteResult(TTestBasicRuntime& runtime, ui64 shardId, std::vector<ui64>
 void ScanIndexStats(TTestBasicRuntime& runtime, TActorId& sender, const std::vector<ui64>& pathIds,
                     NOlap::TSnapshot snap, ui64 scanId = 0);
 
-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds);
-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds);
+void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId = 1);
+void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId = 1);
 
 void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 planStep, const TSet<ui64>& txIds);
 void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, const TSet<ui64>& txIds);
@@ -435,7 +441,7 @@ inline void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 planSt
     PlanCommit(runtime, sender, planStep, ids);
 }
 
-void Wakeup(TTestBasicRuntime& runtime, TActorId& sender, const ui64 shardId);
+void Wakeup(TTestBasicRuntime& runtime, const TActorId& sender, const ui64 shardId);
 
 struct TTestBlobOptions {
     THashSet<TString> NullColumns;
diff --git a/ydb/core/tx/columnshard/test_helper/controllers.cpp b/ydb/core/tx/columnshard/test_helper/controllers.cpp
index 997a700d901b..a9f1a877a13b 100644
--- a/ydb/core/tx/columnshard/test_helper/controllers.cpp
+++ b/ydb/core/tx/columnshard/test_helper/controllers.cpp
@@ -1,7 +1,8 @@
 #include "columnshard_ut_common.h"
 #include "controllers.h"
-#include <ydb/core/tx/columnshard/engines/changes/ttl.h>
+
 #include <ydb/core/tx/columnshard/engines/changes/indexation.h>
+#include <ydb/core/tx/columnshard/engines/changes/ttl.h>
 
 namespace NKikimr::NOlap {
 
@@ -10,13 +11,13 @@ void TWaitCompactionController::OnTieringModified(const std::shared_ptr<NKikimr:
     AFL_INFO(NKikimrServices::TX_COLUMNSHARD)("event", "OnTieringModified")("count", TiersModificationsCount);
 }
 
-void TWaitCompactionController::SetTiersSnapshot(TTestBasicRuntime& runtime, const TActorId& tabletActorId, const NMetadata::NFetcher::ISnapshot::TPtr& snapshot) {
-    CurrentConfig = snapshot;
+void TWaitCompactionController::OverrideTierConfigs(
+    TTestBasicRuntime& runtime, const TActorId& tabletActorId, THashMap<TString, NColumnShard::NTiers::TTierConfig> tiers) {
+    OverrideTiers = std::move(tiers);
     ui32 startCount = TiersModificationsCount;
-    NTxUT::ProvideTieringSnapshot(runtime, tabletActorId, snapshot);
+    NTxUT::RefreshTiering(runtime, tabletActorId);
     while (TiersModificationsCount == startCount) {
         runtime.SimulateSleep(TDuration::Seconds(1));
     }
 }
-
-}
\ No newline at end of file
+}   // namespace NKikimr::NOlap
diff --git a/ydb/core/tx/columnshard/test_helper/controllers.h b/ydb/core/tx/columnshard/test_helper/controllers.h
index 68cd6a1dc4ed..281058322ac7 100644
--- a/ydb/core/tx/columnshard/test_helper/controllers.h
+++ b/ydb/core/tx/columnshard/test_helper/controllers.h
@@ -1,6 +1,7 @@
 #pragma once
-#include <ydb/core/tx/columnshard/hooks/testing/controller.h>
 #include <ydb/core/testlib/basics/runtime.h>
+#include <ydb/core/tx/columnshard/hooks/testing/controller.h>
+#include <ydb/core/tx/tiering/manager.h>
 
 namespace NKikimr::NOlap {
 
@@ -8,11 +9,14 @@ class TWaitCompactionController: public NYDBTest::NColumnShard::TController {
 private:
     using TBase = NKikimr::NYDBTest::ICSController;
     TAtomicCounter ExportsFinishedCount = 0;
-    NMetadata::NFetcher::ISnapshot::TPtr CurrentConfig;
+    THashMap<TString, NColumnShard::NTiers::TTierConfig> OverrideTiers;
     ui32 TiersModificationsCount = 0;
+    YDB_READONLY(TAtomicCounter, TieringMetadataActualizationCount, 0);
     YDB_READONLY(TAtomicCounter, StatisticsUsageCount, 0);
     YDB_READONLY(TAtomicCounter, MaxValueUsageCount, 0);
     YDB_ACCESSOR_DEF(std::optional<ui64>, SmallSizeDetector);
+    YDB_ACCESSOR(bool, SkipSpecialCheckForEvict, false);
+
 protected:
     virtual void OnTieringModified(const std::shared_ptr<NKikimr::NColumnShard::TTiersManager>& /*tiers*/) override;
     virtual void OnExportFinished() override {
@@ -34,6 +38,15 @@ class TWaitCompactionController: public NYDBTest::NColumnShard::TController {
         return TDuration::Zero();
     }
 public:
+    virtual bool CheckPortionForEvict(const TPortionInfo& portion) const override {
+        if (SkipSpecialCheckForEvict) {
+            return true;
+        } else {
+            return TBase::CheckPortionForEvict(portion);
+        }
+    }
+
+
     TWaitCompactionController() {
         SetOverridePeriodicWakeupActivationPeriod(TDuration::Seconds(1));
     }
@@ -42,20 +55,20 @@ class TWaitCompactionController: public NYDBTest::NColumnShard::TController {
         return ExportsFinishedCount.Val();
     }
 
+    virtual void OnTieringMetadataActualized() override {
+        TieringMetadataActualizationCount.Inc();
+    }
     virtual void OnStatisticsUsage(const NKikimr::NOlap::NIndexes::TIndexMetaContainer& /*statOperator*/) override {
         StatisticsUsageCount.Inc();
     }
     virtual void OnMaxValueUsage() override {
         MaxValueUsageCount.Inc();
     }
-    void SetTiersSnapshot(TTestBasicRuntime& runtime, const TActorId& tabletActorId, const NMetadata::NFetcher::ISnapshot::TPtr& snapshot);
+    void OverrideTierConfigs(
+        TTestBasicRuntime& runtime, const TActorId& tabletActorId, THashMap<TString, NColumnShard::NTiers::TTierConfig> tiers);
 
-    virtual NMetadata::NFetcher::ISnapshot::TPtr GetFallbackTiersSnapshot() const override {
-        if (CurrentConfig) {
-            return CurrentConfig;
-        } else {
-            return TBase::GetFallbackTiersSnapshot();
-        }
+    THashMap<TString, NColumnShard::NTiers::TTierConfig> GetOverrideTierConfigs() const override {
+        return OverrideTiers;
     }
 };
 
diff --git a/ydb/core/tx/columnshard/test_helper/shard_reader.cpp b/ydb/core/tx/columnshard/test_helper/shard_reader.cpp
new file mode 100644
index 000000000000..6b3ce1a5a1b4
--- /dev/null
+++ b/ydb/core/tx/columnshard/test_helper/shard_reader.cpp
@@ -0,0 +1,101 @@
+#include "shard_reader.h"
+
+namespace NKikimr::NTxUT {
+
+std::unique_ptr<NKikimr::TEvDataShard::TEvKqpScan> TShardReader::BuildStartEvent() const {
+    auto ev = std::make_unique<TEvDataShard::TEvKqpScan>();
+    ev->Record.SetLocalPathId(PathId);
+    ev->Record.MutableSnapshot()->SetStep(Snapshot.GetPlanStep());
+    ev->Record.MutableSnapshot()->SetTxId(Snapshot.GetTxId());
+
+    ev->Record.SetStatsMode(NYql::NDqProto::DQ_STATS_MODE_FULL);
+    ev->Record.SetTxId(Snapshot.GetTxId());
+
+    ev->Record.SetReverse(Reverse);
+    ev->Record.SetItemsLimit(Limit);
+
+    ev->Record.SetDataFormat(NKikimrDataEvents::FORMAT_ARROW);
+
+    auto protoRanges = ev->Record.MutableRanges();
+    protoRanges->Reserve(Ranges.size());
+    for (auto& range : Ranges) {
+        auto newRange = protoRanges->Add();
+        range.Serialize(*newRange);
+    }
+
+    if (ProgramProto) {
+        NKikimrSSA::TOlapProgram olapProgram;
+        {
+            TString programBytes;
+            TStringOutput stream(programBytes);
+            ProgramProto->SerializeToArcadiaStream(&stream);
+            olapProgram.SetProgram(programBytes);
+        }
+        {
+            TString programBytes;
+            TStringOutput stream(programBytes);
+            olapProgram.SerializeToArcadiaStream(&stream);
+            ev->Record.SetOlapProgram(programBytes);
+        }
+        ev->Record.SetOlapProgramType(NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS);
+    } else if (SerializedProgram) {
+        ev->Record.SetOlapProgram(*SerializedProgram);
+        ev->Record.SetOlapProgramType(NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS);
+    }
+
+    return ev;
+}
+
+NKikimr::NTxUT::TShardReader& TShardReader::SetReplyColumns(const std::vector<TString>& replyColumns) {
+    AFL_VERIFY(!SerializedProgram);
+    if (!ProgramProto) {
+        ProgramProto = NKikimrSSA::TProgram();
+    }
+    for (auto&& command : *ProgramProto->MutableCommand()) {
+        if (command.HasProjection()) {
+            NKikimrSSA::TProgram::TProjection proj;
+            for (auto&& i : replyColumns) {
+                proj.AddColumns()->SetName(i);
+            }
+            *command.MutableProjection() = proj;
+            return *this;
+        }
+    }
+    {
+        auto* command = ProgramProto->AddCommand();
+        NKikimrSSA::TProgram::TProjection proj;
+        for (auto&& i : replyColumns) {
+            proj.AddColumns()->SetName(i);
+        }
+        *command->MutableProjection() = proj;
+    }
+    return *this;
+}
+
+NKikimr::NTxUT::TShardReader& TShardReader::SetReplyColumnIds(const std::vector<ui32>& replyColumnIds) {
+    AFL_VERIFY(!SerializedProgram);
+    if (!ProgramProto) {
+        ProgramProto = NKikimrSSA::TProgram();
+    }
+    for (auto&& command : *ProgramProto->MutableCommand()) {
+        if (command.HasProjection()) {
+            NKikimrSSA::TProgram::TProjection proj;
+            for (auto&& i : replyColumnIds) {
+                proj.AddColumns()->SetId(i);
+            }
+            *command.MutableProjection() = proj;
+            return *this;
+        }
+    }
+    {
+        auto* command = ProgramProto->AddCommand();
+        NKikimrSSA::TProgram::TProjection proj;
+        for (auto&& i : replyColumnIds) {
+            proj.AddColumns()->SetId(i);
+        }
+        *command->MutableProjection() = proj;
+    }
+    return *this;
+}
+
+}
diff --git a/ydb/core/tx/columnshard/test_helper/shard_reader.h b/ydb/core/tx/columnshard/test_helper/shard_reader.h
index 2beaa5a782d9..eb9f041062a6 100644
--- a/ydb/core/tx/columnshard/test_helper/shard_reader.h
+++ b/ydb/core/tx/columnshard/test_helper/shard_reader.h
@@ -28,53 +28,7 @@ class TShardReader {
     std::vector<TString> ReplyColumns;
     std::vector<TSerializedTableRange> Ranges;
 
-    std::unique_ptr<TEvDataShard::TEvKqpScan> BuildStartEvent() const {
-        auto ev = std::make_unique<TEvDataShard::TEvKqpScan>();
-        ev->Record.SetLocalPathId(PathId);
-        ev->Record.MutableSnapshot()->SetStep(Snapshot.GetPlanStep());
-        ev->Record.MutableSnapshot()->SetTxId(Snapshot.GetTxId());
-
-        ev->Record.SetStatsMode(NYql::NDqProto::DQ_STATS_MODE_FULL);
-        ev->Record.SetTxId(Snapshot.GetTxId());
-
-        ev->Record.SetReverse(Reverse);
-        ev->Record.SetItemsLimit(Limit);
-
-        ev->Record.SetDataFormat(NKikimrDataEvents::FORMAT_ARROW);
-
-        auto protoRanges = ev->Record.MutableRanges();
-        protoRanges->Reserve(Ranges.size());
-        for (auto& range : Ranges) {
-            auto newRange = protoRanges->Add();
-            range.Serialize(*newRange);
-        }
-
-        if (ProgramProto) {
-            NKikimrSSA::TOlapProgram olapProgram;
-            {
-                TString programBytes;
-                TStringOutput stream(programBytes);
-                ProgramProto->SerializeToArcadiaStream(&stream);
-                olapProgram.SetProgram(programBytes);
-            }
-            {
-                TString programBytes;
-                TStringOutput stream(programBytes);
-                olapProgram.SerializeToArcadiaStream(&stream);
-                ev->Record.SetOlapProgram(programBytes);
-            }
-            ev->Record.SetOlapProgramType(
-                NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS
-            );
-        } else if (SerializedProgram) {
-            ev->Record.SetOlapProgram(*SerializedProgram);
-            ev->Record.SetOlapProgramType(
-                NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS
-            );
-        }
-
-        return ev;
-    }
+    std::unique_ptr<TEvDataShard::TEvKqpScan> BuildStartEvent() const;
 
     std::vector<std::shared_ptr<arrow::RecordBatch>> ResultBatches;
     YDB_READONLY(ui32, IterationsCount, 0);
@@ -100,57 +54,9 @@ class TShardReader {
         return r ? r->num_rows() : 0;
     }
 
-    TShardReader& SetReplyColumns(const std::vector<TString>& replyColumns) {
-        AFL_VERIFY(!SerializedProgram);
-        if (!ProgramProto) {
-            ProgramProto = NKikimrSSA::TProgram();
-        }
-        for (auto&& command : *ProgramProto->MutableCommand()) {
-            if (command.HasProjection()) {
-                NKikimrSSA::TProgram::TProjection proj;
-                for (auto&& i : replyColumns) {
-                    proj.AddColumns()->SetName(i);
-                }
-                *command.MutableProjection() = proj;
-                return *this;
-            }
-        }
-        {
-            auto* command = ProgramProto->AddCommand();
-            NKikimrSSA::TProgram::TProjection proj;
-            for (auto&& i : replyColumns) {
-                proj.AddColumns()->SetName(i);
-            }
-            *command->MutableProjection() = proj;
-        }
-        return *this;
-    }
+    TShardReader& SetReplyColumns(const std::vector<TString>& replyColumns);
 
-    TShardReader& SetReplyColumnIds(const std::vector<ui32>& replyColumnIds) {
-        AFL_VERIFY(!SerializedProgram);
-        if (!ProgramProto) {
-            ProgramProto = NKikimrSSA::TProgram();
-        }
-        for (auto&& command : *ProgramProto->MutableCommand()) {
-            if (command.HasProjection()) {
-                NKikimrSSA::TProgram::TProjection proj;
-                for (auto&& i : replyColumnIds) {
-                    proj.AddColumns()->SetId(i);
-                }
-                *command.MutableProjection() = proj;
-                return *this;
-            }
-        }
-        {
-            auto* command = ProgramProto->AddCommand();
-            NKikimrSSA::TProgram::TProjection proj;
-            for (auto&& i : replyColumnIds) {
-                proj.AddColumns()->SetId(i);
-            }
-            *command->MutableProjection() = proj;
-        }
-        return *this;
-    }
+    TShardReader& SetReplyColumnIds(const std::vector<ui32>& replyColumnIds);
 
     TShardReader& SetProgram(const NKikimrSSA::TProgram& p) {
         AFL_VERIFY(!ProgramProto);
diff --git a/ydb/core/tx/columnshard/test_helper/shard_writer.cpp b/ydb/core/tx/columnshard/test_helper/shard_writer.cpp
new file mode 100644
index 000000000000..92e262d2f776
--- /dev/null
+++ b/ydb/core/tx/columnshard/test_helper/shard_writer.cpp
@@ -0,0 +1,63 @@
+#include "shard_writer.h"
+
+#include <ydb/core/formats/arrow/arrow_helpers.h>
+#include <ydb/core/testlib/tablet_helpers.h>
+#include <ydb/core/tx/columnshard/defs.h>
+#include <ydb/core/tx/data_events/events.h>
+#include <ydb/core/tx/data_events/payload_helper.h>
+
+namespace NKikimr::NTxUT {
+
+NKikimrDataEvents::TEvWriteResult::EStatus TShardWriter::StartCommit(const ui64 txId) {
+    auto evCommit = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>(txId, NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE);
+    evCommit->Record.MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Commit);
+    auto* lock = evCommit->Record.MutableLocks()->AddLocks();
+    lock->SetLockId(LockId);
+    ForwardToTablet(Runtime, TTestTxConfig::TxTablet0, Sender, evCommit.release());
+
+    TAutoPtr<NActors::IEventHandle> handle;
+    auto event = Runtime.GrabEdgeEvent<NKikimr::NEvents::TDataEvents::TEvWriteResult>(handle);
+    AFL_VERIFY(event);
+
+    return event->Record.GetStatus();
+}
+
+NKikimrDataEvents::TEvWriteResult::EStatus TShardWriter::Abort(const ui64 txId) {
+    auto evCommit = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>(txId, NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE);
+    evCommit->Record.MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Rollback);
+    auto* lock = evCommit->Record.MutableLocks()->AddLocks();
+    lock->SetLockId(LockId);
+    ForwardToTablet(Runtime, TTestTxConfig::TxTablet0, Sender, evCommit.release());
+
+    TAutoPtr<NActors::IEventHandle> handle;
+    auto event = Runtime.GrabEdgeEvent<NKikimr::NEvents::TDataEvents::TEvWriteResult>(handle);
+    AFL_VERIFY(event);
+
+    return event->Record.GetStatus();
+}
+
+NKikimrDataEvents::TEvWriteResult::EStatus TShardWriter::Write(
+    const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<ui32>& columnIds, const ui64 txId) {
+    TString blobData = NArrow::SerializeBatchNoCompression(batch);
+//    AFL_VERIFY(blobData.size() < NColumnShard::TLimits::GetMaxBlobSize());
+
+    auto evWrite = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>(NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE);
+    evWrite->SetTxId(txId);
+    evWrite->SetLockId(LockId, LockNodeId);
+    const ui64 payloadIndex = NEvWrite::TPayloadWriter<NKikimr::NEvents::TDataEvents::TEvWrite>(*evWrite).AddDataToPayload(std::move(blobData));
+    evWrite->AddOperation(NKikimrDataEvents::TEvWrite::TOperation::OPERATION_REPLACE, { OwnerId, PathId, SchemaVersion }, columnIds,
+        payloadIndex, NKikimrDataEvents::FORMAT_ARROW);
+
+    ForwardToTablet(Runtime, TabletId, Sender, evWrite.release());
+
+    TAutoPtr<NActors::IEventHandle> handle;
+    auto event = Runtime.GrabEdgeEvent<NKikimr::NEvents::TDataEvents::TEvWriteResult>(handle);
+    AFL_VERIFY(event);
+
+    AFL_VERIFY(event->Record.GetOrigin() == TabletId);
+    AFL_VERIFY(event->Record.GetTxId() == LockId);
+
+    return event->Record.GetStatus();
+}
+
+}   // namespace NKikimr::NTxUT
diff --git a/ydb/core/tx/columnshard/test_helper/shard_writer.h b/ydb/core/tx/columnshard/test_helper/shard_writer.h
new file mode 100644
index 000000000000..b43e9749a69b
--- /dev/null
+++ b/ydb/core/tx/columnshard/test_helper/shard_writer.h
@@ -0,0 +1,43 @@
+#pragma once
+#include <ydb/core/protos/data_events.pb.h>
+#include <ydb/core/testlib/basics/runtime.h>
+
+#include <ydb/library/accessor/accessor.h>
+
+#include <contrib/libs/apache/arrow/cpp/src/arrow/record_batch.h>
+
+namespace NKikimr::NTxUT {
+
+class TShardWriter {
+private:
+    TTestBasicRuntime& Runtime;
+    const ui64 TabletId;
+    const ui64 PathId;
+    const ui64 LockId;
+    YDB_ACCESSOR(ui64, SchemaVersion, 1);
+    YDB_ACCESSOR(ui64, OwnerId, 0);
+    YDB_ACCESSOR(ui64, LockNodeId, 1);
+    const TActorId Sender;
+
+public:
+    TShardWriter(TTestBasicRuntime& runtime, const ui64 tabletId, const ui64 pathId, const ui64 lockId)
+        : Runtime(runtime)
+        , TabletId(tabletId)
+        , PathId(pathId)
+        , LockId(lockId)
+        , Sender(Runtime.AllocateEdgeActor())
+    {
+    }
+
+    const TActorId& GetSender() const {
+        return Sender;
+    }
+
+    [[nodiscard]] NKikimrDataEvents::TEvWriteResult::EStatus StartCommit(const ui64 txId);
+    [[nodiscard]] NKikimrDataEvents::TEvWriteResult::EStatus Abort(const ui64 txId);
+
+    [[nodiscard]] NKikimrDataEvents::TEvWriteResult::EStatus Write(
+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<ui32>& columnIds, const ui64 txId);
+};
+
+}   // namespace NKikimr::NTxUT
diff --git a/ydb/core/tx/columnshard/test_helper/ya.make b/ydb/core/tx/columnshard/test_helper/ya.make
index cab4937293dd..d4b96709720b 100644
--- a/ydb/core/tx/columnshard/test_helper/ya.make
+++ b/ydb/core/tx/columnshard/test_helper/ya.make
@@ -14,6 +14,8 @@ SRCS(
     helper.cpp
     controllers.cpp
     columnshard_ut_common.cpp
+    shard_reader.cpp
+    shard_writer.cpp
 )
 
 IF (OS_WINDOWS)
diff --git a/ydb/tests/olap/scenario/helpers/scenario_tests_helper.py b/ydb/tests/olap/scenario/helpers/scenario_tests_helper.py
index ad1cab7da4db..910324b1f5bf 100644
--- a/ydb/tests/olap/scenario/helpers/scenario_tests_helper.py
+++ b/ydb/tests/olap/scenario/helpers/scenario_tests_helper.py
@@ -369,6 +369,26 @@ def execute_scan_query(
         allure.attach(json.dumps(rows), 'result', allure.attachment_type.JSON)
         return ret
 
+    @allure.step('Execute query')
+    def execute_query(
+        self, yql: str, expected_status: ydb.StatusCode | Set[ydb.StatusCode] = ydb.StatusCode.SUCCESS
+    ):
+        """Run a query on the tested database.
+
+        Args:
+            yql: Query text.
+            expected_status: Expected status or set of database response statuses. If the response status is not in the expected set, an exception is thrown.
+
+        Example:
+            tablename = 'testTable'
+            sth = ScenarioTestHelper(ctx)
+            sth.execute_query(f'INSERT INTO `{sth.get_full_path("tablename") }` (key, c) values(1, 100)')
+        """
+
+        allure.attach(yql, 'request', allure.attachment_type.TEXT)
+        with ydb.QuerySessionPool(YdbCluster.get_ydb_driver()) as pool:
+            self._run_with_expected_status(lambda: pool.execute_with_retries(yql), expected_status)
+
     def drop_if_exist(self, names: List[str], operation) -> None:
         """Erase entities in the tested database, if it exists.
 
@@ -560,15 +580,18 @@ def list_path(self, path: str) -> List[ydb.SchemeEntry]:
         """
 
         root_path = self.get_full_path('')
-        result = []
-        self_descr = self._describe_path_impl(os.path.join(root_path, path))
-        if self_descr is not None:
-            self_descr.name = path
-            if self_descr.is_directory():
-                result = self._list_directory_impl(root_path, path)
-            result.append(self_descr)
-        allure.attach('
'.join([f'{e.name}: {repr(e.type)}' for e in result]), 'result', allure.attachment_type.TEXT)
-        return result
+        try:
+            self_descr = YdbCluster._describe_path_impl(os.path.join(root_path, path))
+        except ydb.issues.SchemeError:
+            return []
+
+        if self_descr is None:
+            return []
+
+        if self_descr.is_directory():
+            return list(reversed(YdbCluster.list_directory(root_path, path))) + [self_descr]
+        else:
+            return self_descr
 
     @allure.step('Remove path {path}')
     def remove_path(self, path: str) -> None:
diff --git a/ydb/tests/olap/scenario/test_insert.py b/ydb/tests/olap/scenario/test_insert.py
new file mode 100644
index 000000000000..ea9b6aaac86b
--- /dev/null
+++ b/ydb/tests/olap/scenario/test_insert.py
@@ -0,0 +1,87 @@
+from conftest import BaseTestSet
+from ydb.tests.olap.scenario.helpers import (
+    ScenarioTestHelper,
+    TestContext,
+    CreateTable,
+)
+
+from ydb import PrimitiveType
+from typing import List, Dict, Any
+from ydb.tests.olap.lib.utils import get_external_param
+import threading
+
+
+class TestInsert(BaseTestSet):
+    schema_cnt = (
+        ScenarioTestHelper.Schema()
+        .with_column(name="key", type=PrimitiveType.Int32, not_null=True)
+        .with_column(name="c", type=PrimitiveType.Int64)
+        .with_key_columns("key")
+    )
+
+    schema_log = (
+        ScenarioTestHelper.Schema()
+        .with_column(name="key", type=PrimitiveType.Int32, not_null=True)
+        .with_key_columns("key")
+    )
+
+    def _loop_upsert(self, ctx: TestContext, data: list):
+        sth = ScenarioTestHelper(ctx)
+        for batch in data:
+            sth.bulk_upsert_data("log", self.schema_log, batch)
+
+    def _loop_insert(self, ctx: TestContext, rows_count: int):
+        sth = ScenarioTestHelper(ctx)
+        log: str = sth.get_full_path("log")
+        cnt: str = sth.get_full_path("cnt")
+        for i in range(rows_count):
+            sth.execute_query(
+                f'$cnt = SELECT CAST(COUNT(*) AS INT64) from `{log}`; INSERT INTO `{cnt}` (key, c) values({i}, $cnt)'
+            )
+
+    def scenario_read_data_during_bulk_upsert(self, ctx: TestContext):
+        sth = ScenarioTestHelper(ctx)
+        cnt_table_name: str = "cnt"
+        log_table_name: str = "log"
+        batches_count = int(get_external_param("batches_count", "10"))
+        rows_count = int(get_external_param("rows_count", "1000"))
+        inserts_count = int(get_external_param("inserts_count", "200"))
+        sth.execute_scheme_query(
+            CreateTable(cnt_table_name).with_schema(self.schema_cnt)
+        )
+        sth.execute_scheme_query(
+            CreateTable(log_table_name).with_schema(self.schema_log)
+        )
+        data: List = []
+        for i in range(batches_count):
+            batch: List[Dict[str, Any]] = []
+            for j in range(rows_count):
+                batch.append({"key": j + rows_count * i})
+            data.append(batch)
+
+        thread1 = threading.Thread(target=self._loop_upsert, args=[ctx, data])
+        thread2 = threading.Thread(target=self._loop_insert, args=[ctx, inserts_count])
+
+        thread1.start()
+        thread2.start()
+
+        thread2.join()
+        thread1.join()
+
+        rows: int = sth.get_table_rows_count(cnt_table_name)
+        assert rows == inserts_count
+        scan_result = sth.execute_scan_query(
+            f"SELECT key, c FROM `{sth.get_full_path(cnt_table_name)}` ORDER BY key"
+        )
+        for i in range(rows):
+            if scan_result.result_set.rows[i]["key"] != i:
+                assert False, f"{i} ?= {scan_result.result_set.rows[i]['key']}"
+
+        rows: int = sth.get_table_rows_count(log_table_name)
+        assert rows == rows_count * batches_count
+        scan_result = sth.execute_scan_query(
+            f"SELECT key FROM `{sth.get_full_path(log_table_name)}` ORDER BY key"
+        )
+        for i in range(rows):
+            if scan_result.result_set.rows[i]["key"] != i:
+                assert False, f"{i} ?= {scan_result.result_set.rows[i]['key']}"
diff --git a/ydb/tests/olap/scenario/test_scheme_load.py b/ydb/tests/olap/scenario/test_scheme_load.py
index b3e0dfebd35d..4a4cb5bde323 100644
--- a/ydb/tests/olap/scenario/test_scheme_load.py
+++ b/ydb/tests/olap/scenario/test_scheme_load.py
@@ -44,7 +44,7 @@ def _drop_tables(self, prefix: str, count: int, ctx: TestContext):
             sth.execute_scheme_query(DropTable(f'store/{prefix}_{i}'))
 
     def scenario_create_and_drop_tables(self, ctx: TestContext):
-        tables_count = 100000
+        tables_count = 100
         threads_count = 20
 
         ScenarioTestHelper(ctx).execute_scheme_query(CreateTableStore('store').with_schema(self.schema1))
diff --git a/ydb/tests/olap/scenario/ya.make b/ydb/tests/olap/scenario/ya.make
index 58a33a89fdba..074086b186e0 100644
--- a/ydb/tests/olap/scenario/ya.make
+++ b/ydb/tests/olap/scenario/ya.make
@@ -12,6 +12,7 @@ PY3TEST()
         test_simple.py
         test_scheme_load.py
         test_alter_tiering.py
+        test_insert.py
     )
 
     PEERDIR(
