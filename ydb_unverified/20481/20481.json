{
  "repo": "ydb-platform/ydb",
  "pull_number": 20481,
  "instance_id": "ydb-platform__ydb-20481",
  "issue_numbers": [
    "20518"
  ],
  "base_commit": "7dac338db3e4eb7a54ebcc998d731f5750ce19ef",
  "patch": "diff --git a/ydb/core/blobstorage/base/blobstorage_events.h b/ydb/core/blobstorage/base/blobstorage_events.h\nindex 7fa6f4f29daa..9fed8a11d789 100644\n--- a/ydb/core/blobstorage/base/blobstorage_events.h\n+++ b/ydb/core/blobstorage/base/blobstorage_events.h\n@@ -4,6 +4,7 @@\n #include \"blobstorage_vdiskid.h\"\n #include <ydb/core/base/blobstorage.h>\n #include <ydb/core/base/bridge.h>\n+#include <ydb/core/blobstorage/base/blobstorage_host_record.h>\n #include <ydb/core/blobstorage/groupinfo/blobstorage_groupinfo.h>\n #include <ydb/core/blobstorage/pdisk/blobstorage_pdisk_config.h>\n #include <ydb/core/blobstorage/pdisk/blobstorage_pdisk_defs.h>\n@@ -225,7 +226,7 @@ namespace NKikimr {\n     {\n         bool SelfHeal = false;\n         bool GroupLayoutSanitizer = false;\n-\n+        std::optional<NBsController::THostRecordMap> EnforceHostRecords;\n         TEvControllerConfigRequest() = default;\n     };\n \ndiff --git a/ydb/core/blobstorage/base/blobstorage_host_record.h b/ydb/core/blobstorage/base/blobstorage_host_record.h\nnew file mode 100644\nindex 000000000000..205729333436\n--- /dev/null\n+++ b/ydb/core/blobstorage/base/blobstorage_host_record.h\n@@ -0,0 +1,100 @@\n+#pragma once\n+\n+#include <ydb/core/base/defs.h>\n+#include <ydb/core/base/blobstorage.h>\n+#include <ydb/core/protos/blobstorage.pb.h>\n+#include <ydb/core/protos/blobstorage_distributed_config.pb.h>\n+#include <ydb/library/actors/core/interconnect.h>\n+#include <util/generic/hash_multi_map.h>\n+\n+namespace NKikimr {\n+namespace NBsController {\n+\n+    using TNodeId = ui32;\n+\n+    struct THostRecord {\n+        TNodeId NodeId;\n+        TNodeLocation Location;\n+\n+        THostRecord(const TEvInterconnect::TNodeInfo& nodeInfo)\n+            : NodeId(nodeInfo.NodeId)\n+            , Location(nodeInfo.Location)\n+        {}\n+\n+        THostRecord(const NKikimrBlobStorage::TNodeIdentifier& node)\n+            : NodeId(node.GetNodeId())\n+            , Location(node.GetLocation())\n+        {}\n+    };\n+\n+    class THostRecordMapImpl {\n+        using THostId = std::tuple<TString, i32>;\n+\n+        THashMap<THostId, THostRecord> HostIdToRecord;\n+        THashMap<TNodeId, THostId> NodeIdToHostId;\n+        THashMultiMap<TString, TNodeId> FqdnToNodeId;\n+\n+    public:\n+        THostRecordMapImpl() = default;\n+\n+        THostRecordMapImpl(TEvInterconnect::TEvNodesInfo *msg) {\n+            for (const TEvInterconnect::TNodeInfo& nodeInfo : msg->Nodes) {\n+                const THostId hostId(nodeInfo.Host, nodeInfo.Port);\n+                NodeIdToHostId.emplace(nodeInfo.NodeId, hostId);\n+                HostIdToRecord.emplace(hostId, nodeInfo);\n+                FqdnToNodeId.emplace(nodeInfo.Host, nodeInfo.NodeId);\n+            }\n+        }\n+\n+        THostRecordMapImpl(const NKikimrBlobStorage::TStorageConfig& config) {\n+            for (const auto& item : config.GetAllNodes()) {\n+                const THostId hostId(item.GetHost(), item.GetPort());\n+                const TNodeId nodeId = item.GetNodeId();\n+                NodeIdToHostId.emplace(nodeId, hostId);\n+                HostIdToRecord.emplace(hostId, item);\n+                FqdnToNodeId.emplace(item.GetHost(), nodeId);\n+            }\n+        }\n+\n+        const TNodeLocation& GetLocation(TNodeId nodeId) const {\n+            if (auto it = NodeIdToHostId.find(nodeId); it != NodeIdToHostId.end()) {\n+                if (auto hostIt = HostIdToRecord.find(it->second); hostIt != HostIdToRecord.end()) {\n+                    return hostIt->second.Location;\n+                }\n+            }\n+            Y_ABORT();\n+        }\n+\n+        TMaybe<TNodeId> ResolveNodeId(const THostId& hostId) const {\n+            if (const auto it = HostIdToRecord.find(hostId); it != HostIdToRecord.end()) {\n+                return it->second.NodeId;\n+            } else {\n+                return {};\n+            }\n+        }\n+\n+        TMaybe<THostId> GetHostId(TNodeId nodeId) const {\n+            if (const auto it = NodeIdToHostId.find(nodeId); it != NodeIdToHostId.end()) {\n+                return it->second;\n+            } else {\n+                return {};\n+            }\n+        }\n+\n+        auto ResolveNodeId(const TString& fqdn) const {\n+            return FqdnToNodeId.equal_range(fqdn);\n+        }\n+\n+        auto begin() const {\n+            return HostIdToRecord.begin();\n+        }\n+\n+        auto end() const {\n+            return HostIdToRecord.end();\n+        }\n+    };\n+\n+    using THostRecordMap = std::shared_ptr<THostRecordMapImpl>;\n+\n+} // NBsController\n+} // NKikimr\ndiff --git a/ydb/core/blobstorage/base/ya.make b/ydb/core/blobstorage/base/ya.make\nindex 4b8cb5ddd708..b7fc88bd39d4 100644\n--- a/ydb/core/blobstorage/base/ya.make\n+++ b/ydb/core/blobstorage/base/ya.make\n@@ -12,6 +12,7 @@ SRCS(\n     batched_vec.h\n     blobstorage_events.cpp\n     blobstorage_events.h\n+    blobstorage_host_record.h\n     blobstorage_oos_defs.h\n     blobstorage_vdiskid.cpp\n     blobstorage_vdiskid.h\ndiff --git a/ydb/core/mind/bscontroller/bsc.cpp b/ydb/core/mind/bscontroller/bsc.cpp\nindex 8f46da5e9c8d..983d58a68cca 100644\n--- a/ydb/core/mind/bscontroller/bsc.cpp\n+++ b/ydb/core/mind/bscontroller/bsc.cpp\n@@ -8,6 +8,10 @@\n #include \"group_layout_checker.h\"\n #include \"util.h\"\n \n+#include <ydb/core/blobstorage/nodewarden/distconf.h>\n+#include <ydb/core/blobstorage/nodewarden/node_warden_impl.h>\n+#include <ydb/library/yaml_config/public/yaml_config.h>\n+\n #include <library/cpp/streams/zstd/zstd.h>\n \n namespace NKikimr {\n@@ -420,47 +424,14 @@ void TBlobStorageController::ApplyBscSettings(const NKikimrConfig::TBlobStorageC\n     Send(SelfId(), ev.release());\n }\n \n-void TBlobStorageController::ApplyStorageConfig(bool ignoreDistconf) {\n-    InvokeOnRootTimer.Reset();\n-    InvokeOnRootCmd.reset();\n-\n-    if (StorageConfig->HasClusterStateDetails()) {\n-        for (const auto& unsynced : StorageConfig->GetClusterStateDetails().GetPileSyncState()) {\n-            if (unsynced.GetUnsyncedBSC()) {\n-                auto ev = std::make_unique<NStorage::TEvNodeConfigInvokeOnRoot>();\n-                auto& record = ev->Record;\n-                auto *nbsf = record.MutableNotifyBridgeSyncFinished();\n-                nbsf->SetGeneration(StorageConfig->GetClusterState().GetGeneration());\n-                nbsf->SetBridgePileId(unsynced.GetBridgePileId());\n-                using TQuery = NKikimrBlobStorage::TEvNodeConfigInvokeOnRoot::TNotifyBridgeSyncFinished;\n-                nbsf->SetStatus(TQuery::Success);\n-                nbsf->SetBSC(true);\n-                for (const auto& [groupId, info] : GroupMap) {\n-                    if (info->BridgeGroupInfo) {\n-                        groupId.CopyToProto(nbsf, &TQuery::AddUnsyncedGroupIdsToAdd);\n-                    }\n-                }\n-                // remember the command in case it fails\n-                InvokeOnRootCmd.emplace(record);\n-                Send(MakeBlobStorageNodeWardenID(SelfId().NodeId()), ev.release());\n-            }\n-        }\n-    }\n-\n-    if (!StorageConfig->HasBlobStorageConfig()) {\n-        return;\n-    }\n-    const auto& bsConfig = StorageConfig->GetBlobStorageConfig();\n-\n-    ApplyBscSettings(bsConfig);\n+std::unique_ptr<TEvBlobStorage::TEvControllerConfigRequest> TBlobStorageController::BuildConfigRequestFromStorageConfig(\n+        const NKikimrBlobStorage::TStorageConfig& storageConfig, const THostRecordMap& hostRecords, bool validationMode) {\n \n-    if (Boxes.size() > 1) {\n-        return;\n+    if (Boxes.size() > 1 || !storageConfig.HasBlobStorageConfig()) {\n+        return nullptr;\n     }\n \n-    if (!ignoreDistconf && (!SelfManagementEnabled || !StorageConfig->GetSelfManagementConfig().GetAutomaticBoxManagement())) {\n-        return; // not expected to be managed by BSC\n-    }\n+    const auto& bsConfig = storageConfig.GetBlobStorageConfig();\n \n     ui64 expectedBoxId = 1;\n     std::optional<ui64> generation;\n@@ -480,7 +451,7 @@ void TBlobStorageController::ApplyStorageConfig(bool ignoreDistconf) {\n \n         // drop matching entries from the new set\n         for (const auto& host : bsConfig.GetDefineBox().GetHost()) {\n-            const auto& resolved = HostRecords->GetHostId(host.GetEnforcedNodeId());\n+            const auto& resolved = hostRecords->GetHostId(host.GetEnforcedNodeId());\n             Y_ABORT_UNLESS(resolved);\n             const auto& [fqdn, port] = *resolved;\n \n@@ -498,6 +469,11 @@ void TBlobStorageController::ApplyStorageConfig(bool ignoreDistconf) {\n     auto ev = std::make_unique<TEvBlobStorage::TEvControllerConfigRequest>();\n     auto& r = ev->Record;\n     auto *request = r.MutableRequest();\n+\n+    if (validationMode) {\n+        ev->EnforceHostRecords.emplace(hostRecords);\n+    }\n+\n     for (const auto& hostConfig : bsConfig.GetDefineHostConfig()) {\n         const auto it = HostConfigs.find(hostConfig.GetHostConfigId());\n         if (it != HostConfigs.end() && HostConfigEquals(it->second, hostConfig)) {\n@@ -521,7 +497,7 @@ void TBlobStorageController::ApplyStorageConfig(bool ignoreDistconf) {\n             const ui32 nodeId = host.GetEnforcedNodeId();\n             host.ClearEnforcedNodeId();\n             auto *key = host.MutableKey();\n-            const auto& resolved = HostRecords->GetHostId(nodeId);\n+            const auto& resolved = hostRecords->GetHostId(nodeId);\n             Y_ABORT_UNLESS(resolved);\n             const auto& [fqdn, port] = *resolved;\n             key->SetFqdn(fqdn);\n@@ -546,8 +522,57 @@ void TBlobStorageController::ApplyStorageConfig(bool ignoreDistconf) {\n         del->SetItemConfigGeneration(generation);\n     }\n \n+    if (validationMode) {\n+        request->SetRollback(true);\n+    }\n+\n     if (request->CommandSize()) {\n-        STLOG(PRI_DEBUG, BS_CONTROLLER, BSC14, \"ApplyStorageConfig\", (Request, r));\n+        return ev;\n+    }\n+\n+    return nullptr;\n+}\n+\n+void TBlobStorageController::ApplyStorageConfig(bool ignoreDistconf) {\n+    InvokeOnRootTimer.Reset();\n+    InvokeOnRootCmd.reset();\n+\n+    if (StorageConfig->HasClusterStateDetails()) {\n+        for (const auto& unsynced : StorageConfig->GetClusterStateDetails().GetPileSyncState()) {\n+            if (unsynced.GetUnsyncedBSC()) {\n+                auto ev = std::make_unique<NStorage::TEvNodeConfigInvokeOnRoot>();\n+                auto& record = ev->Record;\n+                auto *nbsf = record.MutableNotifyBridgeSyncFinished();\n+                nbsf->SetGeneration(StorageConfig->GetClusterState().GetGeneration());\n+                nbsf->SetBridgePileId(unsynced.GetBridgePileId());\n+                using TQuery = NKikimrBlobStorage::TEvNodeConfigInvokeOnRoot::TNotifyBridgeSyncFinished;\n+                nbsf->SetStatus(TQuery::Success);\n+                nbsf->SetBSC(true);\n+                for (const auto& [groupId, info] : GroupMap) {\n+                    if (info->BridgeGroupInfo) {\n+                        groupId.CopyToProto(nbsf, &TQuery::AddUnsyncedGroupIdsToAdd);\n+                    }\n+                }\n+                // remember the command in case it fails\n+                InvokeOnRootCmd.emplace(record);\n+                Send(MakeBlobStorageNodeWardenID(SelfId().NodeId()), ev.release());\n+            }\n+        }\n+    }\n+\n+    if (!StorageConfig->HasBlobStorageConfig()) {\n+        return;\n+    }\n+    const auto& bsConfig = StorageConfig->GetBlobStorageConfig();\n+\n+    ApplyBscSettings(bsConfig);\n+\n+    if (!ignoreDistconf && (!SelfManagementEnabled || !StorageConfig->GetSelfManagementConfig().GetAutomaticBoxManagement())) {\n+        return; // not expected to be managed by BSC\n+    }\n+\n+    if (auto ev = BuildConfigRequestFromStorageConfig(*StorageConfig, HostRecords, false)) {\n+        STLOG(PRI_DEBUG, BS_CONTROLLER, BSC14, \"ApplyStorageConfig\", (Request, ev->Record));\n         Send(SelfId(), ev.release());\n     }\n }\n@@ -571,6 +596,60 @@ void TBlobStorageController::Handle(NStorage::TEvNodeConfigInvokeOnRootResult::T\n }\n \n void TBlobStorageController::Handle(TEvBlobStorage::TEvControllerConfigResponse::TPtr ev) {\n+    if (const auto it = PendingValidationRequests.find(ev->Cookie); it != PendingValidationRequests.end()) {\n+        auto req = std::move(it->second);\n+        PendingValidationRequests.erase(it);\n+\n+        const auto& resp = ev->Get()->Record.GetResponse();\n+        const bool rollbackSuccess = resp.GetRollbackSuccess();\n+        TString errorReason;\n+        if (!rollbackSuccess) {\n+            TStringStream s;\n+            s << resp.GetErrorDescription();\n+            for (const auto& group : resp.GetGroupsGetDegraded()) {\n+                s << \" GroupGetDegraded# \" << group;\n+            }\n+            for (const auto& group : resp.GetGroupsGetDisintegrated()) {\n+                s << \" GroupGetDisintegrated# \" << group;\n+            }\n+            for (const auto& group : resp.GetGroupsGetDisintegratedByExpectedStatus()) {\n+                s << \" GroupGetDisintegratedByExpectedStatus# \" << group;\n+            }\n+            errorReason = s.Str();\n+        }\n+\n+        switch (req.Source) {\n+            case TConfigValidationInfo::ESource::Distconf: {\n+                auto response = std::make_unique<TEvBlobStorage::TEvControllerDistconfResponse>();\n+                auto& record = response->Record;\n+\n+                if (rollbackSuccess) {\n+                    record.SetStatus(NKikimrBlobStorage::TEvControllerDistconfResponse::OK);\n+                } else {\n+                    record.SetStatus(NKikimrBlobStorage::TEvControllerDistconfResponse::Error);\n+                    record.SetErrorReason(errorReason);\n+                }\n+\n+                auto h = std::make_unique<IEventHandle>(req.Sender, SelfId(), response.release(), 0, req.Cookie);\n+                if (req.InterconnectSession) {\n+                    h->Rewrite(TEvInterconnect::EvForward, req.InterconnectSession);\n+                }\n+                TActivationContext::Send(h.release());\n+                break;\n+            }\n+\n+            case TConfigValidationInfo::ESource::ConsoleInteraction:\n+                if (!ConsoleInteraction) {\n+                    STLOG(PRI_ERROR, BS_CONTROLLER, BSC38, \"Received console interaction validation response, but ConsoleInteraction is not set\");\n+                    return;\n+                }\n+                ConsoleInteraction->ProcessDryRunResponse(rollbackSuccess, std::move(errorReason));\n+                break;\n+        }\n+\n+        return;\n+    }\n+\n     auto& record = ev->Get()->Record;\n     auto& response = record.GetResponse();\n     STLOG(response.GetSuccess() ? PRI_DEBUG : PRI_ERROR, BS_CONTROLLER, BSC15, \"TEvControllerConfigResponse\",\n@@ -646,8 +725,48 @@ void TBlobStorageController::Handle(TEvBlobStorage::TEvControllerDistconfRequest\n             break;\n         }\n \n-        case NKikimrBlobStorage::TEvControllerDistconfRequest::ValidateConfig:\n+        case NKikimrBlobStorage::TEvControllerDistconfRequest::ValidateConfig: {\n+            if (!mainYaml) {\n+                rr.SetStatus(NKikimrBlobStorage::TEvControllerDistconfResponse::Error);\n+                rr.SetErrorReason(\"missing main config yaml while validating distconf\");\n+                break;\n+            }\n+\n+            const TString& effectiveConfig = storageYaml ? *storageYaml : *mainYaml;\n+            NKikimrBlobStorage::TStorageConfig storageConfig;\n+\n+            try {\n+                NKikimrConfig::TAppConfig appConfig = NYaml::Parse(effectiveConfig);\n+                TString errorReason;\n+                if (!NKikimr::NStorage::DeriveStorageConfig(appConfig, &storageConfig, &errorReason)) {\n+                    rr.SetStatus(NKikimrBlobStorage::TEvControllerDistconfResponse::Error);\n+                    rr.SetErrorReason(\"failed to derive storage config: \" + errorReason);\n+                    break;\n+                }\n+            } catch (const std::exception& ex) {\n+                rr.SetStatus(NKikimrBlobStorage::TEvControllerDistconfResponse::Error);\n+                rr.SetErrorReason(TStringBuilder() << \"failed to parse YAML: \" << ex.what());\n+                break;\n+            }\n+\n+            const ui64 cookie = NextValidationCookie++;\n+            PendingValidationRequests.emplace(cookie, TConfigValidationInfo{\n+                .Sender = ev->Sender,\n+                .Cookie = ev->Cookie,\n+                .InterconnectSession = ev->InterconnectSession,\n+                .Source = TConfigValidationInfo::ESource::Distconf,\n+            });\n+\n+            auto tempHostRecords = std::make_shared<THostRecordMap::element_type>(storageConfig);\n+            if (auto ev = BuildConfigRequestFromStorageConfig(storageConfig, tempHostRecords, true)) {\n+                Send(SelfId(), ev.release(), 0, cookie);\n+                return;\n+            } else {\n+                rr.SetStatus(NKikimrBlobStorage::TEvControllerDistconfResponse::OK);\n+                PendingValidationRequests.erase(cookie);\n+            }\n             break;\n+        }\n     }\n \n     if (putConfigs) {\ndiff --git a/ydb/core/mind/bscontroller/config_cmd.cpp b/ydb/core/mind/bscontroller/config_cmd.cpp\nindex ddfd71417969..e68efd0f6323 100644\n--- a/ydb/core/mind/bscontroller/config_cmd.cpp\n+++ b/ydb/core/mind/bscontroller/config_cmd.cpp\n@@ -12,21 +12,24 @@ namespace NKikimr::NBsController {\n             const NKikimrBlobStorage::TConfigRequest Cmd;\n             const bool SelfHeal;\n             const bool GroupLayoutSanitizer;\n+            std::optional<THostRecordMap> EnforceHostRecords;\n             THolder<TEvBlobStorage::TEvControllerConfigResponse> Ev;\n             NKikimrBlobStorage::TConfigResponse *Response;\n             std::optional<TConfigState> State;\n             bool Success = true;\n+            bool RollbackSuccess = false;\n             TString Error;\n \n         public:\n             TTxConfigCmd(const NKikimrBlobStorage::TConfigRequest &cmd, const TActorId &notifyId, ui64 cookie,\n-                    bool selfHeal, bool groupLayoutSanitizer, TBlobStorageController *controller)\n+                    bool selfHeal, bool groupLayoutSanitizer, std::optional<THostRecordMap> enforceHostRecords, TBlobStorageController *controller)\n                 : TTransactionBase(controller)\n                 , NotifyId(notifyId)\n                 , Cookie(cookie)\n                 , Cmd(cmd)\n                 , SelfHeal(selfHeal)\n                 , GroupLayoutSanitizer(groupLayoutSanitizer)\n+                , EnforceHostRecords(std::move(enforceHostRecords))\n                 , Ev(new TEvBlobStorage::TEvControllerConfigResponse())\n                 , Response(Ev->Record.MutableResponse())\n             {}\n@@ -52,6 +55,7 @@ namespace NKikimr::NBsController {\n \n             void Finish() {\n                 Response->SetSuccess(Success);\n+                Response->SetRollbackSuccess(RollbackSuccess);\n                 if (!Success) {\n                     Response->SetErrorDescription(Error);\n                 }\n@@ -180,7 +184,8 @@ namespace NKikimr::NBsController {\n                     Response->MutableStatus()->RemoveLast();\n                 }\n \n-                State.emplace(*Self, Self->HostRecords, TActivationContext::Now(), TActivationContext::Monotonic());\n+                const auto& hostRecords = EnforceHostRecords ? *EnforceHostRecords : Self->HostRecords;\n+                State.emplace(*Self, hostRecords, TActivationContext::Now(), TActivationContext::Monotonic());\n                 State->CheckConsistency();\n \n                 TString m;\n@@ -256,6 +261,7 @@ namespace NKikimr::NBsController {\n \n                 if (Success && Cmd.GetRollback()) {\n                     Success = false;\n+                    RollbackSuccess = true;\n                     Error = \"transaction rollback\";\n                 }\n \n@@ -401,7 +407,7 @@ namespace NKikimr::NBsController {\n             NKikimrBlobStorage::TEvControllerConfigRequest& record(ev->Get()->Record);\n             const NKikimrBlobStorage::TConfigRequest& request = record.GetRequest();\n             STLOG(PRI_DEBUG, BS_CONTROLLER, BSCTXCC01, \"Execute TEvControllerConfigRequest\", (Request, request));\n-            Execute(new TTxConfigCmd(request, ev->Sender, ev->Cookie, ev->Get()->SelfHeal, ev->Get()->GroupLayoutSanitizer, this));\n+            Execute(new TTxConfigCmd(request, ev->Sender, ev->Cookie, ev->Get()->SelfHeal, ev->Get()->GroupLayoutSanitizer, ev->Get()->EnforceHostRecords, this));\n         }\n \n } // NKikimr::NBsController\ndiff --git a/ydb/core/mind/bscontroller/config_fit_pdisks.cpp b/ydb/core/mind/bscontroller/config_fit_pdisks.cpp\nindex bdbd9b49394c..ff708c29dd3e 100644\n--- a/ydb/core/mind/bscontroller/config_fit_pdisks.cpp\n+++ b/ydb/core/mind/bscontroller/config_fit_pdisks.cpp\n@@ -162,7 +162,7 @@ namespace NKikimr {\n                     const auto& hostConfig = it->second;\n \n                     const TBlobStorageController::THostId hostId(hostKey.Fqdn, hostKey.IcPort);\n-                    const auto& nodeId = state.HostRecords->ResolveNodeId(hostKey, hostValue);\n+                    const auto& nodeId = hostValue.EnforcedNodeId ? hostValue.EnforcedNodeId : state.HostRecords->ResolveNodeId(hostKey);\n                     if (!nodeId) {\n                         throw TExHostNotFound(hostKey) << TErrorParams::BoxId(boxId) << TErrorParams::NodeId(*nodeId);\n                     } else if (!usedNodes.insert(*nodeId).second) {\ndiff --git a/ydb/core/mind/bscontroller/console_interaction.cpp b/ydb/core/mind/bscontroller/console_interaction.cpp\nindex bc752d12e480..30d950d8adfd 100644\n--- a/ydb/core/mind/bscontroller/console_interaction.cpp\n+++ b/ydb/core/mind/bscontroller/console_interaction.cpp\n@@ -449,6 +449,31 @@ namespace NKikimr::NBsController {\n         }\n     }\n \n+    void TBlobStorageController::TConsoleInteraction::CommitConfig() {\n+        Y_ABORT_UNLESS(PendingCommitState);\n+        Self.Execute(Self.CreateTxCommitConfig(\n+            std::move(PendingCommitState->YamlConfig),\n+            std::exchange(PendingStorageYamlConfig, {}),\n+            std::move(PendingCommitState->StorageConfig),\n+            PendingCommitState->ExpectedStorageYamlConfigVersion,\n+            nullptr,\n+            SwitchEnableConfigV2,\n+            std::move(AuditLogInfo)\n+        ));\n+        CommitInProgress = true;\n+\n+        PendingCommitState.reset();\n+        PendingYamlConfig.reset();\n+    }\n+\n+    void TBlobStorageController::TConsoleInteraction::ProcessDryRunResponse(bool success, TString errorReason) {\n+        if (success) {\n+            CommitConfig();\n+        } else {\n+            IssueGRpcResponse(NKikimrBlobStorage::TEvControllerReplaceConfigResponse::InvalidRequest, std::move(errorReason));\n+        }\n+    }\n+\n     void TBlobStorageController::TConsoleInteraction::Handle(TEvBlobStorage::TEvControllerValidateConfigResponse::TPtr &ev) {\n         STLOG(PRI_DEBUG, BS_CONTROLLER, BSC27, \"Console validate config response\", (Response, ev->Get()->Record));\n         ++ExpectedValidationTimeoutCookie; // spoil validation timeout cookie to prevent event from firing\n@@ -525,11 +550,31 @@ namespace NKikimr::NBsController {\n                 }\n             }\n \n-            Self.Execute(Self.CreateTxCommitConfig(std::move(yamlConfig), std::exchange(PendingStorageYamlConfig, {}),\n-                std::move(storageConfig), expectedStorageYamlConfigVersion, nullptr, SwitchEnableConfigV2,\n-                std::move(AuditLogInfo)));\n-            CommitInProgress = true;\n-            PendingYamlConfig.reset();\n+            PendingCommitState.emplace();\n+            PendingCommitState->YamlConfig = std::move(yamlConfig);\n+            PendingCommitState->StorageConfig = std::move(storageConfig);\n+            PendingCommitState->ExpectedStorageYamlConfigVersion = expectedStorageYamlConfigVersion;\n+\n+            const ui64 cookie = Self.NextValidationCookie++;\n+            Self.PendingValidationRequests.emplace(cookie, TConfigValidationInfo{\n+                .Sender = Self.SelfId(),\n+                .Cookie = ev->Cookie,\n+                .InterconnectSession = ev->InterconnectSession,\n+                .Source = TConfigValidationInfo::ESource::ConsoleInteraction,\n+            });\n+\n+            if (PendingCommitState->StorageConfig) {\n+                auto tempHostRecords = std::make_shared<THostRecordMap::element_type>(*PendingCommitState->StorageConfig);\n+                if (auto req = Self.BuildConfigRequestFromStorageConfig(*PendingCommitState->StorageConfig, tempHostRecords, true)) {\n+                    Self.Send(Self.SelfId(), req.release(), 0, cookie);\n+                } else {\n+                    Self.PendingValidationRequests.erase(cookie);\n+                    ProcessDryRunResponse(true);\n+                }\n+            } else {\n+                Self.PendingValidationRequests.erase(cookie);\n+                ProcessDryRunResponse(true);\n+            }\n         } catch (const TExError& error) {\n             IssueGRpcResponse(TResponseProto::BSCInvalidConfig, error.ErrorReason);\n         }\ndiff --git a/ydb/core/mind/bscontroller/console_interaction.h b/ydb/core/mind/bscontroller/console_interaction.h\nindex 27420168f483..1bf43c1ad3cd 100644\n--- a/ydb/core/mind/bscontroller/console_interaction.h\n+++ b/ydb/core/mind/bscontroller/console_interaction.h\n@@ -22,6 +22,7 @@ namespace NKikimr::NBsController {\n         void Start();\n         void OnConfigCommit();\n         void Stop();\n+        void ProcessDryRunResponse(bool success, TString errorReason = {});\n \n         void Handle(TEvBlobStorage::TEvControllerProposeConfigResponse::TPtr& ev);\n         void Handle(TEvBlobStorage::TEvControllerConsoleCommitResponse::TPtr& ev);\n@@ -55,9 +56,17 @@ namespace NKikimr::NBsController {\n         std::optional<std::optional<TString>> PendingStorageYamlConfig;\n         std::optional<ui64> ExpectedYamlConfigVersion;\n \n+        struct TPendingCommitState {\n+            std::optional<TYamlConfig> YamlConfig;\n+            std::optional<NKikimrBlobStorage::TStorageConfig> StorageConfig;\n+            std::optional<ui64> ExpectedStorageYamlConfigVersion;\n+        };\n+        std::optional<TPendingCommitState> PendingCommitState;\n+\n         void MakeCommitToConsole(TString& config, ui32 configVersion);\n         void MakeGetBlock();\n \n+        void CommitConfig();\n         void IssueGRpcResponse(NKikimrBlobStorage::TEvControllerReplaceConfigResponse::EStatus status,\n             std::optional<TString> errorReason = std::nullopt, bool disabledConfigV2 = false);\n     };\ndiff --git a/ydb/core/mind/bscontroller/impl.h b/ydb/core/mind/bscontroller/impl.h\nindex 6d02ae018ec8..dc89271f979a 100644\n--- a/ydb/core/mind/bscontroller/impl.h\n+++ b/ydb/core/mind/bscontroller/impl.h\n@@ -1448,92 +1448,18 @@ class TBlobStorageController : public TActor<TBlobStorageController>, public TTa\n         }\n     };\n \n-    struct THostRecord {\n-        TNodeId NodeId;\n-        TNodeLocation Location;\n-\n-        THostRecord(const TEvInterconnect::TNodeInfo& nodeInfo)\n-            : NodeId(nodeInfo.NodeId)\n-            , Location(nodeInfo.Location)\n-        {}\n-\n-        THostRecord(const NKikimrBlobStorage::TNodeIdentifier& node)\n-            : NodeId(node.GetNodeId())\n-            , Location(node.GetLocation())\n-        {}\n-    };\n-\n-    class THostRecordMapImpl {\n-        THashMap<THostId, THostRecord> HostIdToRecord;\n-        THashMap<TNodeId, THostId> NodeIdToHostId;\n-        THashMultiMap<TString, TNodeId> FqdnToNodeId;\n-\n-    public:\n-        THostRecordMapImpl() = default;\n-\n-        THostRecordMapImpl(TEvInterconnect::TEvNodesInfo *msg) {\n-            for (const TEvInterconnect::TNodeInfo& nodeInfo : msg->Nodes) {\n-                const THostId hostId(nodeInfo.Host, nodeInfo.Port);\n-                NodeIdToHostId.emplace(nodeInfo.NodeId, hostId);\n-                HostIdToRecord.emplace(hostId, nodeInfo);\n-                FqdnToNodeId.emplace(nodeInfo.Host, nodeInfo.NodeId);\n-            }\n-        }\n-\n-        THostRecordMapImpl(const NKikimrBlobStorage::TStorageConfig& config) {\n-            for (const auto& item : config.GetAllNodes()) {\n-                const THostId hostId(item.GetHost(), item.GetPort());\n-                const TNodeId nodeId = item.GetNodeId();\n-                NodeIdToHostId.emplace(nodeId, hostId);\n-                HostIdToRecord.emplace(hostId, item);\n-                FqdnToNodeId.emplace(item.GetHost(), nodeId);\n-            }\n-        }\n-\n-        const TNodeLocation& GetLocation(TNodeId nodeId) const {\n-            if (auto it = NodeIdToHostId.find(nodeId); it != NodeIdToHostId.end()) {\n-                if (auto hostIt = HostIdToRecord.find(it->second); hostIt != HostIdToRecord.end()) {\n-                    return hostIt->second.Location;\n-                }\n-            }\n-            Y_ABORT();\n-        }\n-\n-        TMaybe<TNodeId> ResolveNodeId(const THostId& hostId) const {\n-            if (const auto it = HostIdToRecord.find(hostId); it != HostIdToRecord.end()) {\n-                return it->second.NodeId;\n-            } else {\n-                return {};\n-            }\n-        }\n-\n-        TMaybe<TNodeId> ResolveNodeId(const TBoxInfo::THostKey& key, const TBoxInfo::THostInfo& info) const {\n-            return info.EnforcedNodeId ? info.EnforcedNodeId : ResolveNodeId(key);\n-        }\n-\n-        TMaybe<THostId> GetHostId(TNodeId nodeId) const {\n-            if (const auto it = NodeIdToHostId.find(nodeId); it != NodeIdToHostId.end()) {\n-                return it->second;\n-            } else {\n-                return {};\n-            }\n-        }\n-\n-        auto ResolveNodeId(const TString& fqdn) const {\n-            return FqdnToNodeId.equal_range(fqdn);\n-        }\n-\n-        auto begin() const {\n-            return HostIdToRecord.begin();\n-        }\n+    struct TConfigValidationInfo {\n+        enum class ESource {\n+            Distconf,\n+            ConsoleInteraction\n+        };\n \n-        auto end() const {\n-            return HostIdToRecord.end();\n-        }\n+        TActorId Sender;\n+        ui64 Cookie;\n+        TActorId InterconnectSession;\n+        ESource Source;\n     };\n \n-    using THostRecordMap = std::shared_ptr<THostRecordMapImpl>;\n-\n private:\n     TString InstanceId;\n     std::shared_ptr<std::atomic_uint64_t> SelfHealUnreassignableGroups = std::make_shared<std::atomic_uint64_t>();\n@@ -1581,6 +1507,9 @@ class TBlobStorageController : public TActor<TBlobStorageController>, public TTa\n     ui64 ExpectedStorageYamlConfigVersion = 0;\n     TBackoffTimer GetBlockBackoff{1, 1000};\n \n+    ui64 NextValidationCookie = 1;\n+    THashMap<ui64, TConfigValidationInfo> PendingValidationRequests;\n+\n     THashMap<TPDiskId, std::reference_wrapper<const NKikimrBlobStorage::TNodeWardenServiceSet::TPDisk>> StaticPDiskMap;\n     THashMap<TPDiskId, ui32> StaticPDiskSlotUsage;\n     std::unique_ptr<TStoragePoolStat> StoragePoolStat;\n@@ -1831,6 +1760,9 @@ class TBlobStorageController : public TActor<TBlobStorageController>, public TTa\n     void ApplyBscSettings(const NKikimrConfig::TBlobStorageConfig& bsConfig);\n     void ApplyStorageConfig(bool ignoreDistconf = false);\n     void Handle(NStorage::TEvNodeConfigInvokeOnRootResult::TPtr ev);\n+    std::unique_ptr<TEvBlobStorage::TEvControllerConfigRequest> BuildConfigRequestFromStorageConfig(\n+        const NKikimrBlobStorage::TStorageConfig& storageConfig, const THostRecordMap& hostRecords, bool validationMode=false);\n+\n     void Handle(TEvBlobStorage::TEvControllerConfigResponse::TPtr ev);\n     void Handle(TEvBlobStorage::TEvControllerDistconfRequest::TPtr ev);\n \ndiff --git a/ydb/core/mind/bscontroller/load_everything.cpp b/ydb/core/mind/bscontroller/load_everything.cpp\nindex c7efcd5aad21..6cd7ea0411e9 100644\n--- a/ydb/core/mind/bscontroller/load_everything.cpp\n+++ b/ydb/core/mind/bscontroller/load_everything.cpp\n@@ -283,7 +283,7 @@ class TBlobStorageController::TTxLoadEverything : public TTransactionBase<TBlobS\n         std::map<std::tuple<TNodeId, TString>, TBoxId> driveToBox;\n         for (const auto& [boxId, box] : Self->Boxes) {\n             for (const auto& [host, value] : box.Hosts) {\n-                const auto& nodeId = Self->HostRecords->ResolveNodeId(host, value);\n+                const auto& nodeId = value.EnforcedNodeId ? value.EnforcedNodeId : Self->HostRecords->ResolveNodeId(host);\n                 Y_VERIFY_S(nodeId, \"HostKey# \" << host.Fqdn << \":\" << host.IcPort << \" does not resolve to a node\");\n                 if (const auto it = Self->HostConfigs.find(value.HostConfigId); it != Self->HostConfigs.end()) {\n                     for (const auto& [drive, info] : it->second.Drives) {\ndiff --git a/ydb/core/mind/bscontroller/storage_stats_calculator.cpp b/ydb/core/mind/bscontroller/storage_stats_calculator.cpp\nindex 436cc16ec4d8..074fa382fefd 100644\n--- a/ydb/core/mind/bscontroller/storage_stats_calculator.cpp\n+++ b/ydb/core/mind/bscontroller/storage_stats_calculator.cpp\n@@ -33,7 +33,7 @@ class TStorageStatsCoroCalculatorImpl : public TActorCoroImpl {\n public:\n     TStorageStatsCoroCalculatorImpl(\n         const TControllerSystemViewsState& systemViewsState,\n-        const TBlobStorageController::THostRecordMap& hostRecordMap,\n+        const THostRecordMap& hostRecordMap,\n         ui32 groupReserveMin,\n         ui32 groupReservePart)\n         : TActorCoroImpl(/* stackSize */ 640_KB, /* allowUnhandledDtor */ true) // 640 KiB should be enough for anything!\n@@ -231,14 +231,14 @@ class TStorageStatsCoroCalculatorImpl : public TActorCoroImpl {\n \n private:\n     TControllerSystemViewsState SystemViewsState;\n-    TBlobStorageController::THostRecordMap HostRecordMap;\n+    THostRecordMap HostRecordMap;\n     ui32 GroupReserveMin = 0;\n     ui32 GroupReservePart = 0;\n };\n \n std::unique_ptr<IActor> CreateStorageStatsCoroCalculator(\n     const TControllerSystemViewsState& systemViewsState,\n-    const TBlobStorageController::THostRecordMap& hostRecordMap,\n+    const THostRecordMap& hostRecordMap,\n     ui32 groupReserveMin,\n     ui32 groupReservePart)\n {\ndiff --git a/ydb/core/mind/bscontroller/storage_stats_calculator.h b/ydb/core/mind/bscontroller/storage_stats_calculator.h\nindex 25df02da2f23..2cb3ec630f40 100644\n--- a/ydb/core/mind/bscontroller/storage_stats_calculator.h\n+++ b/ydb/core/mind/bscontroller/storage_stats_calculator.h\n@@ -15,7 +15,7 @@ struct TControllerSystemViewsState;\n \n std::unique_ptr<NActors::IActor> CreateStorageStatsCoroCalculator(\n     const TControllerSystemViewsState& state,\n-    const TBlobStorageController::THostRecordMap& hostRecordMap,\n+    const THostRecordMap& hostRecordMap,\n     ui32 groupReserveMin,\n     ui32 groupReservePart);\n \ndiff --git a/ydb/core/mind/bscontroller/sys_view.cpp b/ydb/core/mind/bscontroller/sys_view.cpp\nindex 2fc189f6a0bb..29e6167ad52d 100644\n--- a/ydb/core/mind/bscontroller/sys_view.cpp\n+++ b/ydb/core/mind/bscontroller/sys_view.cpp\n@@ -83,7 +83,7 @@ class TSystemViewsCollector : public TActorBootstrapped<TSystemViewsCollector> {\n     std::map<TVSlotId, const NKikimrSysView::TVSlotInfo*> VSlotIndex;\n     std::map<TGroupId, const NKikimrSysView::TGroupInfo*> GroupIndex;\n     std::map<TBoxStoragePoolId, const NKikimrSysView::TStoragePoolInfo*> StoragePoolIndex;\n-    TBlobStorageController::THostRecordMap HostRecords;\n+    THostRecordMap HostRecords;\n     ui32 GroupReserveMin = 0;\n     ui32 GroupReservePart = 0;\n     ::NMonitoring::TDynamicCounterPtr Counters;\ndiff --git a/ydb/core/mind/bscontroller/sys_view.h b/ydb/core/mind/bscontroller/sys_view.h\nindex 1dd79766cd2b..f2fffc2a06d5 100644\n--- a/ydb/core/mind/bscontroller/sys_view.h\n+++ b/ydb/core/mind/bscontroller/sys_view.h\n@@ -26,7 +26,7 @@ struct TEvControllerUpdateSystemViews :\n     std::unordered_set<TVSlotId, THash<TVSlotId>> DeletedVSlots;\n     std::unordered_set<TGroupId, THash<TGroupId>> DeletedGroups;\n     std::unordered_set<TBoxStoragePoolId, THash<TBoxStoragePoolId>> DeletedStoragePools;\n-    TBlobStorageController::THostRecordMap HostRecords;\n+    THostRecordMap HostRecords;\n     ui32 GroupReserveMin;\n     ui32 GroupReservePart;\n };\ndiff --git a/ydb/core/protos/blobstorage_config.proto b/ydb/core/protos/blobstorage_config.proto\nindex 2044dad8ab5d..455fd1b7328f 100644\n--- a/ydb/core/protos/blobstorage_config.proto\n+++ b/ydb/core/protos/blobstorage_config.proto\n@@ -877,4 +877,5 @@ message TConfigResponse {\n     repeated uint32 GroupsGetDegraded = 5;\n     repeated uint32 GroupsGetDisintegrated = 6;\n     repeated uint32 GroupsGetDisintegratedByExpectedStatus = 7;\n+    bool RollbackSuccess = 8;\n }\ndiff --git a/ydb/services/config/bsconfig_ut.cpp b/ydb/services/config/bsconfig_ut.cpp\nindex da488e79378b..1112ff816826 100644\n--- a/ydb/services/config/bsconfig_ut.cpp\n+++ b/ydb/services/config/bsconfig_ut.cpp\n@@ -21,6 +21,8 @@\n \n #include <util/string/builder.h>\n \n+#include <functional>\n+\n #define UNIT_ASSERT_CHECK_STATUS(got, exp) \\\n     UNIT_ASSERT_C(got.status() == exp, \"exp# \" << Ydb::StatusIds::StatusCode_Name(exp) \\\n             << \" got# \" << Ydb::StatusIds::StatusCode_Name(got.status()) << \" issues# \"  << got.issues()) \\\n@@ -170,7 +172,8 @@ Y_UNIT_TEST_SUITE(ConfigGRPCService) {\n             std::optional<TString> mainConfig,\n             std::optional<TString> storageConfig,\n             std::optional<bool> switchDedicatedStorageSection,\n-            bool dedicatedConfigMode) {\n+            bool dedicatedConfigMode,\n+            const std::function<void(const Ydb::Config::ReplaceConfigResponse&)>& checker) {\n \n         std::unique_ptr<Ydb::Config::V1::ConfigService::Stub> stub;\n         stub = Ydb::Config::V1::ConfigService::NewStub(channel);\n@@ -206,14 +209,12 @@ Y_UNIT_TEST_SUITE(ConfigGRPCService) {\n         }\n \n         Ydb::Config::ReplaceConfigResponse response;\n-        Ydb::Config::ReplaceConfigResult result;\n \n         grpc::ClientContext replaceConfigCtx;\n         AdjustCtxForDB(replaceConfigCtx);\n         stub->ReplaceConfig(&replaceConfigCtx, request, &response);\n-        UNIT_ASSERT_CHECK_STATUS(response.operation(), Ydb::StatusIds::SUCCESS);\n-        Cerr << \"response: \" << response.operation().result().DebugString() << Endl;\n-        response.operation().result().UnpackTo(&result);\n+        Cerr << \"response: \" << response.operation().DebugString() << Endl;\n+        checker(response);\n     }\n \n     void FetchConfig(\n@@ -297,7 +298,10 @@ selector_config: []\n     port: 12001\n     host_config_id: 2\n )\";\n-        ReplaceConfig(server.GetChannel(), yamlConfig, std::nullopt, std::nullopt, false);\n+        ReplaceConfig(server.GetChannel(), yamlConfig, std::nullopt, std::nullopt, false,\n+            [](const auto& resp) {\n+                UNIT_ASSERT_CHECK_STATUS(resp.operation(), Ydb::StatusIds::SUCCESS);\n+            });\n         std::optional<TString> yamlConfigFetched, storageYamlConfigFetched;\n         FetchConfig(server.GetChannel(), false, false, yamlConfigFetched, storageYamlConfigFetched);\n         UNIT_ASSERT(yamlConfigFetched);\n@@ -305,6 +309,35 @@ selector_config: []\n         UNIT_ASSERT_VALUES_EQUAL(yamlConfig, *yamlConfigFetched);\n     }\n \n+    Y_UNIT_TEST(ReplaceConfigWithInvalidHostConfig) {\n+        TKikimrWithGrpcAndRootSchema server;\n+        TString yamlConfig = R\"(\n+metadata:\n+  kind: MainConfig\n+  cluster: \"\"\n+  version: 0\n+config:\n+  host_configs:\n+  - host_config_id: 1\n+    drive:\n+    - path: SectorMap:1:64\n+      type: SSD\n+      expected_slot_count: 9\n+    - path: SectorMap:1:64\n+      type: SSD\n+      expected_slot_count: 9\n+  hosts:\n+  - host: ::1\n+    port: 12001\n+    host_config_id: 1\n+)\";\n+        ReplaceConfig(server.GetChannel(), yamlConfig, std::nullopt, std::nullopt, false,\n+            [](const auto& resp) {\n+                UNIT_ASSERT_CHECK_STATUS(resp.operation(), Ydb::StatusIds::INTERNAL_ERROR);\n+                TString opDebugString = resp.operation().DebugString();\n+                UNIT_ASSERT_C(opDebugString.Contains(\"duplicate path\"), opDebugString);\n+            });\n+    }\n     Y_UNIT_TEST(FetchConfig) {\n         TKikimrWithGrpcAndRootSchema server;\n         std::optional<TString> yamlConfigFetched, storageYamlConfigFetched;\n",
  "test_patch": "diff --git a/ydb/tests/functional/config/test_distconf.py b/ydb/tests/functional/config/test_distconf.py\nindex f91c0b649f06..9b609cb38750 100644\n--- a/ydb/tests/functional/config/test_distconf.py\n+++ b/ydb/tests/functional/config/test_distconf.py\n@@ -296,3 +296,25 @@ def test_cluster_expand_with_seed_nodes(self):\n         finally:\n             if os.path.exists(seed_nodes_file.name):\n                 os.unlink(seed_nodes_file.name)\n+\n+    def test_invalid_host_config_id(self):\n+        fetched_config = fetch_config(self.config_client)\n+        dumped_fetched_config = yaml.safe_load(fetched_config)\n+\n+        # replace config with invalid host config id\n+        dumped_fetched_config['metadata']['version'] = 1\n+        dumped_fetched_config[\"config\"][\"host_configs\"][0][\"host_config_id\"] = 1000\n+        replace_config_response = self.config_client.replace_config(yaml.dump(dumped_fetched_config))\n+        logger.debug(f\"replace_config_response: {replace_config_response}\")\n+        assert_that(replace_config_response.operation.status == StatusIds.INTERNAL_ERROR)\n+\n+    def test_invalid_change_host_config_disk(self):\n+        fetched_config = fetch_config(self.config_client)\n+        dumped_fetched_config = yaml.safe_load(fetched_config)\n+\n+        # replace config with invalid host config disk path\n+        dumped_fetched_config[\"config\"][\"host_configs\"][0][\"drive\"].append(dumped_fetched_config[\"config\"][\"host_configs\"][0][\"drive\"][0])\n+        dumped_fetched_config['metadata']['version'] = 1\n+        replace_config_response = self.config_client.replace_config(yaml.dump(dumped_fetched_config))\n+        logger.debug(f\"replace_config_response: {replace_config_response}\")\n+        assert_that(replace_config_response.operation.status == StatusIds.INTERNAL_ERROR)\ndiff --git a/ydb/tests/functional/config/ya.make b/ydb/tests/functional/config/ya.make\nindex 1f7177d13792..a7d65d9ca64d 100644\n--- a/ydb/tests/functional/config/ya.make\n+++ b/ydb/tests/functional/config/ya.make\n@@ -35,6 +35,7 @@ PEERDIR(\n     contrib/python/requests\n     ydb/tests/library\n     ydb/tests/library/clients\n+    contrib/python/requests\n )\n \n FORK_SUBTESTS()\n",
  "problem_statement": "Validate config in BSC while replace\n\n",
  "hints_text": "",
  "created_at": "2025-07-01T20:19:00Z"
}