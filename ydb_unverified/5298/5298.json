{
  "repo": "ydb-platform/ydb",
  "pull_number": 5298,
  "instance_id": "ydb-platform__ydb-5298",
  "issue_numbers": [
    "4984"
  ],
  "base_commit": "5b2264954da2ff5c8d861877db109ab2532c81ff",
  "patch": "diff --git a/ydb/core/tablet_flat/flat_database.cpp b/ydb/core/tablet_flat/flat_database.cpp\nindex 8f36d068db12..b87ee8056d59 100644\n--- a/ydb/core/tablet_flat/flat_database.cpp\n+++ b/ydb/core/tablet_flat/flat_database.cpp\n@@ -84,8 +84,6 @@ TAutoPtr<TTableIter> TDatabase::Iterate(ui32 table, TRawVals key, TTagsRef tags,\n         Y_ABORT(\"Don't know how to convert ELookup to ESeek mode\");\n     };\n \n-    IteratedTables.insert(table);\n-\n     return Require(table)->Iterate(key, tags, Env, seekBy(key, mode), TRowVersion::Max());\n }\n \n@@ -96,8 +94,6 @@ TAutoPtr<TTableIter> TDatabase::IterateExact(ui32 table, TRawVals key, TTagsRef\n {\n     Y_ABORT_UNLESS(!NoMoreReadsFlag, \"Trying to read after reads prohibited, table %u\", table);\n \n-    IteratedTables.insert(table);\n-\n     auto iter = Require(table)->Iterate(key, tags, Env, ESeek::Exact, snapshot, visible, observer);\n \n     // N.B. ESeek::Exact produces iterators with limit=1\n@@ -153,8 +149,6 @@ TAutoPtr<TTableIter> TDatabase::IterateRange(ui32 table, const TKeyRange& range,\n     Y_DEBUG_ABORT_UNLESS(!IsAmbiguousRange(range, Require(table)->GetScheme()->Keys->Size()),\n         \"%s\", IsAmbiguousRangeReason(range, Require(table)->GetScheme()->Keys->Size()));\n \n-    IteratedTables.insert(table);\n-\n     ESeek seek = !range.MinKey || range.MinInclusive ? ESeek::Lower : ESeek::Upper;\n \n     auto iter = Require(table)->Iterate(range.MinKey, tags, Env, seek, snapshot, visible, observer);\n@@ -182,8 +176,6 @@ TAutoPtr<TTableReverseIter> TDatabase::IterateRangeReverse(ui32 table, const TKe\n     Y_DEBUG_ABORT_UNLESS(!IsAmbiguousRange(range, Require(table)->GetScheme()->Keys->Size()),\n         \"%s\", IsAmbiguousRangeReason(range, Require(table)->GetScheme()->Keys->Size()));\n \n-    IteratedTables.insert(table);\n-\n     ESeek seek = !range.MaxKey || range.MaxInclusive ? ESeek::Lower : ESeek::Upper;\n \n     auto iter = Require(table)->IterateReverse(range.MaxKey, tags, Env, seek, snapshot, visible, observer);\n@@ -699,18 +691,6 @@ TDatabase::TProd TDatabase::Commit(TTxStamp stamp, bool commit, TCookieAllocator\n \n     TempIterators.clear();\n \n-    if (IteratedTables) {\n-        for (ui32 table : IteratedTables) {\n-            if (auto& wrap = DatabaseImpl->Get(table, false)) {\n-                if (auto* cache = wrap->GetErasedKeysCache()) {\n-                    cache->CollectGarbage();\n-                }\n-            }\n-        }\n-\n-        IteratedTables.clear();\n-    }\n-\n     if (commit && HasChanges()) {\n         Y_ABORT_UNLESS(stamp >= Change->Stamp);\n         Y_ABORT_UNLESS(DatabaseImpl->Serial() == Change->Serial);\n@@ -794,6 +774,8 @@ TDatabase::TProd TDatabase::Commit(TTxStamp stamp, bool commit, TCookieAllocator\n         DatabaseImpl->RollbackTransaction();\n     }\n \n+    DatabaseImpl->RunGC();\n+\n     Redo = nullptr;\n     Annex = nullptr;\n     Alter_ = nullptr;\ndiff --git a/ydb/core/tablet_flat/flat_database.h b/ydb/core/tablet_flat/flat_database.h\nindex 8b22577e2c6d..ec4e9945e246 100644\n--- a/ydb/core/tablet_flat/flat_database.h\n+++ b/ydb/core/tablet_flat/flat_database.h\n@@ -304,7 +304,6 @@ class TDatabase {\n     TVector<TUpdateOp> ModifiedOps;\n \n     mutable TDeque<TPartIter> TempIterators; // Keeps the last result of Select() valid\n-    mutable THashSet<ui32> IteratedTables;\n \n     TVector<std::function<void()>> OnCommit_;\n     TVector<std::function<void()>> OnRollback_;\ndiff --git a/ydb/core/tablet_flat/flat_dbase_naked.h b/ydb/core/tablet_flat/flat_dbase_naked.h\nindex e67d6da7b097..5323ca91d3fe 100644\n--- a/ydb/core/tablet_flat/flat_dbase_naked.h\n+++ b/ydb/core/tablet_flat/flat_dbase_naked.h\n@@ -24,6 +24,7 @@ namespace NTable {\n             ui32 Table;\n             TEpoch Head;\n             TTxStamp Edge;\n+            const TIntrusivePtr<TKeyRangeCacheNeedGCList>& GCList;\n         };\n \n         struct TTableWrapper {\n@@ -32,7 +33,7 @@ namespace NTable {\n \n             TTableWrapper(TArgs args)\n                 : Table(args.Table)\n-                , Self(new TTable(args.Head))\n+                , Self(new TTable(args.Head, args.GCList))\n                 , Edge(args.Edge)\n             {\n \n@@ -127,7 +128,8 @@ namespace NTable {\n         using TMemGlob = NPageCollection::TMemGlob;\n \n         TDatabaseImpl(TTxStamp weak, TAutoPtr<TScheme> scheme, const TEdges *edges)\n-            : Weak(weak)\n+            : GCList(new TKeyRangeCacheNeedGCList)\n+            , Weak(weak)\n             , Redo(*this)\n             , Scheme(scheme)\n         {\n@@ -445,6 +447,10 @@ namespace NTable {\n             SchemeRollbackState.Tables.clear();\n         }\n \n+        void RunGC() {\n+            GCList->RunGC();\n+        }\n+\n         TDatabaseImpl& Switch(TTxStamp stamp) noexcept\n         {\n             Y_ABORT_UNLESS(!InTransaction, \"Unexpected switch inside a transaction\");\n@@ -582,7 +588,7 @@ namespace NTable {\n                 edge.Head = TEpoch(i64(head));\n             }\n \n-            TArgs args{ table, edge.Head, edge.TxStamp };\n+            TArgs args{ table, edge.Head, edge.TxStamp, GCList };\n \n             auto result = Tables.emplace(table, args);\n \n@@ -776,6 +782,7 @@ namespace NTable {\n         }\n \n     private:\n+        const TIntrusivePtr<TKeyRangeCacheNeedGCList> GCList;\n         const TTxStamp Weak;    /* db bootstrap upper stamp         */\n         ui64 Stamp = 0;\n         ui64 Serial_ = 1;       /* db global change serial number    */\ndiff --git a/ydb/core/tablet_flat/flat_iterator.h b/ydb/core/tablet_flat/flat_iterator.h\nindex e63ede3a5f29..970cc0dd0fa2 100644\n--- a/ydb/core/tablet_flat/flat_iterator.h\n+++ b/ydb/core/tablet_flat/flat_iterator.h\n@@ -282,12 +282,19 @@ class TTableIterBase : TNonCopyable {\n             } else if (Stage == EStage::Snap) {\n                 if (mode != ENext::Uncommitted) {\n                     Ready = Snap();\n-                    if (ErasedKeysCache && mode == ENext::Data &&\n-                        (Stats.InvisibleRowSkips != SnapInvisibleRowSkips || Stage != EStage::Fill))\n-                    {\n-                        // Interrupt range when key is not at a head version, or skipped entirely\n+                    // Interrupt range when key state might change between iterations\n+                    if (ErasedKeysCache && mode == ENext::Data && Stats.UncertainErase) {\n                         eraseCache.Flush();\n                     }\n+                    // Handle keys that don't exist at current snapshot version\n+                    if (Stage == EStage::Turn) {\n+                        InitLastKey(ERowOp::Absent);\n+                        ++Stats.DeletedRowSkips; /* skip this invisible key */\n+                        if (ErasedKeysCache && mode == ENext::Data && !Stats.UncertainErase) {\n+                            // Erase cache should treat this key as a cachable erase\n+                            eraseCache.OnEraseKey(GetKey().Cells(), TRowVersion::Min());\n+                        }\n+                    }\n                 } else {\n                     Y_DEBUG_ABORT_UNLESS(Active != Inactive);\n                     Stage = EStage::Fill;\n@@ -300,7 +307,7 @@ class TTableIterBase : TNonCopyable {\n             } else {\n                 InitLastKey(ERowOp::Erase);\n                 ++Stats.DeletedRowSkips; /* skip internal technical row states w/o data */\n-                if (ErasedKeysCache && Stats.InvisibleRowSkips == SnapInvisibleRowSkips) {\n+                if (ErasedKeysCache && !Stats.UncertainErase) {\n                     // Try to cache erases that are at a head version\n                     eraseCache.OnEraseKey(GetKey().Cells(), GetRowVersion());\n                 }\n@@ -341,6 +348,7 @@ class TTableIterBase : TNonCopyable {\n     const TRowScheme* Scheme;\n     const TRemap Remap;\n     TIntrusivePtr<TKeyRangeCache> ErasedKeysCache;\n+    NTable::TTransactionSet DecidedTransactions; // Needed for ErasedKeysCache\n     TIteratorStats Stats;\n \n private:\n@@ -435,7 +443,6 @@ class TTableIterBase : TNonCopyable {\n     TIterators Iterators;\n     TForwardIter Active;\n     TForwardIter Inactive;\n-    ui64 SnapInvisibleRowSkips = 0;\n     ui64 DeltaTxId = 0;\n     TRowVersion DeltaVersion;\n     bool Delta = false;\n@@ -609,7 +616,7 @@ inline EReady TTableIterBase<TIteratorOps>::Start() noexcept\n     }\n \n     Stage = EStage::Snap;\n-    SnapInvisibleRowSkips = Stats.InvisibleRowSkips;\n+    Stats.UncertainErase = false;\n     Inactive = Iterators.end();\n     return EReady::Data;\n }\n@@ -792,8 +799,6 @@ inline EReady TTableIterBase<TIteratorOps>::Snap() noexcept\n             return EReady::Data;\n \n         case EReady::Gone:\n-            InitLastKey(ERowOp::Absent);\n-            ++Stats.DeletedRowSkips;\n             Stage = EStage::Turn;\n             return EReady::Data;\n \n@@ -811,14 +816,14 @@ inline EReady TTableIterBase<TIteratorOps>::Snap(TRowVersion rowVersion) noexcep\n         TIteratorId ai = i->IteratorId;\n         switch (ai.Type) {\n             case EType::Mem: {\n-                auto ready = MemIters[ai.Index]->SkipToRowVersion(rowVersion, Stats, CommittedTransactions, TransactionObserver);\n+                auto ready = MemIters[ai.Index]->SkipToRowVersion(rowVersion, Stats, CommittedTransactions, TransactionObserver, DecidedTransactions);\n                 if (ready) {\n                     return EReady::Data;\n                 }\n                 break;\n             }\n             case EType::Run: {\n-                auto ready = RunIters[ai.Index]->SkipToRowVersion(rowVersion, Stats, CommittedTransactions, TransactionObserver);\n+                auto ready = RunIters[ai.Index]->SkipToRowVersion(rowVersion, Stats, CommittedTransactions, TransactionObserver, DecidedTransactions);\n                 if (ready == EReady::Data) {\n                     return EReady::Data;\n                 } else if (ready != EReady::Gone) {\ndiff --git a/ydb/core/tablet_flat/flat_mem_iter.h b/ydb/core/tablet_flat/flat_mem_iter.h\nindex 1fec8da2b087..b1781885237b 100644\n--- a/ydb/core/tablet_flat/flat_mem_iter.h\n+++ b/ydb/core/tablet_flat/flat_mem_iter.h\n@@ -240,7 +240,8 @@ namespace NTable {\n          */\n         bool SkipToRowVersion(TRowVersion rowVersion, TIteratorStats& stats,\n                               NTable::ITransactionMapSimplePtr committedTransactions,\n-                              NTable::ITransactionObserverSimplePtr transactionObserver) noexcept\n+                              NTable::ITransactionObserverSimplePtr transactionObserver,\n+                              const NTable::ITransactionSet& decidedTransactions) noexcept\n         {\n             Y_DEBUG_ABORT_UNLESS(IsValid(), \"Attempt to access an invalid row\");\n \n@@ -250,6 +251,10 @@ namespace NTable {\n             // Skip uncommitted deltas\n             while (chain->RowVersion.Step == Max<ui64>() && !committedTransactions.Find(chain->RowVersion.TxId)) {\n                 transactionObserver.OnSkipUncommitted(chain->RowVersion.TxId);\n+                if (chain->Rop != ERowOp::Erase && !decidedTransactions.Contains(chain->RowVersion.TxId)) {\n+                    // This change may commit and change the iteration result\n+                    stats.UncertainErase = true;\n+                }\n                 if (!(chain = chain->Next)) {\n                     CurrentVersion = nullptr;\n                     return false;\n@@ -267,12 +272,20 @@ namespace NTable {\n                 auto* commitVersion = committedTransactions.Find(chain->RowVersion.TxId);\n                 Y_ABORT_UNLESS(commitVersion);\n                 if (*commitVersion <= rowVersion) {\n+                    if (!decidedTransactions.Contains(chain->RowVersion.TxId)) {\n+                        // This change may rollback and change the iteration result\n+                        stats.UncertainErase = true;\n+                    }\n                     return true;\n                 }\n                 transactionObserver.OnSkipCommitted(*commitVersion, chain->RowVersion.TxId);\n             }\n \n             stats.InvisibleRowSkips++;\n+            if (chain->Rop != ERowOp::Erase) {\n+                // We are skipping non-erase op, so any erase below cannot be trusted\n+                stats.UncertainErase = true;\n+            }\n \n             while ((chain = chain->Next)) {\n                 if (chain->RowVersion.Step != Max<ui64>()) {\n@@ -286,6 +299,10 @@ namespace NTable {\n                 } else {\n                     auto* commitVersion = committedTransactions.Find(chain->RowVersion.TxId);\n                     if (commitVersion && *commitVersion <= rowVersion) {\n+                        if (!decidedTransactions.Contains(chain->RowVersion.TxId)) {\n+                            // This change may rollback and change the iteration result\n+                            stats.UncertainErase = true;\n+                        }\n                         CurrentVersion = chain;\n                         return true;\n                     }\n@@ -295,8 +312,17 @@ namespace NTable {\n                         stats.InvisibleRowSkips++;\n                     } else {\n                         transactionObserver.OnSkipUncommitted(chain->RowVersion.TxId);\n+                        if (decidedTransactions.Contains(chain->RowVersion.TxId)) {\n+                            // This is a decided uncommitted change and will never be committed\n+                            // Make sure we don't mark possible erase below as uncertain\n+                            continue;\n+                        }\n                     }\n                 }\n+                if (chain->Rop != ERowOp::Erase) {\n+                    // We are skipping non-erase op, so any erase below cannot be trusted\n+                    stats.UncertainErase = true;\n+                }\n             }\n \n             CurrentVersion = nullptr;\ndiff --git a/ydb/core/tablet_flat/flat_part_iter.h b/ydb/core/tablet_flat/flat_part_iter.h\nindex 20db44c14357..84c2843a4c14 100644\n--- a/ydb/core/tablet_flat/flat_part_iter.h\n+++ b/ydb/core/tablet_flat/flat_part_iter.h\n@@ -923,7 +923,8 @@ namespace NTable {\n \n         EReady SkipToRowVersion(TRowVersion rowVersion, TIteratorStats& stats,\n                                 NTable::ITransactionMapSimplePtr committedTransactions,\n-                                NTable::ITransactionObserverSimplePtr transactionObserver) noexcept\n+                                NTable::ITransactionObserverSimplePtr transactionObserver,\n+                                const NTable::ITransactionSet& decidedTransactions) noexcept\n         {\n             Y_DEBUG_ABORT_UNLESS(Main.IsValid(), \"Attempt to use an invalid iterator\");\n \n@@ -948,6 +949,7 @@ namespace NTable {\n                             transactionObserver.OnSkipCommitted(Part->MinRowVersion);\n                         }\n                         stats.InvisibleRowSkips++;\n+                        stats.UncertainErase = true;\n                     }\n                     return EReady::Gone;\n                 }\n@@ -964,15 +966,27 @@ namespace NTable {\n                     const auto* commitVersion = committedTransactions.Find(txId);\n                     if (commitVersion && *commitVersion <= rowVersion) {\n                         // Already committed and correct version\n+                        if (!decidedTransactions.Contains(txId)) {\n+                            // This change may rollback and change the iteration result\n+                            stats.UncertainErase = true;\n+                        }\n                         return EReady::Data;\n                     }\n                     if (commitVersion) {\n                         // Skipping a newer committed delta\n                         transactionObserver.OnSkipCommitted(*commitVersion, txId);\n                         stats.InvisibleRowSkips++;\n+                        if (data->GetRop() != ERowOp::Erase) {\n+                            // Skipping non-erase delta, so any erase below cannot be trusted\n+                            stats.UncertainErase = true;\n+                        }\n                     } else {\n                         // Skipping an uncommitted delta\n                         transactionObserver.OnSkipUncommitted(txId);\n+                        if (data->GetRop() != ERowOp::Erase && !decidedTransactions.Contains(txId)) {\n+                            // This change may commit and change the iteration result\n+                            stats.UncertainErase = true;\n+                        }\n                     }\n                     data = Main.GetRecord()->GetAltRecord(++SkipMainDeltas);\n                     if (!data) {\n@@ -991,6 +1005,7 @@ namespace NTable {\n                     SkipEraseVersion = true;\n                     transactionObserver.OnSkipCommitted(current);\n                     stats.InvisibleRowSkips++;\n+                    stats.UncertainErase = true;\n                 }\n \n                 TRowVersion current = data->IsVersioned() ? data->GetMinVersion(info) : Part->MinRowVersion;\n@@ -1001,6 +1016,7 @@ namespace NTable {\n \n                 transactionObserver.OnSkipCommitted(current);\n                 stats.InvisibleRowSkips++;\n+                stats.UncertainErase = true;\n \n                 if (!data->HasHistory()) {\n                     // There is no history, reset\n@@ -1661,10 +1677,11 @@ namespace NTable {\n \n         EReady SkipToRowVersion(TRowVersion rowVersion, TIteratorStats& stats,\n                                 NTable::ITransactionMapSimplePtr committedTransactions,\n-                                NTable::ITransactionObserverSimplePtr transactionObserver) noexcept\n+                                NTable::ITransactionObserverSimplePtr transactionObserver,\n+                                const NTable::ITransactionSet& decidedTransactions) noexcept\n         {\n             Y_DEBUG_ABORT_UNLESS(CurrentIt);\n-            auto ready = CurrentIt->SkipToRowVersion(rowVersion, stats, committedTransactions, transactionObserver);\n+            auto ready = CurrentIt->SkipToRowVersion(rowVersion, stats, committedTransactions, transactionObserver, decidedTransactions);\n             return ready;\n         }\n \ndiff --git a/ydb/core/tablet_flat/flat_range_cache.cpp b/ydb/core/tablet_flat/flat_range_cache.cpp\nindex 65101be07885..af7a6d03014c 100644\n--- a/ydb/core/tablet_flat/flat_range_cache.cpp\n+++ b/ydb/core/tablet_flat/flat_range_cache.cpp\n@@ -4,9 +4,31 @@\n namespace NKikimr {\n namespace NTable {\n \n-TKeyRangeCache::TKeyRangeCache(const TKeyCellDefaults& keyDefaults, const TKeyRangeCacheConfig& config)\n+TKeyRangeCacheNeedGCList::~TKeyRangeCacheNeedGCList()\n+{ }\n+\n+void TKeyRangeCacheNeedGCList::Add(TKeyRangeCache* cache) {\n+    TListItem* item = static_cast<TListItem*>(cache);\n+    if (item->Empty()) {\n+        List.PushBack(item);\n+    }\n+}\n+\n+void TKeyRangeCacheNeedGCList::RunGC() {\n+    while (List) {\n+        auto* item = List.Front();\n+        // Note: we call CollectGarbage while item is still in the list\n+        // This way item is not re-added by internal invalidations\n+        item->CollectGarbage();\n+        List.Remove(item);\n+    }\n+}\n+\n+TKeyRangeCache::TKeyRangeCache(const TKeyCellDefaults& keyDefaults, const TKeyRangeCacheConfig& config,\n+        const TIntrusivePtr<TKeyRangeCacheNeedGCList>& gcList)\n     : KeyCellDefaults(keyDefaults)\n     , Config(config)\n+    , GCList(gcList)\n     , Pool(new TSpecialMemoryPool())\n     , Entries(TKeyRangeEntryCompare(KeyCellDefaults.Types), TAllocator(&UsedHeapMemory))\n { }\n@@ -50,6 +72,9 @@ TArrayRef<TCell> TKeyRangeCache::AllocateKey(TArrayRef<const TCell> key) {\n     }\n \n     ++Stats_.Allocations;\n+    if (GCList) {\n+        GCList->Add(this);\n+    }\n \n     auto copy = AllocateArrayCopy(Pool.Get(), key);\n     for (TCell& cell : copy) {\n@@ -66,6 +91,9 @@ void TKeyRangeCache::DeallocateKey(TArrayRef<TCell> key) {\n     }\n \n     ++Stats_.Deallocations;\n+    if (GCList) {\n+        GCList->Add(this);\n+    }\n \n     size_t index = key.size() - 1;\n     do {\n@@ -104,6 +132,9 @@ TKeyRangeCache::const_iterator TKeyRangeCache::Merge(const_iterator left, const_\n     Entries.erase(right);\n     DeallocateKey(rightCopy.FromKey);\n     ExtendRight(left, rightCopy.ToKey, rightCopy.ToInclusive, ::Max(rightCopy.MaxVersion, version));\n+    if (GCList) {\n+        GCList->Add(this);\n+    }\n     return left;\n }\n \n@@ -112,6 +143,9 @@ TKeyRangeCache::const_iterator TKeyRangeCache::Add(TKeyRangeEntry entry) {\n     Y_DEBUG_ABORT_UNLESS(res.second);\n     TKeyRangeEntryLRU& newEntry = const_cast<TKeyRangeEntryLRU&>(*res.first);\n     Fresh.PushBack(&newEntry);\n+    if (GCList) {\n+        GCList->Add(this);\n+    }\n     return res.first;\n }\n \n@@ -121,6 +155,24 @@ void TKeyRangeCache::Invalidate(const_iterator it) {\n     Entries.erase(it);\n     DeallocateKey(entryCopy.FromKey);\n     DeallocateKey(entryCopy.ToKey);\n+    if (GCList) {\n+        GCList->Add(this);\n+    }\n+}\n+\n+void TKeyRangeCache::InvalidateKey(const_iterator it, TArrayRef<const TCell> key) {\n+    Y_DEBUG_ABORT_UNLESS(it != end());\n+    TKeyRangeEntryLRU& entry = const_cast<TKeyRangeEntryLRU&>(*it);\n+    int cmp = Entries.key_comp().CompareKeys(entry.FromKey, key);\n+    Y_DEBUG_ABORT_UNLESS(cmp <= 0);\n+    if (cmp == 0) {\n+        Y_DEBUG_ABORT_UNLESS(entry.FromInclusive);\n+        Invalidate(it);\n+        return;\n+    }\n+    DeallocateKey(entry.ToKey);\n+    entry.ToKey = AllocateKey(key);\n+    entry.ToInclusive = false;\n }\n \n void TKeyRangeCache::Touch(const_iterator it) {\ndiff --git a/ydb/core/tablet_flat/flat_range_cache.h b/ydb/core/tablet_flat/flat_range_cache.h\nindex b3bb654fff08..0772ceb3da66 100644\n--- a/ydb/core/tablet_flat/flat_range_cache.h\n+++ b/ydb/core/tablet_flat/flat_range_cache.h\n@@ -65,6 +65,12 @@ class TKeyRangeEntryCompare {\n         TArrayRef<const TCell> Key;\n     };\n \n+    int CompareKeys(TArrayRef<const TCell> a, TArrayRef<const TCell> b) const noexcept {\n+        Y_DEBUG_ABORT_UNLESS(a.size() == KeyTypes.size());\n+        Y_DEBUG_ABORT_UNLESS(b.size() == KeyTypes.size());\n+        return CompareTypedCellVectors(a.data(), b.data(), KeyTypes.data(), KeyTypes.size());\n+    }\n+\n     template<class TPoint>\n     bool PointLessThanLeftBorder(const TPoint& a, const TKeyRangeEntry& b) const noexcept {\n         Y_DEBUG_ABORT_UNLESS(a.Key.size() == KeyTypes.size());\n@@ -311,9 +317,30 @@ struct TKeyRangeCacheConfig {\n     size_t MaxBytes = 128 * 1024; // maximum 128KB by default\n };\n \n+class TKeyRangeCache;\n+struct TKeyRangeCacheNeedGCTag;\n+\n+class TKeyRangeCacheNeedGCList final\n+    : public TSimpleRefCount<TKeyRangeCacheNeedGCList>\n+{\n+public:\n+    ~TKeyRangeCacheNeedGCList();\n+\n+    void Add(TKeyRangeCache* cache);\n+\n+    void RunGC();\n+\n+private:\n+    using TListItem = TIntrusiveListItem<TKeyRangeCache, TKeyRangeCacheNeedGCTag>;\n+    TIntrusiveList<TKeyRangeCache, TKeyRangeCacheNeedGCTag> List;\n+};\n+\n class TKeyRangeCache final\n     : public TSimpleRefCount<TKeyRangeCache>\n+    , public TIntrusiveListItem<TKeyRangeCache, TKeyRangeCacheNeedGCTag>\n {\n+    friend class TKeyRangeCacheNeedGCList;\n+\n private:\n     template<class T>\n     class TAccountingAllocator\n@@ -387,7 +414,8 @@ class TKeyRangeCache final\n     };\n \n public:\n-    TKeyRangeCache(const TKeyCellDefaults& keyDefaults, const TKeyRangeCacheConfig& config);\n+    TKeyRangeCache(const TKeyCellDefaults& keyDefaults, const TKeyRangeCacheConfig& config,\n+        const TIntrusivePtr<TKeyRangeCacheNeedGCList>& gcList = nullptr);\n \n     ~TKeyRangeCache();\n \n@@ -514,6 +542,13 @@ class TKeyRangeCache final\n      */\n     void Invalidate(const_iterator it);\n \n+    /**\n+     * Invalidates the specified key from the entry.\n+     * Entry may or may not become invalidated after this call.\n+     * The key doesn't need to be previously allocated with AllocateKey.\n+     */\n+    void InvalidateKey(const_iterator it, TArrayRef<const TCell> key);\n+\n     /**\n      * Marks the specified entry as most recently used\n      */\n@@ -554,6 +589,7 @@ class TKeyRangeCache final\n private:\n     const TKeyCellDefaults& KeyCellDefaults;\n     const TKeyRangeCacheConfig Config;\n+    const TIntrusivePtr<TKeyRangeCacheNeedGCList> GCList;\n     THolder<TSpecialMemoryPool> Pool;\n     size_t UsedHeapMemory = 0;\n     TContainer Entries;\ndiff --git a/ydb/core/tablet_flat/flat_range_cache_ut.cpp b/ydb/core/tablet_flat/flat_range_cache_ut.cpp\nindex 2674e00212c4..ae0c1d79e48c 100644\n--- a/ydb/core/tablet_flat/flat_range_cache_ut.cpp\n+++ b/ydb/core/tablet_flat/flat_range_cache_ut.cpp\n@@ -235,7 +235,7 @@ Y_UNIT_TEST_SUITE(TFlatEraseCacheTest) {\n             DB.Commit(8, true);\n \n             // We touched an erased range, it should become invalidated\n-            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ }\");\n+            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1, 2}, {2, 5}) }\");\n         }\n \n         {\n@@ -249,7 +249,7 @@ Y_UNIT_TEST_SUITE(TFlatEraseCacheTest) {\n             DB.Commit(9, true);\n \n             // We've seen all rows, expect correct erased ranges\n-            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1, 2}, {2, 4}], [{2, 6}, {2, 31}] }\");\n+            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1, 2}, {2, 5}), [{2, 6}, {2, 31}] }\");\n         }\n     }\n \n@@ -423,7 +423,7 @@ Y_UNIT_TEST_SUITE(TFlatEraseCacheTest) {\n             DB.Commit(8, true);\n \n             // We touched an erased range, it should become invalidated\n-            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ }\");\n+            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{2, 2}, {2, 28}) }\");\n         }\n \n         {\n@@ -437,7 +437,7 @@ Y_UNIT_TEST_SUITE(TFlatEraseCacheTest) {\n             DB.Commit(9, true);\n \n             // We've seen all rows, expect correct erased ranges\n-            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{2, 2}, {2, 27}], [{2, 29}, {3, 31}] }\");\n+            UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{2, 2}, {2, 28}), [{2, 29}, {3, 31}] }\");\n         }\n     }\n \ndiff --git a/ydb/core/tablet_flat/flat_table.cpp b/ydb/core/tablet_flat/flat_table.cpp\nindex 19b830e99cd3..354bccbcaefc 100644\n--- a/ydb/core/tablet_flat/flat_table.cpp\n+++ b/ydb/core/tablet_flat/flat_table.cpp\n@@ -16,7 +16,10 @@\n namespace NKikimr {\n namespace NTable {\n \n-TTable::TTable(TEpoch epoch) : Epoch(epoch) { }\n+TTable::TTable(TEpoch epoch, const TIntrusivePtr<TKeyRangeCacheNeedGCList>& gcList)\n+    : Epoch(epoch)\n+    , EraseCacheGCList(gcList)\n+{ }\n \n TTable::~TTable() { }\n \n@@ -30,6 +33,7 @@ void TTable::PrepareRollback()\n     state.EraseCacheConfig = EraseCacheConfig;\n     state.MutableExisted = bool(Mutable);\n     state.MutableUpdated = false;\n+    state.DisableEraseCache = false;\n }\n \n void TTable::RollbackChanges()\n@@ -37,6 +41,8 @@ void TTable::RollbackChanges()\n     Y_ABORT_UNLESS(RollbackState, \"PrepareRollback needed to rollback changes\");\n     auto& state = *RollbackState;\n \n+    CommitOps.clear();\n+\n     while (!RollbackOps.empty()) {\n         struct TApplyRollbackOp {\n             TTable* Self;\n@@ -80,20 +86,12 @@ void TTable::RollbackChanges()\n \n     if (Epoch != state.Epoch) {\n         // We performed a snapshot, roll it back\n-        if (Mutable) {\n-            ErasedKeysCache.Reset();\n-            Mutable = nullptr;\n-        }\n         Y_ABORT_UNLESS(MutableBackup, \"Previous mem table missing\");\n         Mutable = std::move(MutableBackup);\n     } else if (!state.MutableExisted) {\n         // New memtable doesn't need rollback\n-        if (Mutable) {\n-            ErasedKeysCache.Reset();\n-            Mutable = nullptr;\n-        }\n+        Mutable = nullptr;\n     } else if (state.MutableUpdated) {\n-        ErasedKeysCache.Reset();\n         Y_ABORT_UNLESS(Mutable, \"Mutable was updated, but it is missing\");\n         Mutable->RollbackChanges();\n     }\n@@ -103,7 +101,6 @@ void TTable::RollbackChanges()\n     Annexed = state.Annexed;\n     if (state.Scheme) {\n         Levels.Reset();\n-        ErasedKeysCache.Reset();\n         Scheme = std::move(state.Scheme);\n         EraseCacheEnabled = state.EraseCacheEnabled;\n         EraseCacheConfig = state.EraseCacheConfig;\n@@ -116,6 +113,19 @@ void TTable::CommitChanges(TArrayRef<const TMemGlob> blobs)\n     Y_ABORT_UNLESS(RollbackState, \"PrepareRollback needed to rollback changes\");\n     auto& state = *RollbackState;\n \n+    for (auto& op : CommitOps) {\n+        struct TApplyCommitOp {\n+            TTable* Self;\n+\n+            void operator()(const TCommitAddDecidedTx& op) const {\n+                Self->DecidedTransactions.Add(op.TxId);\n+            }\n+        };\n+\n+        std::visit(TApplyCommitOp{ this }, op);\n+    }\n+\n+    CommitOps.clear();\n     RollbackOps.clear();\n \n     if (Epoch != state.Epoch) {\n@@ -162,6 +172,11 @@ void TTable::SetScheme(const TScheme::TTableInfo &table)\n \n     Y_ABORT_UNLESS(!Mutable && table.Columns);\n \n+    if (RollbackState) {\n+        // Make sure we don't populate erase cache with keys based on a schema\n+        // which may end up rolling back.\n+        RollbackState->DisableEraseCache = true;\n+    }\n     if (RollbackState && !RollbackState->Scheme) {\n         RollbackState->Scheme = Scheme;\n         RollbackState->EraseCacheEnabled = EraseCacheEnabled;\n@@ -362,7 +377,8 @@ void TTable::ReplaceSlices(TBundleSlicesMap slices) noexcept\n     }\n     if (slices) {\n         Levels.Reset();\n-        ErasedKeysCache.Reset();\n+        // Note: ReplaceSlices does not introduce any new rows, so we don't\n+        // have to invalidate current erase cache.\n     }\n }\n \n@@ -383,9 +399,12 @@ void TTable::Replace(TArrayRef<const TPartView> partViews, const TSubset &subset\n         Levels.Reset();\n     }\n \n+    bool removingOld = false;\n+    bool addingNew = false;\n     THashSet<ui64> checkNewTransactions;\n \n     for (auto &memTable : subset.Frozen) {\n+        removingOld = true;\n         const auto found = Frozen.erase(memTable.MemTable);\n \n         Y_ABORT_UNLESS(found == 1, \"Got an unknown TMemTable table in TSubset\");\n@@ -406,6 +425,7 @@ void TTable::Replace(TArrayRef<const TPartView> partViews, const TSubset &subset\n     }\n \n     for (auto &part : subset.Flatten) {\n+        removingOld = true;\n         Y_ABORT_UNLESS(part.Slices && *part.Slices,\n             \"Got an empty TPart subset in TSubset\");\n \n@@ -454,12 +474,14 @@ void TTable::Replace(TArrayRef<const TPartView> partViews, const TSubset &subset\n     }\n \n     for (auto &part : subset.ColdParts) {\n+        removingOld = true;\n         auto it = ColdParts.find(part->Label);\n         Y_ABORT_UNLESS(it != ColdParts.end(), \"Got an unknown TColdPart in TSubset\");\n         ColdParts.erase(it);\n     }\n \n     for (const auto &partView : partViews) {\n+        addingNew = true;\n         if (Mutable && partView->Epoch >= Mutable->Epoch) {\n             Y_Fail(\"Replace with \" << NFmt::Do(*partView) << \" after mutable epoch \" << Mutable->Epoch);\n         }\n@@ -481,6 +503,7 @@ void TTable::Replace(TArrayRef<const TPartView> partViews, const TSubset &subset\n             if (!ColdParts) {\n                 CommittedTransactions.Remove(txId);\n                 RemovedTransactions.Remove(txId);\n+                DecidedTransactions.Remove(txId);\n             } else {\n                 CheckTransactions.insert(txId);\n             }\n@@ -491,7 +514,14 @@ void TTable::Replace(TArrayRef<const TPartView> partViews, const TSubset &subset\n \n     ProcessCheckTransactions();\n \n-    ErasedKeysCache.Reset();\n+    if (!removingOld && addingNew) {\n+        // Note: we invalidate erase cache when nothing old is removed,\n+        // because followers always call Replace, even when leader called\n+        // Merge. When something is removed we can assume it's a compaction\n+        // and compactions don't add new rows to the table, keeping erase\n+        // cache valid.\n+        ErasedKeysCache.Reset();\n+    }\n }\n \n void TTable::ReplaceTxStatus(TArrayRef<const TIntrusiveConstPtr<TTxStatusPart>> newTxStatus, const TSubset &subset) noexcept\n@@ -551,6 +581,8 @@ void TTable::Merge(TPartView partView) noexcept\n         it->second.Slices = TSlices::Merge(it->second.Slices, partView.Slices);\n     }\n \n+    // Note: Merge is called when borrowing data, which may introduce new rows\n+    // and invalidate current erase cache.\n     ErasedKeysCache.Reset();\n }\n \n@@ -579,8 +611,11 @@ void TTable::Merge(TIntrusiveConstPtr<TColdPart> part) noexcept\n     Epoch = Max(Epoch, part->Epoch + 1);\n     ColdParts.emplace(label, std::move(part));\n \n-    ErasedKeysCache.Reset();\n     Levels.Reset();\n+\n+    // Note: Merge is called when borrowing data, which may introduce new rows\n+    // and invalidate current erase cache.\n+    ErasedKeysCache.Reset();\n }\n \n void TTable::Merge(TIntrusiveConstPtr<TTxStatusPart> txStatus) noexcept\n@@ -601,6 +636,7 @@ void TTable::Merge(TIntrusiveConstPtr<TTxStatusPart> txStatus) noexcept\n         if (!TxRefs.contains(txId)) {\n             CheckTransactions.insert(txId);\n         }\n+        DecidedTransactions.Add(txId);\n         OpenTxs.erase(txId);\n     }\n     for (auto& item : txStatus->TxStatusPage->GetRemovedItems()) {\n@@ -611,6 +647,7 @@ void TTable::Merge(TIntrusiveConstPtr<TTxStatusPart> txStatus) noexcept\n         if (!TxRefs.contains(txId)) {\n             CheckTransactions.insert(txId);\n         }\n+        DecidedTransactions.Add(txId);\n         OpenTxs.erase(txId);\n     }\n \n@@ -627,7 +664,9 @@ void TTable::Merge(TIntrusiveConstPtr<TTxStatusPart> txStatus) noexcept\n     auto res = TxStatus.emplace(txStatus->Label, txStatus);\n     Y_ABORT_UNLESS(res.second, \"Unexpected failure to add a new TTxStatusPart\");\n \n-    ErasedKeysCache.Reset();\n+    // Note: Merge is called when borrowing data, but new tx status may commit\n+    // or rollback some transactions, and erase cache already accounts for that\n+    // eventuality, so doesn't need to be invalidated.\n }\n \n void TTable::ProcessCheckTransactions() noexcept\n@@ -638,6 +677,7 @@ void TTable::ProcessCheckTransactions() noexcept\n             if (it == TxRefs.end()) {\n                 CommittedTransactions.Remove(txId);\n                 RemovedTransactions.Remove(txId);\n+                DecidedTransactions.Remove(txId);\n             }\n         }\n         CheckTransactions.clear();\n@@ -825,7 +865,7 @@ void TTable::Update(ERowOp rop, TRawVals key, TOpsRef ops, TArrayRef<const TMemG\n         const TCelled cells(key, *Scheme->Keys, true);\n         auto res = ErasedKeysCache->FindKey(cells);\n         if (res.second) {\n-            ErasedKeysCache->Invalidate(res.first);\n+            ErasedKeysCache->InvalidateKey(res.first, cells);\n         }\n     }\n \n@@ -842,6 +882,8 @@ void TTable::AddTxRef(ui64 txId)\n     if (addOpenTx) {\n         auto res = OpenTxs.insert(txId);\n         Y_ABORT_UNLESS(res.second);\n+        Y_DEBUG_ABORT_UNLESS(!DecidedTransactions.Contains(txId),\n+            \"Decided transaction %\" PRIu64 \" is both open and decided\", txId);\n     }\n     if (RollbackState) {\n         RollbackOps.emplace_back(TRollbackRemoveTxRef{ txId });\n@@ -856,6 +898,14 @@ void TTable::UpdateTx(ERowOp rop, TRawVals key, TOpsRef ops, TArrayRef<const TMe\n     auto& memTable = MemTable();\n     bool hadTxRef = memTable.GetTxIdStats().contains(txId);\n \n+    if (ErasedKeysCache && rop != ERowOp::Erase) {\n+        const TCelled cells(key, *Scheme->Keys, true);\n+        auto res = ErasedKeysCache->FindKey(cells);\n+        if (res.second) {\n+            ErasedKeysCache->InvalidateKey(res.first, cells);\n+        }\n+    }\n+\n     // Use a special row version that marks this update as uncommitted\n     TRowVersion rowVersion(Max<ui64>(), txId);\n     MemTable().Update(rop, key, ops, apart, rowVersion, CommittedTransactions);\n@@ -897,13 +947,15 @@ void TTable::CommitTx(ui64 txId, TRowVersion rowVersion)\n         if (auto it = OpenTxs.find(txId); it != OpenTxs.end()) {\n             if (RollbackState) {\n                 RollbackOps.emplace_back(TRollbackAddOpenTx{ txId });\n+                CommitOps.emplace_back(TCommitAddDecidedTx{ txId });\n+            } else {\n+                DecidedTransactions.Add(txId);\n             }\n             OpenTxs.erase(it);\n         }\n     }\n \n-    // We don't know which keys have been commited, invalidate everything\n-    ErasedKeysCache.Reset();\n+    // Note: erase cache accounts for changes that may commit, no need to invalidate\n }\n \n void TTable::RemoveTx(ui64 txId)\n@@ -922,6 +974,9 @@ void TTable::RemoveTx(ui64 txId)\n         if (auto it = OpenTxs.find(txId); it != OpenTxs.end()) {\n             if (RollbackState) {\n                 RollbackOps.emplace_back(TRollbackAddOpenTx{ txId });\n+                CommitOps.emplace_back(TCommitAddDecidedTx{ txId });\n+            } else {\n+                DecidedTransactions.Add(txId);\n             }\n             OpenTxs.erase(it);\n         }\n@@ -963,6 +1018,11 @@ TMemTable& TTable::MemTable()\n     if (!Mutable) {\n         Mutable = new TMemTable(Scheme, Epoch, Annexed);\n     }\n+    if (RollbackState) {\n+        // MemTable() is only called when we want to apply updates\n+        // Make sure we don't taint erase cache with changes that may rollback\n+        RollbackState->DisableEraseCache = true;\n+    }\n     if (RollbackState && Epoch == RollbackState->Epoch && RollbackState->MutableExisted) {\n         if (!RollbackState->MutableUpdated) {\n             RollbackState->MutableUpdated = true;\n@@ -1009,11 +1069,12 @@ TAutoPtr<TTableIter> TTable::Iterate(TRawVals key_, TTagsRef tags, IPages* env,\n         }\n     }\n \n-    if (EraseCacheEnabled && !visible) {\n+    if (EraseCacheEnabled && (!RollbackState || !RollbackState->DisableEraseCache)) {\n         if (!ErasedKeysCache) {\n-            ErasedKeysCache = new TKeyRangeCache(*Scheme->Keys, EraseCacheConfig);\n+            ErasedKeysCache = new TKeyRangeCache(*Scheme->Keys, EraseCacheConfig, EraseCacheGCList);\n         }\n         dbIter->ErasedKeysCache = ErasedKeysCache;\n+        dbIter->DecidedTransactions = DecidedTransactions;\n     }\n \n     return dbIter;\n@@ -1056,11 +1117,12 @@ TAutoPtr<TTableReverseIter> TTable::IterateReverse(TRawVals key_, TTagsRef tags,\n         }\n     }\n \n-    if (EraseCacheEnabled && !visible) {\n+    if (EraseCacheEnabled && (!RollbackState || !RollbackState->DisableEraseCache)) {\n         if (!ErasedKeysCache) {\n-            ErasedKeysCache = new TKeyRangeCache(*Scheme->Keys, EraseCacheConfig);\n+            ErasedKeysCache = new TKeyRangeCache(*Scheme->Keys, EraseCacheConfig, EraseCacheGCList);\n         }\n         dbIter->ErasedKeysCache = ErasedKeysCache;\n+        dbIter->DecidedTransactions = DecidedTransactions;\n     }\n \n     return dbIter;\n@@ -1098,7 +1160,7 @@ EReady TTable::Select(TRawVals key_, TTagsRef tags, IPages* env, TRowState& row,\n     if (Mutable) {\n         lastEpoch = Mutable->Epoch;\n         if (auto it = TMemIter::Make(*Mutable, Mutable->Immediate(), key, ESeek::Exact, Scheme->Keys, &remap, env, EDirection::Forward)) {\n-            if (it->IsValid() && (snapshotFound || it->SkipToRowVersion(snapshot, stats, committed, observer))) {\n+            if (it->IsValid() && (snapshotFound || it->SkipToRowVersion(snapshot, stats, committed, observer, DecidedTransactions))) {\n                 // N.B. stop looking for snapshot after the first hit\n                 snapshotFound = true;\n                 it->Apply(row, committed, observer);\n@@ -1110,7 +1172,7 @@ EReady TTable::Select(TRawVals key_, TTagsRef tags, IPages* env, TRowState& row,\n     if (MutableBackup && !row.IsFinalized()) {\n         lastEpoch = MutableBackup->Epoch;\n         if (auto it = TMemIter::Make(*MutableBackup, MutableBackup->Immediate(), key, ESeek::Exact, Scheme->Keys, &remap, env, EDirection::Forward)) {\n-            if (it->IsValid() && (snapshotFound || it->SkipToRowVersion(snapshot, stats, committed, observer))) {\n+            if (it->IsValid() && (snapshotFound || it->SkipToRowVersion(snapshot, stats, committed, observer, DecidedTransactions))) {\n                 // N.B. stop looking for snapshot after the first hit\n                 snapshotFound = true;\n                 it->Apply(row, committed, observer);\n@@ -1124,7 +1186,7 @@ EReady TTable::Select(TRawVals key_, TTagsRef tags, IPages* env, TRowState& row,\n         Y_ABORT_UNLESS(lastEpoch > memTable->Epoch, \"Ordering of epochs is incorrect\");\n         lastEpoch = memTable->Epoch;\n         if (auto it = TMemIter::Make(*memTable, memTable->Immediate(), key, ESeek::Exact, Scheme->Keys, &remap, env, EDirection::Forward)) {\n-            if (it->IsValid() && (snapshotFound || it->SkipToRowVersion(snapshot, stats, committed, observer))) {\n+            if (it->IsValid() && (snapshotFound || it->SkipToRowVersion(snapshot, stats, committed, observer, DecidedTransactions))) {\n                 // N.B. stop looking for snapshot after the first hit\n                 snapshotFound = true;\n                 it->Apply(row, committed, observer);\n@@ -1150,7 +1212,7 @@ EReady TTable::Select(TRawVals key_, TTagsRef tags, IPages* env, TRowState& row,\n                         Y_ABORT_UNLESS(lastEpoch > part->Epoch, \"Ordering of epochs is incorrect\");\n                         lastEpoch = part->Epoch;\n                         if (!snapshotFound) {\n-                            res = it.SkipToRowVersion(snapshot, stats, committed, observer);\n+                            res = it.SkipToRowVersion(snapshot, stats, committed, observer, DecidedTransactions);\n                             if (res == EReady::Data) {\n                                 // N.B. stop looking for snapshot after the first hit\n                                 snapshotFound = true;\ndiff --git a/ydb/core/tablet_flat/flat_table.h b/ydb/core/tablet_flat/flat_table.h\nindex 47f8567527bc..24af7c23d346 100644\n--- a/ydb/core/tablet_flat/flat_table.h\n+++ b/ydb/core/tablet_flat/flat_table.h\n@@ -31,6 +31,7 @@ namespace NTable {\n \n class TTableEpochs;\n class TKeyRangeCache;\n+class TKeyRangeCacheNeedGCList;\n \n class TTable: public TAtomicRefCount<TTable> {\n public:\n@@ -64,7 +65,7 @@ class TTable: public TAtomicRefCount<TTable> {\n         TIteratorStats Stats;\n     };\n \n-    explicit TTable(TEpoch);\n+    explicit TTable(TEpoch, const TIntrusivePtr<TKeyRangeCacheNeedGCList>& gcList = nullptr);\n     ~TTable();\n \n     void PrepareRollback();\n@@ -351,6 +352,7 @@ class TTable: public TAtomicRefCount<TTable> {\n \n     bool EraseCacheEnabled = false;\n     TKeyRangeCacheConfig EraseCacheConfig;\n+    const TIntrusivePtr<TKeyRangeCacheNeedGCList> EraseCacheGCList;\n \n     TRowVersionRanges RemovedRowVersions;\n \n@@ -359,6 +361,7 @@ class TTable: public TAtomicRefCount<TTable> {\n     absl::flat_hash_set<ui64> CheckTransactions;\n     TTransactionMap CommittedTransactions;\n     TTransactionSet RemovedTransactions;\n+    TTransactionSet DecidedTransactions;\n     TIntrusivePtr<ITableObserver> TableObserver;\n \n private:\n@@ -400,6 +403,13 @@ class TTable: public TAtomicRefCount<TTable> {\n         TRollbackAddOpenTx,\n         TRollbackRemoveOpenTx>;\n \n+    struct TCommitAddDecidedTx {\n+        ui64 TxId;\n+    };\n+\n+    using TCommitOp = std::variant<\n+        TCommitAddDecidedTx>;\n+\n     struct TRollbackState {\n         TEpoch Epoch;\n         TIntrusiveConstPtr<TRowScheme> Scheme;\n@@ -408,6 +418,7 @@ class TTable: public TAtomicRefCount<TTable> {\n         bool EraseCacheEnabled;\n         bool MutableExisted;\n         bool MutableUpdated;\n+        bool DisableEraseCache;\n \n         TRollbackState(TEpoch epoch)\n             : Epoch(epoch)\n@@ -415,6 +426,7 @@ class TTable: public TAtomicRefCount<TTable> {\n     };\n \n     std::optional<TRollbackState> RollbackState;\n+    std::vector<TCommitOp> CommitOps;\n     std::vector<TRollbackOp> RollbackOps;\n     TIntrusivePtr<TMemTable> MutableBackup;\n };\ndiff --git a/ydb/core/tablet_flat/flat_table_committed.cpp b/ydb/core/tablet_flat/flat_table_committed.cpp\nnew file mode 100644\nindex 000000000000..80a85d39ce0f\n--- /dev/null\n+++ b/ydb/core/tablet_flat/flat_table_committed.cpp\n@@ -0,0 +1,15 @@\n+#include \"flat_table_committed.h\"\n+\n+namespace NKikimr::NTable {\n+\n+    class TEmptyTransactionSet : public ITransactionSet {\n+    public:\n+        bool Contains(ui64) const {\n+            return false;\n+        }\n+    };\n+\n+    // Note: binding to reference extends the object lifetime\n+    const ITransactionSet& ITransactionSet::None = TEmptyTransactionSet();\n+\n+} // namespace NKikimr::NTable\ndiff --git a/ydb/core/tablet_flat/flat_table_committed.h b/ydb/core/tablet_flat/flat_table_committed.h\nindex 8cb202c60fb7..8df020d59f3b 100644\n--- a/ydb/core/tablet_flat/flat_table_committed.h\n+++ b/ydb/core/tablet_flat/flat_table_committed.h\n@@ -290,6 +290,26 @@ namespace NTable {\n         TIntrusivePtr<TState> State_;\n     };\n \n+    /**\n+     * An interface for a collection of TxIds\n+     */\n+    class ITransactionSet {\n+    protected:\n+        ~ITransactionSet() = default;\n+\n+    public:\n+        /**\n+         * Returns true when the specified txId is in the set\n+         */\n+        virtual bool Contains(ui64 txId) const = 0;\n+\n+    public:\n+        /**\n+         * A special read-only object that implements an empty transaction set\n+         */\n+        static const ITransactionSet& None;\n+    };\n+\n     /**\n      * A simple copy-on-write data structure for a TxId set\n      */\n@@ -297,7 +317,14 @@ namespace NTable {\n     private:\n         using TTxSet = absl::flat_hash_set<ui64>;\n \n-        struct TState : public TThrRefBase, TTxSet {\n+        struct TState final\n+            : public TThrRefBase\n+            , public ITransactionSet\n+            , public TTxSet\n+        {\n+            bool Contains(ui64 txId) const override {\n+                return TTxSet::contains(txId);\n+            }\n         };\n \n     public:\n@@ -328,6 +355,14 @@ namespace NTable {\n             }\n         }\n \n+        operator const ITransactionSet&() const {\n+            if (State_) {\n+                return *State_;\n+            } else {\n+                return ITransactionSet::None;\n+            }\n+        }\n+\n     public:\n         const_iterator begin() const {\n             if (State_) {\ndiff --git a/ydb/core/tablet_flat/flat_table_stats.h b/ydb/core/tablet_flat/flat_table_stats.h\nindex a83e1f7bcbd6..172c777ac3dd 100644\n--- a/ydb/core/tablet_flat/flat_table_stats.h\n+++ b/ydb/core/tablet_flat/flat_table_stats.h\n@@ -34,6 +34,11 @@ namespace NTable {\n     struct TIteratorStats {\n         ui64 DeletedRowSkips = 0;\n         ui64 InvisibleRowSkips = 0;\n+        // When true an observed erase may possibly change due to undecided or\n+        // skipped changes above. This is a special case to simplify erase\n+        // cache updates, i.e. when UncertainErase is true observed erases\n+        // cannot be cached, since it might change in a different query.\n+        bool UncertainErase = false;\n     };\n \n     struct TSelectStats : TIteratorStats {\ndiff --git a/ydb/core/tablet_flat/ut/ut_db_iface.cpp b/ydb/core/tablet_flat/ut/ut_db_iface.cpp\nindex ebfee8e134fc..b82252553f46 100644\n--- a/ydb/core/tablet_flat/ut/ut_db_iface.cpp\n+++ b/ydb/core/tablet_flat/ut/ut_db_iface.cpp\n@@ -821,7 +821,7 @@ Y_UNIT_TEST_SUITE(DBase) {\n         me.WriteVer({4, 50}).Put(table, *me.SchemedCookRow(table).Col(9_u64, 9_u64));\n         me.Commit();\n \n-        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ }\");\n+        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {9}) }\");\n \n         // Verify we can only see 2 last rows at v3/50 (erased range shouldn't be cached incorrectly)\n         me.To(24).ReadVer({3, 50}).IterData(table)\n@@ -829,7 +829,7 @@ Y_UNIT_TEST_SUITE(DBase) {\n             .Next().Is(*me.SchemedCookRow(table).Col(18_u64, 18_u64))\n             .Next().Is(EReady::Gone);\n \n-        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {8}], [{10}, {16}] }\");\n+        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {9}), [{10}, {16}] }\");\n \n         // Verify we can see all 3 rows at v5/50 (bug would cause as to skip over the key 9)\n         me.To(25).ReadVer({5, 50}).IterData(table)\n@@ -839,6 +839,106 @@ Y_UNIT_TEST_SUITE(DBase) {\n             .Next().Is(EReady::Gone);\n     }\n \n+    void TestEraseCacheWithUncommittedChanges(bool compact) {\n+        TDbExec me;\n+\n+        const ui32 table = 1;\n+        me.To(10)\n+            .Begin()\n+            .Apply(*TAlter()\n+                .AddTable(\"me_1\", table)\n+                .AddColumn(table, \"key\", 1, ETypes::Uint64, false)\n+                .AddColumn(table, \"val\", 2, ETypes::Uint64, false, Cimple(0_u64))\n+                .AddColumnToKey(table, 1)\n+                .SetEraseCache(table, true, 2, 8192))\n+            .Commit();\n+\n+        auto dumpCache = [&]() -> TString {\n+            if (auto* cache = me->DebugGetTableErasedKeysCache(table)) {\n+                TStringStream stream;\n+                stream << cache->DumpRanges();\n+                return stream.Str();\n+            } else {\n+                return nullptr;\n+            }\n+        };\n+\n+        // Write a bunch of rows at v1/50\n+        me.To(20).Begin();\n+        for (ui64 i = 1; i <= 18; ++i) {\n+            if (i != 9) {\n+                me.WriteVer({1, 50}).Put(table, *me.SchemedCookRow(table).Col(i, i));\n+            }\n+        }\n+        me.Commit();\n+        if (compact) {\n+            me.Compact(table, false);\n+        }\n+\n+        // Erase a bunch of rows at v2/50\n+        me.To(21).Begin();\n+        for (ui64 i = 1; i <= 16; ++i) {\n+            if (i != 9) {\n+                me.WriteVer({2, 50}).Add(table, *me.SchemedCookRow(table).Col(i), ERowOp::Erase);\n+            }\n+        }\n+        me.Commit();\n+        if (compact) {\n+            me.Compact(table, false);\n+        }\n+\n+        // Verify we can only see 2 last rows at v3/50 (all other are deleted)\n+        me.To(22).ReadVer({3, 50}).IterData(table)\n+            .Seek({ }, ESeek::Lower).Is(*me.SchemedCookRow(table).Col(17_u64, 17_u64))\n+            .Next().Is(*me.SchemedCookRow(table).Col(18_u64, 18_u64))\n+            .Next().Is(EReady::Gone);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {16}] }\");\n+\n+        // Write an uncommitted row in tx 123\n+        me.To(23).Begin();\n+        me.WriteTx(123).Put(table, *me.SchemedCookRow(table).Col(9_u64, 9_u64));\n+        me.Commit();\n+        if (compact) {\n+            me.Compact(table, false);\n+        }\n+\n+        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {9}) }\");\n+\n+        // Verify we can only see all 3 rows in tx 123 and erase cache is correct\n+        me.To(24).ReadTx(123).IterData(table)\n+            .Seek({ }, ESeek::Lower).Is(*me.SchemedCookRow(table).Col(9_u64, 9_u64))\n+            .Next().Is(*me.SchemedCookRow(table).Col(17_u64, 17_u64))\n+            .Next().Is(*me.SchemedCookRow(table).Col(18_u64, 18_u64))\n+            .Next().Is(EReady::Gone);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {9}), [{10}, {16}] }\");\n+\n+        // Rollback tx 123\n+        me.To(25).Begin();\n+        me.RemoveTx(table, 123);\n+        me.Commit();\n+        if (compact) {\n+            me.Compact(table, false);\n+        }\n+\n+        // Verify we can only see 2 last rows at v3/50 (all other are deleted)\n+        me.To(26).ReadVer({3, 50}).IterData(table)\n+            .Seek({ }, ESeek::Lower).Is(*me.SchemedCookRow(table).Col(17_u64, 17_u64))\n+            .Next().Is(*me.SchemedCookRow(table).Col(18_u64, 18_u64))\n+            .Next().Is(EReady::Gone);\n+\n+        UNIT_ASSERT_VALUES_EQUAL(dumpCache(), \"TKeyRangeCache{ [{1}, {16}] }\");\n+    }\n+\n+    Y_UNIT_TEST(EraseCacheWithUncommittedChanges) {\n+        TestEraseCacheWithUncommittedChanges(false);\n+    }\n+\n+    Y_UNIT_TEST(EraseCacheWithUncommittedChangesCompacted) {\n+        TestEraseCacheWithUncommittedChanges(true);\n+    }\n+\n     Y_UNIT_TEST(AlterAndUpsertChangesVisibility) {\n         TDbExec me;\n \ndiff --git a/ydb/core/tablet_flat/ya.make b/ydb/core/tablet_flat/ya.make\nindex 1512b90c5d5b..e5f02f16af21 100644\n--- a/ydb/core/tablet_flat/ya.make\n+++ b/ydb/core/tablet_flat/ya.make\n@@ -65,6 +65,8 @@ SRCS(\n     flat_table_misc.cpp\n     flat_table_observer.cpp\n     flat_table_observer.h\n+    flat_table_committed.cpp\n+    flat_table_committed.h\n     flat_update_op.h\n     probes.cpp\n     shared_handle.cpp\n",
  "test_patch": "diff --git a/ydb/core/tablet_flat/test/libs/table/wrap_part.h b/ydb/core/tablet_flat/test/libs/table/wrap_part.h\nindex 5bc92e9d68d8..6d90e7b820f4 100644\n--- a/ydb/core/tablet_flat/test/libs/table/wrap_part.h\n+++ b/ydb/core/tablet_flat/test/libs/table/wrap_part.h\n@@ -104,7 +104,8 @@ namespace NTest {\n         EReady SkipToRowVersion(TRowVersion rowVersion) noexcept\n         {\n             TIteratorStats stats;\n-            Ready = Iter->SkipToRowVersion(rowVersion, stats, /* committed */ nullptr, /* observer */ nullptr);\n+            Ready = Iter->SkipToRowVersion(rowVersion, stats, /* committed */ nullptr, /* observer */ nullptr,\n+                /* decided */ ITransactionSet::None);\n \n             if (Ready == EReady::Data)\n                 Ready = RollUp();\n",
  "problem_statement": "LocalDB: erase cache doesn't work with volatile transactions\nWhen table is used to store some deadline queue, i.e. new events are inserted into the table and current head is queried using a range query, we have a problem with skipping tombstones:\r\n\r\n* A large deleted range at the front is cached until some key `K` (the last known deleted key)\r\n* When a new event is inserted just before `K` it invalidates the whole range, i.e. when events are inserted just a little bit \"out of order\" it makes erase cache useless\r\n* Worse, when datashard uses uncommitted changes (e.g. volatile transactions), it also specifies a custom transaction map, which disables erase cache (since it cannot be reliably updated and cannot be fully trusted due to possible changes by a custom transaction map).\r\n\r\nWe need a way for erase cache to reflect a fully committed state that cannot be modified by custom transaction maps, as well as make it possible to partially invalidate cached ranges. Some edge cases:\r\n\r\n* We only cache non-trivial ranges (e.g. those that allow skipping more than 16 keys), but it is possible that a truncated range would become trivial, slowing down iteration instead of helping. We need a way to measure whether a range actually helped to skip enough rows, and remove useless ranges.\r\n* We need a way to detect whether iteration encounters any non-persistent uncommitted changes at the top of a merged state, and skip those keys even when the final state is a tombstone. However LocalDB also uses tx map for committed changes until they are compacted internally, and those we want to cache. So we might need to use multiple tx maps (i.e. check internal map first, and only then use custom maps), which may be a bit slower.\n",
  "hints_text": "",
  "created_at": "2024-06-06T15:06:15Z",
  "modified_files": [
    "ydb/core/tablet_flat/flat_database.cpp",
    "ydb/core/tablet_flat/flat_database.h",
    "ydb/core/tablet_flat/flat_dbase_naked.h",
    "ydb/core/tablet_flat/flat_iterator.h",
    "ydb/core/tablet_flat/flat_mem_iter.h",
    "ydb/core/tablet_flat/flat_part_iter.h",
    "ydb/core/tablet_flat/flat_range_cache.cpp",
    "ydb/core/tablet_flat/flat_range_cache.h",
    "ydb/core/tablet_flat/flat_range_cache_ut.cpp",
    "ydb/core/tablet_flat/flat_table.cpp",
    "ydb/core/tablet_flat/flat_table.h",
    "b/ydb/core/tablet_flat/flat_table_committed.cpp",
    "ydb/core/tablet_flat/flat_table_committed.h",
    "ydb/core/tablet_flat/flat_table_stats.h",
    "ydb/core/tablet_flat/ut/ut_db_iface.cpp",
    "ydb/core/tablet_flat/ya.make"
  ],
  "modified_test_files": [
    "ydb/core/tablet_flat/test/libs/table/wrap_part.h"
  ]
}