{
  "repo": "ydb-platform/ydb",
  "pull_number": 10707,
  "instance_id": "ydb-platform__ydb-10707",
  "issue_numbers": [
    "10647"
  ],
  "base_commit": "94d1ae038caea44886f47fa5354b13e72eb7736a",
  "patch": "diff --git a/ydb/library/yql/core/type_ann/type_ann_blocks.cpp b/ydb/library/yql/core/type_ann/type_ann_blocks.cpp\nindex f37baa83439c..234c2c6dc960 100644\n--- a/ydb/library/yql/core/type_ann/type_ann_blocks.cpp\n+++ b/ydb/library/yql/core/type_ann/type_ann_blocks.cpp\n@@ -791,7 +791,7 @@ IGraphTransformer::TStatus BlockCombineAllWrapper(const TExprNode::TPtr& input,\n     }\n \n     TTypeAnnotationNode::TListType blockItemTypes;\n-    if (!EnsureWideFlowBlockType(input->Head(), blockItemTypes, ctx.Expr)) {\n+    if (!EnsureWideStreamBlockType(input->Head(), blockItemTypes, ctx.Expr)) {\n         return IGraphTransformer::TStatus::Error;\n     }\n \n@@ -817,7 +817,7 @@ IGraphTransformer::TStatus BlockCombineAllWrapper(const TExprNode::TPtr& input,\n     }\n \n     auto outputItemType = ctx.Expr.MakeType<TMultiExprType>(retMultiType);\n-    input->SetTypeAnn(ctx.Expr.MakeType<TFlowExprType>(outputItemType));\n+    input->SetTypeAnn(ctx.Expr.MakeType<TStreamExprType>(outputItemType));\n     return IGraphTransformer::TStatus::Ok;\n }\n \n@@ -828,7 +828,7 @@ IGraphTransformer::TStatus BlockCombineHashedWrapper(const TExprNode::TPtr& inpu\n     }\n \n     TTypeAnnotationNode::TListType blockItemTypes;\n-    if (!EnsureWideFlowBlockType(input->Head(), blockItemTypes, ctx.Expr)) {\n+    if (!EnsureWideStreamBlockType(input->Head(), blockItemTypes, ctx.Expr)) {\n         return IGraphTransformer::TStatus::Error;\n     }\n \n@@ -867,7 +867,7 @@ IGraphTransformer::TStatus BlockCombineHashedWrapper(const TExprNode::TPtr& inpu\n \n     retMultiType.push_back(ctx.Expr.MakeType<TScalarExprType>(ctx.Expr.MakeType<TDataExprType>(EDataSlot::Uint64)));\n     auto outputItemType = ctx.Expr.MakeType<TMultiExprType>(retMultiType);\n-    input->SetTypeAnn(ctx.Expr.MakeType<TFlowExprType>(outputItemType));\n+    input->SetTypeAnn(ctx.Expr.MakeType<TStreamExprType>(outputItemType));\n     return IGraphTransformer::TStatus::Ok;\n }\n \n@@ -879,7 +879,7 @@ IGraphTransformer::TStatus BlockMergeFinalizeHashedWrapper(const TExprNode::TPtr\n     }\n \n     TTypeAnnotationNode::TListType blockItemTypes;\n-    if (!EnsureWideFlowBlockType(input->Head(), blockItemTypes, ctx.Expr)) {\n+    if (!EnsureWideStreamBlockType(input->Head(), blockItemTypes, ctx.Expr)) {\n         return IGraphTransformer::TStatus::Error;\n     }\n     YQL_ENSURE(blockItemTypes.size() > 0);\n@@ -917,7 +917,7 @@ IGraphTransformer::TStatus BlockMergeFinalizeHashedWrapper(const TExprNode::TPtr\n         }\n \n         // disallow any scalar columns except for streamIndex column\n-        auto itemTypes = input->Head().GetTypeAnn()->Cast<TFlowExprType>()->GetItemType()->Cast<TMultiExprType>()->GetItems();\n+        auto itemTypes = input->Head().GetTypeAnn()->Cast<TStreamExprType>()->GetItemType()->Cast<TMultiExprType>()->GetItems();\n         for (ui32 i = 0; i + 1 < itemTypes.size(); ++i) {\n             bool isScalar = itemTypes[i]->GetKind() == ETypeAnnotationKind::Scalar;\n             if (isScalar && i != streamIndex) {\n@@ -929,7 +929,7 @@ IGraphTransformer::TStatus BlockMergeFinalizeHashedWrapper(const TExprNode::TPtr\n \n     retMultiType.push_back(ctx.Expr.MakeType<TScalarExprType>(ctx.Expr.MakeType<TDataExprType>(EDataSlot::Uint64)));\n     auto outputItemType = ctx.Expr.MakeType<TMultiExprType>(retMultiType);\n-    input->SetTypeAnn(ctx.Expr.MakeType<TFlowExprType>(outputItemType));\n+    input->SetTypeAnn(ctx.Expr.MakeType<TStreamExprType>(outputItemType));\n     return IGraphTransformer::TStatus::Ok;\n }\n \ndiff --git a/ydb/library/yql/core/yql_aggregate_expander.cpp b/ydb/library/yql/core/yql_aggregate_expander.cpp\nindex 12714671b67a..a4c7df599ebc 100644\n--- a/ydb/library/yql/core/yql_aggregate_expander.cpp\n+++ b/ydb/library/yql/core/yql_aggregate_expander.cpp\n@@ -699,7 +699,8 @@ TExprNode::TPtr TAggregateExpander::TryGenerateBlockCombineAllOrHashed() {\n     } else {\n         stream = AggList;\n     }\n-    auto blocks = MakeInputBlocks(stream, keyIdxs, outputColumns, aggs, false, false);\n+    \n+    TExprNode::TPtr blocks = MakeInputBlocks(stream, keyIdxs, outputColumns, aggs, false, false);\n     if (!blocks) {\n         return nullptr;\n     }\n@@ -708,22 +709,30 @@ TExprNode::TPtr TAggregateExpander::TryGenerateBlockCombineAllOrHashed() {\n     if (hashed) {\n         aggWideFlow = Ctx.Builder(Node->Pos())\n             .Callable(\"WideFromBlocks\")\n-                .Callable(0, \"BlockCombineHashed\")\n-                    .Add(0, blocks)\n-                    .Callable(1, \"Void\")\n+                .Callable(0, \"ToFlow\")\n+                    .Callable(0, \"BlockCombineHashed\")\n+                        .Callable(0, \"FromFlow\")\n+                            .Add(0, blocks)\n+                            .Seal()\n+                        .Callable(1, \"Void\")\n+                        .Seal()\n+                        .Add(2, Ctx.NewList(Node->Pos(), std::move(keyIdxs)))\n+                        .Add(3, Ctx.NewList(Node->Pos(), std::move(aggs)))\n                     .Seal()\n-                    .Add(2, Ctx.NewList(Node->Pos(), std::move(keyIdxs)))\n-                    .Add(3, Ctx.NewList(Node->Pos(), std::move(aggs)))\n                 .Seal()\n             .Seal()\n             .Build();\n     } else {\n         aggWideFlow = Ctx.Builder(Node->Pos())\n-            .Callable(\"BlockCombineAll\")\n-                .Add(0, blocks)\n-                .Callable(1, \"Void\")\n+            .Callable(\"ToFlow\")\n+                .Callable(0, \"BlockCombineAll\")\n+                    .Callable(0, \"FromFlow\")\n+                        .Add(0, blocks)\n+                        .Seal()\n+                    .Callable(1, \"Void\")\n+                    .Seal()\n+                    .Add(2, Ctx.NewList(Node->Pos(), std::move(aggs)))\n                 .Seal()\n-                .Add(2, Ctx.NewList(Node->Pos(), std::move(aggs)))\n             .Seal()\n             .Build();\n     }\n@@ -2891,10 +2900,14 @@ TExprNode::TPtr TAggregateExpander::TryGenerateBlockMergeFinalizeHashed() {\n     TExprNode::TPtr aggBlocks;\n     if (!isMany) {\n         aggBlocks = Ctx.Builder(Node->Pos())\n-            .Callable(\"BlockMergeFinalizeHashed\")\n-                .Add(0, blocks)\n-                .Add(1, Ctx.NewList(Node->Pos(), std::move(keyIdxs)))\n-                .Add(2, Ctx.NewList(Node->Pos(), std::move(aggs)))\n+            .Callable(\"ToFlow\")\n+                .Callable(0, \"BlockMergeFinalizeHashed\")\n+                    .Callable(0, \"FromFlow\")\n+                        .Add(0, blocks)\n+                    .Seal()\n+                    .Add(1, Ctx.NewList(Node->Pos(), std::move(keyIdxs)))\n+                    .Add(2, Ctx.NewList(Node->Pos(), std::move(aggs)))\n+                .Seal()\n             .Seal()\n             .Build();\n     } else {\n@@ -2902,12 +2915,16 @@ TExprNode::TPtr TAggregateExpander::TryGenerateBlockMergeFinalizeHashed() {\n         YQL_ENSURE(manyStreamsSetting, \"Missing many_streams setting\");\n \n         aggBlocks = Ctx.Builder(Node->Pos())\n-            .Callable(\"BlockMergeManyFinalizeHashed\")\n-                .Add(0, blocks)\n-                .Add(1, Ctx.NewList(Node->Pos(), std::move(keyIdxs)))\n-                .Add(2, Ctx.NewList(Node->Pos(), std::move(aggs)))\n-                .Atom(3, ToString(streamIdxColumn))\n-                .Add(4, manyStreamsSetting->TailPtr())\n+            .Callable(\"ToFlow\")\n+                .Callable(0, \"BlockMergeManyFinalizeHashed\")\n+                    .Callable(0, \"FromFlow\")\n+                        .Add(0, blocks)\n+                    .Seal()\n+                    .Add(1, Ctx.NewList(Node->Pos(), std::move(keyIdxs)))\n+                    .Add(2, Ctx.NewList(Node->Pos(), std::move(aggs)))\n+                    .Atom(3, ToString(streamIdxColumn))\n+                    .Add(4, manyStreamsSetting->TailPtr())\n+                .Seal()\n             .Seal()\n             .Build();\n     }\ndiff --git a/ydb/library/yql/dq/opt/dq_opt_peephole.cpp b/ydb/library/yql/dq/opt/dq_opt_peephole.cpp\nindex c9b854971106..3b0b6079ec89 100644\n--- a/ydb/library/yql/dq/opt/dq_opt_peephole.cpp\n+++ b/ydb/library/yql/dq/opt/dq_opt_peephole.cpp\n@@ -786,16 +786,20 @@ NNodes::TExprBase DqPeepholeRewriteLength(const NNodes::TExprBase& node, TExprCo\n     if (typesCtx.IsBlockEngineEnabled()) {\n         return NNodes::TExprBase(ctx.Builder(node.Pos())\n             .Callable(\"NarrowMap\")\n-                .Callable(0, \"BlockCombineAll\")\n-                    .Callable(0, \"WideToBlocks\")\n-                        .Add(0, MakeExpandMap(node.Pos(), {}, dqPhyLength.Input().Ptr(), ctx))\n-                    .Seal()\n-                    .Callable(1, \"Void\")\n-                    .Seal()\n-                    .List(2)\n-                        .List(0)\n-                            .Callable(0, \"AggBlockApply\")\n-                                .Atom(0, \"count_all\")\n+                .Callable(0, \"ToFlow\")\n+                    .Callable(0, \"BlockCombineAll\")\n+                        .Callable(0, \"FromFlow\")\n+                            .Callable(0, \"WideToBlocks\")\n+                                .Add(0, MakeExpandMap(node.Pos(), {}, dqPhyLength.Input().Ptr(), ctx))\n+                            .Seal()\n+                        .Seal()\n+                        .Callable(1, \"Void\")\n+                        .Seal()\n+                        .List(2)\n+                            .List(0)\n+                                .Callable(0, \"AggBlockApply\")\n+                                    .Atom(0, \"count_all\")\n+                                .Seal()\n                             .Seal()\n                         .Seal()\n                     .Seal()\ndiff --git a/ydb/library/yql/minikql/comp_nodes/mkql_block_agg.cpp b/ydb/library/yql/minikql/comp_nodes/mkql_block_agg.cpp\nindex eb1ffcba560c..a1bef3ae63e4 100644\n--- a/ydb/library/yql/minikql/comp_nodes/mkql_block_agg.cpp\n+++ b/ydb/library/yql/minikql/comp_nodes/mkql_block_agg.cpp\n@@ -442,9 +442,20 @@ size_t GetBitmapPopCount(const std::shared_ptr<arrow::ArrayData>& arr) {\n     return GetSparseBitmapPopCount(src, len);\n }\n \n+TArrayRef<TType *const> GetWideComponents(TType* type) {\n+    if (type->IsFlow()) {\n+        const auto outputFlowType = AS_TYPE(TFlowType, type);\n+        return GetWideComponents(outputFlowType);\n+    }\n+    if (type->IsStream()) {\n+        const auto outputStreamType = AS_TYPE(TStreamType, type);\n+        return GetWideComponents(outputStreamType);\n+    }\n+    MKQL_ENSURE(false, \"Expect either flow or stream\");\n+}\n+\n size_t CalcMaxBlockLenForOutput(TType* out) {\n-    const auto outputType = AS_TYPE(TFlowType, out);\n-    const auto wideComponents = GetWideComponents(outputType);\n+    const auto wideComponents = GetWideComponents(out);\n     MKQL_ENSURE(wideComponents.size() > 0, \"Expecting at least one output column\");\n \n     size_t maxBlockItemSize = 0;\n@@ -604,11 +615,99 @@ class TBlockCombineAllWrapperCodegenBase {\n #endif\n };\n \n-class TBlockCombineAllWrapper : public TStatefulWideFlowCodegeneratorNode<TBlockCombineAllWrapper>,\n+\n+struct TBlockCombineAllState : public TComputationValue<TBlockCombineAllState> {\n+    NUdf::TUnboxedValue* Pointer_ = nullptr;\n+    bool IsFinished_ = false;\n+    bool HasValues_ = false;\n+    TUnboxedValueVector Values_;\n+    std::vector<std::unique_ptr<IBlockAggregatorCombineAll>> Aggs_;\n+    std::vector<char> AggStates_;\n+    const std::optional<ui32> FilterColumn_;\n+    const size_t Width_;\n+\n+    TBlockCombineAllState(TMemoryUsageInfo* memInfo, size_t width, std::optional<ui32> filterColumn, const std::vector<TAggParams<IBlockAggregatorCombineAll>>& params, TComputationContext& ctx)\n+        : TComputationValue(memInfo)\n+        , Values_(std::max(width, params.size()))\n+        , FilterColumn_(filterColumn)\n+        , Width_(width)\n+    {\n+        Pointer_ = Values_.data();\n+\n+        ui32 totalStateSize = 0;\n+        for (const auto& p : params) {\n+            Aggs_.emplace_back(p.Prepared_->Make(ctx));\n+            MKQL_ENSURE(Aggs_.back()->StateSize == p.Prepared_->StateSize, \"State size mismatch\");\n+            totalStateSize += Aggs_.back()->StateSize;\n+        }\n+\n+        AggStates_.resize(totalStateSize);\n+        char* ptr = AggStates_.data();\n+        for (const auto& agg : Aggs_) {\n+            agg->InitState(ptr);\n+            ptr += agg->StateSize;\n+        }\n+    }\n+\n+    void ProcessInput() {\n+        const ui64 batchLength = TArrowBlock::From(Values_[Width_ - 1U]).GetDatum().scalar_as<arrow::UInt64Scalar>().value;\n+        if (!batchLength) {\n+            return;\n+        }\n+\n+        std::optional<ui64> filtered;\n+        if (FilterColumn_) {\n+            const auto filterDatum = TArrowBlock::From(Values_[*FilterColumn_]).GetDatum();\n+            if (filterDatum.is_scalar()) {\n+                if (!filterDatum.scalar_as<arrow::UInt8Scalar>().value) {\n+                    return;\n+                }\n+            } else {\n+                const ui64 popCount = GetBitmapPopCount(filterDatum.array());\n+                if (popCount == 0) {\n+                    return;\n+                }\n+\n+                if (popCount < batchLength) {\n+                    filtered = popCount;\n+                }\n+            }\n+        }\n+\n+        HasValues_ = true;\n+        char* ptr = AggStates_.data();\n+        for (size_t i = 0; i < Aggs_.size(); ++i) {\n+            Aggs_[i]->AddMany(ptr, Values_.data(), batchLength, filtered);\n+            ptr += Aggs_[i]->StateSize;\n+        }\n+    }\n+\n+    bool MakeOutput() {\n+        IsFinished_ = true;\n+        if (!HasValues_)\n+            return false;\n+\n+        char* ptr = AggStates_.data();\n+        for (size_t i = 0; i < Aggs_.size(); ++i) {\n+            Values_[i] = Aggs_[i]->FinishOne(ptr);\n+            Aggs_[i]->DestroyState(ptr);\n+            ptr += Aggs_[i]->StateSize;\n+        }\n+        return true;\n+    }\n+\n+    NUdf::TUnboxedValuePod Get(size_t index) const {\n+        return Values_[index];\n+    }\n+};\n+\n+class TBlockCombineAllWrapperFromFlow : public TStatefulWideFlowCodegeneratorNode<TBlockCombineAllWrapperFromFlow>,\n     protected TBlockCombineAllWrapperCodegenBase {\n-using TBaseComputation = TStatefulWideFlowCodegeneratorNode<TBlockCombineAllWrapper>;\n+using TBaseComputation = TStatefulWideFlowCodegeneratorNode<TBlockCombineAllWrapperFromFlow>;\n+\n+using TState = TBlockCombineAllState;\n public:\n-    TBlockCombineAllWrapper(TComputationMutables& mutables,\n+    TBlockCombineAllWrapperFromFlow(TComputationMutables& mutables,\n         IComputationWideFlowNode* flow,\n         std::optional<ui32> filterColumn,\n         size_t width,\n@@ -655,95 +754,11 @@ using TBaseComputation = TStatefulWideFlowCodegeneratorNode<TBlockCombineAllWrap\n #ifndef MKQL_DISABLE_CODEGEN\n     ICodegeneratorInlineWideNode::TGenerateResult DoGenGetValues(const TCodegenContext& ctx, Value* statePtr, BasicBlock*& block) const {\n         return DoGenGetValuesImpl(ctx, statePtr, block, Flow_, Width_, AggsParams_.size(),\n-            GetMethodPtr(&TState::Get), GetMethodPtr(&TBlockCombineAllWrapper::MakeState),\n+            GetMethodPtr(&TState::Get), GetMethodPtr(&TBlockCombineAllWrapperFromFlow::MakeState),\n             GetMethodPtr(&TState::ProcessInput), GetMethodPtr(&TState::MakeOutput));\n     }\n #endif\n private:\n-    struct TState : public TComputationValue<TState> {\n-        NUdf::TUnboxedValue* Pointer_ = nullptr;\n-        bool IsFinished_ = false;\n-        bool HasValues_ = false;\n-        TUnboxedValueVector Values_;\n-        std::vector<std::unique_ptr<IBlockAggregatorCombineAll>> Aggs_;\n-        std::vector<char> AggStates_;\n-        const std::optional<ui32> FilterColumn_;\n-        const size_t Width_;\n-\n-        TState(TMemoryUsageInfo* memInfo, size_t width, std::optional<ui32> filterColumn, const std::vector<TAggParams<IBlockAggregatorCombineAll>>& params, TComputationContext& ctx)\n-            : TComputationValue(memInfo)\n-            , Values_(std::max(width, params.size()))\n-            , FilterColumn_(filterColumn)\n-            , Width_(width)\n-        {\n-            Pointer_ = Values_.data();\n-\n-            ui32 totalStateSize = 0;\n-            for (const auto& p : params) {\n-                Aggs_.emplace_back(p.Prepared_->Make(ctx));\n-                MKQL_ENSURE(Aggs_.back()->StateSize == p.Prepared_->StateSize, \"State size mismatch\");\n-                totalStateSize += Aggs_.back()->StateSize;\n-            }\n-\n-            AggStates_.resize(totalStateSize);\n-            char* ptr = AggStates_.data();\n-            for (const auto& agg : Aggs_) {\n-                agg->InitState(ptr);\n-                ptr += agg->StateSize;\n-            }\n-        }\n-\n-        void ProcessInput() {\n-            const ui64 batchLength = TArrowBlock::From(Values_[Width_ - 1U]).GetDatum().scalar_as<arrow::UInt64Scalar>().value;\n-            if (!batchLength) {\n-                return;\n-            }\n-\n-            std::optional<ui64> filtered;\n-            if (FilterColumn_) {\n-                const auto filterDatum = TArrowBlock::From(Values_[*FilterColumn_]).GetDatum();\n-                if (filterDatum.is_scalar()) {\n-                    if (!filterDatum.scalar_as<arrow::UInt8Scalar>().value) {\n-                        return;\n-                    }\n-                } else {\n-                    const ui64 popCount = GetBitmapPopCount(filterDatum.array());\n-                    if (popCount == 0) {\n-                        return;\n-                    }\n-\n-                    if (popCount < batchLength) {\n-                        filtered = popCount;\n-                    }\n-                }\n-            }\n-\n-            HasValues_ = true;\n-            char* ptr = AggStates_.data();\n-            for (size_t i = 0; i < Aggs_.size(); ++i) {\n-                Aggs_[i]->AddMany(ptr, Values_.data(), batchLength, filtered);\n-                ptr += Aggs_[i]->StateSize;\n-            }\n-        }\n-\n-        bool MakeOutput() {\n-            IsFinished_ = true;\n-            if (!HasValues_)\n-                return false;\n-\n-            char* ptr = AggStates_.data();\n-            for (size_t i = 0; i < Aggs_.size(); ++i) {\n-                Values_[i] = Aggs_[i]->FinishOne(ptr);\n-                Aggs_[i]->DestroyState(ptr);\n-                ptr += Aggs_[i]->StateSize;\n-            }\n-            return true;\n-        }\n-\n-        NUdf::TUnboxedValuePod Get(size_t index) const {\n-            return Values_[index];\n-        }\n-    };\n     void RegisterDependencies() const final {\n         FlowDependsOn(Flow_);\n     }\n@@ -773,6 +788,89 @@ using TBaseComputation = TStatefulWideFlowCodegeneratorNode<TBlockCombineAllWrap\n     const size_t WideFieldsIndex_;\n };\n \n+class TBlockCombineAllWrapperFromStream : public TMutableComputationNode<TBlockCombineAllWrapperFromStream> {\n+using TBaseComputation = TMutableComputationNode<TBlockCombineAllWrapperFromStream>;\n+\n+using TState = TBlockCombineAllState;\n+public:\n+    TBlockCombineAllWrapperFromStream(TComputationMutables& mutables,\n+        IComputationNode* stream,\n+        std::optional<ui32> filterColumn,\n+        size_t width,\n+        std::vector<TAggParams<IBlockAggregatorCombineAll>>&& aggsParams)\n+        : TBaseComputation(mutables, EValueRepresentation::Boxed)\n+        , Stream_(stream)\n+        , FilterColumn_(filterColumn)\n+        , Width_(width)\n+        , AggsParams_(std::move(aggsParams))\n+        , WideFieldsIndex_(mutables.IncrementWideFieldsIndex(width))\n+    {\n+        MKQL_ENSURE(Width_ > 0, \"Missing block length column\");\n+    }\n+\n+    NUdf::TUnboxedValuePod DoCalculate(TComputationContext& ctx) const\n+    {\n+        const auto state = ctx.HolderFactory.Create<TState>(Width_, FilterColumn_, AggsParams_, ctx);\n+        return ctx.HolderFactory.Create<TStreamValue>(std::move(state), std::move(Stream_->GetValue(ctx)));\n+    }\n+        \n+private:\n+    class TStreamValue : public TComputationValue<TStreamValue> {\n+    using TBase = TComputationValue<TStreamValue>;\n+    public:\n+        TStreamValue(TMemoryUsageInfo* memInfo, NUdf::TUnboxedValue&& state, NUdf::TUnboxedValue&& stream) \n+            : TBase(memInfo)\n+            , State_(state)\n+            , Stream_(stream)\n+        {\n+        }\n+\n+    private:\n+        NUdf::EFetchStatus WideFetch(NUdf::TUnboxedValue* output, ui32 width) {\n+            TState& state = *static_cast<TState*>(State_.AsBoxed().Get());\n+            auto* inputFields = state.Values_.data();\n+            const size_t inputWidth = state.Width_;\n+\n+            if (state.IsFinished_)\n+                return NUdf::EFetchStatus::Finish;\n+            \n+            while (true) {\n+                switch (Stream_.WideFetch(inputFields, inputWidth)) {\n+                    case NUdf::EFetchStatus::Yield:\n+                        return NUdf::EFetchStatus::Yield;\n+                    case NUdf::EFetchStatus::Ok:\n+                        state.ProcessInput();\n+                        continue;\n+                    case NUdf::EFetchStatus::Finish:\n+                        break;\n+                }\n+                if (state.MakeOutput()) {\n+                    for (size_t i = 0; i < width; ++i) {\n+                        output[i] = state.Get(i);\n+                    }\n+                    return NUdf::EFetchStatus::Ok;\n+                }\n+                return NUdf::EFetchStatus::Finish;\n+            }\n+        }\n+    private:\n+        NUdf::TUnboxedValue State_;\n+        NUdf::TUnboxedValue Stream_;\n+    };    \n+\n+private:\n+    void RegisterDependencies() const final {\n+        DependsOn(Stream_);\n+    }\n+\n+private:\n+    IComputationNode *const Stream_;\n+    const std::optional<ui32> FilterColumn_;\n+    const size_t Width_;\n+    const std::vector<TAggParams<IBlockAggregatorCombineAll>> AggsParams_;\n+    const size_t WideFieldsIndex_;\n+};\n+\n template <typename T>\n T MakeKey(TStringBuf s, ui32 keyLength) {\n     Y_UNUSED(keyLength);\n@@ -1050,585 +1148,594 @@ class THashedWrapperCodegenBase {\n };\n \n template <typename TKey, typename TAggregator, typename TFixedAggState, bool UseSet, bool UseFilter, bool Finalize, bool Many, typename TDerived>\n-class THashedWrapperBase : public TStatefulWideFlowCodegeneratorNode<TDerived>,\n-    protected THashedWrapperCodegenBase\n-{\n-    using TComputationBase = TStatefulWideFlowCodegeneratorNode<TDerived>;\n+struct THashedWrapperBaseState : public TBlockState {\n+private:\n     static constexpr bool UseArena = !InlineAggState && std::is_same<TFixedAggState, TStateArena>::value;\n public:\n-    THashedWrapperBase(TComputationMutables& mutables,\n-        IComputationWideFlowNode* flow,\n-        std::optional<ui32> filterColumn,\n-        size_t width,\n-        const std::vector<TKeyParams>& keys,\n-        size_t maxBlockLen,\n-        ui32 keyLength,\n-        std::vector<TAggParams<TAggregator>>&& aggsParams,\n-        ui32 streamIndex,\n-        std::vector<std::vector<ui32>>&& streams)\n-        : TComputationBase(mutables, flow, EValueRepresentation::Boxed)\n-        , Flow_(flow)\n+    bool WritingOutput_ = false;\n+    bool IsFinished_ = false;\n+\n+    const std::optional<ui32> FilterColumn_;\n+    const std::vector<TKeyParams> Keys_;\n+    const std::vector<TAggParams<TAggregator>>& AggsParams_;\n+    const ui32 KeyLength_;\n+    const ui32 StreamIndex_;\n+    const std::vector<std::vector<ui32>> Streams_;\n+    const size_t MaxBlockLen_;\n+    const size_t Width_;\n+    const size_t OutputWidth_;\n+\n+    template<typename TKeyType>\n+    struct THashSettings {\n+        static constexpr bool CacheHash = std::is_same_v<TKeyType, TSSOKey>;\n+    };\n+    using TDynMapImpl = TDynamicHashMapImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>;\n+    using TSetImpl = THashSetImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>;\n+    using TFixedMapImpl = TFixedHashMapImpl<TKey, TFixedAggState, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>;\n+\n+    ui64 BatchNum_ = 0;\n+    TUnboxedValueVector Values_;\n+    std::vector<std::unique_ptr<TAggregator>> Aggs_;\n+    std::vector<ui32> AggStateOffsets_;\n+    TUnboxedValueVector UnwrappedValues_;\n+    std::vector<std::unique_ptr<IBlockReader>> Readers_;\n+    std::vector<std::unique_ptr<IArrayBuilder>> Builders_;\n+    std::vector<std::unique_ptr<IAggColumnBuilder>> AggBuilders_;\n+    bool HasValues_ = false;\n+    ui32 TotalStateSize_ = 0;\n+    size_t OutputBlockSize_ = 0;\n+    std::unique_ptr<TDynMapImpl> HashMap_;\n+    typename TDynMapImpl::const_iterator HashMapIt_;\n+    std::unique_ptr<TSetImpl> HashSet_;\n+    typename TSetImpl::const_iterator HashSetIt_;\n+    std::unique_ptr<TFixedMapImpl> HashFixedMap_;\n+    typename TFixedMapImpl::const_iterator HashFixedMapIt_;\n+    TPagedArena Arena_;\n+\n+    THashedWrapperBaseState(TMemoryUsageInfo* memInfo, ui32 keyLength, ui32 streamIndex, size_t width, size_t outputWidth, std::optional<ui32> filterColumn, const std::vector<TAggParams<TAggregator>>& params,\n+        const std::vector<std::vector<ui32>>& streams, const std::vector<TKeyParams>& keys, size_t maxBlockLen, TComputationContext& ctx)\n+        : TBlockState(memInfo, outputWidth)\n         , FilterColumn_(filterColumn)\n-        , Width_(width)\n-        , OutputWidth_(keys.size() + aggsParams.size() + 1)\n-        , WideFieldsIndex_(mutables.IncrementWideFieldsIndex(width))\n         , Keys_(keys)\n-        , MaxBlockLen_(maxBlockLen)\n-        , AggsParams_(std::move(aggsParams))\n+        , AggsParams_(params)\n         , KeyLength_(keyLength)\n         , StreamIndex_(streamIndex)\n-        , Streams_(std::move(streams))\n+        , Streams_(streams)\n+        , MaxBlockLen_(maxBlockLen)\n+        , Width_(width)\n+        , OutputWidth_(outputWidth)\n+        , Values_(width)\n+        , UnwrappedValues_(width)\n+        , Readers_(keys.size())\n+        , Builders_(keys.size())\n+        , Arena_(TlsAllocState)\n     {\n-        MKQL_ENSURE(Width_ > 0, \"Missing block length column\");\n-        if constexpr (UseFilter) {\n-            MKQL_ENSURE(filterColumn, \"Missing filter column\");\n-            MKQL_ENSURE(!Finalize, \"Filter isn't compatible with Finalize\");\n-        } else {\n-            MKQL_ENSURE(!filterColumn, \"Unexpected filter column\");\n+        Pointer_ = Values_.data();\n+        for (size_t i = 0; i < Keys_.size(); ++i) {\n+            auto itemType = AS_TYPE(TBlockType, Keys_[i].Type)->GetItemType();\n+            Readers_[i] = NYql::NUdf::MakeBlockReader(TTypeInfoHelper(), itemType);\n+            Builders_[i] = NYql::NUdf::MakeArrayBuilder(TTypeInfoHelper(), itemType, ctx.ArrowMemoryPool, MaxBlockLen_, &ctx.Builder->GetPgBuilder());\n         }\n-    }\n-\n-    EFetchResult DoCalculate(NUdf::TUnboxedValue& state,\n-        TComputationContext& ctx,\n-        NUdf::TUnboxedValue*const* output) const\n-    {\n-        auto& s = GetState(state, ctx);\n-        if (!s.Count) {\n-            if (s.IsFinished_)\n-                return EFetchResult::Finish;\n \n-            while (!s.WritingOutput_) {\n-                const auto fields = ctx.WideFields.data() + WideFieldsIndex_;\n-                s.Values_.assign(s.Values_.size(), NUdf::TUnboxedValuePod());\n-                switch (Flow_->FetchValues(ctx, fields)) {\n-                    case EFetchResult::Yield:\n-                        return EFetchResult::Yield;\n-                    case EFetchResult::One:\n-                        s.ProcessInput(ctx.HolderFactory);\n-                        continue;\n-                    case EFetchResult::Finish:\n-                        break;\n-                }\n-\n-                if (s.Finish())\n-                    break;\n-                else\n-                    return EFetchResult::Finish;\n-            }\n+        if constexpr (Many) {\n+            TotalStateSize_ += Streams_.size();\n+        }\n \n-            if (!s.FillOutput(ctx.HolderFactory))\n-                return EFetchResult::Finish;\n+        for (const auto& p : AggsParams_) {\n+            Aggs_.emplace_back(p.Prepared_->Make(ctx));\n+            MKQL_ENSURE(Aggs_.back()->StateSize == p.Prepared_->StateSize, \"State size mismatch\");\n+            AggStateOffsets_.emplace_back(TotalStateSize_);\n+            TotalStateSize_ += Aggs_.back()->StateSize;\n         }\n \n-        const auto sliceSize = s.Slice();\n-        for (size_t i = 0; i < OutputWidth_; ++i) {\n-            if (const auto out = output[i]) {\n-                *out = s.Get(sliceSize, ctx.HolderFactory, i);\n+        auto equal = MakeEqual<TKey>(KeyLength_);\n+        auto hasher = MakeHash<TKey>(KeyLength_);\n+        if constexpr (UseSet) {\n+            MKQL_ENSURE(params.empty(), \"Only keys are supported\");\n+            HashSet_ = std::make_unique<THashSetImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>>(hasher, equal);\n+        } else {\n+            if (!InlineAggState) {\n+                HashFixedMap_ = std::make_unique<TFixedHashMapImpl<TKey, TFixedAggState, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>>(hasher, equal);\n+            } else {\n+                HashMap_ = std::make_unique<TDynamicHashMapImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>>(TotalStateSize_, hasher, equal);\n             }\n         }\n-        return EFetchResult::One;\n-    }\n-#ifndef MKQL_DISABLE_CODEGEN\n-    ICodegeneratorInlineWideNode::TGenerateResult DoGenGetValues(const TCodegenContext& ctx, Value* statePtr, BasicBlock*& block) const {\n-        return DoGenGetValuesImpl(ctx, statePtr, block, Flow_, Width_, OutputWidth_,\n-            GetMethodPtr(&TState::Get), GetMethodPtr(&THashedWrapperBase::MakeState),\n-            GetMethodPtr(&TState::ProcessInput), GetMethodPtr(&TState::Finish),\n-            GetMethodPtr(&TState::FillOutput), GetMethodPtr(&TState::Slice));\n     }\n-#endif\n-private:\n-    struct TState : public TBlockState {\n-        bool WritingOutput_ = false;\n-        bool IsFinished_ = false;\n-\n-        const std::optional<ui32> FilterColumn_;\n-        const std::vector<TKeyParams> Keys_;\n-        const std::vector<TAggParams<TAggregator>>& AggsParams_;\n-        const ui32 KeyLength_;\n-        const ui32 StreamIndex_;\n-        const std::vector<std::vector<ui32>> Streams_;\n-        const size_t MaxBlockLen_;\n-\n-        template<typename TKeyType>\n-        struct THashSettings {\n-            static constexpr bool CacheHash = std::is_same_v<TKeyType, TSSOKey>;\n-        };\n-        using TDynMapImpl = TDynamicHashMapImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>;\n-        using TSetImpl = THashSetImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>;\n-        using TFixedMapImpl = TFixedHashMapImpl<TKey, TFixedAggState, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>;\n-\n-        ui64 BatchNum_ = 0;\n-        TUnboxedValueVector Values_;\n-        std::vector<std::unique_ptr<TAggregator>> Aggs_;\n-        std::vector<ui32> AggStateOffsets_;\n-        TUnboxedValueVector UnwrappedValues_;\n-        std::vector<std::unique_ptr<IBlockReader>> Readers_;\n-        std::vector<std::unique_ptr<IArrayBuilder>> Builders_;\n-        std::vector<std::unique_ptr<IAggColumnBuilder>> AggBuilders_;\n-        bool HasValues_ = false;\n-        ui32 TotalStateSize_ = 0;\n-        size_t OutputBlockSize_ = 0;\n-        std::unique_ptr<TDynMapImpl> HashMap_;\n-        typename TDynMapImpl::const_iterator HashMapIt_;\n-        std::unique_ptr<TSetImpl> HashSet_;\n-        typename TSetImpl::const_iterator HashSetIt_;\n-        std::unique_ptr<TFixedMapImpl> HashFixedMap_;\n-        typename TFixedMapImpl::const_iterator HashFixedMapIt_;\n-        TPagedArena Arena_;\n-\n-        TState(TMemoryUsageInfo* memInfo, ui32 keyLength, ui32 streamIndex, size_t width, size_t outputWidth, std::optional<ui32> filterColumn, const std::vector<TAggParams<TAggregator>>& params,\n-            const std::vector<std::vector<ui32>>& streams, const std::vector<TKeyParams>& keys, size_t maxBlockLen, TComputationContext& ctx)\n-            : TBlockState(memInfo, outputWidth)\n-            , FilterColumn_(filterColumn)\n-            , Keys_(keys)\n-            , AggsParams_(params)\n-            , KeyLength_(keyLength)\n-            , StreamIndex_(streamIndex)\n-            , Streams_(streams)\n-            , MaxBlockLen_(maxBlockLen)\n-            , Values_(width)\n-            , UnwrappedValues_(width)\n-            , Readers_(keys.size())\n-            , Builders_(keys.size())\n-            , Arena_(TlsAllocState)\n-        {\n-            Pointer_ = Values_.data();\n-            for (size_t i = 0; i < Keys_.size(); ++i) {\n-                auto itemType = AS_TYPE(TBlockType, Keys_[i].Type)->GetItemType();\n-                Readers_[i] = NYql::NUdf::MakeBlockReader(TTypeInfoHelper(), itemType);\n-                Builders_[i] = NYql::NUdf::MakeArrayBuilder(TTypeInfoHelper(), itemType, ctx.ArrowMemoryPool, MaxBlockLen_, &ctx.Builder->GetPgBuilder());\n-            }\n-\n-            if constexpr (Many) {\n-                TotalStateSize_ += Streams_.size();\n-            }\n \n-            for (const auto& p : AggsParams_) {\n-                Aggs_.emplace_back(p.Prepared_->Make(ctx));\n-                MKQL_ENSURE(Aggs_.back()->StateSize == p.Prepared_->StateSize, \"State size mismatch\");\n-                AggStateOffsets_.emplace_back(TotalStateSize_);\n-                TotalStateSize_ += Aggs_.back()->StateSize;\n-            }\n+    void ProcessInput(const THolderFactory& holderFactory) {\n+        ++BatchNum_;\n+        const auto batchLength = TArrowBlock::From(Values_.back()).GetDatum().scalar_as<arrow::UInt64Scalar>().value;\n+        if (!batchLength) {\n+            return;\n+        }\n \n-            auto equal = MakeEqual<TKey>(KeyLength_);\n-            auto hasher = MakeHash<TKey>(KeyLength_);\n-            if constexpr (UseSet) {\n-                MKQL_ENSURE(params.empty(), \"Only keys are supported\");\n-                HashSet_ = std::make_unique<THashSetImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>>(hasher, equal);\n+        const ui8* filterBitmap = nullptr;\n+        if constexpr (UseFilter) {\n+            auto filterDatum = TArrowBlock::From(Values_[*FilterColumn_]).GetDatum();\n+            if (filterDatum.is_scalar()) {\n+                if (!filterDatum.template scalar_as<arrow::UInt8Scalar>().value) {\n+                    return;\n+                }\n             } else {\n-                if (!InlineAggState) {\n-                    HashFixedMap_ = std::make_unique<TFixedHashMapImpl<TKey, TFixedAggState, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>>(hasher, equal);\n-                } else {\n-                    HashMap_ = std::make_unique<TDynamicHashMapImpl<TKey, std::equal_to<TKey>, std::hash<TKey>, TMKQLAllocator<char>, THashSettings<TKey>>>(TotalStateSize_, hasher, equal);\n+                const auto& arr = filterDatum.array();\n+                filterBitmap = arr->template GetValues<ui8>(1);\n+                ui64 popCount = GetBitmapPopCount(arr);\n+                if (popCount == 0) {\n+                    return;\n                 }\n             }\n         }\n \n-        void ProcessInput(const THolderFactory& holderFactory) {\n-            ++BatchNum_;\n-            const auto batchLength = TArrowBlock::From(Values_.back()).GetDatum().scalar_as<arrow::UInt64Scalar>().value;\n-            if (!batchLength) {\n-                return;\n+        const ui32* streamIndexData = nullptr;\n+        TMaybe<ui32> streamIndexScalar;\n+        if constexpr (Many) {\n+            auto streamIndexDatum = TArrowBlock::From(Values_[StreamIndex_]).GetDatum();\n+            if (streamIndexDatum.is_scalar()) {\n+                streamIndexScalar = streamIndexDatum.template scalar_as<arrow::UInt32Scalar>().value;\n+            } else {\n+                MKQL_ENSURE(streamIndexDatum.is_array(), \"Expected array\");\n+                streamIndexData = streamIndexDatum.array()->template GetValues<ui32>(1);\n             }\n-\n-            const ui8* filterBitmap = nullptr;\n-            if constexpr (UseFilter) {\n-                auto filterDatum = TArrowBlock::From(Values_[*FilterColumn_]).GetDatum();\n-                if (filterDatum.is_scalar()) {\n-                    if (!filterDatum.template scalar_as<arrow::UInt8Scalar>().value) {\n-                        return;\n-                    }\n-                } else {\n-                    const auto& arr = filterDatum.array();\n-                    filterBitmap = arr->template GetValues<ui8>(1);\n-                    ui64 popCount = GetBitmapPopCount(arr);\n-                    if (popCount == 0) {\n-                        return;\n-                    }\n-                }\n+            UnwrappedValues_ = Values_;\n+            for (const auto& p : AggsParams_) {\n+                const auto& columnDatum = TArrowBlock::From(UnwrappedValues_[p.Column_]).GetDatum();\n+                MKQL_ENSURE(columnDatum.is_array(), \"Expected array\");\n+                UnwrappedValues_[p.Column_] = holderFactory.CreateArrowBlock(Unwrap(*columnDatum.array(), p.StateType_));\n             }\n+        }\n \n-            const ui32* streamIndexData = nullptr;\n-            TMaybe<ui32> streamIndexScalar;\n-            if constexpr (Many) {\n-                auto streamIndexDatum = TArrowBlock::From(Values_[StreamIndex_]).GetDatum();\n-                if (streamIndexDatum.is_scalar()) {\n-                    streamIndexScalar = streamIndexDatum.template scalar_as<arrow::UInt32Scalar>().value;\n-                } else {\n-                    MKQL_ENSURE(streamIndexDatum.is_array(), \"Expected array\");\n-                    streamIndexData = streamIndexDatum.array()->template GetValues<ui32>(1);\n-                }\n-                UnwrappedValues_ = Values_;\n-                for (const auto& p : AggsParams_) {\n-                    const auto& columnDatum = TArrowBlock::From(UnwrappedValues_[p.Column_]).GetDatum();\n-                    MKQL_ENSURE(columnDatum.is_array(), \"Expected array\");\n-                    UnwrappedValues_[p.Column_] = holderFactory.CreateArrowBlock(Unwrap(*columnDatum.array(), p.StateType_));\n-                }\n-            }\n+        HasValues_ = true;\n+        std::vector<arrow::Datum> keysDatum;\n+        keysDatum.reserve(Keys_.size());\n+        for (ui32 i = 0; i < Keys_.size(); ++i) {\n+            keysDatum.emplace_back(TArrowBlock::From(Values_[Keys_[i].Index]).GetDatum());\n+        }\n \n-            HasValues_ = true;\n-            std::vector<arrow::Datum> keysDatum;\n-            keysDatum.reserve(Keys_.size());\n-            for (ui32 i = 0; i < Keys_.size(); ++i) {\n-                keysDatum.emplace_back(TArrowBlock::From(Values_[Keys_[i].Index]).GetDatum());\n-            }\n+        std::array<TOutputBuffer, PrefetchBatchSize> out;\n+        for (ui32 i = 0; i < PrefetchBatchSize; ++i) {\n+            out[i].Resize(sizeof(TKey));\n+        }\n \n-            std::array<TOutputBuffer, PrefetchBatchSize> out;\n-            for (ui32 i = 0; i < PrefetchBatchSize; ++i) {\n-                out[i].Resize(sizeof(TKey));\n+        std::array<TRobinHoodBatchRequestItem<TKey>, PrefetchBatchSize> insertBatch;\n+        std::array<ui64, PrefetchBatchSize> insertBatchRows;\n+        std::array<char*, PrefetchBatchSize> insertBatchPayloads;\n+        std::array<bool, PrefetchBatchSize> insertBatchIsNew;\n+        ui32 insertBatchLen = 0;\n+\n+        const auto processInsertBatch = [&]() {\n+            for (ui32 i = 0; i < insertBatchLen; ++i) {\n+                auto& r = insertBatch[i];\n+                TStringBuf str = out[i].Finish();\n+                TKey key = MakeKey<TKey>(str, KeyLength_);\n+                r.ConstructKey(key);\n             }\n \n-            std::array<TRobinHoodBatchRequestItem<TKey>, PrefetchBatchSize> insertBatch;\n-            std::array<ui64, PrefetchBatchSize> insertBatchRows;\n-            std::array<char*, PrefetchBatchSize> insertBatchPayloads;\n-            std::array<bool, PrefetchBatchSize> insertBatchIsNew;\n-            ui32 insertBatchLen = 0;\n-\n-            const auto processInsertBatch = [&]() {\n-                for (ui32 i = 0; i < insertBatchLen; ++i) {\n-                    auto& r = insertBatch[i];\n-                    TStringBuf str = out[i].Finish();\n-                    TKey key = MakeKey<TKey>(str, KeyLength_);\n-                    r.ConstructKey(key);\n+            if constexpr (UseSet) {\n+                HashSet_->BatchInsert({insertBatch.data(), insertBatchLen},[&](size_t index, typename THashedWrapperBaseState::TSetImpl::iterator iter, bool isNew) {\n+                    Y_UNUSED(index);\n+                    if (isNew) {\n+                        if constexpr (std::is_same<TKey, TSSOKey>::value || std::is_same<TKey, TExternalFixedSizeKey>::value) {\n+                            MoveKeyToArena(HashSet_->GetKey(iter), Arena_, KeyLength_);\n+                        }\n+                    }\n+                });\n+            } else {\n+                using THashTable = std::conditional_t<InlineAggState, typename THashedWrapperBaseState::TDynMapImpl, typename THashedWrapperBaseState::TFixedMapImpl>;\n+                THashTable* hash;\n+                if constexpr (!InlineAggState) {\n+                    hash = HashFixedMap_.get();\n+                } else {\n+                    hash = HashMap_.get();\n                 }\n \n-                if constexpr (UseSet) {\n-                    HashSet_->BatchInsert({insertBatch.data(), insertBatchLen},[&](size_t index, typename TState::TSetImpl::iterator iter, bool isNew) {\n-                        Y_UNUSED(index);\n-                        if (isNew) {\n-                            if constexpr (std::is_same<TKey, TSSOKey>::value || std::is_same<TKey, TExternalFixedSizeKey>::value) {\n-                                MoveKeyToArena(HashSet_->GetKey(iter), Arena_, KeyLength_);\n-                            }\n+                hash->BatchInsert({insertBatch.data(), insertBatchLen}, [&](size_t index, typename THashTable::iterator iter, bool isNew) {\n+                    if (isNew) {\n+                        if constexpr (std::is_same<TKey, TSSOKey>::value || std::is_same<TKey, TExternalFixedSizeKey>::value) {\n+                            MoveKeyToArena(hash->GetKey(iter), Arena_, KeyLength_);\n                         }\n-                    });\n-                } else {\n-                    using THashTable = std::conditional_t<InlineAggState, typename TState::TDynMapImpl, typename TState::TFixedMapImpl>;\n-                    THashTable* hash;\n-                    if constexpr (!InlineAggState) {\n-                        hash = HashFixedMap_.get();\n-                    } else {\n-                        hash = HashMap_.get();\n                     }\n \n-                    hash->BatchInsert({insertBatch.data(), insertBatchLen}, [&](size_t index, typename THashTable::iterator iter, bool isNew) {\n+                    if constexpr (UseArena) {\n+                        // prefetch payloads only\n+                        auto payload = hash->GetPayload(iter);\n+                        char* ptr;\n                         if (isNew) {\n-                            if constexpr (std::is_same<TKey, TSSOKey>::value || std::is_same<TKey, TExternalFixedSizeKey>::value) {\n-                                MoveKeyToArena(hash->GetKey(iter), Arena_, KeyLength_);\n-                            }\n-                        }\n-\n-                        if constexpr (UseArena) {\n-                            // prefetch payloads only\n-                            auto payload = hash->GetPayload(iter);\n-                            char* ptr;\n-                            if (isNew) {\n-                                ptr = (char*)Arena_.Alloc(TotalStateSize_);\n-                                *(char**)payload = ptr;\n-                            } else {\n-                                ptr = *(char**)payload;\n-                            }\n-\n-                            insertBatchIsNew[index] = isNew;\n-                            insertBatchPayloads[index] = ptr;\n-                            NYql::PrefetchForWrite(ptr);\n+                            ptr = (char*)Arena_.Alloc(TotalStateSize_);\n+                            *(char**)payload = ptr;\n                         } else {\n-                            // process insert\n-                            auto payload = (char*)hash->GetPayload(iter);\n-                            auto row = insertBatchRows[index];\n-                            ui32 streamIndex = 0;\n-                            if constexpr (Many) {\n-                                streamIndex = streamIndexScalar ? *streamIndexScalar : streamIndexData[row];\n-                            }\n-\n-                            Insert(row, payload, isNew, streamIndex);\n+                            ptr = *(char**)payload;\n                         }\n-                    });\n \n-                    if constexpr (UseArena) {\n-                        for (ui32 i = 0; i < insertBatchLen; ++i) {\n-                            auto row = insertBatchRows[i];\n-                            ui32 streamIndex = 0;\n-                            if constexpr (Many) {\n-                                streamIndex = streamIndexScalar ? *streamIndexScalar : streamIndexData[row];\n-                            }\n-\n-                            bool isNew = insertBatchIsNew[i];\n-                            char* payload = insertBatchPayloads[i];\n-                            Insert(row, payload, isNew, streamIndex);\n+                        insertBatchIsNew[index] = isNew;\n+                        insertBatchPayloads[index] = ptr;\n+                        NYql::PrefetchForWrite(ptr);\n+                    } else {\n+                        // process insert\n+                        auto payload = (char*)hash->GetPayload(iter);\n+                        auto row = insertBatchRows[index];\n+                        ui32 streamIndex = 0;\n+                        if constexpr (Many) {\n+                            streamIndex = streamIndexScalar ? *streamIndexScalar : streamIndexData[row];\n                         }\n+\n+                        Insert(row, payload, isNew, streamIndex);\n                     }\n-                }\n-            };\n+                });\n \n-            for (ui64 row = 0; row < batchLength; ++row) {\n-                if constexpr (UseFilter) {\n-                    if (filterBitmap && !filterBitmap[row]) {\n-                        continue;\n+                if constexpr (UseArena) {\n+                    for (ui32 i = 0; i < insertBatchLen; ++i) {\n+                        auto row = insertBatchRows[i];\n+                        ui32 streamIndex = 0;\n+                        if constexpr (Many) {\n+                            streamIndex = streamIndexScalar ? *streamIndexScalar : streamIndexData[row];\n+                        }\n+\n+                        bool isNew = insertBatchIsNew[i];\n+                        char* payload = insertBatchPayloads[i];\n+                        Insert(row, payload, isNew, streamIndex);\n                     }\n                 }\n+            }\n+        };\n \n-                // encode key\n-                out[insertBatchLen].Rewind();\n-                for (ui32 i = 0; i < keysDatum.size(); ++i) {\n-                    if (keysDatum[i].is_scalar()) {\n-                        // TODO: more efficient code when grouping by scalar\n-                        Readers_[i]->SaveScalarItem(*keysDatum[i].scalar(), out[insertBatchLen]);\n-                    } else {\n-                        Readers_[i]->SaveItem(*keysDatum[i].array(), row, out[insertBatchLen]);\n-                    }\n+        for (ui64 row = 0; row < batchLength; ++row) {\n+            if constexpr (UseFilter) {\n+                if (filterBitmap && !filterBitmap[row]) {\n+                    continue;\n                 }\n+            }\n \n-                insertBatchRows[insertBatchLen] = row;\n-                ++insertBatchLen;\n-                if (insertBatchLen == PrefetchBatchSize) {\n-                    processInsertBatch();\n-                    insertBatchLen = 0;\n+            // encode key\n+            out[insertBatchLen].Rewind();\n+            for (ui32 i = 0; i < keysDatum.size(); ++i) {\n+                if (keysDatum[i].is_scalar()) {\n+                    // TODO: more efficient code when grouping by scalar\n+                    Readers_[i]->SaveScalarItem(*keysDatum[i].scalar(), out[insertBatchLen]);\n+                } else {\n+                    Readers_[i]->SaveItem(*keysDatum[i].array(), row, out[insertBatchLen]);\n                 }\n             }\n \n-            processInsertBatch();\n+            insertBatchRows[insertBatchLen] = row;\n+            ++insertBatchLen;\n+            if (insertBatchLen == PrefetchBatchSize) {\n+                processInsertBatch();\n+                insertBatchLen = 0;\n+            }\n         }\n \n-        bool Finish() {\n-            if (!HasValues_) {\n-                IsFinished_ = true;\n-                return false;\n-            }\n+        processInsertBatch();\n+    }\n \n-            WritingOutput_ = true;\n-            OutputBlockSize_ = 0;\n-            PrepareAggBuilders();\n+    bool Finish() {\n+        if (!HasValues_) {\n+            IsFinished_ = true;\n+            return false;\n+        }\n \n-            if constexpr (UseSet) {\n-                HashSetIt_ = HashSet_->Begin();\n+        WritingOutput_ = true;\n+        OutputBlockSize_ = 0;\n+        PrepareAggBuilders();\n+\n+        if constexpr (UseSet) {\n+            HashSetIt_ = HashSet_->Begin();\n+        } else {\n+            if constexpr (!InlineAggState) {\n+                HashFixedMapIt_ = HashFixedMap_->Begin();\n             } else {\n-                if constexpr (!InlineAggState) {\n-                    HashFixedMapIt_ = HashFixedMap_->Begin();\n-                } else {\n-                    HashMapIt_ = HashMap_->Begin();\n-                }\n+                HashMapIt_ = HashMap_->Begin();\n             }\n-            return true;\n         }\n+        return true;\n+    }\n \n-        bool FillOutput(const THolderFactory& holderFactory) {\n-            bool exit = false;\n-            while (WritingOutput_) {\n-                if constexpr (UseSet) {\n-                    for (;!exit && HashSetIt_ != HashSet_->End(); HashSet_->Advance(HashSetIt_)) {\n-                        if (!HashSet_->IsValid(HashSetIt_)) {\n-                            continue;\n-                        }\n-\n-                        if (OutputBlockSize_ == MaxBlockLen_) {\n-                            Flush(false, holderFactory);\n-                            //return EFetchResult::One;\n-                            exit = true;\n-                            break;\n-                        }\n-\n-                        const TKey& key = HashSet_->GetKey(HashSetIt_);\n-                        TInputBuffer in(GetKeyView<TKey>(key, KeyLength_));\n-                        for (auto& kb : Builders_) {\n-                            kb->Add(in);\n-                        }\n-                        ++OutputBlockSize_;\n+    bool FillOutput(const THolderFactory& holderFactory) {\n+        bool exit = false;\n+        while (WritingOutput_) {\n+            if constexpr (UseSet) {\n+                for (;!exit && HashSetIt_ != HashSet_->End(); HashSet_->Advance(HashSetIt_)) {\n+                    if (!HashSet_->IsValid(HashSetIt_)) {\n+                        continue;\n                     }\n-                    break;\n-                } else {\n-                    const bool done = InlineAggState ?\n-                        Iterate(*HashMap_, HashMapIt_) :\n-                        Iterate(*HashFixedMap_, HashFixedMapIt_);\n-                    if (done) {\n+\n+                    if (OutputBlockSize_ == MaxBlockLen_) {\n+                        Flush(false, holderFactory);\n+                        //return EFetchResult::One;\n+                        exit = true;\n                         break;\n                     }\n-                    Flush(false, holderFactory);\n-                    exit = true;\n+\n+                    const TKey& key = HashSet_->GetKey(HashSetIt_);\n+                    TInputBuffer in(GetKeyView<TKey>(key, KeyLength_));\n+                    for (auto& kb : Builders_) {\n+                        kb->Add(in);\n+                    }\n+                    ++OutputBlockSize_;\n+                }\n+                break;\n+            } else {\n+                const bool done = InlineAggState ?\n+                    Iterate(*HashMap_, HashMapIt_) :\n+                    Iterate(*HashFixedMap_, HashFixedMapIt_);\n+                if (done) {\n                     break;\n                 }\n+                Flush(false, holderFactory);\n+                exit = true;\n+                break;\n             }\n+        }\n \n-            if (!exit) {\n-                IsFinished_ = true;\n-                WritingOutput_ = false;\n-                if (!OutputBlockSize_)\n-                    return false;\n-                Flush(true, holderFactory);\n-            }\n-\n-            FillArrays();\n-            return true;\n+        if (!exit) {\n+            IsFinished_ = true;\n+            WritingOutput_ = false;\n+            if (!OutputBlockSize_)\n+                return false;\n+            Flush(true, holderFactory);\n         }\n-    private:\n-        void PrepareAggBuilders() {\n-            if constexpr (!UseSet) {\n-                AggBuilders_.clear();\n-                AggBuilders_.reserve(Aggs_.size());\n-                for (const auto& a : Aggs_) {\n-                    if constexpr (Finalize) {\n-                        AggBuilders_.emplace_back(a->MakeResultBuilder(MaxBlockLen_));\n-                    } else {\n-                        AggBuilders_.emplace_back(a->MakeStateBuilder(MaxBlockLen_));\n-                    }\n+\n+        FillArrays();\n+        return true;\n+    }\n+private:\n+    void PrepareAggBuilders() {\n+        if constexpr (!UseSet) {\n+            AggBuilders_.clear();\n+            AggBuilders_.reserve(Aggs_.size());\n+            for (const auto& a : Aggs_) {\n+                if constexpr (Finalize) {\n+                    AggBuilders_.emplace_back(a->MakeResultBuilder(MaxBlockLen_));\n+                } else {\n+                    AggBuilders_.emplace_back(a->MakeStateBuilder(MaxBlockLen_));\n                 }\n             }\n         }\n+    }\n \n-        void Flush(bool final, const THolderFactory& holderFactory) {\n-            if (!OutputBlockSize_) {\n-                return;\n-            }\n+    void Flush(bool final, const THolderFactory& holderFactory) {\n+        if (!OutputBlockSize_) {\n+            return;\n+        }\n \n-            for (size_t i = 0; i < Builders_.size(); ++i) {\n-                Values[i] = holderFactory.CreateArrowBlock(Builders_[i]->Build(final));\n-            }\n+        for (size_t i = 0; i < Builders_.size(); ++i) {\n+            Values[i] = holderFactory.CreateArrowBlock(Builders_[i]->Build(final));\n+        }\n \n-            if constexpr (!UseSet) {\n-                for (size_t i = 0; i < Aggs_.size(); ++i) {\n-                    Values[Builders_.size() + i] = AggBuilders_[i]->Build();\n-                }\n-                if (!final) {\n-                    PrepareAggBuilders();\n-                }\n+        if constexpr (!UseSet) {\n+            for (size_t i = 0; i < Aggs_.size(); ++i) {\n+                Values[Builders_.size() + i] = AggBuilders_[i]->Build();\n+            }\n+            if (!final) {\n+                PrepareAggBuilders();\n             }\n-\n-            Values.back() = holderFactory.CreateArrowBlock(arrow::Datum(std::make_shared<arrow::UInt64Scalar>(OutputBlockSize_)));\n-            OutputBlockSize_ = 0;\n         }\n \n-        void Insert(ui64 row, char* payload, bool isNew, ui32 currentStreamIndex) const {\n-            char* ptr = payload;\n+        Values.back() = holderFactory.CreateArrowBlock(arrow::Datum(std::make_shared<arrow::UInt64Scalar>(OutputBlockSize_)));\n+        OutputBlockSize_ = 0;\n+    }\n \n-            if (isNew) {\n-                if constexpr (Many) {\n-                    static_assert(Finalize);\n-                    MKQL_ENSURE(currentStreamIndex < Streams_.size(), \"Invalid stream index\");\n-                    memset(ptr, 0, Streams_.size());\n-                    ptr[currentStreamIndex] = 1;\n+    void Insert(ui64 row, char* payload, bool isNew, ui32 currentStreamIndex) const {\n+        char* ptr = payload;\n \n-                    for (auto i : Streams_[currentStreamIndex]) {\n+        if (isNew) {\n+            if constexpr (Many) {\n+                static_assert(Finalize);\n+                MKQL_ENSURE(currentStreamIndex < Streams_.size(), \"Invalid stream index\");\n+                memset(ptr, 0, Streams_.size());\n+                ptr[currentStreamIndex] = 1;\n \n-                        Aggs_[i]->LoadState(ptr + AggStateOffsets_[i], BatchNum_, UnwrappedValues_.data(), row);\n-                    }\n-                } else {\n-                    for (size_t i = 0; i < Aggs_.size(); ++i) {\n-                        if constexpr (Finalize) {\n-                            Aggs_[i]->LoadState(ptr, BatchNum_, Values_.data(), row);\n-                        } else {\n-                            Aggs_[i]->InitKey(ptr, BatchNum_, Values_.data(), row);\n-                        }\n+                for (auto i : Streams_[currentStreamIndex]) {\n \n-                        ptr += Aggs_[i]->StateSize;\n-                    }\n+                    Aggs_[i]->LoadState(ptr + AggStateOffsets_[i], BatchNum_, UnwrappedValues_.data(), row);\n                 }\n             } else {\n-                if constexpr (Many) {\n-                    static_assert(Finalize);\n-                    MKQL_ENSURE(currentStreamIndex < Streams_.size(), \"Invalid stream index\");\n-\n-                    bool isNewStream = !ptr[currentStreamIndex];\n-                    ptr[currentStreamIndex] = 1;\n-\n-                    for (auto i : Streams_[currentStreamIndex]) {\n-\n-                        if (isNewStream) {\n-                            Aggs_[i]->LoadState(ptr + AggStateOffsets_[i], BatchNum_, UnwrappedValues_.data(), row);\n-                        } else {\n-                            Aggs_[i]->UpdateState(ptr + AggStateOffsets_[i], BatchNum_, UnwrappedValues_.data(), row);\n-                        }\n+                for (size_t i = 0; i < Aggs_.size(); ++i) {\n+                    if constexpr (Finalize) {\n+                        Aggs_[i]->LoadState(ptr, BatchNum_, Values_.data(), row);\n+                    } else {\n+                        Aggs_[i]->InitKey(ptr, BatchNum_, Values_.data(), row);\n                     }\n-                } else {\n-                    for (size_t i = 0; i < Aggs_.size(); ++i) {\n-                        if constexpr (Finalize) {\n-                            Aggs_[i]->UpdateState(ptr, BatchNum_, Values_.data(), row);\n-                        } else {\n-                            Aggs_[i]->UpdateKey(ptr, BatchNum_, Values_.data(), row);\n-                        }\n \n-                        ptr += Aggs_[i]->StateSize;\n-                    }\n+                    ptr += Aggs_[i]->StateSize;\n                 }\n             }\n-        }\n+        } else {\n+            if constexpr (Many) {\n+                static_assert(Finalize);\n+                MKQL_ENSURE(currentStreamIndex < Streams_.size(), \"Invalid stream index\");\n \n-        template <typename THash>\n-        bool Iterate(THash& hash, typename THash::const_iterator& iter) {\n-            MKQL_ENSURE(WritingOutput_, \"Supposed to be called at the end\");\n-            std::array<typename THash::const_iterator, PrefetchBatchSize> iters;\n-            ui32 itersLen = 0;\n-            auto iterateBatch = [&]() {\n-                for (ui32 i = 0; i < itersLen; ++i) {\n-                    auto iter = iters[i];\n-                    const TKey& key = hash.GetKey(iter);\n-                    auto payload = (char*)hash.GetPayload(iter);\n-                    char* ptr;\n-                    if constexpr (UseArena) {\n-                        ptr = *(char**)payload;\n+                bool isNewStream = !ptr[currentStreamIndex];\n+                ptr[currentStreamIndex] = 1;\n+\n+                for (auto i : Streams_[currentStreamIndex]) {\n+\n+                    if (isNewStream) {\n+                        Aggs_[i]->LoadState(ptr + AggStateOffsets_[i], BatchNum_, UnwrappedValues_.data(), row);\n                     } else {\n-                        ptr = payload;\n+                        Aggs_[i]->UpdateState(ptr + AggStateOffsets_[i], BatchNum_, UnwrappedValues_.data(), row);\n                     }\n-\n-                    TInputBuffer in(GetKeyView<TKey>(key, KeyLength_));\n-                    for (auto& kb : Builders_) {\n-                        kb->Add(in);\n+                }\n+            } else {\n+                for (size_t i = 0; i < Aggs_.size(); ++i) {\n+                    if constexpr (Finalize) {\n+                        Aggs_[i]->UpdateState(ptr, BatchNum_, Values_.data(), row);\n+                    } else {\n+                        Aggs_[i]->UpdateKey(ptr, BatchNum_, Values_.data(), row);\n                     }\n \n-                    if constexpr (Many) {\n-                        for (ui32 i = 0; i < Streams_.size(); ++i) {\n-                            MKQL_ENSURE(ptr[i], \"Missing partial aggregation state for stream #\" << i);\n-                        }\n+                    ptr += Aggs_[i]->StateSize;\n+                }\n+            }\n+        }\n+    }\n \n-                        ptr += Streams_.size();\n-                    }\n+    template <typename THash>\n+    bool Iterate(THash& hash, typename THash::const_iterator& iter) {\n+        MKQL_ENSURE(WritingOutput_, \"Supposed to be called at the end\");\n+        std::array<typename THash::const_iterator, PrefetchBatchSize> iters;\n+        ui32 itersLen = 0;\n+        auto iterateBatch = [&]() {\n+            for (ui32 i = 0; i < itersLen; ++i) {\n+                auto iter = iters[i];\n+                const TKey& key = hash.GetKey(iter);\n+                auto payload = (char*)hash.GetPayload(iter);\n+                char* ptr;\n+                if constexpr (UseArena) {\n+                    ptr = *(char**)payload;\n+                } else {\n+                    ptr = payload;\n+                }\n \n-                    for (size_t i = 0; i < Aggs_.size(); ++i) {\n-                        AggBuilders_[i]->Add(ptr);\n-                        Aggs_[i]->DestroyState(ptr);\n+                TInputBuffer in(GetKeyView<TKey>(key, KeyLength_));\n+                for (auto& kb : Builders_) {\n+                    kb->Add(in);\n+                }\n \n-                        ptr += Aggs_[i]->StateSize;\n+                if constexpr (Many) {\n+                    for (ui32 i = 0; i < Streams_.size(); ++i) {\n+                        MKQL_ENSURE(ptr[i], \"Missing partial aggregation state for stream #\" << i);\n                     }\n-                }\n-            };\n \n-            for (; iter != hash.End(); hash.Advance(iter)) {\n-                if (!hash.IsValid(iter)) {\n-                    continue;\n+                    ptr += Streams_.size();\n                 }\n \n-                if (OutputBlockSize_ == MaxBlockLen_) {\n-                    iterateBatch();\n-                    return false;\n-                }\n+                for (size_t i = 0; i < Aggs_.size(); ++i) {\n+                    AggBuilders_[i]->Add(ptr);\n+                    Aggs_[i]->DestroyState(ptr);\n \n-                if (itersLen == iters.size()) {\n-                    iterateBatch();\n-                    itersLen = 0;\n+                    ptr += Aggs_[i]->StateSize;\n                 }\n+            }\n+        };\n \n-                iters[itersLen] = iter;\n-                ++itersLen;\n-                ++OutputBlockSize_;\n-                if constexpr (UseArena) {\n-                    auto payload = (char*)hash.GetPayload(iter);\n-                    auto ptr = *(char**)payload;\n-                    NYql::PrefetchForWrite(ptr);\n+        for (; iter != hash.End(); hash.Advance(iter)) {\n+            if (!hash.IsValid(iter)) {\n+                continue;\n+            }\n+\n+            if (OutputBlockSize_ == MaxBlockLen_) {\n+                iterateBatch();\n+                return false;\n+            }\n+\n+            if (itersLen == iters.size()) {\n+                iterateBatch();\n+                itersLen = 0;\n+            }\n+\n+            iters[itersLen] = iter;\n+            ++itersLen;\n+            ++OutputBlockSize_;\n+            if constexpr (UseArena) {\n+                auto payload = (char*)hash.GetPayload(iter);\n+                auto ptr = *(char**)payload;\n+                NYql::PrefetchForWrite(ptr);\n+            }\n+\n+            if constexpr (std::is_same<TKey, TSSOKey>::value) {\n+                const auto& key = hash.GetKey(iter);\n+                if (!key.IsInplace()) {\n+                    NYql::PrefetchForRead(key.AsView().Data());\n                 }\n+            } else if constexpr (std::is_same<TKey, TExternalFixedSizeKey>::value) {\n+                const auto& key = hash.GetKey(iter);\n+                NYql::PrefetchForRead(key.Data);\n+            }\n+        }\n \n-                if constexpr (std::is_same<TKey, TSSOKey>::value) {\n-                    const auto& key = hash.GetKey(iter);\n-                    if (!key.IsInplace()) {\n-                        NYql::PrefetchForRead(key.AsView().Data());\n-                    }\n-                } else if constexpr (std::is_same<TKey, TExternalFixedSizeKey>::value) {\n-                    const auto& key = hash.GetKey(iter);\n-                    NYql::PrefetchForRead(key.Data);\n+        iterateBatch();\n+        return true;\n+    }\n+};\n+\n+template <typename TKey, typename TAggregator, typename TFixedAggState, bool UseSet, bool UseFilter, bool Finalize, bool Many, typename TDerived>\n+class THashedWrapperBaseFromFlow : public TStatefulWideFlowCodegeneratorNode<TDerived>,\n+    protected THashedWrapperCodegenBase\n+{\n+    using TComputationBase = TStatefulWideFlowCodegeneratorNode<TDerived>;\n+\n+    using TState = THashedWrapperBaseState<TKey, TAggregator, TFixedAggState, UseSet, UseFilter, Finalize, Many, TDerived>;\n+public:\n+    THashedWrapperBaseFromFlow(TComputationMutables& mutables,\n+        IComputationWideFlowNode* flow,\n+        std::optional<ui32> filterColumn,\n+        size_t width,\n+        const std::vector<TKeyParams>& keys,\n+        size_t maxBlockLen,\n+        ui32 keyLength,\n+        std::vector<TAggParams<TAggregator>>&& aggsParams,\n+        ui32 streamIndex,\n+        std::vector<std::vector<ui32>>&& streams)\n+        : TComputationBase(mutables, flow, EValueRepresentation::Boxed)\n+        , Flow_(flow)\n+        , FilterColumn_(filterColumn)\n+        , Width_(width)\n+        , OutputWidth_(keys.size() + aggsParams.size() + 1)\n+        , WideFieldsIndex_(mutables.IncrementWideFieldsIndex(width))\n+        , Keys_(keys)\n+        , MaxBlockLen_(maxBlockLen)\n+        , AggsParams_(std::move(aggsParams))\n+        , KeyLength_(keyLength)\n+        , StreamIndex_(streamIndex)\n+        , Streams_(std::move(streams))\n+    {\n+        MKQL_ENSURE(Width_ > 0, \"Missing block length column\");\n+        if constexpr (UseFilter) {\n+            MKQL_ENSURE(filterColumn, \"Missing filter column\");\n+            MKQL_ENSURE(!Finalize, \"Filter isn't compatible with Finalize\");\n+        } else {\n+            MKQL_ENSURE(!filterColumn, \"Unexpected filter column\");\n+        }\n+    }\n+\n+    EFetchResult DoCalculate(NUdf::TUnboxedValue& state,\n+        TComputationContext& ctx,\n+        NUdf::TUnboxedValue*const* output) const\n+    {\n+        auto& s = GetState(state, ctx);\n+        if (!s.Count) {\n+            if (s.IsFinished_)\n+                return EFetchResult::Finish;\n+\n+            while (!s.WritingOutput_) {\n+                const auto fields = ctx.WideFields.data() + WideFieldsIndex_;\n+                s.Values_.assign(s.Values_.size(), NUdf::TUnboxedValuePod());\n+                switch (Flow_->FetchValues(ctx, fields)) {\n+                    case EFetchResult::Yield:\n+                        return EFetchResult::Yield;\n+                    case EFetchResult::One:\n+                        s.ProcessInput(ctx.HolderFactory);\n+                        continue;\n+                    case EFetchResult::Finish:\n+                        break;\n                 }\n+\n+                if (s.Finish())\n+                    break;\n+                else\n+                    return EFetchResult::Finish;\n             }\n \n-            iterateBatch();\n-            return true;\n+            if (!s.FillOutput(ctx.HolderFactory))\n+                return EFetchResult::Finish;\n         }\n-    };\n+\n+        const auto sliceSize = s.Slice();\n+        for (size_t i = 0; i < OutputWidth_; ++i) {\n+            if (const auto out = output[i]) {\n+                *out = s.Get(sliceSize, ctx.HolderFactory, i);\n+            }\n+        }\n+        return EFetchResult::One;\n+    }\n+#ifndef MKQL_DISABLE_CODEGEN\n+    ICodegeneratorInlineWideNode::TGenerateResult DoGenGetValues(const TCodegenContext& ctx, Value* statePtr, BasicBlock*& block) const {\n+        return DoGenGetValuesImpl(ctx, statePtr, block, Flow_, Width_, OutputWidth_,\n+            GetMethodPtr(&TState::Get), GetMethodPtr(&THashedWrapperBaseFromFlow::MakeState),\n+            GetMethodPtr(&TState::ProcessInput), GetMethodPtr(&TState::Finish),\n+            GetMethodPtr(&TState::FillOutput), GetMethodPtr(&TState::Slice));\n+    }\n+#endif\n private:\n     void RegisterDependencies() const final {\n         this->FlowDependsOn(Flow_);\n@@ -1665,11 +1772,136 @@ class THashedWrapperBase : public TStatefulWideFlowCodegeneratorNode<TDerived>,\n     const std::vector<std::vector<ui32>> Streams_;\n };\n \n+\n+template <typename TKey, typename TAggregator, typename TFixedAggState, bool UseSet, bool UseFilter, bool Finalize, bool Many, typename TDerived>\n+class THashedWrapperBaseFromStream : public TMutableComputationNode<TDerived>,\n+    protected THashedWrapperCodegenBase\n+{\n+    using TComputationBase = TMutableComputationNode<TDerived>;\n+\n+    using TState = THashedWrapperBaseState<TKey, TAggregator, TFixedAggState, UseSet, UseFilter, Finalize, Many, TDerived>;\n+public:\n+    THashedWrapperBaseFromStream(TComputationMutables& mutables,\n+        IComputationNode* stream,\n+        std::optional<ui32> filterColumn,\n+        size_t width,\n+        const std::vector<TKeyParams>& keys,\n+        size_t maxBlockLen,\n+        ui32 keyLength,\n+        std::vector<TAggParams<TAggregator>>&& aggsParams,\n+        ui32 streamIndex,\n+        std::vector<std::vector<ui32>>&& streams)\n+        : TComputationBase(mutables, EValueRepresentation::Boxed)\n+        , Stream_(stream)\n+        , FilterColumn_(filterColumn)\n+        , Width_(width)\n+        , OutputWidth_(keys.size() + aggsParams.size() + 1)\n+        , WideFieldsIndex_(mutables.IncrementWideFieldsIndex(width))\n+        , Keys_(keys)\n+        , MaxBlockLen_(maxBlockLen)\n+        , AggsParams_(std::move(aggsParams))\n+        , KeyLength_(keyLength)\n+        , StreamIndex_(streamIndex)\n+        , Streams_(std::move(streams))\n+    {\n+        MKQL_ENSURE(Width_ > 0, \"Missing block length column\");\n+        if constexpr (UseFilter) {\n+            MKQL_ENSURE(filterColumn, \"Missing filter column\");\n+            MKQL_ENSURE(!Finalize, \"Filter isn't compatible with Finalize\");\n+        } else {\n+            MKQL_ENSURE(!filterColumn, \"Unexpected filter column\");\n+        }\n+    }\n+\n+    NUdf::TUnboxedValuePod DoCalculate(TComputationContext& ctx) const\n+    {\n+        const auto state = ctx.HolderFactory.Create<TState>(KeyLength_, StreamIndex_, Width_, OutputWidth_, FilterColumn_, AggsParams_, Streams_, Keys_, MaxBlockLen_, ctx);\n+        return ctx.HolderFactory.Create<TStreamValue>(ctx.HolderFactory, std::move(state), std::move(Stream_->GetValue(ctx)));\n+    }\n+private:\n+    class TStreamValue : public TComputationValue<TStreamValue> {\n+    using TBase = TComputationValue<TStreamValue>;\n+    public:\n+        TStreamValue(TMemoryUsageInfo* memInfo, const THolderFactory& holderFactory,\n+                     NUdf::TUnboxedValue&& state, NUdf::TUnboxedValue&& stream) \n+            : TBase(memInfo)\n+            , State_(state)\n+            , Stream_(stream)\n+            , HolderFactory_(holderFactory)\n+        {\n+        }\n+\n+    private:\n+        NUdf::EFetchStatus WideFetch(NUdf::TUnboxedValue* output, ui32 width) {\n+            TState& state = *static_cast<TState*>(State_.AsBoxed().Get());\n+            auto* inputFields = state.Values_.data();\n+            const size_t inputWidth = state.Width_;\n+            const size_t outputWidth = state.OutputWidth_;\n+            MKQL_ENSURE(outputWidth == width, \"The given width doesn't equal to the result type size\");\n+\n+            if (!state.Count) {\n+                if (state.IsFinished_)\n+                    return NUdf::EFetchStatus::Finish;\n+\n+                while (!state.WritingOutput_) {\n+                    switch (Stream_.WideFetch(inputFields, inputWidth)) {\n+                        case NUdf::EFetchStatus::Yield:\n+                            return NUdf::EFetchStatus::Yield;\n+                        case NUdf::EFetchStatus::Ok:\n+                            state.ProcessInput(HolderFactory_);\n+                            continue;\n+                        case NUdf::EFetchStatus::Finish:\n+                            break;\n+                    }\n+\n+                    if (state.Finish())\n+                        break;\n+                    else\n+                        return NUdf::EFetchStatus::Finish;\n+                }\n+\n+                if (!state.FillOutput(HolderFactory_))\n+                    return NUdf::EFetchStatus::Finish;\n+            }\n+\n+            const auto sliceSize = state.Slice();\n+            for (size_t i = 0; i < outputWidth; ++i) {\n+                output[i] = state.Get(sliceSize, HolderFactory_, i);\n+            }\n+            return NUdf::EFetchStatus::Ok;\n+        }\n+    private:\n+        NUdf::TUnboxedValue State_;\n+        NUdf::TUnboxedValue Stream_;\n+        const THolderFactory& HolderFactory_;\n+    };\n+private:\n+    void RegisterDependencies() const final {\n+        this->DependsOn(Stream_);\n+    }\n+\n+    IComputationNode *const Stream_;\n+    const std::optional<ui32> FilterColumn_;\n+    const size_t Width_;\n+    const size_t OutputWidth_;\n+    const size_t WideFieldsIndex_;\n+    const std::vector<TKeyParams> Keys_;\n+    const size_t MaxBlockLen_;\n+    const std::vector<TAggParams<TAggregator>> AggsParams_;\n+    const ui32 KeyLength_;\n+    const ui32 StreamIndex_;\n+    const std::vector<std::vector<ui32>> Streams_;\n+};\n+\n+template <typename TKey, typename TFixedAggState, bool UseSet, bool UseFilter, typename TInputNode>\n+class TBlockCombineHashedWrapper {};\n+\n template <typename TKey, typename TFixedAggState, bool UseSet, bool UseFilter>\n-class TBlockCombineHashedWrapper : public THashedWrapperBase<TKey, IBlockAggregatorCombineKeys, TFixedAggState, UseSet, UseFilter, false, false, TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter>> {\n+class TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter, IComputationWideFlowNode>\n+    : public THashedWrapperBaseFromFlow<TKey, IBlockAggregatorCombineKeys, TFixedAggState, UseSet, UseFilter, false, false, TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter, IComputationWideFlowNode>> {\n public:\n-    using TSelf = TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter>;\n-    using TBase = THashedWrapperBase<TKey, IBlockAggregatorCombineKeys, TFixedAggState, UseSet, UseFilter, false, false, TSelf>;\n+    using TSelf = TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter, IComputationWideFlowNode>;\n+    using TBase = THashedWrapperBaseFromFlow<TKey, IBlockAggregatorCombineKeys, TFixedAggState, UseSet, UseFilter, false, false, TSelf>;\n \n     TBlockCombineHashedWrapper(TComputationMutables& mutables,\n         IComputationWideFlowNode* flow,\n@@ -1683,11 +1915,34 @@ class TBlockCombineHashedWrapper : public THashedWrapperBase<TKey, IBlockAggrega\n     {}\n };\n \n+template <typename TKey, typename TFixedAggState, bool UseSet, bool UseFilter>\n+class TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter, IComputationNode> \n+    : public THashedWrapperBaseFromStream<TKey, IBlockAggregatorCombineKeys, TFixedAggState, UseSet, UseFilter, false, false, TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter, IComputationNode>> {\n+public:\n+    using TSelf = TBlockCombineHashedWrapper<TKey, TFixedAggState, UseSet, UseFilter, IComputationNode>;\n+    using TBase = THashedWrapperBaseFromStream<TKey, IBlockAggregatorCombineKeys, TFixedAggState, UseSet, UseFilter, false, false, TSelf>;\n+\n+    TBlockCombineHashedWrapper(TComputationMutables& mutables,\n+        IComputationNode* stream,\n+        std::optional<ui32> filterColumn,\n+        size_t width,\n+        const std::vector<TKeyParams>& keys,\n+        size_t maxBlockLen,\n+        ui32 keyLength,\n+        std::vector<TAggParams<IBlockAggregatorCombineKeys>>&& aggsParams)\n+        : TBase(mutables, stream, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams), 0, {})\n+    {}\n+};\n+\n+template <typename TKey, typename TFixedAggState, bool UseSet, typename TInputNode>\n+class TBlockMergeFinalizeHashedWrapper {};\n+\n template <typename TKey, typename TFixedAggState, bool UseSet>\n-class TBlockMergeFinalizeHashedWrapper : public THashedWrapperBase<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, UseSet, false, true, false, TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet>> {\n+class TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet, IComputationWideFlowNode> \n+    : public THashedWrapperBaseFromFlow<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, UseSet, false, true, false, TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet, IComputationWideFlowNode>> {\n public:\n-    using TSelf = TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet>;\n-    using TBase = THashedWrapperBase<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, UseSet, false, true, false, TSelf>;\n+    using TSelf = TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet, IComputationWideFlowNode>;\n+    using TBase = THashedWrapperBaseFromFlow<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, UseSet, false, true, false, TSelf>;\n \n     TBlockMergeFinalizeHashedWrapper(TComputationMutables& mutables,\n         IComputationWideFlowNode* flow,\n@@ -1700,11 +1955,33 @@ class TBlockMergeFinalizeHashedWrapper : public THashedWrapperBase<TKey, IBlockA\n     {}\n };\n \n+template <typename TKey, typename TFixedAggState, bool UseSet>\n+class TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet, IComputationNode> \n+    : public THashedWrapperBaseFromStream<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, UseSet, false, true, false, TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet, IComputationNode>> {\n+public:\n+    using TSelf = TBlockMergeFinalizeHashedWrapper<TKey, TFixedAggState, UseSet, IComputationNode>;\n+    using TBase = THashedWrapperBaseFromStream<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, UseSet, false, true, false, TSelf>;\n+\n+    TBlockMergeFinalizeHashedWrapper(TComputationMutables& mutables,\n+        IComputationNode* stream,\n+        size_t width,\n+        const std::vector<TKeyParams>& keys,\n+        size_t maxBlockLen,\n+        ui32 keyLength,\n+        std::vector<TAggParams<IBlockAggregatorFinalizeKeys>>&& aggsParams)\n+        : TBase(mutables, stream, {}, width, keys, maxBlockLen, keyLength, std::move(aggsParams), 0, {})\n+    {}\n+};\n+\n+template <typename TKey, typename TFixedAggState, typename TInputNode>\n+class TBlockMergeManyFinalizeHashedWrapper {};\n+\n template <typename TKey, typename TFixedAggState>\n-class TBlockMergeManyFinalizeHashedWrapper : public THashedWrapperBase<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, false, false, true, true, TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState>> {\n+class TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState, IComputationWideFlowNode> \n+    : public THashedWrapperBaseFromFlow<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, false, false, true, true, TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState, IComputationWideFlowNode>> {\n public:\n-    using TSelf = TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState>;\n-    using TBase = THashedWrapperBase<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, false, false, true, true, TSelf>;\n+    using TSelf = TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState, IComputationWideFlowNode>;\n+    using TBase = THashedWrapperBaseFromFlow<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, false, false, true, true, TSelf>;\n \n     TBlockMergeManyFinalizeHashedWrapper(TComputationMutables& mutables,\n         IComputationWideFlowNode* flow,\n@@ -1718,6 +1995,25 @@ class TBlockMergeManyFinalizeHashedWrapper : public THashedWrapperBase<TKey, IBl\n     {}\n };\n \n+template <typename TKey, typename TFixedAggState>\n+class TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState, IComputationNode> \n+    : public THashedWrapperBaseFromStream<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, false, false, true, true, TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState, IComputationNode>> {\n+public:\n+    using TSelf = TBlockMergeManyFinalizeHashedWrapper<TKey, TFixedAggState, IComputationNode>;\n+    using TBase = THashedWrapperBaseFromStream<TKey, IBlockAggregatorFinalizeKeys, TFixedAggState, false, false, true, true, TSelf>;\n+\n+    TBlockMergeManyFinalizeHashedWrapper(TComputationMutables& mutables,\n+        IComputationNode* stream,\n+        size_t width,\n+        const std::vector<TKeyParams>& keys,\n+        size_t maxBlockLen,\n+        ui32 keyLength,\n+        std::vector<TAggParams<IBlockAggregatorFinalizeKeys>>&& aggsParams,\n+        ui32 streamIndex, std::vector<std::vector<ui32>>&& streams)\n+        : TBase(mutables, stream, {}, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams))\n+    {}\n+};\n+\n template <typename TAggregator>\n std::unique_ptr<IPreparedBlockAggregator<TAggregator>> PrepareBlockAggregator(const IBlockAggregatorFactory& factory,\n     TTupleType* tupleType,\n@@ -1824,117 +2120,117 @@ ui32 FillAggParams(TTupleLiteral* aggsVal, TTupleType* tupleType, std::optional<\n     return totalStateSize;\n }\n \n-template <bool UseSet, bool UseFilter, typename TKey>\n+template <bool UseSet, bool UseFilter, typename TKey, typename TInputNode>\n IComputationNode* MakeBlockCombineHashedWrapper(\n     ui32 keyLength,\n     ui32 totalStateSize,\n     TComputationMutables& mutables,\n-    IComputationWideFlowNode* flow,\n+    TInputNode* streamOrFlow,\n     std::optional<ui32> filterColumn,\n     size_t width,\n     const std::vector<TKeyParams>& keys,\n     size_t maxBlockLen,\n     std::vector<TAggParams<IBlockAggregatorCombineKeys>>&& aggsParams) {\n     if (totalStateSize <= sizeof(TState8)) {\n-        return new TBlockCombineHashedWrapper<TKey, TState8, UseSet, UseFilter>(mutables, flow, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n+        return new TBlockCombineHashedWrapper<TKey, TState8, UseSet, UseFilter, TInputNode>(mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n     }\n \n     if (totalStateSize <= sizeof(TState16)) {\n-        return new TBlockCombineHashedWrapper<TKey, TState16, UseSet, UseFilter>(mutables, flow, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n+        return new TBlockCombineHashedWrapper<TKey, TState16, UseSet, UseFilter, TInputNode>(mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n     }\n \n-    return new TBlockCombineHashedWrapper<TKey, TStateArena, UseSet, UseFilter>(mutables, flow, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n+    return new TBlockCombineHashedWrapper<TKey, TStateArena, UseSet, UseFilter, TInputNode>(mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n }\n \n-template <bool UseSet, bool UseFilter>\n+template <bool UseSet, bool UseFilter, typename TInputNode>\n IComputationNode* MakeBlockCombineHashedWrapper(\n     TMaybe<ui32> totalKeysSize,\n     bool isFixed,\n     ui32 totalStateSize,\n     TComputationMutables& mutables,\n-    IComputationWideFlowNode* flow,\n+    TInputNode* streamOrFlow,\n     std::optional<ui32> filterColumn,\n     size_t width,\n     const std::vector<TKeyParams>& keys,\n     size_t maxBlockLen,\n     std::vector<TAggParams<IBlockAggregatorCombineKeys>>&& aggsParams) {\n     if (totalKeysSize && *totalKeysSize <= sizeof(ui32)) {\n-        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, ui32>(*totalKeysSize, totalStateSize, mutables, flow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, ui32>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n     if (totalKeysSize && *totalKeysSize <= sizeof(ui64)) {\n-        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, ui64>(*totalKeysSize, totalStateSize, mutables, flow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, ui64>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n     if (totalKeysSize && *totalKeysSize <= sizeof(TKey16)) {\n-        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, TKey16>(*totalKeysSize, totalStateSize, mutables, flow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, TKey16>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n     if (totalKeysSize && isFixed) {\n-        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, TExternalFixedSizeKey>(*totalKeysSize, totalStateSize, mutables, flow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockCombineHashedWrapper<UseSet, UseFilter, TExternalFixedSizeKey>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n-    return MakeBlockCombineHashedWrapper<UseSet, UseFilter, TSSOKey>(Max<ui32>(), totalStateSize, mutables, flow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n+    return MakeBlockCombineHashedWrapper<UseSet, UseFilter, TSSOKey>(Max<ui32>(), totalStateSize, mutables, streamOrFlow, filterColumn, width, keys, maxBlockLen, std::move(aggsParams));\n }\n \n-template <typename TKey, bool UseSet>\n+template <typename TKey, bool UseSet, typename TInputNode>\n IComputationNode* MakeBlockMergeFinalizeHashedWrapper(\n     ui32 keyLength,\n     ui32 totalStateSize,\n     TComputationMutables& mutables,\n-    IComputationWideFlowNode* flow,\n+    TInputNode* streamOrFlow,\n     size_t width,\n     const std::vector<TKeyParams>& keys,\n     size_t maxBlockLen,\n     std::vector<TAggParams<IBlockAggregatorFinalizeKeys>>&& aggsParams) {\n \n     if (totalStateSize <= sizeof(TState8)) {\n-        return new TBlockMergeFinalizeHashedWrapper<TKey, TState8, UseSet>(mutables, flow, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n+        return new TBlockMergeFinalizeHashedWrapper<TKey, TState8, UseSet, TInputNode>(mutables, streamOrFlow, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n     }\n \n     if (totalStateSize <= sizeof(TState16)) {\n-        return new TBlockMergeFinalizeHashedWrapper<TKey, TState16, UseSet>(mutables, flow, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n+        return new TBlockMergeFinalizeHashedWrapper<TKey, TState16, UseSet, TInputNode>(mutables, streamOrFlow, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n     }\n \n-    return new TBlockMergeFinalizeHashedWrapper<TKey, TStateArena, UseSet>(mutables, flow, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n+    return new TBlockMergeFinalizeHashedWrapper<TKey, TStateArena, UseSet, TInputNode>(mutables, streamOrFlow, width, keys, maxBlockLen, keyLength, std::move(aggsParams));\n }\n \n-template <bool UseSet>\n+template <bool UseSet, typename TInputNode>\n IComputationNode* MakeBlockMergeFinalizeHashedWrapper(\n     TMaybe<ui32> totalKeysSize,\n     bool isFixed,\n     ui32 totalStateSize,\n     TComputationMutables& mutables,\n-    IComputationWideFlowNode* flow,\n+    TInputNode* streamOrFlow,\n     size_t width,\n     const std::vector<TKeyParams>& keys,\n     size_t maxBlockLen,\n     std::vector<TAggParams<IBlockAggregatorFinalizeKeys>>&& aggsParams) {\n     if (totalKeysSize && *totalKeysSize <= sizeof(ui32)) {\n-        return MakeBlockMergeFinalizeHashedWrapper<ui32, UseSet>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockMergeFinalizeHashedWrapper<ui32, UseSet>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n     if (totalKeysSize && *totalKeysSize <= sizeof(ui64)) {\n-        return MakeBlockMergeFinalizeHashedWrapper<ui64, UseSet>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockMergeFinalizeHashedWrapper<ui64, UseSet>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n     if (totalKeysSize && *totalKeysSize <= sizeof(TKey16)) {\n-        return MakeBlockMergeFinalizeHashedWrapper<TKey16, UseSet>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockMergeFinalizeHashedWrapper<TKey16, UseSet>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n     if (totalKeysSize && isFixed) {\n-        return MakeBlockMergeFinalizeHashedWrapper<TExternalFixedSizeKey, UseSet>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams));\n+        return MakeBlockMergeFinalizeHashedWrapper<TExternalFixedSizeKey, UseSet>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams));\n     }\n \n-    return MakeBlockMergeFinalizeHashedWrapper<TSSOKey, UseSet>(Max<ui32>(), totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams));\n+    return MakeBlockMergeFinalizeHashedWrapper<TSSOKey, UseSet>(Max<ui32>(), totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams));\n }\n \n-template <typename TKey>\n+template <typename TKey, typename TInputNode>\n IComputationNode* MakeBlockMergeManyFinalizeHashedWrapper(\n     ui32 keyLength,\n     ui32 totalStateSize,\n     TComputationMutables& mutables,\n-    IComputationWideFlowNode* flow,\n+    TInputNode* streamOrFlow,\n     size_t width,\n     const std::vector<TKeyParams>& keys,\n     size_t maxBlockLen,\n@@ -1943,22 +2239,23 @@ IComputationNode* MakeBlockMergeManyFinalizeHashedWrapper(\n     std::vector<std::vector<ui32>>&& streams) {\n \n     if (totalStateSize <= sizeof(TState8)) {\n-        return new TBlockMergeManyFinalizeHashedWrapper<TKey, TState8>(mutables, flow, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams));\n+        return new TBlockMergeManyFinalizeHashedWrapper<TKey, TState8, TInputNode>(mutables, streamOrFlow, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams));\n     }\n \n     if (totalStateSize <= sizeof(TState16)) {\n-        return new TBlockMergeManyFinalizeHashedWrapper<TKey, TState16>(mutables, flow, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams));\n+        return new TBlockMergeManyFinalizeHashedWrapper<TKey, TState16, TInputNode>(mutables, streamOrFlow, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams));\n     }\n \n-    return new TBlockMergeManyFinalizeHashedWrapper<TKey, TStateArena>(mutables, flow, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams));\n+    return new TBlockMergeManyFinalizeHashedWrapper<TKey, TStateArena, TInputNode>(mutables, streamOrFlow, width, keys, maxBlockLen, keyLength, std::move(aggsParams), streamIndex, std::move(streams));\n }\n \n+template <typename TInputNode>\n IComputationNode* MakeBlockMergeManyFinalizeHashedWrapper(\n     TMaybe<ui32> totalKeysSize,\n     bool isFixed,\n     ui32 totalStateSize,\n     TComputationMutables& mutables,\n-    IComputationWideFlowNode* flow,\n+    TInputNode* streamOrFlow,\n     size_t width,\n     const std::vector<TKeyParams>& keys,\n     size_t maxBlockLen,\n@@ -1966,22 +2263,22 @@ IComputationNode* MakeBlockMergeManyFinalizeHashedWrapper(\n     ui32 streamIndex,\n     std::vector<std::vector<ui32>>&& streams) {\n     if (totalKeysSize && *totalKeysSize <= sizeof(ui32)) {\n-        return MakeBlockMergeManyFinalizeHashedWrapper<ui32>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        return MakeBlockMergeManyFinalizeHashedWrapper<ui32>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n     }\n \n     if (totalKeysSize && *totalKeysSize <= sizeof(ui64)) {\n-        return MakeBlockMergeManyFinalizeHashedWrapper<ui64>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        return MakeBlockMergeManyFinalizeHashedWrapper<ui64>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n     }\n \n     if (totalKeysSize && *totalKeysSize <= sizeof(TKey16)) {\n-        return MakeBlockMergeManyFinalizeHashedWrapper<TKey16>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        return MakeBlockMergeManyFinalizeHashedWrapper<TKey16>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n     }\n \n     if (totalKeysSize && isFixed) {\n-        return MakeBlockMergeManyFinalizeHashedWrapper<TExternalFixedSizeKey>(*totalKeysSize, totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        return MakeBlockMergeManyFinalizeHashedWrapper<TExternalFixedSizeKey>(*totalKeysSize, totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n     }\n \n-    return MakeBlockMergeManyFinalizeHashedWrapper<TSSOKey>(Max<ui32>(), totalStateSize, mutables, flow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+    return MakeBlockMergeManyFinalizeHashedWrapper<TSSOKey>(Max<ui32>(), totalStateSize, mutables, streamOrFlow, width, keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n }\n \n void PrepareKeys(const std::vector<TKeyParams>& keys, TMaybe<ui32>& totalKeysSize, bool& isFixed) {\n@@ -2012,14 +2309,15 @@ void FillAggStreams(TRuntimeNode streamsNode, std::vector<std::vector<ui32>>& st\n \n IComputationNode* WrapBlockCombineAll(TCallable& callable, const TComputationNodeFactoryContext& ctx) {\n     MKQL_ENSURE(callable.GetInputsCount() == 3, \"Expected 3 args\");\n-    const auto flowType = AS_TYPE(TFlowType, callable.GetInput(0).GetStaticType());\n-    const auto wideComponents = GetWideComponents(flowType);\n+\n+    const bool isStream = callable.GetInput(0).GetStaticType()->IsStream();\n+    MKQL_ENSURE(isStream == callable.GetType()->GetReturnType()->IsStream(), \"input and output must be both either flow or stream\");\n+\n+    const auto wideComponents = GetWideComponents(callable.GetInput(0).GetStaticType());\n     const auto tupleType = TTupleType::Create(wideComponents.size(), wideComponents.data(), ctx.Env);\n-    const auto returnFlowType = AS_TYPE(TFlowType, callable.GetType()->GetReturnType());\n-    const auto returnWideComponents = GetWideComponents(returnFlowType);\n+    const auto returnWideComponents = GetWideComponents(callable.GetType()->GetReturnType());\n \n-    auto wideFlow = dynamic_cast<IComputationWideFlowNode*>(LocateNode(ctx.NodeLocator, callable, 0));\n-    MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+    const auto wideFlowOrStream = LocateNode(ctx.NodeLocator, callable, 0);\n \n     auto filterColumnVal = AS_VALUE(TOptionalLiteral, callable.GetInput(1));\n     std::optional<ui32> filterColumn;\n@@ -2030,19 +2328,28 @@ IComputationNode* WrapBlockCombineAll(TCallable& callable, const TComputationNod\n     auto aggsVal = AS_VALUE(TTupleLiteral, callable.GetInput(2));\n     std::vector<TAggParams<IBlockAggregatorCombineAll>> aggsParams;\n     FillAggParams<IBlockAggregatorCombineAll>(aggsVal, tupleType, filterColumn, aggsParams, ctx.Env, false, false, returnWideComponents, 0);\n-    return new TBlockCombineAllWrapper(ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), std::move(aggsParams));\n+\n+    if (isStream) {\n+        const auto wideStream = wideFlowOrStream;\n+        return new TBlockCombineAllWrapperFromStream(ctx.Mutables, wideStream, filterColumn, tupleType->GetElementsCount(), std::move(aggsParams));\n+    } else {\n+        const auto wideFlow = dynamic_cast<IComputationWideFlowNode*>(wideFlowOrStream);\n+        MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+        return new TBlockCombineAllWrapperFromFlow(ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), std::move(aggsParams));\n+    }\n }\n \n IComputationNode* WrapBlockCombineHashed(TCallable& callable, const TComputationNodeFactoryContext& ctx) {\n     MKQL_ENSURE(callable.GetInputsCount() == 4, \"Expected 4 args\");\n-    const auto flowType = AS_TYPE(TFlowType, callable.GetInput(0).GetStaticType());\n-    const auto wideComponents = GetWideComponents(flowType);\n+\n+    const bool isStream = callable.GetInput(0).GetStaticType()->IsStream();\n+    MKQL_ENSURE(isStream == callable.GetType()->GetReturnType()->IsStream(), \"input and output must be both either flow or stream\");\n+\n+    const auto wideComponents = GetWideComponents(callable.GetInput(0).GetStaticType());\n     const auto tupleType = TTupleType::Create(wideComponents.size(), wideComponents.data(), ctx.Env);\n-    const auto returnFlowType = AS_TYPE(TFlowType, callable.GetType()->GetReturnType());\n-    const auto returnWideComponents = GetWideComponents(returnFlowType);\n+    const auto returnWideComponents = GetWideComponents(callable.GetType()->GetReturnType());\n \n-    auto wideFlow = dynamic_cast<IComputationWideFlowNode*>(LocateNode(ctx.NodeLocator, callable, 0));\n-    MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+    const auto wideStreamOrFlow = LocateNode(ctx.NodeLocator, callable, 0);\n \n     auto filterColumnVal = AS_VALUE(TOptionalLiteral, callable.GetInput(1));\n     std::optional<ui32> filterColumn;\n@@ -2066,31 +2373,51 @@ IComputationNode* WrapBlockCombineHashed(TCallable& callable, const TComputation\n     PrepareKeys(keys, totalKeysSize, isFixed);\n \n     const size_t maxBlockLen = CalcMaxBlockLenForOutput(callable.GetType()->GetReturnType());\n-    if (filterColumn) {\n-        if (aggsParams.empty()) {\n-            return MakeBlockCombineHashedWrapper<true, true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+    if (isStream) {\n+        const auto wideStream = wideStreamOrFlow;\n+        if (filterColumn) {\n+            if (aggsParams.empty()) {\n+                return MakeBlockCombineHashedWrapper<true, true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            } else {\n+                return MakeBlockCombineHashedWrapper<false, true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            }\n         } else {\n-            return MakeBlockCombineHashedWrapper<false, true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            if (aggsParams.empty()) {\n+                return MakeBlockCombineHashedWrapper<true, false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            } else {\n+                return MakeBlockCombineHashedWrapper<false, false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            }\n         }\n     } else {\n-        if (aggsParams.empty()) {\n-            return MakeBlockCombineHashedWrapper<true, false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+        const auto wideFlow = dynamic_cast<IComputationWideFlowNode *>(wideStreamOrFlow);\n+        MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+        if (filterColumn) {\n+            if (aggsParams.empty()) {\n+                return MakeBlockCombineHashedWrapper<true, true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            } else {\n+                return MakeBlockCombineHashedWrapper<false, true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            }\n         } else {\n-            return MakeBlockCombineHashedWrapper<false, false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            if (aggsParams.empty()) {\n+                return MakeBlockCombineHashedWrapper<true, false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            } else {\n+                return MakeBlockCombineHashedWrapper<false, false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, filterColumn, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+            }\n         }\n     }\n }\n \n IComputationNode* WrapBlockMergeFinalizeHashed(TCallable& callable, const TComputationNodeFactoryContext& ctx) {\n     MKQL_ENSURE(callable.GetInputsCount() == 3, \"Expected 3 args\");\n-    const auto flowType = AS_TYPE(TFlowType, callable.GetInput(0).GetStaticType());\n-    const auto wideComponents = GetWideComponents(flowType);\n+    \n+    const bool isStream = callable.GetInput(0).GetStaticType()->IsStream();\n+    MKQL_ENSURE(isStream == callable.GetType()->GetReturnType()->IsStream(), \"input and output must be both either flow or stream\");\n+\n+    const auto wideComponents = GetWideComponents(callable.GetInput(0).GetStaticType());\n     const auto tupleType = TTupleType::Create(wideComponents.size(), wideComponents.data(), ctx.Env);\n-    const auto returnFlowType = AS_TYPE(TFlowType, callable.GetType()->GetReturnType());\n-    const auto returnWideComponents = GetWideComponents(returnFlowType);\n+    const auto returnWideComponents = GetWideComponents(callable.GetType()->GetReturnType());\n \n-    auto wideFlow = dynamic_cast<IComputationWideFlowNode*>(LocateNode(ctx.NodeLocator, callable, 0));\n-    MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+    const auto wideStreamOrFlow = LocateNode(ctx.NodeLocator, callable, 0);\n \n     auto keysVal = AS_VALUE(TTupleLiteral, callable.GetInput(1));\n     std::vector<TKeyParams> keys;\n@@ -2108,23 +2435,35 @@ IComputationNode* WrapBlockMergeFinalizeHashed(TCallable& callable, const TCompu\n     PrepareKeys(keys, totalKeysSize, isFixed);\n \n     const size_t maxBlockLen = CalcMaxBlockLenForOutput(callable.GetType()->GetReturnType());\n-    if (aggsParams.empty()) {\n-        return MakeBlockMergeFinalizeHashedWrapper<true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+    if (isStream) {\n+        const auto wideStream = wideStreamOrFlow;\n+        if (aggsParams.empty()) {\n+            return MakeBlockMergeFinalizeHashedWrapper<true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+        } else {\n+            return MakeBlockMergeFinalizeHashedWrapper<false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+        }\n     } else {\n-        return MakeBlockMergeFinalizeHashedWrapper<false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+        const auto wideFlow = dynamic_cast<IComputationWideFlowNode *>(wideStreamOrFlow);\n+        MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+        if (aggsParams.empty()) {\n+            return MakeBlockMergeFinalizeHashedWrapper<true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+        } else {\n+            return MakeBlockMergeFinalizeHashedWrapper<false>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(), keys, maxBlockLen, std::move(aggsParams));\n+        }\n     }\n }\n \n IComputationNode* WrapBlockMergeManyFinalizeHashed(TCallable& callable, const TComputationNodeFactoryContext& ctx) {\n     MKQL_ENSURE(callable.GetInputsCount() == 5, \"Expected 5 args\");\n-    const auto flowType = AS_TYPE(TFlowType, callable.GetInput(0).GetStaticType());\n-    const auto wideComponents = GetWideComponents(flowType);\n+\n+    const bool isStream = callable.GetInput(0).GetStaticType()->IsStream();\n+    MKQL_ENSURE(isStream == callable.GetType()->GetReturnType()->IsStream(), \"input and output must be both either flow or stream\");\n+\n+    const auto wideComponents = GetWideComponents(callable.GetInput(0).GetStaticType());\n     const auto tupleType = TTupleType::Create(wideComponents.size(), wideComponents.data(), ctx.Env);\n-    const auto returnFlowType = AS_TYPE(TFlowType, callable.GetType()->GetReturnType());\n-    const auto returnWideComponents = GetWideComponents(returnFlowType);\n+    const auto returnWideComponents = GetWideComponents(callable.GetType()->GetReturnType());\n \n-    const auto wideFlow = dynamic_cast<IComputationWideFlowNode*>(LocateNode(ctx.NodeLocator, callable, 0));\n-    MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+    const auto wideStreamOrFlow = LocateNode(ctx.NodeLocator, callable, 0);\n \n     auto keysVal = AS_VALUE(TTupleLiteral, callable.GetInput(1));\n     std::vector<TKeyParams> keys;\n@@ -2147,12 +2486,25 @@ IComputationNode* WrapBlockMergeManyFinalizeHashed(TCallable& callable, const TC\n     totalStateSize += streams.size();\n \n     const size_t maxBlockLen = CalcMaxBlockLenForOutput(callable.GetType()->GetReturnType());\n-    if (aggsParams.empty()) {\n-        return MakeBlockMergeFinalizeHashedWrapper<true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(),\n-            keys, maxBlockLen, std::move(aggsParams));\n+    if (isStream){\n+        const auto wideStream = wideStreamOrFlow;\n+        if (aggsParams.empty()) {\n+            return MakeBlockMergeFinalizeHashedWrapper<true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, tupleType->GetElementsCount(),\n+                keys, maxBlockLen, std::move(aggsParams));\n+        } else {\n+            return MakeBlockMergeManyFinalizeHashedWrapper(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideStream, tupleType->GetElementsCount(),\n+                keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        }\n     } else {\n-        return MakeBlockMergeManyFinalizeHashedWrapper(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(),\n-            keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        const auto wideFlow = dynamic_cast<IComputationWideFlowNode *>(wideStreamOrFlow);\n+        MKQL_ENSURE(wideFlow != nullptr, \"Expected wide flow node\");\n+        if (aggsParams.empty()) {\n+            return MakeBlockMergeFinalizeHashedWrapper<true>(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(),\n+                keys, maxBlockLen, std::move(aggsParams));\n+        } else {\n+            return MakeBlockMergeManyFinalizeHashedWrapper(totalKeysSize, isFixed, totalStateSize, ctx.Mutables, wideFlow, tupleType->GetElementsCount(),\n+                keys, maxBlockLen, std::move(aggsParams), streamIndex, std::move(streams));\n+        }\n     }\n }\n \ndiff --git a/ydb/library/yql/minikql/mkql_program_builder.cpp b/ydb/library/yql/minikql/mkql_program_builder.cpp\nindex 3206c5e47a54..00a7f184639c 100644\n--- a/ydb/library/yql/minikql/mkql_program_builder.cpp\n+++ b/ydb/library/yql/minikql/mkql_program_builder.cpp\n@@ -5730,14 +5730,15 @@ TRuntimeNode TProgramBuilder::BlockBitCast(TRuntimeNode value, TType* targetType\n     return TRuntimeNode(builder.Build(), false);\n }\n \n-TRuntimeNode TProgramBuilder::BlockCombineAll(TRuntimeNode flow, std::optional<ui32> filterColumn,\n-    const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n-    if constexpr (RuntimeVersion < 31U) {\n-        THROW yexception() << \"Runtime version (\" << RuntimeVersion << \") too old for \" << __func__;\n-    }\n+TRuntimeNode TProgramBuilder::BuildBlockCombineAll(const std::string_view& callableName, TRuntimeNode input, std::optional<ui32> filterColumn,\n+        const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n+    const auto inputType = input.GetStaticType();\n+    MKQL_ENSURE(inputType->IsStream() || inputType->IsFlow(), \"Expected either stream or flow as input type\");\n+    MKQL_ENSURE(returnType->IsStream() || returnType->IsFlow(), \"Expected either stream or flow as return type\");\n+\n+    TCallableBuilder builder(Env, callableName, returnType);\n+    builder.Add(input);\n \n-    TCallableBuilder builder(Env, __func__, returnType);\n-    builder.Add(flow);\n     if (!filterColumn) {\n         builder.Add(NewEmptyOptionalDataLiteral(NUdf::TDataType<ui32>::Id));\n     } else {\n@@ -5759,14 +5760,32 @@ TRuntimeNode TProgramBuilder::BlockCombineAll(TRuntimeNode flow, std::optional<u\n     return TRuntimeNode(builder.Build(), false);\n }\n \n-TRuntimeNode TProgramBuilder::BlockCombineHashed(TRuntimeNode flow, std::optional<ui32> filterColumn, const TArrayRef<ui32>& keys,\n+TRuntimeNode TProgramBuilder::BlockCombineAll(TRuntimeNode stream, std::optional<ui32> filterColumn,\n     const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n     if constexpr (RuntimeVersion < 31U) {\n         THROW yexception() << \"Runtime version (\" << RuntimeVersion << \") too old for \" << __func__;\n     }\n \n-    TCallableBuilder builder(Env, __func__, returnType);\n-    builder.Add(flow);\n+    MKQL_ENSURE(stream.GetStaticType()->IsStream(), \"Expected stream as input type\");\n+    MKQL_ENSURE(returnType->IsStream(), \"Expected stream as return type\");\n+\n+    if constexpr (RuntimeVersion < 52U) {\n+        const auto flowReturnType = NewFlowType(AS_TYPE(TStreamType, returnType)->GetItemType());\n+        return FromFlow(BuildBlockCombineAll(__func__, ToFlow(stream), filterColumn, aggs, flowReturnType));\n+    } else {\n+        return BuildBlockCombineAll(__func__, stream, filterColumn, aggs, returnType);\n+    }\n+}\n+\n+TRuntimeNode TProgramBuilder::BuildBlockCombineHashed(const std::string_view& callableName, TRuntimeNode input, std::optional<ui32> filterColumn,\n+    const TArrayRef<ui32>& keys, const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n+    const auto inputType = input.GetStaticType();\n+    MKQL_ENSURE(inputType->IsStream() || inputType->IsFlow(), \"Expected either stream or flow as input type\");\n+    MKQL_ENSURE(returnType->IsStream() || returnType->IsFlow(), \"Expected either stream or flow as return type\");\n+\n+    TCallableBuilder builder(Env, callableName, returnType);\n+    builder.Add(input);\n+\n     if (!filterColumn) {\n         builder.Add(NewEmptyOptionalDataLiteral(NUdf::TDataType<ui32>::Id));\n     } else {\n@@ -5794,14 +5813,31 @@ TRuntimeNode TProgramBuilder::BlockCombineHashed(TRuntimeNode flow, std::optiona\n     return TRuntimeNode(builder.Build(), false);\n }\n \n-TRuntimeNode TProgramBuilder::BlockMergeFinalizeHashed(TRuntimeNode flow, const TArrayRef<ui32>& keys,\n+TRuntimeNode TProgramBuilder::BlockCombineHashed(TRuntimeNode stream, std::optional<ui32> filterColumn, const TArrayRef<ui32>& keys,\n     const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n     if constexpr (RuntimeVersion < 31U) {\n         THROW yexception() << \"Runtime version (\" << RuntimeVersion << \") too old for \" << __func__;\n     }\n \n-    TCallableBuilder builder(Env, __func__, returnType);\n-    builder.Add(flow);\n+    MKQL_ENSURE(stream.GetStaticType()->IsStream(), \"Expected stream as input type\");\n+    MKQL_ENSURE(returnType->IsStream(), \"Expected stream as return type\");\n+\n+    if constexpr (RuntimeVersion < 52U) {\n+        const auto flowReturnType = NewFlowType(AS_TYPE(TStreamType, returnType)->GetItemType());\n+        return FromFlow(BuildBlockCombineHashed(__func__, ToFlow(stream), filterColumn, keys, aggs, flowReturnType));\n+    } else {\n+        return BuildBlockCombineHashed(__func__, stream, filterColumn, keys, aggs, returnType);\n+    }    \n+}\n+\n+TRuntimeNode TProgramBuilder::BuildBlockMergeFinalizeHashed(const std::string_view& callableName, TRuntimeNode input, const TArrayRef<ui32>& keys,\n+    const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n+    const auto inputType = input.GetStaticType();\n+    MKQL_ENSURE(inputType->IsStream() || inputType->IsFlow(), \"Expected either stream or flow as input type\");\n+    MKQL_ENSURE(returnType->IsStream() || returnType->IsFlow(), \"Expected either stream or flow as return type\");\n+\n+    TCallableBuilder builder(Env, callableName, returnType);\n+    builder.Add(input);\n \n     TVector<TRuntimeNode> keyNodes;\n     for (const auto& key : keys) {\n@@ -5824,14 +5860,31 @@ TRuntimeNode TProgramBuilder::BlockMergeFinalizeHashed(TRuntimeNode flow, const\n     return TRuntimeNode(builder.Build(), false);\n }\n \n-TRuntimeNode TProgramBuilder::BlockMergeManyFinalizeHashed(TRuntimeNode flow, const TArrayRef<ui32>& keys,\n-    const TArrayRef<const TAggInfo>& aggs, ui32 streamIndex, const TVector<TVector<ui32>>& streams, TType* returnType) {\n+TRuntimeNode TProgramBuilder::BlockMergeFinalizeHashed(TRuntimeNode stream, const TArrayRef<ui32>& keys,\n+    const TArrayRef<const TAggInfo>& aggs, TType* returnType) {\n     if constexpr (RuntimeVersion < 31U) {\n         THROW yexception() << \"Runtime version (\" << RuntimeVersion << \") too old for \" << __func__;\n     }\n \n-    TCallableBuilder builder(Env, __func__, returnType);\n-    builder.Add(flow);\n+    MKQL_ENSURE(stream.GetStaticType()->IsStream(), \"Expected stream as input type\");\n+    MKQL_ENSURE(returnType->IsStream(), \"Expected stream as return type\");\n+\n+    if constexpr (RuntimeVersion < 52U) {\n+        const auto flowReturnType = NewFlowType(AS_TYPE(TStreamType, returnType)->GetItemType());\n+        return FromFlow(BuildBlockMergeFinalizeHashed(__func__, ToFlow(stream), keys, aggs, flowReturnType));\n+    } else {\n+        return BuildBlockMergeFinalizeHashed(__func__, stream, keys, aggs, returnType);\n+    }\n+}\n+\n+TRuntimeNode TProgramBuilder::BuildBlockMergeManyFinalizeHashed(const std::string_view& callableName, TRuntimeNode input, const TArrayRef<ui32>& keys,\n+    const TArrayRef<const TAggInfo>& aggs, ui32 streamIndex, const TVector<TVector<ui32>>& streams, TType* returnType) {\n+    const auto inputType = input.GetStaticType();\n+    MKQL_ENSURE(inputType->IsStream() || inputType->IsFlow(), \"Expected either stream or flow as input type\");\n+    MKQL_ENSURE(returnType->IsStream() || returnType->IsFlow(), \"Expected either stream or flow as return type\");\n+\n+    TCallableBuilder builder(Env, callableName, returnType);\n+    builder.Add(input);\n \n     TVector<TRuntimeNode> keyNodes;\n     for (const auto& key : keys) {\n@@ -5866,6 +5919,23 @@ TRuntimeNode TProgramBuilder::BlockMergeManyFinalizeHashed(TRuntimeNode flow, co\n     return TRuntimeNode(builder.Build(), false);\n }\n \n+TRuntimeNode TProgramBuilder::BlockMergeManyFinalizeHashed(TRuntimeNode stream, const TArrayRef<ui32>& keys,\n+    const TArrayRef<const TAggInfo>& aggs, ui32 streamIndex, const TVector<TVector<ui32>>& streams, TType* returnType) {\n+    if constexpr (RuntimeVersion < 31U) {\n+        THROW yexception() << \"Runtime version (\" << RuntimeVersion << \") too old for \" << __func__;\n+    }\n+\n+    MKQL_ENSURE(stream.GetStaticType()->IsStream(), \"Expected stream as input type\");\n+    MKQL_ENSURE(returnType->IsStream(), \"Expected stream as return type\");\n+\n+    if constexpr (RuntimeVersion < 52U) {\n+        const auto flowReturnType = NewFlowType(AS_TYPE(TStreamType, returnType)->GetItemType());\n+        return FromFlow(BuildBlockMergeManyFinalizeHashed(__func__, ToFlow(stream), keys, aggs, streamIndex, streams, flowReturnType));\n+    } else {\n+        return BuildBlockMergeManyFinalizeHashed(__func__, stream, keys, aggs, streamIndex, streams, returnType);\n+    }\n+}\n+\n TRuntimeNode TProgramBuilder::ScalarApply(const TArrayRef<const TRuntimeNode>& args, const TArrayLambda& handler) {\n     if constexpr (RuntimeVersion < 39U) {\n         THROW yexception() << \"Runtime version (\" << RuntimeVersion << \") too old for \" << __func__;\ndiff --git a/ydb/library/yql/minikql/mkql_program_builder.h b/ydb/library/yql/minikql/mkql_program_builder.h\nindex 58fdc4c27247..74cf9a80ead5 100644\n--- a/ydb/library/yql/minikql/mkql_program_builder.h\n+++ b/ydb/library/yql/minikql/mkql_program_builder.h\n@@ -759,6 +759,15 @@ class TProgramBuilder : public TTypeBuilder {\n private:\n     TRuntimeNode BuildWideFilter(const std::string_view& callableName, TRuntimeNode flow, const TNarrowLambda& handler);\n \n+    TRuntimeNode BuildBlockCombineAll(const std::string_view& callableName, TRuntimeNode input, std::optional<ui32> filterColumn,\n+        const TArrayRef<const TAggInfo>& aggs, TType* returnType);\n+    TRuntimeNode BuildBlockCombineHashed(const std::string_view& callableName, TRuntimeNode input, std::optional<ui32> filterColumn,\n+        const TArrayRef<ui32>& keys, const TArrayRef<const TAggInfo>& aggs, TType* returnType);\n+    TRuntimeNode BuildBlockMergeFinalizeHashed(const std::string_view& callableName, TRuntimeNode input, const TArrayRef<ui32>& keys,\n+        const TArrayRef<const TAggInfo>& aggs, TType* returnType);\n+    TRuntimeNode BuildBlockMergeManyFinalizeHashed(const std::string_view& callableName, TRuntimeNode input, const TArrayRef<ui32>& keys,\n+        const TArrayRef<const TAggInfo>& aggs, ui32 streamIndex, const TVector<TVector<ui32>>& streams, TType* returnType);\n+\n     TRuntimeNode DictItems(TRuntimeNode dict, EDictItems mode);\n     TRuntimeNode If(TRuntimeNode condition, TRuntimeNode thenBranch, TRuntimeNode elseBranch, TType* resultType);\n \ndiff --git a/ydb/library/yql/minikql/mkql_runtime_version.h b/ydb/library/yql/minikql/mkql_runtime_version.h\nindex 4d416ac7089d..bfd26216ab87 100644\n--- a/ydb/library/yql/minikql/mkql_runtime_version.h\n+++ b/ydb/library/yql/minikql/mkql_runtime_version.h\n@@ -24,7 +24,7 @@ namespace NMiniKQL {\n // 1. Bump this version every time incompatible runtime nodes are introduced.\n // 2. Make sure you provide runtime node generation for previous runtime versions.\n #ifndef MKQL_RUNTIME_VERSION\n-#define MKQL_RUNTIME_VERSION 51U\n+#define MKQL_RUNTIME_VERSION 52U\n #endif\n \n // History:\n",
  "test_patch": "diff --git a/ydb/library/yql/tests/sql/yt_native_file/part0/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part0/canondata/result.json\nindex f0c56ac68990..2ced6d896bda 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part0/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part0/canondata/result.json\n@@ -486,9 +486,9 @@\n     ],\n     \"test.test[blocks-combine_all_pg_filter--Peephole]\": [\n         {\n-            \"checksum\": \"b82fb484ea512752ac0bd055f2881bad\",\n-            \"size\": 5463,\n-            \"uri\": \"https://{canondata_backend}/1689644/c571b164c0329219eb668c8d9e33807153d99a05/resource.tar.gz#test.test_blocks-combine_all_pg_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"f9644e5d1aa2916e452370ff93594ba1\",\n+            \"size\": 5584,\n+            \"uri\": \"https://{canondata_backend}/1942100/eca836514e0d22543696dadda9c6b5fd0411ec2c/resource.tar.gz#test.test_blocks-combine_all_pg_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_pg_filter--Plan]\": [\n@@ -598,9 +598,9 @@\n     ],\n     \"test.test[blocks-minmax_strings--Peephole]\": [\n         {\n-            \"checksum\": \"e24251cf43d6e021c673a59a5d975701\",\n-            \"size\": 7778,\n-            \"uri\": \"https://{canondata_backend}/1775319/332ffa137abc3e824ae9020e8b37875c568e01e9/resource.tar.gz#test.test_blocks-minmax_strings--Peephole_/opt.yql\"\n+            \"checksum\": \"585085c48335fca5229be389e233cf6b\",\n+            \"size\": 8001,\n+            \"uri\": \"https://{canondata_backend}/1942100/eca836514e0d22543696dadda9c6b5fd0411ec2c/resource.tar.gz#test.test_blocks-minmax_strings--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-minmax_strings--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part1/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part1/canondata/result.json\nindex 8481f910b3da..c215fcd5235c 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part1/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part1/canondata/result.json\n@@ -643,9 +643,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_min--Peephole]\": [\n         {\n-            \"checksum\": \"6a4ee50207cc13b68ec0b901b5c90bbc\",\n-            \"size\": 3482,\n-            \"uri\": \"https://{canondata_backend}/1889210/5d1223c56711b5ccfa2ce8980fabbe18f3a04d58/resource.tar.gz#test.test_blocks-combine_hashed_min--Peephole_/opt.yql\"\n+            \"checksum\": \"fe48deb06089372a1be7b0f21a39fafa\",\n+            \"size\": 3530,\n+            \"uri\": \"https://{canondata_backend}/1942100/460fd0564dd37c75913eb7e3e5f96a12d70b483a/resource.tar.gz#test.test_blocks-combine_hashed_min--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_min--Plan]\": [\n@@ -671,9 +671,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_minmax_double--Peephole]\": [\n         {\n-            \"checksum\": \"4eed869d74a2e6927965254eaabfaef9\",\n-            \"size\": 2858,\n-            \"uri\": \"https://{canondata_backend}/1889210/5d1223c56711b5ccfa2ce8980fabbe18f3a04d58/resource.tar.gz#test.test_blocks-combine_hashed_minmax_double--Peephole_/opt.yql\"\n+            \"checksum\": \"ed48b0c0f01f1031a11943749017abb4\",\n+            \"size\": 2862,\n+            \"uri\": \"https://{canondata_backend}/1942100/460fd0564dd37c75913eb7e3e5f96a12d70b483a/resource.tar.gz#test.test_blocks-combine_hashed_minmax_double--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_minmax_double--Plan]\": [\n@@ -699,9 +699,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_set--Peephole]\": [\n         {\n-            \"checksum\": \"c8527dced2050b347b8abb2b106e392e\",\n-            \"size\": 2248,\n-            \"uri\": \"https://{canondata_backend}/1817427/bbd43b1ed3e4b4e4804e9367a38fc8672c2b46db/resource.tar.gz#test.test_blocks-combine_hashed_set--Peephole_/opt.yql\"\n+            \"checksum\": \"65b13975fe3b35dcf2a50f4c796a12c9\",\n+            \"size\": 2268,\n+            \"uri\": \"https://{canondata_backend}/1942100/460fd0564dd37c75913eb7e3e5f96a12d70b483a/resource.tar.gz#test.test_blocks-combine_hashed_set--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_set--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part10/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part10/canondata/result.json\nindex 03e94c85373f..ce2ed47b47dd 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part10/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part10/canondata/result.json\n@@ -460,9 +460,9 @@\n     ],\n     \"test.test[blocks-combine_all_avg_filter--Peephole]\": [\n         {\n-            \"checksum\": \"67e87d544bf1db7426409705ac43f5d2\",\n-            \"size\": 2221,\n-            \"uri\": \"https://{canondata_backend}/1689644/e953ec7ef3d2122dd1da61bd4dc7f631010ae6c6/resource.tar.gz#test.test_blocks-combine_all_avg_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"839af3ed70bf69f8c9ac1d08a622b053\",\n+            \"size\": 2264,\n+            \"uri\": \"https://{canondata_backend}/1936273/60c8060084c7fca13bcbdeeafd7bb7009b935816/resource.tar.gz#test.test_blocks-combine_all_avg_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_avg_filter--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part11/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part11/canondata/result.json\nindex 61cdc48301b2..44d76a49210b 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part11/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part11/canondata/result.json\n@@ -417,9 +417,9 @@\n     ],\n     \"test.test[blocks-combine_all_decimal--Peephole]\": [\n         {\n-            \"checksum\": \"f4f26b88e3c27f7c7b7e9a1dbdd2297d\",\n-            \"size\": 5371,\n-            \"uri\": \"https://{canondata_backend}/1689644/6b51d5d198e5b6a200e05073bbbd27568362da19/resource.tar.gz#test.test_blocks-combine_all_decimal--Peephole_/opt.yql\"\n+            \"checksum\": \"f1af6f4b597cfc3f02016363538384b6\",\n+            \"size\": 5391,\n+            \"uri\": \"https://{canondata_backend}/1937001/d7dd873e29f16ef285cde87454b8789a4270b9bf/resource.tar.gz#test.test_blocks-combine_all_decimal--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_decimal--Plan]\": [\n@@ -445,9 +445,9 @@\n     ],\n     \"test.test[blocks-combine_all_some_filter--Peephole]\": [\n         {\n-            \"checksum\": \"04b9f3cbee17a2e2af320d0764578a2e\",\n-            \"size\": 2020,\n-            \"uri\": \"https://{canondata_backend}/1689644/6b51d5d198e5b6a200e05073bbbd27568362da19/resource.tar.gz#test.test_blocks-combine_all_some_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"12353b122e8698f5979ab7ac48edbf28\",\n+            \"size\": 2063,\n+            \"uri\": \"https://{canondata_backend}/1937001/d7dd873e29f16ef285cde87454b8789a4270b9bf/resource.tar.gz#test.test_blocks-combine_all_some_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_some_filter--Plan]\": [\n@@ -473,9 +473,9 @@\n     ],\n     \"test.test[blocks-combine_all_sum--Peephole]\": [\n         {\n-            \"checksum\": \"2c97860ba346328f8a92d745c7ca45fa\",\n-            \"size\": 4165,\n-            \"uri\": \"https://{canondata_backend}/1689644/6b51d5d198e5b6a200e05073bbbd27568362da19/resource.tar.gz#test.test_blocks-combine_all_sum--Peephole_/opt.yql\"\n+            \"checksum\": \"1332006a572a466ce7cc65cb9f79d3d4\",\n+            \"size\": 4185,\n+            \"uri\": \"https://{canondata_backend}/1937001/d7dd873e29f16ef285cde87454b8789a4270b9bf/resource.tar.gz#test.test_blocks-combine_all_sum--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_sum--Plan]\": [\n@@ -501,9 +501,9 @@\n     ],\n     \"test.test[blocks-distinct_opt_state_keys--Peephole]\": [\n         {\n-            \"checksum\": \"19872b5003fd570975efecbb34cb27a7\",\n-            \"size\": 8532,\n-            \"uri\": \"https://{canondata_backend}/1900335/48c1045110f93be7271adb6caf109f9f9e32f3bc/resource.tar.gz#test.test_blocks-distinct_opt_state_keys--Peephole_/opt.yql\"\n+            \"checksum\": \"2019c89c68ce2f33c11bafe6a65b4f43\",\n+            \"size\": 8686,\n+            \"uri\": \"https://{canondata_backend}/1937001/d7dd873e29f16ef285cde87454b8789a4270b9bf/resource.tar.gz#test.test_blocks-distinct_opt_state_keys--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-distinct_opt_state_keys--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part12/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part12/canondata/result.json\nindex a8b14f0bd16c..5868608e6adb 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part12/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part12/canondata/result.json\n@@ -472,9 +472,9 @@\n     ],\n     \"test.test[blocks-combine_all_max--Peephole]\": [\n         {\n-            \"checksum\": \"311b380d0cf9a03f17b5be896eb75d52\",\n-            \"size\": 6265,\n-            \"uri\": \"https://{canondata_backend}/1936273/2e12f403b84f544db0dddee878135eb165520afe/resource.tar.gz#test.test_blocks-combine_all_max--Peephole_/opt.yql\"\n+            \"checksum\": \"578d8413e4f0938c5c51ddbd50c7ffde\",\n+            \"size\": 6267,\n+            \"uri\": \"https://{canondata_backend}/1942100/1b0eecc460579a62c09a8328b78b1c3d0737be71/resource.tar.gz#test.test_blocks-combine_all_max--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_max--Plan]\": [\n@@ -500,9 +500,9 @@\n     ],\n     \"test.test[blocks-combine_all_minmax_nested--Peephole]\": [\n         {\n-            \"checksum\": \"a0294d39683e7ad6fa80cfeb34bbf0a0\",\n-            \"size\": 3407,\n-            \"uri\": \"https://{canondata_backend}/1936273/2e12f403b84f544db0dddee878135eb165520afe/resource.tar.gz#test.test_blocks-combine_all_minmax_nested--Peephole_/opt.yql\"\n+            \"checksum\": \"1d3e6826662dae4130959c4b1e4d197c\",\n+            \"size\": 3427,\n+            \"uri\": \"https://{canondata_backend}/1942100/1b0eecc460579a62c09a8328b78b1c3d0737be71/resource.tar.gz#test.test_blocks-combine_all_minmax_nested--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_minmax_nested--Plan]\": [\n@@ -528,9 +528,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_sum--Peephole]\": [\n         {\n-            \"checksum\": \"b9e75e3fb2350f09dbbcd3a17fa55617\",\n-            \"size\": 3542,\n-            \"uri\": \"https://{canondata_backend}/1942671/7651701708982db1bc7660dcd6a1d063fc197122/resource.tar.gz#test.test_blocks-combine_hashed_sum--Peephole_/opt.yql\"\n+            \"checksum\": \"ece135ac007bb7b19234bbf85e0aee45\",\n+            \"size\": 3590,\n+            \"uri\": \"https://{canondata_backend}/1920236/0b8929411f995ee81d269f8519a2b62822b5b0f7/resource.tar.gz#test.test_blocks-combine_hashed_sum--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_sum--Plan]\": [\n@@ -724,9 +724,9 @@\n     ],\n     \"test.test[blocks-lazy_nonstrict_with_scalar_ctx--Peephole]\": [\n         {\n-            \"checksum\": \"5f260ad4f10c1e79d9bec7361e08d388\",\n-            \"size\": 3760,\n-            \"uri\": \"https://{canondata_backend}/1936273/2e12f403b84f544db0dddee878135eb165520afe/resource.tar.gz#test.test_blocks-lazy_nonstrict_with_scalar_ctx--Peephole_/opt.yql\"\n+            \"checksum\": \"526263536048e247185473b3e7e22a71\",\n+            \"size\": 3708,\n+            \"uri\": \"https://{canondata_backend}/1942100/1b0eecc460579a62c09a8328b78b1c3d0737be71/resource.tar.gz#test.test_blocks-lazy_nonstrict_with_scalar_ctx--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-lazy_nonstrict_with_scalar_ctx--Plan]\": [\n@@ -752,9 +752,9 @@\n     ],\n     \"test.test[blocks-minmax_strings_filter--Peephole]\": [\n         {\n-            \"checksum\": \"96ad208ff8de572b236d23a250c26c0e\",\n-            \"size\": 3925,\n-            \"uri\": \"https://{canondata_backend}/1942671/7651701708982db1bc7660dcd6a1d063fc197122/resource.tar.gz#test.test_blocks-minmax_strings_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"f0048f669753144b52457204bff26d18\",\n+            \"size\": 4056,\n+            \"uri\": \"https://{canondata_backend}/1942100/1b0eecc460579a62c09a8328b78b1c3d0737be71/resource.tar.gz#test.test_blocks-minmax_strings_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-minmax_strings_filter--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part13/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part13/canondata/result.json\nindex 6497eaa24ff2..3b761f328fbc 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part13/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part13/canondata/result.json\n@@ -484,9 +484,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_pg--Peephole]\": [\n         {\n-            \"checksum\": \"44f4557f8602e6367b7cff827ac89234\",\n-            \"size\": 6379,\n-            \"uri\": \"https://{canondata_backend}/1880306/c85931dc2ddfc9372ac5287e031731a861495fb0/resource.tar.gz#test.test_blocks-combine_hashed_pg--Peephole_/opt.yql\"\n+            \"checksum\": \"bdb9351eb3f869d1e2e3bd47329de921\",\n+            \"size\": 6507,\n+            \"uri\": \"https://{canondata_backend}/1775319/1d2e8f1b903194b7f97d4c3a5928f81379354efa/resource.tar.gz#test.test_blocks-combine_hashed_pg--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_pg--Plan]\": [\n@@ -512,9 +512,9 @@\n     ],\n     \"test.test[blocks-distinct_opt_state_all--Peephole]\": [\n         {\n-            \"checksum\": \"615baf31dbbe6dd549fee114e9f17fe5\",\n-            \"size\": 8713,\n-            \"uri\": \"https://{canondata_backend}/995452/76963fbe19e9e3c21b622412a3ae8fe5473f46ef/resource.tar.gz#test.test_blocks-distinct_opt_state_all--Peephole_/opt.yql\"\n+            \"checksum\": \"1333bede710777316d4570510fd4ea7f\",\n+            \"size\": 8841,\n+            \"uri\": \"https://{canondata_backend}/1936273/1342bc207252f0d51d2a5d59cf94c96ae9330665/resource.tar.gz#test.test_blocks-distinct_opt_state_all--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-distinct_opt_state_all--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part14/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part14/canondata/result.json\nindex 0d2d2128e404..9d7691e3896c 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part14/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part14/canondata/result.json\n@@ -574,9 +574,9 @@\n     ],\n     \"test.test[blocks-combine_all_max_filter_opt--Peephole]\": [\n         {\n-            \"checksum\": \"ce72dc5aaf5dbc78a6afb13ac9ae87da\",\n-            \"size\": 2119,\n-            \"uri\": \"https://{canondata_backend}/1936273/9a6c178c3ec8bbc5f8d9a423f1c2a4b808cc630a/resource.tar.gz#test.test_blocks-combine_all_max_filter_opt--Peephole_/opt.yql\"\n+            \"checksum\": \"eba47c259d4e240f3d15ddd779edc6e5\",\n+            \"size\": 2162,\n+            \"uri\": \"https://{canondata_backend}/1936273/780afd5c76cefb9a0deca536730d6e710dfd47af/resource.tar.gz#test.test_blocks-combine_all_max_filter_opt--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_max_filter_opt--Plan]\": [\n@@ -602,9 +602,9 @@\n     ],\n     \"test.test[blocks-combine_all_min--Peephole]\": [\n         {\n-            \"checksum\": \"57cce58a2b91b32ee543632601fbc42d\",\n-            \"size\": 6265,\n-            \"uri\": \"https://{canondata_backend}/1936273/9a6c178c3ec8bbc5f8d9a423f1c2a4b808cc630a/resource.tar.gz#test.test_blocks-combine_all_min--Peephole_/opt.yql\"\n+            \"checksum\": \"d2ccd2cda420b126acf214dd58008924\",\n+            \"size\": 6267,\n+            \"uri\": \"https://{canondata_backend}/1936273/780afd5c76cefb9a0deca536730d6e710dfd47af/resource.tar.gz#test.test_blocks-combine_all_min--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_min--Plan]\": [\n@@ -630,9 +630,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_count--Peephole]\": [\n         {\n-            \"checksum\": \"97ac986b17396f7162260355d37e2f2b\",\n-            \"size\": 3630,\n-            \"uri\": \"https://{canondata_backend}/1775319/dffc024d6db08a14065eefff7616512e9ec14ce3/resource.tar.gz#test.test_blocks-combine_hashed_count--Peephole_/opt.yql\"\n+            \"checksum\": \"5fd4f1661e889ec3e4f8cce021d028e3\",\n+            \"size\": 3678,\n+            \"uri\": \"https://{canondata_backend}/1881367/4c7aa0ee09ad13a7c4c8522afaebb0a34e8a70bf/resource.tar.gz#test.test_blocks-combine_hashed_count--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_count--Plan]\": [\n@@ -770,9 +770,9 @@\n     ],\n     \"test.test[blocks-minmax_tuple--Peephole]\": [\n         {\n-            \"checksum\": \"88907c5a0dc7d235be650136e083477c\",\n-            \"size\": 5500,\n-            \"uri\": \"https://{canondata_backend}/1936273/9a6c178c3ec8bbc5f8d9a423f1c2a4b808cc630a/resource.tar.gz#test.test_blocks-minmax_tuple--Peephole_/opt.yql\"\n+            \"checksum\": \"34fdb2237dc2a52901a3279048cb493d\",\n+            \"size\": 5540,\n+            \"uri\": \"https://{canondata_backend}/1936273/780afd5c76cefb9a0deca536730d6e710dfd47af/resource.tar.gz#test.test_blocks-minmax_tuple--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-minmax_tuple--Plan]\": [\n@@ -854,9 +854,9 @@\n     ],\n     \"test.test[blocks-struct_type--Peephole]\": [\n         {\n-            \"checksum\": \"1e4eb1415a14aaa58a5201e1dff2698b\",\n-            \"size\": 3095,\n-            \"uri\": \"https://{canondata_backend}/1775319/dffc024d6db08a14065eefff7616512e9ec14ce3/resource.tar.gz#test.test_blocks-struct_type--Peephole_/opt.yql\"\n+            \"checksum\": \"f89c5ad6de169db5bceb2280b2b45c19\",\n+            \"size\": 3099,\n+            \"uri\": \"https://{canondata_backend}/1881367/4c7aa0ee09ad13a7c4c8522afaebb0a34e8a70bf/resource.tar.gz#test.test_blocks-struct_type--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-struct_type--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part16/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part16/canondata/result.json\nindex 82b44a83b7d0..652a27b22dd6 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part16/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part16/canondata/result.json\n@@ -495,9 +495,9 @@\n     ],\n     \"test.test[blocks-combine_all_pg--Peephole]\": [\n         {\n-            \"checksum\": \"51b056d9dadc4c2d59d4d5e57572682a\",\n-            \"size\": 7688,\n-            \"uri\": \"https://{canondata_backend}/1689644/b05960229650fc70467add9c3d7638a8f3cdf3e1/resource.tar.gz#test.test_blocks-combine_all_pg--Peephole_/opt.yql\"\n+            \"checksum\": \"4ddca44c25daaec6456186fbb157f488\",\n+            \"size\": 7776,\n+            \"uri\": \"https://{canondata_backend}/1916746/e62dc8205f86272010640f8fa6ec2e825d624df1/resource.tar.gz#test.test_blocks-combine_all_pg--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_pg--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part17/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part17/canondata/result.json\nindex 593cb70acd99..9e959a3ae248 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part17/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part17/canondata/result.json\n@@ -543,9 +543,9 @@\n     ],\n     \"test.test[blocks-combine_all_count_filter_opt--Peephole]\": [\n         {\n-            \"checksum\": \"d05f14700984d99846058bdf6739bad9\",\n-            \"size\": 2233,\n-            \"uri\": \"https://{canondata_backend}/1903885/ffc476321aa22def0fffeeb1a5d7ff900dfce9d6/resource.tar.gz#test.test_blocks-combine_all_count_filter_opt--Peephole_/opt.yql\"\n+            \"checksum\": \"623683acd53d94b06b7a19bdb11b4ecf\",\n+            \"size\": 2276,\n+            \"uri\": \"https://{canondata_backend}/1937001/3b94c4bb2028a21752a5dee6baf1a850ce51d480/resource.tar.gz#test.test_blocks-combine_all_count_filter_opt--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_count_filter_opt--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part18/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part18/canondata/result.json\nindex 942fb845d0b3..26b520484487 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part18/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part18/canondata/result.json\n@@ -456,9 +456,9 @@\n     ],\n     \"test.test[blocks-combine_all_min_filter--Peephole]\": [\n         {\n-            \"checksum\": \"1c63e924b4b71fb5db01c98dc02d38d8\",\n-            \"size\": 2052,\n-            \"uri\": \"https://{canondata_backend}/1903885/631311924f7bd550e8916c87c0bf4ae694df8ae6/resource.tar.gz#test.test_blocks-combine_all_min_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"4a8fc10717081d3a01a44dbc27597c1f\",\n+            \"size\": 2095,\n+            \"uri\": \"https://{canondata_backend}/1775319/8b72d711520d5cd84e67e6541ace66cd7067ac53/resource.tar.gz#test.test_blocks-combine_all_min_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_min_filter--Plan]\": [\n@@ -512,9 +512,9 @@\n     ],\n     \"test.test[blocks-date_group_by--Peephole]\": [\n         {\n-            \"checksum\": \"54e328a37fe9c9cc95f84acce454d9af\",\n-            \"size\": 4667,\n-            \"uri\": \"https://{canondata_backend}/1942100/977b836f807d2b39508e2ee0606842a99261a1da/resource.tar.gz#test.test_blocks-date_group_by--Peephole_/opt.yql\"\n+            \"checksum\": \"c44c3b19c19cb7bec1fc9a11abdf89b8\",\n+            \"size\": 4673,\n+            \"uri\": \"https://{canondata_backend}/1775319/8b72d711520d5cd84e67e6541ace66cd7067ac53/resource.tar.gz#test.test_blocks-date_group_by--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-date_group_by--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part19/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part19/canondata/result.json\nindex 4d991f8c5821..70f33ed1542a 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part19/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part19/canondata/result.json\n@@ -584,9 +584,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_max--Peephole]\": [\n         {\n-            \"checksum\": \"072de32f237c0a659fcb217825d6fe8d\",\n-            \"size\": 3482,\n-            \"uri\": \"https://{canondata_backend}/1942173/d7b51a8943054cfea98b1e42450768694da5000b/resource.tar.gz#test.test_blocks-combine_hashed_max--Peephole_/opt.yql\"\n+            \"checksum\": \"1c4cc1601f1f61b764e391b851324999\",\n+            \"size\": 3530,\n+            \"uri\": \"https://{canondata_backend}/1946324/820e3db848dce72eac40665b9ca64552c869136b/resource.tar.gz#test.test_blocks-combine_hashed_max--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_max--Plan]\": [\n@@ -612,9 +612,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_sum_many_keys--Peephole]\": [\n         {\n-            \"checksum\": \"dce58d7114cdf691cd277a82b722aaef\",\n-            \"size\": 11971,\n-            \"uri\": \"https://{canondata_backend}/1775319/049530c2ab88f8664aade59a42710a0f0aec002c/resource.tar.gz#test.test_blocks-combine_hashed_sum_many_keys--Peephole_/opt.yql\"\n+            \"checksum\": \"616ca4f49125448895b333f0c77aa4bb\",\n+            \"size\": 12071,\n+            \"uri\": \"https://{canondata_backend}/1946324/820e3db848dce72eac40665b9ca64552c869136b/resource.tar.gz#test.test_blocks-combine_hashed_sum_many_keys--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_sum_many_keys--Plan]\": [\n@@ -640,9 +640,9 @@\n     ],\n     \"test.test[blocks-distinct_mixed_keys--Peephole]\": [\n         {\n-            \"checksum\": \"16b9a0bc731ecbefb8d4274854782711\",\n-            \"size\": 7436,\n-            \"uri\": \"https://{canondata_backend}/1775319/049530c2ab88f8664aade59a42710a0f0aec002c/resource.tar.gz#test.test_blocks-distinct_mixed_keys--Peephole_/opt.yql\"\n+            \"checksum\": \"76517f43bab95ee0125ec1b4ccf3a55b\",\n+            \"size\": 7664,\n+            \"uri\": \"https://{canondata_backend}/1937001/e715663cfc04c70f73b3049843d47c204d5f6c08/resource.tar.gz#test.test_blocks-distinct_mixed_keys--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-distinct_mixed_keys--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part2/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part2/canondata/result.json\nindex fb46e91aedd9..05a7281af69a 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part2/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part2/canondata/result.json\n@@ -554,9 +554,9 @@\n     ],\n     \"test.test[blocks-combine_all_minmax_double--Peephole]\": [\n         {\n-            \"checksum\": \"b2c19f7c87d23fc16be804df86d23185\",\n-            \"size\": 2017,\n-            \"uri\": \"https://{canondata_backend}/995452/d8c0a0cd1e7f0cabf7ce37e867037d3ed9ceb5b4/resource.tar.gz#test.test_blocks-combine_all_minmax_double--Peephole_/opt.yql\"\n+            \"checksum\": \"b2b4a9eeb219a440e6ab3de3861533c0\",\n+            \"size\": 2037,\n+            \"uri\": \"https://{canondata_backend}/1936273/085dd9582c7a504381fe179e61eafc7aa1a2ac09/resource.tar.gz#test.test_blocks-combine_all_minmax_double--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_minmax_double--Plan]\": [\n@@ -722,9 +722,9 @@\n     ],\n     \"test.test[blocks-string_as_agg_key--Peephole]\": [\n         {\n-            \"checksum\": \"5923fbb79cabc45e72d3e1b1ee3a9ecf\",\n-            \"size\": 4217,\n-            \"uri\": \"https://{canondata_backend}/1936947/cf80e3ac9f8ab72a1a9ec43a693fa2afe6eab064/resource.tar.gz#test.test_blocks-string_as_agg_key--Peephole_/opt.yql\"\n+            \"checksum\": \"e54b6a68d1a685a982fc3093a411d4c2\",\n+            \"size\": 4257,\n+            \"uri\": \"https://{canondata_backend}/1942525/f1dbd68be895d5bf52c9eba32b1cb5bb032d2c48/resource.tar.gz#test.test_blocks-string_as_agg_key--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-string_as_agg_key--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part3/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part3/canondata/result.json\nindex 7c6805d5c5ea..c2f6ac769a5b 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part3/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part3/canondata/result.json\n@@ -385,9 +385,9 @@\n     ],\n     \"test.test[blocks-combine_all_sum_filter_opt--Peephole]\": [\n         {\n-            \"checksum\": \"ff2c95963b13fa52699ffa7c693a6a58\",\n-            \"size\": 2119,\n-            \"uri\": \"https://{canondata_backend}/1689644/ed8a7467fa50846051bff00d767534d539df7443/resource.tar.gz#test.test_blocks-combine_all_sum_filter_opt--Peephole_/opt.yql\"\n+            \"checksum\": \"12c44da956ba25f6ecdcb9cb6a59c970\",\n+            \"size\": 2162,\n+            \"uri\": \"https://{canondata_backend}/1925821/5430ca5ee93f79b17db6a6f6b6c531354175f340/resource.tar.gz#test.test_blocks-combine_all_sum_filter_opt--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_sum_filter_opt--Plan]\": [\n@@ -413,9 +413,9 @@\n     ],\n     \"test.test[blocks-distinct_pure_all--Peephole]\": [\n         {\n-            \"checksum\": \"054591522c53f5abcbc928609cdaf8f1\",\n-            \"size\": 3185,\n-            \"uri\": \"https://{canondata_backend}/1689644/ed8a7467fa50846051bff00d767534d539df7443/resource.tar.gz#test.test_blocks-distinct_pure_all--Peephole_/opt.yql\"\n+            \"checksum\": \"6ab2263b47ec33e1dac75559b453cbc2\",\n+            \"size\": 3287,\n+            \"uri\": \"https://{canondata_backend}/1925821/5430ca5ee93f79b17db6a6f6b6c531354175f340/resource.tar.gz#test.test_blocks-distinct_pure_all--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-distinct_pure_all--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part4/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part4/canondata/result.json\nindex 818799a49190..e6a4a05c08db 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part4/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part4/canondata/result.json\n@@ -546,9 +546,9 @@\n     ],\n     \"test.test[blocks-combine_all_min_filter_opt--Peephole]\": [\n         {\n-            \"checksum\": \"ff2c95963b13fa52699ffa7c693a6a58\",\n-            \"size\": 2119,\n-            \"uri\": \"https://{canondata_backend}/1936273/8bc4af96bbb1500304fd1be8e2559bcbead7eb36/resource.tar.gz#test.test_blocks-combine_all_min_filter_opt--Peephole_/opt.yql\"\n+            \"checksum\": \"12c44da956ba25f6ecdcb9cb6a59c970\",\n+            \"size\": 2162,\n+            \"uri\": \"https://{canondata_backend}/1937001/4c624b84b0fd73da233705cdf7f661499ce8ebcf/resource.tar.gz#test.test_blocks-combine_all_min_filter_opt--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_min_filter_opt--Plan]\": [\n@@ -574,9 +574,9 @@\n     ],\n     \"test.test[blocks-decimal_avg--Peephole]\": [\n         {\n-            \"checksum\": \"cdc8a4d00988408c92640297fa47c45a\",\n-            \"size\": 3137,\n-            \"uri\": \"https://{canondata_backend}/1931696/1cb947d289c4d65b45c3fba919aa59c8a7d02c7a/resource.tar.gz#test.test_blocks-decimal_avg--Peephole_/opt.yql\"\n+            \"checksum\": \"3d5fcce74de740687d3dc82295049e37\",\n+            \"size\": 3157,\n+            \"uri\": \"https://{canondata_backend}/1937001/4c624b84b0fd73da233705cdf7f661499ce8ebcf/resource.tar.gz#test.test_blocks-decimal_avg--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-decimal_avg--Plan]\": [\n@@ -602,9 +602,9 @@\n     ],\n     \"test.test[blocks-json_document_type--Peephole]\": [\n         {\n-            \"checksum\": \"a7cd19fa1416b435369188128797921b\",\n-            \"size\": 2595,\n-            \"uri\": \"https://{canondata_backend}/1917492/e3ceae93b691869b63d950444badb29e6ace4842/resource.tar.gz#test.test_blocks-json_document_type--Peephole_/opt.yql\"\n+            \"checksum\": \"1536d7c0c5b539ba78f7d43b8ebb5833\",\n+            \"size\": 2599,\n+            \"uri\": \"https://{canondata_backend}/1946324/6bfca3fdf8ec9efde60e3282ae98ccf726043684/resource.tar.gz#test.test_blocks-json_document_type--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-json_document_type--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part5/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part5/canondata/result.json\nindex eaa893c802e5..64091a3b1975 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part5/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part5/canondata/result.json\n@@ -512,9 +512,9 @@\n     ],\n     \"test.test[blocks-combine_all_some--Peephole]\": [\n         {\n-            \"checksum\": \"988d82092e311c0cc2288f6c721aa11c\",\n-            \"size\": 6223,\n-            \"uri\": \"https://{canondata_backend}/1936273/d36ce8069af100fc1a5be882969a5505c35574b2/resource.tar.gz#test.test_blocks-combine_all_some--Peephole_/opt.yql\"\n+            \"checksum\": \"ec0346c566d620b4bc0d3de5b81e5a9a\",\n+            \"size\": 6225,\n+            \"uri\": \"https://{canondata_backend}/1937001/ef9f5ea919d8150ce90cc4b0dbee0c1cba26fb65/resource.tar.gz#test.test_blocks-combine_all_some--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_some--Plan]\": [\n@@ -540,9 +540,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_avg--Peephole]\": [\n         {\n-            \"checksum\": \"6cb4c5227d709714d5993d2ed2c77b6b\",\n-            \"size\": 4568,\n-            \"uri\": \"https://{canondata_backend}/1777230/4c11233cb21f28d476a7607d88951afa44d7ddc0/resource.tar.gz#test.test_blocks-combine_hashed_avg--Peephole_/opt.yql\"\n+            \"checksum\": \"17a606506695fd0869a72faebd42531d\",\n+            \"size\": 4614,\n+            \"uri\": \"https://{canondata_backend}/1917492/b000db17817f99c1d3a0274a3622303fc2214093/resource.tar.gz#test.test_blocks-combine_hashed_avg--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_avg--Plan]\": [\n@@ -568,9 +568,9 @@\n     ],\n     \"test.test[blocks-distinct_mixed_all--Peephole]\": [\n         {\n-            \"checksum\": \"3848f2a2650fe368e09a4991bdd3fc0d\",\n-            \"size\": 4241,\n-            \"uri\": \"https://{canondata_backend}/1936273/d36ce8069af100fc1a5be882969a5505c35574b2/resource.tar.gz#test.test_blocks-distinct_mixed_all--Peephole_/opt.yql\"\n+            \"checksum\": \"0cee70179fa613f92ac69175e9ca3b83\",\n+            \"size\": 4317,\n+            \"uri\": \"https://{canondata_backend}/1937001/ef9f5ea919d8150ce90cc4b0dbee0c1cba26fb65/resource.tar.gz#test.test_blocks-distinct_mixed_all--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-distinct_mixed_all--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part6/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part6/canondata/result.json\nindex 4744959f04c7..f11d9a45576a 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part6/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part6/canondata/result.json\n@@ -519,9 +519,9 @@\n     ],\n     \"test.test[blocks-combine_all_avg--Peephole]\": [\n         {\n-            \"checksum\": \"72c688d8ba2b59a621b7d928ad361432\",\n-            \"size\": 6542,\n-            \"uri\": \"https://{canondata_backend}/1689644/9c85c8a8fbfb9b467aefa0e6adc30066e9b66407/resource.tar.gz#test.test_blocks-combine_all_avg--Peephole_/opt.yql\"\n+            \"checksum\": \"74bd46cd3b4e6e0003fd1617382d91c2\",\n+            \"size\": 6562,\n+            \"uri\": \"https://{canondata_backend}/1916746/16b0b89d25b015809e26ecf42c6ebb271b7e329d/resource.tar.gz#test.test_blocks-combine_all_avg--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_avg--Plan]\": [\n@@ -547,9 +547,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_count_filter--Peephole]\": [\n         {\n-            \"checksum\": \"dbad3ef6538bee756fe6988b10c2d026\",\n-            \"size\": 2691,\n-            \"uri\": \"https://{canondata_backend}/1920236/9b3d7b78be8d9e7dc5f97424762bc80230b95228/resource.tar.gz#test.test_blocks-combine_hashed_count_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"72546bd6ba3596963df0163bdb47b7ef\",\n+            \"size\": 2718,\n+            \"uri\": \"https://{canondata_backend}/1689644/4afe37611f20ddb78db6921c77de0f60bc674896/resource.tar.gz#test.test_blocks-combine_hashed_count_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_count_filter--Plan]\": [\n@@ -631,9 +631,9 @@\n     ],\n     \"test.test[blocks-finalize_hashed_keys--Peephole]\": [\n         {\n-            \"checksum\": \"1d999c5294dc83f1a97d3da88c4bcd6d\",\n-            \"size\": 3967,\n-            \"uri\": \"https://{canondata_backend}/1920236/9b3d7b78be8d9e7dc5f97424762bc80230b95228/resource.tar.gz#test.test_blocks-finalize_hashed_keys--Peephole_/opt.yql\"\n+            \"checksum\": \"38969a82d581c3ce44fa5c016e693467\",\n+            \"size\": 3975,\n+            \"uri\": \"https://{canondata_backend}/1916746/16b0b89d25b015809e26ecf42c6ebb271b7e329d/resource.tar.gz#test.test_blocks-finalize_hashed_keys--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-finalize_hashed_keys--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part7/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part7/canondata/result.json\nindex c1d8795af5b7..d34292fe7456 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part7/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part7/canondata/result.json\n@@ -436,9 +436,9 @@\n     ],\n     \"test.test[blocks-combine_all_count_filter--Peephole]\": [\n         {\n-            \"checksum\": \"1bd1637694025d218083e5311e2e737e\",\n-            \"size\": 2200,\n-            \"uri\": \"https://{canondata_backend}/1903885/342ba96f93dd1681ca1277caeb9ad885799797d8/resource.tar.gz#test.test_blocks-combine_all_count_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"7e6527be84ea04af5daa4690e3affc77\",\n+            \"size\": 2243,\n+            \"uri\": \"https://{canondata_backend}/1936273/198988f944c8f3fd97179a6f8fffeac11f8d1537/resource.tar.gz#test.test_blocks-combine_all_count_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_count_filter--Plan]\": [\n@@ -464,9 +464,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_minmax_nested--Peephole]\": [\n         {\n-            \"checksum\": \"6a31c3120cf2eb25ca9660df0025dc6d\",\n-            \"size\": 4248,\n-            \"uri\": \"https://{canondata_backend}/1946324/776cdf4fe38b7e55a357e57769c922aaa9c78eb8/resource.tar.gz#test.test_blocks-combine_hashed_minmax_nested--Peephole_/opt.yql\"\n+            \"checksum\": \"c51e7072a46b6629eaca5986198f14b7\",\n+            \"size\": 4252,\n+            \"uri\": \"https://{canondata_backend}/1871182/1602ffd1989777b6937512e2491f3b6431e75351/resource.tar.gz#test.test_blocks-combine_hashed_minmax_nested--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_minmax_nested--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part8/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part8/canondata/result.json\nindex 347924d5c4e4..5da7ca0a9f3b 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part8/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part8/canondata/result.json\n@@ -697,9 +697,9 @@\n     ],\n     \"test.test[blocks-combine_all_avg_filter_opt--Peephole]\": [\n         {\n-            \"checksum\": \"457eaa347bc78b8ae704dcfab24cd2c5\",\n-            \"size\": 2450,\n-            \"uri\": \"https://{canondata_backend}/1689644/939d001ead810a20e7af16f81f7b19e996b5ab10/resource.tar.gz#test.test_blocks-combine_all_avg_filter_opt--Peephole_/opt.yql\"\n+            \"checksum\": \"a86349d68cb76289dcccb93060bf1534\",\n+            \"size\": 2493,\n+            \"uri\": \"https://{canondata_backend}/1936273/ef8b8680bb231b437c30900120a6917ae15cccaa/resource.tar.gz#test.test_blocks-combine_all_avg_filter_opt--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_avg_filter_opt--Plan]\": [\n@@ -725,9 +725,9 @@\n     ],\n     \"test.test[blocks-combine_all_max_filter--Peephole]\": [\n         {\n-            \"checksum\": \"1a245481237e4f62ec4b0a9478b46649\",\n-            \"size\": 2052,\n-            \"uri\": \"https://{canondata_backend}/1689644/939d001ead810a20e7af16f81f7b19e996b5ab10/resource.tar.gz#test.test_blocks-combine_all_max_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"38a1cf0163b1ee0e882d3e2b4510bf6b\",\n+            \"size\": 2095,\n+            \"uri\": \"https://{canondata_backend}/1936273/ef8b8680bb231b437c30900120a6917ae15cccaa/resource.tar.gz#test.test_blocks-combine_all_max_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_max_filter--Plan]\": [\n@@ -753,9 +753,9 @@\n     ],\n     \"test.test[blocks-combine_hashed_some--Peephole]\": [\n         {\n-            \"checksum\": \"6c767ae3fdac7034ca43b157bd8894a7\",\n-            \"size\": 3458,\n-            \"uri\": \"https://{canondata_backend}/1775319/5727f49e842aea7c325a2340890ed9e5d39107df/resource.tar.gz#test.test_blocks-combine_hashed_some--Peephole_/opt.yql\"\n+            \"checksum\": \"a6278c3a5e5565cca2826f911a303aab\",\n+            \"size\": 3506,\n+            \"uri\": \"https://{canondata_backend}/1871102/fcf3cadf4b55e03aeab83cc56f753fec4c829577/resource.tar.gz#test.test_blocks-combine_hashed_some--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_hashed_some--Plan]\": [\ndiff --git a/ydb/library/yql/tests/sql/yt_native_file/part9/canondata/result.json b/ydb/library/yql/tests/sql/yt_native_file/part9/canondata/result.json\nindex 35554fd92ac5..9f3a12c003df 100644\n--- a/ydb/library/yql/tests/sql/yt_native_file/part9/canondata/result.json\n+++ b/ydb/library/yql/tests/sql/yt_native_file/part9/canondata/result.json\n@@ -429,9 +429,9 @@\n     ],\n     \"test.test[blocks-combine_all_count--Peephole]\": [\n         {\n-            \"checksum\": \"d065efb0530ef025a6a377c7e583607d\",\n-            \"size\": 3141,\n-            \"uri\": \"https://{canondata_backend}/1936273/078595a3559c5c438ed530f67006a92558087996/resource.tar.gz#test.test_blocks-combine_all_count--Peephole_/opt.yql\"\n+            \"checksum\": \"a05d2b4951425b78494384e3966a40a7\",\n+            \"size\": 3205,\n+            \"uri\": \"https://{canondata_backend}/1775319/7897edc8408eb00cc6ed290a2f889d4524ac2280/resource.tar.gz#test.test_blocks-combine_all_count--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_count--Plan]\": [\n@@ -457,9 +457,9 @@\n     ],\n     \"test.test[blocks-combine_all_sum_filter--Peephole]\": [\n         {\n-            \"checksum\": \"a08ca9ef70405bb6a580d476ca3972f2\",\n-            \"size\": 2052,\n-            \"uri\": \"https://{canondata_backend}/1936273/078595a3559c5c438ed530f67006a92558087996/resource.tar.gz#test.test_blocks-combine_all_sum_filter--Peephole_/opt.yql\"\n+            \"checksum\": \"bd161548e7817d6c81c75cf0318f8e42\",\n+            \"size\": 2095,\n+            \"uri\": \"https://{canondata_backend}/1775319/7897edc8408eb00cc6ed290a2f889d4524ac2280/resource.tar.gz#test.test_blocks-combine_all_sum_filter--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-combine_all_sum_filter--Plan]\": [\n@@ -513,9 +513,9 @@\n     ],\n     \"test.test[blocks-distinct_pure_keys--Peephole]\": [\n         {\n-            \"checksum\": \"c59c6d34d5ee19a75a2f78eeeac2c5ff\",\n-            \"size\": 6736,\n-            \"uri\": \"https://{canondata_backend}/1936947/dd735d32257373e0e81a1a0c690b04eb821b17d3/resource.tar.gz#test.test_blocks-distinct_pure_keys--Peephole_/opt.yql\"\n+            \"checksum\": \"5a124ce37da8b898226286c987ad5df1\",\n+            \"size\": 6946,\n+            \"uri\": \"https://{canondata_backend}/1775319/7897edc8408eb00cc6ed290a2f889d4524ac2280/resource.tar.gz#test.test_blocks-distinct_pure_keys--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-distinct_pure_keys--Plan]\": [\n@@ -541,9 +541,9 @@\n     ],\n     \"test.test[blocks-group_by_complex_key--Peephole]\": [\n         {\n-            \"checksum\": \"51c549ee925a9e1b57fb53b9d8af78bf\",\n-            \"size\": 3993,\n-            \"uri\": \"https://{canondata_backend}/1937367/bf3daea8b53db195e51f49431b822900029c2a5d/resource.tar.gz#test.test_blocks-group_by_complex_key--Peephole_/opt.yql\"\n+            \"checksum\": \"ed8ba52767c23cc82a2e65723d2d632d\",\n+            \"size\": 3997,\n+            \"uri\": \"https://{canondata_backend}/1871102/d4092e58bfb3465cc6e1385e1e0fb9ddf349664c/resource.tar.gz#test.test_blocks-group_by_complex_key--Peephole_/opt.yql\"\n         }\n     ],\n     \"test.test[blocks-group_by_complex_key--Plan]\": [\n",
  "problem_statement": "\u041f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c BlockCombine \u0441 flow \u043d\u0430 stream\n\u0412\u043e\u0442 \u0442\u0443\u0442 \u043e\u043d\u043e \u0443\u0436\u0435 \u0431\u044b\u043b\u043e \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u043d\u043e \u0438 \u0434\u0430\u0436\u0435 \u0432\u043c\u0435\u0440\u0436\u0435\u043d\u043e: https://github.com/ydb-platform/ydb/pull/9979\r\n\r\n\u041e\u0434\u043d\u0430\u043a\u043e \u043d\u0430 \u0432\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0438\u0445 \u0442\u0435\u0441\u0442\u0430\u0445 yql (https://st.yandex-team.ru/YQL-19193) \u043e\u043d\u043e \u0443\u043f\u0430\u043b\u043e. \u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0431\u044b\u043b\u043e \u043e\u0442\u043a\u0430\u0447\u0435\u043d\u043e \u0432: https://github.com/ydb-platform/ydb/pull/10575\r\n\r\n\u041f\u0430\u0434\u0435\u043d\u0438\u0435 \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u0431\u043e\u043b\u0435\u0435 \u043f\u0440\u043e\u0441\u0442\u043e\u043c \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0438: \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0443\u0431\u0440\u0430\u0442\u044c \u0444\u0438\u043d\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e (`pragma dq.UseFinalizeByKey=\"false\"`).\n",
  "hints_text": "",
  "created_at": "2024-10-22T10:46:06Z"
}