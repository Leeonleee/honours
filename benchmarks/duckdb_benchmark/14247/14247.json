{
  "repo": "duckdb/duckdb",
  "pull_number": 14247,
  "instance_id": "duckdb__duckdb-14247",
  "issue_numbers": [
    "14216"
  ],
  "base_commit": "222c0eb90788c85a21ee322496d7a9ef001f9c37",
  "patch": "diff --git a/src/common/types/bit.cpp b/src/common/types/bit.cpp\nindex f263c2c42975..12293592519f 100644\n--- a/src/common/types/bit.cpp\n+++ b/src/common/types/bit.cpp\n@@ -22,7 +22,7 @@ idx_t Bit::ComputeBitstringLen(idx_t len) {\n \treturn result;\n }\n \n-static inline idx_t GetBitPadding(const string_t &bit_string) {\n+static inline idx_t GetBitPadding(const bitstring_t &bit_string) {\n \tauto data = const_data_ptr_cast(bit_string.GetData());\n \tD_ASSERT(idx_t(data[0]) <= 8);\n \treturn data[0];\n@@ -37,14 +37,14 @@ static inline idx_t GetBitSize(const string_t &str) {\n \treturn str_len;\n }\n \n-uint8_t Bit::GetFirstByte(const string_t &str) {\n+uint8_t Bit::GetFirstByte(const bitstring_t &str) {\n \tD_ASSERT(str.GetSize() > 1);\n \n \tauto data = const_data_ptr_cast(str.GetData());\n \treturn data[1] & ((1 << (8 - data[0])) - 1);\n }\n \n-void Bit::Finalize(string_t &str) {\n+void Bit::Finalize(bitstring_t &str) {\n \t// bit strings require all padding bits to be set to 1\n \t// this method sets all padding bits to 1\n \tauto padding = GetBitPadding(str);\n@@ -55,7 +55,7 @@ void Bit::Finalize(string_t &str) {\n \tBit::Verify(str);\n }\n \n-void Bit::SetEmptyBitString(string_t &target, string_t &input) {\n+void Bit::SetEmptyBitString(bitstring_t &target, string_t &input) {\n \tchar *res_buf = target.GetDataWriteable();\n \tconst char *buf = input.GetData();\n \tmemset(res_buf, 0, input.GetSize());\n@@ -63,7 +63,7 @@ void Bit::SetEmptyBitString(string_t &target, string_t &input) {\n \tBit::Finalize(target);\n }\n \n-void Bit::SetEmptyBitString(string_t &target, idx_t len) {\n+void Bit::SetEmptyBitString(bitstring_t &target, idx_t len) {\n \tchar *res_buf = target.GetDataWriteable();\n \tmemset(res_buf, 0, target.GetSize());\n \tres_buf[0] = ComputePadding(len);\n@@ -71,7 +71,7 @@ void Bit::SetEmptyBitString(string_t &target, idx_t len) {\n }\n \n // **** casting functions ****\n-void Bit::ToString(string_t bits, char *output) {\n+void Bit::ToString(bitstring_t bits, char *output) {\n \tauto data = const_data_ptr_cast(bits.GetData());\n \tauto len = bits.GetSize();\n \n@@ -87,7 +87,7 @@ void Bit::ToString(string_t bits, char *output) {\n \t}\n }\n \n-string Bit::ToString(string_t str) {\n+string Bit::ToString(bitstring_t str) {\n \tauto len = BitLength(str);\n \tauto buffer = make_unsafe_uniq_array_uninitialized<char>(len);\n \tToString(str, buffer.get());\n@@ -117,7 +117,7 @@ bool Bit::TryGetBitStringSize(string_t str, idx_t &str_len, string *error_messag\n \treturn true;\n }\n \n-void Bit::ToBit(string_t str, string_t &output_str) {\n+void Bit::ToBit(string_t str, bitstring_t &output_str) {\n \tauto data = const_data_ptr_cast(str.GetData());\n \tauto len = str.GetSize();\n \tauto output = output_str.GetDataWriteable();\n@@ -151,12 +151,12 @@ void Bit::ToBit(string_t str, string_t &output_str) {\n string Bit::ToBit(string_t str) {\n \tauto bit_len = GetBitSize(str);\n \tauto buffer = make_unsafe_uniq_array_uninitialized<char>(bit_len);\n-\tstring_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit_len));\n+\tbitstring_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit_len));\n \tBit::ToBit(str, output_str);\n \treturn output_str.GetString();\n }\n \n-void Bit::BlobToBit(string_t blob, string_t &output_str) {\n+void Bit::BlobToBit(string_t blob, bitstring_t &output_str) {\n \tauto data = const_data_ptr_cast(blob.GetData());\n \tauto output = output_str.GetDataWriteable();\n \tidx_t size = blob.GetSize();\n@@ -167,12 +167,12 @@ void Bit::BlobToBit(string_t blob, string_t &output_str) {\n \n string Bit::BlobToBit(string_t blob) {\n \tauto buffer = make_unsafe_uniq_array_uninitialized<char>(blob.GetSize() + 1);\n-\tstring_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(blob.GetSize() + 1));\n+\tbitstring_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(blob.GetSize() + 1));\n \tBit::BlobToBit(blob, output_str);\n \treturn output_str.GetString();\n }\n \n-void Bit::BitToBlob(string_t bit, string_t &output_blob) {\n+void Bit::BitToBlob(bitstring_t bit, string_t &output_blob) {\n \tD_ASSERT(bit.GetSize() == output_blob.GetSize() + 1);\n \n \tauto data = const_data_ptr_cast(bit.GetData());\n@@ -189,7 +189,7 @@ void Bit::BitToBlob(string_t bit, string_t &output_blob) {\n \t}\n }\n \n-string Bit::BitToBlob(string_t bit) {\n+string Bit::BitToBlob(bitstring_t bit) {\n \tD_ASSERT(bit.GetSize() > 1);\n \n \tauto buffer = make_unsafe_uniq_array_uninitialized<char>(bit.GetSize() - 1);\n@@ -199,7 +199,7 @@ string Bit::BitToBlob(string_t bit) {\n }\n \n // **** scalar functions ****\n-void Bit::BitString(const string_t &input, const idx_t &bit_length, string_t &result) {\n+void Bit::BitString(const string_t &input, idx_t bit_length, bitstring_t &result) {\n \tchar *res_buf = result.GetDataWriteable();\n \tconst char *buf = input.GetData();\n \n@@ -216,15 +216,35 @@ void Bit::BitString(const string_t &input, const idx_t &bit_length, string_t &re\n \tBit::Finalize(result);\n }\n \n-idx_t Bit::BitLength(string_t bits) {\n+void Bit::ExtendBitString(const bitstring_t &input, idx_t bit_length, bitstring_t &result) {\n+\tuint8_t *res_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());\n+\n+\tauto padding = ComputePadding(bit_length);\n+\tres_buf[0] = static_cast<uint8_t>(padding);\n+\n+\tidx_t original_length = Bit::BitLength(input);\n+\tD_ASSERT(bit_length >= original_length);\n+\tidx_t shift = bit_length - original_length;\n+\tfor (idx_t i = 0; i < bit_length; i++) {\n+\t\tif (i < shift) {\n+\t\t\tBit::SetBit(result, i, 0);\n+\t\t} else {\n+\t\t\tidx_t bit = Bit::GetBit(input, i - shift);\n+\t\t\tBit::SetBit(result, i, bit);\n+\t\t}\n+\t}\n+\tBit::Finalize(result);\n+}\n+\n+idx_t Bit::BitLength(bitstring_t bits) {\n \treturn ((bits.GetSize() - 1) * 8) - GetBitPadding(bits);\n }\n \n-idx_t Bit::OctetLength(string_t bits) {\n+idx_t Bit::OctetLength(bitstring_t bits) {\n \treturn bits.GetSize() - 1;\n }\n \n-idx_t Bit::BitCount(string_t bits) {\n+idx_t Bit::BitCount(bitstring_t bits) {\n \tidx_t count = 0;\n \tconst char *buf = bits.GetData();\n \tfor (idx_t byte_idx = 1; byte_idx < OctetLength(bits) + 1; byte_idx++) {\n@@ -235,7 +255,7 @@ idx_t Bit::BitCount(string_t bits) {\n \treturn count - GetBitPadding(bits);\n }\n \n-idx_t Bit::BitPosition(string_t substring, string_t bits) {\n+idx_t Bit::BitPosition(bitstring_t substring, bitstring_t bits) {\n \tconst char *buf = bits.GetData();\n \tauto len = bits.GetSize();\n \tauto substr_len = BitLength(substring);\n@@ -269,7 +289,7 @@ idx_t Bit::BitPosition(string_t substring, string_t bits) {\n \treturn 0;\n }\n \n-idx_t Bit::GetBit(string_t bit_string, idx_t n) {\n+idx_t Bit::GetBit(bitstring_t bit_string, idx_t n) {\n \treturn Bit::GetBitInternal(bit_string, n + GetBitPadding(bit_string));\n }\n \n@@ -277,7 +297,7 @@ idx_t Bit::GetBitIndex(idx_t n) {\n \treturn n / 8 + 1;\n }\n \n-idx_t Bit::GetBitInternal(string_t bit_string, idx_t n) {\n+idx_t Bit::GetBitInternal(bitstring_t bit_string, idx_t n) {\n \tconst char *buf = bit_string.GetData();\n \tauto idx = Bit::GetBitIndex(n);\n \tD_ASSERT(idx < bit_string.GetSize());\n@@ -285,12 +305,12 @@ idx_t Bit::GetBitInternal(string_t bit_string, idx_t n) {\n \treturn (byte & 1 ? 1 : 0);\n }\n \n-void Bit::SetBit(string_t &bit_string, idx_t n, idx_t new_value) {\n+void Bit::SetBit(bitstring_t &bit_string, idx_t n, idx_t new_value) {\n \tSetBitInternal(bit_string, n + GetBitPadding(bit_string), new_value);\n \tBit::Finalize(bit_string);\n }\n \n-void Bit::SetBitInternal(string_t &bit_string, idx_t n, idx_t new_value) {\n+void Bit::SetBitInternal(bitstring_t &bit_string, idx_t n, idx_t new_value) {\n \tuint8_t *buf = reinterpret_cast<uint8_t *>(bit_string.GetDataWriteable());\n \n \tauto idx = Bit::GetBitIndex(n);\n@@ -305,7 +325,7 @@ void Bit::SetBitInternal(string_t &bit_string, idx_t n, idx_t new_value) {\n }\n \n // **** BITWISE operators ****\n-void Bit::RightShift(const string_t &bit_string, const idx_t &shift, string_t &result) {\n+void Bit::RightShift(const bitstring_t &bit_string, idx_t shift, bitstring_t &result) {\n \tuint8_t *res_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());\n \tconst uint8_t *buf = reinterpret_cast<const uint8_t *>(bit_string.GetData());\n \n@@ -321,7 +341,7 @@ void Bit::RightShift(const string_t &bit_string, const idx_t &shift, string_t &r\n \tBit::Finalize(result);\n }\n \n-void Bit::LeftShift(const string_t &bit_string, const idx_t &shift, string_t &result) {\n+void Bit::LeftShift(const bitstring_t &bit_string, idx_t shift, bitstring_t &result) {\n \tuint8_t *res_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());\n \tconst uint8_t *buf = reinterpret_cast<const uint8_t *>(bit_string.GetData());\n \n@@ -337,7 +357,7 @@ void Bit::LeftShift(const string_t &bit_string, const idx_t &shift, string_t &re\n \tBit::Finalize(result);\n }\n \n-void Bit::BitwiseAnd(const string_t &rhs, const string_t &lhs, string_t &result) {\n+void Bit::BitwiseAnd(const bitstring_t &rhs, const bitstring_t &lhs, bitstring_t &result) {\n \tif (Bit::BitLength(lhs) != Bit::BitLength(rhs)) {\n \t\tthrow InvalidInputException(\"Cannot AND bit strings of different sizes\");\n \t}\n@@ -353,7 +373,7 @@ void Bit::BitwiseAnd(const string_t &rhs, const string_t &lhs, string_t &result)\n \tBit::Finalize(result);\n }\n \n-void Bit::BitwiseOr(const string_t &rhs, const string_t &lhs, string_t &result) {\n+void Bit::BitwiseOr(const bitstring_t &rhs, const bitstring_t &lhs, bitstring_t &result) {\n \tif (Bit::BitLength(lhs) != Bit::BitLength(rhs)) {\n \t\tthrow InvalidInputException(\"Cannot OR bit strings of different sizes\");\n \t}\n@@ -369,7 +389,7 @@ void Bit::BitwiseOr(const string_t &rhs, const string_t &lhs, string_t &result)\n \tBit::Finalize(result);\n }\n \n-void Bit::BitwiseXor(const string_t &rhs, const string_t &lhs, string_t &result) {\n+void Bit::BitwiseXor(const bitstring_t &rhs, const bitstring_t &lhs, bitstring_t &result) {\n \tif (Bit::BitLength(lhs) != Bit::BitLength(rhs)) {\n \t\tthrow InvalidInputException(\"Cannot XOR bit strings of different sizes\");\n \t}\n@@ -385,7 +405,7 @@ void Bit::BitwiseXor(const string_t &rhs, const string_t &lhs, string_t &result)\n \tBit::Finalize(result);\n }\n \n-void Bit::BitwiseNot(const string_t &input, string_t &result) {\n+void Bit::BitwiseNot(const bitstring_t &input, bitstring_t &result) {\n \tuint8_t *result_buf = reinterpret_cast<uint8_t *>(result.GetDataWriteable());\n \tconst uint8_t *buf = reinterpret_cast<const uint8_t *>(input.GetData());\n \n@@ -396,7 +416,7 @@ void Bit::BitwiseNot(const string_t &input, string_t &result) {\n \tBit::Finalize(result);\n }\n \n-void Bit::Verify(const string_t &input) {\n+void Bit::Verify(const bitstring_t &input) {\n #ifdef DEBUG\n \t// bit strings require all padding bits to be set to 1\n \tauto padding = GetBitPadding(input);\ndiff --git a/src/core_functions/function_list.cpp b/src/core_functions/function_list.cpp\nindex 16a5dff379ee..ca77e030964d 100644\n--- a/src/core_functions/function_list.cpp\n+++ b/src/core_functions/function_list.cpp\n@@ -116,7 +116,7 @@ static const StaticFunctionDefinition internal_functions[] = {\n \tDUCKDB_AGGREGATE_FUNCTION_SET(BitOrFun),\n \tDUCKDB_SCALAR_FUNCTION(BitPositionFun),\n \tDUCKDB_AGGREGATE_FUNCTION_SET(BitXorFun),\n-\tDUCKDB_SCALAR_FUNCTION(BitStringFun),\n+\tDUCKDB_SCALAR_FUNCTION_SET(BitStringFun),\n \tDUCKDB_AGGREGATE_FUNCTION_SET(BitstringAggFun),\n \tDUCKDB_AGGREGATE_FUNCTION(BoolAndFun),\n \tDUCKDB_AGGREGATE_FUNCTION(BoolOrFun),\ndiff --git a/src/core_functions/scalar/bit/bitstring.cpp b/src/core_functions/scalar/bit/bitstring.cpp\nindex fc1768850f07..9a9a5eae0f60 100644\n--- a/src/core_functions/scalar/bit/bitstring.cpp\n+++ b/src/core_functions/scalar/bit/bitstring.cpp\n@@ -7,28 +7,46 @@ namespace duckdb {\n //===--------------------------------------------------------------------===//\n // BitStringFunction\n //===--------------------------------------------------------------------===//\n+template <bool FROM_STRING>\n static void BitStringFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n \tBinaryExecutor::Execute<string_t, int32_t, string_t>(\n \t    args.data[0], args.data[1], result, args.size(), [&](string_t input, int32_t n) {\n \t\t    if (n < 0) {\n \t\t\t    throw InvalidInputException(\"The bitstring length cannot be negative\");\n \t\t    }\n-\t\t    if (idx_t(n) < input.GetSize()) {\n+\t\t    idx_t input_length;\n+\t\t    if (FROM_STRING) {\n+\t\t\t    input_length = input.GetSize();\n+\t\t    } else {\n+\t\t\t    input_length = Bit::BitLength(input);\n+\t\t    }\n+\t\t    if (idx_t(n) < input_length) {\n \t\t\t    throw InvalidInputException(\"Length must be equal or larger than input string\");\n \t\t    }\n \t\t    idx_t len;\n-\t\t    Bit::TryGetBitStringSize(input, len, nullptr); // string verification\n+\t\t    if (FROM_STRING) {\n+\t\t\t    Bit::TryGetBitStringSize(input, len, nullptr); // string verification\n+\t\t    }\n \n \t\t    len = Bit::ComputeBitstringLen(UnsafeNumericCast<idx_t>(n));\n \t\t    string_t target = StringVector::EmptyString(result, len);\n-\t\t    Bit::BitString(input, UnsafeNumericCast<idx_t>(n), target);\n+\t\t    if (FROM_STRING) {\n+\t\t\t    Bit::BitString(input, UnsafeNumericCast<idx_t>(n), target);\n+\t\t    } else {\n+\t\t\t    Bit::ExtendBitString(input, UnsafeNumericCast<idx_t>(n), target);\n+\t\t    }\n \t\t    target.Finalize();\n \t\t    return target;\n \t    });\n }\n \n-ScalarFunction BitStringFun::GetFunction() {\n-\treturn ScalarFunction({LogicalType::VARCHAR, LogicalType::INTEGER}, LogicalType::BIT, BitStringFunction);\n+ScalarFunctionSet BitStringFun::GetFunctions() {\n+\tScalarFunctionSet bitstring;\n+\tbitstring.AddFunction(\n+\t    ScalarFunction({LogicalType::VARCHAR, LogicalType::INTEGER}, LogicalType::BIT, BitStringFunction<true>));\n+\tbitstring.AddFunction(\n+\t    ScalarFunction({LogicalType::BIT, LogicalType::INTEGER}, LogicalType::BIT, BitStringFunction<false>));\n+\treturn bitstring;\n }\n \n //===--------------------------------------------------------------------===//\ndiff --git a/src/core_functions/scalar/bit/functions.json b/src/core_functions/scalar/bit/functions.json\nindex 0870e6831426..ac46a530a841 100644\n--- a/src/core_functions/scalar/bit/functions.json\n+++ b/src/core_functions/scalar/bit/functions.json\n@@ -26,6 +26,6 @@\n         \"description\": \"Pads the bitstring until the specified length\",\n         \"example\": \"bitstring('1010'::BIT, 7)\",\n         \"struct\": \"BitStringFun\",\n-        \"type\": \"scalar_function\"\n+        \"type\": \"scalar_function_set\"\n     }\n ]\n\\ No newline at end of file\ndiff --git a/src/include/duckdb/common/types/bit.hpp b/src/include/duckdb/common/types/bit.hpp\nindex 5a1a8209dde1..cbf599139ec5 100644\n--- a/src/include/duckdb/common/types/bit.hpp\n+++ b/src/include/duckdb/common/types/bit.hpp\n@@ -17,85 +17,88 @@\n \n namespace duckdb {\n \n+using bitstring_t = duckdb::string_t;\n+\n //! The Bit class is a static class that holds helper functions for the BIT type.\n class Bit {\n public:\n \t//! Returns the number of bits in the bit string\n-\tDUCKDB_API static idx_t BitLength(string_t bits);\n+\tDUCKDB_API static idx_t BitLength(bitstring_t bits);\n \t//! Returns the number of set bits in the bit string\n-\tDUCKDB_API static idx_t BitCount(string_t bits);\n+\tDUCKDB_API static idx_t BitCount(bitstring_t bits);\n \t//! Returns the number of bytes in the bit string\n-\tDUCKDB_API static idx_t OctetLength(string_t bits);\n+\tDUCKDB_API static idx_t OctetLength(bitstring_t bits);\n \t//! Extracts the nth bit from bit string; the first (leftmost) bit is indexed 0\n-\tDUCKDB_API static idx_t GetBit(string_t bit_string, idx_t n);\n+\tDUCKDB_API static idx_t GetBit(bitstring_t bit_string, idx_t n);\n \t//! Sets the nth bit in bit string to newvalue; the first (leftmost) bit is indexed 0\n-\tDUCKDB_API static void SetBit(string_t &bit_string, idx_t n, idx_t new_value);\n+\tDUCKDB_API static void SetBit(bitstring_t &bit_string, idx_t n, idx_t new_value);\n \t//! Returns first starting index of the specified substring within bits, or zero if it's not present.\n-\tDUCKDB_API static idx_t BitPosition(string_t substring, string_t bits);\n+\tDUCKDB_API static idx_t BitPosition(bitstring_t substring, bitstring_t bits);\n \t//! Converts bits to a string, writing the output to the designated output string.\n \t//! The string needs to have space for at least GetStringSize(bits) bytes.\n-\tDUCKDB_API static void ToString(string_t bits, char *output);\n-\tDUCKDB_API static string ToString(string_t str);\n+\tDUCKDB_API static void ToString(bitstring_t bits, char *output);\n+\tDUCKDB_API static string ToString(bitstring_t bits);\n \t//! Returns the bit size of a string -> bit conversion\n \tDUCKDB_API static bool TryGetBitStringSize(string_t str, idx_t &result_size, string *error_message);\n \t//! Convert a string to a bit. This function should ONLY be called after calling GetBitSize, since it does NOT\n \t//! perform data validation.\n-\tDUCKDB_API static void ToBit(string_t str, string_t &output);\n+\tDUCKDB_API static void ToBit(string_t str, bitstring_t &output);\n \n \tDUCKDB_API static string ToBit(string_t str);\n \n \t//! output needs to have enough space allocated before calling this function (blob size + 1)\n-\tDUCKDB_API static void BlobToBit(string_t blob, string_t &output);\n+\tDUCKDB_API static void BlobToBit(string_t blob, bitstring_t &output);\n \n \tDUCKDB_API static string BlobToBit(string_t blob);\n \n \t//! output_str needs to have enough space allocated before calling this function (sizeof(T) + 1)\n \ttemplate <class T>\n-\tstatic void NumericToBit(T numeric, string_t &output_str);\n+\tstatic void NumericToBit(T numeric, bitstring_t &output_str);\n \n \ttemplate <class T>\n \tstatic string NumericToBit(T numeric);\n \n \t//! bit is expected to fit inside of output num (bit size <= sizeof(T) + 1)\n \ttemplate <class T>\n-\tstatic void BitToNumeric(string_t bit, T &output_num);\n+\tstatic void BitToNumeric(bitstring_t bit, T &output_num);\n \n \ttemplate <class T>\n-\tstatic T BitToNumeric(string_t bit);\n+\tstatic T BitToNumeric(bitstring_t bit);\n \n \t//! bit is expected to fit inside of output_blob (bit size = output_blob + 1)\n-\tstatic void BitToBlob(string_t bit, string_t &output_blob);\n+\tstatic void BitToBlob(bitstring_t bit, string_t &output_blob);\n \n-\tstatic string BitToBlob(string_t bit);\n+\tstatic string BitToBlob(bitstring_t bit);\n \n \t//! Creates a new bitstring of determined length\n-\tDUCKDB_API static void BitString(const string_t &input, const idx_t &len, string_t &result);\n-\tDUCKDB_API static void SetEmptyBitString(string_t &target, string_t &input);\n-\tDUCKDB_API static void SetEmptyBitString(string_t &target, idx_t len);\n+\tDUCKDB_API static void BitString(const string_t &input, idx_t len, bitstring_t &result);\n+\tDUCKDB_API static void ExtendBitString(const bitstring_t &input, idx_t bit_length, bitstring_t &result);\n+\tDUCKDB_API static void SetEmptyBitString(bitstring_t &target, string_t &input);\n+\tDUCKDB_API static void SetEmptyBitString(bitstring_t &target, idx_t len);\n \tDUCKDB_API static idx_t ComputeBitstringLen(idx_t len);\n \n-\tDUCKDB_API static void RightShift(const string_t &bit_string, const idx_t &shif, string_t &result);\n-\tDUCKDB_API static void LeftShift(const string_t &bit_string, const idx_t &shift, string_t &result);\n-\tDUCKDB_API static void BitwiseAnd(const string_t &rhs, const string_t &lhs, string_t &result);\n-\tDUCKDB_API static void BitwiseOr(const string_t &rhs, const string_t &lhs, string_t &result);\n-\tDUCKDB_API static void BitwiseXor(const string_t &rhs, const string_t &lhs, string_t &result);\n-\tDUCKDB_API static void BitwiseNot(const string_t &rhs, string_t &result);\n+\tDUCKDB_API static void RightShift(const bitstring_t &bit_string, idx_t shift, bitstring_t &result);\n+\tDUCKDB_API static void LeftShift(const bitstring_t &bit_string, idx_t shift, bitstring_t &result);\n+\tDUCKDB_API static void BitwiseAnd(const bitstring_t &rhs, const bitstring_t &lhs, bitstring_t &result);\n+\tDUCKDB_API static void BitwiseOr(const bitstring_t &rhs, const bitstring_t &lhs, bitstring_t &result);\n+\tDUCKDB_API static void BitwiseXor(const bitstring_t &rhs, const bitstring_t &lhs, bitstring_t &result);\n+\tDUCKDB_API static void BitwiseNot(const bitstring_t &rhs, bitstring_t &result);\n \n-\tDUCKDB_API static void Verify(const string_t &input);\n+\tDUCKDB_API static void Verify(const bitstring_t &input);\n \n private:\n-\tstatic void Finalize(string_t &str);\n-\tstatic idx_t GetBitInternal(string_t bit_string, idx_t n);\n-\tstatic void SetBitInternal(string_t &bit_string, idx_t n, idx_t new_value);\n+\tstatic void Finalize(bitstring_t &str);\n+\tstatic idx_t GetBitInternal(bitstring_t bit_string, idx_t n);\n+\tstatic void SetBitInternal(bitstring_t &bit_string, idx_t n, idx_t new_value);\n \tstatic idx_t GetBitIndex(idx_t n);\n-\tstatic uint8_t GetFirstByte(const string_t &str);\n+\tstatic uint8_t GetFirstByte(const bitstring_t &str);\n };\n \n //===--------------------------------------------------------------------===//\n // Bit Template definitions\n //===--------------------------------------------------------------------===//\n template <class T>\n-void Bit::NumericToBit(T numeric, string_t &output_str) {\n+void Bit::NumericToBit(T numeric, bitstring_t &output_str) {\n \tD_ASSERT(output_str.GetSize() >= sizeof(T) + 1);\n \n \tauto output = output_str.GetDataWriteable();\n@@ -113,20 +116,20 @@ template <class T>\n string Bit::NumericToBit(T numeric) {\n \tauto bit_len = sizeof(T) + 1;\n \tauto buffer = make_unsafe_uniq_array_uninitialized<char>(bit_len);\n-\tstring_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit_len));\n+\tbitstring_t output_str(buffer.get(), UnsafeNumericCast<uint32_t>(bit_len));\n \tBit::NumericToBit(numeric, output_str);\n \treturn output_str.GetString();\n }\n \n template <class T>\n-T Bit::BitToNumeric(string_t bit) {\n+T Bit::BitToNumeric(bitstring_t bit) {\n \tT output;\n \tBit::BitToNumeric(bit, output);\n \treturn (output);\n }\n \n template <class T>\n-void Bit::BitToNumeric(string_t bit, T &output_num) {\n+void Bit::BitToNumeric(bitstring_t bit, T &output_num) {\n \tD_ASSERT(bit.GetSize() <= sizeof(T) + 1);\n \n \toutput_num = 0;\ndiff --git a/src/include/duckdb/core_functions/scalar/bit_functions.hpp b/src/include/duckdb/core_functions/scalar/bit_functions.hpp\nindex c114d72a68ad..f66427b6d7b5 100644\n--- a/src/include/duckdb/core_functions/scalar/bit_functions.hpp\n+++ b/src/include/duckdb/core_functions/scalar/bit_functions.hpp\n@@ -48,7 +48,7 @@ struct BitStringFun {\n \tstatic constexpr const char *Description = \"Pads the bitstring until the specified length\";\n \tstatic constexpr const char *Example = \"bitstring('1010'::BIT, 7)\";\n \n-\tstatic ScalarFunction GetFunction();\n+\tstatic ScalarFunctionSet GetFunctions();\n };\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/types/bit/test_bit.test b/test/sql/types/bit/test_bit.test\nindex 5f561d648f8d..a7a0c0a5d521 100644\n--- a/test/sql/types/bit/test_bit.test\n+++ b/test/sql/types/bit/test_bit.test\n@@ -20,31 +20,47 @@ statement ok\n CREATE TABLE bits (b bit);\n \n # test creating a bitstring of determined size\n+\n+foreach cast VARCHAR BIT\n+\n query I\n-SELECT bitstring('0101011', 15);\n+SELECT bitstring('0101011'::${cast}, 15);\n ----\n 000000000101011\n \n query I\n-SELECT bitstring('1', 6);\n+SELECT bitstring('1'::${cast}, 6);\n ----\n 000001\n \n+query I\n+SELECT bitstring('1'::${cast}, 1);\n+----\n+1\n+\n+query I\n+SELECT bitstring('0101011'::${cast}, 203);\n+----\n+00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101011\n+\n+query I\n+SELECT bitstring('111100001111000010101010'::${cast}, 36);\n+----\n+000000000000111100001111000010101010\n+\n statement error\n-SELECT bitstring('0101011', 3);\n+SELECT bitstring('0101011'::${cast}, 3);\n ----\n <REGEX>:Invalid Input Error.*Length must be equal or larger than input string.*\n \n+# cast\n+endloop\n+\n statement error\n SELECT bitstring('', 0);\n ----\n <REGEX>:Conversion Error.*Cannot cast empty string to BIT.*\n \n-query I\n-SELECT bitstring('1', 1);\n-----\n-1\n-\n statement error\n SELECT bitstring('5', 10);\n ----\n@@ -55,11 +71,6 @@ SELECT bitstring('0101011');\n ----\n <REGEX>:Binder Error.*No function matches.*\n \n-query I\n-SELECT bitstring('0101011', 203);\n-----\n-00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101011\n-\n # insert valid bit strings\n statement ok\n INSERT INTO bits VALUES('101011010'), ('111'), ('1010010101111111001101')\n",
  "problem_statement": "No function matches 'bitstring(BIT, INTEGER_LITERAL)'\n### What happens?\n\nThe [bitstring function](https://duckdb.org/docs/sql/functions/bitstring.html#bitstringbitstring-length) doesn't work. The given example results in this error:\r\n\r\n```\r\nBinder Error: No function matches the given name and argument types 'bitstring(BIT, INTEGER_LITERAL)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tbitstring(VARCHAR, INTEGER) -> BIT\r\n\r\nLINE 1: SELECT bitstring('1010'::BITSTRING, 7);\r\n```\n\n### To Reproduce\n\n```sql\r\nSELECT bitstring('1010'::BITSTRING, 7);\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nLiam Diprose\n\n### Affiliation:\n\nLiam Diprose\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have not tested with any build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Hi, indeed. As a temporary workaround, the following works:\r\n```sql\r\nSELECT bitstring('1010', 7);\r\n```\r\n",
  "created_at": "2024-10-07T08:16:06Z",
  "modified_files": [
    "src/common/types/bit.cpp",
    "src/core_functions/function_list.cpp",
    "src/core_functions/scalar/bit/bitstring.cpp",
    "src/core_functions/scalar/bit/functions.json",
    "src/include/duckdb/common/types/bit.hpp",
    "src/include/duckdb/core_functions/scalar/bit_functions.hpp"
  ],
  "modified_test_files": [
    "test/sql/types/bit/test_bit.test"
  ]
}