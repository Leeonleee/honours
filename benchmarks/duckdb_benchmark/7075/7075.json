{
  "repo": "duckdb/duckdb",
  "pull_number": 7075,
  "instance_id": "duckdb__duckdb-7075",
  "issue_numbers": [
    "7068"
  ],
  "base_commit": "236e58037781cbe1adfd8cf962688fc37af173b5",
  "patch": "diff --git a/src/optimizer/rule/regex_optimizations.cpp b/src/optimizer/rule/regex_optimizations.cpp\nindex a9a8e1e1d09b..13994053788a 100644\n--- a/src/optimizer/rule/regex_optimizations.cpp\n+++ b/src/optimizer/rule/regex_optimizations.cpp\n@@ -44,17 +44,18 @@ unique_ptr<Expression> RegexOptimizationRule::Apply(LogicalOperator &op, vector<\n \n \tif (pattern.Regexp()->op() == duckdb_re2::kRegexpLiteralString ||\n \t    pattern.Regexp()->op() == duckdb_re2::kRegexpLiteral) {\n-\t\tauto contains = make_uniq<BoundFunctionExpression>(root.return_type, ContainsFun::GetFunction(),\n-\t\t                                                   std::move(root.children), nullptr);\n \n \t\tstring min;\n \t\tstring max;\n-\t\tpattern.PossibleMatchRange(&min, &max, patt_str.size());\n-\t\tif (min == max) {\n-\t\t\tcontains->children[1] = make_uniq<BoundConstantExpression>(Value(std::move(min)));\n-\t\t} else {\n-\t\t\tcontains->children[1] = make_uniq<BoundConstantExpression>(Value(std::move(patt_str)));\n+\t\tpattern.PossibleMatchRange(&min, &max, patt_str.size() + 1);\n+\t\tif (min != max) {\n+\t\t\treturn nullptr;\n \t\t}\n+\t\tauto parameter = make_uniq<BoundConstantExpression>(Value(std::move(min)));\n+\t\tauto contains = make_uniq<BoundFunctionExpression>(root.return_type, ContainsFun::GetFunction(),\n+\t\t                                                   std::move(root.children), nullptr);\n+\t\tcontains->children[1] = std::move(parameter);\n+\n \t\treturn std::move(contains);\n \t}\n \treturn nullptr;\n",
  "test_patch": "diff --git a/test/optimizer/regex_optimizer_coverage.test b/test/optimizer/regex_optimizer_coverage.test\nindex 7aae7a7fd80e..1022a114bbd5 100644\n--- a/test/optimizer/regex_optimizer_coverage.test\n+++ b/test/optimizer/regex_optimizer_coverage.test\n@@ -46,3 +46,18 @@ select regexp_matches(word, '[AAAA]') from test;\n query I nosort correct_result\n select regexp_matches(word, '[A-A]') from test;\n ----\n+\n+# case-insensitive\n+query I nosort correct_result\n+select regexp_matches(word, '(?i)[A-A]') from test;\n+----\n+\n+# single-line mode\n+query I nosort correct_result\n+select regexp_matches(word, '(?s)[A-A]') from test;\n+----\n+\n+# multi-line mode\n+query I nosort correct_result\n+select regexp_matches(word, '(?m)[A-A]') from test;\n+----\n",
  "problem_statement": "Inconsistent Regexp Behavior with Inline (?i) Modifier\n### What happens?\n\nUsing an inline modifier for case insensitive matches (?i), and a varchar value from a table containing a single value 'abc', the following expression returns false: `select regexp_matches(col1, '(?i)ABC')`\r\n\r\nYet, it returns True with a literal 'abc':  `select regexp_matches('abc', '(?i)ABC')`\r\n\r\nAlso returns True with other similar/equivalent formulations, like: `select regexp_matches(col1, '(?i)AB[C]')`\n\n### To Reproduce\n\nThe first two regexp_matches expressions evaluate to False, yet the equivalent expressions written with literals evaluates to True. \r\n\r\n`regexp_matches(col1, '(?i)ABC'),` should evaluate to True, since \"col1\" contains a single value: abc\r\nThe equivalent version with literal 'abc' evaluates to True: `regexp_matches('abc', '(?i)ABC')`\r\n\r\n```\r\nCREATE OR REPLACE TABLE datatest as SELECT 'abc' as col1; \r\n\r\nSELECT \r\n    col1, \r\n    regexp_matches(col1, '(?i)ABC'), -- False??\r\n    regexp_matches(col1, '(?i)AB[C]'), -- False??\r\n    regexp_matches(col1, '(?i)abc') as t1_lower, -- False??\r\n\r\n    -- Below this line everything evaluates to True, yet are more or less equivalent \r\n    -- to the first version\r\n    regexp_matches(col1, 'ABC', 'i'), -- This should be same as #1\r\n    regexp_matches(col1, '(?i)ABC$'), -- $ = end of input\r\n    regexp_matches(col1, '(?i)AB[C]+'), \r\n    regexp_matches(col1, '(?i)AB[C]?'), \r\n\r\n    -- Using literal 'abc' works as expected\r\n    regexp_matches('abc', '(?i)ABC'), \r\n    regexp_matches('abc', '(?i)AB[C]'), \r\n    regexp_matches('abc', '(?i)ABC$'), \r\n    regexp_matches('abc', '(?i)AB[C]+'), \r\n    regexp_matches('abc', '(?i)AB[C]?') \r\nFROM \r\n    datatest\r\n```\r\n\n\n### OS:\n\nWindows\n\n### DuckDB Version:\n\n0.7.2-dev1734\t\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nP Timmins\n\n### Affiliation:\n\nIqmo\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "Hmm first thing that comes to mind is the optimizer might be at fault?\r\nCan you try it again after running `pragma disable_optimizer;` ?\nYes, that fixes it. \nThen that's definitely a bug \ud83d\udc4d \r\nLikely related to not properly fixing #6634 ",
  "created_at": "2023-04-13T13:49:52Z",
  "modified_files": [
    "src/optimizer/rule/regex_optimizations.cpp"
  ],
  "modified_test_files": [
    "test/optimizer/regex_optimizer_coverage.test"
  ]
}