{
  "repo": "duckdb/duckdb",
  "pull_number": 15614,
  "instance_id": "duckdb__duckdb-15614",
  "issue_numbers": [
    "15062",
    "14619"
  ],
  "base_commit": "ce33de966a521d1a6e86ec9579e133ff2b2534f4",
  "patch": "diff --git a/extension/core_functions/scalar/list/list_reduce.cpp b/extension/core_functions/scalar/list/list_reduce.cpp\nindex f8758515f8bd..173b52699bbe 100644\n--- a/extension/core_functions/scalar/list/list_reduce.cpp\n+++ b/extension/core_functions/scalar/list/list_reduce.cpp\n@@ -101,7 +101,7 @@ static bool ExecuteReduce(idx_t loops, ReduceExecuteInfo &execute_info, LambdaFu\n \t}\n \n \t// create the index vector\n-\tVector index_vector(Value::BIGINT(UnsafeNumericCast<int64_t>(loops + 1)));\n+\tVector index_vector(Value::BIGINT(UnsafeNumericCast<int64_t>(loops + 2)));\n \n \t// slice the left and right slice\n \texecute_info.left_slice->Slice(*execute_info.left_slice, execute_info.left_sel, reduced_row_idx);\n",
  "test_patch": "diff --git a/test/sql/function/list/lambdas/reduce.test b/test/sql/function/list/lambdas/reduce.test\nindex 943da335c6e0..3b107ee61999 100644\n--- a/test/sql/function/list/lambdas/reduce.test\n+++ b/test/sql/function/list/lambdas/reduce.test\n@@ -18,7 +18,7 @@ SELECT list_reduce([1, 2, 3], (x, y) -> x * y);\n query I\n SELECT list_reduce([100, 10, 1], (x, y, i) -> x - y - i);\n ----\n-86\n+84\n \n query I\n SELECT list_reduce([1, 2, 3], (x, y) -> y - x);\n@@ -33,7 +33,7 @@ SELECT list_reduce([1, 2, 3], (x, y) -> x - y);\n query I\n SELECT list_reduce([1, 2, 3], (x, y, i) -> x + y + i);\n ----\n-9\n+11\n \n query I\n SELECT list_reduce([NULL], (x, y, i) -> x + y + i);\n@@ -109,10 +109,10 @@ NULL\n query I\n SELECT list_reduce(a, (x, y, i) -> x + y + i) FROM t1;\n ----\n-9\n+11\n 666\n NULL\n-100\n+101\n NULL\n \n statement ok\n@@ -181,7 +181,7 @@ Cannot perform list_reduce on an empty input list\n query I\n SELECT list_reduce([1, 2, 3], (x, y, x_i) -> list_reduce([4, 5, 6], (a, b, a_i) -> x + y + a + b + x_i + a_i));\n ----\n-80\n+92\n \n statement error\n SELECT list_reduce([1, 2, 3], (x, y, x_i) -> list_reduce([], (a, b, a_i) -> x + y + a + b + x_i + a_i));\n@@ -234,7 +234,7 @@ NULL\n query I\n SELECT list_reduce(n, (x, y, x_i) -> list_reduce(l, (a, b, a_i) -> x + y + a + b + x_i + a_i)) FROM nested;\n ----\n-80\n+92\n NULL\n NULL\n NULL\n@@ -312,7 +312,7 @@ SELECT list_reduce([1, 2, 3], (x, y) -> list_reduce([4, 5, 6], (a, b) -> list_re\n query I\n SELECT list_reduce([1, 2, 3], (x, y, x_i) -> list_reduce([4, 5, 6], (a, b, a_i) -> list_reduce([7, 8, 9], (c, d, c_i) -> x + y + a + b + c + d + x_i + a_i + c_i)));\n ----\n-1133\n+1259\n \n query I\n SELECT list_reduce([[[10, 20], [100, 200]], [[30, 40], [300, 400]], [[50, 60], [500, 600]]], (x, y) -> list_pack(list_reduce(x, (l, m) -> list_pack(list_reduce(l, (a, b) -> a + b) + list_reduce(m, (c, d) -> c + d))) + list_reduce(y, (n, o) -> list_pack(list_reduce(n, (a, b) -> a + b) + list_reduce(o, (c, d) -> c + d)))));\n",
  "problem_statement": "Zero-based index in `list_reduce`\n### What happens?\n\n```sql\r\nSELECT list_reduce(['a', 'b'], (x, y, i) -> x || y || i)\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 list_reduce(main.list_value('a', 'b'), (main.\"row\"(x, y, i) -> ((x || y) || i))) \u2502\r\n\u2502                                     varchar                                      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 ab1                                                                              \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nbut according to https://duckdb.org/docs/sql/functions/lambda.html \r\n\r\n> All lambda functions accept an optional extra parameter that represents the index of the current element. This is always the last parameter of the lambda function, and is 1-based (i.e., the first element has index 1).\r\n\r\nwhich strongly suggests that `y = 'b'` should be accompanied with `i = 2`, since `2` is the correct index of `b` in the list `['a', 'b']`.\n\n### To Reproduce\n\n.\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.1.0\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\ni5, AMD64\n\n### Full Name:\n\nSoeren Wolfers\n\n### Affiliation:\n\nG-Research\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\nInconsistent Index Origin in list_transform() and list_reduce() \n### What happens?\n\nIn a nutshell, list_transform() uses 1 as its index-origin (IO=1)\r\nwhereas list_reduce() uses 0 instead:\r\n```\r\nD select list_transform([10,20,30], (x,ix) -> ix) as ix;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    ix     \u2502\r\n\u2502  int64[]  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1, 2, 3] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nD select list_reduce([10,20,30], (acc,x,ix) -> ix) as ix;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  ix   \u2502\r\n\u2502 int32 \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502     2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n\n### To Reproduce\n\n```\r\nselect list_transform([10,20,30], (x,ix) -> ix) as ix;\r\nselect list_reduce([10,20,30], (acc,x,ix) -> ix) as ix;\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nv1.1.3-dev75 c73cfca650 et al\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nPeter Koppstein\n\n### Affiliation:\n\nPrinceton University\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Seems consistent behaviour?\r\n\r\nIn the first iteration of list_reduce the values 'a' and 'b' are taken (hence i = 1).\r\nThe result is this query: SELECT list_reduce(['a', 'b','c'], (x, y, i) -> x || y || i);\r\n\r\nab1c2.\r\n\r\nSo in fact \"i\" is not the index in the list but the iterator count of list reduce.\nThe docs say \"extra parameter that represents the index of the current element\", not \"extra parameter that represents the iterator count\".\r\n\r\n`list_reduce` should eventually take an initial state argument. Once that's available, I think it'd be incompatible with any phrasing/interpretation of \"extra parameter ... index in the list\" if without that initial state `(a, b, 1)` were the first inputs to the lambda function while with the initial state`(init, a, 1)` are the first inputs. \r\n\r\nThen again, documentation can be changed and I'm happy to do that if I get confirmation that the current behavior is preferred. \nI agree with the initial state argument and then index is indeed the current element.\nDuplicate of https://github.com/duckdb/duckdb/issues/14619\nNice find, thanks! This should be consistent indeed.\nI think `list_reduce` is still 1-based. The below is converting loops (0-based) to 1-based.\r\n\r\nhttps://github.com/duckdb/duckdb/blob/2d1b7d796d0e49e7a73ede14fd7d3033c1782626/extension/core_functions/scalar/list/list_reduce.cpp#L104\r\n\r\nHowever, `list_reduce([10,20,30], (acc,x,ix) -> ix) as ix;` is calling the function only twice. The first is `(acc=10, x=20, ix=1)` and the second is `(acc=1, x=30, ix=2)`. That's why the result is 2.\n@kzys The docs say \"extra parameter that represents the index of the current element\", not \"extra parameter that represents the loop iterator count\". \r\n\r\nThat unambiguously requires that the arguments should be `(acc=10, x=20, ix=2)` and `(acc=30, x=30, ix=3)`.\r\n\r\nYou might say that the docs should therefore be changed; however, that wouldn't be future-proof: `list_reduce` will almost surely eventually take an initial state argument. Once that's available, I believe everybody agrees that the arguments have to be `(acc=init, x=10, ix=1), ..., (acc=init+30, x=30, ix=3)` so the only way to square that with the status quo would be to make _different_ `(x, ix)` pairs depending on whether an initial state is passed in, which would be awful.",
  "created_at": "2025-01-08T13:08:52Z",
  "modified_files": [
    "extension/core_functions/scalar/list/list_reduce.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/list/lambdas/reduce.test"
  ]
}