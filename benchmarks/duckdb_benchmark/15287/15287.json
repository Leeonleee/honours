{
  "repo": "duckdb/duckdb",
  "pull_number": 15287,
  "instance_id": "duckdb__duckdb-15287",
  "issue_numbers": [
    "15183",
    "15183"
  ],
  "base_commit": "4a8188effcf664085eedf723996a90dc870a7d7e",
  "patch": "diff --git a/extension/core_functions/scalar/generic/least.cpp b/extension/core_functions/scalar/generic/least.cpp\nindex 8dcb64344f5e..e9df9872829c 100644\n--- a/extension/core_functions/scalar/generic/least.cpp\n+++ b/extension/core_functions/scalar/generic/least.cpp\n@@ -5,6 +5,22 @@\n \n namespace duckdb {\n \n+struct LeastOp {\n+\tusing OP = LessThan;\n+\n+\tstatic OrderByNullType NullOrdering() {\n+\t\treturn OrderByNullType::NULLS_LAST;\n+\t}\n+};\n+\n+struct GreaterOp {\n+\tusing OP = GreaterThan;\n+\n+\tstatic OrderByNullType NullOrdering() {\n+\t\treturn OrderByNullType::NULLS_FIRST;\n+\t}\n+};\n+\n template <class OP>\n struct LeastOperator {\n \ttemplate <class T>\n@@ -14,8 +30,8 @@ struct LeastOperator {\n };\n \n struct LeastGreatestSortKeyState : public FunctionLocalState {\n-\texplicit LeastGreatestSortKeyState(idx_t column_count)\n-\t    : intermediate(LogicalType::BLOB), modifiers(OrderType::ASCENDING, OrderByNullType::NULLS_LAST) {\n+\texplicit LeastGreatestSortKeyState(idx_t column_count, OrderByNullType null_ordering)\n+\t    : intermediate(LogicalType::BLOB), modifiers(OrderType::ASCENDING, null_ordering) {\n \t\tvector<LogicalType> types;\n \t\t// initialize sort key chunk\n \t\tfor (idx_t i = 0; i < column_count; i++) {\n@@ -29,9 +45,10 @@ struct LeastGreatestSortKeyState : public FunctionLocalState {\n \tOrderModifiers modifiers;\n };\n \n+template <class OP>\n unique_ptr<FunctionLocalState> LeastGreatestSortKeyInit(ExpressionState &state, const BoundFunctionExpression &expr,\n                                                         FunctionData *bind_data) {\n-\treturn make_uniq<LeastGreatestSortKeyState>(expr.children.size());\n+\treturn make_uniq<LeastGreatestSortKeyState>(expr.children.size(), OP::NullOrdering());\n }\n \n template <bool STRING>\n@@ -155,7 +172,7 @@ static void LeastGreatestFunction(DataChunk &args, ExpressionState &state, Vecto\n \tresult.SetVectorType(result_type);\n }\n \n-template <class OP>\n+template <class LEAST_GREATER_OP>\n unique_ptr<FunctionData> BindLeastGreatest(ClientContext &context, ScalarFunction &bound_function,\n                                            vector<unique_ptr<Expression>> &arguments) {\n \tLogicalType child_type = ExpressionBinder::GetExpressionReturnType(*arguments[0]);\n@@ -179,7 +196,9 @@ unique_ptr<FunctionData> BindLeastGreatest(ClientContext &context, ScalarFunctio\n \tdefault:\n \t\tbreak;\n \t}\n+\tusing OP = typename LEAST_GREATER_OP::OP;\n \tswitch (child_type.InternalType()) {\n+#ifndef DUCKDB_SMALLER_BINARY\n \tcase PhysicalType::BOOL:\n \tcase PhysicalType::INT8:\n \t\tbound_function.function = LeastGreatestFunction<int8_t, OP>;\n@@ -202,10 +221,11 @@ unique_ptr<FunctionData> BindLeastGreatest(ClientContext &context, ScalarFunctio\n \tcase PhysicalType::VARCHAR:\n \t\tbound_function.function = LeastGreatestFunction<string_t, OP, StandardLeastGreatest<true>>;\n \t\tbreak;\n+#endif\n \tdefault:\n \t\t// fallback with sort keys\n \t\tbound_function.function = LeastGreatestFunction<string_t, OP, SortKeyLeastGreatest>;\n-\t\tbound_function.init_local_state = LeastGreatestSortKeyInit;\n+\t\tbound_function.init_local_state = LeastGreatestSortKeyInit<LEAST_GREATER_OP>;\n \t\tbreak;\n \t}\n \tbound_function.arguments[0] = child_type;\n@@ -229,11 +249,11 @@ static ScalarFunctionSet GetLeastGreatestFunctions() {\n }\n \n ScalarFunctionSet LeastFun::GetFunctions() {\n-\treturn GetLeastGreatestFunctions<LessThan>();\n+\treturn GetLeastGreatestFunctions<LeastOp>();\n }\n \n ScalarFunctionSet GreatestFun::GetFunctions() {\n-\treturn GetLeastGreatestFunctions<GreaterThan>();\n+\treturn GetLeastGreatestFunctions<GreaterOp>();\n }\n \n } // namespace duckdb\ndiff --git a/src/common/types/column/column_data_collection_segment.cpp b/src/common/types/column/column_data_collection_segment.cpp\nindex f8b0c1583dd9..1ec0f6f45900 100644\n--- a/src/common/types/column/column_data_collection_segment.cpp\n+++ b/src/common/types/column/column_data_collection_segment.cpp\n@@ -216,7 +216,6 @@ idx_t ColumnDataCollectionSegment::ReadVector(ChunkManagementState &state, Vecto\n \t\tauto &child_vector = ListVector::GetEntry(result);\n \t\tauto child_count = ReadVector(state, GetChildIndex(vdata.child_index), child_vector);\n \t\tListVector::SetListSize(result, child_count);\n-\n \t} else if (internal_type == PhysicalType::ARRAY) {\n \t\tauto &child_vector = ArrayVector::GetEntry(result);\n \t\tauto child_count = ReadVector(state, GetChildIndex(vdata.child_index), child_vector);\n",
  "test_patch": "diff --git a/test/sql/function/generic/test_least_greatest.test b/test/sql/function/generic/test_least_greatest.test\nindex e743f1888f81..22edc46a8e7c 100644\n--- a/test/sql/function/generic/test_least_greatest.test\n+++ b/test/sql/function/generic/test_least_greatest.test\n@@ -41,6 +41,11 @@ SELECT LEAST(NULL, 3, 0, 2, 7, 8, 10, 11, -100, 30, 1)\n ----\n -100\n \n+query I\n+SELECT GREATEST(NULL, 1.0::FLOAT)\n+----\n+1\n+\n # double\n query R\n SELECT LEAST(1.0, 10.0)\n",
  "problem_statement": "PostgreSQL incompatibility and inconsistency: Floating point version of `greatest` doesn't ignore `NULL`s\n### What happens?\r\n\r\nIn PostgreSQL, `greatest(var1, ..., varn)` and `least(var1, ..., varn)` return the greatest and least non-`NULL` arguments, respectively, for all data-types.\r\n\r\nIn DuckDB, this is true with the exception of only the `greatest` function on floating point datatypes, which returns `NULL` when any argument is `NULL`. \r\n\r\n(FWIW, [the recent SQL standards](https://modern-sql.com/caniuse/greatest-least#null) specify that `greatest` and `least` should always propagate `NULL`s, but I think this can be safely ignored since they did this after a lot of dialects already had made their choices, it doesn't seem like any other system changed in response to this, and certainly DuckDB doesn't seem to adhere to this anywhere else except for the floating point version of `greatest`.) \r\n\r\nPS: This is part two - report bug - of my dissection of https://github.com/duckdb/duckdb/issues/14239, which I closed for being too chaotic.\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nSELECT \r\ngreatest(0::FLOAT, NULL), -- DuckDB returns NULL; PostgreSQL returns 0 \r\nleast(0::FLOAT, NULL), -- both DuckDB and PostgreSQL return 0\r\ngreatest(0::INT, NULL), -- both DuckDB and PostgreSQL return 0\r\nleast(0::INT, NULL) -- both DuckDB and PostgreSQL return 0\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 20.04, x86_64\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nPostgreSQL incompatibility and inconsistency: Floating point version of `greatest` doesn't ignore `NULL`s\n### What happens?\r\n\r\nIn PostgreSQL, `greatest(var1, ..., varn)` and `least(var1, ..., varn)` return the greatest and least non-`NULL` arguments, respectively, for all data-types.\r\n\r\nIn DuckDB, this is true with the exception of only the `greatest` function on floating point datatypes, which returns `NULL` when any argument is `NULL`. \r\n\r\n(FWIW, [the recent SQL standards](https://modern-sql.com/caniuse/greatest-least#null) specify that `greatest` and `least` should always propagate `NULL`s, but I think this can be safely ignored since they did this after a lot of dialects already had made their choices, it doesn't seem like any other system changed in response to this, and certainly DuckDB doesn't seem to adhere to this anywhere else except for the floating point version of `greatest`.) \r\n\r\nPS: This is part two - report bug - of my dissection of https://github.com/duckdb/duckdb/issues/14239, which I closed for being too chaotic.\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nSELECT \r\ngreatest(0::FLOAT, NULL), -- DuckDB returns NULL; PostgreSQL returns 0 \r\nleast(0::FLOAT, NULL), -- both DuckDB and PostgreSQL return 0\r\ngreatest(0::INT, NULL), -- both DuckDB and PostgreSQL return 0\r\nleast(0::INT, NULL) -- both DuckDB and PostgreSQL return 0\r\n```\r\n\r\n### OS:\r\n\r\nUbuntu 20.04, x86_64\r\n\r\n### DuckDB Version:\r\n\r\n1.1.3\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-12-11T15:09:29Z",
  "modified_files": [
    "extension/core_functions/scalar/generic/least.cpp",
    "src/common/types/column/column_data_collection_segment.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/generic/test_least_greatest.test"
  ]
}