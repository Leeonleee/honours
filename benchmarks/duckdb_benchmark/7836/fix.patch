diff --git a/src/include/duckdb/optimizer/unnest_rewriter.hpp b/src/include/duckdb/optimizer/unnest_rewriter.hpp
index 4d6d9a93cd7a..d51a00800a67 100644
--- a/src/include/duckdb/optimizer/unnest_rewriter.hpp
+++ b/src/include/duckdb/optimizer/unnest_rewriter.hpp
@@ -45,6 +45,8 @@ class UnnestRewriterPlanUpdater : LogicalOperatorVisitor {
 
 	//! Contains all bindings that need to be updated
 	vector<ReplaceBinding> replace_bindings;
+	//! Stores the table index of the former child of the LOGICAL_UNNEST
+	idx_t overwritten_tbl_idx;
 };
 
 //! The UnnestRewriter optimizer traverses the logical operator tree and rewrites duplicate
@@ -79,6 +81,8 @@ class UnnestRewriter {
 	vector<LHSBinding> lhs_bindings;
 	//! Stores the table index of the former child of the LOGICAL_UNNEST
 	idx_t overwritten_tbl_idx;
+	//! The number of distinct columns to unnest
+	idx_t distinct_unnest_count;
 };
 
 } // namespace duckdb
diff --git a/src/optimizer/unnest_rewriter.cpp b/src/optimizer/unnest_rewriter.cpp
index e14f11019a97..34836e664d25 100644
--- a/src/optimizer/unnest_rewriter.cpp
+++ b/src/optimizer/unnest_rewriter.cpp
@@ -26,11 +26,7 @@ void UnnestRewriterPlanUpdater::VisitExpression(unique_ptr<Expression> *expressi
 		for (idx_t i = 0; i < replace_bindings.size(); i++) {
 			if (bound_column_ref.binding == replace_bindings[i].old_binding) {
 				bound_column_ref.binding = replace_bindings[i].new_binding;
-			}
-			// previously pointing to the LOGICAL_DELIM_GET
-			if (bound_column_ref.binding.table_index == replace_bindings[i].old_binding.table_index &&
-			    replace_bindings[i].old_binding.column_index == DConstants::INVALID_INDEX) {
-				bound_column_ref.binding = replace_bindings[i].new_binding;
+				break;
 			}
 		}
 	}
@@ -49,6 +45,7 @@ unique_ptr<LogicalOperator> UnnestRewriter::Optimize(unique_ptr<LogicalOperator>
 
 		// rearrange the logical operators
 		if (RewriteCandidate(candidate)) {
+			updater.overwritten_tbl_idx = overwritten_tbl_idx;
 			// update the bindings of the BOUND_UNNEST expression
 			UpdateBoundUnnestBindings(updater, candidate);
 			// update the sequence of LOGICAL_PROJECTION(s)
@@ -106,7 +103,6 @@ void UnnestRewriter::FindCandidates(unique_ptr<LogicalOperator> *op_ptr,
 	if (curr_op->get()->type == LogicalOperatorType::LOGICAL_UNNEST) {
 		candidates.push_back(op_ptr);
 	}
-	return;
 }
 
 bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {
@@ -147,6 +143,11 @@ bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {
 	auto &unnest = curr_op->get()->Cast<LogicalUnnest>();
 	D_ASSERT(unnest.children[0]->type == LogicalOperatorType::LOGICAL_DELIM_GET);
 	overwritten_tbl_idx = unnest.children[0]->Cast<LogicalDelimGet>().table_index;
+
+	D_ASSERT(!unnest.children.empty());
+	auto &delim_get = unnest.children[0]->Cast<LogicalDelimGet>();
+	D_ASSERT(delim_get.chunk_types.size() > 1);
+	distinct_unnest_count = delim_get.chunk_types.size();
 	unnest.children[0] = std::move(lhs_op);
 
 	// replace the LOGICAL_DELIM_JOIN with its RHS child operator
@@ -168,10 +169,11 @@ void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, un
 		D_ASSERT(curr_op->get()->type == LogicalOperatorType::LOGICAL_PROJECTION);
 		auto &proj = curr_op->get()->Cast<LogicalProjection>();
 
-		// pop the two last expressions from all projections (delim_idx and UNNEST column)
-		D_ASSERT(proj.expressions.size() > 2);
-		proj.expressions.pop_back();
-		proj.expressions.pop_back();
+		// pop the unnest columns and the delim index
+		D_ASSERT(proj.expressions.size() > distinct_unnest_count);
+		for (idx_t i = 0; i < distinct_unnest_count; i++) {
+			proj.expressions.pop_back();
+		}
 
 		// store all shifted current bindings
 		idx_t tbl_idx = proj.table_index;
@@ -263,14 +265,23 @@ void UnnestRewriter::UpdateBoundUnnestBindings(UnnestRewriterPlanUpdater &update
 	auto &unnest = curr_op->get()->Cast<LogicalUnnest>();
 
 	D_ASSERT(unnest.children.size() == 1);
-	auto unnest_child_cols = unnest.children[0]->GetColumnBindings();
-	for (idx_t delim_col_idx = 0; delim_col_idx < delim_columns.size(); delim_col_idx++) {
-		for (idx_t child_col_idx = 0; child_col_idx < unnest_child_cols.size(); child_col_idx++) {
-			if (delim_columns[delim_col_idx].table_index == unnest_child_cols[child_col_idx].table_index) {
-				ColumnBinding old_binding(overwritten_tbl_idx, DConstants::INVALID_INDEX);
-				updater.replace_bindings.emplace_back(old_binding, delim_columns[delim_col_idx]);
+	auto unnest_cols = unnest.children[0]->GetColumnBindings();
+
+	for (idx_t i = 0; i < delim_columns.size(); i++) {
+		auto delim_binding = delim_columns[i];
+
+		auto unnest_it = unnest_cols.begin();
+		while (unnest_it != unnest_cols.end()) {
+			auto unnest_binding = *unnest_it;
+
+			if (delim_binding.table_index == unnest_binding.table_index) {
+				unnest_binding.table_index = overwritten_tbl_idx;
+				unnest_binding.column_index++;
+				updater.replace_bindings.emplace_back(unnest_binding, delim_binding);
+				unnest_cols.erase(unnest_it);
 				break;
 			}
+			unnest_it++;
 		}
 	}
 
