diff --git a/src/common/types/vector_buffer.cpp b/src/common/types/vector_buffer.cpp
index 59bc6f9cadf2..aed61d192f52 100644
--- a/src/common/types/vector_buffer.cpp
+++ b/src/common/types/vector_buffer.cpp
@@ -67,11 +67,12 @@ VectorListBuffer::VectorListBuffer(const LogicalType &list_type, idx_t initial_c
 
 void VectorListBuffer::Reserve(idx_t to_reserve) {
 	if (to_reserve > capacity) {
-		idx_t new_capacity = NextPowerOfTwo(to_reserve);
-		if (new_capacity == 0) {
-			// Overflow: set to_reserve to the maximum value
-			new_capacity = to_reserve;
+		if (to_reserve > DConstants::MAX_VECTOR_SIZE) {
+			// overflow: throw an exception
+			throw OutOfRangeException("Cannot resize vector to %d rows: maximum allowed vector size is %s", to_reserve,
+			                          StringUtil::BytesToHumanReadableString(DConstants::MAX_VECTOR_SIZE));
 		}
+		idx_t new_capacity = NextPowerOfTwo(to_reserve);
 		D_ASSERT(new_capacity >= to_reserve);
 		child->Resize(capacity, new_capacity);
 		capacity = new_capacity;
diff --git a/src/core_functions/scalar/string/repeat.cpp b/src/core_functions/scalar/string/repeat.cpp
index c7ceef99257b..31318290fe3a 100644
--- a/src/core_functions/scalar/string/repeat.cpp
+++ b/src/core_functions/scalar/string/repeat.cpp
@@ -65,7 +65,8 @@ static void RepeatListFunction(DataChunk &args, ExpressionState &, Vector &resul
 		    result_list.length = result_length;
 		    for (idx_t i = 0; i < copy_count; i++) {
 			    // repeat the list contents "cnt" times
-			    VectorOperations::Copy(source_child, result_child, list_input.length, list_input.offset, current_size);
+			    VectorOperations::Copy(source_child, result_child, list_input.offset + list_input.length,
+			                           list_input.offset, current_size);
 			    current_size += list_input.length;
 		    }
 		    return result_list;
diff --git a/src/function/scalar/generic/binning.cpp b/src/function/scalar/generic/binning.cpp
index 8882f0c3f070..6d84b5f6191f 100644
--- a/src/function/scalar/generic/binning.cpp
+++ b/src/function/scalar/generic/binning.cpp
@@ -129,15 +129,15 @@ struct EquiWidthBinsInteger {
 		hugeint_t step = span / Hugeint::Convert(bin_count);
 		if (nice_rounding) {
 			// when doing nice rounding we try to make the max/step values nicer
-			step = MakeNumberNice(step, step, NiceRounding::ROUND);
-			max = RoundToNumber(max, step, NiceRounding::CEILING);
+			hugeint_t new_step = MakeNumberNice(step, step, NiceRounding::ROUND);
+			hugeint_t new_max = RoundToNumber(max, new_step, NiceRounding::CEILING);
+			if (new_max != min && new_step != 0) {
+				max = new_max;
+				step = new_step;
+			}
 			// we allow for more bins when doing nice rounding since the bin count is approximate
 			bin_count *= 2;
 		}
-		if (step == 0) {
-			throw InternalException("step is 0!?");
-		}
-
 		for (hugeint_t bin_boundary = max; bin_boundary > min; bin_boundary -= step) {
 			const hugeint_t target_boundary = bin_boundary / FACTOR;
 			int64_t real_boundary = Hugeint::Cast<int64_t>(target_boundary);
diff --git a/src/planner/binder/expression/bind_star_expression.cpp b/src/planner/binder/expression/bind_star_expression.cpp
index ae9bd0d98052..e25c69c160ee 100644
--- a/src/planner/binder/expression/bind_star_expression.cpp
+++ b/src/planner/binder/expression/bind_star_expression.cpp
@@ -203,6 +203,9 @@ void Binder::ExpandStarExpression(unique_ptr<ParsedExpression> expr,
 			// scan the list for all selected columns and construct a lookup table
 			case_insensitive_map_t<bool> selected_set;
 			for (auto &child : children) {
+				if (child.IsNull()) {
+					throw BinderException(*star, "Columns expression does not support NULL input parameters");
+				}
 				selected_set.insert(make_pair(StringValue::Get(child), false));
 			}
 			// now check the list of all possible expressions and select which ones make it in
