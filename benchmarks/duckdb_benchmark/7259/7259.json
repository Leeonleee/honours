{
  "repo": "duckdb/duckdb",
  "pull_number": 7259,
  "instance_id": "duckdb__duckdb-7259",
  "issue_numbers": [
    "7209"
  ],
  "base_commit": "3f43d28dcb62e42dc7253270f55b7c07ec4e34ea",
  "patch": "diff --git a/src/execution/operator/persistent/physical_insert.cpp b/src/execution/operator/persistent/physical_insert.cpp\nindex 770ccabff6a4..202f2eb87eb2 100644\n--- a/src/execution/operator/persistent/physical_insert.cpp\n+++ b/src/execution/operator/persistent/physical_insert.cpp\n@@ -102,6 +102,7 @@ class InsertLocalState : public LocalSinkState {\n \toptional_ptr<OptimisticDataWriter> writer;\n \t// Rows that have been updated by a DO UPDATE conflict\n \tunordered_set<row_t> updated_rows;\n+\tidx_t update_count = 0;\n };\n \n unique_ptr<GlobalSinkState> PhysicalInsert::GetGlobalSinkState(ClientContext &context) const {\n@@ -217,10 +218,10 @@ void PhysicalInsert::CombineExistingAndInsertTuples(DataChunk &result, DataChunk\n \tresult.SetCardinality(input_chunk.size());\n }\n \n-void PhysicalInsert::PerformOnConflictAction(ExecutionContext &context, DataChunk &chunk, TableCatalogEntry &table,\n-                                             Vector &row_ids) const {\n+idx_t PhysicalInsert::PerformOnConflictAction(ExecutionContext &context, DataChunk &chunk, TableCatalogEntry &table,\n+                                              Vector &row_ids) const {\n \tif (action_type == OnConflictAction::NOTHING) {\n-\t\treturn;\n+\t\treturn 0;\n \t}\n \n \tDataChunk update_chunk; // contains only the to-update columns\n@@ -259,6 +260,7 @@ void PhysicalInsert::PerformOnConflictAction(ExecutionContext &context, DataChun\n \tauto &data_table = table.GetStorage();\n \t// Perform the update, using the results of the SET expressions\n \tdata_table.Update(table, context.client, row_ids, set_columns, update_chunk);\n+\treturn update_chunk.size();\n }\n \n // TODO: should we use a hash table to keep track of this instead?\n@@ -275,12 +277,12 @@ void PhysicalInsert::RegisterUpdatedRows(InsertLocalState &lstate, const Vector\n \t}\n }\n \n-void PhysicalInsert::OnConflictHandling(TableCatalogEntry &table, ExecutionContext &context,\n-                                        InsertLocalState &lstate) const {\n+idx_t PhysicalInsert::OnConflictHandling(TableCatalogEntry &table, ExecutionContext &context,\n+                                         InsertLocalState &lstate) const {\n \tauto &data_table = table.GetStorage();\n \tif (action_type == OnConflictAction::THROW) {\n \t\tdata_table.VerifyAppendConstraints(table, context.client, lstate.insert_chunk, nullptr);\n-\t\treturn;\n+\t\treturn 0;\n \t}\n \t// Check whether any conflicts arise, and if they all meet the conflict_target + condition\n \t// If that's not the case - We throw the first error\n@@ -291,8 +293,8 @@ void PhysicalInsert::OnConflictHandling(TableCatalogEntry &table, ExecutionConte\n \tdata_table.VerifyAppendConstraints(table, context.client, lstate.insert_chunk, &conflict_manager);\n \tconflict_manager.Finalize();\n \tif (conflict_manager.ConflictCount() == 0) {\n-\t\t// No conflicts found\n-\t\treturn;\n+\t\t// No conflicts found, 0 updates performed\n+\t\treturn 0;\n \t}\n \tauto &conflicts = conflict_manager.Conflicts();\n \tauto &row_ids = conflict_manager.RowIds();\n@@ -343,7 +345,7 @@ void PhysicalInsert::OnConflictHandling(TableCatalogEntry &table, ExecutionConte\n \n \tRegisterUpdatedRows(lstate, row_ids, combined_chunk.size());\n \n-\tPerformOnConflictAction(context, combined_chunk, table, row_ids);\n+\tidx_t updated_tuples = PerformOnConflictAction(context, combined_chunk, table, row_ids);\n \n \t// Remove the conflicting tuples from the insert chunk\n \tSelectionVector sel_vec(lstate.insert_chunk.size());\n@@ -351,6 +353,7 @@ void PhysicalInsert::OnConflictHandling(TableCatalogEntry &table, ExecutionConte\n \t    SelectionVector::Inverted(conflicts.Selection(), sel_vec, conflicts.Count(), lstate.insert_chunk.size());\n \tlstate.insert_chunk.Slice(sel_vec, new_size);\n \tlstate.insert_chunk.SetCardinality(new_size);\n+\treturn updated_tuples;\n }\n \n SinkResultType PhysicalInsert::Sink(ExecutionContext &context, GlobalSinkState &state, LocalSinkState &lstate_p,\n@@ -368,13 +371,14 @@ SinkResultType PhysicalInsert::Sink(ExecutionContext &context, GlobalSinkState &\n \t\t\tgstate.initialized = true;\n \t\t}\n \n-\t\tOnConflictHandling(table, context, lstate);\n+\t\tidx_t updated_tuples = OnConflictHandling(table, context, lstate);\n \t\tstorage.LocalAppend(gstate.append_state, table, context.client, lstate.insert_chunk, true);\n \n \t\tif (return_chunk) {\n \t\t\tgstate.return_collection.Append(lstate.insert_chunk);\n \t\t}\n-\t\tgstate.insert_count += chunk.size();\n+\t\tgstate.insert_count += lstate.insert_chunk.size();\n+\t\tgstate.insert_count += updated_tuples;\n \t} else {\n \t\tD_ASSERT(!return_chunk);\n \t\t// parallel append\n@@ -388,7 +392,8 @@ SinkResultType PhysicalInsert::Sink(ExecutionContext &context, GlobalSinkState &\n \t\t\tlstate.local_collection->InitializeAppend(lstate.local_append_state);\n \t\t\tlstate.writer = &gstate.table.GetStorage().CreateOptimisticWriter(context.client);\n \t\t}\n-\t\tOnConflictHandling(table, context, lstate);\n+\t\tlstate.update_count += OnConflictHandling(table, context, lstate);\n+\n \t\tauto new_row_group = lstate.local_collection->Append(lstate.insert_chunk, lstate.local_append_state);\n \t\tif (new_row_group) {\n \t\t\tlstate.writer->CheckFlushToDisk(*lstate.local_collection);\n@@ -421,6 +426,7 @@ void PhysicalInsert::Combine(ExecutionContext &context, GlobalSinkState &gstate_\n \t\t// we have few rows - append to the local storage directly\n \t\tlock_guard<mutex> lock(gstate.lock);\n \t\tgstate.insert_count += append_count;\n+\t\tgstate.insert_count += lstate.update_count;\n \t\tauto &table = gstate.table;\n \t\tauto &storage = table.GetStorage();\n \t\tstorage.InitializeLocalAppend(gstate.append_state, context.client);\n@@ -438,6 +444,7 @@ void PhysicalInsert::Combine(ExecutionContext &context, GlobalSinkState &gstate_\n \n \t\tlock_guard<mutex> lock(gstate.lock);\n \t\tgstate.insert_count += append_count;\n+\t\tgstate.insert_count += lstate.update_count;\n \t\tgstate.table.GetStorage().LocalMerge(context.client, *lstate.local_collection);\n \t}\n }\ndiff --git a/src/include/duckdb/execution/operator/persistent/physical_insert.hpp b/src/include/duckdb/execution/operator/persistent/physical_insert.hpp\nindex 6996716b921d..3bf0e952be85 100644\n--- a/src/include/duckdb/execution/operator/persistent/physical_insert.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/physical_insert.hpp\n@@ -116,9 +116,10 @@ class PhysicalInsert : public PhysicalOperator {\n protected:\n \tvoid CombineExistingAndInsertTuples(DataChunk &result, DataChunk &scan_chunk, DataChunk &input_chunk,\n \t                                    ClientContext &client) const;\n-\tvoid OnConflictHandling(TableCatalogEntry &table, ExecutionContext &context, InsertLocalState &lstate) const;\n-\tvoid PerformOnConflictAction(ExecutionContext &context, DataChunk &chunk, TableCatalogEntry &table,\n-\t                             Vector &row_ids) const;\n+\t//! Returns the amount of updated tuples\n+\tidx_t OnConflictHandling(TableCatalogEntry &table, ExecutionContext &context, InsertLocalState &lstate) const;\n+\tidx_t PerformOnConflictAction(ExecutionContext &context, DataChunk &chunk, TableCatalogEntry &table,\n+\t                              Vector &row_ids) const;\n \tvoid RegisterUpdatedRows(InsertLocalState &lstate, const Vector &row_ids, idx_t count) const;\n };\n \n",
  "test_patch": "diff --git a/test/sql/upsert/upsert_default.test b/test/sql/upsert/upsert_default.test\nindex 1a9c6cf86956..afb099bc949e 100644\n--- a/test/sql/upsert/upsert_default.test\n+++ b/test/sql/upsert/upsert_default.test\n@@ -25,3 +25,23 @@ select * from tbl;\n 5\t6\t10\n 5\t7\t10\n 5\t4\t10\n+\n+statement ok\n+create table t (i int primary key, j int);\n+\n+query I\n+insert into t values (1, 1) on conflict do nothing;\n+----\n+1\n+\n+# 0 updates/insertions were performed\n+query I\n+insert into t values (1, 1) on conflict do nothing\n+----\n+0\n+\n+# 0 insertions, but one tuple is updated\n+query I\n+insert into t values (1, 1) on conflict (i) do update set j = excluded.i;\n+----\n+1\n",
  "problem_statement": "Wrong update count in JDBC when INSERT .. ON CONFLICT DO NOTHING statement does nothing\n### What happens?\n\nThis may or may not be a bug (if it's not, then I suggest documenting this behaviour).\r\n\r\nWhen running an `INSERT .. ON CONFLICT DO NOTHING` statement, which produces a conflict and thus does nothing, I would expect the resulting update count to be `0`, not `1`\n\n### To Reproduce\n\n```java\r\ntry (Statement s = connection.createStatement()) {\r\n    try {\r\n        s.executeUpdate(\"create table t (i int primary key, j int)\");\r\n\r\n        System.out.println(s.executeUpdate(\"insert into t values (1, 1) on conflict do nothing\"));\r\n        System.out.println(s.executeUpdate(\"insert into t values (1, 2) on conflict do nothing\"));\r\n    }\r\n    finally {\r\n        s.executeUpdate(\"drop table t\");\r\n    }\r\n}\r\n```\r\n\r\nThis prints:\r\n\r\n```\r\n1\r\n1\r\n```\r\n\r\nBut I would have expected:\r\n\r\n```\r\n1\r\n0\r\n```\n\n### OS:\n\nMicrosoft Windows [Version 10.0.22621.1555]\n\n### DuckDB Version:\n\nv0.7.2-dev2430\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nLukas Eder\n\n### Affiliation:\n\nData Geekery / jOOQ\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "This doesn't look to be java specific, as I can replicate it in the cli",
  "created_at": "2023-04-26T09:25:04Z",
  "modified_files": [
    "src/execution/operator/persistent/physical_insert.cpp",
    "src/include/duckdb/execution/operator/persistent/physical_insert.hpp"
  ],
  "modified_test_files": [
    "test/sql/upsert/upsert_default.test"
  ]
}