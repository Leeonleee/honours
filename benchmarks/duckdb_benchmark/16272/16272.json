{
  "repo": "duckdb/duckdb",
  "pull_number": 16272,
  "instance_id": "duckdb__duckdb-16272",
  "issue_numbers": [
    "16231"
  ],
  "base_commit": "52811a9d197d8c4e98d291b4144a0d1724cefbda",
  "patch": "diff --git a/src/parser/transform/expression/transform_subquery.cpp b/src/parser/transform/expression/transform_subquery.cpp\nindex 6f6d742073ba..0403d24bc5dc 100644\n--- a/src/parser/transform/expression/transform_subquery.cpp\n+++ b/src/parser/transform/expression/transform_subquery.cpp\n@@ -107,6 +107,7 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \t\t\t}\n \t\t}\n \t\t// transform constants (e.g. ORDER BY 1) into positional references (ORDER BY #1)\n+\t\tidx_t array_idx = 0;\n \t\tif (aggr->order_bys) {\n \t\t\tfor (auto &order : aggr->order_bys->orders) {\n \t\t\t\tif (order.expression->GetExpressionType() == ExpressionType::VALUE_CONSTANT) {\n@@ -120,8 +121,10 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \t\t\t\t\t}\n \t\t\t\t} else if (sub_select) {\n \t\t\t\t\t// if we have a SELECT we can push the ORDER BY clause into the SELECT list and reference it\n+\t\t\t\t\tauto alias = \"__array_internal_idx_\" + to_string(++array_idx);\n+\t\t\t\t\torder.expression->alias = alias;\n \t\t\t\t\tsub_select->select_list.push_back(std::move(order.expression));\n-\t\t\t\t\torder.expression = make_uniq<PositionalReferenceExpression>(sub_select->select_list.size() - 1);\n+\t\t\t\t\torder.expression = make_uniq<ColumnRefExpression>(alias);\n \t\t\t\t} else {\n \t\t\t\t\t// otherwise we remove order qualifications\n \t\t\t\t\tRemoveOrderQualificationRecursive(order.expression);\n",
  "test_patch": "diff --git a/test/sql/subquery/scalar/array_order_subquery.test b/test/sql/subquery/scalar/array_order_subquery.test\nindex a0ca2fb4c7d0..94abd308009a 100644\n--- a/test/sql/subquery/scalar/array_order_subquery.test\n+++ b/test/sql/subquery/scalar/array_order_subquery.test\n@@ -86,6 +86,16 @@ SELECT ARRAY\n ----\n [3, 2, 1]\n \n+query I\n+select array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1)) as out;\n+----\n+[b, a]\n+\n+query I\n+select array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1) desc) as out;\n+----\n+[a, b]\n+\n statement error\n SELECT ARRAY\n   (SELECT 1 UNION ALL\n",
  "problem_statement": "Array ordering regression in release 1.2.0\n### What happens?\n\nDuckdb 1.2.0 seems to sort arrays by value, ignoring order by expressions. This was not happening in duckdb 1.1.3 ( i.e. the order was consistent with the expression) \n\n\n### To Reproduce\n\n```sql\nselect array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1)) as out;\nselect array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1) desc) as out;\n```\n\nin duckdb 1.1.3 it returns \n```\nselect array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1)) as out;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    out    \u2502\n\u2502 varchar[] \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [b, a]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n```\nselect array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1) desc) as out;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    out    \u2502\n\u2502 varchar[] \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [a, b]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nwhereas in duckdb 1.2.0 I get \n```\nselect array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1)) as out;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    out    \u2502\n\u2502 varchar[] \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [a, b]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n```\nselect array(select * from unnest(['a', 'b']) as _t(u) order by if(u='a',100, 1) desc) as out;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    out    \u2502\n\u2502 varchar[] \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [b, a]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### OS:\n\nMacOS 15 (aarch64) Python 3.11.6 . Also fails on linux ubuntu 22.04, x86 Python 3.11.6\n\n### DuckDB Version:\n\n1.2.0\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nChinmoy Mandayam\n\n### Affiliation:\n\nActively\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "It seems related to https://github.com/duckdb/duckdb/issues/15052, but that was buggy in 1.1.0, and 1.1.3 gives the right result for me\nThanks, this reproduces in the CLI client as well.",
  "created_at": "2025-02-17T15:02:38Z",
  "modified_files": [
    "src/parser/transform/expression/transform_subquery.cpp"
  ],
  "modified_test_files": [
    "test/sql/subquery/scalar/array_order_subquery.test"
  ]
}