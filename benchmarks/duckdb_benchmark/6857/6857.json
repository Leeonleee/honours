{
  "repo": "duckdb/duckdb",
  "pull_number": 6857,
  "instance_id": "duckdb__duckdb-6857",
  "issue_numbers": [
    "6856",
    "6856"
  ],
  "base_commit": "41104b611e68e401d098668827eecc46c3b8e86a",
  "patch": "diff --git a/src/function/cast_rules.cpp b/src/function/cast_rules.cpp\nindex 75d5c3085936..f4ffb84c92f9 100644\n--- a/src/function/cast_rules.cpp\n+++ b/src/function/cast_rules.cpp\n@@ -207,6 +207,15 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// if aliases are different, an implicit cast is not possible\n \t\treturn -1;\n \t}\n+\tif (from.id() == LogicalTypeId::LIST && to.id() == LogicalTypeId::LIST) {\n+\t\t// Lists can be cast if their child types can be cast\n+\t\tauto child_cost = ImplicitCast(ListType::GetChildType(from), ListType::GetChildType(to));\n+\t\tif (child_cost >= 100) {\n+\t\t\t// subtract one from the cost because we prefer LIST[X] -> LIST[VARCHAR] over LIST[X] -> VARCHAR\n+\t\t\tchild_cost--;\n+\t\t}\n+\t\treturn child_cost;\n+\t}\n \tif (from.id() == to.id()) {\n \t\t// arguments match: do nothing\n \t\treturn 0;\n@@ -219,10 +228,6 @@ int64_t CastRules::ImplicitCast(const LogicalType &from, const LogicalType &to)\n \t\t// everything can be cast to VARCHAR, but this cast has a high cost\n \t\treturn TargetTypeCost(to);\n \t}\n-\tif (from.id() == LogicalTypeId::LIST && to.id() == LogicalTypeId::LIST) {\n-\t\t// Lists can be cast if their child types can be cast\n-\t\treturn ImplicitCast(ListType::GetChildType(from), ListType::GetChildType(to));\n-\t}\n \n \tif (from.id() == LogicalTypeId::UNION && to.id() == LogicalTypeId::UNION) {\n \t\t// Unions can be cast if the source tags are a subset of the target tags\n",
  "test_patch": "diff --git a/test/sql/function/list/flatten.test b/test/sql/function/list/flatten.test\nindex cf1f2e8e240d..a492799806e7 100644\n--- a/test/sql/function/list/flatten.test\n+++ b/test/sql/function/list/flatten.test\n@@ -124,3 +124,19 @@ SELECT i, flatten([[1, 2], [3, 4]]) FROM nested_lists\n 1\t[1, 2, 3, 4]\n 2\t[1, 2, 3, 4]\n 3\t[1, 2, 3, 4]\n+\n+# Issue #6856 - flatten() segfaults when called on bad input\n+statement error\n+select flatten(42);\n+----\n+No function matches the given name and argument types\n+\n+statement error\n+select flatten([1, 2]);\n+----\n+No function matches the given name and argument types\n+\n+query I\n+select flatten(NULL);\n+----\n+NULL\ndiff --git a/test/sql/types/union/union_list.test b/test/sql/types/union/union_list.test\nindex bf5305016bdd..4fe7590512d1 100644\n--- a/test/sql/types/union/union_list.test\n+++ b/test/sql/types/union/union_list.test\n@@ -69,20 +69,6 @@ SELECT union_list[1] FROM tbl2 JOIN tbl1 ON union_with_list.num = union_list[1];\n statement ok\n CREATE TABLE tbl3 (union_with_lists UNION(strs VARCHAR[], nums INT[]));\n \n-# This doesnt work since casting to list costs the same\n-statement error \n-INSERT INTO tbl3 VALUES \n-    (['one', 'two']), \n-    ([1, 2]), \n-    (['three', NULL]), \n-    ([3, 4]),\n-    (['five']), \n-    ([5]), \n-    (['six']), \n-    ([NULL, 6]), \n-    (union_value(strs:=NULL)), \n-\n-\n statement ok \n INSERT INTO tbl3 VALUES \n     (union_value(strs:=['one', 'two'])), \n",
  "problem_statement": "flatten() segfaults when called on bad input\n### What happens?\n\nCalling `flatten` on a list of literals, as opposed to a list of lists, results in a segfault instead of a user readable error.\r\nHave not tried this on trunk. This is trivially reproducible for v0.7.1 b00b93f0b1 and master.\n\n### To Reproduce\n\nJust try to `select flatten([1,2]);`. Here's a copy and paste from my duckdb session:\r\n\r\n```\r\nD select flatten([[1,2]]);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 flatten(main.list_value(main.list_value(1, 2))) \u2502\r\n\u2502                     int32[]                     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1, 2]                                          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select flatten([1, 2]);\r\nzsh: segmentation fault  duckdb\r\n```\n\n### OS:\n\nMacOS,  M1, arm64\n\n### DuckDB Version:\n\nv0.7.1 b00b93f0b1, 0.7.2-dev1034 \n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nDmitriy Ryaboy\n\n### Affiliation:\n\nGinkgo Bioworks\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nflatten() segfaults when called on bad input\n### What happens?\n\nCalling `flatten` on a list of literals, as opposed to a list of lists, results in a segfault instead of a user readable error.\r\nHave not tried this on trunk. This is trivially reproducible for v0.7.1 b00b93f0b1 and master.\n\n### To Reproduce\n\nJust try to `select flatten([1,2]);`. Here's a copy and paste from my duckdb session:\r\n\r\n```\r\nD select flatten([[1,2]]);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 flatten(main.list_value(main.list_value(1, 2))) \u2502\r\n\u2502                     int32[]                     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1, 2]                                          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD select flatten([1, 2]);\r\nzsh: segmentation fault  duckdb\r\n```\n\n### OS:\n\nMacOS,  M1, arm64\n\n### DuckDB Version:\n\nv0.7.1 b00b93f0b1, 0.7.2-dev1034 \n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nDmitriy Ryaboy\n\n### Affiliation:\n\nGinkgo Bioworks\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2023-03-24T22:02:05Z",
  "modified_files": [
    "src/function/cast_rules.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/list/flatten.test",
    "test/sql/types/union/union_list.test"
  ]
}