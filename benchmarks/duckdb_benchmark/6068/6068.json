{
  "repo": "duckdb/duckdb",
  "pull_number": 6068,
  "instance_id": "duckdb__duckdb-6068",
  "issue_numbers": [
    "1468"
  ],
  "base_commit": "9ef9931d65ee0bca488d7a9a037bb143afd7fc33",
  "patch": "diff --git a/src/function/pragma/pragma_queries.cpp b/src/function/pragma/pragma_queries.cpp\nindex 5fd8044cbb66..9bc3e274d7ec 100644\n--- a/src/function/pragma/pragma_queries.cpp\n+++ b/src/function/pragma/pragma_queries.cpp\n@@ -1,10 +1,12 @@\n-#include \"duckdb/function/pragma/pragma_functions.hpp\"\n-#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/common/constants.hpp\"\n #include \"duckdb/common/file_system.hpp\"\n-#include \"duckdb/parser/statement/export_statement.hpp\"\n-#include \"duckdb/parser/statement/copy_statement.hpp\"\n-#include \"duckdb/parser/parser.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/function/pragma/pragma_functions.hpp\"\n #include \"duckdb/main/config.hpp\"\n+#include \"duckdb/parser/parser.hpp\"\n+#include \"duckdb/parser/qualified_name.hpp\"\n+#include \"duckdb/parser/statement/copy_statement.hpp\"\n+#include \"duckdb/parser/statement/export_statement.hpp\"\n \n namespace duckdb {\n \n@@ -58,10 +60,35 @@ string PragmaFunctionsQuery(ClientContext &context, const FunctionParameters &pa\n \n string PragmaShow(ClientContext &context, const FunctionParameters &parameters) {\n \t// PRAGMA table_info but with some aliases\n-\treturn StringUtil::Format(\n-\t    \"SELECT name AS \\\"column_name\\\", type as \\\"column_type\\\", CASE WHEN \\\"notnull\\\" THEN 'NO' ELSE 'YES' \"\n-\t    \"END AS \\\"null\\\", NULL AS \\\"key\\\", dflt_value AS \\\"default\\\", NULL AS \\\"extra\\\" FROM pragma_table_info('%s');\",\n-\t    parameters.values[0].ToString());\n+\tauto table = QualifiedName::Parse(parameters.values[0].ToString());\n+\n+\t// clang-format off\n+    string sql = R\"(\n+\tSELECT\n+\t\tname AS \"column_name\",\n+\t\ttype as \"column_type\",\n+\t\tCASE WHEN \"notnull\" THEN 'NO' ELSE 'YES' END AS \"null\",\n+\t\t(SELECT \n+\t\t\tMIN(CASE \n+\t\t\t\tWHEN constraint_type='PRIMARY KEY' THEN 'PRI'\n+\t\t\t\tWHEN constraint_type='UNIQUE' THEN 'UNI' \n+\t\t\t\tELSE NULL END) \n+\t\tFROM duckdb_constraints() c  \n+\t\tWHERE c.table_oid=cols.table_oid \n+\t\tAND list_contains(constraint_column_names, cols.column_name)) AS \"key\",\n+\t\tdflt_value AS \"default\", \n+\t\tNULL AS \"extra\" \n+\tFROM pragma_table_info('%func_param_table%') \n+\tLEFT JOIN duckdb_columns cols \n+\tON cols.column_name = pragma_table_info.name \n+\tAND cols.table_name='%table_name%'\n+\tAND cols.schema_name='%table_schema%';)\";\n+\t// clang-format on\n+\n+\tsql = StringUtil::Replace(sql, \"%func_param_table%\", parameters.values[0].ToString());\n+\tsql = StringUtil::Replace(sql, \"%table_name%\", table.name);\n+\tsql = StringUtil::Replace(sql, \"%table_schema%\", table.schema.empty() ? DEFAULT_SCHEMA : table.schema);\n+\treturn sql;\n }\n \n string PragmaVersion(ClientContext &context, const FunctionParameters &parameters) {\n",
  "test_patch": "diff --git a/test/sql/pragma/test_show_tables.test b/test/sql/pragma/test_show_tables.test\nindex 1ee2026db108..94d3e327c697 100644\n--- a/test/sql/pragma/test_show_tables.test\n+++ b/test/sql/pragma/test_show_tables.test\n@@ -11,12 +11,57 @@ CREATE TABLE \"select\"(i INTEGER);\n statement ok\n CREATE VIEW v1 AS SELECT DATE '1992-01-01' AS k\n \n+statement ok\n+CREATE TABLE t2 (id INTEGER PRIMARY KEY, j VARCHAR UNIQUE)\n+\n+statement ok\n+CREATE SCHEMA s1;\n+\n+statement ok\n+CREATE TABLE s1.tbl(i INTEGER UNIQUE);\n+\n+statement ok\n+CREATE TABLE tbl(i INTEGER PRIMARY KEY);\n+\n+# We test that right table is described (from s1 schema)\n+# column_name | column_type | null | key | default | extra\n+query TTTITI\n+DESCRIBE s1.tbl;\n+----\n+i\tINTEGER\tYES\tUNI\tNULL\tNULL\n+\n+# We test that right table is described (from main schema)\n+# column_name | column_type | null | key | default | extra\n+query TTTITI\n+DESCRIBE tbl;\n+----\n+i\tINTEGER\tNO\tPRI\tNULL\tNULL\n+\n+# Validate PRI and UNI constrains\n+# column_name | column_type | null | key | default | extra\n+query TTTITI\n+DESCRIBE t2\n+----\n+id\tINTEGER\tNO\tPRI\tNULL\tNULL\n+j\tVARCHAR\tYES\tUNI\tNULL\tNULL\n+\n+# equivalent to DESCRIBE t2\n+# column_name | column_type | null | key | default | extra\n+query TTTITI\n+PRAGMA SHOW('t2')\n+----\n+id\tINTEGER\tNO\tPRI\tNULL\tNULL\n+j\tVARCHAR\tYES\tUNI\tNULL\tNULL\n+\n # SHOW and DESCRIBE are aliases\n query T\n SHOW TABLES\n ----\n integers\n select\n+t2\n+tbl\n+tbl\n v1\n \n query T\n@@ -24,6 +69,9 @@ DESCRIBE TABLES\n ----\n integers\n select\n+t2\n+tbl\n+tbl\n v1\n \n # internally they are equivalent to PRAGMA SHOW_TABLES();\n@@ -32,6 +80,9 @@ PRAGMA show_tables\n ----\n integers\n select\n+t2\n+tbl\n+tbl\n v1\n \n # column_name | column_type | null | key | default | extra\n",
  "problem_statement": "DESCRIBE does not show primary key\nVersion 0.2.4 on Linux\r\n\r\n```\r\nD CREATE TABLE t1(id INTEGER PRIMARY KEY, j VARCHAR);\r\nD describe t1;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Field \u2502  Type   \u2502 Null \u2502 Key \u2502 Default \u2502 Extra \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 id    \u2502 INTEGER \u2502 NO   \u2502     \u2502         \u2502       \u2502\r\n\u2502 j     \u2502 VARCHAR \u2502 YES  \u2502     \u2502         \u2502       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD PRAGMA table_info('t1');\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 cid \u2502 name \u2502  type   \u2502 notnull \u2502 dflt_value \u2502  pk   \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 0   \u2502 id   \u2502 INTEGER \u2502 true    \u2502            \u2502 true  \u2502\r\n\u2502 1   \u2502 j    \u2502 VARCHAR \u2502 false   \u2502            \u2502 false \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "Likewise, table_info needs to give more information regarding column constraints.  UNIQUE in particular seems like it ought to be there.",
  "created_at": "2023-02-01T20:07:08Z",
  "modified_files": [
    "src/function/pragma/pragma_queries.cpp"
  ],
  "modified_test_files": [
    "test/sql/pragma/test_show_tables.test"
  ]
}