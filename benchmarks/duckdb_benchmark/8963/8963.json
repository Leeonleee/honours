{
  "repo": "duckdb/duckdb",
  "pull_number": 8963,
  "instance_id": "duckdb__duckdb-8963",
  "issue_numbers": [
    "7581"
  ],
  "base_commit": "53dc13de5c456624788c8502f36460d8a889dfc6",
  "patch": "diff --git a/extension/icu/icu-datepart.cpp b/extension/icu/icu-datepart.cpp\nindex 500015d759c2..9f917b64f80b 100644\n--- a/extension/icu/icu-datepart.cpp\n+++ b/extension/icu/icu-datepart.cpp\n@@ -108,10 +108,11 @@ struct ICUDatePart : public ICUDateFunc {\n \t\treturn ExtractMillisecond(calendar, micros) * Interval::MICROS_PER_MSEC + micros;\n \t}\n \n-\tstatic int64_t ExtractEpoch(icu::Calendar *calendar, const uint64_t micros) {\n+\tstatic double ExtractEpoch(icu::Calendar *calendar, const uint64_t micros) {\n \t\tUErrorCode status = U_ZERO_ERROR;\n-\t\t//\tTruncate\n-\t\treturn calendar->getTime(status) / Interval::MSECS_PER_SEC;\n+\t\tauto result = calendar->getTime(status) / Interval::MSECS_PER_SEC;\n+\t\tresult += micros / double(Interval::MICROS_PER_SEC);\n+\t\treturn result;\n \t}\n \n \tstatic int64_t ExtractTimezone(icu::Calendar *calendar, const uint64_t micros) {\n@@ -187,8 +188,6 @@ struct ICUDatePart : public ICUDateFunc {\n \t\t\treturn ExtractQuarter;\n \t\tcase DatePartSpecifier::YEARWEEK:\n \t\t\treturn ExtractYearWeek;\n-\t\tcase DatePartSpecifier::EPOCH:\n-\t\t\treturn ExtractEpoch;\n \t\tcase DatePartSpecifier::ERA:\n \t\t\treturn ExtractEra;\n \t\tcase DatePartSpecifier::TIMEZONE:\n@@ -204,6 +203,8 @@ struct ICUDatePart : public ICUDateFunc {\n \n \tstatic part_double_t PartCodeDoubleFactory(DatePartSpecifier part) {\n \t\tswitch (part) {\n+\t\tcase DatePartSpecifier::EPOCH:\n+\t\t\treturn ExtractEpoch;\n \t\tcase DatePartSpecifier::JULIAN_DAY:\n \t\t\treturn ExtractJulianDay;\n \t\tdefault:\n@@ -262,7 +263,7 @@ struct ICUDatePart : public ICUDateFunc {\n \t\tadapters_t adapters;\n \n \t\tbool Equals(const FunctionData &other_p) const override {\n-\t\t\tconst auto &other = (BindAdapterData &)other_p;\n+\t\t\tconst auto &other = other_p.Cast<BindAdapterData>();\n \t\t\treturn BindData::Equals(other_p) && adapters == other.adapters;\n \t\t}\n \n@@ -278,7 +279,7 @@ struct ICUDatePart : public ICUDateFunc {\n \t\tauto &date_arg = args.data[0];\n \n \t\tauto &func_expr = state.expr.Cast<BoundFunctionExpression>();\n-\t\tauto &info = (BIND_TYPE &)*func_expr.bind_info;\n+\t\tauto &info = func_expr.bind_info->Cast<BIND_TYPE>();\n \t\tCalendarPtr calendar_ptr(info.calendar->clone());\n \t\tauto calendar = calendar_ptr.get();\n \n@@ -655,6 +656,8 @@ struct ICUDatePart : public ICUDateFunc {\n \n void RegisterICUDatePartFunctions(ClientContext &context) {\n \t// register the individual operators\n+\n+\t//\tBIGINTs\n \tICUDatePart::AddUnaryPartCodeFunctions(\"era\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"year\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"month\", context);\n@@ -672,12 +675,13 @@ void RegisterICUDatePartFunctions(ClientContext &context) {\n \tICUDatePart::AddUnaryPartCodeFunctions(\"week\", context); //  Note that WeekOperator is ISO-8601, not US\n \tICUDatePart::AddUnaryPartCodeFunctions(\"dayofyear\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"quarter\", context);\n-\tICUDatePart::AddUnaryPartCodeFunctions(\"epoch\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"isoyear\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"timezone\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"timezone_hour\", context);\n \tICUDatePart::AddUnaryPartCodeFunctions(\"timezone_minute\", context);\n \n+\t//\tDOUBLEs\n+\tICUDatePart::AddUnaryPartCodeFunctions<double>(\"epoch\", context, LogicalType::DOUBLE);\n \tICUDatePart::AddUnaryPartCodeFunctions<double>(\"julian\", context, LogicalType::DOUBLE);\n \n \t//  register combinations\ndiff --git a/src/common/enum_util.cpp b/src/common/enum_util.cpp\nindex 2bb218ae6bfc..c75a886b51c5 100644\n--- a/src/common/enum_util.cpp\n+++ b/src/common/enum_util.cpp\n@@ -1196,8 +1196,6 @@ const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value) {\n \t\treturn \"MINUTE\";\n \tcase DatePartSpecifier::HOUR:\n \t\treturn \"HOUR\";\n-\tcase DatePartSpecifier::EPOCH:\n-\t\treturn \"EPOCH\";\n \tcase DatePartSpecifier::DOW:\n \t\treturn \"DOW\";\n \tcase DatePartSpecifier::ISODOW:\n@@ -1220,8 +1218,12 @@ const char* EnumUtil::ToChars<DatePartSpecifier>(DatePartSpecifier value) {\n \t\treturn \"TIMEZONE_HOUR\";\n \tcase DatePartSpecifier::TIMEZONE_MINUTE:\n \t\treturn \"TIMEZONE_MINUTE\";\n+\tcase DatePartSpecifier::EPOCH:\n+\t\treturn \"EPOCH\";\n \tcase DatePartSpecifier::JULIAN_DAY:\n \t\treturn \"JULIAN_DAY\";\n+\tcase DatePartSpecifier::INVALID:\n+\t\treturn \"INVALID\";\n \tdefault:\n \t\tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%d' not implemented\", value));\n \t}\n@@ -1262,9 +1264,6 @@ DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value) {\n \tif (StringUtil::Equals(value, \"HOUR\")) {\n \t\treturn DatePartSpecifier::HOUR;\n \t}\n-\tif (StringUtil::Equals(value, \"EPOCH\")) {\n-\t\treturn DatePartSpecifier::EPOCH;\n-\t}\n \tif (StringUtil::Equals(value, \"DOW\")) {\n \t\treturn DatePartSpecifier::DOW;\n \t}\n@@ -1298,9 +1297,15 @@ DatePartSpecifier EnumUtil::FromString<DatePartSpecifier>(const char *value) {\n \tif (StringUtil::Equals(value, \"TIMEZONE_MINUTE\")) {\n \t\treturn DatePartSpecifier::TIMEZONE_MINUTE;\n \t}\n+\tif (StringUtil::Equals(value, \"EPOCH\")) {\n+\t\treturn DatePartSpecifier::EPOCH;\n+\t}\n \tif (StringUtil::Equals(value, \"JULIAN_DAY\")) {\n \t\treturn DatePartSpecifier::JULIAN_DAY;\n \t}\n+\tif (StringUtil::Equals(value, \"INVALID\")) {\n+\t\treturn DatePartSpecifier::INVALID;\n+\t}\n \tthrow NotImplementedException(StringUtil::Format(\"Enum value: '%s' not implemented\", value));\n }\n \ndiff --git a/src/core_functions/scalar/date/date_part.cpp b/src/core_functions/scalar/date/date_part.cpp\nindex 0e11a746df23..527bba1f8123 100644\n--- a/src/core_functions/scalar/date/date_part.cpp\n+++ b/src/core_functions/scalar/date/date_part.cpp\n@@ -35,6 +35,7 @@ DatePartSpecifier GetDateTypePartSpecifier(const string &specifier, LogicalType\n \t\tcase DatePartSpecifier::DOY:\n \t\tcase DatePartSpecifier::YEARWEEK:\n \t\tcase DatePartSpecifier::ERA:\n+\t\tcase DatePartSpecifier::EPOCH:\n \t\tcase DatePartSpecifier::JULIAN_DAY:\n \t\t\treturn part;\n \t\tdefault:\n@@ -465,7 +466,7 @@ struct DatePart {\n \n \t\ttemplate <class T>\n \t\tstatic unique_ptr<BaseStatistics> PropagateStatistics(ClientContext &context, FunctionStatisticsInput &input) {\n-\t\t\treturn PropagateDatePartStatistics<T, EpochOperator>(input.child_stats);\n+\t\t\treturn PropagateDatePartStatistics<T, EpochOperator, double>(input.child_stats, LogicalType::DOUBLE);\n \t\t}\n \t};\n \n@@ -574,6 +575,8 @@ struct DatePart {\n \t\t\t\tcase DatePartSpecifier::TIMEZONE_MINUTE:\n \t\t\t\t\tmask |= ZONE;\n \t\t\t\t\tbreak;\n+\t\t\t\tcase DatePartSpecifier::INVALID:\n+\t\t\t\t\tthrow InternalException(\"Invalid DatePartSpecifier for STRUCT mask!\");\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn mask;\n@@ -581,12 +584,11 @@ struct DatePart {\n \n \t\ttemplate <typename P>\n \t\tstatic inline P HasPartValue(vector<P> part_values, DatePartSpecifier part) {\n-\t\t\tstatic const auto BEGIN_DOUBLE = size_t(DatePartSpecifier::JULIAN_DAY);\n \t\t\tauto idx = size_t(part);\n \t\t\tif (IsBigintDatepart(part)) {\n-\t\t\t\treturn part_values[idx];\n+\t\t\t\treturn part_values[idx - size_t(DatePartSpecifier::BEGIN_BIGINT)];\n \t\t\t} else {\n-\t\t\t\treturn part_values[idx - BEGIN_DOUBLE];\n+\t\t\t\treturn part_values[idx - size_t(DatePartSpecifier::BEGIN_DOUBLE)];\n \t\t\t}\n \t\t}\n \n@@ -670,9 +672,9 @@ struct DatePart {\n \t\t\t}\n \n \t\t\tif (mask & EPOCH) {\n-\t\t\t\tbigint_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n-\t\t\t\tif (bigint_data) {\n-\t\t\t\t\tbigint_data[idx] = Date::Epoch(input);\n+\t\t\t\tauto double_data = HasPartValue(double_values, DatePartSpecifier::EPOCH);\n+\t\t\t\tif (double_data) {\n+\t\t\t\t\tdouble_data[idx] = Date::Epoch(input);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (mask & DOY) {\n@@ -1016,12 +1018,12 @@ int64_t DatePart::HoursOperator::Operation(dtime_t input) {\n }\n \n template <>\n-int64_t DatePart::EpochOperator::Operation(timestamp_t input) {\n-\treturn Timestamp::GetEpochSeconds(input);\n+double DatePart::EpochOperator::Operation(timestamp_t input) {\n+\treturn Timestamp::GetEpochMicroSeconds(input) / double(Interval::MICROS_PER_SEC);\n }\n \n template <>\n-int64_t DatePart::EpochOperator::Operation(interval_t input) {\n+double DatePart::EpochOperator::Operation(interval_t input) {\n \tint64_t interval_years = input.months / Interval::MONTHS_PER_YEAR;\n \tint64_t interval_days;\n \tinterval_days = Interval::DAYS_PER_YEAR * interval_years;\n@@ -1031,20 +1033,29 @@ int64_t DatePart::EpochOperator::Operation(interval_t input) {\n \tinterval_epoch = interval_days * Interval::SECS_PER_DAY;\n \t// we add 0.25 days per year to sort of account for leap days\n \tinterval_epoch += interval_years * (Interval::SECS_PER_DAY / 4);\n-\tinterval_epoch += input.micros / Interval::MICROS_PER_SEC;\n-\treturn interval_epoch;\n+\treturn interval_epoch + input.micros / double(Interval::MICROS_PER_SEC);\n+}\n+\n+//\tTODO: We can't propagate interval statistics because we can't easily compare interval_t for order.\n+template <>\n+unique_ptr<BaseStatistics> DatePart::EpochOperator::PropagateStatistics<interval_t>(ClientContext &context,\n+                                                                                    FunctionStatisticsInput &input) {\n+\treturn nullptr;\n }\n \n template <>\n-int64_t DatePart::EpochOperator::Operation(dtime_t input) {\n-\treturn input.micros / Interval::MICROS_PER_SEC;\n+double DatePart::EpochOperator::Operation(dtime_t input) {\n+\treturn input.micros / double(Interval::MICROS_PER_SEC);\n }\n \n template <>\n unique_ptr<BaseStatistics> DatePart::EpochOperator::PropagateStatistics<dtime_t>(ClientContext &context,\n                                                                                  FunctionStatisticsInput &input) {\n-\t// time seconds range over a single day\n-\treturn PropagateSimpleDatePartStatistics<0, 86400>(input.child_stats);\n+\tauto result = NumericStats::CreateEmpty(LogicalType::DOUBLE);\n+\tresult.CopyValidity(input.child_stats[0]);\n+\tNumericStats::SetMin(result, Value::DOUBLE(0));\n+\tNumericStats::SetMax(result, Value::DOUBLE(Interval::SECS_PER_DAY));\n+\treturn result.ToUnique();\n }\n \n template <>\n@@ -1121,9 +1132,9 @@ void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &\n \t}\n \n \tif (mask & EPOCH) {\n-\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n+\t\tauto part_data = HasPartValue(double_values, DatePartSpecifier::EPOCH);\n \t\tif (part_data) {\n-\t\t\tpart_data[idx] = EpochOperator::Operation<dtime_t, int64_t>(input);\n+\t\t\tpart_data[idx] = EpochOperator::Operation<dtime_t, double>(input);\n \t\t\t;\n \t\t}\n \t}\n@@ -1157,9 +1168,9 @@ void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &\n \tOperation(bigint_values, double_values, t, idx, mask & ~EPOCH);\n \n \tif (mask & EPOCH) {\n-\t\tauto part_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n+\t\tauto part_data = HasPartValue(double_values, DatePartSpecifier::EPOCH);\n \t\tif (part_data) {\n-\t\t\tpart_data[idx] = EpochOperator::Operation<timestamp_t, int64_t>(input);\n+\t\t\tpart_data[idx] = EpochOperator::Operation<timestamp_t, double>(input);\n \t\t}\n \t}\n \n@@ -1232,9 +1243,9 @@ void DatePart::StructOperator::Operation(bigint_vec &bigint_values, double_vec &\n \t}\n \n \tif (mask & EPOCH) {\n-\t\tpart_data = HasPartValue(bigint_values, DatePartSpecifier::EPOCH);\n+\t\tauto part_data = HasPartValue(double_values, DatePartSpecifier::EPOCH);\n \t\tif (part_data) {\n-\t\t\tpart_data[idx] = EpochOperator::Operation<interval_t, int64_t>(input);\n+\t\t\tpart_data[idx] = EpochOperator::Operation<interval_t, double>(input);\n \t\t}\n \t}\n }\n@@ -1268,8 +1279,6 @@ static int64_t ExtractElement(DatePartSpecifier type, T element) {\n \t\treturn DatePart::ISOYearOperator::template Operation<T, int64_t>(element);\n \tcase DatePartSpecifier::YEARWEEK:\n \t\treturn DatePart::YearWeekOperator::template Operation<T, int64_t>(element);\n-\tcase DatePartSpecifier::EPOCH:\n-\t\treturn DatePart::EpochOperator::template Operation<T, int64_t>(element);\n \tcase DatePartSpecifier::MICROSECONDS:\n \t\treturn DatePart::MicrosecondsOperator::template Operation<T, int64_t>(element);\n \tcase DatePartSpecifier::MILLISECONDS:\n@@ -1340,6 +1349,32 @@ static unique_ptr<FunctionData> DatePartBind(ClientContext &context, ScalarFunct\n \t\t\tthrow BinderException(\"%s can only take DATE or TIMESTAMP arguments\", bound_function.name);\n \t\t}\n \t\tbreak;\n+\tcase DatePartSpecifier::EPOCH:\n+\t\targuments.erase(arguments.begin());\n+\t\tbound_function.arguments.erase(bound_function.arguments.begin());\n+\t\tbound_function.name = \"epoch\";\n+\t\tbound_function.return_type = LogicalType::DOUBLE;\n+\t\tswitch (arguments[0]->return_type.id()) {\n+\t\tcase LogicalType::TIMESTAMP:\n+\t\t\tbound_function.function = DatePart::UnaryFunction<timestamp_t, double, DatePart::EpochOperator>;\n+\t\t\tbound_function.statistics = DatePart::EpochOperator::template PropagateStatistics<timestamp_t>;\n+\t\t\tbreak;\n+\t\tcase LogicalType::DATE:\n+\t\t\tbound_function.function = DatePart::UnaryFunction<date_t, double, DatePart::EpochOperator>;\n+\t\t\tbound_function.statistics = DatePart::EpochOperator::template PropagateStatistics<date_t>;\n+\t\t\tbreak;\n+\t\tcase LogicalType::INTERVAL:\n+\t\t\tbound_function.function = DatePart::UnaryFunction<interval_t, double, DatePart::EpochOperator>;\n+\t\t\tbound_function.statistics = DatePart::EpochOperator::template PropagateStatistics<interval_t>;\n+\t\t\tbreak;\n+\t\tcase LogicalType::TIME:\n+\t\t\tbound_function.function = DatePart::UnaryFunction<dtime_t, double, DatePart::EpochOperator>;\n+\t\t\tbound_function.statistics = DatePart::EpochOperator::template PropagateStatistics<dtime_t>;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow BinderException(\"%s can only take temporal arguments\", bound_function.name);\n+\t\t}\n+\t\tbreak;\n \tdefault:\n \t\tbreak;\n \t}\n@@ -1367,26 +1402,26 @@ static ScalarFunctionSet GetDatePartFunction() {\n \t    OP::template PropagateStatistics<timestamp_t>);\n }\n \n-ScalarFunctionSet GetGenericTimePartFunction(scalar_function_t date_func, scalar_function_t ts_func,\n-                                             scalar_function_t interval_func, scalar_function_t time_func,\n-                                             function_statistics_t date_stats, function_statistics_t ts_stats,\n-                                             function_statistics_t time_stats) {\n+ScalarFunctionSet GetGenericTimePartFunction(const LogicalType &result_type, scalar_function_t date_func,\n+                                             scalar_function_t ts_func, scalar_function_t interval_func,\n+                                             scalar_function_t time_func, function_statistics_t date_stats,\n+                                             function_statistics_t ts_stats, function_statistics_t time_stats) {\n \tScalarFunctionSet operator_set;\n \toperator_set.AddFunction(\n-\t    ScalarFunction({LogicalType::DATE}, LogicalType::BIGINT, std::move(date_func), nullptr, nullptr, date_stats));\n+\t    ScalarFunction({LogicalType::DATE}, result_type, std::move(date_func), nullptr, nullptr, date_stats));\n \toperator_set.AddFunction(\n-\t    ScalarFunction({LogicalType::TIMESTAMP}, LogicalType::BIGINT, std::move(ts_func), nullptr, nullptr, ts_stats));\n-\toperator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, LogicalType::BIGINT, std::move(interval_func)));\n+\t    ScalarFunction({LogicalType::TIMESTAMP}, result_type, std::move(ts_func), nullptr, nullptr, ts_stats));\n+\toperator_set.AddFunction(ScalarFunction({LogicalType::INTERVAL}, result_type, std::move(interval_func)));\n \toperator_set.AddFunction(\n-\t    ScalarFunction({LogicalType::TIME}, LogicalType::BIGINT, std::move(time_func), nullptr, nullptr, time_stats));\n+\t    ScalarFunction({LogicalType::TIME}, result_type, std::move(time_func), nullptr, nullptr, time_stats));\n \treturn operator_set;\n }\n \n-template <class OP>\n-static ScalarFunctionSet GetTimePartFunction() {\n+template <class OP, class TR = int64_t>\n+static ScalarFunctionSet GetTimePartFunction(const LogicalType &result_type = LogicalType::BIGINT) {\n \treturn GetGenericTimePartFunction(\n-\t    DatePart::UnaryFunction<date_t, int64_t, OP>, DatePart::UnaryFunction<timestamp_t, int64_t, OP>,\n-\t    ScalarFunction::UnaryFunction<interval_t, int64_t, OP>, ScalarFunction::UnaryFunction<dtime_t, int64_t, OP>,\n+\t    result_type, DatePart::UnaryFunction<date_t, TR, OP>, DatePart::UnaryFunction<timestamp_t, TR, OP>,\n+\t    ScalarFunction::UnaryFunction<interval_t, TR, OP>, ScalarFunction::UnaryFunction<dtime_t, TR, OP>,\n \t    OP::template PropagateStatistics<date_t>, OP::template PropagateStatistics<timestamp_t>,\n \t    OP::template PropagateStatistics<dtime_t>);\n }\n@@ -1425,10 +1460,6 @@ struct DayNameOperator {\n struct StructDatePart {\n \tusing part_codes_t = vector<DatePartSpecifier>;\n \n-\tstatic const auto BEGIN_BIGINT = size_t(DatePartSpecifier::YEAR);\n-\tstatic const auto BEGIN_DOUBLE = size_t(DatePartSpecifier::JULIAN_DAY);\n-\tstatic const auto BEGIN_INVALID = size_t(DatePartSpecifier::JULIAN_DAY) + 1;\n-\n \tstruct BindData : public VariableReturnBindData {\n \t\tpart_codes_t part_codes;\n \n@@ -1492,8 +1523,12 @@ struct StructDatePart {\n \n \t\tconst auto count = args.size();\n \t\tVector &input = args.data[0];\n-\t\tDatePart::StructOperator::bigint_vec bigint_values(size_t(BEGIN_DOUBLE), nullptr);\n-\t\tDatePart::StructOperator::double_vec double_values(BEGIN_INVALID - size_t(BEGIN_DOUBLE), nullptr);\n+\n+\t\t//\tType counts\n+\t\tconst auto BIGINT_COUNT = size_t(DatePartSpecifier::BEGIN_DOUBLE) - size_t(DatePartSpecifier::BEGIN_BIGINT);\n+\t\tconst auto DOUBLE_COUNT = size_t(DatePartSpecifier::BEGIN_INVALID) - size_t(DatePartSpecifier::BEGIN_DOUBLE);\n+\t\tDatePart::StructOperator::bigint_vec bigint_values(BIGINT_COUNT, nullptr);\n+\t\tDatePart::StructOperator::double_vec double_values(DOUBLE_COUNT, nullptr);\n \t\tconst auto part_mask = DatePart::StructOperator::GetMask(info.part_codes);\n \n \t\tauto &child_entries = StructVector::GetEntries(result);\n@@ -1521,9 +1556,11 @@ struct StructDatePart {\n \t\t\t\t\tconst auto part_index = size_t(info.part_codes[col]);\n \t\t\t\t\tif (owners[part_index] == col) {\n \t\t\t\t\t\tif (IsBigintDatepart(info.part_codes[col])) {\n-\t\t\t\t\t\t\tbigint_values[part_index - BEGIN_BIGINT] = ConstantVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t\t\tbigint_values[part_index - size_t(DatePartSpecifier::BEGIN_BIGINT)] =\n+\t\t\t\t\t\t\t    ConstantVector::GetData<int64_t>(*child_entry);\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tdouble_values[part_index - BEGIN_DOUBLE] = ConstantVector::GetData<double>(*child_entry);\n+\t\t\t\t\t\t\tdouble_values[part_index - size_t(DatePartSpecifier::BEGIN_DOUBLE)] =\n+\t\t\t\t\t\t\t    ConstantVector::GetData<double>(*child_entry);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -1563,9 +1600,11 @@ struct StructDatePart {\n \t\t\t\tconst auto part_index = size_t(info.part_codes[col]);\n \t\t\t\tif (owners[part_index] == col) {\n \t\t\t\t\tif (IsBigintDatepart(info.part_codes[col])) {\n-\t\t\t\t\t\tbigint_values[part_index - BEGIN_BIGINT] = FlatVector::GetData<int64_t>(*child_entry);\n+\t\t\t\t\t\tbigint_values[part_index - size_t(DatePartSpecifier::BEGIN_BIGINT)] =\n+\t\t\t\t\t\t    FlatVector::GetData<int64_t>(*child_entry);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tdouble_values[part_index - BEGIN_DOUBLE] = FlatVector::GetData<double>(*child_entry);\n+\t\t\t\t\t\tdouble_values[part_index - size_t(DatePartSpecifier::BEGIN_DOUBLE)] =\n+\t\t\t\t\t\t    FlatVector::GetData<double>(*child_entry);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -1694,7 +1733,7 @@ ScalarFunctionSet TimezoneMinuteFun::GetFunctions() {\n }\n \n ScalarFunctionSet EpochFun::GetFunctions() {\n-\treturn GetTimePartFunction<DatePart::EpochOperator>();\n+\treturn GetTimePartFunction<DatePart::EpochOperator, double>(LogicalType::DOUBLE);\n }\n \n ScalarFunctionSet EpochNsFun::GetFunctions() {\ndiff --git a/src/include/duckdb/common/enums/date_part_specifier.hpp b/src/include/duckdb/common/enums/date_part_specifier.hpp\nindex fc0f243139c7..54e2790e1e0e 100644\n--- a/src/include/duckdb/common/enums/date_part_specifier.hpp\n+++ b/src/include/duckdb/common/enums/date_part_specifier.hpp\n@@ -25,7 +25,6 @@ enum class DatePartSpecifier : uint8_t {\n \tSECOND,\n \tMINUTE,\n \tHOUR,\n-\tEPOCH,\n \tDOW,\n \tISODOW,\n \tWEEK,\n@@ -39,11 +38,20 @@ enum class DatePartSpecifier : uint8_t {\n \tTIMEZONE_MINUTE,\n \n \t//\tDOUBLE values\n-\tJULIAN_DAY\n+\tEPOCH,\n+\tJULIAN_DAY,\n+\n+\t//\tInvalid\n+\tINVALID,\n+\n+\t//\tType ranges\n+\tBEGIN_BIGINT = YEAR,\n+\tBEGIN_DOUBLE = EPOCH,\n+\tBEGIN_INVALID = INVALID,\n };\n \n inline bool IsBigintDatepart(DatePartSpecifier part_code) {\n-\treturn size_t(part_code) < size_t(DatePartSpecifier::JULIAN_DAY);\n+\treturn size_t(part_code) < size_t(DatePartSpecifier::BEGIN_DOUBLE);\n }\n \n DUCKDB_API bool TryGetDatePartSpecifier(const string &specifier, DatePartSpecifier &result);\ndiff --git a/src/optimizer/rule/date_part_simplification.cpp b/src/optimizer/rule/date_part_simplification.cpp\nindex adff8e010453..037e7a6354ff 100644\n--- a/src/optimizer/rule/date_part_simplification.cpp\n+++ b/src/optimizer/rule/date_part_simplification.cpp\n@@ -70,9 +70,6 @@ unique_ptr<Expression> DatePartSimplificationRule::Apply(LogicalOperator &op, ve\n \tcase DatePartSpecifier::DOY:\n \t\tnew_function_name = \"dayofyear\";\n \t\tbreak;\n-\tcase DatePartSpecifier::EPOCH:\n-\t\tnew_function_name = \"epoch\";\n-\t\tbreak;\n \tcase DatePartSpecifier::MICROSECONDS:\n \t\tnew_function_name = \"microsecond\";\n \t\tbreak;\n",
  "test_patch": "diff --git a/test/sql/function/date/test_date_part.test b/test/sql/function/date/test_date_part.test\nindex b3738b8bd03d..70d51938b8ac 100644\n--- a/test/sql/function/date/test_date_part.test\n+++ b/test/sql/function/date/test_date_part.test\n@@ -463,18 +463,18 @@ endloop\n \n # Date parts\n query II\n-SELECT d, DATE_PART(['year', 'month', 'day'], d) AS parts\n+SELECT d, DATE_PART(['year', 'month', 'day', 'epoch'], d) AS parts\n FROM dates\n ORDER BY 1;\n ----\n NULL\tNULL\n--infinity\t{'year': NULL, 'month': NULL, 'day': NULL}\n-0044-03-15 (BC)\t{'year': -43, 'month': 3, 'day': 15}\n-1992-01-01\t{'year': 1992, 'month': 1, 'day': 1}\n-1992-03-03\t{'year': 1992, 'month': 3, 'day': 3}\n-1992-05-05\t{'year': 1992, 'month': 5, 'day': 5}\n-2022-01-01\t{'year': 2022, 'month': 1, 'day': 1}\n-infinity\t{'year': NULL, 'month': NULL, 'day': NULL}\n+-infinity\t{'year': NULL, 'month': NULL, 'day': NULL, 'epoch': NULL}\n+0044-03-15 (BC)\t{'year': -43, 'month': 3, 'day': 15, 'epoch': -63517824000.0}\n+1992-01-01\t{'year': 1992, 'month': 1, 'day': 1, 'epoch': 694224000.0}\n+1992-03-03\t{'year': 1992, 'month': 3, 'day': 3, 'epoch': 699580800.0}\n+1992-05-05\t{'year': 1992, 'month': 5, 'day': 5, 'epoch': 705024000.0}\n+2022-01-01\t{'year': 2022, 'month': 1, 'day': 1, 'epoch': 1640995200.0}\n+infinity\t{'year': NULL, 'month': NULL, 'day': NULL, 'epoch': NULL}\n \n # Year parts\n query II\n@@ -546,6 +546,11 @@ ORDER BY 1;\n \n endloop\n \n+statement error\n+SELECT DATE_PART(['hour', 'minute'], '2023-09-17'::DATE) AS parts\n+----\n+not recognized\n+\n #\n # Infinities\n #\n@@ -573,6 +578,12 @@ NULL\n \n endloop\n \n+# Struct entries should be NULL\n+query I\n+SELECT DATE_PART(['year', 'month', 'day', 'epoch'], '${special}'::${datatype}) AS parts\n+----\n+{'year': NULL, 'month': NULL, 'day': NULL, 'epoch': NULL}\n+\n endloop\n \n endloop\ndiff --git a/test/sql/function/interval/test_date_part.test b/test/sql/function/interval/test_date_part.test\nindex 14847483521f..db2f7c8abedd 100644\n--- a/test/sql/function/interval/test_date_part.test\n+++ b/test/sql/function/interval/test_date_part.test\n@@ -158,10 +158,10 @@ SELECT i, DATE_PART(['hour', 'minute', 'second', 'epoch'], i) AS parts\n FROM intervals\n ORDER BY 1;\n ----\n-00:34:26.3434\t{'hour': 0, 'minute': 34, 'second': 26, 'epoch': 2066}\n-42 days\t{'hour': 0, 'minute': 0, 'second': 0, 'epoch': 3628800}\n-1 year 4 months\t{'hour': 0, 'minute': 0, 'second': 0, 'epoch': 41925600}\n-2 years\t{'hour': 0, 'minute': 0, 'second': 0, 'epoch': 63115200}\n+00:34:26.3434\t{'hour': 0, 'minute': 34, 'second': 26, 'epoch': 2066.3434}\n+42 days\t{'hour': 0, 'minute': 0, 'second': 0, 'epoch': 3628800.0}\n+1 year 4 months\t{'hour': 0, 'minute': 0, 'second': 0, 'epoch': 41925600.0}\n+2 years\t{'hour': 0, 'minute': 0, 'second': 0, 'epoch': 63115200.0}\n \n # Function-only parts\n query II\ndiff --git a/test/sql/function/time/test_date_part.test b/test/sql/function/time/test_date_part.test\nindex 121461fdf9ba..266f34f60268 100644\n--- a/test/sql/function/time/test_date_part.test\n+++ b/test/sql/function/time/test_date_part.test\n@@ -183,10 +183,10 @@ SELECT d, DATE_PART(['epoch', 'second', 'timezone', 'timezone_hour', 'timezone_m\n FROM times\n ORDER BY 1;\n ----\n-00:01:20\t{'epoch': 80, 'second': 20, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-20:08:10.001\t{'epoch': 72490, 'second': 10, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-20:08:10.33\t{'epoch': 72490, 'second': 10, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-20:08:10.998\t{'epoch': 72490, 'second': 10, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+00:01:20\t{'epoch': 80.0, 'second': 20, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+20:08:10.001\t{'epoch': 72490.001, 'second': 10, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+20:08:10.33\t{'epoch': 72490.33, 'second': 10, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+20:08:10.998\t{'epoch': 72490.998, 'second': 10, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n \n # Function-only parts\n query II\ndiff --git a/test/sql/function/timestamp/test_date_part.test b/test/sql/function/timestamp/test_date_part.test\nindex fc68f3445d83..461b67c868d5 100644\n--- a/test/sql/function/timestamp/test_date_part.test\n+++ b/test/sql/function/timestamp/test_date_part.test\n@@ -482,37 +482,37 @@ ORDER BY 1;\n ----\n NULL\tNULL\n -infinity\t{'epoch': NULL, 'timezone': NULL, 'timezone_hour': NULL, 'timezone_minute': NULL}\n-1962-07-31 12:20:48.123456\t{'epoch': -234185951, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1969-01-01 01:03:20.45432\t{'epoch': -31532199, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1992-01-01 01:01:01.4\t{'epoch': 694227661, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1992-01-01 01:01:02.2\t{'epoch': 694227662, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1992-01-01 01:01:02.4\t{'epoch': 694227662, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1993-08-14 08:22:33\t{'epoch': 745316553, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1993-08-14 08:22:33.42\t{'epoch': 745316553, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2001-04-20 14:42:11\t{'epoch': 987777731, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2001-04-20 14:42:11.123\t{'epoch': 987777731, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2004-01-31 12:00:00.00005\t{'epoch': 1075550400, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2004-01-31 12:00:00.05\t{'epoch': 1075550400, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2004-02-01 12:00:00.00005\t{'epoch': 1075636800, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2004-02-01 12:00:00.05\t{'epoch': 1075636800, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2004-02-29 13:05:47.123456\t{'epoch': 1078059947, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.5\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.594\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.794\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.88926\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.894\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.98926\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:01.99926\t{'epoch': 1199145601, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2008-01-01 00:00:11.1\t{'epoch': 1199145611, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2019-01-06 04:03:02.123456\t{'epoch': 1546747382, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2019-01-06 04:03:02.5\t{'epoch': 1546747382, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2020-01-01 00:00:01.88926\t{'epoch': 1577836801, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2020-12-31 21:25:58.745232\t{'epoch': 1609449958, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2021-04-15 14:55:17.915\t{'epoch': 1618498517, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2021-04-15 14:55:17.915\t{'epoch': 1618498517, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2021-05-02 12:11:49.5\t{'epoch': 1619957509, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2021-12-01 13:54:48.123456\t{'epoch': 1638366888, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2022-01-01 00:00:41\t{'epoch': 1640995241, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1962-07-31 12:20:48.123456\t{'epoch': -234185951.876544, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1969-01-01 01:03:20.45432\t{'epoch': -31532199.54568, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1992-01-01 01:01:01.4\t{'epoch': 694227661.4, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1992-01-01 01:01:02.2\t{'epoch': 694227662.2, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1992-01-01 01:01:02.4\t{'epoch': 694227662.4, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1993-08-14 08:22:33\t{'epoch': 745316553.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1993-08-14 08:22:33.42\t{'epoch': 745316553.42, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2001-04-20 14:42:11\t{'epoch': 987777731.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2001-04-20 14:42:11.123\t{'epoch': 987777731.123, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2004-01-31 12:00:00.00005\t{'epoch': 1075550400.00005, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2004-01-31 12:00:00.05\t{'epoch': 1075550400.05, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2004-02-01 12:00:00.00005\t{'epoch': 1075636800.00005, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2004-02-01 12:00:00.05\t{'epoch': 1075636800.05, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2004-02-29 13:05:47.123456\t{'epoch': 1078059947.123456, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.5\t{'epoch': 1199145601.5, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.594\t{'epoch': 1199145601.594, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.794\t{'epoch': 1199145601.794, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.88926\t{'epoch': 1199145601.88926, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.894\t{'epoch': 1199145601.894, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.98926\t{'epoch': 1199145601.98926, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:01.99926\t{'epoch': 1199145601.99926, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2008-01-01 00:00:11.1\t{'epoch': 1199145611.1, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2019-01-06 04:03:02.123456\t{'epoch': 1546747382.123456, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2019-01-06 04:03:02.5\t{'epoch': 1546747382.5, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2020-01-01 00:00:01.88926\t{'epoch': 1577836801.88926, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2020-12-31 21:25:58.745232\t{'epoch': 1609449958.745232, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2021-04-15 14:55:17.915\t{'epoch': 1618498517.915, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2021-04-15 14:55:17.915\t{'epoch': 1618498517.915, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2021-05-02 12:11:49.5\t{'epoch': 1619957509.5, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2021-12-01 13:54:48.123456\t{'epoch': 1638366888.123456, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2022-01-01 00:00:41\t{'epoch': 1640995241.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n infinity\t{'epoch': NULL, 'timezone': NULL, 'timezone_hour': NULL, 'timezone_minute': NULL}\n \n query II\n@@ -520,11 +520,11 @@ SELECT ts, DATE_PART(['epoch', 'timezone', 'timezone_hour', 'timezone_minute'],\n FROM millennia\n ORDER BY 1;\n ----\n-1001-03-15 (BC) 20:38:40\t{'epoch': -93717746480, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-0044-03-15 (BC) 20:38:40\t{'epoch': -63517749680, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-0998-02-16 20:38:40\t{'epoch': -30669247280, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-1998-02-16 20:38:40\t{'epoch': 887661520, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n-2001-02-16 20:38:40\t{'epoch': 982355920, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1001-03-15 (BC) 20:38:40\t{'epoch': -93717746480.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+0044-03-15 (BC) 20:38:40\t{'epoch': -63517749680.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+0998-02-16 20:38:40\t{'epoch': -30669247280.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+1998-02-16 20:38:40\t{'epoch': 887661520.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n+2001-02-16 20:38:40\t{'epoch': 982355920.0, 'timezone': 0, 'timezone_hour': 0, 'timezone_minute': 0}\n \n query I\n SELECT DATE_PART(['hour', 'minute', 'microsecond'], NULL::TIMESTAMP);\ndiff --git a/test/sql/function/timestamp/test_icu_datepart.test b/test/sql/function/timestamp/test_icu_datepart.test\nindex 5bff05fc45bd..ca09a0f3e48b 100644\n--- a/test/sql/function/timestamp/test_icu_datepart.test\n+++ b/test/sql/function/timestamp/test_icu_datepart.test\n@@ -119,7 +119,6 @@ NULL\tNULL\n NULL\tNULL\n NULL\tNULL\n \n-# ICU loses accuracy far from the epoch\n query II\n SELECT microsecond(ts), microsecond(ts::TIMESTAMP) FROM timestamps;\n ----\n@@ -328,23 +327,24 @@ NULL\tNULL\n query II\n SELECT epoch(ts), epoch(ts::TIMESTAMP) FROM timestamps;\n ----\n--63517962378\t-63517990756\n--234185951\t-234211151\n-1609459200\t1609430400\n-1612224000\t1612195200\n-1637921713\t1637892913\n-1636972200\t1636943400\n-1636968600\t1636939800\n-1640383200\t1640354400\n+-63517962378.012344\t-63517990756.012344\n+-234185951.876544\t-234211151.876544\n+1609459200.0\t1609430400.0\n+1612224000.0\t1612195200.0\n+1637921713.123456\t1637892913.123456\n+1636972200.0\t1636943400.0\n+1636968600.0\t1636939800.0\n+1640383200.0\t1640354400.0\n NULL\tNULL\n NULL\tNULL\n NULL\tNULL\n \n query III\n-SELECT date_part(part, ts), date_part(part, ts::TIMESTAMP), part FROM timestamps;\n+SELECT date_part(part, ts), date_part(part, ts::TIMESTAMP), part \n+FROM timestamps\n+WHERE part NOT IN ('epoch', 'julian')\n ----\n 0\t0\tera\n--234185951\t-234211151\tepoch\n 2020\t2020\tyear\n 2\t2\tmonth\n 13123456\t13123456\tmicrosecond\n@@ -665,14 +665,14 @@ ORDER BY 2\n ----\n NULL\tNULL\n {'epoch': NULL, 'second': NULL, 'timezone': NULL, 'timezone_hour': NULL, 'timezone_minute': NULL}\t-infinity\n-{'epoch': -63517962378, 'second': 43, 'timezone': -28378, 'timezone_hour': -7, 'timezone_minute': -52}\t0044-03-13 (BC) 01:40:43.987654-07:52\n-{'epoch': -234185951, 'second': 48, 'timezone': -25200, 'timezone_hour': -7, 'timezone_minute': 0}\t1962-07-31 05:20:48.123456-07\n-{'epoch': 1609459200, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2020-12-31 16:00:00-08\n-{'epoch': 1612224000, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-02-01 16:00:00-08\n-{'epoch': 1636968600, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-11-15 01:30:00-08\n-{'epoch': 1636972200, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-11-15 02:30:00-08\n-{'epoch': 1637921713, 'second': 13, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-11-26 02:15:13.123456-08\n-{'epoch': 1640383200, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-12-24 14:00:00-08\n+{'epoch': -63517962378.012344, 'second': 43, 'timezone': -28378, 'timezone_hour': -7, 'timezone_minute': -52}\t0044-03-13 (BC) 01:40:43.987654-07:52\n+{'epoch': -234185951.876544, 'second': 48, 'timezone': -25200, 'timezone_hour': -7, 'timezone_minute': 0}\t1962-07-31 05:20:48.123456-07\n+{'epoch': 1609459200.0, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2020-12-31 16:00:00-08\n+{'epoch': 1612224000.0, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-02-01 16:00:00-08\n+{'epoch': 1636968600.0, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-11-15 01:30:00-08\n+{'epoch': 1636972200.0, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-11-15 02:30:00-08\n+{'epoch': 1637921713.123456, 'second': 13, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-11-26 02:15:13.123456-08\n+{'epoch': 1640383200.0, 'second': 0, 'timezone': -28800, 'timezone_hour': -8, 'timezone_minute': 0}\t2021-12-24 14:00:00-08\n {'epoch': NULL, 'second': NULL, 'timezone': NULL, 'timezone_hour': NULL, 'timezone_minute': NULL}\tinfinity\n \n # Correctness: Compare struct values with scalar values\ndiff --git a/test/sql/table_function/range_non_foldable.test b/test/sql/table_function/range_non_foldable.test\nindex 75db281ebe1c..131e5e570b63 100644\n--- a/test/sql/table_function/range_non_foldable.test\n+++ b/test/sql/table_function/range_non_foldable.test\n@@ -18,15 +18,15 @@ FROM range(\n statement ok\n SELECT to_timestamp(range) as entry\n     FROM range(\n-      epoch(date_trunc('month', current_date)),\n-      epoch(date_trunc('month', current_date) + interval '1 month' - interval '1 day'),\n-      epoch(interval '1 day')\n+      epoch(date_trunc('month', current_date))::BIGINT,\n+      epoch(date_trunc('month', current_date) + interval '1 month' - interval '1 day')::BIGINT,\n+      epoch(interval '1 day')::BIGINT\n     )\n \n statement ok\n SELECT to_timestamp(range) as entry\n FROM range(\n-  epoch(date_trunc('month', current_date)),\n-  epoch(date_trunc('month', current_date) + interval '1 month' - interval '1 day'),\n-  epoch(interval '1 day')\n+  epoch(date_trunc('month', current_date))::BIGINT,\n+  epoch(date_trunc('month', current_date) + interval '1 month' - interval '1 day')::BIGINT,\n+  epoch(interval '1 day')::BIGINT\n )\n",
  "problem_statement": "EPOCH FROM 'TIMESTAMP with milliseconds' drops millisecond output\n### What happens?\n\nThe milliseconds portion of the time is dropped when using EPOCH against a timestamp which has milliseconds provided. \r\n\n\n### To Reproduce\n\n`SELECT EXTRACT(EPOCH FROM '2001-02-16 20:38:40.12-08'::TIMESTAMP);`\r\n**Result: 982384720** \r\nShould be: **982384720.120000**\r\n\r\n`SELECT EXTRACT(EPOCH FROM '2001-02-16 20:38:40.12'::TIMESTAMP);`\r\n**Result: 982355920** \r\nShould be: **982355920.120000**\r\n\r\n`SELECT EPOCH('2001-02-16 20:38:40.12'::TIMESTAMP);`\r\n**Result: 982355920**\r\nShould be: **982355920.120000**\r\n\r\nRelated info when comparing to PostgreSQL: https://www.postgresql.org/docs/15/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT under the epoch section.\r\n\r\nAlso \"The extract function returns values of type numeric.\" in PostgreSQL and looks like DuckDB is returning BIGINT.\n\n### OS:\n\nWeb\n\n### DuckDB Version:\n\nDuckDB Web Shell Database: v0.7.2-dev3783\n\n### DuckDB Client:\n\nWeb\n\n### Full Name:\n\nDwayne McMurchy\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "This issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nThis issue was closed because it has been stale for 30 days with no activity.",
  "created_at": "2023-09-16T21:18:48Z",
  "modified_files": [
    "extension/icu/icu-datepart.cpp",
    "src/common/enum_util.cpp",
    "src/core_functions/scalar/date/date_part.cpp",
    "src/include/duckdb/common/enums/date_part_specifier.hpp",
    "src/optimizer/rule/date_part_simplification.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/date/test_date_part.test",
    "test/sql/function/interval/test_date_part.test",
    "test/sql/function/time/test_date_part.test",
    "test/sql/function/timestamp/test_date_part.test",
    "test/sql/function/timestamp/test_icu_datepart.test",
    "test/sql/table_function/range_non_foldable.test"
  ]
}