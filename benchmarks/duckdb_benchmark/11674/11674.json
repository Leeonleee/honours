{
  "repo": "duckdb/duckdb",
  "pull_number": 11674,
  "instance_id": "duckdb__duckdb-11674",
  "issue_numbers": [
    "11484"
  ],
  "base_commit": "5bcfd7434790fabb0ea99998abb78e3a31bad47a",
  "patch": "diff --git a/src/parser/transform/expression/transform_subquery.cpp b/src/parser/transform/expression/transform_subquery.cpp\nindex 33a9b1604bc4..c8dbe23a48c8 100644\n--- a/src/parser/transform/expression/transform_subquery.cpp\n+++ b/src/parser/transform/expression/transform_subquery.cpp\n@@ -2,6 +2,8 @@\n #include \"duckdb/parser/transformer.hpp\"\n #include \"duckdb/parser/query_node/select_node.hpp\"\n #include \"duckdb/parser/tableref/subqueryref.hpp\"\n+#include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/expression/positional_reference_expression.hpp\"\n \n namespace duckdb {\n \n@@ -69,12 +71,28 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \t\tvector<unique_ptr<ParsedExpression>> children;\n \t\tchildren.push_back(std::move(columns_star));\n \t\tauto aggr = make_uniq<FunctionExpression>(\"array_agg\", std::move(children));\n+\t\t// push ORDER BY modifiers into the array_agg\n \t\tfor (auto &modifier : subquery_expr->subquery->node->modifiers) {\n \t\t\tif (modifier->type == ResultModifierType::ORDER_MODIFIER) {\n \t\t\t\taggr->order_bys = unique_ptr_cast<ResultModifier, OrderModifier>(modifier->Copy());\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n+\t\t// transform constants (e.g. ORDER BY 1) into positional references (ORDER BY #1)\n+\t\tif (aggr->order_bys) {\n+\t\t\tfor (auto &order : aggr->order_bys->orders) {\n+\t\t\t\tif (order.expression->type == ExpressionType::VALUE_CONSTANT) {\n+\t\t\t\t\tauto &constant_expr = order.expression->Cast<ConstantExpression>();\n+\t\t\t\t\tValue bigint_value;\n+\t\t\t\t\tstring error;\n+\t\t\t\t\tif (constant_expr.value.DefaultTryCastAs(LogicalType::BIGINT, bigint_value, &error)) {\n+\t\t\t\t\t\tint64_t order_index = BigIntValue::Get(bigint_value);\n+\t\t\t\t\t\tidx_t positional_index = order_index < 0 ? NumericLimits<idx_t>::Maximum() : idx_t(order_index);\n+\t\t\t\t\t\torder.expression = make_uniq<PositionalReferenceExpression>(positional_index);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\t// ARRAY_AGG(COLUMNS(*)) IS NULL\n \t\tauto agg_is_null = make_uniq<OperatorExpression>(ExpressionType::OPERATOR_IS_NULL, aggr->Copy());\n \t\t// empty list\n",
  "test_patch": "diff --git a/test/sql/subquery/scalar/array_order_subquery.test b/test/sql/subquery/scalar/array_order_subquery.test\nindex d622e99df772..13af1aa1816d 100644\n--- a/test/sql/subquery/scalar/array_order_subquery.test\n+++ b/test/sql/subquery/scalar/array_order_subquery.test\n@@ -37,3 +37,46 @@ select array(select unnest(l) AS i order by i desc nulls first) as a from (value\n []\n [12, 11, 10]\n \n+# use integer literals\n+query I\n+SELECT ARRAY\n+  (SELECT 1 UNION ALL\n+   SELECT 2 UNION ALL\n+   SELECT 3\n+   ORDER by 1) AS new_array;\n+----\n+[1, 2, 3]\n+\n+query I\n+SELECT ARRAY\n+  (SELECT 1 UNION ALL\n+   SELECT 2 UNION ALL\n+   SELECT 3\n+   ORDER by 1 DESC) AS new_array;\n+----\n+[3, 2, 1]\n+\n+statement error\n+SELECT ARRAY\n+  (SELECT 1 UNION ALL\n+   SELECT 2 UNION ALL\n+   SELECT 3\n+   ORDER by -1) AS new_array;\n+----\n+ORDER term out of range\n+\n+statement error\n+SELECT ARRAY\n+  (SELECT 1 UNION ALL\n+   SELECT 2 UNION ALL\n+   SELECT 3\n+   ORDER by 2) AS new_array;\n+----\n+ORDER term out of range\n+\n+statement ok\n+SELECT ARRAY\n+  (SELECT 1 UNION ALL\n+   SELECT 2 UNION ALL\n+   SELECT 3\n+   ORDER by 'hello world') AS new_array;\n",
  "problem_statement": "created ARRAYS are not ordered\n### What happens?\r\n\r\nCreating an Array will shuffle the elements randomly, which:\r\na) does not match the documentation, stating: \r\n\r\n[Ordering](https://duckdb.org/docs/sql/data_types/array#ordering)\r\n\r\nThe ordering of ARRAY instances is defined using a lexicographical order. NULL values compare greater than all other values and are considered equal to each other.\r\n\r\nb) becomes a problem when accessing the elements\r\n\r\n### To Reproduce\r\n\r\n```sql\r\n\r\n-- repeat a few times\r\nSELECT ARRAY\r\n  (SELECT 1 UNION ALL\r\n   SELECT 2 UNION ALL\r\n   SELECT 3\r\n   ORDER by 1) AS new_array;\r\n\r\n/* outputs are:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 new_array \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [2, 3, 1] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 new_array \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [2, 1, 3] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 new_array \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [3, 1, 2] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n*/\r\n\r\n```\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n0.10.0 .. 0.11-Snapshot\r\n\r\n### DuckDB Client:\r\n\r\nJava\r\n\r\n### Full Name:\r\n\r\nAndreas Reichel\r\n\r\n### Affiliation:\r\n\r\nReichel\r\n\r\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\r\n\r\nI have tested with a nightly build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Even an `ORDER BY` clause does not help:\r\n\r\n```sql\r\n\r\n-- still random order\r\nSELECT ARRAY\r\n  (SELECT 1 UNION ALL\r\n   SELECT 2 UNION ALL\r\n   SELECT 3 order by 1) AS new_array;\r\n\r\n-- although the `SetOperation` is always sorted\r\nSELECT 1 UNION ALL\r\n   SELECT 2 UNION ALL\r\n   SELECT 3 order by 1;\r\n\r\n--> strictly returns rows 1, 2, 3\r\n```\n(1) Is the `ARRAY` constructor you're using documented anywhere? It feels rather magic\r\n\r\n(2) The bit of the documentation that you quote talks about the ordering of different arrays, not the ordering of elements within an array\r\n\r\n(3) For now, you can use `array_agg(... ORDER BY COLUMNNAME)` (you need to specify the column name here, integer constants are treated as literals, not as column specifiers. This is the same as in PostgreSQL: \" its expressions are always just expressions and cannot be output-column names or number\" at https://www.postgresql.org/docs/9.5/sql-expressions.html#SYNTAX-AGGREGATES )\n> (2) The bit of the documentation that you quote talks about the ordering of different arrays, not the ordering of elements within an array\r\n\r\nOk :-D\r\n\r\n```sql\r\nSELECT ARRAY\r\n  (SELECT ARRAY[1] UNION ALL\r\n   SELECT ARRAY[2] UNION ALL\r\n   SELECT ARRAY[3] order by 1) AS new_array;\r\n\r\n/*\r\n\"new_array\"\r\n\"[[1], [3], [2]]\"\r\n*/\r\n```\nWe can also close this, when it is rather a feature than a bug. I only recorded what I noticed as unexpected behavior from my own point of view.\nI don't know if it's expected because I can't find documentation for it. \r\n\r\nIn any case, your example still doesn't contradict the documentation, not just because the documentation doesn't talk about the ARRAY construct you're using but also because the documentation talks about how you can compare an array `a1` to an array `a2`, not about how array entries are sorted or how sorting is preserved from subqueries. \nPractically speaking, I don't think you should worry about this and just use the regular and documented aggregate function `array_agg` or the regular constructor function `array_value` for now. ",
  "created_at": "2024-04-16T12:20:18Z",
  "modified_files": [
    "src/parser/transform/expression/transform_subquery.cpp"
  ],
  "modified_test_files": [
    "test/sql/subquery/scalar/array_order_subquery.test"
  ]
}