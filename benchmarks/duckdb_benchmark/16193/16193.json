{
  "repo": "duckdb/duckdb",
  "pull_number": 16193,
  "instance_id": "duckdb__duckdb-16193",
  "issue_numbers": [
    "16163",
    "16163"
  ],
  "base_commit": "d76982157f9e3f72426dcf52458a26c1c8741ef3",
  "patch": "diff --git a/src/planner/expression_binder/table_function_binder.cpp b/src/planner/expression_binder/table_function_binder.cpp\nindex fca04a10b87a..71ccdefe4dd2 100644\n--- a/src/planner/expression_binder/table_function_binder.cpp\n+++ b/src/planner/expression_binder/table_function_binder.cpp\n@@ -49,6 +49,11 @@ BindResult TableFunctionBinder::BindColumnReference(unique_ptr<ParsedExpression>\n \tif (value_function) {\n \t\treturn BindExpression(value_function, depth, root_expression);\n \t}\n+\tif (table_function_name.empty()) {\n+\t\tthrow BinderException(query_location,\n+\t\t                      \"Failed to bind \\\"%s\\\" - COLUMNS expression can only contain lambda parameters\",\n+\t\t                      result_name);\n+\t}\n \n \treturn BindResult(make_uniq<BoundConstantExpression>(Value(result_name)));\n }\n",
  "test_patch": "diff --git a/test/fuzzer/duckfuzz/strptime_const_arg.test b/test/fuzzer/duckfuzz/strptime_const_arg.test\nindex 1bacd7544e08..2fd862937ea5 100644\n--- a/test/fuzzer/duckfuzz/strptime_const_arg.test\n+++ b/test/fuzzer/duckfuzz/strptime_const_arg.test\n@@ -6,6 +6,6 @@ statement ok\n create table all_types as select * exclude(small_enum, medium_enum, large_enum) from test_all_types() limit 0;\n \n statement error\n-SELECT COLUMNS(list_filter(*, (c43 -> try_strptime(c29, c24)))) FROM all_types AS t42(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41)\n+SELECT COLUMNS(list_filter(*, (c43 -> try_strptime('c29', 'c24')))) FROM all_types AS t42(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, c30, c31, c32, c33, c34, c35, c36, c37, c38, c39, c40, c41)\n ----\n Binder Error: Star expression\ndiff --git a/test/sql/parser/test_columns.test b/test/sql/parser/test_columns.test\nindex 88dc0800d5f9..a6519bce9e7d 100644\n--- a/test/sql/parser/test_columns.test\n+++ b/test/sql/parser/test_columns.test\n@@ -85,7 +85,7 @@ SELECT (SELECT COLUMNS(*)) FROM integers\n ----\n \n statement error\n-SELECT columns([a, null]) FROM values (42) t(a);\n+SELECT columns(['a', null]) FROM values (42) t(a);\n ----\n does not support NULL input parameters\n \ndiff --git a/test/sql/parser/test_columns_lists.test b/test/sql/parser/test_columns_lists.test\nindex 39621709750a..344f1a29f6db 100644\n--- a/test/sql/parser/test_columns_lists.test\n+++ b/test/sql/parser/test_columns_lists.test\n@@ -59,12 +59,11 @@ SELECT COLUMNS(['i']) + COLUMNS(['i']) FROM integers\n 84\n 26\n \n-# columns are turned into strings\n-query II\n+# columns must be returned as strings\n+statement error\n SELECT COLUMNS([i, j]) FROM integers\n ----\n-42\t84\n-13\t14\n+COLUMNS expression can only contain lambda parameters\n \n # nested columns\n statement error\n",
  "problem_statement": "`COLUMNS(x -> <anything>) ` treats tokens in `<anything>` as string literals even when not in quotes\n### What happens?\n\n`COLUMNS(x -> <anything>)` treats tokens in `<anything>` as string literals even when not in quotes.\n\n\n### To Reproduce\n\n```sql\nSELECT COLUMNS(x -> x.type[3] = 't') FROM range(1); -- e.g., user wants to filter for integers, but gets all columns\n```\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 range \u2502\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n```sql\nSELECT COLUMNS(x -> asdf >= asdf) FROM range(1); \n```\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 range \u2502\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.2\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n.\n\n### Full Name:\n\nSoeren Wolfers\n\n### Affiliation:\n\nG-Research\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n`COLUMNS(x -> <anything>) ` treats tokens in `<anything>` as string literals even when not in quotes\n### What happens?\n\n`COLUMNS(x -> <anything>)` treats tokens in `<anything>` as string literals even when not in quotes.\n\n\n### To Reproduce\n\n```sql\nSELECT COLUMNS(x -> x.type[3] = 't') FROM range(1); -- e.g., user wants to filter for integers, but gets all columns\n```\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 range \u2502\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n```sql\nSELECT COLUMNS(x -> asdf >= asdf) FROM range(1); \n```\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 range \u2502\n\u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.2\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n.\n\n### Full Name:\n\nSoeren Wolfers\n\n### Affiliation:\n\nG-Research\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "+1.\n\nAnother version of this that I was recently fighting with. In this case, I was trying to pass a list into the columns expression: \n\n```sql\nwith q1 as (select ['somerange'] as selected_cols)\n    select \n        columns(c->c in selected_cols) from q1, range(10) t(somerange)\n```\n\n> selected_cols \n> [somerange]\n> ...\n\nYet this had the expected result: \n```sql\n  select \n      columns(c->c in ['somerange'])\n      from range(10) t(somerange)\n```\n+1.\n\nAnother version of this that I was recently fighting with. In this case, I was trying to pass a list into the columns expression: \n\n```sql\nwith q1 as (select ['somerange'] as selected_cols)\n    select \n        columns(c->c in selected_cols) from q1, range(10) t(somerange)\n```\n\n> selected_cols \n> [somerange]\n> ...\n\nYet this had the expected result: \n```sql\n  select \n      columns(c->c in ['somerange'])\n      from range(10) t(somerange)\n```",
  "created_at": "2025-02-11T19:22:41Z",
  "modified_files": [
    "src/planner/expression_binder/table_function_binder.cpp"
  ],
  "modified_test_files": [
    "test/fuzzer/duckfuzz/strptime_const_arg.test",
    "test/sql/parser/test_columns.test",
    "test/sql/parser/test_columns_lists.test"
  ]
}