diff --git a/src/include/duckdb/common/enum_class_hash.hpp b/src/include/duckdb/common/enum_class_hash.hpp
new file mode 100644
index 000000000000..1de2c811f3d2
--- /dev/null
+++ b/src/include/duckdb/common/enum_class_hash.hpp
@@ -0,0 +1,22 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/common/enum_class_hash.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include <cstddef>
+
+namespace duckdb {
+/* For compatibility with older C++ STL, an explicit hash class
+   is required for enums with C++ sets and maps */
+struct EnumClassHash {
+	template <typename T>
+	std::size_t operator()(T t) const {
+		return static_cast<std::size_t>(t);
+	}
+};
+} // namespace duckdb
diff --git a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp
index 1e8345667f40..f24ff0d174a9 100644
--- a/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/create_sequence_info.hpp
@@ -13,6 +13,21 @@
 
 namespace duckdb {
 
+enum class SequenceInfo : uint8_t {
+	// Sequence start
+	SEQ_START,
+	// Sequence increment
+	SEQ_INC,
+	// Sequence minimum value
+	SEQ_MIN,
+	// Sequence maximum value
+	SEQ_MAX,
+	// Sequence cycle option
+	SEQ_CYCLE,
+	// Sequence owner table
+	SEQ_OWN
+};
+
 struct CreateSequenceInfo : public CreateInfo {
 	CreateSequenceInfo()
 	    : CreateInfo(CatalogType::SEQUENCE_ENTRY, INVALID_SCHEMA), name(string()), usage_count(0), increment(1),
diff --git a/src/parser/transform/statement/transform_alter_sequence.cpp b/src/parser/transform/statement/transform_alter_sequence.cpp
index c9f3bfa0584c..e8d360245aba 100644
--- a/src/parser/transform/statement/transform_alter_sequence.cpp
+++ b/src/parser/transform/statement/transform_alter_sequence.cpp
@@ -1,6 +1,9 @@
 #include "duckdb/parser/transformer.hpp"
 #include "duckdb/parser/statement/alter_statement.hpp"
 #include "duckdb/parser/parsed_data/alter_table_info.hpp"
+#include "duckdb/parser/parsed_data/create_sequence_info.hpp"
+#include "duckdb/common/enum_class_hash.hpp"
+#include "duckdb/common/unordered_set.hpp"
 
 namespace duckdb {
 
@@ -17,12 +20,18 @@ unique_ptr<AlterStatement> Transformer::TransformAlterSequence(duckdb_libpgquery
 		throw InternalException("Expected an argument for ALTER SEQUENCE.");
 	}
 
+	unordered_set<SequenceInfo, EnumClassHash> used;
 	duckdb_libpgquery::PGListCell *cell = nullptr;
 	for_each_cell(cell, stmt->options->head) {
 		auto *def_elem = reinterpret_cast<duckdb_libpgquery::PGDefElem *>(cell->data.ptr_value);
 		string opt_name = string(def_elem->defname);
 
 		if (opt_name == "owned_by") {
+			if (used.find(SequenceInfo::SEQ_OWN) != used.end()) {
+				throw ParserException("Owned by value should be passed as most once");
+			}
+			used.insert(SequenceInfo::SEQ_OWN);
+
 			auto val = (duckdb_libpgquery::PGValue *)def_elem->arg;
 			if (!val) {
 				throw InternalException("Expected an argument for option %s", opt_name);
diff --git a/src/parser/transform/statement/transform_alter_table.cpp b/src/parser/transform/statement/transform_alter_table.cpp
index a82fa8723984..83403bb05a5f 100644
--- a/src/parser/transform/statement/transform_alter_table.cpp
+++ b/src/parser/transform/statement/transform_alter_table.cpp
@@ -11,8 +11,11 @@ unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode
 	D_ASSERT(stmt);
 	D_ASSERT(stmt->relation);
 
-	auto result = make_unique<AlterStatement>();
+	if (stmt->cmds->length != 1) {
+		throw ParserException("Only one ALTER command per statement is supported");
+	}
 
+	auto result = make_unique<AlterStatement>();
 	auto qname = TransformQualifiedName(stmt->relation);
 
 	// first we check the type of ALTER
@@ -22,6 +25,10 @@ unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode
 		switch (command->subtype) {
 		case duckdb_libpgquery::PG_AT_AddColumn: {
 			auto cdef = (duckdb_libpgquery::PGColumnDef *)command->def;
+
+			if (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {
+				throw ParserException("Adding columns is only supported for tables");
+			}
 			if (cdef->category == duckdb_libpgquery::COL_GENERATED) {
 				throw ParserException("Adding generated columns after table creation is not supported yet");
 			}
@@ -41,20 +48,31 @@ unique_ptr<AlterStatement> Transformer::TransformAlter(duckdb_libpgquery::PGNode
 		}
 		case duckdb_libpgquery::PG_AT_DropColumn: {
 			bool cascade = command->behavior == duckdb_libpgquery::PG_DROP_CASCADE;
+
+			if (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {
+				throw ParserException("Dropping columns is only supported for tables");
+			}
 			result->info =
 			    make_unique<RemoveColumnInfo>(qname.schema, qname.name, command->name, command->missing_ok, cascade);
 			break;
 		}
 		case duckdb_libpgquery::PG_AT_ColumnDefault: {
 			auto expr = TransformExpression(command->def);
+
+			if (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {
+				throw ParserException("Alter column's default is only supported for tables");
+			}
 			result->info = make_unique<SetDefaultInfo>(qname.schema, qname.name, command->name, move(expr));
 			break;
 		}
 		case duckdb_libpgquery::PG_AT_AlterColumnType: {
 			auto cdef = (duckdb_libpgquery::PGColumnDef *)command->def;
 			auto column_definition = TransformColumnDefinition(cdef);
-
 			unique_ptr<ParsedExpression> expr;
+
+			if (stmt->relkind != duckdb_libpgquery::PG_OBJECT_TABLE) {
+				throw ParserException("Alter column's type is only supported for tables");
+			}
 			if (cdef->raw_default) {
 				expr = TransformExpression(cdef->raw_default);
 			} else {
diff --git a/src/parser/transform/statement/transform_create_sequence.cpp b/src/parser/transform/statement/transform_create_sequence.cpp
index 1adb20bce4f0..ed1e87c0b881 100644
--- a/src/parser/transform/statement/transform_create_sequence.cpp
+++ b/src/parser/transform/statement/transform_create_sequence.cpp
@@ -1,6 +1,8 @@
 #include "duckdb/parser/statement/create_statement.hpp"
 #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
 #include "duckdb/parser/transformer.hpp"
+#include "duckdb/common/enum_class_hash.hpp"
+#include "duckdb/common/unordered_set.hpp"
 #include "duckdb/common/operator/cast_operators.hpp"
 
 namespace duckdb {
@@ -16,27 +18,35 @@ unique_ptr<CreateStatement> Transformer::TransformCreateSequence(duckdb_libpgque
 	info->name = qname.name;
 
 	if (stmt->options) {
+		unordered_set<SequenceInfo, EnumClassHash> used;
 		duckdb_libpgquery::PGListCell *cell = nullptr;
 		for_each_cell(cell, stmt->options->head) {
 			auto *def_elem = reinterpret_cast<duckdb_libpgquery::PGDefElem *>(cell->data.ptr_value);
 			string opt_name = string(def_elem->defname);
-
 			auto val = (duckdb_libpgquery::PGValue *)def_elem->arg;
-			if (def_elem->defaction == duckdb_libpgquery::PG_DEFELEM_UNSPEC && !val) { // e.g. NO MINVALUE
-				continue;
-			}
-			D_ASSERT(val);
-			int64_t opt_value;
-			if (val->type == duckdb_libpgquery::T_PGInteger) {
-				opt_value = val->val.ival;
-			} else if (val->type == duckdb_libpgquery::T_PGFloat) {
-				if (!TryCast::Operation<string_t, int64_t>(string_t(val->val.str), opt_value, true)) {
+			bool nodef = def_elem->defaction == duckdb_libpgquery::PG_DEFELEM_UNSPEC && !val; // e.g. NO MINVALUE
+			int64_t opt_value = 0;
+
+			if (val) {
+				if (val->type == duckdb_libpgquery::T_PGInteger) {
+					opt_value = val->val.ival;
+				} else if (val->type == duckdb_libpgquery::T_PGFloat) {
+					if (!TryCast::Operation<string_t, int64_t>(string_t(val->val.str), opt_value, true)) {
+						throw ParserException("Expected an integer argument for option %s", opt_name);
+					}
+				} else {
 					throw ParserException("Expected an integer argument for option %s", opt_name);
 				}
-			} else {
-				throw ParserException("Expected an integer argument for option %s", opt_name);
 			}
 			if (opt_name == "increment") {
+				if (used.find(SequenceInfo::SEQ_INC) != used.end()) {
+					throw ParserException("Increment value should be passed as most once");
+				}
+				used.insert(SequenceInfo::SEQ_INC);
+				if (nodef) {
+					continue;
+				}
+
 				info->increment = opt_value;
 				if (info->increment == 0) {
 					throw ParserException("Increment must not be zero");
@@ -49,18 +59,50 @@ unique_ptr<CreateStatement> Transformer::TransformCreateSequence(duckdb_libpgque
 					info->max_value = NumericLimits<int64_t>::Maximum();
 				}
 			} else if (opt_name == "minvalue") {
+				if (used.find(SequenceInfo::SEQ_MIN) != used.end()) {
+					throw ParserException("Minvalue should be passed as most once");
+				}
+				used.insert(SequenceInfo::SEQ_MIN);
+				if (nodef) {
+					continue;
+				}
+
 				info->min_value = opt_value;
 				if (info->increment > 0) {
 					info->start_value = info->min_value;
 				}
 			} else if (opt_name == "maxvalue") {
+				if (used.find(SequenceInfo::SEQ_MAX) != used.end()) {
+					throw ParserException("Maxvalue should be passed as most once");
+				}
+				used.insert(SequenceInfo::SEQ_MAX);
+				if (nodef) {
+					continue;
+				}
+
 				info->max_value = opt_value;
 				if (info->increment < 0) {
 					info->start_value = info->max_value;
 				}
 			} else if (opt_name == "start") {
+				if (used.find(SequenceInfo::SEQ_START) != used.end()) {
+					throw ParserException("Start value should be passed as most once");
+				}
+				used.insert(SequenceInfo::SEQ_START);
+				if (nodef) {
+					continue;
+				}
+
 				info->start_value = opt_value;
 			} else if (opt_name == "cycle") {
+				if (used.find(SequenceInfo::SEQ_CYCLE) != used.end()) {
+					throw ParserException("Cycle value should be passed as most once");
+				}
+				used.insert(SequenceInfo::SEQ_CYCLE);
+				if (nodef) {
+					continue;
+				}
+
 				info->cycle = opt_value > 0;
 			} else {
 				throw ParserException("Unrecognized option \"%s\" for CREATE SEQUENCE", opt_name);
diff --git a/src/parser/transform/statement/transform_rename.cpp b/src/parser/transform/statement/transform_rename.cpp
index 5e3e45e1fd25..30e9e5982681 100644
--- a/src/parser/transform/statement/transform_rename.cpp
+++ b/src/parser/transform/statement/transform_rename.cpp
@@ -71,6 +71,7 @@ unique_ptr<AlterStatement> Transformer::TransformRename(duckdb_libpgquery::PGNod
 		throw NotImplementedException("Schema element not supported yet!");
 	}
 	D_ASSERT(info);
+	info->if_exists = stmt->missing_ok;
 
 	auto result = make_unique<AlterStatement>();
 	result->info = move(info);
diff --git a/src/parser/transform/tableref/transform_subquery.cpp b/src/parser/transform/tableref/transform_subquery.cpp
index 0dab25a43419..bb0d86fb89de 100644
--- a/src/parser/transform/tableref/transform_subquery.cpp
+++ b/src/parser/transform/tableref/transform_subquery.cpp
@@ -9,6 +9,9 @@ unique_ptr<TableRef> Transformer::TransformRangeSubselect(duckdb_libpgquery::PGR
 	if (!subquery) {
 		return nullptr;
 	}
+	if (root->lateral) {
+		throw NotImplementedException("LATERAL not implemented");
+	}
 	auto result = make_unique<SubqueryRef>(move(subquery));
 	result->alias = TransformAlias(root->alias, result->column_name_alias);
 	if (root->sample) {
diff --git a/tools/odbc/include/odbc_diagnostic.hpp b/tools/odbc/include/odbc_diagnostic.hpp
index d1381f0a4c25..e521a1862308 100644
--- a/tools/odbc/include/odbc_diagnostic.hpp
+++ b/tools/odbc/include/odbc_diagnostic.hpp
@@ -3,6 +3,7 @@
 
 #include "duckdb.hpp"
 #include "duckdb/common/windows.hpp"
+#include "duckdb/common/enum_class_hash.hpp"
 
 #include "sqlext.h"
 #include "sqltypes.h"
@@ -154,13 +155,6 @@ struct SQLState {
 	std::string erro_msg;
 };
 
-struct EnumClassHash {
-	template <typename T>
-	std::size_t operator()(T t) const {
-		return static_cast<std::size_t>(t);
-	}
-};
-
 struct DiagRecord {
 public:
 	explicit DiagRecord(const std::string &msg, const SQLStateType &sqlstate_type, const std::string &server_name = "",
@@ -207,7 +201,7 @@ class OdbcDiagnostic {
 	std::vector<SQLSMALLINT> vec_record_idx;
 	static const std::unordered_map<SQLINTEGER, std::string> MAP_DYNAMIC_FUNCTION;
 	static const std::set<std::string> SET_ODBC3_SUBCLASS_ORIGIN;
-	static const std::unordered_map<SQLStateType, SQLState, EnumClassHash> MAP_ODBC_SQL_STATES;
+	static const std::unordered_map<SQLStateType, SQLState, duckdb::EnumClassHash> MAP_ODBC_SQL_STATES;
 
 public:
 	static bool IsDiagRecordField(SQLSMALLINT diag_identifier);
