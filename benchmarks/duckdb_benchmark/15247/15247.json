{
  "repo": "duckdb/duckdb",
  "pull_number": 15247,
  "instance_id": "duckdb__duckdb-15247",
  "issue_numbers": [
    "15072"
  ],
  "base_commit": "82abc6a40de7ed102c86d12ed5ec09bfa207d559",
  "patch": "diff --git a/src/planner/binder/expression/bind_star_expression.cpp b/src/planner/binder/expression/bind_star_expression.cpp\nindex 2a15d0c8d4ad..40704836cb4f 100644\n--- a/src/planner/binder/expression/bind_star_expression.cpp\n+++ b/src/planner/binder/expression/bind_star_expression.cpp\n@@ -44,6 +44,11 @@ bool Binder::FindStarExpression(unique_ptr<ParsedExpression> &expr, StarExpressi\n \t\t\t\tthrow BinderException(\n \t\t\t\t    \"STAR expression with REPLACE list is only allowed as the root element of COLUMNS\");\n \t\t\t}\n+\t\t\tif (!current_star.rename_list.empty()) {\n+\t\t\t\t// '*' inside COLUMNS can not have a REPLACE list\n+\t\t\t\tthrow BinderException(\n+\t\t\t\t    \"STAR expression with RENAME list is only allowed as the root element of COLUMNS\");\n+\t\t\t}\n \n \t\t\t// '*' expression inside a COLUMNS - convert to a constant list of strings (column names)\n \t\t\tvector<unique_ptr<ParsedExpression>> star_list;\n@@ -162,26 +167,37 @@ void TryTransformStarLike(unique_ptr<ParsedExpression> &root) {\n \tif (right->expression_class != ExpressionClass::CONSTANT) {\n \t\tthrow BinderException(*root, \"Pattern applied to a star expression must be a constant\");\n \t}\n+\tif (!star.rename_list.empty()) {\n+\t\tthrow BinderException(*root, \"Rename list cannot be combined with a filtering operation\");\n+\t}\n \tif (!star.replace_list.empty()) {\n \t\tthrow BinderException(*root, \"Replace list cannot be combined with a filtering operation\");\n \t}\n-\t// generate a columns expression\n-\t// \"* LIKE '%literal%'\n-\t// -> COLUMNS(list_filter(*, x -> x LIKE '%literal%'))\n+\tauto original_alias = root->alias;\n \tauto star_expr = std::move(left);\n+\tunique_ptr<ParsedExpression> child_expr;\n+\tif (function.function_name == \"regexp_full_match\" && star.exclude_list.empty()) {\n+\t\t// * SIMILAR TO '[regex]' is equivalent to COLUMNS('[regex]') so we can just move the expression directly\n+\t\tchild_expr = std::move(right);\n+\t} else {\n+\t\t// for other expressions -> generate a columns expression\n+\t\t// \"* LIKE '%literal%'\n+\t\t// -> COLUMNS(list_filter(*, x -> x LIKE '%literal%'))\n+\t\tauto lhs = make_uniq<ColumnRefExpression>(\"__lambda_col\");\n+\t\tfunction.children[0] = lhs->Copy();\n \n-\tauto lhs = make_uniq<ColumnRefExpression>(\"__lambda_col\");\n-\tfunction.children[0] = lhs->Copy();\n-\n-\tauto lambda = make_uniq<LambdaExpression>(std::move(lhs), std::move(root));\n-\tvector<unique_ptr<ParsedExpression>> filter_children;\n-\tfilter_children.push_back(std::move(star_expr));\n-\tfilter_children.push_back(std::move(lambda));\n-\tauto list_filter = make_uniq<FunctionExpression>(\"list_filter\", std::move(filter_children));\n+\t\tauto lambda = make_uniq<LambdaExpression>(std::move(lhs), std::move(root));\n+\t\tvector<unique_ptr<ParsedExpression>> filter_children;\n+\t\tfilter_children.push_back(std::move(star_expr));\n+\t\tfilter_children.push_back(std::move(lambda));\n+\t\tauto list_filter = make_uniq<FunctionExpression>(\"list_filter\", std::move(filter_children));\n+\t\tchild_expr = std::move(list_filter);\n+\t}\n \n \tauto columns_expr = make_uniq<StarExpression>();\n \tcolumns_expr->columns = true;\n-\tcolumns_expr->expr = std::move(list_filter);\n+\tcolumns_expr->expr = std::move(child_expr);\n+\tcolumns_expr->alias = std::move(original_alias);\n \troot = std::move(columns_expr);\n }\n \n",
  "test_patch": "diff --git a/test/sql/projection/select_star_like.test b/test/sql/projection/select_star_like.test\nindex fcb3a552632f..40969744dfa1 100644\n--- a/test/sql/projection/select_star_like.test\n+++ b/test/sql/projection/select_star_like.test\n@@ -45,6 +45,22 @@ SELECT * EXCLUDE (col1) SIMILAR TO '.*col.*' FROM integers\n ----\n 2\n \n+# SIMILAR TO alias can use regex groups\n+query II\n+SELECT c2, c1 FROM (\n+SELECT * SIMILAR TO 'number(\\d+)' AS 'c\\1' FROM (SELECT 1 AS number1, 2 AS number2, 3 AS end)\n+)\n+----\n+2\t1\n+\n+# LIKE\n+query I\n+SELECT val FROM (\n+SELECT * NOT LIKE '%number%' AS val FROM (SELECT 1 AS number1, 2 AS number2, 3 AS end)\n+)\n+----\n+3\n+\n # non-constant pattern\n statement error\n SELECT * SIMILAR TO pattern FROM integers, (SELECT '.*col.*') t(pattern)\n@@ -62,3 +78,9 @@ statement error\n SELECT * REPLACE (col1 + 42 AS col1) SIMILAR TO '.*col.*' FROM integers\n ----\n Replace list cannot be combined with a filtering operation\n+\n+# rename\n+statement error\n+SELECT * RENAME (col1 AS other_) SIMILAR TO '.*col.*' FROM integers\n+----\n+Rename list cannot be combined with a filtering operation\n",
  "problem_statement": "`SELECT * SIMILAR TO <regexp> AS <name>` ignores `<name>`\n### What happens?\r\n\r\nThe newly introduced `SELECT * SIMILAR TO <pattern>` syntax (and the related `LIKE` / `GLOB` versions) ignores subsequent `AS` clauses.\r\n\r\nIdeally, it'd treat them just like `COLUMNS(<pattern>) AS <name>` including allowing for matching group references.\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nSELECT * SIMILAR TO 'number(\\d+)' AS '\\1'\r\nFROM (SELECT 1 AS number1, 2 AS number2, 3 AS end)\r\n```\r\nand\r\n```sql\r\nSELECT * SIMILAR TO 'number(\\d+)' AS test\r\nFROM (SELECT 1 AS number1, 2 AS number2, 3 AS end)\r\n```\r\nboth return columns `number1` and `number2`, completely ignoring the `AS` clause.\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n1.1.4\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Hardware:\r\n\r\ni5, AMD64\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a nightly build\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-12-10T15:10:21Z",
  "modified_files": [
    "src/planner/binder/expression/bind_star_expression.cpp"
  ],
  "modified_test_files": [
    "test/sql/projection/select_star_like.test"
  ]
}