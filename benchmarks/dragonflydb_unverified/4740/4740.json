{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4740,
  "instance_id": "dragonflydb__dragonfly-4740",
  "issue_numbers": [
    "4659",
    "4724"
  ],
  "base_commit": "74f5f149bd025c3f87a5b13a40c1be8ca92c0dc7",
  "patch": "diff --git a/src/server/channel_store.cc b/src/server/channel_store.cc\nindex 6c4373b3fa32..3e03fd9a1e77 100644\n--- a/src/server/channel_store.cc\n+++ b/src/server/channel_store.cc\n@@ -126,6 +126,7 @@ unsigned ChannelStore::SendMessages(std::string_view channel, facade::ArgRange m\n   // and don't prevent the buffer from possibly filling, but the approach is good enough for\n   // limiting fast producers. Most importantly, we can use DispatchBrief below as we block here\n   int32_t last_thread = -1;\n+\n   for (auto& sub : subscribers) {\n     int sub_thread = sub.Thread();\n     DCHECK_LE(last_thread, sub_thread);\n@@ -323,7 +324,9 @@ void ChannelStoreUpdater::Apply() {\n   // queued SubscribeMaps in the freelist are no longer in use.\n   shard_set->pool()->AwaitBrief([](unsigned idx, util::ProactorBase*) {\n     ServerState::tlocal()->UpdateChannelStore(\n-        ChannelStore::control_block.most_recent.load(memory_order_relaxed));\n+        // Do not use memory_order_relaxed, we need to fetch the latest value of\n+        // the control block\n+        ChannelStore::control_block.most_recent.load(std::memory_order_seq_cst));\n   });\n \n   // Delete previous map and channel store.\n",
  "test_patch": "diff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py\nindex 4164eb24ae06..65c9c3010416 100644\n--- a/tests/dragonfly/cluster_test.py\n+++ b/tests/dragonfly/cluster_test.py\n@@ -2943,7 +2943,6 @@ async def do_migration(index):\n     assert await seeder.compare(capture, nodes[1].instance.port)\n \n \n-@pytest.mark.skip(\"Flaky test\")\n @dfly_args({\"proactor_threads\": 2, \"cluster_mode\": \"yes\"})\n async def test_cluster_sharded_pub_sub(df_factory: DflyInstanceFactory):\n     nodes = [df_factory.create(port=next(next_port)) for i in range(2)]\n@@ -2970,6 +2969,9 @@ async def test_cluster_sharded_pub_sub(df_factory: DflyInstanceFactory):\n     consumer.ssubscribe(\"kostas\")\n \n     await c_nodes[0].execute_command(\"SPUBLISH kostas hello\")\n+    # We need to sleep cause we use DispatchBrief internally. Otherwise we can't really gurantee\n+    # that the client received the message\n+    await asyncio.sleep(1)\n \n     # Consume subscription message result from above\n     message = consumer.get_sharded_message(target_node=node_a)\n@@ -2979,6 +2981,7 @@ async def test_cluster_sharded_pub_sub(df_factory: DflyInstanceFactory):\n     assert message == {\"type\": \"message\", \"pattern\": None, \"channel\": b\"kostas\", \"data\": b\"hello\"}\n \n     consumer.sunsubscribe(\"kostas\")\n+    await asyncio.sleep(1)\n     await c_nodes[0].execute_command(\"SPUBLISH kostas new_message\")\n     message = consumer.get_sharded_message(target_node=node_a)\n     assert message == {\"type\": \"unsubscribe\", \"pattern\": None, \"channel\": b\"kostas\", \"data\": 0}\n",
  "problem_statement": "test_cluster_sharded_pub_sub failed\n99% sure the test is a little racy. Will jump on this on the first chance https://github.com/dragonflydb/dragonfly/actions/runs/13517488144/job/37769144898#step:6:4085\ntest_cluster_sharded_pubsub_shard_commands failed\nThis test failed on [CI](https://github.com/dragonflydb/dragonfly/actions/runs/13712970075/job/38352821395).\n\nWhile we should be subscribed to two channels only one channel is returned with `SHARDCHANNELS`.\n\n",
  "hints_text": "\n",
  "created_at": "2025-03-10T11:34:32Z",
  "modified_files": [
    "src/server/channel_store.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/cluster_test.py"
  ]
}