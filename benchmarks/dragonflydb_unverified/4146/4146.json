{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4146,
  "instance_id": "dragonflydb__dragonfly-4146",
  "issue_numbers": [
    "4120"
  ],
  "base_commit": "5e2b48c3f3d108d2d2c4d9e923c5128db37bcf2b",
  "patch": "diff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 0c5605a2cfa5..ba1e477d66dc 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -1000,6 +1000,7 @@ bool DbSlice::Acquire(IntentLock::Mode mode, const KeyLockArgs& lock_args) {\n   if (lock_args.fps.empty()) {  // Can be empty for NO_KEY_TRANSACTIONAL commands.\n     return true;\n   }\n+  DCHECK_LT(lock_args.db_index, db_array_size());\n \n   auto& lt = db_arr_[lock_args.db_index]->trans_locks;\n   bool lock_acquired = true;\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 5cfe94c5fcc8..0b3aa70bb5ee 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -1607,6 +1607,16 @@ void GenericFamily::Select(CmdArgList args, Transaction*, SinkReplyBuilder* buil\n   if (index < 0 || index >= absl::GetFlag(FLAGS_dbnum)) {\n     return builder->SendError(kDbIndOutOfRangeErr);\n   }\n+\n+  if (cntx->conn_state.db_index == index) {\n+    // accept a noop.\n+    return builder->SendOk();\n+  }\n+\n+  if (cntx->conn_state.exec_info.IsRunning()) {\n+    return builder->SendError(\"SELECT is not allowed in a transaction\");\n+  }\n+\n   cntx->conn_state.db_index = index;\n   auto cb = [ns = cntx->ns, index](EngineShard* shard) {\n     auto& db_slice = ns->GetDbSlice(shard->shard_id());\ndiff --git a/src/server/journal/executor.cc b/src/server/journal/executor.cc\nindex ea1b2dd8484d..f8c85e8eb7f8 100644\n--- a/src/server/journal/executor.cc\n+++ b/src/server/journal/executor.cc\n@@ -76,8 +76,6 @@ void JournalExecutor::Execute(journal::ParsedEntry::CmdData& cmd) {\n }\n \n void JournalExecutor::SelectDb(DbIndex dbid) {\n-  conn_context_.conn_state.db_index = dbid;\n-\n   if (ensured_dbs_.size() <= dbid)\n     ensured_dbs_.resize(dbid + 1);\n \n@@ -85,6 +83,8 @@ void JournalExecutor::SelectDb(DbIndex dbid) {\n     auto cmd = BuildFromParts(\"SELECT\", dbid);\n     Execute(cmd);\n     ensured_dbs_[dbid] = true;\n+  } else {\n+    conn_context_.conn_state.db_index = dbid;\n   }\n }\n \ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex b6c361bab182..7d872d01cda5 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -1084,7 +1084,7 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n     return ErrorReply{\"-READONLY You can't write against a read only replica.\"};\n \n   if (multi_active) {\n-    if (cmd_name == \"SELECT\" || absl::EndsWith(cmd_name, \"SUBSCRIBE\"))\n+    if (absl::EndsWith(cmd_name, \"SUBSCRIBE\"))\n       return ErrorReply{absl::StrCat(\"Can not call \", cmd_name, \" within a transaction\")};\n \n     if (cmd_name == \"WATCH\" || cmd_name == \"FLUSHALL\" || cmd_name == \"FLUSHDB\")\n",
  "test_patch": "diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex d5229effb042..de57627e6d36 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -1067,7 +1067,7 @@ async def assert_replica_reconnections(replica_inst, initial_reconnects_count):\n @pytest.mark.asyncio\n async def test_replication_info(df_factory: DflyInstanceFactory, df_seeder_factory, n_keys=2000):\n     master = df_factory.create()\n-    replica = df_factory.create(logtostdout=True, replication_acks_interval=100)\n+    replica = df_factory.create(replication_acks_interval=100)\n     df_factory.start_all([master, replica])\n     c_master = master.client()\n     c_replica = replica.client()\n@@ -1157,8 +1157,8 @@ async def test_flushall_in_full_sync(df_factory):\n \n @pytest.mark.asyncio\n async def test_readonly_script(df_factory):\n-    master = df_factory.create(proactor_threads=2, logtostdout=True)\n-    replica = df_factory.create(proactor_threads=2, logtostdout=True)\n+    master = df_factory.create(proactor_threads=2)\n+    replica = df_factory.create(proactor_threads=2)\n \n     df_factory.start_all([master, replica])\n \n",
  "problem_statement": "MULTI does not allow SELECT\n**Describe the bug**\r\nIm trying to use Dragonfly DB with StackExchange.Redis, which is the most popular redis library for C#.\r\nHowever transactions do not work at all. After some debugging, I figured out the core issue. The issue is that dragonflydb doesnt seem to allow SELECT during MULTI. Dont ask me why it does that, but it does.\r\n\r\nThe command that SE.Redis sends is for example\r\n```\r\nSELECT 0 MULTI JSON.SET LoginSession:test . {\"Id\":\"test\"} SELECT 0 EXEC\r\n```\r\n\r\n**To Reproduce in CLI**\r\nSteps to reproduce the behavior:\r\n1. Start a new transaction with `MULTI`\r\n2. `SELECT 0` (You can already see the error message)\r\n3. `EXEC` to see the final error message that the library also responds with\r\n\r\n**Expected behavior**\r\nSELECT should be allowed in transactions, especially `SELECT 0`\r\n\r\n**Screenshots**\r\nDragonFly logs\r\n![{8486689F-470C-447B-9512-1814CC9F7702}](https://github.com/user-attachments/assets/cf7568d7-79cc-466f-89fc-5dd3ffeba388)\r\n\r\nWireshark capture\r\n![{7D5E22B6-68B2-4246-A05E-2D49432D8AD1}](https://github.com/user-attachments/assets/3896b35f-27fa-42eb-ac05-45e3566dceaa)\r\n\r\n\r\n\r\n**Environment (please complete the following information):**\r\n - OS: WSL (docker desktop)\r\n - Kernel: # Command: `uname -a`\r\n - Containerized?: Docker\r\n - Dragonfly Version: 1.25.1\r\n\r\n**Reproducible Code Snippet**\r\n```cs\r\n        var transaction = _connectionMultiplexer.GetDatabase().CreateTransaction();\r\n        \r\n        var executeAsync = transaction.ExecuteAsync(\"JSON.SET\", new object[]\r\n        {\r\n            \r\n                \"LoginSession:test\",\r\n            \".\",\r\n            \"{\\\"Id\\\":\\\"test\\\"}\"\r\n        });\r\n        await transaction.ExecuteAsync();\r\n        await executeAsync;\r\n```\r\n\r\n**Additional context**\r\nThis also affects libraries that build upon StackExchange.Redis like Redis.OM, this is where I encountered the bug the first time.\n",
  "hints_text": "Thanks. Do you know if database id  in select can actually change during MULTI? \r\nwe can definitely relax this restriction if database id has already been 0, or the same ID before any select in  `MULTI` \n> especially SELECT 0 - indeed,  it's a low effort to allow \nNo I dont think it can change. `_connectionMultiplexer.GetDatabase()` gets the database you desire. Defaults to 0 here, after that point it cannot switch database anymore.\r\n\r\nWell technically you can send a raw query but i dont think we need to worry about that.\r\nNot even sure if multi does support multiple databases in a single transaction",
  "created_at": "2024-11-18T15:48:05Z",
  "modified_files": [
    "src/server/db_slice.cc",
    "src/server/generic_family.cc",
    "src/server/journal/executor.cc",
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/replication_test.py"
  ]
}