{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4590,
  "instance_id": "dragonflydb__dragonfly-4590",
  "issue_numbers": [
    "4569"
  ],
  "base_commit": "603235819d624a20158178452df24a4ce9bf2957",
  "patch": "diff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 8787a9a0a9b6..51158156c107 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -250,6 +250,10 @@ OpResult<string> OpMoveSingleShard(const OpArgs& op_args, string_view src, strin\n                           GetFlag(FLAGS_list_compress_depth));\n       dest_res.it->second.InitRobj(OBJ_LIST, OBJ_ENCODING_QUICKLIST, dest_ql);\n     }\n+    auto blocking_controller = op_args.db_cntx.ns->GetBlockingController(op_args.shard->shard_id());\n+    if (blocking_controller) {\n+      blocking_controller->AwakeWatched(op_args.db_cntx.db_index, dest);\n+    }\n   } else {\n     if (dest_res.it->second.ObjType() != OBJ_LIST)\n       return OpStatus::WRONG_TYPE;\n@@ -380,9 +384,6 @@ OpResult<uint32_t> OpPush(const OpArgs& op_args, std::string_view key, ListDir d\n   if (res.is_new) {\n     auto blocking_controller = op_args.db_cntx.ns->GetBlockingController(es->shard_id());\n     if (blocking_controller) {\n-      string tmp;\n-      string_view key = res.it->first.GetSlice(&tmp);\n-\n       blocking_controller->AwakeWatched(op_args.db_cntx.db_index, key);\n     }\n   }\n@@ -1010,14 +1011,7 @@ OpResult<string> BPopPusher::RunSingle(time_point tp, Transaction* tx, Connectio\n         std::array<string_view, 4> arr = {pop_key_, push_key_, DirToSv(popdir_), DirToSv(pushdir_)};\n         RecordJournal(op_args, \"LMOVE\", arr, 1);\n       }\n-      auto blocking_controller = t->GetNamespace().GetBlockingController(shard->shard_id());\n-      if (blocking_controller) {\n-        string tmp;\n-\n-        blocking_controller->AwakeWatched(op_args.db_cntx.db_index, push_key_);\n-      }\n     }\n-\n     return OpStatus::OK;\n   };\n   tx->Execute(cb_move, false);\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 704f1d4cbc5a..99c932d88b4e 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -177,8 +177,6 @@ OpResult<DbSlice::ItAndUpdater> FindZEntry(const ZSetFamily::ZParams& zparams,\n \n   auto* blocking_controller = op_args.db_cntx.ns->GetBlockingController(op_args.shard->shard_id());\n   if (add_res.is_new && blocking_controller) {\n-    string tmp;\n-    string_view key = it->first.GetSlice(&tmp);\n     blocking_controller->AwakeWatched(op_args.db_cntx.db_index, key);\n   }\n \n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex 0b602c364b5c..cd2b36daefaf 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -700,6 +700,22 @@ TEST_F(ListFamilyTest, BRPopLPushSingleShardBug2857) {\n   EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n }\n \n+TEST_F(ListFamilyTest, BRPopLPushSingleShardBug4569) {\n+  RespExpr resp;\n+  auto fb0 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&] { resp = Run({\"brpop\", \"x\", \"0\"}); });\n+  WaitUntilLocked(0, \"x\");\n+\n+  ASSERT_TRUE(IsLocked(0, \"x\"));\n+  Run({\"lpush\", \"y\", \"val\"});\n+  Run({\"rpoplpush\", \"y\", \"x\"});\n+  ASSERT_EQ(1, GetDebugInfo().shards_count);\n+  fb0.Join();\n+  EXPECT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"x\", \"val\"));\n+  ASSERT_EQ(0, NumWatched());\n+  ASSERT_FALSE(IsLocked(0, \"x\"));\n+}\n+\n TEST_F(ListFamilyTest, BRPopLPushSingleShardBlocking) {\n   RespExpr resp;\n \n@@ -1307,7 +1323,6 @@ TEST_F(ListFamilyTest, LMPopWrongType) {\n   EXPECT_THAT(resp, RespArray(ElementsAre(\"l1\", RespArray(ElementsAre(\"e1\")))));\n }\n \n-\n // Reproduce a flow that trigerred a wrong DCHECK in the transaction flow.\n TEST_F(ListFamilyTest, AwakeMulti) {\n   auto f1 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&] {\n",
  "problem_statement": "BLMOVE in cluster mode is not awaked\n**Describe the bug**\nBLMOVE is not awaked after an element was pushed to the list\n\n**To Reproduce**\nRun dragonfly with flags --proactor_threads=2  --cluster_mode=emulated \nRun the following commands\nfrom connection 1:\n1. blmove {test}1 {test}2 LEFT LEFT 0\nfrom connection 2:\n1. lpush {test}3 val\n2. rpoplpush {test}3 {test}1\n\n**Expected behaviour**\nafter running command #2 from connection 2 the blmove command should return but it stays blocked\n",
  "hints_text": "",
  "created_at": "2025-02-11T13:25:43Z",
  "modified_files": [
    "src/server/list_family.cc",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc"
  ]
}