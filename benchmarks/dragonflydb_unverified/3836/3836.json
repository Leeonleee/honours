{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3836,
  "instance_id": "dragonflydb__dragonfly-3836",
  "issue_numbers": [
    "3822"
  ],
  "base_commit": "c868b27bbe4843ccca7b14c310dc095fe6b4b066",
  "patch": "diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex 1e5aa0bcdbcb..408174d8e1fc 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -171,6 +171,11 @@ pair<void*, bool> DefragIntSet(intset* is, float ratio) {\n   return {replacement, true};\n }\n \n+pair<void*, bool> DefragSortedMap(detail::SortedMap* sm, float ratio) {\n+  const bool reallocated = sm->DefragIfNeeded(ratio);\n+  return {sm, reallocated};\n+}\n+\n // Iterates over allocations of internal hash data structures and re-allocates\n // them if their pages are underutilized.\n // Returns pointer to new object ptr and whether any re-allocations happened.\n@@ -208,6 +213,23 @@ pair<void*, bool> DefragSet(unsigned encoding, void* ptr, float ratio) {\n   }\n }\n \n+pair<void*, bool> DefragZSet(unsigned encoding, void* ptr, float ratio) {\n+  switch (encoding) {\n+    // Listpack is stored as a single contiguous array\n+    case OBJ_ENCODING_LISTPACK: {\n+      return DefragListPack((uint8_t*)ptr, ratio);\n+    }\n+\n+    // SKIPLIST really means ScoreMap\n+    case OBJ_ENCODING_SKIPLIST: {\n+      return DefragSortedMap((detail::SortedMap*)ptr, ratio);\n+    }\n+\n+    default:\n+      ABSL_UNREACHABLE();\n+  }\n+}\n+\n inline void FreeObjStream(void* ptr) {\n   freeStream((stream*)ptr);\n }\n@@ -420,19 +442,23 @@ void RobjWrapper::SetString(string_view s, MemoryResource* mr) {\n }\n \n bool RobjWrapper::DefragIfNeeded(float ratio) {\n+  auto do_defrag = [this, ratio](auto defrag_fun) mutable {\n+    auto [new_ptr, realloced] = defrag_fun(encoding_, inner_obj_, ratio);\n+    inner_obj_ = new_ptr;\n+    return realloced;\n+  };\n+\n   if (type() == OBJ_STRING) {\n     if (zmalloc_page_is_underutilized(inner_obj(), ratio)) {\n       ReallocateString(tl.local_mr);\n       return true;\n     }\n   } else if (type() == OBJ_HASH) {\n-    auto [new_ptr, realloced] = DefragHash(encoding_, inner_obj_, ratio);\n-    inner_obj_ = new_ptr;\n-    return realloced;\n+    return do_defrag(DefragHash);\n   } else if (type() == OBJ_SET) {\n-    auto [new_ptr, realloced] = DefragSet(encoding_, inner_obj_, ratio);\n-    inner_obj_ = new_ptr;\n-    return realloced;\n+    return do_defrag(DefragSet);\n+  } else if (type() == OBJ_ZSET) {\n+    return do_defrag(DefragZSet);\n   }\n   return false;\n }\n@@ -440,11 +466,11 @@ bool RobjWrapper::DefragIfNeeded(float ratio) {\n int RobjWrapper::ZsetAdd(double score, sds ele, int in_flags, int* out_flags, double* newscore) {\n   // copied from zsetAdd for listpack only.\n   /* Turn options into simple to check vars. */\n-  int incr = (in_flags & ZADD_IN_INCR) != 0;\n-  int nx = (in_flags & ZADD_IN_NX) != 0;\n-  int xx = (in_flags & ZADD_IN_XX) != 0;\n-  int gt = (in_flags & ZADD_IN_GT) != 0;\n-  int lt = (in_flags & ZADD_IN_LT) != 0;\n+  bool incr = (in_flags & ZADD_IN_INCR) != 0;\n+  bool nx = (in_flags & ZADD_IN_NX) != 0;\n+  bool xx = (in_flags & ZADD_IN_XX) != 0;\n+  bool gt = (in_flags & ZADD_IN_GT) != 0;\n+  bool lt = (in_flags & ZADD_IN_LT) != 0;\n   *out_flags = 0; /* We'll return our response flags. */\n   double curscore;\n \ndiff --git a/src/core/score_map.cc b/src/core/score_map.cc\nindex 276627bb06d7..8ab7158e51ce 100644\n--- a/src/core/score_map.cc\n+++ b/src/core/score_map.cc\n@@ -146,4 +146,43 @@ detail::SdsScorePair ScoreMap::iterator::BreakToPair(void* obj) {\n   return detail::SdsScorePair(f, GetValue(f));\n }\n \n+namespace {\n+// Does not Release obj. Callers must do so explicitly if a `Reallocation` happened\n+pair<sds, bool> ReallocIfNeededGeneric(void* obj, float ratio) {\n+  sds key = (sds)obj;\n+  size_t key_len = sdslen(key);\n+\n+  if (!zmalloc_page_is_underutilized(key, ratio))\n+    return {key, false};\n+\n+  sds newkey = AllocSdsWithSpace(key_len, 8);\n+  memcpy(newkey, key, key_len + 8 + 1);\n+\n+  return {newkey, true};\n+}\n+\n+}  // namespace\n+\n+bool ScoreMap::iterator::ReallocIfNeeded(float ratio, std::function<void(sds, sds)> cb) {\n+  // Unwrap all links to correctly call SetObject()\n+  auto* ptr = curr_entry_;\n+\n+  if (ptr->IsLink()) {\n+    ptr = ptr->AsLink();\n+  }\n+\n+  // Note: we do not iterate over the links. Although we could that...\n+  auto* obj = ptr->GetObject();\n+  auto [new_obj, reallocated] = ReallocIfNeededGeneric(obj, ratio);\n+  if (reallocated) {\n+    if (cb) {\n+      cb((sds)obj, (sds)new_obj);\n+    }\n+    sdsfree((sds)obj);\n+    ptr->SetObject(new_obj);\n+  }\n+\n+  return reallocated;\n+}\n+\n }  // namespace dfly\ndiff --git a/src/core/score_map.h b/src/core/score_map.h\nindex 22bd86b453b4..33f330930389 100644\n--- a/src/core/score_map.h\n+++ b/src/core/score_map.h\n@@ -63,6 +63,14 @@ class ScoreMap : public DenseSet {\n       return BreakToPair(ptr);\n     }\n \n+    // Try reducing memory fragmentation of the value by re-allocating. Returns true if\n+    // re-allocation happened.\n+    // If function is set, we call it with the old and the new sds. This is used for data\n+    // structures that hold multiple storages that need to be update simultaneously. For example,\n+    // SortedMap contains both a B+ tree and a ScoreMap with the former, containing pointers\n+    // to the later. Therefore, we need to update those. This is handled by the cb below.\n+    bool ReallocIfNeeded(float ratio, std::function<void(sds, sds)> = {});\n+\n     iterator& operator++() {\n       Advance();\n       return *this;\ndiff --git a/src/core/sorted_map.cc b/src/core/sorted_map.cc\nindex 3cdcb96ac969..d2f395908c05 100644\n--- a/src/core/sorted_map.cc\n+++ b/src/core/sorted_map.cc\n@@ -769,5 +769,19 @@ SortedMap* SortedMap::FromListPack(PMR_NS::memory_resource* res, const uint8_t*\n   return zs;\n }\n \n+bool SortedMap::DefragIfNeeded(float ratio) {\n+  auto cb = [this](sds old_obj, sds new_obj) {\n+    score_tree->Delete(old_obj);\n+    score_tree->Insert(new_obj);\n+  };\n+  bool reallocated = false;\n+\n+  for (auto it = score_map->begin(); it != score_map->end(); ++it) {\n+    reallocated |= it.ReallocIfNeeded(ratio, cb);\n+  }\n+\n+  return reallocated;\n+}\n+\n }  // namespace detail\n }  // namespace dfly\ndiff --git a/src/core/sorted_map.h b/src/core/sorted_map.h\nindex b69c64ddb6de..8206779d65f7 100644\n--- a/src/core/sorted_map.h\n+++ b/src/core/sorted_map.h\n@@ -88,6 +88,8 @@ class SortedMap {\n   uint8_t* ToListPack() const;\n   static SortedMap* FromListPack(PMR_NS::memory_resource* res, const uint8_t* lp);\n \n+  bool DefragIfNeeded(float ratio);\n+\n  private:\n   using ScoreTree = BPTree<ScoreSds, ScoreSdsPolicy>;\n \ndiff --git a/src/core/string_map.cc b/src/core/string_map.cc\nindex cc22b7b44268..0f9b586bbf49 100644\n--- a/src/core/string_map.cc\n+++ b/src/core/string_map.cc\n@@ -300,9 +300,11 @@ detail::SdsPair StringMap::iterator::BreakToPair(void* obj) {\n bool StringMap::iterator::ReallocIfNeeded(float ratio) {\n   // Unwrap all links to correctly call SetObject()\n   auto* ptr = curr_entry_;\n-  while (ptr->IsLink())\n+  if (ptr->IsLink()) {\n     ptr = ptr->AsLink();\n+  }\n \n+  // Note: we do not iterate over the links. Although we could that...\n   auto* obj = ptr->GetObject();\n   auto [new_obj, realloced] = static_cast<StringMap*>(owner_)->ReallocIfNeeded(obj, ratio);\n   ptr->SetObject(new_obj);\n",
  "test_patch": "diff --git a/src/core/score_map_test.cc b/src/core/score_map_test.cc\nindex c6e8dc8d343d..88b686285b15 100644\n--- a/src/core/score_map_test.cc\n+++ b/src/core/score_map_test.cc\n@@ -4,6 +4,8 @@\n \n #include \"core/score_map.h\"\n \n+#include <mimalloc.h>\n+\n #include \"base/gtest.h\"\n #include \"base/logging.h\"\n #include \"core/mi_memory_resource.h\"\n@@ -84,4 +86,54 @@ TEST_F(ScoreMapTest, EmptyFind) {\n   EXPECT_EQ(nullopt, sm_->Find(\"bar\"));\n }\n \n+uint64_t total_wasted_memory = 0;\n+\n+TEST_F(ScoreMapTest, ReallocIfNeeded) {\n+  auto build_str = [](size_t i) { return to_string(i) + string(131, 'a'); };\n+\n+  auto count_waste = [](const mi_heap_t* heap, const mi_heap_area_t* area, void* block,\n+                        size_t block_size, void* arg) {\n+    size_t used = block_size * area->used;\n+    total_wasted_memory += area->committed - used;\n+    return true;\n+  };\n+\n+  for (size_t i = 0; i < 10'000; i++) {\n+    sm_->AddOrUpdate(build_str(i), i);\n+  }\n+\n+  for (size_t i = 0; i < 10'000; i++) {\n+    if (i % 10 == 0)\n+      continue;\n+    sm_->Erase(build_str(i));\n+  }\n+\n+  mi_heap_collect(mi_heap_get_backing(), true);\n+  mi_heap_visit_blocks(mi_heap_get_backing(), false, count_waste, nullptr);\n+  size_t wasted_before = total_wasted_memory;\n+\n+  size_t underutilized = 0;\n+  for (auto it = sm_->begin(); it != sm_->end(); ++it) {\n+    underutilized += zmalloc_page_is_underutilized(it->first, 0.9);\n+    it.ReallocIfNeeded(0.9);\n+  }\n+  // Check there are underutilized pages\n+  CHECK_GT(underutilized, 0u);\n+\n+  total_wasted_memory = 0;\n+  mi_heap_collect(mi_heap_get_backing(), true);\n+  mi_heap_visit_blocks(mi_heap_get_backing(), false, count_waste, nullptr);\n+  size_t wasted_after = total_wasted_memory;\n+\n+  // Check we waste significanlty less now\n+  EXPECT_GT(wasted_before, wasted_after * 2);\n+\n+  ASSERT_EQ(sm_->UpperBoundSize(), 1000);\n+  for (size_t i = 0; i < 1000; i++) {\n+    auto res = sm_->Find(build_str(i * 10));\n+    ASSERT_EQ(res.has_value(), true);\n+    ASSERT_EQ((size_t)*res, i * 10);\n+  }\n+}\n+\n }  // namespace dfly\ndiff --git a/src/core/sorted_map_test.cc b/src/core/sorted_map_test.cc\nindex efe46c69f16b..266a61118998 100644\n--- a/src/core/sorted_map_test.cc\n+++ b/src/core/sorted_map_test.cc\n@@ -265,4 +265,59 @@ TEST_F(SortedMapTest, MemoryUsage) {\n   zslFree(zsl);\n }\n \n+uint64_t total_wasted_memory = 0;\n+\n+TEST_F(SortedMapTest, ReallocIfNeeded) {\n+  auto build_str = [](size_t i) { return to_string(i) + string(131, 'a'); };\n+\n+  auto count_waste = [](const mi_heap_t* heap, const mi_heap_area_t* area, void* block,\n+                        size_t block_size, void* arg) {\n+    size_t used = block_size * area->used;\n+    total_wasted_memory += area->committed - used;\n+    return true;\n+  };\n+\n+  for (size_t i = 0; i < 10'000; i++) {\n+    int out_flags;\n+    double new_val;\n+    auto str = build_str(i);\n+    sds ele = sdsnew(str.c_str());\n+    sm_.Add(i, ele, 0, &out_flags, &new_val);\n+    sdsfree(ele);\n+  }\n+\n+  for (size_t i = 0; i < 10'000; i++) {\n+    if (i % 10 == 0)\n+      continue;\n+    auto str = build_str(i);\n+    sds ele = sdsnew(str.c_str());\n+    sm_.Delete(ele);\n+    sdsfree(ele);\n+  }\n+\n+  mi_heap_collect(mi_heap_get_backing(), true);\n+  mi_heap_visit_blocks(mi_heap_get_backing(), false, count_waste, nullptr);\n+  size_t wasted_before = total_wasted_memory;\n+\n+  ASSERT_TRUE(sm_.DefragIfNeeded(9));\n+\n+  total_wasted_memory = 0;\n+  mi_heap_collect(mi_heap_get_backing(), true);\n+  mi_heap_visit_blocks(mi_heap_get_backing(), false, count_waste, nullptr);\n+  size_t wasted_after = total_wasted_memory;\n+\n+  // Check we waste significanlty less now\n+  EXPECT_GT(wasted_before, wasted_after * 2);\n+\n+  ASSERT_EQ(sm_.Size(), 1000);\n+  auto cb = [i = 0, build_str](sds ele, double score) mutable -> bool {\n+    EXPECT_EQ(std::string_view(ele), build_str(i * 10));\n+    EXPECT_EQ((size_t)score, i * 10);\n+    ++i;\n+    return true;\n+  };\n+\n+  sm_.Iterate(0, 10000, false, cb);\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Implement defragmentation for OBJ_ZSET and OBJ_SET\nToday we support defrag only for OBJ_STRING and OBJ_HASH see RobjWrapper::DefragIfNeeded\r\nWe want to add support for OBJ_ZSET and OBJ_SET\r\n\r\n- [x] Defrag for ZSet\r\n- [ ] Defrag for Set\r\n\n",
  "hints_text": "",
  "created_at": "2024-09-30T17:14:58Z",
  "modified_files": [
    "src/core/compact_object.cc",
    "src/core/score_map.cc",
    "src/core/score_map.h",
    "src/core/sorted_map.cc",
    "src/core/sorted_map.h",
    "src/core/string_map.cc"
  ],
  "modified_test_files": [
    "src/core/score_map_test.cc",
    "src/core/sorted_map_test.cc"
  ]
}