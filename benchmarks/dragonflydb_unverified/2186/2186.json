{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2186,
  "instance_id": "dragonflydb__dragonfly-2186",
  "issue_numbers": [
    "2175"
  ],
  "base_commit": "c4cae58fc8ae0f0198bdc2c9f4cbd46bc0ef9445",
  "patch": "diff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 3dceb181046a..d8c1696162f5 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -19,6 +19,7 @@ extern \"C\" {\n \n #include \"base/logging.h\"\n #include \"core/json_object.h\"\n+#include \"facade/cmd_arg_parser.h\"\n #include \"server/acl/acl_commands_def.h\"\n #include \"server/command_registry.h\"\n #include \"server/error.h\"\n@@ -389,9 +390,10 @@ void SendJsonValue(ConnectionContext* cntx, const JsonType& j) {\n   }\n }\n \n-OpResult<string> OpGet(const OpArgs& op_args, string_view key,\n-                       vector<pair<string_view, JsonExpression>> expressions, bool should_format,\n-                       const OptString& indent, const OptString& new_line, const OptString& space) {\n+OpResult<string> OpJsonGet(const OpArgs& op_args, string_view key,\n+                           const vector<pair<string_view, optional<JsonExpression>>>& expressions,\n+                           bool should_format, const OptString& indent, const OptString& new_line,\n+                           const OptString& space) {\n   OpResult<JsonType*> result = GetJson(op_args, key);\n   if (!result) {\n     return result.status();\n@@ -427,22 +429,16 @@ OpResult<string> OpGet(const OpArgs& op_args, string_view key,\n     }\n   }\n \n-  if (expressions.size() == 1) {\n-    json out = expressions[0].second.evaluate(json_entry);\n-    if (should_format) {\n-      json_printable jp(out, options, indenting::indent);\n-      std::stringstream ss;\n-      jp.dump(ss);\n-      return ss.str();\n-    }\n-\n-    return out.as<string>();\n-  }\n+  auto eval_wrapped = [&json_entry](const optional<JsonExpression>& expr) {\n+    return expr ? expr->evaluate(json_entry) : json_entry;\n+  };\n \n   json out;\n-  for (auto& expr : expressions) {\n-    json eval = expr.second.evaluate(json_entry);\n-    out[expr.first] = eval;\n+  if (expressions.size() == 1) {\n+    out = eval_wrapped(expressions[0].second);\n+  } else {\n+    for (auto& [expr_str, expr] : expressions)\n+      out[expr_str] = eval_wrapped(expr);\n   }\n \n   if (should_format) {\n@@ -1785,54 +1781,50 @@ void JsonFamily::StrLen(CmdArgList args, ConnectionContext* cntx) {\n \n void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n   DCHECK_GE(args.size(), 1U);\n-  string_view key = ArgS(args, 0);\n+\n+  facade::CmdArgParser parser{args};\n+  string_view key = parser.Next();\n \n   OptString indent;\n   OptString new_line;\n   OptString space;\n-  vector<pair<string_view, JsonExpression>> expressions;\n-  for (size_t i = 1; i < args.size(); ++i) {\n-    string_view param = ArgS(args, i);\n-    if (absl::EqualsIgnoreCase(param, \"space\")) {\n-      if (++i >= args.size()) {\n-        return (*cntx)->SendError(facade::WrongNumArgsError(cntx->cid->name()),\n-                                  facade::kSyntaxErrType);\n-      } else {\n-        space = ArgS(args, i);\n-        continue;\n-      }\n-    } else if (absl::EqualsIgnoreCase(param, \"newline\")) {\n-      if (++i >= args.size()) {\n-        return (*cntx)->SendError(facade::WrongNumArgsError(cntx->cid->name()),\n-                                  facade::kSyntaxErrType);\n-      } else {\n-        new_line = ArgS(args, i);\n-        continue;\n-      }\n-    } else if (absl::EqualsIgnoreCase(param, \"indent\")) {\n-      if (++i >= args.size()) {\n-        return (*cntx)->SendError(facade::WrongNumArgsError(cntx->cid->name()),\n-                                  facade::kSyntaxErrType);\n-      } else {\n-        indent = ArgS(args, i);\n-        continue;\n-      }\n+  vector<pair<string_view, optional<JsonExpression>>> expressions;\n+\n+  while (parser.HasNext()) {\n+    if (parser.Check(\"SPACE\").IgnoreCase().ExpectTail(1)) {\n+      space = parser.Next();\n+      continue;\n+    }\n+    if (parser.Check(\"NEWLINE\").IgnoreCase().ExpectTail(1)) {\n+      new_line = parser.Next();\n+      continue;\n+    }\n+    if (parser.Check(\"INDENT\").IgnoreCase().ExpectTail(1)) {\n+      indent = parser.Next();\n+      continue;\n     }\n \n-    error_code ec;\n-    JsonExpression expr = ParseJsonPath(param, &ec);\n+    optional<JsonExpression> expr;\n+    string_view expr_str = parser.Next();\n \n-    if (ec) {\n-      LOG(WARNING) << \"path '\" << param << \"': Invalid JSONPath syntax: \" << ec.message();\n-      return (*cntx)->SendError(kSyntaxErr);\n+    if (expr_str != \".\") {\n+      error_code ec;\n+      expr = ParseJsonPath(expr_str, &ec);\n+      if (ec) {\n+        LOG(WARNING) << \"path '\" << expr_str << \"': Invalid JSONPath syntax: \" << ec.message();\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n     }\n-    expressions.emplace_back(param, move(expr));\n+\n+    expressions.emplace_back(expr_str, move(expr));\n   }\n \n+  if (auto err = parser.Error(); err)\n+    return (*cntx)->SendError(err->MakeReply());\n+\n   bool should_format = (indent || new_line || space);\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpGet(t->GetOpArgs(shard), key, move(expressions), should_format, indent, new_line,\n-                 space);\n+    return OpJsonGet(t->GetOpArgs(shard), key, expressions, should_format, indent, new_line, space);\n   };\n \n   Transaction* trans = cntx->transaction;\n@@ -1842,8 +1834,7 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n     (*cntx)->SendBulkString(*result);\n   } else {\n     if (result == facade::OpStatus::KEY_NOTFOUND) {\n-      // Match what Redis returning\n-      (*cntx)->SendNull();\n+      (*cntx)->SendNull();  // Match Redis\n     } else {\n       (*cntx)->SendError(result.status());\n     }\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex 11a1b453e806..33fd3aaacfce 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -4,6 +4,10 @@\n \n #include \"server/json_family.h\"\n \n+#include <absl/strings/str_replace.h>\n+\n+#include <jsoncons/json.hpp>\n+\n #include \"base/gtest.h\"\n #include \"base/logging.h\"\n #include \"facade/facade_test.h\"\n@@ -106,6 +110,14 @@ TEST_F(JsonFamilyTest, SetGetFromPhonebook) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", PhonebookJson});\n   ASSERT_THAT(resp, \"OK\");\n \n+  auto compact_json = jsoncons::json::parse(PhonebookJson).as_string();\n+\n+  resp = Run({\"JSON.GET\", \"json\", \".\"});\n+  EXPECT_EQ(resp, compact_json);\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$\"});\n+  EXPECT_EQ(resp, \"[\" + compact_json + \"]\");\n+\n   resp = Run({\"JSON.GET\", \"json\", \"$.address.*\"});\n   EXPECT_EQ(resp, R\"([\"New York\",\"NY\",\"21 2nd Street\",\"10021-3100\"])\");\n \n@@ -1038,15 +1050,4 @@ TEST_F(JsonFamilyTest, Set) {\n   EXPECT_EQ(resp, R\"([{\"a\":2,\"b\":8,\"c\":[1,2,3]}])\");\n }\n \n-TEST_F(JsonFamilyTest, LegacyV1) {\n-  string json = R\"({\"key\":[1,2,3,4]})\";\n-\n-  auto resp = Run({\"JSON.SET\", \"json1\", \".\", json});\n-  EXPECT_THAT(resp, \"OK\");\n-\n-  // JSON.GET key \".\" is the same as JSON.GET key \"$\"\n-  resp = Run({\"JSON.GET\", \"json1\", \".\"});\n-  EXPECT_THAT(resp, absl::StrCat(\"[\", json, \"]\"));\n-}\n-\n }  // namespace dfly\n",
  "problem_statement": "improper handling of JSON path \".\"\n**Describe the bug**\r\nThe current behavior is to treat a JSON path of \".\" as \"$\" for compatibility with tools like RedisInsight and official Redis libraries; however, this is different from the way Redis itself handles the legacy path \".\".\r\n\r\n**To Reproduce**\r\n\r\n**Redis**\r\n\r\n> 127.0.0.1:6379> JSON.SET doc $ '{\"a\":2}'\r\n> OK\r\n> 127.0.0.1:6379> JSON.GET doc\r\n> {\"a\":2}\r\n> 127.0.0.1:6379> JSON.GET doc $\r\n> [{\"a\":2}]\r\n> 127.0.0.1:6379> JSON.GET doc .\r\n> {\"a\":2}\r\n\r\n**Dragonfly**\r\n\r\n> 127.0.0.1:6379> JSON.SET doc $ '{\"a\":2}'\r\n> OK\r\n> 127.0.0.1:6379> JSON.GET doc\r\n> {\"a\":2}\r\n> 127.0.0.1:6379> JSON.GET doc $\r\n> [{\"a\":2}]\r\n> 127.0.0.1:6379> JSON.GET doc .\r\n> [{\"a\":2}]\r\n\r\n**Expected behavior**\r\nProviding a path of \".\" should give the same output as not providing a path at all. This would increase compatibility with RedisInsight and official Redis libraries.\r\n\r\nI'm not as intimately familiar with other Redis libraries but redis-py automatically adds a path of \".\" if no path is provided. This is causing compatibility issues with using Dragonfly as a drop-in replacement since `redis.json().get(\"key\")` is always returning a list due to the implied \".\" path.\r\n\n",
  "hints_text": "thank you for describing the issue in such detail! :)\r\nwe will fix it before the next release.\nExcellent! Thanks for the quick response and resolution, Roman.\nThis is the same error as in https://github.com/dragonflydb/dragonfly/issues/1523 and https://github.com/dragonflydb/dragonfly/issues/2053\r\n\r\nAs I understand it, it has to do with json legacy path syntax v1 and v2 syntax.\r\n\nBefore making this, I searched for issues related to JSON and didn't see either issue. You are correct in that it relates to legacy v2 syntax but, more importantly in my case, it is altering the way the official Redis python library returns results. To give a python specific example that shows the behavior:\r\n\r\n**Redis:**\r\n> db.json().set(\"doc\", \"$\", {\"a\":2})\r\n> True\r\n> db.json().get(\"doc\", \"$\")\r\n> [{'a': 2}]\r\n> db.json().get(\"doc\", \".\")\r\n> {'a': 2}\r\n> db.json().get(\"doc\")\r\n> {'a': 2}\r\n\r\n**Dragonfly:**\r\n> db.json().set(\"doc\", \"$\", {\"a\":2})\r\n> True\r\n> db.json().get(\"doc\", \"$\")\r\n> [{'a': 2}]\r\n> db.json().get(\"doc\", \".\")\r\n> [{'a': 2}]\r\n> db.json().get(\"doc\")\r\n> [{'a': 2}]\r\n\r\nThis behavior difference is preventing me from implementing Dragonfly in our environment currently. We use `get` in most places without a supplied path because we want the entire JSON structure, but the code is expecting the original element instead of a list containing the element.\r\n\r\nI'm not asking for JSON path v1 support right now, but it should eventually be implemented if Dragonfly wants to be considered a genuine drop-in replacement for Redis. All I need is for \".\" not to be handled like \"$\" and instead be handled like no path was provided because this is an unexpected significant difference to the output.\r\n\r\nI haven't tested it or created a PR because my C++ is a bit rusty, but I'm pretty sure all that needs to change is line 92 of json_family.cc from `path = \"$\"sv;` to `path = \"\"sv;`\nOh, that wasn't meant to be a criticism, I just wanted to summarize the issues.\r\nFor example, RedisInsight also uses the legacy path, so json is currently not displayed correctly (in an array see https://github.com/dragonflydb/dragonfly/issues/2053). Therefore you cannot edit or delete json entries. ",
  "created_at": "2023-11-17T13:58:57Z",
  "modified_files": [
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}