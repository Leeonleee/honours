{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 609,
  "instance_id": "dragonflydb__dragonfly-609",
  "issue_numbers": [
    "607"
  ],
  "base_commit": "aacab66434c454c84920819c7cebf4582ad12e3a",
  "patch": "diff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 5148e474402e..317055bda14b 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -506,21 +506,29 @@ void DbSlice::FlushDb(DbIndex db_ind) {\n   }).detach();\n }\n \n-// Returns true if a state has changed, false otherwise.\n-bool DbSlice::UpdateExpire(DbIndex db_ind, PrimeIterator it, uint64_t at) {\n-  auto& db = *db_arr_[db_ind];\n-  if (at == 0 && it->second.HasExpire()) {\n-    CHECK_EQ(1u, db.expire.Erase(it->first));\n-    it->second.SetExpire(false);\n+void DbSlice::AddExpire(DbIndex db_ind, PrimeIterator main_it, uint64_t at) {\n+  uint64_t delta = at - expire_base_[0];  // TODO: employ multigen expire updates.\n+  CHECK(db_arr_[db_ind]->expire.Insert(main_it->first.AsRef(), ExpirePeriod(delta)).second);\n+  main_it->second.SetExpire(true);\n+}\n \n+bool DbSlice::RemoveExpire(DbIndex db_ind, PrimeIterator main_it) {\n+  if (main_it->second.HasExpire()) {\n+    CHECK_EQ(1u, db_arr_[db_ind]->expire.Erase(main_it->first));\n+    main_it->second.SetExpire(false);\n     return true;\n   }\n+  return false;\n+}\n+\n+// Returns true if a state has changed, false otherwise.\n+bool DbSlice::UpdateExpire(DbIndex db_ind, PrimeIterator it, uint64_t at) {\n+  if (at == 0) {\n+    return RemoveExpire(db_ind, it);\n+  }\n \n   if (!it->second.HasExpire() && at) {\n-    uint64_t delta = at - expire_base_[0];  // TODO: employ multigen expire updates.\n-    CHECK(db.expire.Insert(it->first.AsRef(), ExpirePeriod(delta)).second);\n-    it->second.SetExpire(true);\n-\n+    AddExpire(db_ind, it, at);\n     return true;\n   }\n \ndiff --git a/src/server/db_slice.h b/src/server/db_slice.h\nindex 3a3f41447338..24c81f0eb157 100644\n--- a/src/server/db_slice.h\n+++ b/src/server/db_slice.h\n@@ -174,6 +174,13 @@ class DbSlice {\n   facade::OpStatus UpdateExpire(const Context& cntx, PrimeIterator prime_it, ExpireIterator exp_it,\n                                 const ExpireParams& params);\n \n+  // Adds expiry information.\n+  void AddExpire(DbIndex db_ind, PrimeIterator main_it, uint64_t at);\n+\n+  // Removes the corresponing expiry information if exists.\n+  // Returns true if expiry existed (and removed).\n+  bool RemoveExpire(DbIndex db_ind, PrimeIterator main_it);\n+\n   // Either adds or removes (if at == 0) expiry. Returns true if a change was made.\n   // Does not change expiry if at != 0 and expiry already exists.\n   bool UpdateExpire(DbIndex db_ind, PrimeIterator main_it, uint64_t at);\ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex bcd011eef2ba..86acf235a2ea 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -313,16 +313,17 @@ OpResult<int64_t> OpIncrBy(const OpArgs& op_args, string_view key, int64_t incr,\n   return new_val;\n }\n \n-int64_t CalculateAbsTime(int64_t unix_time, bool as_milli) {\n+int64_t AbsExpiryToTtl(int64_t abs_expiry_time, bool as_milli) {\n   using std::chrono::duration_cast;\n   using std::chrono::milliseconds;\n   using std::chrono::seconds;\n   using std::chrono::system_clock;\n \n   if (as_milli) {\n-    return unix_time - duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\n+    return abs_expiry_time -\n+           duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\n   } else {\n-    return unix_time - duration_cast<seconds>(system_clock::now().time_since_epoch()).count();\n+    return abs_expiry_time - duration_cast<seconds>(system_clock::now().time_since_epoch()).count();\n   }\n }\n \n@@ -438,13 +439,19 @@ OpStatus SetCmd::SetExisting(const SetParams& params, PrimeIterator it, ExpireIt\n   DbSlice& db_slice = shard->db_slice();\n   uint64_t at_ms =\n       params.expire_after_ms ? params.expire_after_ms + op_args_.db_cntx.time_now_ms : 0;\n-  if (IsValid(e_it) && at_ms) {\n-    e_it->second = db_slice.FromAbsoluteTime(at_ms);\n-  } else if (!(params.flags & SET_KEEP_EXPIRE)) {\n-    // We need to update expiry, or maybe erase the object if it was expired.\n-    bool changed = db_slice.UpdateExpire(op_args_.db_cntx.db_index, it, at_ms);\n-    if (changed && at_ms == 0)  // erased.\n-      return OpStatus::OK;      // TODO: to update journal with deletion.\n+\n+  if (!(params.flags & SET_KEEP_EXPIRE)) {\n+    if (at_ms) {  // Command has an expiry paramater.\n+      if (IsValid(e_it)) {\n+        // Updated exisitng expiry information.\n+        e_it->second = db_slice.FromAbsoluteTime(at_ms);\n+      } else {\n+        // Add new expiry information.\n+        db_slice.AddExpire(op_args_.db_cntx.db_index, it, at_ms);\n+      }\n+    } else {\n+      db_slice.RemoveExpire(op_args_.db_cntx.db_index, it);\n+    }\n   }\n \n   db_slice.PreUpdate(op_args_.db_cntx.db_index, it);\n@@ -513,7 +520,7 @@ void StringFamily::Set(CmdArgList args, ConnectionContext* cntx) {\n       // check here and if the time is in the past, return OK but don't set it\n       // Note that the time pass here for PXAT is in milliseconds, we must not change it!\n       if (cur_arg == \"EXAT\" || cur_arg == \"PXAT\") {\n-        int_arg = CalculateAbsTime(int_arg, is_ms);\n+        int_arg = AbsExpiryToTtl(int_arg, is_ms);\n         if (int_arg < 0) {\n           // this happened in the past, just return, for some reason Redis reports OK in this case\n           return builder->SendStored();\n",
  "test_patch": "diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc\nindex f6e273f32944..22cb6133b0ee 100644\n--- a/src/server/dragonfly_test.cc\n+++ b/src/server/dragonfly_test.cc\n@@ -772,6 +772,21 @@ TEST_F(DflyEngineTest, Bug496) {\n   });\n }\n \n+TEST_F(DflyEngineTest, Issue706) {\n+  // https://github.com/dragonflydb/dragonfly/issues/607\n+\n+  Run({\"SET\", \"key\", \"value1\"});\n+  EXPECT_EQ(Run({\"GET\", \"key\"}), \"value1\");\n+\n+  Run({\"SET\", \"key\", \"value2\"});\n+  EXPECT_EQ(Run({\"GET\", \"key\"}), \"value2\");\n+\n+  Run({\"EXPIRE\", \"key\", \"1000\"});\n+\n+  Run({\"SET\", \"key\", \"value3\"});\n+  EXPECT_EQ(Run({\"GET\", \"key\"}), \"value3\");\n+}\n+\n TEST_F(DefragDflyEngineTest, TestDefragOption) {\n   absl::SetFlag(&FLAGS_commit_use_threshold, 1.1);\n   // Fill data into dragonfly and then check if we have\n",
  "problem_statement": "Redis API incompatibility on `SET` command modifying key with an expiration\n**Describe the bug**\r\nIn Redis, a key that has an expiry set, can be overwritten without any issues. In Dragonfly, if a key has an expiry added, the `SET` command does not replace the value but still returns `OK` and wipes the expiry time.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Set a key with `SET key value`\r\n2. `GET` the key, observe it being set correctly\r\n3. Set the same key, replacing the value with `SET key value1`\r\n4. `GET` the key, observe it still being set correctly\r\n5. Add an expiry to the key with `EXPIRE key seconds`\r\n6. Set the same key, replacing the value with `SET key value2`\r\n8. `GET` the key, observe the key **not being updated** and still being `value1`\r\n9. After `seconds` set in 5., `GET` the key and observe it still existing (meaning that `SET` did remove the expiry)\r\n\r\n**Expected behavior**\r\nThe key should be updated and the expiry cleared regardless of expiry or current value.\r\nQuoting the [Redis docs for the `SET` command](https://redis.io/commands/set/):\r\n> Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful SET operation.\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Host: Ubuntu 22.04 (Pop!OS) for this example, also AlmaLinux 9 for a testing cluster\r\n - Kernel: `Linux pop-os 6.1.0-x64v1-xanmod1 #0~20221213.629e4bb9 SMP PREEMPT_DYNAMIC Tue Dec 13 11:05:44 UTC x86_64 x86_64 x86_64 GNU/Linux` (for this example), `Linux [redacted] 5.14.0-70.26.1.el9_0.x86_64 #1 SMP PREEMPT Tue Sep 20 08:44:24 EDT 2022 x86_64 x86_64 x86_64 GNU/Linux` for a testing cluster\r\n - Containerized?: Yes, Docker for this example, also Kubernetes\r\n - Dragonfly Version: v0.12.0\r\n\r\n**Reproducible Code Snippet**\r\nOn Dragonfly:\r\n```\r\n127.0.0.1:36379> set hello world\r\nOK\r\n127.0.0.1:36379> get hello\r\n\"world\"\r\n127.0.0.1:36379> set hello world1\r\nOK\r\n127.0.0.1:36379> get hello\r\n\"world1\"\r\n127.0.0.1:36379> expire hello 100\r\n(integer) 1\r\n127.0.0.1:36379> set hello world2\r\nOK\r\n127.0.0.1:36379> get hello\r\n\"world1\"\r\n```\r\n\r\nOn Redis 7.0.7:\r\n```\r\n127.0.0.1:26379> set hello world\r\nOK\r\n127.0.0.1:26379> get hello\r\n\"world\"\r\n127.0.0.1:26379> set hello world1\r\nOK\r\n127.0.0.1:26379> get hello\r\n\"world1\"\r\n127.0.0.1:26379> expire hello 100\r\n(integer) 1\r\n127.0.0.1:26379> set hello world2\r\nOK\r\n127.0.0.1:26379> get hello\r\n\"world2\"\r\n```\n",
  "hints_text": "Thanks for reporting this issue. It will be fixed with the next release.\n\nOn Mon, Dec 26, 2022, 21:07 ported-pw ***@***.***> wrote:\n\n> *Describe the bug*\n> In Redis, a key that has an expiry set, can be overwritten without any\n> issues. In Dragonfly, if a key has an expiry added, the SET command does\n> not replace the value but still returns OK.\n>\n> *To Reproduce*\n> Steps to reproduce the behavior:\n>\n>    1. Set a key with SET key value\n>    2. GET the key, observe it being set correctly\n>    3. Set the same key, replacing the value with SET key value1\n>    4. GET the key, observe it still being set correctly\n>    5. Add an expiry to the key with EXPIRE key seconds\n>    6. Set the same key, replacing the value with SET key value2\n>    7. GET the key, observe the key not being updated and still being\n>    value1\n>\n> *Expected behavior*\n> The key should be updated and the expiry cleared regardless of expiry or\n> current value.\n> Quoting the Redis docs for the SET command\n> <https://redis.io/commands/set/>:\n>\n> Set key to hold the string value. If key already holds a value, it is\n> overwritten, regardless of its type. Any previous time to live associated\n> with the key is discarded on successful SET operation.\n>\n> *Environment (please complete the following information):*\n>\n>    - OS: Host: Ubuntu 22.04 (Pop!OS) for this example, also AlmaLinux 9\n>    in Production\n>    - Kernel: Linux pop-os 6.1.0-x64v1-xanmod1 #0~20221213.629e4bb9 SMP\n>    PREEMPT_DYNAMIC Tue Dec 13 11:05:44 UTC x86_64 x86_64 x86_64 GNU/Linux\n>    (for this example), Linux [redacted] 5.14.0-70.26.1.el9_0.x86_64 #1\n>    SMP PREEMPT Tue Sep 20 08:44:24 EDT 2022 x86_64 x86_64 x86_64 GNU/Linux\n>    in Production\n>    - Containerized?: Yes, Docker for this example, also Kubernetes in\n>    Production\n>    - Dragonfly Version: v0.12.0\n>\n> *Reproducible Code Snippet*\n> On Dragonfly:\n>\n> 127.0.0.1:36379> set hello world\n> OK127.0.0.1:36379> get hello\n> \"world\"127.0.0.1:36379> set hello world1\n> OK127.0.0.1:36379> get hello\n> \"world1\"127.0.0.1:36379> expire hello 100\n> (integer) 1127.0.0.1:36379> set hello world2\n> OK127.0.0.1:36379> get hello\n> \"world1\"\n>\n> On Redis 7.0.7:\n>\n> 127.0.0.1:26379> set hello world\n> OK127.0.0.1:26379> get hello\n> \"world\"127.0.0.1:26379> set hello world1\n> OK127.0.0.1:26379> get hello\n> \"world1\"127.0.0.1:26379> expire hello 100\n> (integer) 1127.0.0.1:26379> set hello world2\n> OK127.0.0.1:26379> get hello\n> \"world2\"\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dragonflydb/dragonfly/issues/607>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AA4BFCGHMGQYAOVACY42OPDWPHUGNANCNFSM6AAAAAATJ2YACQ>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n",
  "created_at": "2022-12-27T14:33:37Z",
  "modified_files": [
    "src/server/db_slice.cc",
    "src/server/db_slice.h",
    "src/server/string_family.cc"
  ],
  "modified_test_files": [
    "src/server/dragonfly_test.cc"
  ]
}