{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 141,
  "instance_id": "dragonflydb__dragonfly-141",
  "issue_numbers": [
    "59"
  ],
  "base_commit": "15fd4514876f710b79bec04d909d6662c0b3c7e0",
  "patch": "diff --git a/docs/api_status.md b/docs/api_status.md\nindex e21979acec1a..f6e54536fa5e 100644\n--- a/docs/api_status.md\n+++ b/docs/api_status.md\n@@ -204,7 +204,26 @@ with respect to Memcached and Redis APIs.\n ### API 3\n ### API 4\n ### API 5\n-### API 6\n+- [X] Stream Family\n+  - [X] XADD\n+  - [ ] XCLAIM\n+  - [X] XDEL\n+  - [X] XGROUP CREATE/DELCONSUMER/DESTROY/HELP/SETID\n+  - [ ] XGROUP CREATECONSUMER\n+  - [X] XINFO GROUPS/HELP\n+  - [ ] XINFO CONSUMERS/GROUPS/STREAM\n+  - [X] XLEN\n+  - [ ] XPENDING\n+  - [X] XRANGE\n+  - [ ] XREAD\n+  - [ ] XREADGROUP\n+  - [X] XREVRANGE\n+  - [X] XSETID\n+  - [ ] XTRIM\n+\n+### API 6,7\n+- [ ] Stream Family\n+  - [ ] XAUTOCLAIM\n \n ## Notes\n Some commands were implemented as decorators along the way:\ndiff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex 1e85c88fb45c..76643c0f8d3d 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -99,6 +99,11 @@ size_t MallocUsedZSet(unsigned encoding, void* ptr) {\n   return 0;\n }\n \n+size_t MallocUsedStream(unsigned encoding, void* streamv) {\n+  // stream* str_obj = (stream*)streamv;\n+  return 0; // TODO\n+}\n+\n inline void FreeObjHash(unsigned encoding, void* ptr) {\n   switch (encoding) {\n     case OBJ_ENCODING_HT:\n@@ -228,6 +233,8 @@ size_t RobjWrapper::MallocUsed() const {\n       return MallocUsedHSet(encoding_, inner_obj_);\n     case OBJ_ZSET:\n       return MallocUsedZSet(encoding_, inner_obj_);\n+    case OBJ_STREAM:\n+      return MallocUsedStream(encoding_, inner_obj_);\n \n     default:\n       LOG(FATAL) << \"Not supported \" << type_;\ndiff --git a/src/facade/error.h b/src/facade/error.h\nindex 7d90e93f9359..51913f72927a 100644\n--- a/src/facade/error.h\n+++ b/src/facade/error.h\n@@ -11,6 +11,8 @@ namespace facade {\n \n std::string WrongNumArgsError(std::string_view cmd);\n std::string InvalidExpireTime(std::string_view cmd);\n+std::string UnknownSubCmd(std::string_view subcmd, std::string_view cmd);\n+\n \n extern const char kSyntaxErr[];\n extern const char kWrongTypeErr[];\ndiff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex 1a157004950f..9002a44b4e3b 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -57,6 +57,12 @@ string InvalidExpireTime(string_view cmd) {\n   return absl::StrCat(\"invalid expire time in '\", cmd, \"' command\");\n }\n \n+string UnknownSubCmd(string_view subcmd, string_view cmd) {\n+  return absl::StrCat(\"Unknown subcommand or wrong number of arguments for '\", subcmd, \"'. Try \",\n+                      cmd, \" HELP.\");\n+}\n+\n+\n const char kSyntaxErr[] = \"syntax error\";\n const char kWrongTypeErr[] = \"-WRONGTYPE Operation against a key holding the wrong kind of value\";\n const char kKeyNotFoundErr[] = \"no such key\";\ndiff --git a/src/facade/op_status.h b/src/facade/op_status.h\nindex 434ce24e871e..84b0c9630298 100644\n--- a/src/facade/op_status.h\n+++ b/src/facade/op_status.h\n@@ -21,6 +21,9 @@ enum class OpStatus : uint16_t {\n   INVALID_FLOAT,\n   INVALID_INT,\n   SYNTAX_ERR,\n+  BUSY_GROUP,\n+  STREAM_ID_SMALL,\n+  ENTRIES_ADDED_SMALL,\n };\n \n class OpResultBase {\ndiff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex 05af7450cbb8..53725451dca6 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -243,6 +243,9 @@ void RedisReplyBuilder::SendError(OpStatus status) {\n     case OpStatus::OUT_OF_MEMORY:\n       SendError(kOutOfMemory);\n       break;\n+    case OpStatus::BUSY_GROUP:\n+      SendError(\"-BUSYGROUP Consumer Group name already exists\");\n+      break;\n     default:\n       LOG(ERROR) << \"Unsupported status \" << status;\n       SendError(\"Internal error\");\ndiff --git a/src/redis/stream.h b/src/redis/stream.h\nindex 4bf3ba032cf9..745f3ab65c3e 100644\n--- a/src/redis/stream.h\n+++ b/src/redis/stream.h\n@@ -131,7 +131,7 @@ void streamIteratorStop(streamIterator *si);\n streamCG *streamLookupCG(stream *s, sds groupname);\n streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags);\n streamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags);\n-streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read);\n+streamCG *streamCreateCG(stream *s, const char *name, size_t namelen, streamID *id, long long entries_read);\n streamNACK *streamCreateNACK(streamConsumer *consumer);\n void streamDecodeID(void *buf, streamID *id);\n int streamCompareID(streamID *a, streamID *b);\n@@ -149,5 +149,9 @@ void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_i\n long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id);\n int64_t streamTrimByLength(stream *s, long long maxlen, int approx);\n int64_t streamTrimByID(stream *s, streamID minid, int approx);\n+void streamFreeCG(streamCG *cg);\n+void streamDelConsumer(streamCG *cg, streamConsumer *consumer);\n+void streamLastValidID(stream *s, streamID *maxid);\n+int streamIDEqZero(streamID *id);\n \n #endif\ndiff --git a/src/redis/t_stream.c b/src/redis/t_stream.c\nindex d2028beccf1d..c55eb5e03730 100644\n--- a/src/redis/t_stream.c\n+++ b/src/redis/t_stream.c\n@@ -2485,7 +2485,7 @@ void streamFreeConsumer(streamConsumer *sc) {\n  * specified name, last server ID and reads counter. If a consumer group with\n  * the same name already exists NULL is returned, otherwise the pointer to the\n  * consumer group is returned. */\n-streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {\n+streamCG *streamCreateCG(stream *s, const char *name, size_t namelen, streamID *id, long long entries_read) {\n     if (s->cgroups == NULL) s->cgroups = raxNew();\n     if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)\n         return NULL;\ndiff --git a/src/server/debugcmd.cc b/src/server/debugcmd.cc\nindex 3f9498f0f79a..d8dbfba3e0ae 100644\n--- a/src/server/debugcmd.cc\n+++ b/src/server/debugcmd.cc\n@@ -77,9 +77,9 @@ DebugCmd::DebugCmd(ServerFamily* owner, ConnectionContext* cntx) : sf_(*owner),\n }\n \n void DebugCmd::Run(CmdArgList args) {\n-  std::string_view subcmd = ArgS(args, 1);\n+  string_view subcmd = ArgS(args, 1);\n   if (subcmd == \"HELP\") {\n-    std::string_view help_arr[] = {\n+    string_view help_arr[] = {\n         \"DEBUG <subcommand> [<arg> [value] [opt] ...]. Subcommands are:\",\n         \"OBJECT <key>\",\n         \"    Show low-level info about `key` and associated value.\",\n@@ -122,8 +122,7 @@ void DebugCmd::Run(CmdArgList args) {\n     return Inspect(key);\n   }\n \n-  string reply = absl::StrCat(\"Unknown subcommand or wrong number of arguments for '\", subcmd,\n-                              \"'. Try DEBUG HELP.\");\n+  string reply = UnknownSubCmd(subcmd, \"DEBUG\");\n   return (*cntx_)->SendError(reply, kSyntaxErrType);\n }\n \n@@ -132,7 +131,7 @@ void DebugCmd::Reload(CmdArgList args) {\n \n   for (size_t i = 2; i < args.size(); ++i) {\n     ToUpper(&args[i]);\n-    std::string_view opt = ArgS(args, i);\n+    string_view opt = ArgS(args, i);\n     VLOG(1) << \"opt \" << opt;\n \n     if (opt == \"NOSAVE\") {\n@@ -161,7 +160,7 @@ void DebugCmd::Reload(CmdArgList args) {\n   Load(last_save_file);\n }\n \n-void DebugCmd::Load(std::string_view filename) {\n+void DebugCmd::Load(string_view filename) {\n   GlobalState new_state = sf_.service().SwitchState(GlobalState::ACTIVE, GlobalState::LOADING);\n   if (new_state != GlobalState::LOADING) {\n     LOG(WARNING) << GlobalStateName(new_state) << \" in progress, ignored\";\n@@ -202,8 +201,7 @@ void DebugCmd::Load(std::string_view filename) {\n \n void DebugCmd::Populate(CmdArgList args) {\n   if (args.size() < 3 || args.size() > 5) {\n-    return (*cntx_)->SendError(\n-        \"Unknown subcommand or wrong number of arguments for 'populate'. Try DEBUG HELP.\");\n+    return (*cntx_)->SendError(UnknownSubCmd(\"populate\", \"DEBUG\"));\n   }\n \n   uint64_t total_count = 0;\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 9230b13d53af..7deb05d3a25d 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -993,7 +993,7 @@ void Service::Function(CmdArgList args, ConnectionContext* cntx) {\n     return (*cntx)->SendOk();\n   }\n \n-  string err = StrCat(\"Unknown subcommand '\", sub_cmd, \"'. Try FUNCTION HELP.\");\n+  string err = UnknownSubCmd(sub_cmd, \"FUNCTION\");\n   return (*cntx)->SendError(err, kSyntaxErrType);\n }\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex b9b967ea268f..8e0154d796d3 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -87,11 +87,6 @@ error_code CreateDirs(fs::path dir_path) {\n   return ec;\n }\n \n-string UnknownSubCmd(string_view subcmd, string cmd) {\n-  return absl::StrCat(\"Unknown subcommand or wrong number of arguments for '\", subcmd, \"'. Try \",\n-                      cmd, \" HELP.\");\n-}\n-\n string UnknownCmd(string cmd, CmdArgList args) {\n   return absl::StrCat(\"unknown command '\", cmd, \"' with args beginning with: \",\n                       StrJoin(args.begin(), args.end(), \", \", CmdArgListFormatter()));\n@@ -689,8 +684,7 @@ void ServerFamily::Memory(CmdArgList args, ConnectionContext* cntx) {\n     return (*cntx)->SendLong(1);\n   }\n \n-  string err = StrCat(\"Unknown subcommand or wrong number of arguments for '\", sub_cmd,\n-                      \"'. Try MEMORY HELP.\");\n+  string err = UnknownSubCmd(sub_cmd, \"MEMORY\");\n   return (*cntx)->SendError(err, kSyntaxErrType);\n }\n \ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 5a961ed823d6..9d041b0adaaa 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -43,6 +43,40 @@ struct RangeId {\n   bool exclude = false;\n };\n \n+struct AddOpts {\n+  ParsedStreamId parsed_id;\n+  uint32_t max_limit = kuint32max;\n+  bool max_limit_approx = false;\n+};\n+\n+struct GroupInfo {\n+  string name;\n+  size_t consumer_size;\n+  size_t pending_size;\n+  streamID last_id;\n+};\n+\n+struct RangeOpts {\n+  ParsedStreamId start;\n+  ParsedStreamId end;\n+  bool is_rev = false;\n+  uint32_t count = kuint32max;\n+};\n+\n+const char kInvalidStreamId[] = \"Invalid stream ID specified as stream command argument\";\n+const char kXGroupKeyNotFound[] =\n+    \"The XGROUP subcommand requires the key to exist. \"\n+    \"Note that for CREATE you may want to use the MKSTREAM option to create \"\n+    \"an empty stream automatically.\";\n+\n+inline string StreamIdRepr(const streamID& id) {\n+  return absl::StrCat(id.ms, \"-\", id.seq);\n+};\n+\n+inline string NoGroupError(string_view key, string_view cgroup) {\n+  return absl::StrCat(\"-NOGROUP No such consumer group '\", cgroup, \"' for key name '\", key, \"'\");\n+}\n+\n bool ParseID(string_view strid, bool strict, uint64_t missing_seq, ParsedStreamId* dest) {\n   if (strid.empty() || strid.size() > 127)\n     return false;\n@@ -70,15 +104,13 @@ bool ParseID(string_view strid, bool strict, uint64_t missing_seq, ParsedStreamI\n   }\n \n   /* Parse <ms>-<seq> form. */\n-  streamID result{.ms = 0, .seq = 0};\n+  streamID result{.ms = 0, .seq = missing_seq};\n \n   size_t dash_pos = strid.find('-');\n   if (!absl::SimpleAtoi(strid.substr(0, dash_pos), &result.ms))\n     return false;\n \n-  if (dash_pos == string_view::npos) {\n-    result.seq = missing_seq;\n-  } else {\n+  if (dash_pos != string_view::npos) {\n     if (dash_pos + 1 == strid.size())\n       return false;\n \n@@ -106,7 +138,7 @@ bool ParseRangeId(string_view id, RangeId* dest) {\n   return ParseID(id, dest->exclude, 0, &dest->parsed_id);\n }\n \n-OpResult<streamID> OpAdd(const OpArgs& op_args, string_view key, const ParsedStreamId& parsed_id,\n+OpResult<streamID> OpAdd(const OpArgs& op_args, string_view key, const AddOpts& opts,\n                          CmdArgList args) {\n   DCHECK(!args.empty() && args.size() % 2 == 0);\n   auto& db_slice = op_args.shard->db_slice();\n@@ -132,7 +164,7 @@ OpResult<streamID> OpAdd(const OpArgs& op_args, string_view key, const ParsedStr\n     db_slice.PreUpdate(op_args.db_ind, it);\n   }\n \n-  stream* str = (stream*)it->second.RObjPtr();\n+  stream* stream_inst = (stream*)it->second.RObjPtr();\n \n   // we should really get rid of this monstrousity and rewrite streamAppendItem ourselves here.\n   unique_ptr<robj*[]> objs(new robj*[args.size()]);\n@@ -141,21 +173,33 @@ OpResult<streamID> OpAdd(const OpArgs& op_args, string_view key, const ParsedStr\n   }\n \n   streamID result_id;\n+  const auto& parsed_id = opts.parsed_id;\n   streamID passed_id = parsed_id.val;\n-  int res = streamAppendItem(str, objs.get(), args.size() / 2, &result_id,\n+  int res = streamAppendItem(stream_inst, objs.get(), args.size() / 2, &result_id,\n                              parsed_id.id_given ? &passed_id : nullptr, parsed_id.has_seq);\n+\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    decrRefCount(objs[i]);\n+  }\n+\n   if (res != C_OK) {\n     if (errno == ERANGE)\n       return OpStatus::OUT_OF_RANGE;\n+    if (errno == EDOM)\n+      return OpStatus::STREAM_ID_SMALL;\n \n     return OpStatus::OUT_OF_MEMORY;\n   }\n \n+  if (opts.max_limit < kuint32max) {\n+    /* Notify xtrim event if needed. */\n+    streamTrimByLength(stream_inst, opts.max_limit, opts.max_limit_approx);\n+    // TODO: when replicating, we should propagate it as exact limit in case of trimming.\n+  }\n   return result_id;\n }\n \n-OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const ParsedStreamId& start,\n-                            const ParsedStreamId& end, uint32_t count) {\n+OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const RangeOpts& opts) {\n   auto& db_slice = op_args.shard->db_slice();\n   OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_ind, key, OBJ_STREAM);\n   if (!res_it)\n@@ -163,7 +207,7 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const Parsed\n \n   RecordVec result;\n \n-  if (count == 0)\n+  if (opts.count == 0)\n     return result;\n \n   streamIterator si;\n@@ -171,10 +215,9 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const Parsed\n   streamID id;\n   CompactObj& cobj = (*res_it)->second;\n   stream* s = (stream*)cobj.RObjPtr();\n-  int rev = 0;\n-  streamID sstart = start.val, send = end.val;\n+  streamID sstart = opts.start.val, send = opts.end.val;\n \n-  streamIteratorStart(&si, s, &sstart, &send, rev);\n+  streamIteratorStart(&si, s, &sstart, &send, opts.is_rev);\n   while (streamIteratorGetID(&si, &id, &numfields)) {\n     Record rec;\n     rec.id = id;\n@@ -193,7 +236,7 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const Parsed\n \n     result.push_back(move(rec));\n \n-    if (count == result.size())\n+    if (opts.count == result.size())\n       break;\n   }\n \n@@ -212,32 +255,360 @@ OpResult<uint32_t> OpLen(const OpArgs& op_args, string_view key) {\n   return s->length;\n }\n \n-inline string StreamIdRepr(const streamID& id) {\n-  return absl::StrCat(id.ms, \"-\", id.seq);\n+OpResult<vector<GroupInfo>> OpListGroups(const OpArgs& op_args, string_view key) {\n+  auto& db_slice = op_args.shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_ind, key, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  vector<GroupInfo> result;\n+  CompactObj& cobj = (*res_it)->second;\n+  stream* s = (stream*)cobj.RObjPtr();\n+\n+  if (s->cgroups) {\n+    result.reserve(raxSize(s->cgroups));\n+\n+    raxIterator ri;\n+    raxStart(&ri, s->cgroups);\n+    raxSeek(&ri, \"^\", NULL, 0);\n+    while (raxNext(&ri)) {\n+      streamCG* cg = (streamCG*)ri.data;\n+      GroupInfo ginfo;\n+      ginfo.name.assign(reinterpret_cast<char*>(ri.key), ri.key_len);\n+      ginfo.consumer_size = raxSize(cg->consumers);\n+      ginfo.pending_size = raxSize(cg->pel);\n+      ginfo.last_id = cg->last_id;\n+      result.push_back(std::move(ginfo));\n+    }\n+    raxStop(&ri);\n+  }\n+\n+  return result;\n+}\n+\n+struct CreateOpts {\n+  string_view gname;\n+  string_view id;\n };\n \n-const char kInvalidStreamId[] = \"Invalid stream ID specified as stream command argument\";\n+OpStatus OpCreate(const OpArgs& op_args, string_view key, const CreateOpts& opts) {\n+  auto* shard = op_args.shard;\n+  auto& db_slice = shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_ind, key, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  CompactObj& cobj = (*res_it)->second;\n+  stream* s = (stream*)cobj.RObjPtr();\n+  streamID id;\n+  ParsedStreamId parsed_id;\n+  if (opts.id == \"$\") {\n+    id = s->last_id;\n+  } else {\n+    if (ParseID(opts.id, true, 0, &parsed_id)) {\n+      id = parsed_id.val;\n+    } else {\n+      return OpStatus::SYNTAX_ERR;\n+    }\n+  }\n+\n+  streamCG* cg = streamCreateCG(s, opts.gname.data(), opts.gname.size(), &id, 0);\n+  if (cg) {\n+    return OpStatus::OK;\n+  }\n+  return OpStatus::BUSY_GROUP;\n+}\n+\n+OpResult<pair<stream*, streamCG*>> FindGroup(const OpArgs& op_args, string_view key,\n+                                             string_view gname) {\n+  auto* shard = op_args.shard;\n+  auto& db_slice = shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_ind, key, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  CompactObj& cobj = (*res_it)->second;\n+  pair<stream*, streamCG*> res;\n+  res.first = (stream*)cobj.RObjPtr();\n+  shard->tmp_str1 = sdscpylen(shard->tmp_str1, gname.data(), gname.size());\n+  res.second = streamLookupCG(res.first, shard->tmp_str1);\n+\n+  return res;\n+}\n+\n+// XGROUP DESTROY key groupname\n+OpStatus OpDestroyGroup(const OpArgs& op_args, string_view key, string_view gname) {\n+  OpResult<pair<stream*, streamCG*>> cgr_res = FindGroup(op_args, key, gname);\n+  if (!cgr_res)\n+    return cgr_res.status();\n+\n+  stream* s = cgr_res->first;\n+  streamCG* scg = cgr_res->second;\n+\n+  if (scg) {\n+    raxRemove(s->cgroups, (uint8_t*)(gname.data()), gname.size(), NULL);\n+    streamFreeCG(scg);\n+    return OpStatus::OK;\n+  }\n+\n+  return OpStatus::SKIPPED;\n+}\n+\n+// XGROUP DELCONSUMER key groupname consumername\n+OpResult<uint32_t> OpDelConsumer(const OpArgs& op_args, string_view key, string_view gname,\n+                                 string_view consumer_name) {\n+  OpResult<pair<stream*, streamCG*>> cgroup_res = FindGroup(op_args, key, gname);\n+  if (!cgroup_res)\n+    return cgroup_res.status();\n+\n+  streamCG* cg = cgroup_res->second;\n+  if (cg == nullptr)\n+    return OpStatus::SKIPPED;\n+\n+  long long pending = 0;\n+  auto* shard = op_args.shard;\n+\n+  shard->tmp_str1 = sdscpylen(shard->tmp_str1, consumer_name.data(), consumer_name.size());\n+  streamConsumer* consumer = streamLookupConsumer(cg, shard->tmp_str1, SLC_NO_REFRESH);\n+  if (consumer) {\n+    pending = raxSize(consumer->pel);\n+    streamDelConsumer(cg, consumer);\n+  }\n+\n+  return pending;\n+}\n+\n+OpStatus OpSetId(const OpArgs& op_args, string_view key, string_view gname, string_view id) {\n+  OpResult<pair<stream*, streamCG*>> cgr_res = FindGroup(op_args, key, gname);\n+  if (!cgr_res)\n+    return cgr_res.status();\n+\n+  streamCG* cg = cgr_res->second;\n+  if (cg == nullptr)\n+    return OpStatus::SKIPPED;\n+\n+  streamID sid;\n+  ParsedStreamId parsed_id;\n+  if (id == \"$\") {\n+    sid = cgr_res->first->last_id;\n+  } else {\n+    if (ParseID(id, true, 0, &parsed_id)) {\n+      sid = parsed_id.val;\n+    } else {\n+      return OpStatus::SYNTAX_ERR;\n+    }\n+  }\n+  cg->last_id = sid;\n+\n+  return OpStatus::OK;\n+}\n+\n+OpStatus OpSetId2(const OpArgs& op_args, string_view key, const streamID& sid) {\n+  auto* shard = op_args.shard;\n+  auto& db_slice = shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_ind, key, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  CompactObj& cobj = (*res_it)->second;\n+  stream* stream_inst = (stream*)cobj.RObjPtr();\n+  long long entries_added = -1;\n+  streamID max_xdel_id{0, 0};\n+\n+  /* If the stream has at least one item, we want to check that the user\n+   * is setting a last ID that is equal or greater than the current top\n+   * item, otherwise the fundamental ID monotonicity assumption is violated. */\n+  if (stream_inst->length > 0) {\n+    streamID maxid;\n+    streamID id = sid;\n+    streamLastValidID(stream_inst, &maxid);\n+\n+    if (streamCompareID(&id, &maxid) < 0) {\n+      return OpStatus::STREAM_ID_SMALL;\n+    }\n+\n+    /* If an entries_added was provided, it can't be lower than the length. */\n+    if (entries_added != -1 && stream_inst->length > uint64_t(entries_added)) {\n+      return OpStatus::ENTRIES_ADDED_SMALL;\n+    }\n+  }\n+\n+  stream_inst->last_id = sid;\n+  if (entries_added != -1)\n+    stream_inst->entries_added = entries_added;\n+  if (!streamIDEqZero(&max_xdel_id))\n+    stream_inst->max_deleted_entry_id = max_xdel_id;\n+\n+  return OpStatus::OK;\n+}\n+\n+OpResult<uint32_t> OpDel(const OpArgs& op_args, string_view key, absl::Span<streamID> ids) {\n+  auto* shard = op_args.shard;\n+  auto& db_slice = shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_ind, key, OBJ_STREAM);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  CompactObj& cobj = (*res_it)->second;\n+  stream* stream_inst = (stream*)cobj.RObjPtr();\n+\n+  uint32_t deleted = 0;\n+  bool first_entry = false;\n+\n+  for (size_t j = 0; j < ids.size(); j++) {\n+    streamID id = ids[j];\n+    if (!streamDeleteItem(stream_inst, &id))\n+      continue;\n+\n+    /* We want to know if the first entry in the stream was deleted\n+     * so we can later set the new one. */\n+    if (streamCompareID(&id, &stream_inst->first_id) == 0) {\n+      first_entry = 1;\n+    }\n+    /* Update the stream's maximal tombstone if needed. */\n+    if (streamCompareID(&id, &stream_inst->max_deleted_entry_id) > 0) {\n+      stream_inst->max_deleted_entry_id = id;\n+    }\n+    deleted++;\n+  }\n+\n+  /* Update the stream's first ID. */\n+  if (deleted) {\n+    if (stream_inst->length == 0) {\n+      stream_inst->first_id.ms = 0;\n+      stream_inst->first_id.seq = 0;\n+    } else if (first_entry) {\n+      streamGetEdgeID(stream_inst, 1, 1, &stream_inst->first_id);\n+    }\n+  }\n+\n+  return deleted;\n+}\n+\n+void CreateGroup(CmdArgList args, string_view key, ConnectionContext* cntx) {\n+  if (args.size() < 2)\n+    return (*cntx)->SendError(UnknownSubCmd(\"CREATE\", \"XGROUP\"));\n+\n+  CreateOpts opts;\n+  opts.gname = ArgS(args, 0);\n+  opts.id = ArgS(args, 1);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    OpArgs op_args{shard, t->db_index()};\n+    return OpCreate(op_args, key, opts);\n+  };\n+\n+  OpStatus result = cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  switch (result) {\n+    case OpStatus::KEY_NOTFOUND:\n+      return (*cntx)->SendError(kXGroupKeyNotFound);\n+    default:\n+      (*cntx)->SendError(result);\n+  }\n+}\n+\n+void DestroyGroup(string_view key, string_view gname, ConnectionContext* cntx) {\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    OpArgs op_args{shard, t->db_index()};\n+    return OpDestroyGroup(op_args, key, gname);\n+  };\n+\n+  OpStatus result = cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  switch (result) {\n+    case OpStatus::OK:\n+      return (*cntx)->SendLong(1);\n+    case OpStatus::SKIPPED:\n+      return (*cntx)->SendLong(0);\n+    case OpStatus::KEY_NOTFOUND:\n+      return (*cntx)->SendError(kXGroupKeyNotFound);\n+    default:\n+      (*cntx)->SendError(result);\n+  }\n+}\n+\n+void DelConsumer(string_view key, string_view gname, string_view consumer,\n+                 ConnectionContext* cntx) {\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    OpArgs op_args{shard, t->db_index()};\n+    return OpDelConsumer(op_args, key, gname, consumer);\n+  };\n+\n+  OpResult<uint32_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+\n+  switch (result.status()) {\n+    case OpStatus::OK:\n+      return (*cntx)->SendLong(*result);\n+    case OpStatus::SKIPPED:\n+      return (*cntx)->SendError(NoGroupError(key, gname));\n+    case OpStatus::KEY_NOTFOUND:\n+      return (*cntx)->SendError(kXGroupKeyNotFound);\n+    default:\n+      (*cntx)->SendError(result.status());\n+  }\n+}\n+\n+void SetId(string_view key, string_view gname, CmdArgList args, ConnectionContext* cntx) {\n+  string_view id = ArgS(args, 0);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    OpArgs op_args{shard, t->db_index()};\n+    return OpSetId(op_args, key, gname, id);\n+  };\n+\n+  OpStatus result = cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  switch (result) {\n+    case OpStatus::SKIPPED:\n+      return (*cntx)->SendError(NoGroupError(key, gname));\n+    case OpStatus::KEY_NOTFOUND:\n+      return (*cntx)->SendError(kXGroupKeyNotFound);\n+    default:\n+      (*cntx)->SendError(result);\n+  }\n+}\n+\n }  // namespace\n \n void StreamFamily::XAdd(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n+  unsigned id_indx = 2;\n+  AddOpts add_opts;\n+\n+  for (; id_indx < args.size(); ++id_indx) {\n+    ToUpper(&args[id_indx]);\n+    string_view arg = ArgS(args, id_indx);\n+    if (arg == \"MAXLEN\") {\n+      if (id_indx + 2 >= args.size()) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+      ++id_indx;\n+      if (ArgS(args, id_indx) == \"~\") {\n+        add_opts.max_limit_approx = true;\n+        ++id_indx;\n+      }\n+      arg = ArgS(args, id_indx);\n+      if (!absl::SimpleAtoi(arg, &add_opts.max_limit)) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+    } else {\n+      break;\n+    }\n+  }\n \n-  // TODO: args parsing\n-  string_view id = ArgS(args, 2);\n-  ParsedStreamId parsed_id;\n-\n-  args.remove_prefix(3);\n-  if (args.empty() || args.size() % 2 == 1) {\n+  args.remove_prefix(id_indx);\n+  if (args.size() < 3 || args.size() % 2 == 0) {\n     return (*cntx)->SendError(WrongNumArgsError(\"XADD\"), kSyntaxErrType);\n   }\n \n-  if (!ParseID(id, true, 0, &parsed_id)) {\n+  string_view id = ArgS(args, 0);\n+\n+  if (!ParseID(id, true, 0, &add_opts.parsed_id)) {\n     return (*cntx)->SendError(kInvalidStreamId, kSyntaxErrType);\n   }\n \n+  args.remove_prefix(1);\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     OpArgs op_args{shard, t->db_index()};\n-    return OpAdd(op_args, key, parsed_id, args);\n+    return OpAdd(op_args, key, add_opts, args);\n   };\n \n   OpResult<streamID> add_result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n@@ -245,9 +616,134 @@ void StreamFamily::XAdd(CmdArgList args, ConnectionContext* cntx) {\n     return (*cntx)->SendBulkString(StreamIdRepr(*add_result));\n   }\n \n+  if (add_result.status() == OpStatus::STREAM_ID_SMALL) {\n+    return (*cntx)->SendError(\n+        \"The ID specified in XADD is equal or smaller than \"\n+        \"the target stream top item\");\n+  }\n+\n   return (*cntx)->SendError(add_result.status());\n }\n \n+void StreamFamily::XDel(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  args.remove_prefix(2);\n+\n+  absl::InlinedVector<streamID, 8> ids(ids.size());\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    ParsedStreamId parsed_id;\n+    string_view str_id = ArgS(args, i);\n+    if (!ParseID(str_id, true, 0, &parsed_id)) {\n+      return (*cntx)->SendError(kInvalidStreamId, kSyntaxErrType);\n+    }\n+    ids[i] = parsed_id.val;\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    OpArgs op_args{shard, t->db_index()};\n+    return OpDel(op_args, key, absl::Span{ids.data(), ids.size()});\n+  };\n+\n+  OpResult<uint32_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  if (result || result.status() == OpStatus::KEY_NOTFOUND) {\n+    return (*cntx)->SendLong(*result);\n+  }\n+\n+  (*cntx)->SendError(result.status());\n+}\n+\n+void StreamFamily::XGroup(CmdArgList args, ConnectionContext* cntx) {\n+  ToUpper(&args[1]);\n+  string_view sub_cmd = ArgS(args, 1);\n+  if (sub_cmd == \"HELP\") {\n+    string_view help_arr[] = {\n+        \"CREATE <key> <groupname> <id|$> [option]\",\n+        \"    Create a new consumer group. Options are:\",\n+        \"    * MKSTREAM\",\n+        \"      Create the empty stream if it does not exist.\",\n+        \"CREATECONSUMER <key> <groupname> <consumer>\",\n+        \"    Create a new consumer in the specified group.\",\n+        \"DELCONSUMER <key> <groupname> <consumer>\",\n+        \"    Remove the specified consumer.\",\n+        \"DESTROY <key> <groupname>\"\n+        \"    Remove the specified group.\",\n+        \"SETID <key> <groupname> <id|$>\",\n+        \"    Set the current group ID.\",\n+    };\n+    return (*cntx)->SendSimpleStrArr(help_arr, ABSL_ARRAYSIZE(help_arr));\n+  }\n+\n+  if (args.size() >= 3) {\n+    string_view key = ArgS(args, 2);\n+    if (sub_cmd == \"CREATE\") {\n+      args.remove_prefix(3);\n+      return CreateGroup(std::move(args), key, cntx);\n+    }\n+\n+    if (sub_cmd == \"DESTROY\" && args.size() == 4) {\n+      string_view gname = ArgS(args, 3);\n+      return DestroyGroup(key, gname, cntx);\n+    }\n+\n+    if (sub_cmd == \"DELCONSUMER\" && args.size() == 5) {\n+      string_view gname = ArgS(args, 3);\n+      string_view cname = ArgS(args, 4);\n+      return DelConsumer(key, gname, cname, cntx);\n+    }\n+\n+    if (sub_cmd == \"SETID\" && args.size() >= 5) {\n+      string_view gname = ArgS(args, 3);\n+      args.remove_prefix(4);\n+      return SetId(key, gname, std::move(args), cntx);\n+    }\n+  }\n+\n+  return (*cntx)->SendError(UnknownSubCmd(sub_cmd, \"XGROUP\"));\n+}\n+\n+void StreamFamily::XInfo(CmdArgList args, ConnectionContext* cntx) {\n+  ToUpper(&args[1]);\n+  string_view sub_cmd = ArgS(args, 1);\n+  if (sub_cmd == \"HELP\") {\n+    string_view help_arr[] = {\n+        \"CONSUMERS <key> <groupname>\",\n+        \"    Show consumers of <groupname>.\",\n+        \"GROUPS <key>\",\n+        \"    Show the stream consumer groups.\",\n+        \"STREAM <key> [FULL [COUNT <count>]\",\n+        \"    Show information about the stream.\",\n+    };\n+    return (*cntx)->SendSimpleStrArr(help_arr, ABSL_ARRAYSIZE(help_arr));\n+  }\n+\n+  if (args.size() >= 3) {\n+    string_view key = ArgS(args, 2);\n+    if (sub_cmd == \"GROUPS\") {\n+      auto cb = [&](Transaction* t, EngineShard* shard) {\n+        OpArgs op_args{shard, t->db_index()};\n+        return OpListGroups(op_args, key);\n+      };\n+\n+      OpResult<vector<GroupInfo>> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+      if (result) {\n+        (*cntx)->StartArray(result->size());\n+        for (const auto& ginfo : *result) {\n+          absl::AlphaNum an1(ginfo.consumer_size);\n+          absl::AlphaNum an2(ginfo.pending_size);\n+          string last_id = StreamIdRepr(ginfo.last_id);\n+          string_view arr[8] = {\"name\",    ginfo.name,  \"consumers\",         an1.Piece(),\n+                                \"pending\", an2.Piece(), \"last-delivered-id\", last_id};\n+\n+          (*cntx)->SendStringArr(absl::Span<string_view>{arr, 8});\n+        }\n+        return;\n+      }\n+      return (*cntx)->SendError(result.status());\n+    }\n+  }\n+  return (*cntx)->SendError(UnknownSubCmd(sub_cmd, \"XINFO\"));\n+}\n+\n void StreamFamily::XLen(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -264,11 +760,46 @@ void StreamFamily::XLen(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void StreamFamily::XRange(CmdArgList args, ConnectionContext* cntx) {\n+  XRangeGeneric(std::move(args), false, cntx);\n+}\n+\n+void StreamFamily::XRevRange(CmdArgList args, ConnectionContext* cntx) {\n+  XRangeGeneric(std::move(args), true, cntx);\n+}\n+\n+void StreamFamily::XSetId(CmdArgList args, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view idstr = ArgS(args, 2);\n+\n+  ParsedStreamId parsed_id;\n+  if (!ParseID(idstr, true, 0, &parsed_id)) {\n+    return (*cntx)->SendError(kInvalidStreamId, kSyntaxErrType);\n+  }\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    OpArgs op_args{shard, t->db_index()};\n+    return OpSetId2(op_args, key, parsed_id.val);\n+  };\n+\n+  OpStatus result = cntx->transaction->ScheduleSingleHop(std::move(cb));\n+  switch (result) {\n+    case OpStatus::STREAM_ID_SMALL:\n+      return (*cntx)->SendError(\n+          \"The ID specified in XSETID is smaller than the target stream top item\");\n+    case OpStatus::ENTRIES_ADDED_SMALL:\n+      return (*cntx)->SendError(\n+          \"The entries_added specified in XSETID is smaller than \"\n+          \"the target stream length\");\n+    default:\n+      return (*cntx)->SendError(result);\n+  }\n+}\n+\n+void StreamFamily::XRangeGeneric(CmdArgList args, bool is_rev, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   string_view start = ArgS(args, 2);\n   string_view end = ArgS(args, 3);\n-  uint32_t count = kuint32max;\n-\n+  RangeOpts range_opts;\n   RangeId rs, re;\n   if (!ParseRangeId(start, &rs) || !ParseRangeId(end, &re)) {\n     return (*cntx)->SendError(kInvalidStreamId, kSyntaxErrType);\n@@ -290,14 +821,18 @@ void StreamFamily::XRange(CmdArgList args, ConnectionContext* cntx) {\n     string_view opt = ArgS(args, 4);\n     string_view val = ArgS(args, 5);\n \n-    if (opt != \"COUNT\" || !absl::SimpleAtoi(val, &count)) {\n+    if (opt != \"COUNT\" || !absl::SimpleAtoi(val, &range_opts.count)) {\n       return (*cntx)->SendError(kSyntaxErr);\n     }\n   }\n \n+  range_opts.start = rs.parsed_id;\n+  range_opts.end = re.parsed_id;\n+  range_opts.is_rev = is_rev;\n+\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     OpArgs op_args{shard, t->db_index()};\n-    return OpRange(op_args, key, rs.parsed_id, re.parsed_id, count);\n+    return OpRange(op_args, key, range_opts);\n   };\n \n   OpResult<RecordVec> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n@@ -327,8 +862,13 @@ void StreamFamily::Register(CommandRegistry* registry) {\n   using CI = CommandId;\n \n   *registry << CI{\"XADD\", CO::WRITE | CO::FAST, -5, 1, 1, 1}.HFUNC(XAdd)\n+            << CI{\"XDEL\", CO::WRITE | CO::FAST, -3, 1, 1, 1}.HFUNC(XDel)\n+            << CI{\"XGROUP\", CO::WRITE | CO::DENYOOM, -2, 2, 2, 1}.HFUNC(XGroup)\n+            << CI{\"XINFO\", CO::READONLY, -2, 2, 2, 1}.HFUNC(XInfo)\n             << CI{\"XLEN\", CO::READONLY | CO::FAST, 2, 1, 1, 1}.HFUNC(XLen)\n-            << CI{\"XRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(XRange);\n+            << CI{\"XRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(XRange)\n+            << CI{\"XREVRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(XRevRange)\n+            << CI{\"XSETID\", CO::WRITE | CO::DENYOOM, 3, 1, 1, 1}.HFUNC(XSetId);\n }\n \n }  // namespace dfly\n\\ No newline at end of file\ndiff --git a/src/server/stream_family.h b/src/server/stream_family.h\nindex 929297381546..1726967547f6 100644\n--- a/src/server/stream_family.h\n+++ b/src/server/stream_family.h\n@@ -17,9 +17,14 @@ class StreamFamily {\n \n  private:\n   static void XAdd(CmdArgList args, ConnectionContext* cntx);\n+  static void XDel(CmdArgList args, ConnectionContext* cntx);\n+  static void XGroup(CmdArgList args, ConnectionContext* cntx);\n+  static void XInfo(CmdArgList args, ConnectionContext* cntx);\n   static void XLen(CmdArgList args, ConnectionContext* cntx);\n+  static void XRevRange(CmdArgList args, ConnectionContext* cntx);\n   static void XRange(CmdArgList args, ConnectionContext* cntx);\n-\n+  static void XSetId(CmdArgList args, ConnectionContext* cntx);\n+  static void XRangeGeneric(CmdArgList args, bool is_rev, ConnectionContext* cntx);\n };\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 73485c020e97..a7e85062161f 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -36,6 +36,52 @@ TEST_F(StreamFamilyTest, Add) {\n \n   resp = Run({\"xlen\", \"key\"});\n   EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"xadd\", \"key\", \"badid\", \"f1\", \"val1\"});\n+  EXPECT_THAT(resp, ErrArg(\"Invalid stream ID\"));\n+}\n+\n+TEST_F(StreamFamilyTest, AddExtended) {\n+  auto resp0 = Run({\"xadd\", \"key\", \"5\", \"f1\", \"v1\", \"f2\", \"v2\"});\n+  EXPECT_EQ(resp0, \"5-0\");\n+  resp0 = Run({\"xrange\", \"key\", \"5-0\", \"5-0\"});\n+  EXPECT_THAT(resp0, ArrLen(2));\n+  auto sub_arr = resp0.GetVec();\n+  EXPECT_THAT(sub_arr, ElementsAre(\"5-0\", ArrLen(4)));\n+  sub_arr = sub_arr[1].GetVec();\n+  EXPECT_THAT(sub_arr, ElementsAre(\"f1\", \"v1\", \"f2\", \"v2\"));\n+\n+  auto resp1 = Run({\"xadd\", \"key\", \"maxlen\", \"1\", \"*\", \"field1\", \"val1\"});\n+  string id1 = string(ToSV(resp1.GetBuf()));\n+\n+  auto resp2 = Run({\"xadd\", \"key\", \"maxlen\", \"1\", \"*\", \"field2\", \"val2\"});\n+  string id2 = string(ToSV(resp2.GetBuf()));\n+\n+  EXPECT_THAT(Run({\"xlen\", \"key\"}), IntArg(1));\n+  EXPECT_THAT(Run({\"xrange\", \"key\", id1, id1}), ArrLen(0));\n+\n+  auto resp3 = Run({\"xadd\", \"key\", id2, \"f1\", \"val1\"});\n+  EXPECT_THAT(resp3, ErrArg(\"equal or smaller than\"));\n+}\n+\n+TEST_F(StreamFamilyTest, Range) {\n+  Run({\"xadd\", \"key\", \"1-*\", \"f1\", \"v1\"});\n+  Run({\"xadd\", \"key\", \"1-*\", \"f2\", \"v2\"});\n+  auto resp = Run({\"xrange\", \"key\", \"-\", \"+\"});\n+  EXPECT_THAT(resp, ArrLen(2));\n+  auto sub_arr = resp.GetVec();\n+  EXPECT_THAT(sub_arr, ElementsAre(ArrLen(2), ArrLen(2)));\n+  auto sub0 = sub_arr[0].GetVec();\n+  auto sub1 = sub_arr[1].GetVec();\n+  EXPECT_THAT(sub0, ElementsAre(\"1-0\", ArrLen(2)));\n+  EXPECT_THAT(sub1, ElementsAre(\"1-1\", ArrLen(2)));\n+\n+  resp = Run({\"xrevrange\", \"key\", \"-\", \"+\"});\n+  sub_arr = resp.GetVec();\n+  sub0 = sub_arr[0].GetVec();\n+  sub1 = sub_arr[1].GetVec();\n+  EXPECT_THAT(sub0, ElementsAre(\"1-1\", ArrLen(2)));\n+  EXPECT_THAT(sub1, ElementsAre(\"1-0\", ArrLen(2)));\n }\n \n }  // namespace dfly\n\\ No newline at end of file\n",
  "problem_statement": "Support Stream data structure\nHello, came across Dragonfly on Hacker News. Very cool project \u2013 good luck with it!\r\n\r\nI am very interested in [Stream data structure](https://redis.io/docs/manual/data-types/streams/) support - think that's the only missing command for me to start experimenting with Dragonfly.\r\n\r\nSpecifically, in my use case I am using:\r\n\r\n* XADD\r\n* XRANGE\r\n* XREVRANGE\r\n\r\nHope this will be added at some point.\n",
  "hints_text": "Ok ok, I hear you load and clear. Your wish is my command.",
  "created_at": "2022-06-12T13:09:53Z",
  "modified_files": [
    "docs/api_status.md",
    "src/core/compact_object.cc",
    "src/facade/error.h",
    "src/facade/facade.cc",
    "src/facade/op_status.h",
    "src/facade/reply_builder.cc",
    "src/redis/stream.h",
    "src/redis/t_stream.c",
    "src/server/debugcmd.cc",
    "src/server/main_service.cc",
    "src/server/server_family.cc",
    "src/server/stream_family.cc",
    "src/server/stream_family.h"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}