{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1475,
  "instance_id": "dragonflydb__dragonfly-1475",
  "issue_numbers": [
    "1433"
  ],
  "base_commit": "698cbefac1f17cc677c6397ddf2a0dec15e7a601",
  "patch": "diff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 713ec9db2e47..5990b46f15f2 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -83,16 +83,36 @@ struct RangeOpts {\n   ParsedStreamId end;\n   bool is_rev = false;\n   uint32_t count = kuint32max;\n+\n+  // readgroup range fields\n+  streamCG* group = nullptr;\n+  streamConsumer* consumer = nullptr;\n+  bool noack = false;\n+};\n+\n+struct StreamIDsItem {\n+  ParsedStreamId id;\n+\n+  // Readgroup fields - id and group-consumer pair is exclusive.\n+  streamCG* group = nullptr;\n+  streamConsumer* consumer = nullptr;\n };\n \n struct ReadOpts {\n   // Contains a mapping from stream name to the starting stream ID.\n-  unordered_map<string_view, ParsedStreamId> stream_ids;\n+  unordered_map<string_view, StreamIDsItem> stream_ids;\n   // Contains the maximum number of entries to return for each stream.\n   uint32_t count = kuint32max;\n   // Contains the time to block waiting for entries, or -1 if should not block.\n   int64_t timeout = -1;\n   size_t streams_arg = 0;\n+\n+  // readgroup fields\n+  bool read_group = false;\n+  bool serve_history = false;\n+  string_view group_name;\n+  string_view consumer_name;\n+  bool noack = false;\n };\n \n const char kInvalidStreamId[] = \"Invalid stream ID specified as stream command argument\";\n@@ -100,6 +120,7 @@ const char kXGroupKeyNotFound[] =\n     \"The XGROUP subcommand requires the key to exist. \"\n     \"Note that for CREATE you may want to use the MKSTREAM option to create \"\n     \"an empty stream automatically.\";\n+const char kSameStreamFound[] = \"Same stream specified multiple time\";\n \n const uint32_t STREAM_LISTPACK_MAX_SIZE = 1 << 30;\n const uint32_t kStreamNodeMaxBytes = 4096;\n@@ -613,6 +634,9 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const RangeO\n     Record rec;\n     rec.id = id;\n     rec.kv_arr.reserve(numfields);\n+    if (opts.group && streamCompareID(&id, &opts.group->last_id) > 0) {\n+      opts.group->last_id = id;\n+    }\n \n     /* Emit the field-value pairs. */\n     while (numfields--) {\n@@ -622,11 +646,40 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const RangeO\n       string skey(reinterpret_cast<char*>(key), key_len);\n       string sval(reinterpret_cast<char*>(value), value_len);\n \n-      rec.kv_arr.emplace_back(move(skey), move(sval));\n+      rec.kv_arr.emplace_back(std::move(skey), std::move(sval));\n     }\n \n-    result.push_back(move(rec));\n-\n+    result.push_back(std::move(rec));\n+\n+    if (opts.group && !opts.noack) {\n+      unsigned char buf[sizeof(streamID)];\n+      StreamEncodeID(buf, &id);\n+\n+      /* Try to add a new NACK. Most of the time this will work and\n+       * will not require extra lookups. We'll fix the problem later\n+       * if we find that there is already an entry for this ID. */\n+      streamNACK* nack = streamCreateNACK(opts.consumer);\n+      int group_inserted = raxTryInsert(opts.group->pel, buf, sizeof(buf), nack, nullptr);\n+      int consumer_inserted = raxTryInsert(opts.consumer->pel, buf, sizeof(buf), nack, nullptr);\n+\n+      /* Now we can check if the entry was already busy, and\n+       * in that case reassign the entry to the new consumer,\n+       * or update it if the consumer is the same as before. */\n+      if (group_inserted == 0) {\n+        streamFreeNACK(nack);\n+        nack = static_cast<streamNACK*>(raxFind(opts.group->pel, buf, sizeof(buf)));\n+        DCHECK(nack != raxNotFound);\n+        raxRemove(nack->consumer->pel, buf, sizeof(buf), NULL);\n+        /* Update the consumer and NACK metadata. */\n+        nack->consumer = opts.consumer;\n+        nack->delivery_time = mstime();\n+        nack->delivery_count = 1;\n+        /* Add the entry in the new consumer local PEL. */\n+        raxInsert(opts.consumer->pel, buf, sizeof(buf), nack, NULL);\n+      } else if (group_inserted == 1 && consumer_inserted == 0) {\n+        return OpStatus::SKIPPED;  // (\"NACK half-created. Should not be possible.\");\n+      }\n+    }\n     if (opts.count == result.size())\n       break;\n   }\n@@ -636,6 +689,49 @@ OpResult<RecordVec> OpRange(const OpArgs& op_args, string_view key, const RangeO\n   return result;\n }\n \n+OpResult<RecordVec> OpRangeFromConsumerPEL(const OpArgs& op_args, string_view key,\n+                                           const RangeOpts& opts) {\n+  RecordVec result;\n+\n+  if (opts.count == 0)\n+    return result;\n+\n+  unsigned char start_key[sizeof(streamID)];\n+  unsigned char end_key[sizeof(streamID)];\n+  auto sstart = opts.start.val;\n+  auto send = opts.end.val;\n+\n+  StreamEncodeID(start_key, &sstart);\n+  StreamEncodeID(end_key, &send);\n+  raxIterator ri;\n+\n+  raxStart(&ri, opts.consumer->pel);\n+  raxSeek(&ri, \">=\", start_key, sizeof(start_key));\n+  size_t ecount = 0;\n+  while (raxNext(&ri) && (!opts.count || ecount < opts.count)) {\n+    if (memcmp(ri.key, &send, ri.key_len) > 0)\n+      break;\n+    streamID id;\n+\n+    streamDecodeID(ri.key, &id);\n+    RangeOpts ropts;\n+    ropts.start.val = id;\n+    ropts.end.val = id;\n+    auto op_result = OpRange(op_args, key, ropts);\n+    if (!op_result || !op_result.value().size()) {\n+      result.push_back(Record{id, vector<pair<string, string>>()});\n+    } else {\n+      streamNACK* nack = static_cast<streamNACK*>(ri.data);\n+      nack->delivery_time = mstime();\n+      nack->delivery_count++;\n+      result.push_back(std::move(op_result.value()[0]));\n+    }\n+    ecount++;\n+  }\n+  raxStop(&ri);\n+  return result;\n+}\n+\n // Returns a map of stream to the ID of the last entry in the stream. Any\n // streams not found are omitted from the result.\n OpResult<vector<pair<string_view, streamID>>> OpLastIDs(const OpArgs& op_args,\n@@ -682,9 +778,21 @@ vector<RecordVec> OpRead(const OpArgs& op_args, const ArgSlice& args, const Read\n   for (size_t i = 0; i < args.size(); ++i) {\n     string_view key = args[i];\n \n-    range_opts.start = opts.stream_ids.at(key);\n+    auto sitem = opts.stream_ids.at(key);\n+    if (!sitem.group && opts.read_group) {\n+      continue;\n+    }\n+    range_opts.start = sitem.id;\n+    range_opts.group = sitem.group;\n+    range_opts.consumer = sitem.consumer;\n+    range_opts.noack = opts.noack;\n \n-    auto range_res = OpRange(op_args, key, range_opts);\n+    OpResult<RecordVec> range_res;\n+\n+    if (opts.serve_history)\n+      range_res = OpRangeFromConsumerPEL(op_args, key, range_opts);\n+    else\n+      range_res = OpRange(op_args, key, range_opts);\n     if (range_res) {\n       response[i] = std::move(range_res.value());\n     }\n@@ -817,6 +925,45 @@ OpStatus OpDestroyGroup(const OpArgs& op_args, string_view key, string_view gnam\n   return OpStatus::SKIPPED;\n }\n \n+struct GroupConsumerPair {\n+  streamCG* group;\n+  streamConsumer* consumer;\n+};\n+\n+struct GroupConsumerPairOpts {\n+  string_view group;\n+  string_view consumer;\n+};\n+\n+vector<GroupConsumerPair> OpGetGroupConsumerPairs(ArgSlice slice_args, const OpArgs& op_args,\n+                                                  const GroupConsumerPairOpts& opts) {\n+  vector<GroupConsumerPair> sid_items(slice_args.size());\n+\n+  // get group and consumer\n+  for (size_t i = 0; i < slice_args.size(); i++) {\n+    string_view key = slice_args[i];\n+    streamCG* group = nullptr;\n+    streamConsumer* consumer = nullptr;\n+    auto group_res = FindGroup(op_args, key, opts.group);\n+    if (!group_res) {\n+      continue;\n+    }\n+    if (group = group_res->second; !group) {\n+      continue;\n+    }\n+\n+    op_args.shard->tmp_str1 =\n+        sdscpylen(op_args.shard->tmp_str1, opts.consumer.data(), opts.consumer.size());\n+    consumer = streamLookupConsumer(group, op_args.shard->tmp_str1, SLC_NO_REFRESH);\n+    if (!consumer) {\n+      consumer = streamCreateConsumer(group, op_args.shard->tmp_str1, NULL, 0,\n+                                      SCC_NO_NOTIFY | SCC_NO_DIRTIFY);\n+    }\n+    sid_items[i] = {group, consumer};\n+  }\n+  return sid_items;\n+}\n+\n // XGROUP CREATECONSUMER key groupname consumername\n OpResult<uint32_t> OpCreateConsumer(const OpArgs& op_args, string_view key, string_view gname,\n                                     string_view consumer_name) {\n@@ -1354,12 +1501,35 @@ void StreamFamily::XRevRange(CmdArgList args, ConnectionContext* cntx) {\n   XRangeGeneric(std::move(args), true, cntx);\n }\n \n-std::optional<ReadOpts> ParseReadArgsOrReply(CmdArgList args, ConnectionContext* cntx) {\n+std::optional<ReadOpts> ParseReadArgsOrReply(CmdArgList args, bool read_group,\n+                                             ConnectionContext* cntx) {\n   size_t streams_count = 0;\n \n   ReadOpts opts;\n+  opts.read_group = read_group;\n+  size_t id_indx = 0;\n+\n+  if (opts.read_group) {\n+    ToUpper(&args[id_indx]);\n+    string_view arg = ArgS(args, id_indx);\n+\n+    if (arg.size() - 1 < 2) {\n+      (*cntx)->SendError(kSyntaxErr);\n+      return std::nullopt;\n+    }\n+\n+    if (arg != \"GROUP\") {\n+      const auto m = \"Missing 'GROUP' in 'XREADGROUP' command\";\n+      (*cntx)->SendError(m, kSyntaxErr);\n+      return std::nullopt;\n+    }\n+    id_indx++;\n+    opts.group_name = ArgS(args, id_indx);\n+    opts.consumer_name = ArgS(args, ++id_indx);\n+    id_indx++;\n+  }\n \n-  for (size_t id_indx = 0; id_indx < args.size(); ++id_indx) {\n+  for (; id_indx < args.size(); ++id_indx) {\n     ToUpper(&args[id_indx]);\n     string_view arg = ArgS(args, id_indx);\n \n@@ -1378,13 +1548,14 @@ std::optional<ReadOpts> ParseReadArgsOrReply(CmdArgList args, ConnectionContext*\n         (*cntx)->SendError(kInvalidIntErr);\n         return std::nullopt;\n       }\n+    } else if (opts.read_group && arg == \"NOACK\") {\n+      opts.noack = true;\n     } else if (arg == \"STREAMS\" && remaining_args) {\n       opts.streams_arg = id_indx + 1;\n \n       size_t pair_count = args.size() - opts.streams_arg;\n       if ((pair_count % 2) != 0) {\n-        const auto m =\n-            \"Unbalanced 'XREAD' list of streams: for each stream key an ID must be specified\";\n+        const auto m = \"Unbalanced list of streams: for each stream key an ID must be specified\";\n         (*cntx)->SendError(m, kSyntaxErr);\n         return std::nullopt;\n       }\n@@ -1407,25 +1578,45 @@ std::optional<ReadOpts> ParseReadArgsOrReply(CmdArgList args, ConnectionContext*\n     string_view key = ArgS(args, i - streams_count);\n     string_view idstr = ArgS(args, i);\n \n+    StreamIDsItem sitem;\n     ParsedStreamId id;\n \n     if (idstr == \"$\") {\n       // Set ID to 0 so if the ID cannot be resolved (when the stream doesn't\n       // exist) it takes the first entry added.\n+      if (opts.read_group) {\n+        (*cntx)->SendError(\"The $ can be specified only when calling XREAD.\", kSyntaxErr);\n+        return std::nullopt;\n+      }\n       id.val.ms = 0;\n       id.val.seq = 0;\n       id.last_id = true;\n-      opts.stream_ids.emplace(key, id);\n+      sitem.id = id;\n+      auto [_, is_inserted] = opts.stream_ids.emplace(key, sitem);\n+      if (!is_inserted) {\n+        (*cntx)->SendError(kSameStreamFound);\n+        return std::nullopt;\n+      }\n       continue;\n     }\n \n     if (idstr == \">\") {\n-      // XREADGROUP is not supported.\n-      (*cntx)->SendError(\n-          \"The > ID can be specified only when calling XREADGROUP using the GROUP <group> \"\n-          \"<consumer> option.\",\n-          kSyntaxErr);\n-      return std::nullopt;\n+      if (!opts.read_group) {\n+        (*cntx)->SendError(\n+            \"The > ID can be specified only when calling XREADGROUP using the GROUP <group> \"\n+            \"<consumer> option.\",\n+            kSyntaxErr);\n+        return std::nullopt;\n+      }\n+      id.val.ms = UINT64_MAX;\n+      id.val.seq = UINT64_MAX;\n+      sitem.id = id;\n+      auto [_, is_inserted] = opts.stream_ids.emplace(key, sitem);\n+      if (!is_inserted) {\n+        (*cntx)->SendError(kSameStreamFound);\n+        return std::nullopt;\n+      }\n+      continue;\n     }\n \n     if (!ParseID(idstr, true, 0, &id)) {\n@@ -1436,9 +1627,13 @@ std::optional<ReadOpts> ParseReadArgsOrReply(CmdArgList args, ConnectionContext*\n     // We only include messages with IDs greater than start so increment the\n     // starting ID.\n     streamIncrID(&id.val);\n-    opts.stream_ids.emplace(key, id);\n+    sitem.id = id;\n+    auto [_, is_inserted] = opts.stream_ids.emplace(key, sitem);\n+    if (!is_inserted) {\n+      (*cntx)->SendError(kSameStreamFound);\n+      return std::nullopt;\n+    }\n   }\n-\n   return opts;\n }\n \n@@ -1498,7 +1693,12 @@ void XReadBlock(ReadOpts opts, ConnectionContext* cntx) {\n                                           .ms = UINT64_MAX,\n                                           .seq = UINT64_MAX,\n                                       }};\n-      range_opts.start = opts.stream_ids.at(*wake_key);\n+      auto sitem = opts.stream_ids.at(*wake_key);\n+      range_opts.start = sitem.id;\n+      range_opts.group = sitem.group;\n+      range_opts.consumer = sitem.consumer;\n+      range_opts.noack = opts.noack;\n+\n       result = OpRange(t->GetOpArgs(shard), *wake_key, range_opts);\n       key = *wake_key;\n     }\n@@ -1530,14 +1730,8 @@ void XReadBlock(ReadOpts opts, ConnectionContext* cntx) {\n   }\n }\n \n-void StreamFamily::XRead(CmdArgList args, ConnectionContext* cntx) {\n-  auto opts = ParseReadArgsOrReply(args, cntx);\n-  if (!opts) {\n-    return;\n-  }\n-\n-  cntx->transaction->Schedule();\n-\n+// Read entries from given streams\n+void XReadImpl(CmdArgList args, std::optional<ReadOpts> opts, ConnectionContext* cntx) {\n   auto last_ids = StreamLastIDs(cntx->transaction);\n   if (!last_ids) {\n     // Close the transaction.\n@@ -1555,21 +1749,37 @@ void StreamFamily::XRead(CmdArgList args, ConnectionContext* cntx) {\n   // Resolve '$' IDs and check if there are any streams with entries that can\n   // be resolved without blocking.\n   bool block = true;\n-  for (auto& [stream, requested_id] : opts->stream_ids) {\n+  for (auto& [stream, requested_sitem] : opts->stream_ids) {\n     if (auto last_id_it = last_ids->find(stream); last_id_it != last_ids->end()) {\n       streamID last_id = last_id_it->second;\n \n+      if (opts->read_group && !requested_sitem.group) {\n+        // if the group associated with the key is not found,\n+        // we will not read entries from the key.\n+        continue;\n+      }\n+\n       // Resolve $ to the last ID in the stream.\n-      if (requested_id.last_id) {\n-        requested_id.val = last_id;\n+      if (requested_sitem.id.last_id && !opts->read_group) {\n+        requested_sitem.id.val = last_id;\n         // We only include messages with IDs greater than the last message so\n         // increment the ID.\n-        streamIncrID(&requested_id.val);\n-        requested_id.last_id = false;\n+        streamIncrID(&requested_sitem.id.val);\n+        requested_sitem.id.last_id = false;\n         continue;\n       }\n+      if (opts->read_group) {\n+        // If '>' is not provided, consumer PEL is used. So don't need to block.\n+        if (requested_sitem.id.val.ms != UINT64_MAX || requested_sitem.id.val.seq != UINT64_MAX) {\n+          block = false;\n+          opts->serve_history = true;\n+          continue;\n+        }\n+        requested_sitem.id.val = requested_sitem.group->last_id;\n+        streamIncrID(&requested_sitem.id.val);\n+      }\n \n-      if (streamCompareID(&last_id, &requested_id.val) >= 0) {\n+      if (streamCompareID(&last_id, &requested_sitem.id.val) >= 0) {\n         block = false;\n       }\n     }\n@@ -1640,6 +1850,52 @@ void StreamFamily::XRead(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n+void XReadGeneric(CmdArgList args, bool read_group, ConnectionContext* cntx) {\n+  auto opts = ParseReadArgsOrReply(args, read_group, cntx);\n+  if (!opts) {\n+    return;\n+  }\n+\n+  vector<vector<GroupConsumerPair>> res_pairs(shard_set->size());\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    auto sid = shard->shard_id();\n+    auto s_args = t->GetShardArgs(sid);\n+    GroupConsumerPairOpts gc_opts = {opts->group_name, opts->consumer_name};\n+\n+    res_pairs[sid] = OpGetGroupConsumerPairs(s_args, t->GetOpArgs(shard), gc_opts);\n+    return OpStatus::OK;\n+  };\n+  cntx->transaction->Schedule();\n+  if (opts->read_group) {\n+    // If the command is `XReadGroup`, we need to get\n+    // the (group, consumer) pairs for each key.\n+    cntx->transaction->Execute(std::move(cb), false);\n+\n+    for (size_t i = 0; i < shard_set->size(); i++) {\n+      auto s_item = res_pairs[i];\n+      auto s_args = cntx->transaction->GetShardArgs(i);\n+      if (s_item.size() == 0) {\n+        continue;\n+      }\n+      for (size_t j = 0; j < s_args.size(); j++) {\n+        string_view key = s_args[j];\n+        StreamIDsItem& item = opts->stream_ids.at(key);\n+        item.consumer = s_item[j].consumer;\n+        item.group = s_item[j].group;\n+      }\n+    }\n+  }\n+  return XReadImpl(args, opts, cntx);\n+}\n+\n+void StreamFamily::XRead(CmdArgList args, ConnectionContext* cntx) {\n+  return XReadGeneric(args, false, cntx);\n+}\n+\n+void StreamFamily::XReadGroup(CmdArgList args, ConnectionContext* cntx) {\n+  return XReadGeneric(args, true, cntx);\n+}\n+\n void StreamFamily::XSetId(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n   string_view idstr = ArgS(args, 1);\n@@ -1763,6 +2019,8 @@ void StreamFamily::Register(CommandRegistry* registry) {\n             << CI{\"XREVRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(XRevRange)\n             << CI{\"XREAD\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 3, 3, 1}\n                    .HFUNC(XRead)\n+            << CI{\"XREADGROUP\", CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -6, 6, 6, 1}\n+                   .HFUNC(XReadGroup)\n             << CI{\"XSETID\", CO::WRITE | CO::DENYOOM, 3, 1, 1, 1}.HFUNC(XSetId)\n             << CI{\"XTRIM\", CO::WRITE | CO::FAST, -4, 1, 1, 1}.HFUNC(XTrim)\n             << CI{\"_XGROUP_HELP\", CO::NOSCRIPT | CO::HIDDEN, 2, 0, 0, 0}.SetHandler(XGroupHelp);\ndiff --git a/src/server/stream_family.h b/src/server/stream_family.h\nindex 9c3e9137db4b..f964ce766a48 100644\n--- a/src/server/stream_family.h\n+++ b/src/server/stream_family.h\n@@ -24,6 +24,7 @@ class StreamFamily {\n   static void XRevRange(CmdArgList args, ConnectionContext* cntx);\n   static void XRange(CmdArgList args, ConnectionContext* cntx);\n   static void XRead(CmdArgList args, ConnectionContext* cntx);\n+  static void XReadGroup(CmdArgList args, ConnectionContext* cntx);\n   static void XSetId(CmdArgList args, ConnectionContext* cntx);\n   static void XTrim(CmdArgList args, ConnectionContext* cntx);\n   static void XRangeGeneric(CmdArgList args, bool is_rev, ConnectionContext* cntx);\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 834ee4c421d7..11339f3f243c 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1414,7 +1414,7 @@ OpResult<KeyIndex> DetermineKeys(const CommandId* cid, CmdArgList args) {\n \n     string_view name{cid->name()};\n \n-    if (name == \"XREAD\") {\n+    if (name == \"XREAD\" || name == \"XREADGROUP\") {\n       for (size_t i = 0; i < args.size(); ++i) {\n         string_view arg = ArgS(args, i);\n         if (absl::EqualsIgnoreCase(arg, \"STREAMS\")) {\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 325337c79f06..2d2944a62229 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -159,6 +159,86 @@ TEST_F(StreamFamilyTest, XRead) {\n   EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n }\n \n+TEST_F(StreamFamilyTest, XReadGroup) {\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k1\", \"v1\"});\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k2\", \"v2\"});\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k3\", \"v3\"});\n+  Run({\"xadd\", \"bar\", \"1-*\", \"k4\", \"v4\"});\n+\n+  Run({\"xadd\", \"mystream\", \"k1\", \"v1\"});\n+  Run({\"xadd\", \"mystream\", \"k2\", \"v2\"});\n+  Run({\"xadd\", \"mystream\", \"k3\", \"v3\"});\n+\n+  Run({\"xgroup\", \"create\", \"foo\", \"group\", \"0\"});\n+  Run({\"xgroup\", \"create\", \"bar\", \"group\", \"0\"});\n+\n+  // consumer PEL is empty, so resp should have empty list\n+  auto resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+\n+  // should return unread entries with key \"foo\"\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \">\"});\n+  // only \"foo\" key entries are read\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec()[1], ArrLen(3));\n+\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k5\", \"v5\"});\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"bar\", \"foo\", \">\", \">\"});\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec()[0].GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n+  EXPECT_THAT(resp.GetVec()[0].GetVec()[1].GetVec()[0].GetVec(), ElementsAre(\"1-0\", ArrLen(2)));\n+  EXPECT_THAT(resp.GetVec()[1].GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n+  EXPECT_THAT(resp.GetVec()[1].GetVec()[1].GetVec()[0].GetVec(), ElementsAre(\"1-3\", ArrLen(2)));\n+\n+  // now we can specify id for \"foo\" and it fetches from alice's consumer PEL\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp.GetVec()[1], ArrLen(4));\n+\n+  // now \">\" gives nil\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \">\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+\n+  // count limits the fetched entries\n+  resp = Run(\n+      {\"xreadgroup\", \"group\", \"group\", \"alice\", \"count\", \"2\", \"streams\", \"foo\", \"bar\", \"0\", \"0\"});\n+  EXPECT_THAT(resp.GetVec()[0].GetVec(), ElementsAre(\"foo\", ArrLen(2)));\n+  EXPECT_THAT(resp.GetVec()[1].GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n+\n+  // bob will not get entries of alice\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+\n+  resp = Run({\"xinfo\", \"groups\", \"foo\"});\n+  // 2 consumers created\n+  EXPECT_THAT(resp.GetVec()[3], IntArg(2));\n+  // check last_delivery_id\n+  EXPECT_THAT(resp.GetVec()[7], \"1-3\");\n+\n+  // Noack\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k6\", \"v6\"});\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"noack\", \"streams\", \"foo\", \">\"});\n+  // check basic results\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n+  // Entry is not inserted in Bob's consumer PEL.\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+\n+  // No Group\n+  resp = Run({\"xreadgroup\", \"group\", \"nogroup\", \"alice\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+\n+  // '>' gives the null array result if group doesn't exist\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"mystream\", \">\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k7\", \"v7\"});\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"mystream\", \"foo\", \">\", \">\"});\n+  // Only entries of 'foo' is read\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n+}\n+\n TEST_F(StreamFamilyTest, XReadBlock) {\n   Run({\"xadd\", \"foo\", \"1-*\", \"k1\", \"v1\"});\n   Run({\"xadd\", \"foo\", \"1-*\", \"k2\", \"v2\"});\n@@ -197,6 +277,51 @@ TEST_F(StreamFamilyTest, XReadBlock) {\n   EXPECT_THAT(resp1.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n }\n \n+TEST_F(StreamFamilyTest, XReadGroupBlock) {\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k1\", \"v1\"});\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k2\", \"v2\"});\n+  Run({\"xadd\", \"foo\", \"1-*\", \"k3\", \"v3\"});\n+  Run({\"xadd\", \"bar\", \"1-*\", \"k4\", \"v4\"});\n+\n+  Run({\"xgroup\", \"create\", \"foo\", \"group\", \"0\"});\n+  Run({\"xgroup\", \"create\", \"bar\", \"group\", \"0\"});\n+\n+  // Receive all records from both streams.\n+  auto resp = Run(\n+      {\"xreadgroup\", \"group\", \"group\", \"alice\", \"block\", \"100\", \"streams\", \"foo\", \"bar\", \">\", \">\"});\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec()[0].GetVec(), ElementsAre(\"foo\", ArrLen(3)));\n+  EXPECT_THAT(resp.GetVec()[1].GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n+\n+  // Timeout\n+  resp = Run(\n+      {\"xreadgroup\", \"group\", \"group\", \"alice\", \"block\", \"1\", \"streams\", \"foo\", \"bar\", \">\", \">\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+\n+  // Run XREADGROUP BLOCK from 2 fibers.\n+  RespExpr resp0, resp1;\n+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+    resp0 = Run(\n+        {\"xreadgroup\", \"group\", \"group\", \"alice\", \"block\", \"0\", \"streams\", \"foo\", \"bar\", \">\", \">\"});\n+  });\n+  auto fb1 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&] {\n+    resp1 = Run(\n+        {\"xreadgroup\", \"group\", \"group\", \"alice\", \"block\", \"0\", \"streams\", \"foo\", \"bar\", \">\", \">\"});\n+  });\n+  ThisFiber::SleepFor(50us);\n+\n+  resp = pp_->at(1)->Await([&] { return Run(\"xadd\", {\"xadd\", \"foo\", \"1-*\", \"k5\", \"v5\"}); });\n+\n+  fb0.Join();\n+  fb1.Join();\n+\n+  // Both xread calls should have been unblocked.\n+  //\n+  // Note when the response has length 1, Run returns the first element.\n+  EXPECT_THAT(resp0.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n+  EXPECT_THAT(resp1.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n+}\n+\n TEST_F(StreamFamilyTest, XReadInvalidArgs) {\n   // Invalid COUNT value.\n   auto resp = Run({\"xread\", \"count\", \"invalid\", \"streams\", \"s1\", \"s2\", \"0\", \"0\"});\n@@ -228,6 +353,38 @@ TEST_F(StreamFamilyTest, XReadInvalidArgs) {\n   EXPECT_THAT(resp, ErrArg(\"key holding the wrong kind of value\"));\n }\n \n+TEST_F(StreamFamilyTest, XReadGroupInvalidArgs) {\n+  Run({\"xgroup\", \"create\", \"group\", \"foo\", \"0\", \"mkstream\"});\n+  // Invalid COUNT value.\n+  auto resp =\n+      Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"count\", \"invalid\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"not an integer or out of range\"));\n+\n+  // Invalid \"stream\" instead of GROUP.\n+  resp = Run({\"xreadgroup\", \"stream\", \"group\", \"alice\", \"count\", \"1\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"Missing 'GROUP' in 'XREADGROUP' command\"));\n+\n+  // Missing streams.\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments for 'xreadgroup' command\"));\n+\n+  // Missing consumer.\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Missing block value.\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"block\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"not an integer or out of range\"));\n+\n+  // Invalid block value.\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"block\", \"invalid\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"not an integer or out of range\"));\n+\n+  // Unbalanced list of streams.\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"s1\", \"s2\", \"s3\", \"0\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+}\n+\n TEST_F(StreamFamilyTest, Issue854) {\n   auto resp = Run({\"xgroup\", \"help\"});\n   EXPECT_THAT(resp, ArgType(RespExpr::ARRAY));\n",
  "problem_statement": "Implement `XREADGROUP` command\nCommand reference info - https://redis.io/commands/xreadgroup/\n",
  "hints_text": "",
  "created_at": "2023-06-24T07:00:55Z",
  "modified_files": [
    "src/server/stream_family.cc",
    "src/server/stream_family.h",
    "src/server/transaction.cc"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}