{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3910,
  "instance_id": "dragonflydb__dragonfly-3910",
  "issue_numbers": [
    "3893"
  ],
  "base_commit": "5d2c308c99a34937e06d198ba2f751cb6afdb688",
  "patch": "diff --git a/src/server/bitops_family.cc b/src/server/bitops_family.cc\nindex 043b7a49eb1d..48449efc7abf 100644\n--- a/src/server/bitops_family.cc\n+++ b/src/server/bitops_family.cc\n@@ -548,6 +548,8 @@ void BitPos(CmdArgList args, ConnectionContext* cntx) {\n \n   if (!absl::SimpleAtoi(ArgS(args, 1), &value)) {\n     return cntx->SendError(kInvalidIntErr);\n+  } else if (value != 0 && value != 1) {\n+    return cntx->SendError(\"The bit argument must be 1 or 0\");\n   }\n \n   if (args.size() >= 3) {\n@@ -1340,11 +1342,15 @@ OpResult<int64_t> FindFirstBitWithValue(const OpArgs& op_args, std::string_view\n                                         int64_t start, int64_t end, bool as_bit) {\n   OpResult<std::string> value = ReadValue(op_args.db_cntx, key, op_args.shard);\n \n-  std::string_view value_str;\n-  if (value) {  // non-existent keys are treated as empty strings, per Redis\n-    value_str = value.value();\n+  // non-existent keys are handled exactly as in Redis's implementation,\n+  // even though it contradicts its docs:\n+  //     If a clear bit isn't found in the specified range, the function returns -1\n+  //     as the user specified a clear range and there are no 0 bits in that range\n+  if (!value) {\n+    return bit_value ? -1 : 0;\n   }\n \n+  std::string_view value_str = value.value();\n   int64_t size = value_str.size();\n   if (as_bit) {\n     size *= OFFSET_FACTOR;\n",
  "test_patch": "diff --git a/src/server/bitops_family_test.cc b/src/server/bitops_family_test.cc\nindex 8eaf15dc97b0..17bcca6a0161 100644\n--- a/src/server/bitops_family_test.cc\n+++ b/src/server/bitops_family_test.cc\n@@ -555,8 +555,15 @@ TEST_F(BitOpsFamilyTest, BitPos) {\n   EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"empty\", \"0\"}));\n   EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"empty\", \"0\", \"1\"}));\n \n-  // Non-existent key should be treated like an empty string.\n-  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"d\", \"0\"}));\n+  // Non-existent key should be treated like padded with zeros string.\n+  EXPECT_EQ(-1, CheckedInt({\"bitpos\", \"d\", \"1\"}));\n+  EXPECT_EQ(0, CheckedInt({\"bitpos\", \"d\", \"0\"}));\n+\n+  // Make sure we accept only 0 and 1 for the bit mode arguement.\n+  const auto argument_must_be_0_or_1_error = ErrArg(\"ERR The bit argument must be 1 or 0\");\n+  ASSERT_THAT(Run({\"bitpos\", \"d\", \"2\"}), argument_must_be_0_or_1_error);\n+  ASSERT_THAT(Run({\"bitpos\", \"d\", \"42\"}), argument_must_be_0_or_1_error);\n+  ASSERT_THAT(Run({\"bitpos\", \"d\", \"-1\"}), argument_must_be_0_or_1_error);\n }\n \n TEST_F(BitOpsFamilyTest, BitFieldParsing) {\n",
  "problem_statement": "improve BITPOS command\nCurrently, the [`BITPOS`](https://www.dragonflydb.io/docs/command-reference/strings/bitpos) command works fine for normal cases. However, for some edge cases, it's not behaving the same as Redis/Valkey. It's better to improve this command for edge cases.\r\n\r\nSpecifically:\r\n\r\n- The `bit` parameter should accept only `0` or `1`:\r\n\r\n  ```shell\r\n  dragonfly$> SET mykey \"\\xff\\xf0\\x00\"\r\n  OK\r\n\r\n  dragonfly$> BITPOS mykey 0\r\n  (integer) 12\r\n\r\n  dragonfly$> BITPOS mykey 1\r\n  (integer) 0\r\n\r\n  dragonfly$> BITPOS mykey 2 # Should throw an error here.\r\n  (integer) 0\r\n  ```\r\n\r\n- For non-existent or empty strings, Dragonfly always returns `-1`, which makes sense to me. But for compatibility purpose, this can be improved as well so that client SDKs can deal with it better. See example and details below.\r\n\r\n  ```shell\r\n  dragonfly$> BITPOS non_existent_key 0 # Should return 0 instead of -1 when searching clear bit in empty string.\r\n  (integer) -1\r\n  \r\n  dragonfly$> BITPOS non_existent_key 1\r\n  (integer) -1\r\n  ```\r\n\r\n  Taking from the Redis [doc](https://redis.io/docs/latest/commands/bitpos/):\r\n  > [Integer reply](https://redis.io/docs/latest/develop/reference/protocol-spec#integers): the position of the first bit set to 1 or 0 according to the request\r\n  > [Integer reply](https://redis.io/docs/latest/develop/reference/protocol-spec#integers): -1. In case the bit argument is 1 and the string is empty or composed of just zero bytes\r\n\r\n  > If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.\r\n\r\n  > If we look for clear bits (the bit argument is 0) and the string only contains bits set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value 0xff the command BITPOS key 0 will return 24, since up to bit 23 all the bits are 1.\r\n\r\n  > The function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the start argument only.\r\n\r\n  > However, this behavior changes if you are looking for clear bits and specify a range with both start and end. If a clear bit isn't found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.\n",
  "hints_text": "I think this can be a `hacktoberfest` and a `good first issue`. @romange \nSure\nHey, do you mind if i take it?\n@Diskein sure!",
  "created_at": "2024-10-11T21:21:20Z",
  "modified_files": [
    "src/server/bitops_family.cc"
  ],
  "modified_test_files": [
    "src/server/bitops_family_test.cc"
  ]
}