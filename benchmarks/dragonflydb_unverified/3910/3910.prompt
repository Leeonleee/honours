You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
improve BITPOS command
Currently, the [`BITPOS`](https://www.dragonflydb.io/docs/command-reference/strings/bitpos) command works fine for normal cases. However, for some edge cases, it's not behaving the same as Redis/Valkey. It's better to improve this command for edge cases.

Specifically:

- The `bit` parameter should accept only `0` or `1`:

  ```shell
  dragonfly$> SET mykey "\xff\xf0\x00"
  OK

  dragonfly$> BITPOS mykey 0
  (integer) 12

  dragonfly$> BITPOS mykey 1
  (integer) 0

  dragonfly$> BITPOS mykey 2 # Should throw an error here.
  (integer) 0
  ```

- For non-existent or empty strings, Dragonfly always returns `-1`, which makes sense to me. But for compatibility purpose, this can be improved as well so that client SDKs can deal with it better. See example and details below.

  ```shell
  dragonfly$> BITPOS non_existent_key 0 # Should return 0 instead of -1 when searching clear bit in empty string.
  (integer) -1
  
  dragonfly$> BITPOS non_existent_key 1
  (integer) -1
  ```

  Taking from the Redis [doc](https://redis.io/docs/latest/commands/bitpos/):
  > [Integer reply](https://redis.io/docs/latest/develop/reference/protocol-spec#integers): the position of the first bit set to 1 or 0 according to the request
  > [Integer reply](https://redis.io/docs/latest/develop/reference/protocol-spec#integers): -1. In case the bit argument is 1 and the string is empty or composed of just zero bytes

  > If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.

  > If we look for clear bits (the bit argument is 0) and the string only contains bits set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value 0xff the command BITPOS key 0 will return 24, since up to bit 23 all the bits are 1.

  > The function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the start argument only.

  > However, this behavior changes if you are looking for clear bits and specify a range with both start and end. If a clear bit isn't found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
