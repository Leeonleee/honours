{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5006,
  "instance_id": "dragonflydb__dragonfly-5006",
  "issue_numbers": [
    "5005"
  ],
  "base_commit": "71dd189ebdd89764bb39badaead21c0fceccdc01",
  "patch": "diff --git a/src/server/cluster_support.cc b/src/server/cluster_support.cc\nindex aea847ed015d..47754287da01 100644\n--- a/src/server/cluster_support.cc\n+++ b/src/server/cluster_support.cc\n@@ -17,6 +17,10 @@ ABSL_FLAG(string, cluster_mode, \"\",\n           \"Cluster mode supported. Possible values are \"\n           \"'emulated', 'yes' or ''\");\n \n+ABSL_FLAG(bool, experimental_cluster_shard_by_slot, false,\n+          \"If true, cluster mode is enabled and sharding is done by slot. \"\n+          \"Otherwise, sharding is done by hash tag.\");\n+\n namespace dfly {\n \n void UniqueSlotChecker::Add(std::string_view key) {\n@@ -43,16 +47,13 @@ optional<SlotId> UniqueSlotChecker::GetUniqueSlotId() const {\n   return slot_id_ > kMaxSlotNum ? optional<SlotId>() : slot_id_;\n }\n \n-namespace {\n-enum class ClusterMode {\n-  kUninitialized,\n-  kNoCluster,\n-  kEmulatedCluster,\n-  kRealCluster,\n-};\n-\n+namespace detail {\n ClusterMode cluster_mode = ClusterMode::kUninitialized;\n-}  // namespace\n+bool cluster_shard_by_slot = false;\n+\n+}  // namespace detail\n+\n+using namespace detail;\n \n void InitializeCluster() {\n   string cluster_mode_str = absl::GetFlag(FLAGS_cluster_mode);\n@@ -67,14 +68,10 @@ void InitializeCluster() {\n     LOG(ERROR) << \"Invalid value for flag --cluster_mode. Exiting...\";\n     exit(1);\n   }\n-}\n \n-bool IsClusterEnabled() {\n-  return cluster_mode == ClusterMode::kRealCluster;\n-}\n-\n-bool IsClusterEmulated() {\n-  return cluster_mode == ClusterMode::kEmulatedCluster;\n+  if (cluster_mode != ClusterMode::kNoCluster) {\n+    cluster_shard_by_slot = absl::GetFlag(FLAGS_experimental_cluster_shard_by_slot);\n+  }\n }\n \n SlotId KeySlot(std::string_view key) {\n@@ -82,10 +79,6 @@ SlotId KeySlot(std::string_view key) {\n   return crc16(tag.data(), tag.length()) & kMaxSlotNum;\n }\n \n-bool IsClusterEnabledOrEmulated() {\n-  return IsClusterEnabled() || IsClusterEmulated();\n-}\n-\n bool IsClusterShardedByTag() {\n   return IsClusterEnabledOrEmulated() || LockTagOptions::instance().enabled;\n }\ndiff --git a/src/server/cluster_support.h b/src/server/cluster_support.h\nindex 48de740cfd37..01a230531b68 100644\n--- a/src/server/cluster_support.h\n+++ b/src/server/cluster_support.h\n@@ -10,6 +10,20 @@\n \n namespace dfly {\n \n+namespace detail {\n+\n+enum class ClusterMode {\n+  kUninitialized,\n+  kNoCluster,\n+  kEmulatedCluster,\n+  kRealCluster,\n+};\n+\n+extern ClusterMode cluster_mode;\n+extern bool cluster_shard_by_slot;\n+\n+};  // namespace detail\n+\n using SlotId = std::uint16_t;\n constexpr SlotId kMaxSlotNum = 0x3FFF;\n \n@@ -42,9 +56,23 @@ class UniqueSlotChecker {\n SlotId KeySlot(std::string_view key);\n \n void InitializeCluster();\n-bool IsClusterEnabled();\n-bool IsClusterEmulated();\n-bool IsClusterEnabledOrEmulated();\n+\n+inline bool IsClusterEnabled() {\n+  return detail::cluster_mode == detail::ClusterMode::kRealCluster;\n+}\n+\n+inline bool IsClusterEmulated() {\n+  return detail::cluster_mode == detail::ClusterMode::kEmulatedCluster;\n+}\n+\n+inline bool IsClusterEnabledOrEmulated() {\n+  return IsClusterEnabled() || IsClusterEmulated();\n+}\n+\n+inline bool IsClusterShardedBySlot() {\n+  return detail::cluster_shard_by_slot;\n+}\n+\n bool IsClusterShardedByTag();\n \n }  // namespace dfly\ndiff --git a/src/server/engine_shard.cc b/src/server/engine_shard.cc\nindex 6a36458c75bc..be401c45e4fa 100644\n--- a/src/server/engine_shard.cc\n+++ b/src/server/engine_shard.cc\n@@ -261,6 +261,17 @@ __thread EngineShard* EngineShard::shard_ = nullptr;\n uint64_t TEST_current_time_ms = 0;\n \n ShardId Shard(string_view v, ShardId shard_num) {\n+  // This cluster sharding is not necessary and may degrade keys distribution among shard threads.\n+  // For example, if we have 3 shards, then no single-char keys will be assigned to shard 2 and\n+  // 32 single char keys in range ['_' - '~'] will be assigned to shard 0.\n+  // Yes, SlotId function does not have great distribution properties.\n+  // On the other side, slot based sharding may help with pipeline squashing optimizations,\n+  // because they rely on commands being single-sharded.\n+  // TODO: once we improve our squashing logic, we can remove this.\n+  if (IsClusterShardedBySlot()) {\n+    return KeySlot(v) % shard_num;\n+  }\n+\n   if (IsClusterShardedByTag()) {\n     v = LockTagOptions::instance().Tag(v);\n   }\n",
  "test_patch": "diff --git a/src/server/hll_family_test.cc b/src/server/hll_family_test.cc\nindex 7d162fc4fa63..4b52924daa54 100644\n--- a/src/server/hll_family_test.cc\n+++ b/src/server/hll_family_test.cc\n@@ -194,6 +194,8 @@ TEST_F(HllFamilyTest, MergeOverlapping) {\n }\n \n TEST_F(HllFamilyTest, MergeInvalid) {\n+  GTEST_SKIP() << \"TBD: MergeInvalid test fails with multi-shard runs, see #5004\";\n+\n   EXPECT_EQ(CheckedInt({\"pfadd\", \"key1\", \"1\", \"2\", \"3\"}), 1);\n   EXPECT_EQ(Run({\"set\", \"key2\", \"...\"}), \"OK\");\n   EXPECT_THAT(Run({\"pfmerge\", \"key1\", \"key2\"}), ErrArg(HllFamily::kInvalidHllErr));\n",
  "problem_statement": "optionally shard keys by slot id in cluster mode\nThis serves as a short term fix for a performance bug where pipeline squashing in cluster mode may meet\nmulti-shard but single slot commands that will hamper its efficiency.\n",
  "hints_text": "",
  "created_at": "2025-04-26T07:29:34Z",
  "modified_files": [
    "src/server/cluster_support.cc",
    "src/server/cluster_support.h",
    "src/server/engine_shard.cc"
  ],
  "modified_test_files": [
    "src/server/hll_family_test.cc"
  ]
}