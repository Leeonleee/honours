{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3473,
  "instance_id": "dragonflydb__dragonfly-3473",
  "issue_numbers": [
    "3470"
  ],
  "base_commit": "7b9bbc19d7df29a7b8651ed9060eb11ef883d5e0",
  "patch": "diff --git a/src/server/replica.cc b/src/server/replica.cc\nindex a7a13d8f69e2..2189f703ecf6 100644\n--- a/src/server/replica.cc\n+++ b/src/server/replica.cc\n@@ -289,7 +289,8 @@ error_code Replica::Greet() {\n   auto announce_ip = absl::GetFlag(FLAGS_announce_ip);\n   if (!announce_ip.empty()) {\n     RETURN_ON_ERR(SendCommandAndReadResponse(StrCat(\"REPLCONF ip-address \", announce_ip)));\n-    PC_RETURN_ON_BAD_RESPONSE(CheckRespIsSimpleReply(\"OK\"));\n+    LOG_IF(WARNING, !CheckRespIsSimpleReply(\"OK\"))\n+        << \"Master did not OK announced IP address, perhaps it is using an old version\";\n   }\n \n   // Corresponds to server.repl_state == REPL_STATE_SEND_CAPA\n",
  "test_patch": "diff --git a/tests/dragonfly/instance.py b/tests/dragonfly/instance.py\nindex 8aaa5a37130c..7d2fac7c9cb5 100644\n--- a/tests/dragonfly/instance.py\n+++ b/tests/dragonfly/instance.py\n@@ -334,7 +334,7 @@ def __init__(self, params: DflyParams, args):\n         self.params = params\n         self.instances = []\n \n-    def create(self, existing_port=None, **kwargs) -> DflyInstance:\n+    def create(self, existing_port=None, path=None, **kwargs) -> DflyInstance:\n         args = {**self.args, **kwargs}\n         args.setdefault(\"dbfilename\", \"\")\n         args.setdefault(\"noversion_check\", None)\n@@ -352,6 +352,10 @@ def create(self, existing_port=None, **kwargs) -> DflyInstance:\n             params = dataclasses.replace(self.params, existing_port=existing_port)\n         else:\n             params = self.params\n+\n+        if path is not None:\n+            params = dataclasses.replace(self.params, path=path)\n+\n         instance = DflyInstance(params, args)\n         self.instances.append(instance)\n         return instance\ndiff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex 11d64ae1ee80..24223d5b3eae 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -4,8 +4,11 @@\n import pytest\n import asyncio\n import async_timeout\n+import platform\n import pymemcache\n import logging\n+import tarfile\n+import urllib.request\n from redis import asyncio as aioredis\n from .utility import *\n from .instance import DflyInstanceFactory, DflyInstance\n@@ -2261,3 +2264,67 @@ async def check_replica_disconnected():\n     await asyncio.sleep(1)  # wait for the master to recognize it's being blocked\n     await check_replica_disconnected()\n     df_factory.stop_all()\n+\n+\n+def download_dragonfly_release(version):\n+    path = f\"/tmp/{tmp_file_name()}\"\n+    os.mkdir(path)\n+    gzfile = f\"{path}/dragonfly.tar.gz\"\n+    logging.debug(f\"Downloading Dragonfly release into {gzfile}...\")\n+\n+    # Download\n+    urllib.request.urlretrieve(\n+        f\"https://github.com/dragonflydb/dragonfly/releases/download/{version}/dragonfly-x86_64.tar.gz\",\n+        gzfile,\n+    )\n+\n+    # Extract\n+    file = tarfile.open(gzfile)\n+    file.extractall(path)\n+    file.close()\n+\n+    # Return path\n+    return f\"{path}/dragonfly-x86_64\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"cluster_mode, announce_ip, announce_port\",\n+    [\n+        (\"\", \"localhost\", 7000),\n+        (\"emulated\", \"\", 0),\n+        (\"emulated\", \"localhost\", 7000),\n+    ],\n+)\n+async def test_replicate_old_master(\n+    df_factory: DflyInstanceFactory, cluster_mode, announce_ip, announce_port\n+):\n+    cpu = platform.processor()\n+    if cpu != \"x86_64\":\n+        pytest.skip(f\"Supported only on x64, running on {cpu}\")\n+\n+    dfly_version = \"v1.19.2\"\n+    released_dfly_path = download_dragonfly_release(dfly_version)\n+    master = df_factory.create(path=released_dfly_path, cluster_mode=cluster_mode)\n+    replica = df_factory.create(\n+        cluster_mode=cluster_mode, announce_ip=announce_ip, announce_port=announce_port\n+    )\n+\n+    df_factory.start_all([master, replica])\n+\n+    c_master = master.client()\n+    c_replica = replica.client()\n+\n+    assert (\n+        f\"df-{dfly_version}\"\n+        == (await c_master.execute_command(\"info\", \"server\"))[\"dragonfly_version\"]\n+    )\n+    assert \"df-dev\" == (await c_replica.execute_command(\"info\", \"server\"))[\"dragonfly_version\"]\n+\n+    await c_master.execute_command(\"set\", \"k1\", \"v1\")\n+\n+    assert await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\") == \"OK\"\n+    await wait_available_async(c_replica)\n+\n+    assert await c_replica.execute_command(\"get\", \"k1\") == \"v1\"\n+\n+    await disconnect_clients(c_master, c_replica)\n",
  "problem_statement": "New version replication regression test\nWe should implement a new regression test that checks if we can successfully attach a replica (built from `HEAD`) to a master running a released version.\r\n\r\nThis regression test should be parameterized and cover the following cases:\r\n1. \"Regular\" master\r\n2. Emulated-cluster master\r\n3. Replica which uses `--announce_ip` and `--announce_port`\r\n\r\nSuccess condition is whether the replica is healthy and successfully replicated all keys from the master.\r\n\r\nTo run the master we can simply download a released version. We can hardcode this version (URL) and update it every once in a while if easier.\n",
  "hints_text": "",
  "created_at": "2024-08-08T12:47:49Z",
  "modified_files": [
    "src/server/replica.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/instance.py",
    "tests/dragonfly/replication_test.py"
  ]
}