{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2879,
  "instance_id": "dragonflydb__dragonfly-2879",
  "issue_numbers": [
    "2870"
  ],
  "base_commit": "eb164be596e3e5ba67312a2b44e79d0f2a0ec72c",
  "patch": "diff --git a/src/facade/error.h b/src/facade/error.h\nindex bc24278820ae..3eaf060cfc84 100644\n--- a/src/facade/error.h\n+++ b/src/facade/error.h\n@@ -32,6 +32,7 @@ extern const char kOutOfMemory[];\n extern const char kInvalidNumericResult[];\n extern const char kClusterNotConfigured[];\n extern const char kLoadingErr[];\n+extern const char kUndeclaredKeyErr[];\n \n extern const char kSyntaxErrType[];\n extern const char kScriptErrType[];\ndiff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex f5a832ad0d8f..d6487fe9dd9d 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -42,7 +42,7 @@ ConnectionStats& ConnectionStats::operator+=(const ConnectionStats& o) {\n }\n \n ReplyStats& ReplyStats::operator+=(const ReplyStats& o) {\n-  static_assert(sizeof(ReplyStats) == 64u + kSanitizerOverhead);\n+  static_assert(sizeof(ReplyStats) == 72u + kSanitizerOverhead);\n   ADD(io_write_cnt);\n   ADD(io_write_bytes);\n \n@@ -50,6 +50,8 @@ ReplyStats& ReplyStats::operator+=(const ReplyStats& o) {\n     err_count[k_v.first] += k_v.second;\n   }\n \n+  ADD(script_error_count);\n+\n   send_stats += o.send_stats;\n \n   return *this;\n@@ -91,6 +93,7 @@ const char kOutOfMemory[] = \"Out of memory\";\n const char kInvalidNumericResult[] = \"result is not a number\";\n const char kClusterNotConfigured[] = \"Cluster is not yet configured\";\n const char kLoadingErr[] = \"-LOADING Dragonfly is loading the dataset in memory\";\n+const char kUndeclaredKeyErr[] = \"script tried accessing undeclared key\";\n \n const char kSyntaxErrType[] = \"syntax_error\";\n const char kScriptErrType[] = \"script_error\";\ndiff --git a/src/facade/facade_types.h b/src/facade/facade_types.h\nindex 035e381986e4..97079f9feda8 100644\n--- a/src/facade/facade_types.h\n+++ b/src/facade/facade_types.h\n@@ -95,6 +95,7 @@ struct ReplyStats {\n   size_t io_write_cnt = 0;\n   size_t io_write_bytes = 0;\n   absl::flat_hash_map<std::string, uint64_t> err_count;\n+  size_t script_error_count = 0;\n \n   ReplyStats& operator+=(const ReplyStats& other);\n };\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex fcc00b48235f..3b8159bc4de3 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -1084,7 +1084,7 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA\n         CheckKeysDeclared(*dfly_cntx.conn_state.script_info, cid, tail_args, dfly_cntx.transaction);\n \n     if (status == OpStatus::KEY_NOTFOUND)\n-      return ErrorReply{\"script tried accessing undeclared key\"};\n+      return ErrorReply(kUndeclaredKeyErr);\n \n     if (status != OpStatus::OK)\n       return ErrorReply{status};\n@@ -1943,6 +1943,7 @@ void Service::EvalInternal(CmdArgList args, const EvalArgs& eval_args, Interpret\n \n   if (result == Interpreter::RUN_ERR) {\n     string resp = StrCat(\"Error running script (call to \", eval_args.sha, \"): \", error);\n+    server_family_.script_mgr()->OnScriptError(eval_args.sha, error);\n     return cntx->SendError(resp, facade::kScriptErrType);\n   }\n \ndiff --git a/src/server/script_mgr.cc b/src/server/script_mgr.cc\nindex 726112dd82dc..214d9d354bde 100644\n--- a/src/server/script_mgr.cc\n+++ b/src/server/script_mgr.cc\n@@ -33,8 +33,12 @@ ABSL_FLAG(\n     bool, lua_auto_async, false,\n     \"If enabled, call/pcall with discarded values are automatically replaced with acall/apcall.\");\n \n-namespace dfly {\n+ABSL_FLAG(bool, lua_allow_undeclared_auto_correct, false,\n+          \"If enabled, when a script that is not allowed to run with undeclared keys is trying to \"\n+          \"access undeclared keys, automaticaly set the script flag to be able to run with \"\n+          \"undeclared key.\");\n \n+namespace dfly {\n using namespace std;\n using namespace facade;\n using namespace util;\n@@ -283,6 +287,29 @@ optional<ScriptMgr::ScriptData> ScriptMgr::Find(std::string_view sha) const {\n   return std::nullopt;\n }\n \n+void ScriptMgr::OnScriptError(std::string_view sha, std::string_view error) {\n+  ++tl_facade_stats->reply_stats.script_error_count;\n+  lock_guard lk{mu_};\n+  auto it = db_.find(sha);\n+  if (it == db_.end()) {\n+    return;\n+  }\n+\n+  if (++it->second.error_resp < 5) {\n+    LOG(ERROR) << \"Error running script (call to \" << sha << \"): \" << error;\n+  }\n+  // If script has undeclared_keys and was not flaged to run in this mode we will change the\n+  // script flag - this will make script next run to not fail but run as global.\n+  if (absl::GetFlag(FLAGS_lua_allow_undeclared_auto_correct)) {\n+    size_t pos = error.rfind(kUndeclaredKeyErr);\n+    if (pos != string::npos) {\n+      it->second.undeclared_keys = true;\n+      LOG(WARNING) << \"Setting undeclared_keys flag for script with sha : (\" << sha << \")\";\n+      UpdateScriptCaches(sha, it->second);\n+    }\n+  }\n+}\n+\n void ScriptMgr::FlushAllScript() {\n   lock_guard lk{mu_};\n   db_.clear();\ndiff --git a/src/server/script_mgr.h b/src/server/script_mgr.h\nindex c80296725001..ab92f96d5cb6 100644\n--- a/src/server/script_mgr.h\n+++ b/src/server/script_mgr.h\n@@ -59,6 +59,8 @@ class ScriptMgr {\n   // Returns if scripts run as global transactions by default\n   bool AreGlobalByDefault() const;\n \n+  void OnScriptError(std::string_view sha, std::string_view error);\n+\n  private:\n   void ExistsCmd(CmdArgList args, ConnectionContext* cntx) const;\n   void FlushCmd(CmdArgList args, ConnectionContext* cntx);\n@@ -73,6 +75,7 @@ class ScriptMgr {\n   struct InternalScriptData : public ScriptParams {\n     std::unique_ptr<char[]> body{};\n     std::unique_ptr<char[]> orig_body{};\n+    uint32_t error_resp = 0;\n   };\n \n   ScriptParams default_params_;\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex f4023e5431de..55854128feb0 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1146,6 +1146,9 @@ void PrintPrometheusMetrics(const Metrics& m, StringResponse* resp) {\n     }\n   }\n \n+  AppendMetricWithoutLabels(\"script_error_total\", \"\", m.facade_stats.reply_stats.script_error_count,\n+                            MetricType::COUNTER, &resp->body());\n+\n   // DB stats\n   AppendMetricWithoutLabels(\"expired_keys_total\", \"\", m.events.expired_keys, MetricType::COUNTER,\n                             &resp->body());\n@@ -1792,6 +1795,8 @@ void ServerFamily::ResetStat() {\n     tl_facade_stats->reply_stats.io_write_bytes = 0;\n     tl_facade_stats->reply_stats.io_write_cnt = 0;\n     tl_facade_stats->reply_stats.send_stats = {};\n+    tl_facade_stats->reply_stats.script_error_count = 0;\n+    tl_facade_stats->reply_stats.err_count.clear();\n \n     service_.mutable_registry()->ResetCallStats(index);\n   });\n",
  "test_patch": "diff --git a/src/server/multi_test.cc b/src/server/multi_test.cc\nindex 49ad93c4f1cb..288297acdb87 100644\n--- a/src/server/multi_test.cc\n+++ b/src/server/multi_test.cc\n@@ -19,6 +19,7 @@\n ABSL_DECLARE_FLAG(uint32_t, multi_exec_mode);\n ABSL_DECLARE_FLAG(bool, multi_exec_squash);\n ABSL_DECLARE_FLAG(bool, lua_auto_async);\n+ABSL_DECLARE_FLAG(bool, lua_allow_undeclared_auto_correct);\n ABSL_DECLARE_FLAG(std::string, default_lua_flags);\n \n namespace dfly {\n@@ -375,27 +376,36 @@ TEST_F(MultiTest, Eval) {\n     GTEST_SKIP() << \"Skipped Eval test because default_lua_flags is set\";\n     return;\n   }\n+  absl::SetFlag(&FLAGS_lua_allow_undeclared_auto_correct, true);\n \n   RespExpr resp;\n \n   resp = Run({\"incrby\", \"foo\", \"42\"});\n   EXPECT_THAT(resp, IntArg(42));\n \n+  // first time running the script will return error and will change the script flag to allow\n+  // undeclared\n   resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"0\"});\n   EXPECT_THAT(resp, ErrArg(\"undeclared\"));\n \n+  // running the same script the second time will succeed\n+  resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"0\"});\n+  EXPECT_THAT(resp, \"42\");\n+\n+  Run({\"script\", \"flush\"});\n+\n   resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"1\", \"bar\"});\n   EXPECT_THAT(resp, ErrArg(\"undeclared\"));\n-\n   ASSERT_FALSE(service_->IsLocked(0, \"foo\"));\n \n+  Run({\"script\", \"flush\"});\n+\n   resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"1\", \"foo\"});\n   EXPECT_THAT(resp, \"42\");\n   ASSERT_FALSE(service_->IsLocked(0, \"foo\"));\n \n   resp = Run({\"eval\", \"return redis.call('get', KEYS[1])\", \"1\", \"foo\"});\n   EXPECT_THAT(resp, \"42\");\n-\n   ASSERT_FALSE(service_->IsLocked(0, \"foo\"));\n   ASSERT_FALSE(service_->IsShardSetLocked());\n \n",
  "problem_statement": "bring visibility to script errors\n1. expose a metric with script errors\r\n2. Add an error log of a script SHA and the reason for failure. The error log must be bounded with at most K log entries per script so we won't have logs overflow for high throughput traffic.\r\n3. Additional feature (under a flag) upon receiving the undeclared variable error - transform the script to globally-atomic and retry the call.\n",
  "hints_text": "",
  "created_at": "2024-04-10T10:18:14Z",
  "modified_files": [
    "src/facade/error.h",
    "src/facade/facade.cc",
    "src/facade/facade_types.h",
    "src/server/main_service.cc",
    "src/server/script_mgr.cc",
    "src/server/script_mgr.h",
    "src/server/server_family.cc"
  ],
  "modified_test_files": [
    "src/server/multi_test.cc"
  ]
}