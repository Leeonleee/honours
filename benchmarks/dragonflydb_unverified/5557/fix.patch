diff --git a/helio b/helio
index 5a55e71b5b77..e6235850f5df 160000
--- a/helio
+++ b/helio
@@ -1,1 +1,1 @@
-Subproject commit 5a55e71b5b77c0594436ad4a7135e15d388ba6ab
+Subproject commit e6235850f5dfa8b4e238ece802f5c1c1fa443b53
diff --git a/src/core/dash_internal.h b/src/core/dash_internal.h
index 5108b397d2c3..73546c598df2 100644
--- a/src/core/dash_internal.h
+++ b/src/core/dash_internal.h
@@ -1013,6 +1013,11 @@ ___] |___ |__] |  | |___ | \|  |
 
 */
 
+// for clang ignore -Wunused-lambda-capture
+#ifdef __clang__
+#pragma clang diagnostic ignored "-Wunused-lambda-capture"
+#endif
+
 template <typename Key, typename Value, typename Policy>
 template <typename Pred>
 auto Segment<Key, Value, Policy>::Bucket::FindByFp(uint8_t fp_hash, bool probe, Pred&& pred) const
diff --git a/src/core/page_usage_stats.cc b/src/core/page_usage_stats.cc
index 81a1d2913786..4dcca93d38d2 100644
--- a/src/core/page_usage_stats.cc
+++ b/src/core/page_usage_stats.cc
@@ -19,8 +19,8 @@ PageUsage::PageUsage(CollectPageStats collect_stats, float threshold)
 }
 
 bool PageUsage::IsPageForObjectUnderUtilized(void* object) {
-  mi_page_usage_stats_t stat =
-      zmalloc_page_is_underutilized(object, threshold_, collect_stats_ == CollectPageStats::YES);
+  mi_page_usage_stats_t stat;
+  zmalloc_page_is_underutilized(object, threshold_, collect_stats_ == CollectPageStats::YES, &stat);
   return ConsumePageStats(stat);
 }
 
diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc
index 2e4bfbd88c86..441fa869ff54 100644
--- a/src/facade/dragonfly_connection.cc
+++ b/src/facade/dragonfly_connection.cc
@@ -736,7 +736,7 @@ void Connection::OnPostMigrateThread() {
 }
 
 void Connection::OnConnectionStart() {
-  ThisFiber::SetName("DflyConnection");
+  SetName(absl::StrCat(id_));
 
   stats_ = &tl_facade_stats->conn_stats;
 
@@ -996,7 +996,7 @@ bool Connection::IsMainOrMemcache() const {
 }
 
 void Connection::SetName(string name) {
-  util::ThisFiber::SetName(absl::StrCat("DflyConnection_", name));
+  util::ThisFiber::SetName(absl::StrCat("DflyConn_", name));
   name_ = std::move(name);
 }
 
@@ -1424,7 +1424,6 @@ error_code Connection::HandleRecvSocket() {
   } else {
     io::MutableBytes append_buf = io_buf_.AppendBuffer();
     DCHECK(!append_buf.empty());
-
     ::io::Result<size_t> recv_sz = socket_->Recv(append_buf);
     last_interaction_ = time(nullptr);
 
@@ -2176,7 +2175,7 @@ void Connection::EnsureMemoryBudget(unsigned tid) {
 }
 
 void Connection::SetMaxBusyReadUsecThreadLocal(unsigned usec) {
-  max_busy_read_cycles_cached = (base::CycleClock::Frequency() * usec) / 1000000U;
+  max_busy_read_cycles_cached = base::CycleClock::FromUsec(usec);
 }
 
 void Connection::SetAlwaysFlushPipelineThreadLocal(bool flush) {
diff --git a/src/redis/zmalloc.h b/src/redis/zmalloc.h
index f8a6c79be2cf..bead6b6975e2 100644
--- a/src/redis/zmalloc.h
+++ b/src/redis/zmalloc.h
@@ -128,7 +128,7 @@ int zmalloc_get_allocator_wasted_blocks(float ratio, size_t* allocated, size_t*
  * This uses the current local thread heap.
  * return 0 if not, 1 if underutilized
  */
-struct mi_page_usage_stats_s zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats);
+void zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats, struct mi_page_usage_stats_s* result);
 char* zstrdup(const char* s);
 
 void init_zmalloc_threadlocal(void* heap);
diff --git a/src/redis/zmalloc_mi.c b/src/redis/zmalloc_mi.c
index 17091df10a87..fb1ce845fb5e 100644
--- a/src/redis/zmalloc_mi.c
+++ b/src/redis/zmalloc_mi.c
@@ -177,8 +177,10 @@ void init_zmalloc_threadlocal(void* heap) {
   zmalloc_heap = heap;
 }
 
-mi_page_usage_stats_t zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats) {
-  return mi_heap_page_is_underutilized(zmalloc_heap, ptr, ratio, collect_stats);
+void zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats,
+                                   mi_page_usage_stats_t* result) {
+  *result = mi_heap_page_is_underutilized(zmalloc_heap, ptr, ratio,
+                                          collect_stats);
 }
 
 char* zstrdup(const char* s) {
diff --git a/src/server/command_registry.cc b/src/server/command_registry.cc
index 89f5d54ea7dc..9c12e5c0c9c9 100644
--- a/src/server/command_registry.cc
+++ b/src/server/command_registry.cc
@@ -40,8 +40,6 @@ using namespace facade;
 
 using absl::AsciiStrToUpper;
 using absl::GetFlag;
-using absl::StrAppend;
-using absl::StrCat;
 using absl::StrSplit;
 
 namespace {
@@ -233,11 +231,11 @@ hdr_histogram* CommandId::LatencyHist() const {
 CommandRegistry::CommandRegistry() {
   cmd_rename_map_ = ParseCmdlineArgMap(FLAGS_rename_command);
 
-  for (string name : GetFlag(FLAGS_restricted_commands)) {
+  for (const string& name : GetFlag(FLAGS_restricted_commands)) {
     restricted_cmds_.emplace(AsciiStrToUpper(name));
   }
 
-  for (string name : GetFlag(FLAGS_oom_deny_commands)) {
+  for (const string& name : GetFlag(FLAGS_oom_deny_commands)) {
     oomdeny_cmds_.emplace(AsciiStrToUpper(name));
   }
 }
diff --git a/src/server/db_slice.cc b/src/server/db_slice.cc
index 424f02ae8399..4c274312b893 100644
--- a/src/server/db_slice.cc
+++ b/src/server/db_slice.cc
@@ -1601,6 +1601,7 @@ void DbSlice::SendQueuedInvalidationMessages() {
     // Notify all the clients. this function is not efficient,
     // because it broadcasts to all threads unrelated to the subscribers for the key.
     auto local_map = std::move(pending_send_map_);
+    pending_send_map_ = {};
     auto cb = [&](unsigned thread_id, util::ProactorBase*) {
       SendQueuedInvalidationMessagesCb(local_map, thread_id);
     };
@@ -1767,6 +1768,7 @@ void DbSlice::OnCbFinishBlocking() {
   if (IsCacheMode()) {
     // move fetched items to local variable
     auto fetched_items = std::move(fetched_items_);
+    fetched_items_ = {};
     for (const auto& [key_hash, db_index] : fetched_items) {
       auto& db = *db_arr_[db_index];
 
diff --git a/src/server/multi_command_squasher.cc b/src/server/multi_command_squasher.cc
index 6847f508a68b..2c6d52488c4f 100644
--- a/src/server/multi_command_squasher.cc
+++ b/src/server/multi_command_squasher.cc
@@ -258,7 +258,11 @@ bool MultiCommandSquasher::ExecuteSquashed(facade::RedisReplyBuilder* rb) {
       this->SquashedHopCb(EngineShard::tlocal(), rb->GetRespVersion());
       bc->Dec();
     };
-
+    unsigned run_usec = base::CycleClock::ToUsec(ThisFiber::GetRunningTimeCycles());
+    if (run_usec > 10'000) {
+      LOG_EVERY_T(WARNING, 1) << "Fiber run " << run_usec << " usec, squashed " << cmds_.size()
+                              << " commands";
+    }
     for (unsigned i = 0; i < sharded_.size(); ++i) {
       if (!sharded_[i].dispatched.empty())
         shard_set->AddL2(i, cb);
