{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5557,
  "instance_id": "dragonflydb__dragonfly-5557",
  "issue_numbers": [
    "5529"
  ],
  "base_commit": "d7208624739192740fe24923b586d89019883af1",
  "patch": "diff --git a/helio b/helio\nindex 5a55e71b5b77..e6235850f5df 160000\n--- a/helio\n+++ b/helio\n@@ -1,1 +1,1 @@\n-Subproject commit 5a55e71b5b77c0594436ad4a7135e15d388ba6ab\n+Subproject commit e6235850f5dfa8b4e238ece802f5c1c1fa443b53\ndiff --git a/src/core/dash_internal.h b/src/core/dash_internal.h\nindex 5108b397d2c3..73546c598df2 100644\n--- a/src/core/dash_internal.h\n+++ b/src/core/dash_internal.h\n@@ -1013,6 +1013,11 @@ ___] |___ |__] |  | |___ | \\|  |\n \n */\n \n+// for clang ignore -Wunused-lambda-capture\n+#ifdef __clang__\n+#pragma clang diagnostic ignored \"-Wunused-lambda-capture\"\n+#endif\n+\n template <typename Key, typename Value, typename Policy>\n template <typename Pred>\n auto Segment<Key, Value, Policy>::Bucket::FindByFp(uint8_t fp_hash, bool probe, Pred&& pred) const\ndiff --git a/src/core/page_usage_stats.cc b/src/core/page_usage_stats.cc\nindex 81a1d2913786..4dcca93d38d2 100644\n--- a/src/core/page_usage_stats.cc\n+++ b/src/core/page_usage_stats.cc\n@@ -19,8 +19,8 @@ PageUsage::PageUsage(CollectPageStats collect_stats, float threshold)\n }\n \n bool PageUsage::IsPageForObjectUnderUtilized(void* object) {\n-  mi_page_usage_stats_t stat =\n-      zmalloc_page_is_underutilized(object, threshold_, collect_stats_ == CollectPageStats::YES);\n+  mi_page_usage_stats_t stat;\n+  zmalloc_page_is_underutilized(object, threshold_, collect_stats_ == CollectPageStats::YES, &stat);\n   return ConsumePageStats(stat);\n }\n \ndiff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex 2e4bfbd88c86..441fa869ff54 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -736,7 +736,7 @@ void Connection::OnPostMigrateThread() {\n }\n \n void Connection::OnConnectionStart() {\n-  ThisFiber::SetName(\"DflyConnection\");\n+  SetName(absl::StrCat(id_));\n \n   stats_ = &tl_facade_stats->conn_stats;\n \n@@ -996,7 +996,7 @@ bool Connection::IsMainOrMemcache() const {\n }\n \n void Connection::SetName(string name) {\n-  util::ThisFiber::SetName(absl::StrCat(\"DflyConnection_\", name));\n+  util::ThisFiber::SetName(absl::StrCat(\"DflyConn_\", name));\n   name_ = std::move(name);\n }\n \n@@ -1424,7 +1424,6 @@ error_code Connection::HandleRecvSocket() {\n   } else {\n     io::MutableBytes append_buf = io_buf_.AppendBuffer();\n     DCHECK(!append_buf.empty());\n-\n     ::io::Result<size_t> recv_sz = socket_->Recv(append_buf);\n     last_interaction_ = time(nullptr);\n \n@@ -2176,7 +2175,7 @@ void Connection::EnsureMemoryBudget(unsigned tid) {\n }\n \n void Connection::SetMaxBusyReadUsecThreadLocal(unsigned usec) {\n-  max_busy_read_cycles_cached = (base::CycleClock::Frequency() * usec) / 1000000U;\n+  max_busy_read_cycles_cached = base::CycleClock::FromUsec(usec);\n }\n \n void Connection::SetAlwaysFlushPipelineThreadLocal(bool flush) {\ndiff --git a/src/redis/zmalloc.h b/src/redis/zmalloc.h\nindex f8a6c79be2cf..bead6b6975e2 100644\n--- a/src/redis/zmalloc.h\n+++ b/src/redis/zmalloc.h\n@@ -128,7 +128,7 @@ int zmalloc_get_allocator_wasted_blocks(float ratio, size_t* allocated, size_t*\n  * This uses the current local thread heap.\n  * return 0 if not, 1 if underutilized\n  */\n-struct mi_page_usage_stats_s zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats);\n+void zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats, struct mi_page_usage_stats_s* result);\n char* zstrdup(const char* s);\n \n void init_zmalloc_threadlocal(void* heap);\ndiff --git a/src/redis/zmalloc_mi.c b/src/redis/zmalloc_mi.c\nindex 17091df10a87..fb1ce845fb5e 100644\n--- a/src/redis/zmalloc_mi.c\n+++ b/src/redis/zmalloc_mi.c\n@@ -177,8 +177,10 @@ void init_zmalloc_threadlocal(void* heap) {\n   zmalloc_heap = heap;\n }\n \n-mi_page_usage_stats_t zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats) {\n-  return mi_heap_page_is_underutilized(zmalloc_heap, ptr, ratio, collect_stats);\n+void zmalloc_page_is_underutilized(void* ptr, float ratio, int collect_stats,\n+                                   mi_page_usage_stats_t* result) {\n+  *result = mi_heap_page_is_underutilized(zmalloc_heap, ptr, ratio,\n+                                          collect_stats);\n }\n \n char* zstrdup(const char* s) {\ndiff --git a/src/server/command_registry.cc b/src/server/command_registry.cc\nindex 89f5d54ea7dc..9c12e5c0c9c9 100644\n--- a/src/server/command_registry.cc\n+++ b/src/server/command_registry.cc\n@@ -40,8 +40,6 @@ using namespace facade;\n \n using absl::AsciiStrToUpper;\n using absl::GetFlag;\n-using absl::StrAppend;\n-using absl::StrCat;\n using absl::StrSplit;\n \n namespace {\n@@ -233,11 +231,11 @@ hdr_histogram* CommandId::LatencyHist() const {\n CommandRegistry::CommandRegistry() {\n   cmd_rename_map_ = ParseCmdlineArgMap(FLAGS_rename_command);\n \n-  for (string name : GetFlag(FLAGS_restricted_commands)) {\n+  for (const string& name : GetFlag(FLAGS_restricted_commands)) {\n     restricted_cmds_.emplace(AsciiStrToUpper(name));\n   }\n \n-  for (string name : GetFlag(FLAGS_oom_deny_commands)) {\n+  for (const string& name : GetFlag(FLAGS_oom_deny_commands)) {\n     oomdeny_cmds_.emplace(AsciiStrToUpper(name));\n   }\n }\ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 424f02ae8399..4c274312b893 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -1601,6 +1601,7 @@ void DbSlice::SendQueuedInvalidationMessages() {\n     // Notify all the clients. this function is not efficient,\n     // because it broadcasts to all threads unrelated to the subscribers for the key.\n     auto local_map = std::move(pending_send_map_);\n+    pending_send_map_ = {};\n     auto cb = [&](unsigned thread_id, util::ProactorBase*) {\n       SendQueuedInvalidationMessagesCb(local_map, thread_id);\n     };\n@@ -1767,6 +1768,7 @@ void DbSlice::OnCbFinishBlocking() {\n   if (IsCacheMode()) {\n     // move fetched items to local variable\n     auto fetched_items = std::move(fetched_items_);\n+    fetched_items_ = {};\n     for (const auto& [key_hash, db_index] : fetched_items) {\n       auto& db = *db_arr_[db_index];\n \ndiff --git a/src/server/multi_command_squasher.cc b/src/server/multi_command_squasher.cc\nindex 6847f508a68b..2c6d52488c4f 100644\n--- a/src/server/multi_command_squasher.cc\n+++ b/src/server/multi_command_squasher.cc\n@@ -258,7 +258,11 @@ bool MultiCommandSquasher::ExecuteSquashed(facade::RedisReplyBuilder* rb) {\n       this->SquashedHopCb(EngineShard::tlocal(), rb->GetRespVersion());\n       bc->Dec();\n     };\n-\n+    unsigned run_usec = base::CycleClock::ToUsec(ThisFiber::GetRunningTimeCycles());\n+    if (run_usec > 10'000) {\n+      LOG_EVERY_T(WARNING, 1) << \"Fiber run \" << run_usec << \" usec, squashed \" << cmds_.size()\n+                              << \" commands\";\n+    }\n     for (unsigned i = 0; i < sharded_.size(); ++i) {\n       if (!sharded_[i].dispatched.empty())\n         shard_set->AddL2(i, cb);\n",
  "test_patch": "diff --git a/src/core/search/block_list_test.cc b/src/core/search/block_list_test.cc\nindex d8289a693564..36e98145fec0 100644\n--- a/src/core/search/block_list_test.cc\n+++ b/src/core/search/block_list_test.cc\n@@ -9,6 +9,7 @@\n #include <gtest/gtest.h>\n \n #include <algorithm>\n+#include <random>\n #include <set>\n \n #include \"base/gtest.h\"\n",
  "problem_statement": "`debug stacktrace` crashes inside ConnectionsWatcherFb\nReproduces only on aarch64 in release mode (tried on r6g.xlarge)\n\nTo reproduce:\n\n1. `./dragonfly --timeout=500`\n2. `redis-cli DEBUG STACKTRACE`\n\ncrashes in absl code inside `absl::lts_20240722::GetStackTrace()`.\nSomething is special in ConnectionsWatcherFb that reproduces it. \nOne direction is - to just remove pieces of code there until we understand why it happens.\nAnother option is to check if newer version of absl (say https://github.com/abseil/abseil-cpp/releases/tag/20250512.1) fixes the issue.\n\n",
  "hints_text": "I successfully reproduced this issue locally. I tried to update the Abseil library to the mentioned (latest) version: 20250512.1\nThe bug doesn't reproduce on the latest version. I suggest updating the Helio third parties to the latest Abseil version. It looks reasonable.\nThe question: the current version is patched with a custom patch. As far as I understand, it was done to support symbolizing different versions of libc.\n@romange, should we add the same patch for the new version of the library?\nFixes:\nhttps://github.com/romange/helio/pull/435\nhttps://github.com/dragonflydb/dragonfly/pull/5537\nThe latest version of the Abseil library with crash: https://github.com/abseil/abseil-cpp/releases/tag/20250127.1\nThe next version and all following have the fix: https://github.com/abseil/abseil-cpp/releases/tag/20250512.rc1\n\nThe fix was in absl/debugging/internal/stacktrace_aarch64-inl.inc\n\nThe commit: https://github.com/abseil/abseil-cpp/commit/a9a1b50468762a05a7407c2b5d18cc50db0d0bf4\n\n",
  "created_at": "2025-07-24T08:47:50Z",
  "modified_files": [
    "helio",
    "src/core/dash_internal.h",
    "src/core/page_usage_stats.cc",
    "src/facade/dragonfly_connection.cc",
    "src/redis/zmalloc.h",
    "src/redis/zmalloc_mi.c",
    "src/server/command_registry.cc",
    "src/server/db_slice.cc",
    "src/server/multi_command_squasher.cc"
  ],
  "modified_test_files": [
    "src/core/search/block_list_test.cc"
  ]
}