diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc
index e205bb0a5ff1..7b77967a160d 100644
--- a/src/server/zset_family_test.cc
+++ b/src/server/zset_family_test.cc
@@ -527,4 +527,55 @@ TEST_F(ZSetFamilyTest, Resp3) {
   ASSERT_THAT(resp.GetVec()[1].GetVec(), ElementsAre("b", DoubleArg(2)));
 }
 
+TEST_F(ZSetFamilyTest, BlockingIsReleased) {
+  // Inputs for ZSET store commands.
+  Run({"ZADD", "A", "1", "x", "2", "b"});
+  Run({"ZADD", "B", "1", "x", "3", "b"});
+  Run({"ZADD", "C", "1", "x", "10", "a"});
+  Run({"ZADD", "D", "1", "x", "5", "c"});
+
+  vector<string> blocking_keys{"zset1", "zset2", "zset3"};
+  for (const auto& key : blocking_keys) {
+    vector<vector<string>> unblocking_commands;
+    // All commands output the same set {2,x}.
+    unblocking_commands.push_back({"ZADD", key, "2", "x", "10", "y"});
+    unblocking_commands.push_back({"ZINCRBY", key, "2", "x"});
+    unblocking_commands.push_back({"ZINTERSTORE", key, "2", "A", "B"});
+    unblocking_commands.push_back({"ZUNIONSTORE", key, "2", "C", "D"});
+    // unblocking_commands.push_back({"ZDIFFSTORE", key, "2", "A", "B"}); // unimplemented
+
+    for (auto& cmd : unblocking_commands) {
+      RespExpr resp0;
+      auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {
+        resp0 = Run({"BZPOPMIN", "zset1", "zset2", "zset3", "0"});
+        LOG(INFO) << "BZPOPMIN";
+      });
+
+      pp_->at(1)->Await([&] { return Run({cmd.data(), cmd.size()}); });
+      fb0.Join();
+
+      ASSERT_THAT(resp0, ArrLen(3)) << cmd[0];
+      EXPECT_THAT(resp0.GetVec(), ElementsAre(key, "x", "2")) << cmd[0];
+
+      Run({"DEL", key});
+    }
+  }
+}
+
+TEST_F(ZSetFamilyTest, BlockingTimeout) {
+  RespExpr resp0;
+
+  auto start = absl::Now();
+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {
+    resp0 = Run({"BZPOPMIN", "zset1", "1"});
+    LOG(INFO) << "BZPOPMIN";
+  });
+  fb0.Join();
+  auto dur = absl::Now() - start;
+
+  // Check that the timeout duration is not too crazy.
+  EXPECT_LT(AbsDuration(dur - absl::Milliseconds(1000)), absl::Milliseconds(300));
+  EXPECT_THAT(resp0, ArgType(RespExpr::NIL_ARRAY));
+}
+
 }  // namespace dfly
