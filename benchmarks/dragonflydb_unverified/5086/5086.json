{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5086,
  "instance_id": "dragonflydb__dragonfly-5086",
  "issue_numbers": [
    "4880"
  ],
  "base_commit": "705d61e793dec8a5d6973c37975c8f49dc576e78",
  "patch": "diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex 87e9b976205a..0c1148a68123 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -787,13 +787,17 @@ CompactObj& CompactObj::operator=(CompactObj&& o) noexcept {\n \n size_t CompactObj::Size() const {\n   size_t raw_size = 0;\n-\n+  uint8_t first_byte = 0;\n   if (IsInline()) {\n     raw_size = taglen_;\n+    first_byte = u_.inline_str[0];\n   } else {\n     switch (taglen_) {\n       case SMALL_TAG:\n         raw_size = u_.small_str.size();\n+        if (mask_bits_.encoding == HUFFMAN_ENC) {\n+          return DecodedLen(raw_size, u_.small_str.first_byte());\n+        }\n         break;\n       case INT_TAG: {\n         absl::AlphaNum an(u_.ival);\n@@ -802,11 +806,16 @@ size_t CompactObj::Size() const {\n       }\n       case EXTERNAL_TAG:\n         raw_size = u_.ext_ptr.serialized_size;\n+        CHECK(mask_bits_.encoding != HUFFMAN_ENC);\n         break;\n       case ROBJ_TAG:\n         raw_size = u_.r_obj.Size();\n+        if (mask_bits_.encoding == HUFFMAN_ENC) {\n+          return DecodedLen(raw_size, *(uint8_t*)u_.r_obj.inner_obj());\n+        }\n         break;\n       case JSON_TAG:\n+        DCHECK_EQ(mask_bits_.encoding, NONE_ENC);\n         if (JsonEnconding() == kEncodingJsonFlat) {\n           raw_size = u_.json_obj.flat.json_len;\n         } else {\n@@ -814,48 +823,54 @@ size_t CompactObj::Size() const {\n         }\n         break;\n       case SBF_TAG:\n+        DCHECK_EQ(mask_bits_.encoding, NONE_ENC);\n         raw_size = u_.sbf->current_size();\n         break;\n       default:\n         LOG(DFATAL) << \"Should not reach \" << int(taglen_);\n     }\n   }\n-  return mask_bits_.encoding ? DecodedLen(raw_size) : raw_size;\n+  return mask_bits_.encoding ? DecodedLen(raw_size, first_byte) : raw_size;\n }\n \n uint64_t CompactObj::HashCode() const {\n   DCHECK(taglen_ != JSON_TAG) << \"JSON type cannot be used for keys!\";\n \n-  uint8_t encoded = mask_bits_.encoding;\n-  if (IsInline()) {\n-    if (encoded) {\n-      char buf[kInlineLen * 2];\n-      size_t decoded_len = DecodedLen(taglen_);\n-      detail::ascii_unpack(to_byte(u_.inline_str), decoded_len, buf);\n-      return XXH3_64bits_withSeed(buf, decoded_len, kHashSeed);\n+  if (mask_bits_.encoding == NONE_ENC) {\n+    if (IsInline()) {\n+      return XXH3_64bits_withSeed(u_.inline_str, taglen_, kHashSeed);\n     }\n-    return XXH3_64bits_withSeed(u_.inline_str, taglen_, kHashSeed);\n-  }\n \n-  if (encoded) {\n-    string_view sv = GetSlice(&tl.tmp_str);\n-    return XXH3_64bits_withSeed(sv.data(), sv.size(), kHashSeed);\n+    switch (taglen_) {\n+      case SMALL_TAG:\n+        return u_.small_str.HashCode();\n+      case ROBJ_TAG:\n+        return u_.r_obj.HashCode();\n+      case INT_TAG: {\n+        absl::AlphaNum an(u_.ival);\n+        return XXH3_64bits_withSeed(an.data(), an.size(), kHashSeed);\n+      }\n+    }\n   }\n \n-  switch (taglen_) {\n-    case SMALL_TAG:\n-      return u_.small_str.HashCode();\n-    case ROBJ_TAG:\n-      return u_.r_obj.HashCode();\n-    case INT_TAG: {\n-      absl::AlphaNum an(u_.ival);\n-      return XXH3_64bits_withSeed(an.data(), an.size(), kHashSeed);\n+  DCHECK(mask_bits_.encoding);\n+\n+  if (IsInline()) {\n+    char buf[kInlineLen * 3];  // should suffice for most huffman decodings.\n+    size_t decoded_len = DecodedLen(taglen_, u_.inline_str[0]);\n+    if (mask_bits_.encoding == HUFFMAN_ENC) {\n+      if (decoded_len <= sizeof(buf) &&\n+          tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, decoded_len, buf)) {\n+        return XXH3_64bits_withSeed(buf, decoded_len, kHashSeed);\n+      }\n+    } else {\n+      detail::ascii_unpack(to_byte(u_.inline_str), decoded_len, buf);\n+      return XXH3_64bits_withSeed(buf, decoded_len, kHashSeed);\n     }\n   }\n-  // We need hash only for keys.\n-  LOG(DFATAL) << \"Should not reach \" << int(taglen_);\n \n-  return 0;\n+  string_view sv = GetSlice(&tl.tmp_str);\n+  return XXH3_64bits_withSeed(sv.data(), sv.size(), kHashSeed);\n }\n \n uint64_t CompactObj::HashCode(string_view str) {\n@@ -1111,7 +1126,8 @@ void CompactObj::GetString(char* dest) const {\n         detail::ascii_unpack(to_byte(u_.inline_str), taglen_ + 2, dest);\n         break;\n       case HUFFMAN_ENC:\n-        tl.huff_decoder.Decode(u_.inline_str, taglen_, dest);\n+        tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)},\n+                               u_.inline_str[0] + taglen_ - 1, dest);\n         break;\n       case NONE_ENC:\n         memcpy(dest, u_.inline_str, taglen_);\n@@ -1132,24 +1148,39 @@ void CompactObj::GetString(char* dest) const {\n     if (taglen_ == ROBJ_TAG) {\n       CHECK_EQ(OBJ_STRING, u_.r_obj.type());\n       DCHECK_EQ(OBJ_ENCODING_RAW, u_.r_obj.encoding());\n-      size_t decoded_len = DecodedLen(u_.r_obj.Size());\n+      size_t decoded_len = DecodedLen(u_.r_obj.Size(), *(const uint8_t*)u_.r_obj.inner_obj());\n+      if (mask_bits_.encoding == HUFFMAN_ENC) {\n+        CHECK(tl.huff_decoder.Decode({(const char*)u_.r_obj.inner_obj() + 1, u_.r_obj.Size() - 1},\n+                                     decoded_len, dest));\n+        return;\n+      }\n       detail::ascii_unpack_simd(to_byte(u_.r_obj.inner_obj()), decoded_len, dest);\n-    } else if (taglen_ == SMALL_TAG) {\n-      size_t decoded_len = DecodedLen(u_.small_str.size());\n+    } else {\n+      CHECK_EQ(SMALL_TAG, taglen_);\n+      string_view slices[2];\n+      unsigned num = u_.small_str.GetV(slices);\n+      DCHECK_EQ(2u, num);\n+      size_t decoded_len = DecodedLen(u_.small_str.size(), slices[0][0]);\n+\n+      if (mask_bits_.encoding == HUFFMAN_ENC) {\n+        tl.tmp_buf.resize(slices[0].size() + slices[1].size() - 1);\n+        uint8_t* next = tl.tmp_buf.data();\n+        memcpy(next, slices[0].data() + 1, slices[0].size() - 1);\n+        next += slices[0].size() - 1;\n+        memcpy(next, slices[1].data(), slices[1].size());\n+        string_view src(reinterpret_cast<const char*>(tl.tmp_buf.data()), tl.tmp_buf.size());\n+        CHECK(tl.huff_decoder.Decode(src, decoded_len, dest));\n+        return;\n+      }\n \n       // we left some space on the left to allow inplace ascii unpacking.\n       size_t space_left = decoded_len - u_.small_str.size();\n \n-      string_view slices[2];\n-      unsigned num = u_.small_str.GetV(slices);\n-      DCHECK_EQ(2u, num);\n       char* next = dest + space_left;\n       memcpy(next, slices[0].data(), slices[0].size());\n       next += slices[0].size();\n       memcpy(next, slices[1].data(), slices[1].size());\n       detail::ascii_unpack_simd(reinterpret_cast<uint8_t*>(dest + space_left), decoded_len, dest);\n-    } else {\n-      LOG(FATAL) << \"Unsupported tag \" << int(taglen_);\n     }\n     return;\n   }\n@@ -1343,8 +1374,25 @@ bool CompactObj::EqualNonInline(std::string_view sv) const {\n }\n \n bool CompactObj::CmpEncoded(string_view sv) const {\n-  size_t encode_len = binpacked_len(sv.size());\n+  if (mask_bits_.encoding == HUFFMAN_ENC) {\n+    size_t sz = Size();\n+    if (sv.size() != sz)\n+      return false;\n \n+    if (IsInline()) {\n+      constexpr size_t kMaxHuffLen = kInlineLen * 3;\n+      if (sz <= kMaxHuffLen) {\n+        char buf[kMaxHuffLen];\n+        CHECK(tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, sz, buf));\n+        return sv == string_view(buf, sz);\n+      }\n+    }\n+    tl.tmp_str.resize(sz);\n+    GetString(tl.tmp_str.data());\n+    return sv == tl.tmp_str;\n+  }\n+\n+  size_t encode_len = binpacked_len(sv.size());\n   if (IsInline()) {\n     if (encode_len != taglen_)\n       return false;\n@@ -1524,8 +1572,12 @@ StringOrView CompactObj::GetRawString() const {\n   return {};\n }\n \n-size_t CompactObj::DecodedLen(size_t sz) const {\n-  unsigned delta = (mask_bits_.encoding == ASCII1_ENC ? 1 : 0);\n+size_t CompactObj::DecodedLen(size_t sz, uint8_t b) const {\n+  DCHECK(mask_bits_.encoding);\n+  if (mask_bits_.encoding == HUFFMAN_ENC) {\n+    return sz + b - 1;\n+  }\n+  unsigned delta = (mask_bits_.encoding == ASCII1_ENC) ? 1 : 0;\n   return ascii_len(sz) - delta;\n }\n \ndiff --git a/src/core/compact_object.h b/src/core/compact_object.h\nindex 7f4bfb23a881..e136fa5a724d 100644\n--- a/src/core/compact_object.h\n+++ b/src/core/compact_object.h\n@@ -410,7 +410,7 @@ class CompactObj {\n \n  private:\n   void EncodeString(std::string_view str);\n-  size_t DecodedLen(size_t sz) const;\n+  size_t DecodedLen(size_t sz, uint8_t firstb) const;\n \n   bool EqualNonInline(std::string_view sv) const;\n \ndiff --git a/src/core/huff_coder.cc b/src/core/huff_coder.cc\nindex 0b19f54ae719..5e40ecbb5273 100644\n--- a/src/core/huff_coder.cc\n+++ b/src/core/huff_coder.cc\n@@ -144,7 +144,7 @@ bool HuffmanDecoder::Decode(std::string_view src, size_t dest_size, char* dest)\n       HUF_decompress1X_usingDTable(dest, dest_size, src.data(), src.size(), huf_dtable_.get(), 1);\n \n   if (HUF_isError(res)) {\n-    LOG(FATAL) << \"Failed to decompress: \" << HUF_getErrorName(res);\n+    LOG(DFATAL) << \"Failed to decompress: \" << HUF_getErrorName(res);\n     return false;\n   }\n   return true;\ndiff --git a/src/core/small_string.h b/src/core/small_string.h\nindex e80c0036cc65..3273d88aebbf 100644\n--- a/src/core/small_string.h\n+++ b/src/core/small_string.h\n@@ -50,6 +50,10 @@ class SmallString {\n \n   bool DefragIfNeeded(float ratio);\n \n+  uint8_t first_byte() const {\n+    return prefix_[0];\n+  }\n+\n  private:\n   // prefix of the string that is broken down into 2 parts.\n   char prefix_[kPrefLen];\n",
  "test_patch": "diff --git a/src/core/compact_object_test.cc b/src/core/compact_object_test.cc\nindex f5f3a75fb73f..633b9c4d53c3 100644\n--- a/src/core/compact_object_test.cc\n+++ b/src/core/compact_object_test.cc\n@@ -4,6 +4,7 @@\n #include \"core/compact_object.h\"\n \n #include <absl/strings/str_cat.h>\n+#include <gtest/gtest.h>\n #include <mimalloc.h>\n #include <xxhash.h>\n \n@@ -13,6 +14,7 @@\n #include \"base/logging.h\"\n #include \"core/detail/bitpacking.h\"\n #include \"core/flat_set.h\"\n+#include \"core/huff_coder.h\"\n #include \"core/mi_memory_resource.h\"\n #include \"core/string_set.h\"\n \n@@ -656,6 +658,30 @@ TEST_F(CompactObjectTest, lpGetInteger) {\n   lpFree(lp);\n }\n \n+TEST_F(CompactObjectTest, HuffMan) {\n+  array<unsigned, 256> hist;\n+  hist.fill(1);\n+  hist['a'] = 100;\n+  hist['b'] = 50;\n+  HuffmanEncoder encoder;\n+  ASSERT_TRUE(encoder.Build(hist.data(), hist.size() - 1, nullptr));\n+  string bindata = encoder.Export();\n+  ASSERT_TRUE(CompactObj::InitHuffmanThreadLocal(bindata));\n+  for (unsigned i = 30; i < 2048; i += 10) {\n+    string data(i, 'a');\n+    cobj_.SetString(data);\n+    bool malloc_used = i >= 60;\n+    ASSERT_EQ(malloc_used, cobj_.MallocUsed() > 0) << i;\n+    ASSERT_EQ(data.size(), cobj_.Size());\n+    ASSERT_EQ(CompactObj::HashCode(data), cobj_.HashCode());\n+\n+    string actual;\n+    cobj_.GetString(&actual);\n+    EXPECT_EQ(data, actual);\n+    EXPECT_EQ(cobj_, data);\n+  }\n+}\n+\n static void ascii_pack_naive(const char* ascii, size_t len, uint8_t* bin) {\n   const char* end = ascii + len;\n \n",
  "problem_statement": "add huffman encoding support for CompactObject\n## Motivation\n\nAnalysis of workload key spaces reveals that they are often well compressible using Huffman encoding, achieving a 30-45% reduction in size. This is primarily because these keys are typically ASCII text with low entropy.\n\nInstead of using generic compression libraries, which introduce significant metadata and apply run-length encoding (RLE), we should use a low-level Huffman coding solution. Given that most keys are short and require independent processing, a standard Huffman coding approach with a global table per shard (across all keys) is likely the most efficient. I've checked it with \"DEBUG COMPRESSION\" on several workloads.\n\n## This task\n\n1.  **Implement Huffman Encoding in `CompactObject`:**\n    * Currently, `ASCII1_ENC_BIT` and `ASCII2_ENC_BIT` represent three states: not encoded, ASCII1, and ASCII2.\n    * We can repurpose these bits as a 2-bit enum to include a fourth state: `huff_encoded`.\n2.  **Maintain Transparent Decoding:**\n    * Ensure decoding is transparent to callers by storing the Huffman table locally within the `TL` structure defined in `compact_object.cc`.\n3.  **Utilize Existing Huffman Utilities:**\n    * Leverage the Huffman utilities exposed via `huff/huf.h`, as demonstrated in `debugcmd.cc`.\n4.  **Restrict Huffman Encoding to Keys:**\n    * Limit this feature to keys by adding a `bool huffman_allowed` argument to `CompactObj::SetString`, prohibiting Huffman encoding for other string types.\n5.  **Manage Huffman Data Structures within `TL`:**\n    * Ensure Huffman data structures within `TL` are immutable.\n    * The table should either exist with pre-calculated weights or not exist at all.\n    * Prevent modifications to the table if string objects have already been encoded using it.\n6. encoding stats should be tracked under TL (attempts, successes, raw size, compressed size)\n7. Do not attempt encode short strings (inline). Do not attempt encode huge strings (above certain length).\n    Note that some strings after encoding may become inline, so the decoding code GetSlice should be able to handle it.\n\n## Encoded Format\n\nHuffman encoding can result in bit sequences that do not align with byte boundaries, as it translates each byte into one or more bits.\n\nTo address the ambiguity of decoding an encoded string of size *k* into the original string:\n\n* Use the first byte to indicate the length of the \"unused\" suffix (the number of unused bits in the last byte).\n* Since we need at least one extra byte to store the suffix length, apply Huffman encoding only if it reduces the data size by at least two bytes.\n\nThis task does not introduce a new functionality for Dragonfly and should be contained within the `compact_object*` code.  \n\n",
  "hints_text": "There is not need to build your own huffman tree - we should leverage the highly efficient code from \"huff.h\"\nI will get some free bandwidth probably soon and I always wanted to be a `rockstar` so... \n\nYou are good in sales/marketing @romange \nDoes it mean async tls is for grabs?\n@romange nooooo\n@kostasrim  I am planning to take over this, sorry but I would like to complete it this month.\n@romange add me as a reviewer ",
  "created_at": "2025-05-09T05:42:15Z",
  "modified_files": [
    "src/core/compact_object.cc",
    "src/core/compact_object.h",
    "src/core/huff_coder.cc",
    "src/core/small_string.h"
  ],
  "modified_test_files": [
    "src/core/compact_object_test.cc"
  ]
}