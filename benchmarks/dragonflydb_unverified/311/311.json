{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 311,
  "instance_id": "dragonflydb__dragonfly-311",
  "issue_numbers": [
    "287"
  ],
  "base_commit": "082ac36ac195b5fd503422db7152c2d6efbd857a",
  "patch": "diff --git a/docs/differences.md b/docs/differences.md\nindex 46fbbdab459d..b6b6acd2480c 100644\n--- a/docs/differences.md\n+++ b/docs/differences.md\n@@ -6,6 +6,10 @@ String sizes are limited to 256MB.\n Indices (say in GETRANGE and SETRANGE commands) should be signed 32 bit integers in range\n [-2147483647, 2147483648].\n \n+### String handling.\n+\n+SORT does not take any locale into account.\n+\n ## Expiry ranges.\n Expirations are limited to 4 years. For commands with millisecond precision like PEXPIRE or PSETEX,\n expirations greater than 2^27ms are quietly rounded to the nearest second loosing precision of less than 0.001%.\ndiff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex c774d1b646fd..cefddf899475 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -262,6 +262,16 @@ size_t RobjWrapper::Size() const {\n     case OBJ_STRING:\n       DCHECK_EQ(OBJ_ENCODING_RAW, encoding_);\n       return sz_;\n+    case OBJ_LIST:\n+      return quicklistCount((quicklist*)inner_obj_);\n+    case OBJ_ZSET: {\n+      robj self{.type = type_,\n+                .encoding = encoding_,\n+                .lru = 0,\n+                .refcount = OBJ_STATIC_REFCOUNT,\n+                .ptr = inner_obj_};\n+      return zsetLength(&self);\n+    }\n     case OBJ_SET:\n       switch (encoding_) {\n         case kEncodingIntSet: {\n@@ -278,7 +288,7 @@ size_t RobjWrapper::Size() const {\n         }\n         default:\n           LOG(FATAL) << \"Unexpected encoding \" << encoding_;\n-      }\n+      };\n     default:;\n   }\n   return 0;\ndiff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex ab54931c69cc..b031c6aeec5c 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -299,6 +299,10 @@ void RedisReplyBuilder::SendNullArray() {\n   SendRaw(\"*-1\\r\\n\");\n }\n \n+void RedisReplyBuilder::SendEmptyArray() {\n+  StartArray(0);\n+}\n+\n void RedisReplyBuilder::SendStringArr(absl::Span<const std::string_view> arr) {\n   if (arr.empty()) {\n     SendRaw(\"*0\\r\\n\");\ndiff --git a/src/facade/reply_builder.h b/src/facade/reply_builder.h\nindex 60fba486d55b..0bfe2aa93800 100644\n--- a/src/facade/reply_builder.h\n+++ b/src/facade/reply_builder.h\n@@ -128,7 +128,10 @@ class RedisReplyBuilder : public SinkReplyBuilder {\n   void SendError(OpStatus status);\n \n   virtual void SendSimpleStrArr(const std::string_view* arr, uint32_t count);\n+  // Send *-1\n   virtual void SendNullArray();\n+  // Send *0\n+  virtual void SendEmptyArray();\n \n   virtual void SendStringArr(absl::Span<const std::string_view> arr);\n   virtual void SendStringArr(absl::Span<const std::string> arr);\ndiff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 9fd26161af63..a5b5cb8ab594 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -12,7 +12,7 @@ add_library(dragonfly_lib  channel_slice.cc command_registry.cc\n             list_family.cc main_service.cc  rdb_load.cc rdb_save.cc replica.cc\n             snapshot.cc script_mgr.cc server_family.cc malloc_stats.cc\n             set_family.cc stream_family.cc string_family.cc\n-            zset_family.cc version.cc bitops_family.cc)\n+            zset_family.cc version.cc bitops_family.cc container_utils.cc)\n \n cxx_link(dragonfly_lib dfly_transaction dfly_facade redis_lib strings_lib html_lib\n          absl::random_random TRDP::jsoncons)\ndiff --git a/src/server/container_utils.cc b/src/server/container_utils.cc\nnew file mode 100644\nindex 000000000000..21febb123dcf\n--- /dev/null\n+++ b/src/server/container_utils.cc\n@@ -0,0 +1,161 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+#include \"server/container_utils.h\"\n+\n+#include \"base/logging.h\"\n+\n+extern \"C\" {\n+#include \"redis/intset.h\"\n+#include \"redis/listpack.h\"\n+#include \"redis/object.h\"\n+#include \"redis/redis_aux.h\"\n+#include \"redis/util.h\"\n+#include \"redis/zset.h\"\n+}\n+\n+namespace dfly::container_utils {\n+\n+quicklistEntry QLEntry() {\n+  quicklistEntry res{.quicklist = NULL,\n+                     .node = NULL,\n+                     .zi = NULL,\n+                     .value = NULL,\n+                     .longval = 0,\n+                     .sz = 0,\n+                     .offset = 0};\n+  return res;\n+}\n+\n+bool IterateList(const PrimeValue& pv, const IterateFunc& func, long start, long end) {\n+  quicklist* ql = static_cast<quicklist*>(pv.RObjPtr());\n+  long llen = quicklistCount(ql);\n+  if (end < 0 || end >= llen)\n+    end = llen - 1;\n+\n+  quicklistIter* qiter = quicklistGetIteratorAtIdx(ql, AL_START_HEAD, start);\n+  quicklistEntry entry = QLEntry();\n+  long lrange = end - start + 1;\n+\n+  bool success = true;\n+  while (success && quicklistNext(qiter, &entry) && lrange-- > 0) {\n+    if (entry.value) {\n+      success = func(ContainerEntry{reinterpret_cast<char*>(entry.value), entry.sz});\n+    } else {\n+      success = func(ContainerEntry{nullptr, .longval=entry.longval});\n+    }\n+  }\n+  quicklistReleaseIterator(qiter);\n+  return success;\n+}\n+\n+bool IterateSet(const PrimeValue& pv, const IterateFunc& func) {\n+  bool success = true;\n+  if (pv.Encoding() == kEncodingIntSet) {\n+    intset* is = static_cast<intset*>(pv.RObjPtr());\n+    int64_t ival;\n+    int ii = 0;\n+\n+    while (success && intsetGet(is, ii++, &ival)) {\n+      success = func(ContainerEntry{nullptr, .longval=ival});\n+    }\n+  } else {\n+    if (pv.Encoding() == kEncodingStrMap2) {\n+      for (sds ptr : *static_cast<StringSet*>(pv.RObjPtr())) {\n+        if (!func(ContainerEntry{ptr, sdslen(ptr)})) {\n+          success = false;\n+          break;\n+        }\n+      }\n+    } else {\n+      dict* ds = static_cast<dict*>(pv.RObjPtr());\n+      dictIterator* di = dictGetIterator(ds);\n+      dictEntry* de = nullptr;\n+      while (success && (de = dictNext(di))) {\n+        sds ptr = static_cast<sds>(de->key);\n+        success = func(ContainerEntry{ptr, sdslen(ptr)});\n+      }\n+      dictReleaseIterator(di);\n+    }\n+  }\n+\n+  return success;\n+}\n+\n+bool IterateSortedSet(robj* zobj, const IterateSortedFunc& func, int32_t start, int32_t end,\n+                      bool reverse, bool use_score) {\n+  unsigned long llen = zsetLength(zobj);\n+  if (end < 0 || unsigned(end) >= llen)\n+    end = llen - 1;\n+\n+  unsigned rangelen = unsigned(end - start) + 1;\n+\n+  if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n+    uint8_t* zl = static_cast<uint8_t*>(zobj->ptr);\n+    uint8_t *eptr, *sptr;\n+    uint8_t* vstr;\n+    unsigned int vlen;\n+    long long vlong;\n+    double score = 0.0;\n+\n+    if (reverse) {\n+      eptr = lpSeek(zl, -2 - long(2 * start));\n+    } else {\n+      eptr = lpSeek(zl, 2 * start);\n+    }\n+    DCHECK(eptr);\n+\n+    sptr = lpNext(zl, eptr);\n+\n+    bool success = true;\n+    while (success && rangelen--) {\n+      DCHECK(eptr != NULL && sptr != NULL);\n+      vstr = lpGetValue(eptr, &vlen, &vlong);\n+\n+      // don't bother to extract the score if it's gonna be ignored.\n+      if (use_score)\n+        score = zzlGetScore(sptr);\n+\n+      if (vstr == NULL) {\n+        success = func(ContainerEntry{nullptr, .longval=vlong}, score);\n+      } else {\n+        success = func(ContainerEntry{reinterpret_cast<const char*>(vstr), vlen}, score);\n+      }\n+\n+      if (reverse) {\n+        zzlPrev(zl, &eptr, &sptr);\n+      } else {\n+        zzlNext(zl, &eptr, &sptr);\n+      };\n+    }\n+    return success;\n+  } else {\n+    CHECK_EQ(zobj->encoding, OBJ_ENCODING_SKIPLIST);\n+    zset* zs = static_cast<zset*>(zobj->ptr);\n+    zskiplist* zsl = zs->zsl;\n+    zskiplistNode* ln;\n+\n+    /* Check if starting point is trivial, before doing log(N) lookup. */\n+    if (reverse) {\n+      ln = zsl->tail;\n+      unsigned long llen = zsetLength(zobj);\n+      if (start > 0)\n+        ln = zslGetElementByRank(zsl, llen - start);\n+    } else {\n+      ln = zsl->header->level[0].forward;\n+      if (start > 0)\n+        ln = zslGetElementByRank(zsl, start + 1);\n+    }\n+\n+    bool success = true;\n+    while (success && rangelen--) {\n+      DCHECK(ln != NULL);\n+      success = func(ContainerEntry{ln->ele, sdslen(ln->ele)}, ln->score);\n+      ln = reverse ? ln->backward : ln->level[0].forward;\n+    }\n+    return success;\n+  }\n+  return false;\n+}\n+\n+}  // namespace dfly::container_utils\ndiff --git a/src/server/container_utils.h b/src/server/container_utils.h\nnew file mode 100644\nindex 000000000000..d3409e7c7ae4\n--- /dev/null\n+++ b/src/server/container_utils.h\n@@ -0,0 +1,69 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+#pragma once\n+\n+#include \"core/compact_object.h\"\n+#include \"core/string_set.h\"\n+#include \"server/common.h\"\n+#include \"server/table.h\"\n+\n+extern \"C\" {\n+#include \"redis/object.h\"\n+#include \"redis/quicklist.h\"\n+}\n+\n+#include <functional>\n+\n+namespace dfly {\n+\n+namespace container_utils {\n+\n+// IsContainer returns true if the iterator points to a container type.\n+inline bool IsContainer(const PrimeValue& pv) {\n+  unsigned type = pv.ObjType();\n+  return (type == OBJ_LIST || type == OBJ_SET || type == OBJ_ZSET);\n+}\n+\n+// Create empty quicklistEntry\n+quicklistEntry QLEntry();\n+\n+// Stores either:\n+// - A single long long value (longval) when value = nullptr\n+// - A single char* (value) when value != nullptr\n+struct ContainerEntry {\n+  const char* value;\n+  union {\n+    size_t length;\n+    long long longval;\n+  };\n+  std::string ToString() {\n+    if (value)\n+      return {value, length};\n+    else\n+      return absl::StrCat(longval);\n+  }\n+};\n+\n+using IterateFunc = std::function<bool(ContainerEntry)>;\n+using IterateSortedFunc = std::function<bool(ContainerEntry, double)>;\n+\n+// Iterate over all values and call func(val). Iteration stops as soon\n+// as func return false. Returns true if it successfully processed all elements\n+// without stopping.\n+bool IterateList(const PrimeValue& pv, const IterateFunc& func, long start = 0, long end = -1);\n+\n+// Iterate over all values and call func(val). Iteration stops as soon\n+// as func return false. Returns true if it successfully processed all elements\n+// without stopping.\n+bool IterateSet(const PrimeValue& pv, const IterateFunc& func);\n+\n+// Iterate over all values and call func(val). Iteration stops as soon\n+// as func return false. Returns true if it successfully processed all elements\n+// without stopping.\n+bool IterateSortedSet(robj* zobj, const IterateSortedFunc& func, int32_t start = 0, int32_t end = -1,\n+                      bool reverse = false, bool use_score = false);\n+\n+};  // namespace container_utils\n+\n+}  // namespace dfly\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 130ddf4b7994..6343d071f1e6 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -14,6 +14,7 @@ extern \"C\" {\n #include \"server/blocking_controller.h\"\n #include \"server/command_registry.h\"\n #include \"server/conn_context.h\"\n+#include \"server/container_utils.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/error.h\"\n #include \"server/transaction.h\"\n@@ -208,8 +209,7 @@ bool ScanCb(const OpArgs& op_args, PrimeIterator it, const ScanOpts& opts, Strin\n   return true;\n }\n \n-void OpScan(const OpArgs& op_args, const ScanOpts& scan_opts, uint64_t* cursor,\n-            StringVec* vec) {\n+void OpScan(const OpArgs& op_args, const ScanOpts& scan_opts, uint64_t* cursor, StringVec* vec) {\n   auto& db_slice = op_args.shard->db_slice();\n   DCHECK(db_slice.IsDbValid(op_args.db_ind));\n \n@@ -463,6 +463,170 @@ void GenericFamily::Stick(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(match_cnt);\n }\n \n+// Used to conditionally store double score\n+struct SortEntryScore {\n+  double score;\n+};\n+\n+// SortEntry stores all data required for sorting\n+template <bool ALPHA>\n+struct SortEntry\n+    // Store score only if we need it\n+    : public std::conditional_t<ALPHA, std::tuple<>, SortEntryScore> {\n+  std::string key;\n+\n+  bool Parse(std::string&& item) {\n+    if constexpr (!ALPHA) {\n+      if (!absl::SimpleAtod(item, &this->score))\n+        return false;\n+    }\n+    key = std::move(item);\n+    return true;\n+  }\n+\n+  bool Parse(int64_t item) {\n+    if constexpr (!ALPHA) {\n+      this->score = item;\n+    }\n+    key = absl::StrCat(item);\n+    return true;\n+  }\n+\n+  std::conditional_t<ALPHA, const std::string&, double> Cmp() const {\n+    if constexpr (ALPHA) {\n+      return key;\n+    } else {\n+      return this->score;\n+    }\n+  }\n+};\n+\n+// std::variant of all possible vectors of SortEntries\n+using SortEntryList = std::variant<\n+    // Used when sorting by double values\n+    std::vector<SortEntry<false>>,\n+    // Used when sorting by string values\n+    std::vector<SortEntry<true>>>;\n+\n+// Create SortEntryList based on runtime arguments\n+SortEntryList MakeSortEntryList(bool alpha) {\n+  if (alpha)\n+    return SortEntryList{std::vector<SortEntry<true>>{}};\n+  else\n+    return SortEntryList{std::vector<SortEntry<false>>{}};\n+}\n+\n+// Iterate over container with generic function that accepts strings and ints\n+template <typename F> bool Iterate(const PrimeValue& pv, F&& func) {\n+  auto cb = [&func](container_utils::ContainerEntry ce) {\n+    if (ce.value)\n+      return func(ce.ToString());\n+    else\n+      return func(ce.longval);\n+  };\n+\n+  switch (pv.ObjType()) {\n+    case OBJ_LIST:\n+      return container_utils::IterateList(pv, cb);\n+    case OBJ_SET:\n+      return container_utils::IterateSet(pv, cb);\n+    case OBJ_ZSET:\n+      return container_utils::IterateSortedSet(\n+          pv.AsRObj(), [&cb](container_utils::ContainerEntry ce, double) { return cb(ce); });\n+    default:\n+      return false;\n+  }\n+}\n+\n+// Create a SortEntryList from given key\n+OpResult<SortEntryList> OpFetchSortEntries(const OpArgs& op_args, std::string_view key,\n+                                           bool alpha) {\n+  using namespace container_utils;\n+\n+  auto [it, _] = op_args.shard->db_slice().FindExt(op_args.db_ind, key);\n+  if (!IsValid(it) || !IsContainer(it->second)) {\n+    return OpStatus::KEY_NOTFOUND;\n+  }\n+\n+  auto result = MakeSortEntryList(alpha);\n+  bool success = std::visit(\n+      [&pv = it->second](auto& entries) {\n+        entries.reserve(pv.Size());\n+        return Iterate(pv, [&entries](auto&& val) {\n+          return entries.emplace_back().Parse(std::forward<decltype(val)>(val));\n+        });\n+      },\n+      result);\n+  return success ? OpResult{std::move(result)} : OpStatus::WRONG_TYPE;\n+}\n+\n+void GenericFamily::Sort(CmdArgList args, ConnectionContext* cntx) {\n+  std::string_view key = ArgS(args, 1);\n+  bool alpha = false;\n+  bool reversed = false;\n+  std::optional<std::pair<size_t, size_t>> bounds;\n+\n+  for (size_t i = 2; i < args.size(); i++) {\n+    ToUpper(&args[i]);\n+\n+    std::string_view arg = ArgS(args, i);\n+    if (arg == \"ALPHA\") {\n+      alpha = true;\n+    } else if (arg == \"DESC\") {\n+      reversed = true;\n+    } else if (arg == \"LIMIT\") {\n+      int offset, limit;\n+      if (i + 2 >= args.size()) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+      if (!absl::SimpleAtoi(ArgS(args, i + 1), &offset) ||\n+          !absl::SimpleAtoi(ArgS(args, i + 2), &limit)) {\n+        return (*cntx)->SendError(kInvalidIntErr);\n+      }\n+      bounds = {offset, limit};\n+      i += 2;\n+    }\n+  }\n+\n+  OpResult<SortEntryList> entries =\n+      cntx->transaction->ScheduleSingleHopT([&](Transaction* t, EngineShard* shard) {\n+        return OpFetchSortEntries(t->GetOpArgs(shard), key, alpha);\n+      });\n+\n+  if (entries.status() == OpStatus::WRONG_TYPE)\n+    return (*cntx)->SendError(\"One or more scores can't be converted into double\");\n+\n+  if (!entries.ok())\n+    return (*cntx)->SendEmptyArray();\n+\n+  auto sort_call = [cntx, bounds, reversed, key](auto& entries) {\n+    if (bounds) {\n+      auto sort_it = entries.begin() + std::min(bounds->first + bounds->second, entries.size());\n+      std::partial_sort(entries.begin(), sort_it, entries.end(),\n+                        [reversed](const auto& lhs, const auto& rhs) {\n+                          return bool(lhs.Cmp() < rhs.Cmp()) ^ reversed;\n+                        });\n+    } else {\n+      std::sort(entries.begin(), entries.end(), [reversed](const auto& lhs, const auto& rhs) {\n+        return bool(lhs.Cmp() < rhs.Cmp()) ^ reversed;\n+      });\n+    }\n+\n+    auto start_it = entries.begin();\n+    auto end_it = entries.end();\n+    if (bounds) {\n+      start_it += std::min(bounds->first, entries.size());\n+      end_it = entries.begin() + std::min(bounds->first + bounds->second, entries.size());\n+    }\n+\n+    (*cntx)->StartArray(std::distance(start_it, end_it));\n+    for (auto it = start_it; it != end_it; ++it) {\n+      (*cntx)->SendBulkString(it->key);\n+    }\n+  };\n+  std::visit(std::move(sort_call), entries.value());\n+}\n+\n void GenericFamily::Move(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   int64_t target_db;\n@@ -868,6 +1032,7 @@ void GenericFamily::Register(CommandRegistry* registry) {\n             << CI{\"TYPE\", CO::READONLY | CO::FAST | CO::LOADING, 2, 1, 1, 1}.HFUNC(Type)\n             << CI{\"UNLINK\", CO::WRITE, -2, 1, -1, 1}.HFUNC(Del)\n             << CI{\"STICK\", CO::WRITE, -2, 1, -1, 1}.HFUNC(Stick)\n+            << CI{\"SORT\", CO::READONLY, -2, 1, 1, 1}.HFUNC(Sort)\n             << CI{\"MOVE\", CO::WRITE | CO::GLOBAL_TRANS, 3, 1, 1, 1}.HFUNC(Move);\n }\n \ndiff --git a/src/server/generic_family.h b/src/server/generic_family.h\nindex dd4b526f02be..346e8a8eb0bc 100644\n--- a/src/server/generic_family.h\n+++ b/src/server/generic_family.h\n@@ -49,6 +49,7 @@ class GenericFamily {\n   static void Keys(CmdArgList args, ConnectionContext* cntx);\n   static void PexpireAt(CmdArgList args, ConnectionContext* cntx);\n   static void Stick(CmdArgList args, ConnectionContext* cntx);\n+  static void Sort(CmdArgList args, ConnectionContext* cntx);\n   static void Move(CmdArgList args, ConnectionContext* cntx);\n \n   static void Rename(CmdArgList args, ConnectionContext* cntx);\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 08d771dd846f..33d8c5aba180 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -19,6 +19,7 @@ extern \"C\" {\n #include \"server/error.h\"\n #include \"server/server_state.h\"\n #include \"server/transaction.h\"\n+#include \"server/container_utils.h\"\n \n /**\n  * The number of entries allowed per internal list node can be specified\n@@ -65,17 +66,6 @@ using absl::GetFlag;\n \n namespace {\n \n-quicklistEntry QLEntry() {\n-  quicklistEntry res{.quicklist = NULL,\n-                     .node = NULL,\n-                     .zi = NULL,\n-                     .value = NULL,\n-                     .longval = 0,\n-                     .sz = 0,\n-                     .offset = 0};\n-  return res;\n-}\n-\n quicklist* GetQL(const PrimeValue& mv) {\n   return (quicklist*)mv.RObjPtr();\n }\n@@ -358,7 +348,7 @@ OpResult<string> RPeek(const OpArgs& op_args, string_view key, bool fetch) {\n     return OpStatus::OK;\n \n   quicklist* ql = GetQL(it_res.value()->second);\n-  quicklistEntry entry = QLEntry();\n+  quicklistEntry entry = container_utils::QLEntry();\n   quicklistIter* iter = quicklistGetIterator(ql, AL_START_TAIL);\n   CHECK(quicklistNext(iter, &entry));\n   quicklistReleaseIterator(iter);\n@@ -845,7 +835,7 @@ OpResult<string> ListFamily::OpIndex(const OpArgs& op_args, std::string_view key\n   if (!res)\n     return res.status();\n   quicklist* ql = GetQL(res.value()->second);\n-  quicklistEntry entry = QLEntry();\n+  quicklistEntry entry = container_utils::QLEntry();\n   quicklistIter* iter = quicklistGetIteratorAtIdx(ql, AL_START_TAIL, index);\n   if (!iter)\n     return OpStatus::KEY_NOTFOUND;\n@@ -871,7 +861,7 @@ OpResult<int> ListFamily::OpInsert(const OpArgs& op_args, string_view key, strin\n     return it_res.status();\n \n   quicklist* ql = GetQL(it_res.value()->second);\n-  quicklistEntry entry = QLEntry();\n+  quicklistEntry entry = container_utils::QLEntry();\n   quicklistIter* qiter = quicklistGetIterator(ql, AL_START_HEAD);\n   bool found = false;\n \n@@ -1030,24 +1020,12 @@ OpResult<StringVec> ListFamily::OpRange(const OpArgs& op_args, std::string_view\n     return StringVec{};\n   }\n \n-  if (end >= llen)\n-    end = llen - 1;\n-\n-  unsigned lrange = end - start + 1;\n-  quicklistIter* qiter = quicklistGetIteratorAtIdx(ql, AL_START_HEAD, start);\n-  quicklistEntry entry = QLEntry();\n   StringVec str_vec;\n-\n-  unsigned cnt = 0;\n-  while (cnt < lrange && quicklistNext(qiter, &entry)) {\n-    if (entry.value)\n-      str_vec.emplace_back(reinterpret_cast<char*>(entry.value), entry.sz);\n-    else\n-      str_vec.push_back(absl::StrCat(entry.longval));\n-    ++cnt;\n-  }\n-  quicklistReleaseIterator(qiter);\n-\n+  container_utils::IterateList(res.value()->second, [&str_vec](container_utils::ContainerEntry ce) {\n+    str_vec.emplace_back(ce.ToString());\n+    return true;\n+  }, start, end);\n+  \n   return str_vec;\n }\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex acf8226a6889..d80e7c3dc60b 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1439,7 +1439,7 @@ void ServerFamily::Latency(CmdArgList args, ConnectionContext* cntx) {\n   string_view sub_cmd = ArgS(args, 1);\n \n   if (sub_cmd == \"LATEST\") {\n-    return (*cntx)->StartArray(0);\n+    return (*cntx)->SendEmptyArray();\n   }\n \n   LOG_FIRST_N(ERROR, 10) << \"Subcommand \" << sub_cmd << \" not supported\";\ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex cd36b6c70fd6..5411fefe41eb 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -21,6 +21,8 @@ extern \"C\" {\n #include \"server/error.h\"\n #include \"server/transaction.h\"\n \n+#include \"server/container_utils.h\"\n+\n ABSL_DECLARE_FLAG(bool, use_set2);\n \n namespace dfly {\n@@ -146,27 +148,6 @@ void InitStrSet(CompactObj* set) {\n   }\n }\n \n-// f receives a str object.\n-template <typename F> void FillFromStrSet(F&& f, void* ptr) {\n-  string str;\n-  if (GetFlag(FLAGS_use_set2)) {\n-    for (sds ptr : *(StringSet*)ptr) {\n-      str.assign(ptr, sdslen(ptr));\n-      f(move(str));\n-    }\n-  } else {\n-    dict* ds = (dict*)ptr;\n-\n-    dictIterator* di = dictGetIterator(ds);\n-    dictEntry* de = nullptr;\n-    while ((de = dictNext(di))) {\n-      str.assign((sds)de->key, sdslen((sds)de->key));\n-      f(move(str));\n-    }\n-    dictReleaseIterator(di);\n-  }\n-}\n-\n // returns (removed, isempty)\n pair<unsigned, bool> RemoveSet(ArgSlice vals, CompactObj* set) {\n   bool isempty = false;\n@@ -493,22 +474,6 @@ OpStatus NoOpCb(Transaction* t, EngineShard* shard) {\n   return OpStatus::OK;\n };\n \n-template <typename F> void FillSet(const SetType& set, F&& f) {\n-  if (set.second == kEncodingIntSet) {\n-    intset* is = (intset*)set.first;\n-    int64_t ival;\n-    int ii = 0;\n-    char buf[32];\n-\n-    while (intsetGet(is, ii++, &ival)) {\n-      char* next = absl::numbers_internal::FastIntToBuffer(ival, buf);\n-      f(string{buf, size_t(next - buf)});\n-    }\n-  } else {\n-    FillFromStrSet(move(f), set.first);\n-  }\n-}\n-\n // if overwrite is true then OpAdd writes vals into the key and discards its previous value.\n OpResult<uint32_t> OpAdd(const OpArgs& op_args, std::string_view key, ArgSlice vals,\n                          bool overwrite) {\n@@ -713,8 +678,10 @@ OpResult<StringVec> OpUnion(const OpArgs& op_args, ArgSlice keys) {\n   for (std::string_view key : keys) {\n     OpResult<PrimeIterator> find_res = op_args.shard->db_slice().Find(op_args.db_ind, key, OBJ_SET);\n     if (find_res) {\n-      SetType st{find_res.value()->second.RObjPtr(), find_res.value()->second.Encoding()};\n-      FillSet(st, [&uniques](string s) { uniques.emplace(move(s)); });\n+      container_utils::IterateSet(find_res.value()->second, [&uniques](container_utils::ContainerEntry ce){\n+        uniques.emplace(ce.ToString());\n+        return true;\n+      });\n       continue;\n     }\n \n@@ -738,9 +705,10 @@ OpResult<StringVec> OpDiff(const OpArgs& op_args, ArgSlice keys) {\n   }\n \n   absl::flat_hash_set<string> uniques;\n-  SetType st{find_res.value()->second.RObjPtr(), find_res.value()->second.Encoding()};\n-\n-  FillSet(st, [&uniques](string s) { uniques.insert(move(s)); });\n+  container_utils::IterateSet(find_res.value()->second, [&uniques](container_utils::ContainerEntry ce) {\n+    uniques.emplace(ce.ToString());\n+    return true;\n+  });\n \n   DCHECK(!uniques.empty());  // otherwise the key would not exist.\n \n@@ -786,9 +754,10 @@ OpResult<StringVec> OpInter(const Transaction* t, EngineShard* es, bool remove_f\n     if (!find_res)\n       return find_res.status();\n \n-    SetType st{find_res.value()->second.RObjPtr(), find_res.value()->second.Encoding()};\n-\n-    FillSet(st, [&result](string s) { result.push_back(move(s)); });\n+    container_utils::IterateSet(find_res.value()->second, [&result](container_utils::ContainerEntry ce) {\n+      result.push_back(ce.ToString());\n+      return true;\n+    });\n     return result;\n   }\n \n@@ -1261,16 +1230,20 @@ OpResult<StringVec> SetFamily::OpPop(const OpArgs& op_args, std::string_view key\n \n   PrimeIterator it = find_res.value();\n   size_t slen = it->second.Size();\n-  SetType st{it->second.RObjPtr(), it->second.Encoding()};\n \n   /* CASE 1:\n    * The number of requested elements is greater than or equal to\n    * the number of elements inside the set: simply return the whole set. */\n   if (count >= slen) {\n-    FillSet(st, [&result](string s) { result.push_back(move(s)); });\n+    container_utils::IterateSet(it->second, [&result](container_utils::ContainerEntry ce) {\n+      result.push_back(ce.ToString());\n+      return true;\n+    });\n+\n     /* Delete the set as it is now empty */\n     CHECK(db_slice.Del(op_args.db_ind, it));\n   } else {\n+    SetType st{it->second.RObjPtr(), it->second.Encoding()};\n     db_slice.PreUpdate(op_args.db_ind, it);\n     if (st.second == kEncodingIntSet) {\n       intset* is = (intset*)st.first;\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex be9d6aafe17a..49c65ea6d254 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -847,7 +847,7 @@ void StreamFamily::XRangeGeneric(CmdArgList args, bool is_rev, ConnectionContext\n   }\n \n   if (result.status() == OpStatus::KEY_NOTFOUND) {\n-    return (*cntx)->StartArray(0);\n+    return (*cntx)->SendEmptyArray();\n   }\n   return (*cntx)->SendError(result.status());\n }\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex d57b4de35045..4a4c1235fc47 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -18,6 +18,7 @@ extern \"C\" {\n #include \"server/conn_context.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/transaction.h\"\n+#include \"server/container_utils.h\"\n \n namespace dfly {\n \n@@ -244,60 +245,10 @@ void IntervalVisitor::operator()(const ZSetFamily::LexInterval& li) {\n }\n \n void IntervalVisitor::ActionRange(unsigned start, unsigned end) {\n-  unsigned rangelen = (end - start) + 1;\n-\n-  if (zobj_->encoding == OBJ_ENCODING_LISTPACK) {\n-    uint8_t* zl = (uint8_t*)zobj_->ptr;\n-    uint8_t *eptr, *sptr;\n-    uint8_t* vstr;\n-    unsigned int vlen;\n-    long long vlong;\n-    double score = 0.0;\n-\n-    if (params_.reverse)\n-      eptr = lpSeek(zl, -2 - long(2 * start));\n-    else\n-      eptr = lpSeek(zl, 2 * start);\n-    DCHECK(eptr);\n-\n-    sptr = lpNext(zl, eptr);\n-\n-    while (rangelen--) {\n-      DCHECK(eptr != NULL && sptr != NULL);\n-      vstr = lpGetValue(eptr, &vlen, &vlong);\n-\n-      if (params_.with_scores) /* don't bother to extract the score if it's gonna be ignored. */\n-        score = zzlGetScore(sptr);\n-\n-      AddResult(vstr, vlen, vlong, score);\n-\n-      Next(zl, &eptr, &sptr);\n-    }\n-  } else {\n-    CHECK_EQ(zobj_->encoding, OBJ_ENCODING_SKIPLIST);\n-    zset* zs = (zset*)zobj_->ptr;\n-    zskiplist* zsl = zs->zsl;\n-    zskiplistNode* ln;\n-\n-    /* Check if starting point is trivial, before doing log(N) lookup. */\n-    if (params_.reverse) {\n-      ln = zsl->tail;\n-      unsigned long llen = zsetLength(zobj_);\n-      if (start > 0)\n-        ln = zslGetElementByRank(zsl, llen - start);\n-    } else {\n-      ln = zsl->header->level[0].forward;\n-      if (start > 0)\n-        ln = zslGetElementByRank(zsl, start + 1);\n-    }\n-\n-    while (rangelen--) {\n-      DCHECK(ln != NULL);\n-      sds ele = ln->ele;\n-      result_.emplace_back(string(ele, sdslen(ele)), ln->score);\n-      ln = Next(ln);\n-    }\n-  }\n+  container_utils::IterateSortedSet(zobj_, [this](container_utils::ContainerEntry ce, double score){\n+    result_.emplace_back(ce.ToString(), score);\n+    return true;\n+  }, start, end, params_.reverse, params_.with_scores);\n }\n \n void IntervalVisitor::ActionRange(const zrangespec& range) {\n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex 6ac0f63f54f6..932be0dae9e7 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -160,7 +160,7 @@ TEST_F(GenericFamilyTest, RenameNx) {\n   Run({\"mset\", \"x\", x_val, \"b\", b_val});\n \n   ASSERT_THAT(Run({\"renamenx\", \"z\", \"b\"}), ErrArg(\"no such key\"));\n-  ASSERT_THAT(Run({\"renamenx\", \"x\", \"b\"}), IntArg(0)); // b already exists\n+  ASSERT_THAT(Run({\"renamenx\", \"x\", \"b\"}), IntArg(0));  // b already exists\n   ASSERT_THAT(Run({\"renamenx\", \"x\", \"y\"}), IntArg(1));\n   ASSERT_EQ(Run({\"get\", \"y\"}), x_val);\n }\n@@ -169,7 +169,7 @@ TEST_F(GenericFamilyTest, Stick) {\n   // check stick returns zero on non-existent keys\n   ASSERT_THAT(Run({\"stick\", \"a\", \"b\"}), IntArg(0));\n \n-  for (auto key: {\"a\", \"b\", \"c\", \"d\"}) {\n+  for (auto key : {\"a\", \"b\", \"c\", \"d\"}) {\n     Run({\"set\", key, \".\"});\n   }\n \n@@ -276,4 +276,59 @@ TEST_F(GenericFamilyTest, Scan) {\n   EXPECT_THAT(vec, Each(StartsWith(\"zset\")));\n }\n \n+TEST_F(GenericFamilyTest, Sort) {\n+  // Test list sort with params\n+  Run({\"del\", \"list-1\"});\n+  Run({\"lpush\", \"list-1\", \"3.5\", \"1.2\", \"10.1\", \"2.20\", \"200\"});\n+  // numeric\n+  ASSERT_THAT(Run({\"sort\", \"list-1\"}).GetVec(), ElementsAre(\"1.2\", \"2.20\", \"3.5\", \"10.1\", \"200\"));\n+  // string\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"ALPHA\"}).GetVec(), ElementsAre(\"1.2\", \"10.1\", \"2.20\", \"200\", \"3.5\"));\n+  // desc numeric\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"DESC\"}).GetVec(), ElementsAre(\"200\", \"10.1\", \"3.5\", \"2.20\", \"1.2\"));\n+  // desc strig\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"DESC\", \"ALPHA\"}).GetVec(), ElementsAre(\"3.5\", \"200\", \"2.20\", \"10.1\", \"1.2\"));\n+  // limits\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"LIMIT\", \"0\", \"5\"}).GetVec(), ElementsAre(\"1.2\", \"2.20\", \"3.5\", \"10.1\", \"200\"));\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"LIMIT\", \"0\", \"10\"}).GetVec(), ElementsAre(\"1.2\", \"2.20\", \"3.5\", \"10.1\", \"200\"));\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"LIMIT\", \"2\", \"2\"}).GetVec(), ElementsAre(\"3.5\", \"10.1\"));\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"LIMIT\", \"1\", \"1\"}), \"2.20\");\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"LIMIT\", \"4\", \"2\"}), \"200\");\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"LIMIT\", \"5\", \"2\"}), ArrLen(0));\n+  // limits desc\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"DESC\", \"LIMIT\", \"0\", \"5\"}).GetVec(), ElementsAre(\"200\", \"10.1\", \"3.5\", \"2.20\", \"1.2\"));\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"DESC\", \"LIMIT\", \"2\", \"2\"}).GetVec(), ElementsAre(\"3.5\", \"2.20\"));\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"DESC\", \"LIMIT\", \"1\", \"1\"}), \"10.1\");\n+  ASSERT_THAT(Run({\"sort\", \"list-1\", \"DESC\", \"LIMIT\", \"5\", \"2\"}), ArrLen(0));\n+\n+  // Test set sort\n+  Run({\"del\", \"set-1\"});\n+  Run({\"sadd\", \"set-1\", \"5.3\", \"4.4\", \"60\", \"99.9\", \"100\", \"9\"});\n+  ASSERT_THAT(Run({\"sort\", \"set-1\"}).GetVec(), ElementsAre(\"4.4\", \"5.3\", \"9\", \"60\", \"99.9\", \"100\"));\n+  ASSERT_THAT(Run({\"sort\", \"set-1\", \"ALPHA\"}).GetVec(), ElementsAre(\"100\", \"4.4\", \"5.3\", \"60\", \"9\", \"99.9\"));\n+  ASSERT_THAT(Run({\"sort\", \"set-1\", \"DESC\"}).GetVec(), ElementsAre(\"100\", \"99.9\", \"60\", \"9\", \"5.3\", \"4.4\"));\n+  ASSERT_THAT(Run({\"sort\", \"set-1\", \"DESC\", \"ALPHA\"}).GetVec(), ElementsAre(\"99.9\", \"9\", \"60\", \"5.3\", \"4.4\", \"100\"));\n+\n+  // Test intset sort\n+  Run({\"del\", \"intset-1\"});\n+  Run({\"sadd\", \"intset-1\", \"5\", \"4\", \"3\", \"2\", \"1\"});\n+  ASSERT_THAT(Run({\"sort\", \"intset-1\"}).GetVec(), ElementsAre(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+\n+  // Test sorted set sort\n+  Run({\"del\", \"zset-1\"});\n+  Run({\"zadd\", \"zset-1\", \"0\", \"3.3\", \"0\", \"30.1\", \"0\", \"8.2\"});\n+  ASSERT_THAT(Run({\"sort\", \"zset-1\"}).GetVec(), ElementsAre(\"3.3\", \"8.2\", \"30.1\"));\n+  ASSERT_THAT(Run({\"sort\", \"zset-1\", \"ALPHA\"}).GetVec(), ElementsAre(\"3.3\", \"30.1\", \"8.2\"));\n+  ASSERT_THAT(Run({\"sort\", \"zset-1\", \"DESC\"}).GetVec(), ElementsAre(\"30.1\", \"8.2\", \"3.3\"));\n+  ASSERT_THAT(Run({\"sort\", \"zset-1\", \"DESC\", \"ALPHA\"}).GetVec(), ElementsAre(\"8.2\", \"30.1\", \"3.3\"));\n+\n+  // Test sort with non existent key\n+  Run({\"del\", \"list-2\"});\n+  ASSERT_THAT(Run({\"sort\", \"list-2\"}), ArrLen(0));\n+\n+  // Test not convertible to double\n+  Run({\"lpush\", \"list-2\", \"NOTADOUBLE\"});\n+  ASSERT_THAT(Run({\"sort\", \"list-2\"}), ErrArg(\"One or more scores can't be converted into double\"));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Support SORT command\nPart of #91 \n",
  "hints_text": "",
  "created_at": "2022-09-18T13:35:10Z",
  "modified_files": [
    "docs/differences.md",
    "src/core/compact_object.cc",
    "src/facade/reply_builder.cc",
    "src/facade/reply_builder.h",
    "src/server/CMakeLists.txt",
    "b/src/server/container_utils.cc",
    "b/src/server/container_utils.h",
    "src/server/generic_family.cc",
    "src/server/generic_family.h",
    "src/server/list_family.cc",
    "src/server/server_family.cc",
    "src/server/set_family.cc",
    "src/server/stream_family.cc",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc"
  ]
}