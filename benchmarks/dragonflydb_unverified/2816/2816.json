{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2816,
  "instance_id": "dragonflydb__dragonfly-2816",
  "issue_numbers": [
    "2660"
  ],
  "base_commit": "bb242a78941df8a1b31fd55ae0a875e8c662618b",
  "patch": "diff --git a/src/facade/conn_context.h b/src/facade/conn_context.h\nindex 9ba641108421..b5bce8b4f4d0 100644\n--- a/src/facade/conn_context.h\n+++ b/src/facade/conn_context.h\n@@ -97,10 +97,9 @@ class ConnectionContext {\n   bool async_dispatch : 1;    // whether this connection is amid an async dispatch\n   bool sync_dispatch : 1;     // whether this connection is amid a sync dispatch\n   bool journal_emulated : 1;  // whether it is used to dispatch journal commands\n-  bool paused : 1;            // whether this connection is paused due to CLIENT PAUSE\n-\n+  bool paused = false;        // whether this connection is paused due to CLIENT PAUSE\n   // whether it's blocked on blocking commands like BLPOP, needs to be addressable\n-  bool blocked;\n+  bool blocked = false;\n \n   // How many async subscription sources are active: monitor and/or pubsub - at most 2.\n   uint8_t subscriptions;\ndiff --git a/src/server/container_utils.cc b/src/server/container_utils.cc\nindex ab5caab7ae6a..0af7f1b35ba6 100644\n--- a/src/server/container_utils.cc\n+++ b/src/server/container_utils.cc\n@@ -258,7 +258,7 @@ string_view LpGetView(uint8_t* lp_it, uint8_t int_buf[]) {\n \n OpResult<string> RunCbOnFirstNonEmptyBlocking(Transaction* trans, int req_obj_type,\n                                               BlockingResultCb func, unsigned limit_ms,\n-                                              bool* block_flag) {\n+                                              bool* block_flag, bool* pause_flag) {\n   string result_key;\n \n   // Fast path. If we have only a single shard, we can run opportunistically with a single hop.\n@@ -317,9 +317,7 @@ OpResult<string> RunCbOnFirstNonEmptyBlocking(Transaction* trans, int req_obj_ty\n     return owner->db_slice().FindReadOnly(context, key, req_obj_type).ok();\n   };\n \n-  *block_flag = true;\n-  auto status = trans->WaitOnWatch(limit_tp, std::move(wcb), key_checker);\n-  *block_flag = false;\n+  auto status = trans->WaitOnWatch(limit_tp, std::move(wcb), key_checker, block_flag, pause_flag);\n \n   if (status != OpStatus::OK)\n     return status;\ndiff --git a/src/server/container_utils.h b/src/server/container_utils.h\nindex 508af5c0b9e3..e149ce95feef 100644\n--- a/src/server/container_utils.h\n+++ b/src/server/container_utils.h\n@@ -87,10 +87,9 @@ using BlockingResultCb =\n // Block until a any key of the transaction becomes non-empty and executes the callback.\n // If multiple keys are non-empty when this function is called, the callback is executed\n // immediately with the first key listed in the tx arguments.\n-// The block flag is set to true while the transaction is blocking.\n OpResult<std::string> RunCbOnFirstNonEmptyBlocking(Transaction* trans, int req_obj_type,\n                                                    BlockingResultCb cb, unsigned limit_ms,\n-                                                   bool* block_flag);\n+                                                   bool* block_flag, bool* pause_flag);\n \n };  // namespace container_utils\n \ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex fc06a484bcef..ca5bec84decb 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -164,11 +164,11 @@ class BPopPusher {\n \n   // Returns WRONG_TYPE, OK.\n   // If OK is returned then use result() to fetch the value.\n-  OpResult<string> Run(Transaction* t, unsigned limit_ms);\n+  OpResult<string> Run(ConnectionContext* cntx, unsigned limit_ms);\n \n  private:\n-  OpResult<string> RunSingle(Transaction* t, time_point tp);\n-  OpResult<string> RunPair(Transaction* t, time_point tp);\n+  OpResult<string> RunSingle(ConnectionContext* cntx, time_point tp);\n+  OpResult<string> RunPair(ConnectionContext* cntx, time_point tp);\n \n   string_view pop_key_, push_key_;\n   ListDir popdir_, pushdir_;\n@@ -765,7 +765,7 @@ void BRPopLPush(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   BPopPusher bpop_pusher(src, dest, ListDir::RIGHT, ListDir::LEFT);\n-  OpResult<string> op_res = bpop_pusher.Run(cntx->transaction, unsigned(timeout * 1000));\n+  OpResult<string> op_res = bpop_pusher.Run(cntx, unsigned(timeout * 1000));\n \n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   if (op_res) {\n@@ -808,7 +808,7 @@ void BLMove(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   BPopPusher bpop_pusher(src, dest, *src_dir, *dest_dir);\n-  OpResult<string> op_res = bpop_pusher.Run(cntx->transaction, unsigned(timeout * 1000));\n+  OpResult<string> op_res = bpop_pusher.Run(cntx, unsigned(timeout * 1000));\n \n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   if (op_res) {\n@@ -831,20 +831,21 @@ BPopPusher::BPopPusher(string_view pop_key, string_view push_key, ListDir popdir\n     : pop_key_(pop_key), push_key_(push_key), popdir_(popdir), pushdir_(pushdir) {\n }\n \n-OpResult<string> BPopPusher::Run(Transaction* t, unsigned limit_ms) {\n+OpResult<string> BPopPusher::Run(ConnectionContext* cntx, unsigned limit_ms) {\n   time_point tp =\n       limit_ms ? chrono::steady_clock::now() + chrono::milliseconds(limit_ms) : time_point::max();\n \n-  t->Schedule();\n+  cntx->transaction->Schedule();\n \n-  if (t->GetUniqueShardCnt() == 1) {\n-    return RunSingle(t, tp);\n+  if (cntx->transaction->GetUniqueShardCnt() == 1) {\n+    return RunSingle(cntx, tp);\n   }\n \n-  return RunPair(t, tp);\n+  return RunPair(cntx, tp);\n }\n \n-OpResult<string> BPopPusher::RunSingle(Transaction* t, time_point tp) {\n+OpResult<string> BPopPusher::RunSingle(ConnectionContext* cntx, time_point tp) {\n+  Transaction* t = cntx->transaction;\n   OpResult<string> op_res;\n   bool is_multi = t->IsMulti();\n   auto cb_move = [&](Transaction* t, EngineShard* shard) {\n@@ -873,14 +874,16 @@ OpResult<string> BPopPusher::RunSingle(Transaction* t, time_point tp) {\n     return owner->db_slice().FindReadOnly(context, key, OBJ_LIST).ok();\n   };\n   // Block\n-  if (auto status = t->WaitOnWatch(tp, std::move(wcb), key_checker); status != OpStatus::OK)\n+  auto status = t->WaitOnWatch(tp, std::move(wcb), key_checker, &(cntx->blocked), &(cntx->paused));\n+  if (status != OpStatus::OK)\n     return status;\n \n   t->Execute(cb_move, true);\n   return op_res;\n }\n \n-OpResult<string> BPopPusher::RunPair(Transaction* t, time_point tp) {\n+OpResult<string> BPopPusher::RunPair(ConnectionContext* cntx, time_point tp) {\n+  Transaction* t = cntx->transaction;\n   bool is_multi = t->IsMulti();\n   OpResult<string> op_res = MoveTwoShards(t, pop_key_, push_key_, popdir_, pushdir_, false);\n \n@@ -902,7 +905,8 @@ OpResult<string> BPopPusher::RunPair(Transaction* t, time_point tp) {\n     return owner->db_slice().FindReadOnly(context, key, OBJ_LIST).ok();\n   };\n \n-  if (auto status = t->WaitOnWatch(tp, std::move(wcb), key_checker); status != OpStatus::OK)\n+  if (auto status = t->WaitOnWatch(tp, std::move(wcb), key_checker, &cntx->blocked, &cntx->paused);\n+      status != OpStatus::OK)\n     return status;\n \n   return MoveTwoShards(t, pop_key_, push_key_, popdir_, pushdir_, true);\n@@ -1194,7 +1198,8 @@ void ListFamily::BPopGeneric(ListDir dir, CmdArgList args, ConnectionContext* cn\n   };\n \n   OpResult<string> popped_key = container_utils::RunCbOnFirstNonEmptyBlocking(\n-      transaction, OBJ_LIST, std::move(cb), unsigned(timeout * 1000), &cntx->blocked);\n+      transaction, OBJ_LIST, std::move(cb), unsigned(timeout * 1000), &cntx->blocked,\n+      &cntx->paused);\n \n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   if (popped_key) {\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 9d10fc01283b..d700fb5029cc 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -2833,7 +2833,8 @@ void XReadBlock(ReadOpts opts, ConnectionContext* cntx) {\n     return streamCompareID(&last_id, &sitem.group->last_id) > 0;\n   };\n \n-  if (auto status = cntx->transaction->WaitOnWatch(tp, std::move(wcb), key_checker);\n+  if (auto status = cntx->transaction->WaitOnWatch(tp, std::move(wcb), key_checker, &cntx->blocked,\n+                                                   &cntx->paused);\n       status != OpStatus::OK)\n     return rb->SendNullArray();\n \ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 36578ff7dbcb..b5aadaf9ced0 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1320,7 +1320,7 @@ size_t Transaction::ReverseArgIndex(ShardId shard_id, size_t arg_index) const {\n }\n \n OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_provider,\n-                                  KeyReadyChecker krc) {\n+                                  KeyReadyChecker krc, bool* block_flag, bool* pause_flag) {\n   DCHECK(!blocking_barrier_.IsClaimed());  // Blocking barrier can't be re-used\n \n   // Register keys on active shards blocking controllers and mark shard state as suspended.\n@@ -1333,16 +1333,19 @@ OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_p\n   auto* stats = ServerState::tl_connection_stats();\n   ++stats->num_blocked_clients;\n   DVLOG(1) << \"WaitOnWatch wait for \" << tp << \" \" << DebugId();\n-  // TBD set connection blocking state\n+\n   // Wait for the blocking barrier to be closed.\n   // Note: It might return immediately if another thread already notified us.\n+  *block_flag = true;\n   cv_status status = blocking_barrier_.Wait(tp);\n+  *block_flag = false;\n \n   DVLOG(1) << \"WaitOnWatch done \" << int(status) << \" \" << DebugId();\n   --stats->num_blocked_clients;\n \n-  // TBD set connection pause state\n+  *pause_flag = true;\n   ServerState::tlocal()->AwaitPauseState(true);  // blocking are always write commands\n+  *pause_flag = false;\n \n   OpStatus result = OpStatus::OK;\n   if (status == cv_status::timeout) {\ndiff --git a/src/server/transaction.h b/src/server/transaction.h\nindex 6aa9d0dbc75f..a1d62e3eaeb1 100644\n--- a/src/server/transaction.h\n+++ b/src/server/transaction.h\n@@ -213,7 +213,8 @@ class Transaction {\n   // or b) tp is reached. If tp is time_point::max() then waits indefinitely.\n   // Expects that the transaction had been scheduled before, and uses Execute(.., true) to register.\n   // Returns false if timeout occurred, true if was notified by one of the keys.\n-  facade::OpStatus WaitOnWatch(const time_point& tp, WaitKeysProvider cb, KeyReadyChecker krc);\n+  facade::OpStatus WaitOnWatch(const time_point& tp, WaitKeysProvider cb, KeyReadyChecker krc,\n+                               bool* block_flag, bool* pause_flag);\n \n   // Returns true if transaction is awaked, false if it's timed-out and can be removed from the\n   // blocking queue.\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 7d74639c4642..a27ddff04a2b 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -1318,7 +1318,8 @@ void BZPopMinMax(CmdArgList args, ConnectionContext* cntx, bool is_max) {\n   };\n \n   OpResult<string> popped_key = container_utils::RunCbOnFirstNonEmptyBlocking(\n-      transaction, OBJ_ZSET, std::move(cb), unsigned(timeout * 1000), &cntx->blocked);\n+      transaction, OBJ_ZSET, std::move(cb), unsigned(timeout * 1000), &cntx->blocked,\n+      &cntx->paused);\n \n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   if (popped_key) {\n",
  "test_patch": "diff --git a/src/server/blocking_controller_test.cc b/src/server/blocking_controller_test.cc\nindex b68843759586..e9af80b7a632 100644\n--- a/src/server/blocking_controller_test.cc\n+++ b/src/server/blocking_controller_test.cc\n@@ -93,11 +93,14 @@ TEST_F(BlockingControllerTest, Basic) {\n \n TEST_F(BlockingControllerTest, Timeout) {\n   time_point tp = steady_clock::now() + chrono::milliseconds(10);\n+  bool blocked;\n+  bool paused;\n \n   trans_->Schedule();\n   auto cb = [&](Transaction* t, EngineShard* shard) { return trans_->GetShardArgs(0); };\n \n-  facade::OpStatus status = trans_->WaitOnWatch(tp, cb, [](auto...) { return true; });\n+  facade::OpStatus status = trans_->WaitOnWatch(\n+      tp, cb, [](auto...) { return true; }, &blocked, &paused);\n \n   EXPECT_EQ(status, facade::OpStatus::TIMED_OUT);\n   unsigned num_watched = shard_set->Await(\ndiff --git a/tests/dragonfly/connection_test.py b/tests/dragonfly/connection_test.py\nindex 3c15f5479517..2b50f88b55d5 100755\n--- a/tests/dragonfly/connection_test.py\n+++ b/tests/dragonfly/connection_test.py\n@@ -698,6 +698,7 @@ async def do_write():\n     await p3\n \n \n+@dfly_args({\"proactor_threads\": \"4\"})\n async def test_blocking_command_client_pause(async_client: aioredis.Redis):\n     \"\"\"\n     1. Check client pause success when blocking transaction is running\n@@ -705,14 +706,19 @@ async def test_blocking_command_client_pause(async_client: aioredis.Redis):\n     3. once puased is finished lpush will run and blpop will pop the pushed value\n     \"\"\"\n \n-    async def blocking_command():\n-        res = await async_client.execute_command(\"blpop key 2\")\n-        assert res == [\"key\", \"value\"]\n+    async def blpop_command():\n+        res = await async_client.execute_command(\"blpop dest7 10\")\n+        assert res == [\"dest7\", \"value\"]\n+\n+    async def brpoplpush_command():\n+        res = await async_client.execute_command(\"brpoplpush src dest7 2\")\n+        assert res == \"value\"\n \n     async def lpush_command():\n-        await async_client.execute_command(\"lpush key value\")\n+        await async_client.execute_command(\"lpush src value\")\n \n-    blocking = asyncio.create_task(blocking_command())\n+    blpop = asyncio.create_task(blpop_command())\n+    brpoplpush = asyncio.create_task(brpoplpush_command())\n     await asyncio.sleep(0.1)\n \n     res = await async_client.execute_command(\"client pause 1000\")\n@@ -722,7 +728,8 @@ async def lpush_command():\n     assert not lpush.done()\n \n     await lpush\n-    await blocking\n+    await brpoplpush\n+    await blpop\n \n \n async def test_multiple_blocking_commands_client_pause(async_client: aioredis.Redis):\n",
  "problem_statement": "Bug: set connection blocking flag on all blocking commands\nneed to set blocking flag inside Transaction:: WaitOnWatch\r\nToday we set the blocking connection flag only from RunCbOnFirstNonEmptyBlocking\r\n\n",
  "hints_text": "",
  "created_at": "2024-04-02T07:37:35Z",
  "modified_files": [
    "src/facade/conn_context.h",
    "src/server/container_utils.cc",
    "src/server/container_utils.h",
    "src/server/list_family.cc",
    "src/server/stream_family.cc",
    "src/server/transaction.cc",
    "src/server/transaction.h",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/blocking_controller_test.cc",
    "tests/dragonfly/connection_test.py"
  ]
}