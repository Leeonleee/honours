{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5617,
  "instance_id": "dragonflydb__dragonfly-5617",
  "issue_numbers": [
    "5590"
  ],
  "base_commit": "99f14e1768ebda35c9112bf72e81248a0cfa6c3e",
  "patch": "diff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex c04b2bdc916c..2631368b94c6 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -419,22 +419,27 @@ OpResult<SvArray> InterResultVec(const ResultStringVec& result_vec, unsigned req\n       return OpStatus::OK;  // empty set.\n   }\n \n-  bool first = true;\n+  std::vector<const StringVec*> sorted_vec;\n   for (const auto& res : result_vec) {\n     if (res.status() == OpStatus::SKIPPED)\n       continue;\n-\n     DCHECK(res);  // we handled it above.\n+    sorted_vec.push_back(&res.value());\n+  }\n \n-    // I use this awkward 'first' condition instead of table[s]++ deliberately.\n-    // I do not want to add keys that I know will not stay in the set.\n-    if (first) {\n-      for (const string& s : res.value()) {\n-        uniques.emplace(s, 1);\n-      }\n-      first = false;\n-    } else {\n-      for (const string& s : res.value()) {\n+  // Sort the per shard-sorted sets\n+  if (!sorted_vec.empty()) {\n+    std::sort(sorted_vec.begin(), sorted_vec.end(),\n+              [](const auto* lhs, const auto* rhs) { return lhs->size() < rhs->size(); });\n+\n+    for (const string& s : *sorted_vec[0]) {\n+      uniques.emplace(s, 1);\n+    }\n+    // Remove the smallest\n+    sorted_vec.erase(sorted_vec.begin());\n+\n+    for (const auto& res : sorted_vec) {\n+      for (const string& s : *res) {\n         auto it = uniques.find(s);\n         if (it != uniques.end()) {\n           ++it->second;\n",
  "test_patch": "diff --git a/src/server/engine_shard_set_test.cc b/src/server/engine_shard_set_test.cc\nindex c6c9fa144664..5d6ea7b49325 100644\n--- a/src/server/engine_shard_set_test.cc\n+++ b/src/server/engine_shard_set_test.cc\n@@ -30,37 +30,11 @@ using testing::Pair;\n \n class RoundRobinSharderTest : public BaseFamilyTest {\n  protected:\n-  RoundRobinSharderTest() : BaseFamilyTest() {\n+  RoundRobinSharderTest() {\n     absl::SetFlag(&FLAGS_shard_round_robin_prefix, \"RR:\");\n     SetTestFlag(\"cluster_mode\", \"emulated\");\n     ResetService();\n   }\n-\n-  map<int, int> GetShardKeyCount() {\n-    map<int, int> m;\n-\n-    auto res = Run({\"debug\", \"shards\"});\n-    for (string_view line : absl::StrSplit(res.GetString(), '\\n')) {\n-      vector<string> parts = absl::StrSplit(line, \": \");\n-      if (parts.size() != 2) {\n-        continue;\n-      }\n-\n-      string_view k = parts[0];\n-      if (!absl::StartsWith(k, \"shard\") || !absl::EndsWith(k, \"_key_count\")) {\n-        continue;\n-      }\n-\n-      CHECK(absl::ConsumePrefix(&k, \"shard\")) << k;\n-      CHECK(absl::ConsumeSuffix(&k, \"_key_count\")) << k;\n-      int sid;\n-      CHECK(absl::SimpleAtoi(k, &sid));\n-      int count;\n-      CHECK(absl::SimpleAtoi(parts[1], &count));\n-      m[sid] = count;\n-    }\n-    return m;\n-  }\n };\n \n TEST_F(RoundRobinSharderTest, RoundRobinShard) {\ndiff --git a/src/server/set_family_test.cc b/src/server/set_family_test.cc\nindex d751826e319f..cf1e57f74edd 100644\n--- a/src/server/set_family_test.cc\n+++ b/src/server/set_family_test.cc\n@@ -16,7 +16,7 @@ extern \"C\" {\n #include \"redis/zmalloc.h\"\n }\n \n-ABSL_DECLARE_FLAG(bool, legacy_saddex_keepttl);\n+ABSL_DECLARE_FLAG(std::string, shard_round_robin_prefix);\n \n using namespace testing;\n using namespace std;\n@@ -442,4 +442,30 @@ TEST_F(SetFamilyTest, CheckSetLinkExpiryTransfer) {\n   EXPECT_THAT(Run(\"SCARD key\"), IntArg(0));\n }\n \n+TEST_F(SetFamilyTest, SetInter_5590) {\n+  absl::FlagSaver fs;\n+  // Default break num_shards=2 and threads=3\n+  // TODO(#5651) fix it\n+  SetTestFlag(\"num_shards\", \"4\");\n+  num_threads_ = 4;\n+  SetTestFlag(\"shard_round_robin_prefix\", \"prefix-\");\n+  ResetService();\n+\n+  Run(\"DEBUG POPULATE 1 prefix- 5 RAND ELEMENTS 5000 TYPE SET\");\n+  Run(\"SADD prefix-:0 common\");\n+  // shard 0 has 1 key\n+  EXPECT_THAT(GetShardKeyCount(), Contains(Pair(0, 1)));\n+\n+  Run(\"SADD prefix-foo bar hello common\");\n+  // shard 1 has 1 key\n+  EXPECT_THAT(GetShardKeyCount(), Contains(Pair(0, 1)));\n+  EXPECT_THAT(GetShardKeyCount(), Contains(Pair(1, 1)));\n+\n+  int64_t start = absl::GetCurrentTimeNanos();\n+  Run(\"SINTER prefix-foo prefix-:0\");\n+  int64_t end = absl::GetCurrentTimeNanos();\n+  // Less than 100 ms. Before the fix it took 3seconds.\n+  EXPECT_LE(end - start, 100000000);\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex 3e0abaf06cfe..4bcef866e3fa 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -783,6 +783,32 @@ void BaseFamilyTest::SetTestFlag(string_view flag_name, string_view new_value) {\n   CHECK(flag->ParseFrom(new_value, &error)) << \"Error: \" << error;\n }\n \n+std::map<int, int> BaseFamilyTest::GetShardKeyCount() {\n+  map<int, int> m;\n+\n+  auto res = Run({\"debug\", \"shards\"});\n+  for (string_view line : absl::StrSplit(res.GetString(), '\\n')) {\n+    vector<string> parts = absl::StrSplit(line, \": \");\n+    if (parts.size() != 2) {\n+      continue;\n+    }\n+\n+    string_view k = parts[0];\n+    if (!absl::StartsWith(k, \"shard\") || !absl::EndsWith(k, \"_key_count\")) {\n+      continue;\n+    }\n+\n+    CHECK(absl::ConsumePrefix(&k, \"shard\")) << k;\n+    CHECK(absl::ConsumeSuffix(&k, \"_key_count\")) << k;\n+    int sid;\n+    CHECK(absl::SimpleAtoi(k, &sid));\n+    int count;\n+    CHECK(absl::SimpleAtoi(parts[1], &count));\n+    m[sid] = count;\n+  }\n+  return m;\n+}\n+\n const acl::AclFamily* BaseFamilyTest::TestInitAclFam() {\n   absl::SetFlag(&FLAGS_acllog_max_len, 0);\n   return service_->TestInit();\ndiff --git a/src/server/test_utils.h b/src/server/test_utils.h\nindex 01d6fa638f69..d8e17883d411 100644\n--- a/src/server/test_utils.h\n+++ b/src/server/test_utils.h\n@@ -70,7 +70,6 @@ class BaseFamilyTest : public ::testing::Test {\n   void SetUp() override;\n   void TearDown() override;\n \n- protected:\n   class TestConnWrapper;\n \n   RespExpr Run(std::initializer_list<const std::string_view> list) {\n@@ -160,6 +159,8 @@ class BaseFamilyTest : public ::testing::Test {\n \n   const acl::AclFamily* TestInitAclFam();\n \n+  std::map<int, int> GetShardKeyCount();\n+\n   std::unique_ptr<util::ProactorPool> pp_;\n   std::unique_ptr<Service> service_;\n   unsigned num_threads_ = 3;\n",
  "problem_statement": "SINTER on large sets is extremely slow\n**Description**\nSINTER command on large sets is extremely slow compared to Redis.\n\n**To Reproduce**\n\n1. Insert 600M records into SET1 using `SADD`\n2. Insert 4096 records into SET2 using `SADD`\n3. Execute SINTER SET1 SET2\n4. Observe slow query execution\n\n**Expected behavior**\n6-15 ms execution time (tested on Redis and Valkey on the same machine)\n\n**Actual behavior**\n200-600 s execution time.\n\n**Environment**\n - OS: ubuntu 22.04\n - Kernel: 5.15.0-144-generic, x86_64\n - Bare Metal\n - Dragonfly Version: 1.31.1\n\n\n",
  "hints_text": "@Bango-bet \nThanks for reporting the issue. Could you please mention how much memory you used? Did you execute the Dragonfly in epoll or iouring mode?\n> Thanks for reporting the issue. Could you please mention how much memory you used? Did you execute the Dragonfly in epoll or iouring mode?\n\n\nI think the issue is pretty clear. Our set merge algorithm misses an optimization\nYeah... It's an easy one as well. Our algorithm ignores the cardiniality of the input sets and blindly picks the first one and inserts it in the unique set. So if the first set is 600M elements and the second is 4k, we insert 600M elements in a hashtable and do the lookup\nI will patch it when I get a chance\n> [@Bango-bet](https://github.com/Bango-bet) Thanks for reporting the issue. Could you please mention how much memory you used? Did you execute the Dragonfly in epoll or iouring mode?\n\niouring mode, memory consumption is about 37G, memory limit is 240G",
  "created_at": "2025-08-04T14:30:45Z",
  "modified_files": [
    "src/server/set_family.cc"
  ],
  "modified_test_files": [
    "src/server/engine_shard_set_test.cc",
    "src/server/set_family_test.cc",
    "src/server/test_utils.cc",
    "src/server/test_utils.h"
  ]
}