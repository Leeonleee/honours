{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1804,
  "instance_id": "dragonflydb__dragonfly-1804",
  "issue_numbers": [
    "858"
  ],
  "base_commit": "4e393cf742a7a6a985b14f80362c06e71c44be95",
  "patch": "diff --git a/src/core/string_map.cc b/src/core/string_map.cc\nindex 55c7f94e58c7..313bae4ce321 100644\n--- a/src/core/string_map.cc\n+++ b/src/core/string_map.cc\n@@ -101,6 +101,77 @@ sds StringMap::Find(std::string_view key) {\n   return GetValue(str);\n }\n \n+std::pair<sds, sds> StringMap::RandomPair() {\n+  auto it = begin();\n+  it += rand() % Size();\n+  return std::make_pair(it->first, it->second);\n+}\n+\n+void StringMap::RandomPairsUnique(unsigned int count, std::vector<sds>& keys,\n+                                  std::vector<sds>& vals, bool with_value) {\n+  unsigned int total_size = Size();\n+  unsigned int index = 0;\n+  if (count > total_size)\n+    count = total_size;\n+\n+  auto itr = begin();\n+  uint32_t picked = 0, remaining = count;\n+  while (picked < count && itr != end()) {\n+    double random_double = ((double)rand()) / RAND_MAX;\n+    double threshold = ((double)remaining) / (total_size - index);\n+    if (random_double <= threshold) {\n+      keys.push_back(itr->first);\n+      if (with_value) {\n+        vals.push_back(itr->second);\n+      }\n+      remaining--;\n+      picked++;\n+    }\n+    ++itr;\n+    index++;\n+  }\n+\n+  DCHECK(keys.size() == count);\n+  if (with_value)\n+    DCHECK(vals.size() == count);\n+}\n+\n+void StringMap::RandomPairs(unsigned int count, std::vector<sds>& keys, std::vector<sds>& vals,\n+                            bool with_value) {\n+  using RandomPick = std::pair<unsigned int, unsigned int>;\n+  std::vector<RandomPick> picks;\n+  unsigned int total_size = Size();\n+\n+  for (unsigned int i = 0; i < count; ++i) {\n+    RandomPick pick{rand() % total_size, i};\n+    picks.push_back(pick);\n+  }\n+\n+  std::sort(picks.begin(), picks.end(), [](auto& x, auto& y) { return x.first < y.first; });\n+\n+  unsigned int index = picks[0].first, pick_index = 0;\n+  auto itr = begin();\n+  for (unsigned int i = 0; i < index; ++i)\n+    ++itr;\n+\n+  keys.reserve(count);\n+  if (with_value)\n+    vals.reserve(count);\n+\n+  while (itr != end() && pick_index < count) {\n+    auto [key, val] = *itr;\n+    while (pick_index < count && index == picks[pick_index].first) {\n+      int store_order = picks[pick_index].second;\n+      keys[store_order] = key;\n+      if (with_value)\n+        vals[store_order] = val;\n+      ++pick_index;\n+    }\n+    ++index;\n+    ++itr;\n+  }\n+}\n+\n pair<sds, bool> StringMap::ReallocIfNeeded(void* obj, float ratio) {\n   sds key = (sds)obj;\n   size_t key_len = sdslen(key);\ndiff --git a/src/core/string_map.h b/src/core/string_map.h\nindex e31ee511b4c4..62c5a1d63916 100644\n--- a/src/core/string_map.h\n+++ b/src/core/string_map.h\n@@ -81,6 +81,12 @@ class StringMap : public DenseSet {\n       return *this;\n     }\n \n+    iterator& operator+=(unsigned int n) {\n+      for (unsigned int i = 0; i < n; ++i)\n+        Advance();\n+      return *this;\n+    }\n+\n     bool operator==(const iterator& b) const {\n       return curr_list_ == b.curr_list_;\n     }\n@@ -117,6 +123,21 @@ class StringMap : public DenseSet {\n     return iterator{this, true};\n   }\n \n+  // Returns a random key value pair.\n+  // Returns key only if value is a nullptr.\n+  std::pair<sds, sds> RandomPair();\n+\n+  // Randomly selects count of key value pairs. The selections are unique.\n+  // if count is larger than the total number of key value pairs, returns\n+  // every pair.\n+  void RandomPairsUnique(unsigned int count, std::vector<sds>& keys, std::vector<sds>& vals,\n+                         bool with_value);\n+\n+  // Randomly selects count of key value pairs. The select key value pairs\n+  // are allowed to have duplications.\n+  void RandomPairs(unsigned int count, std::vector<sds>& keys, std::vector<sds>& vals,\n+                   bool with_value);\n+\n  private:\n   // Reallocate key and/or value if their pages are underutilized.\n   // Returns new pointer (stays same if key utilization is enough) and if reallocation happened.\ndiff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex d1947865b321..0e6055d00695 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -27,6 +27,7 @@ using namespace std;\n namespace dfly {\n \n using namespace facade;\n+using absl::SimpleAtoi;\n \n namespace {\n \n@@ -1005,8 +1006,35 @@ void HSetFamily::HStrLen(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n+void StrVecEmplaceBack(StringVec& str_vec, const listpackEntry& lp) {\n+  if (lp.sval) {\n+    str_vec.emplace_back(reinterpret_cast<char*>(lp.sval), lp.slen);\n+    return;\n+  }\n+  str_vec.emplace_back(absl::StrCat(lp.lval));\n+}\n+\n void HSetFamily::HRandField(CmdArgList args, ConnectionContext* cntx) {\n+  if (args.size() > 3) {\n+    DVLOG(1) << \"Wrong number of command arguments: \" << args.size();\n+    return (*cntx)->SendError(kSyntaxErr);\n+  }\n+\n   string_view key = ArgS(args, 0);\n+  int32_t count;\n+  bool with_values = false;\n+\n+  if ((args.size() > 1) && (!SimpleAtoi(ArgS(args, 1), &count))) {\n+    return (*cntx)->SendError(\"count value is not an integer\", kSyntaxErrType);\n+  }\n+\n+  if (args.size() == 3) {\n+    ToUpper(&args[2]);\n+    if (ArgS(args, 2) != \"WITHVALUES\")\n+      return (*cntx)->SendError(kSyntaxErr);\n+    else\n+      with_values = true;\n+  }\n \n   auto cb = [&](Transaction* t, EngineShard* shard) -> OpResult<StringVec> {\n     auto& db_slice = shard->db_slice();\n@@ -1020,24 +1048,56 @@ void HSetFamily::HRandField(CmdArgList args, ConnectionContext* cntx) {\n     StringVec str_vec;\n \n     if (pv.Encoding() == kEncodingStrMap2) {\n-      // TODO: to create real random logic.\n       StringMap* string_map = (StringMap*)pv.RObjPtr();\n-\n-      sds key = string_map->begin()->first;\n-      str_vec.emplace_back(key, sdslen(key));\n+      if (args.size() == 1) {\n+        auto [key, value] = string_map->RandomPair();\n+        str_vec.emplace_back(key, sdslen(key));\n+      } else {\n+        size_t actual_count =\n+            (count >= 0) ? std::min(size_t(count), string_map->Size()) : abs(count);\n+        std::vector<sds> keys, vals;\n+        if (count >= 0) {\n+          string_map->RandomPairsUnique(actual_count, keys, vals, with_values);\n+        } else {\n+          string_map->RandomPairs(actual_count, keys, vals, with_values);\n+        }\n+        for (size_t i = 0; i < actual_count; ++i) {\n+          str_vec.emplace_back(keys[i], sdslen(keys[i]));\n+          if (with_values) {\n+            str_vec.emplace_back(vals[i], sdslen(vals[i]));\n+          }\n+        }\n+      }\n     } else if (pv.Encoding() == kEncodingListPack) {\n       uint8_t* lp = (uint8_t*)pv.RObjPtr();\n       size_t lplen = lpLength(lp);\n       CHECK(lplen > 0 && lplen % 2 == 0);\n-\n       size_t hlen = lplen / 2;\n-      listpackEntry key;\n-\n-      lpRandomPair(lp, hlen, &key, NULL);\n-      if (key.sval) {\n-        str_vec.emplace_back(reinterpret_cast<char*>(key.sval), key.slen);\n+      if (args.size() == 1) {\n+        listpackEntry key;\n+        lpRandomPair(lp, hlen, &key, NULL);\n+        StrVecEmplaceBack(str_vec, key);\n       } else {\n-        str_vec.emplace_back(absl::StrCat(key.lval));\n+        size_t actual_count = (count >= 0) ? std::min(size_t(count), hlen) : abs(count);\n+        std::unique_ptr<listpackEntry[]> keys = nullptr, vals = nullptr;\n+        keys = std::make_unique<listpackEntry[]>(actual_count);\n+        if (with_values)\n+          vals = std::make_unique<listpackEntry[]>(actual_count);\n+\n+        // count has been specified.\n+        if (count >= 0)\n+          // always returns unique entries.\n+          lpRandomPairsUnique(lp, actual_count, keys.get(), vals.get());\n+        else\n+          // allows non-unique entries.\n+          lpRandomPairs(lp, actual_count, keys.get(), vals.get());\n+\n+        for (size_t i = 0; i < actual_count; ++i) {\n+          StrVecEmplaceBack(str_vec, keys[i]);\n+          if (with_values) {\n+            StrVecEmplaceBack(str_vec, vals[i]);\n+          }\n+        }\n       }\n     } else {\n       LOG(ERROR) << \"Invalid encoding \" << pv.Encoding();\n@@ -1048,8 +1108,7 @@ void HSetFamily::HRandField(CmdArgList args, ConnectionContext* cntx) {\n \n   OpResult<StringVec> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n   if (result) {\n-    CHECK_EQ(1u, result->size());  // TBD: to support count and withvalues.\n-    (*cntx)->SendBulkString(result->front());\n+    (*cntx)->SendStringArr(*result);\n   } else if (result.status() == OpStatus::KEY_NOTFOUND) {\n     (*cntx)->SendNull();\n   } else {\n@@ -1094,9 +1153,7 @@ void HSetFamily::Register(CommandRegistry* registry) {\n       << CI{\"HINCRBYFLOAT\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1, acl::kHIncrByFloat}\n              .HFUNC(HIncrByFloat)\n       << CI{\"HKEYS\", CO::READONLY, 2, 1, 1, 1, acl::kHKeys}.HFUNC(HKeys)\n-\n-      // TODO: add options support\n-      << CI{\"HRANDFIELD\", CO::READONLY, 2, 1, 1, 1, acl::kHRandField}.HFUNC(HRandField)\n+      << CI{\"HRANDFIELD\", CO::READONLY, -2, 1, 1, 1, acl::kHRandField}.HFUNC(HRandField)\n       << CI{\"HSCAN\", CO::READONLY, -3, 1, 1, 1, acl::kHScan}.HFUNC(HScan)\n       << CI{\"HSET\", CO::WRITE | CO::FAST | CO::DENYOOM, -4, 1, 1, 1, acl::kHSet}.HFUNC(HSet)\n       << CI{\"HSETEX\", CO::WRITE | CO::FAST | CO::DENYOOM, -5, 1, 1, 1, acl::kHSetEx}.SetHandler(\n",
  "test_patch": "diff --git a/src/server/hset_family_test.cc b/src/server/hset_family_test.cc\nindex 7999dcf2cb33..839ec12c58a8 100644\n--- a/src/server/hset_family_test.cc\n+++ b/src/server/hset_family_test.cc\n@@ -203,6 +203,117 @@ TEST_F(HSetFamilyTest, HRandFloat) {\n   Run({\"hrandfield\", \"k\"});\n }\n \n+TEST_F(HSetFamilyTest, HRandField) {\n+  // exercise Redis' listpack encoding\n+  Run({\"HSET\", \"k\", \"a\", \"0\", \"b\", \"1\", \"c\", \"2\"});\n+\n+  EXPECT_THAT(Run({\"hrandfield\", \"k\"}), AnyOf(\"a\", \"b\", \"c\"));\n+\n+  EXPECT_THAT(Run({\"hrandfield\", \"k\", \"2\"}).GetVec(), IsSubsetOf({\"a\", \"b\", \"c\"}));\n+\n+  EXPECT_THAT(Run({\"hrandfield\", \"k\", \"3\"}).GetVec(), UnorderedElementsAre(\"a\", \"b\", \"c\"));\n+\n+  EXPECT_THAT(Run({\"hrandfield\", \"k\", \"4\"}).GetVec(), UnorderedElementsAre(\"a\", \"b\", \"c\"));\n+\n+  auto resp = Run({\"hrandfield\", \"k\", \"4\", \"withvalues\"});\n+  EXPECT_THAT(resp, ArrLen(6));\n+  auto vec = resp.GetVec();\n+\n+  std::vector<RespExpr> k, v;\n+  for (unsigned int i = 0; i < vec.size(); ++i) {\n+    if (i % 2 == 1)\n+      v.push_back(vec[i]);\n+    else\n+      k.push_back(vec[i]);\n+  }\n+\n+  EXPECT_THAT(v, UnorderedElementsAre(\"0\", \"1\", \"2\"));\n+  EXPECT_THAT(k, UnorderedElementsAre(\"a\", \"b\", \"c\"));\n+\n+  resp = Run({\"hrandfield\", \"k\", \"-4\", \"withvalues\"});\n+  EXPECT_THAT(resp, ArrLen(8));\n+  vec = resp.GetVec();\n+  k.clear();\n+  v.clear();\n+  for (unsigned int i = 0; i < vec.size(); ++i) {\n+    if (i % 2 == 0) {\n+      if (vec[i] == \"a\")\n+        EXPECT_EQ(vec[i + 1], \"0\");\n+      else if (vec[i] == \"b\")\n+        EXPECT_EQ(vec[i + 1], \"1\");\n+      else if (vec[i] == \"c\")\n+        EXPECT_EQ(vec[i + 1], \"2\");\n+      else\n+        ADD_FAILURE();\n+    }\n+  }\n+\n+  // exercise Dragonfly's string map encoding\n+  int num_entries = 500;\n+  for (int i = 0; i < num_entries; i++) {\n+    Run({\"HSET\", \"largehash\", std::to_string(i), std::to_string(i * 10)});\n+  }\n+\n+  resp = Run({\"hrandfield\", \"largehash\"});\n+  EXPECT_LE(stoi(resp.GetString()), num_entries - 1);\n+  EXPECT_GE(stoi(resp.GetString()), 0);\n+\n+  resp = Run({\"hrandfield\", \"largehash\", std::to_string(num_entries / 2)});\n+  vec = resp.GetVec();\n+  std::vector<std::string> string_vec;\n+  for (auto v : vec) {\n+    string_vec.push_back(v.GetString());\n+  }\n+\n+  sort(string_vec.begin(), string_vec.end());\n+  auto it = std::unique(string_vec.begin(), string_vec.end());\n+  bool is_unique = (it == string_vec.end());\n+  EXPECT_TRUE(is_unique);\n+\n+  for (const auto& str : string_vec) {\n+    EXPECT_LE(stoi(str), num_entries - 1);\n+    EXPECT_GE(stoi(str), 0);\n+  }\n+\n+  resp = Run({\"hrandfield\", \"largehash\", std::to_string(num_entries * -1 - 1)});\n+  EXPECT_THAT(resp, ArrLen(num_entries + 1));\n+  vec = resp.GetVec();\n+\n+  string_vec.clear();\n+  for (auto v : vec) {\n+    string_vec.push_back(v.GetString());\n+    int i = stoi(v.GetString());\n+    EXPECT_LE(i, num_entries - 1);\n+    EXPECT_GE(i, 0);\n+  }\n+\n+  sort(string_vec.begin(), string_vec.end());\n+  it = std::unique(string_vec.begin(), string_vec.end());\n+  is_unique = (it == string_vec.end());\n+  EXPECT_FALSE(is_unique);\n+\n+  resp = Run({\"hrandfield\", \"largehash\", std::to_string(num_entries * -1 - 1), \"withvalues\"});\n+  EXPECT_THAT(resp, ArrLen((num_entries + 1) * 2));\n+  vec = resp.GetVec();\n+\n+  string_vec.clear();\n+  for (unsigned int i = 0; i < vec.size(); ++i) {\n+    if (i % 2 == 0) {\n+      int k = stoi(vec[i].GetString());\n+      EXPECT_LE(k, num_entries - 1);\n+      EXPECT_GE(k, 0);\n+      int v = stoi(vec[i + 1].GetString());\n+      EXPECT_EQ(v, k * 10);\n+      string_vec.push_back(vec[i].GetString());\n+    }\n+  }\n+\n+  sort(string_vec.begin(), string_vec.end());\n+  it = std::unique(string_vec.begin(), string_vec.end());\n+  is_unique = (it == string_vec.end());\n+  EXPECT_FALSE(is_unique);\n+}\n+\n TEST_F(HSetFamilyTest, HSetEx) {\n   TEST_current_time_ms = kMemberExpiryBase * 1000;  // to reset to test time.\n \n",
  "problem_statement": "Support arguments (count, withvalues) in HRANDFIELD\n\n",
  "hints_text": "",
  "created_at": "2023-09-05T10:13:00Z",
  "modified_files": [
    "src/core/string_map.cc",
    "src/core/string_map.h",
    "src/server/hset_family.cc"
  ],
  "modified_test_files": [
    "src/server/hset_family_test.cc"
  ]
}