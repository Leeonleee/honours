{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 975,
  "instance_id": "dragonflydb__dragonfly-975",
  "issue_numbers": [
    "218"
  ],
  "base_commit": "3a6b98f2013d816cb69e2f2c63b009e88e13a21e",
  "patch": "diff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex 9329ebaf8d62..decbd30e96d0 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -88,6 +88,8 @@ const char* RespExpr::TypeName(Type t) {\n       return \"string\";\n     case INT64:\n       return \"int\";\n+    case DOUBLE:\n+      return \"double\";\n     case ARRAY:\n       return \"array\";\n     case NIL_ARRAY:\n@@ -155,6 +157,9 @@ ostream& operator<<(ostream& os, const facade::RespExpr& e) {\n     case RespExpr::INT64:\n       os << \"i\" << get<int64_t>(e.u);\n       break;\n+    case RespExpr::DOUBLE:\n+      os << \"d\" << get<int64_t>(e.u);\n+      break;\n     case RespExpr::STRING:\n       os << \"'\" << ToSV(get<RespExpr::Buffer>(e.u)) << \"'\";\n       break;\ndiff --git a/src/facade/op_status.h b/src/facade/op_status.h\nindex 3dd70af2d0e1..424dc9a66bea 100644\n--- a/src/facade/op_status.h\n+++ b/src/facade/op_status.h\n@@ -92,6 +92,26 @@ template <> class OpResult<void> : public OpResultBase {\n   using OpResultBase::OpResultBase;\n };\n \n+template <typename V> class OpResultTyped : public OpResult<V> {\n+ public:\n+  OpResultTyped(V v) : OpResult<V>(std::move(v)) {\n+  }\n+\n+  OpResultTyped(OpStatus st = OpStatus::OK) : OpResult<V>(st) {\n+  }\n+\n+  void setType(int type) {\n+    type_ = type;\n+  }\n+\n+  int type() const {\n+    return type_;\n+  }\n+\n+ private:\n+  int type_ = -1;\n+};\n+\n inline bool operator==(OpStatus st, const OpResultBase& ob) {\n   return ob.operator==(st);\n }\ndiff --git a/src/facade/redis_parser.cc b/src/facade/redis_parser.cc\nindex f2cf118ff1fb..4cccce032524 100644\n--- a/src/facade/redis_parser.cc\n+++ b/src/facade/redis_parser.cc\n@@ -40,11 +40,12 @@ auto RedisParser::Parse(Buffer str, uint32_t* consumed, RespExpr::Vec* res) -> R\n   while (state_ != CMD_COMPLETE_S) {\n     last_consumed_ = 0;\n     switch (state_) {\n+      case MAP_LEN_S:\n       case ARRAY_LEN_S:\n         last_result_ = ConsumeArrayLen(str);\n         break;\n       case PARSE_ARG_S:\n-        if (str.size() < 4) {\n+        if (str.size() == 0 || (str.size() < 4 && str[0] != '_')) {\n           last_result_ = INPUT_PENDING;\n         } else {\n           last_result_ = ParseArg(str);\n@@ -99,12 +100,18 @@ void RedisParser::InitStart(uint8_t prefix_b, RespExpr::Vec* res) {\n     case ':':\n     case '+':\n     case '-':\n+    case '_':  // Resp3 NULL\n+    case ',':  // Resp3 DOUBLE\n       state_ = PARSE_ARG_S;\n       parse_stack_.emplace_back(1, cached_expr_);  // expression of length 1.\n       break;\n     case '*':\n+    case '~':  // Resp3 SET\n       state_ = ARRAY_LEN_S;\n       break;\n+    case '%':  // Resp3 MAP\n+      state_ = MAP_LEN_S;\n+      break;\n     default:\n       state_ = INLINE_S;\n       break;\n@@ -231,6 +238,11 @@ auto RedisParser::ConsumeArrayLen(Buffer str) -> Result {\n   int64_t len;\n \n   Result res = ParseNum(str, &len);\n+  if (state_ == MAP_LEN_S) {\n+    // Map starts with %N followed by an array of 2*N elements.\n+    // Even elements are keys, odd elements are values.\n+    len *= 2;\n+  }\n   switch (res) {\n     case INPUT_PENDING:\n       return INPUT_PENDING;\n@@ -284,6 +296,15 @@ auto RedisParser::ConsumeArrayLen(Buffer str) -> Result {\n \n auto RedisParser::ParseArg(Buffer str) -> Result {\n   char c = str[0];\n+\n+  if (c == '_') {  // Resp3 NIL\n+    state_ = FINISH_ARG_S;\n+    cached_expr_->emplace_back(RespExpr::NIL);\n+    cached_expr_->back().u = Buffer{};\n+    last_consumed_ += 3;  // '_','\\r','\\n'\n+    return OK;\n+  }\n+\n   if (c == '$') {\n     int64_t len;\n \n@@ -301,7 +322,7 @@ auto RedisParser::ParseArg(Buffer str) -> Result {\n         LOG(ERROR) << \"Unexpected result \" << res;\n     }\n \n-    if (len < 0) {\n+    if (len < 0) {  // Resp2 NIL\n       state_ = FINISH_ARG_S;\n       cached_expr_->emplace_back(RespExpr::NIL);\n     } else {\n@@ -349,6 +370,19 @@ auto RedisParser::ParseArg(Buffer str) -> Result {\n \n     cached_expr_->emplace_back(RespExpr::INT64);\n     cached_expr_->back().u = ival;\n+  } else if (c == ',') {\n+    DCHECK(!server_mode_);\n+    if (!eol) {\n+      return str.size() < 32 ? INPUT_PENDING : BAD_DOUBLE;\n+    }\n+    double_t dval;\n+    std::string_view tok{s, size_t((eol - s) - 1)};\n+\n+    if (eol[-1] != '\\r' || !absl::SimpleAtod(tok, &dval))\n+      return BAD_INT;\n+\n+    cached_expr_->emplace_back(RespExpr::DOUBLE);\n+    cached_expr_->back().u = dval;\n   } else {\n     return BAD_STRING;\n   }\n@@ -441,4 +475,4 @@ void RedisParser::ExtendLastString(Buffer str) {\n   buf_stash_.back() = std::move(nb);\n }\n \n-}  // namespace dfly\n+}  // namespace facade\ndiff --git a/src/facade/redis_parser.h b/src/facade/redis_parser.h\nindex 7ce32f237650..abf7911ea244 100644\n--- a/src/facade/redis_parser.h\n+++ b/src/facade/redis_parser.h\n@@ -18,7 +18,7 @@ namespace facade {\n  */\n class RedisParser {\n  public:\n-  enum Result { OK, INPUT_PENDING, BAD_ARRAYLEN, BAD_BULKLEN, BAD_STRING, BAD_INT };\n+  enum Result { OK, INPUT_PENDING, BAD_ARRAYLEN, BAD_BULKLEN, BAD_STRING, BAD_INT, BAD_DOUBLE };\n   using Buffer = RespExpr::Buffer;\n \n   explicit RedisParser(bool server_mode = true) : server_mode_(server_mode) {\n@@ -73,6 +73,7 @@ class RedisParser {\n     INIT_S = 0,\n     INLINE_S,\n     ARRAY_LEN_S,\n+    MAP_LEN_S,\n     PARSE_ARG_S,  // Parse [$:+-]string\\r\\n\n     BULK_STR_S,\n     FINISH_ARG_S,\ndiff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex efd91ed6125d..bebe70b6e342 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -169,6 +169,10 @@ char* RedisReplyBuilder::FormatDouble(double val, char* dest, unsigned dest_len)\n RedisReplyBuilder::RedisReplyBuilder(::io::Sink* sink) : SinkReplyBuilder(sink) {\n }\n \n+void RedisReplyBuilder::SetResp3(bool is_resp3) {\n+  is_resp3_ = is_resp3;\n+}\n+\n void RedisReplyBuilder::SendError(string_view str, string_view err_type) {\n   if (err_type.empty()) {\n     err_type = str;\n@@ -201,10 +205,15 @@ void RedisReplyBuilder::SendSetSkipped() {\n   SendNull();\n }\n \n-void RedisReplyBuilder::SendNull() {\n-  constexpr char kNullStr[] = \"$-1\\r\\n\";\n+const char* RedisReplyBuilder::NullString() {\n+  if (is_resp3_) {\n+    return \"_\\r\\n\";\n+  }\n+  return \"$-1\\r\\n\";\n+}\n \n-  iovec v[] = {IoVec(kNullStr)};\n+void RedisReplyBuilder::SendNull() {\n+  iovec v[] = {IoVec(NullString())};\n \n   Send(v, ABSL_ARRAYSIZE(v));\n }\n@@ -265,13 +274,45 @@ void RedisReplyBuilder::SendLong(long num) {\n   SendRaw(str);\n }\n \n+void RedisReplyBuilder::SendScoredArray(const std::vector<std::pair<std::string, double>>& arr,\n+                                        bool with_scores) {\n+  if (!with_scores) {\n+    StartArray(arr.size());\n+    for (const auto& p : arr) {\n+      SendBulkString(p.first);\n+    }\n+    return;\n+  }\n+  if (!is_resp3_) {  // RESP2 formats withscores as a flat array.\n+    StartArray(arr.size() * 2);\n+    for (const auto& p : arr) {\n+      SendBulkString(p.first);\n+      SendDouble(p.second);\n+    }\n+    return;\n+  }\n+  // Resp3 formats withscores as array of (key, score) pairs.\n+  StartArray(arr.size());\n+  for (const auto& p : arr) {\n+    StartArray(2);\n+    SendBulkString(p.first);\n+    SendDouble(p.second);\n+  }\n+}\n+\n void RedisReplyBuilder::SendDouble(double val) {\n   char buf[64];\n \n   StringBuilder sb(buf, sizeof(buf));\n   CHECK(dfly_conv.ToShortest(val, &sb));\n \n-  SendBulkString(sb.Finalize());\n+  if (!is_resp3_) {\n+    SendBulkString(sb.Finalize());\n+  } else {\n+    // RESP3\n+    string str = absl::StrCat(\",\", sb.Finalize(), kCRLF);\n+    SendRaw(str);\n+  }\n }\n \n void RedisReplyBuilder::SendMGetResponse(const OptResp* resp, uint32_t count) {\n@@ -281,7 +322,7 @@ void RedisReplyBuilder::SendMGetResponse(const OptResp* resp, uint32_t count) {\n       StrAppend(&res, \"$\", resp[i]->value.size(), kCRLF);\n       res.append(resp[i]->value).append(kCRLF);\n     } else {\n-      res.append(\"$-1\\r\\n\");\n+      res.append(NullString());\n     }\n   }\n \n@@ -312,7 +353,7 @@ void RedisReplyBuilder::SendStringArr(absl::Span<const std::string_view> arr) {\n     return;\n   }\n \n-  SendStringArr(arr.data(), arr.size());\n+  SendStringCollection(arr.data(), arr.size(), CollectionType::ARRAY);\n }\n \n // This implementation a bit complicated because it uses vectorized\n@@ -321,19 +362,67 @@ void RedisReplyBuilder::SendStringArr(absl::Span<const std::string_view> arr) {\n // We limit the vector length to 256 and when it fills up we flush it to the socket and continue\n // iterating.\n void RedisReplyBuilder::SendStringArr(absl::Span<const string> arr) {\n-  if (arr.empty()) {\n-    SendRaw(\"*0\\r\\n\");\n-    return;\n-  }\n-  SendStringArr(arr.data(), arr.size());\n+  SendStringCollection(arr.data(), arr.size(), CollectionType::ARRAY);\n+}\n+\n+void RedisReplyBuilder::SendStringArrayAsMap(absl::Span<const std::string_view> arr) {\n+  SendStringCollection(arr.data(), arr.size(), CollectionType::MAP);\n+}\n+\n+void RedisReplyBuilder::SendStringArrayAsMap(absl::Span<const std::string> arr) {\n+  SendStringCollection(arr.data(), arr.size(), CollectionType::MAP);\n+}\n+\n+void RedisReplyBuilder::SendStringArrayAsSet(absl::Span<const std::string_view> arr) {\n+  SendStringCollection(arr.data(), arr.size(), CollectionType::SET);\n+}\n+\n+void RedisReplyBuilder::SendStringArrayAsSet(absl::Span<const std::string> arr) {\n+  SendStringCollection(arr.data(), arr.size(), CollectionType::SET);\n }\n \n void RedisReplyBuilder::StartArray(unsigned len) {\n   SendRaw(absl::StrCat(\"*\", len, kCRLF));\n }\n \n-void RedisReplyBuilder::SendStringArr(StrPtr str_ptr, uint32_t len) {\n-  DVLOG(2) << \"Sending array of \" << len << \" strings.\";\n+void RedisReplyBuilder::StartMap(unsigned num_pairs) {\n+  if (is_resp3_) {\n+    SendRaw(absl::StrCat(\"%\", num_pairs, kCRLF));\n+    return;\n+  }\n+  // Flatten for Resp2.\n+  StartArray(num_pairs * 2);\n+}\n+\n+void RedisReplyBuilder::StartSet(unsigned num_elements) {\n+  if (is_resp3_) {\n+    SendRaw(absl::StrCat(\"~\", num_elements, kCRLF));\n+  }\n+  // Flatten for Resp2.\n+  StartArray(num_elements);\n+}\n+\n+void RedisReplyBuilder::SendStringCollection(StrPtr str_ptr, uint32_t len, CollectionType type) {\n+  string type_char = \"*\";\n+  size_t header_len = len;\n+  if (is_resp3_) {\n+    switch (type) {\n+      case CollectionType::ARRAY:\n+        break;\n+      case CollectionType::MAP:\n+        type_char[0] = '%';\n+        header_len = 0.5 * len;  // Each key value pair counts as one.\n+        break;\n+      case CollectionType::SET:\n+        type_char[0] = '~';\n+        break;\n+    }\n+  }\n+\n+  if (header_len == 0) {\n+    SendRaw(absl::StrCat(type_char, \"0\\r\\n\"));\n+    return;\n+  }\n \n   // When vector length is too long, Send returns EMSGSIZE.\n   size_t vec_len = std::min<size_t>(256u, len);\n@@ -342,8 +431,8 @@ void RedisReplyBuilder::SendStringArr(StrPtr str_ptr, uint32_t len) {\n   absl::FixedArray<char, 64> meta((vec_len + 1) * 16);\n   char* next = meta.data();\n \n-  *next++ = '*';\n-  next = absl::numbers_internal::FastIntToBuffer(len, next);\n+  *next++ = type_char[0];\n+  next = absl::numbers_internal::FastIntToBuffer(header_len, next);\n   *next++ = '\\r';\n   *next++ = '\\n';\n   vec[0] = IoVec(string_view{meta.data(), size_t(next - meta.data())});\ndiff --git a/src/facade/reply_builder.h b/src/facade/reply_builder.h\nindex e49541ff2402..d461ccaff5e3 100644\n--- a/src/facade/reply_builder.h\n+++ b/src/facade/reply_builder.h\n@@ -118,6 +118,8 @@ class RedisReplyBuilder : public SinkReplyBuilder {\n  public:\n   RedisReplyBuilder(::io::Sink* stream);\n \n+  void SetResp3(bool is_resp3);\n+\n   void SendError(std::string_view str, std::string_view type = std::string_view{}) override;\n   void SendMGetResponse(const OptResp* resp, uint32_t count) override;\n   void SendSimpleString(std::string_view str) override;\n@@ -135,13 +137,23 @@ class RedisReplyBuilder : public SinkReplyBuilder {\n \n   virtual void SendStringArr(absl::Span<const std::string_view> arr);\n   virtual void SendStringArr(absl::Span<const std::string> arr);\n+  virtual void SendStringArrayAsMap(absl::Span<const std::string_view> arr);\n+  virtual void SendStringArrayAsMap(absl::Span<const std::string> arr);\n+  virtual void SendStringArrayAsSet(absl::Span<const std::string_view> arr);\n+  virtual void SendStringArrayAsSet(absl::Span<const std::string> arr);\n+\n   virtual void SendNull();\n \n+  virtual void SendScoredArray(const std::vector<std::pair<std::string, double>>& arr,\n+                               bool with_scores);\n+\n   virtual void SendDouble(double val);\n \n   virtual void SendBulkString(std::string_view str);\n \n   virtual void StartArray(unsigned len);\n+  virtual void StartMap(unsigned num_pairs);\n+  virtual void StartSet(unsigned num_elements);\n \n   static char* FormatDouble(double val, char* dest, unsigned dest_len);\n \n@@ -150,8 +162,17 @@ class RedisReplyBuilder : public SinkReplyBuilder {\n   static std::string_view StatusToMsg(OpStatus status);\n \n  private:\n+  enum CollectionType {\n+    ARRAY,\n+    SET,\n+    MAP,\n+  };\n+\n   using StrPtr = std::variant<const std::string_view*, const std::string*>;\n-  void SendStringArr(StrPtr str_ptr, uint32_t len);\n+  void SendStringCollection(StrPtr str_ptr, uint32_t len, CollectionType type);\n+\n+  bool is_resp3_ = false;\n+  const char* NullString();\n };\n \n class ReqSerializer {\ndiff --git a/src/facade/resp_expr.h b/src/facade/resp_expr.h\nindex 28d123a2d085..fba007b11e50 100644\n--- a/src/facade/resp_expr.h\n+++ b/src/facade/resp_expr.h\n@@ -16,13 +16,13 @@ class RespExpr {\n  public:\n   using Buffer = absl::Span<uint8_t>;\n \n-  enum Type : uint8_t { STRING, ARRAY, INT64, NIL, NIL_ARRAY, ERROR };\n+  enum Type : uint8_t { STRING, ARRAY, INT64, DOUBLE, NIL, NIL_ARRAY, ERROR };\n \n   using Vec = std::vector<RespExpr>;\n   Type type;\n   bool has_support;  // whether pointers in this item are supported by the external storage.\n \n-  std::variant<int64_t, Buffer, Vec*> u;\n+  std::variant<int64_t, double, Buffer, Vec*> u;\n \n   RespExpr(Type t = NIL) : type(t), has_support(false) {\n   }\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 5bdbd1fa3649..646b1a245e4f 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -929,8 +929,8 @@ template <typename F> bool Iterate(const PrimeValue& pv, F&& func) {\n }\n \n // Create a SortEntryList from given key\n-OpResult<SortEntryList> OpFetchSortEntries(const OpArgs& op_args, std::string_view key,\n-                                           bool alpha) {\n+OpResultTyped<SortEntryList> OpFetchSortEntries(const OpArgs& op_args, std::string_view key,\n+                                                bool alpha) {\n   using namespace container_utils;\n \n   auto [it, _] = op_args.shard->db_slice().FindExt(op_args.db_cntx, key);\n@@ -947,7 +947,9 @@ OpResult<SortEntryList> OpFetchSortEntries(const OpArgs& op_args, std::string_vi\n         });\n       },\n       result);\n-  return success ? OpResult{std::move(result)} : OpStatus::WRONG_TYPE;\n+  auto res = OpResultTyped{std::move(result)};\n+  res.setType(it->second.ObjType());\n+  return success ? res : OpStatus::WRONG_TYPE;\n }\n \n void GenericFamily::Sort(CmdArgList args, ConnectionContext* cntx) {\n@@ -978,18 +980,19 @@ void GenericFamily::Sort(CmdArgList args, ConnectionContext* cntx) {\n     }\n   }\n \n-  OpResult<SortEntryList> entries =\n+  OpResultTyped<SortEntryList> fetch_result =\n       cntx->transaction->ScheduleSingleHopT([&](Transaction* t, EngineShard* shard) {\n         return OpFetchSortEntries(t->GetOpArgs(shard), key, alpha);\n       });\n \n-  if (entries.status() == OpStatus::WRONG_TYPE)\n+  if (fetch_result.status() == OpStatus::WRONG_TYPE)\n     return (*cntx)->SendError(\"One or more scores can't be converted into double\");\n \n-  if (!entries.ok())\n+  if (!fetch_result.ok())\n     return (*cntx)->SendEmptyArray();\n \n-  auto sort_call = [cntx, bounds, reversed](auto& entries) {\n+  auto result_type = fetch_result.type();\n+  auto sort_call = [cntx, bounds, reversed, result_type](auto& entries) {\n     if (bounds) {\n       auto sort_it = entries.begin() + std::min(bounds->first + bounds->second, entries.size());\n       std::partial_sort(entries.begin(), sort_it, entries.end(),\n@@ -1009,12 +1012,17 @@ void GenericFamily::Sort(CmdArgList args, ConnectionContext* cntx) {\n       end_it = entries.begin() + std::min(bounds->first + bounds->second, entries.size());\n     }\n \n-    (*cntx)->StartArray(std::distance(start_it, end_it));\n+    if (result_type == OBJ_SET || result_type == OBJ_ZSET) {\n+      (*cntx)->StartSet(std::distance(start_it, end_it));\n+    } else {\n+      (*cntx)->StartArray(std::distance(start_it, end_it));\n+    }\n+\n     for (auto it = start_it; it != end_it; ++it) {\n       (*cntx)->SendBulkString(it->key);\n     }\n   };\n-  std::visit(std::move(sort_call), entries.value());\n+  std::visit(std::move(sort_call), fetch_result.value());\n }\n \n void GenericFamily::Restore(CmdArgList args, ConnectionContext* cntx) {\ndiff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex a3760ac02da3..29c889a8b650 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -697,7 +697,11 @@ void HGetGeneric(CmdArgList args, ConnectionContext* cntx, uint8_t getall_mask)\n   OpResult<vector<string>> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n \n   if (result) {\n-    (*cntx)->SendStringArr(absl::Span<const string>{*result});\n+    if (getall_mask == (VALUES | FIELDS)) {\n+      (*cntx)->SendStringArrayAsMap(absl::Span<const string>{*result});\n+    } else {\n+      (*cntx)->SendStringArr(absl::Span<const string>{*result});\n+    }\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -945,7 +949,7 @@ void HSetFamily::HScan(CmdArgList args, ConnectionContext* cntx) {\n   if (result.status() != OpStatus::WRONG_TYPE) {\n     (*cntx)->StartArray(2);\n     (*cntx)->SendBulkString(absl::StrCat(cursor));\n-    (*cntx)->StartArray(result->size());\n+    (*cntx)->StartArray(result->size());  // Within scan the page type is array\n     for (const auto& k : *result) {\n       (*cntx)->SendBulkString(k);\n     }\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 30880058cfd6..a04d55962589 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -213,6 +213,10 @@ class InterpreterReplier : public RedisReplyBuilder {\n   void SendSimpleString(std::string_view str) final;\n   void SendMGetResponse(const OptResp* resp, uint32_t count) final;\n   void SendSimpleStrArr(const string_view* arr, uint32_t count) final;\n+  void SendStringArrayAsMap(absl::Span<const std::string_view> arr) final;\n+  void SendStringArrayAsMap(absl::Span<const std::string> arr) final;\n+  void SendStringArrayAsSet(absl::Span<const std::string_view> arr) final;\n+  void SendStringArrayAsSet(absl::Span<const std::string> arr) final;\n   void SendNullArray() final;\n \n   void SendStringArr(absl::Span<const string_view> arr) final;\n@@ -340,6 +344,22 @@ void InterpreterReplier::SendSimpleStrArr(const string_view* arr, uint32_t count\n   explr_->OnArrayEnd();\n }\n \n+void InterpreterReplier::SendStringArrayAsMap(absl::Span<const string_view> arr) {\n+  SendStringArr(arr);\n+}\n+\n+void InterpreterReplier::SendStringArrayAsMap(absl::Span<const string> arr) {\n+  SendStringArr(arr);\n+}\n+\n+void InterpreterReplier::SendStringArrayAsSet(absl::Span<const string_view> arr) {\n+  SendStringArr(arr);\n+}\n+\n+void InterpreterReplier::SendStringArrayAsSet(absl::Span<const string> arr) {\n+  SendStringArr(arr);\n+}\n+\n void InterpreterReplier::SendNullArray() {\n   SendSimpleStrArr(nullptr, 0);\n   PostItem();\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 5c7400d5c3d1..ead35722d6f5 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1318,7 +1318,7 @@ void ServerFamily::Config(CmdArgList args, ConnectionContext* cntx) {\n     string_view param = ArgS(args, 2);\n     string_view res[2] = {param, \"tbd\"};\n \n-    return (*cntx)->SendStringArr(res);\n+    return (*cntx)->SendStringArrayAsMap(res);\n   } else if (sub_cmd == \"RESETSTAT\") {\n     shard_set->pool()->Await([](auto*) {\n       auto* stats = ServerState::tl_connection_stats();\n@@ -1689,21 +1689,29 @@ void ServerFamily::Info(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void ServerFamily::Hello(CmdArgList args, ConnectionContext* cntx) {\n-  // Allow calling this commands with no arguments or protover=2\n-  // technically that is all that is supported at the moment.\n-  // For all other cases degrade to 'unknown command' so that clients\n-  // checking for the existence of the command to detect if RESP3 is\n-  // supported or whether authentication can be performed using HELLO\n-  // will gracefully fallback to RESP2 and using the AUTH command explicitly.\n+  // If no arguments are provided default to RESP2.\n+  // AUTH and SETNAME options are not supported.\n+  bool is_resp3 = false;\n   if (args.size() > 1) {\n     string_view proto_version = ArgS(args, 1);\n-    if (proto_version != \"2\" || args.size() > 2) {\n+    is_resp3 = proto_version == \"3\";\n+    bool valid_proto_version = proto_version == \"2\" || is_resp3;\n+    if (!valid_proto_version || args.size() > 2) {\n       (*cntx)->SendError(UnknownCmd(\"HELLO\", args.subspan(1)));\n       return;\n     }\n   }\n \n-  (*cntx)->StartArray(14);\n+  int proto_version = 2;\n+  if (is_resp3) {\n+    proto_version = 3;\n+    (*cntx)->SetResp3(true);\n+  } else {\n+    // Issuing hello 2 again is valid and should switch back to RESP2\n+    (*cntx)->SetResp3(false);\n+  }\n+\n+  (*cntx)->StartMap(7);\n   (*cntx)->SendBulkString(\"server\");\n   (*cntx)->SendBulkString(\"redis\");\n   (*cntx)->SendBulkString(\"version\");\n@@ -1711,7 +1719,7 @@ void ServerFamily::Hello(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendBulkString(\"dfly_version\");\n   (*cntx)->SendBulkString(GetVersion());\n   (*cntx)->SendBulkString(\"proto\");\n-  (*cntx)->SendLong(2);\n+  (*cntx)->SendLong(proto_version);\n   (*cntx)->SendBulkString(\"id\");\n   (*cntx)->SendLong(cntx->owner()->GetClientId());\n   (*cntx)->SendBulkString(\"mode\");\ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex a497ca68892d..6f874875eb4f 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -1205,7 +1205,7 @@ void SPop(CmdArgList args, ConnectionContext* cntx) {\n         (*cntx)->SendBulkString(result.value().front());\n       }\n     } else {  // SPOP key cnt\n-      (*cntx)->SendStringArr(*result);\n+      (*cntx)->SendStringArrayAsSet(*result);\n     }\n     return;\n   }\n@@ -1241,7 +1241,7 @@ void SDiff(CmdArgList args, ConnectionContext* cntx) {\n   if (cntx->conn_state.script_info) {  // sort under script\n     sort(arr.begin(), arr.end());\n   }\n-  (*cntx)->SendStringArr(arr);\n+  (*cntx)->SendStringArrayAsSet(arr);\n }\n \n void SDiffStore(CmdArgList args, ConnectionContext* cntx) {\n@@ -1309,7 +1309,7 @@ void SMembers(CmdArgList args, ConnectionContext* cntx) {\n     if (cntx->conn_state.script_info) {  // sort under script\n       sort(svec.begin(), svec.end());\n     }\n-    (*cntx)->SendStringArr(*result);\n+    (*cntx)->SendStringArrayAsSet(*result);\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -1331,7 +1331,7 @@ void SInter(CmdArgList args, ConnectionContext* cntx) {\n     if (cntx->conn_state.script_info) {  // sort under script\n       sort(arr.begin(), arr.end());\n     }\n-    (*cntx)->SendStringArr(arr);\n+    (*cntx)->SendStringArrayAsSet(arr);\n   } else {\n     (*cntx)->SendError(result.status());\n   }\n@@ -1394,7 +1394,7 @@ void SUnion(CmdArgList args, ConnectionContext* cntx) {\n     if (cntx->conn_state.script_info) {  // sort under script\n       sort(arr.begin(), arr.end());\n     }\n-    (*cntx)->SendStringArr(arr);\n+    (*cntx)->SendStringArrayAsSet(arr);\n   } else {\n     (*cntx)->SendError(unionset.status());\n   }\n@@ -1473,7 +1473,7 @@ void SScan(CmdArgList args, ConnectionContext* cntx) {\n   if (result.status() != OpStatus::WRONG_TYPE) {\n     (*cntx)->StartArray(2);\n     (*cntx)->SendBulkString(absl::StrCat(cursor));\n-    (*cntx)->StartArray(result->size());\n+    (*cntx)->StartArray(result->size());  // Within scan the return page is of type array\n     for (const auto& k : *result) {\n       (*cntx)->SendBulkString(k);\n     }\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 4202e78c0ce8..8facf5d176bb 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -734,7 +734,7 @@ void StreamFamily::XInfo(CmdArgList args, ConnectionContext* cntx) {\n           string_view arr[8] = {\"name\",    ginfo.name,  \"consumers\",         an1.Piece(),\n                                 \"pending\", an2.Piece(), \"last-delivered-id\", last_id};\n \n-          (*cntx)->SendStringArr(absl::Span<string_view>{arr, 8});\n+          (*cntx)->SendStringArrayAsMap(absl::Span<string_view>{arr, 8});\n         }\n         return;\n       }\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 0cf891bb3691..c4a7f2ee8e30 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -1578,7 +1578,7 @@ void ZSetFamily::ZMScore(CmdArgList args, ConnectionContext* cntx) {\n     return (*cntx)->SendError(kWrongTypeErr);\n   }\n \n-  (*cntx)->StartArray(result->size());\n+  (*cntx)->StartArray(result->size());  // Array return type.\n   const MScoreResponse& array = result.value();\n   for (const auto& p : array) {\n     if (p) {\n@@ -1614,7 +1614,7 @@ void ZSetFamily::ZScan(CmdArgList args, ConnectionContext* cntx) {\n   if (result.status() != OpStatus::WRONG_TYPE) {\n     (*cntx)->StartArray(2);\n     (*cntx)->SendBulkString(absl::StrCat(cursor));\n-    (*cntx)->StartArray(result->size());\n+    (*cntx)->StartArray(result->size());  // Within scan the returned page is of type array.\n     for (const auto& k : *result) {\n       (*cntx)->SendBulkString(k);\n     }\n@@ -1649,16 +1649,7 @@ void ZSetFamily::OutputScoredArrayResult(const OpResult<ScoredArray>& result,\n \n   LOG_IF(WARNING, !result && result.status() != OpStatus::KEY_NOTFOUND)\n       << \"Unexpected status \" << result.status();\n-\n-  (*cntx)->StartArray(result->size() * (params.with_scores ? 2 : 1));\n-  const ScoredArray& array = result.value();\n-  for (const auto& p : array) {\n-    (*cntx)->SendBulkString(p.first);\n-\n-    if (params.with_scores) {\n-      (*cntx)->SendDouble(p.second);\n-    }\n-  }\n+  (*cntx)->SendScoredArray(result.value(), params.with_scores);\n }\n \n void ZSetFamily::ZRemRangeGeneric(string_view key, const ZRangeSpec& range_spec,\n",
  "test_patch": "diff --git a/src/facade/facade_test.cc b/src/facade/facade_test.cc\nindex 78e7c325d152..48a286c4faad 100644\n--- a/src/facade/facade_test.cc\n+++ b/src/facade/facade_test.cc\n@@ -35,6 +35,12 @@ bool RespMatcher::MatchAndExplain(const RespExpr& e, MatchResultListener* listen\n       *listener << \"\\nActual : \" << actual << \" expected: \" << exp_int_;\n       return false;\n     }\n+  } else if (type_ == RespExpr::DOUBLE) {\n+    auto actual = get<double>(e.u);\n+    if (exp_double_ != actual) {\n+      *listener << \"\\nActual : \" << actual << \" expected: \" << exp_double_;\n+      return false;\n+    }\n   } else if (type_ == RespExpr::ARRAY) {\n     size_t len = get<RespVec*>(e.u)->size();\n     if (len != size_t(exp_int_)) {\ndiff --git a/src/facade/facade_test.h b/src/facade/facade_test.h\nindex c0b5add9d569..929c25079335 100644\n--- a/src/facade/facade_test.h\n+++ b/src/facade/facade_test.h\n@@ -18,6 +18,8 @@ class RespMatcher {\n   RespMatcher(int64_t val, RespExpr::Type t = RespExpr::INT64) : type_(t), exp_int_(val) {\n   }\n \n+  RespMatcher(double_t val, RespExpr::Type t = RespExpr::DOUBLE) : type_(t), exp_double_(val) {\n+  }\n   using is_gtest_matcher = void;\n \n   bool MatchAndExplain(const RespExpr& e, testing::MatchResultListener*) const;\n@@ -31,6 +33,7 @@ class RespMatcher {\n \n   std::string exp_str_;\n   int64_t exp_int_;\n+  double_t exp_double_;\n };\n \n class RespTypeMatcher {\n@@ -58,8 +61,12 @@ inline ::testing::PolymorphicMatcher<RespMatcher> IntArg(int64_t ival) {\n   return ::testing::MakePolymorphicMatcher(RespMatcher(ival));\n }\n \n+inline ::testing::PolymorphicMatcher<RespMatcher> DoubleArg(double_t dval) {\n+  return ::testing::MakePolymorphicMatcher(RespMatcher(dval));\n+}\n+\n inline ::testing::PolymorphicMatcher<RespMatcher> ArrLen(size_t len) {\n-  return ::testing::MakePolymorphicMatcher(RespMatcher(len, RespExpr::ARRAY));\n+  return ::testing::MakePolymorphicMatcher(RespMatcher((int64_t)len, RespExpr::ARRAY));\n }\n \n inline ::testing::PolymorphicMatcher<RespTypeMatcher> ArgType(RespExpr::Type t) {\ndiff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc\nindex 1f9f74dc448b..58b42d409770 100644\n--- a/src/facade/reply_builder_test.cc\n+++ b/src/facade/reply_builder_test.cc\n@@ -656,4 +656,100 @@ TEST_F(RedisReplyBuilderTest, TestBatchMode) {\n                           absl::StrCat(kBulkStringStart, \"0\"), std::string_view{}));\n }\n \n+TEST_F(RedisReplyBuilderTest, TestResp3Double) {\n+  builder_->SetResp3(true);\n+  builder_->SendDouble(5.5);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(str(), \",5.5\\r\\n\");\n+}\n+\n+TEST_F(RedisReplyBuilderTest, TestResp3NullString) {\n+  builder_->SetResp3(true);\n+  builder_->SendNull();\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"_\\r\\n\");\n+}\n+\n+TEST_F(RedisReplyBuilderTest, TestSendStringArrayAsMap) {\n+  const std::vector<std::string> map_array{\"k1\", \"v1\", \"k2\", \"v2\"};\n+\n+  builder_->SetResp3(false);\n+  builder_->SendStringArrayAsMap(map_array);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"*4\\r\\n$2\\r\\nk1\\r\\n$2\\r\\nv1\\r\\n$2\\r\\nk2\\r\\n$2\\r\\nv2\\r\\n\")\n+      << \"SendStringArrayAsMap Resp2 Failed.\";\n+\n+  builder_->SetResp3(true);\n+  builder_->SendStringArrayAsMap(map_array);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"%2\\r\\n$2\\r\\nk1\\r\\n$2\\r\\nv1\\r\\n$2\\r\\nk2\\r\\n$2\\r\\nv2\\r\\n\")\n+      << \"SendStringArrayAsMap Resp3 Failed.\";\n+}\n+\n+TEST_F(RedisReplyBuilderTest, TestSendStringArrayAsSet) {\n+  const std::vector<std::string> set_array{\"e1\", \"e2\", \"e3\"};\n+\n+  builder_->SetResp3(false);\n+  builder_->SendStringArrayAsSet(set_array);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"*3\\r\\n$2\\r\\ne1\\r\\n$2\\r\\ne2\\r\\n$2\\r\\ne3\\r\\n\")\n+      << \"SendStringArrayAsSet Resp2 Failed.\";\n+\n+  builder_->SetResp3(true);\n+  builder_->SendStringArrayAsSet(set_array);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"~3\\r\\n$2\\r\\ne1\\r\\n$2\\r\\ne2\\r\\n$2\\r\\ne3\\r\\n\")\n+      << \"SendStringArrayAsSet Resp3 Failed.\";\n+}\n+\n+TEST_F(RedisReplyBuilderTest, TestSendScoredArray) {\n+  const std::vector<std::pair<std::string, double>> scored_array{\n+      {\"e1\", 1.1}, {\"e2\", 2.2}, {\"e3\", 3.3}};\n+\n+  builder_->SetResp3(false);\n+  builder_->SendScoredArray(scored_array, false);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"*3\\r\\n$2\\r\\ne1\\r\\n$2\\r\\ne2\\r\\n$2\\r\\ne3\\r\\n\")\n+      << \"Resp2 WITHOUT scores failed.\";\n+\n+  builder_->SetResp3(true);\n+  builder_->SendScoredArray(scored_array, false);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"*3\\r\\n$2\\r\\ne1\\r\\n$2\\r\\ne2\\r\\n$2\\r\\ne3\\r\\n\")\n+      << \"Resp3 WITHOUT scores failed.\";\n+\n+  builder_->SetResp3(false);\n+  builder_->SendScoredArray(scored_array, true);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(),\n+            \"*6\\r\\n$2\\r\\ne1\\r\\n$3\\r\\n1.1\\r\\n$2\\r\\ne2\\r\\n$3\\r\\n2.2\\r\\n$2\\r\\ne3\\r\\n$3\\r\\n3.3\\r\\n\")\n+      << \"Resp3 WITHSCORES failed.\";\n+\n+  builder_->SetResp3(true);\n+  builder_->SendScoredArray(scored_array, true);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(),\n+            \"*3\\r\\n*2\\r\\n$2\\r\\ne1\\r\\n,1.1\\r\\n*2\\r\\n$2\\r\\ne2\\r\\n,2.2\\r\\n*2\\r\\n$2\\r\\ne3\\r\\n,3.3\\r\\n\")\n+      << \"Resp3 WITHSCORES failed.\";\n+}\n+\n+TEST_F(RedisReplyBuilderTest, TestSendMGetResponse) {\n+  std::vector<SinkReplyBuilder::OptResp> mget_res(3);\n+  auto& v = mget_res[0].emplace();\n+  v.value = \"v1\";\n+  v = mget_res[2].emplace();\n+  v.value = \"v3\";\n+\n+  builder_->SetResp3(false);\n+  builder_->SendMGetResponse(&mget_res[0], 3);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"*3\\r\\n$2\\r\\nv3\\r\\n$-1\\r\\n$0\\r\\n\\r\\n\")\n+      << \"Resp2 SendMGetResponse failed.\";\n+\n+  builder_->SetResp3(true);\n+  builder_->SendMGetResponse(&mget_res[0], 3);\n+  ASSERT_TRUE(builder_->err_count().empty());\n+  ASSERT_EQ(TakePayload(), \"*3\\r\\n$2\\r\\nv3\\r\\n_\\r\\n$0\\r\\n\\r\\n\") << \"Resp3 SendMGetResponse failed.\";\n+}\n+\n }  // namespace facade\ndiff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc\nindex 6b027083d0bb..32a115ff3bce 100644\n--- a/src/server/dragonfly_test.cc\n+++ b/src/server/dragonfly_test.cc\n@@ -228,10 +228,15 @@ TEST_F(DflyEngineTest, Hello) {\n                           ArgType(RespExpr::STRING), \"proto\", IntArg(2), \"id\",\n                           ArgType(RespExpr::INT64), \"mode\", \"standalone\", \"role\", \"master\"));\n \n+  resp = Run({\"hello\", \"3\"});\n+  ASSERT_THAT(resp, ArrLen(14));\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"server\", \"redis\", \"version\", \"6.2.11\", \"dfly_version\",\n+                          ArgType(RespExpr::STRING), \"proto\", IntArg(3), \"id\",\n+                          ArgType(RespExpr::INT64), \"mode\", \"standalone\", \"role\", \"master\"));\n+\n   // These are valid arguments to HELLO, however as they are not yet supported the implementation\n   // is degraded to 'unknown command'.\n-  EXPECT_THAT(Run({\"hello\", \"3\"}),\n-              ErrArg(\"ERR unknown command 'HELLO' with args beginning with: `3`\"));\n   EXPECT_THAT(\n       Run({\"hello\", \"2\", \"AUTH\", \"uname\", \"pwd\"}),\n       ErrArg(\"ERR unknown command 'HELLO' with args beginning with: `2`, `AUTH`, `uname`, `pwd`\"));\ndiff --git a/src/server/hset_family_test.cc b/src/server/hset_family_test.cc\nindex 80d0980cac50..e281e58e5306 100644\n--- a/src/server/hset_family_test.cc\n+++ b/src/server/hset_family_test.cc\n@@ -27,6 +27,14 @@ class HSetFamilyTest : public BaseFamilyTest {\n  protected:\n };\n \n+class HestFamilyTestProtocolVersioned : public HSetFamilyTest,\n+                                        public ::testing::WithParamInterface<string> {\n+ protected:\n+};\n+\n+INSTANTIATE_TEST_CASE_P(HestFamilyTestProtocolVersioned, HestFamilyTestProtocolVersioned,\n+                        ::testing::Values(\"2\", \"3\"));\n+\n TEST_F(HSetFamilyTest, Hash) {\n   robj* obj = createHashObject();\n   sds field = sdsnew(\"field\");\n@@ -70,8 +78,12 @@ TEST_F(HSetFamilyTest, HSet) {\n   EXPECT_EQ(1, CheckedInt({\"hset\", \"small\", \"\", \"565323349817\"}));\n }\n \n-TEST_F(HSetFamilyTest, Get) {\n-  auto resp = Run({\"hset\", \"x\", \"a\", \"1\", \"b\", \"2\", \"c\", \"3\"});\n+TEST_P(HestFamilyTestProtocolVersioned, Get) {\n+  auto resp = Run({\"hello\", GetParam()});\n+  EXPECT_THAT(resp.GetVec()[6], \"proto\");\n+  EXPECT_THAT(resp.GetVec()[7], IntArg(atoi(GetParam().c_str())));\n+\n+  resp = Run({\"hset\", \"x\", \"a\", \"1\", \"b\", \"2\", \"c\", \"3\"});\n   EXPECT_THAT(resp, IntArg(3));\n \n   resp = Run({\"hmget\", \"unkwn\", \"a\", \"c\"});\ndiff --git a/src/server/string_family_test.cc b/src/server/string_family_test.cc\nindex d38e4e837997..e61df22ad7f0 100644\n--- a/src/server/string_family_test.cc\n+++ b/src/server/string_family_test.cc\n@@ -663,4 +663,14 @@ TEST_F(StringFamilyTest, ClThrottle) {\n   EXPECT_THAT(resp, ErrArg(kInvalidIntErr));\n }\n \n+TEST_F(StringFamilyTest, SetMGetWithNilResp3) {\n+  Run({\"hello\", \"3\"});\n+\n+  EXPECT_EQ(Run({\"set\", \"key\", \"val\"}), \"OK\");\n+  EXPECT_EQ(Run({\"get\", \"key\"}), \"val\");\n+  RespExpr resp = Run({\"mget\", \"key\", \"nonexist\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"val\", ArgType(RespExpr::NIL)));\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 06dbb0fa760c..da6fa0abbdc5 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -477,4 +477,14 @@ TEST_F(ZSetFamilyTest, ZPopMax) {\n   resp = Run({\"zpopmax\", \"key\", \"1\"});\n   ASSERT_THAT(resp, ArrLen(0));\n }\n+\n+TEST_F(ZSetFamilyTest, Resp3) {\n+  Run({\"hello\", \"3\"});\n+  Run({\"zadd\", \"x\", \"1\", \"a\", \"2\", \"b\"});\n+  auto resp = Run({\"zrange\", \"x\", \"0\", \"-1\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  ASSERT_THAT(resp.GetVec()[0].GetVec(), ElementsAre(\"a\", DoubleArg(1)));\n+  ASSERT_THAT(resp.GetVec()[1].GetVec(), ElementsAre(\"b\", DoubleArg(2)));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Support RESP3 protocol\nRESP3 is an enhancement of RESP2. Specifically, it encodes response types as part of the protocol. It's much easier to build client libraries with RESP3 because a client library does not need to know the semantics of the command in order to parse them. \r\n\r\nRelates to #129 #180 and #102\n",
  "hints_text": "Also \"CLIENT TRACKING\" support is missing from: https://github.com/dragonflydb/dragonfly/blob/main/docs/api_status.md\r\n\r\nhttps://redis.io/commands/client-tracking/\r\n\r\nhttps://redis.io/docs/manual/client-side-caching/\nSidekiq >= 7 uses a RESP3 redis client by default:\r\nhttps://github.com/sidekiq/sidekiq/blob/4c101d243e9589cd3d1a81060dac602beb1652a1/docs/7.0-Upgrade.md#redis-client",
  "created_at": "2023-03-21T16:24:04Z",
  "modified_files": [
    "src/facade/facade.cc",
    "src/facade/op_status.h",
    "src/facade/redis_parser.cc",
    "src/facade/redis_parser.h",
    "src/facade/reply_builder.cc",
    "src/facade/reply_builder.h",
    "src/facade/resp_expr.h",
    "src/server/generic_family.cc",
    "src/server/hset_family.cc",
    "src/server/main_service.cc",
    "src/server/server_family.cc",
    "src/server/set_family.cc",
    "src/server/stream_family.cc",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/facade/facade_test.cc",
    "src/facade/facade_test.h",
    "src/facade/reply_builder_test.cc",
    "src/server/dragonfly_test.cc",
    "src/server/hset_family_test.cc",
    "src/server/string_family_test.cc",
    "src/server/zset_family_test.cc"
  ]
}