{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1583,
  "instance_id": "dragonflydb__dragonfly-1583",
  "issue_numbers": [
    "1381"
  ],
  "base_commit": "12c893085c0d112db101b48cc39c344f4a306ab9",
  "patch": "diff --git a/src/server/replica.cc b/src/server/replica.cc\nindex 348251830cf2..a19e6af9786e 100644\n--- a/src/server/replica.cc\n+++ b/src/server/replica.cc\n@@ -117,6 +117,15 @@ error_code Replica::Start(ConnectionContext* cntx) {\n   return {};\n }  // namespace dfly\n \n+void Replica::EnableReplication(ConnectionContext* cntx) {\n+  VLOG(1) << \"Enabling replication\";\n+\n+  state_mask_.store(R_ENABLED);                             // set replica state to enabled\n+  sync_fb_ = MakeFiber(&Replica::MainReplicationFb, this);  // call replication fiber\n+\n+  (*cntx)->SendOk();\n+}\n+\n void Replica::Stop() {\n   VLOG(1) << \"Stopping replication\";\n   // Stops the loop in MainReplicationFb.\n@@ -1007,9 +1016,7 @@ error_code Replica::ParseReplicationHeader(base::IoBuf* io_buf, PSyncResponse* d\n }\n \n Replica::Info Replica::GetInfo() const {\n-  CHECK(Sock());\n-\n-  return Proactor()->AwaitBrief([this] {\n+  auto f = [this]() {\n     auto last_io_time = LastIoTime();\n     for (const auto& flow : shard_flows_) {  // Get last io time from all sub flows.\n       last_io_time = std::max(last_io_time, flow->LastIoTime());\n@@ -1023,7 +1030,22 @@ Replica::Info Replica::GetInfo() const {\n     res.full_sync_done = (state_mask_.load() & R_SYNC_OK);\n     res.master_last_io_sec = (ProactorBase::GetMonotonicTimeNs() - last_io_time) / 1000000000UL;\n     return res;\n-  });\n+  };\n+\n+  if (Sock())\n+    return Proactor()->AwaitBrief(f);\n+  else {\n+    /**\n+     * when this branch happens: there is a very short grace period\n+     * where Sock() is not initialized, yet the server can\n+     * receive ROLE/INFO commands. That period happens when launching\n+     * an instance with '--replicaof' and then immediately\n+     * sending a command.\n+     *\n+     * In that instance, we have to run f() on the current fiber.\n+     */\n+    return f();\n+  }\n }\n \n std::vector<uint64_t> Replica::GetReplicaOffset() const {\ndiff --git a/src/server/replica.h b/src/server/replica.h\nindex 4ef14fb04dbb..569260e3733b 100644\n--- a/src/server/replica.h\n+++ b/src/server/replica.h\n@@ -77,6 +77,11 @@ class Replica : ProtocolClient {\n   // false if it has failed.\n   std::error_code Start(ConnectionContext* cntx);\n \n+  // Sets the server state to have replication enabled.\n+  // It is like Start(), but does not attempt to establish\n+  // a connection right-away, but instead lets MainReplicationFb do the work.\n+  void EnableReplication(ConnectionContext* cntx);\n+\n   void Stop();  // thread-safe\n \n   void Pause(bool pause);\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex aa5f8c6f9ae1..13e1713e2f8a 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -25,6 +25,7 @@ extern \"C\" {\n #include \"base/logging.h\"\n #include \"croncpp.h\"  // cron::cronexpr\n #include \"facade/dragonfly_connection.h\"\n+#include \"facade/reply_builder.h\"\n #include \"io/file_util.h\"\n #include \"io/proc_reader.h\"\n #include \"server/command_registry.h\"\n@@ -54,6 +55,18 @@ extern \"C\" {\n \n using namespace std;\n \n+struct ReplicaOfFlag {\n+  string host;\n+  string port;\n+\n+  bool has_value() const {\n+    return !host.empty() && !port.empty();\n+  }\n+};\n+\n+static bool AbslParseFlag(std::string_view in, ReplicaOfFlag* flag, std::string* err);\n+static std::string AbslUnparseFlag(const ReplicaOfFlag& flag);\n+\n ABSL_FLAG(string, dir, \"\", \"working directory\");\n ABSL_FLAG(string, dbfilename, \"dump-{timestamp}\", \"the filename to save/load the DB\");\n ABSL_FLAG(string, requirepass, \"\",\n@@ -68,6 +81,10 @@ ABSL_FLAG(bool, df_snapshot_format, true,\n ABSL_FLAG(int, epoll_file_threads, 0,\n           \"thread size for file workers when running in epoll mode, default is hardware concurrent \"\n           \"threads\");\n+ABSL_FLAG(ReplicaOfFlag, replicaof, ReplicaOfFlag{},\n+          \"Specifies a host and port which point to a target master \"\n+          \"to replicate. \"\n+          \"Format should be <IPv4>:<PORT> or host:<PORT> or [<IPv6>]:<PORT>\");\n \n ABSL_DECLARE_FLAG(uint32_t, port);\n ABSL_DECLARE_FLAG(bool, cache_mode);\n@@ -76,6 +93,54 @@ ABSL_DECLARE_FLAG(bool, tls);\n ABSL_DECLARE_FLAG(string, tls_ca_cert_file);\n ABSL_DECLARE_FLAG(string, tls_ca_cert_dir);\n \n+bool AbslParseFlag(std::string_view in, ReplicaOfFlag* flag, std::string* err) {\n+#define RETURN_ON_ERROR(cond, m)                                           \\\n+  do {                                                                     \\\n+    if ((cond)) {                                                          \\\n+      *err = m;                                                            \\\n+      LOG(WARNING) << \"Error in parsing arguments for --replicaof: \" << m; \\\n+      return false;                                                        \\\n+    }                                                                      \\\n+  } while (0)\n+\n+  if (in.empty()) {  // on empty flag \"parse\" nothing. If we return false then DF exists.\n+    *flag = ReplicaOfFlag{};\n+    return true;\n+  }\n+\n+  auto pos = in.find_last_of(':');\n+  RETURN_ON_ERROR(pos == string::npos, \"missing ':'.\");\n+\n+  string_view ip = in.substr(0, pos);\n+  flag->port = in.substr(pos + 1);\n+\n+  RETURN_ON_ERROR(ip.empty() || flag->port.empty(), \"IP/host or port are empty.\");\n+\n+  // For IPv6: ip1.front == '[' AND ip1.back == ']'\n+  // For IPv4: ip1.front != '[' AND ip1.back != ']'\n+  // Together, this ip1.front == '[' iff ip1.back == ']', which can be implemented as XNOR (NOT XOR)\n+  RETURN_ON_ERROR(((ip.front() == '[') ^ (ip.back() == ']')), \"unclosed brackets.\");\n+\n+  if (ip.front() == '[') {\n+    // shortest possible IPv6 is '::1' (loopback)\n+    RETURN_ON_ERROR(ip.length() <= 2, \"IPv6 host name is too short\");\n+\n+    flag->host = ip.substr(1, ip.length() - 2);\n+    VLOG(1) << \"received IP of type IPv6: \" << flag->host;\n+  } else {\n+    flag->host = ip;\n+    VLOG(1) << \"received IP of type IPv4 (or a host): \" << flag->host;\n+  }\n+\n+  VLOG(1) << \"--replicaof: Received \" << flag->host << \" :  \" << flag->port;\n+  return true;\n+#undef RETURN_ON_ERROR\n+}\n+\n+std::string AbslUnparseFlag(const ReplicaOfFlag& flag) {\n+  return (flag.has_value()) ? absl::StrCat(flag.host, \":\", flag.port) : \"\";\n+}\n+\n namespace dfly {\n \n namespace fs = std::filesystem;\n@@ -452,6 +517,10 @@ void ValidateServerTlsFlags() {\n   }\n }\n \n+bool IsReplicatingNoOne(string_view host, string_view port) {\n+  return absl::EqualsIgnoreCase(host, \"no\") && absl::EqualsIgnoreCase(port, \"one\");\n+}\n+\n }  // namespace\n \n std::optional<SnapshotSpec> ParseSaveSchedule(string_view time) {\n@@ -593,6 +662,13 @@ void ServerFamily::Init(util::AcceptServer* acceptor, std::vector<facade::Listen\n   stats_caching_task_ =\n       pb_task_->AwaitBrief([&] { return pb_task_->AddPeriodic(period_ms, cache_cb); });\n \n+  // check for '--replicaof' before loading anything\n+  if (ReplicaOfFlag flag = GetFlag(FLAGS_replicaof); flag.has_value()) {\n+    service_.proactor_pool().GetNextProactor()->Await(\n+        [this, &flag]() { this->Replicate(flag.host, flag.port); });\n+    return;  // DONT load any snapshots\n+  }\n+\n   string flag_dir = GetFlag(FLAGS_dir);\n   if (IsCloudPath(flag_dir)) {\n     aws_ = make_unique<cloud::AWS>(\"s3\");\n@@ -1973,12 +2049,10 @@ void ServerFamily::Hello(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendBulkString((*ServerState::tlocal()).is_master ? \"master\" : \"slave\");\n }\n \n-void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {\n-  std::string_view host = ArgS(args, 0);\n-  std::string_view port_s = ArgS(args, 1);\n+void ServerFamily::ReplicaOfInternal(string_view host, string_view port_sv, ConnectionContext* cntx,\n+                                     ActionOnConnectionFail on_err) {\n   auto& pool = service_.proactor_pool();\n-\n-  LOG(INFO) << \"Replicating \" << host << \":\" << port_s;\n+  LOG(INFO) << \"Replicating \" << host << \":\" << port_sv;\n \n   // We lock to protect global state changes that we perform during the replication setup:\n   // The replica_ pointer, GlobalState, and the DB itself (we do a flushall txn before syncing).\n@@ -1993,7 +2067,7 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {\n   VLOG(1) << \"Acquire replica lock\";\n   unique_lock lk(replicaof_mu_);\n \n-  if (absl::EqualsIgnoreCase(host, \"no\") && absl::EqualsIgnoreCase(port_s, \"one\")) {\n+  if (IsReplicatingNoOne(host, port_sv)) {\n     if (!ServerState::tlocal()->is_master) {\n       auto repl_ptr = replica_;\n       CHECK(repl_ptr);\n@@ -2004,12 +2078,15 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {\n       replica_.reset();\n     }\n \n+    CHECK(service_.SwitchState(GlobalState::LOADING, GlobalState::ACTIVE) == GlobalState::ACTIVE)\n+        << \"Server is set to replica no one, yet state is not active!\";\n+\n     return (*cntx)->SendOk();\n   }\n \n   uint32_t port;\n \n-  if (!absl::SimpleAtoi(port_s, &port) || port < 1 || port > 65535) {\n+  if (!absl::SimpleAtoi(port_sv, &port) || port < 1 || port > 65535) {\n     (*cntx)->SendError(kInvalidIntErr);\n     return;\n   }\n@@ -2031,20 +2108,20 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {\n     return;\n   }\n \n-  // Flushing all the data after we marked this instance as replica.\n-  Transaction* transaction = cntx->transaction;\n-  transaction->Schedule();\n-\n-  auto cb = [](Transaction* t, EngineShard* shard) {\n-    shard->db_slice().FlushDb(DbSlice::kDbAll);\n-    return OpStatus::OK;\n-  };\n-  transaction->Execute(std::move(cb), true);\n-\n   // Replica sends response in either case. No need to send response in this function.\n   // It's a bit confusing but simpler.\n   lk.unlock();\n-  error_code ec = new_replica->Start(cntx);\n+  error_code ec{};\n+\n+  switch (on_err) {\n+    case ActionOnConnectionFail::kReturnOnError:\n+      ec = new_replica->Start(cntx);\n+      break;\n+    case ActionOnConnectionFail::kContinueReplication:  // set DF to replicate, and forget about it\n+      new_replica->EnableReplication(cntx);\n+      break;\n+  };\n+\n   VLOG(1) << \"Acquire replica lock\";\n   lk.lock();\n \n@@ -2064,6 +2141,27 @@ void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {\n   }\n }\n \n+void ServerFamily::ReplicaOf(CmdArgList args, ConnectionContext* cntx) {\n+  string_view host = ArgS(args, 0);\n+  string_view port = ArgS(args, 1);\n+\n+  // don't flush if input is NO ONE\n+  if (!IsReplicatingNoOne(host, port))\n+    Drakarys(cntx->transaction, DbSlice::kDbAll);\n+\n+  ReplicaOfInternal(host, port, cntx, ActionOnConnectionFail::kReturnOnError);\n+}\n+\n+void ServerFamily::Replicate(string_view host, string_view port) {\n+  io::NullSink sink;\n+  ConnectionContext ctxt{&sink, nullptr};\n+\n+  // we don't flush the database as the context is null\n+  // (and also because there is nothing to flush)\n+\n+  ReplicaOfInternal(host, port, &ctxt, ActionOnConnectionFail::kContinueReplication);\n+}\n+\n void ServerFamily::ReplTakeOver(CmdArgList args, ConnectionContext* cntx) {\n   VLOG(1) << \"Starting take over\";\n   VLOG(1) << \"Acquire replica lock\";\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex edc3f6ccae24..8275a603c4bc 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -163,6 +163,9 @@ class ServerFamily {\n   bool AwaitDispatches(absl::Duration timeout,\n                        const std::function<bool(util::Connection*)>& filter);\n \n+  // Sets the server to replicate another instance. Does not flush the database beforehand!\n+  void Replicate(std::string_view host, std::string_view port);\n+\n  private:\n   uint32_t shard_count() const {\n     return shard_set->size();\n@@ -192,7 +195,17 @@ class ServerFamily {\n \n   void SyncGeneric(std::string_view repl_master_id, uint64_t offs, ConnectionContext* cntx);\n \n-  // Returns the number of loaded keys if successfull.\n+  enum ActionOnConnectionFail {\n+    kReturnOnError,        // if we fail to connect to master, return to err\n+    kContinueReplication,  // continue attempting to connect to master, regardless of initial\n+                           // failure\n+  };\n+\n+  // REPLICAOF implementation. See arguments above\n+  void ReplicaOfInternal(std::string_view host, std::string_view port, ConnectionContext* cntx,\n+                         ActionOnConnectionFail on_error);\n+\n+  // Returns the number of loaded keys if successful.\n   io::Result<size_t> LoadRdb(const std::string& rdb_file);\n \n   void SnapshotScheduling();\n",
  "test_patch": "diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex b4c55ee0bf58..6d30001657af 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -1371,3 +1371,133 @@ async def test_tls_replication(\n \n     await c_replica.close()\n     await c_master.close()\n+\n+\n+# busy wait for 'replica' instance to have replication status 'status'\n+async def wait_for_replica_status(replica: aioredis.Redis, status: str, wait_for_seconds=0.01):\n+    while True:\n+        await asyncio.sleep(wait_for_seconds)\n+\n+        info = await replica.info(\"replication\")\n+        if info[\"master_link_status\"] == status:\n+            return\n+\n+\n+@pytest.mark.asyncio\n+async def test_replicaof_flag(df_local_factory):\n+    # tests --replicaof works under normal conditions\n+    master = df_local_factory.create(\n+        port=BASE_PORT,\n+        proactor_threads=2,\n+    )\n+\n+    # set up master\n+    master.start()\n+    c_master = aioredis.Redis(port=master.port)\n+    await c_master.set(\"KEY\", b\"VALUE\")\n+    db_size = await c_master.dbsize()\n+    assert 1 == db_size\n+\n+    replica = df_local_factory.create(\n+        port=BASE_PORT + 1,\n+        proactor_threads=2,\n+        replicaof=f\"localhost:{BASE_PORT}\",  # start to replicate master\n+    )\n+\n+    # set up replica. check that it is replicating\n+    replica.start()\n+    c_replica = aioredis.Redis(port=replica.port)\n+\n+    await wait_available_async(c_replica)  # give it time to startup\n+    await wait_for_replica_status(c_replica, status=\"up\")  # wait until we have a connection\n+\n+    dbsize = await c_replica.dbsize()\n+    assert 1 == dbsize\n+\n+    val = await c_replica.get(\"KEY\")\n+    assert b\"VALUE\" == val\n+\n+\n+@pytest.mark.asyncio\n+async def test_replicaof_flag_replication_waits(df_local_factory):\n+    # tests --replicaof works when we launch replication before the master\n+    replica = df_local_factory.create(\n+        port=BASE_PORT + 1,\n+        proactor_threads=2,\n+        replicaof=f\"localhost:{BASE_PORT}\",  # start to replicate master\n+    )\n+\n+    # set up replica first\n+    replica.start()\n+    c_replica = aioredis.Redis(port=replica.port)\n+    await wait_for_replica_status(c_replica, status=\"down\")\n+\n+    # check that it is in replica mode, yet status is down\n+    info = await c_replica.info(\"replication\")\n+    assert info[\"role\"] == \"replica\"\n+    assert info[\"master_host\"] == \"localhost\"\n+    assert info[\"master_port\"] == BASE_PORT\n+    assert info[\"master_link_status\"] == \"down\"\n+\n+    # set up master\n+    master = df_local_factory.create(\n+        port=BASE_PORT,\n+        proactor_threads=2,\n+    )\n+\n+    master.start()\n+    c_master = aioredis.Redis(port=master.port)\n+    await c_master.set(\"KEY\", b\"VALUE\")\n+    db_size = await c_master.dbsize()\n+    assert 1 == db_size\n+\n+    # check that replication works now\n+    await wait_for_replica_status(c_replica, status=\"up\")\n+\n+    dbsize = await c_replica.dbsize()\n+    assert 1 == dbsize\n+\n+    val = await c_replica.get(\"KEY\")\n+    assert b\"VALUE\" == val\n+\n+\n+@pytest.mark.asyncio\n+async def test_replicaof_flag_disconnect(df_local_factory):\n+    # test stopping replication when started using --replicaof\n+    master = df_local_factory.create(\n+        port=BASE_PORT,\n+        proactor_threads=2,\n+    )\n+\n+    # set up master\n+    master.start()\n+    c_master = aioredis.Redis(port=master.port)\n+    await wait_available_async(c_master)\n+\n+    await c_master.set(\"KEY\", b\"VALUE\")\n+    db_size = await c_master.dbsize()\n+    assert 1 == db_size\n+\n+    replica = df_local_factory.create(\n+        port=BASE_PORT + 1,\n+        proactor_threads=2,\n+        replicaof=f\"localhost:{BASE_PORT}\",  # start to replicate master\n+    )\n+\n+    # set up replica. check that it is replicating\n+    replica.start()\n+\n+    c_replica = aioredis.Redis(port=replica.port)\n+    await wait_available_async(c_replica)\n+    await wait_for_replica_status(c_replica, status=\"up\")\n+\n+    dbsize = await c_replica.dbsize()\n+    assert 1 == dbsize\n+\n+    val = await c_replica.get(\"KEY\")\n+    assert b\"VALUE\" == val\n+\n+    await c_replica.replicaof(\"no\", \"one\")  #  disconnect\n+\n+    role = await c_replica.role()\n+    assert role[0] == b\"master\"\n",
  "problem_statement": "Add replicaof command flag\nas discussed on slack for starting replication from now we need to interact with the redis protocol to set the master.\r\nfor auto starting replication we need something like --slaveof= flag. \r\n\r\n(even if some ugly hack with systemd post start is possible)\n",
  "hints_text": "Lets make it `--replicaof=foo:port` \n> Lets make it `--replicaof=foo:port`\r\n\r\nJust have to make sure we parse IPv6 addresses correctly (see https://softwareengineering.stackexchange.com/questions/311413/how-should-we-represent-an-ipv6-address-with-port-number-in-text)\nI can help to implement this task.\r\nWhat kind of argument format do we want to support? I can think of the followings:\r\n* `--replicaof=<ipv4>:port`\r\n* `--replicaof=[<ipv6>]:port`\nIdeally I think the both seems needed \ud83d\udc4d ",
  "created_at": "2023-07-23T19:23:29Z",
  "modified_files": [
    "src/server/replica.cc",
    "src/server/replica.h",
    "src/server/server_family.cc",
    "src/server/server_family.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/replication_test.py"
  ]
}