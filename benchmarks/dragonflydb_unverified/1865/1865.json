{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1865,
  "instance_id": "dragonflydb__dragonfly-1865",
  "issue_numbers": [
    "1808"
  ],
  "base_commit": "0be2d98f2761b34c75d6e227c7aa25cb27ccc1c0",
  "patch": "diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex d45a7712f751..27ed3924895a 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -10,6 +10,7 @@\n \n #include <variant>\n \n+#include \"absl/strings/str_cat.h\"\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n #include \"facade/conn_context.h\"\n@@ -394,11 +395,11 @@ std::string Connection::LocalBindAddress() const {\n   return le.address().to_string();\n }\n \n-string Connection::GetClientInfo(unsigned thread_id) const {\n+std::pair<std::string, std::string> Connection::GetClientInfoBeforeAfterTid() const {\n   CHECK(service_ && socket_);\n   CHECK_LT(unsigned(phase_), NUM_PHASES);\n \n-  string res;\n+  string before;\n   auto le = socket_->LocalEndpoint();\n   auto re = socket_->RemoteEndpoint();\n   time_t now = time(nullptr);\n@@ -416,19 +417,48 @@ string Connection::GetClientInfo(unsigned thread_id) const {\n   static constexpr string_view PHASE_NAMES[] = {\"setup\", \"readsock\", \"process\"};\n   static_assert(PHASE_NAMES[PROCESS] == \"process\");\n \n-  absl::StrAppend(&res, \"id=\", id_, \" addr=\", re.address().to_string(), \":\", re.port());\n-  absl::StrAppend(&res, \" laddr=\", le.address().to_string(), \":\", le.port());\n-  absl::StrAppend(&res, \" fd=\", socket_->native_handle(), \" name=\", name_);\n-  absl::StrAppend(&res, \" tid=\", thread_id, \" irqmatch=\", int(cpu == my_cpu_id));\n-  absl::StrAppend(&res, \" age=\", now - creation_time_, \" idle=\", now - last_interaction_);\n-  absl::StrAppend(&res, \" phase=\", PHASE_NAMES[phase_]);\n+  absl::StrAppend(&before, \"id=\", id_, \" addr=\", re.address().to_string(), \":\", re.port());\n+  absl::StrAppend(&before, \" laddr=\", le.address().to_string(), \":\", le.port());\n+  absl::StrAppend(&before, \" fd=\", socket_->native_handle(), \" name=\", name_);\n+\n+  string after;\n+  absl::StrAppend(&after, \" irqmatch=\", int(cpu == my_cpu_id));\n+  absl::StrAppend(&after, \" age=\", now - creation_time_, \" idle=\", now - last_interaction_);\n+  absl::StrAppend(&after, \" phase=\", PHASE_NAMES[phase_]);\n \n   if (cc_) {\n     string cc_info = service_->GetContextInfo(cc_.get());\n-    absl::StrAppend(&res, \" \", cc_info);\n+    absl::StrAppend(&after, \" \", cc_info);\n   }\n \n-  return res;\n+  return {std::move(before), std::move(after)};\n+}\n+\n+string Connection::GetClientInfo(unsigned thread_id) const {\n+  auto [before, after] = GetClientInfoBeforeAfterTid();\n+  absl::StrAppend(&before, \" tid=\", thread_id);\n+  absl::StrAppend(&before, after);\n+  return before;\n+}\n+\n+string Connection::GetClientInfo() const {\n+  auto [before, after] = GetClientInfoBeforeAfterTid();\n+  absl::StrAppend(&before, after);\n+  // The following are dummy fields and users should not rely on those unless\n+  // we decide to implement them.\n+  // This is only done because the redis pyclient parser for the field \"client-info\"\n+  // for the command ACL LOG hardcodes the expected values. This behaviour does not\n+  // conform to the actual expected values, since it's missing half of them.\n+  // That is, even for redis-server, issuing an ACL LOG command via redis-cli and the pyclient\n+  // will return different results! For example, the fields:\n+  // addr=127.0.0.1:57275\n+  // laddr=127.0.0.1:6379\n+  // are missing from the pyclient.\n+\n+  absl::StrAppend(&before, \" qbuf=0 \", \"qbuf-free=0 \", \"obl=0 \", \"argv-mem=0 \");\n+  absl::StrAppend(&before, \"oll=0 \", \"omem=0 \", \"tot-mem=0 \", \"multi=0 \");\n+  absl::StrAppend(&before, \"psub=0 \", \"sub=0\");\n+  return before;\n }\n \n uint32_t Connection::GetClientId() const {\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex 9498c54c5862..a138b741add9 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -156,6 +156,7 @@ class Connection : public util::Connection {\n   bool IsCurrentlyDispatching() const;\n \n   std::string GetClientInfo(unsigned thread_id) const;\n+  std::string GetClientInfo() const;\n   std::string RemoteEndpointStr() const;\n   std::string RemoteEndpointAddress() const;\n   std::string LocalBindAddress() const;\n@@ -228,6 +229,7 @@ class Connection : public util::Connection {\n   PipelineMessagePtr GetFromPipelinePool();\n \n  private:\n+  std::pair<std::string, std::string> GetClientInfoBeforeAfterTid() const;\n   std::deque<MessageHandle> dispatch_q_;  // dispatch queue\n   dfly::EventCount evc_;                  // dispatch queue waker\n   util::fb2::Fiber dispatch_fb_;          // dispatch fiber (if started)\ndiff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 85fa5848d818..8d5bb0d9569e 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -18,7 +18,7 @@ add_library(dfly_transaction db_slice.cc malloc_stats.cc engine_shard_set.cc blo\n             common.cc journal/journal.cc journal/types.cc journal/journal_slice.cc\n             server_state.cc table.cc  top_keys.cc transaction.cc\n             serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc\n-            ${TX_LINUX_SRCS}\n+            ${TX_LINUX_SRCS} acl/acl_log.cc\n             )\n cxx_link(dfly_transaction dfly_core strings_lib)\n \ndiff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc\nindex 227feedece64..2dcf8934a8f0 100644\n--- a/src/server/acl/acl_family.cc\n+++ b/src/server/acl/acl_family.cc\n@@ -5,13 +5,19 @@\n \n #include <glog/logging.h>\n \n+#include <algorithm>\n #include <cctype>\n+#include <chrono>\n+#include <deque>\n #include <memory>\n+#include <numeric>\n #include <optional>\n #include <string>\n #include <utility>\n #include <variant>\n \n+#include \"absl/strings/match.h\"\n+#include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/types/span.h\"\n #include \"base/flags.h\"\n@@ -23,15 +29,19 @@\n #include \"io/file_util.h\"\n #include \"io/io.h\"\n #include \"server/acl/acl_commands_def.h\"\n+#include \"server/acl/acl_log.h\"\n #include \"server/acl/helpers.h\"\n #include \"server/command_registry.h\"\n #include \"server/conn_context.h\"\n+#include \"server/server_state.h\"\n+#include \"util/proactor_pool.h\"\n \n ABSL_FLAG(std::string, aclfile, \"\", \"Path and name to aclfile\");\n \n namespace dfly::acl {\n \n-AclFamily::AclFamily(UserRegistry* registry) : registry_(registry) {\n+AclFamily::AclFamily(UserRegistry* registry, util::ProactorPool* pool)\n+    : registry_(registry), pool_(pool) {\n }\n \n void AclFamily::Acl(CmdArgList args, ConnectionContext* cntx) {\n@@ -272,9 +282,89 @@ void AclFamily::Load(CmdArgList args, ConnectionContext* cntx) {\n   cntx->SendOk();\n }\n \n+void AclFamily::Log(CmdArgList args, ConnectionContext* cntx) {\n+  if (args.size() > 1) {\n+    (*cntx)->SendError(facade::OpStatus::OUT_OF_RANGE);\n+  }\n+\n+  size_t max_output = 10;\n+  if (args.size() == 1) {\n+    auto option = facade::ToSV(args[0]);\n+    if (absl::EqualsIgnoreCase(option, \"RESET\")) {\n+      pool_->AwaitFiberOnAll(\n+          [](auto index, auto* context) { ServerState::tlocal()->acl_log.Reset(); });\n+      (*cntx)->SendOk();\n+      return;\n+    }\n+\n+    if (!absl::SimpleAtoi(facade::ToSV(args[0]), &max_output)) {\n+      (*cntx)->SendError(\"Invalid count\");\n+      return;\n+    }\n+  }\n+\n+  std::vector<AclLog::LogType> logs(pool_->size());\n+  pool_->AwaitFiberOnAll([&logs, max_output](auto index, auto* context) {\n+    logs[index] = ServerState::tlocal()->acl_log.GetLog(max_output);\n+  });\n+\n+  size_t total_entries = 0;\n+  for (auto& log : logs) {\n+    total_entries += log.size();\n+  }\n+\n+  if (total_entries == 0) {\n+    (*cntx)->SendEmptyArray();\n+    return;\n+  }\n+\n+  (*cntx)->StartArray(total_entries);\n+  auto print_element = [cntx](const auto& entry) {\n+    (*cntx)->StartArray(12);\n+    (*cntx)->SendSimpleString(\"reason\");\n+    using Reason = AclLog::Reason;\n+    std::string_view reason = entry.reason == Reason::COMMAND ? \"COMMAND\" : \"AUTH\";\n+    (*cntx)->SendSimpleString(reason);\n+    (*cntx)->SendSimpleString(\"object\");\n+    (*cntx)->SendSimpleString(entry.object);\n+    (*cntx)->SendSimpleString(\"username\");\n+    (*cntx)->SendSimpleString(entry.username);\n+    (*cntx)->SendSimpleString(\"age-seconds\");\n+    auto now_diff = std::chrono::system_clock::now() - entry.entry_creation;\n+    auto secs = std::chrono::duration_cast<std::chrono::seconds>(now_diff);\n+    auto left_over = now_diff - std::chrono::duration_cast<std::chrono::microseconds>(secs);\n+    auto age = absl::StrCat(secs.count(), \".\", left_over.count());\n+    (*cntx)->SendSimpleString(absl::StrCat(age));\n+    (*cntx)->SendSimpleString(\"client-info\");\n+    (*cntx)->SendSimpleString(entry.client_info);\n+    (*cntx)->SendSimpleString(\"timestamp-created\");\n+    (*cntx)->SendLong(entry.entry_creation.time_since_epoch().count());\n+  };\n+\n+  auto n_way_minimum = [](const auto& logs) {\n+    size_t id = 0;\n+    AclLog::LogEntry limit;\n+    const AclLog::LogEntry* max = &limit;\n+    for (size_t i = 0; i < logs.size(); ++i) {\n+      if (!logs[i].empty() && logs[i].front() < *max) {\n+        id = i;\n+        max = &logs[i].front();\n+      }\n+    }\n+\n+    return id;\n+  };\n+\n+  for (size_t i = 0; i < total_entries; ++i) {\n+    auto min = n_way_minimum(logs);\n+    print_element(logs[min].front());\n+    logs[min].pop_front();\n+  }\n+}\n+\n using MemberFunc = void (AclFamily::*)(CmdArgList args, ConnectionContext* cntx);\n \n-inline CommandId::Handler HandlerFunc(AclFamily* acl, MemberFunc f) {\n+CommandId::Handler HandlerFunc(AclFamily* acl, MemberFunc f) {\n   return [=](CmdArgList args, ConnectionContext* cntx) { return (acl->*f)(args, cntx); };\n }\n \n@@ -287,6 +377,7 @@ constexpr uint32_t kDelUser = acl::ADMIN | acl::SLOW | acl::DANGEROUS;\n constexpr uint32_t kWhoAmI = acl::SLOW;\n constexpr uint32_t kSave = acl::ADMIN | acl::SLOW | acl::DANGEROUS;\n constexpr uint32_t kLoad = acl::ADMIN | acl::SLOW | acl::DANGEROUS;\n+constexpr uint32_t kLog = acl::ADMIN | acl::SLOW | acl::DANGEROUS;\n \n // We can't implement the ACL commands and its respective subcommands LIST, CAT, etc\n // the usual way, (that is, one command called ACL which then dispatches to the subcommand\n@@ -312,6 +403,8 @@ void AclFamily::Register(dfly::CommandRegistry* registry) {\n       Save);\n   *registry << CI{\"ACL LOAD\", CO::ADMIN | CO::NOSCRIPT | CO::LOADING, 1, 0, 0, 0, acl::kLoad}.HFUNC(\n       Load);\n+  *registry << CI{\"ACL LOG\", CO::ADMIN | CO::NOSCRIPT | CO::LOADING, 0, 0, 0, 0, acl::kLog}.HFUNC(\n+      Log);\n \n   cmd_registry_ = registry;\n }\ndiff --git a/src/server/acl/acl_family.h b/src/server/acl/acl_family.h\nindex d5f9ae6f0a54..417c028cb09f 100644\n--- a/src/server/acl/acl_family.h\n+++ b/src/server/acl/acl_family.h\n@@ -23,7 +23,7 @@ namespace acl {\n \n class AclFamily final {\n  public:\n-  explicit AclFamily(UserRegistry* registry);\n+  explicit AclFamily(UserRegistry* registry, util::ProactorPool* pool);\n \n   void Register(CommandRegistry* registry);\n   void Init(facade::Listener* listener, UserRegistry* registry);\n@@ -36,7 +36,9 @@ class AclFamily final {\n   void WhoAmI(CmdArgList args, ConnectionContext* cntx);\n   void Save(CmdArgList args, ConnectionContext* cntx);\n   void Load(CmdArgList args, ConnectionContext* cntx);\n+  // Helper function for bootstrap\n   bool Load();\n+  void Log(CmdArgList args, ConnectionContext* cntx);\n \n   // Helper function that updates all open connections and their\n   // respective ACL fields on all the available proactor threads\ndiff --git a/src/server/acl/acl_log.cc b/src/server/acl/acl_log.cc\nnew file mode 100644\nindex 000000000000..7717463bbefa\n--- /dev/null\n+++ b/src/server/acl/acl_log.cc\n@@ -0,0 +1,58 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#include \"server/acl/acl_log.h\"\n+\n+#include <chrono>\n+#include <iterator>\n+\n+#include \"base/flags.h\"\n+#include \"base/logging.h\"\n+#include \"facade/dragonfly_connection.h\"\n+\n+ABSL_FLAG(size_t, acllog_max_len, 32,\n+          \"Specify the number of log entries. Logs are kept locally for each thread \"\n+          \"and therefore the total number of entries are acllog_max_len * threads\");\n+\n+namespace dfly::acl {\n+\n+AclLog::AclLog() : total_entries_allowed_(absl::GetFlag(FLAGS_acllog_max_len)) {\n+}\n+\n+void AclLog::Add(const ConnectionContext& cntx, std::string object, Reason reason,\n+                 std::string tried_to_auth) {\n+  if (total_entries_allowed_ == 0) {\n+    return;\n+  }\n+\n+  if (log_.size() == total_entries_allowed_) {\n+    log_.pop_back();\n+  }\n+\n+  std::string username;\n+  // We can't use a conditional here because the result is the common type which is a const-ref\n+  if (tried_to_auth.empty()) {\n+    username = cntx.authed_username;\n+  } else {\n+    username = std::move(tried_to_auth);\n+  }\n+\n+  std::string client_info = cntx.owner()->GetClientInfo();\n+  using clock = std::chrono::system_clock;\n+  LogEntry entry = {std::move(username), std::move(client_info), std::move(object), reason,\n+                    clock::now()};\n+  log_.push_front(std::move(entry));\n+}\n+\n+void AclLog::Reset() {\n+  log_.clear();\n+}\n+\n+AclLog::LogType AclLog::GetLog(size_t number_of_entries) const {\n+  auto start = log_.begin();\n+  auto end = log_.size() <= number_of_entries ? log_.end() : std::next(start, number_of_entries);\n+  return {start, end};\n+}\n+\n+}  // namespace dfly::acl\ndiff --git a/src/server/acl/acl_log.h b/src/server/acl/acl_log.h\nnew file mode 100644\nindex 000000000000..ced2af7ece16\n--- /dev/null\n+++ b/src/server/acl/acl_log.h\n@@ -0,0 +1,50 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#pragma once\n+\n+#include <chrono>\n+#include <deque>\n+#include <string>\n+\n+#include \"base/flags.h\"\n+#include \"server/conn_context.h\"\n+\n+ABSL_DECLARE_FLAG(size_t, acllog_max_len);\n+\n+namespace dfly::acl {\n+\n+class AclLog {\n+ public:\n+  explicit AclLog();\n+\n+  enum class Reason { COMMAND, AUTH };\n+\n+  struct LogEntry {\n+    std::string username;\n+    std::string client_info;\n+    std::string object;\n+    Reason reason;\n+    using TimePoint = std::chrono::time_point<std::chrono::system_clock>;\n+    TimePoint entry_creation = TimePoint::max();\n+\n+    friend bool operator<(const LogEntry& lhs, const LogEntry& rhs) {\n+      return lhs.entry_creation < rhs.entry_creation;\n+    }\n+  };\n+\n+  void Add(const ConnectionContext& cntx, std::string object, Reason reason,\n+           std::string tried_to_auth = \"\");\n+  void Reset();\n+\n+  using LogType = std::deque<LogEntry>;\n+\n+  LogType GetLog(size_t number_of_entries) const;\n+\n+ private:\n+  LogType log_;\n+  const size_t total_entries_allowed_;\n+};\n+\n+}  // namespace dfly::acl\ndiff --git a/src/server/acl/helpers.cc b/src/server/acl/helpers.cc\nindex 97b68d56eeac..92cfed5b078a 100644\n--- a/src/server/acl/helpers.cc\n+++ b/src/server/acl/helpers.cc\n@@ -245,5 +245,4 @@ ParseAclSetUser<std::vector<std::string_view>&>(std::vector<std::string_view>&,\n \n template std::variant<User::UpdateRequest, ErrorReply> ParseAclSetUser<CmdArgList>(\n     CmdArgList args, const CommandRegistry& registry, bool hashed);\n-\n }  // namespace dfly::acl\ndiff --git a/src/server/acl/helpers.h b/src/server/acl/helpers.h\nindex bf4d6b476a67..97885197bdf7 100644\n--- a/src/server/acl/helpers.h\n+++ b/src/server/acl/helpers.h\n@@ -11,6 +11,7 @@\n #include <variant>\n \n #include \"facade/facade_types.h\"\n+#include \"server/acl/acl_log.h\"\n #include \"server/acl/user.h\"\n #include \"server/command_registry.h\"\n \ndiff --git a/src/server/acl/validator.cc b/src/server/acl/validator.cc\nindex aeb54ab77b9d..ddfa9eac9ced 100644\n--- a/src/server/acl/validator.cc\n+++ b/src/server/acl/validator.cc\n@@ -5,6 +5,7 @@\n #include \"server/acl/validator.h\"\n \n #include \"base/logging.h\"\n+#include \"facade/dragonfly_connection.h\"\n #include \"server/acl/acl_commands_def.h\"\n #include \"server/server_state.h\"\n \n@@ -17,9 +18,16 @@ namespace dfly::acl {\n   const size_t index = id.GetFamily();\n   const uint64_t command_mask = id.GetBitIndex();\n   DCHECK_LT(index, cntx.acl_commands.size());\n+  const bool is_authed = (cntx.acl_categories & cat_credentials) != 0 ||\n+                         (cntx.acl_commands[index] & command_mask) != 0;\n \n-  return (cntx.acl_categories & cat_credentials) != 0 ||\n-         (cntx.acl_commands[index] & command_mask) != 0;\n+  if (!is_authed) {\n+    auto& log = ServerState::tlocal()->acl_log;\n+    using Reason = acl::AclLog::Reason;\n+    log.Add(cntx, std::string(id.name()), Reason::COMMAND);\n+  }\n+\n+  return is_authed;\n }\n \n }  // namespace dfly::acl\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex a7cfb52bc90d..f1834f6885fc 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -630,7 +630,7 @@ optional<ShardId> GetRemoteShardToRunAt(const Transaction& tx) {\n \n Service::Service(ProactorPool* pp)\n     : pp_(*pp),\n-      acl_family_(&user_registry_),\n+      acl_family_(&user_registry_, pp),\n       server_family_(this),\n       cluster_family_(&server_family_) {\n   CHECK(pp);\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex b9e0461367ea..435afa168c8c 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1013,6 +1013,9 @@ void ServerFamily::Auth(CmdArgList args, ConnectionContext* cntx) {\n       cntx->acl_commands = cred.acl_commands;\n       return (*cntx)->SendOk();\n     }\n+    auto& log = ServerState::tlocal()->acl_log;\n+    using Reason = acl::AclLog::Reason;\n+    log.Add(*cntx, \"AUTH\", Reason::AUTH, std::string(username));\n     return (*cntx)->SendError(absl::StrCat(\"Could not authorize user: \", username));\n   }\n \ndiff --git a/src/server/server_state.h b/src/server/server_state.h\nindex fa7d13deed97..e93ad774bfe2 100644\n--- a/src/server/server_state.h\n+++ b/src/server/server_state.h\n@@ -9,6 +9,7 @@\n \n #include \"base/histogram.h\"\n #include \"core/interpreter.h\"\n+#include \"server/acl/acl_log.h\"\n #include \"server/acl/user_registry.h\"\n #include \"server/common.h\"\n #include \"server/script_mgr.h\"\n@@ -209,6 +210,8 @@ class ServerState {  // public struct - to allow initialization.\n \n   acl::UserRegistry* user_registry;\n \n+  acl::AclLog acl_log;\n+\n  private:\n   int64_t live_transactions_ = 0;\n   mi_heap_t* data_heap_;\n",
  "test_patch": "diff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex 24daf6f7e924..236bec185f41 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -19,6 +19,7 @@ extern \"C\" {\n #include \"base/logging.h\"\n #include \"base/stl_util.h\"\n #include \"facade/dragonfly_connection.h\"\n+#include \"server/acl/acl_log.h\"\n #include \"util/fibers/pool.h\"\n \n using namespace std;\n@@ -563,6 +564,7 @@ void BaseFamilyTest::SetTestFlag(string_view flag_name, string_view new_value) {\n }\n \n void BaseFamilyTest::TestInitAclFam() {\n+  absl::SetFlag(&FLAGS_acllog_max_len, 0);\n   service_->TestInit();\n }\n \ndiff --git a/tests/dragonfly/acl_family_test.py b/tests/dragonfly/acl_family_test.py\nindex f237692cad91..ff4f76b0fc01 100644\n--- a/tests/dragonfly/acl_family_test.py\n+++ b/tests/dragonfly/acl_family_test.py\n@@ -349,3 +349,42 @@ async def test_good_acl_file(df_local_factory, tmp_dir):\n     assert \"user vlad off nopass +@STRING\" in result\n \n     await client.close()\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_log(async_client):\n+    res = await async_client.execute_command(\"ACL LOG\")\n+    assert [] == res\n+\n+    await async_client.execute_command(\"ACL SETUSER elon >mars ON +@string +@dangerous\")\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"AUTH elon wrong\")\n+\n+    res = await async_client.execute_command(\"ACL LOG\")\n+    assert 1 == len(res)\n+    assert res[0][\"reason\"] == \"AUTH\"\n+    assert res[0][\"object\"] == \"AUTH\"\n+    assert res[0][\"username\"] == \"elon\"\n+\n+    await async_client.execute_command(\"ACL LOG RESET\")\n+    res = await async_client.execute_command(\"ACL LOG\")\n+    assert 0 == len(res)\n+\n+    res = await async_client.execute_command(\"AUTH elon mars\")\n+    res = await async_client.execute_command(\"SET mykey 22\")\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"HSET mk kk 22\")\n+\n+    res = await async_client.execute_command(\"ACL LOG\")\n+    assert 1 == len(res)\n+    assert res[0][\"reason\"] == \"COMMAND\"\n+    assert res[0][\"object\"] == \"HSET\"\n+    assert res[0][\"username\"] == \"elon\"\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"LPUSH mylist 2\")\n+\n+    res = await async_client.execute_command(\"ACL LOG\")\n+    assert 2 == len(res)\n",
  "problem_statement": "Add acl command log\n* ACL LOG\n",
  "hints_text": "",
  "created_at": "2023-09-15T16:03:04Z",
  "modified_files": [
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/server/CMakeLists.txt",
    "src/server/acl/acl_family.cc",
    "src/server/acl/acl_family.h",
    "b/src/server/acl/acl_log.cc",
    "b/src/server/acl/acl_log.h",
    "src/server/acl/helpers.cc",
    "src/server/acl/helpers.h",
    "src/server/acl/validator.cc",
    "src/server/main_service.cc",
    "src/server/server_family.cc",
    "src/server/server_state.h"
  ],
  "modified_test_files": [
    "src/server/test_utils.cc",
    "tests/dragonfly/acl_family_test.py"
  ]
}