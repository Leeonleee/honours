{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5266,
  "instance_id": "dragonflydb__dragonfly-5266",
  "issue_numbers": [
    "5265"
  ],
  "base_commit": "6a6a010dfa46eeb7d3f51926ffa25af446f83460",
  "patch": "diff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 873545d8471b..cd5c58a6ff3d 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -432,6 +432,12 @@ OpStatus SetFullJson(const OpArgs& op_args, string_view key, string_view json_st\n   auto it_res = op_args.GetDbSlice().AddOrFind(op_args.db_cntx, key);\n   RETURN_ON_BAD_STATUS(it_res);\n \n+  auto type = it_res->it->second.ObjType();\n+  if (type != OBJ_JSON && type != OBJ_STRING) {\n+    // The object is not a JSON object and not a string, so we cannot set a full JSON value\n+    return OpStatus::WRONG_TYPE;\n+  }\n+\n   JsonAutoUpdater updater(op_args, key, *std::move(it_res));\n \n   std::optional<JsonType> parsed_json = ShardJsonFromString(json_str);\n@@ -756,6 +762,8 @@ bool LegacyModeIsEnabled(const std::vector<std::pair<std::string_view, WrappedJs\n \n OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,\n                                 const JsonGetParams& params) {\n+  // We don't use OBJ_JSON here because we want to support both JSON and STRING types.\n+  // If the key is not OBJ_JSON and not OBJ_STRING, we return WRONG_TYPE.\n   auto it = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key).it;\n   if (!IsValid(it))\n     return OpStatus::KEY_NOTFOUND;\n@@ -1029,9 +1037,12 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,\n                      const WrappedJsonPath& json_path) {\n   if (json_path.RefersToRootElement()) {\n     auto& db_slice = op_args.GetDbSlice();\n-    auto it = db_slice.FindMutable(op_args.db_cntx, key).it;  // post_updater will run immediately\n-    if (IsValid(it)) {\n-      db_slice.Del(op_args.db_cntx, it);\n+    auto res_it = db_slice.FindMutable(op_args.db_cntx, key, OBJ_JSON);\n+    RETURN_ON_BAD_STATUS(res_it);\n+\n+    if (IsValid(res_it->it)) {\n+      res_it->post_updater.Run();\n+      db_slice.Del(op_args.db_cntx, res_it->it);\n       return 1;\n     }\n     return 0;\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex 334d455b1037..183c2586b415 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -9,6 +9,7 @@\n \n #include \"base/gtest.h\"\n #include \"base/logging.h\"\n+#include \"facade/error.h\"\n #include \"facade/facade_test.h\"\n #include \"server/command_registry.h\"\n #include \"server/test_utils.h\"\n@@ -3087,4 +3088,26 @@ TEST_F(JsonFamilyTest, DepthLimitExceeded) {\n   ASSERT_THAT(resp, ErrArg(\"ERR failed to parse JSON\"));\n }\n \n+TEST_F(JsonFamilyTest, JsonCommandsWorkingWithOtherTypesBug) {\n+  std::string_view wrong_type_err{kWrongTypeErr};\n+  wrong_type_err.remove_prefix(1);  // Remove the leading - character\n+\n+  auto resp = Run({\"HSET\", \"k1\", \"field\", \"value\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  // First bug: JSON.SET should return an error\n+  resp = Run({\"JSON.SET\", \"k1\", \"$\", R\"({\"a\":\"b\"})\"});\n+  ASSERT_THAT(resp, ErrArg(wrong_type_err));\n+\n+  // Second bug: JSON.DEL should not delete the hash\n+  resp = Run({\"HSET\", \"k2\", \"field\", \"value\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.DEL\", \"k2\"});\n+  ASSERT_THAT(resp, ErrArg(wrong_type_err));\n+\n+  resp = Run({\"HGET\", \"k2\", \"field\"});\n+  EXPECT_THAT(resp, \"value\");\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "JSON commands changing other datatypes\nI found two bugs in current json logic. We are not using `OBJ_JSON` for some commands when we call `FindMutable`.\n1. Bug:\n\n```\n127.0.0.1:6379> hset k1 field value                                                                                                                                                                         \n(integer) 1                                                                                                                                                                                                 \n127.0.0.1:6379> json.set k1 $ '{\"a\":\"b\"}'                                                                                                                                                                   \nOK\n```\nExpected:\n```\n127.0.0.1:6379> hset k1 field value\n(integer) 1\n127.0.0.1:6379> json.set k1 $ '{\"a\":\"b\"}'\n(error) WRONGTYPE Operation against a key holding the wrong kind of value\n```\n\n2. Bug:\n\n```\n127.0.0.1:6379> hset k1 field value\n(integer) 1\n127.0.0.1:6379> json.del k1\n(integer) 1\n127.0.0.1:6379> hget k1 field\n(nil)\n```\nExpected:\n```\n127.0.0.1:6379> hset k1 field value\n(integer) 1\n127.0.0.1:6379> json.del k1\n(error) WRONGTYPE Operation against a key holding the wrong kind of value\n127.0.0.1:6379> hget k1 field\n\"value\"\n```\n",
  "hints_text": "",
  "created_at": "2025-06-10T11:51:56Z",
  "modified_files": [
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}