diff --git a/src/server/json_family.cc b/src/server/json_family.cc
index 873545d8471b..cd5c58a6ff3d 100644
--- a/src/server/json_family.cc
+++ b/src/server/json_family.cc
@@ -432,6 +432,12 @@ OpStatus SetFullJson(const OpArgs& op_args, string_view key, string_view json_st
   auto it_res = op_args.GetDbSlice().AddOrFind(op_args.db_cntx, key);
   RETURN_ON_BAD_STATUS(it_res);
 
+  auto type = it_res->it->second.ObjType();
+  if (type != OBJ_JSON && type != OBJ_STRING) {
+    // The object is not a JSON object and not a string, so we cannot set a full JSON value
+    return OpStatus::WRONG_TYPE;
+  }
+
   JsonAutoUpdater updater(op_args, key, *std::move(it_res));
 
   std::optional<JsonType> parsed_json = ShardJsonFromString(json_str);
@@ -756,6 +762,8 @@ bool LegacyModeIsEnabled(const std::vector<std::pair<std::string_view, WrappedJs
 
 OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,
                                 const JsonGetParams& params) {
+  // We don't use OBJ_JSON here because we want to support both JSON and STRING types.
+  // If the key is not OBJ_JSON and not OBJ_STRING, we return WRONG_TYPE.
   auto it = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key).it;
   if (!IsValid(it))
     return OpStatus::KEY_NOTFOUND;
@@ -1029,9 +1037,12 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,
                      const WrappedJsonPath& json_path) {
   if (json_path.RefersToRootElement()) {
     auto& db_slice = op_args.GetDbSlice();
-    auto it = db_slice.FindMutable(op_args.db_cntx, key).it;  // post_updater will run immediately
-    if (IsValid(it)) {
-      db_slice.Del(op_args.db_cntx, it);
+    auto res_it = db_slice.FindMutable(op_args.db_cntx, key, OBJ_JSON);
+    RETURN_ON_BAD_STATUS(res_it);
+
+    if (IsValid(res_it->it)) {
+      res_it->post_updater.Run();
+      db_slice.Del(op_args.db_cntx, res_it->it);
       return 1;
     }
     return 0;
