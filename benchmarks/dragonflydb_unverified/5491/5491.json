{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5491,
  "instance_id": "dragonflydb__dragonfly-5491",
  "issue_numbers": [
    "5487"
  ],
  "base_commit": "f55d74cb6abb9b9572ae959a2540edc6f0684828",
  "patch": "diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt\nindex 833dbc7c6c5c..2695281a3ae0 100644\n--- a/src/core/CMakeLists.txt\n+++ b/src/core/CMakeLists.txt\n@@ -26,7 +26,7 @@ add_library(dfly_core allocation_tracker.cc bloom.cc compact_object.cc dense_set\n     segment_allocator.cc score_map.cc small_string.cc sorted_map.cc task_queue.cc\n     tx_queue.cc string_set.cc string_map.cc top_keys.cc detail/bitpacking.cc)\n \n-cxx_link(dfly_core base absl::flat_hash_map absl::str_format redis_lib TRDP::lua lua_modules\n+cxx_link(dfly_core base absl::flat_hash_map absl::str_format absl::random_random redis_lib TRDP::lua lua_modules\n     fibers2 ${SEARCH_LIB} jsonpath OpenSSL::Crypto TRDP::dconv TRDP::lz4)\n \n add_executable(dash_bench dash_bench.cc)\ndiff --git a/src/core/dense_set.cc b/src/core/dense_set.cc\nindex d78b572a6e30..5effbe13b024 100644\n--- a/src/core/dense_set.cc\n+++ b/src/core/dense_set.cc\n@@ -12,6 +12,8 @@\n #include <type_traits>\n #include <vector>\n \n+#include \"absl/random/distributions.h\"\n+#include \"absl/random/random.h\"\n #include \"base/logging.h\"\n \n extern \"C\" {\n@@ -670,22 +672,38 @@ void DenseSet::Delete(DensePtr* prev, DensePtr* ptr) {\n   ObjDelete(obj, false);\n }\n \n-void* DenseSet::PopInternal() {\n-  ChainVectorIterator bucket_iter = entries_.begin();\n+DenseSet::ChainVectorIterator DenseSet::GetRandomChain() {\n+  size_t offset = absl::Uniform(absl::BitGen{}, 0u, entries_.size());\n+  for (size_t i = offset; i < entries_.size() + offset; i++) {\n+    auto it = entries_.begin() + (i % entries_.size());\n+    ExpireIfNeeded(nullptr, &*it);\n+    if (!it->IsEmpty())\n+      return it;\n+  }\n+  return entries_.end();\n+}\n \n-  // find the first non-empty chain\n-  do {\n-    while (bucket_iter != entries_.end() && bucket_iter->IsEmpty()) {\n-      ++bucket_iter;\n-    }\n+DenseSet::IteratorBase DenseSet::GetRandomIterator() {\n+  ChainVectorIterator chain_it = GetRandomChain();\n+  if (chain_it == entries_.end())\n+    return IteratorBase{};\n \n-    // empty set\n-    if (bucket_iter == entries_.end()) {\n-      return nullptr;\n-    }\n+  DensePtr* ptr = &*chain_it;\n+  absl::BitGen bg{};\n+  while (ptr->IsLink() && absl::Bernoulli(bg, 0.5)) {\n+    DensePtr* next = ptr->Next();\n+    if (ExpireIfNeeded(ptr, next))  // stop if we break the chain with expiration\n+      break;\n+    ptr = next;\n+  }\n \n-    ExpireIfNeeded(nullptr, &(*bucket_iter));\n-  } while (bucket_iter->IsEmpty());\n+  return IteratorBase{(DenseSet*)this, chain_it, ptr};\n+}\n+\n+void* DenseSet::PopInternal() {\n+  auto bucket_iter = GetRandomChain();  // Find first non empty chain\n+  if (bucket_iter == entries_.end())\n+    return nullptr;\n \n   if (bucket_iter->IsObject()) {\n     --num_used_buckets_;\ndiff --git a/src/core/dense_set.h b/src/core/dense_set.h\nindex 0ac73a47bc0c..bd8c7898622f 100644\n--- a/src/core/dense_set.h\n+++ b/src/core/dense_set.h\n@@ -305,6 +305,12 @@ class DenseSet {\n     return IteratorBase{};\n   }\n \n+  // Get iterator to start of random non-empty chain (bucket)\n+  ChainVectorIterator GetRandomChain();\n+\n+  // Wrap RandomChain() into iterator and advance with reservoir sampling\n+  IteratorBase GetRandomIterator();\n+\n   void* PopInternal();\n \n   void IncreaseMallocUsed(size_t delta) {\ndiff --git a/src/core/string_set.cc b/src/core/string_set.cc\nindex ea424f6e6d5e..8c1ed043d8a0 100644\n--- a/src/core/string_set.cc\n+++ b/src/core/string_set.cc\n@@ -112,6 +112,10 @@ unsigned StringSet::AddBatch(absl::Span<std::string_view> span, uint32_t ttl_sec\n   return res;\n }\n \n+StringSet::iterator StringSet::GetRandomMember() {\n+  return iterator{DenseSet::GetRandomIterator()};\n+}\n+\n std::optional<std::string> StringSet::Pop() {\n   sds str = (sds)PopInternal();\n \ndiff --git a/src/core/string_set.h b/src/core/string_set.h\nindex 846ee852c7a9..3fe1f3ef1945 100644\n--- a/src/core/string_set.h\n+++ b/src/core/string_set.h\n@@ -39,8 +39,6 @@ class StringSet : public DenseSet {\n     return FindInternal(&s1, Hash(&s1, 1), 1) != nullptr;\n   }\n \n-  std::optional<std::string> Pop();\n-\n   class iterator : private IteratorBase {\n    public:\n     using iterator_category = std::forward_iterator_tag;\n@@ -99,6 +97,11 @@ class StringSet : public DenseSet {\n     return iterator{};\n   }\n \n+  // See DenseSet::GetRandomIterator\n+  iterator GetRandomMember();\n+\n+  std::optional<std::string> Pop();\n+\n   uint32_t Scan(uint32_t, const std::function<void(sds)>&) const;\n \n   iterator Find(std::string_view member) {\ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex 6a8ded6f26ab..711233a771bd 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -133,6 +133,10 @@ struct StringSetWrapper {\n     return curs;\n   }\n \n+  explicit operator StringSet*() const {\n+    return ss;\n+  }\n+\n   StringSet* operator->() const {\n     return ss;\n   }\n@@ -265,9 +269,33 @@ void InterStrSet(const DbContext& db_context, const vector<SetType>& vec, String\n   }\n }\n \n+template <typename C = absl::flat_hash_set<string>>\n+StringVec RandMemberStrSetPicky(StringSet* strset, size_t count) {\n+  C picks;\n+  picks.reserve(count);\n+\n+  size_t tries = 0;\n+  while (picks.size() < count && tries++ < count * 2)\n+    picks.insert(picks.end(), string{*strset->GetRandomMember()});\n+\n+  if constexpr (is_same_v<StringVec, C>)\n+    return picks;\n+  return StringVec{make_move_iterator(picks.begin()), make_move_iterator(picks.end())};\n+}\n+\n StringVec RandMemberStrSet(const DbContext& db_context, const CompactObj& co,\n-                           PicksGenerator& generator, std::size_t picks_count) {\n+                           PicksGenerator& generator, size_t picks_count) {\n   CHECK(IsDenseEncoding(co));\n+  StringSetWrapper strset{co, db_context};\n+\n+  // If the set is small, extract entries with StringSet::GetRandomMember\n+  if (picks_count * 5 < strset->UpperBoundSize()) {\n+    StringSet* ss(strset);\n+    if (bool unique = (dynamic_cast<UniquePicksGenerator*>(&generator) != nullptr); unique)\n+      return RandMemberStrSetPicky(ss, picks_count);\n+    else\n+      return RandMemberStrSetPicky<StringVec>(ss, picks_count);\n+  }\n \n   std::unordered_map<RandomPick, std::uint32_t> times_index_is_picked;\n   for (std::size_t i = 0; i < picks_count; i++) {\n@@ -278,7 +306,7 @@ StringVec RandMemberStrSet(const DbContext& db_context, const CompactObj& co,\n   result.reserve(picks_count);\n \n   std::uint32_t ss_entry_index = 0;\n-  for (string_view str : StringSetWrapper{co, db_context}.Range()) {\n+  for (string_view str : strset.Range()) {\n     auto it = times_index_is_picked.find(ss_entry_index++);\n     if (it != times_index_is_picked.end()) {\n       while (it->second--)\n",
  "test_patch": "diff --git a/src/server/set_family_test.cc b/src/server/set_family_test.cc\nindex 7dfa00b15d13..5820f72c5a76 100644\n--- a/src/server/set_family_test.cc\n+++ b/src/server/set_family_test.cc\n@@ -180,6 +180,21 @@ TEST_F(SetFamilyTest, SPop) {\n   resp = Run({\"smembers\", \"y\"});\n   ASSERT_THAT(resp, ArrLen(2));\n   EXPECT_THAT(resp.GetVec(), IsSubsetOf({\"a\", \"b\", \"c\"}));\n+\n+  // Test POP on large set with small pop count\n+  vector<string> xlarge{\"sadd\", \"xlarge\"};\n+  for (size_t i = 0; i < 100; i++)\n+    xlarge.push_back(to_string(i));\n+  Run(absl::MakeSpan(xlarge));\n+\n+  resp = Run({\"spop\", \"xlarge\", \"2\"});\n+  {\n+    auto elems = resp.GetVec();\n+    EXPECT_NE(elems[0].GetString(), elems[1].GetString());\n+  }\n+\n+  resp = Run({\"scard\", \"xlarge\"});\n+  EXPECT_THAT(resp, IntArg(98));\n }\n \n TEST_F(SetFamilyTest, SRandMember) {\n",
  "problem_statement": "SPOP is extremely slow for huge sets\nTo reproduce: ./dragonfly --proactor_threads=1\n1. add 1000000 items to a set `foo`\n2. run `redis-cli SPOP foo 5` in a loop and see how dragonfly saturates its CPU\n\nThe reason: we uniformly select 5 indices in [0, 1M] and then use an `O(N)` iteration to advance over the whole set to select 5 items. \n\nIt's not possible to fix this without the cooperation from dense_set interface\nWhat we need to do is a different (additional) strategy when `count` is much smaller than the set size.\nSay when `count * 3 < set size`.\n\nIn that case we would want to call 5 times  `DenseSet::GetRandomIterator`  which should provide a random dereferenceable place in O(1).  We do not have such a function but it's easy to implement one.\nDenseSet is an array of linked lists so we could choose a random index [0, N] and then call Advance to reach a busy place. \n\n",
  "hints_text": "",
  "created_at": "2025-07-13T12:01:05Z",
  "modified_files": [
    "src/core/CMakeLists.txt",
    "src/core/dense_set.cc",
    "src/core/dense_set.h",
    "src/core/string_set.cc",
    "src/core/string_set.h",
    "src/server/set_family.cc"
  ],
  "modified_test_files": [
    "src/server/set_family_test.cc"
  ]
}