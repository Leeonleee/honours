{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4504,
  "instance_id": "dragonflydb__dragonfly-4504",
  "issue_numbers": [
    "3884"
  ],
  "base_commit": "d945b831dbb26035e58890ab9788d375d3b76933",
  "patch": "diff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex ea800eff1b6a..33858c0f8618 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -69,6 +69,7 @@ using namespace std;\n using namespace facade;\n using absl::GetFlag;\n using time_point = Transaction::time_point;\n+using absl::SimpleAtoi;\n \n namespace {\n \n@@ -1173,8 +1174,159 @@ void BPopGeneric(ListDir dir, CmdArgList args, Transaction* tx, SinkReplyBuilder\n   return rb->SendNullArray();\n }\n \n+struct LMPopParams {\n+  uint32_t num_keys;\n+  ListDir dir;\n+  int pop_count;\n+};\n+\n+facade::ErrorReply ParseLMPop(CmdArgList args, LMPopParams* params) {\n+  CmdArgParser parser{args};\n+\n+  if (!SimpleAtoi(parser.Next(), &params->num_keys)) {\n+    return facade::ErrorReply(kUintErr);\n+  }\n+\n+  if (params->num_keys <= 0 || !parser.HasAtLeast(params->num_keys + 1)) {\n+    return facade::ErrorReply(kSyntaxErr);\n+  }\n+\n+  parser.Skip(params->num_keys);\n+\n+  if (parser.Check(\"LEFT\")) {\n+    params->dir = ListDir::LEFT;\n+  } else if (parser.Check(\"RIGHT\")) {\n+    params->dir = ListDir::RIGHT;\n+  } else {\n+    return facade::ErrorReply(kSyntaxErr);\n+  }\n+\n+  params->pop_count = 1;\n+  if (parser.HasNext()) {\n+    if (!parser.Check(\"COUNT\", &params->pop_count)) {\n+      return facade::ErrorReply(kSyntaxErr);\n+    }\n+  }\n+\n+  if (!parser.Finalize()) {\n+    return facade::ErrorReply(parser.Error()->MakeReply());\n+  }\n+\n+  return facade::ErrorReply(OpStatus::OK);\n+}\n+\n+// Returns the first non-empty key found in the shard arguments along with its type validity.\n+// Returns a pair of (key, is_valid_type) where is_valid_type is true if the key exists\n+// and has the correct type (LIST). If a wrong type is found, returns that key with false.\n+// Returns nullopt if no suitable key is found.\n+optional<pair<string_view, bool>> GetFirstNonEmptyKeyFound(EngineShard* shard, Transaction* t) {\n+  ShardArgs keys = t->GetShardArgs(shard->shard_id());\n+  DCHECK(!keys.Empty());\n+\n+  auto& db_slice = t->GetDbSlice(shard->shard_id());\n+  optional<pair<string_view, bool>> result;\n+\n+  for (string_view key : keys) {\n+    auto res = db_slice.FindReadOnly(t->GetDbContext(), key, OBJ_LIST);\n+    if (res) {\n+      result = {key, true};\n+      break;\n+    }\n+\n+    // If the key is not found, check if it's a wrong type error\n+    if (res.status() == OpStatus::WRONG_TYPE) {\n+      result = {key, false};\n+      break;\n+    }\n+  }\n+\n+  return result;\n+}\n+\n }  // namespace\n \n+void ListFamily::LMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n+  auto* response_builder = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n+\n+  LMPopParams params;\n+  facade::ErrorReply parse_result = ParseLMPop(args, &params);\n+\n+  if (parse_result.status != OpStatus::OK) {\n+    response_builder->SendError(parse_result);\n+    return;\n+  }\n+\n+  // Create a vector to store first found key for each shard\n+  vector<optional<pair<string_view, bool>>> found_keys_per_shard(shard_set->size());\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    // Each shard writes results to its own space\n+    found_keys_per_shard[shard->shard_id()] = GetFirstNonEmptyKeyFound(shard, t);\n+    return OpStatus::OK;\n+  };\n+\n+  cmd_cntx.tx->Execute(std::move(cb), false /* followed by another hop */);\n+\n+  // Find the first existing key from command arguments\n+  optional<string_view> key_to_pop;\n+  bool found_wrong_type = false;\n+  size_t min_index = numeric_limits<size_t>::max();\n+\n+  // Iterate over each shard to find the key with the smallest index\n+  for (ShardId sid = 0; sid < found_keys_per_shard.size(); ++sid) {\n+    if (!found_keys_per_shard[sid])\n+      continue;\n+\n+    const auto& [found_key, is_valid_type] = *found_keys_per_shard[sid];\n+    ShardArgs shard_args = cmd_cntx.tx->GetShardArgs(sid);\n+\n+    for (auto it = shard_args.begin(); it != shard_args.end(); ++it) {\n+      if (found_key == *it && it.index() < min_index) {\n+        min_index = it.index();\n+        key_to_pop = found_key;\n+        found_wrong_type = !is_valid_type;\n+        break;\n+      }\n+    }\n+  }\n+\n+  // Handle errors and empty cases first\n+  if (!key_to_pop || found_wrong_type) {\n+    cmd_cntx.tx->Conclude();\n+    if (found_wrong_type) {\n+      response_builder->SendError(kWrongTypeErr);\n+    } else {\n+      response_builder->SendNull();\n+    }\n+    return;\n+  }\n+\n+  // Pop values from the found key\n+  optional<ShardId> key_shard = Shard(*key_to_pop, shard_set->size());\n+  OpResult<StringVec> result;\n+\n+  auto cb_pop = [&params, key_shard, &result, key = *key_to_pop](Transaction* t,\n+                                                                 EngineShard* shard) {\n+    if (*key_shard == shard->shard_id()) {\n+      result = OpPop(t->GetOpArgs(shard), key, params.dir, params.pop_count, true, false);\n+    }\n+    return OpStatus::OK;\n+  };\n+\n+  cmd_cntx.tx->Execute(std::move(cb_pop), true);\n+\n+  if (result) {\n+    response_builder->StartArray(2);\n+    response_builder->SendBulkString(*key_to_pop);\n+    response_builder->StartArray(result->size());\n+    for (const auto& val : *result) {\n+      response_builder->SendBulkString(val);\n+    }\n+  } else {\n+    response_builder->SendNull();\n+  }\n+}\n+\n void ListFamily::LPush(CmdArgList args, const CommandContext& cmd_cntx) {\n   return PushGeneric(ListDir::LEFT, false, std::move(args), cmd_cntx.tx, cmd_cntx.rb);\n }\n@@ -1442,6 +1594,7 @@ namespace acl {\n constexpr uint32_t kLPush = WRITE | LIST | FAST;\n constexpr uint32_t kLPushX = WRITE | LIST | FAST;\n constexpr uint32_t kLPop = WRITE | LIST | FAST;\n+constexpr uint32_t kLMPop = WRITE | LIST | FAST;\n constexpr uint32_t kRPush = WRITE | LIST | FAST;\n constexpr uint32_t kRPushX = WRITE | LIST | FAST;\n constexpr uint32_t kRPop = WRITE | LIST | FAST;\n@@ -1467,6 +1620,7 @@ void ListFamily::Register(CommandRegistry* registry) {\n       << CI{\"LPUSH\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kLPush}.HFUNC(LPush)\n       << CI{\"LPUSHX\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kLPushX}.HFUNC(LPushX)\n       << CI{\"LPOP\", CO::WRITE | CO::FAST, -2, 1, 1, acl::kLPop}.HFUNC(LPop)\n+      << CI{\"LMPOP\", CO::WRITE | CO::SLOW | CO::VARIADIC_KEYS, -4, 2, 2, acl::kLMPop}.HFUNC(LMPop)\n       << CI{\"RPUSH\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kRPush}.HFUNC(RPush)\n       << CI{\"RPUSHX\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kRPushX}.HFUNC(RPushX)\n       << CI{\"RPOP\", CO::WRITE | CO::FAST, -2, 1, 1, acl::kRPop}.HFUNC(RPop)\ndiff --git a/src/server/list_family.h b/src/server/list_family.h\nindex 73518a438816..0b5155264727 100644\n--- a/src/server/list_family.h\n+++ b/src/server/list_family.h\n@@ -33,6 +33,7 @@ class ListFamily {\n   static void RPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void BLPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void BRPop(CmdArgList args, const CommandContext& cmd_cntx);\n+  static void LMPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LLen(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LPos(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LIndex(CmdArgList args, const CommandContext& cmd_cntx);\n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex e53384804a77..787a98446176 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -1086,5 +1086,226 @@ TEST_F(ListFamilyTest, ContendExpire) {\n   }\n }\n \n+TEST_F(ListFamilyTest, LMPopInvalidSyntax) {\n+  // Not enough arguments\n+  auto resp = Run({\"lmpop\", \"1\", \"a\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  // Zero keys\n+  resp = Run({\"lmpop\", \"0\", \"LEFT\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Number of keys is not uint\n+  resp = Run({\"lmpop\", \"aa\", \"a\", \"LEFT\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Missing LEFT/RIGHT\n+  resp = Run({\"lmpop\", \"1\", \"a\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Wrong number of keys\n+  resp = Run({\"lmpop\", \"1\", \"a\", \"b\", \"LEFT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // COUNT without number\n+  resp = Run({\"lmpop\", \"1\", \"a\", \"LEFT\", \"COUNT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // COUNT is not uint\n+  resp = Run({\"lmpop\", \"1\", \"a\", \"LEFT\", \"COUNT\", \"boo\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Too many arguments\n+  resp = Run({\"lmpop\", \"1\", \"c\", \"LEFT\", \"COUNT\", \"2\", \"foo\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+}\n+\n+TEST_F(ListFamilyTest, LMPop) {\n+  // All lists are empty\n+  auto resp = Run({\"lmpop\", \"1\", \"e\", \"LEFT\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  // LEFT operation\n+  resp = Run({\"lpush\", \"a\", \"a1\", \"a2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"lmpop\", \"1\", \"a\", \"LEFT\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"a\", RespArray(ElementsAre(\"a2\")))));\n+\n+  // RIGHT operation\n+  resp = Run({\"lpush\", \"b\", \"b1\", \"b2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"lmpop\", \"1\", \"b\", \"RIGHT\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"b\", RespArray(ElementsAre(\"b1\")))));\n+\n+  // COUNT > 1\n+  resp = Run({\"lpush\", \"c\", \"c1\", \"c2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"lmpop\", \"1\", \"c\", \"RIGHT\", \"COUNT\", \"2\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"c\", RespArray(ElementsAre(\"c1\", \"c2\")))));\n+\n+  resp = Run({\"llen\", \"c\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // COUNT > number of elements in list\n+  resp = Run({\"lpush\", \"d\", \"d1\", \"d2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"lmpop\", \"1\", \"d\", \"RIGHT\", \"COUNT\", \"3\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"d\", RespArray(ElementsAre(\"d1\", \"d2\")))));\n+\n+  resp = Run({\"llen\", \"d\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // First non-empty list is not the first list\n+  resp = Run({\"lpush\", \"x\", \"x1\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"lpush\", \"y\", \"y1\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"lmpop\", \"3\", \"empty\", \"x\", \"y\", \"RIGHT\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"x\", RespArray(ElementsAre(\"x1\")))));\n+\n+  resp = Run({\"llen\", \"x\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+}\n+\n+TEST_F(ListFamilyTest, LMPopMultipleElements) {\n+  // Test removing multiple elements from left end\n+  Run({\"rpush\", \"list1\", \"a\", \"b\", \"c\", \"d\", \"e\"});\n+  auto resp = Run({\"lmpop\", \"1\", \"list1\", \"LEFT\", \"COUNT\", \"3\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"list1\", RespArray(ElementsAre(\"a\", \"b\", \"c\")))));\n+\n+  resp = Run({\"lrange\", \"list1\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"d\", \"e\"));\n+\n+  // Test removing multiple elements from right end\n+  Run({\"rpush\", \"list2\", \"v\", \"w\", \"x\", \"y\", \"z\"});\n+  resp = Run({\"lmpop\", \"1\", \"list2\", \"RIGHT\", \"COUNT\", \"2\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"list2\", RespArray(ElementsAre(\"z\", \"y\")))));\n+\n+  resp = Run({\"lrange\", \"list2\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"v\", \"w\", \"x\"));\n+}\n+\n+TEST_F(ListFamilyTest, LMPopMultipleLists) {\n+  // Test finding first non-empty list\n+  Run({\"rpush\", \"list1\", \"a\", \"b\"});\n+  Run({\"rpush\", \"list2\", \"c\", \"d\"});\n+  Run({\"rpush\", \"list3\", \"e\", \"f\"});\n+\n+  // Pop from first non-empty list\n+  auto resp = Run({\"lmpop\", \"3\", \"list1\", \"list2\", \"list3\", \"LEFT\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"list1\", RespArray(ElementsAre(\"a\")))));\n+\n+  // Pop from second list after first becomes empty\n+  Run({\"lmpop\", \"1\", \"list1\", \"LEFT\"});  // Empty list1\n+  resp = Run({\"lmpop\", \"3\", \"list1\", \"list2\", \"list3\", \"RIGHT\", \"COUNT\", \"2\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"list2\", RespArray(ElementsAre(\"d\", \"c\")))));\n+\n+  // Verify third list remains untouched\n+  resp = Run({\"lrange\", \"list3\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"e\", \"f\"));\n+}\n+\n+TEST_F(ListFamilyTest, LMPopEdgeCases) {\n+  // Test with empty list\n+  Run({\"rpush\", \"empty_list\", \"a\"});\n+  Run({\"lpop\", \"empty_list\"});\n+  auto resp = Run({\"lmpop\", \"1\", \"empty_list\", \"LEFT\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  // Test with non-existent list\n+  resp = Run({\"lmpop\", \"1\", \"nonexistent\", \"LEFT\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  // Test with wrong type key\n+  Run({\"set\", \"string_key\", \"value\"});\n+  resp = Run({\"lmpop\", \"1\", \"string_key\", \"LEFT\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n+\n+  // Test without COUNT parameter - should return 1 element by default\n+  Run({\"rpush\", \"list\", \"a\", \"b\"});\n+  resp = Run({\"lmpop\", \"1\", \"list\", \"LEFT\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\n+                  \"list\", RespArray(ElementsAre(\"a\")))));  // Should return 1 element by default\n+\n+  // Test with COUNT = 0 - should return error\n+  resp = Run({\"lmpop\", \"1\", \"list\", \"LEFT\", \"COUNT\", \"0\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"list\", RespArray(ElementsAre()))));\n+\n+  // Test with negative COUNT - should return error\n+  resp = Run({\"lmpop\", \"1\", \"list\", \"LEFT\", \"COUNT\", \"-1\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"list\", RespArray(ElementsAre(\"b\")))));\n+}\n+\n+TEST_F(ListFamilyTest, LMPopDocExample) {\n+  // Try to pop from non-existing lists\n+  auto resp = Run({\"LMPOP\", \"2\", \"non1\", \"non2\", \"LEFT\", \"COUNT\", \"10\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  // Create first list and test basic pop\n+  resp = Run({\"LPUSH\", \"mylist\", \"one\", \"two\", \"three\", \"four\", \"five\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"LMPOP\", \"1\", \"mylist\", \"LEFT\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"mylist\", RespArray(ElementsAre(\"five\")))));\n+\n+  resp = Run({\"LRANGE\", \"mylist\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"four\", \"three\", \"two\", \"one\"));\n+\n+  // Test RIGHT pop with COUNT\n+  resp = Run({\"LMPOP\", \"1\", \"mylist\", \"RIGHT\", \"COUNT\", \"10\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"mylist\",\n+                                          RespArray(ElementsAre(\"one\", \"two\", \"three\", \"four\")))));\n+\n+  // Create two lists and test multi-key pop\n+  resp = Run({\"LPUSH\", \"mylist\", \"one\", \"two\", \"three\", \"four\", \"five\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"LPUSH\", \"mylist2\", \"a\", \"b\", \"c\", \"d\", \"e\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"LMPOP\", \"2\", \"mylist\", \"mylist2\", \"RIGHT\", \"COUNT\", \"3\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\"mylist\", RespArray(ElementsAre(\"one\", \"two\", \"three\")))));\n+\n+  resp = Run({\"LRANGE\", \"mylist\", \"0\", \"-1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"five\", \"four\"));\n+\n+  resp = Run({\"LMPOP\", \"2\", \"mylist\", \"mylist2\", \"RIGHT\", \"COUNT\", \"5\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"mylist\", RespArray(ElementsAre(\"four\", \"five\")))));\n+\n+  resp = Run({\"LMPOP\", \"2\", \"mylist\", \"mylist2\", \"RIGHT\", \"COUNT\", \"10\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\"mylist2\", RespArray(ElementsAre(\"a\", \"b\", \"c\", \"d\", \"e\")))));\n+\n+  // Verify both lists are now empty\n+  resp = Run({\"EXISTS\", \"mylist\", \"mylist2\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+}\n+\n+TEST_F(ListFamilyTest, LMPopWrongType) {\n+  // Setup: create a list and a hash\n+  Run({\"lpush\", \"l1\", \"e1\"});\n+  Run({\"hset\", \"foo\", \"k1\", \"v1\"});\n+\n+  // Test: first key is wrong type\n+  auto resp = Run({\"lmpop\", \"2\", \"foo\", \"l1\", \"left\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n+\n+  // Test: second key is wrong type but first doesn't exist\n+  resp = Run({\"lmpop\", \"2\", \"nonexistent\", \"foo\", \"left\"});\n+  EXPECT_THAT(resp, ErrArg(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n+\n+  // Test: second key is wrong type but first is a valid list\n+  resp = Run({\"lmpop\", \"2\", \"l1\", \"foo\", \"left\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"l1\", RespArray(ElementsAre(\"e1\")))));\n+}\n+\n #pragma GCC diagnostic pop\n }  // namespace dfly\n",
  "problem_statement": "implement LMPOP\nSee here: \r\nhttps://valkey.io/commands/lmpop/ \r\n\r\nfor more details\n",
  "hints_text": "Hi, \r\nCould anyone please provide discription of this issue?\n> Hi, Could anyone please provide discription of this issue?\r\n\r\nDone.\nHi, \r\nI have a few queries about the `LMPOP` implementation:\r\n1. In which file or module should I add the new `LMPOP` command?\r\n2. Is there any specific design pattern or guideline I should follow when implementing this command?\r\n3. Should I also add test cases in the current testing framework?\r\n\r\nThanks for your guidance!\r\n\nHi @SalmanDeveloperz , you can checkout LPOP implemantion in list_family.cc, add the LMPOP command to this file and add unit tests in list_family_test.cc\nThanks for the guidance! I\u2019d like to take on the implementation of the `LMPOP` command as discussed. Could you please assign this issue to me?\r\nBest Regards,\nHello @SalmanDeveloperz  we do not assign issues to external contributors. Feel free to just send a PR and link it to this issue.\nHi, I've implemented the LMPOP command functionality in list_family.cc and added unit tests in list_family_test.cc. You can review the changes in my pull request: [Add LMPOP command implementation and unit tests]\r\n\r\nPlease let me know if you need any further modifications or if there's anything else I can assist with!\r\nThanks",
  "created_at": "2025-01-25T11:50:38Z",
  "modified_files": [
    "src/server/list_family.cc",
    "src/server/list_family.h"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc"
  ]
}