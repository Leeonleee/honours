{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 865,
  "instance_id": "dragonflydb__dragonfly-865",
  "issue_numbers": [
    "852"
  ],
  "base_commit": "e52b0f42c3b544fa77d4be3f416722fdcb6255e3",
  "patch": "diff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex a11222b0d393..8edcb516deea 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -38,6 +38,8 @@ using JsonReplaceCb = function<void(const string&, JsonType&)>;\n using JsonReplaceVerify = std::function<OpStatus()>;\n using CI = CommandId;\n \n+static const char DefaultJsonPath[] = \"$\";\n+\n namespace {\n \n inline OpStatus JsonReplaceVerifyNoOp() {\n@@ -1004,7 +1006,10 @@ void JsonFamily::Set(CmdArgList args, ConnectionContext* cntx) {\n \n void JsonFamily::Resp(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n-  string_view path = ArgS(args, 2);\n+  string_view path = DefaultJsonPath;\n+  if (args.size() > 2) {\n+    path = ArgS(args, 2);\n+  }\n \n   error_code ec;\n   JsonExpression expression = jsonpath::make_expression<JsonType>(path, ec);\n@@ -1661,7 +1666,7 @@ void JsonFamily::Register(CommandRegistry* registry) {\n       ArrAppend);\n   *registry << CI{\"JSON.ARRINDEX\", CO::READONLY | CO::FAST, -4, 1, 1, 1}.HFUNC(ArrIndex);\n   *registry << CI{\"JSON.DEBUG\", CO::READONLY | CO::FAST, -2, 1, 1, 1}.HFUNC(Debug);\n-  *registry << CI{\"JSON.RESP\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(Resp);\n+  *registry << CI{\"JSON.RESP\", CO::READONLY | CO::FAST, -2, 1, 1, 1}.HFUNC(Resp);\n   *registry << CI{\"JSON.SET\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1}.HFUNC(Set);\n }\n \n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex 9fb2734d54a8..a26b07ca382d 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -899,6 +899,9 @@ TEST_F(JsonFamilyTest, Resp) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", PhonebookJson});\n   ASSERT_THAT(resp, \"OK\");\n \n+  resp = Run({\"JSON.RESP\", \"json\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+\n   resp = Run({\"JSON.RESP\", \"json\", \"$.address.*\"});\n   ASSERT_EQ(RespExpr::ARRAY, resp.type);\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"New York\", \"NY\", \"21 2nd Street\", \"10021-3100\"));\n",
  "problem_statement": "JSON.RESP path arg should be optional \nJSON.SET item:2 $ '{\"name\":\"Wireless earbuds\",\"description\":\"Wireless Bluetooth in-ear headphones\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":64.99,\"stock\":17,\"colors\":[\"black\",\"white\"], \"max_level\":[80, 100, 120]}'\r\n\r\nJSON.RESP item:2 \r\nyields\r\n(error) ERR wrong number of arguments for 'json.resp' command\r\n\r\nshould behave like JSON.RESP item:2 $\n",
  "hints_text": "I'm pretty sure that you can open the same bug on each JSON command, the path is required.\n@iko1  why are you saying this? \r\nhttps://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/json-resp.html  says that path is optional.\nIndeed, in the official documentation of both Json implementations, the path is optional.\r\nWhat I'm saying is if you set the path argument to be optional and set the default value of the path to the root on one JSON command in the projects' JSON implementation, I recommend doing the same change in each Json command, to be aligned with the other JSON implementations.\nGot ya!",
  "created_at": "2023-02-21T22:37:29Z",
  "modified_files": [
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}