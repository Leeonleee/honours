diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt
index e649f6401f7e..b2f2a5f7b60a 100644
--- a/src/server/CMakeLists.txt
+++ b/src/server/CMakeLists.txt
@@ -59,7 +59,7 @@ add_library(dragonfly_lib bloom_family.cc engine_shard_set.cc
             cluster/cluster_config.cc cluster/cluster_family.cc cluster/incoming_slot_migration.cc
             cluster/outgoing_slot_migration.cc cluster/cluster_defs.cc
             acl/user.cc acl/user_registry.cc acl/acl_family.cc
-            acl/validator.cc acl/helpers.cc)
+            acl/validator.cc)
 
 if (DF_ENABLE_MEMORY_TRACKING)
   target_compile_definitions(dragonfly_lib PRIVATE DFLY_ENABLE_MEMORY_TRACKING)
diff --git a/src/server/acl/acl_commands_def.h b/src/server/acl/acl_commands_def.h
index c53eb1cb60eb..99b8257c7591 100644
--- a/src/server/acl/acl_commands_def.h
+++ b/src/server/acl/acl_commands_def.h
@@ -47,108 +47,21 @@ enum AclCat {
   JSON = 1ULL << 31
 };
 
-// See definitions for NONE and ALL in facade/acl_commands_def.h
-
-inline const absl::flat_hash_map<std::string_view, uint32_t> CATEGORY_INDEX_TABLE{
-    {"KEYSPACE", KEYSPACE},
-    {"READ", READ},
-    {"WRITE", WRITE},
-    {"SET", SET},
-    {"SORTEDSET", SORTEDSET},
-    {"LIST", LIST},
-    {"HASH", HASH},
-    {"STRING", STRING},
-    {"BITMAP", BITMAP},
-    {"HYPERLOG", HYPERLOGLOG},
-    {"GEO", GEO},
-    {"STREAM", STREAM},
-    {"PUBSUB", PUBSUB},
-    {"ADMIN", ADMIN},
-    {"FAST", FAST},
-    {"SLOW", SLOW},
-    {"BLOCKING", BLOCKING},
-    {"DANGEROUS", DANGEROUS},
-    {"CONNECTION", CONNECTION},
-    {"TRANSACTION", TRANSACTION},
-    {"SCRIPTING", SCRIPTING},
-    {"BLOOM", BLOOM},
-    {"FT_SEARCH", FT_SEARCH},
-    {"THROTTLE", THROTTLE},
-    {"JSON", JSON},
-    {"ALL", ALL},
-    {"NONE", NONE}};
-
-// bit 0 at index 0
-// bit 1 at index 1
-// bit n at index n
-inline const std::vector<std::string> REVERSE_CATEGORY_INDEX_TABLE{
-    "KEYSPACE",  "READ",      "WRITE",     "SET",       "SORTEDSET",  "LIST",        "HASH",
-    "STRING",    "BITMAP",    "HYPERLOG",  "GEO",       "STREAM",     "PUBSUB",      "ADMIN",
-    "FAST",      "SLOW",      "BLOCKING",  "DANGEROUS", "CONNECTION", "TRANSACTION", "SCRIPTING",
-    "_RESERVED", "_RESERVED", "_RESERVED", "_RESERVED", "_RESERVED",  "_RESERVED",   "_RESERVED",
-    "BLOOM",     "FT_SEARCH", "THROTTLE",  "JSON"};
-
-// bit index to index in the REVERSE_CATEGORY_INDEX_TABLE
-using CategoryToIdxStore = absl::flat_hash_map<uint32_t, uint32_t>;
-
-inline const CategoryToIdxStore& CategoryToIdx(CategoryToIdxStore store = {}) {
-  static CategoryToIdxStore cat_idx = std::move(store);
-  return cat_idx;
-}
-
-using RevCommandField = std::vector<std::string>;
-using RevCommandsIndexStore = std::vector<RevCommandField>;
-
 constexpr uint64_t ALL_COMMANDS = std::numeric_limits<uint64_t>::max();
 constexpr uint64_t NONE_COMMANDS = std::numeric_limits<uint64_t>::min();
 
-// A variation of meyers singleton
-// This is initialized when the constructor of Service is called.
-// Basically, it calls this functions within the AclFamily::Register
-// functions which has the number of all the acl families registered
 inline size_t NumberOfFamilies(size_t number = 0) {
   static size_t number_of_families = number;
   return number_of_families;
 }
 
-inline const RevCommandsIndexStore& CommandsRevIndexer(RevCommandsIndexStore store = {}) {
-  static RevCommandsIndexStore rev_index_store = std::move(store);
-  return rev_index_store;
-}
+using CategoryIndexTable = absl::flat_hash_map<std::string_view, uint32_t>;
+using ReverseCategoryIndexTable = std::vector<std::string>;
+// bit index to index in the REVERSE_CATEGORY_INDEX_TABLE
+using CategoryToIdxStore = absl::flat_hash_map<uint32_t, uint32_t>;
 
+using RevCommandField = std::vector<std::string>;
+using RevCommandsIndexStore = std::vector<RevCommandField>;
 using CategoryToCommandsIndexStore = absl::flat_hash_map<std::string, std::vector<uint64_t>>;
 
-inline const CategoryToCommandsIndexStore& CategoryToCommandsIndex(
-    CategoryToCommandsIndexStore store = {}) {
-  static CategoryToCommandsIndexStore index = std::move(store);
-  return index;
-}
-
-inline void BuildIndexers(RevCommandsIndexStore families, CommandRegistry* cmd_registry) {
-  acl::NumberOfFamilies(families.size());
-  acl::CommandsRevIndexer(std::move(families));
-  CategoryToCommandsIndexStore index;
-  cmd_registry->Traverse([&](std::string_view name, auto& cid) {
-    auto cat = cid.acl_categories();
-    for (size_t i = 0; i < 32; ++i) {
-      if (cat & (1 << i)) {
-        std::string_view cat_name = REVERSE_CATEGORY_INDEX_TABLE[i];
-        if (index[cat_name].empty()) {
-          index[cat_name].resize(CommandsRevIndexer().size());
-        }
-        auto family = cid.GetFamily();
-        auto bit_index = cid.GetBitIndex();
-        index[cat_name][family] |= bit_index;
-      }
-    }
-  });
-
-  CategoryToCommandsIndex(std::move(index));
-  CategoryToIdxStore idx_store;
-  for (size_t i = 0; i < 32; ++i) {
-    idx_store[1 << i] = i;
-  }
-  CategoryToIdx(std::move(idx_store));
-}
-
 }  // namespace dfly::acl
diff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc
index d7b18fe0b359..fc7b00a18d62 100644
--- a/src/server/acl/acl_family.cc
+++ b/src/server/acl/acl_family.cc
@@ -3,8 +3,6 @@
 
 #include "server/acl/acl_family.h"
 
-#include <glog/logging.h>
-
 #include <algorithm>
 #include <cctype>
 #include <chrono>
@@ -20,10 +18,11 @@
 
 #include "absl/container/flat_hash_set.h"
 #include "absl/flags/commandlineflag.h"
+#include "absl/strings/escaping.h"
 #include "absl/strings/match.h"
 #include "absl/strings/numbers.h"
 #include "absl/strings/str_cat.h"
-#include "absl/types/span.h"
+#include "absl/strings/str_split.h"
 #include "base/flags.h"
 #include "base/logging.h"
 #include "core/overloaded.h"
@@ -31,10 +30,8 @@
 #include "facade/facade_types.h"
 #include "io/file.h"
 #include "io/file_util.h"
-#include "io/io.h"
 #include "server/acl/acl_commands_def.h"
 #include "server/acl/acl_log.h"
-#include "server/acl/helpers.h"
 #include "server/acl/validator.h"
 #include "server/command_registry.h"
 #include "server/common.h"
@@ -48,6 +45,18 @@ ABSL_FLAG(std::string, aclfile, "", "Path and name to aclfile");
 
 namespace dfly::acl {
 
+namespace {
+
+std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,
+                              bool full_sha);
+using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;
+
+MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,
+                                             std::string_view file_contents);
+
+std::string AclKeysToString(const AclKeys& keys);
+}  // namespace
+
 AclFamily::AclFamily(UserRegistry* registry, util::ProactorPool* pool)
     : registry_(registry), pool_(pool) {
 }
@@ -107,7 +116,7 @@ void AclFamily::SetUser(CmdArgList args, ConnectionContext* cntx) {
   const bool exists = reg.registry.contains(username);
   const bool has_all_keys = exists ? reg.registry.find(username)->second.Keys().all_keys : false;
 
-  auto req = ParseAclSetUser(args.subspan(1), *cmd_registry_, false, has_all_keys);
+  auto req = ParseAclSetUser(args.subspan(1), false, has_all_keys);
 
   auto error_case = [cntx](ErrorReply&& error) { cntx->SendError(error); };
 
@@ -116,9 +125,10 @@ void AclFamily::SetUser(CmdArgList args, ConnectionContext* cntx) {
     if (!exists) {
       User::UpdateRequest default_req;
       default_req.updates = {User::UpdateRequest::CategoryValueType{User::Sign::MINUS, acl::ALL}};
-      user.Update(std::move(default_req));
+      user.Update(std::move(default_req), CategoryToIdx(), reverse_cat_table_,
+                  CategoryToCommandsIndex());
     }
-    user.Update(std::move(req));
+    user.Update(std::move(req), CategoryToIdx(), reverse_cat_table_, CategoryToCommandsIndex());
     if (exists) {
       StreamUpdatesToAllProactorConnections(std::string(username), user.AclCommands(), user.Keys());
     }
@@ -278,7 +288,7 @@ GenericError AclFamily::LoadToRegistryFromFile(std::string_view full_path,
   std::vector<User::UpdateRequest> requests;
 
   for (auto& cmds : *materialized) {
-    auto req = ParseAclSetUser(cmds, *cmd_registry_, true);
+    auto req = ParseAclSetUser(cmds, true);
     if (std::holds_alternative<ErrorReply>(req)) {
       auto error = std::move(std::get<ErrorReply>(req));
       LOG(WARNING) << "Error while parsing aclfile: " << error.ToSv();
@@ -300,13 +310,16 @@ GenericError AclFamily::LoadToRegistryFromFile(std::string_view full_path,
     User::UpdateRequest default_req;
     default_req.updates = {User::UpdateRequest::CategoryValueType{User::Sign::MINUS, acl::ALL}};
     auto& user = registry[usernames[i]];
-    user.Update(std::move(default_req));
-    user.Update(std::move(requests[i]));
+    user.Update(std::move(default_req), CategoryToIdx(), reverse_cat_table_,
+                CategoryToCommandsIndex());
+    user.Update(std::move(requests[i]), CategoryToIdx(), reverse_cat_table_,
+                CategoryToCommandsIndex());
   }
 
   if (!registry.contains("default")) {
     auto& user = registry["default"];
-    user.Update(registry_->DefaultUserUpdateRequest());
+    user.Update(registry_->DefaultUserUpdateRequest(), CategoryToIdx(), reverse_cat_table_,
+                CategoryToCommandsIndex());
   }
 
   return {};
@@ -440,13 +453,13 @@ void AclFamily::Cat(CmdArgList args, ConnectionContext* cntx) {
   if (args.size() == 1) {
     ToUpper(&args[0]);
     std::string_view category = facade::ToSV(args[0]);
-    if (!CATEGORY_INDEX_TABLE.contains(category)) {
+    if (!cat_table_.contains(category)) {
       auto error = absl::StrCat("Unkown category: ", category);
       cntx->SendError(error);
       return;
     }
 
-    const uint32_t cid_mask = CATEGORY_INDEX_TABLE.find(category)->second;
+    const uint32_t cid_mask = cat_table_.find(category)->second;
     std::vector<std::string_view> results;
     // TODO replace this with indexer
     auto cb = [cid_mask, &results](auto name, auto& cid) {
@@ -466,7 +479,7 @@ void AclFamily::Cat(CmdArgList args, ConnectionContext* cntx) {
   }
 
   size_t total_categories = 0;
-  for (auto& elem : REVERSE_CATEGORY_INDEX_TABLE) {
+  for (auto& elem : reverse_cat_table_) {
     if (elem != "_RESERVED") {
       ++total_categories;
     }
@@ -474,7 +487,7 @@ void AclFamily::Cat(CmdArgList args, ConnectionContext* cntx) {
 
   auto* rb = static_cast<facade::RedisReplyBuilder*>(cntx->reply_builder());
   rb->StartArray(total_categories);
-  for (auto& elem : REVERSE_CATEGORY_INDEX_TABLE) {
+  for (auto& elem : reverse_cat_table_) {
     if (elem != "_RESERVED") {
       rb->SendSimpleString(elem);
     }
@@ -638,6 +651,9 @@ void AclFamily::Register(dfly::CommandRegistry* registry) {
   *registry << CI{"ACL GENPASS", CO::NOSCRIPT | CO::LOADING, -1, 0, 0, acl::kGenPass}.HFUNC(
       GenPass);
   cmd_registry_ = registry;
+
+  // build indexers
+  BuildIndexers(cmd_registry_->GetFamilies());
 }
 
 #undef HFUNC
@@ -655,7 +671,7 @@ void AclFamily::Init(facade::Listener* main_listener, UserRegistry* registry) {
   if (!acl_file.empty() && Load()) {
     return;
   }
-  registry_->Init();
+  registry_->Init(&CategoryToIdx(), &reverse_cat_table_, &CategoryToCommandsIndex());
   config_registry.RegisterMutable("aclfile");
   config_registry.RegisterMutable("acllog_max_len", [this](const absl::CommandLineFlag& flag) {
     auto res = flag.TryGet<size_t>();
@@ -668,4 +684,381 @@ void AclFamily::Init(facade::Listener* main_listener, UserRegistry* registry) {
   });
 }
 
+std::string AclFamily::AclCatToString(uint32_t acl_category, User::Sign sign) const {
+  std::string res = sign == User::Sign::PLUS ? "+@" : "-@";
+  if (acl_category == acl::ALL) {
+    absl::StrAppend(&res, "all");
+    return res;
+  }
+
+  const auto& index = CategoryToIdx().at(acl_category);
+  absl::StrAppend(&res, absl::AsciiStrToLower(reverse_cat_table_[index]));
+  return res;
+}
+
+std::string AclFamily::AclCommandToString(size_t family, uint64_t mask, User::Sign sign) const {
+  // This is constant but can be optimized with an indexer
+  const auto& rev_index = CommandsRevIndexer();
+  std::string res;
+  std::string prefix = (sign == User::Sign::PLUS) ? "+" : "-";
+  if (mask == ALL_COMMANDS) {
+    for (const auto& cmd : rev_index[family]) {
+      absl::StrAppend(&res, prefix, absl::AsciiStrToLower(cmd), " ");
+    }
+    res.pop_back();
+    return res;
+  }
+
+  size_t pos = 0;
+  while (mask != 0) {
+    ++pos;
+    mask = mask >> 1;
+  }
+  --pos;
+  absl::StrAppend(&res, prefix, absl::AsciiStrToLower(rev_index[family][pos]));
+  return res;
+}
+
+namespace {
+struct CategoryAndMetadata {
+  User::CategoryChange change;
+  User::ChangeMetadata metadata;
+};
+
+struct CommandAndMetadata {
+  User::CommandChange change;
+  User::ChangeMetadata metadata;
+};
+
+using MergeResult = std::vector<std::variant<CategoryAndMetadata, CommandAndMetadata>>;
+
+MergeResult MergeTables(const User::CategoryChanges& categories,
+                        const User::CommandChanges& commands) {
+  MergeResult result;
+  for (auto [cat, meta] : categories) {
+    result.push_back(CategoryAndMetadata{cat, meta});
+  }
+
+  for (auto [cmd, meta] : commands) {
+    result.push_back(CommandAndMetadata{cmd, meta});
+  }
+
+  std::sort(result.begin(), result.end(), [](const auto& l, const auto& r) {
+    auto fetch = [](const auto& l) { return l.metadata.seq_no; };
+    return std::visit(fetch, l) < std::visit(fetch, r);
+  });
+
+  return result;
+}
+
+using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;
+
+MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,
+                                             std::string_view file_contents) {
+  // This is fine, a very large file will top at 1-2 mb. And that's for 5000+ users with 400
+  // characters per line
+  std::vector<std::string_view> commands = absl::StrSplit(file_contents, "
");
+  std::vector<std::vector<std::string_view>> materialized;
+  materialized.reserve(commands.size());
+  usernames->reserve(commands.size());
+  for (auto& command : commands) {
+    if (command.empty())
+      continue;
+    std::vector<std::string_view> cmds = absl::StrSplit(command, ' ');
+    if (!absl::EqualsIgnoreCase(cmds[0], "USER") || cmds.size() < 4) {
+      return {};
+    }
+
+    usernames->push_back(std::string(cmds[1]));
+    cmds.erase(cmds.begin(), cmds.begin() + 2);
+    materialized.push_back(cmds);
+  }
+  return materialized;
+}
+
+struct ParseKeyResult {
+  std::string glob;
+  KeyOp op;
+  bool all_keys{false};
+  bool reset_keys{false};
+};
+
+std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command) {
+  if (absl::EqualsIgnoreCase(command, "ALLKEYS") || command == "~*") {
+    return ParseKeyResult{"", {}, true};
+  }
+
+  if (absl::EqualsIgnoreCase(command, "RESETKEYS")) {
+    return ParseKeyResult{"", {}, false, true};
+  }
+
+  auto op = KeyOp::READ_WRITE;
+
+  if (absl::StartsWith(command, "%RW")) {
+    command = command.substr(3);
+  } else if (absl::StartsWith(command, "%R")) {
+    op = KeyOp::READ;
+    command = command.substr(2);
+  } else if (absl::StartsWith(command, "%W")) {
+    op = KeyOp::WRITE;
+    command = command.substr(2);
+  }
+
+  if (!absl::StartsWith(command, "~")) {
+    return {};
+  }
+
+  auto key = command.substr(1);
+  if (key.empty()) {
+    return {};
+  }
+  return ParseKeyResult{std::string(key), op};
+}
+
+std::string PrettyPrintSha(std::string_view pass, bool all) {
+  if (all) {
+    return absl::BytesToHexString(pass);
+  }
+  return absl::BytesToHexString(pass.substr(0, 15)).substr(0, 15);
+};
+
+std::optional<User::UpdatePass> MaybeParsePassword(std::string_view command, bool hashed) {
+  using UpPass = User::UpdatePass;
+  if (command == "nopass") {
+    return UpPass{"", false, true};
+  }
+
+  if (command == "resetpass") {
+    return UpPass{"", false, false, true};
+  }
+
+  if (command[0] == '>' || (hashed && command[0] == '#')) {
+    return UpPass{std::string(command.substr(1))};
+  }
+
+  if (command[0] == '<') {
+    return UpPass{std::string(command.substr(1)), true};
+  }
+
+  return {};
+}
+
+std::optional<bool> MaybeParseStatus(std::string_view command) {
+  if (command == "ON") {
+    return true;
+  }
+  if (command == "OFF") {
+    return false;
+  }
+  return {};
+}
+
+std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,
+                              bool full_sha) {
+  if (nopass) {
+    return "nopass ";
+  }
+  std::string result;
+  for (const auto& pass : passwords) {
+    absl::StrAppend(&result, "#", PrettyPrintSha(pass, full_sha), " ");
+  }
+
+  return result;
+}
+
+std::string AclKeysToString(const AclKeys& keys) {
+  if (keys.all_keys) {
+    return "~*";
+  }
+  std::string result;
+  for (auto& [pattern, op] : keys.key_globs) {
+    if (op == KeyOp::READ_WRITE) {
+      absl::StrAppend(&result, "~", pattern, " ");
+      continue;
+    }
+    std::string op_str = (op == KeyOp::READ) ? "R" : "W";
+    absl::StrAppend(&result, "%", op_str, "~", pattern, " ");
+  }
+
+  if (!result.empty()) {
+    result.pop_back();
+  }
+  return result;
+}
+
+}  // namespace
+
+std::string AclFamily::AclCatAndCommandToString(const User::CategoryChanges& cat,
+                                                const User::CommandChanges& cmds) const {
+  std::string result;
+
+  auto tables = MergeTables(cat, cmds);
+
+  auto cat_visitor = [&result, this](const CategoryAndMetadata& val) {
+    const auto& [change, meta] = val;
+    absl::StrAppend(&result, AclCatToString(change, meta.sign), " ");
+  };
+
+  auto cmd_visitor = [&result, this](const CommandAndMetadata& val) {
+    const auto& [change, meta] = val;
+    const auto [family, bit_index] = change;
+    absl::StrAppend(&result, AclCommandToString(family, bit_index, meta.sign), " ");
+  };
+
+  Overloaded visitor{cat_visitor, cmd_visitor};
+
+  for (auto change : tables) {
+    std::visit(visitor, change);
+  }
+
+  if (!result.empty()) {
+    result.pop_back();
+  }
+
+  return result;
+}
+
+using OptCat = std::optional<uint32_t>;
+
+// bool == true if +
+// bool == false if -
+std::pair<OptCat, bool> AclFamily::MaybeParseAclCategory(std::string_view command) const {
+  if (absl::StartsWith(command, "+@")) {
+    auto res = cat_table_.find(command.substr(2));
+    if (res == cat_table_.end()) {
+      return {};
+    }
+    return {res->second, true};
+  }
+
+  if (absl::StartsWith(command, "-@")) {
+    auto res = cat_table_.find(command.substr(2));
+    if (res == cat_table_.end()) {
+      return {};
+    }
+    return {res->second, false};
+  }
+
+  return {};
+}
+
+std::pair<AclFamily::OptCommand, bool> AclFamily::MaybeParseAclCommand(
+    std::string_view command) const {
+  if (absl::StartsWith(command, "+")) {
+    auto res = cmd_registry_->Find(command.substr(1));
+    if (!res) {
+      return {};
+    }
+    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};
+    return {cmd, true};
+  }
+
+  if (absl::StartsWith(command, "-")) {
+    auto res = cmd_registry_->Find(command.substr(1));
+    if (!res) {
+      return {};
+    }
+    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};
+    return {cmd, false};
+  }
+
+  return {};
+}
+
+using facade::ErrorReply;
+
+std::variant<User::UpdateRequest, ErrorReply> AclFamily::ParseAclSetUser(
+    const facade::ArgRange& args, bool hashed, bool has_all_keys) const {
+  User::UpdateRequest req;
+
+  for (std::string_view arg : args) {
+    if (auto pass = MaybeParsePassword(facade::ToSV(arg), hashed); pass) {
+      req.passwords.push_back(std::move(*pass));
+
+      if (hashed && absl::StartsWith(facade::ToSV(arg), "#")) {
+        req.passwords.back().is_hashed = true;
+      }
+      continue;
+    }
+
+    if (auto res = MaybeParseAclKey(facade::ToSV(arg)); res) {
+      auto& [glob, op, all_keys, reset_keys] = *res;
+      if ((has_all_keys && !all_keys && !reset_keys) ||
+          (req.allow_all_keys && !all_keys && !reset_keys)) {
+        return ErrorReply(
+            "Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * pattern (or the "
+            "'allkeys' flag) is not valid and does not have any effect. Try 'resetkeys' to start "
+            "with an empty list of patterns");
+      }
+
+      req.allow_all_keys = all_keys;
+      req.reset_all_keys = reset_keys;
+      if (reset_keys) {
+        has_all_keys = false;
+      }
+      req.keys.push_back({std::move(glob), op, all_keys, reset_keys});
+      continue;
+    }
+
+    std::string command = absl::AsciiStrToUpper(arg);
+
+    if (auto status = MaybeParseStatus(command); status) {
+      if (req.is_active) {
+        return ErrorReply("Multiple ON/OFF are not allowed");
+      }
+      req.is_active = *status;
+      continue;
+    }
+
+    auto [cat, add] = MaybeParseAclCategory(command);
+    if (cat) {
+      using Sign = User::Sign;
+      using Val = std::pair<Sign, uint32_t>;
+      auto val = add ? Val{Sign::PLUS, *cat} : Val{Sign::MINUS, *cat};
+      req.updates.push_back(val);
+      continue;
+    }
+
+    auto [cmd, sign] = MaybeParseAclCommand(command);
+    if (!cmd) {
+      return ErrorReply(absl::StrCat("Unrecognized parameter ", command));
+    }
+
+    using Sign = User::Sign;
+    using Val = User::UpdateRequest::CommandsValueType;
+    auto [index, bit] = *cmd;
+    auto val = sign ? Val{Sign::PLUS, index, bit} : Val{Sign::MINUS, index, bit};
+    req.updates.push_back(val);
+  }
+
+  return req;
+}
+
+void AclFamily::BuildIndexers(RevCommandsIndexStore families) {
+  acl::NumberOfFamilies(families.size());
+  CommandsRevIndexer(std::move(families));
+  CategoryToCommandsIndexStore index;
+  cmd_registry_->Traverse([&](std::string_view name, auto& cid) {
+    auto cat = cid.acl_categories();
+    for (size_t i = 0; i < 32; ++i) {
+      if (cat & (1 << i)) {
+        std::string_view cat_name = reverse_cat_table_[i];
+        if (index[cat_name].empty()) {
+          index[cat_name].resize(CommandsRevIndexer().size());
+        }
+        auto family = cid.GetFamily();
+        auto bit_index = cid.GetBitIndex();
+        index[cat_name][family] |= bit_index;
+      }
+    }
+  });
+
+  CategoryToCommandsIndex(std::move(index));
+  CategoryToIdxStore idx_store;
+  for (size_t i = 0; i < 32; ++i) {
+    idx_store[1 << i] = i;
+  }
+  CategoryToIdx(std::move(idx_store));
+}
+
 }  // namespace dfly::acl
diff --git a/src/server/acl/acl_family.h b/src/server/acl/acl_family.h
index 61439f36d62f..143e29f02d82 100644
--- a/src/server/acl/acl_family.h
+++ b/src/server/acl/acl_family.h
@@ -13,6 +13,7 @@
 #include "facade/dragonfly_listener.h"
 #include "facade/facade_types.h"
 #include "helio/util/proactor_pool.h"
+#include "server/acl/acl_commands_def.h"
 #include "server/acl/user_registry.h"
 #include "server/command_registry.h"
 #include "server/common.h"
@@ -62,12 +63,107 @@ class AclFamily final {
   // Helper function that loads the acl state of an acl file into the user registry
   GenericError LoadToRegistryFromFile(std::string_view full_path, ConnectionContext* init);
 
+  // Serializes the whole registry into a string
   std::string RegistryToString() const;
 
+  std::string AclCatToString(uint32_t acl_category, User::Sign sign) const;
+
+  std::string AclCommandToString(size_t family, uint64_t mask, User::Sign sign) const;
+
+  // Serializes category and command to string
+  std::string AclCatAndCommandToString(const User::CategoryChanges& cat,
+                                       const User::CommandChanges& cmds) const;
+
+  using OptCat = std::optional<uint32_t>;
+  std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command) const;
+
+  using OptCommand = std::optional<std::pair<size_t, uint64_t>>;
+  std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command) const;
+
+  std::variant<User::UpdateRequest, facade::ErrorReply> ParseAclSetUser(
+      const facade::ArgRange& args, bool hashed = false, bool has_all_keys = false) const;
+
+  void BuildIndexers(RevCommandsIndexStore families);
+
+  // Data members
+
   facade::Listener* main_listener_{nullptr};
   UserRegistry* registry_;
   CommandRegistry* cmd_registry_;
   util::ProactorPool* pool_;
+
+  // Indexes
+
+  // See definitions for NONE and ALL in facade/acl_commands_def.h
+  const CategoryIndexTable cat_table_{{"KEYSPACE", KEYSPACE},
+                                      {"READ", READ},
+                                      {"WRITE", WRITE},
+                                      {"SET", SET},
+                                      {"SORTEDSET", SORTEDSET},
+                                      {"LIST", LIST},
+                                      {"HASH", HASH},
+                                      {"STRING", STRING},
+                                      {"BITMAP", BITMAP},
+                                      {"HYPERLOG", HYPERLOGLOG},
+                                      {"GEO", GEO},
+                                      {"STREAM", STREAM},
+                                      {"PUBSUB", PUBSUB},
+                                      {"ADMIN", ADMIN},
+                                      {"FAST", FAST},
+                                      {"SLOW", SLOW},
+                                      {"BLOCKING", BLOCKING},
+                                      {"DANGEROUS", DANGEROUS},
+                                      {"CONNECTION", CONNECTION},
+                                      {"TRANSACTION", TRANSACTION},
+                                      {"SCRIPTING", SCRIPTING},
+                                      {"BLOOM", BLOOM},
+                                      {"FT_SEARCH", FT_SEARCH},
+                                      {"THROTTLE", THROTTLE},
+                                      {"JSON", JSON},
+                                      {"ALL", ALL},
+                                      {"NONE", NONE}};
+
+  // bit 0 at index 0
+  // bit 1 at index 1
+  // bit n at index n
+  const ReverseCategoryIndexTable reverse_cat_table_{
+      "KEYSPACE",  "READ",      "WRITE",     "SET",       "SORTEDSET",  "LIST",        "HASH",
+      "STRING",    "BITMAP",    "HYPERLOG",  "GEO",       "STREAM",     "PUBSUB",      "ADMIN",
+      "FAST",      "SLOW",      "BLOCKING",  "DANGEROUS", "CONNECTION", "TRANSACTION", "SCRIPTING",
+      "_RESERVED", "_RESERVED", "_RESERVED", "_RESERVED", "_RESERVED",  "_RESERVED",   "_RESERVED",
+      "BLOOM",     "FT_SEARCH", "THROTTLE",  "JSON"};
+
+  // We need this to act as a const member, since the initialization of const data members
+  // must be done on the constructor. However, these are initialized a little later, when
+  // we Register the commands
+  const CategoryToIdxStore& CategoryToIdx(CategoryToIdxStore store = {}) const {
+    static CategoryToIdxStore cat_idx = std::move(store);
+    return cat_idx;
+  }
+
+  const RevCommandsIndexStore& CommandsRevIndexer(RevCommandsIndexStore store = {}) const {
+    static RevCommandsIndexStore rev_index_store = std::move(store);
+    return rev_index_store;
+  }
+
+  const CategoryToCommandsIndexStore& CategoryToCommandsIndex(
+      CategoryToCommandsIndexStore store = {}) const {
+    static CategoryToCommandsIndexStore index = std::move(store);
+    return index;
+  }
+
+  // Only for testing interface
+ public:
+  // Helper accessors for tests. Do not use them directly.
+  const ReverseCategoryIndexTable& GetRevTable() const {
+    return reverse_cat_table_;
+  }
+
+  // We could make CommandsRevIndexer public, but I want this to be
+  // clear that this is for TESTING so do not use this in the codebase
+  const RevCommandsIndexStore& GetCommandsRevIndexer() const {
+    return CommandsRevIndexer();
+  }
 };
 
 }  // namespace acl
diff --git a/src/server/acl/helpers.cc b/src/server/acl/helpers.cc
deleted file mode 100644
index 2471b11bf715..000000000000
--- a/src/server/acl/helpers.cc
+++ /dev/null
@@ -1,368 +0,0 @@
-// Copyright 2022, DragonflyDB authors.  All rights reserved.
-// See LICENSE for licensing terms.
-//
-
-#include "server/acl/helpers.h"
-
-#include <limits>
-#include <vector>
-
-#include "absl/strings/ascii.h"
-#include "absl/strings/escaping.h"
-#include "absl/strings/match.h"
-#include "absl/strings/str_cat.h"
-#include "absl/strings/str_split.h"
-#include "core/overloaded.h"
-#include "facade/acl_commands_def.h"
-#include "server/acl/acl_commands_def.h"
-#include "server/acl/user.h"
-#include "server/common.h"
-
-namespace dfly::acl {
-
-namespace {
-
-std::string AclCatToString(uint32_t acl_category, User::Sign sign) {
-  std::string res = sign == User::Sign::PLUS ? "+@" : "-@";
-  if (acl_category == acl::ALL) {
-    absl::StrAppend(&res, "all");
-    return res;
-  }
-
-  const auto& index = CategoryToIdx().at(acl_category);
-  absl::StrAppend(&res, absl::AsciiStrToLower(REVERSE_CATEGORY_INDEX_TABLE[index]));
-  return res;
-}
-
-std::string AclCommandToString(size_t family, uint64_t mask, User::Sign sign) {
-  // This is constant but can be optimized with an indexer
-  const auto& rev_index = CommandsRevIndexer();
-  std::string res;
-  std::string prefix = (sign == User::Sign::PLUS) ? "+" : "-";
-  if (mask == ALL_COMMANDS) {
-    for (const auto& cmd : rev_index[family]) {
-      absl::StrAppend(&res, prefix, absl::AsciiStrToLower(cmd), " ");
-    }
-    res.pop_back();
-    return res;
-  }
-
-  size_t pos = 0;
-  while (mask != 0) {
-    ++pos;
-    mask = mask >> 1;
-  }
-  --pos;
-  absl::StrAppend(&res, prefix, absl::AsciiStrToLower(rev_index[family][pos]));
-  return res;
-}
-
-struct CategoryAndMetadata {
-  User::CategoryChange change;
-  User::ChangeMetadata metadata;
-};
-
-struct CommandAndMetadata {
-  User::CommandChange change;
-  User::ChangeMetadata metadata;
-};
-
-using MergeResult = std::vector<std::variant<CategoryAndMetadata, CommandAndMetadata>>;
-
-}  // namespace
-
-// Merge Category and Command changes and sort them by global order seq_no
-MergeResult MergeTables(const User::CategoryChanges& categories,
-                        const User::CommandChanges& commands) {
-  MergeResult result;
-  for (auto [cat, meta] : categories) {
-    result.push_back(CategoryAndMetadata{cat, meta});
-  }
-
-  for (auto [cmd, meta] : commands) {
-    result.push_back(CommandAndMetadata{cmd, meta});
-  }
-
-  std::sort(result.begin(), result.end(), [](const auto& l, const auto& r) {
-    auto fetch = [](const auto& l) { return l.metadata.seq_no; };
-    return std::visit(fetch, l) < std::visit(fetch, r);
-  });
-
-  return result;
-}
-
-std::string AclCatAndCommandToString(const User::CategoryChanges& cat,
-                                     const User::CommandChanges& cmds) {
-  std::string result;
-
-  auto tables = MergeTables(cat, cmds);
-
-  auto cat_visitor = [&result](const CategoryAndMetadata& val) {
-    const auto& [change, meta] = val;
-    absl::StrAppend(&result, AclCatToString(change, meta.sign), " ");
-  };
-
-  auto cmd_visitor = [&result](const CommandAndMetadata& val) {
-    const auto& [change, meta] = val;
-    const auto [family, bit_index] = change;
-    absl::StrAppend(&result, AclCommandToString(family, bit_index, meta.sign), " ");
-  };
-
-  Overloaded visitor{cat_visitor, cmd_visitor};
-
-  for (auto change : tables) {
-    std::visit(visitor, change);
-  }
-
-  if (!result.empty()) {
-    result.pop_back();
-  }
-
-  return result;
-}
-
-std::string PrettyPrintSha(std::string_view pass, bool all) {
-  if (all) {
-    return absl::BytesToHexString(pass);
-  }
-  return absl::BytesToHexString(pass.substr(0, 15)).substr(0, 15);
-};
-
-std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command) {
-  if (absl::EqualsIgnoreCase(command, "ALLKEYS") || command == "~*") {
-    return ParseKeyResult{"", {}, true};
-  }
-
-  if (absl::EqualsIgnoreCase(command, "RESETKEYS")) {
-    return ParseKeyResult{"", {}, false, true};
-  }
-
-  auto op = KeyOp::READ_WRITE;
-
-  if (absl::StartsWith(command, "%RW")) {
-    command = command.substr(3);
-  } else if (absl::StartsWith(command, "%R")) {
-    op = KeyOp::READ;
-    command = command.substr(2);
-  } else if (absl::StartsWith(command, "%W")) {
-    op = KeyOp::WRITE;
-    command = command.substr(2);
-  }
-
-  if (!absl::StartsWith(command, "~")) {
-    return {};
-  }
-
-  auto key = command.substr(1);
-  if (key.empty()) {
-    return {};
-  }
-  return ParseKeyResult{std::string(key), op};
-}
-
-std::optional<User::UpdatePass> MaybeParsePassword(std::string_view command, bool hashed) {
-  using UpPass = User::UpdatePass;
-  if (command == "nopass") {
-    return UpPass{"", false, true};
-  }
-
-  if (command == "resetpass") {
-    return UpPass{"", false, false, true};
-  }
-
-  if (command[0] == '>' || (hashed && command[0] == '#')) {
-    return UpPass{std::string(command.substr(1))};
-  }
-
-  if (command[0] == '<') {
-    return UpPass{std::string(command.substr(1)), true};
-  }
-
-  return {};
-}
-
-std::optional<bool> MaybeParseStatus(std::string_view command) {
-  if (command == "ON") {
-    return true;
-  }
-  if (command == "OFF") {
-    return false;
-  }
-  return {};
-}
-
-using OptCat = std::optional<uint32_t>;
-
-// bool == true if +
-// bool == false if -
-std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command) {
-  if (absl::StartsWith(command, "+@")) {
-    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));
-    if (res == CATEGORY_INDEX_TABLE.end()) {
-      return {};
-    }
-    return {res->second, true};
-  }
-
-  if (absl::StartsWith(command, "-@")) {
-    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));
-    if (res == CATEGORY_INDEX_TABLE.end()) {
-      return {};
-    }
-    return {res->second, false};
-  }
-
-  return {};
-}
-
-std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command,
-                                                 const CommandRegistry& registry) {
-  if (absl::StartsWith(command, "+")) {
-    auto res = registry.Find(command.substr(1));
-    if (!res) {
-      return {};
-    }
-    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};
-    return {cmd, true};
-  }
-
-  if (absl::StartsWith(command, "-")) {
-    auto res = registry.Find(command.substr(1));
-    if (!res) {
-      return {};
-    }
-    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};
-    return {cmd, false};
-  }
-
-  return {};
-}
-
-MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,
-                                             std::string_view file_contents) {
-  // This is fine, a very large file will top at 1-2 mb. And that's for 5000+ users with 400
-  // characters per line
-  std::vector<std::string_view> commands = absl::StrSplit(file_contents, "
");
-  std::vector<std::vector<std::string_view>> materialized;
-  materialized.reserve(commands.size());
-  usernames->reserve(commands.size());
-  for (auto& command : commands) {
-    if (command.empty())
-      continue;
-    std::vector<std::string_view> cmds = absl::StrSplit(command, ' ');
-    if (!absl::EqualsIgnoreCase(cmds[0], "USER") || cmds.size() < 4) {
-      return {};
-    }
-
-    usernames->push_back(std::string(cmds[1]));
-    cmds.erase(cmds.begin(), cmds.begin() + 2);
-    materialized.push_back(cmds);
-  }
-  return materialized;
-}
-
-using facade::ErrorReply;
-
-std::variant<User::UpdateRequest, ErrorReply> ParseAclSetUser(facade::ArgRange args,
-                                                              const CommandRegistry& registry,
-                                                              bool hashed, bool has_all_keys) {
-  User::UpdateRequest req;
-
-  for (std::string_view arg : args) {
-    if (auto pass = MaybeParsePassword(facade::ToSV(arg), hashed); pass) {
-      req.passwords.push_back(std::move(*pass));
-
-      if (hashed && absl::StartsWith(facade::ToSV(arg), "#")) {
-        req.passwords.back().is_hashed = true;
-      }
-      continue;
-    }
-
-    if (auto res = MaybeParseAclKey(facade::ToSV(arg)); res) {
-      auto& [glob, op, all_keys, reset_keys] = *res;
-      if ((has_all_keys && !all_keys && !reset_keys) ||
-          (req.allow_all_keys && !all_keys && !reset_keys)) {
-        return ErrorReply(
-            "Error in ACL SETUSER modifier '~tmp': Adding a pattern after the * pattern (or the "
-            "'allkeys' flag) is not valid and does not have any effect. Try 'resetkeys' to start "
-            "with an empty list of patterns");
-      }
-
-      req.allow_all_keys = all_keys;
-      req.reset_all_keys = reset_keys;
-      if (reset_keys) {
-        has_all_keys = false;
-      }
-      req.keys.push_back({std::move(glob), op, all_keys, reset_keys});
-      continue;
-    }
-
-    std::string command = absl::AsciiStrToUpper(arg);
-
-    if (auto status = MaybeParseStatus(command); status) {
-      if (req.is_active) {
-        return ErrorReply("Multiple ON/OFF are not allowed");
-      }
-      req.is_active = *status;
-      continue;
-    }
-
-    auto [cat, add] = MaybeParseAclCategory(command);
-    if (cat) {
-      using Sign = User::Sign;
-      using Val = std::pair<Sign, uint32_t>;
-      auto val = add ? Val{Sign::PLUS, *cat} : Val{Sign::MINUS, *cat};
-      req.updates.push_back(val);
-      continue;
-    }
-
-    auto [cmd, sign] = MaybeParseAclCommand(command, registry);
-    if (!cmd) {
-      return ErrorReply(absl::StrCat("Unrecognized parameter ", command));
-    }
-
-    using Sign = User::Sign;
-    using Val = User::UpdateRequest::CommandsValueType;
-    auto [index, bit] = *cmd;
-    auto val = sign ? Val{Sign::PLUS, index, bit} : Val{Sign::MINUS, index, bit};
-    req.updates.push_back(val);
-  }
-
-  return req;
-}
-
-using facade::CmdArgList;
-
-std::string AclKeysToString(const AclKeys& keys) {
-  if (keys.all_keys) {
-    return "~*";
-  }
-  std::string result;
-  for (auto& [pattern, op] : keys.key_globs) {
-    if (op == KeyOp::READ_WRITE) {
-      absl::StrAppend(&result, "~", pattern, " ");
-      continue;
-    }
-    std::string op_str = (op == KeyOp::READ) ? "R" : "W";
-    absl::StrAppend(&result, "%", op_str, "~", pattern, " ");
-  }
-
-  if (!result.empty()) {
-    result.pop_back();
-  }
-  return result;
-}
-
-std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,
-                              bool full_sha) {
-  if (nopass) {
-    return "nopass ";
-  }
-  std::string result;
-  for (const auto& pass : passwords) {
-    absl::StrAppend(&result, "#", PrettyPrintSha(pass, full_sha), " ");
-  }
-
-  return result;
-}
-}  // namespace dfly::acl
diff --git a/src/server/acl/helpers.h b/src/server/acl/helpers.h
deleted file mode 100644
index 75cbd4d8b491..000000000000
--- a/src/server/acl/helpers.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright 2022, DragonflyDB authors.  All rights reserved.
-// See LICENSE for licensing terms.
-//
-
-#pragma once
-
-#include <cstdint>
-#include <optional>
-#include <string>
-#include <string_view>
-#include <variant>
-
-#include "absl/container/flat_hash_set.h"
-#include "facade/facade_types.h"
-#include "server/acl/acl_log.h"
-#include "server/acl/user.h"
-#include "server/command_registry.h"
-
-namespace dfly::acl {
-
-std::string AclCatAndCommandToString(const User::CategoryChanges& cat,
-                                     const User::CommandChanges& cmds);
-
-std::string PrettyPrintSha(std::string_view pass, bool all = false);
-
-// When hashed is true, we allow passwords that start with both # and >
-std::optional<User::UpdatePass> MaybeParsePassword(std::string_view command, bool hashed = false);
-
-std::optional<bool> MaybeParseStatus(std::string_view command);
-
-using OptCat = std::optional<uint32_t>;
-std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command);
-
-bool IsIndexAllCommandsFlag(size_t index);
-
-using OptCommand = std::optional<std::pair<size_t, uint64_t>>;
-std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command,
-                                                 const CommandRegistry& registry);
-
-std::variant<User::UpdateRequest, facade::ErrorReply> ParseAclSetUser(
-    facade::ArgRange args, const CommandRegistry& registry, bool hashed = false,
-    bool has_all_keys = false);
-
-using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;
-
-MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,
-                                             std::string_view file_contents);
-
-struct ParseKeyResult {
-  std::string glob;
-  KeyOp op;
-  bool all_keys{false};
-  bool reset_keys{false};
-};
-
-std::optional<ParseKeyResult> MaybeParseAclKey(std::string_view command);
-
-std::string AclKeysToString(const AclKeys& keys);
-
-std::string PasswordsToString(const absl::flat_hash_set<std::string>& passwords, bool nopass,
-                              bool full_sha);
-
-}  // namespace dfly::acl
diff --git a/src/server/acl/user.cc b/src/server/acl/user.cc
index 37ae93432fc6..fa59c7a25278 100644
--- a/src/server/acl/user.cc
+++ b/src/server/acl/user.cc
@@ -11,7 +11,6 @@
 #include "absl/container/flat_hash_set.h"
 #include "absl/strings/escaping.h"
 #include "core/overloaded.h"
-#include "server/acl/helpers.h"
 
 namespace dfly::acl {
 
@@ -30,7 +29,9 @@ User::User() {
   commands_ = std::vector<uint64_t>(NumberOfFamilies(), 0);
 }
 
-void User::Update(UpdateRequest&& req) {
+void User::Update(UpdateRequest&& req, const CategoryToIdxStore& cat_to_id,
+                  const ReverseCategoryIndexTable& reverse_cat,
+                  const CategoryToCommandsIndexStore& cat_to_commands) {
   for (auto& pass : req.passwords) {
     if (pass.nopass) {
       SetNopass();
@@ -47,13 +48,13 @@ void User::Update(UpdateRequest&& req) {
     SetPasswordHash(pass.password, pass.is_hashed);
   }
 
-  auto cat_visitor = [this](UpdateRequest::CategoryValueType cat) {
+  auto cat_visitor = [&, this](UpdateRequest::CategoryValueType cat) {
     auto [sign, category] = cat;
     if (sign == Sign::PLUS) {
-      SetAclCategoriesAndIncrSeq(category);
+      SetAclCategoriesAndIncrSeq(category, cat_to_id, reverse_cat, cat_to_commands);
       return;
     }
-    UnsetAclCategoriesAndIncrSeq(category);
+    UnsetAclCategoriesAndIncrSeq(category, cat_to_id, reverse_cat, cat_to_commands);
   };
 
   auto cmd_visitor = [this](UpdateRequest::CommandsValueType cmd) {
@@ -100,14 +101,16 @@ bool User::HasPassword(std::string_view password) const {
   return password_hashes_.contains(StringSHA256(password));
 }
 
-void User::SetAclCategoriesAndIncrSeq(uint32_t cat) {
+void User::SetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,
+                                      const ReverseCategoryIndexTable& reverse_cat,
+                                      const CategoryToCommandsIndexStore& cat_to_commands) {
   acl_categories_ |= cat;
   if (cat == acl::ALL) {
     SetAclCommands(std::numeric_limits<size_t>::max(), 0);
   } else {
-    auto id = CategoryToIdx().at(cat);
-    std::string_view name = REVERSE_CATEGORY_INDEX_TABLE[id];
-    const auto& commands_group = CategoryToCommandsIndex().at(name);
+    auto id = cat_to_id.at(cat);
+    std::string_view name = reverse_cat[id];
+    const auto& commands_group = cat_to_commands.at(name);
     for (size_t fam_id = 0; fam_id < commands_group.size(); ++fam_id) {
       SetAclCommands(fam_id, commands_group[fam_id]);
     }
@@ -117,14 +120,16 @@ void User::SetAclCategoriesAndIncrSeq(uint32_t cat) {
   cat_changes_[change] = ChangeMetadata{Sign::PLUS, seq_++};
 }
 
-void User::UnsetAclCategoriesAndIncrSeq(uint32_t cat) {
+void User::UnsetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,
+                                        const ReverseCategoryIndexTable& reverse_cat,
+                                        const CategoryToCommandsIndexStore& cat_to_commands) {
   acl_categories_ ^= cat;
   if (cat == acl::ALL) {
     UnsetAclCommands(std::numeric_limits<size_t>::max(), 0);
   } else {
-    auto id = CategoryToIdx().at(cat);
-    std::string_view name = REVERSE_CATEGORY_INDEX_TABLE[id];
-    const auto& commands_group = CategoryToCommandsIndex().at(name);
+    auto id = cat_to_id.at(cat);
+    std::string_view name = reverse_cat[id];
+    const auto& commands_group = cat_to_commands.at(name);
     for (size_t fam_id = 0; fam_id < commands_group.size(); ++fam_id) {
       UnsetAclCommands(fam_id, commands_group[fam_id]);
     }
diff --git a/src/server/acl/user.h b/src/server/acl/user.h
index 0aafdb59994b..d8e44029394f 100644
--- a/src/server/acl/user.h
+++ b/src/server/acl/user.h
@@ -81,7 +81,9 @@ class User final {
   User(User&&) = default;
 
   // For single step updates
-  void Update(UpdateRequest&& req);
+  void Update(UpdateRequest&& req, const CategoryToIdxStore& cat_to_id,
+              const ReverseCategoryIndexTable& reverse_cat,
+              const CategoryToCommandsIndexStore& cat_to_commands);
 
   bool HasPassword(std::string_view password) const;
 
@@ -110,8 +112,12 @@ class User final {
   const CommandChanges& CmdChanges() const;
 
  private:
-  void SetAclCategoriesAndIncrSeq(uint32_t cat);
-  void UnsetAclCategoriesAndIncrSeq(uint32_t cat);
+  void SetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,
+                                  const ReverseCategoryIndexTable& reverse_cat,
+                                  const CategoryToCommandsIndexStore& cat_to_commands);
+  void UnsetAclCategoriesAndIncrSeq(uint32_t cat, const CategoryToIdxStore& cat_to_id,
+                                    const ReverseCategoryIndexTable& reverse_cat,
+                                    const CategoryToCommandsIndexStore& cat_to_commands);
 
   // For ACL commands
   void SetAclCommands(size_t index, uint64_t bit_index);
diff --git a/src/server/acl/user_registry.cc b/src/server/acl/user_registry.cc
index 9bd9645bff6c..ae252ea3ad91 100644
--- a/src/server/acl/user_registry.cc
+++ b/src/server/acl/user_registry.cc
@@ -21,7 +21,7 @@ namespace dfly::acl {
 void UserRegistry::MaybeAddAndUpdate(std::string_view username, User::UpdateRequest req) {
   std::unique_lock<fb2::SharedMutex> lock(mu_);
   auto& user = registry_[username];
-  user.Update(std::move(req));
+  user.Update(std::move(req), *cat_to_id_table_, *reverse_cat_table_, *cat_to_commands_table_);
 }
 
 bool UserRegistry::RemoveUser(std::string_view username) {
@@ -79,11 +79,16 @@ User::UpdateRequest UserRegistry::DefaultUserUpdateRequest() const {
   return {std::move(pass), true, false, {std::move(acl)}, {std::move(key)}};
 }
 
-void UserRegistry::Init() {
+void UserRegistry::Init(const CategoryToIdxStore* cat_to_id_table,
+                        const ReverseCategoryIndexTable* reverse_cat_table,
+                        const CategoryToCommandsIndexStore* cat_to_commands_table) {
   // if there exists an acl file to load from, requirepass
   // will not overwrite the default's user password loaded from
   // that file. Loading the default's user password from a file
   // has higher priority than the deprecated flag
+  cat_to_id_table_ = cat_to_id_table;
+  reverse_cat_table_ = reverse_cat_table;
+  cat_to_commands_table_ = cat_to_commands_table;
   auto default_user = DefaultUserUpdateRequest();
   auto maybe_password = absl::GetFlag(FLAGS_requirepass);
   if (!maybe_password.empty()) {
diff --git a/src/server/acl/user_registry.h b/src/server/acl/user_registry.h
index fef3fefd8622..034d288228f8 100644
--- a/src/server/acl/user_registry.h
+++ b/src/server/acl/user_registry.h
@@ -12,6 +12,7 @@
 #include <utility>
 #include <vector>
 
+#include "server/acl/acl_commands_def.h"
 #include "server/acl/user.h"
 #include "util/fibers/synchronization.h"
 
@@ -27,7 +28,9 @@ class UserRegistry {
   UserRegistry(const UserRegistry&) = delete;
   UserRegistry(UserRegistry&&) = delete;
 
-  void Init();
+  void Init(const CategoryToIdxStore* cat_to_id_table,
+            const ReverseCategoryIndexTable* reverse_cat_table,
+            const CategoryToCommandsIndexStore* cat_to_commands_table);
 
   using RegistryType = absl::flat_hash_map<std::string, User>;
 
@@ -88,6 +91,10 @@ class UserRegistry {
    private:
     LockT<util::fb2::SharedMutex> registry_lk_;
   };
+
+  const CategoryToIdxStore* cat_to_id_table_;
+  const ReverseCategoryIndexTable* reverse_cat_table_;
+  const CategoryToCommandsIndexStore* cat_to_commands_table_;
 };
 
 }  // namespace dfly::acl
diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index ed74e83e2fdf..f025b018d4fb 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -2629,8 +2629,9 @@ void Service::RegisterCommands() {
   server_family_.Register(&registry_);
   cluster_family_.Register(&registry_);
 
+  // AclFamily should always be registered last
+  // If we add a new familly, register that first above and *not* below
   acl_family_.Register(&registry_);
-  acl::BuildIndexers(registry_.GetFamilies(), &registry_);
 
   // Only after all the commands are registered
   registry_.Init(pp_.size());
@@ -2658,8 +2659,9 @@ void Service::RegisterCommands() {
   }
 }
 
-void Service::TestInit() {
+const acl::AclFamily* Service::TestInit() {
   acl_family_.Init(nullptr, &user_registry_);
+  return &acl_family_;
 }
 
 void SetMaxMemoryFlag(uint64_t value) {
diff --git a/src/server/main_service.h b/src/server/main_service.h
index 0bc318378d3f..f8cf381a6516 100644
--- a/src/server/main_service.h
+++ b/src/server/main_service.h
@@ -125,7 +125,7 @@ class Service : public facade::ServiceInterface {
 
   // Utility function used in unit tests
   // Do not use in production, only meant to be used by unit tests
-  void TestInit();
+  const acl::AclFamily* TestInit();
 
  private:
   static void Quit(CmdArgList args, ConnectionContext* cntx);
