diff --git a/src/core/dense_set.cc b/src/core/dense_set.cc
index 080045c32962..ef228158816a 100644
--- a/src/core/dense_set.cc
+++ b/src/core/dense_set.cc
@@ -28,7 +28,12 @@ constexpr bool kAllowDisplacements = true;
 DenseSet::IteratorBase::IteratorBase(const DenseSet* owner, bool is_end)
     : owner_(const_cast<DenseSet*>(owner)), curr_entry_(nullptr) {
   curr_list_ = is_end ? owner_->entries_.end() : owner_->entries_.begin();
-  if (curr_list_ != owner->entries_.end()) {
+
+  // Even if `is_end` is `false`, the list can be empty.
+  if (curr_list_ == owner->entries_.end()) {
+    curr_entry_ = nullptr;
+    owner_ = nullptr;
+  } else {
     curr_entry_ = &(*curr_list_);
     owner->ExpireIfNeeded(nullptr, curr_entry_);
 
@@ -86,8 +91,10 @@ size_t DenseSet::PushFront(DenseSet::ChainVectorIterator it, void* data, bool ha
     it->SetLink(NewLink(data, *it));
   }
 
-  if (has_ttl)
+  if (has_ttl) {
     it->SetTtl(true);
+    expiration_used_ = true;
+  }
   return ObjectAllocSize(data);
 }
 
@@ -97,8 +104,10 @@ void DenseSet::PushFront(DenseSet::ChainVectorIterator it, DenseSet::DensePtr pt
 
   if (it->IsEmpty()) {
     it->SetObject(ptr.GetObject());
-    if (ptr.HasTtl())
+    if (ptr.HasTtl()) {
       it->SetTtl(true);
+      expiration_used_ = true;
+    }
     if (ptr.IsLink()) {
       FreeLink(ptr.AsLink());
     }
@@ -112,8 +121,10 @@ void DenseSet::PushFront(DenseSet::ChainVectorIterator it, DenseSet::DensePtr pt
 
     // allocate a new link if needed and copy the pointer to the new link
     it->SetLink(NewLink(ptr.Raw(), *it));
-    if (ptr.HasTtl())
+    if (ptr.HasTtl()) {
       it->SetTtl(true);
+      expiration_used_ = true;
+    }
     DCHECK(!it->AsLink()->next.IsEmpty());
   }
 }
@@ -175,6 +186,7 @@ void DenseSet::ClearInternal() {
   num_used_buckets_ = 0;
   num_chain_entries_ = 0;
   size_ = 0;
+  expiration_used_ = false;
 }
 
 bool DenseSet::Equal(DensePtr dptr, const void* ptr, uint32_t cookie) const {
@@ -401,8 +413,10 @@ void DenseSet::AddUnique(void* obj, bool has_ttl, uint64_t hashcode) {
    */
 
   DensePtr to_insert(obj);
-  if (has_ttl)
+  if (has_ttl) {
     to_insert.SetTtl(true);
+    expiration_used_ = true;
+  }
 
   while (!entries_[bucket_id].IsEmpty() && entries_[bucket_id].IsDisplaced()) {
     DensePtr unlinked = PopPtrFront(entries_.begin() + bucket_id);
diff --git a/src/core/dense_set.h b/src/core/dense_set.h
index 6b077c2dfd58..0c55287b7399 100644
--- a/src/core/dense_set.h
+++ b/src/core/dense_set.h
@@ -258,6 +258,10 @@ class DenseSet {
     return time_now_;
   }
 
+  bool ExpirationUsed() const {
+    return expiration_used_;
+  }
+
  protected:
   // Virtual functions to be implemented for generic data
   virtual uint64_t Hash(const void* obj, uint32_t cookie) const = 0;
@@ -397,6 +401,8 @@ class DenseSet {
   unsigned capacity_log_ = 0;
 
   uint32_t time_now_ = 0;
+
+  mutable bool expiration_used_ = false;
 };
 
 inline void* DenseSet::FindInternal(const void* obj, uint64_t hashcode, uint32_t cookie) const {
diff --git a/src/server/generic_family.cc b/src/server/generic_family.cc
index 9f3b17bb9248..a16c411c6e84 100644
--- a/src/server/generic_family.cc
+++ b/src/server/generic_family.cc
@@ -456,9 +456,7 @@ OpResult<std::string> OpDump(const OpArgs& op_args, string_view key) {
     // According to Redis code we need to
     // 1. Save the value itself - without the key
     // 2. Save footer: this include the RDB version and the CRC value for the message
-    unsigned obj_type = it->second.ObjType();
-    unsigned encoding = it->second.Encoding();
-    auto type = RdbObjectType(obj_type, encoding);
+    auto type = RdbObjectType(it->second);
     DVLOG(1) << "We are going to dump object type: " << type;
     std::error_code ec = serializer.WriteOpcode(type);
     CHECK(!ec);
diff --git a/src/server/rdb_extensions.h b/src/server/rdb_extensions.h
index 2fc936213e7a..50104eeb961a 100644
--- a/src/server/rdb_extensions.h
+++ b/src/server/rdb_extensions.h
@@ -11,9 +11,12 @@ extern "C" {
 //  Custom types: Range 30-35 is used by DF RDB types.
 constexpr uint8_t RDB_TYPE_JSON_OLD = 20;
 constexpr uint8_t RDB_TYPE_JSON = 30;
+constexpr uint8_t RDB_TYPE_HASH_WITH_EXPIRY = 31;
+constexpr uint8_t RDB_TYPE_SET_WITH_EXPIRY = 32;
 
 constexpr bool rdbIsObjectTypeDF(uint8_t type) {
-  return __rdbIsObjectType(type) || (type == RDB_TYPE_JSON);
+  return __rdbIsObjectType(type) || (type == RDB_TYPE_JSON) ||
+         (type == RDB_TYPE_HASH_WITH_EXPIRY) || (type == RDB_TYPE_SET_WITH_EXPIRY);
 }
 
 //  Opcodes: Range 200-240 is used by DF extensions.
diff --git a/src/server/rdb_load.cc b/src/server/rdb_load.cc
index 20136bb0cc9c..086902ab07a8 100644
--- a/src/server/rdb_load.cc
+++ b/src/server/rdb_load.cc
@@ -439,9 +439,11 @@ void RdbLoaderBase::OpaqueObjLoader::operator()(const LzfString& lzfstr) {
 void RdbLoaderBase::OpaqueObjLoader::operator()(const unique_ptr<LoadTrace>& ptr) {
   switch (rdb_type_) {
     case RDB_TYPE_SET:
+    case RDB_TYPE_SET_WITH_EXPIRY:
       CreateSet(ptr.get());
       break;
     case RDB_TYPE_HASH:
+    case RDB_TYPE_HASH_WITH_EXPIRY:
       CreateHMap(ptr.get());
       break;
     case RDB_TYPE_LIST_QUICKLIST:
@@ -468,7 +470,7 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {
   size_t len = ltrace->blob_count();
 
   bool is_intset = true;
-  if (len <= SetFamily::MaxIntsetEntries()) {
+  if (rdb_type_ == RDB_TYPE_HASH && ltrace->blob_count() <= SetFamily::MaxIntsetEntries()) {
     Iterate(*ltrace, [&](const LoadBlob& blob) {
       if (!holds_alternative<long long>(blob.rdb_var)) {
         is_intset = false;
@@ -506,12 +508,22 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {
     });
   } else {
     bool use_set2 = GetFlag(FLAGS_use_set2);
+
     if (use_set2) {
       StringSet* set = new StringSet{CompactObj::memory_resource()};
+      set->set_time(MemberTimeSeconds(GetCurrentTimeMs()));
       res = createObject(OBJ_SET, set);
       res->encoding = OBJ_ENCODING_HT;
     } else {
       res = createSetObject();
+
+      if (rdb_type_ == RDB_TYPE_SET_WITH_EXPIRY) {
+        LOG(ERROR) << "Detected set with key expiration, but use_set2 is disabled. Unable to load "
+                      "set - key will be ignored.";
+        pv_->ImportRObj(res);
+        std::move(cleanup).Cancel();
+        return;
+      }
     }
 
     // TODO: to move this logic to set_family similarly to ConvertToStrSet.
@@ -525,18 +537,41 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {
     }
 
     if (use_set2) {
-      Iterate(*ltrace, [&](const LoadBlob& blob) {
-        sdsele = ToSds(blob.rdb_var);
-        if (!sdsele)
-          return false;
+      size_t increment = 1;
+      if (rdb_type_ == RDB_TYPE_SET_WITH_EXPIRY) {
+        increment = 2;
+      }
 
-        if (!((StringSet*)res->ptr)->AddSds(sdsele)) {
-          LOG(ERROR) << "Duplicate set members detected";
-          ec_ = RdbError(errc::duplicate_key);
-          return false;
+      auto set = (StringSet*)res->ptr;
+      for (const auto& seg : ltrace->arr) {
+        for (size_t i = 0; i < seg.size(); i += increment) {
+          string_view element = ToSV(seg[i].rdb_var);
+
+          uint32_t ttl_sec = UINT32_MAX;
+          if (increment == 2) {
+            int64_t ttl_time = -1;
+            string_view ttl_str = ToSV(seg[i + 1].rdb_var);
+            if (!absl::SimpleAtoi(ttl_str, &ttl_time)) {
+              LOG(ERROR) << "Can't parse set TTL " << ttl_str;
+              ec_ = RdbError(errc::rdb_file_corrupted);
+              return;
+            }
+
+            if (ttl_time != -1) {
+              if (ttl_time < set->time_now()) {
+                continue;
+              }
+
+              ttl_sec = ttl_time - set->time_now();
+            }
+          }
+          if (!set->Add(element, ttl_sec)) {
+            LOG(ERROR) << "Duplicate set members detected";
+            ec_ = RdbError(errc::duplicate_key);
+            return;
+          }
         }
-        return true;
-      });
+      }
     } else {
       Iterate(*ltrace, [&](const LoadBlob& blob) {
         sdsele = ToSds(blob.rdb_var);
@@ -560,10 +595,14 @@ void RdbLoaderBase::OpaqueObjLoader::CreateSet(const LoadTrace* ltrace) {
 }
 
 void RdbLoaderBase::OpaqueObjLoader::CreateHMap(const LoadTrace* ltrace) {
-  size_t len = ltrace->blob_count() / 2;
+  size_t increment = 2;
+  if (rdb_type_ == RDB_TYPE_HASH_WITH_EXPIRY)
+    increment = 3;
+
+  size_t len = ltrace->blob_count() / increment;
 
   /* Too many entries? Use a hash table right from the start. */
-  bool keep_lp = (len <= 64);
+  bool keep_lp = (len <= 64) && (rdb_type_ != RDB_TYPE_HASH_WITH_EXPIRY);
 
   size_t lp_size = 0;
   if (keep_lp) {
@@ -603,12 +642,13 @@ void RdbLoaderBase::OpaqueObjLoader::CreateHMap(const LoadTrace* ltrace) {
     pv_->InitRobj(OBJ_HASH, kEncodingListPack, lp);
   } else {
     StringMap* string_map = new StringMap;
+    string_map->set_time(MemberTimeSeconds(GetCurrentTimeMs()));
 
     auto cleanup = absl::MakeCleanup([&] { delete string_map; });
     std::string key;
     string_map->Reserve(len);
     for (const auto& seg : ltrace->arr) {
-      for (size_t i = 0; i < seg.size(); i += 2) {
+      for (size_t i = 0; i < seg.size(); i += increment) {
         // ToSV may reference an internal buffer, therefore we can use only before the
         // next call to ToSV. To workaround, copy the key locally.
         key = ToSV(seg[i].rdb_var);
@@ -617,7 +657,27 @@ void RdbLoaderBase::OpaqueObjLoader::CreateHMap(const LoadTrace* ltrace) {
         if (ec_)
           return;
 
-        if (!string_map->AddOrSkip(key, val)) {
+        uint32_t ttl_sec = UINT32_MAX;
+        if (increment == 3) {
+          int64_t ttl_time = -1;
+          string_view ttl_str = ToSV(seg[i + 2].rdb_var);
+          if (!absl::SimpleAtoi(ttl_str, &ttl_time)) {
+            LOG(ERROR) << "Can't parse hashmap TTL for " << key << ", val=" << val
+                       << ", ttl=" << ttl_str;
+            ec_ = RdbError(errc::rdb_file_corrupted);
+            return;
+          }
+
+          if (ttl_time != -1) {
+            if (ttl_time < string_map->time_now()) {
+              continue;
+            }
+
+            ttl_sec = ttl_time - string_map->time_now();
+          }
+        }
+
+        if (!string_map->AddOrSkip(key, val, ttl_sec)) {
           LOG(ERROR) << "Duplicate hash fields detected for field " << key;
           ec_ = RdbError(errc::rdb_file_corrupted);
           return;
@@ -1310,7 +1370,8 @@ error_code RdbLoaderBase::ReadObj(int rdbtype, OpaqueObj* dest) {
       return ReadStringObj(&dest->obj);
     }
     case RDB_TYPE_SET:
-      iores = ReadSet();
+    case RDB_TYPE_SET_WITH_EXPIRY:
+      iores = ReadSet(rdbtype);
       break;
     case RDB_TYPE_SET_INTSET:
       iores = ReadIntSet();
@@ -1321,7 +1382,8 @@ error_code RdbLoaderBase::ReadObj(int rdbtype, OpaqueObj* dest) {
       iores = ReadGeneric(rdbtype);
       break;
     case RDB_TYPE_HASH:
-      iores = ReadHMap();
+    case RDB_TYPE_HASH_WITH_EXPIRY:
+      iores = ReadHMap(rdbtype);
       break;
     case RDB_TYPE_ZSET:
     case RDB_TYPE_ZSET_2:
@@ -1439,12 +1501,13 @@ auto RdbLoaderBase::ReadLzf() -> io::Result<LzfString> {
   return res;
 }
 
-auto RdbLoaderBase::ReadSet() -> io::Result<OpaqueObj> {
+auto RdbLoaderBase::ReadSet(int rdbtype) -> io::Result<OpaqueObj> {
   size_t len;
   SET_OR_UNEXPECT(LoadLen(NULL), len);
 
-  if (len == 0)
-    return Unexpected(errc::empty_key);
+  if (rdbtype == RDB_TYPE_SET_WITH_EXPIRY) {
+    len *= 2;
+  }
 
   unique_ptr<LoadTrace> load_trace(new LoadTrace);
   load_trace->arr.resize((len + kMaxBlobLen - 1) / kMaxBlobLen);
@@ -1459,7 +1522,7 @@ auto RdbLoaderBase::ReadSet() -> io::Result<OpaqueObj> {
     }
   }
 
-  return OpaqueObj{std::move(load_trace), RDB_TYPE_SET};
+  return OpaqueObj{std::move(load_trace), rdbtype};
 }
 
 auto RdbLoaderBase::ReadIntSet() -> io::Result<OpaqueObj> {
@@ -1498,16 +1561,19 @@ auto RdbLoaderBase::ReadGeneric(int rdbtype) -> io::Result<OpaqueObj> {
   return OpaqueObj{std::move(str_obj), rdbtype};
 }
 
-auto RdbLoaderBase::ReadHMap() -> io::Result<OpaqueObj> {
+auto RdbLoaderBase::ReadHMap(int rdbtype) -> io::Result<OpaqueObj> {
   size_t len;
   SET_OR_UNEXPECT(LoadLen(nullptr), len);
 
-  if (len == 0)
-    return Unexpected(errc::empty_key);
-
   unique_ptr<LoadTrace> load_trace(new LoadTrace);
 
-  len *= 2;
+  if (rdbtype == RDB_TYPE_HASH) {
+    len *= 2;
+  } else {
+    DCHECK_EQ(rdbtype, RDB_TYPE_HASH_WITH_EXPIRY);
+    len *= 3;
+  }
+
   load_trace->arr.resize((len + kMaxBlobLen - 1) / kMaxBlobLen);
   for (size_t i = 0; i < load_trace->arr.size(); ++i) {
     size_t n = std::min<size_t>(len, kMaxBlobLen);
@@ -1520,7 +1586,7 @@ auto RdbLoaderBase::ReadHMap() -> io::Result<OpaqueObj> {
     len -= n;
   }
 
-  return OpaqueObj{std::move(load_trace), RDB_TYPE_HASH};
+  return OpaqueObj{std::move(load_trace), rdbtype};
 }
 
 auto RdbLoaderBase::ReadZSet(int rdbtype) -> io::Result<OpaqueObj> {
diff --git a/src/server/rdb_load.h b/src/server/rdb_load.h
index 59159ccfb818..8b14c795a3a0 100644
--- a/src/server/rdb_load.h
+++ b/src/server/rdb_load.h
@@ -124,10 +124,10 @@ class RdbLoaderBase {
   ::io::Result<long long> ReadIntObj(int encoding);
   ::io::Result<LzfString> ReadLzf();
 
-  ::io::Result<OpaqueObj> ReadSet();
+  ::io::Result<OpaqueObj> ReadSet(int rdbtype);
   ::io::Result<OpaqueObj> ReadIntSet();
   ::io::Result<OpaqueObj> ReadGeneric(int rdbtype);
-  ::io::Result<OpaqueObj> ReadHMap();
+  ::io::Result<OpaqueObj> ReadHMap(int rdbtype);
   ::io::Result<OpaqueObj> ReadZSet(int rdbtype);
   ::io::Result<OpaqueObj> ReadZSetZL();
   ::io::Result<OpaqueObj> ReadListQuicklist(int rdbtype);
diff --git a/src/server/rdb_save.cc b/src/server/rdb_save.cc
index fd03238f3f66..c485484b8cac 100644
--- a/src/server/rdb_save.cc
+++ b/src/server/rdb_save.cc
@@ -109,7 +109,9 @@ constexpr size_t kAmask = 4_KB - 1;
 
 }  // namespace
 
-uint8_t RdbObjectType(unsigned type, unsigned compact_enc) {
+uint8_t RdbObjectType(const PrimeValue& pv) {
+  unsigned type = pv.ObjType();
+  unsigned compact_enc = pv.Encoding();
   switch (type) {
     case OBJ_STRING:
       return RDB_TYPE_STRING;
@@ -120,8 +122,12 @@ uint8_t RdbObjectType(unsigned type, unsigned compact_enc) {
     case OBJ_SET:
       if (compact_enc == kEncodingIntSet)
         return RDB_TYPE_SET_INTSET;
-      else if (compact_enc == kEncodingStrMap || compact_enc == kEncodingStrMap2)
-        return RDB_TYPE_SET;
+      else if (compact_enc == kEncodingStrMap || compact_enc == kEncodingStrMap2) {
+        if (((StringSet*)pv.RObjPtr())->ExpirationUsed())
+          return RDB_TYPE_SET_WITH_EXPIRY;
+        else
+          return RDB_TYPE_SET;
+      }
       break;
     case OBJ_ZSET:
       if (compact_enc == OBJ_ENCODING_LISTPACK)
@@ -132,8 +138,12 @@ uint8_t RdbObjectType(unsigned type, unsigned compact_enc) {
     case OBJ_HASH:
       if (compact_enc == kEncodingListPack)
         return RDB_TYPE_HASH_ZIPLIST;
-      else if (compact_enc == kEncodingStrMap2)
-        return RDB_TYPE_HASH;
+      else if (compact_enc == kEncodingStrMap2) {
+        if (((StringMap*)pv.RObjPtr())->ExpirationUsed())
+          return RDB_TYPE_HASH_WITH_EXPIRY;  // Incompatible with Redis
+        else
+          return RDB_TYPE_HASH;
+      }
       break;
     case OBJ_STREAM:
       return RDB_TYPE_STREAM_LISTPACKS;
@@ -293,9 +303,7 @@ io::Result<uint8_t> RdbSerializer::SaveEntry(const PrimeKey& pk, const PrimeValu
   }
 
   string_view key = pk.GetSlice(&tmp_str_);
-  unsigned obj_type = pv.ObjType();
-  unsigned encoding = pv.Encoding();
-  uint8_t rdb_type = RdbObjectType(obj_type, encoding);
+  uint8_t rdb_type = RdbObjectType(pv);
 
   DVLOG(3) << ((void*)this) << ": Saving key/val start " << key << " in dbid=" << dbid;
 
@@ -416,8 +424,14 @@ error_code RdbSerializer::SaveSetObject(const PrimeValue& obj) {
 
     RETURN_ON_ERR(SaveLen(set->SizeSlow()));
 
-    for (sds ele : *set) {
-      RETURN_ON_ERR(SaveString(string_view{ele, sdslen(ele)}));
+    for (auto it = set->begin(); it != set->end(); ++it) {
+      RETURN_ON_ERR(SaveString(string_view{*it, sdslen(*it)}));
+      if (set->ExpirationUsed()) {
+        int64_t expiry = -1;
+        if (it.HasExpiry())
+          expiry = it.ExpiryTime();
+        RETURN_ON_ERR(SaveLongLongAsString(expiry));
+      }
     }
   } else {
     CHECK_EQ(obj.Encoding(), kEncodingIntSet);
@@ -438,9 +452,16 @@ error_code RdbSerializer::SaveHSetObject(const PrimeValue& pv) {
 
     RETURN_ON_ERR(SaveLen(string_map->SizeSlow()));
 
-    for (const auto& k_v : *string_map) {
-      RETURN_ON_ERR(SaveString(string_view{k_v.first, sdslen(k_v.first)}));
-      RETURN_ON_ERR(SaveString(string_view{k_v.second, sdslen(k_v.second)}));
+    for (auto it = string_map->begin(); it != string_map->end(); ++it) {
+      const auto& [k, v] = *it;
+      RETURN_ON_ERR(SaveString(string_view{k, sdslen(k)}));
+      RETURN_ON_ERR(SaveString(string_view{v, sdslen(v)}));
+      if (string_map->ExpirationUsed()) {
+        int64_t expiry = -1;
+        if (it.HasExpiry())
+          expiry = it.ExpiryTime();
+        RETURN_ON_ERR(SaveLongLongAsString(expiry));
+      }
     }
   } else {
     CHECK_EQ(kEncodingListPack, pv.Encoding());
diff --git a/src/server/rdb_save.h b/src/server/rdb_save.h
index cafc0380a7e1..507e923b9e54 100644
--- a/src/server/rdb_save.h
+++ b/src/server/rdb_save.h
@@ -25,7 +25,7 @@ typedef struct streamCG streamCG;
 
 namespace dfly {
 
-uint8_t RdbObjectType(unsigned type, unsigned encoding);
+uint8_t RdbObjectType(const PrimeValue& pv);
 
 class EngineShard;
 class Service;
