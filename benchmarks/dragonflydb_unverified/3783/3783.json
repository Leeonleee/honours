{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3783,
  "instance_id": "dragonflydb__dragonfly-3783",
  "issue_numbers": [
    "3458"
  ],
  "base_commit": "987e6feaa51df8aa2d60b79d20bbce795d7fc6cb",
  "patch": "diff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc\nindex d7ee4c3bdfe9..1cb569f7d251 100644\n--- a/src/server/acl/acl_family.cc\n+++ b/src/server/acl/acl_family.cc\n@@ -651,7 +651,7 @@ constexpr uint32_t kGenPass = acl::SLOW;\n \n // We can't implement the ACL commands and its respective subcommands LIST, CAT, etc\n // the usual way, (that is, one command called ACL which then dispatches to the subcommand\n-// based on the secocond argument) because each of the subcommands has different ACL\n+// based on the second argument) because each of the subcommands has different ACL\n // categories. Therefore, to keep it compatible with the CommandId, I need to treat them\n // as separate commands in the registry. This is the least intrusive change because it's very\n // easy to handle that case explicitly in `DispatchCommand`.\n@@ -990,6 +990,14 @@ using OptCat = std::optional<uint32_t>;\n // bool == true if +\n // bool == false if -\n std::pair<OptCat, bool> AclFamily::MaybeParseAclCategory(std::string_view command) const {\n+  if (absl::EqualsIgnoreCase(command, \"ALLCOMMANDS\")) {\n+    return {cat_table_.at(\"ALL\"), true};\n+  }\n+\n+  if (absl::EqualsIgnoreCase(command, \"NOCOMMANDS\")) {\n+    return {cat_table_.at(\"ALL\"), false};\n+  }\n+\n   if (absl::StartsWith(command, \"+@\")) {\n     auto res = cat_table_.find(command.substr(2));\n     if (res == cat_table_.end()) {\n",
  "test_patch": "diff --git a/src/server/acl/acl_family_test.cc b/src/server/acl/acl_family_test.cc\nindex c1f2f83e81ac..367cbb1ec4b2 100644\n--- a/src/server/acl/acl_family_test.cc\n+++ b/src/server/acl/acl_family_test.cc\n@@ -116,6 +116,24 @@ TEST_F(AclFamilyTest, AclSetUser) {\n   // +@NONE should not exist anymore. It's not in the spec.\n   resp = Run({\"ACL\", \"SETUSER\", \"rand\", \"+@NONE\"});\n   EXPECT_THAT(resp, ErrArg(\"ERR Unrecognized parameter +@NONE\"));\n+\n+  resp = Run({\"ACL\", \"SETUSER\", \"rand\", \"ALLCOMMANDS\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"ACL\", \"LIST\"});\n+  vec = resp.GetVec();\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                        \"user vlad on resetchannels -@all +acl\",\n+                                        \"user rand off resetchannels +@all\"));\n+\n+  resp = Run({\"ACL\", \"SETUSER\", \"rand\", \"NOCOMMANDS\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"ACL\", \"LIST\"});\n+  vec = resp.GetVec();\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                                        \"user vlad on resetchannels -@all +acl\",\n+                                        \"user rand off resetchannels -@all\"));\n }\n \n TEST_F(AclFamilyTest, AclDelUser) {\n",
  "problem_statement": "add `allcomands` and `nocommands` support for ACL's\n* allcommands is syntactic sugar for `+@all`\r\n* nocommands is syntactic sugar for `-@all`\n",
  "hints_text": "@kostasrim  is it still relevant?\nyes",
  "created_at": "2024-09-24T15:08:41Z",
  "modified_files": [
    "src/server/acl/acl_family.cc"
  ],
  "modified_test_files": [
    "src/server/acl/acl_family_test.cc"
  ]
}