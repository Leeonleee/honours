{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 792,
  "instance_id": "dragonflydb__dragonfly-792",
  "issue_numbers": [
    "784"
  ],
  "base_commit": "3e46fd1318364219f684c8b641b2985e84549158",
  "patch": "diff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex f9d569466ad8..ec6010e3df09 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -43,8 +43,6 @@ using namespace std;\n ABSL_FLAG(uint32_t, port, 6379, \"Redis port\");\n ABSL_FLAG(uint32_t, memcache_port, 0, \"Memcached port\");\n \n-ABSL_DECLARE_FLAG(string, requirepass);\n-\n namespace dfly {\n \n #if __GLIBC__ == 2 && __GLIBC_MINOR__ < 30\n@@ -813,7 +811,7 @@ void Service::DispatchMC(const MemcacheParser::Command& cmd, std::string_view va\n facade::ConnectionContext* Service::CreateContext(util::FiberSocketBase* peer,\n                                                   facade::Connection* owner) {\n   ConnectionContext* res = new ConnectionContext{peer, owner};\n-  res->req_auth = IsPassProtected();\n+  res->req_auth = !GetPassword().empty();\n \n   // a bit of a hack. I set up breaker callback here for the owner.\n   // Should work though it's confusing to have it here.\n@@ -853,10 +851,6 @@ bool Service::IsShardSetLocked() const {\n   return res.load() != 0;\n }\n \n-bool Service::IsPassProtected() const {\n-  return !GetFlag(FLAGS_requirepass).empty();\n-}\n-\n absl::flat_hash_map<std::string, unsigned> Service::UknownCmdMap() const {\n   lock_guard lk(mu_);\n   return unknown_cmds_;\ndiff --git a/src/server/main_service.h b/src/server/main_service.h\nindex d22582c41fe4..6fd29bc4c0fc 100644\n--- a/src/server/main_service.h\n+++ b/src/server/main_service.h\n@@ -59,8 +59,6 @@ class Service : public facade::ServiceInterface {\n     return pp_;\n   }\n \n-  bool IsPassProtected() const;\n-\n   absl::flat_hash_map<std::string, unsigned> UknownCmdMap() const;\n \n   const CommandId* FindCmd(std::string_view cmd) const {\n@@ -79,7 +77,7 @@ class Service : public facade::ServiceInterface {\n   // if from equals the old state then the switch is performed \"to\" is returned.\n   // Otherwise, does not switch and returns the current state in the system.\n   // Upon switch, updates cached global state in threadlocal ServerState struct.\n-  GlobalState SwitchState(GlobalState from , GlobalState to);\n+  GlobalState SwitchState(GlobalState from, GlobalState to);\n \n   void ConfigureHttpHandlers(util::HttpListenerBase* base) final;\n   void OnClose(facade::ConnectionContext* cntx) final;\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 78ef6a784840..ec00e15468b2 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -51,7 +51,9 @@ using namespace std;\n \n ABSL_FLAG(string, dir, \"\", \"working directory\");\n ABSL_FLAG(string, dbfilename, \"dump\", \"the filename to save/load the DB\");\n-ABSL_FLAG(string, requirepass, \"\", \"password for AUTH authentication\");\n+ABSL_FLAG(string, requirepass, \"\",\n+          \"password for AUTH authentication. \"\n+          \"If empty can also be set with DFLY_PASSWORD environment variable.\");\n ABSL_FLAG(string, save_schedule, \"\",\n           \"glob spec for the UTC time to save a snapshot which matches HH:MM 24h time\");\n \n@@ -1047,6 +1049,20 @@ void ServerFamily::BreakOnShutdown() {\n   dfly_cmd_->BreakOnShutdown();\n }\n \n+string GetPassword() {\n+  string flag = GetFlag(FLAGS_requirepass);\n+  if (!flag.empty()) {\n+    return flag;\n+  }\n+\n+  const char* env_var = getenv(\"DFLY_PASSWORD\");\n+  if (env_var) {\n+    return env_var;\n+  }\n+\n+  return \"\";\n+}\n+\n void ServerFamily::FlushDb(CmdArgList args, ConnectionContext* cntx) {\n   DCHECK(cntx->transaction);\n   Drakarys(cntx->transaction, cntx->transaction->GetDbIndex());\n@@ -1080,7 +1096,7 @@ void ServerFamily::Auth(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   string_view pass = ArgS(args, 1);\n-  if (pass == GetFlag(FLAGS_requirepass)) {\n+  if (pass == GetPassword()) {\n     cntx->authenticated = true;\n     (*cntx)->SendOk();\n   } else {\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex 3ff954105b82..895c29204a72 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -5,6 +5,7 @@\n #pragma once\n \n #include <boost/fiber/future.hpp>\n+#include <string>\n \n #include \"facade/conn_context.h\"\n #include \"facade/redis_parser.h\"\n@@ -20,6 +21,8 @@ class HttpListenerBase;\n \n namespace dfly {\n \n+std::string GetPassword();\n+\n namespace journal {\n class Journal;\n }  // namespace journal\n",
  "test_patch": "diff --git a/tests/dragonfly/generic_test.py b/tests/dragonfly/generic_test.py\nindex d427ed741170..63a8820386ec 100644\n--- a/tests/dragonfly/generic_test.py\n+++ b/tests/dragonfly/generic_test.py\n@@ -1,3 +1,6 @@\n+import os\n+import aioredis\n+import pytest\n from . import dfly_multi_test_args\n from .utility import batch_fill_data, gen_test_data\n \n@@ -11,3 +14,36 @@ def test_max_keys(self, client, df_server):\n \n         keys = client.keys()\n         assert len(keys) in range(max_keys, max_keys+512)\n+\n+@pytest.fixture(scope=\"function\")\n+def export_dfly_password() -> str:\n+    pwd = 'flypwd'\n+    os.environ['DFLY_PASSWORD'] = pwd\n+    yield pwd\n+    del os.environ['DFLY_PASSWORD']\n+\n+@pytest.mark.asyncio\n+async def test_password(df_local_factory, export_dfly_password):\n+    dfly = df_local_factory.create()\n+    dfly.start()\n+\n+    # Expect password form environment variable\n+    with pytest.raises(aioredis.exceptions.AuthenticationError):\n+        client = aioredis.Redis()\n+        await client.ping()\n+    client = aioredis.Redis(password=export_dfly_password)\n+    await client.ping()\n+    dfly.stop()\n+\n+    # --requirepass should take precedence over environment variable\n+    requirepass = 'requirepass'\n+    dfly = df_local_factory.create(requirepass=requirepass)\n+    dfly.start()\n+\n+    # Expect password form flag\n+    with pytest.raises(aioredis.exceptions.ResponseError):\n+        client = aioredis.Redis(password=export_dfly_password)\n+        await client.ping()\n+    client = aioredis.Redis(password=requirepass)\n+    await client.ping()\n+    dfly.stop()\n",
  "problem_statement": "Support requirepass with an env variable \nS.t. it is not leaked e.g. on /flagz\n",
  "hints_text": "",
  "created_at": "2023-02-13T16:57:12Z",
  "modified_files": [
    "src/server/main_service.cc",
    "src/server/main_service.h",
    "src/server/server_family.cc",
    "src/server/server_family.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/generic_test.py"
  ]
}