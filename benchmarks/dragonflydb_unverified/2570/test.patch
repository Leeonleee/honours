diff --git a/tests/dragonfly/eval_test.py b/tests/dragonfly/eval_test.py
index 34a69e3a4f42..8e0b4463f760 100644
--- a/tests/dragonfly/eval_test.py
+++ b/tests/dragonfly/eval_test.py
@@ -3,11 +3,15 @@
 from redis import asyncio as aioredis
 import time
 import json
+import logging
 import pytest
 import random
 import itertools
 import random
 import string
+
+from .instance import DflyInstance
+
 from . import dfly_args, dfly_multi_test_args
 
 DJANGO_CACHEOPS_SCRIPT = """
@@ -310,3 +314,28 @@ async def measure_blocked():
     # At least some connection was seen blocked
     # Flaky: release build is too fast and never blocks
     # assert max_blocked > 0
+
+
+"""
+Tests migrate/close interaction for the connection
+Reproduces #2569
+"""
+
+
+@dfly_args({"proactor_threads": "4", "pipeline_squash": 0})
+async def test_migrate_close_connection(async_client: aioredis.Redis, df_server: DflyInstance):
+    sha = await async_client.script_load("return redis.call('GET', KEYS[1])")
+
+    async def run():
+        reader, writer = await asyncio.open_connection("localhost", df_server.port)
+
+        # write a EVALSHA that will ask for migration (75% it's on the wrong shard)
+        writer.write((f"EVALSHA {sha} 1 a\r
").encode())
+        await writer.drain()
+
+        # disconnect the client connection
+        writer.close()
+        await writer.wait_closed()
+
+    tasks = [asyncio.create_task(run()) for _ in range(50)]
+    await asyncio.gather(*tasks)
diff --git a/tests/dragonfly/instance.py b/tests/dragonfly/instance.py
index eef422042065..66c0d36cc622 100644
--- a/tests/dragonfly/instance.py
+++ b/tests/dragonfly/instance.py
@@ -5,7 +5,6 @@
 import logging
 from dataclasses import dataclass
 from typing import Dict, Optional, List, Union
-import os
 import re
 import psutil
 import itertools
@@ -163,22 +162,13 @@ def stop(self, kill=False):
         if proc is None:
             return
 
-        # if we have log files, it means that we started a process.
-        # if it died before we could stop it, we should raise an exception
-        if self.log_files:
-            exitcode = proc.poll()
-            if exitcode is not None:
-                if exitcode != 0:
-                    raise Exception(f"Process exited with code {exitcode}")
-                return
-
         logging.debug(f"Stopping instance on {self._port}")
         try:
             if kill:
                 proc.kill()
             else:
                 proc.terminate()
-            proc.communicate(timeout=30)
+            proc.communicate(timeout=15)
         except subprocess.TimeoutExpired:
             # We need to send SIGUSR1 to DF such that it prints the stacktrace
             proc.send_signal(signal.SIGUSR1)
@@ -203,11 +193,9 @@ def _start(self):
             self._port = None
 
         all_args = self.format_args(self.args)
-        arg_str = " ".join(all_args)
-        bin_path = os.path.realpath(self.params.path)
-        logging.debug(f"Starting {bin_path} with arguments: {arg_str}")
+        logging.debug(f"Starting instance with arguments {all_args} from {self.params.path}")
 
-        run_cmd = [bin_path, *all_args]
+        run_cmd = [self.params.path, *all_args]
         if self.params.gdb:
             run_cmd = ["gdb", "--ex", "r", "--args"] + run_cmd
 
