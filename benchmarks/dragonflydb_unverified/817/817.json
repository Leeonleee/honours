{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 817,
  "instance_id": "dragonflydb__dragonfly-817",
  "issue_numbers": [
    "687"
  ],
  "base_commit": "4ef06e759ae787f2cc35be9c69393310e30acb50",
  "patch": "diff --git a/src/server/common.h b/src/server/common.h\nindex 90d4072d3c8a..911d7e65bb58 100644\n--- a/src/server/common.h\n+++ b/src/server/common.h\n@@ -325,4 +325,11 @@ struct ScanOpts {\n   static OpResult<ScanOpts> TryFrom(CmdArgList args);\n };\n \n+// I use relative time from Feb 1, 2023 in seconds.\n+constexpr uint64_t kMemberExpiryBase = 1675209600;\n+\n+inline uint32_t MemberTimeSeconds(uint64_t now_ms) {\n+  return (now_ms / 1000) - kMemberExpiryBase;\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex a1ab8bd943c6..a3760ac02da3 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -43,6 +43,13 @@ bool IsGoodForListpack(CmdArgList args, const uint8_t* lp) {\n   return lpBytes(const_cast<uint8_t*>(lp)) + sum < kMaxListPackLen;\n }\n \n+inline StringMap* GetStringMap(const PrimeValue& pv, const DbContext& db_context) {\n+  StringMap* res = (StringMap*)pv.RObjPtr();\n+  uint32_t map_time = MemberTimeSeconds(db_context.time_now_ms);\n+  res->set_time(map_time);\n+  return res;\n+}\n+\n inline string_view LpGetView(uint8_t* lp_it, uint8_t int_buf[]) {\n   int64_t ele_len = 0;\n   uint8_t* elem = lpGet(lp_it, &ele_len, int_buf);\n@@ -117,12 +124,13 @@ pair<uint8_t*, bool> LpInsert(uint8_t* lp, string_view field, string_view val, b\n   return make_pair(lp, !updated);\n }\n \n-size_t HMapLength(const CompactObj& co) {\n+size_t HMapLength(const DbContext& db_cntx, const CompactObj& co) {\n   void* ptr = co.RObjPtr();\n   if (co.Encoding() == kEncodingStrMap2) {\n-    StringMap* sm = (StringMap*)ptr;\n+    StringMap* sm = GetStringMap(co, db_cntx);\n     return sm->Size();\n   }\n+\n   DCHECK_EQ(kEncodingListPack, co.Encoding());\n   return lpLength((uint8_t*)ptr) / 2;\n }\n@@ -229,7 +237,8 @@ OpStatus OpIncrBy(const OpArgs& op_args, string_view key, string_view field, Inc\n     stats->listpack_bytes += lpBytes(lp);\n   } else {\n     DCHECK_EQ(enc, kEncodingStrMap2);\n-    StringMap* sm = (StringMap*)pv.RObjPtr();\n+    StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n+\n     sds val = nullptr;\n     if (!inserted) {\n       val = sm->Find(field);\n@@ -309,7 +318,8 @@ OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t\n     *cursor = 0;\n   } else {\n     DCHECK_EQ(pv.Encoding(), kEncodingStrMap2);\n-    StringMap* sm = (StringMap*)pv.RObjPtr();\n+    StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n+\n     long max_iterations = count * INTERATION_FACTOR;\n \n     // note about this lambda - don't capture here! it should be convertible to C function!\n@@ -365,7 +375,8 @@ OpResult<uint32_t> OpDel(const OpArgs& op_args, string_view key, CmdArgList valu\n     pv.SetRObjPtr(lp);\n   } else {\n     DCHECK_EQ(enc, kEncodingStrMap2);\n-    StringMap* sm = (StringMap*)pv.RObjPtr();\n+    StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n+\n     for (auto s : values) {\n       bool res = sm->Erase(ToSV(s));\n       if (res) {\n@@ -438,7 +449,7 @@ OpResult<vector<OptStr>> OpMGet(const OpArgs& op_args, std::string_view key, Cmd\n     } while (lp_elem);\n   } else {\n     DCHECK_EQ(kEncodingStrMap2, pv.Encoding());\n-    StringMap* sm = (StringMap*)pv.RObjPtr();\n+    StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n \n     for (size_t i = 0; i < fields.size(); ++i) {\n       sds val = sm->Find(ToSV(fields[i]));\n@@ -456,8 +467,9 @@ OpResult<uint32_t> OpLen(const OpArgs& op_args, string_view key) {\n   auto it_res = db_slice.Find(op_args.db_cntx, key, OBJ_HASH);\n \n   if (it_res) {\n-    return HMapLength((*it_res)->second);\n+    return HMapLength(op_args.db_cntx, (*it_res)->second);\n   }\n+\n   if (it_res.status() == OpStatus::KEY_NOTFOUND)\n     return 0;\n   return it_res.status();\n@@ -482,7 +494,8 @@ OpResult<int> OpExist(const OpArgs& op_args, string_view key, string_view field)\n   }\n \n   DCHECK_EQ(kEncodingStrMap2, pv.Encoding());\n-  StringMap* sm = (StringMap*)ptr;\n+  StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n+\n   return sm->Find(field) ? 1 : 0;\n };\n \n@@ -505,8 +518,9 @@ OpResult<string> OpGet(const OpArgs& op_args, string_view key, string_view field\n   }\n \n   DCHECK_EQ(pv.Encoding(), kEncodingStrMap2);\n-  StringMap* sm = (StringMap*)ptr;\n+  StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n   sds val = sm->Find(field);\n+\n   if (!val)\n     return OpStatus::KEY_NOTFOUND;\n \n@@ -547,7 +561,8 @@ OpResult<vector<string>> OpGetAll(const OpArgs& op_args, string_view key, uint8_\n     }\n   } else {\n     DCHECK_EQ(pv.Encoding(), kEncodingStrMap2);\n-    StringMap* sm = (StringMap*)pv.RObjPtr();\n+    StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n+\n     res.resize(sm->Size() * (keyval ? 2 : 1));\n     for (const auto& k_v : *sm) {\n       if (mask & FIELDS) {\n@@ -583,14 +598,19 @@ OpResult<size_t> OpStrLen(const OpArgs& op_args, string_view key, string_view fi\n   }\n \n   DCHECK_EQ(pv.Encoding(), kEncodingStrMap2);\n-  StringMap* sm = (StringMap*)ptr;\n-  sds res = sm->Find(field);\n+  StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n \n+  sds res = sm->Find(field);\n   return res ? sdslen(res) : 0;\n }\n \n+struct OpSetParams {\n+  bool skip_if_exists = false;\n+  uint32_t ttl = UINT32_MAX;\n+};\n+\n OpResult<uint32_t> OpSet(const OpArgs& op_args, string_view key, CmdArgList values,\n-                         bool skip_if_exists) {\n+                         const OpSetParams& op_sp = OpSetParams{}) {\n   DCHECK(!values.empty() && 0 == values.size() % 2);\n \n   auto& db_slice = op_args.shard->db_slice();\n@@ -608,11 +628,16 @@ OpResult<uint32_t> OpSet(const OpArgs& op_args, string_view key, CmdArgList valu\n   PrimeValue& pv = it->second;\n \n   if (add_res.second) {  // new key\n-    lp = lpNew(0);\n-    pv.InitRobj(OBJ_HASH, kEncodingListPack, lp);\n+    if (op_sp.ttl == UINT32_MAX) {\n+      lp = lpNew(0);\n+      pv.InitRobj(OBJ_HASH, kEncodingListPack, lp);\n \n-    stats->listpack_blob_cnt++;\n-    stats->listpack_bytes += lpBytes(lp);\n+      stats->listpack_blob_cnt++;\n+      stats->listpack_bytes += lpBytes(lp);\n+    } else {\n+      StringMap* sm = new StringMap(CompactObj::memory_resource());\n+      pv.InitRobj(OBJ_HASH, kEncodingStrMap2, sm);\n+    }\n   } else {\n     if (pv.ObjType() != OBJ_HASH)\n       return OpStatus::WRONG_TYPE;\n@@ -624,7 +649,7 @@ OpResult<uint32_t> OpSet(const OpArgs& op_args, string_view key, CmdArgList valu\n     lp = (uint8_t*)pv.RObjPtr();\n     stats->listpack_bytes -= lpBytes(lp);\n \n-    if (!IsGoodForListpack(values, lp)) {\n+    if (op_sp.ttl != UINT32_MAX || !IsGoodForListpack(values, lp)) {\n       stats->listpack_blob_cnt--;\n       StringMap* sm = HSetFamily::ConvertToStrMap(lp);\n       pv.InitRobj(OBJ_HASH, kEncodingStrMap2, sm);\n@@ -637,21 +662,22 @@ OpResult<uint32_t> OpSet(const OpArgs& op_args, string_view key, CmdArgList valu\n   if (lp) {\n     bool inserted;\n     for (size_t i = 0; i < values.size(); i += 2) {\n-      tie(lp, inserted) = LpInsert(lp, ArgS(values, i), ArgS(values, i + 1), skip_if_exists);\n+      tie(lp, inserted) = LpInsert(lp, ArgS(values, i), ArgS(values, i + 1), op_sp.skip_if_exists);\n       created += inserted;\n     }\n     pv.SetRObjPtr(lp);\n     stats->listpack_bytes += lpBytes(lp);\n   } else {\n     DCHECK_EQ(kEncodingStrMap2, pv.Encoding());  // Dictionary\n-    StringMap* sm = (StringMap*)pv.RObjPtr();\n+    StringMap* sm = GetStringMap(pv, op_args.db_cntx);\n+\n     bool added;\n \n     for (size_t i = 0; i < values.size(); i += 2) {\n-      if (skip_if_exists)\n-        added = sm->AddOrSkip(ToSV(values[i]), ToSV(values[i + 1]));\n+      if (op_sp.skip_if_exists)\n+        added = sm->AddOrSkip(ToSV(values[i]), ToSV(values[i + 1]), op_sp.ttl);\n       else\n-        added = sm->AddOrUpdate(ToSV(values[i]), ToSV(values[i + 1]));\n+        added = sm->AddOrUpdate(ToSV(values[i]), ToSV(values[i + 1]), op_sp.ttl);\n \n       created += unsigned(added);\n     }\n@@ -661,6 +687,57 @@ OpResult<uint32_t> OpSet(const OpArgs& op_args, string_view key, CmdArgList valu\n   return created;\n }\n \n+void HGetGeneric(CmdArgList args, ConnectionContext* cntx, uint8_t getall_mask) {\n+  string_view key = ArgS(args, 1);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpGetAll(t->GetOpArgs(shard), key, getall_mask);\n+  };\n+\n+  OpResult<vector<string>> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+\n+  if (result) {\n+    (*cntx)->SendStringArr(absl::Span<const string>{*result});\n+  } else {\n+    (*cntx)->SendError(result.status());\n+  }\n+}\n+\n+// HSETEX key tll_sec field value field value ...\n+void HSetEx(CmdArgList args, ConnectionContext* cntx) {\n+  if (args.size() % 2 != 1) {\n+    ToLower(&args[0]);\n+\n+    string_view cmd = ArgS(args, 0);\n+\n+    return (*cntx)->SendError(facade::WrongNumArgsError(cmd), kSyntaxErrType);\n+  }\n+\n+  string_view key = ArgS(args, 1);\n+  string_view ttl_str = ArgS(args, 2);\n+  uint32_t ttl_sec;\n+  constexpr uint32_t kMaxTtl = (1UL << 26);\n+\n+  if (!absl::SimpleAtoi(ttl_str, &ttl_sec) || ttl_sec == 0 || ttl_sec > kMaxTtl) {\n+    return (*cntx)->SendError(kInvalidIntErr);\n+  }\n+\n+  args.remove_prefix(3);\n+  OpSetParams op_sp;\n+  op_sp.ttl = ttl_sec;\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpSet(t->GetOpArgs(shard), key, args, op_sp);\n+  };\n+\n+  OpResult<uint32_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  if (result) {\n+    (*cntx)->SendLong(*result);\n+  } else {\n+    (*cntx)->SendError(result.status());\n+  }\n+}\n+\n }  // namespace\n \n void HSetFamily::HDel(CmdArgList args, ConnectionContext* cntx) {\n@@ -836,22 +913,6 @@ void HSetFamily::HGetAll(CmdArgList args, ConnectionContext* cntx) {\n   HGetGeneric(args, cntx, GetAllMode::FIELDS | GetAllMode::VALUES);\n }\n \n-void HSetFamily::HGetGeneric(CmdArgList args, ConnectionContext* cntx, uint8_t getall_mask) {\n-  string_view key = ArgS(args, 1);\n-\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpGetAll(t->GetOpArgs(shard), key, getall_mask);\n-  };\n-\n-  OpResult<vector<string>> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    (*cntx)->SendStringArr(absl::Span<const string>{*result});\n-  } else {\n-    (*cntx)->SendError(result.status());\n-  }\n-}\n-\n void HSetFamily::HScan(CmdArgList args, ConnectionContext* cntx) {\n   std::string_view key = ArgS(args, 1);\n   std::string_view token = ArgS(args, 2);\n@@ -905,7 +966,7 @@ void HSetFamily::HSet(CmdArgList args, ConnectionContext* cntx) {\n \n   args.remove_prefix(2);\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpSet(t->GetOpArgs(shard), key, args, false);\n+    return OpSet(t->GetOpArgs(shard), key, args);\n   };\n \n   OpResult<uint32_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n@@ -921,7 +982,7 @@ void HSetFamily::HSetNx(CmdArgList args, ConnectionContext* cntx) {\n \n   args.remove_prefix(2);\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpSet(t->GetOpArgs(shard), key, args, true);\n+    return OpSet(t->GetOpArgs(shard), key, args, OpSetParams{.skip_if_exists = true});\n   };\n \n   OpResult<uint32_t> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n@@ -953,7 +1014,8 @@ void HSetFamily::HRandField(CmdArgList args, ConnectionContext* cntx) {\n \n   auto cb = [&](Transaction* t, EngineShard* shard) -> OpResult<StringVec> {\n     auto& db_slice = shard->db_slice();\n-    auto it_res = db_slice.Find(t->GetDbContext(), key, OBJ_HASH);\n+    DbContext db_context = t->GetDbContext();\n+    auto it_res = db_slice.Find(db_context, key, OBJ_HASH);\n \n     if (!it_res)\n       return it_res.status();\n@@ -1018,6 +1080,7 @@ void HSetFamily::Register(CommandRegistry* registry) {\n             << CI{\"HRANDFIELD\", CO::READONLY, 2, 1, 1, 1}.HFUNC(HRandField)\n             << CI{\"HSCAN\", CO::READONLY, -3, 1, 1, 1}.HFUNC(HScan)\n             << CI{\"HSET\", CO::WRITE | CO::FAST | CO::DENYOOM, -4, 1, 1, 1}.HFUNC(HSet)\n+            << CI{\"HSETEX\", CO::WRITE | CO::FAST | CO::DENYOOM, -5, 1, 1, 1}.SetHandler(HSetEx)\n             << CI{\"HSETNX\", CO::WRITE | CO::DENYOOM | CO::FAST, 4, 1, 1, 1}.HFUNC(HSetNx)\n             << CI{\"HSTRLEN\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(HStrLen)\n             << CI{\"HVALS\", CO::READONLY, 2, 1, 1, 1}.HFUNC(HVals);\ndiff --git a/src/server/hset_family.h b/src/server/hset_family.h\nindex a03e64b49a0a..16495ca6d009 100644\n--- a/src/server/hset_family.h\n+++ b/src/server/hset_family.h\n@@ -27,6 +27,8 @@ class HSetFamily {\n   static StringMap* ConvertToStrMap(uint8_t* lp);\n \n  private:\n+  // TODO: to move it to anonymous namespace in cc file.\n+\n   static void HDel(CmdArgList args, ConnectionContext* cntx);\n   static void HLen(CmdArgList args, ConnectionContext* cntx);\n   static void HExists(CmdArgList args, ConnectionContext* cntx);\n@@ -42,8 +44,6 @@ class HSetFamily {\n   static void HSetNx(CmdArgList args, ConnectionContext* cntx);\n   static void HStrLen(CmdArgList args, ConnectionContext* cntx);\n   static void HRandField(CmdArgList args, ConnectionContext* cntx);\n-\n-  static void HGetGeneric(CmdArgList args, ConnectionContext* cntx, uint8_t getall_mask);\n };\n \n }  // namespace dfly\ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex dc942b63da24..a497ca68892d 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -39,13 +39,6 @@ namespace {\n \n constexpr uint32_t kMaxIntSetEntries = 256;\n \n-// I use relative time from Oct 1, 2022\n-constexpr uint64_t kNowBase = 1664582400ULL;\n-\n-uint32_t TimeNowSecRel(uint64_t now_ms) {\n-  return (now_ms / 1000) - kNowBase;\n-}\n-\n bool IsDenseEncoding(const CompactObj& co) {\n   return co.Encoding() == kEncodingStrMap2;\n }\n@@ -130,7 +123,7 @@ unsigned AddStrSet(const DbContext& db_context, ArgSlice vals, uint32_t ttl_sec,\n \n   if (IsDenseEncoding(*dest)) {\n     StringSet* ss = (StringSet*)dest->RObjPtr();\n-    uint32_t time_now = TimeNowSecRel(db_context.time_now_ms);\n+    uint32_t time_now = MemberTimeSeconds(db_context.time_now_ms);\n \n     ss->set_time(time_now);\n \n@@ -186,7 +179,7 @@ pair<unsigned, bool> RemoveSet(const DbContext& db_context, ArgSlice vals, Compa\n     isempty = (intsetLen(is) == 0);\n     set->SetRObjPtr(is);\n   } else {\n-    return RemoveStrSet(TimeNowSecRel(db_context.time_now_ms), vals, set);\n+    return RemoveStrSet(MemberTimeSeconds(db_context.time_now_ms), vals, set);\n   }\n   return make_pair(removed, isempty);\n }\n@@ -217,7 +210,7 @@ uint64_t ScanStrSet(const DbContext& db_context, const CompactObj& co, uint64_t\n \n   if (IsDenseEncoding(co)) {\n     StringSet* set = (StringSet*)co.RObjPtr();\n-    set->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    set->set_time(MemberTimeSeconds(db_context.time_now_ms));\n \n     do {\n       auto scan_callback = [&](const sds ptr) {\n@@ -263,7 +256,7 @@ uint32_t SetTypeLen(const DbContext& db_context, const SetType& set) {\n \n   if (IsDenseEncoding(set)) {\n     StringSet* ss = (StringSet*)set.first;\n-    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(db_context.time_now_ms));\n     return ss->Size();\n   }\n \n@@ -281,7 +274,7 @@ bool IsInSet(const DbContext& db_context, const SetType& st, int64_t val) {\n \n   if (IsDenseEncoding(st)) {\n     StringSet* ss = (StringSet*)st.first;\n-    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(db_context.time_now_ms));\n     return ss->Contains(str);\n   }\n \n@@ -300,7 +293,7 @@ bool IsInSet(const DbContext& db_context, const SetType& st, string_view member)\n \n   if (IsDenseEncoding(st)) {\n     StringSet* ss = (StringSet*)st.first;\n-    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(db_context.time_now_ms));\n \n     return ss->Contains(member);\n   } else {\n@@ -322,7 +315,7 @@ void DiffStrSet(const DbContext& db_context, const SetType& st,\n                 absl::flat_hash_set<string>* result) {\n   if (IsDenseEncoding(st)) {\n     StringSet* ss = (StringSet*)st.first;\n-    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(db_context.time_now_ms));\n     for (sds ptr : *ss) {\n       result->erase(string_view{ptr, sdslen(ptr)});\n     }\n@@ -342,7 +335,7 @@ void DiffStrSet(const DbContext& db_context, const SetType& st,\n void InterStrSet(const DbContext& db_context, const vector<SetType>& vec, StringVec* result) {\n   if (IsDenseEncoding(vec.front())) {\n     StringSet* ss = (StringSet*)vec.front().first;\n-    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(db_context.time_now_ms));\n     for (const sds ptr : *ss) {\n       std::string_view str{ptr, sdslen(ptr)};\n       size_t j = 1;\n@@ -385,7 +378,7 @@ StringVec PopStrSet(const DbContext& db_context, unsigned count, const SetType&\n \n   if (IsDenseEncoding(st)) {\n     StringSet* ss = (StringSet*)st.first;\n-    ss->set_time(TimeNowSecRel(db_context.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(db_context.time_now_ms));\n \n     // TODO: this loop is inefficient because Pop searches again and again an occupied bucket.\n     for (unsigned i = 0; i < count && !ss->Empty(); ++i) {\n@@ -798,7 +791,7 @@ OpResult<StringVec> OpUnion(const OpArgs& op_args, ArgSlice keys) {\n       PrimeValue& pv = find_res.value()->second;\n       if (IsDenseEncoding(pv)) {\n         StringSet* ss = (StringSet*)pv.RObjPtr();\n-        ss->set_time(TimeNowSecRel(op_args.db_cntx.time_now_ms));\n+        ss->set_time(MemberTimeSeconds(op_args.db_cntx.time_now_ms));\n       }\n       container_utils::IterateSet(pv, [&uniques](container_utils::ContainerEntry ce) {\n         uniques.emplace(ce.ToString());\n@@ -830,7 +823,7 @@ OpResult<StringVec> OpDiff(const OpArgs& op_args, ArgSlice keys) {\n   PrimeValue& pv = find_res.value()->second;\n   if (IsDenseEncoding(pv)) {\n     StringSet* ss = (StringSet*)pv.RObjPtr();\n-    ss->set_time(TimeNowSecRel(op_args.db_cntx.time_now_ms));\n+    ss->set_time(MemberTimeSeconds(op_args.db_cntx.time_now_ms));\n   }\n \n   container_utils::IterateSet(pv, [&uniques](container_utils::ContainerEntry ce) {\n@@ -886,7 +879,7 @@ OpResult<StringVec> OpInter(const Transaction* t, EngineShard* es, bool remove_f\n     PrimeValue& pv = find_res.value()->second;\n     if (IsDenseEncoding(pv)) {\n       StringSet* ss = (StringSet*)pv.RObjPtr();\n-      ss->set_time(TimeNowSecRel(t->GetDbContext().time_now_ms));\n+      ss->set_time(MemberTimeSeconds(t->GetDbContext().time_now_ms));\n     }\n \n     container_utils::IterateSet(find_res.value()->second,\n@@ -971,7 +964,7 @@ OpResult<StringVec> OpPop(const OpArgs& op_args, string_view key, unsigned count\n     PrimeValue& pv = it->second;\n     if (IsDenseEncoding(pv)) {\n       StringSet* ss = (StringSet*)pv.RObjPtr();\n-      ss->set_time(TimeNowSecRel(op_args.db_cntx.time_now_ms));\n+      ss->set_time(MemberTimeSeconds(op_args.db_cntx.time_now_ms));\n     }\n \n     container_utils::IterateSet(it->second, [&result](container_utils::ContainerEntry ce) {\n",
  "test_patch": "diff --git a/src/server/hset_family_test.cc b/src/server/hset_family_test.cc\nindex 0bc48b0cc983..80d0980cac50 100644\n--- a/src/server/hset_family_test.cc\n+++ b/src/server/hset_family_test.cc\n@@ -191,4 +191,16 @@ TEST_F(HSetFamilyTest, HRandFloat) {\n   Run({\"hrandfield\", \"k\"});\n }\n \n+TEST_F(HSetFamilyTest, HSetEx) {\n+  TEST_current_time_ms = kMemberExpiryBase * 1000;  // to reset to test time.\n+\n+  EXPECT_THAT(Run({\"HSETEX\", \"k\", \"1\", \"f\", \"v\"}), IntArg(1));\n+\n+  AdvanceTime(500);\n+  EXPECT_THAT(Run({\"HGET\", \"k\", \"f\"}), \"v\");\n+\n+  AdvanceTime(500);\n+  EXPECT_THAT(Run({\"HGET\", \"k\", \"f\"}), ArgType(RespExpr::NIL));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "TTL for messages in HSET\n**Did you search GitHub Issues and GitHub Discussions First?**\r\nYes.\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\n#335 allows to set TTL for set members. This should also be possible for HSET\r\n\r\n**Describe the solution you'd like**\r\nImplement HSADDEX similar to SADDEX\r\n\n",
  "hints_text": "Ok, can you provide some context about how you want to use this feature?\r\nAlso, feel free to join our discord server and ping me directly\nHello, thank you a lot for the fast response.\r\n\r\nOne reason is consistency ^^ Since it it possible for set members, why shouldn't it be possible for hash members?\r\n\r\nWe are currently using KeyDB as cache for our IoT platform which seems to be a dead end.  So I look around for a good replacement and dragonfly looks very promising.\r\n\r\nWe use HSETs as cache for IoT gateways The Key is the gateway ID. The hash key is the ID of a device received by that gateway. The hash value contains a JSON with metadata about the device. That way I can easily cache which gateway received which device + metadata. I use \"EXPIREMEMBER\" of keydb to evict devices from that cache that have not be seen for a while.\r\n\r\nMaybe there are alternative approaches which looks less elegant to me:\r\n\r\n* Using keys of \"Gateway + Device Id\" for each entry - requires a key scan to retrieve the data for one gateway\r\n* Put a timestamp into the hash value and evict programmatically - would be an ugly workaround but would work.\r\n\r\nKind regards,\r\nMichael.\r\n\r\n\r\n\nHi Michael,\r\nwhy do you consider keydb is a dead end? Is it because of its maintenance prospects, or do you have actual problems with it in production?\r\nI am asking to understand what kind of value a multi-threaded server provides for your use-case. Is it latency, throughput, complexity, cost, something else?\r\n\r\nregarding your use-case - are gateway ids relatively constant, or are they also added and removed constantly? \n> regarding your use-case - are gateway ids relatively constant, or are they also added and removed constantly?\r\n\r\nrelatively constant. while a gateway lasts a few years, devices may be added/removed every few months. Even faster if a gateway is moved around.\r\n\r\n> why do you consider keydb is a dead end? Is it because of its maintenance prospects, or do you have actual problems with it in production?\r\n\r\nMainly because of https://github.com/Snapchat/KeyDB/issues/470 and https://github.com/Snapchat/KeyDB/issues/494 - The last \"stable\" release is a year old. Plus a lot of open \"priority 1\" issues affecting stability and performance.\r\n\r\nIn production we have a lot of outages that my colleague has tracked down to already known, still open issues. ATM we have (hopefully) mitigated the main issue (cluster out of sync, cannot re-sync). But I'm looking around for a replacement.\r\n\r\n\nMichael, I can create a similar feature to SADDEX called HSETEX, but I would appreciate it if you could provide your contact information. This way, I can receive feedback on how the feature is working and make any necessary improvements. We can communicate through Discord, Slack, or email. If it's ok by you, please send me an email to roman at  dragonflydb.io \r\nor DM me on discord (linked from the README).",
  "created_at": "2023-02-17T18:23:17Z",
  "modified_files": [
    "src/server/common.h",
    "src/server/hset_family.cc",
    "src/server/hset_family.h",
    "src/server/set_family.cc"
  ],
  "modified_test_files": [
    "src/server/hset_family_test.cc"
  ]
}