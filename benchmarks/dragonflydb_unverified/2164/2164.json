{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2164,
  "instance_id": "dragonflydb__dragonfly-2164",
  "issue_numbers": [
    "2147"
  ],
  "base_commit": "09415c4f577887d744866a61b55af8f35612d66b",
  "patch": "diff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nold mode 100644\nnew mode 100755\nindex 25cbe1a6afaa..77dd3620929b\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -1058,6 +1058,41 @@ struct SetOpArgs {\n   bool with_scores = false;\n };\n \n+void HandleOpStatus(ConnectionContext* cntx, OpStatus op_status) {\n+  switch (op_status) {\n+    case OpStatus::INVALID_FLOAT:\n+      return (*cntx)->SendError(\"weight value is not a float\", kSyntaxErrType);\n+    default:\n+      return (*cntx)->SendError(op_status);\n+  }\n+}\n+\n+OpResult<ScoredMap> IntersectResults(vector<OpResult<ScoredMap>>& results, AggType agg_type) {\n+  ScoredMap result;\n+  for (auto& op_res : results) {\n+    if (op_res.status() == OpStatus::SKIPPED)\n+      continue;\n+\n+    if (!op_res) {\n+      return op_res.status();\n+    }\n+\n+    if (op_res->empty()) {\n+      return ScoredMap{};\n+    }\n+\n+    if (result.empty()) {\n+      result.swap(op_res.value());\n+    } else {\n+      InterScoredMap(&result, &op_res.value(), agg_type);\n+    }\n+\n+    if (result.empty())\n+      break;\n+  }\n+  return result;\n+}\n+\n OpResult<void> FillAggType(string_view agg, SetOpArgs* op_args) {\n   if (agg == \"SUM\") {\n     op_args->agg_type = AggType::SUM;\n@@ -1161,12 +1196,7 @@ OpResult<SetOpArgs> ParseSetOpArgs(CmdArgList args, bool store) {\n void ZUnionFamilyInternal(CmdArgList args, bool store, ConnectionContext* cntx) {\n   OpResult<SetOpArgs> op_args_res = ParseSetOpArgs(args, store);\n   if (!op_args_res) {\n-    switch (op_args_res.status()) {\n-      case OpStatus::INVALID_FLOAT:\n-        return (*cntx)->SendError(\"weight value is not a float\", kSyntaxErrType);\n-      default:\n-        return (*cntx)->SendError(op_args_res.status());\n-    }\n+    return HandleOpStatus(cntx, op_args_res.status());\n   }\n   const auto& op_args = *op_args_res;\n   if (op_args.num_keys == 0) {\n@@ -1969,12 +1999,7 @@ void ZSetFamily::ZInterStore(CmdArgList args, ConnectionContext* cntx) {\n   OpResult<SetOpArgs> op_args_res = ParseSetOpArgs(args, true);\n \n   if (!op_args_res) {\n-    switch (op_args_res.status()) {\n-      case OpStatus::INVALID_FLOAT:\n-        return (*cntx)->SendError(\"weight value is not a float\", kSyntaxErrType);\n-      default:\n-        return (*cntx)->SendError(op_args_res.status());\n-    }\n+    return HandleOpStatus(cntx, op_args_res.status());\n   }\n   const auto& op_args = *op_args_res;\n   if (op_args.num_keys == 0) {\n@@ -1991,28 +2016,14 @@ void ZSetFamily::ZInterStore(CmdArgList args, ConnectionContext* cntx) {\n   cntx->transaction->Schedule();\n   cntx->transaction->Execute(std::move(cb), false);\n \n-  ScoredMap result;\n-  for (auto& op_res : maps) {\n-    if (op_res.status() == OpStatus::SKIPPED)\n-      continue;\n-\n-    if (!op_res)\n-      return (*cntx)->SendError(op_res.status());\n-\n-    if (result.empty()) {\n-      result.swap(op_res.value());\n-    } else {\n-      InterScoredMap(&result, &op_res.value(), op_args.agg_type);\n-    }\n-\n-    if (result.empty())\n-      break;\n-  }\n+  OpResult<ScoredMap> result = IntersectResults(maps, op_args.agg_type);\n+  if (!result)\n+    return (*cntx)->SendError(result.status());\n \n   ShardId dest_shard = Shard(dest_key, maps.size());\n   AddResult add_result;\n   vector<ScoredMemberView> smvec;\n-  for (const auto& elem : result) {\n+  for (const auto& elem : result.value()) {\n     smvec.emplace_back(elem.second, elem.first);\n   }\n \n@@ -2030,6 +2041,44 @@ void ZSetFamily::ZInterStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(smvec.size());\n }\n \n+void ZSetFamily::ZInter(CmdArgList args, ConnectionContext* cntx) {\n+  OpResult<SetOpArgs> op_args_res = ParseSetOpArgs(args, false);\n+\n+  if (!op_args_res) {\n+    return HandleOpStatus(cntx, op_args_res.status());\n+  }\n+  const auto& op_args = *op_args_res;\n+  if (op_args.num_keys == 0) {\n+    return SendAtLeastOneKeyError(cntx);\n+  }\n+\n+  vector<OpResult<ScoredMap>> maps(shard_set->size(), OpStatus::SKIPPED);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    maps[shard->shard_id()] = OpInter(shard, t, \"\", op_args.agg_type, op_args.weights, false);\n+    return OpStatus::OK;\n+  };\n+\n+  cntx->transaction->ScheduleSingleHop(std::move(cb));\n+\n+  OpResult<ScoredMap> result = IntersectResults(maps, op_args.agg_type);\n+  if (!result)\n+    return (*cntx)->SendError(result.status());\n+\n+  std::vector<std::pair<std::string, double>> scored_array;\n+  scored_array.reserve(result.value().size());\n+  for (const auto& elem : result.value()) {\n+    scored_array.emplace_back(elem.first, elem.second);\n+  }\n+\n+  std::sort(scored_array.begin(), scored_array.end(),\n+            [](const std::pair<std::string, double>& a, const std::pair<std::string, double>& b) {\n+              return a.second < b.second;\n+            });\n+\n+  (*cntx)->SendScoredArray(scored_array, op_args_res->with_scores);\n+}\n+\n void ZSetFamily::ZInterCard(CmdArgList args, ConnectionContext* cntx) {\n   unsigned num_keys;\n   if (!absl::SimpleAtoi(ArgS(args, 0), &num_keys)) {\n@@ -2054,28 +2103,14 @@ void ZSetFamily::ZInterCard(CmdArgList args, ConnectionContext* cntx) {\n \n   cntx->transaction->ScheduleSingleHop(std::move(cb));\n \n-  ScoredMap result;\n-  for (auto& op_res : maps) {\n-    if (op_res.status() == OpStatus::SKIPPED)\n-      continue;\n-\n-    if (!op_res)\n-      return (*cntx)->SendError(op_res.status());\n-\n-    if (result.empty()) {\n-      result.swap(op_res.value());\n-    } else {\n-      InterScoredMap(&result, &op_res.value(), AggType::NOOP);\n-    }\n-\n-    if (result.empty())\n-      break;\n-  }\n+  OpResult<ScoredMap> result = IntersectResults(maps, AggType::NOOP);\n+  if (!result)\n+    return (*cntx)->SendError(result.status());\n \n-  if (0 < limit && limit < result.size()) {\n+  if (0 < limit && limit < result.value().size()) {\n     return (*cntx)->SendLong(limit);\n   }\n-  (*cntx)->SendLong(result.size());\n+  (*cntx)->SendLong(result.value().size());\n }\n \n void ZSetFamily::ZPopMax(CmdArgList args, ConnectionContext* cntx) {\n@@ -3066,6 +3101,7 @@ constexpr uint32_t kZCount = READ | SORTEDSET | FAST;\n constexpr uint32_t kZDiff = READ | SORTEDSET | SLOW;\n constexpr uint32_t kZIncrBy = WRITE | SORTEDSET | FAST;\n constexpr uint32_t kZInterStore = WRITE | SORTEDSET | SLOW;\n+constexpr uint32_t kZInter = READ | SORTEDSET | SLOW;\n constexpr uint32_t kZInterCard = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZLexCount = READ | SORTEDSET | FAST;\n constexpr uint32_t kZPopMax = WRITE | SORTEDSET | FAST;\n@@ -3112,6 +3148,7 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n       << CI{\"ZDIFF\", CO::READONLY | CO::VARIADIC_KEYS, -3, 2, 2, acl::kZDiff}.HFUNC(ZDiff)\n       << CI{\"ZINCRBY\", CO::FAST | CO::WRITE, 4, 1, 1, acl::kZIncrBy}.HFUNC(ZIncrBy)\n       << CI{\"ZINTERSTORE\", kStoreMask, -4, 3, 3, acl::kZInterStore}.HFUNC(ZInterStore)\n+      << CI{\"ZINTER\", kStoreMask, -3, 2, 2, acl::kZInter}.HFUNC(ZInter)\n       << CI{\"ZINTERCARD\",    CO::READONLY | CO::REVERSE_MAPPING | CO::VARIADIC_KEYS, -3, 2, 2,\n             acl::kZInterCard}\n              .HFUNC(ZInterCard)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex 844994731e90..33aefc2473ea 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -64,6 +64,7 @@ class ZSetFamily {\n   static void ZDiff(CmdArgList args, ConnectionContext* cntx);\n   static void ZIncrBy(CmdArgList args, ConnectionContext* cntx);\n   static void ZInterStore(CmdArgList args, ConnectionContext* cntx);\n+  static void ZInter(CmdArgList args, ConnectionContext* cntx);\n   static void ZInterCard(CmdArgList args, ConnectionContext* cntx);\n   static void ZLexCount(CmdArgList args, ConnectionContext* cntx);\n   static void ZPopMax(CmdArgList args, ConnectionContext* cntx);\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex f1377268acc6..8bdd05a990ec 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -523,6 +523,23 @@ TEST_F(ZSetFamilyTest, ZInterStore) {\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"b\", \"3\"));\n }\n \n+TEST_F(ZSetFamilyTest, ZInter) {\n+  EXPECT_EQ(2, CheckedInt({\"zadd\", \"z1\", \"1\", \"one\", \"2\", \"two\"}));\n+  EXPECT_EQ(3, CheckedInt({\"zadd\", \"z2\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\"}));\n+  RespExpr resp;\n+\n+  resp = Run({\"zinter\", \"2\", \"z1\", \"z2\"});\n+  EXPECT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"one\", \"two\"));\n+\n+  EXPECT_EQ(3, CheckedInt({\"zadd\", \"z3\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\"}));\n+  EXPECT_EQ(3, CheckedInt({\"zadd\", \"z4\", \"4\", \"four\", \"5\", \"five\", \"6\", \"six\"}));\n+  EXPECT_EQ(1, CheckedInt({\"zadd\", \"z5\", \"6\", \"six\"}));\n+\n+  resp = Run({\"zinter\", \"3\", \"z3\", \"z4\", \"z5\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+}\n+\n TEST_F(ZSetFamilyTest, ZInterCard) {\n   EXPECT_EQ(3, CheckedInt({\"zadd\", \"z1\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\"}));\n   EXPECT_EQ(3, CheckedInt({\"zadd\", \"z2\", \"2\", \"b\", \"3\", \"c\", \"4\", \"d\"}));\n",
  "problem_statement": "ZINTER command is absent\n\n",
  "hints_text": "Hi, I'd like to work on this!\ncool, send a pr :)\r\nwe usually do not assign, but feel free to start working on it.  ",
  "created_at": "2023-11-12T16:14:26Z",
  "modified_files": [
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}