{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2584,
  "instance_id": "dragonflydb__dragonfly-2584",
  "issue_numbers": [
    "2661",
    "2576"
  ],
  "base_commit": "91c299b33e1a9ca975cea0fa5bb2dbb25cb214ae",
  "patch": "diff --git a/src/facade/dragonfly_listener.cc b/src/facade/dragonfly_listener.cc\nindex 1981c4846bb3..04456e82ac21 100644\n--- a/src/facade/dragonfly_listener.cc\n+++ b/src/facade/dragonfly_listener.cc\n@@ -392,6 +392,7 @@ DispatchTracker::DispatchTracker(absl::Span<facade::Listener* const> listeners,\n       issuer_{issuer},\n       ignore_paused_{ignore_paused},\n       ignore_blocked_{ignore_blocked} {\n+  bc_ = make_unique<util::fb2::BlockingCounter>(0);\n }\n \n void DispatchTracker::TrackOnThread() {\n@@ -400,7 +401,15 @@ void DispatchTracker::TrackOnThread() {\n }\n \n bool DispatchTracker::Wait(absl::Duration duration) {\n-  return bc_.WaitFor(absl::ToChronoMilliseconds(duration));\n+  bool res = bc_->WaitFor(absl::ToChronoMilliseconds(duration));\n+  if (!res && ignore_blocked_) {\n+    // We track all connections again because a connection might became blocked between the time\n+    // we call tracking the last time.\n+    bc_.reset(new util::fb2::BlockingCounter(0));\n+    TrackAll();\n+    res = bc_->WaitFor(absl::ToChronoMilliseconds(duration));\n+  }\n+  return res;\n }\n \n void DispatchTracker::TrackAll() {\n@@ -410,7 +419,7 @@ void DispatchTracker::TrackAll() {\n \n void DispatchTracker::Handle(unsigned thread_index, util::Connection* conn) {\n   if (auto* fconn = static_cast<facade::Connection*>(conn); fconn != issuer_)\n-    fconn->SendCheckpoint(bc_, ignore_paused_, ignore_blocked_);\n+    fconn->SendCheckpoint(*bc_, ignore_paused_, ignore_blocked_);\n }\n \n }  // namespace facade\ndiff --git a/src/facade/dragonfly_listener.h b/src/facade/dragonfly_listener.h\nindex e6cc751d1abd..b78b29699660 100644\n--- a/src/facade/dragonfly_listener.h\n+++ b/src/facade/dragonfly_listener.h\n@@ -103,7 +103,7 @@ class DispatchTracker {\n \n   std::vector<facade::Listener*> listeners_;\n   facade::Connection* issuer_;\n-  util::fb2::BlockingCounter bc_{0};\n+  std::unique_ptr<util::fb2::BlockingCounter> bc_;\n   bool ignore_paused_;\n   bool ignore_blocked_;\n };\ndiff --git a/src/server/command_registry.h b/src/server/command_registry.h\nindex 8b42e65f584e..7eb6f12c48c2 100644\n--- a/src/server/command_registry.h\n+++ b/src/server/command_registry.h\n@@ -107,6 +107,10 @@ class CommandId : public facade::CommandId {\n     return opt_mask_ & CO::WRITE;\n   }\n \n+  bool IsBlocking() const {\n+    return opt_mask_ & CO::BLOCKING;\n+  }\n+\n   static const char* OptName(CO::CommandOpt fl);\n \n   CommandId&& SetHandler(Handler f) && {\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 0629b49a6a2b..06f81cdadd44 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -1327,7 +1327,9 @@ size_t Service::DispatchManyCommands(absl::Span<CmdArgList> args_list,\n     // paired with shardlocal eval\n     const bool is_eval = CO::IsEvalKind(ArgS(args, 0));\n \n-    if (!is_multi && !is_eval && cid != nullptr) {\n+    const bool is_blocking = cid != nullptr && cid->IsBlocking();\n+\n+    if (!is_multi && !is_eval && !is_blocking && cid != nullptr) {\n       stored_cmds.reserve(args_list.size());\n       stored_cmds.emplace_back(cid, tail_args);\n       continue;\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex b3f6fdd1d497..6ea66553392d 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -559,9 +559,13 @@ string_view GetRedisMode() {\n std::optional<fb2::Fiber> Pause(absl::Span<facade::Listener* const> listeners,\n                                 facade::Connection* conn, ClientPause pause_state,\n                                 std::function<bool()> is_pause_in_progress) {\n-  // Set global pause state and track commands that are running when the pause state is flipped.\n-  // Exlude already paused commands from the busy count.\n-  DispatchTracker tracker{listeners, conn, true /* ignore paused commands */};\n+  // Track connections and set pause state to be able to wait untill all running transactions read\n+  // the new pause state. Exlude already paused commands from the busy count. Exlude tracking\n+  // blocked connections because: a) If the connection is blocked it is puased. b) We read pause\n+  // state after waking from blocking so if the trasaction was waken by another running\n+  //    command that did not pause on the new state yet we will pause after waking up.\n+  DispatchTracker tracker{listeners, conn, true /* ignore paused commands */,\n+                          true /*ignore blocking*/};\n   shard_set->pool()->Await([&tracker, pause_state](util::ProactorBase* pb) {\n     // Commands don't suspend before checking the pause state, so\n     // it's impossible to deadlock on waiting for a command that will be paused.\n@@ -569,7 +573,6 @@ std::optional<fb2::Fiber> Pause(absl::Span<facade::Listener* const> listeners,\n     ServerState::tlocal()->SetPauseState(pause_state, true);\n   });\n \n-  // TODO handle blocking commands\n   // Wait for all busy commands to finish running before replying to guarantee\n   // that no more (write) operations will occur.\n   const absl::Duration kDispatchTimeout = absl::Seconds(1);\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 59c47b931f06..3ce72ed62b43 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1349,7 +1349,7 @@ OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_p\n   auto* stats = ServerState::tl_connection_stats();\n   ++stats->num_blocked_clients;\n   DVLOG(1) << \"WaitOnWatch wait for \" << tp << \" \" << DebugId();\n-\n+  // TBD set connection blocking state\n   // Wait for the blocking barrier to be closed.\n   // Note: It might return immediately if another thread already notified us.\n   cv_status status = blocking_barrier_.Wait(tp);\n@@ -1357,6 +1357,9 @@ OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_p\n   DVLOG(1) << \"WaitOnWatch done \" << int(status) << \" \" << DebugId();\n   --stats->num_blocked_clients;\n \n+  // TBD set connection pause state\n+  ServerState::tlocal()->AwaitPauseState(true);  // blocking are always write commands\n+\n   OpStatus result = OpStatus::OK;\n   if (status == cv_status::timeout) {\n     result = OpStatus::TIMED_OUT;\n",
  "test_patch": "diff --git a/tests/dragonfly/connection_test.py b/tests/dragonfly/connection_test.py\nindex 601e5b064cbd..33389e116f00 100755\n--- a/tests/dragonfly/connection_test.py\n+++ b/tests/dragonfly/connection_test.py\n@@ -1,4 +1,5 @@\n import random\n+import string\n import pytest\n import asyncio\n import time\n@@ -737,3 +738,55 @@ async def do_write():\n     await asyncio.sleep(0.0)\n     assert p3.done()\n     await p3\n+\n+\n+@pytest.mark.asyncio\n+async def test_blocking_command_client_pause(async_client: aioredis.Redis):\n+    \"\"\"\n+    1. Check client pause success when blocking transaction is running\n+    2. lpush is paused after running client puase\n+    3. once puased is finished lpush will run and blpop will pop the pushed value\n+    \"\"\"\n+\n+    async def blocking_command():\n+        res = await async_client.execute_command(\"blpop key 2\")\n+        assert res == [\"key\", \"value\"]\n+\n+    async def lpush_command():\n+        await async_client.execute_command(\"lpush key value\")\n+\n+    blocking = asyncio.create_task(blocking_command())\n+    await asyncio.sleep(0.1)\n+\n+    res = await async_client.execute_command(\"client pause 1000\")\n+    assert res == \"OK\"\n+\n+    lpush = asyncio.create_task(lpush_command())\n+    assert not lpush.done()\n+\n+    await lpush\n+    await blocking\n+\n+\n+@pytest.mark.asyncio\n+async def test_multiple_blocking_commands_client_pause(async_client: aioredis.Redis):\n+    \"\"\"\n+    Check running client pause command simultaneously with running multiple blocking command\n+    from multiple connections\n+    \"\"\"\n+\n+    async def just_blpop():\n+        key = \"\".join(random.choices(string.ascii_letters, k=3))\n+        await async_client.execute_command(f\"blpop {key} 2\")\n+\n+    async def client_pause():\n+        res = await async_client.execute_command(\"client pause 1000\")\n+        assert res == \"OK\"\n+\n+    tasks = [just_blpop() for _ in range(20)]\n+    tasks.append(client_pause())\n+\n+    all = asyncio.gather(*tasks)\n+\n+    assert not all.done()\n+    await all\n",
  "problem_statement": "Bug: do not squash blocking commands in Service::DispatchManyCommands\nToday we squash  blocking commands in Service::DispatchManyCommands and return error on the squeshed command as blocking commands can not run as part of multi transaction\nsupport client pause with blocking command\nToday when blocking command is running we are getting timeout on pausing clients\n",
  "hints_text": "\n",
  "created_at": "2024-02-13T13:03:02Z",
  "modified_files": [
    "src/facade/dragonfly_listener.cc",
    "src/facade/dragonfly_listener.h",
    "src/server/command_registry.h",
    "src/server/main_service.cc",
    "src/server/server_family.cc",
    "src/server/transaction.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/connection_test.py"
  ]
}