{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 378,
  "instance_id": "dragonflydb__dragonfly-378",
  "issue_numbers": [
    "359",
    "358"
  ],
  "base_commit": "28706715dcc281dbb977a8cd7f7ca73cca530bf9",
  "patch": "diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md\nindex cfa4cc78a038..e8f1c44552c3 100644\n--- a/CONTRIBUTORS.md\n+++ b/CONTRIBUTORS.md\n@@ -3,6 +3,7 @@\n * **[Amir Alperin](https://github.com/iko1)**\n * **[Philipp Born](https://github.com/tamcore)**\n   * Helm Chart\n+* **[Redha Lhimeur](https://github.com/redhal)**\n * **[Braydn Moore](https://github.com/braydnm)**\n * **[Logan Raarup](https://github.com/logandk)**\n * **[Ryan Russell](https://github.com/ryanrussell)**\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 2d66bd7c4a07..b55d234deeb4 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -125,6 +125,7 @@ OpResult<PrimeIterator> FindZEntry(const ZParams& zparams, const OpArgs& op_args\n enum class Action {\n   RANGE = 0,\n   REMOVE = 1,\n+  POP = 2\n };\n \n class IntervalVisitor {\n@@ -139,6 +140,8 @@ class IntervalVisitor {\n \n   void operator()(const ZSetFamily::LexInterval& li);\n \n+  void operator()(ZSetFamily::TopNScored sc);\n+\n   ZSetFamily::ScoredArray PopResult() {\n     return std::move(result_);\n   }\n@@ -154,6 +157,9 @@ class IntervalVisitor {\n   void ExtractListPack(const zlexrangespec& range);\n   void ExtractSkipList(const zlexrangespec& range);\n \n+  void PopListPack(ZSetFamily::TopNScored sc);\n+  void PopSkipList(ZSetFamily::TopNScored sc);\n+\n   void ActionRange(unsigned start, unsigned end);  // rank\n   void ActionRange(const zrangespec& range);       // score\n   void ActionRange(const zlexrangespec& range);    // lex\n@@ -162,6 +168,8 @@ class IntervalVisitor {\n   void ActionRem(const zrangespec& range);       // score\n   void ActionRem(const zlexrangespec& range);    // lex\n \n+  void ActionPop(ZSetFamily::TopNScored sc);\n+\n   void Next(uint8_t* zl, uint8_t** eptr, uint8_t** sptr) const {\n     if (params_.reverse) {\n       zzlPrev(zl, eptr, sptr);\n@@ -214,6 +222,8 @@ void IntervalVisitor::operator()(const ZSetFamily::IndexInterval& ii) {\n     case Action::REMOVE:\n       ActionRem(start, end);\n       break;\n+    default:\n+      break;\n   }\n }\n \n@@ -227,6 +237,8 @@ void IntervalVisitor::operator()(const ZSetFamily::ScoreInterval& si) {\n     case Action::REMOVE:\n       ActionRem(range);\n       break;\n+    default:\n+      break;\n   }\n }\n \n@@ -240,10 +252,22 @@ void IntervalVisitor::operator()(const ZSetFamily::LexInterval& li) {\n     case Action::REMOVE:\n       ActionRem(range);\n       break;\n+    default:\n+      break;\n   }\n   zslFreeLexRange(&range);\n }\n \n+void IntervalVisitor::operator()(ZSetFamily::TopNScored sc) {\n+  switch (action_) {\n+    case Action::POP:\n+      ActionPop(sc);\n+      break;\n+    default:\n+      break;\n+  }\n+}\n+\n void IntervalVisitor::ActionRange(unsigned start, unsigned end) {\n   container_utils::IterateSortedSet(zobj_, [this](container_utils::ContainerEntry ce, double score){\n     result_.emplace_back(ce.ToString(), score);\n@@ -311,6 +335,15 @@ void IntervalVisitor::ActionRem(const zlexrangespec& range) {\n   }\n }\n \n+void IntervalVisitor::ActionPop(ZSetFamily::TopNScored sc) {\n+  if (zobj_->encoding == OBJ_ENCODING_LISTPACK) {\n+    PopListPack(sc);\n+  } else {\n+    CHECK_EQ(zobj_->encoding, OBJ_ENCODING_SKIPLIST);\n+    PopSkipList(sc);\n+  }\n+}\n+\n void IntervalVisitor::ExtractListPack(const zrangespec& range) {\n   uint8_t* zl = (uint8_t*)zobj_->ptr;\n   uint8_t *eptr, *sptr;\n@@ -472,6 +505,67 @@ void IntervalVisitor::ExtractSkipList(const zlexrangespec& range) {\n   }\n }\n \n+void IntervalVisitor::PopListPack(ZSetFamily::TopNScored sc) {\n+  uint8_t* zl = (uint8_t*)zobj_->ptr;\n+  uint8_t *eptr, *sptr;\n+  uint8_t* vstr;\n+  unsigned int vlen = 0;\n+  long long vlong = 0;\n+\n+  if (params_.reverse) {\n+    eptr = lpSeek(zl,-2);\n+  } else {\n+    eptr = lpSeek(zl,0);\n+  }\n+\n+  /* Get score pointer for the first element. */\n+  if (eptr)\n+    sptr = lpNext(zl, eptr);\n+\n+  /* First we get the entries */\n+  unsigned int num = sc;\n+  while (eptr && num--) {\n+    double score = zzlGetScore(sptr);\n+    vstr = lpGetValue(eptr, &vlen, &vlong);\n+    AddResult(vstr, vlen, vlong, score);\n+\n+    /* Move to next node */\n+    Next(zl, &eptr, &sptr);\n+  }\n+\n+  int start = 0;\n+  if (params_.reverse) {\n+    /* If the number of elements to delete is greater than the listpack length,\n+     * we set the start to 0 because lpseek fails to search beyond length in reverse */\n+    start = (2*sc > lpLength(zl)) ? 0 : -2*sc;\n+  }\n+\n+  /* We can finally delete the elements */\n+  zobj_->ptr = lpDeleteRange(zl, start, 2*sc);\n+}\n+\n+void IntervalVisitor::PopSkipList(ZSetFamily::TopNScored sc) {\n+  zset* zs = (zset*)zobj_->ptr;\n+  zskiplist* zsl = zs->zsl;\n+  zskiplistNode* ln;\n+\n+  /* We start from the header, or the tail if reversed. */\n+  if (params_.reverse) {\n+    ln = zsl->tail;\n+  } else {\n+    ln = zsl->header;\n+  }\n+\n+  while (ln && sc--) {\n+    result_.emplace_back(string{ln->ele, sdslen(ln->ele)}, ln->score);\n+\n+    /* we can delete the element now */\n+    zsetDel(zobj_, ln->ele);\n+\n+    ln = Next(ln);\n+  }\n+}\n+\n void IntervalVisitor::AddResult(const uint8_t* vstr, unsigned vlen, long long vlong, double score) {\n   if (vstr == NULL) {\n     result_.emplace_back(absl::StrCat(vlong), score);\n@@ -1078,6 +1172,14 @@ void ZSetFamily::ZInterStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(smvec.size());\n }\n \n+void ZSetFamily::ZPopMax(CmdArgList args, ConnectionContext* cntx) {\n+  ZPopMinMax(std::move(args), true, cntx);\n+}\n+\n+void ZSetFamily::ZPopMin(CmdArgList args, ConnectionContext* cntx) {\n+  ZPopMinMax(std::move(args), false, cntx);\n+}\n+\n void ZSetFamily::ZLexCount(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n \n@@ -1532,6 +1634,30 @@ bool ZSetFamily::ParseRangeByScoreParams(CmdArgList args, RangeParams* params) {\n   return true;\n }\n \n+void ZSetFamily::ZPopMinMax(CmdArgList args, bool reverse, ConnectionContext* cntx) {\n+  string_view key = ArgS(args, 1);\n+  string_view count = ArgS(args, 2);\n+\n+  RangeParams range_params;\n+  range_params.reverse = reverse;\n+  ZRangeSpec range_spec;\n+  range_spec.params = range_params;\n+  TopNScored sc;\n+\n+  if (!SimpleAtoi(count, &sc)) {\n+    return (*cntx)->SendError(kUintErr);\n+  }\n+\n+  range_spec.interval = sc;\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpPopCount(range_spec, t->GetOpArgs(shard), key);\n+  };\n+\n+  OpResult<ScoredArray> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  OutputScoredArrayResult(result, range_params, cntx);\n+}\n+\n OpResult<StringVec> ZSetFamily::OpScan(const OpArgs& op_args, std::string_view key,\n                                        uint64_t* cursor) {\n   OpResult<PrimeIterator> find_res = op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_ZSET);\n@@ -1658,6 +1784,30 @@ OpResult<ZSetFamily::MScoreResponse> ZSetFamily::OpMScore(const OpArgs& op_args,\n   return scores;\n }\n \n+auto ZSetFamily::OpPopCount(const ZRangeSpec& range_spec, const OpArgs& op_args, string_view key) -> OpResult<ScoredArray> {\n+  auto& db_slice = op_args.shard->db_slice();\n+  OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_cntx, key, OBJ_ZSET);\n+  if (!res_it)\n+    return res_it.status();\n+\n+  db_slice.PreUpdate(op_args.db_cntx.db_index, *res_it);\n+\n+  robj* zobj = res_it.value()->second.AsRObj();\n+\n+  IntervalVisitor iv{Action::POP, range_spec.params, zobj};\n+  std::visit(iv, range_spec.interval);\n+\n+  res_it.value()->second.SyncRObj();\n+  db_slice.PostUpdate(op_args.db_cntx.db_index, *res_it, key);\n+\n+  auto zlen = zsetLength(zobj);\n+  if (zlen == 0) {\n+    CHECK(op_args.shard->db_slice().Del(op_args.db_cntx.db_index, res_it.value()));\n+  }\n+\n+  return iv.PopResult();\n+}\n+\n auto ZSetFamily::OpRange(const ZRangeSpec& range_spec, const OpArgs& op_args, string_view key)\n     -> OpResult<ScoredArray> {\n   OpResult<PrimeIterator> res_it = op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_ZSET);\n@@ -1857,6 +2007,8 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n             << CI{\"ZINCRBY\", CO::FAST | CO::WRITE | CO::DENYOOM, 4, 1, 1, 1}.HFUNC(ZIncrBy)\n             << CI{\"ZINTERSTORE\", kUnionMask, -4, 3, 3, 1}.HFUNC(ZInterStore)\n             << CI{\"ZLEXCOUNT\", CO::READONLY, 4, 1, 1, 1}.HFUNC(ZLexCount)\n+            << CI{\"ZPOPMAX\", CO::READONLY, 3, 1, 1, 1}.HFUNC(ZPopMax)\n+            << CI{\"ZPOPMIN\", CO::READONLY, 3, 1, 1, 1}.HFUNC(ZPopMin)\n             << CI{\"ZREM\", CO::FAST | CO::WRITE, -3, 1, 1, 1}.HFUNC(ZRem)\n             << CI{\"ZRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRange)\n             << CI{\"ZRANK\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZRank)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex 9ee85777bae5..b39ad6bfb674 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -34,6 +34,8 @@ class ZSetFamily {\n \n   using LexInterval = std::pair<LexBound, LexBound>;\n \n+  using TopNScored = uint32_t;\n+\n   struct RangeParams {\n     uint32_t offset = 0;\n     uint32_t limit = UINT32_MAX;\n@@ -42,7 +44,7 @@ class ZSetFamily {\n   };\n \n   struct ZRangeSpec {\n-    std::variant<IndexInterval, ScoreInterval, LexInterval> interval;\n+    std::variant<IndexInterval, ScoreInterval, LexInterval, TopNScored> interval;\n     RangeParams params;\n   };\n \n@@ -58,6 +60,8 @@ class ZSetFamily {\n   static void ZIncrBy(CmdArgList args, ConnectionContext* cntx);\n   static void ZInterStore(CmdArgList args, ConnectionContext* cntx);\n   static void ZLexCount(CmdArgList args, ConnectionContext* cntx);\n+  static void ZPopMax(CmdArgList args, ConnectionContext* cntx);\n+  static void ZPopMin(CmdArgList args, ConnectionContext* cntx);\n   static void ZRange(CmdArgList args, ConnectionContext* cntx);\n   static void ZRank(CmdArgList args, ConnectionContext* cntx);\n   static void ZRem(CmdArgList args, ConnectionContext* cntx);\n@@ -84,7 +88,7 @@ class ZSetFamily {\n   static void ZRangeGeneric(CmdArgList args, bool reverse, ConnectionContext* cntx);\n   static void ZRankGeneric(CmdArgList args, bool reverse, ConnectionContext* cntx);\n   static bool ParseRangeByScoreParams(CmdArgList args, RangeParams* params);\n-\n+  static void ZPopMinMax(CmdArgList args, bool reverse, ConnectionContext* cntx);\n   static OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t* cursor);\n \n   static OpResult<unsigned> OpRem(const OpArgs& op_args, std::string_view key, ArgSlice members);\n@@ -93,6 +97,8 @@ class ZSetFamily {\n   using MScoreResponse = std::vector<std::optional<double>>;\n   static OpResult<MScoreResponse> OpMScore(const OpArgs& op_args, std::string_view key,\n                                   ArgSlice members);\n+  static OpResult<ScoredArray> OpPopCount(const ZRangeSpec& range_spec, const OpArgs& op_args,\n+                                          std::string_view key);\n   static OpResult<ScoredArray> OpRange(const ZRangeSpec& range_spec, const OpArgs& op_args,\n                                        std::string_view key);\n   static OpResult<unsigned> OpRemRange(const OpArgs& op_args, std::string_view key,\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 141394cbe164..33b1ec125adf 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -267,4 +267,47 @@ TEST_F(ZSetFamilyTest, ZAddBug148) {\n   EXPECT_THAT(resp, IntArg(1));\n }\n \n+TEST_F(ZSetFamilyTest, ZPopMin) {\n+  auto resp = Run({\"zadd\", \"key\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\", \"4\", \"d\", \"5\", \"e\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"zpopmin\", \"key\", \"2\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"b\"));\n+\n+  resp = Run({\"zpopmin\", \"key\", \"-1\"});\n+  ASSERT_THAT(resp, ErrArg(\"value is out of range, must be positive\"));\n+\n+  resp = Run({\"zpopmin\", \"key\", \"1\"});\n+  ASSERT_THAT(resp, \"c\");\n+\n+  resp = Run({\"zpopmin\", \"key\", \"3\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"d\", \"e\"));\n+\n+  resp = Run({\"zpopmin\", \"key\", \"1\"});\n+  ASSERT_THAT(resp, ArrLen(0));\n+}\n+\n+TEST_F(ZSetFamilyTest, ZPopMax) {\n+  auto resp = Run({\"zadd\", \"key\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\", \"4\", \"d\", \"5\", \"e\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"zpopmax\", \"key\", \"2\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"e\", \"d\"));\n+\n+  resp = Run({\"zpopmax\", \"key\", \"-1\"});\n+  ASSERT_THAT(resp, ErrArg(\"value is out of range, must be positive\"));\n+\n+  resp = Run({\"zpopmax\", \"key\", \"1\"});\n+  ASSERT_THAT(resp, \"c\");\n+\n+  resp = Run({\"zpopmax\", \"key\", \"3\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"b\", \"a\"));\n+\n+  resp = Run({\"zpopmax\", \"key\", \"1\"});\n+  ASSERT_THAT(resp, ArrLen(0));\n+}\n }  // namespace dfly\n",
  "problem_statement": "Support ZPOPMIN\nsee for more details https://redis.io/commands/zpopmin/ \nSupport ZPOPMAX\nSee https://redis.io/commands/zpopmax/ for more details\r\n\n",
  "hints_text": "\n",
  "created_at": "2022-10-11T00:55:09Z",
  "modified_files": [
    "CONTRIBUTORS.md",
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}