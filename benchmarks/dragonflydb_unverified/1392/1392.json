{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1392,
  "instance_id": "dragonflydb__dragonfly-1392",
  "issue_numbers": [
    "1391"
  ],
  "base_commit": "16454c1e176c081332c6398f37e9c6a55dbcf086",
  "patch": "diff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex 37d84d3c12fe..83b8c431e355 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -87,7 +87,6 @@ struct ConnectionState {\n \n   // Lua-script related data.\n   struct ScriptInfo {\n-    bool is_write = true;\n     absl::flat_hash_set<std::string_view> keys;  // declared keys\n \n     size_t async_cmds_heap_mem = 0;     // bytes used by async_cmds\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex db7ef788a808..41aa13d7f025 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -723,8 +723,7 @@ bool Service::VerifyCommand(const CommandId* cid, CmdArgList args, ConnectionCon\n     return false;\n   }\n \n-  bool is_write_cmd = (cid->opt_mask() & CO::WRITE) ||\n-                      (under_script && dfly_cntx->conn_state.script_info->is_write);\n+  bool is_write_cmd = cid->opt_mask() & CO::WRITE;\n   bool under_multi = dfly_cntx->conn_state.exec_info.IsActive() && !is_trans_cmd;\n \n   if (!etl.is_master && is_write_cmd && !dfly_cntx->is_replicating) {\n",
  "test_patch": "diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex fad916c7dd2f..b22f83b33935 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -952,10 +952,14 @@ async def test_replication_info(df_local_factory, df_seeder_factory, n_keys=2000\n This can cause an issue because it will be executed on each shard independently.\n More details in https://github.com/dragonflydb/dragonfly/issues/1231\n \"\"\"\n+\n+\n @pytest.mark.asyncio\n async def test_flushall_in_full_sync(df_local_factory, df_seeder_factory):\n-    master = df_local_factory.create(port=BASE_PORT, proactor_threads=4, logtostdout=True)\n-    replica = df_local_factory.create(port=BASE_PORT+1, proactor_threads=2, logtostdout=True)\n+    master = df_local_factory.create(\n+        port=BASE_PORT, proactor_threads=4, logtostdout=True)\n+    replica = df_local_factory.create(\n+        port=BASE_PORT+1, proactor_threads=2, logtostdout=True)\n \n     # Start master\n     master.start()\n@@ -992,9 +996,51 @@ async def is_full_sync_mode(c_replica):\n     new_syncid, _ = await c_replica.execute_command(\"DEBUG REPLICA OFFSET\")\n     assert new_syncid != syncid\n \n-    post_seeder = df_seeder_factory.create(port=master.port, keys=10, dbcount=1)\n+    post_seeder = df_seeder_factory.create(\n+        port=master.port, keys=10, dbcount=1)\n     await post_seeder.run(target_deviation=0.1)\n \n     await check_all_replicas_finished([c_replica], c_master)\n \n     await check_data(post_seeder, [replica], [c_replica])\n+\n+\n+\"\"\"\n+Test read-only scripts work with replication. EVAL_RO and the 'no-writes' flags are currently not supported.\n+\"\"\"\n+\n+READONLY_SCRIPT = \"\"\"\n+redis.call('GET', 'A')\n+redis.call('EXISTS', 'B')\n+return redis.call('GET', 'WORKS')\n+\"\"\"\n+\n+WRITE_SCRIPT = \"\"\"\n+redis.call('SET', 'A', 'ErrroR')\n+\"\"\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_readonly_script(df_local_factory):\n+    master = df_local_factory.create(\n+        port=BASE_PORT, proactor_threads=2, logtostdout=True)\n+    replica = df_local_factory.create(\n+        port=BASE_PORT+1, proactor_threads=2, logtostdout=True)\n+\n+    df_local_factory.start_all([master, replica])\n+\n+    c_master = aioredis.Redis(port=master.port)\n+    c_replica = aioredis.Redis(port=replica.port)\n+\n+    await c_master.set('WORKS', 'YES')\n+\n+    await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\")\n+    await wait_available_async(c_replica)\n+\n+    await c_replica.eval(READONLY_SCRIPT, 3, 'A', 'B', 'WORKS') == 'YES'\n+\n+    try:\n+        await c_replica.eval(WRITE_SCRIPT, 1, 'A')\n+        assert False\n+    except aioredis.ResponseError as roe:\n+        assert 'READONLY ' in str(roe)\n",
  "problem_statement": "cannot use lua scripting on slave replica\nDragonfly lastest version.\r\n\r\nOn a replica which is read only (and it's perfectly fine) we cannot use lua scripting. For example the simple example in the redis doc is not working:\r\n\r\n127.0.0.1:6379> EVAL \"return redis.call('SET', KEYS[1], ARGV[1])\" 1 foo bar\r\n(error) ERR Error running script (call to d8f2fad9f8e86a53d2a6ebd960b33c4972cacc37): @user_script:2: -READONLY You can't write against a read only replica.\r\n\r\nthis is a blocker for adoption for us (we heavily rely on this)\r\n\n",
  "hints_text": "",
  "created_at": "2023-06-11T18:59:51Z",
  "modified_files": [
    "src/server/conn_context.h",
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/replication_test.py"
  ]
}