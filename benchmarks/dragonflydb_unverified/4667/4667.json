{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4667,
  "instance_id": "dragonflydb__dragonfly-4667",
  "issue_numbers": [
    "3858"
  ],
  "base_commit": "618af313ca412585e43f7183172bfeb35796b977",
  "patch": "diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 53480b472b55..f1e9b6ae0378 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -113,7 +113,7 @@ cxx_test(bitops_family_test dfly_test_lib LABELS DFLY)\n cxx_test(rdb_test dfly_test_lib DATA testdata/empty.rdb testdata/redis6_small.rdb\n          testdata/redis6_stream.rdb testdata/hll.rdb testdata/redis7_small.rdb\n          testdata/redis_json.rdb testdata/RDB_TYPE_STREAM_LISTPACKS_2.rdb\n-         testdata/RDB_TYPE_STREAM_LISTPACKS_3.rdb LABELS DFLY)\n+         testdata/RDB_TYPE_STREAM_LISTPACKS_3.rdb testdata/ignore_expiry.rdb LABELS DFLY)\n cxx_test(zset_family_test dfly_test_lib LABELS DFLY)\n cxx_test(geo_family_test dfly_test_lib LABELS DFLY)\n cxx_test(blocking_controller_test dfly_test_lib LABELS DFLY)\ndiff --git a/src/server/rdb_load.cc b/src/server/rdb_load.cc\nindex 5782828f1df8..1b436ee2f56b 100644\n--- a/src/server/rdb_load.cc\n+++ b/src/server/rdb_load.cc\n@@ -58,6 +58,7 @@ ABSL_DECLARE_FLAG(int32_t, list_compress_depth);\n ABSL_DECLARE_FLAG(uint32_t, dbnum);\n ABSL_DECLARE_FLAG(bool, list_experimental_v2);\n ABSL_FLAG(bool, rdb_load_dry_run, false, \"Dry run RDB load without applying changes\");\n+ABSL_FLAG(bool, rdb_ignore_expiry, false, \"Ignore Key Expiry when loding from RDB snapshot\");\n \n namespace dfly {\n \n@@ -1810,7 +1811,7 @@ auto RdbLoaderBase::ReadStreams(int rdbtype) -> io::Result<OpaqueObj> {\n         }*/\n       }\n     }  // while (consumers_num)\n-  }  // while (cgroup_num)\n+  }    // while (cgroup_num)\n \n   return OpaqueObj{std::move(load_trace), RDB_TYPE_STREAM_LISTPACKS};\n }\n@@ -1935,6 +1936,7 @@ struct RdbLoader::ObjSettings {\n \n RdbLoader::RdbLoader(Service* service)\n     : service_{service},\n+      rdb_ignore_expiry_{GetFlag(FLAGS_rdb_ignore_expiry)},\n       script_mgr_{service == nullptr ? nullptr : service->script_mgr()},\n       shard_buf_{shard_set->size()} {\n }\n@@ -2029,7 +2031,9 @@ error_code RdbLoader::Load(io::Source* src) {\n       /* EXPIRETIME_MS: milliseconds precision expire times introduced\n        * with RDB v3. Like EXPIRETIME but no with more precision. */\n       SET_OR_RETURN(FetchInt<int64_t>(), val);\n-      settings.SetExpire(val);\n+      if (!rdb_ignore_expiry_) {\n+        settings.SetExpire(val);\n+      }\n       continue; /* Read next opcode. */\n     }\n \ndiff --git a/src/server/rdb_load.h b/src/server/rdb_load.h\nindex eea834514bf9..f6de09b44d07 100644\n--- a/src/server/rdb_load.h\n+++ b/src/server/rdb_load.h\n@@ -322,6 +322,7 @@ class RdbLoader : protected RdbLoaderBase {\n   Service* service_;\n   bool override_existing_keys_ = false;\n   bool load_unowned_slots_ = false;\n+  bool rdb_ignore_expiry_;\n   ScriptMgr* script_mgr_;\n   std::vector<ItemsBuf> shard_buf_;\n \n",
  "test_patch": "diff --git a/src/server/rdb_test.cc b/src/server/rdb_test.cc\nindex c4feca4b9de4..747549c06777 100644\n--- a/src/server/rdb_test.cc\n+++ b/src/server/rdb_test.cc\n@@ -33,6 +33,7 @@ using absl::StrCat;\n ABSL_DECLARE_FLAG(int32, list_compress_depth);\n ABSL_DECLARE_FLAG(int32, list_max_listpack_size);\n ABSL_DECLARE_FLAG(dfly::CompressionMode, compression_mode);\n+ABSL_DECLARE_FLAG(bool, rdb_ignore_expiry);\n \n namespace dfly {\n \n@@ -750,4 +751,30 @@ TEST_F(RdbTest, HugeKeyIssue4554) {\n   EXPECT_EQ(Run({\"flushall\"}), \"OK\");\n }\n \n+// ignore_expiry.rdb contains 2 keys which are expired keys\n+// this test case verifies wheather rdb_ignore_expiry flag is working as expected.\n+TEST_F(RdbTest, RDBIgnoreExpiryFlag) {\n+  absl::FlagSaver fs;\n+\n+  SetTestFlag(\"rdb_ignore_expiry\", \"true\");\n+  auto ec = LoadRdb(\"ignore_expiry.rdb\");\n+\n+  ASSERT_FALSE(ec) << ec.message();\n+\n+  auto resp = Run({\"scan\", \"0\"});\n+\n+  ASSERT_THAT(resp, ArrLen(2));\n+\n+  EXPECT_THAT(StrArray(resp.GetVec()[1]), UnorderedElementsAre(\"test\", \"test2\"));\n+\n+  EXPECT_THAT(Run({\"get\", \"test\"}), \"expkey\");\n+  EXPECT_THAT(Run({\"get\", \"test2\"}), \"expkey\");\n+\n+  int ttl = CheckedInt({\"ttl\", \"test\"});  // should ignore expiry for key\n+  EXPECT_EQ(ttl, -1);\n+\n+  int ttl2 = CheckedInt({\"ttl\", \"test2\"});  // should ignore expiry for key\n+  EXPECT_EQ(ttl2, -1);\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/testdata/ignore_expiry.rdb b/src/server/testdata/ignore_expiry.rdb\nnew file mode 100644\nindex 000000000000..b161204befa5\nBinary files /dev/null and b/src/server/testdata/ignore_expiry.rdb differ\n",
  "problem_statement": "Add argument to dont expire when loading from snapshot\nWhen restoring from an older snapshot redis keys with expire TTL are removed at start.  \r\nI understand that this maybe the default flow but in my opinion breaks the concept of `snapshot`.  \r\nMy request is to add a new argument, for example `--no-expire` to allow all data from snapshot to be recovered.\r\n\n",
  "hints_text": "Hi @cfradewavecom \r\n\r\n> I understand that this maybe the default flow but in my opinion breaks the concept of snapshot.\r\n\r\nWhy does it ? If an element has expired then why would I want to restore it ?\r\n\r\nDoes something similar exist for Valkey or ?\nRestoring everything (applications and cache) to the same date as snapshot may be expecting that a key with expiration is still there but when starting it is already gone from cache because it expired due to the date jump.  \r\n\r\nThis may well be a design flaw from applications using cache but with that argument we could control the behavior and even recover important data from cache that would expire eventually when recovering from a snapshot. Right now even if i needed to look what data was in a snapshot i can't.  \r\n\n@cfradewavecom I genuinely don't see or understand why this is a problem ? You got a snapshot let's say at time `X`. Some of your data should expire at time `X + 1` and then you loaded the snapshot at time `X + 2`. Why would the data you loaded include the `expired` elements since by `design and definition of expires` they should not exist after a certain time point? \r\n\r\nThis looks more of a design defect of an application. Simply, if you don't want certain elements to expire, then don't attach an expiration date to them.\r\n\r\n@romange Any ideas why this would be useful ? \nI agree with you but i cannot control the way applications are designed and this already happened to me where i could not recover from a disaster event because there where important information in a snapshot and i could not retrieve it has it is.\r\n\r\nIf i am not mistaken, this is supported with redis insight  \r\n![Captura de ecr\u00e3 de 2024-10-03 13-02-33](https://github.com/user-attachments/assets/61a203c0-7938-4c3e-8b75-19b4161ee47b)\r\n\r\nAnd a quick search there are several tools that can at least dump information from snapshot.  If this feature does not make sense would be possible to provide a tool to dump information from snapshot with your current spec?    \nHi @cfradewavecom,\r\n\r\n> this already happened to me where i could not recover from a disaster event\r\n\r\nThat's why there is replication right ?\r\n\r\nI am not familiar much with Redis Insight, but I guess if it can load an rdb fille you can do the same with DF, but saving into the old rdb format (and not the one we provide). However this will have a few downsides I am afraid\n`it can load an rdb fille you can do the same with DF, but saving into the old rdb format (and not the one we provide). However this will have a few downsides I am afraid`  \r\n\r\nYes i notice that after the event and arrive to the same conclusion as you. The snapshot that i needed was in your native format.\r\n\r\n`That's why there is replication right ?` \r\nI had two replicas of dragonfly, both did their snapshot, at some point their volume run out of space since they do not remove older snapshots (i will create something to do this). Since this is a silent error (log only), i did not notice this was occurring. Suffered from restart on both replicas, they started from the last snapshot that was too old for the TTL that was defined in the keys at the time.\nThanks @cfradewavecom I think this is a good suggestion. \r\nI added the 'help wanted' label, maybe an external contributor can take this.\r\n\r\nThe task is:\r\n1. introduce a new flag in rdb_load.cc\r\n2. ignore the expire info loaded from rdb file on load if flag is set to true\r\n\nI can take a stab at this if no one is working on this task\ntake\nSure, why not.",
  "created_at": "2025-02-27T05:17:50Z",
  "modified_files": [
    "src/server/CMakeLists.txt",
    "src/server/rdb_load.cc",
    "src/server/rdb_load.h"
  ],
  "modified_test_files": [
    "src/server/rdb_test.cc"
  ]
}