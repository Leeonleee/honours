diff --git a/src/server/multi_command_squasher.cc b/src/server/multi_command_squasher.cc
index 8caf9f77ee25..92dace25f63b 100644
--- a/src/server/multi_command_squasher.cc
+++ b/src/server/multi_command_squasher.cc
@@ -153,10 +153,14 @@ bool MultiCommandSquasher::ExecuteStandalone(RedisReplyBuilder* rb, const Stored
   auto* tx = cntx_->transaction;
   if (cmd->Cid()->IsTransactional()) {
     tx->MultiSwitchCmd(cmd->Cid());
-    tx->InitByArgs(cntx_->ns, cntx_->conn_state.db_index, args);
+    auto status = tx->InitByArgs(cntx_->ns, cntx_->conn_state.db_index, args);
+    if (status != OpStatus::OK) {
+      rb->SendError(status);
+      rb->ConsumeLastError();
+      return !opts_.error_abort;
+    }
   }
   service_->InvokeCmd(cmd->Cid(), args, CommandContext{tx, rb, cntx_});
-
   return true;
 }
 
@@ -195,10 +199,13 @@ OpStatus MultiCommandSquasher::SquashedHopCb(EngineShard* es, RespVersion resp_v
     crb.SetReplyMode(dispatched.cmd->ReplyMode());
 
     local_tx->MultiSwitchCmd(dispatched.cmd->Cid());
-    local_tx->InitByArgs(cntx_->ns, local_cntx.conn_state.db_index, args);
-    service_->InvokeCmd(dispatched.cmd->Cid(), args,
-                        CommandContext{local_cntx.transaction, &crb, &local_cntx});
-
+    auto status = local_tx->InitByArgs(cntx_->ns, local_cntx.conn_state.db_index, args);
+    if (status != OpStatus::OK) {
+      crb.SendError(status);
+    } else {
+      service_->InvokeCmd(dispatched.cmd->Cid(), args,
+                          CommandContext{local_cntx.transaction, &crb, &local_cntx});
+    }
     move_reply(crb.Take(), &dispatched.reply);
 
     // Assert commands made no persistent state changes to stub context state
diff --git a/src/server/transaction.cc b/src/server/transaction.cc
index 168a22c30266..17b8c9e86395 100644
--- a/src/server/transaction.cc
+++ b/src/server/transaction.cc
@@ -307,12 +307,14 @@ void Transaction::PrepareMultiFps(CmdArgList keys) {
 }
 
 void Transaction::StoreKeysInArgs(const KeyIndex& key_index) {
-  DCHECK(!key_index.bonus);
   DCHECK(kv_fp_.empty());
   DCHECK(args_slices_.empty());
 
   // even for a single key we may have multiple arguments per key (MSET).
+  if (key_index.bonus)
+    args_slices_.emplace_back(*key_index.bonus, *key_index.bonus + 1);
   args_slices_.emplace_back(key_index.start, key_index.end);
+
   for (string_view key : key_index.Range(full_args_))
     kv_fp_.push_back(LockTag(key).Fingerprint());
 }
