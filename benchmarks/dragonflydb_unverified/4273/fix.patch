diff --git a/helio b/helio
index ff9b6cd35bf0..32e8c4ec830e 160000
--- a/helio
+++ b/helio
@@ -1,1 +1,1 @@
-Subproject commit ff9b6cd35bf082a9d48cf0904b0e8557cf31b6d2
+Subproject commit 32e8c4ec830e8d4224d8a13a11c1607f357da80f
diff --git a/src/facade/redis_parser.cc b/src/facade/redis_parser.cc
index f7ebd2db4beb..2e2967761764 100644
--- a/src/facade/redis_parser.cc
+++ b/src/facade/redis_parser.cc
@@ -11,6 +11,7 @@
 namespace facade {
 
 using namespace std;
+constexpr static long kMaxBulkLen = 256 * (1ul << 20);  // 256MB.
 
 auto RedisParser::Parse(Buffer str, uint32_t* consumed, RespExpr::Vec* res) -> Result {
   DCHECK(!str.empty());
@@ -218,7 +219,11 @@ auto RedisParser::ParseLen(Buffer str, int64_t* res) -> ResultConsumed {
   const char* s = reinterpret_cast<const char*>(str.data());
   const char* pos = reinterpret_cast<const char*>(memchr(s, '
', str.size()));
   if (!pos) {
-    Result r = str.size() < 32 ? INPUT_PENDING : BAD_ARRAYLEN;
+    Result r = INPUT_PENDING;
+    if (str.size() >= 32) {
+      LOG(WARNING) << "Unexpected format " << string_view{s, str.size()};
+      r = BAD_ARRAYLEN;
+    }
     return {r, 0};
   }
 
@@ -227,10 +232,16 @@ auto RedisParser::ParseLen(Buffer str, int64_t* res) -> ResultConsumed {
   }
 
   // Skip the first character and 2 last ones (\r
).
-  bool success = absl::SimpleAtoi(std::string_view{s + 1, size_t(pos - 1 - s)}, res);
+  string_view len_token{s + 1, size_t(pos - 1 - s)};
+  bool success = absl::SimpleAtoi(len_token, res);
+
   unsigned consumed = pos - s + 1;
+  if (success && *res >= -1) {
+    return ResultConsumed{OK, consumed};
+  }
 
-  return ResultConsumed{success ? OK : BAD_ARRAYLEN, consumed};
+  LOG(WARNING) << "Failed to parse len " << len_token;
+  return ResultConsumed{BAD_ARRAYLEN, consumed};
 }
 
 auto RedisParser::ConsumeArrayLen(Buffer str) -> ResultConsumed {
@@ -247,8 +258,8 @@ auto RedisParser::ConsumeArrayLen(Buffer str) -> ResultConsumed {
     len *= 2;
   }
 
-  if (len < -1 || len > max_arr_len_) {
-    LOG_IF(WARNING, len > max_arr_len_) << "Multibulk len is too large " << len;
+  if (len > max_arr_len_) {
+    LOG(WARNING) << "Multibulk len is too large " << len;
 
     return {BAD_ARRAYLEN, res.second};
   }
@@ -310,15 +321,14 @@ auto RedisParser::ParseArg(Buffer str) -> ResultConsumed {
       return res;
     }
 
-    if (len < -1 || len > kMaxBulkLen)
-      return {BAD_ARRAYLEN, res.second};
-
     if (len == -1) {  // Resp2 NIL
       cached_expr_->emplace_back(RespExpr::NIL);
       cached_expr_->back().u = Buffer{};
       HandleFinishArg();
     } else {
       DVLOG(1) << "String(" << len << ")";
+      LOG_IF(WARNING, len > kMaxBulkLen) << "Large bulk len: " << len;
+
       cached_expr_->emplace_back(RespExpr::STRING);
       cached_expr_->back().u = Buffer{};
       bulk_len_ = len;
diff --git a/src/facade/redis_parser.h b/src/facade/redis_parser.h
index f9986dd4d37e..e092be06ae98 100644
--- a/src/facade/redis_parser.h
+++ b/src/facade/redis_parser.h
@@ -22,8 +22,6 @@ namespace facade {
  */
 class RedisParser {
  public:
-  constexpr static long kMaxBulkLen = 256 * (1ul << 20);  // 256MB.
-
   enum Result : uint8_t {
     OK,
     INPUT_PENDING,
diff --git a/src/server/server_family.cc b/src/server/server_family.cc
index 7e9638c10bd1..632409deb461 100644
--- a/src/server/server_family.cc
+++ b/src/server/server_family.cc
@@ -877,6 +877,7 @@ void ServerFamily::Init(util::AcceptServer* acceptor, std::vector<facade::Listen
         absl::GetFlag(FLAGS_s3_ec2_metadata), absl::GetFlag(FLAGS_s3_sign_payload));
 #else
     LOG(ERROR) << "Compiled without AWS support";
+    exit(1);
 #endif
   } else if (IsGCSPath(flag_dir)) {
     auto gcs = std::make_shared<detail::GcsSnapshotStorage>();
