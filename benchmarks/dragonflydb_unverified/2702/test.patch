diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc
index 4eb323a1590b..dcd8b58e33a5 100644
--- a/src/server/generic_family_test.cc
+++ b/src/server/generic_family_test.cc
@@ -695,8 +695,10 @@ TEST_F(GenericFamilyTest, Info) {
   EXPECT_EQ(1, get_rdb_changes_since_last_save(resp.GetString()));
 
   EXPECT_EQ(Run({"bgsave"}), "OK");
-  resp = Run({"info", "persistence"});
-  EXPECT_EQ(0, get_rdb_changes_since_last_save(resp.GetString()));
+  WaitUntilCondition([&]() {
+    resp = Run({"info", "persistence"});
+    return get_rdb_changes_since_last_save(resp.GetString()) == 0;
+  });
 
   EXPECT_EQ(Run({"set", "k3", "3"}), "OK");
   resp = Run({"info", "persistence"});
diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py
index 13bc9380fbd7..1baa3a235a8c 100644
--- a/tests/dragonfly/replication_test.py
+++ b/tests/dragonfly/replication_test.py
@@ -2022,16 +2022,13 @@ async def test_saving_replica(df_local_factory):
     async def save_replica():
         await c_replica.execute_command("save")
 
-    async def is_saving():
-        return "saving:1" in (await c_replica.execute_command("INFO PERSISTENCE"))
-
     save_task = asyncio.create_task(save_replica())
-    while not await is_saving():  # wait for replica start saving
+    while not await is_saving(c_replica):  # wait for replica start saving
         asyncio.sleep(0.1)
     await c_replica.execute_command("replicaof no one")
-    assert await is_saving()
+    assert await is_saving(c_replica)
     await save_task
-    assert not await is_saving()
+    assert not await is_saving(c_replica)
 
     await disconnect_clients(c_master, *[c_replica])
 
@@ -2052,15 +2049,12 @@ async def test_start_replicating_while_save(df_local_factory):
     async def save_replica():
         await c_replica.execute_command("save")
 
-    async def is_saving():
-        return "saving:1" in (await c_replica.execute_command("INFO PERSISTENCE"))
-
     save_task = asyncio.create_task(save_replica())
-    while not await is_saving():  # wait for server start saving
+    while not await is_saving(c_replica):  # wait for server start saving
         asyncio.sleep(0.1)
     await c_replica.execute_command(f"REPLICAOF localhost {master.port}")
-    assert await is_saving()
+    assert await is_saving(c_replica)
     await save_task
-    assert not await is_saving()
+    assert not await is_saving(c_replica)
 
     await disconnect_clients(c_master, *[c_replica])
diff --git a/tests/dragonfly/snapshot_test.py b/tests/dragonfly/snapshot_test.py
index ff21835aa5df..d775ea429dd6 100644
--- a/tests/dragonfly/snapshot_test.py
+++ b/tests/dragonfly/snapshot_test.py
@@ -3,12 +3,13 @@
 import glob
 import asyncio
 import async_timeout
+import redis
 from redis import asyncio as aioredis
 from pathlib import Path
 import boto3
 
 from . import dfly_args
-from .utility import wait_available_async, chunked
+from .utility import wait_available_async, chunked, is_saving
 
 from .seeder import StaticSeeder
 
@@ -356,3 +357,22 @@ async def info_in_loop():
     await save_task
     save_finished = True
     await info_task
+
+
+@dfly_args({**BASIC_ARGS, "dbfilename": "test-bgsave"})
+async def test_bgsave_and_save(async_client: aioredis.Redis):
+    await async_client.execute_command("DEBUG POPULATE 20000")
+
+    await async_client.execute_command("BGSAVE")
+    with pytest.raises(redis.exceptions.ResponseError):
+        await async_client.execute_command("BGSAVE")
+
+    while await is_saving(async_client):
+        await asyncio.sleep(0.1)
+    await async_client.execute_command("BGSAVE")
+    with pytest.raises(redis.exceptions.ResponseError):
+        await async_client.execute_command("SAVE")
+
+    while await is_saving(async_client):
+        await asyncio.sleep(0.1)
+    await async_client.execute_command("SAVE")
diff --git a/tests/dragonfly/utility.py b/tests/dragonfly/utility.py
index b2176dad5bf3..addf9a070be3 100644
--- a/tests/dragonfly/utility.py
+++ b/tests/dragonfly/utility.py
@@ -646,3 +646,7 @@ def __exit__(self, exc_type, exc_value, exc_traceback):
                 os.environ[k] = self.undo[k]
             else:
                 del os.environ[k]
+
+
+async def is_saving(c_client: aioredis.Redis):
+    return "saving:1" in (await c_client.execute_command("INFO PERSISTENCE"))
