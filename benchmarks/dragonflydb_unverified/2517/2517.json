{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2517,
  "instance_id": "dragonflydb__dragonfly-2517",
  "issue_numbers": [
    "2514"
  ],
  "base_commit": "2b0310db320a1c34a4caf0f4307f48744238bd49",
  "patch": "diff --git a/src/server/blocking_controller.cc b/src/server/blocking_controller.cc\nindex 5922e0eb5422..a795dc10b0a5 100644\n--- a/src/server/blocking_controller.cc\n+++ b/src/server/blocking_controller.cc\n@@ -93,13 +93,14 @@ bool BlockingController::DbWatchTable::UnwatchTx(string_view key, Transaction* t\n     // the suspended item does not have to be the first one in the queue.\n     // This shard has not been awakened and in case this transaction in the queue\n     // we must clean it up.\n-\n     if (auto it = wq->Find(tx); it != wq->items.end()) {\n       wq->items.erase(it);\n     }\n   }\n \n   if (wq->items.empty()) {\n+    DVLOG(1) << \"queue_map.erase\";\n+    awakened_keys.erase(wq_it->first);\n     queue_map.erase(wq_it);\n   }\n   return res;\n@@ -120,45 +121,7 @@ bool BlockingController::DbWatchTable::AddAwakeEvent(string_view key) {\n   return awakened_keys.insert(it->first).second;\n }\n \n-// Optionally removes tx from the front of the watch queues.\n-void BlockingController::FinalizeWatched(KeyLockArgs lock_args, Transaction* tx) {\n-  DCHECK(tx);\n-\n-  ShardId sid = owner_->shard_id();\n-\n-  uint16_t local_mask = tx->GetLocalMask(sid);\n-  VLOG(1) << \"FinalizeBlocking [\" << sid << \"]\" << tx->DebugId() << \" \" << local_mask;\n-\n-  bool is_awakened = local_mask & Transaction::AWAKED_Q;\n-\n-  if (is_awakened)\n-    awakened_transactions_.erase(tx);\n-\n-  auto dbit = watched_dbs_.find(tx->GetDbIndex());\n-\n-  // Can happen if it was the only transaction in the queue and it was notified and removed.\n-  if (dbit == watched_dbs_.end())\n-    return;\n-\n-  DbWatchTable& wt = *dbit->second;\n-\n-  // Add keys of processed transaction so we could awake the next one in the queue\n-  // in case those keys still exist.\n-  for (size_t i = 0; i < lock_args.args.size(); i += lock_args.key_step) {\n-    string_view key = lock_args.args[i];\n-    bool removed_awakened = wt.UnwatchTx(key, tx);\n-    if (removed_awakened) {\n-      CHECK(is_awakened) << tx->DebugId() << \" \" << key << \" \" << local_mask;\n-    }\n-  }\n-\n-  if (wt.queue_map.empty()) {\n-    watched_dbs_.erase(dbit);\n-  }\n-  awakened_indices_.emplace(tx->GetDbIndex());\n-}\n-\n-// Similar function but with ArgSlice. TODO: to fix the duplication.\n+// Removes tx from its watch queues if tx appears there.\n void BlockingController::FinalizeWatched(ArgSlice args, Transaction* tx) {\n   DCHECK(tx);\n \n@@ -195,6 +158,7 @@ void BlockingController::FinalizeWatched(ArgSlice args, Transaction* tx) {\n   awakened_indices_.emplace(tx->GetDbIndex());\n }\n \n+// Runs on the shard thread.\n void BlockingController::NotifyPending() {\n   const Transaction* tx = owner_->GetContTx();\n   CHECK(tx == nullptr) << tx->DebugId();\n@@ -214,6 +178,8 @@ void BlockingController::NotifyPending() {\n       DVLOG(1) << \"Processing awakened key \" << sv_key;\n       auto w_it = wt.queue_map.find(sv_key);\n       if (w_it == wt.queue_map.end()) {\n+        // This should not happen because we remove keys from awakened_keys every type we remove\n+        // the entry from queue_map. TODO: to make it a CHECK after Dec 2024\n         LOG(ERROR) << \"Internal error: Key \" << sv_key\n                    << \" was not found in the watch queue, wt.awakened_keys len is \"\n                    << wt.awakened_keys.size() << \" wt.queue_map len is \" << wt.queue_map.size();\n@@ -229,6 +195,7 @@ void BlockingController::NotifyPending() {\n       WatchQueue* wq = w_it->second.get();\n       NotifyWatchQueue(sv_key, wq, context);\n       if (wq->items.empty()) {\n+        // we erase awakened_keys right after this loop finishes running.\n         wt.queue_map.erase(w_it);\n       }\n     }\ndiff --git a/src/server/blocking_controller.h b/src/server/blocking_controller.h\nindex 0a835625c5ef..081aff9f461b 100644\n--- a/src/server/blocking_controller.h\n+++ b/src/server/blocking_controller.h\n@@ -28,10 +28,8 @@ class BlockingController {\n     return awakened_transactions_;\n   }\n \n-  void FinalizeWatched(KeyLockArgs lock_args, Transaction* tx);\n-\n-  // A mirror reflection but with ArgSlice. Yeah, I know....\n   void FinalizeWatched(ArgSlice args, Transaction* tx);\n+\n   // go over potential wakened keys, verify them and activate watch queues.\n   void NotifyPending();\n \ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex e9db7b5a25ed..874970ef386b 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -634,7 +634,8 @@ bool Transaction::RunInShard(EngineShard* shard, bool txq_ooo) {\n     //    of the queue and notify the next one.\n     if (auto* bcontroller = shard->blocking_controller(); bcontroller) {\n       if (awaked_prerun || was_suspended) {\n-        bcontroller->FinalizeWatched(largs, this);\n+        CHECK_EQ(largs.key_step, 1u);\n+        bcontroller->FinalizeWatched(largs.args, this);\n       }\n \n       // Wake only if no tx queue head is currently running\n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex 4303e2316b17..3284ead5ea2b 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -815,7 +815,7 @@ TEST_F(ListFamilyTest, BLPopUnwakesInScript) {\n   });\n \n   // Start long running script that intends to wake up blpop\n-  auto f2 = pp_->at(2)->LaunchFiber([&]() {\n+  auto f2 = pp_->at(2)->LaunchFiber([&] {\n     Run(\"script\", {\"EVAL\", SCRIPT, \"5\", \"a\", \"b\", \"c\", \"d\", \"l\"});\n   });\n \n@@ -841,7 +841,7 @@ TEST_F(ListFamilyTest, OtherMultiWakesBLpop) {\n   )\";\n \n   // Start BLPOP with infinite timeout\n-  auto f1 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&]() {\n+  auto f1 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&] {\n     auto resp = Run(\"blpop\", {\"BLPOP\", \"l\", \"0\"});\n     // blpop should only be awakened after the script has completed, so the\n     // last element added in the script should be returned.\n@@ -851,7 +851,7 @@ TEST_F(ListFamilyTest, OtherMultiWakesBLpop) {\n \n   // Start long running script that accesses the list, but should wake up blpop only after it\n   // finished\n-  auto f2 = pp_->at(2)->LaunchFiber(Launch::dispatch, [&]() {\n+  auto f2 = pp_->at(2)->LaunchFiber(Launch::dispatch, [&] {\n     Run(\"script\", {\"EVAL\", SCRIPT, \"5\", \"a\", \"b\", \"c\", \"d\", \"l\"});\n   });\n \n@@ -862,4 +862,26 @@ TEST_F(ListFamilyTest, OtherMultiWakesBLpop) {\n   f2.Join();\n }\n \n+TEST_F(ListFamilyTest, ContendExpire) {\n+  vector<fb2::Fiber> blpop_fibers;\n+  for (unsigned i = 0; i < num_threads_; ++i) {\n+    for (unsigned j = 0; j < 30; ++j) {\n+      blpop_fibers.emplace_back(pp_->at(i)->LaunchFiber(Launch::post, [&, i, j] {\n+        string keys[2] = {\"key0\", \"key1\"};\n+        thread_local unsigned cur = 0;\n+        for (unsigned n = 0; n < 30; n++) {\n+          string k = keys[cur];\n+          cur ^= 1;\n+          Run(StrCat(\"push\", i, \"_\", j), {\"lpush\", k, \"foo\"});\n+          Run(StrCat(\"blpop\", i, \"_\", j), {\"blpop\", keys[cur], \"a\", \"0.001\"});\n+        }\n+      }));\n+    }\n+  }\n+\n+  for (auto& f : blpop_fibers) {\n+    f.Join();\n+  }\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex 70f66f348c9b..5b3d200ad105 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -228,7 +228,7 @@ void BaseFamilyTest::ResetService() {\n   watchdog_fiber_ = pp_->GetNextProactor()->LaunchFiber([this] {\n     ThisFiber::SetName(\"Watchdog\");\n \n-    if (!watchdog_done_.WaitFor(120s)) {\n+    if (!watchdog_done_.WaitFor(60s)) {\n       LOG(ERROR) << \"Deadlock detected!!!!\";\n       absl::SetFlag(&FLAGS_alsologtostderr, true);\n       fb2::Mutex m;\n",
  "problem_statement": "Crash with blocking commands\n```\r\n\r\n2024-01-31 17:46:35.081\t\r\nPC: @     0x7f12662fc941  (unknown)  abort\r\n2024-01-31 17:46:35.081\t\r\n*** SIGSEGV received at time=1706741195 on cpu 0 ***\r\n2024-01-31 17:46:35.081\t\r\n[failure_signal_handler.cc : 345] RAW: Signal 11 raised at PC=0x7f12662fc941 while already in AbslFailureSignalHandler()\r\n2024-01-31 17:46:35.081\t\r\nPC: @     0x7f126631d00b  (unknown)  raise\r\n2024-01-31 17:46:35.080\t\r\n*** SIGABRT received at time=1706741195 on cpu 0 ***\r\n2024-01-31 17:46:35.080\t\r\n    @     0x5613e7a08daf  make_fcontext\r\n2024-01-31 17:46:35.077\t\r\n    @     0x5613e7418a9e  _ZN5boost7context6detail11fiber_entryINS1_12fiber_recordINS0_5fiberENS0_21basic_fixedsize_stackINS0_12stack_traitsEEEZN4util3fb26detail15WorkerFiberImplIZN4dfly11EngineShardC4EPNS9_12ProactorBaseEP9mi_heap_sEUlvE0_JEEC4IS7_EESt17basic_string_viewIcSt11char_traitsIcEERKNS0_12preallocatedEOT_OSI_EUlOS4_E_EEEEvNS1_10transfer_tE\r\n2024-01-31 17:46:35.076\t\r\n    @     0x5613e79efa8a  util::fb2::FiberQueue::Run()\r\n2024-01-31 17:46:35.074\t\r\n    @     0x5613e74e7766  _ZNSt17_Function_handlerIFvvEZN4dfly11Transaction11UnlockMultiEvEUlvE_E9_M_invokeERKSt9_Any_data\r\n2024-01-31 17:46:35.074\t\r\n    @     0x5613e74e770d  dfly::Transaction::UnlockMultiShardCb()\r\n2024-01-31 17:46:35.071\t\r\n    @     0x5613e74d185d  dfly::BlockingController::NotifyPending()\r\n2024-01-31 17:46:35.069\t\r\n    @     0x5613e74d0f79  dfly::BlockingController::NotifyWatchQueue()\r\n2024-01-31 17:46:35.064\t\r\n    @     0x5613e7be5b3f  google::LogMessageFatal::~LogMessageFatal()\r\n2024-01-31 17:46:35.063\t\r\n    @     0x5613e7be41b7  google::LogMessage::Flush()\r\n2024-01-31 17:46:35.062\t\r\n    @     0x5613e7beb9f3  google::LogMessage::SendToLog()\r\n2024-01-31 17:46:35.060\t\r\n*** Check failure stack trace: ***\r\n2024-01-31 17:46:35.060\t\r\nF20240131 22:46:35.060096     8 blocking_controller.cc:276] Check failed: w_it != wqm->end() \r\n\r\n```\n",
  "hints_text": "",
  "created_at": "2024-02-01T09:27:05Z",
  "modified_files": [
    "src/server/blocking_controller.cc",
    "src/server/blocking_controller.h",
    "src/server/transaction.cc"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc",
    "src/server/test_utils.cc"
  ]
}