diff --git a/src/core/overloaded.h b/src/core/overloaded.h
index 9db0c50a2ae1..0a1ccc572dd9 100644
--- a/src/core/overloaded.h
+++ b/src/core/overloaded.h
@@ -3,6 +3,8 @@
 //
 //
 
+#pragma once
+
 template <class... Ts> struct Overloaded : Ts... { using Ts::operator()...; };
 
 template <class... Ts> Overloaded(Ts...) -> Overloaded<Ts...>;
diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt
index 89452b486ca8..5ad14245b8bb 100644
--- a/src/server/CMakeLists.txt
+++ b/src/server/CMakeLists.txt
@@ -25,7 +25,8 @@ add_library(dragonfly_lib channel_store.cc command_registry.cc
             zset_family.cc version.cc bitops_family.cc container_utils.cc io_utils.cc
             serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc
             top_keys.cc multi_command_squasher.cc hll_family.cc cluster/cluster_config.cc
-            cluster/cluster_family.cc acl/user.cc acl/user_registry.cc acl/acl_family.cc)
+            cluster/cluster_family.cc acl/user.cc acl/user_registry.cc acl/acl_family.cc
+            acl/validator.cc)
 
 
 cxx_link(dragonfly_lib dfly_transaction dfly_facade redis_lib aws_lib strings_lib html_lib
diff --git a/src/server/acl/user.h b/src/server/acl/user.h
index e40ee04e7b6f..4f09950d2bc7 100644
--- a/src/server/acl/user.h
+++ b/src/server/acl/user.h
@@ -16,10 +16,6 @@
 
 namespace dfly::acl {
 
-// TODO implement these
-//#bool CheckIfCommandAllowed(uint64_t command_id, const CommandId& command);
-//#bool CheckIfAclCategoryAllowed(uint64_t command_id, const CommandId& command);
-
 class User final {
  public:
   struct UpdateRequest {
diff --git a/src/server/acl/validator.cc b/src/server/acl/validator.cc
new file mode 100644
index 000000000000..bcc7edba99c0
--- /dev/null
+++ b/src/server/acl/validator.cc
@@ -0,0 +1,19 @@
+// Copyright 2023, DragonflyDB authors.  All rights reserved.
+// See LICENSE for licensing terms.
+//
+
+#include "server/acl/validator.h"
+
+#include "server/server_state.h"
+
+namespace dfly::acl {
+
+[[nodiscard]] bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx,
+                                                const facade::CommandId& id) {
+  auto& registry = *ServerState::tlocal()->user_registry;
+  auto credentials = registry.GetCredentials(cntx.authed_username);
+  auto command_credentials = id.acl_categories();
+  return (credentials.acl_categories & command_credentials) != 0;
+}
+
+}  // namespace dfly::acl
diff --git a/src/server/acl/validator.h b/src/server/acl/validator.h
new file mode 100644
index 000000000000..67a78b6e953e
--- /dev/null
+++ b/src/server/acl/validator.h
@@ -0,0 +1,16 @@
+// Copyright 2023, DragonflyDB authors.  All rights reserved.
+// See LICENSE for licensing terms.
+//
+
+#pragma once
+
+#include <string_view>
+
+#include "facade/command_id.h"
+#include "server/conn_context.h"
+
+namespace dfly::acl {
+
+bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx, const facade::CommandId& id);
+
+}
diff --git a/src/server/conn_context.h b/src/server/conn_context.h
index 319228f815cd..d377c84d0f3c 100644
--- a/src/server/conn_context.h
+++ b/src/server/conn_context.h
@@ -196,7 +196,7 @@ class ConnectionContext : public facade::ConnectionContext {
   // Reference to a FlowInfo for this connection if from a master to a replica.
   FlowInfo* replication_flow;
 
-  std::optional<std::string> authed_username;
+  std::string authed_username{"default"};
 
  private:
   void EnableMonitoring(bool enable) {
diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index bfd61e0126d5..cdee899a9461 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -27,6 +27,7 @@ extern "C" {
 #include "facade/reply_capture.h"
 #include "server/acl/acl_commands_def.h"
 #include "server/acl/acl_family.h"
+#include "server/acl/validator.h"
 #include "server/bitops_family.h"
 #include "server/cluster/cluster_family.h"
 #include "server/conn_context.h"
@@ -784,11 +785,27 @@ OpStatus CheckKeysDeclared(const ConnectionState::ScriptInfo& eval_info, const C
   return OpStatus::OK;
 }
 
-optional<ErrorReply> Service::VerifyCommandExecution(const CommandId* cid) {
-  // TODO: Move OOM check here
+static optional<ErrorReply> VerifyConnectionAclStatus(const CommandId* cid,
+                                                      const ConnectionContext* cntx,
+                                                      string_view error_msg) {
+  // If we are on a squashed context we need to use the owner, because the
+  // context we are operating on is a stub and the acl username is not copied
+  // See: MultiCommandSquasher::SquashedHopCb
+  if (cntx->conn_state.squashing_info)
+    cntx = cntx->conn_state.squashing_info->owner;
+
+  if (!acl::IsUserAllowedToInvokeCommand(*cntx, *cid)) {
+    return ErrorReply(absl::StrCat("NOPERM: ", cntx->authed_username, " ", error_msg));
+  }
   return nullopt;
 }
 
+optional<ErrorReply> Service::VerifyCommandExecution(const CommandId* cid,
+                                                     const ConnectionContext* cntx) {
+  // TODO: Move OOM check here
+  return VerifyConnectionAclStatus(cid, cntx, "ACL rules changed between the MULTI and EXEC");
+}
+
 std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdArgList tail_args,
                                                       const ConnectionContext& dfly_cntx) {
   DCHECK(cid);
@@ -866,7 +883,7 @@ std::optional<ErrorReply> Service::VerifyCommandState(const CommandId* cid, CmdA
       return ErrorReply{status};
   }
 
-  return nullopt;
+  return VerifyConnectionAclStatus(cid, &dfly_cntx, "has no ACL permissions");
 }
 
 void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx) {
@@ -980,7 +997,7 @@ bool Service::InvokeCmd(const CommandId* cid, CmdArgList tail_args, ConnectionCo
   DCHECK(cid);
   DCHECK(!cid->Validate(tail_args));
 
-  if (auto err = VerifyCommandExecution(cid); err) {
+  if (auto err = VerifyCommandExecution(cid, cntx); err) {
     (*cntx)->SendError(std::move(*err));
     return true;  // return false only for internal error aborts
   }
diff --git a/src/server/main_service.h b/src/server/main_service.h
index 11b8deeabf83..1854a81b105a 100644
--- a/src/server/main_service.h
+++ b/src/server/main_service.h
@@ -55,7 +55,8 @@ class Service : public facade::ServiceInterface {
 
   // Verify command can be executed now (check out of memory), always called immediately before
   // execution
-  std::optional<facade::ErrorReply> VerifyCommandExecution(const CommandId* cid);
+  std::optional<facade::ErrorReply> VerifyCommandExecution(const CommandId* cid,
+                                                           const ConnectionContext* cntx);
 
   // Verify command prepares excution in correct state.
   // It's usually called before command execution. Only for multi/exec transactions it's checked
