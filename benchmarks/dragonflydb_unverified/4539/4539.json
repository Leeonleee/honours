{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4539,
  "instance_id": "dragonflydb__dragonfly-4539",
  "issue_numbers": [
    "4526"
  ],
  "base_commit": "c95ad198301a7f27c3f32c2e480e63837e7371bc",
  "patch": "diff --git a/src/facade/CMakeLists.txt b/src/facade/CMakeLists.txt\nindex 67b83a6d65dc..6e8d65fa9e78 100644\n--- a/src/facade/CMakeLists.txt\n+++ b/src/facade/CMakeLists.txt\n@@ -3,7 +3,7 @@ cxx_link(dfly_parser_lib base strings_lib)\n \n add_library(dfly_facade conn_context.cc dragonfly_listener.cc dragonfly_connection.cc facade.cc\n             memcache_parser.cc reply_builder.cc op_status.cc service_interface.cc\n-            reply_capture.cc cmd_arg_parser.cc tls_error.cc)\n+            reply_capture.cc cmd_arg_parser.cc tls_helpers.cc)\n \n if (DF_USE_SSL)\n   set(TLS_LIB tls_lib)\ndiff --git a/src/facade/dragonfly_listener.cc b/src/facade/dragonfly_listener.cc\nindex ddde92164fda..733f65116dc2 100644\n--- a/src/facade/dragonfly_listener.cc\n+++ b/src/facade/dragonfly_listener.cc\n@@ -1,4 +1,4 @@\n-// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n //\n \n@@ -9,7 +9,7 @@\n #include <memory>\n \n #include \"absl/functional/bind_front.h\"\n-#include \"facade/tls_error.h\"\n+#include \"facade/tls_helpers.h\"\n \n #ifdef DFLY_USE_SSL\n #include <openssl/ssl.h>\n@@ -29,12 +29,11 @@ ABSL_FLAG(bool, conn_use_incoming_cpu, false,\n           \"If true uses incoming cpu of a socket in order to distribute\"\n           \" incoming connections\");\n \n-ABSL_FLAG(string, tls_cert_file, \"\", \"cert file for tls connections\");\n-ABSL_FLAG(string, tls_key_file, \"\", \"key file for tls connections\");\n-ABSL_FLAG(string, tls_ca_cert_file, \"\", \"ca signed certificate to validate tls connections\");\n-ABSL_FLAG(string, tls_ca_cert_dir, \"\",\n-          \"ca signed certificates directory. Use c_rehash before, read description in \"\n-          \"https://www.openssl.org/docs/man3.0/man1/c_rehash.html\");\n+ABSL_DECLARE_FLAG(std::string, tls_cert_file);\n+ABSL_DECLARE_FLAG(std::string, tls_key_file);\n+ABSL_DECLARE_FLAG(std::string, tls_ca_cert_file);\n+ABSL_DECLARE_FLAG(std::string, tls_ca_cert_dir);\n+\n ABSL_FLAG(uint32_t, tcp_keepalive, 300,\n           \"the period in seconds of inactivity after which keep-alives are triggerred,\"\n           \"the duration until an inactive connection is terminated is twice the specified time\");\n@@ -71,61 +70,6 @@ using absl::GetFlag;\n \n namespace {\n \n-#ifdef DFLY_USE_SSL\n-\n-// Creates the TLS context. Returns nullptr if the TLS configuration is invalid.\n-// To connect: openssl s_client -state -crlf -connect 127.0.0.1:6380\n-SSL_CTX* CreateSslServerCntx() {\n-  const auto& tls_key_file = GetFlag(FLAGS_tls_key_file);\n-  if (tls_key_file.empty()) {\n-    LOG(ERROR) << \"To use TLS, a server certificate must be provided with the --tls_key_file flag!\";\n-    return nullptr;\n-  }\n-\n-  SSL_CTX* ctx = SSL_CTX_new(TLS_server_method());\n-  unsigned mask = SSL_VERIFY_NONE;\n-\n-  if (SSL_CTX_use_PrivateKey_file(ctx, tls_key_file.c_str(), SSL_FILETYPE_PEM) != 1) {\n-    LOG(ERROR) << \"Failed to load TLS key\";\n-    return nullptr;\n-  }\n-  const auto& tls_cert_file = GetFlag(FLAGS_tls_cert_file);\n-\n-  if (!tls_cert_file.empty()) {\n-    // TO connect with redis-cli you need both tls-key-file and tls-cert-file\n-    // loaded. Use `redis-cli --tls -p 6380 --insecure  PING` to test\n-    if (SSL_CTX_use_certificate_chain_file(ctx, tls_cert_file.c_str()) != 1) {\n-      LOG(ERROR) << \"Failed to load TLS certificate\";\n-      return nullptr;\n-    }\n-  }\n-\n-  const auto tls_ca_cert_file = GetFlag(FLAGS_tls_ca_cert_file);\n-  const auto tls_ca_cert_dir = GetFlag(FLAGS_tls_ca_cert_dir);\n-  if (!tls_ca_cert_file.empty() || !tls_ca_cert_dir.empty()) {\n-    const auto* file = tls_ca_cert_file.empty() ? nullptr : tls_ca_cert_file.data();\n-    const auto* dir = tls_ca_cert_dir.empty() ? nullptr : tls_ca_cert_dir.data();\n-    if (SSL_CTX_load_verify_locations(ctx, file, dir) != 1) {\n-      LOG(ERROR) << \"Failed to load TLS verify locations (CA cert file or CA cert dir)\";\n-      return nullptr;\n-    }\n-    mask = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n-  }\n-\n-  DFLY_SSL_CHECK(1 == SSL_CTX_set_cipher_list(ctx, \"DEFAULT\"));\n-\n-  SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\n-\n-  SSL_CTX_set_options(ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);\n-\n-  SSL_CTX_set_verify(ctx, mask, NULL);\n-\n-  DFLY_SSL_CHECK(1 == SSL_CTX_set_dh_auto(ctx, 1));\n-\n-  return ctx;\n-}\n-#endif\n-\n bool ConfigureKeepAlive(int fd) {\n   int val = 1;\n   if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) < 0)\n@@ -260,7 +204,7 @@ error_code Listener::ConfigureServerSocket(int fd) {\n bool Listener::ReconfigureTLS() {\n   SSL_CTX* prev_ctx = ctx_;\n   if (GetFlag(FLAGS_tls)) {\n-    SSL_CTX* ctx = CreateSslServerCntx();\n+    SSL_CTX* ctx = CreateSslCntx(facade::TlsContextRole::SERVER);\n     if (!ctx) {\n       return false;\n     }\ndiff --git a/src/facade/dragonfly_listener.h b/src/facade/dragonfly_listener.h\nindex 106884424e81..35e0c21673c9 100644\n--- a/src/facade/dragonfly_listener.h\n+++ b/src/facade/dragonfly_listener.h\n@@ -1,4 +1,4 @@\n-// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n //\n \ndiff --git a/src/facade/tls_error.cc b/src/facade/tls_error.cc\ndeleted file mode 100644\nindex b8d98c50ad84..000000000000\n--- a/src/facade/tls_error.cc\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-#include \"facade/tls_error.h\"\n-\n-#include <openssl/err.h>\n-\n-#include <string_view>\n-\n-#include \"base/logging.h\"\n-\n-#ifdef DFLY_USE_SSL\n-\n-void facade::PrintSSLError() {\n-  ERR_print_errors_cb(\n-      [](const char* str, size_t len, void* u) {\n-        LOG(ERROR) << std::string_view(str, len);\n-        return 1;\n-      },\n-      nullptr);\n-}\n-\n-#else\n-\n-void facade::PrintSSLError() {\n-}\n-\n-#endif\ndiff --git a/src/facade/tls_helpers.cc b/src/facade/tls_helpers.cc\nnew file mode 100644\nindex 000000000000..4ecf9e63da7e\n--- /dev/null\n+++ b/src/facade/tls_helpers.cc\n@@ -0,0 +1,98 @@\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+#include \"tls_helpers.h\"\n+\n+#include <openssl/err.h>\n+\n+#ifdef DFLY_USE_SSL\n+#include <openssl/ssl.h>\n+#endif\n+\n+#include <string>\n+\n+#include \"absl/functional/bind_front.h\"\n+#include \"base/flags.h\"\n+#include \"base/logging.h\"\n+\n+ABSL_FLAG(std::string, tls_cert_file, \"\", \"cert file for tls connections\");\n+ABSL_FLAG(std::string, tls_key_file, \"\", \"key file for tls connections\");\n+ABSL_FLAG(std::string, tls_ca_cert_file, \"\", \"ca signed certificate to validate tls connections\");\n+ABSL_FLAG(std::string, tls_ca_cert_dir, \"\",\n+          \"ca signed certificates directory. Use c_rehash before, read description in \"\n+          \"https://www.openssl.org/docs/man3.0/man1/c_rehash.html\");\n+\n+namespace facade {\n+\n+#ifdef DFLY_USE_SSL\n+\n+// Creates the TLS context. Returns nullptr if the TLS configuration is invalid.\n+// To connect: openssl s_client -state -crlf -connect 127.0.0.1:6380\n+SSL_CTX* CreateSslCntx(TlsContextRole role) {\n+  using absl::GetFlag;\n+  const auto& tls_key_file = GetFlag(FLAGS_tls_key_file);\n+  if (tls_key_file.empty()) {\n+    LOG(ERROR) << \"To use TLS, a server certificate must be provided with the --tls_key_file flag!\";\n+    return nullptr;\n+  }\n+\n+  SSL_CTX* ctx;\n+\n+  if (role == TlsContextRole::SERVER) {\n+    ctx = SSL_CTX_new(TLS_server_method());\n+  } else {\n+    ctx = SSL_CTX_new(TLS_client_method());\n+  }\n+  unsigned mask = SSL_VERIFY_NONE;\n+\n+  if (SSL_CTX_use_PrivateKey_file(ctx, tls_key_file.c_str(), SSL_FILETYPE_PEM) != 1) {\n+    LOG(ERROR) << \"Failed to load TLS key\";\n+    return nullptr;\n+  }\n+  const auto& tls_cert_file = GetFlag(FLAGS_tls_cert_file);\n+\n+  if (!tls_cert_file.empty()) {\n+    // TO connect with redis-cli you need both tls-key-file and tls-cert-file\n+    // loaded. Use `redis-cli --tls -p 6380 --insecure  PING` to test\n+    if (SSL_CTX_use_certificate_chain_file(ctx, tls_cert_file.c_str()) != 1) {\n+      LOG(ERROR) << \"Failed to load TLS certificate\";\n+      return nullptr;\n+    }\n+  }\n+\n+  const auto tls_ca_cert_file = GetFlag(FLAGS_tls_ca_cert_file);\n+  const auto tls_ca_cert_dir = GetFlag(FLAGS_tls_ca_cert_dir);\n+  if (!tls_ca_cert_file.empty() || !tls_ca_cert_dir.empty()) {\n+    const auto* file = tls_ca_cert_file.empty() ? nullptr : tls_ca_cert_file.data();\n+    const auto* dir = tls_ca_cert_dir.empty() ? nullptr : tls_ca_cert_dir.data();\n+    if (SSL_CTX_load_verify_locations(ctx, file, dir) != 1) {\n+      LOG(ERROR) << \"Failed to load TLS verify locations (CA cert file or CA cert dir)\";\n+      return nullptr;\n+    }\n+    mask = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n+  }\n+\n+  DFLY_SSL_CHECK(1 == SSL_CTX_set_cipher_list(ctx, \"DEFAULT\"));\n+\n+  SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\n+\n+  SSL_CTX_set_options(ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);\n+\n+  SSL_CTX_set_verify(ctx, mask, NULL);\n+\n+  DFLY_SSL_CHECK(1 == SSL_CTX_set_dh_auto(ctx, 1));\n+\n+  return ctx;\n+}\n+\n+void PrintSSLError() {\n+  ERR_print_errors_cb(\n+      [](const char* str, size_t len, void* u) {\n+        LOG(ERROR) << std::string_view(str, len);\n+        return 1;\n+      },\n+      nullptr);\n+}\n+\n+#endif\n+}  // namespace facade\ndiff --git a/src/facade/tls_error.h b/src/facade/tls_helpers.h\nsimilarity index 57%\nrename from src/facade/tls_error.h\nrename to src/facade/tls_helpers.h\nindex 52164cd11f99..c0ca7d0f1587 100644\n--- a/src/facade/tls_error.h\n+++ b/src/facade/tls_helpers.h\n@@ -1,14 +1,21 @@\n-// Copyright 2023, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n //\n \n #pragma once\n \n+#ifdef DFLY_USE_SSL\n+#include <openssl/ssl.h>\n+#endif\n+\n namespace facade {\n \n-void PrintSSLError();\n+#ifdef DFLY_USE_SSL\n+enum class TlsContextRole { SERVER, CLIENT };\n+\n+SSL_CTX* CreateSslCntx(TlsContextRole role);\n \n-}\n+void PrintSSLError();\n \n #define DFLY_SSL_CHECK(condition)               \\\n   if (!(condition)) {                           \\\n@@ -16,3 +23,7 @@ void PrintSSLError();\n     PrintSSLError();                            \\\n     exit(17);                                   \\\n   }\n+\n+#endif\n+\n+}  // namespace facade\ndiff --git a/src/server/protocol_client.cc b/src/server/protocol_client.cc\nindex aeb46e69c73e..df6be0dd0b03 100644\n--- a/src/server/protocol_client.cc\n+++ b/src/server/protocol_client.cc\n@@ -3,7 +3,7 @@\n //\n #include \"server/protocol_client.h\"\n \n-#include \"facade/tls_error.h\"\n+#include \"facade/tls_helpers.h\"\n \n extern \"C\" {\n #include \"redis/rdb.h\"\n@@ -54,46 +54,6 @@ using absl::StrCat;\n \n namespace {\n \n-#ifdef DFLY_USE_SSL\n-\n-static ProtocolClient::SSL_CTX* CreateSslClientCntx() {\n-  ProtocolClient::SSL_CTX* ctx = SSL_CTX_new(TLS_client_method());\n-  const auto& tls_key_file = GetFlag(FLAGS_tls_key_file);\n-  unsigned mask = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n-\n-  // Load client certificate if given.\n-  if (!tls_key_file.empty()) {\n-    DFLY_SSL_CHECK(1 == SSL_CTX_use_PrivateKey_file(ctx, tls_key_file.c_str(), SSL_FILETYPE_PEM));\n-    // We checked that the flag is non empty in ValidateClientTlsFlags.\n-    const auto& tls_cert_file = GetFlag(FLAGS_tls_cert_file);\n-\n-    DFLY_SSL_CHECK(1 == SSL_CTX_use_certificate_chain_file(ctx, tls_cert_file.c_str()));\n-  }\n-\n-  // Load custom certificate validation if given.\n-  const auto& tls_ca_cert_file = GetFlag(FLAGS_tls_ca_cert_file);\n-  const auto& tls_ca_cert_dir = GetFlag(FLAGS_tls_ca_cert_dir);\n-\n-  const auto* file = tls_ca_cert_file.empty() ? nullptr : tls_ca_cert_file.data();\n-  const auto* dir = tls_ca_cert_dir.empty() ? nullptr : tls_ca_cert_dir.data();\n-  if (file || dir) {\n-    DFLY_SSL_CHECK(1 == SSL_CTX_load_verify_locations(ctx, file, dir));\n-  } else {\n-    DFLY_SSL_CHECK(1 == SSL_CTX_set_default_verify_paths(ctx));\n-  }\n-\n-  DFLY_SSL_CHECK(1 == SSL_CTX_set_cipher_list(ctx, \"DEFAULT\"));\n-  SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\n-\n-  SSL_CTX_set_options(ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);\n-\n-  SSL_CTX_set_verify(ctx, mask, NULL);\n-\n-  DFLY_SSL_CHECK(1 == SSL_CTX_set_dh_auto(ctx, 1));\n-  return ctx;\n-}\n-#endif\n-\n error_code Recv(FiberSocketBase* input, base::IoBuf* dest) {\n   auto buf = dest->AppendBuffer();\n   io::Result<size_t> exp_size = input->Recv(buf);\n@@ -136,9 +96,11 @@ void ValidateClientTlsFlags() {\n }\n \n void ProtocolClient::MaybeInitSslCtx() {\n+#ifdef DFLY_USE_SSL\n   if (absl::GetFlag(FLAGS_tls_replication)) {\n-    ssl_ctx_ = CreateSslClientCntx();\n+    ssl_ctx_ = CreateSslCntx(facade::TlsContextRole::CLIENT);\n   }\n+#endif\n }\n \n ProtocolClient::ProtocolClient(string host, uint16_t port) {\n",
  "test_patch": "diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex a542c01bfa3f..9c1a41266b1f 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -1491,6 +1491,35 @@ async def test_tls_replication(\n     await proxy.close(proxy_task)\n \n \n+@dfly_args({\"proactor_threads\": 2})\n+async def test_tls_replication_without_ca(\n+    df_factory,\n+    df_seeder_factory,\n+    with_tls_server_args,\n+    with_ca_tls_client_args,\n+):\n+    # 1. Spin up dragonfly tls enabled, debug populate\n+    master = df_factory.create(tls_replication=\"true\", **with_tls_server_args, requirepass=\"hi\")\n+    master.start()\n+    # Somehow redis-py forces to verify the certificate and it fails\n+    # TODO investigate why and remove with_ca_tls_clients_args\n+    c_master = master.client(password=\"hi\", **with_ca_tls_client_args)\n+    await c_master.execute_command(\"DEBUG POPULATE 100\")\n+\n+    # 2. Spin up a replica and initiate a REPLICAOF\n+    replica = df_factory.create(\n+        tls_replication=\"true\", **with_tls_server_args, masterauth=\"hi\", requirepass=\"hi\"\n+    )\n+    replica.start()\n+\n+    c_replica = replica.client(password=\"hi\", **with_ca_tls_client_args)\n+\n+    res = await c_replica.execute_command(\"REPLICAOF localhost \" + str(master.port))\n+    assert \"OK\" == res\n+    await check_all_replicas_finished([c_replica], c_master)\n+    assert 100 == await c_replica.execute_command(\"dbsize\")\n+\n+\n @pytest.mark.exclude_epoll\n async def test_ipv6_replication(df_factory: DflyInstanceFactory):\n     \"\"\"Test that IPV6 addresses work for replication, ::1 is 127.0.0.1 localhost\"\"\"\n",
  "problem_statement": "TLS Handshake Error: \"wrong version number\" with --tls\nI started Dragonfly with the flags --tls, --tls_key_file, and --tls_cert_file, but after the server starts, the following log message keeps appearing repeatedly.\n**W20250129 15:59:21.307173 1357310 dragonfly_connection.cc:696] Error handshaking error:1408F10B:SSL routines:ssl3_get_record:wrong version number** \n\nDoes DragonflyDB support specific TLS versions, and do I need to configure them explicitly?\n",
  "hints_text": "Hi @jahnavilatha589, thanks for reporting this. I will proceed with that and get back to you later\n@jahnavilatha589  do you succeed to connect to the instance?\n@romange , Yes.able to connect to instance\nso maybe it's bots scanning your open ports, trying to connect? is your connection accessible from the internet?\n@romange , No, Not accessible from the internet\nNow it's working. Instance receiving requests from Monitoring tool. Thank you.\n@BagritsevichStepan  you are very quick :)\ni think there i a lesson here that we can still learn from.\nIf I run dragonfly with tls mode but use plain protocol `echo PING | nc localhost 6379`, I will get a clear response from Dragonfly \"-ERR Bad TLS header, double check if you enabled TLS for your client\"\n\nbut the logs will contain:\n```\nW20250130 15:07:56.191462 86915 tls_engine.cc:243] SSL protocol error 0:167772427 wrong version number /home/roman/projects/dragonfly/helio/util/tls/tls_engine.cc : 136\nI20250130 15:07:56.191491 86915 dragonfly_connection.cc:706] Error handshaking Software caused connection abort\n```\n\nwhich looks disturbing. We should tone down the logs or at least have better wording\n\nIt wasn't me who closed the ticket \ud83d\ude04 \nBut okay, I will fix that.\nEnabled TLS with flags --tls, --tls_key_file, --tls_cert_file, and tls_replication. Now replication stops working. \n\n```\n127.0.0.1:6379> REPLICAOF 10.12.34.53 6380\n(error) ERR could not connect to master: Unknown error 337047686\n```\nLOGS in master : \nW20250130 18:37:55.819727 3868529 dragonfly_connection.cc:688] Error handshaking Software caused connection abort\nW20250130 18:37:56.320842 3868531 dragonfly_connection.cc:688] Error handshaking Software caused connection abort\nW20250130 18:37:57.023748 3868532 dragonfly_connection.cc:688] Error handshaking Software caused connection abort\nW20250130 18:37:57.068193 3868533 dragonfly_connection.cc:688] Error handshaking Software caused connection abort\n\n**Is --tls_ca_cert_file mandatory flag for replication.?**\n\n@kostasrim can you help please?\n> Enabled TLS with flags --tls, --tls_key_file, --tls_cert_file, and tls_replication. Now replication stops working.\n> \n> ```\n> 127.0.0.1:6379> REPLICAOF 10.12.34.53 6380\n> (error) ERR could not connect to master: Unknown error 337047686\n> ```\n> \n> LOGS in master : W20250130 18:37:55.819727 3868529 dragonfly_connection.cc:688] Error handshaking Software caused connection abort W20250130 18:37:56.320842 3868531 dragonfly_connection.cc:688] Error handshaking Software caused connection abort W20250130 18:37:57.023748 3868532 dragonfly_connection.cc:688] Error handshaking Software caused connection abort W20250130 18:37:57.068193 3868533 dragonfly_connection.cc:688] Error handshaking Software caused connection abort\n> \n> **Is --tls_ca_cert_file mandatory flag for replication.?**\n\nhow did you configure master and replica ? Plz place the exact `commands` you used to run both master and replica\n**Master :  dragonfly.conf**\n\n--tiered_prefix=storage/flash/flash\n--aclfile=aclfile.txt\n--dir=storage/data\n--version_check=false\n--hz=1\n--snapshot_cron=/30  * * *\n--masteruser=repl\n--masterauth=hypermemreplpwd\n--proactor_threads=8\n\n**start command :**  ./dragonfly --flagfile=dragonfly.conf --tls --tls_key_file=/certs/hypermem.key --tls_cert_file=/certs/hypermem.pem --requirepass=test --port=6380 --tls_replication \n\n**Replica : dragonfly.conf** \n\n--tiered_prefix=storage/flash/flash\n--aclfile=aclfile.txt\n--dir=storage/data\n--version_check=false\n--hz=1\n--snapshot_cron=/30  * * *\n--masteruser=repl\n--masterauth=hypermemreplpwd\n--proactor_threads=8\n--replicaof=10.12.32.78:6380\n\n**start command :**     ./dragonfly --flagfile=dragonfly.conf --tls --tls_key_file=/certs/hypermem.key --tls_cert_file=/certs/hypermem.pem --requirepass=test --port=6380 --tls_replication \nif `--requirepass=test` than your `--masterauth=` on replica should also be test.\n^^ this\n@romange I wanted to add a configuration test (we only got replication with tls and `ca_cert`) and it failed. Basically, replication with tls enabled and without `ca_cert` is broken. Generally you want some form of authorization, which is offered by requirepass or by the certified authority. Should be a simple fix + I will add some tests such that we don't break it again.\n\n@jahnavilatha589 for now plz use `ca_cert` and `masterauth` flag until the former is addressed.",
  "created_at": "2025-01-30T20:09:23Z",
  "modified_files": [
    "src/facade/CMakeLists.txt",
    "src/facade/dragonfly_listener.cc",
    "src/facade/dragonfly_listener.h",
    "src/facade/tls_error.cc",
    "b/src/facade/tls_helpers.cc",
    "src/facade/tls_error.h",
    "src/server/protocol_client.cc"
  ],
  "modified_test_files": [
    "tests/dragonfly/replication_test.py"
  ]
}