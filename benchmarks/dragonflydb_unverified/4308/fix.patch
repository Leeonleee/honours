diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc
index 9b79315ed192..64645c7f53aa 100644
--- a/src/core/compact_object.cc
+++ b/src/core/compact_object.cc
@@ -276,6 +276,15 @@ pair<void*, bool> DefragSortedMap(detail::SortedMap* sm, float ratio) {
   return {sm, reallocated};
 }
 
+pair<void*, bool> DefragStrSet(StringSet* ss, float ratio) {
+  bool realloced = false;
+
+  for (auto it = ss->begin(); it != ss->end(); ++it)
+    realloced |= it.ReallocIfNeeded(ratio);
+
+  return {ss, realloced};
+}
+
 // Iterates over allocations of internal hash data structures and re-allocates
 // them if their pages are underutilized.
 // Returns pointer to new object ptr and whether any re-allocations happened.
@@ -304,8 +313,7 @@ pair<void*, bool> DefragSet(unsigned encoding, void* ptr, float ratio) {
     }
 
     case kEncodingStrMap2: {
-      // Still not implemented
-      return {ptr, false};
+      return DefragStrSet((StringSet*)ptr, ratio);
     }
 
     default:
diff --git a/src/core/string_set.cc b/src/core/string_set.cc
index e231375b857c..9ab97be6f0d7 100644
--- a/src/core/string_set.cc
+++ b/src/core/string_set.cc
@@ -165,4 +165,44 @@ sds StringSet::MakeSetSds(string_view src, uint32_t ttl_sec) const {
   return sdsnewlen(src.data(), src.size());
 }
 
+// Does not release obj. Callers must deallocate with sdsfree explicitly
+pair<sds, bool> StringSet::DuplicateEntryIfFragmented(void* obj, float ratio) {
+  sds key = (sds)obj;
+
+  if (!zmalloc_page_is_underutilized(key, ratio))
+    return {key, false};
+
+  size_t key_len = sdslen(key);
+  bool has_ttl = MayHaveTtl(key);
+
+  if (has_ttl) {
+    sds res = AllocSdsWithSpace(key_len, sizeof(uint32_t));
+    std::memcpy(res, key, key_len + sizeof(uint32_t));
+    return {res, true};
+  }
+
+  return {sdsnewlen(key, key_len), true};
+}
+
+bool StringSet::iterator::ReallocIfNeeded(float ratio) {
+  auto* ptr = curr_entry_;
+  if (ptr->IsLink()) {
+    ptr = ptr->AsLink();
+  }
+
+  DCHECK(!ptr->IsEmpty());
+  DCHECK(ptr->IsObject());
+
+  auto* obj = ptr->GetObject();
+  auto [new_obj, realloced] =
+      static_cast<StringSet*>(owner_)->DuplicateEntryIfFragmented(obj, ratio);
+
+  if (realloced) {
+    ptr->SetObject(new_obj);
+    sdsfree((sds)obj);
+  }
+
+  return realloced;
+}
+
 }  // namespace dfly
diff --git a/src/core/string_set.h b/src/core/string_set.h
index 8ff3c8477ad0..1edf755da73b 100644
--- a/src/core/string_set.h
+++ b/src/core/string_set.h
@@ -85,6 +85,10 @@ class StringSet : public DenseSet {
     using IteratorBase::ExpiryTime;
     using IteratorBase::HasExpiry;
     using IteratorBase::SetExpiryTime;
+
+    // Try reducing memory fragmentation of the value by re-allocating. Returns true if
+    // re-allocation happened.
+    bool ReallocIfNeeded(float ratio);
   };
 
   iterator begin() {
@@ -114,6 +118,9 @@ class StringSet : public DenseSet {
   void ObjDelete(void* obj, bool has_ttl) const override;
   void* ObjectClone(const void* obj, bool has_ttl, bool add_ttl) const override;
   sds MakeSetSds(std::string_view src, uint32_t ttl_sec) const;
+
+ private:
+  std::pair<sds, bool> DuplicateEntryIfFragmented(void* obj, float ratio);
 };
 
 template <typename T> unsigned StringSet::AddMany(absl::Span<T> span, uint32_t ttl_sec) {
