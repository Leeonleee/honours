{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4308,
  "instance_id": "dragonflydb__dragonfly-4308",
  "issue_numbers": [
    "3822"
  ],
  "base_commit": "3fdd9877f40aeebc9d7a05089d7299202da932bc",
  "patch": "diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex 9b79315ed192..64645c7f53aa 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -276,6 +276,15 @@ pair<void*, bool> DefragSortedMap(detail::SortedMap* sm, float ratio) {\n   return {sm, reallocated};\n }\n \n+pair<void*, bool> DefragStrSet(StringSet* ss, float ratio) {\n+  bool realloced = false;\n+\n+  for (auto it = ss->begin(); it != ss->end(); ++it)\n+    realloced |= it.ReallocIfNeeded(ratio);\n+\n+  return {ss, realloced};\n+}\n+\n // Iterates over allocations of internal hash data structures and re-allocates\n // them if their pages are underutilized.\n // Returns pointer to new object ptr and whether any re-allocations happened.\n@@ -304,8 +313,7 @@ pair<void*, bool> DefragSet(unsigned encoding, void* ptr, float ratio) {\n     }\n \n     case kEncodingStrMap2: {\n-      // Still not implemented\n-      return {ptr, false};\n+      return DefragStrSet((StringSet*)ptr, ratio);\n     }\n \n     default:\ndiff --git a/src/core/string_set.cc b/src/core/string_set.cc\nindex e231375b857c..9ab97be6f0d7 100644\n--- a/src/core/string_set.cc\n+++ b/src/core/string_set.cc\n@@ -165,4 +165,44 @@ sds StringSet::MakeSetSds(string_view src, uint32_t ttl_sec) const {\n   return sdsnewlen(src.data(), src.size());\n }\n \n+// Does not release obj. Callers must deallocate with sdsfree explicitly\n+pair<sds, bool> StringSet::DuplicateEntryIfFragmented(void* obj, float ratio) {\n+  sds key = (sds)obj;\n+\n+  if (!zmalloc_page_is_underutilized(key, ratio))\n+    return {key, false};\n+\n+  size_t key_len = sdslen(key);\n+  bool has_ttl = MayHaveTtl(key);\n+\n+  if (has_ttl) {\n+    sds res = AllocSdsWithSpace(key_len, sizeof(uint32_t));\n+    std::memcpy(res, key, key_len + sizeof(uint32_t));\n+    return {res, true};\n+  }\n+\n+  return {sdsnewlen(key, key_len), true};\n+}\n+\n+bool StringSet::iterator::ReallocIfNeeded(float ratio) {\n+  auto* ptr = curr_entry_;\n+  if (ptr->IsLink()) {\n+    ptr = ptr->AsLink();\n+  }\n+\n+  DCHECK(!ptr->IsEmpty());\n+  DCHECK(ptr->IsObject());\n+\n+  auto* obj = ptr->GetObject();\n+  auto [new_obj, realloced] =\n+      static_cast<StringSet*>(owner_)->DuplicateEntryIfFragmented(obj, ratio);\n+\n+  if (realloced) {\n+    ptr->SetObject(new_obj);\n+    sdsfree((sds)obj);\n+  }\n+\n+  return realloced;\n+}\n+\n }  // namespace dfly\ndiff --git a/src/core/string_set.h b/src/core/string_set.h\nindex 8ff3c8477ad0..1edf755da73b 100644\n--- a/src/core/string_set.h\n+++ b/src/core/string_set.h\n@@ -85,6 +85,10 @@ class StringSet : public DenseSet {\n     using IteratorBase::ExpiryTime;\n     using IteratorBase::HasExpiry;\n     using IteratorBase::SetExpiryTime;\n+\n+    // Try reducing memory fragmentation of the value by re-allocating. Returns true if\n+    // re-allocation happened.\n+    bool ReallocIfNeeded(float ratio);\n   };\n \n   iterator begin() {\n@@ -114,6 +118,9 @@ class StringSet : public DenseSet {\n   void ObjDelete(void* obj, bool has_ttl) const override;\n   void* ObjectClone(const void* obj, bool has_ttl, bool add_ttl) const override;\n   sds MakeSetSds(std::string_view src, uint32_t ttl_sec) const;\n+\n+ private:\n+  std::pair<sds, bool> DuplicateEntryIfFragmented(void* obj, float ratio);\n };\n \n template <typename T> unsigned StringSet::AddMany(absl::Span<T> span, uint32_t ttl_sec) {\n",
  "test_patch": "diff --git a/src/core/string_set_test.cc b/src/core/string_set_test.cc\nindex f39166dc78b5..8deeacc05033 100644\n--- a/src/core/string_set_test.cc\n+++ b/src/core/string_set_test.cc\n@@ -657,4 +657,50 @@ void BM_Grow(benchmark::State& state) {\n }\n BENCHMARK(BM_Grow);\n \n+unsigned total_wasted_memory = 0;\n+\n+TEST_F(StringSetTest, ReallocIfNeeded) {\n+  auto build_str = [](size_t i) { return to_string(i) + string(131, 'a'); };\n+\n+  auto count_waste = [](const mi_heap_t* heap, const mi_heap_area_t* area, void* block,\n+                        size_t block_size, void* arg) {\n+    size_t used = block_size * area->used;\n+    total_wasted_memory += area->committed - used;\n+    return true;\n+  };\n+\n+  for (size_t i = 0; i < 10'000; i++)\n+    ss_->Add(build_str(i));\n+\n+  for (size_t i = 0; i < 10'000; i++) {\n+    if (i % 10 == 0)\n+      continue;\n+    ss_->Erase(build_str(i));\n+  }\n+\n+  mi_heap_collect(mi_heap_get_backing(), true);\n+  mi_heap_visit_blocks(mi_heap_get_backing(), false, count_waste, nullptr);\n+  size_t wasted_before = total_wasted_memory;\n+\n+  size_t underutilized = 0;\n+  for (auto it = ss_->begin(); it != ss_->end(); ++it) {\n+    underutilized += zmalloc_page_is_underutilized(*it, 0.9);\n+    it.ReallocIfNeeded(0.9);\n+  }\n+  // Check there are underutilized pages\n+  CHECK_GT(underutilized, 0u);\n+\n+  total_wasted_memory = 0;\n+  mi_heap_collect(mi_heap_get_backing(), true);\n+  mi_heap_visit_blocks(mi_heap_get_backing(), false, count_waste, nullptr);\n+  size_t wasted_after = total_wasted_memory;\n+\n+  // Check we waste significanlty less now\n+  EXPECT_GT(wasted_before, wasted_after * 2);\n+\n+  EXPECT_EQ(ss_->UpperBoundSize(), 1000);\n+  for (size_t i = 0; i < 1000; i++)\n+    EXPECT_EQ(*ss_->Find(build_str(i * 10)), build_str(i * 10));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "Implement defragmentation for OBJ_ZSET and OBJ_SET\nToday we support defrag only for OBJ_STRING and OBJ_HASH see RobjWrapper::DefragIfNeeded\r\nWe want to add support for OBJ_ZSET and OBJ_SET\r\n\r\n- [x] Defrag for ZSet\r\n- [ ] Defrag for Set\r\n\n",
  "hints_text": "@adiholden see https://github.com/dragonflydb/dragonfly/pull/4283#issuecomment-2530737762 \nI will try to patch this today, I think I will have the bandwidth",
  "created_at": "2024-12-13T10:14:40Z",
  "modified_files": [
    "src/core/compact_object.cc",
    "src/core/string_set.cc",
    "src/core/string_set.h"
  ],
  "modified_test_files": [
    "src/core/string_set_test.cc"
  ]
}