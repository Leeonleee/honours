diff --git a/src/redis/object.c b/src/redis/object.c
index 45ae81acf657..8763d26e05f4 100644
--- a/src/redis/object.c
+++ b/src/redis/object.c
@@ -1175,7 +1175,7 @@ sds getMemoryDoctorReport(void) {
     return s;
 }
 
-#endif
+
 
 /* Set the object LRU/LFU depending on server.maxmemory_policy.
  * The lfu_freq arg is only relevant if policy is MAXMEMORY_FLAG_LFU.
@@ -1210,3 +1210,4 @@ int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
     return 0;
 }
 
+#endif
diff --git a/src/server/db_slice.cc b/src/server/db_slice.cc
index 9df2f626ec62..15a2a55b4f96 100644
--- a/src/server/db_slice.cc
+++ b/src/server/db_slice.cc
@@ -124,6 +124,10 @@ unsigned PrimeEvictionPolicy::Evict(const PrimeTable::HotspotBuckets& eb, PrimeT
   auto last_slot_it = bucket_it;
   last_slot_it += (PrimeTable::kBucketWidth - 1);
   if (!last_slot_it.is_done()) {
+    if (last_slot_it->second.HasExpire()) {
+      ExpireTable* expire_tbl = db_slice_->GetTables(db_indx_).second;
+      CHECK_EQ(1u, expire_tbl->Erase(last_slot_it->first));
+    }
     UpdateStatsOnDeletion(last_slot_it, db_slice_->MutableStats(db_indx_));
   }
   CHECK(me->ShiftRight(bucket_it));
@@ -446,7 +450,6 @@ bool DbSlice::UpdateExpire(DbIndex db_ind, PrimeIterator it, uint64_t at) {
 
   if (!it->second.HasExpire() && at) {
     uint64_t delta = at - expire_base_[0];  // TODO: employ multigen expire updates.
-
     CHECK(db.expire.Insert(it->first.AsRef(), ExpirePeriod(delta)).second);
     it->second.SetExpire(true);
 
diff --git a/src/server/db_slice.h b/src/server/db_slice.h
index 9e83e50badce..5fc74ff35e08 100644
--- a/src/server/db_slice.h
+++ b/src/server/db_slice.h
@@ -237,6 +237,10 @@ class DbSlice {
     return db_arr_;
   }
 
+  void TEST_EnableCacheMode() {
+    caching_mode_ = 1;
+  }
+
  private:
   void CreateDb(DbIndex index);
 
diff --git a/src/server/engine_shard_set.cc b/src/server/engine_shard_set.cc
index c8bd6770c2ff..1e6ea49b1bf0 100644
--- a/src/server/engine_shard_set.cc
+++ b/src/server/engine_shard_set.cc
@@ -381,4 +381,8 @@ void EngineShardSet::TEST_EnableHeartBeat() {
   RunBriefInParallel([](EngineShard* shard) { shard->TEST_EnableHeartbeat(); });
 }
 
+void EngineShardSet::TEST_EnableCacheMode() {
+  RunBriefInParallel([](EngineShard* shard) { shard->db_slice().TEST_EnableCacheMode(); });
+}
+
 }  // namespace dfly
diff --git a/src/server/engine_shard_set.h b/src/server/engine_shard_set.h
index d0dc5e12de1f..e09ba02b6846 100644
--- a/src/server/engine_shard_set.h
+++ b/src/server/engine_shard_set.h
@@ -226,6 +226,7 @@ class EngineShardSet {
 
   // Used in tests
   void TEST_EnableHeartBeat();
+  void TEST_EnableCacheMode();
 
  private:
   void InitThreadLocal(util::ProactorBase* pb, bool update_db_time);
diff --git a/src/server/string_family.cc b/src/server/string_family.cc
index 87a0d74fcc61..c0eb64a8682f 100644
--- a/src/server/string_family.cc
+++ b/src/server/string_family.cc
@@ -501,6 +501,7 @@ void StringFamily::ExtendGeneric(CmdArgList args, bool prepend, ConnectionContex
   builder->SendSetSkipped();
 }
 
+/// (P)SETEX key seconds value
 void StringFamily::SetExGeneric(bool seconds, CmdArgList args, ConnectionContext* cntx) {
   string_view key = ArgS(args, 1);
   string_view ex = ArgS(args, 2);
diff --git a/src/server/table.cc b/src/server/table.cc
index 4f6b2e087f15..9ead685d44f5 100644
--- a/src/server/table.cc
+++ b/src/server/table.cc
@@ -10,6 +10,9 @@ namespace dfly {
 
 #define ADD(x) (x) += o.x
 
+// It should be const, but we override this variable in our tests so that they run faster.
+unsigned kInitSegmentLog = 3;
+
 DbTableStats& DbTableStats::operator+=(const DbTableStats& o) {
   constexpr size_t kDbSz = sizeof(DbTableStats);
   static_assert(kDbSz == 56);
@@ -26,7 +29,7 @@ DbTableStats& DbTableStats::operator+=(const DbTableStats& o) {
 }
 
 DbTable::DbTable(std::pmr::memory_resource* mr)
-    : prime(2, detail::PrimeTablePolicy{}, mr),
+    : prime(kInitSegmentLog, detail::PrimeTablePolicy{}, mr),
       expire(0, detail::ExpireTablePolicy{}, mr),
       mcflag(0, detail::ExpireTablePolicy{}, mr) {
 }
diff --git a/src/server/table.h b/src/server/table.h
index a9cf27e65384..552f9c2ebc5b 100644
--- a/src/server/table.h
+++ b/src/server/table.h
@@ -71,6 +71,9 @@ struct DbTable : boost::intrusive_ref_counter<DbTable, boost::thread_unsafe_coun
   void Release(IntentLock::Mode mode, std::string_view key, unsigned count);
 };
 
+// We use reference counting semantics of DbTable when doing snapshotting.
+// There we need to preserve the copy of the table in case someone flushes it during
+// the snapshot process. We copy the pointers in StartSnapshotInShard function.
 using DbTableArray = std::vector<boost::intrusive_ptr<DbTable>>;
 
 }  // namespace dfly
