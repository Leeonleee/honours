{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 208,
  "instance_id": "dragonflydb__dragonfly-208",
  "issue_numbers": [
    "207"
  ],
  "base_commit": "d2b7987ac3048e997c8ec5967d0f4447740e8491",
  "patch": "diff --git a/src/redis/object.c b/src/redis/object.c\nindex 45ae81acf657..8763d26e05f4 100644\n--- a/src/redis/object.c\n+++ b/src/redis/object.c\n@@ -1175,7 +1175,7 @@ sds getMemoryDoctorReport(void) {\n     return s;\n }\n \n-#endif\n+\n \n /* Set the object LRU/LFU depending on server.maxmemory_policy.\n  * The lfu_freq arg is only relevant if policy is MAXMEMORY_FLAG_LFU.\n@@ -1210,3 +1210,4 @@ int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,\n     return 0;\n }\n \n+#endif\ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 9df2f626ec62..15a2a55b4f96 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -124,6 +124,10 @@ unsigned PrimeEvictionPolicy::Evict(const PrimeTable::HotspotBuckets& eb, PrimeT\n   auto last_slot_it = bucket_it;\n   last_slot_it += (PrimeTable::kBucketWidth - 1);\n   if (!last_slot_it.is_done()) {\n+    if (last_slot_it->second.HasExpire()) {\n+      ExpireTable* expire_tbl = db_slice_->GetTables(db_indx_).second;\n+      CHECK_EQ(1u, expire_tbl->Erase(last_slot_it->first));\n+    }\n     UpdateStatsOnDeletion(last_slot_it, db_slice_->MutableStats(db_indx_));\n   }\n   CHECK(me->ShiftRight(bucket_it));\n@@ -446,7 +450,6 @@ bool DbSlice::UpdateExpire(DbIndex db_ind, PrimeIterator it, uint64_t at) {\n \n   if (!it->second.HasExpire() && at) {\n     uint64_t delta = at - expire_base_[0];  // TODO: employ multigen expire updates.\n-\n     CHECK(db.expire.Insert(it->first.AsRef(), ExpirePeriod(delta)).second);\n     it->second.SetExpire(true);\n \ndiff --git a/src/server/db_slice.h b/src/server/db_slice.h\nindex 9e83e50badce..5fc74ff35e08 100644\n--- a/src/server/db_slice.h\n+++ b/src/server/db_slice.h\n@@ -237,6 +237,10 @@ class DbSlice {\n     return db_arr_;\n   }\n \n+  void TEST_EnableCacheMode() {\n+    caching_mode_ = 1;\n+  }\n+\n  private:\n   void CreateDb(DbIndex index);\n \ndiff --git a/src/server/engine_shard_set.cc b/src/server/engine_shard_set.cc\nindex c8bd6770c2ff..1e6ea49b1bf0 100644\n--- a/src/server/engine_shard_set.cc\n+++ b/src/server/engine_shard_set.cc\n@@ -381,4 +381,8 @@ void EngineShardSet::TEST_EnableHeartBeat() {\n   RunBriefInParallel([](EngineShard* shard) { shard->TEST_EnableHeartbeat(); });\n }\n \n+void EngineShardSet::TEST_EnableCacheMode() {\n+  RunBriefInParallel([](EngineShard* shard) { shard->db_slice().TEST_EnableCacheMode(); });\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/engine_shard_set.h b/src/server/engine_shard_set.h\nindex d0dc5e12de1f..e09ba02b6846 100644\n--- a/src/server/engine_shard_set.h\n+++ b/src/server/engine_shard_set.h\n@@ -226,6 +226,7 @@ class EngineShardSet {\n \n   // Used in tests\n   void TEST_EnableHeartBeat();\n+  void TEST_EnableCacheMode();\n \n  private:\n   void InitThreadLocal(util::ProactorBase* pb, bool update_db_time);\ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex 87a0d74fcc61..c0eb64a8682f 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -501,6 +501,7 @@ void StringFamily::ExtendGeneric(CmdArgList args, bool prepend, ConnectionContex\n   builder->SendSetSkipped();\n }\n \n+/// (P)SETEX key seconds value\n void StringFamily::SetExGeneric(bool seconds, CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   string_view ex = ArgS(args, 2);\ndiff --git a/src/server/table.cc b/src/server/table.cc\nindex 4f6b2e087f15..9ead685d44f5 100644\n--- a/src/server/table.cc\n+++ b/src/server/table.cc\n@@ -10,6 +10,9 @@ namespace dfly {\n \n #define ADD(x) (x) += o.x\n \n+// It should be const, but we override this variable in our tests so that they run faster.\n+unsigned kInitSegmentLog = 3;\n+\n DbTableStats& DbTableStats::operator+=(const DbTableStats& o) {\n   constexpr size_t kDbSz = sizeof(DbTableStats);\n   static_assert(kDbSz == 56);\n@@ -26,7 +29,7 @@ DbTableStats& DbTableStats::operator+=(const DbTableStats& o) {\n }\n \n DbTable::DbTable(std::pmr::memory_resource* mr)\n-    : prime(2, detail::PrimeTablePolicy{}, mr),\n+    : prime(kInitSegmentLog, detail::PrimeTablePolicy{}, mr),\n       expire(0, detail::ExpireTablePolicy{}, mr),\n       mcflag(0, detail::ExpireTablePolicy{}, mr) {\n }\ndiff --git a/src/server/table.h b/src/server/table.h\nindex a9cf27e65384..552f9c2ebc5b 100644\n--- a/src/server/table.h\n+++ b/src/server/table.h\n@@ -71,6 +71,9 @@ struct DbTable : boost::intrusive_ref_counter<DbTable, boost::thread_unsafe_coun\n   void Release(IntentLock::Mode mode, std::string_view key, unsigned count);\n };\n \n+// We use reference counting semantics of DbTable when doing snapshotting.\n+// There we need to preserve the copy of the table in case someone flushes it during\n+// the snapshot process. We copy the pointers in StartSnapshotInShard function.\n using DbTableArray = std::vector<boost::intrusive_ptr<DbTable>>;\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc\nindex b5f67739d240..c4148efb22a2 100644\n--- a/src/server/dragonfly_test.cc\n+++ b/src/server/dragonfly_test.cc\n@@ -7,6 +7,7 @@ extern \"C\" {\n #include \"redis/zmalloc.h\"\n }\n \n+#include <absl/flags/reflection.h>\n #include <absl/strings/ascii.h>\n #include <absl/strings/str_join.h>\n #include <absl/strings/strip.h>\n@@ -444,7 +445,7 @@ TEST_F(DflyEngineTest, OOM) {\n   max_memory_limit = 0;\n   size_t i = 0;\n   RespExpr resp;\n-  for (; i < 10000; i += 3) {\n+  for (; i < 5000; i += 3) {\n     resp = Run({\"mset\", StrCat(\"key\", i), \"bar\", StrCat(\"key\", i + 1), \"bar\", StrCat(\"key\", i + 2),\n                 \"bar\"});\n     if (resp != \"OK\")\n@@ -464,7 +465,7 @@ TEST_F(DflyEngineTest, OOM) {\n     }\n     run_args.push_back(\"bar\");\n \n-    for (unsigned i = 0; i < 10000; ++i) {\n+    for (unsigned i = 0; i < 5000; ++i) {\n       run_args[1] = StrCat(\"key\", cmd, i);\n       resp = Run(run_args);\n \n@@ -477,6 +478,27 @@ TEST_F(DflyEngineTest, OOM) {\n   }\n }\n \n+/// Reproduces the case where items with expiry data were evicted,\n+/// and then written with the same key.\n+TEST_F(DflyEngineTest, Bug207) {\n+  shard_set->TEST_EnableHeartBeat();\n+  shard_set->TEST_EnableCacheMode();\n+\n+  max_memory_limit = 0;\n+\n+  ssize_t i = 0;\n+  RespExpr resp;\n+  for (; i < 5000; ++i) {\n+    resp = Run({\"setex\", StrCat(\"key\", i), \"30\", \"bar\"});\n+    // we evict some items because 5000 is too much when max_memory_limit is zero.\n+    ASSERT_EQ(resp, \"OK\");\n+  }\n+\n+  for (; i > 0; --i) {\n+    resp = Run({\"setex\", StrCat(\"key\", i), \"30\", \"bar\"});\n+  }\n+}\n+\n TEST_F(DflyEngineTest, PSubscribe) {\n   single_response_ = false;\n   auto resp = pp_->at(1)->Await([&] { return Run({\"psubscribe\", \"a*\", \"b*\"}); });\ndiff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex 26a77681bb80..df234dafbd9f 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -23,6 +23,9 @@ using namespace std;\n ABSL_DECLARE_FLAG(string, dbfilename);\n \n namespace dfly {\n+\n+extern unsigned kInitSegmentLog;\n+\n using MP = MemcacheParser;\n using namespace util;\n using namespace testing;\n@@ -113,6 +116,8 @@ BaseFamilyTest::~BaseFamilyTest() {\n }\n \n void BaseFamilyTest::SetUpTestSuite() {\n+  kInitSegmentLog = 1;\n+\n   absl::SetFlag(&FLAGS_dbfilename, \"\");\n   init_zmalloc_threadlocal(mi_heap_get_backing());\n }\n",
  "problem_statement": "SIGABRT and dragonflydb crash on \"Check failed: db.expire.Insert\"\n**Describe the bug**\r\nWe're running dragonflydb v0.4.0 in cache mode (see exact command below), it serves SETEX requests at the rate of 40-60K op/s and crashes when its memory utilization reaches 98% or so (see graphs). By default it allocates about 80% of memory available and we're pretty sure evictions should not cause the crash but you can see clear correlation between evictions spikes and the crashes.\r\n\r\n```\r\n/usr/bin/dragonflydb -logtostderr -port=6480 -cache_mode=true\r\n```\r\n\r\nCrash error log:\r\n```\r\nI20220714 07:25:59.001474 125027 init.cc:56] /usr/bin/dragonflydb running in opt mode.\r\nI20220714 07:25:59.001526 125027 dfly_main.cc:179] maxmemory has not been specified. Deciding myself....\r\nI20220714 07:25:59.001564 125027 dfly_main.cc:184] Found 122.89GiB available memory. Setting maxmemory to 98.31GiB\r\nI20220714 07:25:59.001924 125029 proactor.cc:456] IORing with 1024 entries, allocated 102720 bytes, cq_entries is 2048\r\nI20220714 07:25:59.004504 125027 proactor_pool.cc:66] Running 16 io threads\r\nI20220714 07:25:59.006286 125027 server_family.cc:193] Data directory is \"/\"\r\nI20220714 07:25:59.006350 125027 server_family.cc:117] Checking \"/dump\"\r\nI20220714 07:25:59.006436 125031 listener_interface.cc:79] sock[51] AcceptServer - listening on port 6480\r\nF20220714 12:55:40.518728 125029 db_slice.cc:450] Check failed: db.expire.Insert(it->first.AsRef(), ExpirePeriod(delta)).second\r\n*** Check failure stack trace: ***\r\n    @     0x5622e4cc1c53  (unknown)\r\n    @     0x5622e4cba417  (unknown)\r\n    @     0x5622e4cbbd9f  (unknown)\r\n    @     0x5622e49fd73f  (unknown)\r\n    @     0x5622e4a3155d  (unknown)\r\n    @     0x5622e4a3187e  (unknown)\r\n    @     0x5622e4a2251e  (unknown)\r\n    @     0x5622e49e290f  (unknown)\r\n    @     0x5622e49de513  (unknown)\r\n    @     0x5622e4acd7bf  (unknown)\r\n*** SIGABRT received at time=1657803340 on cpu 0 ***\r\nPC: @     0x7fb74e8f000b  (unknown)  raise\r\n    @ ... and at least 1 more frames\r\n```\r\n\r\n**Screenshots**\r\n\r\nDisregard `redis` labels on the graphs, we're using redis exported for dragonflydb.\r\n\r\n![Screen Shot 2022-07-14 at 13 05 43](https://user-images.githubusercontent.com/14876304/179042325-40cfce55-0997-4ad9-995a-fe7144e8636c.png)\r\n\r\n**Desktop (please complete the following information):**\r\n - OS: Ubuntu 20.04.4 LTS\r\n - Kernel: 5.13.0-1031-aws\r\n - Containerized?: Bare Metal at EC2 under monit\r\n  - Version v0.4.0\r\n\r\n\n",
  "hints_text": "Update: I've tried to decrease `--hz` param (from default 1000 to 100, 50, 25) to make evictions more aggressive *but still see crashes*. They can be easily reproduced if I decrease `--maxmemory` so it saturates faster.\nThanks, Artem. `--hz` is not related. Finally an interesting bug. I am looking into it.\r\nFor the protocol,  runnig\r\n`dragonfly --alsologtostderr   --cache_mode   --maxmemory=300000000 --proactor_threads=1` \r\nand then sending SETEX traffic with \r\n`memtier_benchmark  --ratio 1:0 -n 600000  -c 40 --distinct-client-seed  --key-prefix=\"key:\"  --hide-histogram --expiry-range=30-30 --key-maximum=10000000 -d 2000` reproduces it.",
  "created_at": "2022-07-15T12:04:02Z",
  "modified_files": [
    "src/redis/object.c",
    "src/server/db_slice.cc",
    "src/server/db_slice.h",
    "src/server/engine_shard_set.cc",
    "src/server/engine_shard_set.h",
    "src/server/string_family.cc",
    "src/server/table.cc",
    "src/server/table.h"
  ],
  "modified_test_files": [
    "src/server/dragonfly_test.cc",
    "src/server/test_utils.cc"
  ]
}