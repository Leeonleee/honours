{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 951,
  "instance_id": "dragonflydb__dragonfly-951",
  "issue_numbers": [
    "257"
  ],
  "base_commit": "94b8951f5e235c13c4b440eab106b88ccb06322d",
  "patch": "diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex 00df29205d3e..cbcc357ed739 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -11,7 +11,7 @@ endif()\n add_library(dfly_transaction db_slice.cc malloc_stats.cc engine_shard_set.cc blocking_controller.cc\n             common.cc\n             io_mgr.cc journal/journal.cc journal/journal_slice.cc server_state.cc table.cc\n-            tiered_storage.cc transaction.cc)\n+            tiered_storage.cc top_keys.cc transaction.cc)\n cxx_link(dfly_transaction uring_fiber_lib dfly_core strings_lib)\n \n add_library(dragonfly_lib  channel_slice.cc command_registry.cc\n@@ -21,7 +21,8 @@ add_library(dragonfly_lib  channel_slice.cc command_registry.cc\n             snapshot.cc script_mgr.cc server_family.cc malloc_stats.cc\n             set_family.cc stream_family.cc string_family.cc\n             zset_family.cc version.cc bitops_family.cc container_utils.cc io_utils.cc\n-            serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc)\n+            serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc\n+            top_keys.cc)\n \n cxx_link(dragonfly_lib dfly_transaction dfly_facade redis_lib strings_lib html_lib http_client_lib\n          absl::random_random TRDP::jsoncons zstd TRDP::lz4)\n@@ -46,6 +47,7 @@ cxx_test(snapshot_test dragonfly_lib LABELS DFLY)\n cxx_test(json_family_test dfly_test_lib LABELS DFLY)\n cxx_test(journal_test dfly_test_lib LABELS DFLY)\n cxx_test(tiered_storage_test dfly_test_lib LABELS DFLY)\n+cxx_test(top_keys_test dfly_test_lib LABELS DFLY)\n \n add_custom_target(check_dfly WORKING_DIRECTORY .. COMMAND ctest -L DFLY)\n add_dependencies(check_dfly dragonfly_test json_family_test list_family_test\ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 332d3fe2b828..3d04f80f1084 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -329,6 +329,7 @@ pair<PrimeIterator, ExpireIterator> DbSlice::FindExt(const Context& cntx, string\n   }\n \n   events_.hits++;\n+  db.top_keys.Touch(key);\n   return res;\n }\n \ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 2d6b7203c5e1..962ac517233c 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -428,6 +428,34 @@ bool EvalValidator(CmdArgList args, ConnectionContext* cntx) {\n   return true;\n }\n \n+void Topkeys(const http::QueryArgs& args, HttpContext* send) {\n+  http::StringResponse resp = http::MakeStringResponse(h2::status::ok);\n+  resp.body() = \"<h1>Detected top keys</h1>\\n<pre>\\n\";\n+\n+  std::atomic_bool is_enabled = false;\n+  if (shard_set) {\n+    vector<string> rows(shard_set->size());\n+\n+    shard_set->RunBriefInParallel([&](EngineShard* shard) {\n+      for (const auto& db : shard->db_slice().databases()) {\n+        if (db->top_keys.IsEnabled()) {\n+          is_enabled = true;\n+          for (const auto& [key, count] : db->top_keys.GetTopKeys()) {\n+            absl::StrAppend(&resp.body(), key, \":\\t\", count, \"\\n\");\n+          }\n+        }\n+      }\n+    });\n+  }\n+\n+  resp.body() += \"</pre>\";\n+\n+  if (!is_enabled) {\n+    resp.body() += \"<i>TopKeys are disabled.</i>\";\n+  }\n+  send->Invoke(std::move(resp));\n+}\n+\n void TxTable(const http::QueryArgs& args, HttpContext* send) {\n   using html::SortedTable;\n \n@@ -1566,6 +1594,7 @@ GlobalState Service::SwitchState(GlobalState from, GlobalState to) {\n void Service::ConfigureHttpHandlers(util::HttpListenerBase* base) {\n   server_family_.ConfigureMetrics(base);\n   base->RegisterCb(\"/txz\", TxTable);\n+  base->RegisterCb(\"/topkeys\", Topkeys);\n }\n \n void Service::OnClose(facade::ConnectionContext* cntx) {\ndiff --git a/src/server/table.cc b/src/server/table.cc\nindex 281a0ebf0412..77825168c019 100644\n--- a/src/server/table.cc\n+++ b/src/server/table.cc\n@@ -4,8 +4,12 @@\n \n #include \"server/table.h\"\n \n+#include \"base/flags.h\"\n #include \"base/logging.h\"\n \n+ABSL_FLAG(bool, enable_top_keys_tracking, false,\n+          \"Enables / disables tracking of hot keys debugging feature\");\n+\n namespace dfly {\n \n #define ADD(x) (x) += o.x\n@@ -31,7 +35,8 @@ DbTableStats& DbTableStats::operator+=(const DbTableStats& o) {\n \n DbTable::DbTable(std::pmr::memory_resource* mr)\n     : prime(kInitSegmentLog, detail::PrimeTablePolicy{}, mr),\n-      expire(0, detail::ExpireTablePolicy{}, mr), mcflag(0, detail::ExpireTablePolicy{}, mr) {\n+      expire(0, detail::ExpireTablePolicy{}, mr), mcflag(0, detail::ExpireTablePolicy{}, mr),\n+      top_keys({.enabled = absl::GetFlag(FLAGS_enable_top_keys_tracking)}) {\n }\n \n DbTable::~DbTable() {\ndiff --git a/src/server/table.h b/src/server/table.h\nindex cc7776d6fdbd..14687e4b16e1 100644\n--- a/src/server/table.h\n+++ b/src/server/table.h\n@@ -13,6 +13,7 @@\n #include \"core/intent_lock.h\"\n #include \"server/conn_context.h\"\n #include \"server/detail/table.h\"\n+#include \"server/top_keys.h\"\n \n namespace dfly {\n \n@@ -72,6 +73,8 @@ struct DbTable : boost::intrusive_ref_counter<DbTable, boost::thread_unsafe_coun\n   ExpireTable::Cursor expire_cursor;\n   PrimeTable::Cursor prime_cursor;\n \n+  TopKeys top_keys;\n+\n   explicit DbTable(std::pmr::memory_resource* mr);\n   ~DbTable();\n \ndiff --git a/src/server/top_keys.cc b/src/server/top_keys.cc\nnew file mode 100644\nindex 000000000000..27141cdd2295\n--- /dev/null\n+++ b/src/server/top_keys.cc\n@@ -0,0 +1,96 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#include \"server/top_keys.h\"\n+\n+#include <xxhash.h>\n+\n+#include \"absl/numeric/bits.h\"\n+#include \"absl/random/distributions.h\"\n+#include \"base/logging.h\"\n+\n+namespace dfly {\n+\n+TopKeys::TopKeys(Options options) : options_(options) {\n+  fingerprints_.resize(options_.buckets * options_.arrays);\n+}\n+\n+void TopKeys::Touch(std::string_view key) {\n+  if (!IsEnabled()) {\n+    return;\n+  }\n+\n+  auto ResetCell = [&](Cell& cell, uint64_t fingerprint) {\n+    cell.fingerprint = fingerprint;\n+    cell.count = 1;\n+    if (cell.count >= options_.min_key_count_to_record) {\n+      cell.key = key;\n+    }\n+  };\n+\n+  const uint64_t fingerprint = XXH3_64bits(key.data(), key.size());\n+  const int shift = absl::bit_width(options_.buckets);\n+\n+  for (uint64_t array = 0; array < options_.arrays; ++array) {\n+    // TODO: if we decide to keep this logic, CHECK that bit_width(buckets) * arrays < 64\n+    const int bucket = (fingerprint >> (shift * array)) % options_.buckets;\n+    Cell& cell = GetCell(array, bucket);\n+    if (cell.count == 0) {\n+      // No fingerprint in cell.\n+      ResetCell(cell, fingerprint);\n+    } else if (cell.fingerprint == fingerprint) {\n+      // Same fingerprint, simply increment count.\n+\n+      // We could make sure that, if !cell.key.empty(), then key == cell.key.empty() here. However,\n+      // what do we do in case they are different?\n+      ++cell.count;\n+\n+      if (cell.count >= options_.min_key_count_to_record && cell.key.empty()) {\n+        cell.key = key;\n+      }\n+    } else {\n+      // Different fingerprint, apply exponential decay.\n+      const double rand = absl::Uniform(bitgen_, 0, 1.0);\n+      if (rand < std::pow(options_.decay_base, -static_cast<double>(cell.count))) {\n+        --cell.count;\n+        if (cell.count == 0) {\n+          ResetCell(cell, fingerprint);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+absl::flat_hash_map<std::string, uint64_t> TopKeys::GetTopKeys() const {\n+  absl::flat_hash_map<std::string, uint64_t> results;\n+\n+  for (uint64_t array = 0; array < options_.arrays; ++array) {\n+    for (uint64_t bucket = 0; bucket < options_.buckets; ++bucket) {\n+      const Cell& cell = GetCell(array, bucket);\n+      if (!cell.key.empty()) {\n+        results[cell.key] = std::max(results[cell.key], cell.count);\n+      }\n+    }\n+  }\n+\n+  return results;\n+}\n+\n+bool TopKeys::IsEnabled() const {\n+  return options_.enabled;\n+}\n+\n+TopKeys::Cell& TopKeys::GetCell(uint64_t array, uint64_t bucket) {\n+  DCHECK(array < options_.arrays);\n+  DCHECK(bucket < options_.buckets);\n+  return fingerprints_[array * options_.buckets + bucket];\n+}\n+\n+const TopKeys::Cell& TopKeys::GetCell(uint64_t array, uint64_t bucket) const {\n+  DCHECK(array < options_.arrays);\n+  DCHECK(bucket < options_.buckets);\n+  return fingerprints_[array * options_.buckets + bucket];\n+}\n+\n+}  // end of namespace dfly\ndiff --git a/src/server/top_keys.h b/src/server/top_keys.h\nnew file mode 100644\nindex 000000000000..5d89f15e9bab\n--- /dev/null\n+++ b/src/server/top_keys.h\n@@ -0,0 +1,73 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#pragma once\n+\n+#include <absl/container/flat_hash_map.h>\n+#include <absl/random/random.h>\n+\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+namespace dfly {\n+\n+// TopKeys is a utility class that helps determine the most frequently used keys.\n+//\n+// Usage:\n+// - Instanciate this class with proper options (see below)\n+// - For every used key k, call Touch(k)\n+// - At some point(s) in time, call GetTopKeys() to get an estimated list of top keys along with\n+//   their approximate count (i.e. how many times Touch() was invoked for them).\n+//\n+// Notes:\n+// - This class implements a slightly modified version of HeavyKeeper, a data structure designed\n+//   for a similar problem domain. The modification made is to store the keys directly within the\n+//   tables, when they meet a certain threshold, instead of using a min-heap.\n+// - This class is statistical in nature. Do *not* expect accurate counts.\n+// - When misconfigured, real top keys may be missing from GetTopKeys(). This can occur when there\n+//   are too few buckets, or when min_key_count_to_record is too high, depending on actual usage.\n+class TopKeys {\n+ public:\n+  struct Options {\n+    // HeavyKeeper options\n+    uint64_t buckets = 1 << 16;\n+    uint64_t arrays = 4;\n+    double decay_base = 1.08;\n+\n+    // What is the minimum times Touch() has to be called for a given key in order for the key to be\n+    // saved. Use lower values when load is low, or higher values when load is high. The cost of a\n+    // low value for high load is frequent string copying and memory allocation.\n+    uint64_t min_key_count_to_record = 100;\n+\n+    // Pass false to disable, making this class no-op.\n+    bool enabled = true;\n+  };\n+\n+  explicit TopKeys(Options options);\n+\n+  void Touch(std::string_view key);\n+  absl::flat_hash_map<std::string, uint64_t> GetTopKeys() const;\n+\n+  bool IsEnabled() const;\n+\n+ private:\n+  // Each cell consists of a key-fingerprint, a count, and potentially the key itself, when it's\n+  // above options_.min_key_count_to_record.\n+  struct Cell {\n+    uint64_t fingerprint = 0;\n+    uint64_t count = 0;\n+    std::string key;\n+  };\n+  Cell& GetCell(uint64_t array, uint64_t bucket);\n+  const Cell& GetCell(uint64_t array, uint64_t bucket) const;\n+\n+  Options options_;\n+  absl::BitGen bitgen_;\n+\n+  // fingerprints_'s size is options_.buckets * options_.arrays. Always access fields via GetCell().\n+  std::vector<Cell> fingerprints_;\n+};\n+\n+}  // end of namespace dfly\n",
  "test_patch": "diff --git a/src/server/top_keys_test.cc b/src/server/top_keys_test.cc\nnew file mode 100644\nindex 000000000000..94969b702fe1\n--- /dev/null\n+++ b/src/server/top_keys_test.cc\n@@ -0,0 +1,148 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#include \"server/top_keys.h\"\n+\n+#include <gmock/gmock.h>\n+\n+#include \"base/gtest.h\"\n+#include \"base/logging.h\"\n+\n+using ::testing::Pair;\n+using ::testing::UnorderedElementsAre;\n+\n+namespace dfly {\n+\n+TEST(TopKeysTest, Basic) {\n+  TopKeys top_keys({.min_key_count_to_record = 1});\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 1)));\n+}\n+\n+TEST(TopKeysTest, MultiTouch) {\n+  TopKeys top_keys({.min_key_count_to_record = 1});\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 1)));\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 2)));\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 3)));\n+}\n+\n+TEST(TopKeysTest, MinKeyCountToRecord) {\n+  TopKeys top_keys({.min_key_count_to_record = 3});\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre());\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre());\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 3)));\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 4)));\n+  top_keys.Touch(\"key1\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 5)));\n+}\n+\n+TEST(TopKeysTest, MultiKeys) {\n+  TopKeys top_keys({.min_key_count_to_record = 1});\n+  top_keys.Touch(\"key1\");\n+  top_keys.Touch(\"key2\");\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 1), Pair(\"key2\", 1)));\n+}\n+\n+TEST(TopKeysTest, BucketCollision) {\n+  TopKeys top_keys({.buckets = 1, .min_key_count_to_record = 1});\n+  for (int i = 0; i < 5; ++i) {\n+    top_keys.Touch(\"key1\");\n+  }\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 5)));\n+\n+  for (int i = 0; i < 100; ++i) {\n+    top_keys.Touch(\"key2\");\n+  }\n+\n+  auto top_keys_table = top_keys.GetTopKeys();\n+  EXPECT_EQ(top_keys_table.size(), 1);\n+  EXPECT_LE(top_keys_table[\"key2\"], 100);\n+  EXPECT_GE(top_keys_table[\"key2\"], 50);\n+\n+  // Touching \"key1\" should *not* replace \"key2\".\n+  top_keys.Touch(\"key1\");\n+  EXPECT_FALSE(top_keys.GetTopKeys().contains(\"key1\"));\n+}\n+\n+TEST(TopKeysTest, BucketCollisionAggressiveDecay) {\n+  TopKeys top_keys({.buckets = 1, .decay_base = 1.0, .min_key_count_to_record = 1});\n+  for (int i = 0; i < 5; ++i) {\n+    top_keys.Touch(\"key1\");\n+  }\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 5)));\n+\n+  for (int i = 0; i < 100; ++i) {\n+    top_keys.Touch(\"key2\");\n+  }\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key2\", 96)));\n+}\n+\n+TEST(TopKeysTest, BucketCollisionHesitantDecay) {\n+  TopKeys top_keys({.buckets = 1, .decay_base = 1000.0, .min_key_count_to_record = 1});\n+  for (int i = 0; i < 5; ++i) {\n+    top_keys.Touch(\"key1\");\n+  }\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 5)));\n+\n+  for (int i = 0; i < 100; ++i) {\n+    top_keys.Touch(\"key2\");\n+  }\n+  // \"key2\" will never replace \"key1\", as the decay practically never happens (1000^-5)\n+  EXPECT_THAT(top_keys.GetTopKeys(), UnorderedElementsAre(Pair(\"key1\", 5)));\n+}\n+\n+TEST(TopKeysTest, SavedByMultipleArrays) {\n+  // This test is not trivial. It tests that having multiple arrays inside TopKeys saves keys in\n+  // case of collision. The way it does it is by inserting an arbitrary key (= \"key\"), and then (at\n+  // runtime) finding another key which *does* collide with that key.\n+  //\n+  // Once we've found such a key, we create another TopKeys instance, but this time with 10 arrays\n+  // which should mean that for some hash value, the keys won't be present in the same bucket.\n+\n+  std::string collision_key;\n+\n+  TopKeys::Options options(\n+      {.buckets = 2, .arrays = 1, .decay_base = 1, .min_key_count_to_record = 1});\n+  {\n+    TopKeys top_keys(options);\n+\n+    // Insert some key\n+    top_keys.Touch(\"key\");\n+    top_keys.Touch(\"key\");\n+\n+    // Find a key with a collision\n+    int i = 0;\n+    while (true) {\n+      collision_key = absl::StrCat(\"key\", i);\n+      top_keys.Touch(collision_key);\n+      if (!top_keys.GetTopKeys().contains(collision_key)) {\n+        break;\n+      }\n+      ++i;\n+    }\n+  }\n+\n+  options.arrays = 10;\n+  {\n+    TopKeys top_keys(options);\n+\n+    // Insert some key\n+    top_keys.Touch(\"key\");\n+    top_keys.Touch(\"key\");\n+\n+    // Insert collision key, expect result to be present\n+    top_keys.Touch(collision_key);\n+    EXPECT_THAT(top_keys.GetTopKeys(),\n+                UnorderedElementsAre(Pair(\"key\", 2), Pair(collision_key, 1)));\n+  }\n+}\n+\n+}  // end of namespace dfly\n",
  "problem_statement": "recognizing hot keys\nMotivation: https://blog.box.com/introducing-memsniff-robust-memcache-traffic-analyzer\r\n\r\nfor large scale deployments, caching teams would like to learn about hot keys in real-time so that they could handle them in a special way.\r\n\r\nCurrently, teams develop sniffers! (see the link) to do so. It's not very elegant way and very CPU intensive. We could integrate it into DF and provide native support for this.\r\n\n",
  "hints_text": "Algorithms that might help:\r\nhttps://www.usenix.org/conference/atc18/presentation/gong\r\nhttps://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2016/CS/CS-2016-01.pdf\r\n\r\nwe should choose the simpler one, not necessarily the most sophisticated one.\r\n\nafter reading these paper I think it's better to start with HeavyKeeper.\r\nWe even do not need to maintain a min-heap data structure because query complexity is not the issue here - we need to focus on fast updates.\nI have read the heavykeeper paper and am implementing a heavykeeper structure that does not use min-heap.\r\n\r\nThe basic idea for dragonfly to introduce hotspot awareness is to set one heavykeeper per proactor and perform sorting to find the hottest few keys when hotspot information is needed.\r\n\r\nI intend to do the following.\r\nstep1. complete and test a heavykeeper structure without min-heap (**work in progress**)\r\nstep2. think about how heavykeeper is used in each proactor of dragonfly?\r\nstep3. what can each proactor do when it senses a hotspot?\r\nstep4. How to aggregate hotspot information from all proactors when dragonfly users need hotspot information?\r\nstep5. do we need to persist hotspot information to provide hotspot history query function? \r\n\r\nFirst I will focus on the implementation and testing of heavykeeper, and continue to dive into dragonfly's code, subsequent questions may need to be discussed by community members.\r\n\r\nThis is not something that can be done quickly, so I think these ideas will appear in many PRs that\n@Super-long please join our Discord server https://discord.gg/HsPjXGVH85 and say hello. I will add you to our #dev channel.\r\n",
  "created_at": "2023-03-16T09:05:15Z",
  "modified_files": [
    "src/server/CMakeLists.txt",
    "src/server/db_slice.cc",
    "src/server/main_service.cc",
    "src/server/table.cc",
    "src/server/table.h",
    "b/src/server/top_keys.cc",
    "b/src/server/top_keys.h"
  ],
  "modified_test_files": [
    "b/src/server/top_keys_test.cc"
  ]
}