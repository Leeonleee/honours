{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4745,
  "instance_id": "dragonflydb__dragonfly-4745",
  "issue_numbers": [
    "4743"
  ],
  "base_commit": "4f70d1bdbc6fe8f126aab88bf209d0c9364ca3fa",
  "patch": "diff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex 79d37f23a752..71767fe5107b 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -408,10 +408,10 @@ OpResult<vector<OptStr>> OpHMGet(const OpArgs& op_args, std::string_view key, Cm\n   if (pv.Encoding() == kEncodingListPack) {\n     uint8_t* lp = (uint8_t*)pv.RObjPtr();\n \n-    absl::flat_hash_map<string_view, unsigned> reverse;\n+    absl::flat_hash_map<string_view, absl::InlinedVector<size_t, 3>> reverse;\n     reverse.reserve(fields.size() + 1);\n     for (size_t i = 0; i < fields.size(); ++i) {\n-      reverse.emplace(ArgS(fields, i), i);  // map fields to their index.\n+      reverse[ArgS(fields, i)].push_back(i);  // map fields to their index.\n     }\n \n     size_t lplen = lpLength(lp);\n@@ -431,8 +431,10 @@ OpResult<vector<OptStr>> OpHMGet(const OpArgs& op_args, std::string_view key, Cm\n \n       auto it = reverse.find(key);\n       if (it != reverse.end()) {\n-        DCHECK_LT(it->second, result.size());\n-        result[it->second].emplace(LpGetView(lp_elem, ibuf));  // populate found items.\n+        for (size_t index : it->second) {\n+          DCHECK_LT(index, result.size());\n+          result[index].emplace(LpGetView(lp_elem, ibuf));  // populate found items.\n+        }\n       }\n \n       lp_elem = lpNext(lp, lp_elem);  // switch to the next key\n",
  "test_patch": "diff --git a/src/server/hset_family_test.cc b/src/server/hset_family_test.cc\nindex 0c8bc031cf2a..8664355c10d7 100644\n--- a/src/server/hset_family_test.cc\n+++ b/src/server/hset_family_test.cc\n@@ -91,6 +91,11 @@ TEST_P(HestFamilyTestProtocolVersioned, Get) {\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"1\", \"3\", ArgType(RespExpr::NIL)));\n \n+  resp = Run({\"hmget\", \"x\", \"a\", \"c\", \"d\", \"d\", \"c\", \"a\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(),\n+              ElementsAre(\"1\", \"3\", ArgType(RespExpr::NIL), ArgType(RespExpr::NIL), \"3\", \"1\"));\n+\n   resp = Run({\"hgetall\", \"x\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"1\", \"b\", \"2\", \"c\", \"3\"));\n",
  "problem_statement": "[BUG] HMGET with none-unique keys\nHi.\n\nDragonfly Version: v1.27.1\n\nThe HMGET command returns a value only for the first unique key.\n\nReproduce:\n\n```\n127.0.0.1:6379> HSET test f1 \"hi\"\n(integer) 1\n127.0.0.1:6379> HMGET test f1 f1 f1\n1) \"hi\"\n2) (nil)\n3) (nil)\n```\n\nExpected behavior:\n\n```\n127.0.0.1:6379> HSET test f1 \"hi\"\n(integer) 1\n127.0.0.1:6379> HMGET test f1 f1 f1\n1) \"hi\"\n2) \"hi\"\n3) \"hi\"\n```\n\nExpects behavior similar to that of Redis and KeyDB\n",
  "hints_text": "Thank you @Gasillo we will fix it in 1.28",
  "created_at": "2025-03-11T07:24:33Z",
  "modified_files": [
    "src/server/hset_family.cc"
  ],
  "modified_test_files": [
    "src/server/hset_family_test.cc"
  ]
}