{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3235,
  "instance_id": "dragonflydb__dragonfly-3235",
  "issue_numbers": [
    "3232"
  ],
  "base_commit": "b34d3ba6da3b4231dbebc3c17749026e7f4f9bf7",
  "patch": "diff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex 374bab951c28..145388fb10ad 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -609,10 +609,16 @@ uint64_t ScanGeneric(uint64_t cursor, const ScanOpts& scan_opts, StringVec* keys\n   DbContext db_cntx{cntx->conn_state.db_index, GetCurrentTimeMs()};\n \n   do {\n-    ess->Await(sid, [&] {\n+    auto cb = [&] {\n       OpArgs op_args{EngineShard::tlocal(), 0, db_cntx};\n       OpScan(op_args, scan_opts, &cursor, keys);\n-    });\n+    };\n+\n+    // Avoid deadlocking, if called from shard queue script\n+    if (EngineShard::tlocal() && EngineShard::tlocal()->shard_id() == sid)\n+      cb();\n+    else\n+      ess->Await(sid, cb);\n \n     if (cursor == 0) {\n       ++sid;\n",
  "test_patch": "diff --git a/src/server/multi_test.cc b/src/server/multi_test.cc\nindex 225ae5523122..02a7c687bbd4 100644\n--- a/src/server/multi_test.cc\n+++ b/src/server/multi_test.cc\n@@ -396,13 +396,13 @@ TEST_F(MultiTest, Eval) {\n   resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"0\"});\n   EXPECT_THAT(resp, \"42\");\n \n-  Run({\"script\", \"flush\"});\n+  Run({\"script\", \"flush\"});  // Reset global flag due to lua_allow_undeclared_auto_correct effect\n \n   resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"1\", \"bar\"});\n   EXPECT_THAT(resp, ErrArg(\"undeclared\"));\n   ASSERT_FALSE(service_->IsLocked(0, \"foo\"));\n \n-  Run({\"script\", \"flush\"});\n+  Run({\"script\", \"flush\"});  // Reset global flag from autocorrect\n \n   resp = Run({\"eval\", \"return redis.call('get', 'foo')\", \"1\", \"foo\"});\n   EXPECT_THAT(resp, \"42\");\n@@ -459,6 +459,11 @@ TEST_F(MultiTest, Eval) {\n                  \"1\", \"foo\"}),\n             \"42\");\n   fb.Join();\n+\n+  // Call multi-shard command scan from single shard mode\n+  resp = Run({\"eval\", \"return redis.call('scan', '0'); \", \"1\", \"key\"});\n+  EXPECT_EQ(resp.GetVec()[0], \"0\");\n+  EXPECT_EQ(resp.GetVec()[1].type, RespExpr::Type::ARRAY);\n }\n #endif\n \n",
  "problem_statement": "Eval command does not returns, transaction getting stuck\nHow to reproduce:\r\n\r\nRun the following commands in redis cli:\r\n\r\n1. `script load \"      local pattern = KEYS[1]\\n      local oldest = tonumber(ARGV[1])\\n      local cursor = ARGV[2]\\n      local count = tonumber(ARGV[3])\\n      local result = redis.call(\\\"SCAN\\\", cursor, \\\"MATCH\\\", pattern, \\\"COUNT\\\", count)\\n      cursor = result[1]\\n      local keys = result[2]\\n      for i, key in ipairs(keys) do\\n        local to_delete = {}\\n        for _, timestamp in ipairs(redis.call('hkeys', key)) do\\n          if tonumber(timestamp) <= oldest then\\n            table.insert(to_delete, timestamp)\\n          end\\n        end\\n        if #to_delete > 0 then\\n          redis.call('hdel', key, unpack(to_delete))\\n        end\\n      end\\n      return cursor\\n\"\r\n`\r\n2.  debug populate 1000\r\n3. evalsha 591f96f821898bddced228c3fe18d0192691bd05 1 key: 1 0 1000\r\n\r\nstep 3 does not return causing transaction getting stuck\n",
  "hints_text": "The problem is with running scan command under script.\r\nscan is not transactional and uses EngineShardSet Await to run the scanop on a shard.\r\n\r\nIf you run dragonfly with the following flags\r\n./dragonfly --alsologtostderr --dbfilename= --proactor_threads=6 --vmodule=generic_family=1\r\nyou can see that the scanop is getting deadlocked when trying to run the scanop on the shard the script was scheduled on (the shard of the key provided for the script)\r\n\r\n\nWe can reproduce the bug also with this simple script\r\n`eval \"return redis.call('scan', '0', 'match', 'key:', 'count', '1000')\" 1 key:`\nShould we just refuse running SCAN in the script (return error) ?\nAnother option is to support patterns that have specific hashslot inside like `{foo}`. In that case if we identify that scan is single sharded we can continue running it in the script under lock_on_hashtag mode \n> Should we just refuse running SCAN in the script (return error) ?\r\n\r\nI assume this is a very common usecase",
  "created_at": "2024-06-28T04:45:18Z",
  "modified_files": [
    "src/server/generic_family.cc"
  ],
  "modified_test_files": [
    "src/server/multi_test.cc"
  ]
}