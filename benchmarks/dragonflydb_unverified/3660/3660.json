{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3660,
  "instance_id": "dragonflydb__dragonfly-3660",
  "issue_numbers": [
    "3646"
  ],
  "base_commit": "c34f2b7eeb3affa9950d1e4d7a1a096f36bf46f5",
  "patch": "diff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex 65e6e8addaad..0fc601b3ddd4 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -252,19 +252,22 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n   AggregateParams params;\n   tie(params.index, params.query) = parser.Next<string_view, string_view>();\n \n-  while (parser.HasNext()) {\n-    // LOAD count field [field ...]\n-    if (parser.Check(\"LOAD\")) {\n-      size_t num_fields = parser.Next<size_t>();\n+  // Parse LOAD count field [field ...]\n+  // LOAD options are at the beginning of the query, so we need to parse them first\n+  while (parser.HasNext() && parser.Check(\"LOAD\")) {\n+    size_t num_fields = parser.Next<size_t>();\n+    if (!params.load_fields.fields) {\n       params.load_fields.fields.emplace();\n-      while (params.load_fields->size() < num_fields) {\n-        string_view field = ParseField(&parser);\n-        string_view alias = parser.Check(\"AS\") ? parser.Next() : field;\n-        params.load_fields->emplace_back(field, alias);\n-      }\n-      continue;\n     }\n \n+    while (num_fields--) {\n+      string_view field = ParseField(&parser);\n+      string_view alias = parser.Check(\"AS\") ? parser.Next() : field;\n+      params.load_fields->emplace_back(field, alias);\n+    }\n+  }\n+\n+  while (parser.HasNext()) {\n     // GROUPBY nargs property [property ...]\n     if (parser.Check(\"GROUPBY\")) {\n       vector<string_view> fields(parser.Next<size_t>());\n@@ -332,6 +335,11 @@ optional<AggregateParams> ParseAggregatorParamsOrReply(CmdArgParser parser,\n       continue;\n     }\n \n+    if (parser.Check(\"LOAD\")) {\n+      cntx->SendError(\"LOAD cannot be applied after projectors or reducers\");\n+      return nullopt;\n+    }\n+\n     cntx->SendError(absl::StrCat(\"Unknown clause: \", parser.Peek()));\n     return nullopt;\n   }\n",
  "test_patch": "diff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex d1279d36f3e5..a3593c054318 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -884,6 +884,26 @@ TEST_F(SearchFamilyTest, AggregateLoadGroupBy) {\n   EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"even\", \"false\"), IsMap(\"even\", \"true\")));\n }\n \n+TEST_F(SearchFamilyTest, AggregateLoad) {\n+  Run({\"hset\", \"key:1\", \"word\", \"item1\", \"foo\", \"10\"});\n+  Run({\"hset\", \"key:2\", \"word\", \"item2\", \"foo\", \"20\"});\n+  Run({\"hset\", \"key:3\", \"word\", \"item1\", \"foo\", \"30\"});\n+\n+  auto resp = Run({\"ft.create\", \"index\", \"ON\", \"HASH\", \"SCHEMA\", \"word\", \"TAG\", \"foo\", \"NUMERIC\"});\n+  EXPECT_EQ(resp, \"OK\");\n+\n+  // ft.aggregate index \"*\" LOAD 1 @word LOAD 1 @foo\n+  resp = Run({\"ft.aggregate\", \"index\", \"*\", \"LOAD\", \"1\", \"@word\", \"LOAD\", \"1\", \"@foo\"});\n+  EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"word\", \"item1\", \"foo\", \"30\"),\n+                                         IsMap(\"word\", \"item2\", \"foo\", \"20\"),\n+                                         IsMap(\"word\", \"item1\", \"foo\", \"10\")));\n+\n+  // ft.aggregate index \"*\" GROUPBY 1 @word REDUCE SUM 1 @foo AS foo_total LOAD 1 foo_total\n+  resp = Run({\"ft.aggregate\", \"index\", \"*\", \"GROUPBY\", \"1\", \"@word\", \"REDUCE\", \"SUM\", \"1\", \"@foo\",\n+              \"AS\", \"foo_total\", \"LOAD\", \"1\", \"foo_total\"});\n+  EXPECT_THAT(resp, ErrArg(\"LOAD cannot be applied after projectors or reducers\"));\n+}\n+\n TEST_F(SearchFamilyTest, Vector) {\n   auto resp = Run({\"ft.create\", \"ann\", \"ON\", \"HASH\", \"SCHEMA\", \"vector\", \"VECTOR\", \"HNSW\", \"8\",\n                    \"TYPE\", \"FLOAT32\", \"DIM\", \"100\", \"distance_metric\", \"cosine\", \"M\", \"64\"});\n",
  "problem_statement": "LOAD option is broken in the FT.AGGREGATE command\n**Describe the bug**\r\nSeveral snippets of the `FT.AGGREGATE` command do not work correct with the `LOAD` option:\r\n\r\nInitialize:\r\n```shell\r\n127.0.0.1:6379> hset key:1 word item1 foo 10\r\n(integer) 2\r\n127.0.0.1:6379> hset key:2 word item2 foo 20\r\n(integer) 2\r\n127.0.0.1:6379> hset key:3 word item1 foo 30\r\n(integer) 2\r\n127.0.0.1:6379> ft.create index on hash schema word TAG foo NUMERIC\r\nOK\r\n```\r\n\r\n1. LOAD should go before all other options, otherwise we should return an error:\r\n```shell\r\n127.0.0.1:6379> ft.aggregate index \"*\" GROUPBY 1 @word REDUCE SUM 1 @foo AS foo_total LOAD 1 foo_total\r\n(error) LOAD cannot be applied after projectors or reducers\r\n```\r\n\r\n2. There may be several LOAD options at the beginning:\r\n```shell\r\n127.0.0.1:6379> ft.aggregate index \"*\" LOAD 1 @word LOAD 1 @foo\r\n1) (integer) 1\r\n2) 1) \"word\"\r\n   2) \"item1\"\r\n   3) \"foo\"\r\n   4) \"30\"\r\n3) 1) \"word\"\r\n   2) \"item2\"\r\n   3) \"foo\"\r\n   4) \"20\"\r\n4) 1) \"word\"\r\n   2) \"item1\"\r\n   3) \"foo\"\r\n   4) \"10\"\r\n```\r\n\r\n3. Redis also supports the following command:\r\n```shell\r\n127.0.0.1:6379> ft.aggregate index \"*\" LOAD 1 @word GROUPBY 1 @word REDUCE SUM 1 @foo AS foo_total\r\n1) (integer) 2\r\n2) 1) \"word\"\r\n   2) \"item1\"\r\n   3) \"foo_total\"\r\n   4) \"40\"\r\n3) 1) \"word\"\r\n   2) \"item2\"\r\n   3) \"foo_total\"\r\n   4) \"20\"\r\n```\r\nIt still calculates the sum for the `@foo` field that has not been uploaded. ~~**But it seems to be a bug that does not match the documentation.**~~. Upd.: See #3659\n",
  "hints_text": "",
  "created_at": "2024-09-05T14:40:43Z",
  "modified_files": [
    "src/server/search/search_family.cc"
  ],
  "modified_test_files": [
    "src/server/search/search_family_test.cc"
  ]
}