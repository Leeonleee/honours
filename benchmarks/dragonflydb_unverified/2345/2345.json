{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2345,
  "instance_id": "dragonflydb__dragonfly-2345",
  "issue_numbers": [
    "2294"
  ],
  "base_commit": "03f69ff6c36bcbacf5f1162f7586d3775c40ba70",
  "patch": "diff --git a/src/server/blocking_controller.cc b/src/server/blocking_controller.cc\nindex b665ad66fcf2..aa97334fee34 100644\n--- a/src/server/blocking_controller.cc\n+++ b/src/server/blocking_controller.cc\n@@ -4,6 +4,8 @@\n \n #include \"server/blocking_controller.h\"\n \n+#include <absl/container/inlined_vector.h>\n+\n #include <boost/smart_ptr/intrusive_ptr.hpp>\n \n extern \"C\" {\n@@ -20,12 +22,13 @@ using namespace std;\n \n struct WatchItem {\n   Transaction* trans;\n+  KeyReadyChecker key_ready_checker;\n \n   Transaction* get() const {\n     return trans;\n   }\n \n-  WatchItem(Transaction* t) : trans(t) {\n+  WatchItem(Transaction* t, KeyReadyChecker krc) : trans(t), key_ready_checker(std::move(krc)) {\n   }\n };\n \n@@ -212,15 +215,7 @@ void BlockingController::NotifyPending() {\n     for (auto key : wt.awakened_keys) {\n       string_view sv_key = static_cast<string_view>(key);\n       DVLOG(1) << \"Processing awakened key \" << sv_key;\n-\n-      // Double verify we still got the item.\n-      auto [it, exp_it] = owner_->db_slice().FindReadOnly(context, sv_key);\n-      // Only LIST, ZSET and STREAM are allowed to block.\n-      if (!IsValid(it) || !(it->second.ObjType() == OBJ_LIST || it->second.ObjType() == OBJ_ZSET ||\n-                            it->second.ObjType() == OBJ_STREAM))\n-        continue;\n-\n-      NotifyWatchQueue(sv_key, &wt.queue_map);\n+      NotifyWatchQueue(sv_key, &wt.queue_map, context);\n     }\n     wt.awakened_keys.clear();\n \n@@ -231,7 +226,7 @@ void BlockingController::NotifyPending() {\n   awakened_indices_.clear();\n }\n \n-void BlockingController::AddWatched(ArgSlice keys, Transaction* trans) {\n+void BlockingController::AddWatched(ArgSlice keys, KeyReadyChecker krc, Transaction* trans) {\n   auto [dbit, added] = watched_dbs_.emplace(trans->GetDbIndex(), nullptr);\n   if (added) {\n     dbit->second.reset(new DbWatchTable);\n@@ -254,7 +249,7 @@ void BlockingController::AddWatched(ArgSlice keys, Transaction* trans) {\n         continue;\n     }\n     DVLOG(2) << \"Emplace \" << trans->DebugId() << \" to watch \" << key;\n-    res->second->items.emplace_back(trans);\n+    res->second->items.emplace_back(trans, krc);\n   }\n }\n \n@@ -275,33 +270,40 @@ void BlockingController::AwakeWatched(DbIndex db_index, string_view db_key) {\n }\n \n // Marks the queue as active and notifies the first transaction in the queue.\n-void BlockingController::NotifyWatchQueue(std::string_view key, WatchQueueMap* wqm) {\n+void BlockingController::NotifyWatchQueue(std::string_view key, WatchQueueMap* wqm,\n+                                          const DbContext& context) {\n   auto w_it = wqm->find(key);\n   CHECK(w_it != wqm->end());\n   DVLOG(1) << \"Notify WQ: [\" << owner_->shard_id() << \"] \" << key;\n   WatchQueue* wq = w_it->second.get();\n-\n   DCHECK_EQ(wq->state, WatchQueue::SUSPENDED);\n-  wq->state = WatchQueue::ACTIVE;\n \n   auto& queue = wq->items;\n   ShardId sid = owner_->shard_id();\n \n-  do {\n-    WatchItem& wi = queue.front();\n+  // In the most cases we shouldn't have skipped elements at all\n+  absl::InlinedVector<dfly::WatchItem, 4> skipped;\n+  while (!queue.empty()) {\n+    auto& wi = queue.front();\n     Transaction* head = wi.get();\n-    DVLOG(2) << \"WQ-Pop \" << head->DebugId() << \" from key \" << key;\n-\n-    if (head->NotifySuspended(owner_->committed_txid(), sid, key)) {\n-      // We deliberately keep the notified transaction in the queue to know which queue\n-      // must handled when this transaction finished.\n-      wq->notify_txid = owner_->committed_txid();\n-      awakened_transactions_.insert(head);\n-      break;\n+    // We check may the transaction be notified otherwise move it to the end of the queue\n+    if (wi.key_ready_checker(owner_, context, head, key)) {\n+      DVLOG(2) << \"WQ-Pop \" << head->DebugId() << \" from key \" << key;\n+      if (head->NotifySuspended(owner_->committed_txid(), sid, key)) {\n+        wq->state = WatchQueue::ACTIVE;\n+        // We deliberately keep the notified transaction in the queue to know which queue\n+        // must handled when this transaction finished.\n+        wq->notify_txid = owner_->committed_txid();\n+        awakened_transactions_.insert(head);\n+        break;\n+      }\n+    } else {\n+      skipped.push_back(std::move(wi));\n     }\n \n     queue.pop_front();\n-  } while (!queue.empty());\n+  }\n+  std::move(skipped.begin(), skipped.end(), std::back_inserter(queue));\n \n   if (wq->items.empty()) {\n     wqm->erase(w_it);\ndiff --git a/src/server/blocking_controller.h b/src/server/blocking_controller.h\nindex fb83fe934d02..48df4854997f 100644\n--- a/src/server/blocking_controller.h\n+++ b/src/server/blocking_controller.h\n@@ -39,7 +39,7 @@ class BlockingController {\n   // TODO: consider moving all watched functions to\n   // EngineShard with separate per db map.\n   //! AddWatched adds a transaction to the blocking queue.\n-  void AddWatched(ArgSlice watch_keys, Transaction* me);\n+  void AddWatched(ArgSlice watch_keys, KeyReadyChecker krc, Transaction* me);\n \n   // Called from operations that create keys like lpush, rename etc.\n   void AwakeWatched(DbIndex db_index, std::string_view db_key);\n@@ -54,7 +54,7 @@ class BlockingController {\n \n   using WatchQueueMap = absl::flat_hash_map<std::string, std::unique_ptr<WatchQueue>>;\n \n-  void NotifyWatchQueue(std::string_view key, WatchQueueMap* wqm);\n+  void NotifyWatchQueue(std::string_view key, WatchQueueMap* wqm, const DbContext& context);\n \n   // void NotifyConvergence(Transaction* tx);\n \ndiff --git a/src/server/common.h b/src/server/common.h\nindex 19644c1d8d84..582cddf8366d 100644\n--- a/src/server/common.h\n+++ b/src/server/common.h\n@@ -359,6 +359,10 @@ inline uint32_t MemberTimeSeconds(uint64_t now_ms) {\n   return (now_ms / 1000) - kMemberExpiryBase;\n }\n \n+// Checks whether the touched key is valid for a blocking transaction watching it\n+using KeyReadyChecker =\n+    std::function<bool(EngineShard*, const DbContext& context, Transaction* tx, std::string_view)>;\n+\n struct MemoryBytesFlag {\n   uint64_t value = 0;\n };\ndiff --git a/src/server/container_utils.cc b/src/server/container_utils.cc\nindex 7c4832e88ce1..90c18a9a26a6 100644\n--- a/src/server/container_utils.cc\n+++ b/src/server/container_utils.cc\n@@ -283,7 +283,11 @@ OpResult<string> RunCbOnFirstNonEmptyBlocking(Transaction* trans, int req_obj_ty\n   auto wcb = [](Transaction* t, EngineShard* shard) { return t->GetShardArgs(shard->shard_id()); };\n \n   *block_flag = true;\n-  auto status = trans->WaitOnWatch(limit_tp, std::move(wcb));\n+  const auto key_checker = [req_obj_type](EngineShard* owner, const DbContext& context,\n+                                          Transaction*, std::string_view key) -> bool {\n+    return owner->db_slice().FindReadOnly(context, key, req_obj_type).ok();\n+  };\n+  auto status = trans->WaitOnWatch(limit_tp, std::move(wcb), key_checker);\n   *block_flag = false;\n \n   if (status != OpStatus::OK)\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 9ada11ecf04e..2c42f26872a7 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -881,8 +881,12 @@ OpResult<string> BPopPusher::RunSingle(Transaction* t, time_point tp) {\n \n   auto wcb = [&](Transaction* t, EngineShard* shard) { return ArgSlice{&this->pop_key_, 1}; };\n \n+  const auto key_checker = [](EngineShard* owner, const DbContext& context, Transaction*,\n+                              std::string_view key) -> bool {\n+    return owner->db_slice().FindReadOnly(context, key, OBJ_LIST).ok();\n+  };\n   // Block\n-  if (auto status = t->WaitOnWatch(tp, std::move(wcb)); status != OpStatus::OK)\n+  if (auto status = t->WaitOnWatch(tp, std::move(wcb), key_checker); status != OpStatus::OK)\n     return status;\n \n   t->Execute(cb_move, true);\n@@ -906,7 +910,12 @@ OpResult<string> BPopPusher::RunPair(Transaction* t, time_point tp) {\n   // This allows us to run Transaction::Execute on watched transactions in both shards.\n   auto wcb = [&](Transaction* t, EngineShard* shard) { return ArgSlice{&this->pop_key_, 1}; };\n \n-  if (auto status = t->WaitOnWatch(tp, std::move(wcb)); status != OpStatus::OK)\n+  const auto key_checker = [](EngineShard* owner, const DbContext& context, Transaction*,\n+                              std::string_view key) -> bool {\n+    return owner->db_slice().FindReadOnly(context, key, OBJ_LIST).ok();\n+  };\n+\n+  if (auto status = t->WaitOnWatch(tp, std::move(wcb), key_checker); status != OpStatus::OK)\n     return status;\n \n   return MoveTwoShards(t, pop_key_, push_key_, popdir_, pushdir_, true);\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 9b6defc9c838..d27f4ef8a154 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -2817,7 +2817,28 @@ void XReadBlock(ReadOpts opts, ConnectionContext* cntx) {\n   auto tp = (opts.timeout) ? chrono::steady_clock::now() + chrono::milliseconds(opts.timeout)\n                            : Transaction::time_point::max();\n \n-  if (auto status = cntx->transaction->WaitOnWatch(tp, std::move(wcb)); status != OpStatus::OK)\n+  const auto key_checker = [&opts](EngineShard* owner, const DbContext& context, Transaction* tx,\n+                                   std::string_view key) -> bool {\n+    auto res_it = owner->db_slice().FindReadOnly(context, key, OBJ_STREAM);\n+    if (!res_it.ok())\n+      return false;\n+\n+    auto sitem = opts.stream_ids.at(key);\n+    if (sitem.id.val.ms != UINT64_MAX && sitem.id.val.seq != UINT64_MAX)\n+      return true;\n+\n+    const CompactObj& cobj = (*res_it)->second;\n+    stream* s = GetReadOnlyStream(cobj);\n+    streamID last_id = s->last_id;\n+    if (s->length) {\n+      streamLastValidID(s, &last_id);\n+    }\n+\n+    return streamCompareID(&last_id, &sitem.group->last_id) > 0;\n+  };\n+\n+  if (auto status = cntx->transaction->WaitOnWatch(tp, std::move(wcb), key_checker);\n+      status != OpStatus::OK)\n     return rb->SendNullArray();\n \n   // Resolve the entry in the woken key. Note this must not use OpRead since\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 5f9b226c01bf..7d62c716ceb6 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1203,13 +1203,14 @@ size_t Transaction::ReverseArgIndex(ShardId shard_id, size_t arg_index) const {\n   return reverse_index_[sd.arg_start + arg_index];\n }\n \n-OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_provider) {\n+OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_provider,\n+                                  KeyReadyChecker krc) {\n   DVLOG(2) << \"WaitOnWatch \" << DebugId();\n   using namespace chrono;\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     auto keys = wkeys_provider(t, shard);\n-    return t->WatchInShard(keys, shard);\n+    return t->WatchInShard(keys, shard, krc);\n   };\n \n   Execute(std::move(cb), true);\n@@ -1257,14 +1258,14 @@ OpStatus Transaction::WaitOnWatch(const time_point& tp, WaitKeysProvider wkeys_p\n }\n \n // Runs only in the shard thread.\n-OpStatus Transaction::WatchInShard(ArgSlice keys, EngineShard* shard) {\n+OpStatus Transaction::WatchInShard(ArgSlice keys, EngineShard* shard, KeyReadyChecker krc) {\n   ShardId idx = SidToId(shard->shard_id());\n \n   auto& sd = shard_data_[idx];\n   CHECK_EQ(0, sd.local_mask & SUSPENDED_Q);\n \n   auto* bc = shard->EnsureBlockingController();\n-  bc->AddWatched(keys, this);\n+  bc->AddWatched(keys, std::move(krc), this);\n \n   sd.local_mask |= SUSPENDED_Q;\n   sd.local_mask &= ~OUT_OF_ORDER;\ndiff --git a/src/server/transaction.h b/src/server/transaction.h\nindex 479b56dfaf39..eb9c6b2a42e1 100644\n--- a/src/server/transaction.h\n+++ b/src/server/transaction.h\n@@ -186,7 +186,7 @@ class Transaction {\n   // or b) tp is reached. If tp is time_point::max() then waits indefinitely.\n   // Expects that the transaction had been scheduled before, and uses Execute(.., true) to register.\n   // Returns false if timeout occurred, true if was notified by one of the keys.\n-  facade::OpStatus WaitOnWatch(const time_point& tp, WaitKeysProvider cb);\n+  facade::OpStatus WaitOnWatch(const time_point& tp, WaitKeysProvider cb, KeyReadyChecker krc);\n \n   // Returns true if transaction is awaked, false if it's timed-out and can be removed from the\n   // blocking queue.\n@@ -456,7 +456,7 @@ class Transaction {\n   void ExecuteAsync();\n \n   // Adds itself to watched queue in the shard. Must run in that shard thread.\n-  OpStatus WatchInShard(ArgSlice keys, EngineShard* shard);\n+  OpStatus WatchInShard(ArgSlice keys, EngineShard* shard, KeyReadyChecker krc);\n \n   // Expire blocking transaction, unlock keys and unregister it from the blocking controller\n   void ExpireBlocking(WaitKeysProvider wcb);\n",
  "test_patch": "diff --git a/src/server/blocking_controller_test.cc b/src/server/blocking_controller_test.cc\nindex 18df73ef2fbc..01f0ed8c8b1f 100644\n--- a/src/server/blocking_controller_test.cc\n+++ b/src/server/blocking_controller_test.cc\n@@ -75,7 +75,8 @@ TEST_F(BlockingControllerTest, Basic) {\n     EngineShard* shard = EngineShard::tlocal();\n     BlockingController bc(shard);\n     auto keys = trans_->GetShardArgs(shard->shard_id());\n-    bc.AddWatched(keys, trans_.get());\n+    bc.AddWatched(\n+        keys, [](auto...) { return true; }, trans_.get());\n     EXPECT_EQ(1, bc.NumWatched(0));\n \n     bc.FinalizeWatched(keys, trans_.get());\n@@ -89,7 +90,7 @@ TEST_F(BlockingControllerTest, Timeout) {\n   trans_->Schedule();\n   auto cb = [&](Transaction* t, EngineShard* shard) { return trans_->GetShardArgs(0); };\n \n-  facade::OpStatus status = trans_->WaitOnWatch(tp, cb);\n+  facade::OpStatus status = trans_->WaitOnWatch(tp, cb, [](auto...) { return true; });\n \n   EXPECT_EQ(status, facade::OpStatus::TIMED_OUT);\n   unsigned num_watched = shard_set->Await(\ndiff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex bd27ca3d907c..f154839b4db4 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -342,26 +342,18 @@ TEST_F(StreamFamilyTest, XReadGroupBlock) {\n   ThisFiber::SleepFor(50us);\n   pp_->at(1)->Await([&] { return Run(\"xadd\", {\"xadd\", \"bar\", \"1-*\", \"k5\", \"v5\"}); });\n   // The second one should be unblocked\n+  ThisFiber::SleepFor(50us);\n \n   fb0.Join();\n   fb1.Join();\n-  // temporary incorrect results\n-  if (resp0.GetVec()[1].GetVec().size() == 0) {\n-    EXPECT_THAT(resp0.GetVec(), ElementsAre(\"foo\", ArrLen(0)));\n-    EXPECT_THAT(resp1.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n-  } else {\n+\n+  if (resp0.GetVec()[0].GetString() == \"foo\") {\n     EXPECT_THAT(resp0.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n-    EXPECT_THAT(resp1.GetVec(), ElementsAre(\"foo\", ArrLen(0)));\n+    EXPECT_THAT(resp1.GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n+  } else {\n+    EXPECT_THAT(resp1.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n+    EXPECT_THAT(resp0.GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n   }\n-\n-  // correct results\n-  // if (resp0.GetVec()[0].GetString() == \"foo\") {\n-  //   EXPECT_THAT(resp0.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n-  //   EXPECT_THAT(resp1.GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n-  // } else {\n-  //   EXPECT_THAT(resp1.GetVec(), ElementsAre(\"foo\", ArrLen(1)));\n-  //   EXPECT_THAT(resp0.GetVec(), ElementsAre(\"bar\", ArrLen(1)));\n-  // }\n }\n \n TEST_F(StreamFamilyTest, XReadInvalidArgs) {\ndiff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 1e7571057a5a..40bce478c250 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -677,6 +677,26 @@ TEST_F(ZSetFamilyTest, BlockingIsReleased) {\n   }\n }\n \n+TEST_F(ZSetFamilyTest, BlockingWithIncorrectType) {\n+  RespExpr resp0;\n+  RespExpr resp1;\n+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+    resp0 = Run({\"BLPOP\", \"list1\", \"0\"});\n+  });\n+  auto fb1 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&] {\n+    resp1 = Run({\"BZPOPMIN\", \"list1\", \"0\"});\n+  });\n+\n+  ThisFiber::SleepFor(50us);\n+  pp_->at(2)->Await([&] { return Run({\"ZADD\", \"list1\", \"1\", \"a\"}); });\n+  pp_->at(2)->Await([&] { return Run({\"LPUSH\", \"list1\", \"0\"}); });\n+  fb0.Join();\n+  fb1.Join();\n+\n+  EXPECT_THAT(resp1.GetVec(), ElementsAre(\"list1\", \"a\", \"1\"));\n+  EXPECT_THAT(resp0.GetVec(), ElementsAre(\"list1\", \"0\"));\n+}\n+\n TEST_F(ZSetFamilyTest, BlockingTimeout) {\n   RespExpr resp0;\n \n",
  "problem_statement": "Redis STREAM consumer group have duplicates\n**Describe the bug**\r\nRedis STREAM Consumer groups have duplicates\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Start `dragonflydb` with docker\r\n2. Run 3 separate session of docker exec, `docker exec -ti <container> redis-cli -a <password>`\r\n3. In session 1: `XGROUP CREATE pokenews pokenews-group 0 MKSTREAM`\r\n4. In session 2: `XREADGROUP GROUP pokenews-group ash COUNT 1 BLOCK 0 STREAMS pokenews >`\r\n5. In session 3: `XREADGROUP GROUP pokenews-group ash COUNT 1 BLOCK 0 STREAMS pokenews >`\r\n6. In session 1: `XADD pokenews * pokemon entei`\r\n\r\nboth session 2 and session 3 receives the message.\r\n\r\n\r\n**Expected behavior**\r\nOnly session 2 OR session 3 should receive the message, both of them are in the same consumer group\r\n\r\n**Environment (please complete the following information):**\r\n- Host OS: MacOS `13.4.1`\r\n - OS: ubuntu docker image\r\n - Containerized?: Docker, `ghcr.io/dragonflydb/dragonfly:v1.13.0-ubuntu`\r\n - Dragonfly Version: `1.13.0`\r\n\r\n\r\n**Additional context**\r\nNone\r\n\n",
  "hints_text": "@kirinnee thx for reporting the bug, I've already reproduced it and will fix it soon.",
  "created_at": "2023-12-27T14:07:18Z",
  "modified_files": [
    "src/server/blocking_controller.cc",
    "src/server/blocking_controller.h",
    "src/server/common.h",
    "src/server/container_utils.cc",
    "src/server/list_family.cc",
    "src/server/stream_family.cc",
    "src/server/transaction.cc",
    "src/server/transaction.h"
  ],
  "modified_test_files": [
    "src/server/blocking_controller_test.cc",
    "src/server/stream_family_test.cc",
    "src/server/zset_family_test.cc"
  ]
}