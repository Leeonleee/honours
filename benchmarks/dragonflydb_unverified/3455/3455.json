{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3455,
  "instance_id": "dragonflydb__dragonfly-3455",
  "issue_numbers": [
    "3449"
  ],
  "base_commit": "e482eefcbb1c8637cf1c8f3126528cad218738ef",
  "patch": "diff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex 66dd7c50250e..0b4e24736e7a 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -593,27 +593,38 @@ void RedisReplyBuilder::SendStringArrInternal(\n   serialize_len(type_char[0], header_len);\n   unsigned vec_indx = 0;\n   string_view src;\n+\n+#define FLUSH_IOVEC()           \\\n+  do {                          \\\n+    Send(vec.data(), vec_indx); \\\n+    if (ec_)                    \\\n+      return;                   \\\n+    vec_indx = 0;               \\\n+    next = meta.data();         \\\n+  } while (false)\n+\n   for (unsigned i = 0; i < size; ++i) {\n+    DCHECK_LT(vec_indx, vec_cap);\n+\n     src = producer(i);\n     serialize_len('$', src.size());\n \n     // copy data either by referencing via an iovec or copying inline into meta buf.\n     constexpr size_t kSSOLen = 32;\n     if (src.size() > kSSOLen) {\n-      if (vec_indx + 1 >= vec_cap) {\n-        Send(vec.data(), vec_indx);\n-        if (ec_)\n-          return;\n-        vec_indx = 0;\n-        next = meta.data();\n-      }\n-\n       // reference metadata blob before referencing another vector.\n       DCHECK_GT(next - start, 0);\n       vec[vec_indx++] = IoVec(string_view{start, size_t(next - start)});\n-      start = next;\n+      if (vec_indx >= vec_cap) {\n+        FLUSH_IOVEC();\n+      }\n+\n       DCHECK_LT(vec_indx, vec.size());\n       vec[vec_indx++] = IoVec(src);\n+      if (vec_indx >= vec_cap) {\n+        FLUSH_IOVEC();\n+      }\n+      start = next;\n     } else if (src.size() > 0) {\n       // NOTE!: this is not just optimization. producer may returns a string_piece that will\n       // be overriden for the next call, so we must do this for correctness.\n@@ -621,19 +632,15 @@ void RedisReplyBuilder::SendStringArrInternal(\n       next += src.size();\n     }\n \n-    constexpr ptrdiff_t kMargin = kSSOLen + 3 /*$\\r\\n*/ + 2 /*length*/ + 2 /* \\r\\n*/;  // metadata\n+    // how much buffer we need to perform the next iteration.\n+    constexpr ptrdiff_t kMargin = kSSOLen + 3 /* $\\r\\n */ + 2 /*length*/ + 2 /* \\r\\n */;\n \n     // Keep at least kMargin bytes for a small string as well as its length.\n-    if (vec_indx >= vec.size() || ((meta.end() - next) <= kMargin)) {\n+    if (kMargin >= meta.end() - next) {\n       // Flush the iovec array.\n-      DVLOG(2) << \"i=\" << i << \"meta size=\" << next - meta.data();\n-      Send(vec.data(), vec_indx);\n-      if (ec_)\n-        return;\n-\n-      vec_indx = 0;\n-      start = meta.data();\n-      next = start;\n+      vec[vec_indx++] = IoVec(string_view{start, size_t(next - start)});\n+      FLUSH_IOVEC();\n+      start = next;\n     }\n     *next++ = '\\r';\n     *next++ = '\\n';\n",
  "test_patch": "diff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc\nindex a7aea79f5dd0..498632afc455 100644\n--- a/src/facade/reply_builder_test.cc\n+++ b/src/facade/reply_builder_test.cc\n@@ -85,7 +85,7 @@ class RedisReplyBuilderTest : public testing::Test {\n     }\n \n     bool IsError() const {\n-      return args.size() == 1 && args[0].type == RespExpr::ERROR;\n+      return result != RedisParser::OK || (args.size() == 1 && args[0].type == RespExpr::ERROR);\n     }\n \n     bool IsOk() const {\n@@ -951,6 +951,18 @@ TEST_F(RedisReplyBuilderTest, VerbatimString) {\n   ASSERT_EQ(TakePayload(), \"$16\\r\\nA simple string!\\r\\n\") << \"Resp3 VerbatimString TXT failed.\";\n }\n \n+TEST_F(RedisReplyBuilderTest, Issue3449) {\n+  vector<string> records;\n+  for (unsigned i = 0; i < 10'000; ++i) {\n+    records.push_back(absl::StrCat(i));\n+  }\n+  builder_->SendStringArr(records);\n+  ASSERT_TRUE(NoErrors());\n+  ParsingResults parse_result = Parse();\n+  ASSERT_FALSE(parse_result.IsError());\n+  EXPECT_EQ(10000, parse_result.args.size());\n+}\n+\n static void BM_FormatDouble(benchmark::State& state) {\n   vector<double> values;\n   char buf[64];\n",
  "problem_statement": "Regression: long replies contain invalid characters\nHow to reproduce:\r\n\r\n```python\r\n@pytest.mark.asyncio\r\nasync def test_large_replies(df_factory):\r\n    master = df_factory.create(proactor_threads=1)\r\n    df_factory.start_all([master])\r\n    c_master = master.client()\r\n\r\n    l = [i for i in range(0, 10_000)]\r\n    await c_master.lpush(\"list\", *l)\r\n    assert l == await c_master.lrange(\"list\", 0, -1)\r\n\r\n    await c_master.close()\r\n```\r\n\r\nError:\r\n\r\n```\r\n$ redis-cli lrange _counter1 0 -1\r\nError: Protocol error, got \"\\r\" as reply type byte\r\n```\n",
  "hints_text": "```py\r\n@pytest.mark.asyncio\r\nasync def test_large_replies(df_factory):\r\n    master = df_factory.create(proactor_threads=1)\r\n    df_factory.start_all([master])\r\n    c_master = master.client()\r\n\r\n    l = [str(i) for i in range(0, 10_000)]\r\n    await c_master.rpush(\"list\", *l)\r\n    assert l == await c_master.lrange(\"list\", 0, -1)\r\n\r\n    await c_master.close()\r\n```",
  "created_at": "2024-08-06T06:32:08Z",
  "modified_files": [
    "src/facade/reply_builder.cc"
  ],
  "modified_test_files": [
    "src/facade/reply_builder_test.cc"
  ]
}