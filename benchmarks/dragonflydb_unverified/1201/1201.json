{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1201,
  "instance_id": "dragonflydb__dragonfly-1201",
  "issue_numbers": [
    "1163"
  ],
  "base_commit": "964eeee6f0f40ba2cbdbb9c9745148ada0a5e848",
  "patch": "diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nindex b1599f8566ba..f293f1855436 100644\n--- a/.pre-commit-config.yaml\n+++ b/.pre-commit-config.yaml\n@@ -1,6 +1,9 @@\n default_stages: [commit]\n-exclude: 'src\\/redis\\/.*'\n-exclude: 'contrib\\/charts\\/dragonfly\\/ci\\/.*'\n+exclude: |\n+    (?x)(\n+      src/redis/.* |\n+      contrib/charts/dragonfly/ci/.*\n+    )\n repos:\n   - repo: local\n     hooks:\ndiff --git a/src/redis/stream.h b/src/redis/stream.h\nindex 745f3ab65c3e..4ca981e1c56b 100644\n--- a/src/redis/stream.h\n+++ b/src/redis/stream.h\n@@ -105,6 +105,26 @@ typedef struct streamPropInfo {\n     robj *groupname;\n } streamPropInfo;\n \n+typedef struct {\n+  /* XADD options */\n+  streamID id;     /* User-provided ID, for XADD only. */\n+  int id_given;    /* Was an ID different than \"*\" specified? for XADD only. */\n+  int seq_given;   /* Was an ID different than \"ms-*\" specified? for XADD only. */\n+  int no_mkstream; /* if set to 1 do not create new stream */\n+\n+  /* XADD + XTRIM common options */\n+  int trim_strategy;         /* TRIM_STRATEGY_* */\n+  int trim_strategy_arg_idx; /* Index of the count in MAXLEN/MINID, for rewriting. */\n+  int approx_trim;           /* If 1 only delete whole radix tree nodes, so\n+                              * the trim argument is not applied verbatim. */\n+  long long limit;           /* Maximum amount of entries to trim. If 0, no limitation\n+                              * on the amount of trimming work is enforced. */\n+  /* TRIM_STRATEGY_MAXLEN options */\n+  long long maxlen; /* After trimming, leave stream at this length . */\n+  /* TRIM_STRATEGY_MINID options */\n+  streamID minid; /* Trim by ID (No stream entries with ID < 'minid' will remain) */\n+} streamAddTrimArgs;\n+\n /* Prototypes of exported APIs. */\n // struct client;\n \n@@ -119,6 +139,10 @@ typedef struct streamPropInfo {\n \n #define SCG_INVALID_ENTRIES_READ -1\n \n+#define TRIM_STRATEGY_NONE 0\n+#define TRIM_STRATEGY_MAXLEN 1\n+#define TRIM_STRATEGY_MINID 2\n+\n stream *streamNew(void);\n void freeStream(stream *s);\n unsigned long streamLength(const robj *subject);\n@@ -147,6 +171,7 @@ int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_\n int streamDeleteItem(stream *s, streamID *id);\n void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id);\n long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id);\n+int64_t streamTrim(stream *s, streamAddTrimArgs *args);\n int64_t streamTrimByLength(stream *s, long long maxlen, int approx);\n int64_t streamTrimByID(stream *s, streamID minid, int approx);\n void streamFreeCG(streamCG *cg);\ndiff --git a/src/redis/t_stream.c b/src/redis/t_stream.c\nindex 9ca2577af741..464817769e9d 100644\n--- a/src/redis/t_stream.c\n+++ b/src/redis/t_stream.c\n@@ -673,30 +673,6 @@ int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_\n     return C_OK;\n }\n \n-typedef struct {\n-    /* XADD options */\n-    streamID id; /* User-provided ID, for XADD only. */\n-    int id_given; /* Was an ID different than \"*\" specified? for XADD only. */\n-    int seq_given; /* Was an ID different than \"ms-*\" specified? for XADD only. */\n-    int no_mkstream; /* if set to 1 do not create new stream */\n-\n-    /* XADD + XTRIM common options */\n-    int trim_strategy; /* TRIM_STRATEGY_* */\n-    int trim_strategy_arg_idx; /* Index of the count in MAXLEN/MINID, for rewriting. */\n-    int approx_trim; /* If 1 only delete whole radix tree nodes, so\n-                      * the trim argument is not applied verbatim. */\n-    long long limit; /* Maximum amount of entries to trim. If 0, no limitation\n-                      * on the amount of trimming work is enforced. */\n-    /* TRIM_STRATEGY_MAXLEN options */\n-    long long maxlen; /* After trimming, leave stream at this length . */\n-    /* TRIM_STRATEGY_MINID options */\n-    streamID minid; /* Trim by ID (No stream entries with ID < 'minid' will remain) */\n-} streamAddTrimArgs;\n-\n-#define TRIM_STRATEGY_NONE 0\n-#define TRIM_STRATEGY_MAXLEN 1\n-#define TRIM_STRATEGY_MINID 2\n-\n /* Trim the stream 's' according to args->trim_strategy, and return the\n  * number of elements removed from the stream. The 'approx' option, if non-zero,\n  * specifies that the trimming must be performed in a approximated way in\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 62a896064aba..3227f05592db 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -43,10 +43,20 @@ struct RangeId {\n   bool exclude = false;\n };\n \n+enum class TrimStrategy {\n+  kAddOptsTrimNone = TRIM_STRATEGY_NONE,\n+  kAddOptsTrimMaxLen = TRIM_STRATEGY_MAXLEN,\n+  kAddOptsTrimMinId = TRIM_STRATEGY_MINID,\n+};\n+\n struct AddOpts {\n   ParsedStreamId parsed_id;\n-  uint32_t max_limit = kuint32max;\n-  bool max_limit_approx = false;\n+  ParsedStreamId minid;\n+  uint32_t max_len = kuint32max;\n+  uint32_t limit = 0;\n+  TrimStrategy trim_strategy = TrimStrategy::kAddOptsTrimNone;\n+  bool trim_approx = false;\n+  bool no_mkstream = false;\n };\n \n struct GroupInfo {\n@@ -471,10 +481,19 @@ OpResult<streamID> OpAdd(const OpArgs& op_args, string_view key, const AddOpts&\n   auto& db_slice = op_args.shard->db_slice();\n   pair<PrimeIterator, bool> add_res;\n \n-  try {\n-    add_res = db_slice.AddOrFind(op_args.db_cntx, key);\n-  } catch (bad_alloc&) {\n-    return OpStatus::OUT_OF_MEMORY;\n+  if (opts.no_mkstream) {\n+    auto res_it = db_slice.Find(op_args.db_cntx, key, OBJ_STREAM);\n+    if (!res_it) {\n+      return res_it.status();\n+    }\n+    add_res.first = res_it.value();\n+    add_res.second = false;\n+  } else {\n+    try {\n+      add_res = db_slice.AddOrFind(op_args.db_cntx, key);\n+    } catch (bad_alloc&) {\n+      return OpStatus::OUT_OF_MEMORY;\n+    }\n   }\n \n   robj* stream_obj = nullptr;\n@@ -508,10 +527,26 @@ OpResult<streamID> OpAdd(const OpArgs& op_args, string_view key, const AddOpts&\n     return OpStatus::OUT_OF_MEMORY;\n   }\n \n-  if (opts.max_limit < kuint32max) {\n-    /* Notify xtrim event if needed. */\n-    streamTrimByLength(stream_inst, opts.max_limit, opts.max_limit_approx);\n-    // TODO: when replicating, we should propagate it as exact limit in case of trimming.\n+  if (!opts.limit) {\n+    if (opts.trim_strategy == TrimStrategy::kAddOptsTrimMaxLen) {\n+      /* Notify xtrim event if needed. */\n+      streamTrimByLength(stream_inst, opts.max_len, opts.trim_approx);\n+      // TODO: when replicating, we should propagate it as exact limit in case of trimming.\n+    } else if (opts.trim_strategy == TrimStrategy::kAddOptsTrimMinId) {\n+      streamTrimByID(stream_inst, opts.minid.val, opts.trim_approx);\n+    }\n+  } else {\n+    streamAddTrimArgs add_args = {\n+        .trim_strategy = static_cast<int>(opts.trim_strategy),\n+        .approx_trim = opts.trim_approx,\n+        .limit = opts.limit,\n+    };\n+    if (opts.trim_strategy == TrimStrategy::kAddOptsTrimMaxLen) {\n+      add_args.maxlen = opts.max_len;\n+    } else if (opts.trim_strategy == TrimStrategy::kAddOptsTrimMinId) {\n+      add_args.minid = opts.minid.val;\n+    }\n+    streamTrim(stream_inst, &add_args);\n   }\n   return result_id;\n }\n@@ -927,17 +962,38 @@ void StreamFamily::XAdd(CmdArgList args, ConnectionContext* cntx) {\n   for (; id_indx < args.size(); ++id_indx) {\n     ToUpper(&args[id_indx]);\n     string_view arg = ArgS(args, id_indx);\n-    if (arg == \"MAXLEN\") {\n+    if (arg == \"NOMKSTREAM\") {\n+      add_opts.no_mkstream = true;\n+    } else if (arg == \"MAXLEN\" || arg == \"MINID\") {\n+      if (arg == \"MAXLEN\") {\n+        add_opts.trim_strategy = TrimStrategy::kAddOptsTrimMaxLen;\n+      } else {\n+        add_opts.trim_strategy = TrimStrategy::kAddOptsTrimMinId;\n+      }\n       if (id_indx + 2 >= args.size()) {\n         return (*cntx)->SendError(kSyntaxErr);\n       }\n       ++id_indx;\n       if (ArgS(args, id_indx) == \"~\") {\n-        add_opts.max_limit_approx = true;\n+        add_opts.trim_approx = true;\n         ++id_indx;\n       }\n       arg = ArgS(args, id_indx);\n-      if (!absl::SimpleAtoi(arg, &add_opts.max_limit)) {\n+      if (add_opts.trim_strategy == TrimStrategy::kAddOptsTrimMaxLen &&\n+          !absl::SimpleAtoi(arg, &add_opts.max_len)) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+      if (add_opts.trim_strategy == TrimStrategy::kAddOptsTrimMinId &&\n+          !ParseID(arg, false, 0, &add_opts.minid)) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+\n+    } else if (arg == \"LIMIT\" && add_opts.trim_strategy != TrimStrategy::kAddOptsTrimNone) {\n+      if (id_indx + 2 >= args.size() || !add_opts.trim_approx) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+      ++id_indx;\n+      if (!absl::SimpleAtoi(ArgS(args, id_indx), &add_opts.limit)) {\n         return (*cntx)->SendError(kSyntaxErr);\n       }\n     } else {\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex b43da436614b..1b26cc37c6aa 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -39,6 +39,12 @@ TEST_F(StreamFamilyTest, Add) {\n \n   resp = Run({\"xadd\", \"key\", \"badid\", \"f1\", \"val1\"});\n   EXPECT_THAT(resp, ErrArg(\"Invalid stream ID\"));\n+\n+  resp = Run({\"xadd\", \"key\", \"nomkstream\", \"*\", \"field2\", \"value2\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::STRING));\n+\n+  resp = Run({\"xadd\", \"noexist\", \"nomkstream\", \"*\", \"field\", \"value\"});\n+  EXPECT_THAT(resp, ErrArg(\"no such key\"));\n }\n \n TEST_F(StreamFamilyTest, AddExtended) {\n@@ -62,6 +68,24 @@ TEST_F(StreamFamilyTest, AddExtended) {\n \n   auto resp3 = Run({\"xadd\", \"key\", id2, \"f1\", \"val1\"});\n   EXPECT_THAT(resp3, ErrArg(\"equal or smaller than\"));\n+\n+  Run({\"xadd\", \"key2\", \"5-0\", \"field\", \"val\"});\n+  Run({\"xadd\", \"key2\", \"6-0\", \"field1\", \"val1\"});\n+  Run({\"xadd\", \"key2\", \"7-0\", \"field2\", \"val2\"});\n+  auto resp = Run({\"xadd\", \"key2\", \"minid\", \"6\", \"*\", \"field3\", \"val3\"});\n+  EXPECT_THAT(Run({\"xlen\", \"key2\"}), IntArg(3));\n+  EXPECT_THAT(Run({\"xrange\", \"key2\", \"5-0\", \"5-0\"}), ArrLen(0));\n+\n+  for (int i = 0; i < 700; i++) {\n+    Run({\"xadd\", \"key3\", \"*\", \"field\", \"val\"});\n+  }\n+  resp = Run({\"xadd\", \"key3\", \"maxlen\", \"~\", \"500\", \"*\", \"field\", \"val\"});\n+  EXPECT_THAT(Run({\"xlen\", \"key3\"}), IntArg(501));\n+  for (int i = 0; i < 700; i++) {\n+    Run({\"xadd\", \"key4\", \"*\", \"field\", \"val\"});\n+  }\n+  resp = Run({\"xadd\", \"key4\", \"maxlen\", \"~\", \"500\", \"limit\", \"100\", \"*\", \"field\", \"val\"});\n+  EXPECT_THAT(Run({\"xlen\", \"key4\"}), IntArg(601));\n }\n \n TEST_F(StreamFamilyTest, Range) {\n",
  "problem_statement": "XADD missing NOMKSTREAM and MINID options\nAlso LIMIT option is missing\n",
  "hints_text": "Working on the issue. @romange Could you assign it to me?\nSure, thanks!\nHey @romange, I have implemented `NOMKSTREAM` and `MINID` for XADD. But I find that the redis \"[stream.h](https://github.com/dragonflydb/dragonfly/blob/main/src/redis/stream.h)\" library doesn't provide any function API that excepts \"limit\" value to limit the trimming of streams. Functions like [`streamTrimByID`](https://github.com/dragonflydb/dragonfly/blob/c3dc05a5719d1b755160d0df1a109978daf191ec/src/redis/t_stream.c#L896) and [`streamTrimByLength`](https://github.com/dragonflydb/dragonfly/blob/c3dc05a5719d1b755160d0df1a109978daf191ec/src/redis/t_stream.c#L885) sets the limit to a default value (which is `100 * server.stream_node_max_entries`).\r\n\r\nThe only possible way I can think is to add the declaration of [`streamTrim`](https://github.com/dragonflydb/dragonfly/blob/c3dc05a5719d1b755160d0df1a109978daf191ec/src/redis/t_stream.c#L723) function and \"streamAddTrimArgs\" struct to redis \"stream.h\" library so that I can use that function.\r\n\r\nWhat is your thought on it? Is it possible to modify the \"stream.h\" library (i.e. according to redis license)?\nYes, of course you can. In fact you can see our changes under src/redis. ",
  "created_at": "2023-05-10T10:54:33Z",
  "modified_files": [
    ".pre-commit-config.yaml",
    "src/redis/stream.h",
    "src/redis/t_stream.c",
    "src/server/stream_family.cc"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}