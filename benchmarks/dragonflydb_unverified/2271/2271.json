{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2271,
  "instance_id": "dragonflydb__dragonfly-2271",
  "issue_numbers": [
    "2265"
  ],
  "base_commit": "f89b65ca8711e8496806d03be0232dd072aa68c2",
  "patch": "diff --git a/patches/jsoncons-v0.171.0.patch b/patches/jsoncons-v0.171.0.patch\ndeleted file mode 100644\nindex ac7c38243e5c..000000000000\n--- a/patches/jsoncons-v0.171.0.patch\n+++ /dev/null\n@@ -1,110 +0,0 @@\n-diff --git a/include/jsoncons/json_encoder.hpp b/include/jsoncons/json_encoder.hpp\n-index 6a1daba63..d20673171 100644\n---- a/include/jsoncons/json_encoder.hpp\n-+++ b/include/jsoncons/json_encoder.hpp\n-@@ -355,6 +355,7 @@ namespace detail {\n-                     colon_str_.push_back(':');\n-                     break;\n-             }\n-+            colon_str_.append(options.after_key_chars());\n-             switch (options.spaces_around_comma())\n-             {\n-                 case spaces_option::space_after:\n-@@ -1021,9 +1022,9 @@ namespace detail {\n-             sink_.append(options_.new_line_chars().data(),options_.new_line_chars().length());\n-             for (int i = 0; i < indent_amount_; ++i)\n-             {\n--                sink_.push_back(' ');\n-+                sink_.append(options_.indent_chars().data(), options_.indent_chars().length());\n-             }\n--            column_ = indent_amount_;\n-+            column_ = indent_amount_ * options_.new_line_chars().length();\n-         }\n- \n-         void new_line(std::size_t len)\n-@@ -1031,7 +1032,7 @@ namespace detail {\n-             sink_.append(options_.new_line_chars().data(),options_.new_line_chars().length());\n-             for (std::size_t i = 0; i < len; ++i)\n-             {\n--                sink_.push_back(' ');\n-+                sink_.append(options_.indent_chars().data(), options_.indent_chars().length());\n-             }\n-             column_ = len;\n-         }\n-diff --git a/include/jsoncons/json_options.hpp b/include/jsoncons/json_options.hpp\n-index 58dcf3ba3..74d5ab217 100644\n---- a/include/jsoncons/json_options.hpp\n-+++ b/include/jsoncons/json_options.hpp\n-@@ -425,6 +425,8 @@ private:\n-     uint8_t indent_size_;\n-     std::size_t line_length_limit_;\n-     string_type new_line_chars_;\n-+    string_type after_key_chars_;\n-+    string_type indent_chars_;\n- public:\n-     basic_json_encode_options()\n-         : escape_all_non_ascii_(false),\n-@@ -445,6 +447,7 @@ public:\n-           line_length_limit_(line_length_limit_default)\n-     {\n-         new_line_chars_.push_back('\\n');\n-+        indent_chars_.push_back('\\t');\n-     }\n- \n-     basic_json_encode_options(const basic_json_encode_options&) = default;\n-@@ -467,7 +470,9 @@ public:\n-           precision_(other.precision_),\n-           indent_size_(other.indent_size_),\n-           line_length_limit_(other.line_length_limit_),\n--          new_line_chars_(std::move(other.new_line_chars_))\n-+          new_line_chars_(std::move(other.new_line_chars_)),\n-+          after_key_chars_(std::move(other.after_key_chars_)),\n-+          indent_chars_(std::move(other.indent_chars))\n-     {\n-     }\n- \n-@@ -515,6 +520,16 @@ public:\n-         return new_line_chars_;\n-     }\n- \n-+    string_type after_key_chars() const\n-+    {\n-+        return after_key_chars_;\n-+    }\n-+\n-+    string_type indent_chars() const\n-+    {\n-+        return indent_chars_;\n-+    }\n-+\n-     std::size_t line_length_limit() const \n-     {\n-         return line_length_limit_;\n-@@ -599,6 +614,8 @@ public:\n-     using basic_json_encode_options<CharT>::pad_inside_object_braces;\n-     using basic_json_encode_options<CharT>::pad_inside_array_brackets;\n-     using basic_json_encode_options<CharT>::new_line_chars;\n-+    using basic_json_encode_options<CharT>::after_key_chars;\n-+    using basic_json_encode_options<CharT>::indent_chars;\n-     using basic_json_encode_options<CharT>::line_length_limit;\n-     using basic_json_encode_options<CharT>::float_format;\n-     using basic_json_encode_options<CharT>::precision;\n-@@ -761,6 +778,18 @@ public:\n-         return *this;\n-     }\n- \n-+    basic_json_options& after_key_chars(const string_type& value)\n-+    {\n-+        this->after_key_chars_ = value;\n-+        return *this;\n-+    }\n-+\n-+    basic_json_options& indent_chars(const string_type& value)\n-+    {\n-+        this->indent_chars_ = value;\n-+        return *this;\n-+    }\n-+\n-     basic_json_options& lossless_number(bool value) \n-     {\n-         this->lossless_number_ = value;\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 7c9f9a311008..28a9b6dd7502 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -72,8 +72,11 @@ set(REFLEX \"${THIRD_PARTY_LIB_DIR}/reflex/bin/reflex\")\n \n add_third_party(\n   jsoncons\n-  URL https://github.com/danielaparker/jsoncons/archive/refs/tags/v0.171.1.tar.gz\n-  PATCH_COMMAND patch -p1 -i \"${CMAKE_SOURCE_DIR}/patches/jsoncons-v0.171.0.patch\"\n+  GIT_REPOSITORY https://github.com/dragonflydb/jsoncons\n+  # URL https://github.com/danielaparker/jsoncons/archive/refs/tags/v0.171.1.tar.gz\n+  GIT_TAG Dragonfly\n+  GIT_SHALLOW 1\n+  # PATCH_COMMAND patch -p1 -i \"${CMAKE_SOURCE_DIR}/patches/jsoncons-v0.171.0.patch\"\n   CMAKE_PASS_FLAGS \"-DJSONCONS_BUILD_TESTS=OFF -DJSONCONS_HAS_POLYMORPHIC_ALLOCATOR=ON\"\n   LIB \"none\"\n )\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 343ee514f35a..996b7773c891 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -38,7 +38,7 @@ using OptBool = optional<bool>;\n using OptLong = optional<long>;\n using OptSizeT = optional<size_t>;\n using OptString = optional<string>;\n-using JsonReplaceCb = function<void(const string&, JsonType&)>;\n+using JsonReplaceCb = function<void(const JsonExpression::path_node_type&, JsonType&)>;\n using JsonReplaceVerify = std::function<OpStatus(JsonType&)>;\n using CI = CommandId;\n \n@@ -119,28 +119,28 @@ void PrintOptVec(ConnectionContext* cntx, const OpResult<vector<optional<T>>>& r\n }\n \n error_code JsonReplace(JsonType& instance, string_view path, JsonReplaceCb callback) {\n-  using evaluator_t = jsoncons::jsonpath::detail::jsonpath_evaluator<JsonType, JsonType&>;\n+  using evaluator_t = jsonpath::detail::jsonpath_evaluator<JsonType, JsonType&>;\n   using value_type = evaluator_t::value_type;\n   using reference = evaluator_t::reference;\n   using json_selector_t = evaluator_t::path_expression_type;\n-  using json_location_type = evaluator_t::json_location_type;\n+\n   jsonpath::custom_functions<JsonType> funcs = jsonpath::custom_functions<JsonType>();\n \n   error_code ec;\n-  jsoncons::jsonpath::detail::static_resources<value_type, reference> static_resources(funcs);\n+  jsonpath::detail::static_resources<value_type, reference> static_resources(funcs);\n   evaluator_t e;\n   json_selector_t expr = e.compile(static_resources, path, ec);\n   if (ec) {\n     return ec;\n   }\n \n-  jsoncons::jsonpath::detail::dynamic_resources<value_type, reference> resources;\n-  auto f = [&callback](const json_location_type& path, reference val) {\n-    callback(path.to_string(), val);\n+  jsonpath::detail::dynamic_resources<value_type, reference> resources;\n+  auto f = [&callback](const json_selector_t::path_node_type& path, reference val) {\n+    callback(path, val);\n   };\n \n-  expr.evaluate(resources, instance, resources.root_path_node(), instance, f,\n-                jsonpath::result_options::nodups);\n+  expr.evaluate(resources, instance, json_selector_t::path_node_type{}, instance, f,\n+                jsonpath::result_options::nodups | jsonpath::result_options::path);\n   return ec;\n }\n \n@@ -532,7 +532,7 @@ OpResult<vector<OptSizeT>> OpArrLen(const OpArgs& op_args, string_view key,\n \n OpResult<vector<OptBool>> OpToggle(const OpArgs& op_args, string_view key, string_view path) {\n   vector<OptBool> vec;\n-  auto cb = [&vec](const string& path, JsonType& val) {\n+  auto cb = [&vec](const auto&, JsonType& val) {\n     if (val.is_bool()) {\n       bool current_val = val.as_bool() ^ true;\n       val = current_val;\n@@ -558,7 +558,7 @@ OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key, stri\n   bool has_fractional_part = (modf(num, &int_part) != 0);\n   json output(json_array_arg);\n \n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto&, JsonType& val) {\n     if (val.is_number()) {\n       double result = arithmetic_op(val.as<double>(), num);\n       if (isinf(result)) {\n@@ -607,9 +607,10 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path) {\n   }\n \n   vector<string> deletion_items;\n-  auto cb = [&](const string& path, JsonType& val) { deletion_items.emplace_back(path); };\n+  auto cb = [&](const JsonExpression::path_node_type& path, JsonType& val) {\n+    deletion_items.emplace_back(jsonpath::to_string(path));\n+  };\n \n-  // json j = move(result.value());\n   JsonType& json_entry = *(result.value());\n   error_code ec = JsonReplace(json_entry, path, cb);\n   if (ec) {\n@@ -672,7 +673,7 @@ OpResult<vector<StringVec>> OpObjKeys(const OpArgs& op_args, string_view key,\n OpResult<vector<OptSizeT>> OpStrAppend(const OpArgs& op_args, string_view key, string_view path,\n                                        const vector<string_view>& strs) {\n   vector<OptSizeT> vec;\n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto&, JsonType& val) {\n     if (val.is_string()) {\n       string new_val = val.as_string();\n       for (auto& str : strs) {\n@@ -698,7 +699,7 @@ OpResult<vector<OptSizeT>> OpStrAppend(const OpArgs& op_args, string_view key, s\n // Clears containers(arrays or objects) and zeroing numbers.\n OpResult<long> OpClear(const OpArgs& op_args, string_view key, string_view path) {\n   long clear_items = 0;\n-  auto cb = [&clear_items](const string& path, JsonType& val) {\n+  auto cb = [&clear_items](const auto& path, JsonType& val) {\n     if (!(val.is_object() || val.is_array() || val.is_number())) {\n       return;\n     }\n@@ -725,7 +726,7 @@ OpResult<long> OpClear(const OpArgs& op_args, string_view key, string_view path)\n OpResult<vector<OptString>> OpArrPop(const OpArgs& op_args, string_view key, string_view path,\n                                      int index) {\n   vector<OptString> vec;\n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto& path, JsonType& val) {\n     if (!val.is_array() || val.empty()) {\n       vec.emplace_back(nullopt);\n       return;\n@@ -768,7 +769,7 @@ OpResult<vector<OptString>> OpArrPop(const OpArgs& op_args, string_view key, str\n OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, string_view path,\n                                      int start_index, int stop_index) {\n   vector<OptSizeT> vec;\n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto&, JsonType& val) {\n     if (!val.is_array()) {\n       vec.emplace_back(nullopt);\n       return;\n@@ -824,7 +825,7 @@ OpResult<vector<OptSizeT>> OpArrInsert(const OpArgs& op_args, string_view key, s\n   // Insert user-supplied value into the supplied index that should be valid.\n   // If at least one index isn't valid within an array in the json doc, the operation is discarded.\n   // Negative indexes start from the end of the array.\n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto&, JsonType& val) {\n     if (out_of_boundaries_encountered) {\n       return;\n     }\n@@ -889,7 +890,7 @@ OpResult<vector<OptSizeT>> OpArrAppend(const OpArgs& op_args, string_view key, s\n     return result.status();\n   }\n \n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto&, JsonType& val) {\n     if (!val.is_array()) {\n       vec.emplace_back(nullopt);\n       return;\n@@ -1091,7 +1092,7 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n   bool path_exists = false;\n   bool operation_result = false;\n   const JsonType& new_json = parsed_json.value();\n-  auto cb = [&](const string& path, JsonType& val) {\n+  auto cb = [&](const auto&, JsonType& val) {\n     path_exists = true;\n     if (!is_nx_condition) {\n       operation_result = true;\n",
  "test_patch": "diff --git a/src/core/json_test.cc b/src/core/json_test.cc\nindex df1463c658f1..510bd9da0d0b 100644\n--- a/src/core/json_test.cc\n+++ b/src/core/json_test.cc\n@@ -85,18 +85,15 @@ TEST_F(JsonTest, Path) {\n   EXPECT_FALSE(ec);\n \n   expr.evaluate(j1, [](const std::string& path, const json& val) {\n-    ASSERT_EQ(\"$\", path);\n+    ASSERT_EQ(\"$['field']\", path);\n     ASSERT_EQ(1, val.as<int>());\n   });\n \n   expr = jsonpath::make_expression<json>(\"$.field-dash\", ec);\n-  EXPECT_TRUE(ec);  // can not parse '-'\n+  ASSERT_FALSE(ec);  // parses '-'\n \n-  ec = {};\n-  expr = jsonpath::make_expression<json>(\"$.'field-dash'\", ec);\n-  ASSERT_FALSE(ec);\n   expr.evaluate(j1, [](const std::string& path, const json& val) {\n-    ASSERT_EQ(\"$\", path);\n+    ASSERT_EQ(\"$['field-dash']\", path);\n     ASSERT_EQ(2, val.as<int>());\n   });\n }\n",
  "problem_statement": "FT.CREATE fields with dash errors with \"Bad json path\"\n**Describe the bug**\r\nI'm trying to create an index on json objects which have some fields with dashes in their name.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Try to create an index `FT.CREATE idx ON JSON SCHEMA $.some-text AS some-text TEXT $.some-tag AS some-tag TAG`\r\n2. See error `(error) ERR Bad json path: $.some-text`\r\n\r\n**Expected behavior**\r\nI expect that the index will be created successfully as it does in RediSearch, and correctly index and find objects with such fields.\r\n\r\n**Environment (please complete the following information):**\r\n - OS: [ubuntu 20.04]\r\n - Kernel: `5.15.0-47-generic`\r\n - Containerized: Docker\r\n - Dragonfly Version: 1.13.0\r\n\r\n**Reproducible Code Snippet**\r\n```\r\ndocker run -d --network=host --ulimit memlock=-1 docker.dragonflydb.io/dragonflydb/dragonfly\r\nredis-cli\r\nFT.CREATE idx ON JSON SCHEMA $.some-text AS some-text TEXT $.some-tag AS some-tag TAG\r\n```\r\n\r\n**Additional context**\r\nThis does work on RediSearch, I tried digging a bit and I think it might be related to the implementation of [`jsoncons`](https://github.com/danielaparker/jsoncons/blob/master/include/jsoncons_ext/jmespath/jmespath.hpp#L3433) and its usage in dragonfly in [`IsValidJsonPath`](https://github.com/dragonflydb/dragonfly/blob/main/src/server/search/search_family.cc#L42)\r\n\n",
  "hints_text": "Thank you @chkp-omris .\r\nA minimal reproducible example is `FT.CREATE idx ON JSON SCHEMA $.text-d TEXT` where it rejects `-` field.\r\nwhile we are at it, `FT.CREATE idx ON JSON SCHEMA $.text` responds with a bit confusing error, imho - `ERR Invalid field type:` instead of something like `missing type specifier for field $.text` \nThe workaround @chkp-omris  is to use `FT.CREATE idx ON JSON SCHEMA \"$.'text-d'\" TEXT`.\r\n\r\nDoes it work for you?",
  "created_at": "2023-12-07T12:31:56Z",
  "modified_files": [
    "patches/jsoncons-v0.171.0.patch",
    "src/CMakeLists.txt",
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/core/json_test.cc"
  ]
}