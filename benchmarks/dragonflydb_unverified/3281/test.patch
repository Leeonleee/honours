diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc
index aa15589359f5..a96be4b28e89 100644
--- a/src/server/dragonfly_test.cc
+++ b/src/server/dragonfly_test.cc
@@ -362,6 +362,13 @@ TEST_F(DflyEngineTest, MemcacheFlags) {
   ASSERT_EQ(resp, "OK");
   MCResponse resp2 = RunMC(MP::GET, "key");
   EXPECT_THAT(resp2, ElementsAre("VALUE key 42 3", "bar", "END"));
+
+  ASSERT_EQ(Run("resp", {"flushdb"}), "OK");
+  pp_->AwaitFiberOnAll([](auto*) {
+    if (auto* shard = EngineShard::tlocal(); shard) {
+      EXPECT_EQ(shard->db_slice().GetDBTable(0)->mcflag.size(), 0u);
+    }
+  });
 }
 
 TEST_F(DflyEngineTest, LimitMemory) {
diff --git a/src/server/tiered_storage_test.cc b/src/server/tiered_storage_test.cc
index 909f053c3792..f97f097d89d2 100644
--- a/src/server/tiered_storage_test.cc
+++ b/src/server/tiered_storage_test.cc
@@ -30,6 +30,13 @@ ABSL_DECLARE_FLAG(unsigned, tiered_storage_write_depth);
 
 namespace dfly {
 
+using absl::GetFlag;
+using absl::SetFlag;
+
+string BuildString(size_t len, char c = 'A') {
+  return string(len, c);
+}
+
 class TieredStorageTest : public BaseFamilyTest {
  protected:
   TieredStorageTest() {
@@ -37,15 +44,17 @@ class TieredStorageTest : public BaseFamilyTest {
   }
 
   void SetUp() override {
-    if (absl::GetFlag(FLAGS_force_epoll)) {
+    if (GetFlag(FLAGS_force_epoll)) {
       LOG(WARNING) << "Can't run tiered tests on EPOLL";
       exit(0);
     }
 
-    absl::SetFlag(&FLAGS_tiered_storage_write_depth, 15000);
-    absl::SetFlag(&FLAGS_tiered_prefix, "/tmp/tiered_storage_test");
-    absl::SetFlag(&FLAGS_tiered_storage_cache_fetched, true);
-    absl::SetFlag(&FLAGS_backing_file_direct, true);
+    SetFlag(&FLAGS_tiered_storage_write_depth, 15000);
+    if (GetFlag(FLAGS_tiered_prefix).empty()) {
+      SetFlag(&FLAGS_tiered_prefix, "/tmp/tiered_storage_test");
+    }
+    SetFlag(&FLAGS_tiered_storage_cache_fetched, true);
+    SetFlag(&FLAGS_backing_file_direct, true);
 
     BaseFamilyTest::SetUp();
   }
@@ -54,13 +63,13 @@ class TieredStorageTest : public BaseFamilyTest {
 // Perform simple series of SET, GETSET and GET
 TEST_F(TieredStorageTest, SimpleGetSet) {
   absl::FlagSaver saver;
-  absl::SetFlag(&FLAGS_tiered_offload_threshold, 1.1f);  // disable offloading
+  SetFlag(&FLAGS_tiered_offload_threshold, 1.1f);  // disable offloading
   const int kMin = 256;
   const int kMax = tiering::kPageSize + 10;
 
   // Perform SETs
   for (size_t i = kMin; i < kMax; i++) {
-    Run({"SET", absl::StrCat("k", i), string(i, 'A')});
+    Run({"SET", absl::StrCat("k", i), BuildString(i)});
   }
 
   // Make sure all entries were stashed, except the one not filling a small page
@@ -113,18 +122,18 @@ TEST_F(TieredStorageTest, SimpleAppend) {
   // TODO: use pipelines to issue APPEND/GET/APPEND sequence,
   // currently it's covered only for op_manager_test
   for (size_t sleep : {0, 100, 500, 1000}) {
-    Run({"SET", "k0", string(3000, 'A')});
+    Run({"SET", "k0", BuildString(3000)});
     if (sleep)
       util::ThisFiber::SleepFor(sleep * 1us);
     EXPECT_THAT(Run({"APPEND", "k0", "B"}), IntArg(3001));
-    EXPECT_EQ(Run({"GET", "k0"}), string(3000, 'A') + 'B');
+    EXPECT_EQ(Run({"GET", "k0"}), BuildString(3000) + 'B');
   }
 }
 
 TEST_F(TieredStorageTest, MultiDb) {
   for (size_t i = 0; i < 10; i++) {
     Run({"SELECT", absl::StrCat(i)});
-    Run({"SET", absl::StrCat("k", i), string(3000, char('A' + i))});
+    Run({"SET", absl::StrCat("k", i), BuildString(3000, char('A' + i))});
   }
 
   ExpectConditionWithinTimeout([this] { return GetMetrics().tiered_stats.total_stashes >= 10; });
@@ -132,7 +141,7 @@ TEST_F(TieredStorageTest, MultiDb) {
   for (size_t i = 0; i < 10; i++) {
     Run({"SELECT", absl::StrCat(i)});
     EXPECT_EQ(GetMetrics().db_stats[i].tiered_entries, 1);
-    EXPECT_EQ(Run({"GET", absl::StrCat("k", i)}), string(3000, char('A' + i)));
+    EXPECT_EQ(Run({"GET", absl::StrCat("k", i)}), BuildString(3000, char('A' + i)));
     EXPECT_EQ(GetMetrics().db_stats[i].tiered_entries, 0);
   }
 }
@@ -168,7 +177,7 @@ TEST_F(TieredStorageTest, Defrag) {
 
 TEST_F(TieredStorageTest, BackgroundOffloading) {
   absl::FlagSaver saver;
-  absl::SetFlag(&FLAGS_tiered_offload_threshold, 0.0f);  // offload all values
+  SetFlag(&FLAGS_tiered_offload_threshold, 0.0f);  // offload all values
 
   const int kNum = 500;
 
@@ -177,7 +186,7 @@ TEST_F(TieredStorageTest, BackgroundOffloading) {
 
   // Stash all values
   for (size_t i = 0; i < kNum; i++) {
-    Run({"SET", absl::StrCat("k", i), string(3000, 'A')});
+    Run({"SET", absl::StrCat("k", i), BuildString(3000)});
   }
 
   ExpectConditionWithinTimeout([&] { return GetMetrics().db_stats[0].tiered_entries == kNum; });
@@ -200,11 +209,11 @@ TEST_F(TieredStorageTest, BackgroundOffloading) {
 
 TEST_F(TieredStorageTest, FlushAll) {
   absl::FlagSaver saver;
-  absl::SetFlag(&FLAGS_tiered_offload_threshold, 0.0f);  // offload all values
+  SetFlag(&FLAGS_tiered_offload_threshold, 0.0f);  // offload all values
 
   const int kNum = 500;
   for (size_t i = 0; i < kNum; i++) {
-    Run({"SET", absl::StrCat("k", i), string(3000, 'A')});
+    Run({"SET", absl::StrCat("k", i), BuildString(3000)});
   }
   ExpectConditionWithinTimeout([&] { return GetMetrics().db_stats[0].tiered_entries == kNum; });
 
@@ -228,4 +237,18 @@ TEST_F(TieredStorageTest, FlushAll) {
   EXPECT_GT(metrics.tiered_stats.total_fetches, 2u);
 }
 
+TEST_F(TieredStorageTest, FlushPending) {
+  absl::FlagSaver saver;
+  SetFlag(&FLAGS_tiered_offload_threshold, 0.0f);  // offload all values
+
+  const int kNum = 10;
+  for (size_t i = 0; i < kNum; i++) {
+    Run({"SET", absl::StrCat("k", i), BuildString(256)});
+  }
+  ExpectConditionWithinTimeout(
+      [&] { return GetMetrics().tiered_stats.small_bins_filling_bytes > 0; });
+  Run({"FLUSHALL"});
+  EXPECT_EQ(GetMetrics().tiered_stats.small_bins_filling_bytes, 0u);
+}
+
 }  // namespace dfly
diff --git a/src/server/tiering/op_manager_test.cc b/src/server/tiering/op_manager_test.cc
index c8aed570ff47..ec589e21a920 100644
--- a/src/server/tiering/op_manager_test.cc
+++ b/src/server/tiering/op_manager_test.cc
@@ -100,7 +100,7 @@ TEST_F(OpManagerTest, DeleteAfterReads) {
     std::vector<util::fb2::Future<std::string>> reads;
     for (unsigned i = 0; i < 100; i++)
       reads.emplace_back(Read(0u, stashed_[0u]));
-    Delete(stashed_[0u]);
+    DeleteOffloaded(stashed_[0u]);
 
     for (auto& fut : reads)
       EXPECT_EQ(fut.Get(), "DATA");
diff --git a/tests/dragonfly/conftest.py b/tests/dragonfly/conftest.py
index 926dd50734ab..49e06f134df7 100644
--- a/tests/dragonfly/conftest.py
+++ b/tests/dragonfly/conftest.py
@@ -19,7 +19,7 @@
 from copy import deepcopy
 
 from pathlib import Path
-from tempfile import TemporaryDirectory, gettempdir
+from tempfile import gettempdir, mkdtemp
 
 from .instance import DflyInstance, DflyParams, DflyInstanceFactory, RedisServer
 from . import PortPicker, dfly_args
@@ -37,9 +37,12 @@ def tmp_dir():
     where the Dragonfly executable will be run and where all test data
     should be stored. The directory will be cleaned up at the end of a session
     """
-    tmp = TemporaryDirectory()
-    yield Path(tmp.name)
-    tmp.cleanup()
+    tmp_name = mkdtemp()
+    yield Path(tmp_name)
+    if os.environ.get("DRAGONFLY_KEEP_TMP"):
+        logging.info(f"Keeping tmp dir {tmp_name}")
+        return
+    shutil.rmtree(tmp_name, ignore_errors=True)
 
 
 @pytest.fixture(scope="session")
diff --git a/tests/dragonfly/instance.py b/tests/dragonfly/instance.py
index ed102c0c9c66..50ce582080b0 100644
--- a/tests/dragonfly/instance.py
+++ b/tests/dragonfly/instance.py
@@ -215,6 +215,8 @@ def _check_status(self):
         if not self.params.existing_port:
             return_code = self.proc.poll()
             if return_code is not None:
+                # log stdout of the failed process
+                logging.error("Dragonfly process error:
%s", self.proc.stdout.read().decode())
                 self.proc = None
                 raise DflyStartException(f"Failed to start instance, return code {return_code}")
 
