{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2858,
  "instance_id": "dragonflydb__dragonfly-2858",
  "issue_numbers": [
    "2756"
  ],
  "base_commit": "a5ea47f2d99b1abb9683f675fef9086a953bdc7f",
  "patch": "diff --git a/src/server/cluster/cluster_family.cc b/src/server/cluster/cluster_family.cc\nindex 61fbf060569b..ba86f46be62e 100644\n--- a/src/server/cluster/cluster_family.cc\n+++ b/src/server/cluster/cluster_family.cc\n@@ -406,7 +406,7 @@ void ClusterFamily::DflyCluster(CmdArgList args, ConnectionContext* cntx) {\n   } else if (sub_cmd == \"FLUSHSLOTS\") {\n     return DflyClusterFlushSlots(args, cntx);\n   } else if (sub_cmd == \"SLOT-MIGRATION-STATUS\") {\n-    return DflyIncomingSlotMigrationStatus(args, cntx);\n+    return DflySlotMigrationStatus(args, cntx);\n   }\n \n   return cntx->SendError(UnknownSubCmd(sub_cmd, \"DFLYCLUSTER\"), kSyntaxErrType);\n@@ -609,7 +609,7 @@ bool ClusterFamily::StartSlotMigrations(std::vector<MigrationInfo> migrations,\n   return true;\n }\n \n-static std::string_view state_to_str(MigrationState state) {\n+static string_view StateToStr(MigrationState state) {\n   switch (state) {\n     case MigrationState::C_NO_STATE:\n       return \"NO_STATE\"sv;\n@@ -626,44 +626,67 @@ static std::string_view state_to_str(MigrationState state) {\n   return \"UNDEFINED_STATE\"sv;\n }\n \n-void ClusterFamily::DflyIncomingSlotMigrationStatus(CmdArgList args, ConnectionContext* cntx) {\n-  CmdArgParser parser(args);\n+static uint64_t GetKeyCount(const SlotRanges& slots) {\n+  atomic_uint64_t keys = 0;\n+\n+  shard_set->pool()->Await([&](auto*) {\n+    EngineShard* shard = EngineShard::tlocal();\n+    if (shard == nullptr)\n+      return;\n+\n+    uint64_t shard_keys = 0;\n+    for (const SlotRange& range : slots) {\n+      for (SlotId slot = range.start; slot <= range.end; slot++) {\n+        shard_keys += shard->db_slice().GetSlotStats(slot).key_count;\n+      }\n+    }\n+    keys.fetch_add(shard_keys);\n+  });\n+\n+  return keys.load();\n+}\n+\n+void ClusterFamily::DflySlotMigrationStatus(CmdArgList args, ConnectionContext* cntx) {\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  CmdArgParser parser(args);\n+\n+  lock_guard lk(migration_mu_);\n \n+  string_view node_id;\n   if (parser.HasNext()) {\n-    auto node_id = parser.Next<std::string_view>();\n-    if (auto err = parser.Error(); err)\n+    node_id = parser.Next<std::string_view>();\n+    if (auto err = parser.Error(); err) {\n       return rb->SendError(err->MakeReply());\n-\n-    lock_guard lk(migration_mu_);\n-    // find incoming slot migration\n-    for (const auto& m : incoming_migrations_jobs_) {\n-      if (m->GetSourceID() == node_id)\n-        return rb->SendSimpleString(state_to_str(m->GetState()));\n-    }\n-    // find outgoing slot migration\n-    for (const auto& migration : outgoing_migration_jobs_) {\n-      if (migration->GetMigrationInfo().node_id == node_id)\n-        return rb->SendSimpleString(state_to_str(migration->GetState()));\n     }\n-  } else if (auto arr_size = incoming_migrations_jobs_.size() + outgoing_migration_jobs_.size();\n-             arr_size != 0) {\n-    rb->StartArray(arr_size);\n-    const auto& send_answer = [rb](std::string_view direction, std::string_view node_id,\n-                                   auto state) {\n-      auto str = absl::StrCat(direction, \" \", node_id, \" \", state_to_str(state));\n-      rb->SendSimpleString(str);\n-    };\n-    lock_guard lk(migration_mu_);\n-    for (const auto& m : incoming_migrations_jobs_) {\n-      send_answer(\"in\", m->GetSourceID(), m->GetState());\n-    }\n-    for (const auto& migration : outgoing_migration_jobs_) {\n-      send_answer(\"out\", migration->GetMigrationInfo().node_id, migration->GetState());\n+  }\n+\n+  vector<string> reply;\n+  reply.reserve(incoming_migrations_jobs_.size() + outgoing_migration_jobs_.size());\n+\n+  auto append_answer = [rb, &reply](string_view direction, string_view node_id, string_view filter,\n+                                    MigrationState state, const SlotRanges& slots) {\n+    if (filter.empty() || filter == node_id) {\n+      reply.push_back(absl::StrCat(direction, \" \", node_id, \" \", StateToStr(state), \" \",\n+                                   \"keys:\", GetKeyCount(slots)));\n     }\n-    return;\n+  };\n+\n+  for (const auto& m : incoming_migrations_jobs_) {\n+    append_answer(\"in\", m->GetSourceID(), node_id, m->GetState(), m->GetSlots());\n+  }\n+  for (const auto& migration : outgoing_migration_jobs_) {\n+    append_answer(\"out\", migration->GetMigrationInfo().node_id, node_id, migration->GetState(),\n+                  migration->GetSlots());\n+  }\n+\n+  if (reply.empty()) {\n+    rb->SendSimpleString(StateToStr(MigrationState::C_NO_STATE));\n+  } else if (!node_id.empty()) {\n+    DCHECK_EQ(reply.size(), 1UL);\n+    rb->SendSimpleString(reply[0]);\n+  } else {\n+    rb->SendStringArr(reply);\n   }\n-  return rb->SendSimpleString(state_to_str(MigrationState::C_NO_STATE));\n }\n \n void ClusterFamily::DflyMigrate(CmdArgList args, ConnectionContext* cntx) {\ndiff --git a/src/server/cluster/cluster_family.h b/src/server/cluster/cluster_family.h\nindex cb88e214e69d..4d4ac3a5bfbe 100644\n--- a/src/server/cluster/cluster_family.h\n+++ b/src/server/cluster/cluster_family.h\n@@ -56,7 +56,7 @@ class ClusterFamily {\n   void DflyClusterFlushSlots(CmdArgList args, ConnectionContext* cntx);\n \n  private:  // Slots migration section\n-  void DflyIncomingSlotMigrationStatus(CmdArgList args, ConnectionContext* cntx);\n+  void DflySlotMigrationStatus(CmdArgList args, ConnectionContext* cntx);\n \n   // DFLYMIGRATE is internal command defines several steps in slots migrations process\n   void DflyMigrate(CmdArgList args, ConnectionContext* cntx);\ndiff --git a/tools/cluster_mgr.py b/tools/cluster_mgr.py\nindex 86c759b14393..fd99d57f327c 100755\n--- a/tools/cluster_mgr.py\n+++ b/tools/cluster_mgr.py\n@@ -343,7 +343,7 @@ def migrate(args):\n     while True:\n         sync_status = send_command(target_node, [\"DFLYCLUSTER\", \"SLOT-MIGRATION-STATUS\"])\n         assert len(sync_status) == 1\n-        if sync_status[0].endswith(\"STABLE_SYNC\"):\n+        if \"STABLE_SYNC\" in sync_status[0]:\n             break\n \n     print(\"Reached stable sync: \", sync_status)\n",
  "test_patch": "diff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py\nindex c3cec1541e4a..95ef38934d02 100644\n--- a/tests/dragonfly/cluster_test.py\n+++ b/tests/dragonfly/cluster_test.py\n@@ -1042,9 +1042,8 @@ async def test_cluster_data_migration(df_local_factory: DflyInstanceFactory):\n \n     await asyncio.sleep(0.5)\n \n-    while (\n-        await c_nodes_admin[1].execute_command(\"DFLYCLUSTER\", \"SLOT-MIGRATION-STATUS\", node_ids[0])\n-        != \"FINISHED\"\n+    while \"FINISHED\" not in await c_nodes_admin[1].execute_command(\n+        \"DFLYCLUSTER\", \"SLOT-MIGRATION-STATUS\", node_ids[0]\n     ):\n         await asyncio.sleep(0.05)\n \n@@ -1245,7 +1244,7 @@ async def list_counter(key, client: aioredis.RedisCluster):\n         for node in nodes:\n             states = await node.admin_client.execute_command(\"DFLYCLUSTER\", \"SLOT-MIGRATION-STATUS\")\n             print(states)\n-            if not all(s.endswith(\"FINISHED\") for s in states) and not states == \"NO_STATE\":\n+            if not all(\"FINISHED\" in s for s in states) and not states == \"NO_STATE\":\n                 break\n         else:\n             break\n",
  "problem_statement": "Add migration statistics to migration status\nAdd number of keys sent to target node\n",
  "hints_text": "",
  "created_at": "2024-04-07T16:04:35Z",
  "modified_files": [
    "src/server/cluster/cluster_family.cc",
    "src/server/cluster/cluster_family.h",
    "tools/cluster_mgr.py"
  ],
  "modified_test_files": [
    "tests/dragonfly/cluster_test.py"
  ]
}