{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3991,
  "instance_id": "dragonflydb__dragonfly-3991",
  "issue_numbers": [
    "3984"
  ],
  "base_commit": "7035606b4b516540d8a8f07a1b5d1d1d5c9c4df0",
  "patch": "diff --git a/src/core/dense_set.cc b/src/core/dense_set.cc\nindex c4be03b24429..f03d2cbabb00 100644\n--- a/src/core/dense_set.cc\n+++ b/src/core/dense_set.cc\n@@ -52,6 +52,8 @@ void DenseSet::IteratorBase::SetExpiryTime(uint32_t ttl_sec) {\n   if (!HasExpiry()) {\n     void* new_obj = owner_->ObjectClone(src, false, true);\n     ptr->SetObject(new_obj);\n+\n+    // Important: we set the ttl bit on the wrapping pointer.\n     curr_entry_->SetTtl(true);\n     owner_->ObjDelete(src, false);\n     src = new_obj;\n@@ -678,8 +680,12 @@ void* DenseSet::AddOrReplaceObj(void* obj, bool has_ttl) {\n   uint64_t hc = Hash(obj, 0);\n   DensePtr* dptr = entries_.empty() ? nullptr : Find(obj, BucketId(hc), 0).second;\n \n-  if (dptr) {  // replace\n-    if (dptr->IsLink())\n+  if (dptr) {  // replace existing object.\n+    // A bit confusing design: ttl bit is located on the wrapping pointer,\n+    // therefore we must set ttl bit before unrapping below.\n+    dptr->SetTtl(has_ttl);\n+\n+    if (dptr->IsLink())  // unwrap the pointer.\n       dptr = dptr->AsLink();\n \n     void* res = dptr->Raw();\n@@ -687,7 +693,6 @@ void* DenseSet::AddOrReplaceObj(void* obj, bool has_ttl) {\n     obj_malloc_used_ += ObjectAllocSize(obj);\n \n     dptr->SetObject(obj);\n-    dptr->SetTtl(has_ttl);\n \n     return res;\n   }\n",
  "test_patch": "diff --git a/src/core/string_map_test.cc b/src/core/string_map_test.cc\nindex 3feaef03d4d1..4f59fa0d3fe8 100644\n--- a/src/core/string_map_test.cc\n+++ b/src/core/string_map_test.cc\n@@ -168,6 +168,22 @@ TEST_F(StringMapTest, Bug3973) {\n   }\n }\n \n+TEST_F(StringMapTest, Bug3984) {\n+  for (unsigned i = 0; i < 6; i++) {\n+    EXPECT_TRUE(sm_->AddOrUpdate(to_string(i), \"val\"));\n+  }\n+  for (unsigned i = 0; i < 6; i++) {\n+    auto k = sm_->Find(to_string(i));\n+    ASSERT_FALSE(k.HasExpiry());\n+    k.SetExpiryTime(1);\n+    EXPECT_EQ(k.ExpiryTime(), 1);\n+  }\n+\n+  for (unsigned i = 0; i < 6; i++) {\n+    EXPECT_FALSE(sm_->AddOrUpdate(to_string(i), \"val\"));\n+  }\n+}\n+\n unsigned total_wasted_memory = 0;\n \n TEST_F(StringMapTest, ReallocIfNeeded) {\n",
  "problem_statement": "HEXPIRE can cause SIGFPE and SIGSEGV\n**Describe the bug**\r\nWhen sending `HSET` and `HEXPIRE` in parallell to fields under the same `key`, it seems to sometimes lead to segfault or floating point exceptions :thinking: \r\nThis never happens the first time you set / expire the key, but seems to happen on the second interaction with it.\r\n**I want to emphasize that this is a different error from the one reported yesterday.**\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Compile main branch, and start with `./dragonfly --alsologtostderr`\r\n2. Generate some test-data `for run in {1..100}; do touch $(uuidgen); done;`\r\n3. Run HSET and HEXPIRE at the same time, targeting same `key` and `field`. `ls | xargs -P 8 -I{} sh -c 'echo \"HSET abc {} 1\" | nc -q0 localhost 6379' &; ls | xargs -P 20 -I{} sh -c 'echo \"HEXPIRE abc 10 FIELDS 1 {}\" | nc -q0 localhost 6379'`\r\n4. repeat step 3.\r\n5. Observe one of two errors (?)\r\n```\r\n*** SIGFPE received at time=1729777199 on cpu 8 ***\r\nPC: @     0x5c94e22e72da  (unknown)  mi_free_generic_mt\r\nfish: Job 1, './dragonfly --alsologtostderr p\u2026' terminated by signal SIGFPE (Floating point exception)\r\n```\r\n```\r\n*** SIGSEGV received at time=1729777853 on cpu 8 ***\r\nPC: @     0x63fd16cf28c6  (unknown)  mi_heap_malloc\r\nfish: Job 1, './dragonfly --alsologtostderr p\u2026' terminated by signal SIGSEGV (Address boundary error)\r\n```\r\n\r\n**Expected behavior**\r\nNo crashes.\r\n\r\n**Environment (please complete the following information):**\r\n - OS: ubuntu 22.04\r\n - Kernel: # Linux  6.8.0-47-generic 47~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Oct  2 16:16:55 UTC 2 x86_64 x86_64 x86_64 GNU/Linux\r\n - Containerized?: No\r\n - Dragonfly Version: main@b7160404ede0b476f30914be044cb8bb5bf1da29\r\n\r\n**Additional context**\r\n@romange I'm just tagging you since you're probably the most familiar with the internals here. And since you're already familiar with both prs and the previous bug. :pray: \r\n\n",
  "hints_text": "",
  "created_at": "2024-10-24T16:35:59Z",
  "modified_files": [
    "src/core/dense_set.cc"
  ],
  "modified_test_files": [
    "src/core/string_map_test.cc"
  ]
}