{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2695,
  "instance_id": "dragonflydb__dragonfly-2695",
  "issue_numbers": [
    "2643"
  ],
  "base_commit": "66b87e16c2d9cb369f09ee0f35675e7dca6a5864",
  "patch": "diff --git a/src/server/cluster/cluster_family.cc b/src/server/cluster/cluster_family.cc\nindex 4146decac147..62214a3c8615 100644\n--- a/src/server/cluster/cluster_family.cc\n+++ b/src/server/cluster/cluster_family.cc\n@@ -25,6 +25,9 @@\n #include \"server/server_state.h\"\n \n ABSL_FLAG(std::string, cluster_announce_ip, \"\", \"ip that cluster commands announce to the client\");\n+ABSL_FLAG(std::string, cluster_node_id, \"\",\n+          \"ID within a cluster, used for slot assignment. MUST be unique. If empty, uses master \"\n+          \"replication ID (random string)\");\n \n ABSL_DECLARE_FLAG(int32_t, port);\n \n@@ -49,7 +52,16 @@ thread_local shared_ptr<ClusterConfig> tl_cluster_config;\n \n ClusterFamily::ClusterFamily(ServerFamily* server_family) : server_family_(server_family) {\n   CHECK_NOTNULL(server_family_);\n+\n   ClusterConfig::Initialize();\n+\n+  id_ = absl::GetFlag(FLAGS_cluster_node_id);\n+  if (id_.empty()) {\n+    id_ = server_family_->master_replid();\n+  } else if (ClusterConfig::IsEmulated()) {\n+    LOG(ERROR) << \"Setting --cluster_node_id in emulated mode is unsupported\";\n+    exit(1);\n+  }\n }\n \n ClusterConfig* ClusterFamily::cluster_config() {\n@@ -70,7 +82,7 @@ ClusterShard ClusterFamily::GetEmulatedShardInfo(ConnectionContext* cntx) const\n     std::string preferred_endpoint =\n         cluster_announce_ip.empty() ? cntx->conn()->LocalBindAddress() : cluster_announce_ip;\n \n-    info.master = {.id = server_family_->master_id(),\n+    info.master = {.id = id_,\n                    .ip = preferred_endpoint,\n                    .port = static_cast<uint16_t>(absl::GetFlag(FLAGS_port))};\n \n@@ -82,7 +94,7 @@ ClusterShard ClusterFamily::GetEmulatedShardInfo(ConnectionContext* cntx) const\n   } else {\n     info.master = {\n         .id = etl.remote_client_id_, .ip = replication_info->host, .port = replication_info->port};\n-    info.replicas.push_back({.id = server_family_->master_id(),\n+    info.replicas.push_back({.id = id_,\n                              .ip = cntx->conn()->LocalBindAddress(),\n                              .port = static_cast<uint16_t>(absl::GetFlag(FLAGS_port))});\n   }\n@@ -254,9 +266,9 @@ void ClusterNodesImpl(const ClusterShards& config, string_view my_id, Connection\n \n void ClusterFamily::ClusterNodes(ConnectionContext* cntx) {\n   if (ClusterConfig::IsEmulated()) {\n-    return ClusterNodesImpl({GetEmulatedShardInfo(cntx)}, server_family_->master_id(), cntx);\n+    return ClusterNodesImpl({GetEmulatedShardInfo(cntx)}, id_, cntx);\n   } else if (tl_cluster_config != nullptr) {\n-    return ClusterNodesImpl(tl_cluster_config->GetConfig(), server_family_->master_id(), cntx);\n+    return ClusterNodesImpl(tl_cluster_config->GetConfig(), id_, cntx);\n   } else {\n     return cntx->SendError(kClusterNotConfigured);\n   }\n@@ -408,7 +420,7 @@ void ClusterFamily::DflyClusterMyId(CmdArgList args, ConnectionContext* cntx) {\n     return cntx->SendError(WrongNumArgsError(\"DFLYCLUSTER MYID\"));\n   }\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  rb->SendBulkString(server_family_->master_id());\n+  rb->SendBulkString(id_);\n }\n \n namespace {\n@@ -483,8 +495,7 @@ void ClusterFamily::DflyClusterConfig(CmdArgList args, ConnectionContext* cntx)\n     return cntx->SendError(\"Invalid JSON cluster config\", kSyntaxErrType);\n   }\n \n-  shared_ptr<ClusterConfig> new_config =\n-      ClusterConfig::CreateFromConfig(server_family_->master_id(), json.value());\n+  shared_ptr<ClusterConfig> new_config = ClusterConfig::CreateFromConfig(id_, json.value());\n   if (new_config == nullptr) {\n     LOG(WARNING) << \"Can't set cluster config\";\n     return cntx->SendError(\"Invalid cluster configuration.\");\ndiff --git a/src/server/cluster/cluster_family.h b/src/server/cluster/cluster_family.h\nindex eec6c68470dc..525b15e84431 100644\n--- a/src/server/cluster/cluster_family.h\n+++ b/src/server/cluster/cluster_family.h\n@@ -100,6 +100,8 @@ class ClusterFamily {\n  private:\n   ClusterConfig::ClusterShard GetEmulatedShardInfo(ConnectionContext* cntx) const;\n \n+  std::string id_;\n+\n   ServerFamily* server_family_ = nullptr;\n };\n \ndiff --git a/src/server/dflycmd.cc b/src/server/dflycmd.cc\nindex 9de3976f4d61..bcacd13f7786 100644\n--- a/src/server/dflycmd.cc\n+++ b/src/server/dflycmd.cc\n@@ -190,7 +190,7 @@ void DflyCmd::Flow(CmdArgList args, ConnectionContext* cntx) {\n   VLOG(1) << \"Got DFLY FLOW master_id: \" << master_id << \" sync_id: \" << sync_id_str\n           << \" flow: \" << flow_id_str << \" seq: \" << seqid.value_or(-1);\n \n-  if (master_id != sf_->master_id()) {\n+  if (master_id != sf_->master_replid()) {\n     return rb->SendError(kBadMasterId);\n   }\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 6a119e98cb92..a5e591049efd 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -5,7 +5,7 @@\n #include \"server/server_family.h\"\n \n #include <absl/cleanup/cleanup.h>\n-#include <absl/random/random.h>  // for master_id_ generation.\n+#include <absl/random/random.h>  // for master_replid_ generation.\n #include <absl/strings/match.h>\n #include <absl/strings/str_join.h>\n #include <absl/strings/str_replace.h>\n@@ -615,8 +615,8 @@ ServerFamily::ServerFamily(Service* service) : service_(*service) {\n \n   {\n     absl::InsecureBitGen eng;\n-    master_id_ = GetRandomHex(eng, CONFIG_RUN_ID_SIZE);\n-    DCHECK_EQ(CONFIG_RUN_ID_SIZE, master_id_.size());\n+    master_replid_ = GetRandomHex(eng, CONFIG_RUN_ID_SIZE);\n+    DCHECK_EQ(CONFIG_RUN_ID_SIZE, master_replid_.size());\n   }\n \n   if (auto ec =\n@@ -2036,7 +2036,7 @@ void ServerFamily::Info(CmdArgList args, ConnectionContext* cntx) {\n         append(StrCat(\"slave\", i), StrCat(\"ip=\", r.address, \",port=\", r.listening_port,\n                                           \",state=\", r.state, \",lag=\", r.lsn_lag));\n       }\n-      append(\"master_replid\", master_id_);\n+      append(\"master_replid\", master_replid_);\n     } else {\n       append(\"role\", \"replica\");\n \n@@ -2273,7 +2273,7 @@ void ServerFamily::ReplicaOfInternal(string_view host, string_view port_sv, Conn\n   }\n \n   // Create a new replica and assing it\n-  auto new_replica = make_shared<Replica>(string(host), port, &service_, master_id());\n+  auto new_replica = make_shared<Replica>(string(host), port, &service_, master_replid());\n   replica_ = new_replica;\n \n   // TODO: disconnect pending blocked clients (pubsub, blocking commands)\n@@ -2385,7 +2385,7 @@ void ServerFamily::ReplConf(CmdArgList args, ConnectionContext* cntx) {\n         // The response for 'capa dragonfly' is: <masterid> <syncid> <numthreads> <version>\n         auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n         rb->StartArray(4);\n-        rb->SendSimpleString(master_id_);\n+        rb->SendSimpleString(master_replid_);\n         rb->SendSimpleString(sync_id);\n         rb->SendLong(replica_info->flows.size());\n         rb->SendLong(unsigned(DflyVersion::CURRENT_VER));\ndiff --git a/src/server/server_family.h b/src/server/server_family.h\nindex 15d1b0a2aa42..2c38e1c0328b 100644\n--- a/src/server/server_family.h\n+++ b/src/server/server_family.h\n@@ -187,8 +187,8 @@ class ServerFamily {\n   void PauseReplication(bool pause);\n   std::optional<ReplicaOffsetInfo> GetReplicaOffsetInfo();\n \n-  const std::string& master_id() const {\n-    return master_id_;\n+  const std::string& master_replid() const {\n+    return master_replid_;\n   }\n \n   journal::Journal* journal() {\n@@ -282,7 +282,7 @@ class ServerFamily {\n   std::unique_ptr<journal::Journal> journal_;\n   std::unique_ptr<DflyCmd> dfly_cmd_;\n \n-  std::string master_id_;\n+  std::string master_replid_;\n \n   time_t start_time_ = 0;  // in seconds, epoch time.\n \n",
  "test_patch": "diff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py\nindex f66d6bb058b8..396910ec50de 100644\n--- a/tests/dragonfly/cluster_test.py\n+++ b/tests/dragonfly/cluster_test.py\n@@ -174,6 +174,17 @@ async def test_cluster_nodes(df_server, async_client):\n \"\"\"\n \n \n+@dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\", \"cluster_node_id\": \"inigo montoya\"})\n+async def test_cluster_node_id(df_local_factory: DflyInstanceFactory):\n+    node = df_local_factory.create(port=BASE_PORT)\n+    df_local_factory.start_all([node])\n+\n+    conn = node.client()\n+    assert \"inigo montoya\" == await get_node_id(conn)\n+\n+    await close_clients(conn)\n+\n+\n @dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\"})\n async def test_cluster_slot_ownership_changes(df_local_factory: DflyInstanceFactory):\n     # Start and configure cluster with 2 nodes\n@@ -306,7 +317,7 @@ async def test_cluster_slot_ownership_changes(df_local_factory: DflyInstanceFact\n \n # Tests that master commands to the replica are applied regardless of slot ownership\n @dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\"})\n-async def test_cluster_replica_sets_non_owned_keys(df_local_factory):\n+async def test_cluster_replica_sets_non_owned_keys(df_local_factory: DflyInstanceFactory):\n     # Start and configure cluster with 1 master and 1 replica, both own all slots\n     master = df_local_factory.create(admin_port=BASE_PORT + 1000)\n     replica = df_local_factory.create(admin_port=BASE_PORT + 1001)\n@@ -570,14 +581,20 @@ async def test_cluster_blocking_command(df_server):\n     await close_clients(c_master, c_master_admin)\n \n \n+@pytest.mark.parametrize(\"set_cluster_node_id\", [True, False])\n @dfly_args({\"proactor_threads\": 4, \"cluster_mode\": \"yes\"})\n async def test_cluster_native_client(\n     df_local_factory: DflyInstanceFactory,\n     df_seeder_factory: DflySeederFactory,\n+    set_cluster_node_id: bool,\n ):\n     # Start and configure cluster with 3 masters and 3 replicas\n     masters = [\n-        df_local_factory.create(port=BASE_PORT + i, admin_port=BASE_PORT + i + 1000)\n+        df_local_factory.create(\n+            port=BASE_PORT + i,\n+            admin_port=BASE_PORT + i + 1000,\n+            cluster_node_id=f\"master{i}\" if set_cluster_node_id else \"\",\n+        )\n         for i in range(3)\n     ]\n     df_local_factory.start_all(masters)\n@@ -586,11 +603,17 @@ async def test_cluster_native_client(\n     master_ids = await asyncio.gather(*(get_node_id(c) for c in c_masters_admin))\n \n     replicas = [\n-        df_local_factory.create(port=BASE_PORT + 100 + i, admin_port=BASE_PORT + i + 1100)\n+        df_local_factory.create(\n+            port=BASE_PORT + 100 + i,\n+            admin_port=BASE_PORT + i + 1100,\n+            cluster_node_id=f\"replica{i}\" if set_cluster_node_id else \"\",\n+            replicaof=f\"localhost:{BASE_PORT + i}\",\n+        )\n         for i in range(3)\n     ]\n     df_local_factory.start_all(replicas)\n     c_replicas = [replica.client() for replica in replicas]\n+    await asyncio.gather(*(wait_available_async(c) for c in c_replicas))\n     c_replicas_admin = [replica.admin_client() for replica in replicas]\n     replica_ids = await asyncio.gather(*(get_node_id(c) for c in c_replicas_admin))\n \n@@ -678,10 +701,12 @@ async def test_random_keys():\n     await asyncio.gather(*(wait_available_async(c) for c in c_replicas))\n \n     # Make sure that getting a value from a replica works as well.\n-    replica_response = await client.execute_command(\n-        \"get\", \"key0\", target_nodes=aioredis.RedisCluster.REPLICAS\n-    )\n-    assert \"value\" in replica_response.values()\n+    # We use connections directly to NOT follow 'MOVED' error, as that will redirect to the master.\n+    for c in c_replicas:\n+        try:\n+            assert await c.get(\"key0\")\n+        except redis.exceptions.ResponseError as e:\n+            assert e.args[0].startswith(\"MOVED\")\n \n     # Push new config\n     config = f\"\"\"\ndiff --git a/tests/dragonfly/utility.py b/tests/dragonfly/utility.py\nindex b2176dad5bf3..47c42c91440f 100644\n--- a/tests/dragonfly/utility.py\n+++ b/tests/dragonfly/utility.py\n@@ -46,12 +46,8 @@ async def wait_available_async(client: aioredis.Redis, timeout=10):\n     start = time.time()\n     while (time.time() - start) < timeout:\n         try:\n-            await client.get(\"key\")\n+            await client.ping()\n             return\n-        except aioredis.ResponseError as e:\n-            if \"MOVED\" in str(e):\n-                # MOVED means we *can* serve traffic, but 'key' does not belong to an owned slot\n-                return\n         except aioredis.BusyLoadingError as e:\n             assert \"Dragonfly is loading the dataset in memory\" in str(e)\n \n",
  "problem_statement": "persistent node ids in cluster mode\n\n",
  "hints_text": "Some background on this issue:\r\n1. We need unique IDs for Dragonfly masters to support partial replication. This eliminates potential collisions when a replica connects to a different, or restarted, Dragonfly server\r\n2. We also need unique IDs for Dragonfly cluster nodes, so that they know which part of the config is assigned to them. In theory we could have used IP/port, but external/internal IPs make this complicated. I'm not sure it's worth giving up on, as it might simplify things.\r\n\r\nAnyway, currently we use the same ID for the above 2 (unrelated) requirements.\r\nThis issue is about being able to have a persistent ID for _cluster_ purposes. So my questions are:\r\n1. Is this persistent ID a flag (`--node_id=X`)?\r\n2. If not, is it saved in the RDB file? If so, what about nodes that do use `--dbfilename=`?\r\n3. Is this ID different from the replication ID?\r\nMy personal preference is to have a `--node_id=X`, which if unset randomizes a string like we do today. Replication will use the same ID, which means users have to be careful about setting this ID and switching replicas between masters with the same ID (but why would that even be a scenario?)\n@ashotland  to chip in. Also related to #2636\r\n1. do we need node id for cluster i.e. master and replica nodes for the same shard will have different ids, \r\n2. or we should set a shard id, i.e. master/slaves will share the same shard id, and slaves will indeed accept it upon replication together with cluster config. \r\n\r\nI do not think that replication should use the same id as master_id for replication if that's what @chakaz  means - see #2636 why we always want a random id for the replication.  ",
  "created_at": "2024-03-06T11:47:53Z",
  "modified_files": [
    "src/server/cluster/cluster_family.cc",
    "src/server/cluster/cluster_family.h",
    "src/server/dflycmd.cc",
    "src/server/server_family.cc",
    "src/server/server_family.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/cluster_test.py",
    "tests/dragonfly/utility.py"
  ]
}