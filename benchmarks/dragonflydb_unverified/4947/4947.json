{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4947,
  "instance_id": "dragonflydb__dragonfly-4947",
  "issue_numbers": [
    "3915"
  ],
  "base_commit": "eba8340ad130108847e59a71bc5f070d1f1b9e58",
  "patch": "diff --git a/src/core/dense_set.cc b/src/core/dense_set.cc\nindex c3273ba88a34..d78b572a6e30 100644\n--- a/src/core/dense_set.cc\n+++ b/src/core/dense_set.cc\n@@ -648,6 +648,8 @@ void DenseSet::Delete(DensePtr* prev, DensePtr* ptr) {\n \n       DenseLinkKey* plink = prev->AsLink();\n       DensePtr tmp = DensePtr::From(plink);\n+      // Transfer TTL flag\n+      tmp.SetTtl(prev->HasTtl());\n       DCHECK(ObjectAllocSize(tmp.GetObject()));\n \n       FreeLink(plink);\n",
  "test_patch": "diff --git a/src/core/string_set_test.cc b/src/core/string_set_test.cc\nindex 4a9f1fcd7f30..2e3f033f2817 100644\n--- a/src/core/string_set_test.cc\n+++ b/src/core/string_set_test.cc\n@@ -767,4 +767,16 @@ TEST_F(StringSetTest, ReallocIfNeeded) {\n     EXPECT_EQ(*ss_->Find(build_str(i * 10)), build_str(i * 10));\n }\n \n+TEST_F(StringSetTest, TransferTTLFlagLinkToObjectOnDelete) {\n+  for (size_t i = 0; i < 10; i++) {\n+    EXPECT_TRUE(ss_->Add(absl::StrCat(i), 1));\n+  }\n+  for (size_t i = 0; i < 9; i++) {\n+    EXPECT_TRUE(ss_->Erase(absl::StrCat(i)));\n+  }\n+  auto it = ss_->Find(\"9\"sv);\n+  EXPECT_TRUE(it.HasExpiry());\n+  EXPECT_EQ(1u, it.ExpiryTime());\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/set_family_test.cc b/src/server/set_family_test.cc\nindex ffddcc3b46f0..54bc93269aab 100644\n--- a/src/server/set_family_test.cc\n+++ b/src/server/set_family_test.cc\n@@ -412,4 +412,17 @@ TEST_F(SetFamilyTest, SAddEx) {\n   EXPECT_THAT(Run({\"saddex\", \"key\", \"KEEPTTL\", \"2\"}), ErrArg(\"wrong number of arguments\"));\n }\n \n+TEST_F(SetFamilyTest, CheckSetLinkExpiryTransfer) {\n+  for (int i = 0; i < 10; i++) {\n+    EXPECT_THAT(Run({\"SADDEX\", \"key\", \"5\", absl::StrCat(i)}), IntArg(1));\n+  }\n+  for (int i = 0; i < 9; i++) {\n+    Run({\"SREM\", \"key\", absl::StrCat(i)});\n+  }\n+  EXPECT_THAT(Run({\"SCARD\", \"key\"}), IntArg(1));\n+  AdvanceTime(6000);\n+  Run({\"SMEMBERS\", \"key\"});\n+  EXPECT_THAT(Run({\"SCARD\", \"key\"}), IntArg(0));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "`SADDEX` is broken\n**Describe the bug**\r\n`SADDEX` fails to expire members occasionally. Leaving them not having an expiration.\r\n\r\n**To Reproduce**\r\nHere's a test run in python with the redis-py package:\r\n```python\r\nfrom asyncio import sleep, Runner, gather\r\nfrom random import random\r\nfrom time import time_ns\r\nfrom redis.asyncio import Redis\r\n\r\nTIMEOUT = 10\r\nKEY = 'concurrentRequest:user:1'\r\n\r\n\r\nasync def simulate_request(redis):\r\n    member = time_ns()\r\n    await redis.execute_command('SADDEX', KEY, TIMEOUT, member)\r\n    await sleep(random())  # simulate handling the request\r\n\r\n    if random() < 0.05: # 5% chance to fail, members should be expired automatically\r\n        raise Exception\r\n    await redis.srem(KEY, member)\r\n\r\n\r\nasync def main():\r\n    # simulate 5000 requests\r\n    async with Redis(decode_responses=True) as redis:\r\n        requests = [simulate_request(redis) for _ in range(5000)]\r\n        await gather(*requests, return_exceptions=True)\r\n\r\n        # wait for the remaining failed requests to expire\r\n        await sleep(TIMEOUT + 1) \r\n\r\n        # actively expire by reading the key\r\n        await redis.smembers(KEY)\r\n\r\n        # assert the set is empty after running the test\r\n        cardinality = await redis.scard(KEY)\r\n        print(cardinality)\r\n        assert cardinality == 0\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    with Runner() as runner:\r\n        runner.run(main())\r\n\r\n```\r\n\r\n**Expected behavior**\r\nThe test runs without error, i.e. the set should be empty.\r\n\r\n**Environment (please complete the following information):**\r\n - OS: Debian 11 Bullseye\r\n - Dragonfly Version: v1.23.2-4959bef8d17e6132b4227ea7ca413faf1b1dc037\r\n\r\n\r\n**Additional context**\r\nI have a service in which I need to keep track of client's requests concurrency. I use a set to store the request starting-time as members, then it's `SREM` when the response is returned, therefore keeping the cardinality as the number of on-flight requests. I use `SADDEX` (add members with expiration to a set) instead of the normal `SADD` so that if any error occurs, the member will get removed automatically after a certain timeout. I'm aware that `SADDEX` is dragonfly-only and experimental, it's the one of the reason I'm using dragonfly over redis.\n",
  "hints_text": "Previously closed thinking it was due to passive expiration, but the bug still persists.\nHi! Can you please try replacing\r\n\r\n```py\r\ncardinality = await redis.scard(KEY)\r\n```\r\n\r\nwith \r\n\r\n```py\r\nmembers = await redis.smembers()\r\nassert members == []\r\n```\r\n\r\nOur set expiration logic is lazy, i.e. it invalidates only when a specific member is accessed.\r\n\nYes, that's why the issue was closed before. I edited the snipped to add\r\n```python\r\n# actively expire by reading the key\r\nawait redis.smembers(KEY)\r\n```\r\nbut the problem still persists, hence I reopened the issue. Inspecting with `redis-cli` confirms there are still some values left.\r\n",
  "created_at": "2025-04-16T12:51:06Z",
  "modified_files": [
    "src/core/dense_set.cc"
  ],
  "modified_test_files": [
    "src/core/string_set_test.cc",
    "src/server/set_family_test.cc"
  ]
}