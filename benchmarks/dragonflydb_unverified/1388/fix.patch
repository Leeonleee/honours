diff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc
index 0252309d3da2..9697829d9bdd 100644
--- a/src/facade/dragonfly_connection.cc
+++ b/src/facade/dragonfly_connection.cc
@@ -837,6 +837,10 @@ void Connection::ShutdownThreadLocal() {
   pipeline_req_pool_.clear();
 }
 
+bool Connection::IsCurrentlyDispatching() const {
+  return cc_->async_dispatch || cc_->sync_dispatch;
+}
+
 void RespToArgList(const RespVec& src, CmdArgVec* dest) {
   dest->resize(src.size());
   for (size_t i = 0; i < src.size(); ++i) {
diff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h
index c194a10d8212..20a1e0fde12f 100644
--- a/src/facade/dragonfly_connection.h
+++ b/src/facade/dragonfly_connection.h
@@ -138,6 +138,8 @@ class Connection : public util::Connection {
 
   static void ShutdownThreadLocal();
 
+  bool IsCurrentlyDispatching() const;
+
   std::string GetClientInfo(unsigned thread_id) const;
   std::string RemoteEndpointStr() const;
   std::string RemoteEndpointAddress() const;
diff --git a/src/facade/dragonfly_listener.cc b/src/facade/dragonfly_listener.cc
index ae3a48a49d26..5d5560dc200a 100644
--- a/src/facade/dragonfly_listener.cc
+++ b/src/facade/dragonfly_listener.cc
@@ -180,6 +180,37 @@ void Listener::PreAcceptLoop(util::ProactorBase* pb) {
 }
 
 void Listener::PreShutdown() {
+  // Iterate on all connections and allow them to finish their commands for
+  // a short period.
+  // Executed commands can be visible in snapshots or replicas, but if we close the client
+  // connections too fast we might not send the acknowledgment for those commands.
+  // This shouldn't take a long time: All clients should reject incoming commands
+  // at this stage since we're in SHUTDOWN mode.
+  // If a command is running for too long we give up and proceed.
+  const absl::Duration kDispatchShutdownTimeout = absl::Milliseconds(10);
+  absl::Time start = absl::Now();
+
+  bool success = false;
+  while (absl::Now() - start < kDispatchShutdownTimeout) {
+    std::atomic<bool> any_connection_dispatching = false;
+    auto cb = [&any_connection_dispatching](unsigned thread_index, util::Connection* conn) {
+      if (static_cast<Connection*>(conn)->IsCurrentlyDispatching()) {
+        any_connection_dispatching.store(true);
+      }
+    };
+    this->TraverseConnections(cb);
+    if (!any_connection_dispatching.load()) {
+      success = true;
+      break;
+    }
+    VLOG(1) << "A command is still dispatching, let's wait for it";
+    ThisFiber::SleepFor(100us);
+  }
+
+  if (!success) {
+    LOG(WARNING) << "Some commands are still being dispatched but didn't conclude in time. "
+                    "Proceeding in shutdown.";
+  }
 }
 
 void Listener::PostShutdown() {
diff --git a/src/server/server_family.cc b/src/server/server_family.cc
index 10d83a2c296c..924ba7766b92 100644
--- a/src/server/server_family.cc
+++ b/src/server/server_family.cc
@@ -2069,6 +2069,9 @@ void ServerFamily::_Shutdown(CmdArgList args, ConnectionContext* cntx) {
     }
   }
 
+  service_.proactor_pool().AwaitFiberOnAll(
+      [](ProactorBase* pb) { ServerState::tlocal()->EnterLameDuck(); });
+
   CHECK_NOTNULL(acceptor_)->Stop();
   (*cntx)->SendOk();
 }
