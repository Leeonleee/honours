diff --git a/src/facade/cmd_arg_parser.h b/src/facade/cmd_arg_parser.h
index bda1b5f7c33c..5f4fdaad5fa1 100644
--- a/src/facade/cmd_arg_parser.h
+++ b/src/facade/cmd_arg_parser.h
@@ -90,6 +90,11 @@ struct CmdArgParser {
     }
   }
 
+  // returns next value if exists or default value
+  template <class T = std::string_view> auto NextOrDefault(T default_value = {}) {
+    return HasNext() ? Next<T>() : default_value;
+  }
+
   // check next value ignoring case and consume it
   void ExpectTag(std::string_view tag);
 
diff --git a/src/facade/error.h b/src/facade/error.h
index c6aded2b55a0..d973b9d334ac 100644
--- a/src/facade/error.h
+++ b/src/facade/error.h
@@ -17,6 +17,7 @@ std::string UnknownSubCmd(std::string_view subcmd, std::string_view cmd);
 
 extern const char kSyntaxErr[];
 extern const char kWrongTypeErr[];
+extern const char kWrongJsonTypeErr[];
 extern const char kKeyNotFoundErr[];
 extern const char kInvalidIntErr[];
 extern const char kInvalidFloatErr[];
diff --git a/src/facade/facade.cc b/src/facade/facade.cc
index fce39a55cb84..041df090a874 100644
--- a/src/facade/facade.cc
+++ b/src/facade/facade.cc
@@ -79,6 +79,7 @@ string ConfigSetFailed(string_view config_name) {
 
 const char kSyntaxErr[] = "syntax error";
 const char kWrongTypeErr[] = "-WRONGTYPE Operation against a key holding the wrong kind of value";
+const char kWrongJsonTypeErr[] = "-WRONGTYPE wrong JSON type of path value";
 const char kKeyNotFoundErr[] = "no such key";
 const char kInvalidIntErr[] = "value is not an integer or out of range";
 const char kInvalidFloatErr[] = "value is not a valid float";
diff --git a/src/facade/op_status.cc b/src/facade/op_status.cc
index 941f0f0aa2d7..84f5c8e6a880 100644
--- a/src/facade/op_status.cc
+++ b/src/facade/op_status.cc
@@ -14,6 +14,8 @@ std::string_view StatusToMsg(OpStatus status) {
       return kKeyNotFoundErr;
     case OpStatus::WRONG_TYPE:
       return kWrongTypeErr;
+    case OpStatus::WRONG_JSON_TYPE:
+      return kWrongJsonTypeErr;
     case OpStatus::OUT_OF_RANGE:
       return kIndexOutOfRange;
     case OpStatus::INVALID_FLOAT:
diff --git a/src/facade/op_status.h b/src/facade/op_status.h
index 82ab517f3c99..4c5c1e92ca61 100644
--- a/src/facade/op_status.h
+++ b/src/facade/op_status.h
@@ -18,6 +18,7 @@ enum class OpStatus : uint16_t {
   INVALID_VALUE,
   OUT_OF_RANGE,
   WRONG_TYPE,
+  WRONG_JSON_TYPE,
   TIMED_OUT,
   OUT_OF_MEMORY,
   INVALID_FLOAT,
diff --git a/src/server/detail/wrapped_json_path.h b/src/server/detail/wrapped_json_path.h
index 7bca419ef684..fb2d2cf4efd9 100644
--- a/src/server/detail/wrapped_json_path.h
+++ b/src/server/detail/wrapped_json_path.h
@@ -24,32 +24,15 @@ using JsonExpression = jsoncons::jsonpath::jsonpath_expression<JsonType>;
 template <typename T>
 using JsonPathEvaluateCallback = absl::FunctionRef<T(std::string_view, const JsonType&)>;
 
-template <typename T = Nothing> class MutateCallbackResult {
- public:
+template <typename T = Nothing> struct MutateCallbackResult {
   MutateCallbackResult() = default;
 
-  explicit MutateCallbackResult(bool should_be_deleted) : should_be_deleted_(should_be_deleted_) {
-  }
-
-  MutateCallbackResult(bool should_be_deleted, T&& value)
-      : should_be_deleted_(should_be_deleted), value_(std::forward<T>(value)) {
-  }
-
-  bool HasValue() const {
-    return value_.has_value();
-  }
-
-  T&& GetValue() && {
-    return std::move(value_).value();
+  MutateCallbackResult(bool should_be_deleted_, T value_)
+      : should_be_deleted(should_be_deleted_), value(std::move(value_)) {
   }
 
-  bool ShouldBeDeleted() const {
-    return should_be_deleted_;
-  }
-
- private:
-  bool should_be_deleted_;
-  std::optional<T> value_;
+  bool should_be_deleted = false;
+  std::optional<T> value;
 };
 
 template <typename T>
@@ -81,7 +64,8 @@ template <typename T> class JsonCallbackResult {
 
   JsonCallbackResult() = default;
 
-  explicit JsonCallbackResult(bool legacy_mode_is_enabled) {
+  explicit JsonCallbackResult(bool legacy_mode_is_enabled, bool save_first_result = false)
+      : save_first_result_(save_first_result) {
     if (!legacy_mode_is_enabled) {
       result_ = JsonV2Result{};
     }
@@ -89,7 +73,14 @@ template <typename T> class JsonCallbackResult {
 
   void AddValue(T value) {
     if (IsV1()) {
-      details::OptionalEmplace(std::move(value), &AsV1());
+      if (!save_first_result_) {
+        details::OptionalEmplace(std::move(value), &AsV1());
+      } else {
+        auto& as_v1 = AsV1();
+        if (!as_v1.has_value()) {
+          details::OptionalEmplace(std::move(value), &as_v1);
+        }
+      }
     } else {
       AsV2().emplace_back(std::move(value));
     }
@@ -117,6 +108,7 @@ template <typename T> class JsonCallbackResult {
 
  private:
   std::variant<JsonV1Result, JsonV2Result> result_;
+  bool save_first_result_ = false;
 };
 
 class WrappedJsonPath {
@@ -137,14 +129,15 @@ class WrappedJsonPath {
   }
 
   template <typename T>
-  JsonCallbackResult<T> Evaluate(const JsonType* json_entry, JsonPathEvaluateCallback<T> cb) const {
-    return Evaluate(json_entry, cb, IsLegacyModePath());
+  JsonCallbackResult<T> Evaluate(const JsonType* json_entry, JsonPathEvaluateCallback<T> cb,
+                                 bool save_first_result) const {
+    return Evaluate(json_entry, cb, save_first_result, IsLegacyModePath());
   }
 
   template <typename T>
   JsonCallbackResult<T> Evaluate(const JsonType* json_entry, JsonPathEvaluateCallback<T> cb,
-                                 bool legacy_mode_is_enabled) const {
-    JsonCallbackResult<T> eval_result{legacy_mode_is_enabled};
+                                 bool save_first_result, bool legacy_mode_is_enabled) const {
+    JsonCallbackResult<T> eval_result{legacy_mode_is_enabled, save_first_result};
 
     auto eval_callback = [&cb, &eval_result](std::string_view path, const JsonType& val) {
       eval_result.AddValue(cb(path, val));
@@ -172,10 +165,10 @@ class WrappedJsonPath {
     auto mutate_callback = [&cb, &mutate_result](std::optional<std::string_view> path,
                                                  JsonType* val) -> bool {
       auto res = cb(path, val);
-      if (res.HasValue()) {
-        mutate_result.AddValue(std::move(res).GetValue());
+      if (res.value.has_value()) {
+        mutate_result.AddValue(std::move(res.value).value());
       }
-      return res.ShouldBeDeleted();
+      return res.should_be_deleted;
     };
 
     if (HoldsJsonPath()) {
@@ -217,7 +210,11 @@ class WrappedJsonPath {
     return is_legacy_mode_path_;
   }
 
- private:
+  bool RefersToRootElement() const {
+    auto path = path_.view();
+    return path.empty() || path == kV1PathRootElement || path == kV2PathRootElement;
+  }
+
   bool HoldsJsonPath() const {
     return std::holds_alternative<json::Path>(parsed_path_);
   }
diff --git a/src/server/error.h b/src/server/error.h
index 157c1f68926f..c5fe49cbfcca 100644
--- a/src/server/error.h
+++ b/src/server/error.h
@@ -44,17 +44,6 @@ using facade::kWrongTypeErr;
 
 #endif  // RETURN_ON_BAD_STATUS
 
-#ifndef RETURN_UNEXPECTED
-
-#define RETURN_UNEXPECTED(x)       \
-  do {                             \
-    if (!(x)) {                    \
-      return (x).get_unexpected(); \
-    }                              \
-  } while (0)
-
-#endif  // RETURN_UNEXPECTED
-
 #ifndef GET_OR_SEND_UNEXPECTED
 
 #define GET_OR_SEND_UNEXPECTED(expr)     \
diff --git a/src/server/json_family.cc b/src/server/json_family.cc
index 4393811b2723..f96085fccfe3 100644
--- a/src/server/json_family.cc
+++ b/src/server/json_family.cc
@@ -42,23 +42,15 @@ namespace dfly {
 
 using namespace std;
 using namespace jsoncons;
+using facade::CmdArgParser;
 using facade::kSyntaxErrType;
-using facade::WrongNumArgsError;
 
 using JsonExpression = jsonpath::jsonpath_expression<JsonType>;
-using OptBool = optional<bool>;
-using OptLong = optional<long>;
-using OptSizeT = optional<size_t>;
-using OptString = optional<string>;
 using JsonReplaceVerify = std::function<void(JsonType&)>;
 using CI = CommandId;
 
-static const char DefaultJsonPath[] = "$";
-
 namespace {
 
-namespace json_parser {
-
 template <typename T> using ParseResult = io::Result<T, std::string>;
 
 ParseResult<JsonExpression> ParseJsonPathAsExpression(std::string_view path) {
@@ -72,17 +64,23 @@ ParseResult<JsonExpression> ParseJsonPathAsExpression(std::string_view path) {
 ParseResult<WrappedJsonPath> ParseJsonPath(StringOrView path, bool is_legacy_mode_path) {
   if (absl::GetFlag(FLAGS_jsonpathv2)) {
     auto path_result = json::ParsePath(path.view());
-    RETURN_UNEXPECTED(path_result);
+    if (!path_result) {
+      VLOG(1) << "Invalid Json path: " << path << ' ' << path_result.error() << std::endl;
+      return nonstd::make_unexpected(kSyntaxErr);
+    }
     return WrappedJsonPath{std::move(path_result).value(), std::move(path), is_legacy_mode_path};
   }
 
   auto expr_result = ParseJsonPathAsExpression(path.view());
-  RETURN_UNEXPECTED(expr_result);
+  if (!expr_result) {
+    VLOG(1) << "Invalid Json path: " << path << ' ' << expr_result.error() << std::endl;
+    return nonstd::make_unexpected(kSyntaxErr);
+  }
   return WrappedJsonPath{std::move(expr_result).value(), std::move(path), is_legacy_mode_path};
 }
 
 ParseResult<WrappedJsonPath> ParseJsonPathV1(std::string_view path) {
-  if (path == WrappedJsonPath::kV1PathRootElement) {
+  if (path.empty() || path == WrappedJsonPath::kV1PathRootElement) {
     return ParseJsonPath(StringOrView::FromView(WrappedJsonPath::kV2PathRootElement), true);
   }
 
@@ -97,22 +95,67 @@ ParseResult<WrappedJsonPath> ParseJsonPathV2(std::string_view path) {
 }
 
 bool IsJsonPathV2(std::string_view path) {
-  return path.front() == '$';
+  return !path.empty() && path.front() == '$';
 }
 
 ParseResult<WrappedJsonPath> ParseJsonPath(std::string_view path) {
-  DCHECK(!path.empty());
   return IsJsonPathV2(path) ? ParseJsonPathV2(path) : ParseJsonPathV1(path);
 }
 
-}  // namespace json_parser
-
 namespace reply_generic {
 
-void Send(std::size_t value, RedisReplyBuilder* rb) {
+template <typename T> void Send(const std::optional<T>& opt, RedisReplyBuilder* rb);
+template <typename T> void Send(const std::vector<T>& vec, RedisReplyBuilder* rb);
+template <> void Send(const std::vector<std::string>& vec, RedisReplyBuilder* rb);
+
+void Send(bool value, RedisReplyBuilder* rb) {
+  rb->SendBulkString(value ? "true"sv : "false"sv);
+}
+
+void Send(long value, RedisReplyBuilder* rb) {
+  rb->SendLong(value);
+}
+
+void Send(size_t value, RedisReplyBuilder* rb) {
   rb->SendLong(value);
 }
 
+void Send(double value, RedisReplyBuilder* rb) {
+  rb->SendDouble(value);
+}
+
+void Send(const std::string& value, RedisReplyBuilder* rb) {
+  rb->SendBulkString(value);
+}
+
+void Send(const JsonType& value, RedisReplyBuilder* rb) {
+  if (value.is_double()) {
+    Send(value.as_double(), rb);
+  } else if (value.is_number()) {
+    Send(value.as_integer<long>(), rb);
+  } else if (value.is_bool()) {
+    rb->SendSimpleString(value.as_bool() ? "true" : "false");
+  } else if (value.is_null()) {
+    rb->SendNull();
+  } else if (value.is_string()) {
+    rb->SendBulkString(value.as_string_view());
+  } else if (value.is_object()) {
+    rb->StartArray(value.size() + 1);
+    rb->SendSimpleString("{");
+    for (const auto& item : value.object_range()) {
+      rb->StartArray(2);
+      rb->SendBulkString(item.key());
+      Send(item.value(), rb);
+    }
+  } else if (value.is_array()) {
+    rb->StartArray(value.size() + 1);
+    rb->SendSimpleString("[");
+    for (const auto& item : value.array_range()) {
+      Send(item, rb);
+    }
+  }
+}
+
 template <typename T> void Send(const std::optional<T>& opt, RedisReplyBuilder* rb) {
   if (opt.has_value()) {
     Send(opt.value(), rb);
@@ -123,7 +166,7 @@ template <typename T> void Send(const std::optional<T>& opt, RedisReplyBuilder*
 
 template <typename T> void Send(const std::vector<T>& vec, RedisReplyBuilder* rb) {
   if (vec.empty()) {
-    rb->SendNullArray();
+    rb->SendEmptyArray();
   } else {
     rb->StartArray(vec.size());
     for (auto&& x : vec) {
@@ -132,6 +175,14 @@ template <typename T> void Send(const std::vector<T>& vec, RedisReplyBuilder* rb
   }
 }
 
+template <> void Send(const std::vector<std::string>& vec, RedisReplyBuilder* rb) {
+  if (vec.empty()) {
+    rb->SendEmptyArray();
+  } else {
+    rb->SendStringArr(vec);
+  }
+}
+
 template <typename T> void Send(const JsonCallbackResult<T>& result, RedisReplyBuilder* rb) {
   if (result.IsV1()) {
     /* The specified path was restricted (JSON legacy mode), then the result consists only of a
@@ -154,30 +205,6 @@ template <typename T> void Send(const OpResult<T>& result, RedisReplyBuilder* rb
 
 }  // namespace reply_generic
 
-using JsonPathV2 = variant<json::Path, JsonExpression>;
-using ExprCallback = absl::FunctionRef<void(string_view, const JsonType&)>;
-
-inline void Evaluate(const JsonExpression& expr, const JsonType& obj, ExprCallback cb) {
-  expr.evaluate(obj, cb);
-}
-
-inline void Evaluate(const json::Path& expr, const JsonType& obj, ExprCallback cb) {
-  json::EvaluatePath(expr, obj, [&cb](optional<string_view> key, const JsonType& val) {
-    cb(key ? *key : string_view{}, val);
-  });
-}
-
-inline JsonType Evaluate(const JsonExpression& expr, const JsonType& obj) {
-  return expr.evaluate(obj);
-}
-
-inline JsonType Evaluate(const json::Path& expr, const JsonType& obj) {
-  JsonType res(json_array_arg);
-  json::EvaluatePath(expr, obj,
-                     [&res](optional<string_view>, const JsonType& val) { res.push_back(val); });
-  return res;
-}
-
 facade::OpStatus SetJson(const OpArgs& op_args, string_view key, JsonType&& value) {
   auto& db_slice = op_args.GetDbSlice();
 
@@ -227,149 +254,6 @@ inline std::optional<JsonType> JsonFromString(std::string_view input) {
   return dfly::JsonFromString(input, CompactObj::memory_resource());
 }
 
-io::Result<JsonExpression> ParseJsonPath(string_view path) {
-  if (path == ".") {
-    // RedisJson V1 uses the dot for root level access.
-    // There are more incompatibilities with legacy paths which are not supported.
-    path = "$"sv;
-  }
-  std::error_code ec;
-  JsonExpression res = MakeJsonPathExpr(path, ec);
-  if (ec)
-    return nonstd::make_unexpected(ec);
-  return res;
-}
-
-template <typename T>
-void PrintOptVec(ConnectionContext* cntx, const OpResult<vector<optional<T>>>& result) {
-  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-  if (result->empty()) {
-    rb->SendNullArray();
-  } else {
-    rb->StartArray(result->size());
-    for (auto& it : *result) {
-      if (it.has_value()) {
-        if constexpr (is_floating_point_v<T>) {
-          rb->SendDouble(*it);
-        } else {
-          static_assert(is_integral_v<T>, "Integral required.");
-          rb->SendLong(*it);
-        }
-      } else {
-        rb->SendNull();
-      }
-    }
-  }
-}
-
-error_code JsonReplace(JsonType& instance, string_view path, json::MutateCallback callback) {
-  using evaluator_t = jsonpath::detail::jsonpath_evaluator<JsonType, JsonType&>;
-  using value_type = evaluator_t::value_type;
-  using reference = evaluator_t::reference;
-  using json_selector_t = evaluator_t::path_expression_type;
-
-  jsonpath::custom_functions<JsonType> funcs = jsonpath::custom_functions<JsonType>();
-
-  error_code ec;
-  jsonpath::detail::static_resources<value_type, reference> static_resources(funcs);
-  evaluator_t e;
-  json_selector_t expr = e.compile(static_resources, path, ec);
-  if (ec) {
-    return ec;
-  }
-
-  jsonpath::detail::dynamic_resources<value_type, reference> resources;
-
-  auto f = [&callback](const jsonpath::basic_path_node<char>& path, JsonType& val) {
-    callback(jsonpath::to_string(path), &val);
-  };
-
-  expr.evaluate(resources, instance, json_selector_t::path_node_type{}, instance, f,
-                jsonpath::result_options::nodups | jsonpath::result_options::path);
-  return ec;
-}
-
-template <typename T>
-OpResult<JsonCallbackResult<T>> UpdateEntry(const OpArgs& op_args, std::string_view key,
-                                            const WrappedJsonPath& json_path,
-                                            JsonPathMutateCallback<T> cb,
-                                            JsonReplaceVerify verify_op = {}) {
-  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);
-  RETURN_ON_BAD_STATUS(it_res);
-
-  PrimeValue& pv = it_res->it->second;
-
-  JsonType* json_val = pv.GetJson();
-  DCHECK(json_val) << "should have a valid JSON object for key '" << key << "' the type for it is '"
-                   << pv.ObjType() << "'";
-
-  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, pv);
-
-  auto mutate_res = json_path.Mutate(json_val, cb);
-
-  // Make sure that we don't have other internal issue with the operation
-  if (mutate_res && verify_op) {
-    verify_op(*json_val);
-  }
-
-  it_res->post_updater.Run();
-  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, pv);
-
-  return mutate_res;
-}
-
-// jsoncons version
-OpStatus UpdateEntry(const OpArgs& op_args, std::string_view key, std::string_view path,
-                     json::MutateCallback callback, JsonReplaceVerify verify_op = {}) {
-  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);
-  if (!it_res.ok()) {
-    return it_res.status();
-  }
-
-  auto entry_it = it_res->it;
-  JsonType* json_val = entry_it->second.GetJson();
-  DCHECK(json_val) << "should have a valid JSON object for key '" << key << "' the type for it is '"
-                   << entry_it->second.ObjType() << "'";
-  JsonType& json_entry = *json_val;
-
-  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, entry_it->second);
-
-  // Run the update operation on this entry
-  error_code ec = JsonReplace(json_entry, path, callback);
-  if (ec) {
-    VLOG(1) << "Failed to evaluate expression on json with error: " << ec.message();
-    return OpStatus::SYNTAX_ERR;
-  }
-
-  // Make sure that we don't have other internal issue with the operation
-  if (verify_op) {
-    verify_op(json_entry);
-  }
-
-  it_res->post_updater.Run();
-  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, entry_it->second);
-
-  return OpStatus::OK;
-}
-
-// json::Path version.
-OpStatus UpdateEntry(const OpArgs& op_args, string_view key, const json::Path& path,
-                     json::MutateCallback cb) {
-  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);
-  if (!it_res.ok()) {
-    return it_res.status();
-  }
-
-  PrimeValue& pv = it_res->it->second;
-
-  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, pv);
-  json::MutatePath(path, std::move(cb), pv.GetJson());
-  it_res->post_updater.Run();
-  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, pv);
-
-  return OpStatus::OK;
-}
-
 OpResult<JsonType*> GetJson(const OpArgs& op_args, string_view key) {
   auto it_res = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key, OBJ_JSON);
   if (!it_res.ok())
@@ -554,32 +438,70 @@ size_t CountJsonFields(const JsonType& j) {
   return res;
 }
 
-void SendJsonValue(RedisReplyBuilder* rb, const JsonType& j) {
-  if (j.is_double()) {
-    rb->SendDouble(j.as_double());
-  } else if (j.is_number()) {
-    rb->SendLong(j.as_integer<long>());
-  } else if (j.is_bool()) {
-    rb->SendSimpleString(j.as_bool() ? "true" : "false");
-  } else if (j.is_null()) {
-    rb->SendNull();
-  } else if (j.is_string()) {
-    rb->SendBulkString(j.as_string_view());
-  } else if (j.is_object()) {
-    rb->StartArray(j.size() + 1);
-    rb->SendSimpleString("{");
-    for (const auto& item : j.object_range()) {
-      rb->StartArray(2);
-      rb->SendBulkString(item.key());
-      SendJsonValue(rb, item.value());
-    }
-  } else if (j.is_array()) {
-    rb->StartArray(j.size() + 1);
-    rb->SendSimpleString("[");
-    for (const auto& item : j.array_range()) {
-      SendJsonValue(rb, item);
+template <typename T> struct is_optional : std::false_type {};
+
+template <typename T> struct is_optional<std::optional<T>> : std::true_type {};
+
+template <typename T>
+OpResult<JsonCallbackResult<T>> ReturnWrongTypeOnNullOpt(JsonCallbackResult<T> result) {
+  if constexpr (is_optional<T>::value) {
+    if (result.IsV1()) {
+      auto& as_v1 = result.AsV1();
+      if (!as_v1 || !as_v1.value()) {
+        return OpStatus::WRONG_JSON_TYPE;
+      }
     }
   }
+  return result;
+}
+
+struct EvaluateOperationOptions {
+  bool save_first_result = false;
+  bool return_empty_result_if_key_not_found = false;
+};
+
+template <typename T>
+OpResult<JsonCallbackResult<T>> JsonEvaluateOperation(const OpArgs& op_args, std::string_view key,
+                                                      const WrappedJsonPath& json_path,
+                                                      JsonPathEvaluateCallback<T> cb,
+                                                      EvaluateOperationOptions options = {}) {
+  OpResult<JsonType*> result = GetJson(op_args, key);
+  if (options.return_empty_result_if_key_not_found && result == OpStatus::KEY_NOTFOUND) {
+    return JsonCallbackResult<T>{};
+  }
+  RETURN_ON_BAD_STATUS(result);
+  return ReturnWrongTypeOnNullOpt(
+      json_path.Evaluate<T>(result.value(), cb, options.save_first_result));
+}
+
+template <typename T>
+OpResult<JsonCallbackResult<T>> UpdateEntry(const OpArgs& op_args, std::string_view key,
+                                            const WrappedJsonPath& json_path,
+                                            JsonPathMutateCallback<T> cb,
+                                            JsonReplaceVerify verify_op = {}) {
+  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);
+  RETURN_ON_BAD_STATUS(it_res);
+
+  PrimeValue& pv = it_res->it->second;
+
+  JsonType* json_val = pv.GetJson();
+  DCHECK(json_val) << "should have a valid JSON object for key '" << key << "' the type for it is '"
+                   << pv.ObjType() << "'";
+
+  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, pv);
+
+  auto mutate_res = json_path.Mutate(json_val, cb);
+
+  // Make sure that we don't have other internal issue with the operation
+  if (mutate_res && verify_op) {
+    verify_op(*json_val);
+  }
+
+  it_res->post_updater.Run();
+  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, pv);
+
+  RETURN_ON_BAD_STATUS(mutate_res);
+  return ReturnWrongTypeOnNullOpt(*std::move(mutate_res));
 }
 
 bool LegacyModeIsEnabled(const std::vector<std::pair<std::string_view, WrappedJsonPath>>& paths) {
@@ -597,7 +519,7 @@ OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,
 
   const JsonType& json_entry = *(result.value());
   if (paths.empty()) {
-    // this implicitly means that we're using $ which
+    // this implicitly means that we're using . which
     // means we just brings all values
     return json_entry.to_string();
   }
@@ -628,7 +550,7 @@ OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,
 
   auto eval_wrapped = [&json_entry, &cb, legacy_mode_is_enabled](
                           const WrappedJsonPath& json_path) -> std::optional<JsonType> {
-    auto eval_result = json_path.Evaluate<JsonType>(&json_entry, cb, legacy_mode_is_enabled);
+    auto eval_result = json_path.Evaluate<JsonType>(&json_entry, cb, false, legacy_mode_is_enabled);
 
     DCHECK(legacy_mode_is_enabled == eval_result.IsV1());
 
@@ -657,106 +579,78 @@ OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,
   return ss.str();
 }
 
-OpResult<vector<string>> OpType(const OpArgs& op_args, string_view key, JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  const JsonType& json_entry = *(result.value());
-  vector<string> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) {
-    vec.emplace_back(JsonTypeToName(val));
+auto OpType(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view&, const JsonType& val) -> std::string {
+    return JsonTypeToName(val);
   };
-
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+  return JsonEvaluateOperation<std::string>(op_args, key, json_path, std::move(cb), {false, true});
 }
 
-OpResult<vector<OptSizeT>> OpStrLen(const OpArgs& op_args, string_view key, JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-  const JsonType& json_entry = *(result.value());
-  vector<OptSizeT> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) {
+OpResult<JsonCallbackResult<std::optional<size_t>>> OpStrLen(const OpArgs& op_args, string_view key,
+                                                             const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {
     if (val.is_string()) {
-      vec.emplace_back(val.as_string_view().size());
+      return val.as_string_view().size();
     } else {
-      vec.emplace_back(nullopt);
+      return std::nullopt;
     }
   };
 
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb),
+                                                           {true, true});
 }
 
-OpResult<vector<OptSizeT>> OpObjLen(const OpArgs& op_args, string_view key, JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  const JsonType& json_entry = *(result.value());
-  vector<OptSizeT> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) {
+OpResult<JsonCallbackResult<std::optional<size_t>>> OpObjLen(const OpArgs& op_args, string_view key,
+                                                             const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {
     if (val.is_object()) {
-      vec.emplace_back(val.size());
+      return val.size();
     } else {
-      vec.emplace_back(nullopt);
+      return std::nullopt;
     }
   };
 
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb),
+                                                           {true, true});
 }
 
-OpResult<vector<OptSizeT>> OpArrLen(const OpArgs& op_args, string_view key, JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  const JsonType& json_entry = *(result.value());
-  vector<OptSizeT> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) {
+OpResult<JsonCallbackResult<std::optional<size_t>>> OpArrLen(const OpArgs& op_args, string_view key,
+                                                             const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {
     if (val.is_array()) {
-      vec.emplace_back(val.size());
+      return val.size();
     } else {
-      vec.emplace_back(nullopt);
+      return std::nullopt;
     }
   };
-
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb),
+                                                           {true, true});
 }
 
-OpResult<vector<OptBool>> OpToggle(const OpArgs& op_args, string_view key, string_view path,
-                                   JsonPathV2 expression) {
-  vector<OptBool> vec;
-  OpStatus status;
-  auto cb = [&vec](optional<string_view>, JsonType* val) {
+template <typename T>
+auto OpToggle(const OpArgs& op_args, string_view key,
+              const WrappedJsonPath& json_path) {  // TODO(change the output type for enhanced path)
+  auto cb = [](std::optional<std::string_view>,
+               JsonType* val) -> MutateCallbackResult<std::optional<T>> {
     if (val->is_bool()) {
       bool next_val = val->as_bool() ^ true;
       *val = next_val;
-      vec.emplace_back(next_val);
-    } else {
-      vec.emplace_back(nullopt);
+      return {false, next_val};
     }
-    return false;
+    return {false, std::nullopt};
   };
+  return UpdateEntry<std::optional<T>>(op_args, key, json_path, std::move(cb));
+}
 
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& expr = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, expr, cb);
-  } else {
-    status = UpdateEntry(op_args, key, path, cb);
-  }
-  if (status != OpStatus::OK) {
-    return status;
-  }
-  return vec;
+template <typename T>
+auto ExecuteToggle(string_view key, const WrappedJsonPath& json_path, ConnectionContext* cntx) {
+  auto cb = [&](Transaction* t, EngineShard* shard) {
+    return OpToggle<T>(t->GetOpArgs(shard), key, json_path);
+  };
+
+  auto result = cntx->transaction->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 enum ArithmeticOpType { OP_ADD, OP_MULTIPLY };
@@ -786,95 +680,115 @@ void BinOpApply(double num, bool num_is_double, ArithmeticOpType op, JsonType* v
   *overflow = false;
 }
 
-OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key, string_view path,
-                                    double num, ArithmeticOpType op_type, JsonPathV2 expression) {
+OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key,
+                                    const WrappedJsonPath& json_path, double num,
+                                    ArithmeticOpType op_type) {
   bool is_result_overflow = false;
   double int_part;
   bool has_fractional_part = (modf(num, &int_part) != 0);
-  JsonType output(json_array_arg);
-  OpStatus status;
 
-  auto cb = [&](optional<string_view>, JsonType* val) {
+  // Tmp solution with struct CallbackResult, because MutateCallbackResult<std::optional<JsonType>>
+  // does not compile
+  struct CallbackResult {
+    explicit CallbackResult(bool legacy_mode_is_enabled_)
+        : legacy_mode_is_enabled(legacy_mode_is_enabled_) {
+      if (!legacy_mode_is_enabled) {
+        json_value.emplace(jsoncons::json_array_arg);
+      }
+    }
+
+    void AddValue(JsonType val) {
+      if (legacy_mode_is_enabled) {
+        json_value = std::move(val);
+      } else {
+        json_value->emplace_back(std::move(val));
+      }
+    }
+
+    void AddEmptyValue() {
+      if (!legacy_mode_is_enabled) {
+        json_value->emplace_back(JsonType::null());
+      }
+    }
+
+    std::optional<JsonType> json_value;
+    bool legacy_mode_is_enabled;
+  };
+
+  CallbackResult result{json_path.IsLegacyModePath()};
+  auto cb = [&](std::optional<std::string_view>, JsonType* val) -> MutateCallbackResult<> {
     if (val->is_number()) {
       bool res = false;
       BinOpApply(num, has_fractional_part, op_type, val, &res);
       if (res) {
         is_result_overflow = true;
       } else {
-        output.push_back(*val);
+        result.AddValue(*val);
+        return {};
       }
-    } else {
-      output.push_back(JsonType::null());
     }
-    return false;
+    result.AddEmptyValue();
+    return {};
   };
 
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& path = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, path, std::move(cb));
-  } else {
-    status = UpdateEntry(op_args, key, path, std::move(cb));
-  }
+  auto res = UpdateEntry<Nothing>(op_args, key, json_path, std::move(cb));
 
   if (is_result_overflow)
     return OpStatus::INVALID_NUMERIC_RESULT;
-  if (status != OpStatus::OK) {
-    return status;
-  }
 
-  return output.as_string();
+  RETURN_ON_BAD_STATUS(res);
+
+  if (!result.json_value) {
+    return OpStatus::WRONG_JSON_TYPE;
+  }
+  return result.json_value->as_string();
 }
 
-// If expression is nullopt, then the whole key should be deleted, otherwise deletes
-// items specified by the expression/path.
+// Deletes items specified by the expression/path.
 OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,
-                     optional<JsonPathV2> expression) {
-  if (!expression || path.empty()) {
+                     const WrappedJsonPath& json_path) {
+  if (json_path.RefersToRootElement()) {
     auto& db_slice = op_args.GetDbSlice();
     auto it = db_slice.FindMutable(op_args.db_cntx, key).it;  // post_updater will run immediately
-    return long(db_slice.Del(op_args.db_cntx, it));
+    return static_cast<long>(db_slice.Del(op_args.db_cntx, it));
   }
-
   OpResult<JsonType*> result = GetJson(op_args, key);
   if (!result) {
     return 0;
   }
 
-  if (holds_alternative<json::Path>(*expression)) {
-    const json::Path& path = get<json::Path>(*expression);
+  if (json_path.HoldsJsonPath()) {
+    const json::Path& path = json_path.AsJsonPath();
     long deletions = json::MutatePath(
         path, [](optional<string_view>, JsonType* val) { return true; }, *result);
     return deletions;
   }
 
   vector<string> deletion_items;
-  auto cb = [&](const auto& path, JsonType* val) {
+  auto cb = [&](std::optional<std::string_view> path, JsonType* val) -> MutateCallbackResult<> {
     deletion_items.emplace_back(*path);
-    return false;
+    return {};
   };
 
-  JsonType& json_entry = *(result.value());
-  error_code ec = JsonReplace(json_entry, path, std::move(cb));
-  if (ec) {
-    VLOG(1) << "Failed to evaluate expression on json with error: " << ec.message();
-    return 0;
-  }
+  auto res = json_path.Mutate<Nothing>(result.value(), std::move(cb));
+  RETURN_ON_BAD_STATUS(res);
 
   if (deletion_items.empty()) {
     return 0;
   }
 
   long total_deletions = 0;
-  JsonType patch(json_array_arg, {});
+  JsonType patch(jsoncons::json_array_arg, {});
   reverse(deletion_items.begin(), deletion_items.end());  // deletion should finish at root keys.
   for (const auto& item : deletion_items) {
     string pointer = ConvertToJsonPointer(item);
     total_deletions++;
-    JsonType patch_item(json_object_arg, {{"op", "remove"}, {"path", pointer}});
+    JsonType patch_item(jsoncons::json_object_arg, {{"op", "remove"}, {"path", pointer}});
     patch.emplace_back(patch_item);
   }
 
-  jsonpatch::apply_patch(json_entry, patch, ec);
+  std::error_code ec;
+  jsoncons::jsonpatch::apply_patch(*result.value(), patch, ec);
   if (ec) {
     VLOG(1) << "Failed to apply patch on json with error: " << ec.message();
     return 0;
@@ -886,37 +800,26 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,
 
 // Returns a vector of string vectors,
 // keys within the same object are stored in the same string vector.
-OpResult<vector<StringVec>> OpObjKeys(const OpArgs& op_args, string_view key,
-                                      JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  vector<StringVec> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) {
+auto OpObjKeys(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view& path, const JsonType& val) {
     // Aligned with ElastiCache flavor.
     DVLOG(2) << "path: " << path << " val: " << val.to_string();
 
-    if (!val.is_object()) {
-      vec.emplace_back();
-      return;
-    }
-
-    auto& current_object = vec.emplace_back();
-    for (const auto& member : val.object_range()) {
-      current_object.emplace_back(member.key());
+    StringVec vec;
+    if (val.is_object()) {
+      for (const auto& member : val.object_range()) {
+        vec.emplace_back(member.key());
+      }
     }
+    return vec;
   };
-  JsonType& json_entry = *(result.value());
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-
-  return vec;
+  return JsonEvaluateOperation<StringVec>(op_args, key, json_path, std::move(cb), {true, true});
 }
 
 auto OpStrAppend(const OpArgs& op_args, string_view key, const WrappedJsonPath& path,
                  facade::ArgRange strs) {
-  auto cb = [&](const auto&, JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {
+  auto cb = [&](std::optional<std::string_view>,
+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {
     if (val->is_string()) {
       string new_val = val->as_string();
       for (string_view str : strs) {
@@ -935,13 +838,13 @@ auto OpStrAppend(const OpArgs& op_args, string_view key, const WrappedJsonPath&
 
 // Returns the numbers of values cleared.
 // Clears containers(arrays or objects) and zeroing numbers.
-OpResult<long> OpClear(const OpArgs& op_args, string_view key, string_view path,
-                       JsonPathV2 expression) {
+OpResult<long> OpClear(const OpArgs& op_args, string_view key, const WrappedJsonPath& path) {
   long clear_items = 0;
-  OpStatus status;
-  auto cb = [&clear_items](const auto& path, JsonType* val) {
+
+  auto cb = [&clear_items](std::optional<std::string_view>,
+                           JsonType* val) -> MutateCallbackResult<> {
     if (!(val->is_object() || val->is_array() || val->is_number())) {
-      return false;
+      return {};
     }
 
     if (val->is_object()) {
@@ -953,92 +856,61 @@ OpResult<long> OpClear(const OpArgs& op_args, string_view key, string_view path,
     }
 
     clear_items += 1;
-    return false;
+    return {};
   };
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& json_path = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, json_path, cb);
-  } else {
-    status = UpdateEntry(op_args, key, path, cb);
-  }
-  if (status != OpStatus::OK) {
-    return status;
-  }
+
+  auto res = UpdateEntry<Nothing>(op_args, key, path, std::move(cb));
+  RETURN_ON_BAD_STATUS(res);
   return clear_items;
 }
 
-void ArrayPop(std::optional<std::string_view>, int index, JsonType* val,
-              vector<OptString>* result) {
-  if (!val->is_array() || val->empty()) {
-    result->emplace_back(nullopt);
-    return;
-  }
-
-  size_t removal_index;
-  if (index < 0) {
-    int temp_index = index + val->size();
-    removal_index = abs(temp_index);
-  } else {
-    removal_index = index;
-  }
+// Returns string vector that represents the pop out values.
+auto OpArrPop(const OpArgs& op_args, string_view key, WrappedJsonPath& path, int index) {
+  auto cb = [index](std::optional<std::string_view>,
+                    JsonType* val) -> MutateCallbackResult<std::optional<std::string>> {
+    if (!val->is_array() || val->empty()) {
+      return {false, std::nullopt};
+    }
 
-  if (removal_index >= val->size()) {
-    removal_index %= val->size();  // rounded to the array boundaries.
-  }
+    size_t removal_index;
+    if (index < 0) {
+      int temp_index = index + val->size();
+      removal_index = abs(temp_index);
+    } else {
+      removal_index = index;
+    }
 
-  auto it = val->array_range().begin() + removal_index;
-  string str;
-  error_code ec;
-  it->dump(str, {}, ec);
-  if (ec) {
-    LOG(ERROR) << "Failed to dump JSON to string with the error: " << ec.message();
-    result->emplace_back(nullopt);
-    return;
-  }
+    if (removal_index >= val->size()) {
+      removal_index %= val->size();  // rounded to the array boundaries.
+    }
 
-  result->push_back(std::move(str));
-  val->erase(it);
-  return;
-};
+    auto it = val->array_range().begin() + removal_index;
+    string str;
+    error_code ec;
+    it->dump(str, {}, ec);
+    if (ec) {
+      LOG(ERROR) << "Failed to dump JSON to string with the error: " << ec.message();
+      return {};
+    }
 
-// Returns string vector that represents the pop out values.
-OpResult<vector<OptString>> OpArrPop(const OpArgs& op_args, string_view key, string_view path,
-                                     int index, JsonPathV2 expression) {
-  vector<OptString> vec;
-  OpStatus status;
-  auto cb = [&vec, index](optional<string_view>, JsonType* val) {
-    ArrayPop(nullopt, index, val, &vec);
-    return false;
+    val->erase(it);
+    return {false, std::move(str)};
   };
-
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& json_path = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, json_path, std::move(cb));
-  } else {
-    status = UpdateEntry(op_args, key, path, cb);
-  }
-  if (status != OpStatus::OK) {
-    return status;
-  }
-  return vec;
+  return UpdateEntry<std::optional<std::string>>(op_args, key, path, std::move(cb));
 }
 
 // Returns numeric vector that represents the new length of the array at each path.
-OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, string_view path,
-                                     JsonPathV2 expression, int start_index, int stop_index) {
-  vector<OptSizeT> vec;
-  OpStatus status;
-  auto cb = [&](const auto&, JsonType* val) {
+auto OpArrTrim(const OpArgs& op_args, string_view key, const WrappedJsonPath& path, int start_index,
+               int stop_index) {
+  auto cb = [&](std::optional<std::string_view>,
+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {
     if (!val->is_array()) {
-      vec.emplace_back(nullopt);
-      return false;
+      return {false, std::nullopt};
     }
 
     if (val->empty()) {
-      vec.emplace_back(0);
-      return false;
+      return {false, 0};
     }
-
     size_t trim_start_index;
     if (start_index < 0) {
       trim_start_index = 0;
@@ -1055,8 +927,7 @@ OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, str
 
     if (trim_start_index >= val->size() || trim_start_index > trim_end_index) {
       val->erase(val->array_range().begin(), val->array_range().end());
-      vec.emplace_back(0);
-      return false;
+      return {false, 0};
     }
 
     auto trim_start_it = std::next(val->array_range().begin(), trim_start_index);
@@ -1065,62 +936,49 @@ OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, str
       trim_end_it = std::next(val->array_range().begin(), trim_end_index + 1);
     }
 
-    *val = json_array<JsonType>(trim_start_it, trim_end_it);
-    vec.emplace_back(val->size());
-    return false;
+    *val = jsoncons::json_array<JsonType>(trim_start_it, trim_end_it);
+    return {false, val->size()};
   };
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& json_path = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, json_path, cb);
-  } else {
-    status = UpdateEntry(op_args, key, path, cb);
-  }
-
-  if (status != OpStatus::OK) {
-    return status;
-  }
-  return vec;
+  return UpdateEntry<std::optional<std::size_t>>(op_args, key, path, std::move(cb));
 }
 
 // Returns numeric vector that represents the new length of the array at each path.
-OpResult<vector<OptSizeT>> OpArrInsert(const OpArgs& op_args, string_view key, string_view path,
-                                       JsonPathV2 expression, int index,
-                                       const vector<JsonType>& new_values) {
+OpResult<JsonCallbackResult<std::optional<std::size_t>>> OpArrInsert(
+    const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path, int index,
+    const vector<JsonType>& new_values) {
   bool out_of_boundaries_encountered = false;
-  vector<OptSizeT> vec;
-  OpStatus status;
 
   // Insert user-supplied value into the supplied index that should be valid.
   // If at least one index isn't valid within an array in the json doc, the operation is discarded.
   // Negative indexes start from the end of the array.
-  auto cb = [&](const auto&, JsonType* val) {
+  auto cb = [&](std::optional<std::string_view>,
+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {
     if (out_of_boundaries_encountered) {
-      return false;
+      return {};
     }
 
     if (!val->is_array()) {
-      vec.emplace_back(nullopt);
-      return false;
+      return {false, std::nullopt};
     }
 
     size_t removal_index;
     if (index < 0) {
       if (val->empty()) {
         out_of_boundaries_encountered = true;
-        return false;
+        return {false, std::nullopt};
       }
 
       int temp_index = index + val->size();
       if (temp_index < 0) {
         out_of_boundaries_encountered = true;
-        return false;
+        return {};
       }
 
       removal_index = temp_index;
     } else {
       if ((size_t)index > val->size()) {
         out_of_boundaries_encountered = true;
-        return false;
+        return {};
       }
 
       removal_index = index;
@@ -1131,87 +989,43 @@ OpResult<vector<OptSizeT>> OpArrInsert(const OpArgs& op_args, string_view key, s
       it = val->insert(it, new_val);
       it++;
     }
-
-    vec.emplace_back(val->size());
-    return false;
+    return {false, val->size()};
   };
-
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& json_path = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, json_path, cb);
-  } else {
-    status = UpdateEntry(op_args, key, path, cb);
-  }
-
-  if (status != OpStatus::OK) {
-    return status;
-  }
-
-  if (out_of_boundaries_encountered) {
-    return OpStatus::OUT_OF_RANGE;
-  }
-
-  return vec;
-}
-
-// Returns numeric vector that represents the new length of the array at each path, or Null reply
-// if the matching JSON value is not an array.
-OpResult<vector<OptSizeT>> OpArrAppend(const OpArgs& op_args, string_view key, string_view path,
-                                       JsonPathV2 expression,
-                                       const vector<JsonType>& append_values) {
-  vector<OptSizeT> vec;
-  OpStatus status;
-
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
+
+  auto res = UpdateEntry<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb));
+  if (out_of_boundaries_encountered) {
+    return OpStatus::OUT_OF_RANGE;
   }
+  return res;
+}
 
-  auto cb = [&](const auto&, JsonType* val) {
+auto OpArrAppend(const OpArgs& op_args, string_view key, const WrappedJsonPath& path,
+                 const vector<JsonType>& append_values) {
+  auto cb = [&](std::optional<std::string_view>,
+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {
     if (!val->is_array()) {
-      vec.emplace_back(nullopt);
-      return false;
+      return {false, std::nullopt};
     }
     for (auto& new_val : append_values) {
       val->emplace_back(new_val);
     }
-    vec.emplace_back(val->size());
-    return false;
+    return {false, val->size()};
   };
-
-  if (holds_alternative<json::Path>(expression)) {
-    const json::Path& json_path = std::get<json::Path>(expression);
-    status = UpdateEntry(op_args, key, json_path, cb);
-  } else {
-    status = UpdateEntry(op_args, key, path, cb);
-  }
-  if (status != OpStatus::OK) {
-    return status;
-  }
-
-  return vec;
+  return UpdateEntry<std::optional<std::size_t>>(op_args, key, path, std::move(cb));
 }
 
 // Returns a numeric vector representing each JSON value first index of the JSON scalar.
 // An index value of -1 represents unfound in the array.
 // JSON scalar has types of string, boolean, null, and number.
-OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, JsonPathV2 expression,
-                                     const JsonType& search_val, int start_index, int end_index) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  vector<OptLong> vec;
-  auto cb = [&](const string_view& path, const JsonType& val) {
+auto OpArrIndex(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path,
+                const JsonType& search_val, int start_index, int end_index) {
+  auto cb = [&](const string_view&, const JsonType& val) -> std::optional<long> {
     if (!val.is_array()) {
-      vec.emplace_back(nullopt);
-      return;
+      return std::nullopt;
     }
 
     if (val.empty()) {
-      vec.emplace_back(-1);
-      return;
+      return -1;
     }
 
     // Negative value or out-of-range index is handled by rounding the index to the array's start
@@ -1231,8 +1045,7 @@ OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, Jso
     }
 
     if (start_index > end_index) {
-      vec.emplace_back(-1);
-      return;
+      return -1;
     }
 
     size_t pos = -1;
@@ -1249,19 +1062,18 @@ OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, Jso
       }
     }
 
-    vec.emplace_back(pos);
+    return pos;
   };
-  JsonType& json_entry = *(result.value());
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+
+  return JsonEvaluateOperation<std::optional<long>>(op_args, key, json_path, std::move(cb));
 }
 
 // Returns string vector that represents the query result of each supplied key.
-vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,
-                             EngineShard* shard) {
+std::vector<std::optional<std::string>> OpJsonMGet(const WrappedJsonPath& json_path,
+                                                   const Transaction* t, EngineShard* shard) {
   ShardArgs args = t->GetShardArgs(shard->shard_id());
   DCHECK(!args.Empty());
-  vector<OptString> response(args.Size());
+  std::vector<std::optional<std::string>> response(args.Size());
 
   auto& db_slice = t->GetDbSlice(shard->shard_id());
   unsigned index = 0;
@@ -1271,31 +1083,31 @@ vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,
     if (!it_res.ok())
       continue;
 
-    dest.emplace();
     JsonType* json_val = it_res.value()->second.GetJson();
     DCHECK(json_val) << "should have a valid JSON object for key " << key;
 
-    vector<JsonType> query_result;
-    auto cb = [&query_result](const string_view& path, const JsonType& val) {
-      query_result.push_back(val);
+    auto cb = [](std::string_view, const JsonType& val) { return val; };
+
+    auto eval_wrapped = [&json_val,
+                         &cb](const WrappedJsonPath& json_path) -> std::optional<JsonType> {
+      auto eval_result = json_path.Evaluate<JsonType>(json_val, std::move(cb), false);
+
+      if (eval_result.IsV1()) {
+        return eval_result.AsV1();
+      }
+
+      return JsonType{eval_result.AsV2()};
     };
 
-    const JsonType& json_entry = *(json_val);
-    visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
+    auto eval_result = eval_wrapped(json_path);
 
-    if (query_result.empty()) {
+    if (!eval_result) {
       continue;
     }
 
-    JsonType arr(json_array_arg);
-    arr.reserve(query_result.size());
-    for (auto& s : query_result) {
-      arr.push_back(s);
-    }
-
-    string str;
-    error_code ec;
-    arr.dump(str, {}, ec);
+    std::string str;
+    std::error_code ec;
+    eval_result->dump(str, {}, ec);
     if (ec) {
       VLOG(1) << "Failed to dump JSON array to string with the error: " << ec.message();
     }
@@ -1307,38 +1119,24 @@ vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,
 }
 
 // Returns numeric vector that represents the number of fields of JSON value at each path.
-OpResult<vector<OptSizeT>> OpFields(const OpArgs& op_args, string_view key, JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  vector<OptSizeT> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) {
-    vec.emplace_back(CountJsonFields(val));
+auto OpFields(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {
+    return CountJsonFields(val);
   };
-  const JsonType& json_entry = *(result.value());
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+
+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb));
 }
 
 // Returns json vector that represents the result of the json query.
-OpResult<vector<JsonType>> OpResp(const OpArgs& op_args, string_view key, JsonPathV2 expression) {
-  OpResult<JsonType*> result = GetJson(op_args, key);
-  if (!result) {
-    return result.status();
-  }
-
-  vector<JsonType> vec;
-  auto cb = [&vec](const string_view& path, const JsonType& val) { vec.emplace_back(val); };
-  const JsonType& json_entry = *(result.value());
-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);
-  return vec;
+auto OpResp(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {
+  auto cb = [](const string_view&, const JsonType& val) { return val; };
+  return JsonEvaluateOperation<JsonType>(op_args, key, json_path, std::move(cb));
 }
 
 // Returns boolean that represents the result of the operation.
 OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
-                     std::string_view json_str, bool is_nx_condition, bool is_xx_condition) {
+                     const WrappedJsonPath& json_path, std::string_view json_str,
+                     bool is_nx_condition, bool is_xx_condition) {
   std::optional<JsonType> parsed_json = JsonFromString(json_str);
   if (!parsed_json) {
     VLOG(1) << "got invalid JSON string '" << json_str << "' cannot be saved";
@@ -1349,7 +1147,7 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
   // NOTE: unlike in Redis, we are overriding the value when the path is "$"
   // this is regardless of the current key type. In redis if the key exists
   // and its not JSON, it would return an error.
-  if (path == "." || path == "$") {
+  if (json_path.RefersToRootElement()) {
     if (is_nx_condition || is_xx_condition) {
       auto it_res = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key, OBJ_JSON);
       bool key_exists = (it_res.status() != OpStatus::KEY_NOTFOUND);
@@ -1377,13 +1175,13 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
   bool path_exists = false;
   bool operation_result = false;
   const JsonType& new_json = parsed_json.value();
-  auto cb = [&](const auto&, JsonType* val) {
+  auto cb = [&](std::optional<std::string_view>, JsonType* val) -> MutateCallbackResult<> {
     path_exists = true;
     if (!is_nx_condition) {
       operation_result = true;
       *val = new_json;
     }
-    return false;
+    return {};
   };
 
   auto inserter = [&](JsonType& json) {
@@ -1397,7 +1195,7 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
       }
 
       error_code ec;
-      jsonpointer::add(json, pointer, new_json, ec);
+      jsoncons::jsonpointer::add(json, pointer, new_json, ec);
       if (ec) {
         VLOG(1) << "Failed to add a JSON value to the following path: " << path
                 << " with the error: " << ec.message();
@@ -1410,14 +1208,21 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
     return OpStatus::OK;
   };
 
-  OpStatus status = UpdateEntry(op_args, key, path, cb, inserter);
-  if (status != OpStatus::OK) {
-    return status;
-  }
-
+  auto res = UpdateEntry<Nothing>(op_args, key, json_path, std::move(cb), inserter);
+  RETURN_ON_BAD_STATUS(res);
   return operation_result;
 }
 
+OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,
+                     std::string_view json_str, bool is_nx_condition, bool is_xx_condition) {
+  auto res_json_path = ParseJsonPath(path);
+  if (!res_json_path) {
+    return OpStatus::SYNTAX_ERR;  // TODO(Return initial error)
+  }
+  return OpSet(op_args, key, path, res_json_path.value(), json_str, is_nx_condition,
+               is_xx_condition);
+}
+
 OpStatus OpMSet(const OpArgs& op_args, const ShardArgs& args) {
   DCHECK_EQ(args.Size() % 3, 0u);
 
@@ -1454,15 +1259,17 @@ OpStatus OpMSet(const OpArgs& op_args, const ShardArgs& args) {
 
 // Note that currently OpMerge works only with jsoncons and json::Path support has not been
 // implemented yet.
-OpStatus OpMerge(const OpArgs& op_args, string_view key, JsonPathV2 expression, string_view path,
-                 std::string_view json_str) {
+OpStatus OpMerge(const OpArgs& op_args, string_view key, string_view path,
+                 const WrappedJsonPath& json_path, std::string_view json_str) {
+  // DCHECK(!json_path.HoldsJsonPath());
+
   std::optional<JsonType> parsed_json = JsonFromString(json_str);
   if (!parsed_json) {
     VLOG(1) << "got invalid JSON string '" << json_str << "' cannot be saved";
     return OpStatus::SYNTAX_ERR;
   }
 
-  auto cb = [&](optional<string_view> cur_path, JsonType* val) {
+  auto cb = [&](std::optional<std::string_view> cur_path, JsonType* val) -> MutateCallbackResult<> {
     string_view strpath = cur_path ? *cur_path : string_view{};
 
     DVLOG(2) << "Handling " << strpath << " " << val->to_string();
@@ -1472,80 +1279,38 @@ OpStatus OpMerge(const OpArgs& op_args, string_view key, JsonPathV2 expression,
     } catch (const std::exception& e) {
       LOG_EVERY_T(ERROR, 1) << "Exception in OpMerge: " << e.what() << " with obj: " << *val
                             << " and patch: " << *parsed_json << ", path: " << strpath;
-      return false;
     }
 
-    return false;
+    return {};
   };
 
-  OpStatus status = UpdateEntry(op_args, key, path, cb);
-  if (status != OpStatus::KEY_NOTFOUND)
-    return status;
-
-  if (path == "$") {
-    // Add a new key.
-    return OpSet(op_args, key, "$", json_str, false, false).status();
-  }
-  return OpStatus::SYNTAX_ERR;
-}
+  auto res = UpdateEntry<Nothing>(op_args, key, json_path, std::move(cb));
 
-io::Result<JsonPathV2, string> ParsePathV2(string_view path) {
-  // We expect all valid paths to start with the root selector, otherwise prepend it
-  string tmp_buf;
-  if (!path.empty() && path.front() != '$') {
-    tmp_buf = absl::StrCat("$", path.front() != '.' ? "." : "", path);
-    path = tmp_buf;
-  }
+  if (res.status() != OpStatus::KEY_NOTFOUND)
+    return res.status();
 
-  if (absl::GetFlag(FLAGS_jsonpathv2)) {
-    auto path_result = json::ParsePath(path);
-    if (!path_result) {
-      VLOG(1) << "Invalid Json path: " << path << ' ' << path_result.error() << std::endl;
-      return nonstd::make_unexpected(kSyntaxErr);
-    }
-    return path_result;
-  }
-  io::Result<JsonExpression> expr_result = ParseJsonPath(path);
-  if (!expr_result) {
-    VLOG(1) << "Invalid Json path: " << path << ' ' << expr_result.error() << std::endl;
-    return nonstd::make_unexpected(kSyntaxErr);
+  if (json_path.RefersToRootElement()) {
+    return OpSet(op_args, key, path, json_path, json_str, false, false).status();
   }
-  return JsonPathV2(std::move(expr_result.value()));
+  return OpStatus::SYNTAX_ERR;
 }
 
 }  // namespace
 
-#define PARSE_PATHV2(path)             \
-  ({                                   \
-    auto result = ParsePathV2(path);   \
-    if (!result) {                     \
-      cntx->SendError(result.error()); \
-      return;                          \
-    }                                  \
-    std::move(*result);                \
-  })
-
 void JsonFamily::Set(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
-  string_view json_str = ArgS(args, 2);
-  bool is_nx_condition = false;
-  bool is_xx_condition = false;
-  string_view operation_opts;
-  if (args.size() > 3) {
-    operation_opts = ArgS(args, 3);
-    if (absl::EqualsIgnoreCase(operation_opts, "NX")) {
-      is_nx_condition = true;
-    } else if (absl::EqualsIgnoreCase(operation_opts, "XX")) {
-      is_xx_condition = true;
-    } else {
-      cntx->SendError(kSyntaxErr);
-      return;
-    }
-  }
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.Next();
+  string_view json_str = parser.Next();
+
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
+
+  bool is_nx_condition = static_cast<bool>(parser.Check("NX"));
+  bool is_xx_condition = static_cast<bool>(parser.Check("XX"));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpSet(t->GetOpArgs(shard), key, path, json_str, is_nx_condition, is_xx_condition);
+    return OpSet(t->GetOpArgs(shard), key, path, json_path, json_str, is_nx_condition,
+                 is_xx_condition);
   };
 
   Transaction* trans = cntx->transaction;
@@ -1590,52 +1355,44 @@ void JsonFamily::MSet(CmdArgList args, ConnectionContext* cntx) {
 // JSON.MERGE key path value
 // Based on https://datatracker.ietf.org/doc/html/rfc7386 spec
 void JsonFamily::Merge(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
-  string_view value = ArgS(args, 2);
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.Next();
+  string_view value = parser.Next();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpMerge(t->GetOpArgs(shard), key, std::move(expression), path, value);
+    return OpMerge(t->GetOpArgs(shard), key, path, json_path, value);
   };
 
-  OpStatus status = cntx->transaction->ScheduleSingleHop(cb);
+  OpStatus status = cntx->transaction->ScheduleSingleHop(std::move(cb));
   if (status == OpStatus::OK)
     return cntx->SendOk();
   cntx->SendError(status);
 }
 
 void JsonFamily::Resp(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = DefaultJsonPath;
-  if (args.size() > 1) {
-    path = ArgS(args, 1);
-  }
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpResp(t->GetOpArgs(shard), key, std::move(expression));
+    return OpResp(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<JsonType>> result = trans->ScheduleSingleHopT(std::move(cb));
-
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-  if (result) {
-    rb->StartArray(result->size());
-    for (const auto& it : *result) {
-      SendJsonValue(rb, it);
-    }
-  } else {
-    cntx->SendError(result.status());
-  }
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::Debug(CmdArgList args, ConnectionContext* cntx) {
-  function<decltype(OpFields)> func;
-  string_view command = ArgS(args, 0);
+  CmdArgParser parser{args};
+  string_view command = parser.Next();
+
   // The 'MEMORY' sub-command is not supported yet, calling to operation function should be added
   // here.
   if (absl::EqualsIgnoreCase(command, "help")) {
@@ -1645,62 +1402,53 @@ void JsonFamily::Debug(CmdArgList args, ConnectionContext* cntx) {
         "JSON.DEBUG FIELDS <key> <path> - report number of fields in the JSON element.");
     rb->SendBulkString("JSON.DEBUG HELP - print help message.");
     return;
-
-  } else if (absl::EqualsIgnoreCase(command, "fields")) {
-    func = &OpFields;
-  } else {
+  } else if (!absl::EqualsIgnoreCase(command, "fields")) {
     cntx->SendError(facade::UnknownSubCmd(command, "JSON.DEBUG"), facade::kSyntaxErrType);
     return;
   }
 
-  if (args.size() < 3) {
-    cntx->SendError(facade::WrongNumArgsError(cntx->cid->name()), facade::kSyntaxErrType);
-    return;
-  }
+  // JSON.DEBUG FIELDS
+
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  string_view key = ArgS(args, 1);
-  string_view path = ArgS(args, 2);
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return func(t->GetOpArgs(shard), key, std::move(expression));
+    return OpFields(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {
   DCHECK_GE(args.size(), 1U);
 
   string_view path = ArgS(args, args.size() - 1);
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   Transaction* transaction = cntx->transaction;
   unsigned shard_count = shard_set->size();
-  std::vector<vector<OptString>> mget_resp(shard_count);
+  std::vector<std::vector<std::optional<std::string>>> mget_resp(shard_count);
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
     ShardId sid = shard->shard_id();
-    mget_resp[sid] = OpJsonMGet(expression, t, shard);
+    mget_resp[sid] = OpJsonMGet(json_path, t, shard);
     return OpStatus::OK;
   };
 
   OpStatus result = transaction->ScheduleSingleHop(std::move(cb));
   CHECK_EQ(OpStatus::OK, result);
 
-  std::vector<OptString> results(args.size() - 1);
+  std::vector<std::optional<std::string>> results(args.size() - 1);
   for (ShardId sid = 0; sid < shard_count; ++sid) {
     if (!transaction->IsActive(sid))
       continue;
 
-    vector<OptString>& res = mget_resp[sid];
+    std::vector<std::optional<std::string>>& res = mget_resp[sid];
     ShardArgs shard_args = transaction->GetShardArgs(sid);
     unsigned src_index = 0;
     for (auto it = shard_args.begin(); it != shard_args.end(); ++it, ++src_index) {
@@ -1713,21 +1461,14 @@ void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {
   }
 
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-  rb->StartArray(results.size());
-  for (auto& it : results) {
-    if (!it) {
-      rb->SendNull();
-    } else {
-      rb->SendBulkString(*it);
-    }
-  }
+  reply_generic::Send(results, rb);
 }
 
 void JsonFamily::ArrIndex(CmdArgList args, ConnectionContext* cntx) {
   string_view key = ArgS(args, 0);
   string_view path = ArgS(args, 1);
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   optional<JsonType> search_value = JsonFromString(ArgS(args, 2));
   if (!search_value) {
@@ -1759,18 +1500,13 @@ void JsonFamily::ArrIndex(CmdArgList args, ConnectionContext* cntx) {
   }
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpArrIndex(t->GetOpArgs(shard), key, std::move(expression), *search_value, start_index,
-                      end_index);
+    return OpArrIndex(t->GetOpArgs(shard), key, json_path, *search_value, start_index, end_index);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptLong>> result = trans->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::ArrInsert(CmdArgList args, ConnectionContext* cntx) {
@@ -1784,7 +1520,7 @@ void JsonFamily::ArrInsert(CmdArgList args, ConnectionContext* cntx) {
     return;
   }
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   vector<JsonType> new_values;
   for (size_t i = 3; i < args.size(); i++) {
@@ -1798,23 +1534,20 @@ void JsonFamily::ArrInsert(CmdArgList args, ConnectionContext* cntx) {
   }
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpArrInsert(t->GetOpArgs(shard), key, path, std::move(expression), index, new_values);
+    return OpArrInsert(t->GetOpArgs(shard), key, json_path, index, new_values);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::ArrAppend(CmdArgList args, ConnectionContext* cntx) {
   string_view key = ArgS(args, 0);
   string_view path = ArgS(args, 1);
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   vector<JsonType> append_values;
 
@@ -1830,16 +1563,13 @@ void JsonFamily::ArrAppend(CmdArgList args, ConnectionContext* cntx) {
   }
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpArrAppend(t->GetOpArgs(shard), key, path, std::move(expression), append_values);
+    return OpArrAppend(t->GetOpArgs(shard), key, json_path, append_values);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::ArrTrim(CmdArgList args, ConnectionContext* cntx) {
@@ -1865,82 +1595,58 @@ void JsonFamily::ArrTrim(CmdArgList args, ConnectionContext* cntx) {
     return;
   }
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpArrTrim(t->GetOpArgs(shard), key, path, std::move(expression), start_index,
-                     stop_index);
+    return OpArrTrim(t->GetOpArgs(shard), key, json_path, start_index, stop_index);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::ArrPop(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
-  int index = -1;
-
-  if (args.size() >= 3) {
-    if (!absl::SimpleAtoi(ArgS(args, 2), &index)) {
-      VLOG(1) << "Failed to convert the following value to numeric, pop out the last item"
-              << ArgS(args, 2);
-    }
-  }
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
+  int index = parser.NextOrDefault<int>(-1);
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpArrPop(t->GetOpArgs(shard), key, path, index, std::move(expression));
+    return OpArrPop(t->GetOpArgs(shard), key, json_path, index);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptString>> result = trans->ScheduleSingleHopT(std::move(cb));
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-  if (result) {
-    rb->StartArray(result->size());
-    for (auto& it : *result) {
-      if (!it) {
-        rb->SendNull();
-      } else {
-        rb->SendSimpleString(*it);
-      }
-    }
-  } else {
-    cntx->SendError(result.status());
-  }
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::Clear(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpClear(t->GetOpArgs(shard), key, path, std::move(expression));
+    return OpClear(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
   OpResult<long> result = trans->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    cntx->SendLong(*result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::StrAppend(CmdArgList args, ConnectionContext* cntx) {
   string_view key = ArgS(args, 0);
   string_view path = ArgS(args, 1);
 
-  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(json_parser::ParseJsonPath(path));
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
   auto strs = args.subspan(2);
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
@@ -1954,57 +1660,37 @@ void JsonFamily::StrAppend(CmdArgList args, ConnectionContext* cntx) {
 }
 
 void JsonFamily::ObjKeys(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = "$";
-  if (args.size() == 2) {
-    path = ArgS(args, 1);
-  }
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpObjKeys(t->GetOpArgs(shard), key, std::move(expression));
+    return OpObjKeys(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<StringVec>> result = trans->ScheduleSingleHopT(std::move(cb));
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-  if (result) {
-    rb->StartArray(result->size());
-    for (auto& it : *result) {
-      if (it.empty()) {
-        rb->SendNullArray();
-      } else {
-        rb->SendStringArr(it);
-      }
-    }
-  } else {
-    cntx->SendError(result.status());
-  }
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::Del(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path;
-
-  optional<JsonPathV2> expression;
-
-  if (args.size() > 1) {
-    path = ArgS(args, 1);
-    expression.emplace(PARSE_PATHV2(path));
-  }
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  if (path == "$" || path == ".") {
-    path = ""sv;
-  }
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpDel(t->GetOpArgs(shard), key, path, std::move(expression));
+    return OpDel(t->GetOpArgs(shard), key, path, json_path);
   };
 
   Transaction* trans = cntx->transaction;
   OpResult<long> result = trans->ScheduleSingleHopT(std::move(cb));
-  cntx->SendLong(*result);
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {
@@ -2018,20 +1704,15 @@ void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {
     return;
   }
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, OP_ADD, std::move(expression));
+    return OpDoubleArithmetic(t->GetOpArgs(shard), key, json_path, dnum, OP_ADD);
   };
 
   OpResult<string> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-
-  if (result) {
-    rb->SendBulkString(*result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::NumMultBy(CmdArgList args, ConnectionContext* cntx) {
@@ -2045,130 +1726,97 @@ void JsonFamily::NumMultBy(CmdArgList args, ConnectionContext* cntx) {
     return;
   }
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, OP_MULTIPLY,
-                              std::move(expression));
+    return OpDoubleArithmetic(t->GetOpArgs(shard), key, json_path, dnum, OP_MULTIPLY);
   };
 
-  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
   OpResult<string> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    rb->SendBulkString(*result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::Toggle(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
-
-  JsonPathV2 expression = PARSE_PATHV2(path);
-
-  auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpToggle(t->GetOpArgs(shard), key, path, std::move(expression));
-  };
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  Transaction* trans = cntx->transaction;
-  OpResult<vector<OptBool>> result = trans->ScheduleSingleHopT(std::move(cb));
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
-  if (result) {
-    PrintOptVec(cntx, result);
+  if (json_path.IsLegacyModePath()) {
+    ExecuteToggle<bool>(key, json_path, cntx);
   } else {
-    cntx->SendError(result.status());
+    ExecuteToggle<long>(key, json_path, cntx);
   }
 }
 
 void JsonFamily::Type(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpType(t->GetOpArgs(shard), key, std::move(expression));
+    return OpType(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<string>> result = trans->ScheduleSingleHopT(std::move(cb));
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
-  if (result) {
-    if (result->empty()) {
-      // When vector is empty, the path doesn't exist in the corresponding json.
-      rb->SendNull();
-    } else {
-      rb->SendStringArr(*result);
-    }
-  } else {
-    if (result.status() == OpStatus::KEY_NOTFOUND) {
-      rb->SendNullArray();
-    } else {
-      cntx->SendError(result.status());
-    }
-  }
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::ArrLen(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpArrLen(t->GetOpArgs(shard), key, std::move(expression));
+    return OpArrLen(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::ObjLen(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpObjLen(t->GetOpArgs(shard), key, std::move(expression));
+    return OpObjLen(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::StrLen(CmdArgList args, ConnectionContext* cntx) {
-  string_view key = ArgS(args, 0);
-  string_view path = ArgS(args, 1);
+  CmdArgParser parser{args};
+  string_view key = parser.Next();
+  string_view path = parser.NextOrDefault();
 
-  JsonPathV2 expression = PARSE_PATHV2(path);
+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));
 
   auto cb = [&](Transaction* t, EngineShard* shard) {
-    return OpStrLen(t->GetOpArgs(shard), key, std::move(expression));
+    return OpStrLen(t->GetOpArgs(shard), key, json_path);
   };
 
   Transaction* trans = cntx->transaction;
-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));
-
-  if (result) {
-    PrintOptVec(cntx, result);
-  } else {
-    cntx->SendError(result.status());
-  }
+  auto result = trans->ScheduleSingleHopT(std::move(cb));
+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());
+  reply_generic::Send(result, rb);
 }
 
 void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {
@@ -2177,9 +1825,9 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {
   facade::CmdArgParser parser{args};
   string_view key = parser.Next();
 
-  OptString indent;
-  OptString new_line;
-  OptString space;
+  std::optional<std::string> indent;
+  std::optional<std::string> new_line;
+  std::optional<std::string> space;
 
   vector<pair<string_view, WrappedJsonPath>> paths;
 
@@ -2198,7 +1846,7 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {
     }
 
     string_view path_str = parser.Next();
-    WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(json_parser::ParseJsonPath(path_str));
+    WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path_str));
 
     paths.emplace_back(path_str, std::move(json_path));
   }
@@ -2238,11 +1886,11 @@ void JsonFamily::Register(CommandRegistry* registry) {
   registry->StartFamily();
   *registry << CI{"JSON.GET", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Get);
   *registry << CI{"JSON.MGET", CO::READONLY | CO::FAST, -3, 1, -2, acl::JSON}.HFUNC(MGet);
-  *registry << CI{"JSON.TYPE", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(Type);
-  *registry << CI{"JSON.STRLEN", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(StrLen);
-  *registry << CI{"JSON.OBJLEN", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(ObjLen);
-  *registry << CI{"JSON.ARRLEN", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(ArrLen);
-  *registry << CI{"JSON.TOGGLE", CO::WRITE | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(Toggle);
+  *registry << CI{"JSON.TYPE", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Type);
+  *registry << CI{"JSON.STRLEN", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(StrLen);
+  *registry << CI{"JSON.OBJLEN", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ObjLen);
+  *registry << CI{"JSON.ARRLEN", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ArrLen);
+  *registry << CI{"JSON.TOGGLE", CO::WRITE | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Toggle);
   *registry << CI{"JSON.NUMINCRBY", CO::WRITE | CO::FAST, 4, 1, 1, acl::JSON}.HFUNC(NumIncrBy);
   *registry << CI{"JSON.NUMMULTBY", CO::WRITE | CO::FAST, 4, 1, 1, acl::JSON}.HFUNC(NumMultBy);
   *registry << CI{"JSON.DEL", CO::WRITE, -2, 1, 1, acl::JSON}.HFUNC(Del);
@@ -2251,8 +1899,8 @@ void JsonFamily::Register(CommandRegistry* registry) {
   *registry << CI{"JSON.OBJKEYS", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ObjKeys);
   *registry << CI{"JSON.STRAPPEND", CO::WRITE | CO::DENYOOM | CO::FAST, -4, 1, 1, acl::JSON}.HFUNC(
       StrAppend);
-  *registry << CI{"JSON.CLEAR", CO::WRITE | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(Clear);
-  *registry << CI{"JSON.ARRPOP", CO::WRITE | CO::FAST, -3, 1, 1, acl::JSON}.HFUNC(ArrPop);
+  *registry << CI{"JSON.CLEAR", CO::WRITE | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Clear);
+  *registry << CI{"JSON.ARRPOP", CO::WRITE | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ArrPop);
   *registry << CI{"JSON.ARRTRIM", CO::WRITE | CO::FAST, 5, 1, 1, acl::JSON}.HFUNC(ArrTrim);
   *registry << CI{"JSON.ARRINSERT", CO::WRITE | CO::DENYOOM | CO::FAST, -4, 1, 1, acl::JSON}.HFUNC(
       ArrInsert);
