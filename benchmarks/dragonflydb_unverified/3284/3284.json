{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3284,
  "instance_id": "dragonflydb__dragonfly-3284",
  "issue_numbers": [
    "2959"
  ],
  "base_commit": "7df72fd6d08f19b2388afd567a1fb6a4f0334972",
  "patch": "diff --git a/src/facade/cmd_arg_parser.h b/src/facade/cmd_arg_parser.h\nindex bda1b5f7c33c..5f4fdaad5fa1 100644\n--- a/src/facade/cmd_arg_parser.h\n+++ b/src/facade/cmd_arg_parser.h\n@@ -90,6 +90,11 @@ struct CmdArgParser {\n     }\n   }\n \n+  // returns next value if exists or default value\n+  template <class T = std::string_view> auto NextOrDefault(T default_value = {}) {\n+    return HasNext() ? Next<T>() : default_value;\n+  }\n+\n   // check next value ignoring case and consume it\n   void ExpectTag(std::string_view tag);\n \ndiff --git a/src/facade/error.h b/src/facade/error.h\nindex c6aded2b55a0..d973b9d334ac 100644\n--- a/src/facade/error.h\n+++ b/src/facade/error.h\n@@ -17,6 +17,7 @@ std::string UnknownSubCmd(std::string_view subcmd, std::string_view cmd);\n \n extern const char kSyntaxErr[];\n extern const char kWrongTypeErr[];\n+extern const char kWrongJsonTypeErr[];\n extern const char kKeyNotFoundErr[];\n extern const char kInvalidIntErr[];\n extern const char kInvalidFloatErr[];\ndiff --git a/src/facade/facade.cc b/src/facade/facade.cc\nindex fce39a55cb84..041df090a874 100644\n--- a/src/facade/facade.cc\n+++ b/src/facade/facade.cc\n@@ -79,6 +79,7 @@ string ConfigSetFailed(string_view config_name) {\n \n const char kSyntaxErr[] = \"syntax error\";\n const char kWrongTypeErr[] = \"-WRONGTYPE Operation against a key holding the wrong kind of value\";\n+const char kWrongJsonTypeErr[] = \"-WRONGTYPE wrong JSON type of path value\";\n const char kKeyNotFoundErr[] = \"no such key\";\n const char kInvalidIntErr[] = \"value is not an integer or out of range\";\n const char kInvalidFloatErr[] = \"value is not a valid float\";\ndiff --git a/src/facade/op_status.cc b/src/facade/op_status.cc\nindex 941f0f0aa2d7..84f5c8e6a880 100644\n--- a/src/facade/op_status.cc\n+++ b/src/facade/op_status.cc\n@@ -14,6 +14,8 @@ std::string_view StatusToMsg(OpStatus status) {\n       return kKeyNotFoundErr;\n     case OpStatus::WRONG_TYPE:\n       return kWrongTypeErr;\n+    case OpStatus::WRONG_JSON_TYPE:\n+      return kWrongJsonTypeErr;\n     case OpStatus::OUT_OF_RANGE:\n       return kIndexOutOfRange;\n     case OpStatus::INVALID_FLOAT:\ndiff --git a/src/facade/op_status.h b/src/facade/op_status.h\nindex 82ab517f3c99..4c5c1e92ca61 100644\n--- a/src/facade/op_status.h\n+++ b/src/facade/op_status.h\n@@ -18,6 +18,7 @@ enum class OpStatus : uint16_t {\n   INVALID_VALUE,\n   OUT_OF_RANGE,\n   WRONG_TYPE,\n+  WRONG_JSON_TYPE,\n   TIMED_OUT,\n   OUT_OF_MEMORY,\n   INVALID_FLOAT,\ndiff --git a/src/server/detail/wrapped_json_path.h b/src/server/detail/wrapped_json_path.h\nindex 7bca419ef684..fb2d2cf4efd9 100644\n--- a/src/server/detail/wrapped_json_path.h\n+++ b/src/server/detail/wrapped_json_path.h\n@@ -24,32 +24,15 @@ using JsonExpression = jsoncons::jsonpath::jsonpath_expression<JsonType>;\n template <typename T>\n using JsonPathEvaluateCallback = absl::FunctionRef<T(std::string_view, const JsonType&)>;\n \n-template <typename T = Nothing> class MutateCallbackResult {\n- public:\n+template <typename T = Nothing> struct MutateCallbackResult {\n   MutateCallbackResult() = default;\n \n-  explicit MutateCallbackResult(bool should_be_deleted) : should_be_deleted_(should_be_deleted_) {\n-  }\n-\n-  MutateCallbackResult(bool should_be_deleted, T&& value)\n-      : should_be_deleted_(should_be_deleted), value_(std::forward<T>(value)) {\n-  }\n-\n-  bool HasValue() const {\n-    return value_.has_value();\n-  }\n-\n-  T&& GetValue() && {\n-    return std::move(value_).value();\n+  MutateCallbackResult(bool should_be_deleted_, T value_)\n+      : should_be_deleted(should_be_deleted_), value(std::move(value_)) {\n   }\n \n-  bool ShouldBeDeleted() const {\n-    return should_be_deleted_;\n-  }\n-\n- private:\n-  bool should_be_deleted_;\n-  std::optional<T> value_;\n+  bool should_be_deleted = false;\n+  std::optional<T> value;\n };\n \n template <typename T>\n@@ -81,7 +64,8 @@ template <typename T> class JsonCallbackResult {\n \n   JsonCallbackResult() = default;\n \n-  explicit JsonCallbackResult(bool legacy_mode_is_enabled) {\n+  explicit JsonCallbackResult(bool legacy_mode_is_enabled, bool save_first_result = false)\n+      : save_first_result_(save_first_result) {\n     if (!legacy_mode_is_enabled) {\n       result_ = JsonV2Result{};\n     }\n@@ -89,7 +73,14 @@ template <typename T> class JsonCallbackResult {\n \n   void AddValue(T value) {\n     if (IsV1()) {\n-      details::OptionalEmplace(std::move(value), &AsV1());\n+      if (!save_first_result_) {\n+        details::OptionalEmplace(std::move(value), &AsV1());\n+      } else {\n+        auto& as_v1 = AsV1();\n+        if (!as_v1.has_value()) {\n+          details::OptionalEmplace(std::move(value), &as_v1);\n+        }\n+      }\n     } else {\n       AsV2().emplace_back(std::move(value));\n     }\n@@ -117,6 +108,7 @@ template <typename T> class JsonCallbackResult {\n \n  private:\n   std::variant<JsonV1Result, JsonV2Result> result_;\n+  bool save_first_result_ = false;\n };\n \n class WrappedJsonPath {\n@@ -137,14 +129,15 @@ class WrappedJsonPath {\n   }\n \n   template <typename T>\n-  JsonCallbackResult<T> Evaluate(const JsonType* json_entry, JsonPathEvaluateCallback<T> cb) const {\n-    return Evaluate(json_entry, cb, IsLegacyModePath());\n+  JsonCallbackResult<T> Evaluate(const JsonType* json_entry, JsonPathEvaluateCallback<T> cb,\n+                                 bool save_first_result) const {\n+    return Evaluate(json_entry, cb, save_first_result, IsLegacyModePath());\n   }\n \n   template <typename T>\n   JsonCallbackResult<T> Evaluate(const JsonType* json_entry, JsonPathEvaluateCallback<T> cb,\n-                                 bool legacy_mode_is_enabled) const {\n-    JsonCallbackResult<T> eval_result{legacy_mode_is_enabled};\n+                                 bool save_first_result, bool legacy_mode_is_enabled) const {\n+    JsonCallbackResult<T> eval_result{legacy_mode_is_enabled, save_first_result};\n \n     auto eval_callback = [&cb, &eval_result](std::string_view path, const JsonType& val) {\n       eval_result.AddValue(cb(path, val));\n@@ -172,10 +165,10 @@ class WrappedJsonPath {\n     auto mutate_callback = [&cb, &mutate_result](std::optional<std::string_view> path,\n                                                  JsonType* val) -> bool {\n       auto res = cb(path, val);\n-      if (res.HasValue()) {\n-        mutate_result.AddValue(std::move(res).GetValue());\n+      if (res.value.has_value()) {\n+        mutate_result.AddValue(std::move(res.value).value());\n       }\n-      return res.ShouldBeDeleted();\n+      return res.should_be_deleted;\n     };\n \n     if (HoldsJsonPath()) {\n@@ -217,7 +210,11 @@ class WrappedJsonPath {\n     return is_legacy_mode_path_;\n   }\n \n- private:\n+  bool RefersToRootElement() const {\n+    auto path = path_.view();\n+    return path.empty() || path == kV1PathRootElement || path == kV2PathRootElement;\n+  }\n+\n   bool HoldsJsonPath() const {\n     return std::holds_alternative<json::Path>(parsed_path_);\n   }\ndiff --git a/src/server/error.h b/src/server/error.h\nindex 157c1f68926f..c5fe49cbfcca 100644\n--- a/src/server/error.h\n+++ b/src/server/error.h\n@@ -44,17 +44,6 @@ using facade::kWrongTypeErr;\n \n #endif  // RETURN_ON_BAD_STATUS\n \n-#ifndef RETURN_UNEXPECTED\n-\n-#define RETURN_UNEXPECTED(x)       \\\n-  do {                             \\\n-    if (!(x)) {                    \\\n-      return (x).get_unexpected(); \\\n-    }                              \\\n-  } while (0)\n-\n-#endif  // RETURN_UNEXPECTED\n-\n #ifndef GET_OR_SEND_UNEXPECTED\n \n #define GET_OR_SEND_UNEXPECTED(expr)     \\\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 4393811b2723..f96085fccfe3 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -42,23 +42,15 @@ namespace dfly {\n \n using namespace std;\n using namespace jsoncons;\n+using facade::CmdArgParser;\n using facade::kSyntaxErrType;\n-using facade::WrongNumArgsError;\n \n using JsonExpression = jsonpath::jsonpath_expression<JsonType>;\n-using OptBool = optional<bool>;\n-using OptLong = optional<long>;\n-using OptSizeT = optional<size_t>;\n-using OptString = optional<string>;\n using JsonReplaceVerify = std::function<void(JsonType&)>;\n using CI = CommandId;\n \n-static const char DefaultJsonPath[] = \"$\";\n-\n namespace {\n \n-namespace json_parser {\n-\n template <typename T> using ParseResult = io::Result<T, std::string>;\n \n ParseResult<JsonExpression> ParseJsonPathAsExpression(std::string_view path) {\n@@ -72,17 +64,23 @@ ParseResult<JsonExpression> ParseJsonPathAsExpression(std::string_view path) {\n ParseResult<WrappedJsonPath> ParseJsonPath(StringOrView path, bool is_legacy_mode_path) {\n   if (absl::GetFlag(FLAGS_jsonpathv2)) {\n     auto path_result = json::ParsePath(path.view());\n-    RETURN_UNEXPECTED(path_result);\n+    if (!path_result) {\n+      VLOG(1) << \"Invalid Json path: \" << path << ' ' << path_result.error() << std::endl;\n+      return nonstd::make_unexpected(kSyntaxErr);\n+    }\n     return WrappedJsonPath{std::move(path_result).value(), std::move(path), is_legacy_mode_path};\n   }\n \n   auto expr_result = ParseJsonPathAsExpression(path.view());\n-  RETURN_UNEXPECTED(expr_result);\n+  if (!expr_result) {\n+    VLOG(1) << \"Invalid Json path: \" << path << ' ' << expr_result.error() << std::endl;\n+    return nonstd::make_unexpected(kSyntaxErr);\n+  }\n   return WrappedJsonPath{std::move(expr_result).value(), std::move(path), is_legacy_mode_path};\n }\n \n ParseResult<WrappedJsonPath> ParseJsonPathV1(std::string_view path) {\n-  if (path == WrappedJsonPath::kV1PathRootElement) {\n+  if (path.empty() || path == WrappedJsonPath::kV1PathRootElement) {\n     return ParseJsonPath(StringOrView::FromView(WrappedJsonPath::kV2PathRootElement), true);\n   }\n \n@@ -97,22 +95,67 @@ ParseResult<WrappedJsonPath> ParseJsonPathV2(std::string_view path) {\n }\n \n bool IsJsonPathV2(std::string_view path) {\n-  return path.front() == '$';\n+  return !path.empty() && path.front() == '$';\n }\n \n ParseResult<WrappedJsonPath> ParseJsonPath(std::string_view path) {\n-  DCHECK(!path.empty());\n   return IsJsonPathV2(path) ? ParseJsonPathV2(path) : ParseJsonPathV1(path);\n }\n \n-}  // namespace json_parser\n-\n namespace reply_generic {\n \n-void Send(std::size_t value, RedisReplyBuilder* rb) {\n+template <typename T> void Send(const std::optional<T>& opt, RedisReplyBuilder* rb);\n+template <typename T> void Send(const std::vector<T>& vec, RedisReplyBuilder* rb);\n+template <> void Send(const std::vector<std::string>& vec, RedisReplyBuilder* rb);\n+\n+void Send(bool value, RedisReplyBuilder* rb) {\n+  rb->SendBulkString(value ? \"true\"sv : \"false\"sv);\n+}\n+\n+void Send(long value, RedisReplyBuilder* rb) {\n+  rb->SendLong(value);\n+}\n+\n+void Send(size_t value, RedisReplyBuilder* rb) {\n   rb->SendLong(value);\n }\n \n+void Send(double value, RedisReplyBuilder* rb) {\n+  rb->SendDouble(value);\n+}\n+\n+void Send(const std::string& value, RedisReplyBuilder* rb) {\n+  rb->SendBulkString(value);\n+}\n+\n+void Send(const JsonType& value, RedisReplyBuilder* rb) {\n+  if (value.is_double()) {\n+    Send(value.as_double(), rb);\n+  } else if (value.is_number()) {\n+    Send(value.as_integer<long>(), rb);\n+  } else if (value.is_bool()) {\n+    rb->SendSimpleString(value.as_bool() ? \"true\" : \"false\");\n+  } else if (value.is_null()) {\n+    rb->SendNull();\n+  } else if (value.is_string()) {\n+    rb->SendBulkString(value.as_string_view());\n+  } else if (value.is_object()) {\n+    rb->StartArray(value.size() + 1);\n+    rb->SendSimpleString(\"{\");\n+    for (const auto& item : value.object_range()) {\n+      rb->StartArray(2);\n+      rb->SendBulkString(item.key());\n+      Send(item.value(), rb);\n+    }\n+  } else if (value.is_array()) {\n+    rb->StartArray(value.size() + 1);\n+    rb->SendSimpleString(\"[\");\n+    for (const auto& item : value.array_range()) {\n+      Send(item, rb);\n+    }\n+  }\n+}\n+\n template <typename T> void Send(const std::optional<T>& opt, RedisReplyBuilder* rb) {\n   if (opt.has_value()) {\n     Send(opt.value(), rb);\n@@ -123,7 +166,7 @@ template <typename T> void Send(const std::optional<T>& opt, RedisReplyBuilder*\n \n template <typename T> void Send(const std::vector<T>& vec, RedisReplyBuilder* rb) {\n   if (vec.empty()) {\n-    rb->SendNullArray();\n+    rb->SendEmptyArray();\n   } else {\n     rb->StartArray(vec.size());\n     for (auto&& x : vec) {\n@@ -132,6 +175,14 @@ template <typename T> void Send(const std::vector<T>& vec, RedisReplyBuilder* rb\n   }\n }\n \n+template <> void Send(const std::vector<std::string>& vec, RedisReplyBuilder* rb) {\n+  if (vec.empty()) {\n+    rb->SendEmptyArray();\n+  } else {\n+    rb->SendStringArr(vec);\n+  }\n+}\n+\n template <typename T> void Send(const JsonCallbackResult<T>& result, RedisReplyBuilder* rb) {\n   if (result.IsV1()) {\n     /* The specified path was restricted (JSON legacy mode), then the result consists only of a\n@@ -154,30 +205,6 @@ template <typename T> void Send(const OpResult<T>& result, RedisReplyBuilder* rb\n \n }  // namespace reply_generic\n \n-using JsonPathV2 = variant<json::Path, JsonExpression>;\n-using ExprCallback = absl::FunctionRef<void(string_view, const JsonType&)>;\n-\n-inline void Evaluate(const JsonExpression& expr, const JsonType& obj, ExprCallback cb) {\n-  expr.evaluate(obj, cb);\n-}\n-\n-inline void Evaluate(const json::Path& expr, const JsonType& obj, ExprCallback cb) {\n-  json::EvaluatePath(expr, obj, [&cb](optional<string_view> key, const JsonType& val) {\n-    cb(key ? *key : string_view{}, val);\n-  });\n-}\n-\n-inline JsonType Evaluate(const JsonExpression& expr, const JsonType& obj) {\n-  return expr.evaluate(obj);\n-}\n-\n-inline JsonType Evaluate(const json::Path& expr, const JsonType& obj) {\n-  JsonType res(json_array_arg);\n-  json::EvaluatePath(expr, obj,\n-                     [&res](optional<string_view>, const JsonType& val) { res.push_back(val); });\n-  return res;\n-}\n-\n facade::OpStatus SetJson(const OpArgs& op_args, string_view key, JsonType&& value) {\n   auto& db_slice = op_args.GetDbSlice();\n \n@@ -227,149 +254,6 @@ inline std::optional<JsonType> JsonFromString(std::string_view input) {\n   return dfly::JsonFromString(input, CompactObj::memory_resource());\n }\n \n-io::Result<JsonExpression> ParseJsonPath(string_view path) {\n-  if (path == \".\") {\n-    // RedisJson V1 uses the dot for root level access.\n-    // There are more incompatibilities with legacy paths which are not supported.\n-    path = \"$\"sv;\n-  }\n-  std::error_code ec;\n-  JsonExpression res = MakeJsonPathExpr(path, ec);\n-  if (ec)\n-    return nonstd::make_unexpected(ec);\n-  return res;\n-}\n-\n-template <typename T>\n-void PrintOptVec(ConnectionContext* cntx, const OpResult<vector<optional<T>>>& result) {\n-  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  if (result->empty()) {\n-    rb->SendNullArray();\n-  } else {\n-    rb->StartArray(result->size());\n-    for (auto& it : *result) {\n-      if (it.has_value()) {\n-        if constexpr (is_floating_point_v<T>) {\n-          rb->SendDouble(*it);\n-        } else {\n-          static_assert(is_integral_v<T>, \"Integral required.\");\n-          rb->SendLong(*it);\n-        }\n-      } else {\n-        rb->SendNull();\n-      }\n-    }\n-  }\n-}\n-\n-error_code JsonReplace(JsonType& instance, string_view path, json::MutateCallback callback) {\n-  using evaluator_t = jsonpath::detail::jsonpath_evaluator<JsonType, JsonType&>;\n-  using value_type = evaluator_t::value_type;\n-  using reference = evaluator_t::reference;\n-  using json_selector_t = evaluator_t::path_expression_type;\n-\n-  jsonpath::custom_functions<JsonType> funcs = jsonpath::custom_functions<JsonType>();\n-\n-  error_code ec;\n-  jsonpath::detail::static_resources<value_type, reference> static_resources(funcs);\n-  evaluator_t e;\n-  json_selector_t expr = e.compile(static_resources, path, ec);\n-  if (ec) {\n-    return ec;\n-  }\n-\n-  jsonpath::detail::dynamic_resources<value_type, reference> resources;\n-\n-  auto f = [&callback](const jsonpath::basic_path_node<char>& path, JsonType& val) {\n-    callback(jsonpath::to_string(path), &val);\n-  };\n-\n-  expr.evaluate(resources, instance, json_selector_t::path_node_type{}, instance, f,\n-                jsonpath::result_options::nodups | jsonpath::result_options::path);\n-  return ec;\n-}\n-\n-template <typename T>\n-OpResult<JsonCallbackResult<T>> UpdateEntry(const OpArgs& op_args, std::string_view key,\n-                                            const WrappedJsonPath& json_path,\n-                                            JsonPathMutateCallback<T> cb,\n-                                            JsonReplaceVerify verify_op = {}) {\n-  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);\n-  RETURN_ON_BAD_STATUS(it_res);\n-\n-  PrimeValue& pv = it_res->it->second;\n-\n-  JsonType* json_val = pv.GetJson();\n-  DCHECK(json_val) << \"should have a valid JSON object for key '\" << key << \"' the type for it is '\"\n-                   << pv.ObjType() << \"'\";\n-\n-  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, pv);\n-\n-  auto mutate_res = json_path.Mutate(json_val, cb);\n-\n-  // Make sure that we don't have other internal issue with the operation\n-  if (mutate_res && verify_op) {\n-    verify_op(*json_val);\n-  }\n-\n-  it_res->post_updater.Run();\n-  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, pv);\n-\n-  return mutate_res;\n-}\n-\n-// jsoncons version\n-OpStatus UpdateEntry(const OpArgs& op_args, std::string_view key, std::string_view path,\n-                     json::MutateCallback callback, JsonReplaceVerify verify_op = {}) {\n-  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);\n-  if (!it_res.ok()) {\n-    return it_res.status();\n-  }\n-\n-  auto entry_it = it_res->it;\n-  JsonType* json_val = entry_it->second.GetJson();\n-  DCHECK(json_val) << \"should have a valid JSON object for key '\" << key << \"' the type for it is '\"\n-                   << entry_it->second.ObjType() << \"'\";\n-  JsonType& json_entry = *json_val;\n-\n-  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, entry_it->second);\n-\n-  // Run the update operation on this entry\n-  error_code ec = JsonReplace(json_entry, path, callback);\n-  if (ec) {\n-    VLOG(1) << \"Failed to evaluate expression on json with error: \" << ec.message();\n-    return OpStatus::SYNTAX_ERR;\n-  }\n-\n-  // Make sure that we don't have other internal issue with the operation\n-  if (verify_op) {\n-    verify_op(json_entry);\n-  }\n-\n-  it_res->post_updater.Run();\n-  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, entry_it->second);\n-\n-  return OpStatus::OK;\n-}\n-\n-// json::Path version.\n-OpStatus UpdateEntry(const OpArgs& op_args, string_view key, const json::Path& path,\n-                     json::MutateCallback cb) {\n-  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);\n-  if (!it_res.ok()) {\n-    return it_res.status();\n-  }\n-\n-  PrimeValue& pv = it_res->it->second;\n-\n-  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, pv);\n-  json::MutatePath(path, std::move(cb), pv.GetJson());\n-  it_res->post_updater.Run();\n-  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, pv);\n-\n-  return OpStatus::OK;\n-}\n-\n OpResult<JsonType*> GetJson(const OpArgs& op_args, string_view key) {\n   auto it_res = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key, OBJ_JSON);\n   if (!it_res.ok())\n@@ -554,32 +438,70 @@ size_t CountJsonFields(const JsonType& j) {\n   return res;\n }\n \n-void SendJsonValue(RedisReplyBuilder* rb, const JsonType& j) {\n-  if (j.is_double()) {\n-    rb->SendDouble(j.as_double());\n-  } else if (j.is_number()) {\n-    rb->SendLong(j.as_integer<long>());\n-  } else if (j.is_bool()) {\n-    rb->SendSimpleString(j.as_bool() ? \"true\" : \"false\");\n-  } else if (j.is_null()) {\n-    rb->SendNull();\n-  } else if (j.is_string()) {\n-    rb->SendBulkString(j.as_string_view());\n-  } else if (j.is_object()) {\n-    rb->StartArray(j.size() + 1);\n-    rb->SendSimpleString(\"{\");\n-    for (const auto& item : j.object_range()) {\n-      rb->StartArray(2);\n-      rb->SendBulkString(item.key());\n-      SendJsonValue(rb, item.value());\n-    }\n-  } else if (j.is_array()) {\n-    rb->StartArray(j.size() + 1);\n-    rb->SendSimpleString(\"[\");\n-    for (const auto& item : j.array_range()) {\n-      SendJsonValue(rb, item);\n+template <typename T> struct is_optional : std::false_type {};\n+\n+template <typename T> struct is_optional<std::optional<T>> : std::true_type {};\n+\n+template <typename T>\n+OpResult<JsonCallbackResult<T>> ReturnWrongTypeOnNullOpt(JsonCallbackResult<T> result) {\n+  if constexpr (is_optional<T>::value) {\n+    if (result.IsV1()) {\n+      auto& as_v1 = result.AsV1();\n+      if (!as_v1 || !as_v1.value()) {\n+        return OpStatus::WRONG_JSON_TYPE;\n+      }\n     }\n   }\n+  return result;\n+}\n+\n+struct EvaluateOperationOptions {\n+  bool save_first_result = false;\n+  bool return_empty_result_if_key_not_found = false;\n+};\n+\n+template <typename T>\n+OpResult<JsonCallbackResult<T>> JsonEvaluateOperation(const OpArgs& op_args, std::string_view key,\n+                                                      const WrappedJsonPath& json_path,\n+                                                      JsonPathEvaluateCallback<T> cb,\n+                                                      EvaluateOperationOptions options = {}) {\n+  OpResult<JsonType*> result = GetJson(op_args, key);\n+  if (options.return_empty_result_if_key_not_found && result == OpStatus::KEY_NOTFOUND) {\n+    return JsonCallbackResult<T>{};\n+  }\n+  RETURN_ON_BAD_STATUS(result);\n+  return ReturnWrongTypeOnNullOpt(\n+      json_path.Evaluate<T>(result.value(), cb, options.save_first_result));\n+}\n+\n+template <typename T>\n+OpResult<JsonCallbackResult<T>> UpdateEntry(const OpArgs& op_args, std::string_view key,\n+                                            const WrappedJsonPath& json_path,\n+                                            JsonPathMutateCallback<T> cb,\n+                                            JsonReplaceVerify verify_op = {}) {\n+  auto it_res = op_args.GetDbSlice().FindMutable(op_args.db_cntx, key, OBJ_JSON);\n+  RETURN_ON_BAD_STATUS(it_res);\n+\n+  PrimeValue& pv = it_res->it->second;\n+\n+  JsonType* json_val = pv.GetJson();\n+  DCHECK(json_val) << \"should have a valid JSON object for key '\" << key << \"' the type for it is '\"\n+                   << pv.ObjType() << \"'\";\n+\n+  op_args.shard->search_indices()->RemoveDoc(key, op_args.db_cntx, pv);\n+\n+  auto mutate_res = json_path.Mutate(json_val, cb);\n+\n+  // Make sure that we don't have other internal issue with the operation\n+  if (mutate_res && verify_op) {\n+    verify_op(*json_val);\n+  }\n+\n+  it_res->post_updater.Run();\n+  op_args.shard->search_indices()->AddDoc(key, op_args.db_cntx, pv);\n+\n+  RETURN_ON_BAD_STATUS(mutate_res);\n+  return ReturnWrongTypeOnNullOpt(*std::move(mutate_res));\n }\n \n bool LegacyModeIsEnabled(const std::vector<std::pair<std::string_view, WrappedJsonPath>>& paths) {\n@@ -597,7 +519,7 @@ OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,\n \n   const JsonType& json_entry = *(result.value());\n   if (paths.empty()) {\n-    // this implicitly means that we're using $ which\n+    // this implicitly means that we're using . which\n     // means we just brings all values\n     return json_entry.to_string();\n   }\n@@ -628,7 +550,7 @@ OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,\n \n   auto eval_wrapped = [&json_entry, &cb, legacy_mode_is_enabled](\n                           const WrappedJsonPath& json_path) -> std::optional<JsonType> {\n-    auto eval_result = json_path.Evaluate<JsonType>(&json_entry, cb, legacy_mode_is_enabled);\n+    auto eval_result = json_path.Evaluate<JsonType>(&json_entry, cb, false, legacy_mode_is_enabled);\n \n     DCHECK(legacy_mode_is_enabled == eval_result.IsV1());\n \n@@ -657,106 +579,78 @@ OpResult<std::string> OpJsonGet(const OpArgs& op_args, string_view key,\n   return ss.str();\n }\n \n-OpResult<vector<string>> OpType(const OpArgs& op_args, string_view key, JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  const JsonType& json_entry = *(result.value());\n-  vector<string> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) {\n-    vec.emplace_back(JsonTypeToName(val));\n+auto OpType(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view&, const JsonType& val) -> std::string {\n+    return JsonTypeToName(val);\n   };\n-\n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+  return JsonEvaluateOperation<std::string>(op_args, key, json_path, std::move(cb), {false, true});\n }\n \n-OpResult<vector<OptSizeT>> OpStrLen(const OpArgs& op_args, string_view key, JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-  const JsonType& json_entry = *(result.value());\n-  vector<OptSizeT> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) {\n+OpResult<JsonCallbackResult<std::optional<size_t>>> OpStrLen(const OpArgs& op_args, string_view key,\n+                                                             const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {\n     if (val.is_string()) {\n-      vec.emplace_back(val.as_string_view().size());\n+      return val.as_string_view().size();\n     } else {\n-      vec.emplace_back(nullopt);\n+      return std::nullopt;\n     }\n   };\n \n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb),\n+                                                           {true, true});\n }\n \n-OpResult<vector<OptSizeT>> OpObjLen(const OpArgs& op_args, string_view key, JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  const JsonType& json_entry = *(result.value());\n-  vector<OptSizeT> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) {\n+OpResult<JsonCallbackResult<std::optional<size_t>>> OpObjLen(const OpArgs& op_args, string_view key,\n+                                                             const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {\n     if (val.is_object()) {\n-      vec.emplace_back(val.size());\n+      return val.size();\n     } else {\n-      vec.emplace_back(nullopt);\n+      return std::nullopt;\n     }\n   };\n \n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb),\n+                                                           {true, true});\n }\n \n-OpResult<vector<OptSizeT>> OpArrLen(const OpArgs& op_args, string_view key, JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  const JsonType& json_entry = *(result.value());\n-  vector<OptSizeT> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) {\n+OpResult<JsonCallbackResult<std::optional<size_t>>> OpArrLen(const OpArgs& op_args, string_view key,\n+                                                             const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {\n     if (val.is_array()) {\n-      vec.emplace_back(val.size());\n+      return val.size();\n     } else {\n-      vec.emplace_back(nullopt);\n+      return std::nullopt;\n     }\n   };\n-\n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb),\n+                                                           {true, true});\n }\n \n-OpResult<vector<OptBool>> OpToggle(const OpArgs& op_args, string_view key, string_view path,\n-                                   JsonPathV2 expression) {\n-  vector<OptBool> vec;\n-  OpStatus status;\n-  auto cb = [&vec](optional<string_view>, JsonType* val) {\n+template <typename T>\n+auto OpToggle(const OpArgs& op_args, string_view key,\n+              const WrappedJsonPath& json_path) {  // TODO(change the output type for enhanced path)\n+  auto cb = [](std::optional<std::string_view>,\n+               JsonType* val) -> MutateCallbackResult<std::optional<T>> {\n     if (val->is_bool()) {\n       bool next_val = val->as_bool() ^ true;\n       *val = next_val;\n-      vec.emplace_back(next_val);\n-    } else {\n-      vec.emplace_back(nullopt);\n+      return {false, next_val};\n     }\n-    return false;\n+    return {false, std::nullopt};\n   };\n+  return UpdateEntry<std::optional<T>>(op_args, key, json_path, std::move(cb));\n+}\n \n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& expr = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, expr, cb);\n-  } else {\n-    status = UpdateEntry(op_args, key, path, cb);\n-  }\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n-  return vec;\n+template <typename T>\n+auto ExecuteToggle(string_view key, const WrappedJsonPath& json_path, ConnectionContext* cntx) {\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpToggle<T>(t->GetOpArgs(shard), key, json_path);\n+  };\n+\n+  auto result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n enum ArithmeticOpType { OP_ADD, OP_MULTIPLY };\n@@ -786,95 +680,115 @@ void BinOpApply(double num, bool num_is_double, ArithmeticOpType op, JsonType* v\n   *overflow = false;\n }\n \n-OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key, string_view path,\n-                                    double num, ArithmeticOpType op_type, JsonPathV2 expression) {\n+OpResult<string> OpDoubleArithmetic(const OpArgs& op_args, string_view key,\n+                                    const WrappedJsonPath& json_path, double num,\n+                                    ArithmeticOpType op_type) {\n   bool is_result_overflow = false;\n   double int_part;\n   bool has_fractional_part = (modf(num, &int_part) != 0);\n-  JsonType output(json_array_arg);\n-  OpStatus status;\n \n-  auto cb = [&](optional<string_view>, JsonType* val) {\n+  // Tmp solution with struct CallbackResult, because MutateCallbackResult<std::optional<JsonType>>\n+  // does not compile\n+  struct CallbackResult {\n+    explicit CallbackResult(bool legacy_mode_is_enabled_)\n+        : legacy_mode_is_enabled(legacy_mode_is_enabled_) {\n+      if (!legacy_mode_is_enabled) {\n+        json_value.emplace(jsoncons::json_array_arg);\n+      }\n+    }\n+\n+    void AddValue(JsonType val) {\n+      if (legacy_mode_is_enabled) {\n+        json_value = std::move(val);\n+      } else {\n+        json_value->emplace_back(std::move(val));\n+      }\n+    }\n+\n+    void AddEmptyValue() {\n+      if (!legacy_mode_is_enabled) {\n+        json_value->emplace_back(JsonType::null());\n+      }\n+    }\n+\n+    std::optional<JsonType> json_value;\n+    bool legacy_mode_is_enabled;\n+  };\n+\n+  CallbackResult result{json_path.IsLegacyModePath()};\n+  auto cb = [&](std::optional<std::string_view>, JsonType* val) -> MutateCallbackResult<> {\n     if (val->is_number()) {\n       bool res = false;\n       BinOpApply(num, has_fractional_part, op_type, val, &res);\n       if (res) {\n         is_result_overflow = true;\n       } else {\n-        output.push_back(*val);\n+        result.AddValue(*val);\n+        return {};\n       }\n-    } else {\n-      output.push_back(JsonType::null());\n     }\n-    return false;\n+    result.AddEmptyValue();\n+    return {};\n   };\n \n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& path = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, path, std::move(cb));\n-  } else {\n-    status = UpdateEntry(op_args, key, path, std::move(cb));\n-  }\n+  auto res = UpdateEntry<Nothing>(op_args, key, json_path, std::move(cb));\n \n   if (is_result_overflow)\n     return OpStatus::INVALID_NUMERIC_RESULT;\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n \n-  return output.as_string();\n+  RETURN_ON_BAD_STATUS(res);\n+\n+  if (!result.json_value) {\n+    return OpStatus::WRONG_JSON_TYPE;\n+  }\n+  return result.json_value->as_string();\n }\n \n-// If expression is nullopt, then the whole key should be deleted, otherwise deletes\n-// items specified by the expression/path.\n+// Deletes items specified by the expression/path.\n OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,\n-                     optional<JsonPathV2> expression) {\n-  if (!expression || path.empty()) {\n+                     const WrappedJsonPath& json_path) {\n+  if (json_path.RefersToRootElement()) {\n     auto& db_slice = op_args.GetDbSlice();\n     auto it = db_slice.FindMutable(op_args.db_cntx, key).it;  // post_updater will run immediately\n-    return long(db_slice.Del(op_args.db_cntx, it));\n+    return static_cast<long>(db_slice.Del(op_args.db_cntx, it));\n   }\n-\n   OpResult<JsonType*> result = GetJson(op_args, key);\n   if (!result) {\n     return 0;\n   }\n \n-  if (holds_alternative<json::Path>(*expression)) {\n-    const json::Path& path = get<json::Path>(*expression);\n+  if (json_path.HoldsJsonPath()) {\n+    const json::Path& path = json_path.AsJsonPath();\n     long deletions = json::MutatePath(\n         path, [](optional<string_view>, JsonType* val) { return true; }, *result);\n     return deletions;\n   }\n \n   vector<string> deletion_items;\n-  auto cb = [&](const auto& path, JsonType* val) {\n+  auto cb = [&](std::optional<std::string_view> path, JsonType* val) -> MutateCallbackResult<> {\n     deletion_items.emplace_back(*path);\n-    return false;\n+    return {};\n   };\n \n-  JsonType& json_entry = *(result.value());\n-  error_code ec = JsonReplace(json_entry, path, std::move(cb));\n-  if (ec) {\n-    VLOG(1) << \"Failed to evaluate expression on json with error: \" << ec.message();\n-    return 0;\n-  }\n+  auto res = json_path.Mutate<Nothing>(result.value(), std::move(cb));\n+  RETURN_ON_BAD_STATUS(res);\n \n   if (deletion_items.empty()) {\n     return 0;\n   }\n \n   long total_deletions = 0;\n-  JsonType patch(json_array_arg, {});\n+  JsonType patch(jsoncons::json_array_arg, {});\n   reverse(deletion_items.begin(), deletion_items.end());  // deletion should finish at root keys.\n   for (const auto& item : deletion_items) {\n     string pointer = ConvertToJsonPointer(item);\n     total_deletions++;\n-    JsonType patch_item(json_object_arg, {{\"op\", \"remove\"}, {\"path\", pointer}});\n+    JsonType patch_item(jsoncons::json_object_arg, {{\"op\", \"remove\"}, {\"path\", pointer}});\n     patch.emplace_back(patch_item);\n   }\n \n-  jsonpatch::apply_patch(json_entry, patch, ec);\n+  std::error_code ec;\n+  jsoncons::jsonpatch::apply_patch(*result.value(), patch, ec);\n   if (ec) {\n     VLOG(1) << \"Failed to apply patch on json with error: \" << ec.message();\n     return 0;\n@@ -886,37 +800,26 @@ OpResult<long> OpDel(const OpArgs& op_args, string_view key, string_view path,\n \n // Returns a vector of string vectors,\n // keys within the same object are stored in the same string vector.\n-OpResult<vector<StringVec>> OpObjKeys(const OpArgs& op_args, string_view key,\n-                                      JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  vector<StringVec> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) {\n+auto OpObjKeys(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view& path, const JsonType& val) {\n     // Aligned with ElastiCache flavor.\n     DVLOG(2) << \"path: \" << path << \" val: \" << val.to_string();\n \n-    if (!val.is_object()) {\n-      vec.emplace_back();\n-      return;\n-    }\n-\n-    auto& current_object = vec.emplace_back();\n-    for (const auto& member : val.object_range()) {\n-      current_object.emplace_back(member.key());\n+    StringVec vec;\n+    if (val.is_object()) {\n+      for (const auto& member : val.object_range()) {\n+        vec.emplace_back(member.key());\n+      }\n     }\n+    return vec;\n   };\n-  JsonType& json_entry = *(result.value());\n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-\n-  return vec;\n+  return JsonEvaluateOperation<StringVec>(op_args, key, json_path, std::move(cb), {true, true});\n }\n \n auto OpStrAppend(const OpArgs& op_args, string_view key, const WrappedJsonPath& path,\n                  facade::ArgRange strs) {\n-  auto cb = [&](const auto&, JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {\n+  auto cb = [&](std::optional<std::string_view>,\n+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {\n     if (val->is_string()) {\n       string new_val = val->as_string();\n       for (string_view str : strs) {\n@@ -935,13 +838,13 @@ auto OpStrAppend(const OpArgs& op_args, string_view key, const WrappedJsonPath&\n \n // Returns the numbers of values cleared.\n // Clears containers(arrays or objects) and zeroing numbers.\n-OpResult<long> OpClear(const OpArgs& op_args, string_view key, string_view path,\n-                       JsonPathV2 expression) {\n+OpResult<long> OpClear(const OpArgs& op_args, string_view key, const WrappedJsonPath& path) {\n   long clear_items = 0;\n-  OpStatus status;\n-  auto cb = [&clear_items](const auto& path, JsonType* val) {\n+\n+  auto cb = [&clear_items](std::optional<std::string_view>,\n+                           JsonType* val) -> MutateCallbackResult<> {\n     if (!(val->is_object() || val->is_array() || val->is_number())) {\n-      return false;\n+      return {};\n     }\n \n     if (val->is_object()) {\n@@ -953,92 +856,61 @@ OpResult<long> OpClear(const OpArgs& op_args, string_view key, string_view path,\n     }\n \n     clear_items += 1;\n-    return false;\n+    return {};\n   };\n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& json_path = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, json_path, cb);\n-  } else {\n-    status = UpdateEntry(op_args, key, path, cb);\n-  }\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n+\n+  auto res = UpdateEntry<Nothing>(op_args, key, path, std::move(cb));\n+  RETURN_ON_BAD_STATUS(res);\n   return clear_items;\n }\n \n-void ArrayPop(std::optional<std::string_view>, int index, JsonType* val,\n-              vector<OptString>* result) {\n-  if (!val->is_array() || val->empty()) {\n-    result->emplace_back(nullopt);\n-    return;\n-  }\n-\n-  size_t removal_index;\n-  if (index < 0) {\n-    int temp_index = index + val->size();\n-    removal_index = abs(temp_index);\n-  } else {\n-    removal_index = index;\n-  }\n+// Returns string vector that represents the pop out values.\n+auto OpArrPop(const OpArgs& op_args, string_view key, WrappedJsonPath& path, int index) {\n+  auto cb = [index](std::optional<std::string_view>,\n+                    JsonType* val) -> MutateCallbackResult<std::optional<std::string>> {\n+    if (!val->is_array() || val->empty()) {\n+      return {false, std::nullopt};\n+    }\n \n-  if (removal_index >= val->size()) {\n-    removal_index %= val->size();  // rounded to the array boundaries.\n-  }\n+    size_t removal_index;\n+    if (index < 0) {\n+      int temp_index = index + val->size();\n+      removal_index = abs(temp_index);\n+    } else {\n+      removal_index = index;\n+    }\n \n-  auto it = val->array_range().begin() + removal_index;\n-  string str;\n-  error_code ec;\n-  it->dump(str, {}, ec);\n-  if (ec) {\n-    LOG(ERROR) << \"Failed to dump JSON to string with the error: \" << ec.message();\n-    result->emplace_back(nullopt);\n-    return;\n-  }\n+    if (removal_index >= val->size()) {\n+      removal_index %= val->size();  // rounded to the array boundaries.\n+    }\n \n-  result->push_back(std::move(str));\n-  val->erase(it);\n-  return;\n-};\n+    auto it = val->array_range().begin() + removal_index;\n+    string str;\n+    error_code ec;\n+    it->dump(str, {}, ec);\n+    if (ec) {\n+      LOG(ERROR) << \"Failed to dump JSON to string with the error: \" << ec.message();\n+      return {};\n+    }\n \n-// Returns string vector that represents the pop out values.\n-OpResult<vector<OptString>> OpArrPop(const OpArgs& op_args, string_view key, string_view path,\n-                                     int index, JsonPathV2 expression) {\n-  vector<OptString> vec;\n-  OpStatus status;\n-  auto cb = [&vec, index](optional<string_view>, JsonType* val) {\n-    ArrayPop(nullopt, index, val, &vec);\n-    return false;\n+    val->erase(it);\n+    return {false, std::move(str)};\n   };\n-\n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& json_path = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, json_path, std::move(cb));\n-  } else {\n-    status = UpdateEntry(op_args, key, path, cb);\n-  }\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n-  return vec;\n+  return UpdateEntry<std::optional<std::string>>(op_args, key, path, std::move(cb));\n }\n \n // Returns numeric vector that represents the new length of the array at each path.\n-OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, string_view path,\n-                                     JsonPathV2 expression, int start_index, int stop_index) {\n-  vector<OptSizeT> vec;\n-  OpStatus status;\n-  auto cb = [&](const auto&, JsonType* val) {\n+auto OpArrTrim(const OpArgs& op_args, string_view key, const WrappedJsonPath& path, int start_index,\n+               int stop_index) {\n+  auto cb = [&](std::optional<std::string_view>,\n+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {\n     if (!val->is_array()) {\n-      vec.emplace_back(nullopt);\n-      return false;\n+      return {false, std::nullopt};\n     }\n \n     if (val->empty()) {\n-      vec.emplace_back(0);\n-      return false;\n+      return {false, 0};\n     }\n-\n     size_t trim_start_index;\n     if (start_index < 0) {\n       trim_start_index = 0;\n@@ -1055,8 +927,7 @@ OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, str\n \n     if (trim_start_index >= val->size() || trim_start_index > trim_end_index) {\n       val->erase(val->array_range().begin(), val->array_range().end());\n-      vec.emplace_back(0);\n-      return false;\n+      return {false, 0};\n     }\n \n     auto trim_start_it = std::next(val->array_range().begin(), trim_start_index);\n@@ -1065,62 +936,49 @@ OpResult<vector<OptSizeT>> OpArrTrim(const OpArgs& op_args, string_view key, str\n       trim_end_it = std::next(val->array_range().begin(), trim_end_index + 1);\n     }\n \n-    *val = json_array<JsonType>(trim_start_it, trim_end_it);\n-    vec.emplace_back(val->size());\n-    return false;\n+    *val = jsoncons::json_array<JsonType>(trim_start_it, trim_end_it);\n+    return {false, val->size()};\n   };\n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& json_path = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, json_path, cb);\n-  } else {\n-    status = UpdateEntry(op_args, key, path, cb);\n-  }\n-\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n-  return vec;\n+  return UpdateEntry<std::optional<std::size_t>>(op_args, key, path, std::move(cb));\n }\n \n // Returns numeric vector that represents the new length of the array at each path.\n-OpResult<vector<OptSizeT>> OpArrInsert(const OpArgs& op_args, string_view key, string_view path,\n-                                       JsonPathV2 expression, int index,\n-                                       const vector<JsonType>& new_values) {\n+OpResult<JsonCallbackResult<std::optional<std::size_t>>> OpArrInsert(\n+    const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path, int index,\n+    const vector<JsonType>& new_values) {\n   bool out_of_boundaries_encountered = false;\n-  vector<OptSizeT> vec;\n-  OpStatus status;\n \n   // Insert user-supplied value into the supplied index that should be valid.\n   // If at least one index isn't valid within an array in the json doc, the operation is discarded.\n   // Negative indexes start from the end of the array.\n-  auto cb = [&](const auto&, JsonType* val) {\n+  auto cb = [&](std::optional<std::string_view>,\n+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {\n     if (out_of_boundaries_encountered) {\n-      return false;\n+      return {};\n     }\n \n     if (!val->is_array()) {\n-      vec.emplace_back(nullopt);\n-      return false;\n+      return {false, std::nullopt};\n     }\n \n     size_t removal_index;\n     if (index < 0) {\n       if (val->empty()) {\n         out_of_boundaries_encountered = true;\n-        return false;\n+        return {false, std::nullopt};\n       }\n \n       int temp_index = index + val->size();\n       if (temp_index < 0) {\n         out_of_boundaries_encountered = true;\n-        return false;\n+        return {};\n       }\n \n       removal_index = temp_index;\n     } else {\n       if ((size_t)index > val->size()) {\n         out_of_boundaries_encountered = true;\n-        return false;\n+        return {};\n       }\n \n       removal_index = index;\n@@ -1131,87 +989,43 @@ OpResult<vector<OptSizeT>> OpArrInsert(const OpArgs& op_args, string_view key, s\n       it = val->insert(it, new_val);\n       it++;\n     }\n-\n-    vec.emplace_back(val->size());\n-    return false;\n+    return {false, val->size()};\n   };\n-\n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& json_path = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, json_path, cb);\n-  } else {\n-    status = UpdateEntry(op_args, key, path, cb);\n-  }\n-\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n-\n-  if (out_of_boundaries_encountered) {\n-    return OpStatus::OUT_OF_RANGE;\n-  }\n-\n-  return vec;\n-}\n-\n-// Returns numeric vector that represents the new length of the array at each path, or Null reply\n-// if the matching JSON value is not an array.\n-OpResult<vector<OptSizeT>> OpArrAppend(const OpArgs& op_args, string_view key, string_view path,\n-                                       JsonPathV2 expression,\n-                                       const vector<JsonType>& append_values) {\n-  vector<OptSizeT> vec;\n-  OpStatus status;\n-\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n+\n+  auto res = UpdateEntry<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb));\n+  if (out_of_boundaries_encountered) {\n+    return OpStatus::OUT_OF_RANGE;\n   }\n+  return res;\n+}\n \n-  auto cb = [&](const auto&, JsonType* val) {\n+auto OpArrAppend(const OpArgs& op_args, string_view key, const WrappedJsonPath& path,\n+                 const vector<JsonType>& append_values) {\n+  auto cb = [&](std::optional<std::string_view>,\n+                JsonType* val) -> MutateCallbackResult<std::optional<std::size_t>> {\n     if (!val->is_array()) {\n-      vec.emplace_back(nullopt);\n-      return false;\n+      return {false, std::nullopt};\n     }\n     for (auto& new_val : append_values) {\n       val->emplace_back(new_val);\n     }\n-    vec.emplace_back(val->size());\n-    return false;\n+    return {false, val->size()};\n   };\n-\n-  if (holds_alternative<json::Path>(expression)) {\n-    const json::Path& json_path = std::get<json::Path>(expression);\n-    status = UpdateEntry(op_args, key, json_path, cb);\n-  } else {\n-    status = UpdateEntry(op_args, key, path, cb);\n-  }\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n-\n-  return vec;\n+  return UpdateEntry<std::optional<std::size_t>>(op_args, key, path, std::move(cb));\n }\n \n // Returns a numeric vector representing each JSON value first index of the JSON scalar.\n // An index value of -1 represents unfound in the array.\n // JSON scalar has types of string, boolean, null, and number.\n-OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, JsonPathV2 expression,\n-                                     const JsonType& search_val, int start_index, int end_index) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  vector<OptLong> vec;\n-  auto cb = [&](const string_view& path, const JsonType& val) {\n+auto OpArrIndex(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path,\n+                const JsonType& search_val, int start_index, int end_index) {\n+  auto cb = [&](const string_view&, const JsonType& val) -> std::optional<long> {\n     if (!val.is_array()) {\n-      vec.emplace_back(nullopt);\n-      return;\n+      return std::nullopt;\n     }\n \n     if (val.empty()) {\n-      vec.emplace_back(-1);\n-      return;\n+      return -1;\n     }\n \n     // Negative value or out-of-range index is handled by rounding the index to the array's start\n@@ -1231,8 +1045,7 @@ OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, Jso\n     }\n \n     if (start_index > end_index) {\n-      vec.emplace_back(-1);\n-      return;\n+      return -1;\n     }\n \n     size_t pos = -1;\n@@ -1249,19 +1062,18 @@ OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, Jso\n       }\n     }\n \n-    vec.emplace_back(pos);\n+    return pos;\n   };\n-  JsonType& json_entry = *(result.value());\n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+\n+  return JsonEvaluateOperation<std::optional<long>>(op_args, key, json_path, std::move(cb));\n }\n \n // Returns string vector that represents the query result of each supplied key.\n-vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,\n-                             EngineShard* shard) {\n+std::vector<std::optional<std::string>> OpJsonMGet(const WrappedJsonPath& json_path,\n+                                                   const Transaction* t, EngineShard* shard) {\n   ShardArgs args = t->GetShardArgs(shard->shard_id());\n   DCHECK(!args.Empty());\n-  vector<OptString> response(args.Size());\n+  std::vector<std::optional<std::string>> response(args.Size());\n \n   auto& db_slice = t->GetDbSlice(shard->shard_id());\n   unsigned index = 0;\n@@ -1271,31 +1083,31 @@ vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,\n     if (!it_res.ok())\n       continue;\n \n-    dest.emplace();\n     JsonType* json_val = it_res.value()->second.GetJson();\n     DCHECK(json_val) << \"should have a valid JSON object for key \" << key;\n \n-    vector<JsonType> query_result;\n-    auto cb = [&query_result](const string_view& path, const JsonType& val) {\n-      query_result.push_back(val);\n+    auto cb = [](std::string_view, const JsonType& val) { return val; };\n+\n+    auto eval_wrapped = [&json_val,\n+                         &cb](const WrappedJsonPath& json_path) -> std::optional<JsonType> {\n+      auto eval_result = json_path.Evaluate<JsonType>(json_val, std::move(cb), false);\n+\n+      if (eval_result.IsV1()) {\n+        return eval_result.AsV1();\n+      }\n+\n+      return JsonType{eval_result.AsV2()};\n     };\n \n-    const JsonType& json_entry = *(json_val);\n-    visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n+    auto eval_result = eval_wrapped(json_path);\n \n-    if (query_result.empty()) {\n+    if (!eval_result) {\n       continue;\n     }\n \n-    JsonType arr(json_array_arg);\n-    arr.reserve(query_result.size());\n-    for (auto& s : query_result) {\n-      arr.push_back(s);\n-    }\n-\n-    string str;\n-    error_code ec;\n-    arr.dump(str, {}, ec);\n+    std::string str;\n+    std::error_code ec;\n+    eval_result->dump(str, {}, ec);\n     if (ec) {\n       VLOG(1) << \"Failed to dump JSON array to string with the error: \" << ec.message();\n     }\n@@ -1307,38 +1119,24 @@ vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,\n }\n \n // Returns numeric vector that represents the number of fields of JSON value at each path.\n-OpResult<vector<OptSizeT>> OpFields(const OpArgs& op_args, string_view key, JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  vector<OptSizeT> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) {\n-    vec.emplace_back(CountJsonFields(val));\n+auto OpFields(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view&, const JsonType& val) -> std::optional<std::size_t> {\n+    return CountJsonFields(val);\n   };\n-  const JsonType& json_entry = *(result.value());\n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+\n+  return JsonEvaluateOperation<std::optional<std::size_t>>(op_args, key, json_path, std::move(cb));\n }\n \n // Returns json vector that represents the result of the json query.\n-OpResult<vector<JsonType>> OpResp(const OpArgs& op_args, string_view key, JsonPathV2 expression) {\n-  OpResult<JsonType*> result = GetJson(op_args, key);\n-  if (!result) {\n-    return result.status();\n-  }\n-\n-  vector<JsonType> vec;\n-  auto cb = [&vec](const string_view& path, const JsonType& val) { vec.emplace_back(val); };\n-  const JsonType& json_entry = *(result.value());\n-  visit([&](auto&& arg) { Evaluate(arg, json_entry, cb); }, expression);\n-  return vec;\n+auto OpResp(const OpArgs& op_args, string_view key, const WrappedJsonPath& json_path) {\n+  auto cb = [](const string_view&, const JsonType& val) { return val; };\n+  return JsonEvaluateOperation<JsonType>(op_args, key, json_path, std::move(cb));\n }\n \n // Returns boolean that represents the result of the operation.\n OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n-                     std::string_view json_str, bool is_nx_condition, bool is_xx_condition) {\n+                     const WrappedJsonPath& json_path, std::string_view json_str,\n+                     bool is_nx_condition, bool is_xx_condition) {\n   std::optional<JsonType> parsed_json = JsonFromString(json_str);\n   if (!parsed_json) {\n     VLOG(1) << \"got invalid JSON string '\" << json_str << \"' cannot be saved\";\n@@ -1349,7 +1147,7 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n   // NOTE: unlike in Redis, we are overriding the value when the path is \"$\"\n   // this is regardless of the current key type. In redis if the key exists\n   // and its not JSON, it would return an error.\n-  if (path == \".\" || path == \"$\") {\n+  if (json_path.RefersToRootElement()) {\n     if (is_nx_condition || is_xx_condition) {\n       auto it_res = op_args.GetDbSlice().FindReadOnly(op_args.db_cntx, key, OBJ_JSON);\n       bool key_exists = (it_res.status() != OpStatus::KEY_NOTFOUND);\n@@ -1377,13 +1175,13 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n   bool path_exists = false;\n   bool operation_result = false;\n   const JsonType& new_json = parsed_json.value();\n-  auto cb = [&](const auto&, JsonType* val) {\n+  auto cb = [&](std::optional<std::string_view>, JsonType* val) -> MutateCallbackResult<> {\n     path_exists = true;\n     if (!is_nx_condition) {\n       operation_result = true;\n       *val = new_json;\n     }\n-    return false;\n+    return {};\n   };\n \n   auto inserter = [&](JsonType& json) {\n@@ -1397,7 +1195,7 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n       }\n \n       error_code ec;\n-      jsonpointer::add(json, pointer, new_json, ec);\n+      jsoncons::jsonpointer::add(json, pointer, new_json, ec);\n       if (ec) {\n         VLOG(1) << \"Failed to add a JSON value to the following path: \" << path\n                 << \" with the error: \" << ec.message();\n@@ -1410,14 +1208,21 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n     return OpStatus::OK;\n   };\n \n-  OpStatus status = UpdateEntry(op_args, key, path, cb, inserter);\n-  if (status != OpStatus::OK) {\n-    return status;\n-  }\n-\n+  auto res = UpdateEntry<Nothing>(op_args, key, json_path, std::move(cb), inserter);\n+  RETURN_ON_BAD_STATUS(res);\n   return operation_result;\n }\n \n+OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n+                     std::string_view json_str, bool is_nx_condition, bool is_xx_condition) {\n+  auto res_json_path = ParseJsonPath(path);\n+  if (!res_json_path) {\n+    return OpStatus::SYNTAX_ERR;  // TODO(Return initial error)\n+  }\n+  return OpSet(op_args, key, path, res_json_path.value(), json_str, is_nx_condition,\n+               is_xx_condition);\n+}\n+\n OpStatus OpMSet(const OpArgs& op_args, const ShardArgs& args) {\n   DCHECK_EQ(args.Size() % 3, 0u);\n \n@@ -1454,15 +1259,17 @@ OpStatus OpMSet(const OpArgs& op_args, const ShardArgs& args) {\n \n // Note that currently OpMerge works only with jsoncons and json::Path support has not been\n // implemented yet.\n-OpStatus OpMerge(const OpArgs& op_args, string_view key, JsonPathV2 expression, string_view path,\n-                 std::string_view json_str) {\n+OpStatus OpMerge(const OpArgs& op_args, string_view key, string_view path,\n+                 const WrappedJsonPath& json_path, std::string_view json_str) {\n+  // DCHECK(!json_path.HoldsJsonPath());\n+\n   std::optional<JsonType> parsed_json = JsonFromString(json_str);\n   if (!parsed_json) {\n     VLOG(1) << \"got invalid JSON string '\" << json_str << \"' cannot be saved\";\n     return OpStatus::SYNTAX_ERR;\n   }\n \n-  auto cb = [&](optional<string_view> cur_path, JsonType* val) {\n+  auto cb = [&](std::optional<std::string_view> cur_path, JsonType* val) -> MutateCallbackResult<> {\n     string_view strpath = cur_path ? *cur_path : string_view{};\n \n     DVLOG(2) << \"Handling \" << strpath << \" \" << val->to_string();\n@@ -1472,80 +1279,38 @@ OpStatus OpMerge(const OpArgs& op_args, string_view key, JsonPathV2 expression,\n     } catch (const std::exception& e) {\n       LOG_EVERY_T(ERROR, 1) << \"Exception in OpMerge: \" << e.what() << \" with obj: \" << *val\n                             << \" and patch: \" << *parsed_json << \", path: \" << strpath;\n-      return false;\n     }\n \n-    return false;\n+    return {};\n   };\n \n-  OpStatus status = UpdateEntry(op_args, key, path, cb);\n-  if (status != OpStatus::KEY_NOTFOUND)\n-    return status;\n-\n-  if (path == \"$\") {\n-    // Add a new key.\n-    return OpSet(op_args, key, \"$\", json_str, false, false).status();\n-  }\n-  return OpStatus::SYNTAX_ERR;\n-}\n+  auto res = UpdateEntry<Nothing>(op_args, key, json_path, std::move(cb));\n \n-io::Result<JsonPathV2, string> ParsePathV2(string_view path) {\n-  // We expect all valid paths to start with the root selector, otherwise prepend it\n-  string tmp_buf;\n-  if (!path.empty() && path.front() != '$') {\n-    tmp_buf = absl::StrCat(\"$\", path.front() != '.' ? \".\" : \"\", path);\n-    path = tmp_buf;\n-  }\n+  if (res.status() != OpStatus::KEY_NOTFOUND)\n+    return res.status();\n \n-  if (absl::GetFlag(FLAGS_jsonpathv2)) {\n-    auto path_result = json::ParsePath(path);\n-    if (!path_result) {\n-      VLOG(1) << \"Invalid Json path: \" << path << ' ' << path_result.error() << std::endl;\n-      return nonstd::make_unexpected(kSyntaxErr);\n-    }\n-    return path_result;\n-  }\n-  io::Result<JsonExpression> expr_result = ParseJsonPath(path);\n-  if (!expr_result) {\n-    VLOG(1) << \"Invalid Json path: \" << path << ' ' << expr_result.error() << std::endl;\n-    return nonstd::make_unexpected(kSyntaxErr);\n+  if (json_path.RefersToRootElement()) {\n+    return OpSet(op_args, key, path, json_path, json_str, false, false).status();\n   }\n-  return JsonPathV2(std::move(expr_result.value()));\n+  return OpStatus::SYNTAX_ERR;\n }\n \n }  // namespace\n \n-#define PARSE_PATHV2(path)             \\\n-  ({                                   \\\n-    auto result = ParsePathV2(path);   \\\n-    if (!result) {                     \\\n-      cntx->SendError(result.error()); \\\n-      return;                          \\\n-    }                                  \\\n-    std::move(*result);                \\\n-  })\n-\n void JsonFamily::Set(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n-  string_view json_str = ArgS(args, 2);\n-  bool is_nx_condition = false;\n-  bool is_xx_condition = false;\n-  string_view operation_opts;\n-  if (args.size() > 3) {\n-    operation_opts = ArgS(args, 3);\n-    if (absl::EqualsIgnoreCase(operation_opts, \"NX\")) {\n-      is_nx_condition = true;\n-    } else if (absl::EqualsIgnoreCase(operation_opts, \"XX\")) {\n-      is_xx_condition = true;\n-    } else {\n-      cntx->SendError(kSyntaxErr);\n-      return;\n-    }\n-  }\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.Next();\n+  string_view json_str = parser.Next();\n+\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n+\n+  bool is_nx_condition = static_cast<bool>(parser.Check(\"NX\"));\n+  bool is_xx_condition = static_cast<bool>(parser.Check(\"XX\"));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpSet(t->GetOpArgs(shard), key, path, json_str, is_nx_condition, is_xx_condition);\n+    return OpSet(t->GetOpArgs(shard), key, path, json_path, json_str, is_nx_condition,\n+                 is_xx_condition);\n   };\n \n   Transaction* trans = cntx->transaction;\n@@ -1590,52 +1355,44 @@ void JsonFamily::MSet(CmdArgList args, ConnectionContext* cntx) {\n // JSON.MERGE key path value\n // Based on https://datatracker.ietf.org/doc/html/rfc7386 spec\n void JsonFamily::Merge(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n-  string_view value = ArgS(args, 2);\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.Next();\n+  string_view value = parser.Next();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpMerge(t->GetOpArgs(shard), key, std::move(expression), path, value);\n+    return OpMerge(t->GetOpArgs(shard), key, path, json_path, value);\n   };\n \n-  OpStatus status = cntx->transaction->ScheduleSingleHop(cb);\n+  OpStatus status = cntx->transaction->ScheduleSingleHop(std::move(cb));\n   if (status == OpStatus::OK)\n     return cntx->SendOk();\n   cntx->SendError(status);\n }\n \n void JsonFamily::Resp(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = DefaultJsonPath;\n-  if (args.size() > 1) {\n-    path = ArgS(args, 1);\n-  }\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpResp(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpResp(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<JsonType>> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  if (result) {\n-    rb->StartArray(result->size());\n-    for (const auto& it : *result) {\n-      SendJsonValue(rb, it);\n-    }\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::Debug(CmdArgList args, ConnectionContext* cntx) {\n-  function<decltype(OpFields)> func;\n-  string_view command = ArgS(args, 0);\n+  CmdArgParser parser{args};\n+  string_view command = parser.Next();\n+\n   // The 'MEMORY' sub-command is not supported yet, calling to operation function should be added\n   // here.\n   if (absl::EqualsIgnoreCase(command, \"help\")) {\n@@ -1645,62 +1402,53 @@ void JsonFamily::Debug(CmdArgList args, ConnectionContext* cntx) {\n         \"JSON.DEBUG FIELDS <key> <path> - report number of fields in the JSON element.\");\n     rb->SendBulkString(\"JSON.DEBUG HELP - print help message.\");\n     return;\n-\n-  } else if (absl::EqualsIgnoreCase(command, \"fields\")) {\n-    func = &OpFields;\n-  } else {\n+  } else if (!absl::EqualsIgnoreCase(command, \"fields\")) {\n     cntx->SendError(facade::UnknownSubCmd(command, \"JSON.DEBUG\"), facade::kSyntaxErrType);\n     return;\n   }\n \n-  if (args.size() < 3) {\n-    cntx->SendError(facade::WrongNumArgsError(cntx->cid->name()), facade::kSyntaxErrType);\n-    return;\n-  }\n+  // JSON.DEBUG FIELDS\n+\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  string_view key = ArgS(args, 1);\n-  string_view path = ArgS(args, 2);\n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return func(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpFields(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {\n   DCHECK_GE(args.size(), 1U);\n \n   string_view path = ArgS(args, args.size() - 1);\n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   Transaction* transaction = cntx->transaction;\n   unsigned shard_count = shard_set->size();\n-  std::vector<vector<OptString>> mget_resp(shard_count);\n+  std::vector<std::vector<std::optional<std::string>>> mget_resp(shard_count);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     ShardId sid = shard->shard_id();\n-    mget_resp[sid] = OpJsonMGet(expression, t, shard);\n+    mget_resp[sid] = OpJsonMGet(json_path, t, shard);\n     return OpStatus::OK;\n   };\n \n   OpStatus result = transaction->ScheduleSingleHop(std::move(cb));\n   CHECK_EQ(OpStatus::OK, result);\n \n-  std::vector<OptString> results(args.size() - 1);\n+  std::vector<std::optional<std::string>> results(args.size() - 1);\n   for (ShardId sid = 0; sid < shard_count; ++sid) {\n     if (!transaction->IsActive(sid))\n       continue;\n \n-    vector<OptString>& res = mget_resp[sid];\n+    std::vector<std::optional<std::string>>& res = mget_resp[sid];\n     ShardArgs shard_args = transaction->GetShardArgs(sid);\n     unsigned src_index = 0;\n     for (auto it = shard_args.begin(); it != shard_args.end(); ++it, ++src_index) {\n@@ -1713,21 +1461,14 @@ void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  rb->StartArray(results.size());\n-  for (auto& it : results) {\n-    if (!it) {\n-      rb->SendNull();\n-    } else {\n-      rb->SendBulkString(*it);\n-    }\n-  }\n+  reply_generic::Send(results, rb);\n }\n \n void JsonFamily::ArrIndex(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n   string_view path = ArgS(args, 1);\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   optional<JsonType> search_value = JsonFromString(ArgS(args, 2));\n   if (!search_value) {\n@@ -1759,18 +1500,13 @@ void JsonFamily::ArrIndex(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpArrIndex(t->GetOpArgs(shard), key, std::move(expression), *search_value, start_index,\n-                      end_index);\n+    return OpArrIndex(t->GetOpArgs(shard), key, json_path, *search_value, start_index, end_index);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptLong>> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::ArrInsert(CmdArgList args, ConnectionContext* cntx) {\n@@ -1784,7 +1520,7 @@ void JsonFamily::ArrInsert(CmdArgList args, ConnectionContext* cntx) {\n     return;\n   }\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   vector<JsonType> new_values;\n   for (size_t i = 3; i < args.size(); i++) {\n@@ -1798,23 +1534,20 @@ void JsonFamily::ArrInsert(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpArrInsert(t->GetOpArgs(shard), key, path, std::move(expression), index, new_values);\n+    return OpArrInsert(t->GetOpArgs(shard), key, json_path, index, new_values);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::ArrAppend(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n   string_view path = ArgS(args, 1);\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   vector<JsonType> append_values;\n \n@@ -1830,16 +1563,13 @@ void JsonFamily::ArrAppend(CmdArgList args, ConnectionContext* cntx) {\n   }\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpArrAppend(t->GetOpArgs(shard), key, path, std::move(expression), append_values);\n+    return OpArrAppend(t->GetOpArgs(shard), key, json_path, append_values);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::ArrTrim(CmdArgList args, ConnectionContext* cntx) {\n@@ -1865,82 +1595,58 @@ void JsonFamily::ArrTrim(CmdArgList args, ConnectionContext* cntx) {\n     return;\n   }\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpArrTrim(t->GetOpArgs(shard), key, path, std::move(expression), start_index,\n-                     stop_index);\n+    return OpArrTrim(t->GetOpArgs(shard), key, json_path, start_index, stop_index);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::ArrPop(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n-  int index = -1;\n-\n-  if (args.size() >= 3) {\n-    if (!absl::SimpleAtoi(ArgS(args, 2), &index)) {\n-      VLOG(1) << \"Failed to convert the following value to numeric, pop out the last item\"\n-              << ArgS(args, 2);\n-    }\n-  }\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n+  int index = parser.NextOrDefault<int>(-1);\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpArrPop(t->GetOpArgs(shard), key, path, index, std::move(expression));\n+    return OpArrPop(t->GetOpArgs(shard), key, json_path, index);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptString>> result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  if (result) {\n-    rb->StartArray(result->size());\n-    for (auto& it : *result) {\n-      if (!it) {\n-        rb->SendNull();\n-      } else {\n-        rb->SendSimpleString(*it);\n-      }\n-    }\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::Clear(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpClear(t->GetOpArgs(shard), key, path, std::move(expression));\n+    return OpClear(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n   OpResult<long> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    cntx->SendLong(*result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::StrAppend(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n   string_view path = ArgS(args, 1);\n \n-  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(json_parser::ParseJsonPath(path));\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n   auto strs = args.subspan(2);\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -1954,57 +1660,37 @@ void JsonFamily::StrAppend(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void JsonFamily::ObjKeys(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = \"$\";\n-  if (args.size() == 2) {\n-    path = ArgS(args, 1);\n-  }\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpObjKeys(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpObjKeys(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<StringVec>> result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  if (result) {\n-    rb->StartArray(result->size());\n-    for (auto& it : *result) {\n-      if (it.empty()) {\n-        rb->SendNullArray();\n-      } else {\n-        rb->SendStringArr(it);\n-      }\n-    }\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::Del(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path;\n-\n-  optional<JsonPathV2> expression;\n-\n-  if (args.size() > 1) {\n-    path = ArgS(args, 1);\n-    expression.emplace(PARSE_PATHV2(path));\n-  }\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  if (path == \"$\" || path == \".\") {\n-    path = \"\"sv;\n-  }\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpDel(t->GetOpArgs(shard), key, path, std::move(expression));\n+    return OpDel(t->GetOpArgs(shard), key, path, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n   OpResult<long> result = trans->ScheduleSingleHopT(std::move(cb));\n-  cntx->SendLong(*result);\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {\n@@ -2018,20 +1704,15 @@ void JsonFamily::NumIncrBy(CmdArgList args, ConnectionContext* cntx) {\n     return;\n   }\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, OP_ADD, std::move(expression));\n+    return OpDoubleArithmetic(t->GetOpArgs(shard), key, json_path, dnum, OP_ADD);\n   };\n \n   OpResult<string> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-\n-  if (result) {\n-    rb->SendBulkString(*result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::NumMultBy(CmdArgList args, ConnectionContext* cntx) {\n@@ -2045,130 +1726,97 @@ void JsonFamily::NumMultBy(CmdArgList args, ConnectionContext* cntx) {\n     return;\n   }\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpDoubleArithmetic(t->GetOpArgs(shard), key, path, dnum, OP_MULTIPLY,\n-                              std::move(expression));\n+    return OpDoubleArithmetic(t->GetOpArgs(shard), key, json_path, dnum, OP_MULTIPLY);\n   };\n \n-  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   OpResult<string> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    rb->SendBulkString(*result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::Toggle(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n-\n-  JsonPathV2 expression = PARSE_PATHV2(path);\n-\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpToggle(t->GetOpArgs(shard), key, path, std::move(expression));\n-  };\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptBool>> result = trans->ScheduleSingleHopT(std::move(cb));\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n-  if (result) {\n-    PrintOptVec(cntx, result);\n+  if (json_path.IsLegacyModePath()) {\n+    ExecuteToggle<bool>(key, json_path, cntx);\n   } else {\n-    cntx->SendError(result.status());\n+    ExecuteToggle<long>(key, json_path, cntx);\n   }\n }\n \n void JsonFamily::Type(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpType(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpType(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<string>> result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n-  if (result) {\n-    if (result->empty()) {\n-      // When vector is empty, the path doesn't exist in the corresponding json.\n-      rb->SendNull();\n-    } else {\n-      rb->SendStringArr(*result);\n-    }\n-  } else {\n-    if (result.status() == OpStatus::KEY_NOTFOUND) {\n-      rb->SendNullArray();\n-    } else {\n-      cntx->SendError(result.status());\n-    }\n-  }\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::ArrLen(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpArrLen(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpArrLen(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::ObjLen(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpObjLen(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpObjLen(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::StrLen(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 0);\n-  string_view path = ArgS(args, 1);\n+  CmdArgParser parser{args};\n+  string_view key = parser.Next();\n+  string_view path = parser.NextOrDefault();\n \n-  JsonPathV2 expression = PARSE_PATHV2(path);\n+  WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path));\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpStrLen(t->GetOpArgs(shard), key, std::move(expression));\n+    return OpStrLen(t->GetOpArgs(shard), key, json_path);\n   };\n \n   Transaction* trans = cntx->transaction;\n-  OpResult<vector<OptSizeT>> result = trans->ScheduleSingleHopT(std::move(cb));\n-\n-  if (result) {\n-    PrintOptVec(cntx, result);\n-  } else {\n-    cntx->SendError(result.status());\n-  }\n+  auto result = trans->ScheduleSingleHopT(std::move(cb));\n+  auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n+  reply_generic::Send(result, rb);\n }\n \n void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n@@ -2177,9 +1825,9 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n   facade::CmdArgParser parser{args};\n   string_view key = parser.Next();\n \n-  OptString indent;\n-  OptString new_line;\n-  OptString space;\n+  std::optional<std::string> indent;\n+  std::optional<std::string> new_line;\n+  std::optional<std::string> space;\n \n   vector<pair<string_view, WrappedJsonPath>> paths;\n \n@@ -2198,7 +1846,7 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n     }\n \n     string_view path_str = parser.Next();\n-    WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(json_parser::ParseJsonPath(path_str));\n+    WrappedJsonPath json_path = GET_OR_SEND_UNEXPECTED(ParseJsonPath(path_str));\n \n     paths.emplace_back(path_str, std::move(json_path));\n   }\n@@ -2238,11 +1886,11 @@ void JsonFamily::Register(CommandRegistry* registry) {\n   registry->StartFamily();\n   *registry << CI{\"JSON.GET\", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Get);\n   *registry << CI{\"JSON.MGET\", CO::READONLY | CO::FAST, -3, 1, -2, acl::JSON}.HFUNC(MGet);\n-  *registry << CI{\"JSON.TYPE\", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(Type);\n-  *registry << CI{\"JSON.STRLEN\", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(StrLen);\n-  *registry << CI{\"JSON.OBJLEN\", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(ObjLen);\n-  *registry << CI{\"JSON.ARRLEN\", CO::READONLY | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(ArrLen);\n-  *registry << CI{\"JSON.TOGGLE\", CO::WRITE | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(Toggle);\n+  *registry << CI{\"JSON.TYPE\", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Type);\n+  *registry << CI{\"JSON.STRLEN\", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(StrLen);\n+  *registry << CI{\"JSON.OBJLEN\", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ObjLen);\n+  *registry << CI{\"JSON.ARRLEN\", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ArrLen);\n+  *registry << CI{\"JSON.TOGGLE\", CO::WRITE | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Toggle);\n   *registry << CI{\"JSON.NUMINCRBY\", CO::WRITE | CO::FAST, 4, 1, 1, acl::JSON}.HFUNC(NumIncrBy);\n   *registry << CI{\"JSON.NUMMULTBY\", CO::WRITE | CO::FAST, 4, 1, 1, acl::JSON}.HFUNC(NumMultBy);\n   *registry << CI{\"JSON.DEL\", CO::WRITE, -2, 1, 1, acl::JSON}.HFUNC(Del);\n@@ -2251,8 +1899,8 @@ void JsonFamily::Register(CommandRegistry* registry) {\n   *registry << CI{\"JSON.OBJKEYS\", CO::READONLY | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ObjKeys);\n   *registry << CI{\"JSON.STRAPPEND\", CO::WRITE | CO::DENYOOM | CO::FAST, -4, 1, 1, acl::JSON}.HFUNC(\n       StrAppend);\n-  *registry << CI{\"JSON.CLEAR\", CO::WRITE | CO::FAST, 3, 1, 1, acl::JSON}.HFUNC(Clear);\n-  *registry << CI{\"JSON.ARRPOP\", CO::WRITE | CO::FAST, -3, 1, 1, acl::JSON}.HFUNC(ArrPop);\n+  *registry << CI{\"JSON.CLEAR\", CO::WRITE | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(Clear);\n+  *registry << CI{\"JSON.ARRPOP\", CO::WRITE | CO::FAST, -2, 1, 1, acl::JSON}.HFUNC(ArrPop);\n   *registry << CI{\"JSON.ARRTRIM\", CO::WRITE | CO::FAST, 5, 1, 1, acl::JSON}.HFUNC(ArrTrim);\n   *registry << CI{\"JSON.ARRINSERT\", CO::WRITE | CO::DENYOOM | CO::FAST, -4, 1, 1, acl::JSON}.HFUNC(\n       ArrInsert);\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex 3e54e3afa889..ccad32429088 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -24,6 +24,36 @@ class JsonFamilyTest : public BaseFamilyTest {\n  protected:\n };\n \n+MATCHER_P(ElementsAreArraysMatcher, matchers, \"\") {\n+  const auto& vec = arg.GetVec();\n+  const size_t expected_size = std::tuple_size<decltype(matchers)>::value;\n+\n+  if (vec.size() != expected_size) {\n+    *result_listener << \"size mismatch: expected \" << expected_size << \" but got \" << vec.size();\n+    return false;\n+  }\n+\n+  bool result = true;\n+  size_t index = 0;\n+\n+  auto check_matcher = [&](const auto& matcher) {\n+    if (!ExplainMatchResult(matcher, vec[index].GetVec(), result_listener)) {\n+      *result_listener << \" at index \" << index;\n+      result = false;\n+    }\n+    index++;\n+  };\n+\n+  std::apply([&check_matcher](const auto&... matchers) { (check_matcher(matchers), ...); },\n+             matchers);\n+\n+  return result;\n+}\n+\n+template <typename... Matchers> auto ElementsAreArrays(Matchers&&... matchers) {\n+  return ElementsAreArraysMatcher(std::make_tuple(std::forward<Matchers>(matchers)...));\n+}\n+\n TEST_F(JsonFamilyTest, SetGetBasic) {\n   string json = R\"(\n     {\n@@ -88,6 +118,9 @@ TEST_F(JsonFamilyTest, GetLegacy) {\n   auto resp = Run({\"JSON.SET\", \"json\", \"$\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n+  resp = Run({\"JSON.GET\", \"json\"});  // V1 Response\n+  ASSERT_THAT(resp, \"{\\\"lastSeen\\\":1478476800,\\\"loggedOut\\\":true,\\\"name\\\":\\\"Leonard Cohen\\\"}\");\n+\n   resp = Run({\"JSON.GET\", \"json\", \".\"});  // V1 Response\n   ASSERT_THAT(resp, \"{\\\"lastSeen\\\":1478476800,\\\"loggedOut\\\":true,\\\"name\\\":\\\"Leonard Cohen\\\"}\");\n \n@@ -203,10 +236,53 @@ TEST_F(JsonFamilyTest, Type) {\n                                           \"object\", \"array\")));\n \n   resp = Run({\"JSON.TYPE\", \"json\", \"$[10]\"});\n-  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n \n   resp = Run({\"JSON.TYPE\", \"not_exist_key\", \"$[10]\"});\n-  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+}\n+\n+TEST_F(JsonFamilyTest, TypeLegacy) {\n+  string json = R\"(\n+    {\n+      \"firstName\":\"John\",\n+      \"lastName\":\"Smith\",\n+      \"age\":27,\n+      \"weight\":135.25,\n+      \"isAlive\":true,\n+      \"address\":{\"street\":\"21 2nd Street\",\"city\":\"New York\",\"state\":\"NY\",\"zipcode\":\"10021-3100\"},\n+      \"phoneNumbers\":[{\"type\":\"home\",\"number\":\"212 555-1234\"},{\"type\":\"office\",\"number\":\"646 555-4567\"}],\n+      \"children\":[],\n+      \"spouse\":null\n+    }\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\"});\n+  EXPECT_EQ(resp, \"object\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\", \".children\"});\n+  EXPECT_EQ(resp, \"array\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\", \".firstName\"});\n+  EXPECT_EQ(resp, \"string\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\", \".age\"});\n+  EXPECT_EQ(resp, \"integer\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\", \".weight\"});\n+  EXPECT_EQ(resp, \"number\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\", \".isAlive\"});\n+  EXPECT_EQ(resp, \"boolean\");\n+\n+  resp = Run({\"JSON.TYPE\", \"json\", \".spouse\"});\n+  EXPECT_EQ(resp, \"null\");\n+\n+  resp = Run({\"JSON.TYPE\", \"not_exist_key\", \".some_field\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n }\n \n TEST_F(JsonFamilyTest, StrLen) {\n@@ -217,25 +293,78 @@ TEST_F(JsonFamilyTest, StrLen) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n+  /* Test simple response from only one value */\n+\n   resp = Run({\"JSON.STRLEN\", \"json\", \"$.a.a\"});\n   EXPECT_THAT(resp, IntArg(1));\n \n+  resp = Run({\"JSON.STRLEN\", \"json\", \"$.a\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n   resp = Run({\"JSON.STRLEN\", \"json\", \"$.a.*\"});\n   EXPECT_THAT(resp, IntArg(1));\n \n+  resp = Run({\"JSON.STRLEN\", \"json\", \"$.c.b\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.STRLEN\", \"non_existent_key\", \"$.c.b\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  /*\n+  Test response from several possible values\n+  In JSON V2, the response is an array of all possible values\n+  */\n+\n   resp = Run({\"JSON.STRLEN\", \"json\", \"$.c.*\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(), ElementsAre(IntArg(1), IntArg(2)));\n \n-  resp = Run({\"JSON.STRLEN\", \"json\", \"$.c.b\"});\n-  EXPECT_THAT(resp, IntArg(2));\n-\n   resp = Run({\"JSON.STRLEN\", \"json\", \"$.d.*\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(),\n               ElementsAre(ArgType(RespExpr::NIL), IntArg(1), ArgType(RespExpr::NIL)));\n }\n \n+TEST_F(JsonFamilyTest, StrLenLegacy) {\n+  string json = R\"(\n+    {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"bb\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  /* Test simple response from only one value */\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\", \".a.a\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\", \".a\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\", \".a.*\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\", \".c.b\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.STRLEN\", \"non_existent_key\", \".c.b\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  /*\n+  Test response from several possible values\n+  In JSON legacy mode, the response contains only one value - the first string's length.\n+  */\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\", \".c.*\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\", \".d.*\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+}\n+\n TEST_F(JsonFamilyTest, ObjLen) {\n   string json = R\"(\n     {\"a\":{}, \"b\":{\"a\":\"a\"}, \"c\":{\"a\":\"a\", \"b\":\"bb\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":{\"a\":3,\"b\":4}}, \"e\":1}\n@@ -244,11 +373,13 @@ TEST_F(JsonFamilyTest, ObjLen) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n+  /* Test simple response from only one value */\n+\n   resp = Run({\"JSON.OBJLEN\", \"json\", \"$.a\"});\n   EXPECT_THAT(resp, IntArg(0));\n \n   resp = Run({\"JSON.OBJLEN\", \"json\", \"$.a.*\"});\n-  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n \n   resp = Run({\"JSON.OBJLEN\", \"json\", \"$.b\"});\n   EXPECT_THAT(resp, IntArg(1));\n@@ -259,13 +390,21 @@ TEST_F(JsonFamilyTest, ObjLen) {\n   resp = Run({\"JSON.OBJLEN\", \"json\", \"$.c\"});\n   EXPECT_THAT(resp, IntArg(2));\n \n+  resp = Run({\"JSON.OBJLEN\", \"json\", \"$.d\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"non_existent_key\", \"$.a\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  /*\n+  Test response from several possible values\n+  In JSON V2, the response is an array of all possible values\n+  */\n+\n   resp = Run({\"JSON.OBJLEN\", \"json\", \"$.c.*\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(), ElementsAre(ArgType(RespExpr::NIL), ArgType(RespExpr::NIL)));\n \n-  resp = Run({\"JSON.OBJLEN\", \"json\", \"$.d\"});\n-  EXPECT_THAT(resp, IntArg(3));\n-\n   resp = Run({\"JSON.OBJLEN\", \"json\", \"$.d.*\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(),\n@@ -277,6 +416,55 @@ TEST_F(JsonFamilyTest, ObjLen) {\n               ElementsAre(IntArg(0), IntArg(1), IntArg(2), IntArg(3), ArgType(RespExpr::NIL)));\n }\n \n+TEST_F(JsonFamilyTest, ObjLenLegacy) {\n+  string json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":\"a\"}, \"c\":{\"a\":\"a\", \"b\":\"bb\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":{\"a\":3,\"b\":4}}, \"e\":1}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  /* Test simple response from only one value */\n+\n+  resp = Run({\"JSON.STRLEN\", \"json\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".a\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".a.*\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".b\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".b.*\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".c\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".d\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"non_existent_key\", \".a\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  /*\n+  Test response from several possible values\n+  In JSON legacy mode, the response contains only one value - the first object's length.\n+  */\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".c.*\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".d.*\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"json\", \".*\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+}\n+\n TEST_F(JsonFamilyTest, ArrLen) {\n   string json = R\"(\n     [[], [\"a\"], [\"a\", \"b\"], [\"a\", \"b\", \"c\"]]\n@@ -300,6 +488,46 @@ TEST_F(JsonFamilyTest, ArrLen) {\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(), ElementsAre(IntArg(0), ArgType(RespExpr::NIL), IntArg(2), IntArg(3),\n                                          ArgType(RespExpr::NIL)));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"non_existent_key\", \"$[*]\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+}\n+\n+TEST_F(JsonFamilyTest, ArrLenLegacy) {\n+  string json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"], [\"a\", \"b\", \"c\"]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRLEN\", \"json\"});\n+  EXPECT_THAT(resp, IntArg(4));\n+\n+  resp = Run({\"JSON.ARRLEN\", \"json\", \"[*]\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  resp = Run({\"JSON.ARRLEN\", \"json\", \"[3]\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  json = R\"(\n+    [[], \"a\", [\"a\", \"b\"], [\"a\", \"b\", \"c\"], 4]\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRLEN\", \"json\", \"[*]\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  resp = Run({\"JSON.ARRLEN\", \"json\", \"[1]\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.ARRLEN\", \"json\", \"[2]\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.OBJLEN\", \"non_existent_key\", \"[*]\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n }\n \n TEST_F(JsonFamilyTest, Toggle) {\n@@ -310,9 +538,6 @@ TEST_F(JsonFamilyTest, Toggle) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(R\"([true,false,1,null,\"foo\",[],{}])\", resp);\n-\n   resp = Run({\"JSON.TOGGLE\", \"json\", \"$.*\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   EXPECT_THAT(resp.GetVec(),\n@@ -332,6 +557,49 @@ TEST_F(JsonFamilyTest, Toggle) {\n   EXPECT_EQ(resp, R\"([true,false,1,null,\"foo\",[],{}])\");\n }\n \n+TEST_F(JsonFamilyTest, ToggleLegacy) {\n+  string json = R\"(\n+    {\"a\":true, \"b\":false, \"c\":1, \"d\":null, \"e\":\"foo\", \"f\":[], \"g\":{}}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\", \".*\"});\n+  EXPECT_EQ(resp, \"true\");\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\", \".*\"});\n+  EXPECT_EQ(resp, \"false\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(R\"([true,false,1,null,\"foo\",[],{}])\", resp);\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", \"true\"});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\", \".\"});\n+  EXPECT_EQ(resp, \"false\");\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\", \".\"});\n+  EXPECT_EQ(resp, \"true\");\n+\n+  json = R\"(\n+    {\"isAvailable\": false}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\", \".isAvailable\"});\n+  EXPECT_EQ(resp, \"true\");\n+\n+  resp = Run({\"JSON.TOGGLE\", \"json\", \".isAvailable\"});\n+  EXPECT_EQ(resp, \"false\");\n+}\n+\n TEST_F(JsonFamilyTest, NumIncrBy) {\n   string json = R\"(\n     {\"e\":1.5,\"a\":1}\n@@ -349,10 +617,6 @@ TEST_F(JsonFamilyTest, NumIncrBy) {\n   resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.e\", \"inf\"});\n   EXPECT_THAT(resp, ErrArg(\"ERR result is not a number\"));\n \n-  json = R\"(\n-    {\"e\":1.5,\"a\":1}\n-  )\";\n-\n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n@@ -378,10 +642,6 @@ TEST_F(JsonFamilyTest, NumIncrBy) {\n   resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n   EXPECT_EQ(resp, \"[11,12,13]\");\n \n-  json = R\"(\n-    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n-  )\";\n-\n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n@@ -400,8 +660,8 @@ TEST_F(JsonFamilyTest, NumIncrBy) {\n   resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d[2]\", \"1\"});\n   EXPECT_EQ(resp, \"[5]\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(resp, R\"([[],[2],[2,3],[2,3,5]])\");\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[],\"b\":[2],\"c\":[2,3],\"d\":[2,3,5]})\");\n \n   json = R\"(\n     {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}}\n@@ -422,8 +682,8 @@ TEST_F(JsonFamilyTest, NumIncrBy) {\n   resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d.*\", \"1\"});\n   EXPECT_EQ(resp, \"[2,3,4]\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(resp, R\"([{},{\"a\":2},{\"a\":2,\"b\":3},{\"a\":2,\"b\":3,\"c\":4}])\");\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":2},\"c\":{\"a\":2,\"b\":3},\"d\":{\"a\":2,\"b\":3,\"c\":4}})\");\n \n   json = R\"(\n     {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"b\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n@@ -444,23 +704,40 @@ TEST_F(JsonFamilyTest, NumIncrBy) {\n   resp = Run({\"JSON.NUMINCRBY\", \"json\", \"$.d.*\", \"1\"});\n   EXPECT_EQ(resp, \"[2,null,4]\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":\"a\"},{\"a\":\"a\",\"b\":2},{\"a\":\"a\",\"b\":\"b\"},{\"a\":2,\"b\":\"b\",\"c\":4}])\");\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(\n+      resp,\n+      R\"({\"a\":{\"a\":\"a\"},\"b\":{\"a\":\"a\",\"b\":2},\"c\":{\"a\":\"a\",\"b\":\"b\"},\"d\":{\"a\":2,\"b\":\"b\",\"c\":4}})\");\n }\n \n-TEST_F(JsonFamilyTest, NumMultBy) {\n+TEST_F(JsonFamilyTest, NumIncrByLegacy) {\n   string json = R\"(\n-    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+    {\"e\":1.5,\"a\":1}\n   )\";\n \n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d[*]\", \"2\"});\n-  EXPECT_EQ(resp, \"[2,4,6]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".a\", \"1.1\"});\n+  EXPECT_EQ(resp, \"2.1\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n-  EXPECT_EQ(resp, R\"([2,4,6])\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".e\", \"1\"});\n+  EXPECT_EQ(resp, \"2.5\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".e\", \"inf\"});\n+  EXPECT_THAT(resp, ErrArg(\"ERR result is not a number\"));\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".e\", \"1.7e308\"});\n+  EXPECT_EQ(resp, \"1.7e+308\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".e\", \"1.7e308\"});\n+  EXPECT_THAT(resp, ErrArg(\"ERR result is not a number\"));\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n+  EXPECT_EQ(resp, R\"([1,1.7e+308])\");\n \n   json = R\"(\n     {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n@@ -469,20 +746,32 @@ TEST_F(JsonFamilyTest, NumMultBy) {\n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a[*]\", \"2\"});\n-  EXPECT_EQ(resp, \"[]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".d[*]\", \"10\"});\n+  EXPECT_EQ(resp, \"13\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b[*]\", \"2\"});\n-  EXPECT_EQ(resp, \"[2]\");\n+  resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n+  EXPECT_EQ(resp, \"[11,12,13]\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c[*]\", \"2\"});\n-  EXPECT_EQ(resp, \"[2,4]\");\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d[*]\", \"2\"});\n-  EXPECT_EQ(resp, \"[2,4,6]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".a[*]\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(resp, R\"([[],[2],[2,4],[2,4,6]])\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".b[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"2\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".c[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"3\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".d[*]\", \"1\"});\n+  EXPECT_EQ(resp, \"4\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".d[2]\", \"1\"});\n+  EXPECT_EQ(resp, \"5\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[],\"b\":[2],\"c\":[2,3],\"d\":[2,3,5]})\");\n \n   json = R\"(\n     {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}}\n@@ -491,20 +780,20 @@ TEST_F(JsonFamilyTest, NumMultBy) {\n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a.*\", \"2\"});\n-  EXPECT_EQ(resp, \"[]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".a.*\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b.*\", \"2\"});\n-  EXPECT_EQ(resp, \"[2]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".b.*\", \"1\"});\n+  EXPECT_EQ(resp, \"2\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c.*\", \"2\"});\n-  EXPECT_EQ(resp, \"[2,4]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".c.*\", \"1\"});\n+  EXPECT_EQ(resp, \"3\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d.*\", \"2\"});\n-  EXPECT_EQ(resp, \"[2,4,6]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".d.*\", \"1\"});\n+  EXPECT_EQ(resp, \"4\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(resp, R\"([{},{\"a\":2},{\"a\":2,\"b\":4},{\"a\":2,\"b\":4,\"c\":6}])\");\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":2},\"c\":{\"a\":2,\"b\":3},\"d\":{\"a\":2,\"b\":3,\"c\":4}})\");\n \n   json = R\"(\n     {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"b\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n@@ -513,11 +802,90 @@ TEST_F(JsonFamilyTest, NumMultBy) {\n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a.*\", \"2\"});\n-  EXPECT_EQ(resp, \"[null]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".a.*\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n \n-  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b.*\", \"2\"});\n-  EXPECT_EQ(resp, \"[null,2]\");\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".b.*\", \"1\"});\n+  EXPECT_EQ(resp, \"2\");\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".c.*\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.NUMINCRBY\", \"json\", \".d.*\", \"1\"});\n+  EXPECT_EQ(resp, \"4\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(\n+      resp,\n+      R\"({\"a\":{\"a\":\"a\"},\"b\":{\"a\":\"a\",\"b\":2},\"c\":{\"a\":\"a\",\"b\":\"b\"},\"d\":{\"a\":2,\"b\":\"b\",\"c\":4}})\");\n+}\n+\n+TEST_F(JsonFamilyTest, NumMultBy) {\n+  string json = R\"(\n+    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n+  EXPECT_EQ(resp, R\"([2,4,6])\");\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[],\"b\":[2],\"c\":[2,4],\"d\":[2,4,6]})\");\n+\n+  json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[2,4,6]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":2},\"c\":{\"a\":2,\"b\":4},\"d\":{\"a\":2,\"b\":4,\"c\":6}})\");\n+\n+  json = R\"(\n+    {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"b\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.a.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[null]\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.b.*\", \"2\"});\n+  EXPECT_EQ(resp, \"[null,2]\");\n \n   resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.c.*\", \"2\"});\n   EXPECT_EQ(resp, \"[null,null]\");\n@@ -525,8 +893,89 @@ TEST_F(JsonFamilyTest, NumMultBy) {\n   resp = Run({\"JSON.NUMMULTBY\", \"json\", \"$.d.*\", \"2\"});\n   EXPECT_EQ(resp, \"[2,null,6]\");\n \n-  resp = Run({\"JSON.GET\", \"json\", \"$.*\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":\"a\"},{\"a\":\"a\",\"b\":2},{\"a\":\"a\",\"b\":\"b\"},{\"a\":2,\"b\":\"b\",\"c\":6}])\");\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(\n+      resp,\n+      R\"({\"a\":{\"a\":\"a\"},\"b\":{\"a\":\"a\",\"b\":2},\"c\":{\"a\":\"a\",\"b\":\"b\"},\"d\":{\"a\":2,\"b\":\"b\",\"c\":6}})\");\n+}\n+\n+TEST_F(JsonFamilyTest, NumMultByLegacy) {\n+  string json = R\"(\n+    {\"a\":[], \"b\":[1], \"c\":[1,2], \"d\":[1,2,3]}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".d[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"6\");\n+\n+  resp = Run({\"JSON.GET\", \"json\", \"$.d[*]\"});\n+  EXPECT_EQ(resp, R\"([2,4,6])\");\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".a[*]\", \"2\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".b[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"2\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".c[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"4\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".d[*]\", \"2\"});\n+  EXPECT_EQ(resp, \"6\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[],\"b\":[2],\"c\":[2,4],\"d\":[2,4,6]})\");\n+\n+  json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".a.*\", \"2\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".b.*\", \"2\"});\n+  EXPECT_EQ(resp, \"2\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".c.*\", \"2\"});\n+  EXPECT_EQ(resp, \"4\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".d.*\", \"2\"});\n+  EXPECT_EQ(resp, \"6\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":2},\"c\":{\"a\":2,\"b\":4},\"d\":{\"a\":2,\"b\":4,\"c\":6}})\");\n+\n+  json = R\"(\n+    {\"a\":{\"a\":\"a\"}, \"b\":{\"a\":\"a\", \"b\":1}, \"c\":{\"a\":\"a\", \"b\":\"b\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":3}}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".a.*\", \"2\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".b.*\", \"2\"});\n+  EXPECT_EQ(resp, \"2\");\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".c.*\", \"2\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+\n+  resp = Run({\"JSON.NUMMULTBY\", \"json\", \".d.*\", \"2\"});\n+  EXPECT_EQ(resp, \"6\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(\n+      resp,\n+      R\"({\"a\":{\"a\":\"a\"},\"b\":{\"a\":\"a\",\"b\":2},\"c\":{\"a\":\"a\",\"b\":\"b\"},\"d\":{\"a\":2,\"b\":\"b\",\"c\":6}})\");\n }\n \n TEST_F(JsonFamilyTest, Del) {\n@@ -561,6 +1010,7 @@ TEST_F(JsonFamilyTest, Del) {\n \n   resp = Run({\"JSON.DEL\", \"json\"});\n   EXPECT_THAT(resp, IntArg(1));\n+\n   resp = Run({\"GET\", \"json\"});  // This is legal since the key was removed\n   EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n \n@@ -579,6 +1029,7 @@ TEST_F(JsonFamilyTest, Del) {\n \n   resp = Run({\"GET\", \"json\"});  // not a legal type\n   EXPECT_THAT(resp, ErrArg(\"Operation against a key holding the wrong kind of value\"));\n+\n   resp = Run({\"JSON.GET\", \"json\"});\n   EXPECT_EQ(resp, R\"({\"a\":[{\"b\":[2,3]}],\"b\":[{\"c\":2}],\"c']\":[1,2,3]})\");\n \n@@ -594,9 +1045,93 @@ TEST_F(JsonFamilyTest, Del) {\n   resp = Run({\"JSON.GET\", \"json\"});\n   EXPECT_EQ(resp, R\"({})\");\n \n-  Run({\"JSON.SET\", \"json\", \"$\", R\"({\"a\": 1})\"});\n+  resp = Run({\"JSON.SET\", \"json\", \"$\", R\"({\"a\": 1})\"});\n+  ASSERT_THAT(resp, \"OK\");\n+\n   resp = Run({\"JSON.DEL\", \"json\", \"$\"});\n   EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+}\n+\n+TEST_F(JsonFamilyTest, DelLegacy) {\n+  string json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":1}, \"c\":{\"a\":1, \"b\":2}, \"d\":{\"a\":1, \"b\":2, \"c\":3}, \"e\": [1,2,3,4,5]}}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \".d.*\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":1},\"c\":{\"a\":1,\"b\":2},\"d\":{},\"e\":[1,2,3,4,5]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \".e[*]\"});\n+  EXPECT_THAT(resp, IntArg(5));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{},\"b\":{\"a\":1},\"c\":{\"a\":1,\"b\":2},\"d\":{},\"e\":[]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \"..*\"});\n+  EXPECT_GE(resp.GetInt(), 5);\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"GET\", \"json\"});  // This is legal since the key was removed\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  json = R\"(\n+    {\"a\":[{\"b\": [1,2,3]}], \"b\": [{\"c\": 2}], \"c']\":[1,2,3]}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \".a[0].b[0]\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"GET\", \"json\"});  // not a legal type\n+  EXPECT_THAT(resp, ErrArg(\"Operation against a key holding the wrong kind of value\"));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[{\"b\":[2,3]}],\"b\":[{\"c\":2}],\"c']\":[1,2,3]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \".b[0].c\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[{\"b\":[2,3]}],\"b\":[{}],\"c']\":[1,2,3]})\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \".*\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({})\");\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", R\"({\"a\": 1})\"});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\", \".\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEL\", \"json\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n   resp = Run({\"JSON.GET\", \"json\"});\n   EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n }\n@@ -609,62 +1144,89 @@ TEST_F(JsonFamilyTest, ObjKeys) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.OBJKEYS\", \"json\"});\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \"$\"});\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"b\", \"c\", \"d\", \"e\"));\n \n   resp = Run({\"JSON.OBJKEYS\", \"json\", \"$.a\"});\n-  EXPECT_THAT(resp, ArgType(RespExpr::NIL_ARRAY));\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n \n   resp = Run({\"JSON.OBJKEYS\", \"json\", \"$.b\"});\n   EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\"));\n \n-  resp = Run({\"JSON.OBJKEYS\", \"json\", \".b\"});\n-  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\"));\n-\n-  resp = Run({\"JSON.OBJKEYS\", \"json\", \"b\"});\n-  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\"));\n-\n   resp = Run({\"JSON.OBJKEYS\", \"json\", \"$.*\"});\n-  ASSERT_THAT(resp, ArrLen(5));\n-  const auto& arr = resp.GetVec();\n-  EXPECT_THAT(arr[0], ArgType(RespExpr::NIL_ARRAY));\n-  EXPECT_THAT(arr[1].GetVec(), ElementsAre(\"a\"));\n-  EXPECT_THAT(arr[2].GetVec(), ElementsAre(\"a\", \"b\"));\n-  EXPECT_THAT(arr[3].GetVec(), ElementsAre(\"a\", \"b\", \"c\"));\n-  EXPECT_THAT(arr[4], ArgType(RespExpr::NIL_ARRAY));\n+  EXPECT_THAT(resp, ElementsAreArrays(IsEmpty(), ElementsAre(\"a\"), ElementsAre(\"a\", \"b\"),\n+                                      ElementsAre(\"a\", \"b\", \"c\"), IsEmpty()));\n \n   resp = Run({\"JSON.OBJKEYS\", \"json\", \"$.notfound\"});\n-  EXPECT_THAT(resp, ArgType(RespExpr::ARRAY));\n-  EXPECT_THAT(resp, ArrLen(0));\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n \n   json = R\"(\n-    {\"a\":[7], \"inner\": {\"a\": {\"b\": 2, \"c\": 1337}}}\n-  )\";\n+     {\"a\":[7], \"inner\": {\"a\": {\"b\": 2, \"c\": 1337}}}\n+   )\";\n \n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n   resp = Run({\"JSON.OBJKEYS\", \"json\", \"$..a\"});\n-  ASSERT_THAT(resp, ArrLen(2));\n-  const auto& arr1 = resp.GetVec();\n-  EXPECT_THAT(arr1[0], ArgType(RespExpr::NIL_ARRAY));\n-  EXPECT_THAT(arr1[1], RespArray(ElementsAre(\"b\", \"c\")));\n+  EXPECT_THAT(resp, ElementsAreArrays(IsEmpty(), ElementsAre(\"b\", \"c\")));\n \n   json = R\"(\n-    {\"a\":{}, \"b\":{\"c\":{\"d\": {\"e\": 1337}}}}\n-  )\";\n+     {\"a\":{}, \"b\":{\"c\":{\"d\": {\"e\": 1337}}}}\n+   )\";\n \n   resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n   resp = Run({\"JSON.OBJKEYS\", \"json\", \"$..*\"});\n-  ASSERT_THAT(resp, ArrLen(5));\n-  const auto& arr2 = resp.GetVec();\n-  EXPECT_THAT(arr2[0], ArgType(RespExpr::NIL_ARRAY));\n-  EXPECT_THAT(arr2[1].GetVec(), ElementsAre(\"c\"));\n-  EXPECT_THAT(arr2[2].GetVec(), ElementsAre(\"d\"));\n-  EXPECT_THAT(arr2[3].GetVec(), ElementsAre(\"e\"));\n-  EXPECT_THAT(arr2[4], ArgType(RespExpr::NIL_ARRAY));\n+  EXPECT_THAT(resp, ElementsAreArrays(IsEmpty(), ElementsAre(\"c\"), ElementsAre(\"d\"),\n+                                      ElementsAre(\"e\"), IsEmpty()));\n+}\n+\n+TEST_F(JsonFamilyTest, ObjKeysLegacy) {\n+  string json = R\"(\n+    {\"a\":{}, \"b\":{\"a\":\"a\"}, \"c\":{\"a\":\"a\", \"b\":\"bb\"}, \"d\":{\"a\":1, \"b\":\"b\", \"c\":{\"a\":3,\"b\":4}}, \"e\":1}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"b\", \"c\", \"d\", \"e\"));\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \".\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"b\", \"c\", \"d\", \"e\"));\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \".a\"});\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \".b\"});\n+  EXPECT_THAT(resp, \"a\");\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \".*\"});\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \".notfound\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  json = R\"(\n+     {\"a\":[7], \"inner\": {\"a\": {\"b\": 2, \"c\": 1337}}}\n+   )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \"..a\"});\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n+\n+  json = R\"(\n+     {\"a\":{}, \"b\":{\"c\":{\"d\": {\"e\": 1337}}}}\n+   )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.OBJKEYS\", \"json\", \"..*\"});\n+  EXPECT_THAT(resp.GetVec(), IsEmpty());\n }\n \n TEST_F(JsonFamilyTest, StrAppend) {\n@@ -1016,26 +1578,139 @@ TEST_F(JsonFamilyTest, Clear) {\n   EXPECT_EQ(resp, R\"({})\");\n }\n \n-TEST_F(JsonFamilyTest, ArrPop) {\n+TEST_F(JsonFamilyTest, ClearLegacy) {\n   string json = R\"(\n-    [[6,1,6], [7,2,7], [8,3,8]]\n+    [[], [0], [0,1], [0,1,2], 1, true, null, \"d\"]\n   )\";\n \n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.ARRPOP\", \"json\", \"$[*]\", \"-2\"});\n-  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n-  EXPECT_THAT(resp.GetVec(), ElementsAre(\"1\", \"2\", \"3\"));\n+  resp = Run({\"JSON.CLEAR\", \"json\", \"[*]\"});\n+  EXPECT_THAT(resp, IntArg(5));\n \n   resp = Run({\"JSON.GET\", \"json\"});\n-  EXPECT_EQ(resp, R\"([[6,6],[7,7],[8,8]])\");\n-}\n+  EXPECT_EQ(resp, R\"([[],[],[],[],0,true,null,\"d\"])\");\n \n-TEST_F(JsonFamilyTest, ArrTrim) {\n-  string json = R\"(\n-    [[], [\"a\"], [\"a\", \"b\"], [\"a\", \"b\", \"c\"]]\n-  )\";\n+  resp = Run({\"JSON.CLEAR\", \"json\", \".\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([])\");\n+\n+  json = R\"(\n+    {\"children\": [\"Yossi\", \"Rafi\", \"Benni\", \"Avraham\", \"Yehoshua\", \"Moshe\"]}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.CLEAR\", \"json\", \".children\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"children\":[]})\");\n+\n+  resp = Run({\"JSON.CLEAR\", \"json\", \".\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({})\");\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.CLEAR\", \"json\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({})\");\n+}\n+\n+TEST_F(JsonFamilyTest, ArrPop) {\n+  string json = R\"(\n+    [[6,1,6], [7,2,7], [8,3,8]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\", \"$[*]\", \"-2\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"1\", \"2\", \"3\"));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[6,6],[7,7],[8,8]])\");\n+\n+  json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"]]\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\", \"$[*]\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(ArgType(RespExpr::NIL), R\"(\"a\")\", R\"(\"b\")\"));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[],[],[\"a\"]])\");\n+}\n+\n+TEST_F(JsonFamilyTest, ArrPopLegacy) {\n+  string json = R\"(\n+    [[6,1,6], [7,2,7], [8,3,8]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\", \"[*]\", \"-2\"});\n+  EXPECT_EQ(resp, R\"(3)\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[6,6],[7,7],[8,8]])\");\n+\n+  json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"]]\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\", \".\"});\n+  EXPECT_EQ(resp, R\"([\"a\",\"b\"])\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[],[\"a\"]])\");\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\", \".\", \"0\"});\n+  EXPECT_EQ(resp, \"[]\");\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[\"a\"],[\"a\",\"b\"]])\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\"});\n+  EXPECT_EQ(resp, R\"([\"a\",\"b\"])\");\n+\n+  json = R\"(\n+    {\"a\":\"b\"}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRPOP\", \"json\", \".\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+}\n+\n+TEST_F(JsonFamilyTest, ArrTrim) {\n+  string json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"], [\"a\", \"b\", \"c\"]]\n+  )\";\n \n   auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n   ASSERT_THAT(resp, \"OK\");\n@@ -1089,6 +1764,70 @@ TEST_F(JsonFamilyTest, ArrTrim) {\n   EXPECT_EQ(resp, R\"([3,4])\");\n }\n \n+TEST_F(JsonFamilyTest, ArrTrimLegacy) {\n+  string json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"], [\"a\", \"b\", \"c\"]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRTRIM\", \"json\", \"[*]\", \"0\", \"1\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[],[\"a\"],[\"a\",\"b\"],[\"a\",\"b\"]])\");\n+\n+  json = R\"(\n+    {\"a\":[], \"nested\": {\"a\": [1,4]}}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRTRIM\", \"json\", \"..a\", \"0\", \"1\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[],\"nested\":{\"a\":[1,4]}})\");\n+\n+  json = R\"(\n+    {\"a\":[1,2,3,2], \"nested\": {\"a\": false}}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRTRIM\", \"json\", \"..a\", \"1\", \"2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[2,3],\"nested\":{\"a\":false}})\");\n+\n+  json = R\"(\n+    [1,2,3,4,5,6,7]\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \"$\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRTRIM\", \"json\", \".\", \"2\", \"3\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([3,4])\");\n+\n+  json = R\"(\n+    {\"a\":\"b\"}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRTRIM\", \"json\", \".\", \"0\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+}\n+\n TEST_F(JsonFamilyTest, ArrInsert) {\n   string json = R\"(\n     [[], [\"a\"], [\"a\", \"b\"]]\n@@ -1117,6 +1856,44 @@ TEST_F(JsonFamilyTest, ArrInsert) {\n \n   resp = Run({\"JSON.GET\", \"json\"});\n   EXPECT_EQ(resp, R\"([[\"b\",\"c\",\"a\"],[\"a\",\"c\",\"b\",\"a\"],[\"a\",\"c\",\"a\",\"b\",\"b\"]])\");\n+\n+  json = R\"(\n+    {\"a\":{\"b\":\"c\"}, \"b\":[[\"a\"], [\"a\", \"b\"]]}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRINSERT\", \"json\", \"$.a\", \"0\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+}\n+\n+TEST_F(JsonFamilyTest, ArrInsertLegacy) {\n+  string json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRINSERT\", \"json\", \"[*]\", \"0\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.ARRINSERT\", \"json\", \".\", \"0\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, IntArg(4));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([\"c\",[\"c\"],[\"c\",\"a\"],[\"c\",\"a\",\"b\"]])\");\n+\n+  json = R\"(\n+    {\"a\":{\"b\":\"c\"}, \"b\":[[\"a\"], [\"a\", \"b\"]]}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRINSERT\", \"json\", \".a\", \"0\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n }\n \n TEST_F(JsonFamilyTest, ArrAppend) {\n@@ -1149,6 +1926,34 @@ TEST_F(JsonFamilyTest, ArrAppend) {\n   EXPECT_EQ(resp, R\"({\"a\":[1,3],\"nested\":{\"a\":[1,2,3],\"nested2\":{\"a\":42}}})\");\n }\n \n+TEST_F(JsonFamilyTest, ArrAppendLegacy) {\n+  string json = R\"(\n+    [[], [\"a\"], [\"a\", \"b\"]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRAPPEND\", \"json\", \"[-1]\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.ARRAPPEND\", \"json\", \".*\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, IntArg(4));\n+\n+  resp = Run({\"JSON.GET\", \"json\"});\n+  EXPECT_EQ(resp, R\"([[\"c\"],[\"a\",\"c\"],[\"a\",\"b\",\"c\",\"c\"]])\");\n+\n+  json = R\"(\n+    {\"a\":\"b\"}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRAPPEND\", \"json\", \".\", R\"(\"c\")\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+}\n+\n TEST_F(JsonFamilyTest, ArrIndex) {\n   string json = R\"(\n     [[], [\"a\"], [\"a\", \"b\"], [\"a\", \"b\", \"c\"]]\n@@ -1193,6 +1998,31 @@ TEST_F(JsonFamilyTest, ArrIndex) {\n   EXPECT_THAT(resp, IntArg(1));\n }\n \n+TEST_F(JsonFamilyTest, ArrIndexLegacy) {\n+  string json = R\"(\n+    {\"children\": [\"John\", \"Jack\", \"Tom\", \"Bob\", \"Mike\"]}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRINDEX\", \"json\", \".children\", R\"(\"Tom\")\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"JSON.ARRINDEX\", \"json\", \".children\", R\"(\"DoesNotExist\")\"});\n+  EXPECT_THAT(resp, IntArg(-1));\n+\n+  json = R\"(\n+    {\"a\":\"b\"}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.ARRINDEX\", \"json\", \".\", R\"(\"Tom\")\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong JSON type of path value\"));\n+}\n+\n TEST_F(JsonFamilyTest, MGet) {\n   string json[] = {\n       R\"(\n@@ -1235,6 +2065,42 @@ TEST_F(JsonFamilyTest, MGet) {\n   EXPECT_THAT(resp.GetVec(), ElementsAre(R\"([1,3])\", R\"([4,6])\"));\n }\n \n+TEST_F(JsonFamilyTest, MGetLegacy) {\n+  string json[] = {\n+      R\"(\n+    {\"address\":{\"street\":\"14 Imber Street\",\"city\":\"Petah-Tikva\",\"country\":\"Israel\",\"zipcode\":\"49511\"}}\n+  )\",\n+      R\"(\n+    {\"address\":{\"street\":\"Oranienburger Str. 27\",\"city\":\"Berlin\",\"country\":\"Germany\",\"zipcode\":\"10117\"}}\n+  )\",\n+      R\"(\n+    {\"a\":1, \"b\": 2, \"nested\": {\"a\": 3}, \"c\": null}\n+  )\",\n+      R\"(\n+    {\"a\":4, \"b\": 5, \"nested\": {\"a\": 6}, \"c\": null}\n+  )\"};\n+\n+  auto resp = Run({\"JSON.SET\", \"json1\", \".\", json[0]});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json2\", \".\", json[1]});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.MGET\", \"json1\", \"json2\", \"json3\", \".address.country\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(R\"(\"Israel\")\", R\"(\"Germany\")\", ArgType(RespExpr::NIL)));\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \".\", json[2]});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json4\", \".\", json[3]});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.MGET\", \"json3\", \"json4\", \"..a\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(R\"(3)\", R\"(6)\"));\n+}\n+\n TEST_F(JsonFamilyTest, DebugFields) {\n   string json = R\"(\n     [1, 2.3, \"foo\", true, null, {}, [], {\"a\":1, \"b\":2}, [1,2,3]]\n@@ -1277,11 +2143,53 @@ TEST_F(JsonFamilyTest, DebugFields) {\n   EXPECT_THAT(resp, IntArg(1));\n }\n \n+TEST_F(JsonFamilyTest, DebugFieldsLegacy) {\n+  string json = R\"(\n+    [1, 2.3, \"foo\", true, null, {}, [], {\"a\":1, \"b\":2}, [1,2,3]]\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json1\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEBUG\", \"fields\", \"json1\", \"[*]\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.DEBUG\", \"fields\", \"json1\", \".\"});\n+  EXPECT_THAT(resp, IntArg(14));\n+\n+  resp = Run({\"JSON.DEBUG\", \"fields\", \"json1\"});\n+  EXPECT_THAT(resp, IntArg(14));\n+\n+  json = R\"(\n+    [[1,2,3, [4,5,6,[6,7,8]]], {\"a\": {\"b\": {\"c\": 1337}}}]\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json1\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEBUG\", \"fields\", \"json1\", \"[*]\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  resp = Run({\"JSON.DEBUG\", \"fields\", \"json1\", \".\"});\n+  EXPECT_THAT(resp, IntArg(16));\n+\n+  json = R\"({\"a\":1, \"b\":2, \"c\":{\"k1\":1,\"k2\":2}})\";\n+\n+  resp = Run({\"JSON.SET\", \"obj_doc\", \".\", json});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.DEBUG\", \"FIELDS\", \"obj_doc\", \".a\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"JSON.DEBUG\", \"fields\", \"obj_doc\", \".a\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+}\n+\n TEST_F(JsonFamilyTest, Resp) {\n   auto resp = Run({\"JSON.SET\", \"json\", \".\", PhonebookJson});\n   ASSERT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.RESP\", \"json\"});\n+  resp = Run({\"JSON.RESP\", \"json\", \"$\"});\n   ASSERT_EQ(RespExpr::ARRAY, resp.type);\n \n   resp = Run({\"JSON.RESP\", \"json\", \"$.address.*\"});\n@@ -1298,6 +2206,26 @@ TEST_F(JsonFamilyTest, Resp) {\n   EXPECT_THAT(resp, \"135.25\");\n }\n \n+TEST_F(JsonFamilyTest, RespLegacy) {\n+  auto resp = Run({\"JSON.SET\", \"json\", \".\", PhonebookJson});\n+  ASSERT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.RESP\", \"json\"});\n+  ASSERT_EQ(RespExpr::ARRAY, resp.type);\n+\n+  resp = Run({\"JSON.RESP\", \"json\", \".address.*\"});\n+  EXPECT_THAT(resp, \"10021-3100\");\n+\n+  resp = Run({\"JSON.RESP\", \"json\", \".isAlive\"});\n+  EXPECT_THAT(resp, \"true\");\n+\n+  resp = Run({\"JSON.RESP\", \"json\", \".age\"});\n+  EXPECT_THAT(resp, IntArg(27));\n+\n+  resp = Run({\"JSON.RESP\", \"json\", \".weight\"});\n+  EXPECT_THAT(resp, \"135.25\");\n+}\n+\n TEST_F(JsonFamilyTest, Set) {\n   string json = R\"(\n     {\"a\":{\"a\":1, \"b\":2, \"c\":3}}\n@@ -1309,8 +2237,8 @@ TEST_F(JsonFamilyTest, Set) {\n   resp = Run({\"JSON.SET\", \"json1\", \"$.a.*\", \"0\"});\n   EXPECT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.GET\", \"json1\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":{\"a\":0,\"b\":0,\"c\":0}}])\");\n+  resp = Run({\"JSON.GET\", \"json1\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{\"a\":0,\"b\":0,\"c\":0}})\");\n \n   json = R\"(\n     {\"a\": [1,2,3,4,5]}\n@@ -1322,8 +2250,8 @@ TEST_F(JsonFamilyTest, Set) {\n   resp = Run({\"JSON.SET\", \"json2\", \"$.a[*]\", \"0\"});\n   EXPECT_THAT(resp, \"OK\");\n \n-  resp = Run({\"JSON.GET\", \"json2\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":[0,0,0,0,0]}])\");\n+  resp = Run({\"JSON.GET\", \"json2\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[0,0,0,0,0]})\");\n \n   json = R\"(\n     {\"a\": 2}\n@@ -1344,8 +2272,58 @@ TEST_F(JsonFamilyTest, Set) {\n   resp = Run({\"JSON.SET\", \"json3\", \"$.b\", \"4\", \"NX\"});\n   EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n \n-  resp = Run({\"JSON.GET\", \"json3\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":2,\"b\":8,\"c\":[1,2,3]}])\");\n+  resp = Run({\"JSON.GET\", \"json3\"});\n+  EXPECT_EQ(resp, R\"({\"a\":2,\"b\":8,\"c\":[1,2,3]})\");\n+}\n+\n+TEST_F(JsonFamilyTest, SetLegacy) {\n+  string json = R\"(\n+    {\"a\":{\"a\":1, \"b\":2, \"c\":3}}\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"json1\", \".\", json});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json1\", \".a.*\", \"0\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.GET\", \"json1\"});\n+  EXPECT_EQ(resp, R\"({\"a\":{\"a\":0,\"b\":0,\"c\":0}})\");\n+\n+  json = R\"(\n+    {\"a\": [1,2,3,4,5]}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json2\", \".\", json});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json2\", \".a[*]\", \"0\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.GET\", \"json2\"});\n+  EXPECT_EQ(resp, R\"({\"a\":[0,0,0,0,0]})\");\n+\n+  json = R\"(\n+    {\"a\": 2}\n+  )\";\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$\", json});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.b\", \"8\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.c\", \"[1,2,3]\"});\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.z\", \"3\", \"XX\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  resp = Run({\"JSON.SET\", \"json3\", \"$.b\", \"4\", \"NX\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  resp = Run({\"JSON.GET\", \"json3\"});\n+  EXPECT_EQ(resp, R\"({\"a\":2,\"b\":8,\"c\":[1,2,3]})\");\n }\n \n TEST_F(JsonFamilyTest, MSet) {\n@@ -1365,6 +2343,23 @@ TEST_F(JsonFamilyTest, MSet) {\n                                          \"[\" + json2 + \"]\"));\n }\n \n+TEST_F(JsonFamilyTest, MSetLegacy) {\n+  string json1 = R\"({\"a\":{\"a\":1,\"b\":2,\"c\":3}})\";\n+  string json2 = R\"({\"a\":{\"a\":4,\"b\":5,\"c\":6}})\";\n+\n+  auto resp = Run({\"JSON.MSET\", \"j1\", \".\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number\"));\n+  resp = Run({\"JSON.MSET\", \"j1\", \".\", json1, \"j3\", \".\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number\"));\n+\n+  resp = Run({\"JSON.MSET\", \"j1\", \".\", json1, \"j2\", \".\", json2, \"j3\", \".\", json1, \"j4\", \".\", json2});\n+  EXPECT_EQ(resp, \"OK\");\n+\n+  resp = Run({\"JSON.MGET\", \"j1\", \"j2\", \"j3\", \"j4\", \"$\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"[\" + json1 + \"]\", \"[\" + json2 + \"]\", \"[\" + json1 + \"]\",\n+                                         \"[\" + json2 + \"]\"));\n+}\n+\n TEST_F(JsonFamilyTest, Merge) {\n   string json = R\"(\n   { \"a\": \"b\",\n@@ -1374,6 +2369,7 @@ TEST_F(JsonFamilyTest, Merge) {\n     }\n   }\n   )\";\n+\n   auto resp = Run({\"JSON.SET\", \"j1\", \"$\", json});\n   EXPECT_EQ(resp, \"OK\");\n \n@@ -1385,21 +2381,24 @@ TEST_F(JsonFamilyTest, Merge) {\n       }\n     }\n   )\";\n+\n   resp = Run({\"JSON.MERGE\", \"new\", \"$\", patch});\n   EXPECT_EQ(resp, \"OK\");\n-  resp = Run({\"JSON.GET\", \"new\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":\"z\",\"c\":{\"f\":null}}])\");\n+\n+  resp = Run({\"JSON.GET\", \"new\"});\n+  EXPECT_EQ(resp, R\"({\"a\":\"z\",\"c\":{\"f\":null}})\");\n+\n   resp = Run({\"JSON.MERGE\", \"j1\", \"$\", patch});\n   EXPECT_EQ(resp, \"OK\");\n-  resp = Run({\"JSON.GET\", \"j1\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"a\":\"z\",\"c\":{\"d\":\"e\"}}])\");\n+  resp = Run({\"JSON.GET\", \"j1\"});\n+  EXPECT_EQ(resp, R\"({\"a\":\"z\",\"c\":{\"d\":\"e\"}})\");\n \n   resp = Run({\"JSON.SET\", \"foo\", \"$\", R\"(\"{\"f1\":1, \"common\":2}\")\"});\n   EXPECT_EQ(resp, \"OK\");\n   resp = Run({\"JSON.MERGE\", \"foo\", \"$\", R\"({\"f2\":2, \"common\":4})\"});\n   EXPECT_EQ(resp, \"OK\");\n-  resp = Run({\"JSON.GET\", \"foo\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"common\":4,\"f2\":2}])\");\n+  resp = Run({\"JSON.GET\", \"foo\"});\n+  EXPECT_EQ(resp, R\"({\"common\":4,\"f2\":2})\");\n \n   json = R\"({\n   \"ans\": {\n@@ -1428,15 +2427,93 @@ TEST_F(JsonFamilyTest, Merge) {\n   resp = Run({\"JSON.MERGE\", \"j2\", \"$.ans.x\", patch});\n \n   EXPECT_EQ(resp, \"OK\");\n-  resp = Run({\"JSON.GET\", \"j2\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"ans\":{\"x\":{\"y\":{\"answers\":[\"foo\",\"bar\"],\"doubled\":true},)\"\n-                  R\"(\"z\":{\"answers\":[\"xxx\",\"yyy\"],\"doubled\":false}}}}])\");\n+  resp = Run({\"JSON.GET\", \"j2\"});\n+  EXPECT_EQ(resp, R\"({\"ans\":{\"x\":{\"y\":{\"answers\":[\"foo\",\"bar\"],\"doubled\":true},)\"\n+                  R\"(\"z\":{\"answers\":[\"xxx\",\"yyy\"],\"doubled\":false}}}})\");\n \n   // Test not existing entry\n   resp = Run({\"JSON.MERGE\", \"j3\", \"$\", patch});\n   EXPECT_EQ(resp, \"OK\");\n-  resp = Run({\"JSON.GET\", \"j3\", \"$\"});\n-  EXPECT_EQ(resp, R\"([{\"y\":{\"doubled\":true},\"z\":{\"answers\":[\"xxx\",\"yyy\"],\"doubled\":false}}])\");\n+  resp = Run({\"JSON.GET\", \"j3\"});\n+  EXPECT_EQ(resp, R\"({\"y\":{\"doubled\":true},\"z\":{\"answers\":[\"xxx\",\"yyy\"],\"doubled\":false}})\");\n+}\n+\n+TEST_F(JsonFamilyTest, MergeLegacy) {\n+  string json = R\"(\n+  { \"a\": \"b\",\n+    \"c\": {\n+      \"d\": \"e\",\n+      \"f\": \"g\"\n+    }\n+  }\n+  )\";\n+\n+  auto resp = Run({\"JSON.SET\", \"j1\", \"$\", json});\n+  EXPECT_EQ(resp, \"OK\");\n+\n+  string patch = R\"(\n+    {\n+      \"a\":\"z\",\n+      \"c\": {\n+      \"f\": null\n+      }\n+    }\n+  )\";\n+\n+  resp = Run({\"JSON.MERGE\", \"new\", \".\", patch});\n+  EXPECT_EQ(resp, \"OK\");\n+\n+  resp = Run({\"JSON.GET\", \"new\"});\n+  EXPECT_EQ(resp, R\"({\"a\":\"z\",\"c\":{\"f\":null}})\");\n+\n+  resp = Run({\"JSON.MERGE\", \"j1\", \".\", patch});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.GET\", \"j1\"});\n+  EXPECT_EQ(resp, R\"({\"a\":\"z\",\"c\":{\"d\":\"e\"}})\");\n+\n+  resp = Run({\"JSON.SET\", \"foo\", \"$\", R\"(\"{\"f1\":1, \"common\":2}\")\"});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.MERGE\", \"foo\", \".\", R\"({\"f2\":2, \"common\":4})\"});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.GET\", \"foo\"});\n+  EXPECT_EQ(resp, R\"({\"common\":4,\"f2\":2})\");\n+\n+  json = R\"({\n+  \"ans\": {\n+    \"x\": {\n+      \"y\" : {\n+        \"doubled\": false,\n+        \"answers\": [\n+          \"foo\",\n+          \"bar\"\n+        ]\n+      }\n+    }\n+  }\n+  })\";\n+  resp = Run({\"JSON.SET\", \"j2\", \"$\", json});\n+  ASSERT_EQ(resp, \"OK\");\n+\n+  patch = R\"(\n+    {\"z\": {\n+      \"doubled\": false,\n+      \"answers\": [\"xxx\",  \"yyy\"]\n+     },\n+     \"y\": { \"doubled\": true}\n+     })\";\n+\n+  resp = Run({\"JSON.MERGE\", \"j2\", \".ans.x\", patch});\n+\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.GET\", \"j2\"});\n+  EXPECT_EQ(resp, R\"({\"ans\":{\"x\":{\"y\":{\"answers\":[\"foo\",\"bar\"],\"doubled\":true},)\"\n+                  R\"(\"z\":{\"answers\":[\"xxx\",\"yyy\"],\"doubled\":false}}}})\");\n+\n+  // Test not existing entry\n+  resp = Run({\"JSON.MERGE\", \"j3\", \".\", patch});\n+  EXPECT_EQ(resp, \"OK\");\n+  resp = Run({\"JSON.GET\", \"j3\"});\n+  EXPECT_EQ(resp, R\"({\"y\":{\"doubled\":true},\"z\":{\"answers\":[\"xxx\",\"yyy\"],\"doubled\":false}})\");\n }\n \n }  // namespace dfly\n",
  "problem_statement": "JSON API legacy mode with '.' is not conforming to the elasticache behavior\nFor example, `JSON.OBJKEYS key .` returns a nested array\r\nbut it should return a plain []string\n",
  "hints_text": "update: it should return a nested array for `$` paths and plain array for `.` path.\r\n",
  "created_at": "2024-07-08T05:22:52Z",
  "modified_files": [
    "src/facade/cmd_arg_parser.h",
    "src/facade/error.h",
    "src/facade/facade.cc",
    "src/facade/op_status.cc",
    "src/facade/op_status.h",
    "src/server/detail/wrapped_json_path.h",
    "src/server/error.h",
    "src/server/json_family.cc"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc"
  ]
}