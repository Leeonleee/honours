{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1159,
  "instance_id": "dragonflydb__dragonfly-1159",
  "issue_numbers": [
    "854"
  ],
  "base_commit": "b09a36d5534892914d1ac8fb42ee76fc23c66445",
  "patch": "diff --git a/src/server/command_registry.cc b/src/server/command_registry.cc\nindex 1b8df89eaf73..76d2d7e6a5e9 100644\n--- a/src/server/command_registry.cc\n+++ b/src/server/command_registry.cc\n@@ -32,8 +32,7 @@ bool CommandId::IsTransactional() const {\n   if (first_key_ > 0 || (opt_mask_ & CO::GLOBAL_TRANS) || (opt_mask_ & CO::NO_KEY_JOURNAL))\n     return true;\n \n-  string_view name{name_};\n-  if (name == \"EVAL\" || name == \"EVALSHA\" || name == \"EXEC\")\n+  if (name_ == \"EVAL\" || name_ == \"EVALSHA\" || name_ == \"EXEC\")\n     return true;\n \n   return false;\n@@ -44,30 +43,41 @@ uint32_t CommandId::OptCount(uint32_t mask) {\n }\n \n CommandRegistry::CommandRegistry() {\n-  CommandId cd(\"COMMAND\", CO::LOADING | CO::NOSCRIPT, -1, 0, 0, 0);\n+  static const char kCMD[] = \"COMMAND\";\n+  CommandId cd(kCMD, CO::LOADING | CO::NOSCRIPT, -1, 0, 0, 0);\n \n   cd.SetHandler([this](const auto& args, auto* cntx) { return Command(args, cntx); });\n \n-  const char* nm = cd.name();\n-  cmd_map_.emplace(nm, std::move(cd));\n+  cmd_map_.emplace(kCMD, std::move(cd));\n }\n \n void CommandRegistry::Command(CmdArgList args, ConnectionContext* cntx) {\n+  unsigned cmd_cnt = 0;\n+  for (const auto& val : cmd_map_) {\n+    const CommandId& cd = val.second;\n+    if (cd.opt_mask() & CO::HIDDEN)\n+      continue;\n+\n+    ++cmd_cnt;\n+  }\n+\n   if (args.size() > 0) {\n     ToUpper(&args[0]);\n     string_view subcmd = ArgS(args, 0);\n     if (subcmd == \"COUNT\") {\n-      return (*cntx)->SendLong(cmd_map_.size());\n+      return (*cntx)->SendLong(cmd_cnt);\n     } else {\n       return (*cntx)->SendError(kSyntaxErr, kSyntaxErrType);\n     }\n   }\n-  size_t len = cmd_map_.size();\n \n-  (*cntx)->StartArray(len);\n+  (*cntx)->StartArray(cmd_cnt);\n \n   for (const auto& val : cmd_map_) {\n     const CommandId& cd = val.second;\n+    if (cd.opt_mask() & CO::HIDDEN)\n+      continue;\n+\n     (*cntx)->StartArray(6);\n     (*cntx)->SendSimpleString(cd.name());\n     (*cntx)->SendLong(cd.arity());\n@@ -118,6 +128,8 @@ const char* OptName(CO::CommandOpt fl) {\n       return \"noscript\";\n     case BLOCKING:\n       return \"blocking\";\n+    case HIDDEN:\n+      return \"hidden\";\n     case GLOBAL_TRANS:\n       return \"global-trans\";\n     case VARIADIC_KEYS:\ndiff --git a/src/server/command_registry.h b/src/server/command_registry.h\nindex f83e4ba2bc27..007672aa021a 100644\n--- a/src/server/command_registry.h\n+++ b/src/server/command_registry.h\n@@ -31,6 +31,7 @@ enum CommandOpt : uint32_t {\n   ADMIN = 1U << 7,  // implies NOSCRIPT,\n   NOSCRIPT = 1U << 8,\n   BLOCKING = 1U << 9,  // implies REVERSE_MAPPING\n+  HIDDEN = 1U << 10,   // does not show in COMMAND command output\n   GLOBAL_TRANS = 1U << 12,\n \n   NO_AUTOJOURNAL = 1U << 15,  // Skip automatically logging command to journal inside transaction.\n@@ -43,6 +44,10 @@ constexpr inline bool IsEvalKind(std::string_view name) {\n   return name.compare(0, 4, \"EVAL\") == 0;\n }\n \n+constexpr inline bool IsTransKind(std::string_view name) {\n+  return (name == \"EXEC\") || (name == \"MULTI\") || (name == \"DISCARD\");\n+}\n+\n static_assert(IsEvalKind(\"EVAL\") && IsEvalKind(\"EVALSHA\"));\n static_assert(!IsEvalKind(\"\"));\n \n@@ -78,7 +83,7 @@ class CommandId {\n   CommandId(const char* name, uint32_t mask, int8_t arity, int8_t first_key, int8_t last_key,\n             int8_t step);\n \n-  const char* name() const {\n+  std::string_view name() const {\n     return name_;\n   }\n \n@@ -132,7 +137,7 @@ class CommandId {\n   static uint32_t OptCount(uint32_t mask);\n \n  private:\n-  const char* name_;\n+  std::string_view name_;\n \n   uint32_t opt_mask_;\n   int8_t arity_;\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 2abe5fa9dc78..3a7815b122bc 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -11,6 +11,7 @@ extern \"C\" {\n #include <absl/cleanup/cleanup.h>\n #include <absl/functional/bind_front.h>\n #include <absl/strings/ascii.h>\n+#include <absl/strings/match.h>\n #include <absl/strings/str_format.h>\n #include <xxhash.h>\n \n@@ -191,14 +192,14 @@ void SendMonitor(const std::string& msg) {\n   }\n }\n \n-void DispatchMonitorIfNeeded(bool admin_cmd, ConnectionContext* connection, CmdArgList args) {\n+void DispatchMonitorIfNeeded(bool admin_cmd, ConnectionContext* cntx, CmdArgList args) {\n   // We are not sending any admin command in the monitor, and we do not want to\n   // do any processing if we don't have any waiting connections with monitor\n   // enabled on them - see https://redis.io/commands/monitor/\n   const auto& my_monitors = ServerState::tlocal()->Monitors();\n   if (!(my_monitors.Empty() || admin_cmd)) {\n     //  We have connections waiting to get the info on the last command, send it to them\n-    auto monitor_msg = MakeMonitorMessage(connection->conn_state, connection->owner(), args);\n+    auto monitor_msg = MakeMonitorMessage(cntx->conn_state, cntx->owner(), args);\n \n     VLOG(1) << \"sending command '\" << monitor_msg << \"' to the clients that registered on it\";\n \n@@ -582,12 +583,6 @@ void Service::Shutdown() {\n   ThisFiber::SleepFor(10ms);\n }\n \n-static void SetMultiExecErrorFlag(ConnectionContext* cntx) {\n-  if (cntx->conn_state.exec_info.IsActive()) {\n-    cntx->conn_state.exec_info.state = ConnectionState::ExecInfo::EXEC_ERROR;\n-  }\n-}\n-\n // Return OK if all keys are allowed to be accessed: either declared in EVAL or\n // transaction is running in global or non-atomic mode.\n OpStatus CheckKeysDeclared(const ConnectionState::ScriptInfo& eval_info, const CommandId* cid,\n@@ -618,20 +613,19 @@ OpStatus CheckKeysDeclared(const ConnectionState::ScriptInfo& eval_info, const C\n   return OpStatus::OK;\n }\n \n-bool Service::VerifyCommand(const CommandId* cid, CmdArgList args,\n-                            facade::ConnectionContext* cntx) {\n+bool Service::VerifyCommand(const CommandId* cid, CmdArgList args, ConnectionContext* dfly_cntx) {\n   ServerState& etl = *ServerState::tlocal();\n \n   string_view cmd_str = ArgS(args, 0);\n-  ConnectionContext* dfly_cntx = static_cast<ConnectionContext*>(cntx);\n \n-  bool is_trans_cmd = (cmd_str == \"EXEC\" || cmd_str == \"MULTI\" || cmd_str == \"DISCARD\");\n-  bool under_script = bool(dfly_cntx->conn_state.script_info);\n-\n-  absl::Cleanup multi_error([dfly_cntx] { SetMultiExecErrorFlag(dfly_cntx); });\n+  absl::Cleanup multi_error([exec_info = &dfly_cntx->conn_state.exec_info] {\n+    if (exec_info->IsActive()) {\n+      exec_info->state = ConnectionState::ExecInfo::EXEC_ERROR;\n+    }\n+  });\n \n   if (cid == nullptr) {\n-    (*cntx)->SendError(StrCat(\"unknown command `\", cmd_str, \"`\"), \"unknown_cmd\");\n+    (*dfly_cntx)->SendError(StrCat(\"unknown command `\", cmd_str, \"`\"), \"unknown_cmd\");\n \n     lock_guard lk(mu_);\n     if (unknown_cmds_.size() < 1024)\n@@ -639,31 +633,33 @@ bool Service::VerifyCommand(const CommandId* cid, CmdArgList args,\n     return false;\n   }\n \n-  bool blocked_by_loading = !cntx->journal_emulated && etl.gstate() == GlobalState::LOADING &&\n+  bool is_trans_cmd = CO::IsTransKind(cid->name());\n+  bool under_script = bool(dfly_cntx->conn_state.script_info);\n+  bool blocked_by_loading = !dfly_cntx->journal_emulated && etl.gstate() == GlobalState::LOADING &&\n                             (cid->opt_mask() & CO::LOADING) == 0;\n   if (blocked_by_loading || etl.gstate() == GlobalState::SHUTTING_DOWN) {\n     string err = StrCat(\"Can not execute during \", GlobalStateName(etl.gstate()));\n-    (*cntx)->SendError(err);\n+    (*dfly_cntx)->SendError(err);\n     return false;\n   }\n \n   string_view cmd_name{cid->name()};\n \n-  if (cntx->req_auth && !cntx->authenticated) {\n+  if (dfly_cntx->req_auth && !dfly_cntx->authenticated) {\n     if (cmd_name != \"AUTH\" && cmd_name != \"QUIT\" && cmd_name != \"HELLO\") {\n-      (*cntx)->SendError(\"-NOAUTH Authentication required.\");\n+      (*dfly_cntx)->SendError(\"-NOAUTH Authentication required.\");\n       return false;\n     }\n   }\n \n   // only reset and quit are allow if this connection is used for monitoring\n   if (dfly_cntx->monitor && (cmd_name != \"RESET\" && cmd_name != \"QUIT\")) {\n-    (*cntx)->SendError(\"Replica can't interact with the keyspace\");\n+    (*dfly_cntx)->SendError(\"Replica can't interact with the keyspace\");\n     return false;\n   }\n \n   if (under_script && (cid->opt_mask() & CO::NOSCRIPT)) {\n-    (*cntx)->SendError(\"This Redis command is not allowed from script\");\n+    (*dfly_cntx)->SendError(\"This Redis command is not allowed from script\");\n     return false;\n   }\n \n@@ -672,18 +668,18 @@ bool Service::VerifyCommand(const CommandId* cid, CmdArgList args,\n   bool under_multi = dfly_cntx->conn_state.exec_info.IsActive() && !is_trans_cmd;\n \n   if (!etl.is_master && is_write_cmd && !dfly_cntx->is_replicating) {\n-    (*cntx)->SendError(\"-READONLY You can't write against a read only replica.\");\n+    (*dfly_cntx)->SendError(\"-READONLY You can't write against a read only replica.\");\n     return false;\n   }\n \n   if ((cid->arity() > 0 && args.size() != size_t(cid->arity())) ||\n       (cid->arity() < 0 && args.size() < size_t(-cid->arity()))) {\n-    (*cntx)->SendError(facade::WrongNumArgsError(cmd_str), kSyntaxErrType);\n+    (*dfly_cntx)->SendError(facade::WrongNumArgsError(cmd_str), kSyntaxErrType);\n     return false;\n   }\n \n   if (cid->key_arg_step() == 2 && (args.size() % 2) == 0) {\n-    (*cntx)->SendError(facade::WrongNumArgsError(cmd_str), kSyntaxErrType);\n+    (*dfly_cntx)->SendError(facade::WrongNumArgsError(cmd_str), kSyntaxErrType);\n     return false;\n   }\n \n@@ -694,12 +690,12 @@ bool Service::VerifyCommand(const CommandId* cid, CmdArgList args,\n \n   if (under_multi) {\n     if (cmd_name == \"SELECT\") {\n-      (*cntx)->SendError(\"Can not call SELECT within a transaction\");\n+      (*dfly_cntx)->SendError(\"Can not call SELECT within a transaction\");\n       return false;\n     }\n \n     if (cmd_name == \"WATCH\" || cmd_name == \"FLUSHALL\" || cmd_name == \"FLUSHDB\") {\n-      (*cntx)->SendError(absl::StrCat(\"'\", cmd_name, \"' inside MULTI is not allowed\"));\n+      (*dfly_cntx)->SendError(absl::StrCat(\"'\", cmd_name, \"' inside MULTI is not allowed\"));\n       return false;\n     }\n   }\n@@ -709,12 +705,12 @@ bool Service::VerifyCommand(const CommandId* cid, CmdArgList args,\n                                         dfly_cntx->transaction);\n \n     if (status == OpStatus::KEY_NOTFOUND) {\n-      (*cntx)->SendError(\"script tried accessing undeclared key\");\n+      (*dfly_cntx)->SendError(\"script tried accessing undeclared key\");\n       return false;\n     }\n \n     if (status != OpStatus::OK) {\n-      (*cntx)->SendError(status);\n+      (*dfly_cntx)->SendError(status);\n       return false;\n     }\n   }\n@@ -739,21 +735,20 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n               << \" in dbid=\" << dfly_cntx->conn_state.db_index;\n   }\n \n-  string_view cmd_str = ArgS(args, 0);\n-  bool is_trans_cmd = (cmd_str == \"EXEC\" || cmd_str == \"MULTI\" || cmd_str == \"DISCARD\");\n-  const CommandId* cid = registry_.Find(cmd_str);\n+  const CommandId* cid = FindCmd(args);\n   ServerState& etl = *ServerState::tlocal();\n \n   etl.RecordCmd();\n \n-  if (!VerifyCommand(cid, args, cntx))\n+  if (!VerifyCommand(cid, args, dfly_cntx))\n     return;\n \n+  bool is_trans_cmd = CO::IsTransKind(cid->name());\n   etl.connection_stats.cmd_count_map[cid->name()]++;\n-\n+  auto args_no_cmd = args.subspan(1);\n   if (dfly_cntx->conn_state.exec_info.IsActive() && !is_trans_cmd) {\n     // TODO: protect against aggregating huge transactions.\n-    StoredCmd stored_cmd{cid, args.subspan(1)};\n+    StoredCmd stored_cmd{cid, args_no_cmd};\n     dfly_cntx->conn_state.exec_info.body.push_back(std::move(stored_cmd));\n \n     return (*cntx)->SendSimpleString(\"QUEUED\");\n@@ -770,7 +765,7 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n     if (cid->IsTransactional()) {\n       dfly_cntx->transaction->MultiSwitchCmd(cid);\n       OpStatus status =\n-          dfly_cntx->transaction->InitByArgs(dfly_cntx->conn_state.db_index, args.subspan(1));\n+          dfly_cntx->transaction->InitByArgs(dfly_cntx->conn_state.db_index, args_no_cmd);\n \n       if (status != OpStatus::OK)\n         return (*cntx)->SendError(status);\n@@ -782,7 +777,7 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n       dist_trans.reset(new Transaction{cid, etl.thread_index()});\n \n       if (!dist_trans->IsMulti()) {  // Multi command initialize themself based on their mode.\n-        if (auto st = dist_trans->InitByArgs(dfly_cntx->conn_state.db_index, args.subspan(1));\n+        if (auto st = dist_trans->InitByArgs(dfly_cntx->conn_state.db_index, args_no_cmd);\n             st != OpStatus::OK)\n           return (*cntx)->SendError(st);\n       }\n@@ -806,7 +801,7 @@ void Service::DispatchCommand(CmdArgList args, facade::ConnectionContext* cntx)\n   }\n \n   end_usec = ProactorBase::GetMonotonicTimeNs();\n-  request_latency_usec.IncBy(cmd_str, (end_usec - start_usec) / 1000);\n+  request_latency_usec.IncBy(cid->name(), (end_usec - start_usec) / 1000);\n \n   if (!under_script) {\n     dfly_cntx->transaction = nullptr;\n@@ -1215,6 +1210,20 @@ bool StartMultiEval(DbIndex dbid, CmdArgList keys, ScriptMgr::ScriptParams param\n   return false;\n }\n \n+const CommandId* Service::FindCmd(CmdArgList args) const {\n+  const CommandId* res = registry_.Find(ArgS(args, 0));\n+  if (!res)\n+    return nullptr;\n+\n+  // A workaround for XGROUP HELP that does not fit our static taxonomy of commands.\n+  if (args.size() == 2 && res->name() == \"XGROUP\") {\n+    if (absl::EqualsIgnoreCase(ArgS(args, 1), \"HELP\")) {\n+      res = registry_.Find(\"_XGROUP_HELP\");\n+    }\n+  }\n+  return res;\n+}\n+\n void Service::EvalInternal(const EvalArgs& eval_args, Interpreter* interpreter,\n                            ConnectionContext* cntx) {\n   DCHECK(!eval_args.sha.empty());\ndiff --git a/src/server/main_service.h b/src/server/main_service.h\nindex c73b4eed548b..e03ea23ba491 100644\n--- a/src/server/main_service.h\n+++ b/src/server/main_service.h\n@@ -116,7 +116,9 @@ class Service : public facade::ServiceInterface {\n   };\n \n   // Return false if command is invalid and reply with error.\n-  bool VerifyCommand(const CommandId* cid, CmdArgList args, facade::ConnectionContext* cntx);\n+  bool VerifyCommand(const CommandId* cid, CmdArgList args, ConnectionContext* cntx);\n+\n+  const CommandId* FindCmd(CmdArgList args) const;\n \n   void EvalInternal(const EvalArgs& eval_args, Interpreter* interpreter, ConnectionContext* cntx);\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 9fc147ebe640..e9c2931b04c3 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -2158,7 +2158,7 @@ void ServerFamily::Register(CommandRegistry* registry) {\n             << CI{\"ROLE\", CO::LOADING | CO::FAST | CO::NOSCRIPT, 1, 0, 0, 0}.HFUNC(Role)\n             << CI{\"SLOWLOG\", CO::ADMIN | CO::FAST, -2, 0, 0, 0}.SetHandler(SlowLog)\n             << CI{\"SCRIPT\", CO::NOSCRIPT | CO::NO_KEY_JOURNAL, -2, 0, 0, 0}.HFUNC(Script)\n-            << CI{\"DFLY\", CO::ADMIN | CO::GLOBAL_TRANS, -2, 0, 0, 0}.HFUNC(Dfly);\n+            << CI{\"DFLY\", CO::ADMIN | CO::GLOBAL_TRANS | CO::HIDDEN, -2, 0, 0, 0}.HFUNC(Dfly);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 8dc2162fea41..cafb245589cd 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -563,6 +563,24 @@ void SetId(string_view key, string_view gname, CmdArgList args, ConnectionContex\n   }\n }\n \n+void XGroupHelp(CmdArgList args, ConnectionContext* cntx) {\n+  string_view help_arr[] = {\n+      \"CREATE <key> <groupname> <id|$> [option]\",\n+      \"    Create a new consumer group. Options are:\",\n+      \"    * MKSTREAM\",\n+      \"      Create the empty stream if it does not exist.\",\n+      \"CREATECONSUMER <key> <groupname> <consumer>\",\n+      \"    Create a new consumer in the specified group.\",\n+      \"DELCONSUMER <key> <groupname> <consumer>\",\n+      \"    Remove the specified consumer.\",\n+      \"DESTROY <key> <groupname>\"\n+      \"    Remove the specified group.\",\n+      \"SETID <key> <groupname> <id|$>\",\n+      \"    Set the current group ID.\",\n+  };\n+  return (*cntx)->SendSimpleStrArr(help_arr);\n+}\n+\n }  // namespace\n \n void StreamFamily::XAdd(CmdArgList args, ConnectionContext* cntx) {\n@@ -651,23 +669,6 @@ void StreamFamily::XDel(CmdArgList args, ConnectionContext* cntx) {\n void StreamFamily::XGroup(CmdArgList args, ConnectionContext* cntx) {\n   ToUpper(&args[0]);\n   string_view sub_cmd = ArgS(args, 0);\n-  if (sub_cmd == \"HELP\") {\n-    string_view help_arr[] = {\n-        \"CREATE <key> <groupname> <id|$> [option]\",\n-        \"    Create a new consumer group. Options are:\",\n-        \"    * MKSTREAM\",\n-        \"      Create the empty stream if it does not exist.\",\n-        \"CREATECONSUMER <key> <groupname> <consumer>\",\n-        \"    Create a new consumer in the specified group.\",\n-        \"DELCONSUMER <key> <groupname> <consumer>\",\n-        \"    Remove the specified consumer.\",\n-        \"DESTROY <key> <groupname>\"\n-        \"    Remove the specified group.\",\n-        \"SETID <key> <groupname> <id|$>\",\n-        \"    Set the current group ID.\",\n-    };\n-    return (*cntx)->SendSimpleStrArr(help_arr);\n-  }\n \n   if (args.size() >= 2) {\n     string_view key = ArgS(args, 1);\n@@ -859,12 +860,13 @@ void StreamFamily::Register(CommandRegistry* registry) {\n \n   *registry << CI{\"XADD\", CO::WRITE | CO::FAST, -5, 1, 1, 1}.HFUNC(XAdd)\n             << CI{\"XDEL\", CO::WRITE | CO::FAST, -3, 1, 1, 1}.HFUNC(XDel)\n-            << CI{\"XGROUP\", CO::WRITE | CO::DENYOOM, -2, 2, 2, 1}.HFUNC(XGroup)\n+            << CI{\"XGROUP\", CO::WRITE | CO::DENYOOM, -3, 2, 2, 1}.HFUNC(XGroup)\n             << CI{\"XINFO\", CO::READONLY | CO::NOSCRIPT, -2, 0, 0, 0}.HFUNC(XInfo)\n             << CI{\"XLEN\", CO::READONLY | CO::FAST, 2, 1, 1, 1}.HFUNC(XLen)\n             << CI{\"XRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(XRange)\n             << CI{\"XREVRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(XRevRange)\n-            << CI{\"XSETID\", CO::WRITE | CO::DENYOOM, 3, 1, 1, 1}.HFUNC(XSetId);\n+            << CI{\"XSETID\", CO::WRITE | CO::DENYOOM, 3, 1, 1, 1}.HFUNC(XSetId)\n+            << CI{\"_XGROUP_HELP\", CO::NOSCRIPT | CO::HIDDEN, 2, 0, 0, 0}.SetHandler(XGroupHelp);\n }\n \n }  // namespace dfly\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 45d1e289d250..fe5800a0a7d3 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -920,7 +920,7 @@ void Transaction::UnwatchBlocking(bool should_expire, WaitKeysProvider wcb) {\n   DVLOG(1) << \"UnwatchBlocking finished \" << DebugId();\n }\n \n-const char* Transaction::Name() const {\n+string_view Transaction::Name() const {\n   return cid_->name();\n }\n \ndiff --git a/src/server/transaction.h b/src/server/transaction.h\nindex 68bb43a5de49..60094b985f7b 100644\n--- a/src/server/transaction.h\n+++ b/src/server/transaction.h\n@@ -251,7 +251,7 @@ class Transaction {\n \n   IntentLock::Mode Mode() const;  // Based on command mask\n \n-  const char* Name() const;  // Based on command name\n+  std::string_view Name() const;  // Based on command name\n \n   uint32_t GetUniqueShardCnt() const {\n     return unique_shard_cnt_;\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 3d892513fb3d..85fe7fa1dd63 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -615,7 +615,7 @@ bool ParseLexBound(string_view src, ZSetFamily::LexBound* bound) {\n }\n \n void SendAtLeastOneKeyError(ConnectionContext* cntx) {\n-  string name = cntx->cid->name();\n+  string name{cntx->cid->name()};\n   absl::AsciiStrToLower(&name);\n   (*cntx)->SendError(absl::StrCat(\"at least 1 input key is needed for \", name));\n }\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 913413787138..25e3b7a4af19 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -84,4 +84,12 @@ TEST_F(StreamFamilyTest, Range) {\n   EXPECT_THAT(sub1, ElementsAre(\"1-0\", ArrLen(2)));\n }\n \n+TEST_F(StreamFamilyTest, Issue854) {\n+  auto resp = Run({\"xgroup\", \"help\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::ARRAY));\n+\n+  resp = Run({\"eval\", \"redis.call('xgroup', 'help')\", \"0\"});\n+  EXPECT_THAT(resp, ErrArg(\"is not allowed\"));\n+}\n+\n }  // namespace dfly\n",
  "problem_statement": "XGROUP HELP crashes the server\n**Description & Reproducing**\r\n\r\nRun Dragonfly, and send the `XGROUP HELP` command, which normally should list the available `XGROUP xyz` commands. Dragonfly (debug, optimized builds) then crashes, with the following output:\r\n\r\n```\r\nF20230221 17:27:20.083921 83220 transaction.cc:104] Check failed: absl::StartsWith(cid_->name(), \"EVAL\") \r\n*** Check failure stack trace: ***\r\n    @     0x5620bf86975f  google::LogMessage::Fail()\r\n    @     0x5620bf8696a5  google::LogMessage::SendToLog()\r\n    @     0x5620bf868e7a  google::LogMessage::Flush()\r\n    @     0x5620bf86ccf2  google::LogMessageFatal::~LogMessageFatal()\r\n    @     0x5620bf2caf6f  dfly::Transaction::InitByArgs()\r\n    @     0x5620be84df3a  dfly::Service::DispatchCommand()\r\n    @     0x5620bf3fea24  facade::Connection::ParseRedis()\r\n    @     0x5620bf402097  facade::Connection::IoLoop()\r\n    @     0x5620bf3fb021  facade::Connection::ConnectionFlow()\r\n    @     0x5620bf3f67c7  facade::Connection::HandleRequests()\r\n    @     0x5620bf7546c9  util::ListenerInterface::RunSingleConnection()\r\n    @     0x5620bf7501a7  _ZZN4util17ListenerInterface13RunAcceptLoopEvENKUlvE0_clEv\r\n    @     0x5620bf768e0d  _ZSt13__invoke_implIvZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEET_St14__invoke_otherOT0_DpOT1_\r\n    @     0x5620bf766c7d  _ZSt8__invokeIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEENSt15__invoke_resultIT_JDpT0_EE4typeEOS4_DpOS5_\r\n    @     0x5620bf763451  _ZSt12__apply_implIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_St5tupleIJEEJEEDcOT_OT0_St16integer_sequenceImJXspT1_EEE\r\n    @     0x5620bf7634ce  _ZSt5applyIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_St5tupleIJEEEDcOT_OT0_\r\n    @     0x5620bf763713  _ZN5boost6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEE4run_EONS_7context5fiberE\r\n    @     0x5620bf774014  _ZSt13__invoke_implIN5boost7context5fiberERMNS0_6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFS2_OS2_ERPS8_JS2_EET_St21__invoke_memfun_derefOT0_OT1_DpOT2_\r\n    @     0x5620bf77342b  _ZSt8__invokeIRMN5boost6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFNS0_7context5fiberEOS8_EJRPS6_S8_EENSt15__invoke_resultIT_JDpT0_EE4typeEOSG_DpOSH_\r\n    @     0x5620bf772e54  _ZNSt5_BindIFMN5boost6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFNS0_7context5fiberEOS8_EPS6_St12_PlaceholderILi1EEEE6__callIS8_JS9_EJLm0ELm1EEEET_OSt5tupleIJDpT0_EESt12_Index_tupleIJXspT1_EEE\r\n    @     0x5620bf772843  _ZNSt5_BindIFMN5boost6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFNS0_7context5fiberEOS8_EPS6_St12_PlaceholderILi1EEEEclIJS8_ES8_EET0_DpOT_\r\n    @     0x5620bf771a7e  _ZSt13__invoke_implIN5boost7context5fiberERSt5_BindIFMNS0_6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFS2_OS2_EPS9_St12_PlaceholderILi1EEEEJS2_EET_St14__invoke_otherOT0_DpOT1_\r\n    @     0x5620bf770dfb  _ZSt8__invokeIRSt5_BindIFMN5boost6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFNS1_7context5fiberEOS9_EPS7_St12_PlaceholderILi1EEEEJS9_EENSt15__invoke_resultIT_JDpT0_EE4typeEOSK_DpOSL_\r\n    @     0x5620bf76ee5b  _ZSt6invokeIRSt5_BindIFMN5boost6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFNS1_7context5fiberEOS9_EPS7_St12_PlaceholderILi1EEEEJS9_EENSt13invoke_resultIT_JDpT0_EE4typeEOSK_DpOSL_\r\n    @     0x5620bf76c23d  _ZN5boost7context6detail12fiber_recordINS0_5fiberENS0_21basic_fixedsize_stackINS0_12stack_traitsEEESt5_BindIFMNS_6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFS3_OS3_EPSD_St12_PlaceholderILi1EEEEE3runEPv\r\n    @     0x5620bf7695b8  _ZN5boost7context6detail11fiber_entryINS1_12fiber_recordINS0_5fiberENS0_21basic_fixedsize_stackINS0_12stack_traitsEEESt5_BindIFMNS_6fibers14worker_contextIZN4util17ListenerInterface13RunAcceptLoopEvEUlvE0_JEEEFS4_OS4_EPSE_St12_PlaceholderILi1EEEEEEEEvNS1_10transfer_tE\r\n    @     0x7f4843fa324f  make_fcontext\r\n*** SIGABRT received at time=1676993240 on cpu 0 ***\r\nPC: @     0x7f4843488a7c  (unknown)  pthread_kill\r\n    @     0x5620bf8bd4db         64  absl::lts_20230125::WriteFailureInfo()\r\n    @     0x5620bf8bd6e5         96  absl::lts_20230125::AbslFailureSignalHandler()\r\n    @     0x7f4843434520  (unknown)  (unknown)\r\n[1]    83219 IOT instruction (core dumped)  ./dragonfly --logtostderr\r\n```\r\n**System info**\r\n- OS: Linux Mint 21.1 (Vera)\r\n- Kernel: 5.15.0-60-generic\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2023-04-29T16:06:12Z",
  "modified_files": [
    "src/server/command_registry.cc",
    "src/server/command_registry.h",
    "src/server/main_service.cc",
    "src/server/main_service.h",
    "src/server/server_family.cc",
    "src/server/stream_family.cc",
    "src/server/transaction.cc",
    "src/server/transaction.h",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}