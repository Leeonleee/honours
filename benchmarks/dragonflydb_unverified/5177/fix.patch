diff --git a/src/facade/redis_parser.cc b/src/facade/redis_parser.cc
index 1ec691d033c5..869b9334686f 100644
--- a/src/facade/redis_parser.cc
+++ b/src/facade/redis_parser.cc
@@ -422,13 +422,18 @@ auto RedisParser::ParseArg(Buffer str) -> ResultConsumed {
   const char* s = reinterpret_cast<const char*>(str.data());
   const char* eol = reinterpret_cast<const char*>(memchr(s, '
', str.size()));
 
-  // TODO: in client mode we still may not consume everything (see INPUT_PENDING below).
-  // It's not a problem, because we need consume all the input only in server mode.
-
   if (arg_c_ == '+' || arg_c_ == '-') {  // Simple string or error.
     DCHECK(!server_mode_);
     if (!eol) {
-      Result r = str.size() < 256 ? INPUT_PENDING : BAD_STRING;
+      // if eol is not found we should still read input as bulk string
+      cached_expr_->emplace_back(RespExpr::STRING);
+      cached_expr_->back().u = Buffer{};
+      bulk_len_ = str.length();
+      // eol is not found but if '\r' is present decrease bulk_len
+      if (s[bulk_len_ - 1] == '\r')
+        bulk_len_--;
+      state_ = BULK_STR_S;
+      Result r = str.size() < 256 ? OK : BAD_STRING;
       return {r, 0};
     }
 
@@ -479,6 +484,16 @@ auto RedisParser::ConsumeBulk(Buffer str) -> ResultConsumed {
   uint32_t consumed = 0;
   auto& bulk_str = get<Buffer>(cached_expr_->back().u);
 
+  bool extend = false;
+  // Handle split simple message or error in client mode
+  if (!server_mode_ && (arg_c_ == '+' || arg_c_ == '-') && !bulk_len_) {
+    // Search first '\r' in next partial message which ends bulk string
+    const char* s = reinterpret_cast<const char*>(str.data());
+    const char* pos = reinterpret_cast<const char*>(memchr(s, '\r', str.size()));
+    bulk_len_ = pos ? pos - s : str.size();
+    extend = true;
+  }
+
   if (str.size() >= bulk_len_) {
     consumed = bulk_len_;
     if (bulk_len_) {
@@ -487,6 +502,8 @@ auto RedisParser::ConsumeBulk(Buffer str) -> ResultConsumed {
       if (is_broken_token_) {
         memcpy(const_cast<uint8_t*>(bulk_str.end()), str.data(), bulk_len_);
         bulk_str = Buffer{bulk_str.data(), bulk_str.size() + bulk_len_};
+      } else if (extend) {
+        ExtendBulkString(Buffer(str.begin(), bulk_len_));
       } else {
         bulk_str = str.subspan(0, bulk_len_);
       }
@@ -568,6 +585,20 @@ void RedisParser::ExtendLastString(Buffer str) {
   buf_stash_.back() = std::move(nb);
 }
 
+void RedisParser::ExtendBulkString(Buffer str) {
+  DCHECK(!cached_expr_->empty() && cached_expr_->back().type == RespExpr::STRING);
+
+  Buffer& bulk_str = get<Buffer>(cached_expr_->back().u);
+
+  DCHECK(bulk_str.data() == buf_stash_.back().data());
+
+  vector<uint8_t> nb(bulk_str.size() + str.size());
+  memcpy(nb.data(), bulk_str.data(), bulk_str.size());
+  memcpy(nb.data() + bulk_str.size(), str.data(), str.size());
+  bulk_str = RespExpr::Buffer{nb.data(), bulk_str.size() + str.size()};
+  buf_stash_.back() = std::move(nb);
+}
+
 size_t RedisParser::UsedMemory() const {
   return dfly::HeapSize(parse_stack_) + dfly::HeapSize(stash_) + dfly::HeapSize(buf_stash_);
 }
diff --git a/src/facade/redis_parser.h b/src/facade/redis_parser.h
index ac3cf9fdc170..c4598d60c690 100644
--- a/src/facade/redis_parser.h
+++ b/src/facade/redis_parser.h
@@ -85,6 +85,7 @@ class RedisParser {
 
   void HandleFinishArg();
   void ExtendLastString(Buffer str);
+  void ExtendBulkString(Buffer str);
 
   enum State : uint8_t {
     INLINE_S,
