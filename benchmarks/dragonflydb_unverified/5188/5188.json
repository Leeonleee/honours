{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5188,
  "instance_id": "dragonflydb__dragonfly-5188",
  "issue_numbers": [
    "5186"
  ],
  "base_commit": "e241efc420ee8193f4bd81fb45cc7dd6303baf4a",
  "patch": "diff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex dc700eaec118..b6732f507792 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -64,8 +64,6 @@ bool SendErrorIfOccurred(const ParseResult<T>& result, CmdArgParser* parser,\n   return false;\n }\n \n-static const set<string_view> kIgnoredOptions = {\"WEIGHT\", \"SEPARATOR\"};\n-\n bool IsValidJsonPath(string_view path) {\n   error_code ec;\n   MakeJsonPathExpr(path, ec);\n@@ -191,6 +189,11 @@ ParseResult<bool> ParseStopwords(CmdArgParser* parser, DocIndex* index) {\n   return true;\n }\n \n+constexpr std::array<const std::string_view, 6> kIgnoredOptions = {\n+    \"UNF\"sv, \"NOSTEM\"sv, \"CASESENSITIVE\"sv, \"WITHSUFFIXTRIE\"sv, \"INDEXMISSING\"sv, \"INDEXEMPTY\"sv};\n+constexpr std::array<const std::string_view, 3> kIgnoredOptionsWithArg = {\"WEIGHT\"sv, \"SEPARATOR\"sv,\n+                                                                          \"PHONETIC\"sv};\n+\n // SCHEMA field [AS alias] type [flags...]\n ParseResult<bool> ParseSchema(CmdArgParser* parser, DocIndex* index) {\n   auto& schema = index->schema;\n@@ -237,16 +240,28 @@ ParseResult<bool> ParseSchema(CmdArgParser* parser, DocIndex* index) {\n       auto flag = parser->TryMapNext(\"NOINDEX\", search::SchemaField::NOINDEX, \"SORTABLE\",\n                                      search::SchemaField::SORTABLE);\n       if (!flag) {\n+        std::string_view option = parser->Peek();\n+        if (std::find(kIgnoredOptions.begin(), kIgnoredOptions.end(), option) !=\n+            kIgnoredOptions.end()) {\n+          LOG_IF(WARNING, option != \"INDEXMISSING\"sv && option != \"INDEXEMPTY\"sv)\n+              << \"Ignoring unsupported field option in FT.CREATE: \" << option;\n+          // Ignore these options\n+          parser->Skip(1);\n+          continue;\n+        }\n+        if (std::find(kIgnoredOptionsWithArg.begin(), kIgnoredOptionsWithArg.end(), option) !=\n+            kIgnoredOptionsWithArg.end()) {\n+          LOG(WARNING) << \"Ignoring unsupported field option in FT.CREATE: \" << option;\n+          // Ignore these options with argument\n+          parser->Skip(2);\n+          continue;\n+        }\n         break;\n       }\n \n       flags |= *flag;\n     }\n \n-    // Skip all trailing ignored parameters\n-    while (kIgnoredOptions.count(parser->Peek()) > 0)\n-      parser->Skip(2);\n-\n     schema.fields[field] = {field_type, flags, string{field_alias}, params};\n     schema.field_names[field_alias] = field;\n   }\n",
  "test_patch": "diff --git a/src/server/search/search_family_test.cc b/src/server/search/search_family_test.cc\nindex 7411a2ea0709..c0b09780070c 100644\n--- a/src/server/search/search_family_test.cc\n+++ b/src/server/search/search_family_test.cc\n@@ -2767,4 +2767,38 @@ TEST_F(SearchFamilyTest, JsonSetIndexesBug) {\n   resp = Run({\"FT.AGGREGATE\", \"index\", \"*\", \"GROUPBY\", \"1\", \"@text\"});\n   EXPECT_THAT(resp, IsUnordArrayWithSize(IsMap(\"text\", \"some text\")));\n }\n+\n+TEST_F(SearchFamilyTest, IgnoredOptionsInFtCreate) {\n+  Run({\"HSET\", \"doc:1\", \"title\", \"Test Document\"});\n+\n+  // Create an index with various options, some of which should be ignored\n+  // INDEXMISSING and INDEXEMPTY are supported by default\n+  auto resp = Run({\"FT.CREATE\",\n+                   \"idx\",\n+                   \"ON\",\n+                   \"HASH\",\n+                   \"SCHEMA\",\n+                   \"title\",\n+                   \"TEXT\",\n+                   \"UNF\",\n+                   \"NOSTEM\",\n+                   \"CASESENSITIVE\",\n+                   \"WITHSUFFIXTRIE\",\n+                   \"INDEXMISSING\",\n+                   \"INDEXEMPTY\",\n+                   \"WEIGHT\",\n+                   \"1\",\n+                   \"SEPARATOR\",\n+                   \"|\",\n+                   \"PHONETIC\",\n+                   \"dm:en\",\n+                   \"SORTABLE\"});\n+\n+  // Check that the response is OK, indicating the index was created successfully\n+  EXPECT_THAT(resp, \"OK\");\n+\n+  // Verify that the index was created correctly\n+  resp = Run({\"FT.SEARCH\", \"idx\", \"*\"});\n+  EXPECT_THAT(resp, AreDocIds(\"doc:1\"));\n+}\n }  // namespace dfly\n",
  "problem_statement": "FT.CREATE miss INDEXEMPTY and INDEXMISSING support\n**Did you search GitHub Issues and GitHub Discussions First?**\nYes\n\n**Is your feature request related to a problem? Please describe.**\nRedis.OM Framework during index creation fails with Bad json path: INDEXMISSING\n\n**Describe the solution you'd like**\nINDEXMISSING and INDEXEMPTY being supported\n\n**Describe alternatives you've considered**\nNo alternatives.\n\n\n",
  "hints_text": "",
  "created_at": "2025-05-27T18:44:56Z",
  "modified_files": [
    "src/server/search/search_family.cc"
  ],
  "modified_test_files": [
    "src/server/search/search_family_test.cc"
  ]
}