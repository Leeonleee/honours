{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3421,
  "instance_id": "dragonflydb__dragonfly-3421",
  "issue_numbers": [
    "3380"
  ],
  "base_commit": "7e911c100a3bd3286fa9c5e9acb3a4913fb48507",
  "patch": "diff --git a/README.ja-JP.md b/README.ja-JP.md\nindex fe03b0e1a7a9..cd68b0b73f8e 100644\n--- a/README.ja-JP.md\n+++ b/README.ja-JP.md\n@@ -113,7 +113,7 @@ Dragonfly \u7279\u6709\u306e\u8b70\u8ad6\u3082\u3042\u308b:\n  * `admin_bind`: \u7ba1\u7406\u30b3\u30f3\u30bd\u30fc\u30eb\u306e TCP \u63a5\u7d9a\u3092\u6307\u5b9a\u3055\u308c\u305f\u30a2\u30c9\u30ec\u30b9\u306b\u30d0\u30a4\u30f3\u30c9\u3059\u308b(`default: any`)\u3002HTTP \u3068 RESP \u306e\u4e21\u65b9\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u3002\n  * `admin_nopass`: \u5272\u308a\u5f53\u3066\u3089\u308c\u305f\u30dd\u30fc\u30c8\u3067\u3001\u8a8d\u8a3c\u30c8\u30fc\u30af\u30f3\u306a\u3057\u3067\u30b3\u30f3\u30bd\u30fc\u30eb\u3078\u306e\u30aa\u30fc\u30d7\u30f3\u7ba1\u7406\u30a2\u30af\u30bb\u30b9\u3092\u6709\u52b9\u306b\u3059\u308b (`default: false`)\u3002HTTP \u3068 RESP \u306e\u4e21\u65b9\u306e\u30d7\u30ed\u30c8\u30b3\u30eb\u3092\u30b5\u30dd\u30fc\u30c8\u3059\u308b\u3002\n  * `cluster_mode`: \u30b5\u30dd\u30fc\u30c8\u3059\u308b\u30af\u30e9\u30b9\u30bf\u30fc\u30e2\u30fc\u30c9 (`default: \"\"`)\u3002\u73fe\u5728\u306f `emulated` \u306e\u307f\u3092\u30b5\u30dd\u30fc\u30c8\u3057\u3066\u3044\u308b\u3002\n- * `cluster_announce_ip`: \u30af\u30e9\u30b9\u30bf\u30b3\u30de\u30f3\u30c9\u304c\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u30a2\u30ca\u30a6\u30f3\u30b9\u3059\u308b IP\u3002\n+ * `announce_ip`: \u30af\u30e9\u30b9\u30bf\u30b3\u30de\u30f3\u30c9\u304c\u30af\u30e9\u30a4\u30a2\u30f3\u30c8\u306b\u30a2\u30ca\u30a6\u30f3\u30b9\u3059\u308b IP\u3002\n \n ### \u4e00\u822c\u7684\u306a\u30aa\u30d7\u30b7\u30e7\u30f3\u3092\u4f7f\u7528\u3057\u305f\u958b\u59cb\u30b9\u30af\u30ea\u30d7\u30c8\u306e\u4f8b:\n \ndiff --git a/README.ko-KR.md b/README.ko-KR.md\nindex 4b88806c0d41..dda61fc9db94 100644\n--- a/README.ko-KR.md\n+++ b/README.ko-KR.md\n@@ -111,7 +111,7 @@ Dragonfly\ub294 \ud604\uc7ac \uc544\ub798\uc640 \uac19\uc740 Redis \uc778\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud569\ub2c8\ub2e4 :\n   * `admin_bind`: \uc8fc\uc5b4\uc9c4 \uc8fc\uc18c\uc5d0 \uad00\ub9ac\uc790 \ucf58\uc194 TCP \uc5f0\uacb0\uc744 \ubc14\uc778\ub529\ud569\ub2c8\ub2e4. (`\uae30\ubcf8\uac12: any`). HTTP\uc640 RESP \ud504\ub85c\ud1a0\ucf5c \ubaa8\ub450\ub97c \uc9c0\uc6d0\ud569\ub2c8\ub2e4.\n   * `admin_nopass`: \ud560\ub2f9\ub41c \ud3ec\ud2b8\uc5d0 \ub300\ud574\uc11c \uc778\uc99d \ud1a0\ud070 \uc5c6\uc774 \uad00\ub9ac\uc790 \ucf58\uc194 \uc811\uadfc\uc744 \ud65c\uc131\ud654\ud569\ub2c8\ub2e4. (`default: false`). HTTP\uc640 RESP \ud504\ub85c\ud1a0\ucf5c \ubaa8\ub450\ub97c \uc9c0\uc6d0\ud569\ub2c8\ub2e4.\n   * `cluster_mode`: \ud074\ub7ec\uc2a4\ud130 \ubaa8\ub4dc\uac00 \uc9c0\uc6d0\ub429\ub2c8\ub2e4. (`\uae30\ubcf8\uac12: \"\"`). \ud604\uc7ac\ub294`emulated` \ub9cc \uc9c0\uc6d0\ud569\ub2c8\ub2e4.\n-  * `cluster_announce_ip`: \ud074\ub7ec\uc2a4\ud130 \uba85\ub839\uc744 \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc54c\ub9ac\ub294 IP \uc8fc\uc18c.\n+  * `announce_ip`: \ud074\ub7ec\uc2a4\ud130 \uba85\ub839\uc744 \ud074\ub77c\uc774\uc5b8\ud2b8\uc5d0\uac8c \uc54c\ub9ac\ub294 IP \uc8fc\uc18c.\n \n \n ### \uc8fc\uc694 \uc635\uc158\uc744 \ud65c\uc6a9\ud55c \uc2e4\ud589 \uc2a4\ud06c\ub9bd\ud2b8 \uc608\uc2dc:\ndiff --git a/README.md b/README.md\nindex 84f68a6ee548..f5844606fcdd 100644\n--- a/README.md\n+++ b/README.md\n@@ -166,7 +166,8 @@ There are also some Dragonfly-specific arguments:\n  * `admin_bind`: To bind the admin console TCP connection to a given address (`default: any`). Supports both HTTP and RESP protocols.\n  * `admin_nopass`: To enable open admin access to console on the assigned port, without auth token needed (`default: false`). Supports both HTTP and RESP protocols.\n  * `cluster_mode`: Cluster mode supported (`default: \"\"`). Currently supports only `emulated`.\n- * `cluster_announce_ip`: The IP that cluster commands announce to the client.\n+ * `announce_ip`: The IP that cluster commands announce to the client, and to replication master.\n+ * `announce_port`: The port that cluster commands announce to the client, and to replication master.\n \n ### Example start script with popular options:\n \ndiff --git a/README.zh-CN.md b/README.zh-CN.md\nindex 05e2b3073089..fdfea228bc0a 100644\n--- a/README.zh-CN.md\n+++ b/README.zh-CN.md\n@@ -135,7 +135,7 @@ Dragonfly \u652f\u6301 Redis \u7684\u5e38\u89c1\u53c2\u6570\u3002\n \n * `cluster_mode`\uff1a\u652f\u6301\u96c6\u7fa4\u6a21\u5f0f\u3002\u76ee\u524d\u4ec5\u652f\u6301 `emulated`\u3002\u9ed8\u8ba4\u4e3a\u7a7a `\"\"`\u3002\n \n-* `cluster_announce_ip`\uff1a\u96c6\u7fa4\u6a21\u5f0f\u4e0b\u5411\u5ba2\u6237\u7aef\u516c\u5f00\u7684 IP\u3002\n+* `announce_ip`\uff1a\u96c6\u7fa4\u6a21\u5f0f\u4e0b\u5411\u5ba2\u6237\u7aef\u516c\u5f00\u7684 IP\u3002\n \n ### \u542f\u52a8\u811a\u672c\u793a\u4f8b\uff0c\u5305\u542b\u5e38\u7528\u9009\u9879\uff1a\n \ndiff --git a/src/server/cluster/cluster_family.cc b/src/server/cluster/cluster_family.cc\nindex 6d58f8398c45..616a637b37db 100644\n--- a/src/server/cluster/cluster_family.cc\n+++ b/src/server/cluster/cluster_family.cc\n@@ -25,12 +25,15 @@\n #include \"server/server_family.h\"\n #include \"server/server_state.h\"\n \n-ABSL_FLAG(std::string, cluster_announce_ip, \"\", \"ip that cluster commands announce to the client\");\n+ABSL_FLAG(std::string, cluster_announce_ip, \"\", \"DEPRECATED: use --announce_ip\");\n+\n ABSL_FLAG(std::string, cluster_node_id, \"\",\n           \"ID within a cluster, used for slot assignment. MUST be unique. If empty, uses master \"\n           \"replication ID (random string)\");\n \n ABSL_DECLARE_FLAG(int32_t, port);\n+ABSL_DECLARE_FLAG(std::string, announce_ip);\n+ABSL_DECLARE_FLAG(uint16_t, announce_port);\n \n namespace dfly {\n namespace acl {\n@@ -66,6 +69,16 @@ ClusterFamily::ClusterFamily(ServerFamily* server_family) : server_family_(serve\n \n   InitializeCluster();\n \n+  // TODO: Remove flag cluster_announce_ip in v1.23+\n+  if (!absl::GetFlag(FLAGS_cluster_announce_ip).empty()) {\n+    CHECK(absl::GetFlag(FLAGS_announce_ip).empty())\n+        << \"Can't use both --cluster_announce_ip and --announce_ip\";\n+\n+    LOG(WARNING) << \"WARNING: Flag --cluster_announce_ip is deprecated in favor of --announce_ip. \"\n+                    \"Use the latter, as the former will be removed in a future release.\";\n+    absl::SetFlag(&FLAGS_announce_ip, absl::GetFlag(FLAGS_cluster_announce_ip));\n+  }\n+\n   id_ = absl::GetFlag(FLAGS_cluster_node_id);\n   if (id_.empty()) {\n     id_ = server_family_->master_replid();\n@@ -104,13 +117,15 @@ ClusterShardInfo ClusterFamily::GetEmulatedShardInfo(ConnectionContext* cntx) co\n   ServerState& etl = *ServerState::tlocal();\n   if (!replication_info.has_value()) {\n     DCHECK(etl.is_master);\n-    std::string cluster_announce_ip = absl::GetFlag(FLAGS_cluster_announce_ip);\n+    std::string cluster_announce_ip = absl::GetFlag(FLAGS_announce_ip);\n     std::string preferred_endpoint =\n         cluster_announce_ip.empty() ? cntx->conn()->LocalBindAddress() : cluster_announce_ip;\n+    uint16_t cluster_announce_port = absl::GetFlag(FLAGS_announce_port);\n+    uint16_t preferred_port = cluster_announce_port == 0\n+                                  ? static_cast<uint16_t>(absl::GetFlag(FLAGS_port))\n+                                  : cluster_announce_port;\n \n-    info.master = {.id = id_,\n-                   .ip = preferred_endpoint,\n-                   .port = static_cast<uint16_t>(absl::GetFlag(FLAGS_port))};\n+    info.master = {.id = id_, .ip = preferred_endpoint, .port = preferred_port};\n \n     for (const auto& replica : server_family_->GetDflyCmd()->GetReplicasRoleInfo()) {\n       info.replicas.push_back({.id = replica.id,\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex a61c513fd39f..11acf9852abb 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -131,6 +131,7 @@ struct ConnectionState {\n     // then it holds positive sync session id.\n     uint32_t repl_session_id = 0;\n     uint32_t repl_flow_id = UINT32_MAX;\n+    std::string repl_ip_address;\n     uint32_t repl_listening_port = 0;\n     DflyVersion repl_version = DflyVersion::VER0;\n   };\ndiff --git a/src/server/dflycmd.cc b/src/server/dflycmd.cc\nindex f937b54e7017..61fecc857602 100644\n--- a/src/server/dflycmd.cc\n+++ b/src/server/dflycmd.cc\n@@ -563,7 +563,7 @@ auto DflyCmd::CreateSyncSession(ConnectionContext* cntx)\n     fb2::Fiber(\"stop_replication\", &DflyCmd::StopReplication, this, sync_id).Detach();\n   };\n \n-  string address = cntx->conn()->RemoteEndpointAddress();\n+  string address = cntx->conn_state.replication_info.repl_ip_address;\n   uint32_t port = cntx->conn_state.replication_info.repl_listening_port;\n \n   LOG(INFO) << \"Registered replica \" << address << \":\" << port;\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex f76dbbca2d9e..8029386196bf 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -67,6 +67,11 @@ using facade::ErrorReply;\n ABSL_FLAG(int32_t, port, 6379,\n           \"Redis port. 0 disables the port, -1 will bind on a random available port.\");\n \n+ABSL_FLAG(std::string, announce_ip, \"\",\n+          \"IP address that Dragonfly announces to cluster clients and replication master\");\n+ABSL_FLAG(uint16_t, announce_port, 0,\n+          \"Port that Dragonfly announces to cluster clients and replication master\");\n+\n ABSL_FLAG(uint32_t, memcached_port, 0, \"Memcached port\");\n \n ABSL_FLAG(uint32_t, num_shards, 0, \"Number of database shards, 0 - to choose automatically\");\ndiff --git a/src/server/replica.cc b/src/server/replica.cc\nindex f0df153edbbe..4e13d077f691 100644\n--- a/src/server/replica.cc\n+++ b/src/server/replica.cc\n@@ -42,6 +42,8 @@ ABSL_FLAG(bool, break_replication_on_master_restart, false,\n           \"When in replica mode, and master restarts, break replication from master to avoid \"\n           \"flushing the replica's data.\");\n ABSL_DECLARE_FLAG(int32_t, port);\n+ABSL_DECLARE_FLAG(uint16_t, announce_port);\n+ABSL_DECLARE_FLAG(std::string, announce_ip);\n ABSL_FLAG(\n     int, replica_priority, 100,\n     \"Published by info command for sentinel to pick replica based on score during a failover\");\n@@ -266,10 +268,19 @@ error_code Replica::Greet() {\n   PC_RETURN_ON_BAD_RESPONSE(CheckRespIsSimpleReply(\"PONG\"));\n \n   // Corresponds to server.repl_state == REPL_STATE_SEND_HANDSHAKE condition in replication.c\n-  auto port = absl::GetFlag(FLAGS_port);\n+  uint16_t port = absl::GetFlag(FLAGS_announce_port);\n+  if (port == 0) {\n+    port = static_cast<uint16_t>(absl::GetFlag(FLAGS_port));\n+  }\n   RETURN_ON_ERR(SendCommandAndReadResponse(StrCat(\"REPLCONF listening-port \", port)));\n   PC_RETURN_ON_BAD_RESPONSE(CheckRespIsSimpleReply(\"OK\"));\n \n+  auto announce_ip = absl::GetFlag(FLAGS_announce_ip);\n+  if (!announce_ip.empty()) {\n+    RETURN_ON_ERR(SendCommandAndReadResponse(StrCat(\"REPLCONF ip-address \", announce_ip)));\n+    PC_RETURN_ON_BAD_RESPONSE(CheckRespIsSimpleReply(\"OK\"));\n+  }\n+\n   // Corresponds to server.repl_state == REPL_STATE_SEND_CAPA\n   RETURN_ON_ERR(SendCommandAndReadResponse(\"REPLCONF capa eof capa psync2\"));\n   PC_RETURN_ON_BAD_RESPONSE(CheckRespIsSimpleReply(\"OK\"));\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 4b6d8646ff33..4f4988344d5e 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -2695,6 +2695,13 @@ void ServerFamily::ReplConf(CmdArgList args, ConnectionContext* cntx) {\n         return;\n       }\n       cntx->conn_state.replication_info.repl_listening_port = replica_listening_port;\n+      // We set a default value of ip_address here, because LISTENING-PORT is a mandatory field\n+      // but IP-ADDRESS is optional\n+      if (cntx->conn_state.replication_info.repl_ip_address.empty()) {\n+        cntx->conn_state.replication_info.repl_ip_address = cntx->conn()->RemoteEndpointAddress();\n+      }\n+    } else if (cmd == \"IP-ADDRESS\") {\n+      cntx->conn_state.replication_info.repl_ip_address = arg;\n     } else if (cmd == \"CLIENT-ID\" && args.size() == 2) {\n       auto info = dfly_cmd_->GetReplicaInfo(cntx);\n       DCHECK(info != nullptr);\n",
  "test_patch": "diff --git a/src/server/cluster/cluster_family_test.cc b/src/server/cluster/cluster_family_test.cc\nindex d523bb5ae35c..feaa1d6d5875 100644\n--- a/src/server/cluster/cluster_family_test.cc\n+++ b/src/server/cluster/cluster_family_test.cc\n@@ -696,7 +696,7 @@ class ClusterFamilyEmulatedTest : public ClusterFamilyTest {\n  public:\n   ClusterFamilyEmulatedTest() {\n     SetTestFlag(\"cluster_mode\", \"emulated\");\n-    SetTestFlag(\"cluster_announce_ip\", \"fake-host\");\n+    SetTestFlag(\"announce_ip\", \"fake-host\");\n   }\n };\n \ndiff --git a/tests/dragonfly/cluster_test.py b/tests/dragonfly/cluster_test.py\nindex 0e17ecf277f0..c9e2ef53e8a9 100644\n--- a/tests/dragonfly/cluster_test.py\n+++ b/tests/dragonfly/cluster_test.py\n@@ -199,7 +199,9 @@ def test_cluster_pipeline(self, cluster_client: redis.RedisCluster):\n         assert val == [True, \"bar\"]\n \n \n-@dfly_args({\"cluster_mode\": \"emulated\", \"cluster_announce_ip\": \"127.0.0.2\"})\n+# Unfortunately we can't test --announce_port here because that causes the Python Cluster client to\n+# throw if it can't access the port in `CLUSTER SLOTS` :|\n+@dfly_args({\"cluster_mode\": \"emulated\", \"announce_ip\": \"127.0.0.2\"})\n class TestEmulatedWithAnnounceIp:\n     def test_cluster_slots_command(self, df_server, cluster_client: redis.RedisCluster):\n         expected = {(0, 16383): {\"primary\": (\"127.0.0.2\", df_server.port), \"replicas\": []}}\n@@ -323,7 +325,7 @@ async def test_emulated_cluster_with_replicas(df_factory):\n     await close_clients(c_master, *c_replicas)\n \n \n-@dfly_args({\"cluster_mode\": \"emulated\", \"cluster_announce_ip\": \"127.0.0.2\"})\n+@dfly_args({\"cluster_mode\": \"emulated\"})\n async def test_cluster_info(async_client):\n     res = await async_client.execute_command(\"CLUSTER INFO\")\n     assert len(res) == 16\n@@ -347,7 +349,7 @@ async def test_cluster_info(async_client):\n     }\n \n \n-@dfly_args({\"cluster_mode\": \"emulated\", \"cluster_announce_ip\": \"127.0.0.2\"})\n+@dfly_args({\"cluster_mode\": \"emulated\", \"announce_ip\": \"127.0.0.2\"})\n @pytest.mark.asyncio\n async def test_cluster_nodes(df_server, async_client):\n     res = await async_client.execute_command(\"CLUSTER NODES\")\ndiff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex da027b8d7dac..f80984db3d44 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -2213,3 +2213,24 @@ async def test_replica_reconnect(df_factory, break_conn):\n     assert await c_replica.execute_command(\"get k\") == \"6789\"\n \n     await disconnect_clients(c_master, c_replica)\n+\n+\n+@pytest.mark.asyncio\n+async def test_announce_ip_port(df_factory):\n+    master = df_factory.create()\n+    replica = df_factory.create(announce_ip=\"overrode-host\", announce_port=\"1337\")\n+\n+    master.start()\n+    replica.start()\n+\n+    # Connect clients, connect replica to master\n+    c_master = master.client()\n+    c_replica = replica.client()\n+    await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\")\n+    await wait_available_async(c_replica)\n+\n+    role, node = await c_master.execute_command(\"role\")\n+    assert role == \"master\"\n+    host, port, _ = node[0]\n+    assert host == \"overrode-host\"\n+    assert port == \"1337\"\n",
  "problem_statement": "Support for replica-announce-ip and replica-announce-port\nWe host our Redis pods in K8s\r\nWhen Redis replicates with a master, Redis uses the pod IP to \"name\" the replica\r\nPod IPs are ephemeral, when the pod is bounced, it comes up with a new IP\r\nThis is problematic for Redis Sentinel because as pods are bounced, it sees a new IP address for the previous replica and creates a bloated list of \"dead replicas\"\r\nRedis Sentinel should not have any dead replicas, so the command sentinel reset SHARD_NAME removes them - however executing this after each pod cycle is toilsome\r\nWe mitigate this in K8s by provisioning a K8s Service with a ClusterIP\r\nOur helm-chart has an init container which discovers the ClusterIP for the StatefulSet Pod, and sets replica-announce-ip to this value\r\nRedis then advertises itself as being available at that IP address\n",
  "hints_text": "Need to see if it is possible to merge cluster_announce_ip and replica_announce_ip.\r\nseems that they both serve the same purpose - to announce an external ip, not visible to Dragonfly process",
  "created_at": "2024-08-01T05:46:28Z",
  "modified_files": [
    "README.ja-JP.md",
    "README.ko-KR.md",
    "README.md",
    "README.zh-CN.md",
    "src/server/cluster/cluster_family.cc",
    "src/server/conn_context.h",
    "src/server/dflycmd.cc",
    "src/server/main_service.cc",
    "src/server/replica.cc",
    "src/server/server_family.cc"
  ],
  "modified_test_files": [
    "src/server/cluster/cluster_family_test.cc",
    "tests/dragonfly/cluster_test.py",
    "tests/dragonfly/replication_test.py"
  ]
}