diff --git a/src/server/dragonfly_test.cc b/src/server/dragonfly_test.cc
index ca350d99819e..ffcd2d60e3a5 100644
--- a/src/server/dragonfly_test.cc
+++ b/src/server/dragonfly_test.cc
@@ -398,9 +398,9 @@ TEST_F(DflyEngineTest, PSubscribe) {
 
   ASSERT_EQ(1, SubscriberMessagesLen("IO1"));
 
-  facade::Connection::PubMessage msg = GetPublishedMessage("IO1", 0);
+  const facade::Connection::PubMessage& msg = GetPublishedMessage("IO1", 0);
   EXPECT_EQ("foo", *msg.message);
-  EXPECT_EQ("ab", msg.channel);
+  EXPECT_EQ("ab", *msg.channel);
   EXPECT_EQ("a*", msg.pattern);
 }
 
diff --git a/src/server/test_utils.cc b/src/server/test_utils.cc
index 59b36856b1f7..da688c0a9470 100644
--- a/src/server/test_utils.cc
+++ b/src/server/test_utils.cc
@@ -58,23 +58,21 @@ static vector<string> SplitLines(const std::string& src) {
   return res;
 }
 
-TestConnection::TestConnection(Protocol protocol)
-    : facade::Connection(protocol, nullptr, nullptr, nullptr) {
+TestConnection::TestConnection(Protocol protocol, io::StringSink* sink)
+    : facade::Connection(protocol, nullptr, nullptr, nullptr), sink_(sink) {
 }
 
-void TestConnection::SendMsgVecAsync(const PubMessage& pmsg) {
-  backing_str_.emplace_back(new string(pmsg.channel));
-  PubMessage dest;
-  dest.channel = *backing_str_.back();
-
-  backing_str_.emplace_back(new string(*pmsg.message));
-  dest.message = pmsg.message;
-
-  if (!pmsg.pattern.empty()) {
-    backing_str_.emplace_back(new string(pmsg.pattern));
-    dest.pattern = *backing_str_.back();
+void TestConnection::SendMsgVecAsync(PubMessage pmsg) {
+  if (pmsg.type == PubMessage::kPublish) {
+    messages.push_back(move(pmsg));
+  } else {
+    RedisReplyBuilder builder(sink_);
+    const char* action[2] = {"unsubscribe", "subscribe"};
+    builder.StartArray(3);
+    builder.SendBulkString(action[pmsg.type == PubMessage::kSubscribe]);
+    builder.SendBulkString(*pmsg.channel);
+    builder.SendLong(pmsg.channel_cnt);
   }
-  messages.push_back(dest);
 }
 
 class BaseFamilyTest::TestConnWrapper {
@@ -87,7 +85,7 @@ class BaseFamilyTest::TestConnWrapper {
   RespVec ParseResponse(bool fully_consumed);
 
   // returns: type(pmessage), pattern, channel, message.
-  facade::Connection::PubMessage GetPubMessage(size_t index) const;
+  const facade::Connection::PubMessage& GetPubMessage(size_t index) const;
 
   ConnectionContext* cmd_cntx() {
     return &cmd_cntx_;
@@ -117,7 +115,7 @@ class BaseFamilyTest::TestConnWrapper {
 };
 
 BaseFamilyTest::TestConnWrapper::TestConnWrapper(Protocol proto)
-    : dummy_conn_(new TestConnection(proto)), cmd_cntx_(&sink_, dummy_conn_.get()) {
+    : dummy_conn_(new TestConnection(proto, &sink_)), cmd_cntx_(&sink_, dummy_conn_.get()) {
 }
 
 BaseFamilyTest::TestConnWrapper::~TestConnWrapper() {
@@ -359,7 +357,8 @@ RespVec BaseFamilyTest::TestConnWrapper::ParseResponse(bool fully_consumed) {
   return res;
 }
 
-facade::Connection::PubMessage BaseFamilyTest::TestConnWrapper::GetPubMessage(size_t index) const {
+const facade::Connection::PubMessage& BaseFamilyTest::TestConnWrapper::GetPubMessage(
+    size_t index) const {
   CHECK_LT(index, dummy_conn_->messages.size());
   return dummy_conn_->messages[index];
 }
@@ -389,13 +388,10 @@ size_t BaseFamilyTest::SubscriberMessagesLen(string_view conn_id) const {
   return it->second->conn()->messages.size();
 }
 
-facade::Connection::PubMessage BaseFamilyTest::GetPublishedMessage(string_view conn_id,
-                                                                   size_t index) const {
-  facade::Connection::PubMessage res;
-
+const facade::Connection::PubMessage& BaseFamilyTest::GetPublishedMessage(string_view conn_id,
+                                                                          size_t index) const {
   auto it = connections_.find(conn_id);
-  if (it == connections_.end())
-    return res;
+  CHECK(it != connections_.end());
 
   return it->second->GetPubMessage(index);
 }
diff --git a/src/server/test_utils.h b/src/server/test_utils.h
index e7d2db24cee2..e2634db1556f 100644
--- a/src/server/test_utils.h
+++ b/src/server/test_utils.h
@@ -19,14 +19,14 @@ using namespace facade;
 
 class TestConnection : public facade::Connection {
  public:
-  TestConnection(Protocol protocol);
+  TestConnection(Protocol protocol, io::StringSink* sink);
 
-  void SendMsgVecAsync(const PubMessage& pmsg) final;
+  void SendMsgVecAsync(PubMessage pmsg) final;
 
   std::vector<PubMessage> messages;
 
  private:
-  std::vector<std::unique_ptr<std::string>> backing_str_;
+  io::StringSink* sink_;
 };
 
 class BaseFamilyTest : public ::testing::Test {
@@ -87,9 +87,8 @@ class BaseFamilyTest : public ::testing::Test {
   std::string GetId() const;
   size_t SubscriberMessagesLen(std::string_view conn_id) const;
 
-  // Returns message parts as returned by RESP:
-  // pmessage, pattern, channel, message
-  facade::Connection::PubMessage GetPublishedMessage(std::string_view conn_id, size_t index) const;
+  const facade::Connection::PubMessage& GetPublishedMessage(std::string_view conn_id,
+                                                            size_t index) const;
 
   std::unique_ptr<util::ProactorPool> pp_;
   std::unique_ptr<Service> service_;
diff --git a/tests/README.md b/tests/README.md
index e3db30f6e80e..dbb8af28f669 100644
--- a/tests/README.md
+++ b/tests/README.md
@@ -38,6 +38,10 @@ pip install -r dragonfly/requirements.txt
 to run pytest, run:
 `pytest -xv dragonfly`
 
+to run selectively, use:
+`pytest -xv dragonfly -k <substring>`
+For more pytest flags [check here](https://fig.io/manual/pytest).
+
 ## Writing tests
 The [Getting Started](https://docs.pytest.org/en/7.1.x/getting-started.html) guide is a great resource to become familiar with writing pytest test cases.
 
diff --git a/tests/dragonfly/connection_test.py b/tests/dragonfly/connection_test.py
index 58008012abfd..ffc014e4a01e 100644
--- a/tests/dragonfly/connection_test.py
+++ b/tests/dragonfly/connection_test.py
@@ -4,6 +4,8 @@
 import aioredis
 import async_timeout
 
+from . import DflyInstance
+
 
 async def run_monitor_eval(monitor, expected):
     async with monitor as mon:
@@ -278,6 +280,42 @@ def generate(max):
     assert state, message
 
 
+@pytest.mark.asyncio
+async def test_subsribers_with_active_publisher(df_server: DflyInstance, max_connections=100):
+    # TODO: I am not how to customize the max connections for the pool.
+    async_pool = aioredis.ConnectionPool(host="localhost", port=df_server.port,
+                                         db=0, decode_responses=True, max_connections=max_connections)
+
+    async def publish_worker():
+        client = aioredis.Redis(connection_pool=async_pool)
+        for i in range(0, 2000):
+            await client.publish("channel", f"message-{i}")
+        await client.close()
+
+    async def channel_reader(channel: aioredis.client.PubSub):
+        for i in range(0, 150):
+            try:
+                async with async_timeout.timeout(1):
+                    message = await channel.get_message(ignore_subscribe_messages=True)
+            except asyncio.TimeoutError:
+                break
+
+    async def subscribe_worker():
+        client = aioredis.Redis(connection_pool=async_pool)
+        pubsub = client.pubsub()
+        async with pubsub as p:
+            await pubsub.subscribe("channel")
+            await channel_reader(pubsub)
+            await pubsub.unsubscribe("channel")
+
+    # Create a publisher that sends constantly messages to the channel
+    # Then create subscribers that will subscribe to already active channel
+    pub_task = asyncio.create_task(publish_worker())
+    await asyncio.gather(*(subscribe_worker() for _ in range(max_connections - 10)))
+    await pub_task
+    await async_pool.disconnect()
+
+
 @pytest.mark.asyncio
 async def test_big_command(df_server, size=8 * 1024):
     reader, writer = await asyncio.open_connection('127.0.0.1', df_server.port)
