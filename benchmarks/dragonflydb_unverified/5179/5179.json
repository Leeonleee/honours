{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5179,
  "instance_id": "dragonflydb__dragonfly-5179",
  "issue_numbers": [
    "4883"
  ],
  "base_commit": "ade10fbdb835293aed13cbf0ee9ebee282ff1d1a",
  "patch": "diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc\nindex 9b8aede88315..ada7e40364c7 100644\n--- a/src/core/compact_object.cc\n+++ b/src/core/compact_object.cc\n@@ -375,13 +375,17 @@ static_assert(ascii_len(15) == 17);\n static_assert(ascii_len(16) == 18);\n static_assert(ascii_len(17) == 19);\n \n+struct Huffman {\n+  HuffmanEncoder encoder;\n+  HuffmanDecoder decoder;\n+};\n+\n struct TL {\n   MemoryResource* local_mr = PMR_NS::get_default_resource();\n   base::PODArray<uint8_t> tmp_buf;\n   string tmp_str;\n-  HuffmanEncoder huff_encoder;\n-  HuffmanDecoder huff_decoder;\n   size_t small_str_bytes;\n+  Huffman huff_keys;\n   uint64_t huff_encode_total = 0, huff_encode_success = 0;  // success/total metrics.\n };\n \n@@ -751,20 +755,27 @@ void CompactObj::InitThreadLocal(MemoryResource* mr) {\n   tl.tmp_buf = base::PODArray<uint8_t>{mr};\n }\n \n-bool CompactObj::InitHuffmanThreadLocal(std::string_view hufftable) {\n+bool CompactObj::InitHuffmanThreadLocal(HuffmanDomain domain, std::string_view hufftable) {\n   string err_msg;\n \n+  Huffman* huffman = nullptr;\n+  switch (domain) {\n+    case HUFF_KEYS:\n+      huffman = &tl.huff_keys;\n+      break;\n+  }\n+\n   // We do not allow overriding the existing huffman table once it is set.\n-  if (tl.huff_encoder.valid()) {\n+  if (huffman->encoder.valid()) {\n     return false;\n   }\n \n-  if (!tl.huff_encoder.Load(hufftable, &err_msg)) {\n+  if (!huffman->encoder.Load(hufftable, &err_msg)) {\n     LOG(DFATAL) << \"Failed to load huffman table: \" << err_msg;\n     return false;\n   }\n \n-  if (!tl.huff_decoder.Load(hufftable, &err_msg)) {\n+  if (!huffman->decoder.Load(hufftable, &err_msg)) {\n     LOG(DFATAL) << \"Failed to load huffman table: \" << err_msg;\n     return false;\n   }\n@@ -865,7 +876,7 @@ uint64_t CompactObj::HashCode() const {\n     size_t decoded_len = DecodedLen(taglen_, u_.inline_str[0]);\n     if (mask_bits_.encoding == HUFFMAN_ENC) {\n       if (decoded_len <= sizeof(buf) &&\n-          tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, decoded_len, buf)) {\n+          tl.huff_keys.decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, decoded_len, buf)) {\n         return XXH3_64bits_withSeed(buf, decoded_len, kHashSeed);\n       }\n     } else {\n@@ -1131,8 +1142,8 @@ void CompactObj::GetString(char* dest) const {\n         detail::ascii_unpack(to_byte(u_.inline_str), taglen_ + 2, dest);\n         break;\n       case HUFFMAN_ENC:\n-        tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)},\n-                               u_.inline_str[0] + taglen_ - 1, dest);\n+        tl.huff_keys.decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)},\n+                                    u_.inline_str[0] + taglen_ - 1, dest);\n         break;\n       case NONE_ENC:\n         memcpy(dest, u_.inline_str, taglen_);\n@@ -1155,8 +1166,8 @@ void CompactObj::GetString(char* dest) const {\n       DCHECK_EQ(OBJ_ENCODING_RAW, u_.r_obj.encoding());\n       size_t decoded_len = DecodedLen(u_.r_obj.Size(), *(const uint8_t*)u_.r_obj.inner_obj());\n       if (mask_bits_.encoding == HUFFMAN_ENC) {\n-        CHECK(tl.huff_decoder.Decode({(const char*)u_.r_obj.inner_obj() + 1, u_.r_obj.Size() - 1},\n-                                     decoded_len, dest));\n+        CHECK(tl.huff_keys.decoder.Decode(\n+            {(const char*)u_.r_obj.inner_obj() + 1, u_.r_obj.Size() - 1}, decoded_len, dest));\n         return;\n       }\n       detail::ascii_unpack_simd(to_byte(u_.r_obj.inner_obj()), decoded_len, dest);\n@@ -1174,7 +1185,7 @@ void CompactObj::GetString(char* dest) const {\n         next += slices[0].size() - 1;\n         memcpy(next, slices[1].data(), slices[1].size());\n         string_view src(reinterpret_cast<const char*>(tl.tmp_buf.data()), tl.tmp_buf.size());\n-        CHECK(tl.huff_decoder.Decode(src, decoded_len, dest));\n+        CHECK(tl.huff_keys.decoder.Decode(src, decoded_len, dest));\n         return;\n       }\n \n@@ -1388,7 +1399,7 @@ bool CompactObj::CmpEncoded(string_view sv) const {\n       constexpr size_t kMaxHuffLen = kInlineLen * 3;\n       if (sz <= kMaxHuffLen) {\n         char buf[kMaxHuffLen];\n-        CHECK(tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, sz, buf));\n+        CHECK(tl.huff_keys.decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, sz, buf));\n         return sv == string_view(buf, sz);\n       }\n     }\n@@ -1488,13 +1499,13 @@ void CompactObj::EncodeString(string_view str) {\n       kUseAsciiEncoding && str.size() < 19 && detail::validate_ascii_fast(str.data(), str.size());\n \n   // if !is_ascii, we try huffman encoding next.\n-  if (!is_ascii && str.size() <= kMaxHuffLen && tl.huff_encoder.valid()) {\n-    unsigned dest_len = tl.huff_encoder.CompressedBound(str.size());\n+  if (!is_ascii && str.size() <= kMaxHuffLen && tl.huff_keys.encoder.valid()) {\n+    unsigned dest_len = tl.huff_keys.encoder.CompressedBound(str.size());\n     // 1 byte for storing the size delta.\n     tl.tmp_buf.resize(1 + dest_len);\n     string err_msg;\n     ++tl.huff_encode_total;\n-    bool res = tl.huff_encoder.Encode(str, tl.tmp_buf.data() + 1, &dest_len, &err_msg);\n+    bool res = tl.huff_keys.encoder.Encode(str, tl.tmp_buf.data() + 1, &dest_len, &err_msg);\n     if (res) {\n       // we accept huffman encoding only if it is:\n       // 1. smaller than the original string by 20%\ndiff --git a/src/core/compact_object.h b/src/core/compact_object.h\nindex 1857ca008d3b..d5379b9817d2 100644\n--- a/src/core/compact_object.h\n+++ b/src/core/compact_object.h\n@@ -378,7 +378,13 @@ class CompactObj {\n \n   static Stats GetStatsThreadLocal();\n   static void InitThreadLocal(MemoryResource* mr);\n-  static bool InitHuffmanThreadLocal(std::string_view hufftable);\n+\n+  enum HuffmanDomain : uint8_t {\n+    HUFF_KEYS = 0,\n+    // TODO: add more domains.\n+  };\n+\n+  static bool InitHuffmanThreadLocal(HuffmanDomain domain, std::string_view hufftable);\n   static MemoryResource* memory_resource();  // thread-local.\n \n   template <typename T, typename... Args> static T* AllocateMR(Args&&... args) {\ndiff --git a/src/server/debugcmd.cc b/src/server/debugcmd.cc\nindex a3f986491e52..5fad41f04318 100644\n--- a/src/server/debugcmd.cc\n+++ b/src/server/debugcmd.cc\n@@ -1298,19 +1298,26 @@ void DebugCmd::Compression(CmdArgList args, facade::SinkReplyBuilder* builder) {\n   bool print_bintable = false;\n \n   if (parser.Check(\"SET\", &bintable)) {\n-    atomic_bool succeed = true;\n-    shard_set->RunBriefInParallel([&](EngineShard* shard) {\n-      if (!CompactObj::InitHuffmanThreadLocal(bintable)) {\n-        succeed = false;\n-      }\n-    });\n+    string raw;\n+    atomic_bool succeed = absl::Base64Unescape(bintable, &raw);\n+    if (succeed) {\n+      shard_set->RunBriefInParallel([&](EngineShard* shard) {\n+        if (!CompactObj::InitHuffmanThreadLocal(CompactObj::HUFF_KEYS, raw)) {\n+          succeed = false;\n+        }\n+      });\n+    }\n     return succeed ? builder->SendOk() : builder->SendError(\"Failed to set bintable\");\n   }\n \n   if (parser.Check(\"EXPORT\")) {\n     print_bintable = true;\n-  } else {\n-    parser.Check(\"IMPORT\", &bintable);\n+  } else if (parser.Check(\"IMPORT\", &bintable)) {\n+    string raw;\n+    bool succeed = absl::Base64Unescape(bintable, &raw);\n+    if (succeed) {\n+      bintable = raw;\n+    }\n   }\n \n   if (parser.HasNext()) {\n@@ -1366,7 +1373,6 @@ void DebugCmd::Compression(CmdArgList args, facade::SinkReplyBuilder* builder) {\n \n     if (print_bintable) {\n       bintable = huff_enc.Export();\n-      VLOG(1) << \"bintable: \" << absl::CHexEscape(bintable);\n     } else {\n       bintable.clear();\n     }\n@@ -1389,7 +1395,7 @@ void DebugCmd::Compression(CmdArgList args, facade::SinkReplyBuilder* builder) {\n   rb->SendDouble(ratio);\n   if (print_bintable) {\n     rb->SendSimpleString(\"bintable\");\n-    rb->SendBulkString(bintable);\n+    rb->SendBulkString(absl::Base64Escape(bintable));\n   }\n }\n \ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 2bb79854c858..23c8e3e1ab5a 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -119,6 +119,11 @@ ABSL_FLAG(size_t, serialization_max_chunk_size, 64_KB,\n ABSL_FLAG(uint32_t, max_squashed_cmd_num, 100,\n           \"Max number of commands squashed in a single shard during squash optimizaiton\");\n \n+ABSL_FLAG(string, huffman_table, \"\",\n+          \"a comma separated map: domain1:code1,domain2:code2,... where \"\n+          \"domain can currently be only KEYS, code is base64 encoded huffman table exported via \"\n+          \"DEBUG COMPRESSION EXPORT. if empty no huffman compression is appplied.\");\n+\n namespace dfly {\n \n #if defined(__linux__)\n@@ -712,6 +717,41 @@ void SetMaxSquashedCmdNum(int32_t val) {\n   shard_set->pool()->AwaitBrief(cb);\n }\n \n+void SetHuffmanTable(const std::string& huffman_table) {\n+  if (huffman_table.empty())\n+    return;\n+  vector<string_view> parts = absl::StrSplit(huffman_table, ',');\n+  for (const auto& part : parts) {\n+    vector<string_view> kv = absl::StrSplit(part, ':');\n+    if (kv.size() != 2 || kv[0].empty() || kv[1].empty()) {\n+      LOG(ERROR) << \"Invalid huffman table entry\" << part;\n+      continue;\n+    }\n+    string domain_str = absl::AsciiStrToUpper(kv[0]);\n+    optional<CompactObj::HuffmanDomain> domain;\n+    if (domain_str == \"KEYS\") {\n+      domain = CompactObj::HUFF_KEYS;\n+    } else {\n+      LOG(ERROR) << \"Unknown huffman domain: \" << kv[0];\n+      continue;\n+    }\n+    string unescaped;\n+    if (!absl::Base64Unescape(kv[1], &unescaped)) {\n+      LOG(ERROR) << \"Failed to decode base64 huffman table for domain \" << kv[0] << \" with value \"\n+                 << kv[1];\n+      continue;\n+    }\n+    atomic_bool success = true;\n+    shard_set->RunBriefInParallel([&](auto* shard) {\n+      if (!CompactObj::InitHuffmanThreadLocal(CompactObj::HUFF_KEYS, unescaped)) {\n+        success = false;\n+      }\n+    });\n+    LOG_IF(ERROR, !success) << \"Failed to set huffman table for domain \" << kv[0] << \" with value \"\n+                            << kv[1];\n+  }\n+}\n+\n }  // namespace\n \n Service::Service(ProactorPool* pp)\n@@ -865,6 +905,7 @@ void Service::Init(util::AcceptServer* acceptor, std::vector<facade::Listener*>\n   SetRssOomDenyRatioOnAllThreads(absl::GetFlag(FLAGS_rss_oom_deny_ratio));\n   SetSerializationMaxChunkSize(absl::GetFlag(FLAGS_serialization_max_chunk_size));\n   SetMaxSquashedCmdNum(absl::GetFlag(FLAGS_max_squashed_cmd_num));\n+  SetHuffmanTable(absl::GetFlag(FLAGS_huffman_table));\n \n   // Requires that shard_set will be initialized before because server_family_.Init might\n   // load the snapshot.\n",
  "test_patch": "diff --git a/src/core/compact_object_test.cc b/src/core/compact_object_test.cc\nindex 6a8d94e8632f..0476f6375687 100644\n--- a/src/core/compact_object_test.cc\n+++ b/src/core/compact_object_test.cc\n@@ -666,7 +666,7 @@ TEST_F(CompactObjectTest, HuffMan) {\n   HuffmanEncoder encoder;\n   ASSERT_TRUE(encoder.Build(hist.data(), hist.size() - 1, nullptr));\n   string bindata = encoder.Export();\n-  ASSERT_TRUE(CompactObj::InitHuffmanThreadLocal(bindata));\n+  ASSERT_TRUE(CompactObj::InitHuffmanThreadLocal(CompactObj::HUFF_KEYS, bindata));\n   for (unsigned i = 30; i < 2048; i += 10) {\n     string data(i, 'a');\n     cobj_.SetString(data);\n",
  "problem_statement": "Support keys compression in Dragonfly\nSee #4880 for motivation and as a prerequisite\n\n## feature description\n\n1. being able to enable keys huffman encoding via a run-time flag. \n2. can also disable it (via curl /flagz).\n3. Once enabled it samples the key space by scanning N ( hardcoded ) keys, builds the histogram the derivative data structures needed for encoding/decoding.\n4. The data structures can be built once during the process lifetime because decoding is dependent on them. \n5. Bonus: The data structures are immutable so might be shared among threads, but need to verify if it's easy to do (someone still needs to delete them upon service shutdown).\n6. Once they appear, `CompactObject::SetString` should be able to use huffman encoding.\n7. encoding stats like total raw size, total compressed size, tries, successful - should be exposed via \"info\".\n\n\n\n",
  "hints_text": "",
  "created_at": "2025-05-25T18:31:59Z",
  "modified_files": [
    "src/core/compact_object.cc",
    "src/core/compact_object.h",
    "src/server/debugcmd.cc",
    "src/server/main_service.cc"
  ],
  "modified_test_files": [
    "src/core/compact_object_test.cc"
  ]
}