diff --git a/src/core/compact_object.cc b/src/core/compact_object.cc
index 9b8aede88315..ada7e40364c7 100644
--- a/src/core/compact_object.cc
+++ b/src/core/compact_object.cc
@@ -375,13 +375,17 @@ static_assert(ascii_len(15) == 17);
 static_assert(ascii_len(16) == 18);
 static_assert(ascii_len(17) == 19);
 
+struct Huffman {
+  HuffmanEncoder encoder;
+  HuffmanDecoder decoder;
+};
+
 struct TL {
   MemoryResource* local_mr = PMR_NS::get_default_resource();
   base::PODArray<uint8_t> tmp_buf;
   string tmp_str;
-  HuffmanEncoder huff_encoder;
-  HuffmanDecoder huff_decoder;
   size_t small_str_bytes;
+  Huffman huff_keys;
   uint64_t huff_encode_total = 0, huff_encode_success = 0;  // success/total metrics.
 };
 
@@ -751,20 +755,27 @@ void CompactObj::InitThreadLocal(MemoryResource* mr) {
   tl.tmp_buf = base::PODArray<uint8_t>{mr};
 }
 
-bool CompactObj::InitHuffmanThreadLocal(std::string_view hufftable) {
+bool CompactObj::InitHuffmanThreadLocal(HuffmanDomain domain, std::string_view hufftable) {
   string err_msg;
 
+  Huffman* huffman = nullptr;
+  switch (domain) {
+    case HUFF_KEYS:
+      huffman = &tl.huff_keys;
+      break;
+  }
+
   // We do not allow overriding the existing huffman table once it is set.
-  if (tl.huff_encoder.valid()) {
+  if (huffman->encoder.valid()) {
     return false;
   }
 
-  if (!tl.huff_encoder.Load(hufftable, &err_msg)) {
+  if (!huffman->encoder.Load(hufftable, &err_msg)) {
     LOG(DFATAL) << "Failed to load huffman table: " << err_msg;
     return false;
   }
 
-  if (!tl.huff_decoder.Load(hufftable, &err_msg)) {
+  if (!huffman->decoder.Load(hufftable, &err_msg)) {
     LOG(DFATAL) << "Failed to load huffman table: " << err_msg;
     return false;
   }
@@ -865,7 +876,7 @@ uint64_t CompactObj::HashCode() const {
     size_t decoded_len = DecodedLen(taglen_, u_.inline_str[0]);
     if (mask_bits_.encoding == HUFFMAN_ENC) {
       if (decoded_len <= sizeof(buf) &&
-          tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, decoded_len, buf)) {
+          tl.huff_keys.decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, decoded_len, buf)) {
         return XXH3_64bits_withSeed(buf, decoded_len, kHashSeed);
       }
     } else {
@@ -1131,8 +1142,8 @@ void CompactObj::GetString(char* dest) const {
         detail::ascii_unpack(to_byte(u_.inline_str), taglen_ + 2, dest);
         break;
       case HUFFMAN_ENC:
-        tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)},
-                               u_.inline_str[0] + taglen_ - 1, dest);
+        tl.huff_keys.decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)},
+                                    u_.inline_str[0] + taglen_ - 1, dest);
         break;
       case NONE_ENC:
         memcpy(dest, u_.inline_str, taglen_);
@@ -1155,8 +1166,8 @@ void CompactObj::GetString(char* dest) const {
       DCHECK_EQ(OBJ_ENCODING_RAW, u_.r_obj.encoding());
       size_t decoded_len = DecodedLen(u_.r_obj.Size(), *(const uint8_t*)u_.r_obj.inner_obj());
       if (mask_bits_.encoding == HUFFMAN_ENC) {
-        CHECK(tl.huff_decoder.Decode({(const char*)u_.r_obj.inner_obj() + 1, u_.r_obj.Size() - 1},
-                                     decoded_len, dest));
+        CHECK(tl.huff_keys.decoder.Decode(
+            {(const char*)u_.r_obj.inner_obj() + 1, u_.r_obj.Size() - 1}, decoded_len, dest));
         return;
       }
       detail::ascii_unpack_simd(to_byte(u_.r_obj.inner_obj()), decoded_len, dest);
@@ -1174,7 +1185,7 @@ void CompactObj::GetString(char* dest) const {
         next += slices[0].size() - 1;
         memcpy(next, slices[1].data(), slices[1].size());
         string_view src(reinterpret_cast<const char*>(tl.tmp_buf.data()), tl.tmp_buf.size());
-        CHECK(tl.huff_decoder.Decode(src, decoded_len, dest));
+        CHECK(tl.huff_keys.decoder.Decode(src, decoded_len, dest));
         return;
       }
 
@@ -1388,7 +1399,7 @@ bool CompactObj::CmpEncoded(string_view sv) const {
       constexpr size_t kMaxHuffLen = kInlineLen * 3;
       if (sz <= kMaxHuffLen) {
         char buf[kMaxHuffLen];
-        CHECK(tl.huff_decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, sz, buf));
+        CHECK(tl.huff_keys.decoder.Decode({u_.inline_str + 1, size_t(taglen_ - 1)}, sz, buf));
         return sv == string_view(buf, sz);
       }
     }
@@ -1488,13 +1499,13 @@ void CompactObj::EncodeString(string_view str) {
       kUseAsciiEncoding && str.size() < 19 && detail::validate_ascii_fast(str.data(), str.size());
 
   // if !is_ascii, we try huffman encoding next.
-  if (!is_ascii && str.size() <= kMaxHuffLen && tl.huff_encoder.valid()) {
-    unsigned dest_len = tl.huff_encoder.CompressedBound(str.size());
+  if (!is_ascii && str.size() <= kMaxHuffLen && tl.huff_keys.encoder.valid()) {
+    unsigned dest_len = tl.huff_keys.encoder.CompressedBound(str.size());
     // 1 byte for storing the size delta.
     tl.tmp_buf.resize(1 + dest_len);
     string err_msg;
     ++tl.huff_encode_total;
-    bool res = tl.huff_encoder.Encode(str, tl.tmp_buf.data() + 1, &dest_len, &err_msg);
+    bool res = tl.huff_keys.encoder.Encode(str, tl.tmp_buf.data() + 1, &dest_len, &err_msg);
     if (res) {
       // we accept huffman encoding only if it is:
       // 1. smaller than the original string by 20%
diff --git a/src/core/compact_object.h b/src/core/compact_object.h
index 1857ca008d3b..d5379b9817d2 100644
--- a/src/core/compact_object.h
+++ b/src/core/compact_object.h
@@ -378,7 +378,13 @@ class CompactObj {
 
   static Stats GetStatsThreadLocal();
   static void InitThreadLocal(MemoryResource* mr);
-  static bool InitHuffmanThreadLocal(std::string_view hufftable);
+
+  enum HuffmanDomain : uint8_t {
+    HUFF_KEYS = 0,
+    // TODO: add more domains.
+  };
+
+  static bool InitHuffmanThreadLocal(HuffmanDomain domain, std::string_view hufftable);
   static MemoryResource* memory_resource();  // thread-local.
 
   template <typename T, typename... Args> static T* AllocateMR(Args&&... args) {
diff --git a/src/server/debugcmd.cc b/src/server/debugcmd.cc
index a3f986491e52..5fad41f04318 100644
--- a/src/server/debugcmd.cc
+++ b/src/server/debugcmd.cc
@@ -1298,19 +1298,26 @@ void DebugCmd::Compression(CmdArgList args, facade::SinkReplyBuilder* builder) {
   bool print_bintable = false;
 
   if (parser.Check("SET", &bintable)) {
-    atomic_bool succeed = true;
-    shard_set->RunBriefInParallel([&](EngineShard* shard) {
-      if (!CompactObj::InitHuffmanThreadLocal(bintable)) {
-        succeed = false;
-      }
-    });
+    string raw;
+    atomic_bool succeed = absl::Base64Unescape(bintable, &raw);
+    if (succeed) {
+      shard_set->RunBriefInParallel([&](EngineShard* shard) {
+        if (!CompactObj::InitHuffmanThreadLocal(CompactObj::HUFF_KEYS, raw)) {
+          succeed = false;
+        }
+      });
+    }
     return succeed ? builder->SendOk() : builder->SendError("Failed to set bintable");
   }
 
   if (parser.Check("EXPORT")) {
     print_bintable = true;
-  } else {
-    parser.Check("IMPORT", &bintable);
+  } else if (parser.Check("IMPORT", &bintable)) {
+    string raw;
+    bool succeed = absl::Base64Unescape(bintable, &raw);
+    if (succeed) {
+      bintable = raw;
+    }
   }
 
   if (parser.HasNext()) {
@@ -1366,7 +1373,6 @@ void DebugCmd::Compression(CmdArgList args, facade::SinkReplyBuilder* builder) {
 
     if (print_bintable) {
       bintable = huff_enc.Export();
-      VLOG(1) << "bintable: " << absl::CHexEscape(bintable);
     } else {
       bintable.clear();
     }
@@ -1389,7 +1395,7 @@ void DebugCmd::Compression(CmdArgList args, facade::SinkReplyBuilder* builder) {
   rb->SendDouble(ratio);
   if (print_bintable) {
     rb->SendSimpleString("bintable");
-    rb->SendBulkString(bintable);
+    rb->SendBulkString(absl::Base64Escape(bintable));
   }
 }
 
diff --git a/src/server/main_service.cc b/src/server/main_service.cc
index 2bb79854c858..23c8e3e1ab5a 100644
--- a/src/server/main_service.cc
+++ b/src/server/main_service.cc
@@ -119,6 +119,11 @@ ABSL_FLAG(size_t, serialization_max_chunk_size, 64_KB,
 ABSL_FLAG(uint32_t, max_squashed_cmd_num, 100,
           "Max number of commands squashed in a single shard during squash optimizaiton");
 
+ABSL_FLAG(string, huffman_table, "",
+          "a comma separated map: domain1:code1,domain2:code2,... where "
+          "domain can currently be only KEYS, code is base64 encoded huffman table exported via "
+          "DEBUG COMPRESSION EXPORT. if empty no huffman compression is appplied.");
+
 namespace dfly {
 
 #if defined(__linux__)
@@ -712,6 +717,41 @@ void SetMaxSquashedCmdNum(int32_t val) {
   shard_set->pool()->AwaitBrief(cb);
 }
 
+void SetHuffmanTable(const std::string& huffman_table) {
+  if (huffman_table.empty())
+    return;
+  vector<string_view> parts = absl::StrSplit(huffman_table, ',');
+  for (const auto& part : parts) {
+    vector<string_view> kv = absl::StrSplit(part, ':');
+    if (kv.size() != 2 || kv[0].empty() || kv[1].empty()) {
+      LOG(ERROR) << "Invalid huffman table entry" << part;
+      continue;
+    }
+    string domain_str = absl::AsciiStrToUpper(kv[0]);
+    optional<CompactObj::HuffmanDomain> domain;
+    if (domain_str == "KEYS") {
+      domain = CompactObj::HUFF_KEYS;
+    } else {
+      LOG(ERROR) << "Unknown huffman domain: " << kv[0];
+      continue;
+    }
+    string unescaped;
+    if (!absl::Base64Unescape(kv[1], &unescaped)) {
+      LOG(ERROR) << "Failed to decode base64 huffman table for domain " << kv[0] << " with value "
+                 << kv[1];
+      continue;
+    }
+    atomic_bool success = true;
+    shard_set->RunBriefInParallel([&](auto* shard) {
+      if (!CompactObj::InitHuffmanThreadLocal(CompactObj::HUFF_KEYS, unescaped)) {
+        success = false;
+      }
+    });
+    LOG_IF(ERROR, !success) << "Failed to set huffman table for domain " << kv[0] << " with value "
+                            << kv[1];
+  }
+}
+
 }  // namespace
 
 Service::Service(ProactorPool* pp)
@@ -865,6 +905,7 @@ void Service::Init(util::AcceptServer* acceptor, std::vector<facade::Listener*>
   SetRssOomDenyRatioOnAllThreads(absl::GetFlag(FLAGS_rss_oom_deny_ratio));
   SetSerializationMaxChunkSize(absl::GetFlag(FLAGS_serialization_max_chunk_size));
   SetMaxSquashedCmdNum(absl::GetFlag(FLAGS_max_squashed_cmd_num));
+  SetHuffmanTable(absl::GetFlag(FLAGS_huffman_table));
 
   // Requires that shard_set will be initialized before because server_family_.Init might
   // load the snapshot.
