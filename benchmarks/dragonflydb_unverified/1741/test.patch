diff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc
index 8b2b297be84d..95aa045d3326 100644
--- a/src/facade/reply_builder_test.cc
+++ b/src/facade/reply_builder_test.cc
@@ -232,7 +232,7 @@ TEST_F(RedisReplyBuilderTest, ErrorBuiltInMessage) {
       OpStatus::OUT_OF_MEMORY, OpStatus::INVALID_FLOAT, OpStatus::INVALID_INT,
       OpStatus::SYNTAX_ERR,    OpStatus::BUSY_GROUP,    OpStatus::INVALID_NUMERIC_RESULT};
   for (const auto& err : error_codes) {
-    const std::string_view error_name = RedisReplyBuilder::StatusToMsg(err);
+    const std::string_view error_name = StatusToMsg(err);
     const std::string_view error_type = GetErrorType(error_name);
 
     sink_.Clear();
@@ -251,6 +251,31 @@ TEST_F(RedisReplyBuilderTest, ErrorBuiltInMessage) {
   }
 }
 
+TEST_F(RedisReplyBuilderTest, ErrorReplyBuiltInMessage) {
+  ErrorReply err{OpStatus::OUT_OF_RANGE};
+  builder_->SendError(err);
+  ASSERT_TRUE(absl::StartsWith(str(), kErrorStart));
+  ASSERT_TRUE(absl::EndsWith(str(), kCRLF));
+  ASSERT_EQ(builder_->err_count().at(kIndexOutOfRange), 1);
+  ASSERT_EQ(str(), BuildExpectedErrorString(kIndexOutOfRange));
+
+  auto parsing_output = Parse();
+  ASSERT_TRUE(parsing_output.Verify(SinkSize()));
+  ASSERT_TRUE(parsing_output.IsError());
+  sink_.Clear();
+
+  err = ErrorReply{"e1", "e2"};
+  builder_->SendError(err);
+  ASSERT_TRUE(absl::StartsWith(str(), kErrorStart));
+  ASSERT_TRUE(absl::EndsWith(str(), kCRLF));
+  ASSERT_EQ(builder_->err_count().at("e2"), 1);
+  ASSERT_EQ(str(), BuildExpectedErrorString("e1"));
+
+  parsing_output = Parse();
+  ASSERT_TRUE(parsing_output.Verify(SinkSize()));
+  ASSERT_TRUE(parsing_output.IsError());
+}
+
 TEST_F(RedisReplyBuilderTest, ErrorNoneBuiltInMessage) {
   // All these op codes creating the same error message
   OpStatus none_unique_codes[] = {OpStatus::ENTRIES_ADDED_SMALL, OpStatus::SKIPPED,
@@ -258,7 +283,7 @@ TEST_F(RedisReplyBuilderTest, ErrorNoneBuiltInMessage) {
                                   OpStatus::TIMED_OUT,           OpStatus::STREAM_ID_SMALL};
   uint64_t error_count = 0;
   for (const auto& err : none_unique_codes) {
-    const std::string_view error_name = RedisReplyBuilder::StatusToMsg(err);
+    const std::string_view error_name = StatusToMsg(err);
     const std::string_view error_type = GetErrorType(error_name);
 
     sink_.Clear();
diff --git a/tests/dragonfly/__init__.py b/tests/dragonfly/__init__.py
index 5f4559009f9a..9d1c47c3e88b 100644
--- a/tests/dragonfly/__init__.py
+++ b/tests/dragonfly/__init__.py
@@ -106,7 +106,7 @@ def admin_port(self) -> int:
     def mc_port(self) -> int:
         if self.params.existing_mc_port:
             return self.params.existing_mc_port
-        return int(self.args.get("mc_port", "11211"))
+        return int(self.args.get("memcached_port", "11211"))
 
     @staticmethod
     def format_args(args):
diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py
index eda47b5cb27d..5ce59f229c49 100644
--- a/tests/dragonfly/replication_test.py
+++ b/tests/dragonfly/replication_test.py
@@ -7,6 +7,7 @@
 from redis import asyncio as aioredis
 from .utility import *
 from . import DflyInstanceFactory, dfly_args
+import pymemcache
 import logging
 
 BASE_PORT = 1111
@@ -1506,3 +1507,37 @@ async def test_replicaof_flag_disconnect(df_local_factory):
 
     role = await c_replica.role()
     assert role[0] == b"master"
+
+
+@pytest.mark.asyncio
+async def test_df_crash_on_memcached_error(df_local_factory):
+    master = df_local_factory.create(
+        port=BASE_PORT,
+        memcached_port=11211,
+        proactor_threads=2,
+    )
+
+    replica = df_local_factory.create(
+        port=master.port + 1,
+        memcached_port=master.mc_port + 1,
+        proactor_threads=2,
+    )
+
+    master.start()
+    replica.start()
+
+    c_master = aioredis.Redis(port=master.port)
+    await wait_available_async(c_master)
+
+    c_replica = aioredis.Redis(port=replica.port)
+    await c_replica.execute_command(f"REPLICAOF localhost {master.port}")
+    await wait_available_async(c_replica)
+    await wait_for_replica_status(c_replica, status="up")
+    await c_replica.close()
+
+    memcached_client = pymemcache.Client(f"localhost:{replica.mc_port}")
+
+    with pytest.raises(pymemcache.exceptions.MemcacheClientError):
+        memcached_client.set(b"key", b"data", noreply=False)
+
+    await c_master.close()
