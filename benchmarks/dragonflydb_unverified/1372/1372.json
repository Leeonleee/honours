{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1372,
  "instance_id": "dragonflydb__dragonfly-1372",
  "issue_numbers": [
    "1162"
  ],
  "base_commit": "30b8bcad4e7f3a78b404f60005c042362069656e",
  "patch": "diff --git a/src/redis/stream.h b/src/redis/stream.h\nindex 4ca981e1c56b..5f8e2ed9ba90 100644\n--- a/src/redis/stream.h\n+++ b/src/redis/stream.h\n@@ -159,6 +159,7 @@ streamCG *streamCreateCG(stream *s, const char *name, size_t namelen, streamID *\n streamNACK *streamCreateNACK(streamConsumer *consumer);\n void streamDecodeID(void *buf, streamID *id);\n int streamCompareID(streamID *a, streamID *b);\n+int streamEntryExists(stream *s, streamID *id);\n void streamFreeNACK(streamNACK *na);\n int streamIncrID(streamID *id);\n int streamDecrID(streamID *id);\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex cf243cff149c..364ee793c022 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -920,6 +920,143 @@ OpResult<pair<stream*, streamCG*>> FindGroup(const OpArgs& op_args, string_view\n   return res;\n }\n \n+constexpr uint8_t kClaimForce = 1 << 0;\n+constexpr uint8_t kClaimJustID = 1 << 1;\n+\n+struct ClaimOpts {\n+  string_view group;\n+  string_view consumer;\n+  int64 min_idle_time;\n+  int64 delivery_time = -1;\n+  int retry = -1;\n+  uint8_t flags = 0;\n+};\n+\n+struct ClaimInfo {\n+  bool justid = false;\n+  vector<streamID> ids;\n+  RecordVec records;\n+};\n+\n+void AppendClaimResultItem(ClaimInfo& result, stream* s, streamID id) {\n+  int64_t numfields;\n+  if (result.justid) {\n+    result.ids.push_back(id);\n+    return;\n+  }\n+  streamIterator it;\n+  streamID cid;\n+  streamIteratorStart(&it, s, &id, &id, 0);\n+  while (streamIteratorGetID(&it, &cid, &numfields)) {\n+    Record rec;\n+    rec.id = cid;\n+    rec.kv_arr.reserve(numfields);\n+\n+    /* Emit the field-value pairs. */\n+    while (numfields--) {\n+      unsigned char *key, *value;\n+      int64_t key_len, value_len;\n+      streamIteratorGetField(&it, &key, &value, &key_len, &value_len);\n+      string skey(reinterpret_cast<char*>(key), key_len);\n+      string sval(reinterpret_cast<char*>(value), value_len);\n+\n+      rec.kv_arr.emplace_back(std::move(skey), std::move(sval));\n+    }\n+    result.records.push_back(std::move(rec));\n+  }\n+  streamIteratorStop(&it);\n+}\n+\n+// XCLAIM key group consumer min-idle-time id\n+OpResult<ClaimInfo> OpClaim(const OpArgs& op_args, string_view key, const ClaimOpts& opts,\n+                            absl::Span<streamID> ids) {\n+  OpResult<pair<stream*, streamCG*>> cgr_res = FindGroup(op_args, key, opts.group);\n+  if (!cgr_res)\n+    return cgr_res.status();\n+  stream* s = cgr_res->first;\n+  streamCG* scg = cgr_res->second;\n+  if (!scg) {\n+    return OpStatus::SKIPPED;\n+  }\n+  streamConsumer* consumer = nullptr;\n+  auto now = GetCurrentTimeMs();\n+  ClaimInfo result;\n+  result.justid = (opts.flags & kClaimJustID);\n+\n+  for (streamID id : ids) {\n+    std::array<uint8_t, sizeof(streamID)> buf;\n+    StreamEncodeID(buf.begin(), &id);\n+\n+    streamNACK* nack = (streamNACK*)raxFind(scg->pel, buf.begin(), sizeof(buf));\n+    if (!streamEntryExists(s, &id)) {\n+      if (nack != raxNotFound) {\n+        /* Release the NACK */\n+        raxRemove(scg->pel, buf.begin(), sizeof(buf), nullptr);\n+        raxRemove(nack->consumer->pel, buf.begin(), sizeof(buf), nullptr);\n+        streamFreeNACK(nack);\n+      }\n+      continue;\n+    }\n+\n+    // We didn't find a nack but the FORCE option is given.\n+    // Create the NACK forcefully.\n+    if ((opts.flags & kClaimForce) && nack == raxNotFound) {\n+      /* Create the NACK. */\n+      nack = streamCreateNACK(nullptr);\n+      raxInsert(scg->pel, buf.begin(), sizeof(buf), nack, nullptr);\n+    }\n+\n+    // We found the nack, continue.\n+    if (nack != raxNotFound) {\n+      // First check if the entry id exceeds the `min_idle_time`.\n+      if (nack->consumer && opts.min_idle_time) {\n+        mstime_t this_idle = now - nack->delivery_time;\n+        if (this_idle < opts.min_idle_time) {\n+          continue;\n+        }\n+      }\n+\n+      // Try to get the consumer. If not found, create a new one.\n+      op_args.shard->tmp_str1 =\n+          sdscpylen(op_args.shard->tmp_str1, opts.consumer.data(), opts.consumer.size());\n+      if ((consumer = streamLookupConsumer(scg, op_args.shard->tmp_str1, SLC_NO_REFRESH)) ==\n+          nullptr) {\n+        consumer = streamCreateConsumer(scg, op_args.shard->tmp_str1, nullptr, 0,\n+                                        SCC_NO_NOTIFY | SCC_NO_DIRTIFY);\n+      }\n+\n+      // If the entry belongs to the same consumer, we don't have to\n+      // do anything. Else remove the entry from the old consumer.\n+      if (nack->consumer != consumer) {\n+        /* Remove the entry from the old consumer.\n+         * Note that nack->consumer is NULL if we created the\n+         * NACK above because of the FORCE option. */\n+        if (nack->consumer) {\n+          raxRemove(nack->consumer->pel, buf.begin(), sizeof(buf), nullptr);\n+        }\n+      }\n+      // Set the delivery time for the entry.\n+      nack->delivery_time = opts.delivery_time;\n+      /* Set the delivery attempts counter if given, otherwise\n+       * autoincrement unless JUSTID option provided */\n+      if (opts.retry >= 0) {\n+        nack->delivery_count = opts.retry;\n+      } else if (!(opts.flags & kClaimJustID)) {\n+        nack->delivery_count++;\n+      }\n+      if (nack->consumer != consumer) {\n+        /* Add the entry in the new consumer local PEL. */\n+        raxInsert(consumer->pel, buf.begin(), sizeof(buf), nack, nullptr);\n+        nack->consumer = consumer;\n+      }\n+\n+      /* Send the reply for this entry. */\n+      AppendClaimResultItem(result, s, id);\n+    }\n+  }\n+  return result;\n+}\n+\n // XGROUP DESTROY key groupname\n OpStatus OpDestroyGroup(const OpArgs& op_args, string_view key, string_view gname) {\n   OpResult<pair<stream*, streamCG*>> cgr_res = FindGroup(op_args, key, gname);\n@@ -1518,6 +1655,119 @@ void StreamFamily::XAdd(CmdArgList args, ConnectionContext* cntx) {\n   return (*cntx)->SendError(add_result.status());\n }\n \n+absl::InlinedVector<streamID, 8> GetXclaimIds(CmdArgList& args) {\n+  size_t i;\n+  absl::InlinedVector<streamID, 8> ids;\n+  for (i = 0; i < args.size(); ++i) {\n+    ParsedStreamId parsed_id;\n+    string_view str_id = ArgS(args, i);\n+    if (!ParseID(str_id, true, 0, &parsed_id)) {\n+      if (i > 0) {\n+        break;\n+      }\n+      return ids;\n+    }\n+    ids.push_back(parsed_id.val);\n+  }\n+  args.remove_prefix(i);\n+  return ids;\n+}\n+\n+void ParseXclaimOptions(CmdArgList& args, ClaimOpts& opts, ConnectionContext* cntx) {\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    ToUpper(&args[i]);\n+    string_view arg = ArgS(args, i);\n+    bool remaining_args = args.size() - i - 1 > 0;\n+\n+    if (remaining_args) {\n+      if (arg == \"IDLE\") {\n+        arg = ArgS(args, ++i);\n+        if (!absl::SimpleAtoi(arg, &opts.delivery_time)) {\n+          return (*cntx)->SendError(kInvalidIntErr);\n+        }\n+        continue;\n+      } else if (arg == \"TIME\") {\n+        arg = ArgS(args, ++i);\n+        if (!absl::SimpleAtoi(arg, &opts.delivery_time)) {\n+          return (*cntx)->SendError(kInvalidIntErr);\n+        }\n+        continue;\n+      } else if (arg == \"RETRYCOUNT\") {\n+        arg = ArgS(args, ++i);\n+        if (!absl::SimpleAtoi(arg, &opts.retry)) {\n+          return (*cntx)->SendError(kInvalidIntErr);\n+        }\n+        continue;\n+      } else if (arg == \"LASTID\") {\n+        arg = ArgS(args, ++i);\n+        // TODO: implement lastID\n+        continue;\n+      }\n+    }\n+    if (arg == \"FORCE\") {\n+      opts.flags |= kClaimForce;\n+    } else if (arg == \"JUSTID\") {\n+      opts.flags |= kClaimJustID;\n+    } else {\n+      return (*cntx)->SendError(\"Unknown argument given for XCLAIM command\", kSyntaxErr);\n+    }\n+  }\n+}\n+\n+void StreamFamily::XClaim(CmdArgList args, ConnectionContext* cntx) {\n+  ClaimOpts opts;\n+  string_view key = ArgS(args, 0);\n+  opts.group = ArgS(args, 1);\n+  opts.consumer = ArgS(args, 2);\n+  if (!absl::SimpleAtoi(ArgS(args, 3), &opts.min_idle_time)) {\n+    return (*cntx)->SendError(kSyntaxErr);\n+  }\n+  // Ignore negative min-idle-time\n+  opts.min_idle_time = std::max(opts.min_idle_time, static_cast<int64>(0));\n+  args.remove_prefix(4);\n+\n+  auto ids = GetXclaimIds(args);\n+  if (ids.empty()) {\n+    // No ids given.\n+    return (*cntx)->SendError(kInvalidStreamId, kSyntaxErrType);\n+  }\n+\n+  // parse the options\n+  ParseXclaimOptions(args, opts, cntx);\n+  if (auto now = GetCurrentTimeMs();\n+      opts.delivery_time < 0 || static_cast<uint64_t>(opts.delivery_time) > now)\n+    opts.delivery_time = now;\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    return OpClaim(t->GetOpArgs(shard), key, opts, absl::Span{ids.data(), ids.size()});\n+  };\n+  OpResult<ClaimInfo> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n+  if (!result) {\n+    (*cntx)->SendError(result.status());\n+    return;\n+  }\n+\n+  ClaimInfo cresult = result.value();\n+  if (cresult.justid) {\n+    (*cntx)->StartArray(cresult.ids.size());\n+    for (auto id : cresult.ids) {\n+      (*cntx)->SendBulkString(StreamIdRepr(id));\n+    }\n+  } else {\n+    const RecordVec& crec = cresult.records;\n+    (*cntx)->StartArray(crec.size());\n+    for (const auto& item : crec) {\n+      (*cntx)->StartArray(2);\n+      (*cntx)->SendBulkString(StreamIdRepr(item.id));\n+      (*cntx)->StartArray(item.kv_arr.size() * 2);\n+      for (const auto& [k, v] : item.kv_arr) {\n+        (*cntx)->SendBulkString(k);\n+        (*cntx)->SendBulkString(v);\n+      }\n+    }\n+  }\n+}\n+\n void StreamFamily::XDel(CmdArgList args, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 0);\n   args.remove_prefix(1);\n@@ -2274,6 +2524,7 @@ void StreamFamily::XRangeGeneric(CmdArgList args, bool is_rev, ConnectionContext\n \n namespace acl {\n constexpr uint32_t kXAdd = WRITE | STREAM | FAST;\n+constexpr uint32_t kXClaim = WRITE | FAST;\n constexpr uint32_t kXDel = WRITE | STREAM | FAST;\n constexpr uint32_t kXGroup = SLOW;\n constexpr uint32_t kXInfo = SLOW;\n@@ -2293,6 +2544,7 @@ void StreamFamily::Register(CommandRegistry* registry) {\n \n   *registry\n       << CI{\"XADD\", CO::WRITE | CO::DENYOOM | CO::FAST, -5, 1, 1, 1, acl::kXAdd}.HFUNC(XAdd)\n+      << CI{\"XCLAIM\", CO::WRITE | CO::FAST, -6, 1, 1, 1, acl::kXClaim}.HFUNC(XClaim)\n       << CI{\"XDEL\", CO::WRITE | CO::FAST, -3, 1, 1, 1, acl::kXDel}.HFUNC(XDel)\n       << CI{\"XGROUP\", CO::WRITE | CO::DENYOOM, -3, 2, 2, 1, acl::kXGroup}.HFUNC(XGroup)\n       << CI{\"XINFO\", CO::READONLY | CO::NOSCRIPT, -2, 0, 0, 0, acl::kXInfo}.HFUNC(XInfo)\ndiff --git a/src/server/stream_family.h b/src/server/stream_family.h\nindex 876063407a77..f4abfca9c2bd 100644\n--- a/src/server/stream_family.h\n+++ b/src/server/stream_family.h\n@@ -17,6 +17,7 @@ class StreamFamily {\n \n  private:\n   static void XAdd(CmdArgList args, ConnectionContext* cntx);\n+  static void XClaim(CmdArgList args, ConnectionContext* cntx);\n   static void XDel(CmdArgList args, ConnectionContext* cntx);\n   static void XGroup(CmdArgList args, ConnectionContext* cntx);\n   static void XInfo(CmdArgList args, ConnectionContext* cntx);\n",
  "test_patch": "diff --git a/src/server/stream_family_test.cc b/src/server/stream_family_test.cc\nindex 37bcdab63cb3..cee3fe68a165 100644\n--- a/src/server/stream_family_test.cc\n+++ b/src/server/stream_family_test.cc\n@@ -416,6 +416,81 @@ TEST_F(StreamFamilyTest, XGroupConsumer) {\n   EXPECT_THAT(resp, ErrArg(\"NOGROUP\"));\n }\n \n+TEST_F(StreamFamilyTest, Xclaim) {\n+  Run({\"xadd\", \"foo\", \"1-0\", \"k1\", \"v1\"});\n+  Run({\"xadd\", \"foo\", \"1-1\", \"k2\", \"v2\"});\n+  Run({\"xadd\", \"foo\", \"1-2\", \"k3\", \"v3\"});\n+  Run({\"xadd\", \"foo\", \"1-3\", \"k4\", \"v4\"});\n+\n+  // create a group for foo stream\n+  Run({\"xgroup\", \"create\", \"foo\", \"group\", \"0\"});\n+  // alice consume all the stream entries\n+  Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \">\"});\n+\n+  // bob claims alice's two pending stream entries\n+  auto resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"0\", \"1-2\", \"1-3\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\n+                        RespArray(ElementsAre(\"1-2\", RespArray(ElementsAre(\"k3\", \"v3\")))),\n+                        RespArray(ElementsAre(\"1-3\", RespArray(ElementsAre(\"k4\", \"v4\")))))));\n+\n+  // bob really have these claimed entries\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\n+                  \"foo\", RespArray(ElementsAre(\n+                             RespArray(ElementsAre(\"1-2\", RespArray(ElementsAre(\"k3\", \"v3\")))),\n+                             RespArray(ElementsAre(\"1-3\", RespArray(ElementsAre(\"k4\", \"v4\")))))))));\n+\n+  // alice no longer have those entries\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\n+                  \"foo\", RespArray(ElementsAre(\n+                             RespArray(ElementsAre(\"1-0\", RespArray(ElementsAre(\"k1\", \"v1\")))),\n+                             RespArray(ElementsAre(\"1-1\", RespArray(ElementsAre(\"k2\", \"v2\")))))))));\n+\n+  // xclaim ensures that entries before the min-idle-time are not claimed by bob\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"3600000\", \"1-0\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp,\n+              RespArray(ElementsAre(\n+                  \"foo\", RespArray(ElementsAre(\n+                             RespArray(ElementsAre(\"1-0\", RespArray(ElementsAre(\"k1\", \"v1\")))),\n+                             RespArray(ElementsAre(\"1-1\", RespArray(ElementsAre(\"k2\", \"v2\")))))))));\n+\n+  Run({\"xadd\", \"foo\", \"1-4\", \"k5\", \"v5\"});\n+  Run({\"xreadgroup\", \"group\", \"group\", \"alice\", \"streams\", \"foo\", \">\"});\n+  // xclaim returns only claimed ids when justid is set\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"0\", \"1-0\", \"1-4\", \"justid\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"1-0\", \"1-4\"));\n+\n+  Run({\"xadd\", \"foo\", \"1-5\", \"k6\", \"v6\"});\n+  // bob should claim the id forcefully even if it is not yet present in group pel\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"0\", \"1-5\", \"force\", \"justid\"});\n+  EXPECT_THAT(resp.GetString(), \"1-5\");\n+  resp = Run({\"xreadgroup\", \"group\", \"group\", \"bob\", \"streams\", \"foo\", \"0\"});\n+  EXPECT_THAT(resp.GetVec()[1].GetVec()[4].GetVec(),\n+              ElementsAre(\"1-5\", RespArray(ElementsAre(\"k6\", \"v6\"))));\n+\n+  TEST_current_time_ms += 2000;\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"alice\", \"0\", \"1-4\", \"TIME\",\n+              absl::StrCat(TEST_current_time_ms - 500), \"justid\"});\n+  EXPECT_THAT(resp.GetString(), \"1-4\");\n+  // min idle time is exceeded for this entry\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"600\", \"1-4\"});\n+  EXPECT_THAT(resp, ArrLen(0));\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"400\", \"1-4\", \"justid\"});\n+  EXPECT_THAT(resp.GetString(), \"1-4\");\n+\n+  //  test RETRYCOUNT\n+  Run({\"xadd\", \"foo\", \"1-6\", \"k7\", \"v7\"});\n+  resp = Run({\"xclaim\", \"foo\", \"group\", \"bob\", \"0\", \"1-6\", \"force\", \"justid\", \"retrycount\", \"5\"});\n+  EXPECT_THAT(resp.GetString(), \"1-6\");\n+  resp = Run({\"xpending\", \"foo\", \"group\", \"1-6\", \"1-6\", \"1\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"1-6\", \"bob\", ArgType(RespExpr::INT64), IntArg(5)));\n+}\n+\n TEST_F(StreamFamilyTest, XTrim) {\n   Run({\"xadd\", \"foo\", \"1-*\", \"k\", \"v\"});\n   Run({\"xadd\", \"foo\", \"1-*\", \"k\", \"v\"});\n",
  "problem_statement": "implement xclaim\n\n",
  "hints_text": "Hey @romange, would like to work on XCLAIM :)\nSure, @Abhra303 ! :)",
  "created_at": "2023-06-08T13:00:00Z",
  "modified_files": [
    "src/redis/stream.h",
    "src/server/stream_family.cc",
    "src/server/stream_family.h"
  ],
  "modified_test_files": [
    "src/server/stream_family_test.cc"
  ]
}