{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5436,
  "instance_id": "dragonflydb__dragonfly-5436",
  "issue_numbers": [
    "3877"
  ],
  "base_commit": "25f3b0c7d5c0e3c4837f9dc18dd8d79d3ff95d88",
  "patch": "diff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 0ad8a07f1edf..122e6ac573ad 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1588,7 +1588,7 @@ OpResult<KeyIndex> DetermineKeys(const CommandId* cid, CmdArgList args) {\n       bonus = 0;  // Z<xxx>STORE <key> commands\n \n     unsigned num_keys_index;\n-    if (absl::StartsWith(name, \"EVAL\") || name == \"BLMPOP\")\n+    if (absl::StartsWith(name, \"EVAL\") || name == \"BLMPOP\" || name == \"BZMPOP\")\n       num_keys_index = 1;\n     else\n       num_keys_index = bonus ? *bonus + 1 : 0;\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex e4c38ce7f7ec..875ed81dbda3 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -48,6 +48,13 @@ using ScoredArray = ZSetFamily::ScoredArray;\n using ScoredMemberView = ZSetFamily::ScoredMemberView;\n using ScoredMemberSpan = ZSetFamily::ScoredMemberSpan;\n \n+struct ValidateZMPopResult {\n+  uint32_t num_keys;\n+  bool is_max;\n+  int pop_count;\n+  float timeout;\n+};\n+\n inline zrangespec GetZrangeSpec(bool reverse, const ZSetFamily::ScoreInterval& si) {\n   auto interval = si;\n   if (reverse)\n@@ -1140,6 +1147,17 @@ auto OpPopCount(const ZSetFamily::ZRangeSpec& range_spec, const OpArgs& op_args,\n     op_args.GetDbSlice().Del(op_args.db_cntx, res_it->it);\n   }\n \n+  // Checking if command conatins flag with no autojournal\n+  // and we are assuming auto journaling is not re-enabled.\n+  if ((op_args.tx->GetCId()->opt_mask() & CO::NO_AUTOJOURNAL) && op_args.shard->journal()) {\n+    auto reverse = range_spec.params.reverse;\n+    // Checking if interval is actually TopNScored or something else before proceeding.\n+    DCHECK(std::holds_alternative<ZSetFamily::TopNScored>(range_spec.interval));\n+    auto count = std::get<ZSetFamily::TopNScored>(range_spec.interval);\n+    string command = (reverse ? \"ZPOPMAX\" : \"ZPOPMIN\");\n+    RecordJournal(op_args, command, ArgSlice{key, absl::StrCat(count)}, 1);\n+  }\n+\n   return iv.PopResult();\n }\n \n@@ -1819,39 +1837,50 @@ std::optional<std::string_view> GetFirstNonEmptyKeyFound(EngineShard* shard, Tra\n   return std::nullopt;\n }\n \n-// Validates the ZMPop command arguments and extracts the values to the output params.\n+// Validates the ZMPop and BZMPop command arguments and extracts the values to the output params.\n // If the arguments are invalid sends the appropiate error to builder and returns false.\n-bool ValidateZMPopCommand(CmdArgList args, uint32* num_keys, bool* is_max, int* pop_count,\n-                          SinkReplyBuilder* builder) {\n+bool ValidateZMPopCommand(CmdArgList args, bool is_blocking, SinkReplyBuilder* builder,\n+                          ValidateZMPopResult* result) {\n   CmdArgParser parser{args};\n \n-  if (!SimpleAtoi(parser.Next(), num_keys)) {\n+  if (is_blocking) {\n+    if (!absl::SimpleAtof(parser.Next(), &result->timeout)) {\n+      builder->SendError(\"timeout is not a float or out of range\");\n+      return false;\n+    }\n+    if (result->timeout < 0) {\n+      builder->SendError(\"timeout is negative\");\n+      return false;\n+    }\n+  }\n+\n+  if (!SimpleAtoi(parser.Next(), &(result->num_keys))) {\n     builder->SendError(kUintErr);\n     return false;\n   }\n \n-  if (*num_keys <= 0 || !parser.HasAtLeast(*num_keys + 1)) {\n+  if (result->num_keys <= 0 || !parser.HasAtLeast(result->num_keys + 1)) {\n     // We should have at least num_keys keys + a MIN/MAX arg.\n     builder->SendError(kSyntaxErr);\n     return false;\n   }\n   // Skip over the keys themselves.\n-  parser.Skip(*num_keys);\n+  parser.Skip(result->num_keys);\n \n   // We know we have at least one more arg (we checked above).\n   if (parser.Check(\"MAX\")) {\n-    *is_max = true;\n+    result->is_max = true;\n   } else if (parser.Check(\"MIN\")) {\n-    *is_max = false;\n+    result->is_max = false;\n   } else {\n     builder->SendError(kSyntaxErr);\n     return false;\n   }\n \n-  *pop_count = 1;\n+  result->pop_count = 1;\n   // Check if we have additional COUNT argument.\n   if (parser.HasNext()) {\n-    if (!parser.Check(\"COUNT\", pop_count)) {\n+    if (!parser.Check(\"COUNT\", &result->pop_count)) {\n       builder->SendError(kSyntaxErr);\n       return false;\n     }\n@@ -2401,11 +2430,10 @@ void ZSetFamily::ZInterCard(CmdArgList args, const CommandContext& cmd_cntx) {\n   builder->SendLong(result.value().size());\n }\n \n-void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n-  uint32 num_keys;\n-  bool is_max;\n-  int pop_count;\n-  if (!ValidateZMPopCommand(args, &num_keys, &is_max, &pop_count, cmd_cntx.rb)) {\n+// Generic function for ZMPop and BZMPop commands\n+void ZMPopGeneric(CmdArgList args, const CommandContext& cmd_cntx, bool is_blocking) {\n+  ValidateZMPopResult zmpop_args;\n+  if (!ValidateZMPopCommand(args, is_blocking, cmd_cntx.rb, &zmpop_args)) {\n     return;\n   }\n   auto* response_builder = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n@@ -2428,7 +2456,7 @@ void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n   // Keep all the keys found (first only for each shard) in a set for fast lookups.\n   absl::flat_hash_set<std::string_view> first_found_keys_for_shard;\n   // We can have at most one result from each shard.\n-  first_found_keys_for_shard.reserve(std::min(shard_set->size(), num_keys));\n+  first_found_keys_for_shard.reserve(std::min(shard_set->size(), zmpop_args.num_keys));\n   for (const auto& key : first_found_key_per_shard_vec) {\n     if (!key.has_value()) {\n       continue;\n@@ -2439,7 +2467,8 @@ void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n   // Now that we have the first non empty key from each shard, find the first overall first key and\n   // pop elements from it.\n   std::optional<std::string_view> key_to_pop = std::nullopt;\n-  ArgRange arg_keys(args.subspan(1, num_keys));\n+  // BZMPOP have 1 extra argument as compared to ZMPOP hence adding 1 is is_blocking is true\n+  ArgRange arg_keys(args.subspan(1 + is_blocking, zmpop_args.num_keys));\n   // Find the first arg_key which exists in any shard and is not empty.\n   for (std::string_view key : arg_keys) {\n     if (first_found_keys_for_shard.contains(key)) {\n@@ -2448,15 +2477,52 @@ void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n     }\n   }\n \n-  if (!key_to_pop.has_value()) {\n+  if (!key_to_pop.has_value() && (!is_blocking || cmd_cntx.tx->IsMulti())) {\n     cmd_cntx.tx->Conclude();\n     response_builder->SendNull();\n     return;\n   }\n+  // if we don't have any key to pop and it's blocking then we will block it using `WaitOnWatch`\n+  if (is_blocking && !key_to_pop.has_value()) {\n+    auto trans = cmd_cntx.tx;\n+    auto cntx = cmd_cntx.conn_cntx;\n+    auto* ns = &trans->GetNamespace();\n+\n+    auto limit_tp = Transaction::time_point::max();\n+    auto limit_ms = (unsigned)(zmpop_args.timeout * 1000);\n+    if (limit_ms > 0) {\n+      using namespace std::chrono;\n+      limit_tp = steady_clock::now() + milliseconds(limit_ms);\n+    }\n+    const auto key_checker = [ns](EngineShard* owner, const DbContext& context, Transaction*,\n+                                  std::string_view key) -> bool {\n+      return ns->GetDbSlice(owner->shard_id()).FindReadOnly(context, key, OBJ_ZSET).ok();\n+    };\n+\n+    DCHECK(trans->IsScheduled());  // Checking if the transaction is scheduled before calling\n+                                   // `WaitOnWatch`\n+    auto status = trans->WaitOnWatch(limit_tp, Transaction::kShardArgs, key_checker, &cntx->blocked,\n+                                     &cntx->paused);\n+\n+    if (status != OpStatus::OK) {\n+      response_builder->SendNull();\n+      return;\n+    }\n+\n+    auto cb = [&key_to_pop](Transaction* t, EngineShard* shard) {\n+      if (auto wake_key = t->GetWakeKey(shard->shard_id()); wake_key) {\n+        key_to_pop = *wake_key;\n+      }\n+      return OpStatus::OK;\n+    };\n+    trans->Execute(std::move(cb), false);\n+  }\n+\n+  DCHECK(key_to_pop.has_value());\n \n   // Pop elements from relevant set.\n-  OpResult<ScoredArray> pop_result =\n-      ZPopMinMaxInternal(*key_to_pop, FilterShards::YES, pop_count, is_max, cmd_cntx.tx);\n+  OpResult<ScoredArray> pop_result = ZPopMinMaxInternal(\n+      *key_to_pop, FilterShards::YES, zmpop_args.pop_count, zmpop_args.is_max, cmd_cntx.tx);\n \n   if (pop_result.status() == OpStatus::WRONG_TYPE) {\n     return response_builder->SendError(kWrongTypeErr);\n@@ -2466,6 +2532,14 @@ void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n   response_builder->SendLabeledScoredArray(*key_to_pop, pop_result.value());\n }\n \n+void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n+  ZMPopGeneric(args, cmd_cntx, false);\n+}\n+\n+void ZSetFamily::BZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n+  ZMPopGeneric(args, cmd_cntx, true);\n+}\n+\n void ZSetFamily::ZPopMax(CmdArgList args, const CommandContext& cmd_cntx) {\n   ZPopMinMaxFromArgs(args, true, cmd_cntx.tx, cmd_cntx.rb);\n }\n@@ -2737,6 +2811,7 @@ constexpr uint32_t kZInter = READ | SORTEDSET | SLOW;\n constexpr uint32_t kZInterCard = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZLexCount = READ | SORTEDSET | FAST;\n constexpr uint32_t kZMPop = WRITE | SORTEDSET | SLOW;\n+constexpr uint32_t kBZMPop = WRITE | SORTEDSET | SLOW | BLOCKING;\n constexpr uint32_t kZPopMax = WRITE | SORTEDSET | FAST;\n constexpr uint32_t kZPopMin = WRITE | SORTEDSET | FAST;\n constexpr uint32_t kZRem = WRITE | SORTEDSET | FAST;\n@@ -2782,7 +2857,13 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n       << CI{\"ZINTERCARD\", CO::READONLY | CO::VARIADIC_KEYS, -3, 2, 2, acl::kZInterCard}.HFUNC(\n              ZInterCard)\n       << CI{\"ZLEXCOUNT\", CO::READONLY, 4, 1, 1, acl::kZLexCount}.HFUNC(ZLexCount)\n-      << CI{\"ZMPOP\", CO::SLOW | CO::WRITE | CO::VARIADIC_KEYS, -4, 2, 2, acl::kZMPop}.HFUNC(ZMPop)\n+      << CI{\"ZMPOP\",    CO::SLOW | CO::WRITE | CO::VARIADIC_KEYS | CO::NO_AUTOJOURNAL, -4, 2, 2,\n+            acl::kZMPop}\n+             .HFUNC(ZMPop)\n+      << CI{\"BZMPOP\", CO::SLOW | CO::WRITE | CO::VARIADIC_KEYS | CO::BLOCKING | CO::NO_AUTOJOURNAL,\n+            -5,       3,\n+            3,        acl::kBZMPop}\n+             .HFUNC(BZMPop)\n \n       << CI{\"ZPOPMAX\", CO::FAST | CO::WRITE, -2, 1, 1, acl::kZPopMax}.HFUNC(ZPopMax)\n       << CI{\"ZPOPMIN\", CO::FAST | CO::WRITE, -2, 1, 1, acl::kZPopMin}.HFUNC(ZPopMin)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex 2fa35f127391..b248bab39883 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -113,6 +113,7 @@ class ZSetFamily {\n   static void ZInterCard(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZLexCount(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZMPop(CmdArgList args, const CommandContext& cmd_cntx);\n+  static void BZMPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZPopMax(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZPopMin(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZRange(CmdArgList args, const CommandContext& cmd_cntx);\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex ee32e2c7e9b8..289a6a0ab87a 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -4,6 +4,8 @@\n \n #include \"server/zset_family.h\"\n \n+#include <vector>\n+\n #include \"base/gtest.h\"\n #include \"base/logging.h\"\n #include \"facade/facade_test.h\"\n@@ -906,6 +908,118 @@ TEST_F(ZSetFamilyTest, ZMPop) {\n   EXPECT_THAT(resp, RespArray(ElementsAre(\"y1\", \"1\")));\n }\n \n+TEST_F(ZSetFamilyTest, BZMPopInvalidSyntax) {\n+  // Not enough arguments.\n+  auto resp = Run({\"bzmpop\", \"1\", \"1\", \"a\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  // Zero keys.\n+  resp = Run({\"bzmpop\", \"1\", \"0\", \"MIN\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"at least 1 input key is needed\"));\n+\n+  // Number of keys not uint.\n+  resp = Run({\"bzmpop\", \"1\", \"aa\", \"a\", \"MIN\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Missing MIN/MAX.\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"a\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Wrong number of keys.\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"a\", \"b\", \"MAX\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Count with no number.\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"a\", \"MAX\", \"COUNT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Count number is not uint.\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"a\", \"MIN\", \"COUNT\", \"boo\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Too many arguments.\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"c\", \"MAX\", \"COUNT\", \"2\", \"foo\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Negative time argument.\n+  resp = Run({\"bzmpop\", \"-1\", \"1\", \"a\", \"MIN\"});\n+  EXPECT_THAT(resp, ErrArg(\"timeout is negative\"));\n+}\n+\n+TEST_F(ZSetFamilyTest, BZMPop) {\n+  // Min operation.\n+  auto resp = Run({\"zadd\", \"a\", \"1\", \"a1\", \"2\", \"a2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"a\", \"MIN\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"a\", {{\"a1\", \"1\"}}));\n+\n+  resp = Run({\"ZRANGE\", \"a\", \"0\", \"-1\", \"WITHSCORES\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"a2\", \"2\")));\n+\n+  // Max operation.\n+  resp = Run({\"zadd\", \"b\", \"1\", \"b1\", \"2\", \"b2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"b\", \"MAX\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"b\", {{\"b2\", \"2\"}}));\n+\n+  resp = Run({\"ZRANGE\", \"b\", \"0\", \"-1\", \"WITHSCORES\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"b1\", \"1\")));\n+\n+  // Count > 1.\n+  resp = Run({\"zadd\", \"c\", \"1\", \"c1\", \"2\", \"c2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"c\", \"MAX\", \"COUNT\", \"2\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"c\", {{\"c1\", \"1\"}, {\"c2\", \"2\"}}));\n+\n+  resp = Run({\"zcard\", \"c\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // Count > #elements in set.\n+  resp = Run({\"zadd\", \"d\", \"1\", \"d1\", \"2\", \"d2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"bzmpop\", \"1\", \"1\", \"d\", \"MAX\", \"COUNT\", \"3\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"d\", {{\"d1\", \"1\"}, {\"d2\", \"2\"}}));\n+\n+  resp = Run({\"zcard\", \"d\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // First non empty set is not the first set.\n+  resp = Run({\"zadd\", \"x\", \"1\", \"x1\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"zadd\", \"y\", \"1\", \"y1\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"bzmpop\", \"1\", \"3\", \"empty\", \"x\", \"y\", \"MAX\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"x\", {{\"x1\", \"1\"}}));\n+\n+  resp = Run({\"zcard\", \"x\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  resp = Run({\"ZRANGE\", \"y\", \"0\", \"-1\", \"WITHSCORES\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"y1\", \"1\")));\n+}\n+\n+TEST_F(ZSetFamilyTest, BMPOPBlockingTimeout) {\n+  RespExpr resp0;\n+\n+  auto start = absl::Now();\n+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+    resp0 = Run({\"BZMPOP\", \"1\", \"1\", \"zset1\", \"MIN\"});\n+    LOG(INFO) << \"BZMPOP\";\n+  });\n+  fb0.Join();\n+  auto dur = absl::Now() - start;\n+\n+  // Check that the timeout duration is not too crazy.\n+  EXPECT_LT(AbsDuration(dur - absl::Milliseconds(1000)), absl::Milliseconds(300));\n+  EXPECT_THAT(resp0, ArgType(RespExpr::NIL));\n+}\n+\n TEST_F(ZSetFamilyTest, ZPopMin) {\n   auto resp = Run({\"zadd\", \"key\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\", \"4\", \"d\", \"5\", \"e\", \"6\", \"f\"});\n   EXPECT_THAT(resp, IntArg(6));\n@@ -1016,6 +1130,23 @@ TEST_F(ZSetFamilyTest, BlockingIsReleased) {\n \n       Run({\"DEL\", key});\n     }\n+\n+    // Tests for BZMPOP command\n+    for (auto& cmd : unblocking_commands) {\n+      RespExpr resp0;\n+      auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+        resp0 = Run({\"BZMPOP\", \"0\", \"3\", \"zset1\", \"zset2\", \"zset3\", \"MIN\"});\n+        LOG(INFO) << \"BZMPOP\";\n+      });\n+\n+      pp_->at(1)->Await([&] { return Run({cmd.data(), cmd.size()}); });\n+      fb0.Join();\n+\n+      ASSERT_THAT(resp0, ArrLen(2)) << cmd[0];\n+      EXPECT_THAT(resp0, ContainsLabeledScoredArray(key, {{\"x\", \"2\"}})) << cmd[0];\n+\n+      Run({\"DEL\", key});\n+    }\n   }\n }\n \ndiff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex cb298f1a5a13..2fa0a37be0d7 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -746,6 +746,24 @@ async def check_expire(key):\n             [r\"XTRIM k-stream MINID 0\", r\"SREM k-one-element-set value[12]\"],\n         )\n \n+        # check BZMPOP turns into ZPOPMAX and ZPOPMIN command\n+        await c_master.zadd(\"key\", {\"a\": 1, \"b\": 2, \"c\": 3})\n+        await skip_cmd()\n+        await check(\"BZMPOP 0 3 key3 key2 key MAX COUNT 3\", r\"ZPOPMAX key 3\")\n+\n+        await c_master.zadd(\"key\", {\"a\": 1, \"b\": 2, \"c\": 3})\n+        await skip_cmd()\n+        await check(\"BZMPOP 0 3 key3 key2 key MIN\", r\"ZPOPMIN key 1\")\n+\n+        # Check ZMPOP turns into ZPOPMAX and ZPOPMIN commands\n+        await c_master.zadd(\"key\", {\"a\": 1, \"b\": 2, \"c\": 3})\n+        await skip_cmd()\n+        await check(\"ZMPOP 3 key3 key2 key MIN COUNT 3\", r\"ZPOPMIN key 3\")\n+\n+        await c_master.zadd(\"key\", {\"a\": 1, \"b\": 2, \"c\": 3})\n+        await skip_cmd()\n+        await check(\"ZMPOP 3 key3 key2 key MAX\", r\"ZPOPMAX key 1\")\n+\n \n \"\"\"\n Test automatic replication of expiry.\n",
  "problem_statement": "implement BZMPOP\nredis command documentation :\nhttps://redis.io/docs/latest/commands/bzmpop/\n",
  "hints_text": "",
  "created_at": "2025-07-09T02:30:07Z",
  "modified_files": [
    "src/server/transaction.cc",
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc",
    "tests/dragonfly/replication_test.py"
  ]
}