{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 456,
  "instance_id": "dragonflydb__dragonfly-456",
  "issue_numbers": [
    "422"
  ],
  "base_commit": "1c483f123e03a2c4b4eff47b191b1b91d6c367d8",
  "patch": "diff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex b55d234deeb4..92f24e0b1215 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -16,9 +16,9 @@ extern \"C\" {\n #include \"facade/error.h\"\n #include \"server/command_registry.h\"\n #include \"server/conn_context.h\"\n+#include \"server/container_utils.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/transaction.h\"\n-#include \"server/container_utils.h\"\n \n namespace dfly {\n \n@@ -122,11 +122,7 @@ OpResult<PrimeIterator> FindZEntry(const ZParams& zparams, const OpArgs& op_args\n   return it;\n }\n \n-enum class Action {\n-  RANGE = 0,\n-  REMOVE = 1,\n-  POP = 2\n-};\n+enum class Action { RANGE = 0, REMOVE = 1, POP = 2 };\n \n class IntervalVisitor {\n  public:\n@@ -269,10 +265,13 @@ void IntervalVisitor::operator()(ZSetFamily::TopNScored sc) {\n }\n \n void IntervalVisitor::ActionRange(unsigned start, unsigned end) {\n-  container_utils::IterateSortedSet(zobj_, [this](container_utils::ContainerEntry ce, double score){\n-    result_.emplace_back(ce.ToString(), score);\n-    return true;\n-  }, start, end, params_.reverse, params_.with_scores);\n+  container_utils::IterateSortedSet(\n+      zobj_,\n+      [this](container_utils::ContainerEntry ce, double score) {\n+        result_.emplace_back(ce.ToString(), score);\n+        return true;\n+      },\n+      start, end, params_.reverse, params_.with_scores);\n }\n \n void IntervalVisitor::ActionRange(const zrangespec& range) {\n@@ -513,9 +512,9 @@ void IntervalVisitor::PopListPack(ZSetFamily::TopNScored sc) {\n   long long vlong = 0;\n \n   if (params_.reverse) {\n-    eptr = lpSeek(zl,-2);\n+    eptr = lpSeek(zl, -2);\n   } else {\n-    eptr = lpSeek(zl,0);\n+    eptr = lpSeek(zl, 0);\n   }\n \n   /* Get score pointer for the first element. */\n@@ -537,11 +536,11 @@ void IntervalVisitor::PopListPack(ZSetFamily::TopNScored sc) {\n   if (params_.reverse) {\n     /* If the number of elements to delete is greater than the listpack length,\n      * we set the start to 0 because lpseek fails to search beyond length in reverse */\n-    start = (2*sc > lpLength(zl)) ? 0 : -2*sc;\n+    start = (2 * sc > lpLength(zl)) ? 0 : -2 * sc;\n   }\n \n   /* We can finally delete the elements */\n-  zobj_->ptr = lpDeleteRange(zl, start, 2*sc);\n+  zobj_->ptr = lpDeleteRange(zl, start, 2 * sc);\n }\n \n void IntervalVisitor::PopSkipList(ZSetFamily::TopNScored sc) {\n@@ -1204,7 +1203,41 @@ void ZSetFamily::ZLexCount(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void ZSetFamily::ZRange(CmdArgList args, ConnectionContext* cntx) {\n-  ZRangeGeneric(std::move(args), false, cntx);\n+  RangeParams range_params;\n+\n+  for (size_t i = 4; i < args.size(); ++i) {\n+    ToUpper(&args[i]);\n+\n+    string_view cur_arg = ArgS(args, i);\n+    if (cur_arg == \"BYSCORE\") {\n+      if (range_params.interval_type == RangeParams::IntervalType::LEX) {\n+        return (*cntx)->SendError(\"BYSCORE and BYLEX options are not compatible\");\n+      }\n+      range_params.interval_type = RangeParams::IntervalType::SCORE;\n+    } else if (cur_arg == \"BYLEX\") {\n+      if (range_params.interval_type == RangeParams::IntervalType::SCORE) {\n+        return (*cntx)->SendError(\"BYSCORE and BYLEX options are not compatible\");\n+      }\n+      range_params.interval_type = RangeParams::IntervalType::LEX;\n+    } else if (cur_arg == \"REV\") {\n+      range_params.reverse = true;\n+    } else if (cur_arg == \"WITHSCORES\") {\n+      range_params.with_scores = true;\n+    } else if (cur_arg == \"LIMIT\") {\n+      if (i + 3 > args.size()) {\n+        return (*cntx)->SendError(kSyntaxErr);\n+      }\n+      string_view os = ArgS(args, i + 1);\n+      string_view cs = ArgS(args, i + 2);\n+      if (!SimpleAtoi(os, &range_params.offset) || !SimpleAtoi(cs, &range_params.limit)) {\n+        return (*cntx)->SendError(kInvalidIntErr);\n+      }\n+      i += 2;\n+    } else {\n+      return cntx->reply_builder()->SendError(absl::StrCat(\"unsupported option \", cur_arg));\n+    }\n+  }\n+  ZRangeGeneric(std::move(args), range_params, cntx);\n }\n \n void ZSetFamily::ZRank(CmdArgList args, ConnectionContext* cntx) {\n@@ -1212,23 +1245,25 @@ void ZSetFamily::ZRank(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void ZSetFamily::ZRevRange(CmdArgList args, ConnectionContext* cntx) {\n-  ZRangeGeneric(std::move(args), true, cntx);\n-}\n-\n-void ZSetFamily::ZRevRangeByScore(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 1);\n-  string_view min_s = ArgS(args, 2);\n-  string_view max_s = ArgS(args, 3);\n-\n   RangeParams range_params;\n   range_params.reverse = true;\n-  args.remove_prefix(4);\n \n-  if (!ParseRangeByScoreParams(args, &range_params)) {\n-    return (*cntx)->SendError(kSyntaxErr);\n+  for (size_t i = 4; i < args.size(); ++i) {\n+    ToUpper(&args[i]);\n+\n+    string_view cur_arg = ArgS(args, i);\n+    if (cur_arg == \"WITHSCORES\") {\n+      range_params.with_scores = true;\n+    } else {\n+      return cntx->reply_builder()->SendError(absl::StrCat(\"unsupported option \", cur_arg));\n+    }\n   }\n \n-  ZRangeByScoreInternal(key, min_s, max_s, range_params, cntx);\n+  ZRangeGeneric(std::move(args), range_params, cntx);\n+}\n+\n+void ZSetFamily::ZRevRangeByScore(CmdArgList args, ConnectionContext* cntx) {\n+  ZRangeByScoreInternal(std::move(args), true, cntx);\n }\n \n void ZSetFamily::ZRevRank(CmdArgList args, ConnectionContext* cntx) {\n@@ -1236,12 +1271,20 @@ void ZSetFamily::ZRevRank(CmdArgList args, ConnectionContext* cntx) {\n }\n \n void ZSetFamily::ZRangeByLex(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 1);\n-  string_view min_s = ArgS(args, 2);\n-  string_view max_s = ArgS(args, 3);\n+  ZRangeByLexInternal(std::move(args), false, cntx);\n+}\n+void ZSetFamily::ZRevRangeByLex(CmdArgList args, ConnectionContext* cntx) {\n+  ZRangeByLexInternal(std::move(args), true, cntx);\n+}\n+\n+void ZSetFamily::ZRangeByLexInternal(CmdArgList args, bool reverse, ConnectionContext* cntx) {\n   uint32_t offset = 0;\n   uint32_t count = kuint32max;\n \n+  RangeParams range_params;\n+  range_params.interval_type = RangeParams::IntervalType::LEX;\n+  range_params.reverse = reverse;\n+\n   if (args.size() > 4) {\n     if (args.size() != 7)\n       return (*cntx)->SendError(kSyntaxErr);\n@@ -1251,42 +1294,18 @@ void ZSetFamily::ZRangeByLex(CmdArgList args, ConnectionContext* cntx) {\n       return (*cntx)->SendError(kSyntaxErr);\n     string_view os = ArgS(args, 5);\n     string_view cs = ArgS(args, 6);\n-    if (!SimpleAtoi(os, &count) || !SimpleAtoi(cs, &count)) {\n+    if (!SimpleAtoi(os, &offset) || !SimpleAtoi(cs, &count)) {\n       return (*cntx)->SendError(kInvalidIntErr);\n     }\n   }\n+  range_params.offset = offset;\n+  range_params.limit = count;\n \n-  LexInterval li;\n-  if (!ParseLexBound(min_s, &li.first) || !ParseLexBound(max_s, &li.second)) {\n-    return (*cntx)->SendError(kLexRangeErr);\n-  }\n-\n-  ZRangeSpec range_spec;\n-  range_spec.params.offset = offset;\n-  range_spec.params.limit = count;\n-  range_spec.interval = li;\n-\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpRange(range_spec, t->GetOpArgs(shard), key);\n-  };\n-\n-  OpResult<ScoredArray> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n-  OutputScoredArrayResult(result, range_spec.params, cntx);\n+  ZRangeGeneric(args, range_params, cntx);\n }\n \n void ZSetFamily::ZRangeByScore(CmdArgList args, ConnectionContext* cntx) {\n-  string_view key = ArgS(args, 1);\n-  string_view min_s = ArgS(args, 2);\n-  string_view max_s = ArgS(args, 3);\n-\n-  RangeParams range_params;\n-  args.remove_prefix(4);\n-\n-  if (!ParseRangeByScoreParams(args, &range_params)) {\n-    return (*cntx)->SendError(kSyntaxErr);\n-  }\n-\n-  ZRangeByScoreInternal(key, min_s, max_s, range_params, cntx);\n+  ZRangeByScoreInternal(std::move(args), false, cntx);\n }\n \n void ZSetFamily::ZRemRangeByRank(CmdArgList args, ConnectionContext* cntx) {\n@@ -1492,23 +1511,14 @@ void ZSetFamily::ZUnionStore(CmdArgList args, ConnectionContext* cntx) {\n   (*cntx)->SendLong(smvec.size());\n }\n \n-void ZSetFamily::ZRangeByScoreInternal(string_view key, string_view min_s, string_view max_s,\n-                                       const RangeParams& params, ConnectionContext* cntx) {\n-  ZRangeSpec range_spec;\n-  range_spec.params = params;\n-\n-  ScoreInterval si;\n-  if (!ParseBound(min_s, &si.first) || !ParseBound(max_s, &si.second)) {\n-    return (*cntx)->SendError(kFloatRangeErr);\n+void ZSetFamily::ZRangeByScoreInternal(CmdArgList args, bool reverse, ConnectionContext* cntx) {\n+  RangeParams range_params;\n+  range_params.interval_type = RangeParams::IntervalType::SCORE;\n+  range_params.reverse = reverse;\n+  if (!ParseRangeByScoreParams(args.subspan(4), &range_params)) {\n+    return (*cntx)->SendError(kSyntaxErr);\n   }\n-  range_spec.interval = si;\n-\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpRange(range_spec, t->GetOpArgs(shard), key);\n-  };\n-\n-  OpResult<ScoredArray> result = cntx->transaction->ScheduleSingleHopT(std::move(cb));\n-  OutputScoredArrayResult(result, params, cntx);\n+  ZRangeGeneric(args, range_params, cntx);\n }\n \n void ZSetFamily::OutputScoredArrayResult(const OpResult<ScoredArray>& result,\n@@ -1545,44 +1555,42 @@ void ZSetFamily::ZRemRangeGeneric(string_view key, const ZRangeSpec& range_spec,\n   }\n }\n \n-void ZSetFamily::ZRangeGeneric(CmdArgList args, bool reverse, ConnectionContext* cntx) {\n+void ZSetFamily::ZRangeGeneric(CmdArgList args, RangeParams range_params, ConnectionContext* cntx) {\n   string_view key = ArgS(args, 1);\n   string_view min_s = ArgS(args, 2);\n   string_view max_s = ArgS(args, 3);\n \n-  bool parse_score = false;\n-  RangeParams range_params;\n-  range_params.reverse = reverse;\n-\n-  for (size_t i = 4; i < args.size(); ++i) {\n-    ToUpper(&args[i]);\n+  ZRangeSpec range_spec;\n+  range_spec.params = range_params;\n \n-    string_view cur_arg = ArgS(args, i);\n-    if (!reverse && cur_arg == \"BYSCORE\") {\n-      parse_score = true;\n-    } else if (cur_arg == \"WITHSCORES\") {\n-      range_params.with_scores = true;\n-    } else {\n-      return cntx->reply_builder()->SendError(absl::StrCat(\"unsupported option \", cur_arg));\n+  switch (range_params.interval_type) {\n+    case RangeParams::IntervalType::SCORE: {\n+      ScoreInterval si;\n+      if (!ParseBound(min_s, &si.first) || !ParseBound(max_s, &si.second)) {\n+        return (*cntx)->SendError(kFloatRangeErr);\n+      }\n+      range_spec.interval = si;\n+      break;\n+    }\n+    case RangeParams::IntervalType::LEX: {\n+      LexInterval li;\n+      if (!ParseLexBound(min_s, &li.first) || !ParseLexBound(max_s, &li.second)) {\n+        return (*cntx)->SendError(kLexRangeErr);\n+      }\n+      range_spec.interval = li;\n+      break;\n+    }\n+    case RangeParams::IntervalType::RANK: {\n+      IndexInterval ii;\n+      if (!SimpleAtoi(min_s, &ii.first) || !SimpleAtoi(max_s, &ii.second)) {\n+        (*cntx)->SendError(kInvalidIntErr);\n+        return;\n+      }\n+      range_spec.interval = ii;\n+      break;\n     }\n   }\n \n-  if (parse_score) {\n-    ZRangeByScoreInternal(key, min_s, max_s, range_params, cntx);\n-    return;\n-  }\n-\n-  IndexInterval ii;\n-\n-  if (!SimpleAtoi(min_s, &ii.first) || !SimpleAtoi(max_s, &ii.second)) {\n-    (*cntx)->SendError(kInvalidIntErr);\n-    return;\n-  }\n-\n-  ZRangeSpec range_spec;\n-  range_spec.params = range_params;\n-  range_spec.interval = ii;\n-\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     return OpRange(range_spec, t->GetOpArgs(shard), key);\n   };\n@@ -1617,7 +1625,7 @@ bool ZSetFamily::ParseRangeByScoreParams(CmdArgList args, RangeParams* params) {\n     if (cur_arg == \"WITHSCORES\") {\n       params->with_scores = true;\n     } else if (cur_arg == \"LIMIT\") {\n-      if (i + 3 != args.size())\n+      if (i + 3 > args.size())\n         return false;\n \n       string_view os = ArgS(args, i + 1);\n@@ -1625,7 +1633,7 @@ bool ZSetFamily::ParseRangeByScoreParams(CmdArgList args, RangeParams* params) {\n \n       if (!SimpleAtoi(os, &params->offset) || !SimpleAtoi(cs, &params->limit))\n         return false;\n-      i += 3;\n+      i += 2;\n     } else {\n       return false;\n     }\n@@ -1758,7 +1766,8 @@ OpResult<double> ZSetFamily::OpScore(const OpArgs& op_args, string_view key, str\n   return score;\n }\n \n-OpResult<ZSetFamily::MScoreResponse> ZSetFamily::OpMScore(const OpArgs& op_args, string_view key, ArgSlice members) {\n+OpResult<ZSetFamily::MScoreResponse> ZSetFamily::OpMScore(const OpArgs& op_args, string_view key,\n+                                                          ArgSlice members) {\n   OpResult<PrimeIterator> res_it = op_args.shard->db_slice().Find(op_args.db_cntx, key, OBJ_ZSET);\n   if (!res_it)\n     return res_it.status();\n@@ -1784,7 +1793,8 @@ OpResult<ZSetFamily::MScoreResponse> ZSetFamily::OpMScore(const OpArgs& op_args,\n   return scores;\n }\n \n-auto ZSetFamily::OpPopCount(const ZRangeSpec& range_spec, const OpArgs& op_args, string_view key) -> OpResult<ScoredArray> {\n+auto ZSetFamily::OpPopCount(const ZRangeSpec& range_spec, const OpArgs& op_args, string_view key)\n+    -> OpResult<ScoredArray> {\n   auto& db_slice = op_args.shard->db_slice();\n   OpResult<PrimeIterator> res_it = db_slice.Find(op_args.db_cntx, key, OBJ_ZSET);\n   if (!res_it)\n@@ -2020,6 +2030,7 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n             << CI{\"ZREMRANGEBYSCORE\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByScore)\n             << CI{\"ZREMRANGEBYLEX\", CO::WRITE, 4, 1, 1, 1}.HFUNC(ZRemRangeByLex)\n             << CI{\"ZREVRANGE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRange)\n+            << CI{\"ZREVRANGEBYLEX\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRangeByLex)\n             << CI{\"ZREVRANGEBYSCORE\", CO::READONLY, -4, 1, 1, 1}.HFUNC(ZRevRangeByScore)\n             << CI{\"ZREVRANK\", CO::READONLY | CO::FAST, 3, 1, 1, 1}.HFUNC(ZRevRank)\n             << CI{\"ZSCAN\", CO::READONLY, -3, 1, 1, 1}.HFUNC(ZScan)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex b39ad6bfb674..56e31438d888 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -29,7 +29,7 @@ class ZSetFamily {\n \n   struct LexBound {\n     std::string_view val;\n-    enum Type {PLUS_INF, MINUS_INF, OPEN, CLOSED} type = CLOSED;\n+    enum Type { PLUS_INF, MINUS_INF, OPEN, CLOSED } type = CLOSED;\n   };\n \n   using LexInterval = std::pair<LexBound, LexBound>;\n@@ -41,6 +41,7 @@ class ZSetFamily {\n     uint32_t limit = UINT32_MAX;\n     bool with_scores = false;\n     bool reverse = false;\n+    enum IntervalType { LEX, RANK, SCORE } interval_type = RANK;\n   };\n \n   struct ZRangeSpec {\n@@ -68,6 +69,8 @@ class ZSetFamily {\n   static void ZScore(CmdArgList args, ConnectionContext* cntx);\n   static void ZMScore(CmdArgList args, ConnectionContext* cntx);\n   static void ZRangeByLex(CmdArgList args, ConnectionContext* cntx);\n+  static void ZRevRangeByLex(CmdArgList args, ConnectionContext* cntx);\n+  static void ZRangeByLexInternal(CmdArgList args, bool reverse, ConnectionContext* cntx);\n   static void ZRangeByScore(CmdArgList args, ConnectionContext* cntx);\n   static void ZRemRangeByRank(CmdArgList args, ConnectionContext* cntx);\n   static void ZRemRangeByScore(CmdArgList args, ConnectionContext* cntx);\n@@ -78,14 +81,12 @@ class ZSetFamily {\n   static void ZScan(CmdArgList args, ConnectionContext* cntx);\n   static void ZUnionStore(CmdArgList args, ConnectionContext* cntx);\n \n-  static void ZRangeByScoreInternal(std::string_view key, std::string_view min_s,\n-                                    std::string_view max_s, const RangeParams& params,\n-                                    ConnectionContext* cntx);\n+  static void ZRangeByScoreInternal(CmdArgList args, bool reverse, ConnectionContext* cntx);\n   static void OutputScoredArrayResult(const OpResult<ScoredArray>& arr, const RangeParams& params,\n                                       ConnectionContext* cntx);\n   static void ZRemRangeGeneric(std::string_view key, const ZRangeSpec& range_spec,\n                                ConnectionContext* cntx);\n-  static void ZRangeGeneric(CmdArgList args, bool reverse, ConnectionContext* cntx);\n+  static void ZRangeGeneric(CmdArgList args, RangeParams range_params, ConnectionContext* cntx);\n   static void ZRankGeneric(CmdArgList args, bool reverse, ConnectionContext* cntx);\n   static bool ParseRangeByScoreParams(CmdArgList args, RangeParams* params);\n   static void ZPopMinMax(CmdArgList args, bool reverse, ConnectionContext* cntx);\n@@ -96,7 +97,7 @@ class ZSetFamily {\n                                   std::string_view member);\n   using MScoreResponse = std::vector<std::optional<double>>;\n   static OpResult<MScoreResponse> OpMScore(const OpArgs& op_args, std::string_view key,\n-                                  ArgSlice members);\n+                                           ArgSlice members);\n   static OpResult<ScoredArray> OpPopCount(const ZRangeSpec& range_spec, const OpArgs& op_args,\n                                           std::string_view key);\n   static OpResult<ScoredArray> OpRange(const ZRangeSpec& range_spec, const OpArgs& op_args,\n@@ -112,7 +113,6 @@ class ZSetFamily {\n \n   static OpResult<unsigned> OpLexCount(const OpArgs& op_args, std::string_view key,\n                                        const LexInterval& interval);\n-\n };\n \n }  // namespace dfly\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 33b1ec125adf..b43048914048 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -78,7 +78,15 @@ TEST_F(ZSetFamilyTest, ZRangeRank) {\n   EXPECT_THAT(Run({\"zrangebyscore\", \"x\", \"0\", \"(1.1\"}), ArrLen(0));\n   EXPECT_THAT(Run({\"zrangebyscore\", \"x\", \"-inf\", \"1.1\", \"limit\", \"0\", \"10\"}), \"a\");\n \n-  auto resp = Run({\"zrevrangebyscore\", \"x\", \"+inf\", \"-inf\", \"limit\", \"0\", \"5\"});\n+  auto resp = Run({\"zrangebyscore\", \"x\", \"-inf\", \"1.1\", \"limit\", \"0\", \"10\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"a\", \"1.1\"));\n+\n+  resp = Run({\"zrangebyscore\", \"x\", \"-inf\", \"1.1\", \"WITHSCORES\", \"limit\", \"0\", \"10\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"a\", \"1.1\"));\n+\n+  resp = Run({\"zrevrangebyscore\", \"x\", \"+inf\", \"-inf\", \"limit\", \"0\", \"5\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n   ASSERT_THAT(resp.GetVec(), ElementsAre(\"b\", \"a\"));\n \n@@ -142,6 +150,69 @@ TEST_F(ZSetFamilyTest, ByLex) {\n   ASSERT_THAT(resp.GetVec(), ElementsAre(\"alpha\", \"bar\", \"cool\", \"down\", \"elephant\", \"foo\"));\n }\n \n+TEST_F(ZSetFamilyTest, ZRevRangeByLex) {\n+  Run({\n+      \"zadd\", \"key\",      \"0\", \"alpha\", \"0\", \"bar\",   \"0\", \"cool\", \"0\", \"down\",\n+      \"0\",    \"elephant\", \"0\", \"foo\",   \"0\", \"great\", \"0\", \"hill\", \"0\", \"omega\",\n+  });\n+\n+  auto resp = Run({\"zrevrangebylex\", \"key\", \"[cool\", \"-\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"cool\", \"bar\", \"alpha\"));\n+\n+  EXPECT_EQ(3, CheckedInt({\"ZLEXCOUNT\", \"key\", \"(foo\", \"+\"}));\n+  EXPECT_EQ(3, CheckedInt({\"ZREMRANGEBYLEX\", \"key\", \"(foo\", \"+\"}));\n+\n+  resp = Run({\"zrevrangebylex\", \"key\", \"+\", \"[a\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"foo\", \"elephant\", \"down\", \"cool\", \"bar\", \"alpha\"));\n+}\n+\n+TEST_F(ZSetFamilyTest, ZRange) {\n+  Run({\"zadd\", \"key\", \"0\", \"a\", \"1\", \"d\", \"1\", \"b\", \"2\", \"c\", \"4\", \"e\"});\n+\n+  auto resp = Run({\"zrange\", \"key\", \"0\", \"2\"});\n+  ASSERT_THAT(resp, ArrLen(3));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"a\", \"b\", \"d\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"1\", \"3\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(6));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"b\", \"1\", \"d\", \"1\", \"c\", \"2\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"1\", \"3\", \"WITHSCORES\", \"REV\"});\n+  ASSERT_THAT(resp, ArrLen(6));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"c\", \"2\", \"d\", \"1\", \"b\", \"1\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"(1\", \"4\", \"BYSCORE\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(4));\n+  ASSERT_THAT(resp.GetVec(), ElementsAre(\"c\", \"2\", \"e\", \"4\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"-\", \"d\", \"BYLEX\", \"BYSCORE\"});\n+  EXPECT_THAT(resp, ErrArg(\"BYSCORE and BYLEX options are not compatible\"));\n+\n+  Run({\"zremrangebyscore\", \"key\", \"0\", \"4\"});\n+\n+  Run({\n+      \"zadd\", \"key\",      \"0\", \"alpha\", \"0\", \"bar\",   \"0\", \"cool\", \"0\", \"down\",\n+      \"0\",    \"elephant\", \"0\", \"foo\",   \"0\", \"great\", \"0\", \"hill\", \"0\", \"omega\",\n+  });\n+  resp = Run({\"zrange\", \"key\", \"-\", \"[cool\", \"BYLEX\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"alpha\", \"bar\", \"cool\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"[cool\", \"-\", \"REV\", \"BYLEX\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"cool\", \"bar\", \"alpha\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"+\", \"[cool\", \"REV\", \"BYLEX\", \"LIMIT\", \"2\", \"2\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"great\", \"foo\"));\n+\n+  resp = Run({\"zrange\", \"key\", \"+\", \"[cool\", \"BYLEX\", \"LIMIT\", \"2\", \"2\", \"REV\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"great\", \"foo\"));\n+}\n+\n TEST_F(ZSetFamilyTest, ZRevRange) {\n   Run({\"zadd\", \"key\", \"-inf\", \"a\", \"1\", \"b\", \"2\", \"c\"});\n   auto resp = Run({\"zrevrangebyscore\", \"key\", \"2\", \"-inf\"});\n",
  "problem_statement": "Support for LIMIT and REV in ZRANGE\n`ZRANGE my-set +inf -inf BYSCORE REV LIMIT 0 1000`\r\n(error) ERR unsupported option REV\r\n\r\n;'(\n",
  "hints_text": "I'll be working on this",
  "created_at": "2022-11-01T22:57:04Z",
  "modified_files": [
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}