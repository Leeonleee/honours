{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1844,
  "instance_id": "dragonflydb__dragonfly-1844",
  "issue_numbers": [
    "1809"
  ],
  "base_commit": "ff079f0af104994cb6161bb31ed30ca31084021d",
  "patch": "diff --git a/src/facade/command_id.h b/src/facade/command_id.h\nindex 917ca1081f2b..1ca5627ae3fd 100644\n--- a/src/facade/command_id.h\n+++ b/src/facade/command_id.h\n@@ -64,6 +64,22 @@ class CommandId {\n     return acl_categories_;\n   }\n \n+  void SetFamily(size_t fam) {\n+    family_ = fam;\n+  }\n+\n+  void SetBitIndex(uint64_t bit) {\n+    bit_index_ = bit;\n+  }\n+\n+  size_t GetFamily() const {\n+    return family_;\n+  }\n+\n+  uint64_t GetBitIndex() const {\n+    return bit_index_;\n+  }\n+\n   static uint32_t OptCount(uint32_t mask);\n \n  protected:\n@@ -74,7 +90,11 @@ class CommandId {\n   int8_t first_key_;\n   int8_t last_key_;\n   int8_t step_key_;\n+  // Acl categories\n   uint32_t acl_categories_;\n+  // Acl commands indices\n+  size_t family_;\n+  uint64_t bit_index_;\n };\n \n }  // namespace facade\ndiff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex e91aa8f62645..d45a7712f751 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -217,6 +217,7 @@ void Connection::DispatchOperations::operator()(const AclUpdateMessage& msg) {\n     for (size_t id = 0; id < msg.username.size(); ++id) {\n       if (msg.username[id] == ctx->authed_username) {\n         ctx->acl_categories = msg.categories[id];\n+        ctx->acl_commands = msg.commands[id];\n       }\n     }\n   }\n@@ -989,7 +990,7 @@ void Connection::SendMonitorMessageAsync(string msg) {\n }\n \n void Connection::SendAclUpdateAsync(AclUpdateMessage msg) {\n-  SendAsync({msg});\n+  SendAsync({std::move(msg)});\n }\n \n void Connection::SendAsync(MessageHandle msg) {\n@@ -1009,11 +1010,9 @@ void Connection::SendAsync(MessageHandle msg) {\n \n   auto place_in_dispatch_q = [this](MessageHandle msg) {\n     auto it = dispatch_q_.begin();\n-    for (; it < dispatch_q_.end(); ++it) {\n-      if (!std::holds_alternative<AclUpdateMessage>(it->handle)) {\n-        break;\n-      }\n-    }\n+    const auto end = dispatch_q_.end();\n+    while (it < end && std::holds_alternative<AclUpdateMessage>(it->handle))\n+      ++it;\n     dispatch_q_.insert(it, std::move(msg));\n   };\n \ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex 650b22b755c5..9498c54c5862 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -82,6 +82,7 @@ class Connection : public util::Connection {\n   struct AclUpdateMessage {\n     std::vector<std::string> username;\n     std::vector<uint32_t> categories;\n+    std::vector<std::vector<uint64_t>> commands;\n   };\n \n   struct PipelineMessage {\ndiff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt\nindex d5fc6d0848a9..bf2220a4684f 100644\n--- a/src/server/CMakeLists.txt\n+++ b/src/server/CMakeLists.txt\n@@ -41,7 +41,7 @@ add_library(dragonfly_lib channel_store.cc command_registry.cc\n             serializer_commons.cc journal/serializer.cc journal/executor.cc journal/streamer.cc\n             top_keys.cc multi_command_squasher.cc hll_family.cc cluster/cluster_config.cc\n             cluster/cluster_family.cc acl/user.cc acl/user_registry.cc acl/acl_family.cc\n-            acl/validator.cc)\n+            acl/validator.cc acl/helpers.cc)\n \n \n find_library(ZSTD_LIB NAMES libzstd.a libzstdstatic.a zstd NAMES_PER_DIR REQUIRED)\n@@ -88,4 +88,4 @@ add_dependencies(check_dfly dragonfly_test json_family_test list_family_test\n                  generic_family_test memcache_parser_test rdb_test journal_test\n                  redis_parser_test snapshot_test stream_family_test string_family_test\n                  bitops_family_test set_family_test zset_family_test hll_family_test\n-                 cluster_config_test cluster_family_test user_registry_test)\n+                 cluster_config_test cluster_family_test user_registry_test acl_family_test)\ndiff --git a/src/server/acl/acl_commands_def.h b/src/server/acl/acl_commands_def.h\nindex c34e2d7cde6b..d1042f35f96d 100644\n--- a/src/server/acl/acl_commands_def.h\n+++ b/src/server/acl/acl_commands_def.h\n@@ -5,6 +5,7 @@\n #pragma once\n \n #include \"absl/container/flat_hash_map.h\"\n+#include \"base/logging.h\"\n \n namespace dfly::acl {\n /* There are 21 ACL categories as of redis 7\n@@ -106,4 +107,29 @@ inline const std::vector<std::string> REVERSE_CATEGORY_INDEX_TABLE{\n     \"_RESERVED\", \"_RESERVED\", \"_RESERVED\", \"_RESERVED\", \"_RESERVED\",  \"_RESERVED\",   \"_RESERVED\",\n     \"_RESERVED\", \"FT_SEARCH\", \"THROTTLE\",  \"JSON\"};\n \n+using RevCommandField = std::vector<std::string>;\n+using RevCommandsIndexStore = std::vector<RevCommandField>;\n+\n+constexpr uint64_t ALL_COMMANDS = std::numeric_limits<uint64_t>::max();\n+constexpr uint64_t NONE_COMMANDS = std::numeric_limits<uint64_t>::min();\n+\n+// A variation of meyers singleton\n+// This is initialized when the constructor of Service is called.\n+// Basically, it calls this functions within the AclFamily::Register\n+// functions which has the number of all the acl families registered\n+inline size_t NumberOfFamilies(size_t number = 0) {\n+  static size_t number_of_families = number;\n+  return number_of_families;\n+}\n+\n+inline const RevCommandsIndexStore& CommandsRevIndexer(RevCommandsIndexStore store = {}) {\n+  static RevCommandsIndexStore rev_index_store = std::move(store);\n+  return rev_index_store;\n+}\n+\n+inline void BuildIndexers(std::vector<std::vector<std::string>> families) {\n+  acl::NumberOfFamilies(families.size());\n+  acl::CommandsRevIndexer(std::move(families));\n+}\n+\n }  // namespace dfly::acl\ndiff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc\nindex f1c275abd6a9..227feedece64 100644\n--- a/src/server/acl/acl_family.cc\n+++ b/src/server/acl/acl_family.cc\n@@ -12,11 +12,7 @@\n #include <utility>\n #include <variant>\n \n-#include \"absl/strings/ascii.h\"\n-#include \"absl/strings/escaping.h\"\n-#include \"absl/strings/match.h\"\n #include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/str_split.h\"\n #include \"absl/types/span.h\"\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n@@ -27,47 +23,14 @@\n #include \"io/file_util.h\"\n #include \"io/io.h\"\n #include \"server/acl/acl_commands_def.h\"\n+#include \"server/acl/helpers.h\"\n #include \"server/command_registry.h\"\n #include \"server/conn_context.h\"\n-#include \"server/server_state.h\"\n \n ABSL_FLAG(std::string, aclfile, \"\", \"Path and name to aclfile\");\n \n namespace dfly::acl {\n \n-static std::string AclToString(uint32_t acl_category) {\n-  std::string tmp;\n-\n-  if (acl_category == acl::ALL) {\n-    return \"+@ALL\";\n-  }\n-\n-  if (acl_category == acl::NONE) {\n-    return \"+@NONE\";\n-  }\n-\n-  const std::string prefix = \"+@\";\n-  const std::string postfix = \" \";\n-\n-  for (uint32_t i = 0; i < 32; i++) {\n-    uint32_t cat_bit = 1ULL << i;\n-    if (acl_category & cat_bit) {\n-      absl::StrAppend(&tmp, prefix, REVERSE_CATEGORY_INDEX_TABLE[i], postfix);\n-    }\n-  }\n-\n-  tmp.pop_back();\n-\n-  return tmp;\n-}\n-\n-static std::string PrettyPrintSha(std::string_view pass, bool all = false) {\n-  if (all) {\n-    return absl::BytesToHexString(pass);\n-  }\n-  return absl::BytesToHexString(pass.substr(0, 15)).substr(0, 15);\n-};\n-\n AclFamily::AclFamily(UserRegistry* registry) : registry_(registry) {\n }\n \n@@ -84,139 +47,29 @@ void AclFamily::List(CmdArgList args, ConnectionContext* cntx) {\n     std::string buffer = \"user \";\n     const std::string_view pass = user.Password();\n     const std::string password = pass == \"nopass\" ? \"nopass\" : PrettyPrintSha(pass);\n-    const std::string acl_cat = AclToString(user.AclCategory());\n+    const std::string acl_cat = AclCatToString(user.AclCategory());\n+    const std::string acl_commands = AclCommandToString(user.AclCommandsRef());\n+    const std::string maybe_space = acl_commands.empty() ? \"\" : \" \";\n \n     using namespace std::string_view_literals;\n \n     absl::StrAppend(&buffer, username, \" \", user.IsActive() ? \"on \"sv : \"off \"sv, password, \" \",\n-                    acl_cat);\n+                    acl_cat, maybe_space, acl_commands);\n \n     (*cntx)->SendSimpleString(buffer);\n   }\n }\n \n-namespace {\n-\n-std::optional<std::string> MaybeParsePassword(std::string_view command) {\n-  if (command == \"nopass\") {\n-    return std::string(command);\n-  }\n-  if (command[0] != '>') {\n-    return {};\n-  }\n-\n-  return std::string(command.substr(1));\n-}\n-\n-std::optional<bool> MaybeParseStatus(std::string_view command) {\n-  if (command == \"ON\") {\n-    return true;\n-  }\n-  if (command == \"OFF\") {\n-    return false;\n-  }\n-  return {};\n-}\n-\n-using OptCat = std::optional<uint32_t>;\n-\n-// bool == true if +\n-// bool == false if -\n-std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command) {\n-  if (absl::StartsWith(command, \"+@\")) {\n-    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));\n-    if (res == CATEGORY_INDEX_TABLE.end()) {\n-      return {};\n-    }\n-    return {res->second, true};\n-  }\n-\n-  if (absl::StartsWith(command, \"-@\")) {\n-    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));\n-    if (res == CATEGORY_INDEX_TABLE.end()) {\n-      return {};\n-    }\n-    return {res->second, false};\n-  }\n-\n-  return {};\n-}\n-\n-using facade::ErrorReply;\n-\n-template <typename T>\n-std::variant<User::UpdateRequest, ErrorReply> ParseAclSetUser(T args, bool hashed = false) {\n-  User::UpdateRequest req;\n-\n-  for (auto& arg : args) {\n-    if (auto pass = MaybeParsePassword(facade::ToSV(arg)); pass) {\n-      if (req.password) {\n-        return ErrorReply(\"Only one password is allowed\");\n-      }\n-      req.password = std::move(pass);\n-      req.is_hashed = hashed;\n-      continue;\n-    }\n-    if constexpr (std::is_same_v<T, CmdArgList>) {\n-      ToUpper(&arg);\n-    }\n-    const auto command = facade::ToSV(arg);\n-\n-    if (auto status = MaybeParseStatus(command); status) {\n-      if (req.is_active) {\n-        return ErrorReply(\"Multiple ON/OFF are not allowed\");\n-      }\n-      req.is_active = *status;\n-      continue;\n-    }\n-\n-    auto [cat, add] = MaybeParseAclCategory(command);\n-    if (!cat) {\n-      return ErrorReply(absl::StrCat(\"Unrecognized parameter \", command));\n-    }\n-\n-    using Sign = User::Sign;\n-    using Val = std::pair<Sign, uint32_t>;\n-    auto val = add ? Val{Sign::PLUS, *cat} : Val{Sign::MINUS, *cat};\n-    req.categories.push_back(val);\n-  }\n-\n-  return req;\n-}\n-\n-using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;\n-\n-MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n-                                             std::string_view file_contents) {\n-  // This is fine, a very large file will top at 1-2 mb. And that's for 5000+ users with 400\n-  // characters of ACL infor...\n-  std::vector<std::string_view> commands = absl::StrSplit(file_contents, \"\\n\");\n-  std::vector<std::vector<std::string_view>> materialized;\n-  materialized.reserve(commands.size());\n-  usernames->reserve(commands.size());\n-  for (auto& command : commands) {\n-    if (command.empty())\n-      continue;\n-    std::vector<std::string_view> cmds = absl::StrSplit(command, ' ');\n-    if (cmds[0] != \"ACL\" || cmds[1] != \"SETUSER\" || cmds.size() < 3) {\n-      return {};\n-    }\n-    usernames->push_back(std::string(cmds[2]));\n-    cmds.erase(cmds.begin(), cmds.begin() + 3);\n-    materialized.push_back(cmds);\n-  }\n-  return materialized;\n-}\n-\n-}  // namespace\n-\n void AclFamily::StreamUpdatesToAllProactorConnections(const std::vector<std::string>& user,\n-                                                      const std::vector<uint32_t>& update_cat) {\n-  auto update_cb = [&user, &update_cat]([[maybe_unused]] size_t id, util::Connection* conn) {\n+                                                      const std::vector<uint32_t>& update_cat,\n+                                                      const NestedVector& update_commands) {\n+  auto update_cb = [&user, &update_cat, &update_commands]([[maybe_unused]] size_t id,\n+                                                          util::Connection* conn) {\n     DCHECK(conn);\n     auto connection = static_cast<facade::Connection*>(conn);\n     DCHECK(user.size() == update_cat.size());\n-    connection->SendAclUpdateAsync(facade::Connection::AclUpdateMessage{user, update_cat});\n+    connection->SendAclUpdateAsync(\n+        facade::Connection::AclUpdateMessage{user, update_cat, update_commands});\n   };\n \n   if (main_listener_) {\n@@ -224,15 +77,18 @@ void AclFamily::StreamUpdatesToAllProactorConnections(const std::vector<std::str\n   }\n }\n \n+using facade::ErrorReply;\n+\n void AclFamily::SetUser(CmdArgList args, ConnectionContext* cntx) {\n   std::string_view username = facade::ToSV(args[0]);\n-  auto req = ParseAclSetUser(args.subspan(1));\n+  auto req = ParseAclSetUser(args.subspan(1), *cmd_registry_);\n   auto error_case = [cntx](ErrorReply&& error) { (*cntx)->SendError(error); };\n   auto update_case = [username, cntx, this](User::UpdateRequest&& req) {\n     auto user_with_lock = registry_->MaybeAddAndUpdateWithLock(username, std::move(req));\n     if (user_with_lock.exists) {\n       StreamUpdatesToAllProactorConnections({std::string(username)},\n-                                            {user_with_lock.user.AclCategory()});\n+                                            {user_with_lock.user.AclCategory()},\n+                                            {user_with_lock.user.AclCommands()});\n     }\n     cntx->SendOk();\n   };\n@@ -280,15 +136,19 @@ std::string AclFamily::RegistryToString() const {\n     const std::string_view pass = user.Password();\n     const std::string password =\n         pass == \"nopass\" ? \"nopass \" : absl::StrCat(\">\", PrettyPrintSha(pass, true), \" \");\n-    const std::string acl_cat = AclToString(user.AclCategory());\n+    const std::string acl_cat = AclCatToString(user.AclCategory());\n+    const std::string acl_commands = AclCommandToString(user.AclCommandsRef());\n+    const std::string maybe_space = acl_commands.empty() ? \"\" : \" \";\n \n     using namespace std::string_view_literals;\n \n     absl::StrAppend(&result, command, username, \" \", user.IsActive() ? \"ON \"sv : \"OFF \"sv, password,\n-                    acl_cat, \"\\n\");\n+                    acl_cat, maybe_space, acl_commands, \"\\n\");\n   }\n \n-  result.pop_back();\n+  if (!result.empty()) {\n+    result.pop_back();\n+  }\n \n   return result;\n }\n@@ -359,7 +219,7 @@ std::optional<facade::ErrorReply> AclFamily::LoadToRegistryFromFile(std::string_\n   std::vector<User::UpdateRequest> requests;\n \n   for (auto& cmds : *materialized) {\n-    auto req = ParseAclSetUser<std::vector<std::string_view>&>(cmds, true);\n+    auto req = ParseAclSetUser<std::vector<std::string_view>&>(cmds, *cmd_registry_, true);\n     if (std::holds_alternative<ErrorReply>(req)) {\n       auto error = std::move(std::get<ErrorReply>(req));\n       LOG(WARNING) << \"Error while parsing aclfile: \" << error.ToSv();\n@@ -375,22 +235,24 @@ std::optional<facade::ErrorReply> AclFamily::LoadToRegistryFromFile(std::string_\n     registry.clear();\n   }\n   std::vector<uint32_t> categories;\n+  NestedVector commands;\n   for (size_t i = 0; i < usernames.size(); ++i) {\n     auto& user = registry[usernames[i]];\n     user.Update(std::move(requests[i]));\n     categories.push_back(user.AclCategory());\n+    commands.push_back(user.AclCommands());\n   }\n \n   if (!init) {\n-    StreamUpdatesToAllProactorConnections(usernames, categories);\n+    StreamUpdatesToAllProactorConnections(usernames, categories, commands);\n   }\n \n   return {};\n }\n \n-void AclFamily::Load() {\n+bool AclFamily::Load() {\n   auto acl_file = absl::GetFlag(FLAGS_aclfile);\n-  LoadToRegistryFromFile(acl_file, true);\n+  return !LoadToRegistryFromFile(acl_file, true).has_value();\n }\n \n void AclFamily::Load(CmdArgList args, ConnectionContext* cntx) {\n@@ -410,8 +272,6 @@ void AclFamily::Load(CmdArgList args, ConnectionContext* cntx) {\n   cntx->SendOk();\n }\n \n-using CI = dfly::CommandId;\n-\n using MemberFunc = void (AclFamily::*)(CmdArgList args, ConnectionContext* cntx);\n \n inline CommandId::Handler HandlerFunc(AclFamily* acl, MemberFunc f) {\n@@ -436,6 +296,9 @@ constexpr uint32_t kLoad = acl::ADMIN | acl::SLOW | acl::DANGEROUS;\n // easy to handle that case explicitly in `DispatchCommand`.\n \n void AclFamily::Register(dfly::CommandRegistry* registry) {\n+  using CI = dfly::CommandId;\n+\n+  registry->StartFamily();\n   *registry << CI{\"ACL\", CO::NOSCRIPT | CO::LOADING, 0, 0, 0, 0, acl::kAcl}.HFUNC(Acl);\n   *registry << CI{\"ACL LIST\", CO::ADMIN | CO::NOSCRIPT | CO::LOADING, 1, 0, 0, 0, acl::kList}.HFUNC(\n       List);\n@@ -449,6 +312,8 @@ void AclFamily::Register(dfly::CommandRegistry* registry) {\n       Save);\n   *registry << CI{\"ACL LOAD\", CO::ADMIN | CO::NOSCRIPT | CO::LOADING, 1, 0, 0, 0, acl::kLoad}.HFUNC(\n       Load);\n+\n+  cmd_registry_ = registry;\n }\n \n #undef HFUNC\n@@ -458,8 +323,12 @@ void AclFamily::Init(facade::Listener* main_listener, UserRegistry* registry) {\n   registry_ = registry;\n   auto acl_file = absl::GetFlag(FLAGS_aclfile);\n   if (!acl_file.empty()) {\n-    Load();\n+    if (!Load()) {\n+      registry_->Init();\n+    }\n+    return;\n   }\n+  registry_->Init();\n }\n \n }  // namespace dfly::acl\ndiff --git a/src/server/acl/acl_family.h b/src/server/acl/acl_family.h\nindex 05281d7795d5..d5f9ae6f0a54 100644\n--- a/src/server/acl/acl_family.h\n+++ b/src/server/acl/acl_family.h\n@@ -13,13 +13,12 @@\n #include \"facade/facade_types.h\"\n #include \"helio/util/proactor_pool.h\"\n #include \"server/acl/user_registry.h\"\n+#include \"server/command_registry.h\"\n #include \"server/common.h\"\n \n namespace dfly {\n \n class ConnectionContext;\n-class CommandRegistry;\n-\n namespace acl {\n \n class AclFamily final {\n@@ -37,12 +36,14 @@ class AclFamily final {\n   void WhoAmI(CmdArgList args, ConnectionContext* cntx);\n   void Save(CmdArgList args, ConnectionContext* cntx);\n   void Load(CmdArgList args, ConnectionContext* cntx);\n-  void Load();\n+  bool Load();\n \n   // Helper function that updates all open connections and their\n   // respective ACL fields on all the available proactor threads\n+  using NestedVector = std::vector<std::vector<uint64_t>>;\n   void StreamUpdatesToAllProactorConnections(const std::vector<std::string>& user,\n-                                             const std::vector<uint32_t>& update_cat);\n+                                             const std::vector<uint32_t>& update_cat,\n+                                             const NestedVector& update_commands);\n \n   // Helper function that closes all open connection from the deleted user\n   void EvictOpenConnectionsOnAllProactors(std::string_view user);\n@@ -54,6 +55,8 @@ class AclFamily final {\n \n   facade::Listener* main_listener_{nullptr};\n   UserRegistry* registry_;\n+  CommandRegistry* cmd_registry_;\n+  util::ProactorPool* pool_;\n };\n \n }  // namespace acl\ndiff --git a/src/server/acl/helpers.cc b/src/server/acl/helpers.cc\nnew file mode 100644\nindex 000000000000..97b68d56eeac\n--- /dev/null\n+++ b/src/server/acl/helpers.cc\n@@ -0,0 +1,249 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#include \"server/acl/helpers.h\"\n+\n+#include <limits>\n+#include <vector>\n+\n+#include \"absl/strings/ascii.h\"\n+#include \"absl/strings/escaping.h\"\n+#include \"absl/strings/match.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_split.h\"\n+#include \"server/acl/acl_commands_def.h\"\n+#include \"server/common.h\"\n+\n+namespace dfly::acl {\n+\n+std::string AclCatToString(uint32_t acl_category) {\n+  std::string tmp;\n+\n+  if (acl_category == acl::ALL) {\n+    return \"+@ALL\";\n+  }\n+\n+  if (acl_category == acl::NONE) {\n+    return \"+@NONE\";\n+  }\n+\n+  const std::string prefix = \"+@\";\n+  const std::string postfix = \" \";\n+\n+  for (uint32_t i = 0; i < 32; ++i) {\n+    uint32_t cat_bit = 1ULL << i;\n+    if (acl_category & cat_bit) {\n+      absl::StrAppend(&tmp, prefix, REVERSE_CATEGORY_INDEX_TABLE[i], postfix);\n+    }\n+  }\n+\n+  tmp.pop_back();\n+\n+  return tmp;\n+}\n+\n+std::string AclCommandToString(const std::vector<uint64_t>& acl_category) {\n+  std::string result;\n+\n+  const std::string prefix = \"+\";\n+  const std::string postfix = \" \";\n+  const auto& rev_index = CommandsRevIndexer();\n+  bool all = true;\n+\n+  size_t family_id = 0;\n+  for (auto family : acl_category) {\n+    for (uint64_t i = 0; i < 64; ++i) {\n+      const uint64_t cmd_bit = 1ULL << i;\n+      if (family & cmd_bit && i < rev_index[family_id].size()) {\n+        absl::StrAppend(&result, prefix, rev_index[family_id][i], postfix);\n+        continue;\n+      }\n+      if (i < rev_index[family_id].size()) {\n+        all = false;\n+      }\n+    }\n+    ++family_id;\n+  }\n+\n+  if (!result.empty()) {\n+    result.pop_back();\n+  }\n+  return all ? \"+ALL\" : result;\n+}\n+\n+std::string PrettyPrintSha(std::string_view pass, bool all) {\n+  if (all) {\n+    return absl::BytesToHexString(pass);\n+  }\n+  return absl::BytesToHexString(pass.substr(0, 15)).substr(0, 15);\n+};\n+\n+std::optional<std::string> MaybeParsePassword(std::string_view command) {\n+  if (command == \"nopass\") {\n+    return std::string(command);\n+  }\n+  if (command[0] != '>') {\n+    return {};\n+  }\n+\n+  return std::string(command.substr(1));\n+}\n+\n+std::optional<bool> MaybeParseStatus(std::string_view command) {\n+  if (command == \"ON\") {\n+    return true;\n+  }\n+  if (command == \"OFF\") {\n+    return false;\n+  }\n+  return {};\n+}\n+\n+using OptCat = std::optional<uint32_t>;\n+\n+// bool == true if +\n+// bool == false if -\n+std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command) {\n+  if (absl::StartsWith(command, \"+@\")) {\n+    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));\n+    if (res == CATEGORY_INDEX_TABLE.end()) {\n+      return {};\n+    }\n+    return {res->second, true};\n+  }\n+\n+  if (absl::StartsWith(command, \"-@\")) {\n+    auto res = CATEGORY_INDEX_TABLE.find(command.substr(2));\n+    if (res == CATEGORY_INDEX_TABLE.end()) {\n+      return {};\n+    }\n+    return {res->second, false};\n+  }\n+\n+  return {};\n+}\n+\n+bool IsIndexAllCommandsFlag(size_t index) {\n+  return index == std::numeric_limits<size_t>::max();\n+}\n+\n+std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command,\n+                                                 const CommandRegistry& registry) {\n+  const auto all_commands = std::pair<size_t, uint64_t>{std::numeric_limits<size_t>::max(), 0};\n+  if (command == \"+ALL\") {\n+    return {all_commands, true};\n+  }\n+\n+  if (command == \"-ALL\") {\n+    return {all_commands, false};\n+  }\n+\n+  if (absl::StartsWith(command, \"+\")) {\n+    auto res = registry.Find(command.substr(1));\n+    if (!res) {\n+      return {};\n+    }\n+    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};\n+    return {cmd, true};\n+  }\n+\n+  if (absl::StartsWith(command, \"-\")) {\n+    auto res = registry.Find(command.substr(1));\n+    if (!res) {\n+      return {};\n+    }\n+    std::pair<size_t, uint64_t> cmd{res->GetFamily(), res->GetBitIndex()};\n+    return {cmd, false};\n+  }\n+\n+  return {};\n+}\n+\n+MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n+                                             std::string_view file_contents) {\n+  // This is fine, a very large file will top at 1-2 mb. And that's for 5000+ users with 400\n+  // characters of ACL infor...\n+  std::vector<std::string_view> commands = absl::StrSplit(file_contents, \"\\n\");\n+  std::vector<std::vector<std::string_view>> materialized;\n+  materialized.reserve(commands.size());\n+  usernames->reserve(commands.size());\n+  for (auto& command : commands) {\n+    if (command.empty())\n+      continue;\n+    std::vector<std::string_view> cmds = absl::StrSplit(command, ' ');\n+    if (cmds[0] != \"ACL\" || cmds[1] != \"SETUSER\" || cmds.size() < 3) {\n+      return {};\n+    }\n+    usernames->push_back(std::string(cmds[2]));\n+    cmds.erase(cmds.begin(), cmds.begin() + 3);\n+    materialized.push_back(cmds);\n+  }\n+  return materialized;\n+}\n+\n+using facade::ErrorReply;\n+\n+template <typename T>\n+std::variant<User::UpdateRequest, ErrorReply> ParseAclSetUser(T args,\n+                                                              const CommandRegistry& registry,\n+                                                              bool hashed) {\n+  User::UpdateRequest req;\n+\n+  for (auto& arg : args) {\n+    if (auto pass = MaybeParsePassword(facade::ToSV(arg)); pass) {\n+      if (req.password) {\n+        return ErrorReply(\"Only one password is allowed\");\n+      }\n+      req.password = std::move(pass);\n+      req.is_hashed = hashed;\n+      continue;\n+    }\n+    if constexpr (std::is_same_v<T, facade::CmdArgList>) {\n+      ToUpper(&arg);\n+    }\n+    const auto command = facade::ToSV(arg);\n+\n+    if (auto status = MaybeParseStatus(command); status) {\n+      if (req.is_active) {\n+        return ErrorReply(\"Multiple ON/OFF are not allowed\");\n+      }\n+      req.is_active = *status;\n+      continue;\n+    }\n+\n+    auto [cat, add] = MaybeParseAclCategory(command);\n+    if (cat) {\n+      using Sign = User::Sign;\n+      using Val = std::pair<Sign, uint32_t>;\n+      auto val = add ? Val{Sign::PLUS, *cat} : Val{Sign::MINUS, *cat};\n+      req.categories.push_back(val);\n+      continue;\n+    }\n+\n+    auto [cmd, sign] = MaybeParseAclCommand(command, registry);\n+    if (!cmd) {\n+      return ErrorReply(absl::StrCat(\"Unrecognized parameter \", command));\n+    }\n+\n+    using Sign = User::Sign;\n+    using Val = User::UpdateRequest::CommandsValueType;\n+    ;\n+    auto [index, bit] = *cmd;\n+    auto val = sign ? Val{Sign::PLUS, index, bit} : Val{Sign::MINUS, index, bit};\n+    req.commands.push_back(val);\n+  }\n+\n+  return req;\n+}\n+\n+using facade::CmdArgList;\n+\n+template std::variant<User::UpdateRequest, ErrorReply>\n+ParseAclSetUser<std::vector<std::string_view>&>(std::vector<std::string_view>&,\n+                                                const CommandRegistry& registry, bool hashed);\n+\n+template std::variant<User::UpdateRequest, ErrorReply> ParseAclSetUser<CmdArgList>(\n+    CmdArgList args, const CommandRegistry& registry, bool hashed);\n+\n+}  // namespace dfly::acl\ndiff --git a/src/server/acl/helpers.h b/src/server/acl/helpers.h\nnew file mode 100644\nindex 000000000000..bf4d6b476a67\n--- /dev/null\n+++ b/src/server/acl/helpers.h\n@@ -0,0 +1,47 @@\n+// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// See LICENSE for licensing terms.\n+//\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <variant>\n+\n+#include \"facade/facade_types.h\"\n+#include \"server/acl/user.h\"\n+#include \"server/command_registry.h\"\n+\n+namespace dfly::acl {\n+\n+std::string AclCatToString(uint32_t acl_category);\n+\n+std::string AclCommandToString(const std::vector<uint64_t>& acl_category);\n+\n+std::string PrettyPrintSha(std::string_view pass, bool all = false);\n+\n+std::optional<std::string> MaybeParsePassword(std::string_view command);\n+\n+std::optional<bool> MaybeParseStatus(std::string_view command);\n+\n+using OptCat = std::optional<uint32_t>;\n+std::pair<OptCat, bool> MaybeParseAclCategory(std::string_view command);\n+\n+bool IsIndexAllCommandsFlag(size_t index);\n+\n+using OptCommand = std::optional<std::pair<size_t, uint64_t>>;\n+std::pair<OptCommand, bool> MaybeParseAclCommand(std::string_view command,\n+                                                 const CommandRegistry& registry);\n+\n+template <typename T>\n+std::variant<User::UpdateRequest, facade::ErrorReply> ParseAclSetUser(\n+    T args, const CommandRegistry& registry, bool hashed = false);\n+\n+using MaterializedContents = std::optional<std::vector<std::vector<std::string_view>>>;\n+\n+MaterializedContents MaterializeFileContents(std::vector<std::string>* usernames,\n+                                             std::string_view file_contents);\n+\n+}  // namespace dfly::acl\ndiff --git a/src/server/acl/user.cc b/src/server/acl/user.cc\nindex aaede4662dea..e7424ef2ff0c 100644\n--- a/src/server/acl/user.cc\n+++ b/src/server/acl/user.cc\n@@ -6,7 +6,10 @@\n \n #include <openssl/sha.h>\n \n+#include <limits>\n+\n #include \"absl/strings/escaping.h\"\n+#include \"server/acl/helpers.h\"\n \n namespace dfly::acl {\n \n@@ -22,7 +25,7 @@ std::string StringSHA256(std::string_view password) {\n }  // namespace\n \n User::User() {\n-  // acl_categories_ = AclCat::ACL_CATEGORY_ADMIN;\n+  commands_ = std::vector<uint64_t>(NumberOfFamilies(), 0);\n }\n \n void User::Update(UpdateRequest&& req) {\n@@ -38,6 +41,14 @@ void User::Update(UpdateRequest&& req) {\n     UnsetAclCategories(category);\n   }\n \n+  for (auto [sign, index, bit_index] : req.commands) {\n+    if (sign == Sign::PLUS) {\n+      SetAclCommands(index, bit_index);\n+      continue;\n+    }\n+    UnsetAclCommands(index, bit_index);\n+  }\n+\n   if (req.is_active) {\n     SetIsActive(*req.is_active);\n   }\n@@ -66,22 +77,47 @@ bool User::HasPassword(std::string_view password) const {\n   return *password_hash_ == StringSHA256(password);\n }\n \n-void User::SetAclCategories(uint64_t cat) {\n+void User::SetAclCategories(uint32_t cat) {\n   acl_categories_ |= cat;\n }\n \n-void User::UnsetAclCategories(uint64_t cat) {\n+void User::UnsetAclCategories(uint32_t cat) {\n   SetAclCategories(cat);\n   acl_categories_ ^= cat;\n }\n \n+void User::SetAclCommands(size_t index, uint64_t bit_index) {\n+  if (IsIndexAllCommandsFlag(index)) {\n+    for (auto& family : commands_) {\n+      family = ALL_COMMANDS;\n+    }\n+    return;\n+  }\n+  commands_[index] |= bit_index;\n+}\n+\n+void User::UnsetAclCommands(size_t index, uint64_t bit_index) {\n+  if (IsIndexAllCommandsFlag(index)) {\n+    for (auto& family : commands_) {\n+      family = NONE_COMMANDS;\n+    }\n+    return;\n+  }\n+  SetAclCommands(index, bit_index);\n+  commands_[index] ^= bit_index;\n+}\n+\n uint32_t User::AclCategory() const {\n   return acl_categories_;\n }\n \n-// For ACL commands\n-// void SetAclCommand()\n-// void AclCommand() const;\n+std::vector<uint64_t> User::AclCommands() const {\n+  return commands_;\n+}\n+\n+const std::vector<uint64_t>& User::AclCommandsRef() const {\n+  return commands_;\n+}\n \n void User::SetIsActive(bool is_active) {\n   is_active_ = is_active;\ndiff --git a/src/server/acl/user.h b/src/server/acl/user.h\nindex be23b07106cc..4ccc0e096d67 100644\n--- a/src/server/acl/user.h\n+++ b/src/server/acl/user.h\n@@ -9,6 +9,7 @@\n #include <optional>\n #include <string>\n #include <string_view>\n+#include <tuple>\n #include <utility>\n #include <vector>\n \n@@ -27,11 +28,14 @@ class User final {\n \n     std::vector<std::pair<Sign, uint32_t>> categories;\n \n-    // DATATYPE_BITSET commands;\n-\n     std::optional<bool> is_active{};\n \n     bool is_hashed{false};\n+\n+    // If index s numberic_limits::max() then it's a +all flag\n+    using CommandsValueType = std::tuple<Sign, size_t /*index*/, uint64_t /*bit*/>;\n+    using CommandsUpdateType = std::vector<CommandsValueType>;\n+    CommandsUpdateType commands;\n   };\n \n   /* Used for default user\n@@ -51,19 +55,25 @@ class User final {\n \n   uint32_t AclCategory() const;\n \n-  // TODO\n-  // For ACL commands\n-  // void SetAclCommand()\n-  // void AclCommand() const;\n+  std::vector<uint64_t> AclCommands() const;\n+  const std::vector<uint64_t>& AclCommandsRef() const;\n \n   bool IsActive() const;\n \n   std::string_view Password() const;\n \n+  // Selector maps a command string (like HSET, SET etc) to\n+  // its respective ID within the commands vector.\n+  static size_t Selector(std::string_view);\n+\n  private:\n   // For ACL categories\n-  void SetAclCategories(uint64_t cat);\n-  void UnsetAclCategories(uint64_t cat);\n+  void SetAclCategories(uint32_t cat);\n+  void UnsetAclCategories(uint32_t cat);\n+\n+  // For ACL commands\n+  void SetAclCommands(size_t index, uint64_t bit_index);\n+  void UnsetAclCommands(size_t index, uint64_t bit_index);\n \n   // For is_active flag\n   void SetIsActive(bool is_active);\n@@ -75,6 +85,11 @@ class User final {\n   // password hashed with xx64\n   std::optional<std::string> password_hash_;\n   uint32_t acl_categories_{NONE};\n+  // Each element index in the vector corresponds to a familly of commands\n+  // Each bit in the uin64_t field at index id, corresponds to a specific\n+  // command of that family. Look on TableCommandBuilder and on Service::Register\n+  // on how this mapping is built during the startup/registration of commands\n+  std::vector<uint64_t> commands_;\n \n   // we have at least 221 commands including a bunch of subcommands\n   //  LARGE_BITFIELD_DATATYPE acl_commands_;\ndiff --git a/src/server/acl/user_registry.cc b/src/server/acl/user_registry.cc\nindex 69c649a47ac7..9288735ceafe 100644\n--- a/src/server/acl/user_registry.cc\n+++ b/src/server/acl/user_registry.cc\n@@ -4,6 +4,7 @@\n \n #include \"server/acl/user_registry.h\"\n \n+#include <limits>\n #include <mutex>\n \n #include \"core/fibers.h\"\n@@ -12,12 +13,6 @@\n \n namespace dfly::acl {\n \n-UserRegistry::UserRegistry() {\n-  std::pair<User::Sign, uint32_t> acl{User::Sign::PLUS, acl::ALL};\n-  User::UpdateRequest req{{}, {acl}, true};\n-  MaybeAddAndUpdate(\"default\", std::move(req));\n-}\n-\n void UserRegistry::MaybeAddAndUpdate(std::string_view username, User::UpdateRequest req) {\n   std::unique_lock<util::SharedMutex> lock(mu_);\n   auto& user = registry_[username];\n@@ -35,7 +30,7 @@ UserRegistry::UserCredentials UserRegistry::GetCredentials(std::string_view user\n   if (it == registry_.end()) {\n     return {};\n   }\n-  return {it->second.AclCategory()};\n+  return {it->second.AclCategory(), it->second.AclCommands()};\n }\n \n bool UserRegistry::IsUserActive(std::string_view username) const {\n@@ -81,4 +76,16 @@ UserRegistry::UserWithWriteLock UserRegistry::MaybeAddAndUpdateWithLock(std::str\n   return {std::move(lock), user, exists};\n }\n \n+void UserRegistry::Init() {\n+  // Add default user\n+  User::UpdateRequest::CommandsUpdateType tmp(NumberOfFamilies());\n+  size_t id = 0;\n+  for (auto& elem : tmp) {\n+    elem = {User::Sign::PLUS, id++, acl::ALL_COMMANDS};\n+  }\n+  std::pair<User::Sign, uint32_t> acl{User::Sign::PLUS, acl::ALL};\n+  User::UpdateRequest req{{}, {acl}, true, false, std::move(tmp)};\n+  MaybeAddAndUpdate(\"default\", std::move(req));\n+}\n+\n }  // namespace dfly::acl\ndiff --git a/src/server/acl/user_registry.h b/src/server/acl/user_registry.h\nindex 83bfb780d8b7..43169dd505b8 100644\n--- a/src/server/acl/user_registry.h\n+++ b/src/server/acl/user_registry.h\n@@ -23,11 +23,13 @@ class UserRegistry {\n   template <template <typename T> typename LockT, typename RegT> class RegistryWithLock;\n \n  public:\n-  UserRegistry();\n+  UserRegistry() = default;\n \n   UserRegistry(const UserRegistry&) = delete;\n   UserRegistry(UserRegistry&&) = delete;\n \n+  void Init();\n+\n   using RegistryType = absl::flat_hash_map<std::string, User>;\n \n   // Acquires a write lock of mu_\n@@ -43,6 +45,7 @@ class UserRegistry {\n \n   struct UserCredentials {\n     uint32_t acl_categories{0};\n+    std::vector<uint64_t> acl_commands;\n   };\n \n   // Acquires a read lock\ndiff --git a/src/server/acl/validator.cc b/src/server/acl/validator.cc\nindex 0504f9cbdbcc..aeb54ab77b9d 100644\n--- a/src/server/acl/validator.cc\n+++ b/src/server/acl/validator.cc\n@@ -4,12 +4,22 @@\n \n #include \"server/acl/validator.h\"\n \n+#include \"base/logging.h\"\n+#include \"server/acl/acl_commands_def.h\"\n+#include \"server/server_state.h\"\n+\n namespace dfly::acl {\n \n [[nodiscard]] bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx,\n                                                 const facade::CommandId& id) {\n-  auto command_credentials = id.acl_categories();\n-  return (cntx.acl_categories & command_credentials) != 0;\n+  const auto cat_credentials = id.acl_categories();\n+\n+  const size_t index = id.GetFamily();\n+  const uint64_t command_mask = id.GetBitIndex();\n+  DCHECK_LT(index, cntx.acl_commands.size());\n+\n+  return (cntx.acl_categories & cat_credentials) != 0 ||\n+         (cntx.acl_commands[index] & command_mask) != 0;\n }\n \n }  // namespace dfly::acl\ndiff --git a/src/server/bitops_family.cc b/src/server/bitops_family.cc\nindex 9529a14adf4d..bcdb492eb4c8 100644\n--- a/src/server/bitops_family.cc\n+++ b/src/server/bitops_family.cc\n@@ -841,7 +841,7 @@ constexpr uint32_t kSetBit = WRITE | BITMAP | SLOW;\n \n void BitOpsFamily::Register(CommandRegistry* registry) {\n   using CI = CommandId;\n-\n+  registry->StartFamily();\n   *registry\n       << CI{\"BITPOS\", CO::CommandOpt::READONLY, -3, 1, 1, 1, acl::kBitPos}.SetHandler(&BitPos)\n       << CI{\"BITCOUNT\", CO::READONLY, -2, 1, 1, 1, acl::kBitCount}.SetHandler(&BitCount)\ndiff --git a/src/server/cluster/cluster_family.cc b/src/server/cluster/cluster_family.cc\nindex 2d004991abac..71f789c88804 100644\n--- a/src/server/cluster/cluster_family.cc\n+++ b/src/server/cluster/cluster_family.cc\n@@ -608,6 +608,7 @@ constexpr uint32_t kReadWrite = FAST | CONNECTION;\n }  // namespace acl\n \n void ClusterFamily::Register(CommandRegistry* registry) {\n+  registry->StartFamily();\n   *registry << CI{\"CLUSTER\", CO::READONLY, -2, 0, 0, 0, acl::kCluster}.HFUNC(Cluster)\n             << CI{\"DFLYCLUSTER\",    CO::ADMIN | CO::GLOBAL_TRANS | CO::HIDDEN, -2, 0, 0, 0,\n                   acl::kDflyCluster}\ndiff --git a/src/server/command_registry.cc b/src/server/command_registry.cc\nindex 9be210d4ea29..c38e1a8588d0 100644\n--- a/src/server/command_registry.cc\n+++ b/src/server/command_registry.cc\n@@ -12,6 +12,7 @@\n #include \"base/flags.h\"\n #include \"base/logging.h\"\n #include \"facade/error.h\"\n+#include \"server/acl/acl_commands_def.h\"\n #include \"server/conn_context.h\"\n #include \"server/server_state.h\"\n \n@@ -103,11 +104,24 @@ CommandRegistry& CommandRegistry::operator<<(CommandId cmd) {\n     }\n     k = it->second;\n   }\n+\n+  family_of_commands_.back().push_back(std::string(k));\n+  cmd.SetFamily(family_of_commands_.size() - 1);\n+  cmd.SetBitIndex(1ULL << bit_index_++);\n   CHECK(cmd_map_.emplace(k, std::move(cmd)).second) << k;\n \n   return *this;\n }\n \n+void CommandRegistry::StartFamily() {\n+  family_of_commands_.push_back({});\n+  bit_index_ = 0;\n+}\n+\n+CommandRegistry::FamiliesVec CommandRegistry::GetFamilies() {\n+  return std::move(family_of_commands_);\n+}\n+\n namespace CO {\n \n const char* OptName(CO::CommandOpt fl) {\ndiff --git a/src/server/command_registry.h b/src/server/command_registry.h\nindex 71677ec04eba..c388fbf97ad0 100644\n--- a/src/server/command_registry.h\n+++ b/src/server/command_registry.h\n@@ -116,9 +116,6 @@ class CommandId : public facade::CommandId {\n };\n \n class CommandRegistry {\n-  absl::flat_hash_map<std::string_view, CommandId> cmd_map_;\n-  absl::flat_hash_map<std::string, std::string> cmd_rename_map_;\n-\n  public:\n   CommandRegistry();\n \n@@ -159,6 +156,17 @@ class CommandRegistry {\n       cb(k_v.second.name(), src);\n     }\n   }\n+\n+  using FamiliesVec = std::vector<std::vector<std::string>>;\n+  void StartFamily();\n+  FamiliesVec GetFamilies();\n+\n+ private:\n+  absl::flat_hash_map<std::string_view, CommandId> cmd_map_;\n+  absl::flat_hash_map<std::string, std::string> cmd_rename_map_;\n+\n+  FamiliesVec family_of_commands_;\n+  size_t bit_index_;\n };\n \n }  // namespace dfly\ndiff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex 45a70c39dec3..782e6f88d1ac 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -5,6 +5,7 @@\n #include \"server/conn_context.h\"\n \n #include \"base/logging.h\"\n+#include \"server/acl/acl_commands_def.h\"\n #include \"server/command_registry.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/server_family.h\"\n@@ -79,6 +80,7 @@ const CommandId* StoredCmd::Cid() const {\n ConnectionContext::ConnectionContext(const ConnectionContext* owner, Transaction* tx,\n                                      facade::CapturingReplyBuilder* crb)\n     : facade::ConnectionContext(nullptr, nullptr), transaction{tx} {\n+  acl_commands = std::vector<uint64_t>(acl::NumberOfFamilies(), acl::ALL_COMMANDS);\n   if (tx) {  // If we have a carrier transaction, this context is used for squashing\n     DCHECK(owner);\n     conn_state.db_index = owner->conn_state.db_index;\ndiff --git a/src/server/conn_context.h b/src/server/conn_context.h\nindex fb99f6c0867b..7ab3988732ce 100644\n--- a/src/server/conn_context.h\n+++ b/src/server/conn_context.h\n@@ -157,6 +157,7 @@ class ConnectionContext : public facade::ConnectionContext {\n  public:\n   ConnectionContext(::io::Sink* stream, facade::Connection* owner)\n       : facade::ConnectionContext(stream, owner) {\n+    acl_commands = std::vector<uint64_t>(acl::NumberOfFamilies(), acl::ALL_COMMANDS);\n   }\n \n   ConnectionContext(const ConnectionContext* owner, Transaction* tx,\n@@ -199,6 +200,7 @@ class ConnectionContext : public facade::ConnectionContext {\n \n   std::string authed_username{\"default\"};\n   uint32_t acl_categories{acl::ALL};\n+  std::vector<uint64_t> acl_commands;\n \n  private:\n   void EnableMonitoring(bool enable) {\ndiff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex c99c0dfe6e90..e8d9a61feb68 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -1468,7 +1468,7 @@ constexpr uint32_t kRestore = KEYSPACE | WRITE | SLOW | DANGEROUS;\n \n void GenericFamily::Register(CommandRegistry* registry) {\n   constexpr auto kSelectOpts = CO::LOADING | CO::FAST | CO::NOSCRIPT;\n-\n+  registry->StartFamily();\n   *registry\n       << CI{\"DEL\", CO::WRITE, -2, 1, -1, 1, acl::kDel}.HFUNC(Del)\n       /* Redis compatibility:\ndiff --git a/src/server/hll_family.cc b/src/server/hll_family.cc\nindex 9384697e038c..9b94e3ccf5ff 100644\n--- a/src/server/hll_family.cc\n+++ b/src/server/hll_family.cc\n@@ -294,7 +294,7 @@ constexpr uint32_t kPFMerge = WRITE | HYPERLOGLOG | SLOW;\n \n void HllFamily::Register(CommandRegistry* registry) {\n   using CI = CommandId;\n-\n+  registry->StartFamily();\n   *registry << CI{\"PFADD\", CO::WRITE, -3, 1, 1, 1, acl::kPFAdd}.SetHandler(PFAdd)\n             << CI{\"PFCOUNT\", CO::WRITE, -2, 1, -1, 1, acl::kPFCount}.SetHandler(PFCount)\n             << CI{\"PFMERGE\", CO::WRITE, -2, 1, -1, 1, acl::kPFMerge}.SetHandler(PFMerge);\ndiff --git a/src/server/hset_family.cc b/src/server/hset_family.cc\nindex 0e6055d00695..68800aca2f7f 100644\n--- a/src/server/hset_family.cc\n+++ b/src/server/hset_family.cc\n@@ -1141,6 +1141,7 @@ constexpr uint32_t kHVals = READ | HASH | SLOW;\n }  // namespace acl\n \n void HSetFamily::Register(CommandRegistry* registry) {\n+  registry->StartFamily();\n   *registry\n       << CI{\"HDEL\", CO::FAST | CO::WRITE, -3, 1, 1, 1, acl::kHDel}.HFUNC(HDel)\n       << CI{\"HLEN\", CO::FAST | CO::READONLY, 2, 1, 1, 1, acl::kHLen}.HFUNC(HLen)\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex d09b39410975..817d3175530f 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -1796,6 +1796,7 @@ void JsonFamily::Get(CmdArgList args, ConnectionContext* cntx) {\n // TODO: Add sensible defaults/categories to json commands\n \n void JsonFamily::Register(CommandRegistry* registry) {\n+  registry->StartFamily();\n   *registry << CI{\"JSON.GET\", CO::READONLY | CO::FAST, -2, 1, 1, 1, acl::JSON}.HFUNC(Get);\n   *registry << CI{\"JSON.MGET\", CO::READONLY | CO::FAST | CO::REVERSE_MAPPING, -3, 1, -2, 1,\n                   acl::JSON}\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 580a2d57aedb..1808323bd9b4 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -1326,6 +1326,7 @@ constexpr uint32_t kBLMove = READ | LIST | SLOW | BLOCKING;\n }  // namespace acl\n \n void ListFamily::Register(CommandRegistry* registry) {\n+  registry->StartFamily();\n   *registry\n       << CI{\"LPUSH\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, 1, acl::kLPush}.HFUNC(LPush)\n       << CI{\"LPUSHX\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, 1, acl::kLPushX}.HFUNC(LPushX)\ndiff --git a/src/server/main_service.cc b/src/server/main_service.cc\nindex 6e73965c68db..fcafb1ef9e73 100644\n--- a/src/server/main_service.cc\n+++ b/src/server/main_service.cc\n@@ -2139,10 +2139,10 @@ constexpr uint32_t kPubSub = SLOW;\n constexpr uint32_t kCommand = SLOW | CONNECTION;\n }  // namespace acl\n \n-void Service::RegisterCommands() {\n+void Service::Register(CommandRegistry* registry) {\n   using CI = CommandId;\n-\n-  registry_\n+  registry->StartFamily();\n+  *registry\n       << CI{\"QUIT\", CO::READONLY | CO::FAST, 1, 0, 0, 0, acl::kQuit}.HFUNC(Quit)\n       << CI{\"MULTI\", CO::NOSCRIPT | CO::FAST | CO::LOADING, 1, 0, 0, 0, acl::kMulti}.HFUNC(Multi)\n       << CI{\"WATCH\", CO::LOADING, -2, 1, -1, 1, acl::kWatch}.HFUNC(Watch)\n@@ -2168,7 +2168,10 @@ void Service::RegisterCommands() {\n       << CI{\"MONITOR\", CO::ADMIN, 1, 0, 0, 0, acl::kMonitor}.MFUNC(Monitor)\n       << CI{\"PUBSUB\", CO::LOADING | CO::FAST, -1, 0, 0, 0, acl::kPubSub}.MFUNC(Pubsub)\n       << CI{\"COMMAND\", CO::LOADING | CO::NOSCRIPT, -1, 0, 0, 0, acl::kCommand}.MFUNC(Command);\n+}\n \n+void Service::RegisterCommands() {\n+  Register(&registry_);\n   StreamFamily::Register(&registry_);\n   StringFamily::Register(&registry_);\n   GenericFamily::Register(&registry_);\n@@ -2184,14 +2187,16 @@ void Service::RegisterCommands() {\n   SearchFamily::Register(&registry_);\n #endif\n \n-  acl_family_.Register(&registry_);\n-\n   server_family_.Register(&registry_);\n   cluster_family_.Register(&registry_);\n \n+  acl_family_.Register(&registry_);\n+  acl::BuildIndexers(registry_.GetFamilies());\n+\n   // Only after all the commands are registered\n   registry_.Init(pp_.size());\n \n+  using CI = CommandId;\n   if (VLOG_IS_ON(1)) {\n     LOG(INFO) << \"Multi-key commands are: \";\n     registry_.Traverse([](std::string_view key, const CI& cid) {\n@@ -2214,6 +2219,10 @@ void Service::RegisterCommands() {\n   }\n }\n \n+void Service::TestInit() {\n+  acl_family_.Init(nullptr, &user_registry_);\n+}\n+\n void SetMaxMemoryFlag(uint64_t value) {\n   absl::SetFlag(&FLAGS_maxmemory, {value});\n }\ndiff --git a/src/server/main_service.h b/src/server/main_service.h\nindex 6de1859a32f5..8931405b680c 100644\n--- a/src/server/main_service.h\n+++ b/src/server/main_service.h\n@@ -9,6 +9,7 @@\n #include \"base/varz_value.h\"\n #include \"core/interpreter.h\"\n #include \"facade/service_interface.h\"\n+#include \"server/acl/acl_commands_def.h\"\n #include \"server/acl/acl_family.h\"\n #include \"server/acl/user_registry.h\"\n #include \"server/cluster/cluster_family.h\"\n@@ -116,6 +117,10 @@ class Service : public facade::ServiceInterface {\n     return server_family_;\n   }\n \n+  // Utility function used in unit tests\n+  // Do not use in production, only meant to be used by unit tests\n+  void TestInit();\n+\n  private:\n   static void Quit(CmdArgList args, ConnectionContext* cntx);\n   static void Multi(CmdArgList args, ConnectionContext* cntx);\n@@ -160,6 +165,7 @@ class Service : public facade::ServiceInterface {\n   void CallFromScript(ConnectionContext* cntx, Interpreter::CallArgs& args);\n \n   void RegisterCommands();\n+  void Register(CommandRegistry* registry);\n \n   base::VarzValue::Map GetVarzStats();\n \ndiff --git a/src/server/search/search_family.cc b/src/server/search/search_family.cc\nindex 66b58a4e0974..e63e32ac14cb 100644\n--- a/src/server/search/search_family.cc\n+++ b/src/server/search/search_family.cc\n@@ -520,7 +520,7 @@ void SearchFamily::FtProfile(CmdArgList args, ConnectionContext* cntx) {\n \n void SearchFamily::Register(CommandRegistry* registry) {\n   using CI = CommandId;\n-\n+  registry->StartFamily();\n   *registry << CI{\"FT.CREATE\", CO::GLOBAL_TRANS, -2, 0, 0, 0, acl::FT_SEARCH}.HFUNC(FtCreate)\n             << CI{\"FT.DROPINDEX\", CO::GLOBAL_TRANS, -2, 0, 0, 0, acl::FT_SEARCH}.HFUNC(FtDropIndex)\n             << CI{\"FT.INFO\", CO::GLOBAL_TRANS, 2, 0, 0, 0, acl::FT_SEARCH}.HFUNC(FtInfo)\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex cf13f8d5034b..0efb59b19ed8 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1013,6 +1013,7 @@ void ServerFamily::Auth(CmdArgList args, ConnectionContext* cntx) {\n       cntx->authed_username = username;\n       auto cred = registry->GetCredentials(username);\n       cntx->acl_categories = cred.acl_categories;\n+      cntx->acl_commands = cred.acl_commands;\n       return (*cntx)->SendOk();\n     }\n     return (*cntx)->SendError(absl::StrCat(\"Could not authorize user: \", username));\n@@ -1989,13 +1990,14 @@ constexpr uint32_t kReplConf = ADMIN | SLOW | DANGEROUS;\n constexpr uint32_t kRole = ADMIN | FAST | DANGEROUS;\n constexpr uint32_t kSlowLog = ADMIN | SLOW | DANGEROUS;\n constexpr uint32_t kScript = SLOW | SCRIPTING;\n+// TODO(check this)\n constexpr uint32_t kDfly = ADMIN;\n }  // namespace acl\n \n void ServerFamily::Register(CommandRegistry* registry) {\n   constexpr auto kReplicaOpts = CO::LOADING | CO::ADMIN | CO::GLOBAL_TRANS;\n   constexpr auto kMemOpts = CO::LOADING | CO::READONLY | CO::FAST | CO::NOSCRIPT;\n-\n+  registry->StartFamily();\n   *registry\n       << CI{\"AUTH\", CO::NOSCRIPT | CO::FAST | CO::LOADING, -2, 0, 0, 0, acl::kAuth}.HFUNC(Auth)\n       << CI{\"BGSAVE\", CO::ADMIN | CO::GLOBAL_TRANS, 1, 0, 0, 0, acl::kBGSave}.HFUNC(Save)\ndiff --git a/src/server/set_family.cc b/src/server/set_family.cc\nindex 342f550c5fc2..8d517c4a2874 100644\n--- a/src/server/set_family.cc\n+++ b/src/server/set_family.cc\n@@ -1580,6 +1580,7 @@ constexpr uint32_t kSScan = READ | SET | SLOW;\n }  // namespace acl\n \n void SetFamily::Register(CommandRegistry* registry) {\n+  registry->StartFamily();\n   *registry\n       << CI{\"SADD\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, 1, acl::kSAdd}.HFUNC(SAdd)\n       << CI{\"SDIFF\", CO::READONLY, -2, 1, -1, 1, acl::kSDiff}.HFUNC(SDiff)\ndiff --git a/src/server/set_family.h b/src/server/set_family.h\nindex d406982b81d9..ac2e5698bc0f 100644\n--- a/src/server/set_family.h\n+++ b/src/server/set_family.h\n@@ -7,7 +7,6 @@\n #include \"facade/op_status.h\"\n #include \"server/common.h\"\n \n-\n typedef struct intset intset;\n typedef struct redisObject robj;\n typedef struct dict dict;\ndiff --git a/src/server/stream_family.cc b/src/server/stream_family.cc\nindex 364ee793c022..ef3a747646ac 100644\n--- a/src/server/stream_family.cc\n+++ b/src/server/stream_family.cc\n@@ -2541,7 +2541,7 @@ constexpr uint32_t kXGroupHelp = READ | STREAM | SLOW;\n \n void StreamFamily::Register(CommandRegistry* registry) {\n   using CI = CommandId;\n-\n+  registry->StartFamily();\n   *registry\n       << CI{\"XADD\", CO::WRITE | CO::DENYOOM | CO::FAST, -5, 1, 1, 1, acl::kXAdd}.HFUNC(XAdd)\n       << CI{\"XCLAIM\", CO::WRITE | CO::FAST, -6, 1, 1, 1, acl::kXClaim}.HFUNC(XClaim)\ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex d3903f78d767..495592eeb5d8 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -1499,6 +1499,7 @@ constexpr uint32_t kClThrottle = THROTTLE;\n }  // namespace acl\n \n void StringFamily::Register(CommandRegistry* registry) {\n+  registry->StartFamily();\n   *registry\n       << CI{\"SET\", CO::WRITE | CO::DENYOOM | CO::NO_AUTOJOURNAL, -3, 1, 1, 1, acl::kSet}.HFUNC(Set)\n       << CI{\"SETEX\", CO::WRITE | CO::DENYOOM | CO::NO_AUTOJOURNAL, 4, 1, 1, 1, acl::kSetEx}.HFUNC(\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex e3729af89ee3..7b7b1efdc4bd 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -2574,7 +2574,7 @@ constexpr uint32_t kGeoDist = READ | GEO | SLOW;\n \n void ZSetFamily::Register(CommandRegistry* registry) {\n   constexpr uint32_t kStoreMask = CO::WRITE | CO::VARIADIC_KEYS | CO::REVERSE_MAPPING | CO::DENYOOM;\n-\n+  registry->StartFamily();\n   *registry\n       << CI{\"ZADD\", CO::FAST | CO::WRITE | CO::DENYOOM, -4, 1, 1, 1, acl::kZAdd}.HFUNC(ZAdd)\n       << CI{\"BZPOPMIN\",\n",
  "test_patch": "diff --git a/src/server/acl/acl_family_test.cc b/src/server/acl/acl_family_test.cc\nindex c13499752a07..b01d3dbff2b4 100644\n--- a/src/server/acl/acl_family_test.cc\n+++ b/src/server/acl/acl_family_test.cc\n@@ -21,6 +21,7 @@ class AclFamilyTest : public BaseFamilyTest {\n };\n \n TEST_F(AclFamilyTest, AclSetUser) {\n+  TestInitAclFam();\n   auto resp = Run({\"ACL\", \"SETUSER\"});\n   EXPECT_THAT(resp, ErrArg(\"ERR wrong number of arguments for 'acl setuser' command\"));\n \n@@ -34,11 +35,12 @@ TEST_F(AclFamilyTest, AclSetUser) {\n   EXPECT_THAT(resp, \"OK\");\n   resp = Run({\"ACL\", \"LIST\"});\n   auto vec = resp.GetVec();\n-  EXPECT_THAT(vec,\n-              UnorderedElementsAre(\"user default on nopass +@ALL\", \"user vlad off nopass +@NONE\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass +@ALL +ALL\",\n+                                        \"user vlad off nopass +@NONE\"));\n }\n \n TEST_F(AclFamilyTest, AclDelUser) {\n+  TestInitAclFam();\n   auto resp = Run({\"ACL\", \"DELUSER\"});\n   EXPECT_THAT(resp, ErrArg(\"ERR wrong number of arguments for 'acl deluser' command\"));\n \n@@ -55,10 +57,11 @@ TEST_F(AclFamilyTest, AclDelUser) {\n   EXPECT_THAT(resp, \"OK\");\n \n   resp = Run({\"ACL\", \"LIST\"});\n-  EXPECT_THAT(resp.GetString(), \"user default on nopass +@ALL\");\n+  EXPECT_THAT(resp.GetString(), \"user default on nopass +@ALL +ALL\");\n }\n \n TEST_F(AclFamilyTest, AclList) {\n+  TestInitAclFam();\n   auto resp = Run({\"ACL\", \"LIST\", \"NONSENSE\"});\n   EXPECT_THAT(resp, ErrArg(\"ERR wrong number of arguments for 'acl list' command\"));\n \n@@ -70,12 +73,13 @@ TEST_F(AclFamilyTest, AclList) {\n \n   resp = Run({\"ACL\", \"LIST\"});\n   auto vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass +@ALL\",\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass +@ALL +ALL\",\n                                         \"user kostas off d74ff0ee8da3b98 +@ADMIN\",\n                                         \"user adi off d74ff0ee8da3b98 +@FAST\"));\n }\n \n TEST_F(AclFamilyTest, AclAuth) {\n+  TestInitAclFam();\n   auto resp = Run({\"ACL\", \"SETUSER\", \"shahar\", \">mypass\"});\n   EXPECT_THAT(resp, \"OK\");\n \n@@ -94,6 +98,7 @@ TEST_F(AclFamilyTest, AclAuth) {\n }\n \n TEST_F(AclFamilyTest, AclWhoAmI) {\n+  TestInitAclFam();\n   auto resp = Run({\"ACL\", \"WHOAMI\", \"WHO\"});\n   EXPECT_THAT(resp, ErrArg(\"ERR wrong number of arguments for 'acl whoami' command\"));\n \n@@ -108,6 +113,7 @@ TEST_F(AclFamilyTest, AclWhoAmI) {\n }\n \n TEST_F(AclFamilyTest, TestAllCategories) {\n+  TestInitAclFam();\n   for (auto& cat : acl::REVERSE_CATEGORY_INDEX_TABLE) {\n     if (cat != \"_RESERVED\") {\n       auto resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"+@\", cat)});\n@@ -115,7 +121,7 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass +@ALL\",\n+                  UnorderedElementsAre(\"user default on nopass +@ALL +ALL\",\n                                        absl::StrCat(\"user kostas off nopass \", \"+@\", cat)));\n \n       resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"-@\", cat)});\n@@ -123,7 +129,7 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass +@ALL\",\n+                  UnorderedElementsAre(\"user default on nopass +@ALL +ALL\",\n                                        absl::StrCat(\"user kostas off nopass \", \"+@NONE\")));\n \n       resp = Run({\"ACL\", \"DELUSER\", \"kostas\"});\n@@ -152,4 +158,31 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n   //  EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"user default on nopass +@ALL\", \"user kostas\n   //  off nopass +@NONE\"));\n }\n+\n+TEST_F(AclFamilyTest, TestAllCommands) {\n+  TestInitAclFam();\n+  const auto& rev_indexer = acl::CommandsRevIndexer();\n+  for (const auto& family : rev_indexer) {\n+    for (const auto& command_name : family) {\n+      auto resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"+\", command_name)});\n+      EXPECT_THAT(resp, \"OK\");\n+\n+      resp = Run({\"ACL\", \"LIST\"});\n+      EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"user default on nopass +@ALL +ALL\",\n+                                                      absl::StrCat(\"user kostas off nopass +@NONE \",\n+                                                                   \"+\", command_name)));\n+\n+      resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"-\", command_name)});\n+\n+      resp = Run({\"ACL\", \"LIST\"});\n+      EXPECT_THAT(resp.GetVec(),\n+                  UnorderedElementsAre(\"user default on nopass +@ALL +ALL\",\n+                                       absl::StrCat(\"user kostas off nopass \", \"+@NONE\")));\n+\n+      resp = Run({\"ACL\", \"DELUSER\", \"kostas\"});\n+      EXPECT_THAT(resp, \"OK\");\n+    }\n+  }\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/acl/user_registry_test.cc b/src/server/acl/user_registry_test.cc\nindex bbdfcd3fecc1..6c3fb1788f32 100644\n--- a/src/server/acl/user_registry_test.cc\n+++ b/src/server/acl/user_registry_test.cc\n@@ -23,7 +23,7 @@ TEST_F(UserRegistryTest, BasicOp) {\n   const std::string username = \"kostas\";\n   const std::string pass = \"mypass\";\n \n-  User::UpdateRequest req{pass, {}, true};\n+  User::UpdateRequest req{pass, {}, true, false, {}};\n   registry.MaybeAddAndUpdate(username, std::move(req));\n   CHECK_EQ(registry.AuthUser(username, pass), true);\n   CHECK_EQ(registry.IsUserActive(username), true);\n@@ -32,14 +32,14 @@ TEST_F(UserRegistryTest, BasicOp) {\n \n   using Sign = User::Sign;\n   std::vector<std::pair<Sign, uint32_t>> cat = {{Sign::PLUS, LIST}, {Sign::PLUS, SET}};\n-  req = User::UpdateRequest{{}, std::move(cat), {}};\n+  req = User::UpdateRequest{{}, std::move(cat), true, false, {}};\n   registry.MaybeAddAndUpdate(username, std::move(req));\n   auto acl_categories = registry.GetCredentials(username).acl_categories;\n   uint32_t expected_result = NONE | LIST | SET;\n   CHECK_EQ(acl_categories, expected_result);\n \n   cat.push_back({Sign::MINUS, LIST});\n-  req = User::UpdateRequest{{}, std::move(cat), {}};\n+  req = User::UpdateRequest{{}, std::move(cat), true, false, {}};\n   registry.MaybeAddAndUpdate(username, std::move(req));\n   acl_categories = registry.GetCredentials(username).acl_categories;\n   expected_result = NONE | SET;\ndiff --git a/src/server/test_utils.cc b/src/server/test_utils.cc\nindex efa813003a92..24daf6f7e924 100644\n--- a/src/server/test_utils.cc\n+++ b/src/server/test_utils.cc\n@@ -562,4 +562,8 @@ void BaseFamilyTest::SetTestFlag(string_view flag_name, string_view new_value) {\n   CHECK(flag->ParseFrom(new_value, &error)) << \"Error: \" << error;\n }\n \n+void BaseFamilyTest::TestInitAclFam() {\n+  service_->TestInit();\n+}\n+\n }  // namespace dfly\ndiff --git a/src/server/test_utils.h b/src/server/test_utils.h\nindex 7245b3cc3703..735c28133752 100644\n--- a/src/server/test_utils.h\n+++ b/src/server/test_utils.h\n@@ -127,6 +127,8 @@ class BaseFamilyTest : public ::testing::Test {\n \n   static void SetTestFlag(std::string_view flag_name, std::string_view new_value);\n \n+  void TestInitAclFam();\n+\n   std::unique_ptr<util::ProactorPool> pp_;\n   std::unique_ptr<Service> service_;\n   unsigned num_threads_ = 3;\ndiff --git a/tests/dragonfly/acl_family_test.py b/tests/dragonfly/acl_family_test.py\nindex 797de4836220..f237692cad91 100644\n--- a/tests/dragonfly/acl_family_test.py\n+++ b/tests/dragonfly/acl_family_test.py\n@@ -43,6 +43,25 @@ async def test_acl_setuser(async_client):\n     result = await async_client.execute_command(\"ACL LIST\")\n     assert \"user kostas on nopass +@ALL\" in result\n \n+    # commands\n+    await async_client.execute_command(\"ACL SETUSER kostas +set +get +hset\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on nopass +@ALL +SET +GET +HSET\" in result\n+\n+    await async_client.execute_command(\"ACL SETUSER kostas -set -get +hset\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on nopass +@ALL +HSET\" in result\n+\n+    # interleaved\n+    await async_client.execute_command(\"ACL SETUSER kostas -hset +get -get -@all\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on nopass +@NONE\" in result\n+\n+    # interleaved with categories\n+    await async_client.execute_command(\"ACL SETUSER kostas +@string +get -get +set\")\n+    result = await async_client.execute_command(\"ACL LIST\")\n+    assert \"user kostas on nopass +@STRING +SET\" in result\n+\n \n @pytest.mark.asyncio\n async def test_acl_categories(async_client):\n@@ -94,11 +113,26 @@ async def test_acl_categories(async_client):\n \n \n @pytest.mark.asyncio\n-async def test_acl_categories_multi_exec_squash(df_local_factory):\n+async def test_acl_commands(async_client):\n+    await async_client.execute_command(\"ACL SETUSER random ON >mypass +@NONE +set +get\")\n+\n+    result = await async_client.execute_command(\"AUTH random mypass\")\n+    assert result == \"OK\"\n+\n+    result = await async_client.execute_command(\"SET foo bar\")\n+    assert result == \"OK\"\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await async_client.execute_command(\"ZADD myset 1 two\")\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_cat_commands_multi_exec_squash(df_local_factory):\n     df = df_local_factory.create(multi_exec_squash=True, port=1111)\n \n     df.start()\n \n+    # Testing acl categories\n     client = aioredis.Redis(port=df.port)\n     res = await client.execute_command(\"ACL SETUSER kk ON >kk +@transaction +@string\")\n     assert res == b\"OK\"\n@@ -155,6 +189,34 @@ async def test_acl_categories_multi_exec_squash(df_local_factory):\n     await admin_client.close()\n     await client.close()\n \n+    # Testing acl commands\n+    client = aioredis.Redis(port=df.port)\n+    res = await client.execute_command(\"ACL SETUSER myuser ON >kk +@transaction +set\")\n+    assert res == b\"OK\"\n+\n+    res = await client.execute_command(\"AUTH myuser kk\")\n+    assert res == b\"OK\"\n+\n+    await client.execute_command(\"MULTI\")\n+    assert res == b\"OK\"\n+    for x in range(33):\n+        await client.execute_command(f\"SET x{x} {x}\")\n+    await client.execute_command(\"EXEC\")\n+\n+    # NOPERM between multi and exec\n+    admin_client = aioredis.Redis(port=df.port)\n+    res = await admin_client.execute_command(\"ACL SETUSER myuser -set\")\n+    assert res == b\"OK\"\n+\n+    # NOPERM while executing multi\n+    await client.execute_command(\"MULTI\")\n+\n+    with pytest.raises(redis.exceptions.ResponseError):\n+        await client.execute_command(f\"SET x{x} {x}\")\n+\n+    await admin_client.close()\n+    await client.close()\n+\n \n @pytest.mark.asyncio\n async def test_acl_deluser(df_server):\n@@ -264,15 +326,14 @@ async def test_good_acl_file(df_local_factory, tmp_dir):\n     df.start()\n     client = aioredis.Redis(port=df.port)\n \n-    await client.execute_command(\"ACL SETUSER roy ON >mypass +@STRING\")\n+    await client.execute_command(\"ACL SETUSER roy ON >mypass +@STRING +HSET\")\n     await client.execute_command(\"ACL SETUSER shahar >mypass +@SET\")\n     await client.execute_command(\"ACL SETUSER vlad +@STRING\")\n \n     result = await client.execute_command(\"ACL LIST\")\n-    assert 4 == len(result)\n-    assert \"user roy on ea71c25a7a60224 +@STRING\" in result\n+    assert 3 == len(result)\n+    assert \"user roy on ea71c25a7a60224 +@STRING +HSET\" in result\n     assert \"user shahar off ea71c25a7a60224 +@SET\" in result\n-    assert \"user default on nopass +@ALL\" in result\n     assert \"user vlad off nopass +@STRING\" in result\n \n     result = await client.execute_command(\"ACL DELUSER shahar\")\n@@ -281,12 +342,10 @@ async def test_good_acl_file(df_local_factory, tmp_dir):\n     result = await client.execute_command(\"ACL SAVE\")\n \n     result = await client.execute_command(\"ACL LOAD\")\n-    #    assert result == b\"OK\"\n \n     result = await client.execute_command(\"ACL LIST\")\n-    assert 3 == len(result)\n-    assert \"user roy on ea71c25a7a60224 +@STRING\" in result\n-    assert \"user default on nopass +@ALL\" in result\n+    assert 2 == len(result)\n+    assert \"user roy on ea71c25a7a60224 +@STRING +HSET\" in result\n     assert \"user vlad off nopass +@STRING\" in result\n \n     await client.close()\n",
  "problem_statement": "Add filtering by commands\nExtend the already existing functionality with all the family of commands.\n\nExample:\n\nACL SETUSER kostas +set -hset\n",
  "hints_text": "",
  "created_at": "2023-09-11T16:20:32Z",
  "modified_files": [
    "src/facade/command_id.h",
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/server/CMakeLists.txt",
    "src/server/acl/acl_commands_def.h",
    "src/server/acl/acl_family.cc",
    "src/server/acl/acl_family.h",
    "b/src/server/acl/helpers.cc",
    "b/src/server/acl/helpers.h",
    "src/server/acl/user.cc",
    "src/server/acl/user.h",
    "src/server/acl/user_registry.cc",
    "src/server/acl/user_registry.h",
    "src/server/acl/validator.cc",
    "src/server/bitops_family.cc",
    "src/server/cluster/cluster_family.cc",
    "src/server/command_registry.cc",
    "src/server/command_registry.h",
    "src/server/conn_context.cc",
    "src/server/conn_context.h",
    "src/server/generic_family.cc",
    "src/server/hll_family.cc",
    "src/server/hset_family.cc",
    "src/server/json_family.cc",
    "src/server/list_family.cc",
    "src/server/main_service.cc",
    "src/server/main_service.h",
    "src/server/search/search_family.cc",
    "src/server/server_family.cc",
    "src/server/set_family.cc",
    "src/server/set_family.h",
    "src/server/stream_family.cc",
    "src/server/string_family.cc",
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/acl/acl_family_test.cc",
    "src/server/acl/user_registry_test.cc",
    "src/server/test_utils.cc",
    "src/server/test_utils.h",
    "tests/dragonfly/acl_family_test.py"
  ]
}