{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4696,
  "instance_id": "dragonflydb__dragonfly-4696",
  "issue_numbers": [
    "4668"
  ],
  "base_commit": "d8500c9686819fca2b4a47b55b242d69672e0f1f",
  "patch": "diff --git a/src/facade/acl_commands_def.h b/src/facade/acl_commands_def.h\nindex 13bbc63665c9..ea6878440dbb 100644\n--- a/src/facade/acl_commands_def.h\n+++ b/src/facade/acl_commands_def.h\n@@ -43,6 +43,7 @@ struct UserCredentials {\n   AclKeys keys;\n   AclPubSub pub_sub;\n   std::string ns;\n+  size_t db;\n };\n \n }  // namespace dfly::acl\ndiff --git a/src/facade/conn_context.h b/src/facade/conn_context.h\nindex 38133e391d47..0817a7291efa 100644\n--- a/src/facade/conn_context.h\n+++ b/src/facade/conn_context.h\n@@ -65,6 +65,8 @@ class ConnectionContext {\n   dfly::acl::AclKeys keys{{}, true};\n   // pub/sub\n   dfly::acl::AclPubSub pub_sub{{}, true};\n+  // db index, std::numeric_limits<size_t>::max for ALL db's\n+  size_t acl_db_idx = 0;\n \n  private:\n   Connection* owner_;\ndiff --git a/src/facade/dragonfly_connection.cc b/src/facade/dragonfly_connection.cc\nindex a9cde22703ec..0a1fa0f02676 100644\n--- a/src/facade/dragonfly_connection.cc\n+++ b/src/facade/dragonfly_connection.cc\n@@ -492,6 +492,7 @@ void Connection::AsyncOperations::operator()(const AclUpdateMessage& msg) {\n       self->cntx()->acl_commands = msg.commands;\n       self->cntx()->keys = msg.keys;\n       self->cntx()->pub_sub = msg.pub_sub;\n+      self->cntx()->acl_db_idx = msg.db_indx;\n     }\n   }\n }\ndiff --git a/src/facade/dragonfly_connection.h b/src/facade/dragonfly_connection.h\nindex a264722e1098..c25a45c63510 100644\n--- a/src/facade/dragonfly_connection.h\n+++ b/src/facade/dragonfly_connection.h\n@@ -116,6 +116,7 @@ class Connection : public util::Connection {\n     std::vector<uint64_t> commands;\n     dfly::acl::AclKeys keys;\n     dfly::acl::AclPubSub pub_sub;\n+    size_t db_indx;\n   };\n \n   // Migration request message, the async fiber stops to give way for thread migration.\ndiff --git a/src/server/acl/acl_family.cc b/src/server/acl/acl_family.cc\nindex 25fb4fc85173..157c2024e0cd 100644\n--- a/src/server/acl/acl_family.cc\n+++ b/src/server/acl/acl_family.cc\n@@ -1,4 +1,4 @@\n-// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n \n #include \"server/acl/acl_family.h\"\n@@ -45,6 +45,7 @@\n using namespace std;\n \n ABSL_FLAG(string, aclfile, \"\", \"Path and name to aclfile\");\n+ABSL_DECLARE_FLAG(uint32_t, dbnum);\n \n namespace dfly::acl {\n \n@@ -58,10 +59,16 @@ MaterializedContents MaterializeFileContents(vector<string>* usernames, string_v\n string AclKeysToString(const AclKeys& keys);\n \n string AclPubSubToString(const AclPubSub& pub_sub);\n+\n+void SendAclSecurityEvents(const AclLog::LogEntry& entry, facade::RedisReplyBuilder* rb);\n+\n+string AclDbToString(size_t db);\n+\n }  // namespace\n \n AclFamily::AclFamily(UserRegistry* registry, util::ProactorPool* pool)\n     : registry_(registry), pool_(pool) {\n+  dbnum_ = absl::GetFlag(FLAGS_dbnum);\n }\n \n void AclFamily::Acl(CmdArgList args, const CommandContext& cmd_cntx) {\n@@ -87,10 +94,13 @@ void AclFamily::List(CmdArgList args, const CommandContext& cmd_cntx) {\n     const string acl_cat_and_commands =\n         AclCatAndCommandToString(user.CatChanges(), user.CmdChanges());\n \n+    const string db_index = AclDbToString(user.Db());\n+\n     using namespace string_view_literals;\n \n     absl::StrAppend(&buffer, username, \" \", user.IsActive() ? \"on \"sv : \"off \"sv, password,\n-                    acl_keys, maybe_space_com, acl_pub_sub, \" \", acl_cat_and_commands);\n+                    acl_keys, maybe_space_com, acl_pub_sub, \" \", acl_cat_and_commands, \" $\",\n+                    db_index);\n \n     rb->SendSimpleString(buffer);\n   }\n@@ -99,13 +109,13 @@ void AclFamily::List(CmdArgList args, const CommandContext& cmd_cntx) {\n void AclFamily::StreamUpdatesToAllProactorConnections(const std::string& user,\n                                                       const Commands& update_commands,\n                                                       const AclKeys& update_keys,\n-                                                      const AclPubSub& update_pub_sub) {\n+                                                      const AclPubSub& update_pub_sub, size_t db) {\n   auto update_cb = [&]([[maybe_unused]] size_t id, util::Connection* conn) {\n     DCHECK(conn);\n     auto connection = static_cast<facade::Connection*>(conn);\n     if (!connection->IsHttp() && connection->cntx()) {\n-      connection->SendAclUpdateAsync(\n-          facade::Connection::AclUpdateMessage{user, update_commands, update_keys, update_pub_sub});\n+      connection->SendAclUpdateAsync(facade::Connection::AclUpdateMessage{\n+          user, update_commands, update_keys, update_pub_sub, db});\n     }\n   };\n \n@@ -141,7 +151,7 @@ void AclFamily::SetUser(CmdArgList args, const CommandContext& cmd_cntx) {\n     if (exists) {\n       if (!reset_channels) {\n         StreamUpdatesToAllProactorConnections(string(username), user.AclCommands(), user.Keys(),\n-                                              user.PubSub());\n+                                              user.PubSub(), user.Db());\n       }\n       // We evict connections that had their channels reseted\n       else {\n@@ -230,10 +240,13 @@ string AclFamily::RegistryToString() const {\n     const string acl_cat_and_commands =\n         AclCatAndCommandToString(user.CatChanges(), user.CmdChanges());\n \n+    const string db_index = AclDbToString(user.Db());\n+\n     using namespace string_view_literals;\n \n     absl::StrAppend(&result, command, username, \" \", user.IsActive() ? \"ON \"sv : \"OFF \"sv, password,\n-                    acl_keys, maybe_space, acl_pub_sub, \" \", acl_cat_and_commands, \"\\n\");\n+                    acl_keys, maybe_space, acl_pub_sub, \" \", acl_cat_and_commands, \" $\", db_index,\n+                    \"\\n\");\n   }\n \n   return result;\n@@ -399,40 +412,6 @@ void AclFamily::Log(CmdArgList args, const CommandContext& cmd_cntx) {\n     return;\n   }\n \n-  rb->StartArray(total_entries);\n-  auto print_element = [rb](const auto& entry) {\n-    rb->StartArray(12);\n-    rb->SendSimpleString(\"reason\");\n-    using Reason = AclLog::Reason;\n-    std::string reason;\n-    if (entry.reason == Reason::COMMAND) {\n-      reason = \"COMMAND\";\n-    } else if (entry.reason == Reason::KEY) {\n-      reason = \"KEY\";\n-    } else if (entry.reason == Reason::PUB_SUB) {\n-      reason = \"PUB_SUB\";\n-    } else {\n-      reason = \"AUTH\";\n-    }\n-\n-    rb->SendSimpleString(reason);\n-    rb->SendSimpleString(\"object\");\n-    rb->SendSimpleString(entry.object);\n-    rb->SendSimpleString(\"username\");\n-    rb->SendSimpleString(entry.username);\n-    rb->SendSimpleString(\"age-seconds\");\n-\n-    auto now_diff = std::chrono::system_clock::now() - entry.entry_creation;\n-    auto secs = std::chrono::duration_cast<std::chrono::seconds>(now_diff);\n-    auto left_over = now_diff - std::chrono::duration_cast<std::chrono::microseconds>(secs);\n-    auto age = absl::StrCat(secs.count(), \".\", left_over.count());\n-    rb->SendSimpleString(absl::StrCat(age));\n-    rb->SendSimpleString(\"client-info\");\n-    rb->SendSimpleString(entry.client_info);\n-    rb->SendSimpleString(\"timestamp-created\");\n-    rb->SendLong(entry.entry_creation.time_since_epoch().count());\n-  };\n-\n   auto n_way_minimum = [](const auto& logs) {\n     size_t id = 0;\n     AclLog::LogEntry limit;\n@@ -447,9 +426,11 @@ void AclFamily::Log(CmdArgList args, const CommandContext& cmd_cntx) {\n     return id;\n   };\n \n+  rb->StartArray(total_entries);\n+\n   for (size_t i = 0; i < total_entries; ++i) {\n-    auto min = n_way_minimum(logs);\n-    print_element(logs[min].front());\n+    const auto min = n_way_minimum(logs);\n+    SendAclSecurityEvents(logs[min].front(), rb);\n     logs[min].pop_front();\n   }\n }\n@@ -617,8 +598,14 @@ void AclFamily::DryRun(CmdArgList args, const CommandContext& cmd_cntx) {\n   }\n \n   const auto& user = registry.find(username)->second;\n-  const bool is_allowed =\n-      IsUserAllowedToInvokeCommandGeneric(user.AclCommandsRef(), {{}, true}, {}, *cid).first;\n+  // Stub, used to mimic connection context for a user.\n+  ConnectionContext stub(nullptr, nullptr);\n+  stub.acl_commands = user.AclCommandsRef();\n+  // \"mock\" without an actual connection we can't know which db is active so we skip this check\n+  // for DryRun.\n+  stub.acl_db_idx = {};\n+  stub.keys = {{}, true};\n+  const auto [is_allowed, reason] = IsUserAllowedToInvokeCommandGeneric(stub, *cid, {});\n   if (is_allowed) {\n     rb->SendOk();\n     return;\n@@ -856,6 +843,23 @@ std::optional<ParsePubSubResult> MaybeParseAclPubSub(std::string_view command) {\n   return {};\n }\n \n+std::optional<size_t> MaybeParseAclDflySelect(std::string_view command, uint32_t dbnum) {\n+  if (!absl::StartsWith(command, \"$\")) {\n+    return std::nullopt;\n+  }\n+\n+  size_t res = 0;\n+  if (absl::SimpleAtoi(command.substr(1), &res) && res < dbnum) {\n+    return {res};\n+  }\n+\n+  if (absl::EqualsIgnoreCase(command.substr(1), \"ALL\")) {\n+    return {std::numeric_limits<size_t>::max()};\n+  }\n+\n+  return std::nullopt;\n+}\n+\n std::string PrettyPrintSha(std::string_view pass, bool all) {\n   if (all) {\n     return absl::BytesToHexString(pass);\n@@ -945,6 +949,43 @@ std::string AclPubSubToString(const AclPubSub& pub_sub) {\n   return result;\n }\n \n+void SendAclSecurityEvents(const AclLog::LogEntry& entry, facade::RedisReplyBuilder* rb) {\n+  rb->StartArray(12);\n+  rb->SendSimpleString(\"reason\");\n+  using Reason = AclLog::Reason;\n+  std::string reason;\n+  if (entry.reason == Reason::COMMAND) {\n+    reason = \"COMMAND\";\n+  } else if (entry.reason == Reason::KEY) {\n+    reason = \"KEY\";\n+  } else if (entry.reason == Reason::PUB_SUB) {\n+    reason = \"PUB_SUB\";\n+  } else {\n+    reason = \"AUTH\";\n+  }\n+\n+  rb->SendSimpleString(reason);\n+  rb->SendSimpleString(\"object\");\n+  rb->SendSimpleString(entry.object);\n+  rb->SendSimpleString(\"username\");\n+  rb->SendSimpleString(entry.username);\n+  rb->SendSimpleString(\"age-seconds\");\n+\n+  auto now_diff = std::chrono::system_clock::now() - entry.entry_creation;\n+  auto secs = std::chrono::duration_cast<std::chrono::seconds>(now_diff);\n+  auto left_over = now_diff - std::chrono::duration_cast<std::chrono::microseconds>(secs);\n+  auto age = absl::StrCat(secs.count(), \".\", left_over.count());\n+  rb->SendSimpleString(absl::StrCat(age));\n+  rb->SendSimpleString(\"client-info\");\n+  rb->SendSimpleString(entry.client_info);\n+  rb->SendSimpleString(\"timestamp-created\");\n+  rb->SendLong(entry.entry_creation.time_since_epoch().count());\n+}\n+\n+std::string AclDbToString(size_t db) {\n+  return std::numeric_limits<size_t>::max() == db ? \"all\" : absl::StrCat(db);\n+}\n+\n }  // namespace\n \n std::string AclFamily::AclCatAndCommandToString(const User::CategoryChanges& cat,\n@@ -1096,6 +1137,14 @@ std::variant<User::UpdateRequest, ErrorReply> AclFamily::ParseAclSetUser(\n       continue;\n     }\n \n+    if (auto res = MaybeParseAclDflySelect(facade::ToSV(arg), dbnum_); res) {\n+      if (req.select_db) {\n+        return ErrorReply(\"ERR Error, select db $ was used twice\");\n+      }\n+      req.select_db = res;\n+      continue;\n+    }\n+\n     std::string command = absl::AsciiStrToUpper(arg);\n \n     if (auto status = MaybeParseStatus(command); status) {\ndiff --git a/src/server/acl/acl_family.h b/src/server/acl/acl_family.h\nindex 70324c3e5fdc..645d0a5c755e 100644\n--- a/src/server/acl/acl_family.h\n+++ b/src/server/acl/acl_family.h\n@@ -1,4 +1,4 @@\n-// Copyright 2022, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n //\n \n@@ -59,7 +59,7 @@ class AclFamily final {\n   void StreamUpdatesToAllProactorConnections(const std::string& user,\n                                              const Commands& update_commands,\n                                              const AclKeys& update_keys,\n-                                             const AclPubSub& update_pub_sub);\n+                                             const AclPubSub& update_pub_sub, size_t db);\n \n   // Helper function that closes all open connection from the deleted user\n   void EvictOpenConnectionsOnAllProactors(const absl::flat_hash_set<std::string_view>& user);\n@@ -161,6 +161,8 @@ class AclFamily final {\n     return index;\n   }\n \n+  size_t dbnum_ = 0;\n+\n   // Only for testing interface\n  public:\n   // Helper accessors for tests. Do not use them directly.\ndiff --git a/src/server/acl/user.cc b/src/server/acl/user.cc\nindex 44cc8c478bdd..bd976dc35620 100644\n--- a/src/server/acl/user.cc\n+++ b/src/server/acl/user.cc\n@@ -84,6 +84,8 @@ void User::Update(UpdateRequest&& req, const CategoryToIdxStore& cat_to_id,\n     SetIsActive(*req.is_active);\n   }\n \n+  SetSelectDb(req.select_db);\n+\n   SetNamespace(req.ns);\n }\n \n@@ -109,6 +111,16 @@ void User::SetNamespace(const std::string& ns) {\n   namespace_ = ns;\n }\n \n+void User::SetSelectDb(std::optional<size_t> db) {\n+  if (db) {\n+    db_ = *db;\n+  }\n+}\n+\n+size_t User::Db() const {\n+  return db_;\n+}\n+\n const std::string& User::Namespace() const {\n   return namespace_;\n }\ndiff --git a/src/server/acl/user.h b/src/server/acl/user.h\nindex 134c8aeb7541..fb8daa418fc5 100644\n--- a/src/server/acl/user.h\n+++ b/src/server/acl/user.h\n@@ -74,6 +74,8 @@ class User final {\n     // TODO allow reset all\n     // bool reset_all{false};\n \n+    // DFLY specific\n+    std::optional<size_t> select_db;\n     std::string ns;\n   };\n \n@@ -123,6 +125,8 @@ class User final {\n \n   const std::string& Namespace() const;\n \n+  size_t Db() const;\n+\n   using CategoryChanges = absl::flat_hash_map<CategoryChange, ChangeMetadata>;\n   using CommandChanges = absl::flat_hash_map<CommandChange, ChangeMetadata>;\n \n@@ -160,6 +164,8 @@ class User final {\n \n   void SetNamespace(const std::string& ns);\n \n+  void SetSelectDb(std::optional<size_t> db);\n+\n   // Set NOPASS and remove all passwords\n   void SetNopass();\n \n@@ -195,6 +201,10 @@ class User final {\n   bool is_active_{false};\n \n   std::string namespace_;\n+\n+  // if db == std::numeric_limits<size_t>::max() then all db's.\n+  // Otherwise user restricted to the value of db_\n+  size_t db_{std::numeric_limits<size_t>::max()};\n };\n \n }  // namespace dfly::acl\ndiff --git a/src/server/acl/user_registry.cc b/src/server/acl/user_registry.cc\nindex 309d944f1f29..307a2f9cdc7c 100644\n--- a/src/server/acl/user_registry.cc\n+++ b/src/server/acl/user_registry.cc\n@@ -36,7 +36,8 @@ UserCredentials UserRegistry::GetCredentials(std::string_view username) const {\n     return {};\n   }\n   auto& user = it->second;\n-  return {user.AclCategory(), user.AclCommands(), user.Keys(), user.PubSub(), user.Namespace()};\n+  return {user.AclCategory(), user.AclCommands(), user.Keys(),\n+          user.PubSub(),      user.Namespace(),   user.Db()};\n }\n \n bool UserRegistry::IsUserActive(std::string_view username) const {\ndiff --git a/src/server/acl/validator.cc b/src/server/acl/validator.cc\nindex 4089ac1843db..941ca7ad5978 100644\n--- a/src/server/acl/validator.cc\n+++ b/src/server/acl/validator.cc\n@@ -1,4 +1,4 @@\n-// Copyright 2023, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n //\n \n@@ -14,11 +14,52 @@\n \n namespace dfly::acl {\n \n-inline bool Matches(std::string_view pattern, std::string_view target) {\n+namespace {\n+\n+bool Matches(std::string_view pattern, std::string_view target) {\n   GlobMatcher matcher(pattern, true);\n   return matcher.Matches(target);\n };\n \n+bool ValidateCommand(const std::vector<uint64_t>& acl_commands, const CommandId& id) {\n+  const size_t index = id.GetFamily();\n+  const uint64_t command_mask = id.GetBitIndex();\n+  DCHECK_LT(index, acl_commands.size());\n+\n+  return (acl_commands[index] & command_mask) != 0;\n+}\n+\n+[[nodiscard]] std::pair<bool, AclLog::Reason> IsPubSubCommandAuthorized(\n+    bool literal_match, const std::vector<uint64_t>& acl_commands, const AclPubSub& pub_sub,\n+    CmdArgList tail_args, const CommandId& id) {\n+  if (!ValidateCommand(acl_commands, id)) {\n+    return {false, AclLog::Reason::COMMAND};\n+  }\n+\n+  auto iterate_globs = [&](std::string_view target) {\n+    for (auto& [glob, has_asterisk] : pub_sub.globs) {\n+      if (literal_match && (glob == target)) {\n+        return true;\n+      }\n+      if (!literal_match && Matches(glob, target)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  };\n+\n+  bool allowed = true;\n+  if (!pub_sub.all_channels) {\n+    for (auto channel : tail_args) {\n+      allowed &= iterate_globs(facade::ToSV(channel));\n+    }\n+  }\n+\n+  return {allowed, AclLog::Reason::PUB_SUB};\n+}\n+\n+}  // namespace\n+\n [[nodiscard]] bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx, const CommandId& id,\n                                                 ArgSlice tail_args) {\n   if (cntx.skip_acl_validation) {\n@@ -32,7 +73,7 @@ inline bool Matches(std::string_view pattern, std::string_view target) {\n   } else if (id.IsPSub()) {\n     auth_res = IsPubSubCommandAuthorized(true, cntx.acl_commands, cntx.pub_sub, tail_args, id);\n   } else {\n-    auth_res = IsUserAllowedToInvokeCommandGeneric(cntx.acl_commands, cntx.keys, tail_args, id);\n+    auth_res = IsUserAllowedToInvokeCommandGeneric(cntx, id, tail_args);\n   }\n \n   const auto [is_authed, reason] = auth_res;\n@@ -45,17 +86,24 @@ inline bool Matches(std::string_view pattern, std::string_view target) {\n   return is_authed;\n }\n \n-static bool ValidateCommand(const std::vector<uint64_t>& acl_commands, const CommandId& id) {\n-  const size_t index = id.GetFamily();\n-  const uint64_t command_mask = id.GetBitIndex();\n-  DCHECK_LT(index, acl_commands.size());\n-\n-  return (acl_commands[index] & command_mask) != 0;\n-}\n-\n [[nodiscard]] std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(\n-    const std::vector<uint64_t>& acl_commands, const AclKeys& keys, CmdArgList tail_args,\n-    const CommandId& id) {\n+    const ConnectionContext& cntx, const CommandId& id, CmdArgList tail_args) {\n+  const size_t max = std::numeric_limits<size_t>::max();\n+  // Once we support ranges this must change\n+  const bool reject_move_command = cntx.acl_db_idx != max && id.name() == \"MOVE\";\n+  const bool reject_trans_command =\n+      cntx.acl_db_idx != max && cntx.acl_db_idx != cntx.db_index() && id.IsTransactional();\n+  if (reject_move_command || reject_trans_command) {\n+    return {false, AclLog::Reason::AUTH};\n+  }\n+  size_t res = 0;\n+  if (tail_args.size() == 1 && id.name() == \"SELECT\" && absl::SimpleAtoi(tail_args[0], &res) &&\n+      cntx.acl_db_idx != max && cntx.acl_db_idx != res) {\n+    return {false, AclLog::Reason::AUTH};\n+  }\n+\n+  const auto& acl_commands = cntx.acl_commands;\n+  const auto& keys = cntx.keys;\n   if (!ValidateCommand(acl_commands, id)) {\n     return {false, AclLog::Reason::COMMAND};\n   }\n@@ -89,33 +137,4 @@ static bool ValidateCommand(const std::vector<uint64_t>& acl_commands, const Com\n   return {keys_allowed, AclLog::Reason::KEY};\n }\n \n-[[nodiscard]] std::pair<bool, AclLog::Reason> IsPubSubCommandAuthorized(\n-    bool literal_match, const std::vector<uint64_t>& acl_commands, const AclPubSub& pub_sub,\n-    CmdArgList tail_args, const CommandId& id) {\n-  if (!ValidateCommand(acl_commands, id)) {\n-    return {false, AclLog::Reason::COMMAND};\n-  }\n-\n-  auto iterate_globs = [&](std::string_view target) {\n-    for (auto& [glob, has_asterisk] : pub_sub.globs) {\n-      if (literal_match && (glob == target)) {\n-        return true;\n-      }\n-      if (!literal_match && Matches(glob, target)) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  };\n-\n-  bool allowed = true;\n-  if (!pub_sub.all_channels) {\n-    for (auto channel : tail_args) {\n-      allowed &= iterate_globs(facade::ToSV(channel));\n-    }\n-  }\n-\n-  return {allowed, AclLog::Reason::PUB_SUB};\n-}\n-\n }  // namespace dfly::acl\ndiff --git a/src/server/acl/validator.h b/src/server/acl/validator.h\nindex 70d849f97de8..231c891cf956 100644\n--- a/src/server/acl/validator.h\n+++ b/src/server/acl/validator.h\n@@ -1,4 +1,4 @@\n-// Copyright 2023, DragonflyDB authors.  All rights reserved.\n+// Copyright 2025, DragonflyDB authors.  All rights reserved.\n // See LICENSE for licensing terms.\n //\n \n@@ -15,17 +15,10 @@ namespace dfly::acl {\n struct AclKeys;\n struct AclPubSub;\n \n-std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(\n-    const std::vector<uint64_t>& acl_commands, const AclKeys& keys, facade::CmdArgList tail_args,\n-    const CommandId& id);\n+std::pair<bool, AclLog::Reason> IsUserAllowedToInvokeCommandGeneric(const ConnectionContext& cntx,\n+                                                                    const CommandId& id,\n+                                                                    facade::CmdArgList tail_args);\n \n bool IsUserAllowedToInvokeCommand(const ConnectionContext& cntx, const CommandId& id,\n                                   facade::CmdArgList tail_args);\n-\n-std::pair<bool, AclLog::Reason> IsPubSubCommandAuthorized(bool literal_match,\n-                                                          const std::vector<uint64_t>& acl_commands,\n-                                                          const AclPubSub& pub_sub,\n-                                                          facade::CmdArgList tail_args,\n-                                                          const CommandId& id);\n-\n }  // namespace dfly::acl\ndiff --git a/src/server/conn_context.cc b/src/server/conn_context.cc\nindex 9ffa535733ca..c01bd3a009ab 100644\n--- a/src/server/conn_context.cc\n+++ b/src/server/conn_context.cc\n@@ -113,6 +113,7 @@ ConnectionContext::ConnectionContext(facade::Connection* owner, acl::UserCredent\n   } else {\n     acl_commands = std::move(cred.acl_commands);\n   }\n+  acl_db_idx = cred.db;\n }\n \n ConnectionContext::ConnectionContext(const ConnectionContext* owner, Transaction* tx)\n@@ -122,6 +123,7 @@ ConnectionContext::ConnectionContext(const ConnectionContext* owner, Transaction\n     keys = owner->keys;\n     pub_sub = owner->pub_sub;\n     skip_acl_validation = owner->skip_acl_validation;\n+    acl_db_idx = owner->acl_db_idx;\n     ns = owner->ns;\n   } else {\n     acl_commands = std::vector<uint64_t>(acl::NumberOfFamilies(), acl::NONE_COMMANDS);\ndiff --git a/src/server/generic_family.h b/src/server/generic_family.h\nindex c91eb5823dce..5876ad7ff028 100644\n--- a/src/server/generic_family.h\n+++ b/src/server/generic_family.h\n@@ -10,7 +10,6 @@\n \n ABSL_DECLARE_FLAG(uint32_t, dbnum);\n \n-\n namespace dfly {\n \n using facade::CmdArgList;\n@@ -26,8 +25,8 @@ class GenericFamily {\n   // Accessed by Service::Exec and Service::Watch as an utility.\n   static OpResult<uint32_t> OpExists(const OpArgs& op_args, const ShardArgs& keys);\n   static OpResult<uint32_t> OpDel(const OpArgs& op_args, const ShardArgs& keys, bool async);\n- private:\n \n+ private:\n   static void Del(CmdArgList args, const CommandContext& cmd_cntx);\n   static void Unlink(CmdArgList args, const CommandContext& cmd_cntx);\n   static void Ping(CmdArgList args, const CommandContext& cmd_cntx);\ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 952fa1f64b93..ca8c0754bd1e 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -1857,6 +1857,18 @@ bool ServerFamily::DoAuth(ConnectionContext* cntx, std::string_view username,\n     cntx->pub_sub = std::move(cred.pub_sub);\n     cntx->ns = &namespaces->GetOrInsert(cred.ns);\n     cntx->authenticated = true;\n+    cntx->acl_db_idx = cred.db;\n+    if (cred.db == std::numeric_limits<size_t>::max()) {\n+      cntx->conn_state.db_index = 0;\n+    } else {\n+      auto cb = [ns = cntx->ns, index = cred.db](EngineShard* shard) {\n+        auto& db_slice = ns->GetDbSlice(shard->shard_id());\n+        db_slice.ActivateDb(index);\n+        return OpStatus::OK;\n+      };\n+      shard_set->RunBriefInParallel(std::move(cb));\n+      cntx->conn_state.db_index = cred.db;\n+    }\n   }\n   return is_authorized;\n }\n",
  "test_patch": "diff --git a/src/server/acl/acl_family_test.cc b/src/server/acl/acl_family_test.cc\nindex 367cbb1ec4b2..7e06bf514242 100644\n--- a/src/server/acl/acl_family_test.cc\n+++ b/src/server/acl/acl_family_test.cc\n@@ -48,16 +48,16 @@ TEST_F(AclFamilyTest, AclSetUser) {\n   EXPECT_THAT(resp, \"OK\");\n   resp = Run({\"ACL\", \"LIST\"});\n   auto vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n-                                        \"user vlad off resetchannels -@all\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n+                                        \"user vlad off resetchannels -@all $all\"));\n \n   resp = Run({\"ACL\", \"SETUSER\", \"vlad\", \"+ACL\"});\n   EXPECT_THAT(resp, \"OK\");\n \n   resp = Run({\"ACL\", \"LIST\"});\n   vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n-                                        \"user vlad off resetchannels -@all +acl\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n+                                        \"user vlad off resetchannels -@all +acl $all\"));\n \n   resp = Run({\"ACL\", \"SETUSER\", \"vlad\", \"on\", \">pass\", \">temp\"});\n   EXPECT_THAT(resp, \"OK\");\n@@ -66,11 +66,11 @@ TEST_F(AclFamilyTest, AclSetUser) {\n   vec = resp.GetVec();\n   EXPECT_THAT(vec.size(), 2);\n   auto contains_vlad = [](const auto& vec) {\n-    const std::string default_user = \"user default on nopass ~* &* +@all\";\n+    const std::string default_user = \"user default on nopass ~* &* +@all $all\";\n     const std::string a_permutation =\n-        \"user vlad on #a6864eb339b0e1f #d74ff0ee8da3b98 resetchannels -@all +acl\";\n+        \"user vlad on #a6864eb339b0e1f #d74ff0ee8da3b98 resetchannels -@all +acl $all\";\n     const std::string b_permutation =\n-        \"user vlad on #d74ff0ee8da3b98 #a6864eb339b0e1f resetchannels -@all +acl\";\n+        \"user vlad on #d74ff0ee8da3b98 #a6864eb339b0e1f resetchannels -@all +acl $all\";\n     std::string_view other;\n     if (vec[0] == default_user) {\n       other = vec[1].GetView();\n@@ -110,8 +110,8 @@ TEST_F(AclFamilyTest, AclSetUser) {\n \n   resp = Run({\"ACL\", \"LIST\"});\n   vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n-                                        \"user vlad on resetchannels -@all +acl\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n+                                        \"user vlad on resetchannels -@all +acl $all\"));\n \n   // +@NONE should not exist anymore. It's not in the spec.\n   resp = Run({\"ACL\", \"SETUSER\", \"rand\", \"+@NONE\"});\n@@ -122,18 +122,18 @@ TEST_F(AclFamilyTest, AclSetUser) {\n \n   resp = Run({\"ACL\", \"LIST\"});\n   vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n-                                        \"user vlad on resetchannels -@all +acl\",\n-                                        \"user rand off resetchannels +@all\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n+                                        \"user vlad on resetchannels -@all +acl $all\",\n+                                        \"user rand off resetchannels +@all $all\"));\n \n   resp = Run({\"ACL\", \"SETUSER\", \"rand\", \"NOCOMMANDS\"});\n   EXPECT_THAT(resp, \"OK\");\n \n   resp = Run({\"ACL\", \"LIST\"});\n   vec = resp.GetVec();\n-  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n-                                        \"user vlad on resetchannels -@all +acl\",\n-                                        \"user rand off resetchannels -@all\"));\n+  EXPECT_THAT(vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n+                                        \"user vlad on resetchannels -@all +acl $all\",\n+                                        \"user rand off resetchannels -@all $all\"));\n }\n \n TEST_F(AclFamilyTest, AclDelUser) {\n@@ -160,7 +160,7 @@ TEST_F(AclFamilyTest, AclDelUser) {\n   EXPECT_THAT(resp, IntArg(0));\n \n   resp = Run({\"ACL\", \"LIST\"});\n-  EXPECT_THAT(resp.GetString(), \"user default on nopass ~* &* +@all\");\n+  EXPECT_THAT(resp.GetString(), \"user default on nopass ~* &* +@all $all\");\n \n   Run({\"ACL\", \"SETUSER\", \"michael\", \"ON\"});\n   Run({\"ACL\", \"SETUSER\", \"kobe\", \"ON\"});\n@@ -181,10 +181,10 @@ TEST_F(AclFamilyTest, AclList) {\n \n   resp = Run({\"ACL\", \"LIST\"});\n   auto vec = resp.GetVec();\n-  EXPECT_THAT(vec,\n-              UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n-                                   \"user kostas off #d74ff0ee8da3b98 resetchannels -@all +@admin\",\n-                                   \"user adi off #d74ff0ee8da3b98 resetchannels -@all +@fast\"));\n+  EXPECT_THAT(\n+      vec, UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n+                                \"user kostas off #d74ff0ee8da3b98 resetchannels -@all +@admin $all\",\n+                                \"user adi off #d74ff0ee8da3b98 resetchannels -@all +@fast $all\"));\n }\n \n TEST_F(AclFamilyTest, AclAuth) {\n@@ -233,18 +233,18 @@ TEST_F(AclFamilyTest, TestAllCategories) {\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n                                        absl::StrCat(\"user kostas off resetchannels -@all \", \"+@\",\n-                                                    absl::AsciiStrToLower(cat))));\n+                                                    absl::AsciiStrToLower(cat), \" $all\")));\n \n       resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"-@\", cat)});\n       EXPECT_THAT(resp, \"OK\");\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n                                        absl::StrCat(\"user kostas off resetchannels -@all \", \"-@\",\n-                                                    absl::AsciiStrToLower(cat))));\n+                                                    absl::AsciiStrToLower(cat), \" $all\")));\n \n       resp = Run({\"ACL\", \"DELUSER\", \"kostas\"});\n       EXPECT_THAT(resp, IntArg(1));\n@@ -283,17 +283,17 @@ TEST_F(AclFamilyTest, TestAllCommands) {\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n                                        absl::StrCat(\"user kostas off resetchannels -@all \", \"+\",\n-                                                    absl::AsciiStrToLower(command_name))));\n+                                                    absl::AsciiStrToLower(command_name), \" $all\")));\n \n       resp = Run({\"ACL\", \"SETUSER\", \"kostas\", absl::StrCat(\"-\", command_name)});\n \n       resp = Run({\"ACL\", \"LIST\"});\n       EXPECT_THAT(resp.GetVec(),\n-                  UnorderedElementsAre(\"user default on nopass ~* &* +@all\",\n+                  UnorderedElementsAre(\"user default on nopass ~* &* +@all $all\",\n                                        absl::StrCat(\"user kostas off resetchannels -@all \", \"-\",\n-                                                    absl::AsciiStrToLower(command_name))));\n+                                                    absl::AsciiStrToLower(command_name), \" $all\")));\n \n       resp = Run({\"ACL\", \"DELUSER\", \"kostas\"});\n       EXPECT_THAT(resp, IntArg(1));\n@@ -537,4 +537,5 @@ TEST_F(AclFamilyTest, TestPubSub) {\n   EXPECT_THAT(vec[8], \"channels\");\n   EXPECT_THAT(vec[9], \"resetchannels &foo\");\n }\n+\n }  // namespace dfly\ndiff --git a/tests/dragonfly/acl_family_test.py b/tests/dragonfly/acl_family_test.py\nindex 393174fbe333..d885b936753b 100644\n--- a/tests/dragonfly/acl_family_test.py\n+++ b/tests/dragonfly/acl_family_test.py\n@@ -15,60 +15,64 @@ async def test_acl_setuser(async_client):\n     await async_client.execute_command(\"ACL SETUSER kostas\")\n     result = await async_client.execute_command(\"ACL LIST\")\n     assert 2 == len(result)\n-    assert \"user kostas off resetchannels -@all\" in result\n+    assert \"user kostas off resetchannels -@all $all\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas ON\")\n     result = await async_client.execute_command(\"ACL LIST\")\n-    assert \"user kostas on resetchannels -@all\" in result\n+    assert \"user kostas on resetchannels -@all $all\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas +@list +@string +@admin\")\n     result = await async_client.execute_command(\"ACL LIST\")\n     # TODO consider printing to lowercase\n-    assert \"user kostas on resetchannels -@all +@list +@string +@admin\" in result\n+    assert \"user kostas on resetchannels -@all +@list +@string +@admin $all\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas -@list -@admin\")\n     result = await async_client.execute_command(\"ACL LIST\")\n-    assert \"user kostas on resetchannels -@all +@string -@list -@admin\" in result\n+    assert \"user kostas on resetchannels -@all +@string -@list -@admin $all\" in result\n \n     # mix and match\n     await async_client.execute_command(\"ACL SETUSER kostas +@list -@string\")\n     result = await async_client.execute_command(\"ACL LIST\")\n-    assert \"user kostas on resetchannels -@all -@admin +@list -@string\" in result\n+    assert \"user kostas on resetchannels -@all -@admin +@list -@string $all\" in result\n \n     # mix and match interleaved\n     await async_client.execute_command(\"ACL SETUSER kostas +@set -@set +@set\")\n     result = await async_client.execute_command(\"ACL LIST\")\n-    assert \"user kostas on resetchannels -@all -@admin +@list -@string +@set\" in result\n+    assert \"user kostas on resetchannels -@all -@admin +@list -@string +@set $all\" in result\n \n     await async_client.execute_command(\"ACL SETUSER kostas +@all\")\n     result = await async_client.execute_command(\"ACL LIST\")\n-    assert \"user kostas on resetchannels -@admin +@list -@string +@set +@all\" in result\n+    assert \"user kostas on resetchannels -@admin +@list -@string +@set +@all $all\" in result\n \n     # commands\n     await async_client.execute_command(\"ACL SETUSER kostas +set +get +hset\")\n     result = await async_client.execute_command(\"ACL LIST\")\n     assert (\n-        \"user kostas on resetchannels -@admin +@list -@string +@set +@all +set +get +hset\" in result\n+        \"user kostas on resetchannels -@admin +@list -@string +@set +@all +set +get +hset $all\"\n+        in result\n     )\n \n     await async_client.execute_command(\"ACL SETUSER kostas -set -get +hset\")\n     result = await async_client.execute_command(\"ACL LIST\")\n     assert (\n-        \"user kostas on resetchannels -@admin +@list -@string +@set +@all -set -get +hset\" in result\n+        \"user kostas on resetchannels -@admin +@list -@string +@set +@all -set -get +hset $all\"\n+        in result\n     )\n \n     # interleaved\n     await async_client.execute_command(\"ACL SETUSER kostas -hset +get -get -@all\")\n     result = await async_client.execute_command(\"ACL LIST\")\n     assert (\n-        \"user kostas on resetchannels -@admin +@list -@string +@set -set -hset -get -@all\" in result\n+        \"user kostas on resetchannels -@admin +@list -@string +@set -set -hset -get -@all $all\"\n+        in result\n     )\n \n     # interleaved with categories\n     await async_client.execute_command(\"ACL SETUSER kostas +@string +get -get +set\")\n     result = await async_client.execute_command(\"ACL LIST\")\n     assert (\n-        \"user kostas on resetchannels -@admin +@list +@set -hset -@all +@string -get +set\" in result\n+        \"user kostas on resetchannels -@admin +@list +@set -hset -@all +@string -get +set $all\"\n+        in result\n     )\n \n \n@@ -340,28 +344,29 @@ async def test_good_acl_file(df_factory, tmp_dir):\n     result = await client.execute_command(\"ACL LIST\")\n     assert 2 == len(result)\n     assert (\n-        \"user MrFoo on #ea71c25a7a60224 #a6864eb339b0e1f resetchannels &bar &r*nd -@all\" in result\n-        or \"user MrFoo on #a6864eb339b0e1f #ea71c25a7a60224 resetchannels &bar &r*nd -@all\"\n+        \"user MrFoo on #ea71c25a7a60224 #a6864eb339b0e1f resetchannels &bar &r*nd -@all $all\"\n+        in result\n+        or \"user MrFoo on #a6864eb339b0e1f #ea71c25a7a60224 resetchannels &bar &r*nd -@all $all\"\n         in result\n     )\n-    assert \"user default on nopass ~* &* +@all\" in result\n-    await client.execute_command(\"ACL SETUSER MrFoo +@all\")\n+    assert \"user default on nopass ~* &* +@all $all\" in result\n+    await client.execute_command(\"ACL SETUSER MrFoo +@all $0\")\n     # Check multiple passwords work\n     assert \"OK\" == await client.execute_command(\"AUTH mypass\")\n     assert \"OK\" == await client.execute_command(\"AUTH temp\")\n     assert \"OK\" == await client.execute_command(\"AUTH default\")\n     await client.execute_command(\"ACL DELUSER MrFoo\")\n \n-    await client.execute_command(\"ACL SETUSER roy ON >mypass +@string +hset\")\n-    await client.execute_command(\"ACL SETUSER shahar >mypass +@set\")\n-    await client.execute_command(\"ACL SETUSER vlad ~foo ~bar* +@string\")\n+    await client.execute_command(\"ACL SETUSER roy ON >mypass +@string +hset $1\")\n+    await client.execute_command(\"ACL SETUSER shahar >mypass +@set $2\")\n+    await client.execute_command(\"ACL SETUSER vlad ~foo ~bar* +@string $3\")\n \n     result = await client.execute_command(\"ACL LIST\")\n     assert 4 == len(result)\n-    assert \"user roy on #ea71c25a7a60224 resetchannels -@all +@string +hset\" in result\n-    assert \"user shahar off #ea71c25a7a60224 resetchannels -@all +@set\" in result\n-    assert \"user vlad off ~foo ~bar* resetchannels -@all +@string\" in result\n-    assert \"user default on nopass ~* &* +@all\" in result\n+    assert \"user roy on #ea71c25a7a60224 resetchannels -@all +@string +hset $1\" in result\n+    assert \"user shahar off #ea71c25a7a60224 resetchannels -@all +@set $2\" in result\n+    assert \"user vlad off ~foo ~bar* resetchannels -@all +@string $3\" in result\n+    assert \"user default on nopass ~* &* +@all $all\" in result\n \n     result = await client.execute_command(\"ACL DELUSER shahar\")\n     assert result == 1\n@@ -372,9 +377,9 @@ async def test_good_acl_file(df_factory, tmp_dir):\n \n     result = await client.execute_command(\"ACL LIST\")\n     assert 3 == len(result)\n-    assert \"user roy on #ea71c25a7a60224 resetchannels -@all +@string +hset\" in result\n-    assert \"user vlad off ~foo ~bar* resetchannels -@all +@string\" in result\n-    assert \"user default on nopass ~* &* +@all\" in result\n+    assert \"user roy on #ea71c25a7a60224 resetchannels -@all +@string +hset $1\" in result\n+    assert \"user vlad off ~foo ~bar* resetchannels -@all +@string $3\" in result\n+    assert \"user default on nopass ~* &* +@all $all\" in result\n \n \n @pytest.mark.asyncio\n@@ -721,3 +726,21 @@ async def subscribe_worker(channel: aioredis.client.PubSub):\n     await publish_worker(publisher)\n     with pytest.raises(redis.exceptions.ConnectionError):\n         await subscribe_task\n+\n+\n+@pytest.mark.asyncio\n+async def test_acl_select(async_client):\n+    await async_client.execute_command(\"ACL SETUSER kostas on >tmp +@all $1 ~*\")\n+    assert await async_client.execute_command(\"AUTH kostas tmp\") == \"OK\"\n+\n+    res = await async_client.execute_command(\"SET foo bar\")\n+    assert res == \"OK\"\n+\n+    with pytest.raises(redis.exceptions.NoPermissionError):\n+        await async_client.execute_command(\"SELECT 0\")\n+\n+    with pytest.raises(redis.exceptions.NoPermissionError):\n+        await async_client.execute_command(\"MOVE foo 2\")\n+\n+    res = await async_client.client_list()\n+    assert res[0][\"db\"] == \"1\"\n",
  "problem_statement": "support ACL for database ids\nIntroduce a (dragonfly specific) ACL rule that restricts a user to a specific database id.\n\nso if they use a connection string  `rediss://myuser:pass@hostname/1` but `myuser` is only allowed on DB 42 then this will be rejected with auth rejected error. Similarly, `select x` will be rejected if `x ` is not allowed.\n",
  "hints_text": "",
  "created_at": "2025-03-04T14:46:26Z",
  "modified_files": [
    "src/facade/acl_commands_def.h",
    "src/facade/conn_context.h",
    "src/facade/dragonfly_connection.cc",
    "src/facade/dragonfly_connection.h",
    "src/server/acl/acl_family.cc",
    "src/server/acl/acl_family.h",
    "src/server/acl/user.cc",
    "src/server/acl/user.h",
    "src/server/acl/user_registry.cc",
    "src/server/acl/validator.cc",
    "src/server/acl/validator.h",
    "src/server/conn_context.cc",
    "src/server/generic_family.h",
    "src/server/server_family.cc"
  ],
  "modified_test_files": [
    "src/server/acl/acl_family_test.cc",
    "tests/dragonfly/acl_family_test.py"
  ]
}