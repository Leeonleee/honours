diff --git a/src/server/conn_context.cc b/src/server/conn_context.cc
index d223cd592ae3..64b1b644c836 100644
--- a/src/server/conn_context.cc
+++ b/src/server/conn_context.cc
@@ -270,7 +270,12 @@ bool ConnectionState::ClientTracking::ShouldTrackKeys() const {
     return false;
   }
 
-  return !optin_ || (seq_num_ == (1 + caching_seq_num_));
+  if (option_ == NONE) {
+    return true;
+  }
+
+  const bool match = (seq_num_ == (1 + caching_seq_num_));
+  return option_ == OPTIN ? match : !match;
 }
 
 }  // namespace dfly
diff --git a/src/server/conn_context.h b/src/server/conn_context.h
index 7d57fc2c9a63..057cdfcd2f6e 100644
--- a/src/server/conn_context.h
+++ b/src/server/conn_context.h
@@ -186,6 +186,15 @@ struct ConnectionState {
   // If seq_num == caching_seq_num + 1 then we know that we should Track().
   class ClientTracking {
    public:
+    enum Options : uint8_t {
+      NONE,   // NO subcommand, that is no OPTIN and no OUTPUT was used when CLIENT TRACKING was
+              // called. We track all keys of read commands.
+      OPTIN,  // OPTIN was used with CLIENT TRACKING. We only track keys of read commands preceded
+              // by CACHING TRUE command.
+      OPTOUT  // OPTOUT was used with CLIENT TRACKING. We track all keys of read commands except the
+              // ones preceded by a CACHING FALSE command.
+    };
+
     // Sets to true when CLIENT TRACKING is ON
     void SetClientTracking(bool is_on) {
       tracking_enabled_ = is_on;
@@ -196,9 +205,9 @@ struct ConnectionState {
       ++seq_num_;
     }
 
-    // Set if OPTIN subcommand is used in CLIENT TRACKING
-    void SetOptin(bool optin) {
-      optin_ = optin;
+    // Set if OPTIN/OPTOUT subcommand is used in CLIENT TRACKING
+    void SetOption(Options option) {
+      option_ = option;
     }
 
     // Check if the keys should be tracked. Result adheres to the state machine described above.
@@ -219,10 +228,14 @@ struct ConnectionState {
       caching_seq_num_ = 0;
     }
 
+    bool HasOption(Options option) const {
+      return option_ == option;
+    }
+
    private:
     // a flag indicating whether the client has turned on client tracking.
     bool tracking_enabled_ = false;
-    bool optin_ = false;
+    Options option_ = NONE;
     // sequence number
     size_t seq_num_ = 0;
     size_t caching_seq_num_ = 0;
diff --git a/src/server/server_family.cc b/src/server/server_family.cc
index f749f3d97a90..d3afbae5da2d 100644
--- a/src/server/server_family.cc
+++ b/src/server/server_family.cc
@@ -466,7 +466,8 @@ void ClientTracking(CmdArgList args, ConnectionContext* cntx) {
     return cntx->SendError(kSyntaxErr);
 
   bool is_on = false;
-  bool optin = false;
+  using Tracking = ConnectionState::ClientTracking;
+  Tracking::Options option = Tracking::NONE;
   if (parser.Check("ON").IgnoreCase()) {
     is_on = true;
   } else if (!parser.Check("OFF").IgnoreCase()) {
@@ -475,7 +476,9 @@ void ClientTracking(CmdArgList args, ConnectionContext* cntx) {
 
   if (parser.HasNext()) {
     if (parser.Check("OPTIN").IgnoreCase()) {
-      optin = true;
+      option = Tracking::OPTIN;
+    } else if (parser.Check("OPTOUT").IgnoreCase()) {
+      option = Tracking::OPTOUT;
     } else {
       return cntx->SendError(kSyntaxErr);
     }
@@ -485,7 +488,7 @@ void ClientTracking(CmdArgList args, ConnectionContext* cntx) {
     ++cntx->subscriptions;
   }
   cntx->conn_state.tracking_info_.SetClientTracking(is_on);
-  cntx->conn_state.tracking_info_.SetOptin(optin);
+  cntx->conn_state.tracking_info_.SetOption(option);
   return cntx->SendOk();
 }
 
@@ -499,16 +502,26 @@ void ClientCaching(CmdArgList args, ConnectionContext* cntx) {
     return cntx->SendError(kSyntaxErr);
   }
 
+  using Tracking = ConnectionState::ClientTracking;
   CmdArgParser parser{args};
   if (parser.Check("YES").IgnoreCase()) {
-    bool is_multi = cntx->transaction && cntx->transaction->IsMulti();
-    cntx->conn_state.tracking_info_.SetCachingSequenceNumber(is_multi);
+    if (!cntx->conn_state.tracking_info_.HasOption(Tracking::OPTIN)) {
+      return cntx->SendError(
+          "ERR CLIENT CACHING YES is only valid when tracking is enabled in OPTIN mode");
+    }
   } else if (parser.Check("NO").IgnoreCase()) {
+    if (!cntx->conn_state.tracking_info_.HasOption(Tracking::OPTOUT)) {
+      return cntx->SendError(
+          "ERR CLIENT CACHING NO is only valid when tracking is enabled in OPTOUT mode");
+    }
     cntx->conn_state.tracking_info_.ResetCachingSequenceNumber();
   } else {
     return cntx->SendError(kSyntaxErr);
   }
 
+  bool is_multi = cntx->transaction && cntx->transaction->IsMulti();
+  cntx->conn_state.tracking_info_.SetCachingSequenceNumber(is_multi);
+
   cntx->SendOk();
 }
 
