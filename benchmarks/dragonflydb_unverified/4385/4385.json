{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 4385,
  "instance_id": "dragonflydb__dragonfly-4385",
  "issue_numbers": [
    "3888"
  ],
  "base_commit": "b7532538fee6746511c9f61e9798e219bdfaa45d",
  "patch": "diff --git a/src/facade/reply_builder.cc b/src/facade/reply_builder.cc\nindex 9a909b902d12..d398ecbf8f98 100644\n--- a/src/facade/reply_builder.cc\n+++ b/src/facade/reply_builder.cc\n@@ -408,8 +408,7 @@ void RedisReplyBuilder::SendBulkStrArr(const facade::ArgRange& strs, CollectionT\n     SendBulkString(str);\n }\n \n-void RedisReplyBuilder::SendScoredArray(absl::Span<const std::pair<std::string, double>> arr,\n-                                        bool with_scores) {\n+void RedisReplyBuilder::SendScoredArray(ScoredArray arr, bool with_scores) {\n   ReplyScope scope(this);\n   StartArray((with_scores && !IsResp3()) ? arr.size() * 2 : arr.size());\n   for (const auto& [str, score] : arr) {\n@@ -421,6 +420,21 @@ void RedisReplyBuilder::SendScoredArray(absl::Span<const std::pair<std::string,\n   }\n }\n \n+void RedisReplyBuilder::SendLabeledScoredArray(std::string_view arr_label, ScoredArray arr) {\n+  ReplyScope scope(this);\n+  \n+  StartArray(2);\n+\n+  SendBulkString(arr_label);\n+  StartArray(arr.size());\n+  for (const auto& [str, score] : arr) {\n+    StartArray(2);\n+    SendBulkString(str);\n+    SendDouble(score);\n+  }\n+  \n+}\n+\n void RedisReplyBuilder::SendStored() {\n   SendSimpleString(\"OK\");\n }\ndiff --git a/src/facade/reply_builder.h b/src/facade/reply_builder.h\nindex 4000558c7fd0..8c2bf7ee38c6 100644\n--- a/src/facade/reply_builder.h\n+++ b/src/facade/reply_builder.h\n@@ -273,6 +273,7 @@ class RedisReplyBuilderBase : public SinkReplyBuilder {\n class RedisReplyBuilder : public RedisReplyBuilderBase {\n  public:\n   using RedisReplyBuilderBase::CollectionType;\n+  using ScoredArray = absl::Span<const std::pair<std::string, double>>;\n \n   RedisReplyBuilder(io::Sink* sink) : RedisReplyBuilderBase(sink) {\n   }\n@@ -281,8 +282,8 @@ class RedisReplyBuilder : public RedisReplyBuilderBase {\n \n   void SendSimpleStrArr(const facade::ArgRange& strs);\n   void SendBulkStrArr(const facade::ArgRange& strs, CollectionType ct = ARRAY);\n-  void SendScoredArray(absl::Span<const std::pair<std::string, double>> arr, bool with_scores);\n-\n+  void SendScoredArray(ScoredArray arr, bool with_scores);\n+  void SendLabeledScoredArray(std::string_view arr_label, ScoredArray arr);\n   void SendStored() final;\n   void SendSetSkipped() final;\n \ndiff --git a/src/server/command_registry.cc b/src/server/command_registry.cc\nindex cce5354f8ffe..0777ad7d992e 100644\n--- a/src/server/command_registry.cc\n+++ b/src/server/command_registry.cc\n@@ -283,6 +283,8 @@ const char* OptName(CO::CommandOpt fl) {\n       return \"no-key-tx-span-all\";\n     case IDEMPOTENT:\n       return \"idempotent\";\n+    case SLOW:\n+      return \"slow\";\n   }\n   return \"unknown\";\n }\ndiff --git a/src/server/command_registry.h b/src/server/command_registry.h\nindex 3acc69c355bc..76f27117bef1 100644\n--- a/src/server/command_registry.h\n+++ b/src/server/command_registry.h\n@@ -52,6 +52,7 @@ enum CommandOpt : uint32_t {\n   // The same callback can be run multiple times without corrupting the result. Used for\n   // opportunistic optimizations where inconsistencies can only be detected afterwards.\n   IDEMPOTENT = 1U << 18,\n+  SLOW = 1U << 19  // Unused?\n };\n \n const char* OptName(CommandOpt fl);\ndiff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 56b8a1777f07..fc440ad92037 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -67,10 +67,10 @@ struct GeoPoint {\n   double dist;\n   double score;\n   std::string member;\n-  GeoPoint() : longitude(0.0), latitude(0.0), dist(0.0), score(0.0){};\n+  GeoPoint() : longitude(0.0), latitude(0.0), dist(0.0), score(0.0) {};\n   GeoPoint(double _longitude, double _latitude, double _dist, double _score,\n            const std::string& _member)\n-      : longitude(_longitude), latitude(_latitude), dist(_dist), score(_score), member(_member){};\n+      : longitude(_longitude), latitude(_latitude), dist(_dist), score(_score), member(_member) {};\n };\n using GeoArray = std::vector<GeoPoint>;\n \n@@ -179,8 +179,7 @@ struct ZParams {\n   bool override = false;\n };\n \n-void OutputScoredArrayResult(const OpResult<ScoredArray>& result,\n-                             const ZSetFamily::RangeParams& params, SinkReplyBuilder* builder) {\n+void OutputScoredArrayResult(const OpResult<ScoredArray>& result, SinkReplyBuilder* builder) {\n   if (result.status() == OpStatus::WRONG_TYPE) {\n     return builder->SendError(kWrongTypeErr);\n   }\n@@ -188,7 +187,7 @@ void OutputScoredArrayResult(const OpResult<ScoredArray>& result,\n   LOG_IF(WARNING, !result && result.status() != OpStatus::KEY_NOTFOUND)\n       << \"Unexpected status \" << result.status();\n   auto* rb = static_cast<RedisReplyBuilder*>(builder);\n-  rb->SendScoredArray(result.value(), params.with_scores);\n+  rb->SendScoredArray(result.value(), true /* with scores */);\n }\n \n OpResult<DbSlice::ItAndUpdater> FindZEntry(const ZParams& zparams, const OpArgs& op_args,\n@@ -1821,31 +1820,47 @@ void ZBooleanOperation(CmdArgList args, string_view cmd, bool is_union, bool sto\n   }\n }\n \n-void ZPopMinMax(CmdArgList args, bool reverse, Transaction* tx, SinkReplyBuilder* builder) {\n-  string_view key = ArgS(args, 0);\n+enum class FilterShards { NO = 0, YES = 1 };\n \n+OpResult<ScoredArray> ZPopMinMaxInternal(std::string_view key, FilterShards should_filter_shards,\n+                                         uint32 count, bool reverse, Transaction* tx) {\n   ZSetFamily::RangeParams range_params;\n   range_params.reverse = reverse;\n   range_params.with_scores = true;\n   ZSetFamily::ZRangeSpec range_spec;\n   range_spec.params = range_params;\n \n-  ZSetFamily::TopNScored sc = 1;\n-  if (args.size() > 1) {\n-    string_view count = ArgS(args, 1);\n-    if (!SimpleAtoi(count, &sc)) {\n-      return builder->SendError(kUintErr);\n-    }\n-  }\n+  range_spec.interval = count;\n \n-  range_spec.interval = sc;\n+  OpResult<ScoredArray> result;\n \n+  std::optional<ShardId> key_shard;\n+  if (should_filter_shards == FilterShards::YES) {\n+    key_shard = Shard(key, shard_set->size());\n+  }\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpPopCount(range_spec, t->GetOpArgs(shard), key);\n+    if (!key_shard.has_value() || *key_shard == shard->shard_id()) {\n+      result = std::move(OpPopCount(range_spec, t->GetOpArgs(shard), key));\n+    }\n+    return OpStatus::OK;\n   };\n \n-  OpResult<ScoredArray> result = tx->ScheduleSingleHopT(std::move(cb));\n-  OutputScoredArrayResult(result, range_params, builder);\n+  tx->Execute(std::move(cb), true);\n+\n+  return result;\n+}\n+\n+void ZPopMinMaxFromArgs(CmdArgList args, bool reverse, Transaction* tx, SinkReplyBuilder* builder) {\n+  string_view key = ArgS(args, 0);\n+  uint32 count = 1;\n+  if (args.size() > 1) {\n+    string_view count_str = ArgS(args, 1);\n+    if (!SimpleAtoi(count_str, &count)) {\n+      return builder->SendError(kUintErr);\n+    }\n+  }\n+\n+  OutputScoredArrayResult(ZPopMinMaxInternal(key, FilterShards::NO, count, reverse, tx), builder);\n }\n \n OpResult<MScoreResponse> ZGetMembers(CmdArgList args, Transaction* tx, SinkReplyBuilder* builder) {\n@@ -2060,6 +2075,71 @@ void ZRemRangeGeneric(string_view key, const ZSetFamily::ZRangeSpec& range_spec,\n   }\n }\n \n+// Returns the key of the first non empty set found in the list of shard arguments.\n+// Returns nullopt if none.\n+std::optional<std::string_view> GetFirstNonEmptyKeyFound(EngineShard* shard, Transaction* t) {\n+  ShardArgs keys = t->GetShardArgs(shard->shard_id());\n+  DCHECK(!keys.Empty());\n+\n+  auto& db_slice = t->GetDbSlice(shard->shard_id());\n+\n+  for (string_view key : keys) {\n+    auto it = db_slice.FindReadOnly(t->GetDbContext(), key, OBJ_ZSET);\n+    if (!it) {\n+      continue;\n+    }\n+    return std::optional<std::string_view>(key);\n+  }\n+\n+  return std::nullopt;\n+}\n+\n+// Validates the ZMPop command arguments and extracts the values to the output params.\n+// If the arguments are invalid sends the appropiate error to builder and returns false.\n+bool ValidateZMPopCommand(CmdArgList args, uint32* num_keys, bool* is_max, int* pop_count,\n+                          SinkReplyBuilder* builder) {\n+  CmdArgParser parser{args};\n+\n+  if (!SimpleAtoi(parser.Next(), num_keys)) {\n+    builder->SendError(kUintErr);\n+    return false;\n+  }\n+\n+  if (*num_keys <= 0 || !parser.HasAtLeast(*num_keys + 1)) {\n+    // We should have at least num_keys keys + a MIN/MAX arg.\n+    builder->SendError(kSyntaxErr);\n+    return false;\n+  }\n+  // Skip over the keys themselves.\n+  parser.Skip(*num_keys);\n+\n+  // We know we have at least one more arg (we checked above).\n+  if (parser.Check(\"MAX\")) {\n+    *is_max = true;\n+  } else if (parser.Check(\"MIN\")) {\n+    *is_max = false;\n+  } else {\n+    builder->SendError(kSyntaxErr);\n+    return false;\n+  }\n+\n+  *pop_count = 1;\n+  // Check if we have additional COUNT argument.\n+  if (parser.HasNext()) {\n+    if (!parser.Check(\"COUNT\", pop_count)) {\n+      builder->SendError(kSyntaxErr);\n+      return false;\n+    }\n+  }\n+\n+  if (!parser.Finalize()) {\n+      builder->SendError(parser.Error()->MakeReply());\n+      return false;\n+  }\n+\n+  return true;\n+}\n+\n }  // namespace\n \n void ZSetFamily::BZPopMin(CmdArgList args, const CommandContext& cmd_cntx) {\n@@ -2355,12 +2435,77 @@ void ZSetFamily::ZInterCard(CmdArgList args, const CommandContext& cmd_cntx) {\n   builder->SendLong(result.value().size());\n }\n \n+void ZSetFamily::ZMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n+  uint32 num_keys;\n+  bool is_max;\n+  int pop_count;\n+  if (!ValidateZMPopCommand(args, &num_keys, &is_max, &pop_count, cmd_cntx.rb)) {\n+    return;\n+  }\n+  auto* response_builder = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n+\n+  // From the list of input keys, keep the first (in the order of keys in the command) key found in\n+  // the current shard.\n+  std::vector<std::optional<std::string_view>> first_found_key_per_shard_vec(shard_set->size(),\n+                                                                             std::nullopt);\n+\n+  auto cb = [&](Transaction* t, EngineShard* shard) {\n+    std::optional<std::string_view> result = GetFirstNonEmptyKeyFound(shard, t);\n+    if (result.has_value()) {\n+      first_found_key_per_shard_vec[shard->shard_id()] = result;\n+    }\n+    return OpStatus::OK;\n+  };\n+\n+  cmd_cntx.tx->Execute(std::move(cb), false /* possibly another hop */);\n+\n+  // Keep all the keys found (first only for each shard) in a set for fast lookups.\n+  absl::flat_hash_set<std::string_view> first_found_keys_for_shard;\n+  // We can have at most one result from each shard.\n+  first_found_keys_for_shard.reserve(std::min(shard_set->size(), num_keys));\n+  for (const auto& key : first_found_key_per_shard_vec) {\n+    if (!key.has_value()) {\n+      continue;\n+    }\n+    first_found_keys_for_shard.insert(*key);\n+  }\n+\n+  // Now that we have the first non empty key from each shard, find the first overall first key and\n+  // pop elements from it.\n+  std::optional<std::string_view> key_to_pop = std::nullopt;\n+  ArgRange arg_keys(args.subspan(1, num_keys));\n+  // Find the first arg_key which exists in any shard and is not empty.\n+  for (std::string_view key : arg_keys) {\n+    if (first_found_keys_for_shard.contains(key)) {\n+      key_to_pop = key;\n+      break;\n+    }\n+  }\n+\n+  if (!key_to_pop.has_value()) {\n+    cmd_cntx.tx->Conclude();\n+    response_builder->SendNull();\n+    return;\n+  }\n+\n+  // Pop elements from relevant set.\n+  OpResult<ScoredArray> pop_result =\n+      ZPopMinMaxInternal(*key_to_pop, FilterShards::YES, pop_count, is_max, cmd_cntx.tx);\n+\n+  if (pop_result.status() == OpStatus::WRONG_TYPE) {\n+    return response_builder->SendError(kWrongTypeErr);\n+  }\n+\n+  LOG_IF(WARNING, !pop_result) << \"Unexpected status \" << pop_result.status();\n+  response_builder->SendLabeledScoredArray(*key_to_pop, pop_result.value());\n+}\n+\n void ZSetFamily::ZPopMax(CmdArgList args, const CommandContext& cmd_cntx) {\n-  ZPopMinMax(std::move(args), true, cmd_cntx.tx, cmd_cntx.rb);\n+  ZPopMinMaxFromArgs(std::move(args), true, cmd_cntx.tx, cmd_cntx.rb);\n }\n \n void ZSetFamily::ZPopMin(CmdArgList args, const CommandContext& cmd_cntx) {\n-  ZPopMinMax(std::move(args), false, cmd_cntx.tx, cmd_cntx.rb);\n+  ZPopMinMaxFromArgs(std::move(args), false, cmd_cntx.tx, cmd_cntx.rb);\n }\n \n void ZSetFamily::ZLexCount(CmdArgList args, const CommandContext& cmd_cntx) {\n@@ -3217,6 +3362,7 @@ constexpr uint32_t kZInterStore = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZInter = READ | SORTEDSET | SLOW;\n constexpr uint32_t kZInterCard = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZLexCount = READ | SORTEDSET | FAST;\n+constexpr uint32_t kZMPop = WRITE | SORTEDSET | SLOW;\n constexpr uint32_t kZPopMax = WRITE | SORTEDSET | FAST;\n constexpr uint32_t kZPopMin = WRITE | SORTEDSET | FAST;\n constexpr uint32_t kZRem = WRITE | SORTEDSET | FAST;\n@@ -3267,6 +3413,8 @@ void ZSetFamily::Register(CommandRegistry* registry) {\n       << CI{\"ZINTERCARD\", CO::READONLY | CO::VARIADIC_KEYS, -3, 2, 2, acl::kZInterCard}.HFUNC(\n              ZInterCard)\n       << CI{\"ZLEXCOUNT\", CO::READONLY, 4, 1, 1, acl::kZLexCount}.HFUNC(ZLexCount)\n+      << CI{\"ZMPOP\", CO::SLOW | CO::WRITE | CO::VARIADIC_KEYS, -4, 2, 2, acl::kZMPop}.HFUNC(ZMPop)\n+\n       << CI{\"ZPOPMAX\", CO::FAST | CO::WRITE, -2, 1, 1, acl::kZPopMax}.HFUNC(ZPopMax)\n       << CI{\"ZPOPMIN\", CO::FAST | CO::WRITE, -2, 1, 1, acl::kZPopMin}.HFUNC(ZPopMin)\n       << CI{\"ZREM\", CO::FAST | CO::WRITE, -3, 1, 1, acl::kZRem}.HFUNC(ZRem)\ndiff --git a/src/server/zset_family.h b/src/server/zset_family.h\nindex ec678597a791..17d4eceb24ad 100644\n--- a/src/server/zset_family.h\n+++ b/src/server/zset_family.h\n@@ -72,6 +72,7 @@ class ZSetFamily {\n   static void ZInter(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZInterCard(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZLexCount(CmdArgList args, const CommandContext& cmd_cntx);\n+  static void ZMPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZPopMax(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZPopMin(CmdArgList args, const CommandContext& cmd_cntx);\n   static void ZRange(CmdArgList args, const CommandContext& cmd_cntx);\n",
  "test_patch": "diff --git a/src/facade/reply_builder_test.cc b/src/facade/reply_builder_test.cc\nindex 028d594eef9f..8560bcde5ee0 100644\n--- a/src/facade/reply_builder_test.cc\n+++ b/src/facade/reply_builder_test.cc\n@@ -775,6 +775,27 @@ TEST_F(RedisReplyBuilderTest, SendScoredArray) {\n       << \"Resp3 WITHSCORES failed.\";\n }\n \n+TEST_F(RedisReplyBuilderTest, SendLabeledScoredArray) {\n+  const std::vector<std::pair<std::string, double>> scored_array{\n+      {\"e1\", 1.1}, {\"e2\", 2.2}, {\"e3\", 3.3}};\n+\n+  builder_->SetResp3(false);\n+  builder_->SendLabeledScoredArray(\"foobar\", scored_array);\n+  ASSERT_TRUE(NoErrors());\n+  ASSERT_EQ(TakePayload(),\n+            \"*2\\r\\n$6\\r\\nfoobar\\r\\n*3\\r\\n*2\\r\\n$2\\r\\ne1\\r\\n$3\\r\\n1.1\\r\\n*2\\r\\n$2\\r\\ne2\\r\\n$3\\r\\n2.\"\n+            \"2\\r\\n*2\\r\\n$2\\r\\ne3\\r\\n$3\\r\\n3.3\\r\\n\")\n+      << \"Resp3 failed.\\n\";\n+\n+  builder_->SetResp3(true);\n+  builder_->SendLabeledScoredArray(\"foobar\", scored_array);\n+  ASSERT_TRUE(NoErrors());\n+  ASSERT_EQ(TakePayload(),\n+            \"*2\\r\\n$6\\r\\nfoobar\\r\\n*3\\r\\n*2\\r\\n$2\\r\\ne1\\r\\n,1.1\\r\\n*2\\r\\n$2\\r\\ne2\\r\\n,2.2\\r\\n*\"\n+            \"2\\r\\n$2\\r\\ne3\\r\\n,3.3\\r\\n\")\n+      << \"Resp3 failed.\";\n+}\n+\n TEST_F(RedisReplyBuilderTest, BasicCapture) {\n   GTEST_SKIP() << \"Unmark when CaptuingReplyBuilder is updated\";\n \ndiff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 140488741de7..e38a364fbabf 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -81,6 +81,32 @@ MATCHER_P(UnorderedScoredElementsAreMatcher, elements_list, \"\") {\n                              elements_list.end());\n }\n \n+MATCHER_P2(ContainsLabeledScoredArrayMatcher, label, elements, \"\") {\n+  auto label_vec = arg.GetVec();\n+  if (label_vec.size() != 2) {\n+    *result_listener << \"Labeled Scored Array does no contain two elements.\";\n+    return false;\n+  }\n+\n+  if (!ExplainMatchResult(Eq(label), label_vec[0].GetString(), result_listener)) {\n+    return false;\n+  }\n+\n+  auto value_pairs_vec = label_vec[1].GetVec();\n+  std::set<std::pair<std::string, std::string>> actual_elements;\n+  for (const auto& scored_element : value_pairs_vec) {\n+    actual_elements.insert(std::make_pair(scored_element.GetVec()[0].GetString(),\n+                                          scored_element.GetVec()[1].GetString()));\n+  }\n+  if (actual_elements != elements) {\n+    *result_listener << \"Scored elements do not match: \";\n+    ExplainMatchResult(ElementsAreArray(elements), actual_elements, result_listener);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n auto ConsistsOf(std::initializer_list<std::string> elements) {\n   return ConsistsOfMatcher(std::unordered_set<std::string>{elements});\n }\n@@ -98,6 +124,12 @@ auto UnorderedScoredElementsAre(\n   return UnorderedScoredElementsAreMatcher(elements);\n }\n \n+auto ContainsLabeledScoredArray(\n+    std::string_view label, std::initializer_list<std::pair<std::string, std::string>> elements) {\n+  return ContainsLabeledScoredArrayMatcher(label,\n+                                           std::set<std::pair<std::string, std::string>>{elements});\n+}\n+\n TEST_F(ZSetFamilyTest, Add) {\n   auto resp = Run({\"zadd\", \"x\", \"1.1\", \"a\"});\n   EXPECT_THAT(resp, IntArg(1));\n@@ -757,6 +789,102 @@ TEST_F(ZSetFamilyTest, ZAddBug148) {\n   EXPECT_THAT(resp, IntArg(1));\n }\n \n+TEST_F(ZSetFamilyTest, ZMPopInvalidSyntax) {\n+  // Not enough arguments.\n+  auto resp = Run({\"zmpop\", \"1\", \"a\"});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  // Zero keys.\n+  resp = Run({\"zmpop\", \"0\", \"MIN\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Number of keys not uint.\n+  resp = Run({\"zmpop\", \"aa\", \"a\", \"MIN\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Missing MIN/MAX.\n+  resp = Run({\"zmpop\", \"1\", \"a\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Wrong number of keys.\n+  resp = Run({\"zmpop\", \"1\", \"a\", \"b\", \"MAX\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Count with no number.\n+  resp = Run({\"zmpop\", \"1\", \"a\", \"MAX\", \"COUNT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Count number is not uint.\n+  resp = Run({\"zmpop\", \"1\", \"a\", \"MIN\", \"COUNT\", \"boo\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Too many arguments.\n+  resp = Run({\"zmpop\", \"1\", \"c\", \"MAX\", \"COUNT\", \"2\", \"foo\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+}\n+\n+TEST_F(ZSetFamilyTest, ZMPop) {\n+  // All sets are empty.\n+  auto resp = Run({\"zmpop\", \"1\", \"e\", \"MIN\"});\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  // Min operation.\n+  resp = Run({\"zadd\", \"a\", \"1\", \"a1\", \"2\", \"a2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"zmpop\", \"1\", \"a\", \"MIN\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"a\", {{\"a1\", \"1\"}}));\n+\n+  resp = Run({\"ZRANGE\", \"a\", \"0\", \"-1\", \"WITHSCORES\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"a2\", \"2\")));\n+\n+  // Max operation.\n+  resp = Run({\"zadd\", \"b\", \"1\", \"b1\", \"2\", \"b2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"zmpop\", \"1\", \"b\", \"MAX\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"b\", {{\"b2\", \"2\"}}));\n+\n+  resp = Run({\"ZRANGE\", \"b\", \"0\", \"-1\", \"WITHSCORES\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"b1\", \"1\")));\n+\n+  // Count > 1.\n+  resp = Run({\"zadd\", \"c\", \"1\", \"c1\", \"2\", \"c2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"zmpop\", \"1\", \"c\", \"MAX\", \"COUNT\", \"2\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"c\", {{\"c1\", \"1\"}, {\"c2\", \"2\"}}));\n+\n+  resp = Run({\"zcard\", \"c\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // Count > #elements in set.\n+  resp = Run({\"zadd\", \"d\", \"1\", \"d1\", \"2\", \"d2\"});\n+  EXPECT_THAT(resp, IntArg(2));\n+\n+  resp = Run({\"zmpop\", \"1\", \"d\", \"MAX\", \"COUNT\", \"3\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"d\", {{\"d1\", \"1\"}, {\"d2\", \"2\"}}));\n+\n+  resp = Run({\"zcard\", \"d\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // First non empty set is not the first set.\n+  resp = Run({\"zadd\", \"x\", \"1\", \"x1\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"zadd\", \"y\", \"1\", \"y1\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  resp = Run({\"zmpop\", \"3\", \"empty\", \"x\", \"y\", \"MAX\"});\n+  EXPECT_THAT(resp, ContainsLabeledScoredArray(\"x\", {{\"x1\", \"1\"}}));\n+\n+  resp = Run({\"zcard\", \"x\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  resp = Run({\"ZRANGE\", \"y\", \"0\", \"-1\", \"WITHSCORES\"});\n+  EXPECT_THAT(resp, RespArray(ElementsAre(\"y1\", \"1\")));\n+}\n+\n TEST_F(ZSetFamilyTest, ZPopMin) {\n   auto resp = Run({\"zadd\", \"key\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\", \"4\", \"d\", \"5\", \"e\", \"6\", \"f\"});\n   EXPECT_THAT(resp, IntArg(6));\n",
  "problem_statement": "implement ZMPOP\n\n",
  "hints_text": "Interested in taking this issue on. Will review the CONTRIBUTING.md and start looking into this.\nHonestly, I'm still interested, but I will probably not be able to do this at least until next summer. I waive my claim if anyone else wants to do it, and if nobody does, maybe I can write this patch or another one next summer :)",
  "created_at": "2024-12-30T13:08:57Z",
  "modified_files": [
    "src/facade/reply_builder.cc",
    "src/facade/reply_builder.h",
    "src/server/command_registry.cc",
    "src/server/command_registry.h",
    "src/server/zset_family.cc",
    "src/server/zset_family.h"
  ],
  "modified_test_files": [
    "src/facade/reply_builder_test.cc",
    "src/server/zset_family_test.cc"
  ]
}