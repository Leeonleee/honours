{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5370,
  "instance_id": "dragonflydb__dragonfly-5370",
  "issue_numbers": [
    "3876"
  ],
  "base_commit": "6bde91e390e89121934e020f1694825287d63e02",
  "patch": "diff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 9f6ea5a04086..0465ab8cdc22 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -1008,6 +1008,47 @@ void ListFamily::LMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n   }\n }\n \n+void ListFamily::BLMPop(CmdArgList args, const CommandContext& cmd_cntx) {\n+  auto* response_builder = static_cast<RedisReplyBuilder*>(cmd_cntx.rb);\n+\n+  CmdArgParser parser{args};\n+  float timeout = parser.Next<float>();\n+  if (auto err = parser.Error(); err)\n+    return response_builder->SendError(err->MakeReply());\n+\n+  if (timeout < 0)\n+    return response_builder->SendError(\"timeout is negative\");\n+\n+  parser.Skip(parser.Next<size_t>());  // Skip numkeys and keys\n+  ListDir dir = parser.MapNext(\"LEFT\", ListDir::LEFT, \"RIGHT\", ListDir::RIGHT);\n+\n+  size_t pop_count = 1;\n+  if (parser.Check(\"COUNT\"))\n+    pop_count = parser.Next<size_t>();\n+\n+  if (!parser.Finalize())\n+    return response_builder->SendError(parser.Error()->MakeReply());\n+\n+  OpResult<StringVec> result;\n+  auto cb = [&](Transaction* t, EngineShard* shard, string_view key) {\n+    result = OpPop(t->GetOpArgs(shard), key, dir, pop_count, true, false);\n+    return result.status();\n+  };\n+\n+  ConnectionContext* conn_cntx = cmd_cntx.conn_cntx;\n+  OpResult<string> popped_key = container_utils::RunCbOnFirstNonEmptyBlocking(\n+      cmd_cntx.tx, OBJ_LIST, std::move(cb), unsigned(timeout * 1000), &conn_cntx->blocked,\n+      &conn_cntx->paused);\n+\n+  if (popped_key.ok()) {\n+    response_builder->StartArray(2);\n+    response_builder->SendBulkString(*popped_key);\n+    response_builder->SendBulkStrArr(*result);\n+  } else {\n+    response_builder->SendNull();\n+  }\n+}\n+\n void ListFamily::LPush(CmdArgList args, const CommandContext& cmd_cntx) {\n   return PushGeneric(ListDir::LEFT, false, args, cmd_cntx.tx, cmd_cntx.rb);\n }\n@@ -1271,6 +1312,7 @@ constexpr uint32_t kLPush = WRITE | LIST | FAST;\n constexpr uint32_t kLPushX = WRITE | LIST | FAST;\n constexpr uint32_t kLPop = WRITE | LIST | FAST;\n constexpr uint32_t kLMPop = WRITE | LIST | FAST;\n+constexpr uint32_t kBLMPop = WRITE | LIST | SLOW | BLOCKING;\n constexpr uint32_t kRPush = WRITE | LIST | FAST;\n constexpr uint32_t kRPushX = WRITE | LIST | FAST;\n constexpr uint32_t kRPop = WRITE | LIST | FAST;\n@@ -1297,6 +1339,8 @@ void ListFamily::Register(CommandRegistry* registry) {\n       << CI{\"LPUSHX\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kLPushX}.HFUNC(LPushX)\n       << CI{\"LPOP\", CO::WRITE | CO::FAST, -2, 1, 1, acl::kLPop}.HFUNC(LPop)\n       << CI{\"LMPOP\", CO::WRITE | CO::SLOW | CO::VARIADIC_KEYS, -4, 2, 2, acl::kLMPop}.HFUNC(LMPop)\n+      << CI{\"BLMPOP\", CO::WRITE | CO::SLOW | CO::VARIADIC_KEYS, -5, 3, 3, acl::kBLMPop}.HFUNC(\n+             BLMPop)\n       << CI{\"RPUSH\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kRPush}.HFUNC(RPush)\n       << CI{\"RPUSHX\", CO::WRITE | CO::FAST | CO::DENYOOM, -3, 1, 1, acl::kRPushX}.HFUNC(RPushX)\n       << CI{\"RPOP\", CO::WRITE | CO::FAST, -2, 1, 1, acl::kRPop}.HFUNC(RPop)\ndiff --git a/src/server/list_family.h b/src/server/list_family.h\nindex 0b5155264727..0683a7593c0d 100644\n--- a/src/server/list_family.h\n+++ b/src/server/list_family.h\n@@ -34,6 +34,7 @@ class ListFamily {\n   static void BLPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void BRPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LMPop(CmdArgList args, const CommandContext& cmd_cntx);\n+  static void BLMPop(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LLen(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LPos(CmdArgList args, const CommandContext& cmd_cntx);\n   static void LIndex(CmdArgList args, const CommandContext& cmd_cntx);\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex f294460a69df..0ad8a07f1edf 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -1588,7 +1588,7 @@ OpResult<KeyIndex> DetermineKeys(const CommandId* cid, CmdArgList args) {\n       bonus = 0;  // Z<xxx>STORE <key> commands\n \n     unsigned num_keys_index;\n-    if (absl::StartsWith(name, \"EVAL\"))\n+    if (absl::StartsWith(name, \"EVAL\") || name == \"BLMPOP\")\n       num_keys_index = 1;\n     else\n       num_keys_index = bonus ? *bonus + 1 : 0;\n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex adef56df9c9a..cbfde997fdbb 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -85,6 +85,108 @@ TEST_F(ListFamilyTest, Expire) {\n   EXPECT_THAT(resp, IntArg(1));\n }\n \n+TEST_F(ListFamilyTest, BLMPopNonblocking) {\n+  auto resp = Run({\"lpush\", kKey1, \"1\", \"2\", \"3\", \"4\"});\n+  EXPECT_THAT(resp, IntArg(4));\n+\n+  resp = Run({\"blmpop\", \"0.01\", \"2\", kKey2, kKey1, \"LEFT\"});\n+  EXPECT_THAT(resp, RespElementsAre(kKey1, RespElementsAre(\"4\")));\n+\n+  resp = Run({\"blmpop\", \"0.01\", \"2\", kKey2, kKey1, \"RIGHT\", \"COUNT\", \"2\"});\n+  EXPECT_THAT(resp, RespElementsAre(kKey1, RespElementsAre(\"1\", \"2\")));\n+\n+  // If the count exceeds the size of the key's values (but the key is non-empty) then return all of\n+  // the key's values\n+  resp = Run({\"blmpop\", \"0.01\", \"1\", kKey1, \"RIGHT\", \"COUNT\", \"10\"});\n+  EXPECT_THAT(resp, RespElementsAre(kKey1, RespElementsAre(\"3\")));\n+}\n+\n+TEST_F(ListFamilyTest, BLMPopInvalidSyntax) {\n+  // Not enough arguments\n+  auto resp = Run({\"blmpop\", \"0.1\", \"1\", kKey1});\n+  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+\n+  // Timeout is not a float\n+  resp = Run({\"blmpop\", \"foo\", \"1\", kKey1, \"LEFT\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not a valid float\"));\n+\n+  // Negative timeout\n+  resp = Run({\"blmpop\", \"-0.01\", \"1\", kKey1, \"LEFT\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"timeout is negative\"));\n+\n+  // Zero keys\n+  resp = Run({\"blmpop\", \"0.01\", \"0\", \"LEFT\", \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"at least 1 input key is needed\"));\n+\n+  // Number of keys is not uint\n+  resp = Run({\"blmpop\", \"0.01\", \"aa\", kKey1, \"LEFT\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Missing LEFT/RIGHT\n+  resp = Run({\"blmpop\", \"0.01\", \"1\", kKey1, \"COUNT\", \"1\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // Wrong number of keys\n+  resp = Run({\"blmpop\", \"0.01\", \"1\", kKey1, kKey2, \"LEFT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // COUNT without number\n+  resp = Run({\"blmpop\", \"0.01\", \"1\", kKey1, \"LEFT\", \"COUNT\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+\n+  // COUNT is not uint\n+  resp = Run({\"blmpop\", \"0.01\", \"1\", kKey1, \"LEFT\", \"COUNT\", \"boo\"});\n+  EXPECT_THAT(resp, ErrArg(\"value is not an integer or out of range\"));\n+\n+  // Too many arguments\n+  resp = Run({\"blmpop\", \"0.01\", \"1\", \"c\", \"LEFT\", \"COUNT\", \"2\", \"foo\"});\n+  EXPECT_THAT(resp, ErrArg(\"syntax error\"));\n+}\n+\n+TEST_F(ListFamilyTest, BLMPopBlocking) {\n+  // attempting to pop from empty key results in blocking and returns\n+  // null if no values are pushed to the key.\n+  RespExpr resp;\n+  auto fb0 = pp_->at(0)->LaunchFiber(Launch::dispatch, [&] {\n+    resp = Run({\"blmpop\", \"0.1\", \"1\", kKey1, \"LEFT\"});\n+  });\n+  ThisFiber::SleepFor(50us);\n+  ASSERT_TRUE(IsLocked(0, kKey1));\n+\n+  fb0.Join();\n+  ASSERT_FALSE(IsLocked(0, kKey1));\n+  EXPECT_THAT(resp, ArgType(RespExpr::NIL));\n+\n+  // BLMPOP should not block if there is a non-empty key available\n+  resp = Run({\"lpush\", kKey1, \"0\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  auto fb1 = pp_->at(1)->LaunchFiber(Launch::dispatch, [&] {\n+    resp = Run({\"blmpop\", \"0.1\", \"1\", kKey1, \"LEFT\"});\n+  });\n+  ThisFiber::SleepFor(50us);\n+  // shouldn't need to lock the key just pop immediately\n+  ASSERT_FALSE(IsLocked(0, kKey1));\n+  fb1.Join();\n+\n+  // should block until a key is available and then immediately unblock\n+  auto fb2 = pp_->at(2)->LaunchFiber(Launch::dispatch, [&] {\n+    resp = Run({\"blmpop\", \"0.1\", \"1\", kKey1, \"LEFT\"});\n+  });\n+  ThisFiber::SleepFor(50us);\n+\n+  // key should be locked while waiting\n+  ASSERT_TRUE(IsLocked(0, kKey1));\n+\n+  auto push_resp = Run({\"lpush\", kKey1, \"1\"});\n+  EXPECT_THAT(push_resp, IntArg(1));\n+\n+  // key should be unlocked after being inserted to\n+  fb2.Join();\n+  ASSERT_FALSE(IsLocked(0, kKey1));\n+  EXPECT_THAT(resp, RespElementsAre(kKey1, RespElementsAre(\"1\")));\n+}\n+\n TEST_F(ListFamilyTest, BLPopUnblocking) {\n   auto resp = Run({\"lpush\", kKey1, \"1\"});\n   EXPECT_THAT(resp, IntArg(1));\n",
  "problem_statement": "implement BLMPOP\n\n",
  "hints_text": "Hi! I was wondering if this issue is still open. If so, I\u2019d love to work on it \u2014 could I be assigned or go ahead and take it?\nHello @EricHayter , yes it's up for grabs",
  "created_at": "2025-06-26T21:12:13Z",
  "modified_files": [
    "src/server/list_family.cc",
    "src/server/list_family.h",
    "src/server/transaction.cc"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc"
  ]
}