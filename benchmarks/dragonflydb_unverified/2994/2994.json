{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 2994,
  "instance_id": "dragonflydb__dragonfly-2994",
  "issue_numbers": [
    "2850"
  ],
  "base_commit": "9f6b716b47f3c664618d063e24a6fe9d4b46ca2b",
  "patch": "diff --git a/src/server/zset_family.cc b/src/server/zset_family.cc\nindex 22dd8e0452c9..1ab3443aa241 100644\n--- a/src/server/zset_family.cc\n+++ b/src/server/zset_family.cc\n@@ -222,6 +222,70 @@ OpResult<DbSlice::ItAndUpdater> FindZEntry(const ZParams& zparams, const OpArgs&\n   return DbSlice::ItAndUpdater{add_res.it, add_res.exp_it, std::move(add_res.post_updater)};\n }\n \n+using RandomPick = std::uint32_t;\n+\n+class PicksGenerator {\n+ public:\n+  virtual RandomPick Generate() = 0;\n+  virtual ~PicksGenerator() = default;\n+};\n+\n+class NonUniquePicksGenerator : public PicksGenerator {\n+ public:\n+  NonUniquePicksGenerator(RandomPick max_range) : max_range_(max_range) {\n+    CHECK_GT(max_range, RandomPick(0));\n+  }\n+\n+  RandomPick Generate() override {\n+    return absl::Uniform(bitgen_, 0u, max_range_);\n+  }\n+\n+ private:\n+  const RandomPick max_range_;\n+  absl::BitGen bitgen_{};\n+};\n+\n+/*\n+ * Generates unique index in O(1).\n+ *\n+ * picks_count specifies the number of random indexes to be generated.\n+ * In other words, this is the number of times the Generate() function is called.\n+ *\n+ * The class uses Robert Floyd's sampling algorithm\n+ * https://dl.acm.org/doi/pdf/10.1145/30401.315746\n+ * */\n+class UniquePicksGenerator : public PicksGenerator {\n+ public:\n+  UniquePicksGenerator(std::uint32_t picks_count, RandomPick max_range)\n+      : remaining_picks_count_(picks_count), picked_indexes_(picks_count) {\n+    CHECK_GE(max_range, picks_count);\n+    current_random_limit_ = max_range - picks_count;\n+  }\n+\n+  RandomPick Generate() override {\n+    DCHECK_GT(remaining_picks_count_, 0u);\n+\n+    remaining_picks_count_--;\n+\n+    const RandomPick max_index = current_random_limit_++;\n+    const RandomPick random_index = absl::Uniform(bitgen_, 0u, max_index + 1u);\n+\n+    const bool random_index_is_picked = picked_indexes_.emplace(random_index).second;\n+    if (random_index_is_picked) {\n+      return random_index;\n+    }\n+\n+    picked_indexes_.insert(max_index);\n+    return max_index;\n+  }\n+\n+ private:\n+  RandomPick current_random_limit_;\n+  std::uint32_t remaining_picks_count_;\n+  std::unordered_set<RandomPick> picked_indexes_;\n+  absl::BitGen bitgen_{};\n+};\n+\n bool ScoreToLongLat(const std::optional<double>& val, double* xy) {\n   if (!val.has_value())\n     return false;\n@@ -1702,6 +1766,48 @@ OpResult<StringVec> OpScan(const OpArgs& op_args, std::string_view key, uint64_t\n   return res;\n }\n \n+OpResult<ScoredArray> OpRandMember(int count, const ZSetFamily::RangeParams& params,\n+                                   const OpArgs& op_args, string_view key) {\n+  auto it = op_args.shard->db_slice().FindReadOnly(op_args.db_cntx, key, OBJ_ZSET);\n+  if (!it)\n+    return it.status();\n+\n+  // Action::RANGE is a read-only operation, but requires const_cast\n+  PrimeValue& pv = const_cast<PrimeValue&>(it.value()->second);\n+\n+  const std::size_t size = pv.Size();\n+  const std::size_t picks_count =\n+      count >= 0 ? std::min(static_cast<std::size_t>(count), size) : std::abs(count);\n+\n+  ScoredArray result{picks_count};\n+  std::unique_ptr<PicksGenerator> generator =\n+      count >= 0 ? static_cast<std::unique_ptr<PicksGenerator>>(\n+                       std::make_unique<UniquePicksGenerator>(picks_count, size))\n+                 : std::make_unique<NonUniquePicksGenerator>(size);\n+\n+  if (picks_count * static_cast<std::uint64_t>(std::log2(size)) < size) {\n+    for (std::size_t i = 0; i < picks_count; i++) {\n+      const std::size_t picked_index = generator->Generate();\n+\n+      IntervalVisitor iv{Action::RANGE, params, &pv};\n+      iv(ZSetFamily::IndexInterval{picked_index, picked_index});\n+\n+      result[i] = iv.PopResult().front();\n+    }\n+  } else {\n+    IntervalVisitor iv{Action::RANGE, params, &pv};\n+    iv(ZSetFamily::IndexInterval{0, -1});\n+\n+    ScoredArray all_elements = iv.PopResult();\n+\n+    for (std::size_t i = 0; i < picks_count; i++) {\n+      result[i] = all_elements[generator->Generate()];\n+    }\n+  }\n+\n+  return result;\n+}\n+\n void ZAddGeneric(string_view key, const ZParams& zparams, ScoredMemberSpan memb_sp,\n                  ConnectionContext* cntx) {\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n@@ -2323,16 +2429,14 @@ void ZSetFamily::ZRandMember(CmdArgList args, ConnectionContext* cntx) {\n   if (args.size() > 3)\n     return cntx->SendError(WrongNumArgsError(\"ZRANDMEMBER\"));\n \n-  ZRangeSpec range_spec;\n-  range_spec.interval = IndexInterval(0, -1);\n-\n   CmdArgParser parser{args};\n   string_view key = parser.Next();\n \n   bool is_count = parser.HasNext();\n   int count = is_count ? parser.Next<int>() : 1;\n \n-  range_spec.params.with_scores = static_cast<bool>(parser.Check(\"WITHSCORES\").IgnoreCase());\n+  ZSetFamily::RangeParams params;\n+  params.with_scores = static_cast<bool>(parser.Check(\"WITHSCORES\").IgnoreCase());\n \n   if (parser.HasNext())\n     return cntx->SendError(absl::StrCat(\"Unsupported option:\", string_view(parser.Next())));\n@@ -2340,26 +2444,17 @@ void ZSetFamily::ZRandMember(CmdArgList args, ConnectionContext* cntx) {\n   if (auto err = parser.Error(); err)\n     return cntx->SendError(err->MakeReply());\n \n-  bool sign = count < 0;\n-  range_spec.params.limit = std::abs(count);\n-\n   const auto cb = [&](Transaction* t, EngineShard* shard) {\n-    return OpRange(range_spec, t->GetOpArgs(shard), key);\n+    return OpRandMember(count, params, t->GetOpArgs(shard), key);\n   };\n \n   OpResult<ScoredArray> result = cntx->transaction->ScheduleSingleHopT(cb);\n   auto* rb = static_cast<RedisReplyBuilder*>(cntx->reply_builder());\n   if (result) {\n-    if (sign && !result->empty()) {\n-      for (auto i = result->size(); i < range_spec.params.limit; ++i) {\n-        // we can return duplicate elements, so first is OK\n-        result->push_back(result->front());\n-      }\n-    }\n-    rb->SendScoredArray(result.value(), range_spec.params.with_scores);\n+    rb->SendScoredArray(result.value(), params.with_scores);\n   } else if (result.status() == OpStatus::KEY_NOTFOUND) {\n     if (is_count) {\n-      rb->SendScoredArray(ScoredArray(), range_spec.params.with_scores);\n+      rb->SendScoredArray(ScoredArray(), params.with_scores);\n     } else {\n       rb->SendNull();\n     }\n",
  "test_patch": "diff --git a/src/server/zset_family_test.cc b/src/server/zset_family_test.cc\nindex 093c3e647a62..f8868f937b65 100644\n--- a/src/server/zset_family_test.cc\n+++ b/src/server/zset_family_test.cc\n@@ -20,6 +20,84 @@ class ZSetFamilyTest : public BaseFamilyTest {\n  protected:\n };\n \n+using ScoredElement = std::pair<std::string, std::string>;\n+\n+template <typename Array> auto ParseToScoredArray(Array arr) {\n+  std::vector<ScoredElement> scored_elements;\n+  for (std::size_t i = 1; i < arr.size(); i += 2) {\n+    scored_elements.emplace_back(arr[i - 1].GetString(), arr[i].GetString());\n+  }\n+  return scored_elements;\n+}\n+\n+MATCHER_P(ConsistsOfMatcher, elements, \"\") {\n+  auto vec = arg.GetVec();\n+  for (const auto& x : vec) {\n+    if (elements.find(x.GetString()) == elements.end()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+MATCHER_P(ConsistsOfScoredElementsMatcher, elements, \"\") {\n+  auto vec = arg.GetVec();\n+  if (vec.size() % 2) {\n+    return false;\n+  }\n+\n+  auto scored_vec = ParseToScoredArray(vec);\n+  for (const auto& scored_element : scored_vec) {\n+    if (elements.find(scored_element) == elements.end()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+MATCHER_P(IsScoredSubsetOfMatcher, elements_list, \"\") {\n+  auto vec = arg.GetVec();\n+  if (vec.size() % 2) {\n+    return false;\n+  }\n+\n+  auto scored_vec = ParseToScoredArray(vec);\n+  std::vector<ScoredElement> elements{elements_list};\n+\n+  std::sort(scored_vec.begin(), scored_vec.end());\n+  std::sort(elements.begin(), elements.end());\n+\n+  return std::includes(elements.begin(), elements.end(), scored_vec.begin(), scored_vec.end());\n+}\n+\n+MATCHER_P(UnorderedScoredElementsAreMatcher, elements_list, \"\") {\n+  auto vec = arg.GetVec();\n+  if (vec.size() % 2) {\n+    return false;\n+  }\n+\n+  auto scored_vec = ParseToScoredArray(vec);\n+  return std::is_permutation(scored_vec.begin(), scored_vec.end(), elements_list.begin(),\n+                             elements_list.end());\n+}\n+\n+auto ConsistsOf(std::initializer_list<std::string> elements) {\n+  return ConsistsOfMatcher(std::unordered_set<std::string>{elements});\n+}\n+\n+auto ConsistsOfScoredElements(std::initializer_list<std::pair<std::string, std::string>> elements) {\n+  return ConsistsOfScoredElementsMatcher(std::set<std::pair<std::string, std::string>>{elements});\n+}\n+\n+auto IsScoredSubsetOf(std::initializer_list<std::pair<std::string, std::string>> elements) {\n+  return IsScoredSubsetOfMatcher(elements);\n+}\n+\n+auto UnorderedScoredElementsAre(\n+    std::initializer_list<std::pair<std::string, std::string>> elements) {\n+  return UnorderedScoredElementsAreMatcher(elements);\n+}\n+\n TEST_F(ZSetFamilyTest, Add) {\n   auto resp = Run({\"zadd\", \"x\", \"1.1\", \"a\"});\n   EXPECT_THAT(resp, IntArg(1));\n@@ -77,53 +155,95 @@ TEST_F(ZSetFamilyTest, ZRem) {\n }\n \n TEST_F(ZSetFamilyTest, ZRandMember) {\n-  auto resp = Run({\n-      \"zadd\",\n-      \"x\",\n-      \"1\",\n-      \"a\",\n-      \"2\",\n-      \"b\",\n-      \"3\",\n-      \"c\",\n-  });\n+  auto resp = Run({\"ZAdd\", \"x\", \"1\", \"a\", \"2\", \"b\", \"3\", \"c\"});\n+  EXPECT_THAT(resp, IntArg(3));\n+\n+  // Test if count > 0\n   resp = Run({\"ZRandMember\", \"x\"});\n   ASSERT_THAT(resp, ArgType(RespExpr::STRING));\n-  EXPECT_THAT(resp, \"a\");\n+  EXPECT_THAT(resp, AnyOf(\"a\", \"b\", \"c\"));\n+\n+  resp = Run({\"ZRandMember\", \"x\", \"1\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::STRING));\n+  EXPECT_THAT(resp, AnyOf(\"a\", \"b\", \"c\"));\n \n   resp = Run({\"ZRandMember\", \"x\", \"2\"});\n-  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n-  EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"a\", \"b\"));\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp.GetVec(), IsSubsetOf({\"a\", \"b\", \"c\"}));\n \n-  resp = Run({\"ZRandMember\", \"x\", \"0\"});\n-  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n-  EXPECT_EQ(resp.GetVec().size(), 0);\n+  resp = Run({\"ZRandMember\", \"x\", \"3\"});\n+  ASSERT_THAT(resp, ArrLen(3));\n+  EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"a\", \"b\", \"c\"));\n+\n+  // Test if count < 0\n+  resp = Run({\"ZRandMember\", \"x\", \"-1\"});\n+  ASSERT_THAT(resp, ArgType(RespExpr::STRING));\n+  EXPECT_THAT(resp, AnyOf(\"a\", \"b\", \"c\"));\n \n-  resp = Run({\"ZRandMember\", \"k\"});\n-  ASSERT_THAT(resp, ArgType(RespExpr::NIL));\n+  resp = Run({\"ZRandMember\", \"x\", \"-2\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp, ConsistsOf({\"a\", \"b\", \"c\"}));\n \n-  resp = Run({\"ZRandMember\", \"k\", \"2\"});\n-  ASSERT_THAT(resp, ArgType(RespExpr::ARRAY));\n-  EXPECT_EQ(resp.GetVec().size(), 0);\n+  resp = Run({\"ZRandMember\", \"x\", \"-3\"});\n+  ASSERT_THAT(resp, ArrLen(3));\n+  EXPECT_THAT(resp, ConsistsOf({\"a\", \"b\", \"c\"}));\n \n-  resp = Run({\"ZRandMember\", \"x\", \"-5\"});\n-  ASSERT_THAT(resp, ArrLen(5));\n-  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"b\", \"c\", \"a\", \"a\"));\n+  // Test if count < 0, but the absolute value is larger than the size of the sorted set\n+  resp = Run({\"ZRandMember\", \"x\", \"-15\"});\n+  ASSERT_THAT(resp, ArrLen(15));\n+  EXPECT_THAT(resp, ConsistsOf({\"a\", \"b\", \"c\"}));\n \n-  resp = Run({\"ZRandMember\", \"x\", \"5\"});\n+  // Test if count is 0\n+  ASSERT_THAT(Run({\"ZRandMember\", \"x\", \"0\"}), ArrLen(0));\n+\n+  // Test if count is larger than the size of the sorted set\n+  resp = Run({\"ZRandMember\", \"x\", \"15\"});\n   ASSERT_THAT(resp, ArrLen(3));\n   EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"a\", \"b\", \"c\"));\n \n-  resp = Run({\"ZRandMember\", \"x\", \"-5\", \"WITHSCORES\"});\n-  ASSERT_THAT(resp, ArrLen(10));\n-  EXPECT_THAT(resp.GetVec(), ElementsAre(\"a\", \"1\", \"b\", \"2\", \"c\", \"3\", \"a\", \"1\", \"a\", \"1\"));\n+  // Test if sorted set is empty\n+  EXPECT_THAT(Run({\"ZAdd\", \"empty::zset\", \"1\", \"one\"}), IntArg(1));\n+  EXPECT_THAT(Run({\"ZRem\", \"empty::zset\", \"one\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"ZRandMember\", \"empty::zset\", \"0\"}), ArrLen(0));\n+  ASSERT_THAT(Run({\"ZRandMember\", \"empty::zset\", \"3\"}), ArrLen(0));\n+  ASSERT_THAT(Run({\"ZRandMember\", \"empty::zset\", \"-4\"}), ArrLen(0));\n+\n+  // Test if key does not exist\n+  ASSERT_THAT(Run({\"ZRandMember\", \"y\"}), ArgType(RespExpr::NIL));\n+  ASSERT_THAT(Run({\"ZRandMember\", \"y\", \"0\"}), ArrLen(0));\n+\n+  // Test WITHSCORES\n+  resp = Run({\"ZRandMember\", \"x\", \"1\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp, IsScoredSubsetOf({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n+\n+  resp = Run({\"ZRandMember\", \"x\", \"2\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(4));\n+  EXPECT_THAT(resp, IsScoredSubsetOf({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n \n   resp = Run({\"ZRandMember\", \"x\", \"3\", \"WITHSCORES\"});\n   ASSERT_THAT(resp, ArrLen(6));\n-  EXPECT_THAT(resp.GetVec(), UnorderedElementsAre(\"a\", \"1\", \"b\", \"2\", \"c\", \"3\"));\n+  EXPECT_THAT(resp, UnorderedScoredElementsAre({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n \n-  resp = Run({\"ZRandMember\", \"x\", \"3\", \"WITHSCORES\", \"test\"});\n-  EXPECT_THAT(resp, ErrArg(\"wrong number of arguments\"));\n+  resp = Run({\"ZRandMember\", \"x\", \"15\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(6));\n+  EXPECT_THAT(resp, UnorderedScoredElementsAre({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n+\n+  resp = Run({\"ZRandMember\", \"x\", \"-1\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(2));\n+  EXPECT_THAT(resp, ConsistsOfScoredElements({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n+\n+  resp = Run({\"ZRandMember\", \"x\", \"-2\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(4));\n+  EXPECT_THAT(resp, ConsistsOfScoredElements({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n+\n+  resp = Run({\"ZRandMember\", \"x\", \"-3\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(6));\n+  EXPECT_THAT(resp, ConsistsOfScoredElements({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n+\n+  resp = Run({\"ZRandMember\", \"x\", \"-15\", \"WITHSCORES\"});\n+  ASSERT_THAT(resp, ArrLen(30));\n+  EXPECT_THAT(resp, ConsistsOfScoredElements({{\"a\", \"1\"}, {\"b\", \"2\"}, {\"c\", \"3\"}}));\n }\n \n TEST_F(ZSetFamilyTest, ZMScore) {\n",
  "problem_statement": "ZRANDMEMBER only ever returns first n elements in sorted set\n**Describe the bug**\r\n`ZRANDMEMBER` should return random elements from the specified sorted set, instead, it only returns the lowest scoring element(s).\r\n\r\n\r\n\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Insert some elements into a sorted set: `redis-cli zadd x 2 b 1 a 4 d 3 c`\r\n2. Get a random member multiple times: `seq 25 | xargs -I {} redis-cli ZRANDMEMBER x 1`\r\n3. The output will always be \"a\".\r\n\r\n**Expected behavior**\r\nI expect to get a pseudo random element for each invocation of `ZRANDMEMBER`.\r\n\r\nThe same steps above produce the expected randomized response when run against a standard redis docker image:\r\n\r\n```sh\r\n# seq 25 | xargs -I {} redis-cli ZRANDMEMBER x 1\r\n1) \"a\"\r\n1) \"a\"\r\n1) \"d\"\r\n1) \"b\"\r\n1) \"d\"\r\n1) \"b\"\r\n1) \"d\"\r\n1) \"b\"\r\n1) \"a\"\r\n1) \"c\"\r\n1) \"b\"\r\n1) \"a\"\r\n1) \"b\"\r\n1) \"d\"\r\n1) \"a\"\r\n1) \"b\"\r\n1) \"d\"\r\n1) \"a\"\r\n1) \"b\"\r\n1) \"d\"\r\n1) \"d\"\r\n1) \"b\"\r\n1) \"b\"\r\n1) \"d\"\r\n1) \"a\"\r\n```\r\n\r\n\r\n**Environment (please complete the following information):**\r\n - OS: ubuntu 20.04\r\n - Kernel: Linux 7e19e630bc09 6.4.16-linuxkit #1 SMP PREEMPT Fri Nov 10 14:49:23 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux\r\n - Containerized?: Docker\r\n - Dragonfly Version: v1.15.0\r\n\r\n**Reproducible Code Snippet**\r\n```\r\nredis-cli zadd x 2 b 1 a 4 d 3 c\r\nseq 25 | xargs -I {} redis-cli ZRANDMEMBER x 1\r\n```\r\n\r\n**Additional context**\r\nThe [dragonfly website](https://www.dragonflydb.io/docs/command-reference/compatibility) says it is fully compatible with Redis' implementation of `ZRANDMEMBER`, so it appears to be a bug instead of an intentional partial implementation.\r\n\n",
  "hints_text": "Thanks for reporting this. Out of curiosity how do you use this command? I am asking because I have not seen much traction with RAND commands of Redis API. \nSure thing!  Thanks for the quick response.\r\n\r\nIn this case, I am keeping global set of unique identifiers and the timestamp they were last updated in a handful of other data structures that all tie back to that identifier to track when they can be safely expired.  The rand usage is probably somewhat niche - I use it to facilitate a couple of kinds of load testing of the datastore and the soft real-time API that sits in front of it.  One such scenario is generating a constant read load in a production setting alongside normal traffic.  The randomness is useful for generating synthetic read load that is dynamic to data that is known to be in the system at any given time.\r\n\r\nThere are, of course, a thousand other ways to skin that cat, but I've found that this one to be one of the simplest and effective for the use cases (real-time, high data volume) I tend to have.\nI would like to add that `SRANDMEMBER` and `SPOP` have the same problem. Both commands return/remove only the lowest scoring element(s).\r\n\r\n### SRANDMEMBER\r\nThe steps to reproduce the behavior of the `SRANDMEMBER` command are the same as in the case of `ZRANDMEMBER`:\r\n\r\n1. Inserting elements into a set: `redis-cli SADD myset one two three four five six seven eight nine ten`\r\n2. \u0421alling SRANDMEMBER multiple times: `seq 20 | xargs -I {} redis-cli SRANDMEMBER myset`\r\n\r\nThe result is always \"eight\".\r\n\r\n### SPOP\r\nThe steps to reproduce the `SPOP` behavior are more tricky. After each deletion of an element, we must return it back to the set in order to keep the same set of elements:\r\n\r\n1. Insert elements into a set: `redis-cli SADD myset one two three four five six seven eight nine ten`\r\n2. Remove the element and return it back multiple times: `for i in {1..30}; do redis-cli SPOP myset | tee -a removed_members.txt | xargs -I {} redis-cli SADD myset {}; done`\r\n\r\n     - Notice: between running `SPOP` and `SADD`, we write the `SPOP` result to the file `removed_members.txt`. As a result, in `removed_elements.txt` we can see which elements were deleted during the `SPOP` commands.\r\n\r\nIn `removed_element.txt` we can see that \"eight\" was deleted each time.\r\n\r\n#### Expected behavior\r\nRedis always removes a pseudo-random element. So, the result may differ between runs:\r\n```console\r\n$ cat removed_members.txt\r\nten\r\nnine\r\nfour\r\nfive\r\neight\r\neight\r\none\r\nnine\r\ntwo\r\nnine\r\nthree\r\nfive\r\nfour\r\nnine\r\neight\r\nfive\r\nfour\r\ntwo\r\nsix\r\ntwo\r\ntwo\r\nten\r\neight\r\ntwo\r\nfive\r\nten\r\ntwo\r\nfour\r\nsix\r\nnine\r\n```",
  "created_at": "2024-05-01T14:57:33Z",
  "modified_files": [
    "src/server/zset_family.cc"
  ],
  "modified_test_files": [
    "src/server/zset_family_test.cc"
  ]
}