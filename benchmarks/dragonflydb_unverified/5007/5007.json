{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 5007,
  "instance_id": "dragonflydb__dragonfly-5007",
  "issue_numbers": [
    "4829"
  ],
  "base_commit": "13d8062bb9ca67c09e0b073c2ca605441cfdf056",
  "patch": "diff --git a/src/server/generic_family.cc b/src/server/generic_family.cc\nindex fb7e9677b94e..99e00f360058 100644\n--- a/src/server/generic_family.cc\n+++ b/src/server/generic_family.cc\n@@ -1903,13 +1903,13 @@ void GenericFamily::Register(CommandRegistry* registry) {\n       << CI{\"TOUCH\", CO::READONLY | CO::FAST, -2, 1, -1, acl::kTouch}.HFUNC(Exists)\n       << CI{\"EXPIRE\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, -3, 1, 1, acl::kExpire}.HFUNC(\n              Expire)\n-      << CI{\"EXPIREAT\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, 3, 1, 1, acl::kExpireAt}.HFUNC(\n+      << CI{\"EXPIREAT\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, -3, 1, 1, acl::kExpireAt}.HFUNC(\n              ExpireAt)\n       << CI{\"PERSIST\", CO::WRITE | CO::FAST, 2, 1, 1, acl::kPersist}.HFUNC(Persist)\n       << CI{\"KEYS\", CO::READONLY, 2, 0, 0, acl::kKeys}.HFUNC(Keys)\n-      << CI{\"PEXPIREAT\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, 3, 1, 1, acl::kPExpireAt}.HFUNC(\n-             PexpireAt)\n-      << CI{\"PEXPIRE\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, 3, 1, 1, acl::kPExpire}.HFUNC(\n+      << CI{\"PEXPIREAT\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, -3, 1, 1, acl::kPExpireAt}\n+             .HFUNC(PexpireAt)\n+      << CI{\"PEXPIRE\", CO::WRITE | CO::FAST | CO::NO_AUTOJOURNAL, -3, 1, 1, acl::kPExpire}.HFUNC(\n              Pexpire)\n       << CI{\"FIELDEXPIRE\", CO::WRITE | CO::FAST | CO::DENYOOM, -4, 1, 1, acl::kFieldExpire}.HFUNC(\n              FieldExpire)\n",
  "test_patch": "diff --git a/src/server/generic_family_test.cc b/src/server/generic_family_test.cc\nindex ed6587795618..ec947b11ef12 100644\n--- a/src/server/generic_family_test.cc\n+++ b/src/server/generic_family_test.cc\n@@ -145,6 +145,218 @@ TEST_F(GenericFamilyTest, ExpireOptions) {\n   EXPECT_THAT(resp.GetInt(), 101);\n }\n \n+TEST_F(GenericFamilyTest, ExpireAtOptions) {\n+  auto test_time_ms = TEST_current_time_ms;\n+  auto time_s = (test_time_ms + 500) / 1000;\n+  auto test_time_s = time_s;\n+\n+  Run({\"set\", \"key\", \"val\"});\n+  // NX and XX are mutually exclusive\n+  auto resp = Run({\"expireat\", \"key\", \"3600\", \"NX\", \"XX\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // NX and GT are mutually exclusive\n+  resp = Run({\"expireat\", \"key\", \"3600\", \"NX\", \"GT\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // NX and LT are mutually exclusive\n+  resp = Run({\"expireat\", \"key\", \"3600\", \"NX\", \"LT\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // GT and LT are mutually exclusive\n+  resp = Run({\"expireat\", \"key\", \"3600\", \"GT\", \"LT\"});\n+  ASSERT_THAT(resp, ErrArg(\"GT and LT options at the same time are not compatible\"));\n+\n+  // NX option should be added since there is no expiry\n+  test_time_s = time_s + 5;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(test_time_s), \"NX\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  EXPECT_EQ(test_time_s, CheckedInt({\"EXPIRETIME\", \"key\"}));\n+\n+  // running again with NX option, should not change expiry\n+  test_time_s = time_s + 9;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(test_time_s), \"NX\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // given a key with no expiry\n+  Run({\"set\", \"key2\", \"val\"});\n+  test_time_s = time_s + 9;\n+  resp = Run({\"expireat\", \"key2\", absl::StrCat(test_time_s), \"XX\"});\n+  // XX does not apply expiry since key has no existing expiry\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"ttl\", \"key2\"});\n+  EXPECT_THAT(resp.GetInt(), -1);\n+\n+  // set expiry to 101\n+  test_time_s = time_s + 101;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(test_time_s)});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  // GT should not apply expiry since new is not greater than the current one\n+  auto less_test_time_s = time_s + 99;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(less_test_time_s), \"GT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  EXPECT_EQ(test_time_s, CheckedInt({\"EXPIRETIME\", \"key\"}));\n+\n+  // GT should apply expiry since new is greater than the current one\n+  test_time_s = time_s + 105;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(test_time_s), \"GT\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  EXPECT_EQ(test_time_s, CheckedInt({\"EXPIRETIME\", \"key\"}));\n+\n+  // LT should apply new expiry is smaller than current\n+  test_time_s = time_s + 101;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(test_time_s), \"LT\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  EXPECT_EQ(test_time_s, CheckedInt({\"EXPIRETIME\", \"key\"}));\n+\n+  // LT should not apply expiry since new is not lesser than the current one\n+  auto gt_test_time_s = time_s + 102;\n+  resp = Run({\"expireat\", \"key\", absl::StrCat(gt_test_time_s), \"LT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  EXPECT_EQ(test_time_s, CheckedInt({\"EXPIRETIME\", \"key\"}));\n+}\n+\n+TEST_F(GenericFamilyTest, PExpireOptions) {\n+  // NX and XX are mutually exclusive\n+  Run({\"set\", \"key\", \"val\"});\n+  auto resp = Run({\"pexpire\", \"key\", \"3600\", \"NX\", \"XX\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // NX and GT are mutually exclusive\n+  resp = Run({\"pexpire\", \"key\", \"3600\", \"NX\", \"GT\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // NX and LT are mutually exclusive\n+  resp = Run({\"pexpire\", \"key\", \"3600\", \"NX\", \"LT\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // GT and LT are mutually exclusive\n+  resp = Run({\"pexpire\", \"key\", \"3600\", \"GT\", \"LT\"});\n+  ASSERT_THAT(resp, ErrArg(\"GT and LT options at the same time are not compatible\"));\n+\n+  // NX option should be added since there is no expiry\n+  resp = Run({\"pexpire\", \"key\", \"3600000\", \"NX\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"pttl\", \"key\"});\n+  EXPECT_THAT(resp.GetInt(), 3600000);\n+\n+  // running again with NX option, should not change expiry\n+  resp = Run({\"pexpire\", \"key\", \"42\", \"NX\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // given a key with no expiry\n+  Run({\"set\", \"key2\", \"val\"});\n+  resp = Run({\"pexpire\", \"key2\", \"404\", \"XX\"});\n+  // XX does not apply expiry since key has no existing expiry\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"pttl\", \"key2\"});\n+  EXPECT_THAT(resp.GetInt(), -1);\n+\n+  // set expiry to 101\n+  resp = Run({\"pexpire\", \"key\", \"101000\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  // GT should not apply expiry since new is not greater than the current one\n+  resp = Run({\"pexpire\", \"key\", \"100000\", \"GT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"pttl\", \"key\"});\n+  EXPECT_THAT(resp.GetInt(), 101000);\n+\n+  // GT should apply expiry since new is greater than the current one\n+  resp = Run({\"pexpire\", \"key\", \"102000\", \"GT\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"pttl\", \"key\"});\n+  EXPECT_THAT(resp.GetInt(), 102000);\n+\n+  // GT should not apply since expiry is smaller than current\n+  resp = Run({\"pexpire\", \"key\", \"101000\", \"GT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"pttl\", \"key\"});\n+  EXPECT_THAT(resp.GetInt(), 102000);\n+\n+  // LT should apply new expiry is smaller than current\n+  resp = Run({\"pexpire\", \"key\", \"101000\", \"LT\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  resp = Run({\"pttl\", \"key\"});\n+  EXPECT_THAT(resp.GetInt(), 101000);\n+\n+  // LT should not apply since expiry is greater than current\n+  resp = Run({\"pexpire\", \"key\", \"102000\", \"LT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"pttl\", \"key\"});\n+  EXPECT_THAT(resp.GetInt(), 101000);\n+}\n+\n+TEST_F(GenericFamilyTest, PExpireAtOptions) {\n+  auto test_time_ms = TEST_current_time_ms;\n+  Run({\"set\", \"key\", \"val\"});\n+  // NX and XX are mutually exclusive\n+  auto resp = Run({\"pexpireat\", \"key\", \"3600\", \"NX\", \"XX\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // NX and GT are mutually exclusive\n+  resp = Run({\"pexpireat\", \"key\", \"3600\", \"NX\", \"GT\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // NX and LT are mutually exclusive\n+  resp = Run({\"pexpireat\", \"key\", \"3600\", \"NX\", \"LT\"});\n+  ASSERT_THAT(resp, ErrArg(\"NX and XX, GT or LT options at the same time are not compatible\"));\n+\n+  // GT and LT are mutually exclusive\n+  resp = Run({\"pexpireat\", \"key\", \"3600\", \"GT\", \"LT\"});\n+  ASSERT_THAT(resp, ErrArg(\"GT and LT options at the same time are not compatible\"));\n+\n+  // NX option should be added since there is no expiry\n+  test_time_ms = TEST_current_time_ms + 3600;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(test_time_ms), \"NX\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  EXPECT_EQ(test_time_ms, CheckedInt({\"PEXPIRETIME\", \"key\"}));\n+\n+  // running again with NX option, should not change expiry\n+  test_time_ms = TEST_current_time_ms + 42000;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(test_time_ms), \"NX\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+\n+  // given a key with no expiry\n+  Run({\"set\", \"key2\", \"val\"});\n+  test_time_ms = TEST_current_time_ms + 404;\n+  resp = Run({\"pexpireat\", \"key2\", absl::StrCat(test_time_ms), \"XX\"});\n+  // XX does not apply expiry since key has no existing expiry\n+  EXPECT_THAT(resp, IntArg(0));\n+  resp = Run({\"ttl\", \"key2\"});\n+  EXPECT_THAT(resp.GetInt(), -1);\n+\n+  // set expiry to 101\n+  test_time_ms = TEST_current_time_ms + 101;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(test_time_ms)});\n+  EXPECT_THAT(resp, IntArg(1));\n+\n+  // GT should not apply expiry since new is not greater than the current one\n+  auto less_test_time_ms = TEST_current_time_ms + 100;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(less_test_time_ms), \"GT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  EXPECT_EQ(test_time_ms, CheckedInt({\"PEXPIRETIME\", \"key\"}));\n+\n+  // GT should apply expiry since new is greater than the current one\n+  test_time_ms = TEST_current_time_ms + 105;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(test_time_ms), \"GT\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  EXPECT_EQ(test_time_ms, CheckedInt({\"PEXPIRETIME\", \"key\"}));\n+\n+  // LT should apply new expiry is smaller than current\n+  test_time_ms = TEST_current_time_ms + 101;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(test_time_ms), \"LT\"});\n+  EXPECT_THAT(resp, IntArg(1));\n+  EXPECT_EQ(test_time_ms, CheckedInt({\"PEXPIRETIME\", \"key\"}));\n+\n+  // LT should not apply expiry since new is not lesser than the current one\n+  auto gt_test_time_ms = TEST_current_time_ms + 102;\n+  resp = Run({\"pexpireat\", \"key\", absl::StrCat(gt_test_time_ms), \"LT\"});\n+  EXPECT_THAT(resp, IntArg(0));\n+  EXPECT_EQ(test_time_ms, CheckedInt({\"PEXPIRETIME\", \"key\"}));\n+}\n+\n TEST_F(GenericFamilyTest, Del) {\n   for (size_t i = 0; i < 1000; ++i) {\n     Run({\"set\", StrCat(\"foo\", i), \"1\"});\n",
  "problem_statement": "EXPIREAT, PEXPIRE, and PEXPIREAT commands do not support optional flags [NX | XX | GT | LT]\nRelates to #842 and #2051\n\nThe intent of the above referenced issue and PR appears to have been to add support for expiry options to _all_ Redis commands that support them. However, these options were only implemented for `EXPIRE`:\n\n```\n> expire foo 2000 NX\n0\n> expireat foo 2000 NX\nERR wrong number of arguments for 'expireat' command\n> pexpire foo 2000 NX\nERR wrong number of arguments for 'pexpire' command\n> pexpireat foo 2000 NX\nERR wrong number of arguments for 'pexpireat' command\n```\n\nEnvironment:\n```\nredis_version: 7.4.0\ndragonfly_version: df-v1.27.3\n```\n\n\nAdditionally, the documentation for [`EXPIRE`](https://www.dragonflydb.io/docs/command-reference/generic/expire) was not updated to include those options. \n",
  "hints_text": "Can I work on this ?\nSure\nHey @guozhihao-224 I forgot to add it here but I already created a fix for this. Shall I add a PR is you are fine with it?",
  "created_at": "2025-04-26T08:48:04Z",
  "modified_files": [
    "src/server/generic_family.cc"
  ],
  "modified_test_files": [
    "src/server/generic_family_test.cc"
  ]
}