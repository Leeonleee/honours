{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3827,
  "instance_id": "dragonflydb__dragonfly-3827",
  "issue_numbers": [
    "3806"
  ],
  "base_commit": "b19f72201194aceb95d70f4192b4f87416e2317b",
  "patch": "diff --git a/src/redis/listpack.h b/src/redis/listpack.h\nindex d6b7f20e1f57..bba86ef63707 100644\n--- a/src/redis/listpack.h\n+++ b/src/redis/listpack.h\n@@ -76,6 +76,7 @@ unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf);\n \n // Fills count and returns 1 if the item is an integer, 0 otherwise.\n int lpGetInteger(unsigned char *p, int64_t *ival);\n+int lpStringToInt64(const char *s, unsigned long slen, int64_t *value);\n \n unsigned char *lpGetValue(unsigned char *p, unsigned int *slen, long long *lval);\n unsigned char *lpFind(unsigned char *lp, unsigned char *p, unsigned char *s, uint32_t slen, unsigned int skip);\ndiff --git a/src/redis/quicklist.c b/src/redis/quicklist.c\nindex aa860f245771..28fd439eb62a 100644\n--- a/src/redis/quicklist.c\n+++ b/src/redis/quicklist.c\n@@ -1184,14 +1184,6 @@ int quicklistDelRange(quicklist *quicklist, const long start, const long count)\n     return 1;\n }\n \n-/* compare between a two entries */\n-int quicklistCompare(const quicklistEntry* entry, const unsigned char *p2, const size_t p2_len) {\n-    if (unlikely(QL_NODE_IS_PLAIN(entry->node))) {\n-        return ((entry->sz == p2_len) && (memcmp(entry->value, p2, p2_len) == 0));\n-    }\n-    return lpCompare(entry->zi, p2, p2_len);\n-}\n-\n /* Returns a quicklist iterator 'iter'. After the initialization every\n  * call to quicklistNext() will return the next element of the quicklist. */\n quicklistIter *quicklistGetIterator(quicklist *quicklist, int direction) {\ndiff --git a/src/redis/quicklist.h b/src/redis/quicklist.h\nindex b1c01a2b93fa..e117226ac933 100644\n--- a/src/redis/quicklist.h\n+++ b/src/redis/quicklist.h\n@@ -186,7 +186,6 @@ int quicklistPopCustom(quicklist *quicklist,\n                        void *(*saver)(unsigned char *data, size_t sz));\n int quicklistPop(quicklist *quicklist, int where, unsigned char **data, size_t *sz, long long *slong);\n unsigned long quicklistCount(const quicklist *ql);\n-int quicklistCompare(const quicklistEntry *entry, const unsigned char *p2, const size_t p2_len);\n size_t quicklistGetLzf(const quicklistNode *node, void **data);\n void quicklistNodeLimit(int fill, size_t *size, unsigned int *count);\n int quicklistNodeExceedsLimit(int fill, size_t new_sz, unsigned int new_count);\ndiff --git a/src/server/list_family.cc b/src/server/list_family.cc\nindex 7fddc7062e2d..2f2ffb216b26 100644\n--- a/src/server/list_family.cc\n+++ b/src/server/list_family.cc\n@@ -547,10 +547,20 @@ OpResult<uint32_t> OpRem(const OpArgs& op_args, string_view key, string_view ele\n   quicklistInitIterator(&qiter, ql, iter_direction, index);\n   quicklistEntry entry;\n   unsigned removed = 0;\n-  const uint8_t* elem_ptr = reinterpret_cast<const uint8_t*>(elem.data());\n+  int64_t ival;\n+\n+  // try parsing the element into an integer.\n+  int is_int = lpStringToInt64(elem.data(), elem.size(), &ival);\n+\n+  auto is_match = [&](const quicklistEntry& entry) {\n+    if (is_int != (entry.value == nullptr))\n+      return false;\n+\n+    return is_int ? entry.longval == ival : ElemCompare(entry, elem);\n+  };\n \n   while (quicklistNext(&qiter, &entry)) {\n-    if (quicklistCompare(&entry, elem_ptr, elem.size())) {\n+    if (is_match(entry)) {\n       quicklistDelEntry(&qiter, &entry);\n       removed++;\n       if (count && removed == count)\n",
  "test_patch": "diff --git a/src/server/list_family_test.cc b/src/server/list_family_test.cc\nindex a70729d8ad06..6abecf6a5d51 100644\n--- a/src/server/list_family_test.cc\n+++ b/src/server/list_family_test.cc\n@@ -370,6 +370,13 @@ TEST_F(ListFamilyTest, LRem) {\n   Run({\"set\", \"foo\", \"bar\"});\n   ASSERT_THAT(Run({\"lrem\", \"foo\", \"0\", \"elem\"}), ErrArg(\"WRONGTYPE\"));\n   ASSERT_THAT(Run({\"lrem\", \"nexists\", \"0\", \"elem\"}), IntArg(0));\n+\n+  // Triggers QUICKLIST_NODE_CONTAINER_PLAIN coverage\n+  string val(10000, 'a');\n+  Run({\"rpush\", kKey2, val, \"12345678\"});\n+\n+  ASSERT_THAT(Run({\"lrem\", kKey2, \"1\", \"12345678\"}), IntArg(1));\n+  ASSERT_THAT(Run({\"lrem\", kKey2, \"1\", val}), IntArg(1));\n }\n \n TEST_F(ListFamilyTest, LTrim) {\n",
  "problem_statement": "optimize OpRem\nbullmq once overloaded has long lists and then it does something like that\r\n`\"LREM\" \"bull:{job_queue}:active\" \"-1\" \"29207431\" `\r\n\r\n![image](https://github.com/user-attachments/assets/78a1e078-91b1-4816-9293-7cf9014b733f)\r\n\r\n\n",
  "hints_text": "Seems that both `lpStringToInt64` and `ll2string` can be replaced by highly optimized code in abseil: `SimpleAtoi` and `FastIntToBuffer`\r\n\r\nbut we should also benchmark both functions to see if lpCompare should really use `SimpleAtoi` or `FastIntToBuffer`\r\n",
  "created_at": "2024-09-30T08:09:01Z",
  "modified_files": [
    "src/redis/listpack.h",
    "src/redis/quicklist.c",
    "src/redis/quicklist.h",
    "src/server/list_family.cc"
  ],
  "modified_test_files": [
    "src/server/list_family_test.cc"
  ]
}