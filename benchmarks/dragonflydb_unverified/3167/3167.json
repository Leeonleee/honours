{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 3167,
  "instance_id": "dragonflydb__dragonfly-3167",
  "issue_numbers": [
    "2021"
  ],
  "base_commit": "a9ffb223847f5677165df0932fc201982e02ab87",
  "patch": "diff --git a/src/server/command_registry.cc b/src/server/command_registry.cc\nindex 82548d8d8488..e96008d9f043 100644\n--- a/src/server/command_registry.cc\n+++ b/src/server/command_registry.cc\n@@ -78,8 +78,10 @@ optional<facade::ErrorReply> CommandId::Validate(CmdArgList tail_args) const {\n     return facade::ErrorReply{facade::WrongNumArgsError(name()), kSyntaxErrType};\n   }\n \n-  if ((opt_mask() & CO::INTERLEAVED_KEYS) && (tail_args.size() % 2) != 0) {\n-    return facade::ErrorReply{facade::WrongNumArgsError(name()), kSyntaxErrType};\n+  if ((opt_mask() & CO::INTERLEAVED_KEYS)) {\n+    if ((name() == \"JSON.MSET\" && tail_args.size() % 3 != 0) ||\n+        (name() == \"MSET\" && tail_args.size() % 2 != 0))\n+      return facade::ErrorReply{facade::WrongNumArgsError(name()), kSyntaxErrType};\n   }\n \n   if (validator_)\ndiff --git a/src/server/json_family.cc b/src/server/json_family.cc\nindex 3b02c64baa3d..f12b4a723a0e 100644\n--- a/src/server/json_family.cc\n+++ b/src/server/json_family.cc\n@@ -23,6 +23,7 @@\n #include \"facade/op_status.h\"\n #include \"server/acl/acl_commands_def.h\"\n #include \"server/command_registry.h\"\n+#include \"server/common.h\"\n #include \"server/error.h\"\n #include \"server/journal/journal.h\"\n #include \"server/search/doc_index.h\"\n@@ -1129,7 +1130,8 @@ OpResult<vector<OptLong>> OpArrIndex(const OpArgs& op_args, string_view key, Jso\n }\n \n // Returns string vector that represents the query result of each supplied key.\n-vector<OptString> OpJsonMGet(JsonPathV2 expression, const Transaction* t, EngineShard* shard) {\n+vector<OptString> OpJsonMGet(const JsonPathV2& expression, const Transaction* t,\n+                             EngineShard* shard) {\n   ShardArgs args = t->GetShardArgs(shard->shard_id());\n   DCHECK(!args.Empty());\n   vector<OptString> response(args.Size());\n@@ -1289,6 +1291,40 @@ OpResult<bool> OpSet(const OpArgs& op_args, string_view key, string_view path,\n   return operation_result;\n }\n \n+OpStatus OpMSet(const OpArgs& op_args, const ShardArgs& args) {\n+  DCHECK_EQ(args.Size() % 3, 0u);\n+\n+  OpStatus result = OpStatus::OK;\n+  size_t stored = 0;\n+  for (auto it = args.begin(); it != args.end();) {\n+    string_view key = *(it++);\n+    string_view path = *(it++);\n+    string_view value = *(it++);\n+    if (auto res = OpSet(op_args, key, path, value, false, false); !res.ok()) {\n+      result = res.status();\n+      break;\n+    }\n+\n+    stored++;\n+  }\n+\n+  // Replicate custom journal, see OpMSet\n+  if (auto journal = op_args.shard->journal(); journal) {\n+    if (stored * 3 == args.Size()) {\n+      RecordJournal(op_args, \"JSON.MSET\", args, op_args.tx->GetUniqueShardCnt());\n+      DCHECK_EQ(result, OpStatus::OK);\n+      return result;\n+    }\n+\n+    string_view cmd = stored == 0 ? \"PING\" : \"JSON.MSET\";\n+    vector<string_view> store_args(args.begin(), args.end());\n+    store_args.resize(stored * 3);\n+    RecordJournal(op_args, cmd, store_args, op_args.tx->GetUniqueShardCnt());\n+  }\n+\n+  return result;\n+}\n+\n // Implements the recursive algorithm from\n // https://datatracker.ietf.org/doc/html/rfc7386#section-2\n void RecursiveMerge(const JsonType& patch, JsonType* dest) {\n@@ -1414,16 +1450,19 @@ void JsonFamily::MSet(CmdArgList args, ConnectionContext* cntx) {\n     return cntx->SendError(facade::WrongNumArgsError(\"json.mset\"));\n   }\n \n-  return cntx->SendError(\"Not implemented\");\n-\n-  auto cb = [&](Transaction* t, EngineShard* shard) {\n+  AggregateStatus status;\n+  auto cb = [&status](Transaction* t, EngineShard* shard) {\n+    auto op_args = t->GetOpArgs(shard);\n     ShardArgs args = t->GetShardArgs(shard->shard_id());\n-    (void)args;  // TBD\n+    if (auto result = OpMSet(op_args, args); result != OpStatus::OK)\n+      status = result;\n     return OpStatus::OK;\n   };\n \n-  Transaction* trans = cntx->transaction;\n-  trans->ScheduleSingleHop(cb);\n+  cntx->transaction->ScheduleSingleHop(cb);\n+\n+  if (*status != OpStatus::OK)\n+    return cntx->SendError(*status);\n   cntx->SendOk();\n }\n \n@@ -1530,7 +1569,7 @@ void JsonFamily::MGet(CmdArgList args, ConnectionContext* cntx) {\n \n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     ShardId sid = shard->shard_id();\n-    mget_resp[sid] = OpJsonMGet(*ParseJsonPath(path), t, shard);\n+    mget_resp[sid] = OpJsonMGet(expression, t, shard);\n     return OpStatus::OK;\n   };\n \ndiff --git a/src/server/string_family.cc b/src/server/string_family.cc\nindex 53d7d8fe9cd7..9772e188a649 100644\n--- a/src/server/string_family.cc\n+++ b/src/server/string_family.cc\n@@ -263,54 +263,43 @@ int64_t AbsExpiryToTtl(int64_t abs_expiry_time, bool as_milli) {\n }\n \n // Returns true if keys were set, false otherwise.\n-void OpMSet(const OpArgs& op_args, const ShardArgs& args, atomic_bool* success) {\n+OpStatus OpMSet(const OpArgs& op_args, const ShardArgs& args) {\n   DCHECK(!args.Empty() && args.Size() % 2 == 0);\n \n   SetCmd::SetParams params;\n   SetCmd sg(op_args, false);\n \n-  size_t index = 0;\n-  bool partial = false;\n-  for (auto it = args.begin(); it != args.end(); ++it) {\n-    string_view key = *it;\n-    ++it;\n-    string_view value = *it;\n-    DVLOG(1) << \"MSet \" << key << \":\" << value;\n-    if (sg.Set(params, key, value) != OpStatus::OK) {  // OOM for example.\n-      success->store(false);\n-      partial = true;\n+  OpStatus result = OpStatus::OK;\n+  size_t stored = 0;\n+  for (auto it = args.begin(); it != args.end();) {\n+    string_view key = *(it++);\n+    string_view value = *(it++);\n+    if (auto status = sg.Set(params, key, value); status != OpStatus::OK) {\n+      result = status;\n       break;\n     }\n-    index += 2;\n+\n+    stored++;\n   }\n \n+  // Above loop could have parial success (e.g. OOM), so replicate only what was\n+  // changed\n   if (auto journal = op_args.shard->journal(); journal) {\n-    // We write a custom journal because an OOM in the above loop could lead to partial success, so\n-    // we replicate only what was changed.\n-    if (partial) {\n-      string_view cmd;\n-      ArgSlice cmd_args;\n-      vector<string_view> store_args(index);\n-      if (index == 0) {\n-        // All shards must record the tx was executed for the replica to execute it, so we send a\n-        // PING in case nothing was changed\n-        cmd = \"PING\";\n-      } else {\n-        // journal [0, i)\n-        cmd = \"MSET\";\n-        unsigned i = 0;\n-        for (string_view arg : args) {\n-          store_args[i++] = arg;\n-          if (i >= store_args.size())\n-            break;\n-        }\n-        cmd_args = absl::MakeSpan(store_args);\n-      }\n-      RecordJournal(op_args, cmd, cmd_args, op_args.tx->GetUniqueShardCnt());\n-    } else {\n+    if (stored * 2 == args.Size()) {\n       RecordJournal(op_args, \"MSET\", args, op_args.tx->GetUniqueShardCnt());\n+      DCHECK_EQ(result, OpStatus::OK);\n+      return result;\n     }\n+\n+    // Even without changes, we have to send a dummy command like PING for the\n+    // replica to ack\n+    string_view cmd = stored == 0 ? \"PING\" : \"MSET\";\n+    vector<string_view> store_args(args.begin(), args.end());\n+    store_args.resize(stored * 2);\n+    RecordJournal(op_args, cmd, store_args, op_args.tx->GetUniqueShardCnt());\n   }\n+\n+  return result;\n }\n \n // emission_interval_ms assumed to be positive\n@@ -451,7 +440,8 @@ SinkReplyBuilder::MGetResponse OpMGet(util::fb2::BlockingCounter wait_bc, bool f\n \n     auto& resp = response.resp_arr[i].emplace();\n \n-    // Copy to buffer or trigger tiered read that will eventually write to buffer\n+    // Copy to buffer or trigger tiered read that will eventually write to\n+    // buffer\n     if (it->second.IsExternal()) {\n       wait_bc->Add(1);\n       auto cb = [next, wait_bc](const string& v) mutable {\n@@ -481,7 +471,8 @@ SinkReplyBuilder::MGetResponse OpMGet(util::fb2::BlockingCounter wait_bc, bool f\n   return response;\n }\n \n-// Extend key with value, either prepend or append. Return size of stored string after modification\n+// Extend key with value, either prepend or append. Return size of stored string\n+// after modification\n OpResult<variant<size_t, util::fb2::Future<size_t>>> OpExtend(const OpArgs& op_args,\n                                                               std::string_view key,\n                                                               std::string_view value,\n@@ -761,13 +752,15 @@ void StringFamily::Set(CmdArgList args, ConnectionContext* cntx) {\n \n       bool is_ms = (opt[0] == 'P');\n \n-      // for []AT we need to take expiration time as absolute from the value given\n-      // check here and if the time is in the past, return OK but don't set it\n-      // Note that the time pass here for PXAT is in milliseconds, we must not change it!\n+      // for []AT we need to take expiration time as absolute from the value\n+      // given check here and if the time is in the past, return OK but don't\n+      // set it Note that the time pass here for PXAT is in milliseconds, we\n+      // must not change it!\n       if (absl::EndsWith(opt, \"AT\")) {\n         int_arg = AbsExpiryToTtl(int_arg, is_ms);\n         if (int_arg < 0) {\n-          // this happened in the past, just return, for some reason Redis reports OK in this case\n+          // this happened in the past, just return, for some reason Redis\n+          // reports OK in this case\n           return builder->SendStored();\n         }\n       }\n@@ -843,7 +836,8 @@ void StringFamily::SetNx(CmdArgList args, ConnectionContext* cntx) {\n   // This is the same as calling the \"Set\" function, only in this case we are\n   // change the value only if the key does not exist. Otherwise the function\n   // will not modify it. in which case it would return 0\n-  // it would return to the caller 1 in case the key did not exists and was added\n+  // it would return to the caller 1 in case the key did not exists and was\n+  // added\n   string_view key = ArgS(args, 0);\n   string_view value = ArgS(args, 1);\n \n@@ -1168,7 +1162,8 @@ void StringFamily::MGet(CmdArgList args, ConnectionContext* cntx) {\n   // wait for all tiered reads to finish\n   tiering_bc->Wait();\n \n-  // reorder the responses back according to the order of their corresponding keys.\n+  // reorder the responses back according to the order of their corresponding\n+  // keys.\n   SinkReplyBuilder::MGetResponse res(args.size());\n \n   for (ShardId sid = 0; sid < mget_resp.size(); ++sid) {\n@@ -1208,18 +1203,21 @@ void StringFamily::MSet(CmdArgList args, ConnectionContext* cntx) {\n     LOG(INFO) << \"MSET/\" << transaction->GetUniqueShardCnt() << str;\n   }\n \n-  atomic_bool success = true;\n+  AggregateStatus result;\n   auto cb = [&](Transaction* t, EngineShard* shard) {\n     ShardArgs args = t->GetShardArgs(shard->shard_id());\n-    OpMSet(t->GetOpArgs(shard), args, &success);\n+    if (auto status = OpMSet(t->GetOpArgs(shard), args); status != OpStatus::OK)\n+      result = status;\n     return OpStatus::OK;\n   };\n \n-  OpStatus status = transaction->ScheduleSingleHop(std::move(cb));\n-  if (success.load()) {\n+  if (auto status = transaction->ScheduleSingleHop(std::move(cb)); status != OpStatus::OK)\n+    result = status;\n+\n+  if (*result == OpStatus::OK) {\n     cntx->SendOk();\n   } else {\n-    cntx->SendError(status);\n+    cntx->SendError(*result);\n   }\n }\n \n@@ -1245,18 +1243,19 @@ void StringFamily::MSetNx(CmdArgList args, ConnectionContext* cntx) {\n   transaction->Execute(std::move(cb), false);\n   const bool to_skip = exists.load(memory_order_relaxed);\n \n-  atomic_bool success = true;\n+  AggregateStatus result;\n   auto epilog_cb = [&](Transaction* t, EngineShard* shard) {\n     if (to_skip)\n       return OpStatus::OK;\n \n     auto args = t->GetShardArgs(shard->shard_id());\n-    OpMSet(t->GetOpArgs(shard), std::move(args), &success);\n+    if (auto status = OpMSet(t->GetOpArgs(shard), args); status != OpStatus::OK)\n+      result = status;\n     return OpStatus::OK;\n   };\n   transaction->Execute(std::move(epilog_cb), true);\n \n-  cntx->SendLong(to_skip || !success.load() ? 0 : 1);\n+  cntx->SendLong(to_skip || (*result != OpStatus::OK) ? 0 : 1);\n }\n \n void StringFamily::StrLen(CmdArgList args, ConnectionContext* cntx) {\n@@ -1343,13 +1342,13 @@ void StringFamily::SetRange(CmdArgList args, ConnectionContext* cntx) {\n  *  1. Whether the action was limited:\n  *   - 0 indicates the action is allowed.\n  *   - 1 indicates that the action was limited/blocked.\n- *  2. The total limit of the key (max_burst + 1). This is equivalent to the common\n- * X-RateLimit-Limit HTTP header.\n+ *  2. The total limit of the key (max_burst + 1). This is equivalent to the\n+ * common X-RateLimit-Limit HTTP header.\n  *  3. The remaining limit of the key. Equivalent to X-RateLimit-Remaining.\n- *  4. The number of seconds until the user should retry, and always -1 if the action was allowed.\n- * Equivalent to Retry-After.\n- *  5. The number of seconds until the limit will reset to its maximum capacity. Equivalent to\n- * X-RateLimit-Reset.\n+ *  4. The number of seconds until the user should retry, and always -1 if the\n+ * action was allowed. Equivalent to Retry-After.\n+ *  5. The number of seconds until the limit will reset to its maximum capacity.\n+ * Equivalent to X-RateLimit-Reset.\n  */\n void StringFamily::ClThrottle(CmdArgList args, ConnectionContext* cntx) {\n   const string_view key = ArgS(args, 0);\ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex f0be75cb89c9..6bac7448528e 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -312,7 +312,7 @@ void Transaction::InitByKeys(const KeyIndex& key_index) {\n   }\n \n   shard_data_.resize(shard_set->size());  // shard_data isn't sparse, so we must allocate for all :(\n-  DCHECK_EQ(full_args_.size() % key_index.step, 0u);\n+  DCHECK_EQ(full_args_.size() % key_index.step, 0u) << full_args_;\n \n   // Safe, because flow below is not preemptive.\n   auto& shard_index = tmp_space.GetShardIndex(shard_data_.size());\ndiff --git a/src/server/tx_base.h b/src/server/tx_base.h\nindex 02f4f057b627..5410221f2187 100644\n--- a/src/server/tx_base.h\n+++ b/src/server/tx_base.h\n@@ -153,6 +153,12 @@ class ShardArgs {\n       return *this;\n     }\n \n+    Iterator operator++(int) {\n+      Iterator copy = *this;\n+      operator++();\n+      return copy;\n+    }\n+\n     size_t index() const {\n       return index_it_->first + delta_;\n     }\n",
  "test_patch": "diff --git a/src/server/json_family_test.cc b/src/server/json_family_test.cc\nindex 6a09c9ac3edf..ed5cbe733ad0 100644\n--- a/src/server/json_family_test.cc\n+++ b/src/server/json_family_test.cc\n@@ -952,6 +952,9 @@ TEST_F(JsonFamilyTest, MGet) {\n   resp = Run({\"JSON.SET\", \"json2\", \".\", json[1]});\n   ASSERT_THAT(resp, \"OK\");\n \n+  resp = Run({\"JSON.MGET\", \"json1\", \"??INNNNVALID??\"});\n+  EXPECT_THAT(resp, ErrArg(\"Unknown token\"));\n+\n   resp = Run({\"JSON.MGET\", \"json1\", \"json2\", \"json3\", \"$.address.country\"});\n   ASSERT_EQ(RespExpr::ARRAY, resp.type);\n   EXPECT_THAT(resp.GetVec(),\n@@ -1082,18 +1085,20 @@ TEST_F(JsonFamilyTest, Set) {\n }\n \n TEST_F(JsonFamilyTest, MSet) {\n-  GTEST_SKIP() << \"Not implemented\";\n-  string json = R\"(\n-    {\"a\":{\"a\":1, \"b\":2, \"c\":3}}\n-  )\";\n+  string json1 = R\"({\"a\":{\"a\":1,\"b\":2,\"c\":3}})\";\n+  string json2 = R\"({\"a\":{\"a\":4,\"b\":5,\"c\":6}})\";\n \n   auto resp = Run({\"JSON.MSET\", \"j1\", \"$\"});\n   EXPECT_THAT(resp, ErrArg(\"wrong number\"));\n-  resp = Run({\"JSON.MSET\", \"j1\", \"$\", json, \"j3\", \"$\"});\n+  resp = Run({\"JSON.MSET\", \"j1\", \"$\", json1, \"j3\", \"$\"});\n   EXPECT_THAT(resp, ErrArg(\"wrong number\"));\n \n-  resp = Run({\"JSON.MSET\", \"j1\", \"$\", json, \"j3\", \"$\", json});\n+  resp = Run({\"JSON.MSET\", \"j1\", \"$\", json1, \"j2\", \"$\", json2, \"j3\", \"$\", json1, \"j4\", \"$\", json2});\n   EXPECT_EQ(resp, \"OK\");\n+\n+  resp = Run({\"JSON.MGET\", \"j1\", \"j2\", \"j3\", \"j4\", \"$\"});\n+  EXPECT_THAT(resp.GetVec(), ElementsAre(\"[\" + json1 + \"]\", \"[\" + json2 + \"]\", \"[\" + json1 + \"]\",\n+                                         \"[\" + json2 + \"]\"));\n }\n \n TEST_F(JsonFamilyTest, Merge) {\ndiff --git a/tests/dragonfly/utility.py b/tests/dragonfly/utility.py\nindex 8e2cfd61db1c..e20eba864ed6 100644\n--- a/tests/dragonfly/utility.py\n+++ b/tests/dragonfly/utility.py\n@@ -233,7 +233,7 @@ def gen_update_cmd(self):\n         ValueType.SET: \"SADD\",\n         ValueType.HSET: \"HMSET\",\n         ValueType.ZSET: \"ZADD\",\n-        ValueType.JSON: \"JSON.SET\",\n+        ValueType.JSON: \"JSON.MSET\",\n     }\n \n     def gen_grow_cmd(self):\n@@ -242,7 +242,7 @@ def gen_grow_cmd(self):\n         \"\"\"\n         # TODO: Implement COPY in Dragonfly.\n         t = self.random_type()\n-        if t == ValueType.STRING:\n+        if t in [ValueType.STRING, ValueType.JSON]:\n             count = random.randint(1, self.max_multikey)\n         else:\n             count = 1\n",
  "problem_statement": "Implement JSON.MSET\nimplementing JSON.MSET  https://redis.io/commands/json.mset/\r\n\r\n\n",
  "hints_text": "@dranikpg  Should be much simpler to implement with #3101 \r\nCan you please do it?\nOk",
  "created_at": "2024-06-12T09:52:27Z",
  "modified_files": [
    "src/server/command_registry.cc",
    "src/server/json_family.cc",
    "src/server/string_family.cc",
    "src/server/transaction.cc",
    "src/server/tx_base.h"
  ],
  "modified_test_files": [
    "src/server/json_family_test.cc",
    "tests/dragonfly/utility.py"
  ]
}