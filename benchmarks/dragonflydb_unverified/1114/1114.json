{
  "repo": "dragonflydb/dragonfly",
  "pull_number": 1114,
  "instance_id": "dragonflydb__dragonfly-1114",
  "issue_numbers": [
    "1040"
  ],
  "base_commit": "6632261a2deb997d6ba7edcae4181b4dbd4c266f",
  "patch": "diff --git a/src/server/command_registry.cc b/src/server/command_registry.cc\nindex 9315145f639d..1b8df89eaf73 100644\n--- a/src/server/command_registry.cc\n+++ b/src/server/command_registry.cc\n@@ -29,7 +29,7 @@ CommandId::CommandId(const char* name, uint32_t mask, int8_t arity, int8_t first\n }\n \n bool CommandId::IsTransactional() const {\n-  if (first_key_ > 0 || (opt_mask_ & CO::GLOBAL_TRANS))\n+  if (first_key_ > 0 || (opt_mask_ & CO::GLOBAL_TRANS) || (opt_mask_ & CO::NO_KEY_JOURNAL))\n     return true;\n \n   string_view name{name_};\n@@ -124,6 +124,8 @@ const char* OptName(CO::CommandOpt fl) {\n       return \"variadic-keys\";\n     case NO_AUTOJOURNAL:\n       return \"custom-journal\";\n+    case NO_KEY_JOURNAL:\n+      return \"no-key-journal\";\n   }\n   return \"unknown\";\n }\ndiff --git a/src/server/command_registry.h b/src/server/command_registry.h\nindex 6bc1ac7f7c0d..c7fdb2662aab 100644\n--- a/src/server/command_registry.h\n+++ b/src/server/command_registry.h\n@@ -34,6 +34,7 @@ enum CommandOpt : uint32_t {\n   GLOBAL_TRANS = 1U << 12,\n \n   NO_AUTOJOURNAL = 1U << 15,  // Skip automatically logging command to journal inside transaction.\n+  NO_KEY_JOURNAL = 1U << 16,  // Command with no keys that need to be journaled\n };\n \n const char* OptName(CommandOpt fl);\ndiff --git a/src/server/db_slice.cc b/src/server/db_slice.cc\nindex 28be929f59bc..0bd3b1adabbd 100644\n--- a/src/server/db_slice.cc\n+++ b/src/server/db_slice.cc\n@@ -674,6 +674,9 @@ size_t DbSlice::DbSize(DbIndex db_ind) const {\n }\n \n bool DbSlice::Acquire(IntentLock::Mode mode, const KeyLockArgs& lock_args) {\n+  if (lock_args.args.empty()) {\n+    return true;\n+  }\n   DCHECK_GT(lock_args.key_step, 0u);\n \n   auto& lt = db_arr_[lock_args.db_index]->trans_locks;\n@@ -700,6 +703,9 @@ bool DbSlice::Acquire(IntentLock::Mode mode, const KeyLockArgs& lock_args) {\n }\n \n void DbSlice::Release(IntentLock::Mode mode, const KeyLockArgs& lock_args) {\n+  if (lock_args.args.empty()) {\n+    return;\n+  }\n   DVLOG(2) << \"Release \" << IntentLock::ModeName(mode) << \" for \" << lock_args.args[0];\n   if (lock_args.args.size() == 1) {\n     Release(mode, lock_args.db_index, lock_args.args.front(), 1);\n@@ -729,7 +735,6 @@ bool DbSlice::CheckLock(IntentLock::Mode mode, DbIndex dbid, string_view key) co\n }\n \n bool DbSlice::CheckLock(IntentLock::Mode mode, const KeyLockArgs& lock_args) const {\n-  DCHECK(!lock_args.args.empty());\n   const auto& lt = db_arr_[lock_args.db_index]->trans_locks;\n   for (size_t i = 0; i < lock_args.args.size(); i += lock_args.key_step) {\n     auto s = lock_args.args[i];\ndiff --git a/src/server/script_mgr.cc b/src/server/script_mgr.cc\nindex 14a6f0282209..b1d6385a9469 100644\n--- a/src/server/script_mgr.cc\n+++ b/src/server/script_mgr.cc\n@@ -20,6 +20,7 @@\n #include \"facade/error.h\"\n #include \"server/engine_shard_set.h\"\n #include \"server/server_state.h\"\n+#include \"server/transaction.h\"\n \n ABSL_FLAG(std::string, default_lua_config, \"\",\n           \"Configure default mode for running Lua scripts: \\n - Use 'allow-undeclared-keys' to \"\n@@ -126,6 +127,10 @@ void ScriptMgr::LoadCmd(CmdArgList args, ConnectionContext* cntx) {\n   if (!res)\n     return (*cntx)->SendError(res.error().Format());\n \n+  // Schedule empty callback inorder to journal command via transaction framework.\n+  auto cb = [&](Transaction* t, EngineShard* shard) { return OpStatus::OK; };\n+\n+  cntx->transaction->ScheduleSingleHop(std::move(cb));\n   return (*cntx)->SendBulkString(res.value());\n }\n \ndiff --git a/src/server/server_family.cc b/src/server/server_family.cc\nindex 7836ed6b43b9..a449c06d1357 100644\n--- a/src/server/server_family.cc\n+++ b/src/server/server_family.cc\n@@ -2084,7 +2084,7 @@ void ServerFamily::Register(CommandRegistry* registry) {\n             << CI{\"REPLCONF\", CO::ADMIN | CO::LOADING, -1, 0, 0, 0}.HFUNC(ReplConf)\n             << CI{\"ROLE\", CO::LOADING | CO::FAST | CO::NOSCRIPT, 1, 0, 0, 0}.HFUNC(Role)\n             << CI{\"SLOWLOG\", CO::ADMIN | CO::FAST, -2, 0, 0, 0}.SetHandler(SlowLog)\n-            << CI{\"SCRIPT\", CO::NOSCRIPT, -2, 0, 0, 0}.HFUNC(Script)\n+            << CI{\"SCRIPT\", CO::NOSCRIPT | CO::NO_KEY_JOURNAL, -2, 0, 0, 0}.HFUNC(Script)\n             << CI{\"DFLY\", CO::ADMIN | CO::GLOBAL_TRANS, -2, 0, 0, 0}.HFUNC(Dfly);\n }\n \ndiff --git a/src/server/transaction.cc b/src/server/transaction.cc\nindex 99ac19770242..45d1e289d250 100644\n--- a/src/server/transaction.cc\n+++ b/src/server/transaction.cc\n@@ -83,6 +83,14 @@ void Transaction::InitGlobal() {\n     sd.local_mask = ACTIVE;\n }\n \n+void Transaction::InitNoKey() {\n+  // No key command will use the first shard.\n+  unique_shard_cnt_ = 1;\n+  unique_shard_id_ = 0;\n+  shard_data_.resize(1);\n+  shard_data_.front().local_mask |= ACTIVE;\n+}\n+\n void Transaction::BuildShardIndex(KeyIndex key_index, bool rev_mapping,\n                                   std::vector<PerShardCache>* out) {\n   auto args = full_args_;\n@@ -310,6 +318,11 @@ OpStatus Transaction::InitByArgs(DbIndex index, CmdArgList args) {\n     return OpStatus::OK;\n   }\n \n+  if ((cid_->opt_mask() & CO::NO_KEY_JOURNAL) > 0) {\n+    InitNoKey();\n+    return OpStatus::OK;\n+  }\n+\n   DCHECK_EQ(unique_shard_cnt_, 0u);\n   DCHECK(args_.empty());\n \n@@ -916,6 +929,7 @@ KeyLockArgs Transaction::GetLockArgs(ShardId sid) const {\n   res.db_index = db_index_;\n   res.key_step = cid_->key_arg_step();\n   res.args = GetShardArgs(sid);\n+  DCHECK(!res.args.empty() || (cid_->opt_mask() & CO::NO_KEY_JOURNAL));\n \n   return res;\n }\n@@ -947,6 +961,7 @@ bool Transaction::ScheduleUniqueShard(EngineShard* shard) {\n   sd.pq_pos = shard->txq()->Insert(this);\n \n   DCHECK_EQ(0, sd.local_mask & KEYLOCK_ACQUIRED);\n+\n   shard->db_slice().Acquire(mode, lock_args);\n   sd.local_mask |= KEYLOCK_ACQUIRED;\n \n@@ -1057,8 +1072,6 @@ bool Transaction::CancelShardCb(EngineShard* shard) {\n \n // runs in engine-shard thread.\n ArgSlice Transaction::GetShardArgs(ShardId sid) const {\n-  DCHECK(!args_.empty());\n-\n   // We can read unique_shard_cnt_  only because ShardArgsInShard is called after IsArmedInShard\n   // barrier.\n   if (unique_shard_cnt_ == 1) {\n@@ -1289,10 +1302,18 @@ void Transaction::LogAutoJournalOnShard(EngineShard* shard) {\n   if (multi_ && multi_->role == SQUASHER)\n     return;\n \n-  // Ignore non-write commands or ones with disabled autojournal.\n-  if ((cid_->opt_mask() & CO::WRITE) == 0 || ((cid_->opt_mask() & CO::NO_AUTOJOURNAL) > 0 &&\n-                                              !renabled_auto_journal_.load(memory_order_relaxed)))\n+  bool journal_by_cmd_mask = true;\n+  if ((cid_->opt_mask() & CO::NO_KEY_JOURNAL) > 0) {\n+    journal_by_cmd_mask = true;  // Enforce journaling for commands that dont change the db.\n+  } else if ((cid_->opt_mask() & CO::WRITE) == 0) {\n+    journal_by_cmd_mask = false;  // Non-write command are not journaled.\n+  } else if ((cid_->opt_mask() & CO::NO_AUTOJOURNAL) > 0 &&\n+             !renabled_auto_journal_.load(memory_order_relaxed)) {\n+    journal_by_cmd_mask = false;  // Command disabled auto journal.\n+  }\n+  if (!journal_by_cmd_mask) {\n     return;\n+  }\n \n   auto journal = shard->journal();\n   if (journal == nullptr)\ndiff --git a/src/server/transaction.h b/src/server/transaction.h\nindex 2331292ef751..68bb43a5de49 100644\n--- a/src/server/transaction.h\n+++ b/src/server/transaction.h\n@@ -389,6 +389,9 @@ class Transaction {\n   // Init as a global transaction.\n   void InitGlobal();\n \n+  // Init when command has no keys and it need to use transaction framework\n+  void InitNoKey();\n+\n   // Init with a set of keys.\n   void InitByKeys(KeyIndex keys);\n \n",
  "test_patch": "diff --git a/tests/dragonfly/replication_test.py b/tests/dragonfly/replication_test.py\nindex 62cb5035ae5e..5fef1fc29d78 100644\n--- a/tests/dragonfly/replication_test.py\n+++ b/tests/dragonfly/replication_test.py\n@@ -407,6 +407,7 @@ async def test_cancel_replication_immediately(df_local_factory, df_seeder_factor\n     await asyncio.gather(*(seeder.run(target_deviation=0.1) for seeder in seeders))\n \n     replication_commands = []\n+\n     async def replicate(index):\n         await asyncio.sleep(10.0 * random.random())\n         try:\n@@ -427,7 +428,6 @@ async def replicate(index):\n     assert COMMANDS_TO_ISSUE > num_successes, \"At least one REPLICAOF must be cancelled\"\n     assert num_successes > 0, \"At least one REPLICAOF must be succeed\"\n \n-\n     await c_replica.execute_command(f\"REPLICAOF localhost {masters[0].port}\")\n \n     capture = await seeders[0].capture()\n@@ -838,3 +838,39 @@ async def test_auth_master(df_local_factory, n_keys=20):\n     assert all(v is not None for v in res)\n     await c_master.connection_pool.disconnect()\n     await c_replica.connection_pool.disconnect()\n+\n+\n+SCRIPT_TEMPLATE = \"return {}\"\n+\n+\n+@dfly_args({\"proactor_threads\": 2})\n+async def test_script_transfer(df_local_factory):\n+    master = df_local_factory.create(port=BASE_PORT)\n+    replica = df_local_factory.create(port=BASE_PORT+1)\n+\n+    df_local_factory.start_all([master, replica])\n+\n+    c_master = aioredis.Redis(port=master.port)\n+    c_replica = aioredis.Redis(port=replica.port)\n+\n+    # Load some scripts into master ahead\n+    scripts = []\n+    for i in range(0, 10):\n+        sha = await c_master.script_load(SCRIPT_TEMPLATE.format(i))\n+        scripts.append(sha)\n+\n+    await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\")\n+    await wait_available_async(c_replica)\n+\n+    # transfer in stable state\n+    for i in range(10, 20):\n+        sha = await c_master.script_load(SCRIPT_TEMPLATE.format(i))\n+        scripts.append(sha)\n+\n+    await check_all_replicas_finished([c_replica], c_master)\n+    await c_replica.execute_command(\"REPLICAOF NO ONE\")\n+\n+    for i, sha in enumerate(scripts):\n+        assert await c_replica.evalsha(sha, 0) == i\n+    await c_master.connection_pool.disconnect()\n+    await c_replica.connection_pool.disconnect()\n",
  "problem_statement": "Scripts are not transferred in stable sync\n```py\r\n\r\n\r\n\r\nSCRIPT_TEMPLATE = \"return {}\"\r\n\r\n@dfly_args({\"proactor_threads\": 2})\r\nasync def test_script_transfer(df_local_factory):\r\n    master = df_local_factory.create(port=BASE_PORT)\r\n    replica = df_local_factory.create(port=BASE_PORT+1)\r\n\r\n    df_local_factory.start_all([master, replica])\r\n\r\n    c_master = aioredis.Redis(port=master.port)\r\n    c_replica = aioredis.Redis(port=replica.port)\r\n\r\n    # Load some scripts into master ahead\r\n    scripts = []\r\n    for i in range(0, 10):\r\n        sha = await c_master.script_load(SCRIPT_TEMPLATE.format(i))\r\n        scripts.append(sha)\r\n\r\n    await c_replica.execute_command(f\"REPLICAOF localhost {master.port}\")\r\n    await wait_available_async(c_replica)\r\n    \r\n    # transfer in stable state\r\n    for i in range(10, 20):\r\n        sha = await c_master.script_load(SCRIPT_TEMPLATE.format(i))\r\n        scripts.append(sha)\r\n    \r\n    check_all_replicas_finished([c_replica], c_master)\r\n    await c_replica.execute_command(\"REPLICAOF NO ONE\")\r\n    \r\n    for i, sha in enumerate(scripts):\r\n        print(i) # fails from 10 and on\r\n        assert await c_replica.evalsha(sha, 0) == i\r\n```\n",
  "hints_text": "",
  "created_at": "2023-04-20T07:55:25Z",
  "modified_files": [
    "src/server/command_registry.cc",
    "src/server/command_registry.h",
    "src/server/db_slice.cc",
    "src/server/script_mgr.cc",
    "src/server/server_family.cc",
    "src/server/transaction.cc",
    "src/server/transaction.h"
  ],
  "modified_test_files": [
    "tests/dragonfly/replication_test.py"
  ]
}