{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9891,
  "instance_id": "ClickHouse__ClickHouse-9891",
  "issue_numbers": [
    "4756"
  ],
  "base_commit": "6f87f7ba688360ece3e8230afc8a7508618b0b8d",
  "patch": "diff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\nindex cad4b3bd188e..d5a5bf7ead72 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -24,7 +24,6 @@\n \n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/ExpressionActions.h>\n-#include <Interpreters/InJoinSubqueriesPreprocessor.h>\n #include <Interpreters/LogicalExpressionsOptimizer.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n #include <Interpreters/Set.h>\ndiff --git a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp\nindex 389d6c825b05..f40e91e7dcd8 100644\n--- a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp\n+++ b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp\n@@ -38,6 +38,7 @@ struct NonGlobalTableData\n \n     const CheckShardsAndTables & checker;\n     const Context & context;\n+    std::vector<ASTPtr> & renamed_tables;\n     ASTFunction * function = nullptr;\n     ASTTableJoin * table_join = nullptr;\n \n@@ -95,10 +96,11 @@ struct NonGlobalTableData\n \n             String alias = database_and_table->tryGetAlias();\n             if (alias.empty())\n-                throw Exception(\"Distributed table should have an alias when distributed_product_mode set to local.\",\n+                throw Exception(\"Distributed table should have an alias when distributed_product_mode set to local\",\n                                 ErrorCodes::DISTRIBUTED_IN_JOIN_SUBQUERY_DENIED);\n \n             auto & identifier = database_and_table->as<ASTIdentifier &>();\n+            renamed_tables.emplace_back(identifier.clone());\n             identifier.resetTable(database, table);\n         }\n         else\n@@ -118,6 +120,7 @@ class NonGlobalSubqueryMatcher\n     {\n         const CheckShardsAndTables & checker;\n         const Context & context;\n+        std::vector<std::pair<ASTPtr, std::vector<ASTPtr>>> & renamed_tables;\n     };\n \n     static void visit(ASTPtr & node, Data & data)\n@@ -148,8 +151,11 @@ class NonGlobalSubqueryMatcher\n         if (node.name == \"in\" || node.name == \"notIn\")\n         {\n             auto & subquery = node.arguments->children.at(1);\n-            NonGlobalTableVisitor::Data table_data{data.checker, data.context, &node, nullptr};\n+            std::vector<ASTPtr> renamed;\n+            NonGlobalTableVisitor::Data table_data{data.checker, data.context, renamed, &node, nullptr};\n             NonGlobalTableVisitor(table_data).visit(subquery);\n+            if (!renamed.empty())\n+                data.renamed_tables.emplace_back(subquery, std::move(renamed));\n         }\n     }\n \n@@ -163,8 +169,11 @@ class NonGlobalSubqueryMatcher\n         {\n             if (auto & subquery = node.table_expression->as<ASTTableExpression>()->subquery)\n             {\n-                NonGlobalTableVisitor::Data table_data{data.checker, data.context, nullptr, table_join};\n+                std::vector<ASTPtr> renamed;\n+                NonGlobalTableVisitor::Data table_data{data.checker, data.context, renamed, nullptr, table_join};\n                 NonGlobalTableVisitor(table_data).visit(subquery);\n+                if (!renamed.empty())\n+                    data.renamed_tables.emplace_back(subquery, std::move(renamed));\n             }\n         }\n     }\n@@ -208,7 +217,7 @@ void InJoinSubqueriesPreprocessor::visit(ASTPtr & ast) const\n             return;\n     }\n \n-    NonGlobalSubqueryVisitor::Data visitor_data{*checker, context};\n+    NonGlobalSubqueryVisitor::Data visitor_data{*checker, context, renamed_tables};\n     NonGlobalSubqueryVisitor(visitor_data).visit(ast);\n }\n \ndiff --git a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h\nindex ff39d812deec..5aa9cfbcadfc 100644\n--- a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h\n+++ b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h\n@@ -35,6 +35,8 @@ class Context;\n class InJoinSubqueriesPreprocessor\n {\n public:\n+    using SubqueryTables = std::vector<std::pair<ASTPtr, std::vector<ASTPtr>>>;  /// {subquery, renamed_tables}\n+\n     struct CheckShardsAndTables\n     {\n         using Ptr = std::unique_ptr<CheckShardsAndTables>;\n@@ -45,8 +47,10 @@ class InJoinSubqueriesPreprocessor\n         virtual ~CheckShardsAndTables() {}\n     };\n \n-    InJoinSubqueriesPreprocessor(const Context & context_, CheckShardsAndTables::Ptr _checker = std::make_unique<CheckShardsAndTables>())\n+    InJoinSubqueriesPreprocessor(const Context & context_, SubqueryTables & renamed_tables_,\n+                                 CheckShardsAndTables::Ptr _checker = std::make_unique<CheckShardsAndTables>())\n         : context(context_)\n+        , renamed_tables(renamed_tables_)\n         , checker(std::move(_checker))\n     {}\n \n@@ -54,6 +58,7 @@ class InJoinSubqueriesPreprocessor\n \n private:\n     const Context & context;\n+    SubqueryTables & renamed_tables;\n     CheckShardsAndTables::Ptr checker;\n };\n \ndiff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\nindex 4fe83afa48db..db1894026d83 100644\n--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -301,6 +301,8 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n             source_header = interpreter_subquery->getSampleBlock();\n     }\n \n+    joined_tables.rewriteDistributedInAndJoins(query_ptr);\n+\n     max_streams = settings.max_threads;\n     ASTSelectQuery & query = getSelectQuery();\n \ndiff --git a/dbms/src/Interpreters/JoinedTables.cpp b/dbms/src/Interpreters/JoinedTables.cpp\nindex beec338f9bfa..48e763ffb193 100644\n--- a/dbms/src/Interpreters/JoinedTables.cpp\n+++ b/dbms/src/Interpreters/JoinedTables.cpp\n@@ -1,12 +1,18 @@\n #include <Interpreters/JoinedTables.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/getTableExpressions.h>\n+#include <Interpreters/InJoinSubqueriesPreprocessor.h>\n+#include <Interpreters/IdentifierSemantic.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n #include <Storages/IStorage.h>\n #include <Storages/ColumnsDescription.h>\n #include <Storages/StorageValues.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTQualifiedAsterisk.h>\n \n namespace DB\n {\n@@ -14,6 +20,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ALIAS_REQUIRED;\n+    extern const int AMBIGUOUS_COLUMN_NAME;\n }\n \n namespace\n@@ -32,6 +39,71 @@ void checkTablesWithColumns(const std::vector<T> & tables_with_columns, const Co\n     }\n }\n \n+class RenameQualifiedIdentifiersMatcher\n+{\n+public:\n+    using Data = const std::vector<DatabaseAndTableWithAlias>;\n+\n+    static void visit(ASTPtr & ast, Data & data)\n+    {\n+        if (auto * t = ast->as<ASTIdentifier>())\n+            visit(*t, ast, data);\n+        if (auto * node = ast->as<ASTQualifiedAsterisk>())\n+            visit(*node, ast, data);\n+    }\n+\n+    static bool needChildVisit(ASTPtr & node, const ASTPtr & child)\n+    {\n+        if (node->as<ASTTableExpression>() ||\n+            node->as<ASTQualifiedAsterisk>() ||\n+            child->as<ASTSubquery>())\n+            return false; // NOLINT\n+        return true;\n+    }\n+\n+private:\n+    static void visit(ASTIdentifier & identifier, ASTPtr &, Data & data)\n+    {\n+        if (identifier.isShort())\n+            return;\n+\n+        bool rewritten = false;\n+        for (auto & table : data)\n+        {\n+            /// Table has an alias. We do not need to rewrite qualified names with table alias (match == ColumnMatch::TableName).\n+            auto match = IdentifierSemantic::canReferColumnToTable(identifier, table);\n+            if (match == IdentifierSemantic::ColumnMatch::AliasedTableName ||\n+                match == IdentifierSemantic::ColumnMatch::DbAndTable)\n+            {\n+                if (rewritten)\n+                    throw Exception(\"Failed to rewrite distributed table names. Ambiguous column '\" + identifier.name + \"'\",\n+                                    ErrorCodes::AMBIGUOUS_COLUMN_NAME);\n+                /// Table has an alias. So we set a new name qualified by table alias.\n+                IdentifierSemantic::setColumnLongName(identifier, table);\n+                rewritten = true;\n+            }\n+        }\n+    }\n+\n+    static void visit(const ASTQualifiedAsterisk & node, const ASTPtr &, Data & data)\n+    {\n+        ASTIdentifier & identifier = *node.children[0]->as<ASTIdentifier>();\n+        bool rewritten = false;\n+        for (auto & table : data)\n+        {\n+            if (identifier.name == table.table)\n+            {\n+                if (rewritten)\n+                    throw Exception(\"Failed to rewrite distributed table. Ambiguous column '\" + identifier.name + \"'\",\n+                                    ErrorCodes::AMBIGUOUS_COLUMN_NAME);\n+                identifier.setShortName(table.alias);\n+                rewritten = true;\n+            }\n+        }\n+    }\n+};\n+using RenameQualifiedIdentifiersVisitor = InDepthNodeVisitor<RenameQualifiedIdentifiersMatcher, true>;\n+\n }\n \n JoinedTables::JoinedTables(Context && context_, const ASTSelectQuery & select_query)\n@@ -114,4 +186,27 @@ void JoinedTables::makeFakeTable(StoragePtr storage, const Block & source_header\n         tables_with_columns.emplace_back(DatabaseAndTableWithAlias{}, source_header.getNamesAndTypesList());\n }\n \n+void JoinedTables::rewriteDistributedInAndJoins(ASTPtr & query)\n+{\n+    /// Rewrite IN and/or JOIN for distributed tables according to distributed_product_mode setting.\n+    InJoinSubqueriesPreprocessor::SubqueryTables renamed_tables;\n+    InJoinSubqueriesPreprocessor(context, renamed_tables).visit(query);\n+\n+    String database;\n+    if (!renamed_tables.empty())\n+        database = context.getCurrentDatabase();\n+\n+    for (auto & [subquery, ast_tables] : renamed_tables)\n+    {\n+        std::vector<DatabaseAndTableWithAlias> renamed;\n+        renamed.reserve(ast_tables.size());\n+        for (auto & ast : ast_tables)\n+            renamed.emplace_back(DatabaseAndTableWithAlias(*ast->as<ASTIdentifier>(), database));\n+\n+        /// Change qualified column names in distributed subqueries using table aliases.\n+        RenameQualifiedIdentifiersVisitor::Data data(renamed);\n+        RenameQualifiedIdentifiersVisitor(data).visit(subquery);\n+    }\n+}\n+\n }\ndiff --git a/dbms/src/Interpreters/JoinedTables.h b/dbms/src/Interpreters/JoinedTables.h\nindex f1940366ef5a..66b3c8de609a 100644\n--- a/dbms/src/Interpreters/JoinedTables.h\n+++ b/dbms/src/Interpreters/JoinedTables.h\n@@ -37,6 +37,8 @@ class JoinedTables\n \n     const StorageID & leftTableID() const { return table_id; }\n \n+    void rewriteDistributedInAndJoins(ASTPtr & query);\n+\n     std::unique_ptr<InterpreterSelectWithUnionQuery> makeLeftTableSubquery(const SelectQueryOptions & select_options);\n \n private:\ndiff --git a/dbms/src/Interpreters/SyntaxAnalyzer.cpp b/dbms/src/Interpreters/SyntaxAnalyzer.cpp\nindex 099513ed0989..68b1c55c5001 100644\n--- a/dbms/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/dbms/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -2,7 +2,6 @@\n #include <Core/NamesAndTypes.h>\n \n #include <Interpreters/SyntaxAnalyzer.h>\n-#include <Interpreters/InJoinSubqueriesPreprocessor.h>\n #include <Interpreters/LogicalExpressionsOptimizer.h>\n #include <Interpreters/QueryAliasesVisitor.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n@@ -819,9 +818,6 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyzeSelect(\n \n     translateQualifiedNames(query, *select_query, source_columns_set, tables_with_column_names);\n \n-    /// Rewrite IN and/or JOIN for distributed tables according to distributed_product_mode setting.\n-    InJoinSubqueriesPreprocessor(context).visit(query);\n-\n     /// Optimizes logical expressions.\n     LogicalExpressionsOptimizer(select_query, settings.optimize_min_equality_disjunction_chain_length.value).perform();\n \n",
  "test_patch": "diff --git a/dbms/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp b/dbms/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp\nindex 9a6d7ca41627..9a17f03f32a7 100644\n--- a/dbms/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp\n+++ b/dbms/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp\n@@ -1181,7 +1181,8 @@ TestResult check(const TestEntry & entry)\n \n         try\n         {\n-            DB::InJoinSubqueriesPreprocessor(context, std::make_unique<CheckShardsAndTablesMock>()).visit(ast_input);\n+            DB::InJoinSubqueriesPreprocessor::SubqueryTables renamed;\n+            DB::InJoinSubqueriesPreprocessor(context, renamed, std::make_unique<CheckShardsAndTablesMock>()).visit(ast_input);\n         }\n         catch (const DB::Exception & ex)\n         {\ndiff --git a/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.reference b/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.reference\nnew file mode 100644\nindex 000000000000..53f7332cffbf\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.reference\n@@ -0,0 +1,12 @@\n+42\n+42\n+42\n+42\n+42\n+42\n+42\n+42\n+42\n+42\n+42\n+42\ndiff --git a/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.sql b/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.sql\nnew file mode 100644\nindex 000000000000..32655420a279\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.sql\n@@ -0,0 +1,87 @@\n+CREATE DATABASE IF NOT EXISTS test_01103;\n+USE test_01103;\n+\n+DROP TABLE IF EXISTS t1_shard;\n+DROP TABLE IF EXISTS t2_shard;\n+DROP TABLE IF EXISTS t1_distr;\n+DROP TABLE IF EXISTS t2_distr;\n+\n+create table t1_shard (id Int32) engine MergeTree order by id;\n+create table t2_shard (id Int32) engine MergeTree order by id;\n+\n+create table t1_distr as t1_shard engine Distributed(test_cluster_two_shards_localhost, test_01103, t1_shard, id);\n+create table t2_distr as t2_shard engine Distributed(test_cluster_two_shards_localhost, test_01103, t2_shard, id);\n+\n+insert into t1_shard values (42);\n+insert into t2_shard values (42);\n+\n+SET distributed_product_mode = 'local';\n+\n+select d0.id\n+from t1_distr d0\n+where d0.id in\n+(\n+    select d1.id\n+    from t1_distr as d1\n+    inner join t2_distr as d2 on d1.id = d2.id\n+    where d1.id  > 0\n+    order by d1.id\n+);\n+\n+select t1_distr.id\n+from t1_distr\n+where t1_distr.id in\n+(\n+    select t1_distr.id\n+    from t1_distr as d1\n+    inner join t2_distr as d2 on t1_distr.id = t2_distr.id\n+    where t1_distr.id  > 0\n+    order by t1_distr.id\n+);\n+\n+select test_01103.t1_distr.id\n+from test_01103.t1_distr\n+where test_01103.t1_distr.id in\n+(\n+    select test_01103.t1_distr.id\n+    from test_01103.t1_distr as d1\n+    inner join test_01103.t2_distr as d2 on test_01103.t1_distr.id = test_01103.t2_distr.id\n+    where test_01103.t1_distr.id  > 0\n+    order by test_01103.t1_distr.id\n+);\n+\n+select d0.id\n+from t1_distr d0\n+join (\n+    select d1.id\n+    from t1_distr as d1\n+    inner join t2_distr as d2 on d1.id = d2.id\n+    where d1.id  > 0\n+    order by d1.id\n+) s0 using id;\n+\n+select t1_distr.id\n+from t1_distr\n+join (\n+    select t1_distr.id\n+    from t1_distr as d1\n+    inner join t2_distr as d2 on t1_distr.id = t2_distr.id\n+    where t1_distr.id  > 0\n+    order by t1_distr.id\n+) s0 using id;\n+\n+select test_01103.t1_distr.id\n+from test_01103.t1_distr\n+join (\n+    select test_01103.t1_distr.id\n+    from test_01103.t1_distr as d1\n+    inner join test_01103.t2_distr as d2 on test_01103.t1_distr.id = test_01103.t2_distr.id\n+    where test_01103.t1_distr.id  > 0\n+    order by test_01103.t1_distr.id\n+) s0 using id;\n+\n+DROP TABLE t1_shard;\n+DROP TABLE t2_shard;\n+DROP TABLE t1_distr;\n+DROP TABLE t2_distr;\n+DROP DATABASE test_01103;\ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.reference b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.reference\nnew file mode 100644\nindex 000000000000..c5079fa2cfd0\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.reference\n@@ -0,0 +1,4 @@\n+100\n+100\n+100\n+100\ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql\nnew file mode 100644\nindex 000000000000..b301c0ac00f6\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql\n@@ -0,0 +1,12 @@\n+DROP TABLE IF EXISTS d_numbers;\n+CREATE TABLE d_numbers (number UInt32) ENGINE = Distributed(test_cluster_two_shards_localhost, system, numbers, rand());\n+\n+SET experimental_use_processors = 1;\n+\n+SELECT '100' AS number FROM d_numbers AS n WHERE n.number = 100 LIMIT 2;\n+\n+SET distributed_product_mode = 'local';\n+\n+SELECT '100' AS number FROM d_numbers AS n WHERE n.number = 100 LIMIT 2;\n+\n+DROP TABLE d_numbers;\ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference b/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference\nnew file mode 100644\nindex 000000000000..929dd64ae90f\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference\n@@ -0,0 +1,6 @@\n+local_0\t1\n+distributed_0\t1\t1\n+distributed_0\t2\t1\n+local_0\t1\n+distributed_0\t1\t1\n+distributed_0\t2\t1\ndiff --git a/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql b/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql\nnew file mode 100644\nindex 000000000000..92b4a83ebf36\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql\n@@ -0,0 +1,18 @@\n+DROP TABLE IF EXISTS d_one;\n+CREATE TABLE d_one (dummy UInt8) ENGINE = Distributed(test_cluster_two_shards_localhost, system, one, rand());\n+\n+SELECT 'local_0', toUInt8(1) AS dummy FROM system.one AS o WHERE o.dummy = 0;\n+SELECT 'local_1', toUInt8(1) AS dummy FROM system.one AS o WHERE o.dummy = 1;\n+\n+SELECT 'distributed_0', _shard_num, toUInt8(1) AS dummy FROM d_one AS o WHERE o.dummy = 0 ORDER BY _shard_num;\n+SELECT 'distributed_1', _shard_num, toUInt8(1) AS dummy FROM d_one AS o WHERE o.dummy = 1 ORDER BY _shard_num;\n+\n+SET distributed_product_mode = 'local';\n+\n+SELECT 'local_0', toUInt8(1) AS dummy FROM system.one AS o WHERE o.dummy = 0;\n+SELECT 'local_1', toUInt8(1) AS dummy FROM system.one AS o WHERE o.dummy = 1;\n+\n+SELECT 'distributed_0', _shard_num, toUInt8(1) AS dummy FROM d_one AS o WHERE o.dummy = 0 ORDER BY _shard_num;\n+SELECT 'distributed_1', _shard_num, toUInt8(1) AS dummy FROM d_one AS o WHERE o.dummy = 1 ORDER BY _shard_num;\n+\n+DROP TABLE d_one;\n",
  "problem_statement": "Incorrect field reference in distributed query with distributed_product_mode=local\n**Describe the bug**\r\nIf setting distributed_product_mode=local, distributed query contains IN condition and \r\na) fields in subquery are referenced with database name, ClickHouse  replaces distributed names with local names only in FROM and JOIN sections, but not in SELECT, WHERE, ORDER BY\r\nb) fields in subquery are referenced with table alias, ClickHouse replaces distributed names and aliases with local names. So aliases are lost.\r\n\r\n**How to reproduce**\r\nClickHouse version 19.4.0.49 cluster (shards)\r\nHTTP interface\r\nsetting distributed_product_mode=local\r\n\r\n```\r\ncreate table bug_shard1 on cluster mycluster\r\n\t(id Int32) \r\n\tengine = MergeTree \r\n\torder by cityHash64(id);\r\n\r\ncreate table bug_distr1 on cluster mycluster\r\n    as bug_shard1\r\n    engine Distributed(\r\n        mycluster,\r\n        `default`,\r\n        bug_shard1,\r\n        cityHash64(id)\r\n    );\r\n\r\ncreate table bug_shard2 on cluster mycluster\r\n\t(id Int32) \r\n\tengine = MergeTree \r\n\torder by cityHash64(id);\r\n\r\ncreate table bug_distr2 on cluster mycluster\r\n    as bug_shard2\r\n    engine Distributed(\r\n        mycluster,\r\n        `default`,\r\n        bug_shard2,\r\n        cityHash64(id)\r\n    );\r\n```\r\n\r\n**Queries to run that lead to unexpected result**\r\na)\r\n```\r\nselect `default`.bug_distr1.id \r\n\tfrom `default`.bug_distr1\r\n\twhere `default`.bug_distr1.id in \r\n\t(\r\n  \t\tselect `default`.bug_distr1.id \r\n  \t\t\tfrom `default`.bug_distr1\r\n  \t\t\t\tinner join `default`.bug_distr2 on `default`.bug_distr1.id = `default`.bug_distr2.id\r\n\t\t\twhere `default`.bug_distr1.id  > 0\r\n\t\t\torder by `default`.bug_distr1.id  \r\n\t);\r\n```\r\nb)\r\n```\r\nselect d0.id \r\n\tfrom bug_distr1 d0\r\n\twhere d0.id in \r\n\t(\r\n  \t\tselect d1.id \r\n  \t\t\tfrom bug_distr1 as d1\r\n  \t\t\t\tinner join bug_distr2 as d2 on d1.id = d2.id\r\n\t\t\twhere d1.id  > 0\r\n\t\t\torder by d1.id  \r\n\t);\r\n```\r\n\r\n**Expected behavior**\r\na) distributed table names has been replaced with local names in all query sections\r\nb) aliases in FROM and JOIN sections has not been removed\r\n\r\n**Error message and/or stacktrace**\r\na) \r\n\r\n> SQL Error [47]: ClickHouse exception, code: 47, host: localhost, port: 8125; Code: 47, e.displayText() = DB::Exception: Unknown identifier: default.bug_distr1.id, context: query: 'SELECT default.bug_distr1.id FROM default.bug_shard1  INNER JOIN default.bug_shard2 ON default.bug_distr1.id = default.bug_distr2.id WHERE default.bug_distr1.id > 0 ORDER BY default.bug_distr1.id ASC' required_names: 'default.bug_distr2.id''default.bug_distr1.id' source_tables: 'default.bug_shard1' 'default.bug_shard2' table_aliases: complex_aliases: masked_columns: array_join_columns: source_columns: \r\n\r\nb) \r\n>SQL Error [47]: ClickHouse exception, code: 47, host: localhost, port: 8125; Code: 47, e.displayText() = DB::Exception: Unknown identifier: d1.id, context: query: 'SELECT d1.id FROM default.bug_shard1  INNER JOIN default.bug_shard2 ON d1.id = d2.id WHERE d1.id > 0 ORDER BY d1.id ASC' required_names: 'd2.id''d1.id' source_tables: 'default.bug_shard1' 'default.bug_shard2' table_aliases: complex_aliases: masked_columns: array_join_columns: source_columns: \r\n\r\n\n",
  "hints_text": "Probably related #4879\nPartial fix #4986\nI checked fix for #4879 on v 19.5.2.6\r\nBoth queries from this issue work in global and allow modes, and they did not before.\r\nBoth queries fail in local mode.\nUPD.\r\nClickhouse v 19.15.3.6\r\nQuery with aliases works in local mode\r\nQuery with db names throws exception\r\n\r\n>    SQL Error [288]: ClickHouse exception, code: 288, host: localhost, port: 8123; Code: 288, e.displayText() = DB::Exception: Distributed table should have an alias when distributed_product_mode set to local. (version 19.15.3.6 (official build))",
  "created_at": "2020-03-26T19:56:45Z",
  "modified_files": [
    "dbms/src/Interpreters/ExpressionAnalyzer.cpp",
    "dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp",
    "dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h",
    "dbms/src/Interpreters/InterpreterSelectQuery.cpp",
    "dbms/src/Interpreters/JoinedTables.cpp",
    "dbms/src/Interpreters/JoinedTables.h",
    "dbms/src/Interpreters/SyntaxAnalyzer.cpp"
  ],
  "modified_test_files": [
    "dbms/src/Interpreters/tests/in_join_subqueries_preprocessor.cpp",
    "b/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.reference",
    "b/dbms/tests/queries/0_stateless/01103_distributed_product_mode_local_column_renames.sql",
    "b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.reference",
    "b/dbms/tests/queries/0_stateless/01104_distributed_numbers_test.sql",
    "b/dbms/tests/queries/0_stateless/01104_distributed_one_test.reference",
    "b/dbms/tests/queries/0_stateless/01104_distributed_one_test.sql"
  ]
}