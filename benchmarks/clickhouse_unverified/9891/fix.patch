diff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp
index cad4b3bd188e..d5a5bf7ead72 100644
--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp
@@ -24,7 +24,6 @@
 
 #include <Interpreters/ExpressionAnalyzer.h>
 #include <Interpreters/ExpressionActions.h>
-#include <Interpreters/InJoinSubqueriesPreprocessor.h>
 #include <Interpreters/LogicalExpressionsOptimizer.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
 #include <Interpreters/Set.h>
diff --git a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp
index 389d6c825b05..f40e91e7dcd8 100644
--- a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp
+++ b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.cpp
@@ -38,6 +38,7 @@ struct NonGlobalTableData
 
     const CheckShardsAndTables & checker;
     const Context & context;
+    std::vector<ASTPtr> & renamed_tables;
     ASTFunction * function = nullptr;
     ASTTableJoin * table_join = nullptr;
 
@@ -95,10 +96,11 @@ struct NonGlobalTableData
 
             String alias = database_and_table->tryGetAlias();
             if (alias.empty())
-                throw Exception("Distributed table should have an alias when distributed_product_mode set to local.",
+                throw Exception("Distributed table should have an alias when distributed_product_mode set to local",
                                 ErrorCodes::DISTRIBUTED_IN_JOIN_SUBQUERY_DENIED);
 
             auto & identifier = database_and_table->as<ASTIdentifier &>();
+            renamed_tables.emplace_back(identifier.clone());
             identifier.resetTable(database, table);
         }
         else
@@ -118,6 +120,7 @@ class NonGlobalSubqueryMatcher
     {
         const CheckShardsAndTables & checker;
         const Context & context;
+        std::vector<std::pair<ASTPtr, std::vector<ASTPtr>>> & renamed_tables;
     };
 
     static void visit(ASTPtr & node, Data & data)
@@ -148,8 +151,11 @@ class NonGlobalSubqueryMatcher
         if (node.name == "in" || node.name == "notIn")
         {
             auto & subquery = node.arguments->children.at(1);
-            NonGlobalTableVisitor::Data table_data{data.checker, data.context, &node, nullptr};
+            std::vector<ASTPtr> renamed;
+            NonGlobalTableVisitor::Data table_data{data.checker, data.context, renamed, &node, nullptr};
             NonGlobalTableVisitor(table_data).visit(subquery);
+            if (!renamed.empty())
+                data.renamed_tables.emplace_back(subquery, std::move(renamed));
         }
     }
 
@@ -163,8 +169,11 @@ class NonGlobalSubqueryMatcher
         {
             if (auto & subquery = node.table_expression->as<ASTTableExpression>()->subquery)
             {
-                NonGlobalTableVisitor::Data table_data{data.checker, data.context, nullptr, table_join};
+                std::vector<ASTPtr> renamed;
+                NonGlobalTableVisitor::Data table_data{data.checker, data.context, renamed, nullptr, table_join};
                 NonGlobalTableVisitor(table_data).visit(subquery);
+                if (!renamed.empty())
+                    data.renamed_tables.emplace_back(subquery, std::move(renamed));
             }
         }
     }
@@ -208,7 +217,7 @@ void InJoinSubqueriesPreprocessor::visit(ASTPtr & ast) const
             return;
     }
 
-    NonGlobalSubqueryVisitor::Data visitor_data{*checker, context};
+    NonGlobalSubqueryVisitor::Data visitor_data{*checker, context, renamed_tables};
     NonGlobalSubqueryVisitor(visitor_data).visit(ast);
 }
 
diff --git a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h
index ff39d812deec..5aa9cfbcadfc 100644
--- a/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h
+++ b/dbms/src/Interpreters/InJoinSubqueriesPreprocessor.h
@@ -35,6 +35,8 @@ class Context;
 class InJoinSubqueriesPreprocessor
 {
 public:
+    using SubqueryTables = std::vector<std::pair<ASTPtr, std::vector<ASTPtr>>>;  /// {subquery, renamed_tables}
+
     struct CheckShardsAndTables
     {
         using Ptr = std::unique_ptr<CheckShardsAndTables>;
@@ -45,8 +47,10 @@ class InJoinSubqueriesPreprocessor
         virtual ~CheckShardsAndTables() {}
     };
 
-    InJoinSubqueriesPreprocessor(const Context & context_, CheckShardsAndTables::Ptr _checker = std::make_unique<CheckShardsAndTables>())
+    InJoinSubqueriesPreprocessor(const Context & context_, SubqueryTables & renamed_tables_,
+                                 CheckShardsAndTables::Ptr _checker = std::make_unique<CheckShardsAndTables>())
         : context(context_)
+        , renamed_tables(renamed_tables_)
         , checker(std::move(_checker))
     {}
 
@@ -54,6 +58,7 @@ class InJoinSubqueriesPreprocessor
 
 private:
     const Context & context;
+    SubqueryTables & renamed_tables;
     CheckShardsAndTables::Ptr checker;
 };
 
diff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp
index 4fe83afa48db..db1894026d83 100644
--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp
@@ -301,6 +301,8 @@ InterpreterSelectQuery::InterpreterSelectQuery(
             source_header = interpreter_subquery->getSampleBlock();
     }
 
+    joined_tables.rewriteDistributedInAndJoins(query_ptr);
+
     max_streams = settings.max_threads;
     ASTSelectQuery & query = getSelectQuery();
 
diff --git a/dbms/src/Interpreters/JoinedTables.cpp b/dbms/src/Interpreters/JoinedTables.cpp
index beec338f9bfa..48e763ffb193 100644
--- a/dbms/src/Interpreters/JoinedTables.cpp
+++ b/dbms/src/Interpreters/JoinedTables.cpp
@@ -1,12 +1,18 @@
 #include <Interpreters/JoinedTables.h>
 #include <Interpreters/Context.h>
 #include <Interpreters/getTableExpressions.h>
+#include <Interpreters/InJoinSubqueriesPreprocessor.h>
+#include <Interpreters/IdentifierSemantic.h>
+#include <Interpreters/InDepthNodeVisitor.h>
 #include <Storages/IStorage.h>
 #include <Storages/ColumnsDescription.h>
 #include <Storages/StorageValues.h>
 #include <Parsers/ASTFunction.h>
 #include <Parsers/ASTSelectWithUnionQuery.h>
+#include <Parsers/ASTSubquery.h>
 #include <Parsers/ASTTablesInSelectQuery.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTQualifiedAsterisk.h>
 
 namespace DB
 {
@@ -14,6 +20,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int ALIAS_REQUIRED;
+    extern const int AMBIGUOUS_COLUMN_NAME;
 }
 
 namespace
@@ -32,6 +39,71 @@ void checkTablesWithColumns(const std::vector<T> & tables_with_columns, const Co
     }
 }
 
+class RenameQualifiedIdentifiersMatcher
+{
+public:
+    using Data = const std::vector<DatabaseAndTableWithAlias>;
+
+    static void visit(ASTPtr & ast, Data & data)
+    {
+        if (auto * t = ast->as<ASTIdentifier>())
+            visit(*t, ast, data);
+        if (auto * node = ast->as<ASTQualifiedAsterisk>())
+            visit(*node, ast, data);
+    }
+
+    static bool needChildVisit(ASTPtr & node, const ASTPtr & child)
+    {
+        if (node->as<ASTTableExpression>() ||
+            node->as<ASTQualifiedAsterisk>() ||
+            child->as<ASTSubquery>())
+            return false; // NOLINT
+        return true;
+    }
+
+private:
+    static void visit(ASTIdentifier & identifier, ASTPtr &, Data & data)
+    {
+        if (identifier.isShort())
+            return;
+
+        bool rewritten = false;
+        for (auto & table : data)
+        {
+            /// Table has an alias. We do not need to rewrite qualified names with table alias (match == ColumnMatch::TableName).
+            auto match = IdentifierSemantic::canReferColumnToTable(identifier, table);
+            if (match == IdentifierSemantic::ColumnMatch::AliasedTableName ||
+                match == IdentifierSemantic::ColumnMatch::DbAndTable)
+            {
+                if (rewritten)
+                    throw Exception("Failed to rewrite distributed table names. Ambiguous column '" + identifier.name + "'",
+                                    ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+                /// Table has an alias. So we set a new name qualified by table alias.
+                IdentifierSemantic::setColumnLongName(identifier, table);
+                rewritten = true;
+            }
+        }
+    }
+
+    static void visit(const ASTQualifiedAsterisk & node, const ASTPtr &, Data & data)
+    {
+        ASTIdentifier & identifier = *node.children[0]->as<ASTIdentifier>();
+        bool rewritten = false;
+        for (auto & table : data)
+        {
+            if (identifier.name == table.table)
+            {
+                if (rewritten)
+                    throw Exception("Failed to rewrite distributed table. Ambiguous column '" + identifier.name + "'",
+                                    ErrorCodes::AMBIGUOUS_COLUMN_NAME);
+                identifier.setShortName(table.alias);
+                rewritten = true;
+            }
+        }
+    }
+};
+using RenameQualifiedIdentifiersVisitor = InDepthNodeVisitor<RenameQualifiedIdentifiersMatcher, true>;
+
 }
 
 JoinedTables::JoinedTables(Context && context_, const ASTSelectQuery & select_query)
@@ -114,4 +186,27 @@ void JoinedTables::makeFakeTable(StoragePtr storage, const Block & source_header
         tables_with_columns.emplace_back(DatabaseAndTableWithAlias{}, source_header.getNamesAndTypesList());
 }
 
+void JoinedTables::rewriteDistributedInAndJoins(ASTPtr & query)
+{
+    /// Rewrite IN and/or JOIN for distributed tables according to distributed_product_mode setting.
+    InJoinSubqueriesPreprocessor::SubqueryTables renamed_tables;
+    InJoinSubqueriesPreprocessor(context, renamed_tables).visit(query);
+
+    String database;
+    if (!renamed_tables.empty())
+        database = context.getCurrentDatabase();
+
+    for (auto & [subquery, ast_tables] : renamed_tables)
+    {
+        std::vector<DatabaseAndTableWithAlias> renamed;
+        renamed.reserve(ast_tables.size());
+        for (auto & ast : ast_tables)
+            renamed.emplace_back(DatabaseAndTableWithAlias(*ast->as<ASTIdentifier>(), database));
+
+        /// Change qualified column names in distributed subqueries using table aliases.
+        RenameQualifiedIdentifiersVisitor::Data data(renamed);
+        RenameQualifiedIdentifiersVisitor(data).visit(subquery);
+    }
+}
+
 }
diff --git a/dbms/src/Interpreters/JoinedTables.h b/dbms/src/Interpreters/JoinedTables.h
index f1940366ef5a..66b3c8de609a 100644
--- a/dbms/src/Interpreters/JoinedTables.h
+++ b/dbms/src/Interpreters/JoinedTables.h
@@ -37,6 +37,8 @@ class JoinedTables
 
     const StorageID & leftTableID() const { return table_id; }
 
+    void rewriteDistributedInAndJoins(ASTPtr & query);
+
     std::unique_ptr<InterpreterSelectWithUnionQuery> makeLeftTableSubquery(const SelectQueryOptions & select_options);
 
 private:
diff --git a/dbms/src/Interpreters/SyntaxAnalyzer.cpp b/dbms/src/Interpreters/SyntaxAnalyzer.cpp
index 099513ed0989..68b1c55c5001 100644
--- a/dbms/src/Interpreters/SyntaxAnalyzer.cpp
+++ b/dbms/src/Interpreters/SyntaxAnalyzer.cpp
@@ -2,7 +2,6 @@
 #include <Core/NamesAndTypes.h>
 
 #include <Interpreters/SyntaxAnalyzer.h>
-#include <Interpreters/InJoinSubqueriesPreprocessor.h>
 #include <Interpreters/LogicalExpressionsOptimizer.h>
 #include <Interpreters/QueryAliasesVisitor.h>
 #include <Interpreters/InterpreterSelectWithUnionQuery.h>
@@ -819,9 +818,6 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyzeSelect(
 
     translateQualifiedNames(query, *select_query, source_columns_set, tables_with_column_names);
 
-    /// Rewrite IN and/or JOIN for distributed tables according to distributed_product_mode setting.
-    InJoinSubqueriesPreprocessor(context).visit(query);
-
     /// Optimizes logical expressions.
     LogicalExpressionsOptimizer(select_query, settings.optimize_min_equality_disjunction_chain_length.value).perform();
 
