diff --git a/src/Common/UTF8Helpers.cpp b/src/Common/UTF8Helpers.cpp
index 22f2753a8a9b..a3ffb9587f51 100644
--- a/src/Common/UTF8Helpers.cpp
+++ b/src/Common/UTF8Helpers.cpp
@@ -164,40 +164,43 @@ size_t computeWidthImpl(const UInt8 * data, size_t size, size_t prefix, size_t l
         if (mode == BytesBeforeLimit && width > limit)
             return i - (width - limit);
 
-        switch (decoder.decode(data[i]))
+        if (i < size)
         {
-            case UTF8Decoder::REJECT:
+            switch (decoder.decode(data[i]))
             {
-                decoder.reset();
-                // invalid sequences seem to have zero width in modern terminals
-                // tested in libvte-based, alacritty, urxvt and xterm
-                i -= rollback;
-                rollback = 0;
-                break;
-            }
-            case UTF8Decoder::ACCEPT:
-            {
-                // TODO: multiline support for '
'
-
-                // special treatment for '\t' and for ESC
-                size_t next_width = width;
-                if (decoder.codepoint == '\x1b')
-                    is_escape_sequence = true;
-                else if (decoder.codepoint == '\t')
-                    next_width += 8 - (prefix + width) % 8;
-                else
-                    next_width += wcwidth(decoder.codepoint);
-
-                if (mode == BytesBeforeLimit && next_width > limit)
-                    return i - rollback;
-                width = next_width;
-
-                rollback = 0;
-                break;
+                case UTF8Decoder::REJECT:
+                {
+                    decoder.reset();
+                    // invalid sequences seem to have zero width in modern terminals
+                    // tested in libvte-based, alacritty, urxvt and xterm
+                    i -= rollback;
+                    rollback = 0;
+                    break;
+                }
+                case UTF8Decoder::ACCEPT:
+                {
+                    // TODO: multiline support for '
'
+
+                    // special treatment for '\t' and for ESC
+                    size_t next_width = width;
+                    if (decoder.codepoint == '\x1b')
+                        is_escape_sequence = true;
+                    else if (decoder.codepoint == '\t')
+                        next_width += 8 - (prefix + width) % 8;
+                    else
+                        next_width += wcwidth(decoder.codepoint);
+
+                    if (mode == BytesBeforeLimit && next_width > limit)
+                        return i - rollback;
+                    width = next_width;
+
+                    rollback = 0;
+                    break;
+                }
+                // continue if we meet other values here
+                default:
+                    ++rollback;
             }
-            // continue if we meet other values here
-            default:
-                ++rollback;
         }
     }
 
diff --git a/src/Parsers/Lexer.cpp b/src/Parsers/Lexer.cpp
index bc25f80bee6e..23e34dca4b5e 100644
--- a/src/Parsers/Lexer.cpp
+++ b/src/Parsers/Lexer.cpp
@@ -2,8 +2,10 @@
 #include <base/defines.h>
 #include <Parsers/Lexer.h>
 #include <Common/StringUtils.h>
+#include <Common/UTF8Helpers.h>
 #include <base/find_symbols.h>
 
+
 namespace DB
 {
 
@@ -518,7 +520,12 @@ Token Lexer::nextTokenImpl()
             pos = skipWhitespacesUTF8(pos, end);
             if (pos > token_begin)
                 return Token(TokenType::Whitespace, token_begin, pos);
-            return Token(TokenType::Error, token_begin, ++pos);
+
+            ++pos;
+            while (pos < end && UTF8::isContinuationOctet(*pos))
+                ++pos;
+
+            return Token(TokenType::Error, token_begin, pos);
     }
 }
 
@@ -556,7 +563,7 @@ const char * getErrorTokenDescription(TokenType type)
         case TokenType::ErrorWrongNumber:
             return "Wrong number";
         case TokenType::ErrorMaxQuerySizeExceeded:
-            return "Max query size exceeded";
+            return "Max query size exceeded (can be increased with the `max_query_size` setting)";
         default:
             return "Not an error";
     }
diff --git a/src/Parsers/parseQuery.cpp b/src/Parsers/parseQuery.cpp
index ba7b44ca852a..d53a7fbfba77 100644
--- a/src/Parsers/parseQuery.cpp
+++ b/src/Parsers/parseQuery.cpp
@@ -121,7 +121,13 @@ void writeQueryAroundTheError(
     else
     {
         if (num_positions_to_hilite)
-            out << ": " << std::string(positions_to_hilite[0].begin, std::min(SHOW_CHARS_ON_SYNTAX_ERROR, end - positions_to_hilite[0].begin)) << ". ";
+        {
+            const char * example_begin = positions_to_hilite[0].begin;
+            size_t total_bytes = end - example_begin;
+            size_t show_bytes = UTF8::computeBytesBeforeWidth(
+                reinterpret_cast<const UInt8 *>(example_begin), total_bytes, 0, SHOW_CHARS_ON_SYNTAX_ERROR);
+            out << ": " << std::string(example_begin, show_bytes) << (show_bytes < total_bytes ? "... " : ". ");
+        }
     }
 }
 
@@ -146,7 +152,13 @@ void writeCommonErrorMessage(
     }
     else
     {
-        out << " ('" << std::string(last_token.begin, last_token.end - last_token.begin) << "')";
+        /// Do not print too long tokens.
+        size_t token_size_bytes = last_token.end - last_token.begin;
+        size_t token_preview_size_bytes = UTF8::computeBytesBeforeWidth(
+            reinterpret_cast<const UInt8 *>(last_token.begin), token_size_bytes, 0, SHOW_CHARS_ON_SYNTAX_ERROR);
+
+        out << " (" << std::string(last_token.begin, token_preview_size_bytes)
+            << (token_preview_size_bytes < token_size_bytes ? "..." : "") << ")";
     }
 
     /// If query is multiline.
@@ -189,15 +201,9 @@ std::string getLexicalErrorMessage(
     const std::string & query_description)
 {
     WriteBufferFromOwnString out;
+    out << getErrorTokenDescription(last_token.type) << ": ";
     writeCommonErrorMessage(out, begin, end, last_token, query_description);
     writeQueryAroundTheError(out, begin, end, hilite, &last_token, 1);
-
-    out << getErrorTokenDescription(last_token.type);
-    if (last_token.size())
-    {
-       out << ": '" << std::string_view{last_token.begin, last_token.size()} << "'";
-    }
-
     return out.str();
 }
 
