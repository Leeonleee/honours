{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28352,
  "instance_id": "ClickHouse__ClickHouse-28352",
  "issue_numbers": [
    "22621"
  ],
  "base_commit": "122d39cbba40ed3fbb7d9aaf1c1b6b321d7af47c",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex f3f1956c01c8..7f1f5499f5ae 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -24,6 +24,7 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnAggregateFunction.h>\n+#include <Columns/ColumnNullable.h>\n #include \"Core/DecimalFunctions.h\"\n #include \"IFunction.h\"\n #include \"FunctionHelpers.h\"\n@@ -51,7 +52,6 @@\n \n #include <cassert>\n \n-\n namespace DB\n {\n \n@@ -197,18 +197,43 @@ struct BinaryOperation\n     static const constexpr bool allow_string_integer = false;\n \n     template <OpCase op_case>\n-    static void NO_INLINE process(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t size)\n+    static void NO_INLINE process(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t size, const NullMap * right_nullmap = nullptr)\n     {\n-        for (size_t i = 0; i < size; ++i)\n-            if constexpr (op_case == OpCase::Vector)\n-                c[i] = Op::template apply<ResultType>(a[i], b[i]);\n-            else if constexpr (op_case == OpCase::LeftConstant)\n-                c[i] = Op::template apply<ResultType>(*a, b[i]);\n-            else\n+        if constexpr (op_case == OpCase::RightConstant)\n+        {\n+            if (right_nullmap && (*right_nullmap)[0])\n+                return;\n+\n+            for (size_t i = 0; i < size; ++i)\n                 c[i] = Op::template apply<ResultType>(a[i], *b);\n+        }\n+        else\n+        {\n+            if (right_nullmap)\n+            {\n+                for (size_t i = 0; i < size; ++i)\n+                    if ((*right_nullmap)[i])\n+                        c[i] = ResultType();\n+                    else\n+                        apply<op_case>(a, b, c, i);\n+            }\n+            else\n+                for (size_t i = 0; i < size; ++i)\n+                    apply<op_case>(a, b, c, i);\n+        }\n     }\n \n     static ResultType process(A a, B b) { return Op::template apply<ResultType>(a, b); }\n+\n+private:\n+    template <OpCase op_case>\n+    static inline void apply(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t i)\n+    {\n+        if constexpr (op_case == OpCase::Vector)\n+            c[i] = Op::template apply<ResultType>(a[i], b[i]);\n+        else\n+            c[i] = Op::template apply<ResultType>(*a, b[i]);\n+    }\n };\n \n template <typename B, typename Op>\n@@ -371,7 +396,7 @@ struct DecimalBinaryOperation\n public:\n     template <OpCase op_case, bool is_decimal_a, bool is_decimal_b>\n     static void NO_INLINE process(const auto & a, const auto & b, ResultContainerType & c,\n-        NativeResultType scale_a, NativeResultType scale_b)\n+        NativeResultType scale_a, NativeResultType scale_b, const NullMap * right_nullmap = nullptr)\n     {\n         if constexpr (op_case == OpCase::LeftConstant) static_assert(!is_decimal<decltype(a)>);\n         if constexpr (op_case == OpCase::RightConstant) static_assert(!is_decimal<decltype(b)>);\n@@ -428,18 +453,14 @@ struct DecimalBinaryOperation\n         }\n         else if constexpr (is_division && is_decimal_b)\n         {\n-            for (size_t i = 0; i < size; ++i)\n-                c[i] = applyScaledDiv<is_decimal_a>(\n-                    unwrap<op_case, OpCase::LeftConstant>(a, i),\n-                    unwrap<op_case, OpCase::RightConstant>(b, i),\n-                    scale_a);\n+            processWithRightNullmapImpl<op_case>(a, b, c, size, right_nullmap, [&scale_a](const auto & left, const auto & right)\n+            {\n+                return applyScaledDiv<is_decimal_a>(left, right, scale_a);\n+            });\n             return;\n         }\n \n-        for (size_t i = 0; i < size; ++i)\n-            c[i] = apply(\n-                unwrap<op_case, OpCase::LeftConstant>(a, i),\n-                unwrap<op_case, OpCase::RightConstant>(b, i));\n+        processWithRightNullmapImpl<op_case>(a, b, c, size, right_nullmap, [](const auto & left, const auto & right){ return apply(left, right); });\n     }\n \n     template <bool is_decimal_a, bool is_decimal_b, class A, class B>\n@@ -460,6 +481,35 @@ struct DecimalBinaryOperation\n     }\n \n private:\n+    template <OpCase op_case, typename ApplyFunc>\n+    static inline void processWithRightNullmapImpl(const auto & a, const auto & b, ResultContainerType & c, size_t size, const NullMap * right_nullmap, ApplyFunc apply_func)\n+    {\n+        if (right_nullmap)\n+        {\n+            if constexpr (op_case == OpCase::RightConstant)\n+            {\n+                if ((*right_nullmap)[0])\n+                    return;\n+\n+                for (size_t i = 0; i < size; ++i)\n+                    c[i] = apply_func(undec(a[i]), undec(b));\n+            }\n+            else\n+            {\n+                for (size_t i = 0; i < size; ++i)\n+                {\n+                    if ((*right_nullmap)[i])\n+                        c[i] = ResultType();\n+                    else\n+                        c[i] = apply_func(unwrap<op_case, OpCase::LeftConstant>(a, i), undec(b[i]));\n+                }\n+            }\n+        }\n+        else\n+            for (size_t i = 0; i < size; ++i)\n+                c[i] = apply_func(unwrap<op_case, OpCase::LeftConstant>(a, i), unwrap<op_case, OpCase::RightConstant>(b, i));\n+    }\n+\n     static constexpr bool is_plus_minus =   IsOperation<Operation>::plus ||\n                                             IsOperation<Operation>::minus;\n     static constexpr bool is_multiply =     IsOperation<Operation>::multiply;\n@@ -564,7 +614,7 @@ struct DecimalBinaryOperation\n using namespace traits_;\n using namespace impl_;\n \n-template <template <typename, typename> class Op, typename Name, bool valid_on_default_arguments = true, bool valid_on_float_arguments = true>\n+template <template <typename, typename> class Op, typename Name, bool valid_on_default_arguments = true, bool valid_on_float_arguments = true, bool division_by_nullable = false>\n class FunctionBinaryArithmetic : public IFunction\n {\n     static constexpr const bool is_plus = IsOperation<Op>::plus;\n@@ -884,12 +934,12 @@ class FunctionBinaryArithmetic : public IFunction\n     }\n \n     template <OpCase op_case, bool left_decimal, bool right_decimal, typename OpImpl, typename OpImplCheck>\n-    void helperInvokeEither(const auto& left, const auto& right, auto& vec_res, auto scale_a, auto scale_b) const\n+    void helperInvokeEither(const auto& left, const auto& right, auto& vec_res, auto scale_a, auto scale_b, const NullMap * right_nullmap) const\n     {\n         if (check_decimal_overflow)\n-            OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b);\n+            OpImplCheck::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);\n         else\n-            OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b);\n+            OpImpl::template process<op_case, left_decimal, right_decimal>(left, right, vec_res, scale_a, scale_b, right_nullmap);\n     }\n \n     template <class LeftDataType, class RightDataType, class ResultDataType>\n@@ -897,7 +947,7 @@ class FunctionBinaryArithmetic : public IFunction\n         const auto & left, const auto & right,\n         const ColumnConst * const col_left_const, const ColumnConst * const col_right_const,\n         const auto * const col_left, const auto * const col_right,\n-        size_t col_left_size) const\n+        size_t col_left_size, const NullMap * right_nullmap) const\n     {\n         using T0 = typename LeftDataType::FieldType;\n         using T1 = typename RightDataType::FieldType;\n@@ -979,9 +1029,10 @@ class FunctionBinaryArithmetic : public IFunction\n             const NativeResultType const_a = helperGetOrConvert<T0, ResultDataType>(col_left_const, left);\n             const NativeResultType const_b = helperGetOrConvert<T1, ResultDataType>(col_right_const, right);\n \n-            const ResultType res = check_decimal_overflow\n-                ? OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)\n-                : OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b);\n+            ResultType res = {};\n+            if (!right_nullmap || !(*right_nullmap)[0])\n+                res = check_decimal_overflow ? OpImplCheck::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b)\n+                    : OpImpl::template process<left_is_decimal, right_is_decimal>(const_a, const_b, scale_a, scale_b);\n \n             if constexpr (result_is_decimal)\n                 return ResultDataType(type.getPrecision(), type.getScale()).createColumnConst(\n@@ -1001,21 +1052,21 @@ class FunctionBinaryArithmetic : public IFunction\n         if (col_left && col_right)\n         {\n             helperInvokeEither<OpCase::Vector, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n-                col_left->getData(), col_right->getData(), vec_res, scale_a, scale_b);\n+                col_left->getData(), col_right->getData(), vec_res, scale_a, scale_b, right_nullmap);\n         }\n         else if (col_left_const && col_right)\n         {\n             const NativeResultType const_a = helperGetOrConvert<T0, ResultDataType>(col_left_const, left);\n \n             helperInvokeEither<OpCase::LeftConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n-                const_a, col_right->getData(), vec_res, scale_a, scale_b);\n+                const_a, col_right->getData(), vec_res, scale_a, scale_b, right_nullmap);\n         }\n         else if (col_left && col_right_const)\n         {\n             const NativeResultType const_b = helperGetOrConvert<T1, ResultDataType>(col_right_const, right);\n \n             helperInvokeEither<OpCase::RightConstant, left_is_decimal, right_is_decimal, OpImpl, OpImplCheck>(\n-                col_left->getData(), const_b, vec_res, scale_a, scale_b);\n+                col_left->getData(), const_b, vec_res, scale_a, scale_b, right_nullmap);\n         }\n         else\n             return nullptr;\n@@ -1036,6 +1087,14 @@ class FunctionBinaryArithmetic : public IFunction\n \n     size_t getNumberOfArguments() const override { return 2; }\n \n+    bool useDefaultImplementationForNulls() const override\n+    {\n+        /// We shouldn't use default implementation for nulls for the case when operation is divide,\n+        /// intDiv or modulo and denominator is Nullable(Something), because it may cause division\n+        /// by zero error (when value is Null we store default value 0 in nested column).\n+        return !division_by_nullable;\n+    }\n+\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override\n     {\n         return ((IsOperation<Op>::div_int || IsOperation<Op>::modulo) && !arguments[1].is_const)\n@@ -1385,7 +1444,7 @@ class FunctionBinaryArithmetic : public IFunction\n     }\n \n     template <typename A, typename B>\n-    ColumnPtr executeNumeric(const ColumnsWithTypeAndName & arguments, const A & left, const B & right) const\n+    ColumnPtr executeNumeric(const ColumnsWithTypeAndName & arguments, const A & left, const B & right, const NullMap * right_nullmap) const\n     {\n         using LeftDataType = std::decay_t<decltype(left)>;\n         using RightDataType = std::decay_t<decltype(right)>;\n@@ -1420,7 +1479,8 @@ class FunctionBinaryArithmetic : public IFunction\n                     left, right,\n                     col_left_const, col_right_const,\n                     col_left, col_right,\n-                    col_left_size);\n+                    col_left_size,\n+                    right_nullmap);\n             }\n             else // can't avoid else and another indentation level, otherwise the compiler would try to instantiate\n                  // ColVecResult for Decimals which would lead to a compile error.\n@@ -1430,7 +1490,7 @@ class FunctionBinaryArithmetic : public IFunction\n                 /// non-vector result\n                 if (col_left_const && col_right_const)\n                 {\n-                    const auto res = OpImpl::process(\n+                    const auto res = right_nullmap && (*right_nullmap)[0] ? ResultType() : OpImpl::process(\n                         col_left_const->template getValue<T0>(),\n                         col_right_const->template getValue<T1>());\n \n@@ -1448,7 +1508,8 @@ class FunctionBinaryArithmetic : public IFunction\n                         col_left->getData().data(),\n                         col_right->getData().data(),\n                         vec_res.data(),\n-                        vec_res.size());\n+                        vec_res.size(),\n+                        right_nullmap);\n                 }\n                 else if (col_left_const && col_right)\n                 {\n@@ -1458,7 +1519,8 @@ class FunctionBinaryArithmetic : public IFunction\n                         &value,\n                         col_right->getData().data(),\n                         vec_res.data(),\n-                        vec_res.size());\n+                        vec_res.size(),\n+                        right_nullmap);\n                 }\n                 else if (col_left && col_right_const)\n                 {\n@@ -1468,7 +1530,8 @@ class FunctionBinaryArithmetic : public IFunction\n                         col_left->getData().data(),\n                         &value,\n                         vec_res.data(),\n-                        vec_res.size());\n+                        vec_res.size(),\n+                        right_nullmap);\n                 }\n                 else\n                     return nullptr;\n@@ -1493,28 +1556,46 @@ class FunctionBinaryArithmetic : public IFunction\n         }\n \n         /// Special case when the function is plus or minus, one of arguments is Date/DateTime and another is Interval.\n-        if (auto function_builder\n-            = getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context))\n+        if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0].type, arguments[1].type, context))\n         {\n             return executeDateTimeIntervalPlusMinus(arguments, result_type, input_rows_count, function_builder);\n         }\n \n         /// Special case when the function is plus, minus or multiply, both arguments are tuples.\n-        if (auto function_builder\n-            = getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context))\n+        if (auto function_builder = getFunctionForTupleArithmetic(arguments[0].type, arguments[1].type, context))\n         {\n             return function_builder->build(arguments)->execute(arguments, result_type, input_rows_count);\n         }\n \n         /// Special case when the function is multiply or divide, one of arguments is Tuple and another is Number.\n-        if (auto function_builder\n-            = getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context))\n+        if (auto function_builder = getFunctionForTupleAndNumberArithmetic(arguments[0].type, arguments[1].type, context))\n         {\n             return executeTupleNumberOperator(arguments, result_type, input_rows_count, function_builder);\n         }\n \n+        return executeImpl2(arguments, result_type, input_rows_count);\n+    }\n+\n+    ColumnPtr executeImpl2(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, const NullMap * right_nullmap = nullptr) const\n+    {\n         const auto & left_argument = arguments[0];\n         const auto & right_argument = arguments[1];\n+\n+        /// Process special case when operation is divide, intDiv or modulo and denominator\n+        /// is Nullable(Something) to prevent division by zero error.\n+        if (division_by_nullable && !right_nullmap)\n+        {\n+            assert(right_argument.type->isNullable());\n+\n+            bool is_const = checkColumnConst<ColumnNullable>(right_argument.column.get());\n+            const ColumnNullable * nullable_column = is_const ? checkAndGetColumnConstData<ColumnNullable>(right_argument.column.get())\n+                                                              : checkAndGetColumn<ColumnNullable>(*right_argument.column);\n+\n+            const auto & null_bytemap = nullable_column->getNullMapData();\n+            auto res = executeImpl2(createBlockWithNestedColumns(arguments), removeNullable(result_type), input_rows_count, &null_bytemap);\n+            return wrapInNullable(res, arguments, result_type, input_rows_count);\n+        }\n+\n         const auto * const left_generic = left_argument.type.get();\n         const auto * const right_generic = right_argument.type.get();\n         ColumnPtr res;\n@@ -1548,7 +1629,7 @@ class FunctionBinaryArithmetic : public IFunction\n                     return (res = executeStringInteger<ColumnString>(arguments, left, right)) != nullptr;\n             }\n             else\n-                return (res = executeNumeric(arguments, left, right)) != nullptr;\n+                return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;\n         });\n \n         if (!valid)\n@@ -1619,11 +1700,11 @@ class FunctionBinaryArithmetic : public IFunction\n };\n \n \n-template <template <typename, typename> class Op, typename Name, bool valid_on_default_arguments = true, bool valid_on_float_arguments = true>\n-class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>\n+template <template <typename, typename> class Op, typename Name, bool valid_on_default_arguments = true, bool valid_on_float_arguments = true, bool division_by_nullable = false>\n+class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, division_by_nullable>\n {\n public:\n-    using Base = FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>;\n+    using Base = FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, division_by_nullable>;\n     using Monotonicity = typename Base::Monotonicity;\n \n     static FunctionPtr create(\n@@ -1822,22 +1903,37 @@ class BinaryArithmeticOverloadResolver : public IFunctionOverloadResolver\n \n     FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override\n     {\n+        /// Check the case when operation is divide, intDiv or modulo and denominator is Nullable(Something).\n+        /// For divide operation we should check only Nullable(Decimal), because only this case can throw division by zero error.\n+        bool division_by_nullable = !arguments[0].type->onlyNull() && !arguments[1].type->onlyNull() && arguments[1].type->isNullable()\n+            && (IsOperation<Op>::div_int || IsOperation<Op>::modulo\n+                || (IsOperation<Op>::div_floating\n+                    && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type))));\n+\n         /// More efficient specialization for two numeric arguments.\n         if (arguments.size() == 2\n             && ((arguments[0].column && isColumnConst(*arguments[0].column))\n                 || (arguments[1].column && isColumnConst(*arguments[1].column))))\n         {\n+            auto function = division_by_nullable ? FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(\n+                    arguments[0], arguments[1], return_type, context)\n+                : FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(\n+                    arguments[0], arguments[1], return_type, context);\n+\n             return std::make_unique<FunctionToFunctionBaseAdaptor>(\n-                FunctionBinaryArithmeticWithConstants<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::create(\n-                    arguments[0], arguments[1], return_type, context),\n+                function,\n                 collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n                 return_type);\n         }\n+        auto function = division_by_nullable\n+            ? FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, true>::create(context)\n+            : FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments, false>::create(context);\n \n         return std::make_unique<FunctionToFunctionBaseAdaptor>(\n-            FunctionBinaryArithmetic<Op, Name, valid_on_default_arguments, valid_on_float_arguments>::create(context),\n+            function,\n             collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }),\n             return_type);\n+\n     }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\ndiff --git a/src/Functions/intDiv.cpp b/src/Functions/intDiv.cpp\nindex 6b77b2890d46..f2713bb1adbb 100644\n--- a/src/Functions/intDiv.cpp\n+++ b/src/Functions/intDiv.cpp\n@@ -26,16 +26,29 @@ struct DivideIntegralByConstantImpl\n     static const constexpr bool allow_string_integer = false;\n \n     template <OpCase op_case>\n-    static void NO_INLINE process(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t size)\n+    static void NO_INLINE process(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t size, const NullMap * right_nullmap)\n     {\n-        if constexpr (op_case == OpCase::Vector)\n-            for (size_t i = 0; i < size; ++i)\n-                c[i] = Op::template apply<ResultType>(a[i], b[i]);\n-        else if constexpr (op_case == OpCase::LeftConstant)\n-            for (size_t i = 0; i < size; ++i)\n-                c[i] = Op::template apply<ResultType>(*a, b[i]);\n-        else\n+        if constexpr (op_case == OpCase::RightConstant)\n+        {\n+            if (right_nullmap && (*right_nullmap)[0])\n+                return;\n+\n             vectorConstant(a, *b, c, size);\n+        }\n+        else\n+        {\n+            if (right_nullmap)\n+            {\n+                for (size_t i = 0; i < size; ++i)\n+                    if ((*right_nullmap)[i])\n+                        c[i] = ResultType();\n+                    else\n+                        apply<op_case>(a, b, c, i);\n+            }\n+            else\n+                for (size_t i = 0; i < size; ++i)\n+                    apply<op_case>(a, b, c, i);\n+        }\n     }\n \n     static ResultType process(A a, B b) { return Op::template apply<ResultType>(a, b); }\n@@ -69,6 +82,16 @@ struct DivideIntegralByConstantImpl\n \n         divideImpl(a_pos, b, c_pos, size);\n     }\n+\n+private:\n+    template <OpCase op_case>\n+    static inline void apply(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t i)\n+    {\n+        if constexpr (op_case == OpCase::Vector)\n+            c[i] = Op::template apply<ResultType>(a[i], b[i]);\n+        else\n+            c[i] = Op::template apply<ResultType>(*a, b[i]);\n+    }\n };\n \n /** Specializations are specified for dividing numbers of the type UInt64, UInt32, Int64, Int32 by the numbers of the same sign.\ndiff --git a/src/Functions/modulo.cpp b/src/Functions/modulo.cpp\nindex e53f8d16a17f..d494dfca74d1 100644\n--- a/src/Functions/modulo.cpp\n+++ b/src/Functions/modulo.cpp\n@@ -30,16 +30,28 @@ struct ModuloByConstantImpl\n     static const constexpr bool allow_string_integer = false;\n \n     template <OpCase op_case>\n-    static void NO_INLINE process(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t size)\n+    static void NO_INLINE process(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t size, const NullMap * right_nullmap)\n     {\n-        if constexpr (op_case == OpCase::Vector)\n-            for (size_t i = 0; i < size; ++i)\n-                c[i] = Op::template apply<ResultType>(a[i], b[i]);\n-        else if constexpr (op_case == OpCase::LeftConstant)\n-            for (size_t i = 0; i < size; ++i)\n-                c[i] = Op::template apply<ResultType>(*a, b[i]);\n-        else\n+        if constexpr (op_case == OpCase::RightConstant)\n+        {\n+            if (right_nullmap && (*right_nullmap)[0])\n+                return;\n             vectorConstant(a, *b, c, size);\n+        }\n+        else\n+        {\n+            if (right_nullmap)\n+            {\n+                for (size_t i = 0; i < size; ++i)\n+                    if ((*right_nullmap)[i])\n+                        c[i] = ResultType();\n+                    else\n+                        apply<op_case>(a, b, c, i);\n+            }\n+            else\n+                for (size_t i = 0; i < size; ++i)\n+                    apply<op_case>(a, b, c, i);\n+        }\n     }\n \n     static ResultType process(A a, B b) { return Op::template apply<ResultType>(a, b); }\n@@ -95,6 +107,16 @@ struct ModuloByConstantImpl\n                 dst[i] = src[i] & mask;\n         }\n     }\n+\n+private:\n+    template <OpCase op_case>\n+    static inline void apply(const A * __restrict a, const B * __restrict b, ResultType * __restrict c, size_t i)\n+    {\n+        if constexpr (op_case == OpCase::Vector)\n+            c[i] = Op::template apply<ResultType>(a[i], b[i]);\n+        else\n+            c[i] = Op::template apply<ResultType>(*a, b[i]);\n+    }\n };\n \n template <typename A, typename B>\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02015_division_by_nullable.reference b/tests/queries/0_stateless/02015_division_by_nullable.reference\nnew file mode 100644\nindex 000000000000..d85e2a48b713\n--- /dev/null\n+++ b/tests/queries/0_stateless/02015_division_by_nullable.reference\n@@ -0,0 +1,80 @@\n+\\N\n+\\N\n+\\N\n+\\N\n+1\n+1\n+1\n+1\n+\\N\n+\\N\n+\\N\n+\\N\n+1\n+1\n+1\n+1\n+\\N\n+\\N\n+\\N\n+\\N\n+1\n+1\n+1\n+1\n+\\N\n+\\N\n+\\N\n+\\N\n+1\n+1\n+1\n+1\n+\\N\n+\\N\n+\\N\n+\\N\n+0\n+0\n+0\n+0\n+\\N\n+\\N\n+\\N\n+\\N\n+1\n+1\n+1\n+1\n+\\N\n+\\N\n+\\N\n+\\N\n+0\n+0\n+0\n+0\n+1\n+\\N\n+0\n+0\n+\\N\n+0\n+1\n+\\N\n+0\n+1\n+\\N\n+0\n+1\n+\\N\n+0\n+1\n+\\N\n+0\n+1\n+\\N\n+0\n+1\n+\\N\n+0\ndiff --git a/tests/queries/0_stateless/02015_division_by_nullable.sql b/tests/queries/0_stateless/02015_division_by_nullable.sql\nnew file mode 100644\nindex 000000000000..16a010610705\n--- /dev/null\n+++ b/tests/queries/0_stateless/02015_division_by_nullable.sql\n@@ -0,0 +1,101 @@\n+SELECT 1 / CAST(NULL, 'Nullable(Decimal(7, 2))');\n+SELECT materialize(1) / CAST(NULL, 'Nullable(Decimal(7, 2))');\n+SELECT 1 / CAST(materialize(NULL), 'Nullable(Decimal(7, 2))');\n+SELECT materialize(1) / CAST(materialize(NULL), 'Nullable(Decimal(7, 2))');\n+\n+\n+SELECT 1 / CAST(1, 'Nullable(Decimal(7, 2))');\n+SELECT materialize(1) / CAST(1, 'Nullable(Decimal(7, 2))');\n+SELECT 1 / CAST(materialize(1), 'Nullable(Decimal(7, 2))');\n+SELECT materialize(1) / CAST(materialize(1), 'Nullable(Decimal(7, 2))');\n+\n+\n+SELECT intDiv(1, CAST(NULL, 'Nullable(Decimal(7, 2))'));\n+SELECT intDiv(materialize(1), CAST(NULL, 'Nullable(Decimal(7, 2))'));\n+SELECT intDiv(1, CAST(materialize(NULL), 'Nullable(Decimal(7, 2))'));\n+SELECT intDiv(materialize(1), CAST(materialize(NULL), 'Nullable(Decimal(7, 2))'));\n+\n+\n+SELECT intDiv(1, CAST(1, 'Nullable(Decimal(7, 2))'));\n+SELECT intDiv(materialize(1), CAST(1, 'Nullable(Decimal(7, 2))'));\n+SELECT intDiv(1, CAST(materialize(1), 'Nullable(Decimal(7, 2))'));\n+SELECT intDiv(materialize(1), CAST(materialize(1), 'Nullable(Decimal(7, 2))'));\n+\n+\n+SELECT toDecimal32(1, 2) / CAST(NULL, 'Nullable(UInt32)');\n+SELECT materialize(toDecimal32(1, 2)) / CAST(NULL, 'Nullable(UInt32)');\n+SELECT toDecimal32(1, 2) / CAST(materialize(NULL), 'Nullable(UInt32)');\n+SELECT materialize(toDecimal32(1, 2)) / CAST(materialize(NULL), 'Nullable(UInt32)');\n+\n+\n+SELECT toDecimal32(1, 2) / CAST(1, 'Nullable(UInt32)');\n+SELECT materialize(toDecimal32(1, 2)) / CAST(1, 'Nullable(UInt32)');\n+SELECT toDecimal32(1, 2) / CAST(materialize(1), 'Nullable(UInt32)');\n+SELECT materialize(toDecimal32(1, 2)) / CAST(materialize(1), 'Nullable(UInt32)');\n+\n+\n+SELECT intDiv(1, CAST(NULL, 'Nullable(UInt32)'));\n+SELECT intDiv(materialize(1), CAST(NULL, 'Nullable(UInt32)'));\n+SELECT intDiv(1, CAST(materialize(NULL), 'Nullable(UInt32)'));\n+SELECT intDiv(materialize(1), CAST(materialize(NULL), 'Nullable(UInt32)'));\n+\n+\n+SELECT intDiv(1, CAST(1, 'Nullable(UInt32)'));\n+SELECT intDiv(materialize(1), CAST(1, 'Nullable(UInt32)'));\n+SELECT intDiv(1, CAST(materialize(1), 'Nullable(UInt32)'));\n+SELECT intDiv(materialize(1), CAST(materialize(1), 'Nullable(UInt32)'));\n+\n+\n+SELECT 1 % CAST(NULL, 'Nullable(UInt32)');\n+SELECT materialize(1) % CAST(NULL, 'Nullable(UInt32)');\n+SELECT 1 % CAST(materialize(NULL), 'Nullable(UInt32)');\n+SELECT materialize(1) % CAST(materialize(NULL), 'Nullable(UInt32)');\n+\n+\n+SELECT 1 % CAST(1, 'Nullable(UInt32)');\n+SELECT materialize(1) % CAST(1, 'Nullable(UInt32)');\n+SELECT 1 % CAST(materialize(1), 'Nullable(UInt32)');\n+SELECT materialize(1) % CAST(materialize(1), 'Nullable(UInt32)');\n+\n+\n+SELECT intDiv(1, CAST(NULL, 'Nullable(Float32)'));\n+SELECT intDiv(materialize(1), CAST(NULL, 'Nullable(Float32)'));\n+SELECT intDiv(1, CAST(materialize(NULL), 'Nullable(Float32)'));\n+SELECT intDiv(materialize(1), CAST(materialize(NULL), 'Nullable(Float32)'));\n+\n+\n+SELECT intDiv(1, CAST(1, 'Nullable(Float32)'));\n+SELECT intDiv(materialize(1), CAST(1, 'Nullable(Float32)'));\n+SELECT intDiv(1, CAST(materialize(1), 'Nullable(Float32)'));\n+SELECT intDiv(materialize(1), CAST(materialize(1), 'Nullable(Float32)'));\n+\n+\n+SELECT 1 % CAST(NULL, 'Nullable(Float32)');\n+SELECT materialize(1) % CAST(NULL, 'Nullable(Float32)');\n+SELECT 1 % CAST(materialize(NULL), 'Nullable(Float32)');\n+SELECT materialize(1) % CAST(materialize(NULL), 'Nullable(Float32)');\n+\n+\n+SELECT 1 % CAST(1, 'Nullable(Float32)');\n+SELECT materialize(1) % CAST(1, 'Nullable(Float32)');\n+SELECT 1 % CAST(materialize(1), 'Nullable(Float32)');\n+SELECT materialize(1) % CAST(materialize(1), 'Nullable(Float32)');\n+\n+\n+DROP TABLE IF EXISTS nullable_division;\n+CREATE TABLE nullable_division (x UInt32, y Nullable(UInt32), a Decimal(7, 2), b Nullable(Decimal(7, 2))) ENGINE=MergeTree() order by x;\n+INSERT INTO nullable_division VALUES (1, 1, 1, 1), (1, NULL, 1, NULL), (1, 0, 1, 0);\n+\n+SELECT if(y = 0, 0, intDiv(x, y)) from nullable_division;\n+SELECT if(y = 0, 0, x % y) from nullable_division;\n+\n+SELECT if(y = 0, 0, intDiv(a, y)) from nullable_division;\n+SELECT if(y = 0, 0, a / y) from nullable_division;\n+\n+SELECT if(b = 0, 0, intDiv(a, b)) from nullable_division;\n+SELECT if(b = 0, 0, a / b) from nullable_division;\n+\n+SELECT if(b = 0, 0, intDiv(x, b)) from nullable_division;\n+SELECT if(b = 0, 0, x / b) from nullable_division;\n+\n+DROP TABLE nullable_division;\n",
  "problem_statement": "Null in decimal datatype, division by zero.\n**Describe the bug**\r\nThere is a lot of similar reports (https://github.com/ClickHouse/ClickHouse/issues/7509) but they mostly related to https://github.com/ClickHouse/ClickHouse/issues/12587 and If/case statements.\r\n\r\n**How to reproduce**\r\nClickhouse version 21.5\r\n```\r\nSELECT\r\n    1 / CAST(NULL, 'Nullable(UInt32)') AS int,\r\n    1 / CAST(NULL, 'Nullable(UInt32)') AS float\r\n\r\nQuery id: 8f68936f-3ff9-4637-bc63-c19fc71a58ed\r\n\r\n\u250c\u2500\u2500int\u2500\u252c\u2500float\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502  \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT 1 / CAST(NULL, 'Nullable(Decimal(7, 2))')\r\n\r\nQuery id: ed010d6a-4924-4af3-a200-701deeb9d2f4\r\n\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 153. DB::Exception: Received from localhost:9000. DB::Exception: Division by zero: While processing 1 / CAST(NULL, 'Nullable(Decimal(7, 2))').\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2021-08-30T12:15:07Z",
  "modified_files": [
    "src/Functions/FunctionBinaryArithmetic.h",
    "src/Functions/intDiv.cpp",
    "src/Functions/modulo.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02015_division_by_nullable.reference",
    "b/tests/queries/0_stateless/02015_division_by_nullable.sql"
  ]
}