{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12042,
  "instance_id": "ClickHouse__ClickHouse-12042",
  "issue_numbers": [
    "11360"
  ],
  "base_commit": "f1151ed4742cb812b60c7080a607d008ba24c8e4",
  "patch": "diff --git a/src/DataStreams/CheckConstraintsBlockOutputStream.cpp b/src/DataStreams/CheckConstraintsBlockOutputStream.cpp\nindex 8e075e5bf087..7a67074dbdf2 100644\n--- a/src/DataStreams/CheckConstraintsBlockOutputStream.cpp\n+++ b/src/DataStreams/CheckConstraintsBlockOutputStream.cpp\n@@ -3,6 +3,7 @@\n #include <Interpreters/ExpressionActions.h>\n #include <Columns/ColumnsCommon.h>\n #include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnConst.h>\n #include <Common/assert_cast.h>\n #include <Common/quoteString.h>\n #include <Common/FieldVisitors.h>\n@@ -14,6 +15,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int VIOLATED_CONSTRAINT;\n+    extern const int LOGICAL_ERROR;\n }\n \n \n@@ -40,46 +42,72 @@ void CheckConstraintsBlockOutputStream::write(const Block & block)\n         for (size_t i = 0; i < expressions.size(); ++i)\n         {\n             auto constraint_expr = expressions[i];\n-\n             constraint_expr->execute(block_to_calculate);\n+\n+            auto * constraint_ptr = constraints.constraints[i]->as<ASTConstraintDeclaration>();\n+\n             ColumnWithTypeAndName res_column = block_to_calculate.getByPosition(block_to_calculate.columns() - 1);\n-            const ColumnUInt8 & res_column_uint8 = assert_cast<const ColumnUInt8 &>(*res_column.column);\n \n-            const UInt8 * data = res_column_uint8.getData().data();\n-            size_t size = res_column_uint8.size();\n+            if (!isUInt8(res_column.type))\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Constraint {} does not return a value of type UInt8\",\n+                    backQuote(constraint_ptr->name));\n \n-            /// Is violated.\n-            if (!memoryIsByte(data, size, 1))\n+            if (const ColumnConst * res_const = typeid_cast<const ColumnConst *>(res_column.column.get()))\n             {\n-                size_t row_idx = 0;\n-                for (; row_idx < size; ++row_idx)\n-                    if (data[row_idx] != 1)\n-                        break;\n+                UInt8 value = res_const->getValue<UInt64>();\n \n-                Names related_columns = constraint_expr->getRequiredColumns();\n+                /// Is violated.\n+                if (!value)\n+                {\n+                    std::stringstream exception_message;\n \n-                std::stringstream exception_message;\n+                    exception_message << \"Constraint \" << backQuote(constraint_ptr->name)\n+                        << \" for table \" << table_id.getNameForLogs()\n+                        << \" is violated, because it is a constant expression returning 0.\"\n+                        << \" It is most likely an error in table definition.\";\n+\n+                    throw Exception{exception_message.str(), ErrorCodes::VIOLATED_CONSTRAINT};\n+                }\n+            }\n+            else\n+            {\n+                const ColumnUInt8 & res_column_uint8 = assert_cast<const ColumnUInt8 &>(*res_column.column);\n \n-                auto * constraint_ptr = constraints.constraints[i]->as<ASTConstraintDeclaration>();\n-                exception_message << \"Constraint \" << backQuote(constraint_ptr->name)\n-                    << \" for table \" << table_id.getNameForLogs()\n-                    << \" is violated at row \" << (rows_written + row_idx + 1)\n-                    << \". Expression: (\" << serializeAST(*(constraint_ptr->expr), true) << \")\"\n-                    << \". Column values\";\n+                const UInt8 * data = res_column_uint8.getData().data();\n+                size_t size = res_column_uint8.size();\n \n-                bool first = true;\n-                for (const auto & name : related_columns)\n+                /// Is violated.\n+                if (!memoryIsByte(data, size, 1))\n                 {\n-                    const IColumn & column = *block.getByName(name).column;\n-                    assert(row_idx < column.size());\n+                    size_t row_idx = 0;\n+                    for (; row_idx < size; ++row_idx)\n+                        if (data[row_idx] != 1)\n+                            break;\n \n-                    exception_message << (first ? \": \" : \", \")\n-                        << backQuoteIfNeed(name) << \" = \" << applyVisitor(FieldVisitorToString(), column[row_idx]);\n+                    Names related_columns = constraint_expr->getRequiredColumns();\n \n-                    first = false;\n-                }\n+                    std::stringstream exception_message;\n+\n+                    exception_message << \"Constraint \" << backQuote(constraint_ptr->name)\n+                        << \" for table \" << table_id.getNameForLogs()\n+                        << \" is violated at row \" << (rows_written + row_idx + 1)\n+                        << \". Expression: (\" << serializeAST(*(constraint_ptr->expr), true) << \")\"\n+                        << \". Column values\";\n+\n+                    bool first = true;\n+                    for (const auto & name : related_columns)\n+                    {\n+                        const IColumn & column = *block.getByName(name).column;\n+                        assert(row_idx < column.size());\n \n-                throw Exception{exception_message.str(), ErrorCodes::VIOLATED_CONSTRAINT};\n+                        exception_message << (first ? \": \" : \", \")\n+                            << backQuoteIfNeed(name) << \" = \" << applyVisitor(FieldVisitorToString(), column[row_idx]);\n+\n+                        first = false;\n+                    }\n+\n+                    throw Exception{exception_message.str(), ErrorCodes::VIOLATED_CONSTRAINT};\n+                }\n             }\n         }\n     }\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 3e09d728c4cc..503807be0a78 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -325,7 +325,6 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n                 const auto tmp_column_name = final_column_name + \"_tmp\";\n                 const auto * data_type_ptr = column_names_and_types.back().type.get();\n \n-\n                 default_expr_list->children.emplace_back(\n                     setAlias(addTypeConversionToAST(std::make_shared<ASTIdentifier>(tmp_column_name), data_type_ptr->getName()),\n                         final_column_name));\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01358_constexpr_constraint.reference b/tests/queries/0_stateless/01358_constexpr_constraint.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01358_constexpr_constraint.sql b/tests/queries/0_stateless/01358_constexpr_constraint.sql\nnew file mode 100644\nindex 000000000000..799f6f322595\n--- /dev/null\n+++ b/tests/queries/0_stateless/01358_constexpr_constraint.sql\n@@ -0,0 +1,12 @@\n+CREATE TEMPORARY TABLE constrained\n+(\n+    `URL` String,\n+    CONSTRAINT is_yandex CHECK domainWithoutWWW(URL) = domainWithoutWWW(URL),\n+    CONSTRAINT is_utf8 CHECK isValidUTF8(URL)\n+);\n+\n+insert into constrained values ('a');\n+\n+DROP TEMPORARY TABLE constrained;\n+CREATE TEMPORARY TABLE constrained (x UInt8, CONSTRAINT bogus CHECK 0);\n+INSERT INTO constrained VALUES (1); -- { serverError 469 }\n",
  "problem_statement": "Bad cast from type DB::ColumnConst to DB::ColumnVector<char8_t>\n```\r\nATTACH TABLE constrained\r\n(\r\n    `URL` String, \r\n    CONSTRAINT is_yandex CHECK domainWithoutWWW(URL) = domainWithoutWWW(URL), \r\n    CONSTRAINT is_utf8 CHECK isValidUTF8(URL)\r\n)\r\nENGINE = TinyLog;\r\n\r\ninsert into constrained values ('a');\r\n\r\nCode: 368. DB::Exception: Received from localhost:9000. DB::Exception: Bad cast from type DB::ColumnConst to DB::ColumnVector<char8_t>. Stack trace\r\n```\n",
  "hints_text": "You forgot to attach the stack trace.\n> You forgot to attach the stack trace.\r\n\r\nI always skip them for easily reproducible issues (i.e. just copy+paste to clickhouse-client) to reduce visual clutter. Do you find it more convenient to always have the trace? Maybe I should start attaching them even in simple cases.\nIt does not reproduce in release build (that I use on my workstation). But it's easy, I already have the fix.",
  "created_at": "2020-06-29T22:56:34Z",
  "modified_files": [
    "src/DataStreams/CheckConstraintsBlockOutputStream.cpp",
    "src/Interpreters/InterpreterCreateQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01358_constexpr_constraint.sql"
  ]
}