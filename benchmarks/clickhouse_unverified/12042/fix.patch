diff --git a/src/DataStreams/CheckConstraintsBlockOutputStream.cpp b/src/DataStreams/CheckConstraintsBlockOutputStream.cpp
index 8e075e5bf087..7a67074dbdf2 100644
--- a/src/DataStreams/CheckConstraintsBlockOutputStream.cpp
+++ b/src/DataStreams/CheckConstraintsBlockOutputStream.cpp
@@ -3,6 +3,7 @@
 #include <Interpreters/ExpressionActions.h>
 #include <Columns/ColumnsCommon.h>
 #include <Columns/ColumnsNumber.h>
+#include <Columns/ColumnConst.h>
 #include <Common/assert_cast.h>
 #include <Common/quoteString.h>
 #include <Common/FieldVisitors.h>
@@ -14,6 +15,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int VIOLATED_CONSTRAINT;
+    extern const int LOGICAL_ERROR;
 }
 
 
@@ -40,46 +42,72 @@ void CheckConstraintsBlockOutputStream::write(const Block & block)
         for (size_t i = 0; i < expressions.size(); ++i)
         {
             auto constraint_expr = expressions[i];
-
             constraint_expr->execute(block_to_calculate);
+
+            auto * constraint_ptr = constraints.constraints[i]->as<ASTConstraintDeclaration>();
+
             ColumnWithTypeAndName res_column = block_to_calculate.getByPosition(block_to_calculate.columns() - 1);
-            const ColumnUInt8 & res_column_uint8 = assert_cast<const ColumnUInt8 &>(*res_column.column);
 
-            const UInt8 * data = res_column_uint8.getData().data();
-            size_t size = res_column_uint8.size();
+            if (!isUInt8(res_column.type))
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Constraint {} does not return a value of type UInt8",
+                    backQuote(constraint_ptr->name));
 
-            /// Is violated.
-            if (!memoryIsByte(data, size, 1))
+            if (const ColumnConst * res_const = typeid_cast<const ColumnConst *>(res_column.column.get()))
             {
-                size_t row_idx = 0;
-                for (; row_idx < size; ++row_idx)
-                    if (data[row_idx] != 1)
-                        break;
+                UInt8 value = res_const->getValue<UInt64>();
 
-                Names related_columns = constraint_expr->getRequiredColumns();
+                /// Is violated.
+                if (!value)
+                {
+                    std::stringstream exception_message;
 
-                std::stringstream exception_message;
+                    exception_message << "Constraint " << backQuote(constraint_ptr->name)
+                        << " for table " << table_id.getNameForLogs()
+                        << " is violated, because it is a constant expression returning 0."
+                        << " It is most likely an error in table definition.";
+
+                    throw Exception{exception_message.str(), ErrorCodes::VIOLATED_CONSTRAINT};
+                }
+            }
+            else
+            {
+                const ColumnUInt8 & res_column_uint8 = assert_cast<const ColumnUInt8 &>(*res_column.column);
 
-                auto * constraint_ptr = constraints.constraints[i]->as<ASTConstraintDeclaration>();
-                exception_message << "Constraint " << backQuote(constraint_ptr->name)
-                    << " for table " << table_id.getNameForLogs()
-                    << " is violated at row " << (rows_written + row_idx + 1)
-                    << ". Expression: (" << serializeAST(*(constraint_ptr->expr), true) << ")"
-                    << ". Column values";
+                const UInt8 * data = res_column_uint8.getData().data();
+                size_t size = res_column_uint8.size();
 
-                bool first = true;
-                for (const auto & name : related_columns)
+                /// Is violated.
+                if (!memoryIsByte(data, size, 1))
                 {
-                    const IColumn & column = *block.getByName(name).column;
-                    assert(row_idx < column.size());
+                    size_t row_idx = 0;
+                    for (; row_idx < size; ++row_idx)
+                        if (data[row_idx] != 1)
+                            break;
 
-                    exception_message << (first ? ": " : ", ")
-                        << backQuoteIfNeed(name) << " = " << applyVisitor(FieldVisitorToString(), column[row_idx]);
+                    Names related_columns = constraint_expr->getRequiredColumns();
 
-                    first = false;
-                }
+                    std::stringstream exception_message;
+
+                    exception_message << "Constraint " << backQuote(constraint_ptr->name)
+                        << " for table " << table_id.getNameForLogs()
+                        << " is violated at row " << (rows_written + row_idx + 1)
+                        << ". Expression: (" << serializeAST(*(constraint_ptr->expr), true) << ")"
+                        << ". Column values";
+
+                    bool first = true;
+                    for (const auto & name : related_columns)
+                    {
+                        const IColumn & column = *block.getByName(name).column;
+                        assert(row_idx < column.size());
 
-                throw Exception{exception_message.str(), ErrorCodes::VIOLATED_CONSTRAINT};
+                        exception_message << (first ? ": " : ", ")
+                            << backQuoteIfNeed(name) << " = " << applyVisitor(FieldVisitorToString(), column[row_idx]);
+
+                        first = false;
+                    }
+
+                    throw Exception{exception_message.str(), ErrorCodes::VIOLATED_CONSTRAINT};
+                }
             }
         }
     }
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 3e09d728c4cc..503807be0a78 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -325,7 +325,6 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(
                 const auto tmp_column_name = final_column_name + "_tmp";
                 const auto * data_type_ptr = column_names_and_types.back().type.get();
 
-
                 default_expr_list->children.emplace_back(
                     setAlias(addTypeConversionToAST(std::make_shared<ASTIdentifier>(tmp_column_name), data_type_ptr->getName()),
                         final_column_name));
