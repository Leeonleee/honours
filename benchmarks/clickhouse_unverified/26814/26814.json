{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 26814,
  "instance_id": "ClickHouse__ClickHouse-26814",
  "issue_numbers": [
    "26196"
  ],
  "base_commit": "b5dce17707a1fd2572eb2e71d7d496a7244fb2c3",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionArray.cpp b/src/AggregateFunctions/AggregateFunctionArray.cpp\nindex 5ec41fbdd82e..982180ab50cd 100644\n--- a/src/AggregateFunctions/AggregateFunctionArray.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionArray.cpp\n@@ -43,9 +43,9 @@ class AggregateFunctionCombinatorArray final : public IAggregateFunctionCombinat\n         const AggregateFunctionPtr & nested_function,\n         const AggregateFunctionProperties &,\n         const DataTypes & arguments,\n-        const Array &) const override\n+        const Array & params) const override\n     {\n-        return std::make_shared<AggregateFunctionArray>(nested_function, arguments);\n+        return std::make_shared<AggregateFunctionArray>(nested_function, arguments, params);\n     }\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionArray.h b/src/AggregateFunctions/AggregateFunctionArray.h\nindex f1005e2e43a6..e6f2b46c67e9 100644\n--- a/src/AggregateFunctions/AggregateFunctionArray.h\n+++ b/src/AggregateFunctions/AggregateFunctionArray.h\n@@ -29,10 +29,11 @@ class AggregateFunctionArray final : public IAggregateFunctionHelper<AggregateFu\n     size_t num_arguments;\n \n public:\n-    AggregateFunctionArray(AggregateFunctionPtr nested_, const DataTypes & arguments)\n-        : IAggregateFunctionHelper<AggregateFunctionArray>(arguments, {})\n+    AggregateFunctionArray(AggregateFunctionPtr nested_, const DataTypes & arguments, const Array & params_)\n+        : IAggregateFunctionHelper<AggregateFunctionArray>(arguments, params_)\n         , nested_func(nested_), num_arguments(arguments.size())\n     {\n+        assert(parameters == nested_func->getParameters());\n         for (const auto & type : arguments)\n             if (!isArray(type))\n                 throw Exception(\"All arguments for aggregate function \" + getName() + \" must be arrays\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\ndiff --git a/src/AggregateFunctions/AggregateFunctionDistinct.cpp b/src/AggregateFunctions/AggregateFunctionDistinct.cpp\nindex d5e4d421bb13..f224768991b2 100644\n--- a/src/AggregateFunctions/AggregateFunctionDistinct.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionDistinct.cpp\n@@ -34,14 +34,14 @@ class AggregateFunctionCombinatorDistinct final : public IAggregateFunctionCombi\n         const AggregateFunctionPtr & nested_function,\n         const AggregateFunctionProperties &,\n         const DataTypes & arguments,\n-        const Array &) const override\n+        const Array & params) const override\n     {\n         AggregateFunctionPtr res;\n         if (arguments.size() == 1)\n         {\n             res.reset(createWithNumericType<\n                 AggregateFunctionDistinct,\n-                AggregateFunctionDistinctSingleNumericData>(*arguments[0], nested_function, arguments));\n+                AggregateFunctionDistinctSingleNumericData>(*arguments[0], nested_function, arguments, params));\n \n             if (res)\n                 return res;\n@@ -49,14 +49,14 @@ class AggregateFunctionCombinatorDistinct final : public IAggregateFunctionCombi\n             if (arguments[0]->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n                 return std::make_shared<\n                     AggregateFunctionDistinct<\n-                        AggregateFunctionDistinctSingleGenericData<true>>>(nested_function, arguments);\n+                        AggregateFunctionDistinctSingleGenericData<true>>>(nested_function, arguments, params);\n             else\n                 return std::make_shared<\n                     AggregateFunctionDistinct<\n-                        AggregateFunctionDistinctSingleGenericData<false>>>(nested_function, arguments);\n+                        AggregateFunctionDistinctSingleGenericData<false>>>(nested_function, arguments, params);\n         }\n \n-        return std::make_shared<AggregateFunctionDistinct<AggregateFunctionDistinctMultipleGenericData>>(nested_function, arguments);\n+        return std::make_shared<AggregateFunctionDistinct<AggregateFunctionDistinctMultipleGenericData>>(nested_function, arguments, params);\n     }\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionDistinct.h b/src/AggregateFunctions/AggregateFunctionDistinct.h\nindex 9b7853f86656..0f085423bb99 100644\n--- a/src/AggregateFunctions/AggregateFunctionDistinct.h\n+++ b/src/AggregateFunctions/AggregateFunctionDistinct.h\n@@ -167,8 +167,8 @@ class AggregateFunctionDistinct : public IAggregateFunctionDataHelper<Data, Aggr\n     }\n \n public:\n-    AggregateFunctionDistinct(AggregateFunctionPtr nested_func_, const DataTypes & arguments)\n-    : IAggregateFunctionDataHelper<Data, AggregateFunctionDistinct>(arguments, nested_func_->getParameters())\n+    AggregateFunctionDistinct(AggregateFunctionPtr nested_func_, const DataTypes & arguments, const Array & params_)\n+    : IAggregateFunctionDataHelper<Data, AggregateFunctionDistinct>(arguments, params_)\n     , nested_func(nested_func_)\n     , arguments_num(arguments.size()) {}\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionForEach.cpp b/src/AggregateFunctions/AggregateFunctionForEach.cpp\nindex 7b09c7d95da9..cf448d602bfd 100644\n--- a/src/AggregateFunctions/AggregateFunctionForEach.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionForEach.cpp\n@@ -38,9 +38,9 @@ class AggregateFunctionCombinatorForEach final : public IAggregateFunctionCombin\n         const AggregateFunctionPtr & nested_function,\n         const AggregateFunctionProperties &,\n         const DataTypes & arguments,\n-        const Array &) const override\n+        const Array & params) const override\n     {\n-        return std::make_shared<AggregateFunctionForEach>(nested_function, arguments);\n+        return std::make_shared<AggregateFunctionForEach>(nested_function, arguments, params);\n     }\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionForEach.h b/src/AggregateFunctions/AggregateFunctionForEach.h\nindex 66209d8c0f54..084396b24055 100644\n--- a/src/AggregateFunctions/AggregateFunctionForEach.h\n+++ b/src/AggregateFunctions/AggregateFunctionForEach.h\n@@ -105,8 +105,8 @@ class AggregateFunctionForEach final : public IAggregateFunctionDataHelper<Aggre\n     }\n \n public:\n-    AggregateFunctionForEach(AggregateFunctionPtr nested_, const DataTypes & arguments)\n-        : IAggregateFunctionDataHelper<AggregateFunctionForEachData, AggregateFunctionForEach>(arguments, {})\n+    AggregateFunctionForEach(AggregateFunctionPtr nested_, const DataTypes & arguments, const Array & params_)\n+        : IAggregateFunctionDataHelper<AggregateFunctionForEachData, AggregateFunctionForEach>(arguments, params_)\n         , nested_func(nested_), num_arguments(arguments.size())\n     {\n         nested_size_of_data = nested_func->sizeOfData();\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.cpp b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.cpp\nindex 646d03413434..7709357189c9 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.cpp\n@@ -25,8 +25,8 @@ template <typename HasLimit>\n class AggregateFunctionGroupUniqArrayDate : public AggregateFunctionGroupUniqArray<DataTypeDate::FieldType, HasLimit>\n {\n public:\n-    explicit AggregateFunctionGroupUniqArrayDate(const DataTypePtr & argument_type, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n-        : AggregateFunctionGroupUniqArray<DataTypeDate::FieldType, HasLimit>(argument_type, max_elems_) {}\n+    explicit AggregateFunctionGroupUniqArrayDate(const DataTypePtr & argument_type, const Array & parameters_, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n+        : AggregateFunctionGroupUniqArray<DataTypeDate::FieldType, HasLimit>(argument_type, parameters_, max_elems_) {}\n     DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDate>()); }\n };\n \n@@ -34,8 +34,8 @@ template <typename HasLimit>\n class AggregateFunctionGroupUniqArrayDateTime : public AggregateFunctionGroupUniqArray<DataTypeDateTime::FieldType, HasLimit>\n {\n public:\n-    explicit AggregateFunctionGroupUniqArrayDateTime(const DataTypePtr & argument_type, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n-        : AggregateFunctionGroupUniqArray<DataTypeDateTime::FieldType, HasLimit>(argument_type, max_elems_) {}\n+    explicit AggregateFunctionGroupUniqArrayDateTime(const DataTypePtr & argument_type, const Array & parameters_, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n+        : AggregateFunctionGroupUniqArray<DataTypeDateTime::FieldType, HasLimit>(argument_type, parameters_, max_elems_) {}\n     DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDateTime>()); }\n };\n \n@@ -102,9 +102,9 @@ AggregateFunctionPtr createAggregateFunctionGroupUniqArray(\n                         ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n     if (!limit_size)\n-        return createAggregateFunctionGroupUniqArrayImpl<std::false_type>(name, argument_types[0]);\n+        return createAggregateFunctionGroupUniqArrayImpl<std::false_type>(name, argument_types[0], parameters);\n     else\n-        return createAggregateFunctionGroupUniqArrayImpl<std::true_type>(name, argument_types[0], max_elems);\n+        return createAggregateFunctionGroupUniqArrayImpl<std::true_type>(name, argument_types[0], parameters, max_elems);\n }\n \n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h\nindex ccba789483f2..cec160ee21fb 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h\n@@ -48,9 +48,9 @@ class AggregateFunctionGroupUniqArray\n     using State = AggregateFunctionGroupUniqArrayData<T>;\n \n public:\n-    AggregateFunctionGroupUniqArray(const DataTypePtr & argument_type, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n+    AggregateFunctionGroupUniqArray(const DataTypePtr & argument_type, const Array & parameters_, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n         : IAggregateFunctionDataHelper<AggregateFunctionGroupUniqArrayData<T>,\n-          AggregateFunctionGroupUniqArray<T, Tlimit_num_elem>>({argument_type}, {}),\n+          AggregateFunctionGroupUniqArray<T, Tlimit_num_elem>>({argument_type}, parameters_),\n           max_elems(max_elems_) {}\n \n     String getName() const override { return \"groupUniqArray\"; }\n@@ -152,8 +152,8 @@ class AggregateFunctionGroupUniqArrayGeneric\n     using State = AggregateFunctionGroupUniqArrayGenericData;\n \n public:\n-    AggregateFunctionGroupUniqArrayGeneric(const DataTypePtr & input_data_type_, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n-        : IAggregateFunctionDataHelper<AggregateFunctionGroupUniqArrayGenericData, AggregateFunctionGroupUniqArrayGeneric<is_plain_column, Tlimit_num_elem>>({input_data_type_}, {})\n+    AggregateFunctionGroupUniqArrayGeneric(const DataTypePtr & input_data_type_, const Array & parameters_, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n+        : IAggregateFunctionDataHelper<AggregateFunctionGroupUniqArrayGenericData, AggregateFunctionGroupUniqArrayGeneric<is_plain_column, Tlimit_num_elem>>({input_data_type_}, parameters_)\n         , input_data_type(this->argument_types[0])\n         , max_elems(max_elems_) {}\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.cpp b/src/AggregateFunctions/AggregateFunctionIf.cpp\nindex c074daf45be6..d841fe8c06dc 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionIf.cpp\n@@ -35,9 +35,9 @@ class AggregateFunctionCombinatorIf final : public IAggregateFunctionCombinator\n         const AggregateFunctionPtr & nested_function,\n         const AggregateFunctionProperties &,\n         const DataTypes & arguments,\n-        const Array &) const override\n+        const Array & params) const override\n     {\n-        return std::make_shared<AggregateFunctionIf>(nested_function, arguments);\n+        return std::make_shared<AggregateFunctionIf>(nested_function, arguments, params);\n     }\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.h b/src/AggregateFunctions/AggregateFunctionIf.h\nindex 153c80e87b25..79999437ca1c 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.h\n+++ b/src/AggregateFunctions/AggregateFunctionIf.h\n@@ -37,8 +37,8 @@ class AggregateFunctionIf final : public IAggregateFunctionHelper<AggregateFunct\n     size_t num_arguments;\n \n public:\n-    AggregateFunctionIf(AggregateFunctionPtr nested, const DataTypes & types)\n-        : IAggregateFunctionHelper<AggregateFunctionIf>(types, nested->getParameters())\n+    AggregateFunctionIf(AggregateFunctionPtr nested, const DataTypes & types, const Array & params_)\n+        : IAggregateFunctionHelper<AggregateFunctionIf>(types, params_)\n         , nested_func(nested), num_arguments(types.size())\n     {\n         if (num_arguments == 0)\ndiff --git a/src/AggregateFunctions/AggregateFunctionMerge.cpp b/src/AggregateFunctions/AggregateFunctionMerge.cpp\nindex a19a21fd4a45..cdf399585f50 100644\n--- a/src/AggregateFunctions/AggregateFunctionMerge.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionMerge.cpp\n@@ -39,7 +39,7 @@ class AggregateFunctionCombinatorMerge final : public IAggregateFunctionCombinat\n         const AggregateFunctionPtr & nested_function,\n         const AggregateFunctionProperties &,\n         const DataTypes & arguments,\n-        const Array &) const override\n+        const Array & params) const override\n     {\n         const DataTypePtr & argument = arguments[0];\n \n@@ -53,7 +53,7 @@ class AggregateFunctionCombinatorMerge final : public IAggregateFunctionCombinat\n                 + \", because it corresponds to different aggregate function: \" + function->getFunctionName() + \" instead of \" + nested_function->getName(),\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        return std::make_shared<AggregateFunctionMerge>(nested_function, argument);\n+        return std::make_shared<AggregateFunctionMerge>(nested_function, argument, params);\n     }\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionMerge.h b/src/AggregateFunctions/AggregateFunctionMerge.h\nindex 3bb482e4ac9f..0451c4a1118e 100644\n--- a/src/AggregateFunctions/AggregateFunctionMerge.h\n+++ b/src/AggregateFunctions/AggregateFunctionMerge.h\n@@ -29,8 +29,8 @@ class AggregateFunctionMerge final : public IAggregateFunctionHelper<AggregateFu\n     AggregateFunctionPtr nested_func;\n \n public:\n-    AggregateFunctionMerge(const AggregateFunctionPtr & nested_, const DataTypePtr & argument)\n-        : IAggregateFunctionHelper<AggregateFunctionMerge>({argument}, nested_->getParameters())\n+    AggregateFunctionMerge(const AggregateFunctionPtr & nested_, const DataTypePtr & argument, const Array & params_)\n+        : IAggregateFunctionHelper<AggregateFunctionMerge>({argument}, params_)\n         , nested_func(nested_)\n     {\n         const DataTypeAggregateFunction * data_type = typeid_cast<const DataTypeAggregateFunction *>(argument.get());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01156_pcg_deserialization.reference b/tests/queries/0_stateless/01156_pcg_deserialization.reference\nindex e43b7ca3cebc..a41bc53d840a 100644\n--- a/tests/queries/0_stateless/01156_pcg_deserialization.reference\n+++ b/tests/queries/0_stateless/01156_pcg_deserialization.reference\n@@ -1,3 +1,6 @@\n 5\t5\n 5\t5\n 5\t5\n+5\t5\n+5\t5\n+5\t5\ndiff --git a/tests/queries/0_stateless/01156_pcg_deserialization.sh b/tests/queries/0_stateless/01156_pcg_deserialization.sh\nindex 9c8ac29f32e3..00ef86dce9cc 100755\n--- a/tests/queries/0_stateless/01156_pcg_deserialization.sh\n+++ b/tests/queries/0_stateless/01156_pcg_deserialization.sh\n@@ -4,16 +4,20 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n # shellcheck source=../shell_config.sh\n . \"$CURDIR\"/../shell_config.sh\n \n+declare -a functions=(\"groupArraySample\" \"groupUniqArray\")\n declare -a engines=(\"Memory\" \"MergeTree order by n\" \"Log\")\n \n-for engine in \"${engines[@]}\"\n+for func in \"${functions[@]}\"\n do\n-  $CLICKHOUSE_CLIENT -q \"drop table if exists t\";\n-  $CLICKHOUSE_CLIENT -q \"create table t (n UInt8, a1 AggregateFunction(groupArraySample(1), UInt8)) engine=$engine\"\n-  $CLICKHOUSE_CLIENT -q \"insert into t select number % 5 as n, groupArraySampleState(1)(toUInt8(number)) from numbers(10) group by n\"\n+  for engine in \"${engines[@]}\"\n+  do\n+    $CLICKHOUSE_CLIENT -q \"drop table if exists t\";\n+    $CLICKHOUSE_CLIENT -q \"create table t (n UInt8, a1 AggregateFunction($func(1), UInt8)) engine=$engine\"\n+    $CLICKHOUSE_CLIENT -q \"insert into t select number % 5 as n, ${func}State(1)(toUInt8(number)) from numbers(10) group by n\"\n \n-  $CLICKHOUSE_CLIENT -q \"select * from t format TSV\" | $CLICKHOUSE_CLIENT -q \"insert into t format TSV\"\n-  $CLICKHOUSE_CLIENT -q \"select countDistinct(n), countDistinct(a1) from t\"\n+    $CLICKHOUSE_CLIENT -q \"select * from t format TSV\" | $CLICKHOUSE_CLIENT -q \"insert into t format TSV\"\n+    $CLICKHOUSE_CLIENT -q \"select countDistinct(n), countDistinct(a1) from t\"\n \n-  $CLICKHOUSE_CLIENT -q \"drop table t\";\n+    $CLICKHOUSE_CLIENT -q \"drop table t\";\n+  done\n done\ndiff --git a/tests/queries/0_stateless/01159_combinators_with_parameters.reference b/tests/queries/0_stateless/01159_combinators_with_parameters.reference\nnew file mode 100644\nindex 000000000000..cc0cb604bf37\n--- /dev/null\n+++ b/tests/queries/0_stateless/01159_combinators_with_parameters.reference\n@@ -0,0 +1,20 @@\n+AggregateFunction(topKArray(10), Array(String))\n+AggregateFunction(topKDistinct(10), String)\n+AggregateFunction(topKForEach(10), Array(String))\n+AggregateFunction(topKIf(10), String, UInt8)\n+AggregateFunction(topK(10), String)\n+AggregateFunction(topKOrNull(10), String)\n+AggregateFunction(topKOrDefault(10), String)\n+AggregateFunction(topKResample(10, 1, 2, 42), String, UInt64)\n+AggregateFunction(topK(10), String)\n+AggregateFunction(topKArrayResampleOrDefaultIf(10, 1, 2, 42), Array(String), UInt64, UInt8)\n+10\n+10\n+[10]\n+11\n+10\n+10\n+10\n+[1]\n+10\n+[1]\ndiff --git a/tests/queries/0_stateless/01159_combinators_with_parameters.sql b/tests/queries/0_stateless/01159_combinators_with_parameters.sql\nnew file mode 100644\nindex 000000000000..69508d8e304c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01159_combinators_with_parameters.sql\n@@ -0,0 +1,43 @@\n+SELECT toTypeName(topKArrayState(10)([toString(number)])) FROM numbers(100);\n+SELECT toTypeName(topKDistinctState(10)(toString(number))) FROM numbers(100);\n+SELECT toTypeName(topKForEachState(10)([toString(number)])) FROM numbers(100);\n+SELECT toTypeName(topKIfState(10)(toString(number), number % 2)) FROM numbers(100);\n+SELECT toTypeName(topKMergeState(10)(state)) FROM (SELECT topKState(10)(toString(number)) as state FROM numbers(100));\n+SELECT toTypeName(topKOrNullState(10)(toString(number))) FROM numbers(100);\n+SELECT toTypeName(topKOrDefaultState(10)(toString(number))) FROM numbers(100);\n+SELECT toTypeName(topKResampleState(10, 1, 2, 42)(toString(number), number)) FROM numbers(100);\n+SELECT toTypeName(topKState(10)(toString(number))) FROM numbers(100);\n+SELECT toTypeName(topKArrayResampleOrDefaultIfState(10, 1, 2, 42)([toString(number)], number, number % 2)) FROM numbers(100);\n+\n+CREATE TEMPORARY TABLE t0 AS SELECT quantileArrayState(0.10)([number]) FROM numbers(100);\n+CREATE TEMPORARY TABLE t1 AS SELECT quantileDistinctState(0.10)(number) FROM numbers(100);\n+CREATE TEMPORARY TABLE t2 AS SELECT quantileForEachState(0.10)([number]) FROM numbers(100);\n+CREATE TEMPORARY TABLE t3 AS SELECT quantileIfState(0.10)(number, number % 2) FROM numbers(100);\n+CREATE TEMPORARY TABLE t4 AS SELECT quantileMergeState(0.10)(state) FROM (SELECT quantileState(0.10)(number) as state FROM numbers(100));\n+CREATE TEMPORARY TABLE t5 AS SELECT quantileOrNullState(0.10)(number) FROM numbers(100);\n+CREATE TEMPORARY TABLE t6 AS SELECT quantileOrDefaultState(0.10)(number) FROM numbers(100);\n+CREATE TEMPORARY TABLE t7 AS SELECT quantileResampleState(0.10, 1, 2, 42)(number, number) FROM numbers(100);\n+CREATE TEMPORARY TABLE t8 AS SELECT quantileState(0.10)(number) FROM numbers(100);\n+CREATE TEMPORARY TABLE t9 AS SELECT quantileArrayResampleOrDefaultIfState(0.10, 1, 2, 42)([number], number, number % 2) FROM numbers(100);\n+\n+INSERT INTO t0 SELECT quantileArrayState(0.10)([number]) FROM numbers(100);\n+INSERT INTO t1 SELECT quantileDistinctState(0.10)(number) FROM numbers(100);\n+INSERT INTO t2 SELECT quantileForEachState(0.10)([number]) FROM numbers(100);\n+INSERT INTO t3 SELECT quantileIfState(0.10)(number, number % 2) FROM numbers(100);\n+INSERT INTO t4 SELECT quantileMergeState(0.10)(state) FROM (SELECT quantileState(0.10)(number) as state FROM numbers(100));\n+INSERT INTO t5 SELECT quantileOrNullState(0.10)(number) FROM numbers(100);\n+INSERT INTO t6 SELECT quantileOrDefaultState(0.10)(number) FROM numbers(100);\n+INSERT INTO t7 SELECT quantileResampleState(0.10, 1, 2, 42)(number, number) FROM numbers(100);\n+INSERT INTO t8 SELECT quantileState(0.10)(number) FROM numbers(100);\n+INSERT INTO t9 SELECT quantileArrayResampleOrDefaultIfState(0.10, 1, 2, 42)([number], number, number % 2) FROM numbers(100);\n+\n+SELECT round(quantileArrayMerge(0.10)((*,).1)) FROM t0;\n+SELECT round(quantileDistinctMerge(0.10)((*,).1)) FROM t1;\n+SELECT arrayMap(x -> round(x), quantileForEachMerge(0.10)((*,).1)) FROM t2;\n+SELECT round(quantileIfMerge(0.10)((*,).1)) FROM t3;\n+SELECT round(quantileMerge(0.10)((*,).1)) FROM t4;\n+SELECT round(quantileOrNullMerge(0.10)((*,).1)) FROM t5;\n+SELECT round(quantileOrDefaultMerge(0.10)((*,).1)) FROM t6;\n+SELECT arrayMap(x -> round(x), quantileResampleMerge(0.10, 1, 2, 42)((*,).1)) FROM t7;\n+SELECT round(quantileMerge(0.10)((*,).1)) FROM t8;\n+SELECT arrayMap(x -> round(x), quantileArrayResampleOrDefaultIfMerge(0.10, 1, 2, 42)((*,).1)) FROM t9;\n",
  "problem_statement": "21.5.8, 21.6 & 21.7 break *Array aggregation types\nUpdating existing table to 21.6 and 21.7 breaks *Array aggregation types. The table contains mater view with the following column\r\n\r\n````\r\nstrings AggregateFunction(topKArray(10), Array(String)),\r\n````\r\n\r\nWhen trying to insert into the table I get the following error:\r\n\r\n```\r\nConversion from AggregateFunction(topKArray, Array(String)) to AggregateFunction(topKArray(10), Array(String)) is not supported\r\n```\r\n\r\nAs you see the type has changed from `topKArray(10)` to `topKArray`. I can update the mater view schema to use the new type and the problem goes away, but it is not clear whether this change was intentional because only `*Array` agg functions are affected.\r\n\r\nIt is the same with `groupUniqArrayArray` and even worse, because I can't cast `groupUniqArrayArray(1000)` to `groupUniqArrayArray`:\r\n\r\n```\r\nMODIFY COLUMN strings AggregateFunction(groupUniqArrayArray, Array(String))\r\n\r\nConversion from AggregateFunction(groupUniqArrayArray(1000), Array(String)) to AggregateFunction(groupUniqArrayArray, Array(String)) is not supported\r\n```\r\n\r\nThe last working version is 21.5.7.9. The next 21.5.8 version is broken.\n",
  "hints_text": "To reproduce create a table:\r\n\r\n```sql\r\nCREATE TABLE test (\r\n  strings AggregateFunction(topKArray(10), Array(String))\r\n)\r\nENGINE = SummingMergeTree()\r\nPARTITION BY tuple()\r\nORDER BY tuple()\r\n```\r\n\r\nAnd execute:\r\n\r\n```sql\r\nINSERT INTO test SELECT topKArrayState(10)([toString(number)])\r\nFROM numbers(100)\r\n\r\nQuery id: 50ea28dc-02b6-402b-9902-0e1d3ceaf6fe\r\n\r\n\r\n0 rows in set. Elapsed: 0.005 sec. \r\n\r\nReceived exception from server (version 21.7.2):\r\nCode: 70. DB::Exception: Received from localhost:9000. DB::Exception: Conversion from AggregateFunction(topKArray, Array(String)) to AggregateFunction(topKArray(10), Array(String)) is not supported: while converting source column `topKArrayState(10)(array(toString(number)))` to destination column strings.\r\n```\r\n\r\nThe same queries work on 21.5.7.9. but fail on versions starting from 21.5.8",
  "created_at": "2021-07-26T15:04:45Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionArray.cpp",
    "src/AggregateFunctions/AggregateFunctionArray.h",
    "src/AggregateFunctions/AggregateFunctionDistinct.cpp",
    "src/AggregateFunctions/AggregateFunctionDistinct.h",
    "src/AggregateFunctions/AggregateFunctionForEach.cpp",
    "src/AggregateFunctions/AggregateFunctionForEach.h",
    "src/AggregateFunctions/AggregateFunctionGroupUniqArray.cpp",
    "src/AggregateFunctions/AggregateFunctionGroupUniqArray.h",
    "src/AggregateFunctions/AggregateFunctionIf.cpp",
    "src/AggregateFunctions/AggregateFunctionIf.h",
    "src/AggregateFunctions/AggregateFunctionMerge.cpp",
    "src/AggregateFunctions/AggregateFunctionMerge.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01156_pcg_deserialization.reference",
    "tests/queries/0_stateless/01156_pcg_deserialization.sh",
    "b/tests/queries/0_stateless/01159_combinators_with_parameters.reference",
    "b/tests/queries/0_stateless/01159_combinators_with_parameters.sql"
  ]
}