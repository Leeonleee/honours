diff --git a/src/Functions/GeoHash.cpp b/src/Functions/GeoHash.cpp
index e59cf160ce12..7fdeb52b15c9 100644
--- a/src/Functions/GeoHash.cpp
+++ b/src/Functions/GeoHash.cpp
@@ -3,6 +3,7 @@
 #include <cassert>
 #include <Functions/GeoHash.h>
 
+
 namespace DB
 {
 
@@ -260,15 +261,21 @@ void geohashDecode(const char * encoded_string, size_t encoded_len, Float64 * lo
     *latitude = decodeCoordinate(lat_encoded, LAT_MIN, LAT_MAX, singleCoordBitsPrecision(precision, LATITUDE));
 }
 
-GeohashesInBoxPreparedArgs geohashesInBoxPrepare(Float64 longitude_min,
-                                              Float64 latitude_min,
-                                              Float64 longitude_max,
-                                              Float64 latitude_max,
-                                              uint8_t precision)
+GeohashesInBoxPreparedArgs geohashesInBoxPrepare(
+    Float64 longitude_min,
+    Float64 latitude_min,
+    Float64 longitude_max,
+    Float64 latitude_max,
+    uint8_t precision)
 {
     precision = geohashPrecision(precision);
 
-    if (longitude_max < longitude_min || latitude_max < latitude_min)
+    if (longitude_max < longitude_min
+        || latitude_max < latitude_min
+        || std::isnan(longitude_min)
+        || std::isnan(longitude_max)
+        || std::isnan(latitude_min)
+        || std::isnan(latitude_max))
     {
         return {};
     }
@@ -281,51 +288,50 @@ GeohashesInBoxPreparedArgs geohashesInBoxPrepare(Float64 longitude_min,
     const auto lon_step = getSpan(precision, LONGITUDE);
     const auto lat_step = getSpan(precision, LATITUDE);
 
-    // align max to the right(or up) border of geohash grid cell to ensure that cell is in result.
+    /// Align max to the right (or up) border of geohash grid cell to ensure that cell is in result.
     Float64 lon_min = floor(longitude_min / lon_step) * lon_step;
     Float64 lat_min = floor(latitude_min / lat_step) * lat_step;
     Float64 lon_max = ceil(longitude_max / lon_step) * lon_step;
     Float64 lat_max = ceil(latitude_max / lat_step) * lat_step;
 
-    const auto lon_span = lon_max - lon_min;
-    const auto lat_span = lat_max - lat_min;
-    // in case of a very small (or zero) span, produce at least 1 item.
-    const auto items_count = std::max(size_t{1}, static_cast<size_t>(ceil(lon_span/lon_step * lat_span/lat_step)));
-
-    return GeohashesInBoxPreparedArgs{
-            items_count,
-            precision,
-            lon_min,
-            lat_min,
-            lon_max,
-            lat_max,
-            lon_step,
-            lat_step
+    UInt32 lon_items = (lon_max - lon_min) / lon_step;
+    UInt32 lat_items = (lat_max - lat_min) / lat_step;
+
+    return GeohashesInBoxPreparedArgs
+    {
+        std::max<UInt64>(1, UInt64(lon_items) * lat_items),
+        lon_items,
+        lat_items,
+        lon_min,
+        lat_min,
+        lon_step,
+        lat_step,
+        precision
     };
 }
 
 UInt64 geohashesInBox(const GeohashesInBoxPreparedArgs & args, char * out)
 {
-    if (args.items_count == 0
-            || args.precision == 0
-            || args.precision > MAX_PRECISION
-            || args.latitude_min > args.latitude_max
-            || args.longitude_min > args.longitude_max
-            || args.longitude_step <= 0
-            || args.latitude_step <= 0)
+    if (args.precision == 0
+        || args.precision > MAX_PRECISION
+        || args.longitude_step <= 0
+        || args.latitude_step <= 0)
     {
         return 0;
     }
 
     UInt64 items = 0;
-    for (auto lon = args.longitude_min; lon < args.longitude_max; lon += args.longitude_step) // NOLINT
+    for (size_t i = 0; i < args.longitude_items; ++i)
     {
-        for (auto lat = args.latitude_min; lat < args.latitude_max; lat += args.latitude_step) // NOLINT
+        for (size_t j = 0; j < args.latitude_items; ++j)
         {
-            assert(items <= args.items_count);
+            size_t length = geohashEncodeImpl(
+                args.longitude_min + args.longitude_step * i,
+                args.latitude_min + args.latitude_step * j,
+                args.precision,
+                out);
 
-            size_t l = geohashEncodeImpl(lon, lat, args.precision, out);
-            out += l;
+            out += length;
             *out = '\0';
             ++out;
 
@@ -335,8 +341,8 @@ UInt64 geohashesInBox(const GeohashesInBoxPreparedArgs & args, char * out)
 
     if (items == 0)
     {
-        size_t l = geohashEncodeImpl(args.longitude_min, args.latitude_min, args.precision, out);
-        out += l;
+        size_t length = geohashEncodeImpl(args.longitude_min, args.latitude_min, args.precision, out);
+        out += length;
         *out = '\0';
         ++out;
 
diff --git a/src/Functions/GeoHash.h b/src/Functions/GeoHash.h
index e1e44a9d9087..105384d714c2 100644
--- a/src/Functions/GeoHash.h
+++ b/src/Functions/GeoHash.h
@@ -23,15 +23,17 @@ std::vector<std::pair<Float64, Float64>> geohashCoverBox(
 struct GeohashesInBoxPreparedArgs
 {
     UInt64 items_count = 0;
-    uint8_t precision = 0;
+
+    UInt32 longitude_items = 0;
+    UInt32 latitude_items = 0;
 
     Float64 longitude_min = 0.0;
     Float64 latitude_min = 0.0;
-    Float64 longitude_max = 0.0;
-    Float64 latitude_max = 0.0;
 
     Float64 longitude_step = 0.0;
     Float64 latitude_step = 0.0;
+
+    uint8_t precision = 0;
 };
 
 GeohashesInBoxPreparedArgs geohashesInBoxPrepare(
diff --git a/src/Functions/geohashesInBox.cpp b/src/Functions/geohashesInBox.cpp
index 6bf0e5a82cd0..a3f7f8bd58e9 100644
--- a/src/Functions/geohashesInBox.cpp
+++ b/src/Functions/geohashesInBox.cpp
@@ -11,6 +11,7 @@
 #include <memory>
 #include <string>
 
+
 namespace DB
 {
 
@@ -121,9 +122,7 @@ class FunctionGeohashesInBox : public IFunction
             geohashesInBox(prepared_args, out);
 
             for (UInt64 i = 1; i <= prepared_args.items_count ; ++i)
-            {
                 res_strings_offsets.push_back(starting_offset + (prepared_args.precision + 1) * i);
-            }
             res_offsets.push_back((res_offsets.empty() ? 0 : res_offsets.back()) + prepared_args.items_count);
         }
         if (!res_strings_offsets.empty() && res_strings_offsets.back() != res_strings_chars.size())
