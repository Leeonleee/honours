diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp
index e39a9fb5750f..f16e1a8883b7 100644
--- a/src/Interpreters/ActionsDAG.cpp
+++ b/src/Interpreters/ActionsDAG.cpp
@@ -2485,12 +2485,13 @@ ColumnsWithTypeAndName prepareFunctionArguments(const ActionsDAG::NodeRawConstPt
 ///
 /// Result actions add single column with conjunction result (it is always first in outputs).
 /// No other columns are added or removed.
-std::optional<ActionsDAG> ActionsDAG::createActionsForConjunction(NodeRawConstPtrs conjunction, const ColumnsWithTypeAndName & all_inputs)
+std::optional<ActionsDAG::ActionsForFilterPushDown> ActionsDAG::createActionsForConjunction(NodeRawConstPtrs conjunction, const ColumnsWithTypeAndName & all_inputs)
 {
     if (conjunction.empty())
         return {};
 
     ActionsDAG actions;
+    bool remove_filter = true;
 
     FunctionOverloadResolverPtr func_builder_and = std::make_unique<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionAnd>());
 
@@ -2557,7 +2558,8 @@ std::optional<ActionsDAG> ActionsDAG::createActionsForConjunction(NodeRawConstPt
         result_predicate = &actions.addFunction(func_builder_and, std::move(args), {});
     }
 
-    actions.outputs.push_back(result_predicate);
+    size_t filter_pos = 0;
+    bool has_input_name_collision = false;
 
     for (const auto & col : all_inputs)
     {
@@ -2573,14 +2575,39 @@ std::optional<ActionsDAG> ActionsDAG::createActionsForConjunction(NodeRawConstPt
         }
 
         /// We should not add result_predicate into the outputs for the second time.
-        if (input->result_name != result_predicate->result_name)
-            actions.outputs.push_back(input);
+        /// If the predicate is an input, do not remove it.
+        if (input == result_predicate)
+        {
+            remove_filter = false;
+            filter_pos = actions.outputs.size();
+        }
+        /// Predicate name has a collision with another node. Need to rename it.
+        else if (input->result_name == result_predicate->result_name)
+            has_input_name_collision = true;
+
+        actions.outputs.push_back(input);
     }
 
-    return actions;
+    if (has_input_name_collision)
+    {
+        for (size_t idx = 0;; ++idx)
+        {
+            std::string rename = fmt::format("_filter_{}_{}", result_predicate->result_name, idx);
+            if (required_inputs.contains(rename))
+                continue;
+
+            result_predicate = &actions.addAlias(*result_predicate, std::move(rename));
+            break;
+        }
+    }
+
+    if (remove_filter)
+        actions.outputs.insert(actions.outputs.begin(), result_predicate);
+
+    return ActionsForFilterPushDown{std::move(actions), filter_pos, remove_filter};
 }
 
-std::optional<ActionsDAG> ActionsDAG::splitActionsForFilterPushDown(
+std::optional<ActionsDAG::ActionsForFilterPushDown> ActionsDAG::splitActionsForFilterPushDown(
     const std::string & filter_name,
     bool removes_filter,
     const Names & available_inputs,
@@ -2744,12 +2771,14 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu
     auto left_stream_filter_to_push_down = createActionsForConjunction(left_stream_allowed_conjunctions, left_stream_header.getColumnsWithTypeAndName());
     auto right_stream_filter_to_push_down = createActionsForConjunction(right_stream_allowed_conjunctions, right_stream_header.getColumnsWithTypeAndName());
 
-    auto replace_equivalent_columns_in_filter = [](const ActionsDAG & filter,
+    auto replace_equivalent_columns_in_filter = [](
+        const ActionsDAG & filter,
+        size_t filter_pos,
         const Block & stream_header,
         const std::unordered_map<std::string, ColumnWithTypeAndName> & columns_to_replace)
     {
-        auto updated_filter = ActionsDAG::buildFilterActionsDAG({filter.getOutputs()[0]}, columns_to_replace);
-        chassert(updated_filter->getOutputs().size() == 1);
+        auto updated_filter = *ActionsDAG::buildFilterActionsDAG({filter.getOutputs()[filter_pos]}, columns_to_replace);
+        chassert(updated_filter.getOutputs().size() == 1);
 
         /** If result filter to left or right stream has column that is one of the stream inputs, we need distinguish filter column from
           * actual input column. It is necessary because after filter step, filter column became constant column with value 1, and
@@ -2757,16 +2786,16 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu
           *
           * Example: SELECT key FROM ( SELECT key FROM t1 ) AS t1 JOIN ( SELECT key FROM t1 ) AS t2 ON t1.key = t2.key WHERE key;
           */
-        const auto * stream_filter_node = updated_filter->getOutputs()[0];
+        const auto * stream_filter_node = updated_filter.getOutputs()[0];
         if (stream_header.has(stream_filter_node->result_name))
         {
-            const auto & alias_node = updated_filter->addAlias(*stream_filter_node, "__filter" + stream_filter_node->result_name);
-            updated_filter->getOutputs()[0] = &alias_node;
+            const auto & alias_node = updated_filter.addAlias(*stream_filter_node, "__filter" + stream_filter_node->result_name);
+            updated_filter.getOutputs()[0] = &alias_node;
         }
 
         std::unordered_map<std::string, std::list<const Node *>> updated_filter_inputs;
 
-        for (const auto & input : updated_filter->getInputs())
+        for (const auto & input : updated_filter.getInputs())
             updated_filter_inputs[input->result_name].push_back(input);
 
         for (const auto & input : filter.getInputs())
@@ -2778,9 +2807,9 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu
 
             auto it = columns_to_replace.find(input->result_name);
             if (it != columns_to_replace.end())
-                updated_filter_input_node = &updated_filter->addInput(it->second);
+                updated_filter_input_node = &updated_filter.addInput(it->second);
             else
-                updated_filter_input_node = &updated_filter->addInput({input->column, input->result_type, input->result_name});
+                updated_filter_input_node = &updated_filter.addInput({input->column, input->result_type, input->result_name});
 
             updated_filter_inputs[input->result_name].push_back(updated_filter_input_node);
         }
@@ -2791,7 +2820,7 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu
             auto & list = updated_filter_inputs[input_column.name];
             if (list.empty())
             {
-                input = &updated_filter->addInput(input_column);
+                input = &updated_filter.addInput(input_column);
             }
             else
             {
@@ -2799,20 +2828,22 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu
                 list.pop_front();
             }
 
-            if (input != updated_filter->getOutputs()[0])
-                updated_filter->outputs.push_back(input);
+            if (input != updated_filter.getOutputs()[0])
+                updated_filter.outputs.push_back(input);
         }
 
         return updated_filter;
     };
 
     if (left_stream_filter_to_push_down)
-        left_stream_filter_to_push_down = replace_equivalent_columns_in_filter(*left_stream_filter_to_push_down,
+        left_stream_filter_to_push_down->dag = replace_equivalent_columns_in_filter(left_stream_filter_to_push_down->dag,
+            left_stream_filter_to_push_down->filter_pos,
             left_stream_header,
             equivalent_right_stream_column_to_left_stream_column);
 
     if (right_stream_filter_to_push_down)
-        right_stream_filter_to_push_down = replace_equivalent_columns_in_filter(*right_stream_filter_to_push_down,
+        right_stream_filter_to_push_down->dag = replace_equivalent_columns_in_filter(right_stream_filter_to_push_down->dag,
+            right_stream_filter_to_push_down->filter_pos,
             right_stream_header,
             equivalent_left_stream_column_to_right_stream_column);
 
@@ -2827,24 +2858,28 @@ ActionsDAG::ActionsForJOINFilterPushDown ActionsDAG::splitActionsForJOINFilterPu
 
     bool left_stream_filter_removes_filter = true;
     bool right_stream_filter_removes_filter = true;
+    std::optional<ActionsDAG> left_stream_filter_to_push_down_dag;
+    std::optional<ActionsDAG> right_stream_filter_to_push_down_dag;
 
     if (left_stream_filter_to_push_down)
     {
-        const auto & left_stream_filter_column_name = left_stream_filter_to_push_down->getOutputs()[0]->result_name;
+        const auto & left_stream_filter_column_name = left_stream_filter_to_push_down->dag.getOutputs()[0]->result_name;
         left_stream_filter_removes_filter = !left_stream_header.has(left_stream_filter_column_name);
+        left_stream_filter_to_push_down_dag = std::move(left_stream_filter_to_push_down->dag);
     }
 
     if (right_stream_filter_to_push_down)
     {
-        const auto & right_stream_filter_column_name = right_stream_filter_to_push_down->getOutputs()[0]->result_name;
+        const auto & right_stream_filter_column_name = right_stream_filter_to_push_down->dag.getOutputs()[0]->result_name;
         right_stream_filter_removes_filter = !right_stream_header.has(right_stream_filter_column_name);
+        right_stream_filter_to_push_down_dag = std::move(right_stream_filter_to_push_down->dag);
     }
 
     ActionsDAG::ActionsForJOINFilterPushDown result
     {
-        .left_stream_filter_to_push_down = std::move(left_stream_filter_to_push_down),
+        .left_stream_filter_to_push_down = std::move(left_stream_filter_to_push_down_dag),
         .left_stream_filter_removes_filter = left_stream_filter_removes_filter,
-        .right_stream_filter_to_push_down = std::move(right_stream_filter_to_push_down),
+        .right_stream_filter_to_push_down = std::move(right_stream_filter_to_push_down_dag),
         .right_stream_filter_removes_filter = right_stream_filter_removes_filter
     };
 
diff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h
index 9e2e94c173fe..50c18b513819 100644
--- a/src/Interpreters/ActionsDAG.h
+++ b/src/Interpreters/ActionsDAG.h
@@ -369,6 +369,7 @@ class ActionsDAG
       */
     bool isFilterAlwaysFalseForDefaultValueInputs(const std::string & filter_name, const Block & input_stream_header) const;
 
+    struct ActionsForFilterPushDown;
     /// Create actions which may calculate part of filter using only available_inputs.
     /// If nothing may be calculated, returns nullptr.
     /// Otherwise, return actions which inputs are from available_inputs.
@@ -386,7 +387,7 @@ class ActionsDAG
     /// columns will be transformed like `x, y, z` -> `z > 0, z, x, y` -(remove filter)-> `z, x, y`.
     /// To avoid it, add inputs from `all_inputs` list,
     /// so actions `x, y, z -> z > 0, x, y, z` -(remove filter)-> `x, y, z` will not change columns order.
-    std::optional<ActionsDAG> splitActionsForFilterPushDown(
+    std::optional<ActionsForFilterPushDown> splitActionsForFilterPushDown(
         const std::string & filter_name,
         bool removes_filter,
         const Names & available_inputs,
@@ -475,7 +476,7 @@ class ActionsDAG
     void compileFunctions(size_t min_count_to_compile_expression, const std::unordered_set<const Node *> & lazy_executed_nodes = {});
 #endif
 
-    static std::optional<ActionsDAG> createActionsForConjunction(NodeRawConstPtrs conjunction, const ColumnsWithTypeAndName & all_inputs);
+    static std::optional<ActionsForFilterPushDown> createActionsForConjunction(NodeRawConstPtrs conjunction, const ColumnsWithTypeAndName & all_inputs);
 
     void removeUnusedConjunctions(NodeRawConstPtrs rejected_conjunctions, Node * predicate, bool removes_filter);
 };
@@ -487,6 +488,13 @@ struct ActionsDAG::SplitResult
     std::unordered_map<const Node *, const Node *> split_nodes_mapping;
 };
 
+struct ActionsDAG::ActionsForFilterPushDown
+{
+    ActionsDAG dag;
+    size_t filter_pos;
+    bool remove_filter;
+};
+
 struct ActionsDAG::ActionsForJOINFilterPushDown
 {
     std::optional<ActionsDAG> left_stream_filter_to_push_down;
diff --git a/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp b/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp
index fac2471422cb..e04e53c98c6e 100644
--- a/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp
+++ b/src/Processors/QueryPlan/Optimizations/filterPushDown.cpp
@@ -37,17 +37,6 @@ namespace DB::ErrorCodes
 namespace DB::QueryPlanOptimizations
 {
 
-static bool filterColumnIsNotAmongAggregatesArguments(const AggregateDescriptions & aggregates, const std::string & filter_column_name)
-{
-    for (const auto & aggregate : aggregates)
-    {
-        const auto & argument_names = aggregate.argument_names;
-        if (std::find(argument_names.begin(), argument_names.end(), filter_column_name) != argument_names.end())
-            return false;
-    }
-    return true;
-}
-
 /// Assert that `node->children` has at least `child_num` elements
 static void checkChildrenSize(QueryPlan::Node * node, size_t child_num)
 {
@@ -104,7 +93,7 @@ static NameSet findIdentifiersOfNode(const ActionsDAG::Node * node)
     return res;
 }
 
-static std::optional<ActionsDAG> splitFilter(QueryPlan::Node * parent_node, bool step_changes_the_number_of_rows, const Names & available_inputs, size_t child_idx = 0)
+static std::optional<ActionsDAG::ActionsForFilterPushDown> splitFilter(QueryPlan::Node * parent_node, bool step_changes_the_number_of_rows, const Names & available_inputs, size_t child_idx = 0)
 {
     QueryPlan::Node * child_node = parent_node->children.front();
     checkChildrenSize(child_node, child_idx + 1);
@@ -122,9 +111,11 @@ static std::optional<ActionsDAG> splitFilter(QueryPlan::Node * parent_node, bool
     return expression.splitActionsForFilterPushDown(filter_column_name, removes_filter, available_inputs, all_inputs, allow_deterministic_functions);
 }
 
-static size_t
-addNewFilterStepOrThrow(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes, ActionsDAG split_filter,
-                    bool can_remove_filter = true, size_t child_idx = 0, bool update_parent_filter = true)
+static size_t addNewFilterStepOrThrow(
+    QueryPlan::Node * parent_node,
+    QueryPlan::Nodes & nodes,
+    ActionsDAG::ActionsForFilterPushDown split_filter,
+    size_t child_idx = 0, bool update_parent_filter = true)
 {
     QueryPlan::Node * child_node = parent_node->children.front();
     checkChildrenSize(child_node, child_idx + 1);
@@ -151,18 +142,9 @@ addNewFilterStepOrThrow(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes,
     /// Expression/Filter -> Child -> Filter -> Something
 
     /// New filter column is the first one.
-    String split_filter_column_name = split_filter.getOutputs().front()->result_name;
-
-    // If no new columns added, filter just used one of the input columns as-is and moved it to the front, move it back to keep aggregation key in order.
-    if (const auto & input = node.children.at(0)->step->getOutputHeader(); split_filter.getOutputs().size() == input.columns())
-    {
-        auto pos = input.getPositionByName(split_filter_column_name);
-        if (pos != 0)
-            std::rotate(split_filter.getOutputs().begin(), split_filter.getOutputs().begin() + 1, split_filter.getOutputs().begin() + pos + 1);
-    }
-
+    String split_filter_column_name = split_filter.dag.getOutputs()[split_filter.filter_pos]->result_name;
     node.step = std::make_unique<FilterStep>(
-        node.children.at(0)->step->getOutputHeader(), std::move(split_filter), std::move(split_filter_column_name), can_remove_filter);
+        node.children.at(0)->step->getOutputHeader(), std::move(split_filter.dag), std::move(split_filter_column_name), split_filter.remove_filter);
 
     child->updateInputHeader(node.step->getOutputHeader(), child_idx);
 
@@ -186,12 +168,15 @@ addNewFilterStepOrThrow(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes,
     return 3;
 }
 
-static size_t
-tryAddNewFilterStep(QueryPlan::Node * parent_node, bool step_changes_the_number_of_rows, QueryPlan::Nodes & nodes, const Names & allowed_inputs,
-                    bool can_remove_filter = true, size_t child_idx = 0)
+static size_t tryAddNewFilterStep(
+    QueryPlan::Node * parent_node,
+    bool step_changes_the_number_of_rows,
+    QueryPlan::Nodes & nodes,
+    const Names & allowed_inputs,
+    size_t child_idx = 0)
 {
     if (auto split_filter = splitFilter(parent_node, step_changes_the_number_of_rows, allowed_inputs, child_idx))
-        return addNewFilterStepOrThrow(parent_node, nodes, std::move(*split_filter), can_remove_filter, child_idx);
+        return addNewFilterStepOrThrow(parent_node, nodes, std::move(*split_filter), child_idx);
     return 0;
 }
 
@@ -417,8 +402,7 @@ static size_t tryPushDownOverJoinStep(QueryPlan::Node * parent_node, QueryPlan::
         const auto & result_name = join_filter_push_down_actions.left_stream_filter_to_push_down->getOutputs()[0]->result_name;
         updated_steps += addNewFilterStepOrThrow(parent_node,
             nodes,
-            std::move(*join_filter_push_down_actions.left_stream_filter_to_push_down),
-            join_filter_push_down_actions.left_stream_filter_removes_filter,
+            {std::move(*join_filter_push_down_actions.left_stream_filter_to_push_down), 0, join_filter_push_down_actions.left_stream_filter_removes_filter},
             0 /*child_idx*/,
             false /*update_parent_filter*/);
         LOG_DEBUG(&Poco::Logger::get("QueryPlanOptimizations"),
@@ -442,8 +426,7 @@ static size_t tryPushDownOverJoinStep(QueryPlan::Node * parent_node, QueryPlan::
         const auto & result_name = join_filter_push_down_actions.right_stream_filter_to_push_down->getOutputs()[0]->result_name;
         updated_steps += addNewFilterStepOrThrow(parent_node,
             nodes,
-            std::move(*join_filter_push_down_actions.right_stream_filter_to_push_down),
-            join_filter_push_down_actions.right_stream_filter_removes_filter,
+            {std::move(*join_filter_push_down_actions.right_stream_filter_to_push_down), 0, join_filter_push_down_actions.right_stream_filter_removes_filter},
             1 /*child_idx*/,
             false /*update_parent_filter*/);
         LOG_DEBUG(&Poco::Logger::get("QueryPlanOptimizations"),
@@ -536,14 +519,7 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes
         if (keys.empty())
             return 0;
 
-        const bool filter_column_is_not_among_aggregation_keys
-            = std::find(keys.begin(), keys.end(), filter->getFilterColumnName()) == keys.end();
-
-        /// When we only merging aggregated data, we do not need aggregation arguments.
-        bool filter_is_not_among_aggregates_arguments = merging_aggregated || filterColumnIsNotAmongAggregatesArguments(params.aggregates, filter->getFilterColumnName());
-        const bool can_remove_filter = filter_column_is_not_among_aggregation_keys && filter_is_not_among_aggregates_arguments;
-
-        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, keys, can_remove_filter))
+        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, keys))
             return updated_steps;
     }
 
@@ -645,34 +621,24 @@ size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes
     // {
     // }
 
-    if (auto * sorting = typeid_cast<SortingStep *>(child.get()))
+    if (typeid_cast<SortingStep *>(child.get()))
     {
-        const auto & sort_description = sorting->getSortDescription();
-        auto sort_description_it = std::find_if(sort_description.begin(), sort_description.end(), [&](auto & sort_column_description)
-        {
-            return sort_column_description.column_name == filter->getFilterColumnName();
-        });
-        bool can_remove_filter = sort_description_it == sort_description.end();
-
         Names allowed_inputs = child->getOutputHeader().getNames();
-        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, allowed_inputs, can_remove_filter))
+        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, allowed_inputs))
             return updated_steps;
     }
 
     if (typeid_cast<CustomMetricLogViewStep *>(child.get()))
     {
         Names allowed_inputs = {"event_date", "event_time", "hostname"};
-        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, allowed_inputs, true))
+        if (auto updated_steps = tryAddNewFilterStep(parent_node, true, nodes, allowed_inputs))
             return updated_steps;
     }
 
-    if (const auto * join_filter_set_step = typeid_cast<CreateSetAndFilterOnTheFlyStep *>(child.get()))
+    if (typeid_cast<CreateSetAndFilterOnTheFlyStep *>(child.get()))
     {
-        const auto & filter_column_name = assert_cast<const FilterStep *>(parent_node->step.get())->getFilterColumnName();
-        bool can_remove_filter = !join_filter_set_step->isColumnPartOfSetKey(filter_column_name);
-
         Names allowed_inputs = child->getOutputHeader().getNames();
-        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, allowed_inputs, can_remove_filter))
+        if (auto updated_steps = tryAddNewFilterStep(parent_node, false, nodes, allowed_inputs))
             return updated_steps;
     }
 
