diff --git a/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp b/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp
index 7205b5b3294f..8de809712384 100644
--- a/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp
+++ b/src/Disks/ObjectStorages/S3/S3ObjectStorage.cpp
@@ -63,7 +63,7 @@ void throwIfError(const Aws::Utils::Outcome<Result, Error> & response)
     {
         const auto & err = response.GetError();
         throw S3Exception(
-            fmt::format("{} (Code: {}, s3 exception: {})",
+            fmt::format("{} (Code: {}, S3 exception: '{}')",
                         err.GetMessage(), static_cast<size_t>(err.GetErrorType()), err.GetExceptionName()),
             err.GetErrorType());
     }
diff --git a/src/IO/S3/Credentials.cpp b/src/IO/S3/Credentials.cpp
index dfb7727fca43..d6f7542da6b3 100644
--- a/src/IO/S3/Credentials.cpp
+++ b/src/IO/S3/Credentials.cpp
@@ -145,12 +145,16 @@ Aws::String AWSEC2MetadataClient::getDefaultCredentialsSecurely() const
 {
     String user_agent_string = awsComputeUserAgentString();
     auto [new_token, response_code] = getEC2MetadataToken(user_agent_string);
-    if (response_code == Aws::Http::HttpResponseCode::BAD_REQUEST)
+    if (response_code == Aws::Http::HttpResponseCode::BAD_REQUEST
+        || response_code == Aws::Http::HttpResponseCode::REQUEST_NOT_MADE)
+    {
+        /// At least the host should be available and reply, otherwise neither IMDSv2 nor IMDSv1 are usable.
         return {};
+    }
     else if (response_code != Aws::Http::HttpResponseCode::OK || new_token.empty())
     {
         LOG_TRACE(logger, "Calling EC2MetadataService to get token failed, "
-                  "falling back to less secure way. HTTP response code: {}", response_code);
+                  "falling back to a less secure way. HTTP response code: {}", response_code);
         return getDefaultCredentials();
     }
 
@@ -247,7 +251,7 @@ static Aws::String getAWSMetadataEndpoint()
     return ec2_metadata_service_endpoint;
 }
 
-std::shared_ptr<AWSEC2MetadataClient> InitEC2MetadataClient(const Aws::Client::ClientConfiguration & client_configuration)
+std::shared_ptr<AWSEC2MetadataClient> createEC2MetadataClient(const Aws::Client::ClientConfiguration & client_configuration)
 {
     auto endpoint = getAWSMetadataEndpoint();
     return std::make_shared<AWSEC2MetadataClient>(client_configuration, endpoint.c_str());
@@ -781,11 +785,13 @@ S3CredentialsProviderChain::S3CredentialsProviderChain(
 
             /// EC2MetadataService throttles by delaying the response so the service client should set a large read timeout.
             /// EC2MetadataService delay is in order of seconds so it only make sense to retry after a couple of seconds.
-            aws_client_configuration.connectTimeoutMs = 1000;
+            /// But the connection timeout should be small because there is the case when there is no IMDS at all,
+            /// like outside of the cloud, on your own machines.
+            aws_client_configuration.connectTimeoutMs = 10;
             aws_client_configuration.requestTimeoutMs = 1000;
 
             aws_client_configuration.retryStrategy = std::make_shared<Aws::Client::DefaultRetryStrategy>(1, 1000);
-            auto ec2_metadata_client = InitEC2MetadataClient(aws_client_configuration);
+            auto ec2_metadata_client = createEC2MetadataClient(aws_client_configuration);
             auto config_loader = std::make_shared<AWSEC2InstanceProfileConfigLoader>(ec2_metadata_client, !credentials_configuration.use_insecure_imds_request);
 
             AddProvider(std::make_shared<AWSInstanceProfileCredentialsProvider>(config_loader));
diff --git a/src/IO/S3/Credentials.h b/src/IO/S3/Credentials.h
index 95297ab0538c..042c48ec15a1 100644
--- a/src/IO/S3/Credentials.h
+++ b/src/IO/S3/Credentials.h
@@ -70,7 +70,7 @@ class AWSEC2MetadataClient : public Aws::Internal::AWSHttpResourceClient
     LoggerPtr logger;
 };
 
-std::shared_ptr<AWSEC2MetadataClient> InitEC2MetadataClient(const Aws::Client::ClientConfiguration & client_configuration);
+std::shared_ptr<AWSEC2MetadataClient> createEC2MetadataClient(const Aws::Client::ClientConfiguration & client_configuration);
 
 class AWSEC2InstanceProfileConfigLoader : public Aws::Config::AWSProfileConfigLoader
 {
diff --git a/src/IO/S3/PocoHTTPClient.cpp b/src/IO/S3/PocoHTTPClient.cpp
index aab7a39534dd..de43f34d8386 100644
--- a/src/IO/S3/PocoHTTPClient.cpp
+++ b/src/IO/S3/PocoHTTPClient.cpp
@@ -128,7 +128,7 @@ void PocoHTTPClientConfiguration::updateSchemeAndRegion()
             }
             else
             {
-                /// In global mode AWS C++ SDK send `us-east-1` but accept switching to another one if being suggested.
+                /// In global mode AWS C++ SDK sends `us-east-1` but accepts switching to another one if being suggested.
                 region = Aws::Region::AWS_GLOBAL;
             }
         }
diff --git a/src/IO/S3/URI.cpp b/src/IO/S3/URI.cpp
index fead18315d84..9c80b377661b 100644
--- a/src/IO/S3/URI.cpp
+++ b/src/IO/S3/URI.cpp
@@ -1,8 +1,8 @@
 #include <IO/S3/URI.h>
-#include <Interpreters/Context.h>
-#include <Storages/NamedCollectionsHelpers.h>
-#include "Common/Macros.h"
+
 #if USE_AWS_S3
+#include <Interpreters/Context.h>
+#include <Common/Macros.h>
 #include <Common/Exception.h>
 #include <Common/quoteString.h>
 #include <Common/re2.h>
@@ -10,6 +10,7 @@
 
 #include <boost/algorithm/string/case_conv.hpp>
 
+
 namespace DB
 {
 
@@ -40,21 +41,13 @@ URI::URI(const std::string & uri_, bool allow_archive_path_syntax)
     /// Case when AWS Private Link Interface is being used
     /// E.g. (bucket.vpce-07a1cd78f1bd55c5f-j3a3vg6w.s3.us-east-1.vpce.amazonaws.com/bucket-name/key)
     /// https://docs.aws.amazon.com/AmazonS3/latest/userguide/privatelink-interface-endpoints.html
-    static const RE2 aws_private_link_style_pattern(R"(bucket\.vpce\-([a-z0-9\-.]+)\.vpce.amazonaws.com(:\d{1,5})?)");
+    static const RE2 aws_private_link_style_pattern(R"(bucket\.vpce\-([a-z0-9\-.]+)\.vpce\.amazonaws\.com(:\d{1,5})?)");
 
-    /// Case when bucket name and key represented in path of S3 URL.
+    /// Case when bucket name and key represented in the path of S3 URL.
     /// E.g. (https://s3.region.amazonaws.com/bucket-name/key)
     /// https://docs.aws.amazon.com/AmazonS3/latest/dev/VirtualHosting.html#path-style-access
     static const RE2 path_style_pattern("^/([^/]*)/(.*)");
 
-    static constexpr auto S3 = "S3";
-    static constexpr auto S3EXPRESS = "S3EXPRESS";
-    static constexpr auto COSN = "COSN";
-    static constexpr auto COS = "COS";
-    static constexpr auto OBS = "OBS";
-    static constexpr auto OSS = "OSS";
-    static constexpr auto EOS = "EOS";
-
     if (allow_archive_path_syntax)
         std::tie(uri_str, archive_pattern) = getURIAndArchivePattern(uri_);
     else
@@ -85,7 +78,7 @@ URI::URI(const std::string & uri_, bool allow_archive_path_syntax)
             URIConverter::modifyURI(uri, mapper);
     }
 
-    storage_name = S3;
+    storage_name = "S3";
 
     if (uri.getHost().empty())
         throw Exception(ErrorCodes::BAD_ARGUMENTS, "Host is empty in S3 URI.");
@@ -93,11 +86,13 @@ URI::URI(const std::string & uri_, bool allow_archive_path_syntax)
     /// Extract object version ID from query string.
     bool has_version_id = false;
     for (const auto & [query_key, query_value] : uri.getQueryParameters())
+    {
         if (query_key == "versionId")
         {
             version_id = query_value;
             has_version_id = true;
         }
+    }
 
     /// Poco::URI will ignore '?' when parsing the path, but if there is a versionId in the http parameter,
     /// '?' can not be used as a wildcard, otherwise it will be ambiguous.
@@ -129,15 +124,8 @@ URI::URI(const std::string & uri_, bool allow_archive_path_syntax)
         }
 
         boost::to_upper(name);
-        /// For S3Express it will look like s3express-eun1-az1, i.e. contain region and AZ info
-        if (name != S3 && !name.starts_with(S3EXPRESS) && name != COS && name != OBS && name != OSS && name != EOS)
-            throw Exception(
-                ErrorCodes::BAD_ARGUMENTS,
-                "Object storage system name is unrecognized in virtual hosted style S3 URI: {}",
-                quoteString(name));
-
-        if (name == COS)
-            storage_name = COSN;
+        if (name == "COS")
+            storage_name = "COSN";
         else
             storage_name = name;
     }
@@ -148,13 +136,22 @@ URI::URI(const std::string & uri_, bool allow_archive_path_syntax)
         validateBucket(bucket, uri);
     }
     else
-        throw Exception(ErrorCodes::BAD_ARGUMENTS, "Bucket or key name are invalid in S3 URI.");
+    {
+        /// Custom endpoint, e.g. a public domain of Cloudflare R2,
+        /// which could be served by a custom server-side code.
+        storage_name = "S3";
+        bucket = "default";
+        is_virtual_hosted_style = false;
+        endpoint = uri.getScheme() + "://" + uri.getAuthority();
+        if (!uri.getPath().empty())
+            key = uri.getPath().substr(1);
+    }
 }
 
 void URI::addRegionToURI(const std::string &region)
 {
-    if (auto pos = endpoint.find("amazonaws.com"); pos != std::string::npos)
-        endpoint = endpoint.substr(0, pos) + region + "." + endpoint.substr(pos);
+    if (auto pos = endpoint.find(".amazonaws.com"); pos != std::string::npos)
+        endpoint = endpoint.substr(0, pos) + "." + region + endpoint.substr(pos);
 }
 
 void URI::validateBucket(const String & bucket, const Poco::URI & uri)
diff --git a/src/IO/S3/URI.h b/src/IO/S3/URI.h
index 80e2da96cd4d..c8d0b28cd150 100644
--- a/src/IO/S3/URI.h
+++ b/src/IO/S3/URI.h
@@ -1,14 +1,14 @@
 #pragma once
 
-#include <optional>
-#include <string>
-
 #include "config.h"
 
 #if USE_AWS_S3
 
+#include <optional>
+#include <string>
 #include <Poco/URI.h>
 
+
 namespace DB::S3
 {
 
@@ -23,7 +23,7 @@ namespace DB::S3
 struct URI
 {
     Poco::URI uri;
-    // Custom endpoint if URI scheme is not S3.
+    // Custom endpoint if URI scheme, if not S3.
     std::string endpoint;
     std::string bucket;
     std::string key;
diff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp
index 78dbb72c199c..f7701a2aab80 100644
--- a/src/Storages/StorageMergeTree.cpp
+++ b/src/Storages/StorageMergeTree.cpp
@@ -895,7 +895,7 @@ void StorageMergeTree::loadDeduplicationLog()
     std::string path = fs::path(relative_data_path) / "deduplication_logs";
 
     /// If either there is already a deduplication log, or we will be able to use it.
-    if (disk->exists(path) || !disk->isReadOnly())
+    if (!disk->isReadOnly() || disk->exists(path))
     {
         deduplication_log = std::make_unique<MergeTreeDeduplicationLog>(path, settings->non_replicated_deduplication_window, format_version, disk);
         deduplication_log->load();
