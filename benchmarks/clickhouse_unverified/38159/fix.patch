diff --git a/.gitmodules b/.gitmodules
index 55fd684fddbc..a8924e3aaba6 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -268,3 +268,9 @@
 [submodule "contrib/hashidsxx"]
 	path = contrib/hashidsxx
 	url = https://github.com/schoentoon/hashidsxx.git
+[submodule "contrib/base-x"]
+	path = contrib/base-x
+	url = https://github.com/ClickHouse/base-x.git
+[submodule "contrib/liburing"]
+	path = contrib/liburing
+	url = https://github.com/axboe/liburing.git
diff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt
index 09cf80595a72..f2513c29d3e2 100644
--- a/contrib/CMakeLists.txt
+++ b/contrib/CMakeLists.txt
@@ -155,6 +155,7 @@ endif()
 
 add_contrib (sqlite-cmake sqlite-amalgamation)
 add_contrib (s2geometry-cmake s2geometry)
+add_contrib (base-x-cmake base-x)
 
 # Put all targets defined here and in subdirectories under "contrib/<immediate-subdir>" folders in GUI-based IDEs.
 # Some of third-party projects may override CMAKE_FOLDER or FOLDER property of their targets, so they would not appear
diff --git a/contrib/base-x-cmake/CMakeLists.txt b/contrib/base-x-cmake/CMakeLists.txt
new file mode 100644
index 000000000000..b0c11a176c6c
--- /dev/null
+++ b/contrib/base-x-cmake/CMakeLists.txt
@@ -0,0 +1,28 @@
+option (ENABLE_BASEX "Enable base-x" ${ENABLE_LIBRARIES})
+
+if (NOT ENABLE_BASEX)
+    message(STATUS "Not using base-x")
+    return()
+endif()
+
+set(LIBRARY_DIR "${ClickHouse_SOURCE_DIR}/contrib/base-x")
+
+set (SRCS
+        ${LIBRARY_DIR}/base_x.hh
+        ${LIBRARY_DIR}/uinteger_t.hh
+        )
+
+add_library(_base-x INTERFACE)
+target_include_directories(_base-x SYSTEM BEFORE INTERFACE "${ClickHouse_SOURCE_DIR}/contrib/base-x")
+
+if (XCODE OR XCODE_VERSION)
+    # https://gitlab.kitware.com/cmake/cmake/issues/17457
+    #     Some native build systems may not like targets that have only object files, so consider adding at least one real source file
+    # This applies to Xcode.
+    if (NOT EXISTS "${CMAKE_CURRENT_BINARY_DIR}/dummy.c")
+        file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/dummy.c" "")
+    endif ()
+    target_sources(_base-x PRIVATE "${CMAKE_CURRENT_BINARY_DIR}/dummy.c")
+endif ()
+
+add_library(ch_contrib::base-x ALIAS _base-x)
\ No newline at end of file
diff --git a/contrib/base-x/.gitignore b/contrib/base-x/.gitignore
new file mode 100644
index 000000000000..b63b40c8b71c
--- /dev/null
+++ b/contrib/base-x/.gitignore
@@ -0,0 +1,4 @@
+.DS_Store
+test
+*.o
+*.dSYM
\ No newline at end of file
diff --git a/contrib/base-x/.travis.yml b/contrib/base-x/.travis.yml
new file mode 100755
index 000000000000..f55132e614f2
--- /dev/null
+++ b/contrib/base-x/.travis.yml
@@ -0,0 +1,36 @@
+sudo: false
+
+language: cpp
+
+compiler:
+  - clang
+  - gcc
+
+addons:
+  apt:
+    sources:
+    - ubuntu-toolchain-r-test
+    - llvm-toolchain-precise-3.8
+    packages:
+    - g++-6
+    - clang-3.8
+
+install:
+  - if [ "$CXX" = "g++" ]; then export CXX="g++-6"; fi
+  - if [ "$CXX" == "clang++" ]; then export CXX="clang++-3.8"; fi
+  - sudo apt-get install -qq git cmake
+
+before_script:
+  # not much better than git submodules, but there was never a need/want for the repo in this repo
+  - cd ..
+  - git clone https://github.com/google/googletest.git
+  - cd googletest
+  - git reset --hard d62d6c6556d96dda924382547c54a4b3afedb22c
+  - cmake CMakeLists.txt
+  - make
+
+  - cd ../base-x/tests
+  - make
+
+script:
+  - make run
diff --git a/contrib/base-x/LICENSE b/contrib/base-x/LICENSE
new file mode 100644
index 000000000000..f7b3408abace
--- /dev/null
+++ b/contrib/base-x/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/contrib/base-x/README.md b/contrib/base-x/README.md
new file mode 100644
index 000000000000..5dc4a068043c
--- /dev/null
+++ b/contrib/base-x/README.md
@@ -0,0 +1,97 @@
+ï»¿# base-x [![License][license-img]][license-url] [![GitHub Stars][stars-img]][stars-url] [![GitHub Forks][forks-img]][forks-url] [![GitHub Watchers][watchers-img]][watchers-url] [![Tweet][tweet-img]][tweet-url]
+
+[![Build Status](https://travis-ci.org/Kronuz/base-x.svg?branch=master)](https://travis-ci.org/Kronuz/base-x)
+
+
+### BaseX encoder / decoder for C++
+
+This is a fast base encoder / decoder of any given alphabet.
+
+
+#### Example
+
+``` cpp
+// example.cc
+// g++ -std=c++14 -o example example.cc
+
+#include <iostream>
+#include "base_x.hh"
+
+int main() {
+    auto encoded = Base58::base58().encode("Hello world!");
+
+    std::cout << encoded << std::endl;
+    // => 1LDlk6QWOejX6rPrJ
+
+    return 0;
+}
+```
+
+
+#### Compilation
+
+* g++ and clang++ are supported.
+* C++14 is required.
+
+
+### Alphabets
+
+See below for a list of commonly recognized alphabets, and their respective base.
+
+Base | Factory             | Alphabet
+-----|---------------------|-------------
+   2 | base2::base2()      | `01`
+   2 | base8::base8()      | `01234567`
+  11 | bas11::bas11()      | `0123456789a`
+  16 | base16::base16()    | `0123456789abcdef`
+  32 | base32::base32()    | `0123456789ABCDEFGHJKMNPQRSTVWXYZ`
+  36 | base36::base36()    | `0123456789abcdefghijklmnopqrstuvwxyz`
+  58 | base58::base58()    | `123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`
+  58 | base58::bitcoin()   | `123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`
+  58 | base58::gmp()       | `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv`
+  58 | base58::ripple()    | `rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz`
+  58 | base58::flickr()    | `123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ`
+  62 | base62::base62()    | `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
+  62 | base62::inverted()  | `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`
+  64 | base64::base64()    | `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`
+  64 | base64::urlsafe()   | `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_`
+  66 | base66::base66()    | `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~`
+
+
+### How it works
+
+It encodes octet arrays by doing long divisions on all significant digits in the
+array, creating a representation of that number in the new base.
+
+**If you need standard hex encoding, or base64 encoding, this module is NOT
+appropriate.**
+
+
+## Author
+[**German Mendez Bravo (Kronuz)**](https://kronuz.io/)
+
+[![Follow on GitHub][github-follow-img]][github-follow-url]
+[![Follow on Twitter][twitter-follow-img]][twitter-follow-url]
+
+
+## License
+
+MIT License. See [LICENSE](LICENSE) for details.
+
+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com
+
+
+[license-url]: https://github.com/Kronuz/base-x/blob/master/LICENSE
+[license-img]: https://img.shields.io/github/license/Kronuz/base-x.svg
+[stars-url]: https://github.com/Kronuz/base-x/stargazers
+[stars-img]: https://img.shields.io/github/stars/Kronuz/base-x.svg?style=social&amp;label=Stars
+[forks-url]: https://github.com/Kronuz/base-x/network/members
+[forks-img]: https://img.shields.io/github/forks/Kronuz/base-x.svg?style=social&amp;label=Forks
+[watchers-url]: https://github.com/Kronuz/base-x/watchers
+[watchers-img]: https://img.shields.io/github/watchers/Kronuz/base-x.svg?style=social&amp;label=Watchers
+[tweet-img]: https://img.shields.io/twitter/url/https/github.com/Kronuz/base-x.svg?style=social
+[tweet-url]: https://twitter.com/intent/tweet?text=Base-X+encoding%2Fdecoding+for+modern+C%2B%2B+by+%40germbravo:&url=https%3A%2F%2Fgithub.com%2FKronuz%2Fbase-x
+[github-follow-url]: https://github.com/Kronuz
+[github-follow-img]: https://img.shields.io/github/followers/Kronuz.svg?style=social&label=Follow
+[twitter-follow-url]: https://twitter.com/intent/follow?screen_name=germbravo
+[twitter-follow-img]: https://img.shields.io/twitter/follow/germbravo.svg?style=social&label=Follow
diff --git a/contrib/base-x/base_x.hh b/contrib/base-x/base_x.hh
new file mode 100644
index 000000000000..fdc06fead2f1
--- /dev/null
+++ b/contrib/base-x/base_x.hh
@@ -0,0 +1,614 @@
+/*
+base_x.hh
+BaseX encoder / decoder for C++
+
+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/
+
+#ifndef __BASE_X__H_
+#define __BASE_X__H_
+
+#include <algorithm>        // for std::find_if, std::reverse
+#include <stdexcept>        // for std::invalid_argument
+#include <string>           // for std::string
+#include <type_traits>      // for std::enable_if_t
+
+#include "uinteger_t.hh"
+
+
+class BaseX {
+	char _chr[256];
+	int _ord[256];
+
+	const int size;
+	const int alphabet_base;
+	const unsigned base_size;
+	const unsigned alphabet_base_bits;
+	const unsigned block_size;
+	const uinteger_t::digit alphabet_base_mask;
+	const unsigned padding_size;
+	const char padding;
+	const int flags;
+
+	constexpr char chr(unsigned char ord) const {
+		return _chr[ord];
+	}
+
+	constexpr int ord(unsigned char chr) const {
+		return _ord[chr];
+	}
+
+public:
+	static constexpr int ignore_case =   (1 << 0);
+	static constexpr int with_checksum = (1 << 1);
+	static constexpr int with_check =    (1 << 2);
+	static constexpr int block_padding = (1 << 3);
+
+	template <std::size_t alphabet_size1, std::size_t extended_size1, std::size_t padding_size1, std::size_t translate_size1>
+	constexpr BaseX(int flgs, const char (&alphabet)[alphabet_size1], const char (&extended)[extended_size1], const char (&padding_string)[padding_size1], const char (&translate)[translate_size1]) :
+		_chr(),
+		_ord(),
+		size(alphabet_size1 - 1 + extended_size1 - 1),
+		alphabet_base(alphabet_size1 - 1),
+		base_size(uinteger_t::base_size(alphabet_base)),
+		alphabet_base_bits(uinteger_t::base_bits(alphabet_base)),
+		block_size((flgs & BaseX::block_padding) ? alphabet_base_bits : 0),
+		alphabet_base_mask(alphabet_base - 1),
+		padding_size(padding_size1 - 1),
+		padding(padding_size ? padding_string[0] : '\0'),
+		flags(flgs)
+	{
+		for (int c = 0; c < 256; ++c) {
+			_chr[c] = 0;
+			_ord[c] = alphabet_base;
+		}
+		for (int cp = 0; cp < alphabet_base; ++cp) {
+			auto ch = alphabet[cp];
+			_chr[cp] = ch;
+			ASSERT(_ord[(unsigned char)ch] == alphabet_base);  // Duplicate character in the alphabet
+			_ord[(unsigned char)ch] = cp;
+			if (flags & BaseX::ignore_case) {
+				if (ch >= 'A' && ch <='Z') {
+					_ord[(unsigned char)ch - 'A' + 'a'] = cp;
+				} else if (ch >= 'a' && ch <='z') {
+					_ord[(unsigned char)ch - 'a' + 'A'] = cp;
+				}
+			}
+		}
+		for (std::size_t i = 0; i < extended_size1 - 1; ++i) {
+			auto ch = extended[i];
+			auto cp = alphabet_base + i;
+			_chr[cp] = ch;
+			ASSERT(_ord[(unsigned char)ch] == alphabet_base); // Duplicate character in the extended alphabet
+			_ord[(unsigned char)ch] = cp;
+			if (flags & BaseX::ignore_case) {
+				if (ch >= 'A' && ch <='Z') {
+					_ord[(unsigned char)ch - 'A' + 'a'] = cp;
+				} else if (ch >= 'a' && ch <='z') {
+					_ord[(unsigned char)ch - 'a' + 'A'] = cp;
+				}
+			}
+		}
+		int cp = -1;
+		for (std::size_t i = 0; i < translate_size1 - 1; ++i) {
+			auto ch = translate[i];
+			auto ncp = _ord[(unsigned char)ch];
+			if (ncp >= alphabet_base) {
+				ASSERT(_ord[(unsigned char)ch] == alphabet_base); // Invalid translation character
+				_ord[(unsigned char)ch] = cp;
+				if (flags & BaseX::ignore_case) {
+					if (ch >= 'A' && ch <='Z') {
+						_ord[(unsigned char)ch - 'A' + 'a'] = cp;
+					} else if (ch >= 'a' && ch <='z') {
+						_ord[(unsigned char)ch - 'a' + 'A'] = cp;
+					}
+				}
+			} else {
+				cp = ncp;
+			}
+		}
+	}
+
+	// Get string representation of value
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	void encode(Result& result, const uinteger_t& input) const {
+		std::size_t bp = 0;
+		uinteger_t quotient;
+		if (block_size) {
+			bp = ((input.bits() + 7) & 0xf8) % block_size;
+			bp = bp ? (block_size - bp) % block_size : 0;
+			if (bp) {
+				quotient = input << bp;
+			}
+		}
+		const uinteger_t& num = bp ? quotient : input;
+		auto num_sz = num.size();
+		if (num_sz) {
+			int sum = 0;
+			result.reserve(num_sz * base_size);
+			if (alphabet_base_bits) {
+				std::size_t shift = 0;
+				auto ptr = reinterpret_cast<const uinteger_t::half_digit*>(num.data());
+				uinteger_t::digit v = *ptr++;
+				v <<= uinteger_t::half_digit_bits;
+				for (auto i = num_sz * 2 - 1; i; --i) {
+					v >>= uinteger_t::half_digit_bits;
+					v |= (static_cast<uinteger_t::digit>(*ptr++) << uinteger_t::half_digit_bits);
+					do {
+						auto d = static_cast<int>((v >> shift) & alphabet_base_mask);
+						result.push_back(chr(d));
+						shift += alphabet_base_bits;
+						sum += d;
+					} while (shift <= uinteger_t::half_digit_bits);
+					shift -= uinteger_t::half_digit_bits;
+				}
+				v >>= (shift + uinteger_t::half_digit_bits);
+				while (v) {
+					auto d = static_cast<int>(v & alphabet_base_mask);
+					result.push_back(chr(d));
+					v >>= alphabet_base_bits;
+					sum += d;
+				}
+				auto s = chr(0);
+				auto rit_f = std::find_if(result.rbegin(), result.rend(), [s](const char& c) { return c != s; });
+				result.resize(result.rend() - rit_f); // shrink
+			} else {
+				uinteger_t uint_base = alphabet_base;
+				if (!bp) {
+					quotient = num;
+				}
+				do {
+					auto r = quotient.divmod(uint_base);
+					auto d = static_cast<int>(r.second);
+					result.push_back(chr(d));
+					quotient = std::move(r.first);
+					sum += d;
+				} while (quotient);
+			}
+			std::reverse(result.begin(), result.end());
+			if (padding_size) {
+				Result p;
+				p.resize((padding_size - (result.size() % padding_size)) % padding_size, padding);
+				result.append(p);
+			}
+			if (flags & BaseX::with_check) {
+				auto chk = static_cast<int>(num % size);
+				result.push_back(chr(chk));
+				sum += chk;
+			}
+			if (flags & BaseX::with_checksum) {
+				auto sz = result.size();
+				sz = (sz + sz / size) % size;
+				sum += sz;
+				sum = (size - sum % size) % size;
+				result.push_back(chr(sum));
+			}
+		} else {
+			result.push_back(chr(0));
+		}
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result encode(const uinteger_t& num) const {
+		Result result;
+		encode(result, num);
+		return result;
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	void encode(Result& result, const unsigned char* decoded, std::size_t decoded_size) const {
+		encode(result, uinteger_t(decoded, decoded_size, 256));
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result encode(const unsigned char* decoded, std::size_t decoded_size) const {
+		Result result;
+		encode(result, uinteger_t(decoded, decoded_size, 256));
+		return result;
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	void encode(Result& result, const char* decoded, std::size_t decoded_size) const {
+		encode(result, uinteger_t(decoded, decoded_size, 256));
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result encode(const char* decoded, std::size_t decoded_size) const {
+		Result result;
+		encode(result, uinteger_t(decoded, decoded_size, 256));
+		return result;
+	}
+
+	template <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	void encode(Result& result, T (&s)[N]) const {
+		encode(result, s, N - 1);
+	}
+
+	template <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result encode(T (&s)[N]) const {
+		Result result;
+		encode(result, s, N - 1);
+		return result;
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	void encode(Result& result, const std::string& binary) const {
+		return encode(result, binary.data(), binary.size());
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result encode(const std::string& binary) const {
+		Result result;
+		encode(result, binary.data(), binary.size());
+		return result;
+	}
+
+	void decode(uinteger_t& result, const char* encoded, std::size_t encoded_size) const {
+		result = 0;
+		int sum = 0;
+		int sumsz = 0;
+		int direction = 1;
+
+		auto sz = encoded_size;
+		if (flags & BaseX::with_checksum) --sz;
+		if (flags & BaseX::with_check) --sz;
+
+		int bp = 0;
+
+		if (alphabet_base_bits) {
+			for (; sz; --sz, encoded += direction) {
+				auto c = *encoded;
+				if (c == padding) break;
+				auto d = ord(static_cast<int>(c));
+				if (d < 0) continue; // ignored character
+				if (d >= alphabet_base) {
+					throw std::invalid_argument("Error: Invalid character: '" + std::string(1, c) + "' at " + std::to_string(encoded_size - sz));
+				}
+				sum += d;
+				++sumsz;
+				result = (result << alphabet_base_bits) | d;
+				bp += block_size;
+			}
+		} else {
+			uinteger_t uint_base = alphabet_base;
+			for (; sz; --sz, encoded += direction) {
+				auto c = *encoded;
+				if (c == padding) break;
+				auto d = ord(static_cast<int>(c));
+				if (d < 0) continue; // ignored character
+				if (d >= alphabet_base) {
+					throw std::invalid_argument("Error: Invalid character: '" + std::string(1, c) + "' at " + std::to_string(encoded_size - sz));
+				}
+				sum += d;
+				++sumsz;
+				result = (result * uint_base) + d;
+				bp += block_size;
+			}
+		}
+
+		for (; sz && *encoded == padding; --sz, ++encoded);
+
+		result >>= (bp & 7);
+
+		if (flags & BaseX::with_check) {
+			auto c = *encoded;
+			auto d = ord(static_cast<int>(c));
+			if (d < 0 || d >= size) {
+				throw std::invalid_argument("Error: Invalid character: '" + std::string(1, c) + "' at " + std::to_string(encoded_size - sz));
+			}
+			auto chk = static_cast<int>(result % size);
+			if (d != chk) {
+				throw std::invalid_argument("Error: Invalid check");
+			}
+			sum += chk;
+			++sumsz;
+			++encoded;
+		}
+
+		if (flags & BaseX::with_checksum) {
+			auto c = *encoded;
+			auto d = ord(static_cast<int>(c));
+			if (d < 0 || d >= size) {
+				throw std::invalid_argument("Error: Invalid character: '" + std::string(1, c) + "' at " + std::to_string(encoded_size - sz));
+			}
+			sum += d;
+			sum += (sumsz + sumsz / size) % size;
+			if (sum % size) {
+				throw std::invalid_argument("Error: Invalid checksum");
+			}
+		}
+	}
+
+	template <typename Result, typename = typename std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	void decode(Result& result, const char* encoded, std::size_t encoded_size) const {
+		uinteger_t num;
+		decode(num, encoded, encoded_size);
+		result = num.template str<Result>(256);
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>
+	Result decode(const char* encoded, std::size_t encoded_size) const {
+		Result result;
+		decode(result, encoded, encoded_size);
+		return result;
+	}
+
+	template <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>
+	void decode(Result& result, T (&s)[N]) const {
+		decode(result, s, N - 1);
+	}
+
+	template <typename Result = std::string, typename T, std::size_t N, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>
+	Result decode(T (&s)[N]) const {
+		Result result;
+		decode(result, s, N - 1);
+		return result;
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>
+	void decode(Result& result, const std::string& encoded) const {
+		decode(result, encoded.data(), encoded.size());
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value or std::is_integral<Result>::value>>
+	Result decode(const std::string& encoded) const {
+		Result result;
+		decode(result, encoded.data(), encoded.size());
+		return result;
+	}
+
+	bool is_valid(const char* encoded, std::size_t encoded_size) const {
+		int sum = 0;
+		int sumsz = 0;
+		if (flags & BaseX::with_checksum) --sumsz;
+		for (; encoded_size; --encoded_size, ++encoded) {
+			auto d = ord(static_cast<int>(*encoded));
+			if (d < 0) continue; // ignored character
+			if (d >= alphabet_base) {
+				return false;
+			}
+			sum += d;
+			++sumsz;
+		}
+		if (flags & BaseX::with_checksum) {
+			sum += (sumsz + sumsz / size) % size;
+			if (sum % size) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	template <typename T, std::size_t N>
+	bool is_valid(T (&s)[N]) const {
+		return is_valid(s, N - 1);
+	}
+
+	bool is_valid(const std::string& encoded) const {
+		return is_valid(encoded.data(), encoded.size());
+	}
+};
+
+// base2
+struct Base2 {
+	static const BaseX& base2() {
+		static constexpr BaseX encoder(0, "01", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base2chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "01", "", "", "");
+		return encoder;
+	}
+};
+
+// base8
+struct Base8 {
+	static const BaseX& base8() {
+		static constexpr BaseX encoder(0, "01234567", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base8chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "01234567", "", "", "");
+		return encoder;
+	}
+};
+
+// base11
+struct Base11 {
+	static const BaseX& base11() {
+		static constexpr BaseX encoder(BaseX::ignore_case, "0123456789a", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base11chk() {
+		static constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, "0123456789a", "", "", "");
+		return encoder;
+	}
+};
+
+// base16
+struct Base16 {
+	static const BaseX& base16() {
+		static constexpr BaseX encoder(BaseX::ignore_case, "0123456789abcdef", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base16chk() {
+		static constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, "0123456789abcdef", "", "", "");
+		return encoder;
+	}
+	static const BaseX& rfc4648() {
+		static constexpr BaseX encoder(0, "0123456789ABCDEF", "", "", "");
+		return encoder;
+	}
+};
+
+// base32
+struct Base32 {
+	static const BaseX& base32() {
+		static constexpr BaseX encoder(BaseX::ignore_case, "0123456789abcdefghijklmnopqrstuv", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base32chk() {
+		static constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, "0123456789abcdefghijklmnopqrstuv", "", "", "");
+		return encoder;
+	}
+	static const BaseX& crockford() {
+		static constexpr BaseX encoder(BaseX::ignore_case, "0123456789ABCDEFGHJKMNPQRSTVWXYZ", "", "", "-0O1IL");
+		return encoder;
+	}
+	static const BaseX& crockfordchk() {
+		static constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_check, "0123456789ABCDEFGHJKMNPQRSTVWXYZ", "*~$=U", "", "-0O1IL");
+		return encoder;
+	}
+	static const BaseX& rfc4648() {
+		static constexpr BaseX encoder(BaseX::block_padding, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", "", "========", "
\r");
+		return encoder;
+	}
+	static const BaseX& rfc4648hex() {
+		static constexpr BaseX encoder(BaseX::block_padding, "0123456789ABCDEFGHIJKLMNOPQRSTUV", "", "========", "
\r");
+		return encoder;
+	}
+};
+
+// base36
+struct Base36 {
+	static const BaseX& base36() {
+		static constexpr BaseX encoder(BaseX::ignore_case, "0123456789abcdefghijklmnopqrstuvwxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base36chk() {
+		static constexpr BaseX encoder(BaseX::ignore_case | BaseX::with_checksum, "0123456789abcdefghijklmnopqrstuvwxyz", "", "", "");
+		return encoder;
+	}
+};
+
+// base58
+struct Base58 {
+	static const BaseX& base58() {
+		static constexpr BaseX encoder(0, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base58chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuv", "", "", "");
+		return encoder;
+	}
+	static const BaseX& bitcoin() {
+		static constexpr BaseX encoder(0, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& bitcoinchk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& ripple() {
+		static constexpr BaseX encoder(0, "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& ripplechk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& flickr() {
+		static constexpr BaseX encoder(0, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", "", "", "");
+		return encoder;
+	}
+	static const BaseX& flickrchk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", "", "", "");
+		return encoder;
+	}
+};
+
+// base59
+struct Base59 {
+	static const BaseX& base59() {
+		static constexpr BaseX encoder(0, "23456789abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ", "", "", "l1IO0");
+		return encoder;
+	}
+	static const BaseX& base59chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "23456789abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ", "", "", "l1IO0");
+		return encoder;
+	}
+	static const BaseX& dubaluchk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "zy9MalDxwpKLdvW2AtmscgbYUq6jhP7E53TiXenZRkVCrouBH4GSQf8FNJO", "", "", "-l1IO0");
+		return encoder;
+	}
+};
+
+// base62
+struct Base62 {
+	static const BaseX& base62() {
+		static constexpr BaseX encoder(0, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base62chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", "", "", "");
+		return encoder;
+	}
+	static const BaseX& inverted() {
+		static constexpr BaseX encoder(0, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "", "", "");
+		return encoder;
+	}
+	static const BaseX& invertedchk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "", "", "");
+		return encoder;
+	}
+};
+
+// base64
+struct Base64 {
+	static const BaseX& base64() {
+		static constexpr BaseX encoder(0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base64chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "", "", "");
+		return encoder;
+	}
+	static const BaseX& url() {
+		static constexpr BaseX encoder(0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", "", "", "");
+		return encoder;
+	}
+	static const BaseX& urlchk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", "", "", "");
+		return encoder;
+	}
+	static const BaseX& rfc4648() {
+		static constexpr BaseX encoder(BaseX::block_padding, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", "", "====", "
\r");
+		return encoder;
+	}
+	static const BaseX& rfc4648url() {
+		static constexpr BaseX encoder(BaseX::block_padding, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", "", "====", "
\r");
+		return encoder;
+	}
+};
+
+// base66
+struct Base66 {
+	static const BaseX& base66() {
+		static constexpr BaseX encoder(0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~", "", "", "");
+		return encoder;
+	}
+	static const BaseX& base66chk() {
+		static constexpr BaseX encoder(BaseX::with_checksum, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~", "", "", "");
+		return encoder;
+	}
+};
+
+#endif
diff --git a/contrib/base-x/uinteger_t.hh b/contrib/base-x/uinteger_t.hh
new file mode 100644
index 000000000000..901460f75c49
--- /dev/null
+++ b/contrib/base-x/uinteger_t.hh
@@ -0,0 +1,2546 @@
+/*
+uinteger_t.hh
+An arbitrary precision unsigned integer type for C++
+
+Copyright (c) 2017 German Mendez Bravo (Kronuz) @ german dot mb at gmail.com
+Copyright (c) 2013 - 2017 Jason Lee @ calccrypto at gmail.com
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+With much help from Auston Sterling
+
+Thanks to Stefan DeigmÃ¼ller for finding
+a bug in operator*.
+
+Thanks to FranÃ§ois Dessenne for convincing me
+to do a general rewrite of this class.
+
+GermÃ¡n MÃ¡ndez Bravo (Kronuz) converted Jason Lee's uint128_t
+to header-only and extended to arbitrary bit length.
+*/
+
+#ifndef __uint_t__
+#define __uint_t__
+
+#include <vector>
+#include <string>
+#include <cassert>
+#include <utility>
+#include <cstring>
+#include <cstdint>
+#include <iostream>
+#include <algorithm>
+#include <stdexcept>
+#include <functional>
+#include <type_traits>
+
+#define ASSERT assert
+
+// Compatibility inlines
+#ifndef __has_builtin         // Optional of course
+#define __has_builtin(x) 0    // Compatibility with non-clang compilers
+#endif
+
+#if defined _MSC_VER
+#  define HAVE___ADDCARRY_U64
+#  define HAVE___SUBBORROW_U64
+#  define HAVE___ADDCARRY_U32
+#  define HAVE___SUBBORROW_U32
+#  define HAVE___ADDCARRY_U16
+#  define HAVE___SUBBORROW_U16
+#  define HAVE___UMUL128
+#  define HAVE___UMUL64
+#  define HAVE___UMUL32
+#  include <intrin.h>
+#endif
+
+#if (defined(__clang__) && __has_builtin(__builtin_clzll)) || (defined(__GNUC__ ) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))
+#  define HAVE____BUILTIN_CLZLL
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_clzl)) || (defined(__GNUC__ ) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))
+#  define HAVE____BUILTIN_CLZL
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_clz)) || (defined(__GNUC__ ) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))
+#  define HAVE____BUILTIN_CLZ
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_addcll))
+#  define HAVE____BUILTIN_ADDCLL
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_addcl))
+#  define HAVE____BUILTIN_ADDCL
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_addc))
+#  define HAVE____BUILTIN_ADDC
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_subcll))
+#  define HAVE____BUILTIN_SUBCLL
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_subcl))
+#  define HAVE____BUILTIN_SUBCL
+#endif
+#if (defined(__clang__) && __has_builtin(__builtin_subc))
+#  define HAVE____BUILTIN_SUBC
+#endif
+
+#if defined __SIZEOF_INT128__
+#define HAVE____INT128_T
+#endif
+
+
+#ifndef DIGIT_T
+#define DIGIT_T        std::uint64_t
+#endif
+
+#ifndef HALF_DIGIT_T
+#define HALF_DIGIT_T   std::uint32_t
+#endif
+
+class uinteger_t;
+
+namespace std {  // This is probably not a good idea
+	// Give uinteger_t type traits
+	template <> struct is_arithmetic <uinteger_t> : std::true_type {};
+	template <> struct is_integral   <uinteger_t> : std::true_type {};
+	template <> struct is_unsigned   <uinteger_t> : std::true_type {};
+}
+
+class uinteger_t {
+public:
+	using digit = DIGIT_T;
+	using half_digit = HALF_DIGIT_T;
+
+	static constexpr std::size_t digit_octets = sizeof(digit);             // number of octets per digit
+	static constexpr std::size_t digit_bits = digit_octets * 8;            // number of bits per digit
+	static constexpr std::size_t half_digit_octets = sizeof(half_digit);   // number of octets per half_digit
+	static constexpr std::size_t half_digit_bits = half_digit_octets * 8;  // number of bits per half_digit
+
+	using container = std::vector<digit>;
+
+	template <typename T>
+	struct is_result {
+		static const bool value = false;
+	};
+
+	template <typename T, typename Alloc>
+	struct is_result<std::vector<T, Alloc>> {
+		static const bool value = true;
+	};
+
+	template <typename charT, typename traits, typename Alloc>
+	struct is_result<std::basic_string<charT, traits, Alloc>> {
+		static const bool value = true;
+	};
+
+private:
+	static_assert(digit_octets == half_digit_octets * 2, "half_digit must be exactly half the size of digit");
+
+	static constexpr std::size_t karatsuba_cutoff = 1024 / digit_bits;
+	static constexpr double growth_factor = 1.5;
+
+	std::size_t _begin;
+	std::size_t _end;
+	container _value_instance;
+	container& _value;
+	bool _carry;
+
+public:
+	// Window to vector (uses _begin and _end)
+
+	void reserve(std::size_t sz) {
+		_value.reserve(sz + _begin);
+	}
+
+	std::size_t grow(std::size_t n) {
+		// expands the vector using a growth factor
+		// and returns the new capacity.
+		auto cc = _value.capacity();
+		if (n >= cc) {
+			cc = n * growth_factor;
+			_value.reserve(cc);
+		}
+		return cc;
+	}
+
+	void resize(std::size_t sz) {
+		grow(sz + _begin);
+		_value.resize(sz + _begin);
+	}
+
+	void resize(std::size_t sz, const digit& c) {
+		grow(sz + _begin);
+		_value.resize(sz + _begin, c);
+	}
+
+	void clear() {
+		_value.clear();
+		_begin = 0;
+		_end = 0;
+		_carry = false;
+	}
+
+	digit* data() noexcept {
+		return _value.data() + _begin;
+	}
+
+	const digit* data() const noexcept {
+		return _value.data() + _begin;
+	}
+
+	std::size_t size() const noexcept {
+		return _end ? _end - _begin : _value.size() - _begin;
+	}
+
+	void prepend(std::size_t sz, const digit& c) {
+		// Efficiently prepend by growing backwards by growth factor
+		auto min = std::min(_begin, sz);
+		if (min) {
+			// If there is some space before `_begin`, we try using it first:
+			_begin -= min;
+			std::fill_n(_value.begin() + _begin, min, c);
+			sz -= min;
+		}
+		if (sz) {
+			ASSERT(_begin == 0); // _begin should be 0 in here
+			// If there's still more room needed, we grow the vector:
+			// Ex.: grow using prepend(3, y)
+			//    sz = 3
+			//    _begin = 0  (B)
+			//    _end = 1  (E)
+			// initially (capacity == 12):
+			//              |xxxxxxxxxx- |
+			//              B           E
+			// after reclaiming space after `_end` (same capacity == 12):
+			//              |xxxxxxxxxx  |
+			//              B
+			//    _end = 0
+			//    csz = 10
+			// grow returns the new capacity (22)
+			//    isz = 12  (22 - 10)
+			//    _begin = 9  (12 - 3)
+			// after (capacity == (12 + 3) * 1.5 == 22):
+			//    |---------yyyxxxxxxxxxx|
+			//              B
+			if (_end) {
+				// reclaim space after `_end`
+				_value.resize(_end);
+				_end = 0;
+			}
+			auto csz = _value.size();
+			auto isz = grow(csz + sz) - csz;
+			_value.insert(_value.begin(), isz, c);
+			_begin = isz - sz;
+		}
+	}
+
+	void prepend(const digit& c) {
+		prepend(1, c);
+	}
+
+	void prepend(const uinteger_t& num) {
+		prepend(num.size(), 0);
+		std::copy(num.begin(), num.end(), begin());
+	}
+
+	void append(std::size_t sz, const digit& c) {
+		// Efficiently append by growing by growth factor
+		if (_end) {
+			// reclaim space after `_end`
+			_value.resize(_end);
+			_end = 0;
+		}
+		auto nsz = _value.size() + sz;
+		grow(nsz);
+		_value.resize(nsz, c);
+	}
+
+	void append(const digit& c) {
+		append(1, c);
+	}
+
+	void append(const uinteger_t& num) {
+		auto sz = num.size();
+		append(sz, 0);
+		std::copy(num.begin(), num.end(), end() - sz);
+	}
+
+	container::iterator begin() noexcept {
+		return _value.begin() + _begin;
+	}
+
+	container::const_iterator begin() const noexcept {
+		return _value.cbegin() + _begin;
+	}
+
+	container::iterator end() noexcept {
+		return _end ? _value.begin() + _end : _value.end();
+	}
+
+	container::const_iterator end() const noexcept {
+		return _end ? _value.cbegin() + _end : _value.cend();
+	}
+
+	container::reverse_iterator rbegin() noexcept {
+		return _end ? container::reverse_iterator(_value.begin() + _end) : _value.rbegin();
+	}
+
+	container::const_reverse_iterator rbegin() const noexcept {
+		return _end ? container::const_reverse_iterator(_value.cbegin() + _end) : _value.crbegin();
+	}
+
+	container::reverse_iterator rend() noexcept {
+		return container::reverse_iterator(_value.begin() + _begin);
+	}
+
+	container::const_reverse_iterator rend() const noexcept {
+		return container::const_reverse_iterator(_value.cbegin() + _begin);
+	}
+
+	container::reference front() {
+		return *begin();
+	}
+
+	container::const_reference front() const {
+		return *begin();
+	}
+
+	container::reference back() {
+		return *rbegin();
+	}
+
+	container::const_reference back() const {
+		return *rbegin();
+	}
+
+private:
+	// Optimized primitives for operations
+
+	static digit _bits(digit x) {
+	#if defined HAVE____BUILTIN_CLZLL
+		if (digit_octets == sizeof(unsigned long long)) {
+			return x ? digit_bits - __builtin_clzll(x) : 1;
+		}
+	#endif
+	#if defined HAVE____BUILTIN_CLZL
+		if (digit_octets == sizeof(unsigned long)) {
+			return x ? digit_bits - __builtin_clzl(x) : 1;
+		}
+	#endif
+	#if defined HAVE____BUILTIN_CLZ
+		if (digit_octets == sizeof(unsigned)) {
+			return x ? digit_bits - __builtin_clz(x) : 1;
+		}
+	#endif
+		{
+			digit c = x ? 0 : 1;
+			while (x) {
+				x >>= 1;
+				++c;
+			}
+			return c;
+		}
+	}
+
+	static digit _mult(digit x, digit y, digit* lo) {
+	#if defined HAVE___UMUL128
+		if (digit_bits == 64) {
+			digit h;
+			digit l = _umul128(x, y, &h);  // _umul128(x, y, *hi) -> lo
+			return h;
+		}
+	#endif
+	#if defined HAVE___UMUL64
+		if (digit_bits == 32) {
+			digit h;
+			digit l = _umul64(x, y, &h);  // _umul64(x, y, *hi) -> lo
+			return h;
+		}
+	#endif
+	#if defined HAVE___UMUL32
+		if (digit_bits == 16) {
+			digit h;
+			digit l = _umul32(x, y, &h);  // _umul32(x, y, *hi) -> lo
+			return h;
+		}
+	#endif
+	#if defined HAVE____INT128_T
+		if (digit_bits == 64) {
+			auto r = static_cast<__uint128_t>(x) * static_cast<__uint128_t>(y);
+			*lo = r;
+			return r >> digit_bits;
+		}
+	#endif
+		if (digit_bits == 64) {
+			digit x0 = x & 0xffffffffUL;
+			digit x1 = x >> 32;
+			digit y0 = y & 0xffffffffUL;
+			digit y1 = y >> 32;
+
+			digit u = (x0 * y0);
+			digit v = (x1 * y0) + (u >> 32);
+			digit w = (x0 * y1) + (v & 0xffffffffUL);
+
+			*lo = (w << 32) + (u & 0xffffffffUL); // low
+			return (x1 * y1) + (v >> 32) + (w >> 32); // high
+		} if (digit_bits == 32) {
+			auto r = static_cast<std::uint64_t>(x) * static_cast<std::uint64_t>(y);
+			*lo = r;
+			return r >> 32;
+		} if (digit_bits == 16) {
+			auto r = static_cast<std::uint32_t>(x) * static_cast<std::uint32_t>(y);
+			*lo = r;
+			return r >> 16;
+		} if (digit_bits == 8) {
+			auto r = static_cast<std::uint16_t>(x) * static_cast<std::uint16_t>(y);
+			*lo = r;
+			return r >> 8;
+		}
+	}
+
+	static digit _multadd(digit x, digit y, digit a, digit c, digit* lo) {
+	#if defined HAVE___UMUL128 && defined HAVE___ADDCARRY_U64
+		if (digit_bits == 64) {
+			digit h;
+			digit l = _umul128(x, y, &h);  // _umul128(x, y, *hi) -> lo
+			return h + _addcarry_u64(c, l, a, lo);  // _addcarry_u64(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE___UMUL64 && defined HAVE___ADDCARRY_U32
+		if (digit_bits == 32) {
+			digit h;
+			digit l = _umul64(x, y, &h);  // _umul64(x, y, *hi) -> lo
+			return h + _addcarry_u32(c, l, a, lo);  // _addcarry_u32(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE___UMUL32 && defined HAVE___ADDCARRY_U16
+		if (digit_bits == 16) {
+			digit h;
+			digit l = _umul32(x, y, &h);  // _umul32(x, y, *hi) -> lo
+			return h + _addcarry_u16(c, l, a, lo);  // _addcarry_u16(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE____INT128_T
+		if (digit_bits == 64) {
+			auto r = static_cast<__uint128_t>(x) * static_cast<__uint128_t>(y) + static_cast<__uint128_t>(a) + static_cast<__uint128_t>(c);
+			*lo = r;
+			return r >> digit_bits;
+		}
+	#endif
+		if (digit_bits == 64) {
+			digit x0 = x & 0xffffffffUL;
+			digit x1 = x >> 32;
+			digit y0 = y & 0xffffffffUL;
+			digit y1 = y >> 32;
+
+			digit u = (x0 * y0) + (a & 0xffffffffUL) + (c & 0xffffffffUL);
+			digit v = (x1 * y0) + (u >> 32) + (a >> 32) + (c >> 32);
+			digit w = (x0 * y1) + (v & 0xffffffffUL);
+
+			*lo = (w << 32) + (u & 0xffffffffUL); // low
+			return (x1 * y1) + (v >> 32) + (w >> 32); // high
+		}
+		if (digit_bits == 32) {
+			auto r = static_cast<std::uint64_t>(x) * static_cast<std::uint64_t>(y) + static_cast<std::uint64_t>(a) + static_cast<std::uint64_t>(c);
+			*lo = r;
+			return r >> 32;
+		}
+		if (digit_bits == 16) {
+			auto r = static_cast<std::uint32_t>(x) * static_cast<std::uint32_t>(y) + static_cast<std::uint32_t>(a) + static_cast<std::uint32_t>(c);
+			*lo = r;
+			return r >> 16;
+		}
+		if (digit_bits == 8) {
+			auto r = static_cast<std::uint16_t>(x) * static_cast<std::uint16_t>(y) + static_cast<std::uint16_t>(a) + static_cast<std::uint16_t>(c);
+			*lo = r;
+			return r >> 8;
+		}
+	}
+
+	static digit _divmod(digit x_hi, digit x_lo, digit y, digit* result) {
+	#if defined HAVE____INT128_T
+		if (digit_bits == 64) {
+			auto x = static_cast<__uint128_t>(x_hi) << digit_bits | static_cast<__uint128_t>(x_lo);
+			digit q = x / y;
+			digit r = x % y;
+
+			*result = q;
+			return r;
+		}
+	#endif
+		if (digit_bits == 64) {
+			// quotient
+			digit q = x_lo << 1;
+
+			// remainder
+			digit r = x_hi;
+
+			digit carry = x_lo >> 63;
+			int i;
+
+			for (i = 0; i < 64; i++) {
+				auto tmp = r >> 63;
+				r <<= 1;
+				r |= carry;
+				carry = tmp;
+
+				if (carry == 0) {
+					if (r >= y) {
+						carry = 1;
+					} else {
+						tmp = q >> 63;
+						q <<= 1;
+						q |= carry;
+						carry = tmp;
+						continue;
+					}
+				}
+
+				r -= y;
+				r -= (1 - carry);
+				carry = 1;
+				tmp = q >> 63;
+				q <<= 1;
+				q |= carry;
+				carry = tmp;
+			}
+
+			*result = q;
+			return r;
+		}
+		if (digit_bits == 32) {
+			auto x = static_cast<std::uint64_t>(x_hi) << 32 | static_cast<std::uint64_t>(x_lo);
+			digit q = x / y;
+			digit r = x % y;
+
+			*result = q;
+			return r;
+		}
+		if (digit_bits == 16) {
+			auto x = static_cast<std::uint32_t>(x_hi) << 16 | static_cast<std::uint32_t>(x_lo);
+			digit q = x / y;
+			digit r = x % y;
+
+			*result = q;
+			return r;
+		}
+		if (digit_bits == 8) {
+			auto x = static_cast<std::uint16_t>(x_hi) << 8 | static_cast<std::uint16_t>(x_lo);
+			digit q = x / y;
+			digit r = x % y;
+
+			*result = q;
+			return r;
+		}
+	}
+
+	static digit _addcarry(digit x, digit y, digit c, digit* result) {
+	#if defined HAVE___ADDCARRY_U64
+		if (digit_bits == 64) {
+			return _addcarry_u64(c, x, y, result);  // _addcarry_u64(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE___ADDCARRY_U32
+		if (digit_bits == 32) {
+			return _addcarry_u32(c, x, y, result);  // _addcarry_u32(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE___ADDCARRY_U16
+		if (digit_bits == 16) {
+			return _addcarry_u16(c, x, y, result);  // _addcarry_u16(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE____BUILTIN_ADDCLL
+		if (digit_octets == sizeof(unsigned long long)) {
+			unsigned long long carryout;
+			*result = __builtin_addcll(x, y, c, &carryout);  // __builtin_addcll(x, y, carryin, *carryout) -> sum
+			return carryout;
+		}
+	#endif
+	#if defined HAVE____BUILTIN_ADDCL
+		if (digit_octets == sizeof(unsigned long)) {
+			unsigned long carryout;
+			*result = __builtin_addcl(x, y, c, &carryout);  // __builtin_addcl(x, y, carryin, *carryout) -> sum
+			return carryout;
+		}
+	#endif
+	#if defined HAVE____BUILTIN_ADDC
+		if (digit_octets == sizeof(unsigned)) {
+			unsigned carryout;
+			*result = __builtin_addc(x, y, c, &carryout);  // __builtin_addc(x, y, carryin, *carryout) -> sum
+			return carryout;
+		}
+	#endif
+	#if defined HAVE____INT128_T
+		if (digit_bits == 64) {
+			auto r = static_cast<__uint128_t>(x) + static_cast<__uint128_t>(y) + static_cast<__uint128_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> digit_bits);
+		}
+	#endif
+		if (digit_bits == 64) {
+			digit x0 = x & 0xffffffffUL;
+			digit x1 = x >> 32;
+			digit y0 = y & 0xffffffffUL;
+			digit y1 = y >> 32;
+
+			auto u = x0 + y0 + c;
+			auto v = x1 + y1 + static_cast<bool>(u >> 32);
+			*result = (v << 32) + (u & 0xffffffffUL);
+			return static_cast<bool>(v >> 32);
+		}
+		if (digit_bits == 32) {
+			auto r = static_cast<std::uint64_t>(x) + static_cast<std::uint64_t>(y) + static_cast<std::uint64_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 32);
+		}
+		if (digit_bits == 16) {
+			auto r = static_cast<std::uint32_t>(x) + static_cast<std::uint32_t>(y) + static_cast<std::uint32_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 16);
+		}
+		if (digit_bits == 8) {
+			auto r = static_cast<std::uint16_t>(x) + static_cast<std::uint16_t>(y) + static_cast<std::uint16_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 8);
+		}
+	}
+
+	static digit _subborrow(digit x, digit y, digit c, digit* result) {
+	#if defined HAVE___SUBBORROW_U64
+		if (digit_bits == 64) {
+			return _subborrow_u64(c, x, y, result);  // _subborrow_u64(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE___SUBBORROW_U32
+		if (digit_bits == 64) {
+			return _subborrow_u32(c, x, y, result);  // _subborrow_u32(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE___SUBBORROW_U16
+		if (digit_bits == 64) {
+			return _subborrow_u16(c, x, y, result);  // _subborrow_u16(carryin, x, y, *sum) -> carryout
+		}
+	#endif
+	#if defined HAVE____BUILTIN_SUBCLL
+		if (digit_octets == sizeof(unsigned long long)) {
+			unsigned long long carryout;
+			*result = __builtin_subcll(x, y, c, &carryout);  // __builtin_subcll(x, y, carryin, *carryout) -> sum
+			return carryout;
+		}
+	#endif
+	#if defined HAVE____BUILTIN_SUBCL
+		if (digit_octets == sizeof(unsigned long)) {
+			unsigned long carryout;
+			*result = __builtin_subcl(x, y, c, &carryout);  // __builtin_subcl(x, y, carryin, *carryout) -> sum
+			return carryout;
+		}
+	#endif
+	#if defined HAVE____BUILTIN_SUBC
+		if (digit_octets == sizeof(unsigned)) {
+			unsigned carryout;
+			*result = __builtin_subc(x, y, c, &carryout);  // __builtin_subc(x, y, carryin, *carryout) -> sum
+			return carryout;
+		}
+	#endif
+	#if defined HAVE____INT128_T
+		if (digit_bits == 64) {
+			auto r = static_cast<__uint128_t>(x) - static_cast<__uint128_t>(y) - static_cast<__uint128_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 64);
+		}
+	#endif
+		if (digit_bits == 64) {
+			digit x0 = x & 0xffffffffUL;
+			digit x1 = x >> 32;
+			digit y0 = y & 0xffffffffUL;
+			digit y1 = y >> 32;
+
+			auto u = x0 - y0 - c;
+			auto v = x1 - y1 - static_cast<bool>(u >> 32);
+			*result = (v << 32) + (u & 0xffffffffUL);
+			return static_cast<bool>(v >> 32);
+		}
+		if (digit_bits == 32) {
+			auto r = static_cast<std::uint64_t>(x) - static_cast<std::uint64_t>(y) - static_cast<std::uint64_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 32);
+		}
+		if (digit_bits == 16) {
+			auto r = static_cast<std::uint32_t>(x) - static_cast<std::uint32_t>(y) - static_cast<std::uint32_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 16);
+		}
+		if (digit_bits == 8) {
+			auto r = static_cast<std::uint16_t>(x) - static_cast<std::uint16_t>(y) - static_cast<std::uint16_t>(c);
+			*result = r;
+			return static_cast<bool>(r >> 8);
+		}
+	}
+
+	// Helper functions
+
+	void trim(digit mask = 0) {
+		auto rit = rbegin();
+		auto rit_e = rend();
+
+		// Masks the last value of internal vector
+		mask &= (digit_bits - 1);
+		if (mask && rit != rit_e) {
+			*rit &= (static_cast<digit>(1) << mask) - 1;
+		}
+
+		// Removes all unused zeros from the internal vector
+		auto rit_f = std::find_if(rit, rit_e, [](const digit& c) { return c; });
+		resize(rit_e - rit_f); // shrink
+	}
+
+	static constexpr char chr(int ord) {
+		constexpr const char _[256] = {
+			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',
+			'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
+			'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+		};
+		return _[ord];
+	}
+
+	static constexpr int ord(int chr) {
+		constexpr const int _[256] = {
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,
+
+			-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+			25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
+			-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
+			25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
+
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+		};
+		return _[chr];
+	}
+
+public:
+	static constexpr unsigned base_bits(int base) {
+		constexpr const unsigned _[256] = {
+			0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
+
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,
+
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
+		};
+		return _[base - 1];
+	}
+
+	static constexpr unsigned base_size(int base) {
+		constexpr const unsigned _[256] = {
+			0, 64, 41, 32, 28, 25, 23, 22, 21, 20, 19, 18, 18, 17, 17, 16,
+			16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 13, 13,
+			13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12,
+			12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11,
+
+			11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+			11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+			10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+			10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+
+			10, 10, 10, 10, 10, 10, 10, 10, 10, 10,  9,  9,  9,  9,  9,  9,
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
+
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
+			9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  8,
+		};
+		return _[base - 1];
+	}
+
+	static const uinteger_t uint_0() {
+		static uinteger_t uint_0(0);
+		return uint_0;
+	}
+
+	static const uinteger_t uint_1() {
+		static uinteger_t uint_1(1);
+		return uint_1;
+	}
+
+private:
+	// Public Implementation
+#ifdef UINT_T_PUBLIC_IMPLEMENTATION
+public:
+#endif
+	static uinteger_t& bitwise_and(uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz > rhs_sz) {
+			lhs.resize(rhs_sz); // shrink
+		}
+
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs.end();
+
+		auto rhs_it = rhs.begin();
+
+		for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it) {
+			*lhs_it &= *rhs_it;
+		}
+
+		// Finish up
+		lhs.trim();
+		return lhs;
+	}
+
+	static uinteger_t& bitwise_and(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		auto result_sz = std::max(lhs_sz, rhs_sz);
+		result.resize(result_sz);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		auto it = result.begin();
+
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				*it = *lhs_it & *rhs_it;
+			}
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++it) {
+				*it = 0;
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				*it = *lhs_it & *rhs_it;
+			}
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				*it = 0;
+			}
+		}
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t bitwise_and(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		bitwise_and(result, lhs, rhs);
+		return result;
+	}
+
+	static uinteger_t& bitwise_or(uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz < rhs_sz) {
+			lhs.resize(rhs_sz, 0); // grow
+		}
+
+		auto lhs_it = lhs.begin();
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs.end();
+
+		for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {
+			*lhs_it |= *rhs_it;
+		}
+
+		// Finish up
+		lhs.trim();
+		return lhs;
+	}
+
+	static uinteger_t& bitwise_or(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		auto result_sz = std::max(lhs_sz, rhs_sz);
+		result.resize(result_sz);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		auto it = result.begin();
+
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				*it = *lhs_it | *rhs_it;
+			}
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++it) {
+				*it = *rhs_it;
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				*it = *lhs_it | *rhs_it;
+			}
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				*it = *lhs_it;
+			}
+		}
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+	static uinteger_t bitwise_or(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		bitwise_or(result, lhs, rhs);
+		return result;
+	}
+
+	static uinteger_t& bitwise_xor(uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz < rhs_sz) {
+			lhs.resize(rhs_sz, 0); // grow
+		}
+
+		auto lhs_it = lhs.begin();
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs.end();
+
+		for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {
+			*lhs_it ^= *rhs_it;
+		}
+
+		// Finish up
+		lhs.trim();
+		return lhs;
+	}
+
+	static uinteger_t& bitwise_xor(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		auto result_sz = std::max(lhs_sz, rhs_sz);
+		result.resize(result_sz);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		auto it = result.begin();
+
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				*it = *lhs_it ^ *rhs_it;
+			}
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++it) {
+				*it = *rhs_it;
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				*it = *lhs_it ^ *rhs_it;
+			}
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				*it = *lhs_it;
+			}
+		}
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t bitwise_xor(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		bitwise_xor(result, lhs, rhs);
+		return result;
+	}
+
+	static uinteger_t& bitwise_inv(uinteger_t& lhs) {
+		auto lhs_sz = lhs.size();
+
+		auto b = lhs.bits();
+
+		if (!lhs_sz) {
+			lhs.append(0);
+		}
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` if `result` is also `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		for (; lhs_it != lhs_it_e; ++lhs_it) {
+			*lhs_it = ~*lhs_it;
+		}
+
+		// Finish up
+		lhs.trim(b ? b : 1);
+		return lhs;
+	}
+
+	static uinteger_t& bitwise_inv(uinteger_t& result, const uinteger_t& lhs) {
+		auto lhs_sz = lhs.size();
+
+		auto b = lhs.bits();
+
+		auto result_sz = lhs_sz ? lhs_sz : 1;
+		result.resize(result_sz);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` if `result` is also `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto it = result.begin();
+		auto it_e = it + result_sz;
+
+		for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+			*it = ~*lhs_it;
+		}
+		for (; it != it_e; ++it) {
+			*it = ~static_cast<digit>(0);
+		}
+
+		// Finish up
+		result.trim(b ? b : 1);
+		return result;
+	}
+
+	static uinteger_t bitwise_inv(const uinteger_t& lhs) {
+		uinteger_t result;
+		bitwise_inv(result, lhs);
+		return result;
+	}
+
+	static uinteger_t& bitwise_lshift(uinteger_t& lhs, const uinteger_t& rhs) {
+		if (!rhs) {
+			return lhs;
+		}
+
+		uinteger_t shifts_q;
+		uinteger_t shifts_r;
+		auto _digit_bits = digit_bits;
+		auto uint_digit_bits = uinteger_t(_digit_bits);
+		divmod(shifts_q, shifts_r, rhs, uint_digit_bits);
+		std::size_t shifts = static_cast<std::size_t>(shifts_q);
+		std::size_t shift = static_cast<std::size_t>(shifts_r);
+
+		if (shifts) {
+			lhs.prepend(shifts, 0);
+		}
+		if (shift) {
+			digit shifted = 0;
+			auto lhs_it = lhs.begin() + shifts;
+			auto lhs_it_e = lhs.end();
+			for (; lhs_it != lhs_it_e; ++lhs_it) {
+				auto v = (*lhs_it << shift) | shifted;
+				shifted = *lhs_it >> (_digit_bits - shift);
+				*lhs_it = v;
+			}
+			if (shifted) {
+				lhs.append(shifted);
+			}
+		}
+
+		// Finish up
+		lhs.trim();
+		return lhs;
+	}
+
+	static uinteger_t& bitwise_lshift(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		if (&result._value == &lhs._value) {
+			bitwise_lshift(result, rhs);
+			return result;
+		}
+		if (!rhs) {
+			result = lhs;
+			return result;
+		}
+
+		auto lhs_sz = lhs.size();
+
+		uinteger_t shifts_q;
+		uinteger_t shifts_r;
+		auto _digit_bits = digit_bits;
+		auto uint_digit_bits = uinteger_t(_digit_bits);
+		divmod(shifts_q, shifts_r, rhs, uint_digit_bits);
+		std::size_t shifts = static_cast<std::size_t>(shifts_q);
+		std::size_t shift = static_cast<std::size_t>(shifts_r);
+
+		auto result_sz = lhs_sz + shifts;
+		result.grow(result_sz + 1);
+		result.resize(shifts, 0);
+		result.resize(result_sz);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` if `result` is also `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto it = result.begin() + shifts;
+
+		if (shift) {
+			digit shifted = 0;
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				auto v = (*lhs_it << shift) | shifted;
+				shifted = *lhs_it >> (_digit_bits - shift);
+				*it = v;
+			}
+			if (shifted) {
+				result.append(shifted);
+			}
+		} else {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				*it = *lhs_it;
+			}
+		}
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t bitwise_lshift(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		bitwise_lshift(result, lhs, rhs);
+		return result;
+	}
+
+	static uinteger_t& bitwise_rshift(uinteger_t& lhs, const uinteger_t& rhs) {
+		if (!rhs) {
+			return lhs;
+		}
+
+		auto lhs_sz = lhs.size();
+
+		auto _digit_bits = digit_bits;
+		if (compare(rhs, uinteger_t(lhs_sz * _digit_bits)) >= 0) {
+			lhs = uint_0();
+			return lhs;
+		}
+
+		uinteger_t shifts_q;
+		uinteger_t shifts_r;
+		auto uint_digit_bits = uinteger_t(_digit_bits);
+		divmod(shifts_q, shifts_r, rhs, uint_digit_bits);
+		std::size_t shifts = static_cast<std::size_t>(shifts_q);
+		std::size_t shift = static_cast<std::size_t>(shifts_r);
+
+		if (shifts) {
+			lhs._begin += shifts;
+		}
+		if (shift) {
+			digit shifted = 0;
+			auto lhs_rit = lhs.rbegin();
+			auto lhs_rit_e = lhs.rend();
+			for (; lhs_rit != lhs_rit_e; ++lhs_rit) {
+				auto v = (*lhs_rit >> shift) | shifted;
+				shifted = *lhs_rit << (_digit_bits - shift);
+				*lhs_rit = v;
+			}
+			lhs.trim();
+		}
+
+		return lhs;
+	}
+
+	static uinteger_t& bitwise_rshift(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		if (&result._value == &lhs._value) {
+			bitwise_lshift(result, rhs);
+			return result;
+		}
+		if (!rhs) {
+			result = lhs;
+			return result;
+		}
+
+		auto lhs_sz = lhs.size();
+
+		auto _digit_bits = digit_bits;
+		if (compare(rhs, uinteger_t(lhs_sz * _digit_bits)) >= 0) {
+			result = uint_0();
+			return result;
+		}
+
+		uinteger_t shifts_q;
+		uinteger_t shifts_r;
+		auto uint_digit_bits = uinteger_t(_digit_bits);
+		divmod(shifts_q, shifts_r, rhs, uint_digit_bits);
+		std::size_t shifts = static_cast<std::size_t>(shifts_q);
+		std::size_t shift = static_cast<std::size_t>(shifts_r);
+
+		auto result_sz = lhs_sz - shifts;
+		result.resize(result_sz);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` if `result` is also `lhs`.
+		auto lhs_rit = lhs.rbegin();
+		auto lhs_rit_e = lhs_rit + lhs_sz - shifts;
+
+		auto rit = result.rbegin();
+		auto rit_e = rit + result_sz;
+
+		if (shift) {
+			digit shifted = 0;
+			for (; lhs_rit != lhs_rit_e; ++lhs_rit, ++rit) {
+				ASSERT(rit != rit_e); (void)(rit_e);
+				auto v = (*lhs_rit >> shift) | shifted;
+				shifted = *lhs_rit << (_digit_bits - shift);
+				*rit = v;
+			}
+		} else {
+			for (; lhs_rit != lhs_rit_e; ++lhs_rit, ++rit) {
+				ASSERT(rit != rit_e); (void)(rit_e);
+				*rit = *lhs_rit;
+			}
+		}
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t bitwise_rshift(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		bitwise_rshift(result, lhs, rhs);
+		return result;
+	}
+
+	static int compare(const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz > rhs_sz) return 1;
+		if (lhs_sz < rhs_sz) return -1;
+
+		auto lhs_rit = lhs.rbegin();
+		auto lhs_rit_e = lhs.rend();
+
+		auto rhs_rit = rhs.rbegin();
+
+		for (; lhs_rit != lhs_rit_e && *lhs_rit == *rhs_rit; ++lhs_rit, ++rhs_rit);
+
+		if (lhs_rit != lhs_rit_e) {
+			if (*lhs_rit > *rhs_rit) return 1;
+			if (*lhs_rit < *rhs_rit) return -1;
+		}
+
+		return 0;
+	}
+
+	static uinteger_t& long_add(uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz < rhs_sz) {
+			lhs.reserve(rhs_sz + 1);
+			lhs.resize(rhs_sz, 0); // grow
+		}
+
+		// not using `end()` because resize of `lhs.resize()` could have
+		// resized `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		digit carry = 0;
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++rhs_it, ++lhs_it) {
+				carry = _addcarry(*lhs_it, *rhs_it, carry, &*lhs_it);
+			}
+			for (; carry && rhs_it != rhs_it_e; ++rhs_it, ++lhs_it) {
+				carry = _addcarry(0, *rhs_it, carry, &*lhs_it);
+			}
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++lhs_it) {
+				*lhs_it = *rhs_it;
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++lhs_it) {
+				carry = _addcarry(*lhs_it, *rhs_it, carry, &*lhs_it);
+			}
+			for (; carry && lhs_it != lhs_it_e; ++lhs_it) {
+				carry = _addcarry(*lhs_it, 0, carry, &*lhs_it);
+			}
+		}
+
+		if (carry) {
+			lhs.append(1);
+		}
+
+		lhs._carry = false;
+
+		// Finish up
+		lhs.trim();
+		return lhs;
+	}
+
+	static uinteger_t& long_add(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		auto result_sz = std::max(lhs_sz, rhs_sz);
+		result.reserve(result_sz + 1);
+		result.resize(result_sz, 0);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		auto it = result.begin();
+
+		digit carry = 0;
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				carry = _addcarry(*lhs_it, *rhs_it, carry, &*it);
+			}
+			for (; carry && rhs_it != rhs_it_e; ++rhs_it, ++it) {
+				carry = _addcarry(0, *rhs_it, carry, &*it);
+			}
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++it) {
+				*it = *rhs_it;
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				carry = _addcarry(*lhs_it, *rhs_it, carry, &*it);
+			}
+			for (; carry && lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				carry = _addcarry(*lhs_it, 0, carry, &*it);
+			}
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				*it = *lhs_it;
+			}
+		}
+
+		if (carry) {
+			result.append(1);
+		}
+		result._carry = false;
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t& add(uinteger_t& lhs, const uinteger_t& rhs) {
+		// First try saving some calculations:
+		if (!rhs) {
+			return lhs;
+		}
+		if (!lhs) {
+			lhs = rhs;
+			return lhs;
+		}
+
+		return long_add(lhs, rhs);
+	}
+
+	static uinteger_t& add(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		// First try saving some calculations:
+		if (!rhs) {
+			result = lhs;
+			return result;
+		}
+		if (!lhs) {
+			result = rhs;
+			return result;
+		}
+
+		return long_add(result, lhs, rhs);
+	}
+
+	static uinteger_t add(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		add(result, lhs, rhs);
+		return result;
+	}
+
+	static uinteger_t& long_sub(uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz < rhs_sz) {
+			lhs.resize(rhs_sz, 0); // grow
+		}
+
+		// not using `end()` because resize of `lhs.resize()` could have
+		// resized `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		digit borrow = 0;
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it) {
+				borrow = _subborrow(*lhs_it, *rhs_it, borrow, &*lhs_it);
+			}
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {
+				borrow = _subborrow(0, *rhs_it, borrow, &*lhs_it);
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it) {
+				borrow = _subborrow(*lhs_it, *rhs_it, borrow, &*lhs_it);
+			}
+			for (; borrow && lhs_it != lhs_it_e; ++lhs_it) {
+				borrow = _subborrow(*lhs_it, 0, borrow, &*lhs_it);
+			}
+		}
+
+		lhs._carry = borrow;
+
+		// Finish up
+		lhs.trim();
+		return lhs;
+	}
+
+	static uinteger_t& long_sub(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		auto result_sz = std::max(lhs_sz, rhs_sz);
+		result.resize(result_sz, 0);
+
+		// not using `end()` because resize of `result.resize()` could have
+		// resized `lhs` or `rhs` if `result` is also either `rhs` or `lhs`.
+		auto lhs_it = lhs.begin();
+		auto lhs_it_e = lhs_it + lhs_sz;
+
+		auto rhs_it = rhs.begin();
+		auto rhs_it_e = rhs_it + rhs_sz;
+
+		auto it = result.begin();
+
+		digit borrow = 0;
+		if (lhs_sz < rhs_sz) {
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				borrow = _subborrow(*lhs_it, *rhs_it, borrow, &*it);
+			}
+			for (; rhs_it != rhs_it_e; ++rhs_it, ++it) {
+				borrow = _subborrow(0, *rhs_it, borrow, &*it);
+			}
+		} else {
+			for (; rhs_it != rhs_it_e; ++lhs_it, ++rhs_it, ++it) {
+				borrow = _subborrow(*lhs_it, *rhs_it, borrow, &*it);
+			}
+			for (; borrow && lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				borrow = _subborrow(*lhs_it, 0, borrow, &*it);
+			}
+			for (; lhs_it != lhs_it_e; ++lhs_it, ++it) {
+				*it = *lhs_it;
+			}
+		}
+
+		result._carry = borrow;
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t& sub(uinteger_t& lhs, const uinteger_t& rhs) {
+		// First try saving some calculations:
+		if (!rhs) {
+			return lhs;
+		}
+
+		return long_sub(lhs, rhs);
+	}
+
+	static uinteger_t& sub(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		// First try saving some calculations:
+		if (!rhs) {
+			result = lhs;
+			return result;
+		}
+
+		return long_sub(result, lhs, rhs);
+	}
+
+	static uinteger_t sub(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		sub(result, lhs, rhs);
+		return result;
+	}
+
+	// Single word long multiplication
+	// Fastests, but ONLY for single sized rhs
+	static uinteger_t& single_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		ASSERT(rhs_sz == 1); (void)(rhs_sz);
+		auto n = rhs.front();
+
+		uinteger_t tmp;
+		tmp.resize(lhs_sz + 1, 0);
+
+		auto it_lhs = lhs.begin();
+		auto it_lhs_e = lhs.end();
+
+		auto it_result = tmp.begin();
+
+		digit carry = 0;
+		for (; it_lhs != it_lhs_e; ++it_lhs, ++it_result) {
+			carry = _multadd(*it_lhs, n, 0, carry, &*it_result);
+		}
+		if (carry) {
+			*it_result = carry;
+		}
+
+		result = std::move(tmp);
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t& long_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz > rhs_sz) {
+			// rhs should be the largest:
+			return long_mult(result, rhs, lhs);
+		}
+
+		if (lhs_sz == 1) {
+			return single_mult(result, rhs, lhs);
+		}
+
+		uinteger_t tmp;
+		tmp.resize(lhs_sz + rhs_sz, 0);
+
+		auto it_lhs = lhs.begin();
+		auto it_lhs_e = lhs.end();
+
+		auto it_rhs = rhs.begin();
+		auto it_rhs_e = rhs.end();
+
+		auto it_result = tmp.begin();
+		auto it_result_s = it_result;
+		auto it_result_l = it_result;
+
+		for (; it_lhs != it_lhs_e; ++it_lhs, ++it_result) {
+			if (auto lhs_it_val = *it_lhs) {
+				auto _it_rhs = it_rhs;
+				auto _it_result = it_result;
+				digit carry = 0;
+				for (; _it_rhs != it_rhs_e; ++_it_rhs, ++_it_result) {
+					carry = _multadd(*_it_rhs, lhs_it_val, *_it_result, carry, &*_it_result);
+				}
+				if (carry) {
+					*_it_result++ = carry;
+				}
+				if (it_result_l < _it_result) {
+					it_result_l = _it_result;
+				}
+			}
+		}
+
+		tmp.resize(it_result_l - it_result_s); // shrink
+
+		result = std::move(tmp);
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	// A helper for Karatsuba multiplication to split a number in two, at n.
+	static std::pair<const uinteger_t, const uinteger_t> karatsuba_mult_split(const uinteger_t& num, std::size_t n) {
+		const uinteger_t a(num, num._begin, num._begin + n);
+		const uinteger_t b(num, num._begin + n, num._end);
+		return std::make_pair(std::move(a), std::move(b));
+	}
+
+	// If rhs has at least twice the digits of lhs, and lhs is big enough that
+	// Karatsuba would pay off *if* the inputs had balanced sizes.
+	// View rhs as a sequence of slices, each with lhs.size() digits,
+	// and multiply the slices by lhs, one at a time.
+	static uinteger_t& karatsuba_lopsided_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs, std::size_t cutoff) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		ASSERT(lhs_sz > cutoff);
+		ASSERT(2 * lhs_sz <= rhs_sz);
+
+		auto rhs_begin = rhs._begin;
+		std::size_t shift = 0;
+
+		uinteger_t r;
+		while (rhs_sz > 0) {
+			// Multiply the next slice of rhs by lhs and add into result:
+			auto slice_size = std::min(lhs_sz, rhs_sz);
+			const uinteger_t rhs_slice(rhs, rhs_begin, rhs_begin + slice_size);
+			uinteger_t p;
+			karatsuba_mult(p, lhs, rhs_slice, cutoff);
+			uinteger_t rs(r, shift, 0);
+			add(rs, rs, p);
+			shift += slice_size;
+			rhs_sz -= slice_size;
+			rhs_begin += slice_size;
+		}
+
+		result = std::move(r);
+		return result;
+	}
+
+	// Karatsuba multiplication
+	static uinteger_t& karatsuba_mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs, std::size_t cutoff = 1) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		if (lhs_sz > rhs_sz) {
+			// rhs should be the largest:
+			return karatsuba_mult(result, rhs, lhs, cutoff);
+		}
+
+		if (lhs_sz <= cutoff) {
+			return long_mult(result, lhs, rhs);
+		}
+
+		// If a is too small compared to b, splitting on b gives a degenerate case
+		// in which Karatsuba may be (even much) less efficient than long multiplication.
+		if (2 * lhs_sz <= rhs_sz) {
+			return karatsuba_lopsided_mult(result, lhs, rhs, cutoff);
+		}
+
+		// Karatsuba:
+		//
+		//                  A      B
+		//               x  C      D
+		//     ---------------------
+		//                 AD     BD
+		//       AC        BC
+		//     ---------------------
+		//       AC    AD + BC    BD
+		//
+		//  AD + BC  =
+		//  AC + AD + BC + BD - AC - BD
+		//  (A + B) (C + D) - AC - BD
+
+		// Calculate the split point near the middle of the largest (rhs).
+		auto shift = rhs_sz >> 1;
+
+		// Split to get A and B:
+		const auto lhs_pair = karatsuba_mult_split(lhs, shift);
+		const auto& A = lhs_pair.second; // hi
+		const auto& B = lhs_pair.first;  // lo
+
+		// Split to get C and D:
+		const auto rhs_pair = karatsuba_mult_split(rhs, shift);
+		const auto& C = rhs_pair.second; // hi
+		const auto& D = rhs_pair.first;  // lo
+
+		// Get the pieces:
+		uinteger_t AC;
+		karatsuba_mult(AC, A, C, cutoff);
+
+		uinteger_t BD;
+		karatsuba_mult(BD, B, D, cutoff);
+		uinteger_t AD_BC, AB, CD;
+		karatsuba_mult(AD_BC, A + B, C + D, cutoff);
+		AD_BC -= AC;
+		AD_BC -= BD;
+
+		// Join the pieces, AC and BD (can't overlap) into BD:
+		BD.reserve(shift * 2 + AC.size());
+		BD.resize(shift * 2, 0);
+		BD.append(AC);
+
+		// And add AD_BC to the middle: (AC           BD) + (    AD + BC    ):
+		uinteger_t BDs(BD, shift, 0);
+		add(BDs, BDs, AD_BC);
+
+		result = std::move(BD);
+
+		// Finish up
+		result.trim();
+		return result;
+	}
+
+	static uinteger_t& mult(uinteger_t& lhs, const uinteger_t& rhs) {
+		// Hard to see how this could have a further optimized implementation.
+		return mult(lhs, lhs, rhs);
+	}
+
+	static uinteger_t& mult(uinteger_t& result, const uinteger_t& lhs, const uinteger_t& rhs) {
+		// First try saving some calculations:
+		if (!lhs || !rhs) {
+			result = uint_0();
+			return result;
+		}
+		if (compare(lhs, uint_1()) == 0) {
+			result = rhs;
+			return result;
+		}
+		if (compare(rhs, uint_1()) == 0) {
+			result = lhs;
+			return result;
+		}
+
+		return karatsuba_mult(result, lhs, rhs, karatsuba_cutoff);
+	}
+
+	static uinteger_t mult(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t result;
+		mult(result, lhs, rhs);
+		return result;
+	}
+
+	// Single word long division
+	// Fastests, but ONLY for single sized rhs
+	static std::pair<std::reference_wrapper<uinteger_t>, std::reference_wrapper<uinteger_t>> single_divmod(uinteger_t& quotient, uinteger_t& remainder, const uinteger_t& lhs, const uinteger_t& rhs) {
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+
+		ASSERT(rhs_sz == 1); (void)(rhs_sz);
+		auto n = rhs.front();
+
+		auto rit_lhs = lhs.rbegin();
+		auto rit_lhs_e = lhs.rend();
+
+		auto q = uint_0();
+		q.resize(lhs_sz, 0);
+		auto rit_q = q.rbegin();
+
+		digit r = 0;
+		for (; rit_lhs != rit_lhs_e; ++rit_lhs, ++rit_q) {
+			r = _divmod(r, *rit_lhs, n, &*rit_q);
+		}
+
+		q.trim();
+
+		quotient = std::move(q);
+		remainder = r;
+		return std::make_pair(std::ref(quotient), std::ref(remainder));
+	}
+
+	// Implementation of Knuth's Algorithm D
+	static std::pair<std::reference_wrapper<uinteger_t>, std::reference_wrapper<uinteger_t>> knuth_divmod(uinteger_t& quotient, uinteger_t& remainder, const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t v(lhs);
+		uinteger_t w(rhs);
+
+		auto v_size = v.size();
+		auto w_size = w.size();
+		ASSERT(v_size >= w_size && w_size >= 2);
+
+		// D1. normalize: shift rhs left so that its top digit is >= 63 bits.
+		// shift lhs left by the same amount. Results go into w and v.
+		auto d = uinteger_t(digit_bits - _bits(w.back()));
+		v <<= d;
+		w <<= d;
+
+		if (*v.rbegin() >= *w.rbegin()) {
+			v.append(0);
+		}
+		v_size = v.size();
+		v.append(0);
+
+		// Now *v.rbegin() < *w.rbegin() so quotient has at most
+		// (and usually exactly) k = v.size() - w.size() digits.
+		auto k = v_size - w_size;
+		auto q = uint_0();
+		q.resize(k + 1, 0);
+
+		auto rit_q = q.rend() - (k + 1);
+
+		auto it_v_b = v.begin();
+		auto it_v_k = it_v_b + k;
+
+		auto it_w = w.begin();
+		auto it_w_e = w.end();
+
+		auto rit_w = w.rbegin();
+		auto wm1 = *rit_w++;
+		auto wm2 = *rit_w;
+
+		// D2. inner loop: divide v[k+0..k+n] by w[0..n]
+		for (; it_v_k >= it_v_b; --it_v_k, ++rit_q) {
+			// D3. Compute estimate quotient digit q; may overestimate by 1 (rare)
+			digit _q;
+			auto _r = _divmod(*(it_v_k + w_size), *(it_v_k + w_size - 1), wm1, &_q);
+			digit mullo = 0;
+			auto mulhi = _mult(_q, wm2, &mullo);
+			auto rlo = *(it_v_k + w_size - 2);
+			while (mulhi > _r || (mulhi == _r && mullo > rlo)) {
+				--_q;
+				if (_addcarry(_r, wm1, 0, &_r)) {
+					break;
+				}
+				mulhi = _mult(_q, wm2, &mullo);
+			}
+
+			// D4. Multiply and subtract _q * w0[0:size_w] from vk[0:size_w+1]
+			auto _it_v = it_v_k;
+			auto _it_w = it_w;
+			mulhi = 0;
+			digit carry = 0;
+			for (; _it_w != it_w_e; ++_it_v, ++_it_w) {
+				mullo = 0;
+				mulhi = _multadd(*_it_w, _q, 0, mulhi, &mullo);
+				carry = _subborrow(*_it_v, mullo, carry, &*_it_v);
+			}
+			carry = _subborrow(*_it_v, 0, carry, &*_it_v);
+
+			if (carry) {
+				// D6. Add w back if q was too large (this branch taken rarely)
+				--_q;
+
+				_it_v = it_v_k;
+				_it_w = it_w;
+				carry = 0;
+				for (; _it_w != it_w_e; ++_it_v, ++_it_w) {
+					carry = _addcarry(*_it_v, *_it_w, carry, &*_it_v);
+				}
+				carry = _addcarry(*_it_v, 0, carry, &*_it_v);
+			}
+
+			/* store quotient digit */
+			*rit_q = _q;
+		}
+
+		// D8. unnormalize: unshift remainder.
+		v.resize(w_size);
+		v >>= d;
+
+		q.trim();
+		v.trim();
+
+		quotient = std::move(q);
+		remainder = std::move(v);
+		return std::make_pair(std::ref(quotient), std::ref(remainder));
+	}
+
+	static std::pair<std::reference_wrapper<uinteger_t>, std::reference_wrapper<uinteger_t>> divmod(uinteger_t& quotient, uinteger_t& remainder, const uinteger_t& lhs, const uinteger_t& rhs) {
+		// First try saving some calculations:
+		if (!rhs) {
+			throw std::domain_error("Error: division or modulus by 0");
+		}
+		auto lhs_sz = lhs.size();
+		auto rhs_sz = rhs.size();
+		if (lhs_sz == 1 && rhs_sz == 1) {
+			// Fast division and modulo for single value
+			auto a = *lhs.begin();
+			auto b = *rhs.begin();
+			quotient = a / b;
+			remainder = a % b;
+			return std::make_pair(std::ref(quotient), std::ref(remainder));
+		}
+		if (compare(rhs, uint_1()) == 0) {
+			quotient = lhs;
+			remainder = uint_0();
+			return std::make_pair(std::ref(quotient), std::ref(remainder));
+		}
+		auto compared = compare(lhs, rhs);
+		if (compared == 0) {
+			quotient = uint_1();
+			remainder = uint_0();
+			return std::make_pair(std::ref(quotient), std::ref(remainder));
+		}
+		if (!lhs || compared < 0) {
+			quotient = uint_0();
+			remainder = lhs;
+			return std::make_pair(std::ref(quotient), std::ref(remainder));
+		}
+		if (rhs_sz == 1) {
+			return single_divmod(quotient, remainder, lhs, rhs);
+		}
+
+		return knuth_divmod(quotient, remainder, lhs, rhs);
+	}
+
+	static std::pair<uinteger_t, uinteger_t> divmod(const uinteger_t& lhs, const uinteger_t& rhs) {
+		uinteger_t quotient;
+		uinteger_t remainder;
+		divmod(quotient, remainder, lhs, rhs);
+		return std::make_pair(std::move(quotient), std::move(remainder));
+	}
+
+private:
+	// Constructors
+
+	template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+	void _uint_t(const T& value) {
+		append(static_cast<digit>(value));
+	}
+
+	template <typename T, typename... Args, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+	void _uint_t(const T& value, Args... args) {
+		_uint_t(args...);
+		append(static_cast<digit>(value));
+	}
+
+	// This constructor creates a window view of the _value
+	uinteger_t(const uinteger_t& o, std::size_t begin, std::size_t end) :
+		_begin(begin),
+		_end(end),
+		_value(o._value),
+		_carry(o._carry) { }
+
+public:
+	uinteger_t() :
+		_begin(0),
+		_end(0),
+		_value(_value_instance),
+		_carry(false) { }
+
+	uinteger_t(const uinteger_t& o) :
+		_begin(0),
+		_end(0),
+		_value_instance(o.begin(), o.end()),
+		_value(_value_instance),
+		_carry(o._carry) { }
+
+	uinteger_t(uinteger_t&& o) :
+		_begin(std::move(o._begin)),
+		_end(std::move(o._end)),
+		_value_instance(std::move(o._value_instance)),
+		_value(_value_instance),
+		_carry(std::move(o._carry)) { }
+
+	template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+	uinteger_t(const T& value) :
+		_begin(0),
+		_end(0),
+		_value(_value_instance),
+		_carry(false) {
+		if (value) {
+			append(static_cast<digit>(value));
+		}
+	}
+
+	template <typename T, typename... Args, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+	uinteger_t(const T& value, Args... args) :
+		_begin(0),
+		_end(0),
+		_value(_value_instance),
+		_carry(false) {
+		_uint_t(args...);
+		append(static_cast<digit>(value));
+		trim();
+	}
+
+	template <typename T, typename... Args, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+	uinteger_t(std::initializer_list<T> list) :
+		_begin(0),
+		_end(0),
+		_value(_value_instance),
+		_carry(false) {
+		reserve(list.size());
+		for (const auto& value : list) {
+			append(static_cast<digit>(value));
+		}
+		trim();
+	}
+
+	template <typename T, std::size_t N>
+	explicit uinteger_t(T (&s)[N], int base=10) :
+		uinteger_t(s, N - 1, base) { }
+
+	explicit uinteger_t(const unsigned char* bytes, std::size_t sz, int base) :
+		uinteger_t(strtouint(bytes, sz, base)) { }
+
+	explicit uinteger_t(const char* bytes, std::size_t sz, int base) :
+		uinteger_t(strtouint(bytes, sz, base)) { }
+
+	template <typename T>
+	explicit uinteger_t(const std::vector<T>& bytes, int base=10) :
+		uinteger_t(bytes.data(), bytes.size(), base) { }
+
+	explicit uinteger_t(const std::string& bytes, int base=10) :
+		uinteger_t(bytes.data(), bytes.size(), base) { }
+
+	// Assignment Operator
+	uinteger_t& operator=(const uinteger_t& o) {
+		_begin = 0;
+		_end = 0;
+		_value = container(o.begin(), o.end());
+		_carry = o._carry;
+		return *this;
+	}
+	uinteger_t& operator=(uinteger_t&& o) {
+		_begin = std::move(o._begin);
+		_end = std::move(o._end);
+		_value_instance = std::move(o._value_instance);
+		_carry = std::move(o._carry);
+		return *this;
+	}
+
+	// Typecast Operators
+	explicit operator bool() const {
+		return static_cast<bool>(size());
+	}
+	explicit operator unsigned char() const {
+		return static_cast<unsigned char>(size() ? front() : 0);
+	}
+	explicit operator unsigned short() const {
+		return static_cast<unsigned short>(size() ? front() : 0);
+	}
+	explicit operator unsigned int() const {
+		return static_cast<unsigned int>(size() ? front() : 0);
+	}
+	explicit operator unsigned long() const {
+		return static_cast<unsigned long>(size() ? front() : 0);
+	}
+	explicit operator unsigned long long() const {
+		return static_cast<unsigned long long>(size() ? front() : 0);
+	}
+	explicit operator char() const {
+		return static_cast<char>(size() ? front() : 0);
+	}
+	explicit operator short() const {
+		return static_cast<short>(size() ? front() : 0);
+	}
+	explicit operator int() const {
+		return static_cast<int>(size() ? front() : 0);
+	}
+	explicit operator long() const {
+		return static_cast<long>(size() ? front() : 0);
+	}
+	explicit operator long long() const {
+		return static_cast<long long>(size() ? front() : 0);
+	}
+
+	// Bitwise Operators
+	uinteger_t operator&(const uinteger_t& rhs) const {
+		return bitwise_and(*this, rhs);
+	}
+
+	uinteger_t& operator&=(const uinteger_t& rhs) {
+		return bitwise_and(*this, rhs);
+	}
+
+	uinteger_t operator|(const uinteger_t& rhs) const {
+		return bitwise_or(*this, rhs);
+	}
+
+	uinteger_t& operator|=(const uinteger_t& rhs) {
+		return bitwise_or(*this, rhs);
+	}
+
+	uinteger_t operator^(const uinteger_t& rhs) const {
+		return bitwise_xor(*this, rhs);
+	}
+
+	uinteger_t& operator^=(const uinteger_t& rhs) {
+		return bitwise_xor(*this, rhs);
+	}
+
+	uinteger_t operator~() const {
+		return bitwise_inv(*this);
+	}
+
+	uinteger_t inv() {
+		return bitwise_inv(*this);
+	}
+
+	// Bit Shift Operators
+	uinteger_t operator<<(const uinteger_t& rhs) const {
+		return bitwise_lshift(*this, rhs);
+	}
+
+	uinteger_t& operator<<=(const uinteger_t& rhs) {
+		return bitwise_lshift(*this, rhs);
+	}
+
+	uinteger_t operator>>(const uinteger_t& rhs) const {
+		return bitwise_rshift(*this, rhs);
+	}
+
+	uinteger_t& operator>>=(const uinteger_t& rhs) {
+		return bitwise_rshift(*this, rhs);
+	}
+
+	// Logical Operators
+	bool operator!() const {
+		return !static_cast<bool>(*this);
+	}
+
+	bool operator&&(const uinteger_t& rhs) const {
+		return static_cast<bool>(*this) && rhs;
+	}
+
+	bool operator||(const uinteger_t& rhs) const {
+		return static_cast<bool>(*this) || rhs;
+	}
+
+	// Comparison Operators
+	bool operator==(const uinteger_t& rhs) const {
+		return compare(*this, rhs) == 0;
+	}
+
+	bool operator!=(const uinteger_t& rhs) const {
+		return compare(*this, rhs) != 0;
+	}
+
+	bool operator>(const uinteger_t& rhs) const {
+		return compare(*this, rhs) > 0;
+	}
+
+	bool operator<(const uinteger_t& rhs) const {
+		return compare(*this, rhs) < 0;
+	}
+
+	bool operator>=(const uinteger_t& rhs) const {
+		return compare(*this, rhs) >= 0;
+	}
+
+	bool operator<=(const uinteger_t& rhs) const {
+		return compare(*this, rhs) <= 0;
+	}
+
+	// Arithmetic Operators
+	uinteger_t operator+(const uinteger_t& rhs) const {
+		return add(*this, rhs);
+	}
+
+	uinteger_t& operator+=(const uinteger_t& rhs) {
+		return add(*this, rhs);
+	}
+
+	uinteger_t operator-(const uinteger_t& rhs) const {
+		return sub(*this, rhs);
+	}
+
+	uinteger_t& operator-=(const uinteger_t& rhs) {
+		return sub(*this, rhs);
+	}
+
+	uinteger_t operator*(const uinteger_t& rhs) const {
+		return mult(*this, rhs);
+	}
+
+	uinteger_t& operator*=(const uinteger_t& rhs) {
+		return mult(*this, rhs);
+	}
+
+	std::pair<uinteger_t, uinteger_t> divmod(const uinteger_t& rhs) const {
+		return divmod(*this, rhs);
+	}
+
+	uinteger_t operator/(const uinteger_t& rhs) const {
+		return divmod(*this, rhs).first;
+	}
+
+	uinteger_t& operator/=(const uinteger_t& rhs) {
+		uinteger_t quotient;
+		uinteger_t remainder;
+		divmod(quotient, remainder, *this, rhs);
+		*this = std::move(quotient);
+		return *this;
+	}
+
+	uinteger_t operator%(const uinteger_t& rhs) const {
+		return divmod(*this, rhs).second;
+	}
+
+	uinteger_t& operator%=(const uinteger_t& rhs) {
+		uinteger_t quotient;
+		uinteger_t remainder;
+		divmod(quotient, remainder, *this, rhs);
+		*this = std::move(remainder);
+		return *this;
+	}
+
+	// Increment Operator
+	uinteger_t& operator++() {
+		return *this += uint_1();
+	}
+	uinteger_t operator++(int) {
+		uinteger_t temp(*this);
+		++*this;
+		return temp;
+	}
+
+	// Decrement Operator
+	uinteger_t& operator--() {
+		return *this -= uint_1();
+	}
+	uinteger_t operator--(int) {
+		uinteger_t temp(*this);
+		--*this;
+		return temp;
+	}
+
+	// Nothing done since promotion doesn't work here
+	uinteger_t operator+() const {
+		return *this;
+	}
+
+	// two's complement
+	uinteger_t operator-() const {
+		return uint_0() - *this;
+	}
+
+	// Get private value at index
+	const digit& value(std::size_t idx) const {
+		static const digit zero = 0;
+		return idx < size() ? *(begin() + idx) : zero;
+	}
+
+	// Get value of bit N
+	bool operator[](std::size_t n) const {
+		auto nd = n / digit_bits;
+		auto nm = n % digit_bits;
+		return nd < size() ? (*(begin() + nd) >> nm) & 1 : 0;
+	}
+
+	// Get bitsize of value
+	std::size_t bits() const {
+		auto sz = size();
+		if (sz) {
+			return _bits(back()) + (sz - 1) * digit_bits;
+		}
+		return 0;
+	}
+
+	// Get string representation of value
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result str(int alphabet_base = 10) const {
+		auto num_sz = size();
+		if (alphabet_base >= 2 && alphabet_base <= 36) {
+			Result result;
+			if (num_sz) {
+				auto alphabet_base_bits = base_bits(alphabet_base);
+				result.reserve(num_sz * base_size(alphabet_base));
+				if (alphabet_base_bits) {
+					digit alphabet_base_mask = alphabet_base - 1;
+					std::size_t shift = 0;
+					auto ptr = reinterpret_cast<const half_digit*>(data());
+					digit v = *ptr++;
+					v <<= half_digit_bits;
+					for (auto i = num_sz * 2 - 1; i; --i) {
+						v >>= half_digit_bits;
+						v |= (static_cast<digit>(*ptr++) << half_digit_bits);
+						do {
+							auto d = static_cast<int>((v >> shift) & alphabet_base_mask);
+							result.push_back(chr(d));
+							shift += alphabet_base_bits;
+						} while (shift <= half_digit_bits);
+						shift -= half_digit_bits;
+					}
+					v >>= (shift + half_digit_bits);
+					while (v) {
+						auto d = static_cast<int>(v & alphabet_base_mask);
+						result.push_back(chr(d));
+						v >>= alphabet_base_bits;
+					}
+					auto s = chr(0);
+					auto rit_f = std::find_if(result.rbegin(), result.rend(), [s](const char& c) { return c != s; });
+					result.resize(result.rend() - rit_f); // shrink
+				} else {
+					uinteger_t uint_base = alphabet_base;
+					uinteger_t quotient = *this;
+					do {
+						auto r = quotient.divmod(uint_base);
+						auto d = static_cast<int>(r.second);
+						result.push_back(chr(d));
+						quotient = std::move(r.first);
+					} while (quotient);
+				}
+				std::reverse(result.begin(), result.end());
+			} else {
+				result.push_back(chr(0));
+			}
+			return result;
+		} else if (alphabet_base == 256) {
+			if (num_sz) {
+				auto ptr = reinterpret_cast<const char*>(data());
+				Result result(ptr, ptr + num_sz * digit_octets);
+				auto rit_f = std::find_if(result.rbegin(), result.rend(), [](const char& c) { return c; });
+				result.resize(result.rend() - rit_f); // shrink
+				std::reverse(result.begin(), result.end());
+				return result;
+			} else {
+				Result result;
+				result.push_back('\x00');
+				return result;
+			}
+		} else {
+			throw std::invalid_argument("Base must be in the range [2, 36]");
+		}
+	}
+
+	static uinteger_t strtouint(const void* encoded, std::size_t encoded_size, int alphabet_base) {
+		const char* data = (const char *)encoded;
+		uinteger_t result;
+
+		if (alphabet_base >= 2 && alphabet_base <= 36) {
+			uinteger_t alphabet_base_bits = base_bits(alphabet_base);
+			uinteger_t uint_base = alphabet_base;
+			if (alphabet_base_bits) {
+				for (; encoded_size; --encoded_size, ++data) {
+					auto d = ord(static_cast<int>(*data));
+					if (d < 0) {
+						throw std::invalid_argument("Error: Not a digit in base " + std::to_string(alphabet_base) + ": '" + std::string(1, *data) + "' at " + std::to_string(encoded_size));
+					}
+					result = (result << alphabet_base_bits) | d;
+				}
+			} else {
+				for (; encoded_size; --encoded_size, ++data) {
+					auto d = ord(static_cast<int>(*data));
+					if (d < 0) {
+						throw std::invalid_argument("Error: Not a digit in base " + std::to_string(alphabet_base) + ": '" + std::string(1, *data) + "' at " + std::to_string(encoded_size));
+					}
+					result = (result * uint_base) + d;
+				}
+			}
+		} else if (encoded_size && alphabet_base == 256) {
+			auto value_size = encoded_size / digit_octets;
+			auto value_padding = encoded_size % digit_octets;
+			if (value_padding) {
+				value_padding = digit_octets - value_padding;
+				++value_size;
+			}
+			result.resize(value_size); // grow (no initialization)
+			*result.begin() = 0; // initialize value
+			auto ptr = reinterpret_cast<char*>(result.data());
+			std::copy(data, data + encoded_size, ptr + value_padding);
+			std::reverse(ptr, ptr + value_size * digit_octets);
+		} else {
+			throw std::invalid_argument("Error: Cannot convert from base " + std::to_string(alphabet_base));
+		}
+
+		return result;
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result bin() const {
+		return str<Result>(2);
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result oct() const {
+		return str<Result>(8);
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result hex() const {
+		return str<Result>(16);
+	}
+
+	template <typename Result = std::string, typename = std::enable_if_t<uinteger_t::is_result<Result>::value>>
+	Result raw() const {
+		return str<Result>(256);
+	}
+};
+
+namespace std {  // This is probably not a good idea
+	// Make it work with std::string()
+	inline std::string to_string(uinteger_t& num) {
+		return num.str();
+	}
+	inline const std::string to_string(const uinteger_t& num) {
+		return num.str();
+	}
+}
+
+// lhs type T as first arguemnt
+// If the output is not a bool, casts to type T
+
+// Bitwise Operators
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator&(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) & rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator&=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(rhs & lhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator|(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) | rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator|=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(rhs | lhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator^(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) ^ rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator^=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(rhs ^ lhs);
+}
+
+// Bitshift operators
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+inline uinteger_t operator<<(T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) << rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator<<=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(lhs << rhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+inline uinteger_t operator>>(T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) >> rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator>>=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(lhs >> rhs);
+}
+
+// Comparison Operators
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+bool operator==(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) == rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+bool operator!=(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) != rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+bool operator>(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) > rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+bool operator<(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) < rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+bool operator>=(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) >= rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+bool operator<=(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) <= rhs;
+}
+
+// Arithmetic Operators
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator+(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) + rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator+=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(rhs + lhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator-(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) - rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator-=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(lhs - rhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator*(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) * rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator*=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(rhs * lhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator/(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) / rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator/=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(lhs / rhs);
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+uinteger_t operator%(const T& lhs, const uinteger_t& rhs) {
+	return uinteger_t(lhs) % rhs;
+}
+
+template <typename T, typename = typename std::enable_if_t<std::is_integral<T>::value and not std::is_same<T, std::decay_t<uinteger_t>>::value>>
+T& operator%=(T& lhs, const uinteger_t& rhs) {
+	return lhs = static_cast<T>(lhs % rhs);
+}
+
+// IO Operator
+inline std::ostream& operator<<(std::ostream& stream, const uinteger_t& rhs) {
+	if (stream.flags() & stream.oct) {
+		stream << rhs.str(8);
+	} else if (stream.flags() & stream.dec) {
+		stream << rhs.str(10);
+	} else if (stream.flags() & stream.hex) {
+		stream << rhs.str(16);
+	}
+	return stream;
+}
+
+#endif
diff --git a/docs/en/development/contrib.md b/docs/en/development/contrib.md
index 3936b613bcb5..b589a6d64fd0 100644
--- a/docs/en/development/contrib.md
+++ b/docs/en/development/contrib.md
@@ -18,6 +18,7 @@ The list of third-party libraries:
 | aws-c-common | [Apache](https://github.com/ClickHouse-Extras/aws-c-common/blob/736a82d1697c108b04a277e66438a7f4e19b6857/LICENSE) |
 | aws-c-event-stream | [Apache](https://github.com/ClickHouse-Extras/aws-c-event-stream/blob/3bc33662f9ccff4f4cbcf9509cc78c26e022fde0/LICENSE) |
 | aws-checksums | [Apache](https://github.com/ClickHouse-Extras/aws-checksums/blob/519d6d9093819b6cf89ffff589a27ef8f83d0f65/LICENSE) |
+| base58 | [MIT](https://github.com/ClickHouse/base-x/blob/3e58874643c087f57e82b0ff03825c933fab945a/LICENSE) |
 | base64 | [BSD 2-clause](https://github.com/ClickHouse-Extras/Turbo-Base64/blob/af9b331f2b4f30b41c70f3a571ff904a8251c1d3/LICENSE) |
 | boost | [Boost](https://github.com/ClickHouse-Extras/boost/blob/9cf09dbfd55a5c6202dedbdf40781a51b02c2675/LICENSE_1_0.txt) |
 | boringssl | [BSD](https://github.com/ClickHouse-Extras/boringssl/blob/a6a2e2ab3e44d97ce98e51c558e989f211de7eb3/LICENSE) |
diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md
index cac546d9a705..38d247457cf7 100644
--- a/docs/en/sql-reference/functions/string-functions.md
+++ b/docs/en/sql-reference/functions/string-functions.md
@@ -494,6 +494,48 @@ If the âsâ string is non-empty and does not contain the âcâ character at
 
 Returns the string âsâ that was converted from the encoding in âfromâ to the encoding in âtoâ.
 
+## Base58Encode(plaintext[, alphabet_name]), Base58Decode(encoded_text[, alphabet_name])
+
+Accepts a String and encodes/decodes it using [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) encoding scheme using specified alphabet.
+
+**Syntax**
+
+```sql
+base58Encode(decoded[, alphabet_name])
+base58Decode(encoded[, alphabet_name])
+```
+
+**Arguments**
+
+- `decoded` â [String](../../sql-reference/data-types/string.md) column or constant.
+- `encoded` â [String](../../sql-reference/data-types/string.md) column or constant. If the string is not a valid base58-encoded value, an exception is thrown.
+- `alphabet_name` â String constant. Specifies alphabet used for encoding. Possible values: `gmp`, `bitcoin`, `ripple`, `flickr`. Default: `bitcoin`.
+
+**Returned value**
+
+-   A string containing encoded/decoded value of 1st argument.
+
+Type: [String](../../sql-reference/data-types/string.md).
+
+**Example**
+
+Query:
+
+``` sql
+SELECT base58Encode('encode', 'flickr');
+SELECT base58Decode('izCFiDUY', 'ripple');
+```
+
+Result:
+```text
+ââbase58Encode('encode', 'flickr')ââ
+â SvyTHb1D                         â
+ââââââââââââââââââââââââââââââââââââ
+ââbase58Decode('izCFiDUY', 'ripple')ââ
+â decode                             â
+ââââââââââââââââââââââââââââââââââââââ
+```
+
 ## base64Encode(s)
 
 Encodes âsâ string into base64
diff --git a/docs/ru/development/contrib.md b/docs/ru/development/contrib.md
index 1b99ec975534..0f4d22e90ceb 100644
--- a/docs/ru/development/contrib.md
+++ b/docs/ru/development/contrib.md
@@ -18,6 +18,7 @@ sidebar_label: "ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ÑÐµ ÑÑÐ¾ÑÐ¾Ð½Ð½Ð¸Ðµ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸
 | aws-c-common | [Apache](https://github.com/ClickHouse-Extras/aws-c-common/blob/736a82d1697c108b04a277e66438a7f4e19b6857/LICENSE) |
 | aws-c-event-stream | [Apache](https://github.com/ClickHouse-Extras/aws-c-event-stream/blob/3bc33662f9ccff4f4cbcf9509cc78c26e022fde0/LICENSE) |
 | aws-checksums | [Apache](https://github.com/ClickHouse-Extras/aws-checksums/blob/519d6d9093819b6cf89ffff589a27ef8f83d0f65/LICENSE) |
+| base58 | [MIT](https://github.com/ClickHouse/base-x/blob/3e58874643c087f57e82b0ff03825c933fab945a/LICENSE) |
 | base64 | [BSD 2-clause](https://github.com/ClickHouse-Extras/Turbo-Base64/blob/af9b331f2b4f30b41c70f3a571ff904a8251c1d3/LICENSE) |
 | boost | [Boost](https://github.com/ClickHouse-Extras/boost/blob/9cf09dbfd55a5c6202dedbdf40781a51b02c2675/LICENSE_1_0.txt) |
 | boringssl | [BSD](https://github.com/ClickHouse-Extras/boringssl/blob/a6a2e2ab3e44d97ce98e51c558e989f211de7eb3/LICENSE) |
diff --git a/docs/ru/sql-reference/functions/string-functions.md b/docs/ru/sql-reference/functions/string-functions.md
index 6cd4cea403ea..1acf5ec58b2d 100644
--- a/docs/ru/sql-reference/functions/string-functions.md
+++ b/docs/ru/sql-reference/functions/string-functions.md
@@ -490,6 +490,48 @@ SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY (key1, key2);
 
 ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ ÑÐºÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ Ð¸Ð· ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²ÐºÐ¸ from Ð² ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²ÐºÑ to ÑÑÑÐ¾ÐºÑ s.
 
+## Base58Encode(plaintext[, alphabet_name]), Base58Decode(plaintext[, alphabet_name]) {#base58}
+
+ÐÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ Ð½Ð° Ð²ÑÐ¾Ð´ ÑÑÑÐ¾ÐºÑ Ð¸Ð»Ð¸ ÐºÐ¾Ð»Ð¾Ð½ÐºÑ ÑÑÑÐ¾Ðº Ð¸ ÐºÐ¾Ð´Ð¸ÑÑÐµÑ/ÑÐ°ÑÐºÐ¾Ð´Ð¸ÑÑÐµÑ Ð¸Ñ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ ÑÑÐµÐ¼Ñ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð°Ð»ÑÐ°Ð²Ð¸ÑÐ°.
+
+**Ð¡Ð¸Ð½ÑÐ°ÐºÑÐ¸Ñ**
+
+```sql
+base58Encode(decoded[, alphabet_name])
+base58Decode(encoded[, alphabet_name])
+```
+
+**ÐÑÐ³ÑÐ¼ÐµÐ½ÑÑ**
+
+- `decoded` â ÐÐ¾Ð»Ð¾Ð½ÐºÐ° Ð¸Ð»Ð¸ ÑÑÑÐ¾ÐºÐ° ÑÐ¸Ð¿Ð° [String](../../sql-reference/data-types/string.md).
+- `encoded` â ÐÐ¾Ð»Ð¾Ð½ÐºÐ° Ð¸Ð»Ð¸ ÑÑÑÐ¾ÐºÐ° ÑÐ¸Ð¿Ð° [String](../../sql-reference/data-types/string.md). ÐÑÐ»Ð¸ Ð²ÑÐ¾Ð´Ð½Ð°Ñ ÑÑÑÐ¾ÐºÐ° Ð½Ðµ ÑÐ²Ð»ÑÐµÑÑÑ ÐºÐ¾ÑÑÐµÐºÑÐ½ÑÐ¼ ÐºÐ¾Ð´Ð¾Ð¼ Ð´Ð»Ñ ÐºÐ°ÐºÐ¾Ð¹-Ð»Ð¸Ð±Ð¾ Ð´ÑÑÐ³Ð¾Ð¹ ÑÑÑÐ¾ÐºÐ¸, Ð²Ð¾Ð·Ð½Ð¸ÐºÐ½ÐµÑ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ `1001`.
+- `alphabet_name` â Ð¡ÑÑÐ¾ÐºÐ¾Ð²Ð°Ñ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÐ°. Ð£ÐºÐ°Ð·ÑÐ²Ð°ÐµÑ Ð°Ð»ÑÐ°Ð²Ð¸Ñ, Ð´Ð»Ñ ÐºÐ¾ÑÐ¾ÑÐ¾Ð³Ð¾ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÐºÐ¾Ð´. ÐÐ¾Ð¶ÐµÑ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ÑÐ»ÐµÐ´ÑÑÑÐ¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹: `gmp`, `bitcoin`, `ripple`, `flickr`. ÐÐ¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ: `bitcoin`.
+
+**ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ**
+
+-   Ð¡ÑÑÐ¾ÐºÐ°, ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÐ°Ñ ÑÐ°ÑÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹/Ð·Ð°ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ Ð¿ÐµÑÐ²ÑÐ¹ Ð°ÑÐ³ÑÐ¼ÐµÐ½Ñ.
+
+Ð¢Ð¸Ð¿: [String](../../sql-reference/data-types/string.md).
+
+**ÐÑÐ¸Ð¼ÐµÑ:**
+
+ÐÐ°Ð¿ÑÐ¾Ñ:
+
+``` sql
+SELECT base58Encode('encode', 'flickr');
+SELECT base58Decode('izCFiDUY', 'ripple');
+```
+
+Ð ÐµÐ·ÑÐ»ÑÑÐ°Ñ:
+```text
+ââbase58Encode('encode', 'flickr')ââ
+â SvyTHb1D                         â
+ââââââââââââââââââââââââââââââââââââ
+ââbase58Decode('izCFiDUY', 'ripple')ââ
+â decode                             â
+ââââââââââââââââââââââââââââââââââââââ
+```
+
 ## base64Encode(s) {#base64encode}
 
 ÐÑÐ¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÑÐ¾ÐºÐ¸ s Ð² base64-Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ.
diff --git a/src/Functions/CMakeLists.txt b/src/Functions/CMakeLists.txt
index 60386908f014..32f7952961c3 100644
--- a/src/Functions/CMakeLists.txt
+++ b/src/Functions/CMakeLists.txt
@@ -72,6 +72,10 @@ if (TARGET ch_contrib::llvm)
     target_link_libraries(clickhouse_functions PRIVATE ch_contrib::llvm)
 endif ()
 
+if (TARGET ch_contrib::base-x)
+    target_link_libraries(clickhouse_functions PRIVATE ch_contrib::base-x)
+endif()
+
 if (TARGET ch_contrib::base64)
     target_link_libraries(clickhouse_functions PRIVATE ch_contrib::base64)
 endif()
diff --git a/src/Functions/FunctionBase58Conversion.h b/src/Functions/FunctionBase58Conversion.h
new file mode 100644
index 000000000000..6979ce849f46
--- /dev/null
+++ b/src/Functions/FunctionBase58Conversion.h
@@ -0,0 +1,256 @@
+#pragma once
+#include "config_functions.h"
+
+#if USE_BASEX
+#    include <Columns/ColumnConst.h>
+#    include <Common/MemorySanitizer.h>
+#    include <Columns/ColumnString.h>
+#    include <DataTypes/DataTypeString.h>
+#    include <Functions/FunctionFactory.h>
+#    include <Functions/FunctionHelpers.h>
+#    include <IO/WriteHelpers.h>
+#    include <base_x.hh>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_COLUMN;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int BAD_ARGUMENTS;
+}
+
+struct Base58Encode
+{
+    static constexpr auto name = "base58Encode";
+
+    static void process(const ColumnString & input, ColumnString::MutablePtr & dst_column, const std::string & alphabet, size_t input_rows_count)
+    {
+        auto & dst_data = dst_column->getChars();
+        auto & dst_offsets = dst_column->getOffsets();
+
+        /// Wikipedia states Base58 has efficiency of 73%, and we take 1.5 scale to avoid reallocation in most cases
+        size_t current_allocated_size = ceil(1.5 * input.getChars().size());
+
+        dst_data.resize(current_allocated_size);
+        dst_offsets.resize(input_rows_count);
+
+        const ColumnString::Offsets & src_offsets = input.getOffsets();
+
+        const auto * source = input.getChars().raw_data();
+        auto * dst = dst_data.data();
+        auto * dst_pos = dst;
+
+        size_t src_offset_prev = 0;
+        size_t processed_size = 0;
+
+        const auto& encoder = (alphabet == "bitcoin") ? Base58::bitcoin() :
+                             ((alphabet == "flickr") ? Base58::flickr() :
+                             ((alphabet == "ripple") ? Base58::ripple() :
+                                                       Base58::base58())); //GMP
+
+        std::string encoded;
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            size_t srclen = src_offsets[row] - src_offset_prev - 1;
+            /// Why we didn't use char* here?
+            /// We don't know the size of the result string beforehand (it's not byte-to-byte encoding),
+            /// so we may need to do many resizes (the worst case -- we'll do it for each row)
+            /// This way we do exponential resizes and one final resize after whole operation is complete
+            encoded.clear();
+            if (srclen)
+                try
+                {
+                    encoder.encode(encoded, source, srclen);
+                }
+                catch (const std::invalid_argument& e)
+                {
+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);
+                }
+                catch (const std::domain_error& e)
+                {
+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);
+                }
+            size_t outlen = encoded.size();
+
+            if (processed_size + outlen >= current_allocated_size)
+            {
+                current_allocated_size += current_allocated_size;
+                dst_data.resize(current_allocated_size);
+                auto processed_offset = dst_pos - dst;
+                dst = dst_data.data();
+                dst_pos = dst;
+                dst_pos += processed_offset;
+            }
+            std::memcpy(dst_pos, encoded.c_str(), ++outlen);
+
+            source += srclen + 1;
+            dst_pos += outlen;
+
+            dst_offsets[row] = dst_pos - dst;
+            src_offset_prev = src_offsets[row];
+            processed_size += outlen;
+        }
+
+        dst_data.resize(dst_pos - dst);
+    }
+};
+
+struct Base58Decode
+{
+    static constexpr auto name = "base58Decode";
+
+    static void process(const ColumnString & input, ColumnString::MutablePtr & dst_column, const std::string & alphabet, size_t input_rows_count)
+    {
+        auto & dst_data = dst_column->getChars();
+        auto & dst_offsets = dst_column->getOffsets();
+
+        /// We allocate probably even more then needed to avoid many resizes
+        size_t current_allocated_size = input.getChars().size();
+
+        dst_data.resize(current_allocated_size);
+        dst_offsets.resize(input_rows_count);
+
+        const ColumnString::Offsets & src_offsets = input.getOffsets();
+
+        const auto * source = input.getChars().raw_data();
+        auto * dst = dst_data.data();
+        auto * dst_pos = dst;
+
+        size_t src_offset_prev = 0;
+        size_t processed_size = 0;
+
+        const auto& decoder = (alphabet == "bitcoin") ? Base58::bitcoin() :
+                             ((alphabet == "flickr") ? Base58::flickr() :
+                             ((alphabet == "ripple") ? Base58::ripple() :
+                                                       Base58::base58()));
+
+        std::string decoded;
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            size_t srclen = src_offsets[row] - src_offset_prev - 1;
+            /// Why we didn't use char* here?
+            /// We don't know the size of the result string beforehand (it's not byte-to-byte encoding),
+            /// so we may need to do many resizes (the worst case -- we'll do it for each row)
+            /// This way we do exponential resizes and one final resize after whole operation is complete
+            decoded.clear();
+            if (srclen)
+                try
+                {
+                    decoder.decode(decoded, source, srclen);
+                }
+                catch (const std::invalid_argument& e)
+                {
+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);
+                }
+                catch (const std::domain_error& e)
+                {
+                    throw Exception(e.what(), ErrorCodes::BAD_ARGUMENTS);
+                }
+            size_t outlen = decoded.size();
+
+            if (processed_size + outlen >= current_allocated_size)
+            {
+                current_allocated_size += current_allocated_size;
+                dst_data.resize(current_allocated_size);
+                auto processed_offset = dst_pos - dst;
+                dst = dst_data.data();
+                dst_pos = dst;
+                dst_pos += processed_offset;
+            }
+            std::memcpy(dst_pos, decoded.c_str(), ++outlen);
+
+            source += srclen + 1;
+            dst_pos += outlen;
+
+            dst_offsets[row] = dst_pos - dst;
+            src_offset_prev = src_offsets[row];
+            processed_size += outlen;
+        }
+
+        dst_data.resize(dst_pos - dst);
+    }
+};
+
+template <typename Func>
+class FunctionBase58Conversion : public IFunction
+{
+public:
+    static constexpr auto name = Func::name;
+
+    static FunctionPtr create(ContextPtr)
+    {
+        return std::make_shared<FunctionBase58Conversion>();
+    }
+
+    String getName() const override
+    {
+        return Func::name;
+    }
+
+    bool isVariadic() const override { return true; }
+
+    size_t getNumberOfArguments() const override { return 0; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        if (arguments.size() != 1 && arguments.size() != 2)
+            throw Exception(
+                "Wrong number of arguments for function " + getName() + ":  1 or 2 expected.",
+                ErrorCodes::BAD_ARGUMENTS);
+
+        if (!isString(arguments[0].type))
+            throw Exception(
+                "Illegal type " + arguments[0].type->getName() + " of 1st argument of function " + getName() + ". Must be String.",
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+        if (arguments.size() == 2 && !isString(arguments[1].type))
+            throw Exception(
+                "Illegal type " + arguments[1].type->getName() + " of 2nd argument of function " + getName() + ". Must be String.",
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+        return std::make_shared<DataTypeString>();
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        const ColumnPtr column_string = arguments[0].column;
+        const ColumnString * input = checkAndGetColumn<ColumnString>(column_string.get());
+        if (!input)
+            throw Exception(
+                "Illegal column " + arguments[0].column->getName() + " of first argument of function " + getName() + ", must be String",
+                ErrorCodes::ILLEGAL_COLUMN);
+
+        std::string alphabet = "bitcoin";
+
+        if (arguments.size() == 2)
+        {
+            const auto * alphabet_column = checkAndGetColumn<ColumnConst>(arguments[1].column.get());
+
+            if (!alphabet_column)
+                throw Exception("Second argument for function " + getName() + " must be constant String", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+            alphabet = alphabet_column->getValue<DB::String>();
+            if (alphabet != "bitcoin" && alphabet != "ripple" && alphabet != "flickr" && alphabet != "gmp")
+                throw Exception("Second argument for function " + getName() + " must be 'bitcoin', 'ripple', 'gmp' or 'flickr'", ErrorCodes::ILLEGAL_COLUMN);
+
+        }
+
+        auto dst_column = ColumnString::create();
+
+        Func::process(*input, dst_column, alphabet, input_rows_count);
+
+        return dst_column;
+    }
+};
+}
+
+#endif
diff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h
index a1d6b9666603..87a3309f7ef7 100644
--- a/src/Functions/FunctionBase64Conversion.h
+++ b/src/Functions/FunctionBase64Conversion.h
@@ -85,7 +85,7 @@ class FunctionBase64Conversion : public IFunction
     {
         if (!WhichDataType(arguments[0].type).isString())
             throw Exception(
-                "Illegal type " + arguments[0].type->getName() + " of 1 argument of function " + getName() + ". Must be String.",
+                "Illegal type " + arguments[0].type->getName() + " of 1st argument of function " + getName() + ". Must be String.",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         return std::make_shared<DataTypeString>();
@@ -98,7 +98,7 @@ class FunctionBase64Conversion : public IFunction
 
         if (!input)
             throw Exception(
-                "Illegal column " + arguments[0].column->getName() + " of first argument of function " + getName(),
+                "Illegal column " + arguments[0].column->getName() + " of first argument of function " + getName() + ", must be of type String",
                 ErrorCodes::ILLEGAL_COLUMN);
 
         auto dst_column = ColumnString::create();
diff --git a/src/Functions/FunctionsBase58.cpp b/src/Functions/FunctionsBase58.cpp
new file mode 100644
index 000000000000..dc325ff8cfcd
--- /dev/null
+++ b/src/Functions/FunctionsBase58.cpp
@@ -0,0 +1,17 @@
+#include <Functions/FunctionBase58Conversion.h>
+#if USE_BASEX
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+void registerFunctionBase58Encode(FunctionFactory & factory)
+{
+    factory.registerFunction<FunctionBase58Conversion<Base58Encode>>();
+}
+
+void registerFunctionBase58Decode(FunctionFactory & factory)
+{
+    factory.registerFunction<FunctionBase58Conversion<Base58Decode>>();
+}
+}
+#endif
diff --git a/src/Functions/config_functions.h.in b/src/Functions/config_functions.h.in
index a693611f975e..0bfea78922b5 100644
--- a/src/Functions/config_functions.h.in
+++ b/src/Functions/config_functions.h.in
@@ -2,6 +2,7 @@
 
 // .h autogenerated by cmake!
 
+#cmakedefine01 USE_BASEX
 #cmakedefine01 USE_BASE64
 #cmakedefine01 USE_SIMDJSON
 #cmakedefine01 USE_RAPIDJSON
diff --git a/src/Functions/configure_config.cmake b/src/Functions/configure_config.cmake
index 7615a2eeeaf0..1038c09e53f1 100644
--- a/src/Functions/configure_config.cmake
+++ b/src/Functions/configure_config.cmake
@@ -1,6 +1,9 @@
 if (TARGET ch_contrib::fastops)
     set(USE_FASTOPS 1)
 endif()
+if (TARGET ch_contrib::base-x)
+    set(USE_BASEX 1)
+endif()
 if (TARGET ch_contrib::base64)
     set(USE_BASE64 1)
 endif()
diff --git a/src/Functions/registerFunctionsString.cpp b/src/Functions/registerFunctionsString.cpp
index f86043c69597..248b6391b4f3 100644
--- a/src/Functions/registerFunctionsString.cpp
+++ b/src/Functions/registerFunctionsString.cpp
@@ -49,6 +49,11 @@ void registerFunctionBase64Decode(FunctionFactory &);
 void registerFunctionTryBase64Decode(FunctionFactory &);
 #endif
 
+#if USE_BASEX
+void registerFunctionBase58Encode(FunctionFactory &);
+void registerFunctionBase58Decode(FunctionFactory &);
+#endif
+
 #if USE_NLP
 void registerFunctionStem(FunctionFactory &);
 void registerFunctionSynonyms(FunctionFactory &);
@@ -105,6 +110,11 @@ void registerFunctionsString(FunctionFactory & factory)
     registerFunctionTryBase64Decode(factory);
 #endif
 
+#if USE_BASEX
+    registerFunctionBase58Encode(factory);
+    registerFunctionBase58Decode(factory);
+#endif
+
 #if USE_NLP
     registerFunctionStem(factory);
     registerFunctionSynonyms(factory);
diff --git a/src/configure_config.cmake b/src/configure_config.cmake
index 519307ba28a8..45e45b505d41 100644
--- a/src/configure_config.cmake
+++ b/src/configure_config.cmake
@@ -55,6 +55,9 @@ endif()
 if (TARGET ch_contrib::base64)
     set(USE_BASE64 1)
 endif()
+if (TARGET ch_contrib::base-x)
+    set(USE_BASEX 1)
+endif()
 if (TARGET ch_contrib::yaml_cpp)
     set(USE_YAML_CPP 1)
 endif()
