diff --git a/src/Interpreters/ApplyWithSubqueryVisitor.cpp b/src/Interpreters/ApplyWithSubqueryVisitor.cpp
index 2e6048ee0574..38c9ef89adc4 100644
--- a/src/Interpreters/ApplyWithSubqueryVisitor.cpp
+++ b/src/Interpreters/ApplyWithSubqueryVisitor.cpp
@@ -11,6 +11,7 @@
 #include <Parsers/ASTSubquery.h>
 #include <Parsers/ASTTablesInSelectQuery.h>
 #include <Parsers/ASTWithElement.h>
+#include <Parsers/ASTLiteral.h>
 #include <Common/checkStackSize.h>
 
 
@@ -62,11 +63,16 @@ void ApplyWithSubqueryVisitor::visit(ASTSelectQuery & ast, const Data & data)
         for (auto & child : with->children)
         {
             visit(child, new_data ? *new_data : data);
-            if (auto * ast_with_elem = child->as<ASTWithElement>())
+            auto * ast_with_elem = child->as<ASTWithElement>();
+            auto * ast_literal = child->as<ASTLiteral>();
+            if (ast_with_elem || ast_literal)
             {
                 if (!new_data)
                     new_data = data;
-                new_data->subqueries[ast_with_elem->name] = ast_with_elem->subquery;
+                if (ast_with_elem)
+                    new_data->subqueries[ast_with_elem->name] = ast_with_elem->subquery;
+                else
+                    new_data->literals[ast_literal->alias] = child;
             }
         }
     }
@@ -120,15 +126,27 @@ void ApplyWithSubqueryVisitor::visit(ASTFunction & func, const Data & data)
             {
                 /// Clang-tidy is wrong on this line, because `func.arguments->children.at(1)` gets replaced before last use of `name`.
                 auto name = identifier->shortName();  // NOLINT
+
                 auto subquery_it = data.subqueries.find(name);
                 if (subquery_it != data.subqueries.end())
                 {
                     auto old_alias = func.arguments->children[1]->tryGetAlias();
                     func.arguments->children[1] = subquery_it->second->clone();
-                    func.arguments->children[1]->as<ASTSubquery &>().cte_name = name;
+                    func.arguments->children[1]->as<ASTSubquery>()->cte_name = name;
                     if (!old_alias.empty())
                         func.arguments->children[1]->setAlias(old_alias);
                 }
+                else
+                {
+                    auto literal_it = data.literals.find(name);
+                    if (literal_it != data.literals.end())
+                    {
+                        auto old_alias = func.arguments->children[1]->tryGetAlias();
+                        func.arguments->children[1] = literal_it->second->clone();
+                        if (!old_alias.empty())
+                            func.arguments->children[1]->setAlias(old_alias);
+                    }
+                }
             }
         }
     }
diff --git a/src/Interpreters/ApplyWithSubqueryVisitor.h b/src/Interpreters/ApplyWithSubqueryVisitor.h
index b1f7e9a7ff06..00537b0575ee 100644
--- a/src/Interpreters/ApplyWithSubqueryVisitor.h
+++ b/src/Interpreters/ApplyWithSubqueryVisitor.h
@@ -21,6 +21,7 @@ class ApplyWithSubqueryVisitor
     struct Data
     {
         std::map<String, ASTPtr> subqueries;
+        std::map<String, ASTPtr> literals;
     };
 
     void visit(ASTPtr & ast) { visit(ast, {}); }
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 9804f2d21f31..0c3b712384e9 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -1112,7 +1112,7 @@ void InterpreterCreateQuery::validateMaterializedViewColumnsAndEngine(const ASTC
                 /// We should treat SELECT as an initial query in order to properly analyze it.
                 auto context = Context::createCopy(getContext());
                 context->setQueryKindInitial();
-                input_block = InterpreterSelectQueryAnalyzer::getSampleBlock(create.select->clone(), context, SelectQueryOptions{}.createView());
+                input_block = InterpreterSelectQueryAnalyzer::getSampleBlock(create.select->clone(), context, SelectQueryOptions{}.analyze().createView());
             }
             else
             {
