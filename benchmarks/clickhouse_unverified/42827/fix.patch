diff --git a/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp b/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp
index 257bbda68eb7..5d48391d56d7 100644
--- a/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp
+++ b/src/Interpreters/ConvertFunctionOrLikeVisitor.cpp
@@ -15,7 +15,7 @@ void ConvertFunctionOrLikeData::visit(ASTFunction & function, ASTPtr &)
     if (function.name != "or")
         return;
 
-    std::unordered_map<ASTPtr, std::shared_ptr<ASTLiteral>> identifier_to_literals;
+    std::unordered_map<String, std::shared_ptr<ASTLiteral>> identifier_to_literals;
     for (auto & child : function.children)
     {
         if (auto * expr_list_fn = child->as<ASTExpressionList>())
@@ -51,10 +51,11 @@ void ConvertFunctionOrLikeData::visit(ASTFunction & function, ASTPtr &)
                         regexp = "(?i)" + regexp;
 
                     unique_elems.pop_back();
-                    auto it = identifier_to_literals.find(identifier);
+                    auto it = identifier_to_literals.find(identifier->getAliasOrColumnName());
+
                     if (it == identifier_to_literals.end())
                     {
-                        it = identifier_to_literals.insert({identifier, std::make_shared<ASTLiteral>(Field{Array{}})}).first;
+                        it = identifier_to_literals.insert({identifier->getAliasOrColumnName(), std::make_shared<ASTLiteral>(Field{Array{}})}).first;
                         auto match = makeASTFunction("multiMatchAny");
                         match->arguments->children.push_back(arguments[0]);
                         match->arguments->children.push_back(it->second);
diff --git a/src/Interpreters/QueryNormalizer.cpp b/src/Interpreters/QueryNormalizer.cpp
index 2a8b256c3d1b..6a128d37e5d7 100644
--- a/src/Interpreters/QueryNormalizer.cpp
+++ b/src/Interpreters/QueryNormalizer.cpp
@@ -113,12 +113,20 @@ void QueryNormalizer::visit(ASTIdentifier & node, ASTPtr & ast, Data & data)
             if (!is_cycle)
             {
                 /// In a construct like "a AS b", where a is an alias, you must set alias b to the result of substituting alias a.
+                /// Check size of the alias before cloning too large alias AST
+                alias_node->checkSize(data.settings.max_expanded_ast_elements);
                 ast = alias_node->clone();
                 ast->setAlias(node_alias);
             }
         }
         else
-            ast = alias_node;
+        {
+            /// Check size of the alias before cloning too large alias AST
+            alias_node->checkSize(data.settings.max_expanded_ast_elements);
+            auto alias_name = ast->getAliasOrColumnName();
+            ast = alias_node->clone();
+            ast->setAlias(alias_name);
+        }
     }
 }
 
