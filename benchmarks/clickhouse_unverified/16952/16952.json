{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16952,
  "instance_id": "ClickHouse__ClickHouse-16952",
  "issue_numbers": [
    "16655"
  ],
  "base_commit": "81e48856649a10f38f9cc19e844202d64a699323",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\nindex cb62035f5391..e2139ba882fc 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n@@ -4,6 +4,7 @@\n #include <AggregateFunctions/FactoryHelpers.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n #include \"registerAggregateFunctions.h\"\n \n \ndiff --git a/src/AggregateFunctions/AggregateFunctionQuantile.cpp b/src/AggregateFunctions/AggregateFunctionQuantile.cpp\nindex 21451fe33bed..1dcdb2883394 100644\n--- a/src/AggregateFunctions/AggregateFunctionQuantile.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionQuantile.cpp\n@@ -100,6 +100,7 @@ AggregateFunctionPtr createAggregateFunctionQuantile(const std::string & name, c\n         if (which.idx == TypeIndex::Decimal32) return std::make_shared<Function<Decimal32, false>>(argument_types, params);\n         if (which.idx == TypeIndex::Decimal64) return std::make_shared<Function<Decimal64, false>>(argument_types, params);\n         if (which.idx == TypeIndex::Decimal128) return std::make_shared<Function<Decimal128, false>>(argument_types, params);\n+        if (which.idx == TypeIndex::DateTime64) return std::make_shared<Function<DateTime64, false>>(argument_types, params);\n         //if (which.idx == TypeIndex::Decimal256) return std::make_shared<Function<Decimal256, false>>(argument_types, params);\n     }\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionSum.h b/src/AggregateFunctions/AggregateFunctionSum.h\nindex 20bee1815e6b..9c453a63fc85 100644\n--- a/src/AggregateFunctions/AggregateFunctionSum.h\n+++ b/src/AggregateFunctions/AggregateFunctionSum.h\n@@ -237,6 +237,8 @@ template <typename T, typename TResult, typename Data, AggregateFunctionSumType\n class AggregateFunctionSum final : public IAggregateFunctionDataHelper<Data, AggregateFunctionSum<T, TResult, Data, Type>>\n {\n public:\n+    static constexpr bool DateTime64Supported = false;\n+\n     using ResultDataType = std::conditional_t<IsDecimalNumber<T>, DataTypeDecimal<TResult>, DataTypeNumber<TResult>>;\n     using ColVecType = std::conditional_t<IsDecimalNumber<T>, ColumnDecimal<T>, ColumnVector<T>>;\n     using ColVecResult = std::conditional_t<IsDecimalNumber<T>, ColumnDecimal<TResult>, ColumnVector<TResult>>;\ndiff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h\nindex f688dabeab6a..fb727bf98b07 100644\n--- a/src/AggregateFunctions/Helpers.h\n+++ b/src/AggregateFunctions/Helpers.h\n@@ -135,6 +135,8 @@ static IAggregateFunction * createWithDecimalType(const IDataType & argument_typ\n     if (which.idx == TypeIndex::Decimal64) return new AggregateFunctionTemplate<Decimal64>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::Decimal128) return new AggregateFunctionTemplate<Decimal128>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::Decimal256) return new AggregateFunctionTemplate<Decimal256>(std::forward<TArgs>(args)...);\n+    if constexpr (AggregateFunctionTemplate<DateTime64>::DateTime64Supported)\n+        if (which.idx == TypeIndex::DateTime64) return new AggregateFunctionTemplate<DateTime64>(std::forward<TArgs>(args)...);\n     return nullptr;\n }\n \n@@ -146,6 +148,8 @@ static IAggregateFunction * createWithDecimalType(const IDataType & argument_typ\n     if (which.idx == TypeIndex::Decimal64) return new AggregateFunctionTemplate<Decimal64, Data>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::Decimal128) return new AggregateFunctionTemplate<Decimal128, Data>(std::forward<TArgs>(args)...);\n     if (which.idx == TypeIndex::Decimal256) return new AggregateFunctionTemplate<Decimal256, Data>(std::forward<TArgs>(args)...);\n+    if constexpr (AggregateFunctionTemplate<DateTime64, Data>::DateTime64Supported)\n+        if (which.idx == TypeIndex::DateTime64) return new AggregateFunctionTemplate<DateTime64, Data>(std::forward<TArgs>(args)...);\n     return nullptr;\n }\n \ndiff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex f46467514cf7..b591bd3acd76 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -310,6 +310,9 @@ class IAggregateFunctionDataHelper : public IAggregateFunctionHelper<Derived>\n     static const Data & data(ConstAggregateDataPtr place) { return *reinterpret_cast<const Data*>(place); }\n \n public:\n+    // Derived class can `override` this to flag that DateTime64 is not supported.\n+    static constexpr bool DateTime64Supported = true;\n+\n     IAggregateFunctionDataHelper(const DataTypes & argument_types_, const Array & parameters_)\n         : IAggregateFunctionHelper<Derived>(argument_types_, parameters_) {}\n \ndiff --git a/src/Columns/ColumnDecimal.cpp b/src/Columns/ColumnDecimal.cpp\nindex a70c1a6ba6d7..885df0446df1 100644\n--- a/src/Columns/ColumnDecimal.cpp\n+++ b/src/Columns/ColumnDecimal.cpp\n@@ -370,4 +370,5 @@ template class ColumnDecimal<Decimal32>;\n template class ColumnDecimal<Decimal64>;\n template class ColumnDecimal<Decimal128>;\n template class ColumnDecimal<Decimal256>;\n+template class ColumnDecimal<DateTime64>;\n }\ndiff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h\nindex 6da1fc00b7cb..d1537592e768 100644\n--- a/src/Core/DecimalComparison.h\n+++ b/src/Core/DecimalComparison.h\n@@ -114,15 +114,15 @@ class DecimalComparison\n     static std::enable_if_t<IsDecimalNumber<T> && IsDecimalNumber<U>, Shift>\n     getScales(const DataTypePtr & left_type, const DataTypePtr & right_type)\n     {\n-        const DataTypeDecimal<T> * decimal0 = checkDecimal<T>(*left_type);\n-        const DataTypeDecimal<U> * decimal1 = checkDecimal<U>(*right_type);\n+        const DataTypeDecimalBase<T> * decimal0 = checkDecimalBase<T>(*left_type);\n+        const DataTypeDecimalBase<U> * decimal1 = checkDecimalBase<U>(*right_type);\n \n         Shift shift;\n         if (decimal0 && decimal1)\n         {\n-            auto result_type = decimalResultType<false, false>(*decimal0, *decimal1);\n-            shift.a = static_cast<CompareInt>(result_type.scaleFactorFor(*decimal0, false).value);\n-            shift.b = static_cast<CompareInt>(result_type.scaleFactorFor(*decimal1, false).value);\n+            auto result_type = DecimalUtils::binaryOpResult<false, false>(*decimal0, *decimal1);\n+            shift.a = static_cast<CompareInt>(result_type.scaleFactorFor(decimal0->getTrait(), false).value);\n+            shift.b = static_cast<CompareInt>(result_type.scaleFactorFor(decimal1->getTrait(), false).value);\n         }\n         else if (decimal0)\n             shift.b = static_cast<CompareInt>(decimal0->getScaleMultiplier().value);\n@@ -137,7 +137,7 @@ class DecimalComparison\n     getScales(const DataTypePtr & left_type, const DataTypePtr &)\n     {\n         Shift shift;\n-        const DataTypeDecimal<T> * decimal0 = checkDecimal<T>(*left_type);\n+        const DataTypeDecimalBase<T> * decimal0 = checkDecimalBase<T>(*left_type);\n         if (decimal0)\n             shift.b = static_cast<CompareInt>(decimal0->getScaleMultiplier().value);\n         return shift;\n@@ -148,7 +148,7 @@ class DecimalComparison\n     getScales(const DataTypePtr &, const DataTypePtr & right_type)\n     {\n         Shift shift;\n-        const DataTypeDecimal<U> * decimal1 = checkDecimal<U>(*right_type);\n+        const DataTypeDecimalBase<U> * decimal1 = checkDecimalBase<U>(*right_type);\n         if (decimal1)\n             shift.a = static_cast<CompareInt>(decimal1->getScaleMultiplier().value);\n         return shift;\ndiff --git a/src/Core/DecimalFunctions.h b/src/Core/DecimalFunctions.h\nindex 52e8ebae322c..b82cfd88e981 100644\n--- a/src/Core/DecimalFunctions.h\n+++ b/src/Core/DecimalFunctions.h\n@@ -11,9 +11,13 @@\n namespace DB\n {\n \n+template <typename T>\n+class DataTypeNumber;\n+\n namespace ErrorCodes\n {\n     extern const int DECIMAL_OVERFLOW;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n }\n \n namespace DecimalUtils\n@@ -23,6 +27,7 @@ static constexpr size_t minPrecision() { return 1; }\n template <typename T> static constexpr size_t maxPrecision() { return 0; }\n template <> constexpr size_t maxPrecision<Decimal32>() { return 9; }\n template <> constexpr size_t maxPrecision<Decimal64>() { return 18; }\n+template <> constexpr size_t maxPrecision<DateTime64>() { return 18; }\n template <> constexpr size_t maxPrecision<Decimal128>() { return 38; }\n template <> constexpr size_t maxPrecision<Decimal256>() { return 76; }\n \n@@ -31,7 +36,7 @@ inline auto scaleMultiplier(UInt32 scale)\n {\n     if constexpr (std::is_same_v<T, Int32> || std::is_same_v<T, Decimal32>)\n         return common::exp10_i32(scale);\n-    else if constexpr (std::is_same_v<T, Int64> || std::is_same_v<T, Decimal64>)\n+    else if constexpr (std::is_same_v<T, Int64> || std::is_same_v<T, Decimal64> || std::is_same_v<T, DateTime64>)\n         return common::exp10_i64(scale);\n     else if constexpr (std::is_same_v<T, Int128> || std::is_same_v<T, Decimal128>)\n         return common::exp10_i128(scale);\n@@ -51,6 +56,30 @@ struct DecimalComponents\n     T fractional;\n };\n \n+/// Traits used for determining final Type/Precision/Scale for certain math operations on decimals.\n+template <typename T>\n+struct DataTypeDecimalTrait\n+{\n+    using FieldType = T;\n+    const UInt32 precision;\n+    const UInt32 scale;\n+\n+    DataTypeDecimalTrait(UInt32 precision_, UInt32 scale_)\n+        : precision(precision_),\n+          scale(scale_)\n+    {}\n+\n+    /// @returns multiplier for U to become T with correct scale\n+    template <typename U>\n+    T scaleFactorFor(const DataTypeDecimalTrait<U> & x, bool) const\n+    {\n+        if (scale < x.scale)\n+            throw Exception(\"Decimal result's scale is less than argument's one\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+        const UInt32 scale_delta = scale - x.scale; /// scale_delta >= 0\n+        return DecimalUtils::scaleMultiplier<typename T::NativeType>(scale_delta);\n+    }\n+};\n+\n /** Make a decimal value from whole and fractional components with given scale multiplier.\n   * where scale_multiplier = scaleMultiplier<T>(scale)\n   * this is to reduce number of calls to scaleMultiplier when scale is known.\n@@ -211,6 +240,35 @@ To convertTo(const DecimalType & decimal, size_t scale)\n     }\n }\n \n+template <bool is_multiply, bool is_division, typename T, typename U, template <typename> typename DecimalType>\n+inline auto binaryOpResult(const DecimalType<T> & tx, const DecimalType<U> & ty)\n+{\n+    UInt32 scale{};\n+    if constexpr (is_multiply)\n+        scale = tx.getScale() + ty.getScale();\n+    else if constexpr (is_division)\n+        scale = tx.getScale();\n+    else\n+        scale = (tx.getScale() > ty.getScale() ? tx.getScale() : ty.getScale());\n+\n+    if constexpr (sizeof(T) < sizeof(U))\n+        return DataTypeDecimalTrait<U>(DecimalUtils::maxPrecision<U>(), scale);\n+    else\n+        return DataTypeDecimalTrait<T>(DecimalUtils::maxPrecision<T>(), scale);\n+}\n+\n+template <bool, bool, typename T, typename U, template <typename> typename DecimalType>\n+inline const DataTypeDecimalTrait<T> binaryOpResult(const DecimalType<T> & tx, const DataTypeNumber<U> &)\n+{\n+    return DataTypeDecimalTrait<T>(DecimalUtils::maxPrecision<T>(), tx.getScale());\n+}\n+\n+template <bool, bool, typename T, typename U, template <typename> typename DecimalType>\n+inline const DataTypeDecimalTrait<U> binaryOpResult(const DataTypeNumber<T> &, const DecimalType<U> & ty)\n+{\n+    return DataTypeDecimalTrait<U>(DecimalUtils::maxPrecision<U>(), ty.getScale());\n+}\n+\n }\n \n }\ndiff --git a/src/Core/Field.cpp b/src/Core/Field.cpp\nindex 2309a36dc405..6fda3b39b3b9 100644\n--- a/src/Core/Field.cpp\n+++ b/src/Core/Field.cpp\n@@ -592,6 +592,10 @@ template <> bool decimalEqual(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32\n template <> bool decimalLess(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n template <> bool decimalLessOrEqual(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n \n+template <> bool decimalEqual(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }\n+template <> bool decimalLess(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }\n+template <> bool decimalLessOrEqual(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }\n+\n inline void writeText(const Null &, WriteBuffer & buf)\n {\n     writeText(std::string(\"Null\"), buf);\ndiff --git a/src/Core/Field.h b/src/Core/Field.h\nindex 66e4f0ac8dbb..433a1eaa5be8 100644\n--- a/src/Core/Field.h\n+++ b/src/Core/Field.h\n@@ -193,10 +193,12 @@ template <> struct NearestFieldTypeImpl<Decimal32> { using Type = DecimalField<D\n template <> struct NearestFieldTypeImpl<Decimal64> { using Type = DecimalField<Decimal64>; };\n template <> struct NearestFieldTypeImpl<Decimal128> { using Type = DecimalField<Decimal128>; };\n template <> struct NearestFieldTypeImpl<Decimal256> { using Type = DecimalField<Decimal256>; };\n+template <> struct NearestFieldTypeImpl<DateTime64> { using Type = DecimalField<DateTime64>; };\n template <> struct NearestFieldTypeImpl<DecimalField<Decimal32>> { using Type = DecimalField<Decimal32>; };\n template <> struct NearestFieldTypeImpl<DecimalField<Decimal64>> { using Type = DecimalField<Decimal64>; };\n template <> struct NearestFieldTypeImpl<DecimalField<Decimal128>> { using Type = DecimalField<Decimal128>; };\n template <> struct NearestFieldTypeImpl<DecimalField<Decimal256>> { using Type = DecimalField<Decimal256>; };\n+template <> struct NearestFieldTypeImpl<DecimalField<DateTime64>> { using Type = DecimalField<DateTime64>; };\n template <> struct NearestFieldTypeImpl<Float32> { using Type = Float64; };\n template <> struct NearestFieldTypeImpl<Float64> { using Type = Float64; };\n template <> struct NearestFieldTypeImpl<const char *> { using Type = String; };\n@@ -731,6 +733,7 @@ template <> struct Field::TypeToEnum<DecimalField<Decimal32>>{ static const Type\n template <> struct Field::TypeToEnum<DecimalField<Decimal64>>{ static const Types::Which value = Types::Decimal64; };\n template <> struct Field::TypeToEnum<DecimalField<Decimal128>>{ static const Types::Which value = Types::Decimal128; };\n template <> struct Field::TypeToEnum<DecimalField<Decimal256>>{ static const Types::Which value = Types::Decimal256; };\n+template <> struct Field::TypeToEnum<DecimalField<DateTime64>>{ static const Types::Which value = Types::Decimal64; };\n template <> struct Field::TypeToEnum<AggregateFunctionStateData>{ static const Types::Which value = Types::AggregateFunctionState; };\n template <> struct Field::TypeToEnum<UInt256> { static const Types::Which value = Types::UInt256; };\n template <> struct Field::TypeToEnum<Int256> { static const Types::Which value = Types::Int256; };\ndiff --git a/src/Core/Types.h b/src/Core/Types.h\nindex 28ca7146aaff..84c676b22045 100644\n--- a/src/Core/Types.h\n+++ b/src/Core/Types.h\n@@ -184,29 +184,44 @@ using Decimal64 = Decimal<Int64>;\n using Decimal128 = Decimal<Int128>;\n using Decimal256 = Decimal<Int256>;\n \n-using DateTime64 = Decimal64;\n+// Distinguishable type to allow function resultion/deduction based on value type,\n+// but also relatively easy to convert to/from Decimal64.\n+class DateTime64 : public Decimal64\n+{\n+public:\n+    using Base = Decimal64;\n+    using Base::Base;\n+\n+    DateTime64(const Base & v)\n+        : Base(v)\n+    {}\n+};\n \n template <> struct TypeName<Decimal32>   { static constexpr const char * get() { return \"Decimal32\";   } };\n template <> struct TypeName<Decimal64>   { static constexpr const char * get() { return \"Decimal64\";   } };\n template <> struct TypeName<Decimal128>  { static constexpr const char * get() { return \"Decimal128\";  } };\n template <> struct TypeName<Decimal256>  { static constexpr const char * get() { return \"Decimal256\";  } };\n+template <> struct TypeName<DateTime64>  { static constexpr const char * get() { return \"DateTime64\";  } };\n \n template <> struct TypeId<Decimal32>    { static constexpr const TypeIndex value = TypeIndex::Decimal32; };\n template <> struct TypeId<Decimal64>    { static constexpr const TypeIndex value = TypeIndex::Decimal64; };\n template <> struct TypeId<Decimal128>   { static constexpr const TypeIndex value = TypeIndex::Decimal128; };\n template <> struct TypeId<Decimal256>   { static constexpr const TypeIndex value = TypeIndex::Decimal256; };\n+template <> struct TypeId<DateTime64>   { static constexpr const TypeIndex value = TypeIndex::DateTime64; };\n \n template <typename T> constexpr bool IsDecimalNumber = false;\n template <> inline constexpr bool IsDecimalNumber<Decimal32> = true;\n template <> inline constexpr bool IsDecimalNumber<Decimal64> = true;\n template <> inline constexpr bool IsDecimalNumber<Decimal128> = true;\n template <> inline constexpr bool IsDecimalNumber<Decimal256> = true;\n+template <> inline constexpr bool IsDecimalNumber<DateTime64> = true;\n \n template <typename T> struct NativeType { using Type = T; };\n template <> struct NativeType<Decimal32> { using Type = Int32; };\n template <> struct NativeType<Decimal64> { using Type = Int64; };\n template <> struct NativeType<Decimal128> { using Type = Int128; };\n template <> struct NativeType<Decimal256> { using Type = Int256; };\n+template <> struct NativeType<DateTime64> { using Type = Int64; };\n \n template <typename T> constexpr bool OverBigInt = false;\n template <> inline constexpr bool OverBigInt<Int256> = true;\n@@ -275,6 +290,15 @@ namespace std\n         }\n     };\n \n+    template <>\n+    struct hash<DB::DateTime64>\n+    {\n+        size_t operator()(const DB::DateTime64 & x) const\n+        {\n+            return std::hash<std::decay_t<decltype(x)>::NativeType>()(x);\n+        }\n+    };\n+\n \n     template <>\n     struct hash<DB::Decimal256>\ndiff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h\nindex 62eec37c0cba..2ef049762f13 100644\n--- a/src/Core/callOnTypeIndex.h\n+++ b/src/Core/callOnTypeIndex.h\n@@ -141,7 +141,7 @@ inline bool callOnBasicTypes(TypeIndex type_num1, TypeIndex type_num2, F && f)\n         {\n             case TypeIndex::Date: return callOnBasicType<UInt16, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             case TypeIndex::DateTime: return callOnBasicType<UInt32, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n-            case TypeIndex::DateTime64: return callOnBasicType<Decimal64, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n+            case TypeIndex::DateTime64: return callOnBasicType<DateTime64, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             default:\n                 break;\n         }\ndiff --git a/src/DataTypes/DataTypeDateTime64.h b/src/DataTypes/DataTypeDateTime64.h\nindex 8cbeedfb48c4..003e83b7195e 100644\n--- a/src/DataTypes/DataTypeDateTime64.h\n+++ b/src/DataTypes/DataTypeDateTime64.h\n@@ -16,6 +16,7 @@ namespace DB\n class DataTypeDateTime64 final : public DataTypeDecimalBase<DateTime64>, public TimezoneMixin\n {\n public:\n+    using Base = DataTypeDecimalBase<DateTime64>;\n     static constexpr UInt8 default_scale = 3;\n \n     static constexpr auto family_name = \"DateTime64\";\ndiff --git a/src/DataTypes/DataTypeDecimalBase.cpp b/src/DataTypes/DataTypeDecimalBase.cpp\nindex 123f370cb91e..9fb445ab00db 100644\n--- a/src/DataTypes/DataTypeDecimalBase.cpp\n+++ b/src/DataTypes/DataTypeDecimalBase.cpp\n@@ -102,5 +102,6 @@ template class DataTypeDecimalBase<Decimal32>;\n template class DataTypeDecimalBase<Decimal64>;\n template class DataTypeDecimalBase<Decimal128>;\n template class DataTypeDecimalBase<Decimal256>;\n+template class DataTypeDecimalBase<DateTime64>;\n \n }\ndiff --git a/src/DataTypes/DataTypeDecimalBase.h b/src/DataTypes/DataTypeDecimalBase.h\nindex c5669ab735a1..d9128151403c 100644\n--- a/src/DataTypes/DataTypeDecimalBase.h\n+++ b/src/DataTypes/DataTypeDecimalBase.h\n@@ -150,39 +150,45 @@ class DataTypeDecimalBase : public DataTypeWithSimpleSerialization\n \n     static T getScaleMultiplier(UInt32 scale);\n \n+    inline DecimalUtils::DataTypeDecimalTrait<T> getTrait() const\n+    {\n+        return {precision, scale};\n+    }\n+\n protected:\n     const UInt32 precision;\n     const UInt32 scale;\n };\n \n \n+template <typename T>\n+inline const DataTypeDecimalBase<T> * checkDecimalBase(const IDataType & data_type)\n+{\n+    if (isColumnedAsDecimalT<T>(data_type))\n+        return static_cast<const DataTypeDecimalBase<T> *>(&data_type);\n+\n+    return nullptr;\n+}\n+\n template <bool is_multiply, bool is_division, typename T, typename U, template <typename> typename DecimalType>\n inline auto decimalResultType(const DecimalType<T> & tx, const DecimalType<U> & ty)\n {\n-    UInt32 scale{};\n-    if constexpr (is_multiply)\n-        scale = tx.getScale() + ty.getScale();\n-    else if constexpr (is_division)\n-        scale = tx.getScale();\n-    else\n-        scale = (tx.getScale() > ty.getScale() ? tx.getScale() : ty.getScale());\n-\n-    if constexpr (sizeof(T) < sizeof(U))\n-        return DecimalType<U>(DecimalUtils::maxPrecision<U>(), scale);\n-    else\n-        return DecimalType<T>(DecimalUtils::maxPrecision<T>(), scale);\n+    const auto result_trait = DecimalUtils::binaryOpResult<is_multiply, is_division>(tx, ty);\n+    return DecimalType<typename decltype(result_trait)::FieldType>(result_trait.precision, result_trait.scale);\n }\n \n-template <bool, bool, typename T, typename U, template <typename> typename DecimalType>\n-inline const DecimalType<T> decimalResultType(const DecimalType<T> & tx, const DataTypeNumber<U> &)\n+template <bool is_multiply, bool is_division, typename T, typename U, template <typename> typename DecimalType>\n+inline const DecimalType<T> decimalResultType(const DecimalType<T> & tx, const DataTypeNumber<U> & ty)\n {\n-    return DecimalType<T>(DecimalUtils::maxPrecision<T>(), tx.getScale());\n+    const auto result_trait = DecimalUtils::binaryOpResult<is_multiply, is_division>(tx, ty);\n+    return DecimalType<typename decltype(result_trait)::FieldType>(result_trait.precision, result_trait.scale);\n }\n \n-template <bool, bool, typename T, typename U, template <typename> typename DecimalType>\n-inline const DecimalType<U> decimalResultType(const DataTypeNumber<T> &, const DecimalType<U> & ty)\n+template <bool is_multiply, bool is_division, typename T, typename U, template <typename> typename DecimalType>\n+inline const DecimalType<U> decimalResultType(const DataTypeNumber<T> & tx, const DecimalType<U> & ty)\n {\n-    return DecimalType<U>(DecimalUtils::maxPrecision<U>(), ty.getScale());\n+    const auto result_trait = DecimalUtils::binaryOpResult<is_multiply, is_division>(tx, ty);\n+    return DecimalType<typename decltype(result_trait)::FieldType>(result_trait.precision, result_trait.scale);\n }\n \n template <template <typename> typename DecimalType>\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex c32aba721f48..4601378e8c26 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -606,6 +606,14 @@ inline bool isColumnedAsDecimal(const T & data_type)\n     return which.isDecimal() || which.isDateTime64();\n }\n \n+// Same as isColumnedAsDecimal but also checks value type of underlyig column.\n+template <typename T, typename DataType>\n+inline bool isColumnedAsDecimalT(const DataType & data_type)\n+{\n+    const WhichDataType which(data_type);\n+    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>::value;\n+}\n+\n template <typename T>\n inline bool isString(const T & data_type)\n {\ndiff --git a/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp b/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp\nindex b8f13f4ed189..02400a282144 100644\n--- a/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp\n+++ b/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp\n@@ -486,6 +486,8 @@ static void writeFieldsToColumn(\n             write_data_to_column(casted_decimal_128_column, Decimal128(), Decimal128());\n         else if (ColumnDecimal<Decimal256> * casted_decimal_256_column = typeid_cast<ColumnDecimal<Decimal256> *>(&column_to))\n             write_data_to_column(casted_decimal_256_column, Decimal256(), Decimal256());\n+        else if (ColumnDecimal<DateTime64> * casted_datetime_64_column = typeid_cast<ColumnDecimal<DateTime64> *>(&column_to))\n+            write_data_to_column(casted_datetime_64_column, DateTime64(), DateTime64());\n         else if (ColumnInt32 * casted_int32_column = typeid_cast<ColumnInt32 *>(&column_to))\n         {\n             for (size_t index = 0; index < rows_data.size(); ++index)\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex a4531ebc24db..c40278bfc0bb 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -370,7 +370,14 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n template <ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW, typename T>\n void readIntText(T & x, ReadBuffer & buf)\n {\n-    readIntTextImpl<T, void, check_overflow>(x, buf);\n+    if constexpr (IsDecimalNumber<T>)\n+    {\n+        readIntText<check_overflow>(x.value, buf);\n+    }\n+    else\n+    {\n+        readIntTextImpl<T, void, check_overflow>(x, buf);\n+    }\n }\n \n template <ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::CHECK_OVERFLOW, typename T>\n@@ -379,11 +386,6 @@ bool tryReadIntText(T & x, ReadBuffer & buf)\n     return readIntTextImpl<T, bool, check_overflow>(x, buf);\n }\n \n-template <ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW, typename T>\n-void readIntText(Decimal<T> & x, ReadBuffer & buf)\n-{\n-    readIntText<check_overflow>(x.value, buf);\n-}\n \n /** More efficient variant (about 1.5 times on real dataset).\n   * Differs in following:\ndiff --git a/src/Interpreters/RowRefs.cpp b/src/Interpreters/RowRefs.cpp\nindex 7617f589eb7b..03abae014537 100644\n--- a/src/Interpreters/RowRefs.cpp\n+++ b/src/Interpreters/RowRefs.cpp\n@@ -39,6 +39,7 @@ void callWithType(TypeIndex which, F && f)\n         case TypeIndex::Decimal32: return f(Decimal32());\n         case TypeIndex::Decimal64: return f(Decimal64());\n         case TypeIndex::Decimal128: return f(Decimal128());\n+        case TypeIndex::DateTime64: return f(DateTime64());\n         default:\n             break;\n     }\n@@ -153,6 +154,9 @@ std::optional<TypeIndex> AsofRowRefs::getTypeSize(const IColumn & asof_column, s\n         case TypeIndex::Decimal128:\n             size = sizeof(Decimal128);\n             return idx;\n+        case TypeIndex::DateTime64:\n+            size = sizeof(DateTime64);\n+            return idx;\n         default:\n             break;\n     }\ndiff --git a/src/Interpreters/RowRefs.h b/src/Interpreters/RowRefs.h\nindex fc035bf626e2..8e5141be199c 100644\n--- a/src/Interpreters/RowRefs.h\n+++ b/src/Interpreters/RowRefs.h\n@@ -228,7 +228,8 @@ class AsofRowRefs\n         Entry<Float64>::LookupPtr,\n         Entry<Decimal32>::LookupPtr,\n         Entry<Decimal64>::LookupPtr,\n-        Entry<Decimal128>::LookupPtr>;\n+        Entry<Decimal128>::LookupPtr,\n+        Entry<DateTime64>::LookupPtr>;\n \n     AsofRowRefs() {}\n     AsofRowRefs(TypeIndex t);\ndiff --git a/src/Storages/StorageGenerateRandom.cpp b/src/Storages/StorageGenerateRandom.cpp\nindex f1e822be2d18..fd10691ecc49 100644\n--- a/src/Storages/StorageGenerateRandom.cpp\n+++ b/src/Storages/StorageGenerateRandom.cpp\n@@ -319,7 +319,7 @@ ColumnPtr fillColumnWithRandomData(\n         case TypeIndex::DateTime64:\n         {\n             auto column = type->createColumn();\n-            auto & column_concrete = typeid_cast<ColumnDecimal<Decimal64> &>(*column);\n+            auto & column_concrete = typeid_cast<ColumnDecimal<DateTime64> &>(*column);\n             column_concrete.getData().resize(limit);\n \n             UInt64 range = (1ULL << 32) * intExp10(typeid_cast<const DataTypeDateTime64 &>(*type).getScale());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01553_datetime64_comparison.reference b/tests/queries/0_stateless/01553_datetime64_comparison.reference\nnew file mode 100644\nindex 000000000000..07f0dd10d60a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01553_datetime64_comparison.reference\n@@ -0,0 +1,3 @@\n+2015-05-18 07:40:29.123456\t2019-09-16 19:20:33.123\t0\t0\t0\t1\t1\t1\n+2019-09-16 19:20:33.123000\t2019-09-16 19:20:33.123\t0\t1\t1\t1\t0\t0\n+2019-09-16 19:20:33.123456\t2015-05-18 07:40:29.123\t1\t1\t0\t0\t0\t1\ndiff --git a/tests/queries/0_stateless/01553_datetime64_comparison.sql b/tests/queries/0_stateless/01553_datetime64_comparison.sql\nnew file mode 100644\nindex 000000000000..bc7f9a570324\n--- /dev/null\n+++ b/tests/queries/0_stateless/01553_datetime64_comparison.sql\n@@ -0,0 +1,21 @@\n+CREATE TABLE datetime64_cmp\n+(\n+\tdt6 DateTime64(6, 'UTC'),\n+\tdt3 DateTime64(3, 'UTC')\n+) ENGINE = Memory;\n+\n+INSERT INTO datetime64_cmp\n+VALUES ('2019-09-16 19:20:33.123000', '2019-09-16 19:20:33.123'), ('2019-09-16 19:20:33.123456', '2015-05-18 07:40:29.123'),  ('2015-05-18 07:40:29.123456', '2019-09-16 19:20:33.123');\n+\n+-- Compare equal and unequal values of different precicion/scale\n+SELECT\n+\tdt6, dt3,\n+\tdt6 >  dt3,\n+\tdt6 >= dt3,\n+\tdt6 =  dt3,\n+\tdt6 <= dt3,\n+\tdt6 <  dt3,\n+\tdt6 != dt3\n+FROM datetime64_cmp\n+ORDER BY\n+\tdt6, dt3;\n",
  "problem_statement": "incorrect comparisons between DateTime64(3) and DateTime64(6), `DateTime64(6)` field always bigger than `DateTime64(3)` even when it is not \n**Describe the bug**\r\n`DateTime64(6)` field always bigger than `DateTime64(3)`  \r\nit breaks behavior for\r\nqueries like `datetime64_3 BETWEEN datetime64_6_min AND datetime64_6_max`\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use\r\ndocker `yandex/clickhouse-server:latest`\r\n\r\n* Queries to run that lead to unexpected result\r\n```sql\r\nSELECT toDateTime64('2020-11-04 00:00:00.000000',6) < toDateTime64('2020-11-04 23:59:59.999',3);\r\n```\r\n**Expected behavior**\r\nreturn 1\r\n\r\n**Actual behavior**\r\nreturn 0\r\n\r\n**Additional context**\r\n```sql\r\nSELECT toDateTime64('2020-11-04 00:00:00.000000', 3) < toDateTime64('2020-11-04 23:59:59.999', 3)\r\n```\r\nreturn 1 as expected\r\n\r\ntypes converted right\r\n```sql\r\nSELECT toDateTime64('2020-11-04 00:00:00.000000',6) d64_6, toTypeName(d64_6);\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d64_6\u2500\u252c\u2500toTypeName(toDateTime64('2020-11-04 00:00:00.000000', 6))\u2500\u2510\r\n\u2502 2020-11-04 00:00:00.000000 \u2502 DateTime64(6)                                             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT toDateTime64('2020-11-04 00:00:00.000000',3) d64_3, toTypeName(d64_3);\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d64_3\u2500\u252c\u2500toTypeName(toDateTime64('2020-11-04 00:00:00.000000', 3))\u2500\u2510\r\n\u2502 2020-11-04 00:00:00.000 \u2502 DateTime64(3)                                             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "@Enmk @filimonov please look this issue",
  "created_at": "2020-11-12T20:36:39Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp",
    "src/AggregateFunctions/AggregateFunctionQuantile.cpp",
    "src/AggregateFunctions/AggregateFunctionSum.h",
    "src/AggregateFunctions/Helpers.h",
    "src/AggregateFunctions/IAggregateFunction.h",
    "src/Columns/ColumnDecimal.cpp",
    "src/Core/DecimalComparison.h",
    "src/Core/DecimalFunctions.h",
    "src/Core/Field.cpp",
    "src/Core/Field.h",
    "src/Core/Types.h",
    "src/Core/callOnTypeIndex.h",
    "src/DataTypes/DataTypeDateTime64.h",
    "src/DataTypes/DataTypeDecimalBase.cpp",
    "src/DataTypes/DataTypeDecimalBase.h",
    "src/DataTypes/IDataType.h",
    "src/Databases/MySQL/MaterializeMySQLSyncThread.cpp",
    "src/IO/ReadHelpers.h",
    "src/Interpreters/RowRefs.cpp",
    "src/Interpreters/RowRefs.h",
    "src/Storages/StorageGenerateRandom.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01553_datetime64_comparison.reference",
    "b/tests/queries/0_stateless/01553_datetime64_comparison.sql"
  ]
}