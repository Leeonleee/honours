{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11729,
  "instance_id": "ClickHouse__ClickHouse-11729",
  "issue_numbers": [
    "6539",
    "11517"
  ],
  "base_commit": "0260358253c5240f545b31d995250eaf039aecc9",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionAggThrow.cpp b/src/AggregateFunctions/AggregateFunctionAggThrow.cpp\nindex ea3eb9b1a20c..fada039e20a0 100644\n--- a/src/AggregateFunctions/AggregateFunctionAggThrow.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionAggThrow.cpp\n@@ -93,7 +93,7 @@ class AggregateFunctionThrow final : public IAggregateFunctionDataHelper<Aggrega\n         buf.read(c);\n     }\n \n-    void insertResultInto(AggregateDataPtr, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr, IColumn & to, Arena *) const override\n     {\n         to.insertDefault();\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionArgMinMax.h b/src/AggregateFunctions/AggregateFunctionArgMinMax.h\nindex 9a0c428d75bd..9470b1b8692d 100644\n--- a/src/AggregateFunctions/AggregateFunctionArgMinMax.h\n+++ b/src/AggregateFunctions/AggregateFunctionArgMinMax.h\n@@ -85,7 +85,7 @@ class AggregateFunctionArgMinMax final : public IAggregateFunctionDataHelper<Dat\n         return Data::allocatesMemoryInArena();\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         this->data(place).result.insertResultInto(to);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionArray.h b/src/AggregateFunctions/AggregateFunctionArray.h\nindex 4fe5e459ae19..24b070107075 100644\n--- a/src/AggregateFunctions/AggregateFunctionArray.h\n+++ b/src/AggregateFunctions/AggregateFunctionArray.h\n@@ -119,9 +119,9 @@ class AggregateFunctionArray final : public IAggregateFunctionHelper<AggregateFu\n         nested_func->deserialize(place, buf, arena);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const override\n     {\n-        nested_func->insertResultInto(place, to);\n+        nested_func->insertResultInto(place, to, arena);\n     }\n \n     bool allocatesMemoryInArena() const override\ndiff --git a/src/AggregateFunctions/AggregateFunctionAvg.h b/src/AggregateFunctions/AggregateFunctionAvg.h\nindex d9ef8647b821..1f3426160cb2 100644\n--- a/src/AggregateFunctions/AggregateFunctionAvg.h\n+++ b/src/AggregateFunctions/AggregateFunctionAvg.h\n@@ -80,7 +80,7 @@ class AggregateFunctionAvgBase : public IAggregateFunctionDataHelper<Data, Deriv\n         readBinary(this->data(place).denominator, buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & column = static_cast<ColVecResult &>(to);\n         column.getData().push_back(this->data(place).template result<ResultType>());\ndiff --git a/src/AggregateFunctions/AggregateFunctionBitwise.h b/src/AggregateFunctions/AggregateFunctionBitwise.h\nindex a4e5f7ddafa4..6d9eb3c36e16 100644\n--- a/src/AggregateFunctions/AggregateFunctionBitwise.h\n+++ b/src/AggregateFunctions/AggregateFunctionBitwise.h\n@@ -74,7 +74,7 @@ class AggregateFunctionBitwise final : public IAggregateFunctionDataHelper<Data,\n         readBinary(this->data(place).value, buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnVector<T> &>(to).getData().push_back(this->data(place).value);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionBoundingRatio.h b/src/AggregateFunctions/AggregateFunctionBoundingRatio.h\nindex 81846db4bac0..9ceb7976f4a3 100644\n--- a/src/AggregateFunctions/AggregateFunctionBoundingRatio.h\n+++ b/src/AggregateFunctions/AggregateFunctionBoundingRatio.h\n@@ -150,7 +150,7 @@ class AggregateFunctionBoundingRatio final : public IAggregateFunctionDataHelper\n         data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnFloat64 &>(to).getData().push_back(getBoundingRatio(data(place)));\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h b/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h\nindex 1c397c26631f..aa205a71c978 100644\n--- a/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h\n+++ b/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h\n@@ -119,8 +119,8 @@ class AggregateFunctionCategoricalIV final : public IAggregateFunctionHelper<Agg\n \n     void insertResultInto(\n         AggregateDataPtr place,\n-        IColumn & to\n-    ) const override\n+        IColumn & to,\n+        Arena *) const override\n     {\n         auto & col = static_cast<ColumnArray &>(to);\n         auto & data_col = static_cast<ColumnFloat64 &>(col.getData());\ndiff --git a/src/AggregateFunctions/AggregateFunctionCount.h b/src/AggregateFunctions/AggregateFunctionCount.h\nindex feb5725d9f1f..29c5de0021c3 100644\n--- a/src/AggregateFunctions/AggregateFunctionCount.h\n+++ b/src/AggregateFunctions/AggregateFunctionCount.h\n@@ -57,7 +57,7 @@ class AggregateFunctionCount final : public IAggregateFunctionDataHelper<Aggrega\n         readVarUInt(data(place).count, buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(data(place).count);\n     }\n@@ -112,7 +112,7 @@ class AggregateFunctionCountNotNullUnary final\n         readVarUInt(data(place).count, buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(data(place).count);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionDistinct.cpp b/src/AggregateFunctions/AggregateFunctionDistinct.cpp\nnew file mode 100644\nindex 000000000000..4d89e8fb1996\n--- /dev/null\n+++ b/src/AggregateFunctions/AggregateFunctionDistinct.cpp\n@@ -0,0 +1,64 @@\n+#include <AggregateFunctions/AggregateFunctionDistinct.h>\n+#include <AggregateFunctions/AggregateFunctionCombinatorFactory.h>\n+#include <AggregateFunctions/Helpers.h>\n+#include <Common/typeid_cast.h>\n+#include \"registerAggregateFunctions.h\"\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+class AggregateFunctionCombinatorDistinct final : public IAggregateFunctionCombinator\n+{\n+public:\n+    String getName() const override { return \"Distinct\"; }\n+\n+    DataTypes transformArguments(const DataTypes & arguments) const override\n+    {\n+        if (arguments.empty())\n+            throw Exception(\"Incorrect number of arguments for aggregate function with \" + getName() + \" suffix\",\n+                            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        return arguments;\n+    }\n+\n+    AggregateFunctionPtr transformAggregateFunction(\n+        const AggregateFunctionPtr & nested_function,\n+        const AggregateFunctionProperties &,\n+        const DataTypes & arguments,\n+        const Array &) const override\n+    {\n+        AggregateFunctionPtr res;\n+        if (arguments.size() == 1)\n+        {\n+            res.reset(createWithNumericType<\n+                AggregateFunctionDistinct,\n+                AggregateFunctionDistinctSingleNumericData>(*arguments[0], nested_function, arguments));\n+\n+            if (res)\n+                return res;\n+\n+            if (arguments[0]->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n+                return std::make_shared<\n+                    AggregateFunctionDistinct<\n+                        AggregateFunctionDistinctSingleGenericData<true>>>(nested_function, arguments);\n+            else\n+                return std::make_shared<\n+                    AggregateFunctionDistinct<\n+                        AggregateFunctionDistinctSingleGenericData<false>>>(nested_function, arguments);\n+        }\n+\n+        return std::make_shared<AggregateFunctionDistinct<AggregateFunctionDistinctMultipleGenericData>>(nested_function, arguments);\n+    }\n+};\n+\n+void registerAggregateFunctionCombinatorDistinct(AggregateFunctionCombinatorFactory & factory)\n+{\n+    factory.registerCombinator(std::make_shared<AggregateFunctionCombinatorDistinct>());\n+}\n+\n+}\ndiff --git a/src/AggregateFunctions/AggregateFunctionDistinct.h b/src/AggregateFunctions/AggregateFunctionDistinct.h\nnew file mode 100644\nindex 000000000000..01a9c71d94f7\n--- /dev/null\n+++ b/src/AggregateFunctions/AggregateFunctionDistinct.h\n@@ -0,0 +1,240 @@\n+#pragma once\n+\n+#include <AggregateFunctions/IAggregateFunction.h>\n+#include <AggregateFunctions/KeyHolderHelpers.h>\n+#include <Columns/ColumnArray.h>\n+#include <Common/assert_cast.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <Interpreters/AggregationCommon.h>\n+#include <Common/HashTable/HashSet.h>\n+#include <Common/HashTable/HashMap.h>\n+#include <Common/SipHash.h>\n+\n+#include <Common/FieldVisitors.h>\n+\n+namespace DB\n+{\n+\n+\n+template <typename T>\n+struct AggregateFunctionDistinctSingleNumericData\n+{\n+    /// When creating, the hash table must be small.\n+    using Set = HashSetWithStackMemory<T, DefaultHash<T>, 4>;\n+    using Self = AggregateFunctionDistinctSingleNumericData<T>;\n+    Set set;\n+\n+    void add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena *)\n+    {\n+        const auto & vec = assert_cast<const ColumnVector<T> &>(*columns[0]).getData();\n+        set.insert(vec[row_num]);\n+    }\n+\n+    void merge(const Self & rhs, Arena *)\n+    {\n+        set.merge(rhs.set);\n+    }\n+\n+    void serialize(WriteBuffer & buf) const\n+    {\n+        set.write(buf);\n+    }\n+\n+    void deserialize(ReadBuffer & buf, Arena *)\n+    {\n+        set.read(buf);\n+    }\n+\n+    MutableColumns getArguments(const DataTypes & argument_types) const\n+    {\n+        MutableColumns argument_columns;\n+        argument_columns.emplace_back(argument_types[0]->createColumn());\n+        for (const auto & elem : set)\n+            argument_columns[0]->insert(elem.getValue());\n+\n+        return argument_columns;\n+    }\n+};\n+\n+struct AggregateFunctionDistinctGenericData\n+{\n+    /// When creating, the hash table must be small.\n+    using Set = HashSetWithSavedHashWithStackMemory<StringRef, StringRefHash, 4>;\n+    using Self = AggregateFunctionDistinctGenericData;\n+    Set set;\n+\n+    void merge(const Self & rhs, Arena * arena)\n+    {\n+        Set::LookupResult it;\n+        bool inserted;\n+        for (const auto & elem : rhs.set)\n+            set.emplace(ArenaKeyHolder{elem.getValue(), *arena}, it, inserted);\n+    }\n+\n+    void serialize(WriteBuffer & buf) const\n+    {\n+        writeVarUInt(set.size(), buf);\n+        for (const auto & elem : set)\n+            writeStringBinary(elem.getValue(), buf);\n+    }\n+\n+    void deserialize(ReadBuffer & buf, Arena * arena)\n+    {\n+        size_t size;\n+        readVarUInt(size, buf);\n+        for (size_t i = 0; i < size; ++i)\n+            set.insert(readStringBinaryInto(*arena, buf));\n+    }\n+};\n+\n+template <bool is_plain_column>\n+struct AggregateFunctionDistinctSingleGenericData : public AggregateFunctionDistinctGenericData\n+{\n+    void add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena * arena)\n+    {\n+        Set::LookupResult it;\n+        bool inserted;\n+        auto key_holder = getKeyHolder<is_plain_column>(*columns[0], row_num, *arena);\n+        set.emplace(key_holder, it, inserted);\n+    }\n+\n+    MutableColumns getArguments(const DataTypes & argument_types) const\n+    {\n+        MutableColumns argument_columns;\n+        argument_columns.emplace_back(argument_types[0]->createColumn());\n+        for (const auto & elem : set)\n+            deserializeAndInsert<is_plain_column>(elem.getValue(), *argument_columns[0]);\n+\n+        return argument_columns;\n+    }\n+};\n+\n+struct AggregateFunctionDistinctMultipleGenericData : public AggregateFunctionDistinctGenericData\n+{\n+    void add(const IColumn ** columns, size_t columns_num, size_t row_num, Arena * arena)\n+    {\n+        const char * begin = nullptr;\n+        StringRef value(begin, 0);\n+        for (size_t i = 0; i < columns_num; ++i)\n+        {\n+            auto cur_ref = columns[i]->serializeValueIntoArena(row_num, *arena, begin);\n+            value.data = cur_ref.data - value.size;\n+            value.size += cur_ref.size;\n+        }\n+\n+        Set::LookupResult it;\n+        bool inserted;\n+        auto key_holder = SerializedKeyHolder{value, *arena};\n+        set.emplace(key_holder, it, inserted);\n+    }\n+\n+    MutableColumns getArguments(const DataTypes & argument_types) const\n+    {\n+        MutableColumns argument_columns(argument_types.size());\n+        for (size_t i = 0; i < argument_types.size(); ++i)\n+            argument_columns[i] = argument_types[i]->createColumn();\n+\n+        for (const auto & elem : set)\n+        {\n+            const char * begin = elem.getValue().data;\n+            for (auto & column : argument_columns)\n+                begin = column->deserializeAndInsertFromArena(begin);\n+        }\n+\n+        return argument_columns;\n+    }\n+};\n+\n+/** Adaptor for aggregate functions.\n+  * Adding -Distinct suffix to aggregate function\n+**/\n+template <typename Data>\n+class AggregateFunctionDistinct : public IAggregateFunctionDataHelper<Data, AggregateFunctionDistinct<Data>>\n+{\n+private:\n+    static constexpr auto prefix_size = sizeof(Data);\n+    AggregateFunctionPtr nested_func;\n+    size_t arguments_num;\n+\n+    AggregateDataPtr getNestedPlace(AggregateDataPtr place) const noexcept\n+    {\n+        return place + prefix_size;\n+    }\n+\n+    ConstAggregateDataPtr getNestedPlace(ConstAggregateDataPtr place) const noexcept\n+    {\n+        return place + prefix_size;\n+    }\n+\n+public:\n+    AggregateFunctionDistinct(AggregateFunctionPtr nested_func_, const DataTypes & arguments)\n+    : IAggregateFunctionDataHelper<Data, AggregateFunctionDistinct>(arguments, nested_func_->getParameters())\n+    , nested_func(nested_func_)\n+    , arguments_num(arguments.size()) {}\n+\n+    void add(AggregateDataPtr place, const IColumn ** columns, size_t row_num, Arena * arena) const override\n+    {\n+        this->data(place).add(columns, arguments_num, row_num, arena);\n+    }\n+\n+    void merge(AggregateDataPtr place, ConstAggregateDataPtr rhs, Arena * arena) const override\n+    {\n+        this->data(place).merge(this->data(rhs), arena);\n+    }\n+\n+    void serialize(ConstAggregateDataPtr place, WriteBuffer & buf) const override\n+    {\n+        this->data(place).serialize(buf);\n+    }\n+\n+    void deserialize(AggregateDataPtr place, ReadBuffer & buf, Arena * arena) const override\n+    {\n+        this->data(place).deserialize(buf, arena);\n+    }\n+\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const override\n+    {\n+        auto arguments = this->data(place).getArguments(this->argument_types);\n+        ColumnRawPtrs arguments_raw(arguments.size());\n+        for (size_t i = 0; i < arguments.size(); ++i)\n+            arguments_raw[i] = arguments[i].get();\n+\n+        assert(!arguments.empty());\n+        nested_func->addBatchSinglePlace(arguments[0]->size(), getNestedPlace(place), arguments_raw.data(), arena);\n+        nested_func->insertResultInto(getNestedPlace(place), to, arena);\n+    }\n+\n+    size_t sizeOfData() const override\n+    {\n+        return prefix_size + nested_func->sizeOfData();\n+    }\n+\n+    void create(AggregateDataPtr place) const override\n+    {\n+        new (place) Data;\n+        nested_func->create(getNestedPlace(place));\n+    }\n+\n+    void destroy(AggregateDataPtr place) const noexcept override\n+    {\n+        this->data(place).~Data();\n+        nested_func->destroy(getNestedPlace(place));\n+    }\n+\n+    String getName() const override\n+    {\n+        return nested_func->getName() + \"Distinct\";\n+    }\n+\n+    DataTypePtr getReturnType() const override\n+    {\n+        return nested_func->getReturnType();\n+    }\n+\n+    bool allocatesMemoryInArena() const override\n+    {\n+        return true;\n+    }\n+};\n+\n+}\ndiff --git a/src/AggregateFunctions/AggregateFunctionEntropy.h b/src/AggregateFunctions/AggregateFunctionEntropy.h\nindex ff233a5ac93d..656aca43f606 100644\n--- a/src/AggregateFunctions/AggregateFunctionEntropy.h\n+++ b/src/AggregateFunctions/AggregateFunctionEntropy.h\n@@ -132,7 +132,7 @@ class AggregateFunctionEntropy final : public IAggregateFunctionDataHelper<Entro\n         this->data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & column = assert_cast<ColumnVector<Float64> &>(to);\n         column.getData().push_back(this->data(place).get());\ndiff --git a/src/AggregateFunctions/AggregateFunctionForEach.h b/src/AggregateFunctions/AggregateFunctionForEach.h\nindex 23a3487de476..19f2994d3f1b 100644\n--- a/src/AggregateFunctions/AggregateFunctionForEach.h\n+++ b/src/AggregateFunctions/AggregateFunctionForEach.h\n@@ -225,7 +225,7 @@ class AggregateFunctionForEach final : public IAggregateFunctionDataHelper<Aggre\n         }\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const override\n     {\n         AggregateFunctionForEachData & state = data(place);\n \n@@ -236,7 +236,7 @@ class AggregateFunctionForEach final : public IAggregateFunctionDataHelper<Aggre\n         char * nested_state = state.array_of_aggregate_datas;\n         for (size_t i = 0; i < state.dynamic_array_size; ++i)\n         {\n-            nested_func->insertResultInto(nested_state, elems_to);\n+            nested_func->insertResultInto(nested_state, elems_to, arena);\n             nested_state += nested_size_of_data;\n         }\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArray.h b/src/AggregateFunctions/AggregateFunctionGroupArray.h\nindex b76efd9f6c20..f3d31eb599bf 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArray.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArray.h\n@@ -282,7 +282,7 @@ class GroupArrayNumericImpl final\n         // if constexpr (Trait::sampler == Sampler::DETERMINATOR)\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         const auto & value = this->data(place).value;\n         size_t size = value.size();\n@@ -600,7 +600,7 @@ class GroupArrayGeneralImpl final\n         // if constexpr (Trait::sampler == Sampler::DETERMINATOR)\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & column_array = assert_cast<ColumnArray &>(to);\n \n@@ -815,7 +815,7 @@ class GroupArrayGeneralListImpl final\n         data(place).last = prev;\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & column_array = assert_cast<ColumnArray &>(to);\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayInsertAt.h b/src/AggregateFunctions/AggregateFunctionGroupArrayInsertAt.h\nindex 0eec38c51a7e..d84c99aec57a 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayInsertAt.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayInsertAt.h\n@@ -179,7 +179,7 @@ class AggregateFunctionGroupArrayInsertAtGeneric final\n         }\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         ColumnArray & to_array = assert_cast<ColumnArray &>(to);\n         IColumn & to_data = to_array.getData();\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h\nindex 8f93a7eb25a7..19562b37a12d 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h\n@@ -158,7 +158,7 @@ class MovingImpl final\n         this->data(place).sum = value.back();\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         const auto & data = this->data(place);\n         size_t size = data.value.size();\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupBitmap.h b/src/AggregateFunctions/AggregateFunctionGroupBitmap.h\nindex 766479cc08d2..a6470aa69433 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupBitmap.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupBitmap.h\n@@ -48,7 +48,7 @@ class AggregateFunctionBitmap final : public IAggregateFunctionDataHelper<Data,\n         this->data(place).rbs.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnVector<T> &>(to).getData().push_back(this->data(place).rbs.size());\n     }\n@@ -113,7 +113,7 @@ class AggregateFunctionBitmapL2 final : public IAggregateFunctionDataHelper<Data\n         this->data(place).rbs.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnVector<T> &>(to).getData().push_back(this->data(place).rbs.size());\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h\nindex 88b1c87f5267..2ee9d0f6e1ca 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h\n@@ -16,6 +16,7 @@\n #include <Common/assert_cast.h>\n \n #include <AggregateFunctions/IAggregateFunction.h>\n+#include <AggregateFunctions/KeyHolderHelpers.h>\n \n #define AGGREGATE_FUNCTION_GROUP_ARRAY_UNIQ_MAX_SIZE 0xFFFFFF\n \n@@ -97,7 +98,7 @@ class AggregateFunctionGroupUniqArray\n         this->data(place).value.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         ColumnArray & arr_to = assert_cast<ColumnArray &>(to);\n         ColumnArray::Offsets & offsets_to = arr_to.getOffsets();\n@@ -147,26 +148,6 @@ class AggregateFunctionGroupUniqArrayGeneric\n \n     using State = AggregateFunctionGroupUniqArrayGenericData;\n \n-    static auto getKeyHolder(const IColumn & column, size_t row_num, Arena & arena)\n-    {\n-        if constexpr (is_plain_column)\n-        {\n-            return ArenaKeyHolder{column.getDataAt(row_num), arena};\n-        }\n-        else\n-        {\n-            const char * begin = nullptr;\n-            StringRef serialized = column.serializeValueIntoArena(row_num, arena, begin);\n-            assert(serialized.data != nullptr);\n-            return SerializedKeyHolder{serialized, arena};\n-        }\n-    }\n-\n-    static void deserializeAndInsert(StringRef str, IColumn & data_to)\n-    {\n-        return deserializeAndInsertImpl<is_plain_column>(str, data_to);\n-    }\n-\n public:\n     AggregateFunctionGroupUniqArrayGeneric(const DataTypePtr & input_data_type_, UInt64 max_elems_ = std::numeric_limits<UInt64>::max())\n         : IAggregateFunctionDataHelper<AggregateFunctionGroupUniqArrayGenericData, AggregateFunctionGroupUniqArrayGeneric<is_plain_column, Tlimit_num_elem>>({input_data_type_}, {})\n@@ -215,7 +196,7 @@ class AggregateFunctionGroupUniqArrayGeneric\n \n         bool inserted;\n         State::Set::LookupResult it;\n-        auto key_holder = getKeyHolder(*columns[0], row_num, *arena);\n+        auto key_holder = getKeyHolder<is_plain_column>(*columns[0], row_num, *arena);\n         set.emplace(key_holder, it, inserted);\n     }\n \n@@ -237,7 +218,7 @@ class AggregateFunctionGroupUniqArrayGeneric\n         }\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         ColumnArray & arr_to = assert_cast<ColumnArray &>(to);\n         ColumnArray::Offsets & offsets_to = arr_to.getOffsets();\n@@ -247,22 +228,10 @@ class AggregateFunctionGroupUniqArrayGeneric\n         offsets_to.push_back(offsets_to.back() + set.size());\n \n         for (auto & elem : set)\n-            deserializeAndInsert(elem.getValue(), data_to);\n+            deserializeAndInsert<is_plain_column>(elem.getValue(), data_to);\n     }\n };\n \n-template <>\n-inline void deserializeAndInsertImpl<false>(StringRef str, IColumn & data_to)\n-{\n-    data_to.deserializeAndInsertFromArena(str.data);\n-}\n-\n-template <>\n-inline void deserializeAndInsertImpl<true>(StringRef str, IColumn & data_to)\n-{\n-    data_to.insertData(str.data, str.size);\n-}\n-\n #undef AGGREGATE_FUNCTION_GROUP_ARRAY_UNIQ_MAX_SIZE\n \n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionHistogram.h b/src/AggregateFunctions/AggregateFunctionHistogram.h\nindex 8eaa42fdac43..bc9c95ecf2aa 100644\n--- a/src/AggregateFunctions/AggregateFunctionHistogram.h\n+++ b/src/AggregateFunctions/AggregateFunctionHistogram.h\n@@ -353,7 +353,7 @@ class AggregateFunctionHistogram final: public IAggregateFunctionDataHelper<Aggr\n         this->data(place).read(buf, max_bins);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & data = this->data(place);\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.h b/src/AggregateFunctions/AggregateFunctionIf.h\nindex bf4f0b24de33..f04450c91427 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.h\n+++ b/src/AggregateFunctions/AggregateFunctionIf.h\n@@ -95,9 +95,9 @@ class AggregateFunctionIf final : public IAggregateFunctionHelper<AggregateFunct\n         nested_func->deserialize(place, buf, arena);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const override\n     {\n-        nested_func->insertResultInto(place, to);\n+        nested_func->insertResultInto(place, to, arena);\n     }\n \n     bool allocatesMemoryInArena() const override\ndiff --git a/src/AggregateFunctions/AggregateFunctionMLMethod.h b/src/AggregateFunctions/AggregateFunctionMLMethod.h\nindex a11ca9032a57..8a93b66ab3be 100644\n--- a/src/AggregateFunctions/AggregateFunctionMLMethod.h\n+++ b/src/AggregateFunctions/AggregateFunctionMLMethod.h\n@@ -388,7 +388,7 @@ class AggregateFunctionMLMethod final : public IAggregateFunctionDataHelper<Data\n     /** This function is called if aggregate function without State modifier is selected in a query.\n      *  Inserts all weights of the model into the column 'to', so user may use such information if needed\n      */\n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         this->data(place).returnWeights(to);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionMaxIntersections.h b/src/AggregateFunctions/AggregateFunctionMaxIntersections.h\nindex 050c5fd78ea2..b8a4dd63eeae 100644\n--- a/src/AggregateFunctions/AggregateFunctionMaxIntersections.h\n+++ b/src/AggregateFunctions/AggregateFunctionMaxIntersections.h\n@@ -129,7 +129,7 @@ class AggregateFunctionIntersectionsMax final\n         buf.read(reinterpret_cast<char *>(value.data()), size * sizeof(value[0]));\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         Int64 current_intersections = 0;\n         Int64 max_intersections = 0;\ndiff --git a/src/AggregateFunctions/AggregateFunctionMerge.h b/src/AggregateFunctions/AggregateFunctionMerge.h\nindex 51a3c11118f5..066f7a762f8a 100644\n--- a/src/AggregateFunctions/AggregateFunctionMerge.h\n+++ b/src/AggregateFunctions/AggregateFunctionMerge.h\n@@ -93,9 +93,9 @@ class AggregateFunctionMerge final : public IAggregateFunctionHelper<AggregateFu\n         nested_func->deserialize(place, buf, arena);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const override\n     {\n-        nested_func->insertResultInto(place, to);\n+        nested_func->insertResultInto(place, to, arena);\n     }\n \n     bool allocatesMemoryInArena() const override\ndiff --git a/src/AggregateFunctions/AggregateFunctionMinMaxAny.h b/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\nindex 69504f7b2493..a21a64af9a48 100644\n--- a/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\n+++ b/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\n@@ -746,7 +746,7 @@ class AggregateFunctionsSingleValue final : public IAggregateFunctionDataHelper<\n         return Data::allocatesMemoryInArena();\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         this->data(place).insertResultInto(to);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionNothing.h b/src/AggregateFunctions/AggregateFunctionNothing.h\nindex b3206f6db6ec..f373b3b55b02 100644\n--- a/src/AggregateFunctions/AggregateFunctionNothing.h\n+++ b/src/AggregateFunctions/AggregateFunctionNothing.h\n@@ -67,7 +67,7 @@ class AggregateFunctionNothing final : public IAggregateFunctionHelper<Aggregate\n     {\n     }\n \n-    void insertResultInto(AggregateDataPtr, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr, IColumn & to, Arena *) const override\n     {\n         to.insertDefault();\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionNull.h b/src/AggregateFunctions/AggregateFunctionNull.h\nindex d6f0079232c5..2f2c23fdc8b7 100644\n--- a/src/AggregateFunctions/AggregateFunctionNull.h\n+++ b/src/AggregateFunctions/AggregateFunctionNull.h\n@@ -150,14 +150,14 @@ class AggregateFunctionNullBase : public IAggregateFunctionHelper<Derived>\n         }\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const override\n     {\n         if constexpr (result_is_nullable)\n         {\n             ColumnNullable & to_concrete = assert_cast<ColumnNullable &>(to);\n             if (getFlag(place))\n             {\n-                nested_function->insertResultInto(nestedPlace(place), to_concrete.getNestedColumn());\n+                nested_function->insertResultInto(nestedPlace(place), to_concrete.getNestedColumn(), arena);\n                 to_concrete.getNullMapData().push_back(0);\n             }\n             else\n@@ -167,7 +167,7 @@ class AggregateFunctionNullBase : public IAggregateFunctionHelper<Derived>\n         }\n         else\n         {\n-            nested_function->insertResultInto(nestedPlace(place), to);\n+            nested_function->insertResultInto(nestedPlace(place), to, arena);\n         }\n     }\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionOrFill.h b/src/AggregateFunctions/AggregateFunctionOrFill.h\nindex 1bbf2ea3135c..333f07d5e33f 100644\n--- a/src/AggregateFunctions/AggregateFunctionOrFill.h\n+++ b/src/AggregateFunctions/AggregateFunctionOrFill.h\n@@ -148,7 +148,8 @@ class AggregateFunctionOrFill final : public IAggregateFunctionHelper<AggregateF\n \n     void insertResultInto(\n         AggregateDataPtr place,\n-        IColumn & to) const override\n+        IColumn & to,\n+        Arena * arena) const override\n     {\n         if (place[size_of_data])\n         {\n@@ -157,20 +158,20 @@ class AggregateFunctionOrFill final : public IAggregateFunctionHelper<AggregateF\n                 // -OrNull\n \n                 if (inner_nullable)\n-                    nested_function->insertResultInto(place, to);\n+                    nested_function->insertResultInto(place, to, arena);\n                 else\n                 {\n                     ColumnNullable & col = typeid_cast<ColumnNullable &>(to);\n \n                     col.getNullMapColumn().insertDefault();\n-                    nested_function->insertResultInto(place, col.getNestedColumn());\n+                    nested_function->insertResultInto(place, col.getNestedColumn(), arena);\n                 }\n             }\n             else\n             {\n                 // -OrDefault\n \n-                nested_function->insertResultInto(place, to);\n+                nested_function->insertResultInto(place, to, arena);\n             }\n         }\n         else\ndiff --git a/src/AggregateFunctions/AggregateFunctionQuantile.h b/src/AggregateFunctions/AggregateFunctionQuantile.h\nindex 7bdfc13295cd..536d9d5683f2 100644\n--- a/src/AggregateFunctions/AggregateFunctionQuantile.h\n+++ b/src/AggregateFunctions/AggregateFunctionQuantile.h\n@@ -138,7 +138,7 @@ class AggregateFunctionQuantile final : public IAggregateFunctionDataHelper<Data\n         this->data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         /// const_cast is required because some data structures apply finalizaton (like sorting) for obtain a result.\n         auto & data = this->data(place);\ndiff --git a/src/AggregateFunctions/AggregateFunctionResample.h b/src/AggregateFunctions/AggregateFunctionResample.h\nindex 49cc312287ee..043e094a688e 100644\n--- a/src/AggregateFunctions/AggregateFunctionResample.h\n+++ b/src/AggregateFunctions/AggregateFunctionResample.h\n@@ -174,13 +174,14 @@ class AggregateFunctionResample final : public IAggregateFunctionHelper<Aggregat\n \n     void insertResultInto(\n         AggregateDataPtr place,\n-        IColumn & to) const override\n+        IColumn & to,\n+        Arena * arena) const override\n     {\n         auto & col = assert_cast<ColumnArray &>(to);\n         auto & col_offsets = assert_cast<ColumnArray::ColumnOffsets &>(col.getOffsetsColumn());\n \n         for (size_t i = 0; i < total; ++i)\n-            nested_function->insertResultInto(place + i * size_of_data, col.getData());\n+            nested_function->insertResultInto(place + i * size_of_data, col.getData(), arena);\n \n         col_offsets.getData().push_back(col.getData().size());\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionRetention.h b/src/AggregateFunctions/AggregateFunctionRetention.h\nindex 3a76ba9f0554..b742dcdf77fd 100644\n--- a/src/AggregateFunctions/AggregateFunctionRetention.h\n+++ b/src/AggregateFunctions/AggregateFunctionRetention.h\n@@ -123,7 +123,7 @@ class AggregateFunctionRetention final\n         this->data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & data_to = assert_cast<ColumnUInt8 &>(assert_cast<ColumnArray &>(to).getData()).getData();\n         auto & offsets_to = assert_cast<ColumnArray &>(to).getOffsets();\ndiff --git a/src/AggregateFunctions/AggregateFunctionSequenceMatch.h b/src/AggregateFunctions/AggregateFunctionSequenceMatch.h\nindex 416786f8fcbc..79463e890e4b 100644\n--- a/src/AggregateFunctions/AggregateFunctionSequenceMatch.h\n+++ b/src/AggregateFunctions/AggregateFunctionSequenceMatch.h\n@@ -560,7 +560,7 @@ class AggregateFunctionSequenceMatch final : public AggregateFunctionSequenceBas\n \n     DataTypePtr getReturnType() const override { return std::make_shared<DataTypeUInt8>(); }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         this->data(place).sort();\n \n@@ -588,7 +588,7 @@ class AggregateFunctionSequenceCount final : public AggregateFunctionSequenceBas\n \n     DataTypePtr getReturnType() const override { return std::make_shared<DataTypeUInt64>(); }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         const_cast<Data &>(this->data(place)).sort();\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(count(place));\ndiff --git a/src/AggregateFunctions/AggregateFunctionSimpleLinearRegression.h b/src/AggregateFunctions/AggregateFunctionSimpleLinearRegression.h\nindex d1405172e270..8c029855a265 100644\n--- a/src/AggregateFunctions/AggregateFunctionSimpleLinearRegression.h\n+++ b/src/AggregateFunctions/AggregateFunctionSimpleLinearRegression.h\n@@ -170,8 +170,8 @@ class AggregateFunctionSimpleLinearRegression final : public IAggregateFunctionD\n \n     void insertResultInto(\n         AggregateDataPtr place,\n-        IColumn & to\n-    ) const override\n+        IColumn & to,\n+        Arena *) const override\n     {\n         Ret k = this->data(place).getK();\n         Ret b = this->data(place).getB(k);\ndiff --git a/src/AggregateFunctions/AggregateFunctionState.h b/src/AggregateFunctions/AggregateFunctionState.h\nindex 126d63573afc..51a316777235 100644\n--- a/src/AggregateFunctions/AggregateFunctionState.h\n+++ b/src/AggregateFunctions/AggregateFunctionState.h\n@@ -80,7 +80,7 @@ class AggregateFunctionState final : public IAggregateFunctionHelper<AggregateFu\n         nested_func->deserialize(place, buf, arena);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnAggregateFunction &>(to).getData().push_back(place);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionStatistics.h b/src/AggregateFunctions/AggregateFunctionStatistics.h\nindex 7f6de43f5e14..b0ff57665da1 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatistics.h\n+++ b/src/AggregateFunctions/AggregateFunctionStatistics.h\n@@ -143,7 +143,7 @@ class AggregateFunctionVariance final\n         this->data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         this->data(place).publish(to);\n     }\n@@ -395,7 +395,7 @@ class AggregateFunctionCovariance final\n         this->data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         this->data(place).publish(to);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\nindex 96c07cc3d41b..7962453cb352 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n@@ -455,7 +455,7 @@ class AggregateFunctionVarianceSimple final\n         this->data(place).read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         const auto & data = this->data(place);\n         auto & dst = static_cast<ColVecResult &>(to).getData();\ndiff --git a/src/AggregateFunctions/AggregateFunctionSum.h b/src/AggregateFunctions/AggregateFunctionSum.h\nindex 9d3d559ecee8..6f921dbb78ba 100644\n--- a/src/AggregateFunctions/AggregateFunctionSum.h\n+++ b/src/AggregateFunctions/AggregateFunctionSum.h\n@@ -305,7 +305,7 @@ class AggregateFunctionSum final : public IAggregateFunctionDataHelper<Data, Agg\n         this->data(place).read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         auto & column = static_cast<ColVecResult &>(to);\n         column.getData().push_back(this->data(place).get());\ndiff --git a/src/AggregateFunctions/AggregateFunctionSumMap.h b/src/AggregateFunctions/AggregateFunctionSumMap.h\nindex 1f4be4e806e5..ab17da1b490f 100644\n--- a/src/AggregateFunctions/AggregateFunctionSumMap.h\n+++ b/src/AggregateFunctions/AggregateFunctionSumMap.h\n@@ -246,7 +246,7 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<\n         }\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         // Final step does compaction of keys that have zero values, this mutates the state\n         auto & merged_maps = this->data(place).merged_maps;\ndiff --git a/src/AggregateFunctions/AggregateFunctionTimeSeriesGroupSum.h b/src/AggregateFunctions/AggregateFunctionTimeSeriesGroupSum.h\nindex ad83324e4832..3ec40455cf3d 100644\n--- a/src/AggregateFunctions/AggregateFunctionTimeSeriesGroupSum.h\n+++ b/src/AggregateFunctions/AggregateFunctionTimeSeriesGroupSum.h\n@@ -253,7 +253,7 @@ class AggregateFunctionTimeSeriesGroupSum final\n \n     void deserialize(AggregateDataPtr place, ReadBuffer & buf, Arena *) const override { this->data(place).deserialize(buf); }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         const auto & value = this->data(place).result;\n         size_t size = value.size();\ndiff --git a/src/AggregateFunctions/AggregateFunctionTopK.h b/src/AggregateFunctions/AggregateFunctionTopK.h\nindex 23eb0e7ff09c..68317d0bdf0f 100644\n--- a/src/AggregateFunctions/AggregateFunctionTopK.h\n+++ b/src/AggregateFunctions/AggregateFunctionTopK.h\n@@ -79,7 +79,7 @@ class AggregateFunctionTopK\n         set.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         ColumnArray & arr_to = assert_cast<ColumnArray &>(to);\n         ColumnArray::Offsets & offsets_to = arr_to.getOffsets();\n@@ -200,7 +200,7 @@ class AggregateFunctionTopKGeneric : public IAggregateFunctionDataHelper<Aggrega\n         this->data(place).value.merge(this->data(rhs).value);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         ColumnArray & arr_to = assert_cast<ColumnArray &>(to);\n         ColumnArray::Offsets & offsets_to = arr_to.getOffsets();\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniq.h b/src/AggregateFunctions/AggregateFunctionUniq.h\nindex 334e809ebe7b..920232ee92cb 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniq.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniq.h\n@@ -240,7 +240,7 @@ class AggregateFunctionUniq final : public IAggregateFunctionDataHelper<Data, Ag\n         this->data(place).set.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(this->data(place).set.size());\n     }\n@@ -294,7 +294,7 @@ class AggregateFunctionUniqVariadic final : public IAggregateFunctionDataHelper<\n         this->data(place).set.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(this->data(place).set.size());\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.h b/src/AggregateFunctions/AggregateFunctionUniqCombined.h\nindex a92caa4a551b..e34cc602ccd3 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.h\n@@ -167,7 +167,7 @@ class AggregateFunctionUniqCombined final\n         this->data(place).set.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(this->data(place).set.size());\n     }\n@@ -229,7 +229,7 @@ class AggregateFunctionUniqCombinedVariadic final : public IAggregateFunctionDat\n         this->data(place).set.read(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(this->data(place).set.size());\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqUpTo.h b/src/AggregateFunctions/AggregateFunctionUniqUpTo.h\nindex 4c71215141c7..2a48e0fb182f 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqUpTo.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniqUpTo.h\n@@ -180,7 +180,7 @@ class AggregateFunctionUniqUpTo final : public IAggregateFunctionDataHelper<Aggr\n         this->data(place).read(buf, threshold);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(this->data(place).size());\n     }\n@@ -242,7 +242,7 @@ class AggregateFunctionUniqUpToVariadic final\n         this->data(place).read(buf, threshold);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(this->data(place).size());\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\nindex b5704203aded..3f41046c20e4 100644\n--- a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n+++ b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n@@ -280,7 +280,7 @@ class AggregateFunctionWindowFunnel final\n         this->data(place).deserialize(buf);\n     }\n \n-    void insertResultInto(AggregateDataPtr place, IColumn & to) const override\n+    void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override\n     {\n         assert_cast<ColumnUInt8 &>(to).getData().push_back(getEventLevel(this->data(place)));\n     }\ndiff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h\nindex 6c03d25e0b15..bc24e53a7632 100644\n--- a/src/AggregateFunctions/Helpers.h\n+++ b/src/AggregateFunctions/Helpers.h\n@@ -33,6 +33,19 @@ static IAggregateFunction * createWithNumericType(const IDataType & argument_typ\n     return nullptr;\n }\n \n+template <template <typename> class AggregateFunctionTemplate, template <typename> class Data, typename... TArgs>\n+static IAggregateFunction * createWithNumericType(const IDataType & argument_type, TArgs && ... args)\n+{\n+    WhichDataType which(argument_type);\n+#define DISPATCH(TYPE) \\\n+    if (which.idx == TypeIndex::TYPE) return new AggregateFunctionTemplate<Data<TYPE>>(std::forward<TArgs>(args)...);\n+    FOR_NUMERIC_TYPES(DISPATCH)\n+#undef DISPATCH\n+    if (which.idx == TypeIndex::Enum8) return new AggregateFunctionTemplate<Data<Int8>>(std::forward<TArgs>(args)...);\n+    if (which.idx == TypeIndex::Enum16) return new AggregateFunctionTemplate<Data<Int16>>(std::forward<TArgs>(args)...);\n+    return nullptr;\n+}\n+\n template <template <typename, bool> class AggregateFunctionTemplate, bool bool_param, typename... TArgs>\n static IAggregateFunction * createWithNumericType(const IDataType & argument_type, TArgs && ... args)\n {\ndiff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex 5f4291dd21d4..40d589f773d4 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -106,7 +106,7 @@ class IAggregateFunction\n     /// Inserts results into a column.\n     /// This method must be called once, from single thread.\n     /// After this method was called for state, you can't do anything with state but destroy.\n-    virtual void insertResultInto(AggregateDataPtr place, IColumn & to) const = 0;\n+    virtual void insertResultInto(AggregateDataPtr place, IColumn & to, Arena * arena) const = 0;\n \n     /// Used for machine learning methods. Predict result from trained model.\n     /// Will insert result into `to` column for rows in range [offset, offset + limit).\ndiff --git a/src/AggregateFunctions/KeyHolderHelpers.h b/src/AggregateFunctions/KeyHolderHelpers.h\nnew file mode 100644\nindex 000000000000..999e2518f89b\n--- /dev/null\n+++ b/src/AggregateFunctions/KeyHolderHelpers.h\n@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <Common/HashTable/HashTableKeyHolder.h>\n+#include <Columns/IColumn.h>\n+\n+namespace DB\n+{\n+\n+template <bool is_plain_column = false>\n+static auto getKeyHolder(const IColumn & column, size_t row_num, Arena & arena)\n+{\n+    if constexpr (is_plain_column)\n+    {\n+        return ArenaKeyHolder{column.getDataAt(row_num), arena};\n+    }\n+    else\n+    {\n+        const char * begin = nullptr;\n+        StringRef serialized = column.serializeValueIntoArena(row_num, arena, begin);\n+        assert(serialized.data != nullptr);\n+        return SerializedKeyHolder{serialized, arena};\n+    }\n+}\n+\n+template <bool is_plain_column>\n+static void deserializeAndInsert(StringRef str, IColumn & data_to)\n+{\n+    if constexpr (is_plain_column)\n+        data_to.insertData(str.data, str.size);\n+    else\n+        data_to.deserializeAndInsertFromArena(str.data);\n+}\n+\n+}\ndiff --git a/src/AggregateFunctions/registerAggregateFunctions.cpp b/src/AggregateFunctions/registerAggregateFunctions.cpp\nindex a9ab1d4f8eac..a8d0cf6e37ca 100644\n--- a/src/AggregateFunctions/registerAggregateFunctions.cpp\n+++ b/src/AggregateFunctions/registerAggregateFunctions.cpp\n@@ -58,6 +58,7 @@ void registerAggregateFunctions()\n         registerAggregateFunctionCombinatorNull(factory);\n         registerAggregateFunctionCombinatorOrFill(factory);\n         registerAggregateFunctionCombinatorResample(factory);\n+        registerAggregateFunctionCombinatorDistinct(factory);\n     }\n }\n \ndiff --git a/src/AggregateFunctions/registerAggregateFunctions.h b/src/AggregateFunctions/registerAggregateFunctions.h\nindex 88cdf4a504d2..981273141f95 100644\n--- a/src/AggregateFunctions/registerAggregateFunctions.h\n+++ b/src/AggregateFunctions/registerAggregateFunctions.h\n@@ -45,6 +45,7 @@ void registerAggregateFunctionCombinatorMerge(AggregateFunctionCombinatorFactory\n void registerAggregateFunctionCombinatorNull(AggregateFunctionCombinatorFactory &);\n void registerAggregateFunctionCombinatorOrFill(AggregateFunctionCombinatorFactory &);\n void registerAggregateFunctionCombinatorResample(AggregateFunctionCombinatorFactory &);\n+void registerAggregateFunctionCombinatorDistinct(AggregateFunctionCombinatorFactory &);\n \n void registerAggregateFunctions();\n \ndiff --git a/src/AggregateFunctions/ya.make b/src/AggregateFunctions/ya.make\nindex bfa32b6dd782..39f863d9471f 100644\n--- a/src/AggregateFunctions/ya.make\n+++ b/src/AggregateFunctions/ya.make\n@@ -14,6 +14,7 @@ SRCS(\n     AggregateFunctionCategoricalInformationValue.cpp\n     AggregateFunctionCombinatorFactory.cpp\n     AggregateFunctionCount.cpp\n+    AggregateFunctionDistinct.cpp\n     AggregateFunctionEntropy.cpp\n     AggregateFunctionFactory.cpp\n     AggregateFunctionForEach.cpp\ndiff --git a/src/Columns/ColumnAggregateFunction.cpp b/src/Columns/ColumnAggregateFunction.cpp\nindex d4021b45f0e9..3374d171059f 100644\n--- a/src/Columns/ColumnAggregateFunction.cpp\n+++ b/src/Columns/ColumnAggregateFunction.cpp\n@@ -135,7 +135,7 @@ MutableColumnPtr ColumnAggregateFunction::convertToValues(MutableColumnPtr colum\n     res->reserve(data.size());\n \n     for (auto * val : data)\n-        func->insertResultInto(val, *res);\n+        func->insertResultInto(val, *res, &column_aggregate_func.createOrGetArena());\n \n     return res;\n }\ndiff --git a/src/Functions/array/arrayReduce.cpp b/src/Functions/array/arrayReduce.cpp\nindex 2b37965260f2..82d93643e86e 100644\n--- a/src/Functions/array/arrayReduce.cpp\n+++ b/src/Functions/array/arrayReduce.cpp\n@@ -188,7 +188,7 @@ void FunctionArrayReduce::executeImpl(Block & block, const ColumnNumbers & argum\n \n     for (size_t i = 0; i < input_rows_count; ++i)\n         if (!res_col_aggregate_function)\n-            agg_func.insertResultInto(places[i], res_col);\n+            agg_func.insertResultInto(places[i], res_col, arena.get());\n         else\n             res_col_aggregate_function->insertFrom(places[i]);\n     block.getByPosition(result).column = std::move(result_holder);\ndiff --git a/src/Functions/array/arrayReduceInRanges.cpp b/src/Functions/array/arrayReduceInRanges.cpp\nindex c3c65c4d9e5d..ce2995a02d12 100644\n--- a/src/Functions/array/arrayReduceInRanges.cpp\n+++ b/src/Functions/array/arrayReduceInRanges.cpp\n@@ -377,7 +377,7 @@ void FunctionArrayReduceInRanges::executeImpl(Block & block, const ColumnNumbers\n             }\n \n             if (!res_col_aggregate_function)\n-                agg_func.insertResultInto(place, result_data);\n+                agg_func.insertResultInto(place, result_data, arena.get());\n             else\n                 res_col_aggregate_function->insertFrom(place);\n         }\ndiff --git a/src/Functions/runningAccumulate.cpp b/src/Functions/runningAccumulate.cpp\nindex 275259e12095..bf109654bc2d 100644\n--- a/src/Functions/runningAccumulate.cpp\n+++ b/src/Functions/runningAccumulate.cpp\n@@ -124,7 +124,7 @@ class FunctionRunningAccumulate : public IFunction\n             }\n \n             agg_func.merge(place.data(), state_to_add, arena.get());\n-            agg_func.insertResultInto(place.data(), result_column);\n+            agg_func.insertResultInto(place.data(), result_column, arena.get());\n \n             ++row_number;\n         }\ndiff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp\nindex c8165632896b..5f7414b774b2 100644\n--- a/src/Interpreters/Aggregator.cpp\n+++ b/src/Interpreters/Aggregator.cpp\n@@ -831,10 +831,11 @@ Block Aggregator::convertOneBucketToBlock(\n             MutableColumns & key_columns,\n             AggregateColumnsData & aggregate_columns,\n             MutableColumns & final_aggregate_columns,\n+            Arena * arena,\n             bool final_)\n         {\n             convertToBlockImpl(method, method.data.impls[bucket],\n-                key_columns, aggregate_columns, final_aggregate_columns, final_);\n+                key_columns, aggregate_columns, final_aggregate_columns, arena, final_);\n         });\n \n     block.info.bucket_num = bucket;\n@@ -992,6 +993,7 @@ void Aggregator::convertToBlockImpl(\n     MutableColumns & key_columns,\n     AggregateColumnsData & aggregate_columns,\n     MutableColumns & final_aggregate_columns,\n+    Arena * arena,\n     bool final) const\n {\n     if (data.empty())\n@@ -1001,7 +1003,7 @@ void Aggregator::convertToBlockImpl(\n         throw Exception{\"Aggregate. Unexpected key columns size.\", ErrorCodes::LOGICAL_ERROR};\n \n     if (final)\n-        convertToBlockImplFinal(method, data, key_columns, final_aggregate_columns);\n+        convertToBlockImplFinal(method, data, key_columns, final_aggregate_columns, arena);\n     else\n         convertToBlockImplNotFinal(method, data, key_columns, aggregate_columns);\n     /// In order to release memory early.\n@@ -1012,7 +1014,8 @@ void Aggregator::convertToBlockImpl(\n template <typename Mapped>\n inline void Aggregator::insertAggregatesIntoColumns(\n     Mapped & mapped,\n-    MutableColumns & final_aggregate_columns) const\n+    MutableColumns & final_aggregate_columns,\n+    Arena * arena) const\n {\n     /** Final values of aggregate functions are inserted to columns.\n       * Then states of aggregate functions, that are not longer needed, are destroyed.\n@@ -1043,7 +1046,8 @@ inline void Aggregator::insertAggregatesIntoColumns(\n         for (; insert_i < params.aggregates_size; ++insert_i)\n             aggregate_functions[insert_i]->insertResultInto(\n                 mapped + offsets_of_aggregate_states[insert_i],\n-                *final_aggregate_columns[insert_i]);\n+                *final_aggregate_columns[insert_i],\n+                arena);\n     }\n     catch (...)\n     {\n@@ -1080,21 +1084,22 @@ void NO_INLINE Aggregator::convertToBlockImplFinal(\n     Method & method,\n     Table & data,\n     MutableColumns & key_columns,\n-    MutableColumns & final_aggregate_columns) const\n+    MutableColumns & final_aggregate_columns,\n+    Arena * arena) const\n {\n     if constexpr (Method::low_cardinality_optimization)\n     {\n         if (data.hasNullKeyData())\n         {\n             key_columns[0]->insertDefault();\n-            insertAggregatesIntoColumns(data.getNullKeyData(), final_aggregate_columns);\n+            insertAggregatesIntoColumns(data.getNullKeyData(), final_aggregate_columns, arena);\n         }\n     }\n \n     data.forEachValue([&](const auto & key, auto & mapped)\n     {\n         method.insertKeyIntoColumns(key, key_columns, key_sizes);\n-        insertAggregatesIntoColumns(mapped, final_aggregate_columns);\n+        insertAggregatesIntoColumns(mapped, final_aggregate_columns, arena);\n     });\n }\n \n@@ -1183,7 +1188,7 @@ Block Aggregator::prepareBlockAndFill(\n         }\n     }\n \n-    filler(key_columns, aggregate_columns_data, final_aggregate_columns, final);\n+    filler(key_columns, aggregate_columns_data, final_aggregate_columns, data_variants.aggregates_pool, final);\n \n     Block res = header.cloneEmpty();\n \n@@ -1207,6 +1212,7 @@ Block Aggregator::prepareBlockAndFill(\n \n     return res;\n }\n+\n void Aggregator::fillAggregateColumnsWithSingleKey(\n     AggregatedDataVariants & data_variants,\n     MutableColumns & final_aggregate_columns)\n@@ -1249,6 +1255,7 @@ Block Aggregator::prepareBlockAndFillWithoutKey(AggregatedDataVariants & data_va\n         MutableColumns & key_columns,\n         AggregateColumnsData & aggregate_columns,\n         MutableColumns & final_aggregate_columns,\n+        Arena * arena,\n         bool final_)\n     {\n         if (data_variants.type == AggregatedDataVariants::Type::without_key || params.overflow_row)\n@@ -1263,7 +1270,7 @@ Block Aggregator::prepareBlockAndFillWithoutKey(AggregatedDataVariants & data_va\n             }\n             else\n             {\n-                insertAggregatesIntoColumns(data, final_aggregate_columns);\n+                insertAggregatesIntoColumns(data, final_aggregate_columns, arena);\n             }\n \n             if (params.overflow_row)\n@@ -1291,12 +1298,13 @@ Block Aggregator::prepareBlockAndFillSingleLevel(AggregatedDataVariants & data_v\n         MutableColumns & key_columns,\n         AggregateColumnsData & aggregate_columns,\n         MutableColumns & final_aggregate_columns,\n+        Arena * arena,\n         bool final_)\n     {\n     #define M(NAME) \\\n         else if (data_variants.type == AggregatedDataVariants::Type::NAME) \\\n             convertToBlockImpl(*data_variants.NAME, data_variants.NAME->data, \\\n-                key_columns, aggregate_columns, final_aggregate_columns, final_);\n+                key_columns, aggregate_columns, final_aggregate_columns, arena, final_);\n \n         if (false) {} // NOLINT\n         APPLY_FOR_VARIANTS_SINGLE_LEVEL(M)\ndiff --git a/src/Interpreters/Aggregator.h b/src/Interpreters/Aggregator.h\nindex 0546271873b6..7eb30bef7873 100644\n--- a/src/Interpreters/Aggregator.h\n+++ b/src/Interpreters/Aggregator.h\n@@ -1176,19 +1176,22 @@ class Aggregator\n         MutableColumns & key_columns,\n         AggregateColumnsData & aggregate_columns,\n         MutableColumns & final_aggregate_columns,\n+        Arena * arena,\n         bool final) const;\n \n     template <typename Mapped>\n     void insertAggregatesIntoColumns(\n         Mapped & mapped,\n-        MutableColumns & final_aggregate_columns) const;\n+        MutableColumns & final_aggregate_columns,\n+        Arena * arena) const;\n \n     template <typename Method, typename Table>\n     void convertToBlockImplFinal(\n         Method & method,\n         Table & data,\n         MutableColumns & key_columns,\n-        MutableColumns & final_aggregate_columns) const;\n+        MutableColumns & final_aggregate_columns,\n+        Arena * arena) const;\n \n     template <typename Method, typename Table>\n     void convertToBlockImplNotFinal(\ndiff --git a/src/Interpreters/SyntaxAnalyzer.cpp b/src/Interpreters/SyntaxAnalyzer.cpp\nindex b8d6d1714018..5dec563eebb6 100644\n--- a/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -89,7 +89,10 @@ struct CustomizeFunctionsData\n };\n \n char countdistinct[] = \"countdistinct\";\n-using CustomizeFunctionsVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunctionsData<countdistinct>>, true>;\n+using CustomizeCountDistinctVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunctionsData<countdistinct>>, true>;\n+\n+char countifdistinct[] = \"countifdistinct\";\n+using CustomizeCountIfDistinctVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunctionsData<countifdistinct>>, true>;\n \n char in[] = \"in\";\n using CustomizeInVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunctionsData<in>>, true>;\n@@ -103,6 +106,26 @@ using CustomizeGlobalInVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunc\n char globalNotIn[] = \"globalnotin\";\n using CustomizeGlobalNotInVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunctionsData<globalNotIn>>, true>;\n \n+template <char const * func_suffix>\n+struct CustomizeFunctionsSuffixData\n+{\n+    using TypeToVisit = ASTFunction;\n+\n+    const String & customized_func_suffix;\n+\n+    void visit(ASTFunction & func, ASTPtr &)\n+    {\n+        if (endsWith(Poco::toLower(func.name), func_suffix))\n+        {\n+            size_t prefix_len = func.name.length() - strlen(func_suffix);\n+            func.name = func.name.substr(0, prefix_len) + customized_func_suffix;\n+        }\n+    }\n+};\n+\n+/// Swap 'if' and 'distinct' suffixes to make execution more optimal.\n+char ifDistinct[] = \"ifdistinct\";\n+using CustomizeIfDistinctVisitor = InDepthNodeVisitor<OneTypeMatcher<CustomizeFunctionsSuffixData<ifDistinct>>, true>;\n \n /// Translate qualified names such as db.table.column, table.column, table_alias.column to names' normal form.\n /// Expand asterisks and qualified asterisks with column names.\n@@ -1044,8 +1067,14 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(\n \n void SyntaxAnalyzer::normalize(ASTPtr & query, Aliases & aliases, const Settings & settings)\n {\n-    CustomizeFunctionsVisitor::Data data{settings.count_distinct_implementation};\n-    CustomizeFunctionsVisitor(data).visit(query);\n+    CustomizeCountDistinctVisitor::Data data_count_distinct{settings.count_distinct_implementation};\n+    CustomizeCountDistinctVisitor(data_count_distinct).visit(query);\n+\n+    CustomizeCountIfDistinctVisitor::Data data_count_if_distinct{settings.count_distinct_implementation.toString() + \"If\"};\n+    CustomizeCountIfDistinctVisitor(data_count_if_distinct).visit(query);\n+\n+    CustomizeIfDistinctVisitor::Data data_distinct_if{\"DistinctIf\"};\n+    CustomizeIfDistinctVisitor(data_distinct_if).visit(query);\n \n     if (settings.transform_null_in)\n     {\ndiff --git a/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp\nindex 34e32cdfe3ac..b834ed827299 100644\n--- a/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp\n@@ -223,7 +223,7 @@ void AggregatingSortedAlgorithm::AggregatingMergedData::finishGroup()\n     /// Write the simple aggregation result for the current group.\n     for (auto & desc : def.columns_to_simple_aggregate)\n     {\n-        desc.function->insertResultInto(desc.state.data(), *desc.column);\n+        desc.function->insertResultInto(desc.state.data(), *desc.column, arena.get());\n         desc.destroyState();\n     }\n \ndiff --git a/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp\nindex e364a452797f..0e704e5a05bf 100644\n--- a/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp\n@@ -308,7 +308,7 @@ void GraphiteRollupSortedAlgorithm::GraphiteRollupMergedData::insertRow(\n     const Graphite::AggregationPattern * aggregation_pattern = std::get<1>(current_rule);\n     if (aggregate_state_created)\n     {\n-        aggregation_pattern->function->insertResultInto(place_for_aggregate_state.data(), *value_column);\n+        aggregation_pattern->function->insertResultInto(place_for_aggregate_state.data(), *value_column, nullptr);\n         aggregation_pattern->function->destroy(place_for_aggregate_state.data());\n         aggregate_state_created = false;\n     }\ndiff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\nindex 78ee848c3770..3833e3288fda 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n@@ -498,7 +498,7 @@ void SummingSortedAlgorithm::SummingMergedData::finishGroup()\n             {\n                 try\n                 {\n-                    desc.function->insertResultInto(desc.state.data(), *desc.merged_column);\n+                    desc.function->insertResultInto(desc.state.data(), *desc.merged_column, nullptr);\n \n                     /// Update zero status of current row\n                     if (desc.column_numbers.size() == 1)\n",
  "test_patch": "diff --git a/tests/performance/distinct_combinator.xml b/tests/performance/distinct_combinator.xml\nnew file mode 100644\nindex 000000000000..2261dc2f86d1\n--- /dev/null\n+++ b/tests/performance/distinct_combinator.xml\n@@ -0,0 +1,6 @@\n+<test>\n+    <query>SELECT x, sum(DISTINCT y) from (SELECT number % 12 AS x, number % 12321 AS y FROM numbers(10000000)) GROUP BY x</query>\n+    <query>SELECT x, sum(y) from (SELECT DISTINCT number % 12 AS x, number % 12321 AS y FROM numbers(10000000)) GROUP BY x</query>\n+    <query>SELECT sumIf(DISTINCT number % 10, number % 5 = 2) FROM numbers(100000000)</query>\n+    <query>SELECT countIf(DISTINCT number % 10, number % 5 = 2) FROM numbers(100000000)</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/01259_combinator_distinct.reference b/tests/queries/0_stateless/01259_combinator_distinct.reference\nnew file mode 100644\nindex 000000000000..94e4f7d0d179\n--- /dev/null\n+++ b/tests/queries/0_stateless/01259_combinator_distinct.reference\n@@ -0,0 +1,15 @@\n+4999950000\n+78\n+[0,1,2,3,4,5,6,7,8,9,10,11,12]\n+20\n+0.49237\n+0.49237\n+15\n+18\n+21\n+24\n+27\n+2\n+SELECT uniqExactIf(number % 10, (number % 5) = 2)\\nFROM numbers(10000)\n+9\n+SELECT sumDistinctIf(number % 10, (number % 5) = 2)\\nFROM numbers(10000)\ndiff --git a/tests/queries/0_stateless/01259_combinator_distinct.sql b/tests/queries/0_stateless/01259_combinator_distinct.sql\nnew file mode 100644\nindex 000000000000..1b6f887ff701\n--- /dev/null\n+++ b/tests/queries/0_stateless/01259_combinator_distinct.sql\n@@ -0,0 +1,15 @@\n+SELECT sum(DISTINCT number) FROM numbers_mt(100000);\n+SELECT sum(DISTINCT number % 13) FROM numbers_mt(100000);\n+SELECT arraySort(groupArray(DISTINCT number % 13)) FROM numbers_mt(100000);\n+SELECT finalizeAggregation(countState(DISTINCT toString(number % 20))) FROM numbers_mt(100000);\n+SELECT round(corrStable(DISTINCT x, y), 5) FROM (SELECT number % 10 AS x, number % 5 AS y FROM numbers(1000));\n+SELECT round(corrStable(x, y), 5) FROM (SELECT DISTINCT number % 10 AS x, number % 5 AS y FROM numbers(1000));\n+\n+SELECT sum(DISTINCT y) FROM (SELECT number % 5 AS x, number % 15 AS y FROM numbers(1000)) GROUP BY x;\n+\n+SET enable_debug_queries = 1;\n+SELECT countIf(DISTINCT number % 10, number % 5 = 2) FROM numbers(10000);\n+ANALYZE SELECT countIf(DISTINCT number % 10, number % 5 = 2) FROM numbers(10000);\n+\n+SELECT sumIf(DISTINCT number % 10, number % 5 = 2) FROM numbers(10000);\n+ANALYZE SELECT sumIf(DISTINCT number % 10, number % 5 = 2) FROM numbers(10000);\ndiff --git a/tests/queries/0_stateless/01259_combinator_distinct_distributed.reference b/tests/queries/0_stateless/01259_combinator_distinct_distributed.reference\nnew file mode 100644\nindex 000000000000..096d5703292e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01259_combinator_distinct_distributed.reference\n@@ -0,0 +1,4 @@\n+78\n+[0,1,2,3,4,5,6,7,8,9,10,11,12]\n+20\n+0.49237\ndiff --git a/tests/queries/0_stateless/01259_combinator_distinct_distributed.sql b/tests/queries/0_stateless/01259_combinator_distinct_distributed.sql\nnew file mode 100644\nindex 000000000000..f851e64dbcbc\n--- /dev/null\n+++ b/tests/queries/0_stateless/01259_combinator_distinct_distributed.sql\n@@ -0,0 +1,4 @@\n+SELECT sum(DISTINCT number % 13) FROM remote('127.0.0.{1,2}', numbers_mt(100000));\n+SELECT arraySort(groupArray(DISTINCT number % 13)) FROM remote('127.0.0.{1,2}', numbers_mt(100000));\n+SELECT finalizeAggregation(countState(DISTINCT toString(number % 20))) FROM remote('127.0.0.{1,2}', numbers_mt(100000));\n+SELECT round(corrStable(DISTINCT x, y), 5) FROM (SELECT number % 10 AS x, number % 5 AS y FROM remote('127.0.0.{1,2}', numbers(1000)));\n",
  "problem_statement": "What's the issue with `sumDistinct` ?\nI'm trying to do a query along the lines of:\r\n\r\n`SELECT SUM(DISTINCT( (gb_val, weight).2 )) FROM my_table`\r\n\r\nBut I get exception:\r\n`DB::Exception: Unknown function SUMDistinct. `\r\n\r\nHowever, the same logic works perfectly well with:\r\n\r\n`arraySum(arrayMap(lambda(tuple(x), tupleElement(x, 2)), groupUniqArray(tuple(gb_val, weight))))` ... which is slow as ****, presumably due to all the array creation and appending that's going on.\r\n\r\nWhy is `sumDistinct` not a valid function in this case ? And is there a fundamental issue that would stop it from being implemented ? Is there a more efficient way to go about this problem ?\r\n\r\nIn my case the same `gb_val` always has the same `weight`, so the distinct is only needed on the `gb_val` column, `ANY` could be applied to weight... but I think that's besides the point.\nsupport `countIf(DISTINCT col1, <cond_expr>)`\n(you don't have to strictly follow this form)\r\n\r\n**Use case**\r\nwhen trying to translate postgres sql to clickhouse sql,  `COUNT(col1) FILTER (WHERE <cond_expr>)`  is equal with `countIf(col1, <cond_expr>)`. it would be much more consistent if \r\n`COUNT(DISTINCT col1) FILTER (WHERE <cond_expr>)` can translate as `countIf(DISTINCT col1, <cond_expr>)`.\r\n\r\n\r\n\r\n**Describe the solution you'd like**\r\nAs `count(DISTINCT col1)` is supported, looks like it's reasonable to support `countIf(DISTINCT col1, <cond_expr>)` .\r\n\r\n**Describe alternatives you've considered**\r\n`uniqExactIf(col1, <cond_expr>)`\r\n\r\n**Additional context**\r\n \n",
  "hints_text": "There's only count(distinct ) that is replaced with uniqExact() (according to count_distinct_implementation setting). You may try to make sum over subselect with group by.\n@4ertus2 That's the approach I ended up using since it was fastest (SUM over a sub select with group by), but I feel like implementing sumDistinct, even with the same performance, might feel more coherent. Then again, maybe it's harder than I imagine to do something like this.\r\n\r\nIf I ever have the time I'll try looking into how that could be implemented...\n",
  "created_at": "2020-06-17T11:41:26Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionAggThrow.cpp",
    "src/AggregateFunctions/AggregateFunctionArgMinMax.h",
    "src/AggregateFunctions/AggregateFunctionArray.h",
    "src/AggregateFunctions/AggregateFunctionAvg.h",
    "src/AggregateFunctions/AggregateFunctionBitwise.h",
    "src/AggregateFunctions/AggregateFunctionBoundingRatio.h",
    "src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h",
    "src/AggregateFunctions/AggregateFunctionCount.h",
    "b/src/AggregateFunctions/AggregateFunctionDistinct.cpp",
    "b/src/AggregateFunctions/AggregateFunctionDistinct.h",
    "src/AggregateFunctions/AggregateFunctionEntropy.h",
    "src/AggregateFunctions/AggregateFunctionForEach.h",
    "src/AggregateFunctions/AggregateFunctionGroupArray.h",
    "src/AggregateFunctions/AggregateFunctionGroupArrayInsertAt.h",
    "src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h",
    "src/AggregateFunctions/AggregateFunctionGroupBitmap.h",
    "src/AggregateFunctions/AggregateFunctionGroupUniqArray.h",
    "src/AggregateFunctions/AggregateFunctionHistogram.h",
    "src/AggregateFunctions/AggregateFunctionIf.h",
    "src/AggregateFunctions/AggregateFunctionMLMethod.h",
    "src/AggregateFunctions/AggregateFunctionMaxIntersections.h",
    "src/AggregateFunctions/AggregateFunctionMerge.h",
    "src/AggregateFunctions/AggregateFunctionMinMaxAny.h",
    "src/AggregateFunctions/AggregateFunctionNothing.h",
    "src/AggregateFunctions/AggregateFunctionNull.h",
    "src/AggregateFunctions/AggregateFunctionOrFill.h",
    "src/AggregateFunctions/AggregateFunctionQuantile.h",
    "src/AggregateFunctions/AggregateFunctionResample.h",
    "src/AggregateFunctions/AggregateFunctionRetention.h",
    "src/AggregateFunctions/AggregateFunctionSequenceMatch.h",
    "src/AggregateFunctions/AggregateFunctionSimpleLinearRegression.h",
    "src/AggregateFunctions/AggregateFunctionState.h",
    "src/AggregateFunctions/AggregateFunctionStatistics.h",
    "src/AggregateFunctions/AggregateFunctionStatisticsSimple.h",
    "src/AggregateFunctions/AggregateFunctionSum.h",
    "src/AggregateFunctions/AggregateFunctionSumMap.h",
    "src/AggregateFunctions/AggregateFunctionTimeSeriesGroupSum.h",
    "src/AggregateFunctions/AggregateFunctionTopK.h",
    "src/AggregateFunctions/AggregateFunctionUniq.h",
    "src/AggregateFunctions/AggregateFunctionUniqCombined.h",
    "src/AggregateFunctions/AggregateFunctionUniqUpTo.h",
    "src/AggregateFunctions/AggregateFunctionWindowFunnel.h",
    "src/AggregateFunctions/Helpers.h",
    "src/AggregateFunctions/IAggregateFunction.h",
    "b/src/AggregateFunctions/KeyHolderHelpers.h",
    "src/AggregateFunctions/registerAggregateFunctions.cpp",
    "src/AggregateFunctions/registerAggregateFunctions.h",
    "src/AggregateFunctions/ya.make",
    "src/Columns/ColumnAggregateFunction.cpp",
    "src/Functions/array/arrayReduce.cpp",
    "src/Functions/array/arrayReduceInRanges.cpp",
    "src/Functions/runningAccumulate.cpp",
    "src/Interpreters/Aggregator.cpp",
    "src/Interpreters/Aggregator.h",
    "src/Interpreters/SyntaxAnalyzer.cpp",
    "src/Processors/Merges/Algorithms/AggregatingSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/GraphiteRollupSortedAlgorithm.cpp",
    "src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/distinct_combinator.xml",
    "b/tests/queries/0_stateless/01259_combinator_distinct.reference",
    "b/tests/queries/0_stateless/01259_combinator_distinct.sql",
    "b/tests/queries/0_stateless/01259_combinator_distinct_distributed.reference",
    "b/tests/queries/0_stateless/01259_combinator_distinct_distributed.sql"
  ]
}