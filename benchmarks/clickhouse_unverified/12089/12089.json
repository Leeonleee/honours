{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12089,
  "instance_id": "ClickHouse__ClickHouse-12089",
  "issue_numbers": [
    "11595"
  ],
  "base_commit": "8513e1ec7498ca5cb2dc162ebd642cadfc708c6e",
  "patch": "diff --git a/src/DataStreams/BlockIO.h b/src/DataStreams/BlockIO.h\nindex d4733e6aebe8..91d7efac8d13 100644\n--- a/src/DataStreams/BlockIO.h\n+++ b/src/DataStreams/BlockIO.h\n@@ -31,8 +31,8 @@ struct BlockIO\n     QueryPipeline pipeline;\n \n     /// Callbacks for query logging could be set here.\n-    std::function<void(IBlockInputStream *, IBlockOutputStream *)>    finish_callback;\n-    std::function<void()>                                             exception_callback;\n+    std::function<void(IBlockInputStream *, IBlockOutputStream *, QueryPipeline *)>    finish_callback;\n+    std::function<void()>                                                              exception_callback;\n \n     /// When it is true, don't bother sending any non-empty blocks to the out stream\n     bool null_format = false;\n@@ -41,7 +41,13 @@ struct BlockIO\n     void onFinish()\n     {\n         if (finish_callback)\n-            finish_callback(in.get(), out.get());\n+        {\n+            QueryPipeline * pipeline_ptr = nullptr;\n+            if (pipeline.initialized())\n+                pipeline_ptr = &pipeline;\n+\n+            finish_callback(in.get(), out.get(), pipeline_ptr);\n+        }\n     }\n \n     void onException()\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 41fa60324ec9..860c56b1052e 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -479,7 +479,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             }\n \n             /// Also make possible for caller to log successful query finish and exception during execution.\n-            auto finish_callback = [elem, &context, log_queries, log_queries_min_type = settings.log_queries_min_type] (IBlockInputStream * stream_in, IBlockOutputStream * stream_out) mutable\n+            auto finish_callback = [elem, &context, log_queries, log_queries_min_type = settings.log_queries_min_type]\n+                (IBlockInputStream * stream_in, IBlockOutputStream * stream_out, QueryPipeline * query_pipeline) mutable\n             {\n                 QueryStatus * process_list_elem = context.getProcessListElement();\n \n@@ -528,6 +529,14 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                         elem.result_bytes = counting_stream->getProgress().read_bytes;\n                     }\n                 }\n+                else if (query_pipeline)\n+                {\n+                    if (const auto * output_format = query_pipeline->getOutputFormat())\n+                    {\n+                        elem.result_rows = output_format->getResultRows();\n+                        elem.result_bytes = output_format->getResultBytes();\n+                    }\n+                }\n \n                 if (elem.read_rows != 0)\n                 {\ndiff --git a/src/Processors/Formats/IOutputFormat.cpp b/src/Processors/Formats/IOutputFormat.cpp\nindex 334843036dc7..f7fc6170cad3 100644\n--- a/src/Processors/Formats/IOutputFormat.cpp\n+++ b/src/Processors/Formats/IOutputFormat.cpp\n@@ -59,6 +59,8 @@ void IOutputFormat::work()\n     switch (current_block_kind)\n     {\n         case Main:\n+            result_rows += current_chunk.getNumRows();\n+            result_bytes += current_chunk.allocatedBytes();\n             consume(std::move(current_chunk));\n             break;\n         case Totals:\ndiff --git a/src/Processors/Formats/IOutputFormat.h b/src/Processors/Formats/IOutputFormat.h\nindex 2e3db50ee6e5..ae5e4d72d3cb 100644\n--- a/src/Processors/Formats/IOutputFormat.h\n+++ b/src/Processors/Formats/IOutputFormat.h\n@@ -79,6 +79,14 @@ class IOutputFormat : public IProcessor\n \n     void setTotals(const Block & totals) { consumeTotals(Chunk(totals.getColumns(), totals.rows())); }\n     void setExtremes(const Block & extremes) { consumeExtremes(Chunk(extremes.getColumns(), extremes.rows())); }\n+\n+    size_t getResultRows() const { return result_rows; }\n+    size_t getResultBytes() const { return result_bytes; }\n+\n+private:\n+    /// Counters for consumed chunks. Are used for QueryLog.\n+    size_t result_rows = 0;\n+    size_t result_bytes = 0;\n };\n }\n \ndiff --git a/src/Processors/QueryPipeline.h b/src/Processors/QueryPipeline.h\nindex 7dddb2526e54..9a33b549ab51 100644\n--- a/src/Processors/QueryPipeline.h\n+++ b/src/Processors/QueryPipeline.h\n@@ -110,6 +110,8 @@ class QueryPipeline\n     void addCreatingSetsTransform(ProcessorPtr transform);\n     /// Resize pipeline to single output and add IOutputFormat. Pipeline will be completed after this transformation.\n     void setOutputFormat(ProcessorPtr output);\n+    /// Get current OutputFormat.\n+    IOutputFormat * getOutputFormat() const { return output_format; }\n     /// Sink is a processor with single input port and no output ports. Creates sink for each output port.\n     /// Pipeline will be completed after this transformation.\n     void setSinks(const ProcessorGetterWithStreamKind & getter);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01357_result_rows.reference b/tests/queries/0_stateless/01357_result_rows.reference\nnew file mode 100644\nindex 000000000000..cd121fd3feba\n--- /dev/null\n+++ b/tests/queries/0_stateless/01357_result_rows.reference\n@@ -0,0 +1,2 @@\n+1\n+1\t1\ndiff --git a/tests/queries/0_stateless/01357_result_rows.sql b/tests/queries/0_stateless/01357_result_rows.sql\nnew file mode 100644\nindex 000000000000..17c2d15979a7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01357_result_rows.sql\n@@ -0,0 +1,5 @@\n+set log_queries = 1;\n+select count() > 0 from system.settings;\n+\n+system flush logs;\n+select result_rows, result_bytes >= 8 from system.query_log where event_date >= today() - 1 and lower(query) like '%select count() > 0 from system.settings%' and type = 'QueryFinish' order by query_start_time desc limit 1;\n",
  "problem_statement": "select query always have zero result_rows/result_bytes on system.query_log table\n\r\n**Describe the bug**\r\nselect query always have zero result_rows/result_bytes on system.query_log table\r\n\r\n**How to reproduce**\r\n1. select * from any table with data on your clickhouse db.\r\n2. check system.query_log\r\n\r\n* Which ClickHouse server version to use\r\nversion 20.4.4.18\r\n\r\n\r\n* Queries to run that lead to unexpected result\r\nall select queries have this issue.\r\ne.g. `select * from system.settings`\r\n\r\n**Expected behavior**\r\nresult_rows/result_bytes should tell how many rows/bytes returned by clickhouse\r\n\r\n**Error message and/or stacktrace**\r\nNo\r\n**Additional context**\r\nWe monitor result_rows/result_bytes/read_rows/read_bytes as a measurement for the clickhouse cluster usage. read_rows/read_bytes can be get from query_log correctly. However, result_rows/result_bytes are always zero for select clause.\r\n\r\nWe previously use version 19.14. The measurement works well. However, on 20.4, result_rows/result_bytes becomes always zero.\r\n\r\n\n",
  "hints_text": "@filimonov Any update? Is there any work around?",
  "created_at": "2020-07-02T15:17:57Z",
  "modified_files": [
    "src/DataStreams/BlockIO.h",
    "src/Interpreters/executeQuery.cpp",
    "src/Processors/Formats/IOutputFormat.cpp",
    "src/Processors/Formats/IOutputFormat.h",
    "src/Processors/QueryPipeline.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01357_result_rows.reference",
    "b/tests/queries/0_stateless/01357_result_rows.sql"
  ]
}