{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60672,
  "instance_id": "ClickHouse__ClickHouse-60672",
  "issue_numbers": [
    "60653"
  ],
  "base_commit": "580f0f02d39b8af632d0f044872ab1a00e65a682",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex d253095ca014..79e5ee442c20 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -170,7 +170,8 @@ struct BinaryOperationTraits\n     /// DateTime, but if both operands are Dates, their type must be the same (e.g. Date - DateTime is invalid).\n     using ResultDataType = Switch<\n         /// Result must be Integer\n-        Case<IsOperation<Operation>::div_int || IsOperation<Operation>::div_int_or_zero, DataTypeFromFieldType<typename Op::ResultType>>,\n+        Case<IsOperation<Operation>::int_div || IsOperation<Operation>::int_div_or_zero,\n+            std::conditional_t<IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType>, DataTypeFromFieldType<typename Op::ResultType>, InvalidType>>,\n         /// Decimal cases\n         Case<IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>, DecimalResultDataType>,\n         Case<\n@@ -672,8 +673,8 @@ struct DecimalBinaryOperation\n                                             IsOperation<Operation>::minus;\n     static constexpr bool is_multiply =     IsOperation<Operation>::multiply;\n     static constexpr bool is_float_division = IsOperation<Operation>::div_floating;\n-    static constexpr bool is_int_division = IsOperation<Operation>::div_int ||\n-                                            IsOperation<Operation>::div_int_or_zero;\n+    static constexpr bool is_int_division = IsOperation<Operation>::int_div ||\n+                                            IsOperation<Operation>::int_div_or_zero;\n     static constexpr bool is_division = is_float_division || is_int_division;\n     static constexpr bool is_compare =      IsOperation<Operation>::least ||\n                                             IsOperation<Operation>::greatest;\n@@ -781,8 +782,8 @@ class FunctionBinaryArithmetic : public IFunction\n     static constexpr bool is_division = IsOperation<Op>::division;\n     static constexpr bool is_bit_hamming_distance = IsOperation<Op>::bit_hamming_distance;\n     static constexpr bool is_modulo = IsOperation<Op>::modulo;\n-    static constexpr bool is_div_int = IsOperation<Op>::div_int;\n-    static constexpr bool is_div_int_or_zero = IsOperation<Op>::div_int_or_zero;\n+    static constexpr bool is_int_div = IsOperation<Op>::int_div;\n+    static constexpr bool is_int_div_or_zero = IsOperation<Op>::int_div_or_zero;\n \n     ContextPtr context;\n     bool check_decimal_overflow = true;\n@@ -1007,11 +1008,11 @@ class FunctionBinaryArithmetic : public IFunction\n             {\n                 function_name = \"tupleModuloByNumber\";\n             }\n-            else if constexpr (is_div_int)\n+            else if constexpr (is_int_div)\n             {\n                 function_name = \"tupleIntDivByNumber\";\n             }\n-            else if constexpr (is_div_int_or_zero)\n+            else if constexpr (is_int_div_or_zero)\n             {\n                 function_name = \"tupleIntDivOrZeroByNumber\";\n             }\n@@ -1466,7 +1467,7 @@ class FunctionBinaryArithmetic : public IFunction\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override\n     {\n-        return ((IsOperation<Op>::div_int || IsOperation<Op>::modulo || IsOperation<Op>::positive_modulo) && !arguments[1].is_const)\n+        return ((IsOperation<Op>::int_div || IsOperation<Op>::modulo || IsOperation<Op>::positive_modulo) && !arguments[1].is_const)\n             || (IsOperation<Op>::div_floating\n                 && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type)));\n     }\n@@ -1690,7 +1691,7 @@ class FunctionBinaryArithmetic : public IFunction\n \n                 if constexpr (!std::is_same_v<ResultDataType, InvalidType>)\n                 {\n-                    if constexpr (is_div_int || is_div_int_or_zero)\n+                    if constexpr (is_int_div || is_int_div_or_zero)\n                         type_res = std::make_shared<ResultDataType>();\n                     else if constexpr (IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType>)\n                     {\n@@ -2086,7 +2087,7 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n                     right_nullmap);\n             }\n             /// Here we check if we have `intDiv` or `intDivOrZero` and at least one of the arguments is decimal, because in this case originally we had result as decimal, so we need to convert result into integer after calculations\n-            else if constexpr (!decimal_with_float && (is_div_int || is_div_int_or_zero) && (IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>))\n+            else if constexpr (!decimal_with_float && (is_int_div || is_int_div_or_zero) && (IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>))\n             {\n \n                 if constexpr (!std::is_same_v<DecimalResultType, InvalidType>)\n@@ -2624,7 +2625,7 @@ class BinaryArithmeticOverloadResolver : public IFunctionOverloadResolver\n         /// Check the case when operation is divide, intDiv or modulo and denominator is Nullable(Something).\n         /// For divide operation we should check only Nullable(Decimal), because only this case can throw division by zero error.\n         bool division_by_nullable = !arguments[0].type->onlyNull() && !arguments[1].type->onlyNull() && arguments[1].type->isNullable()\n-            && (IsOperation<Op>::div_int || IsOperation<Op>::modulo || IsOperation<Op>::positive_modulo\n+            && (IsOperation<Op>::int_div || IsOperation<Op>::modulo || IsOperation<Op>::positive_modulo\n                 || (IsOperation<Op>::div_floating\n                     && (isDecimalOrNullableDecimal(arguments[0].type) || isDecimalOrNullableDecimal(arguments[1].type))));\n \ndiff --git a/src/Functions/IsOperation.h b/src/Functions/IsOperation.h\nindex b2c7a27d3752..a74df8f4dd94 100644\n--- a/src/Functions/IsOperation.h\n+++ b/src/Functions/IsOperation.h\n@@ -51,8 +51,8 @@ struct IsOperation\n     static constexpr bool minus = IsSameOperation<Op, MinusImpl>::value;\n     static constexpr bool multiply = IsSameOperation<Op, MultiplyImpl>::value;\n     static constexpr bool div_floating = IsSameOperation<Op, DivideFloatingImpl>::value;\n-    static constexpr bool div_int = IsSameOperation<Op, DivideIntegralImpl>::value;\n-    static constexpr bool div_int_or_zero = IsSameOperation<Op, DivideIntegralOrZeroImpl>::value;\n+    static constexpr bool int_div = IsSameOperation<Op, DivideIntegralImpl>::value;\n+    static constexpr bool int_div_or_zero = IsSameOperation<Op, DivideIntegralOrZeroImpl>::value;\n     static constexpr bool modulo = IsSameOperation<Op, ModuloImpl>::value;\n     static constexpr bool positive_modulo = IsSameOperation<Op, PositiveModuloImpl>::value;\n     static constexpr bool least = IsSameOperation<Op, LeastBaseImpl>::value;\n@@ -60,7 +60,7 @@ struct IsOperation\n \n     static constexpr bool bit_hamming_distance = IsSameOperation<Op, BitHammingDistanceImpl>::value;\n \n-    static constexpr bool division = div_floating || div_int || div_int_or_zero || modulo;\n+    static constexpr bool division = div_floating || int_div || int_div_or_zero || modulo;\n     // NOTE: allow_decimal should not fully contain `division` because of divInt\n     static constexpr bool allow_decimal = plus || minus || multiply || division || least || greatest;\n };\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03002_int_div_decimal_with_date_bug.reference b/tests/queries/0_stateless/03002_int_div_decimal_with_date_bug.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03002_int_div_decimal_with_date_bug.sql b/tests/queries/0_stateless/03002_int_div_decimal_with_date_bug.sql\nnew file mode 100644\nindex 000000000000..1668821200c6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03002_int_div_decimal_with_date_bug.sql\n@@ -0,0 +1,5 @@\n+SELECT intDiv(CAST('1.0', 'Decimal256(3)'), today()); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT intDiv(CAST('1.0', 'Decimal256(3)'), toDate('2023-01-02')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT intDiv(CAST('1.0', 'Decimal256(2)'), toDate32('2023-01-02 12:12:12')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT intDiv(CAST('1.0', 'Decimal256(2)'), toDateTime('2023-01-02 12:12:12')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT intDiv(CAST('1.0', 'Decimal256(2)'), toDateTime64('2023-01-02 12:12:12.002', 3)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n",
  "problem_statement": "Logical error: IntDiv with decimal + date\nSource report: https://s3.amazonaws.com/clickhouse-test-reports/0/1b042be13b68c3c0f1a99a22115bd71e003d90a9/ast_fuzzer__asan_.html\r\n\r\nSimplest repo:\r\n```\r\nSELECT intDiv(CAST('1.0', 'Decimal256(3)'), today())\r\n```\r\n\r\n```\r\n<Fatal> : Logical error: 'Arguments of 'intDiv' have incorrect data types: 'CAST('1.0', 'Decimal256(3)')' of type 'Decimal(76, 3)', 'today()' of type 'Date''\r\n```\n",
  "hints_text": "Introduced in https://github.com/ClickHouse/ClickHouse/pull/59243",
  "created_at": "2024-03-01T17:45:40Z",
  "modified_files": [
    "src/Functions/FunctionBinaryArithmetic.h",
    "src/Functions/IsOperation.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03002_int_div_decimal_with_date_bug.sql"
  ]
}