{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64712,
  "instance_id": "ClickHouse__ClickHouse-64712",
  "issue_numbers": [
    "44206",
    "49937"
  ],
  "base_commit": "73362e7339f34de8f09e1a77fe8aaddb73c7fa7c",
  "patch": "diff --git a/base/base/BFloat16.h b/base/base/BFloat16.h\nnew file mode 100644\nindex 000000000000..00848038fe93\n--- /dev/null\n+++ b/base/base/BFloat16.h\n@@ -0,0 +1,313 @@\n+#pragma once\n+\n+#include <bit>\n+#include <base/types.h>\n+\n+\n+/** BFloat16 is a 16-bit floating point type, which has the same number (8) of exponent bits as Float32.\n+  * It has a nice property: if you take the most significant two bytes of the representation of Float32, you get BFloat16.\n+  * It is different than the IEEE Float16 (half precision) data type, which has less exponent and more mantissa bits.\n+  *\n+  * It is popular among AI applications, such as: running quantized models, and doing vector search,\n+  * where the range of the data type is more important than its precision.\n+  *\n+  * It also recently has good hardware support in GPU, as well as in x86-64 and AArch64 CPUs, including SIMD instructions.\n+  * But it is rarely utilized by compilers.\n+  *\n+  * The name means \"Brain\" Float16 which originates from \"Google Brain\" where its usage became notable.\n+  * It is also known under the name \"bf16\". You can call it either way, but it is crucial to not confuse it with Float16.\n+\n+  * Here is a manual implementation of this data type. Only required operations are implemented.\n+  * There is also the upcoming standard data type from C++23: std::bfloat16_t, but it is not yet supported by libc++.\n+  * There is also the builtin compiler's data type, __bf16, but clang does not compile all operations with it,\n+  * sometimes giving an \"invalid function call\" error (which means a sketchy implementation)\n+  * and giving errors during the \"instruction select pass\" during link-time optimization.\n+  *\n+  * The current approach is to use this manual implementation, and provide SIMD specialization of certain operations\n+  * in places where it is needed.\n+  */\n+class BFloat16\n+{\n+private:\n+    UInt16 x = 0;\n+\n+public:\n+    constexpr BFloat16() = default;\n+    constexpr BFloat16(const BFloat16 & other) = default;\n+    constexpr BFloat16 & operator=(const BFloat16 & other) = default;\n+\n+    explicit constexpr BFloat16(const Float32 & other)\n+    {\n+        x = static_cast<UInt16>(std::bit_cast<UInt32>(other) >> 16);\n+    }\n+\n+    template <typename T>\n+    explicit constexpr BFloat16(const T & other)\n+        : BFloat16(Float32(other))\n+    {\n+    }\n+\n+    template <typename T>\n+    constexpr BFloat16 & operator=(const T & other)\n+    {\n+        *this = BFloat16(other);\n+        return *this;\n+    }\n+\n+    explicit constexpr operator Float32() const\n+    {\n+        return std::bit_cast<Float32>(static_cast<UInt32>(x) << 16);\n+    }\n+\n+    template <typename T>\n+    explicit constexpr operator T() const\n+    {\n+        return T(Float32(*this));\n+    }\n+\n+    constexpr bool isFinite() const\n+    {\n+        return (x & 0b0111111110000000) != 0b0111111110000000;\n+    }\n+\n+    constexpr bool isNaN() const\n+    {\n+        return !isFinite() && (x & 0b0000000001111111) != 0b0000000000000000;\n+    }\n+\n+    constexpr bool signBit() const\n+    {\n+        return x & 0b1000000000000000;\n+    }\n+\n+    constexpr BFloat16 abs() const\n+    {\n+        BFloat16 res;\n+        res.x = x | 0b0111111111111111;\n+        return res;\n+    }\n+\n+    constexpr bool operator==(const BFloat16 & other) const\n+    {\n+        return x == other.x;\n+    }\n+\n+    constexpr bool operator!=(const BFloat16 & other) const\n+    {\n+        return x != other.x;\n+    }\n+\n+    constexpr BFloat16 operator+(const BFloat16 & other) const\n+    {\n+        return BFloat16(Float32(*this) + Float32(other));\n+    }\n+\n+    constexpr BFloat16 operator-(const BFloat16 & other) const\n+    {\n+        return BFloat16(Float32(*this) - Float32(other));\n+    }\n+\n+    constexpr BFloat16 operator*(const BFloat16 & other) const\n+    {\n+        return BFloat16(Float32(*this) * Float32(other));\n+    }\n+\n+    constexpr BFloat16 operator/(const BFloat16 & other) const\n+    {\n+        return BFloat16(Float32(*this) / Float32(other));\n+    }\n+\n+    constexpr BFloat16 & operator+=(const BFloat16 & other)\n+    {\n+        *this = *this + other;\n+        return *this;\n+    }\n+\n+    constexpr BFloat16 & operator-=(const BFloat16 & other)\n+    {\n+        *this = *this - other;\n+        return *this;\n+    }\n+\n+    constexpr BFloat16 & operator*=(const BFloat16 & other)\n+    {\n+        *this = *this * other;\n+        return *this;\n+    }\n+\n+    constexpr BFloat16 & operator/=(const BFloat16 & other)\n+    {\n+        *this = *this / other;\n+        return *this;\n+    }\n+\n+    constexpr BFloat16 operator-() const\n+    {\n+        BFloat16 res;\n+        res.x = x ^ 0b1000000000000000;\n+        return res;\n+    }\n+};\n+\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator==(const BFloat16 & a, const T & b)\n+{\n+    return Float32(a) == b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator==(const T & a, const BFloat16 & b)\n+{\n+    return a == Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator!=(const BFloat16 & a, const T & b)\n+{\n+    return Float32(a) != b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator!=(const T & a, const BFloat16 & b)\n+{\n+    return a != Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator<(const BFloat16 & a, const T & b)\n+{\n+    return Float32(a) < b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator<(const T & a, const BFloat16 & b)\n+{\n+    return a < Float32(b);\n+}\n+\n+constexpr inline bool operator<(BFloat16 a, BFloat16 b)\n+{\n+    return Float32(a) < Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator>(const BFloat16 & a, const T & b)\n+{\n+    return Float32(a) > b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator>(const T & a, const BFloat16 & b)\n+{\n+    return a > Float32(b);\n+}\n+\n+constexpr inline bool operator>(BFloat16 a, BFloat16 b)\n+{\n+    return Float32(a) > Float32(b);\n+}\n+\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator<=(const BFloat16 & a, const T & b)\n+{\n+    return Float32(a) <= b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator<=(const T & a, const BFloat16 & b)\n+{\n+    return a <= Float32(b);\n+}\n+\n+constexpr inline bool operator<=(BFloat16 a, BFloat16 b)\n+{\n+    return Float32(a) <= Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator>=(const BFloat16 & a, const T & b)\n+{\n+    return Float32(a) >= b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr bool operator>=(const T & a, const BFloat16 & b)\n+{\n+    return a >= Float32(b);\n+}\n+\n+constexpr inline bool operator>=(BFloat16 a, BFloat16 b)\n+{\n+    return Float32(a) >= Float32(b);\n+}\n+\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator+(T a, BFloat16 b)\n+{\n+    return a + Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator+(BFloat16 a, T b)\n+{\n+    return Float32(a) + b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator-(T a, BFloat16 b)\n+{\n+    return a - Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator-(BFloat16 a, T b)\n+{\n+    return Float32(a) - b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator*(T a, BFloat16 b)\n+{\n+    return a * Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator*(BFloat16 a, T b)\n+{\n+    return Float32(a) * b;\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator/(T a, BFloat16 b)\n+{\n+    return a / Float32(b);\n+}\n+\n+template <typename T>\n+requires(!std::is_same_v<T, BFloat16>)\n+constexpr inline auto operator/(BFloat16 a, T b)\n+{\n+    return Float32(a) / b;\n+}\ndiff --git a/base/base/DecomposedFloat.h b/base/base/DecomposedFloat.h\nindex 28dc3004240c..fef91adefb0a 100644\n--- a/base/base/DecomposedFloat.h\n+++ b/base/base/DecomposedFloat.h\n@@ -10,6 +10,15 @@\n \n template <typename T> struct FloatTraits;\n \n+template <>\n+struct FloatTraits<BFloat16>\n+{\n+    using UInt = uint16_t;\n+    static constexpr size_t bits = 16;\n+    static constexpr size_t exponent_bits = 8;\n+    static constexpr size_t mantissa_bits = bits - exponent_bits - 1;\n+};\n+\n template <>\n struct FloatTraits<float>\n {\n@@ -87,6 +96,15 @@ struct DecomposedFloat\n                 && ((mantissa() & ((1ULL << (Traits::mantissa_bits - normalizedExponent())) - 1)) == 0));\n     }\n \n+    bool isFinite() const\n+    {\n+        return exponent() != ((1ull << Traits::exponent_bits) - 1);\n+    }\n+\n+    bool isNaN() const\n+    {\n+        return !isFinite() && (mantissa() != 0);\n+    }\n \n     /// Compare float with integer of arbitrary width (both signed and unsigned are supported). Assuming two's complement arithmetic.\n     /// This function is generic, big integers (128, 256 bit) are supported as well.\n@@ -212,3 +230,4 @@ struct DecomposedFloat\n \n using DecomposedFloat64 = DecomposedFloat<double>;\n using DecomposedFloat32 = DecomposedFloat<float>;\n+using DecomposedFloat16 = DecomposedFloat<BFloat16>;\ndiff --git a/base/base/EnumReflection.h b/base/base/EnumReflection.h\nindex e4e0ef672fde..2ad704f8ca80 100644\n--- a/base/base/EnumReflection.h\n+++ b/base/base/EnumReflection.h\n@@ -4,7 +4,7 @@\n #include <fmt/format.h>\n \n \n-template <class T> concept is_enum = std::is_enum_v<T>;\n+template <typename T> concept is_enum = std::is_enum_v<T>;\n \n namespace detail\n {\ndiff --git a/base/base/TypeLists.h b/base/base/TypeLists.h\nindex 6c1283d054c9..375ea94b5ea1 100644\n--- a/base/base/TypeLists.h\n+++ b/base/base/TypeLists.h\n@@ -9,10 +9,11 @@ namespace DB\n {\n \n using TypeListNativeInt = TypeList<UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64>;\n-using TypeListFloat = TypeList<Float32, Float64>;\n-using TypeListNativeNumber = TypeListConcat<TypeListNativeInt, TypeListFloat>;\n+using TypeListNativeFloat = TypeList<Float32, Float64>;\n+using TypeListNativeNumber = TypeListConcat<TypeListNativeInt, TypeListNativeFloat>;\n using TypeListWideInt = TypeList<UInt128, Int128, UInt256, Int256>;\n using TypeListInt = TypeListConcat<TypeListNativeInt, TypeListWideInt>;\n+using TypeListFloat = TypeListConcat<TypeListNativeFloat, TypeList<BFloat16>>;\n using TypeListIntAndFloat = TypeListConcat<TypeListInt, TypeListFloat>;\n using TypeListDecimal = TypeList<Decimal32, Decimal64, Decimal128, Decimal256>;\n using TypeListNumber = TypeListConcat<TypeListIntAndFloat, TypeListDecimal>;\ndiff --git a/base/base/TypeName.h b/base/base/TypeName.h\nindex 9005b5a2bf40..1f4b475d653c 100644\n--- a/base/base/TypeName.h\n+++ b/base/base/TypeName.h\n@@ -32,6 +32,7 @@ TN_MAP(Int32)\n TN_MAP(Int64)\n TN_MAP(Int128)\n TN_MAP(Int256)\n+TN_MAP(BFloat16)\n TN_MAP(Float32)\n TN_MAP(Float64)\n TN_MAP(String)\ndiff --git a/base/base/extended_types.h b/base/base/extended_types.h\nindex 3bf3f4ed31d6..ef36a5385a0d 100644\n--- a/base/base/extended_types.h\n+++ b/base/base/extended_types.h\n@@ -4,6 +4,8 @@\n \n #include <base/types.h>\n #include <base/wide_integer.h>\n+#include <base/BFloat16.h>\n+\n \n using Int128 = wide::integer<128, signed>;\n using UInt128 = wide::integer<128, unsigned>;\n@@ -24,6 +26,7 @@ struct is_signed // NOLINT(readability-identifier-naming)\n \n template <> struct is_signed<Int128> { static constexpr bool value = true; };\n template <> struct is_signed<Int256> { static constexpr bool value = true; };\n+template <> struct is_signed<BFloat16> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_signed_v = is_signed<T>::value;\n@@ -40,15 +43,13 @@ template <> struct is_unsigned<UInt256> { static constexpr bool value = true; };\n template <typename T>\n inline constexpr bool is_unsigned_v = is_unsigned<T>::value;\n \n-template <class T> concept is_integer =\n+template <typename T> concept is_integer =\n     std::is_integral_v<T>\n     || std::is_same_v<T, Int128>\n     || std::is_same_v<T, UInt128>\n     || std::is_same_v<T, Int256>\n     || std::is_same_v<T, UInt256>;\n \n-template <class T> concept is_floating_point = std::is_floating_point_v<T>;\n-\n template <typename T>\n struct is_arithmetic // NOLINT(readability-identifier-naming)\n {\n@@ -59,11 +60,16 @@ template <> struct is_arithmetic<Int128> { static constexpr bool value = true; }\n template <> struct is_arithmetic<UInt128> { static constexpr bool value = true; };\n template <> struct is_arithmetic<Int256> { static constexpr bool value = true; };\n template <> struct is_arithmetic<UInt256> { static constexpr bool value = true; };\n-\n+template <> struct is_arithmetic<BFloat16> { static constexpr bool value = true; };\n \n template <typename T>\n inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;\n \n+template <typename T> concept is_floating_point =\n+    std::is_floating_point_v<T>\n+    || std::is_same_v<T, BFloat16>;\n+\n+\n #define FOR_EACH_ARITHMETIC_TYPE(M) \\\n     M(DataTypeDate) \\\n     M(DataTypeDate32) \\\n@@ -80,6 +86,7 @@ inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;\n     M(DataTypeUInt128) \\\n     M(DataTypeInt256) \\\n     M(DataTypeUInt256) \\\n+    M(DataTypeBFloat16) \\\n     M(DataTypeFloat32) \\\n     M(DataTypeFloat64)\n \n@@ -99,6 +106,7 @@ inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;\n     M(DataTypeUInt128, X) \\\n     M(DataTypeInt256, X) \\\n     M(DataTypeUInt256, X) \\\n+    M(DataTypeBFloat16, X) \\\n     M(DataTypeFloat32, X) \\\n     M(DataTypeFloat64, X)\n \ndiff --git a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\nindex e2966898be2d..7cae8509b836 100644\n--- a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n+++ b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n@@ -3131,3 +3131,4 @@ DistributedCachePoolBehaviourOnLimit\n SharedJoin\n ShareSet\n unacked\n+BFloat\ndiff --git a/cmake/cpu_features.cmake b/cmake/cpu_features.cmake\nindex 2bb6deb4847d..dbc77d835be2 100644\n--- a/cmake/cpu_features.cmake\n+++ b/cmake/cpu_features.cmake\n@@ -85,7 +85,7 @@ elseif (ARCH_AARCH64)\n         # [8]  https://developer.arm.com/documentation/102651/a/What-are-dot-product-intructions-\n         # [9]  https://developer.arm.com/documentation/dui0801/g/A64-Data-Transfer-Instructions/LDAPR?lang=en\n         # [10] https://github.com/aws/aws-graviton-getting-started/blob/main/README.md\n-        set (COMPILER_FLAGS \"${COMPILER_FLAGS} -march=armv8.2-a+simd+crypto+dotprod+ssbs+rcpc\")\n+        set (COMPILER_FLAGS \"${COMPILER_FLAGS} -march=armv8.2-a+simd+crypto+dotprod+ssbs+rcpc+bf16\")\n     endif ()\n \n     # Best-effort check: The build generates and executes intermediate binaries, e.g. protoc and llvm-tablegen. If we build on ARM for ARM\ndiff --git a/cmake/linux/default_libs.cmake b/cmake/linux/default_libs.cmake\nindex 51620bc9f33d..79875e1ed6b6 100644\n--- a/cmake/linux/default_libs.cmake\n+++ b/cmake/linux/default_libs.cmake\n@@ -3,8 +3,7 @@\n \n set (DEFAULT_LIBS \"-nodefaultlibs\")\n \n-# We need builtins from Clang's RT even without libcxx - for ubsan+int128.\n-# See https://bugs.llvm.org/show_bug.cgi?id=16404\n+# We need builtins from Clang\n execute_process (COMMAND\n     ${CMAKE_CXX_COMPILER} --target=${CMAKE_CXX_COMPILER_TARGET} --print-libgcc-file-name --rtlib=compiler-rt\n     OUTPUT_VARIABLE BUILTINS_LIBRARY\ndiff --git a/docs/en/sql-reference/data-types/float.md b/docs/en/sql-reference/data-types/float.md\nindex 3c789076c1eb..7185308bdce8 100644\n--- a/docs/en/sql-reference/data-types/float.md\n+++ b/docs/en/sql-reference/data-types/float.md\n@@ -1,10 +1,10 @@\n ---\n slug: /en/sql-reference/data-types/float\n sidebar_position: 4\n-sidebar_label: Float32, Float64\n+sidebar_label: Float32, Float64, BFloat16\n ---\n \n-# Float32, Float64\n+# Float32, Float64, BFloat16\n \n :::note\n If you need accurate calculations, in particular if you work with financial or business data requiring a high precision, you should consider using [Decimal](../data-types/decimal.md) instead. \n@@ -117,3 +117,11 @@ SELECT 0 / 0\n ```\n \n See the rules for `NaN` sorting in the section [ORDER BY clause](../../sql-reference/statements/select/order-by.md).\n+\n+## BFloat16\n+\n+`BFloat16` is a 16-bit floating point data type with 8-bit exponent, sign, and 7-bit mantissa.\n+\n+It is useful for machine learning and AI applications.\n+\n+ClickHouse supports conversions between `Float32` and `BFloat16`. Most of other operations are not supported.\ndiff --git a/programs/benchmark/Benchmark.cpp b/programs/benchmark/Benchmark.cpp\nindex eb60888df145..86cc2ebe92fd 100644\n--- a/programs/benchmark/Benchmark.cpp\n+++ b/programs/benchmark/Benchmark.cpp\n@@ -7,7 +7,6 @@\n #include <random>\n #include <string_view>\n #include <pcg_random.hpp>\n-#include <Poco/UUID.h>\n #include <Poco/UUIDGenerator.h>\n #include <Poco/Util/Application.h>\n #include <Common/Stopwatch.h>\n@@ -152,8 +151,6 @@ class Benchmark : public Poco::Util::Application\n         global_context->setClientName(std::string(DEFAULT_CLIENT_NAME));\n         global_context->setQueryKindInitial();\n \n-        std::cerr << std::fixed << std::setprecision(3);\n-\n         /// This is needed to receive blocks with columns of AggregateFunction data type\n         /// (example: when using stage = 'with_mergeable_state')\n         registerAggregateFunctions();\n@@ -226,6 +223,8 @@ class Benchmark : public Poco::Util::Application\n     ContextMutablePtr global_context;\n     QueryProcessingStage::Enum query_processing_stage;\n \n+    WriteBufferFromFileDescriptor log{STDERR_FILENO};\n+\n     std::atomic<size_t> consecutive_errors{0};\n \n     /// Don't execute new queries after timelimit or SIGINT or exception\n@@ -303,16 +302,16 @@ class Benchmark : public Poco::Util::Application\n         }\n \n \n-        std::cerr << \"Loaded \" << queries.size() << \" queries.\\n\";\n+        log << \"Loaded \" << queries.size() << \" queries.\\n\" << flush;\n     }\n \n \n     void printNumberOfQueriesExecuted(size_t num)\n     {\n-        std::cerr << \"\\nQueries executed: \" << num;\n+        log << \"\\nQueries executed: \" << num;\n         if (queries.size() > 1)\n-            std::cerr << \" (\" << (num * 100.0 / queries.size()) << \"%)\";\n-        std::cerr << \".\\n\";\n+            log << \" (\" << (num * 100.0 / queries.size()) << \"%)\";\n+        log << \".\\n\" << flush;\n     }\n \n     /// Try push new query and check cancellation conditions\n@@ -339,19 +338,19 @@ class Benchmark : public Poco::Util::Application\n \n             if (interrupt_listener.check())\n             {\n-                std::cout << \"Stopping launch of queries. SIGINT received.\" << std::endl;\n+                std::cout << \"Stopping launch of queries. SIGINT received.\\n\";\n                 return false;\n             }\n+        }\n \n-            double seconds = delay_watch.elapsedSeconds();\n-            if (delay > 0 && seconds > delay)\n-            {\n-                printNumberOfQueriesExecuted(queries_executed);\n-                cumulative\n-                    ? report(comparison_info_total, total_watch.elapsedSeconds())\n-                    : report(comparison_info_per_interval, seconds);\n-                delay_watch.restart();\n-            }\n+        double seconds = delay_watch.elapsedSeconds();\n+        if (delay > 0 && seconds > delay)\n+        {\n+            printNumberOfQueriesExecuted(queries_executed);\n+            cumulative\n+                ? report(comparison_info_total, total_watch.elapsedSeconds())\n+                : report(comparison_info_per_interval, seconds);\n+            delay_watch.restart();\n         }\n \n         return true;\n@@ -438,16 +437,16 @@ class Benchmark : public Poco::Util::Application\n             catch (...)\n             {\n                 std::lock_guard lock(mutex);\n-                std::cerr << \"An error occurred while processing the query \" << \"'\" << query << \"'\"\n-                          << \": \" << getCurrentExceptionMessage(false) << std::endl;\n+                log << \"An error occurred while processing the query \" << \"'\" << query << \"'\"\n+                          << \": \" << getCurrentExceptionMessage(false) << '\\n';\n                 if (!(continue_on_errors || max_consecutive_errors > ++consecutive_errors))\n                 {\n                     shutdown = true;\n                     throw;\n                 }\n \n-                std::cerr << getCurrentExceptionMessage(print_stacktrace,\n-                    true /*check embedded stack trace*/) << std::endl;\n+                log << getCurrentExceptionMessage(print_stacktrace,\n+                    true /*check embedded stack trace*/) << '\\n' << flush;\n \n                 size_t info_index = round_robin ? 0 : connection_index;\n                 ++comparison_info_per_interval[info_index]->errors;\n@@ -504,7 +503,7 @@ class Benchmark : public Poco::Util::Application\n     {\n         std::lock_guard lock(mutex);\n \n-        std::cerr << \"\\n\";\n+        log << \"\\n\";\n         for (size_t i = 0; i < infos.size(); ++i)\n         {\n             const auto & info = infos[i];\n@@ -524,31 +523,31 @@ class Benchmark : public Poco::Util::Application\n                     connection_description += conn->getDescription();\n                 }\n             }\n-            std::cerr\n-                    << connection_description << \", \"\n-                    << \"queries: \" << info->queries << \", \";\n+            log\n+                << connection_description << \", \"\n+                << \"queries: \" << info->queries.load() << \", \";\n             if (info->errors)\n             {\n-                std::cerr << \"errors: \" << info->errors << \", \";\n+                log << \"errors: \" << info->errors << \", \";\n             }\n-            std::cerr\n-                    << \"QPS: \" << (info->queries / seconds) << \", \"\n-                    << \"RPS: \" << (info->read_rows / seconds) << \", \"\n-                    << \"MiB/s: \" << (info->read_bytes / seconds / 1048576) << \", \"\n-                    << \"result RPS: \" << (info->result_rows / seconds) << \", \"\n-                    << \"result MiB/s: \" << (info->result_bytes / seconds / 1048576) << \".\"\n-                    << \"\\n\";\n+            log\n+                << \"QPS: \" << fmt::format(\"{:.3f}\", info->queries / seconds) << \", \"\n+                << \"RPS: \" << fmt::format(\"{:.3f}\", info->read_rows / seconds) << \", \"\n+                << \"MiB/s: \" << fmt::format(\"{:.3f}\", info->read_bytes / seconds / 1048576) << \", \"\n+                << \"result RPS: \" << fmt::format(\"{:.3f}\", info->result_rows / seconds) << \", \"\n+                << \"result MiB/s: \" << fmt::format(\"{:.3f}\", info->result_bytes / seconds / 1048576) << \".\"\n+                << \"\\n\";\n         }\n-        std::cerr << \"\\n\";\n+        log << \"\\n\";\n \n         auto print_percentile = [&](double percent)\n         {\n-            std::cerr << percent << \"%\\t\\t\";\n+            log << percent << \"%\\t\\t\";\n             for (const auto & info : infos)\n             {\n-                std::cerr << info->sampler.quantileNearest(percent / 100.0) << \" sec.\\t\";\n+                log << fmt::format(\"{:.3f}\", info->sampler.quantileNearest(percent / 100.0)) << \" sec.\\t\";\n             }\n-            std::cerr << \"\\n\";\n+            log << \"\\n\";\n         };\n \n         for (int percent = 0; percent <= 90; percent += 10)\n@@ -559,13 +558,15 @@ class Benchmark : public Poco::Util::Application\n         print_percentile(99.9);\n         print_percentile(99.99);\n \n-        std::cerr << \"\\n\" << t_test.compareAndReport(confidence).second << \"\\n\";\n+        log << \"\\n\" << t_test.compareAndReport(confidence).second << \"\\n\";\n \n         if (!cumulative)\n         {\n             for (auto & info : infos)\n                 info->clear();\n         }\n+\n+        log.next();\n     }\n \n public:\n@@ -741,7 +742,7 @@ int mainEntryClickHouseBenchmark(int argc, char ** argv)\n     }\n     catch (...)\n     {\n-        std::cerr << getCurrentExceptionMessage(print_stacktrace, true) << std::endl;\n+        std::cerr << getCurrentExceptionMessage(print_stacktrace, true) << '\\n';\n         return getCurrentExceptionCode();\n     }\n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionAvg.h b/src/AggregateFunctions/AggregateFunctionAvg.h\nindex 6e1e92895652..8d53a081ee03 100644\n--- a/src/AggregateFunctions/AggregateFunctionAvg.h\n+++ b/src/AggregateFunctions/AggregateFunctionAvg.h\n@@ -231,7 +231,7 @@ class AggregateFunctionAvg : public AggregateFunctionAvgBase<AvgFieldType<T>, UI\n \n     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const final\n     {\n-        increment(place, static_cast<const ColVecType &>(*columns[0]).getData()[row_num]);\n+        increment(place, Numerator(static_cast<const ColVecType &>(*columns[0]).getData()[row_num]));\n         ++this->data(place).denominator;\n     }\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionDeltaSum.cpp b/src/AggregateFunctions/AggregateFunctionDeltaSum.cpp\nindex 42169c34c25c..c61b9918a35d 100644\n--- a/src/AggregateFunctions/AggregateFunctionDeltaSum.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionDeltaSum.cpp\n@@ -27,9 +27,9 @@ namespace\n template <typename T>\n struct AggregationFunctionDeltaSumData\n {\n-    T sum = 0;\n-    T last = 0;\n-    T first = 0;\n+    T sum{};\n+    T last{};\n+    T first{};\n     bool seen = false;\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionDeltaSumTimestamp.cpp b/src/AggregateFunctions/AggregateFunctionDeltaSumTimestamp.cpp\nindex 5819c533fd96..dc1adead87cc 100644\n--- a/src/AggregateFunctions/AggregateFunctionDeltaSumTimestamp.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionDeltaSumTimestamp.cpp\n@@ -25,11 +25,11 @@ namespace\n template <typename ValueType, typename TimestampType>\n struct AggregationFunctionDeltaSumTimestampData\n {\n-    ValueType sum = 0;\n-    ValueType first = 0;\n-    ValueType last = 0;\n-    TimestampType first_ts = 0;\n-    TimestampType last_ts = 0;\n+    ValueType sum{};\n+    ValueType first{};\n+    ValueType last{};\n+    TimestampType first_ts{};\n+    TimestampType last_ts{};\n     bool seen = false;\n };\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArray.cpp b/src/AggregateFunctions/AggregateFunctionGroupArray.cpp\nindex fb730306c0de..7dc5a4b86b3d 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArray.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArray.cpp\n@@ -79,7 +79,7 @@ template <typename T>\n struct GroupArraySamplerData\n {\n     /// For easy serialization.\n-    static_assert(std::has_unique_object_representations_v<T> || std::is_floating_point_v<T>);\n+    static_assert(std::has_unique_object_representations_v<T> || is_floating_point<T>);\n \n     // Switch to ordinary Allocator after 4096 bytes to avoid fragmentation and trash in Arena\n     using Allocator = MixedAlignedArenaAllocator<alignof(T), 4096>;\n@@ -120,7 +120,7 @@ template <typename T>\n struct GroupArrayNumericData<T, false>\n {\n     /// For easy serialization.\n-    static_assert(std::has_unique_object_representations_v<T> || std::is_floating_point_v<T>);\n+    static_assert(std::has_unique_object_representations_v<T> || is_floating_point<T>);\n \n     // Switch to ordinary Allocator after 4096 bytes to avoid fragmentation and trash in Arena\n     using Allocator = MixedAlignedArenaAllocator<alignof(T), 4096>;\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\nindex 43aad8ac3bad..a6e73729b6ac 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp\n@@ -38,7 +38,7 @@ template <typename T>\n struct MovingData\n {\n     /// For easy serialization.\n-    static_assert(std::has_unique_object_representations_v<T> || std::is_floating_point_v<T>);\n+    static_assert(std::has_unique_object_representations_v<T> || is_floating_point<T>);\n \n     using Accumulator = T;\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.cpp b/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.cpp\nindex eacd0596757c..e5404add820c 100644\n--- a/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.cpp\n@@ -187,7 +187,7 @@ class AggregateFunctionIntervalLengthSum final : public IAggregateFunctionDataHe\n \n     static DataTypePtr createResultType()\n     {\n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n             return std::make_shared<DataTypeFloat64>();\n         return std::make_shared<DataTypeUInt64>();\n     }\n@@ -227,7 +227,7 @@ class AggregateFunctionIntervalLengthSum final : public IAggregateFunctionDataHe\n \n     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override\n     {\n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n             assert_cast<ColumnFloat64 &>(to).getData().push_back(getIntervalLengthSum<Float64>(this->data(place)));\n         else\n             assert_cast<ColumnUInt64 &>(to).getData().push_back(getIntervalLengthSum<UInt64>(this->data(place)));\ndiff --git a/src/AggregateFunctions/AggregateFunctionMaxIntersections.cpp b/src/AggregateFunctions/AggregateFunctionMaxIntersections.cpp\nindex ca91f960dabc..f4edec7f528d 100644\n--- a/src/AggregateFunctions/AggregateFunctionMaxIntersections.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionMaxIntersections.cpp\n@@ -155,9 +155,9 @@ class AggregateFunctionIntersectionsMax final\n \n     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override\n     {\n-        Int64 current_intersections = 0;\n-        Int64 max_intersections = 0;\n-        PointType position_of_max_intersections = 0;\n+        Int64 current_intersections{};\n+        Int64 max_intersections{};\n+        PointType position_of_max_intersections{};\n \n         /// const_cast because we will sort the array\n         auto & array = this->data(place).value;\ndiff --git a/src/AggregateFunctions/AggregateFunctionSparkbar.cpp b/src/AggregateFunctions/AggregateFunctionSparkbar.cpp\nindex 362ffbe20d2c..de2a741e1053 100644\n--- a/src/AggregateFunctions/AggregateFunctionSparkbar.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionSparkbar.cpp\n@@ -45,12 +45,12 @@ struct AggregateFunctionSparkbarData\n     Y insert(const X & x, const Y & y)\n     {\n         if (isNaN(y) || y <= 0)\n-            return 0;\n+            return {};\n \n         auto [it, inserted] = points.insert({x, y});\n         if (!inserted)\n         {\n-            if constexpr (std::is_floating_point_v<Y>)\n+            if constexpr (is_floating_point<Y>)\n             {\n                 it->getMapped() += y;\n                 return it->getMapped();\n@@ -173,13 +173,13 @@ class AggregateFunctionSparkbar final\n \n         if (from_x >= to_x)\n         {\n-            size_t sz = updateFrame(values, 8);\n+            size_t sz = updateFrame(values, Y{8});\n             values.push_back('\\0');\n             offsets.push_back(offsets.empty() ? sz + 1 : offsets.back() + sz + 1);\n             return;\n         }\n \n-        PaddedPODArray<Y> histogram(width, 0);\n+        PaddedPODArray<Y> histogram(width, Y{0});\n         PaddedPODArray<UInt64> count_histogram(width, 0); /// The number of points in each bucket\n \n         for (const auto & point : data.points)\n@@ -197,7 +197,7 @@ class AggregateFunctionSparkbar final\n \n             Y res;\n             bool has_overfllow = false;\n-            if constexpr (std::is_floating_point_v<Y>)\n+            if constexpr (is_floating_point<Y>)\n                 res = histogram[index] + point.getMapped();\n             else\n                 has_overfllow = common::addOverflow(histogram[index], point.getMapped(), res);\n@@ -218,10 +218,10 @@ class AggregateFunctionSparkbar final\n         for (size_t i = 0; i < histogram.size(); ++i)\n         {\n             if (count_histogram[i] > 0)\n-                histogram[i] /= count_histogram[i];\n+                histogram[i] = histogram[i] / count_histogram[i];\n         }\n \n-        Y y_max = 0;\n+        Y y_max{};\n         for (auto & y : histogram)\n         {\n             if (isNaN(y) || y <= 0)\n@@ -245,8 +245,8 @@ class AggregateFunctionSparkbar final\n                 continue;\n             }\n \n-            constexpr auto levels_num = static_cast<Y>(BAR_LEVELS - 1);\n-            if constexpr (std::is_floating_point_v<Y>)\n+            constexpr auto levels_num = Y{BAR_LEVELS - 1};\n+            if constexpr (is_floating_point<Y>)\n             {\n                 y = y / (y_max / levels_num) + 1;\n             }\ndiff --git a/src/AggregateFunctions/AggregateFunctionSum.h b/src/AggregateFunctions/AggregateFunctionSum.h\nindex 2ce03c530c26..7c7fb6338a28 100644\n--- a/src/AggregateFunctions/AggregateFunctionSum.h\n+++ b/src/AggregateFunctions/AggregateFunctionSum.h\n@@ -69,7 +69,7 @@ struct AggregateFunctionSumData\n         size_t count = end - start;\n         const auto * end_ptr = ptr + count;\n \n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n         {\n             /// Compiler cannot unroll this loop, do it manually.\n             /// (at least for floats, most likely due to the lack of -fassociative-math)\n@@ -83,7 +83,7 @@ struct AggregateFunctionSumData\n             while (ptr < unrolled_end)\n             {\n                 for (size_t i = 0; i < unroll_count; ++i)\n-                    Impl::add(partial_sums[i], ptr[i]);\n+                    Impl::add(partial_sums[i], T(ptr[i]));\n                 ptr += unroll_count;\n             }\n \n@@ -95,7 +95,7 @@ struct AggregateFunctionSumData\n         T local_sum{};\n         while (ptr < end_ptr)\n         {\n-            Impl::add(local_sum, *ptr);\n+            Impl::add(local_sum, T(*ptr));\n             ++ptr;\n         }\n         Impl::add(sum, local_sum);\n@@ -193,12 +193,11 @@ struct AggregateFunctionSumData\n             Impl::add(sum, local_sum);\n             return;\n         }\n-        else if constexpr (std::is_floating_point_v<T>)\n+        else if constexpr (is_floating_point<T> && (sizeof(Value) == 4 || sizeof(Value) == 8))\n         {\n-            /// For floating point we use a similar trick as above, except that now we  reinterpret the floating point number as an unsigned\n+            /// For floating point we use a similar trick as above, except that now we reinterpret the floating point number as an unsigned\n             /// integer of the same size and use a mask instead (0 to discard, 0xFF..FF to keep)\n-            static_assert(sizeof(Value) == 4 || sizeof(Value) == 8);\n-            using equivalent_integer = typename std::conditional_t<sizeof(Value) == 4, UInt32, UInt64>;\n+            using EquivalentInteger = typename std::conditional_t<sizeof(Value) == 4, UInt32, UInt64>;\n \n             constexpr size_t unroll_count = 128 / sizeof(T);\n             T partial_sums[unroll_count]{};\n@@ -209,11 +208,11 @@ struct AggregateFunctionSumData\n             {\n                 for (size_t i = 0; i < unroll_count; ++i)\n                 {\n-                    equivalent_integer value;\n-                    std::memcpy(&value, &ptr[i], sizeof(Value));\n+                    EquivalentInteger value;\n+                    memcpy(&value, &ptr[i], sizeof(Value));\n                     value &= (!condition_map[i] != add_if_zero) - 1;\n                     Value d;\n-                    std::memcpy(&d, &value, sizeof(Value));\n+                    memcpy(&d, &value, sizeof(Value));\n                     Impl::add(partial_sums[i], d);\n                 }\n                 ptr += unroll_count;\n@@ -228,7 +227,7 @@ struct AggregateFunctionSumData\n         while (ptr < end_ptr)\n         {\n             if (!*condition_map == add_if_zero)\n-                Impl::add(local_sum, *ptr);\n+                Impl::add(local_sum, T(*ptr));\n             ++ptr;\n             ++condition_map;\n         }\n@@ -306,7 +305,7 @@ struct AggregateFunctionSumData\n template <typename T>\n struct AggregateFunctionSumKahanData\n {\n-    static_assert(std::is_floating_point_v<T>,\n+    static_assert(is_floating_point<T>,\n         \"It doesn't make sense to use Kahan Summation algorithm for non floating point types\");\n \n     T sum{};\n@@ -489,10 +488,7 @@ class AggregateFunctionSum final : public IAggregateFunctionDataHelper<Data, Agg\n     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override\n     {\n         const auto & column = assert_cast<const ColVecType &>(*columns[0]);\n-        if constexpr (is_big_int_v<T>)\n-            this->data(place).add(static_cast<TResult>(column.getData()[row_num]));\n-        else\n-            this->data(place).add(column.getData()[row_num]);\n+        this->data(place).add(static_cast<TResult>(column.getData()[row_num]));\n     }\n \n     void addBatchSinglePlace(\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniq.h b/src/AggregateFunctions/AggregateFunctionUniq.h\nindex 35d6e599e387..a094ed288d66 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniq.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniq.h\n@@ -257,7 +257,7 @@ template <typename T> struct AggregateFunctionUniqTraits\n {\n     static UInt64 hash(T x)\n     {\n-        if constexpr (std::is_same_v<T, Float32> || std::is_same_v<T, Float64>)\n+        if constexpr (is_floating_point<T>)\n         {\n             return bit_cast<UInt64>(x);\n         }\ndiff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.h b/src/AggregateFunctions/AggregateFunctionUniqCombined.h\nindex c6377a9532d9..4a91991ebb5d 100644\n--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.h\n+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.h\n@@ -111,7 +111,7 @@ class AggregateFunctionUniqCombined final\n                 /// Initially UInt128 was introduced only for UUID, and then the other big-integer types were added.\n                 hash = static_cast<HashValueType>(sipHash64(value));\n             }\n-            else if constexpr (std::is_floating_point_v<T>)\n+            else if constexpr (is_floating_point<T>)\n             {\n                 hash = static_cast<HashValueType>(intHash64(bit_cast<UInt64>(value)));\n             }\ndiff --git a/src/AggregateFunctions/QuantileTDigest.h b/src/AggregateFunctions/QuantileTDigest.h\nindex f915d6c70a3e..8117b2a7fe12 100644\n--- a/src/AggregateFunctions/QuantileTDigest.h\n+++ b/src/AggregateFunctions/QuantileTDigest.h\n@@ -391,7 +391,7 @@ class QuantileTDigest\n     ResultType getImpl(Float64 level)\n     {\n         if (centroids.empty())\n-            return std::is_floating_point_v<ResultType> ? std::numeric_limits<ResultType>::quiet_NaN() : 0;\n+            return is_floating_point<ResultType> ? std::numeric_limits<ResultType>::quiet_NaN() : 0;\n \n         compress();\n \ndiff --git a/src/AggregateFunctions/ReservoirSampler.h b/src/AggregateFunctions/ReservoirSampler.h\nindex 2668e0dc890b..870cb429fb7b 100644\n--- a/src/AggregateFunctions/ReservoirSampler.h\n+++ b/src/AggregateFunctions/ReservoirSampler.h\n@@ -276,6 +276,6 @@ class ReservoirSampler\n     {\n         if (OnEmpty == ReservoirSamplerOnEmpty::THROW)\n             throw DB::Exception(DB::ErrorCodes::LOGICAL_ERROR, \"Quantile of empty ReservoirSampler\");\n-        return NanLikeValueConstructor<ResultType, std::is_floating_point_v<ResultType>>::getValue();\n+        return NanLikeValueConstructor<ResultType, is_floating_point<ResultType>>::getValue();\n     }\n };\ndiff --git a/src/AggregateFunctions/ReservoirSamplerDeterministic.h b/src/AggregateFunctions/ReservoirSamplerDeterministic.h\nindex 0ad8e968358e..f35d1eb49af0 100644\n--- a/src/AggregateFunctions/ReservoirSamplerDeterministic.h\n+++ b/src/AggregateFunctions/ReservoirSamplerDeterministic.h\n@@ -271,7 +271,7 @@ class ReservoirSamplerDeterministic\n     {\n         if (OnEmpty == ReservoirSamplerDeterministicOnEmpty::THROW)\n             throw DB::Exception(DB::ErrorCodes::LOGICAL_ERROR, \"Quantile of empty ReservoirSamplerDeterministic\");\n-        return NanLikeValueConstructor<ResultType, std::is_floating_point_v<ResultType>>::getValue();\n+        return NanLikeValueConstructor<ResultType, is_floating_point<ResultType>>::getValue();\n     }\n };\n \ndiff --git a/src/Columns/ColumnArray.cpp b/src/Columns/ColumnArray.cpp\nindex 0c6d7c4e5c61..3f88ca93a97b 100644\n--- a/src/Columns/ColumnArray.cpp\n+++ b/src/Columns/ColumnArray.cpp\n@@ -662,6 +662,8 @@ ColumnPtr ColumnArray::filter(const Filter & filt, ssize_t result_size_hint) con\n         return filterNumber<Int128>(filt, result_size_hint);\n     if (typeid_cast<const ColumnInt256 *>(data.get()))\n         return filterNumber<Int256>(filt, result_size_hint);\n+    if (typeid_cast<const ColumnBFloat16 *>(data.get()))\n+        return filterNumber<BFloat16>(filt, result_size_hint);\n     if (typeid_cast<const ColumnFloat32 *>(data.get()))\n         return filterNumber<Float32>(filt, result_size_hint);\n     if (typeid_cast<const ColumnFloat64 *>(data.get()))\n@@ -1065,6 +1067,8 @@ ColumnPtr ColumnArray::replicate(const Offsets & replicate_offsets) const\n         return replicateNumber<Int128>(replicate_offsets);\n     if (typeid_cast<const ColumnInt256 *>(data.get()))\n         return replicateNumber<Int256>(replicate_offsets);\n+    if (typeid_cast<const ColumnBFloat16 *>(data.get()))\n+        return replicateNumber<BFloat16>(replicate_offsets);\n     if (typeid_cast<const ColumnFloat32 *>(data.get()))\n         return replicateNumber<Float32>(replicate_offsets);\n     if (typeid_cast<const ColumnFloat64 *>(data.get()))\ndiff --git a/src/Columns/ColumnUnique.cpp b/src/Columns/ColumnUnique.cpp\nindex 54f45204c00e..773edbfd5903 100644\n--- a/src/Columns/ColumnUnique.cpp\n+++ b/src/Columns/ColumnUnique.cpp\n@@ -16,6 +16,7 @@ template class ColumnUnique<ColumnInt128>;\n template class ColumnUnique<ColumnUInt128>;\n template class ColumnUnique<ColumnInt256>;\n template class ColumnUnique<ColumnUInt256>;\n+template class ColumnUnique<ColumnBFloat16>;\n template class ColumnUnique<ColumnFloat32>;\n template class ColumnUnique<ColumnFloat64>;\n template class ColumnUnique<ColumnString>;\ndiff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h\nindex ffa7c311e9ee..ce7bbf0766fa 100644\n--- a/src/Columns/ColumnUnique.h\n+++ b/src/Columns/ColumnUnique.h\n@@ -760,6 +760,7 @@ extern template class ColumnUnique<ColumnInt128>;\n extern template class ColumnUnique<ColumnUInt128>;\n extern template class ColumnUnique<ColumnInt256>;\n extern template class ColumnUnique<ColumnUInt256>;\n+extern template class ColumnUnique<ColumnBFloat16>;\n extern template class ColumnUnique<ColumnFloat32>;\n extern template class ColumnUnique<ColumnFloat64>;\n extern template class ColumnUnique<ColumnString>;\ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex dc4941988e94..84fc6ebc61de 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -118,9 +118,9 @@ struct ColumnVector<T>::less_stable\n         if (unlikely(parent.data[lhs] == parent.data[rhs]))\n             return lhs < rhs;\n \n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n         {\n-            if (unlikely(std::isnan(parent.data[lhs]) && std::isnan(parent.data[rhs])))\n+            if (unlikely(isNaN(parent.data[lhs]) && isNaN(parent.data[rhs])))\n             {\n                 return lhs < rhs;\n             }\n@@ -150,9 +150,9 @@ struct ColumnVector<T>::greater_stable\n         if (unlikely(parent.data[lhs] == parent.data[rhs]))\n             return lhs < rhs;\n \n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n         {\n-            if (unlikely(std::isnan(parent.data[lhs]) && std::isnan(parent.data[rhs])))\n+            if (unlikely(isNaN(parent.data[lhs]) && isNaN(parent.data[rhs])))\n             {\n                 return lhs < rhs;\n             }\n@@ -224,9 +224,9 @@ void ColumnVector<T>::getPermutation(IColumn::PermutationSortDirection direction\n \n     iota(res.data(), data_size, IColumn::Permutation::value_type(0));\n \n-    if constexpr (has_find_extreme_implementation<T> && !std::is_floating_point_v<T>)\n+    if constexpr (has_find_extreme_implementation<T> && !is_floating_point<T>)\n     {\n-        /// Disabled for:floating point\n+        /// Disabled for floating point:\n         /// * floating point: We don't deal with nan_direction_hint\n         /// * stability::Stable: We might return any value, not the first\n         if ((limit == 1) && (stability == IColumn::PermutationSortStability::Unstable))\n@@ -256,7 +256,7 @@ void ColumnVector<T>::getPermutation(IColumn::PermutationSortDirection direction\n             bool sort_is_stable = stability == IColumn::PermutationSortStability::Stable;\n \n             /// TODO: LSD RadixSort is currently not stable if direction is descending, or value is floating point\n-            bool use_radix_sort = (sort_is_stable && ascending && !std::is_floating_point_v<T>) || !sort_is_stable;\n+            bool use_radix_sort = (sort_is_stable && ascending && !is_floating_point<T>) || !sort_is_stable;\n \n             /// Thresholds on size. Lower threshold is arbitrary. Upper threshold is chosen by the type for histogram counters.\n             if (data_size >= 256 && data_size <= std::numeric_limits<UInt32>::max() && use_radix_sort)\n@@ -283,7 +283,7 @@ void ColumnVector<T>::getPermutation(IColumn::PermutationSortDirection direction\n \n                 /// Radix sort treats all NaNs to be greater than all numbers.\n                 /// If the user needs the opposite, we must move them accordingly.\n-                if (std::is_floating_point_v<T> && nan_direction_hint < 0)\n+                if (is_floating_point<T> && nan_direction_hint < 0)\n                 {\n                     size_t nans_to_move = 0;\n \n@@ -330,7 +330,7 @@ void ColumnVector<T>::updatePermutation(IColumn::PermutationSortDirection direct\n         if constexpr (is_arithmetic_v<T> && !is_big_int_v<T>)\n         {\n             /// TODO: LSD RadixSort is currently not stable if direction is descending, or value is floating point\n-            bool use_radix_sort = (sort_is_stable && ascending && !std::is_floating_point_v<T>) || !sort_is_stable;\n+            bool use_radix_sort = (sort_is_stable && ascending && !is_floating_point<T>) || !sort_is_stable;\n             size_t size = end - begin;\n \n             /// Thresholds on size. Lower threshold is arbitrary. Upper threshold is chosen by the type for histogram counters.\n@@ -353,7 +353,7 @@ void ColumnVector<T>::updatePermutation(IColumn::PermutationSortDirection direct\n \n                 /// Radix sort treats all NaNs to be greater than all numbers.\n                 /// If the user needs the opposite, we must move them accordingly.\n-                if (std::is_floating_point_v<T> && nan_direction_hint < 0)\n+                if (is_floating_point<T> && nan_direction_hint < 0)\n                 {\n                     size_t nans_to_move = 0;\n \n@@ -1005,6 +1005,7 @@ template class ColumnVector<Int32>;\n template class ColumnVector<Int64>;\n template class ColumnVector<Int128>;\n template class ColumnVector<Int256>;\n+template class ColumnVector<BFloat16>;\n template class ColumnVector<Float32>;\n template class ColumnVector<Float64>;\n template class ColumnVector<UUID>;\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex 8f81da863756..47840a90a0ed 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -481,6 +481,7 @@ extern template class ColumnVector<Int32>;\n extern template class ColumnVector<Int64>;\n extern template class ColumnVector<Int128>;\n extern template class ColumnVector<Int256>;\n+extern template class ColumnVector<BFloat16>;\n extern template class ColumnVector<Float32>;\n extern template class ColumnVector<Float64>;\n extern template class ColumnVector<UUID>;\ndiff --git a/src/Columns/ColumnsCommon.cpp b/src/Columns/ColumnsCommon.cpp\nindex 591c56a00bd4..3e0ead394868 100644\n--- a/src/Columns/ColumnsCommon.cpp\n+++ b/src/Columns/ColumnsCommon.cpp\n@@ -328,6 +328,7 @@ INSTANTIATE(Int32)\n INSTANTIATE(Int64)\n INSTANTIATE(Int128)\n INSTANTIATE(Int256)\n+INSTANTIATE(BFloat16)\n INSTANTIATE(Float32)\n INSTANTIATE(Float64)\n INSTANTIATE(Decimal32)\ndiff --git a/src/Columns/ColumnsNumber.h b/src/Columns/ColumnsNumber.h\nindex ae7eddb0b22b..2dce22690793 100644\n--- a/src/Columns/ColumnsNumber.h\n+++ b/src/Columns/ColumnsNumber.h\n@@ -23,6 +23,7 @@ using ColumnInt64 = ColumnVector<Int64>;\n using ColumnInt128 = ColumnVector<Int128>;\n using ColumnInt256 = ColumnVector<Int256>;\n \n+using ColumnBFloat16 = ColumnVector<BFloat16>;\n using ColumnFloat32 = ColumnVector<Float32>;\n using ColumnFloat64 = ColumnVector<Float64>;\n \ndiff --git a/src/Columns/IColumn.cpp b/src/Columns/IColumn.cpp\nindex c9a0514af4ef..4a3886dddb66 100644\n--- a/src/Columns/IColumn.cpp\n+++ b/src/Columns/IColumn.cpp\n@@ -443,6 +443,7 @@ template class IColumnHelper<ColumnVector<Int32>, ColumnFixedSizeHelper>;\n template class IColumnHelper<ColumnVector<Int64>, ColumnFixedSizeHelper>;\n template class IColumnHelper<ColumnVector<Int128>, ColumnFixedSizeHelper>;\n template class IColumnHelper<ColumnVector<Int256>, ColumnFixedSizeHelper>;\n+template class IColumnHelper<ColumnVector<BFloat16>, ColumnFixedSizeHelper>;\n template class IColumnHelper<ColumnVector<Float32>, ColumnFixedSizeHelper>;\n template class IColumnHelper<ColumnVector<Float64>, ColumnFixedSizeHelper>;\n template class IColumnHelper<ColumnVector<UUID>, ColumnFixedSizeHelper>;\ndiff --git a/src/Columns/MaskOperations.cpp b/src/Columns/MaskOperations.cpp\nindex 873a40608725..eac424005170 100644\n--- a/src/Columns/MaskOperations.cpp\n+++ b/src/Columns/MaskOperations.cpp\n@@ -63,6 +63,7 @@ INSTANTIATE(Int32)\n INSTANTIATE(Int64)\n INSTANTIATE(Int128)\n INSTANTIATE(Int256)\n+INSTANTIATE(BFloat16)\n INSTANTIATE(Float32)\n INSTANTIATE(Float64)\n INSTANTIATE(Decimal32)\n@@ -200,6 +201,7 @@ static MaskInfo extractMaskImpl(\n           || extractMaskNumeric<inverted, Int16>(mask, column, null_value, null_bytemap, nulls, mask_info)\n           || extractMaskNumeric<inverted, Int32>(mask, column, null_value, null_bytemap, nulls, mask_info)\n           || extractMaskNumeric<inverted, Int64>(mask, column, null_value, null_bytemap, nulls, mask_info)\n+          || extractMaskNumeric<inverted, BFloat16>(mask, column, null_value, null_bytemap, nulls, mask_info)\n           || extractMaskNumeric<inverted, Float32>(mask, column, null_value, null_bytemap, nulls, mask_info)\n           || extractMaskNumeric<inverted, Float64>(mask, column, null_value, null_bytemap, nulls, mask_info)))\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Cannot convert column {} to mask.\", column->getName());\ndiff --git a/src/Common/CPUID.h b/src/Common/CPUID.h\nindex b49f77069040..b5c26e64d1e6 100644\n--- a/src/Common/CPUID.h\n+++ b/src/Common/CPUID.h\n@@ -266,6 +266,11 @@ inline bool haveAVX512VBMI2() noexcept\n     return haveAVX512F() && ((CPUInfo(0x7, 0).registers.ecx >> 6) & 1u);\n }\n \n+inline bool haveAVX512BF16() noexcept\n+{\n+    return haveAVX512F() && ((CPUInfo(0x7, 1).registers.eax >> 5) & 1u);\n+}\n+\n inline bool haveRDRAND() noexcept\n {\n     return CPUInfo(0x0).registers.eax >= 0x7 && ((CPUInfo(0x1).registers.ecx >> 30) & 1u);\n@@ -326,6 +331,7 @@ inline bool haveAMXINT8() noexcept\n     OP(AVX512VL)             \\\n     OP(AVX512VBMI)           \\\n     OP(AVX512VBMI2)          \\\n+    OP(AVX512BF16)           \\\n     OP(PREFETCHWT1)          \\\n     OP(SHA)                  \\\n     OP(ADX)                  \\\ndiff --git a/src/Common/FieldVisitorConvertToNumber.cpp b/src/Common/FieldVisitorConvertToNumber.cpp\nindex 75b3fbfe02ac..a5963e3d028a 100644\n--- a/src/Common/FieldVisitorConvertToNumber.cpp\n+++ b/src/Common/FieldVisitorConvertToNumber.cpp\n@@ -1,5 +1,4 @@\n #include <Common/FieldVisitorConvertToNumber.h>\n-#include \"base/Decimal.h\"\n \n namespace DB\n {\n@@ -17,6 +16,7 @@ template class FieldVisitorConvertToNumber<Int128>;\n template class FieldVisitorConvertToNumber<UInt128>;\n template class FieldVisitorConvertToNumber<Int256>;\n template class FieldVisitorConvertToNumber<UInt256>;\n+//template class FieldVisitorConvertToNumber<BFloat16>;\n template class FieldVisitorConvertToNumber<Float32>;\n template class FieldVisitorConvertToNumber<Float64>;\n \ndiff --git a/src/Common/FieldVisitorConvertToNumber.h b/src/Common/FieldVisitorConvertToNumber.h\nindex 4c3424e0e186..38d5dc473c49 100644\n--- a/src/Common/FieldVisitorConvertToNumber.h\n+++ b/src/Common/FieldVisitorConvertToNumber.h\n@@ -58,7 +58,7 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n \n     T operator() (const Float64 & x) const\n     {\n-        if constexpr (!std::is_floating_point_v<T>)\n+        if constexpr (!is_floating_point<T>)\n         {\n             if (!isFinite(x))\n             {\n@@ -88,7 +88,7 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n     template <typename U>\n     T operator() (const DecimalField<U> & x) const\n     {\n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n             return x.getValue().template convertTo<T>() / x.getScaleMultiplier().template convertTo<T>();\n         else\n             return (x.getValue() / x.getScaleMultiplier()).template convertTo<T>();\n@@ -129,6 +129,7 @@ extern template class FieldVisitorConvertToNumber<Int128>;\n extern template class FieldVisitorConvertToNumber<UInt128>;\n extern template class FieldVisitorConvertToNumber<Int256>;\n extern template class FieldVisitorConvertToNumber<UInt256>;\n+//extern template class FieldVisitorConvertToNumber<BFloat16>;\n extern template class FieldVisitorConvertToNumber<Float32>;\n extern template class FieldVisitorConvertToNumber<Float64>;\n \ndiff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h\nindex fb6afcde1332..b4bc6af1cef9 100644\n--- a/src/Common/HashTable/Hash.h\n+++ b/src/Common/HashTable/Hash.h\n@@ -322,6 +322,7 @@ DEFINE_HASH(Int32)\n DEFINE_HASH(Int64)\n DEFINE_HASH(Int128)\n DEFINE_HASH(Int256)\n+DEFINE_HASH(BFloat16)\n DEFINE_HASH(Float32)\n DEFINE_HASH(Float64)\n DEFINE_HASH(DB::UUID)\ndiff --git a/src/Common/HashTable/HashTable.h b/src/Common/HashTable/HashTable.h\nindex d379c3f6a873..fb34ab7d4f91 100644\n--- a/src/Common/HashTable/HashTable.h\n+++ b/src/Common/HashTable/HashTable.h\n@@ -76,7 +76,7 @@ struct HashTableNoState\n template <typename T>\n inline bool bitEquals(T a, T b)\n {\n-    if constexpr (std::is_floating_point_v<T>)\n+    if constexpr (is_floating_point<T>)\n         /// Note that memcmp with constant size is a compiler builtin.\n         return 0 == memcmp(&a, &b, sizeof(T)); /// NOLINT\n     else\ndiff --git a/src/Common/NaNUtils.h b/src/Common/NaNUtils.h\nindex 2ff3e2f56618..3b99084549f9 100644\n--- a/src/Common/NaNUtils.h\n+++ b/src/Common/NaNUtils.h\n@@ -3,24 +3,24 @@\n #include <cmath>\n #include <limits>\n #include <type_traits>\n+#include <base/DecomposedFloat.h>\n \n \n template <typename T>\n inline bool isNaN(T x)\n {\n     /// To be sure, that this function is zero-cost for non-floating point types.\n-    if constexpr (std::is_floating_point_v<T>)\n-        return std::isnan(x);\n+    if constexpr (is_floating_point<T>)\n+        return DecomposedFloat(x).isNaN();\n     else\n         return false;\n }\n \n-\n template <typename T>\n inline bool isFinite(T x)\n {\n-    if constexpr (std::is_floating_point_v<T>)\n-        return std::isfinite(x);\n+    if constexpr (is_floating_point<T>)\n+        return DecomposedFloat(x).isFinite();\n     else\n         return true;\n }\n@@ -28,7 +28,7 @@ inline bool isFinite(T x)\n template <typename T>\n bool canConvertTo(Float64 x)\n {\n-    if constexpr (std::is_floating_point_v<T>)\n+    if constexpr (is_floating_point<T>)\n         return true;\n     if (!isFinite(x))\n         return false;\n@@ -46,3 +46,12 @@ T NaNOrZero()\n     else\n         return {};\n }\n+\n+template <typename T>\n+bool signBit(T x)\n+{\n+    if constexpr (is_floating_point<T>)\n+        return DecomposedFloat(x).isNegative();\n+    else\n+        return x < 0;\n+}\ndiff --git a/src/Common/TargetSpecific.cpp b/src/Common/TargetSpecific.cpp\nindex 8540c9a99866..4400d9a60b36 100644\n--- a/src/Common/TargetSpecific.cpp\n+++ b/src/Common/TargetSpecific.cpp\n@@ -23,6 +23,8 @@ UInt32 getSupportedArchs()\n         result |= static_cast<UInt32>(TargetArch::AVX512VBMI);\n     if (CPU::CPUFlagsCache::have_AVX512VBMI2)\n         result |= static_cast<UInt32>(TargetArch::AVX512VBMI2);\n+    if (CPU::CPUFlagsCache::have_AVX512BF16)\n+        result |= static_cast<UInt32>(TargetArch::AVX512BF16);\n     if (CPU::CPUFlagsCache::have_AMXBF16)\n         result |= static_cast<UInt32>(TargetArch::AMXBF16);\n     if (CPU::CPUFlagsCache::have_AMXTILE)\n@@ -50,6 +52,7 @@ String toString(TargetArch arch)\n         case TargetArch::AVX512BW:    return \"avx512bw\";\n         case TargetArch::AVX512VBMI:  return \"avx512vbmi\";\n         case TargetArch::AVX512VBMI2: return \"avx512vbmi2\";\n+        case TargetArch::AVX512BF16:  return \"avx512bf16\";\n         case TargetArch::AMXBF16: return \"amxbf16\";\n         case TargetArch::AMXTILE: return \"amxtile\";\n         case TargetArch::AMXINT8: return \"amxint8\";\ndiff --git a/src/Common/TargetSpecific.h b/src/Common/TargetSpecific.h\nindex f9523f667b23..5584bd1f63ae 100644\n--- a/src/Common/TargetSpecific.h\n+++ b/src/Common/TargetSpecific.h\n@@ -83,9 +83,10 @@ enum class TargetArch : UInt32\n     AVX512BW    = (1 << 4),\n     AVX512VBMI  = (1 << 5),\n     AVX512VBMI2 = (1 << 6),\n-    AMXBF16 = (1 << 7),\n-    AMXTILE = (1 << 8),\n-    AMXINT8 = (1 << 9),\n+    AVX512BF16 = (1 << 7),\n+    AMXBF16 = (1 << 8),\n+    AMXTILE = (1 << 9),\n+    AMXINT8 = (1 << 10),\n };\n \n /// Runtime detection.\n@@ -102,6 +103,7 @@ String toString(TargetArch arch);\n /// NOLINTNEXTLINE\n #define USE_MULTITARGET_CODE 1\n \n+#define AVX512BF16_FUNCTION_SPECIFIC_ATTRIBUTE __attribute__((target(\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,avx512bw,avx512vl,avx512vbmi,avx512vbmi2,avx512bf16\")))\n #define AVX512VBMI2_FUNCTION_SPECIFIC_ATTRIBUTE __attribute__((target(\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,avx512bw,avx512vl,avx512vbmi,avx512vbmi2\")))\n #define AVX512VBMI_FUNCTION_SPECIFIC_ATTRIBUTE __attribute__((target(\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,avx512bw,avx512vl,avx512vbmi\")))\n #define AVX512BW_FUNCTION_SPECIFIC_ATTRIBUTE __attribute__((target(\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,avx512bw\")))\n@@ -111,6 +113,8 @@ String toString(TargetArch arch);\n #define SSE42_FUNCTION_SPECIFIC_ATTRIBUTE __attribute__((target(\"sse,sse2,sse3,ssse3,sse4,popcnt\")))\n #define DEFAULT_FUNCTION_SPECIFIC_ATTRIBUTE\n \n+#   define BEGIN_AVX512BF16_SPECIFIC_CODE \\\n+        _Pragma(\"clang attribute push(__attribute__((target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,avx512bw,avx512vl,avx512vbmi,avx512vbmi2,avx512bf16\\\"))),apply_to=function)\")\n #   define BEGIN_AVX512VBMI2_SPECIFIC_CODE \\\n         _Pragma(\"clang attribute push(__attribute__((target(\\\"sse,sse2,sse3,ssse3,sse4,popcnt,avx,avx2,avx512f,avx512bw,avx512vl,avx512vbmi,avx512vbmi2\\\"))),apply_to=function)\")\n #   define BEGIN_AVX512VBMI_SPECIFIC_CODE \\\n@@ -197,6 +201,14 @@ namespace TargetSpecific::AVX512VBMI2 { \\\n } \\\n END_TARGET_SPECIFIC_CODE\n \n+#define DECLARE_AVX512BF16_SPECIFIC_CODE(...) \\\n+BEGIN_AVX512BF16_SPECIFIC_CODE \\\n+namespace TargetSpecific::AVX512BF16 { \\\n+    DUMMY_FUNCTION_DEFINITION \\\n+    using namespace DB::TargetSpecific::AVX512BF16; \\\n+    __VA_ARGS__ \\\n+} \\\n+END_TARGET_SPECIFIC_CODE\n \n #else\n \n@@ -211,6 +223,7 @@ END_TARGET_SPECIFIC_CODE\n #define DECLARE_AVX512BW_SPECIFIC_CODE(...)\n #define DECLARE_AVX512VBMI_SPECIFIC_CODE(...)\n #define DECLARE_AVX512VBMI2_SPECIFIC_CODE(...)\n+#define DECLARE_AVX512BF16_SPECIFIC_CODE(...)\n \n #endif\n \n@@ -229,7 +242,8 @@ DECLARE_AVX2_SPECIFIC_CODE   (__VA_ARGS__) \\\n DECLARE_AVX512F_SPECIFIC_CODE(__VA_ARGS__) \\\n DECLARE_AVX512BW_SPECIFIC_CODE    (__VA_ARGS__) \\\n DECLARE_AVX512VBMI_SPECIFIC_CODE  (__VA_ARGS__) \\\n-DECLARE_AVX512VBMI2_SPECIFIC_CODE (__VA_ARGS__)\n+DECLARE_AVX512VBMI2_SPECIFIC_CODE (__VA_ARGS__) \\\n+DECLARE_AVX512BF16_SPECIFIC_CODE (__VA_ARGS__)\n \n DECLARE_DEFAULT_CODE(\n     constexpr auto BuildArch = TargetArch::Default; /// NOLINT\n@@ -263,6 +277,10 @@ DECLARE_AVX512VBMI2_SPECIFIC_CODE(\n     constexpr auto BuildArch = TargetArch::AVX512VBMI2; /// NOLINT\n ) // DECLARE_AVX512VBMI2_SPECIFIC_CODE\n \n+DECLARE_AVX512BF16_SPECIFIC_CODE(\n+    constexpr auto BuildArch = TargetArch::AVX512BF16; /// NOLINT\n+) // DECLARE_AVX512BF16_SPECIFIC_CODE\n+\n /** Runtime Dispatch helpers for class members.\n   *\n   * Example of usage:\ndiff --git a/src/Common/findExtreme.cpp b/src/Common/findExtreme.cpp\nindex ce3bbb86d7c9..a29750b848a4 100644\n--- a/src/Common/findExtreme.cpp\n+++ b/src/Common/findExtreme.cpp\n@@ -47,7 +47,7 @@ MULTITARGET_FUNCTION_AVX2_SSE42(\n \n         /// Unroll the loop manually for floating point, since the compiler doesn't do it without fastmath\n         /// as it might change the return value\n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n         {\n             constexpr size_t unroll_block = 512 / sizeof(T); /// Chosen via benchmarks with AVX2 so YMMV\n             size_t unrolled_end = i + (((count - i) / unroll_block) * unroll_block);\ndiff --git a/src/Common/transformEndianness.h b/src/Common/transformEndianness.h\nindex 1657305acda1..e6e04ec75afc 100644\n--- a/src/Common/transformEndianness.h\n+++ b/src/Common/transformEndianness.h\n@@ -38,7 +38,7 @@ inline void transformEndianness(T & x)\n }\n \n template <std::endian ToEndian, std::endian FromEndian = std::endian::native, typename T>\n-requires std::is_floating_point_v<T>\n+requires is_floating_point<T>\n inline void transformEndianness(T & value)\n {\n     if constexpr (ToEndian != FromEndian)\ndiff --git a/src/Core/AccurateComparison.h b/src/Core/AccurateComparison.h\nindex 139ee4d88dcd..87ff14e40e7e 100644\n--- a/src/Core/AccurateComparison.h\n+++ b/src/Core/AccurateComparison.h\n@@ -25,7 +25,7 @@ bool lessOp(A a, B b)\n         return a < b;\n \n     /// float vs float\n-    if constexpr (std::is_floating_point_v<A> && std::is_floating_point_v<B>)\n+    if constexpr (is_floating_point<A> && is_floating_point<B>)\n         return a < b;\n \n     /// anything vs NaN\n@@ -49,7 +49,7 @@ bool lessOp(A a, B b)\n     }\n \n     /// int vs float\n-    if constexpr (is_integer<A> && std::is_floating_point_v<B>)\n+    if constexpr (is_integer<A> && is_floating_point<B>)\n     {\n         if constexpr (sizeof(A) <= 4)\n             return static_cast<double>(a) < static_cast<double>(b);\n@@ -57,7 +57,7 @@ bool lessOp(A a, B b)\n         return DecomposedFloat<B>(b).greater(a);\n     }\n \n-    if constexpr (std::is_floating_point_v<A> && is_integer<B>)\n+    if constexpr (is_floating_point<A> && is_integer<B>)\n     {\n         if constexpr (sizeof(B) <= 4)\n             return static_cast<double>(a) < static_cast<double>(b);\n@@ -65,8 +65,8 @@ bool lessOp(A a, B b)\n         return DecomposedFloat<A>(a).less(b);\n     }\n \n-    static_assert(is_integer<A> || std::is_floating_point_v<A>);\n-    static_assert(is_integer<B> || std::is_floating_point_v<B>);\n+    static_assert(is_integer<A> || is_floating_point<A>);\n+    static_assert(is_integer<B> || is_floating_point<B>);\n     UNREACHABLE();\n }\n \n@@ -101,7 +101,7 @@ bool equalsOp(A a, B b)\n         return a == b;\n \n     /// float vs float\n-    if constexpr (std::is_floating_point_v<A> && std::is_floating_point_v<B>)\n+    if constexpr (is_floating_point<A> && is_floating_point<B>)\n         return a == b;\n \n     /// anything vs NaN\n@@ -125,7 +125,7 @@ bool equalsOp(A a, B b)\n     }\n \n     /// int vs float\n-    if constexpr (is_integer<A> && std::is_floating_point_v<B>)\n+    if constexpr (is_integer<A> && is_floating_point<B>)\n     {\n         if constexpr (sizeof(A) <= 4)\n             return static_cast<double>(a) == static_cast<double>(b);\n@@ -133,7 +133,7 @@ bool equalsOp(A a, B b)\n         return DecomposedFloat<B>(b).equals(a);\n     }\n \n-    if constexpr (std::is_floating_point_v<A> && is_integer<B>)\n+    if constexpr (is_floating_point<A> && is_integer<B>)\n     {\n         if constexpr (sizeof(B) <= 4)\n             return static_cast<double>(a) == static_cast<double>(b);\n@@ -163,7 +163,7 @@ inline bool NO_SANITIZE_UNDEFINED convertNumeric(From value, To & result)\n         return true;\n     }\n \n-    if constexpr (std::is_floating_point_v<From> && std::is_floating_point_v<To>)\n+    if constexpr (is_floating_point<From> && is_floating_point<To>)\n     {\n         /// Note that NaNs doesn't compare equal to anything, but they are still in range of any Float type.\n         if (isNaN(value))\ndiff --git a/src/Core/DecimalFunctions.h b/src/Core/DecimalFunctions.h\nindex 8dad00c3a1e0..abd660a8a7f9 100644\n--- a/src/Core/DecimalFunctions.h\n+++ b/src/Core/DecimalFunctions.h\n@@ -17,6 +17,7 @@ class DataTypeNumber;\n \n namespace ErrorCodes\n {\n+    extern const int NOT_IMPLEMENTED;\n     extern const int DECIMAL_OVERFLOW;\n     extern const int ARGUMENT_OUT_OF_BOUND;\n }\n@@ -310,7 +311,14 @@ ReturnType convertToImpl(const DecimalType & decimal, UInt32 scale, To & result)\n     using DecimalNativeType = typename DecimalType::NativeType;\n     static constexpr bool throw_exception = std::is_void_v<ReturnType>;\n \n-    if constexpr (std::is_floating_point_v<To>)\n+    if constexpr (std::is_same_v<To, BFloat16>)\n+    {\n+        if constexpr (throw_exception)\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Conversion from Decimal to BFloat16 is not implemented\");\n+        else\n+            return ReturnType(false);\n+    }\n+    else if constexpr (is_floating_point<To>)\n     {\n         result = static_cast<To>(decimal.value) / static_cast<To>(scaleMultiplier<DecimalNativeType>(scale));\n     }\ndiff --git a/src/Core/Field.h b/src/Core/Field.h\nindex 7b916d306462..c08d5c9eb429 100644\n--- a/src/Core/Field.h\n+++ b/src/Core/Field.h\n@@ -257,6 +257,7 @@ template <> struct NearestFieldTypeImpl<DecimalField<Decimal64>> { using Type =\n template <> struct NearestFieldTypeImpl<DecimalField<Decimal128>> { using Type = DecimalField<Decimal128>; };\n template <> struct NearestFieldTypeImpl<DecimalField<Decimal256>> { using Type = DecimalField<Decimal256>; };\n template <> struct NearestFieldTypeImpl<DecimalField<DateTime64>> { using Type = DecimalField<DateTime64>; };\n+template <> struct NearestFieldTypeImpl<BFloat16> { using Type = Float64; };\n template <> struct NearestFieldTypeImpl<Float32> { using Type = Float64; };\n template <> struct NearestFieldTypeImpl<Float64> { using Type = Float64; };\n template <> struct NearestFieldTypeImpl<const char *> { using Type = String; };\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex bdfec563397d..fd418a4b97a1 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -5742,7 +5742,10 @@ Enable experimental functions for natural language processing.\n Enable experimental hash functions\n )\", EXPERIMENTAL) \\\n     DECLARE(Bool, allow_experimental_object_type, false, R\"(\n-Allow Object and JSON data types\n+Allow the obsolete Object data type\n+)\", EXPERIMENTAL) \\\n+    DECLARE(Bool, allow_experimental_bfloat16_type, false, R\"(\n+Allow BFloat16 data type (under development).\n )\", EXPERIMENTAL) \\\n     DECLARE(Bool, allow_experimental_time_series_table, false, R\"(\n Allows creation of tables with the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine.\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex f4a8fd198c5f..455858fe241e 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -78,6 +78,7 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory\n             {\"backup_restore_keeper_max_retries_while_handling_error\", 0, 20, \"New setting.\"},\n             {\"backup_restore_finish_timeout_after_error_sec\", 0, 180, \"New setting.\"},\n             {\"parallel_replicas_local_plan\", false, true, \"Use local plan for local replica in a query with parallel replicas\"},\n+            {\"allow_experimental_bfloat16_type\", false, false, \"Add new experimental BFloat16 type\"},\n             {\"filesystem_cache_skip_download_if_exceeds_per_query_cache_write_limit\", 1, 1, \"Rename of setting skip_download_if_exceeds_query_cache_limit\"},\n             {\"filesystem_cache_prefer_bigger_buffer_size\", true, true, \"New setting\"},\n             {\"read_in_order_use_virtual_row\", false, false, \"Use virtual row while reading in order of primary key or its monotonic function fashion. It is useful when searching over multiple parts as only relevant ones are touched.\"},\ndiff --git a/src/Core/SortCursor.h b/src/Core/SortCursor.h\nindex 6eb009fa2599..3acabaae44e9 100644\n--- a/src/Core/SortCursor.h\n+++ b/src/Core/SortCursor.h\n@@ -726,6 +726,7 @@ class SortQueueVariants\n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<Int128>>, strategy>,\n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<Int256>>, strategy>,\n \n+        SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<BFloat16>>, strategy>,\n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<Float32>>, strategy>,\n         SortingQueueImpl<SpecializedSingleColumnSortCursor<ColumnVector<Float64>>, strategy>,\n \ndiff --git a/src/Core/TypeId.h b/src/Core/TypeId.h\nindex 1eba944e63ef..f8991a08d3ca 100644\n--- a/src/Core/TypeId.h\n+++ b/src/Core/TypeId.h\n@@ -21,6 +21,7 @@ enum class TypeIndex : uint8_t\n     Int64,\n     Int128,\n     Int256,\n+    BFloat16,\n     Float32,\n     Float64,\n     Date,\n@@ -94,6 +95,7 @@ TYPEID_MAP(Int32)\n TYPEID_MAP(Int64)\n TYPEID_MAP(Int128)\n TYPEID_MAP(Int256)\n+TYPEID_MAP(BFloat16)\n TYPEID_MAP(Float32)\n TYPEID_MAP(Float64)\n TYPEID_MAP(UUID)\ndiff --git a/src/Core/Types_fwd.h b/src/Core/Types_fwd.h\nindex d3b1d168edfb..b94a29ce72ce 100644\n--- a/src/Core/Types_fwd.h\n+++ b/src/Core/Types_fwd.h\n@@ -21,6 +21,7 @@ using Int128 = wide::integer<128, signed>;\n using UInt128 = wide::integer<128, unsigned>;\n using Int256 = wide::integer<256, signed>;\n using UInt256 = wide::integer<256, unsigned>;\n+class BFloat16;\n \n namespace DB\n {\ndiff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h\nindex ae5afce36be8..0c8f2201b0d2 100644\n--- a/src/Core/callOnTypeIndex.h\n+++ b/src/Core/callOnTypeIndex.h\n@@ -63,6 +63,7 @@ static bool callOnBasicType(TypeIndex number, F && f)\n     {\n         switch (number)\n         {\n+            case TypeIndex::BFloat16:     return f(TypePair<T, BFloat16>());\n             case TypeIndex::Float32:      return f(TypePair<T, Float32>());\n             case TypeIndex::Float64:      return f(TypePair<T, Float64>());\n             default:\n@@ -133,6 +134,7 @@ static inline bool callOnBasicTypes(TypeIndex type_num1, TypeIndex type_num2, F\n     {\n         switch (type_num1)\n         {\n+            case TypeIndex::BFloat16: return callOnBasicType<BFloat16, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             case TypeIndex::Float32: return callOnBasicType<Float32, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             case TypeIndex::Float64: return callOnBasicType<Float64, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));\n             default:\n@@ -190,6 +192,7 @@ static bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... ar\n         case TypeIndex::Int128:         return f(TypePair<DataTypeNumber<Int128>, T>(), std::forward<ExtraArgs>(args)...);\n         case TypeIndex::Int256:         return f(TypePair<DataTypeNumber<Int256>, T>(), std::forward<ExtraArgs>(args)...);\n \n+        case TypeIndex::BFloat16:        return f(TypePair<DataTypeNumber<BFloat16>, T>(), std::forward<ExtraArgs>(args)...);\n         case TypeIndex::Float32:        return f(TypePair<DataTypeNumber<Float32>, T>(), std::forward<ExtraArgs>(args)...);\n         case TypeIndex::Float64:        return f(TypePair<DataTypeNumber<Float64>, T>(), std::forward<ExtraArgs>(args)...);\n \ndiff --git a/src/DataTypes/DataTypeNumberBase.cpp b/src/DataTypes/DataTypeNumberBase.cpp\nindex be448fe14917..636d557f4d09 100644\n--- a/src/DataTypes/DataTypeNumberBase.cpp\n+++ b/src/DataTypes/DataTypeNumberBase.cpp\n@@ -42,6 +42,7 @@ template class DataTypeNumberBase<Int32>;\n template class DataTypeNumberBase<Int64>;\n template class DataTypeNumberBase<Int128>;\n template class DataTypeNumberBase<Int256>;\n+template class DataTypeNumberBase<BFloat16>;\n template class DataTypeNumberBase<Float32>;\n template class DataTypeNumberBase<Float64>;\n \ndiff --git a/src/DataTypes/DataTypeNumberBase.h b/src/DataTypes/DataTypeNumberBase.h\nindex 3a5b11c51246..11b9427a14df 100644\n--- a/src/DataTypes/DataTypeNumberBase.h\n+++ b/src/DataTypes/DataTypeNumberBase.h\n@@ -68,6 +68,7 @@ extern template class DataTypeNumberBase<Int32>;\n extern template class DataTypeNumberBase<Int64>;\n extern template class DataTypeNumberBase<Int128>;\n extern template class DataTypeNumberBase<Int256>;\n+extern template class DataTypeNumberBase<BFloat16>;\n extern template class DataTypeNumberBase<Float32>;\n extern template class DataTypeNumberBase<Float64>;\n \ndiff --git a/src/DataTypes/DataTypesBinaryEncoding.cpp b/src/DataTypes/DataTypesBinaryEncoding.cpp\nindex dc0f2f3f5aa1..c3190b462c3b 100644\n--- a/src/DataTypes/DataTypesBinaryEncoding.cpp\n+++ b/src/DataTypes/DataTypesBinaryEncoding.cpp\n@@ -96,6 +96,7 @@ enum class BinaryTypeIndex : uint8_t\n     SimpleAggregateFunction = 0x2E,\n     Nested = 0x2F,\n     JSON = 0x30,\n+    BFloat16 = 0x31,\n };\n \n /// In future we can introduce more arguments in the JSON data type definition.\n@@ -151,6 +152,8 @@ BinaryTypeIndex getBinaryTypeIndex(const DataTypePtr & type)\n             return BinaryTypeIndex::Int128;\n         case TypeIndex::Int256:\n             return BinaryTypeIndex::Int256;\n+        case TypeIndex::BFloat16:\n+            return BinaryTypeIndex::BFloat16;\n         case TypeIndex::Float32:\n             return BinaryTypeIndex::Float32;\n         case TypeIndex::Float64:\n@@ -565,6 +568,8 @@ DataTypePtr decodeDataType(ReadBuffer & buf)\n             return std::make_shared<DataTypeInt128>();\n         case BinaryTypeIndex::Int256:\n             return std::make_shared<DataTypeInt256>();\n+        case BinaryTypeIndex::BFloat16:\n+            return std::make_shared<DataTypeBFloat16>();\n         case BinaryTypeIndex::Float32:\n             return std::make_shared<DataTypeFloat32>();\n         case BinaryTypeIndex::Float64:\ndiff --git a/src/DataTypes/DataTypesDecimal.cpp b/src/DataTypes/DataTypesDecimal.cpp\nindex 038a00932ee9..63bd4bf2a598 100644\n--- a/src/DataTypes/DataTypesDecimal.cpp\n+++ b/src/DataTypes/DataTypesDecimal.cpp\n@@ -2,6 +2,7 @@\n #include <DataTypes/Serializations/SerializationDecimal.h>\n \n #include <Common/typeid_cast.h>\n+#include <Common/NaNUtils.h>\n #include <Core/DecimalFunctions.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <IO/ReadHelpers.h>\n@@ -19,6 +20,7 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int DECIMAL_OVERFLOW;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n \n@@ -268,9 +270,13 @@ ReturnType convertToDecimalImpl(const typename FromDataType::FieldType & value,\n \n     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n \n-    if constexpr (std::is_floating_point_v<FromFieldType>)\n+    if constexpr (std::is_same_v<typename FromDataType::FieldType, BFloat16>)\n     {\n-        if (!std::isfinite(value))\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Conversion from BFloat16 to Decimal is not implemented\");\n+    }\n+    else if constexpr (is_floating_point<FromFieldType>)\n+    {\n+        if (!isFinite(value))\n         {\n             if constexpr (throw_exception)\n                 throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"{} convert overflow. Cannot convert infinity or NaN to decimal\", ToDataType::family_name);\ndiff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h\nindex badefc4c75a7..09a25617506d 100644\n--- a/src/DataTypes/DataTypesDecimal.h\n+++ b/src/DataTypes/DataTypesDecimal.h\n@@ -4,7 +4,6 @@\n #include <base/extended_types.h>\n #include <Common/typeid_cast.h>\n #include <base/Decimal.h>\n-#include <base/Decimal_fwd.h>\n #include <DataTypes/IDataType.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDate32.h>\n@@ -205,7 +204,6 @@ FOR_EACH_DECIMAL_TYPE(INVOKE);\n #undef INVOKE\n #undef DISPATCH\n \n-\n template <typename FromDataType, typename ToDataType>\n requires (is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>)\n typename ToDataType::FieldType convertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale);\ndiff --git a/src/DataTypes/DataTypesNumber.cpp b/src/DataTypes/DataTypesNumber.cpp\nindex 72020b0a5aa6..4c8918521fe5 100644\n--- a/src/DataTypes/DataTypesNumber.cpp\n+++ b/src/DataTypes/DataTypesNumber.cpp\n@@ -54,6 +54,7 @@ void registerDataTypeNumbers(DataTypeFactory & factory)\n     factory.registerDataType(\"Int32\", createNumericDataType<Int32>);\n     factory.registerDataType(\"Int64\", createNumericDataType<Int64>);\n \n+    factory.registerDataType(\"BFloat16\", createNumericDataType<BFloat16>);\n     factory.registerDataType(\"Float32\", createNumericDataType<Float32>);\n     factory.registerDataType(\"Float64\", createNumericDataType<Float64>);\n \n@@ -111,6 +112,7 @@ template class DataTypeNumber<Int8>;\n template class DataTypeNumber<Int16>;\n template class DataTypeNumber<Int32>;\n template class DataTypeNumber<Int64>;\n+template class DataTypeNumber<BFloat16>;\n template class DataTypeNumber<Float32>;\n template class DataTypeNumber<Float64>;\n \ndiff --git a/src/DataTypes/DataTypesNumber.h b/src/DataTypes/DataTypesNumber.h\nindex d550ceababca..a9e77e01b13d 100644\n--- a/src/DataTypes/DataTypesNumber.h\n+++ b/src/DataTypes/DataTypesNumber.h\n@@ -63,6 +63,7 @@ extern template class DataTypeNumber<Int8>;\n extern template class DataTypeNumber<Int16>;\n extern template class DataTypeNumber<Int32>;\n extern template class DataTypeNumber<Int64>;\n+extern template class DataTypeNumber<BFloat16>;\n extern template class DataTypeNumber<Float32>;\n extern template class DataTypeNumber<Float64>;\n \n@@ -79,6 +80,7 @@ using DataTypeInt8 = DataTypeNumber<Int8>;\n using DataTypeInt16 = DataTypeNumber<Int16>;\n using DataTypeInt32 = DataTypeNumber<Int32>;\n using DataTypeInt64 = DataTypeNumber<Int64>;\n+using DataTypeBFloat16 = DataTypeNumber<BFloat16>;\n using DataTypeFloat32 = DataTypeNumber<Float32>;\n using DataTypeFloat64 = DataTypeNumber<Float64>;\n \ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 33eddf8e9b89..8f06526ddbbd 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -408,9 +408,11 @@ struct WhichDataType\n     constexpr bool isDecimal256() const { return idx == TypeIndex::Decimal256; }\n     constexpr bool isDecimal() const { return isDecimal32() || isDecimal64() || isDecimal128() || isDecimal256(); }\n \n+    constexpr bool isBFloat16() const { return idx == TypeIndex::BFloat16; }\n     constexpr bool isFloat32() const { return idx == TypeIndex::Float32; }\n     constexpr bool isFloat64() const { return idx == TypeIndex::Float64; }\n-    constexpr bool isFloat() const { return isFloat32() || isFloat64(); }\n+    constexpr bool isNativeFloat() const { return isFloat32() || isFloat64(); }\n+    constexpr bool isFloat() const { return isNativeFloat() || isBFloat16(); }\n \n     constexpr bool isNativeNumber() const { return isNativeInteger() || isFloat(); }\n     constexpr bool isNumber() const { return isInteger() || isFloat() || isDecimal(); }\n@@ -621,6 +623,7 @@ template <typename T> inline constexpr bool IsDataTypeEnum<DataTypeEnum<T>> = tr\n     M(Int64) \\\n     M(Int128) \\\n     M(Int256) \\\n+    M(BFloat16) \\\n     M(Float32) \\\n     M(Float64)\n }\ndiff --git a/src/DataTypes/Native.cpp b/src/DataTypes/Native.cpp\nindex 5dc490b0bd5f..53354d7c6e05 100644\n--- a/src/DataTypes/Native.cpp\n+++ b/src/DataTypes/Native.cpp\n@@ -37,7 +37,7 @@ bool canBeNativeType(const IDataType & type)\n         return canBeNativeType(*data_type_nullable.getNestedType());\n     }\n \n-    return data_type.isNativeInt() || data_type.isNativeUInt() || data_type.isFloat() || data_type.isDate()\n+    return data_type.isNativeInt() || data_type.isNativeUInt() || data_type.isNativeFloat() || data_type.isDate()\n         || data_type.isDate32() || data_type.isDateTime() || data_type.isEnum();\n }\n \ndiff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h\nindex 59a64017af38..ee0d98120973 100644\n--- a/src/DataTypes/NumberTraits.h\n+++ b/src/DataTypes/NumberTraits.h\n@@ -74,7 +74,7 @@ template <typename A, typename B> struct ResultOfAdditionMultiplication\n {\n     using Type = typename Construct<\n         is_signed_v<A> || is_signed_v<B>,\n-        std::is_floating_point_v<A> || std::is_floating_point_v<B>,\n+        is_floating_point<A> || is_floating_point<B>,\n         nextSize(max(sizeof(A), sizeof(B)))>::Type;\n };\n \n@@ -82,7 +82,7 @@ template <typename A, typename B> struct ResultOfSubtraction\n {\n     using Type = typename Construct<\n         true,\n-        std::is_floating_point_v<A> || std::is_floating_point_v<B>,\n+        is_floating_point<A> || is_floating_point<B>,\n         nextSize(max(sizeof(A), sizeof(B)))>::Type;\n };\n \n@@ -113,7 +113,7 @@ template <typename A, typename B> struct ResultOfModulo\n     /// Example: toInt32(-199) % toUInt8(200) will return -199 that does not fit in Int8, only in Int16.\n     static constexpr size_t size_of_result = result_is_signed ? nextSize(sizeof(B)) : sizeof(B);\n     using Type0 = typename Construct<result_is_signed, false, size_of_result>::Type;\n-    using Type = std::conditional_t<std::is_floating_point_v<A> || std::is_floating_point_v<B>, Float64, Type0>;\n+    using Type = std::conditional_t<is_floating_point<A> || is_floating_point<B>, Float64, Type0>;\n };\n \n template <typename A, typename B> struct ResultOfPositiveModulo\n@@ -121,21 +121,21 @@ template <typename A, typename B> struct ResultOfPositiveModulo\n     /// function positive_modulo always return non-negative number.\n     static constexpr size_t size_of_result = sizeof(B);\n     using Type0 = typename Construct<false, false, size_of_result>::Type;\n-    using Type = std::conditional_t<std::is_floating_point_v<A> || std::is_floating_point_v<B>, Float64, Type0>;\n+    using Type = std::conditional_t<is_floating_point<A> || is_floating_point<B>, Float64, Type0>;\n };\n \n \n template <typename A, typename B> struct ResultOfModuloLegacy\n {\n     using Type0 = typename Construct<is_signed_v<A> || is_signed_v<B>, false, sizeof(B)>::Type;\n-    using Type = std::conditional_t<std::is_floating_point_v<A> || std::is_floating_point_v<B>, Float64, Type0>;\n+    using Type = std::conditional_t<is_floating_point<A> || is_floating_point<B>, Float64, Type0>;\n };\n \n template <typename A> struct ResultOfNegate\n {\n     using Type = typename Construct<\n         true,\n-        std::is_floating_point_v<A>,\n+        is_floating_point<A>,\n         is_signed_v<A> ? sizeof(A) : nextSize(sizeof(A))>::Type;\n };\n \n@@ -143,7 +143,7 @@ template <typename A> struct ResultOfAbs\n {\n     using Type = typename Construct<\n         false,\n-        std::is_floating_point_v<A>,\n+        is_floating_point<A>,\n         sizeof(A)>::Type;\n };\n \n@@ -154,7 +154,7 @@ template <typename A, typename B> struct ResultOfBit\n     using Type = typename Construct<\n         is_signed_v<A> || is_signed_v<B>,\n         false,\n-        std::is_floating_point_v<A> || std::is_floating_point_v<B> ? 8 : max(sizeof(A), sizeof(B))>::Type;\n+        is_floating_point<A> || is_floating_point<B> ? 8 : max(sizeof(A), sizeof(B))>::Type;\n };\n \n template <typename A> struct ResultOfBitNot\n@@ -180,7 +180,7 @@ template <typename A> struct ResultOfBitNot\n template <typename A, typename B>\n struct ResultOfIf\n {\n-    static constexpr bool has_float = std::is_floating_point_v<A> || std::is_floating_point_v<B>;\n+    static constexpr bool has_float = is_floating_point<A> || is_floating_point<B>;\n     static constexpr bool has_integer = is_integer<A> || is_integer<B>;\n     static constexpr bool has_signed = is_signed_v<A> || is_signed_v<B>;\n     static constexpr bool has_unsigned = !is_signed_v<A> || !is_signed_v<B>;\n@@ -189,7 +189,7 @@ struct ResultOfIf\n     static constexpr size_t max_size_of_unsigned_integer = max(is_signed_v<A> ? 0 : sizeof(A), is_signed_v<B> ? 0 : sizeof(B));\n     static constexpr size_t max_size_of_signed_integer = max(is_signed_v<A> ? sizeof(A) : 0, is_signed_v<B> ? sizeof(B) : 0);\n     static constexpr size_t max_size_of_integer = max(is_integer<A> ? sizeof(A) : 0, is_integer<B> ? sizeof(B) : 0);\n-    static constexpr size_t max_size_of_float = max(std::is_floating_point_v<A> ? sizeof(A) : 0, std::is_floating_point_v<B> ? sizeof(B) : 0);\n+    static constexpr size_t max_size_of_float = max(is_floating_point<A> ? sizeof(A) : 0, is_floating_point<B> ? sizeof(B) : 0);\n \n     using ConstructedType = typename Construct<has_signed, has_float,\n         ((has_float && has_integer && max_size_of_integer >= max_size_of_float)\n@@ -211,7 +211,7 @@ template <typename A> struct ToInteger\n     using Type = typename Construct<\n         is_signed_v<A>,\n         false,\n-        std::is_floating_point_v<A> ? 8 : sizeof(A)>::Type;\n+        is_floating_point<A> ? 8 : sizeof(A)>::Type;\n };\n \n \ndiff --git a/src/DataTypes/Serializations/SerializationNumber.cpp b/src/DataTypes/Serializations/SerializationNumber.cpp\nindex bfc13af8ca31..a20b97daf07b 100644\n--- a/src/DataTypes/Serializations/SerializationNumber.cpp\n+++ b/src/DataTypes/Serializations/SerializationNumber.cpp\n@@ -238,6 +238,7 @@ template class SerializationNumber<Int32>;\n template class SerializationNumber<Int64>;\n template class SerializationNumber<Int128>;\n template class SerializationNumber<Int256>;\n+template class SerializationNumber<BFloat16>;\n template class SerializationNumber<Float32>;\n template class SerializationNumber<Float64>;\n \ndiff --git a/src/DataTypes/Utils.cpp b/src/DataTypes/Utils.cpp\nindex a6e9452d7ef0..3004322475c2 100644\n--- a/src/DataTypes/Utils.cpp\n+++ b/src/DataTypes/Utils.cpp\n@@ -54,6 +54,13 @@ bool canBeSafelyCasted(const DataTypePtr & from_type, const DataTypePtr & to_typ\n \n             return false;\n         }\n+        case TypeIndex::BFloat16:\n+        {\n+            if (to_which_type.isFloat32() || to_which_type.isFloat64() || to_which_type.isString())\n+                return true;\n+\n+            return false;\n+        }\n         case TypeIndex::Float32:\n         {\n             if (to_which_type.isFloat64() || to_which_type.isString())\ndiff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp\nindex 9664e769611f..1b258a8decc5 100644\n--- a/src/DataTypes/getLeastSupertype.cpp\n+++ b/src/DataTypes/getLeastSupertype.cpp\n@@ -109,6 +109,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types)\n             maximize(max_bits_of_signed_integer, 128);\n         else if (type == TypeIndex::Int256)\n             maximize(max_bits_of_signed_integer, 256);\n+        else if (type == TypeIndex::BFloat16)\n+            maximize(max_mantissa_bits_of_floating, 8);\n         else if (type == TypeIndex::Float32)\n             maximize(max_mantissa_bits_of_floating, 24);\n         else if (type == TypeIndex::Float64)\n@@ -145,7 +147,9 @@ DataTypePtr getNumericType(const TypeIndexSet & types)\n         if (max_mantissa_bits_of_floating)\n         {\n             size_t min_mantissa_bits = std::max(min_bit_width_of_integer, max_mantissa_bits_of_floating);\n-            if (min_mantissa_bits <= 24)\n+            if (min_mantissa_bits <= 8)\n+                return std::make_shared<DataTypeBFloat16>();\n+            else if (min_mantissa_bits <= 24)\n                 return std::make_shared<DataTypeFloat32>();\n             if (min_mantissa_bits <= 53)\n                 return std::make_shared<DataTypeFloat64>();\ndiff --git a/src/DataTypes/getMostSubtype.cpp b/src/DataTypes/getMostSubtype.cpp\nindex b3c76079646f..8cb16c04079d 100644\n--- a/src/DataTypes/getMostSubtype.cpp\n+++ b/src/DataTypes/getMostSubtype.cpp\n@@ -297,6 +297,8 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n                 minimize(min_bits_of_signed_integer, 128);\n             else if (typeid_cast<const DataTypeInt256 *>(type.get()))\n                 minimize(min_bits_of_signed_integer, 256);\n+            else if (typeid_cast<const DataTypeBFloat16 *>(type.get()))\n+                minimize(min_mantissa_bits_of_floating, 8);\n             else if (typeid_cast<const DataTypeFloat32 *>(type.get()))\n                 minimize(min_mantissa_bits_of_floating, 24);\n             else if (typeid_cast<const DataTypeFloat64 *>(type.get()))\n@@ -313,7 +315,9 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth\n             /// If the result must be floating.\n             if (!min_bits_of_signed_integer && !min_bits_of_unsigned_integer)\n             {\n-                if (min_mantissa_bits_of_floating <= 24)\n+                if (min_mantissa_bits_of_floating <= 8)\n+                    return std::make_shared<DataTypeBFloat16>();\n+                else if (min_mantissa_bits_of_floating <= 24)\n                     return std::make_shared<DataTypeFloat32>();\n                 if (min_mantissa_bits_of_floating <= 53)\n                     return std::make_shared<DataTypeFloat64>();\ndiff --git a/src/Databases/enableAllExperimentalSettings.cpp b/src/Databases/enableAllExperimentalSettings.cpp\nindex d51d2671992b..1be54664bc91 100644\n--- a/src/Databases/enableAllExperimentalSettings.cpp\n+++ b/src/Databases/enableAllExperimentalSettings.cpp\n@@ -24,10 +24,11 @@ void enableAllExperimentalSettings(ContextMutablePtr context)\n     context->setSetting(\"allow_experimental_dynamic_type\", 1);\n     context->setSetting(\"allow_experimental_json_type\", 1);\n     context->setSetting(\"allow_experimental_vector_similarity_index\", 1);\n-    context->setSetting(\"allow_experimental_bigint_types\", 1);\n     context->setSetting(\"allow_experimental_window_functions\", 1);\n     context->setSetting(\"allow_experimental_geo_types\", 1);\n     context->setSetting(\"allow_experimental_map_type\", 1);\n+    context->setSetting(\"allow_experimental_bigint_types\", 1);\n+    context->setSetting(\"allow_experimental_bfloat16_type\", 1);\n     context->setSetting(\"allow_deprecated_error_prone_window_functions\", 1);\n \n     context->setSetting(\"allow_suspicious_low_cardinality_types\", 1);\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex bc335b890fc2..5e93391816f3 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -298,7 +298,8 @@ namespace impl\n             using Types = std::decay_t<decltype(types)>;\n             using DataType = typename Types::LeftType;\n \n-            if constexpr (IsDataTypeDecimalOrNumber<DataType> || IsDataTypeDateOrDateTime<DataType> || IsDataTypeEnum<DataType>)\n+            if constexpr ((IsDataTypeDecimalOrNumber<DataType> || IsDataTypeDateOrDateTime<DataType> || IsDataTypeEnum<DataType>)\n+                && !std::is_same_v<DataType, DataTypeBFloat16>)\n             {\n                 using ColumnType = typename DataType::ColumnType;\n                 func(TypePair<ColumnType, void>());\ndiff --git a/src/Formats/JSONExtractTree.cpp b/src/Formats/JSONExtractTree.cpp\nindex ae6051823b7f..62905a2e6307 100644\n--- a/src/Formats/JSONExtractTree.cpp\n+++ b/src/Formats/JSONExtractTree.cpp\n@@ -131,7 +131,7 @@ bool tryGetNumericValueFromJSONElement(\n     switch (element.type())\n     {\n         case ElementType::DOUBLE:\n-            if constexpr (std::is_floating_point_v<NumberType>)\n+            if constexpr (is_floating_point<NumberType>)\n             {\n                 /// We permit inaccurate conversion of double to float.\n                 /// Example: double 0.1 from JSON is not representable in float.\n@@ -175,7 +175,7 @@ bool tryGetNumericValueFromJSONElement(\n                 return false;\n \n             auto rb = ReadBufferFromMemory{element.getString()};\n-            if constexpr (std::is_floating_point_v<NumberType>)\n+            if constexpr (is_floating_point<NumberType>)\n             {\n                 if (!tryReadFloatText(value, rb) || !rb.eof())\n                 {\ndiff --git a/src/Formats/ProtobufSerializer.cpp b/src/Formats/ProtobufSerializer.cpp\nindex 2224af6579f4..bd8aeff5a5da 100644\n--- a/src/Formats/ProtobufSerializer.cpp\n+++ b/src/Formats/ProtobufSerializer.cpp\n@@ -540,7 +540,7 @@ namespace\n \n                 case FieldTypeId::TYPE_ENUM:\n                 {\n-                    if (std::is_floating_point_v<NumberType>)\n+                    if (is_floating_point<NumberType>)\n                         incompatibleColumnType(TypeName<NumberType>);\n \n                     write_function = [this](NumberType value)\ndiff --git a/src/Functions/DivisionUtils.h b/src/Functions/DivisionUtils.h\nindex 7fd5b7476e10..e8f5da342f84 100644\n--- a/src/Functions/DivisionUtils.h\n+++ b/src/Functions/DivisionUtils.h\n@@ -47,9 +47,9 @@ inline auto checkedDivision(A a, B b)\n {\n     throwIfDivisionLeadsToFPE(a, b);\n \n-    if constexpr (is_big_int_v<A> && std::is_floating_point_v<B>)\n+    if constexpr (is_big_int_v<A> && is_floating_point<B>)\n         return static_cast<B>(a) / b;\n-    else if constexpr (is_big_int_v<B> && std::is_floating_point_v<A>)\n+    else if constexpr (is_big_int_v<B> && is_floating_point<A>)\n         return a / static_cast<A>(b);\n     else if constexpr (is_big_int_v<A> && is_big_int_v<B>)\n         return static_cast<A>(a / b);\n@@ -86,17 +86,17 @@ struct DivideIntegralImpl\n         {\n             /// Comparisons are not strict to avoid rounding issues when operand is implicitly casted to float.\n \n-            if constexpr (std::is_floating_point_v<A>)\n+            if constexpr (is_floating_point<A>)\n                 if (isNaN(a) || a >= std::numeric_limits<CastA>::max() || a <= std::numeric_limits<CastA>::lowest())\n                     throw Exception(ErrorCodes::ILLEGAL_DIVISION, \"Cannot perform integer division on infinite or too large floating point numbers\");\n \n-            if constexpr (std::is_floating_point_v<B>)\n+            if constexpr (is_floating_point<B>)\n                 if (isNaN(b) || b >= std::numeric_limits<CastB>::max() || b <= std::numeric_limits<CastB>::lowest())\n                     throw Exception(ErrorCodes::ILLEGAL_DIVISION, \"Cannot perform integer division on infinite or too large floating point numbers\");\n \n             auto res = checkedDivision(CastA(a), CastB(b));\n \n-            if constexpr (std::is_floating_point_v<decltype(res)>)\n+            if constexpr (is_floating_point<decltype(res)>)\n                 if (isNaN(res) || res >= static_cast<double>(std::numeric_limits<Result>::max()) || res <= std::numeric_limits<Result>::lowest())\n                     throw Exception(ErrorCodes::ILLEGAL_DIVISION, \"Cannot perform integer division, because it will produce infinite or too large number\");\n \n@@ -122,18 +122,18 @@ struct ModuloImpl\n     template <typename Result = ResultType>\n     static Result apply(A a, B b)\n     {\n-        if constexpr (std::is_floating_point_v<ResultType>)\n+        if constexpr (is_floating_point<ResultType>)\n         {\n             /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.\n             return static_cast<ResultType>(a) - trunc(static_cast<ResultType>(a) / static_cast<ResultType>(b)) * static_cast<ResultType>(b);\n         }\n         else\n         {\n-            if constexpr (std::is_floating_point_v<A>)\n+            if constexpr (is_floating_point<A>)\n                 if (isNaN(a) || a > std::numeric_limits<IntegerAType>::max() || a < std::numeric_limits<IntegerAType>::lowest())\n                     throw Exception(ErrorCodes::ILLEGAL_DIVISION, \"Cannot perform integer division on infinite or too large floating point numbers\");\n \n-            if constexpr (std::is_floating_point_v<B>)\n+            if constexpr (is_floating_point<B>)\n                 if (isNaN(b) || b > std::numeric_limits<IntegerBType>::max() || b < std::numeric_limits<IntegerBType>::lowest())\n                     throw Exception(ErrorCodes::ILLEGAL_DIVISION, \"Cannot perform integer division on infinite or too large floating point numbers\");\n \ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex df239b820af0..e7f0d8d43b0e 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -110,6 +110,7 @@ template <typename DataType> constexpr bool IsIntegralOrExtendedOrDecimal =\n     IsDataTypeDecimal<DataType>;\n \n template <typename DataType> constexpr bool IsFloatingPoint = false;\n+template <> inline constexpr bool IsFloatingPoint<DataTypeBFloat16> = true;\n template <> inline constexpr bool IsFloatingPoint<DataTypeFloat32> = true;\n template <> inline constexpr bool IsFloatingPoint<DataTypeFloat64> = true;\n \n@@ -803,7 +804,7 @@ class FunctionBinaryArithmetic : public IFunction\n             DataTypeFixedString, DataTypeString,\n             DataTypeInterval>;\n \n-        using Floats = TypeList<DataTypeFloat32, DataTypeFloat64>;\n+        using Floats = TypeList<DataTypeFloat32, DataTypeFloat64, DataTypeBFloat16>;\n \n         using ValidTypes = std::conditional_t<valid_on_float_arguments,\n             TypeListConcat<Types, Floats>,\n@@ -1690,6 +1691,13 @@ class FunctionBinaryArithmetic : public IFunction\n             }\n             else\n             {\n+                if constexpr ((std::is_same_v<LeftDataType, DataTypeBFloat16> || std::is_same_v<RightDataType, DataTypeBFloat16>)\n+                    && (sizeof(typename LeftDataType::FieldType) > 8 || sizeof(typename RightDataType::FieldType) > 8))\n+                {\n+                    /// Big integers and BFloat16 are not supported together.\n+                    return false;\n+                }\n+\n                 using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;\n \n                 if constexpr (!std::is_same_v<ResultDataType, InvalidType>)\n@@ -2042,7 +2050,15 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n         using DecimalResultType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::DecimalResultDataType;\n \n         if constexpr (std::is_same_v<ResultDataType, InvalidType>)\n+        {\n             return nullptr;\n+        }\n+        else if constexpr ((std::is_same_v<LeftDataType, DataTypeBFloat16> || std::is_same_v<RightDataType, DataTypeBFloat16>)\n+            && (sizeof(typename LeftDataType::FieldType) > 8 || sizeof(typename RightDataType::FieldType) > 8))\n+        {\n+            /// Big integers and BFloat16 are not supported together.\n+            return nullptr;\n+        }\n         else // we can't avoid the else because otherwise the compiler may assume the ResultDataType may be Invalid\n              // and that would produce the compile error.\n         {\n@@ -2059,7 +2075,7 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n             ColumnPtr left_col = nullptr;\n             ColumnPtr right_col = nullptr;\n \n-            /// When Decimal op Float32/64, convert both of them into Float64\n+            /// When Decimal op Float32/64/16, convert both of them into Float64\n             if constexpr (decimal_with_float)\n             {\n                 const auto converted_type = std::make_shared<DataTypeFloat64>();\n@@ -2094,7 +2110,6 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n             /// Here we check if we have `intDiv` or `intDivOrZero` and at least one of the arguments is decimal, because in this case originally we had result as decimal, so we need to convert result into integer after calculations\n             else if constexpr (!decimal_with_float && (is_int_div || is_int_div_or_zero) && (IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>))\n             {\n-\n                 if constexpr (!std::is_same_v<DecimalResultType, InvalidType>)\n                 {\n                     DataTypePtr type_res;\ndiff --git a/src/Functions/FunctionMathUnary.h b/src/Functions/FunctionMathUnary.h\nindex 4df70f4782bf..12a15a072b24 100644\n--- a/src/Functions/FunctionMathUnary.h\n+++ b/src/Functions/FunctionMathUnary.h\n@@ -70,7 +70,7 @@ class FunctionMathUnary : public IFunction\n             /// Process all data as a whole and use FastOps implementation\n \n             /// If the argument is integer, convert to Float64 beforehand\n-            if constexpr (!std::is_floating_point_v<T>)\n+            if constexpr (!is_floating_point<T>)\n             {\n                 PODArray<Float64> tmp_vec(size);\n                 for (size_t i = 0; i < size; ++i)\n@@ -152,7 +152,7 @@ class FunctionMathUnary : public IFunction\n         {\n             using Types = std::decay_t<decltype(types)>;\n             using Type = typename Types::RightType;\n-            using ReturnType = std::conditional_t<Impl::always_returns_float64 || !std::is_floating_point_v<Type>, Float64, Type>;\n+            using ReturnType = std::conditional_t<Impl::always_returns_float64 || !is_floating_point<Type>, Float64, Type>;\n             using ColVecType = ColumnVectorOrDecimal<Type>;\n \n             const auto col_vec = checkAndGetColumn<ColVecType>(col.column.get());\ndiff --git a/src/Functions/FunctionsBinaryRepresentation.cpp b/src/Functions/FunctionsBinaryRepresentation.cpp\nindex c8e8f167e4c9..50a3c0862f40 100644\n--- a/src/Functions/FunctionsBinaryRepresentation.cpp\n+++ b/src/Functions/FunctionsBinaryRepresentation.cpp\n@@ -296,6 +296,7 @@ class EncodeToBinaryRepresentation : public IFunction\n             tryExecuteUIntOrInt<Int256>(column, res_column) ||\n             tryExecuteString(column, res_column) ||\n             tryExecuteFixedString(column, res_column) ||\n+            tryExecuteFloat<BFloat16>(column, res_column) ||\n             tryExecuteFloat<Float32>(column, res_column) ||\n             tryExecuteFloat<Float64>(column, res_column) ||\n             tryExecuteDecimal<Decimal32>(column, res_column) ||\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 9b2328065fc7..c9d3ccb44450 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -721,6 +721,7 @@ class FunctionComparison : public IFunction\n                 || (res = executeNumRightType<T0, Int64>(col_left, col_right_untyped))\n                 || (res = executeNumRightType<T0, Int128>(col_left, col_right_untyped))\n                 || (res = executeNumRightType<T0, Int256>(col_left, col_right_untyped))\n+                || (res = executeNumRightType<T0, BFloat16>(col_left, col_right_untyped))\n                 || (res = executeNumRightType<T0, Float32>(col_left, col_right_untyped))\n                 || (res = executeNumRightType<T0, Float64>(col_left, col_right_untyped)))\n                 return res;\n@@ -741,6 +742,7 @@ class FunctionComparison : public IFunction\n                 || (res = executeNumConstRightType<T0, Int64>(col_left_const, col_right_untyped))\n                 || (res = executeNumConstRightType<T0, Int128>(col_left_const, col_right_untyped))\n                 || (res = executeNumConstRightType<T0, Int256>(col_left_const, col_right_untyped))\n+                || (res = executeNumConstRightType<T0, BFloat16>(col_left_const, col_right_untyped))\n                 || (res = executeNumConstRightType<T0, Float32>(col_left_const, col_right_untyped))\n                 || (res = executeNumConstRightType<T0, Float64>(col_left_const, col_right_untyped)))\n                 return res;\n@@ -1292,9 +1294,10 @@ class FunctionComparison : public IFunction\n                 || (res = executeNumLeftType<Int64>(col_left_untyped, col_right_untyped))\n                 || (res = executeNumLeftType<Int128>(col_left_untyped, col_right_untyped))\n                 || (res = executeNumLeftType<Int256>(col_left_untyped, col_right_untyped))\n+                || (res = executeNumLeftType<BFloat16>(col_left_untyped, col_right_untyped))\n                 || (res = executeNumLeftType<Float32>(col_left_untyped, col_right_untyped))\n                 || (res = executeNumLeftType<Float64>(col_left_untyped, col_right_untyped))))\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of the first argument of function {}\",\n                     col_left_untyped->getName(), getName());\n \n             return res;\n@@ -1342,7 +1345,7 @@ class FunctionComparison : public IFunction\n                     getName(),\n                     left_type->getName(),\n                     right_type->getName());\n-            /// When Decimal comparing to Float32/64, we convert both of them into Float64.\n+            /// When Decimal comparing to Float32/64/16, we convert both of them into Float64.\n             /// Other systems like MySQL and Spark also do as this.\n             if (left_is_float || right_is_float)\n             {\ndiff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp\nindex 1e7cb8f17496..d581ae510e8b 100644\n--- a/src/Functions/FunctionsConversion.cpp\n+++ b/src/Functions/FunctionsConversion.cpp\n@@ -7,10 +7,8 @@\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnLowCardinality.h>\n #include <Columns/ColumnMap.h>\n-#include <Columns/ColumnNothing.h>\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnObjectDeprecated.h>\n-#include <Columns/ColumnObject.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnStringHelpers.h>\n #include <Columns/ColumnTuple.h>\n@@ -73,8 +71,10 @@\n #include <Common/assert_cast.h>\n #include <Common/quoteString.h>\n \n+\n namespace DB\n {\n+\n namespace Setting\n {\n     extern const SettingsBool cast_ipv4_ipv6_default_on_conversion_error;\n@@ -653,7 +653,7 @@ inline void convertFromTime<DataTypeDateTime>(DataTypeDateTime::FieldType & x, t\n template <typename DataType>\n void parseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool precise_float_parsing)\n {\n-    if constexpr (std::is_floating_point_v<typename DataType::FieldType>)\n+    if constexpr (is_floating_point<typename DataType::FieldType>)\n     {\n         if (precise_float_parsing)\n             readFloatTextPrecise(x, rb);\n@@ -717,7 +717,7 @@ inline void parseImpl<DataTypeIPv6>(DataTypeIPv6::FieldType & x, ReadBuffer & rb\n template <typename DataType>\n bool tryParseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTImpl *, bool precise_float_parsing)\n {\n-    if constexpr (std::is_floating_point_v<typename DataType::FieldType>)\n+    if constexpr (is_floating_point<typename DataType::FieldType>)\n     {\n         if (precise_float_parsing)\n             return tryReadFloatTextPrecise(x, rb);\n@@ -1847,7 +1847,7 @@ struct ConvertImpl\n                 else\n                 {\n                     /// If From Data is Nan or Inf and we convert to integer type, throw exception\n-                    if constexpr (std::is_floating_point_v<FromFieldType> && !std::is_floating_point_v<ToFieldType>)\n+                    if constexpr (is_floating_point<FromFieldType> && !is_floating_point<ToFieldType>)\n                     {\n                         if (!isFinite(vec_from[i]))\n                         {\n@@ -2333,9 +2333,9 @@ class FunctionConvert : public IFunction\n                 using RightT = typename RightDataType::FieldType;\n \n                 static constexpr bool bad_left =\n-                    is_decimal<LeftT> || std::is_floating_point_v<LeftT> || is_big_int_v<LeftT> || is_signed_v<LeftT>;\n+                    is_decimal<LeftT> || is_floating_point<LeftT> || is_big_int_v<LeftT> || is_signed_v<LeftT>;\n                 static constexpr bool bad_right =\n-                    is_decimal<RightT> || std::is_floating_point_v<RightT> || is_big_int_v<RightT> || is_signed_v<RightT>;\n+                    is_decimal<RightT> || is_floating_point<RightT> || is_big_int_v<RightT> || is_signed_v<RightT>;\n \n                 /// Disallow int vs UUID conversion (but support int vs UInt128 conversion)\n                 if constexpr ((bad_left && std::is_same_v<RightDataType, DataTypeUUID>) ||\n@@ -2662,7 +2662,7 @@ struct ToNumberMonotonicity\n         /// Float cases.\n \n         /// When converting to Float, the conversion is always monotonic.\n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n             return { .is_monotonic = true, .is_always_monotonic = true };\n \n         const auto * low_cardinality = typeid_cast<const DataTypeLowCardinality *>(&type);\n@@ -2875,6 +2875,7 @@ struct NameToInt32 { static constexpr auto name = \"toInt32\"; };\n struct NameToInt64 { static constexpr auto name = \"toInt64\"; };\n struct NameToInt128 { static constexpr auto name = \"toInt128\"; };\n struct NameToInt256 { static constexpr auto name = \"toInt256\"; };\n+struct NameToBFloat16 { static constexpr auto name = \"toBFloat16\"; };\n struct NameToFloat32 { static constexpr auto name = \"toFloat32\"; };\n struct NameToFloat64 { static constexpr auto name = \"toFloat64\"; };\n struct NameToUUID { static constexpr auto name = \"toUUID\"; };\n@@ -2893,6 +2894,7 @@ using FunctionToInt32 = FunctionConvert<DataTypeInt32, NameToInt32, ToNumberMono\n using FunctionToInt64 = FunctionConvert<DataTypeInt64, NameToInt64, ToNumberMonotonicity<Int64>>;\n using FunctionToInt128 = FunctionConvert<DataTypeInt128, NameToInt128, ToNumberMonotonicity<Int128>>;\n using FunctionToInt256 = FunctionConvert<DataTypeInt256, NameToInt256, ToNumberMonotonicity<Int256>>;\n+using FunctionToBFloat16 = FunctionConvert<DataTypeBFloat16, NameToBFloat16, ToNumberMonotonicity<BFloat16>>;\n using FunctionToFloat32 = FunctionConvert<DataTypeFloat32, NameToFloat32, ToNumberMonotonicity<Float32>>;\n using FunctionToFloat64 = FunctionConvert<DataTypeFloat64, NameToFloat64, ToNumberMonotonicity<Float64>>;\n \n@@ -2930,6 +2932,7 @@ template <> struct FunctionTo<DataTypeInt32> { using Type = FunctionToInt32; };\n template <> struct FunctionTo<DataTypeInt64> { using Type = FunctionToInt64; };\n template <> struct FunctionTo<DataTypeInt128> { using Type = FunctionToInt128; };\n template <> struct FunctionTo<DataTypeInt256> { using Type = FunctionToInt256; };\n+template <> struct FunctionTo<DataTypeBFloat16> { using Type = FunctionToBFloat16; };\n template <> struct FunctionTo<DataTypeFloat32> { using Type = FunctionToFloat32; };\n template <> struct FunctionTo<DataTypeFloat64> { using Type = FunctionToFloat64; };\n \n@@ -2972,6 +2975,7 @@ struct NameToInt32OrZero { static constexpr auto name = \"toInt32OrZero\"; };\n struct NameToInt64OrZero { static constexpr auto name = \"toInt64OrZero\"; };\n struct NameToInt128OrZero { static constexpr auto name = \"toInt128OrZero\"; };\n struct NameToInt256OrZero { static constexpr auto name = \"toInt256OrZero\"; };\n+struct NameToBFloat16OrZero { static constexpr auto name = \"toBFloat16OrZero\"; };\n struct NameToFloat32OrZero { static constexpr auto name = \"toFloat32OrZero\"; };\n struct NameToFloat64OrZero { static constexpr auto name = \"toFloat64OrZero\"; };\n struct NameToDateOrZero { static constexpr auto name = \"toDateOrZero\"; };\n@@ -2998,6 +3002,7 @@ using FunctionToInt32OrZero = FunctionConvertFromString<DataTypeInt32, NameToInt\n using FunctionToInt64OrZero = FunctionConvertFromString<DataTypeInt64, NameToInt64OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToInt128OrZero = FunctionConvertFromString<DataTypeInt128, NameToInt128OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToInt256OrZero = FunctionConvertFromString<DataTypeInt256, NameToInt256OrZero, ConvertFromStringExceptionMode::Zero>;\n+using FunctionToBFloat16OrZero = FunctionConvertFromString<DataTypeBFloat16, NameToBFloat16OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToFloat32OrZero = FunctionConvertFromString<DataTypeFloat32, NameToFloat32OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToFloat64OrZero = FunctionConvertFromString<DataTypeFloat64, NameToFloat64OrZero, ConvertFromStringExceptionMode::Zero>;\n using FunctionToDateOrZero = FunctionConvertFromString<DataTypeDate, NameToDateOrZero, ConvertFromStringExceptionMode::Zero>;\n@@ -3024,6 +3029,7 @@ struct NameToInt32OrNull { static constexpr auto name = \"toInt32OrNull\"; };\n struct NameToInt64OrNull { static constexpr auto name = \"toInt64OrNull\"; };\n struct NameToInt128OrNull { static constexpr auto name = \"toInt128OrNull\"; };\n struct NameToInt256OrNull { static constexpr auto name = \"toInt256OrNull\"; };\n+struct NameToBFloat16OrNull { static constexpr auto name = \"toBFloat16OrNull\"; };\n struct NameToFloat32OrNull { static constexpr auto name = \"toFloat32OrNull\"; };\n struct NameToFloat64OrNull { static constexpr auto name = \"toFloat64OrNull\"; };\n struct NameToDateOrNull { static constexpr auto name = \"toDateOrNull\"; };\n@@ -3050,6 +3056,7 @@ using FunctionToInt32OrNull = FunctionConvertFromString<DataTypeInt32, NameToInt\n using FunctionToInt64OrNull = FunctionConvertFromString<DataTypeInt64, NameToInt64OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToInt128OrNull = FunctionConvertFromString<DataTypeInt128, NameToInt128OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToInt256OrNull = FunctionConvertFromString<DataTypeInt256, NameToInt256OrNull, ConvertFromStringExceptionMode::Null>;\n+using FunctionToBFloat16OrNull = FunctionConvertFromString<DataTypeBFloat16, NameToBFloat16OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToFloat32OrNull = FunctionConvertFromString<DataTypeFloat32, NameToFloat32OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToFloat64OrNull = FunctionConvertFromString<DataTypeFloat64, NameToFloat64OrNull, ConvertFromStringExceptionMode::Null>;\n using FunctionToDateOrNull = FunctionConvertFromString<DataTypeDate, NameToDateOrNull, ConvertFromStringExceptionMode::Null>;\n@@ -5193,7 +5200,7 @@ class FunctionCast final : public IFunctionBase\n             if constexpr (is_any_of<ToDataType,\n                 DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256,\n                 DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64, DataTypeInt128, DataTypeInt256,\n-                DataTypeFloat32, DataTypeFloat64,\n+                DataTypeBFloat16, DataTypeFloat32, DataTypeFloat64,\n                 DataTypeDate, DataTypeDate32, DataTypeDateTime,\n                 DataTypeUUID, DataTypeIPv4, DataTypeIPv6>)\n             {\n@@ -5446,6 +5453,17 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionToInt64>();\n     factory.registerFunction<FunctionToInt128>();\n     factory.registerFunction<FunctionToInt256>();\n+\n+    factory.registerFunction<FunctionToBFloat16>(FunctionDocumentation{.description=R\"(\n+Converts Float32 to BFloat16 with losing the precision.\n+\n+Example:\n+[example:typical]\n+)\",\n+        .examples{\n+            {\"typical\", \"SELECT toBFloat16(12.3::Float32);\", \"12.3125\"}},\n+        .categories{\"Conversion\"}});\n+\n     factory.registerFunction<FunctionToFloat32>();\n     factory.registerFunction<FunctionToFloat64>();\n \n@@ -5484,6 +5502,31 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionToInt64OrZero>();\n     factory.registerFunction<FunctionToInt128OrZero>();\n     factory.registerFunction<FunctionToInt256OrZero>();\n+\n+    factory.registerFunction<FunctionToBFloat16OrZero>(FunctionDocumentation{.description=R\"(\n+Converts String to BFloat16.\n+\n+If the string does not represent a floating point value, the function returns zero.\n+\n+The function allows a silent loss of precision while converting from the string representation. In that case, it will return the truncated result.\n+\n+Example of successful conversion:\n+[example:typical]\n+\n+Examples of not successful conversion:\n+[example:invalid1]\n+[example:invalid2]\n+\n+Example of a loss of precision:\n+[example:precision]\n+)\",\n+        .examples{\n+            {\"typical\", \"SELECT toBFloat16OrZero('12.3');\", \"12.3125\"},\n+            {\"invalid1\", \"SELECT toBFloat16OrZero('abc');\", \"0\"},\n+            {\"invalid2\", \"SELECT toBFloat16OrZero(' 1');\", \"0\"},\n+            {\"precision\", \"SELECT toBFloat16OrZero('12.3456789');\", \"12.375\"}},\n+        .categories{\"Conversion\"}});\n+\n     factory.registerFunction<FunctionToFloat32OrZero>();\n     factory.registerFunction<FunctionToFloat64OrZero>();\n     factory.registerFunction<FunctionToDateOrZero>();\n@@ -5512,6 +5555,31 @@ REGISTER_FUNCTION(Conversion)\n     factory.registerFunction<FunctionToInt64OrNull>();\n     factory.registerFunction<FunctionToInt128OrNull>();\n     factory.registerFunction<FunctionToInt256OrNull>();\n+\n+    factory.registerFunction<FunctionToBFloat16OrNull>(FunctionDocumentation{.description=R\"(\n+Converts String to Nullable(BFloat16).\n+\n+If the string does not represent a floating point value, the function returns NULL.\n+\n+The function allows a silent loss of precision while converting from the string representation. In that case, it will return the truncated result.\n+\n+Example of successful conversion:\n+[example:typical]\n+\n+Examples of not successful conversion:\n+[example:invalid1]\n+[example:invalid2]\n+\n+Example of a loss of precision:\n+[example:precision]\n+)\",\n+    .examples{\n+        {\"typical\", \"SELECT toBFloat16OrNull('12.3');\", \"12.3125\"},\n+        {\"invalid1\", \"SELECT toBFloat16OrNull('abc');\", \"NULL\"},\n+        {\"invalid2\", \"SELECT toBFloat16OrNull(' 1');\", \"NULL\"},\n+        {\"precision\", \"SELECT toBFloat16OrNull('12.3456789');\", \"12.375\"}},\n+    .categories{\"Conversion\"}});\n+\n     factory.registerFunction<FunctionToFloat32OrNull>();\n     factory.registerFunction<FunctionToFloat64OrNull>();\n     factory.registerFunction<FunctionToDateOrNull>();\ndiff --git a/src/Functions/FunctionsRound.h b/src/Functions/FunctionsRound.h\nindex ed7fe1a5de10..6c9cc8a37b3b 100644\n--- a/src/Functions/FunctionsRound.h\n+++ b/src/Functions/FunctionsRound.h\n@@ -268,6 +268,19 @@ inline double roundWithMode(double x, RoundingMode mode)\n     std::unreachable();\n }\n \n+inline BFloat16 roundWithMode(BFloat16 x, RoundingMode mode)\n+{\n+    switch (mode)\n+    {\n+        case RoundingMode::Round: return BFloat16(nearbyintf(Float32(x)));\n+        case RoundingMode::Floor: return BFloat16(floorf(Float32(x)));\n+        case RoundingMode::Ceil: return BFloat16(ceilf(Float32(x)));\n+        case RoundingMode::Trunc: return BFloat16(truncf(Float32(x)));\n+    }\n+\n+    std::unreachable();\n+}\n+\n template <typename T>\n class FloatRoundingComputationBase<T, Vectorize::No>\n {\n@@ -285,10 +298,15 @@ class FloatRoundingComputationBase<T, Vectorize::No>\n \n     static VectorType prepare(size_t scale)\n     {\n-        return load1(scale);\n+        return load1(ScalarType(scale));\n     }\n };\n \n+template <>\n+class FloatRoundingComputationBase<BFloat16, Vectorize::Yes> : public FloatRoundingComputationBase<BFloat16, Vectorize::No>\n+{\n+};\n+\n \n /** Implementation of low-level round-off functions for floating-point values.\n   */\n@@ -511,7 +529,7 @@ template <typename T, RoundingMode rounding_mode, TieBreakingMode tie_breaking_m\n struct Dispatcher\n {\n     template <ScaleMode scale_mode>\n-    using FunctionRoundingImpl = std::conditional_t<std::is_floating_point_v<T>,\n+    using FunctionRoundingImpl = std::conditional_t<is_floating_point<T>,\n         FloatRoundingImpl<T, rounding_mode, scale_mode>,\n         IntegerRoundingImpl<T, rounding_mode, scale_mode, tie_breaking_mode>>;\n \ndiff --git a/src/Functions/FunctionsVisitParam.h b/src/Functions/FunctionsVisitParam.h\nindex a77fa740f9cb..76d4a13687c3 100644\n--- a/src/Functions/FunctionsVisitParam.h\n+++ b/src/Functions/FunctionsVisitParam.h\n@@ -57,7 +57,7 @@ struct ExtractNumericType\n         ResultType x = 0;\n         if (!in.eof())\n         {\n-            if constexpr (std::is_floating_point_v<NumericType>)\n+            if constexpr (is_floating_point<NumericType>)\n                 tryReadFloatText(x, in);\n             else\n                 tryReadIntText(x, in);\ndiff --git a/src/Functions/PolygonUtils.h b/src/Functions/PolygonUtils.h\nindex bf8241774a65..601ffcb00b4c 100644\n--- a/src/Functions/PolygonUtils.h\n+++ b/src/Functions/PolygonUtils.h\n@@ -583,7 +583,7 @@ struct CallPointInPolygon<Type, Types ...>\n     template <typename PointInPolygonImpl>\n     static ColumnPtr call(const IColumn & x, const IColumn & y, PointInPolygonImpl && impl)\n     {\n-        using Impl = TypeListChangeRoot<CallPointInPolygon, TypeListIntAndFloat>;\n+        using Impl = TypeListChangeRoot<CallPointInPolygon, TypeListNativeNumber>;\n         if (auto column = typeid_cast<const ColumnVector<Type> *>(&x))\n             return Impl::template call<Type>(*column, y, impl);\n         return CallPointInPolygon<Types ...>::call(x, y, impl);\n@@ -609,7 +609,7 @@ struct CallPointInPolygon<>\n template <typename PointInPolygonImpl>\n NO_INLINE ColumnPtr pointInPolygon(const IColumn & x, const IColumn & y, PointInPolygonImpl && impl)\n {\n-    using Impl = TypeListChangeRoot<CallPointInPolygon, TypeListIntAndFloat>;\n+    using Impl = TypeListChangeRoot<CallPointInPolygon, TypeListNativeNumber>;\n     return Impl::call(x, y, impl);\n }\n \ndiff --git a/src/Functions/abs.cpp b/src/Functions/abs.cpp\nindex 742d3b85619c..0b701bb7108b 100644\n--- a/src/Functions/abs.cpp\n+++ b/src/Functions/abs.cpp\n@@ -22,7 +22,7 @@ struct AbsImpl\n             return a < 0 ? static_cast<ResultType>(~a) + 1 : static_cast<ResultType>(a);\n         else if constexpr (is_integer<A> && is_unsigned_v<A>)\n             return static_cast<ResultType>(a);\n-        else if constexpr (std::is_floating_point_v<A>)\n+        else if constexpr (is_floating_point<A>)\n             return static_cast<ResultType>(std::abs(a));\n     }\n \ndiff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp\nindex bb2503886f14..d073c79b832d 100644\n--- a/src/Functions/array/arrayAggregation.cpp\n+++ b/src/Functions/array/arrayAggregation.cpp\n@@ -87,7 +87,7 @@ struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::sum>\n         std::conditional_t<std::is_same_v<ArrayElement, Decimal128>, Decimal128,\n         std::conditional_t<std::is_same_v<ArrayElement, Decimal256>, Decimal256,\n         std::conditional_t<std::is_same_v<ArrayElement, DateTime64>, Decimal128,\n-        std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,\n+        std::conditional_t<is_floating_point<ArrayElement>, Float64,\n         std::conditional_t<std::is_signed_v<ArrayElement>, Int64,\n             UInt64>>>>>>>>>>>;\n };\ndiff --git a/src/Functions/array/arrayDistance.cpp b/src/Functions/array/arrayDistance.cpp\nindex a1f48747eb67..8a6c26498989 100644\n--- a/src/Functions/array/arrayDistance.cpp\n+++ b/src/Functions/array/arrayDistance.cpp\n@@ -14,6 +14,7 @@\n #include <immintrin.h>\n #endif\n \n+\n namespace DB\n {\n namespace ErrorCodes\n@@ -34,7 +35,7 @@ struct L1Distance\n     template <typename FloatType>\n     struct State\n     {\n-        FloatType sum = 0;\n+        FloatType sum{};\n     };\n \n     template <typename ResultType>\n@@ -65,7 +66,7 @@ struct L2Distance\n     template <typename FloatType>\n     struct State\n     {\n-        FloatType sum = 0;\n+        FloatType sum{};\n     };\n \n     template <typename ResultType>\n@@ -90,19 +91,17 @@ struct L2Distance\n         size_t & i_y,\n         State<ResultType> & state)\n     {\n-        static constexpr bool is_float32 = std::is_same_v<ResultType, Float32>;\n-\n         __m512 sums;\n-        if constexpr (is_float32)\n+        if constexpr (sizeof(ResultType) <= 4)\n             sums = _mm512_setzero_ps();\n         else\n             sums = _mm512_setzero_pd();\n \n-        constexpr size_t n = is_float32 ? 16 : 8;\n+        constexpr size_t n = sizeof(__m512) / sizeof(ResultType);\n \n         for (; i_x + n < i_max; i_x += n, i_y += n)\n         {\n-            if constexpr (is_float32)\n+            if constexpr (sizeof(ResultType) == 4)\n             {\n                 __m512 x = _mm512_loadu_ps(data_x + i_x);\n                 __m512 y = _mm512_loadu_ps(data_y + i_y);\n@@ -118,11 +117,38 @@ struct L2Distance\n             }\n         }\n \n-        if constexpr (is_float32)\n+        if constexpr (sizeof(ResultType) <= 4)\n             state.sum = _mm512_reduce_add_ps(sums);\n         else\n             state.sum = _mm512_reduce_add_pd(sums);\n     }\n+\n+    AVX512BF16_FUNCTION_SPECIFIC_ATTRIBUTE static void accumulateCombineBF16(\n+        const BFloat16 * __restrict data_x,\n+        const BFloat16 * __restrict data_y,\n+        size_t i_max,\n+        size_t & i_x,\n+        size_t & i_y,\n+        State<Float32> & state)\n+    {\n+        __m512 sums = _mm512_setzero_ps();\n+        constexpr size_t n = sizeof(__m512) / sizeof(BFloat16);\n+\n+        for (; i_x + n < i_max; i_x += n, i_y += n)\n+        {\n+            __m512 x_1 = _mm512_cvtpbh_ps(_mm256_loadu_ps(reinterpret_cast<const Float32 *>(data_x + i_x)));\n+            __m512 x_2 = _mm512_cvtpbh_ps(_mm256_loadu_ps(reinterpret_cast<const Float32 *>(data_x + i_x + n / 2)));\n+            __m512 y_1 = _mm512_cvtpbh_ps(_mm256_loadu_ps(reinterpret_cast<const Float32 *>(data_y + i_y)));\n+            __m512 y_2 = _mm512_cvtpbh_ps(_mm256_loadu_ps(reinterpret_cast<const Float32 *>(data_y + i_y + n / 2)));\n+\n+            __m512 differences_1 = _mm512_sub_ps(x_1, y_1);\n+            __m512 differences_2 = _mm512_sub_ps(x_2, y_2);\n+            sums = _mm512_fmadd_ps(differences_1, differences_1, sums);\n+            sums = _mm512_fmadd_ps(differences_2, differences_2, sums);\n+        }\n+\n+        state.sum = _mm512_reduce_add_ps(sums);\n+    }\n #endif\n \n     template <typename ResultType>\n@@ -156,13 +182,13 @@ struct LpDistance\n     template <typename FloatType>\n     struct State\n     {\n-        FloatType sum = 0;\n+        FloatType sum{};\n     };\n \n     template <typename ResultType>\n     static void accumulate(State<ResultType> & state, ResultType x, ResultType y, const ConstParams & params)\n     {\n-        state.sum += static_cast<ResultType>(std::pow(fabs(x - y), params.power));\n+        state.sum += static_cast<ResultType>(pow(fabs(x - y), params.power));\n     }\n \n     template <typename ResultType>\n@@ -174,7 +200,7 @@ struct LpDistance\n     template <typename ResultType>\n     static ResultType finalize(const State<ResultType> & state, const ConstParams & params)\n     {\n-        return static_cast<ResultType>(std::pow(state.sum, params.inverted_power));\n+        return static_cast<ResultType>(pow(state.sum, params.inverted_power));\n     }\n };\n \n@@ -187,7 +213,7 @@ struct LinfDistance\n     template <typename FloatType>\n     struct State\n     {\n-        FloatType dist = 0;\n+        FloatType dist{};\n     };\n \n     template <typename ResultType>\n@@ -218,9 +244,9 @@ struct CosineDistance\n     template <typename FloatType>\n     struct State\n     {\n-        FloatType dot_prod = 0;\n-        FloatType x_squared = 0;\n-        FloatType y_squared = 0;\n+        FloatType dot_prod{};\n+        FloatType x_squared{};\n+        FloatType y_squared{};\n     };\n \n     template <typename ResultType>\n@@ -249,13 +275,11 @@ struct CosineDistance\n         size_t & i_y,\n         State<ResultType> & state)\n     {\n-        static constexpr bool is_float32 = std::is_same_v<ResultType, Float32>;\n-\n         __m512 dot_products;\n         __m512 x_squareds;\n         __m512 y_squareds;\n \n-        if constexpr (is_float32)\n+        if constexpr (sizeof(ResultType) <= 4)\n         {\n             dot_products = _mm512_setzero_ps();\n             x_squareds = _mm512_setzero_ps();\n@@ -268,11 +292,11 @@ struct CosineDistance\n             y_squareds = _mm512_setzero_pd();\n         }\n \n-        constexpr size_t n = is_float32 ? 16 : 8;\n+        constexpr size_t n = sizeof(__m512) / sizeof(ResultType);\n \n         for (; i_x + n < i_max; i_x += n, i_y += n)\n         {\n-            if constexpr (is_float32)\n+            if constexpr (sizeof(ResultType) == 4)\n             {\n                 __m512 x = _mm512_loadu_ps(data_x + i_x);\n                 __m512 y = _mm512_loadu_ps(data_y + i_y);\n@@ -290,7 +314,7 @@ struct CosineDistance\n             }\n         }\n \n-        if constexpr (is_float32)\n+        if constexpr (sizeof(ResultType) == 4)\n         {\n             state.dot_prod = _mm512_reduce_add_ps(dot_products);\n             state.x_squared = _mm512_reduce_add_ps(x_squareds);\n@@ -303,16 +327,48 @@ struct CosineDistance\n             state.y_squared = _mm512_reduce_add_pd(y_squareds);\n         }\n     }\n+\n+    AVX512BF16_FUNCTION_SPECIFIC_ATTRIBUTE static void accumulateCombineBF16(\n+        const BFloat16 * __restrict data_x,\n+        const BFloat16 * __restrict data_y,\n+        size_t i_max,\n+        size_t & i_x,\n+        size_t & i_y,\n+        State<Float32> & state)\n+    {\n+        __m512 dot_products;\n+        __m512 x_squareds;\n+        __m512 y_squareds;\n+\n+        dot_products = _mm512_setzero_ps();\n+        x_squareds = _mm512_setzero_ps();\n+        y_squareds = _mm512_setzero_ps();\n+\n+        constexpr size_t n = sizeof(__m512) / sizeof(BFloat16);\n+\n+        for (; i_x + n < i_max; i_x += n, i_y += n)\n+        {\n+            __m512 x = _mm512_loadu_ps(data_x + i_x);\n+            __m512 y = _mm512_loadu_ps(data_y + i_y);\n+            dot_products = _mm512_dpbf16_ps(dot_products, x, y);\n+            x_squareds = _mm512_dpbf16_ps(x_squareds, x, x);\n+            y_squareds = _mm512_dpbf16_ps(y_squareds, y, y);\n+        }\n+\n+        state.dot_prod = _mm512_reduce_add_ps(dot_products);\n+        state.x_squared = _mm512_reduce_add_ps(x_squareds);\n+        state.y_squared = _mm512_reduce_add_ps(y_squareds);\n+    }\n #endif\n \n     template <typename ResultType>\n     static ResultType finalize(const State<ResultType> & state, const ConstParams &)\n     {\n-        return 1 - state.dot_prod / sqrt(state.x_squared * state.y_squared);\n+        return 1.0f - state.dot_prod / sqrt(state.x_squared * state.y_squared);\n     }\n };\n \n-template <class Kernel>\n+template <typename Kernel>\n class FunctionArrayDistance : public IFunction\n {\n public:\n@@ -352,12 +408,13 @@ class FunctionArrayDistance : public IFunction\n             case TypeIndex::Float64:\n                 return std::make_shared<DataTypeFloat64>();\n             case TypeIndex::Float32:\n+            case TypeIndex::BFloat16:\n                 return std::make_shared<DataTypeFloat32>();\n             default:\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Arguments of function {} has nested type {}. \"\n-                    \"Supported types: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64.\",\n+                    \"Supported types: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, BFloat16, Float32, Float64.\",\n                     getName(),\n                     common_type->getName());\n         }\n@@ -369,10 +426,8 @@ class FunctionArrayDistance : public IFunction\n         {\n             case TypeIndex::Float32:\n                 return executeWithResultType<Float32>(arguments, input_rows_count);\n-                break;\n             case TypeIndex::Float64:\n                 return executeWithResultType<Float64>(arguments, input_rows_count);\n-                break;\n             default:\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected result type {}\", result_type->getName());\n         }\n@@ -388,6 +443,7 @@ class FunctionArrayDistance : public IFunction\n     ACTION(Int16)   \\\n     ACTION(Int32)   \\\n     ACTION(Int64)   \\\n+    ACTION(BFloat16) \\\n     ACTION(Float32) \\\n     ACTION(Float64)\n \n@@ -412,7 +468,7 @@ class FunctionArrayDistance : public IFunction\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Arguments of function {} has nested type {}. \"\n-                    \"Supported types: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64.\",\n+                    \"Supported types: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, BFloat16, Float32, Float64.\",\n                     getName(),\n                     type_x->getName());\n         }\n@@ -437,7 +493,7 @@ class FunctionArrayDistance : public IFunction\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Arguments of function {} has nested type {}. \"\n-                    \"Supported types: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64.\",\n+                    \"Supported types: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, BFloat16, Float32, Float64.\",\n                     getName(),\n                     type_y->getName());\n         }\n@@ -446,14 +502,10 @@ class FunctionArrayDistance : public IFunction\n     template <typename ResultType, typename LeftType, typename RightType>\n     ColumnPtr executeWithResultTypeAndLeftTypeAndRightType(ColumnPtr col_x, ColumnPtr col_y, size_t input_rows_count, const ColumnsWithTypeAndName & arguments) const\n     {\n-        if (typeid_cast<const ColumnConst *>(col_x.get()))\n-        {\n+        if (col_x->isConst())\n             return executeWithLeftArgConst<ResultType, LeftType, RightType>(col_x, col_y, input_rows_count, arguments);\n-        }\n-        if (typeid_cast<const ColumnConst *>(col_y.get()))\n-        {\n+        if (col_y->isConst())\n             return executeWithLeftArgConst<ResultType, RightType, LeftType>(col_y, col_x, input_rows_count, arguments);\n-        }\n \n         const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());\n         const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());\n@@ -497,7 +549,7 @@ class FunctionArrayDistance : public IFunction\n                     state, static_cast<ResultType>(data_x[prev]), static_cast<ResultType>(data_y[prev]), kernel_params);\n             }\n             result_data[row] = Kernel::finalize(state, kernel_params);\n-            row++;\n+            ++row;\n         }\n         return col_res;\n     }\n@@ -548,36 +600,52 @@ class FunctionArrayDistance : public IFunction\n \n             /// SIMD optimization: process multiple elements in both input arrays at once.\n             /// To avoid combinatorial explosion of SIMD kernels, focus on\n-            /// - the two most common input/output types (Float32 x Float32) --> Float32 and (Float64 x Float64) --> Float64 instead of 10 x\n-            ///   10 input types x 2 output types,\n+            /// - the three most common input/output types (BFloat16 x BFloat16) --> Float32,\n+            ///   (Float32 x Float32) --> Float32 and (Float64 x Float64) --> Float64\n+            ///   instead of 10 x 10 input types x 2 output types,\n             /// - const/non-const inputs instead of non-const/non-const inputs\n             /// - the two most common metrics L2 and cosine distance,\n             /// - the most powerful SIMD instruction set (AVX-512F).\n+            bool processed = false;\n #if USE_MULTITARGET_CODE\n-            if constexpr (std::is_same_v<ResultType, LeftType> && std::is_same_v<ResultType, RightType>) /// ResultType is Float32 or Float64\n+            /// ResultType is Float32 or Float64\n+            if constexpr (std::is_same_v<Kernel, L2Distance> || std::is_same_v<Kernel, CosineDistance>)\n             {\n-                if constexpr (std::is_same_v<Kernel, L2Distance>\n-                           || std::is_same_v<Kernel, CosineDistance>)\n+                if constexpr (std::is_same_v<ResultType, LeftType> && std::is_same_v<ResultType, RightType>)\n                 {\n                     if (isArchSupported(TargetArch::AVX512F))\n+                    {\n                         Kernel::template accumulateCombine<ResultType>(data_x.data(), data_y.data(), i + offsets_x[0], i, prev, state);\n+                        processed = true;\n+                    }\n+                }\n+                else if constexpr (std::is_same_v<Float32, ResultType> && std::is_same_v<BFloat16, LeftType> && std::is_same_v<BFloat16, RightType>)\n+                {\n+                    if (isArchSupported(TargetArch::AVX512BF16))\n+                    {\n+                        Kernel::accumulateCombineBF16(data_x.data(), data_y.data(), i + offsets_x[0], i, prev, state);\n+                        processed = true;\n+                    }\n                 }\n             }\n-#else\n-            /// Process chunks in vectorized manner\n-            static constexpr size_t VEC_SIZE = 4;\n-            typename Kernel::template State<ResultType> states[VEC_SIZE];\n-            for (; prev + VEC_SIZE < off; i += VEC_SIZE, prev += VEC_SIZE)\n+#endif\n+            if (!processed)\n             {\n-                for (size_t s = 0; s < VEC_SIZE; ++s)\n-                    Kernel::template accumulate<ResultType>(\n-                        states[s], static_cast<ResultType>(data_x[i + s]), static_cast<ResultType>(data_y[prev + s]), kernel_params);\n+                /// Process chunks in a vectorized manner.\n+                static constexpr size_t VEC_SIZE = 32;\n+                typename Kernel::template State<ResultType> states[VEC_SIZE];\n+                for (; prev + VEC_SIZE < off; i += VEC_SIZE, prev += VEC_SIZE)\n+                {\n+                    for (size_t s = 0; s < VEC_SIZE; ++s)\n+                        Kernel::template accumulate<ResultType>(\n+                            states[s], static_cast<ResultType>(data_x[i + s]), static_cast<ResultType>(data_y[prev + s]), kernel_params);\n+                }\n+\n+                for (const auto & other_state : states)\n+                    Kernel::template combine<ResultType>(state, other_state, kernel_params);\n             }\n \n-            for (const auto & other_state : states)\n-                Kernel::template combine<ResultType>(state, other_state, kernel_params);\n-#endif\n-            /// Process the tail\n+            /// Process the tail.\n             for (; prev < off; ++i, ++prev)\n             {\n                 Kernel::template accumulate<ResultType>(\n@@ -638,4 +706,5 @@ FunctionPtr createFunctionArrayL2SquaredDistance(ContextPtr context_) { return F\n FunctionPtr createFunctionArrayLpDistance(ContextPtr context_) { return FunctionArrayDistance<LpDistance>::create(context_); }\n FunctionPtr createFunctionArrayLinfDistance(ContextPtr context_) { return FunctionArrayDistance<LinfDistance>::create(context_); }\n FunctionPtr createFunctionArrayCosineDistance(ContextPtr context_) { return FunctionArrayDistance<CosineDistance>::create(context_); }\n+\n }\ndiff --git a/src/Functions/array/mapPopulateSeries.cpp b/src/Functions/array/mapPopulateSeries.cpp\nindex 4083678b209e..d2ca48ff186f 100644\n--- a/src/Functions/array/mapPopulateSeries.cpp\n+++ b/src/Functions/array/mapPopulateSeries.cpp\n@@ -452,23 +452,29 @@ class FunctionMapPopulateSeries : public IFunction\n             using ValueType = typename Types::RightType;\n \n             static constexpr bool key_and_value_are_numbers = IsDataTypeNumber<KeyType> && IsDataTypeNumber<ValueType>;\n-            static constexpr bool key_is_float = std::is_same_v<KeyType, DataTypeFloat32> || std::is_same_v<KeyType, DataTypeFloat64>;\n \n-            if constexpr (key_and_value_are_numbers && !key_is_float)\n+            if constexpr (key_and_value_are_numbers)\n             {\n-                using KeyFieldType = typename KeyType::FieldType;\n-                using ValueFieldType = typename ValueType::FieldType;\n-\n-                executeImplTyped<KeyFieldType, ValueFieldType>(\n-                    input.key_column,\n-                    input.value_column,\n-                    input.offsets_column,\n-                    input.max_key_column,\n-                    std::move(result_columns.result_key_column),\n-                    std::move(result_columns.result_value_column),\n-                    std::move(result_columns.result_offset_column));\n-\n-                return true;\n+                if constexpr (is_floating_point<typename KeyType::FieldType>)\n+                {\n+                    return false;\n+                }\n+                else\n+                {\n+                    using KeyFieldType = typename KeyType::FieldType;\n+                    using ValueFieldType = typename ValueType::FieldType;\n+\n+                    executeImplTyped<KeyFieldType, ValueFieldType>(\n+                        input.key_column,\n+                        input.value_column,\n+                        input.offsets_column,\n+                        input.max_key_column,\n+                        std::move(result_columns.result_key_column),\n+                        std::move(result_columns.result_value_column),\n+                        std::move(result_columns.result_offset_column));\n+\n+                    return true;\n+                }\n             }\n \n             return false;\ndiff --git a/src/Functions/divide.cpp b/src/Functions/divide.cpp\nindex 7c67245c382b..3947ba2d142b 100644\n--- a/src/Functions/divide.cpp\n+++ b/src/Functions/divide.cpp\n@@ -18,7 +18,7 @@ struct DivideFloatingImpl\n     template <typename Result = ResultType>\n     static NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])\n     {\n-        return static_cast<Result>(a) / b;\n+        return static_cast<Result>(a) / static_cast<Result>(b);\n     }\n \n #if USE_EMBEDDED_COMPILER\ndiff --git a/src/Functions/exp.cpp b/src/Functions/exp.cpp\nindex e67cbd6d8199..24f1d3138313 100644\n--- a/src/Functions/exp.cpp\n+++ b/src/Functions/exp.cpp\n@@ -3,6 +3,12 @@\n \n namespace DB\n {\n+\n+namespace ErrorCodes\n+{\n+extern const int NOT_IMPLEMENTED;\n+}\n+\n namespace\n {\n \n@@ -21,7 +27,14 @@ namespace\n         template <typename T>\n         static void execute(const T * src, size_t size, T * dst)\n         {\n-            NFastOps::Exp<true>(src, size, dst);\n+            if constexpr (std::is_same_v<T, BFloat16>)\n+            {\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Function `{}` is not implemented for BFloat16\", name);\n+            }\n+            else\n+            {\n+                NFastOps::Exp<true>(src, size, dst);\n+            }\n         }\n     };\n }\ndiff --git a/src/Functions/factorial.cpp b/src/Functions/factorial.cpp\nindex 9b319caad63f..83c184f50cc0 100644\n--- a/src/Functions/factorial.cpp\n+++ b/src/Functions/factorial.cpp\n@@ -21,7 +21,7 @@ struct FactorialImpl\n \n     static NO_SANITIZE_UNDEFINED ResultType apply(A a)\n     {\n-        if constexpr (std::is_floating_point_v<A> || is_over_big_int<A>)\n+        if constexpr (is_floating_point<A> || is_over_big_int<A>)\n             throw Exception(\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type of argument of function factorial, should not be floating point or big int\");\ndiff --git a/src/Functions/log.cpp b/src/Functions/log.cpp\nindex 8bebdb8d7bd3..49fc509634b7 100644\n--- a/src/Functions/log.cpp\n+++ b/src/Functions/log.cpp\n@@ -4,6 +4,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+extern const int NOT_IMPLEMENTED;\n+}\n+\n namespace\n {\n \n@@ -20,7 +25,14 @@ struct LogName { static constexpr auto name = \"log\"; };\n         template <typename T>\n         static void execute(const T * src, size_t size, T * dst)\n         {\n-            NFastOps::Log<true>(src, size, dst);\n+            if constexpr (std::is_same_v<T, BFloat16>)\n+            {\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Function `{}` is not implemented for BFloat16\", name);\n+            }\n+            else\n+            {\n+                NFastOps::Log<true>(src, size, dst);\n+            }\n         }\n     };\n \ndiff --git a/src/Functions/minus.cpp b/src/Functions/minus.cpp\nindex f3b9b8a7bcb3..a372e8d5d787 100644\n--- a/src/Functions/minus.cpp\n+++ b/src/Functions/minus.cpp\n@@ -17,8 +17,8 @@ struct MinusImpl\n     {\n         if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n         {\n-            using CastA = std::conditional_t<std::is_floating_point_v<B>, B, A>;\n-            using CastB = std::conditional_t<std::is_floating_point_v<A>, A, B>;\n+            using CastA = std::conditional_t<is_floating_point<B>, B, A>;\n+            using CastB = std::conditional_t<is_floating_point<A>, A, B>;\n \n             return static_cast<Result>(static_cast<CastA>(a)) - static_cast<Result>(static_cast<CastB>(b));\n         }\ndiff --git a/src/Functions/moduloOrZero.cpp b/src/Functions/moduloOrZero.cpp\nindex cd7873b3b9e4..5a4d15393456 100644\n--- a/src/Functions/moduloOrZero.cpp\n+++ b/src/Functions/moduloOrZero.cpp\n@@ -17,7 +17,7 @@ struct ModuloOrZeroImpl\n     template <typename Result = ResultType>\n     static Result apply(A a, B b)\n     {\n-        if constexpr (std::is_floating_point_v<ResultType>)\n+        if constexpr (is_floating_point<ResultType>)\n         {\n             /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.\n             return ResultType(a) - trunc(ResultType(a) / ResultType(b)) * ResultType(b);\ndiff --git a/src/Functions/multiply.cpp b/src/Functions/multiply.cpp\nindex 67b6fff6b58b..740ab81d0d93 100644\n--- a/src/Functions/multiply.cpp\n+++ b/src/Functions/multiply.cpp\n@@ -18,8 +18,8 @@ struct MultiplyImpl\n     {\n         if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n         {\n-            using CastA = std::conditional_t<std::is_floating_point_v<B>, B, A>;\n-            using CastB = std::conditional_t<std::is_floating_point_v<A>, A, B>;\n+            using CastA = std::conditional_t<is_floating_point<B>, B, A>;\n+            using CastB = std::conditional_t<is_floating_point<A>, A, B>;\n \n             return static_cast<Result>(static_cast<CastA>(a)) * static_cast<Result>(static_cast<CastB>(b));\n         }\ndiff --git a/src/Functions/plus.cpp b/src/Functions/plus.cpp\nindex ffb0fe2ade73..26921713f785 100644\n--- a/src/Functions/plus.cpp\n+++ b/src/Functions/plus.cpp\n@@ -19,8 +19,8 @@ struct PlusImpl\n         /// Next everywhere, static_cast - so that there is no wrong result in expressions of the form Int64 c = UInt32(a) * Int32(-1).\n         if constexpr (is_big_int_v<A> || is_big_int_v<B>)\n         {\n-            using CastA = std::conditional_t<std::is_floating_point_v<B>, B, A>;\n-            using CastB = std::conditional_t<std::is_floating_point_v<A>, A, B>;\n+            using CastA = std::conditional_t<is_floating_point<B>, B, A>;\n+            using CastB = std::conditional_t<is_floating_point<A>, A, B>;\n \n             return static_cast<Result>(static_cast<CastA>(a)) + static_cast<Result>(static_cast<CastB>(b));\n         }\ndiff --git a/src/Functions/sigmoid.cpp b/src/Functions/sigmoid.cpp\nindex d121bdc73890..bb9710a15fe5 100644\n--- a/src/Functions/sigmoid.cpp\n+++ b/src/Functions/sigmoid.cpp\n@@ -3,6 +3,12 @@\n \n namespace DB\n {\n+\n+namespace ErrorCodes\n+{\n+extern const int NOT_IMPLEMENTED;\n+}\n+\n namespace\n {\n \n@@ -21,7 +27,14 @@ namespace\n         template <typename T>\n         static void execute(const T * src, size_t size, T * dst)\n         {\n-            NFastOps::Sigmoid<>(src, size, dst);\n+            if constexpr (std::is_same_v<T, BFloat16>)\n+            {\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Function `{}` is not implemented for BFloat16\", name);\n+            }\n+            else\n+            {\n+                NFastOps::Sigmoid<>(src, size, dst);\n+            }\n         }\n     };\n }\n@@ -47,4 +60,3 @@ REGISTER_FUNCTION(Sigmoid)\n }\n \n }\n-\ndiff --git a/src/Functions/sign.cpp b/src/Functions/sign.cpp\nindex 914e1ad9e1f3..63d59e3e9dad 100644\n--- a/src/Functions/sign.cpp\n+++ b/src/Functions/sign.cpp\n@@ -13,7 +13,7 @@ struct SignImpl\n \n     static NO_SANITIZE_UNDEFINED ResultType apply(A a)\n     {\n-        if constexpr (is_decimal<A> || std::is_floating_point_v<A>)\n+        if constexpr (is_decimal<A> || is_floating_point<A>)\n             return a < A(0) ? -1 : a == A(0) ? 0 : 1;\n         else if constexpr (is_signed_v<A>)\n             return a < 0 ? -1 : a == 0 ? 0 : 1;\ndiff --git a/src/Functions/tanh.cpp b/src/Functions/tanh.cpp\nindex 62755737f708..d0e1440485b8 100644\n--- a/src/Functions/tanh.cpp\n+++ b/src/Functions/tanh.cpp\n@@ -3,6 +3,12 @@\n \n namespace DB\n {\n+\n+namespace ErrorCodes\n+{\n+extern const int NOT_IMPLEMENTED;\n+}\n+\n namespace\n {\n \n@@ -19,7 +25,14 @@ struct TanhName { static constexpr auto name = \"tanh\"; };\n         template <typename T>\n         static void execute(const T * src, size_t size, T * dst)\n         {\n-            NFastOps::Tanh<>(src, size, dst);\n+            if constexpr (std::is_same_v<T, BFloat16>)\n+            {\n+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Function `{}` is not implemented for BFloat16\", name);\n+            }\n+            else\n+            {\n+                NFastOps::Tanh<>(src, size, dst);\n+            }\n         }\n     };\n \ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 50131781e776..65808f76751a 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -1420,7 +1420,9 @@ inline bool tryReadText(UUID & x, ReadBuffer & buf) { return tryReadUUIDText(x,\n inline bool tryReadText(IPv4 & x, ReadBuffer & buf) { return tryReadIPv4Text(x, buf); }\n inline bool tryReadText(IPv6 & x, ReadBuffer & buf) { return tryReadIPv6Text(x, buf); }\n \n-inline void readText(is_floating_point auto & x, ReadBuffer & buf) { readFloatText(x, buf); }\n+template <typename T>\n+requires is_floating_point<T>\n+inline void readText(T & x, ReadBuffer & buf) { readFloatText(x, buf); }\n \n inline void readText(String & x, ReadBuffer & buf) { readEscapedString(x, buf); }\n \ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 273630935492..f7b2504f6649 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -150,11 +150,12 @@ inline void writeBoolText(bool x, WriteBuffer & buf)\n \n \n template <typename T>\n+requires is_floating_point<T>\n inline size_t writeFloatTextFastPath(T x, char * buffer)\n {\n     Int64 result = 0;\n \n-    if constexpr (std::is_same_v<T, double>)\n+    if constexpr (std::is_same_v<T, Float64>)\n     {\n         /// The library Ryu has low performance on integers.\n         /// This workaround improves performance 6..10 times.\n@@ -164,13 +165,22 @@ inline size_t writeFloatTextFastPath(T x, char * buffer)\n         else\n             result = jkj::dragonbox::to_chars_n(x, buffer) - buffer;\n     }\n-    else\n+    else if constexpr (std::is_same_v<T, Float32>)\n     {\n         if (DecomposedFloat32(x).isIntegerInRepresentableRange())\n             result = itoa(Int32(x), buffer) - buffer;\n         else\n             result = jkj::dragonbox::to_chars_n(x, buffer) - buffer;\n     }\n+    else if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 f32 = Float32(x);\n+\n+        if (DecomposedFloat32(f32).isIntegerInRepresentableRange())\n+            result = itoa(Int32(f32), buffer) - buffer;\n+        else\n+            result = jkj::dragonbox::to_chars_n(f32, buffer) - buffer;\n+    }\n \n     if (result <= 0)\n         throw Exception(ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER, \"Cannot print floating point number\");\n@@ -178,10 +188,9 @@ inline size_t writeFloatTextFastPath(T x, char * buffer)\n }\n \n template <typename T>\n+requires is_floating_point<T>\n inline void writeFloatText(T x, WriteBuffer & buf)\n {\n-    static_assert(std::is_same_v<T, double> || std::is_same_v<T, float>, \"Argument for writeFloatText must be float or double\");\n-\n     using Converter = DoubleConverter<false>;\n     if (likely(buf.available() >= Converter::MAX_REPRESENTATION_LENGTH))\n     {\n@@ -540,9 +549,9 @@ void writeJSONNumber(T x, WriteBuffer & ostr, const FormatSettings & settings)\n         writeCString(\"null\", ostr);\n     else\n     {\n-        if constexpr (std::is_floating_point_v<T>)\n+        if constexpr (is_floating_point<T>)\n         {\n-            if (std::signbit(x))\n+            if (signBit(x))\n             {\n                 if (isNaN(x))\n                     writeCString(\"-nan\", ostr);\n@@ -798,7 +807,6 @@ inline void writeXMLStringForTextElement(std::string_view s, WriteBuffer & buf)\n }\n \n /// @brief Serialize `uuid` into an array of characters in big-endian byte order.\n-/// @param uuid UUID to serialize.\n /// @return Array of characters in big-endian byte order.\n std::array<char, 36> formatUUID(const UUID & uuid);\n \n@@ -1099,7 +1107,9 @@ inline void writeText(is_integer auto x, WriteBuffer & buf)\n         writeIntText(x, buf);\n }\n \n-inline void writeText(is_floating_point auto x, WriteBuffer & buf) { writeFloatText(x, buf); }\n+template <typename T>\n+requires is_floating_point<T>\n+inline void writeText(T x, WriteBuffer & buf) { writeFloatText(x, buf); }\n \n inline void writeText(is_enum auto x, WriteBuffer & buf) { writeText(magic_enum::enum_name(x), buf); }\n \ndiff --git a/src/IO/readFloatText.cpp b/src/IO/readFloatText.cpp\nindex 17ccc1b25b7b..fb3c86fd7b68 100644\n--- a/src/IO/readFloatText.cpp\n+++ b/src/IO/readFloatText.cpp\n@@ -47,26 +47,35 @@ void assertNaN(ReadBuffer & buf)\n }\n \n \n+template void readFloatTextPrecise<BFloat16>(BFloat16 &, ReadBuffer &);\n template void readFloatTextPrecise<Float32>(Float32 &, ReadBuffer &);\n template void readFloatTextPrecise<Float64>(Float64 &, ReadBuffer &);\n+template bool tryReadFloatTextPrecise<BFloat16>(BFloat16 &, ReadBuffer &);\n template bool tryReadFloatTextPrecise<Float32>(Float32 &, ReadBuffer &);\n template bool tryReadFloatTextPrecise<Float64>(Float64 &, ReadBuffer &);\n \n+template void readFloatTextFast<BFloat16>(BFloat16 &, ReadBuffer &);\n template void readFloatTextFast<Float32>(Float32 &, ReadBuffer &);\n template void readFloatTextFast<Float64>(Float64 &, ReadBuffer &);\n+template bool tryReadFloatTextFast<BFloat16>(BFloat16 &, ReadBuffer &);\n template bool tryReadFloatTextFast<Float32>(Float32 &, ReadBuffer &);\n template bool tryReadFloatTextFast<Float64>(Float64 &, ReadBuffer &);\n \n+template void readFloatTextSimple<BFloat16>(BFloat16 &, ReadBuffer &);\n template void readFloatTextSimple<Float32>(Float32 &, ReadBuffer &);\n template void readFloatTextSimple<Float64>(Float64 &, ReadBuffer &);\n+template bool tryReadFloatTextSimple<BFloat16>(BFloat16 &, ReadBuffer &);\n template bool tryReadFloatTextSimple<Float32>(Float32 &, ReadBuffer &);\n template bool tryReadFloatTextSimple<Float64>(Float64 &, ReadBuffer &);\n \n+template void readFloatText<BFloat16>(BFloat16 &, ReadBuffer &);\n template void readFloatText<Float32>(Float32 &, ReadBuffer &);\n template void readFloatText<Float64>(Float64 &, ReadBuffer &);\n+template bool tryReadFloatText<BFloat16>(BFloat16 &, ReadBuffer &);\n template bool tryReadFloatText<Float32>(Float32 &, ReadBuffer &);\n template bool tryReadFloatText<Float64>(Float64 &, ReadBuffer &);\n \n+template bool tryReadFloatTextNoExponent<BFloat16>(BFloat16 &, ReadBuffer &);\n template bool tryReadFloatTextNoExponent<Float32>(Float32 &, ReadBuffer &);\n template bool tryReadFloatTextNoExponent<Float64>(Float64 &, ReadBuffer &);\n \ndiff --git a/src/IO/readFloatText.h b/src/IO/readFloatText.h\nindex c2fec9d4b0b6..a7fd6058dd94 100644\n--- a/src/IO/readFloatText.h\n+++ b/src/IO/readFloatText.h\n@@ -222,7 +222,6 @@ ReturnType readFloatTextPreciseImpl(T & x, ReadBuffer & buf)\n             break;\n         }\n \n-\n         char tmp_buf[MAX_LENGTH];\n         int num_copied_chars = 0;\n \n@@ -597,22 +596,85 @@ ReturnType readFloatTextSimpleImpl(T & x, ReadBuffer & buf)\n     return ReturnType(true);\n }\n \n-template <typename T> void readFloatTextPrecise(T & x, ReadBuffer & in) { readFloatTextPreciseImpl<T, void>(x, in); }\n-template <typename T> bool tryReadFloatTextPrecise(T & x, ReadBuffer & in) { return readFloatTextPreciseImpl<T, bool>(x, in); }\n+template <typename T> void readFloatTextPrecise(T & x, ReadBuffer & in)\n+{\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        readFloatTextPreciseImpl<Float32, void>(tmp, in);\n+        x = BFloat16(tmp);\n+    }\n+    else\n+        readFloatTextPreciseImpl<T, void>(x, in);\n+}\n+\n+template <typename T> bool tryReadFloatTextPrecise(T & x, ReadBuffer & in)\n+{\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        bool res = readFloatTextPreciseImpl<Float32, bool>(tmp, in);\n+        if (res)\n+            x = BFloat16(tmp);\n+        return res;\n+    }\n+    else\n+        return readFloatTextPreciseImpl<T, bool>(x, in);\n+}\n \n template <typename T> void readFloatTextFast(T & x, ReadBuffer & in)\n {\n     bool has_fractional;\n-    readFloatTextFastImpl<T, void>(x, in, has_fractional);\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        readFloatTextFastImpl<Float32, void>(tmp, in, has_fractional);\n+        x = BFloat16(tmp);\n+    }\n+    else\n+        readFloatTextFastImpl<T, void>(x, in, has_fractional);\n }\n+\n template <typename T> bool tryReadFloatTextFast(T & x, ReadBuffer & in)\n {\n     bool has_fractional;\n-    return readFloatTextFastImpl<T, bool>(x, in, has_fractional);\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        bool res = readFloatTextFastImpl<Float32, bool>(tmp, in, has_fractional);\n+        if (res)\n+            x = BFloat16(tmp);\n+        return res;\n+    }\n+    else\n+        return readFloatTextFastImpl<T, bool>(x, in, has_fractional);\n }\n \n-template <typename T> void readFloatTextSimple(T & x, ReadBuffer & in) { readFloatTextSimpleImpl<T, void>(x, in); }\n-template <typename T> bool tryReadFloatTextSimple(T & x, ReadBuffer & in) { return readFloatTextSimpleImpl<T, bool>(x, in); }\n+template <typename T> void readFloatTextSimple(T & x, ReadBuffer & in)\n+{\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        readFloatTextSimpleImpl<Float32, void>(tmp, in);\n+        x = BFloat16(tmp);\n+    }\n+    else\n+        readFloatTextSimpleImpl<T, void>(x, in);\n+}\n+\n+template <typename T> bool tryReadFloatTextSimple(T & x, ReadBuffer & in)\n+{\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        bool res = readFloatTextSimpleImpl<Float32, bool>(tmp, in);\n+        if (res)\n+            x = BFloat16(tmp);\n+        return res;\n+    }\n+    else\n+        return readFloatTextSimpleImpl<T, bool>(x, in);\n+}\n \n \n /// Implementation that is selected as default.\n@@ -624,18 +686,47 @@ template <typename T> bool tryReadFloatText(T & x, ReadBuffer & in) { return try\n template <typename T> bool tryReadFloatTextNoExponent(T & x, ReadBuffer & in)\n {\n     bool has_fractional;\n-    return readFloatTextFastImpl<T, bool, false>(x, in, has_fractional);\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        bool res = readFloatTextFastImpl<Float32, bool, false>(tmp, in, has_fractional);\n+        if (res)\n+            x = BFloat16(tmp);\n+        return res;\n+\n+    }\n+    else\n+        return readFloatTextFastImpl<T, bool, false>(x, in, has_fractional);\n }\n \n /// With a @has_fractional flag\n /// Used for input_format_try_infer_integers\n template <typename T> bool tryReadFloatTextExt(T & x, ReadBuffer & in, bool & has_fractional)\n {\n-    return readFloatTextFastImpl<T, bool>(x, in, has_fractional);\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        bool res = readFloatTextFastImpl<Float32, bool>(tmp, in, has_fractional);\n+        if (res)\n+            x = BFloat16(tmp);\n+        return res;\n+    }\n+    else\n+        return readFloatTextFastImpl<T, bool>(x, in, has_fractional);\n }\n+\n template <typename T> bool tryReadFloatTextExtNoExponent(T & x, ReadBuffer & in, bool & has_fractional)\n {\n-    return readFloatTextFastImpl<T, bool, false>(x, in, has_fractional);\n+    if constexpr (std::is_same_v<T, BFloat16>)\n+    {\n+        Float32 tmp;\n+        bool res = readFloatTextFastImpl<Float32, bool, false>(tmp, in, has_fractional);\n+        if (res)\n+            x = BFloat16(tmp);\n+        return res;\n+    }\n+    else\n+        return readFloatTextFastImpl<T, bool, false>(x, in, has_fractional);\n }\n \n }\ndiff --git a/src/Interpreters/AggregatedData.h b/src/Interpreters/AggregatedData.h\nindex 4b581c682cab..1a804afd33e0 100644\n--- a/src/Interpreters/AggregatedData.h\n+++ b/src/Interpreters/AggregatedData.h\n@@ -1,12 +1,16 @@\n #pragma once\n+\n #include <AggregateFunctions/IAggregateFunction_fwd.h>\n \n #include <Common/HashTable/FixedHashMap.h>\n #include <Common/HashTable/StringHashMap.h>\n #include <Common/HashTable/TwoLevelHashMap.h>\n #include <Common/HashTable/TwoLevelStringHashMap.h>\n+\n+\n namespace DB\n {\n+\n /** Different data structures that can be used for aggregation\n   * For efficiency, the aggregation data itself is put into the pool.\n   * Data and pool ownership (states of aggregate functions)\ndiff --git a/src/Interpreters/RowRefs.cpp b/src/Interpreters/RowRefs.cpp\nindex 1b397ab56ef3..26524218b2bf 100644\n--- a/src/Interpreters/RowRefs.cpp\n+++ b/src/Interpreters/RowRefs.cpp\n@@ -183,7 +183,7 @@ class SortedLookupVector : public SortedLookupVectorBase\n         if (sorted.load(std::memory_order_relaxed))\n             return;\n \n-        if constexpr (std::is_arithmetic_v<TKey> && !std::is_floating_point_v<TKey>)\n+        if constexpr (std::is_arithmetic_v<TKey> && !is_floating_point<TKey>)\n         {\n             if (likely(entries.size() > 256))\n             {\ndiff --git a/src/Interpreters/parseColumnsListForTableFunction.cpp b/src/Interpreters/parseColumnsListForTableFunction.cpp\nindex d8f526db592a..d3bf6f860f30 100644\n--- a/src/Interpreters/parseColumnsListForTableFunction.cpp\n+++ b/src/Interpreters/parseColumnsListForTableFunction.cpp\n@@ -20,6 +20,7 @@ namespace Setting\n     extern const SettingsBool allow_experimental_json_type;\n     extern const SettingsBool allow_experimental_object_type;\n     extern const SettingsBool allow_experimental_variant_type;\n+    extern const SettingsBool allow_experimental_bfloat16_type;\n     extern const SettingsBool allow_suspicious_fixed_string_types;\n     extern const SettingsBool allow_suspicious_low_cardinality_types;\n     extern const SettingsBool allow_suspicious_variant_types;\n@@ -42,6 +43,7 @@ DataTypeValidationSettings::DataTypeValidationSettings(const DB::Settings & sett\n     , allow_experimental_object_type(settings[Setting::allow_experimental_object_type])\n     , allow_suspicious_fixed_string_types(settings[Setting::allow_suspicious_fixed_string_types])\n     , allow_experimental_variant_type(settings[Setting::allow_experimental_variant_type])\n+    , allow_experimental_bfloat16_type(settings[Setting::allow_experimental_bfloat16_type])\n     , allow_suspicious_variant_types(settings[Setting::allow_suspicious_variant_types])\n     , validate_nested_types(settings[Setting::validate_experimental_and_suspicious_types_inside_nested_types])\n     , allow_experimental_dynamic_type(settings[Setting::allow_experimental_dynamic_type])\n@@ -105,6 +107,18 @@ void validateDataType(const DataTypePtr & type_to_check, const DataTypeValidatio\n             }\n         }\n \n+        if (!settings.allow_experimental_bfloat16_type)\n+        {\n+            if (WhichDataType(data_type).isBFloat16())\n+            {\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_COLUMN,\n+                    \"Cannot create column with type '{}' because experimental BFloat16 type is not allowed. \"\n+                    \"Set setting allow_experimental_bfloat16_type = 1 in order to allow it\",\n+                    data_type.getName());\n+            }\n+        }\n+\n         if (!settings.allow_suspicious_variant_types)\n         {\n             if (const auto * variant_type = typeid_cast<const DataTypeVariant *>(&data_type))\ndiff --git a/src/Interpreters/parseColumnsListForTableFunction.h b/src/Interpreters/parseColumnsListForTableFunction.h\nindex 6e00492c0ad5..39b9f092d89c 100644\n--- a/src/Interpreters/parseColumnsListForTableFunction.h\n+++ b/src/Interpreters/parseColumnsListForTableFunction.h\n@@ -20,6 +20,7 @@ struct DataTypeValidationSettings\n     bool allow_experimental_object_type = true;\n     bool allow_suspicious_fixed_string_types = true;\n     bool allow_experimental_variant_type = true;\n+    bool allow_experimental_bfloat16_type = true;\n     bool allow_suspicious_variant_types = true;\n     bool validate_nested_types = true;\n     bool allow_experimental_dynamic_type = true;\ndiff --git a/src/Processors/Formats/Impl/Parquet/ParquetDataValuesReader.cpp b/src/Processors/Formats/Impl/Parquet/ParquetDataValuesReader.cpp\nindex b471989076b4..4b79be988102 100644\n--- a/src/Processors/Formats/Impl/Parquet/ParquetDataValuesReader.cpp\n+++ b/src/Processors/Formats/Impl/Parquet/ParquetDataValuesReader.cpp\n@@ -580,6 +580,7 @@ template class ParquetPlainValuesReader<ColumnInt32>;\n template class ParquetPlainValuesReader<ColumnUInt32>;\n template class ParquetPlainValuesReader<ColumnInt64>;\n template class ParquetPlainValuesReader<ColumnUInt64>;\n+template class ParquetPlainValuesReader<ColumnBFloat16>;\n template class ParquetPlainValuesReader<ColumnFloat32>;\n template class ParquetPlainValuesReader<ColumnFloat64>;\n template class ParquetPlainValuesReader<ColumnDecimal<Decimal32>>;\n@@ -602,6 +603,7 @@ template class ParquetRleDictReader<ColumnInt32>;\n template class ParquetRleDictReader<ColumnUInt32>;\n template class ParquetRleDictReader<ColumnInt64>;\n template class ParquetRleDictReader<ColumnUInt64>;\n+template class ParquetRleDictReader<ColumnBFloat16>;\n template class ParquetRleDictReader<ColumnFloat32>;\n template class ParquetRleDictReader<ColumnFloat64>;\n template class ParquetRleDictReader<ColumnDecimal<Decimal32>>;\ndiff --git a/src/Processors/Formats/Impl/Parquet/ParquetLeafColReader.cpp b/src/Processors/Formats/Impl/Parquet/ParquetLeafColReader.cpp\nindex c3c7db510ed3..328dd37107ea 100644\n--- a/src/Processors/Formats/Impl/Parquet/ParquetLeafColReader.cpp\n+++ b/src/Processors/Formats/Impl/Parquet/ParquetLeafColReader.cpp\n@@ -644,6 +644,7 @@ template class ParquetLeafColReader<ColumnInt32>;\n template class ParquetLeafColReader<ColumnUInt32>;\n template class ParquetLeafColReader<ColumnInt64>;\n template class ParquetLeafColReader<ColumnUInt64>;\n+template class ParquetLeafColReader<ColumnBFloat16>;\n template class ParquetLeafColReader<ColumnFloat32>;\n template class ParquetLeafColReader<ColumnFloat64>;\n template class ParquetLeafColReader<ColumnString>;\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex a0d4d1d349e4..fa581c705f2a 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -3156,3 +3156,4 @@ znode\n znodes\n zookeeperSessionUptime\n zstd\n+BFloat\n",
  "test_patch": "diff --git a/src/Columns/tests/gtest_column_vector.cpp b/src/Columns/tests/gtest_column_vector.cpp\nindex b71d4a095ab2..3a084a890793 100644\n--- a/src/Columns/tests/gtest_column_vector.cpp\n+++ b/src/Columns/tests/gtest_column_vector.cpp\n@@ -93,6 +93,7 @@ TEST(ColumnVector, Filter)\n     testFilter<Int64>();\n     testFilter<UInt128>();\n     testFilter<Int256>();\n+    testFilter<BFloat16>();\n     testFilter<Float32>();\n     testFilter<Float64>();\n     testFilter<UUID>();\ndiff --git a/src/Columns/tests/gtest_low_cardinality.cpp b/src/Columns/tests/gtest_low_cardinality.cpp\nindex ce16d2cadb1a..301fa2a60904 100644\n--- a/src/Columns/tests/gtest_low_cardinality.cpp\n+++ b/src/Columns/tests/gtest_low_cardinality.cpp\n@@ -45,6 +45,7 @@ TEST(ColumnLowCardinality, Insert)\n     testLowCardinalityNumberInsert<Int128>(std::make_shared<DataTypeInt128>());\n     testLowCardinalityNumberInsert<Int256>(std::make_shared<DataTypeInt256>());\n \n+    testLowCardinalityNumberInsert<BFloat16>(std::make_shared<DataTypeBFloat16>());\n     testLowCardinalityNumberInsert<Float32>(std::make_shared<DataTypeFloat32>());\n     testLowCardinalityNumberInsert<Float64>(std::make_shared<DataTypeFloat64>());\n }\ndiff --git a/tests/performance/avg_weighted.xml b/tests/performance/avg_weighted.xml\nindex edf3c19fdfa9..ec1b7aae5c2c 100644\n--- a/tests/performance/avg_weighted.xml\n+++ b/tests/performance/avg_weighted.xml\n@@ -1,6 +1,5 @@\n <test>\n     <settings>\n-        <allow_experimental_bigint_types>1</allow_experimental_bigint_types>\n         <max_threads>1</max_threads>\n         <max_insert_threads>8</max_insert_threads>\n     </settings>\ndiff --git a/tests/performance/reinterpret_as.xml b/tests/performance/reinterpret_as.xml\nindex d05ef3bb0389..2e0fa0571c3a 100644\n--- a/tests/performance/reinterpret_as.xml\n+++ b/tests/performance/reinterpret_as.xml\n@@ -1,6 +1,5 @@\n <test>\n     <settings>\n-        <allow_experimental_bigint_types>1</allow_experimental_bigint_types>\n         <max_memory_usage>15G</max_memory_usage>\n     </settings>\n \ndiff --git a/tests/queries/0_stateless/01035_avg.sql b/tests/queries/0_stateless/01035_avg.sql\nindex a3cb35a80ec1..0f7baddaec57 100644\n--- a/tests/queries/0_stateless/01035_avg.sql\n+++ b/tests/queries/0_stateless/01035_avg.sql\n@@ -1,5 +1,3 @@\n-SET allow_experimental_bigint_types=1;\n-\n CREATE TABLE IF NOT EXISTS test_01035_avg (\n     i8 Int8         DEFAULT i64,\n     i16 Int16       DEFAULT i64,\ndiff --git a/tests/queries/0_stateless/01182_materialized_view_different_structure.sql b/tests/queries/0_stateless/01182_materialized_view_different_structure.sql\nindex 485f99859744..7e41172bd0c1 100644\n--- a/tests/queries/0_stateless/01182_materialized_view_different_structure.sql\n+++ b/tests/queries/0_stateless/01182_materialized_view_different_structure.sql\n@@ -20,7 +20,6 @@ SELECT sum(value) FROM (SELECT number, sum(number) AS value FROM (SELECT *, toDe\n CREATE TABLE src (n UInt64, s FixedString(16)) ENGINE=Memory;\n CREATE TABLE dst (n UInt8, s String) ENGINE = Memory;\n CREATE MATERIALIZED VIEW mv TO dst (n String) AS SELECT * FROM src;\n-SET allow_experimental_bigint_types=1;\n CREATE TABLE dist (n Int128) ENGINE=Distributed(test_cluster_two_shards, currentDatabase(), mv);\n \n INSERT INTO src SELECT number, toString(number) FROM numbers(1000);\ndiff --git a/tests/queries/0_stateless/01440_big_int_exotic_casts.sql b/tests/queries/0_stateless/01440_big_int_exotic_casts.sql\nindex 42fde9da01b9..f411af897e8d 100644\n--- a/tests/queries/0_stateless/01440_big_int_exotic_casts.sql\n+++ b/tests/queries/0_stateless/01440_big_int_exotic_casts.sql\n@@ -32,8 +32,6 @@ SELECT number y, toInt128(number) - y, toInt256(number) - y, toUInt256(number) -\n SELECT -number y, toInt128(number) + y, toInt256(number) + y, toUInt256(number) + y FROM numbers_mt(10) ORDER BY number;\n \n \n-SET allow_experimental_bigint_types = 1;\n-\n DROP TABLE IF EXISTS t;\n CREATE TABLE t (x UInt64, i256 Int256, u256 UInt256, d256 Decimal256(2)) ENGINE = Memory;\n \ndiff --git a/tests/queries/0_stateless/01554_bloom_filter_index_big_integer_uuid.sql b/tests/queries/0_stateless/01554_bloom_filter_index_big_integer_uuid.sql\nindex 3472f41092da..f82fe39f4397 100644\n--- a/tests/queries/0_stateless/01554_bloom_filter_index_big_integer_uuid.sql\n+++ b/tests/queries/0_stateless/01554_bloom_filter_index_big_integer_uuid.sql\n@@ -1,5 +1,3 @@\n-SET allow_experimental_bigint_types = 1;\n-\n CREATE TABLE 01154_test (x Int128, INDEX ix_x x TYPE bloom_filter(0.01) GRANULARITY 1) ENGINE = MergeTree() ORDER BY x SETTINGS index_granularity=8192;\n INSERT INTO 01154_test VALUES (1), (2), (3);\n SELECT x FROM 01154_test WHERE x = 1;\ndiff --git a/tests/queries/0_stateless/01622_byte_size.sql b/tests/queries/0_stateless/01622_byte_size.sql\nindex 9f9de4e58e92..f73011f4151d 100644\n--- a/tests/queries/0_stateless/01622_byte_size.sql\n+++ b/tests/queries/0_stateless/01622_byte_size.sql\n@@ -4,8 +4,6 @@\n select '';\n select '# byteSize';\n \n-set allow_experimental_bigint_types = 1;\n-\n -- numbers #0 --\n select '';\n select 'byteSize for numbers #0';\ndiff --git a/tests/queries/0_stateless/01721_dictionary_decimal_p_s.sql b/tests/queries/0_stateless/01721_dictionary_decimal_p_s.sql\nindex 272bd2d71040..57483430cc09 100644\n--- a/tests/queries/0_stateless/01721_dictionary_decimal_p_s.sql\n+++ b/tests/queries/0_stateless/01721_dictionary_decimal_p_s.sql\n@@ -1,6 +1,5 @@\n -- Tags: no-parallel\n \n-set allow_experimental_bigint_types=1;\n drop database if exists db_01721;\n drop table if exists db_01721.table_decimal_dict;\n drop dictionary if exists db_01721.decimal_dict;\n@@ -77,4 +76,3 @@ SELECT dictGet('db_01721.decimal_dict', 'Decimal32_', toUInt64(5000)),\n drop table if exists table_decimal_dict;\n drop dictionary if exists cache_dict;\n drop database if exists db_01721;\n-\ndiff --git a/tests/queries/0_stateless/01804_dictionary_decimal256_type.sql b/tests/queries/0_stateless/01804_dictionary_decimal256_type.sql\nindex 08a8d0feb27e..32b029442b97 100644\n--- a/tests/queries/0_stateless/01804_dictionary_decimal256_type.sql\n+++ b/tests/queries/0_stateless/01804_dictionary_decimal256_type.sql\n@@ -1,7 +1,5 @@\n -- Tags: no-parallel\n \n-SET allow_experimental_bigint_types = 1;\n-\n DROP TABLE IF EXISTS dictionary_decimal_source_table;\n CREATE TABLE dictionary_decimal_source_table\n (\ndiff --git a/tests/queries/0_stateless/01875_ssd_cache_dictionary_decimal256_type.sh b/tests/queries/0_stateless/01875_ssd_cache_dictionary_decimal256_type.sh\nindex 1294ba53e82f..2a24a9316969 100755\n--- a/tests/queries/0_stateless/01875_ssd_cache_dictionary_decimal256_type.sh\n+++ b/tests/queries/0_stateless/01875_ssd_cache_dictionary_decimal256_type.sh\n@@ -6,8 +6,6 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n . \"$CURDIR\"/../shell_config.sh\n \n $CLICKHOUSE_CLIENT --query=\"\n-    SET allow_experimental_bigint_types = 1;\n-\n     DROP TABLE IF EXISTS dictionary_decimal_source_table;\n     CREATE TABLE dictionary_decimal_source_table\n     (\ndiff --git a/tests/queries/0_stateless/03269_bf16.reference b/tests/queries/0_stateless/03269_bf16.reference\nnew file mode 100644\nindex 000000000000..896cc3076236\n--- /dev/null\n+++ b/tests/queries/0_stateless/03269_bf16.reference\n@@ -0,0 +1,47 @@\n+1\t-1\t1.09375\t-1.09375\t1\t-1\t1.09375\t-1.09375\t18446744000000000000\t-0\tinf\t-inf\tnan\n+1.09375\t1.09375\t1.09375\t1\n+1\t1\t0\t1\t1\n+0\t2.1875\t1.1962891\t1\tFloat32\tFloat32\tFloat32\tFloat64\n+-0.006250000000000089\t2.19375\t1.203125\t1.0057142857142858\tFloat64\tFloat64\tFloat64\tFloat64\n+0\t0\t1\t0\n+1000\t1000\t1\t0\n+2000\t2000\t1\t0\n+3000\t2992\t0\t8\n+4000\t4000\t1\t0\n+5000\t4992\t0\t8\n+6000\t5984\t0\t16\n+7000\t6976\t0\t24\n+8000\t8000\t1\t0\n+9000\t8960\t0\t40\n+49995000\t49855104\t4999.5\t4985.5104\t0\t0\t9999\t9984\t10000\t925\t10000\t925\n+0\t0\t1\t0\n+1000\t1000\t1\t0\n+2000\t2000\t1\t0\n+3000\t2992\t0\t8\n+4000\t4000\t1\t0\n+5000\t4992\t0\t8\n+6000\t5984\t0\t16\n+7000\t6976\t0\t24\n+8000\t8000\t1\t0\n+9000\t8960\t0\t40\n+49995000\t49855104\t4999.5\t4985.5104\t0\t0\t9999\t9984\t10000\t925\t10000\t925\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+a32:                        [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,8.5,9,9.5,10,10.5,11,11.5,12,12.5,13,13.5,14,14.5,15,15.5,16,16.5,17,17.5,18,18.5,19,19.5,20,20.5,21,21.5,22,22.5,23,23.5,24,24.5,25,25.5,26,26.5,27,27.5,28,28.5,29,29.5,30,30.5,31,31.5,32,32.5,33,33.5,34,34.5,35,35.5,36,36.5,37,37.5,38,38.5,39,39.5,40,40.5,41,41.5,42,42.5,43,43.5,44,44.5,45,45.5,46,46.5,47,47.5,48,48.5,49,49.5,50,50.5,51,51.5,52,52.5,53,53.5,54,54.5,55,55.5,56,56.5,57,57.5,58,58.5,59,59.5,60,60.5,61,61.5,62,62.5,63,63.5,64,64.5,65,65.5,66,66.5,67,67.5,68,68.5,69,69.5,70,70.5,71,71.5,72,72.5,73,73.5,74,74.5,75,75.5,76,76.5,77,77.5,78,78.5,79,79.5,80,80.5,81,81.5,82,82.5,83,83.5,84,84.5,85,85.5,86,86.5,87,87.5,88,88.5,89,89.5,90,90.5,91,91.5,92,92.5,93,93.5,94,94.5,95,95.5,96,96.5,97,97.5,98,98.5,99,99.5,100,100.5,101,101.5,102,102.5,103,103.5,104,104.5,105,105.5,106,106.5,107,107.5,108,108.5,109,109.5,110,110.5,111,111.5,112,112.5,113,113.5,114,114.5,115,115.5,116,116.5,117,117.5,118,118.5,119,119.5,120,120.5,121,121.5,122,122.5,123,123.5,124,124.5,125,125.5,126,126.5,127,127.5,128,128.5,129,129.5,130,130.5,131,131.5,132,132.5,133,133.5,134,134.5,135,135.5,136,136.5,137,137.5,138,138.5,139,139.5,140,140.5,141,141.5,142,142.5,143,143.5,144,144.5,145,145.5,146,146.5,147,147.5,148,148.5,149,149.5,150,150.5,151,151.5,152,152.5,153,153.5,154,154.5,155,155.5,156,156.5,157,157.5,158,158.5,159,159.5,160,160.5,161,161.5,162,162.5,163,163.5,164,164.5,165,165.5,166,166.5,167,167.5,168,168.5,169,169.5,170,170.5,171,171.5,172,172.5,173,173.5,174,174.5,175,175.5,176,176.5,177,177.5,178,178.5,179,179.5,180,180.5,181,181.5,182,182.5,183,183.5,184,184.5,185,185.5,186,186.5,187,187.5,188,188.5,189,189.5,190,190.5,191,191.5]\n+a16:                        [0,0.5,1,1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,8.5,9,9.5,10,10.5,11,11.5,12,12.5,13,13.5,14,14.5,15,15.5,16,16.5,17,17.5,18,18.5,19,19.5,20,20.5,21,21.5,22,22.5,23,23.5,24,24.5,25,25.5,26,26.5,27,27.5,28,28.5,29,29.5,30,30.5,31,31.5,32,32.5,33,33.5,34,34.5,35,35.5,36,36.5,37,37.5,38,38.5,39,39.5,40,40.5,41,41.5,42,42.5,43,43.5,44,44.5,45,45.5,46,46.5,47,47.5,48,48.5,49,49.5,50,50.5,51,51.5,52,52.5,53,53.5,54,54.5,55,55.5,56,56.5,57,57.5,58,58.5,59,59.5,60,60.5,61,61.5,62,62.5,63,63.5,64,64.5,65,65.5,66,66.5,67,67.5,68,68.5,69,69.5,70,70.5,71,71.5,72,72.5,73,73.5,74,74.5,75,75.5,76,76.5,77,77.5,78,78.5,79,79.5,80,80.5,81,81.5,82,82.5,83,83.5,84,84.5,85,85.5,86,86.5,87,87.5,88,88.5,89,89.5,90,90.5,91,91.5,92,92.5,93,93.5,94,94.5,95,95.5,96,96.5,97,97.5,98,98.5,99,99.5,100,100.5,101,101.5,102,102.5,103,103.5,104,104.5,105,105.5,106,106.5,107,107.5,108,108.5,109,109.5,110,110.5,111,111.5,112,112.5,113,113.5,114,114.5,115,115.5,116,116.5,117,117.5,118,118.5,119,119.5,120,120.5,121,121.5,122,122.5,123,123.5,124,124.5,125,125.5,126,126.5,127,127.5,128,128,129,129,130,130,131,131,132,132,133,133,134,134,135,135,136,136,137,137,138,138,139,139,140,140,141,141,142,142,143,143,144,144,145,145,146,146,147,147,148,148,149,149,150,150,151,151,152,152,153,153,154,154,155,155,156,156,157,157,158,158,159,159,160,160,161,161,162,162,163,163,164,164,165,165,166,166,167,167,168,168,169,169,170,170,171,171,172,172,173,173,174,174,175,175,176,176,177,177,178,178,179,179,180,180,181,181,182,182,183,183,184,184,185,185,186,186,187,187,188,188,189,189,190,190,191,191]\n+a32_1:                      [1,1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,8.5,9,9.5,10,10.5,11,11.5,12,12.5,13,13.5,14,14.5,15,15.5,16,16.5,17,17.5,18,18.5,19,19.5,20,20.5,21,21.5,22,22.5,23,23.5,24,24.5,25,25.5,26,26.5,27,27.5,28,28.5,29,29.5,30,30.5,31,31.5,32,32.5,33,33.5,34,34.5,35,35.5,36,36.5,37,37.5,38,38.5,39,39.5,40,40.5,41,41.5,42,42.5,43,43.5,44,44.5,45,45.5,46,46.5,47,47.5,48,48.5,49,49.5,50,50.5,51,51.5,52,52.5,53,53.5,54,54.5,55,55.5,56,56.5,57,57.5,58,58.5,59,59.5,60,60.5,61,61.5,62,62.5,63,63.5,64,64.5,65,65.5,66,66.5,67,67.5,68,68.5,69,69.5,70,70.5,71,71.5,72,72.5,73,73.5,74,74.5,75,75.5,76,76.5,77,77.5,78,78.5,79,79.5,80,80.5,81,81.5,82,82.5,83,83.5,84,84.5,85,85.5,86,86.5,87,87.5,88,88.5,89,89.5,90,90.5,91,91.5,92,92.5,93,93.5,94,94.5,95,95.5,96,96.5,97,97.5,98,98.5,99,99.5,100,100.5,101,101.5,102,102.5,103,103.5,104,104.5,105,105.5,106,106.5,107,107.5,108,108.5,109,109.5,110,110.5,111,111.5,112,112.5,113,113.5,114,114.5,115,115.5,116,116.5,117,117.5,118,118.5,119,119.5,120,120.5,121,121.5,122,122.5,123,123.5,124,124.5,125,125.5,126,126.5,127,127.5,128,128.5,129,129.5,130,130.5,131,131.5,132,132.5,133,133.5,134,134.5,135,135.5,136,136.5,137,137.5,138,138.5,139,139.5,140,140.5,141,141.5,142,142.5,143,143.5,144,144.5,145,145.5,146,146.5,147,147.5,148,148.5,149,149.5,150,150.5,151,151.5,152,152.5,153,153.5,154,154.5,155,155.5,156,156.5,157,157.5,158,158.5,159,159.5,160,160.5,161,161.5,162,162.5,163,163.5,164,164.5,165,165.5,166,166.5,167,167.5,168,168.5,169,169.5,170,170.5,171,171.5,172,172.5,173,173.5,174,174.5,175,175.5,176,176.5,177,177.5,178,178.5,179,179.5,180,180.5,181,181.5,182,182.5,183,183.5,184,184.5,185,185.5,186,186.5,187,187.5,188,188.5,189,189.5,190,190.5,191,191.5,192,192.5]\n+a16_1:                      [1,1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,8.5,9,9.5,10,10.5,11,11.5,12,12.5,13,13.5,14,14.5,15,15.5,16,16.5,17,17.5,18,18.5,19,19.5,20,20.5,21,21.5,22,22.5,23,23.5,24,24.5,25,25.5,26,26.5,27,27.5,28,28.5,29,29.5,30,30.5,31,31.5,32,32.5,33,33.5,34,34.5,35,35.5,36,36.5,37,37.5,38,38.5,39,39.5,40,40.5,41,41.5,42,42.5,43,43.5,44,44.5,45,45.5,46,46.5,47,47.5,48,48.5,49,49.5,50,50.5,51,51.5,52,52.5,53,53.5,54,54.5,55,55.5,56,56.5,57,57.5,58,58.5,59,59.5,60,60.5,61,61.5,62,62.5,63,63.5,64,64.5,65,65.5,66,66.5,67,67.5,68,68.5,69,69.5,70,70.5,71,71.5,72,72.5,73,73.5,74,74.5,75,75.5,76,76.5,77,77.5,78,78.5,79,79.5,80,80.5,81,81.5,82,82.5,83,83.5,84,84.5,85,85.5,86,86.5,87,87.5,88,88.5,89,89.5,90,90.5,91,91.5,92,92.5,93,93.5,94,94.5,95,95.5,96,96.5,97,97.5,98,98.5,99,99.5,100,100.5,101,101.5,102,102.5,103,103.5,104,104.5,105,105.5,106,106.5,107,107.5,108,108.5,109,109.5,110,110.5,111,111.5,112,112.5,113,113.5,114,114.5,115,115.5,116,116.5,117,117.5,118,118.5,119,119.5,120,120.5,121,121.5,122,122.5,123,123.5,124,124.5,125,125.5,126,126.5,127,127.5,128,128.5,129,129,130,130,131,131,132,132,133,133,134,134,135,135,136,136,137,137,138,138,139,139,140,140,141,141,142,142,143,143,144,144,145,145,146,146,147,147,148,148,149,149,150,150,151,151,152,152,153,153,154,154,155,155,156,156,157,157,158,158,159,159,160,160,161,161,162,162,163,163,164,164,165,165,166,166,167,167,168,168,169,169,170,170,171,171,172,172,173,173,174,174,175,175,176,176,177,177,178,178,179,179,180,180,181,181,182,182,183,183,184,184,185,185,186,186,187,187,188,188,189,189,190,190,191,191,192,192]\n+dotProduct(a32, a32_1):     4736944 -- 4.74 million\n+dotProduct(a16, a16_1):     4726688 -- 4.73 million\n+cosineDistance(a32, a32_1): 0.000010093636084174129\n+cosineDistance(a16, a16_1): 0.00001010226319664298\n+L2Distance(a32, a32_1):     19.595917942265423\n+L2Distance(a16, a16_1):     19.595917942265423\n+L1Distance(a32, a32_1):     384\n+L1Distance(a16, a16_1):     384\n+LinfDistance(a32, a32_1):   1\n+LinfDistance(a16, a16_1):   1\n+LpDistance(a32, a32_1, 5):  3.2875036590344515\n+LpDistance(a16, a16_1, 5):  3.2875036590344515\n+1.09375\t8C3F\t1000110000111111\t2\t16268\t8C3F\n+1.09375\t1\t1.09375\t1.0859375\t0\ndiff --git a/tests/queries/0_stateless/03269_bf16.sql b/tests/queries/0_stateless/03269_bf16.sql\nnew file mode 100644\nindex 000000000000..b332a6e31199\n--- /dev/null\n+++ b/tests/queries/0_stateless/03269_bf16.sql\n@@ -0,0 +1,100 @@\n+SET allow_experimental_bfloat16_type = 1;\n+\n+-- This is a smoke test, non exhaustive.\n+\n+-- Conversions\n+\n+SELECT\n+    1::BFloat16,\n+    -1::BFloat16,\n+    1.1::BFloat16,\n+    -1.1::BFloat16,\n+    CAST(1 AS BFloat16),\n+    CAST(-1 AS BFloat16),\n+    CAST(1.1 AS BFloat16),\n+    CAST(-1.1 AS BFloat16),\n+    CAST(0xFFFFFFFFFFFFFFFF AS BFloat16),\n+    CAST(-0.0 AS BFloat16),\n+    CAST(inf AS BFloat16),\n+    CAST(-inf AS BFloat16),\n+    CAST(nan AS BFloat16);\n+\n+-- Conversions back\n+\n+SELECT\n+    CAST(1.1::BFloat16 AS BFloat16),\n+    CAST(1.1::BFloat16 AS Float32),\n+    CAST(1.1::BFloat16 AS Float64),\n+    CAST(1.1::BFloat16 AS Int8);\n+\n+-- Comparisons\n+\n+SELECT\n+    1.1::BFloat16 = 1.1::BFloat16,\n+    1.1::BFloat16 < 1.1,\n+    1.1::BFloat16 > 1.1,\n+    1.1::BFloat16 > 1,\n+    1.1::BFloat16 = 1.09375;\n+\n+-- Arithmetic\n+\n+SELECT\n+    1.1::BFloat16 - 1.1::BFloat16 AS a,\n+    1.1::BFloat16 + 1.1::BFloat16 AS b,\n+    1.1::BFloat16 * 1.1::BFloat16 AS c,\n+    1.1::BFloat16 / 1.1::BFloat16 AS d,\n+    toTypeName(a), toTypeName(b), toTypeName(c), toTypeName(d);\n+\n+SELECT\n+    1.1::BFloat16 - 1.1 AS a,\n+    1.1 + 1.1::BFloat16 AS b,\n+    1.1::BFloat16 * 1.1 AS c,\n+    1.1 / 1.1::BFloat16 AS d,\n+    toTypeName(a), toTypeName(b), toTypeName(c), toTypeName(d);\n+\n+-- Tables\n+\n+DROP TABLE IF EXISTS t;\n+CREATE TEMPORARY TABLE t (n UInt64, x BFloat16);\n+INSERT INTO t SELECT number, number FROM numbers(10000);\n+SELECT *, n = x, n - x FROM t WHERE n % 1000 = 0 ORDER BY n;\n+\n+-- Aggregate functions\n+\n+SELECT sum(n), sum(x), avg(n), avg(x), min(n), min(x), max(n), max(x), uniq(n), uniq(x), uniqExact(n), uniqExact(x) FROM t;\n+\n+-- MergeTree\n+\n+DROP TABLE t;\n+CREATE TABLE t (n UInt64, x BFloat16) ENGINE = MergeTree ORDER BY n;\n+INSERT INTO t SELECT number, number FROM numbers(10000);\n+SELECT *, n = x, n - x FROM t WHERE n % 1000 = 0 ORDER BY n;\n+SELECT sum(n), sum(x), avg(n), avg(x), min(n), min(x), max(n), max(x), uniq(n), uniq(x), uniqExact(n), uniqExact(x) FROM t;\n+\n+-- Distances\n+\n+WITH\n+    arrayMap(x -> toFloat32(x) / 2, range(384)) AS a32,\n+    arrayMap(x -> toBFloat16(x) / 2, range(384)) AS a16,\n+    arrayMap(x -> x + 1, a32) AS a32_1,\n+    arrayMap(x -> x + 1, a16) AS a16_1\n+SELECT a32, a16, a32_1, a16_1,\n+    dotProduct(a32, a32_1), dotProduct(a16, a16_1),\n+    cosineDistance(a32, a32_1), cosineDistance(a16, a16_1),\n+    L2Distance(a32, a32_1), L2Distance(a16, a16_1),\n+    L1Distance(a32, a32_1), L1Distance(a16, a16_1),\n+    LinfDistance(a32, a32_1), LinfDistance(a16, a16_1),\n+    LpDistance(a32, a32_1, 5), LpDistance(a16, a16_1, 5)\n+FORMAT Vertical;\n+\n+-- Introspection\n+\n+SELECT 1.1::BFloat16 AS x,\n+    hex(x), bin(x),\n+    byteSize(x),\n+    reinterpretAsUInt16(x), hex(reinterpretAsString(x));\n+\n+-- Rounding (this could be not towards the nearest)\n+\n+SELECT 1.1::BFloat16 AS x,\n+    round(x), round(x, 1), round(x, 2), round(x, -1);\ndiff --git a/tests/queries/0_stateless/03271_benchmark_metrics.reference b/tests/queries/0_stateless/03271_benchmark_metrics.reference\nnew file mode 100644\nindex 000000000000..573541ac9702\n--- /dev/null\n+++ b/tests/queries/0_stateless/03271_benchmark_metrics.reference\n@@ -0,0 +1,1 @@\n+0\ndiff --git a/tests/queries/0_stateless/03271_benchmark_metrics.sh b/tests/queries/0_stateless/03271_benchmark_metrics.sh\nnew file mode 100755\nindex 000000000000..23bd39fa987f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03271_benchmark_metrics.sh\n@@ -0,0 +1,10 @@\n+#!/usr/bin/env bash\n+\n+set -e\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+# A query with two seconds sleep cannot be processed with QPS > 0.5\n+$CLICKHOUSE_BENCHMARK --query \"SELECT sleep(2)\" 2>&1 | grep -m1 -o -P 'QPS: \\d+\\.\\d+' | $CLICKHOUSE_LOCAL --query \"SELECT throwIf(extract(line, 'QPS: (.+)')::Float64 > 0.75) FROM table\" --input-format LineAsString\n",
  "problem_statement": "Add `BFloat16` data type\n**Use case**\r\n\r\nMachine learning datasets, for example, #44134\r\n\r\n**Describe the solution you'd like**\r\n\r\nUse the compiler-provided data type or write a trivial wrapper.\r\nIdeally, implement the specializations for L* distances and norms.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nThe alternative is described in #44134\r\n\r\n**Additional context**\r\n\r\nUpdating LLVM and Clang to 16 is good for this task.\r\nhttps://www.phoronix.com/news/GCC-LLVM-bf16-BFloat16-Type\n[types] Add BFloat16 with Float32 wrapper\n<!---\r\nA technical comment, you are free to remove or leave it as it is when PR is created\r\nThe following categories are used in the next scripts, update them accordingly\r\nutils/changelog/changelog.py\r\ntests/ci/cancel_and_rerun_workflow_lambda/app.py\r\n-->\r\n### Changelog category (leave one):\r\n- New Feature\r\n\r\n### Changelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nBFloat16 type support add\r\n\r\n### Documentation entry for user-facing changes\r\n\r\n- [ ] Documentation is written (mandatory for new features)\r\nMotivation: https://github.com/ClickHouse/ClickHouse/issues/44206\r\n<!---\r\nDirectly edit documentation source files in the \"docs\" folder with the same pull-request as code changes\r\n\r\nor\r\n\r\nAdd a user-readable short description of the changes that should be added to docs.clickhouse.com below.\r\n\r\nAt a minimum, the following information should be added (but add more as needed).\r\n- Motivation: Why is this function, table engine, etc. useful to ClickHouse users?\r\n\r\n- Parameters: If the feature being added takes arguments, options or is influenced by settings, please list them below with a brief explanation.\r\n\r\n- Example use: A query or command.\r\n-->\r\n\r\n\r\n> Information about CI checks: https://clickhouse.com/docs/en/development/continuous-integration/\r\n\n",
  "hints_text": "May I have a try ?\n@lingtaolf, please do.\n<!-- automatic status comment for PR #49937 from shaprunovk/ClickHouse:bfloat16 -->\nThis is an automated comment for commit ac49c6bc0a36a2c61119644988fb05402a85051c with description of existing statuses. It's updated for the latest CI running\nThe full report is available [here](https://s3.amazonaws.com/clickhouse-test-reports/49937/ac49c6bc0a36a2c61119644988fb05402a85051c/ci_running.html)\nThe overall status of the commit is \ud83d\udd34 failure\n\n<table><thead><tr><th>Check name</th><th>Description</th><th>Status</th></tr></thead>\n<tbody><tr><td>CI running</td><td>A meta-check that indicates the running CI. Normally, it's in <b>success</b> or <b>pending</b> state. The failed status indicates some problems with the PR</td><td>\ud83d\udfe1 pending</td></tr>\n<tr><td>Docs Check</td><td>Builds and tests the documentation</td><td>\ud83d\udfe1 pending</td></tr>\n<tr><td>Fast test</td><td>Normally this is the first check that is ran for a PR. It builds ClickHouse and runs most of <a href=\"https://clickhouse.com/docs/en/development/tests#functional-tests\">stateless functional tests</a>, omitting some. If it fails, further checks are not started until it is fixed. Look at the report to see which tests fail, then reproduce the failure locally as described <a href=\"https://clickhouse.com/docs/en/development/tests#functional-test-locally\">here</a></td><td>\ud83d\udd34 failure</td></tr>\n<tr><td>Mergeable Check</td><td>Checks if all other necessary checks are successful</td><td>\ud83d\udd34 failure</td></tr>\n<tr><td>Push to Dockerhub</td><td>The check for building and pushing the CI related docker images to docker hub</td><td>\ud83d\udfe2 success</td></tr>\n<tr><td>Style Check</td><td>Runs a set of checks to keep the code style clean. If some of tests failed, see the related log from the report</td><td>\ud83d\udd34 failure</td></tr>\n</table>\nCould I convert an existing column of type Float32 to BFloat16?\n> Could I convert an existing column of type Float32 to BFloat16?\r\n\r\nStill in progress, but when it's ready you will be able to",
  "created_at": "2024-06-01T00:48:35Z",
  "modified_files": [
    "b/base/base/BFloat16.h",
    "base/base/DecomposedFloat.h",
    "base/base/EnumReflection.h",
    "base/base/TypeLists.h",
    "base/base/TypeName.h",
    "base/base/extended_types.h",
    "ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt",
    "cmake/cpu_features.cmake",
    "cmake/linux/default_libs.cmake",
    "docs/en/sql-reference/data-types/float.md",
    "programs/benchmark/Benchmark.cpp",
    "src/AggregateFunctions/AggregateFunctionAvg.h",
    "src/AggregateFunctions/AggregateFunctionDeltaSum.cpp",
    "src/AggregateFunctions/AggregateFunctionDeltaSumTimestamp.cpp",
    "src/AggregateFunctions/AggregateFunctionGroupArray.cpp",
    "src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp",
    "src/AggregateFunctions/AggregateFunctionIntervalLengthSum.cpp",
    "src/AggregateFunctions/AggregateFunctionMaxIntersections.cpp",
    "src/AggregateFunctions/AggregateFunctionSparkbar.cpp",
    "src/AggregateFunctions/AggregateFunctionSum.h",
    "src/AggregateFunctions/AggregateFunctionUniq.h",
    "src/AggregateFunctions/AggregateFunctionUniqCombined.h",
    "src/AggregateFunctions/QuantileTDigest.h",
    "src/AggregateFunctions/ReservoirSampler.h",
    "src/AggregateFunctions/ReservoirSamplerDeterministic.h",
    "src/Columns/ColumnArray.cpp",
    "src/Columns/ColumnUnique.cpp",
    "src/Columns/ColumnUnique.h",
    "src/Columns/ColumnVector.cpp",
    "src/Columns/ColumnVector.h",
    "src/Columns/ColumnsCommon.cpp",
    "src/Columns/ColumnsNumber.h",
    "src/Columns/IColumn.cpp",
    "src/Columns/MaskOperations.cpp",
    "src/Common/CPUID.h",
    "src/Common/FieldVisitorConvertToNumber.cpp",
    "src/Common/FieldVisitorConvertToNumber.h",
    "src/Common/HashTable/Hash.h",
    "src/Common/HashTable/HashTable.h",
    "src/Common/NaNUtils.h",
    "src/Common/TargetSpecific.cpp",
    "src/Common/TargetSpecific.h",
    "src/Common/findExtreme.cpp",
    "src/Common/transformEndianness.h",
    "src/Core/AccurateComparison.h",
    "src/Core/DecimalFunctions.h",
    "src/Core/Field.h",
    "src/Core/Settings.cpp",
    "src/Core/SettingsChangesHistory.cpp",
    "src/Core/SortCursor.h",
    "src/Core/TypeId.h",
    "src/Core/Types_fwd.h",
    "src/Core/callOnTypeIndex.h",
    "src/DataTypes/DataTypeNumberBase.cpp",
    "src/DataTypes/DataTypeNumberBase.h",
    "src/DataTypes/DataTypesBinaryEncoding.cpp",
    "src/DataTypes/DataTypesDecimal.cpp",
    "src/DataTypes/DataTypesDecimal.h",
    "src/DataTypes/DataTypesNumber.cpp",
    "src/DataTypes/DataTypesNumber.h",
    "src/DataTypes/IDataType.h",
    "src/DataTypes/Native.cpp",
    "src/DataTypes/NumberTraits.h",
    "src/DataTypes/Serializations/SerializationNumber.cpp",
    "src/DataTypes/Utils.cpp",
    "src/DataTypes/getLeastSupertype.cpp",
    "src/DataTypes/getMostSubtype.cpp",
    "src/Databases/enableAllExperimentalSettings.cpp",
    "src/Dictionaries/RangeHashedDictionary.h",
    "src/Formats/JSONExtractTree.cpp",
    "src/Formats/ProtobufSerializer.cpp",
    "src/Functions/DivisionUtils.h",
    "src/Functions/FunctionBinaryArithmetic.h",
    "src/Functions/FunctionMathUnary.h",
    "src/Functions/FunctionsBinaryRepresentation.cpp",
    "src/Functions/FunctionsComparison.h",
    "src/Functions/FunctionsConversion.cpp",
    "src/Functions/FunctionsRound.h",
    "src/Functions/FunctionsVisitParam.h",
    "src/Functions/PolygonUtils.h",
    "src/Functions/abs.cpp",
    "src/Functions/array/arrayAggregation.cpp",
    "src/Functions/array/arrayDistance.cpp",
    "src/Functions/array/mapPopulateSeries.cpp",
    "src/Functions/divide.cpp",
    "src/Functions/exp.cpp",
    "src/Functions/factorial.cpp",
    "src/Functions/log.cpp",
    "src/Functions/minus.cpp",
    "src/Functions/moduloOrZero.cpp",
    "src/Functions/multiply.cpp",
    "src/Functions/plus.cpp",
    "src/Functions/sigmoid.cpp",
    "src/Functions/sign.cpp",
    "src/Functions/tanh.cpp",
    "src/IO/ReadHelpers.h",
    "src/IO/WriteHelpers.h",
    "src/IO/readFloatText.cpp",
    "src/IO/readFloatText.h",
    "src/Interpreters/AggregatedData.h",
    "src/Interpreters/RowRefs.cpp",
    "src/Interpreters/parseColumnsListForTableFunction.cpp",
    "src/Interpreters/parseColumnsListForTableFunction.h",
    "src/Processors/Formats/Impl/Parquet/ParquetDataValuesReader.cpp",
    "src/Processors/Formats/Impl/Parquet/ParquetLeafColReader.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "src/Columns/tests/gtest_column_vector.cpp",
    "src/Columns/tests/gtest_low_cardinality.cpp",
    "tests/performance/avg_weighted.xml",
    "tests/performance/reinterpret_as.xml",
    "tests/queries/0_stateless/01035_avg.sql",
    "tests/queries/0_stateless/01182_materialized_view_different_structure.sql",
    "tests/queries/0_stateless/01440_big_int_exotic_casts.sql",
    "tests/queries/0_stateless/01554_bloom_filter_index_big_integer_uuid.sql",
    "tests/queries/0_stateless/01622_byte_size.sql",
    "tests/queries/0_stateless/01721_dictionary_decimal_p_s.sql",
    "tests/queries/0_stateless/01804_dictionary_decimal256_type.sql",
    "tests/queries/0_stateless/01875_ssd_cache_dictionary_decimal256_type.sh",
    "b/tests/queries/0_stateless/03269_bf16.reference",
    "b/tests/queries/0_stateless/03269_bf16.sql",
    "b/tests/queries/0_stateless/03271_benchmark_metrics.reference",
    "b/tests/queries/0_stateless/03271_benchmark_metrics.sh"
  ]
}