diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index 1de9adb834eb..81d6f34aced7 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -53,89 +53,6 @@ namespace ErrorCodes
 }
 
 
-bool ParserArray::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ASTPtr contents_node;
-    ParserExpressionList contents(false);
-
-    if (pos->type != TokenType::OpeningSquareBracket)
-        return false;
-    ++pos;
-
-    if (!contents.parse(pos, contents_node, expected))
-        return false;
-
-    if (pos->type != TokenType::ClosingSquareBracket)
-        return false;
-    ++pos;
-
-    auto function_node = std::make_shared<ASTFunction>();
-    function_node->name = "array";
-    function_node->arguments = contents_node;
-    function_node->children.push_back(contents_node);
-    node = function_node;
-
-    return true;
-}
-
-
-bool ParserParenthesisExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ASTPtr contents_node;
-    ParserExpressionList contents(false);
-
-    if (pos->type != TokenType::OpeningRoundBracket)
-        return false;
-    ++pos;
-
-    if (!contents.parse(pos, contents_node, expected))
-        return false;
-
-    bool is_elem = true;
-    if (pos->type == TokenType::Comma)
-    {
-        is_elem = false;
-        ++pos;
-    }
-
-    if (pos->type != TokenType::ClosingRoundBracket)
-        return false;
-    ++pos;
-
-    const auto & expr_list = contents_node->as<ASTExpressionList &>();
-
-    /// Empty expression in parentheses is not allowed.
-    if (expr_list.children.empty())
-    {
-        expected.add(pos, "non-empty parenthesized list of expressions");
-        return false;
-    }
-
-    /// Special case for one-element tuple.
-    if (expr_list.children.size() == 1 && is_elem)
-    {
-        auto * ast_literal = expr_list.children.front()->as<ASTLiteral>();
-        /// But only if its argument is not tuple,
-        /// since otherwise it will do incorrect transformation:
-        ///
-        ///     (foo,bar) IN (('foo','bar')) -> (foo,bar) IN ('foo','bar')
-        if (!(ast_literal && ast_literal->value.getType() == Field::Types::Tuple))
-        {
-            node = expr_list.children.front();
-            return true;
-        }
-    }
-
-    auto function_node = std::make_shared<ASTFunction>();
-    function_node->name = "tuple";
-    function_node->arguments = contents_node;
-    function_node->children.push_back(contents_node);
-    node = function_node;
-
-    return true;
-}
-
-
 bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     ASTPtr select_node;
@@ -282,850 +199,10 @@ ASTPtr createFunctionCast(const ASTPtr & expr_ast, const ASTPtr & type_ast)
 {
     /// Convert to canonical representation in functional form: CAST(expr, 'type')
     auto type_literal = std::make_shared<ASTLiteral>(queryToString(type_ast));
-
-    auto expr_list_args = std::make_shared<ASTExpressionList>();
-    expr_list_args->children.push_back(expr_ast);
-    expr_list_args->children.push_back(std::move(type_literal));
-
-    auto func_node = std::make_shared<ASTFunction>();
-    func_node->name = "CAST";
-    func_node->arguments = std::move(expr_list_args);
-    func_node->children.push_back(func_node->arguments);
-
-    return func_node;
+    return makeASTFunction("CAST", expr_ast, std::move(type_literal));
 }
 
 
-namespace
-{
-    bool parseCastAs(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /** Possible variants for cast operator cast(expr [[AS] alias_1] AS Type), cast(expr [[AS] alias_1], type_expr [[as] alias_2]).
-          * First try to match with cast(expr [[AS] alias_1] AS Type)
-          * Then try to match with cast(expr [[AS] alias_1], type_expr [[as] alias_2]).
-          */
-
-        ASTPtr expr_node;
-        ASTPtr type_node;
-        ASTPtr identifier_node;
-
-        if (ParserExpression().parse(pos, expr_node, expected))
-        {
-            ParserKeyword as_keyword_parser("AS");
-            bool parse_as = as_keyword_parser.ignore(pos, expected);
-
-            /// CAST (a b AS UInt32) OR CAST (a b, expr)
-
-            if (!parse_as && ParserIdentifier().parse(pos, identifier_node, expected))
-            {
-                expr_node->setAlias(getIdentifierName(identifier_node));
-                parse_as = as_keyword_parser.ignore(pos, expected);
-            }
-
-            if (parse_as)
-            {
-                /// CAST (a AS Type) OR CAST (a AS b AS Type) OR CAST (a AS b, expr)
-
-                auto begin = pos;
-                auto expected_copy = expected;
-                bool next_identifier = ParserIdentifier().ignore(begin, expected_copy);
-                bool next_identifier_with_comma = next_identifier && ParserToken(TokenType::Comma).ignore(begin, expected_copy);
-                bool next_identifier_with_as
-                    = next_identifier && !next_identifier_with_comma && as_keyword_parser.ignore(begin, expected_copy);
-
-                if (next_identifier_with_as)
-                {
-                    if (ParserIdentifier().parse(pos, identifier_node, expected) && as_keyword_parser.ignore(pos, expected))
-                        expr_node->setAlias(getIdentifierName(identifier_node));
-                    else
-                        return false;
-                }
-
-                if (!next_identifier_with_comma && ParserDataType().parse(pos, type_node, expected))
-                {
-                    node = createFunctionCast(expr_node, type_node);
-                    return true;
-                }
-            }
-
-            /// CAST(a AS b, expr)
-
-            if (parse_as)
-            {
-                if (ParserIdentifier().parse(pos, identifier_node, expected))
-                    expr_node->setAlias(getIdentifierName(identifier_node));
-                else
-                    return false;
-            }
-
-            if (ParserToken(TokenType::Comma).ignore(pos, expected)
-                && ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, type_node, expected))
-            {
-                node = makeASTFunction("CAST", expr_node, type_node);
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    bool parseSubstring(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /// Either SUBSTRING(expr FROM start) or SUBSTRING(expr FROM start FOR length) or SUBSTRING(expr, start, length)
-        /// The latter will be parsed normally as a function later.
-
-        ParserKeyword as_keyword_parser("AS");
-        ParserIdentifier identifier_parser;
-
-        ASTPtr expr_node;
-        ASTPtr start_node;
-        ASTPtr length_node;
-
-        if (!ParserExpression().parse(pos, expr_node, expected))
-            return false;
-
-        auto from_keyword_parser = ParserKeyword("FROM");
-        bool from_exists = from_keyword_parser.check(pos, expected);
-
-        if (!from_exists && pos->type != TokenType::Comma)
-        {
-            ASTPtr identifier_node;
-            bool parsed_as = as_keyword_parser.ignore(pos, expected);
-            bool parsed_identifer = identifier_parser.parse(pos, identifier_node, expected);
-
-            if (parsed_as && !parsed_identifer)
-                return false;
-
-            if (parsed_identifer)
-                expr_node->setAlias(getIdentifierName(identifier_node));
-
-            from_exists = from_keyword_parser.check(pos, expected);
-        }
-
-        if (pos->type == TokenType::Comma)
-        {
-            if (from_exists)
-                return false;
-
-            ++pos;
-        }
-
-        if (!ParserExpression().parse(pos, start_node, expected))
-            return false;
-
-        auto for_keyword_parser = ParserKeyword("FOR");
-        bool for_exists = for_keyword_parser.check(pos, expected);
-        if (!for_exists && pos->type != TokenType::Comma)
-        {
-            ASTPtr identifier_node;
-            bool parsed_as = as_keyword_parser.ignore(pos, expected);
-            bool parsed_identifer = identifier_parser.parse(pos, identifier_node, expected);
-            if (parsed_as && !parsed_identifer)
-                return false;
-
-            if (parsed_identifer)
-                start_node->setAlias(getIdentifierName(identifier_node));
-
-            for_exists = for_keyword_parser.check(pos, expected);
-        }
-
-        bool need_parse_length_expression = for_exists;
-        if (pos->type == TokenType::Comma)
-        {
-            if (for_exists)
-                return false;
-
-            ++pos;
-            need_parse_length_expression = true;
-        }
-
-        if (need_parse_length_expression
-            && !ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, length_node, expected))
-            return false;
-
-        /// Convert to canonical representation in functional form: SUBSTRING(expr, start, length)
-        if (length_node)
-            node = makeASTFunction("substring", expr_node, start_node, length_node);
-        else
-            node = makeASTFunction("substring", expr_node, start_node);
-
-        return true;
-    }
-
-    bool parseTrim(bool trim_left, bool trim_right, IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /// Handles all possible TRIM/LTRIM/RTRIM call variants ([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)
-
-        std::string func_name;
-        bool char_override = false;
-        ASTPtr expr_node;
-        ASTPtr pattern_node;
-        ASTPtr to_remove;
-
-        if (!trim_left && !trim_right)
-        {
-            if (ParserKeyword("BOTH").ignore(pos, expected))
-            {
-                trim_left = true;
-                trim_right = true;
-                char_override = true;
-            }
-            else if (ParserKeyword("LEADING").ignore(pos, expected))
-            {
-                trim_left = true;
-                char_override = true;
-            }
-            else if (ParserKeyword("TRAILING").ignore(pos, expected))
-            {
-                trim_right = true;
-                char_override = true;
-            }
-            else
-            {
-                trim_left = true;
-                trim_right = true;
-            }
-
-            if (char_override)
-            {
-                if (!ParserExpression().parse(pos, to_remove, expected))
-                    return false;
-
-                auto from_keyword_parser = ParserKeyword("FROM");
-                bool from_exists = from_keyword_parser.check(pos, expected);
-
-                if (!from_exists)
-                {
-                    ASTPtr identifier_node;
-                    bool parsed_as = ParserKeyword("AS").ignore(pos, expected);
-                    bool parsed_identifer = ParserIdentifier().parse(pos, identifier_node, expected);
-
-                    if (parsed_as && !parsed_identifer)
-                        return false;
-
-                    if (parsed_identifer)
-                        to_remove->setAlias(getIdentifierName(identifier_node));
-
-                    from_exists = from_keyword_parser.check(pos, expected);
-                }
-
-                if (!from_exists)
-                    return false;
-
-                auto quote_meta_func_node = std::make_shared<ASTFunction>();
-                auto quote_meta_list_args = std::make_shared<ASTExpressionList>();
-                quote_meta_list_args->children = {to_remove};
-
-                quote_meta_func_node->name = "regexpQuoteMeta";
-                quote_meta_func_node->arguments = std::move(quote_meta_list_args);
-                quote_meta_func_node->children.push_back(quote_meta_func_node->arguments);
-
-                to_remove = std::move(quote_meta_func_node);
-            }
-        }
-
-        if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, expr_node, expected))
-            return false;
-
-        /// Convert to regexp replace function call
-
-        if (char_override)
-        {
-            auto pattern_func_node = std::make_shared<ASTFunction>();
-            auto pattern_list_args = std::make_shared<ASTExpressionList>();
-            if (trim_left && trim_right)
-            {
-                pattern_list_args->children
-                    = {std::make_shared<ASTLiteral>("^["),
-                       to_remove,
-                       std::make_shared<ASTLiteral>("]+|["),
-                       to_remove,
-                       std::make_shared<ASTLiteral>("]+$")};
-                func_name = "replaceRegexpAll";
-            }
-            else
-            {
-                if (trim_left)
-                {
-                    pattern_list_args->children = {std::make_shared<ASTLiteral>("^["), to_remove, std::make_shared<ASTLiteral>("]+")};
-                }
-                else
-                {
-                    /// trim_right == false not possible
-                    pattern_list_args->children = {std::make_shared<ASTLiteral>("["), to_remove, std::make_shared<ASTLiteral>("]+$")};
-                }
-                func_name = "replaceRegexpOne";
-            }
-
-            pattern_func_node->name = "concat";
-            pattern_func_node->arguments = std::move(pattern_list_args);
-            pattern_func_node->children.push_back(pattern_func_node->arguments);
-
-            pattern_node = std::move(pattern_func_node);
-        }
-        else
-        {
-            if (trim_left && trim_right)
-            {
-                func_name = "trimBoth";
-            }
-            else
-            {
-                if (trim_left)
-                {
-                    func_name = "trimLeft";
-                }
-                else
-                {
-                    /// trim_right == false not possible
-                    func_name = "trimRight";
-                }
-            }
-        }
-
-        if (char_override)
-            node = makeASTFunction(func_name, expr_node, pattern_node, std::make_shared<ASTLiteral>(""));
-        else
-            node = makeASTFunction(func_name, expr_node);
-        return true;
-    }
-
-    bool parseExtract(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /// First try to match with date extract operator EXTRACT(part FROM date)
-        /// Then with function extract(haystack, pattern)
-
-        IParser::Pos begin = pos;
-        IntervalKind interval_kind;
-
-        if (parseIntervalKind(pos, expected, interval_kind))
-        {
-            ASTPtr expr;
-
-            ParserKeyword s_from("FROM");
-            ParserExpressionWithOptionalAlias elem_parser(true /*allow_alias_without_as_keyword*/);
-
-            if (s_from.ignore(pos, expected) && elem_parser.parse(pos, expr, expected))
-            {
-                node = makeASTFunction(interval_kind.toNameOfFunctionExtractTimePart(), expr);
-                return true;
-            }
-        }
-
-        pos = begin;
-
-        ASTPtr expr_list;
-        if (!ParserExpressionList(true /*allow_alias_without_as_keyword*/).parse(pos, expr_list, expected))
-            return false;
-
-        auto res = std::make_shared<ASTFunction>();
-        res->name = "extract";
-        res->arguments = expr_list;
-        res->children.push_back(res->arguments);
-        node = std::move(res);
-        return true;
-    }
-
-    bool parsePosition(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /// First try to match with position(needle IN haystack)
-        /// Then with position(haystack, needle[, start_pos])
-
-        ParserExpressionWithOptionalAlias expr_parser(true /*allow_alias_without_as_keyword*/);
-
-        ASTPtr first_arg_expr_node;
-        if (!expr_parser.parse(pos, first_arg_expr_node, expected))
-        {
-            return false;
-        }
-
-        ASTFunction * func_in = typeid_cast<ASTFunction *>(first_arg_expr_node.get());
-        if (func_in && func_in->name == "in")
-        {
-            ASTExpressionList * in_args = typeid_cast<ASTExpressionList *>(func_in->arguments.get());
-            if (in_args && in_args->children.size() == 2)
-            {
-                node = makeASTFunction("position", in_args->children[1], in_args->children[0]);
-                return true;
-            }
-        }
-
-        if (pos->type != TokenType::Comma)
-            return false;
-        ++pos;
-
-        ASTPtr second_arg_expr_node;
-        if (!expr_parser.parse(pos, second_arg_expr_node, expected))
-        {
-            return false;
-        }
-
-        ASTPtr start_pos_expr_node;
-        if (pos->type == TokenType::Comma)
-        {
-            ++pos;
-
-            if (!expr_parser.parse(pos, start_pos_expr_node, expected))
-                return false;
-        }
-
-        auto arguments = std::make_shared<ASTExpressionList>();
-        arguments->children.push_back(std::move(first_arg_expr_node));
-        arguments->children.push_back(std::move(second_arg_expr_node));
-
-        if (start_pos_expr_node)
-            arguments->children.push_back(std::move(start_pos_expr_node));
-
-        auto res = std::make_shared<ASTFunction>();
-        res->name = "position";
-        res->arguments = std::move(arguments);
-        res->children.push_back(res->arguments);
-        node = std::move(res);
-        return true;
-    }
-
-    bool parseDateAdd(const char * function_name, IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /// First to match with function(unit, offset, timestamp)
-        /// Then with function(offset, timestamp)
-
-        ASTPtr timestamp_node;
-        ASTPtr offset_node;
-
-        IntervalKind interval_kind;
-        ASTPtr interval_func_node;
-        if (parseIntervalKind(pos, expected, interval_kind))
-        {
-            if (pos->type != TokenType::Comma)
-                return false;
-            ++pos;
-
-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, offset_node, expected))
-                return false;
-
-            if (pos->type != TokenType::Comma)
-                return false;
-            ++pos;
-
-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, timestamp_node, expected))
-                return false;
-            auto interval_expr_list_args = std::make_shared<ASTExpressionList>();
-            interval_expr_list_args->children = {offset_node};
-
-            interval_func_node = std::make_shared<ASTFunction>();
-            interval_func_node->as<ASTFunction &>().name = interval_kind.toNameOfFunctionToIntervalDataType();
-            interval_func_node->as<ASTFunction &>().arguments = std::move(interval_expr_list_args);
-            interval_func_node->as<ASTFunction &>().children.push_back(interval_func_node->as<ASTFunction &>().arguments);
-        }
-        else
-        {
-            ASTPtr expr_list;
-            if (!ParserExpressionList(true /*allow_alias_without_as_keyword*/).parse(pos, expr_list, expected))
-                return false;
-
-            auto res = std::make_shared<ASTFunction>();
-            res->name = function_name;
-            res->arguments = expr_list;
-            res->children.push_back(res->arguments);
-            node = std::move(res);
-            return true;
-        }
-
-        node = makeASTFunction(function_name, timestamp_node, interval_func_node);
-        return true;
-    }
-
-    bool parseDateDiff(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        /// First to match with dateDiff(unit, startdate, enddate, [timezone])
-        /// Then with dateDiff('unit', startdate, enddate, [timezone])
-
-        ASTPtr left_node;
-        ASTPtr right_node;
-
-        IntervalKind interval_kind;
-        if (parseIntervalKind(pos, expected, interval_kind))
-        {
-            if (pos->type != TokenType::Comma)
-                return false;
-            ++pos;
-
-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, left_node, expected))
-                return false;
-
-            if (pos->type != TokenType::Comma)
-                return false;
-            ++pos;
-
-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, right_node, expected))
-                return false;
-
-            ASTPtr timezone_node;
-
-            if (pos->type == TokenType::Comma)
-            {
-                /// Optional timezone
-                ++pos;
-
-                if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, timezone_node, expected))
-                    return false;
-            }
-
-            auto interval_literal = std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit());
-            if (timezone_node)
-                node = makeASTFunction("dateDiff", std::move(interval_literal), std::move(left_node), std::move(right_node), std::move(timezone_node));
-            else
-                node = makeASTFunction("dateDiff", std::move(interval_literal), std::move(left_node), std::move(right_node));
-
-            return true;
-        }
-
-        ASTPtr expr_list;
-        if (!ParserExpressionList(true /*allow_alias_without_as_keyword*/).parse(pos, expr_list, expected))
-            return false;
-
-        auto res = std::make_shared<ASTFunction>();
-        res->name = "dateDiff";
-        res->arguments = expr_list;
-        res->children.push_back(res->arguments);
-        node = std::move(res);
-
-        return true;
-    }
-
-    bool parseExists(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        if (!ParserSelectWithUnionQuery().parse(pos, node, expected))
-            return false;
-
-        auto subquery = std::make_shared<ASTSubquery>();
-        subquery->children.push_back(node);
-        node = makeASTFunction("exists", subquery);
-        return true;
-    }
-
-    bool parseGrouping(IParser::Pos & pos, ASTPtr & node, Expected & expected)
-    {
-        ASTPtr expr_list;
-        if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))
-            return false;
-
-        auto res = std::make_shared<ASTFunction>();
-        res->name = "grouping";
-        res->arguments = expr_list;
-        res->children.push_back(res->arguments);
-        node = std::move(res);
-        return true;
-    }
-}
-
-
-bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ParserIdentifier id_parser;
-
-    bool has_all = false;
-    bool has_distinct = false;
-
-    ASTPtr identifier;
-    ASTPtr query;
-    ASTPtr expr_list_args;
-    ASTPtr expr_list_params;
-
-    if (is_table_function)
-    {
-        if (ParserTableFunctionView().parse(pos, node, expected))
-            return true;
-    }
-
-    if (!id_parser.parse(pos, identifier, expected))
-        return false;
-
-    if (pos->type != TokenType::OpeningRoundBracket)
-        return false;
-    ++pos;
-
-    /// Avoid excessive backtracking.
-    //pos.putBarrier();
-
-    /// Special cases for expressions that look like functions but contain some syntax sugar:
-
-    /// CAST, EXTRACT, POSITION, EXISTS
-    /// DATE_ADD, DATEADD, TIMESTAMPADD, DATE_SUB, DATESUB, TIMESTAMPSUB,
-    /// DATE_DIFF, DATEDIFF, TIMESTAMPDIFF, TIMESTAMP_DIFF,
-    /// SUBSTRING, TRIM, LTRIM, RTRIM, POSITION
-
-    /// Can be parsed as a composition of functions, but the contents must be unwrapped:
-    /// POSITION(x IN y) -> POSITION(in(x, y)) -> POSITION(y, x)
-
-    /// Can be parsed as a function, but not always:
-    /// CAST(x AS type) - alias has to be unwrapped
-    /// CAST(x AS type(params))
-
-    /// Can be parsed as a function, but some identifier arguments have special meanings.
-    /// DATE_ADD(MINUTE, x, y) -> addMinutes(x, y)
-    /// DATE_DIFF(MINUTE, x, y)
-
-    /// Have keywords that have to processed explicitly:
-    /// EXTRACT(x FROM y)
-    /// TRIM(BOTH|LEADING|TRAILING x FROM y)
-    /// SUBSTRING(x FROM a)
-    /// SUBSTRING(x FROM a FOR b)
-
-    String function_name = getIdentifierName(identifier);
-    String function_name_lowercase = Poco::toLower(function_name);
-
-    std::optional<bool> parsed_special_function;
-
-    if (function_name_lowercase == "cast")
-        parsed_special_function = parseCastAs(pos, node, expected);
-    else if (function_name_lowercase == "extract")
-        parsed_special_function = parseExtract(pos, node, expected);
-    else if (function_name_lowercase == "substring")
-        parsed_special_function = parseSubstring(pos, node, expected);
-    else if (function_name_lowercase == "position")
-        parsed_special_function = parsePosition(pos, node, expected);
-    else if (function_name_lowercase == "exists")
-        parsed_special_function = parseExists(pos, node, expected);
-    else if (function_name_lowercase == "trim")
-        parsed_special_function = parseTrim(false, false, pos, node, expected);
-    else if (function_name_lowercase == "ltrim")
-        parsed_special_function = parseTrim(true, false, pos, node, expected);
-    else if (function_name_lowercase == "rtrim")
-        parsed_special_function = parseTrim(false, true, pos, node, expected);
-    else if (function_name_lowercase == "dateadd" || function_name_lowercase == "date_add"
-        || function_name_lowercase == "timestampadd" || function_name_lowercase == "timestamp_add")
-        parsed_special_function = parseDateAdd("plus", pos, node, expected);
-    else if (function_name_lowercase == "datesub" || function_name_lowercase == "date_sub"
-        || function_name_lowercase == "timestampsub" || function_name_lowercase == "timestamp_sub")
-        parsed_special_function = parseDateAdd("minus", pos, node, expected);
-    else if (function_name_lowercase == "datediff" || function_name_lowercase == "date_diff"
-        || function_name_lowercase == "timestampdiff" || function_name_lowercase == "timestamp_diff")
-        parsed_special_function = parseDateDiff(pos, node, expected);
-    else if (function_name_lowercase == "grouping")
-        parsed_special_function = parseGrouping(pos, node, expected);
-
-    if (parsed_special_function.has_value())
-        return parsed_special_function.value() && ParserToken(TokenType::ClosingRoundBracket).ignore(pos);
-
-    auto pos_after_bracket = pos;
-    auto old_expected = expected;
-
-    ParserKeyword all("ALL");
-    ParserKeyword distinct("DISTINCT");
-
-    if (all.ignore(pos, expected))
-        has_all = true;
-
-    if (distinct.ignore(pos, expected))
-        has_distinct = true;
-
-    if (!has_all && all.ignore(pos, expected))
-        has_all = true;
-
-    if (has_all && has_distinct)
-        return false;
-
-    if (has_all || has_distinct)
-    {
-        /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier
-        if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)
-        {
-            pos = pos_after_bracket;
-            expected = old_expected;
-            has_all = false;
-            has_distinct = false;
-        }
-    }
-
-    ParserExpressionList contents(false, is_table_function);
-
-    const char * contents_begin = pos->begin;
-    if (!contents.parse(pos, expr_list_args, expected))
-        return false;
-    const char * contents_end = pos->begin;
-
-    if (pos->type != TokenType::ClosingRoundBracket)
-        return false;
-    ++pos;
-
-    /** Check for a common error case - often due to the complexity of quoting command-line arguments,
-      *  an expression of the form toDate(2014-01-01) appears in the query instead of toDate('2014-01-01').
-      * If you do not report that the first option is an error, then the argument will be interpreted as 2014 - 01 - 01 - some number,
-      *  and the query silently returns an unexpected result.
-      */
-    if (function_name == "toDate"
-        && contents_end - contents_begin == strlen("2014-01-01")
-        && contents_begin[0] >= '2' && contents_begin[0] <= '3'
-        && contents_begin[1] >= '0' && contents_begin[1] <= '9'
-        && contents_begin[2] >= '0' && contents_begin[2] <= '9'
-        && contents_begin[3] >= '0' && contents_begin[3] <= '9'
-        && contents_begin[4] == '-'
-        && contents_begin[5] >= '0' && contents_begin[5] <= '9'
-        && contents_begin[6] >= '0' && contents_begin[6] <= '9'
-        && contents_begin[7] == '-'
-        && contents_begin[8] >= '0' && contents_begin[8] <= '9'
-        && contents_begin[9] >= '0' && contents_begin[9] <= '9')
-    {
-        std::string contents_str(contents_begin, contents_end - contents_begin);
-        throw Exception("Argument of function toDate is unquoted: toDate(" + contents_str + "), must be: toDate('" + contents_str + "')"
-            , ErrorCodes::SYNTAX_ERROR);
-    }
-
-    /// The parametric aggregate function has two lists (parameters and arguments) in parentheses. Example: quantile(0.9)(x).
-    if (allow_function_parameters && pos->type == TokenType::OpeningRoundBracket)
-    {
-        ++pos;
-
-        /// Parametric aggregate functions cannot have DISTINCT in parameters list.
-        if (has_distinct)
-            return false;
-
-        expr_list_params = expr_list_args;
-        expr_list_args = nullptr;
-
-        pos_after_bracket = pos;
-        old_expected = expected;
-
-        if (all.ignore(pos, expected))
-            has_all = true;
-
-        if (distinct.ignore(pos, expected))
-            has_distinct = true;
-
-        if (!has_all && all.ignore(pos, expected))
-            has_all = true;
-
-        if (has_all && has_distinct)
-            return false;
-
-        if (has_all || has_distinct)
-        {
-            /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier
-            if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)
-            {
-                pos = pos_after_bracket;
-                expected = old_expected;
-                has_distinct = false;
-            }
-        }
-
-        if (!contents.parse(pos, expr_list_args, expected))
-            return false;
-
-        if (pos->type != TokenType::ClosingRoundBracket)
-            return false;
-        ++pos;
-    }
-
-    auto function_node = std::make_shared<ASTFunction>();
-    tryGetIdentifierNameInto(identifier, function_node->name);
-
-    /// func(DISTINCT ...) is equivalent to funcDistinct(...)
-    if (has_distinct)
-        function_node->name += "Distinct";
-
-    function_node->arguments = expr_list_args;
-    function_node->children.push_back(function_node->arguments);
-
-    if (expr_list_params)
-    {
-        function_node->parameters = expr_list_params;
-        function_node->children.push_back(function_node->parameters);
-    }
-
-    ParserKeyword filter("FILTER");
-    ParserKeyword over("OVER");
-
-    if (filter.ignore(pos, expected))
-    {
-        // We are slightly breaking the parser interface by parsing the window
-        // definition into an existing ASTFunction. Normally it would take a
-        // reference to ASTPtr and assign it the new node. We only have a pointer
-        // of a different type, hence this workaround with a temporary pointer.
-        ASTPtr function_node_as_iast = function_node;
-
-        ParserFilterClause filter_parser;
-        if (!filter_parser.parse(pos, function_node_as_iast, expected))
-            return false;
-    }
-
-    if (over.ignore(pos, expected))
-    {
-        function_node->is_window_function = true;
-
-        ASTPtr function_node_as_iast = function_node;
-
-        ParserWindowReference window_reference;
-        if (!window_reference.parse(pos, function_node_as_iast, expected))
-            return false;
-    }
-
-    node = function_node;
-    return true;
-}
-
-bool ParserTableFunctionView::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ParserIdentifier id_parser;
-    ParserSelectWithUnionQuery select;
-
-    ASTPtr identifier;
-    ASTPtr query;
-
-    bool if_permitted = false;
-
-    if (ParserKeyword{"VIEWIFPERMITTED"}.ignore(pos, expected))
-        if_permitted = true;
-    else if (!ParserKeyword{"VIEW"}.ignore(pos, expected))
-        return false;
-
-    if (pos->type != TokenType::OpeningRoundBracket)
-        return false;
-
-    ++pos;
-
-    bool maybe_an_subquery = pos->type == TokenType::OpeningRoundBracket;
-
-    if (!select.parse(pos, query, expected))
-        return false;
-
-    auto & select_ast = query->as<ASTSelectWithUnionQuery &>();
-    if (select_ast.list_of_selects->children.size() == 1 && maybe_an_subquery)
-    {
-        // It's an subquery. Bail out.
-        return false;
-    }
-
-    ASTPtr else_ast;
-    if (if_permitted)
-    {
-        if (!ParserKeyword{"ELSE"}.ignore(pos, expected))
-            return false;
-
-        if (!ParserWithOptionalAlias{std::make_unique<ParserFunction>(true, true), true}.parse(pos, else_ast, expected))
-            return false;
-    }
-
-    if (pos->type != TokenType::ClosingRoundBracket)
-        return false;
-
-    ++pos;
-
-    auto expr_list = std::make_shared<ASTExpressionList>();
-    expr_list->children.push_back(query);
-    if (if_permitted)
-        expr_list->children.push_back(else_ast);
-
-    auto function_node = std::make_shared<ASTFunction>();
-    tryGetIdentifierNameInto(identifier, function_node->name);
-    function_node->name = if_permitted ? "viewIfPermitted" : "view";
-    function_node->arguments = expr_list;
-    function_node->children.push_back(function_node->arguments);
-    node = function_node;
-    return true;
-}
-
 bool ParserFilterClause::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     assert(node);
@@ -1865,42 +942,63 @@ bool ParserStringLiteral::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte
     return true;
 }
 
+template <typename Collection>
+struct CollectionOfLiteralsLayer
+{
+    explicit CollectionOfLiteralsLayer(IParser::Pos & pos) : literal_begin(pos)
+    {
+        ++pos;
+    }
+
+    IParser::Pos literal_begin;
+    Collection arr;
+};
+
 template <typename Collection>
 bool ParserCollectionOfLiterals<Collection>::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     if (pos->type != opening_bracket)
         return false;
 
-    Pos literal_begin = pos;
+    std::vector<CollectionOfLiteralsLayer<Collection>> layers;
+    layers.emplace_back(pos);
+    pos.increaseDepth();
 
-    Collection arr;
     ParserLiteral literal_p;
-    ParserCollectionOfLiterals<Collection> collection_p(opening_bracket, closing_bracket);
 
-    ++pos;
     while (pos.isValid())
     {
-        if (!arr.empty())
+        if (!layers.back().arr.empty())
         {
             if (pos->type == closing_bracket)
             {
                 std::shared_ptr<ASTLiteral> literal;
 
                 /// Parse one-element tuples (e.g. (1)) later as single values for backward compatibility.
-                if (std::is_same_v<Collection, Tuple> && arr.size() == 1)
+                if (std::is_same_v<Collection, Tuple> && layers.back().arr.size() == 1)
                     return false;
 
-                literal = std::make_shared<ASTLiteral>(std::move(arr));
-                literal->begin = literal_begin;
+                literal = std::make_shared<ASTLiteral>(std::move(layers.back().arr));
+                literal->begin = layers.back().literal_begin;
                 literal->end = ++pos;
-                node = literal;
-                return true;
+
+                layers.pop_back();
+                pos.decreaseDepth();
+
+                if (layers.empty())
+                {
+                    node = literal;
+                    return true;
+                }
+
+                layers.back().arr.push_back(literal->value);
+                continue;
             }
             else if (pos->type == TokenType::Comma)
             {
                 ++pos;
             }
-            else if (pos->type == TokenType::Colon && std::is_same_v<Collection, Map> && arr.size() % 2 == 1)
+            else if (pos->type == TokenType::Colon && std::is_same_v<Collection, Map> && layers.back().arr.size() % 2 == 1)
             {
                 ++pos;
             }
@@ -1912,10 +1010,17 @@ bool ParserCollectionOfLiterals<Collection>::parseImpl(Pos & pos, ASTPtr & node,
         }
 
         ASTPtr literal_node;
-        if (!literal_p.parse(pos, literal_node, expected) && !collection_p.parse(pos, literal_node, expected))
+        if (literal_p.parse(pos, literal_node, expected))
+        {
+            layers.back().arr.push_back(literal_node->as<ASTLiteral &>().value);
+        }
+        else if (pos->type == opening_bracket)
+        {
+            layers.emplace_back(pos);
+            pos.increaseDepth();
+        }
+        else
             return false;
-
-        arr.push_back(literal_node->as<ASTLiteral &>().value);
     }
 
     expected.add(pos, getTokenName(closing_bracket));
@@ -2093,7 +1198,7 @@ bool ParserColumnsTransformers::parseImpl(Pos & pos, ASTPtr & node, Expected & e
         ASTPtr func_name;
         ASTPtr expr_list_args;
         auto opos = pos;
-        if (ParserLambdaExpression().parse(pos, lambda, expected))
+        if (ParserExpression().parse(pos, lambda, expected))
         {
             if (const auto * func = lambda->as<ASTFunction>(); func && func->name == "lambda")
             {
@@ -2396,38 +1501,10 @@ bool ParserMySQLGlobalVariable::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     }
 
     auto name_literal = std::make_shared<ASTLiteral>(name);
-
-    auto expr_list_args = std::make_shared<ASTExpressionList>();
-    expr_list_args->children.push_back(std::move(name_literal));
-
-    auto function_node = std::make_shared<ASTFunction>();
-    function_node->name = "globalVariable";
-    function_node->arguments = expr_list_args;
-    function_node->children.push_back(expr_list_args);
-
-    node = function_node;
+    node = makeASTFunction("globalVariable", name_literal);
     node->setAlias("@@" + name);
-    return true;
-}
 
-
-bool ParserExpressionElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    return ParserSubquery().parse(pos, node, expected)
-        || ParserCastOperator().parse(pos, node, expected)
-        || ParserTupleOfLiterals().parse(pos, node, expected)
-        || ParserParenthesisExpression().parse(pos, node, expected)
-        || ParserArrayOfLiterals().parse(pos, node, expected)
-        || ParserArray().parse(pos, node, expected)
-        || ParserLiteral().parse(pos, node, expected)
-        || ParserCase().parse(pos, node, expected)
-        || ParserColumnsMatcher().parse(pos, node, expected) /// before ParserFunction because it can be also parsed as a function.
-        || ParserFunction().parse(pos, node, expected)
-        || ParserQualifiedAsterisk().parse(pos, node, expected)
-        || ParserAsterisk().parse(pos, node, expected)
-        || ParserCompoundIdentifier(false, true).parse(pos, node, expected)
-        || ParserSubstitution().parse(pos, node, expected)
-        || ParserMySQLGlobalVariable().parse(pos, node, expected);
+    return true;
 }
 
 
diff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h
index 3883631b61cb..f538555f0c1d 100644
--- a/src/Parsers/ExpressionElementParsers.h
+++ b/src/Parsers/ExpressionElementParsers.h
@@ -9,26 +9,6 @@ namespace DB
 {
 
 
-class ParserArray : public IParserBase
-{
-protected:
-    const char * getName() const override { return "array"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-/** If in parenthesis an expression from one element - returns this element in `node`;
-  *  or if there is a SELECT subquery in parenthesis, then this subquery returned in `node`;
-  *  otherwise returns `tuple` function from the contents of brackets.
-  */
-class ParserParenthesisExpression : public IParserBase
-{
-protected:
-    const char * getName() const override { return "parenthesized expression"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
 /** The SELECT subquery is in parenthesis.
   */
 class ParserSubquery : public IParserBase
@@ -141,36 +121,6 @@ class ParserColumnsMatcher : public IParserBase
     ColumnTransformers allowed_transformers;
 };
 
-/** A function, for example, f(x, y + 1, g(z)).
-  * Or an aggregate function: sum(x + f(y)), corr(x, y). The syntax is the same as the usual function.
-  * Or a parametric aggregate function: quantile(0.9)(x + y).
-  *  Syntax - two pairs of parentheses instead of one. The first is for parameters, the second for arguments.
-  * For functions, the DISTINCT modifier can be specified, for example, count(DISTINCT x, y).
-  */
-class ParserFunction : public IParserBase
-{
-public:
-    explicit ParserFunction(bool allow_function_parameters_ = true, bool is_table_function_ = false)
-        : allow_function_parameters(allow_function_parameters_), is_table_function(is_table_function_)
-    {
-    }
-
-protected:
-    const char * getName() const override { return "function"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-    bool allow_function_parameters;
-    bool is_table_function;
-};
-
-// A special function parser for view and viewIfPermitted table functions.
-// It parses an SELECT query as its argument and doesn't support getColumnName().
-class ParserTableFunctionView : public IParserBase
-{
-protected:
-    const char * getName() const override { return "function"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
 // Allows to make queries like SELECT SUM(<expr>) FILTER(WHERE <cond>) FROM ...
 class ParserFilterClause : public IParserBase
 {
@@ -394,16 +344,6 @@ class ParserMySQLGlobalVariable : public IParserBase
 };
 
 
-/** The expression element is one of: an expression in parentheses, an array, a literal, a function, an identifier, an asterisk.
-  */
-class ParserExpressionElement : public IParserBase
-{
-protected:
-    const char * getName() const override { return "element of expression"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
 /** An expression element, possibly with an alias, if appropriate.
   */
 class ParserWithOptionalAlias : public IParserBase
diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp
index 4e88e5c68e6a..f7a016a59e40 100644
--- a/src/Parsers/ExpressionListParsers.cpp
+++ b/src/Parsers/ExpressionListParsers.cpp
@@ -19,80 +19,21 @@
 #include <Parsers/parseIntervalKind.h>
 #include <Common/StringUtils/StringUtils.h>
 
-using namespace std::literals;
-
-
-namespace DB
-{
-
-const char * ParserMultiplicativeExpression::operators[] =
-{
-    "*",     "multiply",
-    "/",     "divide",
-    "%",     "modulo",
-    "MOD",   "modulo",
-    "DIV",   "intDiv",
-    nullptr
-};
-
-const char * ParserUnaryExpression::operators[] =
-{
-    "-",     "negate",
-    "NOT",   "not",
-    nullptr
-};
-
-const char * ParserAdditiveExpression::operators[] =
-{
-    "+",     "plus",
-    "-",     "minus",
-    nullptr
-};
+#include <Parsers/ParserSelectWithUnionQuery.h>
 
-const char * ParserComparisonExpression::operators[] =
-{
-    "==",            "equals",
-    "!=",            "notEquals",
-    "<>",            "notEquals",
-    "<=",            "lessOrEquals",
-    ">=",            "greaterOrEquals",
-    "<",             "less",
-    ">",             "greater",
-    "=",             "equals",
-    "LIKE",          "like",
-    "ILIKE",         "ilike",
-    "NOT LIKE",      "notLike",
-    "NOT ILIKE",     "notILike",
-    "IN",            "in",
-    "NOT IN",        "notIn",
-    "GLOBAL IN",     "globalIn",
-    "GLOBAL NOT IN", "globalNotIn",
-    nullptr
-};
+#include <Common/logger_useful.h>
+#include <Parsers/queryToString.h>
 
-const char * ParserComparisonExpression::overlapping_operators_to_skip[] =
-{
-    "IN PARTITION",
-    nullptr
-};
+using namespace std::literals;
 
-const char * ParserLogicalNotExpression::operators[] =
-{
-    "NOT", "not",
-    nullptr
-};
 
-const char * ParserArrayElementExpression::operators[] =
+namespace DB
 {
-    "[", "arrayElement",
-    nullptr
-};
 
-const char * ParserTupleElementExpression::operators[] =
+namespace ErrorCodes
 {
-    ".", "tupleElement",
-    nullptr
-};
+    extern const int SYNTAX_ERROR;
+}
 
 
 bool ParserList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
@@ -298,7 +239,7 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node
         if (first)
         {
             ASTPtr elem;
-            if (!first_elem_parser->parse(pos, elem, expected))
+            if (!elem_parser->parse(pos, elem, expected))
                 return false;
 
             node = elem;
@@ -307,16 +248,7 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node
         else
         {
             /// try to find any of the valid operators
-
             const char ** it;
-            Expected stub;
-            for (it = overlapping_operators_to_skip; *it; ++it)
-                if (ParserKeyword{*it}.checkWithoutMoving(pos, stub))
-                    break;
-
-            if (*it)
-                break;
-
             for (it = operators; *it; it += 2)
                 if (parseOperator(pos, *it, expected))
                     break;
@@ -324,40 +256,13 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node
             if (!*it)
                 break;
 
-            /// the function corresponding to the operator
-            auto function = std::make_shared<ASTFunction>();
-
-            /// function arguments
-            auto exp_list = std::make_shared<ASTExpressionList>();
-
             ASTPtr elem;
-            SubqueryFunctionType subquery_function_type = SubqueryFunctionType::NONE;
-
-            if (comparison_expression)
-            {
-                if (ParserKeyword("ANY").ignore(pos, expected))
-                    subquery_function_type = SubqueryFunctionType::ANY;
-                else if (ParserKeyword("ALL").ignore(pos, expected))
-                    subquery_function_type = SubqueryFunctionType::ALL;
-            }
 
-            if (subquery_function_type != SubqueryFunctionType::NONE && !ParserSubquery().parse(pos, elem, expected))
-                subquery_function_type = SubqueryFunctionType::NONE;
-
-            if (subquery_function_type == SubqueryFunctionType::NONE
-                && !(remaining_elem_parser ? remaining_elem_parser : first_elem_parser)->parse(pos, elem, expected))
+            if (!elem_parser->parse(pos, elem, expected))
                 return false;
 
             /// the first argument of the function is the previous element, the second is the next one
-            function->name = it[1];
-            function->arguments = exp_list;
-            function->children.push_back(exp_list);
-
-            exp_list->children.push_back(node);
-            exp_list->children.push_back(elem);
-
-            if (comparison_expression && subquery_function_type != SubqueryFunctionType::NONE && !modifyAST(function, subquery_function_type))
-                return false;
+            auto function = makeASTFunction(it[1], node, elem);
 
             /** special exception for the access operator to the element of the array `x[y]`, which
               * contains the infix part '[' and the suffix ''] '(specified as' [')
@@ -381,369 +286,24 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node
 }
 
 
-bool ParserVariableArityOperatorList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ASTPtr arguments;
-
-    if (!elem_parser->parse(pos, node, expected))
-        return false;
-
-    while (true)
-    {
-        if (!parseOperator(pos, infix, expected))
-            break;
-
-        if (!arguments)
-        {
-            node = makeASTFunction(function_name, node);
-            arguments = node->as<ASTFunction &>().arguments;
-        }
-
-        ASTPtr elem;
-        if (!elem_parser->parse(pos, elem, expected))
-            return false;
-
-        arguments->children.push_back(elem);
-    }
-
-    return true;
-}
-
-bool ParserBetweenExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    /// For the expression (subject [NOT] BETWEEN left AND right)
-    /// create an AST the same as for (subject >= left AND subject <= right).
-
-    ParserKeyword s_not("NOT");
-    ParserKeyword s_between("BETWEEN");
-    ParserKeyword s_and("AND");
-
-    ASTPtr subject;
-    ASTPtr left;
-    ASTPtr right;
-
-    if (!elem_parser.parse(pos, subject, expected))
-        return false;
-
-    bool negative = s_not.ignore(pos, expected);
-
-    if (!s_between.ignore(pos, expected))
-    {
-        if (negative)
-            --pos;
-
-        /// No operator was parsed, just return element.
-        node = subject;
-    }
-    else
-    {
-        if (!elem_parser.parse(pos, left, expected))
-            return false;
-
-        if (!s_and.ignore(pos, expected))
-            return false;
-
-        if (!elem_parser.parse(pos, right, expected))
-            return false;
-
-        auto f_combined_expression = std::make_shared<ASTFunction>();
-        auto args_combined_expression = std::make_shared<ASTExpressionList>();
-
-        /// [NOT] BETWEEN left AND right
-        auto f_left_expr = std::make_shared<ASTFunction>();
-        auto args_left_expr = std::make_shared<ASTExpressionList>();
-
-        auto f_right_expr = std::make_shared<ASTFunction>();
-        auto args_right_expr = std::make_shared<ASTExpressionList>();
-
-        args_left_expr->children.emplace_back(subject);
-        args_left_expr->children.emplace_back(left);
-
-        args_right_expr->children.emplace_back(subject);
-        args_right_expr->children.emplace_back(right);
-
-        if (negative)
-        {
-            /// NOT BETWEEN
-            f_left_expr->name = "less";
-            f_right_expr->name = "greater";
-            f_combined_expression->name = "or";
-        }
-        else
-        {
-            /// BETWEEN
-            f_left_expr->name = "greaterOrEquals";
-            f_right_expr->name = "lessOrEquals";
-            f_combined_expression->name = "and";
-        }
-
-        f_left_expr->arguments = args_left_expr;
-        f_left_expr->children.emplace_back(f_left_expr->arguments);
-
-        f_right_expr->arguments = args_right_expr;
-        f_right_expr->children.emplace_back(f_right_expr->arguments);
-
-        args_combined_expression->children.emplace_back(f_left_expr);
-        args_combined_expression->children.emplace_back(f_right_expr);
-
-        f_combined_expression->arguments = args_combined_expression;
-        f_combined_expression->children.emplace_back(f_combined_expression->arguments);
-
-        node = f_combined_expression;
-    }
-
-    return true;
-}
-
-bool ParserTernaryOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ParserToken symbol1(TokenType::QuestionMark);
-    ParserToken symbol2(TokenType::Colon);
-
-    ASTPtr elem_cond;
-    ASTPtr elem_then;
-    ASTPtr elem_else;
-
-    if (!elem_parser.parse(pos, elem_cond, expected))
-        return false;
-
-    if (!symbol1.ignore(pos, expected))
-        node = elem_cond;
-    else
-    {
-        if (!elem_parser.parse(pos, elem_then, expected))
-            return false;
-
-        if (!symbol2.ignore(pos, expected))
-            return false;
-
-        if (!elem_parser.parse(pos, elem_else, expected))
-            return false;
-
-        /// the function corresponding to the operator
-        auto function = std::make_shared<ASTFunction>();
-
-        /// function arguments
-        auto exp_list = std::make_shared<ASTExpressionList>();
-
-        function->name = "if";
-        function->arguments = exp_list;
-        function->children.push_back(exp_list);
-
-        exp_list->children.push_back(elem_cond);
-        exp_list->children.push_back(elem_then);
-        exp_list->children.push_back(elem_else);
-
-        node = function;
-    }
-
-    return true;
-}
-
-
-bool ParserLambdaExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ParserToken arrow(TokenType::Arrow);
-    ParserToken open(TokenType::OpeningRoundBracket);
-    ParserToken close(TokenType::ClosingRoundBracket);
-
-    Pos begin = pos;
-
-    do
-    {
-        ASTPtr inner_arguments;
-        ASTPtr expression;
-
-        bool was_open = false;
-
-        if (open.ignore(pos, expected))
-        {
-            was_open = true;
-        }
-
-        if (!ParserList(std::make_unique<ParserIdentifier>(), std::make_unique<ParserToken>(TokenType::Comma)).parse(pos, inner_arguments, expected))
-            break;
-
-        if (was_open)
-        {
-            if (!close.ignore(pos, expected))
-                break;
-        }
-
-        if (!arrow.ignore(pos, expected))
-            break;
-
-        if (!elem_parser.parse(pos, expression, expected))
-            return false;
-
-        /// lambda(tuple(inner_arguments), expression)
-
-        auto lambda = std::make_shared<ASTFunction>();
-        node = lambda;
-        lambda->name = "lambda";
-
-        auto outer_arguments = std::make_shared<ASTExpressionList>();
-        lambda->arguments = outer_arguments;
-        lambda->children.push_back(lambda->arguments);
-
-        auto tuple = std::make_shared<ASTFunction>();
-        outer_arguments->children.push_back(tuple);
-        tuple->name = "tuple";
-        tuple->arguments = inner_arguments;
-        tuple->children.push_back(inner_arguments);
-
-        outer_arguments->children.push_back(expression);
-
-        return true;
-    }
-    while (false);
-
-    pos = begin;
-    return elem_parser.parse(pos, node, expected);
-}
-
-
-bool ParserTableFunctionExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    if (ParserTableFunctionView().parse(pos, node, expected))
-        return true;
-    ParserKeyword s_settings("SETTINGS");
-    if (s_settings.ignore(pos, expected))
-    {
-        ParserSetQuery parser_settings(true);
-        if (parser_settings.parse(pos, node, expected))
-            return true;
-    }
-    return elem_parser.parse(pos, node, expected);
-}
-
-
-bool ParserPrefixUnaryOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    /// try to find any of the valid operators
-    const char ** it;
-    for (it = operators; *it; it += 2)
-    {
-        if (parseOperator(pos, *it, expected))
-            break;
-    }
-
-    /// Let's parse chains of the form `NOT NOT x`. This is hack.
-    /** This is done, because among the unary operators there is only a minus and NOT.
-      * But for a minus the chain of unary operators does not need to be supported.
-      */
-    size_t count = 1;
-    if (it[0] && 0 == strncmp(it[0], "NOT", 3))
-    {
-        while (true)
-        {
-            const char ** jt;
-            for (jt = operators; *jt; jt += 2)
-                if (parseOperator(pos, *jt, expected))
-                    break;
-
-            if (!*jt)
-                break;
-
-            ++count;
-        }
-    }
-
-    ASTPtr elem;
-    if (!elem_parser->parse(pos, elem, expected))
-        return false;
-
-    if (!*it)
-        node = elem;
-    else
-    {
-        for (size_t i = 0; i < count; ++i)
-        {
-            /// the function corresponding to the operator
-            auto function = std::make_shared<ASTFunction>();
-
-            /// function arguments
-            auto exp_list = std::make_shared<ASTExpressionList>();
-
-            function->name = it[1];
-            function->arguments = exp_list;
-            function->children.push_back(exp_list);
-
-            if (node)
-                exp_list->children.push_back(node);
-            else
-                exp_list->children.push_back(elem);
-
-            node = function;
-        }
-    }
-
-    return true;
-}
-
-
-bool ParserUnaryExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    /// As an exception, negative numbers should be parsed as literals, and not as an application of the operator.
-
-    if (pos->type == TokenType::Minus)
-    {
-        Pos begin = pos;
-        if (ParserCastOperator().parse(pos, node, expected))
-            return true;
-
-        pos = begin;
-        if (ParserLiteral().parse(pos, node, expected))
-            return true;
-
-        pos = begin;
-    }
-
-    return operator_parser.parse(pos, node, expected);
-}
-
-
-bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+ASTPtr makeBetweenOperator(bool negative, ASTs arguments)
 {
-    ASTPtr expr_ast;
-    if (!elem_parser->parse(pos, expr_ast, expected))
-        return false;
+    // SUBJECT = arguments[0], LEFT = arguments[1], RIGHT = arguments[2]
 
-    ASTPtr type_ast;
-    if (ParserToken(TokenType::DoubleColon).ignore(pos, expected)
-        && ParserDataType().parse(pos, type_ast, expected))
+    if (negative)
     {
-        node = createFunctionCast(expr_ast, type_ast);
+        auto f_left_expr = makeASTFunction("less", arguments[0], arguments[1]);
+        auto f_right_expr = makeASTFunction("greater", arguments[0], arguments[2]);
+        return makeASTFunction("or", f_left_expr, f_right_expr);
     }
     else
     {
-        node = expr_ast;
+        auto f_left_expr = makeASTFunction("greaterOrEquals", arguments[0], arguments[1]);
+        auto f_right_expr = makeASTFunction("lessOrEquals", arguments[0], arguments[2]);
+        return makeASTFunction("and", f_left_expr, f_right_expr);
     }
-
-    return true;
-}
-
-
-bool ParserArrayElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected &expected)
-{
-    return ParserLeftAssociativeBinaryOperatorList{
-        operators,
-        std::make_unique<ParserCastExpression>(std::make_unique<ParserExpressionElement>()),
-        std::make_unique<ParserExpressionWithOptionalAlias>(false)
-    }.parse(pos, node, expected);
-}
-
-
-bool ParserTupleElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected &expected)
-{
-    return ParserLeftAssociativeBinaryOperatorList{
-        operators,
-        std::make_unique<ParserCastExpression>(std::make_unique<ParserArrayElementExpression>()),
-        std::make_unique<ParserUnsignedInteger>()
-    }.parse(pos, node, expected);
 }
 
-
 ParserExpressionWithOptionalAlias::ParserExpressionWithOptionalAlias(bool allow_alias_without_as_keyword, bool is_table_function)
     : impl(std::make_unique<ParserWithOptionalAlias>(
         is_table_function ? ParserPtr(std::make_unique<ParserTableFunctionExpression>()) : ParserPtr(std::make_unique<ParserExpression>()),
@@ -760,7 +320,6 @@ bool ParserExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expect
         .parse(pos, node, expected);
 }
 
-
 bool ParserNotEmptyExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     return nested_parser.parse(pos, node, expected) && !node->children.empty();
@@ -836,221 +395,2135 @@ bool ParserTTLExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & exp
 }
 
 
-bool ParserNullityChecking::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+bool ParserKeyValuePair::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
-    ASTPtr node_comp;
-    if (!elem_parser.parse(pos, node_comp, expected))
-        return false;
+    ParserIdentifier id_parser;
+    ParserLiteral literal_parser;
+    ParserFunction func_parser;
 
-    ParserKeyword s_is{"IS"};
-    ParserKeyword s_not{"NOT"};
-    ParserKeyword s_null{"NULL"};
+    ASTPtr identifier;
+    ASTPtr value;
+    bool with_brackets = false;
+    if (!id_parser.parse(pos, identifier, expected))
+        return false;
 
-    if (s_is.ignore(pos, expected))
+    /// If it's neither literal, nor identifier, nor function, than it's possible list of pairs
+    if (!func_parser.parse(pos, value, expected) && !literal_parser.parse(pos, value, expected) && !id_parser.parse(pos, value, expected))
     {
-        bool is_not = false;
-        if (s_not.ignore(pos, expected))
-            is_not = true;
+        ParserKeyValuePairsList kv_pairs_list;
+        ParserToken open(TokenType::OpeningRoundBracket);
+        ParserToken close(TokenType::ClosingRoundBracket);
 
-        if (!s_null.ignore(pos, expected))
+        if (!open.ignore(pos))
             return false;
 
-        auto args = std::make_shared<ASTExpressionList>();
-        args->children.push_back(node_comp);
+        if (!kv_pairs_list.parse(pos, value, expected))
+            return false;
 
-        auto function = std::make_shared<ASTFunction>();
-        function->name = is_not ? "isNotNull" : "isNull";
-        function->arguments = args;
-        function->children.push_back(function->arguments);
+        if (!close.ignore(pos))
+            return false;
 
-        node = function;
+        with_brackets = true;
     }
-    else
-        node = node_comp;
-
-    return true;
-}
 
-bool ParserDateOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+    auto pair = std::make_shared<ASTPair>(with_brackets);
+    pair->first = Poco::toLower(identifier->as<ASTIdentifier>()->name());
+    pair->set(pair->second, value);
+    node = pair;
+    return true;
+}
+
+bool ParserKeyValuePairsList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    ParserList parser(std::make_unique<ParserKeyValuePair>(), std::make_unique<ParserNothing>(), true, 0);
+    return parser.parse(pos, node, expected);
+}
+
+
+enum class Action
+{
+    NONE,
+    OPERAND,
+    OPERATOR
+};
+
+/** Operator types are needed for special handling of certain operators.
+  * Operators can be grouped into some type if they have similar behaviour.
+  * Certain operators are unique in terms of their behaviour, so they are assigned a separate type.
+  */
+enum class OperatorType
+{
+    None,
+    Comparison,
+    Mergeable,
+    ArrayElement,
+    TupleElement,
+    IsNull,
+    StartBetween,
+    StartNotBetween,
+    FinishBetween,
+    StartIf,
+    FinishIf,
+    Cast,
+    Lambda
+};
+
+/** Operator struct stores parameters of the operator:
+  *  - function_name  name of the function that operator will create
+  *  - priority       priority of the operator relative to the other operators
+  *  - arity          the amount of arguments that operator will consume
+  *  - type           type of the operator that defines its behaviour
+  */
+struct Operator
+{
+    Operator() = default;
+
+    Operator(const std::string & function_name_, int priority_, int arity_ = 2, OperatorType type_ = OperatorType::None)
+        : type(type_), priority(priority_), arity(arity_), function_name(function_name_) {}
+
+    OperatorType type;
+    int priority;
+    int arity;
+    std::string function_name;
+};
+
+enum class Checkpoint
+{
+    None,
+    Interval,
+    Case
+};
+
+/** Layer is a class that represents context for parsing certain element,
+  *  that consists of other elements e.g. f(x1, x2, x3)
+  *
+  *  - Manages operands and operators for the future elements (arguments)
+  *  - Combines operands and operator into one element
+  *  - Parsers separators and endings
+  *  - Combines resulting elements into a function
+  */
+
+class Layer
+{
+public:
+    explicit Layer(bool allow_alias_ = true, bool allow_alias_without_as_keyword_ = true) :
+        allow_alias(allow_alias_), allow_alias_without_as_keyword(allow_alias_without_as_keyword_)
+    {
+    }
+
+    virtual ~Layer() = default;
+
+    bool popOperator(Operator & op)
+    {
+        if (operators.empty())
+            return false;
+
+        op = std::move(operators.back());
+        operators.pop_back();
+
+        return true;
+    }
+
+    void pushOperator(Operator op)
+    {
+        operators.push_back(std::move(op));
+    }
+
+    bool popOperand(ASTPtr & op)
+    {
+        if (operands.empty())
+            return false;
+
+        op = std::move(operands.back());
+        operands.pop_back();
+
+        return true;
+    }
+
+    void pushOperand(ASTPtr op)
+    {
+        operands.push_back(std::move(op));
+    }
+
+    void pushResult(ASTPtr op)
+    {
+        elements.push_back(std::move(op));
+    }
+
+    virtual bool getResult(ASTPtr & node)
+    {
+        if (elements.size() == 1)
+        {
+            node = std::move(elements[0]);
+            return true;
+        }
+
+        return false;
+    }
+
+    virtual bool parse(IParser::Pos & /*pos*/, Expected & /*expected*/, Action & /*action*/) = 0;
+
+    bool isFinished() const
+    {
+        return finished;
+    }
+
+    int previousPriority() const
+    {
+        if (operators.empty())
+            return 0;
+
+        return operators.back().priority;
+    }
+
+    OperatorType previousType() const
+    {
+        if (operators.empty())
+            return OperatorType::None;
+
+        return operators.back().type;
+    }
+
+    int isCurrentElementEmpty() const
+    {
+        return operators.empty() && operands.empty();
+    }
+
+    bool popLastNOperands(ASTs & asts, size_t n)
+    {
+        if (n > operands.size())
+            return false;
+
+        asts.reserve(asts.size() + n);
+
+        auto start = operands.begin() + operands.size() - n;
+        asts.insert(asts.end(), std::make_move_iterator(start), std::make_move_iterator(operands.end()));
+        operands.erase(start, operands.end());
+
+        return true;
+    }
+
+    /// Merge operators and operands into a single element (column), then push it to 'elements' vector.
+    ///  Operators are previously sorted in ascending order of priority
+    ///  (operator with priority 1 has higher priority than operator with priority 2),
+    ///  so we can just merge them with operands starting from the end.
+    ///
+    /// If we fail here it means that the query was incorrect and we should return an error.
+    ///
+    bool mergeElement(bool push_to_elements = true)
+    {
+        Operator cur_op;
+        while (popOperator(cur_op))
+        {
+            ASTPtr function;
+
+            // Special case of ternary operator
+            if (cur_op.type == OperatorType::StartIf)
+                return false;
+
+            if (cur_op.type == OperatorType::FinishIf)
+            {
+                Operator tmp;
+                if (!popOperator(tmp) || tmp.type != OperatorType::StartIf)
+                    return false;
+            }
+
+            // Special case of a BETWEEN b AND c operator
+            if (cur_op.type == OperatorType::StartBetween || cur_op.type == OperatorType::StartNotBetween)
+                return false;
+
+            if (cur_op.type == OperatorType::FinishBetween)
+            {
+                Operator tmp_op;
+                if (!popOperator(tmp_op))
+                    return false;
+
+                if (tmp_op.type != OperatorType::StartBetween && tmp_op.type != OperatorType::StartNotBetween)
+                    return false;
+
+                bool negative = tmp_op.type == OperatorType::StartNotBetween;
+
+                ASTs arguments;
+                if (!popLastNOperands(arguments, 3))
+                    return false;
+
+                function = makeBetweenOperator(negative, arguments);
+            }
+            else
+            {
+                function = makeASTFunction(cur_op.function_name);
+
+                if (!popLastNOperands(function->children[0]->children, cur_op.arity))
+                    return false;
+            }
+
+            pushOperand(function);
+        }
+
+        ASTPtr node;
+        if (!popOperand(node))
+            return false;
+
+        bool res = isCurrentElementEmpty();
+
+        if (push_to_elements)
+            pushResult(node);
+        else
+            pushOperand(node);
+
+        return res;
+    }
+
+    bool parseLambda()
+    {
+        // 0. If empty - create function tuple with 0 args
+        if (isCurrentElementEmpty())
+        {
+            auto function = makeASTFunction("tuple");
+            pushOperand(function);
+            return true;
+        }
+
+        if (operands.size() != 1 || !operators.empty() || !mergeElement())
+            return false;
+
+        /// 1. If there is already tuple do nothing
+        if (tryGetFunctionName(elements.back()) == "tuple")
+        {
+            pushOperand(elements.back());
+            elements.pop_back();
+        }
+        /// 2. Put all elements in a single tuple
+        else
+        {
+            auto function = makeASTFunction("tuple", elements);
+            elements.clear();
+            pushOperand(function);
+        }
+        return true;
+    }
+
+    /// Put 'node' identifier into the last operand as its alias
+    bool insertAlias(ASTPtr node)
+    {
+        if (!mergeElement(false))
+            return false;
+
+        if (operands.empty())
+            return false;
+
+        if (auto * ast_with_alias = dynamic_cast<ASTWithAlias *>(operands.back().get()))
+        {
+            tryGetIdentifierNameInto(node, ast_with_alias->alias);
+            return true;
+        }
+
+        return false;
+    }
+
+    bool is_table_function = false;
+
+    /// 'AND' in operator '... BETWEEN ... AND ...'  mirrors logical operator 'AND'.
+    ///  In order to distinguish them we keep a counter of BETWEENs without matching ANDs.
+    int between_counter = 0;
+
+    bool allow_alias = true;
+    bool allow_alias_without_as_keyword = true;
+
+    std::optional<std::pair<IParser::Pos, Checkpoint>> saved_checkpoint;
+    Checkpoint current_checkpoint = Checkpoint::None;
+
+protected:
+    std::vector<Operator> operators;
+    ASTs operands;
+    ASTs elements;
+    bool finished = false;
+    int state = 0;
+};
+
+
+class ExpressionLayer : public Layer
+{
+public:
+
+    explicit ExpressionLayer(bool is_table_function_) : Layer(false, false)
+    {
+        is_table_function = is_table_function_;
+    }
+
+    bool getResult(ASTPtr & node) override
+    {
+        /// We can exit the main cycle outside the parse() function,
+        ///  so we need to merge the element here
+        if (!mergeElement())
+            return false;
+
+        if (elements.size() == 1)
+        {
+            node = std::move(elements[0]);
+            return true;
+        }
+
+        return false;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & /*expected*/, Action & /*action*/) override
+    {
+        if (pos->type == TokenType::Comma)
+            finished = true;
+
+        return true;
+    }
+};
+
+
+/// Basic layer for a function with certain separator and end tokens:
+///  1. If we parse a separator we should merge current operands and operators
+///     into one element and push in to 'elements' vector.
+///  2. If we parse an ending token, we should merge everything as in (1) and
+///     also set 'finished' flag.
+template <TokenType separator, TokenType end>
+class BaseLayer : public Layer
+{
+public:
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        if (ParserToken(separator).ignore(pos, expected))
+        {
+            action = Action::OPERAND;
+            return mergeElement();
+        }
+
+        if (ParserToken(end).ignore(pos, expected))
+        {
+            action = Action::OPERATOR;
+
+            if (!isCurrentElementEmpty() || !elements.empty())
+                if (!mergeElement())
+                    return false;
+
+            finished = true;
+        }
+
+        return true;
+    }
+};
+
+
+class OrdinaryFunctionLayer : public Layer
+{
+public:
+    explicit OrdinaryFunctionLayer(String function_name_, bool allow_function_parameters_ = true)
+        : function_name(function_name_), allow_function_parameters(allow_function_parameters_){}
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        ///   | 0 |      1      |     2    |
+        ///  f(ALL ...)(ALL ...) FILTER ...
+        ///
+        /// 0. Parse ALL and DISTINCT qualifiers (-> 1)
+        /// 1. Parse all the arguments and ending token (-> 2), possibly with parameters list (-> 1)
+        /// 2. Create function, possibly parse FILTER and OVER window definitions (finished)
+
+        if (state == 0)
+        {
+            state = 1;
+
+            auto pos_after_bracket = pos;
+            auto old_expected = expected;
+
+            ParserKeyword all("ALL");
+            ParserKeyword distinct("DISTINCT");
+
+            if (all.ignore(pos, expected))
+                has_all = true;
+
+            if (distinct.ignore(pos, expected))
+                has_distinct = true;
+
+            if (!has_all && all.ignore(pos, expected))
+                has_all = true;
+
+            if (has_all && has_distinct)
+                return false;
+
+            if (has_all || has_distinct)
+            {
+                /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier
+                if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)
+                {
+                    pos = pos_after_bracket;
+                    expected = old_expected;
+                    has_all = false;
+                    has_distinct = false;
+                }
+            }
+
+            contents_begin = pos->begin;
+        }
+
+        if (state == 1)
+        {
+            if (ParserToken(TokenType::Comma).ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+                return mergeElement();
+            }
+
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                action = Action::OPERATOR;
+
+                if (!isCurrentElementEmpty() || !elements.empty())
+                    if (!mergeElement())
+                        return false;
+
+                contents_end = pos->begin;
+
+                /** Check for a common error case - often due to the complexity of quoting command-line arguments,
+                 *  an expression of the form toDate(2014-01-01) appears in the query instead of toDate('2014-01-01').
+                 * If you do not report that the first option is an error, then the argument will be interpreted as 2014 - 01 - 01 - some number,
+                 *  and the query silently returns an unexpected elements.
+                 */
+                if (function_name == "toDate"
+                    && contents_end - contents_begin == strlen("2014-01-01")
+                    && contents_begin[0] >= '2' && contents_begin[0] <= '3'
+                    && contents_begin[1] >= '0' && contents_begin[1] <= '9'
+                    && contents_begin[2] >= '0' && contents_begin[2] <= '9'
+                    && contents_begin[3] >= '0' && contents_begin[3] <= '9'
+                    && contents_begin[4] == '-'
+                    && contents_begin[5] >= '0' && contents_begin[5] <= '9'
+                    && contents_begin[6] >= '0' && contents_begin[6] <= '9'
+                    && contents_begin[7] == '-'
+                    && contents_begin[8] >= '0' && contents_begin[8] <= '9'
+                    && contents_begin[9] >= '0' && contents_begin[9] <= '9')
+                {
+                    std::string contents_str(contents_begin, contents_end - contents_begin);
+                    throw Exception("Argument of function toDate is unquoted: toDate(" + contents_str + "), must be: toDate('" + contents_str + "')"
+                        , ErrorCodes::SYNTAX_ERROR);
+                }
+
+                if (allow_function_parameters && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))
+                {
+                    parameters = std::make_shared<ASTExpressionList>();
+                    std::swap(parameters->children, elements);
+                    action = Action::OPERAND;
+
+                    /// Parametric aggregate functions cannot have DISTINCT in parameters list.
+                    if (has_distinct)
+                        return false;
+
+                    auto pos_after_bracket = pos;
+                    auto old_expected = expected;
+
+                    ParserKeyword all("ALL");
+                    ParserKeyword distinct("DISTINCT");
+
+                    if (all.ignore(pos, expected))
+                        has_all = true;
+
+                    if (distinct.ignore(pos, expected))
+                        has_distinct = true;
+
+                    if (!has_all && all.ignore(pos, expected))
+                        has_all = true;
+
+                    if (has_all && has_distinct)
+                        return false;
+
+                    if (has_all || has_distinct)
+                    {
+                        /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier
+                        if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)
+                        {
+                            pos = pos_after_bracket;
+                            expected = old_expected;
+                            has_distinct = false;
+                        }
+                    }
+                }
+                else
+                {
+                    state = 2;
+                }
+            }
+        }
+
+        if (state == 2)
+        {
+            if (has_distinct)
+                function_name += "Distinct";
+
+            auto function_node = makeASTFunction(function_name, std::move(elements));
+
+            if (parameters)
+            {
+                function_node->parameters = parameters;
+                function_node->children.push_back(function_node->parameters);
+            }
+
+            ParserKeyword filter("FILTER");
+            ParserKeyword over("OVER");
+
+            if (filter.ignore(pos, expected))
+            {
+                // We are slightly breaking the parser interface by parsing the window
+                // definition into an existing ASTFunction. Normally it would take a
+                // reference to ASTPtr and assign it the new node. We only have a pointer
+                // of a different type, hence this workaround with a temporary pointer.
+                ASTPtr function_node_as_iast = function_node;
+
+                // Recursion
+                ParserFilterClause filter_parser;
+                if (!filter_parser.parse(pos, function_node_as_iast, expected))
+                    return false;
+            }
+
+            if (over.ignore(pos, expected))
+            {
+                function_node->is_window_function = true;
+
+                ASTPtr function_node_as_iast = function_node;
+
+                // Recursion
+                ParserWindowReference window_reference;
+                if (!window_reference.parse(pos, function_node_as_iast, expected))
+                    return false;
+            }
+
+            elements = {function_node};
+            finished = true;
+        }
+
+        return true;
+    }
+
+private:
+    bool has_all = false;
+    bool has_distinct = false;
+
+    const char * contents_begin;
+    const char * contents_end;
+
+    String function_name;
+    ASTPtr parameters;
+
+    bool allow_function_parameters;
+};
+
+/// Layer for priority brackets and tuple function
+class RoundBracketsLayer : public Layer
+{
+public:
+    bool getResult(ASTPtr & node) override
+    {
+        // Round brackets can mean priority operator as well as function tuple()
+        if (!is_tuple && elements.size() == 1)
+            node = std::move(elements[0]);
+        else
+            node = makeASTFunction("tuple", std::move(elements));
+
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        if (ParserToken(TokenType::Comma).ignore(pos, expected))
+        {
+            action = Action::OPERAND;
+            is_tuple = true;
+            if (!mergeElement())
+                return false;
+        }
+
+        if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+        {
+            action = Action::OPERATOR;
+
+            if (!isCurrentElementEmpty())
+                if (!mergeElement())
+                    return false;
+
+            // Special case for (('a', 'b')) -> tuple(('a', 'b'))
+            if (!is_tuple && elements.size() == 1)
+                if (auto * literal = elements[0]->as<ASTLiteral>())
+                    if (literal->value.getType() == Field::Types::Tuple)
+                        is_tuple = true;
+
+            finished = true;
+        }
+
+        return true;
+    }
+private:
+    bool is_tuple = false;
+};
+
+/// Layer for array square brackets operator
+class ArrayLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingSquareBracket>
+{
+public:
+    bool getResult(ASTPtr & node) override
+    {
+        node = makeASTFunction("array", std::move(elements));
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        return BaseLayer::parse(pos, expected, action);
+    }
+};
+
+/// Layer for arrayElement square brackets operator
+///  This layer does not create a function, it is only needed to parse closing token
+///  and return only one element.
+class ArrayElementLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingSquareBracket>
+{
+public:
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        return BaseLayer::parse(pos, expected, action);
+    }
+};
+
+class CastLayer : public Layer
+{
+public:
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// CAST(x [AS alias1], T [AS alias2]) or CAST(x [AS alias1] AS T)
+        ///
+        /// 0. Parse all the cases (-> 1)
+        /// 1. Parse closing token (finished)
+
+        ParserKeyword as_keyword_parser("AS");
+        ASTPtr alias;
+
+        /// expr AS type
+        if (state == 0)
+        {
+            ASTPtr type_node;
+
+            if (as_keyword_parser.ignore(pos, expected))
+            {
+                auto old_pos = pos;
+
+                if (ParserIdentifier().parse(pos, alias, expected) &&
+                    as_keyword_parser.ignore(pos, expected) &&
+                    ParserDataType().parse(pos, type_node, expected) &&
+                    ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+                {
+                    if (!insertAlias(alias))
+                        return false;
+
+                    if (!mergeElement())
+                        return false;
+
+                    elements = {createFunctionCast(elements[0], type_node)};
+                    finished = true;
+                    return true;
+                }
+
+                pos = old_pos;
+
+                if (ParserIdentifier().parse(pos, alias, expected) &&
+                    ParserToken(TokenType::Comma).ignore(pos, expected))
+                {
+                    action = Action::OPERAND;
+                    if (!insertAlias(alias))
+                        return false;
+
+                    if (!mergeElement())
+                        return false;
+
+                    state = 1;
+                    return true;
+                }
+
+                pos = old_pos;
+
+                if (ParserDataType().parse(pos, type_node, expected) &&
+                    ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+                {
+                    if (!mergeElement())
+                        return false;
+
+                    elements = {createFunctionCast(elements[0], type_node)};
+                    finished = true;
+                    return true;
+                }
+
+                return false;
+            }
+
+            if (ParserToken(TokenType::Comma).ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+
+                state = 1;
+                return true;
+            }
+        }
+        if (state == 1)
+        {
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                elements = {makeASTFunction("CAST", elements[0], elements[1])};
+                finished = true;
+                return true;
+            }
+        }
+
+        return true;
+    }
+};
+
+class ExtractLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingRoundBracket>
+{
+public:
+    bool getResult(ASTPtr & node) override
+    {
+        if (state == 2)
+        {
+            if (elements.empty())
+                return false;
+
+            node = makeASTFunction(interval_kind.toNameOfFunctionExtractTimePart(), elements[0]);
+        }
+        else
+        {
+            node = makeASTFunction("extract", std::move(elements));
+        }
+
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// extract(haystack, pattern) or EXTRACT(DAY FROM Date)
+        ///
+        /// 0. If we parse interval_kind and 'FROM' keyword (-> 2), otherwise (-> 1)
+        /// 1. Basic parser
+        /// 2. Parse closing bracket (finished)
+
+        if (state == 0)
+        {
+            IParser::Pos begin = pos;
+            ParserKeyword s_from("FROM");
+
+            if (parseIntervalKind(pos, expected, interval_kind) && s_from.ignore(pos, expected))
+            {
+                state = 2;
+                return true;
+            }
+            else
+            {
+                state = 1;
+                pos = begin;
+            }
+        }
+
+        if (state == 1)
+        {
+            return BaseLayer::parse(pos, expected, action);
+        }
+
+        if (state == 2)
+        {
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                finished = true;
+                return true;
+            }
+        }
+
+        return true;
+    }
+
+private:
+    IntervalKind interval_kind;
+};
+
+class SubstringLayer : public Layer
+{
+public:
+    bool getResult(ASTPtr & node) override
+    {
+        node = makeASTFunction("substring", std::move(elements));
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// Either SUBSTRING(expr FROM start [FOR length]) or SUBSTRING(expr, start, length)
+        ///
+        /// 0: Parse first separator: FROM or comma (-> 1)
+        /// 1: Parse second separator: FOR or comma (-> 2)
+        /// 1 or 2: Parse closing bracket (finished)
+
+        if (state == 0)
+        {
+            if (ParserToken(TokenType::Comma).ignore(pos, expected) ||
+                ParserKeyword("FROM").ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+
+                state = 1;
+            }
+        }
+
+        if (state == 1)
+        {
+            if (ParserToken(TokenType::Comma).ignore(pos, expected) ||
+                ParserKeyword("FOR").ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+
+                state = 2;
+            }
+        }
+
+        if (state == 1 || state == 2)
+        {
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                finished = true;
+            }
+        }
+
+        return true;
+    }
+};
+
+class PositionLayer : public Layer
+{
+public:
+    bool getResult(ASTPtr & node) override
+    {
+        if (state == 2)
+            std::swap(elements[1], elements[0]);
+
+        node = makeASTFunction("position", std::move(elements));
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// position(haystack, needle[, start_pos]) or position(needle IN haystack)
+        ///
+        /// 0: Parse separator: comma (-> 1) or IN (-> 2)
+        /// 1: Parse second separator: comma
+        /// 1 or 2: Parse closing bracket (finished)
+
+        if (state == 0)
+        {
+            if (ParserToken(TokenType::Comma).ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+
+                state = 1;
+            }
+            if (ParserKeyword("IN").ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+
+                state = 2;
+            }
+        }
+
+        if (state == 1)
+        {
+            if (ParserToken(TokenType::Comma).ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+            }
+        }
+
+        if (state == 1 || state == 2)
+        {
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                finished = true;
+            }
+        }
+
+        return true;
+    }
+};
+
+
+class ExistsLayer : public Layer
+{
+public:
+    bool parse(IParser::Pos & pos, Expected & expected, Action & /*action*/) override
+    {
+        ASTPtr node;
+
+        // Recursion
+        if (!ParserSelectWithUnionQuery().parse(pos, node, expected))
+            return false;
+
+        if (!ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            return false;
+
+        auto subquery = std::make_shared<ASTSubquery>();
+        subquery->children.push_back(node);
+        elements = {makeASTFunction("exists", subquery)};
+
+        finished = true;
+
+        return true;
+    }
+};
+
+class TrimLayer : public Layer
+{
+public:
+    TrimLayer(bool trim_left_, bool trim_right_) : trim_left(trim_left_), trim_right(trim_right_)
+    {
+    }
+
+    bool getResult(ASTPtr & node) override
+    {
+        node = makeASTFunction(function_name, std::move(elements));
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// Handles all possible TRIM/LTRIM/RTRIM call variants
+        ///
+        /// 0: If flags 'trim_left' and 'trim_right' are set (-> 2).
+        ///    If not, try to parse 'BOTH', 'LEADING', 'TRAILING' keywords,
+        ///    then if char_override (-> 1), else (-> 2)
+        /// 1. Parse 'FROM' keyword (-> 2)
+        /// 2. Parse closing token, choose name, add arguments (finished)
+
+        if (state == 0)
+        {
+            if (!trim_left && !trim_right)
+            {
+                if (ParserKeyword("BOTH").ignore(pos, expected))
+                {
+                    trim_left = true;
+                    trim_right = true;
+                    char_override = true;
+                }
+                else if (ParserKeyword("LEADING").ignore(pos, expected))
+                {
+                    trim_left = true;
+                    char_override = true;
+                }
+                else if (ParserKeyword("TRAILING").ignore(pos, expected))
+                {
+                    trim_right = true;
+                    char_override = true;
+                }
+                else
+                {
+                    trim_left = true;
+                    trim_right = true;
+                }
+
+                if (char_override)
+                    state = 1;
+                else
+                    state = 2;
+            }
+            else
+            {
+                state = 2;
+            }
+        }
+
+        if (state == 1)
+        {
+            if (ParserKeyword("FROM").ignore(pos, expected))
+            {
+                action = Action::OPERAND;
+
+                if (!mergeElement())
+                    return false;
+
+                to_remove = makeASTFunction("regexpQuoteMeta", elements[0]);
+                elements.clear();
+                state = 2;
+            }
+        }
+
+        if (state == 2)
+        {
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                ASTPtr pattern_node;
+
+                if (char_override)
+                {
+                    auto pattern_func_node = std::make_shared<ASTFunction>();
+                    auto pattern_list_args = std::make_shared<ASTExpressionList>();
+                    if (trim_left && trim_right)
+                    {
+                        pattern_list_args->children = {
+                            std::make_shared<ASTLiteral>("^["),
+                            to_remove,
+                            std::make_shared<ASTLiteral>("]+|["),
+                            to_remove,
+                            std::make_shared<ASTLiteral>("]+$")
+                        };
+                        function_name = "replaceRegexpAll";
+                    }
+                    else
+                    {
+                        if (trim_left)
+                        {
+                            pattern_list_args->children = {
+                                std::make_shared<ASTLiteral>("^["),
+                                to_remove,
+                                std::make_shared<ASTLiteral>("]+")
+                            };
+                        }
+                        else
+                        {
+                            /// trim_right == false not possible
+                            pattern_list_args->children = {
+                                std::make_shared<ASTLiteral>("["),
+                                to_remove,
+                                std::make_shared<ASTLiteral>("]+$")
+                            };
+                        }
+                        function_name = "replaceRegexpOne";
+                    }
+
+                    pattern_func_node->name = "concat";
+                    pattern_func_node->arguments = std::move(pattern_list_args);
+                    pattern_func_node->children.push_back(pattern_func_node->arguments);
+
+                    pattern_node = std::move(pattern_func_node);
+                }
+                else
+                {
+                    if (trim_left && trim_right)
+                    {
+                        function_name = "trimBoth";
+                    }
+                    else
+                    {
+                        if (trim_left)
+                            function_name = "trimLeft";
+                        else
+                            function_name = "trimRight";
+                    }
+                }
+
+                if (char_override)
+                {
+                    elements.push_back(pattern_node);
+                    elements.push_back(std::make_shared<ASTLiteral>(""));
+                }
+
+                finished = true;
+            }
+        }
+
+        return true;
+    }
+private:
+    bool trim_left;
+    bool trim_right;
+    bool char_override = false;
+
+    ASTPtr to_remove;
+    String function_name;
+};
+
+
+class DateAddLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingRoundBracket>
+{
+public:
+    explicit DateAddLayer(const char * function_name_) : function_name(function_name_)
+    {
+    }
+
+    bool getResult(ASTPtr & node) override
+    {
+        if (parsed_interval_kind)
+        {
+            elements[0] = makeASTFunction(interval_kind.toNameOfFunctionToIntervalDataType(), elements[0]);
+            node = makeASTFunction(function_name, elements[1], elements[0]);
+        }
+        else
+            node = makeASTFunction(function_name, std::move(elements));
+
+        return true;
+    }
+
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// DATEADD(YEAR, 1, date) or DATEADD(INTERVAL 1 YEAR, date);
+        ///
+        /// 0. Try to parse interval_kind (-> 1)
+        /// 1. Basic parser
+
+        if (state == 0)
+        {
+            if (parseIntervalKind(pos, expected, interval_kind))
+            {
+                if (!ParserToken(TokenType::Comma).ignore(pos, expected))
+                    return false;
+
+                action = Action::OPERAND;
+                parsed_interval_kind = true;
+            }
+
+            state = 1;
+        }
+
+        if (state == 1)
+        {
+            return BaseLayer::parse(pos, expected, action);
+        }
+
+        return true;
+    }
+
+private:
+    IntervalKind interval_kind;
+    const char * function_name;
+    bool parsed_interval_kind = false;
+};
+
+
+class DateDiffLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingRoundBracket>
+{
+public:
+    bool getResult(ASTPtr & node) override
+    {
+        if (parsed_interval_kind)
+        {
+            if (elements.size() == 2)
+                node = makeASTFunction("dateDiff", std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit()), elements[0], elements[1]);
+            else if (elements.size() == 3)
+                node = makeASTFunction("dateDiff", std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit()), elements[0], elements[1], elements[2]);
+            else
+                return false;
+        }
+        else
+        {
+            node = makeASTFunction("dateDiff", std::move(elements));
+        }
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// 0. Try to parse interval_kind (-> 1)
+        /// 1. Basic parser
+
+        if (state == 0)
+        {
+            if (parseIntervalKind(pos, expected, interval_kind))
+            {
+                parsed_interval_kind = true;
+
+                if (!ParserToken(TokenType::Comma).ignore(pos, expected))
+                    return false;
+            }
+
+            state = 1;
+        }
+
+        if (state == 1)
+        {
+            return BaseLayer::parse(pos, expected, action);
+        }
+
+        return true;
+    }
+
+private:
+    IntervalKind interval_kind;
+    bool parsed_interval_kind = false;
+};
+
+
+class IntervalLayer : public Layer
+{
+public:
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// INTERVAL 1 HOUR or INTERVAL expr HOUR
+        ///
+        /// 0. Try to parse interval_kind (-> 1)
+        /// 1. Basic parser
+
+        if (state == 0)
+        {
+            auto begin = pos;
+            auto init_expected = expected;
+            ASTPtr string_literal;
+            //// A String literal followed INTERVAL keyword,
+            /// the literal can be a part of an expression or
+            /// include Number and INTERVAL TYPE at the same time
+            if (ParserStringLiteral{}.parse(pos, string_literal, expected))
+            {
+                String literal;
+                if (string_literal->as<ASTLiteral &>().value.tryGet(literal))
+                {
+                    Tokens tokens(literal.data(), literal.data() + literal.size());
+                    IParser::Pos token_pos(tokens, 0);
+                    Expected token_expected;
+                    ASTPtr expr;
+
+                    if (!ParserNumber{}.parse(token_pos, expr, token_expected))
+                    {
+                        return false;
+                    }
+                    else
+                    {
+                        /// case: INTERVAL '1' HOUR
+                        /// back to begin
+                        if (!token_pos.isValid())
+                        {
+                            pos = begin;
+                            expected = init_expected;
+                        }
+                        else
+                        {
+                            /// case: INTERVAL '1 HOUR'
+                            if (!parseIntervalKind(token_pos, token_expected, interval_kind))
+                                return false;
+
+                            elements = {makeASTFunction(interval_kind.toNameOfFunctionToIntervalDataType(), expr)};
+                            finished = true;
+                            return true;
+                        }
+                    }
+                }
+            }
+            state = 1;
+            return true;
+        }
+
+        if (state == 1)
+        {
+            if (action == Action::OPERATOR && parseIntervalKind(pos, expected, interval_kind))
+            {
+                if (!mergeElement())
+                    return false;
+
+                elements = {makeASTFunction(interval_kind.toNameOfFunctionToIntervalDataType(), elements)};
+                finished = true;
+            }
+        }
+
+        return true;
+    }
+
+private:
+    IntervalKind interval_kind;
+};
+
+/// Layer for table function 'view' and 'viewIfPermitted'
+class ViewLayer : public Layer
+{
+public:
+    explicit ViewLayer(bool if_permitted_) : if_permitted(if_permitted_) {}
+
+    bool getResult(ASTPtr & node) override
+    {
+        if (if_permitted)
+            node = makeASTFunction("viewIfPermitted", std::move(elements));
+        else
+            node = makeASTFunction("view", std::move(elements));
+
+        return true;
+    }
+
+    bool parse(IParser::Pos & pos, Expected & expected, Action & /*action*/) override
+    {
+        /// view(SELECT ...)
+        /// viewIfPermitted(SELECT ... ELSE func(...))
+        ///
+        /// 0. Parse the SELECT query and if 'if_permitted' parse 'ELSE' keyword (-> 1) else (finished)
+        /// 1. Parse closing token
+
+        if (state == 0)
+        {
+            ASTPtr query;
+
+            bool maybe_an_subquery = pos->type == TokenType::OpeningRoundBracket;
+
+            if (!ParserSelectWithUnionQuery().parse(pos, query, expected))
+                return false;
+
+            auto & select_ast = query->as<ASTSelectWithUnionQuery &>();
+            if (select_ast.list_of_selects->children.size() == 1 && maybe_an_subquery)
+            {
+                // It's an subquery. Bail out.
+                return false;
+            }
+
+            pushResult(query);
+
+            if (!if_permitted)
+            {
+                if (!ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+                    return false;
+
+                finished = true;
+                return true;
+            }
+
+            if (!ParserKeyword{"ELSE"}.ignore(pos, expected))
+                return false;
+
+            state = 1;
+            return true;
+        }
+
+        if (state == 1)
+        {
+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                finished = true;
+            }
+        }
+
+        return true;
+    }
+
+private:
+    bool if_permitted;
+};
+
+
+class CaseLayer : public Layer
+{
+public:
+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
+    {
+        /// CASE [x] WHEN expr THEN expr [WHEN expr THEN expr [...]] [ELSE expr] END
+        ///
+        /// 0. Check if we have case expression [x] (-> 1)
+        /// 1. Parse keywords: WHEN (-> 2), ELSE (-> 3), END (finished)
+        /// 2. Parse THEN keyword (-> 1)
+        /// 3. Parse END keyword (finished)
+
+        if (state == 0)
+        {
+            auto old_pos = pos;
+            has_case_expr = !ParserKeyword("WHEN").ignore(pos, expected);
+            pos = old_pos;
+
+            state = 1;
+        }
+
+        if (state == 1)
+        {
+            if (ParserKeyword("WHEN").ignore(pos, expected))
+            {
+                if ((has_case_expr || !elements.empty()) && !mergeElement())
+                    return false;
+
+                action = Action::OPERAND;
+                state = 2;
+            }
+            else if (ParserKeyword("ELSE").ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                action = Action::OPERAND;
+                state = 3;
+            }
+            else if (ParserKeyword("END").ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                Field field_with_null;
+                ASTLiteral null_literal(field_with_null);
+                elements.push_back(std::make_shared<ASTLiteral>(null_literal));
+
+                if (has_case_expr)
+                    elements = {makeASTFunction("caseWithExpression", elements)};
+                else
+                    elements = {makeASTFunction("multiIf", elements)};
+                finished = true;
+            }
+        }
+
+        if (state == 2)
+        {
+            if (ParserKeyword("THEN").ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                action = Action::OPERAND;
+                state = 1;
+            }
+        }
+
+        if (state == 3)
+        {
+            if (ParserKeyword("END").ignore(pos, expected))
+            {
+                if (!mergeElement())
+                    return false;
+
+                if (has_case_expr)
+                    elements = {makeASTFunction("caseWithExpression", elements)};
+                else
+                    elements = {makeASTFunction("multiIf", elements)};
+
+                finished = true;
+            }
+        }
+
+        return true;
+    }
+
+private:
+    bool has_case_expr;
+};
+
+
+std::unique_ptr<Layer> getFunctionLayer(ASTPtr identifier, bool is_table_function, bool allow_function_parameters_ = true)
+{
+    /// Special cases for expressions that look like functions but contain some syntax sugar:
+
+    /// CAST, EXTRACT, POSITION, EXISTS
+    /// DATE_ADD, DATEADD, TIMESTAMPADD, DATE_SUB, DATESUB, TIMESTAMPSUB,
+    /// DATE_DIFF, DATEDIFF, TIMESTAMPDIFF, TIMESTAMP_DIFF,
+    /// SUBSTRING, TRIM, LTRIM, RTRIM, POSITION
+
+    /// Can be parsed as a composition of functions, but the contents must be unwrapped:
+    /// POSITION(x IN y) -> POSITION(in(x, y)) -> POSITION(y, x)
+
+    /// Can be parsed as a function, but not always:
+    /// CAST(x AS type) - alias has to be unwrapped
+    /// CAST(x AS type(params))
+
+    /// Can be parsed as a function, but some identifier arguments have special meanings.
+    /// DATE_ADD(MINUTE, x, y) -> addMinutes(x, y)
+    /// DATE_DIFF(MINUTE, x, y)
+
+    /// Have keywords that have to processed explicitly:
+    /// EXTRACT(x FROM y)
+    /// TRIM(BOTH|LEADING|TRAILING x FROM y)
+    /// SUBSTRING(x FROM a)
+    /// SUBSTRING(x FROM a FOR b)
+
+    String function_name = getIdentifierName(identifier);
+    String function_name_lowercase = Poco::toLower(function_name);
+
+    if (is_table_function)
+    {
+        if (function_name_lowercase == "view")
+            return std::make_unique<ViewLayer>(false);
+        else if (function_name_lowercase == "viewifpermitted")
+            return std::make_unique<ViewLayer>(true);
+    }
+
+    if (function_name_lowercase == "cast")
+        return std::make_unique<CastLayer>();
+    else if (function_name_lowercase == "extract")
+        return std::make_unique<ExtractLayer>();
+    else if (function_name_lowercase == "substring")
+        return std::make_unique<SubstringLayer>();
+    else if (function_name_lowercase == "position")
+        return std::make_unique<PositionLayer>();
+    else if (function_name_lowercase == "exists")
+        return std::make_unique<ExistsLayer>();
+    else if (function_name_lowercase == "trim")
+        return std::make_unique<TrimLayer>(false, false);
+    else if (function_name_lowercase == "ltrim")
+        return std::make_unique<TrimLayer>(true, false);
+    else if (function_name_lowercase == "rtrim")
+        return std::make_unique<TrimLayer>(false, true);
+    else if (function_name_lowercase == "dateadd" || function_name_lowercase == "date_add"
+        || function_name_lowercase == "timestampadd" || function_name_lowercase == "timestamp_add")
+        return std::make_unique<DateAddLayer>("plus");
+    else if (function_name_lowercase == "datesub" || function_name_lowercase == "date_sub"
+        || function_name_lowercase == "timestampsub" || function_name_lowercase == "timestamp_sub")
+        return std::make_unique<DateAddLayer>("minus");
+    else if (function_name_lowercase == "datediff" || function_name_lowercase == "date_diff"
+        || function_name_lowercase == "timestampdiff" || function_name_lowercase == "timestamp_diff")
+        return std::make_unique<DateDiffLayer>();
+    else if (function_name_lowercase == "grouping")
+        return std::make_unique<OrdinaryFunctionLayer>(function_name_lowercase, allow_function_parameters_);
+    else
+        return std::make_unique<OrdinaryFunctionLayer>(function_name, allow_function_parameters_);
+}
+
+
+bool ParseCastExpression(IParser::Pos & pos, ASTPtr & node, Expected & expected)
+{
+    IParser::Pos begin = pos;
+
+    if (ParserCastOperator().parse(pos, node, expected))
+        return true;
+
+    pos = begin;
+
+    /// As an exception, negative numbers should be parsed as literals, and not as an application of the operator.
+    if (pos->type == TokenType::Minus)
+    {
+        if (ParserLiteral().parse(pos, node, expected))
+            return true;
+    }
+    return false;
+}
+
+bool ParseDateOperatorExpression(IParser::Pos & pos, ASTPtr & node, Expected & expected)
 {
     auto begin = pos;
 
     /// If no DATE keyword, go to the nested parser.
     if (!ParserKeyword("DATE").ignore(pos, expected))
-        return next_parser.parse(pos, node, expected);
+        return false;
 
     ASTPtr expr;
     if (!ParserStringLiteral().parse(pos, expr, expected))
     {
         pos = begin;
-        return next_parser.parse(pos, node, expected);
+        return false;
     }
 
-    /// the function corresponding to the operator
-    auto function = std::make_shared<ASTFunction>();
-
-    /// function arguments
-    auto exp_list = std::make_shared<ASTExpressionList>();
-
-    /// the first argument of the function is the previous element, the second is the next one
-    function->name = "toDate";
-    function->arguments = exp_list;
-    function->children.push_back(exp_list);
-
-    exp_list->children.push_back(expr);
-
-    node = function;
+    node = makeASTFunction("toDate", expr);
     return true;
 }
 
-bool ParserTimestampOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+bool ParseTimestampOperatorExpression(IParser::Pos & pos, ASTPtr & node, Expected & expected)
 {
     auto begin = pos;
 
     /// If no TIMESTAMP keyword, go to the nested parser.
     if (!ParserKeyword("TIMESTAMP").ignore(pos, expected))
-        return next_parser.parse(pos, node, expected);
+        return false;
 
     ASTPtr expr;
     if (!ParserStringLiteral().parse(pos, expr, expected))
     {
         pos = begin;
-        return next_parser.parse(pos, node, expected);
+        return false;
     }
 
-    /// the function corresponding to the operator
-    auto function = std::make_shared<ASTFunction>();
+    node = makeASTFunction("toDateTime", expr);
 
-    /// function arguments
-    auto exp_list = std::make_shared<ASTExpressionList>();
+    return true;
+}
 
-    /// the first argument of the function is the previous element, the second is the next one
-    function->name = "toDateTime";
-    function->arguments = exp_list;
-    function->children.push_back(exp_list);
+struct ParserExpressionImpl
+{
+    static std::vector<std::pair<const char *, Operator>> operators_table;
+    static std::vector<std::pair<const char *, Operator>> unary_operators_table;
+    static const char * overlapping_operators_to_skip[];
 
-    exp_list->children.push_back(expr);
+    static Operator finish_between_operator;
 
-    node = function;
-    return true;
+    ParserCompoundIdentifier identifier_parser{false, true};
+    ParserNumber number_parser;
+    ParserAsterisk asterisk_parser;
+    ParserLiteral literal_parser;
+    ParserTupleOfLiterals tuple_literal_parser;
+    ParserArrayOfLiterals array_literal_parser;
+    ParserSubstitution substitution_parser;
+    ParserMySQLGlobalVariable mysql_global_variable_parser;
+
+    ParserKeyword any_parser{"ANY"};
+    ParserKeyword all_parser{"ALL"};
+
+    // Recursion
+    ParserQualifiedAsterisk qualified_asterisk_parser;
+    ParserColumnsMatcher columns_matcher_parser;
+    ParserSubquery subquery_parser;
+
+    bool parse(std::unique_ptr<Layer> start, IParser::Pos & pos, ASTPtr & node, Expected & expected);
+
+    using Layers = std::vector<std::unique_ptr<Layer>>;
+
+    Action tryParseOperand(Layers & layers, IParser::Pos & pos, Expected & expected);
+    static Action tryParseOperator(Layers & layers, IParser::Pos & pos, Expected & expected);
+};
+
+
+bool ParserExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    auto start = std::make_unique<ExpressionLayer>(false);
+    return ParserExpressionImpl().parse(std::move(start), pos, node, expected);
 }
 
-bool ParserIntervalOperatorExpression::parseArgumentAndIntervalKind(
-    Pos & pos, ASTPtr & expr, IntervalKind & interval_kind, Expected & expected)
+bool ParserTableFunctionExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
-    auto begin = pos;
-    auto init_expected = expected;
-    ASTPtr string_literal;
-    //// A String literal followed INTERVAL keyword,
-    /// the literal can be a part of an expression or
-    /// include Number and INTERVAL TYPE at the same time
-    if (ParserStringLiteral{}.parse(pos, string_literal, expected))
+    auto start = std::make_unique<ExpressionLayer>(true);
+    return ParserExpressionImpl().parse(std::move(start), pos, node, expected);
+}
+
+bool ParserArray::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    auto start = std::make_unique<ArrayLayer>();
+    return ParserToken(TokenType::OpeningSquareBracket).ignore(pos, expected)
+        && ParserExpressionImpl().parse(std::move(start), pos, node, expected);
+}
+
+bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    ASTPtr identifier;
+
+    if (ParserIdentifier(true).parse(pos, identifier, expected)
+        && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))
+    {
+        auto start = getFunctionLayer(identifier, is_table_function, allow_function_parameters);
+        start->is_table_function = is_table_function;
+        return ParserExpressionImpl().parse(std::move(start), pos, node, expected);
+    }
+    else
+    {
+        return false;
+    }
+}
+
+std::vector<std::pair<const char *, Operator>> ParserExpressionImpl::operators_table({
+        {"->",            Operator("lambda",          1,  2, OperatorType::Lambda)},
+        {"?",             Operator("",                2,  0, OperatorType::StartIf)},
+        {":",             Operator("if",              3,  3, OperatorType::FinishIf)},
+        {"OR",            Operator("or",              3,  2, OperatorType::Mergeable)},
+        {"AND",           Operator("and",             4,  2, OperatorType::Mergeable)},
+        {"BETWEEN",       Operator("",                6,  0, OperatorType::StartBetween)},
+        {"NOT BETWEEN",   Operator("",                6,  0, OperatorType::StartNotBetween)},
+        {"IS NULL",       Operator("isNull",          8,  1, OperatorType::IsNull)},
+        {"IS NOT NULL",   Operator("isNotNull",       8,  1, OperatorType::IsNull)},
+        {"==",            Operator("equals",          9,  2, OperatorType::Comparison)},
+        {"!=",            Operator("notEquals",       9,  2, OperatorType::Comparison)},
+        {"<>",            Operator("notEquals",       9,  2, OperatorType::Comparison)},
+        {"<=",            Operator("lessOrEquals",    9,  2, OperatorType::Comparison)},
+        {">=",            Operator("greaterOrEquals", 9,  2, OperatorType::Comparison)},
+        {"<",             Operator("less",            9,  2, OperatorType::Comparison)},
+        {">",             Operator("greater",         9,  2, OperatorType::Comparison)},
+        {"=",             Operator("equals",          9,  2, OperatorType::Comparison)},
+        {"LIKE",          Operator("like",            9)},
+        {"ILIKE",         Operator("ilike",           9)},
+        {"NOT LIKE",      Operator("notLike",         9)},
+        {"NOT ILIKE",     Operator("notILike",        9)},
+        {"IN",            Operator("in",              9)},
+        {"NOT IN",        Operator("notIn",           9)},
+        {"GLOBAL IN",     Operator("globalIn",        9)},
+        {"GLOBAL NOT IN", Operator("globalNotIn",     9)},
+        {"||",            Operator("concat",          10, 2, OperatorType::Mergeable)},
+        {"+",             Operator("plus",            11)},
+        {"-",             Operator("minus",           11)},
+        {"*",             Operator("multiply",        12)},
+        {"/",             Operator("divide",          12)},
+        {"%",             Operator("modulo",          12)},
+        {"MOD",           Operator("modulo",          12)},
+        {"DIV",           Operator("intDiv",          12)},
+        {".",             Operator("tupleElement",    14, 2, OperatorType::TupleElement)},
+        {"[",             Operator("arrayElement",    14, 2, OperatorType::ArrayElement)},
+        {"::",            Operator("CAST",            14, 2, OperatorType::Cast)},
+    });
+
+std::vector<std::pair<const char *, Operator>> ParserExpressionImpl::unary_operators_table({
+        {"NOT",           Operator("not",             5,  1)},
+        {"-",             Operator("negate",          13, 1)}
+    });
+
+Operator ParserExpressionImpl::finish_between_operator = Operator("", 7, 0, OperatorType::FinishBetween);
+
+const char * ParserExpressionImpl::overlapping_operators_to_skip[] =
+{
+    "IN PARTITION",
+    nullptr
+};
+
+bool ParserExpressionImpl::parse(std::unique_ptr<Layer> start, IParser::Pos & pos, ASTPtr & node, Expected & expected)
+{
+    Action next = Action::OPERAND;
+
+    Layers layers;
+    layers.push_back(std::move(start));
+
+    while (true)
     {
-        String literal;
-        if (string_literal->as<ASTLiteral &>().value.tryGet(literal))
+        while (pos.isValid())
         {
-            Tokens tokens(literal.data(), literal.data() + literal.size());
-            Pos token_pos(tokens, 0);
-            Expected token_expected;
+            if (!layers.back()->parse(pos, expected, next))
+                break;
 
-            if (!ParserNumber{}.parse(token_pos, expr, token_expected))
-                return false;
+            if (layers.back()->isFinished())
+            {
+                if (layers.size() == 1)
+                    break;
+
+                next = Action::OPERATOR;
+
+                ASTPtr res;
+                if (!layers.back()->getResult(res))
+                    break;
+
+                layers.pop_back();
+                layers.back()->pushOperand(res);
+                continue;
+            }
+
+            if (next == Action::OPERAND)
+                next = tryParseOperand(layers, pos, expected);
             else
+                next = tryParseOperator(layers, pos, expected);
+
+            if (next == Action::NONE)
+                break;
+        }
+
+        /// When we exit the loop we should be on the 1st level
+        if (layers.size() == 1 && layers.back()->getResult(node))
+            return true;
+
+        layers.pop_back();
+
+        /// We try to check whether there was a checkpoint
+        while (!layers.empty() && !layers.back()->saved_checkpoint)
+            layers.pop_back();
+
+        if (layers.empty())
+            return false;
+
+        /// Currently all checkpoints are located in operand section
+        next = Action::OPERAND;
+
+        auto saved_checkpoint = layers.back()->saved_checkpoint.value();
+        layers.back()->saved_checkpoint.reset();
+
+        pos = saved_checkpoint.first;
+        layers.back()->current_checkpoint = saved_checkpoint.second;
+    }
+}
+
+Action ParserExpressionImpl::tryParseOperand(Layers & layers, IParser::Pos & pos, Expected & expected)
+{
+    ASTPtr tmp;
+
+    if (layers.front()->is_table_function)
+    {
+        if (typeid_cast<ViewLayer *>(layers.back().get()))
+        {
+            if (identifier_parser.parse(pos, tmp, expected)
+                && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))
+            {
+                layers.push_back(getFunctionLayer(tmp, layers.front()->is_table_function));
+                return Action::OPERAND;
+            }
+            return Action::NONE;
+        }
+
+        /// Current element should be empty (there should be no other operands or operators)
+        /// to parse SETTINGS in table function
+        if (layers.back()->isCurrentElementEmpty())
+        {
+            auto old_pos = pos;
+            ParserKeyword s_settings("SETTINGS");
+            if (s_settings.ignore(pos, expected))
             {
-                /// case: INTERVAL '1' HOUR
-                /// back to begin
-                if (!token_pos.isValid())
+                ParserSetQuery parser_settings(true);
+                if (parser_settings.parse(pos, tmp, expected))
                 {
-                    pos = begin;
-                    expected = init_expected;
+                    layers.back()->pushOperand(tmp);
+                    return Action::OPERAND;
                 }
                 else
-                    /// case: INTERVAL '1 HOUR'
-                    return parseIntervalKind(token_pos, token_expected, interval_kind);
+                {
+                    pos = old_pos;
+                }
             }
         }
     }
-    // case: INTERVAL expr HOUR
-    if (!ParserExpressionWithOptionalAlias(false).parse(pos, expr, expected))
-        return false;
-    return parseIntervalKind(pos, expected, interval_kind);
-}
 
-bool ParserIntervalOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    auto begin = pos;
+    /// Special case for cast expression
+    if (layers.back()->previousType() != OperatorType::TupleElement &&
+        ParseCastExpression(pos, tmp, expected))
+    {
+        layers.back()->pushOperand(std::move(tmp));
+        return Action::OPERATOR;
+    }
+
+    if (layers.back()->previousType() == OperatorType::Comparison)
+    {
+        SubqueryFunctionType subquery_function_type = SubqueryFunctionType::NONE;
 
-    /// If no INTERVAL keyword, go to the nested parser.
-    if (!ParserKeyword("INTERVAL").ignore(pos, expected))
-        return next_parser.parse(pos, node, expected);
+        if (any_parser.ignore(pos, expected) && subquery_parser.parse(pos, tmp, expected))
+            subquery_function_type = SubqueryFunctionType::ANY;
+        else if (all_parser.ignore(pos, expected) && subquery_parser.parse(pos, tmp, expected))
+            subquery_function_type = SubqueryFunctionType::ALL;
 
-    ASTPtr expr;
-    IntervalKind interval_kind;
-    if (!parseArgumentAndIntervalKind(pos, expr, interval_kind, expected))
+        if (subquery_function_type != SubqueryFunctionType::NONE)
+        {
+            Operator prev_op;
+            ASTPtr function, argument;
+
+            if (!layers.back()->popOperator(prev_op))
+                return Action::NONE;
+            if (!layers.back()->popOperand(argument))
+                return Action::NONE;
+
+            function = makeASTFunction(prev_op.function_name, argument, tmp);
+
+            if (!modifyAST(function, subquery_function_type))
+                return Action::NONE;
+
+            layers.back()->pushOperand(std::move(function));
+            return Action::OPERATOR;
+        }
+    }
+
+    /// Try to find any unary operators
+    auto cur_op = unary_operators_table.begin();
+    for (; cur_op != unary_operators_table.end(); ++cur_op)
     {
-        pos = begin;
-        return next_parser.parse(pos, node, expected);
+        if (parseOperator(pos, cur_op->first, expected))
+            break;
+    }
+
+    if (cur_op != unary_operators_table.end())
+    {
+        layers.back()->pushOperator(cur_op->second);
+        return Action::OPERAND;
     }
 
-    /// the function corresponding to the operator
-    auto function = std::make_shared<ASTFunction>();
+    auto old_pos = pos;
+    auto current_checkpoint = layers.back()->current_checkpoint;
+    layers.back()->current_checkpoint = Checkpoint::None;
 
-    /// function arguments
-    auto exp_list = std::make_shared<ASTExpressionList>();
+    if (current_checkpoint != Checkpoint::Interval && parseOperator(pos, "INTERVAL", expected))
+    {
+        layers.back()->saved_checkpoint = {old_pos, Checkpoint::Interval};
+        layers.push_back(std::make_unique<IntervalLayer>());
+        return Action::OPERAND;
+    }
+    else if (current_checkpoint != Checkpoint::Case && parseOperator(pos, "CASE", expected))
+    {
+        layers.back()->saved_checkpoint = {old_pos, Checkpoint::Case};
+        layers.push_back(std::make_unique<CaseLayer>());
+        return Action::OPERAND;
+    }
 
-    /// the first argument of the function is the previous element, the second is the next one
-    function->name = interval_kind.toNameOfFunctionToIntervalDataType();
-    function->arguments = exp_list;
-    function->children.push_back(exp_list);
+    if (ParseDateOperatorExpression(pos, tmp, expected) ||
+        ParseTimestampOperatorExpression(pos, tmp, expected) ||
+        tuple_literal_parser.parse(pos, tmp, expected) ||
+        array_literal_parser.parse(pos, tmp, expected) ||
+        number_parser.parse(pos, tmp, expected) ||
+        literal_parser.parse(pos, tmp, expected) ||
+        asterisk_parser.parse(pos, tmp, expected) ||
+        qualified_asterisk_parser.parse(pos, tmp, expected) ||
+        columns_matcher_parser.parse(pos, tmp, expected))
+    {
+        layers.back()->pushOperand(std::move(tmp));
+    }
+    else if (identifier_parser.parse(pos, tmp, expected))
+    {
+        if (pos->type == TokenType::OpeningRoundBracket)
+        {
+            ++pos;
+            layers.push_back(getFunctionLayer(tmp, layers.front()->is_table_function));
+            return Action::OPERAND;
+        }
+        else
+        {
+            layers.back()->pushOperand(std::move(tmp));
+        }
+    }
+    else if (substitution_parser.parse(pos, tmp, expected))
+    {
+        layers.back()->pushOperand(std::move(tmp));
+    }
+    else if (pos->type == TokenType::OpeningRoundBracket)
+    {
+        if (subquery_parser.parse(pos, tmp, expected))
+        {
+            layers.back()->pushOperand(std::move(tmp));
+            return Action::OPERATOR;
+        }
 
-    exp_list->children.push_back(expr);
+        ++pos;
+        layers.push_back(std::make_unique<RoundBracketsLayer>());
+        return Action::OPERAND;
+    }
+    else if (pos->type == TokenType::OpeningSquareBracket)
+    {
+        ++pos;
+        layers.push_back(std::make_unique<ArrayLayer>());
+        return Action::OPERAND;
+    }
+    else if (mysql_global_variable_parser.parse(pos, tmp, expected))
+    {
+        layers.back()->pushOperand(std::move(tmp));
+    }
+    else
+    {
+        return Action::NONE;
+    }
 
-    node = function;
-    return true;
+    return Action::OPERATOR;
 }
 
-bool ParserKeyValuePair::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+Action ParserExpressionImpl::tryParseOperator(Layers & layers, IParser::Pos & pos, Expected & expected)
 {
-    ParserIdentifier id_parser;
-    ParserLiteral literal_parser;
-    ParserFunction func_parser;
+    ASTPtr tmp;
+
+    /// ParserExpression can be called in this part of the query:
+    ///  ALTER TABLE partition_all2 CLEAR INDEX [ p ] IN PARTITION ALL
+    ///
+    /// 'IN PARTITION' here is not an 'IN' operator, so we should stop parsing immediately
+    Expected stub;
+    for (const char ** it = overlapping_operators_to_skip; *it; ++it)
+        if (ParserKeyword{*it}.checkWithoutMoving(pos, stub))
+            return Action::NONE;
+
+    /// Try to find operators from 'operators_table'
+    auto cur_op = operators_table.begin();
+    for (; cur_op != operators_table.end(); ++cur_op)
+    {
+        if (parseOperator(pos, cur_op->first, expected))
+            break;
+    }
 
-    ASTPtr identifier;
-    ASTPtr value;
-    bool with_brackets = false;
-    if (!id_parser.parse(pos, identifier, expected))
-        return false;
+    if (cur_op == operators_table.end())
+    {
+        auto old_pos = pos;
+        if (layers.back()->allow_alias && ParserAlias(layers.back()->allow_alias_without_as_keyword).parse(pos, tmp, expected))
+        {
+            if (layers.back()->insertAlias(tmp))
+                return Action::OPERATOR;
+        }
+        pos = old_pos;
+        return Action::NONE;
+    }
 
-    /// If it's neither literal, nor identifier, nor function, than it's possible list of pairs
-    if (!func_parser.parse(pos, value, expected) && !literal_parser.parse(pos, value, expected) && !id_parser.parse(pos, value, expected))
+    auto op = cur_op->second;
+
+    if (op.type == OperatorType::Lambda)
     {
-        ParserKeyValuePairsList kv_pairs_list;
-        ParserToken open(TokenType::OpeningRoundBracket);
-        ParserToken close(TokenType::ClosingRoundBracket);
+        if (!layers.back()->parseLambda())
+            return Action::NONE;
 
-        if (!open.ignore(pos))
-            return false;
+        layers.back()->pushOperator(op);
+        return Action::OPERAND;
+    }
 
-        if (!kv_pairs_list.parse(pos, value, expected))
-            return false;
+    /// 'AND' can be both boolean function and part of the '... BETWEEN ... AND ...' operator
+    if (op.function_name == "and" && layers.back()->between_counter)
+    {
+        layers.back()->between_counter--;
+        op = finish_between_operator;
+    }
 
-        if (!close.ignore(pos))
-            return false;
+    while (layers.back()->previousPriority() >= op.priority)
+    {
+        ASTPtr function;
+        Operator prev_op;
+        layers.back()->popOperator(prev_op);
 
-        with_brackets = true;
+        /// Mergeable operators are operators that are merged into one function:
+        /// For example: 'a OR b OR c' -> 'or(a, b, c)' and not 'or(or(a,b), c)'
+        if (prev_op.type == OperatorType::Mergeable && op.function_name == prev_op.function_name)
+        {
+            op.arity += prev_op.arity - 1;
+            break;
+        }
+
+        if (prev_op.type == OperatorType::FinishBetween)
+        {
+            Operator tmp_op;
+            if (!layers.back()->popOperator(tmp_op))
+                return Action::NONE;
+
+            if (tmp_op.type != OperatorType::StartBetween && tmp_op.type != OperatorType::StartNotBetween)
+                return Action::NONE;
+
+            bool negative = tmp_op.type == OperatorType::StartNotBetween;
+
+            ASTs arguments;
+            if (!layers.back()->popLastNOperands(arguments, 3))
+                return Action::NONE;
+
+            function = makeBetweenOperator(negative, arguments);
+        }
+        else
+        {
+            function = makeASTFunction(prev_op.function_name);
+
+            if (!layers.back()->popLastNOperands(function->children[0]->children, prev_op.arity))
+                return Action::NONE;
+        }
+
+        layers.back()->pushOperand(function);
     }
 
-    auto pair = std::make_shared<ASTPair>(with_brackets);
-    pair->first = Poco::toLower(identifier->as<ASTIdentifier>()->name());
-    pair->set(pair->second, value);
-    node = pair;
-    return true;
-}
+    layers.back()->pushOperator(op);
 
-bool ParserKeyValuePairsList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
-{
-    ParserList parser(std::make_unique<ParserKeyValuePair>(), std::make_unique<ParserNothing>(), true, 0);
-    return parser.parse(pos, node, expected);
+    if (op.type == OperatorType::ArrayElement)
+        layers.push_back(std::make_unique<ArrayElementLayer>());
+
+
+    Action next = Action::OPERAND;
+
+    /// isNull & isNotNull are postfix unary operators
+    if (op.type == OperatorType::IsNull)
+        next = Action::OPERATOR;
+
+    if (op.type == OperatorType::StartBetween || op.type == OperatorType::StartNotBetween)
+        layers.back()->between_counter++;
+
+    if (op.type == OperatorType::Cast)
+    {
+        next = Action::OPERATOR;
+
+        ASTPtr type_ast;
+        if (!ParserDataType().parse(pos, type_ast, expected))
+            return Action::NONE;
+
+        layers.back()->pushOperand(std::make_shared<ASTLiteral>(queryToString(type_ast)));
+    }
+
+    return next;
 }
 
 }
diff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h
index 05c7ec946eee..653654e5a33a 100644
--- a/src/Parsers/ExpressionListParsers.h
+++ b/src/Parsers/ExpressionListParsers.h
@@ -116,75 +116,40 @@ class ParserUnionList : public IParserBase
     SelectUnionModes union_modes;
 };
 
-/** An expression with an infix binary left-associative operator.
-  * For example, a + b - c + d.
-  */
-class ParserLeftAssociativeBinaryOperatorList : public IParserBase
-{
-private:
-    Operators_t operators;
-    Operators_t overlapping_operators_to_skip = { (const char *[]){ nullptr } };
-    ParserPtr first_elem_parser;
-    ParserPtr remaining_elem_parser;
-    /// =, !=, <, > ALL (subquery) / ANY (subquery)
-    bool comparison_expression = false;
-
-public:
-    /** `operators_` - allowed operators and their corresponding functions
-      */
-    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_, ParserPtr && first_elem_parser_)
-        : operators(operators_), first_elem_parser(std::move(first_elem_parser_))
-    {
-    }
-
-    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_,
-            Operators_t overlapping_operators_to_skip_, ParserPtr && first_elem_parser_, bool comparison_expression_ = false)
-        : operators(operators_), overlapping_operators_to_skip(overlapping_operators_to_skip_),
-          first_elem_parser(std::move(first_elem_parser_)), comparison_expression(comparison_expression_)
-    {
-    }
-
-    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_, ParserPtr && first_elem_parser_,
-        ParserPtr && remaining_elem_parser_)
-        : operators(operators_), first_elem_parser(std::move(first_elem_parser_)),
-          remaining_elem_parser(std::move(remaining_elem_parser_))
-    {
-    }
 
+class ParserArray : public IParserBase
+{
 protected:
-    const char * getName() const override { return "list, delimited by binary operators"; }
-
+    const char * getName() const override { return "array"; }
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
 };
 
-
-/** Expression with an infix operator of arbitrary arity.
-  * For example, a AND b AND c AND d.
+/** A function, for example, f(x, y + 1, g(z)).
+  * Or an aggregate function: sum(x + f(y)), corr(x, y). The syntax is the same as the usual function.
+  * Or a parametric aggregate function: quantile(0.9)(x + y).
+  *  Syntax - two pairs of parentheses instead of one. The first is for parameters, the second for arguments.
+  * For functions, the DISTINCT modifier can be specified, for example, count(DISTINCT x, y).
   */
-class ParserVariableArityOperatorList : public IParserBase
+class ParserFunction : public IParserBase
 {
-private:
-    const char * infix;
-    const char * function_name;
-    ParserPtr elem_parser;
-
 public:
-    ParserVariableArityOperatorList(const char * infix_, const char * function_, ParserPtr && elem_parser_)
-        : infix(infix_), function_name(function_), elem_parser(std::move(elem_parser_))
+    explicit ParserFunction(bool allow_function_parameters_ = true, bool is_table_function_ = false)
+        : allow_function_parameters(allow_function_parameters_), is_table_function(is_table_function_)
     {
     }
 
 protected:
-    const char * getName() const override { return "list, delimited by operator of variable arity"; }
-
+    const char * getName() const override { return "function"; }
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
+    bool allow_function_parameters;
+    bool is_table_function;
 };
 
 
-/** An expression with a prefix unary operator.
-  * Example, NOT x.
+/** An expression with an infix binary left-associative operator.
+  * For example, a + b - c + d.
   */
-class ParserPrefixUnaryOperatorExpression : public IParserBase
+class ParserLeftAssociativeBinaryOperatorList : public IParserBase
 {
 private:
     Operators_t operators;
@@ -193,260 +158,20 @@ class ParserPrefixUnaryOperatorExpression : public IParserBase
 public:
     /** `operators_` - allowed operators and their corresponding functions
       */
-    ParserPrefixUnaryOperatorExpression(Operators_t operators_, ParserPtr && elem_parser_)
+    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_, ParserPtr && elem_parser_)
         : operators(operators_), elem_parser(std::move(elem_parser_))
     {
     }
 
 protected:
-    const char * getName() const override { return "expression with prefix unary operator"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-/// CAST operator "::". This parser is used if left argument
-/// of operator cannot be read as simple literal from text of query.
-/// Example: "[1, 1 + 1, 1 + 2]::Array(UInt8)"
-class ParserCastExpression : public IParserBase
-{
-private:
-    ParserPtr elem_parser;
-
-public:
-    explicit ParserCastExpression(ParserPtr && elem_parser_)
-        : elem_parser(std::move(elem_parser_))
-    {
-    }
-
-protected:
-    const char * getName() const override { return "CAST expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-class ParserArrayElementExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-
-protected:
-    const char * getName() const  override{ return "array element expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-class ParserTupleElementExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-
-protected:
-    const char * getName() const override { return "tuple element expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-class ParserUnaryExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-    ParserPrefixUnaryOperatorExpression operator_parser {operators, std::make_unique<ParserCastExpression>(std::make_unique<ParserTupleElementExpression>())};
-
-protected:
-    const char * getName() const override { return "unary expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-class ParserMultiplicativeExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-    ParserLeftAssociativeBinaryOperatorList operator_parser {operators, std::make_unique<ParserUnaryExpression>()};
-
-protected:
-    const char * getName() const  override { return "multiplicative expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-/// DATE operator. "DATE '2001-01-01'" would be parsed as "toDate('2001-01-01')".
-class ParserDateOperatorExpression : public IParserBase
-{
-protected:
-    ParserMultiplicativeExpression next_parser;
-
-    const char * getName() const  override { return "DATE operator expression"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-/// TIMESTAMP operator. "TIMESTAMP '2001-01-01 12:34:56'" would be parsed as "toDateTime('2001-01-01 12:34:56')".
-class ParserTimestampOperatorExpression : public IParserBase
-{
-protected:
-    ParserDateOperatorExpression next_parser;
-
-    const char * getName() const  override { return "TIMESTAMP operator expression"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-/// Optional conversion to INTERVAL data type. Example: "INTERVAL x SECOND" parsed as "toIntervalSecond(x)".
-class ParserIntervalOperatorExpression : public IParserBase
-{
-protected:
-    ParserTimestampOperatorExpression next_parser;
-
-    const char * getName() const  override { return "INTERVAL operator expression"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-
-private:
-    static bool parseArgumentAndIntervalKind(Pos & pos, ASTPtr & expr, IntervalKind & interval_kind, Expected & expected);
-};
-
-class ParserAdditiveExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-    ParserLeftAssociativeBinaryOperatorList operator_parser {operators, std::make_unique<ParserIntervalOperatorExpression>()};
-
-protected:
-    const char * getName() const  override { return "additive expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-
-class ParserConcatExpression : public IParserBase
-{
-    ParserVariableArityOperatorList operator_parser {"||", "concat", std::make_unique<ParserAdditiveExpression>()};
-
-protected:
-    const char * getName() const override { return "string concatenation expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-
-class ParserBetweenExpression : public IParserBase
-{
-private:
-    ParserConcatExpression elem_parser;
-
-protected:
-    const char * getName() const override { return "BETWEEN expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-class ParserComparisonExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-    static const char * overlapping_operators_to_skip[];
-    ParserLeftAssociativeBinaryOperatorList operator_parser {operators,
-        overlapping_operators_to_skip, std::make_unique<ParserBetweenExpression>(), true};
-
-protected:
-    const char * getName() const  override{ return "comparison expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-/** Parser for nullity checking with IS (NOT) NULL.
-  */
-class ParserNullityChecking : public IParserBase
-{
-private:
-    ParserComparisonExpression elem_parser;
-
-protected:
-    const char * getName() const override { return "nullity checking"; }
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
-};
-
-
-class ParserLogicalNotExpression : public IParserBase
-{
-private:
-    static const char * operators[];
-    ParserPrefixUnaryOperatorExpression operator_parser {operators, std::make_unique<ParserNullityChecking>()};
-
-protected:
-    const char * getName() const  override{ return "logical-NOT expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-
-class ParserLogicalAndExpression : public IParserBase
-{
-private:
-    ParserVariableArityOperatorList operator_parser {"AND", "and", std::make_unique<ParserLogicalNotExpression>()};
-
-protected:
-    const char * getName() const override { return "logical-AND expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-
-class ParserLogicalOrExpression : public IParserBase
-{
-private:
-    ParserVariableArityOperatorList operator_parser {"OR", "or", std::make_unique<ParserLogicalAndExpression>()};
-
-protected:
-    const char * getName() const override { return "logical-OR expression"; }
-
-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
-    {
-        return operator_parser.parse(pos, node, expected);
-    }
-};
-
-
-/** An expression with ternary operator.
-  * For example, a = 1 ? b + 1 : c * 2.
-  */
-class ParserTernaryOperatorExpression : public IParserBase
-{
-private:
-    ParserLogicalOrExpression elem_parser;
-
-protected:
-    const char * getName() const override { return "expression with ternary operator"; }
+    const char * getName() const override { return "list, delimited by binary operators"; }
 
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
 };
 
 
-class ParserLambdaExpression : public IParserBase
+class ParserExpression : public IParserBase
 {
-private:
-    ParserTernaryOperatorExpression elem_parser;
-
 protected:
     const char * getName() const override { return "lambda expression"; }
 
@@ -457,9 +182,6 @@ class ParserLambdaExpression : public IParserBase
 // It's used to parse expressions in table function.
 class ParserTableFunctionExpression : public IParserBase
 {
-private:
-    ParserLambdaExpression elem_parser;
-
 protected:
     const char * getName() const override { return "table function expression"; }
 
@@ -467,13 +189,10 @@ class ParserTableFunctionExpression : public IParserBase
 };
 
 
-using ParserExpression = ParserLambdaExpression;
-
-
 class ParserExpressionWithOptionalAlias : public IParserBase
 {
 public:
-    explicit ParserExpressionWithOptionalAlias(bool allow_alias_without_as_keyword, bool is_table_function = false);
+    explicit ParserExpressionWithOptionalAlias(bool allow_alias_without_as_keyword_, bool is_table_function_ = false);
 protected:
     ParserPtr impl;
 
diff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp
index f1557076a07e..65740f290b5c 100644
--- a/src/Parsers/IAST.cpp
+++ b/src/Parsers/IAST.cpp
@@ -138,14 +138,28 @@ void IAST::updateTreeHashImpl(SipHash & hash_state) const
 }
 
 
-size_t IAST::checkDepthImpl(size_t max_depth, size_t level) const
+size_t IAST::checkDepthImpl(size_t max_depth) const
 {
-    size_t res = level + 1;
-    for (const auto & child : children)
+    std::vector<std::pair<ASTPtr, size_t>> stack;
+    stack.reserve(children.size());
+
+    for (const auto & i: children)
+        stack.push_back({i, 1});
+
+    size_t res = 0;
+
+    while (!stack.empty())
     {
-        if (level >= max_depth)
+        auto top = stack.back();
+        stack.pop_back();
+
+        if (top.second >= max_depth)
             throw Exception("AST is too deep. Maximum: " + toString(max_depth), ErrorCodes::TOO_DEEP_AST);
-        res = std::max(res, child->checkDepthImpl(max_depth, level + 1));
+
+        res = std::max(res, top.second);
+
+        for (const auto & i: top.first->children)
+            stack.push_back({i, top.second + 1});
     }
 
     return res;
diff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h
index e91d419acd84..bba878e4769c 100644
--- a/src/Parsers/IAST.h
+++ b/src/Parsers/IAST.h
@@ -92,7 +92,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
       */
     size_t checkDepth(size_t max_depth) const
     {
-        return checkDepthImpl(max_depth, 0);
+        return checkDepthImpl(max_depth);
     }
 
     /** Get total number of tree elements
@@ -273,7 +273,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
     static const char * hilite_none;
 
 private:
-    size_t checkDepthImpl(size_t max_depth, size_t level) const;
+    size_t checkDepthImpl(size_t max_depth) const;
 
     /** Forward linked list of ASTPtr to delete.
       * Used in IAST destructor to avoid possible stack overflow.
diff --git a/src/Parsers/ParserCreateFunctionQuery.cpp b/src/Parsers/ParserCreateFunctionQuery.cpp
index 08df6d8da7a9..2b3cf98a8a79 100644
--- a/src/Parsers/ParserCreateFunctionQuery.cpp
+++ b/src/Parsers/ParserCreateFunctionQuery.cpp
@@ -20,7 +20,7 @@ bool ParserCreateFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Exp
     ParserKeyword s_on("ON");
     ParserIdentifier function_name_p;
     ParserKeyword s_as("AS");
-    ParserLambdaExpression lambda_p;
+    ParserExpression lambda_p;
 
     ASTPtr function_name;
     ASTPtr function_core;
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index 08240abe8c64..fc90f9ce3ed2 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -152,7 +152,7 @@ bool ParserConstraintDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected &
     ParserKeyword s_assume("ASSUME");
 
     ParserIdentifier name_p;
-    ParserLogicalOrExpression expression_p;
+    ParserExpression expression_p;
 
     ASTPtr name;
     ASTPtr expr;
@@ -858,8 +858,8 @@ bool ParserCreateWindowViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &
     ParserStorage storage_p;
     ParserStorage storage_inner;
     ParserTablePropertiesDeclarationList table_properties_p;
-    ParserIntervalOperatorExpression watermark_p;
-    ParserIntervalOperatorExpression lateness_p;
+    ParserExpression watermark_p;
+    ParserExpression lateness_p;
     ParserSelectWithUnionQuery select_p;
 
     ASTPtr table;
diff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h
index f56e0a4c3a0e..b5480fa6eae6 100644
--- a/src/Parsers/ParserCreateQuery.h
+++ b/src/Parsers/ParserCreateQuery.h
@@ -134,7 +134,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     ParserKeyword s_remove{"REMOVE"};
     ParserKeyword s_type{"TYPE"};
     ParserKeyword s_collate{"COLLATE"};
-    ParserTernaryOperatorExpression expr_parser;
+    ParserExpression expr_parser;
     ParserStringLiteral string_literal_parser;
     ParserLiteral literal_parser;
     ParserCodec codec_parser;
diff --git a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp
index 44bb7fb60577..9910c73e5415 100644
--- a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp
+++ b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp
@@ -20,7 +20,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E
     ParserKeyword s_is_object_id{"IS_OBJECT_ID"};
     ParserLiteral default_parser;
     ParserArrayOfLiterals array_literals_parser;
-    ParserTernaryOperatorExpression expression_parser;
+    ParserExpression expression_parser;
 
     /// mandatory attribute name
     ASTPtr name;
diff --git a/src/Parsers/ParserExternalDDLQuery.cpp b/src/Parsers/ParserExternalDDLQuery.cpp
index 87630777fa66..4839ce73614a 100644
--- a/src/Parsers/ParserExternalDDLQuery.cpp
+++ b/src/Parsers/ParserExternalDDLQuery.cpp
@@ -3,7 +3,7 @@
 #include <Parsers/ASTExternalDDLQuery.h>
 #include <Parsers/ASTSelectWithUnionQuery.h>
 #include <Parsers/CommonParsers.h>
-#include <Parsers/ExpressionElementParsers.h>
+#include <Parsers/ExpressionListParsers.h>
 #include <Parsers/ParserDropQuery.h>
 #include <Parsers/ParserExternalDDLQuery.h>
 #include <Parsers/ParserRenameQuery.h>
diff --git a/src/Parsers/ParserTablesInSelectQuery.cpp b/src/Parsers/ParserTablesInSelectQuery.cpp
index 8137093b9905..ef39df8ca523 100644
--- a/src/Parsers/ParserTablesInSelectQuery.cpp
+++ b/src/Parsers/ParserTablesInSelectQuery.cpp
@@ -226,7 +226,7 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec
             else if (ParserKeyword("ON").ignore(pos, expected))
             {
                 /// OR is operator with lowest priority, so start parsing from it.
-                if (!ParserLogicalOrExpression().parse(pos, table_join->on_expression, expected))
+                if (!ParserExpression().parse(pos, table_join->on_expression, expected))
                     return false;
             }
             else
diff --git a/src/TableFunctions/Hive/TableFunctionHive.cpp b/src/TableFunctions/Hive/TableFunctionHive.cpp
index ea682ce8c1f7..7e14f5ca3003 100644
--- a/src/TableFunctions/Hive/TableFunctionHive.cpp
+++ b/src/TableFunctions/Hive/TableFunctionHive.cpp
@@ -61,7 +61,7 @@ namespace DB
         ColumnsDescription /*cached_columns_*/) const
     {
         const Settings & settings = context_->getSettings();
-        ParserLambdaExpression partition_by_parser;
+        ParserExpression partition_by_parser;
         ASTPtr partition_by_ast = parseQuery(
             partition_by_parser,
             "(" + partition_by_def + ")",
