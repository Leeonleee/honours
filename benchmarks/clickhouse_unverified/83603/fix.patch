diff --git a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h
index 07b4ad16ac29..a65a1fb1ca12 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupNumericIndexedVectorDataBSI.h
@@ -3,9 +3,10 @@
 #include <DataTypes/IDataType.h>
 #include <Formats/FormatSettings.h>
 #include <IO/ReadBuffer.h>
-#include <base/demangle.h>
 #include <Common/JSONBuilder.h>
 
+#include <base/demangle.h>
+
 /// Include this last â€” see the reason inside
 #include <AggregateFunctions/AggregateFunctionGroupBitmapData.h>
 #include <roaring/containers/containers.h>
@@ -1624,7 +1625,38 @@ class BSINumericIndexedVector
           * - When value is a Float32/Float64, fraction_bit_num indicates how many bits are used to represent the decimal, Because the
           *   maximum value of total_bit_num(integer_bit_num + fraction_bit_num) is 64, overflow may occur.
           */
-        Int64 scaled_value = Int64(value * (1L << fraction_bit_num));
+
+        Int64 scaled_value = 0;
+        UInt64 scaling = 1ULL << fraction_bit_num;
+
+        /// Check for overflows. (3) With all integer types, value * (1ULL << fraction_bit_num) cannot overflow as fraction_bit_num is
+        /// always 0. (1) Overflow can only occur when value is a UInt64 that is out of bounds of Int64. (2) With floating point value, we
+        /// are concerned that casting Float(32/64) result will overflow Int64 destination.
+        if constexpr (std::is_same_v<ValueType, UInt64>)
+        {
+            if (value > std::numeric_limits<Int64>::max())
+                throw Exception(ErrorCodes::INCORRECT_DATA, "Value {} does not fit in Int64. It should, even when using UInt64.", value);
+
+            scaled_value = static_cast<Int64>(value);
+        }
+        else if constexpr (std::is_same_v<ValueType, Float32> || std::is_same_v<ValueType, Float64>)
+        {
+            constexpr Float64 lim = static_cast<Float64>(std::numeric_limits<Int64>::max());
+
+            if (fabs(value) > lim / static_cast<Float64>(scaling))
+                throw Exception(
+                    ErrorCodes::INCORRECT_DATA,
+                    "Value {} is out of range for BSI with integer_bit_num={} and fraction_bit_num={}",
+                    Float64(value),
+                    integer_bit_num,
+                    fraction_bit_num);
+
+            scaled_value = static_cast<Int64>(value * scaling);
+        }
+        else
+        {
+            scaled_value = static_cast<Int64>(value);
+        }
 
         UInt8 cin = 0;
         for (size_t j = 0; j < total_bit_num; ++j)
