diff --git a/base/base/StringRef.h b/base/base/StringRef.h
index af3441c2a75c..aa2bce71032b 100644
--- a/base/base/StringRef.h
+++ b/base/base/StringRef.h
@@ -369,11 +369,15 @@ namespace PackedZeroTraits
 {
     template <typename Second, template <typename, typename> class PackedPairNoInit>
     inline bool check(const PackedPairNoInit<StringRef, Second> p)
-    { return 0 == p.key.size; }
+    {
+        return 0 == p.key.size;
+    }
 
     template <typename Second, template <typename, typename> class PackedPairNoInit>
     inline void set(PackedPairNoInit<StringRef, Second> & p)
-    { p.key.size = 0; }
+    {
+        p.key.size = 0;
+    }
 }
 
 
diff --git a/src/Common/HashTable/HashTable.h b/src/Common/HashTable/HashTable.h
index 05a257de2e2a..f4374a0f2ca6 100644
--- a/src/Common/HashTable/HashTable.h
+++ b/src/Common/HashTable/HashTable.h
@@ -67,19 +67,6 @@ struct HashTableNoState
 };
 
 
-/// These functions can be overloaded for custom types.
-namespace ZeroTraits
-{
-
-template <typename T>
-bool check(const T x) { return x == T{}; }
-
-template <typename T>
-void set(T & x) { x = T{}; }
-
-}
-
-
 /** Numbers are compared bitwise.
   * Complex types are compared by operator== as usual (this is important if there are gaps).
   *
@@ -87,18 +74,32 @@ void set(T & x) { x = T{}; }
   * Otherwise the invariants in hash table probing do not met when NaNs are present.
   */
 template <typename T>
-inline bool bitEquals(T && a, T && b)
+inline bool bitEquals(T a, T b)
 {
-    using RealT = std::decay_t<T>;
-
-    if constexpr (std::is_floating_point_v<RealT>)
-        /// Note that memcmp with constant size is compiler builtin.
-        return 0 == memcmp(&a, &b, sizeof(RealT)); /// NOLINT
+    if constexpr (std::is_floating_point_v<T>)
+        /// Note that memcmp with constant size is a compiler builtin.
+        return 0 == memcmp(&a, &b, sizeof(T)); /// NOLINT
     else
         return a == b;
 }
 
 
+/// These functions can be overloaded for custom types.
+namespace ZeroTraits
+{
+
+template <typename T>
+bool check(const T x)
+{
+    return bitEquals(x, T{});
+}
+
+template <typename T>
+void set(T & x) { x = T{}; }
+
+}
+
+
 /**
   * getKey/Mapped -- methods to get key/"mapped" values from the LookupResult returned by find() and
   * emplace() methods of HashTable. Must not be called for a null LookupResult.
