diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp
index b6f4798c184f..ba685a5db583 100644
--- a/src/Core/Block.cpp
+++ b/src/Core/Block.cpp
@@ -61,21 +61,27 @@ static ReturnType checkColumnStructure(const ColumnWithTypeAndName & actual, con
         return ReturnType(true);
 
     const IColumn * actual_column = actual.column.get();
+    const IColumn * expected_column = expected.column.get();
 
-    /// If we allow to materialize, and expected column is not const or sparse, then unwrap actual column.
+    /// If we allow to materialize columns, omit Const and Sparse columns.
     if (allow_materialize)
     {
-        if (!isColumnConst(*expected.column))
-            if (const auto * column_const = typeid_cast<const ColumnConst *>(actual_column))
-                actual_column = &column_const->getDataColumn();
+        if (const auto * column_const = typeid_cast<const ColumnConst *>(actual_column))
+            actual_column = &column_const->getDataColumn();
 
-        if (!expected.column->isSparse())
-            if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(actual_column))
-                actual_column = &column_sparse->getValuesColumn();
+        if (const auto * column_const = typeid_cast<const ColumnConst *>(expected_column))
+            expected_column = &column_const->getDataColumn();
+
+        if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(actual_column))
+            actual_column = &column_sparse->getValuesColumn();
+
+        if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(expected_column))
+            expected_column = &column_sparse->getValuesColumn();
     }
 
     const auto * actual_column_maybe_agg = typeid_cast<const ColumnAggregateFunction *>(actual_column);
-    const auto * expected_column_maybe_agg = typeid_cast<const ColumnAggregateFunction *>(expected.column.get());
+    const auto * expected_column_maybe_agg = typeid_cast<const ColumnAggregateFunction *>(expected_column);
+
     if (actual_column_maybe_agg && expected_column_maybe_agg)
     {
         if (!actual_column_maybe_agg->getAggregateFunction()->haveSameStateRepresentation(*expected_column_maybe_agg->getAggregateFunction()))
@@ -85,13 +91,16 @@ static ReturnType checkColumnStructure(const ColumnWithTypeAndName & actual, con
                     actual.dumpStructure(),
                     expected.dumpStructure());
     }
-    else if (actual_column->getName() != expected.column->getName())
+    else if (actual_column->getName() != expected_column->getName())
+    {
         return onError<ReturnType>(code,
                 "Block structure mismatch in {} stream: different columns:
{}
{}",
                 context_description,
                 actual.dumpStructure(),
                 expected.dumpStructure());
 
+    }
+
     if (isColumnConst(*actual.column) && isColumnConst(*expected.column)
         && !actual.column->empty() && !expected.column->empty()) /// don't check values in empty columns
     {
