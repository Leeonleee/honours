{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64386,
  "instance_id": "ClickHouse__ClickHouse-64386",
  "issue_numbers": [
    "61548"
  ],
  "base_commit": "ebaf19bf3f0fc5a0423438a1a60259d1e982b700",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex dfe1224f7b87..9ec9f68ada73 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -735,6 +735,8 @@ LIMIT 10\n \n Given a size (number of bytes), this function returns a readable, rounded size with suffix (KB, MB, etc.) as string.\n \n+The opposite operations of this function are [fromReadableDecimalSize](#fromReadableDecimalSize), [fromReadableDecimalSizeOrZero](#fromReadableDecimalSizeOrZero), and [fromReadableDecimalSizeOrNull](#fromReadableDecimalSizeOrNull).\n+\n **Syntax**\n \n ```sql\n@@ -766,6 +768,8 @@ Result:\n \n Given a size (number of bytes), this function returns a readable, rounded size with suffix (KiB, MiB, etc.) as string.\n \n+The opposite operations of this function are [fromReadableSize](#fromReadableSize), [fromReadableSizeOrZero](#fromReadableSizeOrZero), and [fromReadableSizeOrNull](#fromReadableSizeOrNull).\n+\n **Syntax**\n \n ```sql\n@@ -890,6 +894,238 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## fromReadableSize\n+\n+Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes.\n+If the function is unable to parse the input value, it throws an exception.\n+\n+The opposite operation of this function is [formatReadableSize](#fromReadableSize).\n+\n+**Syntax**\n+\n+```sql\n+fromReadableSize(x)\n+```\n+\n+**Arguments**\n+\n+- `x` : Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md)).\n+\n+**Returned value**\n+\n+- Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB']) AS readable_sizes,\n+    fromReadableSize(readable_sizes) AS sizes\n+```\n+\n+```text\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KiB          \u2502    1024 \u2502\n+\u2502 3 MiB          \u2502 3145728 \u2502\n+\u2502 5.314 KiB      \u2502    5442 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## fromReadableSizeOrNull\n+\n+Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes.\n+If the function is unable to parse the input value, it returns `NULL`.\n+\n+The opposite operation of this function is [formatReadableSize](#fromReadableSize).\n+\n+**Syntax**\n+\n+```sql\n+fromReadableSizeOrNull(x)\n+```\n+\n+**Arguments**\n+\n+- `x` : Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md)).\n+\n+**Returned value**\n+\n+- Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md))).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes,\n+    fromReadableSizeOrNull(readable_sizes) AS sizes\n+```\n+\n+```text\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KiB          \u2502    1024 \u2502\n+\u2502 3 MiB          \u2502 3145728 \u2502\n+\u2502 5.314 KiB      \u2502    5442 \u2502\n+\u2502 invalid        \u2502    \u1d3a\u1d41\u1d38\u1d38 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## fromReadableSizeOrZero\n+\n+Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes.\n+If the function is unable to parse the input value, it returns `0`.\n+\n+The opposite operation of this function is [formatReadableSize](#fromReadableSize).\n+\n+**Syntax**\n+\n+```sql\n+fromReadableSizeOrZero(x)\n+```\n+\n+**Arguments**\n+\n+- `x` : Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md)).\n+\n+**Returned value**\n+\n+- Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes,\n+    fromReadableSizeOrZero(readable_sizes) AS sizes\n+```\n+\n+```text\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KiB          \u2502    1024 \u2502\n+\u2502 3 MiB          \u2502 3145728 \u2502\n+\u2502 5.314 KiB      \u2502    5442 \u2502\n+\u2502 invalid        \u2502       0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## fromReadableDecimalSize\n+\n+Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes.\n+If the function is unable to parse the input value, it throws an exception.\n+\n+The opposite operation of this function is [formatReadableDecimalSize](#formatReadableDecimalSize).\n+\n+**Syntax**\n+\n+```sql\n+fromReadableDecimalSize(x)\n+```\n+\n+**Arguments**\n+\n+- `x` : Readable size with decimal units ([String](../../sql-reference/data-types/string.md)).\n+\n+**Returned value**\n+\n+- Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB']) AS readable_sizes,\n+    fromReadableDecimalSize(readable_sizes) AS sizes\n+```\n+\n+```text\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KB           \u2502    1000 \u2502\n+\u2502 3 MB           \u2502 3000000 \u2502\n+\u2502 5.314 KB       \u2502    5314 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## fromReadableDecimalSizeOrNull\n+\n+Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes.\n+If the function is unable to parse the input value, it returns `NULL`.\n+\n+The opposite operation of this function is [formatReadableDecimalSize](#formatReadableDecimalSize).\n+\n+**Syntax**\n+\n+```sql\n+fromReadableDecimalSizeOrNull(x)\n+```\n+\n+**Arguments**\n+\n+- `x` : Readable size with decimal units ([String](../../sql-reference/data-types/string.md)).\n+\n+**Returned value**\n+\n+- Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md))).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes,\n+    fromReadableDecimalSizeOrNull(readable_sizes) AS sizes\n+```\n+\n+```text\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KB           \u2502    1000 \u2502\n+\u2502 3 MB           \u2502 3000000 \u2502\n+\u2502 5.314 KB       \u2502    5314 \u2502\n+\u2502 invalid        \u2502    \u1d3a\u1d41\u1d38\u1d38 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## fromReadableDecimalSizeOrZero\n+\n+Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes.\n+If the function is unable to parse the input value, it returns `0`.\n+\n+The opposite operation of this function is [formatReadableDecimalSize](#formatReadableDecimalSize).\n+\n+**Syntax**\n+\n+```sql\n+fromReadableDecimalSizeOrZero(x)\n+```\n+\n+**Arguments**\n+\n+- `x` : Readable size with decimal units ([String](../../sql-reference/data-types/string.md)).\n+\n+**Returned value**\n+\n+- Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md)).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes,\n+    fromReadableSizeOrZero(readable_sizes) AS sizes\n+```\n+\n+```text\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KB           \u2502    1000 \u2502\n+\u2502 3 MB           \u2502 3000000 \u2502\n+\u2502 5.314 KB       \u2502    5000 \u2502\n+\u2502 invalid        \u2502       0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## parseTimeDelta\n \n Parse a sequence of numbers followed by something resembling a time unit.\ndiff --git a/src/Functions/fromReadable.h b/src/Functions/fromReadable.h\nnew file mode 100644\nindex 000000000000..386250a617ba\n--- /dev/null\n+++ b/src/Functions/fromReadable.h\n@@ -0,0 +1,221 @@\n+#pragma once\n+\n+#include <base/types.h>\n+#include <boost/algorithm/string/case_conv.hpp>\n+\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnString.h>\n+#include <Common/Exception.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <IO/ReadBufferFromString.h>\n+#include <IO/ReadHelpers.h>\n+#include <cmath>\n+#include <string_view>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;\n+    extern const int CANNOT_PARSE_NUMBER;\n+    extern const int CANNOT_PARSE_TEXT;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int UNEXPECTED_DATA_AFTER_PARSED_VALUE;\n+}\n+\n+enum class ErrorHandling : uint8_t\n+{\n+    Exception,\n+    Zero,\n+    Null\n+};\n+\n+using ScaleFactors = std::unordered_map<std::string_view, size_t>;\n+\n+/** fromReadble*Size - Returns the number of bytes corresponding to a given readable binary or decimal size.\n+  * Examples:\n+  *  - `fromReadableSize('123 MiB')`\n+  *  - `fromReadableDecimalSize('123 MB')`\n+  * Meant to be the inverse of `formatReadable*Size` with the following exceptions:\n+  *  - Number of bytes is returned as an unsigned integer amount instead of a float. Decimal points are rounded up to the nearest integer.\n+  *  - Negative numbers are not allowed as negative sizes don't make sense.\n+  * Flavours:\n+  *  - fromReadableSize\n+  *  - fromReadableSizeOrNull\n+  *  - fromReadableSizeOrZero\n+  *  - fromReadableDecimalSize\n+  *  - fromReadableDecimalSizeOrNull\n+  *  - fromReadableDecimalSizeOrZero\n+  */\n+template <typename Name, typename Impl, ErrorHandling error_handling>\n+class FunctionFromReadable : public IFunction\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionFromReadable<Name, Impl, error_handling>>(); }\n+\n+    String getName() const override { return name; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args\n+        {\n+            {\"readable_size\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"},\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n+        DataTypePtr return_type = std::make_shared<DataTypeUInt64>();\n+        if (error_handling == ErrorHandling::Null)\n+            return std::make_shared<DataTypeNullable>(return_type);\n+        else\n+            return return_type;\n+    }\n+\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * col_str = checkAndGetColumn<ColumnString>(arguments[0].column.get());\n+        if (!col_str)\n+        {\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of first ('str') argument of function {}. Must be string.\",\n+                arguments[0].column->getName(),\n+                getName()\n+            );\n+        }\n+\n+        const ScaleFactors & scale_factors = Impl::getScaleFactors();\n+\n+        auto col_res = ColumnUInt64::create(input_rows_count);\n+\n+        ColumnUInt8::MutablePtr col_null_map;\n+        if constexpr (error_handling == ErrorHandling::Null)\n+            col_null_map = ColumnUInt8::create(input_rows_count, 0);\n+\n+        auto & res_data = col_res->getData();\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            std::string_view value = col_str->getDataAt(i).toView();\n+            try\n+            {\n+                UInt64 num_bytes = parseReadableFormat(scale_factors, value);\n+                res_data[i] = num_bytes;\n+            }\n+            catch (const Exception &)\n+            {\n+                if constexpr (error_handling == ErrorHandling::Exception)\n+                {\n+                    throw;\n+                }\n+                else\n+                {\n+                    res_data[i] = 0;\n+                    if constexpr (error_handling == ErrorHandling::Null)\n+                        col_null_map->getData()[i] = 1;\n+                }\n+            }\n+        }\n+        if constexpr (error_handling == ErrorHandling::Null)\n+            return ColumnNullable::create(std::move(col_res), std::move(col_null_map));\n+        else\n+            return col_res;\n+    }\n+\n+private:\n+\n+    UInt64 parseReadableFormat(const ScaleFactors & scale_factors, const std::string_view & value) const\n+    {\n+        ReadBufferFromString buf(value);\n+\n+        // tryReadFloatText does seem to not raise any error when there is leading whitespace so we check it explicitly\n+        skipWhitespaceIfAny(buf);\n+        if (buf.getPosition() > 0)\n+        {\n+            throw Exception(\n+                ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED,\n+                \"Invalid expression for function {} - Leading whitespace is not allowed (\\\"{}\\\")\",\n+                getName(),\n+                value\n+            );\n+        }\n+\n+        Float64 base = 0;\n+        if (!tryReadFloatTextPrecise(base, buf))    // If we use the default (fast) tryReadFloatText this returns True on garbage input so we use the Precise version\n+        {\n+            throw Exception(\n+                ErrorCodes::CANNOT_PARSE_NUMBER,\n+                \"Invalid expression for function {} - Unable to parse readable size numeric component (\\\"{}\\\")\",\n+                getName(),\n+                value\n+            );\n+        }\n+        else if (std::isnan(base) || !std::isfinite(base))\n+        {\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Invalid expression for function {} - Invalid numeric component: {}\",\n+                getName(),\n+                base\n+            );\n+        }\n+        else if (base < 0)\n+        {\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Invalid expression for function {} - Negative sizes are not allowed ({})\",\n+                getName(),\n+                base\n+            );\n+        }\n+\n+        skipWhitespaceIfAny(buf);\n+\n+        String unit;\n+        readStringUntilWhitespace(unit, buf);\n+        boost::algorithm::to_lower(unit);\n+        auto iter = scale_factors.find(unit);\n+        if (iter == scale_factors.end())\n+        {\n+            throw Exception(\n+                ErrorCodes::CANNOT_PARSE_TEXT,\n+                \"Invalid expression for function {} - Unknown readable size unit (\\\"{}\\\")\",\n+                getName(),\n+                unit\n+            );\n+        }\n+        else if (!buf.eof())\n+        {\n+            throw Exception(\n+                ErrorCodes::UNEXPECTED_DATA_AFTER_PARSED_VALUE,\n+                \"Invalid expression for function {} - Found trailing characters after readable size string (\\\"{}\\\")\",\n+                getName(),\n+                value\n+            );\n+        }\n+\n+        Float64 num_bytes_with_decimals = base * iter->second;\n+        if (num_bytes_with_decimals > std::numeric_limits<UInt64>::max())\n+        {\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Invalid expression for function {} - Result is too big for output type (\\\"{}\\\")\",\n+                getName(),\n+                num_bytes_with_decimals\n+            );\n+        }\n+        // As the input might be an arbitrary decimal number we might end up with a non-integer amount of bytes when parsing binary (eg MiB) units.\n+        // This doesn't make sense so we round up to indicate the byte size that can fit the passed size.\n+        return static_cast<UInt64>(std::ceil(num_bytes_with_decimals));\n+    }\n+};\n+}\ndiff --git a/src/Functions/fromReadableDecimalSize.cpp b/src/Functions/fromReadableDecimalSize.cpp\nnew file mode 100644\nindex 000000000000..6efabe7267d1\n--- /dev/null\n+++ b/src/Functions/fromReadableDecimalSize.cpp\n@@ -0,0 +1,122 @@\n+#include <base/types.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/fromReadable.h>\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+struct Impl\n+{\n+    static const ScaleFactors & getScaleFactors()\n+    {\n+        static const ScaleFactors scale_factors =\n+        {\n+            {\"b\", 1ull},\n+            {\"kb\", 1000ull},\n+            {\"mb\", 1000ull * 1000ull},\n+            {\"gb\", 1000ull * 1000ull * 1000ull},\n+            {\"tb\", 1000ull * 1000ull * 1000ull * 1000ull},\n+            {\"pb\", 1000ull * 1000ull * 1000ull * 1000ull * 1000ull},\n+            {\"eb\", 1000ull * 1000ull * 1000ull * 1000ull * 1000ull * 1000ull},\n+        };\n+\n+        return scale_factors;\n+    }\n+};\n+\n+struct NameFromReadableDecimalSize\n+{\n+    static constexpr auto name = \"fromReadableDecimalSize\";\n+};\n+\n+struct NameFromReadableDecimalSizeOrNull\n+{\n+    static constexpr auto name = \"fromReadableDecimalSizeOrNull\";\n+};\n+\n+struct NameFromReadableDecimalSizeOrZero\n+{\n+    static constexpr auto name = \"fromReadableDecimalSizeOrZero\";\n+};\n+\n+using FunctionFromReadableDecimalSize = FunctionFromReadable<NameFromReadableDecimalSize, Impl, ErrorHandling::Exception>;\n+using FunctionFromReadableDecimalSizeOrNull = FunctionFromReadable<NameFromReadableDecimalSizeOrNull, Impl, ErrorHandling::Null>;\n+using FunctionFromReadableDecimalSizeOrZero = FunctionFromReadable<NameFromReadableDecimalSizeOrZero, Impl, ErrorHandling::Zero>;\n+\n+\n+FunctionDocumentation fromReadableDecimalSize_documentation {\n+    .description = \"Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes. If the function is unable to parse the input value, it throws an exception.\",\n+    .syntax = \"fromReadableDecimalSize(x)\",\n+    .arguments = {{\"x\", \"Readable size with decimal units ([String](../../sql-reference/data-types/string.md))\"}},\n+    .returned_value = \"Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md))\",\n+    .examples = {\n+        {\n+            \"basic\",\n+            \"SELECT arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB']) AS readable_sizes, fromReadableDecimalSize(readable_sizes) AS sizes;\",\n+            R\"(\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KB           \u2502    1000 \u2502\n+\u2502 3 MB           \u2502 3000000 \u2502\n+\u2502 5.314 KB       \u2502    5314 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"\n+        },\n+    },\n+    .categories = {\"OtherFunctions\"},\n+};\n+\n+FunctionDocumentation fromReadableDecimalSizeOrNull_documentation {\n+    .description = \"Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit, this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `NULL`\",\n+    .syntax = \"fromReadableDecimalSizeOrNull(x)\",\n+    .arguments = {{\"x\", \"Readable size with decimal units ([String](../../sql-reference/data-types/string.md))\"}},\n+    .returned_value = \"Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md)))\",\n+    .examples = {\n+        {\n+            \"basic\",\n+            \"SELECT arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes, fromReadableSizeOrNull(readable_sizes) AS sizes;\",\n+            R\"(\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KB           \u2502    1000 \u2502\n+\u2502 3 MB           \u2502 3000000 \u2502\n+\u2502 5.314 KB       \u2502    5314 \u2502\n+\u2502 invalid        \u2502    \u1d3a\u1d41\u1d38\u1d38 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"\n+        },\n+    },\n+    .categories = {\"OtherFunctions\"},\n+};\n+\n+FunctionDocumentation fromReadableDecimalSizeOrZero_documentation {\n+    .description = \"Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit, this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `0`\",\n+    .syntax = \"formatReadableSizeOrZero(x)\",\n+    .arguments = {{\"x\", \"Readable size with decimal units ([String](../../sql-reference/data-types/string.md))\"}},\n+    .returned_value = \"Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md))\",\n+    .examples = {\n+        {\n+            \"basic\",\n+            \"SELECT arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes, fromReadableSizeOrZero(readable_sizes) AS sizes;\",\n+            R\"(\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KB           \u2502    1000 \u2502\n+\u2502 3 MB           \u2502 3000000 \u2502\n+\u2502 5.314 KB       \u2502    5000 \u2502\n+\u2502 invalid        \u2502       0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"\n+        },\n+    },\n+    .categories = {\"OtherFunctions\"},\n+};\n+}\n+\n+REGISTER_FUNCTION(FromReadableDecimalSize)\n+{\n+    factory.registerFunction<FunctionFromReadableDecimalSize>(fromReadableDecimalSize_documentation);\n+    factory.registerFunction<FunctionFromReadableDecimalSizeOrNull>(fromReadableDecimalSizeOrNull_documentation);\n+    factory.registerFunction<FunctionFromReadableDecimalSizeOrZero>(fromReadableDecimalSizeOrZero_documentation);\n+}\n+}\ndiff --git a/src/Functions/fromReadableSize.cpp b/src/Functions/fromReadableSize.cpp\nnew file mode 100644\nindex 000000000000..425fb25e0fd1\n--- /dev/null\n+++ b/src/Functions/fromReadableSize.cpp\n@@ -0,0 +1,124 @@\n+#include <base/types.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/fromReadable.h>\n+#include \"Common/FunctionDocumentation.h\"\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+struct Impl\n+{\n+    static const ScaleFactors & getScaleFactors()\n+    {\n+        // ISO/IEC 80000-13 binary units\n+        static const ScaleFactors scale_factors =\n+        {\n+            {\"b\", 1ull},\n+            {\"kib\", 1024ull},\n+            {\"mib\", 1024ull * 1024ull},\n+            {\"gib\", 1024ull * 1024ull * 1024ull},\n+            {\"tib\", 1024ull * 1024ull * 1024ull * 1024ull},\n+            {\"pib\", 1024ull * 1024ull * 1024ull * 1024ull * 1024ull},\n+            {\"eib\", 1024ull * 1024ull * 1024ull * 1024ull * 1024ull * 1024ull},\n+        };\n+\n+        return scale_factors;\n+    }\n+};\n+\n+\n+struct NameFromReadableSize\n+{\n+    static constexpr auto name = \"fromReadableSize\";\n+};\n+\n+struct NameFromReadableSizeOrNull\n+{\n+    static constexpr auto name = \"fromReadableSizeOrNull\";\n+};\n+\n+struct NameFromReadableSizeOrZero\n+{\n+    static constexpr auto name = \"fromReadableSizeOrZero\";\n+};\n+\n+using FunctionFromReadableSize = FunctionFromReadable<NameFromReadableSize, Impl, ErrorHandling::Exception>;\n+using FunctionFromReadableSizeOrNull = FunctionFromReadable<NameFromReadableSizeOrNull, Impl, ErrorHandling::Null>;\n+using FunctionFromReadableSizeOrZero = FunctionFromReadable<NameFromReadableSizeOrZero, Impl, ErrorHandling::Zero>;\n+\n+FunctionDocumentation fromReadableSize_documentation {\n+    .description = \"Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it throws an exception.\",\n+    .syntax = \"fromReadableSize(x)\",\n+    .arguments = {{\"x\", \"Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md))\"}},\n+    .returned_value = \"Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md))\",\n+    .examples = {\n+        {\n+            \"basic\",\n+            \"SELECT arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB']) AS readable_sizes, fromReadableSize(readable_sizes) AS sizes;\",\n+            R\"(\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KiB          \u2502    1024 \u2502\n+\u2502 3 MiB          \u2502 3145728 \u2502\n+\u2502 5.314 KiB      \u2502    5442 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"\n+        },\n+    },\n+    .categories = {\"OtherFunctions\"},\n+};\n+\n+FunctionDocumentation fromReadableSizeOrNull_documentation {\n+    .description = \"Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `NULL`\",\n+    .syntax = \"fromReadableSizeOrNull(x)\",\n+    .arguments = {{\"x\", \"Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md))\"}},\n+    .returned_value = \"Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md)))\",\n+    .examples = {\n+        {\n+            \"basic\",\n+            \"SELECT arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes, fromReadableSize(readable_sizes) AS sizes;\",\n+            R\"(\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KiB          \u2502    1024 \u2502\n+\u2502 3 MiB          \u2502 3145728 \u2502\n+\u2502 5.314 KiB      \u2502    5442 \u2502\n+\u2502 invalid        \u2502    \u1d3a\u1d41\u1d38\u1d38 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"\n+        },\n+    },\n+    .categories = {\"OtherFunctions\"},\n+};\n+\n+FunctionDocumentation fromReadableSizeOrZero_documentation {\n+    .description = \"Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `0`\",\n+    .syntax = \"fromReadableSizeOrZero(x)\",\n+    .arguments = {{\"x\", \"Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md))\"}},\n+    .returned_value = \"Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md))\",\n+    .examples = {\n+        {\n+            \"basic\",\n+            \"SELECT arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes, fromReadableSize(readable_sizes) AS sizes;\",\n+            R\"(\n+\u250c\u2500readable_sizes\u2500\u252c\u2500\u2500\u2500sizes\u2500\u2510\n+\u2502 1 B            \u2502       1 \u2502\n+\u2502 1 KiB          \u2502    1024 \u2502\n+\u2502 3 MiB          \u2502 3145728 \u2502\n+\u2502 5.314 KiB      \u2502    5442 \u2502\n+\u2502 invalid        \u2502       0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\",\n+        },\n+    },\n+    .categories = {\"OtherFunctions\"},\n+};\n+}\n+\n+REGISTER_FUNCTION(FromReadableSize)\n+{\n+    factory.registerFunction<FunctionFromReadableSize>(fromReadableSize_documentation);\n+    factory.registerFunction<FunctionFromReadableSizeOrNull>(fromReadableSizeOrNull_documentation);\n+    factory.registerFunction<FunctionFromReadableSizeOrZero>(fromReadableSizeOrZero_documentation);\n+}\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 6df2e4265610..7f54d509da13 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1602,6 +1602,12 @@ freezed\n fromDaysSinceYearZero\n fromModifiedJulianDay\n fromModifiedJulianDayOrNull\n+fromReadableSize\n+fromReadableSizeOrNull\n+fromReadableSizeOrZero\n+fromReadableDecimalSize\n+fromReadableDecimalSizeOrNull\n+fromReadableDecimalSizeOrZero\n fromUTCTimestamp\n fromUnixTimestamp\n fromUnixTimestampInJodaSyntax\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03166_fromReadableSize.reference b/tests/queries/0_stateless/03166_fromReadableSize.reference\nnew file mode 100644\nindex 000000000000..6fb54d991716\n--- /dev/null\n+++ b/tests/queries/0_stateless/03166_fromReadableSize.reference\n@@ -0,0 +1,53 @@\n+1.00 B\n+1.00 KiB\n+1.00 MiB\n+1.00 GiB\n+1.00 TiB\n+1.00 PiB\n+1.00 EiB\n+1.00 MiB\n+1024\n+3072\n+1024\n+1024\n+1024\n+1024\n+1024\n+\\N\n+3217\n+3217\n+1000\n+5\n+2048\n+8192\n+0\t0\t0\n+1 B\t1\n+1 KiB\t1024\n+1 MiB\t1048576\n+1 GiB\t1073741824\n+1 TiB\t1099511627776\n+1 PiB\t1125899906842624\n+1 EiB\t1152921504606846976\n+invalid\t\\N\n+1 Joe\t\\N\n+1KB\t\\N\n+ 1 GiB\t\\N\n+1 TiB with fries\t\\N\n+NaN KiB\t\\N\n+Inf KiB\t\\N\n+0xa123 KiB\t\\N\n+1 B\t1\n+1 KiB\t1024\n+1 MiB\t1048576\n+1 GiB\t1073741824\n+1 TiB\t1099511627776\n+1 PiB\t1125899906842624\n+1 EiB\t1152921504606846976\n+invalid\t0\n+1 Joe\t0\n+1KB\t0\n+ 1 GiB\t0\n+1 TiB with fries\t0\n+NaN KiB\t0\n+Inf KiB\t0\n+0xa123 KiB\t0\ndiff --git a/tests/queries/0_stateless/03166_fromReadableSize.sql b/tests/queries/0_stateless/03166_fromReadableSize.sql\nnew file mode 100644\nindex 000000000000..2983280320c6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03166_fromReadableSize.sql\n@@ -0,0 +1,118 @@\n+-- Should be kept in sync with 03167_fromReadableDecimalSize.sql\n+\n+-- Should be the inverse of formatReadableSize\n+SELECT formatReadableSize(fromReadableSize('1 B'));\n+SELECT formatReadableSize(fromReadableSize('1 KiB'));\n+SELECT formatReadableSize(fromReadableSize('1 MiB'));\n+SELECT formatReadableSize(fromReadableSize('1 GiB'));\n+SELECT formatReadableSize(fromReadableSize('1 TiB'));\n+SELECT formatReadableSize(fromReadableSize('1 PiB'));\n+SELECT formatReadableSize(fromReadableSize('1 EiB'));\n+\n+-- Is case-insensitive\n+SELECT formatReadableSize(fromReadableSize('1 mIb'));\n+\n+-- Should be able to parse decimals\n+SELECT fromReadableSize('1.00 KiB');    -- 1024\n+SELECT fromReadableSize('3.00 KiB');    -- 3072\n+\n+-- Infix whitespace is ignored\n+SELECT fromReadableSize('1    KiB');\n+SELECT fromReadableSize('1KiB');\n+\n+-- Can parse LowCardinality\n+SELECT fromReadableSize(toLowCardinality('1 KiB'));\n+\n+-- Can parse nullable fields\n+SELECT fromReadableSize(toNullable('1 KiB'));\n+\n+-- Can parse non-const columns fields\n+SELECT fromReadableSize(materialize('1 KiB'));\n+\n+-- Output is NULL if NULL arg is passed\n+SELECT fromReadableSize(NULL);\n+\n+-- Can parse more decimal places than Float64's precision\n+SELECT fromReadableSize('3.14159265358979323846264338327950288419716939937510 KiB');\n+\n+-- Can parse sizes prefixed with a plus sign\n+SELECT fromReadableSize('+3.1415 KiB');\n+\n+-- Can parse amounts in scientific notation\n+SELECT fromReadableSize('10e2 B');\n+\n+-- Can parse floats with no decimal points\n+SELECT fromReadableSize('5. B');\n+\n+-- Can parse numbers with leading zeroes\n+SELECT fromReadableSize('002 KiB');\n+\n+-- Can parse octal-like\n+SELECT fromReadableSize('08 KiB');\n+\n+-- Can parse various flavours of zero\n+SELECT fromReadableSize('0 KiB'), fromReadableSize('+0 KiB'), fromReadableSize('-0 KiB');\n+\n+-- ERRORS\n+-- No arguments\n+SELECT fromReadableSize(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+-- Too many arguments\n+SELECT fromReadableSize('1 B', '2 B'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+-- Wrong Type\n+SELECT fromReadableSize(12); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+-- Invalid input - overall garbage\n+SELECT fromReadableSize('oh no'); -- { serverError CANNOT_PARSE_NUMBER }\n+-- Invalid input - unknown unit\n+SELECT fromReadableSize('12.3 rb'); -- { serverError CANNOT_PARSE_TEXT }\n+-- Invalid input - Leading whitespace\n+SELECT fromReadableSize(' 1 B'); -- { serverError CANNOT_PARSE_INPUT_ASSERTION_FAILED }\n+-- Invalid input - Trailing characters\n+SELECT fromReadableSize('1 B leftovers'); -- { serverError UNEXPECTED_DATA_AFTER_PARSED_VALUE }\n+-- Invalid input - Decimal size unit is not accepted\n+SELECT fromReadableSize('1 KB'); -- { serverError CANNOT_PARSE_TEXT }\n+-- Invalid input - Negative sizes are not allowed\n+SELECT fromReadableSize('-1 KiB'); -- { serverError BAD_ARGUMENTS }\n+-- Invalid input - Input too large to fit in UInt64\n+SELECT fromReadableSize('1000 EiB'); -- { serverError BAD_ARGUMENTS }\n+-- Invalid input - Hexadecimal is not supported\n+SELECT fromReadableSize('0xa123 KiB'); -- { serverError CANNOT_PARSE_TEXT }\n+-- Invalid input - NaN is not supported, with or without sign and with different capitalizations\n+SELECT fromReadableSize('nan KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('+nan KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('-nan KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('NaN KiB'); -- { serverError BAD_ARGUMENTS }\n+-- Invalid input - Infinite is not supported, with or without sign, in all its forms\n+SELECT fromReadableSize('inf KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('+inf KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('-inf KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('infinite KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('+infinite KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('-infinite KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('Inf KiB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableSize('Infinite KiB'); -- { serverError BAD_ARGUMENTS }\n+\n+\n+\n+-- OR NULL\n+-- Works as the regular version when inputs are correct\n+SELECT\n+    arrayJoin(['1 B', '1 KiB', '1 MiB', '1 GiB', '1 TiB', '1 PiB', '1 EiB']) AS readable_sizes,\n+    fromReadableSizeOrNull(readable_sizes) AS filesize;\n+\n+-- Returns NULL on invalid values\n+SELECT\n+    arrayJoin(['invalid', '1 Joe', '1KB', ' 1 GiB', '1 TiB with fries', 'NaN KiB', 'Inf KiB', '0xa123 KiB']) AS readable_sizes,\n+    fromReadableSizeOrNull(readable_sizes) AS filesize;\n+\n+\n+-- OR ZERO\n+-- Works as the regular version when inputs are correct\n+SELECT\n+    arrayJoin(['1 B', '1 KiB', '1 MiB', '1 GiB', '1 TiB', '1 PiB', '1 EiB']) AS readable_sizes,\n+    fromReadableSizeOrZero(readable_sizes) AS filesize;\n+\n+-- Returns NULL on invalid values\n+SELECT\n+    arrayJoin(['invalid', '1 Joe', '1KB', ' 1 GiB', '1 TiB with fries', 'NaN KiB', 'Inf KiB', '0xa123 KiB']) AS readable_sizes,\n+    fromReadableSizeOrZero(readable_sizes) AS filesize;\n+\ndiff --git a/tests/queries/0_stateless/03167_fromReadableDecimalSize.reference b/tests/queries/0_stateless/03167_fromReadableDecimalSize.reference\nnew file mode 100644\nindex 000000000000..62620501de01\n--- /dev/null\n+++ b/tests/queries/0_stateless/03167_fromReadableDecimalSize.reference\n@@ -0,0 +1,53 @@\n+1.00 B\n+1.00 KB\n+1.00 MB\n+1.00 GB\n+1.00 TB\n+1.00 PB\n+1.00 EB\n+1.00 MB\n+1000\n+3000\n+1000\n+1000\n+1000\n+1000\n+1000\n+\\N\n+3142\n+3142\n+1000\n+5\n+2000\n+8000\n+0\t0\t0\n+1 B\t1\n+1 KB\t1000\n+1 MB\t1000000\n+1 GB\t1000000000\n+1 TB\t1000000000000\n+1 PB\t1000000000000000\n+1 EB\t1000000000000000000\n+invalid\t\\N\n+1 Joe\t\\N\n+1 KiB\t\\N\n+ 1 GB\t\\N\n+1 TB with fries\t\\N\n+NaN KB\t\\N\n+Inf KB\t\\N\n+0xa123 KB\t\\N\n+1 B\t1\n+1 KB\t1000\n+1 MB\t1000000\n+1 GB\t1000000000\n+1 TB\t1000000000000\n+1 PB\t1000000000000000\n+1 EB\t1000000000000000000\n+invalid\t0\n+1 Joe\t0\n+1 KiB\t0\n+ 1 GiB\t0\n+1 TiB with fries\t0\n+NaN KB\t0\n+Inf KB\t0\n+0xa123 KB\t0\ndiff --git a/tests/queries/0_stateless/03167_fromReadableDecimalSize.sql b/tests/queries/0_stateless/03167_fromReadableDecimalSize.sql\nnew file mode 100644\nindex 000000000000..618f99b1d282\n--- /dev/null\n+++ b/tests/queries/0_stateless/03167_fromReadableDecimalSize.sql\n@@ -0,0 +1,117 @@\n+-- Should be kept in sync with 03166_fromReadableSize.sql\n+\n+-- Should be the inverse of formatReadableDecimalSize\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 B'));\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 KB'));\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 MB'));\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 GB'));\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 TB'));\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 PB'));\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 EB'));\n+\n+-- Is case-insensitive\n+SELECT formatReadableDecimalSize(fromReadableDecimalSize('1 mb'));\n+\n+-- Should be able to parse decimals\n+SELECT fromReadableDecimalSize('1.00 KB');    -- 1024\n+SELECT fromReadableDecimalSize('3.00 KB');    -- 3072\n+\n+-- Infix whitespace is ignored\n+SELECT fromReadableDecimalSize('1    KB');\n+SELECT fromReadableDecimalSize('1KB');\n+\n+-- Can parse LowCardinality\n+SELECT fromReadableDecimalSize(toLowCardinality('1 KB'));\n+\n+-- Can parse nullable fields\n+SELECT fromReadableDecimalSize(toNullable('1 KB'));\n+\n+-- Can parse non-const columns fields\n+SELECT fromReadableDecimalSize(materialize('1 KB'));\n+\n+-- Output is NULL if NULL arg is passed\n+SELECT fromReadableDecimalSize(NULL);\n+\n+-- Can parse more decimal places than Float64's precision\n+SELECT fromReadableDecimalSize('3.14159265358979323846264338327950288419716939937510 KB');\n+\n+-- Can parse sizes prefixed with a plus sign\n+SELECT fromReadableDecimalSize('+3.1415 KB');\n+\n+-- Can parse amounts in scientific notation\n+SELECT fromReadableDecimalSize('10e2 B');\n+\n+-- Can parse floats with no decimal points\n+SELECT fromReadableDecimalSize('5. B');\n+\n+-- Can parse numbers with leading zeroes\n+SELECT fromReadableDecimalSize('002 KB');\n+\n+-- Can parse octal-like\n+SELECT fromReadableDecimalSize('08 KB');\n+\n+-- Can parse various flavours of zero\n+SELECT fromReadableDecimalSize('0 KB'), fromReadableDecimalSize('+0 KB'), fromReadableDecimalSize('-0 KB');\n+\n+-- ERRORS\n+-- No arguments\n+SELECT fromReadableDecimalSize(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+-- Too many arguments\n+SELECT fromReadableDecimalSize('1 B', '2 B'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+-- Wrong Type\n+SELECT fromReadableDecimalSize(12); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+-- Invalid input - overall garbage\n+SELECT fromReadableDecimalSize('oh no'); -- { serverError CANNOT_PARSE_NUMBER }\n+-- Invalid input - unknown unit\n+SELECT fromReadableDecimalSize('12.3 rb'); -- { serverError CANNOT_PARSE_TEXT }\n+-- Invalid input - Leading whitespace\n+SELECT fromReadableDecimalSize(' 1 B'); -- { serverError CANNOT_PARSE_INPUT_ASSERTION_FAILED }\n+-- Invalid input - Trailing characters\n+SELECT fromReadableDecimalSize('1 B leftovers'); -- { serverError UNEXPECTED_DATA_AFTER_PARSED_VALUE }\n+-- Invalid input - Binary size unit is not accepted\n+SELECT fromReadableDecimalSize('1 KiB'); -- { serverError CANNOT_PARSE_TEXT }\n+-- Invalid input - Negative sizes are not allowed\n+SELECT fromReadableDecimalSize('-1 KB'); -- { serverError BAD_ARGUMENTS }\n+-- Invalid input - Input too large to fit in UInt64\n+SELECT fromReadableDecimalSize('1000 EB'); -- { serverError BAD_ARGUMENTS }\n+-- Invalid input - Hexadecimal is not supported\n+SELECT fromReadableDecimalSize('0xa123 KB'); -- { serverError CANNOT_PARSE_TEXT }\n+-- Invalid input - NaN is not supported, with or without sign and with different capitalizations\n+SELECT fromReadableDecimalSize('nan KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('+nan KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('-nan KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('NaN KB'); -- { serverError BAD_ARGUMENTS }\n+-- Invalid input - Infinite is not supported, with or without sign, in all its forms\n+SELECT fromReadableDecimalSize('inf KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('+inf KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('-inf KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('infinite KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('+infinite KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('-infinite KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('Inf KB'); -- { serverError BAD_ARGUMENTS }\n+SELECT fromReadableDecimalSize('Infinite KB'); -- { serverError BAD_ARGUMENTS }\n+\n+\n+-- OR NULL\n+-- Works as the regular version when inputs are correct\n+SELECT\n+    arrayJoin(['1 B', '1 KB', '1 MB', '1 GB', '1 TB', '1 PB', '1 EB']) AS readable_sizes,\n+    fromReadableDecimalSizeOrNull(readable_sizes) AS filesize;\n+\n+-- Returns NULL on invalid values\n+SELECT\n+    arrayJoin(['invalid', '1 Joe', '1 KiB', ' 1 GB', '1 TB with fries', 'NaN KB', 'Inf KB', '0xa123 KB']) AS readable_sizes,\n+    fromReadableDecimalSizeOrNull(readable_sizes) AS filesize;\n+\n+\n+-- OR ZERO\n+-- Works as the regular version when inputs are correct\n+SELECT\n+    arrayJoin(['1 B', '1 KB', '1 MB', '1 GB', '1 TB', '1 PB', '1 EB']) AS readable_sizes,\n+    fromReadableDecimalSizeOrZero(readable_sizes) AS filesize;\n+\n+-- Returns NULL on invalid values\n+SELECT\n+    arrayJoin(['invalid', '1 Joe', '1 KiB', ' 1 GiB', '1 TiB with fries', 'NaN KB', 'Inf KB', '0xa123 KB']) AS readable_sizes,\n+    fromReadableDecimalSizeOrZero(readable_sizes) AS filesize;\n+\n",
  "problem_statement": "Add `fromReadableSize` function\n**Use case**\r\n\r\nInverse `formatReadableSize` to simpler input large sizes.\r\n\r\n**Describe the solution you'd like**\r\n\r\nFor integer numbers and unit name convert it to corresponding number. \r\n\r\n```\r\nSELECT fromReadableSize('10MB')\r\n10000000\r\nSELECT fromReadableSize('10mb')\r\n10000000\r\nSELECT fromReadableSize('10MiB')\r\n1048576\r\n```\r\n\n",
  "hints_text": "hello can i work on this issue?\r\ncan you please assign this to me\n@rschu1ze May I check if I can still work on this function?\r\n\n@h12567 Appreciated, please go ahead.",
  "created_at": "2024-05-24T15:13:45Z",
  "modified_files": [
    "docs/en/sql-reference/functions/other-functions.md",
    "b/src/Functions/fromReadable.h",
    "b/src/Functions/fromReadableDecimalSize.cpp",
    "b/src/Functions/fromReadableSize.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03166_fromReadableSize.reference",
    "b/tests/queries/0_stateless/03166_fromReadableSize.sql",
    "b/tests/queries/0_stateless/03167_fromReadableDecimalSize.reference",
    "b/tests/queries/0_stateless/03167_fromReadableDecimalSize.sql"
  ]
}