diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md
index dfe1224f7b87..9ec9f68ada73 100644
--- a/docs/en/sql-reference/functions/other-functions.md
+++ b/docs/en/sql-reference/functions/other-functions.md
@@ -735,6 +735,8 @@ LIMIT 10
 
 Given a size (number of bytes), this function returns a readable, rounded size with suffix (KB, MB, etc.) as string.
 
+The opposite operations of this function are [fromReadableDecimalSize](#fromReadableDecimalSize), [fromReadableDecimalSizeOrZero](#fromReadableDecimalSizeOrZero), and [fromReadableDecimalSizeOrNull](#fromReadableDecimalSizeOrNull).
+
 **Syntax**
 
 ```sql
@@ -766,6 +768,8 @@ Result:
 
 Given a size (number of bytes), this function returns a readable, rounded size with suffix (KiB, MiB, etc.) as string.
 
+The opposite operations of this function are [fromReadableSize](#fromReadableSize), [fromReadableSizeOrZero](#fromReadableSizeOrZero), and [fromReadableSizeOrNull](#fromReadableSizeOrNull).
+
 **Syntax**
 
 ```sql
@@ -890,6 +894,238 @@ SELECT
 └────────────────────┴────────────────────────────────────────────────┘
 ```
 
+## fromReadableSize
+
+Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes.
+If the function is unable to parse the input value, it throws an exception.
+
+The opposite operation of this function is [formatReadableSize](#fromReadableSize).
+
+**Syntax**
+
+```sql
+fromReadableSize(x)
+```
+
+**Arguments**
+
+- `x` : Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md)).
+
+**Returned value**
+
+- Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md)).
+
+**Example**
+
+```sql
+SELECT
+    arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB']) AS readable_sizes,
+    fromReadableSize(readable_sizes) AS sizes
+```
+
+```text
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KiB          │    1024 │
+│ 3 MiB          │ 3145728 │
+│ 5.314 KiB      │    5442 │
+└────────────────┴─────────┘
+```
+
+## fromReadableSizeOrNull
+
+Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes.
+If the function is unable to parse the input value, it returns `NULL`.
+
+The opposite operation of this function is [formatReadableSize](#fromReadableSize).
+
+**Syntax**
+
+```sql
+fromReadableSizeOrNull(x)
+```
+
+**Arguments**
+
+- `x` : Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md)).
+
+**Returned value**
+
+- Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md))).
+
+**Example**
+
+```sql
+SELECT
+    arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes,
+    fromReadableSizeOrNull(readable_sizes) AS sizes
+```
+
+```text
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KiB          │    1024 │
+│ 3 MiB          │ 3145728 │
+│ 5.314 KiB      │    5442 │
+│ invalid        │    ᴺᵁᴸᴸ │
+└────────────────┴─────────┘
+```
+
+## fromReadableSizeOrZero
+
+Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes.
+If the function is unable to parse the input value, it returns `0`.
+
+The opposite operation of this function is [formatReadableSize](#fromReadableSize).
+
+**Syntax**
+
+```sql
+fromReadableSizeOrZero(x)
+```
+
+**Arguments**
+
+- `x` : Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md)).
+
+**Returned value**
+
+- Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md)).
+
+**Example**
+
+```sql
+SELECT
+    arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes,
+    fromReadableSizeOrZero(readable_sizes) AS sizes
+```
+
+```text
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KiB          │    1024 │
+│ 3 MiB          │ 3145728 │
+│ 5.314 KiB      │    5442 │
+│ invalid        │       0 │
+└────────────────┴─────────┘
+```
+
+## fromReadableDecimalSize
+
+Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes.
+If the function is unable to parse the input value, it throws an exception.
+
+The opposite operation of this function is [formatReadableDecimalSize](#formatReadableDecimalSize).
+
+**Syntax**
+
+```sql
+fromReadableDecimalSize(x)
+```
+
+**Arguments**
+
+- `x` : Readable size with decimal units ([String](../../sql-reference/data-types/string.md)).
+
+**Returned value**
+
+- Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md)).
+
+**Example**
+
+```sql
+SELECT
+    arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB']) AS readable_sizes,
+    fromReadableDecimalSize(readable_sizes) AS sizes
+```
+
+```text
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KB           │    1000 │
+│ 3 MB           │ 3000000 │
+│ 5.314 KB       │    5314 │
+└────────────────┴─────────┘
+```
+
+## fromReadableDecimalSizeOrNull
+
+Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes.
+If the function is unable to parse the input value, it returns `NULL`.
+
+The opposite operation of this function is [formatReadableDecimalSize](#formatReadableDecimalSize).
+
+**Syntax**
+
+```sql
+fromReadableDecimalSizeOrNull(x)
+```
+
+**Arguments**
+
+- `x` : Readable size with decimal units ([String](../../sql-reference/data-types/string.md)).
+
+**Returned value**
+
+- Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md))).
+
+**Example**
+
+```sql
+SELECT
+    arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes,
+    fromReadableDecimalSizeOrNull(readable_sizes) AS sizes
+```
+
+```text
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KB           │    1000 │
+│ 3 MB           │ 3000000 │
+│ 5.314 KB       │    5314 │
+│ invalid        │    ᴺᵁᴸᴸ │
+└────────────────┴─────────┘
+```
+
+## fromReadableDecimalSizeOrZero
+
+Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes.
+If the function is unable to parse the input value, it returns `0`.
+
+The opposite operation of this function is [formatReadableDecimalSize](#formatReadableDecimalSize).
+
+**Syntax**
+
+```sql
+fromReadableDecimalSizeOrZero(x)
+```
+
+**Arguments**
+
+- `x` : Readable size with decimal units ([String](../../sql-reference/data-types/string.md)).
+
+**Returned value**
+
+- Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md)).
+
+**Example**
+
+```sql
+SELECT
+    arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes,
+    fromReadableSizeOrZero(readable_sizes) AS sizes
+```
+
+```text
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KB           │    1000 │
+│ 3 MB           │ 3000000 │
+│ 5.314 KB       │    5000 │
+│ invalid        │       0 │
+└────────────────┴─────────┘
+```
+
 ## parseTimeDelta
 
 Parse a sequence of numbers followed by something resembling a time unit.
diff --git a/src/Functions/fromReadable.h b/src/Functions/fromReadable.h
new file mode 100644
index 000000000000..386250a617ba
--- /dev/null
+++ b/src/Functions/fromReadable.h
@@ -0,0 +1,221 @@
+#pragma once
+
+#include <base/types.h>
+#include <boost/algorithm/string/case_conv.hpp>
+
+#include <Columns/ColumnNullable.h>
+#include <Columns/ColumnsNumber.h>
+#include <Columns/ColumnString.h>
+#include <Common/Exception.h>
+#include <DataTypes/DataTypeNullable.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/IFunction.h>
+#include <IO/ReadBufferFromString.h>
+#include <IO/ReadHelpers.h>
+#include <cmath>
+#include <string_view>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+    extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;
+    extern const int CANNOT_PARSE_NUMBER;
+    extern const int CANNOT_PARSE_TEXT;
+    extern const int ILLEGAL_COLUMN;
+    extern const int UNEXPECTED_DATA_AFTER_PARSED_VALUE;
+}
+
+enum class ErrorHandling : uint8_t
+{
+    Exception,
+    Zero,
+    Null
+};
+
+using ScaleFactors = std::unordered_map<std::string_view, size_t>;
+
+/** fromReadble*Size - Returns the number of bytes corresponding to a given readable binary or decimal size.
+  * Examples:
+  *  - `fromReadableSize('123 MiB')`
+  *  - `fromReadableDecimalSize('123 MB')`
+  * Meant to be the inverse of `formatReadable*Size` with the following exceptions:
+  *  - Number of bytes is returned as an unsigned integer amount instead of a float. Decimal points are rounded up to the nearest integer.
+  *  - Negative numbers are not allowed as negative sizes don't make sense.
+  * Flavours:
+  *  - fromReadableSize
+  *  - fromReadableSizeOrNull
+  *  - fromReadableSizeOrZero
+  *  - fromReadableDecimalSize
+  *  - fromReadableDecimalSizeOrNull
+  *  - fromReadableDecimalSizeOrZero
+  */
+template <typename Name, typename Impl, ErrorHandling error_handling>
+class FunctionFromReadable : public IFunction
+{
+public:
+    static constexpr auto name = Name::name;
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionFromReadable<Name, Impl, error_handling>>(); }
+
+    String getName() const override { return name; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+    size_t getNumberOfArguments() const override { return 1; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        FunctionArgumentDescriptors args
+        {
+            {"readable_size", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, "String"},
+        };
+        validateFunctionArgumentTypes(*this, arguments, args);
+        DataTypePtr return_type = std::make_shared<DataTypeUInt64>();
+        if (error_handling == ErrorHandling::Null)
+            return std::make_shared<DataTypeNullable>(return_type);
+        else
+            return return_type;
+    }
+
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        const auto * col_str = checkAndGetColumn<ColumnString>(arguments[0].column.get());
+        if (!col_str)
+        {
+            throw Exception(
+                ErrorCodes::ILLEGAL_COLUMN,
+                "Illegal column {} of first ('str') argument of function {}. Must be string.",
+                arguments[0].column->getName(),
+                getName()
+            );
+        }
+
+        const ScaleFactors & scale_factors = Impl::getScaleFactors();
+
+        auto col_res = ColumnUInt64::create(input_rows_count);
+
+        ColumnUInt8::MutablePtr col_null_map;
+        if constexpr (error_handling == ErrorHandling::Null)
+            col_null_map = ColumnUInt8::create(input_rows_count, 0);
+
+        auto & res_data = col_res->getData();
+
+        for (size_t i = 0; i < input_rows_count; ++i)
+        {
+            std::string_view value = col_str->getDataAt(i).toView();
+            try
+            {
+                UInt64 num_bytes = parseReadableFormat(scale_factors, value);
+                res_data[i] = num_bytes;
+            }
+            catch (const Exception &)
+            {
+                if constexpr (error_handling == ErrorHandling::Exception)
+                {
+                    throw;
+                }
+                else
+                {
+                    res_data[i] = 0;
+                    if constexpr (error_handling == ErrorHandling::Null)
+                        col_null_map->getData()[i] = 1;
+                }
+            }
+        }
+        if constexpr (error_handling == ErrorHandling::Null)
+            return ColumnNullable::create(std::move(col_res), std::move(col_null_map));
+        else
+            return col_res;
+    }
+
+private:
+
+    UInt64 parseReadableFormat(const ScaleFactors & scale_factors, const std::string_view & value) const
+    {
+        ReadBufferFromString buf(value);
+
+        // tryReadFloatText does seem to not raise any error when there is leading whitespace so we check it explicitly
+        skipWhitespaceIfAny(buf);
+        if (buf.getPosition() > 0)
+        {
+            throw Exception(
+                ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED,
+                "Invalid expression for function {} - Leading whitespace is not allowed (\"{}\")",
+                getName(),
+                value
+            );
+        }
+
+        Float64 base = 0;
+        if (!tryReadFloatTextPrecise(base, buf))    // If we use the default (fast) tryReadFloatText this returns True on garbage input so we use the Precise version
+        {
+            throw Exception(
+                ErrorCodes::CANNOT_PARSE_NUMBER,
+                "Invalid expression for function {} - Unable to parse readable size numeric component (\"{}\")",
+                getName(),
+                value
+            );
+        }
+        else if (std::isnan(base) || !std::isfinite(base))
+        {
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "Invalid expression for function {} - Invalid numeric component: {}",
+                getName(),
+                base
+            );
+        }
+        else if (base < 0)
+        {
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "Invalid expression for function {} - Negative sizes are not allowed ({})",
+                getName(),
+                base
+            );
+        }
+
+        skipWhitespaceIfAny(buf);
+
+        String unit;
+        readStringUntilWhitespace(unit, buf);
+        boost::algorithm::to_lower(unit);
+        auto iter = scale_factors.find(unit);
+        if (iter == scale_factors.end())
+        {
+            throw Exception(
+                ErrorCodes::CANNOT_PARSE_TEXT,
+                "Invalid expression for function {} - Unknown readable size unit (\"{}\")",
+                getName(),
+                unit
+            );
+        }
+        else if (!buf.eof())
+        {
+            throw Exception(
+                ErrorCodes::UNEXPECTED_DATA_AFTER_PARSED_VALUE,
+                "Invalid expression for function {} - Found trailing characters after readable size string (\"{}\")",
+                getName(),
+                value
+            );
+        }
+
+        Float64 num_bytes_with_decimals = base * iter->second;
+        if (num_bytes_with_decimals > std::numeric_limits<UInt64>::max())
+        {
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "Invalid expression for function {} - Result is too big for output type (\"{}\")",
+                getName(),
+                num_bytes_with_decimals
+            );
+        }
+        // As the input might be an arbitrary decimal number we might end up with a non-integer amount of bytes when parsing binary (eg MiB) units.
+        // This doesn't make sense so we round up to indicate the byte size that can fit the passed size.
+        return static_cast<UInt64>(std::ceil(num_bytes_with_decimals));
+    }
+};
+}
diff --git a/src/Functions/fromReadableDecimalSize.cpp b/src/Functions/fromReadableDecimalSize.cpp
new file mode 100644
index 000000000000..6efabe7267d1
--- /dev/null
+++ b/src/Functions/fromReadableDecimalSize.cpp
@@ -0,0 +1,122 @@
+#include <base/types.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/fromReadable.h>
+
+namespace DB
+{
+
+namespace
+{
+
+struct Impl
+{
+    static const ScaleFactors & getScaleFactors()
+    {
+        static const ScaleFactors scale_factors =
+        {
+            {"b", 1ull},
+            {"kb", 1000ull},
+            {"mb", 1000ull * 1000ull},
+            {"gb", 1000ull * 1000ull * 1000ull},
+            {"tb", 1000ull * 1000ull * 1000ull * 1000ull},
+            {"pb", 1000ull * 1000ull * 1000ull * 1000ull * 1000ull},
+            {"eb", 1000ull * 1000ull * 1000ull * 1000ull * 1000ull * 1000ull},
+        };
+
+        return scale_factors;
+    }
+};
+
+struct NameFromReadableDecimalSize
+{
+    static constexpr auto name = "fromReadableDecimalSize";
+};
+
+struct NameFromReadableDecimalSizeOrNull
+{
+    static constexpr auto name = "fromReadableDecimalSizeOrNull";
+};
+
+struct NameFromReadableDecimalSizeOrZero
+{
+    static constexpr auto name = "fromReadableDecimalSizeOrZero";
+};
+
+using FunctionFromReadableDecimalSize = FunctionFromReadable<NameFromReadableDecimalSize, Impl, ErrorHandling::Exception>;
+using FunctionFromReadableDecimalSizeOrNull = FunctionFromReadable<NameFromReadableDecimalSizeOrNull, Impl, ErrorHandling::Null>;
+using FunctionFromReadableDecimalSizeOrZero = FunctionFromReadable<NameFromReadableDecimalSizeOrZero, Impl, ErrorHandling::Zero>;
+
+
+FunctionDocumentation fromReadableDecimalSize_documentation {
+    .description = "Given a string containing a byte size and `B`, `KB`, `MB`, etc. as a unit, this function returns the corresponding number of bytes. If the function is unable to parse the input value, it throws an exception.",
+    .syntax = "fromReadableDecimalSize(x)",
+    .arguments = {{"x", "Readable size with decimal units ([String](../../sql-reference/data-types/string.md))"}},
+    .returned_value = "Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md))",
+    .examples = {
+        {
+            "basic",
+            "SELECT arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB']) AS readable_sizes, fromReadableDecimalSize(readable_sizes) AS sizes;",
+            R"(
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KB           │    1000 │
+│ 3 MB           │ 3000000 │
+│ 5.314 KB       │    5314 │
+└────────────────┴─────────┘)"
+        },
+    },
+    .categories = {"OtherFunctions"},
+};
+
+FunctionDocumentation fromReadableDecimalSizeOrNull_documentation {
+    .description = "Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit, this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `NULL`",
+    .syntax = "fromReadableDecimalSizeOrNull(x)",
+    .arguments = {{"x", "Readable size with decimal units ([String](../../sql-reference/data-types/string.md))"}},
+    .returned_value = "Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md)))",
+    .examples = {
+        {
+            "basic",
+            "SELECT arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes, fromReadableSizeOrNull(readable_sizes) AS sizes;",
+            R"(
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KB           │    1000 │
+│ 3 MB           │ 3000000 │
+│ 5.314 KB       │    5314 │
+│ invalid        │    ᴺᵁᴸᴸ │
+└────────────────┴─────────┘)"
+        },
+    },
+    .categories = {"OtherFunctions"},
+};
+
+FunctionDocumentation fromReadableDecimalSizeOrZero_documentation {
+    .description = "Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit, this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `0`",
+    .syntax = "formatReadableSizeOrZero(x)",
+    .arguments = {{"x", "Readable size with decimal units ([String](../../sql-reference/data-types/string.md))"}},
+    .returned_value = "Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md))",
+    .examples = {
+        {
+            "basic",
+            "SELECT arrayJoin(['1 B', '1 KB', '3 MB', '5.314 KB', 'invalid']) AS readable_sizes, fromReadableSizeOrZero(readable_sizes) AS sizes;",
+            R"(
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KB           │    1000 │
+│ 3 MB           │ 3000000 │
+│ 5.314 KB       │    5000 │
+│ invalid        │       0 │
+└────────────────┴─────────┘)"
+        },
+    },
+    .categories = {"OtherFunctions"},
+};
+}
+
+REGISTER_FUNCTION(FromReadableDecimalSize)
+{
+    factory.registerFunction<FunctionFromReadableDecimalSize>(fromReadableDecimalSize_documentation);
+    factory.registerFunction<FunctionFromReadableDecimalSizeOrNull>(fromReadableDecimalSizeOrNull_documentation);
+    factory.registerFunction<FunctionFromReadableDecimalSizeOrZero>(fromReadableDecimalSizeOrZero_documentation);
+}
+}
diff --git a/src/Functions/fromReadableSize.cpp b/src/Functions/fromReadableSize.cpp
new file mode 100644
index 000000000000..425fb25e0fd1
--- /dev/null
+++ b/src/Functions/fromReadableSize.cpp
@@ -0,0 +1,124 @@
+#include <base/types.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/fromReadable.h>
+#include "Common/FunctionDocumentation.h"
+
+namespace DB
+{
+
+namespace
+{
+
+struct Impl
+{
+    static const ScaleFactors & getScaleFactors()
+    {
+        // ISO/IEC 80000-13 binary units
+        static const ScaleFactors scale_factors =
+        {
+            {"b", 1ull},
+            {"kib", 1024ull},
+            {"mib", 1024ull * 1024ull},
+            {"gib", 1024ull * 1024ull * 1024ull},
+            {"tib", 1024ull * 1024ull * 1024ull * 1024ull},
+            {"pib", 1024ull * 1024ull * 1024ull * 1024ull * 1024ull},
+            {"eib", 1024ull * 1024ull * 1024ull * 1024ull * 1024ull * 1024ull},
+        };
+
+        return scale_factors;
+    }
+};
+
+
+struct NameFromReadableSize
+{
+    static constexpr auto name = "fromReadableSize";
+};
+
+struct NameFromReadableSizeOrNull
+{
+    static constexpr auto name = "fromReadableSizeOrNull";
+};
+
+struct NameFromReadableSizeOrZero
+{
+    static constexpr auto name = "fromReadableSizeOrZero";
+};
+
+using FunctionFromReadableSize = FunctionFromReadable<NameFromReadableSize, Impl, ErrorHandling::Exception>;
+using FunctionFromReadableSizeOrNull = FunctionFromReadable<NameFromReadableSizeOrNull, Impl, ErrorHandling::Null>;
+using FunctionFromReadableSizeOrZero = FunctionFromReadable<NameFromReadableSizeOrZero, Impl, ErrorHandling::Zero>;
+
+FunctionDocumentation fromReadableSize_documentation {
+    .description = "Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it throws an exception.",
+    .syntax = "fromReadableSize(x)",
+    .arguments = {{"x", "Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md))"}},
+    .returned_value = "Number of bytes, rounded up to the nearest integer ([UInt64](../../sql-reference/data-types/int-uint.md))",
+    .examples = {
+        {
+            "basic",
+            "SELECT arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB']) AS readable_sizes, fromReadableSize(readable_sizes) AS sizes;",
+            R"(
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KiB          │    1024 │
+│ 3 MiB          │ 3145728 │
+│ 5.314 KiB      │    5442 │
+└────────────────┴─────────┘)"
+        },
+    },
+    .categories = {"OtherFunctions"},
+};
+
+FunctionDocumentation fromReadableSizeOrNull_documentation {
+    .description = "Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `NULL`",
+    .syntax = "fromReadableSizeOrNull(x)",
+    .arguments = {{"x", "Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md))"}},
+    .returned_value = "Number of bytes, rounded up to the nearest integer, or NULL if unable to parse the input (Nullable([UInt64](../../sql-reference/data-types/int-uint.md)))",
+    .examples = {
+        {
+            "basic",
+            "SELECT arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes, fromReadableSize(readable_sizes) AS sizes;",
+            R"(
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KiB          │    1024 │
+│ 3 MiB          │ 3145728 │
+│ 5.314 KiB      │    5442 │
+│ invalid        │    ᴺᵁᴸᴸ │
+└────────────────┴─────────┘)"
+        },
+    },
+    .categories = {"OtherFunctions"},
+};
+
+FunctionDocumentation fromReadableSizeOrZero_documentation {
+    .description = "Given a string containing a byte size and `B`, `KiB`, `MiB`, etc. as a unit (i.e. [ISO/IEC 80000-13](https://en.wikipedia.org/wiki/ISO/IEC_80000) unit), this function returns the corresponding number of bytes. If the function is unable to parse the input value, it returns `0`",
+    .syntax = "fromReadableSizeOrZero(x)",
+    .arguments = {{"x", "Readable size with ISO/IEC 80000-13 units ([String](../../sql-reference/data-types/string.md))"}},
+    .returned_value = "Number of bytes, rounded up to the nearest integer, or 0 if unable to parse the input ([UInt64](../../sql-reference/data-types/int-uint.md))",
+    .examples = {
+        {
+            "basic",
+            "SELECT arrayJoin(['1 B', '1 KiB', '3 MiB', '5.314 KiB', 'invalid']) AS readable_sizes, fromReadableSize(readable_sizes) AS sizes;",
+            R"(
+┌─readable_sizes─┬───sizes─┐
+│ 1 B            │       1 │
+│ 1 KiB          │    1024 │
+│ 3 MiB          │ 3145728 │
+│ 5.314 KiB      │    5442 │
+│ invalid        │       0 │
+└────────────────┴─────────┘)",
+        },
+    },
+    .categories = {"OtherFunctions"},
+};
+}
+
+REGISTER_FUNCTION(FromReadableSize)
+{
+    factory.registerFunction<FunctionFromReadableSize>(fromReadableSize_documentation);
+    factory.registerFunction<FunctionFromReadableSizeOrNull>(fromReadableSizeOrNull_documentation);
+    factory.registerFunction<FunctionFromReadableSizeOrZero>(fromReadableSizeOrZero_documentation);
+}
+}
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 6df2e4265610..7f54d509da13 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1602,6 +1602,12 @@ freezed
 fromDaysSinceYearZero
 fromModifiedJulianDay
 fromModifiedJulianDayOrNull
+fromReadableSize
+fromReadableSizeOrNull
+fromReadableSizeOrZero
+fromReadableDecimalSize
+fromReadableDecimalSizeOrNull
+fromReadableDecimalSizeOrZero
 fromUTCTimestamp
 fromUnixTimestamp
 fromUnixTimestampInJodaSyntax
