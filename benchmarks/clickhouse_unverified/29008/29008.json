{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 29008,
  "instance_id": "ClickHouse__ClickHouse-29008",
  "issue_numbers": [
    "26980"
  ],
  "base_commit": "4204e20f06850a139db9cd17aac5de592a3dfa44",
  "patch": "diff --git a/src/Interpreters/ColumnAliasesVisitor.cpp b/src/Interpreters/ColumnAliasesVisitor.cpp\nindex 9b7e0a91c181..43a6c4d4cf10 100644\n--- a/src/Interpreters/ColumnAliasesVisitor.cpp\n+++ b/src/Interpreters/ColumnAliasesVisitor.cpp\n@@ -3,7 +3,6 @@\n #include <Interpreters/RequiredSourceColumnsVisitor.h>\n #include <Interpreters/addTypeConversionToAST.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTAlterQuery.h>\n@@ -14,8 +13,11 @@\n namespace DB\n {\n \n-bool ColumnAliasesMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)\n+bool ColumnAliasesMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &, const Data & data)\n {\n+    if (data.excluded_nodes.contains(node.get()))\n+        return false;\n+\n     if (const auto * f = node->as<ASTFunction>())\n     {\n         /// \"lambda\" visits children itself.\ndiff --git a/src/Interpreters/ColumnAliasesVisitor.h b/src/Interpreters/ColumnAliasesVisitor.h\nindex 9be83d83d498..b593842e133d 100644\n--- a/src/Interpreters/ColumnAliasesVisitor.h\n+++ b/src/Interpreters/ColumnAliasesVisitor.h\n@@ -46,7 +46,7 @@ using DataTypePtr = std::shared_ptr<const IDataType>;\n class ColumnAliasesMatcher\n {\n public:\n-    using Visitor = InDepthNodeVisitor<ColumnAliasesMatcher, false>;\n+    using Visitor = InDepthNodeVisitor<ColumnAliasesMatcher, false, true>;\n \n     struct Data\n     {\n@@ -57,14 +57,16 @@ class ColumnAliasesMatcher\n         NameSet array_join_source_columns;\n         ContextPtr context;\n \n+        const std::unordered_set<IAST *> & excluded_nodes;\n+\n         /// private_aliases are from lambda, so these are local names.\n         NameSet private_aliases;\n \n         /// Check if query is changed by this visitor.\n         bool changed = false;\n \n-        Data(const ColumnsDescription & columns_, const NameToNameMap & array_join_result_columns_, ContextPtr context_)\n-            : columns(columns_), context(context_)\n+        Data(const ColumnsDescription & columns_, const NameToNameMap & array_join_result_columns_, ContextPtr context_, const std::unordered_set<IAST *> & excluded_nodes_)\n+            : columns(columns_), context(context_), excluded_nodes(excluded_nodes_)\n         {\n             for (const auto & [result, source] : array_join_result_columns_)\n             {\n@@ -75,7 +77,7 @@ class ColumnAliasesMatcher\n     };\n \n     static void visit(ASTPtr & ast, Data & data);\n-    static bool needChildVisit(const ASTPtr & node, const ASTPtr & child);\n+    static bool needChildVisit(const ASTPtr & node, const ASTPtr & child, const Data & data);\n \n private:\n     static void visit(ASTIdentifier & node, ASTPtr & ast, Data & data);\ndiff --git a/src/Interpreters/InDepthNodeVisitor.h b/src/Interpreters/InDepthNodeVisitor.h\nindex 90235de34b02..b7353f2c2431 100644\n--- a/src/Interpreters/InDepthNodeVisitor.h\n+++ b/src/Interpreters/InDepthNodeVisitor.h\n@@ -10,7 +10,7 @@ namespace DB\n \n /// Visits AST tree in depth, call functions for nodes according to Matcher type data.\n /// You need to define Data, visit() and needChildVisit() in Matcher class.\n-template <typename Matcher, bool _top_to_bottom, typename T = ASTPtr>\n+template <typename Matcher, bool _top_to_bottom, bool need_child_accept_data = false, typename T = ASTPtr>\n class InDepthNodeVisitor\n {\n public:\n@@ -51,13 +51,21 @@ class InDepthNodeVisitor\n     void visitChildren(T & ast)\n     {\n         for (auto & child : ast->children)\n-            if (Matcher::needChildVisit(ast, child))\n+        {\n+            bool need_visit_child = false;\n+            if constexpr (need_child_accept_data)\n+                need_visit_child = Matcher::needChildVisit(ast, child, data);\n+            else\n+                need_visit_child = Matcher::needChildVisit(ast, child);\n+\n+            if (need_visit_child)\n                 visit(child);\n+        }\n     }\n };\n \n-template <typename Matcher, bool top_to_bottom>\n-using ConstInDepthNodeVisitor = InDepthNodeVisitor<Matcher, top_to_bottom, const ASTPtr>;\n+template <typename Matcher, bool top_to_bottom, bool need_child_accept_data = false>\n+using ConstInDepthNodeVisitor = InDepthNodeVisitor<Matcher, top_to_bottom, need_child_accept_data, const ASTPtr>;\n \n struct NeedChild\n {\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 51df6cd022b5..11402e052dca 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -951,16 +951,9 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n     setJoinStrictness(\n         *select_query, settings.join_default_strictness, settings.any_join_distinct_right_table_keys, result.analyzed_join->table_join);\n \n-    if (const auto * join_ast = select_query->join(); join_ast && tables_with_columns.size() >= 2)\n-    {\n-        auto & table_join_ast = join_ast->table_join->as<ASTTableJoin &>();\n-        if (table_join_ast.using_expression_list && result.metadata_snapshot)\n-            replaceAliasColumnsInQuery(table_join_ast.using_expression_list, result.metadata_snapshot->getColumns(), result.array_join_result_to_source, getContext());\n-        if (table_join_ast.on_expression && result.metadata_snapshot)\n-            replaceAliasColumnsInQuery(table_join_ast.on_expression, result.metadata_snapshot->getColumns(), result.array_join_result_to_source, getContext());\n-\n-        collectJoinedColumns(*result.analyzed_join, table_join_ast, tables_with_columns, result.aliases);\n-    }\n+    auto * table_join_ast = select_query->join() ? select_query->join()->table_join->as<ASTTableJoin>() : nullptr;\n+    if (table_join_ast && tables_with_columns.size() >= 2)\n+        collectJoinedColumns(*result.analyzed_join, *table_join_ast, tables_with_columns, result.aliases);\n \n     result.aggregates = getAggregates(query, *select_query);\n     result.window_function_asts = getWindowFunctions(query, *select_query);\n@@ -971,8 +964,19 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n     bool is_initiator = getContext()->getClientInfo().distributed_depth == 0;\n     if (settings.optimize_respect_aliases && result.metadata_snapshot && is_initiator)\n     {\n+        std::unordered_set<IAST *> excluded_nodes;\n+        {\n+            /// Do not replace ALIASed columns in JOIN ON/USING sections\n+            if (table_join_ast && table_join_ast->on_expression)\n+                excluded_nodes.insert(table_join_ast->on_expression.get());\n+            if (table_join_ast && table_join_ast->using_expression_list)\n+                excluded_nodes.insert(table_join_ast->using_expression_list.get());\n+        }\n+\n+        bool is_changed = replaceAliasColumnsInQuery(query, result.metadata_snapshot->getColumns(),\n+                                                     result.array_join_result_to_source, getContext(), excluded_nodes);\n         /// If query is changed, we need to redo some work to correct name resolution.\n-        if (replaceAliasColumnsInQuery(query, result.metadata_snapshot->getColumns(), result.array_join_result_to_source, getContext()))\n+        if (is_changed)\n         {\n             result.aggregates = getAggregates(query, *select_query);\n             result.window_function_asts = getWindowFunctions(query, *select_query);\ndiff --git a/src/Interpreters/replaceAliasColumnsInQuery.cpp b/src/Interpreters/replaceAliasColumnsInQuery.cpp\nindex 604ba3590ae7..fc6a97e2039a 100644\n--- a/src/Interpreters/replaceAliasColumnsInQuery.cpp\n+++ b/src/Interpreters/replaceAliasColumnsInQuery.cpp\n@@ -7,9 +7,13 @@ namespace DB\n {\n \n bool replaceAliasColumnsInQuery(\n-    ASTPtr & ast, const ColumnsDescription & columns, const NameToNameMap & array_join_result_to_source, ContextPtr context)\n+        ASTPtr & ast,\n+        const ColumnsDescription & columns,\n+        const NameToNameMap & array_join_result_to_source,\n+        ContextPtr context,\n+        const std::unordered_set<IAST *> & excluded_nodes)\n {\n-    ColumnAliasesVisitor::Data aliases_column_data(columns, array_join_result_to_source, context);\n+    ColumnAliasesVisitor::Data aliases_column_data(columns, array_join_result_to_source, context, excluded_nodes);\n     ColumnAliasesVisitor aliases_column_visitor(aliases_column_data);\n     aliases_column_visitor.visit(ast);\n     return aliases_column_data.changed;\ndiff --git a/src/Interpreters/replaceAliasColumnsInQuery.h b/src/Interpreters/replaceAliasColumnsInQuery.h\nindex 5d9207ad11b2..7f5fee3b14b0 100644\n--- a/src/Interpreters/replaceAliasColumnsInQuery.h\n+++ b/src/Interpreters/replaceAliasColumnsInQuery.h\n@@ -12,6 +12,10 @@ class ColumnsDescription;\n \n /// Replace storage alias columns in select query if possible. Return true if the query is changed.\n bool replaceAliasColumnsInQuery(\n-    ASTPtr & ast, const ColumnsDescription & columns, const NameToNameMap & array_join_result_to_source, ContextPtr context);\n+        ASTPtr & ast,\n+        const ColumnsDescription & columns,\n+        const NameToNameMap & array_join_result_to_source,\n+        ContextPtr context,\n+        const std::unordered_set<IAST *> & excluded_nodes = {});\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01925_join_materialized_columns.reference b/tests/queries/0_stateless/01925_join_materialized_columns.reference\nindex 1dfda3c769b1..5125b322aed4 100644\n--- a/tests/queries/0_stateless/01925_join_materialized_columns.reference\n+++ b/tests/queries/0_stateless/01925_join_materialized_columns.reference\n@@ -22,3 +22,13 @@ fact1t1_val1\tfact1t2_val2\n fact2t1_val2\tfact2t1_val2\n -\n 2020-02-02 13:00:00\t2020-02-05 13:00:00\n+-\n+1\n+1\n+1\n+1\n+-\n+2020-01-01 12:00:00\n+2020-01-01 12:00:00\n+2020-01-01 12:00:00\n+2020-01-01 12:00:00\ndiff --git a/tests/queries/0_stateless/01925_join_materialized_columns.sql b/tests/queries/0_stateless/01925_join_materialized_columns.sql\nindex 6a34fef96ab5..7c56d5fea39c 100644\n--- a/tests/queries/0_stateless/01925_join_materialized_columns.sql\n+++ b/tests/queries/0_stateless/01925_join_materialized_columns.sql\n@@ -2,17 +2,23 @@ DROP TABLE IF EXISTS t1;\n DROP TABLE IF EXISTS t2;\n \n CREATE TABLE t1 (\n-    time DateTime, foo String, dimension_1 String,\n+    time DateTime,\n+    foo String,\n+    dimension_1 String,\n     dt Date MATERIALIZED toDate(time),\n     dt1 Date MATERIALIZED toDayOfYear(time),\n-    aliascol1 ALIAS foo || dimension_1\n+    aliascol1 ALIAS foo || dimension_1,\n+    time_alias DateTime ALIAS time\n ) ENGINE = MergeTree() PARTITION BY toYYYYMM(dt) ORDER BY (dt, foo);\n \n CREATE TABLE t2 (\n-    time DateTime, bar String, dimension_2 String, \n+    time DateTime,\n+    bar String,\n+    dimension_2 String,\n     dt Date MATERIALIZED toDate(time),\n     dt2 Date MATERIALIZED toDayOfYear(time),\n-    aliascol2 ALIAS bar || dimension_2\n+    aliascol2 ALIAS bar || dimension_2,\n+    time_alias DateTime ALIAS time\n ) ENGINE = MergeTree() PARTITION BY toYYYYMM(dt) ORDER BY (dt, bar);\n \n INSERT INTO t1 VALUES ('2020-01-01 12:00:00', 'fact1', 't1_val1'), ('2020-02-02 13:00:00', 'fact2', 't1_val2'), ('2020-01-01 13:00:00', 'fact3', 't1_val3');\n@@ -35,3 +41,15 @@ SELECT '-';\n SELECT t1.aliascol1, t2.aliascol2 FROM t1 JOIN t2 ON t1.foo = t2.bar ORDER BY t1.time, t2.time;\n SELECT '-';\n SELECT t1.time, t2.time FROM t1 JOIN t2 ON t1.aliascol1 = t2.aliascol2 ORDER BY t1.time, t2.time;\n+SELECT '-';\n+SELECT count() FROM t1 JOIN t2 ON t1.time_alias = t2.time;\n+SELECT count() FROM t1 JOIN t2 ON t1.time = t2.time_alias;\n+SELECT count() FROM t1 JOIN t2 ON t1.time_alias = t2.time_alias;\n+SELECT count() FROM t1 JOIN t2 USING (time_alias);\n+SELECT '-';\n+SELECT t1.time as talias FROM t1 JOIN t2 ON talias = t2.time;\n+SELECT t1.time as talias FROM t1 JOIN t2 ON talias = t2.time_alias;\n+SELECT t2.time as talias FROM t1 JOIN t2 ON t1.time = talias;\n+SELECT t2.time as talias FROM t1 JOIN t2 ON t1.time_alias = talias;\n+SELECT time as talias FROM t1 JOIN t2 ON t1.time = talias; -- { serverError AMBIGUOUS_COLUMN_NAME }\n+SELECT time as talias FROM t1 JOIN t2 ON talias = t2.time; -- { serverError AMBIGUOUS_COLUMN_NAME }\n",
  "problem_statement": "\"Not found column ... in block\" error, when join on alias column\n**Describe the bug**\r\n\r\n\"Not found column ... in block\" error, when join on alias column.\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nCREATE TABLE a (\r\n    id UInt32,\r\n    value UInt32,\r\n    id_alias UInt32 ALIAS id    \r\n) ENGINE = MergeTree() ORDER BY id;\r\n\r\nCREATE TABLE b (\r\n    id UInt32,\r\n    value UInt32\r\n) ENGINE = MergeTree() ORDER BY id;\r\n\r\nINSERT INTO a VALUES (1, 1), (2, 2), (3, 3);\r\nINSERT INTO b VALUES (1, 4), (2, 5), (3, 6);\r\n\r\nSELECT * FROM a JOIN b ON a.id_alias = b.id;\r\n```\r\n\r\n**Expected behavior**\r\n\r\nIn version 21.5.9.4 result is:\r\n\r\nid | value | b.id | b.value\r\n-- | -------- | ----- | ----------\r\n1 |  1 | 1 | 4 \r\n2 | 2 | 2 | 5 \r\n3 | 3 | 3 | 6 \r\n\r\n**Error message and/or stacktrace**\r\n\r\nIn version 21.7.5.29 result is:\r\n```\r\nSQL Error [10]: ClickHouse exception, code: 10, host: 127.0.0.1, port: 14343; Code: 10, e.displayText() = DB::Exception: Not found column id_alias in block. There are only columns: id, value (version 21.7.5.29 (official build))\r\n```\n",
  "hints_text": "(version 21.9.1):\r\nCode: 352. DB::Exception: Received from localhost:9000. \r\nDB::Exception: Column 'id' is ambiguous: While processing (id AS id_alias) = b.id. (AMBIGUOUS_COLUMN_NAME)",
  "created_at": "2021-09-14T10:08:45Z",
  "modified_files": [
    "src/Interpreters/ColumnAliasesVisitor.cpp",
    "src/Interpreters/ColumnAliasesVisitor.h",
    "src/Interpreters/InDepthNodeVisitor.h",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/replaceAliasColumnsInQuery.cpp",
    "src/Interpreters/replaceAliasColumnsInQuery.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01925_join_materialized_columns.reference",
    "tests/queries/0_stateless/01925_join_materialized_columns.sql"
  ]
}