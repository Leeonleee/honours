diff --git a/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp b/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp
index 42777d0bbbab..fda3a6ee1c89 100644
--- a/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp
+++ b/src/Common/tests/gtest_makeRegexpPatternFromGlobs.cpp
@@ -8,14 +8,36 @@ using namespace DB;
 
 TEST(Common, makeRegexpPatternFromGlobs)
 {
+
     EXPECT_EQ(makeRegexpPatternFromGlobs("?"), "[^/]");
     EXPECT_EQ(makeRegexpPatternFromGlobs("*"), "[^/]*");
     EXPECT_EQ(makeRegexpPatternFromGlobs("/?"), "/[^/]");
     EXPECT_EQ(makeRegexpPatternFromGlobs("/*"), "/[^/]*");
     EXPECT_EQ(makeRegexpPatternFromGlobs("*_{{a,b,c,d}}/?.csv"), "[^/]*_\\{(a|b|c|d)\\}/[^/]\\.csv");
-    EXPECT_EQ(makeRegexpPatternFromGlobs("f{01..09}"), "f(1|2|3|4|5|6|7|8|9)");
-    EXPECT_EQ(makeRegexpPatternFromGlobs("f{01..9}"), "f(1|2|3|4|5|6|7|8|9)");
-    EXPECT_EQ(makeRegexpPatternFromGlobs("f{0001..0000009}"), "f(1|2|3|4|5|6|7|8|9)");
+    /* Regex Parsing for {..} can have three possible cases
+       1) The left range width == the right range width
+       2) The left range width > the right range width
+       3) The left range width < the right range width
+    */
+    // Ascending Sequences
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{1..9}"), "f(1|2|3|4|5|6|7|8|9)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{0..10}"), "f(0|1|2|3|4|5|6|7|8|9|10)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{10..20}"), "f(10|11|12|13|14|15|16|17|18|19|20)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{00..10}"), "f(00|01|02|03|04|05|06|07|08|09|10)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{0001..0009}"), "f(0001|0002|0003|0004|0005|0006|0007|0008|0009)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{01..9}"), "f(01|02|03|04|05|06|07|08|09)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{000..9}"), "f(000|001|002|003|004|005|006|007|008|009)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{95..103}"), "f(95|96|97|98|99|100|101|102|103)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{99..109}"), "f(99|100|101|102|103|104|105|106|107|108|109)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{001..0009}"), "f(0001|0002|0003|0004|0005|0006|0007|0008|0009)");
+    // Descending Sequences
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{20..15}"), "f(15|16|17|18|19|20)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{200..199}"), "f(199|200)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{0009..0001}"), "f(0001|0002|0003|0004|0005|0006|0007|0008|0009)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{100..90}"), "f(90|91|92|93|94|95|96|97|98|99|100)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{103..95}"), "f(95|96|97|98|99|100|101|102|103)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{9..01}"), "f(01|02|03|04|05|06|07|08|09)");
+    EXPECT_EQ(makeRegexpPatternFromGlobs("f{9..000}"), "f(000|001|002|003|004|005|006|007|008|009)");
     EXPECT_EQ(makeRegexpPatternFromGlobs("f{1..2}{1..2}"), "f(1|2)(1|2)");
     EXPECT_EQ(makeRegexpPatternFromGlobs("f{1..1}{1..1}"), "f(1)(1)");
     EXPECT_EQ(makeRegexpPatternFromGlobs("f{0..0}{0..0}"), "f(0)(0)");
diff --git a/tests/queries/0_stateless/02297_regex_parsing_file_names.reference b/tests/queries/0_stateless/02297_regex_parsing_file_names.reference
new file mode 100644
index 000000000000..b4de39476753
--- /dev/null
+++ b/tests/queries/0_stateless/02297_regex_parsing_file_names.reference
@@ -0,0 +1,1 @@
+11
diff --git a/tests/queries/0_stateless/02297_regex_parsing_file_names.sh b/tests/queries/0_stateless/02297_regex_parsing_file_names.sh
new file mode 100755
index 000000000000..12ccb54235be
--- /dev/null
+++ b/tests/queries/0_stateless/02297_regex_parsing_file_names.sh
@@ -0,0 +1,40 @@
+#!/usr/bin/env bash
+# Tags: no-parallel
+
+CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
+# shellcheck source=../shell_config.sh
+. "$CURDIR"/../shell_config.sh
+
+# Data preparation.
+
+# Now we can get the user_files_path by use the table file function for trick. also we can get it by query as:
+#  "insert into function file('exist.txt', 'CSV', 'val1 char') values ('aaaa'); select _path from file('exist.txt', 'CSV', 'val1 char')"
+CLICKHOUSE_USER_FILES_PATH=$(clickhouse-client --query "select _path, _file from file('nonexist.txt', 'CSV', 'val1 char')" 2>&1 | grep Exception | awk '{gsub("/nonexist.txt","",$9); print $9}')
+
+mkdir -p ${CLICKHOUSE_USER_FILES_PATH}/
+
+rm -rf ${CLICKHOUSE_USER_FILES_PATH}/file_{0..10}.csv
+
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_0.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_1.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_2.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_3.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_4.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_5.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_6.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_7.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_8.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_9.csv
+echo '0' > ${CLICKHOUSE_USER_FILES_PATH}/file_10.csv
+
+# echo '' > ${CLICKHOUSE_USER_FILES_PATH}/file_10.csv
+
+${CLICKHOUSE_CLIENT} -q "DROP TABLE IF EXISTS t_regex;"
+
+${CLICKHOUSE_CLIENT} -q "CREATE TABLE t_regex (id UInt64) ENGINE = MergeTree() order by id;"
+
+${CLICKHOUSE_CLIENT} -q "INSERT INTO t_regex SELECT * FROM file('file_{0..10}.csv','CSV');"
+${CLICKHOUSE_CLIENT} -q "SELECT count() from t_regex;"
+
+rm -rf ${CLICKHOUSE_USER_FILES_PATH}/file_{0..10}.csv;
+${CLICKHOUSE_CLIENT} -q "DROP TABLE IF EXISTS t_regex;"
