{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7156,
  "instance_id": "ClickHouse__ClickHouse-7156",
  "issue_numbers": [
    "7100"
  ],
  "base_commit": "ff02f1345d260241979fc80d8b4c9f794a0cd469",
  "patch": "diff --git a/dbms/src/Functions/now.cpp b/dbms/src/Functions/now.cpp\nindex 59501d96088d..accef94e5894 100644\n--- a/dbms/src/Functions/now.cpp\n+++ b/dbms/src/Functions/now.cpp\n@@ -5,40 +5,81 @@\n \n \n namespace DB\n-{\n \n+{\n /// Get the current time. (It is a constant, it is evaluated once for the entire query.)\n-class FunctionNow : public IFunction\n+\n+class PreparedFunctionNow : public PreparedFunctionImpl\n {\n public:\n-    static constexpr auto name = \"now\";\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionNow>(); }\n+    explicit PreparedFunctionNow(time_t time_) : time_value(time_) {}\n \n-    String getName() const override\n+    String getName() const override { return \"now\"; }\n+\n+protected:\n+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n     {\n-        return name;\n+        block.getByPosition(result).column = DataTypeDateTime().createColumnConst(\n+                input_rows_count,\n+                static_cast<UInt64>(time_value));\n     }\n \n-    size_t getNumberOfArguments() const override { return 0; }\n+private:\n+    time_t time_value;\n+};\n+\n+class FunctionBaseNow : public IFunctionBase\n+{\n+public:\n+    explicit FunctionBaseNow(time_t time_) : time_value(time_), return_type(std::make_shared<DataTypeDateTime>()) {}\n+\n+    String getName() const override { return \"now\"; }\n+\n+    const DataTypes & getArgumentTypes() const override\n+    {\n+        static const DataTypes argument_types;\n+        return argument_types;\n+    }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override\n+    const DataTypePtr & getReturnType() const override\n     {\n-        return std::make_shared<DataTypeDateTime>();\n+        return return_type;\n+    }\n+\n+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override\n+    {\n+        return std::make_shared<PreparedFunctionNow>(time_value);\n     }\n \n     bool isDeterministic() const override { return false; }\n \n-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n+private:\n+    time_t time_value;\n+    DataTypePtr return_type;\n+};\n+\n+class FunctionBuilderNow : public FunctionBuilderImpl\n+{\n+public:\n+    static constexpr auto name = \"now\";\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderNow>(); }\n+\n+protected:\n+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeDateTime>(); }\n+\n+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName &, const DataTypePtr &) const override\n     {\n-        block.getByPosition(result).column = DataTypeDateTime().createColumnConst(\n-            input_rows_count,\n-            static_cast<UInt64>(time(nullptr)));\n+        return std::make_shared<FunctionBaseNow>(time(nullptr));\n     }\n };\n \n void registerFunctionNow(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionNow>(FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<FunctionBuilderNow>(FunctionFactory::CaseInsensitive);\n }\n \n }\ndiff --git a/dbms/src/Functions/randConstant.cpp b/dbms/src/Functions/randConstant.cpp\nindex 91df7a1dfb89..e854484154c1 100644\n--- a/dbms/src/Functions/randConstant.cpp\n+++ b/dbms/src/Functions/randConstant.cpp\n@@ -6,55 +6,105 @@ namespace DB\n {\n \n template <typename ToType, typename Name>\n-class FunctionRandomConstant : public IFunction\n+class PreparedFunctionRandomConstant : public PreparedFunctionImpl\n {\n+public:\n+    explicit PreparedFunctionRandomConstant(ToType value_) : value(value_) {}\n+\n+    String getName() const override { return Name::name; }\n+\n+protected:\n+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n+    {\n+        block.getByPosition(result).column = DataTypeNumber<ToType>().createColumnConst(input_rows_count, value);\n+    }\n+\n private:\n-    /// The value is one for different blocks.\n-    bool is_initialized = false;\n     ToType value;\n+};\n \n+template <typename ToType, typename Name>\n+class FunctionBaseRandomConstant : public IFunctionBase\n+{\n public:\n-    static constexpr auto name = Name::name;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionRandomConstant>(); }\n+    explicit FunctionBaseRandomConstant(ToType value_, DataTypes argument_types_)\n+        : value(value_)\n+        , argument_types(std::move(argument_types_))\n+        , return_type(std::make_shared<DataTypeNumber<ToType>>()) {}\n+\n+    String getName() const override { return Name::name; }\n+\n+    const DataTypes & getArgumentTypes() const override\n+    {\n+        return argument_types;\n+    }\n+\n+    const DataTypePtr & getReturnType() const override\n+    {\n+        return return_type;\n+    }\n \n-    String getName() const override\n+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override\n     {\n-        return name;\n+        return std::make_shared<PreparedFunctionRandomConstant<ToType, Name>>(value);\n     }\n \n+    bool isDeterministic() const override { return false; }\n+\n+private:\n+    ToType value;\n+    DataTypes argument_types;\n+    DataTypePtr return_type;\n+};\n+\n+template <typename ToType, typename Name>\n+class FunctionBuilderRandomConstant : public FunctionBuilderImpl\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    String getName() const override { return name; }\n+\n     bool isVariadic() const override { return true; }\n     size_t getNumberOfArguments() const override { return 0; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    void checkNumberOfArguments(size_t number_of_arguments) const override\n     {\n-        if (arguments.size() > 1)\n+        if (number_of_arguments > 1)\n             throw Exception(\"Number of arguments for function \" + getName() + \" doesn't match: passed \"\n-                + toString(arguments.size()) + \", should be 0 or 1.\",\n-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+                            + toString(number_of_arguments) + \", should be 0 or 1.\",\n+                            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+    }\n \n-        return std::make_shared<DataTypeNumber<ToType>>();\n+    static FunctionBuilderPtr create(const Context &)\n+    {\n+        return std::make_shared<FunctionBuilderRandomConstant<ToType, Name>>();\n     }\n \n-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n+protected:\n+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeNumber<ToType>>(); }\n+\n+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &) const override\n     {\n-        if (!is_initialized)\n-        {\n-            is_initialized = true;\n-            typename ColumnVector<ToType>::Container vec_to(1);\n-            RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), sizeof(ToType));\n-            value = vec_to[0];\n-        }\n-\n-        block.getByPosition(result).column = DataTypeNumber<ToType>().createColumnConst(input_rows_count, toField(value));\n+        DataTypes argument_types;\n+\n+        if (!arguments.empty())\n+            argument_types.emplace_back(arguments.back().type);\n+\n+        typename ColumnVector<ToType>::Container vec_to(1);\n+        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), sizeof(ToType));\n+        ToType value = vec_to[0];\n+\n+        return std::make_shared<FunctionBaseRandomConstant<ToType, Name>>(value, argument_types);\n     }\n };\n \n+\n struct NameRandConstant { static constexpr auto name = \"randConstant\"; };\n-using FunctionRandConstant = FunctionRandomConstant<UInt32, NameRandConstant>;\n+using FunctionBuilderRandConstant = FunctionBuilderRandomConstant<UInt32, NameRandConstant>;\n \n void registerFunctionRandConstant(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionRandConstant>();\n+    factory.registerFunction<FunctionBuilderRandConstant>();\n }\n \n }\ndiff --git a/dbms/src/Functions/today.cpp b/dbms/src/Functions/today.cpp\nindex c74bc0002926..d7eb684996fb 100644\n--- a/dbms/src/Functions/today.cpp\n+++ b/dbms/src/Functions/today.cpp\n@@ -9,37 +9,75 @@\n namespace DB\n {\n \n-class FunctionToday : public IFunction\n+class PreparedFunctionToday : public PreparedFunctionImpl\n {\n public:\n-    static constexpr auto name = \"today\";\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionToday>(); }\n+    explicit PreparedFunctionToday(time_t time_) : day_value(time_) {}\n+\n+    String getName() const override { return \"today\"; }\n \n-    String getName() const override\n+protected:\n+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n     {\n-        return name;\n+        block.getByPosition(result).column = DataTypeDate().createColumnConst(input_rows_count, day_value);\n     }\n \n-    size_t getNumberOfArguments() const override { return 0; }\n+private:\n+    DayNum day_value;\n+};\n+\n+class FunctionBaseToday : public IFunctionBase\n+{\n+public:\n+    explicit FunctionBaseToday(DayNum day_value_) : day_value(day_value_), return_type(std::make_shared<DataTypeDate>()) {}\n+\n+    String getName() const override { return \"today\"; }\n+\n+    const DataTypes & getArgumentTypes() const override\n+    {\n+        static const DataTypes argument_types;\n+        return argument_types;\n+    }\n+\n+    const DataTypePtr & getReturnType() const override\n+    {\n+        return return_type;\n+    }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override\n+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override\n     {\n-        return std::make_shared<DataTypeDate>();\n+        return std::make_shared<PreparedFunctionToday>(day_value);\n     }\n \n     bool isDeterministic() const override { return false; }\n \n-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n+private:\n+    DayNum day_value;\n+    DataTypePtr return_type;\n+};\n+\n+class FunctionBuilderToday : public FunctionBuilderImpl\n+{\n+public:\n+    static constexpr auto name = \"today\";\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderToday>(); }\n+\n+protected:\n+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeDate>(); }\n+\n+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName &, const DataTypePtr &) const override\n     {\n-        block.getByPosition(result).column = DataTypeDate().createColumnConst(\n-            input_rows_count,\n-            DateLUT::instance().toDayNum(time(nullptr)));\n+        return std::make_shared<FunctionBaseToday>(DateLUT::instance().toDayNum(time(nullptr)));\n     }\n };\n \n void registerFunctionToday(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionToday>();\n+    factory.registerFunction<FunctionBuilderToday>();\n }\n \n }\ndiff --git a/dbms/src/Functions/yesterday.cpp b/dbms/src/Functions/yesterday.cpp\nindex 393a3a453612..e08c21978364 100644\n--- a/dbms/src/Functions/yesterday.cpp\n+++ b/dbms/src/Functions/yesterday.cpp\n@@ -9,37 +9,76 @@\n namespace DB\n {\n \n-class FunctionYesterday : public IFunction\n+class PreparedFunctionYesterday : public PreparedFunctionImpl\n {\n public:\n-    static constexpr auto name = \"yesterday\";\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionYesterday>(); }\n+    explicit PreparedFunctionYesterday(time_t time_) : day_value(time_) {}\n+\n+    String getName() const override { return \"yesterday\"; }\n \n-    String getName() const override\n+protected:\n+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n     {\n-        return name;\n+        block.getByPosition(result).column = DataTypeDate().createColumnConst(input_rows_count, day_value);\n     }\n \n-    size_t getNumberOfArguments() const override { return 0; }\n+private:\n+    DayNum day_value;\n+};\n+\n+class FunctionBaseYesterday : public IFunctionBase\n+{\n+public:\n+    explicit FunctionBaseYesterday(DayNum day_value_) : day_value(day_value_), return_type(std::make_shared<DataTypeDate>()) {}\n+\n+    String getName() const override { return \"yesterday\"; }\n+\n+    const DataTypes & getArgumentTypes() const override\n+    {\n+        static const DataTypes argument_types;\n+        return argument_types;\n+    }\n+\n+    const DataTypePtr & getReturnType() const override\n+    {\n+        return return_type;\n+    }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override\n+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override\n     {\n-        return std::make_shared<DataTypeDate>();\n+        return std::make_shared<PreparedFunctionYesterday>(day_value);\n     }\n \n     bool isDeterministic() const override { return false; }\n \n-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override\n+private:\n+    DayNum day_value;\n+    DataTypePtr return_type;\n+};\n+\n+class FunctionBuilderYesterday : public FunctionBuilderImpl\n+{\n+public:\n+    static constexpr auto name = \"yesterday\";\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderYesterday>(); }\n+\n+protected:\n+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeDate>(); }\n+\n+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName &, const DataTypePtr &) const override\n     {\n-        block.getByPosition(result).column = DataTypeDate().createColumnConst(\n-            input_rows_count,\n-            DateLUT::instance().toDayNum(time(nullptr)) - 1);\n+        auto day_num = DateLUT::instance().toDayNum(time(nullptr)) - 1;\n+        return std::make_shared<FunctionBaseYesterday>(static_cast<DayNum>(day_num));\n     }\n };\n \n void registerFunctionYesterday(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionYesterday>();\n+    factory.registerFunction<FunctionBuilderYesterday>();\n }\n \n }\ndiff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\nindex 50f5e3a0b4b6..14849763ef3c 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -589,6 +589,19 @@ bool SelectQueryExpressionAnalyzer::appendPrewhere(\n     return true;\n }\n \n+void SelectQueryExpressionAnalyzer::appendPreliminaryFilter(ExpressionActionsChain & chain, ExpressionActionsPtr actions, String column_name)\n+{\n+    initChain(chain, sourceColumns());\n+    ExpressionActionsChain::Step & step = chain.steps.back();\n+\n+    // FIXME: assert(filter_info);\n+    step.actions = std::move(actions);\n+    step.required_output.push_back(std::move(column_name));\n+    step.can_remove_required_output = {true};\n+\n+    chain.addStep();\n+}\n+\n bool SelectQueryExpressionAnalyzer::appendWhere(ExpressionActionsChain & chain, bool only_types)\n {\n     const auto * select_query = getSelectQuery();\ndiff --git a/dbms/src/Interpreters/ExpressionAnalyzer.h b/dbms/src/Interpreters/ExpressionAnalyzer.h\nindex 2dfc8909d024..aac801fbd4c6 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.h\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.h\n@@ -189,6 +189,8 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n     /// Before aggregation:\n     bool appendArrayJoin(ExpressionActionsChain & chain, bool only_types);\n     bool appendJoin(ExpressionActionsChain & chain, bool only_types);\n+    /// Add preliminary rows filtration. Actions are created in other expression analyzer to prevent any possible alias injection.\n+    void appendPreliminaryFilter(ExpressionActionsChain & chain, ExpressionActionsPtr actions, String column_name);\n     /// remove_filter is set in ExpressionActionsChain::finalize();\n     /// Columns in `additional_required_columns` will not be removed (they can be used for e.g. sampling or FINAL modifier).\n     bool appendPrewhere(ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns);\ndiff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\nindex 8c49cf34ca52..7d1a3b42737e 100644\n--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -113,7 +113,7 @@ namespace ErrorCodes\n namespace\n {\n \n-/// Assumes `storage` is set and the table filter is not empty.\n+/// Assumes `storage` is set and the table filter (row-level security) is not empty.\n String generateFilterActions(ExpressionActionsPtr & actions, const StoragePtr & storage, const Context & context, const Names & prerequisite_columns = {})\n {\n     const auto & db_name = storage->getDatabaseName();\n@@ -350,8 +350,18 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n     required_columns = syntax_analyzer_result->requiredSourceColumns();\n \n     if (storage)\n+    {\n         source_header = storage->getSampleBlockForColumns(required_columns);\n \n+        /// Fix source_header for filter actions.\n+        if (context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), \"filter\"))\n+        {\n+            filter_info = std::make_shared<FilterInfo>();\n+            filter_info->column_name = generateFilterActions(filter_info->actions, storage, context, required_columns);\n+            source_header = storage->getSampleBlockForColumns(filter_info->actions->getRequiredColumns());\n+        }\n+    }\n+\n     /// Calculate structure of the result.\n     result_header = getSampleBlockImpl();\n     for (auto & col : result_header)\n@@ -419,19 +429,47 @@ QueryPipeline InterpreterSelectQuery::executeWithProcessors()\n \n Block InterpreterSelectQuery::getSampleBlockImpl()\n {\n-    /// Need to create sets before analyzeExpressions(). Otherwise some sets for index won't be created.\n-    query_analyzer->makeSetsForIndex(getSelectQuery().where());\n-    query_analyzer->makeSetsForIndex(getSelectQuery().prewhere());\n+    auto & query = getSelectQuery();\n+    const Settings & settings = context.getSettingsRef();\n \n-    auto analysis_result = analyzeExpressions(\n+    /// Do all AST changes here, because actions from analysis_result will be used later in readImpl.\n+\n+    /// PREWHERE optimization.\n+    /// Turn off, if the table filter (row-level security) is applied.\n+    if (storage && !context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), \"filter\"))\n+    {\n+        query_analyzer->makeSetsForIndex(query.where());\n+        query_analyzer->makeSetsForIndex(query.prewhere());\n+\n+        auto optimize_prewhere = [&](auto & merge_tree)\n+        {\n+            SelectQueryInfo current_info;\n+            current_info.query = query_ptr;\n+            current_info.syntax_analyzer_result = syntax_analyzer_result;\n+            current_info.sets = query_analyzer->getPreparedSets();\n+\n+            /// Try transferring some condition from WHERE to PREWHERE if enabled and viable\n+            if (settings.optimize_move_to_prewhere && query.where() && !query.prewhere() && !query.final())\n+                MergeTreeWhereOptimizer{current_info, context, merge_tree,\n+                                        syntax_analyzer_result->requiredSourceColumns(), log};\n+        };\n+\n+        if (const auto * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))\n+            optimize_prewhere(*merge_tree_data);\n+    }\n+\n+    if (storage && !options.only_analyze)\n+        from_stage = storage->getQueryProcessingStage(context);\n+\n+    analysis_result = analyzeExpressions(\n             getSelectQuery(),\n             *query_analyzer,\n-            QueryProcessingStage::Enum::FetchColumns,\n+            from_stage,\n             options.to_stage,\n             context,\n             storage,\n-            true,  // only_types\n-            {}     // filter_info\n+            options.only_analyze,\n+            filter_info\n         );\n \n     if (options.to_stage == QueryProcessingStage::Enum::FetchColumns)\n@@ -574,21 +612,8 @@ InterpreterSelectQuery::analyzeExpressions(\n         if (storage && filter_info)\n         {\n             has_filter = true;\n-\n-            /// XXX: aggregated copy-paste from ExpressionAnalyzer::appendSmth()\n-            if (chain.steps.empty())\n-            {\n-                chain.steps.emplace_back(std::make_shared<ExpressionActions>(NamesAndTypesList(), context));\n-            }\n-            ExpressionActionsChain::Step & step = chain.steps.back();\n-\n-            // FIXME: assert(filter_info);\n             res.filter_info = filter_info;\n-            step.actions = filter_info->actions;\n-            step.required_output.push_back(res.filter_info->column_name);\n-            step.can_remove_required_output = {true};\n-\n-            chain.addStep();\n+            query_analyzer.appendPreliminaryFilter(chain, filter_info->actions, filter_info->column_name);\n         }\n \n         if (query_analyzer.appendPrewhere(chain, !res.first_stage, additional_required_columns_after_prewhere))\n@@ -909,50 +934,12 @@ void InterpreterSelectQuery::executeImpl(TPipeline & pipeline, const BlockInputS\n     /// Now we will compose block streams that perform the necessary actions.\n     auto & query = getSelectQuery();\n     const Settings & settings = context.getSettingsRef();\n-\n-    QueryProcessingStage::Enum from_stage = QueryProcessingStage::FetchColumns;\n-\n-    /// PREWHERE optimization\n-    /// Turn off, if the table filter is applied.\n-    if (storage && !context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), \"filter\"))\n-    {\n-        if (!options.only_analyze)\n-            from_stage = storage->getQueryProcessingStage(context);\n-\n-        query_analyzer->makeSetsForIndex(query.where());\n-        query_analyzer->makeSetsForIndex(query.prewhere());\n-\n-        auto optimize_prewhere = [&](auto & merge_tree)\n-        {\n-            SelectQueryInfo current_info;\n-            current_info.query = query_ptr;\n-            current_info.syntax_analyzer_result = syntax_analyzer_result;\n-            current_info.sets = query_analyzer->getPreparedSets();\n-\n-            /// Try transferring some condition from WHERE to PREWHERE if enabled and viable\n-            if (settings.optimize_move_to_prewhere && query.where() && !query.prewhere() && !query.final())\n-                MergeTreeWhereOptimizer{current_info, context, merge_tree, syntax_analyzer_result->requiredSourceColumns(), log};\n-        };\n-\n-        if (const MergeTreeData * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))\n-            optimize_prewhere(*merge_tree_data);\n-    }\n-\n-    AnalysisResult expressions;\n-    FilterInfoPtr filter_info;\n-\n-    /// We need proper `source_header` for `NullBlockInputStream` in dry-run.\n-    if (storage && context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), \"filter\"))\n-    {\n-        filter_info = std::make_shared<FilterInfo>();\n-        filter_info->column_name = generateFilterActions(filter_info->actions, storage, context, required_columns);\n-        source_header = storage->getSampleBlockForColumns(filter_info->actions->getRequiredColumns());\n-    }\n+    auto & expressions = analysis_result;\n \n     SortingInfoPtr sorting_info;\n     if (settings.optimize_read_in_order && storage && query.orderBy() && !query_analyzer->hasAggregation() && !query.final() && !query.join())\n     {\n-        if (const MergeTreeData * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))\n+        if (const auto * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))\n             sorting_info = optimizeReadInOrder(*merge_tree_data, query, context, syntax_analyzer_result);\n     }\n \n@@ -963,16 +950,6 @@ void InterpreterSelectQuery::executeImpl(TPipeline & pipeline, const BlockInputS\n         else\n             pipeline.streams.emplace_back(std::make_shared<NullBlockInputStream>(source_header));\n \n-        expressions = analyzeExpressions(\n-                getSelectQuery(),\n-                *query_analyzer,\n-                QueryProcessingStage::FetchColumns,\n-                options.to_stage,\n-                context,\n-                storage,\n-                true,\n-                filter_info);\n-\n         if (storage && expressions.filter_info && expressions.prewhere_info)\n             throw Exception(\"PREWHERE is not supported if the table is filtered by row-level security expression\", ErrorCodes::ILLEGAL_PREWHERE);\n \n@@ -1018,16 +995,6 @@ void InterpreterSelectQuery::executeImpl(TPipeline & pipeline, const BlockInputS\n                 pipeline.streams.push_back(prepared_input);\n         }\n \n-        expressions = analyzeExpressions(\n-                getSelectQuery(),\n-                *query_analyzer,\n-                from_stage,\n-                options.to_stage,\n-                context,\n-                storage,\n-                false,\n-                filter_info);\n-\n         if (from_stage == QueryProcessingStage::WithMergeableState &&\n             options.to_stage == QueryProcessingStage::WithMergeableState)\n             throw Exception(\"Distributed on Distributed is not supported\", ErrorCodes::NOT_IMPLEMENTED);\ndiff --git a/dbms/src/Interpreters/InterpreterSelectQuery.h b/dbms/src/Interpreters/InterpreterSelectQuery.h\nindex b1707db3480b..9789ce5a36f6 100644\n--- a/dbms/src/Interpreters/InterpreterSelectQuery.h\n+++ b/dbms/src/Interpreters/InterpreterSelectQuery.h\n@@ -207,7 +207,7 @@ class InterpreterSelectQuery : public IInterpreter\n     void executeWithFill(Pipeline & pipeline);\n     void executeMergeSorted(Pipeline & pipeline);\n     void executePreLimit(Pipeline & pipeline);\n-    void executeUnion(Pipeline & pipeline, Block header); /// If header is not empty, convert streams structure to it.\n+    void executeUnion(Pipeline & pipeline, Block header);\n     void executeLimitBy(Pipeline & pipeline);\n     void executeLimit(Pipeline & pipeline);\n     void executeProjection(Pipeline & pipeline, const ExpressionActionsPtr & expression);\n@@ -260,6 +260,12 @@ class InterpreterSelectQuery : public IInterpreter\n     std::unique_ptr<SelectQueryExpressionAnalyzer> query_analyzer;\n     SelectQueryInfo query_info;\n \n+    /// Is calculated in getSampleBlock. Is used later in readImpl.\n+    AnalysisResult analysis_result;\n+    FilterInfoPtr filter_info;\n+\n+    QueryProcessingStage::Enum from_stage = QueryProcessingStage::FetchColumns;\n+\n     /// How many streams we ask for storage to produce, and in how many threads we will do further processing.\n     size_t max_streams = 1;\n \n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01015_random_constant.reference b/dbms/tests/queries/0_stateless/01015_random_constant.reference\nnew file mode 100644\nindex 000000000000..e8183f05f5db\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01015_random_constant.reference\n@@ -0,0 +1,3 @@\n+1\n+1\n+1\ndiff --git a/dbms/tests/queries/0_stateless/01015_random_constant.sql b/dbms/tests/queries/0_stateless/01015_random_constant.sql\nnew file mode 100644\nindex 000000000000..b25dd9420d7f\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01015_random_constant.sql\n@@ -0,0 +1,3 @@\n+select randConstant() >= 0;\n+select randConstant() % 10 < 10;\n+select uniqExact(x) from (select randConstant() as x);\n",
  "problem_statement": "clickhouse benchmark <<< \"SELECT now()\" does not work on master\n\n",
  "hints_text": "for search:\r\n\r\nCode: 171. DB::Exception: Received from localhost:9000. DB::Exception: Cannot convert column ... because it is constant but values of constants are different in source and result.\r\n\r\nworkaround for `now()` -> `materialize(now())`\r\n\r\nIssues persists at least in 19.14.6.12 stable.\r\n",
  "created_at": "2019-09-30T17:54:32Z",
  "modified_files": [
    "dbms/src/Functions/now.cpp",
    "dbms/src/Functions/randConstant.cpp",
    "dbms/src/Functions/today.cpp",
    "dbms/src/Functions/yesterday.cpp",
    "dbms/src/Interpreters/ExpressionAnalyzer.cpp",
    "dbms/src/Interpreters/ExpressionAnalyzer.h",
    "dbms/src/Interpreters/InterpreterSelectQuery.cpp",
    "dbms/src/Interpreters/InterpreterSelectQuery.h"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/01015_random_constant.reference",
    "b/dbms/tests/queries/0_stateless/01015_random_constant.sql"
  ]
}