diff --git a/dbms/src/Functions/now.cpp b/dbms/src/Functions/now.cpp
index 59501d96088d..accef94e5894 100644
--- a/dbms/src/Functions/now.cpp
+++ b/dbms/src/Functions/now.cpp
@@ -5,40 +5,81 @@
 
 
 namespace DB
-{
 
+{
 /// Get the current time. (It is a constant, it is evaluated once for the entire query.)
-class FunctionNow : public IFunction
+
+class PreparedFunctionNow : public PreparedFunctionImpl
 {
 public:
-    static constexpr auto name = "now";
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionNow>(); }
+    explicit PreparedFunctionNow(time_t time_) : time_value(time_) {}
 
-    String getName() const override
+    String getName() const override { return "now"; }
+
+protected:
+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
     {
-        return name;
+        block.getByPosition(result).column = DataTypeDateTime().createColumnConst(
+                input_rows_count,
+                static_cast<UInt64>(time_value));
     }
 
-    size_t getNumberOfArguments() const override { return 0; }
+private:
+    time_t time_value;
+};
+
+class FunctionBaseNow : public IFunctionBase
+{
+public:
+    explicit FunctionBaseNow(time_t time_) : time_value(time_), return_type(std::make_shared<DataTypeDateTime>()) {}
+
+    String getName() const override { return "now"; }
+
+    const DataTypes & getArgumentTypes() const override
+    {
+        static const DataTypes argument_types;
+        return argument_types;
+    }
 
-    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override
+    const DataTypePtr & getReturnType() const override
     {
-        return std::make_shared<DataTypeDateTime>();
+        return return_type;
+    }
+
+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override
+    {
+        return std::make_shared<PreparedFunctionNow>(time_value);
     }
 
     bool isDeterministic() const override { return false; }
 
-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
+private:
+    time_t time_value;
+    DataTypePtr return_type;
+};
+
+class FunctionBuilderNow : public FunctionBuilderImpl
+{
+public:
+    static constexpr auto name = "now";
+
+    String getName() const override { return name; }
+    size_t getNumberOfArguments() const override { return 0; }
+
+    static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderNow>(); }
+
+protected:
+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeDateTime>(); }
+
+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName &, const DataTypePtr &) const override
     {
-        block.getByPosition(result).column = DataTypeDateTime().createColumnConst(
-            input_rows_count,
-            static_cast<UInt64>(time(nullptr)));
+        return std::make_shared<FunctionBaseNow>(time(nullptr));
     }
 };
 
 void registerFunctionNow(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionNow>(FunctionFactory::CaseInsensitive);
+    factory.registerFunction<FunctionBuilderNow>(FunctionFactory::CaseInsensitive);
 }
 
 }
diff --git a/dbms/src/Functions/randConstant.cpp b/dbms/src/Functions/randConstant.cpp
index 91df7a1dfb89..e854484154c1 100644
--- a/dbms/src/Functions/randConstant.cpp
+++ b/dbms/src/Functions/randConstant.cpp
@@ -6,55 +6,105 @@ namespace DB
 {
 
 template <typename ToType, typename Name>
-class FunctionRandomConstant : public IFunction
+class PreparedFunctionRandomConstant : public PreparedFunctionImpl
 {
+public:
+    explicit PreparedFunctionRandomConstant(ToType value_) : value(value_) {}
+
+    String getName() const override { return Name::name; }
+
+protected:
+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
+    {
+        block.getByPosition(result).column = DataTypeNumber<ToType>().createColumnConst(input_rows_count, value);
+    }
+
 private:
-    /// The value is one for different blocks.
-    bool is_initialized = false;
     ToType value;
+};
 
+template <typename ToType, typename Name>
+class FunctionBaseRandomConstant : public IFunctionBase
+{
 public:
-    static constexpr auto name = Name::name;
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionRandomConstant>(); }
+    explicit FunctionBaseRandomConstant(ToType value_, DataTypes argument_types_)
+        : value(value_)
+        , argument_types(std::move(argument_types_))
+        , return_type(std::make_shared<DataTypeNumber<ToType>>()) {}
+
+    String getName() const override { return Name::name; }
+
+    const DataTypes & getArgumentTypes() const override
+    {
+        return argument_types;
+    }
+
+    const DataTypePtr & getReturnType() const override
+    {
+        return return_type;
+    }
 
-    String getName() const override
+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override
     {
-        return name;
+        return std::make_shared<PreparedFunctionRandomConstant<ToType, Name>>(value);
     }
 
+    bool isDeterministic() const override { return false; }
+
+private:
+    ToType value;
+    DataTypes argument_types;
+    DataTypePtr return_type;
+};
+
+template <typename ToType, typename Name>
+class FunctionBuilderRandomConstant : public FunctionBuilderImpl
+{
+public:
+    static constexpr auto name = Name::name;
+    String getName() const override { return name; }
+
     bool isVariadic() const override { return true; }
     size_t getNumberOfArguments() const override { return 0; }
 
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    void checkNumberOfArguments(size_t number_of_arguments) const override
     {
-        if (arguments.size() > 1)
+        if (number_of_arguments > 1)
             throw Exception("Number of arguments for function " + getName() + " doesn't match: passed "
-                + toString(arguments.size()) + ", should be 0 or 1.",
-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+                            + toString(number_of_arguments) + ", should be 0 or 1.",
+                            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+    }
 
-        return std::make_shared<DataTypeNumber<ToType>>();
+    static FunctionBuilderPtr create(const Context &)
+    {
+        return std::make_shared<FunctionBuilderRandomConstant<ToType, Name>>();
     }
 
-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
+protected:
+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeNumber<ToType>>(); }
+
+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &) const override
     {
-        if (!is_initialized)
-        {
-            is_initialized = true;
-            typename ColumnVector<ToType>::Container vec_to(1);
-            RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), sizeof(ToType));
-            value = vec_to[0];
-        }
-
-        block.getByPosition(result).column = DataTypeNumber<ToType>().createColumnConst(input_rows_count, toField(value));
+        DataTypes argument_types;
+
+        if (!arguments.empty())
+            argument_types.emplace_back(arguments.back().type);
+
+        typename ColumnVector<ToType>::Container vec_to(1);
+        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), sizeof(ToType));
+        ToType value = vec_to[0];
+
+        return std::make_shared<FunctionBaseRandomConstant<ToType, Name>>(value, argument_types);
     }
 };
 
+
 struct NameRandConstant { static constexpr auto name = "randConstant"; };
-using FunctionRandConstant = FunctionRandomConstant<UInt32, NameRandConstant>;
+using FunctionBuilderRandConstant = FunctionBuilderRandomConstant<UInt32, NameRandConstant>;
 
 void registerFunctionRandConstant(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionRandConstant>();
+    factory.registerFunction<FunctionBuilderRandConstant>();
 }
 
 }
diff --git a/dbms/src/Functions/today.cpp b/dbms/src/Functions/today.cpp
index c74bc0002926..d7eb684996fb 100644
--- a/dbms/src/Functions/today.cpp
+++ b/dbms/src/Functions/today.cpp
@@ -9,37 +9,75 @@
 namespace DB
 {
 
-class FunctionToday : public IFunction
+class PreparedFunctionToday : public PreparedFunctionImpl
 {
 public:
-    static constexpr auto name = "today";
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionToday>(); }
+    explicit PreparedFunctionToday(time_t time_) : day_value(time_) {}
+
+    String getName() const override { return "today"; }
 
-    String getName() const override
+protected:
+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
     {
-        return name;
+        block.getByPosition(result).column = DataTypeDate().createColumnConst(input_rows_count, day_value);
     }
 
-    size_t getNumberOfArguments() const override { return 0; }
+private:
+    DayNum day_value;
+};
+
+class FunctionBaseToday : public IFunctionBase
+{
+public:
+    explicit FunctionBaseToday(DayNum day_value_) : day_value(day_value_), return_type(std::make_shared<DataTypeDate>()) {}
+
+    String getName() const override { return "today"; }
+
+    const DataTypes & getArgumentTypes() const override
+    {
+        static const DataTypes argument_types;
+        return argument_types;
+    }
+
+    const DataTypePtr & getReturnType() const override
+    {
+        return return_type;
+    }
 
-    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override
+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override
     {
-        return std::make_shared<DataTypeDate>();
+        return std::make_shared<PreparedFunctionToday>(day_value);
     }
 
     bool isDeterministic() const override { return false; }
 
-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
+private:
+    DayNum day_value;
+    DataTypePtr return_type;
+};
+
+class FunctionBuilderToday : public FunctionBuilderImpl
+{
+public:
+    static constexpr auto name = "today";
+
+    String getName() const override { return name; }
+    size_t getNumberOfArguments() const override { return 0; }
+
+    static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderToday>(); }
+
+protected:
+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeDate>(); }
+
+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName &, const DataTypePtr &) const override
     {
-        block.getByPosition(result).column = DataTypeDate().createColumnConst(
-            input_rows_count,
-            DateLUT::instance().toDayNum(time(nullptr)));
+        return std::make_shared<FunctionBaseToday>(DateLUT::instance().toDayNum(time(nullptr)));
     }
 };
 
 void registerFunctionToday(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionToday>();
+    factory.registerFunction<FunctionBuilderToday>();
 }
 
 }
diff --git a/dbms/src/Functions/yesterday.cpp b/dbms/src/Functions/yesterday.cpp
index 393a3a453612..e08c21978364 100644
--- a/dbms/src/Functions/yesterday.cpp
+++ b/dbms/src/Functions/yesterday.cpp
@@ -9,37 +9,76 @@
 namespace DB
 {
 
-class FunctionYesterday : public IFunction
+class PreparedFunctionYesterday : public PreparedFunctionImpl
 {
 public:
-    static constexpr auto name = "yesterday";
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionYesterday>(); }
+    explicit PreparedFunctionYesterday(time_t time_) : day_value(time_) {}
+
+    String getName() const override { return "yesterday"; }
 
-    String getName() const override
+protected:
+    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
     {
-        return name;
+        block.getByPosition(result).column = DataTypeDate().createColumnConst(input_rows_count, day_value);
     }
 
-    size_t getNumberOfArguments() const override { return 0; }
+private:
+    DayNum day_value;
+};
+
+class FunctionBaseYesterday : public IFunctionBase
+{
+public:
+    explicit FunctionBaseYesterday(DayNum day_value_) : day_value(day_value_), return_type(std::make_shared<DataTypeDate>()) {}
+
+    String getName() const override { return "yesterday"; }
+
+    const DataTypes & getArgumentTypes() const override
+    {
+        static const DataTypes argument_types;
+        return argument_types;
+    }
+
+    const DataTypePtr & getReturnType() const override
+    {
+        return return_type;
+    }
 
-    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override
+    PreparedFunctionPtr prepare(const Block &, const ColumnNumbers &, size_t) const override
     {
-        return std::make_shared<DataTypeDate>();
+        return std::make_shared<PreparedFunctionYesterday>(day_value);
     }
 
     bool isDeterministic() const override { return false; }
 
-    void executeImpl(Block & block, const ColumnNumbers &, size_t result, size_t input_rows_count) override
+private:
+    DayNum day_value;
+    DataTypePtr return_type;
+};
+
+class FunctionBuilderYesterday : public FunctionBuilderImpl
+{
+public:
+    static constexpr auto name = "yesterday";
+
+    String getName() const override { return name; }
+    size_t getNumberOfArguments() const override { return 0; }
+
+    static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderYesterday>(); }
+
+protected:
+    DataTypePtr getReturnTypeImpl(const DataTypes &) const override { return std::make_shared<DataTypeDate>(); }
+
+    FunctionBasePtr buildImpl(const ColumnsWithTypeAndName &, const DataTypePtr &) const override
     {
-        block.getByPosition(result).column = DataTypeDate().createColumnConst(
-            input_rows_count,
-            DateLUT::instance().toDayNum(time(nullptr)) - 1);
+        auto day_num = DateLUT::instance().toDayNum(time(nullptr)) - 1;
+        return std::make_shared<FunctionBaseYesterday>(static_cast<DayNum>(day_num));
     }
 };
 
 void registerFunctionYesterday(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionYesterday>();
+    factory.registerFunction<FunctionBuilderYesterday>();
 }
 
 }
diff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp
index 50f5e3a0b4b6..14849763ef3c 100644
--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp
@@ -589,6 +589,19 @@ bool SelectQueryExpressionAnalyzer::appendPrewhere(
     return true;
 }
 
+void SelectQueryExpressionAnalyzer::appendPreliminaryFilter(ExpressionActionsChain & chain, ExpressionActionsPtr actions, String column_name)
+{
+    initChain(chain, sourceColumns());
+    ExpressionActionsChain::Step & step = chain.steps.back();
+
+    // FIXME: assert(filter_info);
+    step.actions = std::move(actions);
+    step.required_output.push_back(std::move(column_name));
+    step.can_remove_required_output = {true};
+
+    chain.addStep();
+}
+
 bool SelectQueryExpressionAnalyzer::appendWhere(ExpressionActionsChain & chain, bool only_types)
 {
     const auto * select_query = getSelectQuery();
diff --git a/dbms/src/Interpreters/ExpressionAnalyzer.h b/dbms/src/Interpreters/ExpressionAnalyzer.h
index 2dfc8909d024..aac801fbd4c6 100644
--- a/dbms/src/Interpreters/ExpressionAnalyzer.h
+++ b/dbms/src/Interpreters/ExpressionAnalyzer.h
@@ -189,6 +189,8 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer
     /// Before aggregation:
     bool appendArrayJoin(ExpressionActionsChain & chain, bool only_types);
     bool appendJoin(ExpressionActionsChain & chain, bool only_types);
+    /// Add preliminary rows filtration. Actions are created in other expression analyzer to prevent any possible alias injection.
+    void appendPreliminaryFilter(ExpressionActionsChain & chain, ExpressionActionsPtr actions, String column_name);
     /// remove_filter is set in ExpressionActionsChain::finalize();
     /// Columns in `additional_required_columns` will not be removed (they can be used for e.g. sampling or FINAL modifier).
     bool appendPrewhere(ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns);
diff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp
index 8c49cf34ca52..7d1a3b42737e 100644
--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp
@@ -113,7 +113,7 @@ namespace ErrorCodes
 namespace
 {
 
-/// Assumes `storage` is set and the table filter is not empty.
+/// Assumes `storage` is set and the table filter (row-level security) is not empty.
 String generateFilterActions(ExpressionActionsPtr & actions, const StoragePtr & storage, const Context & context, const Names & prerequisite_columns = {})
 {
     const auto & db_name = storage->getDatabaseName();
@@ -350,8 +350,18 @@ InterpreterSelectQuery::InterpreterSelectQuery(
     required_columns = syntax_analyzer_result->requiredSourceColumns();
 
     if (storage)
+    {
         source_header = storage->getSampleBlockForColumns(required_columns);
 
+        /// Fix source_header for filter actions.
+        if (context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), "filter"))
+        {
+            filter_info = std::make_shared<FilterInfo>();
+            filter_info->column_name = generateFilterActions(filter_info->actions, storage, context, required_columns);
+            source_header = storage->getSampleBlockForColumns(filter_info->actions->getRequiredColumns());
+        }
+    }
+
     /// Calculate structure of the result.
     result_header = getSampleBlockImpl();
     for (auto & col : result_header)
@@ -419,19 +429,47 @@ QueryPipeline InterpreterSelectQuery::executeWithProcessors()
 
 Block InterpreterSelectQuery::getSampleBlockImpl()
 {
-    /// Need to create sets before analyzeExpressions(). Otherwise some sets for index won't be created.
-    query_analyzer->makeSetsForIndex(getSelectQuery().where());
-    query_analyzer->makeSetsForIndex(getSelectQuery().prewhere());
+    auto & query = getSelectQuery();
+    const Settings & settings = context.getSettingsRef();
 
-    auto analysis_result = analyzeExpressions(
+    /// Do all AST changes here, because actions from analysis_result will be used later in readImpl.
+
+    /// PREWHERE optimization.
+    /// Turn off, if the table filter (row-level security) is applied.
+    if (storage && !context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), "filter"))
+    {
+        query_analyzer->makeSetsForIndex(query.where());
+        query_analyzer->makeSetsForIndex(query.prewhere());
+
+        auto optimize_prewhere = [&](auto & merge_tree)
+        {
+            SelectQueryInfo current_info;
+            current_info.query = query_ptr;
+            current_info.syntax_analyzer_result = syntax_analyzer_result;
+            current_info.sets = query_analyzer->getPreparedSets();
+
+            /// Try transferring some condition from WHERE to PREWHERE if enabled and viable
+            if (settings.optimize_move_to_prewhere && query.where() && !query.prewhere() && !query.final())
+                MergeTreeWhereOptimizer{current_info, context, merge_tree,
+                                        syntax_analyzer_result->requiredSourceColumns(), log};
+        };
+
+        if (const auto * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))
+            optimize_prewhere(*merge_tree_data);
+    }
+
+    if (storage && !options.only_analyze)
+        from_stage = storage->getQueryProcessingStage(context);
+
+    analysis_result = analyzeExpressions(
             getSelectQuery(),
             *query_analyzer,
-            QueryProcessingStage::Enum::FetchColumns,
+            from_stage,
             options.to_stage,
             context,
             storage,
-            true,  // only_types
-            {}     // filter_info
+            options.only_analyze,
+            filter_info
         );
 
     if (options.to_stage == QueryProcessingStage::Enum::FetchColumns)
@@ -574,21 +612,8 @@ InterpreterSelectQuery::analyzeExpressions(
         if (storage && filter_info)
         {
             has_filter = true;
-
-            /// XXX: aggregated copy-paste from ExpressionAnalyzer::appendSmth()
-            if (chain.steps.empty())
-            {
-                chain.steps.emplace_back(std::make_shared<ExpressionActions>(NamesAndTypesList(), context));
-            }
-            ExpressionActionsChain::Step & step = chain.steps.back();
-
-            // FIXME: assert(filter_info);
             res.filter_info = filter_info;
-            step.actions = filter_info->actions;
-            step.required_output.push_back(res.filter_info->column_name);
-            step.can_remove_required_output = {true};
-
-            chain.addStep();
+            query_analyzer.appendPreliminaryFilter(chain, filter_info->actions, filter_info->column_name);
         }
 
         if (query_analyzer.appendPrewhere(chain, !res.first_stage, additional_required_columns_after_prewhere))
@@ -909,50 +934,12 @@ void InterpreterSelectQuery::executeImpl(TPipeline & pipeline, const BlockInputS
     /// Now we will compose block streams that perform the necessary actions.
     auto & query = getSelectQuery();
     const Settings & settings = context.getSettingsRef();
-
-    QueryProcessingStage::Enum from_stage = QueryProcessingStage::FetchColumns;
-
-    /// PREWHERE optimization
-    /// Turn off, if the table filter is applied.
-    if (storage && !context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), "filter"))
-    {
-        if (!options.only_analyze)
-            from_stage = storage->getQueryProcessingStage(context);
-
-        query_analyzer->makeSetsForIndex(query.where());
-        query_analyzer->makeSetsForIndex(query.prewhere());
-
-        auto optimize_prewhere = [&](auto & merge_tree)
-        {
-            SelectQueryInfo current_info;
-            current_info.query = query_ptr;
-            current_info.syntax_analyzer_result = syntax_analyzer_result;
-            current_info.sets = query_analyzer->getPreparedSets();
-
-            /// Try transferring some condition from WHERE to PREWHERE if enabled and viable
-            if (settings.optimize_move_to_prewhere && query.where() && !query.prewhere() && !query.final())
-                MergeTreeWhereOptimizer{current_info, context, merge_tree, syntax_analyzer_result->requiredSourceColumns(), log};
-        };
-
-        if (const MergeTreeData * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))
-            optimize_prewhere(*merge_tree_data);
-    }
-
-    AnalysisResult expressions;
-    FilterInfoPtr filter_info;
-
-    /// We need proper `source_header` for `NullBlockInputStream` in dry-run.
-    if (storage && context.hasUserProperty(storage->getDatabaseName(), storage->getTableName(), "filter"))
-    {
-        filter_info = std::make_shared<FilterInfo>();
-        filter_info->column_name = generateFilterActions(filter_info->actions, storage, context, required_columns);
-        source_header = storage->getSampleBlockForColumns(filter_info->actions->getRequiredColumns());
-    }
+    auto & expressions = analysis_result;
 
     SortingInfoPtr sorting_info;
     if (settings.optimize_read_in_order && storage && query.orderBy() && !query_analyzer->hasAggregation() && !query.final() && !query.join())
     {
-        if (const MergeTreeData * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))
+        if (const auto * merge_tree_data = dynamic_cast<const MergeTreeData *>(storage.get()))
             sorting_info = optimizeReadInOrder(*merge_tree_data, query, context, syntax_analyzer_result);
     }
 
@@ -963,16 +950,6 @@ void InterpreterSelectQuery::executeImpl(TPipeline & pipeline, const BlockInputS
         else
             pipeline.streams.emplace_back(std::make_shared<NullBlockInputStream>(source_header));
 
-        expressions = analyzeExpressions(
-                getSelectQuery(),
-                *query_analyzer,
-                QueryProcessingStage::FetchColumns,
-                options.to_stage,
-                context,
-                storage,
-                true,
-                filter_info);
-
         if (storage && expressions.filter_info && expressions.prewhere_info)
             throw Exception("PREWHERE is not supported if the table is filtered by row-level security expression", ErrorCodes::ILLEGAL_PREWHERE);
 
@@ -1018,16 +995,6 @@ void InterpreterSelectQuery::executeImpl(TPipeline & pipeline, const BlockInputS
                 pipeline.streams.push_back(prepared_input);
         }
 
-        expressions = analyzeExpressions(
-                getSelectQuery(),
-                *query_analyzer,
-                from_stage,
-                options.to_stage,
-                context,
-                storage,
-                false,
-                filter_info);
-
         if (from_stage == QueryProcessingStage::WithMergeableState &&
             options.to_stage == QueryProcessingStage::WithMergeableState)
             throw Exception("Distributed on Distributed is not supported", ErrorCodes::NOT_IMPLEMENTED);
diff --git a/dbms/src/Interpreters/InterpreterSelectQuery.h b/dbms/src/Interpreters/InterpreterSelectQuery.h
index b1707db3480b..9789ce5a36f6 100644
--- a/dbms/src/Interpreters/InterpreterSelectQuery.h
+++ b/dbms/src/Interpreters/InterpreterSelectQuery.h
@@ -207,7 +207,7 @@ class InterpreterSelectQuery : public IInterpreter
     void executeWithFill(Pipeline & pipeline);
     void executeMergeSorted(Pipeline & pipeline);
     void executePreLimit(Pipeline & pipeline);
-    void executeUnion(Pipeline & pipeline, Block header); /// If header is not empty, convert streams structure to it.
+    void executeUnion(Pipeline & pipeline, Block header);
     void executeLimitBy(Pipeline & pipeline);
     void executeLimit(Pipeline & pipeline);
     void executeProjection(Pipeline & pipeline, const ExpressionActionsPtr & expression);
@@ -260,6 +260,12 @@ class InterpreterSelectQuery : public IInterpreter
     std::unique_ptr<SelectQueryExpressionAnalyzer> query_analyzer;
     SelectQueryInfo query_info;
 
+    /// Is calculated in getSampleBlock. Is used later in readImpl.
+    AnalysisResult analysis_result;
+    FilterInfoPtr filter_info;
+
+    QueryProcessingStage::Enum from_stage = QueryProcessingStage::FetchColumns;
+
     /// How many streams we ask for storage to produce, and in how many threads we will do further processing.
     size_t max_streams = 1;
 
