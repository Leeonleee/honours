{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 45030,
  "instance_id": "ClickHouse__ClickHouse-45030",
  "issue_numbers": [
    "45010"
  ],
  "base_commit": "e07dd44f798d7b7a31b3e48dfd909e3af04765bb",
  "patch": "diff --git a/src/Functions/array/range.cpp b/src/Functions/array/range.cpp\nindex 46284ce95bfe..6bf65662d8c9 100644\n--- a/src/Functions/array/range.cpp\n+++ b/src/Functions/array/range.cpp\n@@ -165,7 +165,7 @@ class FunctionRange : public IFunction\n         {\n             for (size_t idx = 0; idx < row_length[row_idx]; ++idx)\n             {\n-                out_data[offset] = static_cast<T>(start + offset * step);\n+                out_data[offset] = static_cast<T>(start + idx * step);\n                 ++offset;\n             }\n             out_offsets[row_idx] = offset;\n@@ -225,8 +225,11 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n-                out_data[offset++] = static_cast<T>(start_data[row_idx] + idx * step);\n+            for (size_t idx = 0; idx < row_length[row_idx]; ++idx)\n+            {\n+                out_data[offset] = static_cast<T>(start_data[row_idx] + idx * step);\n+                ++offset;\n+            }\n             out_offsets[row_idx] = offset;\n         }\n \n@@ -284,8 +287,11 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n-                out_data[offset++] = static_cast<T>(start + offset * step_data[row_idx]);\n+            for (size_t idx = 0; idx < row_length[row_idx]; ++idx)\n+            {\n+                out_data[offset] = static_cast<T>(start + idx * step_data[row_idx]);\n+                ++offset;\n+            }\n             out_offsets[row_idx] = offset;\n         }\n \n@@ -314,8 +320,8 @@ class FunctionRange : public IFunction\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n             if (step_data[row_idx] == 0)\n-                throw Exception{\"A call to function \" + getName() + \" overflows, the 3rd argument step can't less or equal to zero\",\n-                            ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+                throw Exception{ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n+                    \"A call to function {} underflows, the 3rd argument step can't be less or equal to zero\", getName()};\n             if (start_data[row_idx] < end_start[row_idx] && step_data[row_idx] > 0)\n                 row_length[row_idx] = (static_cast<__int128_t>(end_start[row_idx]) - static_cast<__int128_t>(start_data[row_idx]) - 1) / static_cast<__int128_t>(step_data[row_idx]) + 1;\n             else if (start_data[row_idx] > end_start[row_idx] && step_data[row_idx] < 0)\n@@ -345,8 +351,11 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n-                out_data[offset++] = static_cast<T>(start_data[row_idx] + idx * step_data[row_idx]);\n+            for (size_t idx = 0; idx < row_length[row_idx]; ++idx)\n+            {\n+                out_data[offset] = static_cast<T>(start_data[row_idx] + idx * step_data[row_idx]);\n+                ++offset;\n+            }\n             out_offsets[row_idx] = offset;\n         }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02523_range_const_start.reference b/tests/queries/0_stateless/02523_range_const_start.reference\nnew file mode 100644\nindex 000000000000..143029046e95\n--- /dev/null\n+++ b/tests/queries/0_stateless/02523_range_const_start.reference\n@@ -0,0 +1,44 @@\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+c1:                 1\n+zero_as_start_val:  [0]\n+one_as_start_val:   []\n+no_start_val:       [0]\n+val_as_start:       [1]\n+complex_start_step: []\n+\n+Row 2:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+c1:                 2\n+zero_as_start_val:  [0,1]\n+one_as_start_val:   [1]\n+no_start_val:       [0,1]\n+val_as_start:       [2,3]\n+complex_start_step: [2]\n+\n+Row 3:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+c1:                 3\n+zero_as_start_val:  [0,1,2]\n+one_as_start_val:   [1,2]\n+no_start_val:       [0,1,2]\n+val_as_start:       [3,4,5]\n+complex_start_step: [3,6]\n+\n+Row 4:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+c1:                 4\n+zero_as_start_val:  [0,1,2,3]\n+one_as_start_val:   [1,2,3]\n+no_start_val:       [0,1,2,3]\n+val_as_start:       [4,5,6,7]\n+complex_start_step: [4,8,12]\n+\n+Row 5:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+c1:                 5\n+zero_as_start_val:  [0,1,2,3,4]\n+one_as_start_val:   [1,2,3,4]\n+no_start_val:       [0,1,2,3,4]\n+val_as_start:       [5,6,7,8,9]\n+complex_start_step: [5,10,15,20]\ndiff --git a/tests/queries/0_stateless/02523_range_const_start.sql b/tests/queries/0_stateless/02523_range_const_start.sql\nnew file mode 100644\nindex 000000000000..869dec3c1671\n--- /dev/null\n+++ b/tests/queries/0_stateless/02523_range_const_start.sql\n@@ -0,0 +1,9 @@\n+SELECT\n+  c1,\n+  range(0, c1) AS zero_as_start_val,\n+  range(1, c1) AS one_as_start_val,\n+  range(c1) AS no_start_val,\n+  range(c1, c1 * 2) AS val_as_start,\n+  range(c1, c1 * c1, c1) AS complex_start_step\n+FROM values(1, 2, 3, 4, 5)\n+FORMAT Vertical;\n",
  "problem_statement": "Array `range()` function: Returned arrays only start with specified start value on first row.\n**Describe the unexpected behaviour**\r\n\r\nIf a start value for the Array range() function is specified, the array for subsequent rows doesn't start at the specified value, but instead counts upwards. Example:\r\n\r\n```sql\r\nSELECT c1, range(0, c1) AS zero_as_start_val, range(1, c1) AS one_as_start_val, range(c1) AS no_start_val\r\nFROM values(2, 3, 4, 5);\r\n```\r\n\r\n| c1 | zero\\_as\\_start\\_val | one\\_as\\_start\\_val | no\\_start\\_val |\r\n| :--- | :--- | :--- | :--- |\r\n| 2 | \\[0, 1\\] | \\[1\\] | \\[0, 1\\] |\r\n| 3 | \\[2, 3, 4\\] | \\[2, 3\\] | \\[0, 1, 2\\] |\r\n| 4 | \\[5, 6, 7, 8\\] | \\[4, 5, 6\\] | \\[0, 1, 2, 3\\] |\r\n| 5 | \\[9, 10, 11, 12, 13\\] | \\[7, 8, 9, 10\\] | \\[0, 1, 2, 3, 4\\] |\r\n\r\n\r\nI'm not sure if this is desired behaviour.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: ClickHouse server version 22.13.1.1133 (official build) (macOS arm64)\r\n* [Clickhouse Playground](https://play.clickhouse.com/play?user=play#U0VMRUNUIGMxLCByYW5nZSgwLCBjMSkgQVMgemVyb19hc19zdGFydF92YWwsIHJhbmdlKDEsIGMxKSBBUyBvbmVfYXNfc3RhcnRfdmFsLCByYW5nZShjMSkgQVMgbm9fc3RhcnRfdmFsCkZST00gdmFsdWVzKDIsIDMsIDQsIDUpOw==)\r\n\r\n\r\n**Expected behavior**\r\n\r\nI'd expect all arrays to start with the specified start value.\n",
  "hints_text": "Looks ok in version 22.12: https://fiddle.clickhouse.com/d3214a14-af5e-4fe9-b686-0c8e1e463d70\r\nWe will check what has changed and add a test.",
  "created_at": "2023-01-08T01:57:15Z",
  "modified_files": [
    "src/Functions/array/range.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02523_range_const_start.reference",
    "b/tests/queries/0_stateless/02523_range_const_start.sql"
  ]
}