diff --git a/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.cpp b/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.cpp
index 79dec00ba0da..6496c32738ef 100644
--- a/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.cpp
+++ b/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.cpp
@@ -31,6 +31,8 @@ GroupingAggregatedTransform::GroupingAggregatedTransform(
 void GroupingAggregatedTransform::readFromAllInputs()
 {
     auto in = inputs.begin();
+    read_from_all_inputs = true;
+
     for (size_t i = 0; i < num_inputs; ++i, ++in)
     {
         if (in->isFinished())
@@ -42,14 +44,15 @@ void GroupingAggregatedTransform::readFromAllInputs()
         in->setNeeded();
 
         if (!in->hasData())
-            return;
+        {
+            read_from_all_inputs = false;
+            continue;
+        }
 
         auto chunk = in->pull();
         read_from_input[i] = true;
         addChunk(std::move(chunk), i);
     }
-
-    read_from_all_inputs = true;
 }
 
 void GroupingAggregatedTransform::pushData(Chunks chunks, Int32 bucket, bool is_overflows)
@@ -273,6 +276,7 @@ void GroupingAggregatedTransform::addChunk(Chunk chunk, size_t input)
 
 void GroupingAggregatedTransform::work()
 {
+    /// Convert single level data to two level.
     if (!single_level_chunks.empty())
     {
         const auto & header = getInputs().front().getHeader();  /// Take header from input port. Output header is empty.
diff --git a/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.h b/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.h
index 0c5986c2156c..bf23b67e2040 100644
--- a/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.h
+++ b/src/Processors/Transforms/MergingAggregatedMemoryEfficientTransform.h
@@ -28,11 +28,11 @@ class GroupingAggregatedTransform : public IProcessor
     size_t num_inputs;
     AggregatingTransformParamsPtr params;
 
-    std::vector<Int32> last_bucket_number;
-    std::map<Int32, Chunks> chunks_map;
+    std::vector<Int32> last_bucket_number; /// Last bucket read from each input.
+    std::map<Int32, Chunks> chunks_map; /// bucket -> chunks
     Chunks overflow_chunks;
     Chunks single_level_chunks;
-    Int32 current_bucket = 0;
+    Int32 current_bucket = 0; /// Currently processing bucket.
     Int32 next_bucket_to_push = 0; /// Always <= current_bucket.
     bool has_two_level = false;
 
@@ -42,11 +42,17 @@ class GroupingAggregatedTransform : public IProcessor
 
     bool expect_several_chunks_for_single_bucket_per_source = false;
 
+    /// Add chunk read from input to chunks_map, overflow_chunks or single_level_chunks according to it's chunk info.
     void addChunk(Chunk chunk, size_t input);
+    /// Read from all inputs first chunk. It is needed to detect if any source has two-level aggregation.
     void readFromAllInputs();
+    /// Push chunks if all inputs has single level.
     bool tryPushSingleLevelData();
+    /// Push chunks from ready bucket if has one.
     bool tryPushTwoLevelData();
+    /// Push overflow chunks if has any.
     bool tryPushOverflowData();
+    /// Push chunks from bucket to output port.
     void pushData(Chunks chunks, Int32 bucket, bool is_overflows);
 };
 
