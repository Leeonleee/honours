diff --git a/base/common/arithmeticOverflow.h b/base/common/arithmeticOverflow.h
index 3dfbdbc1346c..e228af287e21 100644
--- a/base/common/arithmeticOverflow.h
+++ b/base/common/arithmeticOverflow.h
@@ -38,18 +38,18 @@ namespace common
     }
 
     template <>
-    inline bool addOverflow(bInt256 x, bInt256 y, bInt256 & res)
+    inline bool addOverflow(wInt256 x, wInt256 y, wInt256 & res)
     {
         res = x + y;
-        return (y > 0 && x > std::numeric_limits<bInt256>::max() - y) ||
-            (y < 0 && x < std::numeric_limits<bInt256>::min() - y);
+        return (y > 0 && x > std::numeric_limits<wInt256>::max() - y) ||
+            (y < 0 && x < std::numeric_limits<wInt256>::min() - y);
     }
 
     template <>
-    inline bool addOverflow(bUInt256 x, bUInt256 y, bUInt256 & res)
+    inline bool addOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)
     {
         res = x + y;
-        return x > std::numeric_limits<bUInt256>::max() - y;
+        return x > std::numeric_limits<wUInt256>::max() - y;
     }
 
     template <typename T>
@@ -86,15 +86,15 @@ namespace common
     }
 
     template <>
-    inline bool subOverflow(bInt256 x, bInt256 y, bInt256 & res)
+    inline bool subOverflow(wInt256 x, wInt256 y, wInt256 & res)
     {
         res = x - y;
-        return (y < 0 && x > std::numeric_limits<bInt256>::max() + y) ||
-            (y > 0 && x < std::numeric_limits<bInt256>::min() + y);
+        return (y < 0 && x > std::numeric_limits<wInt256>::max() + y) ||
+            (y > 0 && x < std::numeric_limits<wInt256>::min() + y);
     }
 
     template <>
-    inline bool subOverflow(bUInt256 x, bUInt256 y, bUInt256 & res)
+    inline bool subOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)
     {
         res = x - y;
         return x < y;
@@ -137,19 +137,19 @@ namespace common
     }
 
     template <>
-    inline bool mulOverflow(bInt256 x, bInt256 y, bInt256 & res)
+    inline bool mulOverflow(wInt256 x, wInt256 y, wInt256 & res)
     {
         res = x * y;
         if (!x || !y)
             return false;
 
-        bInt256 a = (x > 0) ? x : -x;
-        bInt256 b = (y > 0) ? y : -y;
+        wInt256 a = (x > 0) ? x : -x;
+        wInt256 b = (y > 0) ? y : -y;
         return (a * b) / b != a;
     }
 
     template <>
-    inline bool mulOverflow(bUInt256 x, bUInt256 y, bUInt256 & res)
+    inline bool mulOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)
     {
         res = x * y;
         if (!x || !y)
diff --git a/base/common/types.h b/base/common/types.h
index 0a394de9f5ce..682fe94366cc 100644
--- a/base/common/types.h
+++ b/base/common/types.h
@@ -6,7 +6,7 @@
 #include <string>
 #include <type_traits>
 
-#include <boost/multiprecision/cpp_int.hpp>
+#include <common/wide_integer.h>
 
 using Int8 = int8_t;
 using Int16 = int16_t;
@@ -25,12 +25,11 @@ using UInt64 = uint64_t;
 
 using Int128 = __int128;
 
-/// We have to use 127 and 255 bit integers to safe a bit for a sign serialization
-//using bInt256 = boost::multiprecision::int256_t;
-using bInt256 = boost::multiprecision::number<boost::multiprecision::cpp_int_backend<
-    255, 255, boost::multiprecision::signed_magnitude, boost::multiprecision::unchecked, void> >;
-using bUInt256 = boost::multiprecision::uint256_t;
+using wInt256 = std::wide_integer<256, signed>;
+using wUInt256 = std::wide_integer<256, unsigned>;
 
+static_assert(sizeof(wInt256) == 32);
+static_assert(sizeof(wUInt256) == 32);
 
 using String = std::string;
 
@@ -44,7 +43,7 @@ struct is_signed
 };
 
 template <> struct is_signed<Int128> { static constexpr bool value = true; };
-template <> struct is_signed<bInt256> { static constexpr bool value = true; };
+template <> struct is_signed<wInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_signed_v = is_signed<T>::value;
@@ -55,7 +54,7 @@ struct is_unsigned
     static constexpr bool value = std::is_unsigned_v<T>;
 };
 
-template <> struct is_unsigned<bUInt256> { static constexpr bool value = true; };
+template <> struct is_unsigned<wUInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_unsigned_v = is_unsigned<T>::value;
@@ -69,8 +68,8 @@ struct is_integer
 };
 
 template <> struct is_integer<Int128> { static constexpr bool value = true; };
-template <> struct is_integer<bInt256> { static constexpr bool value = true; };
-template <> struct is_integer<bUInt256> { static constexpr bool value = true; };
+template <> struct is_integer<wInt256> { static constexpr bool value = true; };
+template <> struct is_integer<wUInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_integer_v = is_integer<T>::value;
@@ -93,9 +92,9 @@ struct make_unsigned
     typedef std::make_unsigned_t<T> type;
 };
 
-template <> struct make_unsigned<__int128> { using type = unsigned __int128; };
-template <> struct make_unsigned<bInt256>  { using type = bUInt256; };
-template <> struct make_unsigned<bUInt256> { using type = bUInt256; };
+template <> struct make_unsigned<Int128> { using type = unsigned __int128; };
+template <> struct make_unsigned<wInt256>  { using type = wUInt256; };
+template <> struct make_unsigned<wUInt256> { using type = wUInt256; };
 
 template <typename T> using make_unsigned_t = typename make_unsigned<T>::type;
 
@@ -105,8 +104,8 @@ struct make_signed
     typedef std::make_signed_t<T> type;
 };
 
-template <> struct make_signed<bInt256>  { typedef bInt256 type; };
-template <> struct make_signed<bUInt256> { typedef bInt256 type; };
+template <> struct make_signed<wInt256>  { using type = wInt256; };
+template <> struct make_signed<wUInt256> { using type = wInt256; };
 
 template <typename T> using make_signed_t = typename make_signed<T>::type;
 
@@ -116,8 +115,8 @@ struct is_big_int
     static constexpr bool value = false;
 };
 
-template <> struct is_big_int<bUInt256> { static constexpr bool value = true; };
-template <> struct is_big_int<bInt256> { static constexpr bool value = true; };
+template <> struct is_big_int<wInt256> { static constexpr bool value = true; };
+template <> struct is_big_int<wUInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_big_int_v = is_big_int<T>::value;
@@ -125,14 +124,11 @@ inline constexpr bool is_big_int_v = is_big_int<T>::value;
 template <typename T>
 inline std::string bigintToString(const T & x)
 {
-    return x.str();
+    return to_string(x);
 }
 
 template <typename To, typename From>
 inline To bigint_cast(const From & x [[maybe_unused]])
 {
-    if constexpr ((is_big_int_v<From> && std::is_same_v<To, UInt8>) || (is_big_int_v<To> && std::is_same_v<From, UInt8>))
-        return static_cast<uint8_t>(x);
-    else
-        return static_cast<To>(x);
+    return static_cast<To>(x);
 }
diff --git a/base/common/wide_integer.h b/base/common/wide_integer.h
new file mode 100644
index 000000000000..67d0b3f04da1
--- /dev/null
+++ b/base/common/wide_integer.h
@@ -0,0 +1,249 @@
+#pragma once
+
+///////////////////////////////////////////////////////////////
+//  Distributed under the Boost Software License, Version 1.0.
+//  (See at http://www.boost.org/LICENSE_1_0.txt)
+///////////////////////////////////////////////////////////////
+
+/*  Divide and multiply
+ *
+ *
+ * Copyright (c) 2008
+ * Evan Teran
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appears in all copies and that both the
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the same name not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission. We make no representations about the
+ * suitability this software for any purpose. It is provided "as is"
+ * without express or implied warranty.
+ */
+
+#include <climits> // CHAR_BIT
+#include <cmath>
+#include <cstdint>
+#include <limits>
+#include <type_traits>
+
+namespace std
+{
+template <size_t Bits, typename Signed>
+class wide_integer;
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+struct common_type<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>;
+
+template <size_t Bits, typename Signed, typename Arithmetic>
+struct common_type<wide_integer<Bits, Signed>, Arithmetic>;
+
+template <typename Arithmetic, size_t Bits, typename Signed>
+struct common_type<Arithmetic, wide_integer<Bits, Signed>>;
+
+template <size_t Bits, typename Signed>
+class wide_integer
+{
+public:
+    using base_type = uint8_t;
+    using signed_base_type = int8_t;
+
+    // ctors
+    wide_integer() = default;
+
+    template <typename T>
+    constexpr wide_integer(T rhs) noexcept;
+    template <typename T>
+    constexpr wide_integer(std::initializer_list<T> il) noexcept;
+
+    // assignment
+    template <size_t Bits2, typename Signed2>
+    constexpr wide_integer<Bits, Signed> & operator=(const wide_integer<Bits2, Signed2> & rhs) noexcept;
+
+    template <typename Arithmetic>
+    constexpr wide_integer<Bits, Signed> & operator=(Arithmetic rhs) noexcept;
+
+    template <typename Arithmetic>
+    constexpr wide_integer<Bits, Signed> & operator*=(const Arithmetic & rhs);
+
+    template <typename Arithmetic>
+    constexpr wide_integer<Bits, Signed> & operator/=(const Arithmetic & rhs);
+
+    template <typename Arithmetic>
+    constexpr wide_integer<Bits, Signed> & operator+=(const Arithmetic & rhs) noexcept(is_same<Signed, unsigned>::value);
+
+    template <typename Arithmetic>
+    constexpr wide_integer<Bits, Signed> & operator-=(const Arithmetic & rhs) noexcept(is_same<Signed, unsigned>::value);
+
+    template <typename Integral>
+    constexpr wide_integer<Bits, Signed> & operator%=(const Integral & rhs);
+
+    template <typename Integral>
+    constexpr wide_integer<Bits, Signed> & operator&=(const Integral & rhs) noexcept;
+
+    template <typename Integral>
+    constexpr wide_integer<Bits, Signed> & operator|=(const Integral & rhs) noexcept;
+
+    template <typename Integral>
+    constexpr wide_integer<Bits, Signed> & operator^=(const Integral & rhs) noexcept;
+
+    constexpr wide_integer<Bits, Signed> & operator<<=(int n);
+    constexpr wide_integer<Bits, Signed> & operator>>=(int n) noexcept;
+
+    constexpr wide_integer<Bits, Signed> & operator++() noexcept(is_same<Signed, unsigned>::value);
+    constexpr wide_integer<Bits, Signed> operator++(int) noexcept(is_same<Signed, unsigned>::value);
+    constexpr wide_integer<Bits, Signed> & operator--() noexcept(is_same<Signed, unsigned>::value);
+    constexpr wide_integer<Bits, Signed> operator--(int) noexcept(is_same<Signed, unsigned>::value);
+
+    // observers
+
+    constexpr explicit operator bool() const noexcept;
+
+    template <class T>
+    using __integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;
+
+    template <class T, class = __integral_not_wide_integer_class<T>>
+    constexpr operator T() const noexcept;
+
+    constexpr operator long double() const noexcept;
+    constexpr operator double() const noexcept;
+    constexpr operator float() const noexcept;
+
+    struct _impl;
+
+private:
+    template <size_t Bits2, typename Signed2>
+    friend class wide_integer;
+
+    friend class numeric_limits<wide_integer<Bits, signed>>;
+    friend class numeric_limits<wide_integer<Bits, unsigned>>;
+
+    base_type m_arr[_impl::arr_size];
+};
+
+template <typename T>
+static constexpr bool ArithmeticConcept() noexcept;
+template <class T1, class T2>
+using __only_arithmetic = typename std::enable_if<ArithmeticConcept<T1>() && ArithmeticConcept<T2>()>::type;
+
+template <typename T>
+static constexpr bool IntegralConcept() noexcept;
+template <class T, class T2>
+using __only_integer = typename std::enable_if<IntegralConcept<T>() && IntegralConcept<T2>()>::type;
+
+// Unary operators
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator~(const wide_integer<Bits, Signed> & lhs) noexcept;
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator-(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value);
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator+(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value);
+
+// Binary operators
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator*(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator*(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator/(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator/(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator+(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator+(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator-(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator-(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator%(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+std::common_type_t<Integral, Integral2> constexpr operator%(const Integral & rhs, const Integral2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator&(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+std::common_type_t<Integral, Integral2> constexpr operator&(const Integral & rhs, const Integral2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator|(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+std::common_type_t<Integral, Integral2> constexpr operator|(const Integral & rhs, const Integral2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator^(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+std::common_type_t<Integral, Integral2> constexpr operator^(const Integral & rhs, const Integral2 & lhs);
+
+// TODO: Integral
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator<<(const wide_integer<Bits, Signed> & lhs, int n) noexcept;
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator>>(const wide_integer<Bits, Signed> & lhs, int n) noexcept;
+
+template <size_t Bits, typename Signed, typename Int, typename = std::enable_if_t<!std::is_same_v<Int, int>>>
+constexpr wide_integer<Bits, Signed> operator<<(const wide_integer<Bits, Signed> & lhs, Int n) noexcept
+{
+    return lhs << int(n);
+}
+template <size_t Bits, typename Signed, typename Int, typename = std::enable_if_t<!std::is_same_v<Int, int>>>
+constexpr wide_integer<Bits, Signed> operator>>(const wide_integer<Bits, Signed> & lhs, Int n) noexcept
+{
+    return lhs >> int(n);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator<(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+constexpr bool operator<(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator>(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+constexpr bool operator>(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator<=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+constexpr bool operator<=(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator>=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+constexpr bool operator>=(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator==(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+constexpr bool operator==(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator!=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs);
+template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+constexpr bool operator!=(const Arithmetic & rhs, const Arithmetic2 & lhs);
+
+template <size_t Bits, typename Signed>
+std::string to_string(const wide_integer<Bits, Signed> & n);
+
+template <size_t Bits, typename Signed>
+struct hash<wide_integer<Bits, Signed>>;
+
+}
+
+#include "wide_integer_impl.h"
diff --git a/base/common/wide_integer_impl.h b/base/common/wide_integer_impl.h
new file mode 100644
index 000000000000..c77a9120a55a
--- /dev/null
+++ b/base/common/wide_integer_impl.h
@@ -0,0 +1,1301 @@
+/// Original is here https://github.com/cerevra/int
+#pragma once
+
+#include "wide_integer.h"
+
+#include <array>
+#include <cstring>
+
+namespace std
+{
+#define CT(x) \
+    std::common_type_t<std::decay_t<decltype(rhs)>, std::decay_t<decltype(lhs)>> { x }
+
+// numeric limits
+template <size_t Bits, typename Signed>
+class numeric_limits<wide_integer<Bits, Signed>>
+{
+public:
+    static constexpr bool is_specialized = true;
+    static constexpr bool is_signed = is_same<Signed, signed>::value;
+    static constexpr bool is_integer = true;
+    static constexpr bool is_exact = true;
+    static constexpr bool has_infinity = false;
+    static constexpr bool has_quiet_NaN = false;
+    static constexpr bool has_signaling_NaN = true;
+    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;
+    static constexpr bool has_denorm_loss = false;
+    static constexpr std::float_round_style round_style = std::round_toward_zero;
+    static constexpr bool is_iec559 = false;
+    static constexpr bool is_bounded = true;
+    static constexpr bool is_modulo = true;
+    static constexpr int digits = Bits - (is_same<Signed, signed>::value ? 1 : 0);
+    static constexpr int digits10 = digits * 0.30103 /*std::log10(2)*/;
+    static constexpr int max_digits10 = 0;
+    static constexpr int radix = 2;
+    static constexpr int min_exponent = 0;
+    static constexpr int min_exponent10 = 0;
+    static constexpr int max_exponent = 0;
+    static constexpr int max_exponent10 = 0;
+    static constexpr bool traps = true;
+    static constexpr bool tinyness_before = false;
+
+    static constexpr wide_integer<Bits, Signed> min() noexcept
+    {
+        if (is_same<Signed, signed>::value)
+        {
+            using T = wide_integer<Bits, signed>;
+            T res{};
+            res.m_arr[T::_impl::big(0)] = std::numeric_limits<typename wide_integer<Bits, Signed>::signed_base_type>::min();
+            return res;
+        }
+        return 0;
+    }
+
+    static constexpr wide_integer<Bits, Signed> max() noexcept
+    {
+        using T = wide_integer<Bits, Signed>;
+        T res{};
+        res.m_arr[T::_impl::big(0)] = is_same<Signed, signed>::value
+            ? std::numeric_limits<typename wide_integer<Bits, Signed>::signed_base_type>::max()
+            : std::numeric_limits<typename wide_integer<Bits, Signed>::base_type>::max();
+        for (int i = 1; i < wide_integer<Bits, Signed>::_impl::arr_size; ++i)
+        {
+            res.m_arr[T::_impl::big(i)] = std::numeric_limits<typename wide_integer<Bits, Signed>::base_type>::max();
+        }
+        return res;
+    }
+
+    static constexpr wide_integer<Bits, Signed> lowest() noexcept { return min(); }
+    static constexpr wide_integer<Bits, Signed> epsilon() noexcept { return 0; }
+    static constexpr wide_integer<Bits, Signed> round_error() noexcept { return 0; }
+    static constexpr wide_integer<Bits, Signed> infinity() noexcept { return 0; }
+    static constexpr wide_integer<Bits, Signed> quiet_NaN() noexcept { return 0; }
+    static constexpr wide_integer<Bits, Signed> signaling_NaN() noexcept { return 0; }
+    static constexpr wide_integer<Bits, Signed> denorm_min() noexcept { return 0; }
+};
+
+template <typename T>
+struct IsWideInteger
+{
+    static const constexpr bool value = false;
+};
+
+template <size_t Bits, typename Signed>
+struct IsWideInteger<wide_integer<Bits, Signed>>
+{
+    static const constexpr bool value = true;
+};
+
+template <typename T>
+static constexpr bool ArithmeticConcept() noexcept
+{
+    return std::is_arithmetic_v<T> || IsWideInteger<T>::value;
+}
+
+template <typename T>
+static constexpr bool IntegralConcept() noexcept
+{
+    return std::is_integral_v<T> || IsWideInteger<T>::value;
+}
+
+// type traits
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+struct common_type<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>
+{
+    using type = std::conditional_t < Bits == Bits2,
+          wide_integer<
+              Bits,
+              std::conditional_t<(std::is_same<Signed, Signed2>::value && std::is_same<Signed2, signed>::value), signed, unsigned>>,
+          std::conditional_t<Bits2<Bits, wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>>;
+};
+
+template <size_t Bits, typename Signed, typename Arithmetic>
+struct common_type<wide_integer<Bits, Signed>, Arithmetic>
+{
+    static_assert(ArithmeticConcept<Arithmetic>(), "");
+
+    using type = std::conditional_t<
+        std::is_floating_point<Arithmetic>::value,
+        Arithmetic,
+        std::conditional_t<
+            sizeof(Arithmetic) < Bits * sizeof(long),
+            wide_integer<Bits, Signed>,
+            std::conditional_t<
+                Bits * sizeof(long) < sizeof(Arithmetic),
+                Arithmetic,
+                std::conditional_t<
+                    Bits * sizeof(long) == sizeof(Arithmetic) && (is_same<Signed, signed>::value || std::is_signed<Arithmetic>::value),
+                    Arithmetic,
+                    wide_integer<Bits, Signed>>>>>;
+};
+
+template <typename Arithmetic, size_t Bits, typename Signed>
+struct common_type<Arithmetic, wide_integer<Bits, Signed>> : std::common_type<wide_integer<Bits, Signed>, Arithmetic>
+{
+};
+
+template <size_t Bits, typename Signed>
+struct wide_integer<Bits, Signed>::_impl
+{
+    static_assert(Bits % CHAR_BIT == 0, "=)");
+
+    // utils
+    static const int base_bits = sizeof(base_type) * CHAR_BIT;
+    static const int arr_size = Bits / base_bits;
+    static constexpr size_t _Bits = Bits;
+    static constexpr bool _is_wide_integer = true;
+
+    // The original implementation is big-endian. We need little one.
+    static constexpr unsigned little(unsigned idx) { return idx; }
+    static constexpr unsigned big(unsigned idx) { return arr_size - 1 - idx; }
+    static constexpr unsigned any(unsigned idx) { return idx; }
+
+    template <size_t B, class T>
+    constexpr static bool is_negative(const wide_integer<B, T> & n) noexcept
+    {
+        if constexpr (std::is_same_v<T, signed>)
+            return static_cast<signed_base_type>(n.m_arr[big(0)]) < 0;
+        else
+            return false;
+    }
+
+    template <size_t B, class S>
+    constexpr static wide_integer<B, S> make_positive(const wide_integer<B, S> & n) noexcept
+    {
+        return is_negative(n) ? operator_unary_minus(n) : n;
+    }
+
+    template <typename T>
+    constexpr static auto to_Integral(T f) noexcept
+    {
+        if constexpr (std::is_same_v<T, __int128>)
+            return f;
+        else if constexpr (std::is_signed_v<T>)
+            return static_cast<int64_t>(f);
+        else
+            return static_cast<uint64_t>(f);
+    }
+
+    template <typename Integral>
+    constexpr static void wide_integer_from_bultin(wide_integer<Bits, Signed> & self, Integral rhs) noexcept
+    {
+        auto r = _impl::to_Integral(rhs);
+
+        int r_idx = 0;
+        for (; static_cast<size_t>(r_idx) < sizeof(Integral) && r_idx < arr_size; ++r_idx)
+        {
+            base_type & curr = self.m_arr[little(r_idx)];
+            base_type curr_rhs = (r >> (r_idx * CHAR_BIT)) & std::numeric_limits<base_type>::max();
+            curr = curr_rhs;
+        }
+
+        for (; r_idx < arr_size; ++r_idx)
+        {
+            base_type & curr = self.m_arr[little(r_idx)];
+            curr = r < 0 ? std::numeric_limits<base_type>::max() : 0;
+        }
+    }
+
+    constexpr static void wide_integer_from_bultin(wide_integer<Bits, Signed> & self, double rhs) noexcept
+    {
+        if ((rhs > 0 && rhs < std::numeric_limits<uint64_t>::max()) || (rhs < 0 && rhs > std::numeric_limits<int64_t>::min()))
+        {
+            self = to_Integral(rhs);
+            return;
+        }
+
+        long double r = rhs;
+        if (r < 0)
+            r = -r;
+
+        size_t count = r / std::numeric_limits<uint64_t>::max();
+        self = count;
+        self *= std::numeric_limits<uint64_t>::max();
+        long double to_diff = count;
+        to_diff *= std::numeric_limits<uint64_t>::max();
+
+        self += to_Integral(r - to_diff);
+
+        if (rhs < 0)
+            self = -self;
+    }
+
+    template <size_t Bits2, typename Signed2>
+    constexpr static void
+    wide_integer_from_wide_integer(wide_integer<Bits, Signed> & self, const wide_integer<Bits2, Signed2> & rhs) noexcept
+    {
+        //        int Bits_to_copy = std::min(arr_size, rhs.arr_size);
+        auto rhs_arr_size = wide_integer<Bits2, Signed2>::_impl::arr_size;
+        int base_elems_to_copy = _impl::arr_size < rhs_arr_size ? _impl::arr_size : rhs_arr_size;
+        for (int i = 0; i < base_elems_to_copy; ++i)
+        {
+            self.m_arr[little(i)] = rhs.m_arr[little(i)];
+        }
+        for (int i = 0; i < arr_size - base_elems_to_copy; ++i)
+        {
+            self.m_arr[big(i)] = is_negative(rhs) ? std::numeric_limits<base_type>::max() : 0;
+        }
+    }
+
+    template <typename T>
+    constexpr static bool should_keep_size()
+    {
+        return sizeof(T) * CHAR_BIT <= Bits;
+    }
+
+    constexpr static wide_integer<Bits, unsigned> shift_left(const wide_integer<Bits, unsigned> & rhs, int n)
+    {
+        if (static_cast<size_t>(n) >= base_bits * arr_size)
+            return 0;
+        if (n <= 0)
+            return rhs;
+
+        wide_integer<Bits, Signed> lhs = rhs;
+        int bit_shift = n % base_bits;
+        unsigned n_bytes = n / base_bits;
+        if (bit_shift)
+        {
+            lhs.m_arr[big(0)] <<= bit_shift;
+            for (int i = 1; i < arr_size; ++i)
+            {
+                lhs.m_arr[big(i - 1)] |= lhs.m_arr[big(i)] >> (base_bits - bit_shift);
+                lhs.m_arr[big(i)] <<= bit_shift;
+            }
+        }
+        if (n_bytes)
+        {
+            for (unsigned i = 0; i < arr_size - n_bytes; ++i)
+            {
+                lhs.m_arr[big(i)] = lhs.m_arr[big(i + n_bytes)];
+            }
+            for (unsigned i = arr_size - n_bytes; i < arr_size; ++i)
+                lhs.m_arr[big(i)] = 0;
+        }
+        return lhs;
+    }
+
+    constexpr static wide_integer<Bits, signed> shift_left(const wide_integer<Bits, signed> & rhs, int n)
+    {
+        // static_assert(is_negative(rhs), "shift left for negative lhsbers is underfined!");
+        if (is_negative(rhs))
+            throw std::runtime_error("shift left for negative lhsbers is underfined!");
+
+        return wide_integer<Bits, signed>(shift_left(wide_integer<Bits, unsigned>(rhs), n));
+    }
+
+    constexpr static wide_integer<Bits, unsigned> shift_right(const wide_integer<Bits, unsigned> & rhs, int n) noexcept
+    {
+        if (static_cast<size_t>(n) >= base_bits * arr_size)
+            return 0;
+        if (n <= 0)
+            return rhs;
+
+        wide_integer<Bits, Signed> lhs = rhs;
+        int bit_shift = n % base_bits;
+        unsigned n_bytes = n / base_bits;
+        if (bit_shift)
+        {
+            lhs.m_arr[little(0)] >>= bit_shift;
+            for (int i = 1; i < arr_size; ++i)
+            {
+                lhs.m_arr[little(i - 1)] |= lhs.m_arr[little(i)] << (base_bits - bit_shift);
+                lhs.m_arr[little(i)] >>= bit_shift;
+            }
+        }
+        if (n_bytes)
+        {
+            for (unsigned i = 0; i < arr_size - n_bytes; ++i)
+            {
+                lhs.m_arr[little(i)] = lhs.m_arr[little(i + n_bytes)];
+            }
+            for (unsigned i = arr_size - n_bytes; i < arr_size; ++i)
+                lhs.m_arr[little(i)] = 0;
+        }
+        return lhs;
+    }
+
+    constexpr static wide_integer<Bits, signed> shift_right(const wide_integer<Bits, signed> & rhs, int n) noexcept
+    {
+        if (static_cast<size_t>(n) >= base_bits * arr_size)
+            return 0;
+        if (n <= 0)
+            return rhs;
+
+        bool is_neg = is_negative(rhs);
+        if (!is_neg)
+            return shift_right(wide_integer<Bits, unsigned>(rhs), n);
+
+        wide_integer<Bits, Signed> lhs = rhs;
+        int bit_shift = n % base_bits;
+        unsigned n_bytes = n / base_bits;
+        if (bit_shift)
+        {
+            lhs = shift_right(wide_integer<Bits, unsigned>(lhs), bit_shift);
+            lhs.m_arr[big(0)] |= std::numeric_limits<base_type>::max() << (base_bits - bit_shift);
+        }
+        if (n_bytes)
+        {
+            for (unsigned i = 0; i < arr_size - n_bytes; ++i)
+            {
+                lhs.m_arr[little(i)] = lhs.m_arr[little(i + n_bytes)];
+            }
+            for (unsigned i = arr_size - n_bytes; i < arr_size; ++i)
+            {
+                lhs.m_arr[little(i)] = std::numeric_limits<base_type>::max();
+            }
+        }
+        return lhs;
+    }
+
+    template <typename T>
+    constexpr static wide_integer<Bits, Signed>
+    operator_plus_T(const wide_integer<Bits, Signed> & lhs, T rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        if (rhs < 0)
+            return _operator_minus_T(lhs, -rhs);
+        else
+            return _operator_plus_T(lhs, rhs);
+    }
+
+private:
+    template <typename T>
+    constexpr static wide_integer<Bits, Signed>
+    _operator_minus_T(const wide_integer<Bits, Signed> & lhs, T rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        wide_integer<Bits, Signed> res = lhs;
+
+        bool is_underflow = false;
+        int r_idx = 0;
+        for (; static_cast<size_t>(r_idx) < sizeof(T) && r_idx < arr_size; ++r_idx)
+        {
+            base_type & res_i = res.m_arr[little(r_idx)];
+            base_type curr_rhs = (rhs >> (r_idx * CHAR_BIT)) & std::numeric_limits<base_type>::max();
+
+            if (is_underflow)
+            {
+                --res_i;
+                is_underflow = res_i == std::numeric_limits<base_type>::max();
+            }
+
+            if (res_i < curr_rhs)
+                is_underflow = true;
+            res_i -= curr_rhs;
+        }
+
+        if (is_underflow && r_idx < arr_size)
+        {
+            --res.m_arr[little(r_idx)];
+            for (int i = arr_size - 1 - r_idx - 1; i >= 0; --i)
+            {
+                if (res.m_arr[big(i + 1)] == std::numeric_limits<base_type>::max())
+                    --res.m_arr[big(i)];
+                else
+                    break;
+            }
+        }
+
+        return res;
+    }
+
+    template <typename T>
+    constexpr static wide_integer<Bits, Signed>
+    _operator_plus_T(const wide_integer<Bits, Signed> & lhs, T rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        wide_integer<Bits, Signed> res = lhs;
+
+        bool is_overflow = false;
+        int r_idx = 0;
+        for (; static_cast<size_t>(r_idx) < sizeof(T) && r_idx < arr_size; ++r_idx)
+        {
+            base_type & res_i = res.m_arr[little(r_idx)];
+            base_type curr_rhs = (rhs >> (r_idx * CHAR_BIT)) & std::numeric_limits<base_type>::max();
+
+            if (is_overflow)
+            {
+                ++res_i;
+                is_overflow = res_i == 0;
+            }
+
+            res_i += curr_rhs;
+            if (res_i < curr_rhs)
+                is_overflow = true;
+        }
+
+        if (is_overflow && r_idx < arr_size)
+        {
+            ++res.m_arr[little(r_idx)];
+            for (int i = arr_size - 1 - r_idx - 1; i >= 0; --i)
+            {
+                if (res.m_arr[big(i + 1)] == 0)
+                    ++res.m_arr[big(i)];
+                else
+                    break;
+            }
+        }
+
+        return res;
+    }
+
+public:
+    constexpr static wide_integer<Bits, Signed> operator_unary_tilda(const wide_integer<Bits, Signed> & lhs) noexcept
+    {
+        wide_integer<Bits, Signed> res{};
+
+        for (int i = 0; i < arr_size; ++i)
+            res.m_arr[any(i)] = ~lhs.m_arr[any(i)];
+        return res;
+    }
+
+    constexpr static wide_integer<Bits, Signed>
+    operator_unary_minus(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        return operator_plus_T(operator_unary_tilda(lhs), 1);
+    }
+
+    template <typename T>
+    constexpr static auto operator_plus(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> t = rhs;
+            if (is_negative(t))
+                return _operator_minus_wide_integer(lhs, operator_unary_minus(t));
+            else
+                return _operator_plus_wide_integer(lhs, t);
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::_impl::operator_plus(
+                wide_integer<T::_impl::_Bits, Signed>(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static auto operator_minus(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> t = rhs;
+            if (is_negative(t))
+                return _operator_plus_wide_integer(lhs, operator_unary_minus(t));
+            else
+                return _operator_minus_wide_integer(lhs, t);
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::_impl::operator_minus(
+                wide_integer<T::_impl::_Bits, Signed>(lhs), rhs);
+        }
+    }
+
+private:
+    constexpr static wide_integer<Bits, Signed> _operator_minus_wide_integer(
+        const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits, Signed> & rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        wide_integer<Bits, Signed> res = lhs;
+
+        bool is_underflow = false;
+        for (int idx = 0; idx < arr_size; ++idx)
+        {
+            base_type & res_i = res.m_arr[little(idx)];
+            const base_type rhs_i = rhs.m_arr[little(idx)];
+
+            if (is_underflow)
+            {
+                --res_i;
+                is_underflow = res_i == std::numeric_limits<base_type>::max();
+            }
+
+            if (res_i < rhs_i)
+                is_underflow = true;
+
+            res_i -= rhs_i;
+        }
+
+        return res;
+    }
+
+    constexpr static wide_integer<Bits, Signed> _operator_plus_wide_integer(
+        const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits, Signed> & rhs) noexcept(is_same<Signed, unsigned>::value)
+    {
+        wide_integer<Bits, Signed> res = lhs;
+
+        bool is_overflow = false;
+        for (int idx = 0; idx < arr_size; ++idx)
+        {
+            base_type & res_i = res.m_arr[little(idx)];
+            const base_type rhs_i = rhs.m_arr[little(idx)];
+
+            if (is_overflow)
+            {
+                ++res_i;
+                is_overflow = res_i == 0;
+            }
+
+            res_i += rhs_i;
+
+            if (res_i < rhs_i)
+                is_overflow = true;
+        }
+
+        return res;
+    }
+
+public:
+    template <typename T>
+    constexpr static auto operator_star(const wide_integer<Bits, Signed> & lhs, const T & rhs)
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            const wide_integer<Bits, unsigned> a = make_positive(lhs);
+            wide_integer<Bits, unsigned> t = make_positive(wide_integer<Bits, Signed>(rhs));
+
+            wide_integer<Bits, Signed> res = 0;
+
+            for (size_t i = 0; i < arr_size * base_bits; ++i)
+            {
+                if (t.m_arr[little(0)] & 1)
+                    res = operator_plus(res, shift_left(a, i));
+
+                t = shift_right(t, 1);
+            }
+
+            if (is_same<Signed, signed>::value && is_negative(wide_integer<Bits, Signed>(rhs)) != is_negative(lhs))
+                res = operator_unary_minus(res);
+
+            return res;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_star(T(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static bool operator_more(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            // static_assert(Signed == std::is_signed<T>::value,
+            //               "warning: operator_more: comparison of integers of different signs");
+
+            wide_integer<Bits, Signed> t = rhs;
+
+            if (std::numeric_limits<T>::is_signed && (is_negative(lhs) != is_negative(t)))
+                return is_negative(t);
+
+            for (int i = 0; i < arr_size; ++i)
+            {
+                if (lhs.m_arr[big(i)] != t.m_arr[big(i)])
+                    return lhs.m_arr[big(i)] > t.m_arr[big(i)];
+            }
+
+            return false;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_more(T(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static bool operator_less(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            // static_assert(Signed == std::is_signed<T>::value,
+            //               "warning: operator_less: comparison of integers of different signs");
+
+            wide_integer<Bits, Signed> t = rhs;
+
+            if (std::numeric_limits<T>::is_signed && (is_negative(lhs) != is_negative(t)))
+                return is_negative(lhs);
+
+            for (int i = 0; i < arr_size; ++i)
+                if (lhs.m_arr[big(i)] != t.m_arr[big(i)])
+                    return lhs.m_arr[big(i)] < t.m_arr[big(i)];
+
+            return false;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_less(T(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static bool operator_eq(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> t = rhs;
+
+            for (int i = 0; i < arr_size; ++i)
+                if (lhs.m_arr[any(i)] != t.m_arr[any(i)])
+                    return false;
+
+            return true;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_eq(T(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static auto operator_pipe(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> t = rhs;
+            wide_integer<Bits, Signed> res = lhs;
+
+            for (int i = 0; i < arr_size; ++i)
+                res.m_arr[any(i)] |= t.m_arr[any(i)];
+            return res;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_pipe(T(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static auto operator_amp(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> t = rhs;
+            wide_integer<Bits, Signed> res = lhs;
+
+            for (int i = 0; i < arr_size; ++i)
+                res.m_arr[any(i)] &= t.m_arr[any(i)];
+            return res;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, T>::_impl::operator_amp(T(lhs), rhs);
+        }
+    }
+
+private:
+    template <typename T>
+    constexpr static void divide(const T & lhserator, const T & denominator, T & quotient, T & remainder)
+    {
+        bool is_zero = true;
+        for (auto c : denominator.m_arr)
+        {
+            if (c != 0)
+            {
+                is_zero = false;
+                break;
+            }
+        }
+
+        if (is_zero)
+            throw std::domain_error("divide by zero");
+
+        T n = lhserator;
+        T d = denominator;
+        T x = 1;
+        T answer = 0;
+
+        while (!operator_more(d, n) && operator_eq(operator_amp(shift_right(d, base_bits * arr_size - 1), 1), 0))
+        {
+            x = shift_left(x, 1);
+            d = shift_left(d, 1);
+        }
+
+        while (!operator_eq(x, 0))
+        {
+            if (!operator_more(d, n))
+            {
+                n = operator_minus(n, d);
+                answer = operator_pipe(answer, x);
+            }
+
+            x = shift_right(x, 1);
+            d = shift_right(d, 1);
+        }
+
+        quotient = answer;
+        remainder = n;
+    }
+
+public:
+    template <typename T>
+    constexpr static auto operator_slash(const wide_integer<Bits, Signed> & lhs, const T & rhs)
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> o = rhs;
+            wide_integer<Bits, Signed> quotient{}, remainder{};
+            divide(make_positive(lhs), make_positive(o), quotient, remainder);
+
+            if (is_same<Signed, signed>::value && is_negative(o) != is_negative(lhs))
+                quotient = operator_unary_minus(quotient);
+
+            return quotient;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::operator_slash(T(lhs), rhs);
+        }
+    }
+
+    template <typename T>
+    constexpr static auto operator_percent(const wide_integer<Bits, Signed> & lhs, const T & rhs)
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> o = rhs;
+            wide_integer<Bits, Signed> quotient{}, remainder{};
+            divide(make_positive(lhs), make_positive(o), quotient, remainder);
+
+            if (is_same<Signed, signed>::value && is_negative(lhs))
+                remainder = operator_unary_minus(remainder);
+
+            return remainder;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<T::_impl::_Bits, Signed>>::operator_percent(T(lhs), rhs);
+        }
+    }
+
+    // ^
+    template <typename T>
+    constexpr static auto operator_circumflex(const wide_integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    {
+        if constexpr (should_keep_size<T>())
+        {
+            wide_integer<Bits, Signed> t(rhs);
+            wide_integer<Bits, Signed> res = lhs;
+
+            for (int i = 0; i < arr_size; ++i)
+                res.m_arr[any(i)] ^= t.m_arr[any(i)];
+            return res;
+        }
+        else
+        {
+            static_assert(T::_impl::_is_wide_integer, "");
+            return T::operator_circumflex(T(lhs), rhs);
+        }
+    }
+
+    constexpr static wide_integer<Bits, Signed> from_str(const char * c)
+    {
+        wide_integer<Bits, Signed> res = 0;
+
+        bool is_neg = is_same<Signed, signed>::value && *c == '-';
+        if (is_neg)
+            ++c;
+
+        if (*c == '0' && (*(c + 1) == 'x' || *(c + 1) == 'X'))
+        { // hex
+            ++c;
+            ++c;
+            while (*c)
+            {
+                if (*c >= '0' && *c <= '9')
+                {
+                    res = operator_star(res, 16U);
+                    res = operator_plus_T(res, *c - '0');
+                    ++c;
+                }
+                else if (*c >= 'a' && *c <= 'f')
+                {
+                    res = operator_star(res, 16U);
+                    res = operator_plus_T(res, *c - 'a' + 10U);
+                    ++c;
+                }
+                else if (*c >= 'A' && *c <= 'F')
+                { // tolower must be used, but it is not constexpr
+                    res = operator_star(res, 16U);
+                    res = operator_plus_T(res, *c - 'A' + 10U);
+                    ++c;
+                }
+                else
+                    throw std::runtime_error("invalid char from");
+            }
+        }
+        else
+        { // dec
+            while (*c)
+            {
+                if (*c < '0' || *c > '9')
+                    throw std::runtime_error("invalid char from");
+
+                res = operator_star(res, 10U);
+                res = operator_plus_T(res, *c - '0');
+                ++c;
+            }
+        }
+
+        if (is_neg)
+            res = operator_unary_minus(res);
+
+        return res;
+    }
+};
+
+// Members
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed>::wide_integer(T rhs) noexcept
+    : m_arr{}
+{
+    if constexpr (IsWideInteger<T>::value)
+        _impl::wide_integer_from_wide_integer(*this, rhs);
+    else
+        _impl::wide_integer_from_bultin(*this, rhs);
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed>::wide_integer(std::initializer_list<T> il) noexcept
+    : m_arr{}
+{
+    if (il.size() == 1)
+    {
+        if constexpr (IsWideInteger<T>::value)
+            _impl::wide_integer_from_wide_integer(*this, *il.begin());
+        else
+            _impl::wide_integer_from_bultin(*this, *il.begin());
+    }
+    else
+        _impl::wide_integer_from_bultin(*this, 0);
+}
+
+template <size_t Bits, typename Signed>
+template <size_t Bits2, typename Signed2>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator=(const wide_integer<Bits2, Signed2> & rhs) noexcept
+{
+    _impl::wide_integer_from_wide_integer(*this, rhs);
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator=(T rhs) noexcept
+{
+    _impl::wide_integer_from_bultin(*this, rhs);
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator*=(const T & rhs)
+{
+    *this = *this * rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator/=(const T & rhs)
+{
+    *this = *this / rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator+=(const T & rhs) noexcept(is_same<Signed, unsigned>::value)
+{
+    *this = *this + rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator-=(const T & rhs) noexcept(is_same<Signed, unsigned>::value)
+{
+    *this = *this - rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator%=(const T & rhs)
+{
+    *this = *this % rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator&=(const T & rhs) noexcept
+{
+    *this = *this & rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator|=(const T & rhs) noexcept
+{
+    *this = *this | rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+template <typename T>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator^=(const T & rhs) noexcept
+{
+    *this = *this ^ rhs;
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator<<=(int n)
+{
+    *this = _impl::shift_left(*this, n);
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator>>=(int n) noexcept
+{
+    *this = _impl::shift_right(*this, n);
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator++() noexcept(is_same<Signed, unsigned>::value)
+{
+    *this = _impl::operator_plus(*this, 1);
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> wide_integer<Bits, Signed>::operator++(int) noexcept(is_same<Signed, unsigned>::value)
+{
+    auto tmp = *this;
+    *this = _impl::operator_plus(*this, 1);
+    return tmp;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> & wide_integer<Bits, Signed>::operator--() noexcept(is_same<Signed, unsigned>::value)
+{
+    *this = _impl::operator_minus(*this, 1);
+    return *this;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> wide_integer<Bits, Signed>::operator--(int) noexcept(is_same<Signed, unsigned>::value)
+{
+    auto tmp = *this;
+    *this = _impl::operator_minus(*this, 1);
+    return tmp;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed>::operator bool() const noexcept
+{
+    return !_impl::operator_eq(*this, 0);
+}
+
+template <size_t Bits, typename Signed>
+template <class T, class>
+constexpr wide_integer<Bits, Signed>::operator T() const noexcept
+{
+    static_assert(std::numeric_limits<T>::is_integer, "");
+    T res = 0;
+    for (size_t r_idx = 0; r_idx < _impl::arr_size && r_idx < sizeof(T); ++r_idx)
+    {
+        res |= (T(m_arr[_impl::little(r_idx)]) << (_impl::base_bits * r_idx));
+    }
+    return res;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed>::operator long double() const noexcept
+{
+    if (_impl::operator_eq(*this, 0))
+        return 0;
+
+    wide_integer<Bits, Signed> tmp = *this;
+    if (_impl::is_negative(*this))
+        tmp = -tmp;
+
+    long double res = 0;
+    for (size_t idx = 0; idx < _impl::arr_size; ++idx)
+    {
+        long double t = res;
+        res *= std::numeric_limits<base_type>::max();
+        res += t;
+        res += tmp.m_arr[_impl::big(idx)];
+    }
+
+    if (_impl::is_negative(*this))
+        res = -res;
+
+    return res;
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed>::operator double() const noexcept
+{
+    return static_cast<long double>(*this);
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed>::operator float() const noexcept
+{
+    return static_cast<long double>(*this);
+}
+
+// Unary operators
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator~(const wide_integer<Bits, Signed> & lhs) noexcept
+{
+    return wide_integer<Bits, Signed>::_impl::operator_unary_tilda(lhs);
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator-(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value)
+{
+    return wide_integer<Bits, Signed>::_impl::operator_unary_minus(lhs);
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator+(const wide_integer<Bits, Signed> & lhs) noexcept(is_same<Signed, unsigned>::value)
+{
+    return lhs;
+}
+
+// Binary operators
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator*(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_star(lhs, rhs);
+}
+
+template <typename Arithmetic, typename Arithmetic2, class>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator*(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) * CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator/(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_slash(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator/(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) / CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator+(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_plus(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator+(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) + CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator-(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_minus(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+std::common_type_t<Arithmetic, Arithmetic2> constexpr operator-(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) - CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator%(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_percent(lhs, rhs);
+}
+template <typename Integral, typename Integral2, class>
+std::common_type_t<Integral, Integral2> constexpr operator%(const Integral & lhs, const Integral2 & rhs)
+{
+    return CT(lhs) % CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator&(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_amp(lhs, rhs);
+}
+template <typename Integral, typename Integral2, class>
+std::common_type_t<Integral, Integral2> constexpr operator&(const Integral & lhs, const Integral2 & rhs)
+{
+    return CT(lhs) & CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator|(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_pipe(lhs, rhs);
+}
+template <typename Integral, typename Integral2, class>
+std::common_type_t<Integral, Integral2> constexpr operator|(const Integral & lhs, const Integral2 & rhs)
+{
+    return CT(lhs) | CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>> constexpr
+operator^(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_circumflex(lhs, rhs);
+}
+template <typename Integral, typename Integral2, class>
+std::common_type_t<Integral, Integral2> constexpr operator^(const Integral & lhs, const Integral2 & rhs)
+{
+    return CT(lhs) ^ CT(rhs);
+}
+
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator<<(const wide_integer<Bits, Signed> & lhs, int n) noexcept
+{
+    return wide_integer<Bits, Signed>::_impl::shift_left(lhs, n);
+}
+template <size_t Bits, typename Signed>
+constexpr wide_integer<Bits, Signed> operator>>(const wide_integer<Bits, Signed> & lhs, int n) noexcept
+{
+    return wide_integer<Bits, Signed>::_impl::shift_right(lhs, n);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator<(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_less(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+constexpr bool operator<(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) < CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator>(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+constexpr bool operator>(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) > CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator<=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_less(lhs, rhs)
+        || std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+constexpr bool operator<=(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) <= CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator>=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs)
+        || std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+constexpr bool operator>=(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) >= CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator==(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+constexpr bool operator==(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) == CT(rhs);
+}
+
+template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
+constexpr bool operator!=(const wide_integer<Bits, Signed> & lhs, const wide_integer<Bits2, Signed2> & rhs)
+{
+    return !std::common_type_t<wide_integer<Bits, Signed>, wide_integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);
+}
+template <typename Arithmetic, typename Arithmetic2, class>
+constexpr bool operator!=(const Arithmetic & lhs, const Arithmetic2 & rhs)
+{
+    return CT(lhs) != CT(rhs);
+}
+
+template <size_t Bits, typename Signed>
+inline std::string to_string(const wide_integer<Bits, Signed> & n)
+{
+    std::string res;
+    if (wide_integer<Bits, Signed>::_impl::operator_eq(n, 0U))
+        return "0";
+
+    wide_integer<Bits, unsigned> t;
+    bool is_neg = wide_integer<Bits, Signed>::_impl::is_negative(n);
+    if (is_neg)
+        t = wide_integer<Bits, Signed>::_impl::operator_unary_minus(n);
+    else
+        t = n;
+
+    while (!wide_integer<Bits, unsigned>::_impl::operator_eq(t, 0U))
+    {
+        res.insert(res.begin(), '0' + char(wide_integer<Bits, unsigned>::_impl::operator_percent(t, 10U)));
+        t = wide_integer<Bits, unsigned>::_impl::operator_slash(t, 10U);
+    }
+
+    if (is_neg)
+        res.insert(res.begin(), '-');
+    return res;
+}
+
+template <size_t Bits, typename Signed>
+struct hash<wide_integer<Bits, Signed>>
+{
+    std::size_t operator()(const wide_integer<Bits, Signed> & lhs) const
+    {
+        static_assert(Bits % (sizeof(size_t) * 8) == 0);
+
+        const auto * ptr = reinterpret_cast<const size_t *>(lhs.m_arr);
+        unsigned count = Bits / (sizeof(size_t) * 8);
+
+        size_t res = 0;
+        for (unsigned i = 0; i < count; ++i)
+            res ^= ptr[i];
+        return hash<size_t>()(res);
+    }
+};
+
+#undef CT
+}
diff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h
index 11ab294c1a3e..c33ab34b541a 100644
--- a/src/Columns/ColumnDecimal.h
+++ b/src/Columns/ColumnDecimal.h
@@ -126,7 +126,7 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T
 
     bool isNumeric() const override { return false; }
     bool canBeInsideNullable() const override { return true; }
-    bool isFixedAndContiguous() const override { return is_POD; }
+    bool isFixedAndContiguous() const override { return true; }
     size_t sizeOfValueIfFixed() const override { return sizeof(T); }
 
     size_t size() const override { return data.size(); }
diff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h
index d2c4846193ca..1090de556a09 100644
--- a/src/Columns/ColumnVector.h
+++ b/src/Columns/ColumnVector.h
@@ -12,11 +12,6 @@
 namespace DB
 {
 
-namespace ErrorCodes
-{
-    extern const int NOT_IMPLEMENTED;
-}
-
 /** Stuff for comparing numbers.
   * Integer values are compared as usual.
   * Floating-point numbers are compared this way that NaNs always end up at the end
@@ -298,23 +293,17 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>
     void gather(ColumnGathererStream & gatherer_stream) override;
 
     bool canBeInsideNullable() const override { return true; }
-    bool isFixedAndContiguous() const override { return is_POD; }
+    bool isFixedAndContiguous() const override { return true; }
     size_t sizeOfValueIfFixed() const override { return sizeof(T); }
 
     StringRef getRawData() const override
     {
-        if constexpr (is_POD)
-            return StringRef(reinterpret_cast<const char*>(data.data()), byteSize());
-        else
-            throw Exception("getRawData() is not implemented for big integers", ErrorCodes::NOT_IMPLEMENTED);
+        return StringRef(reinterpret_cast<const char*>(data.data()), byteSize());
     }
 
     StringRef getDataAt(size_t n) const override
     {
-        if constexpr (is_POD)
-            return StringRef(reinterpret_cast<const char *>(&data[n]), sizeof(data[n]));
-        else
-            throw Exception("getDataAt() is not implemented for big integers", ErrorCodes::NOT_IMPLEMENTED);
+        return StringRef(reinterpret_cast<const char *>(&data[n]), sizeof(data[n]));
     }
 
     bool structureEquals(const IColumn & rhs) const override
diff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h
index 1d850ab2d327..c561933ab809 100644
--- a/src/Common/HashTable/Hash.h
+++ b/src/Common/HashTable/Hash.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <Core/Types.h>
+#include <Core/BigInt.h>
 #include <Common/UInt128.h>
 #include <common/unaligned.h>
 
@@ -89,8 +90,7 @@ template <typename T>
 inline typename std::enable_if<is_big_int_v<T>, DB::UInt64>::type
 intHashCRC32(const T & x, DB::UInt64 updated_value)
 {
-    std::vector<UInt64> parts;
-    export_bits(x, std::back_inserter(parts), sizeof(UInt64), false);
+    std::vector<UInt64> parts = DB::BigInt<T>::toIntArray(x);
     for (const auto & part : parts)
         updated_value = intHashCRC32(part, updated_value);
 
@@ -199,7 +199,7 @@ inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) > sizeof(UInt64)), T> ke
     {
         return intHash64(key.low ^ key.high);
     }
-    else if constexpr (std::is_same_v<T, bInt256> || std::is_same_v<T, bUInt256>)
+    else if constexpr (is_big_int_v<T> && sizeof(T) == 32)
     {
         return intHash64(static_cast<UInt64>(key) ^
             static_cast<UInt64>(key >> 64) ^
@@ -256,7 +256,7 @@ inline size_t hashCRC32(std::enable_if_t<(sizeof(T) > sizeof(UInt64)), T> key)
     {
         return intHashCRC32(key.low ^ key.high);
     }
-    else if constexpr (std::is_same_v<T, bInt256> || std::is_same_v<T, bUInt256>)
+    else if constexpr (is_big_int_v<T> && sizeof(T) == 32)
     {
         return intHashCRC32(static_cast<UInt64>(key) ^
             static_cast<UInt64>(key >> 64) ^
@@ -358,7 +358,7 @@ struct IntHash32
         {
             return intHash32<salt>(key.low ^ key.high);
         }
-        else if constexpr (std::is_same_v<T, bInt256> || std::is_same_v<T, bUInt256>)
+        else if constexpr (is_big_int_v<T> && sizeof(T) == 32)
         {
             return intHash32<salt>(static_cast<UInt64>(key) ^
                 static_cast<UInt64>(key >> 64) ^
diff --git a/src/Common/SipHash.h b/src/Common/SipHash.h
index df4c09da6d9e..f4f869516523 100644
--- a/src/Common/SipHash.h
+++ b/src/Common/SipHash.h
@@ -148,7 +148,7 @@ class SipHash
     }
 
     template <typename T>
-    std::enable_if_t<is_big_int_v<T>, void> update(const T & x)
+    std::enable_if_t<is_big_int_v<T> && !std::has_unique_object_representations_v<T>, void> update(const T & x)
     {
         update(DB::BigInt<T>::serialize(x));
     }
@@ -213,7 +213,7 @@ std::enable_if_t<std::has_unique_object_representations_v<T>, UInt64> sipHash64(
 }
 
 template <typename T>
-std::enable_if_t<(std::is_floating_point_v<T> || is_big_int_v<T>), UInt64> sipHash64(const T & x)
+std::enable_if_t<(std::is_floating_point_v<T> || (is_big_int_v<T> && !std::has_unique_object_representations_v<T>)), UInt64> sipHash64(const T & x)
 {
     SipHash hash;
     hash.update(x);
diff --git a/src/Common/UInt128.h b/src/Common/UInt128.h
index 2b1177e970c5..3944d8073c26 100644
--- a/src/Common/UInt128.h
+++ b/src/Common/UInt128.h
@@ -67,6 +67,11 @@ struct UInt128
     bool inline operator <= (const Int128 rhs) const { return *this <= UInt128(rhs, rhs >> 64) && rhs >= 0; }
     bool inline operator <  (const Int128 rhs) const { return *this <  UInt128(rhs, rhs >> 64) && rhs >= 0; }
 
+    bool inline operator >  (const Int256 rhs) const { return (rhs < 0) || ((Int256(high) << 64) + low) > rhs; }
+    bool inline operator >  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) > rhs; }
+    bool inline operator <  (const Int256 rhs) const { return (rhs >= 0) && ((Int256(high) << 64) + low) < rhs; }
+    bool inline operator <  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) < rhs; }
+
     template <typename T> bool inline operator== (const T rhs) const { return *this == UInt128(rhs); }
     template <typename T> bool inline operator!= (const T rhs) const { return *this != UInt128(rhs); }
     template <typename T> bool inline operator>= (const T rhs) const { return *this >= UInt128(rhs); }
diff --git a/src/Common/intExp.h b/src/Common/intExp.h
index d585eaa9c675..8a52015c54a5 100644
--- a/src/Common/intExp.h
+++ b/src/Common/intExp.h
@@ -138,9 +138,9 @@ constexpr inline Int128 exp10_i128(int x)
 }
 
 
-inline bInt256 exp10_i256(int x)
+inline wInt256 exp10_i256(int x)
 {
-    using Int256 = bInt256;
+    using Int256 = wInt256;
     static constexpr Int256 i10e18{1000000000000000000ll};
     static const Int256 values[] = {
         static_cast<Int256>(1ll),
diff --git a/src/Core/BigInt.h b/src/Core/BigInt.h
index f1da96d330a2..5abd71100629 100644
--- a/src/Core/BigInt.h
+++ b/src/Core/BigInt.h
@@ -7,46 +7,15 @@ namespace DB
 {
 
 template <typename T>
-struct BigIntPayload
+struct BigInt
 {
-    static_assert(!is_big_int_v<T>);
-    static constexpr size_t size = 0;
-};
-
-template <> struct BigIntPayload<bUInt256> { static constexpr size_t size = 32; };
-
-template <> struct BigIntPayload<bInt256>
-{
-    using UnsingedType = bUInt256;
+    static_assert(sizeof(T) == 32);
     static constexpr size_t size = 32;
-};
-
-template <typename T>
-struct BigInt : BigIntPayload<T>
-{
-    using BigIntPayload<T>::size;
-
-    static constexpr size_t lastBit()
-    {
-        return size * 8 - 1;
-    }
 
     static StringRef serialize(const T & x, char * pos)
     {
-        if constexpr (is_signed_v<T>)
-        {
-            using UnsignedT = typename BigIntPayload<T>::UnsingedType;
-
-            if (x < 0)
-            {
-                UnsignedT unsigned_x = UnsignedT{0} - static_cast<UnsignedT>(-x);
-                export_bits(unsigned_x, pos, 8, false);
-            }
-            else
-                export_bits(x, pos, 8, false);
-        }
-        else
-            export_bits(x, pos, 8, false);
+        //unalignedStore<T>(pos, x);
+        memcpy(pos, &x, size);
         return StringRef(pos, size);
     }
 
@@ -59,24 +28,20 @@ struct BigInt : BigIntPayload<T>
 
     static T deserialize(const char * pos)
     {
-        if constexpr (is_signed_v<T>)
-        {
-            using UnsignedT = typename BigIntPayload<T>::UnsingedType;
-
-            UnsignedT unsigned_x;
-            import_bits(unsigned_x, pos, pos + size, false);
+        //return unalignedLoad<T>(pos);
+        T res;
+        memcpy(&res, pos, size);
+        return res;
+    }
 
-            bool is_negative = bit_test(unsigned_x, lastBit());
-            if (is_negative)
-                unsigned_x = UnsignedT{0} - unsigned_x;
-            return static_cast<T>(unsigned_x);
-        }
-        else
-        {
-            T x;
-            import_bits(x, pos, pos + size, false);
-            return x;
-        }
+    static std::vector<UInt64> toIntArray(const T & x)
+    {
+        std::vector<UInt64> parts(4, 0);
+        parts[0] = UInt64(x);
+        parts[1] = UInt64(x >> 64);
+        parts[2] = UInt64(x >> 128);
+        parts[4] = UInt64(x >> 192);
+        return parts;
     }
 };
 
diff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h
index a43ce8d803cb..939920296347 100644
--- a/src/Core/DecimalComparison.h
+++ b/src/Core/DecimalComparison.h
@@ -226,25 +226,25 @@ class DecimalComparison
     static NO_INLINE UInt8 apply(A a, B b, CompareInt scale [[maybe_unused]])
     {
         CompareInt x;
-        if constexpr (is_big_int_v<CompareInt> && IsDecimalNumber<A>)
+        if constexpr (IsDecimalNumber<A>)
             x = a.value;
         else
-            x = bigint_cast<CompareInt>(a);
+            x = a;
 
         CompareInt y;
-        if constexpr (is_big_int_v<CompareInt> && IsDecimalNumber<B>)
+        if constexpr (IsDecimalNumber<B>)
             y = b.value;
         else
-            y = bigint_cast<CompareInt>(b);
+            y = b;
 
         if constexpr (_check_overflow)
         {
             bool overflow = false;
 
             if constexpr (sizeof(A) > sizeof(CompareInt))
-                overflow |= (A(x) != a);
+                overflow |= (bigint_cast<A>(x) != a);
             if constexpr (sizeof(B) > sizeof(CompareInt))
-                overflow |= (B(y) != b);
+                overflow |= (bigint_cast<B>(y) != b);
             if constexpr (is_unsigned_v<A>)
                 overflow |= (x < 0);
             if constexpr (is_unsigned_v<B>)
diff --git a/src/Core/Types.h b/src/Core/Types.h
index 39c152ce48b7..c23ac4a13795 100644
--- a/src/Core/Types.h
+++ b/src/Core/Types.h
@@ -58,14 +58,14 @@ using UInt8 = ::UInt8;
 using UInt16 = ::UInt16;
 using UInt32 = ::UInt32;
 using UInt64 = ::UInt64;
-using UInt256 = ::bUInt256;
+using UInt256 = ::wUInt256;
 
 using Int8 = ::Int8;
 using Int16 = ::Int16;
 using Int32 = ::Int32;
 using Int64 = ::Int64;
 using Int128 = ::Int128;
-using Int256 = ::bInt256;
+using Int256 = ::wInt256;
 
 using Float32 = float;
 using Float64 = double;
diff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h
index 8c70306ba5d6..603449150dba 100644
--- a/src/DataTypes/NumberTraits.h
+++ b/src/DataTypes/NumberTraits.h
@@ -28,21 +28,13 @@ constexpr size_t min(size_t x, size_t y)
     return x < y ? x : y;
 }
 
+/// @note There's no auto scale to larger big integer, only for integral ones.
+/// It's cause of (U)Int64 backward compatibilty and very big performance penalties.
 constexpr size_t nextSize(size_t size)
 {
-    return min(size * 2, 8);
-}
-
-template <bool is_signed>
-constexpr size_t nextSize2(size_t size)
-{
-    // old way for built-in integers
-    if (size <= 8) return nextSize(size);
-
-    if constexpr (is_signed)
-        return size <= 32 ? 32 : 48;
-    else
-        return size <= 32 ? 16 : 48;
+    if (size < 8)
+        return size * 2;
+    return size;
 }
 
 template <bool is_signed, bool is_floating, size_t size>
@@ -55,9 +47,8 @@ template <> struct Construct<false, false, 1> { using Type = UInt8; };
 template <> struct Construct<false, false, 2> { using Type = UInt16; };
 template <> struct Construct<false, false, 4> { using Type = UInt32; };
 template <> struct Construct<false, false, 8> { using Type = UInt64; };
-template <> struct Construct<false, false, 16> { using Type = UInt256; };
+template <> struct Construct<false, false, 16> { using Type = UInt256; }; /// TODO: we cannot use our UInt128 here
 template <> struct Construct<false, false, 32> { using Type = UInt256; };
-template <> struct Construct<false, false, 48> { using Type = UInt256; };
 template <> struct Construct<false, true, 1> { using Type = Float32; };
 template <> struct Construct<false, true, 2> { using Type = Float32; };
 template <> struct Construct<false, true, 4> { using Type = Float32; };
@@ -67,8 +58,7 @@ template <> struct Construct<true, false, 2> { using Type = Int16; };
 template <> struct Construct<true, false, 4> { using Type = Int32; };
 template <> struct Construct<true, false, 8> { using Type = Int64; };
 template <> struct Construct<true, false, 16> { using Type = Int128; };
-template <> struct Construct<true, false, 32> { using Type = Int128; };
-template <> struct Construct<true, false, 48> { using Type = Int256; };
+template <> struct Construct<true, false, 32> { using Type = Int256; };
 template <> struct Construct<true, true, 1> { using Type = Float32; };
 template <> struct Construct<true, true, 2> { using Type = Float32; };
 template <> struct Construct<true, true, 4> { using Type = Float32; };
@@ -86,7 +76,7 @@ template <typename A, typename B> struct ResultOfAdditionMultiplication
     using Type = typename Construct<
         is_signed_v<A> || is_signed_v<B>,
         std::is_floating_point_v<A> || std::is_floating_point_v<B>,
-        nextSize2< is_signed_v<A> || is_signed_v<B> >(max(sizeof(A), sizeof(B)))>::Type;
+        nextSize(max(sizeof(A), sizeof(B)))>::Type;
 };
 
 template <typename A, typename B> struct ResultOfSubtraction
@@ -94,7 +84,7 @@ template <typename A, typename B> struct ResultOfSubtraction
     using Type = typename Construct<
         true,
         std::is_floating_point_v<A> || std::is_floating_point_v<B>,
-        nextSize2< is_signed_v<A> || is_signed_v<B> >(max(sizeof(A), sizeof(B)))>::Type;
+        nextSize(max(sizeof(A), sizeof(B)))>::Type;
 };
 
 /** When dividing, you always get a floating-point number.
@@ -127,7 +117,7 @@ template <typename A> struct ResultOfNegate
     using Type = typename Construct<
         true,
         std::is_floating_point_v<A>,
-        is_signed_v<A> ? sizeof(A) : nextSize2<true>(sizeof(A))>::Type;
+        is_signed_v<A> ? sizeof(A) : nextSize(sizeof(A))>::Type;
 };
 
 template <typename A> struct ResultOfAbs
diff --git a/src/Functions/DivisionUtils.h b/src/Functions/DivisionUtils.h
index 99fd7795bb8a..7a816df70e54 100644
--- a/src/Functions/DivisionUtils.h
+++ b/src/Functions/DivisionUtils.h
@@ -81,8 +81,10 @@ struct DivideIntegralImpl
         /// NOTE: overflow is still possible when dividing large signed number to large unsigned number or vice-versa. But it's less harmful.
         if constexpr (is_integer_v<A> && is_integer_v<B> && (is_signed_v<A> || is_signed_v<B>))
         {
-            return checkedDivision(make_signed_t<CastA>(a),
-                sizeof(A) > sizeof(B) ? make_signed_t<A>(CastB(b)) : make_signed_t<CastB>(b));
+            using SignedCastA = make_signed_t<CastA>;
+            using SignedCastB = std::conditional_t<sizeof(A) <= sizeof(B), make_signed_t<CastB>, SignedCastA>;
+
+            return bigint_cast<Result>(checkedDivision(bigint_cast<SignedCastA>(a), bigint_cast<SignedCastB>(b)));
         }
         else
             return bigint_cast<Result>(checkedDivision(CastA(a), CastB(b)));
@@ -108,7 +110,7 @@ struct ModuloImpl
         if constexpr (std::is_floating_point_v<ResultType>)
         {
             /// This computation is similar to `fmod` but the latter is not inlined and has 40 times worse performance.
-            return ResultType(a) - trunc(ResultType(a) / ResultType(b)) * ResultType(b);
+            return bigint_cast<ResultType>(a) - trunc(bigint_cast<ResultType>(a) / bigint_cast<ResultType>(b)) * bigint_cast<ResultType>(b);
         }
         else
         {
@@ -125,7 +127,7 @@ struct ModuloImpl
                 if constexpr (is_big_int_v<IntegerBType> && sizeof(IntegerAType) <= sizeof(IntegerBType))
                     return bigint_cast<Result>(bigint_cast<CastB>(int_a) % int_b);
                 else
-                    return bigint_cast<Result>(int_a % int_b);
+                    return bigint_cast<Result>(int_a % bigint_cast<CastA>(int_b));
             }
             else
                 return IntegerAType(a) % IntegerBType(b);
diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h
index 241f7b2fae09..2a467451684a 100644
--- a/src/Functions/FunctionBinaryArithmetic.h
+++ b/src/Functions/FunctionBinaryArithmetic.h
@@ -361,12 +361,8 @@ struct DecimalBinaryOperation
                 return apply(a.value, b);
             else if constexpr (IsDecimalNumber<U>)
                 return apply(a, b.value);
-            else if constexpr (std::is_same_v<T, UInt8>)
-                return apply(UInt16(a), b);
-            else if constexpr (std::is_same_v<U, UInt8>)
-                return apply(a, UInt16(b));
             else
-                return applyNative(static_cast<NativeResultType>(a), static_cast<NativeResultType>(b));
+                return applyNative(bigint_cast<NativeResultType>(a), bigint_cast<NativeResultType>(b));
         }
         else
             return applyNative(a, b);
@@ -381,12 +377,8 @@ struct DecimalBinaryOperation
                 return applyScaled<scale_left>(a.value, b, scale);
             else if constexpr (IsDecimalNumber<U>)
                 return applyScaled<scale_left>(a, b.value, scale);
-            else if constexpr (std::is_same_v<T, UInt8>)
-                return applyScaled<scale_left>(UInt16(a), b, scale);
-            else if constexpr (std::is_same_v<U, UInt8>)
-                return applyScaled<scale_left>(a, UInt16(b), scale);
             else
-                return applyNativeScaled<scale_left>(static_cast<NativeResultType>(a), static_cast<NativeResultType>(b), scale);
+                return applyNativeScaled<scale_left>(bigint_cast<NativeResultType>(a), bigint_cast<NativeResultType>(b), scale);
         }
         else
             return applyNativeScaled<scale_left>(a, b, scale);
@@ -401,12 +393,8 @@ struct DecimalBinaryOperation
                 return applyScaledDiv(a.value, b, scale);
             else if constexpr (IsDecimalNumber<U>)
                 return applyScaledDiv(a, b.value, scale);
-            else if constexpr (std::is_same_v<T, UInt8>)
-                return applyScaledDiv(UInt16(a), b, scale);
-            else if constexpr (std::is_same_v<U, UInt8>)
-                return applyScaledDiv(a, UInt16(b), scale);
             else
-                return applyNativeScaledDiv(static_cast<NativeResultType>(a), static_cast<NativeResultType>(b), scale);
+                return applyNativeScaledDiv(bigint_cast<NativeResultType>(a), bigint_cast<NativeResultType>(b), scale);
         }
         else
             return applyNativeScaledDiv(a, b, scale);
diff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h
index bf13de0c594c..e54538c76b3c 100644
--- a/src/Functions/GatherUtils/Algorithms.h
+++ b/src/Functions/GatherUtils/Algorithms.h
@@ -558,7 +558,7 @@ bool sliceEqualElements(const NumericArraySlice<T> & first [[maybe_unused]],
 {
     /// TODO: Decimal scale
     if constexpr (IsDecimalNumber<T> && IsDecimalNumber<U>)
-        return accurate::equalsOp(typename T::NativeType(first.data[first_ind]), typename U::NativeType(second.data[second_ind]));
+        return accurate::equalsOp(first.data[first_ind].value, second.data[second_ind].value);
     else if constexpr (IsDecimalNumber<T> || IsDecimalNumber<U>)
         return false;
     else
@@ -588,7 +588,7 @@ bool insliceEqualElements(const NumericArraySlice<T> & first [[maybe_unused]],
                           size_t second_ind [[maybe_unused]])
 {
     if constexpr (IsDecimalNumber<T>)
-        return accurate::equalsOp(typename T::NativeType(first.data[first_ind]), typename T::NativeType(first.data[second_ind]));
+        return accurate::equalsOp(first.data[first_ind].value, first.data[second_ind].value);
     else
         return accurate::equalsOp(first.data[first_ind], first.data[second_ind]);
 }
diff --git a/src/Functions/abs.cpp b/src/Functions/abs.cpp
index a7d31f4e0309..f0c530e0e8f1 100644
--- a/src/Functions/abs.cpp
+++ b/src/Functions/abs.cpp
@@ -16,11 +16,10 @@ struct AbsImpl
     {
         if constexpr (IsDecimalNumber<A>)
             return a < A(0) ? A(-a) : a;
-        else if constexpr (is_big_int_v<A>)
-            // from boost/multiprecision/number.hpp
-            return static_cast<ResultType>(abs(a));
+        else if constexpr (is_big_int_v<A> && is_signed_v<A>)
+            return (a < 0) ? -a : a;
         else if constexpr (is_integer_v<A> && is_signed_v<A>)
-            return a < 0 ? static_cast<ResultType>(~a) + 1 : a;
+            return a < 0 ? static_cast<ResultType>(~a) + 1 : static_cast<ResultType>(a);
         else if constexpr (is_integer_v<A> && is_unsigned_v<A>)
             return static_cast<ResultType>(a);
         else if constexpr (std::is_floating_point_v<A>)
diff --git a/src/Functions/bitRotateLeft.cpp b/src/Functions/bitRotateLeft.cpp
index 3bef0bb5ff32..a6975468c1eb 100644
--- a/src/Functions/bitRotateLeft.cpp
+++ b/src/Functions/bitRotateLeft.cpp
@@ -18,7 +18,7 @@ struct BitRotateLeftImpl
     template <typename Result = ResultType>
     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])
     {
-        if constexpr (is_big_int_v<ResultType>)
+        if constexpr (is_big_int_v<A> || is_big_int_v<B>)
             throw Exception("Bit rotate is not implemented for big integers", ErrorCodes::NOT_IMPLEMENTED);
         else
             return (static_cast<Result>(a) << static_cast<Result>(b))
diff --git a/src/Functions/bitRotateRight.cpp b/src/Functions/bitRotateRight.cpp
index e94e13a8e604..71d7385bbdf4 100644
--- a/src/Functions/bitRotateRight.cpp
+++ b/src/Functions/bitRotateRight.cpp
@@ -18,7 +18,7 @@ struct BitRotateRightImpl
     template <typename Result = ResultType>
     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])
     {
-        if constexpr (is_big_int_v<ResultType>)
+        if constexpr (is_big_int_v<A> || is_big_int_v<B>)
             throw Exception("Bit rotate is not implemented for big integers", ErrorCodes::NOT_IMPLEMENTED);
         else
             return (static_cast<Result>(a) >> static_cast<Result>(b))
diff --git a/src/Functions/bitShiftLeft.cpp b/src/Functions/bitShiftLeft.cpp
index 1ea69af73e91..d42082d77782 100644
--- a/src/Functions/bitShiftLeft.cpp
+++ b/src/Functions/bitShiftLeft.cpp
@@ -19,9 +19,9 @@ struct BitShiftLeftImpl
     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])
     {
         if constexpr (is_big_int_v<B>)
-            throw Exception("BitShiftLeftImpl is not implemented for big integers as second argument", ErrorCodes::NOT_IMPLEMENTED);
+            throw Exception("BitShiftLeft is not implemented for big integers as second argument", ErrorCodes::NOT_IMPLEMENTED);
         else if constexpr (is_big_int_v<A>)
-            return static_cast<Result>(a) << bigint_cast<UInt32>(b);
+            return bigint_cast<Result>(a) << bigint_cast<UInt32>(b);
         else
             return static_cast<Result>(a) << static_cast<Result>(b);
     }
diff --git a/src/Functions/bitShiftRight.cpp b/src/Functions/bitShiftRight.cpp
index 25eb86bf353a..249a86d6961b 100644
--- a/src/Functions/bitShiftRight.cpp
+++ b/src/Functions/bitShiftRight.cpp
@@ -19,9 +19,9 @@ struct BitShiftRightImpl
     static inline NO_SANITIZE_UNDEFINED Result apply(A a [[maybe_unused]], B b [[maybe_unused]])
     {
         if constexpr (is_big_int_v<B>)
-            throw Exception("BitRotate is not implemented for big integers as second argument", ErrorCodes::NOT_IMPLEMENTED);
+            throw Exception("BitShiftRight is not implemented for big integers as second argument", ErrorCodes::NOT_IMPLEMENTED);
         else if constexpr (is_big_int_v<A>)
-            return static_cast<Result>(a) >> bigint_cast<UInt32>(b);
+            return bigint_cast<Result>(a) >> bigint_cast<UInt32>(b);
         else
             return static_cast<Result>(a) >> static_cast<Result>(b);
     }
diff --git a/src/Functions/bitTest.cpp b/src/Functions/bitTest.cpp
index 19afa1da84b4..f34e300d6756 100644
--- a/src/Functions/bitTest.cpp
+++ b/src/Functions/bitTest.cpp
@@ -19,10 +19,8 @@ struct BitTestImpl
     template <typename Result = ResultType>
     NO_SANITIZE_UNDEFINED static inline Result apply(A a [[maybe_unused]], B b [[maybe_unused]])
     {
-        if constexpr (is_big_int_v<B>)
+        if constexpr (is_big_int_v<A> || is_big_int_v<B>)
             throw Exception("bitTest is not implemented for big integers as second argument", ErrorCodes::NOT_IMPLEMENTED);
-        else if constexpr (is_big_int_v<A>)
-            return bit_test(a, static_cast<UInt32>(b));
         else
             return (typename NumberTraits::ToInteger<A>::Type(a) >> typename NumberTraits::ToInteger<B>::Type(b)) & 1;
     }
diff --git a/src/Functions/gcd.cpp b/src/Functions/gcd.cpp
index 4ee39f3f2fd6..b5d1ed6e92c9 100644
--- a/src/Functions/gcd.cpp
+++ b/src/Functions/gcd.cpp
@@ -20,7 +20,7 @@ struct GCDImpl
     template <typename Result = ResultType>
     static inline Result apply([[maybe_unused]] A a, [[maybe_unused]] B b)
     {
-        if constexpr (is_big_int_v<A> || is_big_int_v<B>)
+        if constexpr (is_big_int_v<A> || is_big_int_v<B> || is_big_int_v<Result>)
             throw Exception("GCD is not implemented for big integers", ErrorCodes::NOT_IMPLEMENTED);
         else
         {
diff --git a/src/Functions/lcm.cpp b/src/Functions/lcm.cpp
index c61337c75ad1..ceca495ddce9 100644
--- a/src/Functions/lcm.cpp
+++ b/src/Functions/lcm.cpp
@@ -40,14 +40,14 @@ struct LCMImpl
     static const constexpr bool allow_fixed_string = false;
 
     template <typename Result = ResultType>
-    static inline std::enable_if_t<is_big_int_v<A> || is_big_int_v<B>, Result>
+    static inline std::enable_if_t<is_big_int_v<A> || is_big_int_v<B> || is_big_int_v<Result>, Result>
     apply([[maybe_unused]] A a, [[maybe_unused]] B b)
     {
         throw Exception("LCM is not implemented for big integers", ErrorCodes::NOT_IMPLEMENTED);
     }
 
     template <typename Result = ResultType>
-    static inline std::enable_if_t<!is_big_int_v<A> && !is_big_int_v<B>, Result>
+    static inline std::enable_if_t<!is_big_int_v<A> && !is_big_int_v<B> && !is_big_int_v<Result>, Result>
     apply([[maybe_unused]] A a, [[maybe_unused]] B b)
     {
         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));
diff --git a/src/Functions/roundToExp2.cpp b/src/Functions/roundToExp2.cpp
index 12856a7930e4..c6b6f672c66b 100644
--- a/src/Functions/roundToExp2.cpp
+++ b/src/Functions/roundToExp2.cpp
@@ -6,6 +6,11 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int NOT_IMPLEMENTED;
+}
+
 template <typename T>
 inline std::enable_if_t<std::is_integral_v<T> && (sizeof(T) <= sizeof(UInt32)), T>
 roundDownToPowerOfTwo(T x)
@@ -48,10 +53,9 @@ roundDownToPowerOfTwo(T x)
 
 template <typename T>
 inline std::enable_if_t<is_big_int_v<T>, T>
-roundDownToPowerOfTwo(T x)
+roundDownToPowerOfTwo(T)
 {
-    // extention from boost/multiprecision/number.hpp
-    return T(1) << msb(x);
+    throw Exception("roundToExp2() for big integers is not implemented", ErrorCodes::NOT_IMPLEMENTED);
 }
 
 /** For integer data types:
diff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h
index fb7c4e0cd80a..3b9eced09bd2 100644
--- a/src/IO/WriteHelpers.h
+++ b/src/IO/WriteHelpers.h
@@ -831,6 +831,7 @@ template <> inline void writeText<bool>(const bool & x, WriteBuffer & buf) { wri
 inline void writeText(const char * x, WriteBuffer & buf) { writeEscapedString(x, strlen(x), buf); }
 inline void writeText(const char * x, size_t size, WriteBuffer & buf) { writeEscapedString(x, size, buf); }
 
+inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(LocalDate(x), buf); }
 inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }
 inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }
 inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }
diff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h
index c69a56dd83e3..727dd67c3893 100644
--- a/src/IO/readDecimalText.h
+++ b/src/IO/readDecimalText.h
@@ -160,7 +160,7 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_
             " Expected to read decimal with scale {} and precision {}";
 
         if constexpr (is_big_int_v<typename T::NativeType>)
-            throw Exception(fmt::format(pattern, digits, x.value.str(), exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+            throw Exception(fmt::format(pattern, digits, bigintToString(x.value), exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
         else
             throw Exception(fmt::format(pattern, digits, x, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
     }
@@ -180,7 +180,7 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_
         {
             /// Too many digits after point. Just cut off excessive digits.
             auto divisor = intExp10OfSize<typename T::NativeType>(divisor_exp);
-            assert(divisor > T(0)); /// This is for Clang Static Analyzer. It is not smart enough to infer it automatically.
+            assert(divisor > 0); /// This is for Clang Static Analyzer. It is not smart enough to infer it automatically.
             x.value /= divisor;
             scale = 0;
             return;
diff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp
index c011aac13497..86a33dccb530 100644
--- a/src/Interpreters/Aggregator.cpp
+++ b/src/Interpreters/Aggregator.cpp
@@ -362,7 +362,9 @@ AggregatedDataVariants::Type Aggregator::chooseAggregationMethod()
             return AggregatedDataVariants::Type::key64;
         if (size_of_field == 16)
             return AggregatedDataVariants::Type::keys128;
-        throw Exception("Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16.", ErrorCodes::LOGICAL_ERROR);
+        if (size_of_field == 32)
+            return AggregatedDataVariants::Type::keys256;
+        throw Exception("Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16, 32.", ErrorCodes::LOGICAL_ERROR);
     }
 
     /// If all keys fits in N bits, will use hash table with all keys packed (placed contiguously) to single N-bit key.
diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp
index e3f265af004f..9818f89d13ce 100644
--- a/src/Interpreters/HashJoin.cpp
+++ b/src/Interpreters/HashJoin.cpp
@@ -221,7 +221,9 @@ HashJoin::Type HashJoin::chooseMethod(const ColumnRawPtrs & key_columns, Sizes &
             return Type::key64;
         if (size_of_field == 16)
             return Type::keys128;
-        throw Exception("Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16.", ErrorCodes::LOGICAL_ERROR);
+        if (size_of_field == 32)
+            return Type::keys256;
+        throw Exception("Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16, 32.", ErrorCodes::LOGICAL_ERROR);
     }
 
     /// If the keys fit in N bits, we will use a hash table for N-bit-packed keys
diff --git a/src/Interpreters/SetVariants.cpp b/src/Interpreters/SetVariants.cpp
index b026ce567056..eb21333e3ecf 100644
--- a/src/Interpreters/SetVariants.cpp
+++ b/src/Interpreters/SetVariants.cpp
@@ -110,9 +110,8 @@ typename SetVariantsTemplate<Variant>::Type SetVariantsTemplate<Variant>::choose
             size_t size_of_field = nested_key_columns[0]->sizeOfValueIfFixed();
             if ((size_of_field == 1) || (size_of_field == 2) || (size_of_field == 4) || (size_of_field == 8))
                 return Type::nullable_keys128;
-            else
-                throw Exception{"Logical error: numeric column has sizeOfField not in 1, 2, 4, 8.",
-                    ErrorCodes::LOGICAL_ERROR};
+
+            /// Pass to more generic method
         }
 
         if (all_fixed)
@@ -145,7 +144,9 @@ typename SetVariantsTemplate<Variant>::Type SetVariantsTemplate<Variant>::choose
             return Type::key64;
         if (size_of_field == 16)
             return Type::keys128;
-        throw Exception("Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16.", ErrorCodes::LOGICAL_ERROR);
+        if (size_of_field == 32)
+            return Type::keys256;
+        throw Exception("Logical error: numeric column has sizeOfField not in 1, 2, 4, 8, 16, 32.", ErrorCodes::LOGICAL_ERROR);
     }
 
     /// If the keys fit in N bits, we will use a hash table for N-bit-packed keys
