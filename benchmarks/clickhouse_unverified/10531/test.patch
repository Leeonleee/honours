diff --git a/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity.cpp b/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity.cpp
index 0579fd05f5d5..7488b6ea44a6 100644
--- a/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity.cpp
+++ b/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity.cpp
@@ -25,14 +25,16 @@ TEST(AdaptiveIndexGranularity, FillGranularityToyTests)
     EXPECT_EQ(block1.bytes(), 80);
     { /// Granularity bytes are not set. Take default index_granularity.
         MergeTreeIndexGranularity index_granularity;
-        fillIndexGranularityImpl(block1, 0, 100, false, 0, index_granularity, false);
+        auto granularity = computeIndexGranularityImpl(block1, 0, 100, false, false);
+        fillIndexGranularityImpl(index_granularity, 0, granularity, block1.rows());
         EXPECT_EQ(index_granularity.getMarksCount(), 1);
         EXPECT_EQ(index_granularity.getMarkRows(0), 100);
     }
 
     { /// Granule size is less than block size. Block contains multiple granules.
         MergeTreeIndexGranularity index_granularity;
-        fillIndexGranularityImpl(block1, 16, 100, false, 0, index_granularity, true);
+        auto granularity = computeIndexGranularityImpl(block1, 16, 100, false, true);
+        fillIndexGranularityImpl(index_granularity, 0, granularity, block1.rows());
         EXPECT_EQ(index_granularity.getMarksCount(), 5); /// First granule with 8 rows, and second with 1 row
         for (size_t i = 0; i < index_granularity.getMarksCount(); ++i)
             EXPECT_EQ(index_granularity.getMarkRows(i), 2);
@@ -41,7 +43,8 @@ TEST(AdaptiveIndexGranularity, FillGranularityToyTests)
     { /// Granule size is more than block size. Whole block (and maybe more) can be placed in single granule.
 
         MergeTreeIndexGranularity index_granularity;
-        fillIndexGranularityImpl(block1, 512, 100, false, 0, index_granularity, true);
+        auto granularity = computeIndexGranularityImpl(block1, 512, 100, false, true);
+        fillIndexGranularityImpl(index_granularity, 0, granularity, block1.rows());
         EXPECT_EQ(index_granularity.getMarksCount(), 1);
         for (size_t i = 0; i < index_granularity.getMarksCount(); ++i)
             EXPECT_EQ(index_granularity.getMarkRows(i), 64);
@@ -50,7 +53,8 @@ TEST(AdaptiveIndexGranularity, FillGranularityToyTests)
     { /// Blocks with granule size
 
         MergeTreeIndexGranularity index_granularity;
-        fillIndexGranularityImpl(block1, 1, 100, true, 0, index_granularity, true);
+        auto granularity = computeIndexGranularityImpl(block1, 1, 100, true, true);
+        fillIndexGranularityImpl(index_granularity, 0, granularity, block1.rows());
         EXPECT_EQ(index_granularity.getMarksCount(), 1);
         for (size_t i = 0; i < index_granularity.getMarksCount(); ++i)
             EXPECT_EQ(index_granularity.getMarkRows(i), block1.rows());
@@ -58,7 +62,8 @@ TEST(AdaptiveIndexGranularity, FillGranularityToyTests)
 
     { /// Shift in index offset
         MergeTreeIndexGranularity index_granularity;
-        fillIndexGranularityImpl(block1, 16, 100, false, 6, index_granularity, true);
+        auto granularity = computeIndexGranularityImpl(block1, 16, 100, false, true);
+        fillIndexGranularityImpl(index_granularity, 6, granularity, block1.rows());
         EXPECT_EQ(index_granularity.getMarksCount(), 2);
         for (size_t i = 0; i < index_granularity.getMarksCount(); ++i)
             EXPECT_EQ(index_granularity.getMarkRows(i), 2);
@@ -74,7 +79,10 @@ TEST(AdaptiveIndexGranularity, FillGranularitySequenceOfBlocks)
         auto block3 = getBlockWithSize(65536, 8);
         MergeTreeIndexGranularity index_granularity;
         for (const auto & block : {block1, block2, block3})
-            fillIndexGranularityImpl(block, 1024, 8192, false, 0, index_granularity, true);
+        {
+            auto granularity = computeIndexGranularityImpl(block, 1024, 8192, false, true);
+            fillIndexGranularityImpl(index_granularity, 0, granularity, block.rows());
+        }
 
         EXPECT_EQ(index_granularity.getMarksCount(), 192); /// granules
         for (size_t i = 0; i < index_granularity.getMarksCount(); ++i)
@@ -87,7 +95,10 @@ TEST(AdaptiveIndexGranularity, FillGranularitySequenceOfBlocks)
         EXPECT_EQ(block1.rows() + block2.rows() + block3.rows(), 3136);
         MergeTreeIndexGranularity index_granularity;
         for (const auto & block : {block1, block2, block3})
-            fillIndexGranularityImpl(block, 1024, 8192, false, 0, index_granularity, true);
+        {
+            auto granularity = computeIndexGranularityImpl(block, 1024, 8192, false, true);
+            fillIndexGranularityImpl(index_granularity, 0, granularity, block.rows());
+        }
 
         EXPECT_EQ(index_granularity.getMarksCount(), 98); /// granules
         for (size_t i = 0; i < index_granularity.getMarksCount(); ++i)
@@ -105,7 +116,8 @@ TEST(AdaptiveIndexGranularity, FillGranularitySequenceOfBlocks)
         size_t index_offset = 0;
         for (const auto & block : {block1, block2, block3})
         {
-            fillIndexGranularityImpl(block, 16384, 8192, false, index_offset, index_granularity, true);
+            auto granularity = computeIndexGranularityImpl(block, 16384, 8192, false, true);
+            fillIndexGranularityImpl(index_granularity, index_offset, granularity, block.rows());
             index_offset = index_granularity.getLastMarkRows() - block.rows();
         }
         EXPECT_EQ(index_granularity.getMarksCount(), 1); /// granules
diff --git a/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity_compact_parts.cpp b/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity_compact_parts.cpp
new file mode 100644
index 000000000000..f87293dcd5d7
--- /dev/null
+++ b/src/Storages/tests/gtest_aux_funcs_for_adaptive_granularity_compact_parts.cpp
@@ -0,0 +1,81 @@
+#include <gtest/gtest.h>
+#include <Core/Block.h>
+#include <Columns/ColumnVector.h>
+
+// I know that inclusion of .cpp is not good at all
+#include <Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp>
+
+using namespace DB;
+
+TEST(IndexGranularityCompactParts, FillGranularitySequenceOfBlocks)
+{
+    { /// Three blocks in one granule.
+        size_t rows = 8;
+        size_t granularity = 32;
+
+        MergeTreeIndexGranularity index_granularity;
+        size_t index_offset = 0;
+        size_t rows_written = 0;
+        for (size_t i = 0; i < 3; ++i)
+        {
+            fillIndexGranularityImpl(index_granularity, index_offset, granularity, rows);
+            rows_written += rows;
+            index_offset = granularity - rows_written;
+        }
+
+        EXPECT_EQ(index_granularity.getMarksCount(), 1); /// granules
+        /// It's ok, that granularity is higher than actual number of row.
+        /// It will be corrected in CompactWriter.
+        EXPECT_EQ(index_granularity.getMarkRows(0), granularity);
+    }
+
+    { /// Granule is extended with small block
+        size_t rows1 = 30;
+        size_t rows2 = 8;
+        size_t granularity = 32;
+
+        MergeTreeIndexGranularity index_granularity;
+        size_t index_offset = 0;
+
+        fillIndexGranularityImpl(index_granularity, index_offset, granularity, rows1);
+        index_offset = granularity - rows1;
+
+        fillIndexGranularityImpl(index_granularity, index_offset, granularity, rows2);
+
+        EXPECT_EQ(index_granularity.getMarksCount(), 1);
+        EXPECT_EQ(index_granularity.getMarkRows(0), rows1 + rows2);
+    }
+
+    { /// New granule is created with large block;
+        size_t rows1 = 30;
+        size_t rows2 = 25;
+        size_t granularity = 32;
+
+        MergeTreeIndexGranularity index_granularity;
+        size_t index_offset = 0;
+
+        fillIndexGranularityImpl(index_granularity, index_offset, granularity, rows1);
+        index_offset = granularity - rows1;
+
+        fillIndexGranularityImpl(index_granularity, index_offset, granularity, rows2);
+
+        EXPECT_EQ(index_granularity.getMarksCount(), 2);
+        EXPECT_EQ(index_granularity.getMarkRows(0), granularity);
+        EXPECT_EQ(index_granularity.getMarkRows(1), rows1 + rows2 - granularity);
+    }
+
+     { /// Three large blocks
+        size_t rows = 40;
+        size_t granularity = 32;
+
+        MergeTreeIndexGranularity index_granularity;
+        size_t index_offset = 0;
+
+        for (size_t i = 0; i < 3; ++i)
+            fillIndexGranularityImpl(index_granularity, index_offset, granularity, rows);
+
+        EXPECT_EQ(index_granularity.getMarksCount(), 3);
+        for (size_t i = 0; i < 3; ++i)
+            EXPECT_EQ(index_granularity.getMarkRows(i), rows);
+    }
+}
diff --git a/tests/integration/test_polymorphic_parts/test.py b/tests/integration/test_polymorphic_parts/test.py
index f7256de9d9a4..ebb04f498761 100644
--- a/tests/integration/test_polymorphic_parts/test.py
+++ b/tests/integration/test_polymorphic_parts/test.py
@@ -2,6 +2,8 @@
 import pytest
 import random
 import string
+import os
+import struct
 
 from helpers.test_tools import TSV
 from helpers.test_tools import assert_eq_with_retry
@@ -260,3 +262,24 @@ def test_polymorphic_parts_non_adaptive(start_cluster):
         "WHERE table = 'non_adaptive_table' AND active GROUP BY part_type ORDER BY part_type")) == TSV("Wide\t2
")
 
     assert node1.contains_in_log("<Warning> default.non_adaptive_table: Table can't create parts with adaptive granularity")
+
+
+def test_polymorphic_parts_index(start_cluster):
+    node1.query('''
+        CREATE TABLE index_compact(a UInt32, s String) 
+        ENGINE = MergeTree ORDER BY a 
+        SETTINGS min_rows_for_wide_part = 1000, index_granularity = 128, merge_max_block_size = 100''')
+
+    node1.query("INSERT INTO index_compact SELECT number, toString(number) FROM numbers(100)")
+    node1.query("INSERT INTO index_compact SELECT number, toString(number) FROM numbers(30)")
+    node1.query("OPTIMIZE TABLE index_compact FINAL")
+
+    assert node1.query("SELECT part_type FROM system.parts WHERE table = 'index_compact' AND active") == "Compact
"
+    assert node1.query("SELECT marks FROM system.parts WHERE table = 'index_compact' AND active") == "2
"
+
+    index_path = os.path.join(node1.path, "database/data/default/index_compact/all_1_2_1/primary.idx")
+    f = open(index_path, 'rb')
+
+    assert os.path.getsize(index_path) == 8
+    assert struct.unpack('I', f.read(4))[0] == 0
+    assert struct.unpack('I', f.read(4))[0] == 99
