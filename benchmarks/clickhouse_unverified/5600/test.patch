diff --git a/dbms/src/Compression/tests/gtest_compressionCodec.cpp b/dbms/src/Compression/tests/gtest_compressionCodec.cpp
new file mode 100644
index 000000000000..e1413ccd7bd8
--- /dev/null
+++ b/dbms/src/Compression/tests/gtest_compressionCodec.cpp
@@ -0,0 +1,385 @@
+#include <Compression/CompressionCodecDoubleDelta.h>
+#include <Compression/CompressionCodecGorilla.h>
+
+#include <Core/Types.h>
+#include <IO/WriteHelpers.h>
+#include <IO/ReadBufferFromMemory.h>
+#include <Common/PODArray.h>
+
+#include <boost/format.hpp>
+
+#include <cmath>
+#include <initializer_list>
+#include <iomanip>
+#include <memory>
+#include <vector>
+#include <typeinfo>
+#include <iterator>
+#include <optional>
+#include <iostream>
+#include <bitset>
+#include <string.h>
+
+#pragma GCC diagnostic ignored "-Wsign-compare"
+#ifdef __clang__
+#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
+#pragma clang diagnostic ignored "-Wundef"
+#endif
+#include <gtest/gtest.h>
+
+using namespace DB;
+
+template <typename T>
+std::string bin(const T & value, size_t bits = sizeof(T)*8)
+{
+    static const UInt8 MAX_BITS = sizeof(T)*8;
+    assert(bits <= MAX_BITS);
+
+    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))
+            .to_string().substr(MAX_BITS - bits, bits);
+}
+
+template <typename T>
+const char* type_name()
+{
+    return typeid(T).name();
+}
+
+template <>
+const char* type_name<UInt32>()
+{
+    return "uint32";
+}
+
+template <>
+const char* type_name<Int32>()
+{
+    return "int32";
+}
+
+template <>
+const char* type_name<UInt64>()
+{
+    return "uint64";
+}
+
+template <>
+const char* type_name<Int64>()
+{
+    return "int64";
+}
+
+template <>
+const char* type_name<Float32>()
+{
+    return "float";
+}
+
+template <>
+const char* type_name<Float64>()
+{
+    return "double";
+}
+
+
+template <typename T, typename ContainerLeft, typename ContainerRight>
+::testing::AssertionResult EqualByteContainersAs(const ContainerLeft & left, const ContainerRight & right)
+{
+    static_assert(sizeof(typename ContainerLeft::value_type) == 1, "Expected byte-container");
+    static_assert(sizeof(typename ContainerRight::value_type) == 1, "Expected byte-container");
+
+    ::testing::AssertionResult result = ::testing::AssertionSuccess();
+
+    ReadBufferFromMemory left_read_buffer(left.data(), left.size());
+    ReadBufferFromMemory right_read_buffer(right.data(), right.size());
+
+    const auto l_size = left.size() / sizeof(T);
+    const auto r_size = right.size() / sizeof(T);
+    const auto size = std::min(l_size, r_size);
+
+    if (l_size != r_size)
+    {
+        result = ::testing::AssertionFailure() << "size mismatch" << " expected: " << l_size << " got:" << r_size;
+    }
+
+    const auto MAX_MISMATCHING_ITEMS = 5;
+    int mismatching_items = 0;
+    for (int i = 0; i < size; ++i)
+    {
+        T left_value{};
+        left_read_buffer.readStrict(reinterpret_cast<char*>(&left_value), sizeof(left_value));
+
+        T right_value{};
+        right_read_buffer.readStrict(reinterpret_cast<char*>(&right_value), sizeof(right_value));
+
+        if (left_value != right_value)
+        {
+            if (result)
+            {
+                result = ::testing::AssertionFailure();
+            }
+
+            result << "mismatching " << sizeof(T) << "-byte item #" << i
+                   << "
expected: " << bin(left_value)
+                   << "
got     : " << bin(right_value)
+                   << std::endl;
+
+            if (++mismatching_items >= MAX_MISMATCHING_ITEMS)
+            {
+                result << "..." << std::endl;
+                break;
+            }
+        }
+    }
+
+    return result;
+}
+
+struct CodecTestParam
+{
+    std::vector<char> source_data;
+    UInt8 data_byte_size;
+    std::string case_name;
+};
+
+std::ostream & operator<<(std::ostream & ostr, const CodecTestParam & param)
+{
+    return ostr << "name: " << param.case_name
+                << "
byte size: " << static_cast<UInt32>(param.data_byte_size)
+                << "
data size: " << param.source_data.size();
+}
+
+template <typename T, typename... Args>
+CodecTestParam makeParam(Args && ... args)
+{
+    std::initializer_list<T> vals{static_cast<T>(args)...};
+    std::vector<char> data(sizeof(T) * std::size(vals));
+
+    char * write_pos = data.data();
+    for (const auto & v : vals)
+    {
+        unalignedStore<T>(write_pos, v);
+        write_pos += sizeof(v);
+    }
+
+    return CodecTestParam{std::move(data), sizeof(T),
+                (boost::format("%1% %2%") % (sizeof(T) * std::size(vals)) % " predefined values").str()};
+}
+
+template <typename T, size_t Begin = 1, size_t End = 10000, typename Generator>
+CodecTestParam generateParam(Generator gen, const char* gen_name)
+{
+    static_assert (End >= Begin, "End must be not less than Begin");
+
+    std::vector<char> data(sizeof(T) * (End - Begin));
+    char * write_pos = data.data();
+
+    for (size_t i = Begin; i < End; ++i)
+    {
+        const T v = gen(static_cast<T>(i));
+        unalignedStore<T>(write_pos, v);
+        write_pos += sizeof(v);
+    }
+
+    return CodecTestParam{std::move(data), sizeof(T),
+                (boost::format("%1% from %2% (%3% => %4%)") % type_name<T>() % gen_name % Begin % End).str()};
+}
+
+void TestTranscoding(ICompressionCodec * codec, const CodecTestParam & param)
+{
+    const auto & source_data = param.source_data;
+
+    const UInt32 encoded_max_size = codec->getCompressedReserveSize(source_data.size());
+    PODArray<char> encoded(encoded_max_size);
+
+    const UInt32 encoded_size = codec->compress(source_data.data(), source_data.size(), encoded.data());
+    encoded.resize(encoded_size);
+
+    PODArray<char> decoded(source_data.size());
+    const UInt32 decoded_size = codec->decompress(encoded.data(), encoded.size(), decoded.data());
+    decoded.resize(decoded_size);
+
+    switch (param.data_byte_size)
+    {
+        case 1:
+            ASSERT_TRUE(EqualByteContainersAs<UInt8>(source_data, decoded));
+            break;
+        case 2:
+            ASSERT_TRUE(EqualByteContainersAs<UInt16>(source_data, decoded));
+            break;
+        case 4:
+            ASSERT_TRUE(EqualByteContainersAs<UInt32>(source_data, decoded));
+            break;
+        case 8:
+            ASSERT_TRUE(EqualByteContainersAs<UInt64>(source_data, decoded));
+            break;
+        default:
+            FAIL() << "Invalid data_byte_size: " << param.data_byte_size;
+    }
+}
+
+class CodecTest : public ::testing::TestWithParam<CodecTestParam>
+{
+public:
+    static void SetUpTestCase()
+    {
+        // To make random predicatble and avoid failing test "out of the blue".
+        srand(0);
+    }
+};
+
+TEST_P(CodecTest, DoubleDelta)
+{
+    const auto & param = GetParam();
+    auto codec = std::make_unique<CompressionCodecDoubleDelta>(param.data_byte_size);
+
+    TestTranscoding(codec.get(), param);
+}
+
+TEST_P(CodecTest, Gorilla)
+{
+    const auto & param = GetParam();
+    auto codec = std::make_unique<CompressionCodecGorilla>(param.data_byte_size);
+
+    TestTranscoding(codec.get(), param);
+}
+
+auto SameValueGenerator = [](auto value)
+{
+    return [=](auto i)
+    {
+        return static_cast<decltype(i)>(value);
+    };
+};
+
+auto SequentialGenerator = [](auto stride = 1)
+{
+    return [=](auto i)
+    {
+        using ValueType = decltype(i);
+        return static_cast<ValueType>(stride * i);
+    };
+};
+
+template <typename T>
+struct MonotonicGenerator
+{
+    MonotonicGenerator(T stride = 1, size_t max_step = 10)
+        : prev_value{},
+          stride(stride),
+          max_step(max_step)
+    {}
+
+    template <typename U>
+    U operator()(U i)
+    {
+        if (!prev_value.has_value())
+        {
+            prev_value = i * stride;
+        }
+
+        const U result = *prev_value + static_cast<T>(stride * (rand() % max_step));
+
+        prev_value = result;
+        return result;
+    }
+
+    std::optional<T> prev_value;
+    const T stride;
+    const size_t max_step;
+};
+
+auto MinMaxGenerator = [](auto i)
+{
+    if (i % 2 == 0)
+    {
+        return std::numeric_limits<decltype(i)>::min();
+    }
+    else
+    {
+        return std::numeric_limits<decltype(i)>::max();
+    }
+};
+
+auto RandomGenerator = [](auto i) {return static_cast<decltype(i)>(rand());};
+
+auto RandomishGenerator = [](auto i)
+{
+    return static_cast<decltype(i)>(sin(static_cast<double>(i) * i) * i);
+};
+
+INSTANTIATE_TEST_CASE_P(Basic,
+    CodecTest,
+    ::testing::Values(
+        makeParam<UInt32>(1, 2, 3, 4),
+        makeParam<UInt64>(1, 2, 3, 4),
+        makeParam<Float32>(1.1, 2.2, 3.3, 4.4),
+        makeParam<Float64>(1.1, 2.2, 3.3, 4.4)
+    ),
+);
+
+#define G(generator) generator, #generator
+
+INSTANTIATE_TEST_CASE_P(Same,
+    CodecTest,
+    ::testing::Values(
+        generateParam<UInt32>(G(SameValueGenerator(1000))),
+        generateParam<Int32>(G(SameValueGenerator(-1000))),
+        generateParam<UInt64>(G(SameValueGenerator(1000))),
+        generateParam<Int64>(G(SameValueGenerator(-1000))),
+        generateParam<Float32>(G(SameValueGenerator(M_E))),
+        generateParam<Float64>(G(SameValueGenerator(M_E)))
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(Sequential,
+    CodecTest,
+    ::testing::Values(
+        generateParam<UInt32>(G(SequentialGenerator(1))),
+        generateParam<Int32>(G(SequentialGenerator(-1))),
+        generateParam<UInt64>(G(SequentialGenerator(1))),
+        generateParam<Int64>(G(SequentialGenerator(-1))),
+        generateParam<Float32>(G(SequentialGenerator(M_E))),
+        generateParam<Float64>(G(SequentialGenerator(M_E)))
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(Monotonic,
+    CodecTest,
+    ::testing::Values(
+        generateParam<UInt32>(G(MonotonicGenerator<UInt32>(1, 5))),
+        generateParam<Int32>(G(MonotonicGenerator<Int32>(-1, 5))),
+        generateParam<UInt64>(G(MonotonicGenerator<UInt64>(1, 5))),
+        generateParam<Int64>(G(MonotonicGenerator<Int64>(-1, 5))),
+        generateParam<Float32>(G(MonotonicGenerator<Float32>(M_E, 5))),
+        generateParam<Float64>(G(MonotonicGenerator<Float64>(M_E, 5)))
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(Random,
+    CodecTest,
+    ::testing::Values(
+        generateParam<UInt32>(G(RandomGenerator)),
+        generateParam<UInt64>(G(RandomGenerator))
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(RandomLike,
+    CodecTest,
+    ::testing::Values(
+        generateParam<Int32>(G(RandomishGenerator)),
+        generateParam<Int64>(G(RandomishGenerator)),
+        generateParam<Float32>(G(RandomishGenerator)),
+        generateParam<Float64>(G(RandomishGenerator))
+    ),
+);
+
+INSTANTIATE_TEST_CASE_P(Overflow,
+    CodecTest,
+    ::testing::Values(
+        generateParam<UInt32>(G(MinMaxGenerator)),
+        generateParam<Int32>(G(MinMaxGenerator)),
+        generateParam<UInt64>(G(MinMaxGenerator)),
+        generateParam<Int64>(G(MinMaxGenerator))
+    ),
+);
diff --git a/dbms/src/IO/tests/gtest_bit_io.cpp b/dbms/src/IO/tests/gtest_bit_io.cpp
new file mode 100644
index 000000000000..abb5a53e3469
--- /dev/null
+++ b/dbms/src/IO/tests/gtest_bit_io.cpp
@@ -0,0 +1,213 @@
+#include <string.h>
+#include <IO/BitHelpers.h>
+
+#include <Core/Types.h>
+#include <IO/MemoryReadWriteBuffer.h>
+#include <IO/ReadBufferFromMemory.h>
+#include <Common/BitHelpers.h>
+#include <Common/PODArray.h>
+
+#include <cmath>
+#include <iomanip>
+#include <memory>
+#include <bitset>
+#include <string>
+#include <vector>
+#include <typeinfo>
+#include <iostream>
+
+#pragma GCC diagnostic ignored "-Wsign-compare"
+#ifdef __clang__
+#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
+#pragma clang diagnostic ignored "-Wundef"
+#endif
+
+#include <gtest/gtest.h>
+
+using namespace DB;
+
+// Intentionally asymmetric both byte and word-size to detect read and write inconsistencies
+// each prime bit is set to 0.
+//                              v-61     v-53   v-47  v-41 v-37   v-31     v-23  v-17   v-11   v-5
+const UInt64 BIT_PATTERN = 0b11101011'11101111'10111010'11101111'10101111'10111010'11101011'10101001;
+const UInt8 PRIMES[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61};
+
+template <typename T>
+std::string bin(const T & value, size_t bits = sizeof(T)*8)
+{
+    static const UInt8 MAX_BITS = sizeof(T)*8;
+    assert(bits <= MAX_BITS);
+
+    return std::bitset<sizeof(T) * 8>(static_cast<unsigned long long>(value))
+            .to_string().substr(MAX_BITS - bits, bits);
+}
+
+template <typename T>
+T getBits(UInt8 bits, const T & value)
+{
+    const T mask = ((static_cast<T>(1) << static_cast<T>(bits)) - 1);
+    return value & mask;
+}
+
+template <typename T>
+std::ostream & dumpBuffer(const T begin,
+                          const T end,
+                          std::ostream * destination,
+                          const char* col_sep = " ",
+                          const char* row_sep = "
",
+                          const size_t cols_in_row = 8,
+                          UInt32 max_bytes = 0xFFFFFFFF)
+{
+    size_t col = 0;
+    for (auto p = begin; p < end && p - begin < max_bytes; ++p)
+    {
+        *destination << bin(*p);
+        if (++col % cols_in_row == 0)
+        {
+            if (row_sep)
+                *destination << row_sep;
+        }
+        else if (col_sep)
+        {
+            *destination << col_sep;
+        }
+    }
+
+    return *destination;
+}
+
+template <typename T>
+std::string dumpContents(const T& container,
+                         const char* col_sep = " ",
+                         const char* row_sep = "
",
+                         const size_t cols_in_row = 8)
+
+{
+    std::stringstream sstr;
+    dumpBuffer(std::begin(container), std::end(container), &sstr, col_sep, row_sep, cols_in_row);
+
+    return sstr.str();
+}
+
+struct TestCaseParameter
+{
+    std::vector<std::pair<UInt8, UInt64>> bits_and_vals;
+    std::string expected_buffer_binary;
+
+    explicit TestCaseParameter(std::vector<std::pair<UInt8, UInt64>> vals, std::string binary = std::string{})
+        : bits_and_vals(std::move(vals)),
+          expected_buffer_binary(binary)
+    {}
+};
+
+class BitIO : public ::testing::TestWithParam<TestCaseParameter>
+{};
+
+TEST_P(BitIO, WriteAndRead)
+{
+    const auto & param = GetParam();
+    const auto & bits_and_vals = param.bits_and_vals;
+    const auto & expected_buffer_binary = param.expected_buffer_binary;
+
+    UInt64 max_buffer_size = 0;
+    for (const auto & bv : bits_and_vals)
+    {
+        max_buffer_size += bv.first;
+    }
+    max_buffer_size = (max_buffer_size + 7) / 8;
+    SCOPED_TRACE(max_buffer_size);
+
+    PODArray<char> data(max_buffer_size);
+
+    {
+        WriteBuffer write_buffer(data.data(), data.size());
+        BitWriter writer(write_buffer);
+        for (const auto & bv : bits_and_vals)
+        {
+            writer.writeBits(bv.first, bv.second);
+        }
+        writer.flush();
+    }
+
+    {
+        ReadBufferFromMemory read_buffer(data.data(), data.size());
+//        auto memory_read_buffer = memory_write_buffer.tryGetReadBuffer();
+
+        if (expected_buffer_binary != std::string{})
+        {
+            const auto actual_buffer_binary = dumpContents(data, " ", " ");
+            ASSERT_EQ(expected_buffer_binary, actual_buffer_binary);
+        }
+
+        BitReader reader(read_buffer);
+
+        int item = 0;
+        for (const auto & bv : bits_and_vals)
+        {
+            SCOPED_TRACE(::testing::Message()
+                         << "item #" << item << ", width: " << static_cast<UInt32>(bv.first)
+                         << ", value: " << bin(bv.second)
+                         << ".


Buffer memory:
" << dumpContents(data));
+
+            //EXPECT_EQ(getBits(bv.first, bv.second), reader.peekBits(bv.first));
+            EXPECT_EQ(getBits(bv.first, bv.second), reader.readBits(bv.first));
+
+            ++item;
+        }
+    }
+}
+
+INSTANTIATE_TEST_CASE_P(Simple,
+        BitIO,
+        ::testing::Values(
+            TestCaseParameter(
+                {{9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}, {9, 0x00}, {9, 0xFFFFFFFF}},
+                "11111111 10000000 00111111 11100000 00001111 11111000 "),
+            TestCaseParameter(
+                {{7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {7, 0x3f}, {3, 0xFFFF}},
+                "01111110 11111101 11111011 11110111 11101111 11011111 10111111 01111111 11000000 "),
+            TestCaseParameter({{33, 0xFF110d0b07050300}, {33, 0xAAEE29251f1d1713}}),
+            TestCaseParameter({{33, BIT_PATTERN}, {33, BIT_PATTERN}}),
+            TestCaseParameter({{24, 0xFFFFFFFF}},
+                "11111111 11111111 11111111 ")
+),);
+
+TestCaseParameter primes_case(UInt8 repeat_times, UInt64 pattern)
+{
+    std::vector<std::pair<UInt8, UInt64>> test_data;
+
+    {
+        for (UInt8 r = 0; r < repeat_times; ++r)
+        {
+            for (const auto p : PRIMES)
+            {
+                test_data.emplace_back(p, pattern);
+            }
+        }
+    }
+
+    return TestCaseParameter(test_data);
+}
+
+INSTANTIATE_TEST_CASE_P(Primes,
+        BitIO,
+        ::testing::Values(
+            primes_case(11, 0xFFFFFFFFFFFFFFFFULL),
+            primes_case(11, BIT_PATTERN)
+),);
+
+TEST(BitHelpers, maskLowBits)
+{
+    EXPECT_EQ(0b00000111, ::maskLowBits<UInt8>(3));
+    EXPECT_EQ(0b01111111, ::maskLowBits<UInt8>(7));
+    EXPECT_EQ(0b0000000001111111, ::maskLowBits<UInt16>(7));
+    EXPECT_EQ(0b0001111111111111, ::maskLowBits<UInt16>(13));
+    EXPECT_EQ(0b00000111111111111111111111111111, ::maskLowBits<UInt32>(27));
+    EXPECT_EQ(0b111111111111111111111111111111111, ::maskLowBits<UInt64>(33));
+    EXPECT_EQ(0b11111111111111111111111111111111111, ::maskLowBits<UInt64>(35));
+
+    EXPECT_EQ(0xFF, ::maskLowBits<UInt8>(8));
+    EXPECT_EQ(0xFFFF, ::maskLowBits<UInt16>(16));
+    EXPECT_EQ(0xFFFFFFFF, ::maskLowBits<UInt32>(32));
+    EXPECT_EQ(0xFFFFFFFFFFFFFFFF, ::maskLowBits<UInt64>(64));
+}
diff --git a/dbms/tests/performance/codec_double_delta.xml b/dbms/tests/performance/codec_double_delta.xml
new file mode 100644
index 000000000000..a713c606eb1d
--- /dev/null
+++ b/dbms/tests/performance/codec_double_delta.xml
@@ -0,0 +1,67 @@
+<test>
+    <name>IPv4 Functions</name>
+
+    <type>once</type>
+    <stop_conditions>
+        <any_of>
+            <average_speed_not_changing_for_ms>1000</average_speed_not_changing_for_ms>
+            <total_time_ms>2000</total_time_ms>
+        </any_of>
+    </stop_conditions>
+
+    <substitutions>
+        <substitution>
+            <name>table_suffix</name>
+            <values>
+                <value>dd</value>
+                <value>lz4</value>
+                <value>dd_lz4</value>
+            </values>
+        </substitution>
+    </substitutions>
+
+    <create_query>CREATE TABLE IF NOT EXISTS seq_dd (n UInt64 CODEC(DoubleDelta, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS mon_dd AS seq_dd;</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS rnd_dd AS seq_dd;</create_query>
+
+    <create_query>CREATE TABLE IF NOT EXISTS seq_lz4 (n UInt64 CODEC(LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS mon_lz4 AS seq_lz4;</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS rnd_lz4 AS seq_lz4;</create_query>
+
+    <create_query>CREATE TABLE IF NOT EXISTS seq_dd_lz4 (n UInt64 CODEC(DoubleDelta, LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS mon_dd_lz4 AS seq_dd_lz4;</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS rnd_dd_lz4 AS seq_dd_lz4;</create_query>
+
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT number FROM system.numbers LIMIT 100000</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT number*67+(rand()%67) FROM system.numbers LIMIT 100000</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT rand() FROM system.numbers LIMIT 100000</fill_query>
+    
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+
+
+    <query>INSERT INTO seq_{table_suffix} (n) SELECT number FROM system.numbers SETTINGS max_threads=1</query>
+    <query>INSERT INTO mon_{table_suffix} (n) SELECT number*67+(rand()%67) FROM system.numbers SETTINGS max_threads=1</query>
+    <query>INSERT INTO rnd_{table_suffix} (n) SELECT rand() FROM system.numbers SETTINGS max_threads=1</query>
+
+
+    <query>SELECT count(n) FROM seq_{table_suffix} SETTINGS max_threads=1</query>
+    <query>SELECT count(n) FROM mon_{table_suffix} SETTINGS max_threads=1</query>
+    <query>SELECT count(n) FROM rnd_{table_suffix} SETTINGS max_threads=1</query>
+
+
+    <drop_query>DROP TABLE IF EXISTS seq_{table_suffix}</drop_query>
+    <drop_query>DROP TABLE IF EXISTS mon_{table_suffix}</drop_query>
+    <drop_query>DROP TABLE IF EXISTS rnd_{table_suffix}</drop_query>
+
+</test>
diff --git a/dbms/tests/performance/codec_gorilla.xml b/dbms/tests/performance/codec_gorilla.xml
new file mode 100644
index 000000000000..ba7d6297349d
--- /dev/null
+++ b/dbms/tests/performance/codec_gorilla.xml
@@ -0,0 +1,67 @@
+<test>
+    <name>IPv4 Functions</name>
+
+    <type>once</type>
+    <stop_conditions>
+        <any_of>
+            <average_speed_not_changing_for_ms>1000</average_speed_not_changing_for_ms>
+            <total_time_ms>2000</total_time_ms>
+        </any_of>
+    </stop_conditions>
+
+    <substitutions>
+        <substitution>
+            <name>table_suffix</name>
+            <values>
+                <value>g</value>
+                <value>lz4</value>
+                <value>g_lz4</value>
+            </values>
+        </substitution>
+    </substitutions>
+
+    <create_query>CREATE TABLE IF NOT EXISTS seq_g (n UInt64 CODEC(Gorilla, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS mon_g AS seq_g;</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS rnd_g AS seq_g;</create_query>
+
+    <create_query>CREATE TABLE IF NOT EXISTS seq_lz4 (n UInt64 CODEC(LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS mon_lz4 AS seq_lz4;</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS rnd_lz4 AS seq_lz4;</create_query>
+
+    <create_query>CREATE TABLE IF NOT EXISTS seq_g_lz4 (n UInt64 CODEC(Gorilla, LZ4, NONE)) ENGINE = MergeTree PARTITION BY tuple() ORDER BY tuple();</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS mon_g_lz4 AS seq_g_lz4;</create_query>
+    <create_query>CREATE TABLE IF NOT EXISTS rnd_g_lz4 AS seq_g_lz4;</create_query>
+
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT number/pi() FROM system.numbers LIMIT 100000</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT number+sin(number) FROM system.numbers LIMIT 100000</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT (rand() - 4294967295)/pi() FROM system.numbers LIMIT 100000</fill_query>
+    
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO seq_{table_suffix} (n) SELECT n FROM seq_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO mon_{table_suffix} (n) SELECT n FROM mon_{table_suffix}</fill_query>
+    <fill_query>INSERT INTO rnd_{table_suffix} (n) SELECT n FROM rnd_{table_suffix}</fill_query>
+
+
+    <query>INSERT INTO seq_{table_suffix} (n) SELECT number/pi() FROM system.numbers SETTINGS max_threads=1</query>
+    <query>INSERT INTO mon_{table_suffix} (n) SELECT number+sin(number) FROM system.numbers SETTINGS max_threads=1</query>
+    <query>INSERT INTO rnd_{table_suffix} (n) SELECT (rand() - 4294967295)/pi() FROM system.numbers SETTINGS max_threads=1</query>
+
+
+    <query>SELECT count(n) FROM seq_{table_suffix} SETTINGS max_threads=1</query>
+    <query>SELECT count(n) FROM mon_{table_suffix} SETTINGS max_threads=1</query>
+    <query>SELECT count(n) FROM rnd_{table_suffix} SETTINGS max_threads=1</query>
+
+
+    <drop_query>DROP TABLE IF EXISTS seq_{table_suffix}</drop_query>
+    <drop_query>DROP TABLE IF EXISTS mon_{table_suffix}</drop_query>
+    <drop_query>DROP TABLE IF EXISTS rnd_{table_suffix}</drop_query>
+
+</test>
diff --git a/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.reference b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.reference
new file mode 100644
index 000000000000..5fb3bfb36290
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.reference
@@ -0,0 +1,10 @@
+U64
+U32
+U16
+U8
+I64
+I32
+I16
+I8
+DT
+D
diff --git a/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.sql b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.sql
new file mode 100644
index 000000000000..a5ae4766ece0
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00950_test_double_delta_codec.sql
@@ -0,0 +1,151 @@
+USE test;
+
+DROP TABLE IF EXISTS codecTest;
+
+CREATE TABLE codecTest (
+    key      UInt64,
+    ref_valueU64 UInt64,
+    ref_valueU32 UInt32,
+    ref_valueU16 UInt16,
+    ref_valueU8  UInt8,
+    ref_valueI64 Int64,
+    ref_valueI32 Int32,
+    ref_valueI16 Int16,
+    ref_valueI8  Int8,
+    ref_valueDT  DateTime,
+    ref_valueD   Date,
+    valueU64 UInt64   CODEC(DoubleDelta),
+    valueU32 UInt32   CODEC(DoubleDelta),
+    valueU16 UInt16   CODEC(DoubleDelta),
+    valueU8  UInt8    CODEC(DoubleDelta),
+    valueI64 Int64    CODEC(DoubleDelta),
+    valueI32 Int32    CODEC(DoubleDelta),
+    valueI16 Int16    CODEC(DoubleDelta),
+    valueI8  Int8     CODEC(DoubleDelta),
+    valueDT  DateTime CODEC(DoubleDelta),
+    valueD   Date     CODEC(DoubleDelta)
+) Engine = MergeTree ORDER BY key;
+
+
+-- checking for overflow
+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueI64, valueI64)
+	VALUES (101, 18446744073709551615, 18446744073709551615, 9223372036854775807, 9223372036854775807), (202, 0, 0, -9223372036854775808, -9223372036854775808), (203, 18446744073709551615, 18446744073709551615, 9223372036854775807, 9223372036854775807);
+
+-- n^3 covers all double delta storage cases, from small difference between neighbouref_values (stride) to big.
+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueU32, valueU32, ref_valueU16, valueU16, ref_valueU8, valueU8, ref_valueI64, valueI64, ref_valueI32, valueI32, ref_valueI16, valueI16, ref_valueI8, valueI8, ref_valueDT, valueDT, ref_valueD, valueD)
+	SELECT number as n, n * n * n as v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, toDateTime(v), toDateTime(v), toDate(v), toDate(v)
+	FROM system.numbers LIMIT 101, 100;
+
+-- best case - constant stride
+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueU32, valueU32, ref_valueU16, valueU16, ref_valueU8, valueU8, ref_valueI64, valueI64, ref_valueI32, valueI32, ref_valueI16, valueI16, ref_valueI8, valueI8, ref_valueDT, valueDT, ref_valueD, valueD)
+	SELECT number as n, n as v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, toDateTime(v), toDateTime(v), toDate(v), toDate(v)
+	FROM system.numbers LIMIT 201, 100;
+
+
+-- worst case - random stride
+INSERT INTO codecTest (key, ref_valueU64, valueU64, ref_valueU32, valueU32, ref_valueU16, valueU16, ref_valueU8, valueU8, ref_valueI64, valueI64, ref_valueI32, valueI32, ref_valueI16, valueI16, ref_valueI8, valueI8, ref_valueDT, valueDT, ref_valueD, valueD)
+	SELECT number as n, n + (rand64() - 9223372036854775807)/1000 as v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, toDateTime(v), toDateTime(v), toDate(v), toDate(v)
+	FROM system.numbers LIMIT 301, 100;
+
+
+SELECT 'U64';
+SELECT
+	key,
+	ref_valueU64, valueU64, ref_valueU64 - valueU64 as dU64
+FROM codecTest
+WHERE
+	dU64 != 0
+LIMIT 10;
+
+
+SELECT 'U32';
+SELECT
+	key,
+	ref_valueU32, valueU32, ref_valueU32 - valueU32 as dU32
+FROM codecTest
+WHERE
+	dU32 != 0
+LIMIT 10;
+
+
+SELECT 'U16';
+SELECT
+	key,
+	ref_valueU16, valueU16, ref_valueU16 - valueU16 as dU16
+FROM codecTest
+WHERE
+	dU16 != 0
+LIMIT 10;
+
+
+SELECT 'U8';
+SELECT
+	key,
+	ref_valueU8, valueU8, ref_valueU8 - valueU8 as dU8
+FROM codecTest
+WHERE
+	dU8 != 0
+LIMIT 10;
+
+
+SELECT 'I64';
+SELECT
+	key,
+	ref_valueI64, valueI64, ref_valueI64 - valueI64 as dI64
+FROM codecTest
+WHERE
+	dI64 != 0
+LIMIT 10;
+
+
+SELECT 'I32';
+SELECT
+	key,
+	ref_valueI32, valueI32, ref_valueI32 - valueI32 as dI32
+FROM codecTest
+WHERE
+	dI32 != 0
+LIMIT 10;
+
+
+SELECT 'I16';
+SELECT
+	key,
+	ref_valueI16, valueI16, ref_valueI16 - valueI16 as dI16
+FROM codecTest
+WHERE
+	dI16 != 0
+LIMIT 10;
+
+
+SELECT 'I8';
+SELECT
+	key,
+	ref_valueI8, valueI8, ref_valueI8 - valueI8 as dI8
+FROM codecTest
+WHERE
+	dI8 != 0
+LIMIT 10;
+
+
+SELECT 'DT';
+SELECT
+	key,
+	ref_valueDT, valueDT, ref_valueDT - valueDT as dDT
+FROM codecTest
+WHERE
+	dDT != 0
+LIMIT 10;
+
+
+SELECT 'D';
+SELECT
+	key,
+	ref_valueD, valueD, ref_valueD - valueD as dD
+FROM codecTest
+WHERE
+	dD != 0
+LIMIT 10;
+
+
+DROP TABLE IF EXISTS codecTest;
\ No newline at end of file
diff --git a/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.reference b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.reference
new file mode 100644
index 000000000000..5e871ea03295
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.reference
@@ -0,0 +1,2 @@
+F64
+F32
diff --git a/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.sql b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.sql
new file mode 100644
index 000000000000..c4975cdcb5de
--- /dev/null
+++ b/dbms/tests/queries/0_stateless/00950_test_gorilla_codec.sql
@@ -0,0 +1,63 @@
+USE test;
+
+DROP TABLE IF EXISTS codecTest;
+
+CREATE TABLE codecTest (
+    key      UInt64,
+    name     String,
+    ref_valueF64 Float64,
+    ref_valueF32 Float32,
+    valueF64 Float64  CODEC(Gorilla),
+    valueF32 Float32  CODEC(Gorilla)
+) Engine = MergeTree ORDER BY key;
+
+-- best case - same value
+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)
+	SELECT number AS n, 'e()', e() AS v, v, v, v FROM system.numbers LIMIT 1, 100;
+
+-- good case - values that grow insignificantly
+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)
+	SELECT number AS n, 'log2(n)', log2(n) AS v, v, v, v FROM system.numbers LIMIT 101, 100;
+
+-- bad case - values differ significantly
+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)
+	SELECT number AS n, 'n*sqrt(n)', n*sqrt(n) AS v, v, v, v FROM system.numbers LIMIT 201, 100;
+
+-- worst case - almost like a random values
+INSERT INTO codecTest (key, name, ref_valueF64, valueF64, ref_valueF32, valueF32)
+	SELECT number AS n, 'sin(n*n*n)*n', sin(n * n * n * n* n) AS v, v, v, v FROM system.numbers LIMIT 301, 100;
+
+
+-- These floating-point values are expected to be BINARY equal, so comparing by-value is Ok here.
+
+-- referencing previous row key, value, and case name to simplify debugging.
+SELECT 'F64';
+SELECT
+	c1.key, c1.name,
+	c1.ref_valueF64, c1.valueF64, c1.ref_valueF64 - c1.valueF64 AS dF64,
+	'prev:',
+	c2.key, c2.ref_valueF64
+FROM
+	codecTest as c1, codecTest as c2
+WHERE
+	dF64 != 0
+AND
+	c2.key = c1.key - 1
+LIMIT 10;
+
+
+SELECT 'F32';
+SELECT
+	c1.key, c1.name,
+	c1.ref_valueF32, c1.valueF32, c1.ref_valueF32 - c1.valueF32 AS dF32,
+	'prev:',
+	c2.key, c2.ref_valueF32
+FROM
+	codecTest as c1, codecTest as c2
+WHERE
+	dF32 != 0
+AND
+	c2.key = c1.key - 1
+LIMIT 10;
+
+DROP TABLE IF EXISTS codecTest;
\ No newline at end of file
