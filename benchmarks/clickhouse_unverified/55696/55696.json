{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55696,
  "instance_id": "ClickHouse__ClickHouse-55696",
  "issue_numbers": [
    "51402"
  ],
  "base_commit": "73d6f0ddafcc91fadfc63bc823778762c3f1e389",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 2e12b42318ad..ccf290c8e20c 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -4155,6 +4155,18 @@ Possible values:\n \n Default value: `0`.\n \n+## date_time_overflow_behavior {#date_time_overflow_behavior}\n+\n+Defines the behavior when [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md), [DateTime64](../../sql-reference/data-types/datetime64.md) or integers are converted into Date, Date32, DateTime or DateTime64 but the value cannot be represented in the result type.\n+\n+Possible values:\n+\n+- `ignore` \u2014 Silently ignore overflows. The result is random.\n+- `throw` \u2014 Throw an exception in case of conversion overflow.\n+- `saturate` \u2014 Silently saturate the result. If the value is smaller than the smallest value that can be represented by the target type, the result is chosen as the smallest representable value. If the value is bigger than the largest value that can be represented by the target type, the result is chosen as the largest representable value.\n+\n+Default value: `ignore`.\n+\n ## optimize_move_to_prewhere {#optimize_move_to_prewhere}\n \n Enables or disables automatic [PREWHERE](../../sql-reference/statements/select/prewhere.md) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries.\ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex c58b3ae8107a..8757cf2f5e78 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -3838,6 +3838,18 @@ SELECT * FROM positional_arguments ORDER BY 2,3;\n \n \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `0`.\n \n+## date_time_overflow_behavior {#date_time_overflow_behavior}\n+\n+\u0417\u0430\u0434\u0430\u0451\u0442 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0438 [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md), [DateTime64](../../sql-reference/data-types/datetime64.md), \u0430 \u0442\u0430\u043a\u0436\u0435 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445 \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445 \u043a Date, Date32, DateTime, DateTime64 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0432\u044b\u0445\u043e\u0434\u0438\u0442 \u0437\u0430 \u043f\u0440\u0435\u0434\u0435\u043b\u044b \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0433\u043e \u0442\u0438\u043f\u0430.\n+\n+\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f:\n+\n+- `ignore` \u2014 \u041c\u043e\u043b\u0447\u0430 \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435. \u0412 \u0442\u0430\u043a\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435, \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u0431\u0443\u0434\u0435\u0442 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435.\n+- `throw` \u2014 \u0412\u044b\u043a\u0438\u043d\u0443\u0442\u044c \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u0438 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0438.\n+- `saturate` \u2014 \u041c\u043e\u043b\u0447\u0430 \u043e\u043a\u0440\u0443\u0433\u043b\u0438\u0442\u044c \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0433\u043e (\u0442\u043e \u0435\u0441\u0442\u044c \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0435\u0433\u043e \u0438\u043b\u0438 \u043d\u0430\u0438\u043c\u0435\u043d\u044c\u0448\u0435\u0433\u043e) \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438\u0437 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430.\n+\n+\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `ignore`.\n+\n ## optimize_move_to_prewhere {#optimize_move_to_prewhere}\n \n \u0412\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0438\u043b\u0438 \u043e\u0442\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0430\u0446\u0438\u044e [PREWHERE](../../sql-reference/statements/select/prewhere.md) \u0432 \u0437\u0430\u043f\u0440\u043e\u0441\u0430\u0445 [SELECT](../../sql-reference/statements/select/index.md).\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 57ac479c3adc..5111f48ef6a2 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -813,7 +813,7 @@ class IColumn;\n     M(Bool, create_table_empty_primary_key_by_default, false, \"Allow to create *MergeTree tables with empty primary key when ORDER BY and PRIMARY KEY not specified\", 0) \\\n \n // End of COMMON_SETTINGS\n-    // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS, move obsolete settings to OBSOLETE_SETTINGS and obsolete format settings to OBSOLETE_FORMAT_SETTINGS.\n+// Please add settings related to formats into the FORMAT_FACTORY_SETTINGS, move obsolete settings to OBSOLETE_SETTINGS and obsolete format settings to OBSOLETE_FORMAT_SETTINGS.\n \n #define MAKE_OBSOLETE(M, TYPE, NAME, DEFAULT) \\\n     M(TYPE, NAME, DEFAULT, \"Obsolete setting, does nothing.\", BaseSettingsHelpers::Flags::OBSOLETE)\n@@ -1077,6 +1077,8 @@ class IColumn;\n     \\\n     M(Bool, dictionary_use_async_executor, false, \"Execute a pipeline for reading dictionary source in several threads. It's supported only by dictionaries with local CLICKHOUSE source.\", 0) \\\n     M(Bool, precise_float_parsing, false, \"Prefer more precise (but slower) float parsing algorithm\", 0) \\\n+    M(DateTimeOverflowBehavior, date_time_overflow_behavior, \"ignore\", \"Overflow mode for Date, Date32, DateTime, DateTime64 types. Possible values: 'ignore', 'throw', 'saturate'.\", 0) \\\n+\n \n // End of FORMAT_FACTORY_SETTINGS\n // Please add settings non-related to formats into the COMMON_SETTINGS above.\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex 82e158877c56..9b84d092fd06 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -190,4 +190,9 @@ IMPLEMENT_SETTING_ENUM(ExternalCommandStderrReaction, ErrorCodes::BAD_ARGUMENTS,\n      {\"log_last\", ExternalCommandStderrReaction::LOG_LAST},\n      {\"throw\", ExternalCommandStderrReaction::THROW}})\n \n+IMPLEMENT_SETTING_ENUM(DateTimeOverflowBehavior, ErrorCodes::BAD_ARGUMENTS,\n+                       {{\"throw\", FormatSettings::DateTimeOverflowBehavior::Throw},\n+                        {\"ignore\", FormatSettings::DateTimeOverflowBehavior::Ignore},\n+                        {\"saturate\", FormatSettings::DateTimeOverflowBehavior::Saturate}})\n+\n }\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex 7db8c88c53d7..bf32881cca87 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -242,4 +242,6 @@ DECLARE_SETTING_ENUM(S3QueueAction)\n \n DECLARE_SETTING_ENUM(ExternalCommandStderrReaction)\n \n+DECLARE_SETTING_ENUM_WITH_RENAME(DateTimeOverflowBehavior, FormatSettings::DateTimeOverflowBehavior)\n+\n }\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 920a3cb1bb53..d51ea9ad2d0e 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -227,6 +227,7 @@ FormatSettings getFormatSettings(ContextPtr context, const Settings & settings)\n     format_settings.native.allow_types_conversion = settings.input_format_native_allow_types_conversion;\n     format_settings.max_parser_depth = context->getSettingsRef().max_parser_depth;\n     format_settings.client_protocol_version = context->getClientProtocolVersion();\n+    format_settings.date_time_overflow_behavior = settings.date_time_overflow_behavior;\n \n     /// Validate avro_schema_registry_url with RemoteHostFilter when non-empty and in Server context\n     if (format_settings.schema.is_server)\ndiff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h\nindex 77fd8e1fcbd8..382f8b7173ab 100644\n--- a/src/Formats/FormatSettings.h\n+++ b/src/Formats/FormatSettings.h\n@@ -88,6 +88,15 @@ struct FormatSettings\n         IntervalOutputFormat output_format = IntervalOutputFormat::Numeric;\n     } interval;\n \n+    enum class DateTimeOverflowBehavior\n+    {\n+        Ignore,\n+        Throw,\n+        Saturate\n+    };\n+\n+    DateTimeOverflowBehavior date_time_overflow_behavior = DateTimeOverflowBehavior::Ignore;\n+\n     bool input_format_ipv4_default_on_conversion_error = false;\n     bool input_format_ipv6_default_on_conversion_error = false;\n \ndiff --git a/src/Functions/DateTimeTransforms.cpp b/src/Functions/DateTimeTransforms.cpp\nindex af1d9a4a5bb8..7ec13be9d6d0 100644\n--- a/src/Functions/DateTimeTransforms.cpp\n+++ b/src/Functions/DateTimeTransforms.cpp\n@@ -22,5 +22,4 @@ void throwDate32IsNotSupported(const char * name)\n {\n     throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type Date32 of argument for function {}\", name);\n }\n-\n }\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 0814d640f2bb..9737e69bf340 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -23,12 +23,15 @@ namespace DB\n static constexpr auto microsecond_multiplier = 1000000;\n static constexpr auto millisecond_multiplier = 1000;\n \n+static constexpr FormatSettings::DateTimeOverflowBehavior default_date_time_overflow_behavior = FormatSettings::DateTimeOverflowBehavior::Ignore;\n+\n namespace ErrorCodes\n {\n     extern const int CANNOT_CONVERT_TYPE;\n     extern const int DECIMAL_OVERFLOW;\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE;\n }\n \n /** Transformations.\n@@ -44,6 +47,12 @@ namespace ErrorCodes\n   *  factor-transformation F is \"round to the nearest month\" (2015-02-03 -> 2015-02-01).\n   */\n \n+constexpr time_t MAX_DATETIME64_TIMESTAMP = 10413791999LL;    //  1900-01-01 00:00:00 UTC\n+constexpr time_t MIN_DATETIME64_TIMESTAMP = -2208988800LL;    //  2299-12-31 23:59:59 UTC\n+constexpr time_t MAX_DATETIME_TIMESTAMP = 0xFFFFFFFF;\n+constexpr time_t MAX_DATE_TIMESTAMP = 5662310399;       // 2149-06-06 23:59:59 UTC\n+constexpr time_t MAX_DATETIME_DAY_NUM =  49710;               // 2106-02-07\n+\n [[noreturn]] void throwDateIsNotSupported(const char * name);\n [[noreturn]] void throwDateTimeIsNotSupported(const char * name);\n [[noreturn]] void throwDate32IsNotSupported(const char * name);\n@@ -57,25 +66,51 @@ struct ZeroTransform\n     static UInt16 execute(UInt16, const DateLUTImpl &) { return 0; }\n };\n \n+template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior>\n struct ToDateImpl\n {\n     static constexpr auto name = \"toDate\";\n \n     static UInt16 execute(const DecimalUtils::DecimalComponents<DateTime64> & t, const DateLUTImpl & time_zone)\n     {\n-        return static_cast<UInt16>(time_zone.toDayNum(t.whole));\n+        return execute(t.whole, time_zone);\n     }\n+\n     static UInt16 execute(Int64 t, const DateLUTImpl & time_zone)\n     {\n-        return UInt16(time_zone.toDayNum(t));\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Saturate)\n+        {\n+            if (t < 0)\n+                t = 0;\n+            else if (t > MAX_DATE_TIMESTAMP)\n+                t = MAX_DATE_TIMESTAMP;\n+        }\n+        else if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (t < 0 || t > MAX_DATE_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type Date\", t);\n+        }\n+        return static_cast<UInt16>(time_zone.toDayNum(t));\n     }\n     static UInt16 execute(UInt32 t, const DateLUTImpl & time_zone)\n     {\n-        return UInt16(time_zone.toDayNum(t));\n+        return UInt16(time_zone.toDayNum(t));  /// never causes overflow by design\n     }\n-    static UInt16 execute(Int32, const DateLUTImpl &)\n+    static UInt16 execute(Int32 t, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Saturate)\n+        {\n+            if (t < 0)\n+                return UInt16(0);\n+            else if (t > DATE_LUT_MAX_DAY_NUM)\n+                return UInt16(DATE_LUT_MAX_DAY_NUM);\n+        }\n+        else if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (t < 0 || t > DATE_LUT_MAX_DAY_NUM) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type Date\", t);\n+        }\n+        return static_cast<UInt16>(t);\n     }\n     static UInt16 execute(UInt16 d, const DateLUTImpl &)\n     {\n@@ -750,7 +785,7 @@ struct ToTimeImpl\n     }\n     static constexpr bool hasPreimage() { return false; }\n \n-    using FactorTransform = ToDateImpl;\n+    using FactorTransform = ToDateImpl<>;\n };\n \n struct ToStartOfMinuteImpl\n@@ -1401,7 +1436,7 @@ struct ToHourImpl\n     }\n     static constexpr bool hasPreimage() { return false; }\n \n-    using FactorTransform = ToDateImpl;\n+    using FactorTransform = ToDateImpl<>;\n };\n \n struct TimezoneOffsetImpl\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 69c5aa48155f..bda5fce1ac85 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -90,9 +90,9 @@ namespace ErrorCodes\n     extern const int NOT_IMPLEMENTED;\n     extern const int CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN;\n     extern const int CANNOT_PARSE_BOOL;\n+    extern const int VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE;\n }\n \n-\n /** Type conversion functions.\n   * toType - conversion in \"natural way\";\n   */\n@@ -133,7 +133,9 @@ struct ConvertReturnZeroOnErrorTag {};\n /** Conversion of number types to each other, enums to numbers, dates and datetimes to numbers and back: done by straight assignment.\n   *  (Date is represented internally as number of days from some day; DateTime - as unix timestamp)\n   */\n-template <typename FromDataType, typename ToDataType, typename Name, typename SpecialTag = ConvertDefaultBehaviorTag>\n+template <typename FromDataType, typename ToDataType, typename Name,\n+    typename SpecialTag = ConvertDefaultBehaviorTag,\n+    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior>\n struct ConvertImpl\n {\n     using FromFieldType = typename FromDataType::FieldType;\n@@ -388,28 +390,53 @@ struct ConvertImpl\n \n /** Conversion of DateTime to Date: throw off time component.\n   */\n-template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeDateTime, DataTypeDate, ToDateImpl> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDateTime, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDateTime, DataTypeDate, ToDateImpl<date_time_overflow_behavior>, false> {};\n \n /** Conversion of DateTime to Date32: throw off time component.\n   */\n-template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeDateTime, DataTypeDate32, ToDate32Impl> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDateTime, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDateTime, DataTypeDate32, ToDate32Impl, false> {};\n \n /** Conversion of Date to DateTime: adding 00:00:00 time component.\n   */\n+template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior>\n struct ToDateTimeImpl\n {\n     static constexpr auto name = \"toDateTime\";\n \n     static UInt32 execute(UInt16 d, const DateLUTImpl & time_zone)\n     {\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (d > MAX_DATETIME_DAY_NUM) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Day number {} is out of bounds of type DateTime\", d);\n+        }\n+        else if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Saturate)\n+        {\n+            if (d > MAX_DATETIME_DAY_NUM)\n+                d = MAX_DATETIME_DAY_NUM;\n+        }\n         return static_cast<UInt32>(time_zone.fromDayNum(DayNum(d)));\n     }\n \n-    static Int64 execute(Int32 d, const DateLUTImpl & time_zone)\n+    static UInt32 execute(Int32 d, const DateLUTImpl & time_zone)\n     {\n-        return time_zone.fromDayNum(ExtendedDayNum(d));\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Saturate)\n+        {\n+            if (d < 0)\n+                return 0;\n+            else if (d > MAX_DATETIME_DAY_NUM)\n+                d = MAX_DATETIME_DAY_NUM;\n+        }\n+        else if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (d < 0 || d > MAX_DATETIME_DAY_NUM) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type DateTime\", d);\n+        }\n+        return static_cast<UInt32>(time_zone.fromDayNum(ExtendedDayNum(d)));\n     }\n \n     static UInt32 execute(UInt32 dt, const DateLUTImpl & /*time_zone*/)\n@@ -417,36 +444,63 @@ struct ToDateTimeImpl\n         return dt;\n     }\n \n-    // TODO: return UInt32 ???\n-    static Int64 execute(Int64 dt64, const DateLUTImpl & /*time_zone*/)\n+    static UInt32 execute(Int64 dt64, const DateLUTImpl & /*time_zone*/)\n     {\n-        return dt64;\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Ignore)\n+            return static_cast<UInt32>(dt64);\n+        else\n+        {\n+            if (dt64 < 0 || dt64 >= MAX_DATETIME_TIMESTAMP)\n+            {\n+                if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Saturate)\n+                    return dt64 < 0 ? 0 : std::numeric_limits<UInt32>::max();\n+                else\n+                    throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type DateTime\", dt64);\n+            }\n+            else\n+                return static_cast<UInt32>(dt64);\n+        }\n     }\n };\n \n-template <typename Name> struct ConvertImpl<DataTypeDate, DataTypeDateTime, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeDate, DataTypeDateTime, ToDateTimeImpl> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDate, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDate, DataTypeDateTime, ToDateTimeImpl<date_time_overflow_behavior>, false> {};\n \n-template <typename Name> struct ConvertImpl<DataTypeDate32, DataTypeDateTime, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeDate32, DataTypeDateTime, ToDateTimeImpl> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDate32, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDate32, DataTypeDateTime, ToDateTimeImpl<date_time_overflow_behavior>, false> {};\n \n /// Implementation of toDate function.\n \n-template <typename FromType, typename ToType>\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTransform32Or64\n {\n     static constexpr auto name = \"toDate\";\n \n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n-        // since converting to Date, no need in values outside of default LUT range.\n-        return (from <= DATE_LUT_MAX_DAY_NUM)\n-            ? from\n-            : time_zone.toDayNum(std::min(time_t(from), time_t(0xFFFFFFFF)));\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from > MAX_DATETIME_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type Date\", from);\n+        }\n+        /// if value is smaller (or equal) than maximum day value for Date, than treat it as day num,\n+        /// otherwise treat it as unix timestamp. This is a bit weird, but we leave this behavior.\n+        if (from <= DATE_LUT_MAX_DAY_NUM)\n+            return from;\n+        else\n+            return time_zone.toDayNum(std::min(time_t(from), time_t(MAX_DATETIME_TIMESTAMP)));\n     }\n };\n \n-template <typename FromType, typename ToType>\n+/** Conversion of Date32 to Date.\n+  */\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDate32, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDate32, DataTypeDate, ToDateImpl<date_time_overflow_behavior>, false> {};\n+\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTransform32Or64Signed\n {\n     static constexpr auto name = \"toDate\";\n@@ -454,16 +508,23 @@ struct ToDateTransform32Or64Signed\n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n         // TODO: decide narrow or extended range based on FromType\n-        /// The function should be monotonic (better for query optimizations), so we saturate instead of overflow.\n-        if (from < 0)\n-            return 0;\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from < 0 || from > MAX_DATE_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type Date\", from);\n+        }\n+        else\n+        {\n+            if (from < 0)\n+                return 0;\n+        }\n         return (from <= DATE_LUT_MAX_DAY_NUM)\n             ? static_cast<ToType>(from)\n-            : time_zone.toDayNum(std::min(time_t(from), time_t(0xFFFFFFFF)));\n+            : time_zone.toDayNum(std::min(time_t(from), time_t(MAX_DATE_TIMESTAMP)));\n     }\n };\n \n-template <typename FromType, typename ToType>\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTransform8Or16Signed\n {\n     static constexpr auto name = \"toDate\";\n@@ -471,30 +532,44 @@ struct ToDateTransform8Or16Signed\n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n         if (from < 0)\n-            return 0;\n+        {\n+            if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Value {} is out of bounds of type Date\", from);\n+            else\n+                return 0;\n+        }\n         return from;\n     }\n };\n \n-template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-        : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate32, TransformDateTime64<ToDate32Impl>> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDateTime64, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+        : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate32, TransformDateTime64<ToDate32Impl>, false> {};\n \n /// Implementation of toDate32 function.\n \n-template <typename FromType, typename ToType>\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDate32Transform32Or64\n {\n     static constexpr auto name = \"toDate32\";\n \n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n-        return (from < DATE_LUT_MAX_EXTEND_DAY_NUM)\n-            ? static_cast<ToType>(from)\n-            : time_zone.toDayNum(std::min(time_t(from), time_t(0xFFFFFFFF)));\n+        if (from < DATE_LUT_MAX_EXTEND_DAY_NUM)\n+            return static_cast<ToType>(from);\n+        else\n+        {\n+            if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+            {\n+                if (from > MAX_DATETIME64_TIMESTAMP) [[unlikely]]\n+                    throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type Date32\", from);\n+            }\n+            return time_zone.toDayNum(std::min(time_t(from), time_t(MAX_DATETIME64_TIMESTAMP)));\n+        }\n     }\n };\n \n-template <typename FromType, typename ToType>\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDate32Transform32Or64Signed\n {\n     static constexpr auto name = \"toDate32\";\n@@ -502,11 +577,19 @@ struct ToDate32Transform32Or64Signed\n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n         static const Int32 daynum_min_offset = -static_cast<Int32>(time_zone.getDayNumOffsetEpoch());\n+\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from < daynum_min_offset || from > MAX_DATETIME64_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type Date32\", from);\n+        }\n+\n         if (from < daynum_min_offset)\n             return daynum_min_offset;\n+\n         return (from < DATE_LUT_MAX_EXTEND_DAY_NUM)\n             ? static_cast<ToType>(from)\n-            : time_zone.toDayNum(std::min(time_t(Int64(from)), time_t(0xFFFFFFFF)));\n+            : time_zone.toDayNum(std::min(time_t(Int64(from)), time_t(MAX_DATETIME64_TIMESTAMP)));\n     }\n };\n \n@@ -522,7 +605,7 @@ struct ToDate32Transform8Or16Signed\n };\n \n /** Special case of converting Int8, Int16, (U)Int32 or (U)Int64 (and also, for convenience,\n-  * Float32, Float64) to Date. If the number is negative, saturate it to unix epoch time. If the\n+  * Float32, Float64) to Date. If the\n   * number is less than 65536, then it is treated as DayNum, and if it's greater or equals to 65536,\n   * then treated as unix timestamp. If the number exceeds UInt32, saturate to MAX_UINT32 then as DayNum.\n   * It's a bit illogical, as we actually have two functions in one.\n@@ -530,53 +613,89 @@ struct ToDate32Transform8Or16Signed\n   *  when user write toDate(UInt32), expecting conversion of unix timestamp to Date.\n   *  (otherwise such usage would be frequent mistake).\n   */\n-template <typename Name> struct ConvertImpl<DataTypeUInt32, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeUInt32, DataTypeDate, ToDateTransform32Or64<UInt32, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDate, ToDateTransform32Or64<UInt64, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt8, DataTypeDate, ToDateTransform8Or16Signed<Int8, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt16, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt16, DataTypeDate, ToDateTransform8Or16Signed<Int16, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt32, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt32, DataTypeDate, ToDateTransform32Or64Signed<Int32, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt64, DataTypeDate, ToDateTransform32Or64Signed<Int64, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDate, ToDateTransform32Or64Signed<Float32, UInt16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDate, ToDateTransform32Or64Signed<Float64, UInt16>> {};\n-\n-template <typename Name> struct ConvertImpl<DataTypeUInt32, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeUInt32, DataTypeDate32, ToDate32Transform32Or64<UInt32, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDate32, ToDate32Transform32Or64<UInt64, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt8, DataTypeDate32, ToDate32Transform8Or16Signed<Int8, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt16, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt16, DataTypeDate32, ToDate32Transform8Or16Signed<Int16, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt32, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt32, DataTypeDate32, ToDate32Transform32Or64Signed<Int32, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeInt64, DataTypeDate32, ToDate32Transform32Or64Signed<Int64, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDate32, ToDate32Transform32Or64Signed<Float32, Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDate32, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDate32, ToDate32Transform32Or64Signed<Float64, Int32>> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeUInt32, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeUInt32, DataTypeDate, ToDateTransform32Or64<UInt32, UInt16, default_date_time_overflow_behavior>, false> {};\n \n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeUInt64, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDate, ToDateTransform32Or64<UInt64, UInt16, default_date_time_overflow_behavior>, false> {};\n \n-template <typename FromType, typename ToType>\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt8, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt8, DataTypeDate, ToDateTransform8Or16Signed<Int8, UInt16, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt16, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt16, DataTypeDate, ToDateTransform8Or16Signed<Int16, UInt16, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt32, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt32, DataTypeDate, ToDateTransform32Or64Signed<Int32, UInt16, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt64, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt64, DataTypeDate, ToDateTransform32Or64Signed<Int64, UInt16, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat32, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDate, ToDateTransform32Or64Signed<Float32, UInt16, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat64, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDate, ToDateTransform32Or64Signed<Float64, UInt16, default_date_time_overflow_behavior>, false> {};\n+\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeUInt32, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeUInt32, DataTypeDate32, ToDate32Transform32Or64<UInt32, Int32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeUInt64, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDate32, ToDate32Transform32Or64<UInt64, Int32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt8, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt8, DataTypeDate32, ToDate32Transform8Or16Signed<Int8, Int32>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt16, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt16, DataTypeDate32, ToDate32Transform8Or16Signed<Int16, Int32>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt32, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt32, DataTypeDate32, ToDate32Transform32Or64Signed<Int32, Int32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt64, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt64, DataTypeDate32, ToDate32Transform32Or64Signed<Int64, Int32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat32, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDate32, ToDate32Transform32Or64Signed<Float32, Int32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat64, DataTypeDate32, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDate32, ToDate32Transform32Or64Signed<Float64, Int32, default_date_time_overflow_behavior>, false> {};\n+\n+\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTimeTransform64\n {\n     static constexpr auto name = \"toDateTime\";\n \n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n-        return static_cast<ToType>(std::min(time_t(from), time_t(0xFFFFFFFF)));\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from > MAX_DATETIME_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type DateTime\", from);\n+        }\n+        return static_cast<ToType>(std::min(time_t(from), time_t(MAX_DATETIME_TIMESTAMP)));\n     }\n };\n \n-template <typename FromType, typename ToType>\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTimeTransformSigned\n {\n     static constexpr auto name = \"toDateTime\";\n@@ -584,51 +703,68 @@ struct ToDateTimeTransformSigned\n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n         if (from < 0)\n-            return 0;\n+        {\n+            if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type DateTime\", from);\n+            else\n+                return 0;\n+        }\n         return from;\n     }\n };\n \n-template <typename FromType, typename ToType>\n+template <typename FromType, typename ToType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTimeTransform64Signed\n {\n     static constexpr auto name = \"toDateTime\";\n \n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from < 0 || from > MAX_DATETIME_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type DateTime\", from);\n+        }\n+\n         if (from < 0)\n             return 0;\n-        return static_cast<ToType>(std::min(time_t(from), time_t(0xFFFFFFFF)));\n+        return static_cast<ToType>(std::min(time_t(from), time_t(MAX_DATETIME_TIMESTAMP)));\n     }\n };\n \n-/** Special case of converting Int8, Int16, Int32 or (U)Int64 (and also, for convenience, Float32,\n-  * Float64) to DateTime. If the number is negative, saturate it to unix epoch time. If the number\n-  * exceeds UInt32, saturate to MAX_UINT32.\n-  */\n-template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeInt8, DataTypeDateTime, ToDateTimeTransformSigned<Int8, UInt32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt16, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeInt16, DataTypeDateTime, ToDateTimeTransformSigned<Int16, UInt32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt32, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeInt32, DataTypeDateTime, ToDateTimeTransformSigned<Int32, UInt32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeInt64, DataTypeDateTime, ToDateTimeTransform64Signed<Int64, UInt32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDateTime, ToDateTimeTransform64<UInt64, UInt32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDateTime, ToDateTimeTransform64Signed<Float32, UInt32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDateTime, Name>\n-    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime, ToDateTimeTransform64Signed<Float64, UInt32>> {};\n-\n-constexpr time_t LUT_MIN_TIME = -2208988800l;           //  1900-01-01 UTC\n-\n-constexpr time_t LUT_MAX_TIME = 10413791999l;           // 2299-12-31 UTC\n+/// Special case of converting Int8, Int16, Int32 or (U)Int64 (and also, for convenience, Float32, Float64) to DateTime.\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt8, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt8, DataTypeDateTime, ToDateTimeTransformSigned<Int8, UInt32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt16, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt16, DataTypeDateTime, ToDateTimeTransformSigned<Int16, UInt32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt32, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt32, DataTypeDateTime, ToDateTimeTransformSigned<Int32, UInt32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt64, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt64, DataTypeDateTime, ToDateTimeTransform64Signed<Int64, UInt32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeUInt64, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDateTime, ToDateTimeTransform64<UInt64, UInt32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat32, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDateTime, ToDateTimeTransform64Signed<Float32, UInt32, default_date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat64, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime, ToDateTimeTransform64Signed<Float64, UInt32, default_date_time_overflow_behavior>, false> {};\n \n /** Conversion of numeric to DateTime64\n   */\n \n-template <typename FromType>\n+template <typename FromType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTime64TransformUnsigned\n {\n     static constexpr auto name = \"toDateTime64\";\n@@ -641,11 +777,18 @@ struct ToDateTime64TransformUnsigned\n \n     NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n     {\n-        from = std::min<time_t>(from, LUT_MAX_TIME);\n-        return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(from, 0, scale_multiplier);\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from > MAX_DATETIME64_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type DateTime64\", from);\n+            else\n+                return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(from, 0, scale_multiplier);\n+        }\n+        else\n+            return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(std::min<time_t>(from, MAX_DATETIME64_TIMESTAMP), 0, scale_multiplier);\n     }\n };\n-template <typename FromType>\n+template <typename FromType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTime64TransformSigned\n {\n     static constexpr auto name = \"toDateTime64\";\n@@ -658,12 +801,18 @@ struct ToDateTime64TransformSigned\n \n     NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n     {\n-        from = static_cast<FromType>(std::max<time_t>(from, LUT_MIN_TIME));\n-        from = static_cast<FromType>(std::min<time_t>(from, LUT_MAX_TIME));\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from < MIN_DATETIME64_TIMESTAMP || from > MAX_DATETIME64_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type DateTime64\", from);\n+        }\n+        from = static_cast<FromType>(std::max<time_t>(from, MIN_DATETIME64_TIMESTAMP));\n+        from = static_cast<FromType>(std::min<time_t>(from, MAX_DATETIME64_TIMESTAMP));\n+\n         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(from, 0, scale_multiplier);\n     }\n };\n-template <typename FromDataType, typename FromType>\n+template <typename FromDataType, typename FromType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n struct ToDateTime64TransformFloat\n {\n     static constexpr auto name = \"toDateTime64\";\n@@ -676,26 +825,45 @@ struct ToDateTime64TransformFloat\n \n     NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n     {\n-        from = std::max(from, static_cast<FromType>(LUT_MIN_TIME));\n-        from = std::min(from, static_cast<FromType>(LUT_MAX_TIME));\n+        if constexpr (date_time_overflow_behavior == FormatSettings::DateTimeOverflowBehavior::Throw)\n+        {\n+            if (from < MIN_DATETIME64_TIMESTAMP || from > MAX_DATETIME64_TIMESTAMP) [[unlikely]]\n+                throw Exception(ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE, \"Timestamp value {} is out of bounds of type DateTime64\", from);\n+        }\n+\n+        from = std::max(from, static_cast<FromType>(MIN_DATETIME64_TIMESTAMP));\n+        from = std::min(from, static_cast<FromType>(MAX_DATETIME64_TIMESTAMP));\n         return convertToDecimal<FromDataType, DataTypeDateTime64>(from, scale);\n     }\n };\n \n-template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeInt8, DataTypeDateTime64, ToDateTime64TransformSigned<Int8>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt16, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeInt16, DataTypeDateTime64, ToDateTime64TransformSigned<Int16>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt32, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeInt32, DataTypeDateTime64, ToDateTime64TransformSigned<Int32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeInt64, DataTypeDateTime64, ToDateTime64TransformSigned<Int64>> {};\n-template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDateTime64, ToDateTime64TransformUnsigned<UInt64>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDateTime64, ToDateTime64TransformFloat<DataTypeFloat32, Float32>> {};\n-template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime64, ToDateTime64TransformFloat<DataTypeFloat64, Float64>> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt8, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt8, DataTypeDateTime64, ToDateTime64TransformSigned<Int8, date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt16, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt16, DataTypeDateTime64, ToDateTime64TransformSigned<Int16, date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt32, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt32, DataTypeDateTime64, ToDateTime64TransformSigned<Int32, date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeInt64, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeInt64, DataTypeDateTime64, ToDateTime64TransformSigned<Int64, date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeUInt64, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeUInt64, DataTypeDateTime64, ToDateTime64TransformUnsigned<UInt64, date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat32, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDateTime64, ToDateTime64TransformFloat<DataTypeFloat32, Float32, date_time_overflow_behavior>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeFloat64, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime64, ToDateTime64TransformFloat<DataTypeFloat64, Float64, date_time_overflow_behavior>, false> {};\n \n \n /** Conversion of DateTime64 to Date or DateTime: discards fractional part.\n@@ -720,10 +888,13 @@ struct FromDateTime64Transform\n \n /** Conversion of DateTime64 to Date or DateTime: discards fractional part.\n  */\n-template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDate, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate, TransformDateTime64<ToDateImpl>> {};\n-template <typename Name> struct ConvertImpl<DataTypeDateTime64, DataTypeDateTime, Name, ConvertDefaultBehaviorTag>\n-    : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDateTime, TransformDateTime64<ToDateTimeImpl>> {};\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDateTime64, DataTypeDate, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate, TransformDateTime64<ToDateImpl<date_time_overflow_behavior>>, false> {};\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDateTime64, DataTypeDateTime, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n+    : DateTimeTransformImpl<DataTypeDateTime64, DataTypeDateTime, TransformDateTime64<ToDateTimeImpl<date_time_overflow_behavior>>, false> {};\n \n struct ToDateTime64Transform\n {\n@@ -737,13 +908,13 @@ struct ToDateTime64Transform\n \n     DateTime64::NativeType execute(UInt16 d, const DateLUTImpl & time_zone) const\n     {\n-        const auto dt = ToDateTimeImpl::execute(d, time_zone);\n+        const auto dt = ToDateTimeImpl<>::execute(d, time_zone);\n         return execute(dt, time_zone);\n     }\n \n     DateTime64::NativeType execute(Int32 d, const DateLUTImpl & time_zone) const\n     {\n-        const auto dt = ToDateTimeImpl::execute(d, time_zone);\n+        Int64 dt = static_cast<Int64>(time_zone.fromDayNum(ExtendedDayNum(d)));\n         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(dt, 0, scale_multiplier);\n     }\n \n@@ -755,11 +926,16 @@ struct ToDateTime64Transform\n \n /** Conversion of Date or DateTime to DateTime64: add zero sub-second part.\n   */\n-template <typename Name> struct ConvertImpl<DataTypeDate, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag>\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDate, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n     : DateTimeTransformImpl<DataTypeDate, DataTypeDateTime64, ToDateTime64Transform> {};\n-template <typename Name> struct ConvertImpl<DataTypeDate32, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag>\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDate32, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n     : DateTimeTransformImpl<DataTypeDate32, DataTypeDateTime64, ToDateTime64Transform> {};\n-template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag>\n+\n+template <typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct ConvertImpl<DataTypeDateTime, DataTypeDateTime64, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n     : DateTimeTransformImpl<DataTypeDateTime, DataTypeDateTime64, ToDateTime64Transform> {};\n \n \n@@ -1115,8 +1291,8 @@ inline void convertFromTime<DataTypeDateTime>(DataTypeDateTime::FieldType & x, t\n {\n     if (unlikely(time < 0))\n         x = 0;\n-    else if (unlikely(time > 0xFFFFFFFF))\n-        x = 0xFFFFFFFF;\n+    else if (unlikely(time > MAX_DATETIME_TIMESTAMP))\n+        x = MAX_DATETIME_TIMESTAMP;\n     else\n         x = static_cast<UInt32>(time);\n }\n@@ -1614,29 +1790,29 @@ struct ConvertThroughParsing\n };\n \n \n-template <typename ToDataType, typename Name>\n+template <typename ToDataType, typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n requires (!std::is_same_v<ToDataType, DataTypeString>)\n-struct ConvertImpl<DataTypeString, ToDataType, Name, ConvertDefaultBehaviorTag>\n+struct ConvertImpl<DataTypeString, ToDataType, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n     : ConvertThroughParsing<DataTypeString, ToDataType, Name, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::Normal> {};\n \n-template <typename ToDataType, typename Name>\n+template <typename ToDataType, typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n requires (!std::is_same_v<ToDataType, DataTypeFixedString>)\n-struct ConvertImpl<DataTypeFixedString, ToDataType, Name, ConvertDefaultBehaviorTag>\n+struct ConvertImpl<DataTypeFixedString, ToDataType, Name, ConvertDefaultBehaviorTag, date_time_overflow_behavior>\n     : ConvertThroughParsing<DataTypeFixedString, ToDataType, Name, ConvertFromStringExceptionMode::Throw, ConvertFromStringParsingMode::Normal> {};\n \n-template <typename ToDataType, typename Name>\n+template <typename ToDataType, typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n requires (!std::is_same_v<ToDataType, DataTypeString>)\n-struct ConvertImpl<DataTypeString, ToDataType, Name, ConvertReturnNullOnErrorTag>\n+struct ConvertImpl<DataTypeString, ToDataType, Name, ConvertReturnNullOnErrorTag, date_time_overflow_behavior>\n     : ConvertThroughParsing<DataTypeString, ToDataType, Name, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::Normal> {};\n \n-template <typename ToDataType, typename Name>\n+template <typename ToDataType, typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n requires (!std::is_same_v<ToDataType, DataTypeFixedString>)\n-struct ConvertImpl<DataTypeFixedString, ToDataType, Name, ConvertReturnNullOnErrorTag>\n+struct ConvertImpl<DataTypeFixedString, ToDataType, Name, ConvertReturnNullOnErrorTag, date_time_overflow_behavior>\n     : ConvertThroughParsing<DataTypeFixedString, ToDataType, Name, ConvertFromStringExceptionMode::Null, ConvertFromStringParsingMode::Normal> {};\n \n-template <typename FromDataType, typename ToDataType, typename Name>\n+template <typename FromDataType, typename ToDataType, typename Name, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n requires (is_any_of<FromDataType, DataTypeString, DataTypeFixedString> && is_any_of<ToDataType, DataTypeIPv4, DataTypeIPv6>)\n-struct ConvertImpl<FromDataType, ToDataType, Name, ConvertReturnZeroOnErrorTag>\n+struct ConvertImpl<FromDataType, ToDataType, Name, ConvertReturnZeroOnErrorTag, date_time_overflow_behavior>\n     : ConvertThroughParsing<FromDataType, ToDataType, Name, ConvertFromStringExceptionMode::Zero, ConvertFromStringParsingMode::Normal> {};\n \n /// Generic conversion of any type from String. Used for complex types: Array and Tuple or types with custom serialization.\n@@ -2093,6 +2269,11 @@ class FunctionConvert : public IFunction\n         const DataTypePtr from_type = removeNullable(arguments[0].type);\n         ColumnPtr result_column;\n \n+        [[maybe_unused]] FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n+\n+        if (context)\n+            date_time_overflow_behavior = context->getSettingsRef().date_time_overflow_behavior.value;\n+\n         auto call = [&](const auto & types, const auto & tag) -> bool\n         {\n             using Types = std::decay_t<decltype(types)>;\n@@ -2116,13 +2297,42 @@ class FunctionConvert : public IFunction\n                 const ColumnWithTypeAndName & scale_column = arguments[1];\n                 UInt32 scale = extractToDecimalScale(scale_column);\n \n-                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count, scale);\n+                switch (date_time_overflow_behavior)\n+                {\n+                    case FormatSettings::DateTimeOverflowBehavior::Throw:\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, scale);\n+                        break;\n+                    case FormatSettings::DateTimeOverflowBehavior::Ignore:\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::Ignore>::execute(arguments, result_type, input_rows_count, scale);\n+                        break;\n+                    case FormatSettings::DateTimeOverflowBehavior::Saturate:\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::Saturate>::execute(arguments, result_type, input_rows_count, scale);\n+                        break;\n+                }\n+\n             }\n             else if constexpr (IsDataTypeDateOrDateTime<RightDataType> && std::is_same_v<LeftDataType, DataTypeDateTime64>)\n             {\n                 const auto * dt64 = assert_cast<const DataTypeDateTime64 *>(arguments[0].type.get());\n-                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count, dt64->getScale());\n+                switch (date_time_overflow_behavior)\n+                {\n+                    case FormatSettings::DateTimeOverflowBehavior::Throw:\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::Throw>::execute(arguments, result_type, input_rows_count, dt64->getScale());\n+                        break;\n+                    case FormatSettings::DateTimeOverflowBehavior::Ignore:\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::Ignore>::execute(arguments, result_type, input_rows_count, dt64->getScale());\n+                        break;\n+                    case FormatSettings::DateTimeOverflowBehavior::Saturate:\n+                        result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::Saturate>::execute(arguments, result_type, input_rows_count, dt64->getScale());\n+                        break;\n+                }\n             }\n+#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE) \\\n+            case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n+                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>::execute( \\\n+                arguments, result_type, input_rows_count); \\\n+                break;\n+\n             else if constexpr (IsDataTypeDecimalOrNumber<LeftDataType> && IsDataTypeDecimalOrNumber<RightDataType>)\n             {\n                 using LeftT = typename LeftDataType::FieldType;\n@@ -2141,14 +2351,27 @@ class FunctionConvert : public IFunction\n                 }\n                 else\n                 {\n-                    result_column\n-                        = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count);\n+                    switch (date_time_overflow_behavior)\n+                    {\n+                        GENERATE_OVERFLOW_MODE_CASE(Throw)\n+                        GENERATE_OVERFLOW_MODE_CASE(Ignore)\n+                        GENERATE_OVERFLOW_MODE_CASE(Saturate)\n+                    }\n                 }\n             }\n-            else\n+            else if constexpr ((IsDataTypeNumber<LeftDataType> || IsDataTypeDateOrDateTime<LeftDataType>)\n+                               && IsDataTypeDateOrDateTime<RightDataType>)\n             {\n-                result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count);\n+                switch (date_time_overflow_behavior)\n+                {\n+                    GENERATE_OVERFLOW_MODE_CASE(Throw)\n+                    GENERATE_OVERFLOW_MODE_CASE(Ignore)\n+                    GENERATE_OVERFLOW_MODE_CASE(Saturate)\n+                }\n             }\n+#undef GENERATE_OVERFLOW_MODE_CASE\n+            else\n+                  result_column = ConvertImpl<LeftDataType, RightDataType, Name, SpecialTag>::execute(arguments, result_type, input_rows_count);\n \n             return true;\n         };\n@@ -2559,16 +2782,19 @@ struct ToDateMonotonicity\n     static IFunction::Monotonicity get(const IDataType & type, const Field & left, const Field & right)\n     {\n         auto which = WhichDataType(type);\n-        if (which.isDateOrDate32() || which.isDateTime() || which.isDateTime64() || which.isInt8() || which.isInt16() || which.isUInt8() || which.isUInt16())\n+        if (which.isDateOrDate32() || which.isDateTime() || which.isDateTime64() || which.isInt8() || which.isInt16() || which.isUInt8()\n+            || which.isUInt16())\n         {\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n+            return {.is_monotonic = true, .is_always_monotonic = true};\n         }\n         else if (\n             ((left.getType() == Field::Types::UInt64 || left.isNull()) && (right.getType() == Field::Types::UInt64 || right.isNull())\n-                && ((left.isNull() || left.get<UInt64>() < 0xFFFF) && (right.isNull() || right.get<UInt64>() >= 0xFFFF)))\n+             && ((left.isNull() || left.get<UInt64>() < 0xFFFF) && (right.isNull() || right.get<UInt64>() >= 0xFFFF)))\n             || ((left.getType() == Field::Types::Int64 || left.isNull()) && (right.getType() == Field::Types::Int64 || right.isNull())\n                 && ((left.isNull() || left.get<Int64>() < 0xFFFF) && (right.isNull() || right.get<Int64>() >= 0xFFFF)))\n-            || (((left.getType() == Field::Types::Float64 || left.isNull()) && (right.getType() == Field::Types::Float64 || right.isNull())\n+            || ((\n+                (left.getType() == Field::Types::Float64 || left.isNull())\n+                && (right.getType() == Field::Types::Float64 || right.isNull())\n                 && ((left.isNull() || left.get<Float64>() < 0xFFFF) && (right.isNull() || right.get<Float64>() >= 0xFFFF))))\n             || !isNativeNumber(type))\n         {\n@@ -2576,7 +2802,7 @@ struct ToDateMonotonicity\n         }\n         else\n         {\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n+            return {.is_monotonic = true, .is_always_monotonic = true};\n         }\n     }\n };\n@@ -2588,7 +2814,7 @@ struct ToDateTimeMonotonicity\n     static IFunction::Monotonicity get(const IDataType & type, const Field &, const Field &)\n     {\n         if (type.isValueRepresentedByNumber())\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n+            return {.is_monotonic = true, .is_always_monotonic = true};\n         else\n             return {};\n     }\n@@ -2674,11 +2900,17 @@ using FunctionToInt128 = FunctionConvert<DataTypeInt128, NameToInt128, ToNumberM\n using FunctionToInt256 = FunctionConvert<DataTypeInt256, NameToInt256, ToNumberMonotonicity<Int256>>;\n using FunctionToFloat32 = FunctionConvert<DataTypeFloat32, NameToFloat32, ToNumberMonotonicity<Float32>>;\n using FunctionToFloat64 = FunctionConvert<DataTypeFloat64, NameToFloat64, ToNumberMonotonicity<Float64>>;\n+\n using FunctionToDate = FunctionConvert<DataTypeDate, NameToDate, ToDateMonotonicity>;\n+\n using FunctionToDate32 = FunctionConvert<DataTypeDate32, NameToDate32, ToDateMonotonicity>;\n+\n using FunctionToDateTime = FunctionConvert<DataTypeDateTime, NameToDateTime, ToDateTimeMonotonicity>;\n+\n using FunctionToDateTime32 = FunctionConvert<DataTypeDateTime, NameToDateTime32, ToDateTimeMonotonicity>;\n+\n using FunctionToDateTime64 = FunctionConvert<DataTypeDateTime64, NameToDateTime64, ToDateTimeMonotonicity>;\n+\n using FunctionToUUID = FunctionConvert<DataTypeUUID, NameToUUID, ToNumberMonotonicity<UInt128>>;\n using FunctionToIPv4 = FunctionConvert<DataTypeIPv4, NameToIPv4, ToNumberMonotonicity<UInt32>>;\n using FunctionToIPv6 = FunctionConvert<DataTypeIPv6, NameToIPv6, ToNumberMonotonicity<UInt128>>;\n@@ -2689,8 +2921,7 @@ using FunctionToDecimal64 = FunctionConvert<DataTypeDecimal<Decimal64>, NameToDe\n using FunctionToDecimal128 = FunctionConvert<DataTypeDecimal<Decimal128>, NameToDecimal128, UnknownMonotonicity>;\n using FunctionToDecimal256 = FunctionConvert<DataTypeDecimal<Decimal256>, NameToDecimal256, UnknownMonotonicity>;\n \n-\n-template <typename DataType> struct FunctionTo;\n+template <typename DataType, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior> struct FunctionTo;\n \n template <> struct FunctionTo<DataTypeUInt8> { using Type = FunctionToUInt8; };\n template <> struct FunctionTo<DataTypeUInt16> { using Type = FunctionToUInt16; };\n@@ -2706,10 +2937,19 @@ template <> struct FunctionTo<DataTypeInt128> { using Type = FunctionToInt128; }\n template <> struct FunctionTo<DataTypeInt256> { using Type = FunctionToInt256; };\n template <> struct FunctionTo<DataTypeFloat32> { using Type = FunctionToFloat32; };\n template <> struct FunctionTo<DataTypeFloat64> { using Type = FunctionToFloat64; };\n-template <> struct FunctionTo<DataTypeDate> { using Type = FunctionToDate; };\n-template <> struct FunctionTo<DataTypeDate32> { using Type = FunctionToDate32; };\n-template <> struct FunctionTo<DataTypeDateTime> { using Type = FunctionToDateTime; };\n-template <> struct FunctionTo<DataTypeDateTime64> { using Type = FunctionToDateTime64; };\n+\n+template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct FunctionTo<DataTypeDate, date_time_overflow_behavior> { using Type = FunctionToDate; };\n+\n+template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct FunctionTo<DataTypeDate32, date_time_overflow_behavior> { using Type = FunctionToDate32; };\n+\n+template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct FunctionTo<DataTypeDateTime, date_time_overflow_behavior> { using Type = FunctionToDateTime; };\n+\n+template <FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior>\n+struct FunctionTo<DataTypeDateTime64, date_time_overflow_behavior> { using Type = FunctionToDateTime64; };\n+\n template <> struct FunctionTo<DataTypeUUID> { using Type = FunctionToUUID; };\n template <> struct FunctionTo<DataTypeIPv4> { using Type = FunctionToIPv4; };\n template <> struct FunctionTo<DataTypeIPv6> { using Type = FunctionToIPv6; };\n@@ -3044,6 +3284,10 @@ class FunctionCast final : public FunctionCastBase\n         bool can_apply_accurate_cast = (cast_type == CastType::accurate || cast_type == CastType::accurateOrNull)\n             && (which.isInt() || which.isUInt() || which.isFloat());\n \n+        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = default_date_time_overflow_behavior;\n+        if (context)\n+            date_time_overflow_behavior = context->getSettingsRef().date_time_overflow_behavior;\n+\n         if (requested_result_is_nullable && checkAndGetDataType<DataTypeString>(from_type.get()))\n         {\n             /// In case when converting to Nullable type, we apply different parsing rule,\n@@ -3060,7 +3304,7 @@ class FunctionCast final : public FunctionCastBase\n \n         auto wrapper_cast_type = cast_type;\n \n-        return [wrapper_cast_type, from_type_index, to_type]\n+        return [wrapper_cast_type, from_type_index, to_type, date_time_overflow_behavior]\n             (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *column_nullable, size_t input_rows_count)\n         {\n             ColumnPtr result_column;\n@@ -3073,31 +3317,60 @@ class FunctionCast final : public FunctionCastBase\n                 {\n                     if constexpr (IsDataTypeNumber<RightDataType>)\n                     {\n+#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE, ADDITIONS) \\\n+            case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n+                result_column = ConvertImpl<LeftDataType, RightDataType, FunctionName, ConvertDefaultBehaviorTag, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>::execute( \\\n+                arguments, result_type, input_rows_count, ADDITIONS()); \\\n+                break;\n                         if (wrapper_cast_type == CastType::accurate)\n                         {\n-                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionName>::execute(\n-                                arguments, result_type, input_rows_count, AccurateConvertStrategyAdditions());\n+                            switch (date_time_overflow_behavior)\n+                            {\n+                                GENERATE_OVERFLOW_MODE_CASE(Throw, AccurateConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Ignore, AccurateConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Saturate, AccurateConvertStrategyAdditions)\n+                            }\n                         }\n                         else\n                         {\n-                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionName>::execute(\n-                                arguments, result_type, input_rows_count, AccurateOrNullConvertStrategyAdditions());\n+                            switch (date_time_overflow_behavior)\n+                            {\n+                                GENERATE_OVERFLOW_MODE_CASE(Throw, AccurateOrNullConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Ignore, AccurateOrNullConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Saturate, AccurateOrNullConvertStrategyAdditions)\n+                            }\n                         }\n+#undef GENERATE_OVERFLOW_MODE_CASE\n+\n                         return true;\n                     }\n \n                     if constexpr (std::is_same_v<RightDataType, DataTypeDate> || std::is_same_v<RightDataType, DataTypeDateTime>)\n                     {\n+#define GENERATE_OVERFLOW_MODE_CASE(OVERFLOW_MODE, ADDITIONS) \\\n+            case FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE: \\\n+            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionName, ConvertDefaultBehaviorTag, FormatSettings::DateTimeOverflowBehavior::OVERFLOW_MODE>::template execute<ADDITIONS>( \\\n+arguments, result_type, input_rows_count); \\\n+                break;\n                         if (wrapper_cast_type == CastType::accurate)\n                         {\n-                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionName>::template execute<DateTimeAccurateConvertStrategyAdditions>(\n-                                arguments, result_type, input_rows_count);\n+                            switch (date_time_overflow_behavior)\n+                            {\n+                                GENERATE_OVERFLOW_MODE_CASE(Throw, DateTimeAccurateConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Ignore, DateTimeAccurateConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Saturate, DateTimeAccurateConvertStrategyAdditions)\n+                            }\n                         }\n                         else\n                         {\n-                            result_column = ConvertImpl<LeftDataType, RightDataType, FunctionName>::template execute<DateTimeAccurateOrNullConvertStrategyAdditions>(\n-                                arguments, result_type, input_rows_count);\n+                            switch (date_time_overflow_behavior)\n+                            {\n+                                GENERATE_OVERFLOW_MODE_CASE(Throw, DateTimeAccurateOrNullConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Ignore, DateTimeAccurateOrNullConvertStrategyAdditions)\n+                                GENERATE_OVERFLOW_MODE_CASE(Saturate, DateTimeAccurateOrNullConvertStrategyAdditions)\n+                            }\n                         }\n+#undef GENERATE_OVERFLOW_MODE_CASE\n                         return true;\n                     }\n                 }\ndiff --git a/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp b/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\nindex f92406488d81..1e81274f5bef 100644\n--- a/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\n@@ -157,6 +157,7 @@ void ArrowBlockInputFormat::prepareReader()\n         \"Arrow\",\n         format_settings.arrow.allow_missing_columns,\n         format_settings.null_as_default,\n+        format_settings.date_time_overflow_behavior,\n         format_settings.arrow.case_insensitive_column_matching);\n \n     if (stream)\ndiff --git a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\nindex 2a9892b72194..6f9d49498f2c 100644\n--- a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\n+++ b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\n@@ -247,11 +247,13 @@ static ColumnWithTypeAndName readColumnWithBooleanData(std::shared_ptr<arrow::Ch\n     return {std::move(internal_column), internal_type, column_name};\n }\n \n-static ColumnWithTypeAndName readColumnWithDate32Data(std::shared_ptr<arrow::ChunkedArray> & arrow_column, const String & column_name, const DataTypePtr & type_hint)\n+static ColumnWithTypeAndName readColumnWithDate32Data(std::shared_ptr<arrow::ChunkedArray> & arrow_column, const String & column_name,\n+                                                      const DataTypePtr & type_hint, FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior)\n {\n     DataTypePtr internal_type;\n     bool check_date_range = false;\n     /// Make result type Date32 when requested type is actually Date32 or when we use schema inference\n+\n     if (!type_hint || (type_hint && isDate32(*type_hint)))\n     {\n         internal_type = std::make_shared<DataTypeDate32>();\n@@ -277,8 +279,21 @@ static ColumnWithTypeAndName readColumnWithDate32Data(std::shared_ptr<arrow::Chu\n             {\n                 Int32 days_num = static_cast<Int32>(chunk.Value(value_i));\n                 if (days_num > DATE_LUT_MAX_EXTEND_DAY_NUM || days_num < -DAYNUM_OFFSET_EPOCH)\n-                    throw Exception{ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE,\n-                            \"Input value {} of a column \\\"{}\\\" is out of allowed Date32 range, which is [{}, {}]\", days_num, column_name, DAYNUM_OFFSET_EPOCH, DATE_LUT_MAX_EXTEND_DAY_NUM};\n+                {\n+                    switch (date_time_overflow_behavior)\n+                    {\n+                        case FormatSettings::DateTimeOverflowBehavior::Saturate:\n+                            days_num = (days_num < -DAYNUM_OFFSET_EPOCH) ? -DAYNUM_OFFSET_EPOCH : DATE_LUT_MAX_EXTEND_DAY_NUM;\n+                            break;\n+                        default:\n+                        /// Prior to introducing `date_time_overflow_behavior`, this function threw an error in case value was out of range.\n+                        /// In order to leave this behavior as default, we also throw when `date_time_overflow_mode == ignore`, as it is the setting's default value\n+                        /// (As we want to make this backwards compatible, not break any workflows.)\n+                            throw Exception{ErrorCodes::VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE,\n+                                            \"Input value {} of a column \\\"{}\\\" is out of allowed Date32 range, which is [{}, {}]\",\n+                                            days_num,column_name, -DAYNUM_OFFSET_EPOCH, DATE_LUT_MAX_EXTEND_DAY_NUM};\n+                    }\n+                }\n \n                 column_data.emplace_back(days_num);\n             }\n@@ -681,6 +696,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n     bool allow_null_type,\n     bool skip_columns_with_unsupported_types,\n     bool & skipped,\n+    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior = FormatSettings::DateTimeOverflowBehavior::Ignore,\n     DataTypePtr type_hint = nullptr,\n     bool is_map_nested = false)\n {\n@@ -691,7 +707,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n         DataTypePtr nested_type_hint;\n         if (type_hint)\n             nested_type_hint = removeNullable(type_hint);\n-        auto nested_column = readColumnFromArrowColumn(arrow_column, column_name, format_name, true, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, nested_type_hint);\n+        auto nested_column = readColumnFromArrowColumn(arrow_column, column_name, format_name, true, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, date_time_overflow_behavior, nested_type_hint);\n         if (skipped)\n             return {};\n         auto nullmap_column = readByteMapFromArrowColumn(arrow_column);\n@@ -756,7 +772,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n         case arrow::Type::BOOL:\n             return readColumnWithBooleanData(arrow_column, column_name);\n         case arrow::Type::DATE32:\n-            return readColumnWithDate32Data(arrow_column, column_name, type_hint);\n+            return readColumnWithDate32Data(arrow_column, column_name, type_hint, date_time_overflow_behavior);\n         case arrow::Type::DATE64:\n             return readColumnWithDate64Data(arrow_column, column_name);\n         // ClickHouse writes Date as arrow UINT16 and DateTime as arrow UINT32,\n@@ -804,7 +820,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n                 }\n             }\n             auto arrow_nested_column = getNestedArrowColumn(arrow_column);\n-            auto nested_column = readColumnFromArrowColumn(arrow_nested_column, column_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, nested_type_hint, true);\n+            auto nested_column = readColumnFromArrowColumn(arrow_nested_column, column_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, date_time_overflow_behavior, nested_type_hint, true);\n             if (skipped)\n                 return {};\n \n@@ -839,7 +855,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n                     nested_type_hint = array_type_hint->getNestedType();\n             }\n             auto arrow_nested_column = getNestedArrowColumn(arrow_column);\n-            auto nested_column = readColumnFromArrowColumn(arrow_nested_column, column_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, nested_type_hint);\n+            auto nested_column = readColumnFromArrowColumn(arrow_nested_column, column_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, date_time_overflow_behavior, nested_type_hint);\n             if (skipped)\n                 return {};\n             auto offsets_column = readOffsetsFromArrowListColumn(arrow_column);\n@@ -880,7 +896,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n                         nested_type_hint = tuple_type_hint->getElement(i);\n                 }\n                 auto nested_arrow_column = std::make_shared<arrow::ChunkedArray>(nested_arrow_columns[i]);\n-                auto element = readColumnFromArrowColumn(nested_arrow_column, field_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, nested_type_hint);\n+                auto element = readColumnFromArrowColumn(nested_arrow_column, field_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, date_time_overflow_behavior, nested_type_hint);\n                 if (skipped)\n                     return {};\n                 tuple_elements.emplace_back(std::move(element.column));\n@@ -907,7 +923,7 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n                     dict_array.emplace_back(dict_chunk.dictionary());\n                 }\n                 auto arrow_dict_column = std::make_shared<arrow::ChunkedArray>(dict_array);\n-                auto dict_column = readColumnFromArrowColumn(arrow_dict_column, column_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped);\n+                auto dict_column = readColumnFromArrowColumn(arrow_dict_column, column_name, format_name, false, dictionary_infos, allow_null_type, skip_columns_with_unsupported_types, skipped, date_time_overflow_behavior);\n                 for (size_t i = 0; i != dict_column.column->size(); ++i)\n                 {\n                     if (dict_column.column->isDefaultAt(i))\n@@ -997,7 +1013,8 @@ static void checkStatus(const arrow::Status & status, const String & column_name\n \n \n Block ArrowColumnToCHColumn::arrowSchemaToCHHeader(\n-    const arrow::Schema & schema, const std::string & format_name, bool skip_columns_with_unsupported_types, const Block * hint_header, bool ignore_case)\n+    const arrow::Schema & schema, const std::string & format_name,\n+    bool skip_columns_with_unsupported_types, const Block * hint_header, bool ignore_case)\n {\n     ColumnsWithTypeAndName sample_columns;\n     std::unordered_set<String> nested_table_names;\n@@ -1040,12 +1057,14 @@ ArrowColumnToCHColumn::ArrowColumnToCHColumn(\n     const std::string & format_name_,\n     bool allow_missing_columns_,\n     bool null_as_default_,\n+    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior_,\n     bool case_insensitive_matching_)\n     : header(header_)\n     , format_name(format_name_)\n     , allow_missing_columns(allow_missing_columns_)\n     , null_as_default(null_as_default_)\n     , case_insensitive_matching(case_insensitive_matching_)\n+    , date_time_overflow_behavior(date_time_overflow_behavior_)\n {\n }\n \n@@ -1102,8 +1121,9 @@ void ArrowColumnToCHColumn::arrowColumnsToCHChunk(Chunk & res, NameToColumnPtr &\n                     auto nested_table_type = Nested::collect(nested_columns).front().type;\n \n                     std::shared_ptr<arrow::ChunkedArray> arrow_column = name_to_column_ptr[search_nested_table_name];\n-                    ColumnsWithTypeAndName cols = {readColumnFromArrowColumn(\n-                        arrow_column, nested_table_name, format_name, false, dictionary_infos, true, false, skipped, nested_table_type)};\n+                    ColumnsWithTypeAndName cols = {\n+                        readColumnFromArrowColumn(arrow_column, nested_table_name, format_name, false, dictionary_infos, true, false,\n+                                                  skipped, date_time_overflow_behavior, nested_table_type)};\n                     BlockPtr block_ptr = std::make_shared<Block>(cols);\n                     auto column_extractor = std::make_shared<NestedColumnExtractHelper>(*block_ptr, case_insensitive_matching);\n                     nested_tables[search_nested_table_name] = {block_ptr, column_extractor};\n@@ -1138,7 +1158,7 @@ void ArrowColumnToCHColumn::arrowColumnsToCHChunk(Chunk & res, NameToColumnPtr &\n         {\n             auto arrow_column = name_to_column_ptr[search_column_name];\n             column = readColumnFromArrowColumn(\n-                arrow_column, header_column.name, format_name, false, dictionary_infos, true, false, skipped, header_column.type);\n+                arrow_column, header_column.name, format_name, false, dictionary_infos, true, false, skipped, date_time_overflow_behavior, header_column.type);\n         }\n \n         if (null_as_default)\ndiff --git a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.h b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.h\nindex 57f33069e0ef..ff80797dc273 100644\n--- a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.h\n+++ b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.h\n@@ -8,7 +8,7 @@\n #include <Core/ColumnWithTypeAndName.h>\n #include <Core/Block.h>\n #include <arrow/table.h>\n-\n+#include <Formats/FormatSettings.h>\n \n namespace DB\n {\n@@ -26,6 +26,7 @@ class ArrowColumnToCHColumn\n         const std::string & format_name_,\n         bool allow_missing_columns_,\n         bool null_as_default_,\n+        FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior_,\n         bool case_insensitive_matching_ = false);\n \n     void arrowTableToCHChunk(Chunk & res, std::shared_ptr<arrow::Table> & table, size_t num_rows, BlockMissingValues * block_missing_values = nullptr);\n@@ -56,6 +57,7 @@ class ArrowColumnToCHColumn\n     bool allow_missing_columns;\n     bool null_as_default;\n     bool case_insensitive_matching;\n+    FormatSettings::DateTimeOverflowBehavior date_time_overflow_behavior;\n \n     /// Map {column name : dictionary column}.\n     /// To avoid converting dictionary from Arrow Dictionary\ndiff --git a/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp b/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\nindex c0ac0e2c232e..5cde51a4927c 100644\n--- a/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\n@@ -131,6 +131,7 @@ void ORCBlockInputFormat::prepareReader()\n         \"ORC\",\n         format_settings.orc.allow_missing_columns,\n         format_settings.null_as_default,\n+        format_settings.date_time_overflow_behavior,\n         format_settings.orc.case_insensitive_column_matching);\n \n     const bool ignore_case = format_settings.orc.case_insensitive_column_matching;\ndiff --git a/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp b/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\nindex 3cfeb80afd52..c9ac2438fc0d 100644\n--- a/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\n@@ -493,6 +493,7 @@ void ParquetBlockInputFormat::initializeRowGroupBatchReader(size_t row_group_bat\n         \"Parquet\",\n         format_settings.parquet.allow_missing_columns,\n         format_settings.null_as_default,\n+        format_settings.date_time_overflow_behavior,\n         format_settings.parquet.case_insensitive_column_matching);\n }\n \ndiff --git a/src/Storages/DataLakes/DeltaLakeMetadataParser.cpp b/src/Storages/DataLakes/DeltaLakeMetadataParser.cpp\nindex 1172a40627de..eae170785774 100644\n--- a/src/Storages/DataLakes/DeltaLakeMetadataParser.cpp\n+++ b/src/Storages/DataLakes/DeltaLakeMetadataParser.cpp\n@@ -283,6 +283,7 @@ struct DeltaLakeMetadataParser<Configuration, MetadataReadHelper>::Impl\n             header, \"Parquet\",\n             format_settings.parquet.allow_missing_columns,\n             /* null_as_default */true,\n+            format_settings.date_time_overflow_behavior,\n             /* case_insensitive_column_matching */false);\n \n         Chunk res;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02900_date_time_check_overflow.reference b/tests/queries/0_stateless/02900_date_time_check_overflow.reference\nnew file mode 100644\nindex 000000000000..26bbfc8752f6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02900_date_time_check_overflow.reference\n@@ -0,0 +1,23 @@\n+ignore\n+2036-02-07 06:28:16\n+2027-10-18 11:03:27\n+2036-02-07 06:28:16\n+2027-10-17 11:03:28\n+2013-04-29 17:31:44\n+2079-06-07\n+1970-01-01\n+2120-07-26\n+2079-06-07\n+2120-07-26\n+No output on `throw`\n+saturate\n+1970-01-01 00:00:00\n+2106-02-07 06:28:15\n+1970-01-01 00:00:00\n+2106-02-07 00:00:00\n+2106-02-07 00:00:00\n+1970-01-01\n+2149-06-06\n+2149-06-06\n+1970-01-01\n+2149-06-06\ndiff --git a/tests/queries/0_stateless/02900_date_time_check_overflow.sql b/tests/queries/0_stateless/02900_date_time_check_overflow.sql\nnew file mode 100644\nindex 000000000000..ba6125cb4b41\n--- /dev/null\n+++ b/tests/queries/0_stateless/02900_date_time_check_overflow.sql\n@@ -0,0 +1,50 @@\n+SET session_timezone = 'UTC';\n+\n+SELECT 'ignore';\n+SET date_time_overflow_behavior = 'ignore';\n+SELECT toDateTime(toDateTime64('1900-01-01 00:00:00.123', 3));\n+SELECT toDateTime(toDateTime64('2299-12-31 23:59:59.999', 3));\n+\n+SELECT toDateTime(toDate32('1900-01-01'));\n+SELECT toDateTime(toDate32('2299-12-31'));\n+\n+SELECT toDateTime(toDate('2149-06-06'));\n+\n+SELECT toDate(toDateTime64('1900-01-01 00:00:00.123', 3));\n+SELECT toDate(toDateTime64('2149-06-07 00:00:00.123', 3));\n+SELECT toDate(toDateTime64('2299-12-31 23:59:59.999', 3));\n+\n+SELECT toDate(toDate32('1900-01-01'));\n+SELECT toDate(toDate32('2299-12-31'));\n+\n+\n+SELECT 'No output on `throw`';\n+SET date_time_overflow_behavior = 'throw';\n+SELECT toDateTime(toDateTime64('1900-01-01 00:00:00.123', 3)); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDateTime(toDateTime64('2299-12-31 23:59:59.999', 3)); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDateTime(toDate32('1900-01-01')); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDateTime(toDate32('2299-12-31')); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDateTime(toDate('2149-06-06')); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDate(toDateTime64('1900-01-01 00:00:00.123', 3)); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDate(toDateTime64('2299-12-31 23:59:59.999', 3)); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDate(toDate32('1900-01-01')); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+SELECT toDate(toDate32('2299-12-31')); -- { serverError VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE }\n+\n+\n+SELECT 'saturate';\n+SET date_time_overflow_behavior = 'saturate';\n+\n+SELECT toDateTime(toDateTime64('1900-01-01 00:00:00.123', 3));\n+SELECT toDateTime(toDateTime64('2299-12-31 23:59:59.999', 3));\n+\n+SELECT toDateTime(toDate32('1900-01-01'));\n+SELECT toDateTime(toDate32('2299-12-31'));\n+\n+SELECT toDateTime(toDate('2149-06-06'));\n+\n+SELECT toDate(toDateTime64('1900-01-01 00:00:00.123', 3));\n+SELECT toDate(toDateTime64('2149-06-07 00:00:00.123', 3));\n+SELECT toDate(toDateTime64('2299-12-31 23:59:59.999', 3));\n+\n+SELECT toDate(toDate32('1900-01-01'));\n+SELECT toDate(toDate32('2299-12-31'));\n",
  "problem_statement": "Input value ... of a column ...  is out of allowed Date32 range, which is [25567, 120530]: While executing ParquetBlockInputFormat\n\r\n```\r\nimport numpy as np\r\nimport pandas as pd\r\nimport pyarrow as pa\r\nfrom datetime import date\r\ndf = pd.DataFrame({'a': [1, 2, 3],'b': [date.fromisoformat('1900-10-01'),date.fromisoformat('2019-12-04'),date.fromisoformat('9999-12-31') ]})\r\ntable = pa.Table.from_pandas(df)\r\nimport pyarrow.parquet as pq\r\npq.write_table(table, 'date.parquet')\r\n```\r\n\r\n\r\n```\r\nlickhouse-local --stacktrace\r\nClickHouse local version 23.5.1.988 (official build).\r\n\r\nlaptop-5591 :) select * from file('date.parquet','Parquet','a int, b Date32')\r\n\r\nSELECT *\r\nFROM file('date.parquet', 'Parquet', 'a int, b Date32')\r\n\r\nQuery id: 121daf93-4a9e-4d9e-a3ca-8888021fcacf\r\n\r\n\r\n0 rows in set. Elapsed: 0.181 sec. \r\n\r\nReceived exception:\r\nCode: 321. DB::Exception: Input value 2932896 of a column \"b\" is out of allowed Date32 range, which is [25567, 120530]: While executing ParquetBlockInputFormat: While executing File. (VALUE_IS_OUT_OF_RANGE_OF_DATA_TYPE), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. ./build_docker/./src/Common/Exception.cpp:92: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000e144795 in /usr/bin/clickhouse\r\n1. ./build_docker/./contrib/llvm-project/libcxx/include/string:1499: DB::Exception::Exception<int&, String const&, int, int>(int, FormatStringHelperImpl<std::type_identity<int&>::type, std::type_identity<String const&>::type, std::type_identity<int>::type, std::type_identity<int>::type>, int&, String const&, int&&, int&&) @ 0x0000000014b4b927 in /usr/bin/clickhouse\r\n2. ./build_docker/./src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp:283: DB::readColumnFromArrowColumn(std::shared_ptr<arrow::ChunkedArray>&, String const&, String const&, bool, std::unordered_map<String, DB::ArrowColumnToCHColumn::DictionaryInfo, std::hash<String>, std::equal_to<String>, std::allocator<std::pair<String const, DB::ArrowColumnToCHColumn::DictionaryInfo>>>&, bool, bool, bool&, std::shared_ptr<DB::IDataType const>, bool) @ 0x0000000014b41b5b in /usr/bin/clickhouse\r\n3. ./build_docker/./contrib/boost/boost/smart_ptr/intrusive_ptr.hpp:115: DB::ArrowColumnToCHColumn::arrowColumnsToCHChunk(DB::Chunk&, std::unordered_map<String, std::shared_ptr<arrow::ChunkedArray>, std::hash<String>, std::equal_to<String>, std::allocator<std::pair<String const, std::shared_ptr<arrow::ChunkedArray>>>>&, unsigned long, DB::BlockMissingValues*) @ 0x0000000014b447e0 in /usr/bin/clickhouse\r\n4. ./build_docker/./contrib/llvm-project/libcxx/include/__hash_table:1473: DB::ArrowColumnToCHColumn::arrowTableToCHChunk(DB::Chunk&, std::shared_ptr<arrow::Table>&, unsigned long, DB::BlockMissingValues*) @ 0x0000000014b440ae in /usr/bin/clickhouse\r\n5. ./build_docker/./contrib/llvm-project/libcxx/include/__mutex_base:203: DB::ParquetBlockInputFormat::decodeOneChunk(unsigned long, std::unique_lock<std::mutex>&) @ 0x0000000014c37572 in /usr/bin/clickhouse\r\n6. ./build_docker/./src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp:212: void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<DB::ParquetBlockInputFormat::scheduleRowGroup(unsigned long)::$_0, void ()>>(std::__function::__policy_storage const*) @ 0x0000000014c3ac65 in /usr/bin/clickhouse\r\n7. ./build_docker/./base/base/../base/wide_integer_impl.h:796: ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0x000000000e21cd07 in /usr/bin/clickhouse\r\n8. ./build_docker/./src/Common/ThreadPool.cpp:0: void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, long, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000e21f535 in /usr/bin/clickhouse\r\n9. ./build_docker/./base/base/../base/wide_integer_impl.h:796: ThreadPoolImpl<std::thread>::worker(std::__list_iterator<std::thread, void*>) @ 0x000000000e218b34 in /usr/bin/clickhouse\r\n10. ./build_docker/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:302: void* std::__thread_proxy[abi:v15000]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, long, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000e21e3a1 in /usr/bin/clickhouse\r\n11. ? @ 0x00007f327f694b43 in ?\r\n12. ? @ 0x00007f327f726a00 in ?\r\n```\r\n\r\nSimilar  https://github.com/ClickHouse/ClickHouse/issues/39249 \r\n\r\nMaybe we should introduce the setting? (throw / silent overflow / use maximum or minimum from the supported range)\n",
  "hints_text": "Same problem here.",
  "created_at": "2023-10-16T21:42:03Z",
  "modified_files": [
    "docs/en/operations/settings/settings.md",
    "docs/ru/operations/settings/settings.md",
    "src/Core/Settings.h",
    "src/Core/SettingsEnums.cpp",
    "src/Core/SettingsEnums.h",
    "src/Formats/FormatFactory.cpp",
    "src/Formats/FormatSettings.h",
    "src/Functions/DateTimeTransforms.cpp",
    "src/Functions/DateTimeTransforms.h",
    "src/Functions/FunctionsConversion.h",
    "src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp",
    "src/Processors/Formats/Impl/ArrowColumnToCHColumn.h",
    "src/Processors/Formats/Impl/ORCBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp",
    "src/Storages/DataLakes/DeltaLakeMetadataParser.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02900_date_time_check_overflow.reference",
    "b/tests/queries/0_stateless/02900_date_time_check_overflow.sql"
  ]
}