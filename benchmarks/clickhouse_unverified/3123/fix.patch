diff --git a/dbms/src/DataTypes/IDataType.h b/dbms/src/DataTypes/IDataType.h
index b08b1811151d..95b6b029dc52 100644
--- a/dbms/src/DataTypes/IDataType.h
+++ b/dbms/src/DataTypes/IDataType.h
@@ -474,6 +474,7 @@ struct WhichDataType
 
 /// IDataType helpers (alternative for IDataType virtual methods with single point of truth)
 
+inline bool isDate(const DataTypePtr & data_type) { return WhichDataType(data_type).isDate(); }
 inline bool isDateOrDateTime(const DataTypePtr & data_type) { return WhichDataType(data_type).isDateOrDateTime(); }
 inline bool isEnum(const DataTypePtr & data_type) { return WhichDataType(data_type).isEnum(); }
 inline bool isDecimal(const DataTypePtr & data_type) { return WhichDataType(data_type).isDecimal(); }
diff --git a/dbms/src/Dictionaries/DictionarySourceFactory.cpp b/dbms/src/Dictionaries/DictionarySourceFactory.cpp
index 88065113b2a9..82d8cb8f5968 100644
--- a/dbms/src/Dictionaries/DictionarySourceFactory.cpp
+++ b/dbms/src/Dictionaries/DictionarySourceFactory.cpp
@@ -9,6 +9,7 @@
 #include <Dictionaries/LibraryDictionarySource.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeNullable.h>
 #include <Common/FieldVisitors.h>
 #include <Columns/ColumnsNumber.h>
 #include <IO/HTTPCommon.h>
@@ -64,9 +65,16 @@ Block createSampleBlock(const DictionaryStructure & dict_struct)
     }
 
     if (dict_struct.range_min)
+    {
         for (const auto & attribute : { dict_struct.range_min, dict_struct.range_max })
-            block.insert(ColumnWithTypeAndName{
-                ColumnUInt16::create(1, 0), std::make_shared<DataTypeDate>(), attribute->name});
+        {
+            const auto & type = std::make_shared<DataTypeNullable>(attribute->type);
+            auto column = type->createColumn();
+            column->insertDefault();
+
+            block.insert(ColumnWithTypeAndName{std::move(column), type, attribute->name});
+        }
+    }
 
     for (const auto & attribute : dict_struct.attributes)
     {
diff --git a/dbms/src/Dictionaries/DictionaryStructure.cpp b/dbms/src/Dictionaries/DictionaryStructure.cpp
index 1f0d15422659..0aeed4914550 100644
--- a/dbms/src/Dictionaries/DictionaryStructure.cpp
+++ b/dbms/src/Dictionaries/DictionaryStructure.cpp
@@ -1,6 +1,7 @@
 #include <Dictionaries/DictionaryStructure.h>
 #include <Formats/FormatSettings.h>
 #include <DataTypes/DataTypeFactory.h>
+#include <DataTypes/DataTypeNullable.h>
 #include <Columns/IColumn.h>
 #include <Common/StringUtils/StringUtils.h>
 #include <IO/WriteHelpers.h>
@@ -22,6 +23,25 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
 }
 
+namespace
+{
+DictionaryTypedSpecialAttribute makeDictionaryTypedSpecialAttribute(
+        const Poco::Util::AbstractConfiguration & config,
+        const std::string & config_prefix,
+        const std::string& default_type)
+{
+    const auto name = config.getString(config_prefix + ".name", "");
+    const auto expression = config.getString(config_prefix + ".expression", "");
+
+    if (name.empty() && !expression.empty())
+        throw Exception{"Element " + config_prefix + ".name is empty", ErrorCodes::BAD_ARGUMENTS};
+
+    const auto type_name = config.getString(config_prefix + ".type", default_type);
+    return DictionaryTypedSpecialAttribute{std::move(name), std::move(expression), DataTypeFactory::instance().get(type_name)};
+}
+
+} // namespace
+
 
 bool isAttributeTypeConvertibleTo(AttributeUnderlyingType from, AttributeUnderlyingType to)
 {
@@ -143,11 +163,33 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration
         if (id->name.empty())
             throw Exception{"'id' cannot be empty", ErrorCodes::BAD_ARGUMENTS};
 
+        const auto range_default_type = "Date";
         if (config.has(config_prefix + ".range_min"))
-            range_min.emplace(config, config_prefix + ".range_min");
+            range_min.emplace(std::move(makeDictionaryTypedSpecialAttribute(config, config_prefix + ".range_min", range_default_type)));
 
         if (config.has(config_prefix + ".range_max"))
-            range_max.emplace(config, config_prefix + ".range_max");
+            range_max.emplace(std::move(makeDictionaryTypedSpecialAttribute(config, config_prefix + ".range_max", range_default_type)));
+
+        if (range_min.has_value() != range_max.has_value())
+        {
+            throw Exception{"Dictionary structure should have both 'range_min' and 'range_max' either specified or not.", ErrorCodes::BAD_ARGUMENTS};
+        }
+
+        if (range_min && range_max && !range_min->type->equals(*range_max->type))
+        {
+            throw Exception{"Dictionary structure 'range_min' and 'range_max' should have same type, "
+                "'range_min' type: " + range_min->type->getName() + ", "
+                "'range_max' type: " + range_max->type->getName(),
+                ErrorCodes::BAD_ARGUMENTS};
+        }
+
+        if (range_min)
+        {
+            if (!range_min->type->isValueRepresentedByInteger())
+                throw Exception{"Dictionary structure type of 'range_min' and 'range_max' should be an integer, Date, DateTime, or Enum."
+                    " Actual 'range_min' and 'range_max' type is " + range_min->type->getName(),
+                    ErrorCodes::BAD_ARGUMENTS};
+        }
 
         if (!id->expression.empty() ||
             (range_min && !range_min->expression.empty()) ||
diff --git a/dbms/src/Dictionaries/DictionaryStructure.h b/dbms/src/Dictionaries/DictionaryStructure.h
index a42883582d96..a34964b8b2fa 100644
--- a/dbms/src/Dictionaries/DictionaryStructure.h
+++ b/dbms/src/Dictionaries/DictionaryStructure.h
@@ -74,6 +74,13 @@ struct DictionarySpecialAttribute final
     DictionarySpecialAttribute(const Poco::Util::AbstractConfiguration & config, const std::string & config_prefix);
 };
 
+struct DictionaryTypedSpecialAttribute final
+{
+    const std::string name;
+    const std::string expression;
+    const DataTypePtr type;
+};
+
 
 /// Name of identifier plus list of attributes
 struct DictionaryStructure final
@@ -81,8 +88,8 @@ struct DictionaryStructure final
     std::optional<DictionarySpecialAttribute> id;
     std::optional<std::vector<DictionaryAttribute>> key;
     std::vector<DictionaryAttribute> attributes;
-    std::optional<DictionarySpecialAttribute> range_min;
-    std::optional<DictionarySpecialAttribute> range_max;
+    std::optional<DictionaryTypedSpecialAttribute> range_min;
+    std::optional<DictionaryTypedSpecialAttribute> range_max;
     bool has_expressions = false;
 
     DictionaryStructure(const Poco::Util::AbstractConfiguration & config, const std::string & config_prefix);
diff --git a/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h b/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h
index e954f68a9fdc..beef86cc9a5f 100644
--- a/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h
+++ b/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h
@@ -25,8 +25,8 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase
     using DictionaryPtr = std::shared_ptr<DictionaryType const>;
 
     RangeDictionaryBlockInputStream(
-        DictionaryPtr dictionary, size_t max_block_size, const Names & column_names, PaddedPODArray<Key> && ids,
-        PaddedPODArray<UInt16> && start_dates, PaddedPODArray<UInt16> && end_dates);
+        DictionaryPtr dictionary, size_t max_block_size, const Names & column_names, PaddedPODArray<Key> && ids_to_fill,
+        PaddedPODArray<Int64> && start_dates, PaddedPODArray<Int64> && end_dates);
 
     String getName() const override
     {
@@ -39,44 +39,44 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase
 private:
     template <typename Type>
     using DictionaryGetter = void (DictionaryType::*)(const std::string &, const PaddedPODArray<Key> &,
-                             const PaddedPODArray<UInt16> &, PaddedPODArray<Type> &) const;
+                             const PaddedPODArray<Int64> &, PaddedPODArray<Type> &) const;
 
     template <typename AttributeType>
     ColumnPtr getColumnFromAttribute(DictionaryGetter<AttributeType> getter,
-                                     const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<UInt16> & dates,
+                                     const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<Int64> & dates,
                                      const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const;
-    ColumnPtr getColumnFromAttributeString(const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<UInt16> & dates,
+    ColumnPtr getColumnFromAttributeString(const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<Int64> & dates,
                                            const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const;
     template <typename T>
     ColumnPtr getColumnFromPODArray(const PaddedPODArray<T> & array) const;
 
-    template <typename T>
+    template <typename DictionarySpecialAttributeType, typename T>
     void addSpecialColumn(
-        const std::optional<DictionarySpecialAttribute> & attribute, DataTypePtr type,
+        const std::optional<DictionarySpecialAttributeType> & attribute, DataTypePtr type,
         const std::string & default_name, const std::unordered_set<std::string> & column_names_set,
         const PaddedPODArray<T> & values, ColumnsWithTypeAndName & columns) const;
 
     Block fillBlock(const PaddedPODArray<Key> & ids_to_fill,
-                    const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const;
+                    const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const;
 
-    PaddedPODArray<UInt16> makeDateKey(
-        const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const;
+    PaddedPODArray<Int64> makeDateKey(
+        const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const;
 
     DictionaryPtr dictionary;
     Names column_names;
     PaddedPODArray<Key> ids;
-    PaddedPODArray<UInt16> start_dates;
-    PaddedPODArray<UInt16> end_dates;
+    PaddedPODArray<Int64> start_dates;
+    PaddedPODArray<Int64> end_dates;
 };
 
 
 template <typename DictionaryType, typename Key>
 RangeDictionaryBlockInputStream<DictionaryType, Key>::RangeDictionaryBlockInputStream(
     DictionaryPtr dictionary, size_t max_column_size, const Names & column_names, PaddedPODArray<Key> && ids,
-    PaddedPODArray<UInt16> && start_dates, PaddedPODArray<UInt16> && end_dates)
+    PaddedPODArray<Int64> && block_start_dates, PaddedPODArray<Int64> && block_end_dates)
     : DictionaryBlockInputStreamBase(ids.size(), max_column_size),
       dictionary(dictionary), column_names(column_names),
-      ids(std::move(ids)), start_dates(std::move(start_dates)), end_dates(std::move(end_dates))
+      ids(std::move(ids)), start_dates(std::move(block_start_dates)), end_dates(std::move(block_end_dates))
 {
 }
 
@@ -84,8 +84,8 @@ template <typename DictionaryType, typename Key>
 Block RangeDictionaryBlockInputStream<DictionaryType, Key>::getBlock(size_t start, size_t length) const
 {
     PaddedPODArray<Key> block_ids;
-    PaddedPODArray<UInt16> block_start_dates;
-    PaddedPODArray<UInt16> block_end_dates;
+    PaddedPODArray<Int64> block_start_dates;
+    PaddedPODArray<Int64> block_end_dates;
     block_ids.reserve(length);
     block_start_dates.reserve(length);
     block_end_dates.reserve(length);
@@ -104,7 +104,7 @@ template <typename DictionaryType, typename Key>
 template <typename AttributeType>
 ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromAttribute(
     DictionaryGetter<AttributeType> getter, const PaddedPODArray<Key> & ids_to_fill,
-    const PaddedPODArray<UInt16> & dates, const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const
+    const PaddedPODArray<Int64> & dates, const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const
 {
     auto column_vector = ColumnVector<AttributeType>::create(ids_to_fill.size());
     (concrete_dictionary.*getter)(attribute.name, ids_to_fill, dates, column_vector->getData());
@@ -113,7 +113,7 @@ ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromAtt
 
 template <typename DictionaryType, typename Key>
 ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromAttributeString(
-    const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<UInt16> & dates,
+    const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<Int64> & dates,
     const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const
 {
     auto column_string = ColumnString::create();
@@ -134,9 +134,9 @@ ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromPOD
 
 
 template <typename DictionaryType, typename Key>
-template <typename T>
+template <typename DictionarySpecialAttributeType, typename T>
 void RangeDictionaryBlockInputStream<DictionaryType, Key>::addSpecialColumn(
-    const std::optional<DictionarySpecialAttribute> & attribute, DataTypePtr type,
+    const std::optional<DictionarySpecialAttributeType> & attribute, DataTypePtr type,
     const std::string & default_name, const std::unordered_set<std::string> & column_names_set,
     const PaddedPODArray<T> & values, ColumnsWithTypeAndName & columns) const
 {
@@ -149,10 +149,10 @@ void RangeDictionaryBlockInputStream<DictionaryType, Key>::addSpecialColumn(
 }
 
 template <typename DictionaryType, typename Key>
-PaddedPODArray<UInt16> RangeDictionaryBlockInputStream<DictionaryType, Key>::makeDateKey(
-        const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const
+PaddedPODArray<Int64> RangeDictionaryBlockInputStream<DictionaryType, Key>::makeDateKey(
+        const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const
 {
-    PaddedPODArray<UInt16> key(block_start_dates.size());
+    PaddedPODArray<Int64> key(block_start_dates.size());
     for (size_t i = 0; i < key.size(); ++i)
     {
         if (RangeHashedDictionary::Range::isCorrectDate(block_start_dates[i]))
@@ -168,7 +168,7 @@ PaddedPODArray<UInt16> RangeDictionaryBlockInputStream<DictionaryType, Key>::mak
 template <typename DictionaryType, typename Key>
 Block RangeDictionaryBlockInputStream<DictionaryType, Key>::fillBlock(
     const PaddedPODArray<Key> & ids_to_fill,
-    const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const
+    const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const
 {
     ColumnsWithTypeAndName columns;
     const DictionaryStructure & structure = dictionary->getStructure();
@@ -176,8 +176,8 @@ Block RangeDictionaryBlockInputStream<DictionaryType, Key>::fillBlock(
     std::unordered_set<std::string> names(column_names.begin(), column_names.end());
 
     addSpecialColumn(structure.id, std::make_shared<DataTypeUInt64>(), "ID", names, ids_to_fill, columns);
-    addSpecialColumn(structure.range_min, std::make_shared<DataTypeDate>(), "Range Start", names, block_start_dates, columns);
-    addSpecialColumn(structure.range_max, std::make_shared<DataTypeDate>(), "Range End", names, block_end_dates, columns);
+    addSpecialColumn(structure.range_min, structure.range_max->type, "Range Start", names, block_start_dates, columns);
+    addSpecialColumn(structure.range_max, structure.range_max->type, "Range End", names, block_end_dates, columns);
 
     auto date_key = makeDateKey(block_start_dates, block_end_dates);
 
diff --git a/dbms/src/Dictionaries/RangeHashedDictionary.cpp b/dbms/src/Dictionaries/RangeHashedDictionary.cpp
index 890ee293cc83..2360c42fb7c9 100644
--- a/dbms/src/Dictionaries/RangeHashedDictionary.cpp
+++ b/dbms/src/Dictionaries/RangeHashedDictionary.cpp
@@ -1,7 +1,46 @@
 #include <Dictionaries/RangeHashedDictionary.h>
 #include <Dictionaries/RangeDictionaryBlockInputStream.h>
+#include <Functions/FunctionHelpers.h>
+#include <Columns/ColumnNullable.h>
+#include <ext/range.h>
 
 
+namespace
+{
+
+using RangeStorageType = DB::RangeHashedDictionary::RangeStorageType;
+
+// Null values mean that specified boundary, either min or max is not set on range.
+// To simplify comparison, null value of min bound should be bigger than any other value,
+// and null value of maxbound - less than any value.
+const RangeStorageType RANGE_MIN_NULL_VALUE = std::numeric_limits<RangeStorageType>::max();
+const RangeStorageType RANGE_MAX_NULL_VALUE = std::numeric_limits<RangeStorageType>::min();
+
+// Handle both kinds of null values: explicit nulls of NullableColumn and 'implicit' nulls of Date type.
+RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t index, bool isDate, const RangeStorageType & default_value)
+{
+    if (column.isNullAt(index))
+        return default_value;
+
+    const RangeStorageType result = static_cast<RangeStorageType>(column.getInt(index));
+    if (isDate && !DB::RangeHashedDictionary::Range::isCorrectDate(result))
+        return default_value;
+
+    return result;
+}
+
+const DB::IColumn & unwrapNullableColumn(const DB::IColumn & column)
+{
+    if (const auto * m = DB::checkAndGetColumn<DB::ColumnNullable>(&column))
+    {
+        return m->getNestedColumn();
+    }
+
+    return column;
+}
+
+} // namespace
+
 namespace DB
 {
 
@@ -12,6 +51,21 @@ namespace ErrorCodes
     extern const int TYPE_MISMATCH;
 }
 
+bool RangeHashedDictionary::Range::isCorrectDate(const RangeStorageType & date)
+{
+    return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;
+}
+
+bool RangeHashedDictionary::Range::contains(const RangeStorageType & value) const
+{
+    return left <= value && value <= right;
+}
+
+bool operator<(const RangeHashedDictionary::Range & left, const RangeHashedDictionary::Range & right)
+{
+    return std::tie(left.left, left.right) < std::tie(right.left, right.right);
+}
+
 
 RangeHashedDictionary::RangeHashedDictionary(
     const std::string & dictionary_name, const DictionaryStructure & dict_struct, DictionarySourcePtr source_ptr,
@@ -43,7 +97,7 @@ RangeHashedDictionary::RangeHashedDictionary(const RangeHashedDictionary & other
 
 #define DECLARE_MULTIPLE_GETTER(TYPE)\
 void RangeHashedDictionary::get##TYPE(\
-    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,\
+    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<RangeStorageType> & dates,\
     PaddedPODArray<TYPE> & out) const\
 {\
     const auto & attribute = getAttributeWithType(attribute_name, AttributeUnderlyingType::TYPE);\
@@ -63,7 +117,7 @@ DECLARE_MULTIPLE_GETTER(Float64)
 #undef DECLARE_MULTIPLE_GETTER
 
 void RangeHashedDictionary::getString(
-    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,
+    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<RangeStorageType> & dates,
     ColumnString * out) const
 {
     const auto & attribute = getAttributeWithType(attribute_name, AttributeUnderlyingType::String);
@@ -114,8 +168,12 @@ void RangeHashedDictionary::loadData()
     while (const auto block = stream->read())
     {
         const auto & id_column = *block.safeGetByPosition(0).column;
-        const auto & min_range_column = *block.safeGetByPosition(1).column;
-        const auto & max_range_column = *block.safeGetByPosition(2).column;
+
+        // Support old behaviour, where invalid date means 'open range'.
+        const bool is_date = isDate(block.safeGetByPosition(1).type);
+
+        const auto & min_range_column = unwrapNullableColumn(*block.safeGetByPosition(1).column);
+        const auto & max_range_column = unwrapNullableColumn(*block.safeGetByPosition(2).column);
 
         element_count += id_column.size();
 
@@ -124,10 +182,14 @@ void RangeHashedDictionary::loadData()
             const auto & attribute_column = *block.safeGetByPosition(attribute_idx + 3).column;
             auto & attribute = attributes[attribute_idx];
 
-            for (const auto row_idx : ext::range(0, id_column.size()))
-                setAttributeValue(attribute, id_column[row_idx].get<UInt64>(),
-                    Range(min_range_column[row_idx].get<UInt64>(), max_range_column[row_idx].get<UInt64>()),
+            for (const auto row_idx : ext::range(0, id_column.size())) {
+                const auto min = getColumnIntValueOrDefault(min_range_column, row_idx, is_date, RANGE_MIN_NULL_VALUE);
+                const auto max = getColumnIntValueOrDefault(max_range_column, row_idx, is_date, RANGE_MAX_NULL_VALUE);
+
+                setAttributeValue(attribute, id_column.getUInt(row_idx),
+                    Range{min, max},
                     attribute_column[row_idx]);
+            }
         }
     }
 
@@ -216,7 +278,7 @@ template <typename OutputType>
 void RangeHashedDictionary::getItems(
     const Attribute & attribute,
     const PaddedPODArray<Key> & ids,
-    const PaddedPODArray<UInt16> & dates,
+    const PaddedPODArray<RangeStorageType> & dates,
     PaddedPODArray<OutputType> & out) const
 {
     if (false) {}
@@ -243,7 +305,7 @@ template <typename AttributeType, typename OutputType>
 void RangeHashedDictionary::getItemsImpl(
     const Attribute & attribute,
     const PaddedPODArray<Key> & ids,
-    const PaddedPODArray<UInt16> & dates,
+    const PaddedPODArray<RangeStorageType> & dates,
     PaddedPODArray<OutputType> & out) const
 {
     const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);
@@ -354,7 +416,8 @@ const RangeHashedDictionary::Attribute & RangeHashedDictionary::getAttributeWith
 }
 
 void RangeHashedDictionary::getIdsAndDates(PaddedPODArray<Key> & ids,
-                                           PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const
+    PaddedPODArray<RangeStorageType> & start_dates,
+    PaddedPODArray<RangeStorageType> & end_dates) const
 {
     const auto & attribute = attributes.front();
 
@@ -377,7 +440,8 @@ void RangeHashedDictionary::getIdsAndDates(PaddedPODArray<Key> & ids,
 
 template <typename T>
 void RangeHashedDictionary::getIdsAndDates(const Attribute & attribute, PaddedPODArray<Key> & ids,
-                                           PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const
+                                           PaddedPODArray<RangeStorageType> & start_dates,
+                                           PaddedPODArray<RangeStorageType> & end_dates) const
 {
     const HashMap<UInt64, Values<T>> & attr = *std::get<Ptr<T>>(attribute.maps);
 
@@ -390,8 +454,8 @@ void RangeHashedDictionary::getIdsAndDates(const Attribute & attribute, PaddedPO
         for (const auto & value : key.second)
         {
             ids.push_back(key.first);
-            start_dates.push_back(value.range.first);
-            end_dates.push_back(value.range.second);
+            start_dates.push_back(value.range.left);
+            end_dates.push_back(value.range.right);
         }
     }
 }
@@ -399,8 +463,8 @@ void RangeHashedDictionary::getIdsAndDates(const Attribute & attribute, PaddedPO
 BlockInputStreamPtr RangeHashedDictionary::getBlockInputStream(const Names & column_names, size_t max_block_size) const
 {
     PaddedPODArray<Key> ids;
-    PaddedPODArray<UInt16> start_dates;
-    PaddedPODArray<UInt16> end_dates;
+    PaddedPODArray<RangeStorageType> start_dates;
+    PaddedPODArray<RangeStorageType> end_dates;
     getIdsAndDates(ids, start_dates, end_dates);
 
     using BlockInputStreamType = RangeDictionaryBlockInputStream<RangeHashedDictionary, Key>;
diff --git a/dbms/src/Dictionaries/RangeHashedDictionary.h b/dbms/src/Dictionaries/RangeHashedDictionary.h
index e6841388b857..73cb7ff4610d 100644
--- a/dbms/src/Dictionaries/RangeHashedDictionary.h
+++ b/dbms/src/Dictionaries/RangeHashedDictionary.h
@@ -5,7 +5,7 @@
 #include <Dictionaries/DictionaryStructure.h>
 #include <Common/HashTable/HashMap.h>
 #include <Columns/ColumnString.h>
-#include <ext/range.h>
+
 #include <atomic>
 #include <memory>
 #include <tuple>
@@ -59,9 +59,13 @@ class RangeHashedDictionary final : public IDictionaryBase
         return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;
     }
 
+    typedef Int64 RangeStorageType;
+
 #define DECLARE_MULTIPLE_GETTER(TYPE)\
     void get##TYPE(\
-        const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,\
+        const std::string & attribute_name,\
+        const PaddedPODArray<Key> & ids,\
+        const PaddedPODArray<RangeStorageType> & dates,\
         PaddedPODArray<TYPE> & out) const;
     DECLARE_MULTIPLE_GETTER(UInt8)
     DECLARE_MULTIPLE_GETTER(UInt16)
@@ -77,33 +81,18 @@ class RangeHashedDictionary final : public IDictionaryBase
 #undef DECLARE_MULTIPLE_GETTER
 
     void getString(
-        const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,
+        const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<RangeStorageType> & dates,
         ColumnString * out) const;
 
     BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;
 
-    struct Range : std::pair<UInt16, UInt16>
+    struct Range
     {
-        using std::pair<UInt16, UInt16>::pair;
-
-        static bool isCorrectDate(const UInt16 date) { return 0 < date && date <= DATE_LUT_MAX_DAY_NUM; }
-
-        bool contains(const UInt16 date) const
-        {
-            const auto & left = first;
-            const auto & right = second;
-
-            if (left <= date && date <= right)
-                return true;
-
-            const auto has_left_bound = isCorrectDate(left);
-            const auto has_right_bound = isCorrectDate(right);
-
-            if ((!has_left_bound || left <= date) && (!has_right_bound || date <= right))
-                return true;
+        RangeStorageType left;
+        RangeStorageType right;
 
-            return false;
-        }
+        static bool isCorrectDate(const RangeStorageType & date);
+        bool contains(const RangeStorageType& value) const;
     };
 
 private:
@@ -153,14 +142,14 @@ class RangeHashedDictionary final : public IDictionaryBase
     void getItems(
         const Attribute & attribute,
         const PaddedPODArray<Key> & ids,
-        const PaddedPODArray<UInt16> & dates,
+        const PaddedPODArray<RangeStorageType> & dates,
         PaddedPODArray<OutputType> & out) const;
 
     template <typename AttributeType, typename OutputType>
     void getItemsImpl(
         const Attribute & attribute,
         const PaddedPODArray<Key> & ids,
-        const PaddedPODArray<UInt16> & dates,
+        const PaddedPODArray<RangeStorageType> & dates,
         PaddedPODArray<OutputType> & out) const;
 
 
@@ -174,11 +163,11 @@ class RangeHashedDictionary final : public IDictionaryBase
     const Attribute & getAttributeWithType(const std::string & name, const AttributeUnderlyingType type) const;
 
     void getIdsAndDates(PaddedPODArray<Key> & ids,
-                        PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const;
+                        PaddedPODArray<RangeStorageType> & start_dates, PaddedPODArray<RangeStorageType> & end_dates) const;
 
     template <typename T>
     void getIdsAndDates(const Attribute & attribute, PaddedPODArray<Key> & ids,
-                        PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const;
+                        PaddedPODArray<RangeStorageType> & start_dates, PaddedPODArray<RangeStorageType> & end_dates) const;
 
     const std::string dictionary_name;
     const DictionaryStructure dict_struct;
diff --git a/dbms/src/Functions/FunctionsExternalDictionaries.h b/dbms/src/Functions/FunctionsExternalDictionaries.h
index 7aa24f5115f8..7a41439d3fed 100644
--- a/dbms/src/Functions/FunctionsExternalDictionaries.h
+++ b/dbms/src/Functions/FunctionsExternalDictionaries.h
@@ -32,6 +32,7 @@
 
 #include <ext/range.h>
 
+#include <type_traits>
 
 namespace DB
 {
@@ -109,7 +110,7 @@ class FunctionDictHas final : public IFunction
           * This feature is controversial and implemented specially
           *  for backward compatibility with the case in Yandex Banner System.
           */
-        if (input_rows_count== 0)
+        if (input_rows_count == 0)
         {
             auto & elem = block.getByPosition(result);
             elem.column = elem.type->createColumn();
@@ -197,6 +198,8 @@ static bool isDictGetFunctionInjective(const ExternalDictionaries & dictionaries
     return dictionaries.getDictionary(dict_name_col->getValue<String>())->isInjective(attr_name_col->getValue<String>());
 }
 
+template <typename T>
+const PaddedPODArray<T> * getColumnDataAsPaddedPODArray(const IColumn * column, PaddedPODArray<T> * backup_storage);
 
 class FunctionDictGetString final : public IFunction
 {
@@ -250,10 +253,11 @@ class FunctionDictGetString final : public IFunction
         }
 
         /// This is for the case of range dictionaries.
-        if (arguments.size() == 4 && !WhichDataType(arguments[3]).isDate())
+        if (arguments.size() == 4 && !arguments[3]->isValueRepresentedByInteger())
         {
-            throw Exception{"Illegal type " + arguments[3]->getName() + " of fourth argument of function " + getName()
-                + ", must be Date.", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
+            throw Exception{"Illegal type " + arguments[3]->getName() +
+                            " of fourth argument of function " + getName() +
+                            " must be convertible to Int64.", ErrorCodes::ILLEGAL_COLUMN};
         }
 
         return std::make_shared<DataTypeString>();
@@ -377,68 +381,18 @@ class FunctionDictGetString final : public IFunction
         String attr_name = attr_name_col->getValue<String>();
 
         const auto id_col_untyped = block.getByPosition(arguments[2]).column.get();
-        const auto date_col_untyped = block.getByPosition(arguments[3]).column.get();
-        if (const auto id_col = checkAndGetColumn<ColumnUInt64>(id_col_untyped))
-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);
-        else if (const auto id_col = checkAndGetColumnConst<ColumnVector<UInt64>>(id_col_untyped))
-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);
-        else
-        {
-            throw Exception{"Third argument of function " + getName() + " must be UInt64", ErrorCodes::ILLEGAL_COLUMN};
-        }
-
-        return true;
-    }
+        const auto range_col_untyped = block.getByPosition(arguments[3]).column.get();
 
-    template <typename DictionaryType>
-    void executeRange(
-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,
-        const ColumnUInt64 * id_col, const IColumn * date_col_untyped)
-    {
-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))
-        {
-            auto out = ColumnString::create();
-            dictionary->getString(attr_name, id_col->getData(), date_col->getData(), out.get());
-            block.getByPosition(result).column = std::move(out);
-        }
-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))
-        {
-            auto out = ColumnString::create();
-            const PaddedPODArray<UInt16> dates(id_col->size(), date_col->getValue<UInt64>());
-            dictionary->getString(attr_name, id_col->getData(), dates, out.get());
-            block.getByPosition(result).column = std::move(out);
-        }
-        else
-        {
-            throw Exception{"Fourth argument of function " + getName() + " must be Date", ErrorCodes::ILLEGAL_COLUMN};
-        }
-    }
+        PaddedPODArray<UInt64> id_col_values_storage;
+        PaddedPODArray<Int64> range_col_values_storage;
+        const auto * id_col_values = getColumnDataAsPaddedPODArray(id_col_untyped, &id_col_values_storage);
+        const auto * range_col_values = getColumnDataAsPaddedPODArray(range_col_untyped, &range_col_values_storage);
 
-    template <typename DictionaryType>
-    void executeRange(
-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,
-        const ColumnConst * id_col, const IColumn * date_col_untyped)
-    {
-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))
-        {
-            auto out = ColumnString::create();
-            const PaddedPODArray<UInt64> ids(date_col->size(), id_col->getValue<UInt64>());
-            dictionary->getString(attr_name, ids, date_col->getData(), out.get());
-            block.getByPosition(result).column = std::move(out);
-        }
-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))
-        {
-            const PaddedPODArray<UInt64> ids(1, id_col->getValue<UInt64>());
-            const PaddedPODArray<UInt16> dates(1, date_col->getValue<UInt16>());
+        auto out = ColumnString::create();
+        dict->getString(attr_name, *id_col_values, *range_col_values, out.get());
+        block.getByPosition(result).column = std::move(out);
 
-            auto out = ColumnString::create();
-            dictionary->getString(attr_name, ids, dates, out.get());
-            block.getByPosition(result).column = DataTypeString().createColumnConst(id_col->size(), out->getDataAt(0).toString());
-        }
-        else
-        {
-            throw Exception{"Fourth argument of function " + getName() + " must be Date", ErrorCodes::ILLEGAL_COLUMN};
-        }
+        return true;
     }
 
     const ExternalDictionaries & dictionaries;
@@ -666,7 +620,7 @@ template <> struct DictGetTraits<DATA_TYPE>\
     template <typename DictionaryType>\
     static void get(\
         const DictionaryType * dict, const std::string & name, const PaddedPODArray<UInt64> & ids,\
-        const PaddedPODArray<UInt16> & dates, PaddedPODArray<TYPE> & out)\
+        const PaddedPODArray<Int64> & dates, PaddedPODArray<TYPE> & out)\
     {\
         dict->get##TYPE(name, ids, dates, out);\
     }\
@@ -748,9 +702,15 @@ class FunctionDictGet final : public IFunction
             throw Exception{"Illegal type " + arguments[2]->getName() + " of third argument of function " + getName()
                 + ", must be UInt64 or tuple(...).", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
 
-        if (arguments.size() == 4 && !WhichDataType(arguments[3]).isDate())
-            throw Exception{"Illegal type " + arguments[3]->getName() + " of fourth argument of function " + getName()
-                + ", must be Date.", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
+        if (arguments.size() == 4 )
+        {
+            const auto range_argument = arguments[3].get();
+            if (!(range_argument->isValueRepresentedByInteger() &&
+                   range_argument->getSizeOfValueInMemory() <= sizeof(Int64)))
+                throw Exception{"Illegal type " + range_argument->getName() + " of fourth argument of function " + getName()
+                    + ", must be convertible to " + TypeName<Int64>::get() + ".",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};
+        }
 
         return std::make_shared<DataType>();
     }
@@ -883,74 +843,19 @@ class FunctionDictGet final : public IFunction
         String attr_name = attr_name_col->getValue<String>();
 
         const auto id_col_untyped = block.getByPosition(arguments[2]).column.get();
-        const auto date_col_untyped = block.getByPosition(arguments[3]).column.get();
-        if (const auto id_col = checkAndGetColumn<ColumnUInt64>(id_col_untyped))
-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);
-        else if (const auto id_col = checkAndGetColumnConst<ColumnVector<UInt64>>(id_col_untyped))
-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);
-        else
-            throw Exception{"Third argument of function " + getName() + " must be UInt64", ErrorCodes::ILLEGAL_COLUMN};
+        const auto range_col_untyped = block.getByPosition(arguments[3]).column.get();
 
-        return true;
-    }
+        PaddedPODArray<UInt64> id_col_values_storage;
+        PaddedPODArray<Int64> range_col_values_storage;
+        const auto * id_col_values = getColumnDataAsPaddedPODArray(id_col_untyped, &id_col_values_storage);
+        const auto * range_col_values = getColumnDataAsPaddedPODArray(range_col_untyped, &range_col_values_storage);
 
-    template <typename DictionaryType>
-    void executeRange(
-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,
-        const ColumnUInt64 * id_col, const IColumn * date_col_untyped)
-    {
-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))
-        {
-            const auto size = id_col->size();
-            const auto & ids = id_col->getData();
-            const auto & dates = date_col->getData();
-
-            auto out = ColumnVector<Type>::create(size);
-            auto & data = out->getData();
-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);
-            block.getByPosition(result).column = std::move(out);
-        }
-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))
-        {
-            const auto size = id_col->size();
-            const auto & ids = id_col->getData();
-            const PaddedPODArray<UInt16> dates(size, date_col->getValue<UInt16>());
-
-            auto out = ColumnVector<Type>::create(size);
-            auto & data = out->getData();
-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);
-            block.getByPosition(result).column = std::move(out);
-        }
-        else
-            throw Exception{"Fourth argument of function " + getName() + " must be Date", ErrorCodes::ILLEGAL_COLUMN};
-    }
-
-    template <typename DictionaryType>
-    void executeRange(
-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,
-        const ColumnConst * id_col, const IColumn * date_col_untyped)
-    {
-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))
-        {
-            const auto size = date_col->size();
-            const PaddedPODArray<UInt64> ids(size, id_col->getValue<UInt64>());
-            const auto & dates = date_col->getData();
+        auto out = ColumnVector<Type>::create(id_col_untyped->size());
+        auto & data = out->getData();
+        DictGetTraits<DataType>::get(dict, attr_name, *id_col_values, *range_col_values, data);
+        block.getByPosition(result).column = std::move(out);
 
-            auto out = ColumnVector<Type>::create(size);
-            auto & data = out->getData();
-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);
-            block.getByPosition(result).column = std::move(out);
-        }
-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))
-        {
-            const PaddedPODArray<UInt64> ids(1, id_col->getValue<UInt64>());
-            const PaddedPODArray<UInt16> dates(1, date_col->getValue<UInt16>());
-            PaddedPODArray<Type> data(1);
-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);
-            block.getByPosition(result).column = DataTypeNumber<Type>().createColumnConst(id_col->size(), toField(data.front()));
-        }
-        else
-            throw Exception{"Fourth argument of function " + getName() + " must be Date", ErrorCodes::ILLEGAL_COLUMN};
+        return true;
     }
 
     const ExternalDictionaries & dictionaries;
@@ -1547,4 +1452,42 @@ class FunctionDictIsIn final : public IFunction
     const ExternalDictionaries & dictionaries;
 };
 
+
+template <typename T>
+auto getColumnData(const IColumn * column, size_t index) ->
+    std::enable_if_t<std::is_signed_v<T> && std::is_integral_v<T>, Int64>
+{
+    return column->getInt(index);
+}
+
+template <typename T>
+auto getColumnData(const IColumn * column, size_t index) ->
+    std::enable_if_t<std::is_unsigned_v<T> && std::is_integral_v<T>, UInt64>
+{
+    return column->getUInt(index);
+}
+
+template <typename T>
+const PaddedPODArray<T> * getColumnDataAsPaddedPODArray(const IColumn * column, PaddedPODArray<T> * backup_storage)
+{
+    if (const auto vector_col = checkAndGetColumn<ColumnVector<T>>(column))
+    {
+        return &vector_col->getData();
+    }
+    if (const auto const_col = checkAndGetColumnConstData<ColumnVector<T>>(column))
+    {
+        return &const_col->getData();
+    }
+
+    // With type conversion, need to use backup storage here
+    const auto size = column->size();
+    backup_storage->resize(size);
+    for (size_t i = 0; i < size; ++i)
+    {
+        (*backup_storage)[i] = getColumnData<T>(column, i);
+    }
+
+    return backup_storage;
+}
+
 }
diff --git a/dbms/src/Storages/StorageDictionary.cpp b/dbms/src/Storages/StorageDictionary.cpp
index 26fdccbc3b8e..fab2e5408042 100644
--- a/dbms/src/Storages/StorageDictionary.cpp
+++ b/dbms/src/Storages/StorageDictionary.cpp
@@ -54,9 +54,9 @@ NamesAndTypesList StorageDictionary::getNamesAndTypes(const DictionaryStructure
     if (dictionary_structure.id)
         dictionary_names_and_types.emplace_back(dictionary_structure.id->name, std::make_shared<DataTypeUInt64>());
     if (dictionary_structure.range_min)
-        dictionary_names_and_types.emplace_back(dictionary_structure.range_min->name, std::make_shared<DataTypeDate>());
+        dictionary_names_and_types.emplace_back(dictionary_structure.range_min->name, dictionary_structure.range_min->type);
     if (dictionary_structure.range_max)
-        dictionary_names_and_types.emplace_back(dictionary_structure.range_max->name, std::make_shared<DataTypeDate>());
+        dictionary_names_and_types.emplace_back(dictionary_structure.range_max->name, dictionary_structure.range_max->type);
     if (dictionary_structure.key)
         for (const auto & attribute : *dictionary_structure.key)
             dictionary_names_and_types.emplace_back(attribute.name, attribute.type);
