{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 43457,
  "instance_id": "ClickHouse__ClickHouse-43457",
  "issue_numbers": [
    "42158"
  ],
  "base_commit": "a03fc9293c84dd6c3976e84d91f3fda00bcd01dc",
  "patch": "diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex ce7e27026f10..22c94e01a516 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -207,7 +207,7 @@ void LocalServer::tryInitPath()\n \n     global_context->setPath(path);\n \n-    global_context->setTemporaryStorage(path + \"tmp\", \"\", 0);\n+    global_context->setTemporaryStoragePath(path + \"tmp/\", 0);\n     global_context->setFlagsPath(path + \"flags\");\n \n     global_context->setUserFilesPath(\"\"); // user's files are everywhere\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex b6ce358a5efd..e772208c30ef 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -203,46 +203,6 @@ int mainEntryClickHouseServer(int argc, char ** argv)\n namespace\n {\n \n-void setupTmpPath(Poco::Logger * log, const std::string & path)\n-try\n-{\n-    LOG_DEBUG(log, \"Setting up {} to store temporary data in it\", path);\n-\n-    fs::create_directories(path);\n-\n-    /// Clearing old temporary files.\n-    fs::directory_iterator dir_end;\n-    size_t unknown_files = 0;\n-    for (fs::directory_iterator it(path); it != dir_end; ++it)\n-    {\n-        if (it->is_regular_file() && startsWith(it->path().filename(), \"tmp\"))\n-        {\n-            LOG_DEBUG(log, \"Removing old temporary file {}\", it->path().string());\n-            fs::remove(it->path());\n-        }\n-        else\n-        {\n-            unknown_files++;\n-            if (unknown_files < 100)\n-                LOG_DEBUG(log, \"Found unknown {} {} in temporary path\",\n-                    it->is_regular_file() ? \"file\" : (it->is_directory() ? \"directory\" : \"element\"),\n-                    it->path().string());\n-        }\n-    }\n-\n-    if (unknown_files)\n-        LOG_DEBUG(log, \"Found {} unknown files in temporary path\", unknown_files);\n-}\n-catch (...)\n-{\n-    DB::tryLogCurrentException(\n-        log,\n-        fmt::format(\n-            \"Caught exception while setup temporary path: {}. It is ok to skip this exception as cleaning old temporary files is not \"\n-            \"necessary\",\n-            path));\n-}\n-\n size_t waitServersToFinish(std::vector<DB::ProtocolServerAdapter> & servers, size_t seconds_to_wait)\n {\n     const size_t sleep_max_ms = 1000 * seconds_to_wait;\n@@ -1037,13 +997,21 @@ try\n     LOG_TRACE(log, \"Initialized DateLUT with time zone '{}'.\", DateLUT::instance().getTimeZone());\n \n     /// Storage with temporary data for processing of heavy queries.\n+    if (auto temporary_policy = config().getString(\"tmp_policy\", \"\"); !temporary_policy.empty())\n+    {\n+        size_t max_size = config().getUInt64(\"max_temporary_data_on_disk_size\", 0);\n+        global_context->setTemporaryStoragePolicy(temporary_policy, max_size);\n+    }\n+    else if (auto temporary_cache = config().getString(\"tmp_cache\", \"\"); !temporary_cache.empty())\n+    {\n+        size_t max_size = config().getUInt64(\"max_temporary_data_on_disk_size\", 0);\n+        global_context->setTemporaryStorageInCache(temporary_cache, max_size);\n+    }\n+    else\n     {\n         std::string temporary_path = config().getString(\"tmp_path\", path / \"tmp/\");\n-        std::string temporary_policy = config().getString(\"tmp_policy\", \"\");\n         size_t max_size = config().getUInt64(\"max_temporary_data_on_disk_size\", 0);\n-        const VolumePtr & volume = global_context->setTemporaryStorage(temporary_path, temporary_policy, max_size);\n-        for (const DiskPtr & disk : volume->getDisks())\n-            setupTmpPath(log, disk->getPath());\n+        global_context->setTemporaryStoragePath(temporary_path, max_size);\n     }\n \n     /** Directory with 'flags': files indicating temporary settings for the server set by system administrator.\n@@ -1442,7 +1410,7 @@ try\n     }\n     catch (...)\n     {\n-        tryLogCurrentException(log);\n+        tryLogCurrentException(log, \"Caught exception while setting up access control.\");\n         throw;\n     }\n \ndiff --git a/src/Common/filesystemHelpers.cpp b/src/Common/filesystemHelpers.cpp\nindex 07a08dc7fbca..43f88dd7faa6 100644\n--- a/src/Common/filesystemHelpers.cpp\n+++ b/src/Common/filesystemHelpers.cpp\n@@ -64,11 +64,11 @@ bool enoughSpaceInDirectory(const std::string & path, size_t data_size)\n     return data_size <= free_space;\n }\n \n-std::unique_ptr<TemporaryFile> createTemporaryFile(const std::string & path)\n+std::unique_ptr<PocoTemporaryFile> createTemporaryFile(const std::string & folder_path)\n {\n     ProfileEvents::increment(ProfileEvents::ExternalProcessingFilesTotal);\n-    fs::create_directories(path);\n-    return std::make_unique<TemporaryFile>(path);\n+    fs::create_directories(folder_path);\n+    return std::make_unique<PocoTemporaryFile>(folder_path);\n }\n \n #if !defined(OS_LINUX)\ndiff --git a/src/Common/filesystemHelpers.h b/src/Common/filesystemHelpers.h\nindex 0e6e16941bb3..14ee5f54322f 100644\n--- a/src/Common/filesystemHelpers.h\n+++ b/src/Common/filesystemHelpers.h\n@@ -14,10 +14,10 @@ namespace fs = std::filesystem;\n namespace DB\n {\n \n-using TemporaryFile = Poco::TemporaryFile;\n+using PocoTemporaryFile = Poco::TemporaryFile;\n \n bool enoughSpaceInDirectory(const std::string & path, size_t data_size);\n-std::unique_ptr<TemporaryFile> createTemporaryFile(const std::string & path);\n+std::unique_ptr<PocoTemporaryFile> createTemporaryFile(const std::string & folder_path);\n \n \n // Determine what block device is responsible for specified path\ndiff --git a/src/Disks/IO/CachedOnDiskReadBufferFromFile.cpp b/src/Disks/IO/CachedOnDiskReadBufferFromFile.cpp\nindex 5b5d746ab550..0dd40e7f1532 100644\n--- a/src/Disks/IO/CachedOnDiskReadBufferFromFile.cpp\n+++ b/src/Disks/IO/CachedOnDiskReadBufferFromFile.cpp\n@@ -118,10 +118,7 @@ void CachedOnDiskReadBufferFromFile::initialize(size_t offset, size_t size)\n     }\n     else\n     {\n-        CreateFileSegmentSettings create_settings{\n-            .is_persistent = is_persistent\n-        };\n-\n+        CreateFileSegmentSettings create_settings(is_persistent ? FileSegmentKind::Persistent : FileSegmentKind::Regular);\n         file_segments_holder.emplace(cache->getOrSet(cache_key, offset, size, create_settings));\n     }\n \n@@ -951,7 +948,7 @@ bool CachedOnDiskReadBufferFromFile::nextImplStep()\n             }\n             else\n             {\n-                LOG_TRACE(log, \"No space left in cache, will continue without cache download\");\n+                LOG_TRACE(log, \"No space left in cache to reserve {} bytes, will continue without cache download\", size);\n                 file_segment->completeWithState(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);\n             }\n \ndiff --git a/src/Disks/IO/CachedOnDiskWriteBufferFromFile.cpp b/src/Disks/IO/CachedOnDiskWriteBufferFromFile.cpp\nindex 994bb743c5f7..b11edd7e7011 100644\n--- a/src/Disks/IO/CachedOnDiskWriteBufferFromFile.cpp\n+++ b/src/Disks/IO/CachedOnDiskWriteBufferFromFile.cpp\n@@ -51,16 +51,42 @@ FileSegmentRangeWriter::FileSegmentRangeWriter(\n {\n }\n \n-bool FileSegmentRangeWriter::write(const char * data, size_t size, size_t offset, bool is_persistent)\n+bool FileSegmentRangeWriter::write(const char * data, size_t size, size_t offset, FileSegmentKind segment_kind)\n+{\n+    size_t written_size = tryWrite(data, size, offset, segment_kind, true);\n+    return written_size == size;\n+}\n+\n+size_t FileSegmentRangeWriter::tryWrite(const char * data, size_t size, size_t offset, FileSegmentKind segment_kind, bool strict)\n+{\n+    size_t total_written_size = 0;\n+    while (size > 0)\n+    {\n+        size_t written_size = tryWriteImpl(data, size, offset, segment_kind, strict);\n+        chassert(written_size <= size);\n+        if (written_size == 0)\n+            break;\n+\n+        if (data)\n+            data += written_size;\n+\n+        size -= written_size;\n+        offset += written_size;\n+        total_written_size += written_size;\n+    }\n+    return total_written_size;\n+}\n+\n+size_t FileSegmentRangeWriter::tryWriteImpl(const char * data, size_t size, size_t offset, FileSegmentKind segment_kind, bool strict)\n {\n     if (finalized)\n-        return false;\n+        return 0;\n \n     auto & file_segments = file_segments_holder.file_segments;\n \n     if (current_file_segment_it == file_segments.end())\n     {\n-        current_file_segment_it = allocateFileSegment(current_file_segment_write_offset, is_persistent);\n+        current_file_segment_it = allocateFileSegment(current_file_segment_write_offset, segment_kind);\n     }\n     else\n     {\n@@ -78,7 +104,7 @@ bool FileSegmentRangeWriter::write(const char * data, size_t size, size_t offset\n         if (file_segment->range().size() == file_segment->getDownloadedSize())\n         {\n             completeFileSegment(*file_segment);\n-            current_file_segment_it = allocateFileSegment(current_file_segment_write_offset, is_persistent);\n+            current_file_segment_it = allocateFileSegment(current_file_segment_write_offset, segment_kind);\n         }\n     }\n \n@@ -93,20 +119,26 @@ bool FileSegmentRangeWriter::write(const char * data, size_t size, size_t offset\n             file_segment->completePartAndResetDownloader();\n     });\n \n-    bool reserved = file_segment->reserve(size);\n-    if (!reserved)\n+    size_t reserved_size = file_segment->tryReserve(size, strict);\n+    if (reserved_size == 0 || (strict && reserved_size != size))\n     {\n-        file_segment->completeWithState(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);\n-        appendFilesystemCacheLog(*file_segment);\n+        if (strict)\n+        {\n+            file_segment->completeWithState(FileSegment::State::PARTIALLY_DOWNLOADED_NO_CONTINUATION);\n+            appendFilesystemCacheLog(*file_segment);\n+        }\n \n         LOG_DEBUG(\n             &Poco::Logger::get(\"FileSegmentRangeWriter\"),\n             \"Unsuccessful space reservation attempt (size: {}, file segment info: {}\",\n             size, file_segment->getInfoForLog());\n \n-        return false;\n+        return 0;\n     }\n \n+    /// Shrink to reserved size, because we can't write more than reserved\n+    size = reserved_size;\n+\n     try\n     {\n         file_segment->write(data, size, offset);\n@@ -120,7 +152,17 @@ bool FileSegmentRangeWriter::write(const char * data, size_t size, size_t offset\n     file_segment->completePartAndResetDownloader();\n     current_file_segment_write_offset += size;\n \n-    return true;\n+    return size;\n+}\n+\n+bool FileSegmentRangeWriter::reserve(size_t size, size_t offset)\n+{\n+    return write(nullptr, size, offset, FileSegmentKind::Temporary);\n+}\n+\n+size_t FileSegmentRangeWriter::tryReserve(size_t size, size_t offset)\n+{\n+    return tryWrite(nullptr, size, offset, FileSegmentKind::Temporary);\n }\n \n void FileSegmentRangeWriter::finalize()\n@@ -129,6 +171,7 @@ void FileSegmentRangeWriter::finalize()\n         return;\n \n     auto & file_segments = file_segments_holder.file_segments;\n+\n     if (file_segments.empty() || current_file_segment_it == file_segments.end())\n         return;\n \n@@ -149,7 +192,7 @@ FileSegmentRangeWriter::~FileSegmentRangeWriter()\n     }\n }\n \n-FileSegments::iterator FileSegmentRangeWriter::allocateFileSegment(size_t offset, bool is_persistent)\n+FileSegments::iterator FileSegmentRangeWriter::allocateFileSegment(size_t offset, FileSegmentKind segment_kind)\n {\n     /**\n     * Allocate a new file segment starting `offset`.\n@@ -158,10 +201,7 @@ FileSegments::iterator FileSegmentRangeWriter::allocateFileSegment(size_t offset\n \n     std::lock_guard cache_lock(cache->mutex);\n \n-    CreateFileSegmentSettings create_settings\n-    {\n-        .is_persistent = is_persistent,\n-    };\n+    CreateFileSegmentSettings create_settings(segment_kind);\n \n     /// We set max_file_segment_size to be downloaded,\n     /// if we have less size to write, file segment will be resized in complete() method.\n@@ -196,12 +236,15 @@ void FileSegmentRangeWriter::appendFilesystemCacheLog(const FileSegment & file_s\n     }\n }\n \n-void FileSegmentRangeWriter::completeFileSegment(FileSegment & file_segment)\n+void FileSegmentRangeWriter::completeFileSegment(FileSegment & file_segment, std::optional<FileSegment::State> state)\n {\n     /// File segment can be detached if space reservation failed.\n     if (file_segment.isDetached())\n         return;\n \n+    if (state.has_value())\n+        file_segment.setDownloadState(*state);\n+\n     file_segment.completeWithoutState();\n     appendFilesystemCacheLog(file_segment);\n }\n@@ -270,7 +313,8 @@ void CachedOnDiskWriteBufferFromFile::cacheData(char * data, size_t size)\n \n     try\n     {\n-        if (!cache_writer->write(data, size, current_download_offset, is_persistent_cache_file))\n+        auto segment_kind = is_persistent_cache_file ? FileSegmentKind::Persistent : FileSegmentKind::Regular;\n+        if (!cache_writer->write(data, size, current_download_offset, segment_kind))\n         {\n             LOG_INFO(log, \"Write-through cache is stopped as cache limit is reached and nothing can be evicted\");\n             return;\ndiff --git a/src/Disks/IO/CachedOnDiskWriteBufferFromFile.h b/src/Disks/IO/CachedOnDiskWriteBufferFromFile.h\nindex cec7305ab1ba..38ec2b46a5d2 100644\n--- a/src/Disks/IO/CachedOnDiskWriteBufferFromFile.h\n+++ b/src/Disks/IO/CachedOnDiskWriteBufferFromFile.h\n@@ -4,6 +4,7 @@\n #include <IO/WriteSettings.h>\n #include <Interpreters/Cache/FileCache.h>\n #include <Interpreters/FilesystemCacheLog.h>\n+#include <Common/filesystemHelpers.h>\n \n namespace Poco\n {\n@@ -28,22 +29,44 @@ class FileSegmentRangeWriter\n         FileCache * cache_, const FileSegment::Key & key_,\n         std::shared_ptr<FilesystemCacheLog> cache_log_, const String & query_id_, const String & source_path_);\n \n-    /**\n-    * Write a range of file segments. Allocate file segment of `max_file_segment_size` and write to\n-    * it until it is full and then allocate next file segment.\n-    */\n-    bool write(const char * data, size_t size, size_t offset, bool is_persistent);\n+    /* Write a range of file segments.\n+     * Allocate file segment of `max_file_segment_size` and write to it until it is full and then allocate next file segment.\n+     * If it's impossible to allocate new file segment and reserve space to write all data, then returns false.\n+     *\n+     * Note: the data that was written to file segments before the error occurred is not rolled back.\n+     */\n+    bool write(const char * data, size_t size, size_t offset, FileSegmentKind segment_kind);\n+\n+    /* Tries to write data to current file segment.\n+     * Size of written data may be less than requested_size, because it may not be enough space.\n+     *\n+     * Returns size of written data.\n+     */\n+    size_t tryWrite(const char * data, size_t size, size_t offset, FileSegmentKind segment_kind = FileSegmentKind::Regular, bool strict = false);\n+\n+    /// Same as `write/tryWrite`, but doesn't write anything, just reserves some space in cache\n+    bool reserve(size_t size, size_t offset);\n+    size_t tryReserve(size_t size, size_t offset);\n \n     void finalize();\n \n+    size_t currentOffset() const { return current_file_segment_write_offset; }\n+\n     ~FileSegmentRangeWriter();\n \n private:\n-    FileSegments::iterator allocateFileSegment(size_t offset, bool is_persistent);\n+    FileSegments::iterator allocateFileSegment(size_t offset, FileSegmentKind segment_kind);\n \n     void appendFilesystemCacheLog(const FileSegment & file_segment);\n \n-    void completeFileSegment(FileSegment & file_segment);\n+    void completeFileSegment(FileSegment & file_segment, std::optional<FileSegment::State> state = {});\n+\n+    /* Writes data to current file segment as much as possible and returns size of written data, do not allocate new file segments\n+     * In `strict` mode it will write all data or nothing, otherwise it will write as much as possible\n+     * If returned non zero value, then we can try to write again to next file segment.\n+     * If no space is available, returns zero.\n+     */\n+    size_t tryWriteImpl(const char * data, size_t size, size_t offset, FileSegmentKind segment_kind, bool strict);\n \n     FileCache * cache;\n     FileSegment::Key key;\ndiff --git a/src/Disks/IO/FileCachePlaceholder.cpp b/src/Disks/IO/FileCachePlaceholder.cpp\nnew file mode 100644\nindex 000000000000..d45d7b2d83d9\n--- /dev/null\n+++ b/src/Disks/IO/FileCachePlaceholder.cpp\n@@ -0,0 +1,73 @@\n+#include <Disks/IO/FileCachePlaceholder.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NOT_ENOUGH_SPACE;\n+}\n+\n+void ISpacePlaceholder::reserveCapacity(size_t requested_capacity)\n+{\n+    chassert(used_space <= capacity);\n+\n+    size_t remaining_space = capacity - used_space;\n+    LOG_TEST(&Poco::Logger::get(\"ISpacePlaceholder\"), \"Reserving {} bytes (used_space: {}, capacity: {})\", requested_capacity, used_space, capacity);\n+\n+    if (requested_capacity <= remaining_space)\n+        return;\n+\n+    size_t capacity_to_reserve = requested_capacity - remaining_space;\n+    reserveImpl(capacity_to_reserve);\n+    capacity += capacity_to_reserve;\n+}\n+\n+void ISpacePlaceholder::setUsed(size_t size)\n+{\n+    LOG_TEST(&Poco::Logger::get(\"ISpacePlaceholder\"), \"Using {} bytes ({} already used, {} capacity)\", size, used_space, capacity);\n+\n+    if (used_space + size > capacity)\n+    {\n+        LOG_WARNING(&Poco::Logger::get(\"ISpacePlaceholder\"), \"Used space is greater than capacity. It may lead to not enough space error\");\n+        reserveCapacity(size);\n+    }\n+\n+    used_space = used_space + size;\n+}\n+\n+FileCachePlaceholder::FileCachePlaceholder(FileCache * cache, const String & name)\n+    : key_name(name)\n+    , file_cache(cache)\n+{\n+}\n+\n+void FileCachePlaceholder::reserveImpl(size_t requested_size)\n+{\n+    /// We create new cache_writer and will try to reserve requested_size in it\n+    String key = fmt::format(\"{}_{}\", key_name, cache_writers.size());\n+    auto cache_writer = std::make_unique<FileSegmentRangeWriter>(file_cache,\n+                                                                 file_cache->hash(key),\n+                                                                 /* cache_log_ */ nullptr,\n+                                                                 /* query_id_ */ \"\",\n+                                                                 /* source_path_ */ key);\n+\n+    size_t current_offset = cache_writer->currentOffset();\n+    size_t reserved_size = cache_writer->tryReserve(requested_size, current_offset);\n+    if (reserved_size != requested_size)\n+    {\n+        throw Exception(ErrorCodes::NOT_ENOUGH_SPACE,\n+            \"Cannot reserve space in file cache \"\n+            \"({} bytes required, got {} reserved \"\n+            \"{} / {} bytes used, \"\n+            \"{} / {} elements used)\"\n+            , requested_size, reserved_size\n+            , file_cache->getUsedCacheSize(), file_cache->getTotalMaxSize()\n+            , file_cache->getFileSegmentsNum(), file_cache->getTotalMaxElements());\n+    }\n+    /// Add to cache_writers only if we successfully reserved space, otherwise free reserved_size back\n+    cache_writers.push_back(std::move(cache_writer));\n+}\n+\n+\n+}\ndiff --git a/src/Disks/IO/FileCachePlaceholder.h b/src/Disks/IO/FileCachePlaceholder.h\nnew file mode 100644\nindex 000000000000..6ddeb85286b4\n--- /dev/null\n+++ b/src/Disks/IO/FileCachePlaceholder.h\n@@ -0,0 +1,61 @@\n+#pragma once\n+\n+#include <Interpreters/Cache/FileCache.h>\n+#include <Disks/IO/CachedOnDiskWriteBufferFromFile.h>\n+\n+#include <Poco/Logger.h>\n+#include <Poco/ConsoleChannel.h>\n+\n+#include <filesystem>\n+\n+namespace fs = std::filesystem;\n+\n+namespace DB\n+{\n+\n+\n+/* ISpacePlaceholder is a base class for all classes that need to reserve space in some storage.\n+ * You should resrve space with call reserveCapacity() before writing to it.\n+ * After writing you should call setUsed() to let ISpacePlaceholder know how much space was used.\n+ * It can be different because in some cases you don't know exact size of data you will write (because of compression, for example).\n+ * It's better to reserve more space in advance not to overuse space.\n+ */\n+class ISpacePlaceholder\n+{\n+public:\n+    /// Reserve space in storage\n+    void reserveCapacity(size_t requested_capacity);\n+\n+    /// Indicate that some space is used\n+    /// It uses reserved space if it is possible, otherwise it reserves more space\n+    void setUsed(size_t size);\n+\n+    virtual ~ISpacePlaceholder() = default;\n+\n+private:\n+    virtual void reserveImpl(size_t size) = 0;\n+\n+    size_t capacity = 0;\n+    size_t used_space = 0;\n+};\n+\n+/* FileCachePlaceholder is a class that reserves space in FileCache.\n+ * Data is written externally, and FileCachePlaceholder is only used to hold space in FileCache.\n+ */\n+class FileCachePlaceholder : public ISpacePlaceholder\n+{\n+public:\n+    FileCachePlaceholder(FileCache * cache, const String & name);\n+\n+    void reserveImpl(size_t requested_size) override;\n+\n+private:\n+    std::string key_name;\n+    FileCache * file_cache;\n+\n+    /// On each reserveImpl() call we create new FileSegmentRangeWriter that would be hold space\n+    /// It's required to easily release already reserved space on unsuccessful attempt\n+    std::vector<std::unique_ptr<FileSegmentRangeWriter>> cache_writers;\n+};\n+\n+}\ndiff --git a/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h b/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h\nindex 2d67203be0f8..119dc25c66b1 100644\n--- a/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h\n+++ b/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h\n@@ -113,6 +113,8 @@ class CachedObjectStorage final : public IObjectStorage\n \n     WriteSettings getAdjustedSettingsFromMetadataFile(const WriteSettings & settings, const std::string & path) const override;\n \n+    FileCachePtr getCache() const { return cache; }\n+\n private:\n     FileCache::Key getCacheKey(const std::string & path) const;\n \ndiff --git a/src/Disks/ObjectStorages/DiskObjectStorage.cpp b/src/Disks/ObjectStorages/DiskObjectStorage.cpp\nindex 263a9a9d0e10..4230fb6254a3 100644\n--- a/src/Disks/ObjectStorages/DiskObjectStorage.cpp\n+++ b/src/Disks/ObjectStorages/DiskObjectStorage.cpp\n@@ -519,6 +519,14 @@ void DiskObjectStorage::wrapWithCache(FileCachePtr cache, const FileCacheSetting\n     object_storage = std::make_shared<CachedObjectStorage>(object_storage, cache, cache_settings, layer_name);\n }\n \n+FileCachePtr DiskObjectStorage::getCache() const\n+{\n+    const auto * cached_object_storage = typeid_cast<CachedObjectStorage *>(object_storage.get());\n+    if (!cached_object_storage)\n+        return nullptr;\n+    return cached_object_storage->getCache();\n+}\n+\n NameSet DiskObjectStorage::getCacheLayersNames() const\n {\n     NameSet cache_layers;\ndiff --git a/src/Disks/ObjectStorages/DiskObjectStorage.h b/src/Disks/ObjectStorages/DiskObjectStorage.h\nindex 00e3cf98142e..a24acc270c00 100644\n--- a/src/Disks/ObjectStorages/DiskObjectStorage.h\n+++ b/src/Disks/ObjectStorages/DiskObjectStorage.h\n@@ -186,6 +186,7 @@ friend class DiskObjectStorageRemoteMetadataRestoreHelper;\n     /// There can be any number of cache layers:\n     /// DiskObjectStorage(CachedObjectStorage(...CacheObjectStorage(S3ObjectStorage)...))\n     void wrapWithCache(FileCachePtr cache, const FileCacheSettings & cache_settings, const String & layer_name);\n+    FileCachePtr getCache() const;\n \n     /// Get structure of object storage this disk works with. Examples:\n     /// DiskObjectStorage(S3ObjectStorage)\ndiff --git a/src/Disks/TemporaryFileInPath.cpp b/src/Disks/TemporaryFileInPath.cpp\nnew file mode 100644\nindex 000000000000..eae7fa668557\n--- /dev/null\n+++ b/src/Disks/TemporaryFileInPath.cpp\n@@ -0,0 +1,20 @@\n+#include <Disks/TemporaryFileInPath.h>\n+#include <Common/filesystemHelpers.h>\n+\n+namespace DB\n+{\n+\n+TemporaryFileInPath::TemporaryFileInPath(const String & folder_path)\n+    : tmp_file(createTemporaryFile(folder_path))\n+{\n+    chassert(tmp_file);\n+}\n+\n+String TemporaryFileInPath::getPath() const\n+{\n+    return tmp_file->path();\n+}\n+\n+TemporaryFileInPath::~TemporaryFileInPath() = default;\n+\n+}\ndiff --git a/src/Disks/TemporaryFileInPath.h b/src/Disks/TemporaryFileInPath.h\nnew file mode 100644\nindex 000000000000..503247e3f899\n--- /dev/null\n+++ b/src/Disks/TemporaryFileInPath.h\n@@ -0,0 +1,21 @@\n+#pragma once\n+\n+#include <Disks/TemporaryFileOnDisk.h>\n+#include <Poco/TemporaryFile.h>\n+\n+namespace DB\n+{\n+\n+/// Wrapper around Poco::TemporaryFile to implement ITemporaryFile.\n+class TemporaryFileInPath : public ITemporaryFile\n+{\n+public:\n+    explicit TemporaryFileInPath(const String & folder_path);\n+    String getPath() const override;\n+\n+    ~TemporaryFileInPath() override;\n+private:\n+    std::unique_ptr<Poco::TemporaryFile> tmp_file;\n+};\n+\n+}\ndiff --git a/src/Disks/TemporaryFileOnDisk.cpp b/src/Disks/TemporaryFileOnDisk.cpp\nindex 4f3485190370..af1f3f87c71f 100644\n--- a/src/Disks/TemporaryFileOnDisk.cpp\n+++ b/src/Disks/TemporaryFileOnDisk.cpp\n@@ -2,6 +2,7 @@\n #include <Poco/TemporaryFile.h>\n #include <Common/CurrentMetrics.h>\n #include <Common/logger_useful.h>\n+#include <Disks/TemporaryFileInPath.h>\n \n #include <filesystem>\n \n@@ -15,7 +16,6 @@ namespace CurrentMetrics\n     extern const Metric TotalTemporaryFiles;\n }\n \n-\n namespace DB\n {\n \ndiff --git a/src/Disks/TemporaryFileOnDisk.h b/src/Disks/TemporaryFileOnDisk.h\nindex 9ba59c3eaf0a..fa3a03832973 100644\n--- a/src/Disks/TemporaryFileOnDisk.h\n+++ b/src/Disks/TemporaryFileOnDisk.h\n@@ -9,21 +9,30 @@ namespace DB\n {\n using DiskPtr = std::shared_ptr<IDisk>;\n \n+class ITemporaryFile\n+{\n+public:\n+    virtual String getPath() const = 0;\n+    virtual ~ITemporaryFile() = default;\n+};\n+\n+using TemporaryFileHolder = std::unique_ptr<ITemporaryFile>;\n+\n /// This class helps with the handling of temporary files or directories.\n /// A unique name for the temporary file or directory is automatically chosen based on a specified prefix.\n /// Create a directory in the constructor.\n /// The destructor always removes the temporary file or directory with all contained files.\n-class TemporaryFileOnDisk\n+class TemporaryFileOnDisk : public ITemporaryFile\n {\n public:\n     explicit TemporaryFileOnDisk(const DiskPtr & disk_);\n     explicit TemporaryFileOnDisk(const DiskPtr & disk_, CurrentMetrics::Value metric_scope);\n     explicit TemporaryFileOnDisk(const DiskPtr & disk_, const String & prefix);\n \n-    ~TemporaryFileOnDisk();\n+    ~TemporaryFileOnDisk() override;\n \n     DiskPtr getDisk() const { return disk; }\n-    String getPath() const;\n+    String getPath() const override;\n \n private:\n     DiskPtr disk;\ndiff --git a/src/Formats/NativeWriter.cpp b/src/Formats/NativeWriter.cpp\nindex c4dea371afd1..e932bb88c2de 100644\n--- a/src/Formats/NativeWriter.cpp\n+++ b/src/Formats/NativeWriter.cpp\n@@ -64,8 +64,10 @@ static void writeData(const ISerialization & serialization, const ColumnPtr & co\n }\n \n \n-void NativeWriter::write(const Block & block)\n+size_t NativeWriter::write(const Block & block)\n {\n+    size_t written_before = ostr.count();\n+\n     /// Additional information about the block.\n     if (client_revision > 0)\n         block.info.write(ostr);\n@@ -161,6 +163,10 @@ void NativeWriter::write(const Block & block)\n \n     if (index)\n         index->blocks.emplace_back(std::move(index_block));\n+\n+    size_t written_after = ostr.count();\n+    size_t written_size = written_after - written_before;\n+    return written_size;\n }\n \n }\ndiff --git a/src/Formats/NativeWriter.h b/src/Formats/NativeWriter.h\nindex 010a03ec722b..7bb377d2e4ae 100644\n--- a/src/Formats/NativeWriter.h\n+++ b/src/Formats/NativeWriter.h\n@@ -27,7 +27,9 @@ class NativeWriter\n         IndexForNativeFormat * index_ = nullptr, size_t initial_size_of_file_ = 0);\n \n     Block getHeader() const { return header; }\n-    void write(const Block & block);\n+\n+    /// Returns the number of bytes written.\n+    size_t write(const Block & block);\n     void flush();\n \n     static String getContentType() { return \"application/octet-stream\"; }\ndiff --git a/src/IO/WriteBufferFromTemporaryFile.cpp b/src/IO/WriteBufferFromTemporaryFile.cpp\nindex f93c79ca5879..4562ad512b3c 100644\n--- a/src/IO/WriteBufferFromTemporaryFile.cpp\n+++ b/src/IO/WriteBufferFromTemporaryFile.cpp\n@@ -13,7 +13,7 @@ namespace ErrorCodes\n }\n \n \n-WriteBufferFromTemporaryFile::WriteBufferFromTemporaryFile(std::unique_ptr<TemporaryFile> && tmp_file_)\n+WriteBufferFromTemporaryFile::WriteBufferFromTemporaryFile(std::unique_ptr<PocoTemporaryFile> && tmp_file_)\n     : WriteBufferFromFile(tmp_file_->path(), DBMS_DEFAULT_BUFFER_SIZE, O_RDWR | O_TRUNC | O_CREAT, 0600), tmp_file(std::move(tmp_file_))\n {}\n \n@@ -40,11 +40,11 @@ class ReadBufferFromTemporaryWriteBuffer : public ReadBufferFromFile\n         return std::make_shared<ReadBufferFromTemporaryWriteBuffer>(fd, file_name, std::move(origin->tmp_file));\n     }\n \n-    ReadBufferFromTemporaryWriteBuffer(int fd_, const std::string & file_name_, std::unique_ptr<TemporaryFile> && tmp_file_)\n+    ReadBufferFromTemporaryWriteBuffer(int fd_, const std::string & file_name_, std::unique_ptr<PocoTemporaryFile> && tmp_file_)\n         : ReadBufferFromFile(fd_, file_name_), tmp_file(std::move(tmp_file_))\n     {}\n \n-    std::unique_ptr<TemporaryFile> tmp_file;\n+    std::unique_ptr<PocoTemporaryFile> tmp_file;\n };\n \n \ndiff --git a/src/IO/WriteBufferFromTemporaryFile.h b/src/IO/WriteBufferFromTemporaryFile.h\nindex 06e2911db260..a4e83b95ac6e 100644\n--- a/src/IO/WriteBufferFromTemporaryFile.h\n+++ b/src/IO/WriteBufferFromTemporaryFile.h\n@@ -20,11 +20,11 @@ class WriteBufferFromTemporaryFile : public WriteBufferFromFile, public IReadabl\n     ~WriteBufferFromTemporaryFile() override;\n \n private:\n-    explicit WriteBufferFromTemporaryFile(std::unique_ptr<TemporaryFile> && tmp_file);\n+    explicit WriteBufferFromTemporaryFile(std::unique_ptr<PocoTemporaryFile> && tmp_file);\n \n     std::shared_ptr<ReadBuffer> getReadBufferImpl() override;\n \n-    std::unique_ptr<TemporaryFile> tmp_file;\n+    std::unique_ptr<PocoTemporaryFile> tmp_file;\n \n     friend class ReadBufferFromTemporaryWriteBuffer;\n };\ndiff --git a/src/Interpreters/Cache/FileCache.cpp b/src/Interpreters/Cache/FileCache.cpp\nindex 72fa1b3c324e..e2a0e839f19e 100644\n--- a/src/Interpreters/Cache/FileCache.cpp\n+++ b/src/Interpreters/Cache/FileCache.cpp\n@@ -2,6 +2,7 @@\n \n #include <Common/randomSeed.h>\n #include <Common/SipHash.h>\n+#include <Common/logger_useful.h>\n #include <Interpreters/Cache/FileCacheSettings.h>\n #include <Interpreters/Cache/LRUFileCachePriority.h>\n #include <IO/ReadHelpers.h>\n@@ -12,6 +13,7 @@\n #include <pcg-random/pcg_random.hpp>\n #include <filesystem>\n \n+\n namespace fs = std::filesystem;\n \n namespace DB\n@@ -46,13 +48,27 @@ FileCache::Key FileCache::hash(const String & path)\n     return Key(sipHash128(path.data(), path.size()));\n }\n \n-String FileCache::getPathInLocalCache(const Key & key, size_t offset, bool is_persistent) const\n+String FileCache::getPathInLocalCache(const Key & key, size_t offset, FileSegmentKind segment_kind) const\n {\n+    String file_suffix;\n+    switch (segment_kind)\n+    {\n+        case FileSegmentKind::Persistent:\n+            file_suffix = \"_persistent\";\n+            break;\n+        case FileSegmentKind::Temporary:\n+            file_suffix = \"_temporary\";\n+            break;\n+        case FileSegmentKind::Regular:\n+            file_suffix = \"\";\n+            break;\n+    }\n+\n     auto key_str = key.toString();\n     return fs::path(cache_base_path)\n         / key_str.substr(0, 3)\n         / key_str\n-        / (std::to_string(offset) + (is_persistent ? \"_persistent\" : \"\"));\n+        / (std::to_string(offset) + file_suffix);\n }\n \n String FileCache::getPathInLocalCache(const Key & key) const\n@@ -540,9 +556,6 @@ FileSegmentPtr FileCache::createFileSegmentForDownload(\n     assertCacheCorrectness(key, cache_lock);\n #endif\n \n-    if (size > max_file_segment_size)\n-        throw Exception(ErrorCodes::REMOTE_FS_OBJECT_CACHE_ERROR, \"Requested size exceeds max file segment size\");\n-\n     auto * cell = getCell(key, offset, cache_lock);\n     if (cell)\n         throw Exception(\n@@ -999,9 +1012,17 @@ void FileCache::loadCacheInfoIntoMemory(std::lock_guard<std::mutex> & cache_lock\n         fs::directory_iterator key_it{key_prefix_it->path()};\n         for (; key_it != fs::directory_iterator(); ++key_it)\n         {\n-            if (!key_it->is_directory())\n+            if (key_it->is_regular_file())\n             {\n-                LOG_DEBUG(log, \"Unexpected file: {}. Expected a directory\", key_it->path().string());\n+                if (key_prefix_it->path().filename() == \"tmp\" && startsWith(key_it->path().filename(), \"tmp\"))\n+                {\n+                    LOG_DEBUG(log, \"Found temporary file '{}', will remove it\", key_it->path().string());\n+                    fs::remove(key_it->path());\n+                }\n+                else\n+                {\n+                    LOG_DEBUG(log, \"Unexpected file: {}. Expected a directory\", key_it->path().string());\n+                }\n                 continue;\n             }\n \n@@ -1009,17 +1030,26 @@ void FileCache::loadCacheInfoIntoMemory(std::lock_guard<std::mutex> & cache_lock\n             fs::directory_iterator offset_it{key_it->path()};\n             for (; offset_it != fs::directory_iterator(); ++offset_it)\n             {\n+                if (offset_it->is_directory())\n+                {\n+                    LOG_DEBUG(log, \"Unexpected directory: {}. Expected a file\", offset_it->path().string());\n+                    continue;\n+                }\n+\n                 auto offset_with_suffix = offset_it->path().filename().string();\n                 auto delim_pos = offset_with_suffix.find('_');\n                 bool parsed;\n-                bool is_persistent = false;\n+                FileSegmentKind segment_kind = FileSegmentKind::Regular;\n \n                 if (delim_pos == std::string::npos)\n                     parsed = tryParse<UInt64>(offset, offset_with_suffix);\n                 else\n                 {\n                     parsed = tryParse<UInt64>(offset, offset_with_suffix.substr(0, delim_pos));\n-                    is_persistent = offset_with_suffix.substr(delim_pos+1) == \"persistent\";\n+                    if (offset_with_suffix.substr(delim_pos+1) == \"persistent\")\n+                        segment_kind = FileSegmentKind::Persistent;\n+                    if (offset_with_suffix.substr(delim_pos+1) == \"temporary\")\n+                        segment_kind = FileSegmentKind::Temporary;\n                 }\n \n                 if (!parsed)\n@@ -1039,7 +1069,7 @@ void FileCache::loadCacheInfoIntoMemory(std::lock_guard<std::mutex> & cache_lock\n                 {\n                     auto * cell = addCell(\n                         key, offset, size, FileSegment::State::DOWNLOADED,\n-                        CreateFileSegmentSettings{ .is_persistent = is_persistent }, cache_lock);\n+                        CreateFileSegmentSettings(segment_kind), cache_lock);\n \n                     if (cell)\n                         queue_entries.emplace_back(cell->queue_iterator, cell->file_segment);\n@@ -1151,7 +1181,7 @@ std::vector<String> FileCache::tryGetCachePaths(const Key & key)\n     for (const auto & [offset, cell] : cells_by_offset)\n     {\n         if (cell.file_segment->state() == FileSegment::State::DOWNLOADED)\n-            cache_paths.push_back(getPathInLocalCache(key, offset, cell.file_segment->isPersistent()));\n+            cache_paths.push_back(getPathInLocalCache(key, offset, cell.file_segment->getKind()));\n     }\n \n     return cache_paths;\n@@ -1173,6 +1203,16 @@ size_t FileCache::getAvailableCacheSizeUnlocked(std::lock_guard<std::mutex> & ca\n     return max_size - getUsedCacheSizeUnlocked(cache_lock);\n }\n \n+size_t FileCache::getTotalMaxSize() const\n+{\n+    return max_size;\n+}\n+\n+size_t FileCache::getTotalMaxElements() const\n+{\n+    return max_element_size;\n+}\n+\n size_t FileCache::getFileSegmentsNum() const\n {\n     std::lock_guard cache_lock(mutex);\ndiff --git a/src/Interpreters/Cache/FileCache.h b/src/Interpreters/Cache/FileCache.h\nindex 706762b69153..4a2610fd76b4 100644\n--- a/src/Interpreters/Cache/FileCache.h\n+++ b/src/Interpreters/Cache/FileCache.h\n@@ -80,7 +80,7 @@ using QueryContextPtr = std::shared_ptr<QueryContext>;\n \n     static Key hash(const String & path);\n \n-    String getPathInLocalCache(const Key & key, size_t offset, bool is_persistent) const;\n+    String getPathInLocalCache(const Key & key, size_t offset, FileSegmentKind segment_kind) const;\n \n     String getPathInLocalCache(const Key & key) const;\n \n@@ -89,8 +89,10 @@ using QueryContextPtr = std::shared_ptr<QueryContext>;\n     size_t capacity() const { return max_size; }\n \n     size_t getUsedCacheSize() const;\n+    size_t getTotalMaxSize() const;\n \n     size_t getFileSegmentsNum() const;\n+    size_t getTotalMaxElements() const;\n \n     static bool isReadOnly();\n \n@@ -221,6 +223,8 @@ using QueryContextPtr = std::shared_ptr<QueryContext>;\n \n     FileSegmentCell * getCell(const Key & key, size_t offset, std::lock_guard<std::mutex> & cache_lock);\n \n+    /// Returns non-owened pointer to the cell stored in the `files` map.\n+    /// Doesn't reserve any space.\n     FileSegmentCell * addCell(\n         const Key & key,\n         size_t offset,\ndiff --git a/src/Interpreters/Cache/FileCacheFactory.cpp b/src/Interpreters/Cache/FileCacheFactory.cpp\nindex b276760c0dd4..e120fe3fc277 100644\n--- a/src/Interpreters/Cache/FileCacheFactory.cpp\n+++ b/src/Interpreters/Cache/FileCacheFactory.cpp\n@@ -31,14 +31,21 @@ const FileCacheSettings & FileCacheFactory::getSettings(const std::string & cach\n \n }\n \n-FileCachePtr FileCacheFactory::get(const std::string & cache_base_path)\n+FileCachePtr FileCacheFactory::tryGet(const std::string & cache_base_path)\n {\n     std::lock_guard lock(mutex);\n     auto it = caches_by_path.find(cache_base_path);\n     if (it == caches_by_path.end())\n-        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"No cache found by path: {}\", cache_base_path);\n+        return nullptr;\n     return it->second->cache;\n+}\n \n+FileCachePtr FileCacheFactory::get(const std::string & cache_base_path)\n+{\n+    auto file_cache_ptr = tryGet(cache_base_path);\n+    if (!file_cache_ptr)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"No cache found by path: {}\", cache_base_path);\n+    return file_cache_ptr;\n }\n \n FileCachePtr FileCacheFactory::getOrCreate(\ndiff --git a/src/Interpreters/Cache/FileCacheFactory.h b/src/Interpreters/Cache/FileCacheFactory.h\nindex 82e0ec8f9282..32ecd05f019d 100644\n--- a/src/Interpreters/Cache/FileCacheFactory.h\n+++ b/src/Interpreters/Cache/FileCacheFactory.h\n@@ -33,6 +33,7 @@ class FileCacheFactory final : private boost::noncopyable\n \n     FileCachePtr getOrCreate(const std::string & cache_base_path, const FileCacheSettings & file_cache_settings, const std::string & name);\n \n+    FileCachePtr tryGet(const std::string & cache_base_path);\n     FileCachePtr get(const std::string & cache_base_path);\n \n     CacheByBasePath getAll();\ndiff --git a/src/Interpreters/Cache/FileSegment.cpp b/src/Interpreters/Cache/FileSegment.cpp\nindex 418bcee05d94..e070317e454c 100644\n--- a/src/Interpreters/Cache/FileSegment.cpp\n+++ b/src/Interpreters/Cache/FileSegment.cpp\n@@ -23,6 +23,19 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+String toString(FileSegmentKind type)\n+{\n+    switch (type)\n+    {\n+        case FileSegmentKind::Regular:\n+            return \"Regular\";\n+        case FileSegmentKind::Persistent:\n+            return \"Persistent\";\n+        case FileSegmentKind::Temporary:\n+            return \"Temporary\";\n+    }\n+}\n+\n FileSegment::FileSegment(\n         size_t offset_,\n         size_t size_,\n@@ -39,7 +52,7 @@ FileSegment::FileSegment(\n #else\n     , log(&Poco::Logger::get(\"FileSegment\"))\n #endif\n-    , is_persistent(settings.is_persistent)\n+    , segment_kind(settings.type)\n {\n     /// On creation, file segment state can be EMPTY, DOWNLOADED, DOWNLOADING.\n     switch (download_state)\n@@ -73,7 +86,8 @@ FileSegment::FileSegment(\n \n String FileSegment::getPathInLocalCache() const\n {\n-    return cache->getPathInLocalCache(key(), offset(), isPersistent());\n+    chassert(cache);\n+    return cache->getPathInLocalCache(key(), offset(), segment_kind);\n }\n \n FileSegment::State FileSegment::state() const\n@@ -309,7 +323,7 @@ void FileSegment::write(const char * from, size_t size, size_t offset)\n         if (current_downloaded_size == range().size())\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"File segment is already fully downloaded\");\n \n-        if (!cache_writer)\n+        if (!cache_writer && from != nullptr)\n         {\n             if (current_downloaded_size > 0)\n                 throw Exception(\n@@ -324,11 +338,14 @@ void FileSegment::write(const char * from, size_t size, size_t offset)\n \n     try\n     {\n-        cache_writer->write(from, size);\n+        /// if `from` is nullptr, then we just allocate and hold space by current segment and it was (or would) be written outside\n+        if (cache_writer && from != nullptr)\n+            cache_writer->write(from, size);\n \n         std::unique_lock download_lock(download_mutex);\n \n-        cache_writer->next();\n+        if (cache_writer && from != nullptr)\n+            cache_writer->next();\n \n         downloaded_size += size;\n     }\n@@ -379,6 +396,13 @@ FileSegment::State FileSegment::wait()\n }\n \n bool FileSegment::reserve(size_t size_to_reserve)\n+{\n+    size_t reserved = tryReserve(size_to_reserve, true);\n+    assert(reserved == 0 || reserved == size_to_reserve);\n+    return reserved == size_to_reserve;\n+}\n+\n+size_t FileSegment::tryReserve(size_t size_to_reserve, bool strict)\n {\n     if (!size_to_reserve)\n         throw Exception(ErrorCodes::REMOTE_FS_OBJECT_CACHE_ERROR, \"Zero space reservation is not allowed\");\n@@ -394,10 +418,16 @@ bool FileSegment::reserve(size_t size_to_reserve)\n         expected_downloaded_size = getDownloadedSizeUnlocked(segment_lock);\n \n         if (expected_downloaded_size + size_to_reserve > range().size())\n-            throw Exception(\n-                ErrorCodes::REMOTE_FS_OBJECT_CACHE_ERROR,\n-                \"Attempt to reserve space too much space ({}) for file segment with range: {} (downloaded size: {})\",\n-                size_to_reserve, range().toString(), downloaded_size);\n+        {\n+            if (strict)\n+            {\n+                throw Exception(\n+                    ErrorCodes::REMOTE_FS_OBJECT_CACHE_ERROR,\n+                    \"Attempt to reserve space too much space ({}) for file segment with range: {} (downloaded size: {})\",\n+                    size_to_reserve, range().toString(), downloaded_size);\n+            }\n+            size_to_reserve = range().size() - expected_downloaded_size;\n+        }\n \n         chassert(reserved_size >= expected_downloaded_size);\n     }\n@@ -415,17 +445,16 @@ bool FileSegment::reserve(size_t size_to_reserve)\n     {\n         std::lock_guard cache_lock(cache->mutex);\n \n-        size_to_reserve = size_to_reserve - already_reserved_size;\n-        reserved = cache->tryReserve(key(), offset(), size_to_reserve, cache_lock);\n+        size_t need_to_reserve = size_to_reserve - already_reserved_size;\n+        reserved = cache->tryReserve(key(), offset(), need_to_reserve, cache_lock);\n \n-        if (reserved)\n-        {\n-            std::lock_guard segment_lock(mutex);\n-            reserved_size += size_to_reserve;\n-        }\n-    }\n+        if (!reserved)\n+            return 0;\n \n-    return reserved;\n+        std::lock_guard segment_lock(mutex);\n+        reserved_size += need_to_reserve;\n+    }\n+    return size_to_reserve;\n }\n \n void FileSegment::setDownloadedUnlocked([[maybe_unused]] std::unique_lock<std::mutex> & segment_lock)\n@@ -545,6 +574,15 @@ void FileSegment::completeBasedOnCurrentState(std::lock_guard<std::mutex> & cach\n         resetDownloaderUnlocked(segment_lock);\n     }\n \n+    if (segment_kind == FileSegmentKind::Temporary && is_last_holder)\n+    {\n+        LOG_TEST(log, \"Removing temporary file segment: {}\", getInfoForLogUnlocked(segment_lock));\n+        detach(cache_lock, segment_lock);\n+        setDownloadState(State::SKIP_CACHE);\n+        cache->remove(key(), offset(), cache_lock, segment_lock);\n+        return;\n+    }\n+\n     switch (download_state)\n     {\n         case State::SKIP_CACHE:\n@@ -626,7 +664,7 @@ String FileSegment::getInfoForLogUnlocked(std::unique_lock<std::mutex> & segment\n     info << \"first non-downloaded offset: \" << getFirstNonDownloadedOffsetUnlocked(segment_lock) << \", \";\n     info << \"caller id: \" << getCallerId() << \", \";\n     info << \"detached: \" << is_detached << \", \";\n-    info << \"persistent: \" << is_persistent;\n+    info << \"kind: \" << toString(segment_kind);\n \n     return info.str();\n }\n@@ -721,7 +759,7 @@ FileSegmentPtr FileSegment::getSnapshot(const FileSegmentPtr & file_segment, std\n     snapshot->ref_count = file_segment.use_count();\n     snapshot->downloaded_size = file_segment->getDownloadedSizeUnlocked(segment_lock);\n     snapshot->download_state = file_segment->download_state;\n-    snapshot->is_persistent = file_segment->isPersistent();\n+    snapshot->segment_kind = file_segment->getKind();\n \n     return snapshot;\n }\n@@ -783,6 +821,8 @@ FileSegmentsHolder::~FileSegmentsHolder()\n         if (!cache)\n             cache = file_segment->cache;\n \n+        assert(cache == file_segment->cache); /// all segments should belong to the same cache\n+\n         try\n         {\n             bool is_detached = false;\ndiff --git a/src/Interpreters/Cache/FileSegment.h b/src/Interpreters/Cache/FileSegment.h\nindex 8f9c0097d779..8915b2f0a36e 100644\n--- a/src/Interpreters/Cache/FileSegment.h\n+++ b/src/Interpreters/Cache/FileSegment.h\n@@ -30,9 +30,38 @@ using FileSegmentPtr = std::shared_ptr<FileSegment>;\n using FileSegments = std::list<FileSegmentPtr>;\n \n \n+/*\n+ * FileSegmentKind is used to specify the eviction policy for file segments.\n+ */\n+enum class FileSegmentKind\n+{\n+    /* `Regular` file segment is still in cache after usage, and can be evicted\n+     * (unless there're some holders).\n+     */\n+    Regular,\n+\n+    /* `Persistent` file segment can't be evicted from cache,\n+     * it should be removed manually.\n+     */\n+    Persistent,\n+\n+    /* `Temporary` file segment is removed right after relesing.\n+     * Also corresponding files are removed during cache loading (if any).\n+     */\n+    Temporary,\n+};\n+\n+String toString(FileSegmentKind type);\n+\n struct CreateFileSegmentSettings\n {\n-    bool is_persistent = false;\n+    FileSegmentKind type = FileSegmentKind::Regular;\n+\n+    CreateFileSegmentSettings() = default;\n+\n+    explicit CreateFileSegmentSettings(FileSegmentKind type_)\n+        : type(type_)\n+    {}\n };\n \n class FileSegment : private boost::noncopyable, public std::enable_shared_from_this<FileSegment>\n@@ -127,7 +156,8 @@ friend class StorageSystemFilesystemCache;\n \n     size_t offset() const { return range().left; }\n \n-    bool isPersistent() const { return is_persistent; }\n+    FileSegmentKind getKind() const { return segment_kind; }\n+    bool isPersistent() const { return segment_kind == FileSegmentKind::Persistent; }\n \n     using UniqueId = std::pair<FileCacheKey, size_t>;\n     UniqueId getUniqueId() const { return std::pair(key(), offset()); }\n@@ -183,19 +213,19 @@ friend class StorageSystemFilesystemCache;\n \n     void assertCorrectness() const;\n \n-    /**\n-     * ========== Methods for _only_ file segment's `writer` ======================\n-     */\n-\n-    void synchronousWrite(const char * from, size_t size, size_t offset);\n-\n     /**\n      * ========== Methods for _only_ file segment's `downloader` ==================\n      */\n \n     /// Try to reserve exactly `size` bytes.\n+    /// Returns true if reservation was successful, false otherwise.\n     bool reserve(size_t size_to_reserve);\n \n+    /// Try to reserve at max `size` bytes.\n+    /// Returns actual size reserved.\n+    /// In strict mode throws an error on attempt to reserve space too much space\n+    size_t tryReserve(size_t size_to_reserve, bool strict = false);\n+\n     /// Write data into reserved space.\n     void write(const char * from, size_t size, size_t offset);\n \n@@ -247,9 +277,9 @@ friend class StorageSystemFilesystemCache;\n     void assertIsDownloaderUnlocked(const std::string & operation, std::unique_lock<std::mutex> & segment_lock) const;\n     void assertCorrectnessUnlocked(std::unique_lock<std::mutex> & segment_lock) const;\n \n-    /// complete() without any completion state is called from destructor of\n-    /// FileSegmentsHolder. complete() might check if the caller of the method\n-    /// is the last alive holder of the segment. Therefore, complete() and destruction\n+    /// completeWithoutStateUnlocked() is called from destructor of FileSegmentsHolder.\n+    /// Function might check if the caller of the method\n+    /// is the last alive holder of the segment. Therefore, completion and destruction\n     /// of the file segment pointer must be done under the same cache mutex.\n     void completeWithoutStateUnlocked(std::lock_guard<std::mutex> & cache_lock);\n     void completeBasedOnCurrentState(std::lock_guard<std::mutex> & cache_lock, std::unique_lock<std::mutex> & segment_lock);\n@@ -295,12 +325,12 @@ friend class StorageSystemFilesystemCache;\n     /// In general case, all file segments are owned by cache.\n     bool is_detached = false;\n \n-    bool is_downloaded{false};\n+    bool is_downloaded = false;\n \n     std::atomic<size_t> hits_count = 0; /// cache hits.\n     std::atomic<size_t> ref_count = 0; /// Used for getting snapshot state\n \n-    bool is_persistent;\n+    FileSegmentKind segment_kind;\n \n     CurrentMetrics::Increment metric_increment{CurrentMetrics::CacheFileSegments};\n };\n@@ -313,6 +343,8 @@ struct FileSegmentsHolder : private boost::noncopyable\n \n     FileSegmentsHolder(FileSegmentsHolder && other) noexcept : file_segments(std::move(other.file_segments)) {}\n \n+    void reset() { file_segments.clear(); }\n+\n     ~FileSegmentsHolder();\n \n     String toString();\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 913b0535358d..796b93998a97 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -32,6 +32,7 @@\n #include <Storages/StorageS3Settings.h>\n #include <Disks/DiskLocal.h>\n #include <Disks/DiskDecorator.h>\n+#include <Disks/ObjectStorages/DiskObjectStorage.h>\n #include <Disks/ObjectStorages/IObjectStorage.h>\n #include <Disks/IO/ThreadPoolRemoteFSReader.h>\n #include <Disks/IO/ThreadPoolReader.h>\n@@ -102,6 +103,7 @@\n #include <Interpreters/Lemmatizers.h>\n #include <Interpreters/ClusterDiscovery.h>\n #include <Interpreters/TransactionLog.h>\n+#include <Interpreters/Cache/FileCacheFactory.h>\n #include <filesystem>\n #include <re2/re2.h>\n \n@@ -746,29 +748,66 @@ void Context::setPath(const String & path)\n         shared->user_scripts_path = shared->path + \"user_scripts/\";\n }\n \n-VolumePtr Context::setTemporaryStorage(const String & path, const String & policy_name, size_t max_size)\n+static void setupTmpPath(Poco::Logger * log, const std::string & path)\n+try\n {\n-    std::lock_guard lock(shared->storage_policies_mutex);\n-    VolumePtr volume;\n+    LOG_DEBUG(log, \"Setting up {} to store temporary data in it\", path);\n \n-    if (policy_name.empty())\n-    {\n-        shared->tmp_path = path;\n-        if (!shared->tmp_path.ends_with('/'))\n-            shared->tmp_path += '/';\n+    fs::create_directories(path);\n \n-        auto disk = std::make_shared<DiskLocal>(\"_tmp_default\", shared->tmp_path, 0);\n-        volume = std::make_shared<SingleDiskVolume>(\"_tmp_default\", disk, 0);\n+    /// Clearing old temporary files.\n+    fs::directory_iterator dir_end;\n+    for (fs::directory_iterator it(path); it != dir_end; ++it)\n+    {\n+        if (it->is_regular_file() && startsWith(it->path().filename(), \"tmp\"))\n+        {\n+            LOG_DEBUG(log, \"Removing old temporary file {}\", it->path().string());\n+            fs::remove(it->path());\n+        }\n+        else\n+            LOG_DEBUG(log, \"Found unknown file in temporary path {}\", it->path().string());\n     }\n-    else\n+}\n+catch (...)\n+{\n+    DB::tryLogCurrentException(log, fmt::format(\n+        \"Caught exception while setup temporary path: {}. \"\n+        \"It is ok to skip this exception as cleaning old temporary files is not necessary\", path));\n+}\n+\n+static VolumePtr createLocalSingleDiskVolume(const std::string & path)\n+{\n+    auto disk = std::make_shared<DiskLocal>(\"_tmp_default\", path, 0);\n+    VolumePtr volume = std::make_shared<SingleDiskVolume>(\"_tmp_default\", disk, 0);\n+    return volume;\n+}\n+\n+void Context::setTemporaryStoragePath(const String & path, size_t max_size)\n+{\n+    shared->tmp_path = path;\n+    if (!shared->tmp_path.ends_with('/'))\n+        shared->tmp_path += '/';\n+\n+    VolumePtr volume = createLocalSingleDiskVolume(shared->tmp_path);\n+\n+    for (const auto & disk : volume->getDisks())\n     {\n-        StoragePolicyPtr tmp_policy = getStoragePolicySelector(lock)->get(policy_name);\n-        if (tmp_policy->getVolumes().size() != 1)\n-             throw Exception(ErrorCodes::NO_ELEMENTS_IN_CONFIG,\n-                \"Policy '{}' is used temporary files, such policy should have exactly one volume\", policy_name);\n-        volume = tmp_policy->getVolume(0);\n+        setupTmpPath(shared->log, disk->getPath());\n     }\n \n+    shared->temp_data_on_disk = std::make_shared<TemporaryDataOnDiskScope>(volume, nullptr, max_size);\n+}\n+\n+void Context::setTemporaryStoragePolicy(const String & policy_name, size_t max_size)\n+{\n+    std::lock_guard lock(shared->storage_policies_mutex);\n+\n+     StoragePolicyPtr tmp_policy = getStoragePolicySelector(lock)->get(policy_name);\n+    if (tmp_policy->getVolumes().size() != 1)\n+            throw Exception(ErrorCodes::NO_ELEMENTS_IN_CONFIG,\n+            \"Policy '{}' is used temporary files, such policy should have exactly one volume\", policy_name);\n+    VolumePtr volume = tmp_policy->getVolume(0);\n+\n     if (volume->getDisks().empty())\n          throw Exception(\"No disks volume for temporary files\", ErrorCodes::NO_ELEMENTS_IN_CONFIG);\n \n@@ -789,10 +828,33 @@ VolumePtr Context::setTemporaryStorage(const String & path, const String & polic\n                 \"Disk '{}' ({}) is not local and can't be used for temporary files\",\n                 disk_ptr->getName(), typeid(*disk_raw_ptr).name());\n         }\n+\n+        setupTmpPath(shared->log, disk->getPath());\n     }\n \n-    shared->temp_data_on_disk = std::make_shared<TemporaryDataOnDiskScope>(volume, max_size);\n-    return volume;\n+    shared->temp_data_on_disk = std::make_shared<TemporaryDataOnDiskScope>(volume, nullptr, max_size);\n+}\n+\n+\n+void Context::setTemporaryStorageInCache(const String & cache_disk_name, size_t max_size)\n+{\n+    auto disk_ptr = getDisk(cache_disk_name);\n+    if (!disk_ptr)\n+        throw Exception(ErrorCodes::NO_ELEMENTS_IN_CONFIG, \"Disk '{}' is not found\", cache_disk_name);\n+\n+    const auto * disk_object_storage_ptr = dynamic_cast<const DiskObjectStorage *>(disk_ptr.get());\n+    if (!disk_object_storage_ptr)\n+        throw Exception(ErrorCodes::NO_ELEMENTS_IN_CONFIG, \"Disk '{}' does not use cache\", cache_disk_name);\n+\n+    auto file_cache = disk_object_storage_ptr->getCache();\n+    if (!file_cache)\n+        throw Exception(ErrorCodes::NO_ELEMENTS_IN_CONFIG, \"Cache '{}' is not found\", file_cache->getBasePath());\n+\n+    LOG_DEBUG(shared->log, \"Using file cache ({}) for temporary files\", file_cache->getBasePath());\n+\n+    shared->tmp_path = file_cache->getBasePath();\n+    VolumePtr volume = createLocalSingleDiskVolume(shared->tmp_path);\n+    shared->temp_data_on_disk = std::make_shared<TemporaryDataOnDiskScope>(volume, file_cache.get(), max_size);\n }\n \n void Context::setFlagsPath(const String & path)\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex bc89ce36edca..2c3122e41091 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -461,7 +461,9 @@ class Context: public std::enable_shared_from_this<Context>\n \n     void addWarningMessage(const String & msg) const;\n \n-    VolumePtr setTemporaryStorage(const String & path, const String & policy_name, size_t max_size);\n+    void setTemporaryStorageInCache(const String & cache_disk_name, size_t max_size);\n+    void setTemporaryStoragePolicy(const String & policy_name, size_t max_size);\n+    void setTemporaryStoragePath(const String & path, size_t max_size);\n \n     using ConfigurationPtr = Poco::AutoPtr<Poco::Util::AbstractConfiguration>;\n \ndiff --git a/src/Interpreters/TemporaryDataOnDisk.cpp b/src/Interpreters/TemporaryDataOnDisk.cpp\nindex c5ae6f6c8856..a039053b011f 100644\n--- a/src/Interpreters/TemporaryDataOnDisk.cpp\n+++ b/src/Interpreters/TemporaryDataOnDisk.cpp\n@@ -7,6 +7,7 @@\n #include <Formats/NativeWriter.h>\n #include <Formats/NativeReader.h>\n #include <Core/ProtocolDefines.h>\n+#include <Disks/TemporaryFileInPath.h>\n \n #include <Common/logger_useful.h>\n \n@@ -35,35 +36,32 @@ void TemporaryDataOnDiskScope::deltaAllocAndCheck(ssize_t compressed_delta, ssiz\n \n     size_t new_consumprion = stat.compressed_size + compressed_delta;\n     if (compressed_delta > 0 && limit && new_consumprion > limit)\n-        throw Exception(ErrorCodes::TOO_MANY_ROWS_OR_BYTES, \"Limit for temporary files size exceeded\");\n+        throw Exception(ErrorCodes::TOO_MANY_ROWS_OR_BYTES,\n+            \"Limit for temporary files size exceeded (would consume {} / {} bytes)\", new_consumprion, limit);\n \n     stat.compressed_size += compressed_delta;\n     stat.uncompressed_size += uncompressed_delta;\n }\n \n+VolumePtr TemporaryDataOnDiskScope::getVolume() const\n+{\n+    if (!volume)\n+        throw Exception(\"TemporaryDataOnDiskScope has no volume\", ErrorCodes::LOGICAL_ERROR);\n+    return volume;\n+}\n+\n TemporaryFileStream & TemporaryDataOnDisk::createStream(const Block & header, size_t max_file_size)\n {\n-    DiskPtr disk;\n-    if (max_file_size > 0)\n-    {\n-        auto reservation = volume->reserve(max_file_size);\n-        if (!reservation)\n-            throw Exception(\"Not enough space on temporary disk\", ErrorCodes::NOT_ENOUGH_SPACE);\n-        disk = reservation->getDisk();\n-    }\n+    TemporaryFileStreamPtr tmp_stream;\n+    if (cache)\n+        tmp_stream = TemporaryFileStream::create(cache, header, max_file_size, this);\n     else\n-    {\n-        disk = volume->getDisk();\n-    }\n-\n-    auto tmp_file = std::make_unique<TemporaryFileOnDisk>(disk, current_metric_scope);\n+        tmp_stream = TemporaryFileStream::create(volume, header, max_file_size, this);\n \n     std::lock_guard lock(mutex);\n-    TemporaryFileStreamPtr & tmp_stream = streams.emplace_back(std::make_unique<TemporaryFileStream>(std::move(tmp_file), header, this));\n-    return *tmp_stream;\n+    return *streams.emplace_back(std::move(tmp_stream));\n }\n \n-\n std::vector<TemporaryFileStream *> TemporaryDataOnDisk::getStreams() const\n {\n     std::vector<TemporaryFileStream *> res;\n@@ -89,12 +87,13 @@ struct TemporaryFileStream::OutputWriter\n     {\n     }\n \n-    void write(const Block & block)\n+    size_t write(const Block & block)\n     {\n         if (finalized)\n             throw Exception(\"Cannot write to finalized stream\", ErrorCodes::LOGICAL_ERROR);\n-        out_writer.write(block);\n+        size_t written_bytes = out_writer.write(block);\n         num_rows += block.rows();\n+        return written_bytes;\n     }\n \n     void finalize()\n@@ -155,21 +154,68 @@ struct TemporaryFileStream::InputReader\n     NativeReader in_reader;\n };\n \n-TemporaryFileStream::TemporaryFileStream(TemporaryFileOnDiskHolder file_, const Block & header_, TemporaryDataOnDisk * parent_)\n+TemporaryFileStreamPtr TemporaryFileStream::create(const VolumePtr & volume, const Block & header, size_t max_file_size, TemporaryDataOnDisk * parent_)\n+{\n+    if (!volume)\n+        throw Exception(\"TemporaryDataOnDiskScope has no volume\", ErrorCodes::LOGICAL_ERROR);\n+\n+    DiskPtr disk;\n+    if (max_file_size > 0)\n+    {\n+        auto reservation = volume->reserve(max_file_size);\n+        if (!reservation)\n+            throw Exception(\"Not enough space on temporary disk\", ErrorCodes::NOT_ENOUGH_SPACE);\n+        disk = reservation->getDisk();\n+    }\n+    else\n+    {\n+        disk = volume->getDisk();\n+    }\n+\n+    auto tmp_file = std::make_unique<TemporaryFileOnDisk>(disk, parent_->getMetricScope());\n+    return std::make_unique<TemporaryFileStream>(std::move(tmp_file), header, /* cache_placeholder */ nullptr, /* parent */ parent_);\n+}\n+\n+TemporaryFileStreamPtr TemporaryFileStream::create(FileCache * cache, const Block & header, size_t max_file_size, TemporaryDataOnDisk * parent_)\n+{\n+    auto tmp_file = std::make_unique<TemporaryFileInPath>(fs::path(cache->getBasePath()) / \"tmp\");\n+\n+    auto cache_placeholder = std::make_unique<FileCachePlaceholder>(cache, tmp_file->getPath());\n+    cache_placeholder->reserveCapacity(max_file_size);\n+\n+    return std::make_unique<TemporaryFileStream>(std::move(tmp_file), header, std::move(cache_placeholder), parent_);\n+}\n+\n+TemporaryFileStream::TemporaryFileStream(\n+    TemporaryFileHolder file_,\n+    const Block & header_,\n+    std::unique_ptr<ISpacePlaceholder> space_holder_,\n+    TemporaryDataOnDisk * parent_)\n     : parent(parent_)\n     , header(header_)\n     , file(std::move(file_))\n+    , space_holder(std::move(space_holder_))\n     , out_writer(std::make_unique<OutputWriter>(file->getPath(), header))\n {\n }\n \n-void TemporaryFileStream::write(const Block & block)\n+size_t TemporaryFileStream::write(const Block & block)\n {\n     if (!out_writer)\n         throw Exception(\"Writing has been finished\", ErrorCodes::LOGICAL_ERROR);\n \n+    size_t block_size_in_memory = block.bytes();\n+\n+    if (space_holder)\n+        space_holder->reserveCapacity(block_size_in_memory);\n+\n     updateAllocAndCheck();\n-    out_writer->write(block);\n+\n+    size_t bytes_written = out_writer->write(block);\n+    if (space_holder)\n+        space_holder->setUsed(bytes_written);\n+\n+    return bytes_written;\n }\n \n TemporaryFileStream::Stat TemporaryFileStream::finishWriting()\ndiff --git a/src/Interpreters/TemporaryDataOnDisk.h b/src/Interpreters/TemporaryDataOnDisk.h\nindex 11edc8700d20..2790529754f7 100644\n--- a/src/Interpreters/TemporaryDataOnDisk.h\n+++ b/src/Interpreters/TemporaryDataOnDisk.h\n@@ -6,6 +6,7 @@\n #include <Disks/TemporaryFileOnDisk.h>\n #include <Disks/IVolume.h>\n #include <Common/CurrentMetrics.h>\n+#include <Disks/IO/FileCachePlaceholder.h>\n \n \n namespace CurrentMetrics\n@@ -40,23 +41,25 @@ class TemporaryDataOnDiskScope : boost::noncopyable\n         std::atomic<size_t> uncompressed_size;\n     };\n \n-    explicit TemporaryDataOnDiskScope(VolumePtr volume_, size_t limit_)\n-        : volume(std::move(volume_)), limit(limit_)\n+    explicit TemporaryDataOnDiskScope(VolumePtr volume_, FileCache * cache_, size_t limit_)\n+        : volume(std::move(volume_)), cache(cache_), limit(limit_)\n     {}\n \n     explicit TemporaryDataOnDiskScope(TemporaryDataOnDiskScopePtr parent_, size_t limit_)\n-        : parent(std::move(parent_)), volume(parent->volume), limit(limit_)\n+        : parent(std::move(parent_)), volume(parent->volume), cache(parent->cache), limit(limit_)\n     {}\n \n     /// TODO: remove\n     /// Refactor all code that uses volume directly to use TemporaryDataOnDisk.\n-    VolumePtr getVolume() const { return volume; }\n+    VolumePtr getVolume() const;\n \n protected:\n     void deltaAllocAndCheck(ssize_t compressed_delta, ssize_t uncompressed_delta);\n \n     TemporaryDataOnDiskScopePtr parent = nullptr;\n+\n     VolumePtr volume;\n+    FileCache * cache = nullptr;\n \n     StatAtomic stat;\n     size_t limit = 0;\n@@ -91,6 +94,7 @@ class TemporaryDataOnDisk : private TemporaryDataOnDiskScope\n     bool empty() const;\n \n     const StatAtomic & getStat() const { return stat; }\n+    CurrentMetrics::Value getMetricScope() const { return current_metric_scope; }\n \n private:\n     mutable std::mutex mutex;\n@@ -116,9 +120,14 @@ class TemporaryFileStream : boost::noncopyable\n         size_t num_rows = 0;\n     };\n \n-    TemporaryFileStream(TemporaryFileOnDiskHolder file_, const Block & header_, TemporaryDataOnDisk * parent_);\n+    static TemporaryFileStreamPtr create(const VolumePtr & volume, const Block & header, size_t max_file_size, TemporaryDataOnDisk * parent_);\n+    static TemporaryFileStreamPtr create(FileCache * cache, const Block & header, size_t max_file_size, TemporaryDataOnDisk * parent_);\n+\n+    TemporaryFileStream(TemporaryFileHolder file_, const Block & header_, std::unique_ptr<ISpacePlaceholder> space_holder, TemporaryDataOnDisk * parent_);\n+\n+    /// Returns number of written bytes\n+    size_t write(const Block & block);\n \n-    void write(const Block & block);\n     Stat finishWriting();\n     bool isWriteFinished() const;\n \n@@ -142,7 +151,8 @@ class TemporaryFileStream : boost::noncopyable\n \n     Block header;\n \n-    TemporaryFileOnDiskHolder file;\n+    TemporaryFileHolder file;\n+    std::unique_ptr<ISpacePlaceholder> space_holder;\n \n     Stat stat;\n \ndiff --git a/src/Storages/MergeTree/MergeTask.h b/src/Storages/MergeTree/MergeTask.h\nindex 6a29cdbb5ca8..2b8d9055cff8 100644\n--- a/src/Storages/MergeTree/MergeTask.h\n+++ b/src/Storages/MergeTree/MergeTask.h\n@@ -192,7 +192,7 @@ class MergeTask\n         bool force_ttl{false};\n         CompressionCodecPtr compression_codec{nullptr};\n         size_t sum_input_rows_upper_bound{0};\n-        std::unique_ptr<TemporaryFile> rows_sources_file{nullptr};\n+        std::unique_ptr<PocoTemporaryFile> rows_sources_file{nullptr};\n         std::unique_ptr<WriteBufferFromFileBase> rows_sources_uncompressed_write_buf{nullptr};\n         std::unique_ptr<WriteBuffer> rows_sources_write_buf{nullptr};\n         std::optional<ColumnSizeEstimator> column_sizes{};\n@@ -257,7 +257,7 @@ class MergeTask\n         /// Begin dependencies from previous stage\n         std::unique_ptr<WriteBuffer> rows_sources_write_buf{nullptr};\n         std::unique_ptr<WriteBufferFromFileBase> rows_sources_uncompressed_write_buf{nullptr};\n-        std::unique_ptr<TemporaryFile> rows_sources_file;\n+        std::unique_ptr<PocoTemporaryFile> rows_sources_file;\n         std::optional<ColumnSizeEstimator> column_sizes;\n         CompressionCodecPtr compression_codec;\n         DiskPtr tmp_disk{nullptr};\ndiff --git a/src/Storages/System/StorageSystemFilesystemCache.cpp b/src/Storages/System/StorageSystemFilesystemCache.cpp\nindex cd9324b32534..bec92a604360 100644\n--- a/src/Storages/System/StorageSystemFilesystemCache.cpp\n+++ b/src/Storages/System/StorageSystemFilesystemCache.cpp\n@@ -24,7 +24,8 @@ NamesAndTypesList StorageSystemFilesystemCache::getNamesAndTypes()\n         {\"cache_hits\", std::make_shared<DataTypeUInt64>()},\n         {\"references\", std::make_shared<DataTypeUInt64>()},\n         {\"downloaded_size\", std::make_shared<DataTypeUInt64>()},\n-        {\"persistent\", std::make_shared<DataTypeNumber<UInt8>>()}\n+        {\"persistent\", std::make_shared<DataTypeNumber<UInt8>>()},\n+        {\"kind\", std::make_shared<DataTypeString>()},\n     };\n }\n \n@@ -45,8 +46,11 @@ void StorageSystemFilesystemCache::fillData(MutableColumns & res_columns, Contex\n         for (const auto & file_segment : file_segments)\n         {\n             res_columns[0]->insert(cache_base_path);\n+\n+            /// Do not use `file_segment->getPathInLocalCache` here because it will lead to nullptr dereference\n+            /// (because file_segments in getSnapshot doesn't have `cache` field set)\n             res_columns[1]->insert(\n-                cache->getPathInLocalCache(file_segment->key(), file_segment->offset(), file_segment->isPersistent()));\n+                cache->getPathInLocalCache(file_segment->key(), file_segment->offset(), file_segment->getKind()));\n \n             const auto & range = file_segment->range();\n             res_columns[2]->insert(range.left);\n@@ -57,6 +61,7 @@ void StorageSystemFilesystemCache::fillData(MutableColumns & res_columns, Contex\n             res_columns[7]->insert(file_segment->getRefCount());\n             res_columns[8]->insert(file_segment->getDownloadedSize());\n             res_columns[9]->insert(file_segment->isPersistent());\n+            res_columns[10]->insert(toString(file_segment->getKind()));\n         }\n     }\n }\n",
  "test_patch": "diff --git a/src/Interpreters/tests/gtest_lru_file_cache.cpp b/src/Interpreters/tests/gtest_lru_file_cache.cpp\nindex 22150b9f6565..2d408bd9b34e 100644\n--- a/src/Interpreters/tests/gtest_lru_file_cache.cpp\n+++ b/src/Interpreters/tests/gtest_lru_file_cache.cpp\n@@ -6,6 +6,7 @@\n #include <Common/CurrentThread.h>\n #include <Common/filesystemHelpers.h>\n #include <Interpreters/Cache/FileCacheSettings.h>\n+#include <Interpreters/TemporaryDataOnDisk.h>\n #include <Common/tests/gtest_global_context.h>\n #include <Common/SipHash.h>\n #include <Common/hex.h>\n@@ -14,11 +15,14 @@\n #include <IO/WriteHelpers.h>\n #include <filesystem>\n #include <thread>\n+#include <DataTypes/DataTypesNumber.h>\n+\n+#include <Disks/IO/CachedOnDiskWriteBufferFromFile.h>\n \n namespace fs = std::filesystem;\n+using namespace DB;\n \n-fs::path caches_dir = fs::current_path() / \"lru_cache_test\";\n-String cache_base_path = caches_dir / \"cache1\" / \"\";\n+static constexpr auto TEST_LOG_LEVEL = \"debug\";\n \n void assertRange(\n     [[maybe_unused]] size_t assert_n, DB::FileSegmentPtr file_segment,\n@@ -53,7 +57,7 @@ String getFileSegmentPath(const String & base_path, const DB::FileCache::Key & k\n     return fs::path(base_path) / key_str.substr(0, 3) / key_str / DB::toString(offset);\n }\n \n-void download(DB::FileSegmentPtr file_segment)\n+void download(const std::string & cache_base_path, DB::FileSegmentPtr file_segment)\n {\n     const auto & key = file_segment->key();\n     size_t size = file_segment->range().size();\n@@ -67,30 +71,57 @@ void download(DB::FileSegmentPtr file_segment)\n     file_segment->write(data.data(), size, file_segment->getCurrentWriteOffset());\n }\n \n-void prepareAndDownload(DB::FileSegmentPtr file_segment)\n+void prepareAndDownload(const std::string & cache_base_path, DB::FileSegmentPtr file_segment)\n {\n-    // std::cerr << \"Reserving: \" << file_segment->range().size() << \" for: \" << file_segment->range().toString() << \"\\n\";\n     ASSERT_TRUE(file_segment->reserve(file_segment->range().size()));\n-    download(file_segment);\n+    download(cache_base_path, file_segment);\n }\n \n-void complete(const DB::FileSegmentsHolder & holder)\n+void complete(const std::string & cache_base_path, const DB::FileSegmentsHolder & holder)\n {\n     for (const auto & file_segment : holder.file_segments)\n     {\n         ASSERT_TRUE(file_segment->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-        prepareAndDownload(file_segment);\n+        prepareAndDownload(cache_base_path, file_segment);\n         file_segment->completeWithState(DB::FileSegment::State::DOWNLOADED);\n     }\n }\n \n-\n-TEST(FileCache, get)\n+class FileCacheTest : public ::testing::Test\n {\n-    if (fs::exists(cache_base_path))\n-        fs::remove_all(cache_base_path);\n-    fs::create_directories(cache_base_path);\n+public:\n+\n+    static void setupLogs(const std::string & level)\n+    {\n+        Poco::AutoPtr<Poco::ConsoleChannel> channel(new Poco::ConsoleChannel(std::cerr));\n+        Poco::Logger::root().setChannel(channel);\n+        Poco::Logger::root().setLevel(level);\n+    }\n \n+    void SetUp() override\n+    {\n+        if(const char * test_log_level = std::getenv(\"TEST_LOG_LEVEL\")) // NOLINT(concurrency-mt-unsafe)\n+            setupLogs(test_log_level);\n+        else\n+            setupLogs(TEST_LOG_LEVEL);\n+\n+        if (fs::exists(cache_base_path))\n+            fs::remove_all(cache_base_path);\n+        fs::create_directories(cache_base_path);\n+    }\n+\n+    void TearDown() override\n+    {\n+        if (fs::exists(cache_base_path))\n+            fs::remove_all(cache_base_path);\n+    }\n+\n+    fs::path caches_dir = fs::current_path() / \"lru_cache_test\";\n+    std::string cache_base_path = caches_dir / \"cache1\" / \"\";\n+};\n+\n+TEST_F(FileCacheTest, get)\n+{\n     DB::ThreadStatus thread_status;\n \n     /// To work with cache need query_id and query context.\n@@ -126,7 +157,7 @@ TEST(FileCache, get)\n             ASSERT_TRUE(segments[0]->reserve(segments[0]->range().size()));\n             assertRange(2, segments[0], DB::FileSegment::Range(0, 9), DB::FileSegment::State::DOWNLOADING);\n \n-            download(segments[0]);\n+            download(cache_base_path, segments[0]);\n             segments[0]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             assertRange(3, segments[0], DB::FileSegment::Range(0, 9), DB::FileSegment::State::DOWNLOADED);\n         }\n@@ -147,7 +178,7 @@ TEST(FileCache, get)\n             assertRange(5, segments[1], DB::FileSegment::Range(10, 14), DB::FileSegment::State::EMPTY);\n \n             ASSERT_TRUE(segments[1]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-            prepareAndDownload(segments[1]);\n+            prepareAndDownload(cache_base_path, segments[1]);\n             segments[1]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             assertRange(6, segments[1], DB::FileSegment::Range(10, 14), DB::FileSegment::State::DOWNLOADED);\n         }\n@@ -180,8 +211,8 @@ TEST(FileCache, get)\n             assertRange(10, segments[0], DB::FileSegment::Range(10, 14), DB::FileSegment::State::DOWNLOADED);\n         }\n \n-        complete(cache.getOrSet(key, 17, 4, {})); /// Get [17, 20]\n-        complete(cache.getOrSet(key, 24, 3, {})); /// Get [24, 26]\n+        complete(cache_base_path, cache.getOrSet(key, 17, 4, {})); /// Get [17, 20]\n+        complete(cache_base_path, cache.getOrSet(key, 24, 3, {})); /// Get [24, 26]\n         /// completeWithState(cache.getOrSet(key, 27, 1, false)); /// Get [27, 27]\n \n         /// Current cache:    [__________][_____]   [____]    [___][]\n@@ -203,7 +234,7 @@ TEST(FileCache, get)\n             assertRange(13, segments[2], DB::FileSegment::Range(15, 16), DB::FileSegment::State::EMPTY);\n \n             ASSERT_TRUE(segments[2]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-            prepareAndDownload(segments[2]);\n+            prepareAndDownload(cache_base_path, segments[2]);\n \n             segments[2]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n \n@@ -244,7 +275,7 @@ TEST(FileCache, get)\n             assertRange(21, segments[3], DB::FileSegment::Range(21, 21), DB::FileSegment::State::EMPTY);\n \n             ASSERT_TRUE(segments[3]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-            prepareAndDownload(segments[3]);\n+            prepareAndDownload(cache_base_path, segments[3]);\n \n             segments[3]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             ASSERT_TRUE(segments[3]->state() == DB::FileSegment::State::DOWNLOADED);\n@@ -267,8 +298,8 @@ TEST(FileCache, get)\n \n             ASSERT_TRUE(segments[0]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n             ASSERT_TRUE(segments[2]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-            prepareAndDownload(segments[0]);\n-            prepareAndDownload(segments[2]);\n+            prepareAndDownload(cache_base_path, segments[0]);\n+            prepareAndDownload(cache_base_path, segments[2]);\n             segments[0]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             segments[2]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n         }\n@@ -290,8 +321,8 @@ TEST(FileCache, get)\n \n             ASSERT_TRUE(s5[0]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n             ASSERT_TRUE(s1[0]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-            prepareAndDownload(s5[0]);\n-            prepareAndDownload(s1[0]);\n+            prepareAndDownload(cache_base_path, s5[0]);\n+            prepareAndDownload(cache_base_path, s1[0]);\n             s5[0]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             s1[0]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n \n@@ -394,7 +425,7 @@ TEST(FileCache, get)\n                 cv.wait(lock, [&]{ return lets_start_download; });\n             }\n \n-            prepareAndDownload(segments[2]);\n+            prepareAndDownload(cache_base_path, segments[2]);\n             segments[2]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             ASSERT_TRUE(segments[2]->state() == DB::FileSegment::State::DOWNLOADED);\n \n@@ -459,7 +490,7 @@ TEST(FileCache, get)\n                 ASSERT_TRUE(segments_2[1]->state() == DB::FileSegment::State::PARTIALLY_DOWNLOADED);\n \n                 ASSERT_TRUE(segments_2[1]->getOrSetDownloader() == DB::FileSegment::getCallerId());\n-                prepareAndDownload(segments_2[1]);\n+                prepareAndDownload(cache_base_path, segments_2[1]);\n                 segments_2[1]->completeWithState(DB::FileSegment::State::DOWNLOADED);\n             });\n \n@@ -517,3 +548,141 @@ TEST(FileCache, get)\n     }\n \n }\n+\n+TEST_F(FileCacheTest, rangeWriter)\n+{\n+    DB::FileCacheSettings settings;\n+    settings.max_size = 25;\n+    settings.max_elements = 5;\n+    settings.max_file_segment_size = 10;\n+\n+    DB::FileCache cache(cache_base_path, settings);\n+    cache.initialize();\n+    auto key = cache.hash(\"key1\");\n+\n+    DB::FileSegmentRangeWriter writer(&cache, key, nullptr, \"\", \"key1\");\n+\n+    std::string data(100, '\\xf0');\n+\n+    size_t total_written = 0;\n+    for (const size_t size : {3, 5, 8, 1, 1, 3})\n+    {\n+        total_written += size;\n+        ASSERT_EQ(writer.tryWrite(data.data(), size, writer.currentOffset()), size);\n+    }\n+    ASSERT_LT(total_written, settings.max_size);\n+\n+    size_t offset_before_unsuccessful_write = writer.currentOffset();\n+    size_t space_left = settings.max_size - total_written;\n+    ASSERT_EQ(writer.tryWrite(data.data(), space_left + 1, writer.currentOffset()), 0);\n+\n+    ASSERT_EQ(writer.currentOffset(), offset_before_unsuccessful_write);\n+\n+    ASSERT_EQ(writer.tryWrite(data.data(), space_left, writer.currentOffset()), space_left);\n+\n+    writer.finalize();\n+}\n+\n+static Block generateBlock(size_t size = 0)\n+{\n+    Block block;\n+    ColumnWithTypeAndName column;\n+    column.name = \"x\";\n+    column.type = std::make_shared<DataTypeUInt64>();\n+\n+    {\n+        MutableColumnPtr mut_col = column.type->createColumn();\n+        for (size_t i = 0; i < size; ++i)\n+            mut_col->insert(i);\n+        column.column = std::move(mut_col);\n+    }\n+\n+    block.insert(column);\n+\n+    LOG_DEBUG(&Poco::Logger::get(\"FileCacheTest\"), \"generated block {} bytes\", block.bytes());\n+    return block;\n+}\n+\n+static size_t readAllTemporaryData(TemporaryFileStream & stream)\n+{\n+    Block block;\n+    size_t read_rows = 0;\n+    do\n+    {\n+        block = stream.read();\n+        read_rows += block.rows();\n+    } while (block);\n+    return read_rows;\n+}\n+\n+TEST_F(FileCacheTest, temporaryData)\n+{\n+    DB::FileCacheSettings settings;\n+    settings.max_size = 10240;\n+    settings.max_file_segment_size = 1024;\n+\n+    DB::FileCache file_cache(cache_base_path, settings);\n+    file_cache.initialize();\n+\n+    auto tmp_data_scope = std::make_shared<TemporaryDataOnDiskScope>(nullptr, &file_cache, 0);\n+\n+    auto some_data_holder = file_cache.getOrSet(file_cache.hash(\"some_data\"), 0, 1024 * 5, CreateFileSegmentSettings{});\n+\n+    {\n+        auto segments = fromHolder(some_data_holder);\n+        ASSERT_EQ(segments.size(), 5);\n+        for (auto & segment : segments)\n+        {\n+            ASSERT_TRUE(segment->getOrSetDownloader() == DB::FileSegment::getCallerId());\n+            ASSERT_TRUE(segment->reserve(segment->range().size()));\n+            download(cache_base_path, segment);\n+            segment->completeWithState(DB::FileSegment::State::DOWNLOADED);\n+        }\n+    }\n+\n+    size_t size_used_before_temporary_data = file_cache.getUsedCacheSize();\n+    size_t segments_used_before_temporary_data = file_cache.getFileSegmentsNum();\n+    ASSERT_GT(size_used_before_temporary_data, 0);\n+    ASSERT_GT(segments_used_before_temporary_data, 0);\n+\n+    size_t size_used_with_temporary_data;\n+    size_t segments_used_with_temporary_data;\n+    {\n+        auto tmp_data = std::make_unique<TemporaryDataOnDisk>(tmp_data_scope);\n+\n+        auto & stream = tmp_data->createStream(generateBlock());\n+\n+        ASSERT_GT(stream.write(generateBlock(100)), 0);\n+\n+        EXPECT_GT(file_cache.getUsedCacheSize(), 0);\n+        EXPECT_GT(file_cache.getFileSegmentsNum(), 0);\n+\n+        size_t used_size_before_attempt = file_cache.getUsedCacheSize();\n+        /// data can't be evicted because it is still held by `some_data_holder`\n+        ASSERT_THROW(stream.write(generateBlock(1000)), DB::Exception);\n+\n+        ASSERT_EQ(file_cache.getUsedCacheSize(), used_size_before_attempt);\n+\n+        some_data_holder.reset();\n+\n+        stream.write(generateBlock(1011));\n+\n+        auto stat = stream.finishWriting();\n+\n+        EXPECT_EQ(stat.num_rows, 1111);\n+        EXPECT_EQ(readAllTemporaryData(stream), 1111);\n+\n+        size_used_with_temporary_data = file_cache.getUsedCacheSize();\n+        segments_used_with_temporary_data = file_cache.getFileSegmentsNum();\n+        EXPECT_GT(size_used_with_temporary_data, 0);\n+        EXPECT_GT(segments_used_with_temporary_data, 0);\n+    }\n+\n+    /// All temp data should be evicted after removing temporary files\n+    EXPECT_LE(file_cache.getUsedCacheSize(), size_used_with_temporary_data);\n+    EXPECT_LE(file_cache.getFileSegmentsNum(), segments_used_with_temporary_data);\n+\n+    /// Some segments reserved by `some_data_holder` was eviced by temporary data\n+    EXPECT_LE(file_cache.getUsedCacheSize(), size_used_before_temporary_data);\n+    EXPECT_LE(file_cache.getFileSegmentsNum(), segments_used_before_temporary_data);\n+}\ndiff --git a/tests/integration/test_temporary_data_in_cache/__init__.py b/tests/integration/test_temporary_data_in_cache/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_temporary_data_in_cache/configs/config.d/storage_configuration.xml b/tests/integration/test_temporary_data_in_cache/configs/config.d/storage_configuration.xml\nnew file mode 100644\nindex 000000000000..8ccd705c6f18\n--- /dev/null\n+++ b/tests/integration/test_temporary_data_in_cache/configs/config.d/storage_configuration.xml\n@@ -0,0 +1,39 @@\n+<clickhouse>\n+    <storage_configuration>\n+        <disks>\n+            <local_disk>\n+                <type>local</type>\n+                <path>/local_disk/</path>\n+            </local_disk>\n+\n+            <tiny_local_cache>\n+                <type>cache</type>\n+                <disk>local_disk</disk>\n+                <path>/tiny_local_cache/</path>\n+                <max_size>10M</max_size>\n+                <max_file_segment_size>1M</max_file_segment_size>\n+                <cache_on_write_operations>1</cache_on_write_operations>\n+                <do_not_evict_index_and_mark_files>0</do_not_evict_index_and_mark_files>\n+            </tiny_local_cache>\n+\n+            <!-- Used to check free space in `/tiny_local_cache` using `system.disks` -->\n+            <!-- Entry about tiny_local_cache shows incorrect info due to it uses DiskObjectStorage under the hood -->\n+            <tiny_local_cache_local_disk>\n+                <type>local</type>\n+                <path>/tiny_local_cache/</path>\n+            </tiny_local_cache_local_disk>\n+        </disks>\n+\n+        <policies>\n+            <tiny_local_cache>\n+                <volumes>\n+                    <main>\n+                        <disk>tiny_local_cache</disk>\n+                    </main>\n+                </volumes>\n+            </tiny_local_cache>\n+        </policies>\n+    </storage_configuration>\n+\n+    <tmp_cache>tiny_local_cache</tmp_cache>\n+</clickhouse>\ndiff --git a/tests/integration/test_temporary_data_in_cache/test.py b/tests/integration/test_temporary_data_in_cache/test.py\nnew file mode 100644\nindex 000000000000..ba57348ee371\n--- /dev/null\n+++ b/tests/integration/test_temporary_data_in_cache/test.py\n@@ -0,0 +1,81 @@\n+# pylint: disable=unused-argument\n+# pylint: disable=redefined-outer-name\n+\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+from helpers.client import QueryRuntimeException\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+node = cluster.add_instance(\n+    \"node\",\n+    main_configs=[\"configs/config.d/storage_configuration.xml\"],\n+    tmpfs=[\"/local_disk:size=50M\", \"/tiny_local_cache:size=12M\"],\n+)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_cache_evicted_by_temporary_data(start_cluster):\n+    q = node.query\n+    qi = lambda query: int(node.query(query).strip())\n+\n+    cache_size_initial = qi(\"SELECT sum(size) FROM system.filesystem_cache\")\n+    assert cache_size_initial == 0\n+\n+    free_space_initial = qi(\n+        \"SELECT free_space FROM system.disks WHERE name = 'tiny_local_cache_local_disk'\"\n+    )\n+    assert free_space_initial > 8 * 1024 * 1024\n+\n+    q(\n+        \"CREATE TABLE t1 (x UInt64) ENGINE = MergeTree ORDER BY x SETTINGS storage_policy = 'tiny_local_cache'\"\n+    )\n+    q(\"INSERT INTO t1 SELECT number FROM numbers(1024 * 1024)\")\n+\n+    # To be sure that nothing is reading the cache and entries for t1 can be evited\n+    q(\"OPTIMIZE TABLE t1 FINAL\")\n+    q(\"SYSTEM STOP MERGES t1\")\n+\n+    # Read some data to fill the cache\n+    q(\"SELECT sum(x) FROM t1\")\n+\n+    cache_size_with_t1 = qi(\"SELECT sum(size) FROM system.filesystem_cache\")\n+    assert cache_size_with_t1 > 8 * 1024 * 1024\n+\n+    # Almost all disk space is occupied by t1 cache\n+    free_space_with_t1 = qi(\n+        \"SELECT free_space FROM system.disks WHERE name = 'tiny_local_cache_local_disk'\"\n+    )\n+    assert free_space_with_t1 < 4 * 1024 * 1024\n+\n+    # Try to sort the table, but fail because of lack of disk space\n+    with pytest.raises(QueryRuntimeException) as exc:\n+        q(\n+            \"SELECT ignore(*) FROM numbers(10 * 1024 * 1024) ORDER BY sipHash64(number)\",\n+            settings={\n+                \"max_bytes_before_external_group_by\": \"4M\",\n+                \"max_bytes_before_external_sort\": \"4M\",\n+            },\n+        )\n+    assert \"Cannot reserve space in file cache\" in str(exc.value)\n+\n+    # Some data evicted from cache by temporary data\n+    cache_size_after_eviction = qi(\"SELECT sum(size) FROM system.filesystem_cache\")\n+    assert cache_size_after_eviction < cache_size_with_t1\n+\n+    # Disk space freed, at least 3 MB, because temporary data tried to write 4 MB\n+    free_space_after_eviction = qi(\n+        \"SELECT free_space FROM system.disks WHERE name = 'tiny_local_cache_local_disk'\"\n+    )\n+    assert free_space_after_eviction > free_space_with_t1 + 3 * 1024 * 1024\n+\n+    q(\"DROP TABLE IF EXISTS t1\")\ndiff --git a/tests/integration/test_tmp_policy/test.py b/tests/integration/test_tmp_policy/test.py\nindex c919d9a0c3db..870a70b127a0 100644\n--- a/tests/integration/test_tmp_policy/test.py\n+++ b/tests/integration/test_tmp_policy/test.py\n@@ -23,7 +23,7 @@ def start_cluster():\n         cluster.shutdown()\n \n \n-def test_different_versions(start_cluster):\n+def test_disk_selection(start_cluster):\n     query = \"SELECT count(ignore(*)) FROM (SELECT * FROM system.numbers LIMIT 1e7) GROUP BY number\"\n     settings = {\n         \"max_bytes_before_external_group_by\": 1 << 20,\n",
  "problem_statement": "Temporary data on disk should cooperate with the filesystem cache.\n**Use case**\r\n\r\nLocal cache and temporary data on disk are reusing the same space and should work and be limited together.\r\n\r\n**Describe the solution you'd like**\r\n\r\nIf the path for temporary data on disk is identical to the filesystem cache path, the temporary data on the disk will use the cache object to allocate space.\n",
  "hints_text": "",
  "created_at": "2022-11-21T17:49:30Z",
  "modified_files": [
    "programs/local/LocalServer.cpp",
    "programs/server/Server.cpp",
    "src/Common/filesystemHelpers.cpp",
    "src/Common/filesystemHelpers.h",
    "src/Disks/IO/CachedOnDiskReadBufferFromFile.cpp",
    "src/Disks/IO/CachedOnDiskWriteBufferFromFile.cpp",
    "src/Disks/IO/CachedOnDiskWriteBufferFromFile.h",
    "b/src/Disks/IO/FileCachePlaceholder.cpp",
    "b/src/Disks/IO/FileCachePlaceholder.h",
    "src/Disks/ObjectStorages/Cached/CachedObjectStorage.h",
    "src/Disks/ObjectStorages/DiskObjectStorage.cpp",
    "src/Disks/ObjectStorages/DiskObjectStorage.h",
    "b/src/Disks/TemporaryFileInPath.cpp",
    "b/src/Disks/TemporaryFileInPath.h",
    "src/Disks/TemporaryFileOnDisk.cpp",
    "src/Disks/TemporaryFileOnDisk.h",
    "src/Formats/NativeWriter.cpp",
    "src/Formats/NativeWriter.h",
    "src/IO/WriteBufferFromTemporaryFile.cpp",
    "src/IO/WriteBufferFromTemporaryFile.h",
    "src/Interpreters/Cache/FileCache.cpp",
    "src/Interpreters/Cache/FileCache.h",
    "src/Interpreters/Cache/FileCacheFactory.cpp",
    "src/Interpreters/Cache/FileCacheFactory.h",
    "src/Interpreters/Cache/FileSegment.cpp",
    "src/Interpreters/Cache/FileSegment.h",
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "src/Interpreters/TemporaryDataOnDisk.cpp",
    "src/Interpreters/TemporaryDataOnDisk.h",
    "src/Storages/MergeTree/MergeTask.h",
    "src/Storages/System/StorageSystemFilesystemCache.cpp"
  ],
  "modified_test_files": [
    "src/Interpreters/tests/gtest_lru_file_cache.cpp",
    "b/tests/integration/test_temporary_data_in_cache/configs/config.d/storage_configuration.xml",
    "b/tests/integration/test_temporary_data_in_cache/test.py",
    "tests/integration/test_tmp_policy/test.py"
  ]
}