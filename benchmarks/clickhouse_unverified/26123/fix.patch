diff --git a/src/DataTypes/EnumValues.h b/src/DataTypes/EnumValues.h
index d03a8867e420..1e5e4f55ea75 100644
--- a/src/DataTypes/EnumValues.h
+++ b/src/DataTypes/EnumValues.h
@@ -42,11 +42,23 @@ class EnumValues : public IHints<1, EnumValues<T>>
         return it;
     }
 
+    /// throws exception if value is not valid
     const StringRef & getNameForValue(const T & value) const
     {
         return findByValue(value)->second;
     }
 
+    /// returns false if value is not valid
+    bool getNameForValue(const T & value, StringRef & result) const
+    {
+        const auto it = value_to_name_map.find(value);
+        if (it == std::end(value_to_name_map))
+            return false;
+
+        result = it->second;
+        return true;
+    }
+
     T getValue(StringRef field_name, bool try_treat_as_id = false) const;
 
     template <typename TValues>
diff --git a/src/Functions/FunctionHelpers.cpp b/src/Functions/FunctionHelpers.cpp
index dcdd0e521eb0..eac1a7ad1a10 100644
--- a/src/Functions/FunctionHelpers.cpp
+++ b/src/Functions/FunctionHelpers.cpp
@@ -49,47 +49,48 @@ Columns convertConstTupleToConstantElements(const ColumnConst & column)
     return res;
 }
 
-
-ColumnsWithTypeAndName createBlockWithNestedColumns(const ColumnsWithTypeAndName & columns)
+ColumnWithTypeAndName columnGetNested(const ColumnWithTypeAndName & col)
 {
-    ColumnsWithTypeAndName res;
-    for (const auto & col : columns)
+    if (col.type->isNullable())
     {
-        if (col.type->isNullable())
+        const DataTypePtr & nested_type = static_cast<const DataTypeNullable &>(*col.type).getNestedType();
+
+        if (!col.column)
+        {
+            return ColumnWithTypeAndName{nullptr, nested_type, col.name};
+        }
+        else if (const auto * nullable = checkAndGetColumn<ColumnNullable>(*col.column))
+        {
+            const auto & nested_col = nullable->getNestedColumnPtr();
+            return ColumnWithTypeAndName{nested_col, nested_type, col.name};
+        }
+        else if (const auto * const_column = checkAndGetColumn<ColumnConst>(*col.column))
         {
-            const DataTypePtr & nested_type = static_cast<const DataTypeNullable &>(*col.type).getNestedType();
+            const auto * nullable_column = checkAndGetColumn<ColumnNullable>(const_column->getDataColumn());
 
-            if (!col.column)
+            ColumnPtr nullable_res;
+            if (nullable_column)
             {
-                res.emplace_back(ColumnWithTypeAndName{nullptr, nested_type, col.name});
+                const auto & nested_col = nullable_column->getNestedColumnPtr();
+                nullable_res = ColumnConst::create(nested_col, col.column->size());
             }
-            else if (const auto * nullable = checkAndGetColumn<ColumnNullable>(*col.column))
-            {
-                const auto & nested_col = nullable->getNestedColumnPtr();
-                res.emplace_back(ColumnWithTypeAndName{nested_col, nested_type, col.name});
-            }
-            else if (const auto * const_column = checkAndGetColumn<ColumnConst>(*col.column))
+            else
             {
-                const auto * nullable_column = checkAndGetColumn<ColumnNullable>(const_column->getDataColumn());
-
-                ColumnPtr nullable_res;
-                if (nullable_column)
-                {
-                    const auto & nested_col = nullable_column->getNestedColumnPtr();
-                    nullable_res = ColumnConst::create(nested_col, col.column->size());
-                }
-                else
-                {
-                    nullable_res = makeNullable(col.column);
-                }
-                res.emplace_back(ColumnWithTypeAndName{ nullable_res, nested_type, col.name });
+                nullable_res = makeNullable(col.column);
             }
-            else
-                throw Exception("Illegal column for DataTypeNullable", ErrorCodes::ILLEGAL_COLUMN);
+            return ColumnWithTypeAndName{ nullable_res, nested_type, col.name };
         }
         else
-            res.emplace_back(col);
+            throw Exception("Illegal column for DataTypeNullable", ErrorCodes::ILLEGAL_COLUMN);
     }
+    return col;
+}
+
+ColumnsWithTypeAndName createBlockWithNestedColumns(const ColumnsWithTypeAndName & columns)
+{
+    ColumnsWithTypeAndName res;
+    for (const auto & col : columns)
+        res.emplace_back(columnGetNested(col));
 
     return res;
 }
diff --git a/src/Functions/FunctionHelpers.h b/src/Functions/FunctionHelpers.h
index 7ab008b8bea1..5abe24f4e50c 100644
--- a/src/Functions/FunctionHelpers.h
+++ b/src/Functions/FunctionHelpers.h
@@ -81,6 +81,8 @@ inline std::enable_if_t<IsDecimalNumber<T>, Field> toField(const T & x, UInt32 s
 
 Columns convertConstTupleToConstantElements(const ColumnConst & column);
 
+/// Returns nested column with corrected type if nullable
+ColumnWithTypeAndName columnGetNested(const ColumnWithTypeAndName & col);
 
 /// Returns the copy of a given columns in which each column is replaced with its respective nested
 /// column if it is nullable.
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index ff97894d98e9..4cb5b5744752 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -579,36 +579,44 @@ template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDateTime64
 template <typename DataType>
 struct FormatImpl
 {
-    static void execute(const typename DataType::FieldType x, WriteBuffer & wb, const DataType *, const DateLUTImpl *)
+    template <typename ReturnType = void>
+    static ReturnType execute(const typename DataType::FieldType x, WriteBuffer & wb, const DataType *, const DateLUTImpl *)
     {
         writeText(x, wb);
+        return ReturnType(true);
     }
 };
 
 template <>
 struct FormatImpl<DataTypeDate>
 {
-    static void execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl *)
+    template <typename ReturnType = void>
+    static ReturnType execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl *)
     {
         writeDateText(DayNum(x), wb);
+        return ReturnType(true);
     }
 };
 
 template <>
 struct FormatImpl<DataTypeDateTime>
 {
-    static void execute(const DataTypeDateTime::FieldType x, WriteBuffer & wb, const DataTypeDateTime *, const DateLUTImpl * time_zone)
+    template <typename ReturnType = void>
+    static ReturnType execute(const DataTypeDateTime::FieldType x, WriteBuffer & wb, const DataTypeDateTime *, const DateLUTImpl * time_zone)
     {
         writeDateTimeText(x, wb, *time_zone);
+        return ReturnType(true);
     }
 };
 
 template <>
 struct FormatImpl<DataTypeDateTime64>
 {
-    static void execute(const DataTypeDateTime64::FieldType x, WriteBuffer & wb, const DataTypeDateTime64 * type, const DateLUTImpl * time_zone)
+    template <typename ReturnType = void>
+    static ReturnType execute(const DataTypeDateTime64::FieldType x, WriteBuffer & wb, const DataTypeDateTime64 * type, const DateLUTImpl * time_zone)
     {
         writeDateTimeText(DateTime64(x), type->getScale(), wb, *time_zone);
+        return ReturnType(true);
     }
 };
 
@@ -616,18 +624,34 @@ struct FormatImpl<DataTypeDateTime64>
 template <typename FieldType>
 struct FormatImpl<DataTypeEnum<FieldType>>
 {
-    static void execute(const FieldType x, WriteBuffer & wb, const DataTypeEnum<FieldType> * type, const DateLUTImpl *)
+    template <typename ReturnType = void>
+    static ReturnType execute(const FieldType x, WriteBuffer & wb, const DataTypeEnum<FieldType> * type, const DateLUTImpl *)
     {
-        writeString(type->getNameForValue(x), wb);
+        static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;
+
+        if constexpr (throw_exception)
+        {
+            writeString(type->getNameForValue(x), wb);
+        }
+        else
+        {
+            StringRef res;
+            bool is_ok = type->getNameForValue(x, res);
+            if (is_ok)
+                writeString(res, wb);
+            return ReturnType(is_ok);
+        }
     }
 };
 
 template <typename FieldType>
 struct FormatImpl<DataTypeDecimal<FieldType>>
 {
-    static void execute(const FieldType x, WriteBuffer & wb, const DataTypeDecimal<FieldType> * type, const DateLUTImpl *)
+    template <typename ReturnType = void>
+    static ReturnType execute(const FieldType x, WriteBuffer & wb, const DataTypeDecimal<FieldType> * type, const DateLUTImpl *)
     {
         writeText(x, type->getScale(), wb);
+        return ReturnType(true);
     }
 };
 
@@ -642,6 +666,16 @@ struct ConvertImpl<DataTypeEnum<FieldType>, DataTypeNumber<FieldType>, Name, Con
     }
 };
 
+static ColumnUInt8::MutablePtr copyNullMap(ColumnPtr col)
+{
+    ColumnUInt8::MutablePtr null_map = nullptr;
+    if (const auto * col_null = checkAndGetColumn<ColumnNullable>(col.get()))
+    {
+        null_map = ColumnUInt8::create();
+        null_map->insertRangeFrom(col_null->getNullMapColumn(), 0, col_null->size());
+    }
+    return null_map;
+}
 
 template <typename FromDataType, typename Name>
 struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType, DataTypeString>, DataTypeString>, Name, ConvertDefaultBehaviorTag>
@@ -651,13 +685,18 @@ struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType,
 
     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/)
     {
-        const auto & col_with_type_and_name = arguments[0];
+        ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);
+
+        const auto & col_with_type_and_name =  columnGetNested(arguments[0]);
         const auto & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);
 
         const DateLUTImpl * time_zone = nullptr;
         /// For argument of DateTime type, second argument with time zone could be specified.
         if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDateTime64>)
-            time_zone = &extractTimeZoneFromFunctionArguments(arguments, 1, 0);
+        {
+            auto non_null_args = createBlockWithNestedColumns(arguments);
+            time_zone = &extractTimeZoneFromFunctionArguments(non_null_args, 1, 0);
+        }
 
         if (const auto col_from = checkAndGetColumn<ColVecType>(col_with_type_and_name.column.get()))
         {
@@ -681,14 +720,30 @@ struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType,
 
             WriteBufferFromVector<ColumnString::Chars> write_buffer(data_to);
 
-            for (size_t i = 0; i < size; ++i)
+            if (null_map)
             {
-                FormatImpl<FromDataType>::execute(vec_from[i], write_buffer, &type, time_zone);
-                writeChar(0, write_buffer);
-                offsets_to[i] = write_buffer.count();
+                for (size_t i = 0; i < size; ++i)
+                {
+                    bool is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);
+                    null_map->getData()[i] |= !is_ok;
+                    writeChar(0, write_buffer);
+                    offsets_to[i] = write_buffer.count();
+                }
+            }
+            else
+            {
+                for (size_t i = 0; i < size; ++i)
+                {
+                    FormatImpl<FromDataType>::template execute<void>(vec_from[i], write_buffer, &type, time_zone);
+                    writeChar(0, write_buffer);
+                    offsets_to[i] = write_buffer.count();
+                }
             }
 
             write_buffer.finalize();
+
+            if (null_map)
+                return ColumnNullable::create(std::move(col_to), std::move(null_map));
             return col_to;
         }
         else
@@ -702,9 +757,11 @@ struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType,
 /// Generic conversion of any type to String.
 struct ConvertImplGenericToString
 {
-    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments)
+    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type)
     {
-        const auto & col_with_type_and_name = arguments[0];
+        ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);
+
+        const auto & col_with_type_and_name = columnGetNested(arguments[0]);
         const IDataType & type = *col_with_type_and_name.type;
         const IColumn & col_from = *col_with_type_and_name.column;
 
@@ -730,6 +787,9 @@ struct ConvertImplGenericToString
         }
 
         write_buffer.finalize();
+
+        if (result_type->isNullable() && null_map)
+            return ColumnNullable::create(std::move(col_to), std::move(null_map));
         return col_to;
     }
 };
@@ -1398,7 +1458,11 @@ class FunctionConvert : public IFunction
     /// Function actually uses default implementation for nulls,
     /// but we need to know if return type is Nullable or not,
     /// so we use checked_return_type only to intercept the first call to getReturnTypeImpl(...).
-    bool useDefaultImplementationForNulls() const override { return checked_return_type; }
+    bool useDefaultImplementationForNulls() const override
+    {
+        bool to_nullable_string = to_nullable && std::is_same_v<ToDataType, DataTypeString>;
+        return checked_return_type && !to_nullable_string;
+    }
 
     bool useDefaultImplementationForConstants() const override { return true; }
     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override
@@ -1463,7 +1527,10 @@ class FunctionConvert : public IFunction
             throw Exception{"Function " + getName() + " expects at least 1 argument",
                ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION};
 
-        const IDataType * from_type = arguments[0].type.get();
+        if (result_type->onlyNull())
+            return result_type->createColumnConstWithDefaultValue(input_rows_count);
+
+        const DataTypePtr from_type = removeNullable(arguments[0].type);
         ColumnPtr result_column;
 
         auto call = [&](const auto & types, const auto & tag) -> bool
@@ -1559,7 +1626,7 @@ class FunctionConvert : public IFunction
             /// Generic conversion of any type to String.
             if (std::is_same_v<ToDataType, DataTypeString>)
             {
-                return ConvertImplGenericToString::execute(arguments);
+                return ConvertImplGenericToString::execute(arguments, result_type);
             }
             else
                 throw Exception("Illegal type " + arguments[0].type->getName() + " of argument of function " + getName(),
