diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h
index fa13008f352c..174e98dd81f2 100644
--- a/src/Functions/FunctionBinaryArithmetic.h
+++ b/src/Functions/FunctionBinaryArithmetic.h
@@ -1766,12 +1766,12 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op
                     return {true, is_constant_positive, true};
                 }
             }
-            return {false, true, false};
+            return {false, true, false, false};
         }
 
         // For simplicity, we treat every single value interval as positive monotonic.
         if (applyVisitor(FieldVisitorAccurateEquals(), left_point, right_point))
-            return {true, true, false};
+            return {true, true, false, false};
 
         if (name_view == "minus" || name_view == "plus")
         {
@@ -1797,18 +1797,18 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op
                     // Check if there is an overflow
                     if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)
                             == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))
-                        return {true, true, false};
+                        return {true, true, false, true};
                     else
-                        return {false, true, false};
+                        return {false, true, false, false};
                 }
                 else
                 {
                     // Check if there is an overflow
                     if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)
                             != applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))
-                        return {true, false, false};
+                        return {true, false, false, true};
                     else
-                        return {false, false, false};
+                        return {false, false, false, false};
                 }
             }
             // variable +|- constant
@@ -1829,31 +1829,33 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op
                 // Check if there is an overflow
                 if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)
                     == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))
-                    return {true, true, false};
+                    return {true, true, false, true};
                 else
-                    return {false, true, false};
+                    return {false, true, false, false};
             }
         }
         if (name_view == "divide" || name_view == "intDiv")
         {
+            bool is_strict = name_view == "divide";
+
             // const / variable
             if (left.column && isColumnConst(*left.column))
             {
                 auto constant = (*left.column)[0];
                 if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))
-                    return {true, true, false}; // 0 / 0 is undefined, thus it's not always monotonic
+                    return {true, true, false, false}; // 0 / 0 is undefined, thus it's not always monotonic
 
                 bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);
                 if (applyVisitor(FieldVisitorAccurateLess(), left_point, Field(0))
                     && applyVisitor(FieldVisitorAccurateLess(), right_point, Field(0)))
                 {
-                    return {true, is_constant_positive, false};
+                    return {true, is_constant_positive, false, is_strict};
                 }
                 else if (
                     applyVisitor(FieldVisitorAccurateLess(), Field(0), left_point)
                     && applyVisitor(FieldVisitorAccurateLess(), Field(0), right_point))
                 {
-                    return {true, !is_constant_positive, false};
+                    return {true, !is_constant_positive, false, is_strict};
                 }
             }
             // variable / constant
@@ -1861,11 +1863,11 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op
             {
                 auto constant = (*right.column)[0];
                 if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))
-                    return {false, true, false}; // variable / 0 is undefined, let's treat it as non-monotonic
+                    return {false, true, false, false}; // variable / 0 is undefined, let's treat it as non-monotonic
 
                 bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);
                 // division is saturated to `inf`, thus it doesn't have overflow issues.
-                return {true, is_constant_positive, true};
+                return {true, is_constant_positive, true, is_strict};
             }
         }
         return {false, true, false};
diff --git a/src/Functions/IFunction.h b/src/Functions/IFunction.h
index 83b89b85b62c..69cd08c2ddb3 100644
--- a/src/Functions/IFunction.h
+++ b/src/Functions/IFunction.h
@@ -265,9 +265,10 @@ class IFunctionBase
     /// The property of monotonicity for a certain range.
     struct Monotonicity
     {
-        bool is_monotonic = false;    /// Is the function monotonous (non-decreasing or non-increasing).
-        bool is_positive = true;    /// true if the function is non-decreasing, false if non-increasing. If is_monotonic = false, then it does not matter.
+        bool is_monotonic = false;   /// Is the function monotonous (non-decreasing or non-increasing).
+        bool is_positive = true;     /// true if the function is non-decreasing, false if non-increasing. If is_monotonic = false, then it does not matter.
         bool is_always_monotonic = false; /// Is true if function is monotonic on the whole input range I
+        bool is_strict = false;      /// true if the function is strictly decreasing or increasing.
     };
 
     /** Get information about monotonicity on a range of values. Call only if hasInformationAboutMonotonicity.
diff --git a/src/Functions/abs.cpp b/src/Functions/abs.cpp
index ae2a2412a4b0..a7afdbacad6f 100644
--- a/src/Functions/abs.cpp
+++ b/src/Functions/abs.cpp
@@ -46,7 +46,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameAbs>
         if ((left_float < 0 && right_float > 0) || (left_float > 0 && right_float < 0))
             return {};
 
-        return { .is_monotonic = true, .is_positive = left_float > 0 };
+        return { .is_monotonic = true, .is_positive = left_float > 0, .is_strict = true, };
     }
 };
 
diff --git a/src/Functions/fromModifiedJulianDay.cpp b/src/Functions/fromModifiedJulianDay.cpp
index ff434715338e..b22711da8113 100644
--- a/src/Functions/fromModifiedJulianDay.cpp
+++ b/src/Functions/fromModifiedJulianDay.cpp
@@ -139,7 +139,7 @@ namespace DB
 
         Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override
         {
-            return { .is_monotonic = true, .is_always_monotonic = true };
+            return { .is_monotonic = true, .is_always_monotonic = true, .is_strict = true, };
         }
 
     private:
diff --git a/src/Functions/intExp10.cpp b/src/Functions/intExp10.cpp
index e807eec313ca..6e59a41c50be 100644
--- a/src/Functions/intExp10.cpp
+++ b/src/Functions/intExp10.cpp
@@ -55,7 +55,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameIntExp10>
         if (left_float < 0 || right_float > 19)
             return {};
 
-        return { .is_monotonic = true };
+        return { .is_monotonic = true, .is_strict = true };
     }
 };
 
diff --git a/src/Functions/intExp2.cpp b/src/Functions/intExp2.cpp
index 91fc4cb91b11..e39647b6c38e 100644
--- a/src/Functions/intExp2.cpp
+++ b/src/Functions/intExp2.cpp
@@ -58,7 +58,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameIntExp2>
         if (left_float < 0 || right_float > 63)
             return {};
 
-        return { .is_monotonic = true };
+        return { .is_monotonic = true, .is_strict = true, };
     }
 };
 
diff --git a/src/Functions/negate.cpp b/src/Functions/negate.cpp
index 779cc0fff78e..731c0766e9db 100644
--- a/src/Functions/negate.cpp
+++ b/src/Functions/negate.cpp
@@ -42,7 +42,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameNegate>
     static bool has() { return true; }
     static IFunction::Monotonicity get(const Field &, const Field &)
     {
-        return { .is_monotonic = true, .is_positive = false };
+        return { .is_monotonic = true, .is_positive = false, .is_strict = true };
     }
 };
 
diff --git a/src/Functions/toModifiedJulianDay.cpp b/src/Functions/toModifiedJulianDay.cpp
index 2e9b6eb1c792..6c6eda1673ab 100644
--- a/src/Functions/toModifiedJulianDay.cpp
+++ b/src/Functions/toModifiedJulianDay.cpp
@@ -157,7 +157,7 @@ namespace DB
 
         Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override
         {
-            return { .is_monotonic = true, .is_always_monotonic = true };
+            return { .is_monotonic = true, .is_always_monotonic = true, .is_strict = true };
         }
 
     private:
diff --git a/src/Functions/toTimezone.cpp b/src/Functions/toTimezone.cpp
index 5f6784c56550..3a16c8756fbe 100644
--- a/src/Functions/toTimezone.cpp
+++ b/src/Functions/toTimezone.cpp
@@ -67,7 +67,7 @@ class FunctionBaseToTimeZone : public IFunctionBase
     Monotonicity getMonotonicityForRange(const IDataType & /*type*/, const Field & /*left*/, const Field & /*right*/) const override
     {
         const bool b = is_constant_timezone;
-        return { .is_monotonic = b, .is_positive = b, .is_always_monotonic = b };
+        return { .is_monotonic = b, .is_positive = b, .is_always_monotonic = b, .is_strict = b };
     }
 
 private:
diff --git a/src/Storages/ReadInOrderOptimizer.cpp b/src/Storages/ReadInOrderOptimizer.cpp
index b67da14365e1..803b7833494c 100644
--- a/src/Storages/ReadInOrderOptimizer.cpp
+++ b/src/Storages/ReadInOrderOptimizer.cpp
@@ -103,10 +103,17 @@ NameSet getFixedSortingColumns(
     return fixed_points;
 }
 
+struct MatchResult
+{
+    /// One of {-1, 0, 1} - direction of the match. 0 means - doesn't match.
+    int direction = 0;
+    /// If true then current key must be the last in the matched prefix of sort description.
+    bool is_last_key = false;
+};
+
 /// Optimize in case of exact match with order key element
 /// or in some simple cases when order key element is wrapped into monotonic function.
-/// Returns on of {-1, 0, 1} - direction of the match. 0 means - doesn't match.
-int matchSortDescriptionAndKey(
+MatchResult matchSortDescriptionAndKey(
     const ExpressionActions::Actions & actions,
     const SortColumnDescription & sort_column,
     const String & sorting_key_column)
@@ -114,12 +121,13 @@ int matchSortDescriptionAndKey(
     /// If required order depend on collation, it cannot be matched with primary key order.
     /// Because primary keys cannot have collations.
     if (sort_column.collator)
-        return 0;
+        return {};
+
+    MatchResult result{sort_column.direction, false};
 
-    int current_direction = sort_column.direction;
     /// For the path: order by (sort_column, ...)
     if (sort_column.column_name == sorting_key_column)
-        return current_direction;
+        return result;
 
     /// For the path: order by (function(sort_column), ...)
     /// Allow only one simple monotonic functions with one argument
@@ -132,44 +140,35 @@ int matchSortDescriptionAndKey(
             continue;
 
         if (found_function)
-        {
-            current_direction = 0;
-            break;
-        }
-        else
-        {
-            found_function = true;
-        }
+            return {};
 
+        found_function = true;
         if (action.node->children.size() != 1 || action.node->children.at(0)->result_name != sorting_key_column)
-        {
-            current_direction = 0;
-            break;
-        }
+            return {};
 
         const auto & func = *action.node->function_base;
         if (!func.hasInformationAboutMonotonicity())
-        {
-            current_direction = 0;
-            break;
-        }
+            return {};
 
         auto monotonicity = func.getMonotonicityForRange(*func.getArgumentTypes().at(0), {}, {});
         if (!monotonicity.is_monotonic)
-        {
-            current_direction = 0;
-            break;
-        }
-        else if (!monotonicity.is_positive)
-        {
-            current_direction *= -1;
-        }
+            return {};
+
+        /// If function is not strict monotonic, it can break order
+        /// if it's not last in the prefix of sort description.
+        /// E.g. if we have ORDER BY (d, u) -- ('2020-01-01', 1), ('2020-01-02', 0), ('2020-01-03', 1)
+        /// ORDER BY (toStartOfMonth(d), u) -- ('2020-01-01', 1), ('2020-01-01', 0), ('2020-01-01', 1)
+        if (!monotonicity.is_strict)
+            result.is_last_key = true;
+
+        if (!monotonicity.is_positive)
+            result.direction *= -1;
     }
 
     if (!found_function)
-        current_direction = 0;
+        return {};
 
-    return current_direction;
+    return result;
 }
 
 }
@@ -218,8 +217,8 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(
         if (forbidden_columns.contains(description[desc_pos].column_name))
             break;
 
-        int current_direction = matchSortDescriptionAndKey(actions[desc_pos]->getActions(), description[desc_pos], sorting_key_columns[key_pos]);
-        bool is_matched = current_direction && (desc_pos == 0 || current_direction == read_direction);
+        auto match = matchSortDescriptionAndKey(actions[desc_pos]->getActions(), description[desc_pos], sorting_key_columns[key_pos]);
+        bool is_matched = match.direction && (desc_pos == 0 || match.direction == read_direction);
 
         if (!is_matched)
         {
@@ -235,12 +234,15 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(
         }
 
         if (desc_pos == 0)
-            read_direction = current_direction;
+            read_direction = match.direction;
 
         sort_description_for_merging.push_back(description[desc_pos]);
 
         ++desc_pos;
         ++key_pos;
+
+        if (match.is_last_key)
+            break;
     }
 
     if (sort_description_for_merging.empty())
