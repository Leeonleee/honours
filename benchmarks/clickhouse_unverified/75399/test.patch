diff --git a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference
index 401d4d493a82..070f1191d535 100644
--- a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference
+++ b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.reference
@@ -35,6 +35,8 @@ abc	a	abca
 abc	a	abca
 bc	a	abca
 bc	a	abca
+abc
+c
 5	2019-05-05
 5	2019-05-05
 123	1234	123
diff --git a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql
index 423bb619b001..40e4122ad6e6 100644
--- a/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql
+++ b/tests/queries/0_stateless/02267_special_operator_parse_alias_check.sql
@@ -59,6 +59,10 @@ SELECT trim(TRAILING 'a' arg_1 FROM 'abca' arg_2), arg_1, arg_2;
 SELECT trim(BOTH 'a' AS arg_1 FROM 'abca' AS arg_2), arg_1, arg_2;
 SELECT trim(BOTH 'a' arg_1 FROM 'abca' arg_2), arg_1, arg_2;
 
+-- Bug #69922
+SELECT trim(LEADING concat('') FROM 'abc');
+SELECT trim(LEADING concat('a', 'b') FROM 'abc');
+
 -- EXTRACT expression
 
 -- EXTRACT(part FROM date)
diff --git a/tests/queries/0_stateless/03315_trim_two_args.reference b/tests/queries/0_stateless/03315_trim_two_args.reference
new file mode 100644
index 000000000000..4f1d5d1b5ebf
--- /dev/null
+++ b/tests/queries/0_stateless/03315_trim_two_args.reference
@@ -0,0 +1,21 @@
+Basic custom character trimming
+1	1	1
+Same as before but with non-const input strings
+1	1	1
+Multiple different characters to trim
+1	1	1
+Empty trim character string
+1	1	1
+Empty string to trim
+1	1	1
+String containing only trim characters
+1	1	1
+Characters that have special meaning in regex
+1	1	1
+Very long input strings
+1	1	1
+Overlapping trim characters
+1	1	1
+Same trim characters provided more than once
+1	1	1
+Negative tests
diff --git a/tests/queries/0_stateless/03315_trim_two_args.sql b/tests/queries/0_stateless/03315_trim_two_args.sql
new file mode 100644
index 000000000000..c9ed8157fcbe
--- /dev/null
+++ b/tests/queries/0_stateless/03315_trim_two_args.sql
@@ -0,0 +1,70 @@
+-- Tests the second argument (custom trim charactres) for functions trim, trimLeft and trimRight.
+
+SELECT 'Basic custom character trimming';
+SELECT
+    trimLeft('#@hello#@', '#@') = 'hello#@' as left_custom_ok,
+    trimRight('#@hello#@', '#@') = '#@hello' as right_custom_ok,
+    trimBoth('#@hello#@', '#@') = 'hello' as both_custom_ok;
+
+SELECT 'Same as before but with non-const input strings';
+SELECT
+    trimLeft(materialize('#@hello#@'), '#@') = 'hello#@' as left_custom_ok,
+    trimRight(materialize('#@hello#@'), '#@') = '#@hello' as right_custom_ok,
+    trimBoth(materialize('#@hello#@'), '#@') = 'hello' as both_custom_ok;
+
+SELECT 'Multiple different characters to trim';
+SELECT
+    trimLeft('##@@hello##@@', '#@') = 'hello##@@' as left_multi_ok,
+    trimRight('##@@hello##@@', '#@') = '##@@hello' as right_multi_ok,
+    trimBoth('##@@hello##@@', '#@') = 'hello' as both_multi_ok;
+
+SELECT 'Empty trim character string';
+SELECT
+    trimLeft('  hello  ', '') = '  hello  ' as left_empty_chars_ok,
+    trimRight('  hello  ', '') = '  hello  ' as right_empty_chars_ok,
+    trimBoth('  hello  ', '') = '  hello  ' as both_empty_chars_ok;
+
+SELECT 'Empty string to trim';
+SELECT
+    trimLeft('', '#@') = '' as left_empty_str_ok,
+    trimRight('', '#@') = '' as right_empty_str_ok,
+    trimBoth('', '#@') = '' as both_empty_str_ok;
+
+SELECT 'String containing only trim characters';
+SELECT
+    trimLeft('####', '#') = '' as left_only_trim_chars_ok,
+    trimRight('####', '#') = '' as right_only_trim_chars_ok,
+    trimBoth('####', '#') = '' as both_only_trim_chars_ok;
+
+SELECT 'Characters that have special meaning in regex';
+SELECT
+    trimLeft('...hello...', '.') = 'hello...' as left_special_ok,
+    trimRight('...hello...', '.') = '...hello' as right_special_ok,
+    trimBoth('...hello...', '.') = 'hello' as both_special_ok;
+
+SELECT 'Very long input strings';
+WITH
+    repeat('x', 1000) as long_str,
+    repeat('#@', 50) as trim_chars
+SELECT
+    length(trimLeft(concat(trim_chars, long_str, trim_chars), '#@')) = 1100 as left_long_ok,
+    length(trimRight(concat(trim_chars, long_str, trim_chars), '#@')) = 1100 as right_long_ok,
+    length(trimBoth(concat(trim_chars, long_str, trim_chars), '#@')) = 1000 as both_long_ok;
+
+SELECT 'Overlapping trim characters';
+SELECT
+    trimLeft('aabbccHELLOccbbaa', 'abc') = 'HELLOccbbaa' as left_overlap_ok,
+    trimRight('aabbccHELLOccbbaa', 'abc') = 'aabbccHELLO' as right_overlap_ok,
+    trimBoth('aabbccHELLOccbbaa', 'abc') = 'HELLO' as both_overlap_ok;
+
+SELECT 'Same trim characters provided more than once';
+SELECT
+    trimLeft('#@hello#@', '#@#@') = 'hello#@' as left_custom_ok,
+    trimRight('#@hello#@', '#@#@') = '#@hello' as right_custom_ok,
+    trimBoth('#@hello#@', '#@#@') = 'hello' as both_custom_ok;
+
+SELECT 'Negative tests';
+SELECT trimLeft('hello', 'a', 'b'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }
+SELECT trimRight(123, 'a'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+SELECT trimBoth('hello', 123); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+SELECT trimBoth('hello', materialize('a')); -- { serverError ILLEGAL_COLUMN }
