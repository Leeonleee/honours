diff --git a/base/base/find_symbols.h b/base/base/find_symbols.h
index eb1290dd2894..ae6849c4fc16 100644
--- a/base/base/find_symbols.h
+++ b/base/base/find_symbols.h
@@ -3,6 +3,7 @@
 #include <cstdint>
 #include <string>
 #include <array>
+#include <string_view>
 
 #if defined(__SSE2__)
     #include <emmintrin.h>
@@ -51,7 +52,7 @@ struct SearchSymbols
 #if defined(__SSE4_2__)
         if (str.size() > BUFFER_SIZE)
         {
-            throw std::runtime_error("SearchSymbols can contain at most " + std::to_string(BUFFER_SIZE) + " symbols and " + std::to_string(str.size()) + " was provided
");
+            throw std::runtime_error("SearchSymbols may contain at most " + std::to_string(BUFFER_SIZE) + " symbols but " + std::to_string(str.size()) + " symbols were provided");
         }
 
         char tmp_safety_buffer[BUFFER_SIZE] = {0};
@@ -236,6 +237,32 @@ inline const char * find_last_symbols_sse2(const char * const begin, const char
     return return_mode == ReturnMode::End ? end : nullptr;
 }
 
+template <bool positive, ReturnMode return_mode>
+inline const char * find_last_symbols_sse2(const char * const begin, const char * const end, const char * symbols, size_t num_chars)
+{
+    const char * pos = end;
+
+#if defined(__SSE2__)
+    const auto needles = mm_is_in_prepare(symbols, num_chars);
+    for (; pos - 16 >= begin; pos -= 16)
+    {
+        __m128i bytes = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pos - 16));
+
+        __m128i eq = mm_is_in_execute(bytes, needles);
+
+        uint16_t bit_mask = maybe_negate<positive>(uint16_t(_mm_movemask_epi8(eq)));
+        if (bit_mask)
+            return pos - 1 - (__builtin_clz(bit_mask) - 16);    /// because __builtin_clz works with mask as uint32.
+    }
+#endif
+
+    --pos;
+    for (; pos >= begin; --pos)
+        if (maybe_negate<positive>(is_in(*pos, symbols, num_chars)))
+            return pos;
+
+    return return_mode == ReturnMode::End ? end : nullptr;
+}
 
 template <bool positive, ReturnMode return_mode, size_t num_chars,
     char c01,     char c02 = 0, char c03 = 0, char c04 = 0,
@@ -348,6 +375,19 @@ inline const char * find_first_symbols_dispatch(const std::string_view haystack,
     return find_first_symbols_sse2<positive, return_mode>(haystack.begin(), haystack.end(), symbols.str.data(), symbols.str.size());
 }
 
+template <bool positive, ReturnMode return_mode, char... symbols>
+inline const char * find_last_symbols_dispatch(const char * begin, const char * end)
+    requires(0 <= sizeof...(symbols) && sizeof...(symbols) <= 16)
+{
+    return find_last_symbols_sse2<positive, return_mode, symbols...>(begin, end);
+}
+
+template <bool positive, ReturnMode return_mode>
+inline const char * find_last_symbols_dispatch(const std::string_view haystack, const SearchSymbols & symbols)
+{
+    return find_last_symbols_sse2<positive, return_mode>(haystack.begin(), haystack.end(), symbols.str.data(), symbols.str.size());
+}
+
 }
 
 
@@ -424,25 +464,35 @@ inline const char * find_first_not_symbols_or_null(std::string_view haystack, co
 template <char... symbols>
 inline const char * find_last_symbols_or_null(const char * begin, const char * end)
 {
-    return detail::find_last_symbols_sse2<true, detail::ReturnMode::Nullptr, symbols...>(begin, end);
+    return detail::find_last_symbols_dispatch<true, detail::ReturnMode::Nullptr, symbols...>(begin, end);
 }
 
 template <char... symbols>
 inline char * find_last_symbols_or_null(char * begin, char * end)
 {
-    return const_cast<char *>(detail::find_last_symbols_sse2<true, detail::ReturnMode::Nullptr, symbols...>(begin, end));
+    return const_cast<char *>(detail::find_last_symbols_dispatch<true, detail::ReturnMode::Nullptr, symbols...>(begin, end));
+}
+
+inline const char * find_last_symbols_or_null(std::string_view haystack, const SearchSymbols & symbols)
+{
+    return detail::find_last_symbols_dispatch<true, detail::ReturnMode::Nullptr>(haystack, symbols);
 }
 
 template <char... symbols>
 inline const char * find_last_not_symbols_or_null(const char * begin, const char * end)
 {
-    return detail::find_last_symbols_sse2<false, detail::ReturnMode::Nullptr, symbols...>(begin, end);
+    return detail::find_last_symbols_dispatch<false, detail::ReturnMode::Nullptr, symbols...>(begin, end);
 }
 
 template <char... symbols>
 inline char * find_last_not_symbols_or_null(char * begin, char * end)
 {
-    return const_cast<char *>(detail::find_last_symbols_sse2<false, detail::ReturnMode::Nullptr, symbols...>(begin, end));
+    return const_cast<char *>(detail::find_last_symbols_dispatch<false, detail::ReturnMode::Nullptr, symbols...>(begin, end));
+}
+
+inline const char * find_last_not_symbols_or_null(std::string_view haystack, const SearchSymbols & symbols)
+{
+    return detail::find_last_symbols_dispatch<false, detail::ReturnMode::Nullptr>(haystack, symbols);
 }
 
 template <char... symbols>
diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md
index bd85c0f553e2..9d84cbc69d6c 100644
--- a/docs/en/sql-reference/functions/string-functions.md
+++ b/docs/en/sql-reference/functions/string-functions.md
@@ -1473,7 +1473,7 @@ trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)
 
 **Arguments**
 
-- `trim_character` — Specified characters for trim. [String](../data-types/string.md).
+- `trim_character` — The characters to trim. [String](../data-types/string.md).
 - `input_string` — String for trim. [String](../data-types/string.md).
 
 **Returned value**
@@ -1501,14 +1501,15 @@ Removes the consecutive occurrences of whitespace (ASCII-character 32) from the
 **Syntax**
 
 ``` sql
-trimLeft(input_string)
+trimLeft(input_string[, trim_characters])
 ```
 
-Alias: `ltrim(input_string)`.
+Alias: `ltrim`.
 
 **Arguments**
 
-- `input_string` — string to trim. [String](../data-types/string.md).
+- `input_string` — The string to trim. [String](../data-types/string.md).
+- `trim_characters` — The characters to trim. Optional. [String](../data-types/string.md). If not specified, `' '` ( single whitespace) is used as trim character.
 
 **Returned value**
 
@@ -1535,14 +1536,15 @@ Removes the consecutive occurrences of whitespace (ASCII-character 32) from the
 **Syntax**
 
 ``` sql
-trimRight(input_string)
+trimRight(input_string[, trim_characters])
 ```
 
-Alias: `rtrim(input_string)`.
+Alias: `rtrim`.
 
 **Arguments**
 
-- `input_string` — string to trim. [String](../data-types/string.md).
+- `input_string` — The string to trim. [String](../data-types/string.md).
+- `trim_characters` — The characters to trim. Optional. [String](../data-types/string.md). If not specified, `' '` ( single whitespace) is used as trim character.
 
 **Returned value**
 
@@ -1569,14 +1571,15 @@ Removes the consecutive occurrences of whitespace (ASCII-character 32) from both
 **Syntax**
 
 ``` sql
-trimBoth(input_string)
+trimBoth(input_string[, trim_characters])
 ```
 
-Alias: `trim(input_string)`.
+Alias: `trim`.
 
 **Arguments**
 
-- `input_string` — string to trim. [String](../data-types/string.md).
+- `input_string` — The string to trim. [String](../data-types/string.md).
+- `trim_characters` — The characters to trim. Optional. [String](../data-types/string.md). If not specified, `' '` ( single whitespace) is used as trim character.
 
 **Returned value**
 
diff --git a/src/Functions/trim.cpp b/src/Functions/trim.cpp
index 5703e8714239..869c8516d4dd 100644
--- a/src/Functions/trim.cpp
+++ b/src/Functions/trim.cpp
@@ -1,53 +1,80 @@
 #include <Columns/ColumnString.h>
+#include "Columns/IColumn.h"
+#include "Functions/IFunction.h"
 #include <Functions/FunctionFactory.h>
-#include <Functions/FunctionStringToString.h>
+#include <Functions/FunctionHelpers.h>
 #include <base/find_symbols.h>
 
-
 namespace DB
 {
 namespace ErrorCodes
 {
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int ILLEGAL_COLUMN;
 }
 
 namespace
 {
 
-struct TrimModeLeft
+template <typename Mode>
+class FunctionTrim : public IFunction
 {
-    static constexpr auto name = "trimLeft";
-    static constexpr bool trim_left = true;
-    static constexpr bool trim_right = false;
-};
+public:
+    static constexpr auto name = Mode::name;
 
-struct TrimModeRight
-{
-    static constexpr auto name = "trimRight";
-    static constexpr bool trim_left = false;
-    static constexpr bool trim_right = true;
-};
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTrim<Mode>>(); }
+    String getName() const override { return name; }
+    bool isVariadic() const override { return true; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    size_t getNumberOfArguments() const override { return 0; }
 
-struct TrimModeBoth
-{
-    static constexpr auto name = "trimBoth";
-    static constexpr bool trim_left = true;
-    static constexpr bool trim_right = true;
-};
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        FunctionArgumentDescriptors mandatory_args{
+            {"input_string", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, "String"}
+        };
+
+        FunctionArgumentDescriptors optional_args{
+            {"trim_character", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), isColumnConst, "const String"}
+        };
+
+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);
+
+        return arguments[0].type;
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        std::optional<SearchSymbols> custom_trim_characters;
+        if (arguments.size() == 2 && input_rows_count > 0)
+        {
+            const ColumnConst * col_trim_characters_const = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());
+            const String & trim_characters_string = col_trim_characters_const->getDataAt(0).toString();
+            custom_trim_characters = std::make_optional<SearchSymbols>(trim_characters_string);
+        }
+
+        ColumnPtr col_input_full;
+        col_input_full = arguments[0].column->convertToFullColumnIfConst();
+
+        if (const ColumnString * col_input_string = checkAndGetColumn<ColumnString>(col_input_full.get()))
+        {
+            auto col_res = ColumnString::create();
+            vector(col_input_string->getChars(), col_input_string->getOffsets(), custom_trim_characters, col_res->getChars(), col_res->getOffsets(), input_rows_count);
+            return col_res;
+        }
+        throw Exception(
+            ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of argument of function {}", arguments[0].column->getName(), getName());
+    }
 
-template <typename Mode>
-class FunctionTrimImpl
-{
-public:
     static void vector(
-        const ColumnString::Chars & data,
-        const ColumnString::Offsets & offsets,
+        const ColumnString::Chars & input_data,
+        const ColumnString::Offsets & input_offsets,
+        const std::optional<SearchSymbols> & custom_trim_characters,
         ColumnString::Chars & res_data,
         ColumnString::Offsets & res_offsets,
         size_t input_rows_count)
     {
         res_offsets.resize_exact(input_rows_count);
-        res_data.reserve_exact(data.size());
+        res_data.reserve_exact(input_data.size());
 
         size_t prev_offset = 0;
         size_t res_offset = 0;
@@ -57,7 +84,7 @@ class FunctionTrimImpl
 
         for (size_t i = 0; i < input_rows_count; ++i)
         {
-            execute(reinterpret_cast<const UInt8 *>(&data[prev_offset]), offsets[i] - prev_offset - 1, start, length);
+            execute(reinterpret_cast<const UInt8 *>(&input_data[prev_offset]), input_offsets[i] - prev_offset - 1, custom_trim_characters, start, length);
 
             res_data.resize(res_data.size() + length + 1);
             memcpySmallAllowReadWriteOverflow15(&res_data[res_offset], start, length);
@@ -65,45 +92,73 @@ class FunctionTrimImpl
             res_data[res_offset - 1] = '\0';
 
             res_offsets[i] = res_offset;
-            prev_offset = offsets[i];
+            prev_offset = input_offsets[i];
         }
     }
 
-    static void vectorFixed(const ColumnString::Chars &, size_t, ColumnString::Chars &, size_t)
+    static void execute(const UInt8 * data, size_t size, const std::optional<SearchSymbols> & custom_trim_characters, const UInt8 *& res_data, size_t & res_size)
     {
-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Functions trimLeft, trimRight and trimBoth cannot work with FixedString argument");
-    }
-
-private:
-    static void execute(const UInt8 * data, size_t size, const UInt8 *& res_data, size_t & res_size)
-    {
-        const char * char_data = reinterpret_cast<const char *>(data);
-        const char * char_end = char_data + size;
+        const char * char_begin = reinterpret_cast<const char *>(data);
+        const char * char_end = char_begin + size;
 
         if constexpr (Mode::trim_left)
-        { // NOLINT
-            const char * found = find_first_not_symbols<' '>(char_data, char_end);
-            size_t num_chars = found - char_data;
-            char_data += num_chars;
+        {
+            const char * found = nullptr;
+            if (!custom_trim_characters)
+                found = find_first_not_symbols<' '>(char_begin, char_end);
+            else
+            {
+                std::string_view input(char_begin, char_end);
+                found = find_first_not_symbols(input, *custom_trim_characters);
+            }
+            size_t num_chars = found - char_begin;
+            char_begin += num_chars;
         }
-
         if constexpr (Mode::trim_right)
-        { // NOLINT
-            const char * found = find_last_not_symbols_or_null<' '>(char_data, char_end);
+        {
+            const char * found = nullptr;
+            if (!custom_trim_characters)
+                found = find_last_not_symbols_or_null<' '>(char_begin, char_end);
+            else
+            {
+                std::string_view input(char_begin, char_end);
+                found = find_last_not_symbols_or_null(input, *custom_trim_characters);
+            }
             if (found)
                 char_end = found + 1;
             else
-                char_end = char_data;
+                char_end = char_begin;
         }
 
-        res_data = reinterpret_cast<const UInt8 *>(char_data);
-        res_size = char_end - char_data;
+        res_data = reinterpret_cast<const UInt8 *>(char_begin);
+        res_size = char_end - char_begin;
     }
 };
 
-using FunctionTrimLeft = FunctionStringToString<FunctionTrimImpl<TrimModeLeft>, TrimModeLeft>;
-using FunctionTrimRight = FunctionStringToString<FunctionTrimImpl<TrimModeRight>, TrimModeRight>;
-using FunctionTrimBoth = FunctionStringToString<FunctionTrimImpl<TrimModeBoth>, TrimModeBoth>;
+struct TrimModeLeft
+{
+    static constexpr auto name = "trimLeft";
+    static constexpr bool trim_left = true;
+    static constexpr bool trim_right = false;
+};
+
+struct TrimModeRight
+{
+    static constexpr auto name = "trimRight";
+    static constexpr bool trim_left = false;
+    static constexpr bool trim_right = true;
+};
+
+struct TrimModeBoth
+{
+    static constexpr auto name = "trimBoth";
+    static constexpr bool trim_left = true;
+    static constexpr bool trim_right = true;
+};
+
+using FunctionTrimLeft = FunctionTrim<TrimModeLeft>;
+using FunctionTrimRight = FunctionTrim<TrimModeRight>;
+using FunctionTrimBoth = FunctionTrim<TrimModeBoth>;
 
 }
 
diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp
index da9a93beb2a1..35f53eec3710 100644
--- a/src/Parsers/ExpressionListParsers.cpp
+++ b/src/Parsers/ExpressionListParsers.cpp
@@ -30,6 +30,7 @@
 #include <Parsers/Kusto/ParserKQLStatement.h>
 
 #include <AggregateFunctions/AggregateFunctionFactory.h>
+#include <fmt/core.h>
 
 using namespace std::literals;
 
@@ -1617,7 +1618,10 @@ class TrimLayer : public Layer
 {
 public:
     TrimLayer(bool trim_left_, bool trim_right_)
-        : Layer(/*allow_alias*/ true, /*allow_alias_without_as_keyword*/ true), trim_left(trim_left_), trim_right(trim_right_) {}
+        : Layer(/*allow_alias*/ true, /*allow_alias_without_as_keyword*/ true)
+        , trim_left(trim_left_)
+        , trim_right(trim_right_)
+    {}
 
     bool parse(IParser::Pos & pos, Expected & expected, Action & action) override
     {
@@ -1675,7 +1679,7 @@ class TrimLayer : public Layer
                 if (!mergeElement())
                     return false;
 
-                /// Trimming an empty string is a no-op.
+                /// Trimming an empty string is a no-op. (shortcut that works when we supply an empty string as the first argument)
                 ASTLiteral * ast_literal = typeid_cast<ASTLiteral *>(elements[0].get());
                 if (ast_literal && ast_literal->value.getType() == Field::Types::String && ast_literal->value.safeGet<String>().empty())
                 {
@@ -1683,7 +1687,7 @@ class TrimLayer : public Layer
                 }
                 else
                 {
-                    to_remove = makeASTFunction("regexpQuoteMeta", elements[0]);
+                    to_remove = std::move(elements[0]);
                     elements.clear();
                 }
 
@@ -1702,72 +1706,17 @@ class TrimLayer : public Layer
                 {
                     /// The operation does nothing.
                 }
-                if (char_override)
-                {
-                    ASTPtr pattern_node;
-
-                    auto pattern_func_node = std::make_shared<ASTFunction>();
-                    auto pattern_list_args = std::make_shared<ASTExpressionList>();
-                    if (trim_left && trim_right)
-                    {
-                        pattern_list_args->children =
-                        {
-                            std::make_shared<ASTLiteral>("^["),
-                            to_remove,
-                            std::make_shared<ASTLiteral>("]+|["),
-                            to_remove,
-                            std::make_shared<ASTLiteral>("]+$")
-                        };
-                        function_name = "replaceRegexpAll";
-                    }
-                    else
-                    {
-                        if (trim_left)
-                        {
-                            pattern_list_args->children =
-                            {
-                                std::make_shared<ASTLiteral>("^["),
-                                to_remove,
-                                std::make_shared<ASTLiteral>("]+")
-                            };
-                        }
-                        else
-                        {
-                            /// trim_right == false not possible
-                            pattern_list_args->children =
-                            {
-                                std::make_shared<ASTLiteral>("["),
-                                to_remove,
-                                std::make_shared<ASTLiteral>("]+$")
-                            };
-                        }
-                        function_name = "replaceRegexpOne";
-                    }
-
-                    pattern_func_node->name = "concat";
-                    pattern_func_node->arguments = std::move(pattern_list_args);
-                    pattern_func_node->children.push_back(pattern_func_node->arguments);
-
-                    pattern_node = std::move(pattern_func_node);
-
-                    elements.push_back(pattern_node);
-                    elements.push_back(std::make_shared<ASTLiteral>(""));
-                }
+                if (trim_left && trim_right)
+                    function_name = "trimBoth";
+                else if (trim_left)
+                    function_name = "trimLeft";
                 else
+                    function_name = "trimRight";
+
+                if (char_override && to_remove)
                 {
-                    if (trim_left && trim_right)
-                    {
-                        function_name = "trimBoth";
-                    }
-                    else
-                    {
-                        if (trim_left)
-                            function_name = "trimLeft";
-                        else
-                            function_name = "trimRight";
-                    }
+                    elements.push_back(std::move(to_remove));
                 }
-
                 finished = true;
             }
         }
