diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 76f199d8e417..08e9da3f0037 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -2592,7 +2592,7 @@ void InterpreterSelectQuery::executeOrderOptimized(QueryPlan & query_plan, Input
 
     auto finish_sorting_step = std::make_unique<SortingStep>(
         query_plan.getCurrentDataStream(),
-        input_sorting_info->order_key_prefix_descr,
+        input_sorting_info->sort_description_for_merging,
         output_order_descr,
         settings.max_block_size,
         limit);
diff --git a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp b/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp
index 4d3c268ab7e3..2d7b03139550 100644
--- a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp
+++ b/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp
@@ -104,7 +104,7 @@ size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node,
     if (order_info)
     {
         read_from_merge_tree->setQueryInfoInputOrderInfo(order_info);
-        sorting->convertToFinishSorting(order_info->order_key_prefix_descr);
+        sorting->convertToFinishSorting(order_info->sort_description_for_merging);
     }
 
     return 0;
diff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp
index d7dae54bb1e6..945fa970cec4 100644
--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp
+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp
@@ -548,9 +548,7 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(
 
     if (need_preliminary_merge)
     {
-        size_t fixed_prefix_size = input_order_info->order_key_fixed_prefix_descr.size();
-        size_t prefix_size = fixed_prefix_size + input_order_info->order_key_prefix_descr.size();
-
+        size_t prefix_size = input_order_info->used_prefix_of_sorting_key_size;
         auto order_key_prefix_ast = metadata_for_reading->getSortingKey().expression_list_ast->clone();
         order_key_prefix_ast->children.resize(prefix_size);
 
diff --git a/src/Processors/Transforms/AggregatingInOrderTransform.cpp b/src/Processors/Transforms/AggregatingInOrderTransform.cpp
index ce50ae5eeee8..2c7a4e231193 100644
--- a/src/Processors/Transforms/AggregatingInOrderTransform.cpp
+++ b/src/Processors/Transforms/AggregatingInOrderTransform.cpp
@@ -41,13 +41,13 @@ AggregatingInOrderTransform::AggregatingInOrderTransform(
     /// We won't finalize states in order to merge same states (generated due to multi-thread execution) in AggregatingSortedTransform
     res_header = params->getCustomHeader(/* final_= */ false);
 
-    for (size_t i = 0; i < group_by_info->order_key_prefix_descr.size(); ++i)
+    for (size_t i = 0; i < group_by_info->sort_description_for_merging.size(); ++i)
     {
         const auto & column_description = group_by_description_[i];
         group_by_description.emplace_back(column_description, res_header.getPositionByName(column_description.column_name));
     }
 
-    if (group_by_info->order_key_prefix_descr.size() < group_by_description_.size())
+    if (group_by_info->sort_description_for_merging.size() < group_by_description_.size())
     {
         group_by_key = true;
         /// group_by_description may contains duplicates, so we use keys_size from Aggregator::params
diff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
index c5f546a9c364..c024e5da7b5d 100644
--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
@@ -242,7 +242,7 @@ QueryPlanPtr MergeTreeDataSelectExecutor::read(
 
             auto sorting_step = std::make_unique<SortingStep>(
                 projection_plan->getCurrentDataStream(),
-                query_info.projection->input_order_info->order_key_prefix_descr,
+                query_info.projection->input_order_info->sort_description_for_merging,
                 output_order_descr,
                 settings.max_block_size,
                 limit);
diff --git a/src/Storages/ReadInOrderOptimizer.cpp b/src/Storages/ReadInOrderOptimizer.cpp
index b188cef065ef..b67da14365e1 100644
--- a/src/Storages/ReadInOrderOptimizer.cpp
+++ b/src/Storages/ReadInOrderOptimizer.cpp
@@ -5,10 +5,12 @@
 #include <Interpreters/TreeRewriter.h>
 #include <Interpreters/replaceAliasColumnsInQuery.h>
 #include <Functions/IFunction.h>
+#include <Functions/FunctionFactory.h>
 #include <Interpreters/TableJoin.h>
 #include <Interpreters/Context.h>
 #include <Parsers/ASTSelectQuery.h>
 #include <Parsers/ASTFunction.h>
+#include <Parsers/ASTIdentifier.h>
 
 namespace DB
 {
@@ -21,26 +23,46 @@ namespace ErrorCodes
 namespace
 {
 
-ASTPtr getFixedPoint(const ASTPtr & ast)
+/// Finds expression like x = 'y' or f(x) = 'y',
+/// where `x` is identifier, 'y' is literal and `f` is injective functions.
+ASTPtr getFixedPoint(const ASTPtr & ast, const ContextPtr & context)
 {
     const auto * func = ast->as<ASTFunction>();
     if (!func || func->name != "equals")
         return nullptr;
 
+    if (!func->arguments || func->arguments->children.size() != 2)
+        return nullptr;
+
     const auto & lhs = func->arguments->children[0];
     const auto & rhs = func->arguments->children[1];
 
-    if (lhs->as<ASTLiteral>())
-        return rhs;
+    if (!lhs->as<ASTLiteral>() && !rhs->as<ASTLiteral>())
+        return nullptr;
+
+    /// Case of two literals doesn't make sense.
+    if (lhs->as<ASTLiteral>() && rhs->as<ASTLiteral>())
+        return nullptr;
+
+    /// If indetifier is wrapped into injective functions, remove them.
+    auto argument = lhs->as<ASTLiteral>() ? rhs : lhs;
+    while (const auto * arg_func = argument->as<ASTFunction>())
+    {
+        if (!arg_func->arguments || arg_func->arguments->children.size() != 1)
+            return nullptr;
 
-    if (rhs->as<ASTLiteral>())
-        return lhs;
+        auto func_resolver = FunctionFactory::instance().tryGet(arg_func->name, context);
+        if (!func_resolver || !func_resolver->isInjective({}))
+            return nullptr;
 
-    return nullptr;
+        argument = arg_func->arguments->children[0];
+    }
+
+    return argument->as<ASTIdentifier>() ? argument : nullptr;
 }
 
-size_t calculateFixedPrefixSize(
-    const ASTSelectQuery & query, const Names & sorting_key_columns)
+NameSet getFixedSortingColumns(
+    const ASTSelectQuery & query, const Names & sorting_key_columns, const ContextPtr & context)
 {
     ASTPtr condition;
     if (query.where() && query.prewhere())
@@ -51,14 +73,15 @@ size_t calculateFixedPrefixSize(
         condition = query.prewhere();
 
     if (!condition)
-        return 0;
+        return {};
 
     /// Convert condition to CNF for more convenient analysis.
     auto cnf = TreeCNFConverter::tryConvertToCNF(condition);
     if (!cnf)
-        return 0;
+        return {};
 
     NameSet fixed_points;
+    NameSet sorting_key_columns_set(sorting_key_columns.begin(), sorting_key_columns.end());
 
     /// If we met expression like 'column = x', where 'x' is literal,
     /// in clause of size 1 in CNF, then we can guarantee
@@ -67,22 +90,17 @@ size_t calculateFixedPrefixSize(
     {
         if (group.size() == 1 && !group.begin()->negative)
         {
-            auto fixed_point = getFixedPoint(group.begin()->ast);
+            auto fixed_point = getFixedPoint(group.begin()->ast, context);
             if (fixed_point)
-                fixed_points.insert(fixed_point->getColumnName());
+            {
+                auto column_name = fixed_point->getColumnName();
+                if (sorting_key_columns_set.contains(column_name))
+                    fixed_points.insert(column_name);
+            }
         }
     });
 
-    size_t prefix_size = 0;
-    for (const auto & column_name : sorting_key_columns)
-    {
-        if (!fixed_points.contains(column_name))
-            break;
-
-        ++prefix_size;
-    }
-
-    return prefix_size;
+    return fixed_points;
 }
 
 /// Optimize in case of exact match with order key element
@@ -181,46 +199,54 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(
     const StorageMetadataPtr & metadata_snapshot,
     const SortDescription & description,
     const ManyExpressionActions & actions,
+    const ContextPtr & context,
     UInt64 limit) const
 {
     auto sorting_key_columns = metadata_snapshot->getSortingKeyColumns();
     int read_direction = description.at(0).direction;
 
-    size_t fixed_prefix_size = calculateFixedPrefixSize(query, sorting_key_columns);
-    size_t descr_prefix_size = std::min(description.size(), sorting_key_columns.size() - fixed_prefix_size);
+    auto fixed_sorting_columns = getFixedSortingColumns(query, sorting_key_columns, context);
+
+    SortDescription sort_description_for_merging;
+    sort_description_for_merging.reserve(description.size());
 
-    SortDescription order_key_prefix_descr;
-    order_key_prefix_descr.reserve(descr_prefix_size);
+    size_t desc_pos = 0;
+    size_t key_pos = 0;
 
-    for (size_t i = 0; i < descr_prefix_size; ++i)
+    while (desc_pos < description.size() && key_pos < sorting_key_columns.size())
     {
-        if (forbidden_columns.contains(description[i].column_name))
+        if (forbidden_columns.contains(description[desc_pos].column_name))
             break;
 
-        int current_direction = matchSortDescriptionAndKey(
-            actions[i]->getActions(), description[i], sorting_key_columns[i + fixed_prefix_size]);
+        int current_direction = matchSortDescriptionAndKey(actions[desc_pos]->getActions(), description[desc_pos], sorting_key_columns[key_pos]);
+        bool is_matched = current_direction && (desc_pos == 0 || current_direction == read_direction);
+
+        if (!is_matched)
+        {
+            /// If one of the sorting columns is constant after filtering,
+            /// skip it, because it won't affect order anymore.
+            if (fixed_sorting_columns.contains(sorting_key_columns[key_pos]))
+            {
+                ++key_pos;
+                continue;
+            }
 
-        if (!current_direction || (i > 0 && current_direction != read_direction))
             break;
+        }
 
-        if (i == 0)
+        if (desc_pos == 0)
             read_direction = current_direction;
 
-        order_key_prefix_descr.push_back(required_sort_description[i]);
+        sort_description_for_merging.push_back(description[desc_pos]);
+
+        ++desc_pos;
+        ++key_pos;
     }
 
-    if (order_key_prefix_descr.empty())
+    if (sort_description_for_merging.empty())
         return {};
 
-    SortDescription order_key_fixed_prefix_descr;
-    order_key_fixed_prefix_descr.reserve(fixed_prefix_size);
-    for (size_t i = 0; i < fixed_prefix_size; ++i)
-        order_key_fixed_prefix_descr.emplace_back(sorting_key_columns[i], read_direction);
-
-    return std::make_shared<InputOrderInfo>(
-        std::move(order_key_fixed_prefix_descr),
-        std::move(order_key_prefix_descr),
-        read_direction, limit);
+    return std::make_shared<InputOrderInfo>(std::move(sort_description_for_merging), key_pos, read_direction, limit);
 }
 
 InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(
@@ -255,10 +281,10 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(
             aliases_actions[i] = expression_analyzer.getActions(true);
         }
 
-        return getInputOrderImpl(metadata_snapshot, aliases_sort_description, aliases_actions, limit);
+        return getInputOrderImpl(metadata_snapshot, aliases_sort_description, aliases_actions, context, limit);
     }
 
-    return getInputOrderImpl(metadata_snapshot, required_sort_description, elements_actions, limit);
+    return getInputOrderImpl(metadata_snapshot, required_sort_description, elements_actions, context, limit);
 }
 
 }
diff --git a/src/Storages/ReadInOrderOptimizer.h b/src/Storages/ReadInOrderOptimizer.h
index fd8c9187ddb5..161c321ae790 100644
--- a/src/Storages/ReadInOrderOptimizer.h
+++ b/src/Storages/ReadInOrderOptimizer.h
@@ -12,8 +12,6 @@ namespace DB
  *   common prefix, which is needed for
  *   performing reading in order of PK.
  */
-class Context;
-
 class ReadInOrderOptimizer
 {
 public:
@@ -30,6 +28,7 @@ class ReadInOrderOptimizer
         const StorageMetadataPtr & metadata_snapshot,
         const SortDescription & description,
         const ManyExpressionActions & actions,
+        const ContextPtr & context,
         UInt64 limit) const;
 
     /// Actions for every element of order expression to analyze functions for monotonicity
diff --git a/src/Storages/SelectQueryInfo.h b/src/Storages/SelectQueryInfo.h
index 758e4736fc1f..c41b422199d8 100644
--- a/src/Storages/SelectQueryInfo.h
+++ b/src/Storages/SelectQueryInfo.h
@@ -101,17 +101,33 @@ struct FilterDAGInfo
 
 struct InputOrderInfo
 {
-    SortDescription order_key_fixed_prefix_descr;
-    SortDescription order_key_prefix_descr;
+    /// Sort description for merging of already sorted streams.
+    /// Always a prefix of ORDER BY or GROUP BY description specified in query.
+    SortDescription sort_description_for_merging;
+
+    /** Size of prefix of sorting key that is already
+     * sorted before execution of sorting or aggreagation.
+     *
+     * Contains both columns that scpecified in
+     * ORDER BY or GROUP BY clause of query
+     * and columns that turned out to be already sorted.
+     *
+     * E.g. if we have sorting key ORDER BY (a, b, c, d)
+     * and query with `WHERE a = 'x' AND b = 'y' ORDER BY c, d` clauses.
+     * sort_description_for_merging will be equal to (c, d) and
+     * used_prefix_of_sorting_key_size will be equal to 4.
+     */
+    size_t used_prefix_of_sorting_key_size;
+
     int direction;
     UInt64 limit;
 
     InputOrderInfo(
-        const SortDescription & order_key_fixed_prefix_descr_,
-        const SortDescription & order_key_prefix_descr_,
+        const SortDescription & sort_description_for_merging_,
+        size_t used_prefix_of_sorting_key_size_,
         int direction_, UInt64 limit_)
-        : order_key_fixed_prefix_descr(order_key_fixed_prefix_descr_)
-        , order_key_prefix_descr(order_key_prefix_descr_)
+        : sort_description_for_merging(sort_description_for_merging_)
+        , used_prefix_of_sorting_key_size(used_prefix_of_sorting_key_size_)
         , direction(direction_), limit(limit_)
     {
     }
