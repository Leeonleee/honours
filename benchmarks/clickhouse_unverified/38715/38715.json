{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38715,
  "instance_id": "ClickHouse__ClickHouse-38715",
  "issue_numbers": [
    "38036"
  ],
  "base_commit": "d4a1b71b184a06f515fb3d8bb23f4c315528d815",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 76f199d8e417..08e9da3f0037 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -2592,7 +2592,7 @@ void InterpreterSelectQuery::executeOrderOptimized(QueryPlan & query_plan, Input\n \n     auto finish_sorting_step = std::make_unique<SortingStep>(\n         query_plan.getCurrentDataStream(),\n-        input_sorting_info->order_key_prefix_descr,\n+        input_sorting_info->sort_description_for_merging,\n         output_order_descr,\n         settings.max_block_size,\n         limit);\ndiff --git a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp b/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp\nindex 4d3c268ab7e3..2d7b03139550 100644\n--- a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp\n@@ -104,7 +104,7 @@ size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node,\n     if (order_info)\n     {\n         read_from_merge_tree->setQueryInfoInputOrderInfo(order_info);\n-        sorting->convertToFinishSorting(order_info->order_key_prefix_descr);\n+        sorting->convertToFinishSorting(order_info->sort_description_for_merging);\n     }\n \n     return 0;\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex d7dae54bb1e6..945fa970cec4 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -548,9 +548,7 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n \n     if (need_preliminary_merge)\n     {\n-        size_t fixed_prefix_size = input_order_info->order_key_fixed_prefix_descr.size();\n-        size_t prefix_size = fixed_prefix_size + input_order_info->order_key_prefix_descr.size();\n-\n+        size_t prefix_size = input_order_info->used_prefix_of_sorting_key_size;\n         auto order_key_prefix_ast = metadata_for_reading->getSortingKey().expression_list_ast->clone();\n         order_key_prefix_ast->children.resize(prefix_size);\n \ndiff --git a/src/Processors/Transforms/AggregatingInOrderTransform.cpp b/src/Processors/Transforms/AggregatingInOrderTransform.cpp\nindex ce50ae5eeee8..2c7a4e231193 100644\n--- a/src/Processors/Transforms/AggregatingInOrderTransform.cpp\n+++ b/src/Processors/Transforms/AggregatingInOrderTransform.cpp\n@@ -41,13 +41,13 @@ AggregatingInOrderTransform::AggregatingInOrderTransform(\n     /// We won't finalize states in order to merge same states (generated due to multi-thread execution) in AggregatingSortedTransform\n     res_header = params->getCustomHeader(/* final_= */ false);\n \n-    for (size_t i = 0; i < group_by_info->order_key_prefix_descr.size(); ++i)\n+    for (size_t i = 0; i < group_by_info->sort_description_for_merging.size(); ++i)\n     {\n         const auto & column_description = group_by_description_[i];\n         group_by_description.emplace_back(column_description, res_header.getPositionByName(column_description.column_name));\n     }\n \n-    if (group_by_info->order_key_prefix_descr.size() < group_by_description_.size())\n+    if (group_by_info->sort_description_for_merging.size() < group_by_description_.size())\n     {\n         group_by_key = true;\n         /// group_by_description may contains duplicates, so we use keys_size from Aggregator::params\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex c5f546a9c364..c024e5da7b5d 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -242,7 +242,7 @@ QueryPlanPtr MergeTreeDataSelectExecutor::read(\n \n             auto sorting_step = std::make_unique<SortingStep>(\n                 projection_plan->getCurrentDataStream(),\n-                query_info.projection->input_order_info->order_key_prefix_descr,\n+                query_info.projection->input_order_info->sort_description_for_merging,\n                 output_order_descr,\n                 settings.max_block_size,\n                 limit);\ndiff --git a/src/Storages/ReadInOrderOptimizer.cpp b/src/Storages/ReadInOrderOptimizer.cpp\nindex b188cef065ef..b67da14365e1 100644\n--- a/src/Storages/ReadInOrderOptimizer.cpp\n+++ b/src/Storages/ReadInOrderOptimizer.cpp\n@@ -5,10 +5,12 @@\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/replaceAliasColumnsInQuery.h>\n #include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n #include <Interpreters/TableJoin.h>\n #include <Interpreters/Context.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n \n namespace DB\n {\n@@ -21,26 +23,46 @@ namespace ErrorCodes\n namespace\n {\n \n-ASTPtr getFixedPoint(const ASTPtr & ast)\n+/// Finds expression like x = 'y' or f(x) = 'y',\n+/// where `x` is identifier, 'y' is literal and `f` is injective functions.\n+ASTPtr getFixedPoint(const ASTPtr & ast, const ContextPtr & context)\n {\n     const auto * func = ast->as<ASTFunction>();\n     if (!func || func->name != \"equals\")\n         return nullptr;\n \n+    if (!func->arguments || func->arguments->children.size() != 2)\n+        return nullptr;\n+\n     const auto & lhs = func->arguments->children[0];\n     const auto & rhs = func->arguments->children[1];\n \n-    if (lhs->as<ASTLiteral>())\n-        return rhs;\n+    if (!lhs->as<ASTLiteral>() && !rhs->as<ASTLiteral>())\n+        return nullptr;\n+\n+    /// Case of two literals doesn't make sense.\n+    if (lhs->as<ASTLiteral>() && rhs->as<ASTLiteral>())\n+        return nullptr;\n+\n+    /// If indetifier is wrapped into injective functions, remove them.\n+    auto argument = lhs->as<ASTLiteral>() ? rhs : lhs;\n+    while (const auto * arg_func = argument->as<ASTFunction>())\n+    {\n+        if (!arg_func->arguments || arg_func->arguments->children.size() != 1)\n+            return nullptr;\n \n-    if (rhs->as<ASTLiteral>())\n-        return lhs;\n+        auto func_resolver = FunctionFactory::instance().tryGet(arg_func->name, context);\n+        if (!func_resolver || !func_resolver->isInjective({}))\n+            return nullptr;\n \n-    return nullptr;\n+        argument = arg_func->arguments->children[0];\n+    }\n+\n+    return argument->as<ASTIdentifier>() ? argument : nullptr;\n }\n \n-size_t calculateFixedPrefixSize(\n-    const ASTSelectQuery & query, const Names & sorting_key_columns)\n+NameSet getFixedSortingColumns(\n+    const ASTSelectQuery & query, const Names & sorting_key_columns, const ContextPtr & context)\n {\n     ASTPtr condition;\n     if (query.where() && query.prewhere())\n@@ -51,14 +73,15 @@ size_t calculateFixedPrefixSize(\n         condition = query.prewhere();\n \n     if (!condition)\n-        return 0;\n+        return {};\n \n     /// Convert condition to CNF for more convenient analysis.\n     auto cnf = TreeCNFConverter::tryConvertToCNF(condition);\n     if (!cnf)\n-        return 0;\n+        return {};\n \n     NameSet fixed_points;\n+    NameSet sorting_key_columns_set(sorting_key_columns.begin(), sorting_key_columns.end());\n \n     /// If we met expression like 'column = x', where 'x' is literal,\n     /// in clause of size 1 in CNF, then we can guarantee\n@@ -67,22 +90,17 @@ size_t calculateFixedPrefixSize(\n     {\n         if (group.size() == 1 && !group.begin()->negative)\n         {\n-            auto fixed_point = getFixedPoint(group.begin()->ast);\n+            auto fixed_point = getFixedPoint(group.begin()->ast, context);\n             if (fixed_point)\n-                fixed_points.insert(fixed_point->getColumnName());\n+            {\n+                auto column_name = fixed_point->getColumnName();\n+                if (sorting_key_columns_set.contains(column_name))\n+                    fixed_points.insert(column_name);\n+            }\n         }\n     });\n \n-    size_t prefix_size = 0;\n-    for (const auto & column_name : sorting_key_columns)\n-    {\n-        if (!fixed_points.contains(column_name))\n-            break;\n-\n-        ++prefix_size;\n-    }\n-\n-    return prefix_size;\n+    return fixed_points;\n }\n \n /// Optimize in case of exact match with order key element\n@@ -181,46 +199,54 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(\n     const StorageMetadataPtr & metadata_snapshot,\n     const SortDescription & description,\n     const ManyExpressionActions & actions,\n+    const ContextPtr & context,\n     UInt64 limit) const\n {\n     auto sorting_key_columns = metadata_snapshot->getSortingKeyColumns();\n     int read_direction = description.at(0).direction;\n \n-    size_t fixed_prefix_size = calculateFixedPrefixSize(query, sorting_key_columns);\n-    size_t descr_prefix_size = std::min(description.size(), sorting_key_columns.size() - fixed_prefix_size);\n+    auto fixed_sorting_columns = getFixedSortingColumns(query, sorting_key_columns, context);\n+\n+    SortDescription sort_description_for_merging;\n+    sort_description_for_merging.reserve(description.size());\n \n-    SortDescription order_key_prefix_descr;\n-    order_key_prefix_descr.reserve(descr_prefix_size);\n+    size_t desc_pos = 0;\n+    size_t key_pos = 0;\n \n-    for (size_t i = 0; i < descr_prefix_size; ++i)\n+    while (desc_pos < description.size() && key_pos < sorting_key_columns.size())\n     {\n-        if (forbidden_columns.contains(description[i].column_name))\n+        if (forbidden_columns.contains(description[desc_pos].column_name))\n             break;\n \n-        int current_direction = matchSortDescriptionAndKey(\n-            actions[i]->getActions(), description[i], sorting_key_columns[i + fixed_prefix_size]);\n+        int current_direction = matchSortDescriptionAndKey(actions[desc_pos]->getActions(), description[desc_pos], sorting_key_columns[key_pos]);\n+        bool is_matched = current_direction && (desc_pos == 0 || current_direction == read_direction);\n+\n+        if (!is_matched)\n+        {\n+            /// If one of the sorting columns is constant after filtering,\n+            /// skip it, because it won't affect order anymore.\n+            if (fixed_sorting_columns.contains(sorting_key_columns[key_pos]))\n+            {\n+                ++key_pos;\n+                continue;\n+            }\n \n-        if (!current_direction || (i > 0 && current_direction != read_direction))\n             break;\n+        }\n \n-        if (i == 0)\n+        if (desc_pos == 0)\n             read_direction = current_direction;\n \n-        order_key_prefix_descr.push_back(required_sort_description[i]);\n+        sort_description_for_merging.push_back(description[desc_pos]);\n+\n+        ++desc_pos;\n+        ++key_pos;\n     }\n \n-    if (order_key_prefix_descr.empty())\n+    if (sort_description_for_merging.empty())\n         return {};\n \n-    SortDescription order_key_fixed_prefix_descr;\n-    order_key_fixed_prefix_descr.reserve(fixed_prefix_size);\n-    for (size_t i = 0; i < fixed_prefix_size; ++i)\n-        order_key_fixed_prefix_descr.emplace_back(sorting_key_columns[i], read_direction);\n-\n-    return std::make_shared<InputOrderInfo>(\n-        std::move(order_key_fixed_prefix_descr),\n-        std::move(order_key_prefix_descr),\n-        read_direction, limit);\n+    return std::make_shared<InputOrderInfo>(std::move(sort_description_for_merging), key_pos, read_direction, limit);\n }\n \n InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(\n@@ -255,10 +281,10 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrder(\n             aliases_actions[i] = expression_analyzer.getActions(true);\n         }\n \n-        return getInputOrderImpl(metadata_snapshot, aliases_sort_description, aliases_actions, limit);\n+        return getInputOrderImpl(metadata_snapshot, aliases_sort_description, aliases_actions, context, limit);\n     }\n \n-    return getInputOrderImpl(metadata_snapshot, required_sort_description, elements_actions, limit);\n+    return getInputOrderImpl(metadata_snapshot, required_sort_description, elements_actions, context, limit);\n }\n \n }\ndiff --git a/src/Storages/ReadInOrderOptimizer.h b/src/Storages/ReadInOrderOptimizer.h\nindex fd8c9187ddb5..161c321ae790 100644\n--- a/src/Storages/ReadInOrderOptimizer.h\n+++ b/src/Storages/ReadInOrderOptimizer.h\n@@ -12,8 +12,6 @@ namespace DB\n  *   common prefix, which is needed for\n  *   performing reading in order of PK.\n  */\n-class Context;\n-\n class ReadInOrderOptimizer\n {\n public:\n@@ -30,6 +28,7 @@ class ReadInOrderOptimizer\n         const StorageMetadataPtr & metadata_snapshot,\n         const SortDescription & description,\n         const ManyExpressionActions & actions,\n+        const ContextPtr & context,\n         UInt64 limit) const;\n \n     /// Actions for every element of order expression to analyze functions for monotonicity\ndiff --git a/src/Storages/SelectQueryInfo.h b/src/Storages/SelectQueryInfo.h\nindex 758e4736fc1f..c41b422199d8 100644\n--- a/src/Storages/SelectQueryInfo.h\n+++ b/src/Storages/SelectQueryInfo.h\n@@ -101,17 +101,33 @@ struct FilterDAGInfo\n \n struct InputOrderInfo\n {\n-    SortDescription order_key_fixed_prefix_descr;\n-    SortDescription order_key_prefix_descr;\n+    /// Sort description for merging of already sorted streams.\n+    /// Always a prefix of ORDER BY or GROUP BY description specified in query.\n+    SortDescription sort_description_for_merging;\n+\n+    /** Size of prefix of sorting key that is already\n+     * sorted before execution of sorting or aggreagation.\n+     *\n+     * Contains both columns that scpecified in\n+     * ORDER BY or GROUP BY clause of query\n+     * and columns that turned out to be already sorted.\n+     *\n+     * E.g. if we have sorting key ORDER BY (a, b, c, d)\n+     * and query with `WHERE a = 'x' AND b = 'y' ORDER BY c, d` clauses.\n+     * sort_description_for_merging will be equal to (c, d) and\n+     * used_prefix_of_sorting_key_size will be equal to 4.\n+     */\n+    size_t used_prefix_of_sorting_key_size;\n+\n     int direction;\n     UInt64 limit;\n \n     InputOrderInfo(\n-        const SortDescription & order_key_fixed_prefix_descr_,\n-        const SortDescription & order_key_prefix_descr_,\n+        const SortDescription & sort_description_for_merging_,\n+        size_t used_prefix_of_sorting_key_size_,\n         int direction_, UInt64 limit_)\n-        : order_key_fixed_prefix_descr(order_key_fixed_prefix_descr_)\n-        , order_key_prefix_descr(order_key_prefix_descr_)\n+        : sort_description_for_merging(sort_description_for_merging_)\n+        , used_prefix_of_sorting_key_size(used_prefix_of_sorting_key_size_)\n         , direction(direction_), limit(limit_)\n     {\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.reference b/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.reference\nnew file mode 100644\nindex 000000000000..fecc2acec7ee\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.reference\n@@ -0,0 +1,8 @@\n+1\t100000\t1\n+1\t100001\t1\n+1\t100002\t1\n+ReadType: InOrder\n+100000\t1\n+100001\t1\n+100002\t1\n+ReadType: InOrder\ndiff --git a/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.sh b/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.sh\nnew file mode 100755\nindex 000000000000..265c7894852d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.sh\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS test_agg\"\n+\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE test_agg ( A Int64, B Int64 ) Engine=MergeTree() ORDER BY (A, B)\"\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO test_agg SELECT intDiv(number, 1e5), number FROM numbers(1e6)\"\n+\n+$CLICKHOUSE_CLIENT --optimize_aggregation_in_order 1 -q \"SELECT A, B, count() FROM test_agg where A = 1 GROUP BY A, B ORDER BY A, B LIMIT 3\"\n+$CLICKHOUSE_CLIENT --optimize_aggregation_in_order 1 -q \"EXPLAIN actions = 1 SELECT A, B, count() FROM test_agg where A = 1 GROUP BY A, B ORDER BY A, B LIMIT 3\" | grep -o \"ReadType: InOrder\"\n+\n+$CLICKHOUSE_CLIENT --optimize_aggregation_in_order 1 -q \"SELECT B, count() FROM test_agg where A = 1 GROUP BY B ORDER BY B LIMIT 3\"\n+$CLICKHOUSE_CLIENT --optimize_aggregation_in_order 1 -q \"EXPLAIN actions = 1 SELECT B, count() FROM test_agg where A = 1 GROUP BY B ORDER BY B LIMIT 3\" | grep -o \"ReadType: InOrder\"\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS test_agg\"\ndiff --git a/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.python b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.python\nnew file mode 100644\nindex 000000000000..399533480a99\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.python\n@@ -0,0 +1,132 @@\n+#!/usr/bin/env python3\n+import os\n+import sys\n+from itertools import chain, combinations, permutations\n+\n+CURDIR = os.path.dirname(os.path.realpath(__file__))\n+sys.path.insert(0, os.path.join(CURDIR, \"helpers\"))\n+\n+from pure_http_client import ClickHouseClient\n+\n+client = ClickHouseClient()\n+\n+\n+def powerset(iterable):\n+    s = list(iterable)\n+    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n+\n+\n+queries = [\n+    {\"optimize\": True, \"where\": [], \"order_by\": [\"a\"]},\n+    {\"optimize\": True, \"where\": [], \"order_by\": [\"a\", \"b\"]},\n+    {\"optimize\": True, \"where\": [], \"order_by\": [\"a\", \"b\", \"c\"]},\n+    {\"optimize\": True, \"where\": [], \"order_by\": [\"a\", \"b\", \"c\", \"d\"]},\n+    {\"optimize\": True, \"where\": [\"a\"], \"order_by\": [\"a\"]},\n+    {\"optimize\": True, \"where\": [\"a\"], \"order_by\": [\"a\", \"b\"]},\n+    {\"optimize\": True, \"where\": [\"a\"], \"order_by\": [\"b\"]},\n+    {\"optimize\": True, \"where\": [\"a\"], \"order_by\": [\"b\", \"c\"]},\n+    {\"optimize\": True, \"where\": [\"b\"], \"order_by\": [\"a\"]},\n+    {\"optimize\": True, \"where\": [\"b\"], \"order_by\": [\"a\", \"c\"]},\n+    {\"optimize\": False, \"where\": [\"b\"], \"order_by\": [\"b\", \"c\"]},\n+    {\"optimize\": True, \"where\": [\"c\"], \"order_by\": [\"a\"]},\n+    {\"optimize\": True, \"where\": [\"c\"], \"order_by\": [\"a\", \"b\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"a\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"a\", \"b\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"a\", \"c\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"a\", \"b\", \"c\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"a\", \"b\", \"c\", \"d\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"b\", \"c\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"b\"], \"order_by\": [\"c\", \"d\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"c\"], \"order_by\": [\"a\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"c\"], \"order_by\": [\"a\", \"b\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"c\"], \"order_by\": [\"b\", \"d\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"c\"], \"order_by\": [\"a\", \"b\", \"c\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"c\"], \"order_by\": [\"b\", \"c\", \"d\"]},\n+    {\"optimize\": True, \"where\": [\"a\", \"c\"], \"order_by\": [\"a\", \"b\", \"c\", \"d\"]},\n+    {\"optimize\": False, \"where\": [], \"order_by\": [\"b\"]},\n+    {\"optimize\": False, \"where\": [], \"order_by\": [\"b\", \"a\"]},\n+    {\"optimize\": False, \"where\": [], \"order_by\": [\"b\", \"c\"]},\n+    {\"optimize\": False, \"where\": [\"a\"], \"order_by\": [\"c\"]},\n+    {\"optimize\": False, \"where\": [\"a\"], \"order_by\": [\"c\", \"b\"]},\n+    {\"optimize\": False, \"where\": [\"a\"], \"order_by\": [\"c\", \"d\"]},\n+    {\"optimize\": False, \"where\": [\"c\"], \"order_by\": [\"c\", \"d\"]},\n+    {\"optimize\": False, \"where\": [\"c\"], \"order_by\": [\"b\", \"c\"]},\n+]\n+\n+\n+client.query(\"DROP TABLE IF EXISTS t_fixed_prefix\")\n+client.query(\n+    \"\"\"\n+CREATE TABLE t_fixed_prefix (a UInt32, b UInt32, c UInt32, d UInt32, e UInt32)\n+ENGINE = MergeTree ORDER BY (a, b, c, d)\"\"\"\n+)\n+\n+client.query(\"SYSTEM STOP MERGES t_fixed_prefix\")\n+\n+# create several parts\n+for _ in range(4):\n+    client.query(\n+        \"INSERT INTO t_fixed_prefix SELECT number % 2, number % 10, number % 100, number % 1000, number FROM numbers(25000)\"\n+    )\n+\n+\n+def check_query(\n+    fixed_columns, order_by_columns, should_be_optimized, should_use_finish_sorting\n+):\n+    where_clause = \" AND \".join([f\"{c} = 1\" for c in fixed_columns])\n+    order_by_clause = \", \".join(order_by_columns)\n+\n+    query = \"SELECT {} FROM t_fixed_prefix\".format(order_by_clause)\n+    if len(where_clause) != 0:\n+        query += \" WHERE \" + where_clause\n+\n+    if len(order_by_clause) != 0:\n+        query += \" ORDER BY \" + order_by_clause\n+\n+    query += \" SETTINGS optimize_read_in_order = {}\"\n+\n+    res_optimized = client.query(query.format(1))\n+    res_not_optimized = client.query(query.format(0))\n+\n+    if res_optimized != res_not_optimized:\n+        print(\"Failed query {}. Result of queries mismatched\".format(query))\n+        exit(1)\n+\n+    res_explain = client.query(\"EXPLAIN PIPELINE {}\".format(query.format(1)))\n+\n+    is_optimized = \"MergeSortingTransform\" not in res_explain\n+    uses_finish_sorting = \"FinishSortingTransform\" in res_explain\n+\n+    if (\n+        is_optimized != should_be_optimized\n+        or uses_finish_sorting != should_use_finish_sorting\n+    ):\n+        print(\n+            \"\"\"\n+Wrong query pipeline is built for query {}:\n+{}\n+Should be optimized: {}.\n+Is optimized: {}.\n+Should use FinishSortingTransform: {}.\n+Uses FinishSortingTransform: {}\n+\"\"\".format(\n+                query.format(1),\n+                res_explain,\n+                should_be_optimized,\n+                is_optimized,\n+                should_use_finish_sorting,\n+                uses_finish_sorting,\n+            )\n+        )\n+        exit(1)\n+\n+\n+for query in queries:\n+    check_query(query[\"where\"], query[\"order_by\"], query[\"optimize\"], False)\n+    check_query(query[\"where\"], query[\"order_by\"] + [\"e\"], query[\"optimize\"], query[\"optimize\"])\n+\n+    where_columns = [f\"bitNot({col})\" for col in query[\"where\"]]\n+    check_query(where_columns, query[\"order_by\"], query[\"optimize\"], False)\n+    check_query(where_columns, query[\"order_by\"] + [\"e\"], query[\"optimize\"], query[\"optimize\"])\n+\n+print(\"OK\")\ndiff --git a/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.reference b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.reference\nnew file mode 100644\nindex 000000000000..d86bac9de59a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.reference\n@@ -0,0 +1,1 @@\n+OK\ndiff --git a/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.sh b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.sh\nnew file mode 100755\nindex 000000000000..e1a393af0c55\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.sh\n@@ -0,0 +1,10 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest, long\n+# Tag no-fasttest: Require python libraries like scipy, pandas and numpy\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# We should have correct env vars from shell_config.sh to run this test\n+python3 \"$CURDIR\"/02346_read_in_order_fixed_prefix.python\n",
  "problem_statement": "optimize_aggregation_in_order for queries with filters\n```sql\r\ncreate table test_agg ( A Int64, B Int64 ) Engine=MergeTree() order by (A, B);\r\ninsert into test_agg select intDiv(number, 1e7), number from numbers(1e8);\r\n\r\nset optimize_aggregation_in_order=1;\r\n\r\nselect A, B , count() from test_agg where A = 1 group by A, B limit 1 ;\r\nElapsed: 0.666 sec. Processed 10.01 million rows,\r\n\r\nexplain actions=1 select A, B , count() from test_agg where A = 1 group by A, B   limit 1 ;\r\n....\r\n           ReadType: Default\r\n\r\n\r\n```\r\n\r\nif you change predicate to `>=`\r\n\r\n```sql\r\nselect A, B , count() from test_agg where A>= 1 group by A, B limit 1 ;\r\nElapsed: 0.069 sec. Processed 1.66 million rows,\r\n\r\nexplain actions=1 select A, B , count() from test_agg where A>= 1 group by A, B limit 1 ;\r\n...\r\n   ReadType: InOrder\r\n```\r\n\r\n`A >= 1 and A <=1`\r\n```sql\r\nselect A, B , count() from test_agg where A >= 1 and A <=1 group by A, B   limit 1 ;\r\nElapsed: 0.063 sec. Processed 745.47 thousand rows\r\n\r\nexplain actions=1 select A, B , count() from test_agg where A>= 1 group by A, B limit 1 ;\r\n....ReadType: InOrder\r\n```\r\n\r\n```sql\r\nselect A, B , count() from test_agg where A between 1 and 1 group by A, B   limit 1 ;\r\nElapsed: 0.064 sec. Processed 745.47 thousand rows\r\n```\r\n\r\n```sql\r\nselect A, B , count() from test_agg where A in (1)  group by A, B   limit 1 ;\r\nElapsed: 0.075 sec. Processed 802.82 thousand rows\r\n\r\n\r\nselect A, B , count() from test_agg where A in (1,2)  group by A, B   limit 1 ;\r\nElapsed: 0.078 sec. Processed 745.47 thousand rows\r\n```\r\n\r\n```sql\r\nselect  B , count() from test_agg where A =1  group by  B   limit 1 ;\r\nElapsed: 0.037 sec. Processed 745.47 thousand rows\r\n```\n",
  "hints_text": "I think it's a bug of https://github.com/ClickHouse/ClickHouse/pull/32748\r\n\r\nBecause this:\r\n\r\n```\r\nselect A, B , count() from test_agg where A = 1 group by A, B limit 1 ;\r\n```\r\n\r\n worked normally in older versions.\nRight, it worked in 21.8\n@den-crane So, the result is correct but you get lower performance.\n`optimize_aggregation_in_order` is not recommended to be enabled as it does not always give performance improvement.\r\nThat's why we don't have it enabled by default.\n> @den-crane So, the result is correct but you get lower performance.\r\n\r\nIt's not only about lower performance: queries which worked perfectly fine in 21.8, began to fail in 22.3 because of memory exceed exceptions. Which is kinda unexpected behavior for users and prevent them from upgrading.\n@azat ",
  "created_at": "2022-07-01T16:51:49Z",
  "modified_files": [
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.cpp",
    "src/Processors/Transforms/AggregatingInOrderTransform.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp",
    "src/Storages/ReadInOrderOptimizer.cpp",
    "src/Storages/ReadInOrderOptimizer.h",
    "src/Storages/SelectQueryInfo.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.reference",
    "b/tests/queries/0_stateless/02346_aggregation_in_order_fixed_prefix.sh",
    "b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.python",
    "b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.reference",
    "b/tests/queries/0_stateless/02346_read_in_order_fixed_prefix.sh"
  ]
}