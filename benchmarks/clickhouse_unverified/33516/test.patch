diff --git a/src/Common/tests/gtest_interval_tree.cpp b/src/Common/tests/gtest_interval_tree.cpp
new file mode 100644
index 000000000000..d9f19841b665
--- /dev/null
+++ b/src/Common/tests/gtest_interval_tree.cpp
@@ -0,0 +1,540 @@
+#include <gtest/gtest.h>
+
+#include <set>
+#include <map>
+
+#include <base/types.h>
+#include <Common/IntervalTree.h>
+
+
+using namespace DB;
+using Int64Interval = Interval<Int64>;
+
+template <typename IntervalType>
+std::set<IntervalType> intervalSetToSet(const IntervalSet<IntervalType> & interval_set)
+{
+    std::set<IntervalType> result;
+
+    for (const auto & interval : interval_set)
+        result.insert(interval);
+
+    return result;
+}
+
+template <typename IntervalType, typename Value>
+std::map<IntervalType, Value> intervalMapToMap(const IntervalMap<IntervalType, Value> & interval_map)
+{
+    std::map<IntervalType, Value> result;
+
+    for (const auto & [interval, value] : interval_map)
+        result.emplace(interval, value);
+
+    return result;
+}
+
+template <typename IntervalType>
+struct CollectIntervalsSetCallback
+{
+    explicit CollectIntervalsSetCallback(std::set<IntervalType> & result_intervals_)
+        : result_intervals(result_intervals_)
+    {
+    }
+
+    bool operator()(IntervalType interval)
+    {
+        result_intervals.insert(interval);
+        return true;
+    }
+
+    std::set<IntervalType> & result_intervals;
+};
+
+using CollectIntervalsSetInt64Callback = CollectIntervalsSetCallback<Int64Interval>;
+
+template <typename IntervalType>
+std::set<IntervalType> intervalSetFindIntervals(const IntervalSet<IntervalType> & interval_set, typename IntervalType::IntervalStorageType point)
+{
+    std::set<IntervalType> result;
+    CollectIntervalsSetCallback<IntervalType> callback(result);
+
+    interval_set.find(point, callback);
+
+    return result;
+}
+
+template <typename IntervalType, typename Value>
+struct CollectIntervalsMapCallback
+{
+    explicit CollectIntervalsMapCallback(std::map<IntervalType, Value> & result_intervals_)
+        : result_intervals(result_intervals_)
+    {
+    }
+
+    bool operator()(IntervalType interval, const Value & value)
+    {
+        result_intervals.emplace(interval, value);
+        return true;
+    }
+
+    std::map<IntervalType, Value> & result_intervals;
+};
+
+
+template <typename IntervalType, typename Value>
+std::map<IntervalType, Value> intervalMapFindIntervals(const IntervalMap<IntervalType, Value> & interval_set, typename IntervalType::IntervalStorageType point)
+{
+    std::map<IntervalType, Value> result;
+    CollectIntervalsMapCallback callback(result);
+
+    interval_set.find(point, callback);
+
+    return result;
+}
+
+TEST(IntervalTree, IntervalSetBasic)
+{
+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+    {
+        std::set<Int64Interval> expected;
+        IntervalSet<Int64Interval> set;
+
+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+        {
+            auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);
+            expected.insert(interval);
+            set.insert(interval);
+        }
+
+        ASSERT_TRUE(set.getIntervalsSize() == expected.size());
+        ASSERT_TRUE(set.getIntervalsSize() == intervals_size);
+        ASSERT_TRUE(intervalSetToSet(set) == expected);
+
+        for (const auto & expected_interval : expected)
+        {
+            std::set<Int64Interval> expected_intervals = {{expected_interval}};
+
+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            actual_intervals = intervalSetFindIntervals(set, expected_interval.right);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            ASSERT_TRUE(set.has(expected_interval.left));
+            ASSERT_TRUE(set.has(expected_interval.right));
+        }
+
+        set.build();
+
+        ASSERT_TRUE(intervalSetToSet(set) == expected);
+
+        for (const auto & expected_interval : expected)
+        {
+            auto actual_interval = intervalSetFindIntervals(set, expected_interval.left);
+            ASSERT_TRUE(actual_interval.size() == 1);
+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});
+
+            actual_interval = intervalSetFindIntervals(set, expected_interval.right);
+            ASSERT_TRUE(actual_interval.size() == 1);
+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});
+
+            ASSERT_TRUE(set.has(expected_interval.left));
+            ASSERT_TRUE(set.has(expected_interval.right));
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalSetPoints)
+{
+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+    {
+        std::set<Int64Interval> expected;
+        IntervalSet<Int64Interval> set;
+
+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+        {
+            auto interval = Int64Interval(interval_index, interval_index);
+            expected.insert(interval);
+            set.insert(interval);
+        }
+
+        ASSERT_TRUE(set.getIntervalsSize() == expected.size());
+        ASSERT_TRUE(set.getIntervalsSize() == intervals_size);
+        ASSERT_TRUE(intervalSetToSet(set) == expected);
+
+        for (const auto & expected_interval : expected)
+        {
+            std::set<Int64Interval> expected_intervals = {{expected_interval}};
+
+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            actual_intervals = intervalSetFindIntervals(set, expected_interval.right);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            ASSERT_TRUE(set.has(expected_interval.left));
+            ASSERT_TRUE(set.has(expected_interval.right));
+        }
+
+        set.build();
+
+        ASSERT_TRUE(intervalSetToSet(set) == expected);
+
+        for (const auto & expected_interval : expected)
+        {
+            auto actual_interval = intervalSetFindIntervals(set, expected_interval.left);
+            ASSERT_TRUE(actual_interval.size() == 1);
+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});
+
+            actual_interval = intervalSetFindIntervals(set, expected_interval.right);
+            ASSERT_TRUE(actual_interval.size() == 1);
+            ASSERT_TRUE(actual_interval == std::set<Int64Interval>{expected_interval});
+
+            ASSERT_TRUE(set.has(expected_interval.left));
+            ASSERT_TRUE(set.has(expected_interval.right));
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalSetIntersectingIntervals)
+{
+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+    {
+        std::set<Int64Interval> expected;
+        IntervalSet<Int64Interval> set;
+
+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+        {
+            auto interval = Int64Interval(0, interval_index * 2 + 1);
+            expected.insert(interval);
+            set.insert(interval);
+        }
+
+        ASSERT_TRUE(set.getIntervalsSize() == expected.size());
+        ASSERT_TRUE(set.getIntervalsSize() == intervals_size);
+        ASSERT_TRUE(intervalSetToSet(set) == expected);
+
+        for (const auto & expected_interval : expected)
+        {
+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == expected.size());
+            ASSERT_TRUE(actual_intervals == expected);
+
+            ASSERT_TRUE(set.has(expected_interval.left));
+            ASSERT_TRUE(set.has(expected_interval.right));
+        }
+
+        set.build();
+
+        ASSERT_TRUE(intervalSetToSet(set) == expected);
+
+        for (const auto & expected_interval : expected)
+        {
+            auto actual_intervals = intervalSetFindIntervals(set, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == expected.size());
+            ASSERT_TRUE(actual_intervals == expected);
+
+            ASSERT_TRUE(set.has(expected_interval.left));
+            ASSERT_TRUE(set.has(expected_interval.right));
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalSetIterators)
+{
+    {
+        IntervalSet<Int64Interval> set;
+        ASSERT_TRUE(set.begin() == set.end());
+        ASSERT_TRUE(set.cbegin() == set.cend());
+        set.build();
+        ASSERT_TRUE(set.begin() == set.end());
+        ASSERT_TRUE(set.cbegin() == set.cend());
+    }
+    {
+        IntervalSet<Int64Interval> set;
+        set.emplace(Int64Interval(0, 5));
+        ASSERT_TRUE(set.begin() != set.end());
+        ASSERT_TRUE((*set.begin()).left == 0);
+        ASSERT_TRUE((*set.begin()).right == 5);
+        ASSERT_TRUE(set.begin()->left == 0);
+        ASSERT_TRUE(set.begin()->right == 5);
+        auto begin = set.begin();
+        ++begin;
+        ASSERT_TRUE(begin == set.end());
+
+        begin = set.begin();
+        begin++;
+        ASSERT_TRUE(begin == set.end());
+
+        auto end = set.end();
+        --end;
+        ASSERT_TRUE(set.begin() == end);
+
+        end = set.end();
+        end--;
+        ASSERT_TRUE(set.begin() == end);
+    }
+    {
+        for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+        {
+            std::set<Int64Interval> expected;
+            IntervalSet<Int64Interval> set;
+
+            for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+            {
+                auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);
+                set.insert(interval);
+                expected.insert(interval);
+            }
+
+            auto end = set.end();
+            auto begin = set.begin();
+
+            std::set<Int64Interval> actual;
+
+            while (end != begin)
+            {
+                --end;
+                actual.insert(*end);
+            }
+
+            if (end != begin)
+                actual.insert(*end);
+
+            ASSERT_TRUE(actual == expected);
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalMapBasic)
+{
+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+    {
+        std::map<Int64Interval, std::string> expected;
+        IntervalMap<Int64Interval, std::string> map;
+
+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+        {
+            auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);
+            auto value = std::to_string(interval.left);
+            expected.emplace(interval, value);
+            map.emplace(interval, value);
+        }
+
+        ASSERT_TRUE(map.getIntervalsSize() == expected.size());
+        ASSERT_TRUE(map.getIntervalsSize() == intervals_size);
+        ASSERT_TRUE(intervalMapToMap(map) == expected);
+
+        for (const auto & [expected_interval, value] : expected)
+        {
+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};
+
+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            ASSERT_TRUE(map.has(expected_interval.left));
+            ASSERT_TRUE(map.has(expected_interval.right));
+        }
+
+        map.build();
+
+        ASSERT_TRUE(intervalMapToMap(map) == expected);
+
+        for (const auto & [expected_interval, value] : expected)
+        {
+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};
+
+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            ASSERT_TRUE(map.has(expected_interval.left));
+            ASSERT_TRUE(map.has(expected_interval.right));
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalMapPoints)
+{
+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+    {
+        std::map<Int64Interval, std::string> expected;
+        IntervalMap<Int64Interval, std::string> map;
+
+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+        {
+            auto interval = Int64Interval(interval_index, interval_index);
+            auto value = std::to_string(interval.left);
+            expected.emplace(interval, value);
+            map.emplace(interval, value);
+        }
+
+        ASSERT_TRUE(map.getIntervalsSize() == expected.size());
+        ASSERT_TRUE(map.getIntervalsSize() == intervals_size);
+        ASSERT_TRUE(intervalMapToMap(map) == expected);
+
+        for (const auto & [expected_interval, value] : expected)
+        {
+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};
+
+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            ASSERT_TRUE(map.has(expected_interval.left));
+            ASSERT_TRUE(map.has(expected_interval.right));
+        }
+
+        map.build();
+
+        ASSERT_TRUE(intervalMapToMap(map) == expected);
+
+        for (const auto & [expected_interval, value] : expected)
+        {
+            std::map<Int64Interval, std::string> expected_intervals = {{expected_interval, std::to_string(expected_interval.left)}};
+
+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            actual_intervals = intervalMapFindIntervals(map, expected_interval.right);
+            ASSERT_TRUE(actual_intervals.size() == 1);
+            ASSERT_TRUE(actual_intervals == expected_intervals);
+
+            ASSERT_TRUE(map.has(expected_interval.left));
+            ASSERT_TRUE(map.has(expected_interval.right));
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalMapIntersectingIntervals)
+{
+    for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+    {
+        std::map<Int64Interval, std::string> expected;
+        IntervalMap<Int64Interval, std::string> map;
+
+        for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+        {
+            auto interval = Int64Interval(0, interval_index * 2 + 1);
+            auto value = std::to_string(interval.left);
+            expected.emplace(interval, value);
+            map.emplace(interval, value);
+        }
+
+        ASSERT_TRUE(map.getIntervalsSize() == expected.size());
+        ASSERT_TRUE(map.getIntervalsSize() == intervals_size);
+        ASSERT_TRUE(intervalMapToMap(map) == expected);
+
+        for (const auto & [expected_interval, value] : expected)
+        {
+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);
+
+            ASSERT_TRUE(actual_intervals.size() == expected.size());
+            ASSERT_TRUE(actual_intervals == expected);
+
+            ASSERT_TRUE(map.has(expected_interval.left));
+            ASSERT_TRUE(map.has(expected_interval.right));
+        }
+
+        map.build();
+
+        ASSERT_TRUE(intervalMapToMap(map) == expected);
+
+        for (const auto & [expected_interval, value] : expected)
+        {
+            auto actual_intervals = intervalMapFindIntervals(map, expected_interval.left);
+
+            ASSERT_TRUE(actual_intervals.size() == expected.size());
+            ASSERT_TRUE(actual_intervals == expected);
+
+            ASSERT_TRUE(map.has(expected_interval.left));
+            ASSERT_TRUE(map.has(expected_interval.right));
+        }
+    }
+}
+
+TEST(IntervalTree, IntervalMapIterators)
+{
+    {
+        IntervalMap<Int64Interval, std::string> map;
+        ASSERT_TRUE(map.begin() == map.end());
+        ASSERT_TRUE(map.cbegin() == map.cend());
+        map.build();
+        ASSERT_TRUE(map.begin() == map.end());
+        ASSERT_TRUE(map.cbegin() == map.cend());
+    }
+    {
+        IntervalMap<Int64Interval, std::string> map;
+        map.emplace(Int64Interval(0, 5), "value");
+        ASSERT_TRUE(map.begin() != map.end());
+        ASSERT_TRUE((*map.begin()).first.left == 0);
+        ASSERT_TRUE((*map.begin()).first.right == 5);
+        ASSERT_TRUE((*map.begin()).second == "value");
+        ASSERT_TRUE(map.begin()->first.left == 0);
+        ASSERT_TRUE(map.begin()->first.right == 5);
+        ASSERT_TRUE(map.begin()->second == "value");
+        auto begin = map.begin();
+        ++begin;
+        ASSERT_TRUE(begin == map.end());
+
+        begin = map.begin();
+        begin++;
+        ASSERT_TRUE(begin == map.end());
+
+        auto end = map.end();
+        --end;
+        ASSERT_TRUE(map.begin() == end);
+
+        end = map.end();
+        end--;
+        ASSERT_TRUE(map.begin() == end);
+    }
+    {
+        for (size_t intervals_size = 0; intervals_size < 120; ++intervals_size)
+        {
+            std::map<Int64Interval, std::string> expected;
+            IntervalMap<Int64Interval, std::string> map;
+
+            for (size_t interval_index = 0; interval_index < intervals_size; ++interval_index)
+            {
+                auto interval = Int64Interval(interval_index * 2, interval_index * 2 + 1);
+                auto value = std::to_string(interval.left);
+                map.emplace(interval, value);
+                expected.emplace(interval, value);
+            }
+
+            auto end = map.end();
+            auto begin = map.begin();
+
+            std::map<Int64Interval, std::string> actual;
+
+            while (end != begin)
+            {
+                --end;
+                actual.insert(*end);
+            }
+
+            if (end != begin)
+                actual.insert(*end);
+
+            ASSERT_TRUE(actual == expected);
+        }
+    }
+}
diff --git a/tests/performance/range_hashed_dictionary.xml b/tests/performance/range_hashed_dictionary.xml
new file mode 100644
index 000000000000..bdf949cd1ff8
--- /dev/null
+++ b/tests/performance/range_hashed_dictionary.xml
@@ -0,0 +1,126 @@
+<test>
+    <create_query>
+        CREATE TABLE simple_key_range_hashed_dictionary_source_table
+        (
+            id UInt64,
+            value UInt64,
+            start UInt64,
+            end UInt64
+        ) ENGINE = Memory;
+    </create_query>
+
+    <create_query>
+        CREATE TABLE complex_key_range_hashed_dictionary_source_table
+        (
+            id UInt64,
+            id_key String,
+            value UInt64,
+            start UInt64,
+            end UInt64
+        ) ENGINE = Memory;
+    </create_query>
+
+    <create_query>
+        CREATE DICTIONARY simple_key_range_hashed_dictionary
+        (
+            id UInt64,
+            value UInt64,
+            start UInt64,
+            end UInt64
+        )
+        PRIMARY KEY id
+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_key_range_hashed_dictionary_source_table'))
+        LAYOUT(RANGE_HASHED())
+        RANGE(MIN start MAX end)
+        LIFETIME(MIN 0 MAX 1000);
+    </create_query>
+
+    <create_query>
+        CREATE DICTIONARY complex_key_range_hashed_dictionary
+        (
+            id UInt64,
+            id_key String,
+            value UInt64,
+            start UInt64,
+            end UInt64
+        )
+        PRIMARY KEY id, id_key
+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'complex_key_range_hashed_dictionary_source_table'))
+        LAYOUT(COMPLEX_KEY_RANGE_HASHED())
+        RANGE(MIN start MAX end)
+        LIFETIME(MIN 0 MAX 1000);
+    </create_query>
+
+    <fill_query>
+        INSERT INTO simple_key_range_hashed_dictionary_source_table
+        SELECT key, key, range_start * 2, range_start * 2 + 1 FROM
+            (SELECT number as key FROM numbers(10000)) as keys,
+            (SELECT number as range_start FROM numbers(1000)) as ranges;
+    </fill_query>
+
+    <fill_query>
+        INSERT INTO complex_key_range_hashed_dictionary_source_table
+        SELECT key, toString(key), key, range_start * 2, range_start * 2 + 1 FROM
+            (SELECT number as key FROM numbers(10000)) as keys,
+            (SELECT number as range_start FROM numbers(1000)) as ranges;
+    </fill_query>
+
+    <substitutions>
+        <substitution>
+            <name>elements_count</name>
+            <values>
+                <value>500000</value>
+                <value>750000</value>
+            </values>
+        </substitution>
+    </substitutions>
+
+    <query>
+        WITH rand64() % 5000 as key
+        SELECT dictGet('default.simple_key_range_hashed_dictionary', 'value', toUInt64(key), key)
+        FROM system.numbers
+        LIMIT {elements_count}
+        FORMAT Null;
+    </query>
+
+    <query>
+        WITH rand64() % 5000 as key
+        SELECT dictHas('default.simple_key_range_hashed_dictionary', toUInt64(key), key)
+        FROM system.numbers
+        LIMIT {elements_count}
+        FORMAT Null;
+    </query>
+
+    <query>
+        SELECT * FROM simple_key_range_hashed_dictionary
+        FORMAT Null;
+    </query>
+
+    <query>
+        WITH (rand64() % toUInt64(5000) as key, toString(key) as key_id) as complex_key
+        SELECT dictGet('default.complex_key_range_hashed_dictionary', 'value', complex_key, key)
+        FROM system.numbers
+        LIMIT {elements_count}
+        FORMAT Null;
+    </query>
+
+    <query>
+        WITH (rand64() % toUInt64(5000) as key, toString(key) as key_id) as complex_key
+        SELECT dictHas('default.complex_key_range_hashed_dictionary', complex_key, key)
+        FROM system.numbers
+        LIMIT {elements_count}
+        FORMAT Null;
+    </query>
+
+    <query>
+        SELECT * FROM complex_key_range_hashed_dictionary
+        FORMAT Null;
+    </query>
+
+    <drop_query>DROP TABLE IF EXISTS simple_key_range_hashed_dictionary_source_table;</drop_query>
+    <drop_query>DROP TABLE IF EXISTS complex_key_range_hashed_dictionary_source_table;</drop_query>
+
+    <drop_query>DROP DICTIONARY IF EXISTS simple_key_range_hashed_dictionary;</drop_query>
+    <drop_query>DROP DICTIONARY IF EXISTS complex_key_range_hashed_dictionary;</drop_query>
+
+</test>
diff --git a/tests/queries/0_stateless/01676_range_hashed_dictionary.sql b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql
index ff69d61b26b8..7d1fc60e90dc 100644
--- a/tests/queries/0_stateless/01676_range_hashed_dictionary.sql
+++ b/tests/queries/0_stateless/01676_range_hashed_dictionary.sql
@@ -45,13 +45,13 @@ SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(2), toDate('
 SELECT dictHas('database_for_range_dict.range_dictionary', toUInt64(2), toDate('2019-05-31'));
 SELECT 'select columns from dictionary';
 SELECT 'allColumns';
-SELECT * FROM database_for_range_dict.range_dictionary;
+SELECT * FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;
 SELECT 'noColumns';
-SELECT 1 FROM database_for_range_dict.range_dictionary;
+SELECT 1 FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumns';
-SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary;
+SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumn';
-SELECT Tax FROM database_for_range_dict.range_dictionary;
+SELECT Tax FROM database_for_range_dict.range_dictionary ORDER BY CountryID, StartDate, EndDate;
 
 DROP DICTIONARY database_for_range_dict.range_dictionary;
 DROP TABLE database_for_range_dict.date_table;
@@ -97,13 +97,13 @@ SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(2),
 SELECT dictHas('database_for_range_dict.range_dictionary_nullable', toUInt64(2), toDate('2019-05-31'));
 SELECT 'select columns from dictionary';
 SELECT 'allColumns';
-SELECT * FROM database_for_range_dict.range_dictionary_nullable;
+SELECT * FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 SELECT 'noColumns';
-SELECT 1 FROM database_for_range_dict.range_dictionary_nullable;
+SELECT 1 FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumns';
-SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary_nullable;
+SELECT CountryID, StartDate, Tax FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumn';
-SELECT Tax FROM database_for_range_dict.range_dictionary_nullable;
+SELECT Tax FROM database_for_range_dict.range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 
 DROP DICTIONARY database_for_range_dict.range_dictionary_nullable;
 DROP TABLE database_for_range_dict.date_table;
diff --git a/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql
index 677879b1ebdd..72cac481376e 100644
--- a/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql
+++ b/tests/queries/0_stateless/02008_complex_key_range_hashed_dictionary.sql
@@ -45,13 +45,13 @@ SELECT dictHas('range_dictionary', (toUInt64(2), '2'), toDate('2019-05-29'));
 SELECT dictHas('range_dictionary', (toUInt64(2), '2'), toDate('2019-05-31'));
 SELECT 'select columns from dictionary';
 SELECT 'allColumns';
-SELECT * FROM range_dictionary;
+SELECT * FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;
 SELECT 'noColumns';
-SELECT 1 FROM range_dictionary;
+SELECT 1 FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumns';
-SELECT CountryID, StartDate, Tax FROM range_dictionary;
+SELECT CountryID, StartDate, Tax FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumn';
-SELECT Tax FROM range_dictionary;
+SELECT Tax FROM range_dictionary ORDER BY CountryID, StartDate, EndDate;
 
 DROP TABLE date_table;
 DROP DICTIONARY range_dictionary;
@@ -99,13 +99,13 @@ SELECT dictHas('range_dictionary_nullable', (toUInt64(2), '2'), toDate('2019-05-
 SELECT dictHas('range_dictionary_nullable', (toUInt64(2), '2'), toDate('2019-05-31'));
 SELECT 'select columns from dictionary';
 SELECT 'allColumns';
-SELECT * FROM range_dictionary_nullable;
+SELECT * FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 SELECT 'noColumns';
-SELECT 1 FROM range_dictionary_nullable;
+SELECT 1 FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumns';
-SELECT CountryID, StartDate, Tax FROM range_dictionary_nullable;
+SELECT CountryID, StartDate, Tax FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 SELECT 'onlySpecificColumn';
-SELECT Tax FROM range_dictionary_nullable;
+SELECT Tax FROM range_dictionary_nullable ORDER BY CountryID, StartDate, EndDate;
 
 DROP TABLE date_table;
 DROP DICTIONARY range_dictionary_nullable;
