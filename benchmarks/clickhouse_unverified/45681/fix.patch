diff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h
index 9d0252bd6258..ea1fd209a20b 100644
--- a/src/Storages/MergeTree/IMergeTreeDataPart.h
+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h
@@ -110,8 +110,6 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar
 
     virtual bool isStoredOnRemoteDiskWithZeroCopySupport() const = 0;
 
-    virtual bool supportsVerticalMerge() const { return false; }
-
     /// NOTE: Returns zeros if column files are not found in checksums.
     /// Otherwise return information about column size on disk.
     ColumnSize getColumnSize(const String & column_name) const;
diff --git a/src/Storages/MergeTree/MergeTask.cpp b/src/Storages/MergeTree/MergeTask.cpp
index 5874c257ad0b..02165d244ff4 100644
--- a/src/Storages/MergeTree/MergeTask.cpp
+++ b/src/Storages/MergeTree/MergeTask.cpp
@@ -953,10 +953,10 @@ MergeAlgorithm MergeTask::ExecuteAndFinalizeHorizontalPart::chooseMergeAlgorithm
         return MergeAlgorithm::Horizontal;
     if (ctx->need_remove_expired_values)
         return MergeAlgorithm::Horizontal;
-
-    for (const auto & part : global_ctx->future_part->parts)
-        if (!part->supportsVerticalMerge() || !isFullPartStorage(part->getDataPartStorage()))
-            return MergeAlgorithm::Horizontal;
+    if (global_ctx->future_part->part_format.part_type != MergeTreeDataPartType::Wide)
+        return MergeAlgorithm::Horizontal;
+    if (global_ctx->future_part->part_format.storage_type != MergeTreeDataPartStorageType::Full)
+        return MergeAlgorithm::Horizontal;
 
     bool is_supported_storage =
         ctx->merging_params.mode == MergeTreeData::MergingParams::Ordinary ||
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWide.h b/src/Storages/MergeTree/MergeTreeDataPartWide.h
index 0d68334a6233..3f0d52d831eb 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWide.h
+++ b/src/Storages/MergeTree/MergeTreeDataPartWide.h
@@ -47,8 +47,6 @@ class MergeTreeDataPartWide : public IMergeTreeDataPart
 
     bool isStoredOnRemoteDiskWithZeroCopySupport() const override;
 
-    bool supportsVerticalMerge() const override { return true; }
-
     String getFileNameForColumn(const NameAndTypePair & column) const override;
 
     ~MergeTreeDataPartWide() override;
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp
index 1f40177d0fa8..1dec7c2cd7c6 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp
@@ -135,6 +135,7 @@ static size_t computeIndexGranularityImpl(
 {
     size_t rows_in_block = block.rows();
     size_t index_granularity_for_block;
+
     if (!can_use_adaptive_index_granularity)
     {
         index_granularity_for_block = fixed_index_granularity_rows;
@@ -143,7 +144,9 @@ static size_t computeIndexGranularityImpl(
     {
         size_t block_size_in_memory = block.bytes();
         if (blocks_are_granules)
+        {
             index_granularity_for_block = rows_in_block;
+        }
         else if (block_size_in_memory >= index_granularity_bytes)
         {
             size_t granules_in_block = block_size_in_memory / index_granularity_bytes;
@@ -155,10 +158,14 @@ static size_t computeIndexGranularityImpl(
             index_granularity_for_block = index_granularity_bytes / size_of_row_in_bytes;
         }
     }
-    /// We should be less or equal than fixed index granularity
-    index_granularity_for_block = std::min(fixed_index_granularity_rows, index_granularity_for_block);
 
-    /// very rare case when index granularity bytes less then single row
+    /// We should be less or equal than fixed index granularity.
+    /// But if block size is a granule size then do not adjust it.
+    /// Granularity greater than fixed granularity might come from compact part.
+    if (!blocks_are_granules)
+        index_granularity_for_block = std::min(fixed_index_granularity_rows, index_granularity_for_block);
+
+    /// Very rare case when index granularity bytes less than single row.
     if (index_granularity_for_block == 0)
         index_granularity_for_block = 1;
 
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
index cce459c1ba87..f9fe6f2c8ab2 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
@@ -484,15 +484,8 @@ void MergeTreeDataPartWriterWide::validateColumnOfFixedSize(const NameAndTypePai
                             column->size(), mark_num, index_granularity.getMarksCount(), index_granularity_rows);
         }
 
-        if (index_granularity_rows > data_part->index_granularity_info.fixed_index_granularity)
-        {
-            throw Exception(ErrorCodes::LOGICAL_ERROR,
-                            "Mark #{} has {} rows, but max fixed granularity is {}, index granularity size {}",
-                            mark_num, index_granularity_rows, data_part->index_granularity_info.fixed_index_granularity,
-                            index_granularity.getMarksCount());
-        }
-
         if (index_granularity_rows != index_granularity.getMarkRows(mark_num))
+        {
             throw Exception(
                             ErrorCodes::LOGICAL_ERROR,
                             "Incorrect mark rows for part {} for mark #{}"
@@ -501,6 +494,7 @@ void MergeTreeDataPartWriterWide::validateColumnOfFixedSize(const NameAndTypePai
                             mark_num, offset_in_compressed_file, offset_in_decompressed_block,
                             index_granularity.getMarkRows(mark_num), index_granularity_rows,
                             index_granularity.getMarksCount());
+        }
 
         auto column = type->createColumn();
 
