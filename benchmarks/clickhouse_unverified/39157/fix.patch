diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 483ffad67b72..23258c600991 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -1253,7 +1253,7 @@ JoinPtr SelectQueryExpressionAnalyzer::makeJoin(
 }
 
 ActionsDAGPtr SelectQueryExpressionAnalyzer::appendPrewhere(
-    ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns)
+    ExpressionActionsChain & chain, bool only_types)
 {
     const auto * select_query = getSelectQuery();
     if (!select_query->prewhere())
@@ -1290,14 +1290,6 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendPrewhere(
         NameSet required_source_columns(required_columns.begin(), required_columns.end());
         required_source_columns.insert(first_action_names.begin(), first_action_names.end());
 
-        /// Add required columns to required output in order not to remove them after prewhere execution.
-        /// TODO: add sampling and final execution to common chain.
-        for (const auto & column : additional_required_columns)
-        {
-            if (required_source_columns.contains(column))
-                step.addRequiredOutput(column);
-        }
-
         auto names = step.actions()->getNames();
         NameSet name_set(names.begin(), names.end());
 
@@ -1844,12 +1836,28 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
     const Settings & settings = context->getSettingsRef();
     const ConstStoragePtr & storage = query_analyzer.storage();
 
+    Names additional_required_columns_after_prewhere;
     ssize_t prewhere_step_num = -1;
     ssize_t where_step_num = -1;
     ssize_t having_step_num = -1;
 
     auto finalize_chain = [&](ExpressionActionsChain & chain)
     {
+        if (prewhere_step_num >= 0)
+        {
+            ExpressionActionsChain::Step & step = *chain.steps.at(prewhere_step_num);
+
+            auto required_columns = prewhere_info->prewhere_actions->getRequiredColumnsNames();
+            NameSet required_source_columns(required_columns.begin(), required_columns.end());
+            /// Add required columns to required output in order not to remove them after prewhere execution.
+            /// TODO: add sampling and final execution to common chain.
+            for (const auto & column : additional_required_columns_after_prewhere)
+            {
+                if (required_source_columns.contains(column))
+                    step.addRequiredOutput(column);
+            }
+        }
+
         chain.finalize();
 
         finalize(chain, prewhere_step_num, where_step_num, having_step_num, query);
@@ -1859,7 +1867,6 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
 
     {
         ExpressionActionsChain chain(context);
-        Names additional_required_columns_after_prewhere;
 
         if (storage && (query.sampleSize() || settings.parallel_replicas_count > 1))
         {
@@ -1881,7 +1888,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
             filter_info->do_remove_column = true;
         }
 
-        if (auto actions = query_analyzer.appendPrewhere(chain, !first_stage, additional_required_columns_after_prewhere))
+        if (auto actions = query_analyzer.appendPrewhere(chain, !first_stage))
         {
             /// Prewhere is always the first one.
             prewhere_step_num = 0;
@@ -1976,6 +1983,13 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
             && !query.final()
             && join_allow_read_in_order;
 
+        if (storage && optimize_read_in_order)
+        {
+            Names columns_for_sorting_key = metadata_snapshot->getColumnsRequiredForSortingKey();
+            additional_required_columns_after_prewhere.insert(additional_required_columns_after_prewhere.end(),
+                columns_for_sorting_key.begin(), columns_for_sorting_key.end());
+        }
+
         /// If there is aggregation, we execute expressions in SELECT and ORDER BY on the initiating server, otherwise on the source servers.
         query_analyzer.appendSelect(chain, only_types || (need_aggregate ? !second_stage : !first_stage));
 
diff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h
index aae45482a977..019cda8b924a 100644
--- a/src/Interpreters/ExpressionAnalyzer.h
+++ b/src/Interpreters/ExpressionAnalyzer.h
@@ -403,7 +403,7 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer
 
     /// remove_filter is set in ExpressionActionsChain::finalize();
     /// Columns in `additional_required_columns` will not be removed (they can be used for e.g. sampling or FINAL modifier).
-    ActionsDAGPtr appendPrewhere(ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns);
+    ActionsDAGPtr appendPrewhere(ExpressionActionsChain & chain, bool only_types);
     bool appendWhere(ExpressionActionsChain & chain, bool only_types);
     bool appendGroupBy(ExpressionActionsChain & chain, bool only_types, bool optimize_aggregation_in_order, ManyExpressionActions &);
     void appendAggregateFunctionsArguments(ExpressionActionsChain & chain, bool only_types);
