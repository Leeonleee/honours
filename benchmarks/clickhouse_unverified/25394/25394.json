{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25394,
  "instance_id": "ClickHouse__ClickHouse-25394",
  "issue_numbers": [
    "23792"
  ],
  "base_commit": "37770f20fc1370240bc04b4ba30434f5f8f0fb54",
  "patch": "diff --git a/docs/en/sql-reference/functions/encoding-functions.md b/docs/en/sql-reference/functions/encoding-functions.md\nindex 167afdabb803..b464e070accd 100644\n--- a/docs/en/sql-reference/functions/encoding-functions.md\n+++ b/docs/en/sql-reference/functions/encoding-functions.md\n@@ -6,7 +6,7 @@ toc_title: Encoding\n # Encoding Functions {#encoding-functions}\n \n ## char {#char}\n-    \n+\n Returns the string with the length as the number of passed arguments and each byte has the value of corresponding argument. Accepts multiple arguments of numeric types. If the value of argument is out of range of UInt8 data type, it is converted to UInt8 with possible rounding and overflow.\n \n **Syntax**\n@@ -156,7 +156,7 @@ Performs the opposite operation of [hex](#hex). It interprets each pair of hexad\n If you want to convert the result to a number, you can use the [reverse](../../sql-reference/functions/string-functions.md#reverse) and [reinterpretAs<Type>](../../sql-reference/functions/type-conversion-functions.md#type-conversion-functions) functions.\n \n !!! note \"Note\"\n-    If `unhex` is invoked from within the `clickhouse-client`, binary strings display using UTF-8. \n+    If `unhex` is invoked from within the `clickhouse-client`, binary strings display using UTF-8.\n \n Alias: `UNHEX`.\n \n@@ -221,3 +221,51 @@ Accepts an integer. Returns a string containing the list of powers of two that t\n ## bitmaskToArray(num) {#bitmasktoarraynum}\n \n Accepts an integer. Returns an array of UInt64 numbers containing the list of powers of two that total the source number when summed. Numbers in the array are in ascending order.\n+\n+## bitPositionsToArray(num) {#bitpositionstoarraynum}\n+\n+Accepts an integer, argument will be converted to unsigned integer type. Returns an array of UInt64 numbers containing the list of positions of bits that equals 1. Numbers in the array are in ascending order.\n+\n+**Syntax**\n+\n+```sql\n+bitPositionsToArray(arg)\n+```\n+\n+**Arguments**\n+\n+-   `arg` \u2014 Integer value.Types:  [Int/UInt](../../sql-reference/data-types/int-uint.md)\n+\n+**Returned value**\n+\n+An array of UInt64 numbers containing the list of positions of bits that equals 1. Numbers in the array are in ascending order.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT bitPositionsToArray(toInt8(1)) AS bit_positions;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500bit_positions\u2500\u2510\n+\u2502 [0]           \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Query:\n+\n+``` sql\n+select bitPositionsToArray(toInt8(-1)) as bit_positions;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500bit_positions\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 [0,1,2,3,4,5,6,7] \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Functions/FunctionsCoding.cpp b/src/Functions/FunctionsCoding.cpp\nindex c1e20a657b23..150d792f63b8 100644\n--- a/src/Functions/FunctionsCoding.cpp\n+++ b/src/Functions/FunctionsCoding.cpp\n@@ -23,6 +23,7 @@ void registerFunctionsCoding(FunctionFactory & factory)\n     factory.registerFunction<FunctionUnhex>(FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionChar>(FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionBitmaskToArray>();\n+    factory.registerFunction<FunctionBitPositionsToArray>();\n     factory.registerFunction<FunctionToIPv4>();\n     factory.registerFunction<FunctionToIPv6>();\n     factory.registerFunction<FunctionIPv6CIDRToRange>();\ndiff --git a/src/Functions/FunctionsCoding.h b/src/Functions/FunctionsCoding.h\nindex b45eca565d7f..a030e5f393d3 100644\n--- a/src/Functions/FunctionsCoding.h\n+++ b/src/Functions/FunctionsCoding.h\n@@ -24,6 +24,7 @@\n #include <Common/formatIPv6.h>\n #include <Common/hex.h>\n #include <Common/typeid_cast.h>\n+#include <Common/BitHelpers.h>\n \n #include <arpa/inet.h>\n #include <ext/range.h>\n@@ -1506,6 +1507,116 @@ class FunctionBitmaskToArray : public IFunction\n     }\n };\n \n+class FunctionBitPositionsToArray : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"bitPositionsToArray\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBitPositionsToArray>(); }\n+\n+    String getName() const override\n+    {\n+        return name;\n+    }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isInjective(const ColumnsWithTypeAndName &) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        if (!isInteger(arguments[0]))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of argument of function {}\",\n+                getName(),\n+                arguments[0]->getName());\n+\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    template <typename T>\n+    ColumnPtr executeType(const IColumn * column) const\n+    {\n+        const ColumnVector<T> * col_from = checkAndGetColumn<ColumnVector<T>>(column);\n+        if (!col_from)\n+            return nullptr;\n+\n+        auto result_array_values = ColumnVector<UInt64>::create();\n+        auto result_array_offsets = ColumnArray::ColumnOffsets::create();\n+\n+        auto & result_array_values_data = result_array_values->getData();\n+        auto & result_array_offsets_data = result_array_offsets->getData();\n+\n+        auto & vec_from = col_from->getData();\n+        size_t size = vec_from.size();\n+        result_array_offsets_data.resize(size);\n+        result_array_values_data.reserve(size * 2);\n+\n+        using UnsignedType = make_unsigned_t<T>;\n+\n+        for (size_t row = 0; row < size; ++row)\n+        {\n+            UnsignedType x = static_cast<UnsignedType>(vec_from[row]);\n+\n+            if constexpr (is_big_int_v<UnsignedType>)\n+            {\n+                size_t position = 0;\n+\n+                while (x)\n+                {\n+                    if (x & 1)\n+                        result_array_values_data.push_back(position);\n+\n+                    x >>= 1;\n+                    ++position;\n+                }\n+            }\n+            else\n+            {\n+                while (x)\n+                {\n+                    result_array_values_data.push_back(getTrailingZeroBitsUnsafe(x));\n+                    x &= (x - 1);\n+                }\n+            }\n+\n+            result_array_offsets_data[row] = result_array_values_data.size();\n+        }\n+\n+        auto result_column = ColumnArray::create(std::move(result_array_values), std::move(result_array_offsets));\n+\n+        return result_column;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    {\n+        const IColumn * in_column = arguments[0].column.get();\n+        ColumnPtr result_column;\n+\n+        if (!((result_column = executeType<UInt8>(in_column))\n+            || (result_column = executeType<UInt16>(in_column))\n+            || (result_column = executeType<UInt32>(in_column))\n+            || (result_column = executeType<UInt32>(in_column))\n+            || (result_column = executeType<UInt64>(in_column))\n+            || (result_column = executeType<UInt128>(in_column))\n+            || (result_column = executeType<UInt256>(in_column))\n+            || (result_column = executeType<Int8>(in_column))\n+            || (result_column = executeType<Int16>(in_column))\n+            || (result_column = executeType<Int32>(in_column))\n+            || (result_column = executeType<Int64>(in_column))\n+            || (result_column = executeType<Int128>(in_column))\n+            || (result_column = executeType<Int256>(in_column))))\n+        {\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+               \"Illegal column {} of first argument of function {}\",\n+               arguments[0].column->getName(),\n+               getName());\n+        }\n+\n+        return result_column;\n+    }\n+};\n+\n class FunctionToStringCutToZero : public IFunction\n {\n public:\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01866_bit_positions_to_array.reference b/tests/queries/0_stateless/01866_bit_positions_to_array.reference\nnew file mode 100644\nindex 000000000000..659bbdc462bc\n--- /dev/null\n+++ b/tests/queries/0_stateless/01866_bit_positions_to_array.reference\n@@ -0,0 +1,44 @@\n+Int8\n+0\t[]\n+1\t[0]\n+-1\t[0,1,2,3,4,5,6,7]\n+127\t[0,1,2,3,4,5,6]\n+-128\t[7]\n+Int16\n+0\t[]\n+1\t[0]\n+-1\t[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n+32765\t[0,2,3,4,5,6,7,8,9,10,11,12,13,14]\n+-32768\t[15]\n+Int32\n+0\t[]\n+1\t[0]\n+Int64\n+0\t[]\n+1\t[0]\n+Int128\n+0\t[]\n+1\t[0]\n+Int256\n+0\t[]\n+1\t[0]\n+UInt8\n+0\t[]\n+1\t[0]\n+128\t[7]\n+UInt16\n+0\t[]\n+1\t[0]\n+UInt32\n+0\t[]\n+1\t[0]\n+UInt64\n+0\t[]\n+1\t[0]\n+UInt128\n+0\t[]\n+1\t[0]\n+340282366920938463463374607431768211455\t[0]\n+UInt256\n+0\t[]\n+1\t[0]\ndiff --git a/tests/queries/0_stateless/01866_bit_positions_to_array.sql b/tests/queries/0_stateless/01866_bit_positions_to_array.sql\nnew file mode 100644\nindex 000000000000..49c94717506c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01866_bit_positions_to_array.sql\n@@ -0,0 +1,55 @@\n+SELECT 'Int8';\n+SELECT toInt8(0), bitPositionsToArray(toInt8(0));\n+SELECT toInt8(1), bitPositionsToArray(toInt8(1));\n+SELECT toInt8(-1), bitPositionsToArray(toInt8(-1));\n+SELECT toInt8(127), bitPositionsToArray(toInt8(127));\n+SELECT toInt8(128), bitPositionsToArray(toInt8(128));\n+\n+SELECT 'Int16';\n+SELECT toInt16(0), bitPositionsToArray(toInt16(0));\n+SELECT toInt16(1), bitPositionsToArray(toInt16(1));\n+SELECT toInt16(-1), bitPositionsToArray(toInt16(-1));\n+select toInt16(32765), bitPositionsToArray(toInt16(32765));\n+select toInt16(32768), bitPositionsToArray(toInt16(32768));\n+\n+SELECT 'Int32';\n+SELECT toInt32(0), bitPositionsToArray(toInt32(0));\n+SELECT toInt32(1), bitPositionsToArray(toInt32(1));\n+\n+SELECT 'Int64';\n+SELECT toInt64(0), bitPositionsToArray(toInt64(0));\n+SELECT toInt64(1), bitPositionsToArray(toInt64(1));\n+\n+SELECT 'Int128';\n+SELECT toInt128(0), bitPositionsToArray(toInt128(0));\n+SELECT toInt128(1), bitPositionsToArray(toInt128(1));\n+\n+SELECT 'Int256';\n+SELECT toInt256(0), bitPositionsToArray(toInt256(0));\n+SELECT toInt256(1), bitPositionsToArray(toInt256(1));\n+\n+SELECT 'UInt8';\n+SELECT toUInt8(0), bitPositionsToArray(toUInt8(0));\n+SELECT toUInt8(1), bitPositionsToArray(toUInt8(1));\n+SELECT toUInt8(128), bitPositionsToArray(toUInt8(128));\n+\n+SELECT 'UInt16';\n+SELECT toUInt16(0), bitPositionsToArray(toUInt16(0));\n+SELECT toUInt16(1), bitPositionsToArray(toUInt16(1));\n+\n+SELECT 'UInt32';\n+SELECT toUInt32(0), bitPositionsToArray(toUInt32(0));\n+SELECT toUInt32(1), bitPositionsToArray(toUInt32(1));\n+\n+SELECT 'UInt64';\n+SELECT toUInt64(0), bitPositionsToArray(toUInt64(0));\n+SELECT toUInt64(1), bitPositionsToArray(toUInt64(1));\n+\n+SELECT 'UInt128';\n+SELECT toUInt128(0), bitPositionsToArray(toUInt128(0));\n+SELECT toUInt128(1), bitPositionsToArray(toUInt128(1));\n+SELECT toUInt128(-1), bitPositionsToArray(toUInt128(1));\n+\n+SELECT 'UInt256';\n+SELECT toUInt256(0), bitPositionsToArray(toUInt256(0));\n+SELECT toUInt256(1), bitPositionsToArray(toUInt256(1));\n",
  "problem_statement": "Function to get position of non zero bits.\n**Use case**\r\n\r\nConvert bitmask to position.\r\nIt would allow us to directly use FLAT dictionary or Enum datatype without jumping around slow `bitmasktoArray` and `arrayMap`\r\n\r\n**Describe the solution you'd like**\r\n\r\n```\r\nSELECT\r\n    arrayMap(x -> log2(x), bitmaskToArray(100)) AS bitmask,\r\n    bitPositions(100)  AS bitpositions\r\n\r\n\u250c\u2500bitmask\u2500\u252c\u2500bitpositions\u2500\u2510\r\n\u2502 [2,5,6] \u2502 [2,5,6]      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2021-06-17T07:26:01Z",
  "modified_files": [
    "docs/en/sql-reference/functions/encoding-functions.md",
    "src/Functions/FunctionsCoding.cpp",
    "src/Functions/FunctionsCoding.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01866_bit_positions_to_array.reference",
    "b/tests/queries/0_stateless/01866_bit_positions_to_array.sql"
  ]
}