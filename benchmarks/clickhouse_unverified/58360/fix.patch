diff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp
index f1d2b60f1f45..3c9654740f4e 100644
--- a/src/Functions/transform.cpp
+++ b/src/Functions/transform.cpp
@@ -91,19 +91,6 @@ namespace
 
             const auto type_arr_from_nested = type_arr_from->getNestedType();
 
-            auto src = tryGetLeastSupertype(DataTypes{type_x, type_arr_from_nested});
-            if (!src
-                /// Compatibility with previous versions, that allowed even UInt64 with Int64,
-                /// regardless of ambiguous conversions.
-                && !isNativeNumber(type_x) && !isNativeNumber(type_arr_from_nested))
-            {
-                throw Exception(
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "First argument and elements of array "
-                    "of the second argument of function {} must have compatible types",
-                    getName());
-            }
-
             const DataTypeArray * type_arr_to = checkAndGetDataType<DataTypeArray>(arguments[2].get());
 
             if (!type_arr_to)
@@ -766,15 +753,18 @@ namespace
                 }
             }
 
+            WhichDataType which(from_type);
+
             /// Note: Doesn't check the duplicates in the `from` array.
             /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64
-            if (WhichDataType which(from_type); isNativeNumber(which) || which.isDecimal32() || which.isDecimal64())
+            if (isNativeNumber(which) || which.isDecimal32() || which.isDecimal64() || which.isEnum())
             {
                 cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();
                 auto & table = *cache.table_num_to_idx;
                 for (size_t i = 0; i < size; ++i)
                 {
-                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))
+                    if (which.isEnum() /// The correctness of strings are already checked by casting them to the Enum type.
+                        || applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))
                     {
                         UInt64 key = 0;
                         auto * dst = reinterpret_cast<char *>(&key);
