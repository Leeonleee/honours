{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58360,
  "instance_id": "ClickHouse__ClickHouse-58360",
  "issue_numbers": [
    "58241"
  ],
  "base_commit": "7c2d868ef1c99a5e71f38b8566bbf628f96f3845",
  "patch": "diff --git a/src/Functions/transform.cpp b/src/Functions/transform.cpp\nindex f1d2b60f1f45..3c9654740f4e 100644\n--- a/src/Functions/transform.cpp\n+++ b/src/Functions/transform.cpp\n@@ -91,19 +91,6 @@ namespace\n \n             const auto type_arr_from_nested = type_arr_from->getNestedType();\n \n-            auto src = tryGetLeastSupertype(DataTypes{type_x, type_arr_from_nested});\n-            if (!src\n-                /// Compatibility with previous versions, that allowed even UInt64 with Int64,\n-                /// regardless of ambiguous conversions.\n-                && !isNativeNumber(type_x) && !isNativeNumber(type_arr_from_nested))\n-            {\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"First argument and elements of array \"\n-                    \"of the second argument of function {} must have compatible types\",\n-                    getName());\n-            }\n-\n             const DataTypeArray * type_arr_to = checkAndGetDataType<DataTypeArray>(arguments[2].get());\n \n             if (!type_arr_to)\n@@ -766,15 +753,18 @@ namespace\n                 }\n             }\n \n+            WhichDataType which(from_type);\n+\n             /// Note: Doesn't check the duplicates in the `from` array.\n             /// Field may be of Float type, but for the purpose of bitwise equality we can treat them as UInt64\n-            if (WhichDataType which(from_type); isNativeNumber(which) || which.isDecimal32() || which.isDecimal64())\n+            if (isNativeNumber(which) || which.isDecimal32() || which.isDecimal64() || which.isEnum())\n             {\n                 cache.table_num_to_idx = std::make_unique<Cache::NumToIdx>();\n                 auto & table = *cache.table_num_to_idx;\n                 for (size_t i = 0; i < size; ++i)\n                 {\n-                    if (applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))\n+                    if (which.isEnum() /// The correctness of strings are already checked by casting them to the Enum type.\n+                        || applyVisitor(FieldVisitorAccurateEquals(), (*cache.from_column)[i], (*from_column_uncasted)[i]))\n                     {\n                         UInt64 key = 0;\n                         auto * dst = reinterpret_cast<char *>(&key);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02958_transform_enum.reference b/tests/queries/0_stateless/02958_transform_enum.reference\nnew file mode 100644\nindex 000000000000..4c1476a8922d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02958_transform_enum.reference\n@@ -0,0 +1,4 @@\n+Hello\t123\n+world\t456\n+Hello\ttest\n+world\tbest\ndiff --git a/tests/queries/0_stateless/02958_transform_enum.sql b/tests/queries/0_stateless/02958_transform_enum.sql\nnew file mode 100644\nindex 000000000000..3b0fd40a2823\n--- /dev/null\n+++ b/tests/queries/0_stateless/02958_transform_enum.sql\n@@ -0,0 +1,3 @@\n+WITH arrayJoin(['Hello', 'world'])::Enum('Hello', 'world') AS x SELECT x, transform(x, ['Hello', 'world'], [123, 456], 0);\n+WITH arrayJoin(['Hello', 'world'])::Enum('Hello', 'world') AS x SELECT x, transform(x, ['Hello', 'world', 'goodbye'], [123, 456], 0); -- { serverError UNKNOWN_ELEMENT_OF_ENUM }\n+WITH arrayJoin(['Hello', 'world'])::Enum('Hello', 'world') AS x SELECT x, transform(x, ['Hello', 'world'], ['test', 'best']::Array(Enum('test' = 123, 'best' = 456, '' = 0)), ''::Enum('test' = 123, 'best' = 456, '' = 0)) AS y;\n",
  "problem_statement": "`transform` does not work for `Enum`\n```\r\nmilovidov-desktop :) WITH arrayJoin(['Hello', 'world'])::Enum('Hello', 'world') AS x SELECT transform(x, ['Hello', 'world'], [123, 456], 0)\r\n\r\nReceived exception:\r\nCode: 43. DB::Exception: First argument and elements of array of the second argument of function transform must have compatible types: While processing transform(CAST(arrayJoin(['Hello', 'world']), 'Enum(\\'Hello\\', \\'world\\')') AS x, ['Hello', 'world'], [123, 456], 0). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\n```\r\nmilovidov-desktop :) WITH arrayJoin(['Hello', 'world'])::Enum('Hello', 'world') AS x SELECT CASE x WHEN 'Hello' THEN 123 WHEN 'world' THEN 456 END\r\n\r\nReceived exception:\r\nCode: 43. DB::Exception: First argument and elements of array of the second argument of function transform must have compatible types. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2023-12-29T20:49:22Z",
  "modified_files": [
    "src/Functions/transform.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02958_transform_enum.reference",
    "b/tests/queries/0_stateless/02958_transform_enum.sql"
  ]
}