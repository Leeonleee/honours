diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md
index 285737312bd7..a76bb01ce9e0 100644
--- a/docs/en/interfaces/formats.md
+++ b/docs/en/interfaces/formats.md
@@ -7,6 +7,7 @@ title: Formats for Input and Output Data
 
 ClickHouse can accept and return data in various formats. A format supported for input can be used to parse the data provided to `INSERT`s, to perform `SELECT`s from a file-backed table such as File, URL or HDFS, or to read a dictionary. A format supported for output can be used to arrange the
 results of a `SELECT`, and to perform `INSERT`s into a file-backed table.
+All format names are case insensitive.
 
 The supported formats are:
 
diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp
index 0654dd01e491..3303a0a4b660 100644
--- a/src/Formats/FormatFactory.cpp
+++ b/src/Formats/FormatFactory.cpp
@@ -31,14 +31,31 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
 }
 
+bool FormatFactory::exists(const String & name) const
+{
+    return dict.find(boost::to_lower_copy(name)) != dict.end();
+}
+
 const FormatFactory::Creators & FormatFactory::getCreators(const String & name) const
 {
-    auto it = dict.find(name);
+    auto it = dict.find(boost::to_lower_copy(name));
     if (dict.end() != it)
         return it->second;
     throw Exception(ErrorCodes::UNKNOWN_FORMAT, "Unknown format {}", name);
 }
 
+FormatFactory::Creators & FormatFactory::getOrCreateCreators(const String & name)
+{
+    String lower_case = boost::to_lower_copy(name);
+    auto it = dict.find(lower_case);
+    if (dict.end() != it)
+        return it->second;
+
+    auto & creators = dict[lower_case];
+    creators.name = name;
+    return creators;
+}
+
 FormatSettings getFormatSettings(const ContextPtr & context)
 {
     const auto & settings = context->getSettingsRef();
@@ -542,7 +559,7 @@ SchemaReaderPtr FormatFactory::getSchemaReader(
     const ContextPtr & context,
     const std::optional<FormatSettings> & _format_settings) const
 {
-    const auto & schema_reader_creator = dict.at(name).schema_reader_creator;
+    const auto & schema_reader_creator = getCreators(name).schema_reader_creator;
     if (!schema_reader_creator)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Format {} doesn't support schema inference.", name);
 
@@ -558,7 +575,7 @@ ExternalSchemaReaderPtr FormatFactory::getExternalSchemaReader(
     const ContextPtr & context,
     const std::optional<FormatSettings> & _format_settings) const
 {
-    const auto & external_schema_reader_creator = dict.at(name).external_schema_reader_creator;
+    const auto & external_schema_reader_creator = getCreators(name).external_schema_reader_creator;
     if (!external_schema_reader_creator)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Format {} doesn't support schema inference.", name);
 
@@ -569,28 +586,28 @@ ExternalSchemaReaderPtr FormatFactory::getExternalSchemaReader(
 void FormatFactory::registerInputFormat(const String & name, InputCreator input_creator)
 {
     chassert(input_creator);
-    auto & creators = dict[name];
+    auto & creators = getOrCreateCreators(name);
     if (creators.input_creator || creators.random_access_input_creator)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Input format {} is already registered", name);
     creators.input_creator = std::move(input_creator);
     registerFileExtension(name, name);
-    KnownFormatNames::instance().add(name);
+    KnownFormatNames::instance().add(name, /* case_insensitive = */ true);
 }
 
 void FormatFactory::registerRandomAccessInputFormat(const String & name, RandomAccessInputCreator input_creator)
 {
     chassert(input_creator);
-    auto & creators = dict[name];
+    auto & creators = getOrCreateCreators(name);
     if (creators.input_creator || creators.random_access_input_creator)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Input format {} is already registered", name);
     creators.random_access_input_creator = std::move(input_creator);
     registerFileExtension(name, name);
-    KnownFormatNames::instance().add(name);
+    KnownFormatNames::instance().add(name, /* case_insensitive = */ true);
 }
 
 void FormatFactory::registerNonTrivialPrefixAndSuffixChecker(const String & name, NonTrivialPrefixAndSuffixChecker non_trivial_prefix_and_suffix_checker)
 {
-    auto & target = dict[name].non_trivial_prefix_and_suffix_checker;
+    auto & target = getOrCreateCreators(name).non_trivial_prefix_and_suffix_checker;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Non trivial prefix and suffix checker {} is already registered", name);
     target = std::move(non_trivial_prefix_and_suffix_checker);
@@ -598,7 +615,7 @@ void FormatFactory::registerNonTrivialPrefixAndSuffixChecker(const String & name
 
 void FormatFactory::registerAppendSupportChecker(const String & name, AppendSupportChecker append_support_checker)
 {
-    auto & target = dict[name].append_support_checker;
+    auto & target = getOrCreateCreators(name).append_support_checker;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Suffix checker {} is already registered", name);
     target = std::move(append_support_checker);
@@ -612,19 +629,19 @@ void FormatFactory::markFormatHasNoAppendSupport(const String & name)
 bool FormatFactory::checkIfFormatSupportAppend(const String & name, const ContextPtr & context, const std::optional<FormatSettings> & format_settings_)
 {
     auto format_settings = format_settings_ ? *format_settings_ : getFormatSettings(context);
-    auto & append_support_checker = dict[name].append_support_checker;
+    const auto & append_support_checker = getCreators(name).append_support_checker;
     /// By default we consider that format supports append
     return !append_support_checker || append_support_checker(format_settings);
 }
 
 void FormatFactory::registerOutputFormat(const String & name, OutputCreator output_creator)
 {
-    auto & target = dict[name].output_creator;
+    auto & target = getOrCreateCreators(name).output_creator;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Output format {} is already registered", name);
     target = std::move(output_creator);
     registerFileExtension(name, name);
-    KnownFormatNames::instance().add(name);
+    KnownFormatNames::instance().add(name, /* case_insensitive = */ true);
 }
 
 void FormatFactory::registerFileExtension(const String & extension, const String & format_name)
@@ -696,7 +713,7 @@ String FormatFactory::getFormatFromFileDescriptor(int fd)
 
 void FormatFactory::registerFileSegmentationEngine(const String & name, FileSegmentationEngine file_segmentation_engine)
 {
-    auto & target = dict[name].file_segmentation_engine_creator;
+    auto & target = getOrCreateCreators(name).file_segmentation_engine_creator;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: File segmentation engine {} is already registered", name);
     auto creator = [file_segmentation_engine](const FormatSettings &)
@@ -708,7 +725,7 @@ void FormatFactory::registerFileSegmentationEngine(const String & name, FileSegm
 
 void FormatFactory::registerFileSegmentationEngineCreator(const String & name, FileSegmentationEngineCreator file_segmentation_engine_creator)
 {
-    auto & target = dict[name].file_segmentation_engine_creator;
+    auto & target = getOrCreateCreators(name).file_segmentation_engine_creator;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: File segmentation engine creator {} is already registered", name);
     target = std::move(file_segmentation_engine_creator);
@@ -716,7 +733,7 @@ void FormatFactory::registerFileSegmentationEngineCreator(const String & name, F
 
 void FormatFactory::registerSchemaReader(const String & name, SchemaReaderCreator schema_reader_creator)
 {
-    auto & target = dict[name].schema_reader_creator;
+    auto & target = getOrCreateCreators(name).schema_reader_creator;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Schema reader {} is already registered", name);
     target = std::move(schema_reader_creator);
@@ -724,7 +741,7 @@ void FormatFactory::registerSchemaReader(const String & name, SchemaReaderCreato
 
 void FormatFactory::registerExternalSchemaReader(const String & name, ExternalSchemaReaderCreator external_schema_reader_creator)
 {
-    auto & target = dict[name].external_schema_reader_creator;
+    auto & target = getOrCreateCreators(name).external_schema_reader_creator;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Schema reader {} is already registered", name);
     target = std::move(external_schema_reader_creator);
@@ -732,7 +749,7 @@ void FormatFactory::registerExternalSchemaReader(const String & name, ExternalSc
 
 void FormatFactory::markOutputFormatSupportsParallelFormatting(const String & name)
 {
-    auto & target = dict[name].supports_parallel_formatting;
+    auto & target = getOrCreateCreators(name).supports_parallel_formatting;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Output format {} is already marked as supporting parallel formatting", name);
     target = true;
@@ -741,7 +758,7 @@ void FormatFactory::markOutputFormatSupportsParallelFormatting(const String & na
 
 void FormatFactory::markFormatSupportsSubsetOfColumns(const String & name)
 {
-    auto & target = dict[name].subset_of_columns_support_checker;
+    auto & target = getOrCreateCreators(name).subset_of_columns_support_checker;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Format {} is already marked as supporting subset of columns", name);
     target = [](const FormatSettings &){ return true; };
@@ -749,7 +766,7 @@ void FormatFactory::markFormatSupportsSubsetOfColumns(const String & name)
 
 void FormatFactory::registerSubsetOfColumnsSupportChecker(const String & name, SubsetOfColumnsSupportChecker subset_of_columns_support_checker)
 {
-    auto & target = dict[name].subset_of_columns_support_checker;
+    auto & target = getOrCreateCreators(name).subset_of_columns_support_checker;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Format {} is already marked as supporting subset of columns", name);
     target = std::move(subset_of_columns_support_checker);
@@ -757,7 +774,7 @@ void FormatFactory::registerSubsetOfColumnsSupportChecker(const String & name, S
 
 void FormatFactory::markOutputFormatPrefersLargeBlocks(const String & name)
 {
-    auto & target = dict[name].prefers_large_blocks;
+    auto & target = getOrCreateCreators(name).prefers_large_blocks;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: Format {} is already marked as preferring large blocks", name);
     target = true;
@@ -773,7 +790,7 @@ bool FormatFactory::checkIfFormatSupportsSubsetOfColumns(const String & name, co
 void FormatFactory::registerAdditionalInfoForSchemaCacheGetter(
     const String & name, AdditionalInfoForSchemaCacheGetter additional_info_for_schema_cache_getter)
 {
-    auto & target = dict[name].additional_info_for_schema_cache_getter;
+    auto & target = getOrCreateCreators(name).additional_info_for_schema_cache_getter;
     if (target)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "FormatFactory: additional info for schema cache getter {} is already registered", name);
     target = std::move(additional_info_for_schema_cache_getter);
@@ -791,13 +808,13 @@ String FormatFactory::getAdditionalInfoForSchemaCache(const String & name, const
 
 bool FormatFactory::isInputFormat(const String & name) const
 {
-    auto it = dict.find(name);
+    auto it = dict.find(boost::to_lower_copy(name));
     return it != dict.end() && (it->second.input_creator || it->second.random_access_input_creator);
 }
 
 bool FormatFactory::isOutputFormat(const String & name) const
 {
-    auto it = dict.find(name);
+    auto it = dict.find(boost::to_lower_copy(name));
     return it != dict.end() && it->second.output_creator;
 }
 
@@ -826,7 +843,8 @@ bool FormatFactory::checkIfOutputFormatPrefersLargeBlocks(const String & name) c
 
 bool FormatFactory::checkParallelizeOutputAfterReading(const String & name, const ContextPtr & context) const
 {
-    if (name == "Parquet" && context->getSettingsRef().input_format_parquet_preserve_order)
+    auto format_name = boost::to_lower_copy(name);
+    if (format_name == "parquet" && context->getSettingsRef().input_format_parquet_preserve_order)
         return false;
 
     return true;
@@ -834,7 +852,7 @@ bool FormatFactory::checkParallelizeOutputAfterReading(const String & name, cons
 
 void FormatFactory::checkFormatName(const String & name) const
 {
-    auto it = dict.find(name);
+    auto it = dict.find(boost::to_lower_copy(name));
     if (it == dict.end())
         throw Exception(ErrorCodes::UNKNOWN_FORMAT, "Unknown format {}", name);
 }
diff --git a/src/Formats/FormatFactory.h b/src/Formats/FormatFactory.h
index 165a20f7c4d4..46c1b8ddcdd4 100644
--- a/src/Formats/FormatFactory.h
+++ b/src/Formats/FormatFactory.h
@@ -132,6 +132,7 @@ class FormatFactory final : private boost::noncopyable
 
     struct Creators
     {
+        String name;
         InputCreator input_creator;
         RandomAccessInputCreator random_access_input_creator;
         OutputCreator output_creator;
@@ -263,12 +264,14 @@ class FormatFactory final : private boost::noncopyable
 
     /// Check that format with specified name exists and throw an exception otherwise.
     void checkFormatName(const String & name) const;
+    bool exists(const String & name) const;
 
 private:
     FormatsDictionary dict;
     FileExtensionFormats file_extension_formats;
 
     const Creators & getCreators(const String & name) const;
+    Creators & getOrCreateCreators(const String & name);
 
     // Creates a ReadBuffer to give to an input format. Returns nullptr if we should use `buf` directly.
     std::unique_ptr<ReadBuffer> wrapReadBufferIfNeeded(
diff --git a/src/Functions/formatRow.cpp b/src/Functions/formatRow.cpp
index 12a5fc2cc270..1ac6becfb15f 100644
--- a/src/Functions/formatRow.cpp
+++ b/src/Functions/formatRow.cpp
@@ -18,7 +18,6 @@ namespace ErrorCodes
 {
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
-    extern const int UNKNOWN_FORMAT;
     extern const int BAD_ARGUMENTS;
 }
 
@@ -40,8 +39,7 @@ class FunctionFormatRow : public IFunction
         , arguments_column_names(std::move(arguments_column_names_))
         , context(std::move(context_))
     {
-        if (!FormatFactory::instance().getAllFormats().contains(format_name))
-            throw Exception(ErrorCodes::UNKNOWN_FORMAT, "Unknown format {}", format_name);
+        FormatFactory::instance().checkFormatName(format_name);
     }
 
     String getName() const override { return name; }
diff --git a/src/Storages/StorageAzureBlob.cpp b/src/Storages/StorageAzureBlob.cpp
index f5fcf01c59ef..d484fefc46ff 100644
--- a/src/Storages/StorageAzureBlob.cpp
+++ b/src/Storages/StorageAzureBlob.cpp
@@ -68,7 +68,6 @@ namespace ErrorCodes
     extern const int CANNOT_DETECT_FORMAT;
     extern const int LOGICAL_ERROR;
     extern const int NOT_IMPLEMENTED;
-
 }
 
 namespace
@@ -167,7 +166,7 @@ StorageAzureBlob::Configuration StorageAzureBlob::getConfiguration(ASTs & engine
 
     auto is_format_arg = [] (const std::string & s) -> bool
     {
-        return s == "auto" || FormatFactory::instance().getAllFormats().contains(s);
+        return s == "auto" || FormatFactory::instance().exists(s);
     };
 
     if (engine_args.size() == 4)
@@ -200,7 +199,7 @@ StorageAzureBlob::Configuration StorageAzureBlob::getConfiguration(ASTs & engine
     else if (engine_args.size() == 6)
     {
         auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], "format/account_name");
-        if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+        if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
         {
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "Format and compression must be last arguments");
         }
@@ -218,7 +217,7 @@ StorageAzureBlob::Configuration StorageAzureBlob::getConfiguration(ASTs & engine
     else if (engine_args.size() == 7)
     {
         auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], "format/account_name");
-        if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+        if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
         {
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "Format and compression must be last arguments");
         }
diff --git a/src/Storages/StorageS3.cpp b/src/Storages/StorageS3.cpp
index 2d8ef3df1c8c..e59a09efb206 100644
--- a/src/Storages/StorageS3.cpp
+++ b/src/Storages/StorageS3.cpp
@@ -1531,7 +1531,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, const C
                 no_sign_request = true;
                 engine_args_to_idx = {{"format", 2}};
             }
-            else if (second_arg == "auto" || FormatFactory::instance().getAllFormats().contains(second_arg))
+            else if (second_arg == "auto" || FormatFactory::instance().exists(second_arg))
                 engine_args_to_idx = {{"format", 1}, {"compression_method", 2}};
             else
                 engine_args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}};
@@ -1552,7 +1552,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, const C
             else
             {
                 auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], "session_token/format");
-                if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+                if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
                 {
                     engine_args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}, {"format", 3}};
                 }
@@ -1568,7 +1568,7 @@ StorageS3::Configuration StorageS3::getConfiguration(ASTs & engine_args, const C
         else if (count == 5)
         {
             auto fourth_arg = checkAndGetLiteralArgument<String>(engine_args[3], "session_token/format");
-            if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+            if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
             {
                 engine_args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}, {"format", 3}, {"compression", 4}};
             }
diff --git a/src/Storages/System/StorageSystemFormats.cpp b/src/Storages/System/StorageSystemFormats.cpp
index a360971e1f72..849e4eadf78e 100644
--- a/src/Storages/System/StorageSystemFormats.cpp
+++ b/src/Storages/System/StorageSystemFormats.cpp
@@ -23,7 +23,8 @@ void StorageSystemFormats::fillData(MutableColumns & res_columns, ContextPtr, co
     const auto & formats = FormatFactory::instance().getAllFormats();
     for (const auto & pair : formats)
     {
-        const auto & [format_name, creators] = pair;
+        const auto & [name, creators] = pair;
+        String format_name = creators.name;
         UInt64 has_input_format(creators.input_creator != nullptr || creators.random_access_input_creator != nullptr);
         UInt64 has_output_format(creators.output_creator != nullptr);
         UInt64 supports_parallel_parsing(creators.file_segmentation_engine_creator != nullptr || creators.random_access_input_creator != nullptr);
diff --git a/src/TableFunctions/TableFunctionAzureBlobStorage.cpp b/src/TableFunctions/TableFunctionAzureBlobStorage.cpp
index 066d6338b6ae..8f558adb09b1 100644
--- a/src/TableFunctions/TableFunctionAzureBlobStorage.cpp
+++ b/src/TableFunctions/TableFunctionAzureBlobStorage.cpp
@@ -80,7 +80,7 @@ void TableFunctionAzureBlobStorage::parseArgumentsImpl(ASTs & engine_args, const
         configuration.blob_path = checkAndGetLiteralArgument<String>(engine_args[2], "blobpath");
 
         auto is_format_arg
-            = [](const std::string & s) -> bool { return s == "auto" || FormatFactory::instance().getAllFormats().contains(s); };
+            = [](const std::string & s) -> bool { return s == "auto" || FormatFactory::instance().exists(s); };
 
         if (engine_args.size() == 4)
         {
@@ -207,7 +207,7 @@ void TableFunctionAzureBlobStorage::updateStructureAndFormatArgumentsIfNeeded(AS
             arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);
 
         auto is_format_arg
-            = [](const std::string & s) -> bool { return s == "auto" || FormatFactory::instance().getAllFormats().contains(s); };
+            = [](const std::string & s) -> bool { return s == "auto" || FormatFactory::instance().exists(s); };
 
         /// (connection_string, container_name, blobpath)
         if (args.size() == 3)
diff --git a/src/TableFunctions/TableFunctionS3.cpp b/src/TableFunctions/TableFunctionS3.cpp
index 3fedd38277c5..c00b1e2e3e50 100644
--- a/src/TableFunctions/TableFunctionS3.cpp
+++ b/src/TableFunctions/TableFunctionS3.cpp
@@ -100,7 +100,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context
                 no_sign_request = true;
                 args_to_idx = {{"format", 2}};
             }
-            else if (second_arg == "auto" || FormatFactory::instance().getAllFormats().contains(second_arg))
+            else if (second_arg == "auto" || FormatFactory::instance().exists(second_arg))
                 args_to_idx = {{"format", 1}, {"structure", 2}};
             else
                 args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}};
@@ -119,14 +119,14 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context
                 no_sign_request = true;
                 args_to_idx = {{"format", 2}, {"structure", 3}};
             }
-            else if (second_arg == "auto" || FormatFactory::instance().getAllFormats().contains(second_arg))
+            else if (second_arg == "auto" || FormatFactory::instance().exists(second_arg))
             {
                 args_to_idx = {{"format", 1}, {"structure", 2}, {"compression_method", 3}};
             }
             else
             {
                 auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], "format/session_token");
-                if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+                if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
                 {
                     args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}, {"format", 3}};
                 }
@@ -153,7 +153,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context
             else
             {
                 auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], "format/session_token");
-                if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+                if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
                 {
                     args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}, {"format", 3}, {"structure", 4}};
                 }
@@ -170,7 +170,7 @@ void TableFunctionS3::parseArgumentsImpl(ASTs & args, const ContextPtr & context
         else if (count == 6)
         {
             auto fourth_arg = checkAndGetLiteralArgument<String>(args[3], "format/session_token");
-            if (fourth_arg == "auto" || FormatFactory::instance().getAllFormats().contains(fourth_arg))
+            if (fourth_arg == "auto" || FormatFactory::instance().exists(fourth_arg))
             {
                 args_to_idx = {{"access_key_id", 1}, {"secret_access_key", 2}, {"format", 3}, {"structure", 4}, {"compression_method", 5}};
             }
@@ -300,7 +300,7 @@ void TableFunctionS3::updateStructureAndFormatArgumentsIfNeeded(ASTs & args, con
                 args.push_back(structure_literal);
             }
             /// s3(source, format, structure)
-            else if (second_arg == "auto" || FormatFactory::instance().getAllFormats().contains(second_arg))
+            else if (second_arg == "auto" || FormatFactory::instance().exists(second_arg))
             {
                 if (second_arg == "auto")
                     args[1] = format_literal;
@@ -330,7 +330,7 @@ void TableFunctionS3::updateStructureAndFormatArgumentsIfNeeded(ASTs & args, con
                     args[3] = structure_literal;
             }
             /// s3(source, format, structure, compression_method)
-            else if (second_arg == "auto" || FormatFactory::instance().getAllFormats().contains(second_arg))
+            else if (second_arg == "auto" || FormatFactory::instance().exists(second_arg))
             {
                 if (second_arg == "auto")
                     args[1] = format_literal;
