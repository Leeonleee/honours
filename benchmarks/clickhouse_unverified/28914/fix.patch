diff --git a/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp b/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp
new file mode 100644
index 000000000000..8569e8f9c8c0
--- /dev/null
+++ b/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp
@@ -0,0 +1,98 @@
+#include <AggregateFunctions/IAggregateFunction.h>
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+#include <AggregateFunctions/FactoryHelpers.h>
+#include <Common/ExponentiallySmoothedCounter.h>
+#include <Common/FieldVisitorConvertToNumber.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <IO/ReadHelpers.h>
+#include <IO/WriteHelpers.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
+
+
+/** See the comments in ExponentiallySmoothedCounter.h
+  */
+class AggregateFunctionExponentialMovingAverage final
+    : public IAggregateFunctionDataHelper<ExponentiallySmoothedAverage, AggregateFunctionExponentialMovingAverage>
+{
+private:
+    String name;
+    Float64 half_decay;
+
+public:
+    AggregateFunctionExponentialMovingAverage(const DataTypes & argument_types_, const Array & params)
+        : IAggregateFunctionDataHelper<ExponentiallySmoothedAverage, AggregateFunctionExponentialMovingAverage>(argument_types_, params)
+    {
+        if (params.size() != 1)
+            throw Exception{"Aggregate function " + getName() + " requires exactly one parameter: half decay time.",
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};
+
+        half_decay = applyVisitor(FieldVisitorConvertToNumber<Float64>(), params[0]);
+    }
+
+    String getName() const override
+    {
+        return "exponentialMovingAverage";
+    }
+
+    DataTypePtr getReturnType() const override
+    {
+        return std::make_shared<DataTypeNumber<Float64>>();
+    }
+
+    bool allocatesMemoryInArena() const override { return false; }
+
+    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override
+    {
+        const auto & value = columns[0]->getFloat64(row_num);
+        const auto & time = columns[1]->getFloat64(row_num);
+        this->data(place).add(value, time, half_decay);
+    }
+
+    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override
+    {
+        this->data(place).merge(this->data(rhs), half_decay);
+    }
+
+    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf) const override
+    {
+        writeBinary(this->data(place).value, buf);
+        writeBinary(this->data(place).time, buf);
+    }
+
+    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, Arena *) const override
+    {
+        readBinary(this->data(place).value, buf);
+        readBinary(this->data(place).time, buf);
+    }
+
+    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override
+    {
+        auto & column = assert_cast<ColumnVector<Float64> &>(to);
+        column.getData().push_back(this->data(place).get(half_decay));
+    }
+};
+
+void registerAggregateFunctionExponentialMovingAverage(AggregateFunctionFactory & factory)
+{
+    factory.registerFunction("exponentialMovingAverage",
+        [](const std::string & name, const DataTypes & argument_types, const Array & params, const Settings *) -> AggregateFunctionPtr
+        {
+            assertBinary(name, argument_types);
+            for (const auto & type : argument_types)
+                if (!isNumber(*type))
+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Both arguments for aggregate function {} must have numeric type, got {}", name, type->getName());
+            return std::make_shared<AggregateFunctionExponentialMovingAverage>(argument_types, params);
+        });
+}
+
+}
diff --git a/src/AggregateFunctions/registerAggregateFunctions.cpp b/src/AggregateFunctions/registerAggregateFunctions.cpp
index dd1f292a3926..5d0af7192906 100644
--- a/src/AggregateFunctions/registerAggregateFunctions.cpp
+++ b/src/AggregateFunctions/registerAggregateFunctions.cpp
@@ -50,7 +50,9 @@ void registerAggregateFunctionWelchTTest(AggregateFunctionFactory &);
 void registerAggregateFunctionStudentTTest(AggregateFunctionFactory &);
 void registerAggregateFunctionSingleValueOrNull(AggregateFunctionFactory &);
 void registerAggregateFunctionSequenceNextNode(AggregateFunctionFactory &);
+void registerAggregateFunctionExponentialMovingAverage(AggregateFunctionFactory &);
 void registerAggregateFunctionSparkbar(AggregateFunctionFactory &);
+void registerAggregateFunctionIntervalLengthSum(AggregateFunctionFactory &);
 
 class AggregateFunctionCombinatorFactory;
 void registerAggregateFunctionCombinatorIf(AggregateFunctionCombinatorFactory &);
@@ -66,8 +68,6 @@ void registerAggregateFunctionCombinatorDistinct(AggregateFunctionCombinatorFact
 
 void registerWindowFunctions(AggregateFunctionFactory & factory);
 
-void registerAggregateFunctionIntervalLengthSum(AggregateFunctionFactory &);
-
 void registerAggregateFunctions()
 {
     {
@@ -116,11 +116,11 @@ void registerAggregateFunctions()
         registerAggregateFunctionWelchTTest(factory);
         registerAggregateFunctionStudentTTest(factory);
         registerAggregateFunctionSingleValueOrNull(factory);
-
-        registerWindowFunctions(factory);
-
         registerAggregateFunctionIntervalLengthSum(factory);
+        registerAggregateFunctionExponentialMovingAverage(factory);
         registerAggregateFunctionSparkbar(factory);
+
+        registerWindowFunctions(factory);
     }
 
     {
diff --git a/src/Common/ExponentiallySmoothedCounter.h b/src/Common/ExponentiallySmoothedCounter.h
new file mode 100644
index 000000000000..28d4e5e25c1a
--- /dev/null
+++ b/src/Common/ExponentiallySmoothedCounter.h
@@ -0,0 +1,114 @@
+#pragma once
+
+#include <cmath>
+#include <limits>
+
+
+namespace DB
+{
+
+/** https://en.wikipedia.org/wiki/Exponential_smoothing
+  *
+  * Exponentially smoothed average over time is weighted average with weight proportional to negative exponent of the time passed.
+  * For example, the last value is taken with weight 1/2, the value one second ago with weight 1/4, two seconds ago - 1/8, etc.
+  * It can be understood as an average over sliding window, but with different kernel.
+  *
+  * As an advantage, it is easy to update. Instead of collecting values and calculating a series of x1 / 2 + x2 / 4 + x3 / 8...
+  * just calculate x_old / 2 + x_new / 2.
+  *
+  * It is often used for resource usage metrics. For example, "load average" in Linux is exponentially smoothed moving average.
+  * We can use exponentially smoothed counters in query scheduler.
+  */
+struct ExponentiallySmoothedAverage
+{
+    /// The sum. It contains the last value and all previous values scaled accordingly to the difference of their time to the reference time.
+    /// Older values are summed with exponentially smaller coefficients.
+    /// To obtain the average, you have to divide this value to the sum of all coefficients (see 'sumWeights').
+
+    double value = 0;
+
+    /// The point of reference. You can translate the value to a different point of reference (see 'remap').
+    /// You can imagine that the value exponentially decays over time.
+    /// But it is also meaningful to treat the whole counters as constants over time but in another non-linear coordinate system,
+    /// that inflates over time, while the counter itself does not change
+    /// (it continues to be the same physical quantity, but only changes its representation in the "usual" coordinate system).
+
+    /// Recap: the whole counter is one dimensional and it can be represented as a curve formed by two dependent coordinates in 2d plane,
+    /// the space can be represented by (value, time) coordinates, and the curves will be exponentially decaying over time,
+    /// alternatively the space can be represented by (exponentially_adjusted_value, time) and then the curves will be constant over time.
+
+    /// Also useful analogy is the exponential representation of a number: x = a * exp(b) = a * e (where e = exp(b))
+    /// a number x is represented by a curve in 2d plane that can be parametrized by coordinates (a, b) or (a, e).
+
+    double time = 0;
+
+
+    ExponentiallySmoothedAverage()
+    {
+    }
+
+    ExponentiallySmoothedAverage(double current_value, double current_time)
+        : value(current_value), time(current_time)
+    {
+    }
+
+    /// How much value decays after time_passed.
+    static double scale(double time_passed, double half_decay_time)
+    {
+        return exp2(-time_passed / half_decay_time);
+    }
+
+    /// Sum of weights of all values. Divide by it to get the average.
+    static double sumWeights(double half_decay_time)
+    {
+        double k = scale(1.0, half_decay_time);
+        return 1 / (1 - k);
+    }
+
+    /// Obtain the same counter in another point of reference.
+    ExponentiallySmoothedAverage remap(double current_time, double half_decay_time) const
+    {
+        return ExponentiallySmoothedAverage(value * scale(current_time - time, half_decay_time), current_time);
+    }
+
+    /// Merge two counters. It is done by moving to the same point of reference and summing the values.
+    static ExponentiallySmoothedAverage merge(const ExponentiallySmoothedAverage & a, const ExponentiallySmoothedAverage & b, double half_decay_time)
+    {
+        if (a.time > b.time)
+            return ExponentiallySmoothedAverage(a.value + b.remap(a.time, half_decay_time).value, a.time);
+        if (a.time < b.time)
+            return ExponentiallySmoothedAverage(b.value + a.remap(b.time, half_decay_time).value, b.time);
+
+        return ExponentiallySmoothedAverage(a.value + b.value, a.time);
+    }
+
+    void merge(const ExponentiallySmoothedAverage & other, double half_decay_time)
+    {
+        *this = merge(*this, other, half_decay_time);
+    }
+
+    void add(double new_value, double current_time, double half_decay_time)
+    {
+        merge(ExponentiallySmoothedAverage(new_value, current_time), half_decay_time);
+    }
+
+    /// Calculate the average from the sum.
+    double get(double half_decay_time) const
+    {
+        return value / sumWeights(half_decay_time);
+    }
+
+    double get(double current_time, double half_decay_time) const
+    {
+        return remap(current_time, half_decay_time).get(half_decay_time);
+    }
+
+    /// Compare two counters (by moving to the same point of reference and comparing sums).
+    /// You can store the counters in container and sort it without changing the stored values over time.
+    bool less(const ExponentiallySmoothedAverage & other, double half_decay_time) const
+    {
+        return remap(other.time, half_decay_time).value < other.value;
+    }
+};
+
+}
