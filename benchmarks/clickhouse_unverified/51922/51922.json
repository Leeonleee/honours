{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51922,
  "instance_id": "ClickHouse__ClickHouse-51922",
  "issue_numbers": [
    "51918"
  ],
  "base_commit": "e36a638014542348285eeda1a6de650782c0e7ab",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionMinMaxAny.h b/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\nindex 5312df32459f..6bfa6895a5cb 100644\n--- a/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\n+++ b/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\n@@ -51,7 +51,8 @@ struct SingleValueDataFixed\n     T value = T{};\n \n public:\n-    static constexpr bool is_nullable = false;\n+    static constexpr bool result_is_nullable = false;\n+    static constexpr bool should_skip_null_arguments = true;\n     static constexpr bool is_any = false;\n \n     bool has() const\n@@ -501,7 +502,8 @@ struct SingleValueDataString\n     char small_data[MAX_SMALL_STRING_SIZE]; /// Including the terminating zero.\n \n public:\n-    static constexpr bool is_nullable = false;\n+    static constexpr bool result_is_nullable = false;\n+    static constexpr bool should_skip_null_arguments = true;\n     static constexpr bool is_any = false;\n \n     bool has() const\n@@ -769,7 +771,7 @@ static_assert(\n \n \n /// For any other value types.\n-template <bool IS_NULLABLE = false>\n+template <bool RESULT_IS_NULLABLE = false>\n struct SingleValueDataGeneric\n {\n private:\n@@ -779,12 +781,13 @@ struct SingleValueDataGeneric\n     bool has_value = false;\n \n public:\n-    static constexpr bool is_nullable = IS_NULLABLE;\n+    static constexpr bool result_is_nullable = RESULT_IS_NULLABLE;\n+    static constexpr bool should_skip_null_arguments = !RESULT_IS_NULLABLE;\n     static constexpr bool is_any = false;\n \n     bool has() const\n     {\n-        if constexpr (is_nullable)\n+        if constexpr (result_is_nullable)\n             return has_value;\n         return !value.isNull();\n     }\n@@ -820,14 +823,14 @@ struct SingleValueDataGeneric\n     void change(const IColumn & column, size_t row_num, Arena *)\n     {\n         column.get(row_num, value);\n-        if constexpr (is_nullable)\n+        if constexpr (result_is_nullable)\n             has_value = true;\n     }\n \n     void change(const Self & to, Arena *)\n     {\n         value = to.value;\n-        if constexpr (is_nullable)\n+        if constexpr (result_is_nullable)\n             has_value = true;\n     }\n \n@@ -844,7 +847,7 @@ struct SingleValueDataGeneric\n \n     bool changeFirstTime(const Self & to, Arena * arena)\n     {\n-        if (!has() && (is_nullable || to.has()))\n+        if (!has() && (result_is_nullable || to.has()))\n         {\n             change(to, arena);\n             return true;\n@@ -879,7 +882,7 @@ struct SingleValueDataGeneric\n         }\n         else\n         {\n-            if constexpr (is_nullable)\n+            if constexpr (result_is_nullable)\n             {\n                 Field new_value;\n                 column.get(row_num, new_value);\n@@ -910,7 +913,7 @@ struct SingleValueDataGeneric\n     {\n         if (!to.has())\n             return false;\n-        if constexpr (is_nullable)\n+        if constexpr (result_is_nullable)\n         {\n             if (!has())\n             {\n@@ -945,7 +948,7 @@ struct SingleValueDataGeneric\n         }\n         else\n         {\n-            if constexpr (is_nullable)\n+            if constexpr (result_is_nullable)\n             {\n                 Field new_value;\n                 column.get(row_num, new_value);\n@@ -975,7 +978,7 @@ struct SingleValueDataGeneric\n     {\n         if (!to.has())\n             return false;\n-        if constexpr (is_nullable)\n+        if constexpr (result_is_nullable)\n         {\n             if (!value.isNull() && (to.value.isNull() || value < to.value))\n             {\n@@ -1138,13 +1141,20 @@ struct AggregateFunctionAnyLastData : Data\n #endif\n };\n \n+\n+/** The aggregate function 'singleValueOrNull' is used to implement subquery operators,\n+  * such as x = ALL (SELECT ...)\n+  * It checks if there is only one unique non-NULL value in the data.\n+  * If there is only one unique value - returns it.\n+  * If there are zero or at least two distinct values - returns NULL.\n+  */\n template <typename Data>\n struct AggregateFunctionSingleValueOrNullData : Data\n {\n-    static constexpr bool is_nullable = true;\n-\n     using Self = AggregateFunctionSingleValueOrNullData;\n \n+    static constexpr bool result_is_nullable = true;\n+\n     bool first_value = true;\n     bool is_null = false;\n \n@@ -1166,7 +1176,7 @@ struct AggregateFunctionSingleValueOrNullData : Data\n         if (!to.has())\n             return;\n \n-        if (first_value)\n+        if (first_value && !to.first_value)\n         {\n             first_value = false;\n             this->change(to, arena);\n@@ -1311,7 +1321,7 @@ class AggregateFunctionsSingleValue final : public IAggregateFunctionDataHelper<\n \n     static DataTypePtr createResultType(const DataTypePtr & type_)\n     {\n-        if constexpr (Data::is_nullable)\n+        if constexpr (Data::result_is_nullable)\n             return makeNullable(type_);\n         return type_;\n     }\n@@ -1431,13 +1441,13 @@ class AggregateFunctionsSingleValue final : public IAggregateFunctionDataHelper<\n     }\n \n     AggregateFunctionPtr getOwnNullAdapter(\n-        const AggregateFunctionPtr & nested_function,\n+        const AggregateFunctionPtr & original_function,\n         const DataTypes & /*arguments*/,\n         const Array & /*params*/,\n         const AggregateFunctionProperties & /*properties*/) const override\n     {\n-        if (Data::is_nullable)\n-            return nested_function;\n+        if (Data::result_is_nullable && !Data::should_skip_null_arguments)\n+            return original_function;\n         return nullptr;\n     }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02812_subquery_operators.reference b/tests/queries/0_stateless/02812_subquery_operators.reference\nnew file mode 100644\nindex 000000000000..aed0a046f996\n--- /dev/null\n+++ b/tests/queries/0_stateless/02812_subquery_operators.reference\n@@ -0,0 +1,6 @@\n+\n+Hello\n+Hello\n+123\n+1\n+\t['\\0']\t[]\t\\0\t['']\ndiff --git a/tests/queries/0_stateless/02812_subquery_operators.sql b/tests/queries/0_stateless/02812_subquery_operators.sql\nnew file mode 100644\nindex 000000000000..b0638b43e899\n--- /dev/null\n+++ b/tests/queries/0_stateless/02812_subquery_operators.sql\n@@ -0,0 +1,6 @@\n+SELECT singleValueOrNull(toNullable(''));\n+SELECT singleValueOrNull(toNullable('Hello'));\n+SELECT singleValueOrNull((SELECT 'Hello'));\n+SELECT singleValueOrNull(toNullable(123));\n+SELECT '' = ALL (SELECT toNullable(''));\n+SELECT '', ['\\0'], [], singleValueOrNull(( SELECT '\\0' ) ), [''];\n",
  "problem_statement": "nullptr dereference in subquery operators\nOriginally logical error in the test, and a segmentation fault in Fiddle.\r\n\r\n**Test:** https://s3.amazonaws.com/clickhouse-test-reports/51881/c7ccf23a24a7fb2bb1245b76fc9169649cd474c3/stateless_tests__debug__[5_5].html\r\n\r\n**Fiddle:** https://fiddle.clickhouse.com/1e170d25-91cf-4730-918f-045a407efec5\r\n\r\n**Logs:**\r\n```[b302d84f6a02] 2023.07.07 02:04:23.262906 [ 326 ] <Fatal> BaseDaemon: ########################################\r\n[b302d84f6a02] 2023.07.07 02:04:23.262972 [ 326 ] <Fatal> BaseDaemon: (version 23.6.1.1524 (official build), build id: 39AC174BEE13B59373FF7F29F65984557B4408B0, git hash: d1c7e13d08868cb04d3562dcced704dd577cb1df) (from thread 322) (query_id: c5d7191d-6a92-488f-a289-c961b19c9d3f) (query: SELECT '', ['\\0'], [], singleValueOrNull(( SELECT '\\0' ) ), [''];) Received signal Segmentation fault (11)\r\n[b302d84f6a02] 2023.07.07 02:04:23.263002 [ 326 ] <Fatal> BaseDaemon: Address: 0x7f72dabdaff8. Access: read. Address not mapped to object.\r\n[b302d84f6a02] 2023.07.07 02:04:23.263030 [ 326 ] <Fatal> BaseDaemon: Stack trace: 0x0000000010b23cae 0x0000000010b226b1 0x000000001313ca7f 0x000000001313c253 0x0000000014e9ece8 0x0000000014e9aac7 0x0000000014ca3bc9 0x0000000014c9a890 0x0000000014c9ba23 0x000000000e2d5be3 0x000000000e2d83f5 0x000000000e2d1a74 0x000000000e2d7281 0x00007f738746f609 0x00007f7387394133\r\n[b302d84f6a02] 2023.07.07 02:04:23.263100 [ 326 ] <Fatal> BaseDaemon: 2. ? @ 0x0000000010b23cae in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263125 [ 326 ] <Fatal> BaseDaemon: 3. ? @ 0x0000000010b226b1 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263146 [ 326 ] <Fatal> BaseDaemon: 4. ? @ 0x000000001313ca7f in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263191 [ 326 ] <Fatal> BaseDaemon: 5. DB::Aggregator::executeOnBlock(std::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn>>>, unsigned long, unsigned long, DB::AggregatedDataVariants&, std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*>>&, std::vector<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*>>, std::allocator<std::vector<DB::IColumn const*, std::allocator<DB::IColumn const*>>>>&, bool&) const @ 0x000000001313c253 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263223 [ 326 ] <Fatal> BaseDaemon: 6. DB::AggregatingTransform::consume(DB::Chunk) @ 0x0000000014e9ece8 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263248 [ 326 ] <Fatal> BaseDaemon: 7. DB::AggregatingTransform::work() @ 0x0000000014e9aac7 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263273 [ 326 ] <Fatal> BaseDaemon: 8. DB::ExecutionThreadContext::executeTask() @ 0x0000000014ca3bc9 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263301 [ 326 ] <Fatal> BaseDaemon: 9. DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x0000000014c9a890 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263326 [ 326 ] <Fatal> BaseDaemon: 10. ? @ 0x0000000014c9ba23 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263358 [ 326 ] <Fatal> BaseDaemon: 11. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0x000000000e2d5be3 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263392 [ 326 ] <Fatal> BaseDaemon: 12. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000e2d83f5 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263419 [ 326 ] <Fatal> BaseDaemon: 13. ThreadPoolImpl<std::thread>::worker(std::__list_iterator<std::thread, void*>) @ 0x000000000e2d1a74 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263436 [ 326 ] <Fatal> BaseDaemon: 14. ? @ 0x000000000e2d7281 in /usr/bin/clickhouse\r\n[b302d84f6a02] 2023.07.07 02:04:23.263458 [ 326 ] <Fatal> BaseDaemon: 15. ? @ 0x00007f738746f609 in ?\r\n[b302d84f6a02] 2023.07.07 02:04:23.263495 [ 326 ] <Fatal> BaseDaemon: 16. __clone @ 0x00007f7387394133 in ?\r\n[b302d84f6a02] 2023.07.07 02:04:23.391920 [ 326 ] <Fatal> BaseDaemon: Integrity check of the executable successfully passed (checksum: 2CCE0342490FE96D02C1130FB4CA7EE2)\r\n[b302d84f6a02] 2023.07.07 02:04:23.392087 [ 326 ] <Fatal> BaseDaemon: Report this error to https://github.com/ClickHouse/ClickHouse/issues\r\n[b302d84f6a02] 2023.07.07 02:04:23.392184 [ 326 ] <Fatal> BaseDaemon: Changed settings: output_format_pretty_color = false, output_format_pretty_grid_charset = 'ASCII'\r\n```\r\n\n",
  "hints_text": "`clickhouse-local --query \"SELECT singleValueOrNull(toNullable(''))\"`\r\n`clickhouse-local --query \"SELECT '' = ALL (SELECT toNullable(''))\"`\nThe bug was introduced here: https://github.com/ClickHouse/ClickHouse/pull/46467",
  "created_at": "2023-07-07T03:32:00Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionMinMaxAny.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02812_subquery_operators.reference",
    "b/tests/queries/0_stateless/02812_subquery_operators.sql"
  ]
}