diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp
index e01eef980062..b1dda4b4da9c 100644
--- a/programs/client/Client.cpp
+++ b/programs/client/Client.cpp
@@ -684,7 +684,7 @@ class Client : public Poco::Util::Application
                     if (ignore_error)
                     {
                         Tokens tokens(begin, end);
-                        IParser::Pos token_iterator(tokens);
+                        IParser::Pos token_iterator(tokens, context.getSettingsRef().max_parser_depth);
                         while (token_iterator->type != TokenType::Semicolon && token_iterator.isValid())
                             ++token_iterator;
                         begin = token_iterator->end;
@@ -958,10 +958,15 @@ class Client : public Poco::Util::Application
         ParserQuery parser(end, true);
         ASTPtr res;
 
+        const auto & settings = context.getSettingsRef();
+        size_t max_length = 0;
+        if (!allow_multi_statements)
+            max_length = settings.max_query_size;
+
         if (is_interactive || ignore_error)
         {
             String message;
-            res = tryParseQuery(parser, pos, end, message, true, "", allow_multi_statements, 0);
+            res = tryParseQuery(parser, pos, end, message, true, "", allow_multi_statements, max_length, settings.max_parser_depth);
 
             if (!res)
             {
@@ -970,7 +975,7 @@ class Client : public Poco::Util::Application
             }
         }
         else
-            res = parseQueryAndMovePosition(parser, pos, end, "", allow_multi_statements, 0);
+            res = parseQueryAndMovePosition(parser, pos, end, "", allow_multi_statements, max_length, settings.max_parser_depth);
 
         if (is_interactive)
         {
diff --git a/programs/compressor/Compressor.cpp b/programs/compressor/Compressor.cpp
index 98a3055da28d..fecdad9bcead 100644
--- a/programs/compressor/Compressor.cpp
+++ b/programs/compressor/Compressor.cpp
@@ -14,6 +14,7 @@
 #include <Parsers/ExpressionElementParsers.h>
 #include <Compression/CompressionFactory.h>
 #include <Common/TerminalSize.h>
+#include <Core/Defines.h>
 
 
 namespace DB
@@ -123,7 +124,7 @@ int mainEntryClickHouseCompressor(int argc, char ** argv)
             DB::ParserCodec codec_parser;
 
             std::string codecs_line = boost::algorithm::join(codecs, ",");
-            auto ast = DB::parseQuery(codec_parser, "(" + codecs_line + ")", 0);
+            auto ast = DB::parseQuery(codec_parser, "(" + codecs_line + ")", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
             codec = DB::CompressionCodecFactory::instance().get(ast, nullptr);
         }
         else
diff --git a/programs/copier/ClusterCopier.cpp b/programs/copier/ClusterCopier.cpp
index c4714ff201fb..cd5b1e2a2cde 100644
--- a/programs/copier/ClusterCopier.cpp
+++ b/programs/copier/ClusterCopier.cpp
@@ -1197,7 +1197,9 @@ TaskStatus ClusterCopier::processPartitionPieceTaskImpl(
             query += " LIMIT " + limit;
 
         ParserQuery p_query(query.data() + query.size());
-        return parseQuery(p_query, query, 0);
+
+        const auto & settings = context.getSettingsRef();
+        return parseQuery(p_query, query, settings.max_query_size, settings.max_parser_depth);
     };
 
     /// Load balancing
@@ -1409,7 +1411,8 @@ TaskStatus ClusterCopier::processPartitionPieceTaskImpl(
             query += "INSERT INTO " + getQuotedTable(split_table_for_current_piece) + " VALUES ";
 
             ParserQuery p_query(query.data() + query.size());
-            query_insert_ast = parseQuery(p_query, query, 0);
+            const auto & settings = context.getSettingsRef();
+            query_insert_ast = parseQuery(p_query, query, settings.max_query_size, settings.max_parser_depth);
 
             LOG_DEBUG(log, "Executing INSERT query: " << query);
         }
@@ -1634,7 +1637,8 @@ ASTPtr ClusterCopier::getCreateTableForPullShard(const ConnectionTimeouts & time
             &task_cluster->settings_pull);
 
     ParserCreateQuery parser_create_query;
-    return parseQuery(parser_create_query, create_query_pull_str, 0);
+    const auto & settings = context.getSettingsRef();
+    return parseQuery(parser_create_query, create_query_pull_str, settings.max_query_size, settings.max_parser_depth);
 }
 
 /// If it is implicitly asked to create split Distributed table for certain piece on current shard, we will do it.
@@ -1712,7 +1716,8 @@ std::set<String> ClusterCopier::getShardPartitions(const ConnectionTimeouts & ti
     }
 
     ParserQuery parser_query(query.data() + query.size());
-    ASTPtr query_ast = parseQuery(parser_query, query, 0);
+    const auto & settings = context.getSettingsRef();
+    ASTPtr query_ast = parseQuery(parser_query, query, settings.max_query_size, settings.max_parser_depth);
 
     LOG_DEBUG(log, "Computing destination partition set, executing query: " << query);
 
@@ -1759,7 +1764,8 @@ bool ClusterCopier::checkShardHasPartition(const ConnectionTimeouts & timeouts,
                                      << partition_quoted_name << " existence, executing query: " << query);
 
     ParserQuery parser_query(query.data() + query.size());
-    ASTPtr query_ast = parseQuery(parser_query, query, 0);
+const auto & settings = context.getSettingsRef();
+    ASTPtr query_ast = parseQuery(parser_query, query, settings.max_query_size, settings.max_parser_depth);
 
     Context local_context = context;
     local_context.setSettings(task_cluster->settings_pull);
@@ -1793,7 +1799,8 @@ bool ClusterCopier::checkPresentPartitionPiecesOnCurrentShard(const ConnectionTi
                    << "existence, executing query: " << query);
 
     ParserQuery parser_query(query.data() + query.size());
-    ASTPtr query_ast = parseQuery(parser_query, query, 0);
+    const auto & settings = context.getSettingsRef();
+    ASTPtr query_ast = parseQuery(parser_query, query, settings.max_query_size, settings.max_parser_depth);
 
     Context local_context = context;
     local_context.setSettings(task_cluster->settings_pull);
@@ -1826,7 +1833,8 @@ UInt64 ClusterCopier::executeQueryOnCluster(
     if (query_ast_ == nullptr)
     {
         ParserQuery p_query(query.data() + query.size());
-        query_ast = parseQuery(p_query, query, 0);
+        const auto & settings = context.getSettingsRef();
+        query_ast = parseQuery(p_query, query, settings.max_query_size, settings.max_parser_depth);
     }
     else
         query_ast = query_ast_;
diff --git a/programs/copier/TaskTableAndShard.h b/programs/copier/TaskTableAndShard.h
index 615ad297b799..32841e93a145 100644
--- a/programs/copier/TaskTableAndShard.h
+++ b/programs/copier/TaskTableAndShard.h
@@ -4,6 +4,9 @@
 #include "Internals.h"
 #include "ClusterPartition.h"
 
+#include <Core/Defines.h>
+
+
 namespace DB
 {
 namespace ErrorCodes
@@ -260,9 +263,10 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf
                + "." + escapeForFileName(table_push.second);
 
     engine_push_str = config.getString(table_prefix + "engine");
+
     {
         ParserStorage parser_storage;
-        engine_push_ast = parseQuery(parser_storage, engine_push_str, 0);
+        engine_push_ast = parseQuery(parser_storage, engine_push_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
         engine_push_partition_key_ast = extractPartitionKey(engine_push_ast);
         primary_key_comma_separated = createCommaSeparatedStringFrom(extractPrimaryKeyColumnNames(engine_push_ast));
         engine_push_zk_path = extractReplicatedTableZookeeperPath(engine_push_ast);
@@ -273,7 +277,7 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf
     auxiliary_engine_split_asts.reserve(number_of_splits);
     {
         ParserExpressionWithOptionalAlias parser_expression(false);
-        sharding_key_ast = parseQuery(parser_expression, sharding_key_str, 0);
+        sharding_key_ast = parseQuery(parser_expression, sharding_key_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
         main_engine_split_ast = createASTStorageDistributed(cluster_push_name, table_push.first, table_push.second,
                                                             sharding_key_ast);
 
@@ -291,7 +295,7 @@ inline TaskTable::TaskTable(TaskCluster & parent, const Poco::Util::AbstractConf
     if (!where_condition_str.empty())
     {
         ParserExpressionWithOptionalAlias parser_expression(false);
-        where_condition_ast = parseQuery(parser_expression, where_condition_str, 0);
+        where_condition_ast = parseQuery(parser_expression, where_condition_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
         // Will use canonical expression form
         where_condition_str = queryToString(where_condition_ast);
diff --git a/programs/format/Format.cpp b/programs/format/Format.cpp
index f826d6394bc0..b5a4e2d16032 100644
--- a/programs/format/Format.cpp
+++ b/programs/format/Format.cpp
@@ -53,7 +53,7 @@ int mainEntryClickHouseFormat(int argc, char ** argv)
         const char * end = pos + query.size();
 
         ParserQuery parser(end);
-        ASTPtr res = parseQuery(parser, pos, end, "query", 0);
+        ASTPtr res = parseQuery(parser, pos, end, "query", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
         if (!quiet)
         {
diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp
index 26752da5d87e..1ab07d79401a 100644
--- a/programs/local/LocalServer.cpp
+++ b/programs/local/LocalServer.cpp
@@ -267,8 +267,10 @@ void LocalServer::processQueries()
     String initial_create_query = getInitialCreateTableQuery();
     String queries_str = initial_create_query + config().getRawString("query");
 
+    const auto & settings = context->getSettingsRef();
+
     std::vector<String> queries;
-    auto parse_res = splitMultipartQuery(queries_str, queries);
+    auto parse_res = splitMultipartQuery(queries_str, queries, settings.max_query_size, settings.max_parser_depth);
 
     if (!parse_res.second)
         throw Exception("Cannot parse and execute the following part of query: " + String(parse_res.first), ErrorCodes::SYNTAX_ERROR);
diff --git a/programs/odbc-bridge/ColumnInfoHandler.cpp b/programs/odbc-bridge/ColumnInfoHandler.cpp
index b89d50569f68..e3c00f48fb52 100644
--- a/programs/odbc-bridge/ColumnInfoHandler.cpp
+++ b/programs/odbc-bridge/ColumnInfoHandler.cpp
@@ -120,12 +120,14 @@ void ODBCColumnsInfoHandler::handleRequest(Poco::Net::HTTPServerRequest & reques
 
         SCOPE_EXIT(SQLFreeStmt(hstmt, SQL_DROP));
 
+        const auto & context_settings = context->getSettingsRef();
+
         /// TODO Why not do SQLColumns instead?
         std::string name = schema_name.empty() ? table_name : schema_name + "." + table_name;
         std::stringstream ss;
         std::string input = "SELECT * FROM " + name + " WHERE 1 = 0";
         ParserQueryWithOutput parser;
-        ASTPtr select = parseQuery(parser, input.data(), input.data() + input.size(), "", 0);
+        ASTPtr select = parseQuery(parser, input.data(), input.data() + input.size(), "", context_settings.max_query_size, context_settings.max_parser_depth);
 
         IAST::FormatSettings settings(ss, true);
         settings.always_quote_identifiers = true;
diff --git a/src/Access/DiskAccessStorage.cpp b/src/Access/DiskAccessStorage.cpp
index 12c65e7df1e7..d7ba8563f5a1 100644
--- a/src/Access/DiskAccessStorage.cpp
+++ b/src/Access/DiskAccessStorage.cpp
@@ -32,6 +32,7 @@
 #include <Interpreters/InterpreterShowCreateAccessEntityQuery.h>
 #include <Interpreters/InterpreterShowGrantsQuery.h>
 #include <Common/quoteString.h>
+#include <Core/Defines.h>
 #include <boost/range/adaptor/map.hpp>
 #include <boost/range/algorithm/copy.hpp>
 #include <boost/range/algorithm_ext/push_back.hpp>
@@ -93,7 +94,7 @@ namespace
         const char * end = begin + file_contents.size();
         while (pos < end)
         {
-            queries.emplace_back(parseQueryAndMovePosition(parser, pos, end, "", true, 0));
+            queries.emplace_back(parseQueryAndMovePosition(parser, pos, end, "", true, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH));
             while (isWhitespaceASCII(*pos) || *pos == ';')
                 ++pos;
         }
diff --git a/src/Access/RowPolicyCache.cpp b/src/Access/RowPolicyCache.cpp
index 44f2cd160d46..fc67b7e9b86d 100644
--- a/src/Access/RowPolicyCache.cpp
+++ b/src/Access/RowPolicyCache.cpp
@@ -8,6 +8,7 @@
 #include <Common/quoteString.h>
 #include <ext/range.h>
 #include <boost/smart_ptr/make_shared.hpp>
+#include <Core/Defines.h>
 
 
 namespace DB
@@ -77,7 +78,7 @@ void RowPolicyCache::PolicyInfo::setPolicy(const RowPolicyPtr & policy_)
         try
         {
             ParserExpression parser;
-            parsed_conditions[type] = parseQuery(parser, condition, 0);
+            parsed_conditions[type] = parseQuery(parser, condition, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
         }
         catch (...)
         {
diff --git a/src/AggregateFunctions/parseAggregateFunctionParameters.cpp b/src/AggregateFunctions/parseAggregateFunctionParameters.cpp
index bcb73f1e9d9b..2a6b9e3b4997 100644
--- a/src/AggregateFunctions/parseAggregateFunctionParameters.cpp
+++ b/src/AggregateFunctions/parseAggregateFunctionParameters.cpp
@@ -2,6 +2,7 @@
 #include <Parsers/ExpressionListParsers.h>
 #include <Parsers/parseQuery.h>
 #include <Common/typeid_cast.h>
+#include <Core/Defines.h>
 
 
 namespace DB
@@ -65,7 +66,7 @@ void getAggregateFunctionNameAndParametersArray(
     ParserExpressionList params_parser(false);
     ASTPtr args_ast = parseQuery(params_parser,
         parameters_str.data(), parameters_str.data() + parameters_str.size(),
-        "parameters of aggregate function in " + error_context, 0);
+        "parameters of aggregate function in " + error_context, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
     if (args_ast->children.empty())
         throw Exception("Incorrect list of parameters to aggregate function "
diff --git a/src/Core/Defines.h b/src/Core/Defines.h
index c797f527be97..fe614cec6bde 100644
--- a/src/Core/Defines.h
+++ b/src/Core/Defines.h
@@ -95,3 +95,6 @@
 /// Actually, there may be multiple acquisitions of different locks for a given table within one query.
 /// Check with IStorage class for the list of possible locks
 #define DBMS_DEFAULT_LOCK_ACQUIRE_TIMEOUT_SEC 120
+
+/// Default limit on recursion depth of recursive descend parser.
+#define DBMS_DEFAULT_MAX_PARSER_DEPTH 1000
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 725171d4a1b9..325abc16f3f0 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -404,7 +404,7 @@ struct Settings : public SettingsCollection<Settings>
     M(SettingBool, use_compact_format_in_distributed_parts_names, false, "Changes format of directories names for distributed table insert parts.", 0) \
     M(SettingUInt64, multiple_joins_rewriter_version, 1, "1 or 2. Second rewriter version knows about table columns and keep not clashed names as is.", 0) \
     M(SettingBool, validate_polygons, true, "Throw exception if polygon is invalid in function pointInPolygon (e.g. self-tangent, self-intersecting). If the setting is false, the function will accept invalid polygons but may silently return wrong result.", 0) \
-    M(SettingUInt64, max_parser_depth, 1000, "Maximum parser depth.", 0) \
+    M(SettingUInt64, max_parser_depth, DBMS_DEFAULT_MAX_PARSER_DEPTH, "Maximum parser depth (recursion depth of recursive descend parser).", 0) \
     M(SettingSeconds, temporary_live_view_timeout, DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC, "Timeout after which temporary live view is deleted.", 0) \
     M(SettingBool, transform_null_in, false, "If enabled, NULL values will be matched with 'IN' operator as if they are considered equal.", 0) \
     M(SettingBool, allow_nondeterministic_mutations, false, "Allow non-deterministic functions in ALTER UPDATE/ALTER DELETE statements", 0) \
diff --git a/src/DataTypes/DataTypeFactory.cpp b/src/DataTypes/DataTypeFactory.cpp
index 20f7681ec1b0..f81adfe347c5 100644
--- a/src/DataTypes/DataTypeFactory.cpp
+++ b/src/DataTypes/DataTypeFactory.cpp
@@ -9,6 +9,8 @@
 #include <Poco/String.h>
 #include <Common/StringUtils/StringUtils.h>
 #include <IO/WriteHelpers.h>
+#include <Core/Defines.h>
+
 
 namespace DB
 {
@@ -26,7 +28,7 @@ namespace ErrorCodes
 DataTypePtr DataTypeFactory::get(const String & full_name) const
 {
     ParserIdentifierWithOptionalParameters parser;
-    ASTPtr ast = parseQuery(parser, full_name.data(), full_name.data() + full_name.size(), "data type", 0);
+    ASTPtr ast = parseQuery(parser, full_name.data(), full_name.data() + full_name.size(), "data type", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
     return get(ast);
 }
 
diff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp
index a1f5ea1ae6ff..11c4a4400cdb 100644
--- a/src/Databases/DatabaseOrdinary.cpp
+++ b/src/Databases/DatabaseOrdinary.cpp
@@ -234,7 +234,8 @@ void DatabaseOrdinary::alterTable(
     }
 
     ParserCreateQuery parser;
-    ASTPtr ast = parseQuery(parser, statement.data(), statement.data() + statement.size(), "in file " + table_metadata_path, 0);
+    ASTPtr ast = parseQuery(parser, statement.data(), statement.data() + statement.size(), "in file " + table_metadata_path,
+        0, context.getSettingsRef().max_parser_depth);
 
     auto & ast_create_query = ast->as<ASTCreateQuery &>();
 
diff --git a/src/Interpreters/DDLWorker.cpp b/src/Interpreters/DDLWorker.cpp
index 4a39cc6b8a1f..e786849d121a 100644
--- a/src/Interpreters/DDLWorker.cpp
+++ b/src/Interpreters/DDLWorker.cpp
@@ -463,7 +463,7 @@ void DDLWorker::parseQueryAndResolveHost(DDLTask & task)
 
         ParserQuery parser_query(end);
         String description;
-        task.query = parseQuery(parser_query, begin, end, description, 0);
+        task.query = parseQuery(parser_query, begin, end, description, 0, context.getSettingsRef().max_parser_depth);
     }
 
     // XXX: serious design flaw since `ASTQueryWithOnCluster` is not inherited from `IAST`!
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 076b654548b0..37e2c8c59453 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -6,6 +6,8 @@
 #include <Common/escapeForFileName.h>
 #include <Common/typeid_cast.h>
 
+#include <Core/Defines.h>
+
 #include <IO/WriteBufferFromFile.h>
 #include <IO/WriteHelpers.h>
 
@@ -181,7 +183,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const NamesAndTypesList & columns)
         String type_name = column.type->getName();
         auto pos = type_name.data();
         const auto end = pos + type_name.size();
-        column_declaration->type = parseQuery(storage_p, pos, end, "data type", 0);
+        column_declaration->type = parseQuery(storage_p, pos, end, "data type", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
         columns_list->children.emplace_back(column_declaration);
     }
 
@@ -207,7 +209,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)
         String type_name = column.type->getName();
         auto type_name_pos = type_name.data();
         const auto type_name_end = type_name_pos + type_name.size();
-        column_declaration->type = parseQuery(storage_p, type_name_pos, type_name_end, "data type", 0);
+        column_declaration->type = parseQuery(storage_p, type_name_pos, type_name_end, "data type", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
         if (column.default_desc.expression)
         {
@@ -227,7 +229,7 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)
             auto codec_desc_pos = codec_desc.data();
             const auto codec_desc_end = codec_desc_pos + codec_desc.size();
             ParserIdentifierWithParameters codec_p;
-            column_declaration->codec = parseQuery(codec_p, codec_desc_pos, codec_desc_end, "column codec", 0);
+            column_declaration->codec = parseQuery(codec_p, codec_desc_pos, codec_desc_end, "column codec", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
         }
 
         if (column.ttl)
diff --git a/src/Interpreters/InterpreterKillQueryQuery.cpp b/src/Interpreters/InterpreterKillQueryQuery.cpp
index b23d88524e1f..23f39ab3fc58 100644
--- a/src/Interpreters/InterpreterKillQueryQuery.cpp
+++ b/src/Interpreters/InterpreterKillQueryQuery.cpp
@@ -267,7 +267,7 @@ BlockIO InterpreterKillQueryQuery::execute()
                 else
                 {
                     ParserAlterCommand parser;
-                    auto command_ast = parseQuery(parser, command_col.getDataAt(i).toString(), 0);
+                    auto command_ast = parseQuery(parser, command_col.getDataAt(i).toString(), 0, context.getSettingsRef().max_parser_depth);
                     required_access_rights = InterpreterAlterQuery::getRequiredAccessForCommand(command_ast->as<const ASTAlterCommand &>(), table_id.database_name, table_id.table_name);
                     if (!access->isGranted(&Poco::Logger::get("InterpreterKillQueryQuery"), required_access_rights))
                     {
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 82fc4d0873e5..691b3c1045b5 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -137,7 +137,7 @@ String InterpreterSelectQuery::generateFilterActions(ExpressionActionsPtr & acti
     for (const auto & column_str : prerequisite_columns)
     {
         ParserExpression expr_parser;
-        expr_list->children.push_back(parseQuery(expr_parser, column_str, 0));
+        expr_list->children.push_back(parseQuery(expr_parser, column_str, 0, context->getSettingsRef().max_parser_depth));
     }
 
     select_ast->setExpression(ASTSelectQuery::Expression::TABLES, std::make_shared<ASTTablesInSelectQuery>());
diff --git a/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp b/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp
index 4c2dcc19a886..0d3b88facceb 100644
--- a/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp
+++ b/src/Interpreters/InterpreterShowCreateAccessEntityQuery.cpp
@@ -21,6 +21,7 @@
 #include <DataStreams/OneBlockInputStream.h>
 #include <DataTypes/DataTypeString.h>
 #include <Common/StringUtils/StringUtils.h>
+#include <Core/Defines.h>
 #include <ext/range.h>
 #include <sstream>
 
@@ -37,7 +38,7 @@ namespace
     ASTPtr getCreateQueryImpl(
         const User & user,
         const AccessControlManager * manager /* not used if attach_mode == true */,
-        bool attach_mode = false)
+        bool attach_mode)
     {
         auto query = std::make_shared<ASTCreateUserQuery>();
         query->name = user.getName();
@@ -72,7 +73,7 @@ namespace
     }
 
 
-    ASTPtr getCreateQueryImpl(const Role & role, const AccessControlManager * manager, bool attach_mode = false)
+    ASTPtr getCreateQueryImpl(const Role & role, const AccessControlManager * manager, bool attach_mode)
     {
         auto query = std::make_shared<ASTCreateRoleQuery>();
         query->name = role.getName();
@@ -90,7 +91,7 @@ namespace
     }
 
 
-    ASTPtr getCreateQueryImpl(const SettingsProfile & profile, const AccessControlManager * manager, bool attach_mode = false)
+    ASTPtr getCreateQueryImpl(const SettingsProfile & profile, const AccessControlManager * manager, bool attach_mode)
     {
         auto query = std::make_shared<ASTCreateSettingsProfileQuery>();
         query->name = profile.getName();
@@ -121,7 +122,7 @@ namespace
     ASTPtr getCreateQueryImpl(
         const Quota & quota,
         const AccessControlManager * manager /* not used if attach_mode == true */,
-        bool attach_mode = false)
+        bool attach_mode)
     {
         auto query = std::make_shared<ASTCreateQuotaQuery>();
         query->name = quota.getName();
@@ -156,7 +157,7 @@ namespace
     ASTPtr getCreateQueryImpl(
         const RowPolicy & policy,
         const AccessControlManager * manager /* not used if attach_mode == true */,
-        bool attach_mode = false)
+        bool attach_mode)
     {
         auto query = std::make_shared<ASTCreateRowPolicyQuery>();
         query->name_parts = RowPolicy::FullNameParts{policy.getDatabase(), policy.getTableName(), policy.getName()};
@@ -171,7 +172,7 @@ namespace
             if (!condition.empty())
             {
                 ParserExpression parser;
-                ASTPtr expr = parseQuery(parser, condition, 0);
+                ASTPtr expr = parseQuery(parser, condition, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
                 query->conditions.push_back(std::pair{index, expr});
             }
         }
@@ -190,7 +191,7 @@ namespace
     ASTPtr getCreateQueryImpl(
         const IAccessEntity & entity,
         const AccessControlManager * manager /* not used if attach_mode == true */,
-        bool attach_mode = false)
+        bool attach_mode)
     {
         if (const User * user = typeid_cast<const User *>(&entity))
             return getCreateQueryImpl(*user, manager, attach_mode);
@@ -264,24 +265,24 @@ ASTPtr InterpreterShowCreateAccessEntityQuery::getCreateQuery(const ASTShowCreat
     if (show_query.current_user)
     {
         auto user = context.getUser();
-        return getCreateQueryImpl(*user, &access_control);
+        return getCreateQueryImpl(*user, &access_control, false);
     }
 
     if (show_query.current_quota)
     {
         auto quota = access_control.read<Quota>(context.getQuota()->getUsageInfo().quota_id);
-        return getCreateQueryImpl(*quota, &access_control);
+        return getCreateQueryImpl(*quota, &access_control, false);
     }
 
     auto type = getType(show_query.kind);
     if (show_query.kind == Kind::ROW_POLICY)
     {
         RowPolicyPtr policy = access_control.read<RowPolicy>(show_query.row_policy_name.getFullName(context));
-        return getCreateQueryImpl(*policy, &access_control);
+        return getCreateQueryImpl(*policy, &access_control, false);
     }
 
     auto entity = access_control.read(access_control.getID(type, show_query.name));
-    return getCreateQueryImpl(*entity, &access_control);
+    return getCreateQueryImpl(*entity, &access_control, false);
 }
 
 
diff --git a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp
index 331c364c5faa..6a08e11ad9ec 100644
--- a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp
+++ b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp
@@ -14,6 +14,7 @@
 #include <Parsers/ExpressionListParsers.h>
 #include <Parsers/parseQuery.h>
 #include <IO/WriteHelpers.h>
+#include <Core/Defines.h>
 
 
 namespace DB
@@ -35,7 +36,7 @@ namespace
 ASTPtr makeSubqueryTemplate()
 {
     ParserTablesInSelectQueryElement parser(true);
-    ASTPtr subquery_template = parseQuery(parser, "(select * from _t) as `--.s`", 0);
+    ASTPtr subquery_template = parseQuery(parser, "(select * from _t) as `--.s`", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
     if (!subquery_template)
         throw Exception("Cannot parse subquery template", ErrorCodes::LOGICAL_ERROR);
     return subquery_template;
diff --git a/src/Interpreters/SyntaxAnalyzer.cpp b/src/Interpreters/SyntaxAnalyzer.cpp
index 5c1b6c7e62ba..e19961e7a7c2 100644
--- a/src/Interpreters/SyntaxAnalyzer.cpp
+++ b/src/Interpreters/SyntaxAnalyzer.cpp
@@ -1,4 +1,5 @@
 #include <Core/Settings.h>
+#include <Core/Defines.h>
 #include <Core/NamesAndTypes.h>
 
 #include <Interpreters/SyntaxAnalyzer.h>
@@ -587,7 +588,7 @@ void replaceJoinedTable(const ASTSelectQuery & select_query)
         if (table_id.alias.empty() && table_id.isShort())
         {
             ParserTableExpression parser;
-            table_expr = parseQuery(parser, expr, 0)->as<ASTTableExpression &>();
+            table_expr = parseQuery(parser, expr, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH)->as<ASTTableExpression &>();
         }
     }
 }
diff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h
index 7c8dc1606f79..9b0c273674c8 100644
--- a/src/Interpreters/SystemLog.h
+++ b/src/Interpreters/SystemLog.h
@@ -9,6 +9,7 @@
 #include <boost/noncopyable.hpp>
 #include <common/logger_useful.h>
 #include <Core/Types.h>
+#include <Core/Defines.h>
 #include <Storages/IStorage.h>
 #include <Interpreters/Context.h>
 #include <Common/Stopwatch.h>
@@ -460,7 +461,7 @@ ASTPtr SystemLog<LogElement>::getCreateTableQuery()
     ParserStorage storage_parser;
     ASTPtr storage_ast = parseQuery(
         storage_parser, storage_def.data(), storage_def.data() + storage_def.size(),
-        "Storage to create table for " + LogElement::name(), 0);
+        "Storage to create table for " + LogElement::name(), 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
     create->set(create->storage, storage_ast);
 
     return create;
diff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp
index 53954faa2c0b..42bef47a5013 100644
--- a/src/Interpreters/loadMetadata.cpp
+++ b/src/Interpreters/loadMetadata.cpp
@@ -36,7 +36,7 @@ static void executeCreateQuery(
     bool has_force_restore_data_flag)
 {
     ParserCreateQuery parser;
-    ASTPtr ast = parseQuery(parser, query.data(), query.data() + query.size(), "in file " + file_name, 0);
+    ASTPtr ast = parseQuery(parser, query.data(), query.data() + query.size(), "in file " + file_name, 0, context.getSettingsRef().max_parser_depth);
 
     auto & ast_create_query = ast->as<ASTCreateQuery &>();
     ast_create_query.attach = true;
diff --git a/src/Parsers/IParser.h b/src/Parsers/IParser.h
index 5bfbf1ed4768..69c199c201ef 100644
--- a/src/Parsers/IParser.h
+++ b/src/Parsers/IParser.h
@@ -56,8 +56,6 @@ class IParser
     /// Token iterator augmented with depth information. This allows to control recursion depth.
     struct Pos : TokenIterator
     {
-        using TokenIterator::TokenIterator;
-
         uint32_t depth = 0;
         uint32_t max_depth = 0;
 
diff --git a/src/Parsers/parseQuery.cpp b/src/Parsers/parseQuery.cpp
index b8ab940f2dde..ff537e0f70ee 100644
--- a/src/Parsers/parseQuery.cpp
+++ b/src/Parsers/parseQuery.cpp
@@ -328,19 +328,28 @@ ASTPtr parseQuery(
     IParser & parser,
     const std::string & query,
     const std::string & query_description,
-    size_t max_query_size)
+    size_t max_query_size,
+    size_t max_parser_depth)
 {
-    return parseQuery(parser, query.data(), query.data() + query.size(), query_description, max_query_size);
+    return parseQuery(parser, query.data(), query.data() + query.size(), query_description, max_query_size, max_parser_depth);
 }
 
 
-ASTPtr parseQuery(IParser & parser, const std::string & query, size_t max_query_size)
+ASTPtr parseQuery(
+    IParser & parser,
+    const std::string & query,
+    size_t max_query_size,
+    size_t max_parser_depth)
 {
-    return parseQuery(parser, query.data(), query.data() + query.size(), parser.getName(), max_query_size);
+    return parseQuery(parser, query.data(), query.data() + query.size(), parser.getName(), max_query_size, max_parser_depth);
 }
 
 
-std::pair<const char *, bool> splitMultipartQuery(const std::string & queries, std::vector<std::string> & queries_list)
+std::pair<const char *, bool> splitMultipartQuery(
+    const std::string & queries,
+    std::vector<std::string> & queries_list,
+    size_t max_query_size,
+    size_t max_parser_depth)
 {
     ASTPtr ast;
 
@@ -356,7 +365,7 @@ std::pair<const char *, bool> splitMultipartQuery(const std::string & queries, s
     {
         begin = pos;
 
-        ast = parseQueryAndMovePosition(parser, pos, end, "", true, 0);
+        ast = parseQueryAndMovePosition(parser, pos, end, "", true, max_query_size, max_parser_depth);
 
         auto * insert = ast->as<ASTInsertQuery>();
 
diff --git a/src/Parsers/parseQuery.h b/src/Parsers/parseQuery.h
index feea204181ea..14a9a85b22cc 100644
--- a/src/Parsers/parseQuery.h
+++ b/src/Parsers/parseQuery.h
@@ -17,7 +17,7 @@ ASTPtr tryParseQuery(
     bool allow_multi_statements,    /// If false, check for non-space characters after semicolon and set error message if any.
     size_t max_query_size,          /// If (end - pos) > max_query_size and query is longer than max_query_size then throws "Max query size exceeded".
                                     /// Disabled if zero. Is used in order to check query size if buffer can contains data for INSERT query.
-    size_t max_parser_depth = 0);
+    size_t max_parser_depth);
 
 
 /// Parse query or throw an exception with error message.
@@ -27,8 +27,8 @@ ASTPtr parseQueryAndMovePosition(
     const char * end,
     const std::string & description,
     bool allow_multi_statements,
-    size_t max_query_size = 0,
-    size_t max_parser_depth = 0);
+    size_t max_query_size,
+    size_t max_parser_depth);
 
 ASTPtr parseQuery(
     IParser & parser,
@@ -36,24 +36,30 @@ ASTPtr parseQuery(
     const char * end,
     const std::string & description,
     size_t max_query_size,
-    size_t max_parser_depth = 0);
+    size_t max_parser_depth);
 
 ASTPtr parseQuery(
     IParser & parser,
     const std::string & query,
     const std::string & query_description,
-    size_t max_query_size);
+    size_t max_query_size,
+    size_t max_parser_depth);
 
 ASTPtr parseQuery(
     IParser & parser,
     const std::string & query,
-    size_t max_query_size);
+    size_t max_query_size,
+    size_t max_parser_depth);
 
 
 /** Split queries separated by ; on to list of single queries
   * Returns pointer to the end of last successfully parsed query (first), and true if all queries are successfully parsed (second)
   * NOTE: INSERT's data should be placed in single line.
   */
-std::pair<const char *, bool> splitMultipartQuery(const std::string & queries, std::vector<std::string> & queries_list);
+std::pair<const char *, bool> splitMultipartQuery(
+    const std::string & queries,
+    std::vector<std::string> & queries_list,
+    size_t max_query_size,
+    size_t max_parser_depth);
 
 }
diff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp
index 76a55d059eec..c4f6d11605f1 100644
--- a/src/Storages/ColumnsDescription.cpp
+++ b/src/Storages/ColumnsDescription.cpp
@@ -23,11 +23,13 @@
 #include <Interpreters/Context.h>
 #include <Storages/IStorage.h>
 #include <Common/typeid_cast.h>
+#include <Core/Defines.h>
 #include <Compression/CompressionFactory.h>
 #include <Interpreters/ExpressionAnalyzer.h>
 #include <Interpreters/SyntaxAnalyzer.h>
 #include <Interpreters/ExpressionActions.h>
 
+
 namespace DB
 {
 
@@ -102,7 +104,7 @@ void ColumnDescription::readText(ReadBuffer & buf)
     ParserColumnDeclaration column_parser(/* require type */ true);
     String column_line;
     readEscapedStringUntilEOL(column_line, buf);
-    ASTPtr ast = parseQuery(column_parser, column_line, "column parser", 0);
+    ASTPtr ast = parseQuery(column_parser, column_line, "column parser", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
     if (const auto * col_ast = ast->as<ASTColumnDeclaration>())
     {
         name = col_ast->name;
diff --git a/src/Storages/ConstraintsDescription.cpp b/src/Storages/ConstraintsDescription.cpp
index ad0cd76733a6..8c38af0cd5eb 100644
--- a/src/Storages/ConstraintsDescription.cpp
+++ b/src/Storages/ConstraintsDescription.cpp
@@ -5,6 +5,8 @@
 #include <Parsers/parseQuery.h>
 #include <Parsers/ASTExpressionList.h>
 
+#include <Core/Defines.h>
+
 
 namespace DB
 {
@@ -28,7 +30,7 @@ ConstraintsDescription ConstraintsDescription::parse(const String & str)
 
     ConstraintsDescription res;
     ParserConstraintDeclarationList parser;
-    ASTPtr list = parseQuery(parser, str, 0);
+    ASTPtr list = parseQuery(parser, str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
     for (const auto & constraint : list->children)
         res.constraints.push_back(std::dynamic_pointer_cast<ASTConstraintDeclaration>(constraint));
diff --git a/src/Storages/IndicesDescription.cpp b/src/Storages/IndicesDescription.cpp
index a5772a835bfb..2363e7924bad 100644
--- a/src/Storages/IndicesDescription.cpp
+++ b/src/Storages/IndicesDescription.cpp
@@ -5,6 +5,9 @@
 #include <Parsers/ParserCreateQuery.h>
 #include <Parsers/parseQuery.h>
 
+#include <Core/Defines.h>
+
+
 namespace DB
 {
 
@@ -42,7 +45,7 @@ IndicesDescription IndicesDescription::parse(const String & str)
 
     IndicesDescription res;
     ParserIndexDeclarationList parser;
-    ASTPtr list = parseQuery(parser, str, 0);
+    ASTPtr list = parseQuery(parser, str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
     for (const auto & index : list->children)
         res.indices.push_back(std::dynamic_pointer_cast<ASTIndexDeclaration>(index));
diff --git a/src/Storages/MutationCommands.cpp b/src/Storages/MutationCommands.cpp
index d48f85251623..f3569c344d99 100644
--- a/src/Storages/MutationCommands.cpp
+++ b/src/Storages/MutationCommands.cpp
@@ -9,6 +9,7 @@
 #include <Parsers/ASTIdentifier.h>
 #include <Common/typeid_cast.h>
 #include <Common/quoteString.h>
+#include <Core/Defines.h>
 #include <DataTypes/DataTypeFactory.h>
 #include <Parsers/queryToString.h>
 #include <common/logger_useful.h>
@@ -137,7 +138,7 @@ void MutationCommands::readText(ReadBuffer & in)
 
     ParserAlterCommandList p_alter_commands;
     auto commands_ast = parseQuery(
-        p_alter_commands, commands_str.data(), commands_str.data() + commands_str.length(), "mutation commands list", 0);
+        p_alter_commands, commands_str.data(), commands_str.data() + commands_str.length(), "mutation commands list", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
     for (ASTAlterCommand * command_ast : commands_ast->as<ASTAlterCommandList &>().commands)
     {
         auto command = MutationCommand::parse(command_ast, true);
diff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp
index 556e7b41c52b..a19a424c6430 100644
--- a/src/Storages/StorageReplicatedMergeTree.cpp
+++ b/src/Storages/StorageReplicatedMergeTree.cpp
@@ -1,4 +1,5 @@
-#include <Disks/DiskSpaceMonitor.h>
+#include <Core/Defines.h>
+
 #include <Common/FieldVisitors.h>
 #include <Common/Macros.h>
 #include <Common/StringUtils/StringUtils.h>
@@ -25,6 +26,8 @@
 #include <Storages/MergeTree/ReplicatedMergeTreePartHeader.h>
 #include <Storages/VirtualColumnUtils.h>
 
+#include <Disks/DiskSpaceMonitor.h>
+
 #include <Databases/IDatabase.h>
 
 #include <Parsers/formatAST.h>
@@ -479,7 +482,7 @@ void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_column
         if (metadata_diff.sorting_key_changed)
         {
             ParserNotEmptyExpressionList parser(false);
-            auto new_sorting_key_expr_list = parseQuery(parser, metadata_diff.new_sorting_key, 0);
+            auto new_sorting_key_expr_list = parseQuery(parser, metadata_diff.new_sorting_key, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
             if (new_sorting_key_expr_list->children.size() == 1)
                 metadata.order_by_ast = new_sorting_key_expr_list->children[0];
@@ -507,7 +510,7 @@ void StorageReplicatedMergeTree::setTableStructure(ColumnsDescription new_column
         if (metadata_diff.ttl_table_changed)
         {
             ParserTTLExpressionList parser;
-            metadata.ttl_for_table_ast = parseQuery(parser, metadata_diff.new_ttl_table, 0);
+            metadata.ttl_for_table_ast = parseQuery(parser, metadata_diff.new_ttl_table, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
         }
     }
 
diff --git a/src/Storages/getStructureOfRemoteTable.cpp b/src/Storages/getStructureOfRemoteTable.cpp
index eb386c66d60a..3b4ee489b461 100644
--- a/src/Storages/getStructureOfRemoteTable.cpp
+++ b/src/Storages/getStructureOfRemoteTable.cpp
@@ -137,7 +137,7 @@ ColumnsDescription getStructureOfRemoteTableInShard(
                 column.default_desc.kind = columnDefaultKindFromString(kind_name);
                 String expr_str = (*default_expr)[i].get<const String &>();
                 column.default_desc.expression = parseQuery(
-                    expr_parser, expr_str.data(), expr_str.data() + expr_str.size(), "default expression", 0);
+                    expr_parser, expr_str.data(), expr_str.data() + expr_str.size(), "default expression", 0, context.getSettingsRef().max_parser_depth);
             }
 
             res.add(column);
diff --git a/src/TableFunctions/parseColumnsListForTableFunction.cpp b/src/TableFunctions/parseColumnsListForTableFunction.cpp
index 9b775b704929..c419164ac38f 100644
--- a/src/TableFunctions/parseColumnsListForTableFunction.cpp
+++ b/src/TableFunctions/parseColumnsListForTableFunction.cpp
@@ -19,9 +19,7 @@ ColumnsDescription parseColumnsListFromString(const std::string & structure, con
     Expected expected;
 
     Tokens tokens(structure.c_str(), structure.c_str() + structure.size());
-    IParser::Pos token_iterator(tokens);
-    const Settings & settings = context.getSettingsRef();
-    token_iterator.max_depth = settings.max_parser_depth;
+    IParser::Pos token_iterator(tokens, context.getSettingsRef().max_parser_depth);
 
     ParserColumnDeclarationList parser;
     ASTPtr columns_list_raw;
