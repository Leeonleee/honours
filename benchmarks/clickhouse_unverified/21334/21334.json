{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21334,
  "instance_id": "ClickHouse__ClickHouse-21334",
  "issue_numbers": [
    "13675"
  ],
  "base_commit": "ee22eeea6cf62795701d542bd548f4bfe2c4fd97",
  "patch": "diff --git a/src/Storages/MergeTree/DataPartsExchange.cpp b/src/Storages/MergeTree/DataPartsExchange.cpp\nindex f80020991b02..de7f3b6c0f4d 100644\n--- a/src/Storages/MergeTree/DataPartsExchange.cpp\n+++ b/src/Storages/MergeTree/DataPartsExchange.cpp\n@@ -363,7 +363,7 @@ MergeTreeData::MutableDataPartPtr Fetcher::downloadPartToMemory(\n     new_data_part->uuid = part_uuid;\n     new_data_part->is_temp = true;\n     new_data_part->setColumns(block.getNamesAndTypesList());\n-    new_data_part->minmax_idx.update(block, data.minmax_idx_columns);\n+    new_data_part->minmax_idx.update(block, data.getMinMaxColumnsNames(metadata_snapshot->getPartitionKey()));\n     new_data_part->partition.create(metadata_snapshot, block, 0);\n \n     MergedBlockOutputStream part_out(new_data_part, metadata_snapshot, block.getNamesAndTypesList(), {}, CompressionCodecFactory::instance().get(\"NONE\", {}));\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex 2f6513bbb12c..1568ca162542 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -57,13 +57,18 @@ static std::unique_ptr<ReadBufferFromFileBase> openForReading(const DiskPtr & di\n \n void IMergeTreeDataPart::MinMaxIndex::load(const MergeTreeData & data, const DiskPtr & disk_, const String & part_path)\n {\n-    size_t minmax_idx_size = data.minmax_idx_column_types.size();\n+    auto metadata_snapshot = data.getInMemoryMetadataPtr();\n+    const auto & partition_key = metadata_snapshot->getPartitionKey();\n+\n+    auto minmax_column_names = data.getMinMaxColumnsNames(partition_key);\n+    auto minmax_column_types = data.getMinMaxColumnsTypes(partition_key);\n+    size_t minmax_idx_size = minmax_column_types.size();\n     hyperrectangle.reserve(minmax_idx_size);\n     for (size_t i = 0; i < minmax_idx_size; ++i)\n     {\n-        String file_name = part_path + \"minmax_\" + escapeForFileName(data.minmax_idx_columns[i]) + \".idx\";\n+        String file_name = part_path + \"minmax_\" + escapeForFileName(minmax_column_names[i]) + \".idx\";\n         auto file = openForReading(disk_, file_name);\n-        const DataTypePtr & data_type = data.minmax_idx_column_types[i];\n+        const DataTypePtr & data_type = minmax_column_types[i];\n \n         Field min_val;\n         data_type->deserializeBinary(min_val, *file);\n@@ -78,7 +83,13 @@ void IMergeTreeDataPart::MinMaxIndex::load(const MergeTreeData & data, const Dis\n void IMergeTreeDataPart::MinMaxIndex::store(\n     const MergeTreeData & data, const DiskPtr & disk_, const String & part_path, Checksums & out_checksums) const\n {\n-    store(data.minmax_idx_columns, data.minmax_idx_column_types, disk_, part_path, out_checksums);\n+    auto metadata_snapshot = data.getInMemoryMetadataPtr();\n+    const auto & partition_key = metadata_snapshot->getPartitionKey();\n+\n+    auto minmax_column_names = data.getMinMaxColumnsNames(partition_key);\n+    auto minmax_column_types = data.getMinMaxColumnsTypes(partition_key);\n+\n+    store(minmax_column_names, minmax_column_types, disk_, part_path, out_checksums);\n }\n \n void IMergeTreeDataPart::MinMaxIndex::store(\n@@ -1168,6 +1179,7 @@ void IMergeTreeDataPart::checkConsistencyBase() const\n \n     auto metadata_snapshot = storage.getInMemoryMetadataPtr();\n     const auto & pk = metadata_snapshot->getPrimaryKey();\n+    const auto & partition_key = metadata_snapshot->getPartitionKey();\n     if (!checksums.empty())\n     {\n         if (!pk.column_names.empty() && !checksums.files.count(\"primary.idx\"))\n@@ -1183,7 +1195,7 @@ void IMergeTreeDataPart::checkConsistencyBase() const\n \n             if (!isEmpty())\n             {\n-                for (const String & col_name : storage.minmax_idx_columns)\n+                for (const String & col_name : storage.getMinMaxColumnsNames(partition_key))\n                 {\n                     if (!checksums.files.count(\"minmax_\" + escapeForFileName(col_name) + \".idx\"))\n                         throw Exception(\"No minmax idx file checksum for column \" + col_name, ErrorCodes::NO_FILE_IN_DATA_PART);\n@@ -1214,7 +1226,7 @@ void IMergeTreeDataPart::checkConsistencyBase() const\n             if (metadata_snapshot->hasPartitionKey())\n                 check_file_not_empty(volume->getDisk(), path + \"partition.dat\");\n \n-            for (const String & col_name : storage.minmax_idx_columns)\n+            for (const String & col_name : storage.getMinMaxColumnsNames(partition_key))\n                 check_file_not_empty(volume->getDisk(), path + \"minmax_\" + escapeForFileName(col_name) + \".idx\");\n         }\n     }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex d9e24581c0cc..277f525f4d9a 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -165,7 +165,9 @@ MergeTreeData::MergeTreeData(\n     {\n         try\n         {\n+\n             checkPartitionKeyAndInitMinMax(metadata_.partition_key);\n+            setProperties(metadata_, metadata_, attach);\n             if (minmax_idx_date_column_pos == -1)\n                 throw Exception(\"Could not find Date column\", ErrorCodes::BAD_TYPE_OF_FIELD);\n         }\n@@ -182,7 +184,6 @@ MergeTreeData::MergeTreeData(\n         checkPartitionKeyAndInitMinMax(metadata_.partition_key);\n         min_format_version = MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING;\n     }\n-\n     setProperties(metadata_, metadata_, attach);\n \n     /// NOTE: using the same columns list as is read when performing actual merges.\n@@ -422,6 +423,29 @@ ExpressionActionsPtr getCombinedIndicesExpression(\n \n }\n \n+ExpressionActionsPtr MergeTreeData::getMinMaxExpr(const KeyDescription & partition_key)\n+{\n+    NamesAndTypesList partition_key_columns;\n+    if (!partition_key.column_names.empty())\n+        partition_key_columns = partition_key.expression->getRequiredColumnsWithTypes();\n+\n+    return std::make_shared<ExpressionActions>(std::make_shared<ActionsDAG>(partition_key_columns));\n+}\n+\n+Names MergeTreeData::getMinMaxColumnsNames(const KeyDescription & partition_key)\n+{\n+    if (!partition_key.column_names.empty())\n+        return partition_key.expression->getRequiredColumns();\n+    return {};\n+}\n+\n+DataTypes MergeTreeData::getMinMaxColumnsTypes(const KeyDescription & partition_key)\n+{\n+    if (!partition_key.column_names.empty())\n+        return partition_key.expression->getRequiredColumnsWithTypes().getTypes();\n+    return {};\n+}\n+\n ExpressionActionsPtr MergeTreeData::getPrimaryKeyAndSkipIndicesExpression(const StorageMetadataPtr & metadata_snapshot) const\n {\n     return getCombinedIndicesExpression(metadata_snapshot->getPrimaryKey(), metadata_snapshot->getSecondaryIndices(), metadata_snapshot->getColumns(), global_context);\n@@ -441,19 +465,13 @@ void MergeTreeData::checkPartitionKeyAndInitMinMax(const KeyDescription & new_pa\n     checkKeyExpression(*new_partition_key.expression, new_partition_key.sample_block, \"Partition\", allow_nullable_key);\n \n     /// Add all columns used in the partition key to the min-max index.\n-    const NamesAndTypesList & minmax_idx_columns_with_types = new_partition_key.expression->getRequiredColumnsWithTypes();\n-    minmax_idx_expr = std::make_shared<ExpressionActions>(std::make_shared<ActionsDAG>(minmax_idx_columns_with_types));\n-    for (const NameAndTypePair & column : minmax_idx_columns_with_types)\n-    {\n-        minmax_idx_columns.emplace_back(column.name);\n-        minmax_idx_column_types.emplace_back(column.type);\n-    }\n+    DataTypes minmax_idx_columns_types = getMinMaxColumnsTypes(new_partition_key);\n \n     /// Try to find the date column in columns used by the partition key (a common case).\n     bool encountered_date_column = false;\n-    for (size_t i = 0; i < minmax_idx_column_types.size(); ++i)\n+    for (size_t i = 0; i < minmax_idx_columns_types.size(); ++i)\n     {\n-        if (typeid_cast<const DataTypeDate *>(minmax_idx_column_types[i].get()))\n+        if (typeid_cast<const DataTypeDate *>(minmax_idx_columns_types[i].get()))\n         {\n             if (!encountered_date_column)\n             {\n@@ -469,9 +487,9 @@ void MergeTreeData::checkPartitionKeyAndInitMinMax(const KeyDescription & new_pa\n     }\n     if (!encountered_date_column)\n     {\n-        for (size_t i = 0; i < minmax_idx_column_types.size(); ++i)\n+        for (size_t i = 0; i < minmax_idx_columns_types.size(); ++i)\n         {\n-            if (typeid_cast<const DataTypeDateTime *>(minmax_idx_column_types[i].get()))\n+            if (typeid_cast<const DataTypeDateTime *>(minmax_idx_columns_types[i].get()))\n             {\n                 if (!encountered_date_column)\n                 {\n@@ -3503,7 +3521,7 @@ bool MergeTreeData::isPrimaryOrMinMaxKeyColumnPossiblyWrappedInFunctions(\n         if (column_name == name)\n             return true;\n \n-    for (const auto & name : minmax_idx_columns)\n+    for (const auto & name : getMinMaxColumnsNames(metadata_snapshot->getPartitionKey()))\n         if (column_name == name)\n             return true;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex f03f3f1dd8c2..bfc1a5f6b6f4 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -692,12 +692,17 @@ class MergeTreeData : public IStorage\n \n     bool is_custom_partitioned = false;\n \n-    ExpressionActionsPtr minmax_idx_expr;\n-    Names minmax_idx_columns;\n-    DataTypes minmax_idx_column_types;\n+    /// Used only for old syntax tables. Never changes after init.\n     Int64 minmax_idx_date_column_pos = -1; /// In a common case minmax index includes a date column.\n     Int64 minmax_idx_time_column_pos = -1; /// In other cases, minmax index often includes a dateTime column.\n \n+    /// Get partition key expression on required columns\n+    static ExpressionActionsPtr getMinMaxExpr(const KeyDescription & partition_key);\n+    /// Get column names required for partition key\n+    static Names getMinMaxColumnsNames(const KeyDescription & partition_key);\n+    /// Get column types required for partition key\n+    static DataTypes getMinMaxColumnsTypes(const KeyDescription & partition_key);\n+\n     ExpressionActionsPtr getPrimaryKeyAndSkipIndicesExpression(const StorageMetadataPtr & metadata_snapshot) const;\n     ExpressionActionsPtr getSortingKeyAndSkipIndicesExpression(const StorageMetadataPtr & metadata_snapshot) const;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex c571a53d4c84..f2f8172837c3 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -1779,7 +1779,7 @@ void MergeTreeDataMergerMutator::mutateAllPartColumns(\n     Block block;\n     while (checkOperationIsNotCanceled(merge_entry) && (block = mutating_stream->read()))\n     {\n-        minmax_idx.update(block, data.minmax_idx_columns);\n+        minmax_idx.update(block, data.getMinMaxColumnsNames(metadata_snapshot->getPartitionKey()));\n         out.write(block);\n \n         merge_entry->rows_written += block.rows();\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex d23413f4a846..b1f3f524bebb 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -242,16 +242,21 @@ QueryPlanPtr MergeTreeDataSelectExecutor::readFromParts(\n \n     std::optional<KeyCondition> minmax_idx_condition;\n     std::optional<PartitionPruner> partition_pruner;\n-    if (data.minmax_idx_expr)\n+    DataTypes minmax_columns_types;\n+    if (metadata_snapshot->hasPartitionKey())\n     {\n-        minmax_idx_condition.emplace(query_info, context, data.minmax_idx_columns, data.minmax_idx_expr);\n+        const auto & partition_key = metadata_snapshot->getPartitionKey();\n+        auto minmax_columns_names = data.getMinMaxColumnsNames(partition_key);\n+        minmax_columns_types = data.getMinMaxColumnsTypes(partition_key);\n+\n+        minmax_idx_condition.emplace(query_info, context, minmax_columns_names, data.getMinMaxExpr(partition_key));\n         partition_pruner.emplace(metadata_snapshot->getPartitionKey(), query_info, context, false /* strict */);\n \n         if (settings.force_index_by_date && (minmax_idx_condition->alwaysUnknownOrTrue() && partition_pruner->isUseless()))\n         {\n             String msg = \"Neither MinMax index by columns (\";\n             bool first = true;\n-            for (const String & col : data.minmax_idx_columns)\n+            for (const String & col : minmax_columns_names)\n             {\n                 if (first)\n                     first = false;\n@@ -268,9 +273,9 @@ QueryPlanPtr MergeTreeDataSelectExecutor::readFromParts(\n     const Context & query_context = context.hasQueryContext() ? context.getQueryContext() : context;\n \n     if (query_context.getSettingsRef().allow_experimental_query_deduplication)\n-        selectPartsToReadWithUUIDFilter(parts, part_values, minmax_idx_condition, partition_pruner, max_block_numbers_to_read, query_context);\n+        selectPartsToReadWithUUIDFilter(parts, part_values, minmax_idx_condition, minmax_columns_types, partition_pruner, max_block_numbers_to_read, query_context);\n     else\n-        selectPartsToRead(parts, part_values, minmax_idx_condition, partition_pruner, max_block_numbers_to_read);\n+        selectPartsToRead(parts, part_values, minmax_idx_condition, minmax_columns_types, partition_pruner, max_block_numbers_to_read);\n \n \n     /// Sampling.\n@@ -1885,8 +1890,9 @@ void MergeTreeDataSelectExecutor::selectPartsToRead(\n     MergeTreeData::DataPartsVector & parts,\n     const std::unordered_set<String> & part_values,\n     const std::optional<KeyCondition> & minmax_idx_condition,\n+    const DataTypes & minmax_columns_types,\n     std::optional<PartitionPruner> & partition_pruner,\n-    const PartitionIdToMaxBlock * max_block_numbers_to_read) const\n+    const PartitionIdToMaxBlock * max_block_numbers_to_read)\n {\n     auto prev_parts = parts;\n     parts.clear();\n@@ -1900,7 +1906,7 @@ void MergeTreeDataSelectExecutor::selectPartsToRead(\n             continue;\n \n         if (minmax_idx_condition && !minmax_idx_condition->checkInHyperrectangle(\n-                part->minmax_idx.hyperrectangle, data.minmax_idx_column_types).can_be_true)\n+                part->minmax_idx.hyperrectangle, minmax_columns_types).can_be_true)\n             continue;\n \n         if (partition_pruner)\n@@ -1924,6 +1930,7 @@ void MergeTreeDataSelectExecutor::selectPartsToReadWithUUIDFilter(\n     MergeTreeData::DataPartsVector & parts,\n     const std::unordered_set<String> & part_values,\n     const std::optional<KeyCondition> & minmax_idx_condition,\n+    const DataTypes & minmax_columns_types,\n     std::optional<PartitionPruner> & partition_pruner,\n     const PartitionIdToMaxBlock * max_block_numbers_to_read,\n     const Context & query_context) const\n@@ -1950,7 +1957,7 @@ void MergeTreeDataSelectExecutor::selectPartsToReadWithUUIDFilter(\n                 continue;\n \n             if (minmax_idx_condition\n-                && !minmax_idx_condition->checkInHyperrectangle(part->minmax_idx.hyperrectangle, data.minmax_idx_column_types)\n+                && !minmax_idx_condition->checkInHyperrectangle(part->minmax_idx.hyperrectangle, minmax_columns_types)\n                         .can_be_true)\n                 continue;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\nindex 7692424dfb56..634719639ad2 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n@@ -119,18 +119,20 @@ class MergeTreeDataSelectExecutor\n \n     /// Select the parts in which there can be data that satisfy `minmax_idx_condition` and that match the condition on `_part`,\n     ///  as well as `max_block_number_to_read`.\n-    void selectPartsToRead(\n+    static void selectPartsToRead(\n         MergeTreeData::DataPartsVector & parts,\n         const std::unordered_set<String> & part_values,\n         const std::optional<KeyCondition> & minmax_idx_condition,\n+        const DataTypes & minmax_columns_types,\n         std::optional<PartitionPruner> & partition_pruner,\n-        const PartitionIdToMaxBlock * max_block_numbers_to_read) const;\n+        const PartitionIdToMaxBlock * max_block_numbers_to_read);\n \n     /// Same as previous but also skip parts uuids if any to the query context, or skip parts which uuids marked as excluded.\n     void selectPartsToReadWithUUIDFilter(\n         MergeTreeData::DataPartsVector & parts,\n         const std::unordered_set<String> & part_values,\n         const std::optional<KeyCondition> & minmax_idx_condition,\n+        const DataTypes & minmax_columns_types,\n         std::optional<PartitionPruner> & partition_pruner,\n         const PartitionIdToMaxBlock * max_block_numbers_to_read,\n         const Context & query_context) const;\ndiff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\nindex 5a9bdd90bc86..f478cdba40a3 100644\n--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n@@ -268,7 +268,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataWriter::writeTempPart(BlockWithPa\n     Int64 temp_index = data.insert_increment.get();\n \n     IMergeTreeDataPart::MinMaxIndex minmax_idx;\n-    minmax_idx.update(block, data.minmax_idx_columns);\n+    minmax_idx.update(block, data.getMinMaxColumnsNames(metadata_snapshot->getPartitionKey()));\n \n     MergeTreePartition partition(std::move(block_with_partition.partition));\n \ndiff --git a/src/Storages/MergeTree/MergeTreeWriteAheadLog.cpp b/src/Storages/MergeTree/MergeTreeWriteAheadLog.cpp\nindex 7ddc8d93b031..4ca20572e905 100644\n--- a/src/Storages/MergeTree/MergeTreeWriteAheadLog.cpp\n+++ b/src/Storages/MergeTree/MergeTreeWriteAheadLog.cpp\n@@ -191,7 +191,7 @@ MergeTreeData::MutableDataPartsVector MergeTreeWriteAheadLog::restore(const Stor\n         {\n             MergedBlockOutputStream part_out(part, metadata_snapshot, block.getNamesAndTypesList(), {}, CompressionCodecFactory::instance().get(\"NONE\", {}));\n \n-            part->minmax_idx.update(block, storage.minmax_idx_columns);\n+            part->minmax_idx.update(block, storage.getMinMaxColumnsNames(metadata_snapshot->getPartitionKey()));\n             part->partition.create(metadata_snapshot, block, 0);\n             if (metadata_snapshot->hasSortingKey())\n                 metadata_snapshot->getSortingKey().expression->execute(block);\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\nindex d06706f91097..ac1c92849d58 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp\n@@ -26,7 +26,10 @@ static String formattedAST(const ASTPtr & ast)\n ReplicatedMergeTreeTableMetadata::ReplicatedMergeTreeTableMetadata(const MergeTreeData & data, const StorageMetadataPtr & metadata_snapshot)\n {\n     if (data.format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)\n-        date_column = data.minmax_idx_columns[data.minmax_idx_date_column_pos];\n+    {\n+        auto minmax_idx_column_names = data.getMinMaxColumnsNames(metadata_snapshot->getPartitionKey());\n+        date_column = minmax_idx_column_names[data.minmax_idx_date_column_pos];\n+    }\n \n     const auto data_settings = data.getSettings();\n     sampling_expression = formattedAST(metadata_snapshot->getSamplingKeyAST());\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex fbf8a5795bf9..68f3b6d80d10 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -897,21 +897,8 @@ void StorageReplicatedMergeTree::setTableStructure(\n     StorageInMemoryMetadata old_metadata = getInMemoryMetadata();\n \n     if (new_columns != new_metadata.columns)\n-    {\n         new_metadata.columns = new_columns;\n \n-        new_metadata.column_ttls_by_name.clear();\n-        for (const auto & [name, ast] : new_metadata.columns.getColumnTTLs())\n-        {\n-            auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, new_metadata.columns, global_context, new_metadata.primary_key);\n-            new_metadata.column_ttls_by_name[name] = new_ttl_entry;\n-        }\n-\n-        /// The type of partition key expression may change\n-        if (new_metadata.partition_key.definition_ast != nullptr)\n-            new_metadata.partition_key.recalculateWithNewColumns(new_metadata.columns, global_context);\n-    }\n-\n     if (!metadata_diff.empty())\n     {\n         auto parse_key_expr = [] (const String & key_expr)\n@@ -977,6 +964,47 @@ void StorageReplicatedMergeTree::setTableStructure(\n         }\n     }\n \n+    /// Changes in columns may affect following metadata fields\n+    if (new_metadata.columns != old_metadata.columns)\n+    {\n+        new_metadata.column_ttls_by_name.clear();\n+        for (const auto & [name, ast] : new_metadata.columns.getColumnTTLs())\n+        {\n+            auto new_ttl_entry = TTLDescription::getTTLFromAST(ast, new_metadata.columns, global_context, new_metadata.primary_key);\n+            new_metadata.column_ttls_by_name[name] = new_ttl_entry;\n+        }\n+\n+        if (new_metadata.partition_key.definition_ast != nullptr)\n+            new_metadata.partition_key.recalculateWithNewColumns(new_metadata.columns, global_context);\n+\n+        if (!metadata_diff.sorting_key_changed) /// otherwise already updated\n+            new_metadata.sorting_key.recalculateWithNewColumns(new_metadata.columns, global_context);\n+\n+        /// Primary key is special, it exists even if not defined\n+        if (new_metadata.primary_key.definition_ast != nullptr)\n+        {\n+            new_metadata.primary_key.recalculateWithNewColumns(new_metadata.columns, global_context);\n+        }\n+        else\n+        {\n+            new_metadata.primary_key = KeyDescription::getKeyFromAST(new_metadata.sorting_key.definition_ast, new_metadata.columns, global_context);\n+            new_metadata.primary_key.definition_ast = nullptr;\n+        }\n+\n+        if (!metadata_diff.sampling_expression_changed && new_metadata.sampling_key.definition_ast != nullptr)\n+            new_metadata.sampling_key.recalculateWithNewColumns(new_metadata.columns, global_context);\n+\n+        if (!metadata_diff.skip_indices_changed) /// otherwise already updated\n+        {\n+            for (auto & index : new_metadata.secondary_indices)\n+                index.recalculateWithNewColumns(new_metadata.columns, global_context);\n+        }\n+\n+        if (!metadata_diff.ttl_table_changed && new_metadata.table_ttl.definition_ast != nullptr)\n+            new_metadata.table_ttl = TTLTableDescription::getTTLForTableFromAST(\n+                new_metadata.table_ttl.definition_ast, new_metadata.columns, global_context, new_metadata.primary_key);\n+    }\n+\n     /// Even if the primary/sorting/partition keys didn't change we must reinitialize it\n     /// because primary/partition key column types might have changed.\n     checkTTLExpressions(new_metadata, old_metadata);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.reference b/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.reference\nnew file mode 100644\nindex 000000000000..02359f0f98bb\n--- /dev/null\n+++ b/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.reference\n@@ -0,0 +1,6 @@\n+IU\tlada\t2101\t1970-04-19 15:00:00\n+PS\tjeep\tGrand Cherokee\t2005-10-03 15:00:00\n+PS\tjeep\tGrand Cherokee\t2005-10-03 15:00:00\n+IU\tlada\t2101\t1970-04-19 15:00:00\n+PS\tjeep\tGrand Cherokee\t2005-10-03 15:00:00\n+PS\tjeep\tGrand Cherokee\t2005-10-03 15:00:00\ndiff --git a/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.sql b/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.sql\nnew file mode 100644\nindex 000000000000..759c8ba3a0b4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.sql\n@@ -0,0 +1,63 @@\n+DROP TABLE IF EXISTS report;\n+\n+CREATE TABLE report\n+(\n+    `product` Enum8('IU' = 1, 'WS' = 2),\n+    `machine` String,\n+    `branch` String,\n+    `generated_time` DateTime\n+)\n+ENGINE = MergeTree\n+PARTITION BY (product, toYYYYMM(generated_time))\n+ORDER BY (product, machine, branch, generated_time);\n+\n+INSERT INTO report VALUES ('IU', 'lada', '2101', toDateTime('1970-04-19 15:00:00'));\n+\n+SELECT * FROM report  WHERE product = 'IU';\n+\n+ALTER TABLE report MODIFY COLUMN product Enum8('IU' = 1, 'WS' = 2, 'PS' = 3);\n+\n+SELECT * FROM report WHERE product = 'PS';\n+\n+INSERT INTO report VALUES ('PS', 'jeep', 'Grand Cherokee', toDateTime('2005-10-03 15:00:00'));\n+\n+SELECT * FROM report WHERE product = 'PS';\n+\n+DETACH TABLE report;\n+ATTACH TABLE report;\n+\n+SELECT * FROM report WHERE product = 'PS';\n+\n+DROP TABLE IF EXISTS report;\n+\n+DROP TABLE IF EXISTS replicated_report;\n+\n+CREATE TABLE replicated_report\n+(\n+    `product` Enum8('IU' = 1, 'WS' = 2),\n+    `machine` String,\n+    `branch` String,\n+    `generated_time` DateTime\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/01747_alter_partition_key/t', '1')\n+PARTITION BY (product, toYYYYMM(generated_time))\n+ORDER BY (product, machine, branch, generated_time);\n+\n+INSERT INTO replicated_report VALUES ('IU', 'lada', '2101', toDateTime('1970-04-19 15:00:00'));\n+\n+SELECT * FROM replicated_report  WHERE product = 'IU';\n+\n+ALTER TABLE replicated_report MODIFY COLUMN product Enum8('IU' = 1, 'WS' = 2, 'PS' = 3) SETTINGS replication_alter_partitions_sync=2;\n+\n+SELECT * FROM replicated_report WHERE product = 'PS';\n+\n+INSERT INTO replicated_report VALUES ('PS', 'jeep', 'Grand Cherokee', toDateTime('2005-10-03 15:00:00'));\n+\n+SELECT * FROM replicated_report WHERE product = 'PS';\n+\n+DETACH TABLE replicated_report;\n+ATTACH TABLE replicated_report;\n+\n+SELECT * FROM replicated_report WHERE product = 'PS';\n+\n+DROP TABLE IF EXISTS replicated_report;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 36cca55779dd..45d569fc131d 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -261,7 +261,8 @@\n         \"00116_storage_set\",\n         \"00083_create_merge_tree_zookeeper\",\n         \"00062_replicated_merge_tree_alter_zookeeper\",\n-        \"01720_constraints_complex_types\"\n+        \"01720_constraints_complex_types\",\n+        \"01747_alter_partition_key_enum_zookeeper\"\n     ],\n     \"polymorphic-parts\": [\n         \"01508_partition_pruning_long\", /// bug, shoud be fixed\n@@ -748,6 +749,7 @@\n         \"01676_dictget_in_default_expression\",\n         \"01700_system_zookeeper_path_in\",\n         \"01715_background_checker_blather_zookeeper\",\n+        \"01747_alter_partition_key_enum_zookeeper\",\n         \"attach\",\n         \"ddl_dictionaries\",\n         \"dictionary\",\n",
  "problem_statement": "Changes of Enum in partition key is not FULLY applied until reattach\n```\r\nCREATE TABLE report\r\n(\r\n    `product` Enum8('IU' = 1, 'WS' = 2),\r\n    `machine` String,\r\n    `branch` String,\r\n    `build_c1` String,\r\n    `build_c2` String,\r\n    `build_c3` String,\r\n    `build_time` DateTime,\r\n    `generated_time` DateTime\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY (product, toYYYYMM(generated_time))\r\nORDER BY (product, machine, branch, build_c1, build_c2, build_c3, build_time, generated_time)\r\n\r\nselect *  from report  where product = 'IU'\r\nOk.\r\n\r\nalter table report modify column product Enum8('IU' = 1, 'WS' = 2, 'PS' = 3);\r\n\r\nselect * from report where product = 'PS'\r\n\r\nDB::Exception: Key expression contains comparison between inconvertible types: \r\nEnum8('IU' = 1, 'WS' = 2) and String inside product = 'PS'\r\n\r\n\r\ndetach table report;\r\nattach table report;\r\nselect * from report where product = 'PS'\r\nOk.\r\n\r\n\r\n```\r\n\r\nrelated: https://github.com/ClickHouse/ClickHouse/issues/7513 https://github.com/ClickHouse/ClickHouse/pull/11973\n",
  "hints_text": "20.11.1.4897 relevant\nStill relevant in 21.3.",
  "created_at": "2021-03-01T10:01:01Z",
  "modified_files": [
    "src/Storages/MergeTree/DataPartsExchange.cpp",
    "src/Storages/MergeTree/IMergeTreeDataPart.cpp",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.h",
    "src/Storages/MergeTree/MergeTreeDataWriter.cpp",
    "src/Storages/MergeTree/MergeTreeWriteAheadLog.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeTableMetadata.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.reference",
    "b/tests/queries/0_stateless/01747_alter_partition_key_enum_zookeeper.sql",
    "tests/queries/skip_list.json"
  ]
}