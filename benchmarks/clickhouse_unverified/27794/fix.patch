diff --git a/src/Storages/Kafka/KafkaBlockInputStream.cpp b/src/Storages/Kafka/KafkaBlockInputStream.cpp
index 5d9b19b1972c..95fa1459e760 100644
--- a/src/Storages/Kafka/KafkaBlockInputStream.cpp
+++ b/src/Storages/Kafka/KafkaBlockInputStream.cpp
@@ -252,7 +252,11 @@ Block KafkaBlockInputStream::readImpl()
         }
         else
         {
-            LOG_WARNING(log, "Parsing of message (topic: {}, partition: {}, offset: {}) return no rows.", buffer->currentTopic(), buffer->currentPartition(), buffer->currentOffset());
+            // We came here in case of tombstone (or sometimes zero-length) messages, and it is not something abnormal
+            // TODO: it seems like in case of put_error_to_stream=true we may need to process those differently
+            // currently we just skip them with note in logs.
+            buffer->storeLastReadMessageOffset();
+            LOG_DEBUG(log, "Parsing of message (topic: {}, partition: {}, offset: {}) return no rows.", buffer->currentTopic(), buffer->currentPartition(), buffer->currentOffset());
         }
 
         if (!buffer->hasMorePolledMessages()
diff --git a/src/Storages/Kafka/ReadBufferFromKafkaConsumer.cpp b/src/Storages/Kafka/ReadBufferFromKafkaConsumer.cpp
index bd25607a5f39..86037276166e 100644
--- a/src/Storages/Kafka/ReadBufferFromKafkaConsumer.cpp
+++ b/src/Storages/Kafka/ReadBufferFromKafkaConsumer.cpp
@@ -466,13 +466,19 @@ bool ReadBufferFromKafkaConsumer::nextImpl()
     if (!allowed || !hasMorePolledMessages())
         return false;
 
-    // XXX: very fishy place with const casting.
-    auto * new_position = reinterpret_cast<char *>(const_cast<unsigned char *>(current->get_payload().get_data()));
-    BufferBase::set(new_position, current->get_payload().get_size(), 0);
-    allowed = false;
+    const auto * message_data = current->get_payload().get_data();
+    size_t message_size = current->get_payload().get_size();
 
+    allowed = false;
     ++current;
 
+    /// If message is empty, return end of stream.
+    if (message_data == nullptr)
+        return false;
+
+    /// const_cast is needed, because ReadBuffer works with non-const char *.
+    auto * new_position = reinterpret_cast<char *>(const_cast<unsigned char *>(message_data));
+    BufferBase::set(new_position, message_size, 0);
     return true;
 }
 
