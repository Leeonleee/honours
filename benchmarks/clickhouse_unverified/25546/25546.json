{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25546,
  "instance_id": "ClickHouse__ClickHouse-25546",
  "issue_numbers": [
    "8247"
  ],
  "base_commit": "8ba6a5393f664bfe83bdd441d0b700a903346fcf",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 246d00b831b8..476032e66aad 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -423,6 +423,9 @@ KeyCondition::KeyCondition(\n       */\n     Block block_with_constants = getBlockWithConstants(query_info.query, query_info.syntax_analyzer_result, context);\n \n+    for (const auto & [name, _] : query_info.syntax_analyzer_result->array_join_result_to_source)\n+        array_joined_columns.insert(name);\n+\n     const ASTSelectQuery & select = query_info.query->as<ASTSelectQuery &>();\n     if (select.where() || select.prewhere())\n     {\n@@ -610,6 +613,10 @@ bool KeyCondition::canConstantBeWrappedByMonotonicFunctions(\n     DataTypePtr & out_type)\n {\n     String expr_name = node->getColumnNameWithoutAlias();\n+\n+    if (array_joined_columns.count(expr_name))\n+        return false;\n+\n     if (key_subexpr_names.count(expr_name) == 0)\n         return false;\n \n@@ -714,6 +721,9 @@ bool KeyCondition::canConstantBeWrappedByFunctions(\n {\n     String expr_name = ast->getColumnNameWithoutAlias();\n \n+    if (array_joined_columns.count(expr_name))\n+        return false;\n+\n     if (key_subexpr_names.count(expr_name) == 0)\n     {\n         /// Let's check another one case.\n@@ -1075,6 +1085,9 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n     // Key columns should use canonical names for index analysis\n     String name = node->getColumnNameWithoutAlias();\n \n+    if (array_joined_columns.count(name))\n+        return false;\n+\n     auto it = key_columns.find(name);\n     if (key_columns.end() != it)\n     {\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex 7e7b767b53b7..c957c65fc407 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -459,6 +459,8 @@ class KeyCondition\n     const ExpressionActionsPtr key_expr;\n     /// All intermediate columns are used to calculate key_expr.\n     const NameSet key_subexpr_names;\n+\n+    NameSet array_joined_columns;\n     PreparedSets prepared_sets;\n \n     // If true, always allow key_expr to be wrapped by function\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01922_array_join_with_index.reference b/tests/queries/0_stateless/01922_array_join_with_index.reference\nnew file mode 100644\nindex 000000000000..b7539310ef31\n--- /dev/null\n+++ b/tests/queries/0_stateless/01922_array_join_with_index.reference\n@@ -0,0 +1,1 @@\n+a\tc\ndiff --git a/tests/queries/0_stateless/01922_array_join_with_index.sql b/tests/queries/0_stateless/01922_array_join_with_index.sql\nnew file mode 100644\nindex 000000000000..1444c6396928\n--- /dev/null\n+++ b/tests/queries/0_stateless/01922_array_join_with_index.sql\n@@ -0,0 +1,10 @@\n+DROP TABLE IF EXISTS t_array_index;\n+\n+CREATE TABLE t_array_index (n Nested(key String, value String))\n+ENGINE = MergeTree ORDER BY n.key;\n+\n+INSERT INTO t_array_index VALUES (['a', 'b'], ['c', 'd']);\n+\n+SELECT * FROM t_array_index ARRAY JOIN n WHERE n.key = 'a';\n+\n+DROP TABLE IF EXISTS t_array_index;\n",
  "problem_statement": "Index analysis may work incorrectly in presense of ARRAY JOIN: Key expression contains comparison between inconvertible types: Array(String) and String\nHi everyone,\r\nI used CH and caught a bug but I have no solution. \r\nHere, my create table command:\r\n\r\n``` \r\ncreate table report.db_detail\r\n(\r\n    DATE                  DateTime,\r\n    `PARENT_SEGMENT.ID`   Array(String),\r\n    `PARENT_SEGMENT.NAME` Array(String),\r\n    `PARENT_SEGMENT.KEY`  Array(String),\r\n    `SEGMENT.ID`          Array(String),\r\n    `SEGMENT.NAME`        Array(String),\r\n    `SEGMENT.KEY`         Array(String),\r\n    `PLACE.ID`            Array(String),\r\n    `PLACE.NAME`          Array(String),\r\n    `ZONE.ID`             Array(String),\r\n    `ZONE.NAME`           Array(String),\r\n    CAMPAIGN_ID           String,\r\n    CAMPAIGN_NAME         String\r\n)\r\n    engine = MergeTree() PARTITION BY toYYYYMMDD(DATE) ORDER BY (DATE, SEGMENT.KEY, PLACE.ID,\r\n                                                                 ZONE.ID,\r\n                                                                 CAMPAIGN_ID) SETTINGS index_granularity = 8192;\r\n```\r\nI can run below query => successfull\r\n``` SELECT *\r\nFROM report.daily_wifi_tracking_detail array\r\nJOIN SEGMENT\r\nWHERE SEGMENT.ID = '12'\r\nLIMIT 10 \r\n```\r\nBUT when I run the same query => Fail.\r\n``` SELECT *\r\nFROM report.daily_wifi_tracking_detail array\r\nJOIN ZONE\r\nWHERE ZONE.ID = '12'\r\nLIMIT 10\r\n```\r\nCH throw exception:\r\n` DB::Exception: Key expression contains comparison between inconvertible types: Array(String) and String inside ZONE.ID = '12' `\r\n\r\nI think I meet same issue as #6146.\r\n**My CH version:**\r\nClickHouse client version 19.6.2.1.\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 19.6.2 revision 54418.\r\n\r\nThanks so much for your help. Have a nice day!\r\n\n",
  "hints_text": "it's very unusual to put arrays into primary key.\r\n\r\n```\r\ncreate table XX (A Int64, `B.ID` Array(String), `C.ID` Array(String)) \r\nEngine=MergeTree order by (A, B.ID);\r\n\r\ninsert into XX values(1, ['1'], ['1']);\r\nselect * from XX array join C where C.ID='1'\r\n\u250c\u2500A\u2500\u252c\u2500B.ID\u2500\u2500\u252c\u2500C.ID\u2500\u2510\r\n\u2502 1 \u2502 ['1'] \u2502 1    \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect * from XX array join B where B.ID='1'\r\nDB::Exception: Key expression contains comparison between inconvertible types\r\n\r\nselect * from XX array join B where identity(B.ID)='1'\r\n\u250c\u2500A\u2500\u252c\u2500B.ID\u2500\u252c\u2500C.ID\u2500\u2500\u2510\r\n\u2502 1 \u2502 1    \u2502 ['1'] \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect *, arrayJoin(B.ID) from XX where has(B.ID,'1')\r\n\u250c\u2500A\u2500\u252c\u2500B.ID\u2500\u2500\u252c\u2500C.ID\u2500\u2500\u252c\u2500arrayJoin(B.ID)\u2500\u2510\r\n\u2502 1 \u2502 ['1'] \u2502 ['1'] \u2502 1               \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nThanks @den-crane . I tried it I successfully\n@CurtizJ Could you please look why index analysis does not respect type changes due to ARRAY JOIN?",
  "created_at": "2021-06-21T12:35:03Z",
  "modified_files": [
    "src/Storages/MergeTree/KeyCondition.cpp",
    "src/Storages/MergeTree/KeyCondition.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01922_array_join_with_index.reference",
    "b/tests/queries/0_stateless/01922_array_join_with_index.sql"
  ]
}