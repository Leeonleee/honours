diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp
index 453ed9ec37cb..eb144402b527 100644
--- a/src/Common/ProfileEvents.cpp
+++ b/src/Common/ProfileEvents.cpp
@@ -1,7 +1,6 @@
 #include <Common/ProfileEvents.h>
 #include <Common/CurrentThread.h>
-#include <Common/typeid_cast.h>
-#include <Columns/ColumnArray.h>
+
 
 /// Available events. Add something here as you wish.
 #define APPLY_FOR_EVENTS(M) \
@@ -450,7 +449,7 @@ void increment(Event event, Count amount)
 CountersIncrement::CountersIncrement(Counters::Snapshot const & snapshot)
 {
     init();
-    std::memcpy(increment_holder.get(), snapshot.counters_holder.get(), Counters::num_counters * sizeof(Increment));
+    memcpy(increment_holder.get(), snapshot.counters_holder.get(), Counters::num_counters * sizeof(Increment));
 }
 
 CountersIncrement::CountersIncrement(Counters::Snapshot const & after, Counters::Snapshot const & before)
diff --git a/src/Common/ProgressIndication.cpp b/src/Common/ProgressIndication.cpp
index 8ca1612e916f..ab4ecf5c25fb 100644
--- a/src/Common/ProgressIndication.cpp
+++ b/src/Common/ProgressIndication.cpp
@@ -8,7 +8,6 @@
 #include "Common/formatReadable.h"
 #include <Common/TerminalSize.h>
 #include <Common/UnicodeBar.h>
-#include <Common/Stopwatch.h>
 #include "IO/WriteBufferFromString.h"
 #include <Databases/DatabaseMemory.h>
 
@@ -33,6 +32,13 @@ namespace
 namespace DB
 {
 
+UInt64 ProgressIndication::getElapsedNanoseconds() const
+{
+    /// New server versions send server-side elapsed time, which is preferred for calculations.
+    UInt64 server_elapsed_ns = progress.elapsed_ns.load(std::memory_order_relaxed);
+    return server_elapsed_ns ? server_elapsed_ns : watch.elapsed();
+}
+
 bool ProgressIndication::updateProgress(const Progress & value)
 {
     return progress.incrementPiecewiseAtomically(value);
@@ -56,7 +62,7 @@ void ProgressIndication::resetProgress()
     write_progress_on_update = false;
     {
         std::lock_guard lock(profile_events_mutex);
-        cpu_usage_meter.reset(static_cast<double>(clock_gettime_ns()));
+        cpu_usage_meter.reset(getElapsedNanoseconds());
         thread_data.clear();
     }
 }
@@ -93,7 +99,7 @@ void ProgressIndication::updateThreadEventData(HostToThreadTimesMap & new_thread
         total_cpu_ns += aggregateCPUUsageNs(new_host_map.second);
         thread_data[new_host_map.first] = std::move(new_host_map.second);
     }
-    cpu_usage_meter.add(static_cast<double>(clock_gettime_ns()), total_cpu_ns);
+    cpu_usage_meter.add(getElapsedNanoseconds(), total_cpu_ns);
 }
 
 size_t ProgressIndication::getUsedThreadsCount() const
@@ -110,7 +116,7 @@ size_t ProgressIndication::getUsedThreadsCount() const
 double ProgressIndication::getCPUUsage()
 {
     std::lock_guard lock(profile_events_mutex);
-    return cpu_usage_meter.rate(clock_gettime_ns());
+    return cpu_usage_meter.rate(getElapsedNanoseconds());
 }
 
 ProgressIndication::MemoryUsage ProgressIndication::getMemoryUsage() const
@@ -139,7 +145,7 @@ void ProgressIndication::writeFinalProgress()
     std::cout << "Processed " << formatReadableQuantity(progress.read_rows) << " rows, "
                 << formatReadableSizeWithDecimalSuffix(progress.read_bytes);
 
-    size_t elapsed_ns = watch.elapsed();
+    UInt64 elapsed_ns = getElapsedNanoseconds();
     if (elapsed_ns)
         std::cout << " (" << formatReadableQuantity(progress.read_rows * 1000000000.0 / elapsed_ns) << " rows/s., "
                     << formatReadableSizeWithDecimalSuffix(progress.read_bytes * 1000000000.0 / elapsed_ns) << "/s.)";
@@ -185,7 +191,7 @@ void ProgressIndication::writeProgress()
         << formatReadableQuantity(progress.read_rows) << " rows, "
         << formatReadableSizeWithDecimalSuffix(progress.read_bytes);
 
-    auto elapsed_ns = watch.elapsed();
+    UInt64 elapsed_ns = getElapsedNanoseconds();
     if (elapsed_ns)
         message << " ("
                 << formatReadableQuantity(progress.read_rows * 1000000000.0 / elapsed_ns) << " rows/s., "
diff --git a/src/Common/ProgressIndication.h b/src/Common/ProgressIndication.h
index 588a31beca72..4f05f41b9d02 100644
--- a/src/Common/ProgressIndication.h
+++ b/src/Common/ProgressIndication.h
@@ -55,7 +55,7 @@ class ProgressIndication
     void setFileProgressCallback(ContextMutablePtr context, bool write_progress_on_update = false);
 
     /// How much seconds passed since query execution start.
-    double elapsedSeconds() const { return watch.elapsedSeconds(); }
+    double elapsedSeconds() const { return getElapsedNanoseconds() / 1e9; }
 
     void addThreadIdToList(String const & host, UInt64 thread_id);
 
@@ -74,6 +74,8 @@ class ProgressIndication
 
     MemoryUsage getMemoryUsage() const;
 
+    UInt64 getElapsedNanoseconds() const;
+
     /// This flag controls whether to show the progress bar. We start showing it after
     /// the query has been executing for 0.5 seconds, and is still less than half complete.
     bool show_progress_bar = false;
@@ -86,7 +88,7 @@ class ProgressIndication
     /// This information is stored here.
     Progress progress;
 
-    /// Track query execution time.
+    /// Track query execution time on client.
     Stopwatch watch;
 
     bool write_progress_on_update = false;
diff --git a/src/Core/ProtocolDefines.h b/src/Core/ProtocolDefines.h
index 78585492c8e1..7e6ae4f5f823 100644
--- a/src/Core/ProtocolDefines.h
+++ b/src/Core/ProtocolDefines.h
@@ -52,7 +52,7 @@
 /// NOTE: DBMS_TCP_PROTOCOL_VERSION has nothing common with VERSION_REVISION,
 /// later is just a number for server version (one number instead of commit SHA)
 /// for simplicity (sometimes it may be more convenient in some use cases).
-#define DBMS_TCP_PROTOCOL_VERSION 54459
+#define DBMS_TCP_PROTOCOL_VERSION 54460
 
 #define DBMS_MIN_PROTOCOL_VERSION_WITH_INITIAL_QUERY_START_TIME 54449
 
@@ -65,3 +65,6 @@
 #define DBMS_MIN_PROTOCOL_VERSION_WITH_QUOTA_KEY 54458
 
 #define DBMS_MIN_PROTOCOL_VERSION_WITH_PARAMETERS 54459
+
+/// The server will send query elapsed run time in the Progress packet.
+#define DBMS_MIN_PROTOCOL_VERSION_WITH_SERVER_QUERY_TIME_IN_PROGRESS 54460
diff --git a/src/IO/Progress.cpp b/src/IO/Progress.cpp
index eb6eb7fe573b..1069803633c8 100644
--- a/src/IO/Progress.cpp
+++ b/src/IO/Progress.cpp
@@ -11,38 +11,34 @@ namespace DB
 {
 void ProgressValues::read(ReadBuffer & in, UInt64 server_revision)
 {
-    size_t new_read_rows = 0;
-    size_t new_read_bytes = 0;
-    size_t new_total_rows_to_read = 0;
-    size_t new_written_rows = 0;
-    size_t new_written_bytes = 0;
-
-    readVarUInt(new_read_rows, in);
-    readVarUInt(new_read_bytes, in);
-    readVarUInt(new_total_rows_to_read, in);
+    readVarUInt(read_rows, in);
+    readVarUInt(read_bytes, in);
+    readVarUInt(total_rows_to_read, in);
     if (server_revision >= DBMS_MIN_REVISION_WITH_CLIENT_WRITE_INFO)
     {
-        readVarUInt(new_written_rows, in);
-        readVarUInt(new_written_bytes, in);
+        readVarUInt(written_rows, in);
+        readVarUInt(written_bytes, in);
+    }
+    if (server_revision >= DBMS_MIN_PROTOCOL_VERSION_WITH_SERVER_QUERY_TIME_IN_PROGRESS)
+    {
+        readVarUInt(elapsed_ns, in);
     }
-
-    this->read_rows = new_read_rows;
-    this->read_bytes = new_read_bytes;
-    this->total_rows_to_read = new_total_rows_to_read;
-    this->written_rows = new_written_rows;
-    this->written_bytes = new_written_bytes;
 }
 
 
 void ProgressValues::write(WriteBuffer & out, UInt64 client_revision) const
 {
-    writeVarUInt(this->read_rows, out);
-    writeVarUInt(this->read_bytes, out);
-    writeVarUInt(this->total_rows_to_read, out);
+    writeVarUInt(read_rows, out);
+    writeVarUInt(read_bytes, out);
+    writeVarUInt(total_rows_to_read, out);
     if (client_revision >= DBMS_MIN_REVISION_WITH_CLIENT_WRITE_INFO)
     {
-        writeVarUInt(this->written_rows, out);
-        writeVarUInt(this->written_bytes, out);
+        writeVarUInt(written_rows, out);
+        writeVarUInt(written_bytes, out);
+    }
+    if (client_revision >= DBMS_MIN_PROTOCOL_VERSION_WITH_SERVER_QUERY_TIME_IN_PROGRESS)
+    {
+        writeVarUInt(elapsed_ns, out);
     }
 }
 
@@ -52,19 +48,19 @@ void ProgressValues::writeJSON(WriteBuffer & out) const
     ///  of 64-bit integers after interpretation by JavaScript.
 
     writeCString("{\"read_rows\":\"", out);
-    writeText(this->read_rows, out);
+    writeText(read_rows, out);
     writeCString("\",\"read_bytes\":\"", out);
-    writeText(this->read_bytes, out);
+    writeText(read_bytes, out);
     writeCString("\",\"written_rows\":\"", out);
-    writeText(this->written_rows, out);
+    writeText(written_rows, out);
     writeCString("\",\"written_bytes\":\"", out);
-    writeText(this->written_bytes, out);
+    writeText(written_bytes, out);
     writeCString("\",\"total_rows_to_read\":\"", out);
-    writeText(this->total_rows_to_read, out);
+    writeText(total_rows_to_read, out);
     writeCString("\",\"result_rows\":\"", out);
-    writeText(this->result_rows, out);
+    writeText(result_rows, out);
     writeCString("\",\"result_bytes\":\"", out);
-    writeText(this->result_bytes, out);
+    writeText(result_bytes, out);
     writeCString("\"}", out);
 }
 
@@ -82,6 +78,8 @@ bool Progress::incrementPiecewiseAtomically(const Progress & rhs)
     result_rows += rhs.result_rows;
     result_bytes += rhs.result_bytes;
 
+    elapsed_ns += rhs.elapsed_ns;
+
     return rhs.read_rows || rhs.written_rows;
 }
 
@@ -98,6 +96,8 @@ void Progress::reset()
 
     result_rows = 0;
     result_bytes = 0;
+
+    elapsed_ns = 0;
 }
 
 ProgressValues Progress::getValues() const
@@ -116,6 +116,8 @@ ProgressValues Progress::getValues() const
     res.result_rows = result_rows.load(std::memory_order_relaxed);
     res.result_bytes = result_bytes.load(std::memory_order_relaxed);
 
+    res.elapsed_ns = elapsed_ns.load(std::memory_order_relaxed);
+
     return res;
 }
 
@@ -135,6 +137,8 @@ ProgressValues Progress::fetchValuesAndResetPiecewiseAtomically()
     res.result_rows = result_rows.fetch_and(0);
     res.result_bytes = result_bytes.fetch_and(0);
 
+    res.elapsed_ns = elapsed_ns.fetch_and(0);
+
     return res;
 }
 
@@ -154,6 +158,8 @@ Progress Progress::fetchAndResetPiecewiseAtomically()
     res.result_rows = result_rows.fetch_and(0);
     res.result_bytes = result_bytes.fetch_and(0);
 
+    res.elapsed_ns = elapsed_ns.fetch_and(0);
+
     return res;
 }
 
@@ -171,6 +177,8 @@ Progress & Progress::operator=(Progress && other) noexcept
     result_rows = other.result_rows.load(std::memory_order_relaxed);
     result_bytes = other.result_bytes.load(std::memory_order_relaxed);
 
+    elapsed_ns = other.elapsed_ns.load(std::memory_order_relaxed);
+
     return *this;
 }
 
@@ -185,6 +193,8 @@ void Progress::read(ReadBuffer & in, UInt64 server_revision)
 
     written_rows.store(values.written_rows, std::memory_order_relaxed);
     written_bytes.store(values.written_bytes, std::memory_order_relaxed);
+
+    elapsed_ns.store(values.elapsed_ns, std::memory_order_relaxed);
 }
 
 void Progress::write(WriteBuffer & out, UInt64 client_revision) const
diff --git a/src/IO/Progress.h b/src/IO/Progress.h
index 8340974b03dc..c21b1b854b0b 100644
--- a/src/IO/Progress.h
+++ b/src/IO/Progress.h
@@ -16,17 +16,19 @@ class WriteBuffer;
 /// See Progress.
 struct ProgressValues
 {
-    size_t read_rows;
-    size_t read_bytes;
+    UInt64 read_rows = 0;
+    UInt64 read_bytes = 0;
 
-    size_t total_rows_to_read;
-    size_t total_bytes_to_read;
+    UInt64 total_rows_to_read = 0;
+    UInt64 total_bytes_to_read = 0;
 
-    size_t written_rows;
-    size_t written_bytes;
+    UInt64 written_rows = 0;
+    UInt64 written_bytes = 0;
 
-    size_t result_rows;
-    size_t result_bytes;
+    UInt64 result_rows = 0;
+    UInt64 result_bytes = 0;
+
+    UInt64 elapsed_ns = 0;
 
     void read(ReadBuffer & in, UInt64 server_revision);
     void write(WriteBuffer & out, UInt64 client_revision) const;
@@ -35,39 +37,39 @@ struct ProgressValues
 
 struct ReadProgress
 {
-    size_t read_rows;
-    size_t read_bytes;
-    size_t total_rows_to_read;
+    UInt64 read_rows = 0;
+    UInt64 read_bytes = 0;
+    UInt64 total_rows_to_read = 0;
 
-    ReadProgress(size_t read_rows_, size_t read_bytes_, size_t total_rows_to_read_ = 0)
+    ReadProgress(UInt64 read_rows_, UInt64 read_bytes_, UInt64 total_rows_to_read_ = 0)
         : read_rows(read_rows_), read_bytes(read_bytes_), total_rows_to_read(total_rows_to_read_) {}
 };
 
 struct WriteProgress
 {
-    size_t written_rows;
-    size_t written_bytes;
+    UInt64 written_rows = 0;
+    UInt64 written_bytes = 0;
 
-    WriteProgress(size_t written_rows_, size_t written_bytes_)
+    WriteProgress(UInt64 written_rows_, UInt64 written_bytes_)
         : written_rows(written_rows_), written_bytes(written_bytes_) {}
 };
 
 struct ResultProgress
 {
-    size_t result_rows;
-    size_t result_bytes;
+    UInt64 result_rows = 0;
+    UInt64 result_bytes = 0;
 
-    ResultProgress(size_t result_rows_, size_t result_bytes_)
+    ResultProgress(UInt64 result_rows_, UInt64 result_bytes_)
         : result_rows(result_rows_), result_bytes(result_bytes_) {}
 };
 
 struct FileProgress
 {
     /// Here read_bytes (raw bytes) - do not equal ReadProgress::read_bytes, which are calculated according to column types.
-    size_t read_bytes;
-    size_t total_bytes_to_read;
+    UInt64 read_bytes = 0;
+    UInt64 total_bytes_to_read = 0;
 
-    explicit FileProgress(size_t read_bytes_, size_t total_bytes_to_read_ = 0) : read_bytes(read_bytes_), total_bytes_to_read(total_bytes_to_read_) {}
+    explicit FileProgress(UInt64 read_bytes_, UInt64 total_bytes_to_read_ = 0) : read_bytes(read_bytes_), total_bytes_to_read(total_bytes_to_read_) {}
 };
 
 
@@ -77,24 +79,26 @@ struct FileProgress
   */
 struct Progress
 {
-    std::atomic<size_t> read_rows {0};        /// Rows (source) processed.
-    std::atomic<size_t> read_bytes {0};       /// Bytes (uncompressed, source) processed.
+    std::atomic<UInt64> read_rows {0};        /// Rows (source) processed.
+    std::atomic<UInt64> read_bytes {0};       /// Bytes (uncompressed, source) processed.
 
     /** How much rows/bytes must be processed, in total, approximately. Non-zero value is sent when there is information about
       * some new part of job. Received values must be summed to get estimate of total rows to process.
       */
-    std::atomic<size_t> total_rows_to_read {0};
-    std::atomic<size_t> total_bytes_to_read {0};
+    std::atomic<UInt64> total_rows_to_read {0};
+    std::atomic<UInt64> total_bytes_to_read {0};
+
+    std::atomic<UInt64> written_rows {0};
+    std::atomic<UInt64> written_bytes {0};
 
-    std::atomic<size_t> written_rows {0};
-    std::atomic<size_t> written_bytes {0};
+    std::atomic<UInt64> result_rows {0};
+    std::atomic<UInt64> result_bytes {0};
 
-    std::atomic<size_t> result_rows {0};
-    std::atomic<size_t> result_bytes {0};
+    std::atomic<UInt64> elapsed_ns {0};
 
     Progress() = default;
 
-    Progress(size_t read_rows_, size_t read_bytes_, size_t total_rows_to_read_ = 0)
+    Progress(UInt64 read_rows_, UInt64 read_bytes_, UInt64 total_rows_to_read_ = 0)
         : read_rows(read_rows_), read_bytes(read_bytes_), total_rows_to_read(total_rows_to_read_) {}
 
     explicit Progress(ReadProgress read_progress)
diff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp
index 4c6eb1a253bb..b268179ae937 100644
--- a/src/Server/TCPHandler.cpp
+++ b/src/Server/TCPHandler.cpp
@@ -215,7 +215,6 @@ void TCPHandler::runImpl()
             break;
         }
 
-        Stopwatch watch;
         state.reset();
 
         /// Initialized later.
@@ -394,10 +393,11 @@ void TCPHandler::runImpl()
 
                 /// Send final progress
                 ///
-                /// NOTE: we cannot send Progress for regular INSERT (w/ VALUES)
+                /// NOTE: we cannot send Progress for regular INSERT (with VALUES)
                 /// without breaking protocol compatibility, but it can be done
                 /// by increasing revision.
                 sendProgress();
+                sendSelectProfileEvents();
             }
 
             state.io.onFinish();
@@ -405,8 +405,7 @@ void TCPHandler::runImpl()
             /// Do it before sending end of stream, to have a chance to show log message in client.
             query_scope->logPeakMemoryUsage();
 
-            watch.stop();
-            LOG_DEBUG(log, "Processed in {} sec.", watch.elapsedSeconds());
+            LOG_DEBUG(log, "Processed in {} sec.", state.watch.elapsedSeconds());
             query_duration_already_logged = true;
 
             if (state.is_connection_closed)
@@ -520,6 +519,11 @@ void TCPHandler::runImpl()
             LOG_WARNING(log, "Can't skip data packets after query failure.");
         }
 
+        if (!query_duration_already_logged)
+        {
+            LOG_DEBUG(log, "Processed in {} sec.", state.watch.elapsedSeconds());
+        }
+
         try
         {
             /// QueryState should be cleared before QueryScope, since otherwise
@@ -537,12 +541,6 @@ void TCPHandler::runImpl()
              */
         }
 
-        if (!query_duration_already_logged)
-        {
-            watch.stop();
-            LOG_DEBUG(log, "Processed in {} sec.", watch.elapsedSeconds());
-        }
-
         /// It is important to destroy query context here. We do not want it to live arbitrarily longer than the query.
         query_context.reset();
 
@@ -1822,6 +1820,9 @@ void TCPHandler::sendProgress()
 {
     writeVarUInt(Protocol::Server::Progress, *out);
     auto increment = state.progress.fetchValuesAndResetPiecewiseAtomically();
+    UInt64 current_elapsed_ns = state.watch.elapsedNanoseconds();
+    increment.elapsed_ns = current_elapsed_ns - state.prev_elapsed_ns;
+    state.prev_elapsed_ns = current_elapsed_ns;
     increment.write(*out, client_tcp_protocol_version);
     out->next();
 }
diff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h
index cee3cf448d69..ea5fb2f9fe03 100644
--- a/src/Server/TCPHandler.h
+++ b/src/Server/TCPHandler.h
@@ -102,6 +102,8 @@ struct QueryState
 
     /// To output progress, the difference after the previous sending of progress.
     Progress progress;
+    Stopwatch watch;
+    UInt64 prev_elapsed_ns = 0;
 
     /// Timeouts setter for current query
     std::unique_ptr<TimeoutSetter> timeout_setter;
