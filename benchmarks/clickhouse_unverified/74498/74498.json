{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 74498,
  "instance_id": "ClickHouse__ClickHouse-74498",
  "issue_numbers": [
    "74495"
  ],
  "base_commit": "3dabb67667e4061975dc4f9964cca1cc53bfc4fa",
  "patch": "diff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\nindex 689dc7a85b1e..54145f2b1bf2 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n@@ -170,7 +170,8 @@ std::optional<AggregateFunctionMatches> matchAggregateFunctions(\n             /// This is a special case for the function count().\n             /// We can assume that 'count(expr) == count()' if expr is not nullable,\n             /// which can be verified by simply casting to `AggregateFunctionCount *`.\n-            if (typeid_cast<const AggregateFunctionCount *>(aggregate.function.get()))\n+            if (typeid_cast<const AggregateFunctionCount *>(aggregate.function.get())\n+                && typeid_cast<const AggregateFunctionCount *>(candidate.function.get()))\n             {\n                 /// we can ignore arguments for count()\n                 found_match = true;\n@@ -664,6 +665,8 @@ std::optional<String> optimizeUseAggregateProjections(QueryPlan::Node & node, Qu\n                 chassert(ordinary_reading_marks == 0);\n         }\n \n+        auto logger = getLogger(\"optimizeUseAggregateProjections\");\n+\n         /// Selecting best candidate.\n         for (auto & candidate : candidates.real)\n         {\n@@ -684,10 +687,37 @@ std::optional<String> optimizeUseAggregateProjections(QueryPlan::Node & node, Qu\n                 continue;\n \n             if (candidate.sum_marks > ordinary_reading_marks)\n+            {\n+                LOG_DEBUG(\n+                    logger,\n+                    \"Projection {} is usable but it needs to read {} marks, which is no better than reading {} marks from original table\",\n+                    candidate.projection->name,\n+                    candidate.sum_marks,\n+                    ordinary_reading_marks);\n                 continue;\n+            }\n \n             if (best_candidate == nullptr || best_candidate->sum_marks > candidate.sum_marks)\n+            {\n+                LOG_DEBUG(\n+                    logger,\n+                    \"Projection {} is selected as current best candidate with {} marks to read, while original table needs to scan {} \"\n+                    \"marks\",\n+                    candidate.projection->name,\n+                    candidate.sum_marks,\n+                    ordinary_reading_marks);\n                 best_candidate = &candidate;\n+            }\n+            else\n+            {\n+                LOG_DEBUG(\n+                    logger,\n+                    \"Projection {} with {} marks is less efficient than current best candidate {} with {} marks\",\n+                    candidate.projection->name,\n+                    candidate.sum_marks,\n+                    best_candidate->projection->name,\n+                    best_candidate->sum_marks);\n+            }\n         }\n \n         if (!best_candidate)\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\nindex 2de7c7fe0552..1ef7d35518fe 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\n@@ -166,6 +166,8 @@ std::optional<String> optimizeUseNormalProjections(Stack & stack, QueryPlan::Nod\n \n     std::shared_ptr<PartitionIdToMaxBlock> max_added_blocks = getMaxAddedBlocks(reading);\n \n+    auto logger = getLogger(\"optimizeUseNormalProjections\");\n+\n     for (const auto * projection : normal_projections)\n     {\n         if (!hasAllRequiredColumns(projection, required_columns))\n@@ -188,15 +190,39 @@ std::optional<String> optimizeUseNormalProjections(Stack & stack, QueryPlan::Nod\n         if (!analyzed)\n             continue;\n \n-        if (candidate.sum_marks > ordinary_reading_marks)\n-            continue;\n-\n-        /// When force_optimize_projection are true, consider projection when equal cost.\n-        if (candidate.sum_marks == ordinary_reading_marks && !context->getSettingsRef()[Setting::force_optimize_projection])\n+        /// Only consider projection with equal cost when force_optimize_projection is true.\n+        if (candidate.sum_marks > ordinary_reading_marks\n+            || (candidate.sum_marks == ordinary_reading_marks && !context->getSettingsRef()[Setting::force_optimize_projection]))\n+        {\n+            LOG_DEBUG(\n+                logger,\n+                \"Projection {} is usable but it needs to read {} marks, which is no better than reading {} marks from original table\",\n+                candidate.projection->name,\n+                candidate.sum_marks,\n+                ordinary_reading_marks);\n             continue;\n+        }\n \n         if (best_candidate == nullptr || candidate.sum_marks < best_candidate->sum_marks)\n+        {\n+            LOG_DEBUG(\n+                logger,\n+                \"Projection {} is selected as current best candidate with {} marks to read, while original table needs to scan {} marks\",\n+                candidate.projection->name,\n+                candidate.sum_marks,\n+                ordinary_reading_marks);\n             best_candidate = &candidate;\n+        }\n+        else\n+        {\n+            LOG_DEBUG(\n+                logger,\n+                \"Projection {} with {} marks is less efficient than current best candidate {} with {} marks\",\n+                candidate.projection->name,\n+                candidate.sum_marks,\n+                best_candidate->projection->name,\n+                best_candidate->sum_marks);\n+        }\n     }\n \n     if (!best_candidate)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.reference b/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.reference\nnew file mode 100644\nindex 000000000000..0329867089c1\n--- /dev/null\n+++ b/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.reference\n@@ -0,0 +1,12 @@\n+2025-01-01 05\t1\n+2025-01-01 04\t1\n+2025-01-01 03\t1\n+2025-01-01 02\t1\n+2025-01-01 01\t1\n+2025-01-01 00\t1\n+2025-01-01 05\t1\n+2025-01-01 04\t1\n+2025-01-01 03\t1\n+2025-01-01 02\t1\n+2025-01-01 01\t1\n+2025-01-01 00\t1\ndiff --git a/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.sql b/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.sql\nnew file mode 100644\nindex 000000000000..6f71d23e1f73\n--- /dev/null\n+++ b/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.sql\n@@ -0,0 +1,76 @@\n+-- Tags: no-parallel-replicas\n+\n+DROP TABLE IF EXISTS log;\n+\n+CREATE TABLE log(\n+    collectorReceiptTime DateTime,\n+    eventId String,\n+    ruleId Nullable(String),\n+    PROJECTION ailog_rule_count (\n+    SELECT\n+        collectorReceiptTime,\n+        ruleId,\n+        count(ruleId)\n+    GROUP BY\n+        collectorReceiptTime,\n+        ruleId\n+    )\n+)\n+ENGINE = MergeTree\n+PARTITION BY toYYYYMMDD(collectorReceiptTime)\n+ORDER BY (collectorReceiptTime, eventId);\n+\n+INSERT INTO log VALUES ('2025-01-01 00:02:03', 'eventId_001', Null);\n+INSERT INTO log VALUES ('2025-01-01 01:04:05', 'eventId_002', Null);\n+INSERT INTO log VALUES ('2025-01-01 02:06:07', 'eventId_003', Null);\n+INSERT INTO log VALUES ('2025-01-01 03:08:09', 'eventId_004', Null);\n+INSERT INTO log VALUES ('2025-01-01 04:10:11', 'eventId_005', Null);\n+INSERT INTO log VALUES ('2025-01-01 05:12:13', 'eventId_006', Null);\n+\n+SELECT\n+    formatDateTime(toStartOfInterval(collectorReceiptTime, toIntervalHour(1)), '%Y-%m-%d %H') AS time,\n+    COUNT() AS count\n+FROM log\n+WHERE (collectorReceiptTime >= '2025-01-01 00:00:00') AND (collectorReceiptTime <= '2025-01-01 23:59:59')\n+GROUP BY time\n+ORDER BY time DESC;\n+\n+-- Another similar case to verify that COUNT(NOT NULL) should be able to use aggregate projection.\n+\n+DROP TABLE log;\n+\n+CREATE TABLE log(\n+    collectorReceiptTime DateTime,\n+    eventId String,\n+    ruleId String,\n+    PROJECTION ailog_rule_count (\n+    SELECT\n+        collectorReceiptTime,\n+        ruleId,\n+        count(ruleId)\n+    GROUP BY\n+        collectorReceiptTime,\n+        ruleId\n+    )\n+)\n+ENGINE = MergeTree\n+PARTITION BY toYYYYMMDD(collectorReceiptTime)\n+ORDER BY (collectorReceiptTime, eventId);\n+\n+INSERT INTO log VALUES ('2025-01-01 00:02:03', 'eventId_001', '');\n+INSERT INTO log VALUES ('2025-01-01 01:04:05', 'eventId_002', '');\n+INSERT INTO log VALUES ('2025-01-01 02:06:07', 'eventId_003', '');\n+INSERT INTO log VALUES ('2025-01-01 03:08:09', 'eventId_004', '');\n+INSERT INTO log VALUES ('2025-01-01 04:10:11', 'eventId_005', '');\n+INSERT INTO log VALUES ('2025-01-01 05:12:13', 'eventId_006', '');\n+\n+SELECT\n+    formatDateTime(toStartOfInterval(collectorReceiptTime, toIntervalHour(1)), '%Y-%m-%d %H') AS time,\n+    COUNT() AS count\n+FROM log\n+WHERE (collectorReceiptTime >= '2025-01-01 00:00:00') AND (collectorReceiptTime <= '2025-01-01 23:59:59')\n+GROUP BY time\n+ORDER BY time DESC\n+SETTINGS force_optimize_projection = 1;\n+\n+DROP TABLE log;\n",
  "problem_statement": "COUNT(nullable) function use the wrong projection\n### Company or project name\n\n_No response_\n\n### Question\n\nHi all, I\u2019m having some issues with projection: When I use `sql2` for an aggregation query, I find that it uses the wrong projection, which causes the result of count to be incorrect. I\u2019m using `count(ruleId)` in projection, which filters null values for count. In my `sql2`, I directly ran `count()`, but I found that `sql2` used this projection, which caused the result to be incorrect. Then I declare `optimize_use_projections=0;` in `sql3` it\u2019s correct.\r\nMore Detail:\r\nck version: `24.8.8.17`\r\nplayground: [https://fiddle.clickhouse.com/23cf8556-b497-499a-9d84-e7d1774c7561](https://fiddle.clickhouse.com/23cf8556-b497-499a-9d84-e7d1774c7561)\r\nsql:\r\n```\r\nCREATE TABLE log(\r\n    collectorReceiptTime DateTime, \r\n    eventId String, \r\n    ruleId Nullable(String),\r\n    PROJECTION ailog_rule_count (\r\n    SELECT\r\n        collectorReceiptTime,\r\n        ruleId,\r\n        count(ruleId)\r\n    GROUP BY\r\n        collectorReceiptTime,\r\n        ruleId\r\n    )\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toYYYYMMDD(collectorReceiptTime)\r\nORDER BY (collectorReceiptTime, eventId);\r\n\r\n\r\nINSERT INTO log VALUES ('2025-01-01 00:02:03', 'eventId_001', Null);\r\nINSERT INTO log VALUES ('2025-01-01 01:04:05', 'eventId_002', Null);\r\nINSERT INTO log VALUES ('2025-01-01 02:06:07', 'eventId_003', Null);\r\nINSERT INTO log VALUES ('2025-01-01 03:08:09', 'eventId_004', Null);\r\nINSERT INTO log VALUES ('2025-01-01 04:10:11', 'eventId_005', Null);\r\nINSERT INTO log VALUES ('2025-01-01 05:12:13', 'eventId_006', Null);\r\n\r\n\r\nSELECT 'count direct';\r\n--- mark as sql1\r\nSELECT COUNT() as count FROM log WHERE (collectorReceiptTime between '2025-01-01 00:00:00' AND '2025-01-01 23:59:59' );\r\n\r\n--- This SQL should not use the projection 'ailog_rule_count', ailog_rule_count uses count(ruleId) to filter null values, \r\n--- and the current SQL does not need to filter null values. This can lead to incorrect results.\r\nSELECT 'count group by';\r\n--- mark as sql2\r\nSELECT formatDateTime(toStartOfInterval(collectorReceiptTime, INTERVAL 1 HOUR), '%Y-%m-%d %H') AS time, COUNT() as count \r\nFROM log WHERE (collectorReceiptTime between '2025-01-01 00:00:00' AND '2025-01-01 23:59:59' ) \r\nGROUP BY time ORDER BY time DESC;\r\n\r\nSELECT 'count group by with optimize_use_projections=0;';\r\n--- mark as sql3\r\nSELECT formatDateTime(toStartOfInterval(collectorReceiptTime, INTERVAL 1 HOUR), '%Y-%m-%d %H') AS time, COUNT() as count \r\nFROM log WHERE (collectorReceiptTime between '2025-01-01 00:00:00' AND '2025-01-01 23:59:59' ) \r\nGROUP BY time ORDER BY time DESC SETTINGS optimize_use_projections=0;\r\n\r\nSELECT '';\r\nSELECT '';\r\nSELECT 'explain indexes 1';\r\nEXPLAIN indexes=1 SELECT COUNT() as count FROM log WHERE (collectorReceiptTime between '2025-01-01 00:00:00' AND '2025-01-01 23:59:59' );\r\n\r\nSELECT '';\r\nSELECT '';\r\nSELECT 'explain indexes 2';\r\nEXPLAIN indexes=1 SELECT formatDateTime(toStartOfInterval(collectorReceiptTime, INTERVAL 1 HOUR), '%Y-%m-%d %H') AS time, COUNT() as count \r\nFROM log WHERE (collectorReceiptTime between '2025-01-01 00:00:00' AND '2025-01-01 23:59:59' ) \r\nGROUP BY time ORDER BY time DESC;\r\n\r\nSELECT '';\r\nSELECT '';\r\nSELECT 'explain indexes 3';\r\nEXPLAIN indexes=1 SELECT formatDateTime(toStartOfInterval(collectorReceiptTime, INTERVAL 1 HOUR), '%Y-%m-%d %H') AS time, COUNT() as count \r\nFROM log WHERE (collectorReceiptTime between '2025-01-01 00:00:00' AND '2025-01-01 23:59:59' ) \r\nGROUP BY time ORDER BY time DESC SETTINGS optimize_use_projections=0;\r\n```\r\n![image](https://github.com/user-attachments/assets/a2ae3f73-a5dc-49a5-aa83-0ec8e562ac7f)\n",
  "hints_text": "",
  "created_at": "2025-01-13T03:47:31Z",
  "modified_files": [
    "src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp",
    "src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.reference",
    "b/tests/queries/0_stateless/03310_aggregate_projection_count_nullable.sql"
  ]
}