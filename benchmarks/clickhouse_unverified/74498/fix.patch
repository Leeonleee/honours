diff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp
index 689dc7a85b1e..54145f2b1bf2 100644
--- a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp
+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp
@@ -170,7 +170,8 @@ std::optional<AggregateFunctionMatches> matchAggregateFunctions(
             /// This is a special case for the function count().
             /// We can assume that 'count(expr) == count()' if expr is not nullable,
             /// which can be verified by simply casting to `AggregateFunctionCount *`.
-            if (typeid_cast<const AggregateFunctionCount *>(aggregate.function.get()))
+            if (typeid_cast<const AggregateFunctionCount *>(aggregate.function.get())
+                && typeid_cast<const AggregateFunctionCount *>(candidate.function.get()))
             {
                 /// we can ignore arguments for count()
                 found_match = true;
@@ -664,6 +665,8 @@ std::optional<String> optimizeUseAggregateProjections(QueryPlan::Node & node, Qu
                 chassert(ordinary_reading_marks == 0);
         }
 
+        auto logger = getLogger("optimizeUseAggregateProjections");
+
         /// Selecting best candidate.
         for (auto & candidate : candidates.real)
         {
@@ -684,10 +687,37 @@ std::optional<String> optimizeUseAggregateProjections(QueryPlan::Node & node, Qu
                 continue;
 
             if (candidate.sum_marks > ordinary_reading_marks)
+            {
+                LOG_DEBUG(
+                    logger,
+                    "Projection {} is usable but it needs to read {} marks, which is no better than reading {} marks from original table",
+                    candidate.projection->name,
+                    candidate.sum_marks,
+                    ordinary_reading_marks);
                 continue;
+            }
 
             if (best_candidate == nullptr || best_candidate->sum_marks > candidate.sum_marks)
+            {
+                LOG_DEBUG(
+                    logger,
+                    "Projection {} is selected as current best candidate with {} marks to read, while original table needs to scan {} "
+                    "marks",
+                    candidate.projection->name,
+                    candidate.sum_marks,
+                    ordinary_reading_marks);
                 best_candidate = &candidate;
+            }
+            else
+            {
+                LOG_DEBUG(
+                    logger,
+                    "Projection {} with {} marks is less efficient than current best candidate {} with {} marks",
+                    candidate.projection->name,
+                    candidate.sum_marks,
+                    best_candidate->projection->name,
+                    best_candidate->sum_marks);
+            }
         }
 
         if (!best_candidate)
diff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp
index 2de7c7fe0552..1ef7d35518fe 100644
--- a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp
+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp
@@ -166,6 +166,8 @@ std::optional<String> optimizeUseNormalProjections(Stack & stack, QueryPlan::Nod
 
     std::shared_ptr<PartitionIdToMaxBlock> max_added_blocks = getMaxAddedBlocks(reading);
 
+    auto logger = getLogger("optimizeUseNormalProjections");
+
     for (const auto * projection : normal_projections)
     {
         if (!hasAllRequiredColumns(projection, required_columns))
@@ -188,15 +190,39 @@ std::optional<String> optimizeUseNormalProjections(Stack & stack, QueryPlan::Nod
         if (!analyzed)
             continue;
 
-        if (candidate.sum_marks > ordinary_reading_marks)
-            continue;
-
-        /// When force_optimize_projection are true, consider projection when equal cost.
-        if (candidate.sum_marks == ordinary_reading_marks && !context->getSettingsRef()[Setting::force_optimize_projection])
+        /// Only consider projection with equal cost when force_optimize_projection is true.
+        if (candidate.sum_marks > ordinary_reading_marks
+            || (candidate.sum_marks == ordinary_reading_marks && !context->getSettingsRef()[Setting::force_optimize_projection]))
+        {
+            LOG_DEBUG(
+                logger,
+                "Projection {} is usable but it needs to read {} marks, which is no better than reading {} marks from original table",
+                candidate.projection->name,
+                candidate.sum_marks,
+                ordinary_reading_marks);
             continue;
+        }
 
         if (best_candidate == nullptr || candidate.sum_marks < best_candidate->sum_marks)
+        {
+            LOG_DEBUG(
+                logger,
+                "Projection {} is selected as current best candidate with {} marks to read, while original table needs to scan {} marks",
+                candidate.projection->name,
+                candidate.sum_marks,
+                ordinary_reading_marks);
             best_candidate = &candidate;
+        }
+        else
+        {
+            LOG_DEBUG(
+                logger,
+                "Projection {} with {} marks is less efficient than current best candidate {} with {} marks",
+                candidate.projection->name,
+                candidate.sum_marks,
+                best_candidate->projection->name,
+                best_candidate->sum_marks);
+        }
     }
 
     if (!best_candidate)
