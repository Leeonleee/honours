{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13679,
  "instance_id": "ClickHouse__ClickHouse-13679",
  "issue_numbers": [
    "13424"
  ],
  "base_commit": "e95da509bb9135eb82bcb5607f319f8cb58ff610",
  "patch": "diff --git a/src/Interpreters/JoinedTables.cpp b/src/Interpreters/JoinedTables.cpp\nindex 127df9b5eacb..d38a3fa68dc4 100644\n--- a/src/Interpreters/JoinedTables.cpp\n+++ b/src/Interpreters/JoinedTables.cpp\n@@ -28,6 +28,7 @@ namespace ErrorCodes\n {\n     extern const int ALIAS_REQUIRED;\n     extern const int AMBIGUOUS_COLUMN_NAME;\n+    extern const int LOGICAL_ERROR;\n }\n \n namespace\n@@ -187,7 +188,8 @@ StoragePtr JoinedTables::getLeftTableStorage()\n bool JoinedTables::resolveTables()\n {\n     tables_with_columns = getDatabaseAndTablesWithColumns(table_expressions, context);\n-    assert(tables_with_columns.size() == table_expressions.size());\n+    if (tables_with_columns.size() != table_expressions.size())\n+        throw Exception(\"Unexpected tables count\", ErrorCodes::LOGICAL_ERROR);\n \n     const auto & settings = context.getSettingsRef();\n     if (settings.joined_subquery_requires_alias && tables_with_columns.size() > 1)\ndiff --git a/src/Interpreters/PredicateExpressionsOptimizer.cpp b/src/Interpreters/PredicateExpressionsOptimizer.cpp\nindex 3915a0f7f430..86bdec628cd2 100644\n--- a/src/Interpreters/PredicateExpressionsOptimizer.cpp\n+++ b/src/Interpreters/PredicateExpressionsOptimizer.cpp\n@@ -15,6 +15,7 @@ namespace DB\n \n namespace ErrorCodes\n {\n+    extern const int LOGICAL_ERROR;\n }\n \n PredicateExpressionsOptimizer::PredicateExpressionsOptimizer(\n@@ -111,6 +112,10 @@ bool PredicateExpressionsOptimizer::tryRewritePredicatesToTables(ASTs & tables_e\n {\n     bool is_rewrite_tables = false;\n \n+    if (tables_element.size() != tables_predicates.size())\n+        throw Exception(\"Unexpected elements count in predicate push down: `set enable_optimize_predicate_expression = 0` to disable\",\n+                        ErrorCodes::LOGICAL_ERROR);\n+\n     for (size_t index = tables_element.size(); index > 0; --index)\n     {\n         size_t table_pos = index - 1;\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex c98589695799..454d95490e8f 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -38,6 +38,27 @@ namespace ErrorCodes\n     extern const int SAMPLING_NOT_SUPPORTED;\n }\n \n+namespace\n+{\n+\n+/// Rewrite original query removing joined tables from it\n+void removeJoin(const ASTSelectQuery & select)\n+{\n+    const auto & tables = select.tables();\n+    if (!tables || tables->children.size() < 2)\n+        return;\n+\n+    const auto & joined_table = tables->children[1]->as<ASTTablesInSelectQueryElement &>();\n+    if (!joined_table.table_join)\n+        return;\n+\n+    /// The most simple temporary solution: leave only the first table in query.\n+    /// TODO: we also need to remove joined columns and related functions (taking in account aliases if any).\n+    tables->children.resize(1);\n+}\n+\n+}\n+\n \n StorageMerge::StorageMerge(\n     const StorageID & table_id_,\n@@ -243,6 +264,9 @@ Pipes StorageMerge::createSources(\n     SelectQueryInfo modified_query_info = query_info;\n     modified_query_info.query = query_info.query->clone();\n \n+    /// Original query could contain JOIN but we need only the first joined table and its columns.\n+    removeJoin(*modified_query_info.query->as<ASTSelectQuery>());\n+\n     VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, \"_table\", table_name);\n \n     Pipes pipes;\n@@ -436,9 +460,14 @@ Block StorageMerge::getQueryHeader(\n         }\n         case QueryProcessingStage::WithMergeableState:\n         case QueryProcessingStage::Complete:\n-            return InterpreterSelectQuery(\n-                query_info.query, context, std::make_shared<OneBlockInputStream>(metadata_snapshot->getSampleBlockForColumns(column_names, getVirtuals(), getStorageID())),\n-                SelectQueryOptions(processed_stage).analyze()).getSampleBlock();\n+        {\n+            auto query = query_info.query->clone();\n+            removeJoin(*query->as<ASTSelectQuery>());\n+\n+            auto stream = std::make_shared<OneBlockInputStream>(\n+                metadata_snapshot->getSampleBlockForColumns(column_names, getVirtuals(), getStorageID()));\n+            return InterpreterSelectQuery(query, context, stream, SelectQueryOptions(processed_stage).analyze()).getSampleBlock();\n+        }\n     }\n     throw Exception(\"Logical Error: unknown processed stage.\", ErrorCodes::LOGICAL_ERROR);\n }\ndiff --git a/src/Storages/VirtualColumnUtils.h b/src/Storages/VirtualColumnUtils.h\nindex e1c7e400249c..89b69eb79e3c 100644\n--- a/src/Storages/VirtualColumnUtils.h\n+++ b/src/Storages/VirtualColumnUtils.h\n@@ -26,7 +26,6 @@ void rewriteEntityInAst(ASTPtr ast, const String & column_name, const Field & va\n \n /// Leave in the block only the rows that fit under the WHERE clause and the PREWHERE clause of the query.\n /// Only elements of the outer conjunction are considered, depending only on the columns present in the block.\n-/// Returns true if at least one row is discarded.\n void filterBlockWithQuery(const ASTPtr & query, Block & block, const Context & context);\n \n /// Extract from the input stream a set of `name` column values\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.reference b/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.reference\nnew file mode 100644\nindex 000000000000..aa47d0d46d47\n--- /dev/null\n+++ b/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.reference\n@@ -0,0 +1,2 @@\n+0\n+0\ndiff --git a/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.sql b/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.sql\nnew file mode 100644\nindex 000000000000..a3c598c6d837\n--- /dev/null\n+++ b/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.sql\n@@ -0,0 +1,30 @@\n+DROP TABLE IF EXISTS test1;\n+DROP TABLE IF EXISTS test1_distributed;\n+DROP TABLE IF EXISTS test_merge;\n+\n+SET enable_optimize_predicate_expression = 1;\n+\n+CREATE TABLE test1 (id Int64, name String) ENGINE MergeTree PARTITION BY (id) ORDER BY (id);\n+CREATE TABLE test1_distributed AS test1 ENGINE = Distributed(test_cluster_two_shards_localhost, default, test1);\n+CREATE TABLE test_merge AS test1 ENGINE = Merge('default', 'test1_distributed');\n+\n+SELECT count() FROM test_merge\n+JOIN (SELECT 'anystring' AS name) AS n\n+USING name\n+WHERE id = 1;\n+\n+DROP TABLE test1;\n+DROP TABLE test_merge;\n+\n+\n+CREATE TABLE test1 (id Int64, name String) ENGINE MergeTree PARTITION BY (id) ORDER BY (id);\n+CREATE TABLE test_merge AS test1 ENGINE = Merge('default', 'test1');\n+\n+SELECT count() FROM test_merge\n+JOIN (SELECT 'anystring' AS name) AS n\n+USING name\n+WHERE id = 1;\n+\n+DROP TABLE test1;\n+DROP TABLE test_merge;\n+DROP TABLE test1_distributed;\n",
  "problem_statement": "Server crash on Merge-table join & filter condition\nIn (Merge -> Distributed -> MergeTree) tables structure server **crashes** on SELECT query when:\r\n1. Merge table is queried\r\n2. There is a filtration condition \r\n3. There is JOIN on some other table (no matter what)\r\n\r\n**How to reproduce**\r\nPrerequisites: CH with 'clstr1' cluster created (I tested on 2 nodes cluster in docker)\r\n```\r\nCREATE TABLE  default.test1 ON CLUSTER clstr1\r\n(  id   Int64,  name String ) \r\nENGINE MergeTree PARTITION BY (id) ORDER BY (id);\r\n\r\nCREATE TABLE  default.test1_distributed ON CLUSTER clstr1 \r\nAS default.test1 \r\nENGINE = Distributed(clstr1, default, test1);\r\n\r\nCREATE TABLE default.test_merge ON CLUSTER clstr1\r\nAS default.test1\r\nENGINE = Merge('default', 'test1_distributed');\r\n```\r\n\r\nSo with this structure following SELECT query crashes CH server (node which received query):\r\n```\r\nselect count()\r\n    from default.test_merge\r\n         join ( select 'anystring' as name) as n USING name\r\n    WHERE id = 1\r\n```\r\n\r\n**Note** that if you remove either filter condition or join clause query works fine:\r\n```\r\nselect count()\r\n    from default.test_merge\r\n         join ( select 'anystring' as name) as n USING name;\r\n\r\nselect count()\r\n    from default.test_merge\r\n    WHERE id = 1;\r\n\r\nselect count()\r\n  from default.test_merge\r\n     WHERE id = 1 and name in ( select 'anystring' as name);\r\n\r\n```\r\nIssue happens only when both filtration & join applied.\r\n\r\n**Note2:** Sometimes issue raise only on the second query execution. \r\n\r\n\r\n**Logs before crash**\r\n```\r\n2020.08.06 18:03:42.923308 [ 66 ] {a0e71bd3-67ec-46d2-9a2f-a72bf53e109c} <Debug> executeQuery: (from 192.168.160.1:46103) SELECT count() FROM default.test_merge INNER JOIN (SELECT 'anystring' AS name) AS n USING (name) WHERE id = 1\r\n2020.08.06 18:03:42.923565 [ 66 ] {a0e71bd3-67ec-46d2-9a2f-a72bf53e109c} <Trace> AccessRightsContext (default): Access granted: SELECT(dummy) ON system.one\r\n2020.08.06 18:03:42.923823 [ 66 ] {a0e71bd3-67ec-46d2-9a2f-a72bf53e109c} <Trace> AccessRightsContext (default): Access granted: SELECT(dummy) ON system.one\r\n2020.08.06 18:03:42.923857 [ 66 ] {a0e71bd3-67ec-46d2-9a2f-a72bf53e109c} <Debug> Join: setSampleBlock: n.name String Const(size = 0, String(size = 1))\r\n2020.08.06 18:03:42.924451 [ 101 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.08.06 18:03:42.924489 [ 101 ] {} <Fatal> BaseDaemon: (version 20.3.12.112 (official build)) (from thread 66) (query_id: a0e71bd3-67ec-46d2-9a2f-a72bf53e109c) Received signal Segmentation fault (11).\r\n2020.08.06 18:03:42.924516 [ 101 ] {} <Fatal> BaseDaemon: Address: NULL pointer. Access: read. Address not mapped to object.\r\n2020.08.06 18:03:42.924534 [ 101 ] {} <Fatal> BaseDaemon: Stack trace: 0xd4fd8c1 0xd500a1d 0xd4faa20 0xd4faa69 0xd4faa69 0xd4f87a1 0xd4fa09e 0xd4cdb14 0xd123ea5 0xd12521e 0xd1268bd 0xd6f2c65 0xd6f48fb 0xd15ce70 0xd160647 0xd122975 0xd3276b8 0xd539eba 0xd53a991 0x90327b9 0x90337a0 0xe390dfb 0xe39127d 0x105a7d47 0x105a3b4c 0x105a54ed 0x7f109626a6db 0x7f1096b4988f\r\n2020.08.06 18:03:42.963483 [ 101 ] {} <Fatal> BaseDaemon: 3. DB::PredicateRewriteVisitorData::rewriteSubquery(DB::ASTSelectQuery&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0xd4fd8c1 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963513 [ 101 ] {} <Fatal> BaseDaemon: 4. DB::PredicateRewriteVisitorData::visit(DB::ASTSelectWithUnionQuery&, std::__1::shared_ptr<DB::IAST>&) @ 0xd500a1d in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963535 [ 101 ] {} <Fatal> BaseDaemon: 5. DB::InDepthNodeVisitor<DB::OneTypeMatcher<DB::PredicateRewriteVisitorData, false, std::__1::shared_ptr<DB::IAST> >, true, std::__1::shared_ptr<DB::IAST> >::visit(std::__1::shared_ptr<DB::IAST>&) @ 0xd4faa20 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963552 [ 101 ] {} <Fatal> BaseDaemon: 6. DB::InDepthNodeVisitor<DB::OneTypeMatcher<DB::PredicateRewriteVisitorData, false, std::__1::shared_ptr<DB::IAST> >, true, std::__1::shared_ptr<DB::IAST> >::visit(std::__1::shared_ptr<DB::IAST>&) @ 0xd4faa69 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963570 [ 101 ] {} <Fatal> BaseDaemon: 7. DB::InDepthNodeVisitor<DB::OneTypeMatcher<DB::PredicateRewriteVisitorData, false, std::__1::shared_ptr<DB::IAST> >, true, std::__1::shared_ptr<DB::IAST> >::visit(std::__1::shared_ptr<DB::IAST>&) @ 0xd4faa69 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963594 [ 101 ] {} <Fatal> BaseDaemon: 8. DB::PredicateExpressionsOptimizer::tryRewritePredicatesToTables(std::__1::vector<std::__1::shared_ptr<DB::IAST>, std::__1::allocator<std::__1::shared_ptr<DB::IAST> > >&, std::__1::vector<std::__1::vector<std::__1::shared_ptr<DB::IAST>, std::__1::allocator<std::__1::shared_ptr<DB::IAST> > >, std::__1::allocator<std::__1::vector<std::__1::shared_ptr<DB::IAST>, std::__1::allocator<std::__1::shared_ptr<DB::IAST> > > > > const&) @ 0xd4f87a1 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963605 [ 101 ] {} <Fatal> BaseDaemon: 9. DB::PredicateExpressionsOptimizer::optimize(DB::ASTSelectQuery&) @ 0xd4fa09e in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963627 [ 101 ] {} <Fatal> BaseDaemon: 10. DB::SyntaxAnalyzer::analyzeSelect(std::__1::shared_ptr<DB::IAST>&, DB::SyntaxAnalyzerResult&&, DB::SelectQueryOptions const&, std::__1::vector<DB::TableWithColumnNamesAndTypes, std::__1::allocator<DB::TableWithColumnNamesAndTypes> > const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) const @ 0xd4cdb14 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963641 [ 101 ] {} <Fatal> BaseDaemon: 11. ? @ 0xd123ea5 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963656 [ 101 ] {} <Fatal> BaseDaemon: 12. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0xd12521e in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963666 [ 101 ] {} <Fatal> BaseDaemon: 13. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::shared_ptr<DB::IBlockInputStream> const&, DB::SelectQueryOptions const&) @ 0xd1268bd in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963687 [ 101 ] {} <Fatal> BaseDaemon: 14. DB::StorageMerge::getQueryHeader(std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::SelectQueryInfo const&, DB::Context const&, DB::QueryProcessingStage::Enum) @ 0xd6f2c65 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963706 [ 101 ] {} <Fatal> BaseDaemon: 15. DB::StorageMerge::read(std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::SelectQueryInfo const&, DB::Context const&, DB::QueryProcessingStage::Enum, unsigned long, unsigned int) @ 0xd6f48fb in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963719 [ 101 ] {} <Fatal> BaseDaemon: 16. void DB::InterpreterSelectQuery::executeFetchColumns<DB::QueryPipeline>(DB::QueryProcessingStage::Enum, DB::QueryPipeline&, std::__1::shared_ptr<DB::PrewhereInfo> const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::QueryPipeline&) @ 0xd15ce70 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963737 [ 101 ] {} <Fatal> BaseDaemon: 17. void DB::InterpreterSelectQuery::executeImpl<DB::QueryPipeline>(DB::QueryPipeline&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>, DB::QueryPipeline&) @ 0xd160647 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963746 [ 101 ] {} <Fatal> BaseDaemon: 18. DB::InterpreterSelectQuery::executeWithProcessors() @ 0xd122975 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963761 [ 101 ] {} <Fatal> BaseDaemon: 19. DB::InterpreterSelectWithUnionQuery::executeWithProcessors() @ 0xd3276b8 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963777 [ 101 ] {} <Fatal> BaseDaemon: 20. ? @ 0xd539eba in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963790 [ 101 ] {} <Fatal> BaseDaemon: 21. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, bool) @ 0xd53a991 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963804 [ 101 ] {} <Fatal> BaseDaemon: 22. DB::TCPHandler::runImpl() @ 0x90327b9 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963813 [ 101 ] {} <Fatal> BaseDaemon: 23. DB::TCPHandler::run() @ 0x90337a0 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963823 [ 101 ] {} <Fatal> BaseDaemon: 24. Poco::Net::TCPServerConnection::start() @ 0xe390dfb in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963840 [ 101 ] {} <Fatal> BaseDaemon: 25. Poco::Net::TCPServerDispatcher::run() @ 0xe39127d in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963864 [ 101 ] {} <Fatal> BaseDaemon: 26. Poco::PooledThread::run() @ 0x105a7d47 in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963880 [ 101 ] {} <Fatal> BaseDaemon: 27. Poco::ThreadImpl::runnableEntry(void*) @ 0x105a3b4c in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963894 [ 101 ] {} <Fatal> BaseDaemon: 28. ? @ 0x105a54ed in /usr/bin/clickhouse\r\n2020.08.06 18:03:42.963905 [ 101 ] {} <Fatal> BaseDaemon: 29. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2020.08.06 18:03:42.963916 [ 101 ] {} <Fatal> BaseDaemon: 30. clone @ 0x12188f in /lib/x86_64-linux-gnu/libc-2.27.so\r\n\r\n```\r\n\r\n------\r\n\r\n**Reproduced on**:\r\n- 20.5.4.40-stable\r\n- 20.3.12.112-lts\r\n- 20.3.11.97-lts\r\n\r\nVersion 19.17.10.1 works fine.\r\n\r\nWill be happy to provide additional details if necessary!\r\n\r\n\n",
  "hints_text": "I also have the same problem .But the SQL is different.\nAccording to the stacktrace there should be a workaround: `set enable_optimize_predicate_expression=0`.",
  "created_at": "2020-08-13T17:36:29Z",
  "modified_files": [
    "src/Interpreters/JoinedTables.cpp",
    "src/Interpreters/PredicateExpressionsOptimizer.cpp",
    "src/Storages/StorageMerge.cpp",
    "src/Storages/VirtualColumnUtils.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.reference",
    "b/tests/queries/0_stateless/01436_storage_merge_with_join_push_down.sql"
  ]
}