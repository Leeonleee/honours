diff --git a/src/Processors/Formats/Impl/AvroRowInputFormat.cpp b/src/Processors/Formats/Impl/AvroRowInputFormat.cpp
index 52ceaf063b72..567f94d19fec 100644
--- a/src/Processors/Formats/Impl/AvroRowInputFormat.cpp
+++ b/src/Processors/Formats/Impl/AvroRowInputFormat.cpp
@@ -102,10 +102,6 @@ class InputStreamReadBufferAdapter : public avro::InputStream
     ReadBuffer & in;
 };
 
-static void deserializeNoop(IColumn &, avro::Decoder &)
-{
-}
-
 /// Insert value with conversion to the column of target type.
 template <typename T>
 static void insertNumber(IColumn & column, WhichDataType type, T value)
@@ -441,8 +437,43 @@ AvroDeserializer::SkipFn AvroDeserializer::createSkipFn(avro::NodePtr root_node)
     }
 }
 
+void AvroDeserializer::createActions(const Block & header, const avro::NodePtr& node, std::string current_path)
+{
+    if (node->type() == avro::AVRO_RECORD)
+    {
+        for (size_t i = 0; i < node->leaves(); ++i)
+        {
+            const auto & field_node = node->leafAt(i);
+            const auto & field_name = node->nameAt(i);
+            auto field_path = current_path.empty() ? field_name : current_path + "." + field_name;
+            createActions(header, field_node, field_path);
+        }
+    }
+    else
+    {
+        if (header.has(current_path))
+        {
+            auto target_column_idx = header.getPositionByName(current_path);
+            const auto & column = header.getByPosition(target_column_idx);
+            try
+            {
+                actions.emplace_back(target_column_idx, createDeserializeFn(node, column.type));
+            }
+            catch (Exception & e)
+            {
+                e.addMessage("column " + column.name);
+                throw;
+            }
+            column_found[target_column_idx] = true;
+        }
+        else
+        {
+            actions.emplace_back(createSkipFn(node));
+        }
+    }
+}
 
-AvroDeserializer::AvroDeserializer(const ColumnsWithTypeAndName & columns, avro::ValidSchema schema)
+AvroDeserializer::AvroDeserializer(const Block & header, avro::ValidSchema schema)
 {
     const auto & schema_root = schema.root();
     if (schema_root->type() != avro::AVRO_RECORD)
@@ -450,48 +481,23 @@ AvroDeserializer::AvroDeserializer(const ColumnsWithTypeAndName & columns, avro:
         throw Exception("Root schema must be a record", ErrorCodes::TYPE_MISMATCH);
     }
 
-    field_mapping.resize(schema_root->leaves(), -1);
-
-    for (size_t i = 0; i < schema_root->leaves(); ++i)
-    {
-        skip_fns.push_back(createSkipFn(schema_root->leafAt(i)));
-        deserialize_fns.push_back(&deserializeNoop);
-    }
+    column_found.resize(header.columns());
+    createActions(header, schema_root);
 
-    for (size_t i = 0; i < columns.size(); ++i)
+    for (size_t i = 0; i < header.columns(); ++i)
     {
-        const auto & column = columns[i];
-        size_t field_index = 0;
-        if (!schema_root->nameIndex(column.name, field_index))
+        if (!column_found[i])
         {
-            throw Exception("Field " + column.name + " not found in Avro schema", ErrorCodes::THERE_IS_NO_COLUMN);
+            throw Exception("Field " + header.getByPosition(i).name + " not found in Avro schema", ErrorCodes::THERE_IS_NO_COLUMN);
         }
-        auto field_schema = schema_root->leafAt(field_index);
-        try
-        {
-            deserialize_fns[field_index] = createDeserializeFn(field_schema, column.type);
-        }
-        catch (Exception & e)
-        {
-            e.addMessage("column " + column.name);
-            throw;
-        }
-        field_mapping[field_index] = i;
     }
 }
 
 void AvroDeserializer::deserializeRow(MutableColumns & columns, avro::Decoder & decoder) const
 {
-    for (size_t i = 0; i < field_mapping.size(); i++)
+    for (const auto& action : actions)
     {
-        if (field_mapping[i] >= 0)
-        {
-            deserialize_fns[i](*columns[field_mapping[i]], decoder);
-        }
-        else
-        {
-            skip_fns[i](decoder);
-        }
+        action.execute(columns, decoder);
     }
 }
 
@@ -499,7 +505,7 @@ void AvroDeserializer::deserializeRow(MutableColumns & columns, avro::Decoder &
 AvroRowInputFormat::AvroRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_)
     : IRowInputFormat(header_, in_, params_)
     , file_reader(std::make_unique<InputStreamReadBufferAdapter>(in_))
-    , deserializer(header_.getColumnsWithTypeAndName(), file_reader.dataSchema())
+    , deserializer(output.getHeader(), file_reader.dataSchema())
 {
     file_reader.init();
 }
@@ -626,8 +632,7 @@ static uint32_t readConfluentSchemaId(ReadBuffer & in)
 
 AvroConfluentRowInputFormat::AvroConfluentRowInputFormat(
     const Block & header_, ReadBuffer & in_, Params params_, const FormatSettings & format_settings_)
-    : IRowInputFormat(header_.cloneEmpty(), in_, params_)
-    , header_columns(header_.getColumnsWithTypeAndName())
+    : IRowInputFormat(header_, in_, params_)
     , schema_registry(getConfluentSchemaRegistry(format_settings_))
     , input_stream(std::make_unique<InputStreamReadBufferAdapter>(in))
     , decoder(avro::binaryDecoder())
@@ -655,7 +660,7 @@ const AvroDeserializer & AvroConfluentRowInputFormat::getOrCreateDeserializer(Sc
     if (it == deserializer_cache.end())
     {
         auto schema = schema_registry->getSchema(schema_id);
-        AvroDeserializer deserializer(header_columns, schema);
+        AvroDeserializer deserializer(output.getHeader(), schema);
         it = deserializer_cache.emplace(schema_id, deserializer).first;
     }
     return it->second;
diff --git a/src/Processors/Formats/Impl/AvroRowInputFormat.h b/src/Processors/Formats/Impl/AvroRowInputFormat.h
index b54c8ecede5a..6245d704e74a 100644
--- a/src/Processors/Formats/Impl/AvroRowInputFormat.h
+++ b/src/Processors/Formats/Impl/AvroRowInputFormat.h
@@ -22,7 +22,7 @@ namespace DB
 class AvroDeserializer
 {
 public:
-    AvroDeserializer(const ColumnsWithTypeAndName & columns, avro::ValidSchema schema);
+    AvroDeserializer(const Block & header, avro::ValidSchema schema);
     void deserializeRow(MutableColumns & columns, avro::Decoder & decoder) const;
 
 private:
@@ -31,15 +31,46 @@ class AvroDeserializer
     static DeserializeFn createDeserializeFn(avro::NodePtr root_node, DataTypePtr target_type);
     SkipFn createSkipFn(avro::NodePtr root_node);
 
-    /// Map from field index in Avro schema to column number in block header. Or -1 if there is no corresponding column.
-    std::vector<int> field_mapping;
-
-    /// How to skip the corresponding field in Avro schema.
-    std::vector<SkipFn> skip_fns;
-
-    /// How to deserialize the corresponding field in Avro schema.
-    std::vector<DeserializeFn> deserialize_fns;
-
+    struct Action
+    {
+        enum Type { Deserialize, Skip };
+        Type type;
+        /// Deserialize
+        int target_column_idx;
+        DeserializeFn deserialize_fn;
+        /// Skip
+        SkipFn skip_fn;
+
+        Action(int target_column_idx_, DeserializeFn deserialize_fn_)
+            : type(Deserialize)
+            , target_column_idx(target_column_idx_)
+            , deserialize_fn(deserialize_fn_) {}
+
+        Action(SkipFn skip_fn_)
+            : type(Skip)
+            , skip_fn(skip_fn_) {}
+
+        void execute(MutableColumns & columns, avro::Decoder & decoder) const
+        {
+            switch (type)
+            {
+                case Deserialize:
+                    deserialize_fn(*columns[target_column_idx], decoder);
+                    break;
+                case Skip:
+                    skip_fn(decoder);
+                    break;
+            }
+        }
+    };
+
+    /// Populate actions by recursively traversing root schema
+    void createActions(const Block & header, const avro::NodePtr& node, std::string current_path = "");
+
+    /// Bitmap of columns found in Avro schema
+    std::vector<bool> column_found;
+    /// Deserialize/Skip actions for a row
+    std::vector<Action> actions;
     /// Map from name of named Avro type (record, enum, fixed) to SkipFn.
     /// This is to avoid infinite recursion when  Avro schema contains self-references. e.g. LinkedList
     std::map<avro::Name, SkipFn> symbolic_skip_fn_map;
@@ -73,7 +104,6 @@ class AvroConfluentRowInputFormat : public IRowInputFormat
 
     class SchemaRegistry;
 private:
-    const ColumnsWithTypeAndName header_columns;
     std::shared_ptr<SchemaRegistry> schema_registry;
     using SchemaId = uint32_t;
     std::unordered_map<SchemaId, AvroDeserializer> deserializer_cache;
