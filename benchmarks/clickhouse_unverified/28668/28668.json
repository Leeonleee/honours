{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28668,
  "instance_id": "ClickHouse__ClickHouse-28668",
  "issue_numbers": [
    "27226"
  ],
  "base_commit": "33122597fe5f257966fe5cd67a4c1baf6f7fbc26",
  "patch": "diff --git a/programs/copier/ClusterCopier.cpp b/programs/copier/ClusterCopier.cpp\nindex 8b6cb9a98810..141a6d4f911d 100644\n--- a/programs/copier/ClusterCopier.cpp\n+++ b/programs/copier/ClusterCopier.cpp\n@@ -744,8 +744,8 @@ std::shared_ptr<ASTCreateQuery> rewriteCreateQueryStorage(const ASTPtr & create_\n     if (create.storage == nullptr || new_storage_ast == nullptr)\n         throw Exception(\"Storage is not specified\", ErrorCodes::LOGICAL_ERROR);\n \n-    res->database = new_table.first;\n-    res->table = new_table.second;\n+    res->setDatabase(new_table.first);\n+    res->setTable(new_table.second);\n \n     res->children.clear();\n     res->set(res->columns_list, create.columns_list->clone());\n@@ -1659,7 +1659,7 @@ TaskStatus ClusterCopier::processPartitionPieceTaskImpl(\n void ClusterCopier::dropAndCreateLocalTable(const ASTPtr & create_ast)\n {\n     const auto & create = create_ast->as<ASTCreateQuery &>();\n-    dropLocalTableIfExists({create.database, create.table});\n+    dropLocalTableIfExists({create.getDatabase(), create.getTable()});\n \n     auto create_context = Context::createCopy(getContext());\n \n@@ -1671,8 +1671,8 @@ void ClusterCopier::dropLocalTableIfExists(const DatabaseAndTableName & table_na\n {\n     auto drop_ast = std::make_shared<ASTDropQuery>();\n     drop_ast->if_exists = true;\n-    drop_ast->database = table_name.first;\n-    drop_ast->table = table_name.second;\n+    drop_ast->setDatabase(table_name.first);\n+    drop_ast->setTable(table_name.second);\n \n     auto drop_context = Context::createCopy(getContext());\n \ndiff --git a/src/Backups/BackupUtils.cpp b/src/Backups/BackupUtils.cpp\nindex bd5a31e0bf70..5da87cfd6f7b 100644\n--- a/src/Backups/BackupUtils.cpp\n+++ b/src/Backups/BackupUtils.cpp\n@@ -312,11 +312,11 @@ namespace\n     String getDataPathInBackup(const IAST & create_query)\n     {\n         const auto & create = create_query.as<const ASTCreateQuery &>();\n-        if (create.table.empty())\n+        if (!create.table)\n             return {};\n         if (create.temporary)\n-            return getDataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.table});\n-        return getDataPathInBackup({create.database, create.table});\n+            return getDataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.getTable()});\n+        return getDataPathInBackup({create.getDatabase(), create.getTable()});\n     }\n \n     String getMetadataPathInBackup(const DatabaseAndTableName & table_name)\n@@ -336,11 +336,11 @@ namespace\n     String getMetadataPathInBackup(const IAST & create_query)\n     {\n         const auto & create = create_query.as<const ASTCreateQuery &>();\n-        if (create.table.empty())\n-            return getMetadataPathInBackup(create.database);\n+        if (!create.table)\n+            return getMetadataPathInBackup(create.getDatabase());\n         if (create.temporary)\n-            return getMetadataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.table});\n-        return getMetadataPathInBackup({create.database, create.table});\n+            return getMetadataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.getTable()});\n+        return getMetadataPathInBackup({create.getDatabase(), create.getTable()});\n     }\n \n     void backupCreateQuery(const IAST & create_query, BackupEntries & backup_entries)\n@@ -419,7 +419,7 @@ namespace\n \n         /// We create and execute `create` query for the database name.\n         auto create_query = std::make_shared<ASTCreateQuery>();\n-        create_query->database = database_name;\n+        create_query->setDatabase(database_name);\n         create_query->if_not_exists = true;\n         InterpreterCreateQuery create_interpreter{create_query, context};\n         create_interpreter.execute();\n@@ -460,7 +460,7 @@ namespace\n \n         restore_tasks.emplace_back([table_name, new_create_query, partitions, context, backup]() -> RestoreDataTasks\n         {\n-            DatabaseAndTableName new_table_name{new_create_query->database, new_create_query->table};\n+            DatabaseAndTableName new_table_name{new_create_query->getDatabase(), new_create_query->getTable()};\n             if (new_create_query->temporary)\n                 new_table_name.first = DatabaseCatalog::TEMPORARY_DATABASE;\n \n@@ -536,7 +536,7 @@ namespace\n \n         restore_tasks.emplace_back([database_name, new_create_query, except_list, context, backup, renaming_config]() -> RestoreDataTasks\n         {\n-            const String & new_database_name = new_create_query->database;\n+            const String & new_database_name = new_create_query->getDatabase();\n             context->checkAccess(AccessType::SHOW_TABLES, new_database_name);\n \n             if (!DatabaseCatalog::instance().isDatabaseExist(new_database_name))\ndiff --git a/src/Backups/renameInCreateQuery.cpp b/src/Backups/renameInCreateQuery.cpp\nindex 4c78844d2662..7a94a755f677 100644\n--- a/src/Backups/renameInCreateQuery.cpp\n+++ b/src/Backups/renameInCreateQuery.cpp\n@@ -48,21 +48,23 @@ namespace\n         {\n             if (create.temporary)\n             {\n-                if (create.table.empty())\n+                if (!create.table)\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Table name specified in the CREATE TEMPORARY TABLE query must not be empty\");\n-                create.table = data.renaming_config->getNewTemporaryTableName(create.table);\n+                create.setTable(data.renaming_config->getNewTemporaryTableName(create.getTable()));\n             }\n-            else if (create.table.empty())\n+            else if (!create.table)\n             {\n-                if (create.database.empty())\n+                if (!create.database)\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Database name specified in the CREATE DATABASE query must not be empty\");\n-                create.database = data.renaming_config->getNewDatabaseName(create.database);\n+                create.setDatabase(data.renaming_config->getNewDatabaseName(create.getDatabase()));\n             }\n             else\n             {\n-                if (create.database.empty())\n+                if (!create.database)\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Database name specified in the CREATE TABLE query must not be empty\");\n-                std::tie(create.database, create.table) = data.renaming_config->getNewTableName({create.database, create.table});\n+                auto table_and_database_name = data.renaming_config->getNewTableName({create.getDatabase(), create.getTable()});\n+                create.setDatabase(table_and_database_name.first);\n+                create.setTable(table_and_database_name.second);\n             }\n \n             create.uuid = UUIDHelpers::Nil;\ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex 3998f5586203..c4b4009a5ff4 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -490,7 +490,7 @@ void ClientBase::processOrdinaryQuery(const String & query_to_execute, ASTPtr pa\n         ReplaceQueryParameterVisitor visitor(query_parameters);\n         visitor.visit(parsed_query);\n \n-        /// Get new query after substitutions. Note that it cannot be done for INSERT query with embedded data.\n+        /// Get new query after substitutions.\n         query = serializeAST(*parsed_query);\n     }\n \n@@ -824,6 +824,17 @@ bool ClientBase::receiveSampleBlock(Block & out, ColumnsDescription & columns_de\n \n void ClientBase::processInsertQuery(const String & query_to_execute, ASTPtr parsed_query)\n {\n+    auto query = query_to_execute;\n+    if (!query_parameters.empty())\n+    {\n+        /// Replace ASTQueryParameter with ASTLiteral for prepared statements.\n+        ReplaceQueryParameterVisitor visitor(query_parameters);\n+        visitor.visit(parsed_query);\n+\n+        /// Get new query after substitutions.\n+        query = serializeAST(*parsed_query);\n+    }\n+\n     /// Process the query that requires transferring data blocks to the server.\n     const auto parsed_insert_query = parsed_query->as<ASTInsertQuery &>();\n     if ((!parsed_insert_query.data && !parsed_insert_query.infile) && (is_interactive || (!stdin_is_a_tty && std_in.eof())))\n@@ -831,7 +842,7 @@ void ClientBase::processInsertQuery(const String & query_to_execute, ASTPtr pars\n \n     connection->sendQuery(\n         connection_parameters.timeouts,\n-        query_to_execute,\n+        query,\n         global_context->getCurrentQueryId(),\n         query_processing_stage,\n         &global_context->getSettingsRef(),\n@@ -884,8 +895,7 @@ void ClientBase::sendData(Block & sample, const ColumnsDescription & columns_des\n         /// Get name of this file (path to file)\n         const auto & in_file_node = parsed_insert_query->infile->as<ASTLiteral &>();\n         const auto in_file = in_file_node.value.safeGet<std::string>();\n-        /// Get name of table\n-        const auto table_name = parsed_insert_query->table_id.getTableName();\n+\n         std::string compression_method;\n         /// Compression method can be specified in query\n         if (parsed_insert_query->compression)\ndiff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex 0ada66b806a4..76e836a9b71a 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -295,9 +295,9 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n     try\n     {\n         std::unique_lock lock{mutex};\n-        if (query.database != database_name)\n+        if (query.getDatabase() != database_name)\n             throw Exception(ErrorCodes::UNKNOWN_DATABASE, \"Database was renamed to `{}`, cannot create table in `{}`\",\n-                            database_name, query.database);\n+                            database_name, query.getDatabase());\n         /// Do some checks before renaming file from .tmp to .sql\n         not_in_use = cleanupDetachedTables();\n         assertDetachedTableNotInUse(query.uuid);\n@@ -314,8 +314,8 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n \n         /// It throws if `table_metadata_path` already exists (it's possible if table was detached)\n         renameNoReplace(table_metadata_tmp_path, table_metadata_path);  /// Commit point (a sort of)\n-        attachTableUnlocked(query.table, table, lock);   /// Should never throw\n-        table_name_to_path.emplace(query.table, table_data_path);\n+        attachTableUnlocked(query.getTable(), table, lock);   /// Should never throw\n+        table_name_to_path.emplace(query.getTable(), table_data_path);\n     }\n     catch (...)\n     {\n@@ -325,7 +325,7 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n         throw;\n     }\n     if (table->storesDataOnDisk())\n-        tryCreateSymlink(query.table, table_data_path);\n+        tryCreateSymlink(query.getTable(), table_data_path);\n }\n \n void DatabaseAtomic::commitAlterTable(const StorageID & table_id, const String & table_metadata_tmp_path, const String & table_metadata_path,\ndiff --git a/src/Databases/DatabaseFactory.cpp b/src/Databases/DatabaseFactory.cpp\nindex 03d913246728..74b103afbc42 100644\n--- a/src/Databases/DatabaseFactory.cpp\n+++ b/src/Databases/DatabaseFactory.cpp\n@@ -103,7 +103,7 @@ static inline ValueType safeGetLiteralValue(const ASTPtr &ast, const String &eng\n DatabasePtr DatabaseFactory::getImpl(const ASTCreateQuery & create, const String & metadata_path, ContextPtr context)\n {\n     auto * engine_define = create.storage;\n-    const String & database_name = create.database;\n+    const String & database_name = create.getDatabase();\n     const String & engine_name = engine_define->engine->name;\n     const UUID & uuid = create.uuid;\n \ndiff --git a/src/Databases/DatabaseMemory.cpp b/src/Databases/DatabaseMemory.cpp\nindex 288f34ad7d18..8128bb8378e0 100644\n--- a/src/Databases/DatabaseMemory.cpp\n+++ b/src/Databases/DatabaseMemory.cpp\n@@ -75,7 +75,7 @@ void DatabaseMemory::dropTable(\n ASTPtr DatabaseMemory::getCreateDatabaseQuery() const\n {\n     auto create_query = std::make_shared<ASTCreateQuery>();\n-    create_query->database = getDatabaseName();\n+    create_query->setDatabase(getDatabaseName());\n     create_query->set(create_query->storage, std::make_shared<ASTStorage>());\n     create_query->storage->set(create_query->storage->engine, makeASTFunction(getEngineName()));\n \ndiff --git a/src/Databases/DatabaseMemory.h b/src/Databases/DatabaseMemory.h\nindex a661d1c49b0f..b854d9be1f34 100644\n--- a/src/Databases/DatabaseMemory.h\n+++ b/src/Databases/DatabaseMemory.h\n@@ -42,7 +42,7 @@ class DatabaseMemory final : public DatabaseWithOwnTablesBase\n     /// TODO May be it's better to use DiskMemory for such tables.\n     ///      To save data on disk it's possible to explicitly CREATE DATABASE db ENGINE=Ordinary in clickhouse-local.\n     String getTableDataPath(const String & table_name) const override { return data_path + escapeForFileName(table_name) + \"/\"; }\n-    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.table); }\n+    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.getTable()); }\n \n     UUID tryGetTableUUID(const String & table_name) const override;\n \ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 55e5a3071bcb..a1e0a8257361 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -51,7 +51,7 @@ std::pair<String, StoragePtr> createTableFromAST(\n     bool force_restore)\n {\n     ast_create_query.attach = true;\n-    ast_create_query.database = database_name;\n+    ast_create_query.setDatabase(database_name);\n \n     if (ast_create_query.as_table_function)\n     {\n@@ -60,9 +60,9 @@ std::pair<String, StoragePtr> createTableFromAST(\n         ColumnsDescription columns;\n         if (ast_create_query.columns_list && ast_create_query.columns_list->columns)\n             columns = InterpreterCreateQuery::getColumnsDescription(*ast_create_query.columns_list->columns, context, true);\n-        StoragePtr storage = table_function->execute(ast_create_query.as_table_function, context, ast_create_query.table, std::move(columns));\n+        StoragePtr storage = table_function->execute(ast_create_query.as_table_function, context, ast_create_query.getTable(), std::move(columns));\n         storage->renameInMemory(ast_create_query);\n-        return {ast_create_query.table, storage};\n+        return {ast_create_query.getTable(), storage};\n     }\n \n     ColumnsDescription columns;\n@@ -82,7 +82,7 @@ std::pair<String, StoragePtr> createTableFromAST(\n \n     return\n     {\n-        ast_create_query.table,\n+        ast_create_query.getTable(),\n         StorageFactory::instance().get(\n             ast_create_query,\n             table_data_path_relative,\n@@ -112,7 +112,7 @@ String getObjectDefinitionFromCreateQuery(const ASTPtr & query)\n \n     /// We remove everything that is not needed for ATTACH from the query.\n     assert(!create->temporary);\n-    create->database.clear();\n+    create->database.reset();\n     create->as_database.clear();\n     create->as_table.clear();\n     create->if_not_exists = false;\n@@ -129,7 +129,7 @@ String getObjectDefinitionFromCreateQuery(const ASTPtr & query)\n     create->out_file = nullptr;\n \n     if (create->uuid != UUIDHelpers::Nil)\n-        create->table = TABLE_WITH_UUID_NAME_PLACEHOLDER;\n+        create->setTable(TABLE_WITH_UUID_NAME_PLACEHOLDER);\n \n     WriteBufferFromOwnString statement_buf;\n     formatAST(*create, statement_buf, false);\n@@ -161,7 +161,7 @@ void DatabaseOnDisk::createTable(\n {\n     const auto & settings = local_context->getSettingsRef();\n     const auto & create = query->as<ASTCreateQuery &>();\n-    assert(table_name == create.table);\n+    assert(table_name == create.getTable());\n \n     /// Create a file with metadata if necessary - if the query is not ATTACH.\n     /// Write the query of `ATTACH table` to it.\n@@ -251,7 +251,7 @@ void DatabaseOnDisk::commitCreateTable(const ASTCreateQuery & query, const Stora\n     try\n     {\n         /// Add a table to the map of known tables.\n-        attachTable(query.table, table, getTableDataPath(query));\n+        attachTable(query.getTable(), table, getTableDataPath(query));\n \n         /// If it was ATTACH query and file with table metadata already exist\n         /// (so, ATTACH is done after DETACH), then rename atomically replaces old file with new one.\n@@ -382,8 +382,8 @@ void DatabaseOnDisk::renameTable(\n         table_metadata_path = getObjectMetadataPath(table_name);\n         attach_query = parseQueryFromMetadata(log, local_context, table_metadata_path);\n         auto & create = attach_query->as<ASTCreateQuery &>();\n-        create.database = to_database.getDatabaseName();\n-        create.table = to_table_name;\n+        create.setDatabase(to_database.getDatabaseName());\n+        create.setTable(to_table_name);\n         if (from_ordinary_to_atomic)\n             create.uuid = UUIDHelpers::generateV4();\n         if (from_atomic_to_ordinary)\n@@ -458,7 +458,7 @@ ASTPtr DatabaseOnDisk::getCreateDatabaseQuery() const\n         ast = parseQueryFromMetadata(log, getContext(), database_metadata_path, true);\n         auto & ast_create_query = ast->as<ASTCreateQuery &>();\n         ast_create_query.attach = false;\n-        ast_create_query.database = database_name;\n+        ast_create_query.setDatabase(database_name);\n     }\n     if (!ast)\n     {\n@@ -642,18 +642,18 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(\n         return nullptr;\n \n     auto & create = ast->as<ASTCreateQuery &>();\n-    if (!create.table.empty() && create.uuid != UUIDHelpers::Nil)\n+    if (create.table && create.uuid != UUIDHelpers::Nil)\n     {\n         String table_name = unescapeForFileName(fs::path(metadata_file_path).stem());\n \n-        if (create.table != TABLE_WITH_UUID_NAME_PLACEHOLDER && logger)\n+        if (create.getTable() != TABLE_WITH_UUID_NAME_PLACEHOLDER && logger)\n             LOG_WARNING(\n                 logger,\n                 \"File {} contains both UUID and table name. Will use name `{}` instead of `{}`\",\n                 metadata_file_path,\n                 table_name,\n-                create.table);\n-        create.table = table_name;\n+                create.getTable());\n+        create.setTable(table_name);\n     }\n \n     return ast;\n@@ -667,7 +667,7 @@ ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const String & database_metada\n     {\n         auto & ast_create_query = ast->as<ASTCreateQuery &>();\n         ast_create_query.attach = false;\n-        ast_create_query.database = getDatabaseName();\n+        ast_create_query.setDatabase(getDatabaseName());\n     }\n \n     return ast;\ndiff --git a/src/Databases/DatabaseOnDisk.h b/src/Databases/DatabaseOnDisk.h\nindex 81d5bd5adcb8..f27a332fa3e1 100644\n--- a/src/Databases/DatabaseOnDisk.h\n+++ b/src/Databases/DatabaseOnDisk.h\n@@ -63,7 +63,7 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n \n     String getDataPath() const override { return data_path; }\n     String getTableDataPath(const String & table_name) const override { return data_path + escapeForFileName(table_name) + \"/\"; }\n-    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.table); }\n+    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.getTable()); }\n     String getMetadataPath() const override { return metadata_path; }\n \n     static ASTPtr parseQueryFromMetadata(Poco::Logger * log, ContextPtr context, const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false);\ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex 061529f4e127..2da17ed388f5 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -55,7 +55,7 @@ namespace\n         catch (Exception & e)\n         {\n             e.addMessage(\n-                \"Cannot attach table \" + backQuote(database_name) + \".\" + backQuote(query.table) + \" from metadata file \" + metadata_path\n+                \"Cannot attach table \" + backQuote(database_name) + \".\" + backQuote(query.getTable()) + \" from metadata file \" + metadata_path\n                 + \" from query \" + serializeAST(query));\n             throw;\n         }\n@@ -168,7 +168,7 @@ void DatabaseOrdinary::loadTablesMetadata(ContextPtr local_context, ParsedTables\n             if (ast)\n             {\n                 auto * create_query = ast->as<ASTCreateQuery>();\n-                create_query->database = database_name;\n+                create_query->setDatabase(database_name);\n \n                 if (fs::exists(full_path.string() + detached_suffix))\n                 {\n@@ -182,7 +182,7 @@ void DatabaseOrdinary::loadTablesMetadata(ContextPtr local_context, ParsedTables\n                 }\n \n                 TableNamesSet loading_dependencies = getDependenciesSetFromCreateQuery(getContext(), ast);\n-                QualifiedTableName qualified_name{database_name, create_query->table};\n+                QualifiedTableName qualified_name{database_name, create_query->getTable()};\n \n                 std::lock_guard lock{metadata.mutex};\n                 metadata.parsed_tables[qualified_name] = ParsedTableMetadata{full_path.string(), ast};\ndiff --git a/src/Databases/DatabaseReplicated.cpp b/src/Databases/DatabaseReplicated.cpp\nindex 3f253ed0924e..89d1f96857e2 100644\n--- a/src/Databases/DatabaseReplicated.cpp\n+++ b/src/Databases/DatabaseReplicated.cpp\n@@ -349,9 +349,9 @@ void DatabaseReplicated::checkQueryValid(const ASTPtr & query, ContextPtr query_\n     /// Replicas will set correct name of current database in query context (database name can be different on replicas)\n     if (auto * ddl_query = dynamic_cast<ASTQueryWithTableAndOutput *>(query.get()))\n     {\n-        if (ddl_query->database != getDatabaseName())\n+        if (ddl_query->getDatabase() != getDatabaseName())\n             throw Exception(ErrorCodes::UNKNOWN_DATABASE, \"Database was renamed\");\n-        ddl_query->database.clear();\n+        ddl_query->database.reset();\n \n         if (auto * create = query->as<ASTCreateQuery>())\n         {\n@@ -391,7 +391,7 @@ void DatabaseReplicated::checkQueryValid(const ASTPtr & query, ContextPtr query_\n             /// NOTE: we cannot check here that substituted values will be actually different on shards and replicas.\n \n             Macros::MacroExpansionInfo info;\n-            info.table_id = {getDatabaseName(), create->table, create->uuid};\n+            info.table_id = {getDatabaseName(), create->getTable(), create->uuid};\n             query_context->getMacros()->expand(maybe_path, info);\n             bool maybe_shard_macros = info.expanded_other;\n             info.expanded_other = false;\n@@ -715,13 +715,13 @@ ASTPtr DatabaseReplicated::parseQueryFromMetadataInZooKeeper(const String & node\n     auto ast = parseQuery(parser, query, description, 0, getContext()->getSettingsRef().max_parser_depth);\n \n     auto & create = ast->as<ASTCreateQuery &>();\n-    if (create.uuid == UUIDHelpers::Nil || create.table != TABLE_WITH_UUID_NAME_PLACEHOLDER || !create.database.empty())\n+    if (create.uuid == UUIDHelpers::Nil || create.getTable() != TABLE_WITH_UUID_NAME_PLACEHOLDER || create.database)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Got unexpected query from {}: {}\", node_name, query);\n \n     bool is_materialized_view_with_inner_table = create.is_materialized_view && create.to_table_id.empty();\n \n-    create.database = getDatabaseName();\n-    create.table = unescapeForFileName(node_name);\n+    create.setDatabase(getDatabaseName());\n+    create.setTable(unescapeForFileName(node_name));\n     create.attach = is_materialized_view_with_inner_table;\n \n     return ast;\n@@ -811,7 +811,7 @@ void DatabaseReplicated::commitCreateTable(const ASTCreateQuery & query, const S\n     assert(!ddl_worker->isCurrentlyActive() || txn);\n     if (txn && txn->isInitialQuery())\n     {\n-        String metadata_zk_path = zookeeper_path + \"/metadata/\" + escapeForFileName(query.table);\n+        String metadata_zk_path = zookeeper_path + \"/metadata/\" + escapeForFileName(query.getTable());\n         String statement = getObjectDefinitionFromCreateQuery(query.clone());\n         /// zk::multi(...) will throw if `metadata_zk_path` exists\n         txn->addOp(zkutil::makeCreateRequest(metadata_zk_path, statement, zkutil::CreateMode::Persistent));\ndiff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp\nindex e5e54f287ecf..c92aac44083c 100644\n--- a/src/Databases/DatabasesCommon.cpp\n+++ b/src/Databases/DatabasesCommon.cpp\n@@ -29,7 +29,7 @@ void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemo\n     bool has_structure = ast_create_query.columns_list && ast_create_query.columns_list->columns;\n     if (ast_create_query.as_table_function && !has_structure)\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot alter table {} because it was created AS table function\"\n-                                                     \" and doesn't have structure in metadata\", backQuote(ast_create_query.table));\n+                                                     \" and doesn't have structure in metadata\", backQuote(ast_create_query.getTable()));\n \n     assert(has_structure);\n     ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);\ndiff --git a/src/Databases/MySQL/DatabaseMySQL.cpp b/src/Databases/MySQL/DatabaseMySQL.cpp\nindex feebf33f58a0..275a1015c7b9 100644\n--- a/src/Databases/MySQL/DatabaseMySQL.cpp\n+++ b/src/Databases/MySQL/DatabaseMySQL.cpp\n@@ -129,8 +129,8 @@ static ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr\n     {\n         /// init create query.\n         auto table_id = storage->getStorageID();\n-        create_table_query->table = table_id.table_name;\n-        create_table_query->database = table_id.database_name;\n+        create_table_query->setTable(table_id.table_name);\n+        create_table_query->setDatabase(table_id.database_name);\n \n         auto metadata_snapshot = storage->getInMemoryMetadataPtr();\n         for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())\n@@ -192,7 +192,7 @@ time_t DatabaseMySQL::getObjectMetadataModificationTime(const String & table_nam\n ASTPtr DatabaseMySQL::getCreateDatabaseQuery() const\n {\n     const auto & create_query = std::make_shared<ASTCreateQuery>();\n-    create_query->database = getDatabaseName();\n+    create_query->setDatabase(getDatabaseName());\n     create_query->set(create_query->storage, database_engine_define);\n \n     if (const auto comment_value = getDatabaseComment(); !comment_value.empty())\ndiff --git a/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp b/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp\nindex 2b0d73a02ae4..14488f088119 100644\n--- a/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp\n+++ b/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp\n@@ -238,7 +238,7 @@ ASTPtr DatabaseMaterializedPostgreSQL::createAlterSettingsQuery(const SettingCha\n     auto * alter = query->as<ASTAlterQuery>();\n \n     alter->alter_object = ASTAlterQuery::AlterObjectType::DATABASE;\n-    alter->database = database_name;\n+    alter->setDatabase(database_name);\n     alter->set(alter->command_list, command_list);\n \n     return query;\ndiff --git a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp\nindex 5d3493d0c82b..e995a6d2377a 100644\n--- a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp\n+++ b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp\n@@ -355,7 +355,7 @@ void DatabasePostgreSQL::shutdown()\n ASTPtr DatabasePostgreSQL::getCreateDatabaseQuery() const\n {\n     const auto & create_query = std::make_shared<ASTCreateQuery>();\n-    create_query->database = getDatabaseName();\n+    create_query->setDatabase(getDatabaseName());\n     create_query->set(create_query->storage, database_engine_define);\n \n     if (const auto comment_value = getDatabaseComment(); !comment_value.empty())\n@@ -388,8 +388,8 @@ ASTPtr DatabasePostgreSQL::getCreateTableQueryImpl(const String & table_name, Co\n \n     /// init create query.\n     auto table_id = storage->getStorageID();\n-    create_table_query->table = table_id.table_name;\n-    create_table_query->database = table_id.database_name;\n+    create_table_query->setTable(table_id.table_name);\n+    create_table_query->setDatabase(table_id.database_name);\n \n     auto metadata_snapshot = storage->getInMemoryMetadataPtr();\n     for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())\ndiff --git a/src/Databases/SQLite/DatabaseSQLite.cpp b/src/Databases/SQLite/DatabaseSQLite.cpp\nindex 05bc2f248344..ba53ab084074 100644\n--- a/src/Databases/SQLite/DatabaseSQLite.cpp\n+++ b/src/Databases/SQLite/DatabaseSQLite.cpp\n@@ -160,7 +160,7 @@ StoragePtr DatabaseSQLite::fetchTable(const String & table_name, ContextPtr loca\n ASTPtr DatabaseSQLite::getCreateDatabaseQuery() const\n {\n     const auto & create_query = std::make_shared<ASTCreateQuery>();\n-    create_query->database = getDatabaseName();\n+    create_query->setDatabase(getDatabaseName());\n     create_query->set(create_query->storage, database_engine_define);\n \n     if (const auto comment_value = getDatabaseComment(); !comment_value.empty())\n@@ -193,8 +193,8 @@ ASTPtr DatabaseSQLite::getCreateTableQueryImpl(const String & table_name, Contex\n \n     /// init create query.\n     auto table_id = storage->getStorageID();\n-    create_table_query->table = table_id.table_name;\n-    create_table_query->database = table_id.database_name;\n+    create_table_query->setTable(table_id.table_name);\n+    create_table_query->setDatabase(table_id.database_name);\n \n     auto metadata_snapshot = storage->getInMemoryMetadataPtr();\n     for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())\ndiff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\nindex 0c6944eeccc5..f031e8ff038d 100644\n--- a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp\n@@ -536,12 +536,12 @@ getDictionaryConfigurationFromAST(const ASTCreateQuery & query, ContextPtr conte\n \n     AutoPtr<Poco::XML::Element> name_element(xml_document->createElement(\"name\"));\n     current_dictionary->appendChild(name_element);\n-    AutoPtr<Text> name(xml_document->createTextNode(query.table));\n+    AutoPtr<Text> name(xml_document->createTextNode(query.getTable()));\n     name_element->appendChild(name);\n \n     AutoPtr<Poco::XML::Element> database_element(xml_document->createElement(\"database\"));\n     current_dictionary->appendChild(database_element);\n-    AutoPtr<Text> database(xml_document->createTextNode(!database_.empty() ? database_ : query.database));\n+    AutoPtr<Text> database(xml_document->createTextNode(!database_.empty() ? database_ : query.getDatabase()));\n     database_element->appendChild(database);\n \n     if (query.uuid != UUIDHelpers::Nil)\ndiff --git a/src/Interpreters/AddDefaultDatabaseVisitor.h b/src/Interpreters/AddDefaultDatabaseVisitor.h\nindex 480a7c01b98e..d5039a2f19e2 100644\n--- a/src/Interpreters/AddDefaultDatabaseVisitor.h\n+++ b/src/Interpreters/AddDefaultDatabaseVisitor.h\n@@ -239,8 +239,8 @@ class AddDefaultDatabaseVisitor\n         if (only_replace_current_database_function)\n             return;\n \n-        if (node.database.empty())\n-            node.database = database_name;\n+        if (!node.database)\n+            node.setDatabase(database_name);\n     }\n \n     void visitDDL(ASTRenameQuery & node, ASTPtr &) const\n@@ -262,8 +262,8 @@ class AddDefaultDatabaseVisitor\n         if (only_replace_current_database_function)\n             return;\n \n-        if (node.database.empty())\n-            node.database = database_name;\n+        if (!node.database)\n+            node.setDatabase(database_name);\n \n         for (const auto & child : node.command_list->children)\n         {\ndiff --git a/src/Interpreters/DDLTask.cpp b/src/Interpreters/DDLTask.cpp\nindex cfce6ac94639..b8d3d64feea8 100644\n--- a/src/Interpreters/DDLTask.cpp\n+++ b/src/Interpreters/DDLTask.cpp\n@@ -257,12 +257,12 @@ bool DDLTask::tryFindHostInCluster()\n                          * */\n                         is_circular_replicated = true;\n                         auto * query_with_table = dynamic_cast<ASTQueryWithTableAndOutput *>(query.get());\n-                        if (!query_with_table || query_with_table->database.empty())\n+                        if (!query_with_table || !query_with_table->database)\n                         {\n                             throw Exception(ErrorCodes::INCONSISTENT_CLUSTER_DEFINITION,\n                                             \"For a distributed DDL on circular replicated cluster its table name must be qualified by database name.\");\n                         }\n-                        if (default_database == query_with_table->database)\n+                        if (default_database == query_with_table->getDatabase())\n                             return true;\n                     }\n                 }\n@@ -351,8 +351,8 @@ void DatabaseReplicatedTask::parseQueryFromEntry(ContextPtr context)\n     if (auto * ddl_query = dynamic_cast<ASTQueryWithTableAndOutput *>(query.get()))\n     {\n         /// Update database name with actual name of local database\n-        assert(ddl_query->database.empty());\n-        ddl_query->database = database->getDatabaseName();\n+        assert(!ddl_query->database);\n+        ddl_query->setDatabase(database->getDatabaseName());\n     }\n }\n \ndiff --git a/src/Interpreters/DDLWorker.cpp b/src/Interpreters/DDLWorker.cpp\nindex 4633b22ca493..9fefcf012a9e 100644\n--- a/src/Interpreters/DDLWorker.cpp\n+++ b/src/Interpreters/DDLWorker.cpp\n@@ -662,7 +662,7 @@ void DDLWorker::processTask(DDLTaskBase & task, const ZooKeeperPtr & zookeeper)\n             StoragePtr storage;\n             if (auto * query_with_table = dynamic_cast<ASTQueryWithTableAndOutput *>(task.query.get()); query_with_table)\n             {\n-                if (!query_with_table->table.empty())\n+                if (query_with_table->table)\n                 {\n                     /// It's not CREATE DATABASE\n                     auto table_id = context->tryResolveStorageID(*query_with_table, Context::ResolveOrdinary);\ndiff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp\nindex fa8f3e099ff9..898e169bc44c 100644\n--- a/src/Interpreters/DatabaseCatalog.cpp\n+++ b/src/Interpreters/DatabaseCatalog.cpp\n@@ -66,9 +66,9 @@ TemporaryTableHolder::TemporaryTableHolder(ContextPtr context_, const TemporaryT\n         if (create->uuid == UUIDHelpers::Nil)\n             create->uuid = UUIDHelpers::generateV4();\n         id = create->uuid;\n-        create->table = \"_tmp_\" + toString(id);\n-        global_name = create->table;\n-        create->database = DatabaseCatalog::TEMPORARY_DATABASE;\n+        create->setTable(\"_tmp_\" + toString(id));\n+        global_name = create->getTable();\n+        create->setDatabase(DatabaseCatalog::TEMPORARY_DATABASE);\n     }\n     else\n     {\n@@ -786,8 +786,8 @@ void DatabaseCatalog::enqueueDroppedTableCleanup(StorageID table_id, StoragePtr\n         if (create)\n         {\n             String data_path = \"store/\" + getPathForUUID(table_id.uuid);\n-            create->database = table_id.database_name;\n-            create->table = table_id.table_name;\n+            create->setDatabase(table_id.database_name);\n+            create->setTable(table_id.table_name);\n             try\n             {\n                 table = createTableFromAST(*create, table_id.getDatabaseName(), data_path, getContext(), false).second;\ndiff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex 354d25fbe8fc..665d76625ef8 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -62,7 +62,7 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n \n     getContext()->checkAccess(getRequiredAccess());\n     auto table_id = getContext()->resolveStorageID(alter, Context::ResolveOrdinary);\n-    query_ptr->as<ASTAlterQuery &>().database = table_id.database_name;\n+    query_ptr->as<ASTAlterQuery &>().setDatabase(table_id.database_name);\n \n     DatabasePtr database = DatabaseCatalog::instance().getDatabase(table_id.database_name);\n     if (typeid_cast<DatabaseReplicated *>(database.get())\n@@ -175,7 +175,7 @@ BlockIO InterpreterAlterQuery::executeToDatabase(const ASTAlterQuery & alter)\n {\n     BlockIO res;\n     getContext()->checkAccess(getRequiredAccess());\n-    DatabasePtr database = DatabaseCatalog::instance().getDatabase(alter.database);\n+    DatabasePtr database = DatabaseCatalog::instance().getDatabase(alter.getDatabase());\n     AlterCommands alter_commands;\n \n     for (const auto & child : alter.command_list->children)\n@@ -215,7 +215,7 @@ AccessRightsElements InterpreterAlterQuery::getRequiredAccess() const\n     AccessRightsElements required_access;\n     const auto & alter = query_ptr->as<ASTAlterQuery &>();\n     for (const auto & child : alter.command_list->children)\n-        boost::range::push_back(required_access, getRequiredAccessForCommand(child->as<ASTAlterCommand&>(), alter.database, alter.table));\n+        boost::range::push_back(required_access, getRequiredAccessForCommand(child->as<ASTAlterCommand&>(), alter.getDatabase(), alter.getTable()));\n     return required_access;\n }\n \ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 7e6c3f113b50..bef599077824 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -101,7 +101,7 @@ InterpreterCreateQuery::InterpreterCreateQuery(const ASTPtr & query_ptr_, Contex\n \n BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n {\n-    String database_name = create.database;\n+    String database_name = create.getDatabase();\n \n     auto guard = DatabaseCatalog::instance().getDDLGuard(database_name, \"\");\n \n@@ -127,11 +127,11 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n         /// Short syntax: try read database definition from file\n         auto ast = DatabaseOnDisk::parseQueryFromMetadata(nullptr, getContext(), metadata_file_path);\n         create = ast->as<ASTCreateQuery &>();\n-        if (!create.table.empty() || !create.storage)\n+        if (create.table || !create.storage)\n             throw Exception(ErrorCodes::INCORRECT_QUERY, \"Metadata file {} contains incorrect CREATE DATABASE query\", metadata_file_path.string());\n         create.attach = true;\n         create.attach_short_syntax = true;\n-        create.database = database_name;\n+        create.setDatabase(database_name);\n     }\n     else if (!create.storage)\n     {\n@@ -161,7 +161,7 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n     {\n         if (create.attach && create.uuid == UUIDHelpers::Nil)\n             throw Exception(ErrorCodes::INCORRECT_QUERY, \"UUID must be specified for ATTACH. \"\n-                            \"If you want to attach existing database, use just ATTACH DATABASE {};\", create.database);\n+                            \"If you want to attach existing database, use just ATTACH DATABASE {};\", create.getDatabase());\n         else if (create.uuid == UUIDHelpers::Nil)\n             create.uuid = UUIDHelpers::generateV4();\n \n@@ -238,7 +238,7 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)\n     DatabasePtr database = DatabaseFactory::get(create, metadata_path / \"\", getContext());\n \n     if (create.uuid != UUIDHelpers::Nil)\n-        create.database = TABLE_WITH_UUID_NAME_PLACEHOLDER;\n+        create.setDatabase(TABLE_WITH_UUID_NAME_PLACEHOLDER);\n \n     bool need_write_metadata = !create.attach || !fs::exists(metadata_file_path);\n \n@@ -823,7 +823,7 @@ void InterpreterCreateQuery::assertOrSetUUID(ASTCreateQuery & create, const Data\n         bool has_uuid = create.uuid != UUIDHelpers::Nil || create.to_inner_uuid != UUIDHelpers::Nil;\n         if (has_uuid && !is_on_cluster)\n             throw Exception(ErrorCodes::INCORRECT_QUERY,\n-                            \"{} UUID specified, but engine of database {} is not Atomic\", kind, create.database);\n+                            \"{} UUID specified, but engine of database {} is not Atomic\", kind, create.getDatabase());\n \n         /// Ignore UUID if it's ON CLUSTER query\n         create.uuid = UUIDHelpers::Nil;\n@@ -835,12 +835,12 @@ void InterpreterCreateQuery::assertOrSetUUID(ASTCreateQuery & create, const Data\n BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n {\n     /// Temporary tables are created out of databases.\n-    if (create.temporary && !create.database.empty())\n+    if (create.temporary && create.database)\n         throw Exception(\"Temporary tables cannot be inside a database. You should not specify a database for a temporary table.\",\n             ErrorCodes::BAD_DATABASE_FOR_TEMPORARY_TABLE);\n \n     String current_database = getContext()->getCurrentDatabase();\n-    auto database_name = create.database.empty() ? current_database : create.database;\n+    auto database_name = create.database ? create.getDatabase() : current_database;\n \n     // If this is a stub ATTACH query, read the query definition from the database\n     if (create.attach && !create.storage && !create.columns_list)\n@@ -849,12 +849,12 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n \n         if (database->getEngineName() == \"Replicated\")\n         {\n-            auto guard = DatabaseCatalog::instance().getDDLGuard(database_name, create.table);\n+            auto guard = DatabaseCatalog::instance().getDDLGuard(database_name, create.getTable());\n \n             if (auto* ptr = typeid_cast<DatabaseReplicated *>(database.get());\n                 ptr && !getContext()->getClientInfo().is_replicated_database_internal)\n             {\n-                create.database = database_name;\n+                create.setDatabase(database_name);\n                 guard->releaseTableLock();\n                 return ptr->tryEnqueueReplicatedDDL(query_ptr, getContext());\n             }\n@@ -863,18 +863,18 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n         bool if_not_exists = create.if_not_exists;\n \n         // Table SQL definition is available even if the table is detached (even permanently)\n-        auto query = database->getCreateTableQuery(create.table, getContext());\n+        auto query = database->getCreateTableQuery(create.getTable(), getContext());\n         auto create_query = query->as<ASTCreateQuery &>();\n \n         if (!create.is_dictionary && create_query.is_dictionary)\n             throw Exception(ErrorCodes::INCORRECT_QUERY,\n                 \"Cannot ATTACH TABLE {}.{}, it is a Dictionary\",\n-                backQuoteIfNeed(database_name), backQuoteIfNeed(create.table));\n+                backQuoteIfNeed(database_name), backQuoteIfNeed(create.getTable()));\n \n         if (create.is_dictionary && !create_query.is_dictionary)\n             throw Exception(ErrorCodes::INCORRECT_QUERY,\n                 \"Cannot ATTACH DICTIONARY {}.{}, it is a Table\",\n-                backQuoteIfNeed(database_name), backQuoteIfNeed(create.table));\n+                backQuoteIfNeed(database_name), backQuoteIfNeed(create.getTable()));\n \n         create = create_query; // Copy the saved create query, but use ATTACH instead of CREATE\n \n@@ -917,11 +917,11 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n                          \"use either ATTACH TABLE {}; to attach existing table \"\n                          \"or CREATE TABLE {} <table definition>; to create new table \"\n                          \"or ATTACH TABLE {} FROM '/path/to/data/' <table definition>; to create new table and attach data.\",\n-                         create.table, create.table, create.table);\n+                         create.getTable(), create.getTable(), create.getTable());\n     }\n \n-    if (!create.temporary && create.database.empty())\n-        create.database = current_database;\n+    if (!create.temporary && !create.database)\n+        create.setDatabase(current_database);\n     if (create.to_table_id && create.to_table_id.database_name.empty())\n         create.to_table_id.database_name = current_database;\n \n@@ -949,7 +949,7 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n \n     if (need_add_to_database && database->getEngineName() == \"Replicated\")\n     {\n-        auto guard = DatabaseCatalog::instance().getDDLGuard(create.database, create.table);\n+        auto guard = DatabaseCatalog::instance().getDDLGuard(create.getDatabase(), create.getTable());\n \n         if (auto * ptr = typeid_cast<DatabaseReplicated *>(database.get());\n             ptr && !getContext()->getClientInfo().is_replicated_database_internal)\n@@ -972,7 +972,7 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n     /// If table has dependencies - add them to the graph\n     TableNamesSet loading_dependencies = getDependenciesSetFromCreateQuery(getContext()->getGlobalContext(), query_ptr);\n     if (!loading_dependencies.empty())\n-        DatabaseCatalog::instance().addLoadingDependencies(QualifiedTableName{database_name, create.table}, std::move(loading_dependencies));\n+        DatabaseCatalog::instance().addLoadingDependencies(QualifiedTableName{database_name, create.getTable()}, std::move(loading_dependencies));\n \n     return fillTableIfNeeded(create);\n }\n@@ -991,16 +991,16 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n         /** If the request specifies IF NOT EXISTS, we allow concurrent CREATE queries (which do nothing).\n           * If table doesn't exist, one thread is creating table, while others wait in DDLGuard.\n           */\n-        guard = DatabaseCatalog::instance().getDDLGuard(create.database, create.table);\n+        guard = DatabaseCatalog::instance().getDDLGuard(create.getDatabase(), create.getTable());\n \n-        database = DatabaseCatalog::instance().getDatabase(create.database);\n+        database = DatabaseCatalog::instance().getDatabase(create.getDatabase());\n         assertOrSetUUID(create, database);\n \n         String storage_name = create.is_dictionary ? \"Dictionary\" : \"Table\";\n         auto storage_already_exists_error_code = create.is_dictionary ? ErrorCodes::DICTIONARY_ALREADY_EXISTS : ErrorCodes::TABLE_ALREADY_EXISTS;\n \n         /// Table can be created before or it can be created concurrently in another thread, while we were waiting in DDLGuard.\n-        if (database->isTableExist(create.table, getContext()))\n+        if (database->isTableExist(create.getTable(), getContext()))\n         {\n             /// TODO Check structure of table\n             if (create.if_not_exists)\n@@ -1009,8 +1009,8 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n             {\n                 /// when executing CREATE OR REPLACE VIEW, drop current existing view\n                 auto drop_ast = std::make_shared<ASTDropQuery>();\n-                drop_ast->database = create.database;\n-                drop_ast->table = create.table;\n+                drop_ast->setDatabase(create.getDatabase());\n+                drop_ast->setTable(create.getTable());\n                 drop_ast->no_ddl_lock = true;\n \n                 auto drop_context = Context::createCopy(context);\n@@ -1019,7 +1019,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n             }\n             else\n                 throw Exception(storage_already_exists_error_code,\n-                    \"{} {}.{} already exists\", storage_name, backQuoteIfNeed(create.database), backQuoteIfNeed(create.table));\n+                    \"{} {}.{} already exists\", storage_name, backQuoteIfNeed(create.getDatabase()), backQuoteIfNeed(create.getTable()));\n         }\n \n         data_path = database->getTableDataPath(create);\n@@ -1030,10 +1030,10 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     }\n     else\n     {\n-        if (create.if_not_exists && getContext()->tryResolveStorageID({\"\", create.table}, Context::ResolveExternal))\n+        if (create.if_not_exists && getContext()->tryResolveStorageID({\"\", create.getTable()}, Context::ResolveExternal))\n             return false;\n \n-        String temporary_table_name = create.table;\n+        String temporary_table_name = create.getTable();\n         auto temporary_table = TemporaryTableHolder(getContext(), properties.columns, properties.constraints, query_ptr);\n         getContext()->getSessionContext()->addExternalTable(temporary_table_name, std::move(temporary_table));\n         return true;\n@@ -1070,8 +1070,8 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     {\n         const auto & factory = TableFunctionFactory::instance();\n         auto table_func = factory.get(create.as_table_function, getContext());\n-        res = table_func->execute(create.as_table_function, getContext(), create.table, properties.columns);\n-        res->renameInMemory({create.database, create.table, create.uuid});\n+        res = table_func->execute(create.as_table_function, getContext(), create.getTable(), properties.columns);\n+        res->renameInMemory({create.getDatabase(), create.getTable(), create.uuid});\n     }\n     else\n     {\n@@ -1089,12 +1089,12 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n                         \"ATTACH ... FROM ... query is not supported for {} table engine, \"\n                         \"because such tables do not store any data on disk. Use CREATE instead.\", res->getName());\n \n-    database->createTable(getContext(), create.table, res, query_ptr);\n+    database->createTable(getContext(), create.getTable(), res, query_ptr);\n \n     /// Move table data to the proper place. Wo do not move data earlier to avoid situations\n     /// when data directory moved, but table has not been created due to some error.\n     if (from_path)\n-        res->rename(actual_data_path, {create.database, create.table, create.uuid});\n+        res->rename(actual_data_path, {create.getDatabase(), create.getTable(), create.uuid});\n \n     /// We must call \"startup\" and \"shutdown\" while holding DDLGuard.\n     /// Because otherwise method \"shutdown\" (from InterpreterDropQuery) can be called before startup\n@@ -1142,30 +1142,30 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,\n     };\n \n     auto ast_drop = std::make_shared<ASTDropQuery>();\n-    String table_to_replace_name = create.table;\n+    String table_to_replace_name = create.getTable();\n \n     {\n-        auto database = DatabaseCatalog::instance().getDatabase(create.database);\n+        auto database = DatabaseCatalog::instance().getDatabase(create.getDatabase());\n         if (database->getUUID() == UUIDHelpers::Nil)\n             throw Exception(ErrorCodes::INCORRECT_QUERY,\n                             \"{} query is supported only for Atomic databases\",\n                             create.create_or_replace ? \"CREATE OR REPLACE TABLE\" : \"REPLACE TABLE\");\n \n \n-        UInt64 name_hash = sipHash64(create.database + create.table);\n+        UInt64 name_hash = sipHash64(create.getDatabase() + create.getTable());\n         UInt16 random_suffix = thread_local_rng();\n         if (auto txn = current_context->getZooKeeperMetadataTransaction())\n         {\n             /// Avoid different table name on database replicas\n             random_suffix = sipHash64(txn->getTaskZooKeeperPath());\n         }\n-        create.table = fmt::format(\"_tmp_replace_{}_{}\",\n-                                   getHexUIntLowercase(name_hash),\n-                                   getHexUIntLowercase(random_suffix));\n+        create.setTable(fmt::format(\"_tmp_replace_{}_{}\",\n+                            getHexUIntLowercase(name_hash),\n+                            getHexUIntLowercase(random_suffix)));\n \n-        ast_drop->table = create.table;\n+        ast_drop->setTable(create.getTable());\n         ast_drop->is_dictionary = create.is_dictionary;\n-        ast_drop->database = create.database;\n+        ast_drop->setDatabase(create.getDatabase());\n         ast_drop->kind = ASTDropQuery::Drop;\n     }\n \n@@ -1186,8 +1186,8 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,\n         auto ast_rename = std::make_shared<ASTRenameQuery>();\n         ASTRenameQuery::Element elem\n         {\n-            ASTRenameQuery::Table{create.database, create.table},\n-            ASTRenameQuery::Table{create.database, table_to_replace_name}\n+            ASTRenameQuery::Table{create.getDatabase(), create.getTable()},\n+            ASTRenameQuery::Table{create.getDatabase(), table_to_replace_name}\n         };\n \n         ast_rename->elements.push_back(std::move(elem));\n@@ -1217,7 +1217,7 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,\n             InterpreterDropQuery(ast_drop, drop_context).execute();\n         }\n \n-        create.table = table_to_replace_name;\n+        create.setTable(table_to_replace_name);\n \n         return {};\n     }\n@@ -1240,7 +1240,7 @@ BlockIO InterpreterCreateQuery::fillTableIfNeeded(const ASTCreateQuery & create)\n         && !create.is_ordinary_view && !create.is_live_view && (!create.is_materialized_view || create.is_populate))\n     {\n         auto insert = std::make_shared<ASTInsertQuery>();\n-        insert->table_id = {create.database, create.table, create.uuid};\n+        insert->table_id = {create.getDatabase(), create.getTable(), create.uuid};\n         insert->select = create.select->clone();\n \n         if (create.temporary && !getContext()->getSessionContext()->hasQueryContext())\n@@ -1316,7 +1316,7 @@ BlockIO InterpreterCreateQuery::execute()\n     ASTQueryWithOutput::resetOutputASTIfExist(create);\n \n     /// CREATE|ATTACH DATABASE\n-    if (!create.database.empty() && create.table.empty())\n+    if (create.database && !create.table)\n         return createDatabase(create);\n     else\n         return createTable(create);\n@@ -1332,21 +1332,21 @@ AccessRightsElements InterpreterCreateQuery::getRequiredAccess() const\n     AccessRightsElements required_access;\n     const auto & create = query_ptr->as<const ASTCreateQuery &>();\n \n-    if (create.table.empty())\n+    if (!create.table)\n     {\n-        required_access.emplace_back(AccessType::CREATE_DATABASE, create.database);\n+        required_access.emplace_back(AccessType::CREATE_DATABASE, create.getDatabase());\n     }\n     else if (create.is_dictionary)\n     {\n-        required_access.emplace_back(AccessType::CREATE_DICTIONARY, create.database, create.table);\n+        required_access.emplace_back(AccessType::CREATE_DICTIONARY, create.getDatabase(), create.getTable());\n     }\n     else if (create.isView())\n     {\n         assert(!create.temporary);\n         if (create.replace_view)\n-            required_access.emplace_back(AccessType::DROP_VIEW | AccessType::CREATE_VIEW, create.database, create.table);\n+            required_access.emplace_back(AccessType::DROP_VIEW | AccessType::CREATE_VIEW, create.getDatabase(), create.getTable());\n         else\n-            required_access.emplace_back(AccessType::CREATE_VIEW, create.database, create.table);\n+            required_access.emplace_back(AccessType::CREATE_VIEW, create.getDatabase(), create.getTable());\n     }\n     else\n     {\n@@ -1355,8 +1355,8 @@ AccessRightsElements InterpreterCreateQuery::getRequiredAccess() const\n         else\n         {\n             if (create.replace_table)\n-                required_access.emplace_back(AccessType::DROP_TABLE, create.database, create.table);\n-            required_access.emplace_back(AccessType::CREATE_TABLE, create.database, create.table);\n+                required_access.emplace_back(AccessType::DROP_TABLE, create.getDatabase(), create.getTable());\n+            required_access.emplace_back(AccessType::CREATE_TABLE, create.getDatabase(), create.getTable());\n         }\n     }\n \ndiff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp\nindex 03ec34fb6be0..ce54ecc529ad 100644\n--- a/src/Interpreters/InterpreterDropQuery.cpp\n+++ b/src/Interpreters/InterpreterDropQuery.cpp\n@@ -56,9 +56,9 @@ BlockIO InterpreterDropQuery::execute()\n     if (getContext()->getSettingsRef().database_atomic_wait_for_drop_and_detach_synchronously)\n         drop.no_delay = true;\n \n-    if (!drop.table.empty())\n+    if (drop.table)\n         return executeToTable(drop);\n-    else if (!drop.database.empty())\n+    else if (drop.database)\n         return executeToDatabase(drop);\n     else\n         throw Exception(\"Nothing to drop, both names are empty\", ErrorCodes::LOGICAL_ERROR);\n@@ -95,7 +95,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ASTDropQuery & query, DatabaseP\n         if (getContext()->tryResolveStorageID(table_id, Context::ResolveExternal))\n             return executeToTemporaryTable(table_id.getTableName(), query.kind);\n         else\n-            query.database = table_id.database_name = getContext()->getCurrentDatabase();\n+            query.setDatabase(table_id.database_name = getContext()->getCurrentDatabase());\n     }\n \n     if (query.temporary)\n@@ -130,7 +130,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ASTDropQuery & query, DatabaseP\n         table_id.uuid = database->tryGetTableUUID(table_id.table_name);\n \n         /// Prevents recursive drop from drop database query. The original query must specify a table.\n-        bool is_drop_or_detach_database = query_ptr->as<ASTDropQuery>()->table.empty();\n+        bool is_drop_or_detach_database = !query_ptr->as<ASTDropQuery>()->table;\n         bool is_replicated_ddl_query = typeid_cast<DatabaseReplicated *>(database.get()) &&\n                                        !getContext()->getClientInfo().is_replicated_database_internal &&\n                                        !is_drop_or_detach_database;\n@@ -302,7 +302,7 @@ BlockIO InterpreterDropQuery::executeToDatabase(const ASTDropQuery & query)\n \n BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query, DatabasePtr & database, std::vector<UUID> & uuids_to_wait)\n {\n-    const auto & database_name = query.database;\n+    const auto & database_name = query.getDatabase();\n     auto ddl_guard = DatabaseCatalog::instance().getDDLGuard(database_name, \"\");\n \n     database = tryGetDatabase(database_name, query.if_exists);\n@@ -336,7 +336,7 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,\n                 ASTDropQuery query_for_table;\n                 query_for_table.kind = query.kind;\n                 query_for_table.if_exists = true;\n-                query_for_table.database = database_name;\n+                query_for_table.setDatabase(database_name);\n                 query_for_table.no_delay = query.no_delay;\n \n                 /// Flush should not be done if shouldBeEmptyOnDetach() == false,\n@@ -351,7 +351,7 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,\n                 {\n                     DatabasePtr db;\n                     UUID table_to_wait = UUIDHelpers::Nil;\n-                    query_for_table.table = iterator->name();\n+                    query_for_table.setTable(iterator->name());\n                     query_for_table.is_dictionary = iterator->table()->isDictionary();\n                     executeToTableImpl(query_for_table, db, table_to_wait);\n                     uuids_to_wait.push_back(table_to_wait);\n@@ -385,29 +385,29 @@ AccessRightsElements InterpreterDropQuery::getRequiredAccessForDDLOnCluster() co\n     AccessRightsElements required_access;\n     const auto & drop = query_ptr->as<const ASTDropQuery &>();\n \n-    if (drop.table.empty())\n+    if (!drop.table)\n     {\n         if (drop.kind == ASTDropQuery::Kind::Detach)\n-            required_access.emplace_back(AccessType::DROP_DATABASE, drop.database);\n+            required_access.emplace_back(AccessType::DROP_DATABASE, drop.getDatabase());\n         else if (drop.kind == ASTDropQuery::Kind::Drop)\n-            required_access.emplace_back(AccessType::DROP_DATABASE, drop.database);\n+            required_access.emplace_back(AccessType::DROP_DATABASE, drop.getDatabase());\n     }\n     else if (drop.is_dictionary)\n     {\n         if (drop.kind == ASTDropQuery::Kind::Detach)\n-            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.database, drop.table);\n+            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.getDatabase(), drop.getTable());\n         else if (drop.kind == ASTDropQuery::Kind::Drop)\n-            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.database, drop.table);\n+            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.getDatabase(), drop.getTable());\n     }\n     else if (!drop.temporary)\n     {\n         /// It can be view or table.\n         if (drop.kind == ASTDropQuery::Kind::Drop)\n-            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.database, drop.table);\n+            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.getDatabase(), drop.getTable());\n         else if (drop.kind == ASTDropQuery::Kind::Truncate)\n-            required_access.emplace_back(AccessType::TRUNCATE, drop.database, drop.table);\n+            required_access.emplace_back(AccessType::TRUNCATE, drop.getDatabase(), drop.getTable());\n         else if (drop.kind == ASTDropQuery::Kind::Detach)\n-            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.database, drop.table);\n+            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.getDatabase(), drop.getTable());\n     }\n \n     return required_access;\n@@ -424,8 +424,8 @@ void InterpreterDropQuery::executeDropQuery(ASTDropQuery::Kind kind, ContextPtr\n     {\n         /// We create and execute `drop` query for internal table.\n         auto drop_query = std::make_shared<ASTDropQuery>();\n-        drop_query->database = target_table_id.database_name;\n-        drop_query->table = target_table_id.table_name;\n+        drop_query->setDatabase(target_table_id.database_name);\n+        drop_query->setTable(target_table_id.table_name);\n         drop_query->kind = kind;\n         drop_query->no_delay = no_delay;\n         drop_query->if_exists = true;\ndiff --git a/src/Interpreters/InterpreterExistsQuery.cpp b/src/Interpreters/InterpreterExistsQuery.cpp\nindex 5af51c61b295..758c6d814073 100644\n--- a/src/Interpreters/InterpreterExistsQuery.cpp\n+++ b/src/Interpreters/InterpreterExistsQuery.cpp\n@@ -44,25 +44,25 @@ QueryPipeline InterpreterExistsQuery::executeImpl()\n         if (exists_query->temporary)\n         {\n             result = static_cast<bool>(getContext()->tryResolveStorageID(\n-                {\"\", exists_query->table}, Context::ResolveExternal));\n+                {\"\", exists_query->getTable()}, Context::ResolveExternal));\n         }\n         else\n         {\n-            String database = getContext()->resolveDatabase(exists_query->database);\n-            getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->table);\n-            result = DatabaseCatalog::instance().isTableExist({database, exists_query->table}, getContext());\n+            String database = getContext()->resolveDatabase(exists_query->getDatabase());\n+            getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->getTable());\n+            result = DatabaseCatalog::instance().isTableExist({database, exists_query->getTable()}, getContext());\n         }\n     }\n     else if ((exists_query = query_ptr->as<ASTExistsViewQuery>()))\n     {\n-        String database = getContext()->resolveDatabase(exists_query->database);\n-        getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->table);\n-        auto table = DatabaseCatalog::instance().tryGetTable({database, exists_query->table}, getContext());\n+        String database = getContext()->resolveDatabase(exists_query->getDatabase());\n+        getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->getTable());\n+        auto table = DatabaseCatalog::instance().tryGetTable({database, exists_query->getTable()}, getContext());\n         result = table && table->isView();\n     }\n     else if ((exists_query = query_ptr->as<ASTExistsDatabaseQuery>()))\n     {\n-        String database = getContext()->resolveDatabase(exists_query->database);\n+        String database = getContext()->resolveDatabase(exists_query->getDatabase());\n         getContext()->checkAccess(AccessType::SHOW_DATABASES, database);\n         result = DatabaseCatalog::instance().isDatabaseExist(database);\n     }\n@@ -70,9 +70,9 @@ QueryPipeline InterpreterExistsQuery::executeImpl()\n     {\n         if (exists_query->temporary)\n             throw Exception(\"Temporary dictionaries are not possible.\", ErrorCodes::SYNTAX_ERROR);\n-        String database = getContext()->resolveDatabase(exists_query->database);\n-        getContext()->checkAccess(AccessType::SHOW_DICTIONARIES, database, exists_query->table);\n-        result = DatabaseCatalog::instance().isDictionaryExist({database, exists_query->table});\n+        String database = getContext()->resolveDatabase(exists_query->getDatabase());\n+        getContext()->checkAccess(AccessType::SHOW_DICTIONARIES, database, exists_query->getTable());\n+        result = DatabaseCatalog::instance().isDictionaryExist({database, exists_query->getTable()});\n     }\n \n     return QueryPipeline(std::make_shared<SourceFromSingleChunk>(Block{{\ndiff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex 231eb15b02fe..99b68897549e 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -62,7 +62,18 @@ StoragePtr InterpreterInsertQuery::getTable(ASTInsertQuery & query)\n         return table_function_ptr->execute(query.table_function, getContext(), table_function_ptr->getName());\n     }\n \n-    query.table_id = getContext()->resolveStorageID(query.table_id);\n+    if (query.table_id)\n+    {\n+        query.table_id = getContext()->resolveStorageID(query.table_id);\n+    }\n+    else\n+    {\n+        /// Insert query parser does not fill table_id because table and\n+        /// database can be parameters and be filled after parsing.\n+        StorageID local_table_id(query.getDatabase(), query.getTable());\n+        query.table_id = getContext()->resolveStorageID(local_table_id);\n+    }\n+\n     return DatabaseCatalog::instance().getTable(query.table_id, getContext());\n }\n \ndiff --git a/src/Interpreters/InterpreterOptimizeQuery.cpp b/src/Interpreters/InterpreterOptimizeQuery.cpp\nindex a44a49ec0201..f9a701a0a77d 100644\n--- a/src/Interpreters/InterpreterOptimizeQuery.cpp\n+++ b/src/Interpreters/InterpreterOptimizeQuery.cpp\n@@ -79,7 +79,7 @@ AccessRightsElements InterpreterOptimizeQuery::getRequiredAccess() const\n {\n     const auto & optimize = query_ptr->as<const ASTOptimizeQuery &>();\n     AccessRightsElements required_access;\n-    required_access.emplace_back(AccessType::OPTIMIZE, optimize.database, optimize.table);\n+    required_access.emplace_back(AccessType::OPTIMIZE, optimize.getDatabase(), optimize.getTable());\n     return required_access;\n }\n \ndiff --git a/src/Interpreters/InterpreterShowCreateQuery.cpp b/src/Interpreters/InterpreterShowCreateQuery.cpp\nindex 84dbae0fac50..6ae51c1ff235 100644\n--- a/src/Interpreters/InterpreterShowCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterShowCreateQuery.cpp\n@@ -64,26 +64,26 @@ QueryPipeline InterpreterShowCreateQuery::executeImpl()\n         {\n             if (!ast_create_query.isView())\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{}.{} is not a VIEW\",\n-                    backQuote(ast_create_query.database), backQuote(ast_create_query.table));\n+                    backQuote(ast_create_query.getDatabase()), backQuote(ast_create_query.getTable()));\n         }\n         else if (is_dictionary)\n         {\n             if (!ast_create_query.is_dictionary)\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{}.{} is not a DICTIONARY\",\n-                    backQuote(ast_create_query.database), backQuote(ast_create_query.table));\n+                    backQuote(ast_create_query.getDatabase()), backQuote(ast_create_query.getTable()));\n         }\n     }\n     else if ((show_query = query_ptr->as<ASTShowCreateDatabaseQuery>()))\n     {\n         if (show_query->temporary)\n             throw Exception(\"Temporary databases are not possible.\", ErrorCodes::SYNTAX_ERROR);\n-        show_query->database = getContext()->resolveDatabase(show_query->database);\n-        getContext()->checkAccess(AccessType::SHOW_DATABASES, show_query->database);\n-        create_query = DatabaseCatalog::instance().getDatabase(show_query->database)->getCreateDatabaseQuery();\n+        show_query->setDatabase(getContext()->resolveDatabase(show_query->getDatabase()));\n+        getContext()->checkAccess(AccessType::SHOW_DATABASES, show_query->getDatabase());\n+        create_query = DatabaseCatalog::instance().getDatabase(show_query->getDatabase())->getCreateDatabaseQuery();\n     }\n \n     if (!create_query)\n-        throw Exception(\"Unable to show the create query of \" + show_query->table + \". Maybe it was created by the system.\", ErrorCodes::THERE_IS_NO_QUERY);\n+        throw Exception(\"Unable to show the create query of \" + show_query->getTable() + \". Maybe it was created by the system.\", ErrorCodes::THERE_IS_NO_QUERY);\n \n     if (!getContext()->getSettingsRef().show_table_uuid_in_table_create_query_if_not_nil)\n     {\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 69bf036ae97b..1610ae56280b 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -217,12 +217,12 @@ BlockIO InterpreterSystemQuery::execute()\n     /// Make canonical query for simpler processing\n     if (query.type == Type::RELOAD_DICTIONARY)\n     {\n-        if (!query.database.empty())\n-            query.table = query.database + \".\" + query.table;\n+        if (query.database)\n+            query.setTable(query.getDatabase() + \".\" + query.getTable());\n     }\n-    else if (!query.table.empty())\n+    else if (query.table)\n     {\n-        table_id = getContext()->resolveStorageID(StorageID(query.database, query.table), Context::ResolveOrdinary);\n+        table_id = getContext()->resolveStorageID(StorageID(query.getDatabase(), query.getTable()), Context::ResolveOrdinary);\n     }\n \n \n@@ -302,7 +302,7 @@ BlockIO InterpreterSystemQuery::execute()\n             getContext()->checkAccess(AccessType::SYSTEM_RELOAD_DICTIONARY);\n \n             auto & external_dictionaries_loader = system_context->getExternalDictionariesLoader();\n-            external_dictionaries_loader.reloadDictionary(query.table, getContext());\n+            external_dictionaries_loader.reloadDictionary(query.getTable(), getContext());\n \n             ExternalDictionariesLoader::resetAll();\n             break;\n@@ -594,10 +594,10 @@ void InterpreterSystemQuery::dropReplica(ASTSystemQuery & query)\n         if (!dropReplicaImpl(query, table))\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, table_is_not_replicated.data(), table_id.getNameForLogs());\n     }\n-    else if (!query.database.empty())\n+    else if (query.database)\n     {\n-        getContext()->checkAccess(AccessType::SYSTEM_DROP_REPLICA, query.database);\n-        DatabasePtr database = DatabaseCatalog::instance().getDatabase(query.database);\n+        getContext()->checkAccess(AccessType::SYSTEM_DROP_REPLICA, query.getDatabase());\n+        DatabasePtr database = DatabaseCatalog::instance().getDatabase(query.getDatabase());\n         for (auto iterator = database->getTablesIterator(getContext()); iterator->isValid(); iterator->next())\n             dropReplicaImpl(query, iterator->table());\n         LOG_TRACE(log, \"Dropped replica {} from database {}\", query.replica, backQuoteIfNeed(database->getDatabaseName()));\n@@ -790,84 +790,84 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()\n         case Type::STOP_MERGES: [[fallthrough]];\n         case Type::START_MERGES:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_MERGES);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_MERGES, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_MERGES, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::STOP_TTL_MERGES: [[fallthrough]];\n         case Type::START_TTL_MERGES:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_TTL_MERGES);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_TTL_MERGES, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_TTL_MERGES, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::STOP_MOVES: [[fallthrough]];\n         case Type::START_MOVES:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_MOVES);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_MOVES, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_MOVES, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::STOP_FETCHES: [[fallthrough]];\n         case Type::START_FETCHES:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_FETCHES);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_FETCHES, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_FETCHES, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::STOP_DISTRIBUTED_SENDS: [[fallthrough]];\n         case Type::START_DISTRIBUTED_SENDS:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_DISTRIBUTED_SENDS);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_DISTRIBUTED_SENDS, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_DISTRIBUTED_SENDS, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::STOP_REPLICATED_SENDS: [[fallthrough]];\n         case Type::START_REPLICATED_SENDS:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_REPLICATED_SENDS);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_REPLICATED_SENDS, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_REPLICATED_SENDS, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::STOP_REPLICATION_QUEUES: [[fallthrough]];\n         case Type::START_REPLICATION_QUEUES:\n         {\n-            if (query.table.empty())\n+            if (!query.table)\n                 required_access.emplace_back(AccessType::SYSTEM_REPLICATION_QUEUES);\n             else\n-                required_access.emplace_back(AccessType::SYSTEM_REPLICATION_QUEUES, query.database, query.table);\n+                required_access.emplace_back(AccessType::SYSTEM_REPLICATION_QUEUES, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::DROP_REPLICA:\n         {\n-            required_access.emplace_back(AccessType::SYSTEM_DROP_REPLICA, query.database, query.table);\n+            required_access.emplace_back(AccessType::SYSTEM_DROP_REPLICA, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::RESTORE_REPLICA:\n         {\n-            required_access.emplace_back(AccessType::SYSTEM_RESTORE_REPLICA, query.database, query.table);\n+            required_access.emplace_back(AccessType::SYSTEM_RESTORE_REPLICA, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::SYNC_REPLICA:\n         {\n-            required_access.emplace_back(AccessType::SYSTEM_SYNC_REPLICA, query.database, query.table);\n+            required_access.emplace_back(AccessType::SYSTEM_SYNC_REPLICA, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::RESTART_REPLICA:\n         {\n-            required_access.emplace_back(AccessType::SYSTEM_RESTART_REPLICA, query.database, query.table);\n+            required_access.emplace_back(AccessType::SYSTEM_RESTART_REPLICA, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::RESTART_REPLICAS:\n@@ -877,7 +877,7 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()\n         }\n         case Type::FLUSH_DISTRIBUTED:\n         {\n-            required_access.emplace_back(AccessType::SYSTEM_FLUSH_DISTRIBUTED, query.database, query.table);\n+            required_access.emplace_back(AccessType::SYSTEM_FLUSH_DISTRIBUTED, query.getDatabase(), query.getTable());\n             break;\n         }\n         case Type::FLUSH_LOGS:\ndiff --git a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\nindex 187c3dd01915..54b87e3bed6e 100644\n--- a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\n+++ b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp\n@@ -449,8 +449,8 @@ ASTs InterpreterCreateImpl::getRewrittenQueries(\n         String table_name = table_like->shortName();\n         ASTPtr rewritten_create_ast = DatabaseCatalog::instance().getDatabase(mapped_to_database)->getCreateTableQuery(table_name, context);\n         auto * create_ptr = rewritten_create_ast->as<ASTCreateQuery>();\n-        create_ptr->database = mapped_to_database;\n-        create_ptr->table = create_query.table;\n+        create_ptr->setDatabase(mapped_to_database);\n+        create_ptr->setTable(create_query.table);\n         create_ptr->uuid = UUIDHelpers::generateV4();\n         create_ptr->if_not_exists = create_query.if_not_exists;\n         return ASTs{rewritten_create_ast};\n@@ -513,8 +513,8 @@ ASTs InterpreterCreateImpl::getRewrittenQueries(\n \n     storage->set(storage->engine, makeASTFunction(\"ReplacingMergeTree\", std::make_shared<ASTIdentifier>(version_column_name)));\n \n-    rewritten_query->database = mapped_to_database;\n-    rewritten_query->table = create_query.table;\n+    rewritten_query->setDatabase(mapped_to_database);\n+    rewritten_query->setTable(create_query.table);\n     rewritten_query->if_not_exists = create_query.if_not_exists;\n     rewritten_query->set(rewritten_query->storage, storage);\n     rewritten_query->set(rewritten_query->columns_list, columns);\n@@ -529,14 +529,14 @@ void InterpreterDropImpl::validate(const InterpreterDropImpl::TQuery & /*query*/\n ASTs InterpreterDropImpl::getRewrittenQueries(\n     const InterpreterDropImpl::TQuery & drop_query, ContextPtr context, const String & mapped_to_database, const String & mysql_database)\n {\n-    const auto & database_name = resolveDatabase(drop_query.database, mysql_database, mapped_to_database, context);\n+    const auto & database_name = resolveDatabase(drop_query.getDatabase(), mysql_database, mapped_to_database, context);\n \n     /// Skip drop database|view|dictionary\n-    if (database_name != mapped_to_database || drop_query.table.empty() || drop_query.is_view || drop_query.is_dictionary)\n+    if (database_name != mapped_to_database || !drop_query.table || drop_query.is_view || drop_query.is_dictionary)\n         return {};\n \n     ASTPtr rewritten_query = drop_query.clone();\n-    rewritten_query->as<ASTDropQuery>()->database = mapped_to_database;\n+    rewritten_query->as<ASTDropQuery>()->setDatabase(mapped_to_database);\n     return ASTs{rewritten_query};\n }\n \n@@ -588,8 +588,8 @@ ASTs InterpreterAlterImpl::getRewrittenQueries(\n \n     auto rewritten_alter_query = std::make_shared<ASTAlterQuery>();\n     auto rewritten_rename_query = std::make_shared<ASTRenameQuery>();\n-    rewritten_alter_query->database = mapped_to_database;\n-    rewritten_alter_query->table = alter_query.table;\n+    rewritten_alter_query->setDatabase(mapped_to_database);\n+    rewritten_alter_query->setTable(alter_query.table);\n     rewritten_alter_query->alter_object = ASTAlterQuery::AlterObjectType::TABLE;\n     rewritten_alter_query->set(rewritten_alter_query->command_list, std::make_shared<ASTExpressionList>());\n \ndiff --git a/src/Interpreters/StorageID.cpp b/src/Interpreters/StorageID.cpp\nindex 2e76618e4c0d..8811adc087bd 100644\n--- a/src/Interpreters/StorageID.cpp\n+++ b/src/Interpreters/StorageID.cpp\n@@ -18,8 +18,8 @@ namespace ErrorCodes\n \n StorageID::StorageID(const ASTQueryWithTableAndOutput & query)\n {\n-    database_name = query.database;\n-    table_name = query.table;\n+    database_name = query.getDatabase();\n+    table_name = query.getTable();\n     uuid = query.uuid;\n     assertNotEmpty();\n }\ndiff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h\nindex ce0062e8c77f..ee3e3062e137 100644\n--- a/src/Interpreters/SystemLog.h\n+++ b/src/Interpreters/SystemLog.h\n@@ -595,8 +595,8 @@ ASTPtr SystemLog<LogElement>::getCreateTableQuery()\n {\n     auto create = std::make_shared<ASTCreateQuery>();\n \n-    create->database = table_id.database_name;\n-    create->table = table_id.table_name;\n+    create->setDatabase(table_id.database_name);\n+    create->setTable(table_id.table_name);\n \n     auto ordinary_columns = LogElement::getNamesAndTypes();\n     auto alias_columns = LogElement::getNamesAndAliases();\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex f401f708ab14..f67eac108785 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -431,12 +431,6 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 InterpreterSetQuery(query_with_output->settings_ast, context).executeForCurrentContext();\n         }\n \n-        if (const auto * query_with_table_output = dynamic_cast<const ASTQueryWithTableAndOutput *>(ast.get()))\n-        {\n-            query_database = query_with_table_output->database;\n-            query_table = query_with_table_output->table;\n-        }\n-\n         if (auto * create_query = ast->as<ASTCreateQuery>())\n         {\n             if (create_query->select)\n@@ -510,6 +504,12 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             query = serializeAST(*ast);\n         }\n \n+        if (const auto * query_with_table_output = dynamic_cast<const ASTQueryWithTableAndOutput *>(ast.get()))\n+        {\n+            query_database = query_with_table_output->getDatabase();\n+            query_table = query_with_table_output->getTable();\n+        }\n+\n         /// MUST go before any modification (except for prepared statements,\n         /// since it substitute parameters and w/o them query does not contain\n         /// parameters), to keep query as-is in query_log and server log.\ndiff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp\nindex 96f94b965294..c5bef6f72055 100644\n--- a/src/Interpreters/loadMetadata.cpp\n+++ b/src/Interpreters/loadMetadata.cpp\n@@ -39,7 +39,7 @@ static void executeCreateQuery(\n         parser, query.data(), query.data() + query.size(), \"in file \" + file_name, 0, context->getSettingsRef().max_parser_depth);\n \n     auto & ast_create_query = ast->as<ASTCreateQuery &>();\n-    ast_create_query.database = database;\n+    ast_create_query.setDatabase(database);\n \n     InterpreterCreateQuery interpreter(ast, context);\n     interpreter.setInternal(true);\ndiff --git a/src/Parsers/ASTAlterQuery.cpp b/src/Parsers/ASTAlterQuery.cpp\nindex 50c56c9aeff6..2ae494854ec7 100644\n--- a/src/Parsers/ASTAlterQuery.cpp\n+++ b/src/Parsers/ASTAlterQuery.cpp\n@@ -485,7 +485,7 @@ bool ASTAlterQuery::isDropPartitionAlter() const\n /** Get the text that identifies this element. */\n String ASTAlterQuery::getID(char delim) const\n {\n-    return \"AlterQuery\" + (delim + database) + delim + table;\n+    return \"AlterQuery\" + (delim + getDatabase()) + delim + getTable();\n }\n \n ASTPtr ASTAlterQuery::clone() const\n@@ -523,18 +523,18 @@ void ASTAlterQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n \n     settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n-    if (!table.empty())\n+    if (table)\n     {\n-        if (!database.empty())\n+        if (database)\n         {\n-            settings.ostr << indent_str << backQuoteIfNeed(database);\n+            settings.ostr << indent_str << backQuoteIfNeed(getDatabase());\n             settings.ostr << \".\";\n         }\n-        settings.ostr << indent_str << backQuoteIfNeed(table);\n+        settings.ostr << indent_str << backQuoteIfNeed(getTable());\n     }\n-    else if (alter_object == AlterObjectType::DATABASE && !database.empty())\n+    else if (alter_object == AlterObjectType::DATABASE && database)\n     {\n-        settings.ostr << indent_str << backQuoteIfNeed(database);\n+        settings.ostr << indent_str << backQuoteIfNeed(getDatabase());\n     }\n \n     formatOnCluster(settings);\ndiff --git a/src/Parsers/ASTCheckQuery.h b/src/Parsers/ASTCheckQuery.h\nindex fdd1179ec905..8b376ef8d600 100644\n--- a/src/Parsers/ASTCheckQuery.h\n+++ b/src/Parsers/ASTCheckQuery.h\n@@ -12,13 +12,14 @@ struct ASTCheckQuery : public ASTQueryWithTableAndOutput\n     ASTPtr partition;\n \n     /** Get the text that identifies this element. */\n-    String getID(char delim) const override { return \"CheckQuery\" + (delim + database) + delim + table; }\n+    String getID(char delim) const override { return \"CheckQuery\" + (delim + getDatabase()) + delim + getTable(); }\n \n     ASTPtr clone() const override\n     {\n         auto res = std::make_shared<ASTCheckQuery>(*this);\n         res->children.clear();\n         cloneOutputOptions(*res);\n+        cloneTableOptions(*res);\n         return res;\n     }\n \n@@ -32,14 +33,14 @@ struct ASTCheckQuery : public ASTQueryWithTableAndOutput\n \n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << \"CHECK TABLE \" << (settings.hilite ? hilite_none : \"\");\n \n-        if (!table.empty())\n+        if (table)\n         {\n-            if (!database.empty())\n+            if (database)\n             {\n-                settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << backQuoteIfNeed(database) << (settings.hilite ? hilite_none : \"\");\n+                settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << backQuoteIfNeed(getDatabase()) << (settings.hilite ? hilite_none : \"\");\n                 settings.ostr << \".\";\n             }\n-            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << backQuoteIfNeed(table) << (settings.hilite ? hilite_none : \"\");\n+            settings.ostr << (settings.hilite ? hilite_keyword : \"\") << indent_str << backQuoteIfNeed(getTable()) << (settings.hilite ? hilite_none : \"\");\n         }\n \n         if (partition)\ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex 2c0488862475..608098b8d953 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -212,6 +212,7 @@ ASTPtr ASTCreateQuery::clone() const\n         res->set(res->comment, comment->clone());\n \n     cloneOutputOptions(*res);\n+    cloneTableOptions(*res);\n \n     return res;\n }\n@@ -220,13 +221,13 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n {\n     frame.need_parens = false;\n \n-    if (!database.empty() && table.empty())\n+    if (database && !table)\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\")\n             << (attach ? \"ATTACH DATABASE \" : \"CREATE DATABASE \")\n             << (if_not_exists ? \"IF NOT EXISTS \" : \"\")\n             << (settings.hilite ? hilite_none : \"\")\n-            << backQuoteIfNeed(database);\n+            << backQuoteIfNeed(getDatabase());\n \n         if (uuid != UUIDHelpers::Nil)\n         {\n@@ -275,7 +276,7 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n                 << what << \" \"\n                 << (if_not_exists ? \"IF NOT EXISTS \" : \"\")\n             << (settings.hilite ? hilite_none : \"\")\n-            << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+            << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n \n         if (uuid != UUIDHelpers::Nil)\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" UUID \" << (settings.hilite ? hilite_none : \"\")\n@@ -316,7 +317,7 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n         /// Always DICTIONARY\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << action << \" DICTIONARY \"\n                       << (if_not_exists ? \"IF NOT EXISTS \" : \"\") << (settings.hilite ? hilite_none : \"\")\n-                      << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+                      << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n         if (uuid != UUIDHelpers::Nil)\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" UUID \" << (settings.hilite ? hilite_none : \"\")\n                           << quoteString(toString(uuid));\ndiff --git a/src/Parsers/ASTCreateQuery.h b/src/Parsers/ASTCreateQuery.h\nindex 51c4ac15e67a..4c7768517b13 100644\n--- a/src/Parsers/ASTCreateQuery.h\n+++ b/src/Parsers/ASTCreateQuery.h\n@@ -91,7 +91,7 @@ class ASTCreateQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnC\n     bool create_or_replace{false};\n \n     /** Get the text that identifies this element. */\n-    String getID(char delim) const override { return (attach ? \"AttachQuery\" : \"CreateQuery\") + (delim + database) + delim + table; }\n+    String getID(char delim) const override { return (attach ? \"AttachQuery\" : \"CreateQuery\") + (delim + getDatabase()) + delim + getTable(); }\n \n     ASTPtr clone() const override;\n \ndiff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp\nindex 6ea6c81c3be8..9e815ee75deb 100644\n--- a/src/Parsers/ASTDropQuery.cpp\n+++ b/src/Parsers/ASTDropQuery.cpp\n@@ -15,11 +15,11 @@ namespace ErrorCodes\n String ASTDropQuery::getID(char delim) const\n {\n     if (kind == ASTDropQuery::Kind::Drop)\n-        return \"DropQuery\" + (delim + database) + delim + table;\n+        return \"DropQuery\" + (delim + getDatabase()) + delim + getTable();\n     else if (kind == ASTDropQuery::Kind::Detach)\n-        return \"DetachQuery\" + (delim + database) + delim + table;\n+        return \"DetachQuery\" + (delim + getDatabase()) + delim + getTable();\n     else if (kind == ASTDropQuery::Kind::Truncate)\n-        return \"TruncateQuery\" + (delim + database) + delim + table;\n+        return \"TruncateQuery\" + (delim + getDatabase()) + delim + getTable();\n     else\n         throw Exception(\"Not supported kind of drop query.\", ErrorCodes::SYNTAX_ERROR);\n }\n@@ -28,6 +28,7 @@ ASTPtr ASTDropQuery::clone() const\n {\n     auto res = std::make_shared<ASTDropQuery>(*this);\n     cloneOutputOptions(*res);\n+    cloneTableOptions(*res);\n     return res;\n }\n \n@@ -46,7 +47,8 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n     if (temporary)\n         settings.ostr << \"TEMPORARY \";\n \n-    if (table.empty() && !database.empty())\n+\n+    if (!table && database)\n         settings.ostr << \"DATABASE \";\n     else if (is_dictionary)\n         settings.ostr << \"DICTIONARY \";\n@@ -60,10 +62,10 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState\n \n     settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n-    if (table.empty() && !database.empty())\n-        settings.ostr << backQuoteIfNeed(database);\n+    if (!table && database)\n+        settings.ostr << backQuoteIfNeed(getDatabase());\n     else\n-        settings.ostr << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+        settings.ostr << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n \n     formatOnCluster(settings);\n \ndiff --git a/src/Parsers/ASTIdentifier.cpp b/src/Parsers/ASTIdentifier.cpp\nindex 58052b1419bb..a889680c81ff 100644\n--- a/src/Parsers/ASTIdentifier.cpp\n+++ b/src/Parsers/ASTIdentifier.cpp\n@@ -201,6 +201,40 @@ String ASTTableIdentifier::getDatabaseName() const\n     else return {};\n }\n \n+ASTPtr ASTTableIdentifier::getTable() const\n+{\n+    if (name_parts.size() == 2)\n+    {\n+        if (!name_parts[1].empty())\n+            return std::make_shared<ASTIdentifier>(name_parts[1]);\n+\n+        if (name_parts[0].empty())\n+            return std::make_shared<ASTIdentifier>(\"\", children[1]->clone());\n+        else\n+            return std::make_shared<ASTIdentifier>(\"\", children[0]->clone());\n+    }\n+    else if (name_parts.size() == 1)\n+    {\n+        if (name_parts[0].empty())\n+            return std::make_shared<ASTIdentifier>(\"\", children[0]->clone());\n+        else\n+            return std::make_shared<ASTIdentifier>(name_parts[0]);\n+    }\n+    else return {};\n+}\n+\n+ASTPtr ASTTableIdentifier::getDatabase() const\n+{\n+    if (name_parts.size() == 2)\n+    {\n+        if (name_parts[0].empty())\n+            return std::make_shared<ASTIdentifier>(\"\", children[0]->clone());\n+        else\n+            return std::make_shared<ASTIdentifier>(name_parts[0]);\n+    }\n+    else return {};\n+}\n+\n void ASTTableIdentifier::resetTable(const String & database_name, const String & table_name)\n {\n     auto identifier = std::make_shared<ASTTableIdentifier>(database_name, table_name);\ndiff --git a/src/Parsers/ASTIdentifier.h b/src/Parsers/ASTIdentifier.h\nindex 323280e07bc1..048b32e438dc 100644\n--- a/src/Parsers/ASTIdentifier.h\n+++ b/src/Parsers/ASTIdentifier.h\n@@ -61,6 +61,7 @@ class ASTIdentifier : public ASTWithAlias\n private:\n     using ASTWithAlias::children; /// ASTIdentifier is child free\n \n+    friend class ASTTableIdentifier;\n     friend class ReplaceQueryParameterVisitor;\n     friend struct IdentifierSemantic;\n     friend void setIdentifierSpecial(ASTPtr & ast);\n@@ -83,6 +84,9 @@ class ASTTableIdentifier : public ASTIdentifier\n     StorageID getTableId() const;\n     String getDatabaseName() const;\n \n+    ASTPtr getTable() const;\n+    ASTPtr getDatabase() const;\n+\n     // FIXME: used only when it's needed to rewrite distributed table name to real remote table name.\n     void resetTable(const String & database_name, const String & table_name);  // TODO(ilezhankin): get rid of this\n \ndiff --git a/src/Parsers/ASTInsertQuery.cpp b/src/Parsers/ASTInsertQuery.cpp\nindex 3c8c31b85dd1..c733398a32b2 100644\n--- a/src/Parsers/ASTInsertQuery.cpp\n+++ b/src/Parsers/ASTInsertQuery.cpp\n@@ -1,4 +1,5 @@\n #include <iomanip>\n+#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTInsertQuery.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTLiteral.h>\n@@ -15,6 +16,35 @@ namespace ErrorCodes\n     extern const int INVALID_USAGE_OF_INPUT;\n }\n \n+String ASTInsertQuery::getDatabase() const\n+{\n+    String name;\n+    tryGetIdentifierNameInto(database, name);\n+    return name;\n+}\n+\n+String ASTInsertQuery::getTable() const\n+{\n+    String name;\n+    tryGetIdentifierNameInto(table, name);\n+    return name;\n+}\n+\n+void ASTInsertQuery::setDatabase(const String & name)\n+{\n+    if (name.empty())\n+        database.reset();\n+    else\n+        database = std::make_shared<ASTIdentifier>(name);\n+}\n+\n+void ASTInsertQuery::setTable(const String & name)\n+{\n+    if (name.empty())\n+        table.reset();\n+    else\n+        table = std::make_shared<ASTIdentifier>(name);\n+}\n \n void ASTInsertQuery::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n@@ -31,9 +61,16 @@ void ASTInsertQuery::formatImpl(const FormatSettings & settings, FormatState & s\n             partition_by->formatImpl(settings, state, frame);\n         }\n     }\n-    else\n+    else if (table_id)\n+    {\n         settings.ostr << (settings.hilite ? hilite_none : \"\")\n                       << (!table_id.database_name.empty() ? backQuoteIfNeed(table_id.database_name) + \".\" : \"\") << backQuoteIfNeed(table_id.table_name);\n+    }\n+    else\n+    {\n+        settings.ostr << (settings.hilite ? hilite_none : \"\")\n+                      << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n+    }\n \n     if (columns)\n     {\ndiff --git a/src/Parsers/ASTInsertQuery.h b/src/Parsers/ASTInsertQuery.h\nindex 81925ec2e66d..d539ad5fdb35 100644\n--- a/src/Parsers/ASTInsertQuery.h\n+++ b/src/Parsers/ASTInsertQuery.h\n@@ -13,6 +13,10 @@ class ASTInsertQuery : public IAST\n {\n public:\n     StorageID table_id = StorageID::createEmpty();\n+\n+    ASTPtr database;\n+    ASTPtr table;\n+\n     ASTPtr columns;\n     String format;\n     ASTPtr table_function;\n@@ -31,6 +35,12 @@ class ASTInsertQuery : public IAST\n     /// Data from buffer to insert after inlined one - may be nullptr.\n     ReadBuffer * tail = nullptr;\n \n+    String getDatabase() const;\n+    String getTable() const;\n+\n+    void setDatabase(const String & name);\n+    void setTable(const String & name);\n+\n     bool hasInlinedData() const { return data || tail; }\n \n     /// Try to find table function input() in SELECT part\n@@ -44,6 +54,8 @@ class ASTInsertQuery : public IAST\n         auto res = std::make_shared<ASTInsertQuery>(*this);\n         res->children.clear();\n \n+        if (database) { res->database = database->clone(); res->children.push_back(res->database); }\n+        if (table) { res->table = table->clone(); res->children.push_back(res->table); }\n         if (columns) { res->columns = columns->clone(); res->children.push_back(res->columns); }\n         if (select) { res->select = select->clone(); res->children.push_back(res->select); }\n         if (watch) { res->watch = watch->clone(); res->children.push_back(res->watch); }\ndiff --git a/src/Parsers/ASTOptimizeQuery.cpp b/src/Parsers/ASTOptimizeQuery.cpp\nindex 6423e247ecc6..720c7699fb6b 100644\n--- a/src/Parsers/ASTOptimizeQuery.cpp\n+++ b/src/Parsers/ASTOptimizeQuery.cpp\n@@ -8,7 +8,7 @@ namespace DB\n void ASTOptimizeQuery::formatQueryImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"OPTIMIZE TABLE \" << (settings.hilite ? hilite_none : \"\")\n-                  << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+                  << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n \n     formatOnCluster(settings);\n \ndiff --git a/src/Parsers/ASTOptimizeQuery.h b/src/Parsers/ASTOptimizeQuery.h\nindex f4981d156c7b..cac2ef1c6d09 100644\n--- a/src/Parsers/ASTOptimizeQuery.h\n+++ b/src/Parsers/ASTOptimizeQuery.h\n@@ -25,7 +25,7 @@ class ASTOptimizeQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithO\n     /** Get the text that identifies this element. */\n     String getID(char delim) const override\n     {\n-        return \"OptimizeQuery\" + (delim + database) + delim + table + (final ? \"_final\" : \"\") + (deduplicate ? \"_deduplicate\" : \"\");\n+        return \"OptimizeQuery\" + (delim + getDatabase()) + delim + getTable() + (final ? \"_final\" : \"\") + (deduplicate ? \"_deduplicate\" : \"\");\n     }\n \n     ASTPtr clone() const override\ndiff --git a/src/Parsers/ASTQueryWithOnCluster.h b/src/Parsers/ASTQueryWithOnCluster.h\nindex e053b50ffb2d..b309ae5e8479 100644\n--- a/src/Parsers/ASTQueryWithOnCluster.h\n+++ b/src/Parsers/ASTQueryWithOnCluster.h\n@@ -39,8 +39,8 @@ class ASTQueryWithOnCluster\n         T & query = static_cast<T &>(*query_ptr);\n \n         query.cluster.clear();\n-        if (query.database.empty())\n-            query.database = new_database;\n+        if (!query.database)\n+            query.setDatabase(new_database);\n \n         return query_ptr;\n     }\ndiff --git a/src/Parsers/ASTQueryWithTableAndOutput.cpp b/src/Parsers/ASTQueryWithTableAndOutput.cpp\nindex d44ba988d7ae..a216aeaa11f1 100644\n--- a/src/Parsers/ASTQueryWithTableAndOutput.cpp\n+++ b/src/Parsers/ASTQueryWithTableAndOutput.cpp\n@@ -1,3 +1,4 @@\n+#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTQueryWithTableAndOutput.h>\n #include <Common/quoteString.h>\n #include <IO/Operators.h>\n@@ -6,10 +7,67 @@\n namespace DB\n {\n \n+String ASTQueryWithTableAndOutput::getDatabase() const\n+{\n+    String name;\n+    tryGetIdentifierNameInto(database, name);\n+    return name;\n+}\n+\n+String ASTQueryWithTableAndOutput::getTable() const\n+{\n+    String name;\n+    tryGetIdentifierNameInto(table, name);\n+    return name;\n+}\n+\n+void ASTQueryWithTableAndOutput::setDatabase(const String & name)\n+{\n+    if (database)\n+    {\n+        std::erase(children, database);\n+        database.reset();\n+    }\n+\n+    if (!name.empty())\n+    {\n+        database = std::make_shared<ASTIdentifier>(name);\n+        children.push_back(database);\n+    }\n+}\n+\n+void ASTQueryWithTableAndOutput::setTable(const String & name)\n+{\n+    if (table)\n+    {\n+        std::erase(children, table);\n+        table.reset();\n+    }\n+\n+    if (!name.empty())\n+    {\n+        table = std::make_shared<ASTIdentifier>(name);\n+        children.push_back(table);\n+    }\n+}\n+\n+void ASTQueryWithTableAndOutput::cloneTableOptions(ASTQueryWithTableAndOutput & cloned) const\n+{\n+    if (database)\n+    {\n+        cloned.database = database->clone();\n+        cloned.children.push_back(cloned.database);\n+    }\n+    if (table)\n+    {\n+        cloned.table = table->clone();\n+        cloned.children.push_back(cloned.table);\n+    }\n+}\n void ASTQueryWithTableAndOutput::formatHelper(const FormatSettings & settings, const char * name) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << name << \" \" << (settings.hilite ? hilite_none : \"\");\n-    settings.ostr << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+    settings.ostr << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n }\n \n }\ndiff --git a/src/Parsers/ASTQueryWithTableAndOutput.h b/src/Parsers/ASTQueryWithTableAndOutput.h\nindex 03f5fa7bf22e..233028c50236 100644\n--- a/src/Parsers/ASTQueryWithTableAndOutput.h\n+++ b/src/Parsers/ASTQueryWithTableAndOutput.h\n@@ -14,11 +14,21 @@ namespace DB\n class ASTQueryWithTableAndOutput : public ASTQueryWithOutput\n {\n public:\n-    String database;\n-    String table;\n+    ASTPtr database;\n+    ASTPtr table;\n+\n     UUID uuid = UUIDHelpers::Nil;\n     bool temporary{false};\n \n+    String getDatabase() const;\n+    String getTable() const;\n+\n+    // Once database or table are set they cannot be assigned with empty value\n+    void setDatabase(const String & name);\n+    void setTable(const String & name);\n+\n+    void cloneTableOptions(ASTQueryWithTableAndOutput & cloned) const;\n+\n protected:\n     void formatHelper(const FormatSettings & settings, const char * name) const;\n };\n@@ -28,13 +38,14 @@ template <typename AstIDAndQueryNames>\n class ASTQueryWithTableAndOutputImpl : public ASTQueryWithTableAndOutput\n {\n public:\n-    String getID(char delim) const override { return AstIDAndQueryNames::ID + (delim + database) + delim + table; }\n+    String getID(char delim) const override { return AstIDAndQueryNames::ID + (delim + getDatabase()) + delim + getTable(); }\n \n     ASTPtr clone() const override\n     {\n         auto res = std::make_shared<ASTQueryWithTableAndOutputImpl<AstIDAndQueryNames>>(*this);\n         res->children.clear();\n         cloneOutputOptions(*res);\n+        cloneTableOptions(*res);\n         return res;\n     }\n \ndiff --git a/src/Parsers/ASTSystemQuery.cpp b/src/Parsers/ASTSystemQuery.cpp\nindex ba8e49b98cac..b8056862bfc4 100644\n--- a/src/Parsers/ASTSystemQuery.cpp\n+++ b/src/Parsers/ASTSystemQuery.cpp\n@@ -1,3 +1,4 @@\n+#include <Parsers/ASTIdentifier.h>\n #include <Parsers/IAST.h>\n #include <Parsers/ASTSystemQuery.h>\n #include <Common/quoteString.h>\n@@ -39,6 +40,50 @@ const char * ASTSystemQuery::typeToString(Type type)\n     return type_name.data();\n }\n \n+String ASTSystemQuery::getDatabase() const\n+{\n+    String name;\n+    tryGetIdentifierNameInto(database, name);\n+    return name;\n+}\n+\n+String ASTSystemQuery::getTable() const\n+{\n+    String name;\n+    tryGetIdentifierNameInto(table, name);\n+    return name;\n+}\n+\n+void ASTSystemQuery::setDatabase(const String & name)\n+{\n+    if (database)\n+    {\n+        std::erase(children, database);\n+        database.reset();\n+    }\n+\n+    if (!name.empty())\n+    {\n+        database = std::make_shared<ASTIdentifier>(name);\n+        children.push_back(database);\n+    }\n+}\n+\n+void ASTSystemQuery::setTable(const String & name)\n+{\n+    if (table)\n+    {\n+        std::erase(children, table);\n+        table.reset();\n+    }\n+\n+    if (!name.empty())\n+    {\n+        table = std::make_shared<ASTIdentifier>(name);\n+        children.push_back(table);\n+    }\n+}\n+\n void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"SYSTEM \";\n@@ -47,19 +92,19 @@ void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &,\n     auto print_database_table = [&]\n     {\n         settings.ostr << \" \";\n-        if (!database.empty())\n+        if (database)\n         {\n-            settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(database)\n+            settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(getDatabase())\n                           << (settings.hilite ? hilite_none : \"\") << \".\";\n         }\n-        settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(table)\n+        settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(getTable())\n                       << (settings.hilite ? hilite_none : \"\");\n     };\n \n     auto print_drop_replica = [&]\n     {\n         settings.ostr << \" \" << quoteString(replica);\n-        if (!table.empty())\n+        if (table)\n         {\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM TABLE\"\n                           << (settings.hilite ? hilite_none : \"\");\n@@ -70,11 +115,11 @@ void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &,\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM ZKPATH \"\n                           << (settings.hilite ? hilite_none : \"\") << quoteString(replica_zk_path);\n         }\n-        else if (!database.empty())\n+        else if (database)\n         {\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM DATABASE \"\n                           << (settings.hilite ? hilite_none : \"\");\n-            settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(database)\n+            settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(getDatabase())\n                           << (settings.hilite ? hilite_none : \"\");\n         }\n     };\n@@ -107,7 +152,7 @@ void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &,\n         || type == Type::STOP_DISTRIBUTED_SENDS\n         || type == Type::START_DISTRIBUTED_SENDS)\n     {\n-        if (!table.empty())\n+        if (table)\n             print_database_table();\n         else if (!volume.empty())\n             print_on_volume();\ndiff --git a/src/Parsers/ASTSystemQuery.h b/src/Parsers/ASTSystemQuery.h\nindex 419c22dd0d50..16f8a3c118aa 100644\n--- a/src/Parsers/ASTSystemQuery.h\n+++ b/src/Parsers/ASTSystemQuery.h\n@@ -70,10 +70,17 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster\n \n     Type type = Type::UNKNOWN;\n \n+    ASTPtr database;\n+    ASTPtr table;\n+\n+    String getDatabase() const;\n+    String getTable() const;\n+\n+    void setDatabase(const String & name);\n+    void setTable(const String & name);\n+\n     String target_model;\n     String target_function;\n-    String database;\n-    String table;\n     String replica;\n     String replica_zk_path;\n     bool is_drop_whole_replica{};\n@@ -84,7 +91,16 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster\n \n     String getID(char) const override { return \"SYSTEM query\"; }\n \n-    ASTPtr clone() const override { return std::make_shared<ASTSystemQuery>(*this); }\n+    ASTPtr clone() const override\n+    {\n+        auto res = std::make_shared<ASTSystemQuery>(*this);\n+        res->children.clear();\n+\n+        if (database) { res->database = database->clone(); res->children.push_back(res->database); }\n+        if (table) { res->table = table->clone(); res->children.push_back(res->table); }\n+\n+        return res;\n+    }\n \n     ASTPtr getRewrittenASTWithoutOnCluster(const std::string & new_database) const override\n     {\ndiff --git a/src/Parsers/ASTWatchQuery.h b/src/Parsers/ASTWatchQuery.h\nindex 7db6443e024c..ea02c18a51d7 100644\n--- a/src/Parsers/ASTWatchQuery.h\n+++ b/src/Parsers/ASTWatchQuery.h\n@@ -26,13 +26,14 @@ class ASTWatchQuery : public ASTQueryWithTableAndOutput\n     bool is_watch_events;\n \n     ASTWatchQuery() = default;\n-    String getID(char) const override { return \"WatchQuery_\" + database + \"_\" + table; }\n+    String getID(char) const override { return \"WatchQuery_\" + getDatabase() + \"_\" + getTable(); }\n \n     ASTPtr clone() const override\n     {\n         std::shared_ptr<ASTWatchQuery> res = std::make_shared<ASTWatchQuery>(*this);\n         res->children.clear();\n         cloneOutputOptions(*res);\n+        cloneTableOptions(*res);\n         return res;\n     }\n \n@@ -42,7 +43,7 @@ class ASTWatchQuery : public ASTQueryWithTableAndOutput\n         std::string indent_str = s.one_line ? \"\" : std::string(4 * frame.indent, ' ');\n \n         s.ostr << (s.hilite ? hilite_keyword : \"\") << \"WATCH \" << (s.hilite ? hilite_none : \"\")\n-            << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n+            << (database ? backQuoteIfNeed(getDatabase()) + \".\" : \"\") << backQuoteIfNeed(getTable());\n \n         if (is_watch_events)\n         {\ndiff --git a/src/Parsers/ParserAlterQuery.cpp b/src/Parsers/ParserAlterQuery.cpp\nindex 1ea64d94fe7f..66645ccaf0e9 100644\n--- a/src/Parsers/ParserAlterQuery.cpp\n+++ b/src/Parsers/ParserAlterQuery.cpp\n@@ -861,12 +861,12 @@ bool ParserAlterQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n     if (alter_object_type == ASTAlterQuery::AlterObjectType::DATABASE)\n     {\n-        if (!parseDatabase(pos, expected, query->database))\n+        if (!parseDatabaseAsAST(pos, expected, query->database))\n             return false;\n     }\n     else\n     {\n-        if (!parseDatabaseAndTableName(pos, expected, query->database, query->table))\n+        if (!parseDatabaseAndTableAsAST(pos, expected, query->database, query->table))\n             return false;\n \n         String cluster_str;\n@@ -886,6 +886,12 @@ bool ParserAlterQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     query->set(query->command_list, command_list);\n     query->alter_object = alter_object_type;\n \n+    if (query->database)\n+        query->children.push_back(query->database);\n+\n+    if (query->table)\n+        query->children.push_back(query->table);\n+\n     return true;\n }\n \ndiff --git a/src/Parsers/ParserCheckQuery.cpp b/src/Parsers/ParserCheckQuery.cpp\nindex c397e1c33c52..a89416ab2538 100644\n--- a/src/Parsers/ParserCheckQuery.cpp\n+++ b/src/Parsers/ParserCheckQuery.cpp\n@@ -4,6 +4,7 @@\n #include <Parsers/ExpressionElementParsers.h>\n #include <Parsers/ASTCheckQuery.h>\n #include <Parsers/ParserPartition.h>\n+#include <Parsers/parseDatabaseAndTableName.h>\n \n \n namespace DB\n@@ -15,31 +16,15 @@ bool ParserCheckQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ParserKeyword s_partition(\"PARTITION\");\n     ParserToken s_dot(TokenType::Dot);\n \n-    ParserIdentifier table_parser;\n     ParserPartition partition_parser;\n \n-    ASTPtr table;\n-    ASTPtr database;\n-\n     if (!s_check_table.ignore(pos, expected))\n         return false;\n-    if (!table_parser.parse(pos, database, expected))\n-        return false;\n \n     auto query = std::make_shared<ASTCheckQuery>();\n-    if (s_dot.ignore(pos))\n-    {\n-        if (!table_parser.parse(pos, table, expected))\n-            return false;\n \n-        tryGetIdentifierNameInto(database, query->database);\n-        tryGetIdentifierNameInto(table, query->table);\n-    }\n-    else\n-    {\n-        table = database;\n-        tryGetIdentifierNameInto(table, query->table);\n-    }\n+    if (!parseDatabaseAndTableAsAST(pos, expected, query->database, query->table))\n+        return false;\n \n     if (s_partition.ignore(pos, expected))\n     {\n@@ -47,6 +32,12 @@ bool ParserCheckQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             return false;\n     }\n \n+    if (query->database)\n+        query->children.push_back(query->database);\n+\n+    if (query->table)\n+        query->children.push_back(query->table);\n+\n     node = query;\n     return true;\n }\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex af2966948fb7..bc08d4206840 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -426,7 +426,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     ParserKeyword s_temporary(\"TEMPORARY\");\n     ParserKeyword s_table(\"TABLE\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n-    ParserCompoundIdentifier table_name_p(true);\n+    ParserCompoundIdentifier table_name_p(true, true);\n     ParserKeyword s_from(\"FROM\");\n     ParserKeyword s_on(\"ON\");\n     ParserKeyword s_as(\"AS\");\n@@ -495,7 +495,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n             return false;\n     }\n \n-    auto table_id = table->as<ASTTableIdentifier>()->getTableId();\n+    auto * table_id = table->as<ASTTableIdentifier>();\n \n     // Shortcut for ATTACH a previously detached table\n     bool short_attach = attach && !from_path;\n@@ -508,9 +508,14 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n         query->if_not_exists = if_not_exists;\n         query->cluster = cluster_str;\n \n-        query->database = table_id.database_name;\n-        query->table = table_id.table_name;\n-        query->uuid = table_id.uuid;\n+        query->database = table_id->getDatabase();\n+        query->table = table_id->getTable();\n+        query->uuid = table_id->uuid;\n+\n+        if (query->database)\n+            query->children.push_back(query->database);\n+        if (query->table)\n+            query->children.push_back(query->table);\n \n         return true;\n     }\n@@ -585,11 +590,16 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     query->if_not_exists = if_not_exists;\n     query->temporary = is_temporary;\n \n-    query->database = table_id.database_name;\n-    query->table = table_id.table_name;\n-    query->uuid = table_id.uuid;\n+    query->database = table_id->getDatabase();\n+    query->table = table_id->getTable();\n+    query->uuid = table_id->uuid;\n     query->cluster = cluster_str;\n \n+    if (query->database)\n+        query->children.push_back(query->database);\n+    if (query->table)\n+        query->children.push_back(query->table);\n+\n     query->set(query->columns_list, columns_list);\n     query->set(query->storage, storage);\n \n@@ -620,7 +630,7 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     ParserKeyword s_create(\"CREATE\");\n     ParserKeyword s_attach(\"ATTACH\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n-    ParserCompoundIdentifier table_name_p(true);\n+    ParserCompoundIdentifier table_name_p(true, true);\n     ParserKeyword s_as(\"AS\");\n     ParserKeyword s_view(\"VIEW\");\n     ParserKeyword s_live(\"LIVE\");\n@@ -735,12 +745,17 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     query->if_not_exists = if_not_exists;\n     query->is_live_view = true;\n \n-    auto table_id = table->as<ASTTableIdentifier>()->getTableId();\n-    query->database = table_id.database_name;\n-    query->table = table_id.table_name;\n-    query->uuid = table_id.uuid;\n+    auto * table_id = table->as<ASTTableIdentifier>();\n+    query->database = table_id->getDatabase();\n+    query->table = table_id->getTable();\n+    query->uuid = table_id->uuid;\n     query->cluster = cluster_str;\n \n+    if (query->database)\n+        query->children.push_back(query->database);\n+    if (query->table)\n+        query->children.push_back(query->table);\n+\n     if (to_table)\n         query->to_table_id = to_table->as<ASTTableIdentifier>()->getTableId();\n \n@@ -766,7 +781,7 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     ParserKeyword s_database(\"DATABASE\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n     ParserStorage storage_p;\n-    ParserIdentifier name_p;\n+    ParserIdentifier name_p(true);\n \n     ASTPtr database;\n     ASTPtr storage;\n@@ -817,9 +832,12 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     query->attach = attach;\n     query->if_not_exists = if_not_exists;\n \n-    tryGetIdentifierNameInto(database, query->database);\n     query->uuid = uuid;\n     query->cluster = cluster_str;\n+    query->database = database;\n+\n+    if (database)\n+        query->children.push_back(database);\n \n     query->set(query->storage, storage);\n     if (comment)\n@@ -833,7 +851,7 @@ bool ParserCreateViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n     ParserKeyword s_create(\"CREATE\");\n     ParserKeyword s_attach(\"ATTACH\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n-    ParserCompoundIdentifier table_name_p(true);\n+    ParserCompoundIdentifier table_name_p(true, true);\n     ParserKeyword s_as(\"AS\");\n     ParserKeyword s_view(\"VIEW\");\n     ParserKeyword s_materialized(\"MATERIALIZED\");\n@@ -954,12 +972,17 @@ bool ParserCreateViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n     query->is_populate = is_populate;\n     query->replace_view = replace_view;\n \n-    auto table_id = table->as<ASTTableIdentifier>()->getTableId();\n-    query->database = table_id.database_name;\n-    query->table = table_id.table_name;\n-    query->uuid = table_id.uuid;\n+    auto * table_id = table->as<ASTTableIdentifier>();\n+    query->database = table_id->getDatabase();\n+    query->table = table_id->getTable();\n+    query->uuid = table_id->uuid;\n     query->cluster = cluster_str;\n \n+    if (query->database)\n+        query->children.push_back(query->database);\n+    if (query->table)\n+        query->children.push_back(query->table);\n+\n     if (to_table)\n         query->to_table_id = to_table->as<ASTTableIdentifier>()->getTableId();\n     if (to_inner_uuid)\n@@ -987,7 +1010,7 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     ParserKeyword s_dictionary(\"DICTIONARY\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n     ParserKeyword s_on(\"ON\");\n-    ParserCompoundIdentifier dict_name_p(true);\n+    ParserCompoundIdentifier dict_name_p(true, true);\n     ParserToken s_left_paren(TokenType::OpeningRoundBracket);\n     ParserToken s_right_paren(TokenType::ClosingRoundBracket);\n     ParserToken s_dot(TokenType::Dot);\n@@ -1059,10 +1082,15 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     query->create_or_replace = or_replace;\n     query->replace_table = replace;\n \n-    auto dict_id = name->as<ASTTableIdentifier>()->getTableId();\n-    query->database = dict_id.database_name;\n-    query->table = dict_id.table_name;\n-    query->uuid = dict_id.uuid;\n+    auto * dict_id = name->as<ASTTableIdentifier>();\n+    query->database = dict_id->getDatabase();\n+    query->table = dict_id->getTable();\n+    query->uuid = dict_id->uuid;\n+\n+    if (query->database)\n+        query->children.push_back(query->database);\n+    if (query->table)\n+        query->children.push_back(query->table);\n \n     query->if_not_exists = if_not_exists;\n     query->set(query->dictionary_attributes_list, attributes);\ndiff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp\nindex 5400f33fbd93..211c7699723c 100644\n--- a/src/Parsers/ParserDropQuery.cpp\n+++ b/src/Parsers/ParserDropQuery.cpp\n@@ -20,7 +20,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     ParserKeyword s_database(\"DATABASE\");\n     ParserToken s_dot(TokenType::Dot);\n     ParserKeyword s_if_exists(\"IF EXISTS\");\n-    ParserIdentifier name_p;\n+    ParserIdentifier name_p(true);\n     ParserKeyword s_permanently(\"PERMANENTLY\");\n     ParserKeyword s_no_delay(\"NO DELAY\");\n     ParserKeyword s_sync(\"SYNC\");\n@@ -96,9 +96,14 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons\n     query->is_view = is_view;\n     query->no_delay = no_delay;\n     query->permanently = permanently;\n+    query->database = database;\n+    query->table = table;\n \n-    tryGetIdentifierNameInto(database, query->database);\n-    tryGetIdentifierNameInto(table, query->table);\n+    if (database)\n+        query->children.push_back(database);\n+\n+    if (table)\n+        query->children.push_back(table);\n \n     query->cluster = cluster_str;\n \ndiff --git a/src/Parsers/ParserInsertQuery.cpp b/src/Parsers/ParserInsertQuery.cpp\nindex 1bc552af384e..8925de4cf559 100644\n--- a/src/Parsers/ParserInsertQuery.cpp\n+++ b/src/Parsers/ParserInsertQuery.cpp\n@@ -41,7 +41,7 @@ bool ParserInsertQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ParserKeyword s_with(\"WITH\");\n     ParserToken s_lparen(TokenType::OpeningRoundBracket);\n     ParserToken s_rparen(TokenType::ClosingRoundBracket);\n-    ParserIdentifier name_p;\n+    ParserIdentifier name_p(true);\n     ParserList columns_p(std::make_unique<ParserInsertElement>(), std::make_unique<ParserToken>(TokenType::Comma), false);\n     ParserFunction table_function_p{false};\n     ParserStringLiteral infile_name_p;\n@@ -244,8 +244,13 @@ bool ParserInsertQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     }\n     else\n     {\n-        tryGetIdentifierNameInto(database, query->table_id.database_name);\n-        tryGetIdentifierNameInto(table, query->table_id.table_name);\n+        query->database = database;\n+        query->table = table;\n+\n+        if (database)\n+            query->children.push_back(database);\n+        if (table)\n+            query->children.push_back(table);\n     }\n \n     query->columns = columns;\ndiff --git a/src/Parsers/ParserOptimizeQuery.cpp b/src/Parsers/ParserOptimizeQuery.cpp\nindex 441cec1465e9..b1bfd43936b1 100644\n--- a/src/Parsers/ParserOptimizeQuery.cpp\n+++ b/src/Parsers/ParserOptimizeQuery.cpp\n@@ -31,7 +31,7 @@ bool ParserOptimizeQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n     ParserKeyword s_deduplicate(\"DEDUPLICATE\");\n     ParserKeyword s_by(\"BY\");\n     ParserToken s_dot(TokenType::Dot);\n-    ParserIdentifier name_p;\n+    ParserIdentifier name_p(true);\n     ParserPartition partition_p;\n \n     ASTPtr database;\n@@ -80,15 +80,20 @@ bool ParserOptimizeQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n     auto query = std::make_shared<ASTOptimizeQuery>();\n     node = query;\n \n-    tryGetIdentifierNameInto(database, query->database);\n-    tryGetIdentifierNameInto(table, query->table);\n-\n     query->cluster = cluster_str;\n     if ((query->partition = partition))\n         query->children.push_back(partition);\n     query->final = final;\n     query->deduplicate = deduplicate;\n     query->deduplicate_by_columns = deduplicate_by_columns;\n+    query->database = database;\n+    query->table = table;\n+\n+    if (database)\n+        query->children.push_back(database);\n+\n+    if (table)\n+        query->children.push_back(table);\n \n     return true;\n }\ndiff --git a/src/Parsers/ParserSystemQuery.cpp b/src/Parsers/ParserSystemQuery.cpp\nindex b861cbd2a5a0..5a61929bdb30 100644\n--- a/src/Parsers/ParserSystemQuery.cpp\n+++ b/src/Parsers/ParserSystemQuery.cpp\n@@ -39,14 +39,13 @@ static bool parseQueryWithOnClusterAndMaybeTable(std::shared_ptr<ASTSystemQuery>\n         ASTPtr ast;\n         if (ParserStringLiteral{}.parse(pos, ast, expected))\n         {\n-            res->database = {};\n-            res->table = ast->as<ASTLiteral &>().value.safeGet<String>();\n+            res->setTable(ast->as<ASTLiteral &>().value.safeGet<String>());\n             parsed_table = true;\n         }\n     }\n \n     if (!parsed_table)\n-        parsed_table = parseDatabaseAndTableName(pos, expected, res->database, res->table);\n+        parsed_table = parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);\n \n     if (!parsed_table && require_table)\n             return false;\n@@ -56,6 +55,12 @@ static bool parseQueryWithOnClusterAndMaybeTable(std::shared_ptr<ASTSystemQuery>\n             return false;\n \n     res->cluster = cluster;\n+\n+    if (res->database)\n+        res->children.push_back(res->database);\n+    if (res->table)\n+        res->children.push_back(res->table);\n+\n     return true;\n }\n \n@@ -163,14 +168,12 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n                 if (ParserKeyword{\"DATABASE\"}.ignore(pos, expected))\n                 {\n                     ParserIdentifier database_parser;\n-                    ASTPtr database;\n-                    if (!database_parser.parse(pos, database, expected))\n+                    if (!database_parser.parse(pos, res->database, expected))\n                         return false;\n-                    tryGetIdentifierNameInto(database, res->database);\n                 }\n                 else if (ParserKeyword{\"TABLE\"}.ignore(pos, expected))\n                 {\n-                    parseDatabaseAndTableName(pos, expected, res->database, res->table);\n+                    parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);\n                 }\n                 else if (ParserKeyword{\"ZKPATH\"}.ignore(pos, expected))\n                 {\n@@ -193,7 +196,7 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n \n         case Type::RESTART_REPLICA:\n         case Type::SYNC_REPLICA:\n-            if (!parseDatabaseAndTableName(pos, expected, res->database, res->table))\n+            if (!parseDatabaseAndTableAsAST(pos, expected, res->database, res->table))\n                 return false;\n             break;\n \n@@ -251,7 +254,7 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n             res->storage_policy = storage_policy_str;\n             res->volume = volume_str;\n             if (res->volume.empty() && res->storage_policy.empty())\n-                parseDatabaseAndTableName(pos, expected, res->database, res->table);\n+                parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);\n             break;\n         }\n \n@@ -265,7 +268,7 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n         case Type::START_REPLICATED_SENDS:\n         case Type::STOP_REPLICATION_QUEUES:\n         case Type::START_REPLICATION_QUEUES:\n-            parseDatabaseAndTableName(pos, expected, res->database, res->table);\n+            parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);\n             break;\n \n         case Type::SUSPEND:\n@@ -287,6 +290,11 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n             break;\n     }\n \n+    if (res->database)\n+        res->children.push_back(res->database);\n+    if (res->table)\n+        res->children.push_back(res->table);\n+\n     node = std::move(res);\n     return true;\n }\ndiff --git a/src/Parsers/ParserTablePropertiesQuery.cpp b/src/Parsers/ParserTablePropertiesQuery.cpp\nindex 30be37bc4a1f..bf3ff399f61b 100644\n--- a/src/Parsers/ParserTablePropertiesQuery.cpp\n+++ b/src/Parsers/ParserTablePropertiesQuery.cpp\n@@ -24,7 +24,7 @@ bool ParserTablePropertiesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &\n     ParserKeyword s_view(\"VIEW\");\n     ParserKeyword s_dictionary(\"DICTIONARY\");\n     ParserToken s_dot(TokenType::Dot);\n-    ParserIdentifier name_p;\n+    ParserIdentifier name_p(true);\n \n     ASTPtr database;\n     ASTPtr table;\n@@ -110,8 +110,14 @@ bool ParserTablePropertiesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &\n         }\n     }\n \n-    tryGetIdentifierNameInto(database, query->database);\n-    tryGetIdentifierNameInto(table, query->table);\n+    query->database = database;\n+    query->table = table;\n+\n+    if (database)\n+        query->children.push_back(database);\n+\n+    if (table)\n+        query->children.push_back(table);\n \n     node = query;\n \ndiff --git a/src/Parsers/ParserWatchQuery.cpp b/src/Parsers/ParserWatchQuery.cpp\nindex 5171f4f25364..40d2c47bd4f3 100644\n--- a/src/Parsers/ParserWatchQuery.cpp\n+++ b/src/Parsers/ParserWatchQuery.cpp\n@@ -24,7 +24,7 @@ bool ParserWatchQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ParserKeyword s_watch(\"WATCH\");\n     ParserToken s_dot(TokenType::Dot);\n-    ParserIdentifier name_p;\n+    ParserIdentifier name_p(true);\n     ParserKeyword s_events(\"EVENTS\");\n     ParserKeyword s_limit(\"LIMIT\");\n \n@@ -62,11 +62,14 @@ bool ParserWatchQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             return false;\n     }\n \n+    query->database = database;\n+    query->table = table;\n+\n     if (database)\n-        query->database = getIdentifierName(database);\n+        query->children.push_back(database);\n \n     if (table)\n-        query->table = getIdentifierName(table);\n+        query->children.push_back(table);\n \n     node = query;\n \ndiff --git a/src/Parsers/TablePropertiesQueriesASTs.h b/src/Parsers/TablePropertiesQueriesASTs.h\nindex edb040d72d97..b5baddcf268c 100644\n--- a/src/Parsers/TablePropertiesQueriesASTs.h\n+++ b/src/Parsers/TablePropertiesQueriesASTs.h\n@@ -89,7 +89,7 @@ class ASTExistsDatabaseQuery : public ASTQueryWithTableAndOutputImpl<ASTExistsDa\n     void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << ASTExistsDatabaseQueryIDAndQueryNames::Query\n-                    << \" \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(database);\n+                    << \" \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(getDatabase());\n     }\n };\n \n@@ -99,7 +99,7 @@ class ASTShowCreateDatabaseQuery : public ASTQueryWithTableAndOutputImpl<ASTShow\n     void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << ASTShowCreateDatabaseQueryIDAndQueryNames::Query\n-                      << \" \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(database);\n+                      << \" \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(getDatabase());\n     }\n };\n \ndiff --git a/src/Parsers/parseDatabaseAndTableName.cpp b/src/Parsers/parseDatabaseAndTableName.cpp\nindex c071f1b6eb43..48f47dbb68cb 100644\n--- a/src/Parsers/parseDatabaseAndTableName.cpp\n+++ b/src/Parsers/parseDatabaseAndTableName.cpp\n@@ -41,6 +41,24 @@ bool parseDatabaseAndTableName(IParser::Pos & pos, Expected & expected, String &\n     return true;\n }\n \n+bool parseDatabaseAndTableAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database, ASTPtr & table)\n+{\n+    ParserToken s_dot(TokenType::Dot);\n+    ParserIdentifier table_parser(true);\n+\n+    if (!table_parser.parse(pos, table, expected))\n+        return false;\n+\n+    if (s_dot.ignore(pos))\n+    {\n+        database = table;\n+        if (!table_parser.parse(pos, table, expected))\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n \n bool parseDatabase(IParser::Pos & pos, Expected & expected, String & database_str)\n {\n@@ -57,6 +75,12 @@ bool parseDatabase(IParser::Pos & pos, Expected & expected, String & database_st\n     return true;\n }\n \n+bool parseDatabaseAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database)\n+{\n+    ParserIdentifier identifier_parser(/* allow_query_parameter */true);\n+    return identifier_parser.parse(pos, database, expected);\n+}\n+\n \n bool parseDatabaseAndTableNameOrAsterisks(IParser::Pos & pos, Expected & expected, String & database, bool & any_database, String & table, bool & any_table)\n {\ndiff --git a/src/Parsers/parseDatabaseAndTableName.h b/src/Parsers/parseDatabaseAndTableName.h\nindex dc435ca047eb..6ec354d68b44 100644\n--- a/src/Parsers/parseDatabaseAndTableName.h\n+++ b/src/Parsers/parseDatabaseAndTableName.h\n@@ -7,9 +7,13 @@ namespace DB\n /// Parses [db.]name\n bool parseDatabaseAndTableName(IParser::Pos & pos, Expected & expected, String & database_str, String & table_str);\n \n+bool parseDatabaseAndTableAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database, ASTPtr & table);\n+\n /// Parses [db.]name or [db.]* or [*.]*\n bool parseDatabaseAndTableNameOrAsterisks(IParser::Pos & pos, Expected & expected, String & database, bool & any_database, String & table, bool & any_table);\n \n bool parseDatabase(IParser::Pos & pos, Expected & expected, String & database_str);\n \n+bool parseDatabaseAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database);\n+\n }\ndiff --git a/src/Server/GRPCServer.cpp b/src/Server/GRPCServer.cpp\nindex 676d9a61926e..bac88e350e2d 100644\n--- a/src/Server/GRPCServer.cpp\n+++ b/src/Server/GRPCServer.cpp\n@@ -958,7 +958,18 @@ namespace\n         {\n             if (insert_query)\n             {\n-                auto table_id = query_context->resolveStorageID(insert_query->table_id, Context::ResolveOrdinary);\n+                auto table_id = StorageID::createEmpty();\n+\n+                if (insert_query->table_id)\n+                {\n+                    table_id = query_context->resolveStorageID(insert_query->table_id, Context::ResolveOrdinary);\n+                }\n+                else\n+                {\n+                    StorageID local_table_id(insert_query->getDatabase(), insert_query->getTable());\n+                    table_id = query_context->resolveStorageID(local_table_id, Context::ResolveOrdinary);\n+                }\n+\n                 if (query_context->getSettingsRef().input_format_defaults_for_omitted_fields && table_id)\n                 {\n                     StoragePtr storage = DatabaseCatalog::instance().getTable(table_id, query_context);\ndiff --git a/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp b/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp\nindex 69369cbc1a3c..12af472247d0 100644\n--- a/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp\n+++ b/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp\n@@ -24,8 +24,8 @@ namespace\n         {\n             /// We create and execute `drop` query for this table\n             auto drop_query = std::make_shared<ASTDropQuery>();\n-            drop_query->database = storage_id.database_name;\n-            drop_query->table = storage_id.table_name;\n+            drop_query->setDatabase(storage_id.database_name);\n+            drop_query->setTable(storage_id.table_name);\n             drop_query->kind = ASTDropQuery::Kind::Drop;\n             ASTPtr ast_drop_query = drop_query;\n             InterpreterDropQuery drop_interpreter(ast_drop_query, context);\ndiff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\nindex f771b2239efb..84afe7400912 100644\n--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp\n@@ -369,8 +369,8 @@ ASTPtr StorageMaterializedPostgreSQL::getCreateNestedTableQuery(PostgreSQLTableS\n     auto create_table_query = std::make_shared<ASTCreateQuery>();\n \n     auto table_id = getStorageID();\n-    create_table_query->table = getNestedTableName();\n-    create_table_query->database = table_id.database_name;\n+    create_table_query->setTable(getNestedTableName());\n+    create_table_query->setDatabase(table_id.database_name);\n     if (is_materialized_postgresql_database)\n         create_table_query->uuid = table_id.uuid;\n \ndiff --git a/src/Storages/StorageFactory.cpp b/src/Storages/StorageFactory.cpp\nindex ba2ac3f72a3b..1aa6ae98e7a6 100644\n--- a/src/Storages/StorageFactory.cpp\n+++ b/src/Storages/StorageFactory.cpp\n@@ -201,7 +201,7 @@ StoragePtr StorageFactory::get(\n         .storage_def = storage_def,\n         .query = query,\n         .relative_data_path = relative_data_path,\n-        .table_id = StorageID(query.database, query.table, query.uuid),\n+        .table_id = StorageID(query.getDatabase(), query.getTable(), query.uuid),\n         .local_context = local_context,\n         .context = context,\n         .columns = columns,\ndiff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex e7de3010c331..210e65484653 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -105,8 +105,8 @@ StorageMaterializedView::StorageMaterializedView(\n         /// We will create a query to create an internal table.\n         auto create_context = Context::createCopy(local_context);\n         auto manual_create_query = std::make_shared<ASTCreateQuery>();\n-        manual_create_query->database = getStorageID().database_name;\n-        manual_create_query->table = generateInnerTableName(getStorageID());\n+        manual_create_query->setDatabase(getStorageID().database_name);\n+        manual_create_query->setTable(generateInnerTableName(getStorageID()));\n         manual_create_query->uuid = query.to_inner_uuid;\n \n         auto new_columns_list = std::make_shared<ASTColumns>();\n@@ -119,7 +119,7 @@ StorageMaterializedView::StorageMaterializedView(\n         create_interpreter.setInternal(true);\n         create_interpreter.execute();\n \n-        target_table_id = DatabaseCatalog::instance().getTable({manual_create_query->database, manual_create_query->table}, getContext())->getStorageID();\n+        target_table_id = DatabaseCatalog::instance().getTable({manual_create_query->getDatabase(), manual_create_query->getTable()}, getContext())->getStorageID();\n     }\n \n     if (!select.select_table_id.empty())\ndiff --git a/src/Storages/System/attachInformationSchemaTables.cpp b/src/Storages/System/attachInformationSchemaTables.cpp\nindex cfe5de1dc41a..803e9d55dac7 100644\n--- a/src/Storages/System/attachInformationSchemaTables.cpp\n+++ b/src/Storages/System/attachInformationSchemaTables.cpp\n@@ -31,14 +31,14 @@ static void createInformationSchemaView(ContextMutablePtr context, IDatabase & d\n                                 DBMS_DEFAULT_MAX_QUERY_SIZE, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n \n         auto & ast_create = ast->as<ASTCreateQuery &>();\n-        assert(view_name == ast_create.table);\n+        assert(view_name == ast_create.getTable());\n         if (is_uppercase)\n-            ast_create.table = Poco::toUpper(view_name);\n+            ast_create.setTable(Poco::toUpper(view_name));\n \n         StoragePtr view = createTableFromAST(ast_create, database.getDatabaseName(),\n                                              database.getTableDataPath(ast_create), context, true).second;\n \n-        database.createTable(context, ast_create.table, view, ast);\n+        database.createTable(context, ast_create.getTable(), view, ast);\n     }\n     catch (...)\n     {\n",
  "test_patch": "diff --git a/src/Parsers/tests/gtest_dictionary_parser.cpp b/src/Parsers/tests/gtest_dictionary_parser.cpp\nindex 967f68484042..25f48fc27c84 100644\n--- a/src/Parsers/tests/gtest_dictionary_parser.cpp\n+++ b/src/Parsers/tests/gtest_dictionary_parser.cpp\n@@ -42,8 +42,8 @@ TEST(ParserDictionaryDDL, SimpleDictionary)\n     ParserCreateDictionaryQuery parser;\n     ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n-    EXPECT_EQ(create->table, \"dict1\");\n-    EXPECT_EQ(create->database, \"test\");\n+    EXPECT_EQ(create->getTable(), \"dict1\");\n+    EXPECT_EQ(create->getDatabase(), \"test\");\n     EXPECT_EQ(create->is_dictionary, true);\n     EXPECT_NE(create->dictionary, nullptr);\n     EXPECT_NE(create->dictionary->lifetime, nullptr);\n@@ -138,8 +138,8 @@ TEST(ParserDictionaryDDL, AttributesWithMultipleProperties)\n     ParserCreateDictionaryQuery parser;\n     ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n-    EXPECT_EQ(create->table, \"dict2\");\n-    EXPECT_EQ(create->database, \"\");\n+    EXPECT_EQ(create->getTable(), \"dict2\");\n+    EXPECT_EQ(create->getDatabase(), \"\");\n \n     /// test attributes\n     EXPECT_NE(create->dictionary_attributes_list, nullptr);\n@@ -240,8 +240,8 @@ TEST(ParserDictionaryDDL, NestedSource)\n     ParserCreateDictionaryQuery parser;\n     ASTPtr ast = parseQuery(parser, input.data(), input.data() + input.size(), \"\", 0, 0);\n     ASTCreateQuery * create = ast->as<ASTCreateQuery>();\n-    EXPECT_EQ(create->table, \"dict4\");\n-    EXPECT_EQ(create->database, \"\");\n+    EXPECT_EQ(create->getTable(), \"dict4\");\n+    EXPECT_EQ(create->getDatabase(), \"\");\n \n     /// source test\n     EXPECT_EQ(create->dictionary->source->name, \"mysql\");\n@@ -301,8 +301,8 @@ TEST(ParserDictionaryDDL, ParseDropQuery)\n     ASTDropQuery * drop1 = ast1->as<ASTDropQuery>();\n \n     EXPECT_TRUE(drop1->is_dictionary);\n-    EXPECT_EQ(drop1->database, \"test\");\n-    EXPECT_EQ(drop1->table, \"dict1\");\n+    EXPECT_EQ(drop1->getDatabase(), \"test\");\n+    EXPECT_EQ(drop1->getTable(), \"dict1\");\n     auto str1 = serializeAST(*drop1, true);\n     EXPECT_EQ(input1, str1);\n \n@@ -312,8 +312,8 @@ TEST(ParserDictionaryDDL, ParseDropQuery)\n     ASTDropQuery * drop2 = ast2->as<ASTDropQuery>();\n \n     EXPECT_TRUE(drop2->is_dictionary);\n-    EXPECT_EQ(drop2->database, \"\");\n-    EXPECT_EQ(drop2->table, \"dict2\");\n+    EXPECT_EQ(drop2->getDatabase(), \"\");\n+    EXPECT_EQ(drop2->getTable(), \"dict2\");\n     auto str2 = serializeAST(*drop2, true);\n     EXPECT_EQ(input2, str2);\n }\n@@ -326,8 +326,8 @@ TEST(ParserDictionaryDDL, ParsePropertiesQueries)\n     ASTPtr ast1 = parseQuery(parser, input1.data(), input1.data() + input1.size(), \"\", 0, 0);\n     ASTShowCreateDictionaryQuery * show1 = ast1->as<ASTShowCreateDictionaryQuery>();\n \n-    EXPECT_EQ(show1->table, \"dict1\");\n-    EXPECT_EQ(show1->database, \"test\");\n+    EXPECT_EQ(show1->getTable(), \"dict1\");\n+    EXPECT_EQ(show1->getDatabase(), \"test\");\n     EXPECT_EQ(serializeAST(*show1), input1);\n \n     String input2 = \"EXISTS DICTIONARY dict2\";\n@@ -335,7 +335,7 @@ TEST(ParserDictionaryDDL, ParsePropertiesQueries)\n     ASTPtr ast2 = parseQuery(parser, input2.data(), input2.data() + input2.size(), \"\", 0, 0);\n     ASTExistsDictionaryQuery * show2 = ast2->as<ASTExistsDictionaryQuery>();\n \n-    EXPECT_EQ(show2->table, \"dict2\");\n-    EXPECT_EQ(show2->database, \"\");\n+    EXPECT_EQ(show2->getTable(), \"dict2\");\n+    EXPECT_EQ(show2->getDatabase(), \"\");\n     EXPECT_EQ(serializeAST(*show2), input2);\n }\ndiff --git a/tests/queries/0_stateless/01604_explain_ast_of_nonselect_query.reference b/tests/queries/0_stateless/01604_explain_ast_of_nonselect_query.reference\nindex 3c92ffb0a8cd..887c701a5e4d 100644\n--- a/tests/queries/0_stateless/01604_explain_ast_of_nonselect_query.reference\n+++ b/tests/queries/0_stateless/01604_explain_ast_of_nonselect_query.reference\n@@ -1,4 +1,4 @@\n-AlterQuery  t1 (children 1)\n+AlterQuery  t1 (children 2)\n  ExpressionList (children 1)\n   AlterCommand 33 (children 1)\n    Function equals (children 1)\n@@ -6,3 +6,4 @@ AlterQuery  t1 (children 1)\n      Identifier date\n      Function today (children 1)\n       ExpressionList\n+ Identifier t1\ndiff --git a/tests/queries/0_stateless/02014_query_parameters.reference b/tests/queries/0_stateless/02014_query_parameters.reference\nnew file mode 100644\nindex 000000000000..d126b1e773e5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02014_query_parameters.reference\n@@ -0,0 +1,4 @@\n+1\t2\n+1\n+4\n+2\ndiff --git a/tests/queries/0_stateless/02014_query_parameters.sh b/tests/queries/0_stateless/02014_query_parameters.sh\nnew file mode 100755\nindex 000000000000..b3d718fa578b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02014_query_parameters.sh\n@@ -0,0 +1,20 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP DATABASE IF EXISTS test_db\";\n+\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"CREATE DATABASE {db:Identifier}\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"CREATE TABLE {db:Identifier}.{tbl:Identifier} (id UInt64, col1 UInt64) ENGINE = MergeTree() ORDER BY id\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"INSERT INTO {db:Identifier}.{tbl:Identifier} VALUES (1,2)\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"SELECT * FROM {db:Identifier}.{tbl:Identifier}\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"OPTIMIZE TABLE {db:Identifier}.{tbl:Identifier}\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"ALTER TABLE {db:Identifier}.{tbl:Identifier} RENAME COLUMN col1 to col2\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"EXISTS TABLE {db:Identifier}.{tbl:Identifier}\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"INSERT INTO {db:Identifier}.{tbl:Identifier} VALUES (3,4)\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"SELECT col2 FROM {db:Identifier}.{tbl:Identifier} ORDER BY col2 DESC\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"DROP TABLE {db:Identifier}.{tbl:Identifier}\";\n+${CLICKHOUSE_CLIENT} --param_db=\"test_db\" --param_tbl=\"test_t\" --query \"DROP DATABASE {db:Identifier}\";\n",
  "problem_statement": "\"Identifier\" query parameters should work for CREATE TABLE and similar\n**Use case**\r\n\r\n`CREATE TABLE logs.{table:Identifier}`\r\n\r\n**Describe the solution you'd like**\r\n\r\nIt should work.\r\n\r\n**Additional context**\r\n\r\nIt does not.\r\n\n",
  "hints_text": "",
  "created_at": "2021-09-06T22:34:00Z",
  "modified_files": [
    "programs/copier/ClusterCopier.cpp",
    "src/Backups/BackupUtils.cpp",
    "src/Backups/renameInCreateQuery.cpp",
    "src/Client/ClientBase.cpp",
    "src/Databases/DatabaseAtomic.cpp",
    "src/Databases/DatabaseFactory.cpp",
    "src/Databases/DatabaseMemory.cpp",
    "src/Databases/DatabaseMemory.h",
    "src/Databases/DatabaseOnDisk.cpp",
    "src/Databases/DatabaseOnDisk.h",
    "src/Databases/DatabaseOrdinary.cpp",
    "src/Databases/DatabaseReplicated.cpp",
    "src/Databases/DatabasesCommon.cpp",
    "src/Databases/MySQL/DatabaseMySQL.cpp",
    "src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp",
    "src/Databases/PostgreSQL/DatabasePostgreSQL.cpp",
    "src/Databases/SQLite/DatabaseSQLite.cpp",
    "src/Dictionaries/getDictionaryConfigurationFromAST.cpp",
    "src/Interpreters/AddDefaultDatabaseVisitor.h",
    "src/Interpreters/DDLTask.cpp",
    "src/Interpreters/DDLWorker.cpp",
    "src/Interpreters/DatabaseCatalog.cpp",
    "src/Interpreters/InterpreterAlterQuery.cpp",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Interpreters/InterpreterDropQuery.cpp",
    "src/Interpreters/InterpreterExistsQuery.cpp",
    "src/Interpreters/InterpreterInsertQuery.cpp",
    "src/Interpreters/InterpreterOptimizeQuery.cpp",
    "src/Interpreters/InterpreterShowCreateQuery.cpp",
    "src/Interpreters/InterpreterSystemQuery.cpp",
    "src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp",
    "src/Interpreters/StorageID.cpp",
    "src/Interpreters/SystemLog.h",
    "src/Interpreters/executeQuery.cpp",
    "src/Interpreters/loadMetadata.cpp",
    "src/Parsers/ASTAlterQuery.cpp",
    "src/Parsers/ASTCheckQuery.h",
    "src/Parsers/ASTCreateQuery.cpp",
    "src/Parsers/ASTCreateQuery.h",
    "src/Parsers/ASTDropQuery.cpp",
    "src/Parsers/ASTIdentifier.cpp",
    "src/Parsers/ASTIdentifier.h",
    "src/Parsers/ASTInsertQuery.cpp",
    "src/Parsers/ASTInsertQuery.h",
    "src/Parsers/ASTOptimizeQuery.cpp",
    "src/Parsers/ASTOptimizeQuery.h",
    "src/Parsers/ASTQueryWithOnCluster.h",
    "src/Parsers/ASTQueryWithTableAndOutput.cpp",
    "src/Parsers/ASTQueryWithTableAndOutput.h",
    "src/Parsers/ASTSystemQuery.cpp",
    "src/Parsers/ASTSystemQuery.h",
    "src/Parsers/ASTWatchQuery.h",
    "src/Parsers/ParserAlterQuery.cpp",
    "src/Parsers/ParserCheckQuery.cpp",
    "src/Parsers/ParserCreateQuery.cpp",
    "src/Parsers/ParserDropQuery.cpp",
    "src/Parsers/ParserInsertQuery.cpp",
    "src/Parsers/ParserOptimizeQuery.cpp",
    "src/Parsers/ParserSystemQuery.cpp",
    "src/Parsers/ParserTablePropertiesQuery.cpp",
    "src/Parsers/ParserWatchQuery.cpp",
    "src/Parsers/TablePropertiesQueriesASTs.h",
    "src/Parsers/parseDatabaseAndTableName.cpp",
    "src/Parsers/parseDatabaseAndTableName.h",
    "src/Server/GRPCServer.cpp",
    "src/Storages/LiveView/TemporaryLiveViewCleaner.cpp",
    "src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp",
    "src/Storages/StorageFactory.cpp",
    "src/Storages/StorageMaterializedView.cpp",
    "src/Storages/System/attachInformationSchemaTables.cpp"
  ],
  "modified_test_files": [
    "src/Parsers/tests/gtest_dictionary_parser.cpp",
    "tests/queries/0_stateless/01604_explain_ast_of_nonselect_query.reference",
    "b/tests/queries/0_stateless/02014_query_parameters.reference",
    "b/tests/queries/0_stateless/02014_query_parameters.sh"
  ]
}