{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16584,
  "instance_id": "ClickHouse__ClickHouse-16584",
  "issue_numbers": [
    "16482"
  ],
  "base_commit": "2c8e42c23261ab89de2f8df756ed83e733f45871",
  "patch": "diff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex 4fcd9f122765..af8b751e7872 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -114,7 +114,8 @@ void DatabaseAtomic::dropTable(const Context &, const String & table_name, bool\n         DatabaseWithDictionaries::detachTableUnlocked(table_name, lock);       /// Should never throw\n         table_name_to_path.erase(table_name);\n     }\n-    tryRemoveSymlink(table_name);\n+    if (table->storesDataOnDisk())\n+        tryRemoveSymlink(table_name);\n     /// Remove the inner table (if any) to avoid deadlock\n     /// (due to attempt to execute DROP from the worker thread)\n     if (auto * mv = dynamic_cast<StorageMaterializedView *>(table.get()))\n@@ -145,7 +146,7 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n     String old_metadata_path = getObjectMetadataPath(table_name);\n     String new_metadata_path = to_database.getObjectMetadataPath(to_table_name);\n \n-    auto detach = [](DatabaseAtomic & db, const String & table_name_)\n+    auto detach = [](DatabaseAtomic & db, const String & table_name_, bool has_symlink)\n     {\n         auto it = db.table_name_to_path.find(table_name_);\n         String table_data_path_saved;\n@@ -155,7 +156,7 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n         assert(!table_data_path_saved.empty() || db.dictionaries.find(table_name_) != db.dictionaries.end());\n         db.tables.erase(table_name_);\n         db.table_name_to_path.erase(table_name_);\n-        if (!table_data_path_saved.empty())\n+        if (has_symlink)\n             db.tryRemoveSymlink(table_name_);\n         return table_data_path_saved;\n     };\n@@ -166,7 +167,8 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n         if (table_data_path_.empty())\n             return;\n         db.table_name_to_path.emplace(table_name_, table_data_path_);\n-        db.tryCreateSymlink(table_name_, table_data_path_);\n+        if (table_->storesDataOnDisk())\n+            db.tryCreateSymlink(table_name_, table_data_path_);\n     };\n \n     auto assert_can_move_mat_view = [inside_database](const StoragePtr & table_)\n@@ -228,9 +230,9 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n         renameNoReplace(old_metadata_path, new_metadata_path);\n \n     /// After metadata was successfully moved, the following methods should not throw (if them do, it's a logical error)\n-    table_data_path = detach(*this, table_name);\n+    table_data_path = detach(*this, table_name, table->storesDataOnDisk());\n     if (exchange)\n-        other_table_data_path = detach(other_db, to_table_name);\n+        other_table_data_path = detach(other_db, to_table_name, other_table->storesDataOnDisk());\n \n     auto old_table_id = table->getStorageID();\n \n@@ -286,7 +288,8 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n             DatabaseCatalog::instance().removeUUIDMappingFinally(query.uuid);\n         throw;\n     }\n-    tryCreateSymlink(query.table, table_data_path);\n+    if (table->storesDataOnDisk())\n+        tryCreateSymlink(query.table, table_data_path);\n }\n \n void DatabaseAtomic::commitAlterTable(const StorageID & table_id, const String & table_metadata_tmp_path, const String & table_metadata_path)\n@@ -383,17 +386,18 @@ void DatabaseAtomic::loadStoredObjects(Context & context, bool has_force_restore\n \n         Poco::File(path_to_table_symlinks).createDirectories();\n         for (const auto & table : table_names)\n-            tryCreateSymlink(table.first, table.second);\n+            tryCreateSymlink(table.first, table.second, true);\n     }\n }\n \n-void DatabaseAtomic::tryCreateSymlink(const String & table_name, const String & actual_data_path)\n+void DatabaseAtomic::tryCreateSymlink(const String & table_name, const String & actual_data_path, bool if_data_path_exist)\n {\n     try\n     {\n         String link = path_to_table_symlinks + escapeForFileName(table_name);\n-        String data = Poco::Path(global_context.getPath()).makeAbsolute().toString() + actual_data_path;\n-        Poco::File{data}.linkTo(link, Poco::File::LINK_SYMBOLIC);\n+        Poco::File data = Poco::Path(global_context.getPath()).makeAbsolute().toString() + actual_data_path;\n+        if (!if_data_path_exist || data.exists())\n+            data.linkTo(link, Poco::File::LINK_SYMBOLIC);\n     }\n     catch (...)\n     {\ndiff --git a/src/Databases/DatabaseAtomic.h b/src/Databases/DatabaseAtomic.h\nindex 2d90ed96f1d8..82408ff3ab3a 100644\n--- a/src/Databases/DatabaseAtomic.h\n+++ b/src/Databases/DatabaseAtomic.h\n@@ -55,7 +55,7 @@ class DatabaseAtomic : public DatabaseOrdinary\n \n     UUID tryGetTableUUID(const String & table_name) const override;\n \n-    void tryCreateSymlink(const String & table_name, const String & actual_data_path);\n+    void tryCreateSymlink(const String & table_name, const String & actual_data_path, bool if_data_path_exist = false);\n     void tryRemoveSymlink(const String & table_name);\n \n     void waitDetachedTableNotInUse(const UUID & uuid);\ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 8d9f222bf697..4d7fcd4e2485 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -321,7 +321,7 @@ void DatabaseOnDisk::renameTable(\n \n     /// Special case: usually no actions with symlinks are required when detaching/attaching table,\n     /// but not when moving from Atomic database to Ordinary\n-    if (from_atomic_to_ordinary)\n+    if (from_atomic_to_ordinary && table->storesDataOnDisk())\n     {\n         auto & atomic_db = assert_cast<DatabaseAtomic &>(*this);\n         atomic_db.tryRemoveSymlink(table_name);\ndiff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp\nindex 906863f3f44b..9de938ae184e 100644\n--- a/src/Interpreters/DatabaseCatalog.cpp\n+++ b/src/Interpreters/DatabaseCatalog.cpp\n@@ -134,7 +134,10 @@ void DatabaseCatalog::loadDatabases()\n     loadMarkedAsDroppedTables();\n     auto task_holder = global_context->getSchedulePool().createTask(\"DatabaseCatalog\", [this](){ this->dropTableDataTask(); });\n     drop_task = std::make_unique<BackgroundSchedulePoolTaskHolder>(std::move(task_holder));\n-    (*drop_task)->activateAndSchedule();\n+    (*drop_task)->activate();\n+    std::lock_guard lock{tables_marked_dropped_mutex};\n+    if (!tables_marked_dropped.empty())\n+        (*drop_task)->schedule();\n }\n \n void DatabaseCatalog::shutdownImpl()\n@@ -760,14 +763,15 @@ void DatabaseCatalog::enqueueDroppedTableCleanup(StorageID table_id, StoragePtr\n \n     std::lock_guard lock(tables_marked_dropped_mutex);\n     if (ignore_delay)\n-        tables_marked_dropped.push_front({table_id, table, dropped_metadata_path, 0});\n+        tables_marked_dropped.push_front({table_id, table, dropped_metadata_path, drop_time});\n     else\n-        tables_marked_dropped.push_back({table_id, table, dropped_metadata_path, drop_time});\n+        tables_marked_dropped.push_back({table_id, table, dropped_metadata_path, drop_time + drop_delay_sec});\n     tables_marked_dropped_ids.insert(table_id.uuid);\n     CurrentMetrics::add(CurrentMetrics::TablesToDropQueueSize, 1);\n \n-    /// If list of dropped tables was empty, start a drop task\n-    if (drop_task && tables_marked_dropped.size() == 1)\n+    /// If list of dropped tables was empty, start a drop task.\n+    /// If ignore_delay is set, schedule drop task as soon as possible.\n+    if (drop_task && (tables_marked_dropped.size() == 1 || ignore_delay))\n         (*drop_task)->schedule();\n }\n \n@@ -777,26 +781,40 @@ void DatabaseCatalog::dropTableDataTask()\n     /// Table can be removed when it's not used by queries and drop_delay_sec elapsed since it was marked as dropped.\n \n     bool need_reschedule = true;\n+    /// Default reschedule time for the case when we are waiting for reference count to become 1.\n+    size_t schedule_after_ms = reschedule_time_ms;\n     TableMarkedAsDropped table;\n     try\n     {\n         std::lock_guard lock(tables_marked_dropped_mutex);\n+        assert(!tables_marked_dropped.empty());\n         time_t current_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n+        time_t min_drop_time = std::numeric_limits<time_t>::max();\n+        size_t tables_in_use_count = 0;\n         auto it = std::find_if(tables_marked_dropped.begin(), tables_marked_dropped.end(), [&](const auto & elem)\n         {\n             bool not_in_use = !elem.table || elem.table.unique();\n-            bool old_enough = elem.drop_time + drop_delay_sec < current_time;\n+            bool old_enough = elem.drop_time <= current_time;\n+            min_drop_time = std::min(min_drop_time, elem.drop_time);\n+            tables_in_use_count += !not_in_use;\n             return not_in_use && old_enough;\n         });\n         if (it != tables_marked_dropped.end())\n         {\n             table = std::move(*it);\n-            LOG_INFO(log, \"Will try drop {}\", table.table_id.getNameForLogs());\n+            LOG_INFO(log, \"Have {} tables in drop queue ({} of them are in use), will try drop {}\",\n+                     tables_marked_dropped.size(), tables_in_use_count, table.table_id.getNameForLogs());\n             tables_marked_dropped.erase(it);\n+            /// Schedule the task as soon as possible, while there are suitable tables to drop.\n+            schedule_after_ms = 0;\n         }\n-        else\n+        else if (current_time < min_drop_time)\n         {\n-            LOG_TRACE(log, \"Not found any suitable tables to drop, still have {} tables in drop queue\", tables_marked_dropped.size());\n+            /// We are waiting for drop_delay_sec to exceed, no sense to wakeup until min_drop_time.\n+            /// If new table is added to the queue with ignore_delay flag, schedule() is called to wakeup the task earlier.\n+            schedule_after_ms = (min_drop_time - current_time) * 1000;\n+            LOG_TRACE(log, \"Not found any suitable tables to drop, still have {} tables in drop queue ({} of them are in use). \"\n+                           \"Will check again after {} seconds\", tables_marked_dropped.size(), tables_in_use_count, min_drop_time - current_time);\n         }\n         need_reschedule = !tables_marked_dropped.empty();\n     }\n@@ -820,11 +838,15 @@ void DatabaseCatalog::dropTableDataTask()\n             tryLogCurrentException(log, \"Cannot drop table \" + table.table_id.getNameForLogs() +\n                                         \". Will retry later.\");\n             {\n+                table.drop_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()) + drop_error_cooldown_sec;\n                 std::lock_guard lock(tables_marked_dropped_mutex);\n                 tables_marked_dropped.emplace_back(std::move(table));\n                 /// If list of dropped tables was empty, schedule a task to retry deletion.\n                 if (tables_marked_dropped.size() == 1)\n+                {\n                     need_reschedule = true;\n+                    schedule_after_ms = drop_error_cooldown_sec * 1000;\n+                }\n             }\n         }\n \n@@ -833,7 +855,7 @@ void DatabaseCatalog::dropTableDataTask()\n \n     /// Do not schedule a task if there is no tables to drop\n     if (need_reschedule)\n-        (*drop_task)->scheduleAfter(reschedule_time_ms);\n+        (*drop_task)->scheduleAfter(schedule_after_ms);\n }\n \n void DatabaseCatalog::dropTableFinally(const TableMarkedAsDropped & table)\ndiff --git a/src/Interpreters/DatabaseCatalog.h b/src/Interpreters/DatabaseCatalog.h\nindex d26307a3bc3d..2fd5c8d2be8f 100644\n--- a/src/Interpreters/DatabaseCatalog.h\n+++ b/src/Interpreters/DatabaseCatalog.h\n@@ -234,6 +234,7 @@ class DatabaseCatalog : boost::noncopyable\n     void dropTableFinally(const TableMarkedAsDropped & table);\n \n     static constexpr size_t reschedule_time_ms = 100;\n+    static constexpr time_t drop_error_cooldown_sec = 5;\n \n private:\n     using UUIDToDatabaseMap = std::unordered_map<UUID, DatabasePtr>;\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 836e2d7dcf11..fd73ae2ccd24 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -449,6 +449,10 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     /// We do not use mutex because it is not very important that the size could change during the operation.\n     virtual void checkPartitionCanBeDropped(const ASTPtr & /*partition*/) {}\n \n+    /// Returns true if Storage may store some data on disk.\n+    /// NOTE: may not be equivalent to !getDataPaths().empty()\n+    virtual bool storesDataOnDisk() const { return false; }\n+\n     /// Returns data paths if storage supports it, empty vector otherwise.\n     virtual Strings getDataPaths() const { return {}; }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 5c18661dad13..a8371a2dca2a 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -618,6 +618,7 @@ class MergeTreeData : public IStorage\n     /// `additional_path` can be set if part is not located directly in table data path (e.g. 'detached/')\n     std::optional<String> getFullRelativePathForPart(const String & part_name, const String & additional_path = \"\") const;\n \n+    bool storesDataOnDisk() const override { return true; }\n     Strings getDataPaths() const override;\n \n     using PathsWithDisks = std::vector<PathWithDisk>;\ndiff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h\nindex dd043e5feeb2..5adc4ca56271 100644\n--- a/src/Storages/StorageDistributed.h\n+++ b/src/Storages/StorageDistributed.h\n@@ -82,6 +82,7 @@ class StorageDistributed final : public ext::shared_ptr_helper<StorageDistribute\n     void shutdown() override;\n     void drop() override;\n \n+    bool storesDataOnDisk() const override { return true; }\n     Strings getDataPaths() const override;\n \n     const ExpressionActionsPtr & getShardingKeyExpr() const { return sharding_key_expr; }\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 8c7cd7b63d76..0cc3aa807c4d 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -524,6 +524,11 @@ BlockOutputStreamPtr StorageFile::write(\n         chooseCompressionMethod(path, compression_method), context);\n }\n \n+bool StorageFile::storesDataOnDisk() const\n+{\n+    return is_db_table;\n+}\n+\n Strings StorageFile::getDataPaths() const\n {\n     if (paths.empty())\ndiff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h\nindex f331538b4c79..eb6f0cb4d870 100644\n--- a/src/Storages/StorageFile.h\n+++ b/src/Storages/StorageFile.h\n@@ -46,6 +46,7 @@ class StorageFile final : public ext::shared_ptr_helper<StorageFile>, public ISt\n \n     void rename(const String & new_path_to_table_data, const StorageID & new_table_id) override;\n \n+    bool storesDataOnDisk() const override;\n     Strings getDataPaths() const override;\n \n     struct CommonArguments\ndiff --git a/src/Storages/StorageLog.h b/src/Storages/StorageLog.h\nindex 49fc9a576c5b..306383a12354 100644\n--- a/src/Storages/StorageLog.h\n+++ b/src/Storages/StorageLog.h\n@@ -41,6 +41,7 @@ class StorageLog final : public ext::shared_ptr_helper<StorageLog>, public IStor\n \n     void truncate(const ASTPtr &, const StorageMetadataPtr & metadata_snapshot, const Context &, TableExclusiveLockHolder &) override;\n \n+    bool storesDataOnDisk() const override { return true; }\n     Strings getDataPaths() const override { return {DB::fullPath(disk, table_path)}; }\n \n protected:\ndiff --git a/src/Storages/StorageProxy.h b/src/Storages/StorageProxy.h\nindex 7b010476b22f..e2a6438ecfe6 100644\n--- a/src/Storages/StorageProxy.h\n+++ b/src/Storages/StorageProxy.h\n@@ -144,6 +144,7 @@ class StorageProxy : public IStorage\n     CheckResults checkData(const ASTPtr & query , const Context & context) override { return getNested()->checkData(query, context); }\n     void checkTableCanBeDropped() const override { getNested()->checkTableCanBeDropped(); }\n     void checkPartitionCanBeDropped(const ASTPtr & partition) override { getNested()->checkPartitionCanBeDropped(partition); }\n+    bool storesDataOnDisk() const override { return getNested()->storesDataOnDisk(); }\n     Strings getDataPaths() const override { return getNested()->getDataPaths(); }\n     StoragePolicyPtr getStoragePolicy() const override { return getNested()->getStoragePolicy(); }\n     std::optional<UInt64> totalRows() const override { return getNested()->totalRows(); }\ndiff --git a/src/Storages/StorageSet.h b/src/Storages/StorageSet.h\nindex 98677dcfb155..9a734b50002b 100644\n--- a/src/Storages/StorageSet.h\n+++ b/src/Storages/StorageSet.h\n@@ -24,6 +24,7 @@ class StorageSetOrJoinBase : public IStorage\n \n     BlockOutputStreamPtr write(const ASTPtr & query, const StorageMetadataPtr & /*metadata_snapshot*/, const Context & context) override;\n \n+    bool storesDataOnDisk() const override { return true; }\n     Strings getDataPaths() const override { return {path}; }\n \n protected:\ndiff --git a/src/Storages/StorageStripeLog.h b/src/Storages/StorageStripeLog.h\nindex f88120a932ec..ea2b1693169c 100644\n--- a/src/Storages/StorageStripeLog.h\n+++ b/src/Storages/StorageStripeLog.h\n@@ -40,6 +40,7 @@ class StorageStripeLog final : public ext::shared_ptr_helper<StorageStripeLog>,\n \n     CheckResults checkData(const ASTPtr & /* query */, const Context & /* context */) override;\n \n+    bool storesDataOnDisk() const override { return true; }\n     Strings getDataPaths() const override { return {DB::fullPath(disk, table_path)}; }\n \n     void truncate(const ASTPtr &, const StorageMetadataPtr &, const Context &, TableExclusiveLockHolder&) override;\ndiff --git a/src/Storages/StorageTinyLog.h b/src/Storages/StorageTinyLog.h\nindex dc6ff1015038..39c2994aaedc 100644\n--- a/src/Storages/StorageTinyLog.h\n+++ b/src/Storages/StorageTinyLog.h\n@@ -39,6 +39,7 @@ class StorageTinyLog final : public ext::shared_ptr_helper<StorageTinyLog>, publ\n \n     CheckResults checkData(const ASTPtr & /* query */, const Context & /* context */) override;\n \n+    bool storesDataOnDisk() const override { return true; }\n     Strings getDataPaths() const override { return {DB::fullPath(disk, table_path)}; }\n \n     void truncate(const ASTPtr &, const StorageMetadataPtr & metadata_snapshot, const Context &, TableExclusiveLockHolder &) override;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01114_database_atomic.sh b/tests/queries/0_stateless/01114_database_atomic.sh\nindex d220491d152d..2a3a171b7248 100755\n--- a/tests/queries/0_stateless/01114_database_atomic.sh\n+++ b/tests/queries/0_stateless/01114_database_atomic.sh\n@@ -3,6 +3,7 @@\n CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n . \"$CURDIR\"/../shell_config.sh\n \n+\n $CLICKHOUSE_CLIENT -q \"DROP DATABASE IF EXISTS test_01114_1\"\n $CLICKHOUSE_CLIENT -q \"DROP DATABASE IF EXISTS test_01114_2\"\n $CLICKHOUSE_CLIENT -q \"DROP DATABASE IF EXISTS test_01114_3\"\ndiff --git a/tests/queries/0_stateless/01193_metadata_loading.sh b/tests/queries/0_stateless/01193_metadata_loading.sh\nindex 319b537e84bb..0ee583a72655 100755\n--- a/tests/queries/0_stateless/01193_metadata_loading.sh\n+++ b/tests/queries/0_stateless/01193_metadata_loading.sh\n@@ -49,4 +49,4 @@ $CLICKHOUSE_CLIENT -q \"SELECT if(quantile(0.5)(query_duration_ms) < $max_time_ms\n \n $CLICKHOUSE_CLIENT -q \"SELECT count() * $count_multiplier, i, d, s, n.i, n.f FROM $db.table_merge GROUP BY i, d, s, n.i, n.f ORDER BY i\"\n \n-$CLICKHOUSE_CLIENT -q \"DROP DATABASE $db\" --database_atomic_wait_for_drop_and_detach_synchronously=0\n+$CLICKHOUSE_CLIENT -q \"DROP DATABASE $db\"\n",
  "problem_statement": "Clickhouse create broken symlink for buffer table\nClickhouse from official repo on ubuntu 20.04\r\nclickhouse-server                    20.10.2.20\r\n\r\nAfter create buffer table with name clickhouse_queries_buffer  I see broken symlink from\r\n/var/lib/clickhouse/data/default/clickhouse_queries_buffer\r\nto\r\n/var/lib/clickhouse/store/2a2/2a2feebd-c088-4335-8a36-f92af98f4616\r\n\r\nmaybe its features\r\n\n",
  "hints_text": "This behaviour is Ok but can be improved.",
  "created_at": "2020-11-01T17:40:32Z",
  "modified_files": [
    "src/Databases/DatabaseAtomic.cpp",
    "src/Databases/DatabaseAtomic.h",
    "src/Databases/DatabaseOnDisk.cpp",
    "src/Interpreters/DatabaseCatalog.cpp",
    "src/Interpreters/DatabaseCatalog.h",
    "src/Storages/IStorage.h",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/StorageDistributed.h",
    "src/Storages/StorageFile.cpp",
    "src/Storages/StorageFile.h",
    "src/Storages/StorageLog.h",
    "src/Storages/StorageProxy.h",
    "src/Storages/StorageSet.h",
    "src/Storages/StorageStripeLog.h",
    "src/Storages/StorageTinyLog.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01114_database_atomic.sh",
    "tests/queries/0_stateless/01193_metadata_loading.sh"
  ]
}