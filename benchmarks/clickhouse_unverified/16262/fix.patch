diff --git a/src/Parsers/ParserDataType.cpp b/src/Parsers/ParserDataType.cpp
index a0a4eb97efeb..ee746329bff3 100644
--- a/src/Parsers/ParserDataType.cpp
+++ b/src/Parsers/ParserDataType.cpp
@@ -1,13 +1,38 @@
 #include <Parsers/ParserDataType.h>
-#include <Parsers/ExpressionElementParsers.h>
-#include <Parsers/CommonParsers.h>
+
 #include <Parsers/ASTFunction.h>
 #include <Parsers/ASTIdentifier.h>
+#include <Parsers/CommonParsers.h>
+#include <Parsers/ExpressionElementParsers.h>
 #include <Parsers/ParserCreateQuery.h>
 
+
 namespace DB
 {
 
+namespace
+{
+
+/// Wrapper to allow mixed lists of nested and normal types.
+class ParserNestedTableOrExpression : public IParserBase
+{
+    private:
+        const char * getName() const override { return "data type or expression"; }
+        bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override
+        {
+            ParserNestedTable parser1;
+
+            if (parser1.parse(pos, node, expected))
+                return true;
+
+            ParserExpression parser2;
+
+            return parser2.parse(pos, node, expected);
+        }
+};
+
+}
+
 bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     ParserNestedTable nested;
@@ -78,7 +103,7 @@ bool ParserDataType::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     ++pos;
 
     /// Parse optional parameters
-    ParserList args_parser(std::make_unique<ParserExpression>(), std::make_unique<ParserToken>(TokenType::Comma));
+    ParserList args_parser(std::make_unique<ParserNestedTableOrExpression>(), std::make_unique<ParserToken>(TokenType::Comma));
     ASTPtr expr_list_args;
 
     if (!args_parser.parse(pos, expr_list_args, expected))
