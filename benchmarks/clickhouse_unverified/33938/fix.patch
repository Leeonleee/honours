diff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp
index 36731a3acd0e..f9a5c7be75f5 100644
--- a/src/Parsers/ASTFunction.cpp
+++ b/src/Parsers/ASTFunction.cpp
@@ -32,6 +32,15 @@ void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr) const
     if (name == "view")
         throw Exception("Table function view cannot be used as an expression", ErrorCodes::UNEXPECTED_EXPRESSION);
 
+    /// If function can be converted to literal it will be parsed as literal after formatting.
+    /// In distributed query it may lead to mismathed column names.
+    /// To avoid it we check whether we can convert function to literal.
+    if (auto literal = toLiteral())
+    {
+        literal->appendColumnName(ostr);
+        return;
+    }
+
     writeString(name, ostr);
 
     if (parameters)
@@ -111,32 +120,43 @@ void ASTFunction::updateTreeHashImpl(SipHash & hash_state) const
     IAST::updateTreeHashImpl(hash_state);
 }
 
-
-ASTPtr ASTFunction::toLiteral() const
+template <typename Container>
+static ASTPtr createLiteral(const ASTs & arguments)
 {
-    if (!arguments) return {};
+    Container container;
 
-    if (name == "array")
+    for (const auto & arg : arguments)
     {
-        Array array;
-
-        for (const auto & arg : arguments->children)
+        if (const auto * literal = arg->as<ASTLiteral>())
         {
-            if (auto * literal = arg->as<ASTLiteral>())
-                array.push_back(literal->value);
-            else if (auto * func = arg->as<ASTFunction>())
-            {
-                if (auto func_literal = func->toLiteral())
-                    array.push_back(func_literal->as<ASTLiteral>()->value);
-            }
+            container.push_back(literal->value);
+        }
+        else if (auto * func = arg->as<ASTFunction>())
+        {
+            if (auto func_literal = func->toLiteral())
+                container.push_back(func_literal->as<ASTLiteral>()->value);
             else
-                /// Some of the Array arguments is not literal
                 return {};
         }
-
-        return std::make_shared<ASTLiteral>(array);
+        else
+            /// Some of the Array or Tuple arguments is not literal
+            return {};
     }
 
+    return std::make_shared<ASTLiteral>(container);
+}
+
+ASTPtr ASTFunction::toLiteral() const
+{
+    if (!arguments)
+        return {};
+
+    if (name == "array")
+        return createLiteral<Array>(arguments->children);
+
+    if (name == "tuple")
+        return createLiteral<Tuple>(arguments->children);
+
     return {};
 }
 
