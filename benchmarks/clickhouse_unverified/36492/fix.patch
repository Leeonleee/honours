diff --git a/programs/keeper/keeper_config.xml b/programs/keeper/keeper_config.xml
index bb80850d01e3..3d728e2bfdf1 100644
--- a/programs/keeper/keeper_config.xml
+++ b/programs/keeper/keeper_config.xml
@@ -44,6 +44,8 @@
                 <!-- All settings listed in https://github.com/ClickHouse/ClickHouse/blob/master/src/Coordination/CoordinationSettings.h -->
             </coordination_settings>
 
+            <!-- enable sanity hostname checks for cluster configuration (e.g. if localhost is used with remote endpoints) -->
+            <hostname_checks_enabled>true</hostname_checks_enabled>
             <raft_configuration>
                 <server>
                     <id>1</id>
diff --git a/src/Coordination/KeeperStateManager.cpp b/src/Coordination/KeeperStateManager.cpp
index 7304f7e0e6bd..aad37049a89b 100644
--- a/src/Coordination/KeeperStateManager.cpp
+++ b/src/Coordination/KeeperStateManager.cpp
@@ -1,10 +1,10 @@
 #include <Coordination/KeeperStateManager.h>
 
+#include <filesystem>
 #include <Coordination/Defines.h>
+#include <Common/DNSResolver.h>
 #include <Common/Exception.h>
-#include <filesystem>
 #include <Common/isLocalAddress.h>
-#include <Common/DNSResolver.h>
 
 namespace DB
 {
@@ -17,20 +17,6 @@ namespace ErrorCodes
 namespace
 {
 
-bool isLoopback(const std::string & hostname)
-{
-    try
-    {
-        return DNSResolver::instance().resolveHost(hostname).isLoopback();
-    }
-    catch (...)
-    {
-        tryLogCurrentException(__PRETTY_FUNCTION__);
-    }
-
-    return false;
-}
-
 bool isLocalhost(const std::string & hostname)
 {
     try
@@ -47,18 +33,19 @@ bool isLocalhost(const std::string & hostname)
 
 std::unordered_map<UInt64, std::string> getClientPorts(const Poco::Util::AbstractConfiguration & config)
 {
-    static const char * config_port_names[] = {
-        "keeper_server.tcp_port",
-        "keeper_server.tcp_port_secure",
-        "interserver_http_port",
-        "interserver_https_port",
-        "tcp_port",
-        "tcp_with_proxy_port",
-        "tcp_port_secure",
-        "mysql_port",
-        "postgresql_port",
-        "grpc_port",
-        "prometheus.port",
+    using namespace std::string_literals;
+    static const std::array config_port_names = {
+        "keeper_server.tcp_port"s,
+        "keeper_server.tcp_port_secure"s,
+        "interserver_http_port"s,
+        "interserver_https_port"s,
+        "tcp_port"s,
+        "tcp_with_proxy_port"s,
+        "tcp_port_secure"s,
+        "mysql_port"s,
+        "postgresql_port"s,
+        "grpc_port"s,
+        "prometheus.port"s,
     };
 
     std::unordered_map<UInt64, std::string> ports;
@@ -78,8 +65,11 @@ std::unordered_map<UInt64, std::string> getClientPorts(const Poco::Util::Abstrac
 /// 3. Raft internal port is not equal to any other port for client
 /// 4. No duplicate IDs
 /// 5. Our ID present in hostnames list
-KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersConfiguration(const Poco::Util::AbstractConfiguration & config, bool allow_without_us) const
+KeeperStateManager::KeeperConfigurationWrapper
+KeeperStateManager::parseServersConfiguration(const Poco::Util::AbstractConfiguration & config, bool allow_without_us) const
 {
+    const bool hostname_checks_enabled = config.getBool(config_prefix + ".hostname_checks_enabled", true);
+
     KeeperConfigurationWrapper result;
     result.cluster_config = std::make_shared<nuraft::cluster_config>();
     Poco::Util::AbstractConfiguration::Keys keys;
@@ -93,7 +83,7 @@ KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersC
     std::unordered_map<std::string, int> check_duplicated_hostnames;
 
     size_t total_servers = 0;
-    std::string loopback_hostname;
+    bool localhost_present = false;
     std::string non_local_hostname;
     size_t local_address_counter = 0;
     for (const auto & server_key : keys)
@@ -111,22 +101,29 @@ KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersC
 
         if (client_ports.contains(port))
         {
-            throw Exception(ErrorCodes::RAFT_ERROR, "Raft configuration contains hostname '{}' with port '{}' which is equal to '{}' in server configuration",
-                            hostname, port, client_ports[port]);
+            throw Exception(
+                ErrorCodes::RAFT_ERROR,
+                "Raft configuration contains hostname '{}' with port '{}' which is equal to '{}' in server configuration",
+                hostname,
+                port,
+                client_ports[port]);
         }
 
-        if (isLoopback(hostname))
+        if (hostname_checks_enabled)
         {
-            loopback_hostname = hostname;
-            local_address_counter++;
-        }
-        else if (isLocalhost(hostname))
-        {
-            local_address_counter++;
-        }
-        else
-        {
-            non_local_hostname = hostname;
+            if (hostname == "localhost")
+            {
+                localhost_present = true;
+                local_address_counter++;
+            }
+            else if (isLocalhost(hostname))
+            {
+                local_address_counter++;
+            }
+            else
+            {
+                non_local_hostname = hostname;
+            }
         }
 
         if (start_as_follower)
@@ -135,9 +132,13 @@ KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersC
         auto endpoint = hostname + ":" + std::to_string(port);
         if (check_duplicated_hostnames.contains(endpoint))
         {
-            throw Exception(ErrorCodes::RAFT_ERROR, "Raft config contains duplicate endpoints: "
-                            "endpoint {} has been already added with id {}, but going to add it one more time with id {}",
-                            endpoint, check_duplicated_hostnames[endpoint], new_server_id);
+            throw Exception(
+                ErrorCodes::RAFT_ERROR,
+                "Raft config contains duplicate endpoints: "
+                "endpoint {} has been already added with id {}, but going to add it one more time with id {}",
+                endpoint,
+                check_duplicated_hostnames[endpoint],
+                new_server_id);
         }
         else
         {
@@ -145,8 +146,13 @@ KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersC
             for (const auto & [id_endpoint, id] : check_duplicated_hostnames)
             {
                 if (new_server_id == id)
-                    throw Exception(ErrorCodes::RAFT_ERROR, "Raft config contains duplicate ids: id {} has been already added with endpoint {}, "
-                                    "but going to add it one more time with endpoint {}", id, id_endpoint, endpoint);
+                    throw Exception(
+                        ErrorCodes::RAFT_ERROR,
+                        "Raft config contains duplicate ids: id {} has been already added with endpoint {}, "
+                        "but going to add it one more time with endpoint {}",
+                        id,
+                        id_endpoint,
+                        endpoint);
             }
             check_duplicated_hostnames.emplace(endpoint, new_server_id);
         }
@@ -168,31 +174,33 @@ KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersC
     if (result.servers_start_as_followers.size() == total_servers)
         throw Exception(ErrorCodes::RAFT_ERROR, "At least one of servers should be able to start as leader (without <start_as_follower>)");
 
-    if (!loopback_hostname.empty() && !non_local_hostname.empty())
+    if (hostname_checks_enabled)
     {
-        throw Exception(
-            ErrorCodes::RAFT_ERROR,
-            "Mixing loopback and non-local hostnames ('{}' and '{}') in raft_configuration is not allowed. "
-            "Different hosts can resolve it to themselves so it's not allowed.",
-            loopback_hostname, non_local_hostname);
-    }
+        if (localhost_present && !non_local_hostname.empty())
+        {
+            throw Exception(
+                ErrorCodes::RAFT_ERROR,
+                "Mixing 'localhost' and non-local hostnames ('{}') in raft_configuration is not allowed. "
+                "Different hosts can resolve 'localhost' to themselves so it's not allowed.",
+                non_local_hostname);
+        }
 
-    if (!non_local_hostname.empty() && local_address_counter > 1)
-    {
-        throw Exception(
-            ErrorCodes::RAFT_ERROR,
-            "Local address specified more than once ({} times) and non-local hostnames also exists ('{}') in raft_configuration. "
-            "Such configuration is not allowed because single host can vote multiple times.",
-            local_address_counter, non_local_hostname);
+        if (!non_local_hostname.empty() && local_address_counter > 1)
+        {
+            throw Exception(
+                ErrorCodes::RAFT_ERROR,
+                "Local address specified more than once ({} times) and non-local hostnames also exists ('{}') in raft_configuration. "
+                "Such configuration is not allowed because single host can vote multiple times.",
+                local_address_counter,
+                non_local_hostname);
+        }
     }
 
     return result;
 }
 
 KeeperStateManager::KeeperStateManager(int server_id_, const std::string & host, int port, const std::string & logs_path)
-: my_server_id(server_id_)
-, secure(false)
-, log_store(nuraft::cs_new<KeeperLogStore>(logs_path, 5000, false, false))
+    : my_server_id(server_id_), secure(false), log_store(nuraft::cs_new<KeeperLogStore>(logs_path, 5000, false, false))
 {
     auto peer_config = nuraft::cs_new<nuraft::srv_config>(my_server_id, host + ":" + std::to_string(port));
     configuration_wrapper.cluster_config = nuraft::cs_new<nuraft::cluster_config>();
@@ -212,10 +220,10 @@ KeeperStateManager::KeeperStateManager(
     , config_prefix(config_prefix_)
     , configuration_wrapper(parseServersConfiguration(config, false))
     , log_store(nuraft::cs_new<KeeperLogStore>(
-                    log_storage_path,
-                    coordination_settings->rotate_log_storage_interval,
-                    coordination_settings->force_sync,
-                    coordination_settings->compress_logs))
+          log_storage_path,
+          coordination_settings->rotate_log_storage_interval,
+          coordination_settings->force_sync,
+          coordination_settings->compress_logs))
 {
 }
 
