{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38935,
  "instance_id": "ClickHouse__ClickHouse-38935",
  "issue_numbers": [
    "38833"
  ],
  "base_commit": "4f8cc871eb9360345f80c4535d81250dca63ad8c",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-replace-functions.md b/docs/en/sql-reference/functions/string-replace-functions.md\nindex 08fd979ce8f1..3cd9bdf8ff55 100644\n--- a/docs/en/sql-reference/functions/string-replace-functions.md\n+++ b/docs/en/sql-reference/functions/string-replace-functions.md\n@@ -93,3 +93,35 @@ Predefined characters: `\\0`, `\\\\`, `|`, `(`, `)`, `^`, `$`, `.`, `[`, `]`, `?`,\n This implementation slightly differs from re2::RE2::QuoteMeta. It escapes zero byte as `\\0` instead of `\\x00` and it escapes only required characters.\n For more information, see the link: [RE2](https://github.com/google/re2/blob/master/re2/re2.cc#L473)\n \n+\n+## translate(s, from, to)\n+\n+The function replaces characters in the string \u2018s\u2019 in accordance with one-to-one character mapping defined by \u2018from\u2019 and \u2018to\u2019 strings. \u2018from\u2019 and \u2018to\u2019 must be ASCII strings of the same size. Non-ASCII characters in the original string are not modified.\n+\n+Example:\n+\n+``` sql\n+SELECT translate('Hello, World!', 'delor', 'DELOR') AS res\n+```\n+\n+``` text\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 HELLO, WORLD! \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## translateUTF8(string, from, to)\n+\n+Similar to previous function, but works with UTF-8 arguments. \u2018from\u2019 and \u2018to\u2019 must be valid UTF-8 strings of the same size.\n+\n+Example:\n+\n+``` sql\n+SELECT translateUTF8('H\u00e9ll\u00f3, W\u00f3rld\u00a1', '\u00f3\u00e9\u00a1', 'oe!') AS res\n+```\n+\n+``` text\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 Hello, World! \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/docs/ru/sql-reference/functions/string-replace-functions.md b/docs/ru/sql-reference/functions/string-replace-functions.md\nindex dbcdb2e902b0..1bbb68f90145 100644\n--- a/docs/ru/sql-reference/functions/string-replace-functions.md\n+++ b/docs/ru/sql-reference/functions/string-replace-functions.md\n@@ -83,3 +83,34 @@ SELECT replaceRegexpAll('Hello, World!', '^', 'here: ') AS res\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## translate(s, from, to)\n+\n+\u0414\u0430\u043d\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0432 \u0441\u0442\u0440\u043e\u043a\u0435 \u2018s\u2019 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u043f\u043e\u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043d\u044b\u043c \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\u043c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c\u044b\u043c \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438 \u2018from\u2019 \u0438 \u2018to\u2019. \u2018from\u2019 \u0438 \u2018to\u2019 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u043c\u0438 ASCII \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438 \u043e\u0434\u043d\u043e\u0433\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0430. \u041d\u0435 ASCII \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u0432 \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u044e\u0442\u0441\u044f.\n+\n+Example:\n+\n+``` sql\n+SELECT translate('Hello, World!', 'delor', 'DELOR') AS res\n+```\n+\n+``` text\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 HELLO, WORLD! \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## translateUTF8(string, from, to)\n+\n+\u0410\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438, \u043d\u043e \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0441\u043e \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0438\u043c\u0438 \u0438\u0437 UTF-8 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432. \u2018from\u2019 \u0438 \u2018to\u2019 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u043c\u0438 UTF-8 \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438 \u043e\u0434\u043d\u043e\u0433\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0430.\n+\n+Example:\n+\n+``` sql\n+SELECT translateUTF8('H\u00e9ll\u00f3, W\u00f3rld\u00a1', '\u00f3\u00e9\u00a1', 'oe!') AS res\n+```\n+\n+``` text\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 Hello, World! \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Functions/registerFunctionsStringRegexp.cpp b/src/Functions/registerFunctionsStringRegexp.cpp\nindex 61853b19d118..df7e8f583960 100644\n--- a/src/Functions/registerFunctionsStringRegexp.cpp\n+++ b/src/Functions/registerFunctionsStringRegexp.cpp\n@@ -9,6 +9,7 @@ void registerFunctionNotLike(FunctionFactory &);\n void registerFunctionNotILike(FunctionFactory &);\n void registerFunctionMatch(FunctionFactory &);\n void registerFunctionExtract(FunctionFactory &);\n+void registerFunctionTranslate(FunctionFactory &);\n void registerFunctionReplaceOne(FunctionFactory &);\n void registerFunctionReplaceAll(FunctionFactory &);\n void registerFunctionReplaceRegexpOne(FunctionFactory &);\n@@ -31,6 +32,7 @@ void registerFunctionsStringRegexp(FunctionFactory & factory)\n     registerFunctionNotILike(factory);\n     registerFunctionMatch(factory);\n     registerFunctionExtract(factory);\n+    registerFunctionTranslate(factory);\n     registerFunctionReplaceOne(factory);\n     registerFunctionReplaceAll(factory);\n     registerFunctionReplaceRegexpOne(factory);\ndiff --git a/src/Functions/translate.cpp b/src/Functions/translate.cpp\nnew file mode 100644\nindex 000000000000..8342bfe236b9\n--- /dev/null\n+++ b/src/Functions/translate.cpp\n@@ -0,0 +1,364 @@\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnConst.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Common/StringUtils/StringUtils.h>\n+#include <Common/UTF8Helpers.h>\n+#include <Common/HashTable/HashMap.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+struct TranslateImpl\n+{\n+    using Map = std::array<UInt8, 128>;\n+\n+    static void fillMapWithValues(\n+        Map & map,\n+        const std::string & map_from,\n+        const std::string & map_to)\n+    {\n+        if (map_from.size() != map_to.size())\n+            throw Exception(\"Second and trird arguments must be the same length\", ErrorCodes::BAD_ARGUMENTS);\n+\n+        std::iota(map.begin(), map.end(), 0);\n+\n+        for (size_t i = 0; i < map_from.size(); ++i)\n+        {\n+            if (!isASCII(map_from[i]) || !isASCII(map_to[i]))\n+                throw Exception(\"Second and trird arguments must be ASCII strings\", ErrorCodes::BAD_ARGUMENTS);\n+\n+            map[map_from[i]] = map_to[i];\n+        }\n+    }\n+\n+    static void vector(\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        const std::string & map_from,\n+        const std::string & map_to,\n+        ColumnString::Chars & res_data,\n+        ColumnString::Offsets & res_offsets)\n+    {\n+        Map map;\n+        fillMapWithValues(map, map_from, map_to);\n+\n+        res_data.resize(data.size());\n+        res_offsets.assign(offsets);\n+\n+        UInt8 * dst = res_data.data();\n+\n+        for (UInt64 i = 0; i < offsets.size(); ++i)\n+        {\n+            const UInt8 * src = data.data() + offsets[i - 1];\n+            const UInt8 * src_end = data.data() + offsets[i] - 1;\n+\n+            while (src < src_end)\n+            {\n+                if (*src <= ascii_upper_bound)\n+                    *dst = map[*src];\n+                else\n+                    *dst = *src;\n+\n+                ++src;\n+                ++dst;\n+            }\n+\n+            /// Technically '\\0' can be mapped into other character,\n+            ///  so we need to process '\\0' delimiter separately\n+            *dst++ = 0;\n+        }\n+    }\n+\n+    static void vectorFixed(\n+        const ColumnString::Chars & data,\n+        size_t /*n*/,\n+        const std::string & map_from,\n+        const std::string & map_to,\n+        ColumnString::Chars & res_data)\n+    {\n+        std::array<UInt8, 128> map;\n+        fillMapWithValues(map, map_from, map_to);\n+\n+        res_data.resize(data.size());\n+\n+        const UInt8 * src = data.data();\n+        const UInt8 * src_end = data.data() + data.size();\n+        UInt8 * dst = res_data.data();\n+\n+        while (src < src_end)\n+        {\n+            if (*src <= ascii_upper_bound)\n+                *dst = map[*src];\n+            else\n+                *dst = *src;\n+\n+            ++src;\n+            ++dst;\n+        }\n+    }\n+\n+private:\n+    static constexpr auto ascii_upper_bound = '\\x7f';\n+};\n+\n+struct TranslateUTF8Impl\n+{\n+    using MapASCII = std::array<UInt32, 128>;\n+    using MapUTF8 = HashMap<UInt32, UInt32, HashCRC32<UInt32>>;\n+\n+    static void fillMapWithValues(\n+        MapASCII & map_ascii,\n+        MapUTF8 & map,\n+        const std::string & map_from,\n+        const std::string & map_to)\n+    {\n+        auto map_from_size = UTF8::countCodePoints(reinterpret_cast<const UInt8 *>(map_from.data()), map_from.size());\n+        auto map_to_size = UTF8::countCodePoints(reinterpret_cast<const UInt8 *>(map_to.data()), map_to.size());\n+\n+        if (map_from_size != map_to_size)\n+            throw Exception(\"Second and trird arguments must be the same length\", ErrorCodes::BAD_ARGUMENTS);\n+\n+        std::iota(map_ascii.begin(), map_ascii.end(), 0);\n+\n+        const UInt8 * map_from_ptr = reinterpret_cast<const UInt8 *>(map_from.data());\n+        const UInt8 * map_from_end = map_from_ptr + map_from.size();\n+        const UInt8 * map_to_ptr = reinterpret_cast<const UInt8 *>(map_to.data());\n+        const UInt8 * map_to_end = map_to_ptr + map_to.size();\n+\n+        while (map_from_ptr < map_from_end && map_to_ptr < map_to_end)\n+        {\n+            size_t len_from = UTF8::seqLength(*map_from_ptr);\n+            size_t len_to = UTF8::seqLength(*map_to_ptr);\n+\n+            std::optional<UInt32> res_from, res_to;\n+\n+            if (map_from_ptr + len_from <= map_from_end)\n+                res_from = UTF8::convertUTF8ToCodePoint(map_from_ptr, len_from);\n+\n+            if (map_to_ptr + len_to <= map_to_end)\n+                res_to = UTF8::convertUTF8ToCodePoint(map_to_ptr, len_to);\n+\n+            if (!res_from)\n+                throw Exception(\"Second argument must be a valid UTF-8 string\", ErrorCodes::BAD_ARGUMENTS);\n+\n+            if (!res_to)\n+                throw Exception(\"Third argument must be a valid UTF-8 string\", ErrorCodes::BAD_ARGUMENTS);\n+\n+            if (*map_from_ptr <= ascii_upper_bound)\n+                map_ascii[*map_from_ptr] = *res_to;\n+            else\n+                map[*res_from] = *res_to;\n+\n+            map_from_ptr += len_from;\n+            map_to_ptr += len_to;\n+        }\n+    }\n+\n+    static void vector(\n+        const ColumnString::Chars & data,\n+        const ColumnString::Offsets & offsets,\n+        const std::string & map_from,\n+        const std::string & map_to,\n+        ColumnString::Chars & res_data,\n+        ColumnString::Offsets & res_offsets)\n+    {\n+        MapASCII map_ascii;\n+        MapUTF8 map;\n+        fillMapWithValues(map_ascii, map, map_from, map_to);\n+\n+        res_data.resize(data.size());\n+        res_offsets.resize(offsets.size());\n+\n+        UInt8 * dst = res_data.data();\n+        UInt64 data_size = 0;\n+\n+        for (UInt64 i = 0; i < offsets.size(); ++i)\n+        {\n+            const UInt8 * src = data.data() + offsets[i - 1];\n+            const UInt8 * src_end = data.data() + offsets[i] - 1;\n+\n+            while (src < src_end)\n+            {\n+                /// Maximum length of UTF-8 sequence is 4 bytes + 1 zero byte\n+                if (data_size + 5 > res_data.size())\n+                {\n+                    res_data.resize(data_size * 2 + 5);\n+                    dst = res_data.data() + data_size;\n+                }\n+\n+                if (*src <= ascii_upper_bound)\n+                {\n+                    size_t dst_len = UTF8::convertCodePointToUTF8(map_ascii[*src], dst, 4);\n+                    assert(0 < dst_len && dst_len <= 4);\n+\n+                    src += 1;\n+                    dst += dst_len;\n+                    data_size += dst_len;\n+                    continue;\n+                }\n+\n+                size_t src_len = UTF8::seqLength(*src);\n+                assert(0 < src_len && src_len <= 4);\n+\n+                if (src + src_len <= src_end)\n+                {\n+                    auto src_code_point = UTF8::convertUTF8ToCodePoint(src, src_len);\n+\n+                    if (src_code_point)\n+                    {\n+                        auto * it = map.find(*src_code_point);\n+                        if (it != map.end())\n+                        {\n+                            size_t dst_len = UTF8::convertCodePointToUTF8(it->getMapped(), dst, 4);\n+                            assert(0 < dst_len && dst_len <= 4);\n+\n+                            src += src_len;\n+                            dst += dst_len;\n+                            data_size += dst_len;\n+                            continue;\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    src_len = src_end - src;\n+                }\n+\n+                memcpy(dst, src, src_len);\n+                dst += src_len;\n+                src += src_len;\n+                data_size += src_len;\n+            }\n+\n+            /// Technically '\\0' can be mapped into other character,\n+            ///  so we need to process '\\0' delimiter separately\n+            *dst++ = 0;\n+\n+            ++data_size;\n+            res_offsets[i] = data_size;\n+        }\n+\n+        res_data.resize(data_size);\n+    }\n+\n+    [[noreturn]] static void vectorFixed(\n+        const ColumnString::Chars & /*data*/,\n+        size_t /*n*/,\n+        const std::string & /*map_from*/,\n+        const std::string & /*map_to*/,\n+        ColumnString::Chars & /*res_data*/)\n+    {\n+        throw Exception(\"Function translateUTF8 does not support FixedString argument\", ErrorCodes::BAD_ARGUMENTS);\n+    }\n+\n+private:\n+    static constexpr auto ascii_upper_bound = '\\x7f';\n+};\n+\n+\n+template <typename Impl, typename Name>\n+class FunctionTranslate : public IFunction\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTranslate>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 3; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        if (!isStringOrFixedString(arguments[0]))\n+            throw Exception(\n+                \"Illegal type \" + arguments[0]->getName() + \" of first argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        if (!isStringOrFixedString(arguments[1]))\n+            throw Exception(\n+                \"Illegal type \" + arguments[1]->getName() + \" of second argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        if (!isStringOrFixedString(arguments[2]))\n+            throw Exception(\n+                \"Illegal type \" + arguments[2]->getName() + \" of third argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    {\n+        const ColumnPtr column_src = arguments[0].column;\n+        const ColumnPtr column_map_from = arguments[1].column;\n+        const ColumnPtr column_map_to = arguments[2].column;\n+\n+        if (!isColumnConst(*column_map_from) || !isColumnConst(*column_map_to))\n+            throw Exception(\"2nd and 3rd arguments of function \" + getName() + \" must be constants.\", ErrorCodes::ILLEGAL_COLUMN);\n+\n+        const IColumn * c1 = arguments[1].column.get();\n+        const IColumn * c2 = arguments[2].column.get();\n+        const ColumnConst * c1_const = typeid_cast<const ColumnConst *>(c1);\n+        const ColumnConst * c2_const = typeid_cast<const ColumnConst *>(c2);\n+        String map_from = c1_const->getValue<String>();\n+        String map_to = c2_const->getValue<String>();\n+\n+        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column_src.get()))\n+        {\n+            auto col_res = ColumnString::create();\n+            Impl::vector(col->getChars(), col->getOffsets(), map_from, map_to, col_res->getChars(), col_res->getOffsets());\n+            return col_res;\n+        }\n+        else if (const ColumnFixedString * col_fixed = checkAndGetColumn<ColumnFixedString>(column_src.get()))\n+        {\n+            auto col_res = ColumnFixedString::create(col_fixed->getN());\n+            Impl::vectorFixed(col_fixed->getChars(), col_fixed->getN(), map_from, map_to, col_res->getChars());\n+            return col_res;\n+        }\n+        else\n+            throw Exception(\n+                \"Illegal column \" + arguments[0].column->getName() + \" of first argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_COLUMN);\n+    }\n+};\n+\n+\n+namespace\n+{\n+\n+struct NameTranslate\n+{\n+    static constexpr auto name = \"translate\";\n+};\n+\n+struct NameTranslateUTF8\n+{\n+    static constexpr auto name = \"translateUTF8\";\n+};\n+\n+using FunctionTranslateASCII = FunctionTranslate<TranslateImpl, NameTranslate>;\n+using FunctionTranslateUTF8 = FunctionTranslate<TranslateUTF8Impl, NameTranslateUTF8>;\n+\n+}\n+\n+void registerFunctionTranslate(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionTranslateASCII>();\n+    factory.registerFunction<FunctionTranslateUTF8>();\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02353_translate.reference b/tests/queries/0_stateless/02353_translate.reference\nnew file mode 100644\nindex 000000000000..557b51821270\n--- /dev/null\n+++ b/tests/queries/0_stateless/02353_translate.reference\n@@ -0,0 +1,16 @@\n+Hello, world!\n+cagaacgttc\n+jihgfe\n+jihgff\n+jihgfg\n+jihgfh\n+jihgfi\n+HotelGenev\n+\u30fc\u30c9\u3068\u306f\n+\u00bf\u0439\u00f0\u0545\u09a8\ud801\udc0f\n+\u00bf\u0439\u00f0\u0545\u09a8\u09a8\n+\u00bf\u0439\u00f0\u0545\u09a8\u0545\n+\u00bf\u0439\u00f0\u0545\u09a8\u00f0\n+\u00bf\u0439\u00f0\u0545\u09a8\u0439\n+abc\n+abc\ndiff --git a/tests/queries/0_stateless/02353_translate.sql b/tests/queries/0_stateless/02353_translate.sql\nnew file mode 100644\nindex 000000000000..a7059ec85a7b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02353_translate.sql\n@@ -0,0 +1,13 @@\n+SELECT translate('Hello? world.', '.?', '!,');\n+SELECT translate('gtcttgcaag', 'ACGTacgt', 'TGCAtgca');\n+SELECT translate(toString(number), '0123456789', 'abcdefghij') FROM numbers(987654, 5);\n+\n+SELECT translateUTF8('H\u00f4telGen\u00e8v', '\u00c1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f4\u00e8', 'aaeiouoe');\n+SELECT translateUTF8('\u4e2d\u6587\u5185\u7801', '\u4e45\u6807\u51c6\u4e2d\u6587\u5185\u7801', '\u30e6\u30cb\u30b3\u30fc\u30c9\u3068\u306f');\n+SELECT translateUTF8(toString(number), '1234567890', '\u12e9\u092f\ud801\udc7f\ud801\udc0f\u09a8\u0545\u00f0\u0439\u00bf\u0e04') FROM numbers(987654, 5);\n+\n+SELECT translate('abc', '', '');\n+SELECT translateUTF8('abc', '', '');\n+\n+SELECT translate('abc', '\u00c1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f4\u00e8', 'aaeiouoe'); -- { serverError 36 }\n+SELECT translateUTF8('abc', 'efg', ''); -- { serverError 36 }\n",
  "problem_statement": "Multireplace / Transliterate? \n> (you don't have to strictly follow this form)\r\n\r\n**Use case**\r\n\r\nChange the used aphabet for some encoding (see https://github.com/ClickHouse/ClickHouse/issues/38832,  https://github.com/ClickHouse/ClickHouse/issues/38002 etc), implement  Caesar cipher, change DNA to RNA etc. \r\n\r\n:) \r\n\r\n**Describe the solution you'd like**\r\n\r\nSomething similar to  [`tr` operator in perl](https://perldoc.perl.org/perlop#tr/SEARCHLIST/REPLACEMENTLIST/cdsr) \r\n\r\nSingle pass through the string with all replaces applied. \r\n\r\n```\r\nSelect transliterate(dna, 'ACGTacgt', 'TGCAtgca') AS rna\r\n-- if first arg have some characters listed in the   second arg, then they will be replaced by corresponding chars from the third arg\r\n-- other characters are passed as is\r\n```\r\n\r\nOr more expressive (but more noisy) format with map\r\n\r\n```\r\nSelect transliterate(dna,{ 'A' :'T', 'C' :'G',...}) AS rna\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nSequence of replace calls - when aphabet is long (like base64) it looks ugly, and create a lot of copies of the string, so slow. \r\n\n",
  "hints_text": "Should be pretty easy to implement.\r\nThe name is either `transliterate` or `replaceCharacters`.\r\nWith plain and `-UTF8` variant.\r\n\r\nThe plain variant can be implemented by a lookup table and UTF-8 with a hash table.\r\n\r\nPS. I would like to have first-class support for base64 for URL.\nBTW, oracle rdbms has similar function and it named `translate`\r\n\r\nhttps://www.oracletutorial.com/oracle-string-functions/oracle-translate/\nPG as well https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-translate/\r\n\r\n```\r\npsql> SELECT TRANSLATE('11-22', '12', 'ab');\r\n translate\r\n-----------\r\n aa-bb\r\n(1 row)\r\n```\n> PS. I would like to have first-class support for base64 for URL.\r\n\r\nsure. That just reminded me that I used in the past at least 4 different options for base64 alphabets (standard, URL-safe, another variant of URL-safe, and the one to preserve the monotonicity).  \nRelated https://github.com/ClickHouse/ClickHouse/issues/28520",
  "created_at": "2022-07-07T00:07:19Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-replace-functions.md",
    "docs/ru/sql-reference/functions/string-replace-functions.md",
    "src/Functions/registerFunctionsStringRegexp.cpp",
    "b/src/Functions/translate.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02353_translate.reference",
    "b/tests/queries/0_stateless/02353_translate.sql"
  ]
}