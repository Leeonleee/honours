{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10715,
  "instance_id": "ClickHouse__ClickHouse-10715",
  "issue_numbers": [
    "8427"
  ],
  "base_commit": "eeac7aa31366f8609f30cd690ac17518c6282615",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 580c95b34dd2..c0785899aab6 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -813,6 +813,14 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreams(\n     return res;\n }\n \n+static ExpressionActionsPtr createProjection(const Pipe & pipe, const MergeTreeData & data)\n+{\n+    const auto & header = pipe.getHeader();\n+    auto projection = std::make_shared<ExpressionActions>(header.getNamesAndTypesList(), data.global_context);\n+    projection->add(ExpressionAction::project(header.getNames()));\n+    return projection;\n+}\n+\n Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n     RangesInDataParts && parts,\n     size_t num_streams,\n@@ -999,13 +1007,19 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n                 sort_description.emplace_back(data.sorting_key_columns[j],\n                     input_sorting_info->direction, 1);\n \n+            /// Project input columns to drop columns from sorting_key_prefix_expr\n+            /// to allow execute the same expression later.\n+            /// NOTE: It may lead to double computation of expression.\n+            auto projection = createProjection(pipes.back(), data);\n             for (auto & pipe : pipes)\n                 pipe.addSimpleTransform(std::make_shared<ExpressionTransform>(pipe.getHeader(), sorting_key_prefix_expr));\n \n             auto merging_sorted = std::make_shared<MergingSortedTransform>(\n                 pipes.back().getHeader(), pipes.size(), sort_description, max_block_size);\n \n-            res.emplace_back(std::move(pipes), std::move(merging_sorted));\n+            Pipe merged(std::move(pipes), std::move(merging_sorted));\n+            merged.addSimpleTransform(std::make_shared<ExpressionTransform>(merged.getHeader(), projection));\n+            res.emplace_back(std::move(merged));\n         }\n         else\n             res.emplace_back(std::move(pipes.front()));\n@@ -1051,6 +1065,10 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal(\n         use_uncompressed_cache = false;\n \n     Pipes pipes;\n+    /// Project input columns to drop columns from sorting_key_expr\n+    /// to allow execute the same expression later.\n+    /// NOTE: It may lead to double computation of expression.\n+    ExpressionActionsPtr projection;\n \n     for (const auto & part : parts)\n     {\n@@ -1061,6 +1079,9 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal(\n             virt_columns, part.part_index_in_query);\n \n         Pipe pipe(std::move(source_processor));\n+        if (!projection)\n+            projection = createProjection(pipe, data);\n+\n         pipe.addSimpleTransform(std::make_shared<ExpressionTransform>(pipe.getHeader(), data.sorting_key_expr));\n         pipes.emplace_back(std::move(pipe));\n     }\n@@ -1133,6 +1154,7 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsFinal(\n     if (merged_processor)\n     {\n         Pipe pipe(std::move(pipes), std::move(merged_processor));\n+        pipe.addSimpleTransform(std::make_shared<ExpressionTransform>(pipe.getHeader(), projection));\n         pipes = Pipes();\n         pipes.emplace_back(std::move(pipe));\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01137_order_by_func.reference b/tests/queries/0_stateless/01137_order_by_func.reference\nnew file mode 100644\nindex 000000000000..66d4d94db721\n--- /dev/null\n+++ b/tests/queries/0_stateless/01137_order_by_func.reference\n@@ -0,0 +1,8 @@\n+2020-05-05 01:00:00\t0\n+2020-05-05 01:00:00\t1\n+2020-05-05 01:00:00\t2\n+2020-05-05 01:00:00\t3\n+2020-05-05 01:00:00\t4\n+111\t9999999\t9999999\n+111\t9999998\t9999998\n+111\t9999997\t9999997\ndiff --git a/tests/queries/0_stateless/01137_order_by_func.sql b/tests/queries/0_stateless/01137_order_by_func.sql\nnew file mode 100644\nindex 000000000000..682b2d391cee\n--- /dev/null\n+++ b/tests/queries/0_stateless/01137_order_by_func.sql\n@@ -0,0 +1,25 @@\n+DROP TABLE IF EXISTS pk_func;\n+CREATE TABLE pk_func(d DateTime, ui UInt32) ENGINE = MergeTree ORDER BY toDate(d);\n+\n+INSERT INTO pk_func SELECT '2020-05-05 01:00:00', number FROM numbers(1000000);\n+INSERT INTO pk_func SELECT '2020-05-06 01:00:00', number FROM numbers(1000000);\n+INSERT INTO pk_func SELECT '2020-05-07 01:00:00', number FROM numbers(1000000);\n+\n+SELECT * FROM pk_func ORDER BY toDate(d), ui LIMIT 5;\n+\n+DROP TABLE pk_func;\n+\n+DROP TABLE IF EXISTS nORX;\n+CREATE TABLE nORX (`A` Int64, `B` Int64, `V` Int64) ENGINE = MergeTree ORDER BY (A, negate(B));\n+INSERT INTO nORX SELECT 111, number, number FROM numbers(10000000);\n+\n+SELECT *\n+FROM nORX\n+WHERE B >= 1000\n+ORDER BY\n+    A ASC,\n+    -B ASC\n+LIMIT 3\n+SETTINGS max_threads = 1;\n+\n+DROP TABLE nORX;\ndiff --git a/tests/queries/0_stateless/01137_order_by_func_final.reference b/tests/queries/0_stateless/01137_order_by_func_final.reference\nnew file mode 100644\nindex 000000000000..c97316543dad\n--- /dev/null\n+++ b/tests/queries/0_stateless/01137_order_by_func_final.reference\n@@ -0,0 +1,3 @@\n+2020-05-05\t704982704\n+2020-05-06\t704982704\n+2020-05-07\t704982704\ndiff --git a/tests/queries/0_stateless/01137_order_by_func_final.sql b/tests/queries/0_stateless/01137_order_by_func_final.sql\nnew file mode 100644\nindex 000000000000..32a9085e9ee5\n--- /dev/null\n+++ b/tests/queries/0_stateless/01137_order_by_func_final.sql\n@@ -0,0 +1,10 @@\n+DROP TABLE IF EXISTS pk_func;\n+CREATE TABLE pk_func(d DateTime, ui UInt32) ENGINE = SummingMergeTree ORDER BY toDate(d);\n+\n+INSERT INTO pk_func SELECT '2020-05-05 01:00:00', number FROM numbers(100000);\n+INSERT INTO pk_func SELECT '2020-05-06 01:00:00', number FROM numbers(100000);\n+INSERT INTO pk_func SELECT '2020-05-07 01:00:00', number FROM numbers(100000);\n+\n+SELECT toDate(d), ui FROM pk_func FINAL;\n+\n+DROP TABLE pk_func;\n",
  "problem_statement": "Query didn't work well with table created with negate() in Order By\n**Describe the bug or unexpected behaviour**\r\nWhen ran queries on a table created with negation in Order By, we got errors like below. Both Prewhere and Where could trigger this failure with certain filtering conditions. \r\n```\r\nReceived exception from server (version 19.17.5):\r\nCode: 15. DB::Exception: Received from localhost:9000. DB::Exception: Column 'negate(B)' already exists.\r\n```\r\n\r\n**How to reproduce**\r\n\r\nBasic env\r\n```\r\nClickHouse client version 19.17.5.18 (official build).\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 19.17.5 revision 54428.\r\n```\r\n\r\nTo reproduce\r\n```\r\nCREATE TABLE nORX (`A` Int64, `B` Int64, `V` Int64) ENGINE = MergeTree ORDER BY (A, negate(B)) SETTINGS index_granularity = 8192 \r\n\r\ninsert into nORX select 111, number, number from numbers(10000000)\r\n\r\nSELECT *\r\nFROM nORX\r\nPREWHERE (A = 111) AND (B >= 1000)\r\nORDER BY\r\n    A ASC,\r\n    -B ASC\r\nLIMIT 3\r\nSETTINGS max_threads = 1\r\n\r\nReceived exception from server (version 19.17.5):\r\nCode: 15. DB::Exception: Received from localhost:9000. DB::Exception: Column 'negate(B)' already exists.\r\n\r\nSELECT *\r\nFROM nORX\r\nWHERE B >= 1000\r\nORDER BY\r\n    A ASC,\r\n    -B ASC\r\nLIMIT 3\r\nSETTINGS max_threads = 1\r\n\r\nReceived exception from server (version 19.17.5):\r\nCode: 15. DB::Exception: Received from localhost:9000. DB::Exception: Column 'negate(B)' already exists.\r\n```\r\n\r\n**Expected behavior**\r\nBut this query worked as expected:\r\n```\r\nSELECT *\r\nFROM nORX\r\nWHERE (A = 111) AND (B >= 1000)\r\nORDER BY\r\n    A ASC,\r\n    -B ASC\r\nLIMIT 3\r\nSETTINGS max_threads = 1\r\n\r\n\u250c\u2500\u2500\u2500A\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500B\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500V\u2500\u2510\r\n\u2502 111 \u2502 9999999 \u2502 9999999 \u2502\r\n\u2502 111 \u2502 9999998 \u2502 9999998 \u2502\r\n\u2502 111 \u2502 9999997 \u2502 9999997 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n3 rows in set. Elapsed: 0.062 sec. Processed 614.40 thousand rows, 14.75 MB (9.95 million rows/s., 238.75 MB/s.)\r\n```\r\n\r\n**Additional question**\r\nWe use \"ORDER BY A ASC, -B ASC\" in the query to leverage the optimize_read_in_order option. Though \"ORDER BY A ASC, B DESC\" provided same result, the query took much longer to finish: 0.464s vs 0.062s. Is such slowness expected?\r\n```\r\nSELECT *\r\nFROM nORX\r\nWHERE (A = 111) AND (B >= 1000)\r\nORDER BY\r\n    A ASC,\r\n    B DESC\r\nLIMIT 3\r\nSETTINGS max_threads = 1\r\n\r\n\u250c\u2500\u2500\u2500A\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500B\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500V\u2500\u2510\r\n\u2502 111 \u2502 9999999 \u2502 9999999 \u2502\r\n\u2502 111 \u2502 9999998 \u2502 9999998 \u2502\r\n\u2502 111 \u2502 9999997 \u2502 9999997 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n3 rows in set. Elapsed: 0.464 sec. Processed 10.00 million rows, 239.98 MB (21.56 million rows/s., 517.38 MB/s.)\r\n``` \r\n\n",
  "hints_text": "",
  "created_at": "2020-05-06T22:32:34Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01137_order_by_func.reference",
    "b/tests/queries/0_stateless/01137_order_by_func.sql",
    "b/tests/queries/0_stateless/01137_order_by_func_final.reference",
    "b/tests/queries/0_stateless/01137_order_by_func_final.sql"
  ]
}