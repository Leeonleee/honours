diff --git a/src/Dictionaries/CacheDictionaryStorage.h b/src/Dictionaries/CacheDictionaryStorage.h
index a79d83eea057..8374e649cd14 100644
--- a/src/Dictionaries/CacheDictionaryStorage.h
+++ b/src/Dictionaries/CacheDictionaryStorage.h
@@ -55,7 +55,7 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
         cells.resize_fill(cells_size);
         size_overlap_mask = cells_size - 1;
 
-        setup(dictionary_structure);
+        createAttributes(dictionary_structure);
     }
 
     bool returnsFetchedColumnsInOrderOfRequestedKeys() const override { return true; }
@@ -226,23 +226,17 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
             auto & attribute = attributes[attribute_index];
             const auto & default_value_provider = fetch_request.defaultValueProviderAtIndex(attribute_index);
 
-            size_t fetched_keys_size = fetched_keys.size();
             auto & fetched_column = *result.fetched_columns[attribute_index];
-            fetched_column.reserve(fetched_keys_size);
+            fetched_column.reserve(fetched_columns_index);
 
-            if (unlikely(attribute.is_complex_type))
+            if (unlikely(attribute.is_nullable))
             {
-                auto & container = std::get<std::vector<Field>>(attribute.attribute_container);
-
-                for (size_t fetched_key_index = 0; fetched_key_index < fetched_columns_index; ++fetched_key_index)
-                {
-                    auto fetched_key = fetched_keys[fetched_key_index];
-
-                    if (unlikely(fetched_key.is_default))
-                        fetched_column.insert(default_value_provider.getDefaultValue(fetched_key_index));
-                    else
-                        fetched_column.insert(container[fetched_key.element_index]);
-                }
+                getItemsForFetchedKeys<Field>(
+                    attribute,
+                    fetched_columns_index,
+                    fetched_keys,
+                    [&](Field & value) { fetched_column.insert(value); },
+                    default_value_provider);
             }
             else
             {
@@ -250,46 +244,40 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                 {
                     using Type = std::decay_t<decltype(dictionary_attribute_type)>;
                     using AttributeType = typename Type::AttributeType;
+                    using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;
+                    using ColumnType = typename ColumnProvider::ColumnType;
                     using ValueType = DictionaryValueType<AttributeType>;
-                    using ColumnType =
-                        std::conditional_t<std::is_same_v<AttributeType, String>, ColumnString,
-                            std::conditional_t<IsDecimalNumber<AttributeType>, ColumnDecimal<ValueType>,
-                                ColumnVector<AttributeType>>>;
 
-                    auto & container = std::get<PaddedPODArray<ValueType>>(attribute.attribute_container);
                     ColumnType & column_typed = static_cast<ColumnType &>(fetched_column);
 
-                    if constexpr (std::is_same_v<ColumnType, ColumnString>)
+                    if constexpr (std::is_same_v<ValueType, Array>)
                     {
-                        for (size_t fetched_key_index = 0; fetched_key_index < fetched_columns_index; ++fetched_key_index)
-                        {
-                            auto fetched_key = fetched_keys[fetched_key_index];
-
-                            if (unlikely(fetched_key.is_default))
-                                column_typed.insert(default_value_provider.getDefaultValue(fetched_key_index));
-                            else
-                            {
-                                auto item = container[fetched_key.element_index];
-                                column_typed.insertData(item.data, item.size);
-                            }
-                        }
+                        getItemsForFetchedKeys<ValueType>(
+                            attribute,
+                            fetched_columns_index,
+                            fetched_keys,
+                            [&](Array & value) { fetched_column.insert(value); },
+                            default_value_provider);
+                    }
+                    else if constexpr (std::is_same_v<ValueType, StringRef>)
+                    {
+                        getItemsForFetchedKeys<ValueType>(
+                            attribute,
+                            fetched_columns_index,
+                            fetched_keys,
+                            [&](StringRef value) { fetched_column.insertData(value.data, value.size); },
+                            default_value_provider);
                     }
                     else
                     {
                         auto & data = column_typed.getData();
 
-                        for (size_t fetched_key_index = 0; fetched_key_index < fetched_columns_index; ++fetched_key_index)
-                        {
-                            auto fetched_key = fetched_keys[fetched_key_index];
-
-                            if (unlikely(fetched_key.is_default))
-                                column_typed.insert(default_value_provider.getDefaultValue(fetched_key_index));
-                            else
-                            {
-                                auto item = container[fetched_key.element_index];
-                                data.push_back(item);
-                            }
-                        }
+                        getItemsForFetchedKeys<ValueType>(
+                            attribute,
+                            fetched_columns_index,
+                            fetched_keys,
+                            [&](auto value) { data.push_back(value); },
+                            default_value_provider);
                     }
                 };
 
@@ -339,7 +327,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                         column->get(key_index, column_value);
 
                         if constexpr (std::is_same_v<ElementType, Field>)
+                        {
                             container.back() = column_value;
+                        }
                         else if constexpr (std::is_same_v<ElementType, StringRef>)
                         {
                             const String & string_value = column_value.get<String>();
@@ -348,7 +338,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                             container.back() = inserted_value;
                         }
                         else
+                        {
                             container.back() = column_value.get<NearestFieldType<ElementType>>();
+                        }
                     });
                 }
 
@@ -382,7 +374,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                         column->get(key_index, column_value);
 
                         if constexpr (std::is_same_v<ElementType, Field>)
+                        {
                             container[index_to_use] = column_value;
+                        }
                         else if constexpr (std::is_same_v<ElementType, StringRef>)
                         {
                             const String & string_value = column_value.get<String>();
@@ -398,7 +392,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                             container[index_to_use] = inserted_value;
                         }
                         else
+                        {
                             container[index_to_use] = column_value.get<NearestFieldType<ElementType>>();
+                        }
                     });
                 }
             }
@@ -504,9 +500,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
         auto & attribute = attributes[attribute_index];
         auto & attribute_type = attribute.type;
 
-        if (unlikely(attribute.is_complex_type))
+        if (unlikely(attribute.is_nullable))
         {
-            auto & container = std::get<std::vector<Field>>(attribute.attribute_container);
+            auto & container = std::get<ContainerType<Field>>(attribute.attribute_container);
             std::forward<GetContainerFunc>(func)(container);
         }
         else
@@ -517,7 +513,7 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                 using AttributeType = typename Type::AttributeType;
                 using ValueType = DictionaryValueType<AttributeType>;
 
-                auto & container = std::get<PaddedPODArray<ValueType>>(attribute.attribute_container);
+                auto & container = std::get<ContainerType<ValueType>>(attribute.attribute_container);
                 std::forward<GetContainerFunc>(func)(container);
             };
 
@@ -541,7 +537,82 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
         return updated_value;
     }
 
-    void setup(const DictionaryStructure & dictionary_structure)
+    template<typename ValueType>
+    using ContainerType = std::conditional_t<
+        std::is_same_v<ValueType, Field> || std::is_same_v<ValueType, Array>,
+        std::vector<ValueType>,
+        PaddedPODArray<ValueType>>;
+
+    struct Attribute
+    {
+        AttributeUnderlyingType type;
+        bool is_nullable;
+
+        std::variant<
+            ContainerType<UInt8>,
+            ContainerType<UInt16>,
+            ContainerType<UInt32>,
+            ContainerType<UInt64>,
+            ContainerType<UInt128>,
+            ContainerType<UInt256>,
+            ContainerType<Int8>,
+            ContainerType<Int16>,
+            ContainerType<Int32>,
+            ContainerType<Int64>,
+            ContainerType<Int128>,
+            ContainerType<Int256>,
+            ContainerType<Decimal32>,
+            ContainerType<Decimal64>,
+            ContainerType<Decimal128>,
+            ContainerType<Decimal256>,
+            ContainerType<Float32>,
+            ContainerType<Float64>,
+            ContainerType<UUID>,
+            ContainerType<StringRef>,
+            ContainerType<Array>,
+            ContainerType<Field>> attribute_container;
+    };
+
+    template <typename ValueType, typename ValueSetter>
+    void getItemsForFetchedKeys(
+        Attribute & attribute,
+        size_t fetched_keys_size,
+        PaddedPODArray<FetchedKey> & fetched_keys,
+        ValueSetter && value_setter,
+        const DefaultValueProvider & default_value_provider)
+    {
+        auto & container = std::get<ContainerType<ValueType>>(attribute.attribute_container);
+
+        for (size_t fetched_key_index = 0; fetched_key_index < fetched_keys_size; ++fetched_key_index)
+        {
+            auto fetched_key = fetched_keys[fetched_key_index];
+
+            if (unlikely(fetched_key.is_default))
+            {
+                auto default_value = default_value_provider.getDefaultValue(fetched_key_index);
+
+                if constexpr (std::is_same_v<ValueType, Field>)
+                {
+                    value_setter(default_value);
+                }
+                else if constexpr (std::is_same_v<ValueType, StringRef>)
+                {
+                    auto & value = default_value.get<String>();
+                    value_setter(value);
+                }
+                else
+                {
+                    value_setter(default_value.get<ValueType>());
+                }
+            }
+            else
+            {
+                value_setter(container[fetched_key.element_index]);
+            }
+        }
+    }
+
+    void createAttributes(const DictionaryStructure & dictionary_structure)
     {
         /// For each dictionary attribute create storage attribute
         /// For simple attributes create PODArray, for complex vector of Fields
@@ -561,12 +632,12 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
                 attributes.emplace_back();
                 auto & last_attribute = attributes.back();
                 last_attribute.type = attribute_type;
-                last_attribute.is_complex_type = dictionary_attribute.is_nullable || dictionary_attribute.is_array;
+                last_attribute.is_nullable = dictionary_attribute.is_nullable;
 
                 if (dictionary_attribute.is_nullable)
-                    last_attribute.attribute_container = std::vector<Field>();
+                    last_attribute.attribute_container = ContainerType<Field>();
                 else
-                    last_attribute.attribute_container = PaddedPODArray<ValueType>();
+                    last_attribute.attribute_container = ContainerType<ValueType>();
             };
 
             callOnDictionaryAttributeType(attribute_type, type_call);
@@ -583,35 +654,6 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
         time_t deadline;
     };
 
-    struct Attribute
-    {
-        AttributeUnderlyingType type;
-        bool is_complex_type;
-
-        std::variant<
-            PaddedPODArray<UInt8>,
-            PaddedPODArray<UInt16>,
-            PaddedPODArray<UInt32>,
-            PaddedPODArray<UInt64>,
-            PaddedPODArray<UInt128>,
-            PaddedPODArray<UInt256>,
-            PaddedPODArray<Int8>,
-            PaddedPODArray<Int16>,
-            PaddedPODArray<Int32>,
-            PaddedPODArray<Int64>,
-            PaddedPODArray<Int128>,
-            PaddedPODArray<Int256>,
-            PaddedPODArray<Decimal32>,
-            PaddedPODArray<Decimal64>,
-            PaddedPODArray<Decimal128>,
-            PaddedPODArray<Decimal256>,
-            PaddedPODArray<Float32>,
-            PaddedPODArray<Float64>,
-            PaddedPODArray<UUID>,
-            PaddedPODArray<StringRef>,
-            std::vector<Field>> attribute_container;
-    };
-
     CacheDictionaryStorageConfiguration configuration;
 
     pcg64 rnd_engine;
diff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h
index 6d459bab85f6..55027aa88538 100644
--- a/src/Dictionaries/DictionaryHelpers.h
+++ b/src/Dictionaries/DictionaryHelpers.h
@@ -6,8 +6,11 @@
 #include <Columns/ColumnDecimal.h>
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnVector.h>
+#include <Columns/ColumnArray.h>
 #include <DataStreams/IBlockInputStream.h>
 #include <DataTypes/DataTypesDecimal.h>
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypeNullable.h>
 #include <Core/Block.h>
 #include <Dictionaries/IDictionary.h>
 #include <Dictionaries/DictionaryStructure.h>
@@ -231,14 +234,27 @@ class DictionaryAttributeColumnProvider
 {
 public:
     using ColumnType =
-        std::conditional_t<std::is_same_v<DictionaryAttributeType, String>, ColumnString,
-            std::conditional_t<IsDecimalNumber<DictionaryAttributeType>, ColumnDecimal<DictionaryAttributeType>,
-                ColumnVector<DictionaryAttributeType>>>;
+        std::conditional_t<std::is_same_v<DictionaryAttributeType, Array>, ColumnArray,
+            std::conditional_t<std::is_same_v<DictionaryAttributeType, String>, ColumnString,
+                std::conditional_t<IsDecimalNumber<DictionaryAttributeType>, ColumnDecimal<DictionaryAttributeType>,
+                    ColumnVector<DictionaryAttributeType>>>>;
 
     using ColumnPtr = typename ColumnType::MutablePtr;
 
     static ColumnPtr getColumn(const DictionaryAttribute & dictionary_attribute, size_t size)
     {
+        if constexpr (std::is_same_v<DictionaryAttributeType, Array>)
+        {
+            if (const auto * array_type = typeid_cast<const DataTypeArray *>(dictionary_attribute.type.get()))
+            {
+                auto nested_column = array_type->getNestedType()->createColumn();
+                return ColumnArray::create(std::move(nested_column));
+            }
+            else
+            {
+                throw Exception(ErrorCodes::TYPE_MISMATCH, "Unsupported attribute type.");
+            }
+        }
         if constexpr (std::is_same_v<DictionaryAttributeType, String>)
         {
             return ColumnType::create();
@@ -249,7 +265,8 @@ class DictionaryAttributeColumnProvider
         }
         else if constexpr (IsDecimalNumber<DictionaryAttributeType>)
         {
-            auto scale = getDecimalScale(*dictionary_attribute.nested_type);
+            auto nested_type = removeNullable(dictionary_attribute.type);
+            auto scale = getDecimalScale(*nested_type);
             return ColumnType::create(size, scale);
         }
         else if constexpr (is_arithmetic_v<DictionaryAttributeType>)
@@ -280,18 +297,18 @@ class DictionaryDefaultValueExtractor
         : default_value(std::move(attribute_default_value))
     {
         if (default_values_column_ == nullptr)
-            use_default_value_from_column = false;
+            use_attribute_default_value = true;
         else
         {
             if (const auto * const default_col = checkAndGetColumn<DefaultColumnType>(*default_values_column_))
             {
                 default_values_column = default_col;
-                use_default_value_from_column = true;
+                use_attribute_default_value = false;
             }
             else if (const auto * const default_col_const = checkAndGetColumnConst<DefaultColumnType>(default_values_column_.get()))
             {
                 default_value = default_col_const->template getValue<DictionaryAttributeType>();
-                use_default_value_from_column = false;
+                use_attribute_default_value = true;
             }
             else
                 throw Exception(ErrorCodes::TYPE_MISMATCH, "Type of default column is not the same as dictionary attribute type.");
@@ -300,12 +317,17 @@ class DictionaryDefaultValueExtractor
 
     DefaultValueType operator[](size_t row)
     {
-        if (!use_default_value_from_column)
+        if (use_attribute_default_value)
             return static_cast<DefaultValueType>(default_value);
 
         assert(default_values_column != nullptr);
 
-        if constexpr (std::is_same_v<DefaultColumnType, ColumnString>)
+        if constexpr (std::is_same_v<DefaultColumnType, ColumnArray>)
+        {
+            Field field = (*default_values_column)[row];
+            return field.get<Array>();
+        }
+        else if constexpr (std::is_same_v<DefaultColumnType, ColumnString>)
             return default_values_column->getDataAt(row);
         else
             return default_values_column->getData()[row];
@@ -313,7 +335,7 @@ class DictionaryDefaultValueExtractor
 private:
     DictionaryAttributeType default_value;
     const DefaultColumnType * default_values_column = nullptr;
-    bool use_default_value_from_column = false;
+    bool use_attribute_default_value = false;
 };
 
 template <DictionaryKeyType key_type>
diff --git a/src/Dictionaries/DictionarySourceFactory.cpp b/src/Dictionaries/DictionarySourceFactory.cpp
index 507d11eba8e7..41b3fbb68b4e 100644
--- a/src/Dictionaries/DictionarySourceFactory.cpp
+++ b/src/Dictionaries/DictionarySourceFactory.cpp
@@ -25,9 +25,10 @@ namespace
         Block block;
 
         if (dict_struct.id)
+        {
             block.insert(ColumnWithTypeAndName{ColumnUInt64::create(1, 0), std::make_shared<DataTypeUInt64>(), dict_struct.id->name});
-
-        if (dict_struct.key)
+        }
+        else if (dict_struct.key)
         {
             for (const auto & attribute : *dict_struct.key)
             {
diff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp
index c0d00d3ae40d..a6de85f83f54 100644
--- a/src/Dictionaries/DictionaryStructure.cpp
+++ b/src/Dictionaries/DictionaryStructure.cpp
@@ -79,9 +79,7 @@ AttributeUnderlyingType getAttributeUnderlyingType(const DataTypePtr & type)
 
         case TypeIndex::String:         return AttributeUnderlyingType::String;
 
-        // Temporary hack to allow arrays in keys, since they are never retrieved for polygon dictionaries.
-        // TODO: This should be fixed by fully supporting arrays in dictionaries.
-        case TypeIndex::Array:          return AttributeUnderlyingType::String;
+        case TypeIndex::Array:          return AttributeUnderlyingType::Array;
 
         default: break;
     }
@@ -125,7 +123,7 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration
         id.emplace(config, structure_prefix + ".id");
     else if (has_key)
     {
-        key.emplace(getAttributes(config, structure_prefix + ".key", true));
+        key.emplace(getAttributes(config, structure_prefix + ".key", /*complex_key_attributes =*/ true));
         if (key->empty())
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "Empty 'key' supplied");
     }
@@ -173,7 +171,7 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration
             has_expressions = true;
     }
 
-    attributes = getAttributes(config, structure_prefix, false);
+    attributes = getAttributes(config, structure_prefix, /*complex_key_attributes =*/ false);
 
     for (size_t i = 0; i < attributes.size(); ++i)
     {
@@ -375,17 +373,10 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(
 
         const auto type_string = config.getString(prefix + "type");
         const auto initial_type = DataTypeFactory::instance().get(type_string);
-        auto type = initial_type;
-        bool is_array = false;
-        bool is_nullable = false;
+        bool is_nullable = initial_type->isNullable();
 
-        if (type->isNullable())
-        {
-            is_nullable = true;
-            type = removeNullable(type);
-        }
-
-        const auto underlying_type = getAttributeUnderlyingType(type);
+        auto non_nullable_type = removeNullable(initial_type);
+        const auto underlying_type = getAttributeUnderlyingType(non_nullable_type);
 
         const auto expression = config.getString(prefix + "expression", "");
         if (!expression.empty())
@@ -394,26 +385,27 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(
         Field null_value;
         if (allow_null_values)
         {
+            /// TODO: Fix serialization for nullable type.
             const auto null_value_string = config.getString(prefix + "null_value");
+
             try
             {
                 if (null_value_string.empty())
                 {
-                    null_value = type->getDefault();
+                    null_value = non_nullable_type->getDefault();
                 }
                 else
                 {
                     ReadBufferFromString null_value_buffer{null_value_string};
-                    auto column_with_null_value = type->createColumn();
-                    type->getDefaultSerialization()->deserializeTextEscaped(*column_with_null_value, null_value_buffer, format_settings);
+                    auto column_with_null_value = non_nullable_type->createColumn();
+                    non_nullable_type->getDefaultSerialization()->deserializeTextEscaped(*column_with_null_value, null_value_buffer, format_settings);
                     null_value = (*column_with_null_value)[0];
                 }
             }
             catch (Exception & e)
             {
                 String dictionary_name = config.getString(".dictionary.name", "");
-                e.addMessage("While parsing null_value for attribute with name " + name
-                    + " in dictionary " + dictionary_name);
+                e.addMessage(fmt::format("While parsing null_value for attribute with name {} in dictionary {}", name, dictionary_name));
                 throw;
             }
         }
@@ -436,15 +428,12 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(
             name,
             underlying_type,
             initial_type,
-            initial_type->getDefaultSerialization(),
-            type,
             expression,
             null_value,
             hierarchical,
             injective,
             is_object_id,
-            is_nullable,
-            is_array});
+            is_nullable});
     }
 
     return res_attributes;
diff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h
index 4815501b6962..9509aa97ce04 100644
--- a/src/Dictionaries/DictionaryStructure.h
+++ b/src/Dictionaries/DictionaryStructure.h
@@ -39,6 +39,7 @@
     M(Decimal256) \
     M(UUID) \
     M(String) \
+    M(Array) \
 
 
 namespace DB
@@ -74,15 +75,12 @@ struct DictionaryAttribute final
     const std::string name;
     const AttributeUnderlyingType underlying_type;
     const DataTypePtr type;
-    const SerializationPtr serialization;
-    const DataTypePtr nested_type;
     const std::string expression;
     const Field null_value;
     const bool hierarchical;
     const bool injective;
     const bool is_object_id;
     const bool is_nullable;
-    const bool is_array;
 };
 
 template <typename Type>
@@ -92,7 +90,7 @@ struct DictionaryAttributeType
 };
 
 template <typename F>
-void callOnDictionaryAttributeType(AttributeUnderlyingType type, F&& func)
+void callOnDictionaryAttributeType(AttributeUnderlyingType type, F && func)
 {
     switch (type)
     {
diff --git a/src/Dictionaries/ExternalQueryBuilder.cpp b/src/Dictionaries/ExternalQueryBuilder.cpp
index 8c6e9f60afbe..1fc5d160bb0f 100644
--- a/src/Dictionaries/ExternalQueryBuilder.cpp
+++ b/src/Dictionaries/ExternalQueryBuilder.cpp
@@ -358,7 +358,8 @@ void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, cons
         /// key_i=value_i
         writeQuoted(key_description.name, out);
         writeString("=", out);
-        key_description.serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);
+        auto serialization = key_description.type->getDefaultSerialization();
+        serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);
     }
 }
 
@@ -415,7 +416,8 @@ void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const si
             writeString(", ", out);
 
         first = false;
-        (*dict_struct.key)[i].serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);
+        auto serialization = (*dict_struct.key)[i].type->getDefaultSerialization();
+        serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);
     }
 
     writeString(")", out);
diff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp
index f58384a3b8ee..0a95165de4e6 100644
--- a/src/Dictionaries/FlatDictionary.cpp
+++ b/src/Dictionaries/FlatDictionary.cpp
@@ -70,17 +70,27 @@ ColumnPtr FlatDictionary::getColumn(
         using ValueType = DictionaryValueType<AttributeType>;
         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;
 
-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);
+        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);
         AttributeType null_value = static_cast<AttributeType>(attribute_null_value);
         DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);
 
         auto column = ColumnProvider::getColumn(dictionary_attribute, size);
 
-        if constexpr (std::is_same_v<ValueType, StringRef>)
+        if constexpr (std::is_same_v<ValueType, Array>)
+        {
+            auto * out = column.get();
+
+            getItemsImpl<ValueType>(
+                attribute,
+                ids,
+                [&](const size_t, const Array & value) { out->insert(value); },
+                default_value_extractor);
+        }
+        else if constexpr (std::is_same_v<ValueType, StringRef>)
         {
             auto * out = column.get();
 
-            getItemsImpl<ValueType, ValueType>(
+            getItemsImpl<ValueType>(
                 attribute,
                 ids,
                 [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },
@@ -90,7 +100,7 @@ ColumnPtr FlatDictionary::getColumn(
         {
             auto & out = column->getData();
 
-            getItemsImpl<ValueType, ValueType>(
+            getItemsImpl<ValueType>(
                 attribute,
                 ids,
                 [&](const size_t row, const auto value) { out[row] = value; },
@@ -275,6 +285,7 @@ void FlatDictionary::blockToAttributes(const Block & block)
 
             if (already_processed_keys.find(key) != nullptr)
                 continue;
+
             already_processed_keys.insert(key);
 
             setAttributeValue(attribute, key, attribute_column[i]);
@@ -352,7 +363,18 @@ void FlatDictionary::calculateBytesAllocated()
             using ValueType = DictionaryValueType<AttributeType>;
 
             const auto & container = std::get<ContainerType<ValueType>>(attribute.container);
-            bytes_allocated += sizeof(PaddedPODArray<ValueType>) + container.allocated_bytes();
+            bytes_allocated += sizeof(ContainerType<ValueType>);
+
+            if constexpr (std::is_same_v<ValueType, Array>)
+            {
+                /// It is not accurate calculations
+                bytes_allocated += sizeof(Array) * container.size();
+            }
+            else
+            {
+                bytes_allocated += container.allocated_bytes();
+            }
+
             bucket_count = container.capacity();
 
             if constexpr (std::is_same_v<ValueType, StringRef>)
@@ -396,7 +418,7 @@ FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttrib
     return attribute;
 }
 
-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
 void FlatDictionary::getItemsImpl(
     const Attribute & attribute,
     const PaddedPODArray<UInt64> & keys,
@@ -414,7 +436,7 @@ void FlatDictionary::getItemsImpl(
 
         if (key < loaded_keys.size() && loaded_keys[key])
         {
-            set_value(row, static_cast<OutputType>(container[key]));
+            set_value(row, container[key]);
             ++keys_found;
         }
         else
@@ -440,7 +462,11 @@ void FlatDictionary::resize(Attribute & attribute, UInt64 key)
     {
         const size_t elements_count = key + 1; //id=0 -> elements_count=1
         loaded_keys.resize(elements_count, false);
-        container.resize_fill(elements_count, std::get<T>(attribute.null_values));
+
+        if constexpr (std::is_same_v<T, Array>)
+            container.resize(elements_count, std::get<T>(attribute.null_values));
+        else
+            container.resize_fill(elements_count, std::get<T>(attribute.null_values));
     }
 }
 
@@ -461,13 +487,13 @@ void FlatDictionary::setAttributeValueImpl<String>(Attribute & attribute, UInt64
 
 void FlatDictionary::setAttributeValue(Attribute & attribute, const UInt64 key, const Field & value)
 {
-    auto type_call = [&](const auto &dictionary_attribute_type)
+    auto type_call = [&](const auto & dictionary_attribute_type)
     {
         using Type = std::decay_t<decltype(dictionary_attribute_type)>;
         using AttributeType = typename Type::AttributeType;
-        using ResizeType = std::conditional_t<std::is_same_v<AttributeType, String>, StringRef, AttributeType>;
+        using ValueType = DictionaryValueType<AttributeType>;
 
-        resize<ResizeType>(attribute, key);
+        resize<ValueType>(attribute, key);
 
         if (attribute.nullable_set)
         {
diff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h
index 211b1cdc33dc..ec725bcdda2d 100644
--- a/src/Dictionaries/FlatDictionary.h
+++ b/src/Dictionaries/FlatDictionary.h
@@ -106,7 +106,7 @@ class FlatDictionary final : public IDictionary
 
 private:
     template <typename Value>
-    using ContainerType = PaddedPODArray<Value>;
+    using ContainerType = std::conditional_t<std::is_same_v<Value, Array>, std::vector<Value>, PaddedPODArray<Value>>;
 
     using NullableSet = HashSet<UInt64, DefaultHash<UInt64>>;
 
@@ -135,8 +135,10 @@ class FlatDictionary final : public IDictionary
             Float32,
             Float64,
             UUID,
-            StringRef>
+            StringRef,
+            Array>
             null_values;
+
         std::variant<
             ContainerType<UInt8>,
             ContainerType<UInt16>,
@@ -157,7 +159,8 @@ class FlatDictionary final : public IDictionary
             ContainerType<Float32>,
             ContainerType<Float64>,
             ContainerType<UUID>,
-            ContainerType<StringRef>>
+            ContainerType<StringRef>,
+            ContainerType<Array>>
             container;
 
         std::unique_ptr<Arena> string_arena;
@@ -172,7 +175,7 @@ class FlatDictionary final : public IDictionary
 
     Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);
 
-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
     void getItemsImpl(
         const Attribute & attribute,
         const PaddedPODArray<UInt64> & keys,
diff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp
index 0de28f18006b..fd070c4df33c 100644
--- a/src/Dictionaries/HashedDictionary.cpp
+++ b/src/Dictionaries/HashedDictionary.cpp
@@ -90,13 +90,26 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(
         using ValueType = DictionaryValueType<AttributeType>;
         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;
 
-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);
+        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);
         AttributeType null_value = static_cast<AttributeType>(attribute_null_value);
         DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);
 
         auto column = ColumnProvider::getColumn(dictionary_attribute, size);
 
-        if constexpr (std::is_same_v<ValueType, StringRef>)
+        if constexpr (std::is_same_v<ValueType, Array>)
+        {
+            auto * out = column.get();
+
+            getItemsImpl<ValueType>(
+                attribute,
+                extractor,
+                [&](const size_t, const Array & value) { out->insert(value); },
+                [&](const size_t)
+                {
+                },
+                default_value_extractor);
+        }
+        else if constexpr (std::is_same_v<ValueType, StringRef>)
         {
             auto * out = column.get();
 
diff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h
index 324b7601a28c..9a67c9d39012 100644
--- a/src/Dictionaries/HashedDictionary.h
+++ b/src/Dictionaries/HashedDictionary.h
@@ -173,7 +173,8 @@ class HashedDictionary final : public IDictionary
             Float32,
             Float64,
             UUID,
-            StringRef>
+            StringRef,
+            Array>
             null_values;
 
         std::variant<
@@ -196,7 +197,8 @@ class HashedDictionary final : public IDictionary
             CollectionType<Float32>,
             CollectionType<Float64>,
             CollectionType<UUID>,
-            CollectionType<StringRef>>
+            CollectionType<StringRef>,
+            CollectionType<Array>>
             container;
 
         std::unique_ptr<Arena> string_arena;
diff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp
index a0630ab324c8..222664615384 100644
--- a/src/Dictionaries/IPAddressDictionary.cpp
+++ b/src/Dictionaries/IPAddressDictionary.cpp
@@ -27,6 +27,7 @@ namespace ErrorCodes
     extern const int DICTIONARY_IS_EMPTY;
     extern const int LOGICAL_ERROR;
     extern const int TYPE_MISMATCH;
+    extern const int UNSUPPORTED_METHOD;
 }
 
 namespace
@@ -237,11 +238,21 @@ ColumnPtr IPAddressDictionary::getColumn(
 
         auto column = ColumnProvider::getColumn(dictionary_attribute, size);
 
-        if constexpr (std::is_same_v<AttributeType, String>)
+        if constexpr (std::is_same_v<ValueType, Array>)
+        {
+            auto * out = column.get();
+
+            getItemsImpl<ValueType>(
+                attribute,
+                key_columns,
+                [&](const size_t, const Array & value) { out->insert(value); },
+                default_value_extractor);
+        }
+        else if constexpr (std::is_same_v<ValueType, StringRef>)
         {
             auto * out = column.get();
 
-            getItemsImpl<ValueType, ValueType>(
+            getItemsImpl<ValueType>(
                 attribute,
                 key_columns,
                 [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },
@@ -251,7 +262,7 @@ ColumnPtr IPAddressDictionary::getColumn(
         {
             auto & out = column->getData();
 
-            getItemsImpl<ValueType, ValueType>(
+            getItemsImpl<ValueType>(
                 attribute,
                 key_columns,
                 [&](const size_t row, const auto value) { return out[row] = value; },
@@ -315,8 +326,15 @@ void IPAddressDictionary::createAttributes()
     auto create_attributes_from_dictionary_attributes = [this](const std::vector<DictionaryAttribute> & dict_attrs)
     {
         attributes.reserve(attributes.size() + dict_attrs.size());
+
         for (const auto & attribute : dict_attrs)
         {
+            if (attribute.is_nullable)
+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+                    "{}: array or nullable attributes not supported for dictionary of type {}",
+                    full_name,
+                    getTypeName());
+
             attribute_index_by_name.emplace(attribute.name, attributes.size());
             attributes.push_back(createAttributeWithType(attribute.underlying_type, attribute.null_value));
 
@@ -583,7 +601,7 @@ const uint8_t * IPAddressDictionary::getIPv6FromOffset(const IPAddressDictionary
     return reinterpret_cast<const uint8_t *>(&ipv6_col[i * IPV6_BINARY_LENGTH]);
 }
 
-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
 void IPAddressDictionary::getItemsByTwoKeyColumnsImpl(
     const Attribute & attribute,
     const Columns & key_columns,
@@ -622,7 +640,7 @@ void IPAddressDictionary::getItemsByTwoKeyColumnsImpl(
                 (*ipv4_col)[*found_it] == addr &&
                 mask_column[*found_it] == mask))
             {
-                set_value(i, static_cast<OutputType>(vec[row_idx[*found_it]]));
+                set_value(i, vec[row_idx[*found_it]]);
             }
             else
                 set_value(i, default_value_extractor[i]);
@@ -658,13 +676,13 @@ void IPAddressDictionary::getItemsByTwoKeyColumnsImpl(
         if (likely(found_it != range.end() &&
             memequal16(getIPv6FromOffset(*ipv6_col, *found_it), target.addr) &&
             mask_column[*found_it] == mask))
-            set_value(i, static_cast<OutputType>(vec[row_idx[*found_it]]));
+            set_value(i, vec[row_idx[*found_it]]);
         else
             set_value(i, default_value_extractor[i]);
     }
 }
 
-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
 void IPAddressDictionary::getItemsImpl(
     const Attribute & attribute,
     const Columns & key_columns,
@@ -677,7 +695,7 @@ void IPAddressDictionary::getItemsImpl(
     // special case for getBlockInputStream
     if (unlikely(key_columns.size() == 2))
     {
-        getItemsByTwoKeyColumnsImpl<AttributeType, OutputType>(
+        getItemsByTwoKeyColumnsImpl<AttributeType>(
             attribute, key_columns, std::forward<ValueSetter>(set_value), default_value_extractor);
         query_count.fetch_add(rows, std::memory_order_relaxed);
         return;
@@ -697,7 +715,7 @@ void IPAddressDictionary::getItemsImpl(
             auto found = tryLookupIPv4(addrv4, addrv6_buf);
             if (found != ipNotFound())
             {
-                set_value(i, static_cast<OutputType>(vec[*found]));
+                set_value(i, vec[*found]);
                 ++keys_found;
             }
             else
@@ -715,7 +733,7 @@ void IPAddressDictionary::getItemsImpl(
             auto found = tryLookupIPv6(reinterpret_cast<const uint8_t *>(addr.data));
             if (found != ipNotFound())
             {
-                set_value(i, static_cast<OutputType>(vec[*found]));
+                set_value(i, vec[*found]);
                 ++keys_found;
             }
             else
diff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h
index edca68aedbaa..075742da11a4 100644
--- a/src/Dictionaries/IPAddressDictionary.h
+++ b/src/Dictionaries/IPAddressDictionary.h
@@ -116,7 +116,8 @@ class IPAddressDictionary final : public IDictionary
             Float32,
             Float64,
             UUID,
-            String>
+            String,
+            Array>
             null_values;
         std::variant<
             ContainerType<UInt8>,
@@ -138,7 +139,8 @@ class IPAddressDictionary final : public IDictionary
             ContainerType<Float32>,
             ContainerType<Float64>,
             ContainerType<UUID>,
-            ContainerType<StringRef>>
+            ContainerType<StringRef>,
+            ContainerType<Array>>
             maps;
         std::unique_ptr<Arena> string_arena;
     };
@@ -157,14 +159,14 @@ class IPAddressDictionary final : public IDictionary
 
     static Attribute createAttributeWithType(const AttributeUnderlyingType type, const Field & null_value);
 
-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
     void getItemsByTwoKeyColumnsImpl(
         const Attribute & attribute,
         const Columns & key_columns,
         ValueSetter && set_value,
         DefaultValueExtractor & default_value_extractor) const;
 
-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+    template <typename AttributeType,typename ValueSetter, typename DefaultValueExtractor>
     void getItemsImpl(
         const Attribute & attribute,
         const Columns & key_columns,
diff --git a/src/Dictionaries/PolygonDictionary.cpp b/src/Dictionaries/PolygonDictionary.cpp
index 084228c98aec..17e7605d1368 100644
--- a/src/Dictionaries/PolygonDictionary.cpp
+++ b/src/Dictionaries/PolygonDictionary.cpp
@@ -52,7 +52,6 @@ ColumnPtr IPolygonDictionary::getColumn(
     const auto requested_key_points = extractPoints(key_columns);
 
     const auto & attribute = dict_struct.getAttribute(attribute_name, result_type);
-    bool complex_attribute = attribute.is_nullable || attribute.is_array;
     DefaultValueProvider default_value_provider(attribute.null_value, default_values_column);
 
     size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;
@@ -61,28 +60,13 @@ ColumnPtr IPolygonDictionary::getColumn(
     auto result = attribute_values_column->cloneEmpty();
     result->reserve(requested_key_points.size());
 
-    Field row_value_to_insert;
-    size_t polygon_index = 0;
-
-    size_t keys_found = 0;
-
-    if (unlikely(complex_attribute))
+    if (unlikely(attribute.is_nullable))
     {
-        for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)
-        {
-            const auto found = find(requested_key_points[requested_key_index], polygon_index);
-
-            if (found)
-            {
-                size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];
-                attribute_values_column->get(attribute_values_index, row_value_to_insert);
-                ++keys_found;
-            }
-            else
-                row_value_to_insert = default_value_provider.getDefaultValue(requested_key_index);
-
-            result->insert(row_value_to_insert);
-        }
+        getItemsImpl<Field>(
+            requested_key_points,
+            [&](size_t row) { return (*attribute_values_column)[row]; },
+            [&](Field & value) { result->insert(value); },
+            default_value_provider);
     }
     else
     {
@@ -91,10 +75,8 @@ ColumnPtr IPolygonDictionary::getColumn(
             using Type = std::decay_t<decltype(dictionary_attribute_type)>;
             using AttributeType = typename Type::AttributeType;
             using ValueType = DictionaryValueType<AttributeType>;
-            using ColumnType = std::conditional_t<
-                std::is_same_v<AttributeType, String>,
-                ColumnString,
-                std::conditional_t<IsDecimalNumber<AttributeType>, ColumnDecimal<ValueType>, ColumnVector<AttributeType>>>;
+            using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;
+            using ColumnType = typename ColumnProvider::ColumnType;
 
             const auto attribute_values_column_typed = typeid_cast<const ColumnType *>(attribute_values_column.get());
             if (!attribute_values_column_typed)
@@ -102,54 +84,38 @@ ColumnPtr IPolygonDictionary::getColumn(
 
             ColumnType & result_column_typed = static_cast<ColumnType &>(*result);
 
-            if constexpr (std::is_same_v<ColumnType, ColumnString>)
+            if constexpr (std::is_same_v<ValueType, Array>)
             {
-                for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)
-                {
-                    const auto found = find(requested_key_points[requested_key_index], polygon_index);
-
-                    if (found)
-                    {
-                        size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];
-                        auto data_to_insert = attribute_values_column->getDataAt(attribute_values_index);
-                        result_column_typed.insertData(data_to_insert.data, data_to_insert.size);
-                        ++keys_found;
-                    }
-                    else
-                        result_column_typed.insert(default_value_provider.getDefaultValue(requested_key_index));
-                }
+                getItemsImpl<ValueType>(
+                    requested_key_points,
+                    [&](size_t row) { return (*attribute_values_column)[row].get<Array>(); },
+                    [&](Array & value) { result_column_typed.insert(value); },
+                    default_value_provider);
+            }
+            else if constexpr (std::is_same_v<ValueType, StringRef>)
+            {
+                getItemsImpl<ValueType>(
+                    requested_key_points,
+                    [&](size_t row) { return attribute_values_column->getDataAt(row); },
+                    [&](StringRef value) { result_column_typed.insertData(value.data, value.size); },
+                    default_value_provider);
             }
             else
             {
                 auto & attribute_data = attribute_values_column_typed->getData();
                 auto & result_data = result_column_typed.getData();
 
-                for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)
-                {
-                    const auto found = find(requested_key_points[requested_key_index], polygon_index);
-
-                    if (found)
-                    {
-                        size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];
-                        auto & item = attribute_data[attribute_values_index];
-                        result_data.emplace_back(item);
-                        ++keys_found;
-                    }
-                    else
-                    {
-                        row_value_to_insert = default_value_provider.getDefaultValue(requested_key_index);
-                        result_data.emplace_back(row_value_to_insert.template get<NearestFieldType<ValueType>>());
-                    }
-                }
+                getItemsImpl<ValueType>(
+                    requested_key_points,
+                    [&](size_t row) { return attribute_data[row]; },
+                    [&](auto value) { result_data.emplace_back(value); },
+                    default_value_provider);
             }
         };
 
         callOnDictionaryAttributeType(attribute.underlying_type, type_call);
     }
 
-    query_count.fetch_add(requested_key_points.size(), std::memory_order_relaxed);
-    found_count.fetch_add(keys_found, std::memory_order_relaxed);
-
     return result;
 }
 
@@ -309,6 +275,55 @@ ColumnUInt8::Ptr IPolygonDictionary::hasKeys(const Columns & key_columns, const
     return result;
 }
 
+template <typename AttributeType, typename ValueGetter, typename ValueSetter, typename DefaultValueExtractor>
+void IPolygonDictionary::getItemsImpl(
+    const std::vector<IPolygonDictionary::Point> & requested_key_points,
+    ValueGetter && get_value,
+    ValueSetter && set_value,
+    DefaultValueExtractor & default_value_extractor) const
+{
+    size_t polygon_index = 0;
+    size_t keys_found = 0;
+
+    for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)
+    {
+        const auto found = find(requested_key_points[requested_key_index], polygon_index);
+
+        if (found)
+        {
+            size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];
+            auto value = get_value(attribute_values_index);
+            set_value(value);
+            ++keys_found;
+        }
+        else
+        {
+            Field default_value = default_value_extractor.getDefaultValue(requested_key_index);
+
+            if constexpr (std::is_same_v<AttributeType, Field>)
+            {
+                set_value(default_value);
+            }
+            else if constexpr (std::is_same_v<AttributeType, Array>)
+            {
+                set_value(default_value.get<Array>());
+            }
+            else if constexpr (std::is_same_v<AttributeType, StringRef>)
+            {
+                auto default_value_string = default_value.get<String>();
+                set_value(default_value_string);
+            }
+            else
+            {
+                set_value(default_value.get<NearestFieldType<AttributeType>>());
+            }
+        }
+    }
+
+    query_count.fetch_add(requested_key_points.size(), std::memory_order_relaxed);
+    found_count.fetch_add(keys_found, std::memory_order_relaxed);
+}
+
 namespace
 {
 
diff --git a/src/Dictionaries/PolygonDictionary.h b/src/Dictionaries/PolygonDictionary.h
index f43fc0c8f571..14492df6469b 100644
--- a/src/Dictionaries/PolygonDictionary.h
+++ b/src/Dictionaries/PolygonDictionary.h
@@ -49,6 +49,7 @@ class IPolygonDictionary : public IDictionary
         Array,
         Tuple,
     };
+
     IPolygonDictionary(
             const StorageID & dict_id_,
             const DictionaryStructure & dict_struct_,
@@ -138,10 +139,10 @@ class IPolygonDictionary : public IDictionary
     size_t getAttributeIndex(const std::string & attribute_name) const;
 
     /** Helper function for retrieving the value of an attribute by key. */
-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+    template <typename AttributeType, typename ValueGetter, typename ValueSetter, typename DefaultValueExtractor>
     void getItemsImpl(
-        size_t attribute_ind,
-        const Columns & key_columns,
+        const std::vector<IPolygonDictionary::Point> & requested_key_points,
+        ValueGetter && get_value,
         ValueSetter && set_value,
         DefaultValueExtractor & default_value_extractor) const;
 
diff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp
index b771bca068fa..584fba5ee8de 100644
--- a/src/Dictionaries/RangeHashedDictionary.cpp
+++ b/src/Dictionaries/RangeHashedDictionary.cpp
@@ -125,17 +125,30 @@ ColumnPtr RangeHashedDictionary::getColumn(
         using ValueType = DictionaryValueType<AttributeType>;
         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;
 
-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);
+        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);
         AttributeType null_value = static_cast<AttributeType>(attribute_null_value);
         DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);
 
         auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);
 
-        if constexpr (std::is_same_v<AttributeType, String>)
+        if constexpr (std::is_same_v<ValueType, Array>)
         {
             auto * out = column.get();
 
-            getItemsImpl<ValueType, ValueType>(
+            getItemsImpl<ValueType>(
+                attribute,
+                modified_key_columns,
+                [&](const size_t, const Array & value, bool)
+                {
+                    out->insert(value);
+                },
+                default_value_extractor);
+        }
+        else if constexpr (std::is_same_v<ValueType, StringRef>)
+        {
+            auto * out = column.get();
+
+            getItemsImpl<ValueType>(
                 attribute,
                 modified_key_columns,
                 [&](const size_t row, const StringRef value, bool is_null)
@@ -151,7 +164,7 @@ ColumnPtr RangeHashedDictionary::getColumn(
         {
             auto & out = column->getData();
 
-            getItemsImpl<ValueType, ValueType>(
+            getItemsImpl<ValueType>(
                 attribute,
                 modified_key_columns,
                 [&](const size_t row, const auto value, bool is_null)
@@ -369,7 +382,7 @@ void RangeHashedDictionary::createAttributeImpl<String>(Attribute & attribute, c
 }
 
 RangeHashedDictionary::Attribute
-RangeHashedDictionary::createAttribute(const DictionaryAttribute& attribute, const Field & null_value)
+RangeHashedDictionary::createAttribute(const DictionaryAttribute & attribute, const Field & null_value)
 {
     Attribute attr{attribute.underlying_type, attribute.is_nullable, {}, {}, {}};
 
@@ -385,7 +398,7 @@ RangeHashedDictionary::createAttribute(const DictionaryAttribute& attribute, con
     return attr;
 }
 
-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
 void RangeHashedDictionary::getItemsImpl(
     const Attribute & attribute,
     const Columns & key_columns,
@@ -422,8 +435,8 @@ void RangeHashedDictionary::getItemsImpl(
                 ++keys_found;
                 auto & value = val_it->value;
 
-                if (value)
-                    set_value(row, static_cast<OutputType>(*value), false); // NOLINT
+                if (value.has_value())
+                    set_value(row, *value, false);
                 else
                     set_value(row, default_value_extractor[row], true);
             }
diff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h
index edd8275acd1c..50888873c3cf 100644
--- a/src/Dictionaries/RangeHashedDictionary.h
+++ b/src/Dictionaries/RangeHashedDictionary.h
@@ -127,7 +127,8 @@ class RangeHashedDictionary final : public IDictionary
             Float32,
             Float64,
             UUID,
-            StringRef>
+            StringRef,
+            Array>
             null_values;
         std::variant<
             Ptr<UInt8>,
@@ -149,7 +150,8 @@ class RangeHashedDictionary final : public IDictionary
             Ptr<Float32>,
             Ptr<Float64>,
             Ptr<UUID>,
-            Ptr<StringRef>>
+            Ptr<StringRef>,
+            Ptr<Array>>
             maps;
         std::unique_ptr<Arena> string_arena;
     };
@@ -168,7 +170,7 @@ class RangeHashedDictionary final : public IDictionary
 
     static Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);
 
-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>
+    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>
     void getItemsImpl(
         const Attribute & attribute,
         const Columns & key_columns,
diff --git a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp
index 9cd1cebe4e0d..2099618588ea 100644
--- a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp
+++ b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp
@@ -17,6 +17,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E
     ParserKeyword s_injective{"INJECTIVE"};
     ParserKeyword s_is_object_id{"IS_OBJECT_ID"};
     ParserLiteral default_parser;
+    ParserArrayOfLiterals array_literals_parser;
     ParserTernaryOperatorExpression expression_parser;
 
     /// mandatory attribute name
@@ -40,8 +41,10 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E
     {
         if (!default_value && s_default.ignore(pos, expected))
         {
-            if (!default_parser.parse(pos, default_value, expected))
+            if (!default_parser.parse(pos, default_value, expected) &&
+                !array_literals_parser.parse(pos, default_value, expected))
                 return false;
+
             continue;
         }
 
