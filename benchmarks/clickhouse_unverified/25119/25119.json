{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25119,
  "instance_id": "ClickHouse__ClickHouse-25119",
  "issue_numbers": [
    "2135",
    "25085",
    "1640"
  ],
  "base_commit": "1c7c999b25d51834c26f0d6dbe410a25fb86fad7",
  "patch": "diff --git a/src/Dictionaries/CacheDictionaryStorage.h b/src/Dictionaries/CacheDictionaryStorage.h\nindex a79d83eea057..8374e649cd14 100644\n--- a/src/Dictionaries/CacheDictionaryStorage.h\n+++ b/src/Dictionaries/CacheDictionaryStorage.h\n@@ -55,7 +55,7 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n         cells.resize_fill(cells_size);\n         size_overlap_mask = cells_size - 1;\n \n-        setup(dictionary_structure);\n+        createAttributes(dictionary_structure);\n     }\n \n     bool returnsFetchedColumnsInOrderOfRequestedKeys() const override { return true; }\n@@ -226,23 +226,17 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n             auto & attribute = attributes[attribute_index];\n             const auto & default_value_provider = fetch_request.defaultValueProviderAtIndex(attribute_index);\n \n-            size_t fetched_keys_size = fetched_keys.size();\n             auto & fetched_column = *result.fetched_columns[attribute_index];\n-            fetched_column.reserve(fetched_keys_size);\n+            fetched_column.reserve(fetched_columns_index);\n \n-            if (unlikely(attribute.is_complex_type))\n+            if (unlikely(attribute.is_nullable))\n             {\n-                auto & container = std::get<std::vector<Field>>(attribute.attribute_container);\n-\n-                for (size_t fetched_key_index = 0; fetched_key_index < fetched_columns_index; ++fetched_key_index)\n-                {\n-                    auto fetched_key = fetched_keys[fetched_key_index];\n-\n-                    if (unlikely(fetched_key.is_default))\n-                        fetched_column.insert(default_value_provider.getDefaultValue(fetched_key_index));\n-                    else\n-                        fetched_column.insert(container[fetched_key.element_index]);\n-                }\n+                getItemsForFetchedKeys<Field>(\n+                    attribute,\n+                    fetched_columns_index,\n+                    fetched_keys,\n+                    [&](Field & value) { fetched_column.insert(value); },\n+                    default_value_provider);\n             }\n             else\n             {\n@@ -250,46 +244,40 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                 {\n                     using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n                     using AttributeType = typename Type::AttributeType;\n+                    using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n+                    using ColumnType = typename ColumnProvider::ColumnType;\n                     using ValueType = DictionaryValueType<AttributeType>;\n-                    using ColumnType =\n-                        std::conditional_t<std::is_same_v<AttributeType, String>, ColumnString,\n-                            std::conditional_t<IsDecimalNumber<AttributeType>, ColumnDecimal<ValueType>,\n-                                ColumnVector<AttributeType>>>;\n \n-                    auto & container = std::get<PaddedPODArray<ValueType>>(attribute.attribute_container);\n                     ColumnType & column_typed = static_cast<ColumnType &>(fetched_column);\n \n-                    if constexpr (std::is_same_v<ColumnType, ColumnString>)\n+                    if constexpr (std::is_same_v<ValueType, Array>)\n                     {\n-                        for (size_t fetched_key_index = 0; fetched_key_index < fetched_columns_index; ++fetched_key_index)\n-                        {\n-                            auto fetched_key = fetched_keys[fetched_key_index];\n-\n-                            if (unlikely(fetched_key.is_default))\n-                                column_typed.insert(default_value_provider.getDefaultValue(fetched_key_index));\n-                            else\n-                            {\n-                                auto item = container[fetched_key.element_index];\n-                                column_typed.insertData(item.data, item.size);\n-                            }\n-                        }\n+                        getItemsForFetchedKeys<ValueType>(\n+                            attribute,\n+                            fetched_columns_index,\n+                            fetched_keys,\n+                            [&](Array & value) { fetched_column.insert(value); },\n+                            default_value_provider);\n+                    }\n+                    else if constexpr (std::is_same_v<ValueType, StringRef>)\n+                    {\n+                        getItemsForFetchedKeys<ValueType>(\n+                            attribute,\n+                            fetched_columns_index,\n+                            fetched_keys,\n+                            [&](StringRef value) { fetched_column.insertData(value.data, value.size); },\n+                            default_value_provider);\n                     }\n                     else\n                     {\n                         auto & data = column_typed.getData();\n \n-                        for (size_t fetched_key_index = 0; fetched_key_index < fetched_columns_index; ++fetched_key_index)\n-                        {\n-                            auto fetched_key = fetched_keys[fetched_key_index];\n-\n-                            if (unlikely(fetched_key.is_default))\n-                                column_typed.insert(default_value_provider.getDefaultValue(fetched_key_index));\n-                            else\n-                            {\n-                                auto item = container[fetched_key.element_index];\n-                                data.push_back(item);\n-                            }\n-                        }\n+                        getItemsForFetchedKeys<ValueType>(\n+                            attribute,\n+                            fetched_columns_index,\n+                            fetched_keys,\n+                            [&](auto value) { data.push_back(value); },\n+                            default_value_provider);\n                     }\n                 };\n \n@@ -339,7 +327,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                         column->get(key_index, column_value);\n \n                         if constexpr (std::is_same_v<ElementType, Field>)\n+                        {\n                             container.back() = column_value;\n+                        }\n                         else if constexpr (std::is_same_v<ElementType, StringRef>)\n                         {\n                             const String & string_value = column_value.get<String>();\n@@ -348,7 +338,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                             container.back() = inserted_value;\n                         }\n                         else\n+                        {\n                             container.back() = column_value.get<NearestFieldType<ElementType>>();\n+                        }\n                     });\n                 }\n \n@@ -382,7 +374,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                         column->get(key_index, column_value);\n \n                         if constexpr (std::is_same_v<ElementType, Field>)\n+                        {\n                             container[index_to_use] = column_value;\n+                        }\n                         else if constexpr (std::is_same_v<ElementType, StringRef>)\n                         {\n                             const String & string_value = column_value.get<String>();\n@@ -398,7 +392,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                             container[index_to_use] = inserted_value;\n                         }\n                         else\n+                        {\n                             container[index_to_use] = column_value.get<NearestFieldType<ElementType>>();\n+                        }\n                     });\n                 }\n             }\n@@ -504,9 +500,9 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n         auto & attribute = attributes[attribute_index];\n         auto & attribute_type = attribute.type;\n \n-        if (unlikely(attribute.is_complex_type))\n+        if (unlikely(attribute.is_nullable))\n         {\n-            auto & container = std::get<std::vector<Field>>(attribute.attribute_container);\n+            auto & container = std::get<ContainerType<Field>>(attribute.attribute_container);\n             std::forward<GetContainerFunc>(func)(container);\n         }\n         else\n@@ -517,7 +513,7 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                 using AttributeType = typename Type::AttributeType;\n                 using ValueType = DictionaryValueType<AttributeType>;\n \n-                auto & container = std::get<PaddedPODArray<ValueType>>(attribute.attribute_container);\n+                auto & container = std::get<ContainerType<ValueType>>(attribute.attribute_container);\n                 std::forward<GetContainerFunc>(func)(container);\n             };\n \n@@ -541,7 +537,82 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n         return updated_value;\n     }\n \n-    void setup(const DictionaryStructure & dictionary_structure)\n+    template<typename ValueType>\n+    using ContainerType = std::conditional_t<\n+        std::is_same_v<ValueType, Field> || std::is_same_v<ValueType, Array>,\n+        std::vector<ValueType>,\n+        PaddedPODArray<ValueType>>;\n+\n+    struct Attribute\n+    {\n+        AttributeUnderlyingType type;\n+        bool is_nullable;\n+\n+        std::variant<\n+            ContainerType<UInt8>,\n+            ContainerType<UInt16>,\n+            ContainerType<UInt32>,\n+            ContainerType<UInt64>,\n+            ContainerType<UInt128>,\n+            ContainerType<UInt256>,\n+            ContainerType<Int8>,\n+            ContainerType<Int16>,\n+            ContainerType<Int32>,\n+            ContainerType<Int64>,\n+            ContainerType<Int128>,\n+            ContainerType<Int256>,\n+            ContainerType<Decimal32>,\n+            ContainerType<Decimal64>,\n+            ContainerType<Decimal128>,\n+            ContainerType<Decimal256>,\n+            ContainerType<Float32>,\n+            ContainerType<Float64>,\n+            ContainerType<UUID>,\n+            ContainerType<StringRef>,\n+            ContainerType<Array>,\n+            ContainerType<Field>> attribute_container;\n+    };\n+\n+    template <typename ValueType, typename ValueSetter>\n+    void getItemsForFetchedKeys(\n+        Attribute & attribute,\n+        size_t fetched_keys_size,\n+        PaddedPODArray<FetchedKey> & fetched_keys,\n+        ValueSetter && value_setter,\n+        const DefaultValueProvider & default_value_provider)\n+    {\n+        auto & container = std::get<ContainerType<ValueType>>(attribute.attribute_container);\n+\n+        for (size_t fetched_key_index = 0; fetched_key_index < fetched_keys_size; ++fetched_key_index)\n+        {\n+            auto fetched_key = fetched_keys[fetched_key_index];\n+\n+            if (unlikely(fetched_key.is_default))\n+            {\n+                auto default_value = default_value_provider.getDefaultValue(fetched_key_index);\n+\n+                if constexpr (std::is_same_v<ValueType, Field>)\n+                {\n+                    value_setter(default_value);\n+                }\n+                else if constexpr (std::is_same_v<ValueType, StringRef>)\n+                {\n+                    auto & value = default_value.get<String>();\n+                    value_setter(value);\n+                }\n+                else\n+                {\n+                    value_setter(default_value.get<ValueType>());\n+                }\n+            }\n+            else\n+            {\n+                value_setter(container[fetched_key.element_index]);\n+            }\n+        }\n+    }\n+\n+    void createAttributes(const DictionaryStructure & dictionary_structure)\n     {\n         /// For each dictionary attribute create storage attribute\n         /// For simple attributes create PODArray, for complex vector of Fields\n@@ -561,12 +632,12 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n                 attributes.emplace_back();\n                 auto & last_attribute = attributes.back();\n                 last_attribute.type = attribute_type;\n-                last_attribute.is_complex_type = dictionary_attribute.is_nullable || dictionary_attribute.is_array;\n+                last_attribute.is_nullable = dictionary_attribute.is_nullable;\n \n                 if (dictionary_attribute.is_nullable)\n-                    last_attribute.attribute_container = std::vector<Field>();\n+                    last_attribute.attribute_container = ContainerType<Field>();\n                 else\n-                    last_attribute.attribute_container = PaddedPODArray<ValueType>();\n+                    last_attribute.attribute_container = ContainerType<ValueType>();\n             };\n \n             callOnDictionaryAttributeType(attribute_type, type_call);\n@@ -583,35 +654,6 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage\n         time_t deadline;\n     };\n \n-    struct Attribute\n-    {\n-        AttributeUnderlyingType type;\n-        bool is_complex_type;\n-\n-        std::variant<\n-            PaddedPODArray<UInt8>,\n-            PaddedPODArray<UInt16>,\n-            PaddedPODArray<UInt32>,\n-            PaddedPODArray<UInt64>,\n-            PaddedPODArray<UInt128>,\n-            PaddedPODArray<UInt256>,\n-            PaddedPODArray<Int8>,\n-            PaddedPODArray<Int16>,\n-            PaddedPODArray<Int32>,\n-            PaddedPODArray<Int64>,\n-            PaddedPODArray<Int128>,\n-            PaddedPODArray<Int256>,\n-            PaddedPODArray<Decimal32>,\n-            PaddedPODArray<Decimal64>,\n-            PaddedPODArray<Decimal128>,\n-            PaddedPODArray<Decimal256>,\n-            PaddedPODArray<Float32>,\n-            PaddedPODArray<Float64>,\n-            PaddedPODArray<UUID>,\n-            PaddedPODArray<StringRef>,\n-            std::vector<Field>> attribute_container;\n-    };\n-\n     CacheDictionaryStorageConfiguration configuration;\n \n     pcg64 rnd_engine;\ndiff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h\nindex 6d459bab85f6..55027aa88538 100644\n--- a/src/Dictionaries/DictionaryHelpers.h\n+++ b/src/Dictionaries/DictionaryHelpers.h\n@@ -6,8 +6,11 @@\n #include <Columns/ColumnDecimal.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnVector.h>\n+#include <Columns/ColumnArray.h>\n #include <DataStreams/IBlockInputStream.h>\n #include <DataTypes/DataTypesDecimal.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeNullable.h>\n #include <Core/Block.h>\n #include <Dictionaries/IDictionary.h>\n #include <Dictionaries/DictionaryStructure.h>\n@@ -231,14 +234,27 @@ class DictionaryAttributeColumnProvider\n {\n public:\n     using ColumnType =\n-        std::conditional_t<std::is_same_v<DictionaryAttributeType, String>, ColumnString,\n-            std::conditional_t<IsDecimalNumber<DictionaryAttributeType>, ColumnDecimal<DictionaryAttributeType>,\n-                ColumnVector<DictionaryAttributeType>>>;\n+        std::conditional_t<std::is_same_v<DictionaryAttributeType, Array>, ColumnArray,\n+            std::conditional_t<std::is_same_v<DictionaryAttributeType, String>, ColumnString,\n+                std::conditional_t<IsDecimalNumber<DictionaryAttributeType>, ColumnDecimal<DictionaryAttributeType>,\n+                    ColumnVector<DictionaryAttributeType>>>>;\n \n     using ColumnPtr = typename ColumnType::MutablePtr;\n \n     static ColumnPtr getColumn(const DictionaryAttribute & dictionary_attribute, size_t size)\n     {\n+        if constexpr (std::is_same_v<DictionaryAttributeType, Array>)\n+        {\n+            if (const auto * array_type = typeid_cast<const DataTypeArray *>(dictionary_attribute.type.get()))\n+            {\n+                auto nested_column = array_type->getNestedType()->createColumn();\n+                return ColumnArray::create(std::move(nested_column));\n+            }\n+            else\n+            {\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Unsupported attribute type.\");\n+            }\n+        }\n         if constexpr (std::is_same_v<DictionaryAttributeType, String>)\n         {\n             return ColumnType::create();\n@@ -249,7 +265,8 @@ class DictionaryAttributeColumnProvider\n         }\n         else if constexpr (IsDecimalNumber<DictionaryAttributeType>)\n         {\n-            auto scale = getDecimalScale(*dictionary_attribute.nested_type);\n+            auto nested_type = removeNullable(dictionary_attribute.type);\n+            auto scale = getDecimalScale(*nested_type);\n             return ColumnType::create(size, scale);\n         }\n         else if constexpr (is_arithmetic_v<DictionaryAttributeType>)\n@@ -280,18 +297,18 @@ class DictionaryDefaultValueExtractor\n         : default_value(std::move(attribute_default_value))\n     {\n         if (default_values_column_ == nullptr)\n-            use_default_value_from_column = false;\n+            use_attribute_default_value = true;\n         else\n         {\n             if (const auto * const default_col = checkAndGetColumn<DefaultColumnType>(*default_values_column_))\n             {\n                 default_values_column = default_col;\n-                use_default_value_from_column = true;\n+                use_attribute_default_value = false;\n             }\n             else if (const auto * const default_col_const = checkAndGetColumnConst<DefaultColumnType>(default_values_column_.get()))\n             {\n                 default_value = default_col_const->template getValue<DictionaryAttributeType>();\n-                use_default_value_from_column = false;\n+                use_attribute_default_value = true;\n             }\n             else\n                 throw Exception(ErrorCodes::TYPE_MISMATCH, \"Type of default column is not the same as dictionary attribute type.\");\n@@ -300,12 +317,17 @@ class DictionaryDefaultValueExtractor\n \n     DefaultValueType operator[](size_t row)\n     {\n-        if (!use_default_value_from_column)\n+        if (use_attribute_default_value)\n             return static_cast<DefaultValueType>(default_value);\n \n         assert(default_values_column != nullptr);\n \n-        if constexpr (std::is_same_v<DefaultColumnType, ColumnString>)\n+        if constexpr (std::is_same_v<DefaultColumnType, ColumnArray>)\n+        {\n+            Field field = (*default_values_column)[row];\n+            return field.get<Array>();\n+        }\n+        else if constexpr (std::is_same_v<DefaultColumnType, ColumnString>)\n             return default_values_column->getDataAt(row);\n         else\n             return default_values_column->getData()[row];\n@@ -313,7 +335,7 @@ class DictionaryDefaultValueExtractor\n private:\n     DictionaryAttributeType default_value;\n     const DefaultColumnType * default_values_column = nullptr;\n-    bool use_default_value_from_column = false;\n+    bool use_attribute_default_value = false;\n };\n \n template <DictionaryKeyType key_type>\ndiff --git a/src/Dictionaries/DictionarySourceFactory.cpp b/src/Dictionaries/DictionarySourceFactory.cpp\nindex 507d11eba8e7..41b3fbb68b4e 100644\n--- a/src/Dictionaries/DictionarySourceFactory.cpp\n+++ b/src/Dictionaries/DictionarySourceFactory.cpp\n@@ -25,9 +25,10 @@ namespace\n         Block block;\n \n         if (dict_struct.id)\n+        {\n             block.insert(ColumnWithTypeAndName{ColumnUInt64::create(1, 0), std::make_shared<DataTypeUInt64>(), dict_struct.id->name});\n-\n-        if (dict_struct.key)\n+        }\n+        else if (dict_struct.key)\n         {\n             for (const auto & attribute : *dict_struct.key)\n             {\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex c0d00d3ae40d..a6de85f83f54 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -79,9 +79,7 @@ AttributeUnderlyingType getAttributeUnderlyingType(const DataTypePtr & type)\n \n         case TypeIndex::String:         return AttributeUnderlyingType::String;\n \n-        // Temporary hack to allow arrays in keys, since they are never retrieved for polygon dictionaries.\n-        // TODO: This should be fixed by fully supporting arrays in dictionaries.\n-        case TypeIndex::Array:          return AttributeUnderlyingType::String;\n+        case TypeIndex::Array:          return AttributeUnderlyingType::Array;\n \n         default: break;\n     }\n@@ -125,7 +123,7 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration\n         id.emplace(config, structure_prefix + \".id\");\n     else if (has_key)\n     {\n-        key.emplace(getAttributes(config, structure_prefix + \".key\", true));\n+        key.emplace(getAttributes(config, structure_prefix + \".key\", /*complex_key_attributes =*/ true));\n         if (key->empty())\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty 'key' supplied\");\n     }\n@@ -173,7 +171,7 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration\n             has_expressions = true;\n     }\n \n-    attributes = getAttributes(config, structure_prefix, false);\n+    attributes = getAttributes(config, structure_prefix, /*complex_key_attributes =*/ false);\n \n     for (size_t i = 0; i < attributes.size(); ++i)\n     {\n@@ -375,17 +373,10 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n \n         const auto type_string = config.getString(prefix + \"type\");\n         const auto initial_type = DataTypeFactory::instance().get(type_string);\n-        auto type = initial_type;\n-        bool is_array = false;\n-        bool is_nullable = false;\n+        bool is_nullable = initial_type->isNullable();\n \n-        if (type->isNullable())\n-        {\n-            is_nullable = true;\n-            type = removeNullable(type);\n-        }\n-\n-        const auto underlying_type = getAttributeUnderlyingType(type);\n+        auto non_nullable_type = removeNullable(initial_type);\n+        const auto underlying_type = getAttributeUnderlyingType(non_nullable_type);\n \n         const auto expression = config.getString(prefix + \"expression\", \"\");\n         if (!expression.empty())\n@@ -394,26 +385,27 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n         Field null_value;\n         if (allow_null_values)\n         {\n+            /// TODO: Fix serialization for nullable type.\n             const auto null_value_string = config.getString(prefix + \"null_value\");\n+\n             try\n             {\n                 if (null_value_string.empty())\n                 {\n-                    null_value = type->getDefault();\n+                    null_value = non_nullable_type->getDefault();\n                 }\n                 else\n                 {\n                     ReadBufferFromString null_value_buffer{null_value_string};\n-                    auto column_with_null_value = type->createColumn();\n-                    type->getDefaultSerialization()->deserializeTextEscaped(*column_with_null_value, null_value_buffer, format_settings);\n+                    auto column_with_null_value = non_nullable_type->createColumn();\n+                    non_nullable_type->getDefaultSerialization()->deserializeTextEscaped(*column_with_null_value, null_value_buffer, format_settings);\n                     null_value = (*column_with_null_value)[0];\n                 }\n             }\n             catch (Exception & e)\n             {\n                 String dictionary_name = config.getString(\".dictionary.name\", \"\");\n-                e.addMessage(\"While parsing null_value for attribute with name \" + name\n-                    + \" in dictionary \" + dictionary_name);\n+                e.addMessage(fmt::format(\"While parsing null_value for attribute with name {} in dictionary {}\", name, dictionary_name));\n                 throw;\n             }\n         }\n@@ -436,15 +428,12 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n             name,\n             underlying_type,\n             initial_type,\n-            initial_type->getDefaultSerialization(),\n-            type,\n             expression,\n             null_value,\n             hierarchical,\n             injective,\n             is_object_id,\n-            is_nullable,\n-            is_array});\n+            is_nullable});\n     }\n \n     return res_attributes;\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 4815501b6962..9509aa97ce04 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -39,6 +39,7 @@\n     M(Decimal256) \\\n     M(UUID) \\\n     M(String) \\\n+    M(Array) \\\n \n \n namespace DB\n@@ -74,15 +75,12 @@ struct DictionaryAttribute final\n     const std::string name;\n     const AttributeUnderlyingType underlying_type;\n     const DataTypePtr type;\n-    const SerializationPtr serialization;\n-    const DataTypePtr nested_type;\n     const std::string expression;\n     const Field null_value;\n     const bool hierarchical;\n     const bool injective;\n     const bool is_object_id;\n     const bool is_nullable;\n-    const bool is_array;\n };\n \n template <typename Type>\n@@ -92,7 +90,7 @@ struct DictionaryAttributeType\n };\n \n template <typename F>\n-void callOnDictionaryAttributeType(AttributeUnderlyingType type, F&& func)\n+void callOnDictionaryAttributeType(AttributeUnderlyingType type, F && func)\n {\n     switch (type)\n     {\ndiff --git a/src/Dictionaries/ExternalQueryBuilder.cpp b/src/Dictionaries/ExternalQueryBuilder.cpp\nindex 8c6e9f60afbe..1fc5d160bb0f 100644\n--- a/src/Dictionaries/ExternalQueryBuilder.cpp\n+++ b/src/Dictionaries/ExternalQueryBuilder.cpp\n@@ -358,7 +358,8 @@ void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, cons\n         /// key_i=value_i\n         writeQuoted(key_description.name, out);\n         writeString(\"=\", out);\n-        key_description.serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n+        auto serialization = key_description.type->getDefaultSerialization();\n+        serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n     }\n }\n \n@@ -415,7 +416,8 @@ void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const si\n             writeString(\", \", out);\n \n         first = false;\n-        (*dict_struct.key)[i].serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n+        auto serialization = (*dict_struct.key)[i].type->getDefaultSerialization();\n+        serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n     }\n \n     writeString(\")\", out);\ndiff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex f58384a3b8ee..0a95165de4e6 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -70,17 +70,27 @@ ColumnPtr FlatDictionary::getColumn(\n         using ValueType = DictionaryValueType<AttributeType>;\n         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n \n-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);\n+        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);\n         AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n         DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n \n-        if constexpr (std::is_same_v<ValueType, StringRef>)\n+        if constexpr (std::is_same_v<ValueType, Array>)\n+        {\n+            auto * out = column.get();\n+\n+            getItemsImpl<ValueType>(\n+                attribute,\n+                ids,\n+                [&](const size_t, const Array & value) { out->insert(value); },\n+                default_value_extractor);\n+        }\n+        else if constexpr (std::is_same_v<ValueType, StringRef>)\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType, ValueType>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n                 ids,\n                 [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },\n@@ -90,7 +100,7 @@ ColumnPtr FlatDictionary::getColumn(\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<ValueType, ValueType>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n                 ids,\n                 [&](const size_t row, const auto value) { out[row] = value; },\n@@ -275,6 +285,7 @@ void FlatDictionary::blockToAttributes(const Block & block)\n \n             if (already_processed_keys.find(key) != nullptr)\n                 continue;\n+\n             already_processed_keys.insert(key);\n \n             setAttributeValue(attribute, key, attribute_column[i]);\n@@ -352,7 +363,18 @@ void FlatDictionary::calculateBytesAllocated()\n             using ValueType = DictionaryValueType<AttributeType>;\n \n             const auto & container = std::get<ContainerType<ValueType>>(attribute.container);\n-            bytes_allocated += sizeof(PaddedPODArray<ValueType>) + container.allocated_bytes();\n+            bytes_allocated += sizeof(ContainerType<ValueType>);\n+\n+            if constexpr (std::is_same_v<ValueType, Array>)\n+            {\n+                /// It is not accurate calculations\n+                bytes_allocated += sizeof(Array) * container.size();\n+            }\n+            else\n+            {\n+                bytes_allocated += container.allocated_bytes();\n+            }\n+\n             bucket_count = container.capacity();\n \n             if constexpr (std::is_same_v<ValueType, StringRef>)\n@@ -396,7 +418,7 @@ FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttrib\n     return attribute;\n }\n \n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n void FlatDictionary::getItemsImpl(\n     const Attribute & attribute,\n     const PaddedPODArray<UInt64> & keys,\n@@ -414,7 +436,7 @@ void FlatDictionary::getItemsImpl(\n \n         if (key < loaded_keys.size() && loaded_keys[key])\n         {\n-            set_value(row, static_cast<OutputType>(container[key]));\n+            set_value(row, container[key]);\n             ++keys_found;\n         }\n         else\n@@ -440,7 +462,11 @@ void FlatDictionary::resize(Attribute & attribute, UInt64 key)\n     {\n         const size_t elements_count = key + 1; //id=0 -> elements_count=1\n         loaded_keys.resize(elements_count, false);\n-        container.resize_fill(elements_count, std::get<T>(attribute.null_values));\n+\n+        if constexpr (std::is_same_v<T, Array>)\n+            container.resize(elements_count, std::get<T>(attribute.null_values));\n+        else\n+            container.resize_fill(elements_count, std::get<T>(attribute.null_values));\n     }\n }\n \n@@ -461,13 +487,13 @@ void FlatDictionary::setAttributeValueImpl<String>(Attribute & attribute, UInt64\n \n void FlatDictionary::setAttributeValue(Attribute & attribute, const UInt64 key, const Field & value)\n {\n-    auto type_call = [&](const auto &dictionary_attribute_type)\n+    auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n-        using ResizeType = std::conditional_t<std::is_same_v<AttributeType, String>, StringRef, AttributeType>;\n+        using ValueType = DictionaryValueType<AttributeType>;\n \n-        resize<ResizeType>(attribute, key);\n+        resize<ValueType>(attribute, key);\n \n         if (attribute.nullable_set)\n         {\ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex 211b1cdc33dc..ec725bcdda2d 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -106,7 +106,7 @@ class FlatDictionary final : public IDictionary\n \n private:\n     template <typename Value>\n-    using ContainerType = PaddedPODArray<Value>;\n+    using ContainerType = std::conditional_t<std::is_same_v<Value, Array>, std::vector<Value>, PaddedPODArray<Value>>;\n \n     using NullableSet = HashSet<UInt64, DefaultHash<UInt64>>;\n \n@@ -135,8 +135,10 @@ class FlatDictionary final : public IDictionary\n             Float32,\n             Float64,\n             UUID,\n-            StringRef>\n+            StringRef,\n+            Array>\n             null_values;\n+\n         std::variant<\n             ContainerType<UInt8>,\n             ContainerType<UInt16>,\n@@ -157,7 +159,8 @@ class FlatDictionary final : public IDictionary\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n             ContainerType<UUID>,\n-            ContainerType<StringRef>>\n+            ContainerType<StringRef>,\n+            ContainerType<Array>>\n             container;\n \n         std::unique_ptr<Arena> string_arena;\n@@ -172,7 +175,7 @@ class FlatDictionary final : public IDictionary\n \n     Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);\n \n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n         const PaddedPODArray<UInt64> & keys,\ndiff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp\nindex 0de28f18006b..fd070c4df33c 100644\n--- a/src/Dictionaries/HashedDictionary.cpp\n+++ b/src/Dictionaries/HashedDictionary.cpp\n@@ -90,13 +90,26 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(\n         using ValueType = DictionaryValueType<AttributeType>;\n         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n \n-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);\n+        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);\n         AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n         DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n \n-        if constexpr (std::is_same_v<ValueType, StringRef>)\n+        if constexpr (std::is_same_v<ValueType, Array>)\n+        {\n+            auto * out = column.get();\n+\n+            getItemsImpl<ValueType>(\n+                attribute,\n+                extractor,\n+                [&](const size_t, const Array & value) { out->insert(value); },\n+                [&](const size_t)\n+                {\n+                },\n+                default_value_extractor);\n+        }\n+        else if constexpr (std::is_same_v<ValueType, StringRef>)\n         {\n             auto * out = column.get();\n \ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex 324b7601a28c..9a67c9d39012 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -173,7 +173,8 @@ class HashedDictionary final : public IDictionary\n             Float32,\n             Float64,\n             UUID,\n-            StringRef>\n+            StringRef,\n+            Array>\n             null_values;\n \n         std::variant<\n@@ -196,7 +197,8 @@ class HashedDictionary final : public IDictionary\n             CollectionType<Float32>,\n             CollectionType<Float64>,\n             CollectionType<UUID>,\n-            CollectionType<StringRef>>\n+            CollectionType<StringRef>,\n+            CollectionType<Array>>\n             container;\n \n         std::unique_ptr<Arena> string_arena;\ndiff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp\nindex a0630ab324c8..222664615384 100644\n--- a/src/Dictionaries/IPAddressDictionary.cpp\n+++ b/src/Dictionaries/IPAddressDictionary.cpp\n@@ -27,6 +27,7 @@ namespace ErrorCodes\n     extern const int DICTIONARY_IS_EMPTY;\n     extern const int LOGICAL_ERROR;\n     extern const int TYPE_MISMATCH;\n+    extern const int UNSUPPORTED_METHOD;\n }\n \n namespace\n@@ -237,11 +238,21 @@ ColumnPtr IPAddressDictionary::getColumn(\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n \n-        if constexpr (std::is_same_v<AttributeType, String>)\n+        if constexpr (std::is_same_v<ValueType, Array>)\n+        {\n+            auto * out = column.get();\n+\n+            getItemsImpl<ValueType>(\n+                attribute,\n+                key_columns,\n+                [&](const size_t, const Array & value) { out->insert(value); },\n+                default_value_extractor);\n+        }\n+        else if constexpr (std::is_same_v<ValueType, StringRef>)\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType, ValueType>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n                 key_columns,\n                 [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },\n@@ -251,7 +262,7 @@ ColumnPtr IPAddressDictionary::getColumn(\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<ValueType, ValueType>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n                 key_columns,\n                 [&](const size_t row, const auto value) { return out[row] = value; },\n@@ -315,8 +326,15 @@ void IPAddressDictionary::createAttributes()\n     auto create_attributes_from_dictionary_attributes = [this](const std::vector<DictionaryAttribute> & dict_attrs)\n     {\n         attributes.reserve(attributes.size() + dict_attrs.size());\n+\n         for (const auto & attribute : dict_attrs)\n         {\n+            if (attribute.is_nullable)\n+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                    \"{}: array or nullable attributes not supported for dictionary of type {}\",\n+                    full_name,\n+                    getTypeName());\n+\n             attribute_index_by_name.emplace(attribute.name, attributes.size());\n             attributes.push_back(createAttributeWithType(attribute.underlying_type, attribute.null_value));\n \n@@ -583,7 +601,7 @@ const uint8_t * IPAddressDictionary::getIPv6FromOffset(const IPAddressDictionary\n     return reinterpret_cast<const uint8_t *>(&ipv6_col[i * IPV6_BINARY_LENGTH]);\n }\n \n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n void IPAddressDictionary::getItemsByTwoKeyColumnsImpl(\n     const Attribute & attribute,\n     const Columns & key_columns,\n@@ -622,7 +640,7 @@ void IPAddressDictionary::getItemsByTwoKeyColumnsImpl(\n                 (*ipv4_col)[*found_it] == addr &&\n                 mask_column[*found_it] == mask))\n             {\n-                set_value(i, static_cast<OutputType>(vec[row_idx[*found_it]]));\n+                set_value(i, vec[row_idx[*found_it]]);\n             }\n             else\n                 set_value(i, default_value_extractor[i]);\n@@ -658,13 +676,13 @@ void IPAddressDictionary::getItemsByTwoKeyColumnsImpl(\n         if (likely(found_it != range.end() &&\n             memequal16(getIPv6FromOffset(*ipv6_col, *found_it), target.addr) &&\n             mask_column[*found_it] == mask))\n-            set_value(i, static_cast<OutputType>(vec[row_idx[*found_it]]));\n+            set_value(i, vec[row_idx[*found_it]]);\n         else\n             set_value(i, default_value_extractor[i]);\n     }\n }\n \n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n void IPAddressDictionary::getItemsImpl(\n     const Attribute & attribute,\n     const Columns & key_columns,\n@@ -677,7 +695,7 @@ void IPAddressDictionary::getItemsImpl(\n     // special case for getBlockInputStream\n     if (unlikely(key_columns.size() == 2))\n     {\n-        getItemsByTwoKeyColumnsImpl<AttributeType, OutputType>(\n+        getItemsByTwoKeyColumnsImpl<AttributeType>(\n             attribute, key_columns, std::forward<ValueSetter>(set_value), default_value_extractor);\n         query_count.fetch_add(rows, std::memory_order_relaxed);\n         return;\n@@ -697,7 +715,7 @@ void IPAddressDictionary::getItemsImpl(\n             auto found = tryLookupIPv4(addrv4, addrv6_buf);\n             if (found != ipNotFound())\n             {\n-                set_value(i, static_cast<OutputType>(vec[*found]));\n+                set_value(i, vec[*found]);\n                 ++keys_found;\n             }\n             else\n@@ -715,7 +733,7 @@ void IPAddressDictionary::getItemsImpl(\n             auto found = tryLookupIPv6(reinterpret_cast<const uint8_t *>(addr.data));\n             if (found != ipNotFound())\n             {\n-                set_value(i, static_cast<OutputType>(vec[*found]));\n+                set_value(i, vec[*found]);\n                 ++keys_found;\n             }\n             else\ndiff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h\nindex edca68aedbaa..075742da11a4 100644\n--- a/src/Dictionaries/IPAddressDictionary.h\n+++ b/src/Dictionaries/IPAddressDictionary.h\n@@ -116,7 +116,8 @@ class IPAddressDictionary final : public IDictionary\n             Float32,\n             Float64,\n             UUID,\n-            String>\n+            String,\n+            Array>\n             null_values;\n         std::variant<\n             ContainerType<UInt8>,\n@@ -138,7 +139,8 @@ class IPAddressDictionary final : public IDictionary\n             ContainerType<Float32>,\n             ContainerType<Float64>,\n             ContainerType<UUID>,\n-            ContainerType<StringRef>>\n+            ContainerType<StringRef>,\n+            ContainerType<Array>>\n             maps;\n         std::unique_ptr<Arena> string_arena;\n     };\n@@ -157,14 +159,14 @@ class IPAddressDictionary final : public IDictionary\n \n     static Attribute createAttributeWithType(const AttributeUnderlyingType type, const Field & null_value);\n \n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsByTwoKeyColumnsImpl(\n         const Attribute & attribute,\n         const Columns & key_columns,\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType,typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n         const Columns & key_columns,\ndiff --git a/src/Dictionaries/PolygonDictionary.cpp b/src/Dictionaries/PolygonDictionary.cpp\nindex 084228c98aec..17e7605d1368 100644\n--- a/src/Dictionaries/PolygonDictionary.cpp\n+++ b/src/Dictionaries/PolygonDictionary.cpp\n@@ -52,7 +52,6 @@ ColumnPtr IPolygonDictionary::getColumn(\n     const auto requested_key_points = extractPoints(key_columns);\n \n     const auto & attribute = dict_struct.getAttribute(attribute_name, result_type);\n-    bool complex_attribute = attribute.is_nullable || attribute.is_array;\n     DefaultValueProvider default_value_provider(attribute.null_value, default_values_column);\n \n     size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n@@ -61,28 +60,13 @@ ColumnPtr IPolygonDictionary::getColumn(\n     auto result = attribute_values_column->cloneEmpty();\n     result->reserve(requested_key_points.size());\n \n-    Field row_value_to_insert;\n-    size_t polygon_index = 0;\n-\n-    size_t keys_found = 0;\n-\n-    if (unlikely(complex_attribute))\n+    if (unlikely(attribute.is_nullable))\n     {\n-        for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n-        {\n-            const auto found = find(requested_key_points[requested_key_index], polygon_index);\n-\n-            if (found)\n-            {\n-                size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n-                attribute_values_column->get(attribute_values_index, row_value_to_insert);\n-                ++keys_found;\n-            }\n-            else\n-                row_value_to_insert = default_value_provider.getDefaultValue(requested_key_index);\n-\n-            result->insert(row_value_to_insert);\n-        }\n+        getItemsImpl<Field>(\n+            requested_key_points,\n+            [&](size_t row) { return (*attribute_values_column)[row]; },\n+            [&](Field & value) { result->insert(value); },\n+            default_value_provider);\n     }\n     else\n     {\n@@ -91,10 +75,8 @@ ColumnPtr IPolygonDictionary::getColumn(\n             using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n             using AttributeType = typename Type::AttributeType;\n             using ValueType = DictionaryValueType<AttributeType>;\n-            using ColumnType = std::conditional_t<\n-                std::is_same_v<AttributeType, String>,\n-                ColumnString,\n-                std::conditional_t<IsDecimalNumber<AttributeType>, ColumnDecimal<ValueType>, ColumnVector<AttributeType>>>;\n+            using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n+            using ColumnType = typename ColumnProvider::ColumnType;\n \n             const auto attribute_values_column_typed = typeid_cast<const ColumnType *>(attribute_values_column.get());\n             if (!attribute_values_column_typed)\n@@ -102,54 +84,38 @@ ColumnPtr IPolygonDictionary::getColumn(\n \n             ColumnType & result_column_typed = static_cast<ColumnType &>(*result);\n \n-            if constexpr (std::is_same_v<ColumnType, ColumnString>)\n+            if constexpr (std::is_same_v<ValueType, Array>)\n             {\n-                for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n-                {\n-                    const auto found = find(requested_key_points[requested_key_index], polygon_index);\n-\n-                    if (found)\n-                    {\n-                        size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n-                        auto data_to_insert = attribute_values_column->getDataAt(attribute_values_index);\n-                        result_column_typed.insertData(data_to_insert.data, data_to_insert.size);\n-                        ++keys_found;\n-                    }\n-                    else\n-                        result_column_typed.insert(default_value_provider.getDefaultValue(requested_key_index));\n-                }\n+                getItemsImpl<ValueType>(\n+                    requested_key_points,\n+                    [&](size_t row) { return (*attribute_values_column)[row].get<Array>(); },\n+                    [&](Array & value) { result_column_typed.insert(value); },\n+                    default_value_provider);\n+            }\n+            else if constexpr (std::is_same_v<ValueType, StringRef>)\n+            {\n+                getItemsImpl<ValueType>(\n+                    requested_key_points,\n+                    [&](size_t row) { return attribute_values_column->getDataAt(row); },\n+                    [&](StringRef value) { result_column_typed.insertData(value.data, value.size); },\n+                    default_value_provider);\n             }\n             else\n             {\n                 auto & attribute_data = attribute_values_column_typed->getData();\n                 auto & result_data = result_column_typed.getData();\n \n-                for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n-                {\n-                    const auto found = find(requested_key_points[requested_key_index], polygon_index);\n-\n-                    if (found)\n-                    {\n-                        size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n-                        auto & item = attribute_data[attribute_values_index];\n-                        result_data.emplace_back(item);\n-                        ++keys_found;\n-                    }\n-                    else\n-                    {\n-                        row_value_to_insert = default_value_provider.getDefaultValue(requested_key_index);\n-                        result_data.emplace_back(row_value_to_insert.template get<NearestFieldType<ValueType>>());\n-                    }\n-                }\n+                getItemsImpl<ValueType>(\n+                    requested_key_points,\n+                    [&](size_t row) { return attribute_data[row]; },\n+                    [&](auto value) { result_data.emplace_back(value); },\n+                    default_value_provider);\n             }\n         };\n \n         callOnDictionaryAttributeType(attribute.underlying_type, type_call);\n     }\n \n-    query_count.fetch_add(requested_key_points.size(), std::memory_order_relaxed);\n-    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n-\n     return result;\n }\n \n@@ -309,6 +275,55 @@ ColumnUInt8::Ptr IPolygonDictionary::hasKeys(const Columns & key_columns, const\n     return result;\n }\n \n+template <typename AttributeType, typename ValueGetter, typename ValueSetter, typename DefaultValueExtractor>\n+void IPolygonDictionary::getItemsImpl(\n+    const std::vector<IPolygonDictionary::Point> & requested_key_points,\n+    ValueGetter && get_value,\n+    ValueSetter && set_value,\n+    DefaultValueExtractor & default_value_extractor) const\n+{\n+    size_t polygon_index = 0;\n+    size_t keys_found = 0;\n+\n+    for (size_t requested_key_index = 0; requested_key_index < requested_key_points.size(); ++requested_key_index)\n+    {\n+        const auto found = find(requested_key_points[requested_key_index], polygon_index);\n+\n+        if (found)\n+        {\n+            size_t attribute_values_index = polygon_index_to_attribute_value_index[polygon_index];\n+            auto value = get_value(attribute_values_index);\n+            set_value(value);\n+            ++keys_found;\n+        }\n+        else\n+        {\n+            Field default_value = default_value_extractor.getDefaultValue(requested_key_index);\n+\n+            if constexpr (std::is_same_v<AttributeType, Field>)\n+            {\n+                set_value(default_value);\n+            }\n+            else if constexpr (std::is_same_v<AttributeType, Array>)\n+            {\n+                set_value(default_value.get<Array>());\n+            }\n+            else if constexpr (std::is_same_v<AttributeType, StringRef>)\n+            {\n+                auto default_value_string = default_value.get<String>();\n+                set_value(default_value_string);\n+            }\n+            else\n+            {\n+                set_value(default_value.get<NearestFieldType<AttributeType>>());\n+            }\n+        }\n+    }\n+\n+    query_count.fetch_add(requested_key_points.size(), std::memory_order_relaxed);\n+    found_count.fetch_add(keys_found, std::memory_order_relaxed);\n+}\n+\n namespace\n {\n \ndiff --git a/src/Dictionaries/PolygonDictionary.h b/src/Dictionaries/PolygonDictionary.h\nindex f43fc0c8f571..14492df6469b 100644\n--- a/src/Dictionaries/PolygonDictionary.h\n+++ b/src/Dictionaries/PolygonDictionary.h\n@@ -49,6 +49,7 @@ class IPolygonDictionary : public IDictionary\n         Array,\n         Tuple,\n     };\n+\n     IPolygonDictionary(\n             const StorageID & dict_id_,\n             const DictionaryStructure & dict_struct_,\n@@ -138,10 +139,10 @@ class IPolygonDictionary : public IDictionary\n     size_t getAttributeIndex(const std::string & attribute_name) const;\n \n     /** Helper function for retrieving the value of an attribute by key. */\n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, typename ValueGetter, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n-        size_t attribute_ind,\n-        const Columns & key_columns,\n+        const std::vector<IPolygonDictionary::Point> & requested_key_points,\n+        ValueGetter && get_value,\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex b771bca068fa..584fba5ee8de 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -125,17 +125,30 @@ ColumnPtr RangeHashedDictionary::getColumn(\n         using ValueType = DictionaryValueType<AttributeType>;\n         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n \n-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);\n+        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);\n         AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n         DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);\n \n-        if constexpr (std::is_same_v<AttributeType, String>)\n+        if constexpr (std::is_same_v<ValueType, Array>)\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType, ValueType>(\n+            getItemsImpl<ValueType>(\n+                attribute,\n+                modified_key_columns,\n+                [&](const size_t, const Array & value, bool)\n+                {\n+                    out->insert(value);\n+                },\n+                default_value_extractor);\n+        }\n+        else if constexpr (std::is_same_v<ValueType, StringRef>)\n+        {\n+            auto * out = column.get();\n+\n+            getItemsImpl<ValueType>(\n                 attribute,\n                 modified_key_columns,\n                 [&](const size_t row, const StringRef value, bool is_null)\n@@ -151,7 +164,7 @@ ColumnPtr RangeHashedDictionary::getColumn(\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<ValueType, ValueType>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n                 modified_key_columns,\n                 [&](const size_t row, const auto value, bool is_null)\n@@ -369,7 +382,7 @@ void RangeHashedDictionary::createAttributeImpl<String>(Attribute & attribute, c\n }\n \n RangeHashedDictionary::Attribute\n-RangeHashedDictionary::createAttribute(const DictionaryAttribute& attribute, const Field & null_value)\n+RangeHashedDictionary::createAttribute(const DictionaryAttribute & attribute, const Field & null_value)\n {\n     Attribute attr{attribute.underlying_type, attribute.is_nullable, {}, {}, {}};\n \n@@ -385,7 +398,7 @@ RangeHashedDictionary::createAttribute(const DictionaryAttribute& attribute, con\n     return attr;\n }\n \n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n void RangeHashedDictionary::getItemsImpl(\n     const Attribute & attribute,\n     const Columns & key_columns,\n@@ -422,8 +435,8 @@ void RangeHashedDictionary::getItemsImpl(\n                 ++keys_found;\n                 auto & value = val_it->value;\n \n-                if (value)\n-                    set_value(row, static_cast<OutputType>(*value), false); // NOLINT\n+                if (value.has_value())\n+                    set_value(row, *value, false);\n                 else\n                     set_value(row, default_value_extractor[row], true);\n             }\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex edd8275acd1c..50888873c3cf 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -127,7 +127,8 @@ class RangeHashedDictionary final : public IDictionary\n             Float32,\n             Float64,\n             UUID,\n-            StringRef>\n+            StringRef,\n+            Array>\n             null_values;\n         std::variant<\n             Ptr<UInt8>,\n@@ -149,7 +150,8 @@ class RangeHashedDictionary final : public IDictionary\n             Ptr<Float32>,\n             Ptr<Float64>,\n             Ptr<UUID>,\n-            Ptr<StringRef>>\n+            Ptr<StringRef>,\n+            Ptr<Array>>\n             maps;\n         std::unique_ptr<Arena> string_arena;\n     };\n@@ -168,7 +170,7 @@ class RangeHashedDictionary final : public IDictionary\n \n     static Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);\n \n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n         const Columns & key_columns,\ndiff --git a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\nindex 9cd1cebe4e0d..2099618588ea 100644\n--- a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\n+++ b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\n@@ -17,6 +17,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_injective{\"INJECTIVE\"};\n     ParserKeyword s_is_object_id{\"IS_OBJECT_ID\"};\n     ParserLiteral default_parser;\n+    ParserArrayOfLiterals array_literals_parser;\n     ParserTernaryOperatorExpression expression_parser;\n \n     /// mandatory attribute name\n@@ -40,8 +41,10 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n     {\n         if (!default_value && s_default.ignore(pos, expected))\n         {\n-            if (!default_parser.parse(pos, default_value, expected))\n+            if (!default_parser.parse(pos, default_value, expected) &&\n+                !array_literals_parser.parse(pos, default_value, expected))\n                 return false;\n+\n             continue;\n         }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01902_dictionary_array_type.reference b/tests/queries/0_stateless/01902_dictionary_array_type.reference\nnew file mode 100644\nindex 000000000000..b7f0ff968c64\n--- /dev/null\n+++ b/tests/queries/0_stateless/01902_dictionary_array_type.reference\n@@ -0,0 +1,28 @@\n+Flat dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\n+Hashed dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\n+Cache dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\n+Direct dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\n+IPTrie dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\n+Polygon dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\n+Range dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\ndiff --git a/tests/queries/0_stateless/01902_dictionary_array_type.sql b/tests/queries/0_stateless/01902_dictionary_array_type.sql\nnew file mode 100644\nindex 000000000000..fcd41c77819d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01902_dictionary_array_type.sql\n@@ -0,0 +1,164 @@\n+DROP TABLE IF EXISTS dictionary_array_source_table;\n+CREATE TABLE dictionary_array_source_table\n+(\n+    id UInt64,\n+    array_value Array(Int64)\n+) ENGINE=TinyLog;\n+\n+INSERT INTO dictionary_array_source_table VALUES (0, [0, 1, 2]);\n+\n+DROP DICTIONARY IF EXISTS flat_dictionary;\n+CREATE DICTIONARY flat_dictionary\n+(\n+    id UInt64,\n+    array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_array_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(FLAT());\n+\n+SELECT 'Flat dictionary';\n+SELECT dictGet('flat_dictionary', 'array_value', toUInt64(0));\n+SELECT dictGet('flat_dictionary', 'array_value', toUInt64(1));\n+SELECT dictGetOrDefault('flat_dictionary', 'array_value', toUInt64(1), [2,3,4]);\n+DROP DICTIONARY flat_dictionary;\n+\n+DROP DICTIONARY IF EXISTS hashed_dictionary;\n+CREATE DICTIONARY hashed_dictionary\n+(\n+    id UInt64,\n+    array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_array_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Hashed dictionary';\n+SELECT dictGet('hashed_dictionary', 'array_value', toUInt64(0));\n+SELECT dictGet('hashed_dictionary', 'array_value', toUInt64(1));\n+SELECT dictGetOrDefault('hashed_dictionary', 'array_value', toUInt64(1), [2,3,4]);\n+DROP DICTIONARY hashed_dictionary;\n+\n+DROP DICTIONARY IF EXISTS cache_dictionary;\n+CREATE DICTIONARY cache_dictionary\n+(\n+    id UInt64,\n+    array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_array_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(CACHE(SIZE_IN_CELLS 10));\n+\n+SELECT 'Cache dictionary';\n+SELECT dictGet('cache_dictionary', 'array_value', toUInt64(0));\n+SELECT dictGet('cache_dictionary', 'array_value', toUInt64(1));\n+SELECT dictGetOrDefault('cache_dictionary', 'array_value', toUInt64(1), [2,3,4]);\n+DROP DICTIONARY cache_dictionary;\n+\n+DROP DICTIONARY IF EXISTS direct_dictionary;\n+CREATE DICTIONARY direct_dictionary\n+(\n+    id UInt64,\n+    array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_array_source_table'))\n+LAYOUT(DIRECT());\n+\n+SELECT 'Direct dictionary';\n+SELECT dictGet('direct_dictionary', 'array_value', toUInt64(0));\n+SELECT dictGet('direct_dictionary', 'array_value', toUInt64(1));\n+SELECT dictGetOrDefault('direct_dictionary', 'array_value', toUInt64(1), [2,3,4]);\n+DROP DICTIONARY direct_dictionary;\n+\n+DROP TABLE IF EXISTS ip_trie_dictionary_array_source_table;\n+CREATE TABLE ip_trie_dictionary_array_source_table\n+(\n+    prefix String,\n+    array_value Array(Int64)\n+) ENGINE = TinyLog;\n+\n+DROP TABLE dictionary_array_source_table;\n+\n+DROP DICTIONARY IF EXISTS ip_trie_dictionary;\n+CREATE DICTIONARY ip_trie_dictionary\n+(\n+    prefix String,\n+    array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY prefix\n+SOURCE(CLICKHOUSE(HOST 'localhost' port tcpPort() TABLE 'ip_trie_dictionary_array_source_table'))\n+LIFETIME(MIN 10 MAX 1000)\n+LAYOUT(IP_TRIE());\n+\n+INSERT INTO ip_trie_dictionary_array_source_table VALUES ('127.0.0.0', [0, 1, 2]);\n+\n+SELECT 'IPTrie dictionary';\n+SELECT dictGet('ip_trie_dictionary', 'array_value', tuple(IPv4StringToNum('127.0.0.0')));\n+SELECT dictGet('ip_trie_dictionary', 'array_value', tuple(IPv4StringToNum('128.0.0.0')));\n+SELECT dictGetOrDefault('ip_trie_dictionary', 'array_value', tuple(IPv4StringToNum('128.0.0.0')), [2,3,4]);\n+\n+DROP DICTIONARY ip_trie_dictionary;\n+DROP TABLE ip_trie_dictionary_array_source_table;\n+\n+DROP TABLE IF EXISTS polygon_dictionary_array_source_table;\n+CREATE TABLE polygon_dictionary_array_source_table\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    array_value Array(Int64)\n+) ENGINE = TinyLog;\n+\n+INSERT INTO polygon_dictionary_array_source_table VALUES ([[[(0, 0), (0, 1), (1, 1), (1, 0)]]], [0, 1, 2]);\n+\n+DROP DICTIONARY IF EXISTS polygon_dictionary;\n+CREATE DICTIONARY polygon_dictionary\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'polygon_dictionary_array_source_table'))\n+LIFETIME(MIN 0 MAX 1000)\n+LAYOUT(POLYGON());\n+\n+SELECT 'Polygon dictionary';\n+SELECT dictGet('polygon_dictionary', 'array_value', tuple(0.5, 0.5));\n+SELECT dictGet('polygon_dictionary', 'array_value', tuple(1.5, 1.5));\n+SELECT dictGetOrDefault('polygon_dictionary', 'array_value', tuple(1.5, 1.5), [2, 3, 4]);\n+\n+DROP DICTIONARY polygon_dictionary;\n+DROP TABLE polygon_dictionary_array_source_table;\n+\n+CREATE TABLE range_dictionary_array_source_table\n+(\n+  key UInt64,\n+  start_date Date,\n+  end_date Date,\n+  array_value Array(Int64)\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO range_dictionary_array_source_table VALUES(1, toDate('2019-05-05'), toDate('2019-05-20'), [0, 1, 2]);\n+CREATE DICTIONARY range_dictionary\n+(\n+  key UInt64,\n+  start_date Date,\n+  end_date Date,\n+  array_value Array(Int64) DEFAULT [1,2,3]\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'range_dictionary_array_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(RANGE_HASHED())\n+RANGE(MIN start_date MAX end_date);\n+\n+SELECT 'Range dictionary';\n+SELECT dictGet('range_dictionary', 'array_value',  toUInt64(1), toDate('2019-05-15'));\n+SELECT dictGet('range_dictionary', 'array_value', toUInt64(1), toDate('2019-05-21'));\n+SELECT dictGetOrDefault('range_dictionary', 'array_value', toUInt64(1), toDate('2019-05-21'), [2, 3, 4]);\n+\n+DROP DICTIONARY range_dictionary;\n+DROP TABLE range_dictionary_array_source_table;\ndiff --git a/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.reference b/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.reference\nnew file mode 100644\nindex 000000000000..90850428694e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.reference\n@@ -0,0 +1,4 @@\n+SSDCache dictionary\n+[0,1,2]\n+[1,2,3]\n+[2,3,4]\ndiff --git a/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.sh b/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.sh\nnew file mode 100755\nindex 000000000000..70aa46233207\n--- /dev/null\n+++ b/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.sh\n@@ -0,0 +1,35 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+USER_FILES_PATH=$(clickhouse-client --query \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+\n+$CLICKHOUSE_CLIENT -n --query=\"\n+    DROP TABLE IF EXISTS dictionary_array_source_table;\n+    CREATE TABLE dictionary_array_source_table\n+    (\n+        id UInt64,\n+        array_value Array(Int64)\n+    ) ENGINE=TinyLog;\n+\n+    INSERT INTO dictionary_array_source_table VALUES (0, [0, 1, 2]);\n+\n+    DROP DICTIONARY IF EXISTS ssd_cache_dictionary;\n+    CREATE DICTIONARY ssd_cache_dictionary\n+    (\n+        id UInt64,\n+        array_value Array(Int64) DEFAULT [1,2,3]\n+    )\n+    PRIMARY KEY id\n+    SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_array_source_table'))\n+    LIFETIME(MIN 1 MAX 1000)\n+    LAYOUT(SSD_CACHE(BLOCK_SIZE 4096 FILE_SIZE 8192 PATH '$USER_FILES_PATH/0d'));\n+\n+    SELECT 'SSDCache dictionary';\n+    SELECT dictGet('ssd_cache_dictionary', 'array_value', toUInt64(0));\n+    SELECT dictGet('ssd_cache_dictionary', 'array_value', toUInt64(1));\n+    SELECT dictGetOrDefault('ssd_cache_dictionary', 'array_value', toUInt64(1), [2,3,4]);\n+    DROP DICTIONARY ssd_cache_dictionary;\n+    DROP TABLE dictionary_array_source_table;\"\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex b4b0d7581e39..6677613d7cfd 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -412,7 +412,8 @@\n         \"01684_ssd_cache_dictionary_simple_key\",\n         \"01685_ssd_cache_dictionary_complex_key\",\n         \"01889_postgresql_protocol_null_fields\",\n-        \"01889_check_row_policy_defined_using_user_function\"\n+        \"01889_check_row_policy_defined_using_user_function\",\n+        \"01903_ssd_cache_dictionary_array_type\"\n     ],\n     \"parallel\":\n     [\n",
  "problem_statement": "Support Arrays in External Dictionaries\nI had a conversation with @alexey-milovidov in Telegram today about supporting arrays in external dictionary attributes. A good use case might be something like Stack Overflow where users can update the tags. The question is immutable, but the tags need to be updated. In MySQL (or whatever external dictionary source), I would store the question id and an array of the string tags.\r\n\r\nFor now, my workaround is going to be something like this. It seems like this will have some significant performance implications, but I haven't tested them yet.\r\n> Also you can have all tags in a comma separated string field. You can extract this field from the dictionary and split it to array with splitByChar.\r\n\r\ncc @alex-zaitsev \r\n\nSegmentation fault while reading array from dictionary\n**Describe the bug**\r\n\r\nClickHouse crashes when trying to read an array from a dictionary.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nReproduce on v21.6.3.14-stable\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nCREATE TABLE IF NOT EXISTS persons_table (\r\nid UUID,\r\naccounts Array(String)\r\n) ENGINE = MergeTree() ORDER BY id;\r\n\r\nINSERT INTO persons_table VALUES ('a6c5a46d-bf1e-4813-ada8-06f3406e6103', ['vfedorov@acme','vfedorov','vfedorov@acme.com']);\r\n\r\nCREATE DICTIONARY IF NOT EXISTS persons_dictionary_ch (\r\nid UUID,\r\naccounts Array(String)\r\n)\r\nPRIMARY KEY id\r\nSOURCE (CLICKHOUSE( host 'localhost' port 9000 user 'default' password '' db 'default' table 'persons_table' )) LAYOUT(COMPLEX_KEY_HASHED()) LIFETIME(300);\r\n\r\nSELECT id, toString(accounts) FROM persons_dictionary_ch;\r\n```\r\n\r\nThis is a synthetic example. In production, we load the dictionary from HTTP interface.\r\n\r\n**Expected behavior**\r\n\r\n```sql\r\nSELECT id, toString(accounts) FROM persons_dictionary_ch;\r\n\r\n\u250c\u2500id\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toString(accounts)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 a6c5a46d-bf1e-4813-ada8-06f3406e6103 \u2502 ['vfedorov@acme','vfedorov','vfedorov@acme.com'] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```sql\r\nSELECT id, toString(accounts) FROM persons_dictionary_ch;\r\n\r\n[51b45ab248c5] 2021.06.08 17:28:50.985142 [ 162 ] <Fatal> BaseDaemon: ########################################\r\n[51b45ab248c5] 2021.06.08 17:28:50.985210 [ 162 ] <Fatal> BaseDaemon: (version 21.6.3.14 (official build), build id: F48747FBABB1019F05627059924B154D356B9401) (from thread 161) (query_id: df9e46f0-7f00-42a8-8066-7639cddd512f) Received signal Segmentation fault (11)\r\n[51b45ab248c5] 2021.06.08 17:28:50.985252 [ 162 ] <Fatal> BaseDaemon: Address: 0xfffffffffffffff8 Access: read. Address not mapped to object.\r\n[51b45ab248c5] 2021.06.08 17:28:50.985284 [ 162 ] <Fatal> BaseDaemon: Stack trace: 0xf3ab701 0xa9b6667 0xa9b56e9 0xa9b4d5c 0xa76d20e 0xefc84de 0xefc89d2 0xf5dc1b5 0x105991fc 0x10599590 0x1059c467 0x1046195d 0x1045e4f1 0x1045c52d 0x1045c30d 0x1046957f 0x8b9b49f 0x8b9e9c3 0x7f0ae6ca4609 0x7f0ae6bcb293\r\n[51b45ab248c5] 2021.06.08 17:28:50.985355 [ 162 ] <Fatal> BaseDaemon: 1. DB::SerializationArray::serializeText(DB::IColumn const&, unsigned long, DB::WriteBuffer&, DB::FormatSettings const&) const @ 0xf3ab701 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985441 [ 162 ] <Fatal> BaseDaemon: 2. DB::ConvertImplGenericToString::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&) @ 0xa9b6667 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985479 [ 162 ] <Fatal> BaseDaemon: 3. DB::FunctionConvert<DB::DataTypeString, DB::NameToString, DB::ToStringMonotonicity>::executeInternal(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xa9b56e9 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985518 [ 162 ] <Fatal> BaseDaemon: 4. DB::FunctionConvert<DB::DataTypeString, DB::NameToString, DB::ToStringMonotonicity>::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xa9b4d5c in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985568 [ 162 ] <Fatal> BaseDaemon: 5. DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xa76d20e in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985611 [ 162 ] <Fatal> BaseDaemon: 6. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xefc84de in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985670 [ 162 ] <Fatal> BaseDaemon: 7. DB::IExecutableFunction::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xefc89d2 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985733 [ 162 ] <Fatal> BaseDaemon: 8. DB::ExpressionActions::execute(DB::Block&, unsigned long&, bool) const @ 0xf5dc1b5 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985783 [ 162 ] <Fatal> BaseDaemon: 9. DB::ExpressionTransform::transform(DB::Chunk&) @ 0x105991fc in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985833 [ 162 ] <Fatal> BaseDaemon: 10. DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x10599590 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985880 [ 162 ] <Fatal> BaseDaemon: 11. DB::ISimpleTransform::work() @ 0x1059c467 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985943 [ 162 ] <Fatal> BaseDaemon: 12. ? @ 0x1046195d in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.985982 [ 162 ] <Fatal> BaseDaemon: 13. DB::PipelineExecutor::executeStepImpl(unsigned long, unsigned long, std::__1::atomic<bool>*) @ 0x1045e4f1 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.986030 [ 162 ] <Fatal> BaseDaemon: 14. DB::PipelineExecutor::executeImpl(unsigned long) @ 0x1045c52d in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.986140 [ 162 ] <Fatal> BaseDaemon: 15. DB::PipelineExecutor::execute(unsigned long) @ 0x1045c30d in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.986203 [ 162 ] <Fatal> BaseDaemon: 16. ? @ 0x1046957f in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.986256 [ 162 ] <Fatal> BaseDaemon: 17. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x8b9b49f in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.986288 [ 162 ] <Fatal> BaseDaemon: 18. ? @ 0x8b9e9c3 in /usr/bin/clickhouse\r\n[51b45ab248c5] 2021.06.08 17:28:50.986342 [ 162 ] <Fatal> BaseDaemon: 19. start_thread @ 0x9609 in /usr/lib/x86_64-linux-gnu/libpthread-2.31.so\r\n[51b45ab248c5] 2021.06.08 17:28:50.986411 [ 162 ] <Fatal> BaseDaemon: 20. clone @ 0x122293 in /usr/lib/x86_64-linux-gnu/libc-2.31.so\r\n[51b45ab248c5] 2021.06.08 17:28:51.090568 [ 162 ] <Fatal> BaseDaemon: Checksum of the binary: B8C77CBC7ACCB6DD2F4B342509B65FEA, integrity check passed.\r\n\r\nException on client:\r\nCode: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000\r\n\r\nConnecting to localhost:9000 as user default.\r\nCode: 210. DB::NetException: Connection refused (localhost:9000)\r\n```\n\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\u0445\n\u041f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e.\r\n\r\n\u041c\u0430\u0441\u0441\u0438\u0432\u044b \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\u0445 \u043d\u0430 \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u043c\u043e\u043c\u0435\u043d\u0442, \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u044f \u043c\u043e\u0433 \u043f\u043e\u043d\u044f\u0442\u044c, \u043d\u0435 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044e\u0442\u0441\u044f. \u0412 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c PostgreSQL, \u043c\u0430\u0441\u0441\u0438\u0432\u044b \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0438\u043c\u0435\u044e\u0442 \u0432\u0438\u0434 \"{el1, el2, ...}\".\r\n\u0420\u0430\u0431\u043e\u0442\u0430\u0435\u043c \u0441 \u043d\u0438\u043c\u0438 \u0441\u0435\u0439\u0447\u0430\u0441 \u043a\u0430\u043a \u0441\u043e \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044f \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u0442\u0430\u043a\u0438\u0435 \u043a\u043e\u0441\u0442\u044b\u043b\u0438:\r\n\r\n```sql\r\n# \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0441 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u043c\r\nSELECT count() FROM stats WHERE event_date > '2017-10-01' AND offer_id IN (SELECT cast(id as UInt32) FROM dicts.offers_dict WHERE has(splitByChar(',', substring(countries, 2, length(countries)- 2)), '80'));\r\n# \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0441 like\r\nSELECT count() FROM stats WHERE event_date > '2017-10-01' AND offer_id IN (SELECT cast(id as UInt32) FROM dicts.offers_dict WHERE concat(',', substring(countries, 2, length(countries) - 2), ',') like '%,80,%');\r\n\r\n```\r\n\r\n\u041f\u043e\u0434\u0437\u0430\u043f\u0440\u043e\u0441 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 id \u0442\u0435\u0445 offers, \u0443 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u043e\u043b\u0435 countries \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \"80\". \r\n\u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0441 like \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u0431\u044b\u0441\u0442\u0440\u0435\u0435 \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u0432 \u0434\u0432\u0430 \u0440\u0430\u0437\u0430.\r\n\r\n\u0415\u0441\u0442\u044c \u043b\u0438 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0443\u0441\u043a\u043e\u0440\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441? \u0418\u043b\u0438 \u043a\u0430\u043a\u0438\u043c-\u0442\u043e \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u043d\u0430\u0442\u0438\u0432\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432\u044b \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u043e\u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u0435\u0439?\n",
  "hints_text": "Storing tags in comma separated strings is not that slow comparing to array. You can splitByChar or use match() function if you search by tags. Since you can filter dictionary first it is not slow at all.\nI don't have anything to compare it to, but it does seem to be working quickly enough for a materialized view definition. Thanks @alex-zaitsev!\nYou can have a dictionary-like structure with any kind of value after this pr https://github.com/yandex/ClickHouse/pull/3728\r\n\r\n```\r\n201.nobida.cn :) insert into js values (2, ['c++', 'ruby']);\r\n\r\nINSERT INTO js VALUES\r\n\r\nOk.\r\n\r\n1 rows in set. Elapsed: 0.001 sec.\r\n\r\n201.nobida.cn :) select joinGet('js', 'ss', toInt32(1));\r\n\r\nSELECT joinGet('js', 'ss', toInt32(1))\r\n\r\n\u250c\u2500joinGet('js', 'ss', toInt32(1))\u2500\u2510\r\n\u2502 ['c++','java','python']         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.001 sec.\r\n\r\n201.nobida.cn :) select joinGet('js', 'ss', toInt32(2));\r\n\r\nSELECT joinGet('js', 'ss', toInt32(2))\r\n\r\n\u250c\u2500joinGet('js', 'ss', toInt32(2))\u2500\u2510\r\n\u2502 ['c++','ruby']                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.001 sec.\r\n\r\n```\nrelated #1640 \nrelated #7088\nThe implementation is being developed by @kitaisreal in #18236.\nDictionaries do not support Arrays, it's not implemented https://github.com/ClickHouse/ClickHouse/issues/2135\nOk... Maybe then at least the ClickHouse will report an error and not crash\n\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432 \u0432 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\u0445 \u043c\u044b \u0445\u043e\u0442\u0435\u043b\u0438 \u0431\u044b \u0441\u0434\u0435\u043b\u0430\u0442\u044c,\r\n\u043d\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433 \u043c\u0430\u0441\u0441\u0438\u0432\u043e\u0432 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 PostgreSQL, \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e, \u043f\u0440\u0438\u0434\u0451\u0442\u0441\u044f \u0432\u044b\u043d\u0435\u0441\u0442\u0438 \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u0443\u044e \u0437\u0430\u0434\u0430\u0447\u0443,\r\n\u043b\u0438\u0431\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u0441\u0442\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0438\u043d\u0433\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439, \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043d\u043d\u044b\u0445 \u0438\u0437 \u0443\u0434\u0430\u043b\u0451\u043d\u043d\u043e\u0433\u043e \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430, \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0432\u044b\u0440\u0430\u0436\u0435\u043d\u0438\u0439 \u0432 ClickHouse - \u0442\u043e\u0433\u0434\u0430 \u043c\u043e\u0436\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u044d\u0442\u0438 \u043c\u0430\u0441\u0441\u0438\u0432\u044b \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435, \u0438 \u0437\u0430\u0442\u0435\u043c \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e \u0441 \u043d\u0438\u043c\u0438 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c.\nCC @kitaisreal ",
  "created_at": "2021-06-09T10:44:54Z",
  "modified_files": [
    "src/Dictionaries/CacheDictionaryStorage.h",
    "src/Dictionaries/DictionaryHelpers.h",
    "src/Dictionaries/DictionarySourceFactory.cpp",
    "src/Dictionaries/DictionaryStructure.cpp",
    "src/Dictionaries/DictionaryStructure.h",
    "src/Dictionaries/ExternalQueryBuilder.cpp",
    "src/Dictionaries/FlatDictionary.cpp",
    "src/Dictionaries/FlatDictionary.h",
    "src/Dictionaries/HashedDictionary.cpp",
    "src/Dictionaries/HashedDictionary.h",
    "src/Dictionaries/IPAddressDictionary.cpp",
    "src/Dictionaries/IPAddressDictionary.h",
    "src/Dictionaries/PolygonDictionary.cpp",
    "src/Dictionaries/PolygonDictionary.h",
    "src/Dictionaries/RangeHashedDictionary.cpp",
    "src/Dictionaries/RangeHashedDictionary.h",
    "src/Parsers/ParserDictionaryAttributeDeclaration.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01902_dictionary_array_type.reference",
    "b/tests/queries/0_stateless/01902_dictionary_array_type.sql",
    "b/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.reference",
    "b/tests/queries/0_stateless/01903_ssd_cache_dictionary_array_type.sh",
    "tests/queries/skip_list.json"
  ]
}