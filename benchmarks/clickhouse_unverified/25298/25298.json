{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25298,
  "instance_id": "ClickHouse__ClickHouse-25298",
  "issue_numbers": [
    "25293"
  ],
  "base_commit": "d68338a7921f8e9bec667df6e35e679ac89c3774",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionSumMap.h b/src/AggregateFunctions/AggregateFunctionSumMap.h\nindex ec2f24d12cbd..a4b6f3c967b2 100644\n--- a/src/AggregateFunctions/AggregateFunctionSumMap.h\n+++ b/src/AggregateFunctions/AggregateFunctionSumMap.h\n@@ -441,18 +441,11 @@ class FieldVisitorMax : public StaticVisitor<bool>\n {\n private:\n     const Field & rhs;\n-public:\n-    explicit FieldVisitorMax(const Field & rhs_) : rhs(rhs_) {}\n-\n-    bool operator() (Null &) const { throw Exception(\"Cannot compare Nulls\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (Array &) const { throw Exception(\"Cannot compare Arrays\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (Tuple &) const { throw Exception(\"Cannot compare Tuples\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (AggregateFunctionStateData &) const { throw Exception(\"Cannot compare AggregateFunctionStates\", ErrorCodes::LOGICAL_ERROR); }\n \n-    template <typename T>\n-    bool operator() (DecimalField<T> & x) const\n+    template <typename FieldType>\n+    bool compareImpl(FieldType & x) const\n     {\n-        auto val = get<DecimalField<T>>(rhs);\n+        auto val = get<FieldType>(rhs);\n         if (val > x)\n         {\n             x = val;\n@@ -462,18 +455,18 @@ class FieldVisitorMax : public StaticVisitor<bool>\n         return false;\n     }\n \n-    template <typename T>\n-    bool operator() (T & x) const\n-    {\n-        auto val = get<T>(rhs);\n-        if (val > x)\n-        {\n-            x = val;\n-            return true;\n-        }\n+public:\n+    explicit FieldVisitorMax(const Field & rhs_) : rhs(rhs_) {}\n \n-        return false;\n-    }\n+    bool operator() (Null &) const { throw Exception(\"Cannot compare Nulls\", ErrorCodes::LOGICAL_ERROR); }\n+    bool operator() (AggregateFunctionStateData &) const { throw Exception(\"Cannot compare AggregateFunctionStates\", ErrorCodes::LOGICAL_ERROR); }\n+\n+    bool operator() (Array & x) const { return compareImpl<Array>(x); }\n+    bool operator() (Tuple & x) const { return compareImpl<Tuple>(x); }\n+    template <typename T>\n+    bool operator() (DecimalField<T> & x) const { return compareImpl<DecimalField<T>>(x); }\n+    template <typename T>\n+    bool operator() (T & x) const { return compareImpl<T>(x); }\n };\n \n /** Implements `Min` operation.\n@@ -483,18 +476,11 @@ class FieldVisitorMin : public StaticVisitor<bool>\n {\n private:\n     const Field & rhs;\n-public:\n-    explicit FieldVisitorMin(const Field & rhs_) : rhs(rhs_) {}\n-\n-    bool operator() (Null &) const { throw Exception(\"Cannot compare Nulls\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (Array &) const { throw Exception(\"Cannot sum Arrays\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (Tuple &) const { throw Exception(\"Cannot sum Tuples\", ErrorCodes::LOGICAL_ERROR); }\n-    bool operator() (AggregateFunctionStateData &) const { throw Exception(\"Cannot sum AggregateFunctionStates\", ErrorCodes::LOGICAL_ERROR); }\n \n-    template <typename T>\n-    bool operator() (DecimalField<T> & x) const\n+    template <typename FieldType>\n+    bool compareImpl(FieldType & x) const\n     {\n-        auto val = get<DecimalField<T>>(rhs);\n+        auto val = get<FieldType>(rhs);\n         if (val < x)\n         {\n             x = val;\n@@ -504,18 +490,18 @@ class FieldVisitorMin : public StaticVisitor<bool>\n         return false;\n     }\n \n-    template <typename T>\n-    bool operator() (T & x) const\n-    {\n-        auto val = get<T>(rhs);\n-        if (val < x)\n-        {\n-            x = val;\n-            return true;\n-        }\n+public:\n+    explicit FieldVisitorMin(const Field & rhs_) : rhs(rhs_) {}\n \n-        return false;\n-    }\n+    bool operator() (Null &) const { throw Exception(\"Cannot compare Nulls\", ErrorCodes::LOGICAL_ERROR); }\n+    bool operator() (AggregateFunctionStateData &) const { throw Exception(\"Cannot sum AggregateFunctionStates\", ErrorCodes::LOGICAL_ERROR); }\n+\n+    bool operator() (Array & x) const { return compareImpl<Array>(x); }\n+    bool operator() (Tuple & x) const { return compareImpl<Tuple>(x); }\n+    template <typename T>\n+    bool operator() (DecimalField<T> & x) const { return compareImpl<DecimalField<T>>(x); }\n+    template <typename T>\n+    bool operator() (T & x) const { return compareImpl<T>(x); }\n };\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01280_min_map_max_map.reference b/tests/queries/0_stateless/01280_min_map_max_map.reference\nindex abb500553fd4..37a8bfcc6435 100644\n--- a/tests/queries/0_stateless/01280_min_map_max_map.reference\n+++ b/tests/queries/0_stateless/01280_min_map_max_map.reference\n@@ -27,3 +27,7 @@\n (['A','B'],['',''])\n (['A','B'],['',''])\n ([],[])\n+([1],[[1]])\n+([1],[[1,2,3]])\n+([1],[(1,1)])\n+([1],[(1,3)])\ndiff --git a/tests/queries/0_stateless/01280_min_map_max_map.sql b/tests/queries/0_stateless/01280_min_map_max_map.sql\nindex cc07998bb79e..96fdfc619296 100644\n--- a/tests/queries/0_stateless/01280_min_map_max_map.sql\n+++ b/tests/queries/0_stateless/01280_min_map_max_map.sql\n@@ -38,3 +38,9 @@ select maxMap(val, cnt) from values ('val Array(UInt64), cnt Array(UInt64)',  ([\n select minMap(val, cnt) from values ('val Array(String), cnt Array(String)',  (['A'], ['']), (['B'], ['']));\n select maxMap(val, cnt) from values ('val Array(String), cnt Array(String)',  (['A'], ['']), (['B'], ['']));\n select sumMap(val, cnt) from values ('val Array(UInt64), cnt Array(UInt64)',  ([1], [0]), ([2], [0]));\n+\n+-- check working with arrays and tuples as values\n+select minMap([1, 1, 1], [[1, 2], [1], [1, 2, 3]]);\n+select maxMap([1, 1, 1], [[1, 2], [1], [1, 2, 3]]);\n+select minMap([1, 1, 1], [(1, 2), (1, 1), (1, 3)]);\n+select maxMap([1, 1, 1], [(1, 2), (1, 1), (1, 3)]);\n",
  "problem_statement": "AST fuzzer (debug) \u2014 Logical error: 'Cannot sum Tuples'.\nhttps://clickhouse-test-reports.s3.yandex.net/24341/038e4c3ed1881b4dbf4e21cb8992b43cb12f5756/fuzzer_debug/report.html#fail1\r\n\r\nQuery to reproduce:\r\n```sql\r\nSELECT minMap([1, 1], [[1], [1]])\r\n```\n",
  "hints_text": "Will fix it by myself",
  "created_at": "2021-06-15T16:25:39Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionSumMap.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01280_min_map_max_map.reference",
    "tests/queries/0_stateless/01280_min_map_max_map.sql"
  ]
}