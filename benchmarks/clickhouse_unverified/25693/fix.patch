diff --git a/docs/en/operations/system-tables/data_skipping_indices.md b/docs/en/operations/system-tables/data_skipping_indices.md
new file mode 100644
index 000000000000..515f704797af
--- /dev/null
+++ b/docs/en/operations/system-tables/data_skipping_indices.md
@@ -0,0 +1,39 @@
+# system.data_skipping_indices {#system-data-skipping-indices}
+
+Contains information about existing data skipping indices in all the tables.
+
+Columns:
+
+-   `database` ([String](../../sql-reference/data-types/string.md)) — Database name.
+-   `table` ([String](../../sql-reference/data-types/string.md)) — Table name.
+-   `name` ([String](../../sql-reference/data-types/string.md)) — Index name.
+-   `type` ([String](../../sql-reference/data-types/string.md)) — Index type.
+-   `expr` ([String](../../sql-reference/data-types/string.md)) — Expression used to calculate the index.
+-   `granularity` ([UInt64](../../sql-reference/data-types/int-uint.md)) — Number of granules in the block.
+
+**Example**
+
+
+```sql
+SELECT * FROM system.data_skipping_indices LIMIT 2 FORMAT Vertical;
+```
+
+```text
+Row 1:
+──────
+database:    default
+table:       user_actions
+name:        clicks_idx
+type:        minmax
+expr:        clicks
+granularity: 1
+
+Row 2:
+──────
+database:    default
+table:       users
+name:        contacts_null_idx
+type:        minmax
+expr:        assumeNotNull(contacts_null)
+granularity: 1
+```
diff --git a/src/Storages/System/StorageSystemDataSkippingIndices.cpp b/src/Storages/System/StorageSystemDataSkippingIndices.cpp
new file mode 100644
index 000000000000..7a6ce4ec5198
--- /dev/null
+++ b/src/Storages/System/StorageSystemDataSkippingIndices.cpp
@@ -0,0 +1,197 @@
+#include <Storages/System/StorageSystemDataSkippingIndices.h>
+#include <Access/ContextAccess.h>
+#include <Columns/ColumnString.h>
+#include <DataTypes/DataTypeString.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <Databases/IDatabase.h>
+#include <Storages/VirtualColumnUtils.h>
+#include <Interpreters/Context.h>
+#include <Interpreters/DatabaseCatalog.h>
+#include <Parsers/queryToString.h>
+#include <Processors/Sources/SourceWithProgress.h>
+
+
+namespace DB
+{
+StorageSystemDataSkippingIndices::StorageSystemDataSkippingIndices(const StorageID & table_id_)
+    : IStorage(table_id_)
+{
+    StorageInMemoryMetadata storage_metadata;
+    storage_metadata.setColumns(ColumnsDescription(
+        {
+            { "database", std::make_shared<DataTypeString>() },
+            { "table", std::make_shared<DataTypeString>() },
+            { "name", std::make_shared<DataTypeString>() },
+            { "type", std::make_shared<DataTypeString>() },
+            { "expr", std::make_shared<DataTypeString>() },
+            { "granularity", std::make_shared<DataTypeUInt64>() },
+        }));
+    setInMemoryMetadata(storage_metadata);
+}
+
+class DataSkippingIndicesSource : public SourceWithProgress
+{
+public:
+    DataSkippingIndicesSource(
+        std::vector<UInt8> columns_mask_,
+        Block header,
+        UInt64 max_block_size_,
+        ColumnPtr databases_,
+        ContextPtr context_)
+        : SourceWithProgress(header)
+        , column_mask(std::move(columns_mask_))
+        , max_block_size(max_block_size_)
+        , databases(std::move(databases_))
+        , context(Context::createCopy(context_))
+        , database_idx(0)
+    {}
+
+    String getName() const override { return "DataSkippingIndices"; }
+
+protected:
+    Chunk generate() override
+    {
+        if (database_idx >= databases->size())
+            return {};
+
+        MutableColumns res_columns = getPort().getHeader().cloneEmptyColumns();
+
+        const auto access = context->getAccess();
+        const bool check_access_for_databases = !access->isGranted(AccessType::SHOW_TABLES);
+
+        size_t rows_count = 0;
+        while (rows_count < max_block_size)
+        {
+            if (tables_it && !tables_it->isValid())
+                ++database_idx;
+
+            while (database_idx < databases->size() && (!tables_it || !tables_it->isValid()))
+            {
+                database_name = databases->getDataAt(database_idx).toString();
+                database = DatabaseCatalog::instance().tryGetDatabase(database_name);
+
+                if (database)
+                    break;
+                ++database_idx;
+            }
+
+            if (database_idx >= databases->size())
+                break;
+
+            if (!tables_it || !tables_it->isValid())
+                tables_it = database->getTablesIterator(context);
+
+            const bool check_access_for_tables = check_access_for_databases && !access->isGranted(AccessType::SHOW_TABLES, database_name);
+
+            for (; rows_count < max_block_size && tables_it->isValid(); tables_it->next())
+            {
+                auto table_name = tables_it->name();
+                if (check_access_for_tables && !access->isGranted(AccessType::SHOW_TABLES, database_name, table_name))
+                    continue;
+
+                const auto table = tables_it->table();
+                if (!table)
+                    continue;
+                StorageMetadataPtr metadata_snapshot = table->getInMemoryMetadataPtr();
+                if (!metadata_snapshot)
+                    continue;
+                const auto indices = metadata_snapshot->getSecondaryIndices();
+
+                for (const auto & index : indices)
+                {
+                    ++rows_count;
+
+                    size_t src_index = 0;
+                    size_t res_index = 0;
+
+                    // 'database' column
+                    if (column_mask[src_index++])
+                        res_columns[res_index++]->insert(database_name);
+                    // 'table' column
+                    if (column_mask[src_index++])
+                        res_columns[res_index++]->insert(table_name);
+                    // 'name' column
+                    if (column_mask[src_index++])
+                        res_columns[res_index++]->insert(index.name);
+                    // 'type' column
+                    if (column_mask[src_index++])
+                        res_columns[res_index++]->insert(index.type);
+                    // 'expr' column
+                    if (column_mask[src_index++])
+                    {
+                        if (auto expression = index.expression_list_ast)
+                            res_columns[res_index++]->insert(queryToString(expression));
+                        else
+                            res_columns[res_index++]->insertDefault();
+                    }
+                    // 'granularity' column
+                    if (column_mask[src_index++])
+                        res_columns[res_index++]->insert(index.granularity);
+                }
+            }
+        }
+        return Chunk(std::move(res_columns), rows_count);
+    }
+
+private:
+    std::vector<UInt8> column_mask;
+    UInt64 max_block_size;
+    ColumnPtr databases;
+    ContextPtr context;
+    size_t database_idx;
+    DatabasePtr database;
+    std::string database_name;
+    DatabaseTablesIteratorPtr tables_it;
+};
+
+Pipe StorageSystemDataSkippingIndices::read(
+    const Names & column_names,
+    const StorageMetadataPtr & metadata_snapshot,
+    SelectQueryInfo & query_info,
+    ContextPtr context,
+    QueryProcessingStage::Enum /* processed_stage */,
+    size_t max_block_size,
+    unsigned int /* num_streams */)
+{
+    metadata_snapshot->check(column_names, getVirtuals(), getStorageID());
+
+    NameSet names_set(column_names.begin(), column_names.end());
+
+    Block sample_block = metadata_snapshot->getSampleBlock();
+    Block header;
+
+    std::vector<UInt8> columns_mask(sample_block.columns());
+    for (size_t i = 0, size = columns_mask.size(); i < size; ++i)
+    {
+        if (names_set.count(sample_block.getByPosition(i).name))
+        {
+            columns_mask[i] = 1;
+            header.insert(sample_block.getByPosition(i));
+        }
+    }
+
+    MutableColumnPtr column = ColumnString::create();
+
+    const auto databases = DatabaseCatalog::instance().getDatabases();
+    for (const auto & [database_name, database] : databases)
+    {
+        if (database_name == DatabaseCatalog::TEMPORARY_DATABASE)
+            continue;
+
+        /// Lazy database can contain only very primitive tables,
+        /// it cannot contain tables with data skipping indices.
+        /// Skip it to avoid unnecessary tables loading in the Lazy database.
+        if (database->getEngineName() != "Lazy")
+            column->insert(database_name);
+    }
+
+    /// Condition on "database" in a query acts like an index.
+    Block block { ColumnWithTypeAndName(std::move(column), std::make_shared<DataTypeString>(), "database") };
+    VirtualColumnUtils::filterBlockWithQuery(query_info.query, block, context);
+
+    ColumnPtr & filtered_databases = block.getByPosition(0).column;
+    return Pipe(std::make_shared<DataSkippingIndicesSource>(
+        std::move(columns_mask), std::move(header), max_block_size, std::move(filtered_databases), context));
+}
+
+}
diff --git a/src/Storages/System/StorageSystemDataSkippingIndices.h b/src/Storages/System/StorageSystemDataSkippingIndices.h
new file mode 100644
index 000000000000..8497f16606f1
--- /dev/null
+++ b/src/Storages/System/StorageSystemDataSkippingIndices.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include <common/shared_ptr_helper.h>
+#include <Storages/IStorage.h>
+
+
+namespace DB
+{
+
+/// For system.data_skipping_indices table - describes the data skipping indices in tables, similar to system.columns.
+class StorageSystemDataSkippingIndices : public shared_ptr_helper<StorageSystemDataSkippingIndices>, public IStorage
+{
+    friend struct shared_ptr_helper<StorageSystemDataSkippingIndices>;
+public:
+    std::string getName() const override { return "SystemDataSkippingIndices"; }
+
+    Pipe read(
+        const Names & column_names,
+        const StorageMetadataPtr & /*metadata_snapshot*/,
+        SelectQueryInfo & query_info,
+        ContextPtr context,
+        QueryProcessingStage::Enum processed_stage,
+        size_t max_block_size,
+        unsigned num_streams) override;
+
+protected:
+    StorageSystemDataSkippingIndices(const StorageID & table_id_);
+};
+
+}
diff --git a/src/Storages/System/attachSystemTables.cpp b/src/Storages/System/attachSystemTables.cpp
index 830a6c4fcd38..7da65b09d6d7 100644
--- a/src/Storages/System/attachSystemTables.cpp
+++ b/src/Storages/System/attachSystemTables.cpp
@@ -9,6 +9,7 @@
 #include <Storages/System/StorageSystemClusters.h>
 #include <Storages/System/StorageSystemColumns.h>
 #include <Storages/System/StorageSystemDatabases.h>
+#include <Storages/System/StorageSystemDataSkippingIndices.h>
 #include <Storages/System/StorageSystemDataTypeFamilies.h>
 #include <Storages/System/StorageSystemDetachedParts.h>
 #include <Storages/System/StorageSystemDictionaries.h>
@@ -115,6 +116,7 @@ void attachSystemTablesLocal(IDatabase & system_database)
     attach<StorageSystemUserDirectories>(system_database, "user_directories");
     attach<StorageSystemPrivileges>(system_database, "privileges");
     attach<StorageSystemErrors>(system_database, "errors");
+    attach<StorageSystemDataSkippingIndices>(system_database, "data_skipping_indices");
 #if !defined(ARCADIA_BUILD)
     attach<StorageSystemLicenses>(system_database, "licenses");
     attach<StorageSystemTimeZones>(system_database, "time_zones");
diff --git a/src/Storages/ya.make b/src/Storages/ya.make
index d86925242103..6e412cddba7e 100644
--- a/src/Storages/ya.make
+++ b/src/Storages/ya.make
@@ -158,6 +158,7 @@ SRCS(
     System/StorageSystemContributors.generated.cpp
     System/StorageSystemCurrentRoles.cpp
     System/StorageSystemDDLWorkerQueue.cpp
+    System/StorageSystemDataSkippingIndices.cpp
     System/StorageSystemDataTypeFamilies.cpp
     System/StorageSystemDatabases.cpp
     System/StorageSystemDetachedParts.cpp
