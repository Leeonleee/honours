{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32973,
  "instance_id": "ClickHouse__ClickHouse-32973",
  "issue_numbers": [
    "32969"
  ],
  "base_commit": "967738ff8f9fd852f3a18b24969453b6602bd948",
  "patch": "diff --git a/src/Columns/ColumnFunction.h b/src/Columns/ColumnFunction.h\nindex 8e39551676c7..2592dc01f982 100644\n--- a/src/Columns/ColumnFunction.h\n+++ b/src/Columns/ColumnFunction.h\n@@ -24,7 +24,12 @@ class ColumnFunction final : public COWHelper<IColumn, ColumnFunction>\n private:\n     friend class COWHelper<IColumn, ColumnFunction>;\n \n-    ColumnFunction(size_t size, FunctionBasePtr function_, const ColumnsWithTypeAndName & columns_to_capture, bool is_short_circuit_argument_ = false, bool is_function_compiled_ = false);\n+    ColumnFunction(\n+        size_t size,\n+        FunctionBasePtr function_,\n+        const ColumnsWithTypeAndName & columns_to_capture,\n+        bool is_short_circuit_argument_ = false,\n+        bool is_function_compiled_ = false);\n \n public:\n     const char * getFamilyName() const override { return \"Function\"; }\ndiff --git a/src/Columns/MaskOperations.cpp b/src/Columns/MaskOperations.cpp\nindex 9499185da30d..1641bdf5a4cb 100644\n--- a/src/Columns/MaskOperations.cpp\n+++ b/src/Columns/MaskOperations.cpp\n@@ -293,7 +293,7 @@ void executeColumnIfNeeded(ColumnWithTypeAndName & column, bool empty)\n         column.column = column_function->getResultType()->createColumn();\n }\n \n-int checkShirtCircuitArguments(const ColumnsWithTypeAndName & arguments)\n+int checkShortCircuitArguments(const ColumnsWithTypeAndName & arguments)\n {\n     int last_short_circuit_argument_index = -1;\n     for (size_t i = 0; i != arguments.size(); ++i)\ndiff --git a/src/Columns/MaskOperations.h b/src/Columns/MaskOperations.h\nindex bd6c5e8fe2cf..e43b4588258f 100644\n--- a/src/Columns/MaskOperations.h\n+++ b/src/Columns/MaskOperations.h\n@@ -66,7 +66,7 @@ void executeColumnIfNeeded(ColumnWithTypeAndName & column, bool empty = false);\n \n /// Check if arguments contain lazy executed argument. If contain, return index of the last one,\n /// otherwise return -1.\n-int checkShirtCircuitArguments(const ColumnsWithTypeAndName & arguments);\n+int checkShortCircuitArguments(const ColumnsWithTypeAndName & arguments);\n \n void copyMask(const PaddedPODArray<UInt8> & from, PaddedPODArray<UInt8> & to);\n \ndiff --git a/src/Functions/FunctionsLogical.cpp b/src/Functions/FunctionsLogical.cpp\nindex f427deced3a3..87a2ecd4c57b 100644\n--- a/src/Functions/FunctionsLogical.cpp\n+++ b/src/Functions/FunctionsLogical.cpp\n@@ -609,7 +609,7 @@ ColumnPtr FunctionAnyArityLogical<Impl, Name>::executeImpl(\n     ColumnsWithTypeAndName arguments = std::move(args);\n \n     /// Special implementation for short-circuit arguments.\n-    if (checkShirtCircuitArguments(arguments) != -1)\n+    if (checkShortCircuitArguments(arguments) != -1)\n         return executeShortCircuit(arguments, result_type);\n \n     ColumnRawPtrs args_in;\ndiff --git a/src/Functions/if.cpp b/src/Functions/if.cpp\nindex 953aff3568e6..6841098ebcfa 100644\n--- a/src/Functions/if.cpp\n+++ b/src/Functions/if.cpp\n@@ -969,7 +969,7 @@ class FunctionIf : public FunctionIfBase\n \n     static void executeShortCircuitArguments(ColumnsWithTypeAndName & arguments)\n     {\n-        int last_short_circuit_argument_index = checkShirtCircuitArguments(arguments);\n+        int last_short_circuit_argument_index = checkShortCircuitArguments(arguments);\n         if (last_short_circuit_argument_index == -1)\n             return;\n \ndiff --git a/src/Functions/multiIf.cpp b/src/Functions/multiIf.cpp\nindex 3e5242d5f9b3..070a7c2f05e5 100644\n--- a/src/Functions/multiIf.cpp\n+++ b/src/Functions/multiIf.cpp\n@@ -262,7 +262,7 @@ class FunctionMultiIf final : public FunctionIfBase\n private:\n     static void executeShortCircuitArguments(ColumnsWithTypeAndName & arguments)\n     {\n-        int last_short_circuit_argument_index = checkShirtCircuitArguments(arguments);\n+        int last_short_circuit_argument_index = checkShortCircuitArguments(arguments);\n         if (last_short_circuit_argument_index < 0)\n             return;\n \ndiff --git a/src/Functions/throwIf.cpp b/src/Functions/throwIf.cpp\nindex d499f1f492f0..7533e30c9b9e 100644\n--- a/src/Functions/throwIf.cpp\n+++ b/src/Functions/throwIf.cpp\n@@ -48,36 +48,53 @@ class FunctionThrowIf : public IFunction\n         const size_t number_of_arguments = arguments.size();\n \n         if (number_of_arguments < 1 || number_of_arguments > 2)\n-            throw Exception{\"Number of arguments for function \" + getName() + \" doesn't match: passed \"\n-                            + toString(number_of_arguments) + \", should be 1 or 2\",\n-                            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2\",\n+                getName(),\n+                toString(number_of_arguments));\n \n         if (!isNativeNumber(arguments[0]))\n-            throw Exception{\"Argument for function \" + getName() + \" must be number\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Argument for function {} must be number\",\n+                getName());\n \n         if (number_of_arguments > 1 && !isString(arguments[1]))\n-            throw Exception{\"Illegal type \" + arguments[1]->getName() + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of argument of function {}\",\n+                arguments[1]->getName(),\n+                getName());\n \n \n         return std::make_shared<DataTypeUInt8>();\n     }\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return false; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    /** Prevent constant folding for FunctionThrowIf because for short circuit evaluation\n+      * it is unsafe to evaluate this function during DAG analysis.\n+      */\n+    bool isSuitableForConstantFolding() const override { return false; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n+        if (input_rows_count == 0)\n+            return result_type->createColumn();\n+\n         std::optional<String> custom_message;\n         if (arguments.size() == 2)\n         {\n-            const auto * msg_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());\n-            if (!msg_column)\n-                throw Exception{\"Second argument for function \" + getName() + \" must be constant String\", ErrorCodes::ILLEGAL_COLUMN};\n-            custom_message = msg_column->getValue<String>();\n+            const auto * message_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());\n+            if (!message_column)\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                    \"Second argument for function {} must be constant String\",\n+                    getName());\n+\n+            custom_message = message_column->getValue<String>();\n         }\n \n-        const auto * in = arguments.front().column.get();\n+        auto first_argument_column = arguments.front().column;\n+        const auto * in = first_argument_column.get();\n \n         ColumnPtr res;\n         if (!((res = execute<UInt8>(in, custom_message))\n@@ -90,7 +107,9 @@ class FunctionThrowIf : public IFunction\n             || (res = execute<Int64>(in, custom_message))\n             || (res = execute<Float32>(in, custom_message))\n             || (res = execute<Float64>(in, custom_message))))\n+        {\n             throw Exception{\"Illegal column \" + in->getName() + \" of first argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n+        }\n \n         return res;\n     }\n@@ -98,15 +117,22 @@ class FunctionThrowIf : public IFunction\n     template <typename T>\n     ColumnPtr execute(const IColumn * in_untyped, const std::optional<String> & message) const\n     {\n-        if (const auto in = checkAndGetColumn<ColumnVector<T>>(in_untyped))\n+        const auto * in = checkAndGetColumn<ColumnVector<T>>(in_untyped);\n+\n+        if (!in)\n+            in = checkAndGetColumnConstData<ColumnVector<T>>(in_untyped);\n+\n+        if (in)\n         {\n             const auto & in_data = in->getData();\n             if (!memoryIsZero(in_data.data(), in_data.size() * sizeof(in_data[0])))\n-                throw Exception{message.value_or(\"Value passed to '\" + getName() + \"' function is non zero\"),\n-                                ErrorCodes::FUNCTION_THROW_IF_VALUE_IS_NON_ZERO};\n+            {\n+                throw Exception(ErrorCodes::FUNCTION_THROW_IF_VALUE_IS_NON_ZERO,\n+                    message.value_or(\"Value passed to '\" + getName() + \"' function is non zero\"));\n+            }\n \n             /// We return non constant to avoid constant folding.\n-            return  ColumnUInt8::create(in_data.size(), 0);\n+            return ColumnUInt8::create(in_data.size(), 0);\n         }\n \n         return nullptr;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02152_short_circuit_throw_if.reference b/tests/queries/0_stateless/02152_short_circuit_throw_if.reference\nnew file mode 100644\nindex 000000000000..aa47d0d46d47\n--- /dev/null\n+++ b/tests/queries/0_stateless/02152_short_circuit_throw_if.reference\n@@ -0,0 +1,2 @@\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02152_short_circuit_throw_if.sql b/tests/queries/0_stateless/02152_short_circuit_throw_if.sql\nnew file mode 100644\nindex 000000000000..3fdc3cc48c86\n--- /dev/null\n+++ b/tests/queries/0_stateless/02152_short_circuit_throw_if.sql\n@@ -0,0 +1,2 @@\n+SELECT if(1, 0, throwIf(1, 'Executing FALSE branch'));\n+SELECT if(empty(''), 0, throwIf(1, 'Executing FALSE branch'));\n",
  "problem_statement": "Conditional functions with constant expression as condition should evaluate only one branch\nFor example, if I use UInt8 constant for if condition then only one branch is evaluated:\r\n```sql\r\nSELECT if(1, 'success', throwIf(1, 'Executing FALSE branch'))\r\n\r\n\u250c\u2500'success'\u2500\u2510\r\n\u2502 success   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n```\r\n\r\nBut if I use some constant expression, then both branches are evaluated:\r\n```sql\r\nSELECT if(empty(''), 'success', throwIf(1, 'Executing FALSE branch'))\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n\r\nReceived exception from server (version 21.12.2):\r\nCode: 395. DB::Exception: Received from localhost:9000. DB::Exception: Executing FALSE branch: While processing if(empty(''), 'success', throwIf(1, 'Executing FALSE branch')). (FUNCTION_THROW_IF_VALUE_IS_NON_ZERO)\r\n```\n",
  "hints_text": "",
  "created_at": "2021-12-20T11:49:56Z",
  "modified_files": [
    "src/Columns/ColumnFunction.h",
    "src/Columns/MaskOperations.cpp",
    "src/Columns/MaskOperations.h",
    "src/Functions/FunctionsLogical.cpp",
    "src/Functions/if.cpp",
    "src/Functions/multiIf.cpp",
    "src/Functions/throwIf.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02152_short_circuit_throw_if.reference",
    "b/tests/queries/0_stateless/02152_short_circuit_throw_if.sql"
  ]
}