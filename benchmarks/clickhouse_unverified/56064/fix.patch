diff --git a/programs/library-bridge/LibraryBridgeHandlers.cpp b/programs/library-bridge/LibraryBridgeHandlers.cpp
index 9642dd7ee634..7c77e633a446 100644
--- a/programs/library-bridge/LibraryBridgeHandlers.cpp
+++ b/programs/library-bridge/LibraryBridgeHandlers.cpp
@@ -2,6 +2,7 @@
 
 #include "CatBoostLibraryHandler.h"
 #include "CatBoostLibraryHandlerFactory.h"
+#include "Common/ProfileEvents.h"
 #include "ExternalDictionaryLibraryHandler.h"
 #include "ExternalDictionaryLibraryHandlerFactory.h"
 
@@ -44,7 +45,7 @@ namespace
         response.setStatusAndReason(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);
 
         if (!response.sent())
-            *response.send() << message << std::endl;
+            *response.send() << message << '
';
 
         LOG_WARNING(&Poco::Logger::get("LibraryBridge"), fmt::runtime(message));
     }
@@ -96,7 +97,7 @@ ExternalDictionaryLibraryBridgeRequestHandler::ExternalDictionaryLibraryBridgeRe
 }
 
 
-void ExternalDictionaryLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void ExternalDictionaryLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     LOG_TRACE(log, "Request URI: {}", request.getURI());
     HTMLForm params(getContext()->getSettingsRef(), request);
@@ -384,7 +385,7 @@ ExternalDictionaryLibraryBridgeExistsHandler::ExternalDictionaryLibraryBridgeExi
 }
 
 
-void ExternalDictionaryLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void ExternalDictionaryLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     try
     {
@@ -423,7 +424,7 @@ CatBoostLibraryBridgeRequestHandler::CatBoostLibraryBridgeRequestHandler(
 }
 
 
-void CatBoostLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void CatBoostLibraryBridgeRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     LOG_TRACE(log, "Request URI: {}", request.getURI());
     HTMLForm params(getContext()->getSettingsRef(), request);
@@ -621,7 +622,7 @@ CatBoostLibraryBridgeExistsHandler::CatBoostLibraryBridgeExistsHandler(size_t ke
 }
 
 
-void CatBoostLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void CatBoostLibraryBridgeExistsHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     try
     {
diff --git a/programs/library-bridge/LibraryBridgeHandlers.h b/programs/library-bridge/LibraryBridgeHandlers.h
index 16815e847232..4f08d7a60840 100644
--- a/programs/library-bridge/LibraryBridgeHandlers.h
+++ b/programs/library-bridge/LibraryBridgeHandlers.h
@@ -20,7 +20,7 @@ class ExternalDictionaryLibraryBridgeRequestHandler : public HTTPRequestHandler,
 public:
     ExternalDictionaryLibraryBridgeRequestHandler(size_t keep_alive_timeout_, ContextPtr context_);
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     static constexpr inline auto FORMAT = "RowBinary";
@@ -36,7 +36,7 @@ class ExternalDictionaryLibraryBridgeExistsHandler : public HTTPRequestHandler,
 public:
     ExternalDictionaryLibraryBridgeExistsHandler(size_t keep_alive_timeout_, ContextPtr context_);
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     const size_t keep_alive_timeout;
@@ -65,7 +65,7 @@ class CatBoostLibraryBridgeRequestHandler : public HTTPRequestHandler, WithConte
 public:
     CatBoostLibraryBridgeRequestHandler(size_t keep_alive_timeout_, ContextPtr context_);
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     const size_t keep_alive_timeout;
@@ -79,7 +79,7 @@ class CatBoostLibraryBridgeExistsHandler : public HTTPRequestHandler, WithContex
 public:
     CatBoostLibraryBridgeExistsHandler(size_t keep_alive_timeout_, ContextPtr context_);
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     const size_t keep_alive_timeout;
diff --git a/programs/odbc-bridge/ColumnInfoHandler.cpp b/programs/odbc-bridge/ColumnInfoHandler.cpp
index 434abf0bf14c..774883657b71 100644
--- a/programs/odbc-bridge/ColumnInfoHandler.cpp
+++ b/programs/odbc-bridge/ColumnInfoHandler.cpp
@@ -69,7 +69,7 @@ namespace
 }
 
 
-void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());
     LOG_TRACE(log, "Request URI: {}", request.getURI());
@@ -78,7 +78,7 @@ void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServ
     {
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);
         if (!response.sent())
-            *response.send() << message << std::endl;
+            *response.send() << message << '
';
         LOG_WARNING(log, fmt::runtime(message));
     };
 
diff --git a/programs/odbc-bridge/ColumnInfoHandler.h b/programs/odbc-bridge/ColumnInfoHandler.h
index 3ba8b182ba60..e3087701182c 100644
--- a/programs/odbc-bridge/ColumnInfoHandler.h
+++ b/programs/odbc-bridge/ColumnInfoHandler.h
@@ -23,7 +23,7 @@ class ODBCColumnsInfoHandler : public HTTPRequestHandler, WithContext
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     Poco::Logger * log;
diff --git a/programs/odbc-bridge/IdentifierQuoteHandler.cpp b/programs/odbc-bridge/IdentifierQuoteHandler.cpp
index f622995bf154..a23efb112de4 100644
--- a/programs/odbc-bridge/IdentifierQuoteHandler.cpp
+++ b/programs/odbc-bridge/IdentifierQuoteHandler.cpp
@@ -21,7 +21,7 @@
 
 namespace DB
 {
-void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());
     LOG_TRACE(log, "Request URI: {}", request.getURI());
@@ -30,7 +30,7 @@ void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServ
     {
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);
         if (!response.sent())
-            *response.send() << message << std::endl;
+            response.send()->writeln(message);
         LOG_WARNING(log, fmt::runtime(message));
     };
 
diff --git a/programs/odbc-bridge/IdentifierQuoteHandler.h b/programs/odbc-bridge/IdentifierQuoteHandler.h
index d57bbc0ca8ad..ff5c02ca07b3 100644
--- a/programs/odbc-bridge/IdentifierQuoteHandler.h
+++ b/programs/odbc-bridge/IdentifierQuoteHandler.h
@@ -21,7 +21,7 @@ class IdentifierQuoteHandler : public HTTPRequestHandler, WithContext
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     Poco::Logger * log;
diff --git a/programs/odbc-bridge/MainHandler.cpp b/programs/odbc-bridge/MainHandler.cpp
index 9130b3e0f47b..e350afa2b103 100644
--- a/programs/odbc-bridge/MainHandler.cpp
+++ b/programs/odbc-bridge/MainHandler.cpp
@@ -46,12 +46,12 @@ void ODBCHandler::processError(HTTPServerResponse & response, const std::string
 {
     response.setStatusAndReason(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);
     if (!response.sent())
-        *response.send() << message << std::endl;
+        *response.send() << message << '
';
     LOG_WARNING(log, fmt::runtime(message));
 }
 
 
-void ODBCHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void ODBCHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     HTMLForm params(getContext()->getSettingsRef(), request);
     LOG_TRACE(log, "Request URI: {}", request.getURI());
diff --git a/programs/odbc-bridge/MainHandler.h b/programs/odbc-bridge/MainHandler.h
index bc0fca8b9a51..7977245ff821 100644
--- a/programs/odbc-bridge/MainHandler.h
+++ b/programs/odbc-bridge/MainHandler.h
@@ -30,7 +30,7 @@ class ODBCHandler : public HTTPRequestHandler, WithContext
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     Poco::Logger * log;
diff --git a/programs/odbc-bridge/PingHandler.cpp b/programs/odbc-bridge/PingHandler.cpp
index e3ab5e5cd00f..80d0e2bf4a9f 100644
--- a/programs/odbc-bridge/PingHandler.cpp
+++ b/programs/odbc-bridge/PingHandler.cpp
@@ -6,7 +6,7 @@
 
 namespace DB
 {
-void PingHandler::handleRequest(HTTPServerRequest & /* request */, HTTPServerResponse & response)
+void PingHandler::handleRequest(HTTPServerRequest & /* request */, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     try
     {
diff --git a/programs/odbc-bridge/PingHandler.h b/programs/odbc-bridge/PingHandler.h
index c969ec55af76..c5447107e0ce 100644
--- a/programs/odbc-bridge/PingHandler.h
+++ b/programs/odbc-bridge/PingHandler.h
@@ -10,7 +10,7 @@ class PingHandler : public HTTPRequestHandler
 {
 public:
     explicit PingHandler(size_t keep_alive_timeout_) : keep_alive_timeout(keep_alive_timeout_) {}
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     size_t keep_alive_timeout;
diff --git a/programs/odbc-bridge/SchemaAllowedHandler.cpp b/programs/odbc-bridge/SchemaAllowedHandler.cpp
index 020359f51fd7..c7025ca43115 100644
--- a/programs/odbc-bridge/SchemaAllowedHandler.cpp
+++ b/programs/odbc-bridge/SchemaAllowedHandler.cpp
@@ -29,7 +29,7 @@ namespace
 }
 
 
-void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());
     LOG_TRACE(log, "Request URI: {}", request.getURI());
@@ -38,7 +38,7 @@ void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServer
     {
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);
         if (!response.sent())
-            *response.send() << message << std::endl;
+            *response.send() << message << '
';
         LOG_WARNING(log, fmt::runtime(message));
     };
 
diff --git a/programs/odbc-bridge/SchemaAllowedHandler.h b/programs/odbc-bridge/SchemaAllowedHandler.h
index cb71a6fb5a2f..aa0b04b1d314 100644
--- a/programs/odbc-bridge/SchemaAllowedHandler.h
+++ b/programs/odbc-bridge/SchemaAllowedHandler.h
@@ -24,7 +24,7 @@ class SchemaAllowedHandler : public HTTPRequestHandler, WithContext
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     Poco::Logger * log;
diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp
index 481510d681fb..5d52baf182b5 100644
--- a/programs/server/Server.cpp
+++ b/programs/server/Server.cpp
@@ -151,6 +151,18 @@ namespace ProfileEvents
 {
     extern const Event MainConfigLoads;
     extern const Event ServerStartupMilliseconds;
+    extern const Event InterfaceNativeSendBytes;
+    extern const Event InterfaceNativeReceiveBytes;
+    extern const Event InterfaceHTTPSendBytes;
+    extern const Event InterfaceHTTPReceiveBytes;
+    extern const Event InterfacePrometheusSendBytes;
+    extern const Event InterfacePrometheusReceiveBytes;
+    extern const Event InterfaceInterserverSendBytes;
+    extern const Event InterfaceInterserverReceiveBytes;
+    extern const Event InterfaceMySQLSendBytes;
+    extern const Event InterfaceMySQLReceiveBytes;
+    extern const Event InterfacePostgreSQLSendBytes;
+    extern const Event InterfacePostgreSQLReceiveBytes;
 }
 
 namespace fs = std::filesystem;
@@ -2045,7 +2057,7 @@ std::unique_ptr<TCPProtocolStackFactory> Server::buildProtocolStackFromConfig(
     auto create_factory = [&](const std::string & type, const std::string & conf_name) -> TCPServerConnectionFactory::Ptr
     {
         if (type == "tcp")
-            return TCPServerConnectionFactory::Ptr(new TCPHandlerFactory(*this, false, false));
+            return TCPServerConnectionFactory::Ptr(new TCPHandlerFactory(*this, false, false, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes));
 
         if (type == "tls")
 #if USE_SSL
@@ -2057,20 +2069,20 @@ std::unique_ptr<TCPProtocolStackFactory> Server::buildProtocolStackFromConfig(
         if (type == "proxy1")
             return TCPServerConnectionFactory::Ptr(new ProxyV1HandlerFactory(*this, conf_name));
         if (type == "mysql")
-            return TCPServerConnectionFactory::Ptr(new MySQLHandlerFactory(*this));
+            return TCPServerConnectionFactory::Ptr(new MySQLHandlerFactory(*this, ProfileEvents::InterfaceMySQLReceiveBytes, ProfileEvents::InterfaceMySQLSendBytes));
         if (type == "postgres")
-            return TCPServerConnectionFactory::Ptr(new PostgreSQLHandlerFactory(*this));
+            return TCPServerConnectionFactory::Ptr(new PostgreSQLHandlerFactory(*this, ProfileEvents::InterfacePostgreSQLReceiveBytes, ProfileEvents::InterfacePostgreSQLSendBytes));
         if (type == "http")
             return TCPServerConnectionFactory::Ptr(
-                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, "HTTPHandler-factory"))
+                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, "HTTPHandler-factory"), ProfileEvents::InterfaceHTTPReceiveBytes, ProfileEvents::InterfaceHTTPSendBytes)
             );
         if (type == "prometheus")
             return TCPServerConnectionFactory::Ptr(
-                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, "PrometheusHandler-factory"))
+                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, "PrometheusHandler-factory"), ProfileEvents::InterfacePrometheusReceiveBytes, ProfileEvents::InterfacePrometheusSendBytes)
             );
         if (type == "interserver")
             return TCPServerConnectionFactory::Ptr(
-                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, "InterserverIOHTTPHandler-factory"))
+                new HTTPServerConnectionFactory(httpContext(), http_params, createHandlerFactory(*this, config, async_metrics, "InterserverIOHTTPHandler-factory"), ProfileEvents::InterfaceInterserverReceiveBytes, ProfileEvents::InterfaceInterserverSendBytes)
             );
 
         throw Exception(ErrorCodes::INVALID_CONFIG_PARAMETER, "Protocol configuration error, unknown protocol name '{}'", type);
@@ -2203,7 +2215,7 @@ void Server::createServers(
                     port_name,
                     "http://" + address.toString(),
                     std::make_unique<HTTPServer>(
-                        httpContext(), createHandlerFactory(*this, config, async_metrics, "HTTPHandler-factory"), server_pool, socket, http_params));
+                        httpContext(), createHandlerFactory(*this, config, async_metrics, "HTTPHandler-factory"), server_pool, socket, http_params, ProfileEvents::InterfaceHTTPReceiveBytes, ProfileEvents::InterfaceHTTPSendBytes));
             });
         }
 
@@ -2223,7 +2235,7 @@ void Server::createServers(
                     port_name,
                     "https://" + address.toString(),
                     std::make_unique<HTTPServer>(
-                        httpContext(), createHandlerFactory(*this, config, async_metrics, "HTTPSHandler-factory"), server_pool, socket, http_params));
+                        httpContext(), createHandlerFactory(*this, config, async_metrics, "HTTPSHandler-factory"), server_pool, socket, http_params, ProfileEvents::InterfaceHTTPReceiveBytes, ProfileEvents::InterfaceHTTPSendBytes));
 #else
                 UNUSED(port);
                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, "HTTPS protocol is disabled because Poco library was built without NetSSL support.");
@@ -2246,7 +2258,7 @@ void Server::createServers(
                     port_name,
                     "native protocol (tcp): " + address.toString(),
                     std::make_unique<TCPServer>(
-                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ false),
+                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ false, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes),
                         server_pool,
                         socket,
                         new Poco::Net::TCPServerParams));
@@ -2268,7 +2280,7 @@ void Server::createServers(
                     port_name,
                     "native protocol (tcp) with PROXY: " + address.toString(),
                     std::make_unique<TCPServer>(
-                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ true),
+                        new TCPHandlerFactory(*this, /* secure */ false, /* proxy protocol */ true, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes),
                         server_pool,
                         socket,
                         new Poco::Net::TCPServerParams));
@@ -2291,7 +2303,7 @@ void Server::createServers(
                     port_name,
                     "secure native protocol (tcp_secure): " + address.toString(),
                     std::make_unique<TCPServer>(
-                        new TCPHandlerFactory(*this, /* secure */ true, /* proxy protocol */ false),
+                        new TCPHandlerFactory(*this, /* secure */ true, /* proxy protocol */ false, ProfileEvents::InterfaceNativeReceiveBytes, ProfileEvents::InterfaceNativeSendBytes),
                         server_pool,
                         socket,
                         new Poco::Net::TCPServerParams));
@@ -2315,7 +2327,7 @@ void Server::createServers(
                     listen_host,
                     port_name,
                     "MySQL compatibility protocol: " + address.toString(),
-                    std::make_unique<TCPServer>(new MySQLHandlerFactory(*this), server_pool, socket, new Poco::Net::TCPServerParams));
+                    std::make_unique<TCPServer>(new MySQLHandlerFactory(*this, ProfileEvents::InterfaceMySQLReceiveBytes, ProfileEvents::InterfaceMySQLSendBytes), server_pool, socket, new Poco::Net::TCPServerParams));
             });
         }
 
@@ -2332,7 +2344,7 @@ void Server::createServers(
                     listen_host,
                     port_name,
                     "PostgreSQL compatibility protocol: " + address.toString(),
-                    std::make_unique<TCPServer>(new PostgreSQLHandlerFactory(*this), server_pool, socket, new Poco::Net::TCPServerParams));
+                    std::make_unique<TCPServer>(new PostgreSQLHandlerFactory(*this, ProfileEvents::InterfacePostgreSQLReceiveBytes, ProfileEvents::InterfacePostgreSQLSendBytes), server_pool, socket, new Poco::Net::TCPServerParams));
             });
         }
 
@@ -2366,7 +2378,7 @@ void Server::createServers(
                     port_name,
                     "Prometheus: http://" + address.toString(),
                     std::make_unique<HTTPServer>(
-                        httpContext(), createHandlerFactory(*this, config, async_metrics, "PrometheusHandler-factory"), server_pool, socket, http_params));
+                        httpContext(), createHandlerFactory(*this, config, async_metrics, "PrometheusHandler-factory"), server_pool, socket, http_params, ProfileEvents::InterfacePrometheusReceiveBytes, ProfileEvents::InterfacePrometheusSendBytes));
             });
         }
     }
@@ -2412,7 +2424,9 @@ void Server::createInterserverServers(
                         createHandlerFactory(*this, config, async_metrics, "InterserverIOHTTPHandler-factory"),
                         server_pool,
                         socket,
-                        http_params));
+                        http_params,
+                        ProfileEvents::InterfaceInterserverReceiveBytes,
+                        ProfileEvents::InterfaceInterserverSendBytes));
             });
         }
 
@@ -2435,7 +2449,9 @@ void Server::createInterserverServers(
                         createHandlerFactory(*this, config, async_metrics, "InterserverIOHTTPSHandler-factory"),
                         server_pool,
                         socket,
-                        http_params));
+                        http_params,
+                        ProfileEvents::InterfaceInterserverReceiveBytes,
+                        ProfileEvents::InterfaceInterserverSendBytes));
 #else
                 UNUSED(port);
                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, "SSL support for TCP protocol is disabled because Poco library was built without NetSSL support.");
diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp
index 4bdf6288a1cf..d6e5a77b64a3 100644
--- a/src/Common/ProfileEvents.cpp
+++ b/src/Common/ProfileEvents.cpp
@@ -587,6 +587,19 @@ The server successfully detected this situation and will download merged part fr
     M(LogError, "Number of log messages with level Error") \
     M(LogFatal, "Number of log messages with level Fatal") \
     \
+    M(InterfaceHTTPSendBytes, "Number of bytes sent through HTTP interfaces") \
+    M(InterfaceHTTPReceiveBytes, "Number of bytes received through HTTP interfaces") \
+    M(InterfaceNativeSendBytes, "Number of bytes sent through native interfaces") \
+    M(InterfaceNativeReceiveBytes, "Number of bytes received through native interfaces") \
+    M(InterfacePrometheusSendBytes, "Number of bytes sent through Prometheus interfaces") \
+    M(InterfacePrometheusReceiveBytes, "Number of bytes received through Prometheus interfaces") \
+    M(InterfaceInterserverSendBytes, "Number of bytes sent through interserver interfaces") \
+    M(InterfaceInterserverReceiveBytes, "Number of bytes received through interserver interfaces") \
+    M(InterfaceMySQLSendBytes, "Number of bytes sent through MySQL interfaces") \
+    M(InterfaceMySQLReceiveBytes, "Number of bytes received through MySQL interfaces") \
+    M(InterfacePostgreSQLSendBytes, "Number of bytes sent through PostgreSQL interfaces") \
+    M(InterfacePostgreSQLReceiveBytes, "Number of bytes received through PostgreSQL interfaces") \
+    \
     M(ParallelReplicasUsedCount, "Number of replicas used to execute a query with task-based parallel replicas") \
 
 #ifdef APPLY_FOR_EXTERNAL_EVENTS
diff --git a/src/IO/BrotliWriteBuffer.cpp b/src/IO/BrotliWriteBuffer.cpp
index a19c6770dad2..a497b78a6c25 100644
--- a/src/IO/BrotliWriteBuffer.cpp
+++ b/src/IO/BrotliWriteBuffer.cpp
@@ -13,33 +13,14 @@ namespace ErrorCodes
 }
 
 
-class BrotliWriteBuffer::BrotliStateWrapper
+BrotliWriteBuffer::BrotliStateWrapper::BrotliStateWrapper()
+: state(BrotliEncoderCreateInstance(nullptr, nullptr, nullptr))
 {
-public:
-    BrotliStateWrapper()
-    : state(BrotliEncoderCreateInstance(nullptr, nullptr, nullptr))
-    {
-    }
-
-    ~BrotliStateWrapper()
-    {
-        BrotliEncoderDestroyInstance(state);
-    }
-
-    BrotliEncoderState * state;
-};
+}
 
-BrotliWriteBuffer::BrotliWriteBuffer(std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)
-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
-    , brotli(std::make_unique<BrotliStateWrapper>())
-    , in_available(0)
-    , in_data(nullptr)
-    , out_capacity(0)
-    , out_data(nullptr)
+BrotliWriteBuffer::BrotliStateWrapper::~BrotliStateWrapper()
 {
-    BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_QUALITY, static_cast<uint32_t>(compression_level));
-    // Set LZ77 window size. According to brotli sources default value is 24 (c/tools/brotli.c:81)
-    BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_LGWIN, 24);
+    BrotliEncoderDestroyInstance(state);
 }
 
 BrotliWriteBuffer::~BrotliWriteBuffer() = default;
@@ -58,18 +39,20 @@ void BrotliWriteBuffer::nextImpl()
     {
         do
         {
+            const auto * in_data_ptr = in_data;
             out->nextIfAtEnd();
             out_data = reinterpret_cast<unsigned char *>(out->position());
             out_capacity = out->buffer().end() - out->position();
 
             int result = BrotliEncoderCompressStream(
                     brotli->state,
-                    in_available ? BROTLI_OPERATION_PROCESS : BROTLI_OPERATION_FINISH,
+                    BROTLI_OPERATION_PROCESS,
                     &in_available,
                     &in_data,
                     &out_capacity,
                     &out_data,
                     nullptr);
+            total_in += in_data - in_data_ptr;
 
             out->position() = out->buffer().end() - out_capacity;
 
@@ -92,6 +75,10 @@ void BrotliWriteBuffer::finalizeBefore()
 {
     next();
 
+    /// Don't write out if no data was ever compressed
+    if (!compress_empty && total_in == 0)
+        return;
+
     while (true)
     {
         out->nextIfAtEnd();
diff --git a/src/IO/BrotliWriteBuffer.h b/src/IO/BrotliWriteBuffer.h
index 8cbc78bd9e7a..d4cda7b270cc 100644
--- a/src/IO/BrotliWriteBuffer.h
+++ b/src/IO/BrotliWriteBuffer.h
@@ -4,18 +4,38 @@
 #include <IO/BufferWithOwnMemory.h>
 #include <IO/WriteBufferDecorator.h>
 
+#include "config.h"
+
+#if USE_BROTLI
+#    include <brotli/encode.h>
+
 namespace DB
 {
 
+
 class BrotliWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 {
 public:
+    template<typename WriteBufferT>
     BrotliWriteBuffer(
-        std::unique_ptr<WriteBuffer> out_,
+        WriteBufferT && out_,
         int compression_level,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
         char * existing_memory = nullptr,
-        size_t alignment = 0);
+        size_t alignment = 0,
+        bool compress_empty_ = true)
+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
+    , brotli(std::make_unique<BrotliStateWrapper>())
+    , in_available(0)
+    , in_data(nullptr)
+    , out_capacity(0)
+    , out_data(nullptr)
+    , compress_empty(compress_empty_)
+    {
+        BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_QUALITY, static_cast<uint32_t>(compression_level));
+        // Set LZ77 window size. According to brotli sources default value is 24 (c/tools/brotli.c:81)
+        BrotliEncoderSetParameter(brotli->state, BROTLI_PARAM_LGWIN, 24);
+    }
 
     ~BrotliWriteBuffer() override;
 
@@ -24,7 +44,15 @@ class BrotliWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 
     void finalizeBefore() override;
 
-    class BrotliStateWrapper;
+    class BrotliStateWrapper
+    {
+    public:
+        BrotliStateWrapper();
+        ~BrotliStateWrapper();
+
+        BrotliEncoderState * state;
+    };
+
     std::unique_ptr<BrotliStateWrapper> brotli;
 
 
@@ -33,6 +61,12 @@ class BrotliWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 
     size_t out_capacity;
     uint8_t * out_data;
+
+protected:
+    UInt64 total_in = 0;
+    bool compress_empty = true;
 };
 
 }
+
+#endif
diff --git a/src/IO/BufferBase.h b/src/IO/BufferBase.h
index 7a59687fa564..4c0a467b155a 100644
--- a/src/IO/BufferBase.h
+++ b/src/IO/BufferBase.h
@@ -2,6 +2,7 @@
 
 #include <Core/Defines.h>
 #include <algorithm>
+#include <memory>
 
 
 namespace DB
diff --git a/src/IO/Bzip2WriteBuffer.cpp b/src/IO/Bzip2WriteBuffer.cpp
index b84cbdd1e415..3421b4c3985d 100644
--- a/src/IO/Bzip2WriteBuffer.cpp
+++ b/src/IO/Bzip2WriteBuffer.cpp
@@ -15,34 +15,22 @@ namespace ErrorCodes
 }
 
 
-class Bzip2WriteBuffer::Bzip2StateWrapper
+Bzip2WriteBuffer::Bzip2StateWrapper::Bzip2StateWrapper(int compression_level)
 {
-public:
-    explicit Bzip2StateWrapper(int compression_level)
-    {
-        memset(&stream, 0, sizeof(stream));
-
-        int ret = BZ2_bzCompressInit(&stream, compression_level, 0, 0);
+    memset(&stream, 0, sizeof(stream));
 
-        if (ret != BZ_OK)
-            throw Exception(
-                ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,
-                "bzip2 stream encoder init failed: error code: {}",
-                ret);
-    }
+    int ret = BZ2_bzCompressInit(&stream, compression_level, 0, 0);
 
-    ~Bzip2StateWrapper()
-    {
-        BZ2_bzCompressEnd(&stream);
-    }
-
-    bz_stream stream;
-};
+    if (ret != BZ_OK)
+        throw Exception(
+            ErrorCodes::BZIP2_STREAM_ENCODER_FAILED,
+            "bzip2 stream encoder init failed: error code: {}",
+            ret);
+}
 
-Bzip2WriteBuffer::Bzip2WriteBuffer(std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)
-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
-    , bz(std::make_unique<Bzip2StateWrapper>(compression_level))
+Bzip2WriteBuffer::Bzip2StateWrapper::~Bzip2StateWrapper()
 {
+    BZ2_bzCompressEnd(&stream);
 }
 
 Bzip2WriteBuffer::~Bzip2WriteBuffer() = default;
@@ -77,6 +65,8 @@ void Bzip2WriteBuffer::nextImpl()
 
         }
         while (bz->stream.avail_in > 0);
+
+        total_in += offset();
     }
     catch (...)
     {
@@ -90,6 +80,10 @@ void Bzip2WriteBuffer::finalizeBefore()
 {
     next();
 
+    /// Don't write out if no data was ever compressed
+    if (!compress_empty && total_in == 0)
+        return;
+
     out->nextIfAtEnd();
     bz->stream.next_out = out->position();
     bz->stream.avail_out = static_cast<unsigned>(out->buffer().end() - out->position());
diff --git a/src/IO/Bzip2WriteBuffer.h b/src/IO/Bzip2WriteBuffer.h
index d03719034878..63c67461c6ab 100644
--- a/src/IO/Bzip2WriteBuffer.h
+++ b/src/IO/Bzip2WriteBuffer.h
@@ -4,18 +4,29 @@
 #include <IO/BufferWithOwnMemory.h>
 #include <IO/WriteBufferDecorator.h>
 
+#include "config.h"
+
+#if USE_BZIP2
+#    include <bzlib.h>
+
 namespace DB
 {
 
 class Bzip2WriteBuffer : public WriteBufferWithOwnMemoryDecorator
 {
 public:
+    template<typename WriteBufferT>
     Bzip2WriteBuffer(
-        std::unique_ptr<WriteBuffer> out_,
+        WriteBufferT && out_,
         int compression_level,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
         char * existing_memory = nullptr,
-        size_t alignment = 0);
+        size_t alignment = 0,
+        bool compress_empty_ = true)
+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), bz(std::make_unique<Bzip2StateWrapper>(compression_level))
+    , compress_empty(compress_empty_)
+    {
+    }
 
     ~Bzip2WriteBuffer() override;
 
@@ -24,8 +35,20 @@ class Bzip2WriteBuffer : public WriteBufferWithOwnMemoryDecorator
 
     void finalizeBefore() override;
 
-    class Bzip2StateWrapper;
+    class Bzip2StateWrapper
+    {
+    public:
+        explicit Bzip2StateWrapper(int compression_level);
+        ~Bzip2StateWrapper();
+
+        bz_stream stream;
+    };
+
     std::unique_ptr<Bzip2StateWrapper> bz;
+    bool compress_empty = true;
+    UInt64 total_in = 0;
 };
 
 }
+
+#endif
diff --git a/src/IO/CompressionMethod.cpp b/src/IO/CompressionMethod.cpp
index 13e1adbb7024..90453e169619 100644
--- a/src/IO/CompressionMethod.cpp
+++ b/src/IO/CompressionMethod.cpp
@@ -169,37 +169,66 @@ std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(
     return createCompressedWrapper(std::move(nested), method, buf_size, existing_memory, alignment, zstd_window_log_max);
 }
 
-std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(
-    std::unique_ptr<WriteBuffer> nested, CompressionMethod method, int level, size_t buf_size, char * existing_memory, size_t alignment)
+
+template<typename WriteBufferT>
+std::unique_ptr<WriteBuffer> createWriteCompressedWrapper(
+    WriteBufferT && nested, CompressionMethod method, int level, size_t buf_size, char * existing_memory, size_t alignment, bool compress_empty)
 {
     if (method == DB::CompressionMethod::Gzip || method == CompressionMethod::Zlib)
-        return std::make_unique<ZlibDeflatingWriteBuffer>(std::move(nested), method, level, buf_size, existing_memory, alignment);
+        return std::make_unique<ZlibDeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), method, level, buf_size, existing_memory, alignment, compress_empty);
 
 #if USE_BROTLI
     if (method == DB::CompressionMethod::Brotli)
-        return std::make_unique<BrotliWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);
+        return std::make_unique<BrotliWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);
 #endif
     if (method == CompressionMethod::Xz)
-        return std::make_unique<LZMADeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);
+        return std::make_unique<LZMADeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);
 
     if (method == CompressionMethod::Zstd)
-        return std::make_unique<ZstdDeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);
+        return std::make_unique<ZstdDeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);
 
     if (method == CompressionMethod::Lz4)
-        return std::make_unique<Lz4DeflatingWriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);
+        return std::make_unique<Lz4DeflatingWriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);
 
 #if USE_BZIP2
     if (method == CompressionMethod::Bzip2)
-        return std::make_unique<Bzip2WriteBuffer>(std::move(nested), level, buf_size, existing_memory, alignment);
+        return std::make_unique<Bzip2WriteBuffer>(std::forward<WriteBufferT>(nested), level, buf_size, existing_memory, alignment, compress_empty);
 #endif
 #if USE_SNAPPY
     if (method == CompressionMethod::Snappy)
         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Unsupported compression method");
 #endif
+
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Unsupported compression method");
+}
+
+
+std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(
+    std::unique_ptr<WriteBuffer> nested,
+    CompressionMethod method,
+    int level,
+    size_t buf_size,
+    char * existing_memory,
+    size_t alignment,
+    bool compress_empty)
+{
     if (method == CompressionMethod::None)
         return nested;
+    return createWriteCompressedWrapper(nested, method, level, buf_size, existing_memory, alignment, compress_empty);
+}
 
-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Unsupported compression method");
+
+std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(
+    WriteBuffer * nested,
+    CompressionMethod method,
+    int level,
+    size_t buf_size,
+    char * existing_memory,
+    size_t alignment,
+    bool compress_empty)
+{
+    assert(method != CompressionMethod::None);
+    return createWriteCompressedWrapper(nested, method, level, buf_size, existing_memory, alignment, compress_empty);
 }
 
 }
diff --git a/src/IO/CompressionMethod.h b/src/IO/CompressionMethod.h
index c142531cd05f..d218e4c5882d 100644
--- a/src/IO/CompressionMethod.h
+++ b/src/IO/CompressionMethod.h
@@ -61,13 +61,22 @@ std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(
     char * existing_memory = nullptr,
     size_t alignment = 0);
 
-
 std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(
     std::unique_ptr<WriteBuffer> nested,
     CompressionMethod method,
     int level,
     size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
     char * existing_memory = nullptr,
-    size_t alignment = 0);
+    size_t alignment = 0,
+    bool compress_empty = true);
+
+std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(
+    WriteBuffer * nested,
+    CompressionMethod method,
+    int level,
+    size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
+    char * existing_memory = nullptr,
+    size_t alignment = 0,
+    bool compress_empty = true);
 
 }
diff --git a/src/IO/LZMADeflatingWriteBuffer.cpp b/src/IO/LZMADeflatingWriteBuffer.cpp
index a77b2bb7b397..db8f8c95fe60 100644
--- a/src/IO/LZMADeflatingWriteBuffer.cpp
+++ b/src/IO/LZMADeflatingWriteBuffer.cpp
@@ -7,9 +7,7 @@ namespace ErrorCodes
     extern const int LZMA_STREAM_ENCODER_FAILED;
 }
 
-LZMADeflatingWriteBuffer::LZMADeflatingWriteBuffer(
-    std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)
-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
+void LZMADeflatingWriteBuffer::initialize(int compression_level)
 {
 
     lstr = LZMA_STREAM_INIT;
@@ -94,6 +92,10 @@ void LZMADeflatingWriteBuffer::finalizeBefore()
 {
     next();
 
+    /// Don't write out if no data was ever compressed
+    if (!compress_empty && lstr.total_out == 0)
+        return;
+
     do
     {
         out->nextIfAtEnd();
diff --git a/src/IO/LZMADeflatingWriteBuffer.h b/src/IO/LZMADeflatingWriteBuffer.h
index 2e135455e006..797b85cd400a 100644
--- a/src/IO/LZMADeflatingWriteBuffer.h
+++ b/src/IO/LZMADeflatingWriteBuffer.h
@@ -14,22 +14,32 @@ namespace DB
 class LZMADeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 {
 public:
+    template<typename WriteBufferT>
     LZMADeflatingWriteBuffer(
-        std::unique_ptr<WriteBuffer> out_,
+        WriteBufferT && out_,
         int compression_level,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
         char * existing_memory = nullptr,
-        size_t alignment = 0);
+        size_t alignment = 0,
+        bool compress_empty_ = true)
+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), compress_empty(compress_empty_)
+    {
+        initialize(compression_level);
+    }
 
     ~LZMADeflatingWriteBuffer() override;
 
 private:
+    void initialize(int compression_level);
+
     void nextImpl() override;
 
     void finalizeBefore() override;
     void finalizeAfter() override;
 
     lzma_stream lstr;
+
+    bool compress_empty = true;
 };
 
 }
diff --git a/src/IO/Lz4DeflatingWriteBuffer.cpp b/src/IO/Lz4DeflatingWriteBuffer.cpp
index 8241bfd4f3cb..a8cac823b50a 100644
--- a/src/IO/Lz4DeflatingWriteBuffer.cpp
+++ b/src/IO/Lz4DeflatingWriteBuffer.cpp
@@ -63,11 +63,8 @@ namespace ErrorCodes
     extern const int LZ4_ENCODER_FAILED;
 }
 
-Lz4DeflatingWriteBuffer::Lz4DeflatingWriteBuffer(
-    std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)
-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
-    , tmp_memory(buf_size)
 
+void Lz4DeflatingWriteBuffer::initialize(int compression_level)
 {
     kPrefs = {
         {LZ4F_max256KB,
@@ -105,7 +102,7 @@ void Lz4DeflatingWriteBuffer::nextImpl()
 
     if (first_time)
     {
-        auto sink = SinkToOut(out.get(), tmp_memory, LZ4F_HEADER_SIZE_MAX);
+        auto sink = SinkToOut(out, tmp_memory, LZ4F_HEADER_SIZE_MAX);
         chassert(sink.getCapacity() >= LZ4F_HEADER_SIZE_MAX);
 
         /// write frame header and check for errors
@@ -131,7 +128,7 @@ void Lz4DeflatingWriteBuffer::nextImpl()
         /// Ensure that there is enough space for compressed block of minimal size
         size_t min_compressed_block_size = LZ4F_compressBound(1, &kPrefs);
 
-        auto sink = SinkToOut(out.get(), tmp_memory, min_compressed_block_size);
+        auto sink = SinkToOut(out, tmp_memory, min_compressed_block_size);
         chassert(sink.getCapacity() >= min_compressed_block_size);
 
         /// LZ4F_compressUpdate compresses whole input buffer at once so we need to shink it manually
@@ -163,8 +160,12 @@ void Lz4DeflatingWriteBuffer::finalizeBefore()
 {
     next();
 
+    /// Don't write out if no data was ever compressed
+    if (!compress_empty && first_time)
+        return;
+
     auto suffix_size = LZ4F_compressBound(0, &kPrefs);
-    auto sink = SinkToOut(out.get(), tmp_memory, suffix_size);
+    auto sink = SinkToOut(out, tmp_memory, suffix_size);
     chassert(sink.getCapacity() >= suffix_size);
 
     /// compression end
diff --git a/src/IO/Lz4DeflatingWriteBuffer.h b/src/IO/Lz4DeflatingWriteBuffer.h
index 7bb8a5e6c0ec..b37d61fa7326 100644
--- a/src/IO/Lz4DeflatingWriteBuffer.h
+++ b/src/IO/Lz4DeflatingWriteBuffer.h
@@ -14,16 +14,26 @@ namespace DB
 class Lz4DeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 {
 public:
+    template<typename WriteBufferT>
     Lz4DeflatingWriteBuffer(
-        std::unique_ptr<WriteBuffer> out_,
+        WriteBufferT && out_,
         int compression_level,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
         char * existing_memory = nullptr,
-        size_t alignment = 0);
+        size_t alignment = 0,
+        bool compress_empty_ = true)
+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
+    , tmp_memory(buf_size)
+    , compress_empty(compress_empty_)
+    {
+        initialize(compression_level);
+    }
 
     ~Lz4DeflatingWriteBuffer() override;
 
 private:
+    void initialize(int compression_level);
+
     void nextImpl() override;
 
     void finalizeBefore() override;
@@ -35,5 +45,6 @@ class Lz4DeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
     Memory<> tmp_memory;
 
     bool first_time = true;
+    bool compress_empty = true;
 };
 }
diff --git a/src/IO/ReadBufferFromPocoSocket.cpp b/src/IO/ReadBufferFromPocoSocket.cpp
index ff72dc5386c1..d399721d0603 100644
--- a/src/IO/ReadBufferFromPocoSocket.cpp
+++ b/src/IO/ReadBufferFromPocoSocket.cpp
@@ -99,6 +99,9 @@ bool ReadBufferFromPocoSocket::nextImpl()
     if (bytes_read < 0)
         throw NetException(ErrorCodes::CANNOT_READ_FROM_SOCKET, "Cannot read from socket ({})", peer_address.toString());
 
+    if (read_event != ProfileEvents::end())
+        ProfileEvents::increment(read_event, bytes_read);
+
     if (bytes_read)
         working_buffer.resize(bytes_read);
     else
@@ -111,10 +114,17 @@ ReadBufferFromPocoSocket::ReadBufferFromPocoSocket(Poco::Net::Socket & socket_,
     : BufferWithOwnMemory<ReadBuffer>(buf_size)
     , socket(socket_)
     , peer_address(socket.peerAddress())
+    , read_event(ProfileEvents::end())
     , socket_description("socket (" + peer_address.toString() + ")")
 {
 }
 
+ReadBufferFromPocoSocket::ReadBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & read_event_, size_t buf_size)
+    : ReadBufferFromPocoSocket(socket_, buf_size)
+{
+    read_event = read_event_;
+}
+
 bool ReadBufferFromPocoSocket::poll(size_t timeout_microseconds) const
 {
     if (available())
diff --git a/src/IO/ReadBufferFromPocoSocket.h b/src/IO/ReadBufferFromPocoSocket.h
index dab4ac86295c..76156612764b 100644
--- a/src/IO/ReadBufferFromPocoSocket.h
+++ b/src/IO/ReadBufferFromPocoSocket.h
@@ -20,10 +20,13 @@ class ReadBufferFromPocoSocket : public BufferWithOwnMemory<ReadBuffer>
       */
     Poco::Net::SocketAddress peer_address;
 
+    ProfileEvents::Event read_event;
+
     bool nextImpl() override;
 
 public:
     explicit ReadBufferFromPocoSocket(Poco::Net::Socket & socket_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);
+    explicit ReadBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & read_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);
 
     bool poll(size_t timeout_microseconds) const;
 
diff --git a/src/IO/WriteBufferDecorator.h b/src/IO/WriteBufferDecorator.h
index 7c984eeea8db..ee47834b7aff 100644
--- a/src/IO/WriteBufferDecorator.h
+++ b/src/IO/WriteBufferDecorator.h
@@ -12,13 +12,21 @@ class WriteBuffer;
 
 /// WriteBuffer that decorates data and delegates it to underlying buffer.
 /// It's used for writing compressed and encrypted data
+/// This class can own or not own underlying buffer - constructor will differentiate
+/// std::unique_ptr<WriteBuffer> for owning and WriteBuffer* for not owning.
 template <class Base>
 class WriteBufferDecorator : public Base
 {
 public:
     template <class ... BaseArgs>
     explicit WriteBufferDecorator(std::unique_ptr<WriteBuffer> out_, BaseArgs && ... args)
-        : Base(std::forward<BaseArgs>(args)...), out(std::move(out_))
+        : Base(std::forward<BaseArgs>(args)...), owning_holder(std::move(out_)), out(owning_holder.get())
+    {
+    }
+
+    template <class ... BaseArgs>
+    explicit WriteBufferDecorator(WriteBuffer * out_, BaseArgs && ... args)
+        : Base(std::forward<BaseArgs>(args)...), out(out_)
     {
     }
 
@@ -38,7 +46,7 @@ class WriteBufferDecorator : public Base
         }
     }
 
-    WriteBuffer * getNestedBuffer() { return out.get(); }
+    WriteBuffer * getNestedBuffer() { return out; }
 
 protected:
     /// Do some finalization before finalization of underlying buffer.
@@ -47,7 +55,8 @@ class WriteBufferDecorator : public Base
     /// Do some finalization after finalization of underlying buffer.
     virtual void finalizeAfter() {}
 
-    std::unique_ptr<WriteBuffer> out;
+    std::unique_ptr<WriteBuffer> owning_holder;
+    WriteBuffer * out;
 };
 
 using WriteBufferWithOwnMemoryDecorator = WriteBufferDecorator<BufferWithOwnMemory<WriteBuffer>>;
diff --git a/src/IO/WriteBufferFromEncryptedFile.h b/src/IO/WriteBufferFromEncryptedFile.h
index 25dd54ca9d52..f8f864d00a6e 100644
--- a/src/IO/WriteBufferFromEncryptedFile.h
+++ b/src/IO/WriteBufferFromEncryptedFile.h
@@ -28,7 +28,7 @@ class WriteBufferFromEncryptedFile : public WriteBufferDecorator<WriteBufferFrom
 
     void sync() override;
 
-    std::string getFileName() const override { return assert_cast<WriteBufferFromFileBase *>(out.get())->getFileName(); }
+    std::string getFileName() const override { return assert_cast<WriteBufferFromFileBase *>(out)->getFileName(); }
 
 private:
     void nextImpl() override;
diff --git a/src/IO/WriteBufferFromPocoSocket.cpp b/src/IO/WriteBufferFromPocoSocket.cpp
index 171e7f1ce691..10d9fd131cdc 100644
--- a/src/IO/WriteBufferFromPocoSocket.cpp
+++ b/src/IO/WriteBufferFromPocoSocket.cpp
@@ -34,6 +34,97 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
+ssize_t WriteBufferFromPocoSocket::socketSendBytesImpl(const char * ptr, size_t size)
+{
+    ssize_t res = 0;
+
+    /// If async_callback is specified, set socket to non-blocking mode
+    /// and try to write data to it, if socket is not ready for writing,
+    /// run async_callback and try again later.
+    /// It is expected that file descriptor may be polled externally.
+    /// Note that send timeout is not checked here. External code should check it while polling.
+    if (async_callback)
+    {
+        socket.setBlocking(false);
+        /// Set socket to blocking mode at the end.
+        SCOPE_EXIT(socket.setBlocking(true));
+        bool secure = socket.secure();
+        res = socket.impl()->sendBytes(ptr, static_cast<int>(size));
+
+        /// Check EAGAIN and ERR_SSL_WANT_WRITE/ERR_SSL_WANT_READ for secure socket (writing to secure socket can read too).
+        while (res < 0 && (errno == EAGAIN || (secure && (checkSSLWantRead(res) || checkSSLWantWrite(res)))))
+        {
+            /// In case of ERR_SSL_WANT_READ we should wait for socket to be ready for reading, otherwise - for writing.
+            if (secure && checkSSLWantRead(res))
+                async_callback(socket.impl()->sockfd(), socket.getReceiveTimeout(), AsyncEventTimeoutType::RECEIVE, socket_description, AsyncTaskExecutor::Event::READ | AsyncTaskExecutor::Event::ERROR);
+            else
+                async_callback(socket.impl()->sockfd(), socket.getSendTimeout(), AsyncEventTimeoutType::SEND, socket_description, AsyncTaskExecutor::Event::WRITE | AsyncTaskExecutor::Event::ERROR);
+
+            /// Try to write again.
+            res = socket.impl()->sendBytes(ptr, static_cast<int>(size));
+        }
+    }
+    else
+    {
+        res = socket.impl()->sendBytes(ptr, static_cast<int>(size));
+    }
+
+    return res;
+}
+
+void WriteBufferFromPocoSocket::socketSendBytes(const char * ptr, size_t size)
+{
+    if (!size)
+        return;
+
+    Stopwatch watch;
+    size_t bytes_written = 0;
+
+    SCOPE_EXIT({
+        ProfileEvents::increment(ProfileEvents::NetworkSendElapsedMicroseconds, watch.elapsedMicroseconds());
+        ProfileEvents::increment(ProfileEvents::NetworkSendBytes, bytes_written);
+        if (write_event != ProfileEvents::end())
+            ProfileEvents::increment(write_event, bytes_written);
+    });
+
+    while (bytes_written < size)
+    {
+        ssize_t res = 0;
+
+        /// Add more details to exceptions.
+        try
+        {
+            CurrentMetrics::Increment metric_increment(CurrentMetrics::NetworkSend);
+            if (size > INT_MAX)
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Buffer overflow");
+
+            res = socketSendBytesImpl(ptr + bytes_written, size - bytes_written);
+        }
+        catch (const Poco::Net::NetException & e)
+        {
+            throw NetException(ErrorCodes::NETWORK_ERROR, "{}, while writing to socket ({} -> {})", e.displayText(),
+                               our_address.toString(), peer_address.toString());
+        }
+        catch (const Poco::TimeoutException &)
+        {
+            throw NetException(ErrorCodes::SOCKET_TIMEOUT, "Timeout exceeded while writing to socket ({}, {} ms)",
+                peer_address.toString(),
+                socket.impl()->getSendTimeout().totalMilliseconds());
+        }
+        catch (const Poco::IOException & e)
+        {
+            throw NetException(ErrorCodes::NETWORK_ERROR, "{}, while writing to socket ({} -> {})", e.displayText(),
+                               our_address.toString(), peer_address.toString());
+        }
+
+        if (res < 0)
+            throw NetException(ErrorCodes::CANNOT_WRITE_TO_SOCKET, "Cannot write to socket ({} -> {})",
+                               our_address.toString(), peer_address.toString());
+
+        bytes_written += res;
+    }
+}
+
 void WriteBufferFromPocoSocket::nextImpl()
 {
     if (!offset())
@@ -60,36 +151,7 @@ void WriteBufferFromPocoSocket::nextImpl()
             if (size > INT_MAX)
                 throw Exception(ErrorCodes::LOGICAL_ERROR, "Buffer overflow");
 
-            /// If async_callback is specified, set socket to non-blocking mode
-            /// and try to write data to it, if socket is not ready for writing,
-            /// run async_callback and try again later.
-            /// It is expected that file descriptor may be polled externally.
-            /// Note that send timeout is not checked here. External code should check it while polling.
-            if (async_callback)
-            {
-                socket.setBlocking(false);
-                /// Set socket to blocking mode at the end.
-                SCOPE_EXIT(socket.setBlocking(true));
-                bool secure = socket.secure();
-                res = socket.impl()->sendBytes(pos, static_cast<int>(size));
-
-                /// Check EAGAIN and ERR_SSL_WANT_WRITE/ERR_SSL_WANT_READ for secure socket (writing to secure socket can read too).
-                while (res < 0 && (errno == EAGAIN || (secure && (checkSSLWantRead(res) || checkSSLWantWrite(res)))))
-                {
-                    /// In case of ERR_SSL_WANT_READ we should wait for socket to be ready for reading, otherwise - for writing.
-                    if (secure && checkSSLWantRead(res))
-                        async_callback(socket.impl()->sockfd(), socket.getReceiveTimeout(), AsyncEventTimeoutType::RECEIVE, socket_description, AsyncTaskExecutor::Event::READ | AsyncTaskExecutor::Event::ERROR);
-                    else
-                        async_callback(socket.impl()->sockfd(), socket.getSendTimeout(), AsyncEventTimeoutType::SEND, socket_description, AsyncTaskExecutor::Event::WRITE | AsyncTaskExecutor::Event::ERROR);
-
-                    /// Try to write again.
-                    res = socket.impl()->sendBytes(pos, static_cast<int>(size));
-                }
-            }
-            else
-            {
-                res = socket.impl()->sendBytes(pos, static_cast<int>(size));
-            }
+            res = socketSendBytesImpl(pos, size);
         }
         catch (const Poco::Net::NetException & e)
         {
@@ -125,6 +187,12 @@ WriteBufferFromPocoSocket::WriteBufferFromPocoSocket(Poco::Net::Socket & socket_
 {
 }
 
+WriteBufferFromPocoSocket::WriteBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & write_event_, size_t buf_size)
+    : WriteBufferFromPocoSocket(socket_, buf_size)
+{
+    write_event = write_event_;
+}
+
 WriteBufferFromPocoSocket::~WriteBufferFromPocoSocket()
 {
     try
diff --git a/src/IO/WriteBufferFromPocoSocket.h b/src/IO/WriteBufferFromPocoSocket.h
index ecb610203573..9c5509aebd18 100644
--- a/src/IO/WriteBufferFromPocoSocket.h
+++ b/src/IO/WriteBufferFromPocoSocket.h
@@ -17,14 +17,33 @@ class WriteBufferFromPocoSocket : public BufferWithOwnMemory<WriteBuffer>
 {
 public:
     explicit WriteBufferFromPocoSocket(Poco::Net::Socket & socket_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);
+    explicit WriteBufferFromPocoSocket(Poco::Net::Socket & socket_, const ProfileEvents::Event & write_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE);
 
     ~WriteBufferFromPocoSocket() override;
 
     void setAsyncCallback(AsyncCallback async_callback_) { async_callback = std::move(async_callback_); }
 
+    using WriteBuffer::write;
+    void write(const std::string & str) { WriteBuffer::write(str.c_str(), str.size()); }
+    void write(std::string_view str) { WriteBuffer::write(str.data(), str.size()); }
+    void write(const char * str) { WriteBuffer::write(str, strlen(str)); }
+    void writeln(const std::string & str) { write(str); WriteBuffer::write("
", 1); }
+    void writeln(std::string_view str) { write(str); WriteBuffer::write("
", 1); }
+    void writeln(const char * str) { write(str); WriteBuffer::write("
", 1); }
+
 protected:
     void nextImpl() override;
 
+    void socketSendBytes(const char * ptr, size_t size);
+    void socketSendStr(const std::string & str)
+    {
+        return socketSendBytes(str.data(), str.size());
+    }
+    void socketSendStr(const char * ptr)
+    {
+        return socketSendBytes(ptr, strlen(ptr));
+    }
+
     Poco::Net::Socket & socket;
 
     /** For error messages. It is necessary to receive this address in advance, because,
@@ -34,9 +53,13 @@ class WriteBufferFromPocoSocket : public BufferWithOwnMemory<WriteBuffer>
     Poco::Net::SocketAddress peer_address;
     Poco::Net::SocketAddress our_address;
 
+    ProfileEvents::Event write_event;
+
 private:
     AsyncCallback async_callback;
     std::string socket_description;
+
+    ssize_t socketSendBytesImpl(const char * ptr, size_t size);
 };
 
 }
diff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h
index 094352638e6e..b4f8b476b110 100644
--- a/src/IO/WriteHelpers.h
+++ b/src/IO/WriteHelpers.h
@@ -63,9 +63,7 @@ namespace ErrorCodes
 
 inline void writeChar(char x, WriteBuffer & buf)
 {
-    buf.nextIfAtEnd();
-    *buf.position() = x;
-    ++buf.position();
+    buf.write(x);
 }
 
 /// Write the same character n times.
diff --git a/src/IO/ZlibDeflatingWriteBuffer.cpp b/src/IO/ZlibDeflatingWriteBuffer.cpp
index 6e4ab7424137..ab6763fe6a65 100644
--- a/src/IO/ZlibDeflatingWriteBuffer.cpp
+++ b/src/IO/ZlibDeflatingWriteBuffer.cpp
@@ -10,36 +10,6 @@ namespace ErrorCodes
     extern const int ZLIB_DEFLATE_FAILED;
 }
 
-
-ZlibDeflatingWriteBuffer::ZlibDeflatingWriteBuffer(
-        std::unique_ptr<WriteBuffer> out_,
-        CompressionMethod compression_method,
-        int compression_level,
-        size_t buf_size,
-        char * existing_memory,
-        size_t alignment)
-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
-{
-    zstr.zalloc = nullptr;
-    zstr.zfree = nullptr;
-    zstr.opaque = nullptr;
-    zstr.next_in = nullptr;
-    zstr.avail_in = 0;
-    zstr.next_out = nullptr;
-    zstr.avail_out = 0;
-
-    int window_bits = 15;
-    if (compression_method == CompressionMethod::Gzip)
-    {
-        window_bits += 16;
-    }
-
-    int rc = deflateInit2(&zstr, compression_level, Z_DEFLATED, window_bits, 8, Z_DEFAULT_STRATEGY);
-
-    if (rc != Z_OK)
-        throw Exception(ErrorCodes::ZLIB_DEFLATE_FAILED, "deflateInit2 failed: {}; zlib version: {}", zError(rc), ZLIB_VERSION);
-}
-
 void ZlibDeflatingWriteBuffer::nextImpl()
 {
     if (!offset())
@@ -82,6 +52,10 @@ void ZlibDeflatingWriteBuffer::finalizeBefore()
 {
     next();
 
+    /// Don't write out if no data was ever compressed
+    if (!compress_empty && zstr.total_out == 0)
+        return;
+
     /// https://github.com/zlib-ng/zlib-ng/issues/494
     do
     {
diff --git a/src/IO/ZlibDeflatingWriteBuffer.h b/src/IO/ZlibDeflatingWriteBuffer.h
index 58e709b54e64..f01c41c7d13c 100644
--- a/src/IO/ZlibDeflatingWriteBuffer.h
+++ b/src/IO/ZlibDeflatingWriteBuffer.h
@@ -12,17 +12,45 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int ZLIB_DEFLATE_FAILED;
+}
+
 /// Performs compression using zlib library and writes compressed data to out_ WriteBuffer.
 class ZlibDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 {
 public:
+    template<typename WriteBufferT>
     ZlibDeflatingWriteBuffer(
-            std::unique_ptr<WriteBuffer> out_,
+            WriteBufferT && out_,
             CompressionMethod compression_method,
             int compression_level,
             size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
             char * existing_memory = nullptr,
-            size_t alignment = 0);
+            size_t alignment = 0,
+            bool compress_empty_ = true)
+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), compress_empty(compress_empty_)
+    {
+        zstr.zalloc = nullptr;
+        zstr.zfree = nullptr;
+        zstr.opaque = nullptr;
+        zstr.next_in = nullptr;
+        zstr.avail_in = 0;
+        zstr.next_out = nullptr;
+        zstr.avail_out = 0;
+
+        int window_bits = 15;
+        if (compression_method == CompressionMethod::Gzip)
+        {
+            window_bits += 16;
+        }
+
+        int rc = deflateInit2(&zstr, compression_level, Z_DEFLATED, window_bits, 8, Z_DEFAULT_STRATEGY);
+
+        if (rc != Z_OK)
+            throw Exception(ErrorCodes::ZLIB_DEFLATE_FAILED, "deflateInit2 failed: {}; zlib version: {}", zError(rc), ZLIB_VERSION);
+    }
 
     ~ZlibDeflatingWriteBuffer() override;
 
@@ -36,6 +64,7 @@ class ZlibDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
     virtual void finalizeAfter() override;
 
     z_stream zstr;
+    bool compress_empty = true;
 };
 
 }
diff --git a/src/IO/ZstdDeflatingWriteBuffer.cpp b/src/IO/ZstdDeflatingWriteBuffer.cpp
index 949d65926b37..bad6e733cf1c 100644
--- a/src/IO/ZstdDeflatingWriteBuffer.cpp
+++ b/src/IO/ZstdDeflatingWriteBuffer.cpp
@@ -8,9 +8,7 @@ namespace ErrorCodes
     extern const int ZSTD_ENCODER_FAILED;
 }
 
-ZstdDeflatingWriteBuffer::ZstdDeflatingWriteBuffer(
-    std::unique_ptr<WriteBuffer> out_, int compression_level, size_t buf_size, char * existing_memory, size_t alignment)
-    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment)
+void ZstdDeflatingWriteBuffer::initialize(int compression_level)
 {
     cctx = ZSTD_createCCtx();
     if (cctx == nullptr)
@@ -44,6 +42,7 @@ void ZstdDeflatingWriteBuffer::flush(ZSTD_EndDirective mode)
 
     try
     {
+        size_t out_offset = out->offset();
         bool ended = false;
         do
         {
@@ -67,6 +66,8 @@ void ZstdDeflatingWriteBuffer::flush(ZSTD_EndDirective mode)
 
             ended = everything_was_compressed && everything_was_flushed;
         } while (!ended);
+
+        total_out += out->offset() - out_offset;
     }
     catch (...)
     {
@@ -84,6 +85,9 @@ void ZstdDeflatingWriteBuffer::nextImpl()
 
 void ZstdDeflatingWriteBuffer::finalizeBefore()
 {
+    /// Don't write out if no data was ever compressed
+    if (!compress_empty && total_out == 0)
+        return;
     flush(ZSTD_e_end);
 }
 
diff --git a/src/IO/ZstdDeflatingWriteBuffer.h b/src/IO/ZstdDeflatingWriteBuffer.h
index a66d6085a747..d25db515d28f 100644
--- a/src/IO/ZstdDeflatingWriteBuffer.h
+++ b/src/IO/ZstdDeflatingWriteBuffer.h
@@ -14,12 +14,18 @@ namespace DB
 class ZstdDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
 {
 public:
+    template<typename WriteBufferT>
     ZstdDeflatingWriteBuffer(
-        std::unique_ptr<WriteBuffer> out_,
+        WriteBufferT && out_,
         int compression_level,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
         char * existing_memory = nullptr,
-        size_t alignment = 0);
+        size_t alignment = 0,
+        bool compress_empty_ = true)
+    : WriteBufferWithOwnMemoryDecorator(std::move(out_), buf_size, existing_memory, alignment), compress_empty(compress_empty_)
+    {
+        initialize(compression_level);
+    }
 
     ~ZstdDeflatingWriteBuffer() override;
 
@@ -29,6 +35,8 @@ class ZstdDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
     }
 
 private:
+    void initialize(int compression_level);
+
     void nextImpl() override;
 
     /// Flush all pending data and write zstd footer to the underlying buffer.
@@ -42,6 +50,9 @@ class ZstdDeflatingWriteBuffer : public WriteBufferWithOwnMemoryDecorator
     ZSTD_CCtx * cctx;
     ZSTD_inBuffer input;
     ZSTD_outBuffer output;
+
+    size_t total_out = 0;
+    bool compress_empty = true;
 };
 
 }
diff --git a/src/Interpreters/Session.cpp b/src/Interpreters/Session.cpp
index 162772061b58..d2f9fe8b325e 100644
--- a/src/Interpreters/Session.cpp
+++ b/src/Interpreters/Session.cpp
@@ -112,8 +112,7 @@ class NamedSessionsStorage
                 throw Exception(ErrorCodes::SESSION_NOT_FOUND, "Session {} not found", session_id);
 
             /// Create a new session from current context.
-            auto context = Context::createCopy(global_context);
-            it = sessions.insert(std::make_pair(key, std::make_shared<NamedSessionData>(key, context, timeout, *this))).first;
+            it = sessions.insert(std::make_pair(key, std::make_shared<NamedSessionData>(key, global_context, timeout, *this))).first;
             const auto & session = it->second;
 
             if (!thread.joinable())
@@ -128,7 +127,7 @@ class NamedSessionsStorage
             /// Use existing session.
             const auto & session = it->second;
 
-            LOG_TEST(log, "Reuse session from storage with session_id: {}, user_id: {}", key.second, key.first);
+            LOG_TRACE(log, "Reuse session from storage with session_id: {}, user_id: {}", key.second, key.first);
 
             if (!session.unique())
                 throw Exception(ErrorCodes::SESSION_IS_LOCKED, "Session {} is locked by a concurrent client", session_id);
@@ -703,6 +702,10 @@ void Session::releaseSessionID()
 {
     if (!named_session)
         return;
+
+    prepared_client_info = getClientInfo();
+    session_context.reset();
+
     named_session->release();
     named_session = nullptr;
 }
diff --git a/src/Interpreters/Session.h b/src/Interpreters/Session.h
index 2249d8fbb2f9..75e1414b8cba 100644
--- a/src/Interpreters/Session.h
+++ b/src/Interpreters/Session.h
@@ -8,6 +8,7 @@
 
 #include <chrono>
 #include <memory>
+#include <mutex>
 #include <optional>
 
 namespace Poco::Net { class SocketAddress; }
diff --git a/src/Server/HTTP/HTTPRequestHandler.h b/src/Server/HTTP/HTTPRequestHandler.h
index 19340866bb7d..7902e86e3ed6 100644
--- a/src/Server/HTTP/HTTPRequestHandler.h
+++ b/src/Server/HTTP/HTTPRequestHandler.h
@@ -13,7 +13,8 @@ class HTTPRequestHandler : private boost::noncopyable
 public:
     virtual ~HTTPRequestHandler() = default;
 
-    virtual void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) = 0;
+    virtual void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) = 0;
+    virtual void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) { handleRequest(request, response, ProfileEvents::end()); }
 };
 
 }
diff --git a/src/Server/HTTP/HTTPServer.cpp b/src/Server/HTTP/HTTPServer.cpp
index 46734933263d..90bdebf6451d 100644
--- a/src/Server/HTTP/HTTPServer.cpp
+++ b/src/Server/HTTP/HTTPServer.cpp
@@ -10,8 +10,10 @@ HTTPServer::HTTPServer(
     HTTPRequestHandlerFactoryPtr factory_,
     Poco::ThreadPool & thread_pool,
     Poco::Net::ServerSocket & socket_,
-    Poco::Net::HTTPServerParams::Ptr params)
-    : TCPServer(new HTTPServerConnectionFactory(context, params, factory_), thread_pool, socket_, params), factory(factory_)
+    Poco::Net::HTTPServerParams::Ptr params,
+    const ProfileEvents::Event & read_event,
+    const ProfileEvents::Event & write_event)
+    : TCPServer(new HTTPServerConnectionFactory(context, params, factory_, read_event, write_event), thread_pool, socket_, params), factory(factory_)
 {
 }
 
diff --git a/src/Server/HTTP/HTTPServer.h b/src/Server/HTTP/HTTPServer.h
index adfb21e7c621..9911cde1b930 100644
--- a/src/Server/HTTP/HTTPServer.h
+++ b/src/Server/HTTP/HTTPServer.h
@@ -20,7 +20,9 @@ class HTTPServer : public TCPServer
         HTTPRequestHandlerFactoryPtr factory,
         Poco::ThreadPool & thread_pool,
         Poco::Net::ServerSocket & socket,
-        Poco::Net::HTTPServerParams::Ptr params);
+        Poco::Net::HTTPServerParams::Ptr params,
+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     ~HTTPServer() override;
 
diff --git a/src/Server/HTTP/HTTPServerConnection.cpp b/src/Server/HTTP/HTTPServerConnection.cpp
index 042f5e2e5dfa..047db0145602 100644
--- a/src/Server/HTTP/HTTPServerConnection.cpp
+++ b/src/Server/HTTP/HTTPServerConnection.cpp
@@ -11,8 +11,10 @@ HTTPServerConnection::HTTPServerConnection(
     TCPServer & tcp_server_,
     const Poco::Net::StreamSocket & socket,
     Poco::Net::HTTPServerParams::Ptr params_,
-    HTTPRequestHandlerFactoryPtr factory_)
-    : TCPServerConnection(socket), context(std::move(context_)), tcp_server(tcp_server_), params(params_), factory(factory_), stopped(false)
+    HTTPRequestHandlerFactoryPtr factory_,
+    const ProfileEvents::Event & read_event_,
+    const ProfileEvents::Event & write_event_)
+    : TCPServerConnection(socket), context(std::move(context_)), tcp_server(tcp_server_), params(params_), factory(factory_), read_event(read_event_), write_event(write_event_), stopped(false)
 {
     poco_check_ptr(factory);
 }
@@ -30,7 +32,7 @@ void HTTPServerConnection::run()
             if (!stopped && tcp_server.isOpen() && session.connected())
             {
                 HTTPServerResponse response(session);
-                HTTPServerRequest request(context, response, session);
+                HTTPServerRequest request(context, response, session, read_event);
 
                 Poco::Timestamp now;
 
@@ -65,7 +67,7 @@ void HTTPServerConnection::run()
                         if (request.getExpectContinue() && response.getStatus() == Poco::Net::HTTPResponse::HTTP_OK)
                             response.sendContinue();
 
-                        handler->handleRequest(request, response);
+                        handler->handleRequest(request, response, write_event);
                         session.setKeepAlive(params->getKeepAlive() && response.getKeepAlive() && session.canKeepAlive());
                     }
                     else
diff --git a/src/Server/HTTP/HTTPServerConnection.h b/src/Server/HTTP/HTTPServerConnection.h
index 7087f8d5a216..c6b1dc1ba255 100644
--- a/src/Server/HTTP/HTTPServerConnection.h
+++ b/src/Server/HTTP/HTTPServerConnection.h
@@ -19,7 +19,9 @@ class HTTPServerConnection : public Poco::Net::TCPServerConnection
         TCPServer & tcp_server,
         const Poco::Net::StreamSocket & socket,
         Poco::Net::HTTPServerParams::Ptr params,
-        HTTPRequestHandlerFactoryPtr factory);
+        HTTPRequestHandlerFactoryPtr factory,
+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     HTTPServerConnection(
         HTTPContextPtr context_,
@@ -27,8 +29,10 @@ class HTTPServerConnection : public Poco::Net::TCPServerConnection
         const Poco::Net::StreamSocket & socket_,
         Poco::Net::HTTPServerParams::Ptr params_,
         HTTPRequestHandlerFactoryPtr factory_,
-        const String & forwarded_for_)
-    : HTTPServerConnection(context_, tcp_server_, socket_, params_, factory_)
+        const String & forwarded_for_,
+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end())
+    : HTTPServerConnection(context_, tcp_server_, socket_, params_, factory_, read_event_, write_event_)
     {
         forwarded_for = forwarded_for_;
     }
@@ -44,6 +48,8 @@ class HTTPServerConnection : public Poco::Net::TCPServerConnection
     Poco::Net::HTTPServerParams::Ptr params;
     HTTPRequestHandlerFactoryPtr factory;
     String forwarded_for;
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
     bool stopped;
     std::mutex mutex;  // guards the |factory| with assumption that creating handlers is not thread-safe.
 };
diff --git a/src/Server/HTTP/HTTPServerConnectionFactory.cpp b/src/Server/HTTP/HTTPServerConnectionFactory.cpp
index 2c9ac0cda2ab..16e5160fe3f0 100644
--- a/src/Server/HTTP/HTTPServerConnectionFactory.cpp
+++ b/src/Server/HTTP/HTTPServerConnectionFactory.cpp
@@ -5,20 +5,20 @@
 namespace DB
 {
 HTTPServerConnectionFactory::HTTPServerConnectionFactory(
-    HTTPContextPtr context_, Poco::Net::HTTPServerParams::Ptr params_, HTTPRequestHandlerFactoryPtr factory_)
-    : context(std::move(context_)), params(params_), factory(factory_)
+    HTTPContextPtr context_, Poco::Net::HTTPServerParams::Ptr params_, HTTPRequestHandlerFactoryPtr factory_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)
+    : context(std::move(context_)), params(params_), factory(factory_), read_event(read_event_), write_event(write_event_)
 {
     poco_check_ptr(factory);
 }
 
 Poco::Net::TCPServerConnection * HTTPServerConnectionFactory::createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server)
 {
-    return new HTTPServerConnection(context, tcp_server, socket, params, factory);
+    return new HTTPServerConnection(context, tcp_server, socket, params, factory, read_event, write_event);
 }
 
 Poco::Net::TCPServerConnection * HTTPServerConnectionFactory::createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server, TCPProtocolStackData & stack_data)
 {
-    return new HTTPServerConnection(context, tcp_server, socket, params, factory, stack_data.forwarded_for);
+    return new HTTPServerConnection(context, tcp_server, socket, params, factory, stack_data.forwarded_for, read_event, write_event);
 }
 
 }
diff --git a/src/Server/HTTP/HTTPServerConnectionFactory.h b/src/Server/HTTP/HTTPServerConnectionFactory.h
index e18249da4ded..4b785e31744b 100644
--- a/src/Server/HTTP/HTTPServerConnectionFactory.h
+++ b/src/Server/HTTP/HTTPServerConnectionFactory.h
@@ -12,7 +12,7 @@ namespace DB
 class HTTPServerConnectionFactory : public TCPServerConnectionFactory
 {
 public:
-    HTTPServerConnectionFactory(HTTPContextPtr context, Poco::Net::HTTPServerParams::Ptr params, HTTPRequestHandlerFactoryPtr factory);
+    HTTPServerConnectionFactory(HTTPContextPtr context, Poco::Net::HTTPServerParams::Ptr params, HTTPRequestHandlerFactoryPtr factory, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server) override;
     Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & tcp_server, TCPProtocolStackData & stack_data) override;
@@ -21,6 +21,8 @@ class HTTPServerConnectionFactory : public TCPServerConnectionFactory
     HTTPContextPtr context;
     Poco::Net::HTTPServerParams::Ptr params;
     HTTPRequestHandlerFactoryPtr factory;
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
 };
 
 }
diff --git a/src/Server/HTTP/HTTPServerRequest.cpp b/src/Server/HTTP/HTTPServerRequest.cpp
index de5dde3c4aa6..4a6e85ba0fba 100644
--- a/src/Server/HTTP/HTTPServerRequest.cpp
+++ b/src/Server/HTTP/HTTPServerRequest.cpp
@@ -22,7 +22,7 @@
 
 namespace DB
 {
-HTTPServerRequest::HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session)
+HTTPServerRequest::HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session, const ProfileEvents::Event & read_event)
     : max_uri_size(context->getMaxUriSize())
     , max_fields_number(context->getMaxFields())
     , max_field_name_size(context->getMaxFieldNameSize())
@@ -41,7 +41,7 @@ HTTPServerRequest::HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse
     session.socket().setReceiveTimeout(receive_timeout);
     session.socket().setSendTimeout(send_timeout);
 
-    auto in = std::make_unique<ReadBufferFromPocoSocket>(session.socket());
+    auto in = std::make_unique<ReadBufferFromPocoSocket>(session.socket(), read_event);
     socket = session.socket().impl();
 
     readRequest(*in);  /// Try parse according to RFC7230
diff --git a/src/Server/HTTP/HTTPServerRequest.h b/src/Server/HTTP/HTTPServerRequest.h
index 1f38334c7453..aaec89ab7571 100644
--- a/src/Server/HTTP/HTTPServerRequest.h
+++ b/src/Server/HTTP/HTTPServerRequest.h
@@ -4,6 +4,7 @@
 #include <IO/ReadBuffer.h>
 #include <Server/HTTP/HTTPRequest.h>
 #include <Server/HTTP/HTTPContext.h>
+#include <Common/ProfileEvents.h>
 #include "config.h"
 
 #include <Poco/Net/HTTPServerSession.h>
@@ -19,7 +20,7 @@ class ReadBufferFromPocoSocket;
 class HTTPServerRequest : public HTTPRequest
 {
 public:
-    HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session);
+    HTTPServerRequest(HTTPContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session, const ProfileEvents::Event & read_event = ProfileEvents::end());
 
     /// FIXME: it's a little bit inconvenient interface. The rationale is that all other ReadBuffer's wrap each other
     ///        via unique_ptr - but we can't inherit HTTPServerRequest from ReadBuffer and pass it around,
diff --git a/src/Server/HTTP/HTTPServerResponse.cpp b/src/Server/HTTP/HTTPServerResponse.cpp
index 25e7604a515e..3c2d54a67dfc 100644
--- a/src/Server/HTTP/HTTPServerResponse.cpp
+++ b/src/Server/HTTP/HTTPServerResponse.cpp
@@ -9,12 +9,15 @@
 #include <Poco/Net/HTTPHeaderStream.h>
 #include <Poco/Net/HTTPStream.h>
 #include <Poco/StreamCopier.h>
+#include <sstream>
 
 
 namespace DB
 {
 
-HTTPServerResponse::HTTPServerResponse(Poco::Net::HTTPServerSession & session_) : session(session_)
+HTTPServerResponse::HTTPServerResponse(Poco::Net::HTTPServerSession & session_, const ProfileEvents::Event & write_event_)
+    : session(session_)
+    , write_event(write_event_)
 {
 }
 
@@ -24,42 +27,45 @@ void HTTPServerResponse::sendContinue()
     hs << getVersion() << " 100 Continue\r
\r
";
 }
 
-std::shared_ptr<std::ostream> HTTPServerResponse::send()
+std::shared_ptr<WriteBufferFromPocoSocket> HTTPServerResponse::send()
 {
     poco_assert(!stream);
 
     if ((request && request->getMethod() == HTTPRequest::HTTP_HEAD) || getStatus() < 200 || getStatus() == HTTPResponse::HTTP_NO_CONTENT
         || getStatus() == HTTPResponse::HTTP_NOT_MODIFIED)
     {
-        Poco::CountingOutputStream cs;
-        write(cs);
-        stream = std::make_shared<Poco::Net::HTTPFixedLengthOutputStream>(session, cs.chars());
-        write(*stream);
+        // Send header
+        Poco::Net::HTTPHeaderOutputStream hs(session);
+        write(hs);
+        stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event);
     }
     else if (getChunkedTransferEncoding())
     {
+        // Send header
         Poco::Net::HTTPHeaderOutputStream hs(session);
         write(hs);
-        stream = std::make_shared<Poco::Net::HTTPChunkedOutputStream>(session);
+        stream = std::make_shared<HTTPWriteBufferChunked>(session.socket(), write_event);
     }
     else if (hasContentLength())
     {
-        Poco::CountingOutputStream cs;
-        write(cs);
-        stream = std::make_shared<Poco::Net::HTTPFixedLengthOutputStream>(session, getContentLength64() + cs.chars());
-        write(*stream);
+        // Send header
+        Poco::Net::HTTPHeaderOutputStream hs(session);
+        write(hs);
+        stream = std::make_shared<HTTPWriteBufferFixedLength>(session.socket(), getContentLength(), write_event);
     }
     else
     {
-        stream = std::make_shared<Poco::Net::HTTPOutputStream>(session);
         setKeepAlive(false);
-        write(*stream);
+        // Send header
+        Poco::Net::HTTPHeaderOutputStream hs(session);
+        write(hs);
+        stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event);
     }
 
     return stream;
 }
 
-std::pair<std::shared_ptr<std::ostream>, std::shared_ptr<std::ostream>> HTTPServerResponse::beginSend()
+std::pair<std::shared_ptr<WriteBufferFromPocoSocket>, std::shared_ptr<WriteBufferFromPocoSocket>> HTTPServerResponse::beginSend()
 {
     poco_assert(!stream);
     poco_assert(!header_stream);
@@ -71,40 +77,39 @@ std::pair<std::shared_ptr<std::ostream>, std::shared_ptr<std::ostream>> HTTPServ
     {
         throw Poco::Exception("HTTPServerResponse::beginSend is invalid for HEAD request");
     }
-    else if (getChunkedTransferEncoding())
-    {
-        header_stream = std::make_shared<Poco::Net::HTTPHeaderOutputStream>(session);
-        beginWrite(*header_stream);
-        stream = std::make_shared<Poco::Net::HTTPChunkedOutputStream>(session);
-    }
-    else if (hasContentLength())
+
+    if (hasContentLength())
     {
         throw Poco::Exception("HTTPServerResponse::beginSend is invalid for response with Content-Length header");
     }
+
+    // Write header to buffer
+    std::stringstream header; //STYLE_CHECK_ALLOW_STD_STRING_STREAM
+    beginWrite(header);
+    // Send header
+    auto str = header.str();
+    header_stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event, str.size());
+    header_stream->write(str);
+
+    if (getChunkedTransferEncoding())
+        stream = std::make_shared<HTTPWriteBufferChunked>(session.socket(), write_event);
     else
-    {
-        stream = std::make_shared<Poco::Net::HTTPOutputStream>(session);
-        header_stream = stream;
-        setKeepAlive(false);
-        beginWrite(*stream);
-    }
+        stream = std::make_shared<WriteBufferFromPocoSocket>(session.socket(), write_event);
 
     return std::make_pair(header_stream, stream);
 }
 
 void HTTPServerResponse::sendBuffer(const void * buffer, std::size_t length)
 {
-    poco_assert(!stream);
-
     setContentLength(static_cast<int>(length));
     setChunkedTransferEncoding(false);
+    // Send header
+    Poco::Net::HTTPHeaderOutputStream hs(session);
+    write(hs);
+    hs.flush();
 
-    stream = std::make_shared<Poco::Net::HTTPHeaderOutputStream>(session);
-    write(*stream);
     if (request && request->getMethod() != HTTPRequest::HTTP_HEAD)
-    {
-        stream->write(static_cast<const char *>(buffer), static_cast<std::streamsize>(length));
-    }
+        WriteBufferFromPocoSocket(session.socket(), write_event).write(static_cast<const char *>(buffer), length);
 }
 
 void HTTPServerResponse::requireAuthentication(const std::string & realm)
diff --git a/src/Server/HTTP/HTTPServerResponse.h b/src/Server/HTTP/HTTPServerResponse.h
index 236a56e2323f..6efe48667ebf 100644
--- a/src/Server/HTTP/HTTPServerResponse.h
+++ b/src/Server/HTTP/HTTPServerResponse.h
@@ -1,9 +1,12 @@
 #pragma once
 
+#include <IO/WriteBufferFromPocoSocket.h>
 #include <Server/HTTP/HTTPResponse.h>
 
 #include <Poco/Net/HTTPServerSession.h>
 #include <Poco/Net/HTTPResponse.h>
+#include <Poco/Net/StreamSocket.h>
+#include <Poco/NumberFormatter.h>
 
 #include <memory>
 
@@ -11,12 +14,182 @@
 namespace DB
 {
 
+
+class HTTPWriteBufferChunked : public WriteBufferFromPocoSocket
+{
+    using WriteBufferFromPocoSocket::WriteBufferFromPocoSocket;
+protected:
+    void nextImpl() override
+    {
+        if (offset() == 0)
+            return;
+
+        std::string chunk_header;
+        Poco::NumberFormatter::appendHex(chunk_header, offset());
+        chunk_header.append("\r
", 2);
+        socketSendBytes(chunk_header.data(), static_cast<int>(chunk_header.size()));
+        WriteBufferFromPocoSocket::nextImpl();
+        socketSendBytes("\r
", 2);
+    }
+
+    void finalizeImpl() override
+    {
+        WriteBufferFromPocoSocket::finalizeImpl();
+        socketSendBytes("0\r
\r
", 5);
+    }
+};
+
+class HTTPWriteBufferFixedLength : public WriteBufferFromPocoSocket
+{
+public:
+    explicit HTTPWriteBufferFixedLength(Poco::Net::Socket & socket_, size_t fixed_length_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+        : WriteBufferFromPocoSocket(socket_, buf_size)
+    {
+        fixed_length = fixed_length_;
+    }
+    explicit HTTPWriteBufferFixedLength(Poco::Net::Socket & socket_, size_t fixed_length_, const ProfileEvents::Event & write_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+        : WriteBufferFromPocoSocket(socket_, write_event_, buf_size)
+    {
+        fixed_length = fixed_length_;
+    }
+protected:
+    void nextImpl() override
+    {
+        if (count_length >= fixed_length || offset() == 0)
+            return;
+
+        if (count_length + offset() > fixed_length)
+            pos -= offset() - (fixed_length - count_length);
+
+        count_length += offset();
+
+        WriteBufferFromPocoSocket::nextImpl();
+    }
+private:
+    size_t fixed_length;
+    size_t count_length = 0;
+};
+
+/// Universal HTTP buffer, can be switched for different Transfer-Encoding/Content-Length on the fly
+/// so it can be used to output HTTP header and then switched to appropriate mode for body
+class HTTPWriteBuffer : public WriteBufferFromPocoSocket
+{
+public:
+    explicit HTTPWriteBuffer(Poco::Net::Socket & socket_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+        : WriteBufferFromPocoSocket(socket_, buf_size)
+    {
+    }
+    explicit HTTPWriteBuffer(Poco::Net::Socket & socket_, const ProfileEvents::Event & write_event_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+        : WriteBufferFromPocoSocket(socket_, write_event_, buf_size)
+    {
+    }
+
+    void setChunked(size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+    {
+        chunked = true;
+        resizeIfNeeded(buf_size);
+    }
+
+    bool isChunked()
+    {
+        return chunked;
+    }
+
+    void setFixedLength(size_t length)
+    {
+        chunked = false;
+        fixed_length = length;
+        count_length = 0;
+        resizeIfNeeded(length);
+    }
+
+    size_t isFixedLength()
+    {
+        return chunked ? 0 : fixed_length;
+    }
+
+    void setPlain(size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+    {
+        chunked = false;
+        fixed_length = 0;
+        count_length = 0;
+        resizeIfNeeded(buf_size);
+    }
+
+    bool isPlain()
+    {
+        return !(isChunked() || isFixedLength());
+    }
+
+protected:
+    void finalizeImpl() override
+    {
+        WriteBufferFromPocoSocket::finalizeImpl();
+        if (chunked)
+            socketSendBytes("0\r
\r
", 5);
+    }
+
+    void nextImpl() override
+    {
+        if (chunked)
+            return nextImplChunked();
+
+        if (fixed_length)
+            return nextImplFixedLength();
+
+        WriteBufferFromPocoSocket::nextImpl();
+    }
+
+    void nextImplFixedLength()
+    {
+        if (count_length >= fixed_length || offset() == 0)
+            return;
+
+        if (count_length + offset() > fixed_length)
+            pos -= offset() - (fixed_length - count_length);
+
+        count_length += offset();
+
+        WriteBufferFromPocoSocket::nextImpl();
+    }
+
+    void nextImplChunked()
+    {
+        if (offset() == 0)
+            return;
+
+        std::string chunk_header;
+        Poco::NumberFormatter::appendHex(chunk_header, offset());
+        chunk_header.append("\r
", 2);
+        socketSendBytes(chunk_header.data(), static_cast<int>(chunk_header.size()));
+        WriteBufferFromPocoSocket::nextImpl();
+        socketSendBytes("\r
", 2);
+    }
+
+    void resizeIfNeeded(size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE)
+    {
+        if (!buf_size)
+            return;
+
+        auto data_size = offset();
+        assert(data_size <= buf_size);
+
+        memory.resize(buf_size);
+        set(memory.data(), memory.size(), data_size);
+    }
+private:
+    bool chunked = false;
+    size_t fixed_length = 0;
+    size_t count_length = 0;
+};
+
+
 class HTTPServerRequest;
 
 class HTTPServerResponse : public HTTPResponse
 {
 public:
-    explicit HTTPServerResponse(Poco::Net::HTTPServerSession & session);
+    explicit HTTPServerResponse(Poco::Net::HTTPServerSession & session, const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     void sendContinue(); /// Sends a 100 Continue response to the client.
 
@@ -26,7 +199,7 @@ class HTTPServerResponse : public HTTPResponse
     ///
     /// Must not be called after beginSend(), sendFile(), sendBuffer()
     /// or redirect() has been called.
-    std::shared_ptr<std::ostream> send(); /// TODO: use some WriteBuffer implementation here.
+    std::shared_ptr<WriteBufferFromPocoSocket> send();
 
     /// Sends the response headers to the client
     /// but do not finish headers with \r
,
@@ -34,7 +207,7 @@ class HTTPServerResponse : public HTTPResponse
     ///
     /// Must not be called after send(), sendFile(), sendBuffer()
     /// or redirect() has been called.
-    std::pair<std::shared_ptr<std::ostream>, std::shared_ptr<std::ostream>> beginSend(); /// TODO: use some WriteBuffer implementation here.
+    std::pair<std::shared_ptr<WriteBufferFromPocoSocket>, std::shared_ptr<WriteBufferFromPocoSocket>> beginSend();
 
     /// Sends the response header to the client, followed
     /// by the contents of the given buffer.
@@ -58,13 +231,16 @@ class HTTPServerResponse : public HTTPResponse
     /// Returns true if the response (header) has been sent.
     bool sent() const { return !!stream; }
 
+    Poco::Net::StreamSocket & getSocket() { return session.socket(); }
+
     void attachRequest(HTTPServerRequest * request_) { request = request_; }
 
 private:
     Poco::Net::HTTPServerSession & session;
     HTTPServerRequest * request = nullptr;
-    std::shared_ptr<std::ostream> stream;
-    std::shared_ptr<std::ostream> header_stream;
+    ProfileEvents::Event write_event;
+    std::shared_ptr<WriteBufferFromPocoSocket> stream;
+    std::shared_ptr<WriteBufferFromPocoSocket> header_stream;
 };
 
 }
diff --git a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp
index 1a12c09a8c7b..07b87c3ae969 100644
--- a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp
+++ b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.cpp
@@ -1,17 +1,15 @@
 #include <Server/HTTP/WriteBufferFromHTTPServerResponse.h>
-
 #include <IO/HTTPCommon.h>
 #include <IO/Progress.h>
 #include <IO/WriteBufferFromString.h>
 #include <IO/WriteHelpers.h>
+#include <memory>
+#include <sstream>
+#include <string>
 
 namespace DB
 {
 
-namespace ErrorCodes
-{
-}
-
 
 void WriteBufferFromHTTPServerResponse::startSendHeaders()
 {
@@ -19,27 +17,33 @@ void WriteBufferFromHTTPServerResponse::startSendHeaders()
     {
         headers_started_sending = true;
 
+        if (response.getChunkedTransferEncoding())
+            setChunked();
+
         if (add_cors_header)
             response.set("Access-Control-Allow-Origin", "*");
 
         setResponseDefaultHeaders(response, keep_alive_timeout);
 
-        if (!is_http_method_head)
-            std::tie(response_header_ostr, response_body_ostr) = response.beginSend();
+        std::stringstream header; //STYLE_CHECK_ALLOW_STD_STRING_STREAM
+        response.beginWrite(header);
+        auto header_str = header.str();
+        socketSendBytes(header_str.data(), header_str.size());
     }
 }
 
 void WriteBufferFromHTTPServerResponse::writeHeaderProgressImpl(const char * header_name)
 {
-    if (headers_finished_sending)
+    if (is_http_method_head || headers_finished_sending || !headers_started_sending)
         return;
 
     WriteBufferFromOwnString progress_string_writer;
 
     accumulated_progress.writeJSON(progress_string_writer);
 
-    if (response_header_ostr)
-        *response_header_ostr << header_name << progress_string_writer.str() << "\r
" << std::flush;
+    socketSendBytes(header_name, strlen(header_name));
+    socketSendBytes(progress_string_writer.str().data(), progress_string_writer.str().size());
+    socketSendBytes("\r
", 2);
 }
 
 void WriteBufferFromHTTPServerResponse::writeHeaderSummary()
@@ -57,30 +61,30 @@ void WriteBufferFromHTTPServerResponse::writeExceptionCode()
 {
     if (headers_finished_sending || !exception_code)
         return;
-    if (response_header_ostr)
-        *response_header_ostr << "X-ClickHouse-Exception-Code: " << exception_code << "\r
" << std::flush;
+    if (headers_started_sending)
+    {
+        socketSendBytes("X-ClickHouse-Exception-Code: ", sizeof("X-ClickHouse-Exception-Code: ") - 1);
+        auto str_code = std::to_string(exception_code);
+        socketSendBytes(str_code.data(), str_code.size());
+        socketSendBytes("\r
", 2);
+    }
 }
 
 void WriteBufferFromHTTPServerResponse::finishSendHeaders()
 {
-    if (!headers_finished_sending)
-    {
-        writeHeaderSummary();
-        writeExceptionCode();
-        headers_finished_sending = true;
-
-        if (!is_http_method_head)
-        {
-            /// Send end of headers delimiter.
-            if (response_header_ostr)
-                *response_header_ostr << "\r
" << std::flush;
-        }
-        else
-        {
-            if (!response_body_ostr)
-                response_body_ostr = response.send();
-        }
-    }
+    if (headers_finished_sending)
+        return;
+
+    if (!headers_started_sending)
+        startSendHeaders();
+
+    writeHeaderSummary();
+    writeExceptionCode();
+
+    headers_finished_sending = true;
+
+    /// Send end of headers delimiter.
+    socketSendBytes("\r
", 2);
 }
 
 
@@ -89,47 +93,19 @@ void WriteBufferFromHTTPServerResponse::nextImpl()
     if (!initialized)
     {
         std::lock_guard lock(mutex);
-
         /// Initialize as early as possible since if the code throws,
         /// next() should not be called anymore.
         initialized = true;
 
-        startSendHeaders();
-
-        if (!out && !is_http_method_head)
-        {
-            if (compress)
-            {
-                auto content_encoding_name = toContentEncodingName(compression_method);
-
-                *response_header_ostr << "Content-Encoding: " << content_encoding_name << "\r
";
-            }
-
-            /// We reuse our buffer in "out" to avoid extra allocations and copies.
-
-            if (compress)
-                out = wrapWriteBufferWithCompressionMethod(
-                    std::make_unique<WriteBufferFromOStream>(*response_body_ostr),
-                    compress ? compression_method : CompressionMethod::None,
-                    compression_level,
-                    working_buffer.size(),
-                    working_buffer.begin());
-            else
-                out = std::make_unique<WriteBufferFromOStream>(
-                    *response_body_ostr,
-                    working_buffer.size(),
-                    working_buffer.begin());
-        }
+        if (compression_method != CompressionMethod::None)
+            response.set("Content-Encoding", toContentEncodingName(compression_method));
 
+        startSendHeaders();
         finishSendHeaders();
     }
 
-    if (out)
-    {
-        out->buffer() = buffer();
-        out->position() = position();
-        out->next();
-    }
+    if (!is_http_method_head)
+        HTTPWriteBuffer::nextImpl();
 }
 
 
@@ -137,14 +113,11 @@ WriteBufferFromHTTPServerResponse::WriteBufferFromHTTPServerResponse(
     HTTPServerResponse & response_,
     bool is_http_method_head_,
     UInt64 keep_alive_timeout_,
-    bool compress_,
-    CompressionMethod compression_method_)
-    : BufferWithOwnMemory<WriteBuffer>(DBMS_DEFAULT_BUFFER_SIZE)
+    const ProfileEvents::Event & write_event_)
+    : HTTPWriteBuffer(response_.getSocket(), write_event_)
     , response(response_)
     , is_http_method_head(is_http_method_head_)
     , keep_alive_timeout(keep_alive_timeout_)
-    , compress(compress_)
-    , compression_method(compression_method_)
 {
 }
 
@@ -169,6 +142,15 @@ void WriteBufferFromHTTPServerResponse::onProgress(const Progress & progress)
     }
 }
 
+void WriteBufferFromHTTPServerResponse::setExceptionCode(int exception_code_)
+{
+    std::lock_guard lock(mutex);
+    if (headers_started_sending)
+        exception_code = exception_code_;
+    else
+        response.set("X-ClickHouse-Exception-Code", toString<int>(exception_code_));
+}
+
 WriteBufferFromHTTPServerResponse::~WriteBufferFromHTTPServerResponse()
 {
     finalize();
@@ -176,30 +158,20 @@ WriteBufferFromHTTPServerResponse::~WriteBufferFromHTTPServerResponse()
 
 void WriteBufferFromHTTPServerResponse::finalizeImpl()
 {
-    try
-    {
-        next();
-        if (out)
-            out->finalize();
-        out.reset();
-        /// Catch write-after-finalize bugs.
-        set(nullptr, 0);
-    }
-    catch (...)
-    {
-        /// Avoid calling WriteBufferFromOStream::next() from dtor
-        /// (via WriteBufferFromHTTPServerResponse::next())
-        out.reset();
-        throw;
-    }
-
-    if (!offset())
+    if (!headers_finished_sending)
     {
-        /// If no remaining data, just send headers.
         std::lock_guard lock(mutex);
+        /// If no body data just send header
         startSendHeaders();
+
+        if (!initialized && offset() && compression_method != CompressionMethod::None)
+            socketSendStr("Content-Encoding: " + toContentEncodingName(compression_method) + "\r
");
+
         finishSendHeaders();
     }
+
+    if (!is_http_method_head)
+        HTTPWriteBuffer::finalizeImpl();
 }
 
 
diff --git a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h
index 38345f279526..a3952b7c5538 100644
--- a/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h
+++ b/src/Server/HTTP/WriteBufferFromHTTPServerResponse.h
@@ -5,8 +5,8 @@
 #include <IO/HTTPCommon.h>
 #include <IO/Progress.h>
 #include <IO/WriteBuffer.h>
-#include <IO/WriteBufferFromOStream.h>
 #include <Server/HTTP/HTTPServerResponse.h>
+#include <Poco/Net/StreamSocket.h>
 #include <Common/NetException.h>
 #include <Common/Stopwatch.h>
 
@@ -17,48 +17,26 @@
 namespace DB
 {
 
-/// The difference from WriteBufferFromOStream is that this buffer gets the underlying std::ostream
-/// (using response.send()) only after data is flushed for the first time. This is needed in HTTP
-/// servers to change some HTTP headers (e.g. response code) before any data is sent to the client
-/// (headers can't be changed after response.send() is called).
-///
-/// In short, it allows delaying the call to response.send().
-///
-/// Additionally, supports HTTP response compression (in this case corresponding Content-Encoding
-/// header will be set).
+/// Postpone sending HTTP header until first data is flushed. This is needed in HTTP servers
+///  to change some HTTP headers (e.g. response code) before any data is sent to the client.
 ///
 /// Also this class write and flush special X-ClickHouse-Progress HTTP headers
 ///  if no data was sent at the time of progress notification.
 /// This allows to implement progress bar in HTTP clients.
-class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<WriteBuffer>
+class WriteBufferFromHTTPServerResponse final : public HTTPWriteBuffer
 {
 public:
     WriteBufferFromHTTPServerResponse(
         HTTPServerResponse & response_,
         bool is_http_method_head_,
         UInt64 keep_alive_timeout_,
-        bool compress_ = false,        /// If true - set Content-Encoding header and compress the result.
-        CompressionMethod compression_method_ = CompressionMethod::None);
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     ~WriteBufferFromHTTPServerResponse() override;
 
     /// Writes progress in repeating HTTP headers.
     void onProgress(const Progress & progress);
 
-    /// Turn compression on or off.
-    /// The setting has any effect only if HTTP headers haven't been sent yet.
-    void setCompression(bool enable_compression)
-    {
-        compress = enable_compression;
-    }
-
-    /// Set compression level if the compression is turned on.
-    /// The setting has any effect only if HTTP headers haven't been sent yet.
-    void setCompressionLevel(int level)
-    {
-        compression_level = level;
-    }
-
     /// Turn CORS on or off.
     /// The setting has any effect only if HTTP headers haven't been sent yet.
     void addHeaderCORS(bool enable_cors)
@@ -75,7 +53,13 @@ class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<Write
         send_progress_interval_ms = send_progress_interval_ms_;
     }
 
-    void setExceptionCode(int exception_code_) { exception_code = exception_code_; }
+    /// Content-Encoding header will be set on first data package
+    void setCompressionMethodHeader(const CompressionMethod & compression_method_)
+    {
+        compression_method = compression_method_;
+    }
+
+    void setExceptionCode(int exception_code_);
 
 private:
     /// Send at least HTTP headers if no data has been sent yet.
@@ -108,14 +92,7 @@ class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<Write
     bool is_http_method_head;
     bool add_cors_header = false;
     size_t keep_alive_timeout = 0;
-    bool compress = false;
-    CompressionMethod compression_method;
-    int compression_level = 1;
-
-    std::shared_ptr<std::ostream> response_body_ostr;
-    std::shared_ptr<std::ostream> response_header_ostr;
 
-    std::unique_ptr<WriteBuffer> out;
     bool initialized = false;
 
     bool headers_started_sending = false;
@@ -126,6 +103,8 @@ class WriteBufferFromHTTPServerResponse final : public BufferWithOwnMemory<Write
     size_t send_progress_interval_ms = 100;
     Stopwatch progress_watch;
 
+    CompressionMethod compression_method = CompressionMethod::None;
+
     int exception_code = 0;
 
     std::mutex mutex;    /// progress callback could be called from different threads.
diff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp
index f53c0094ef76..224cc3030769 100644
--- a/src/Server/HTTPHandler.cpp
+++ b/src/Server/HTTPHandler.cpp
@@ -46,7 +46,9 @@
 #include <Poco/String.h>
 #include <Poco/Net/SocketAddress.h>
 
+#include <algorithm>
 #include <chrono>
+#include <memory>
 #include <sstream>
 
 #ifdef __clang__
@@ -301,7 +303,7 @@ void HTTPHandler::pushDelayedResults(Output & used_output)
     std::vector<WriteBufferPtr> write_buffers;
     ConcatReadBuffer::Buffers read_buffers;
 
-    auto * cascade_buffer = typeid_cast<CascadeWriteBuffer *>(used_output.out_maybe_delayed_and_compressed.get());
+    auto * cascade_buffer = typeid_cast<CascadeWriteBuffer *>(used_output.out_maybe_delayed_and_compressed);
     if (!cascade_buffer)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Expected CascadeWriteBuffer");
 
@@ -553,7 +555,8 @@ void HTTPHandler::processQuery(
     HTMLForm & params,
     HTTPServerResponse & response,
     Output & used_output,
-    std::optional<CurrentThread::QueryScope> & query_scope)
+    std::optional<CurrentThread::QueryScope> & query_scope,
+    const ProfileEvents::Event & write_event)
 {
     using namespace Poco::Net;
 
@@ -564,6 +567,9 @@ void HTTPHandler::processQuery(
 
     /// The user could specify session identifier and session timeout.
     /// It allows to modify settings, create temporary tables and reuse them in subsequent requests.
+
+    SCOPE_EXIT({ session->releaseSessionID(); });
+
     String session_id;
     std::chrono::steady_clock::duration session_timeout;
     bool session_is_set = params.has("session_id");
@@ -616,15 +622,35 @@ void HTTPHandler::processQuery(
     size_t buffer_size_http = DBMS_DEFAULT_BUFFER_SIZE;
     size_t buffer_size_memory = (buffer_size_total > buffer_size_http) ? buffer_size_total : 0;
 
-    used_output.out = std::make_shared<WriteBufferFromHTTPServerResponse>(
-        response,
-        request.getMethod() == HTTPRequest::HTTP_HEAD,
-        context->getServerSettings().keep_alive_timeout.totalSeconds(),
-        client_supports_http_compression,
-        http_response_compression_method);
+    bool enable_http_compression = params.getParsed<bool>("enable_http_compression", context->getSettingsRef().enable_http_compression);
+    Int64 http_zlib_compression_level = params.getParsed<Int64>("http_zlib_compression_level", context->getSettingsRef().http_zlib_compression_level);
+
+    used_output.out_holder =
+        std::make_shared<WriteBufferFromHTTPServerResponse>(
+            response,
+            request.getMethod() == HTTPRequest::HTTP_HEAD,
+            context->getServerSettings().keep_alive_timeout.totalSeconds(),
+            write_event);
+    used_output.out = used_output.out_holder;
+    used_output.out_maybe_compressed = used_output.out_holder;
+
+    if (client_supports_http_compression && enable_http_compression)
+    {
+        used_output.out_holder->setCompressionMethodHeader(http_response_compression_method);
+        used_output.wrap_compressed_holder =
+            wrapWriteBufferWithCompressionMethod(
+                used_output.out_holder.get(),
+                http_response_compression_method,
+                static_cast<int>(http_zlib_compression_level),
+                DBMS_DEFAULT_BUFFER_SIZE, nullptr, 0, false);
+        used_output.out = used_output.wrap_compressed_holder;
+    }
 
     if (internal_compression)
-        used_output.out_maybe_compressed = std::make_shared<CompressedWriteBuffer>(*used_output.out);
+    {
+        used_output.out_compressed_holder = std::make_shared<CompressedWriteBuffer>(*used_output.out);
+        used_output.out_maybe_compressed = used_output.out_compressed_holder;
+    }
     else
         used_output.out_maybe_compressed = used_output.out;
 
@@ -664,12 +690,12 @@ void HTTPHandler::processQuery(
             cascade_buffer2.emplace_back(push_memory_buffer_and_continue);
         }
 
-        used_output.out_maybe_delayed_and_compressed = std::make_shared<CascadeWriteBuffer>(
-            std::move(cascade_buffer1), std::move(cascade_buffer2));
+        used_output.out_delayed_and_compressed_holder = std::make_unique<CascadeWriteBuffer>(std::move(cascade_buffer1), std::move(cascade_buffer2));
+        used_output.out_maybe_delayed_and_compressed = used_output.out_delayed_and_compressed_holder.get();
     }
     else
     {
-        used_output.out_maybe_delayed_and_compressed = used_output.out_maybe_compressed;
+        used_output.out_maybe_delayed_and_compressed = used_output.out_maybe_compressed.get();
     }
 
     /// Request body can be compressed using algorithm specified in the Content-Encoding header.
@@ -798,14 +824,8 @@ void HTTPHandler::processQuery(
     const auto & query = getQuery(request, params, context);
     std::unique_ptr<ReadBuffer> in_param = std::make_unique<ReadBufferFromString>(query);
 
-    /// HTTP response compression is turned on only if the client signalled that they support it
-    /// (using Accept-Encoding header) and 'enable_http_compression' setting is turned on.
-    used_output.out->setCompression(client_supports_http_compression && settings.enable_http_compression);
-    if (client_supports_http_compression)
-        used_output.out->setCompressionLevel(static_cast<int>(settings.http_zlib_compression_level));
-
-    used_output.out->setSendProgress(settings.send_progress_in_http_headers);
-    used_output.out->setSendProgressInterval(settings.http_headers_progress_interval_ms);
+    used_output.out_holder->setSendProgress(settings.send_progress_in_http_headers);
+    used_output.out_holder->setSendProgressInterval(settings.http_headers_progress_interval_ms);
 
     /// If 'http_native_compression_disable_checksumming_on_decompress' setting is turned on,
     /// checksums of client data compressed with internal algorithm are not checked.
@@ -816,7 +836,7 @@ void HTTPHandler::processQuery(
     /// Note that whether the header is added is determined by the settings, and we can only get the user settings after authentication.
     /// Once the authentication fails, the header can't be added.
     if (settings.add_http_cors_header && !request.get("Origin", "").empty() && !config.has("http_options_response"))
-        used_output.out->addHeaderCORS(true);
+        used_output.out_holder->addHeaderCORS(true);
 
     auto append_callback = [my_context = context] (ProgressCallback callback)
     {
@@ -835,7 +855,7 @@ void HTTPHandler::processQuery(
     /// Note that we add it unconditionally so the progress is available for `X-ClickHouse-Summary`
     append_callback([&used_output](const Progress & progress)
     {
-        used_output.out->onProgress(progress);
+        used_output.out_holder->onProgress(progress);
     });
 
     if (settings.readonly > 0 && settings.cancel_http_readonly_queries_on_client_close)
@@ -888,6 +908,8 @@ void HTTPHandler::processQuery(
         {},
         handle_exception_in_output_format);
 
+    session->releaseSessionID();
+
     if (used_output.hasDelayed())
     {
         /// TODO: set Content-Length if possible
@@ -902,10 +924,8 @@ void HTTPHandler::trySendExceptionToClient(
     const std::string & s, int exception_code, HTTPServerRequest & request, HTTPServerResponse & response, Output & used_output)
 try
 {
-    /// In case data has already been sent, like progress headers, try using the output buffer to
-    /// set the exception code since it will be able to append it if it hasn't finished writing headers
-    if (response.sent() && used_output.out)
-        used_output.out->setExceptionCode(exception_code);
+    if (used_output.out_holder)
+        used_output.out_holder->setExceptionCode(exception_code);
     else
         response.set("X-ClickHouse-Exception-Code", toString<int>(exception_code));
 
@@ -930,10 +950,10 @@ try
         response.setStatusAndReason(exceptionCodeToHTTPStatus(exception_code));
     }
 
-    if (!response.sent() && !used_output.out_maybe_compressed && !used_output.exception_is_written)
+    if (!used_output.out_holder && !used_output.exception_is_written)
     {
         /// If nothing was sent yet and we don't even know if we must compress the response.
-        *response.send() << s << std::endl;
+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, DEFAULT_HTTP_KEEP_ALIVE_TIMEOUT).writeln(s);
     }
     else if (used_output.out_maybe_compressed)
     {
@@ -943,7 +963,8 @@ try
             /// do not call finalize here for CascadeWriteBuffer used_output.out_maybe_delayed_and_compressed,
             /// exception is written into used_output.out_maybe_compressed later
             /// HTTPHandler::trySendExceptionToClient is called with exception context, it is Ok to destroy buffers
-            used_output.out_maybe_delayed_and_compressed.reset();
+            used_output.out_delayed_and_compressed_holder.reset();
+            used_output.out_maybe_delayed_and_compressed = nullptr;
         }
 
         if (!used_output.exception_is_written)
@@ -953,12 +974,12 @@ try
             /// Also HTTP code 200 could have already been sent.
 
             /// If buffer has data, and that data wasn't sent yet, then no need to send that data
-            bool data_sent = used_output.out->count() != used_output.out->offset();
+            bool data_sent = used_output.out_holder->count() != used_output.out_holder->offset();
 
             if (!data_sent)
             {
                 used_output.out_maybe_compressed->position() = used_output.out_maybe_compressed->buffer().begin();
-                used_output.out->position() = used_output.out->buffer().begin();
+                used_output.out_holder->position() = used_output.out_holder->buffer().begin();
             }
 
             writeString(s, *used_output.out_maybe_compressed);
@@ -989,7 +1010,7 @@ catch (...)
 }
 
 
-void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event)
 {
     setThreadName("HTTPHandler");
     ThreadStatus thread_status;
@@ -1078,7 +1099,7 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse
                             "is no Content-Length header for POST request");
         }
 
-        processQuery(request, params, response, used_output, query_scope);
+        processQuery(request, params, response, used_output, query_scope, write_event);
         if (request_credentials)
             LOG_DEBUG(log, "Authentication in progress...");
         else
diff --git a/src/Server/HTTPHandler.h b/src/Server/HTTPHandler.h
index 6ec56cb09c16..18cf3c7c0f5e 100644
--- a/src/Server/HTTPHandler.h
+++ b/src/Server/HTTPHandler.h
@@ -6,6 +6,8 @@
 #include <Server/HTTP/WriteBufferFromHTTPServerResponse.h>
 #include <Common/CurrentMetrics.h>
 #include <Common/CurrentThread.h>
+#include <IO/CascadeWriteBuffer.h>
+#include <Compression/CompressedWriteBuffer.h>
 
 #ifdef __clang__
 #  pragma clang diagnostic push
@@ -40,7 +42,7 @@ class HTTPHandler : public HTTPRequestHandler
     HTTPHandler(IServer & server_, const std::string & name, const std::optional<String> & content_type_override_);
     virtual ~HTTPHandler() override;
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
     /// This method is called right before the query execution.
     virtual void customizeContext(HTTPServerRequest & /* request */, ContextMutablePtr /* context */, ReadBuffer & /* body */) {}
@@ -61,11 +63,22 @@ class HTTPHandler : public HTTPRequestHandler
          * WriteBufferFromHTTPServerResponse out
          */
 
-        std::shared_ptr<WriteBufferFromHTTPServerResponse> out;
-        /// Points to 'out' or to CompressedWriteBuffer(*out), depending on settings.
+        /// Holds original response buffer
+        std::shared_ptr<WriteBufferFromHTTPServerResponse> out_holder;
+        /// If HTTP compression is enabled holds compression wrapper over original response buffer
+        std::shared_ptr<WriteBuffer> wrap_compressed_holder;
+        /// Points either to out_holder or to wrap_compressed_holder
+        std::shared_ptr<WriteBuffer> out;
+
+        /// If internal compression is enabled holds compression wrapper over out buffer
+        std::shared_ptr<CompressedWriteBuffer> out_compressed_holder;
+        /// Points to 'out' or to CompressedWriteBuffer(*out)
         std::shared_ptr<WriteBuffer> out_maybe_compressed;
-        /// Points to 'out' or to CompressedWriteBuffer(*out) or to CascadeWriteBuffer.
-        std::shared_ptr<WriteBuffer> out_maybe_delayed_and_compressed;
+
+        /// If output should be delayed holds cascade buffer
+        std::unique_ptr<CascadeWriteBuffer> out_delayed_and_compressed_holder;
+        /// Points to out_maybe_compressed or to CascadeWriteBuffer.
+        WriteBuffer * out_maybe_delayed_and_compressed = nullptr;
 
         bool finalized = false;
 
@@ -73,7 +86,7 @@ class HTTPHandler : public HTTPRequestHandler
 
         inline bool hasDelayed() const
         {
-            return out_maybe_delayed_and_compressed != out_maybe_compressed;
+            return out_maybe_delayed_and_compressed != out_maybe_compressed.get();
         }
 
         inline void finalize()
@@ -82,11 +95,9 @@ class HTTPHandler : public HTTPRequestHandler
                 return;
             finalized = true;
 
-            if (out_maybe_delayed_and_compressed)
-                out_maybe_delayed_and_compressed->finalize();
             if (out_maybe_compressed)
                 out_maybe_compressed->finalize();
-            if (out)
+            else if (out)
                 out->finalize();
         }
 
@@ -135,7 +146,8 @@ class HTTPHandler : public HTTPRequestHandler
         HTMLForm & params,
         HTTPServerResponse & response,
         Output & used_output,
-        std::optional<CurrentThread::QueryScope> & query_scope);
+        std::optional<CurrentThread::QueryScope> & query_scope,
+        const ProfileEvents::Event & write_event);
 
     void trySendExceptionToClient(
         const std::string & s,
diff --git a/src/Server/InterserverIOHTTPHandler.cpp b/src/Server/InterserverIOHTTPHandler.cpp
index 53773a83b40c..c41d68bab021 100644
--- a/src/Server/InterserverIOHTTPHandler.cpp
+++ b/src/Server/InterserverIOHTTPHandler.cpp
@@ -77,7 +77,7 @@ void InterserverIOHTTPHandler::processQuery(HTTPServerRequest & request, HTTPSer
 }
 
 
-void InterserverIOHTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void InterserverIOHTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event)
 {
     setThreadName("IntersrvHandler");
     ThreadStatus thread_status;
@@ -89,7 +89,7 @@ void InterserverIOHTTPHandler::handleRequest(HTTPServerRequest & request, HTTPSe
     Output used_output;
     const auto keep_alive_timeout = server.context()->getServerSettings().keep_alive_timeout.totalSeconds();
     used_output.out = std::make_shared<WriteBufferFromHTTPServerResponse>(
-        response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout);
+        response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout, write_event);
 
     auto write_response = [&](const std::string & message)
     {
diff --git a/src/Server/InterserverIOHTTPHandler.h b/src/Server/InterserverIOHTTPHandler.h
index da5b286b9e5e..66042ad3d1df 100644
--- a/src/Server/InterserverIOHTTPHandler.h
+++ b/src/Server/InterserverIOHTTPHandler.h
@@ -30,7 +30,7 @@ class InterserverIOHTTPHandler : public HTTPRequestHandler
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 
 private:
     struct Output
diff --git a/src/Server/KeeperReadinessHandler.cpp b/src/Server/KeeperReadinessHandler.cpp
index ed972055aeec..de6edd199d74 100644
--- a/src/Server/KeeperReadinessHandler.cpp
+++ b/src/Server/KeeperReadinessHandler.cpp
@@ -19,7 +19,7 @@
 namespace DB
 {
 
-void KeeperReadinessHandler::handleRequest(HTTPServerRequest & /*request*/, HTTPServerResponse & response)
+void KeeperReadinessHandler::handleRequest(HTTPServerRequest & /*request*/, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     try
     {
@@ -58,7 +58,7 @@ void KeeperReadinessHandler::handleRequest(HTTPServerRequest & /*request*/, HTTP
             if (!response.sent())
             {
                 /// We have not sent anything yet and we don't even know if we need to compress response.
-                *response.send() << getCurrentExceptionMessage(false) << std::endl;
+                *response.send() << getCurrentExceptionMessage(false) << '
';
             }
         }
         catch (...)
diff --git a/src/Server/KeeperReadinessHandler.h b/src/Server/KeeperReadinessHandler.h
index 00b51b886f9d..a16aa9f8021f 100644
--- a/src/Server/KeeperReadinessHandler.h
+++ b/src/Server/KeeperReadinessHandler.h
@@ -22,7 +22,7 @@ class KeeperReadinessHandler : public HTTPRequestHandler, WithContext
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 };
 
 HTTPRequestHandlerFactoryPtr
diff --git a/src/Server/MySQLHandler.cpp b/src/Server/MySQLHandler.cpp
index 10b520ca97ae..b3e07e37f305 100644
--- a/src/Server/MySQLHandler.cpp
+++ b/src/Server/MySQLHandler.cpp
@@ -70,13 +70,17 @@ MySQLHandler::MySQLHandler(
     IServer & server_,
     TCPServer & tcp_server_,
     const Poco::Net::StreamSocket & socket_,
-    bool ssl_enabled, uint32_t connection_id_)
+    bool ssl_enabled, uint32_t connection_id_,
+    const ProfileEvents::Event & read_event_,
+    const ProfileEvents::Event & write_event_)
     : Poco::Net::TCPServerConnection(socket_)
     , server(server_)
     , tcp_server(tcp_server_)
     , log(&Poco::Logger::get("MySQLHandler"))
     , connection_id(connection_id_)
     , auth_plugin(new MySQLProtocol::Authentication::Native41())
+    , read_event(read_event_)
+    , write_event(write_event_)
 {
     server_capabilities = CLIENT_PROTOCOL_41 | CLIENT_SECURE_CONNECTION | CLIENT_PLUGIN_AUTH | CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA | CLIENT_CONNECT_WITH_DB | CLIENT_DEPRECATE_EOF;
     if (ssl_enabled)
@@ -98,8 +102,8 @@ void MySQLHandler::run()
 
     session->setClientConnectionId(connection_id);
 
-    in = std::make_shared<ReadBufferFromPocoSocket>(socket());
-    out = std::make_shared<WriteBufferFromPocoSocket>(socket());
+    in = std::make_shared<ReadBufferFromPocoSocket>(socket(), read_event);
+    out = std::make_shared<WriteBufferFromPocoSocket>(socket(), write_event);
     packet_endpoint = std::make_shared<MySQLProtocol::PacketEndpoint>(*in, *out, sequence_id);
 
     try
@@ -489,8 +493,10 @@ MySQLHandlerSSL::MySQLHandlerSSL(
     bool ssl_enabled,
     uint32_t connection_id_,
     RSA & public_key_,
-    RSA & private_key_)
-    : MySQLHandler(server_, tcp_server_, socket_, ssl_enabled, connection_id_)
+    RSA & private_key_,
+    const ProfileEvents::Event & read_event_,
+    const ProfileEvents::Event & write_event_)
+    : MySQLHandler(server_, tcp_server_, socket_, ssl_enabled, connection_id_, read_event_, write_event_)
     , public_key(public_key_)
     , private_key(private_key_)
 {}
diff --git a/src/Server/MySQLHandler.h b/src/Server/MySQLHandler.h
index 194b18bdc39f..36d63ebca849 100644
--- a/src/Server/MySQLHandler.h
+++ b/src/Server/MySQLHandler.h
@@ -42,7 +42,9 @@ class MySQLHandler : public Poco::Net::TCPServerConnection
         TCPServer & tcp_server_,
         const Poco::Net::StreamSocket & socket_,
         bool ssl_enabled,
-        uint32_t connection_id_);
+        uint32_t connection_id_,
+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     void run() final;
 
@@ -102,6 +104,9 @@ class MySQLHandler : public Poco::Net::TCPServerConnection
     std::shared_ptr<ReadBufferFromPocoSocket> in;
     std::shared_ptr<WriteBuffer> out;
     bool secure_connection = false;
+
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
 };
 
 #if USE_SSL
@@ -115,7 +120,9 @@ class MySQLHandlerSSL : public MySQLHandler
         bool ssl_enabled,
         uint32_t connection_id_,
         RSA & public_key_,
-        RSA & private_key_);
+        RSA & private_key_,
+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
 private:
     void authPluginSSL() override;
diff --git a/src/Server/MySQLHandlerFactory.cpp b/src/Server/MySQLHandlerFactory.cpp
index f74f57926f97..79234c647aa6 100644
--- a/src/Server/MySQLHandlerFactory.cpp
+++ b/src/Server/MySQLHandlerFactory.cpp
@@ -21,9 +21,11 @@ namespace ErrorCodes
     extern const int OPENSSL_ERROR;
 }
 
-MySQLHandlerFactory::MySQLHandlerFactory(IServer & server_)
+MySQLHandlerFactory::MySQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)
     : server(server_)
     , log(&Poco::Logger::get("MySQLHandlerFactory"))
+    , read_event(read_event_)
+    , write_event(write_event_)
 {
 #if USE_SSL
     try
diff --git a/src/Server/MySQLHandlerFactory.h b/src/Server/MySQLHandlerFactory.h
index fa4ce93f7655..307ee3b2f0de 100644
--- a/src/Server/MySQLHandlerFactory.h
+++ b/src/Server/MySQLHandlerFactory.h
@@ -4,6 +4,7 @@
 #include <memory>
 #include <Server/IServer.h>
 #include <Server/TCPServerConnectionFactory.h>
+#include <Common/ProfileEvents.h>
 
 #include "config.h"
 
@@ -37,8 +38,11 @@ class MySQLHandlerFactory : public TCPServerConnectionFactory
 #endif
 
     std::atomic<unsigned> last_connection_id = 0;
+
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
 public:
-    explicit MySQLHandlerFactory(IServer & server_);
+    explicit MySQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     void readRSAKeys();
 
diff --git a/src/Server/NotFoundHandler.cpp b/src/Server/NotFoundHandler.cpp
index 5b1db5085515..38f56921c893 100644
--- a/src/Server/NotFoundHandler.cpp
+++ b/src/Server/NotFoundHandler.cpp
@@ -5,7 +5,7 @@
 
 namespace DB
 {
-void NotFoundHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void NotFoundHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     try
     {
diff --git a/src/Server/NotFoundHandler.h b/src/Server/NotFoundHandler.h
index 1cbfcd57f8f1..a484d2377714 100644
--- a/src/Server/NotFoundHandler.h
+++ b/src/Server/NotFoundHandler.h
@@ -10,7 +10,7 @@ class NotFoundHandler : public HTTPRequestHandler
 {
 public:
     NotFoundHandler(std::vector<std::string> hints_) : hints(std::move(hints_)) {}
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 private:
     std::vector<std::string> hints;
 };
diff --git a/src/Server/PostgreSQLHandler.cpp b/src/Server/PostgreSQLHandler.cpp
index eeb3784c1df1..c62dc8109ea2 100644
--- a/src/Server/PostgreSQLHandler.cpp
+++ b/src/Server/PostgreSQLHandler.cpp
@@ -32,12 +32,16 @@ PostgreSQLHandler::PostgreSQLHandler(
     TCPServer & tcp_server_,
     bool ssl_enabled_,
     Int32 connection_id_,
-    std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_)
+    std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_,
+    const ProfileEvents::Event & read_event_,
+    const ProfileEvents::Event & write_event_)
     : Poco::Net::TCPServerConnection(socket_)
     , server(server_)
     , tcp_server(tcp_server_)
     , ssl_enabled(ssl_enabled_)
     , connection_id(connection_id_)
+    , read_event(read_event_)
+    , write_event(write_event_)
     , authentication_manager(auth_methods_)
 {
     changeIO(socket());
@@ -45,8 +49,8 @@ PostgreSQLHandler::PostgreSQLHandler(
 
 void PostgreSQLHandler::changeIO(Poco::Net::StreamSocket & socket)
 {
-    in = std::make_shared<ReadBufferFromPocoSocket>(socket);
-    out = std::make_shared<WriteBufferFromPocoSocket>(socket);
+    in = std::make_shared<ReadBufferFromPocoSocket>(socket, read_event);
+    out = std::make_shared<WriteBufferFromPocoSocket>(socket, write_event);
     message_transport = std::make_shared<PostgreSQLProtocol::Messaging::MessageTransport>(in.get(), out.get());
 }
 
diff --git a/src/Server/PostgreSQLHandler.h b/src/Server/PostgreSQLHandler.h
index f20af3df02cf..57b91a0ad044 100644
--- a/src/Server/PostgreSQLHandler.h
+++ b/src/Server/PostgreSQLHandler.h
@@ -33,7 +33,9 @@ class PostgreSQLHandler : public Poco::Net::TCPServerConnection
         TCPServer & tcp_server_,
         bool ssl_enabled_,
         Int32 connection_id_,
-        std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_);
+        std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> & auth_methods_,
+        const ProfileEvents::Event & read_event_ = ProfileEvents::end(),
+        const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     void run() final;
 
@@ -51,6 +53,9 @@ class PostgreSQLHandler : public Poco::Net::TCPServerConnection
     std::shared_ptr<WriteBuffer> out;
     std::shared_ptr<PostgreSQLProtocol::Messaging::MessageTransport> message_transport;
 
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
+
 #if USE_SSL
     std::shared_ptr<Poco::Net::SecureStreamSocket> ss;
 #endif
diff --git a/src/Server/PostgreSQLHandlerFactory.cpp b/src/Server/PostgreSQLHandlerFactory.cpp
index 6f2124861e7e..096bbbdcda9a 100644
--- a/src/Server/PostgreSQLHandlerFactory.cpp
+++ b/src/Server/PostgreSQLHandlerFactory.cpp
@@ -5,9 +5,11 @@
 namespace DB
 {
 
-PostgreSQLHandlerFactory::PostgreSQLHandlerFactory(IServer & server_)
+PostgreSQLHandlerFactory::PostgreSQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)
     : server(server_)
     , log(&Poco::Logger::get("PostgreSQLHandlerFactory"))
+    , read_event(read_event_)
+    , write_event(write_event_)
 {
     auth_methods =
     {
@@ -20,7 +22,7 @@ Poco::Net::TCPServerConnection * PostgreSQLHandlerFactory::createConnection(cons
 {
     Int32 connection_id = last_connection_id++;
     LOG_TRACE(log, "PostgreSQL connection. Id: {}. Address: {}", connection_id, socket.peerAddress().toString());
-    return new PostgreSQLHandler(socket, server, tcp_server, ssl_enabled, connection_id, auth_methods);
+    return new PostgreSQLHandler(socket, server, tcp_server, ssl_enabled, connection_id, auth_methods, read_event, write_event);
 }
 
 }
diff --git a/src/Server/PostgreSQLHandlerFactory.h b/src/Server/PostgreSQLHandlerFactory.h
index 35046325386b..e5f762fca6d7 100644
--- a/src/Server/PostgreSQLHandlerFactory.h
+++ b/src/Server/PostgreSQLHandlerFactory.h
@@ -15,6 +15,8 @@ class PostgreSQLHandlerFactory : public TCPServerConnectionFactory
 private:
     IServer & server;
     Poco::Logger * log;
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
 
 #if USE_SSL
     bool ssl_enabled = true;
@@ -26,7 +28,7 @@ class PostgreSQLHandlerFactory : public TCPServerConnectionFactory
     std::vector<std::shared_ptr<PostgreSQLProtocol::PGAuthentication::AuthenticationMethod>> auth_methods;
 
 public:
-    explicit PostgreSQLHandlerFactory(IServer & server_);
+    explicit PostgreSQLHandlerFactory(IServer & server_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());
 
     Poco::Net::TCPServerConnection * createConnection(const Poco::Net::StreamSocket & socket, TCPServer & server) override;
 };
diff --git a/src/Server/PrometheusRequestHandler.cpp b/src/Server/PrometheusRequestHandler.cpp
index 127ed843cb6c..6e0b138f4e07 100644
--- a/src/Server/PrometheusRequestHandler.cpp
+++ b/src/Server/PrometheusRequestHandler.cpp
@@ -13,7 +13,7 @@
 
 namespace DB
 {
-void PrometheusRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void PrometheusRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event)
 {
     try
     {
@@ -27,7 +27,7 @@ void PrometheusRequestHandler::handleRequest(HTTPServerRequest & request, HTTPSe
 
         response.setContentType("text/plain; version=0.0.4; charset=UTF-8");
 
-        WriteBufferFromHTTPServerResponse wb(response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout);
+        WriteBufferFromHTTPServerResponse wb(response, request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD, keep_alive_timeout, write_event);
         try
         {
             metrics_writer.write(wb);
diff --git a/src/Server/PrometheusRequestHandler.h b/src/Server/PrometheusRequestHandler.h
index 1fb3d9f0f595..e366041bc6c5 100644
--- a/src/Server/PrometheusRequestHandler.h
+++ b/src/Server/PrometheusRequestHandler.h
@@ -22,7 +22,7 @@ class PrometheusRequestHandler : public HTTPRequestHandler
     {
     }
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 };
 
 }
diff --git a/src/Server/ReplicasStatusHandler.cpp b/src/Server/ReplicasStatusHandler.cpp
index c30c3ebaa770..07f3b67b6a7e 100644
--- a/src/Server/ReplicasStatusHandler.cpp
+++ b/src/Server/ReplicasStatusHandler.cpp
@@ -22,7 +22,7 @@ ReplicasStatusHandler::ReplicasStatusHandler(IServer & server) : WithContext(ser
 {
 }
 
-void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     try
     {
@@ -113,7 +113,7 @@ void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServe
             if (!response.sent())
             {
                 /// We have not sent anything yet and we don't even know if we need to compress response.
-                *response.send() << getCurrentExceptionMessage(false) << std::endl;
+                *response.send() << getCurrentExceptionMessage(false) << '
';
             }
         }
         catch (...)
diff --git a/src/Server/ReplicasStatusHandler.h b/src/Server/ReplicasStatusHandler.h
index 1a5388aa2abf..08fd757b0d61 100644
--- a/src/Server/ReplicasStatusHandler.h
+++ b/src/Server/ReplicasStatusHandler.h
@@ -14,7 +14,7 @@ class ReplicasStatusHandler : public HTTPRequestHandler, WithContext
 public:
     explicit ReplicasStatusHandler(IServer & server_);
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 };
 
 
diff --git a/src/Server/StaticRequestHandler.cpp b/src/Server/StaticRequestHandler.cpp
index 34cb5d2d1698..67bf3875de48 100644
--- a/src/Server/StaticRequestHandler.cpp
+++ b/src/Server/StaticRequestHandler.cpp
@@ -33,9 +33,11 @@ namespace ErrorCodes
     extern const int INVALID_CONFIG_PARAMETER;
 }
 
-static inline WriteBufferPtr
+static inline std::unique_ptr<WriteBuffer>
 responseWriteBuffer(HTTPServerRequest & request, HTTPServerResponse & response, UInt64 keep_alive_timeout)
 {
+    auto buf = std::unique_ptr<WriteBuffer>(new WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout));
+
     /// The client can pass a HTTP header indicating supported compression method (gzip or deflate).
     String http_response_compression_methods = request.get("Accept-Encoding", "");
     CompressionMethod http_response_compression_method = CompressionMethod::None;
@@ -43,14 +45,11 @@ responseWriteBuffer(HTTPServerRequest & request, HTTPServerResponse & response,
     if (!http_response_compression_methods.empty())
         http_response_compression_method = chooseHTTPCompressionMethod(http_response_compression_methods);
 
-    bool client_supports_http_compression = http_response_compression_method != CompressionMethod::None;
+    if (http_response_compression_method == CompressionMethod::None)
+        return buf;
 
-    return std::make_shared<WriteBufferFromHTTPServerResponse>(
-        response,
-        request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD,
-        keep_alive_timeout,
-        client_supports_http_compression,
-        http_response_compression_method);
+    response.set("Content-Encoding", toContentEncodingName(http_response_compression_method));
+    return wrapWriteBufferWithCompressionMethod(std::move(buf), http_response_compression_method, 1);
 }
 
 static inline void trySendExceptionToClient(
@@ -69,7 +68,7 @@ static inline void trySendExceptionToClient(
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);
 
         if (!response.sent())
-            *response.send() << s << std::endl;
+            *response.send() << s << '
';
         else
         {
             if (out.count() != out.offset())
@@ -88,10 +87,10 @@ static inline void trySendExceptionToClient(
     }
 }
 
-void StaticRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void StaticRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     auto keep_alive_timeout = server.context()->getServerSettings().keep_alive_timeout.totalSeconds();
-    const auto & out = responseWriteBuffer(request, response, keep_alive_timeout);
+    auto out = responseWriteBuffer(request, response, keep_alive_timeout);
 
     try
     {
diff --git a/src/Server/StaticRequestHandler.h b/src/Server/StaticRequestHandler.h
index df9374d44096..38d774bb0aad 100644
--- a/src/Server/StaticRequestHandler.h
+++ b/src/Server/StaticRequestHandler.h
@@ -29,7 +29,7 @@ class StaticRequestHandler : public HTTPRequestHandler
 
     void writeResponse(WriteBuffer & out);
 
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 };
 
 }
diff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp
index a563e0e00047..b56df48a1215 100644
--- a/src/Server/TCPHandler.cpp
+++ b/src/Server/TCPHandler.cpp
@@ -184,23 +184,27 @@ void validateClientInfo(const ClientInfo & session_client_info, const ClientInfo
 namespace DB
 {
 
-TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_)
+TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)
     : Poco::Net::TCPServerConnection(socket_)
     , server(server_)
     , tcp_server(tcp_server_)
     , parse_proxy_protocol(parse_proxy_protocol_)
     , log(&Poco::Logger::get("TCPHandler"))
+    , read_event(read_event_)
+    , write_event(write_event_)
     , server_display_name(std::move(server_display_name_))
 {
 }
 
-TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_)
+TCPHandler::TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_, const ProfileEvents::Event & read_event_, const ProfileEvents::Event & write_event_)
 : Poco::Net::TCPServerConnection(socket_)
     , server(server_)
     , tcp_server(tcp_server_)
     , log(&Poco::Logger::get("TCPHandler"))
     , forwarded_for(stack_data.forwarded_for)
     , certificate(stack_data.certificate)
+    , read_event(read_event_)
+    , write_event(write_event_)
     , default_database(stack_data.default_database)
     , server_display_name(std::move(server_display_name_))
 {
@@ -233,8 +237,8 @@ void TCPHandler::runImpl()
     socket().setSendTimeout(send_timeout);
     socket().setNoDelay(true);
 
-    in = std::make_shared<ReadBufferFromPocoSocket>(socket());
-    out = std::make_shared<WriteBufferFromPocoSocket>(socket());
+    in = std::make_shared<ReadBufferFromPocoSocket>(socket(), read_event);
+    out = std::make_shared<WriteBufferFromPocoSocket>(socket(), write_event);
 
     /// Support for PROXY protocol
     if (parse_proxy_protocol && !receiveProxyHeader())
diff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h
index 45c10b1c27d1..4eb84ee5eee5 100644
--- a/src/Server/TCPHandler.h
+++ b/src/Server/TCPHandler.h
@@ -147,8 +147,8 @@ class TCPHandler : public Poco::Net::TCPServerConnection
       *  because it allows to check the IP ranges of the trusted proxy.
       * Proxy-forwarded (original client) IP address is used for quota accounting if quota is keyed by forwarded IP.
       */
-    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_);
-    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_);
+    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, bool parse_proxy_protocol_, std::string server_display_name_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());
+    TCPHandler(IServer & server_, TCPServer & tcp_server_, const Poco::Net::StreamSocket & socket_, TCPProtocolStackData & stack_data, std::string server_display_name_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end());
     ~TCPHandler() override;
 
     void run() override;
@@ -191,6 +191,9 @@ class TCPHandler : public Poco::Net::TCPServerConnection
     std::shared_ptr<ReadBuffer> in;
     std::shared_ptr<WriteBuffer> out;
 
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
+
     /// Time after the last check to stop the request and send the progress.
     Stopwatch after_check_cancelled;
     Stopwatch after_send_progress;
diff --git a/src/Server/TCPHandlerFactory.h b/src/Server/TCPHandlerFactory.h
index fde04c6e0ab4..3eb032f4250b 100644
--- a/src/Server/TCPHandlerFactory.h
+++ b/src/Server/TCPHandlerFactory.h
@@ -21,6 +21,9 @@ class TCPHandlerFactory : public TCPServerConnectionFactory
     Poco::Logger * log;
     std::string server_display_name;
 
+    ProfileEvents::Event read_event;
+    ProfileEvents::Event write_event;
+
     class DummyTCPHandler : public Poco::Net::TCPServerConnection
     {
     public:
@@ -33,9 +36,11 @@ class TCPHandlerFactory : public TCPServerConnectionFactory
       * and set the information about forwarded address accordingly.
       * See https://github.com/wolfeidau/proxyv2/blob/master/docs/proxy-protocol.txt
       */
-    TCPHandlerFactory(IServer & server_, bool secure_, bool parse_proxy_protocol_)
+    TCPHandlerFactory(IServer & server_, bool secure_, bool parse_proxy_protocol_, const ProfileEvents::Event & read_event_ = ProfileEvents::end(), const ProfileEvents::Event & write_event_ = ProfileEvents::end())
         : server(server_), parse_proxy_protocol(parse_proxy_protocol_)
         , log(&Poco::Logger::get(std::string("TCP") + (secure_ ? "S" : "") + "HandlerFactory"))
+        , read_event(read_event_)
+        , write_event(write_event_)
     {
         server_display_name = server.config().getString("display_name", getFQDNOrHostName());
     }
@@ -45,8 +50,7 @@ class TCPHandlerFactory : public TCPServerConnectionFactory
         try
         {
             LOG_TRACE(log, "TCP Request. Address: {}", socket.peerAddress().toString());
-
-            return new TCPHandler(server, tcp_server, socket, parse_proxy_protocol, server_display_name);
+            return new TCPHandler(server, tcp_server, socket, parse_proxy_protocol, server_display_name, read_event, write_event);
         }
         catch (const Poco::Net::NetException &)
         {
@@ -60,8 +64,7 @@ class TCPHandlerFactory : public TCPServerConnectionFactory
         try
         {
             LOG_TRACE(log, "TCP Request. Address: {}", socket.peerAddress().toString());
-
-            return new TCPHandler(server, tcp_server, socket, stack_data, server_display_name);
+            return new TCPHandler(server, tcp_server, socket, stack_data, server_display_name, read_event, write_event);
         }
         catch (const Poco::Net::NetException &)
         {
diff --git a/src/Server/WebUIRequestHandler.cpp b/src/Server/WebUIRequestHandler.cpp
index ad48b38b91ab..f9b77909df96 100644
--- a/src/Server/WebUIRequestHandler.cpp
+++ b/src/Server/WebUIRequestHandler.cpp
@@ -1,5 +1,6 @@
 #include "WebUIRequestHandler.h"
 #include "IServer.h"
+#include <Server/HTTP/WriteBufferFromHTTPServerResponse.h>
 
 #include <Poco/Net/HTTPServerResponse.h>
 #include <Poco/Util/LayeredConfiguration.h>
@@ -36,7 +37,7 @@ WebUIRequestHandler::WebUIRequestHandler(IServer & server_)
 }
 
 
-void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)
+void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & /*write_event*/)
 {
     auto keep_alive_timeout = server.context()->getServerSettings().keep_alive_timeout.totalSeconds();
 
@@ -50,7 +51,7 @@ void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerR
     if (request.getURI().starts_with("/play"))
     {
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);
-        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_play_htmlData), gresource_play_htmlSize);
+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(reinterpret_cast<const char *>(gresource_play_htmlData), gresource_play_htmlSize);
     }
     else if (request.getURI().starts_with("/dashboard"))
     {
@@ -66,17 +67,17 @@ void WebUIRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerR
         static re2::RE2 uplot_url = R"(https://[^\s"'`]+u[Pp]lot[^\s"'`]*\.js)";
         RE2::Replace(&html, uplot_url, "/js/uplot.js");
 
-        *response.send() << html;
+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(html);
     }
     else if (request.getURI().starts_with("/binary"))
     {
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);
-        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_binary_htmlData), gresource_binary_htmlSize);
+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(reinterpret_cast<const char *>(gresource_binary_htmlData), gresource_binary_htmlSize);
     }
     else if (request.getURI() == "/js/uplot.js")
     {
         response.setStatusAndReason(Poco::Net::HTTPResponse::HTTP_OK);
-        *response.send() << std::string_view(reinterpret_cast<const char *>(gresource_uplot_jsData), gresource_uplot_jsSize);
+        WriteBufferFromHTTPServerResponse(response, request.getMethod() == HTTPRequest::HTTP_HEAD, keep_alive_timeout).write(reinterpret_cast<const char *>(gresource_uplot_jsData), gresource_uplot_jsSize);
     }
     else
     {
diff --git a/src/Server/WebUIRequestHandler.h b/src/Server/WebUIRequestHandler.h
index 09fe62d41c3d..c52946e20899 100644
--- a/src/Server/WebUIRequestHandler.h
+++ b/src/Server/WebUIRequestHandler.h
@@ -16,7 +16,7 @@ class WebUIRequestHandler : public HTTPRequestHandler
 
 public:
     WebUIRequestHandler(IServer & server_);
-    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response) override;
+    void handleRequest(HTTPServerRequest & request, HTTPServerResponse & response, const ProfileEvents::Event & write_event) override;
 };
 
 }
