diff --git a/base/common/DecomposedFloat.h b/base/common/DecomposedFloat.h
new file mode 100644
index 000000000000..078ba823c153
--- /dev/null
+++ b/base/common/DecomposedFloat.h
@@ -0,0 +1,216 @@
+#pragma once
+
+#include <cstdint>
+#include <cstddef>
+#include <cstring>
+#include <common/extended_types.h>
+
+
+/// Allows to check the internals of IEEE-754 floating point number.
+
+template <typename T> struct FloatTraits;
+
+template <>
+struct FloatTraits<float>
+{
+    using UInt = uint32_t;
+    static constexpr size_t bits = 32;
+    static constexpr size_t exponent_bits = 8;
+    static constexpr size_t mantissa_bits = bits - exponent_bits - 1;
+};
+
+template <>
+struct FloatTraits<double>
+{
+    using UInt = uint64_t;
+    static constexpr size_t bits = 64;
+    static constexpr size_t exponent_bits = 11;
+    static constexpr size_t mantissa_bits = bits - exponent_bits - 1;
+};
+
+
+/// x = sign * (2 ^ normalized_exponent) * (1 + mantissa * 2 ^ -mantissa_bits)
+/// x = sign * (2 ^ normalized_exponent + mantissa * 2 ^ (normalized_exponent - mantissa_bits))
+template <typename T>
+struct DecomposedFloat
+{
+    using Traits = FloatTraits<T>;
+
+    DecomposedFloat(T x)
+    {
+        memcpy(&x_uint, &x, sizeof(x));
+    }
+
+    typename Traits::UInt x_uint;
+
+    bool is_negative() const
+    {
+        return x_uint >> (Traits::bits - 1);
+    }
+
+    /// Returns 0 for both +0. and -0.
+    int sign() const
+    {
+        return (exponent() == 0 && mantissa() == 0)
+            ? 0
+            : (is_negative()
+                ? -1
+                : 1);
+    }
+
+    uint16_t exponent() const
+    {
+        return (x_uint >> (Traits::mantissa_bits)) & (((1ull << (Traits::exponent_bits + 1)) - 1) >> 1);
+    }
+
+    int16_t normalized_exponent() const
+    {
+        return int16_t(exponent()) - ((1ull << (Traits::exponent_bits - 1)) - 1);
+    }
+
+    uint64_t mantissa() const
+    {
+        return x_uint & ((1ull << Traits::mantissa_bits) - 1);
+    }
+
+    int64_t mantissa_with_sign() const
+    {
+        return is_negative() ? -mantissa() : mantissa();
+    }
+
+    /// NOTE Probably floating point instructions can be better.
+    bool is_integer_in_representable_range() const
+    {
+        return x_uint == 0
+            || (normalized_exponent() >= 0  /// The number is not less than one
+                /// The number is inside the range where every integer has exact representation in float
+                && normalized_exponent() <= static_cast<int16_t>(Traits::mantissa_bits)
+                /// After multiplying by 2^exp, the fractional part becomes zero, means the number is integer
+                && ((mantissa() & ((1ULL << (Traits::mantissa_bits - normalized_exponent())) - 1)) == 0));
+    }
+
+
+    /// Compare float with integer of arbitrary width (both signed and unsigned are supported). Assuming two's complement arithmetic.
+    /// Infinities are compared correctly. NaNs are treat similarly to infinities, so they can be less than all numbers.
+    /// (note that we need total order)
+    template <typename Int>
+    int compare(Int rhs)
+    {
+        if (rhs == 0)
+            return sign();
+
+        /// Different signs
+        if (is_negative() && rhs > 0)
+            return -1;
+        if (!is_negative() && rhs < 0)
+            return 1;
+
+        /// Fractional number with magnitude less than one
+        if (normalized_exponent() < 0)
+        {
+            if (!is_negative())
+                return rhs > 0 ? -1 : 1;
+            else
+                return rhs >= 0 ? -1 : 1;
+        }
+
+        /// The case of the most negative integer
+        if constexpr (is_signed_v<Int>)
+        {
+            if (rhs == std::numeric_limits<Int>::lowest())
+            {
+                assert(is_negative());
+
+                if (normalized_exponent() < static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))
+                    return 1;
+                if (normalized_exponent() > static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))
+                    return -1;
+
+                if (mantissa() == 0)
+                    return 0;
+                else
+                    return -1;
+            }
+        }
+
+        /// Too large number: abs(float) > abs(rhs). Also the case with infinities and NaN.
+        if (normalized_exponent() >= static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>))
+            return is_negative() ? -1 : 1;
+
+        using UInt = make_unsigned_t<Int>;
+        UInt uint_rhs = rhs < 0 ? -rhs : rhs;
+
+        /// Smaller octave: abs(rhs) < abs(float)
+        if (uint_rhs < (static_cast<UInt>(1) << normalized_exponent()))
+            return is_negative() ? -1 : 1;
+
+        /// Larger octave: abs(rhs) > abs(float)
+        if (normalized_exponent() + 1 < static_cast<int16_t>(8 * sizeof(Int) - is_signed_v<Int>)
+            && uint_rhs >= (static_cast<UInt>(1) << (normalized_exponent() + 1)))
+            return is_negative() ? 1 : -1;
+
+        /// The same octave
+        /// uint_rhs == 2 ^ normalized_exponent + mantissa * 2 ^ (normalized_exponent - mantissa_bits)
+
+        bool large_and_always_integer = normalized_exponent() >= static_cast<int16_t>(Traits::mantissa_bits);
+
+        typename Traits::UInt a = large_and_always_integer
+            ? mantissa() << (normalized_exponent() - Traits::mantissa_bits)
+            : mantissa() >> (Traits::mantissa_bits - normalized_exponent());
+
+        typename Traits::UInt b = uint_rhs - (static_cast<UInt>(1) << normalized_exponent());
+
+        if (a < b)
+            return is_negative() ? 1 : -1;
+        if (a > b)
+            return is_negative() ? -1 : 1;
+
+        /// Float has no fractional part means that the numbers are equal.
+        if (large_and_always_integer || (mantissa() & ((1ULL << (Traits::mantissa_bits - normalized_exponent())) - 1)) == 0)
+            return 0;
+        else
+            /// Float has fractional part means its abs value is larger.
+            return is_negative() ? -1 : 1;
+    }
+
+
+    template <typename Int>
+    bool equals(Int rhs)
+    {
+        return compare(rhs) == 0;
+    }
+
+    template <typename Int>
+    bool notEquals(Int rhs)
+    {
+        return compare(rhs) != 0;
+    }
+
+    template <typename Int>
+    bool less(Int rhs)
+    {
+        return compare(rhs) < 0;
+    }
+
+    template <typename Int>
+    bool greater(Int rhs)
+    {
+        return compare(rhs) > 0;
+    }
+
+    template <typename Int>
+    bool lessOrEquals(Int rhs)
+    {
+        return compare(rhs) <= 0;
+    }
+
+    template <typename Int>
+    bool greaterOrEquals(Int rhs)
+    {
+        return compare(rhs) >= 0;
+    }
+};
+
+
+using DecomposedFloat64 = DecomposedFloat<double>;
+using DecomposedFloat32 = DecomposedFloat<float>;
diff --git a/base/common/arithmeticOverflow.h b/base/common/arithmeticOverflow.h
index c170d2146367..175e75a62f4b 100644
--- a/base/common/arithmeticOverflow.h
+++ b/base/common/arithmeticOverflow.h
@@ -56,27 +56,33 @@ namespace common
     }
 
     template <>
-    inline bool addOverflow(__int128 x, __int128 y, __int128 & res)
+    inline bool addOverflow(Int128 x, Int128 y, Int128 & res)
     {
-        static constexpr __int128 min_int128 = minInt128();
-        static constexpr __int128 max_int128 = maxInt128();
         res = addIgnoreOverflow(x, y);
-        return (y > 0 && x > max_int128 - y) || (y < 0 && x < min_int128 - y);
+        return (y > 0 && x > std::numeric_limits<Int128>::max() - y) ||
+            (y < 0 && x < std::numeric_limits<Int128>::min() - y);
     }
 
     template <>
-    inline bool addOverflow(wInt256 x, wInt256 y, wInt256 & res)
+    inline bool addOverflow(UInt128 x, UInt128 y, UInt128 & res)
     {
         res = addIgnoreOverflow(x, y);
-        return (y > 0 && x > std::numeric_limits<wInt256>::max() - y) ||
-            (y < 0 && x < std::numeric_limits<wInt256>::min() - y);
+        return x > std::numeric_limits<UInt128>::max() - y;
     }
 
     template <>
-    inline bool addOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)
+    inline bool addOverflow(Int256 x, Int256 y, Int256 & res)
     {
         res = addIgnoreOverflow(x, y);
-        return x > std::numeric_limits<wUInt256>::max() - y;
+        return (y > 0 && x > std::numeric_limits<Int256>::max() - y) ||
+            (y < 0 && x < std::numeric_limits<Int256>::min() - y);
+    }
+
+    template <>
+    inline bool addOverflow(UInt256 x, UInt256 y, UInt256 & res)
+    {
+        res = addIgnoreOverflow(x, y);
+        return x > std::numeric_limits<UInt256>::max() - y;
     }
 
     template <typename T>
@@ -104,24 +110,30 @@ namespace common
     }
 
     template <>
-    inline bool subOverflow(__int128 x, __int128 y, __int128 & res)
+    inline bool subOverflow(Int128 x, Int128 y, Int128 & res)
     {
-        static constexpr __int128 min_int128 = minInt128();
-        static constexpr __int128 max_int128 = maxInt128();
         res = subIgnoreOverflow(x, y);
-        return (y < 0 && x > max_int128 + y) || (y > 0 && x < min_int128 + y);
+        return (y < 0 && x > std::numeric_limits<Int128>::max() + y) ||
+            (y > 0 && x < std::numeric_limits<Int128>::min() + y);
     }
 
     template <>
-    inline bool subOverflow(wInt256 x, wInt256 y, wInt256 & res)
+    inline bool subOverflow(UInt128 x, UInt128 y, UInt128 & res)
     {
         res = subIgnoreOverflow(x, y);
-        return (y < 0 && x > std::numeric_limits<wInt256>::max() + y) ||
-            (y > 0 && x < std::numeric_limits<wInt256>::min() + y);
+        return x < y;
     }
 
     template <>
-    inline bool subOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)
+    inline bool subOverflow(Int256 x, Int256 y, Int256 & res)
+    {
+        res = subIgnoreOverflow(x, y);
+        return (y < 0 && x > std::numeric_limits<Int256>::max() + y) ||
+            (y > 0 && x < std::numeric_limits<Int256>::min() + y);
+    }
+
+    template <>
+    inline bool subOverflow(UInt256 x, UInt256 y, UInt256 & res)
     {
         res = subIgnoreOverflow(x, y);
         return x < y;
@@ -151,36 +163,33 @@ namespace common
         return __builtin_smulll_overflow(x, y, &res);
     }
 
+    /// Overflow check is not implemented for big integers.
+
     template <>
-    inline bool mulOverflow(__int128 x, __int128 y, __int128 & res)
+    inline bool mulOverflow(Int128 x, Int128 y, Int128 & res)
     {
         res = mulIgnoreOverflow(x, y);
-        if (!x || !y)
-            return false;
-
-        unsigned __int128 a = (x > 0) ? x : -x;
-        unsigned __int128 b = (y > 0) ? y : -y;
-        return mulIgnoreOverflow(a, b) / b != a;
+        return false;
     }
 
     template <>
-    inline bool mulOverflow(wInt256 x, wInt256 y, wInt256 & res)
+    inline bool mulOverflow(Int256 x, Int256 y, Int256 & res)
     {
         res = mulIgnoreOverflow(x, y);
-        if (!x || !y)
-            return false;
+        return false;
+    }
 
-        wInt256 a = (x > 0) ? x : -x;
-        wInt256 b = (y > 0) ? y : -y;
-        return mulIgnoreOverflow(a, b) / b != a;
+    template <>
+    inline bool mulOverflow(UInt128 x, UInt128 y, UInt128 & res)
+    {
+        res = mulIgnoreOverflow(x, y);
+        return false;
     }
 
     template <>
-    inline bool mulOverflow(wUInt256 x, wUInt256 y, wUInt256 & res)
+    inline bool mulOverflow(UInt256 x, UInt256 y, UInt256 & res)
     {
         res = mulIgnoreOverflow(x, y);
-        if (!x || !y)
-            return false;
-        return res / y != x;
+        return false;
     }
 }
diff --git a/base/common/extended_types.h b/base/common/extended_types.h
index 2ae70c0f4320..79209568ef51 100644
--- a/base/common/extended_types.h
+++ b/base/common/extended_types.h
@@ -5,16 +5,14 @@
 #include <common/types.h>
 #include <common/wide_integer.h>
 
-using Int128 = __int128;
 
-using wInt256 = wide::integer<256, signed>;
-using wUInt256 = wide::integer<256, unsigned>;
+using Int128 = wide::integer<128, signed>;
+using UInt128 = wide::integer<128, unsigned>;
+using Int256 = wide::integer<256, signed>;
+using UInt256 = wide::integer<256, unsigned>;
 
-static_assert(sizeof(wInt256) == 32);
-static_assert(sizeof(wUInt256) == 32);
-
-static constexpr __int128 minInt128() { return static_cast<unsigned __int128>(1) << 127; }
-static constexpr __int128 maxInt128() { return (static_cast<unsigned __int128>(1) << 127) - 1; }
+static_assert(sizeof(Int256) == 32);
+static_assert(sizeof(UInt256) == 32);
 
 /// The standard library type traits, such as std::is_arithmetic, with one exception
 /// (std::common_type), are "set in stone". Attempting to specialize them causes undefined behavior.
@@ -26,7 +24,7 @@ struct is_signed
 };
 
 template <> struct is_signed<Int128> { static constexpr bool value = true; };
-template <> struct is_signed<wInt256> { static constexpr bool value = true; };
+template <> struct is_signed<Int256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_signed_v = is_signed<T>::value;
@@ -37,7 +35,8 @@ struct is_unsigned
     static constexpr bool value = std::is_unsigned_v<T>;
 };
 
-template <> struct is_unsigned<wUInt256> { static constexpr bool value = true; };
+template <> struct is_unsigned<UInt128> { static constexpr bool value = true; };
+template <> struct is_unsigned<UInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_unsigned_v = is_unsigned<T>::value;
@@ -51,8 +50,9 @@ struct is_integer
 };
 
 template <> struct is_integer<Int128> { static constexpr bool value = true; };
-template <> struct is_integer<wInt256> { static constexpr bool value = true; };
-template <> struct is_integer<wUInt256> { static constexpr bool value = true; };
+template <> struct is_integer<UInt128> { static constexpr bool value = true; };
+template <> struct is_integer<Int256> { static constexpr bool value = true; };
+template <> struct is_integer<UInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_integer_v = is_integer<T>::value;
@@ -64,7 +64,11 @@ struct is_arithmetic
     static constexpr bool value = std::is_arithmetic_v<T>;
 };
 
-template <> struct is_arithmetic<__int128> { static constexpr bool value = true; };
+template <> struct is_arithmetic<Int128> { static constexpr bool value = true; };
+template <> struct is_arithmetic<UInt128> { static constexpr bool value = true; };
+template <> struct is_arithmetic<Int256> { static constexpr bool value = true; };
+template <> struct is_arithmetic<UInt256> { static constexpr bool value = true; };
+
 
 template <typename T>
 inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
@@ -75,9 +79,10 @@ struct make_unsigned
     typedef std::make_unsigned_t<T> type;
 };
 
-template <> struct make_unsigned<Int128> { using type = unsigned __int128; };
-template <> struct make_unsigned<wInt256>  { using type = wUInt256; };
-template <> struct make_unsigned<wUInt256> { using type = wUInt256; };
+template <> struct make_unsigned<Int128> { using type = UInt128; };
+template <> struct make_unsigned<UInt128> { using type = UInt128; };
+template <> struct make_unsigned<Int256>  { using type = UInt256; };
+template <> struct make_unsigned<UInt256> { using type = UInt256; };
 
 template <typename T> using make_unsigned_t = typename make_unsigned<T>::type;
 
@@ -87,8 +92,10 @@ struct make_signed
     typedef std::make_signed_t<T> type;
 };
 
-template <> struct make_signed<wInt256>  { using type = wInt256; };
-template <> struct make_signed<wUInt256> { using type = wInt256; };
+template <> struct make_signed<Int128>  { using type = Int128; };
+template <> struct make_signed<UInt128> { using type = Int128; };
+template <> struct make_signed<Int256>  { using type = Int256; };
+template <> struct make_signed<UInt256> { using type = Int256; };
 
 template <typename T> using make_signed_t = typename make_signed<T>::type;
 
@@ -98,8 +105,10 @@ struct is_big_int
     static constexpr bool value = false;
 };
 
-template <> struct is_big_int<wInt256> { static constexpr bool value = true; };
-template <> struct is_big_int<wUInt256> { static constexpr bool value = true; };
+template <> struct is_big_int<Int128> { static constexpr bool value = true; };
+template <> struct is_big_int<UInt128> { static constexpr bool value = true; };
+template <> struct is_big_int<Int256> { static constexpr bool value = true; };
+template <> struct is_big_int<UInt256> { static constexpr bool value = true; };
 
 template <typename T>
 inline constexpr bool is_big_int_v = is_big_int<T>::value;
diff --git a/base/common/itoa.h b/base/common/itoa.h
index a02e7b68c059..4c86239de36c 100644
--- a/base/common/itoa.h
+++ b/base/common/itoa.h
@@ -30,9 +30,8 @@
 #include <cstddef>
 #include <cstring>
 #include <type_traits>
+#include <common/extended_types.h>
 
-using int128_t = __int128;
-using uint128_t = unsigned __int128;
 
 namespace impl
 {
@@ -106,7 +105,7 @@ using UnsignedOfSize = typename SelectType
     uint16_t,
     uint32_t,
     uint64_t,
-    uint128_t
+    __uint128_t
 >::Result;
 
 /// Holds the result of dividing an unsigned N-byte variable by 10^N resulting in
@@ -313,7 +312,8 @@ namespace convert
     }
 }
 
-static inline int digits10(uint128_t x)
+template <typename T>
+static inline int digits10(T x)
 {
     if (x < 10ULL)
         return 1;
@@ -346,8 +346,11 @@ static inline int digits10(uint128_t x)
     return 12 + digits10(x / 1000000000000ULL);
 }
 
-static inline char * writeUIntText(uint128_t x, char * p)
+template <typename T>
+static inline char * writeUIntText(T x, char * p)
 {
+    static_assert(is_unsigned_v<T>);
+
     int len = digits10(x);
     auto pp = p + len;
     while (x >= 100)
@@ -370,14 +373,28 @@ static inline char * writeLeadingMinus(char * pos)
     return pos + 1;
 }
 
-static inline char * writeSIntText(int128_t x, char * pos)
+template <typename T>
+static inline char * writeSIntText(T x, char * pos)
 {
-    static constexpr int128_t min_int128 = uint128_t(1) << 127;
+    static_assert(std::is_same_v<T, Int128> || std::is_same_v<T, Int256>);
+
+    using UnsignedT = make_unsigned_t<T>;
+    static constexpr T min_int = UnsignedT(1) << (sizeof(T) * 8 - 1);
 
-    if (unlikely(x == min_int128))
+    if (unlikely(x == min_int))
     {
-        memcpy(pos, "-170141183460469231731687303715884105728", 40);
-        return pos + 40;
+        if constexpr (std::is_same_v<T, Int128>)
+        {
+            const char * res = "-170141183460469231731687303715884105728";
+            memcpy(pos, res, strlen(res));
+            return pos + strlen(res);
+        }
+        else if constexpr (std::is_same_v<T, Int256>)
+        {
+            const char * res = "-57896044618658097711785492504343953926634992332820282019728792003956564819968";
+            memcpy(pos, res, strlen(res));
+            return pos + strlen(res);
+        }
     }
 
     if (x < 0)
@@ -385,7 +402,7 @@ static inline char * writeSIntText(int128_t x, char * pos)
         x = -x;
         pos = writeLeadingMinus(pos);
     }
-    return writeUIntText(static_cast<uint128_t>(x), pos);
+    return writeUIntText(UnsignedT(x), pos);
 }
 
 }
@@ -403,13 +420,25 @@ inline char * itoa(char8_t i, char * p)
 }
 
 template <>
-inline char * itoa<uint128_t>(uint128_t i, char * p)
+inline char * itoa(UInt128 i, char * p)
+{
+    return impl::writeUIntText(i, p);
+}
+
+template <>
+inline char * itoa(Int128 i, char * p)
+{
+    return impl::writeSIntText(i, p);
+}
+
+template <>
+inline char * itoa(UInt256 i, char * p)
 {
     return impl::writeUIntText(i, p);
 }
 
 template <>
-inline char * itoa<int128_t>(int128_t i, char * p)
+inline char * itoa(Int256 i, char * p)
 {
     return impl::writeSIntText(i, p);
 }
diff --git a/base/common/strong_typedef.h b/base/common/strong_typedef.h
index 77b83bfa6e5f..a1e2b253aa70 100644
--- a/base/common/strong_typedef.h
+++ b/base/common/strong_typedef.h
@@ -4,7 +4,8 @@
 #include <type_traits>
 #include <utility>
 
-template <class T, class Tag>
+
+template <typename T, typename Tag>
 struct StrongTypedef
 {
 private:
@@ -38,14 +39,16 @@ struct StrongTypedef
 
     bool operator==(const Self & rhs) const { return t == rhs.t; }
     bool operator<(const Self & rhs) const { return t < rhs.t; }
+    bool operator>(const Self & rhs) const { return t > rhs.t; }
 
     T & toUnderType() { return t; }
     const T & toUnderType() const { return t; }
 };
 
+
 namespace std
 {
-    template <class T, class Tag>
+    template <typename T, typename Tag>
     struct hash<StrongTypedef<T, Tag>>
     {
         size_t operator()(const StrongTypedef<T, Tag> & x) const
diff --git a/base/common/throwError.h b/base/common/throwError.h
index b495a0fbc7af..dd352913e78c 100644
--- a/base/common/throwError.h
+++ b/base/common/throwError.h
@@ -1,13 +1,15 @@
 #pragma once
+
 #include <stdexcept>
 
+
 /// Throw DB::Exception-like exception before its definition.
 /// DB::Exception derived from Poco::Exception derived from std::exception.
-/// DB::Exception generally cought as Poco::Exception. std::exception generally has other catch blocks and could lead to other outcomes.
+/// DB::Exception generally caught as Poco::Exception. std::exception generally has other catch blocks and could lead to other outcomes.
 /// DB::Exception is not defined yet. It'd better to throw Poco::Exception but we do not want to include any big header here, even <string>.
 /// So we throw some std::exception instead in the hope its catch block is the same as DB::Exception one.
 template <typename T>
-inline void throwError(const T & err)
+[[noreturn]] inline void throwError(const T & err)
 {
     throw std::runtime_error(err);
 }
diff --git a/base/common/wide_integer.h b/base/common/wide_integer.h
index c9d1eaa32aa8..419b4e4558c6 100644
--- a/base/common/wide_integer.h
+++ b/base/common/wide_integer.h
@@ -58,9 +58,11 @@ class integer
     using signed_base_type = int64_t;
 
     // ctors
-    constexpr integer() noexcept;
+    constexpr integer() noexcept = default;
+
     template <typename T>
     constexpr integer(T rhs) noexcept;
+
     template <typename T>
     constexpr integer(std::initializer_list<T> il) noexcept;
 
@@ -108,9 +110,9 @@ class integer
     constexpr explicit operator bool() const noexcept;
 
     template <class T>
-    using __integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;
+    using _integral_not_wide_integer_class = typename std::enable_if<std::is_arithmetic<T>::value, T>::type;
 
-    template <class T, class = __integral_not_wide_integer_class<T>>
+    template <class T, class = _integral_not_wide_integer_class<T>>
     constexpr operator T() const noexcept;
 
     constexpr operator long double() const noexcept;
@@ -119,25 +121,27 @@ class integer
 
     struct _impl;
 
+    base_type items[_impl::item_count];
+
 private:
     template <size_t Bits2, typename Signed2>
     friend class integer;
 
     friend class std::numeric_limits<integer<Bits, signed>>;
     friend class std::numeric_limits<integer<Bits, unsigned>>;
-
-    base_type items[_impl::item_count];
 };
 
 template <typename T>
 static constexpr bool ArithmeticConcept() noexcept;
+
 template <class T1, class T2>
-using __only_arithmetic = typename std::enable_if<ArithmeticConcept<T1>() && ArithmeticConcept<T2>()>::type;
+using _only_arithmetic = typename std::enable_if<ArithmeticConcept<T1>() && ArithmeticConcept<T2>()>::type;
 
 template <typename T>
 static constexpr bool IntegralConcept() noexcept;
+
 template <class T, class T2>
-using __only_integer = typename std::enable_if<IntegralConcept<T>() && IntegralConcept<T2>()>::type;
+using _only_integer = typename std::enable_if<IntegralConcept<T>() && IntegralConcept<T2>()>::type;
 
 // Unary operators
 template <size_t Bits, typename Signed>
@@ -153,54 +157,55 @@ constexpr integer<Bits, Signed> operator+(const integer<Bits, Signed> & lhs) noe
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator*(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 std::common_type_t<Arithmetic, Arithmetic2> constexpr operator*(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator/(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 std::common_type_t<Arithmetic, Arithmetic2> constexpr operator/(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator+(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 std::common_type_t<Arithmetic, Arithmetic2> constexpr operator+(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator-(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 std::common_type_t<Arithmetic, Arithmetic2> constexpr operator-(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator%(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>
 std::common_type_t<Integral, Integral2> constexpr operator%(const Integral & rhs, const Integral2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator&(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>
 std::common_type_t<Integral, Integral2> constexpr operator&(const Integral & rhs, const Integral2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator|(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>
 std::common_type_t<Integral, Integral2> constexpr operator|(const Integral & rhs, const Integral2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>> constexpr
 operator^(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Integral, typename Integral2, class = __only_integer<Integral, Integral2>>
+template <typename Integral, typename Integral2, class = _only_integer<Integral, Integral2>>
 std::common_type_t<Integral, Integral2> constexpr operator^(const Integral & rhs, const Integral2 & lhs);
 
 // TODO: Integral
 template <size_t Bits, typename Signed>
 constexpr integer<Bits, Signed> operator<<(const integer<Bits, Signed> & lhs, int n) noexcept;
+
 template <size_t Bits, typename Signed>
 constexpr integer<Bits, Signed> operator>>(const integer<Bits, Signed> & lhs, int n) noexcept;
 
@@ -217,32 +222,32 @@ constexpr integer<Bits, Signed> operator>>(const integer<Bits, Signed> & lhs, In
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator<(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 constexpr bool operator<(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator>(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 constexpr bool operator>(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator<=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 constexpr bool operator<=(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator>=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 constexpr bool operator>=(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator==(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 constexpr bool operator==(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator!=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs);
-template <typename Arithmetic, typename Arithmetic2, class = __only_arithmetic<Arithmetic, Arithmetic2>>
+template <typename Arithmetic, typename Arithmetic2, class = _only_arithmetic<Arithmetic, Arithmetic2>>
 constexpr bool operator!=(const Arithmetic & rhs, const Arithmetic2 & lhs);
 
 }
diff --git a/base/common/wide_integer_impl.h b/base/common/wide_integer_impl.h
index 456c10a22e43..725caec6a3ef 100644
--- a/base/common/wide_integer_impl.h
+++ b/base/common/wide_integer_impl.h
@@ -5,6 +5,7 @@
 /// (See at http://www.boost.org/LICENSE_1_0.txt)
 
 #include "throwError.h"
+
 #include <cmath>
 #include <cfloat>
 #include <cassert>
@@ -81,7 +82,7 @@ class numeric_limits<wide::integer<Bits, Signed>>
             res.items[T::_impl::big(0)] = std::numeric_limits<typename wide::integer<Bits, Signed>::signed_base_type>::min();
             return res;
         }
-        return 0;
+        return wide::integer<Bits, Signed>(0);
     }
 
     static constexpr wide::integer<Bits, Signed> max() noexcept
@@ -176,7 +177,7 @@ struct integer<Bits, Signed>::_impl
     constexpr static bool is_negative(const integer<B, T> & n) noexcept
     {
         if constexpr (std::is_same_v<T, signed>)
-            return static_cast<signed_base_type>(n.items[big(0)]) < 0;
+            return static_cast<signed_base_type>(n.items[integer<B, T>::_impl::big(0)]) < 0;
         else
             return false;
     }
@@ -193,40 +194,36 @@ struct integer<Bits, Signed>::_impl
     template <size_t B, class S>
     constexpr static integer<B, S> make_positive(const integer<B, S> & n) noexcept
     {
-        return is_negative(n) ? operator_unary_minus(n) : n;
+        return is_negative(n) ? integer<B, S>(operator_unary_minus(n)) : n;
     }
 
     template <typename T>
     __attribute__((no_sanitize("undefined"))) constexpr static auto to_Integral(T f) noexcept
     {
-        if constexpr (std::is_same_v<T, __int128>)
-            return f;
-        else if constexpr (std::is_signed_v<T>)
+        if constexpr (std::is_signed_v<T>)
             return static_cast<int64_t>(f);
         else
             return static_cast<uint64_t>(f);
     }
 
     template <typename Integral>
-    constexpr static void wide_integer_from_bultin(integer<Bits, Signed> & self, Integral rhs) noexcept
+    constexpr static void wide_integer_from_builtin(integer<Bits, Signed> & self, Integral rhs) noexcept
     {
-        self.items[0] = _impl::to_Integral(rhs);
-        if constexpr (std::is_same_v<Integral, __int128>)
-            self.items[1] = rhs >> base_bits;
+        static_assert(sizeof(Integral) <= sizeof(base_type));
 
-        constexpr const unsigned start = (sizeof(Integral) == 16) ? 2 : 1;
+        self.items[0] = _impl::to_Integral(rhs);
 
         if constexpr (std::is_signed_v<Integral>)
         {
             if (rhs < 0)
             {
-                for (unsigned i = start; i < item_count; ++i)
+                for (size_t i = 1; i < item_count; ++i)
                     self.items[i] = -1;
                 return;
             }
         }
 
-        for (unsigned i = start; i < item_count; ++i)
+        for (size_t i = 1; i < item_count; ++i)
             self.items[i] = 0;
     }
 
@@ -239,7 +236,8 @@ struct integer<Bits, Signed>::_impl
      * a_(n - 1) = a_n * max_int + b2, a_n <= max_int <- base case.
      */
     template <class T>
-    constexpr static void set_multiplier(integer<Bits, Signed> & self, T t) noexcept {
+    constexpr static void set_multiplier(integer<Bits, Signed> & self, T t) noexcept
+    {
         constexpr uint64_t max_int = std::numeric_limits<uint64_t>::max();
 
         /// Implementation specific behaviour on overflow (if we don't check here, stack overflow will triggered in bigint_cast).
@@ -260,7 +258,8 @@ struct integer<Bits, Signed>::_impl
         self += static_cast<uint64_t>(t - alpha * static_cast<T>(max_int)); // += b_i
     }
 
-    constexpr static void wide_integer_from_bultin(integer<Bits, Signed>& self, double rhs) noexcept {
+    constexpr static void wide_integer_from_builtin(integer<Bits, Signed>& self, double rhs) noexcept
+    {
         constexpr int64_t max_int = std::numeric_limits<int64_t>::max();
         constexpr int64_t min_int = std::numeric_limits<int64_t>::min();
 
@@ -383,13 +382,13 @@ struct integer<Bits, Signed>::_impl
             if (bit_shift)
                 lhs.items[big(items_shift)] |= std::numeric_limits<base_type>::max() << (base_bits - bit_shift);
 
-            for (unsigned i = item_count - items_shift; i < items_shift; ++i)
-                lhs.items[little(i)] = std::numeric_limits<base_type>::max();
+            for (unsigned i = 0; i < items_shift; ++i)
+                lhs.items[big(i)] = std::numeric_limits<base_type>::max();
         }
         else
         {
-            for (unsigned i = item_count - items_shift; i < items_shift; ++i)
-                lhs.items[little(i)] = 0;
+            for (unsigned i = 0; i < items_shift; ++i)
+                lhs.items[big(i)] = 0;
         }
 
         return lhs;
@@ -397,23 +396,23 @@ struct integer<Bits, Signed>::_impl
 
 private:
     template <typename T>
-    constexpr static base_type get_item(const T & x, unsigned number)
+    constexpr static base_type get_item(const T & x, unsigned idx)
     {
         if constexpr (IsWideInteger<T>::value)
         {
-            if (number < T::_impl::item_count)
-                return x.items[number];
+            if (idx < T::_impl::item_count)
+                return x.items[idx];
             return 0;
         }
         else
         {
             if constexpr (sizeof(T) <= sizeof(base_type))
             {
-                if (!number)
+                if (0 == idx)
                     return x;
             }
-            else if (number * sizeof(base_type) < sizeof(T))
-                return x >> (number * base_bits); // & std::numeric_limits<base_type>::max()
+            else if (idx * sizeof(base_type) < sizeof(T))
+                return x >> (idx * base_bits); // & std::numeric_limits<base_type>::max()
             return 0;
         }
     }
@@ -439,7 +438,7 @@ struct integer<Bits, Signed>::_impl
 
         for (unsigned i = 1; i < item_count; ++i)
         {
-            if (underflows[i-1])
+            if (underflows[i - 1])
             {
                 base_type & res_item = res.items[little(i)];
                 if (res_item == 0)
@@ -472,7 +471,7 @@ struct integer<Bits, Signed>::_impl
 
         for (unsigned i = 1; i < item_count; ++i)
         {
-            if (overflows[i-1])
+            if (overflows[i - 1])
             {
                 base_type & res_item = res.items[little(i)];
                 ++res_item;
@@ -532,6 +531,17 @@ struct integer<Bits, Signed>::_impl
             res.items[little(2)] = r12 >> 64;
             return res;
         }
+        else if constexpr (Bits == 128 && sizeof(base_type) == 8)
+        {
+            using CompilerUInt128 = unsigned __int128;
+            CompilerUInt128 a = (CompilerUInt128(lhs.items[1]) << 64) + lhs.items[0];
+            CompilerUInt128 b = (CompilerUInt128(rhs.items[1]) << 64) + rhs.items[0];
+            CompilerUInt128 c = a * b;
+            integer<Bits, Signed> res;
+            res.items[0] = c;
+            res.items[1] = c >> 64;
+            return res;
+        }
         else
         {
             integer<Bits, Signed> res{};
@@ -657,7 +667,7 @@ struct integer<Bits, Signed>::_impl
     }
 
     template <typename T>
-    constexpr static bool operator_more(const integer<Bits, Signed> & lhs, const T & rhs) noexcept
+    constexpr static bool operator_greater(const integer<Bits, Signed> & lhs, const T & rhs) noexcept
     {
         if constexpr (should_keep_size<T>())
         {
@@ -677,7 +687,7 @@ struct integer<Bits, Signed>::_impl
         else
         {
             static_assert(IsWideInteger<T>::value);
-            return std::common_type_t<integer<Bits, Signed>, T>::_impl::operator_more(T(lhs), rhs);
+            return std::common_type_t<integer<Bits, Signed>, T>::_impl::operator_greater(T(lhs), rhs);
         }
     }
 
@@ -764,7 +774,6 @@ struct integer<Bits, Signed>::_impl
         }
     }
 
-private:
     template <typename T>
     constexpr static bool is_zero(const T & x)
     {
@@ -781,46 +790,65 @@ struct integer<Bits, Signed>::_impl
     }
 
     /// returns quotient as result and remainder in numerator.
-    template <typename T>
-    constexpr static T divide(T & numerator, T && denominator)
+    template <size_t Bits2>
+    constexpr static integer<Bits2, unsigned> divide(integer<Bits2, unsigned> & numerator, integer<Bits2, unsigned> denominator)
     {
+        static_assert(std::is_unsigned_v<Signed>);
+
+        if constexpr (Bits == 128 && sizeof(base_type) == 8)
+        {
+            using CompilerUInt128 = unsigned __int128;
+
+            CompilerUInt128 a = (CompilerUInt128(numerator.items[1]) << 64) + numerator.items[0];
+            CompilerUInt128 b = (CompilerUInt128(denominator.items[1]) << 64) + denominator.items[0];
+            CompilerUInt128 c = a / b;
+
+            integer<Bits, Signed> res;
+            res.items[0] = c;
+            res.items[1] = c >> 64;
+
+            CompilerUInt128 remainder = a - b * c;
+            numerator.items[0] = remainder;
+            numerator.items[1] = remainder >> 64;
+
+            return res;
+        }
+
         if (is_zero(denominator))
-            throwError("divide by zero");
+            throwError("Division by zero");
 
-        T & n = numerator;
-        T & d = denominator;
-        T x = 1;
-        T quotient = 0;
+        integer<Bits2, unsigned> x = 1;
+        integer<Bits2, unsigned> quotient = 0;
 
-        while (!operator_more(d, n) && operator_eq(operator_amp(shift_right(d, base_bits * item_count - 1), 1), 0))
+        while (!operator_greater(denominator, numerator) && is_zero(operator_amp(shift_right(denominator, Bits2 - 1), 1)))
         {
             x = shift_left(x, 1);
-            d = shift_left(d, 1);
+            denominator = shift_left(denominator, 1);
         }
 
-        while (!operator_eq(x, 0))
+        while (!is_zero(x))
         {
-            if (!operator_more(d, n))
+            if (!operator_greater(denominator, numerator))
             {
-                n = operator_minus(n, d);
+                numerator = operator_minus(numerator, denominator);
                 quotient = operator_pipe(quotient, x);
             }
 
             x = shift_right(x, 1);
-            d = shift_right(d, 1);
+            denominator = shift_right(denominator, 1);
         }
 
         return quotient;
     }
 
-public:
     template <typename T>
     constexpr static auto operator_slash(const integer<Bits, Signed> & lhs, const T & rhs)
     {
         if constexpr (should_keep_size<T>())
         {
-            integer<Bits, Signed> numerator = make_positive(lhs);
-            integer<Bits, Signed> quotient = divide(numerator, make_positive(integer<Bits, Signed>(rhs)));
+            integer<Bits, unsigned> numerator = make_positive(lhs);
+            integer<Bits, unsigned> denominator = make_positive(integer<Bits, Signed>(rhs));
+            integer<Bits, unsigned> quotient = integer<Bits, unsigned>::_impl::divide(numerator, std::move(denominator));
 
             if (std::is_same_v<Signed, signed> && is_negative(rhs) != is_negative(lhs))
                 quotient = operator_unary_minus(quotient);
@@ -838,8 +866,9 @@ struct integer<Bits, Signed>::_impl
     {
         if constexpr (should_keep_size<T>())
         {
-            integer<Bits, Signed> remainder = make_positive(lhs);
-            divide(remainder, make_positive(integer<Bits, Signed>(rhs)));
+            integer<Bits, unsigned> remainder = make_positive(lhs);
+            integer<Bits, unsigned> denominator = make_positive(integer<Bits, Signed>(rhs));
+            integer<Bits, unsigned>::_impl::divide(remainder, std::move(denominator));
 
             if (std::is_same_v<Signed, signed> && is_negative(lhs))
                 remainder = operator_unary_minus(remainder);
@@ -905,7 +934,7 @@ struct integer<Bits, Signed>::_impl
                     ++c;
                 }
                 else
-                    throwError("invalid char from");
+                    throwError("Invalid char from");
             }
         }
         else
@@ -913,7 +942,7 @@ struct integer<Bits, Signed>::_impl
             while (*c)
             {
                 if (*c < '0' || *c > '9')
-                    throwError("invalid char from");
+                    throwError("Invalid char from");
 
                 res = multiply(res, 10U);
                 res = plus(res, *c - '0');
@@ -930,11 +959,6 @@ struct integer<Bits, Signed>::_impl
 
 // Members
 
-template <size_t Bits, typename Signed>
-constexpr integer<Bits, Signed>::integer() noexcept
-    : items{}
-{}
-
 template <size_t Bits, typename Signed>
 template <typename T>
 constexpr integer<Bits, Signed>::integer(T rhs) noexcept
@@ -943,7 +967,7 @@ constexpr integer<Bits, Signed>::integer(T rhs) noexcept
     if constexpr (IsWideInteger<T>::value)
         _impl::wide_integer_from_wide_integer(*this, rhs);
     else
-        _impl::wide_integer_from_bultin(*this, rhs);
+        _impl::wide_integer_from_builtin(*this, rhs);
 }
 
 template <size_t Bits, typename Signed>
@@ -956,10 +980,19 @@ constexpr integer<Bits, Signed>::integer(std::initializer_list<T> il) noexcept
         if constexpr (IsWideInteger<T>::value)
             _impl::wide_integer_from_wide_integer(*this, *il.begin());
         else
-            _impl::wide_integer_from_bultin(*this, *il.begin());
+            _impl::wide_integer_from_builtin(*this, *il.begin());
+    }
+    else if (il.size() == 0)
+    {
+        _impl::wide_integer_from_builtin(*this, 0);
     }
     else
-        _impl::wide_integer_from_bultin(*this, 0);
+    {
+        auto it = il.begin();
+        for (size_t i = 0; i < _impl::item_count; ++i)
+            if (it < il.end())
+                items[i] = *it;
+    }
 }
 
 template <size_t Bits, typename Signed>
@@ -974,7 +1007,7 @@ template <size_t Bits, typename Signed>
 template <typename T>
 constexpr integer<Bits, Signed> & integer<Bits, Signed>::operator=(T rhs) noexcept
 {
-    _impl::wide_integer_from_bultin(*this, rhs);
+    _impl::wide_integer_from_builtin(*this, rhs);
     return *this;
 }
 
@@ -1057,7 +1090,7 @@ constexpr integer<Bits, Signed> & integer<Bits, Signed>::operator>>=(int n) noex
 {
     if (static_cast<size_t>(n) >= Bits)
     {
-        if (is_negative(*this))
+        if (_impl::is_negative(*this))
             *this = -1;
         else
             *this = 0;
@@ -1107,16 +1140,17 @@ template <size_t Bits, typename Signed>
 template <class T, class>
 constexpr integer<Bits, Signed>::operator T() const noexcept
 {
-    if constexpr (std::is_same_v<T, __int128>)
-    {
-        static_assert(Bits >= 128);
-        return (__int128(items[1]) << 64) | items[0];
-    }
-    else
-    {
-        static_assert(std::numeric_limits<T>::is_integer);
-        return items[0];
-    }
+    static_assert(std::numeric_limits<T>::is_integer);
+
+    /// NOTE: memcpy will suffice, but unfortunately, this function is constexpr.
+
+    using UnsignedT = std::make_unsigned_t<T>;
+
+    UnsignedT res{};
+    for (unsigned i = 0; i < _impl::item_count && i < (sizeof(T) + sizeof(base_type) - 1) / sizeof(base_type); ++i)
+        res += UnsignedT(items[i]) << (sizeof(base_type) * 8 * i);
+
+    return res;
 }
 
 template <size_t Bits, typename Signed>
@@ -1280,7 +1314,7 @@ template <size_t Bits, typename Signed>
 constexpr integer<Bits, Signed> operator<<(const integer<Bits, Signed> & lhs, int n) noexcept
 {
     if (static_cast<size_t>(n) >= Bits)
-        return 0;
+        return integer<Bits, Signed>(0);
     if (n <= 0)
         return lhs;
     return integer<Bits, Signed>::_impl::shift_left(lhs, n);
@@ -1289,7 +1323,7 @@ template <size_t Bits, typename Signed>
 constexpr integer<Bits, Signed> operator>>(const integer<Bits, Signed> & lhs, int n) noexcept
 {
     if (static_cast<size_t>(n) >= Bits)
-        return 0;
+        return integer<Bits, Signed>(0);
     if (n <= 0)
         return lhs;
     return integer<Bits, Signed>::_impl::shift_right(lhs, n);
@@ -1309,7 +1343,7 @@ constexpr bool operator<(const Arithmetic & lhs, const Arithmetic2 & rhs)
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator>(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs)
 {
-    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs);
+    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_greater(lhs, rhs);
 }
 template <typename Arithmetic, typename Arithmetic2, class>
 constexpr bool operator>(const Arithmetic & lhs, const Arithmetic2 & rhs)
@@ -1332,7 +1366,7 @@ constexpr bool operator<=(const Arithmetic & lhs, const Arithmetic2 & rhs)
 template <size_t Bits, typename Signed, size_t Bits2, typename Signed2>
 constexpr bool operator>=(const integer<Bits, Signed> & lhs, const integer<Bits2, Signed2> & rhs)
 {
-    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_more(lhs, rhs)
+    return std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_greater(lhs, rhs)
         || std::common_type_t<integer<Bits, Signed>, integer<Bits2, Signed2>>::_impl::operator_eq(lhs, rhs);
 }
 template <typename Arithmetic, typename Arithmetic2, class>
diff --git a/base/common/wide_integer_to_string.h b/base/common/wide_integer_to_string.h
index 9908ef4be7a8..8b794fe9bcb2 100644
--- a/base/common/wide_integer_to_string.h
+++ b/base/common/wide_integer_to_string.h
@@ -1,9 +1,12 @@
 #pragma once
 
 #include <string>
+#include <ostream>
+#include <fmt/format.h>
 
 #include "wide_integer.h"
 
+
 namespace wide
 {
 
@@ -33,3 +36,34 @@ inline std::string to_string(const integer<Bits, Signed> & n)
 }
 
 }
+
+
+template <size_t Bits, typename Signed>
+std::ostream & operator<<(std::ostream & out, const wide::integer<Bits, Signed> & value)
+{
+    return out << to_string(value);
+}
+
+
+/// See https://fmt.dev/latest/api.html#formatting-user-defined-types
+template <size_t Bits, typename Signed>
+struct fmt::formatter<wide::integer<Bits, Signed>>
+{
+    constexpr auto parse(format_parse_context & ctx)
+    {
+        auto it = ctx.begin();
+        auto end = ctx.end();
+
+        /// Only support {}.
+        if (it != end && *it != '}')
+            throw format_error("invalid format");
+
+        return it;
+    }
+
+    template <typename FormatContext>
+    auto format(const wide::integer<Bits, Signed> & value, FormatContext & ctx)
+    {
+        return format_to(ctx.out(), "{}", to_string(value));
+    }
+};
diff --git a/programs/client/QueryFuzzer.h b/programs/client/QueryFuzzer.h
index 9ef66db18737..7c79e683eb4e 100644
--- a/programs/client/QueryFuzzer.h
+++ b/programs/client/QueryFuzzer.h
@@ -4,11 +4,14 @@
 #include <unordered_map>
 #include <vector>
 
+#include <pcg-random/pcg_random.hpp>
+
 #include <Common/randomSeed.h>
 #include <Common/Stopwatch.h>
 #include <Core/Field.h>
 #include <Parsers/IAST.h>
 
+
 namespace DB
 {
 
diff --git a/programs/git-import/git-import.cpp b/programs/git-import/git-import.cpp
index b07435dcf781..7977cfba79d3 100644
--- a/programs/git-import/git-import.cpp
+++ b/programs/git-import/git-import.cpp
@@ -774,7 +774,7 @@ UInt128 diffHash(const CommitDiff & file_changes)
     }
 
     UInt128 hash_of_diff;
-    hasher.get128(hash_of_diff.low, hash_of_diff.high);
+    hasher.get128(hash_of_diff.items[0], hash_of_diff.items[1]);
 
     return hash_of_diff;
 }
diff --git a/programs/obfuscator/Obfuscator.cpp b/programs/obfuscator/Obfuscator.cpp
index c92eb5c66474..fb6817fbf806 100644
--- a/programs/obfuscator/Obfuscator.cpp
+++ b/programs/obfuscator/Obfuscator.cpp
@@ -365,16 +365,20 @@ static void transformFixedString(const UInt8 * src, UInt8 * dst, size_t size, UI
     }
 }
 
-static void transformUUID(const UInt128 & src, UInt128 & dst, UInt64 seed)
+static void transformUUID(const UUID & src_uuid, UUID & dst_uuid, UInt64 seed)
 {
+    const UInt128 & src = src_uuid.toUnderType();
+    UInt128 & dst = dst_uuid.toUnderType();
+
     SipHash hash;
     hash.update(seed);
-    hash.update(reinterpret_cast<const char *>(&src), sizeof(UInt128));
+    hash.update(reinterpret_cast<const char *>(&src), sizeof(UUID));
 
     /// Saving version and variant from an old UUID
     hash.get128(reinterpret_cast<char *>(&dst));
-    dst.high = (dst.high & 0x1fffffffffffffffull) | (src.high & 0xe000000000000000ull);
-    dst.low = (dst.low & 0xffffffffffff0fffull) | (src.low & 0x000000000000f000ull);
+
+    dst.items[1] = (dst.items[1] & 0x1fffffffffffffffull) | (src.items[1] & 0xe000000000000000ull);
+    dst.items[0] = (dst.items[0] & 0xffffffffffff0fffull) | (src.items[0] & 0x000000000000f000ull);
 }
 
 class FixedStringModel : public IModel
@@ -426,10 +430,10 @@ class UUIDModel : public IModel
 
     ColumnPtr generate(const IColumn & column) override
     {
-        const ColumnUInt128 & src_column = assert_cast<const ColumnUInt128 &>(column);
+        const ColumnUUID & src_column = assert_cast<const ColumnUUID &>(column);
         const auto & src_data = src_column.getData();
 
-        auto res_column = ColumnUInt128::create();
+        auto res_column = ColumnUUID::create();
         auto & res_data = res_column->getData();
 
         res_data.resize(src_data.size());
diff --git a/programs/odbc-bridge/ODBCBlockOutputStream.cpp b/programs/odbc-bridge/ODBCBlockOutputStream.cpp
index bdbe8add37eb..dc965b3b2a79 100644
--- a/programs/odbc-bridge/ODBCBlockOutputStream.cpp
+++ b/programs/odbc-bridge/ODBCBlockOutputStream.cpp
@@ -1,5 +1,6 @@
 #include "ODBCBlockOutputStream.h"
 
+#include <Common/hex.h>
 #include <common/logger_useful.h>
 #include <Core/Field.h>
 #include <common/LocalDate.h>
@@ -37,7 +38,6 @@ namespace
         query.IAST::format(settings);
         return buf.str();
     }
-
 }
 
 ODBCBlockOutputStream::ODBCBlockOutputStream(nanodbc::ConnectionHolderPtr connection_,
diff --git a/src/Access/IAccessStorage.h b/src/Access/IAccessStorage.h
index 2cdd8eabf731..cc9146641499 100644
--- a/src/Access/IAccessStorage.h
+++ b/src/Access/IAccessStorage.h
@@ -1,7 +1,7 @@
 #pragma once
 
 #include <Access/IAccessEntity.h>
-#include <common/types.h>
+#include <Core/Types.h>
 #include <Core/UUID.h>
 #include <ext/scope_guard.h>
 #include <functional>
diff --git a/src/Access/RolesOrUsersSet.h b/src/Access/RolesOrUsersSet.h
index 0d8983c2ec39..871bb0c0758e 100644
--- a/src/Access/RolesOrUsersSet.h
+++ b/src/Access/RolesOrUsersSet.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <Core/UUID.h>
+#include <Core/Types.h>
 #include <boost/container/flat_set.hpp>
 #include <memory>
 #include <optional>
diff --git a/src/Access/RowPolicy.h b/src/Access/RowPolicy.h
index c9b4d69152de..723db545dbeb 100644
--- a/src/Access/RowPolicy.h
+++ b/src/Access/RowPolicy.h
@@ -2,6 +2,7 @@
 
 #include <Access/IAccessEntity.h>
 #include <Access/RolesOrUsersSet.h>
+#include <Core/Types.h>
 #include <array>
 
 
diff --git a/src/AggregateFunctions/AggregateFunctionAvg.h b/src/AggregateFunctions/AggregateFunctionAvg.h
index 8a6491d9b61a..f2ea51ac28dd 100644
--- a/src/AggregateFunctions/AggregateFunctionAvg.h
+++ b/src/AggregateFunctions/AggregateFunctionAvg.h
@@ -7,7 +7,7 @@
 #include <DataTypes/DataTypesDecimal.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <AggregateFunctions/IAggregateFunction.h>
-#include "Core/DecimalFunctions.h"
+#include <Core/DecimalFunctions.h>
 
 
 namespace DB
diff --git a/src/AggregateFunctions/AggregateFunctionAvgWeighted.h b/src/AggregateFunctions/AggregateFunctionAvgWeighted.h
index f8b452fc4445..8b932918aa5a 100644
--- a/src/AggregateFunctions/AggregateFunctionAvgWeighted.h
+++ b/src/AggregateFunctions/AggregateFunctionAvgWeighted.h
@@ -5,18 +5,18 @@
 
 namespace DB
 {
-template <class T>
+template <typename T>
 using AvgWeightedFieldType = std::conditional_t<IsDecimalNumber<T>,
     std::conditional_t<std::is_same_v<T, Decimal256>, Decimal256, Decimal128>,
     std::conditional_t<DecimalOrExtendedInt<T>,
         Float64, // no way to do UInt128 * UInt128, better cast to Float64
         NearestFieldType<T>>>;
 
-template <class T, class U>
+template <typename T, typename U>
 using MaxFieldType = std::conditional_t<(sizeof(AvgWeightedFieldType<T>) > sizeof(AvgWeightedFieldType<U>)),
     AvgWeightedFieldType<T>, AvgWeightedFieldType<U>>;
 
-template <class Value, class Weight>
+template <typename Value, typename Weight>
 class AggregateFunctionAvgWeighted final :
     public AggregateFunctionAvgBase<
         MaxFieldType<Value, Weight>, AvgWeightedFieldType<Weight>, AggregateFunctionAvgWeighted<Value, Weight>>
diff --git a/src/AggregateFunctions/AggregateFunctionBoundingRatio.h b/src/AggregateFunctions/AggregateFunctionBoundingRatio.h
index 15b355f51a6b..bee58a4a9322 100644
--- a/src/AggregateFunctions/AggregateFunctionBoundingRatio.h
+++ b/src/AggregateFunctions/AggregateFunctionBoundingRatio.h
@@ -2,7 +2,6 @@
 
 #include <DataTypes/DataTypesNumber.h>
 #include <Columns/ColumnsNumber.h>
-#include <Common/FieldVisitors.h>
 #include <IO/ReadHelpers.h>
 #include <IO/WriteHelpers.h>
 #include <AggregateFunctions/Helpers.h>
diff --git a/src/AggregateFunctions/AggregateFunctionDistinct.h b/src/AggregateFunctions/AggregateFunctionDistinct.h
index b587bbebf6e2..b551f8a4ec50 100644
--- a/src/AggregateFunctions/AggregateFunctionDistinct.h
+++ b/src/AggregateFunctions/AggregateFunctionDistinct.h
@@ -10,7 +10,6 @@
 #include <Common/HashTable/HashMap.h>
 #include <Common/SipHash.h>
 
-#include <Common/FieldVisitors.h>
 
 namespace DB
 {
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArray.h b/src/AggregateFunctions/AggregateFunctionGroupArray.h
index 921274f7d59f..e59f19e3baed 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArray.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupArray.h
@@ -296,12 +296,7 @@ class GroupArrayNumericImpl final
         if (size)
         {
             typename ColumnVector<T>::Container & data_to = assert_cast<ColumnVector<T> &>(arr_to.getData()).getData();
-            if constexpr (is_big_int_v<T>)
-                // is data_to empty? we should probably use std::vector::insert then
-                for (auto it = this->data(place).value.begin(); it != this->data(place).value.end(); it++)
-                    data_to.push_back(*it);
-            else
-                data_to.insert(this->data(place).value.begin(), this->data(place).value.end());
+            data_to.insert(this->data(place).value.begin(), this->data(place).value.end());
         }
     }
 
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
index e2139ba882fc..b6e9fda95591 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
@@ -21,6 +21,7 @@ namespace ErrorCodes
 namespace
 {
 
+/// TODO Proper support for Decimal256.
 template <typename T, typename LimitNumberOfElements>
 struct MovingSum
 {
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h
index 3bab831d3163..8b7109ae3ef8 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h
@@ -38,7 +38,7 @@ struct MovingData
     using Array = PODArray<T, 32, Allocator>;
 
     Array value;    /// Prefix sums.
-    T sum = 0;
+    T sum{};
 
     void NO_SANITIZE_UNDEFINED add(T val, Arena * arena)
     {
@@ -69,9 +69,9 @@ struct MovingAvgData : public MovingData<T>
     T NO_SANITIZE_UNDEFINED get(size_t idx, UInt64 window_size) const
     {
         if (idx < window_size)
-            return this->value[idx] / window_size;
+            return this->value[idx] / T(window_size);
         else
-            return (this->value[idx] - this->value[idx - window_size]) / window_size;
+            return (this->value[idx] - this->value[idx - window_size]) / T(window_size);
     }
 };
 
diff --git a/src/AggregateFunctions/AggregateFunctionMannWhitney.h b/src/AggregateFunctions/AggregateFunctionMannWhitney.h
index 7efdebf16391..7573de65cc0c 100644
--- a/src/AggregateFunctions/AggregateFunctionMannWhitney.h
+++ b/src/AggregateFunctions/AggregateFunctionMannWhitney.h
@@ -6,7 +6,6 @@
 #include <Columns/ColumnVector.h>
 #include <Columns/ColumnTuple.h>
 #include <Common/assert_cast.h>
-#include <Common/FieldVisitors.h>
 #include <Common/PODArray_fwd.h>
 #include <common/types.h>
 #include <DataTypes/DataTypesDecimal.h>
@@ -21,7 +20,7 @@
 
 #include <Common/ArenaAllocator.h>
 
-#include <iostream>
+
 namespace DB
 {
 
diff --git a/src/AggregateFunctions/AggregateFunctionQuantile.cpp b/src/AggregateFunctions/AggregateFunctionQuantile.cpp
index 1dcdb2883394..e8d86a03ff17 100644
--- a/src/AggregateFunctions/AggregateFunctionQuantile.cpp
+++ b/src/AggregateFunctions/AggregateFunctionQuantile.cpp
@@ -100,13 +100,14 @@ AggregateFunctionPtr createAggregateFunctionQuantile(const std::string & name, c
         if (which.idx == TypeIndex::Decimal32) return std::make_shared<Function<Decimal32, false>>(argument_types, params);
         if (which.idx == TypeIndex::Decimal64) return std::make_shared<Function<Decimal64, false>>(argument_types, params);
         if (which.idx == TypeIndex::Decimal128) return std::make_shared<Function<Decimal128, false>>(argument_types, params);
+        if (which.idx == TypeIndex::Decimal256) return std::make_shared<Function<Decimal256, false>>(argument_types, params);
         if (which.idx == TypeIndex::DateTime64) return std::make_shared<Function<DateTime64, false>>(argument_types, params);
-        //if (which.idx == TypeIndex::Decimal256) return std::make_shared<Function<Decimal256, false>>(argument_types, params);
     }
 
     if constexpr (supportBigInt<Function>())
     {
         if (which.idx == TypeIndex::Int128) return std::make_shared<Function<Int128, true>>(argument_types, params);
+        if (which.idx == TypeIndex::UInt128) return std::make_shared<Function<Int128, true>>(argument_types, params);
         if (which.idx == TypeIndex::Int256) return std::make_shared<Function<Int256, true>>(argument_types, params);
         if (which.idx == TypeIndex::UInt256) return std::make_shared<Function<UInt256, true>>(argument_types, params);
     }
diff --git a/src/AggregateFunctions/AggregateFunctionStatistics.cpp b/src/AggregateFunctions/AggregateFunctionStatistics.cpp
index 9e3aa0962db5..d8c8c2ab2100 100644
--- a/src/AggregateFunctions/AggregateFunctionStatistics.cpp
+++ b/src/AggregateFunctions/AggregateFunctionStatistics.cpp
@@ -36,7 +36,7 @@ AggregateFunctionPtr createAggregateFunctionStatisticsBinary(const std::string &
     assertNoParameters(name, parameters);
     assertBinary(name, argument_types);
 
-    AggregateFunctionPtr res(createWithTwoNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));
+    AggregateFunctionPtr res(createWithTwoBasicNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));
     if (!res)
         throw Exception("Illegal types " + argument_types[0]->getName() + " and " + argument_types[1]->getName()
             + " of arguments for aggregate function " + name, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
diff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp
index c7c2f9025eda..5dde84c1b647 100644
--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp
+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.cpp
@@ -41,7 +41,7 @@ AggregateFunctionPtr createAggregateFunctionStatisticsBinary(const std::string &
     assertNoParameters(name, parameters);
     assertBinary(name, argument_types);
 
-    AggregateFunctionPtr res(createWithTwoNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));
+    AggregateFunctionPtr res(createWithTwoBasicNumericTypes<FunctionTemplate>(*argument_types[0], *argument_types[1], argument_types));
     if (!res)
         throw Exception("Illegal types " + argument_types[0]->getName() + " and " + argument_types[1]->getName()
             + " of arguments for aggregate function " + name, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
diff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h
index a5d6bbb7dc86..eaf119a62649 100644
--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h
+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h
@@ -131,11 +131,10 @@ class AggregateFunctionVarianceSimple final
                 static_cast<ResultType>(static_cast<const ColVecT2 &>(*columns[1]).getData()[row_num]));
         else
         {
-            if constexpr (std::is_same_v<T1, Decimal256>)
+            if constexpr (IsDecimalNumber<T1>)
             {
                 this->data(place).add(static_cast<ResultType>(
-                    static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num].value
-                ));
+                    static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num].value));
             }
             else
                 this->data(place).add(
diff --git a/src/AggregateFunctions/AggregateFunctionTopK.cpp b/src/AggregateFunctions/AggregateFunctionTopK.cpp
index e32da02f4424..79a39817ea5a 100644
--- a/src/AggregateFunctions/AggregateFunctionTopK.cpp
+++ b/src/AggregateFunctions/AggregateFunctionTopK.cpp
@@ -2,9 +2,10 @@
 #include <AggregateFunctions/AggregateFunctionTopK.h>
 #include <AggregateFunctions/Helpers.h>
 #include <AggregateFunctions/FactoryHelpers.h>
+#include <Common/FieldVisitors.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
-#include "registerAggregateFunctions.h"
+
 
 #define TOP_K_MAX_SIZE 0xFFFFFF
 
diff --git a/src/AggregateFunctions/AggregateFunctionTopK.h b/src/AggregateFunctions/AggregateFunctionTopK.h
index dbc471687ead..5e5e7d07cecb 100644
--- a/src/AggregateFunctions/AggregateFunctionTopK.h
+++ b/src/AggregateFunctions/AggregateFunctionTopK.h
@@ -10,7 +10,6 @@
 #include <Columns/ColumnArray.h>
 
 #include <Common/SpaceSaving.h>
-#include <Common/FieldVisitors.h>
 #include <Common/assert_cast.h>
 
 #include <AggregateFunctions/IAggregateFunction.h>
diff --git a/src/AggregateFunctions/AggregateFunctionUniq.h b/src/AggregateFunctions/AggregateFunctionUniq.h
index 253af6e28957..dfe9acf267ed 100644
--- a/src/AggregateFunctions/AggregateFunctionUniq.h
+++ b/src/AggregateFunctions/AggregateFunctionUniq.h
@@ -69,7 +69,7 @@ struct AggregateFunctionUniqHLL12Data<String>
 };
 
 template <>
-struct AggregateFunctionUniqHLL12Data<UInt128>
+struct AggregateFunctionUniqHLL12Data<UUID>
 {
     using Set = HyperLogLogWithSmallSetOptimization<UInt64, 16, 12>;
     Set set;
@@ -133,16 +133,14 @@ template <typename T> struct AggregateFunctionUniqTraits
 {
     static UInt64 hash(T x)
     {
-        if constexpr (std::is_same_v<T, UInt128>)
-        {
-            return sipHash64(x);
-        }
-        else if constexpr (std::is_same_v<T, Float32> || std::is_same_v<T, Float64>)
+        if constexpr (std::is_same_v<T, Float32> || std::is_same_v<T, Float64>)
         {
             return ext::bit_cast<UInt64>(x);
         }
         else if constexpr (sizeof(T) <= sizeof(UInt64))
+        {
             return x;
+        }
         else
             return DefaultHash64<T>(x);
     }
@@ -184,7 +182,7 @@ struct OneAdder
                 UInt128 key;
                 SipHash hash;
                 hash.update(value.data, value.size);
-                hash.get128(key.low, key.high);
+                hash.get128(key);
 
                 data.set.insert(key);
             }
diff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp b/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp
index c0064044f958..84a9267ffe0f 100644
--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp
+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp
@@ -3,11 +3,13 @@
 #include <AggregateFunctions/AggregateFunctionFactory.h>
 #include <AggregateFunctions/Helpers.h>
 
+#include <Common/FieldVisitors.h>
+
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 
 #include <functional>
-#include "registerAggregateFunctions.h"
+
 
 namespace DB
 {
diff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.h b/src/AggregateFunctions/AggregateFunctionUniqCombined.h
index 31bd8021dcfb..f425a343caa5 100644
--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.h
+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.h
@@ -1,7 +1,6 @@
 #pragma once
 
 #include <Common/CombinedCardinalityEstimator.h>
-#include <Common/FieldVisitors.h>
 #include <Common/SipHash.h>
 #include <Common/typeid_cast.h>
 #include <Common/assert_cast.h>
diff --git a/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp b/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp
index 9befc515de6e..8195bd8964c5 100644
--- a/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp
+++ b/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp
@@ -1,11 +1,11 @@
 #include <AggregateFunctions/AggregateFunctionFactory.h>
 #include <AggregateFunctions/Helpers.h>
 #include <AggregateFunctions/AggregateFunctionUniqUpTo.h>
+#include <Common/FieldVisitors.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeFixedString.h>
-#include "registerAggregateFunctions.h"
 
 
 namespace DB
diff --git a/src/AggregateFunctions/AggregateFunctionUniqUpTo.h b/src/AggregateFunctions/AggregateFunctionUniqUpTo.h
index 853e1cb6447d..5dd62c96a9ed 100644
--- a/src/AggregateFunctions/AggregateFunctionUniqUpTo.h
+++ b/src/AggregateFunctions/AggregateFunctionUniqUpTo.h
@@ -1,6 +1,7 @@
 #pragma once
 
-#include <Common/FieldVisitors.h>
+#include <common/unaligned.h>
+
 #include <Common/typeid_cast.h>
 #include <Common/assert_cast.h>
 
@@ -35,7 +36,7 @@ namespace DB
   */
 
 template <typename T>
-struct __attribute__((__packed__)) AggregateFunctionUniqUpToData
+struct AggregateFunctionUniqUpToData
 {
 /** If count == threshold + 1 - this means that it is "overflowed" (values greater than threshold).
   * In this case (for example, after calling the merge function), the `data` array does not necessarily contain the initialized values
@@ -43,7 +44,17 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData
   *   then set count to `threshold + 1`, and values from another state are not copied.
   */
     UInt8 count = 0;
-    T data[0];
+    char data_ptr[0];
+
+    T load(size_t i) const
+    {
+        return unalignedLoad<T>(data_ptr + i * sizeof(T));
+    }
+
+    void store(size_t i, const T & x)
+    {
+        unalignedStore<T>(data_ptr + i * sizeof(T), x);
+    }
 
     size_t size() const
     {
@@ -60,12 +71,12 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData
 
         /// Linear search for the matching element.
         for (size_t i = 0; i < count; ++i)
-            if (data[i] == x)
+            if (load(i) == x)
                 return;
 
         /// Did not find the matching element. If there is room for one more element, insert it.
         if (count < threshold)
-            data[count] = x;
+            store(count, x);
 
         /// After increasing count, the state may be overflowed.
         ++count;
@@ -84,7 +95,7 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData
         }
 
         for (size_t i = 0; i < rhs.count; ++i)
-            insert(rhs.data[i], threshold);
+            insert(rhs.load(i), threshold);
     }
 
     void write(WriteBuffer & wb, UInt8 threshold) const
@@ -93,7 +104,7 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData
 
         /// Write values only if the state is not overflowed. Otherwise, they are not needed, and only the fact that the state is overflowed is important.
         if (count <= threshold)
-            wb.write(reinterpret_cast<const char *>(data), count * sizeof(data[0]));
+            wb.write(data_ptr, count * sizeof(T));
     }
 
     void read(ReadBuffer & rb, UInt8 threshold)
@@ -101,7 +112,7 @@ struct __attribute__((__packed__)) AggregateFunctionUniqUpToData
         readBinary(count, rb);
 
         if (count <= threshold)
-            rb.read(reinterpret_cast<char *>(data), count * sizeof(data[0]));
+            rb.read(data_ptr, count * sizeof(T));
     }
 
     /// ALWAYS_INLINE is required to have better code layout for uniqUpTo function
diff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h
index bf51b5f6e2eb..d1f1830eb274 100644
--- a/src/AggregateFunctions/Helpers.h
+++ b/src/AggregateFunctions/Helpers.h
@@ -15,12 +15,12 @@
     M(Float32) \
     M(Float64)
 
-// No UInt128 here because of the name conflict
 #define FOR_NUMERIC_TYPES(M) \
     M(UInt8) \
     M(UInt16) \
     M(UInt32) \
     M(UInt64) \
+    M(UInt128) \
     M(UInt256) \
     M(Int8) \
     M(Int16) \
@@ -109,6 +109,8 @@ static IAggregateFunction * createWithUnsignedIntegerType(const IDataType & argu
     if (which.idx == TypeIndex::UInt16) return new AggregateFunctionTemplate<UInt16, Data<UInt16>>(std::forward<TArgs>(args)...);
     if (which.idx == TypeIndex::UInt32) return new AggregateFunctionTemplate<UInt32, Data<UInt32>>(std::forward<TArgs>(args)...);
     if (which.idx == TypeIndex::UInt64) return new AggregateFunctionTemplate<UInt64, Data<UInt64>>(std::forward<TArgs>(args)...);
+    if (which.idx == TypeIndex::UInt128) return new AggregateFunctionTemplate<UInt128, Data<UInt128>>(std::forward<TArgs>(args)...);
+    if (which.idx == TypeIndex::UInt256) return new AggregateFunctionTemplate<UInt256, Data<UInt256>>(std::forward<TArgs>(args)...);
     return nullptr;
 }
 
@@ -119,11 +121,11 @@ static IAggregateFunction * createWithNumericBasedType(const IDataType & argumen
     if (f)
         return f;
 
-    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32 and UUID based on UInt128
+    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32
     WhichDataType which(argument_type);
     if (which.idx == TypeIndex::Date) return new AggregateFunctionTemplate<UInt16>(std::forward<TArgs>(args)...);
     if (which.idx == TypeIndex::DateTime) return new AggregateFunctionTemplate<UInt32>(std::forward<TArgs>(args)...);
-    if (which.idx == TypeIndex::UUID) return new AggregateFunctionTemplate<UInt128>(std::forward<TArgs>(args)...);
+    if (which.idx == TypeIndex::UUID) return new AggregateFunctionTemplate<UUID>(std::forward<TArgs>(args)...);
     return nullptr;
 }
 
@@ -184,6 +186,29 @@ static IAggregateFunction * createWithTwoNumericTypes(const IDataType & first_ty
     return nullptr;
 }
 
+template <typename FirstType, template <typename, typename> class AggregateFunctionTemplate, typename... TArgs>
+static IAggregateFunction * createWithTwoBasicNumericTypesSecond(const IDataType & second_type, TArgs && ... args)
+{
+    WhichDataType which(second_type);
+#define DISPATCH(TYPE) \
+    if (which.idx == TypeIndex::TYPE) return new AggregateFunctionTemplate<FirstType, TYPE>(std::forward<TArgs>(args)...);
+    FOR_BASIC_NUMERIC_TYPES(DISPATCH)
+#undef DISPATCH
+    return nullptr;
+}
+
+template <template <typename, typename> class AggregateFunctionTemplate, typename... TArgs>
+static IAggregateFunction * createWithTwoBasicNumericTypes(const IDataType & first_type, const IDataType & second_type, TArgs && ... args)
+{
+    WhichDataType which(first_type);
+#define DISPATCH(TYPE) \
+    if (which.idx == TypeIndex::TYPE) \
+        return createWithTwoBasicNumericTypesSecond<TYPE, AggregateFunctionTemplate>(second_type, std::forward<TArgs>(args)...);
+    FOR_BASIC_NUMERIC_TYPES(DISPATCH)
+#undef DISPATCH
+    return nullptr;
+}
+
 template <typename FirstType, template <typename, typename> class AggregateFunctionTemplate, typename... TArgs>
 static IAggregateFunction * createWithTwoNumericOrDateTypesSecond(const IDataType & second_type, TArgs && ... args)
 {
@@ -195,7 +220,7 @@ static IAggregateFunction * createWithTwoNumericOrDateTypesSecond(const IDataTyp
     if (which.idx == TypeIndex::Enum8) return new AggregateFunctionTemplate<FirstType, Int8>(std::forward<TArgs>(args)...);
     if (which.idx == TypeIndex::Enum16) return new AggregateFunctionTemplate<FirstType, Int16>(std::forward<TArgs>(args)...);
 
-    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32 and UUID based on UInt128
+    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32
     if (which.idx == TypeIndex::Date) return new AggregateFunctionTemplate<FirstType, UInt16>(std::forward<TArgs>(args)...);
     if (which.idx == TypeIndex::DateTime) return new AggregateFunctionTemplate<FirstType, UInt32>(std::forward<TArgs>(args)...);
 
@@ -216,7 +241,7 @@ static IAggregateFunction * createWithTwoNumericOrDateTypes(const IDataType & fi
     if (which.idx == TypeIndex::Enum16)
         return createWithTwoNumericOrDateTypesSecond<Int16, AggregateFunctionTemplate>(second_type, std::forward<TArgs>(args)...);
 
-    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32 and UUID based on UInt128
+    /// expects that DataTypeDate based on UInt16, DataTypeDateTime based on UInt32
     if (which.idx == TypeIndex::Date)
         return createWithTwoNumericOrDateTypesSecond<UInt16, AggregateFunctionTemplate>(second_type, std::forward<TArgs>(args)...);
     if (which.idx == TypeIndex::DateTime)
diff --git a/src/AggregateFunctions/QuantileReservoirSampler.h b/src/AggregateFunctions/QuantileReservoirSampler.h
index 6b4af04a5fbd..e0217731a123 100644
--- a/src/AggregateFunctions/QuantileReservoirSampler.h
+++ b/src/AggregateFunctions/QuantileReservoirSampler.h
@@ -54,7 +54,7 @@ struct QuantileReservoirSampler
     /// Get the value of the `level` quantile. The level must be between 0 and 1.
     Value get(Float64 level)
     {
-        return data.quantileInterpolated(level);
+        return Value(data.quantileInterpolated(level));
     }
 
     /// Get the `size` values of `levels` quantiles. Write `size` results starting with `result` address.
@@ -62,7 +62,7 @@ struct QuantileReservoirSampler
     void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result)
     {
         for (size_t i = 0; i < size; ++i)
-            result[indices[i]] = data.quantileInterpolated(levels[indices[i]]);
+            result[indices[i]] = Value(data.quantileInterpolated(levels[indices[i]]));
     }
 
     /// The same, but in the case of an empty state, NaN is returned.
diff --git a/src/AggregateFunctions/ReservoirSampler.h b/src/AggregateFunctions/ReservoirSampler.h
index a321ef086481..e4cc77dd3610 100644
--- a/src/AggregateFunctions/ReservoirSampler.h
+++ b/src/AggregateFunctions/ReservoirSampler.h
@@ -131,12 +131,20 @@ class ReservoirSampler
         size_t left_index = static_cast<size_t>(index);
         size_t right_index = left_index + 1;
         if (right_index == samples.size())
-            return static_cast<double>(samples[left_index]);
+        {
+            if constexpr (DB::IsDecimalNumber<T>)
+                return static_cast<double>(samples[left_index].value);
+            else
+                return static_cast<double>(samples[left_index]);
+        }
 
         double left_coef = right_index - index;
         double right_coef = index - left_index;
 
-        return static_cast<double>(samples[left_index]) * left_coef + static_cast<double>(samples[right_index]) * right_coef;
+        if constexpr (DB::IsDecimalNumber<T>)
+            return static_cast<double>(samples[left_index].value) * left_coef + static_cast<double>(samples[right_index].value) * right_coef;
+        else
+            return static_cast<double>(samples[left_index]) * left_coef + static_cast<double>(samples[right_index]) * right_coef;
     }
 
     void merge(const ReservoirSampler<T, OnEmpty> & b)
diff --git a/src/AggregateFunctions/UniqVariadicHash.h b/src/AggregateFunctions/UniqVariadicHash.h
index d6e584a2e1e1..7ca80a9db34d 100644
--- a/src/AggregateFunctions/UniqVariadicHash.h
+++ b/src/AggregateFunctions/UniqVariadicHash.h
@@ -3,7 +3,6 @@
 #include <city.h>
 #include <Core/Defines.h>
 #include <Common/SipHash.h>
-#include <Common/UInt128.h>
 #include <Common/assert_cast.h>
 #include <Columns/ColumnTuple.h>
 
@@ -107,7 +106,7 @@ struct UniqVariadicHash<true, false>
         }
 
         UInt128 key;
-        hash.get128(key.low, key.high);
+        hash.get128(key);
         return key;
     }
 };
@@ -131,7 +130,7 @@ struct UniqVariadicHash<true, true>
         }
 
         UInt128 key;
-        hash.get128(key.low, key.high);
+        hash.get128(key);
         return key;
     }
 };
diff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h
index a4fa15c2d953..8621a793f495 100644
--- a/src/Columns/ColumnDecimal.h
+++ b/src/Columns/ColumnDecimal.h
@@ -85,8 +85,8 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T
     {}
 
 public:
-    const char * getFamilyName() const override { return TypeName<T>::get(); }
-    TypeIndex getDataType() const override { return TypeId<T>::value; }
+    const char * getFamilyName() const override { return TypeName<T>; }
+    TypeIndex getDataType() const override { return TypeId<T>; }
 
     bool isNumeric() const override { return false; }
     bool canBeInsideNullable() const override { return true; }
diff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h
index 820833391077..51b45be53fdf 100644
--- a/src/Columns/ColumnUnique.h
+++ b/src/Columns/ColumnUnique.h
@@ -665,7 +665,7 @@ UInt128 ColumnUnique<ColumnType>::IncrementalHash::getHash(const ColumnType & co
             column.updateHashWithValue(i, sip_hash);
 
         std::lock_guard lock(mutex);
-        sip_hash.get128(hash.low, hash.high);
+        sip_hash.get128(hash);
         cur_hash = hash;
         num_added_rows.store(column_size);
     }
diff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp
index a64906ba2578..4e2a8c16586d 100644
--- a/src/Columns/ColumnVector.cpp
+++ b/src/Columns/ColumnVector.cpp
@@ -33,6 +33,7 @@ namespace ErrorCodes
     extern const int PARAMETER_OUT_OF_BOUND;
     extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;
     extern const int LOGICAL_ERROR;
+    extern const int NOT_IMPLEMENTED;
 }
 
 template <typename T>
@@ -154,7 +155,7 @@ void ColumnVector<T>::getPermutation(bool reverse, size_t limit, int nan_directi
     else
     {
         /// A case for radix sort
-        if constexpr (is_arithmetic_v<T> && !std::is_same_v<T, UInt128>)
+        if constexpr (is_arithmetic_v<T> && !is_big_int_v<T>)
         {
             /// Thresholds on size. Lower threshold is arbitrary. Upper threshold is chosen by the type for histogram counters.
             if (s >= 256 && s <= std::numeric_limits<UInt32>::max())
@@ -292,28 +293,37 @@ MutableColumnPtr ColumnVector<T>::cloneResized(size_t size) const
         memcpy(new_col.data.data(), data.data(), count * sizeof(data[0]));
 
         if (size > count)
-            memset(static_cast<void *>(&new_col.data[count]), static_cast<int>(ValueType()), (size - count) * sizeof(ValueType));
+            memset(static_cast<void *>(&new_col.data[count]), 0, (size - count) * sizeof(ValueType));
     }
 
     return res;
 }
 
 template <typename T>
-UInt64 ColumnVector<T>::get64(size_t n) const
+UInt64 ColumnVector<T>::get64(size_t n [[maybe_unused]]) const
 {
-    return ext::bit_cast<UInt64>(data[n]);
+    if constexpr (is_arithmetic_v<T>)
+        return ext::bit_cast<UInt64>(data[n]);
+    else
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot get the value of {} as UInt64", TypeName<T>);
 }
 
 template <typename T>
-inline Float64 ColumnVector<T>::getFloat64(size_t n) const
+inline Float64 ColumnVector<T>::getFloat64(size_t n [[maybe_unused]]) const
 {
-    return static_cast<Float64>(data[n]);
+    if constexpr (is_arithmetic_v<T>)
+        return static_cast<Float64>(data[n]);
+    else
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot get the value of {} as Float64", TypeName<T>);
 }
 
 template <typename T>
-Float32 ColumnVector<T>::getFloat32(size_t n) const
+Float32 ColumnVector<T>::getFloat32(size_t n [[maybe_unused]]) const
 {
-    return static_cast<Float32>(data[n]);
+    if constexpr (is_arithmetic_v<T>)
+        return static_cast<Float32>(data[n]);
+    else
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot get the value of {} as Float32", TypeName<T>);
 }
 
 template <typename T>
@@ -482,8 +492,6 @@ void ColumnVector<T>::gather(ColumnGathererStream & gatherer)
 template <typename T>
 void ColumnVector<T>::getExtremes(Field & min, Field & max) const
 {
-    using FastRefT = std::conditional_t<is_big_int_v<T>, const T &, const T>;
-
     size_t size = data.size();
 
     if (size == 0)
@@ -504,7 +512,7 @@ void ColumnVector<T>::getExtremes(Field & min, Field & max) const
     T cur_min = NaNOrZero<T>();
     T cur_max = NaNOrZero<T>();
 
-    for (FastRefT x : data)
+    for (const T & x : data)
     {
         if (isNaN(x))
             continue;
@@ -569,5 +577,6 @@ template class ColumnVector<Int128>;
 template class ColumnVector<Int256>;
 template class ColumnVector<Float32>;
 template class ColumnVector<Float64>;
+template class ColumnVector<UUID>;
 
 }
diff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h
index 30ab38ed1c2d..e75fd11d1900 100644
--- a/src/Columns/ColumnVector.h
+++ b/src/Columns/ColumnVector.h
@@ -12,6 +12,12 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int NOT_IMPLEMENTED;
+}
+
+
 /** Stuff for comparing numbers.
   * Integer values are compared as usual.
   * Floating-point numbers are compared this way that NaNs always end up at the end
@@ -90,6 +96,7 @@ struct FloatCompareHelper
 template <class U> struct CompareHelper<Float32, U> : public FloatCompareHelper<Float32> {};
 template <class U> struct CompareHelper<Float64, U> : public FloatCompareHelper<Float64> {};
 
+
 /** A template for columns that use a simple array to store.
  */
 template <typename T>
@@ -118,7 +125,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>
     ColumnVector(std::initializer_list<T> il) : data{il} {}
 
 public:
-    bool isNumeric() const override { return IsNumber<T>; }
+    bool isNumeric() const override { return is_arithmetic_v<T>; }
 
     size_t size() const override
     {
@@ -221,8 +228,8 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>
         data.reserve(n);
     }
 
-    const char * getFamilyName() const override { return TypeName<T>::get(); }
-    TypeIndex getDataType() const override { return TypeId<T>::value; }
+    const char * getFamilyName() const override { return TypeName<T>; }
+    TypeIndex getDataType() const override { return TypeId<T>; }
 
     MutableColumnPtr cloneResized(size_t size) const override;
 
@@ -245,18 +252,27 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>
     /// Out of range conversion is permitted.
     UInt64 NO_SANITIZE_UNDEFINED getUInt(size_t n) const override
     {
-        return UInt64(data[n]);
+        if constexpr (is_arithmetic_v<T>)
+            return UInt64(data[n]);
+        else
+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot get the value of {} as UInt", TypeName<T>);
     }
 
     /// Out of range conversion is permitted.
     Int64 NO_SANITIZE_UNDEFINED getInt(size_t n) const override
     {
-        return Int64(data[n]);
+        if constexpr (is_arithmetic_v<T>)
+            return Int64(data[n]);
+        else
+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot get the value of {} as Int", TypeName<T>);
     }
 
     bool getBool(size_t n) const override
     {
-        return bool(data[n]);
+        if constexpr (is_arithmetic_v<T>)
+            return bool(data[n]);
+        else
+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot get the value of {} as bool", TypeName<T>);
     }
 
     void insert(const Field & x) override
@@ -370,5 +386,6 @@ extern template class ColumnVector<Int128>;
 extern template class ColumnVector<Int256>;
 extern template class ColumnVector<Float32>;
 extern template class ColumnVector<Float64>;
+extern template class ColumnVector<UUID>;
 
 }
diff --git a/src/Columns/ColumnsNumber.h b/src/Columns/ColumnsNumber.h
index 17a28e617c3f..48721c32fa01 100644
--- a/src/Columns/ColumnsNumber.h
+++ b/src/Columns/ColumnsNumber.h
@@ -26,6 +26,6 @@ using ColumnInt256 = ColumnVector<Int256>;
 using ColumnFloat32 = ColumnVector<Float32>;
 using ColumnFloat64 = ColumnVector<Float64>;
 
-using ColumnUUID = ColumnVector<UInt128>;
+using ColumnUUID = ColumnVector<UUID>;
 
 }
diff --git a/src/Columns/IColumnUnique.h b/src/Columns/IColumnUnique.h
index 731445e2b80b..2c1c542fce5e 100644
--- a/src/Columns/IColumnUnique.h
+++ b/src/Columns/IColumnUnique.h
@@ -1,7 +1,6 @@
 #pragma once
 #include <optional>
 #include <Columns/IColumn.h>
-#include <Common/UInt128.h>
 
 namespace DB
 {
diff --git a/src/Common/ColumnsHashing.h b/src/Common/ColumnsHashing.h
index ada783d982c3..3ffa9bb71de4 100644
--- a/src/Common/ColumnsHashing.h
+++ b/src/Common/ColumnsHashing.h
@@ -166,8 +166,7 @@ class LowCardinalityDictionaryCache : public HashMethodContext
         size_t operator()(const DictionaryKey & key) const
         {
             SipHash hash;
-            hash.update(key.hash.low);
-            hash.update(key.hash.high);
+            hash.update(key.hash);
             hash.update(key.size);
             return hash.get64();
         }
diff --git a/src/Common/FieldVisitors.cpp b/src/Common/FieldVisitors.cpp
index 62f048160329..b87152da7e73 100644
--- a/src/Common/FieldVisitors.cpp
+++ b/src/Common/FieldVisitors.cpp
@@ -1,4 +1,3 @@
-#include <Core/UUID.h>
 #include <IO/ReadBuffer.h>
 #include <IO/WriteBuffer.h>
 #include <IO/WriteHelpers.h>
@@ -27,7 +26,7 @@ template <typename T>
 static inline String formatQuotedWithPrefix(T x, const char * prefix)
 {
     WriteBufferFromOwnString wb;
-    wb.write(prefix, strlen(prefix));
+    writeCString(prefix, wb);
     writeQuoted(x, wb);
     return wb.str();
 }
@@ -48,10 +47,11 @@ String FieldVisitorDump::operator() (const DecimalField<Decimal32> & x) const {
 String FieldVisitorDump::operator() (const DecimalField<Decimal64> & x) const { return formatQuotedWithPrefix(x, "Decimal64_"); }
 String FieldVisitorDump::operator() (const DecimalField<Decimal128> & x) const { return formatQuotedWithPrefix(x, "Decimal128_"); }
 String FieldVisitorDump::operator() (const DecimalField<Decimal256> & x) const { return formatQuotedWithPrefix(x, "Decimal256_"); }
+String FieldVisitorDump::operator() (const UInt128 & x) const { return formatQuotedWithPrefix(x, "UInt128_"); }
 String FieldVisitorDump::operator() (const UInt256 & x) const { return formatQuotedWithPrefix(x, "UInt256_"); }
-String FieldVisitorDump::operator() (const Int256 & x) const { return formatQuotedWithPrefix(x, "Int256_"); }
 String FieldVisitorDump::operator() (const Int128 & x) const { return formatQuotedWithPrefix(x, "Int128_"); }
-String FieldVisitorDump::operator() (const UInt128 & x) const { return formatQuotedWithPrefix(UUID(x), "UUID_"); }
+String FieldVisitorDump::operator() (const Int256 & x) const { return formatQuotedWithPrefix(x, "Int256_"); }
+String FieldVisitorDump::operator() (const UUID & x) const { return formatQuotedWithPrefix(x, "UUID_"); }
 
 
 String FieldVisitorDump::operator() (const String & x) const
@@ -152,13 +152,11 @@ String FieldVisitorToString::operator() (const DecimalField<Decimal64> & x) cons
 String FieldVisitorToString::operator() (const DecimalField<Decimal128> & x) const { return formatQuoted(x); }
 String FieldVisitorToString::operator() (const DecimalField<Decimal256> & x) const { return formatQuoted(x); }
 String FieldVisitorToString::operator() (const Int128 & x) const { return formatQuoted(x); }
-String FieldVisitorToString::operator() (const UInt128 & x) const { return formatQuoted(UUID(x)); }
-String FieldVisitorToString::operator() (const AggregateFunctionStateData & x) const
-{
-    return formatQuoted(x.data);
-}
+String FieldVisitorToString::operator() (const UInt128 & x) const { return formatQuoted(x); }
 String FieldVisitorToString::operator() (const UInt256 & x) const { return formatQuoted(x); }
 String FieldVisitorToString::operator() (const Int256 & x) const { return formatQuoted(x); }
+String FieldVisitorToString::operator() (const UUID & x) const { return formatQuoted(x); }
+String FieldVisitorToString::operator() (const AggregateFunctionStateData & x) const { return formatQuoted(x.data); }
 
 String FieldVisitorToString::operator() (const Array & x) const
 {
@@ -228,6 +226,7 @@ void FieldVisitorWriteBinary::operator() (const UInt128 & x, WriteBuffer & buf)
 void FieldVisitorWriteBinary::operator() (const Int128 & x, WriteBuffer & buf) const { DB::writeVarInt(x, buf); }
 void FieldVisitorWriteBinary::operator() (const UInt256 & x, WriteBuffer & buf) const { DB::writeBinary(x, buf); }
 void FieldVisitorWriteBinary::operator() (const Int256 & x, WriteBuffer & buf) const { DB::writeBinary(x, buf); }
+void FieldVisitorWriteBinary::operator() (const UUID & x, WriteBuffer & buf) const { DB::writeBinary(x, buf); }
 void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal32> & x, WriteBuffer & buf) const { DB::writeBinary(x.getValue(), buf); }
 void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal64> & x, WriteBuffer & buf) const { DB::writeBinary(x.getValue(), buf); }
 void FieldVisitorWriteBinary::operator() (const DecimalField<Decimal128> & x, WriteBuffer & buf) const { DB::writeBinary(x.getValue(), buf); }
@@ -315,6 +314,13 @@ void FieldVisitorHash::operator() (const Int128 & x) const
     hash.update(x);
 }
 
+void FieldVisitorHash::operator() (const UUID & x) const
+{
+    UInt8 type = Field::Types::UUID;
+    hash.update(type);
+    hash.update(x);
+}
+
 void FieldVisitorHash::operator() (const Float64 & x) const
 {
     UInt8 type = Field::Types::Float64;
diff --git a/src/Common/FieldVisitors.h b/src/Common/FieldVisitors.h
index 5adbf2b01ac2..0384be39494f 100644
--- a/src/Common/FieldVisitors.h
+++ b/src/Common/FieldVisitors.h
@@ -19,14 +19,6 @@ namespace ErrorCodes
     extern const int NOT_IMPLEMENTED;
 }
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wredundant-decls"
-// Just dont mess with it. If the redundant redeclaration is removed then ReaderHelpers.h should be included.
-// This leads to Arena.h inclusion which has a problem with ASAN stuff included properly and messing macro definition
-// which intefrers with... You dont want to know, really.
-UInt128 stringToUUID(const String & str);
-#pragma GCC diagnostic pop
-
 
 /** StaticVisitor (and its descendants) - class with overloaded operator() for all types of fields.
   * You could call visitor for field using function 'applyVisitor'.
@@ -71,8 +63,11 @@ class FieldVisitorToString : public StaticVisitor<String>
     String operator() (const Null & x) const;
     String operator() (const UInt64 & x) const;
     String operator() (const UInt128 & x) const;
+    String operator() (const UInt256 & x) const;
     String operator() (const Int64 & x) const;
     String operator() (const Int128 & x) const;
+    String operator() (const Int256 & x) const;
+    String operator() (const UUID & x) const;
     String operator() (const Float64 & x) const;
     String operator() (const String & x) const;
     String operator() (const Array & x) const;
@@ -83,9 +78,6 @@ class FieldVisitorToString : public StaticVisitor<String>
     String operator() (const DecimalField<Decimal128> & x) const;
     String operator() (const DecimalField<Decimal256> & x) const;
     String operator() (const AggregateFunctionStateData & x) const;
-
-    String operator() (const UInt256 & x) const;
-    String operator() (const Int256 & x) const;
 };
 
 
@@ -95,8 +87,11 @@ class FieldVisitorWriteBinary
     void operator() (const Null & x, WriteBuffer & buf) const;
     void operator() (const UInt64 & x, WriteBuffer & buf) const;
     void operator() (const UInt128 & x, WriteBuffer & buf) const;
+    void operator() (const UInt256 & x, WriteBuffer & buf) const;
     void operator() (const Int64 & x, WriteBuffer & buf) const;
     void operator() (const Int128 & x, WriteBuffer & buf) const;
+    void operator() (const Int256 & x, WriteBuffer & buf) const;
+    void operator() (const UUID & x, WriteBuffer & buf) const;
     void operator() (const Float64 & x, WriteBuffer & buf) const;
     void operator() (const String & x, WriteBuffer & buf) const;
     void operator() (const Array & x, WriteBuffer & buf) const;
@@ -107,9 +102,6 @@ class FieldVisitorWriteBinary
     void operator() (const DecimalField<Decimal128> & x, WriteBuffer & buf) const;
     void operator() (const DecimalField<Decimal256> & x, WriteBuffer & buf) const;
     void operator() (const AggregateFunctionStateData & x, WriteBuffer & buf) const;
-
-    void operator() (const UInt256 & x, WriteBuffer & buf) const;
-    void operator() (const Int256 & x, WriteBuffer & buf) const;
 };
 
 
@@ -120,8 +112,11 @@ class FieldVisitorDump : public StaticVisitor<String>
     String operator() (const Null & x) const;
     String operator() (const UInt64 & x) const;
     String operator() (const UInt128 & x) const;
+    String operator() (const UInt256 & x) const;
     String operator() (const Int64 & x) const;
     String operator() (const Int128 & x) const;
+    String operator() (const Int256 & x) const;
+    String operator() (const UUID & x) const;
     String operator() (const Float64 & x) const;
     String operator() (const String & x) const;
     String operator() (const Array & x) const;
@@ -132,9 +127,6 @@ class FieldVisitorDump : public StaticVisitor<String>
     String operator() (const DecimalField<Decimal128> & x) const;
     String operator() (const DecimalField<Decimal256> & x) const;
     String operator() (const AggregateFunctionStateData & x) const;
-
-    String operator() (const UInt256 & x) const;
-    String operator() (const Int256 & x) const;
 };
 
 
@@ -171,6 +163,7 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>
     T operator() (const UInt64 & x) const { return T(x); }
     T operator() (const Int64 & x) const { return T(x); }
     T operator() (const Int128 & x) const { return T(x); }
+    T operator() (const UUID & x) const { return T(x.toUnderType()); }
 
     T operator() (const Float64 & x) const
     {
@@ -259,8 +252,11 @@ class FieldVisitorHash : public StaticVisitor<>
     void operator() (const Null & x) const;
     void operator() (const UInt64 & x) const;
     void operator() (const UInt128 & x) const;
+    void operator() (const UInt256 & x) const;
     void operator() (const Int64 & x) const;
     void operator() (const Int128 & x) const;
+    void operator() (const Int256 & x) const;
+    void operator() (const UUID & x) const;
     void operator() (const Float64 & x) const;
     void operator() (const String & x) const;
     void operator() (const Array & x) const;
@@ -271,9 +267,6 @@ class FieldVisitorHash : public StaticVisitor<>
     void operator() (const DecimalField<Decimal128> & x) const;
     void operator() (const DecimalField<Decimal256> & x) const;
     void operator() (const AggregateFunctionStateData & x) const;
-
-    void operator() (const UInt256 & x) const;
-    void operator() (const Int256 & x) const;
 };
 
 
@@ -309,7 +302,7 @@ class FieldVisitorSum : public StaticVisitor<bool>
     bool operator() (Array &) const { throw Exception("Cannot sum Arrays", ErrorCodes::LOGICAL_ERROR); }
     bool operator() (Tuple &) const { throw Exception("Cannot sum Tuples", ErrorCodes::LOGICAL_ERROR); }
     bool operator() (Map &) const { throw Exception("Cannot sum Maps", ErrorCodes::LOGICAL_ERROR); }
-    bool operator() (UInt128 &) const { throw Exception("Cannot sum UUIDs", ErrorCodes::LOGICAL_ERROR); }
+    bool operator() (UUID &) const { throw Exception("Cannot sum UUIDs", ErrorCodes::LOGICAL_ERROR); }
     bool operator() (AggregateFunctionStateData &) const { throw Exception("Cannot sum AggregateFunctionStates", ErrorCodes::LOGICAL_ERROR); }
 
     bool operator() (Int128 & x) const
diff --git a/src/Common/FieldVisitorsAccurateComparison.h b/src/Common/FieldVisitorsAccurateComparison.h
index 84099eafb0f4..cf3cbb208dc4 100644
--- a/src/Common/FieldVisitorsAccurateComparison.h
+++ b/src/Common/FieldVisitorsAccurateComparison.h
@@ -36,41 +36,30 @@ class FieldVisitorAccurateEquals : public StaticVisitor<bool>
             if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)
                 return accurate::equalsOp(l, r);
 
+            /// TODO This is wrong (does not respect scale).
             if constexpr (isDecimalField<T>() && isDecimalField<U>())
                 return l == r;
 
             if constexpr (isDecimalField<T>() && std::is_arithmetic_v<U>)
-                return l == DecimalField<Decimal128>(r, 0);
+                return l == DecimalField<Decimal256>(Decimal256(r), 0);
 
             if constexpr (std::is_arithmetic_v<T> && isDecimalField<U>())
-                return DecimalField<Decimal128>(l, 0) == r;
+                return DecimalField<Decimal256>(Decimal256(l), 0) == r;
 
-            if constexpr (std::is_same_v<T, String>)
+            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)
             {
-                if constexpr (std::is_same_v<U, UInt128>)
-                    return stringToUUID(l) == r;
-
-                if constexpr (std::is_arithmetic_v<U>)
-                {
-                    ReadBufferFromString in(l);
-                    U parsed;
-                    readText(parsed, in);
-                    return operator()(parsed, r);
-                }
+                ReadBufferFromString in(l);
+                U parsed;
+                readText(parsed, in);
+                return operator()(parsed, r);
             }
 
-            if constexpr (std::is_same_v<U, String>)
+            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)
             {
-                if constexpr (std::is_same_v<T, UInt128>)
-                    return l == stringToUUID(r);
-
-                if constexpr (std::is_arithmetic_v<T>)
-                {
-                    ReadBufferFromString in(r);
-                    T parsed;
-                    readText(parsed, in);
-                    return operator()(l, parsed);
-                }
+                ReadBufferFromString in(r);
+                T parsed;
+                readText(parsed, in);
+                return operator()(l, parsed);
             }
         }
 
@@ -96,41 +85,30 @@ class FieldVisitorAccurateLess : public StaticVisitor<bool>
             if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)
                 return accurate::lessOp(l, r);
 
+            /// TODO This is wrong (does not respect scale).
             if constexpr (isDecimalField<T>() && isDecimalField<U>())
                 return l < r;
 
             if constexpr (isDecimalField<T>() && std::is_arithmetic_v<U>)
-                return l < DecimalField<Decimal128>(r, 0);
+                return l < DecimalField<Decimal256>(Decimal256(r), 0);
 
             if constexpr (std::is_arithmetic_v<T> && isDecimalField<U>())
-                return DecimalField<Decimal128>(l, 0) < r;
+                return DecimalField<Decimal256>(Decimal256(l), 0) < r;
 
-            if constexpr (std::is_same_v<T, String>)
+            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)
             {
-                if constexpr (std::is_same_v<U, UInt128>)
-                    return stringToUUID(l) < r;
-
-                if constexpr (std::is_arithmetic_v<U>)
-                {
-                    ReadBufferFromString in(l);
-                    U parsed;
-                    readText(parsed, in);
-                    return operator()(parsed, r);
-                }
+                ReadBufferFromString in(l);
+                U parsed;
+                readText(parsed, in);
+                return operator()(parsed, r);
             }
 
-            if constexpr (std::is_same_v<U, String>)
+            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)
             {
-                if constexpr (std::is_same_v<T, UInt128>)
-                    return l < stringToUUID(r);
-
-                if constexpr (std::is_arithmetic_v<T>)
-                {
-                    ReadBufferFromString in(r);
-                    T parsed;
-                    readText(parsed, in);
-                    return operator()(l, parsed);
-                }
+                ReadBufferFromString in(r);
+                T parsed;
+                readText(parsed, in);
+                return operator()(l, parsed);
             }
         }
 
diff --git a/src/Common/HashTable/Hash.h b/src/Common/HashTable/Hash.h
index d601d945ccfd..84e514c1375b 100644
--- a/src/Common/HashTable/Hash.h
+++ b/src/Common/HashTable/Hash.h
@@ -1,9 +1,10 @@
 #pragma once
 
+#include <city.h>
+#include <Core/Types.h>
 #include <common/types.h>
 #include <common/unaligned.h>
 #include <common/StringRef.h>
-#include <Common/UInt128.h>
 
 #include <type_traits>
 
@@ -167,35 +168,36 @@ inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) <= sizeof(UInt64)), T> k
     return intHash64(u.out);
 }
 
-template <typename T>
-static constexpr bool UseDefaultHashForBigInts =
-    std::is_same_v<T, DB::Int128>  ||
-    std::is_same_v<T, DB::UInt128> ||
-    (is_big_int_v<T> && sizeof(T) == 32);
 
 template <typename T>
-inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) > sizeof(UInt64) && UseDefaultHashForBigInts<T>), T> key)
+inline size_t DefaultHash64(std::enable_if_t<(sizeof(T) > sizeof(UInt64)), T> key)
 {
-    if constexpr (std::is_same_v<T, DB::Int128>)
+    if constexpr (is_big_int_v<T> && sizeof(T) == 16)
     {
-        return intHash64(static_cast<UInt64>(key) ^ static_cast<UInt64>(key >> 64));
+        /// TODO This is classical antipattern.
+        return intHash64(
+            static_cast<UInt64>(key) ^
+            static_cast<UInt64>(key >> 64));
     }
-    else if constexpr (std::is_same_v<T, DB::UInt128>)
+    else if constexpr (std::is_same_v<T, DB::UUID>)
     {
-        return intHash64(key.low ^ key.high);
+        return intHash64(
+            static_cast<UInt64>(key.toUnderType()) ^
+            static_cast<UInt64>(key.toUnderType() >> 64));
     }
     else if constexpr (is_big_int_v<T> && sizeof(T) == 32)
     {
-        return intHash64(static_cast<UInt64>(key) ^
+        return intHash64(
+            static_cast<UInt64>(key) ^
             static_cast<UInt64>(key >> 64) ^
             static_cast<UInt64>(key >> 128) ^
             static_cast<UInt64>(key >> 256));
     }
-
     assert(false);
     __builtin_unreachable();
 }
 
+
 template <typename T, typename Enable = void>
 struct DefaultHash;
 
@@ -213,7 +215,7 @@ struct DefaultHash<T, std::enable_if_t<DB::IsDecimalNumber<T>>>
 {
     size_t operator() (T key) const
     {
-        return DefaultHash64<typename T::NativeType>(key);
+        return DefaultHash64<typename T::NativeType>(key.value);
     }
 };
 
@@ -261,15 +263,98 @@ DEFINE_HASH(DB::Int128)
 DEFINE_HASH(DB::Int256)
 DEFINE_HASH(DB::Float32)
 DEFINE_HASH(DB::Float64)
+DEFINE_HASH(DB::UUID)
 
 #undef DEFINE_HASH
 
 
+struct UInt128Hash
+{
+    size_t operator()(UInt128 x) const
+    {
+        return CityHash_v1_0_2::Hash128to64({x.items[0], x.items[1]});
+    }
+};
+
+struct UUIDHash
+{
+    size_t operator()(DB::UUID x) const
+    {
+        return UInt128Hash()(x.toUnderType());
+    }
+};
+
+#ifdef __SSE4_2__
+
+struct UInt128HashCRC32
+{
+    size_t operator()(UInt128 x) const
+    {
+        UInt64 crc = -1ULL;
+        crc = _mm_crc32_u64(crc, x.items[0]);
+        crc = _mm_crc32_u64(crc, x.items[1]);
+        return crc;
+    }
+};
+
+#else
+
+/// On other platforms we do not use CRC32. NOTE This can be confusing.
+struct UInt128HashCRC32 : public UInt128Hash {};
+
+#endif
+
+struct UInt128TrivialHash
+{
+    size_t operator()(UInt128 x) const { return x.items[0]; }
+};
+
+struct UUIDTrivialHash
+{
+    size_t operator()(DB::UUID x) const { return x.toUnderType().items[0]; }
+};
+
+struct UInt256Hash
+{
+    size_t operator()(UInt256 x) const
+    {
+        /// NOTE suboptimal
+        return CityHash_v1_0_2::Hash128to64({
+            CityHash_v1_0_2::Hash128to64({x.items[0], x.items[1]}),
+            CityHash_v1_0_2::Hash128to64({x.items[2], x.items[3]})});
+    }
+};
+
+#ifdef __SSE4_2__
+
+struct UInt256HashCRC32
+{
+    size_t operator()(UInt256 x) const
+    {
+        UInt64 crc = -1ULL;
+        crc = _mm_crc32_u64(crc, x.items[0]);
+        crc = _mm_crc32_u64(crc, x.items[1]);
+        crc = _mm_crc32_u64(crc, x.items[2]);
+        crc = _mm_crc32_u64(crc, x.items[3]);
+        return crc;
+    }
+};
+
+#else
+
+/// We do not need to use CRC32 on other platforms. NOTE This can be confusing.
+struct UInt256HashCRC32 : public UInt256Hash {};
+
+#endif
+
 template <>
-struct DefaultHash<DB::UInt128> : public DB::UInt128Hash {};
+struct DefaultHash<DB::UInt128> : public UInt128Hash {};
 
 template <>
-struct DefaultHash<DB::DummyUInt256> : public DB::UInt256Hash {};
+struct DefaultHash<DB::UInt256> : public UInt256Hash {};
+
+template <>
+struct DefaultHash<DB::UUID> : public UUIDHash {};
 
 
 /// It is reasonable to use for UInt8, UInt16 with sufficient hash table size.
@@ -322,23 +407,18 @@ struct IntHash32
 {
     size_t operator() (const T & key) const
     {
-        if constexpr (std::is_same_v<T, DB::Int128>)
-        {
-            return intHash32<salt>(static_cast<UInt64>(key) ^ static_cast<UInt64>(key >> 64));
-        }
-        else if constexpr (std::is_same_v<T, DB::UInt128>)
+        if constexpr (is_big_int_v<T> && sizeof(T) == 16)
         {
-            return intHash32<salt>(key.low ^ key.high);
+            return intHash32<salt>(key.items[0] ^ key.items[1]);
         }
         else if constexpr (is_big_int_v<T> && sizeof(T) == 32)
         {
-            return intHash32<salt>(static_cast<UInt64>(key) ^
-                static_cast<UInt64>(key >> 64) ^
-                static_cast<UInt64>(key >> 128) ^
-                static_cast<UInt64>(key >> 256));
+            return intHash32<salt>(key.items[0] ^ key.items[1] ^ key.items[2] ^ key.items[3]);
         }
         else if constexpr (sizeof(T) <= sizeof(UInt64))
+        {
             return intHash32<salt>(key);
+        }
 
         assert(false);
         __builtin_unreachable();
diff --git a/src/Common/HashTable/HashTable.h b/src/Common/HashTable/HashTable.h
index 128fed7822eb..e25b3191652a 100644
--- a/src/Common/HashTable/HashTable.h
+++ b/src/Common/HashTable/HashTable.h
@@ -70,10 +70,10 @@ namespace ZeroTraits
 {
 
 template <typename T>
-bool check(const T x) { return x == 0; }
+bool check(const T x) { return x == T{}; }
 
 template <typename T>
-void set(T & x) { x = 0; }
+void set(T & x) { x = {}; }
 
 }
 
diff --git a/src/Common/HashTable/StringHashMap.h b/src/Common/HashTable/StringHashMap.h
index fe4eab160928..298580dc8375 100644
--- a/src/Common/HashTable/StringHashMap.h
+++ b/src/Common/HashTable/StringHashMap.h
@@ -28,9 +28,8 @@ struct StringHashMapCell<StringKey16, TMapped> : public HashMapCell<StringKey16,
 
     // Zero means unoccupied cells in hash table. Use key with last word = 0 as
     // zero keys, because such keys are unrepresentable (no way to encode length).
-    static bool isZero(const StringKey16 & key, const HashTableNoState &)
-    { return key.high == 0; }
-    void setZero() { this->value.first.high = 0; }
+    static bool isZero(const StringKey16 & key, const HashTableNoState &) { return key.items[1] == 0; }
+    void setZero() { this->value.first.items[1] = 0; }
 
     // external
     const StringRef getKey() const { return toStringRef(this->value.first); }
diff --git a/src/Common/HashTable/StringHashSet.h b/src/Common/HashTable/StringHashSet.h
index 8714a0e1fe4d..0466dca3574b 100644
--- a/src/Common/HashTable/StringHashSet.h
+++ b/src/Common/HashTable/StringHashSet.h
@@ -33,8 +33,8 @@ struct StringHashSetCell<StringKey16> : public HashTableCell<StringKey16, String
     // Zero means unoccupied cells in hash table. Use key with last word = 0 as
     // zero keys, because such keys are unrepresentable (no way to encode length).
     static bool isZero(const StringKey16 & key_, const HashTableNoState &)
-    { return key_.high == 0; }
-    void setZero() { this->key.high = 0; }
+    { return key_.items[1] == 0; }
+    void setZero() { this->key.items[1] = 0; }
 };
 
 template <>
diff --git a/src/Common/HashTable/StringHashTable.h b/src/Common/HashTable/StringHashTable.h
index 3a96d0cefdec..b05d119e0e97 100644
--- a/src/Common/HashTable/StringHashTable.h
+++ b/src/Common/HashTable/StringHashTable.h
@@ -25,8 +25,8 @@ inline StringRef ALWAYS_INLINE toStringRef(const StringKey8 & n)
 }
 inline StringRef ALWAYS_INLINE toStringRef(const StringKey16 & n)
 {
-    assert(n.high != 0);
-    return {reinterpret_cast<const char *>(&n), 16ul - (__builtin_clzll(n.high) >> 3)};
+    assert(n.items[1] != 0);
+    return {reinterpret_cast<const char *>(&n), 16ul - (__builtin_clzll(n.items[1]) >> 3)};
 }
 inline StringRef ALWAYS_INLINE toStringRef(const StringKey24 & n)
 {
@@ -46,8 +46,8 @@ struct StringHashTableHash
     size_t ALWAYS_INLINE operator()(StringKey16 key) const
     {
         size_t res = -1ULL;
-        res = _mm_crc32_u64(res, key.low);
-        res = _mm_crc32_u64(res, key.high);
+        res = _mm_crc32_u64(res, key.items[0]);
+        res = _mm_crc32_u64(res, key.items[1]);
         return res;
     }
     size_t ALWAYS_INLINE operator()(StringKey24 key) const
diff --git a/src/Common/MemoryTracker.cpp b/src/Common/MemoryTracker.cpp
index 60fb4d06b14f..e4c4e0b0ab1f 100644
--- a/src/Common/MemoryTracker.cpp
+++ b/src/Common/MemoryTracker.cpp
@@ -6,12 +6,14 @@
 #include <Common/formatReadable.h>
 #include <common/logger_useful.h>
 #include <Common/ProfileEvents.h>
+#include <Common/thread_local_rng.h>
 
 #include <atomic>
 #include <cmath>
 #include <random>
 #include <cstdlib>
 
+
 #ifdef MEMORY_TRACKER_DEBUG_CHECKS
 thread_local bool _memory_tracker_always_throw_logical_error_on_allocation = false;
 #endif
diff --git a/src/Common/OpenTelemetryTraceContext.h b/src/Common/OpenTelemetryTraceContext.h
index 56503c16a00b..9f2b5af9105d 100644
--- a/src/Common/OpenTelemetryTraceContext.h
+++ b/src/Common/OpenTelemetryTraceContext.h
@@ -6,12 +6,12 @@ namespace DB
 // The runtime info we need to create new OpenTelemetry spans.
 struct OpenTelemetryTraceContext
 {
-    __uint128_t trace_id = 0;
+    UUID trace_id{};
     UInt64 span_id = 0;
     // The incoming tracestate header and the trace flags, we just pass them
     // downstream. See https://www.w3.org/TR/trace-context/
     String tracestate;
-    uint8_t trace_flags = 0;
+    UInt8 trace_flags = 0;
 
     // Parse/compose OpenTelemetry traceparent header.
     bool parseTraceparentHeader(const std::string & traceparent, std::string & error);
diff --git a/src/Common/PODArray.h b/src/Common/PODArray.h
index b1042332cfac..8f6414b3fa93 100644
--- a/src/Common/PODArray.h
+++ b/src/Common/PODArray.h
@@ -260,22 +260,12 @@ class PODArrayBase : private boost::noncopyable, private TAllocator    /// empty
     template <typename ... TAllocatorParams>
     void push_back_raw(const void * ptr, TAllocatorParams &&... allocator_params)
     {
-        push_back_raw_many(1, ptr, std::forward<TAllocatorParams>(allocator_params)...);
-    }
-
-    template <typename ... TAllocatorParams>
-    void push_back_raw_many(size_t number_of_items, const void * ptr, TAllocatorParams &&... allocator_params)
-    {
-        size_t required_capacity = size() + number_of_items;
+        size_t required_capacity = size() + ELEMENT_SIZE;
         if (unlikely(required_capacity > capacity()))
             reserve(required_capacity, std::forward<TAllocatorParams>(allocator_params)...);
 
-        size_t items_byte_size = byte_size(number_of_items);
-        if (items_byte_size)
-        {
-            memcpy(c_end, ptr, items_byte_size);
-            c_end += items_byte_size;
-        }
+        memcpy(c_end, ptr, ELEMENT_SIZE);
+        c_end += ELEMENT_SIZE;
     }
 
     void protect()
diff --git a/src/Common/SipHash.h b/src/Common/SipHash.h
index ce7e80a7204a..92d635eb63cf 100644
--- a/src/Common/SipHash.h
+++ b/src/Common/SipHash.h
@@ -155,7 +155,6 @@ class SipHash
         unalignedStore<UInt64>(out + 8, v2 ^ v3);
     }
 
-    /// template for avoiding 'unsigned long long' vs 'unsigned long' problem on old poco in macos
     template <typename T>
     ALWAYS_INLINE void get128(T & lo, T & hi)
     {
@@ -165,6 +164,13 @@ class SipHash
         hi = v2 ^ v3;
     }
 
+    template <typename T>
+    ALWAYS_INLINE void get128(T & dst)
+    {
+        static_assert(sizeof(T) == 16);
+        get128(reinterpret_cast<char *>(&dst));
+    }
+
     UInt64 get64()
     {
         finalize();
diff --git a/src/Common/SpaceSaving.h b/src/Common/SpaceSaving.h
index 7ad48a6cf874..b7353d803b78 100644
--- a/src/Common/SpaceSaving.h
+++ b/src/Common/SpaceSaving.h
@@ -6,7 +6,6 @@
 #include <boost/range/adaptor/reversed.hpp>
 
 #include <Common/ArenaWithFreeLists.h>
-#include <Common/UInt128.h>
 #include <Common/HashTable/Hash.h>
 #include <Common/HashTable/HashMap.h>
 
diff --git a/src/Common/UInt128.h b/src/Common/UInt128.h
deleted file mode 100644
index be96f4096735..000000000000
--- a/src/Common/UInt128.h
+++ /dev/null
@@ -1,292 +0,0 @@
-#pragma once
-
-#include <tuple>
-#include <iomanip>
-#include <city.h>
-
-#include <Core/Types.h>
-#include <Common/hex.h>
-
-#ifdef __SSE4_2__
-#include <nmmintrin.h>
-#endif
-
-
-namespace DB
-{
-
-/// For aggregation by SipHash, UUID type or concatenation of several fields.
-struct UInt128
-{
-/// Suppress gcc7 warnings: 'prev_key.DB::UInt128::low' may be used uninitialized in this function
-#if !defined(__clang__)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
-#endif
-
-    /// This naming assumes little endian.
-    UInt64 low;
-    UInt64 high;
-
-    /// TODO: Make this constexpr. Currently it is used in unions
-    /// and union cannot contain member with non trivial constructor
-    /// constructor must be non user provided but compiler cannot constexpr constructor
-    /// if members low and high are not initialized, if we default member initialize them
-    /// constructor becomes non trivial.
-    UInt128() = default;
-    explicit constexpr UInt128(const UInt64 low_, const UInt64 high_) : low(low_), high(high_) { }
-
-    /// We need Int128 to UInt128 conversion or AccurateComparison will call greaterOp<Int128, UInt64> instead of greaterOp<Int128, UInt128>
-    explicit constexpr UInt128(const Int128 rhs) : low(rhs), high(rhs >> 64) {}
-    explicit constexpr UInt128(const Int64 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const Int32 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const Int16 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const Int8 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const UInt8 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const UInt16 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const UInt32 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const UInt64 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const Float32 rhs) : low(rhs), high() {}
-    explicit constexpr UInt128(const Float64 rhs) : low(rhs), high() {}
-
-    constexpr auto tuple() const { return std::tie(high, low); }
-
-    String toHexString() const
-    {
-        String res(2 * sizeof(UInt128), 0);
-        writeHexUIntLowercase(*this, res.data());
-        return res;
-    }
-
-    constexpr bool operator== (const UInt128 rhs) const { return tuple() == rhs.tuple(); }
-    constexpr bool operator!= (const UInt128 rhs) const { return tuple() != rhs.tuple(); }
-    constexpr bool operator<  (const UInt128 rhs) const { return tuple() < rhs.tuple(); }
-    constexpr bool operator<= (const UInt128 rhs) const { return tuple() <= rhs.tuple(); }
-    constexpr bool operator>  (const UInt128 rhs) const { return tuple() > rhs.tuple(); }
-    constexpr bool operator>= (const UInt128 rhs) const { return tuple() >= rhs.tuple(); }
-
-    constexpr bool operator == (const Int128 rhs) const { return *this == UInt128(rhs, rhs >> 64) && rhs >= 0; }
-    constexpr bool operator != (const Int128 rhs) const { return *this != UInt128(rhs, rhs >> 64) || rhs < 0; }
-    constexpr bool operator >= (const Int128 rhs) const { return *this >= UInt128(rhs, rhs >> 64) || rhs < 0; }
-    constexpr bool operator >  (const Int128 rhs) const { return *this >  UInt128(rhs, rhs >> 64) || rhs < 0; }
-    constexpr bool operator <= (const Int128 rhs) const { return *this <= UInt128(rhs, rhs >> 64) && rhs >= 0; }
-    constexpr bool operator <  (const Int128 rhs) const { return *this <  UInt128(rhs, rhs >> 64) && rhs >= 0; }
-
-    constexpr bool operator >  (const Int256 rhs) const { return (rhs < 0) || ((Int256(high) << 64) + low) > rhs; }
-    constexpr bool operator >  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) > rhs; }
-    constexpr bool operator <  (const Int256 rhs) const { return (rhs >= 0) && ((Int256(high) << 64) + low) < rhs; }
-    constexpr bool operator <  (const UInt256 rhs) const { return ((UInt256(high) << 64) + low) < rhs; }
-
-    template <typename T> constexpr bool operator== (const T rhs) const { return *this == UInt128(rhs); }
-    template <typename T> constexpr bool operator!= (const T rhs) const { return *this != UInt128(rhs); }
-    template <typename T> constexpr bool operator>= (const T rhs) const { return *this >= UInt128(rhs); }
-    template <typename T> constexpr bool operator>  (const T rhs) const { return *this >  UInt128(rhs); }
-    template <typename T> constexpr bool operator<= (const T rhs) const { return *this <= UInt128(rhs); }
-    template <typename T> constexpr bool operator<  (const T rhs) const { return *this <  UInt128(rhs); }
-
-    template <typename T> explicit operator T() const
-    {
-        if constexpr (std::is_class_v<T>)
-            return T();
-        else
-            return static_cast<T>(low);
-    }
-
-#if !defined(__clang__)
-#pragma GCC diagnostic pop
-#endif
-
-    constexpr UInt128 & operator= (const UInt64 rhs) { low = rhs; high = 0; return *this; }
-};
-
-template <typename T> constexpr bool operator == (T a, const UInt128 b) { return b.operator==(a); }
-template <typename T> constexpr bool operator != (T a, const UInt128 b) { return b.operator!=(a); }
-template <typename T> constexpr bool operator >= (T a, const UInt128 b) { return b <= a; }
-template <typename T> constexpr bool operator >  (T a, const UInt128 b) { return b < a; }
-template <typename T> constexpr bool operator <= (T a, const UInt128 b) { return b >= a; }
-template <typename T> constexpr bool operator <  (T a, const UInt128 b) { return b > a; }
-
-template <> inline constexpr bool IsNumber<UInt128> = true;
-template <> struct TypeName<UInt128> { static constexpr const char * get() { return "UInt128"; } };
-template <> struct TypeId<UInt128> { static constexpr const TypeIndex value = TypeIndex::UInt128; };
-
-struct UInt128Hash
-{
-    size_t operator()(UInt128 x) const
-    {
-        return CityHash_v1_0_2::Hash128to64({x.low, x.high});
-    }
-};
-
-#ifdef __SSE4_2__
-
-struct UInt128HashCRC32
-{
-    size_t operator()(UInt128 x) const
-    {
-        UInt64 crc = -1ULL;
-        crc = _mm_crc32_u64(crc, x.low);
-        crc = _mm_crc32_u64(crc, x.high);
-        return crc;
-    }
-};
-
-#else
-
-/// On other platforms we do not use CRC32. NOTE This can be confusing.
-struct UInt128HashCRC32 : public UInt128Hash {};
-
-#endif
-
-struct UInt128TrivialHash
-{
-    size_t operator()(UInt128 x) const { return x.low; }
-};
-
-
-/** Used for aggregation, for putting a large number of constant-length keys in a hash table.
-  */
-struct DummyUInt256
-{
-
-/// Suppress gcc7 warnings: 'prev_key.DB::UInt256::a' may be used uninitialized in this function
-#if !defined(__clang__)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
-#endif
-
-    UInt64 a;
-    UInt64 b;
-    UInt64 c;
-    UInt64 d;
-
-    bool operator== (const DummyUInt256 rhs) const
-    {
-        return a == rhs.a && b == rhs.b && c == rhs.c && d == rhs.d;
-
-    /* So it's no better.
-        return 0xFFFF == _mm_movemask_epi8(_mm_and_si128(
-            _mm_cmpeq_epi8(
-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&a)),
-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&rhs.a))),
-            _mm_cmpeq_epi8(
-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&c)),
-                _mm_loadu_si128(reinterpret_cast<const __m128i *>(&rhs.c)))));*/
-    }
-
-    bool operator!= (const DummyUInt256 rhs) const { return !operator==(rhs); }
-
-    bool operator== (const UInt64 rhs) const { return a == rhs && b == 0 && c == 0 && d == 0; }
-    bool operator!= (const UInt64 rhs) const { return !operator==(rhs); }
-
-#if !defined(__clang__)
-#pragma GCC diagnostic pop
-#endif
-
-    DummyUInt256 & operator = (const UInt64 rhs) { a = rhs; b = 0; c = 0; d = 0; return *this; }
-};
-
-struct UInt256Hash
-{
-    size_t operator()(DummyUInt256 x) const
-    {
-        /// NOTE suboptimal
-        return CityHash_v1_0_2::Hash128to64({CityHash_v1_0_2::Hash128to64({x.a, x.b}), CityHash_v1_0_2::Hash128to64({x.c, x.d})});
-    }
-};
-
-#ifdef __SSE4_2__
-
-struct UInt256HashCRC32
-{
-    size_t operator()(DummyUInt256 x) const
-    {
-        UInt64 crc = -1ULL;
-        crc = _mm_crc32_u64(crc, x.a);
-        crc = _mm_crc32_u64(crc, x.b);
-        crc = _mm_crc32_u64(crc, x.c);
-        crc = _mm_crc32_u64(crc, x.d);
-        return crc;
-    }
-};
-
-#else
-
-/// We do not need to use CRC32 on other platforms. NOTE This can be confusing.
-struct UInt256HashCRC32 : public UInt256Hash {};
-
-#endif
-
-}
-
-template <> struct is_signed<DB::UInt128>
-{
-    static constexpr bool value = false;
-};
-
-template <> struct is_unsigned<DB::UInt128>
-{
-    static constexpr bool value = true;
-};
-
-template <> struct is_integer<DB::UInt128>
-{
-    static constexpr bool value = true;
-};
-
-// Operator +, -, /, *, % aren't implemented so it's not an arithmetic type
-template <> struct is_arithmetic<DB::UInt128>
-{
-    static constexpr bool value = false;
-};
-
-/// Overload hash for type casting
-namespace std
-{
-template <> struct hash<DB::UInt128>
-{
-    size_t operator()(const DB::UInt128 & u) const
-    {
-        return CityHash_v1_0_2::Hash128to64({u.low, u.high});
-    }
-};
-
-template<>
-class numeric_limits<DB::UInt128>
-{
-public:
-    static constexpr bool is_specialized = true;
-    static constexpr bool is_signed = ::is_signed<DB::UInt128>::value;
-    static constexpr bool is_integer = ::is_integer<DB::UInt128>::value;
-    static constexpr bool is_exact = true;
-    static constexpr bool has_infinity = false;
-    static constexpr bool has_quiet_NaN = false;
-    static constexpr bool has_signaling_NaN = false;
-    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;
-    static constexpr bool has_denorm_loss = false;
-    static constexpr std::float_round_style round_style = std::round_toward_zero;
-    static constexpr bool is_iec559 = false;
-    static constexpr bool is_bounded = true;
-    static constexpr bool is_modulo = true;
-    static constexpr int digits = std::numeric_limits<UInt64>::digits * 2;
-    static constexpr int digits10 = digits * 0.30103 /*std::log10(2)*/;
-    static constexpr int max_digits10 = 0;
-    static constexpr int radix = 2;
-    static constexpr int min_exponent = 0;
-    static constexpr int min_exponent10 = 0;
-    static constexpr int max_exponent = 0;
-    static constexpr int max_exponent10 = 0;
-    static constexpr bool traps = true;
-    static constexpr bool tinyness_before = false;
-
-    static constexpr DB::UInt128 min() noexcept { return DB::UInt128(0, 0); }
-
-    static constexpr DB::UInt128 max() noexcept
-    {
-        return DB::UInt128(std::numeric_limits<UInt64>::max(), std::numeric_limits<UInt64>::max());
-    }
-
-    static constexpr DB::UInt128 lowest() noexcept { return min(); }
-};
-
-}
diff --git a/src/Common/examples/arena_with_free_lists.cpp b/src/Common/examples/arena_with_free_lists.cpp
index d02fadca794c..207fcd7dba2f 100644
--- a/src/Common/examples/arena_with_free_lists.cpp
+++ b/src/Common/examples/arena_with_free_lists.cpp
@@ -172,17 +172,17 @@ struct Dictionary
     {
         switch (attribute.type)
         {
-            case AttributeUnderlyingType::utUInt8: std::get<ContainerPtrType<UInt8>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
-            case AttributeUnderlyingType::utUInt16: std::get<ContainerPtrType<UInt16>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
-            case AttributeUnderlyingType::utUInt32: std::get<ContainerPtrType<UInt32>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
-            case AttributeUnderlyingType::utUInt64: std::get<ContainerPtrType<UInt64>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
-            case AttributeUnderlyingType::utInt8: std::get<ContainerPtrType<Int8>>(attribute.arrays)[idx] = value.get<Int64>(); break;
-            case AttributeUnderlyingType::utInt16: std::get<ContainerPtrType<Int16>>(attribute.arrays)[idx] = value.get<Int64>(); break;
-            case AttributeUnderlyingType::utInt32: std::get<ContainerPtrType<Int32>>(attribute.arrays)[idx] = value.get<Int64>(); break;
-            case AttributeUnderlyingType::utInt64: std::get<ContainerPtrType<Int64>>(attribute.arrays)[idx] = value.get<Int64>(); break;
-            case AttributeUnderlyingType::utFloat32: std::get<ContainerPtrType<Float32>>(attribute.arrays)[idx] = value.get<Float64>(); break;
-            case AttributeUnderlyingType::utFloat64: std::get<ContainerPtrType<Float64>>(attribute.arrays)[idx] = value.get<Float64>(); break;
-            case AttributeUnderlyingType::utString:
+            case AttributeUnderlyingType::UInt8: std::get<ContainerPtrType<UInt8>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
+            case AttributeUnderlyingType::UInt16: std::get<ContainerPtrType<UInt16>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
+            case AttributeUnderlyingType::UInt32: std::get<ContainerPtrType<UInt32>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
+            case AttributeUnderlyingType::UInt64: std::get<ContainerPtrType<UInt64>>(attribute.arrays)[idx] = value.get<UInt64>(); break;
+            case AttributeUnderlyingType::Int8: std::get<ContainerPtrType<Int8>>(attribute.arrays)[idx] = value.get<Int64>(); break;
+            case AttributeUnderlyingType::Int16: std::get<ContainerPtrType<Int16>>(attribute.arrays)[idx] = value.get<Int64>(); break;
+            case AttributeUnderlyingType::Int32: std::get<ContainerPtrType<Int32>>(attribute.arrays)[idx] = value.get<Int64>(); break;
+            case AttributeUnderlyingType::Int64: std::get<ContainerPtrType<Int64>>(attribute.arrays)[idx] = value.get<Int64>(); break;
+            case AttributeUnderlyingType::Float32: std::get<ContainerPtrType<Float32>>(attribute.arrays)[idx] = value.get<Float64>(); break;
+            case AttributeUnderlyingType::Float64: std::get<ContainerPtrType<Float64>>(attribute.arrays)[idx] = value.get<Float64>(); break;
+            case AttributeUnderlyingType::String:
             {
                 const auto & string = value.get<String>();
                 auto & string_ref = std::get<ContainerPtrType<StringRef>>(attribute.arrays)[idx];
@@ -308,7 +308,7 @@ int main(int argc, char ** argv)
     constexpr size_t cache_size = 1024;
 
     Dictionary::Attribute attr;
-    attr.type = Dictionary::AttributeUnderlyingType::utString;
+    attr.type = Dictionary::AttributeUnderlyingType::String;
     std::get<Dictionary::ContainerPtrType<StringRef>>(attr.arrays).reset(new StringRef[cache_size]{});  // NOLINT
 
     while (true)
diff --git a/src/Common/getHashOfLoadedBinary.cpp b/src/Common/getHashOfLoadedBinary.cpp
index d401b0311be4..dcf483b4fa80 100644
--- a/src/Common/getHashOfLoadedBinary.cpp
+++ b/src/Common/getHashOfLoadedBinary.cpp
@@ -38,7 +38,7 @@ std::string getHashOfLoadedBinaryHex()
 {
     SipHash hash = getHashOfLoadedBinary();
     std::array<UInt64, 2> checksum;
-    hash.get128(checksum[0], checksum[1]);
+    hash.get128(checksum);
     return getHexUIntUppercase(checksum);
 }
 
diff --git a/src/Common/intExp.h b/src/Common/intExp.h
index bc977a41d33c..b2d704e58b29 100644
--- a/src/Common/intExp.h
+++ b/src/Common/intExp.h
@@ -138,9 +138,9 @@ constexpr inline Int128 exp10_i128(int x)
 }
 
 
-inline wInt256 exp10_i256(int x)
+inline Int256 exp10_i256(int x)
 {
-    using Int256 = wInt256;
+    using Int256 = Int256;
     static constexpr Int256 i10e18{1000000000000000000ll};
     static const Int256 values[] = {
         static_cast<Int256>(1ll),
diff --git a/src/Compression/getCompressionCodecForFile.cpp b/src/Compression/getCompressionCodecForFile.cpp
index 05dd49f3939b..1557985ff66d 100644
--- a/src/Compression/getCompressionCodecForFile.cpp
+++ b/src/Compression/getCompressionCodecForFile.cpp
@@ -6,8 +6,6 @@
 #include <Common/PODArray.h>
 #include <common/logger_useful.h>
 
-#include <Common/UInt128.h>
-
 namespace DB
 {
 
diff --git a/src/Core/AccurateComparison.h b/src/Core/AccurateComparison.h
index 1e45dbe23dcb..29088cbf1b5c 100644
--- a/src/Core/AccurateComparison.h
+++ b/src/Core/AccurateComparison.h
@@ -2,11 +2,11 @@
 
 #include <cmath>
 #include <limits>
-#include "Defines.h"
-#include "Types.h"
+#include <common/DecomposedFloat.h>
+#include <Core/Defines.h>
+#include <Core/Types.h>
 #include <common/extended_types.h>
 #include <Common/NaNUtils.h>
-#include <Common/UInt128.h>
 
 /** Preceptually-correct number comparisons.
   * Example: Int8(-1) != UInt8(255)
@@ -15,504 +15,142 @@
 namespace accurate
 {
 
-using DB::UInt64;
-
-/** Cases:
-    1) Safe conversion (in case of default C++ operators)
-        a) int vs any int
-        b) uint vs any uint
-        c) float vs any float
-    2) int vs uint
-        a) sizeof(int) <= sizeof(uint). Accurate comparison with MAX_INT tresholds
-        b) sizeof(int)  > sizeof(uint). Casting to int
-    3) integral_type vs floating_type
-        a) sizeof(integral_type) <= 4. Comparison via casting arguments to Float64
-        b) sizeof(integral_type) == 8. Accurate comparison. Consider 3 sets of intervals:
-            1) interval between adjacent floats less or equal 1
-            2) interval between adjacent floats greater then 2
-            3) float is outside [MIN_INT64; MAX_INT64]
-*/
-
-// Case 1. Is pair of floats or pair of ints or pair of uints
-template <typename A, typename B>
-constexpr bool is_safe_conversion = (std::is_floating_point_v<A> && std::is_floating_point_v<B>)
-    || (is_integer_v<A> && is_integer_v<B> && !(is_signed_v<A> ^ is_signed_v<B>));
-template <typename A, typename B>
-using bool_if_safe_conversion = std::enable_if_t<is_safe_conversion<A, B>, bool>;
-template <typename A, typename B>
-using bool_if_not_safe_conversion = std::enable_if_t<!is_safe_conversion<A, B>, bool>;
-
-
-/// Case 2. Are params IntXX and UIntYY ?
-template <typename TInt, typename TUInt>
-constexpr bool is_any_int_vs_uint
-    = is_integer_v<TInt> && is_integer_v<TUInt> && is_signed_v<TInt> && is_unsigned_v<TUInt>;
-
-// Case 2a. Are params IntXX and UIntYY and sizeof(IntXX) >= sizeof(UIntYY) (in such case will use accurate compare)
-template <typename TInt, typename TUInt>
-constexpr bool is_le_int_vs_uint = is_any_int_vs_uint<TInt, TUInt> && (sizeof(TInt) <= sizeof(TUInt));
-
-static_assert(is_le_int_vs_uint<Int128, DB::UInt128>);
-static_assert(is_le_int_vs_uint<Int128, DB::UInt256>);
-
-template <typename TInt, typename TUInt>
-using bool_if_le_int_vs_uint_t = std::enable_if_t<is_le_int_vs_uint<TInt, TUInt>, bool>;
-
-template <typename TInt, typename TUInt>
-inline bool_if_le_int_vs_uint_t<TInt, TUInt> greaterOpTmpl(TInt a, TUInt b)
-{
-    return static_cast<TUInt>(a) > b && a >= 0 && b <= static_cast<TUInt>(std::numeric_limits<TInt>::max());
-}
-
-template <typename TUInt, typename TInt>
-inline bool_if_le_int_vs_uint_t<TInt, TUInt> greaterOpTmpl(TUInt a, TInt b)
-{
-    return a > static_cast<TUInt>(b) || b < 0 || a > static_cast<TUInt>(std::numeric_limits<TInt>::max());
-}
-
-template <typename TInt, typename TUInt>
-inline bool_if_le_int_vs_uint_t<TInt, TUInt> equalsOpTmpl(TInt a, TUInt b)
-{
-    return static_cast<TUInt>(a) == b && a >= 0 && b <= static_cast<TUInt>(std::numeric_limits<TInt>::max());
-}
-
-template <typename TUInt, typename TInt>
-inline bool_if_le_int_vs_uint_t<TInt, TUInt> equalsOpTmpl(TUInt a, TInt b)
-{
-    return a == static_cast<TUInt>(b) && b >= 0 && a <= static_cast<TUInt>(std::numeric_limits<TInt>::max());
-}
-
-
-// Case 2b. Are params IntXX and UIntYY and sizeof(IntXX) > sizeof(UIntYY) (in such case will cast UIntYY to IntXX and compare)
-template <typename TInt, typename TUInt>
-constexpr bool is_gt_int_vs_uint = is_any_int_vs_uint<TInt, TUInt> && (sizeof(TInt) > sizeof(TUInt));
-
-template <typename TInt, typename TUInt>
-using bool_if_gt_int_vs_uint = std::enable_if_t<is_gt_int_vs_uint<TInt, TUInt>, bool>;
-
-template <typename TInt, typename TUInt>
-inline bool_if_gt_int_vs_uint<TInt, TUInt> greaterOpTmpl(TInt a, TUInt b)
-{
-    return static_cast<TInt>(a) > static_cast<TInt>(b);
-}
-
-template <typename TInt, typename TUInt>
-inline bool_if_gt_int_vs_uint<TInt, TUInt> greaterOpTmpl(TUInt a, TInt b)
-{
-    using CastA = std::conditional_t<is_big_int_v<TInt> && std::is_same_v<TUInt, DB::UInt128>, DB::UInt256, TInt>;
-
-    return static_cast<CastA>(a) > b;
-}
-
-template <typename TInt, typename TUInt>
-inline bool_if_gt_int_vs_uint<TInt, TUInt> equalsOpTmpl(TInt a, TUInt b)
-{
-    return static_cast<TInt>(a) == static_cast<TInt>(b);
-}
-
-template <typename TInt, typename TUInt>
-inline bool_if_gt_int_vs_uint<TInt, TUInt> equalsOpTmpl(TUInt a, TInt b)
-{
-    return static_cast<TInt>(a) == static_cast<TInt>(b);
-}
-
-
-// Case 3a. Comparison via conversion to double.
-template <typename TAInt, typename TAFloat>
-using bool_if_double_can_be_used
-    = std::enable_if_t<is_integer_v<TAInt> && (sizeof(TAInt) <= 4) && std::is_floating_point_v<TAFloat>, bool>;
-
-template <typename TAInt, typename TAFloat>
-inline bool_if_double_can_be_used<TAInt, TAFloat> greaterOpTmpl(TAInt a, TAFloat b)
-{
-    return static_cast<double>(a) > static_cast<double>(b);
-}
-
-template <typename TAInt, typename TAFloat>
-inline bool_if_double_can_be_used<TAInt, TAFloat> greaterOpTmpl(TAFloat a, TAInt b)
-{
-    return static_cast<double>(a) > static_cast<double>(b);
-}
-
-template <typename TAInt, typename TAFloat>
-inline bool_if_double_can_be_used<TAInt, TAFloat> equalsOpTmpl(TAInt a, TAFloat b)
-{
-    return static_cast<double>(a) == static_cast<double>(b);
-}
-
-template <typename TAInt, typename TAFloat>
-inline bool_if_double_can_be_used<TAInt, TAFloat> equalsOpTmpl(TAFloat a, TAInt b)
-{
-    return static_cast<double>(a) == static_cast<double>(b);
-}
-
-// Big integers vs Float (not equal in any case for now, until big floats are introduced?)
-template <typename TABigInt, typename TAFloat>
-constexpr bool if_big_int_vs_float = (is_big_int_v<TABigInt> && std::is_floating_point_v<TAFloat>);
-
-template <typename TABigInt, typename TAFloat>
-using bool_if_big_int_vs_float = std::enable_if_t<if_big_int_vs_float<TABigInt, TAFloat>, bool>;
-
-template <typename TABigInt, typename TAFloat>
-inline bool_if_big_int_vs_float<TABigInt, TAFloat> greaterOpTmpl(TAFloat, TABigInt)
-{
-    return false;
-}
-
-template <typename TABigInt, typename TAFloat>
-inline bool_if_big_int_vs_float<TABigInt, TAFloat> greaterOpTmpl(TABigInt, TAFloat)
-{
-    return false;
-}
-
-template <typename TABigInt, typename TAFloat>
-inline bool_if_big_int_vs_float<TABigInt, TAFloat> equalsOpTmpl(TAFloat, TABigInt)
-{
-    return false;
-}
-
-template <typename TABigInt, typename TAFloat>
-inline bool_if_big_int_vs_float<TABigInt, TAFloat> equalsOpTmpl(TABigInt, TAFloat)
-{
-    return false;
-}
-
-/* Final implementations */
+using namespace DB;
 
 
 template <typename A, typename B>
-inline bool_if_not_safe_conversion<A, B> greaterOp(A a, B b)
+bool lessOp(A a, B b)
 {
-    return greaterOpTmpl(a, b);
-}
-
-template <typename A, typename B>
-inline bool_if_safe_conversion<A, B> greaterOp(A a, B b)
-{
-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;
-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;
-
-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;
-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;
-
-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)
-        return static_cast<CastA>(a) > static_cast<CastB>(b);
-    else
-        return a > b;
-}
-
-// Case 3b. 64-bit integers vs floats comparison.
-// See hint at https://github.com/JuliaLang/julia/issues/257 (but it doesn't work properly for -2**63)
-
-constexpr DB::Int64 MAX_INT64_WITH_EXACT_FLOAT64_REPR = 9007199254740992LL; // 2^53
-
-template <>
-inline bool greaterOp<DB::Float64, DB::Int64>(DB::Float64 f, DB::Int64 i)
-{
-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)
-        return f > static_cast<DB::Float64>(i);
-
-    return (f >= static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::max())) // rhs is 2**63 (not 2^63 - 1)
-            || (f > static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::min()) && static_cast<DB::Int64>(f) > i);
-}
-
-template <>
-inline bool greaterOp<DB::Int64, DB::Float64>(DB::Int64 i, DB::Float64 f)
-{
-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)
-        return f < static_cast<DB::Float64>(i);
-
-    return (f < static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::min()))
-            || (f < static_cast<DB::Float64>(std::numeric_limits<DB::Int64>::max()) && i > static_cast<DB::Int64>(f));
-}
-
-template <>
-inline bool greaterOp<DB::Float64, DB::UInt64>(DB::Float64 f, DB::UInt64 u)
-{
-    if (u <= static_cast<DB::UInt64>(MAX_INT64_WITH_EXACT_FLOAT64_REPR))
-        return f > static_cast<DB::Float64>(u);
+    if constexpr (std::is_same_v<A, B>)
+        return a < b;
 
-    return (f >= static_cast<DB::Float64>(std::numeric_limits<DB::UInt64>::max()))
-            || (f >= 0 && static_cast<DB::UInt64>(f) > u);
-}
+    /// float vs float
+    if constexpr (std::is_floating_point_v<A> && std::is_floating_point_v<B>)
+        return a < b;
 
-template <>
-inline bool greaterOp<DB::UInt64, DB::Float64>(DB::UInt64 u, DB::Float64 f)
-{
-    if (u <= static_cast<DB::UInt64>(MAX_INT64_WITH_EXACT_FLOAT64_REPR))
-        return static_cast<DB::Float64>(u) > f;
+    /// anything vs NaN
+    if (isNaN(a) || isNaN(b))
+        return false;
 
-    return (f < 0)
-            || (f < static_cast<DB::Float64>(std::numeric_limits<DB::UInt64>::max()) && u > static_cast<UInt64>(f));
-}
+    /// int vs int
+    if constexpr (is_integer_v<A> && is_integer_v<B>)
+    {
+        /// same signedness
+        if constexpr (is_signed_v<A> == is_signed_v<B>)
+            return a < b;
 
-// Case 3b for float32
-template <>
-inline bool greaterOp<DB::Float32, DB::Int64>(DB::Float32 f, DB::Int64 i)
-{
-    return greaterOp(static_cast<DB::Float64>(f), i);
-}
+        /// different signedness
 
-template <>
-inline bool greaterOp<DB::Int64, DB::Float32>(DB::Int64 i, DB::Float32 f)
-{
-    return greaterOp(i, static_cast<DB::Float64>(f));
-}
+        if constexpr (is_signed_v<A> && !is_signed_v<B>)
+            return a < 0 || static_cast<make_unsigned_t<A>>(a) < b;
 
-template <>
-inline bool greaterOp<DB::Float32, DB::UInt64>(DB::Float32 f, DB::UInt64 u)
-{
-    return greaterOp(static_cast<DB::Float64>(f), u);
-}
+        if constexpr (!is_signed_v<A> && is_signed_v<B>)
+            return b >= 0 && a < static_cast<make_unsigned_t<B>>(b);
+    }
 
-template <>
-inline bool greaterOp<DB::UInt64, DB::Float32>(DB::UInt64 u, DB::Float32 f)
-{
-    return greaterOp(u, static_cast<DB::Float64>(f));
-}
+    /// int vs float
+    if constexpr (is_integer_v<A> && std::is_floating_point_v<B>)
+    {
+        if constexpr (sizeof(A) <= 4)
+            return static_cast<double>(a) < static_cast<double>(b);
 
-template <>
-inline bool greaterOp<DB::Float64, DB::UInt128>(DB::Float64 f, DB::UInt128 u)
-{
-    /// TODO: This is wrong.
-    return u.low == 0 && greaterOp(f, u.high);
-}
+        return DecomposedFloat<B>(b).greater(a);
+    }
 
-template <>
-inline bool greaterOp<DB::UInt128, DB::Float64>(DB::UInt128 u, DB::Float64 f)
-{
-    /// TODO: This is wrong.
-    return u.low != 0 || greaterOp(u.high, f);
-}
+    if constexpr (std::is_floating_point_v<A> && is_integer_v<B>)
+    {
+        if constexpr (sizeof(B) <= 4)
+            return static_cast<double>(a) < static_cast<double>(b);
 
-template <>
-inline bool greaterOp<DB::Float32, DB::UInt128>(DB::Float32 f, DB::UInt128 u)
-{
-    return greaterOp(static_cast<DB::Float64>(f), u);
-}
+        return DecomposedFloat<A>(a).less(b);
+    }
 
-template <>
-inline bool greaterOp<DB::UInt128, DB::Float32>(DB::UInt128 u, DB::Float32 f)
-{
-    return greaterOp(u, static_cast<DB::Float64>(f));
+    static_assert(is_integer_v<A> || std::is_floating_point_v<A>);
+    static_assert(is_integer_v<B> || std::is_floating_point_v<B>);
+    __builtin_unreachable();
 }
 
 template <typename A, typename B>
-inline bool_if_not_safe_conversion<A, B> equalsOp(A a, B b)
+bool greaterOp(A a, B b)
 {
-    return equalsOpTmpl(a, b);
+    return lessOp(b, a);
 }
 
 template <typename A, typename B>
-inline bool_if_safe_conversion<A, B> equalsOp(A a, B b)
-{
-    using LargestType = std::conditional_t<(sizeof(A) > sizeof(B)) || ((sizeof(A) == sizeof(B)) && !std::is_same_v<A, DB::UInt128>), A, B>;
-
-    return static_cast<LargestType>(a) == static_cast<LargestType>(b);
-}
-
-template <>
-inline bool equalsOp<DB::Float64, DB::UInt64>(DB::Float64 f, DB::UInt64 u)
-{
-    /// Maximum exactly representable integer.
-    return u <= (1ULL << std::numeric_limits<DB::Float64>::digits)
-        && f == static_cast<DB::Float64>(u);
-}
-
-template <>
-inline bool equalsOp<DB::UInt64, DB::Float64>(DB::UInt64 u, DB::Float64 f)
-{
-    return equalsOp(f, u);
-}
-
-template <>
-inline bool equalsOp<DB::Float64, DB::Int64>(DB::Float64 f, DB::Int64 u)
-{
-    return u <= (1LL << std::numeric_limits<DB::Float64>::digits)
-        && u >= -(1LL << std::numeric_limits<DB::Float64>::digits)
-        && f == static_cast<DB::Float64>(u);
-}
-
-template <>
-inline bool equalsOp<DB::Int64, DB::Float64>(DB::Int64 u, DB::Float64 f)
-{
-    return equalsOp(f, u);
-}
-
-template <>
-inline bool equalsOp<DB::Float32, DB::UInt64>(DB::Float32 f, DB::UInt64 u)
-{
-    return u <= (1ULL << std::numeric_limits<DB::Float32>::digits)
-        && f == static_cast<DB::Float32>(u);
-}
-
-template <>
-inline bool equalsOp<DB::UInt64, DB::Float32>(DB::UInt64 u, DB::Float32 f)
-{
-    return equalsOp(f, u);
-}
-
-template <>
-inline bool equalsOp<DB::Float32, DB::Int64>(DB::Float32 f, DB::Int64 u)
-{
-    return u <= (1LL << std::numeric_limits<DB::Float32>::digits)
-        && u >= -(1LL << std::numeric_limits<DB::Float32>::digits)
-        && f == static_cast<DB::Float32>(u);
-}
-
-template <>
-inline bool equalsOp<DB::Int64, DB::Float32>(DB::Int64 u, DB::Float32 f)
-{
-    return equalsOp(f, u);
-}
-
-template <>
-inline bool equalsOp<DB::UInt128, DB::Float64>(DB::UInt128 u, DB::Float64 f)
-{
-    /// TODO: This is wrong.
-    return u.low == 0 && equalsOp(static_cast<UInt64>(u.high), f);
-}
-
-template <>
-inline bool equalsOp<DB::UInt128, DB::Float32>(DB::UInt128 u, DB::Float32 f)
-{
-    return equalsOp(u, static_cast<DB::Float64>(f));
-}
-
-template <>
-inline bool equalsOp<DB::Float64, DB::UInt128>(DB::Float64 f, DB::UInt128 u)
-{
-    return equalsOp(u, f);
-}
-
-template <>
-inline bool equalsOp<DB::Float32, DB::UInt128>(DB::Float32 f, DB::UInt128 u)
+bool greaterOrEqualsOp(A a, B b)
 {
-    return equalsOp(static_cast<DB::Float64>(f), u);
-}
-
-inline bool NO_SANITIZE_UNDEFINED greaterOp(DB::Int128 i, DB::Float64 f)
-{
-    static constexpr Int128 min_int128 = minInt128();
-    static constexpr Int128 max_int128 = maxInt128();
-
-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)
-        return static_cast<DB::Float64>(i) > f;
-
-    return (f < static_cast<DB::Float64>(min_int128))
-        || (f < static_cast<DB::Float64>(max_int128) && i > static_cast<DB::Int128>(f));
-}
-
-inline bool NO_SANITIZE_UNDEFINED greaterOp(DB::Float64 f, DB::Int128 i)
-{
-    static constexpr Int128 min_int128 = minInt128();
-    static constexpr Int128 max_int128 = maxInt128();
-
-    if (-MAX_INT64_WITH_EXACT_FLOAT64_REPR <= i && i <= MAX_INT64_WITH_EXACT_FLOAT64_REPR)
-        return f > static_cast<DB::Float64>(i);
+    if (isNaN(a) || isNaN(b))
+        return false;
 
-    return (f >= static_cast<DB::Float64>(max_int128))
-        || (f > static_cast<DB::Float64>(min_int128) && static_cast<DB::Int128>(f) > i);
+    return !lessOp(a, b);
 }
 
-inline bool greaterOp(DB::Int128 i, DB::Float32 f) { return greaterOp(i, static_cast<DB::Float64>(f)); }
-inline bool greaterOp(DB::Float32 f, DB::Int128 i) { return greaterOp(static_cast<DB::Float64>(f), i); }
-
-inline bool NO_SANITIZE_UNDEFINED equalsOp(DB::Int128 i, DB::Float64 f) { return i == static_cast<DB::Int128>(f) && static_cast<DB::Float64>(i) == f; }
-inline bool NO_SANITIZE_UNDEFINED equalsOp(DB::Int128 i, DB::Float32 f) { return i == static_cast<DB::Int128>(f) && static_cast<DB::Float32>(i) == f; }
-inline bool equalsOp(DB::Float64 f, DB::Int128 i) { return equalsOp(i, f); }
-inline bool equalsOp(DB::Float32 f, DB::Int128 i) { return equalsOp(i, f); }
-
 template <typename A, typename B>
-inline bool_if_not_safe_conversion<A, B> notEqualsOp(A a, B b)
+bool lessOrEqualsOp(A a, B b)
 {
-    return !equalsOp(a, b);
+    if (isNaN(a) || isNaN(b))
+        return false;
+
+    return !lessOp(b, a);
 }
 
 template <typename A, typename B>
-inline bool_if_safe_conversion<A, B> notEqualsOp(A a, B b)
+bool equalsOp(A a, B b)
 {
-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;
-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;
+    if constexpr (std::is_same_v<A, B>)
+        return a == b;
 
-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;
-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;
+    /// float vs float
+    if constexpr (std::is_floating_point_v<A> && std::is_floating_point_v<B>)
+        return a == b;
 
-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)
-        return static_cast<CastA>(a) != static_cast<CastB>(b);
-    else
-        return a != b;
-}
+    /// anything vs NaN
+    if (isNaN(a) || isNaN(b))
+        return false;
 
+    /// int vs int
+    if constexpr (is_integer_v<A> && is_integer_v<B>)
+    {
+        /// same signedness
+        if constexpr (is_signed_v<A> == is_signed_v<B>)
+            return a == b;
 
-template <typename A, typename B>
-inline bool_if_not_safe_conversion<A, B> lessOp(A a, B b)
-{
-    return greaterOp(b, a);
-}
+        /// different signedness
 
-template <typename A, typename B>
-inline bool_if_safe_conversion<A, B> lessOp(A a, B b)
-{
-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;
-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;
+        if constexpr (is_signed_v<A> && !is_signed_v<B>)
+            return a >= 0 && static_cast<make_unsigned_t<A>>(a) == b;
 
-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;
-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;
-
-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)
-        return static_cast<CastA>(a) < static_cast<CastB>(b);
-    else
-        return a < b;
-}
+        if constexpr (!is_signed_v<A> && is_signed_v<B>)
+            return b >= 0 && a == static_cast<make_unsigned_t<B>>(b);
+    }
 
+    /// int vs float
+    if constexpr (is_integer_v<A> && std::is_floating_point_v<B>)
+    {
+        if constexpr (sizeof(A) <= 4)
+            return static_cast<double>(a) == static_cast<double>(b);
 
-template <typename A, typename B>
-inline bool_if_not_safe_conversion<A, B> lessOrEqualsOp(A a, B b)
-{
-    if (isNaN(a) || isNaN(b))
-        return false;
-    return !greaterOp(a, b);
-}
+        return DecomposedFloat<B>(b).equals(a);
+    }
 
-template <typename A, typename B>
-inline bool_if_safe_conversion<A, B> lessOrEqualsOp(A a, B b)
-{
-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;
-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;
+    if constexpr (std::is_floating_point_v<A> && is_integer_v<B>)
+    {
+        if constexpr (sizeof(B) <= 4)
+            return static_cast<double>(a) == static_cast<double>(b);
 
-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;
-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;
+        return DecomposedFloat<A>(a).equals(b);
+    }
 
-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)
-        return static_cast<CastA>(a) <= static_cast<CastB>(b);
-    else
-        return a <= b;
+    /// e.g comparing UUID with integer.
+    return false;
 }
 
-
 template <typename A, typename B>
-inline bool_if_not_safe_conversion<A, B> greaterOrEqualsOp(A a, B b)
+bool notEqualsOp(A a, B b)
 {
-    if (isNaN(a) || isNaN(b))
-        return false;
-    return !greaterOp(b, a);
+    return !equalsOp(a, b);
 }
 
-template <typename A, typename B>
-inline bool_if_safe_conversion<A, B> greaterOrEqualsOp(A a, B b)
-{
-    using CastA1 = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, UInt8>, uint8_t, A>;
-    using CastB1 = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, UInt8>, uint8_t, B>;
-
-    using CastA = std::conditional_t<is_big_int_v<B> && std::is_same_v<A, DB::UInt128>, B, CastA1>;
-    using CastB = std::conditional_t<is_big_int_v<A> && std::is_same_v<B, DB::UInt128>, A, CastB1>;
-
-    if constexpr (is_big_int_v<A> || is_big_int_v<B>)
-        return static_cast<CastA>(a) >= static_cast<CastB>(b);
-    else
-        return a >= b;
-}
 
 /// Converts numeric to an equal numeric of other type.
 template <typename From, typename To>
@@ -547,8 +185,8 @@ inline bool NO_SANITIZE_UNDEFINED convertNumeric(From value, To & result)
         }
     }
 
-    if (accurate::greaterOp(value, std::numeric_limits<To>::max())
-        || accurate::greaterOp(std::numeric_limits<To>::lowest(), value))
+    if (greaterOp(value, std::numeric_limits<To>::max())
+        || lessOp(value, std::numeric_limits<To>::lowest()))
     {
         return false;
     }
diff --git a/src/Core/BaseSettings.h b/src/Core/BaseSettings.h
index b193fdd4c933..3b6cc61d1ebc 100644
--- a/src/Core/BaseSettings.h
+++ b/src/Core/BaseSettings.h
@@ -2,7 +2,6 @@
 
 #include <Core/SettingsFields.h>
 #include <Common/SettingsChanges.h>
-#include <Common/FieldVisitors.h>
 #include <ext/range.h>
 #include <boost/blank.hpp>
 #include <unordered_map>
diff --git a/src/Core/DecimalComparison.h b/src/Core/DecimalComparison.h
index 486c2c1f8f47..5b017cd46348 100644
--- a/src/Core/DecimalComparison.h
+++ b/src/Core/DecimalComparison.h
@@ -36,10 +36,13 @@ inline bool allowDecimalComparison(const DataTypePtr & left_type, const DataType
     return false;
 }
 
-template <size_t > struct ConstructDecInt { using Type = Int32; };
+template <size_t> struct ConstructDecInt;
+template <> struct ConstructDecInt<1> { using Type = Int32; };
+template <> struct ConstructDecInt<2> { using Type = Int32; };
+template <> struct ConstructDecInt<4> { using Type = Int32; };
 template <> struct ConstructDecInt<8> { using Type = Int64; };
 template <> struct ConstructDecInt<16> { using Type = Int128; };
-template <> struct ConstructDecInt<48> { using Type = Int256; };
+template <> struct ConstructDecInt<32> { using Type = Int256; };
 
 template <typename T, typename U>
 struct DecCompareInt
@@ -249,7 +252,7 @@ class DecimalComparison
                 overflow |= common::mulOverflow(y, scale, y);
 
             if (overflow)
-                throw Exception("Can't compare", ErrorCodes::DECIMAL_OVERFLOW);
+                throw Exception("Can't compare decimal number due to overflow", ErrorCodes::DECIMAL_OVERFLOW);
         }
         else
         {
diff --git a/src/Core/DecimalFunctions.h b/src/Core/DecimalFunctions.h
index 2131a6e3c33e..0e3992100882 100644
--- a/src/Core/DecimalFunctions.h
+++ b/src/Core/DecimalFunctions.h
@@ -276,9 +276,7 @@ template <typename To, typename DecimalType>
 To convertTo(const DecimalType & decimal, size_t scale)
 {
     To result;
-
     convertToImpl<To, DecimalType, void>(decimal, scale, result);
-
     return result;
 }
 
diff --git a/src/Core/Field.cpp b/src/Core/Field.cpp
index 8aa79b0bbe11..9dec8563d36c 100644
--- a/src/Core/Field.cpp
+++ b/src/Core/Field.cpp
@@ -238,6 +238,13 @@ Field Field::restoreFromDump(const std::string_view & dump_)
         return value;
     }
 
+    prefix = std::string_view{"UInt128_"};
+    if (dump.starts_with(prefix))
+    {
+        UInt128 value = parseFromString<UInt128>(dump.substr(prefix.length()));
+        return value;
+    }
+
     prefix = std::string_view{"Int256_"};
     if (dump.starts_with(prefix))
     {
@@ -295,15 +302,6 @@ Field Field::restoreFromDump(const std::string_view & dump_)
         return decimal;
     }
 
-    prefix = std::string_view{"UUID_"};
-    if (dump.starts_with(prefix))
-    {
-        UUID uuid;
-        ReadBufferFromString buf{dump.substr(prefix.length())};
-        readQuoted(uuid, buf);
-        return uuid;
-    }
-
     if (dump.starts_with("\'"))
     {
         String str;
@@ -410,45 +408,45 @@ Field Field::restoreFromDump(const std::string_view & dump_)
 
 
 template <typename T>
-static bool decEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)
+bool decimalEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)
 {
     using Comparator = DecimalComparison<T, T, EqualsOp>;
     return Comparator::compare(x, y, x_scale, y_scale);
 }
 
 template <typename T>
-static bool decLess(T x, T y, UInt32 x_scale, UInt32 y_scale)
+bool decimalLess(T x, T y, UInt32 x_scale, UInt32 y_scale)
 {
     using Comparator = DecimalComparison<T, T, LessOp>;
     return Comparator::compare(x, y, x_scale, y_scale);
 }
 
 template <typename T>
-static bool decLessOrEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)
+bool decimalLessOrEqual(T x, T y, UInt32 x_scale, UInt32 y_scale)
 {
     using Comparator = DecimalComparison<T, T, LessOrEqualsOp>;
     return Comparator::compare(x, y, x_scale, y_scale);
 }
 
-template <> bool decimalEqual(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }
-template <> bool decimalLess(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }
-template <> bool decimalLessOrEqual(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }
 
-template <> bool decimalEqual(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }
-template <> bool decimalLess(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }
-template <> bool decimalLessOrEqual(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }
+template bool decimalEqual<Decimal32>(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalEqual<Decimal64>(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalEqual<Decimal128>(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalEqual<Decimal256>(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalEqual<DateTime64>(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale);
 
-template <> bool decimalEqual(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }
-template <> bool decimalLess(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }
-template <> bool decimalLessOrEqual(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }
+template bool decimalLess<Decimal32>(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLess<Decimal64>(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLess<Decimal128>(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLess<Decimal256>(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLess<DateTime64>(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale);
 
-template <> bool decimalEqual(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }
-template <> bool decimalLess(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }
-template <> bool decimalLessOrEqual(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }
+template bool decimalLessOrEqual<Decimal32>(Decimal32 x, Decimal32 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLessOrEqual<Decimal64>(Decimal64 x, Decimal64 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLessOrEqual<Decimal128>(Decimal128 x, Decimal128 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLessOrEqual<Decimal256>(Decimal256 x, Decimal256 y, UInt32 x_scale, UInt32 y_scale);
+template bool decimalLessOrEqual<DateTime64>(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale);
 
-template <> bool decimalEqual(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decEqual(x, y, x_scale, y_scale); }
-template <> bool decimalLess(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decLess(x, y, x_scale, y_scale); }
-template <> bool decimalLessOrEqual(DateTime64 x, DateTime64 y, UInt32 x_scale, UInt32 y_scale) { return decLessOrEqual(x, y, x_scale, y_scale); }
 
 inline void writeText(const Null &, WriteBuffer & buf)
 {
diff --git a/src/Core/Field.h b/src/Core/Field.h
index 2c3ca1310e4b..fb9f811ddf3d 100644
--- a/src/Core/Field.h
+++ b/src/Core/Field.h
@@ -7,7 +7,6 @@
 #include <functional>
 
 #include <Common/Exception.h>
-#include <Common/UInt128.h>
 #include <Common/AllocatorWithMemoryTracking.h>
 #include <Core/Types.h>
 #include <Core/Defines.h>
@@ -177,8 +176,7 @@ template <> struct NearestFieldTypeImpl<UInt16> { using Type = UInt64; };
 template <> struct NearestFieldTypeImpl<UInt32> { using Type = UInt64; };
 
 template <> struct NearestFieldTypeImpl<DayNum> { using Type = UInt64; };
-template <> struct NearestFieldTypeImpl<UInt128> { using Type = UInt128; };
-template <> struct NearestFieldTypeImpl<UUID> { using Type = UInt128; };
+template <> struct NearestFieldTypeImpl<UUID> { using Type = UUID; };
 template <> struct NearestFieldTypeImpl<Int16> { using Type = Int64; };
 template <> struct NearestFieldTypeImpl<Int32> { using Type = Int64; };
 
@@ -191,8 +189,9 @@ template <> struct NearestFieldTypeImpl<unsigned long long> { using Type = UInt6
 
 template <> struct NearestFieldTypeImpl<UInt256> { using Type = UInt256; };
 template <> struct NearestFieldTypeImpl<Int256> { using Type = Int256; };
-
+template <> struct NearestFieldTypeImpl<UInt128> { using Type = UInt128; };
 template <> struct NearestFieldTypeImpl<Int128> { using Type = Int128; };
+
 template <> struct NearestFieldTypeImpl<Decimal32> { using Type = DecimalField<Decimal32>; };
 template <> struct NearestFieldTypeImpl<Decimal64> { using Type = DecimalField<Decimal64>; };
 template <> struct NearestFieldTypeImpl<Decimal128> { using Type = DecimalField<Decimal128>; };
@@ -235,7 +234,7 @@ struct NearestFieldTypeImpl<T, std::enable_if_t<std::is_enum_v<T>>>
   *  but somewhat more efficient, and simpler.
   *
   * Used to represent a single value of one of several types in memory.
-  * Warning! Prefer to use chunks of columns instead of single values. See Column.h
+  * Warning! Prefer to use chunks of columns instead of single values. See IColumn.h
   */
 class Field
 {
@@ -252,8 +251,6 @@ class Field
             UInt128 = 4,
             Int128  = 5,
 
-            /// Non-POD types.
-
             String  = 16,
             Array   = 17,
             Tuple   = 18,
@@ -265,10 +262,9 @@ class Field
             UInt256 = 24,
             Int256  = 25,
             Map = 26,
+            UUID = 27,
         };
 
-        static const int MIN_NON_POD = 16;
-
         static const char * toString(Which which)
         {
             switch (which)
@@ -276,8 +272,11 @@ class Field
                 case Null:    return "Null";
                 case UInt64:  return "UInt64";
                 case UInt128: return "UInt128";
+                case UInt256: return "UInt256";
                 case Int64:   return "Int64";
                 case Int128:  return "Int128";
+                case Int256:  return "Int256";
+                case UUID:    return "UUID";
                 case Float64: return "Float64";
                 case String:  return "String";
                 case Array:   return "Array";
@@ -288,8 +287,6 @@ class Field
                 case Decimal128: return "Decimal128";
                 case Decimal256: return "Decimal256";
                 case AggregateFunctionState: return "AggregateFunctionState";
-                case UInt256: return "UInt256";
-                case Int256:  return "Int256";
             }
 
             throw Exception("Bad type of Field", ErrorCodes::BAD_TYPE_OF_FIELD);
@@ -303,12 +300,17 @@ class Field
 
     static bool IsDecimal(Types::Which which)
     {
-        return (which >= Types::Decimal32 && which <= Types::Decimal128) || which == Types::Decimal256;
+        return which == Types::Decimal32
+            || which == Types::Decimal64
+            || which == Types::Decimal128
+            || which == Types::Decimal256;
     }
 
     /// Templates to avoid ambiguity.
     template <typename T, typename Z = void *>
-    using enable_if_not_field_or_stringlike_t = std::enable_if_t<!std::is_same_v<std::decay_t<T>, Field> && !std::is_same_v<NearestFieldType<std::decay_t<T>>, String>, Z>;
+    using enable_if_not_field_or_stringlike_t = std::enable_if_t<
+        !std::is_same_v<std::decay_t<T>, Field>
+        && !std::is_same_v<NearestFieldType<std::decay_t<T>>, String>, Z>;
 
     Field() //-V730
         : which(Types::Null)
@@ -382,10 +384,10 @@ class Field
     enable_if_not_field_or_stringlike_t<T, Field> &
     operator=(T && rhs);
 
-    Field & operator =(const std::string_view & str);
-    Field & operator =(const String & str) { return *this = std::string_view{str}; }
-    Field & operator =(String && str);
-    Field & operator =(const char * str) { return *this = std::string_view{str}; }
+    Field & operator= (const std::string_view & str);
+    Field & operator= (const String & str) { return *this = std::string_view{str}; }
+    Field & operator= (String && str);
+    Field & operator= (const char * str) { return *this = std::string_view{str}; }
 
     ~Field()
     {
@@ -454,8 +456,11 @@ class Field
             case Types::Null:    return false;
             case Types::UInt64:  return get<UInt64>()  < rhs.get<UInt64>();
             case Types::UInt128: return get<UInt128>() < rhs.get<UInt128>();
+            case Types::UInt256: return get<UInt256>() < rhs.get<UInt256>();
             case Types::Int64:   return get<Int64>()   < rhs.get<Int64>();
             case Types::Int128:  return get<Int128>()  < rhs.get<Int128>();
+            case Types::Int256:  return get<Int256>()  < rhs.get<Int256>();
+            case Types::UUID:    return get<UUID>()    < rhs.get<UUID>();
             case Types::Float64: return get<Float64>() < rhs.get<Float64>();
             case Types::String:  return get<String>()  < rhs.get<String>();
             case Types::Array:   return get<Array>()   < rhs.get<Array>();
@@ -466,8 +471,6 @@ class Field
             case Types::Decimal128: return get<DecimalField<Decimal128>>() < rhs.get<DecimalField<Decimal128>>();
             case Types::Decimal256: return get<DecimalField<Decimal256>>() < rhs.get<DecimalField<Decimal256>>();
             case Types::AggregateFunctionState:  return get<AggregateFunctionStateData>() < rhs.get<AggregateFunctionStateData>();
-            case Types::UInt256: return get<UInt256>() < rhs.get<UInt256>();
-            case Types::Int256: return get<Int256>() < rhs.get<Int256>();
         }
 
         throw Exception("Bad type of Field", ErrorCodes::BAD_TYPE_OF_FIELD);
@@ -490,8 +493,11 @@ class Field
             case Types::Null:    return true;
             case Types::UInt64:  return get<UInt64>()  <= rhs.get<UInt64>();
             case Types::UInt128: return get<UInt128>() <= rhs.get<UInt128>();
+            case Types::UInt256: return get<UInt256>() <= rhs.get<UInt256>();
             case Types::Int64:   return get<Int64>()   <= rhs.get<Int64>();
             case Types::Int128:  return get<Int128>()  <= rhs.get<Int128>();
+            case Types::Int256:  return get<Int256>()  <= rhs.get<Int256>();
+            case Types::UUID:    return get<UUID>().toUnderType() <= rhs.get<UUID>().toUnderType();
             case Types::Float64: return get<Float64>() <= rhs.get<Float64>();
             case Types::String:  return get<String>()  <= rhs.get<String>();
             case Types::Array:   return get<Array>()   <= rhs.get<Array>();
@@ -502,8 +508,6 @@ class Field
             case Types::Decimal128: return get<DecimalField<Decimal128>>() <= rhs.get<DecimalField<Decimal128>>();
             case Types::Decimal256: return get<DecimalField<Decimal256>>() <= rhs.get<DecimalField<Decimal256>>();
             case Types::AggregateFunctionState:  return get<AggregateFunctionStateData>() <= rhs.get<AggregateFunctionStateData>();
-            case Types::UInt256: return get<UInt256>() <= rhs.get<UInt256>();
-            case Types::Int256: return get<Int256>() <= rhs.get<Int256>();
         }
 
         throw Exception("Bad type of Field", ErrorCodes::BAD_TYPE_OF_FIELD);
@@ -531,19 +535,20 @@ class Field
                 // Compare as UInt64 so that NaNs compare as equal.
                 return reinterpret<UInt64>() == rhs.reinterpret<UInt64>();
             }
+            case Types::UUID:    return get<UUID>()    == rhs.get<UUID>();
             case Types::String:  return get<String>()  == rhs.get<String>();
             case Types::Array:   return get<Array>()   == rhs.get<Array>();
             case Types::Tuple:   return get<Tuple>()   == rhs.get<Tuple>();
             case Types::Map:     return get<Map>()     == rhs.get<Map>();
             case Types::UInt128: return get<UInt128>() == rhs.get<UInt128>();
+            case Types::UInt256: return get<UInt256>() == rhs.get<UInt256>();
             case Types::Int128:  return get<Int128>()  == rhs.get<Int128>();
+            case Types::Int256:  return get<Int256>()  == rhs.get<Int256>();
             case Types::Decimal32:  return get<DecimalField<Decimal32>>()  == rhs.get<DecimalField<Decimal32>>();
             case Types::Decimal64:  return get<DecimalField<Decimal64>>()  == rhs.get<DecimalField<Decimal64>>();
             case Types::Decimal128: return get<DecimalField<Decimal128>>() == rhs.get<DecimalField<Decimal128>>();
             case Types::Decimal256: return get<DecimalField<Decimal256>>() == rhs.get<DecimalField<Decimal256>>();
             case Types::AggregateFunctionState:  return get<AggregateFunctionStateData>() == rhs.get<AggregateFunctionStateData>();
-            case Types::UInt256: return get<UInt256>() == rhs.get<UInt256>();
-            case Types::Int256:  return get<Int256>()  == rhs.get<Int256>();
         }
 
         throw Exception("Bad type of Field", ErrorCodes::BAD_TYPE_OF_FIELD);
@@ -569,7 +574,11 @@ class Field
 #endif
             case Types::UInt64:  return f(field.template get<UInt64>());
             case Types::UInt128: return f(field.template get<UInt128>());
+            case Types::UInt256: return f(field.template get<UInt256>());
             case Types::Int64:   return f(field.template get<Int64>());
+            case Types::Int128:  return f(field.template get<Int128>());
+            case Types::Int256:  return f(field.template get<Int256>());
+            case Types::UUID:    return f(field.template get<UUID>());
             case Types::Float64: return f(field.template get<Float64>());
             case Types::String:  return f(field.template get<String>());
             case Types::Array:   return f(field.template get<Array>());
@@ -580,19 +589,12 @@ class Field
             case Types::Decimal128: return f(field.template get<DecimalField<Decimal128>>());
             case Types::Decimal256: return f(field.template get<DecimalField<Decimal256>>());
             case Types::AggregateFunctionState: return f(field.template get<AggregateFunctionStateData>());
-            case Types::Int128: return f(field.template get<Int128>());
-            case Types::UInt256: return f(field.template get<UInt256>());
-            case Types::Int256: return f(field.template get<Int256>());
 #if !defined(__clang__)
 #pragma GCC diagnostic pop
 #endif
         }
 
-        // GCC 9 complains that control reaches the end, despite that we handle
-        // all the cases above (maybe because of throw?). Return something to
-        // silence it.
-        Null null{};
-        return f(null);
+        __builtin_unreachable();
     }
 
     String dump() const;
@@ -600,10 +602,9 @@ class Field
 
 private:
     std::aligned_union_t<DBMS_MIN_FIELD_SIZE - sizeof(Types::Which),
-        Null, UInt64, UInt128, Int64, Int128, Float64, String, Array, Tuple, Map,
+        Null, UInt64, UInt128, UInt256, Int64, Int128, Int256, UUID, Float64, String, Array, Tuple, Map,
         DecimalField<Decimal32>, DecimalField<Decimal64>, DecimalField<Decimal128>, DecimalField<Decimal256>,
-        AggregateFunctionStateData,
-        UInt256, Int256
+        AggregateFunctionStateData
         > storage;
 
     Types::Which which;
@@ -685,9 +686,6 @@ class Field
 
     ALWAYS_INLINE void destroy()
     {
-        if (which < Types::MIN_NON_POD)
-            return;
-
         switch (which)
         {
             case Types::String:
@@ -726,8 +724,11 @@ class Field
 template <> struct Field::TypeToEnum<Null>    { static const Types::Which value = Types::Null; };
 template <> struct Field::TypeToEnum<UInt64>  { static const Types::Which value = Types::UInt64; };
 template <> struct Field::TypeToEnum<UInt128> { static const Types::Which value = Types::UInt128; };
+template <> struct Field::TypeToEnum<UInt256> { static const Types::Which value = Types::UInt256; };
 template <> struct Field::TypeToEnum<Int64>   { static const Types::Which value = Types::Int64; };
 template <> struct Field::TypeToEnum<Int128>  { static const Types::Which value = Types::Int128; };
+template <> struct Field::TypeToEnum<Int256>  { static const Types::Which value = Types::Int256; };
+template <> struct Field::TypeToEnum<UUID>    { static const Types::Which value = Types::UUID; };
 template <> struct Field::TypeToEnum<Float64> { static const Types::Which value = Types::Float64; };
 template <> struct Field::TypeToEnum<String>  { static const Types::Which value = Types::String; };
 template <> struct Field::TypeToEnum<Array>   { static const Types::Which value = Types::Array; };
@@ -739,14 +740,15 @@ template <> struct Field::TypeToEnum<DecimalField<Decimal128>>{ static const Typ
 template <> struct Field::TypeToEnum<DecimalField<Decimal256>>{ static const Types::Which value = Types::Decimal256; };
 template <> struct Field::TypeToEnum<DecimalField<DateTime64>>{ static const Types::Which value = Types::Decimal64; };
 template <> struct Field::TypeToEnum<AggregateFunctionStateData>{ static const Types::Which value = Types::AggregateFunctionState; };
-template <> struct Field::TypeToEnum<UInt256> { static const Types::Which value = Types::UInt256; };
-template <> struct Field::TypeToEnum<Int256> { static const Types::Which value = Types::Int256; };
 
 template <> struct Field::EnumToType<Field::Types::Null>    { using Type = Null; };
 template <> struct Field::EnumToType<Field::Types::UInt64>  { using Type = UInt64; };
 template <> struct Field::EnumToType<Field::Types::UInt128> { using Type = UInt128; };
+template <> struct Field::EnumToType<Field::Types::UInt256> { using Type = UInt256; };
 template <> struct Field::EnumToType<Field::Types::Int64>   { using Type = Int64; };
 template <> struct Field::EnumToType<Field::Types::Int128>  { using Type = Int128; };
+template <> struct Field::EnumToType<Field::Types::Int256>  { using Type = Int256; };
+template <> struct Field::EnumToType<Field::Types::UUID>    { using Type = UUID; };
 template <> struct Field::EnumToType<Field::Types::Float64> { using Type = Float64; };
 template <> struct Field::EnumToType<Field::Types::String>  { using Type = String; };
 template <> struct Field::EnumToType<Field::Types::Array>   { using Type = Array; };
@@ -757,10 +759,8 @@ template <> struct Field::EnumToType<Field::Types::Decimal64> { using Type = Dec
 template <> struct Field::EnumToType<Field::Types::Decimal128> { using Type = DecimalField<Decimal128>; };
 template <> struct Field::EnumToType<Field::Types::Decimal256> { using Type = DecimalField<Decimal256>; };
 template <> struct Field::EnumToType<Field::Types::AggregateFunctionState> { using Type = DecimalField<AggregateFunctionStateData>; };
-template <> struct Field::EnumToType<Field::Types::UInt256> { using Type = UInt256; };
-template <> struct Field::EnumToType<Field::Types::Int256>  { using Type = Int256; };
 
-inline constexpr bool isInt64FieldType(Field::Types::Which t)
+inline constexpr bool isInt64OrUInt64FieldType(Field::Types::Which t)
 {
     return t == Field::Types::Int64
         || t == Field::Types::UInt64;
@@ -782,7 +782,7 @@ NearestFieldType<std::decay_t<T>> & Field::get()
     // Disregard signedness when converting between int64 types.
     constexpr Field::Types::Which target = TypeToEnum<StoredType>::value;
     if (target != which
-           && (!isInt64FieldType(target) || !isInt64FieldType(which)))
+           && (!isInt64OrUInt64FieldType(target) || !isInt64OrUInt64FieldType(which)))
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Invalid Field get from type {} to type {}", Types::toString(which), Types::toString(target));
 #endif
 
@@ -834,11 +834,11 @@ T safeGet(Field & field)
     return field.template safeGet<T>();
 }
 
+template <> inline constexpr const char * TypeName<Array> = "Array";
+template <> inline constexpr const char * TypeName<Tuple> = "Tuple";
+template <> inline constexpr const char * TypeName<Map> = "Map";
+template <> inline constexpr const char * TypeName<AggregateFunctionStateData> = "AggregateFunctionState";
 
-template <> struct TypeName<Array> { static std::string get() { return "Array"; } };
-template <> struct TypeName<Tuple> { static std::string get() { return "Tuple"; } };
-template <> struct TypeName<Map>   { static std::string get() { return "Map"; } };
-template <> struct TypeName<AggregateFunctionStateData> { static std::string get() { return "AggregateFunctionState"; } };
 
 template <typename T>
 decltype(auto) castToNearestFieldType(T && x)
@@ -965,7 +965,7 @@ struct fmt::formatter<DB::Field>
 
         /// Only support {}.
         if (it != end && *it != '}')
-            throw format_error("invalid format");
+            throw format_error("Invalid format");
 
         return it;
     }
diff --git a/src/Core/MySQL/MySQLGtid.cpp b/src/Core/MySQL/MySQLGtid.cpp
index 13dc6e0fd699..a441bccb0765 100644
--- a/src/Core/MySQL/MySQLGtid.cpp
+++ b/src/Core/MySQL/MySQLGtid.cpp
@@ -1,6 +1,7 @@
 #include "MySQLGtid.h"
-
 #include <boost/algorithm/string.hpp>
+#include <IO/ReadHelpers.h>
+
 
 namespace DB
 {
@@ -38,7 +39,7 @@ void GTIDSets::parse(const String gtid_format)
         boost::split(server_ids, gset, [](char c) { return c == ':'; });
 
         GTIDSet set;
-        set.uuid = stringToUUID(server_ids[0]);
+        set.uuid = DB::parse<UUID>(server_ids[0]);
 
         for (size_t k = 1; k < server_ids.size(); k++)
         {
@@ -174,8 +175,8 @@ String GTIDSets::toPayload() const
     for (const auto & set : sets)
     {
         // MySQL UUID is big-endian.
-        writeBinaryBigEndian(set.uuid.toUnderType().low, buffer);
-        writeBinaryBigEndian(set.uuid.toUnderType().high, buffer);
+        writeBinaryBigEndian(set.uuid.toUnderType().items[0], buffer);
+        writeBinaryBigEndian(set.uuid.toUnderType().items[1], buffer);
 
         UInt64 intervals_size = set.intervals.size();
         buffer.write(reinterpret_cast<const char *>(&intervals_size), 8);
diff --git a/src/Core/MySQL/MySQLReplication.cpp b/src/Core/MySQL/MySQLReplication.cpp
index 402b026736cc..e326d5e5b32f 100644
--- a/src/Core/MySQL/MySQLReplication.cpp
+++ b/src/Core/MySQL/MySQLReplication.cpp
@@ -658,12 +658,13 @@ namespace MySQLReplication
         payload.readStrict(reinterpret_cast<char *>(&commit_flag), 1);
 
         // MySQL UUID is big-endian.
-        UInt64 high = 0UL, low = 0UL;
+        UInt64 high = 0UL;
+        UInt64 low = 0UL;
         readBigEndianStrict(payload, reinterpret_cast<char *>(&low), 8);
-        gtid.uuid.toUnderType().low = low;
+        gtid.uuid.toUnderType().items[0] = low;
 
         readBigEndianStrict(payload, reinterpret_cast<char *>(&high), 8);
-        gtid.uuid.toUnderType().high = high;
+        gtid.uuid.toUnderType().items[1] = high;
 
         payload.readStrict(reinterpret_cast<char *>(&gtid.seq_no), 8);
 
diff --git a/src/Core/TypeListNumber.h b/src/Core/TypeListNumber.h
index 9b7c33a6007b..b65bdef4e468 100644
--- a/src/Core/TypeListNumber.h
+++ b/src/Core/TypeListNumber.h
@@ -1,20 +1,18 @@
 #pragma once
 
 #include <Core/Types.h>
-#include <Common/UInt128.h>
 #include <Common/TypeList.h>
 
 namespace DB
 {
 
 using TypeListNativeNumbers = TypeList<UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64>;
-using TypeListExtendedNumbers = TypeList<Int128, UInt256, Int256>;
+using TypeListExtendedNumbers = TypeList<UInt128, Int128, UInt256, Int256>;
 using TypeListDecimalNumbers = TypeList<Decimal32, Decimal64, Decimal128, Decimal256>;
 
 using TypeListGeneralNumbers = typename TypeListConcat<TypeListNativeNumbers, TypeListExtendedNumbers>::Type;
 using TypeListNumbers = typename TypeListConcat<TypeListGeneralNumbers, TypeListDecimalNumbers>::Type;
 
-/// Currently separate because UInt128 cannot be used in every context where other numbers can be used.
-using TypeListNumbersAndUInt128 = typename AppendToTypeList<UInt128, TypeListNumbers>::Type;
+using TypeListNumbersAndUUID = typename TypeListConcat<TypeListNumbers, TypeList<UUID>>::Type;
 
 }
diff --git a/src/Core/Types.h b/src/Core/Types.h
index b9ecda4a46da..151d9bdcf5a0 100644
--- a/src/Core/Types.h
+++ b/src/Core/Types.h
@@ -3,6 +3,7 @@
 #include <cstdint>
 #include <string>
 #include <vector>
+#include <common/strong_typedef.h>
 #include <common/extended_types.h>
 #include <common/defines.h>
 
@@ -63,60 +64,52 @@ enum class TypeIndex
 #pragma GCC diagnostic pop
 #endif
 
-/// Other int defines are in common/types.h
-using UInt256 = ::wUInt256;
+
+using UInt128 = ::UInt128;
+using UInt256 = ::UInt256;
 using Int128 = ::Int128;
-using Int256 = ::wInt256;
-
-/** Note that for types not used in DB, IsNumber is false.
-  */
-template <typename T> constexpr bool IsNumber = false;
-
-template <> inline constexpr bool IsNumber<UInt8> = true;
-template <> inline constexpr bool IsNumber<UInt16> = true;
-template <> inline constexpr bool IsNumber<UInt32> = true;
-template <> inline constexpr bool IsNumber<UInt64> = true;
-template <> inline constexpr bool IsNumber<UInt256> = true;
-template <> inline constexpr bool IsNumber<Int8> = true;
-template <> inline constexpr bool IsNumber<Int16> = true;
-template <> inline constexpr bool IsNumber<Int32> = true;
-template <> inline constexpr bool IsNumber<Int64> = true;
-template <> inline constexpr bool IsNumber<Int128> = true;
-template <> inline constexpr bool IsNumber<Int256> = true;
-template <> inline constexpr bool IsNumber<Float32> = true;
-template <> inline constexpr bool IsNumber<Float64> = true;
-
-template <typename T> struct TypeName;
-
-template <> struct TypeName<UInt8>   { static constexpr const char * get() { return "UInt8";   } };
-template <> struct TypeName<UInt16>  { static constexpr const char * get() { return "UInt16";  } };
-template <> struct TypeName<UInt32>  { static constexpr const char * get() { return "UInt32";  } };
-template <> struct TypeName<UInt64>  { static constexpr const char * get() { return "UInt64";  } };
-template <> struct TypeName<UInt256> { static constexpr const char * get() { return "UInt256"; } };
-template <> struct TypeName<Int8>    { static constexpr const char * get() { return "Int8";    } };
-template <> struct TypeName<Int16>   { static constexpr const char * get() { return "Int16";   } };
-template <> struct TypeName<Int32>   { static constexpr const char * get() { return "Int32";   } };
-template <> struct TypeName<Int64>   { static constexpr const char * get() { return "Int64";   } };
-template <> struct TypeName<Int128>  { static constexpr const char * get() { return "Int128";  } };
-template <> struct TypeName<Int256> { static constexpr const char * get() { return "Int256";  } };
-template <> struct TypeName<Float32> { static constexpr const char * get() { return "Float32"; } };
-template <> struct TypeName<Float64> { static constexpr const char * get() { return "Float64"; } };
-template <> struct TypeName<String>  { static constexpr const char * get() { return "String";  } };
-
-template <typename T> struct TypeId;
-template <> struct TypeId<UInt8>    { static constexpr const TypeIndex value = TypeIndex::UInt8;  };
-template <> struct TypeId<UInt16>   { static constexpr const TypeIndex value = TypeIndex::UInt16;  };
-template <> struct TypeId<UInt32>   { static constexpr const TypeIndex value = TypeIndex::UInt32;  };
-template <> struct TypeId<UInt64>   { static constexpr const TypeIndex value = TypeIndex::UInt64;  };
-template <> struct TypeId<UInt256>  { static constexpr const TypeIndex value = TypeIndex::UInt256; };
-template <> struct TypeId<Int8>     { static constexpr const TypeIndex value = TypeIndex::Int8;  };
-template <> struct TypeId<Int16>    { static constexpr const TypeIndex value = TypeIndex::Int16; };
-template <> struct TypeId<Int32>    { static constexpr const TypeIndex value = TypeIndex::Int32; };
-template <> struct TypeId<Int64>    { static constexpr const TypeIndex value = TypeIndex::Int64; };
-template <> struct TypeId<Int128>   { static constexpr const TypeIndex value = TypeIndex::Int128; };
-template <> struct TypeId<Int256>   { static constexpr const TypeIndex value = TypeIndex::Int256; };
-template <> struct TypeId<Float32>  { static constexpr const TypeIndex value = TypeIndex::Float32;  };
-template <> struct TypeId<Float64>  { static constexpr const TypeIndex value = TypeIndex::Float64;  };
+using Int256 = ::Int256;
+
+STRONG_TYPEDEF(UInt128, UUID)
+
+
+template <typename T> constexpr const char * TypeName = "";
+
+template <> inline constexpr const char * TypeName<UInt8> = "UInt8";
+template <> inline constexpr const char * TypeName<UInt16> = "UInt16";
+template <> inline constexpr const char * TypeName<UInt32> = "UInt32";
+template <> inline constexpr const char * TypeName<UInt64> = "UInt64";
+template <> inline constexpr const char * TypeName<UInt128> = "UInt128";
+template <> inline constexpr const char * TypeName<UInt256> = "UInt256";
+template <> inline constexpr const char * TypeName<Int8> = "Int8";
+template <> inline constexpr const char * TypeName<Int16> = "Int16";
+template <> inline constexpr const char * TypeName<Int32> = "Int32";
+template <> inline constexpr const char * TypeName<Int64> = "Int64";
+template <> inline constexpr const char * TypeName<Int128> = "Int128";
+template <> inline constexpr const char * TypeName<Int256> = "Int256";
+template <> inline constexpr const char * TypeName<Float32> = "Float32";
+template <> inline constexpr const char * TypeName<Float64> = "Float64";
+template <> inline constexpr const char * TypeName<String> = "String";
+template <> inline constexpr const char * TypeName<UUID> = "UUID";
+
+/// TODO Try to remove it.
+template <typename T> constexpr TypeIndex TypeId = TypeIndex::Nothing;
+template <> inline constexpr TypeIndex TypeId<UInt8> = TypeIndex::UInt8;
+template <> inline constexpr TypeIndex TypeId<UInt16> = TypeIndex::UInt16;
+template <> inline constexpr TypeIndex TypeId<UInt32> = TypeIndex::UInt32;
+template <> inline constexpr TypeIndex TypeId<UInt64> = TypeIndex::UInt64;
+template <> inline constexpr TypeIndex TypeId<UInt128> = TypeIndex::UInt128;
+template <> inline constexpr TypeIndex TypeId<UInt256> = TypeIndex::UInt256;
+template <> inline constexpr TypeIndex TypeId<Int8> = TypeIndex::Int8;
+template <> inline constexpr TypeIndex TypeId<Int16> = TypeIndex::Int16;
+template <> inline constexpr TypeIndex TypeId<Int32> = TypeIndex::Int32;
+template <> inline constexpr TypeIndex TypeId<Int64> = TypeIndex::Int64;
+template <> inline constexpr TypeIndex TypeId<Int128> = TypeIndex::Int128;
+template <> inline constexpr TypeIndex TypeId<Int256> = TypeIndex::Int256;
+template <> inline constexpr TypeIndex TypeId<Float32> = TypeIndex::Float32;
+template <> inline constexpr TypeIndex TypeId<Float64> = TypeIndex::Float64;
+template <> inline constexpr TypeIndex TypeId<UUID> = TypeIndex::UUID;
+
 
 /// Not a data type in database, defined just for convenience.
 using Strings = std::vector<String>;
@@ -167,6 +160,12 @@ struct Decimal
     const Decimal<T> & operator /= (const T & x) { value /= x; return *this; }
     const Decimal<T> & operator %= (const T & x) { value %= x; return *this; }
 
+    template <typename U> const Decimal<T> & operator += (const Decimal<U> & x) { value += x.value; return *this; }
+    template <typename U> const Decimal<T> & operator -= (const Decimal<U> & x) { value -= x.value; return *this; }
+    template <typename U> const Decimal<T> & operator *= (const Decimal<U> & x) { value *= x.value; return *this; }
+    template <typename U> const Decimal<T> & operator /= (const Decimal<U> & x) { value /= x.value; return *this; }
+    template <typename U> const Decimal<T> & operator %= (const Decimal<U> & x) { value %= x.value; return *this; }
+
     /// This is to avoid UB for sumWithOverflow()
     void NO_SANITIZE_UNDEFINED addOverflow(const T & x) { value += x; }
 
@@ -175,6 +174,8 @@ struct Decimal
 
 template <typename T> inline bool operator< (const Decimal<T> & x, const Decimal<T> & y) { return x.value < y.value; }
 template <typename T> inline bool operator> (const Decimal<T> & x, const Decimal<T> & y) { return x.value > y.value; }
+template <typename T> inline bool operator<= (const Decimal<T> & x, const Decimal<T> & y) { return x.value <= y.value; }
+template <typename T> inline bool operator>= (const Decimal<T> & x, const Decimal<T> & y) { return x.value >= y.value; }
 template <typename T> inline bool operator== (const Decimal<T> & x, const Decimal<T> & y) { return x.value == y.value; }
 template <typename T> inline bool operator!= (const Decimal<T> & x, const Decimal<T> & y) { return x.value != y.value; }
 
@@ -202,17 +203,17 @@ class DateTime64 : public Decimal64
     {}
 };
 
-template <> struct TypeName<Decimal32>   { static constexpr const char * get() { return "Decimal32";   } };
-template <> struct TypeName<Decimal64>   { static constexpr const char * get() { return "Decimal64";   } };
-template <> struct TypeName<Decimal128>  { static constexpr const char * get() { return "Decimal128";  } };
-template <> struct TypeName<Decimal256>  { static constexpr const char * get() { return "Decimal256";  } };
-template <> struct TypeName<DateTime64>  { static constexpr const char * get() { return "DateTime64";  } };
+template <> inline constexpr const char * TypeName<Decimal32> = "Decimal32";
+template <> inline constexpr const char * TypeName<Decimal64> = "Decimal64";
+template <> inline constexpr const char * TypeName<Decimal128> = "Decimal128";
+template <> inline constexpr const char * TypeName<Decimal256> = "Decimal256";
+template <> inline constexpr const char * TypeName<DateTime64> = "DateTime64";
 
-template <> struct TypeId<Decimal32>    { static constexpr const TypeIndex value = TypeIndex::Decimal32; };
-template <> struct TypeId<Decimal64>    { static constexpr const TypeIndex value = TypeIndex::Decimal64; };
-template <> struct TypeId<Decimal128>   { static constexpr const TypeIndex value = TypeIndex::Decimal128; };
-template <> struct TypeId<Decimal256>   { static constexpr const TypeIndex value = TypeIndex::Decimal256; };
-template <> struct TypeId<DateTime64>   { static constexpr const TypeIndex value = TypeIndex::DateTime64; };
+template <> inline constexpr TypeIndex TypeId<Decimal32> = TypeIndex::Decimal32;
+template <> inline constexpr TypeIndex TypeId<Decimal64> = TypeIndex::Decimal64;
+template <> inline constexpr TypeIndex TypeId<Decimal128> = TypeIndex::Decimal128;
+template <> inline constexpr TypeIndex TypeId<Decimal256> = TypeIndex::Decimal256;
+template <> inline constexpr TypeIndex TypeId<DateTime64> = TypeIndex::DateTime64;
 
 template <typename T> constexpr bool IsDecimalNumber = false;
 template <> inline constexpr bool IsDecimalNumber<Decimal32> = true;
@@ -229,8 +230,11 @@ template <> struct NativeType<Decimal256> { using Type = Int256; };
 template <> struct NativeType<DateTime64> { using Type = Int64; };
 
 template <typename T> constexpr bool OverBigInt = false;
+template <> inline constexpr bool OverBigInt<Int128> = true;
+template <> inline constexpr bool OverBigInt<UInt128> = true;
 template <> inline constexpr bool OverBigInt<Int256> = true;
 template <> inline constexpr bool OverBigInt<UInt256> = true;
+template <> inline constexpr bool OverBigInt<Decimal128> = true;
 template <> inline constexpr bool OverBigInt<Decimal256> = true;
 
 inline constexpr const char * getTypeName(TypeIndex idx)
@@ -238,31 +242,31 @@ inline constexpr const char * getTypeName(TypeIndex idx)
     switch (idx)
     {
         case TypeIndex::Nothing:    return "Nothing";
-        case TypeIndex::UInt8:      return TypeName<UInt8>::get();
-        case TypeIndex::UInt16:     return TypeName<UInt16>::get();
-        case TypeIndex::UInt32:     return TypeName<UInt32>::get();
-        case TypeIndex::UInt64:     return TypeName<UInt64>::get();
+        case TypeIndex::UInt8:      return "UInt8";
+        case TypeIndex::UInt16:     return "UInt16";
+        case TypeIndex::UInt32:     return "UInt32";
+        case TypeIndex::UInt64:     return "UInt64";
         case TypeIndex::UInt128:    return "UInt128";
-        case TypeIndex::UInt256:    return TypeName<UInt256>::get();
-        case TypeIndex::Int8:       return TypeName<Int8>::get();
-        case TypeIndex::Int16:      return TypeName<Int16>::get();
-        case TypeIndex::Int32:      return TypeName<Int32>::get();
-        case TypeIndex::Int64:      return TypeName<Int64>::get();
-        case TypeIndex::Int128:     return TypeName<Int128>::get();
-        case TypeIndex::Int256:     return TypeName<Int256>::get();
-        case TypeIndex::Float32:    return TypeName<Float32>::get();
-        case TypeIndex::Float64:    return TypeName<Float64>::get();
+        case TypeIndex::UInt256:    return "UInt256";
+        case TypeIndex::Int8:       return "Int8";
+        case TypeIndex::Int16:      return "Int16";
+        case TypeIndex::Int32:      return "Int32";
+        case TypeIndex::Int64:      return "Int64";
+        case TypeIndex::Int128:     return "Int128";
+        case TypeIndex::Int256:     return "Int256";
+        case TypeIndex::Float32:    return "Float32";
+        case TypeIndex::Float64:    return "Float64";
         case TypeIndex::Date:       return "Date";
         case TypeIndex::DateTime:   return "DateTime";
         case TypeIndex::DateTime64: return "DateTime64";
-        case TypeIndex::String:     return TypeName<String>::get();
+        case TypeIndex::String:     return "String";
         case TypeIndex::FixedString: return "FixedString";
         case TypeIndex::Enum8:      return "Enum8";
         case TypeIndex::Enum16:     return "Enum16";
-        case TypeIndex::Decimal32:  return TypeName<Decimal32>::get();
-        case TypeIndex::Decimal64:  return TypeName<Decimal64>::get();
-        case TypeIndex::Decimal128: return TypeName<Decimal128>::get();
-        case TypeIndex::Decimal256: return TypeName<Decimal256>::get();
+        case TypeIndex::Decimal32:  return "Decimal32";
+        case TypeIndex::Decimal64:  return "Decimal64";
+        case TypeIndex::Decimal128: return "Decimal128";
+        case TypeIndex::Decimal256: return "Decimal256";
         case TypeIndex::UUID:       return "UUID";
         case TypeIndex::Array:      return "Array";
         case TypeIndex::Tuple:      return "Tuple";
diff --git a/src/Core/UUID.cpp b/src/Core/UUID.cpp
new file mode 100644
index 000000000000..ef1e10f50636
--- /dev/null
+++ b/src/Core/UUID.cpp
@@ -0,0 +1,19 @@
+#include <Core/UUID.h>
+#include <Common/thread_local_rng.h>
+
+
+namespace DB
+{
+
+namespace UUIDHelpers
+{
+    UUID generateV4()
+    {
+        UInt128 res{thread_local_rng(), thread_local_rng()};
+        res.items[0] = (res.items[0] & 0xffffffffffff0fffull) | 0x0000000000004000ull;
+        res.items[1] = (res.items[1] & 0x3fffffffffffffffull) | 0x8000000000000000ull;
+        return UUID{res};
+    }
+}
+
+}
diff --git a/src/Core/UUID.h b/src/Core/UUID.h
index d5a6232a72b2..a24dcebdc9e1 100644
--- a/src/Core/UUID.h
+++ b/src/Core/UUID.h
@@ -1,25 +1,17 @@
 #pragma once
 
-#include <Common/UInt128.h>
-#include <common/strong_typedef.h>
-#include <Common/thread_local_rng.h>
+#include <Core/Types.h>
+
 
 namespace DB
 {
 
-STRONG_TYPEDEF(UInt128, UUID)
-
 namespace UUIDHelpers
 {
-    inline UUID generateV4()
-    {
-        UInt128 res{thread_local_rng(), thread_local_rng()};
-        res.low = (res.low & 0xffffffffffff0fffull) | 0x0000000000004000ull;
-        res.high = (res.high & 0x3fffffffffffffffull) | 0x8000000000000000ull;
-        return UUID{res};
-    }
+    /// Generate random UUID.
+    UUID generateV4();
 
-    const UUID Nil = UUID(UInt128(0, 0));
+    const UUID Nil{};
 }
 
 }
diff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h
index 2d6134ab9fc8..520be263f9ff 100644
--- a/src/Core/callOnTypeIndex.h
+++ b/src/Core/callOnTypeIndex.h
@@ -26,6 +26,7 @@ bool callOnBasicType(TypeIndex number, F && f)
             case TypeIndex::UInt16:       return f(TypePair<T, UInt16>());
             case TypeIndex::UInt32:       return f(TypePair<T, UInt32>());
             case TypeIndex::UInt64:       return f(TypePair<T, UInt64>());
+            case TypeIndex::UInt128:      return f(TypePair<T, UInt128>());
             case TypeIndex::UInt256:      return f(TypePair<T, UInt256>());
 
             case TypeIndex::Int8:         return f(TypePair<T, Int8>());
@@ -94,6 +95,7 @@ inline bool callOnBasicTypes(TypeIndex type_num1, TypeIndex type_num2, F && f)
             case TypeIndex::UInt16: return callOnBasicType<UInt16, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));
             case TypeIndex::UInt32: return callOnBasicType<UInt32, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));
             case TypeIndex::UInt64: return callOnBasicType<UInt64, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));
+            case TypeIndex::UInt128: return callOnBasicType<UInt128, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));
             case TypeIndex::UInt256: return callOnBasicType<UInt256, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));
 
             case TypeIndex::Int8: return callOnBasicType<Int8, _int, _float, _decimal, _datetime>(type_num2, std::forward<F>(f));
@@ -171,6 +173,7 @@ bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... args)
         case TypeIndex::UInt16:         return f(TypePair<DataTypeNumber<UInt16>, T>(), std::forward<ExtraArgs>(args)...);
         case TypeIndex::UInt32:         return f(TypePair<DataTypeNumber<UInt32>, T>(), std::forward<ExtraArgs>(args)...);
         case TypeIndex::UInt64:         return f(TypePair<DataTypeNumber<UInt64>, T>(), std::forward<ExtraArgs>(args)...);
+        case TypeIndex::UInt128:        return f(TypePair<DataTypeNumber<UInt128>, T>(), std::forward<ExtraArgs>(args)...);
         case TypeIndex::UInt256:        return f(TypePair<DataTypeNumber<UInt256>, T>(), std::forward<ExtraArgs>(args)...);
 
         case TypeIndex::Int8:           return f(TypePair<DataTypeNumber<Int8>, T>(), std::forward<ExtraArgs>(args)...);
diff --git a/src/DataStreams/MongoDBBlockInputStream.cpp b/src/DataStreams/MongoDBBlockInputStream.cpp
index e4ddcd09ede4..d740448e0cfd 100644
--- a/src/DataStreams/MongoDBBlockInputStream.cpp
+++ b/src/DataStreams/MongoDBBlockInputStream.cpp
@@ -25,7 +25,6 @@
 // Poco/MongoDB/BSONWriter.h:54: void writeCString(const std::string & value);
 // src/IO/WriteHelpers.h:146 #define writeCString(s, buf)
 #include <IO/WriteHelpers.h>
-#include <Common/FieldVisitors.h>
 #include <ext/enumerate.h>
 
 namespace DB
@@ -290,7 +289,7 @@ namespace
                 if (value.type() == Poco::MongoDB::ElementTraits<String>::TypeId)
                 {
                     String string = static_cast<const Poco::MongoDB::ConcreteElement<String> &>(value).value();
-                    assert_cast<ColumnUInt128 &>(column).getData().push_back(parse<UUID>(string));
+                    assert_cast<ColumnUUID &>(column).getData().push_back(parse<UUID>(string));
                 }
                 else
                     throw Exception{"Type mismatch, expected String (UUID), got type id = " + toString(value.type()) + " for column "
diff --git a/src/DataStreams/PostgreSQLBlockInputStream.cpp b/src/DataStreams/PostgreSQLBlockInputStream.cpp
index 8897cd13a2e1..63a8e9edb79c 100644
--- a/src/DataStreams/PostgreSQLBlockInputStream.cpp
+++ b/src/DataStreams/PostgreSQLBlockInputStream.cpp
@@ -161,7 +161,7 @@ void PostgreSQLBlockInputStream::insertValue(IColumn & column, std::string_view
             assert_cast<ColumnString &>(column).insertData(value.data(), value.size());
             break;
         case ValueType::vtUUID:
-            assert_cast<ColumnUInt128 &>(column).insert(parse<UUID>(value.data(), value.size()));
+            assert_cast<ColumnUUID &>(column).insert(parse<UUID>(value.data(), value.size()));
             break;
         case ValueType::vtDate:
             assert_cast<ColumnUInt16 &>(column).insertValue(UInt16{LocalDate{std::string(value)}.getDayNum()});
diff --git a/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h b/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h
index 44b007ab07fe..dc054144e144 100644
--- a/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h
+++ b/src/DataTypes/DataTypeCustomSimpleAggregateFunction.h
@@ -2,7 +2,6 @@
 
 #include <DataTypes/DataTypeCustom.h>
 #include <AggregateFunctions/IAggregateFunction.h>
-#include <Common/FieldVisitors.h>
 
 #include <IO/ReadHelpers.h>
 
diff --git a/src/DataTypes/DataTypeDecimalBase.h b/src/DataTypes/DataTypeDecimalBase.h
index 9e44310a0fff..aea837f890f6 100644
--- a/src/DataTypes/DataTypeDecimalBase.h
+++ b/src/DataTypes/DataTypeDecimalBase.h
@@ -76,7 +76,7 @@ class DataTypeDecimalBase : public IDataType
             throw Exception("Scale " + std::to_string(scale) + " is out of bounds", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
     }
 
-    TypeIndex getTypeId() const override { return TypeId<T>::value; }
+    TypeIndex getTypeId() const override { return TypeId<T>; }
 
     Field getDefault() const override;
     MutableColumnPtr createColumn() const override;
@@ -113,15 +113,15 @@ class DataTypeDecimalBase : public IDataType
 
     T maxWholeValue() const { return getScaleMultiplier(precision - scale) - T(1); }
 
-    template<typename U>
+    template <typename U>
     bool canStoreWhole(U x) const
     {
-        static_assert(std::is_signed_v<typename T::NativeType>);
+        static_assert(is_signed_v<typename T::NativeType>);
         T max = maxWholeValue();
-        if constexpr (std::is_signed_v<U>)
-            return -max <= x && x <= max;
+        if constexpr (is_signed_v<U>)
+            return -max.value <= x && x <= max.value;
         else
-            return x <= static_cast<std::make_unsigned_t<typename T::NativeType>>(max.value);
+            return x <= static_cast<make_unsigned_t<typename T::NativeType>>(max.value);
     }
 
     /// @returns multiplier for U to become T with correct scale
diff --git a/src/DataTypes/DataTypeLowCardinality.cpp b/src/DataTypes/DataTypeLowCardinality.cpp
index 485083d67ee3..95a5addf62a5 100644
--- a/src/DataTypes/DataTypeLowCardinality.cpp
+++ b/src/DataTypes/DataTypeLowCardinality.cpp
@@ -79,6 +79,8 @@ MutableColumnUniquePtr DataTypeLowCardinality::createColumnUniqueImpl(const IDat
         return creator(static_cast<ColumnVector<UInt16> *>(nullptr));
     else if (which.isDateTime())
         return creator(static_cast<ColumnVector<UInt32> *>(nullptr));
+    else if (which.isUUID())
+        return creator(static_cast<ColumnVector<UUID> *>(nullptr));
     else if (which.isInt() || which.isUInt() || which.isFloat())
     {
         MutableColumnUniquePtr column;
diff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp
index 1d5807613625..b09a5e9e590f 100644
--- a/src/DataTypes/DataTypeMap.cpp
+++ b/src/DataTypes/DataTypeMap.cpp
@@ -55,9 +55,12 @@ DataTypeMap::DataTypeMap(const DataTypePtr & key_type_, const DataTypePtr & valu
 
 void DataTypeMap::assertKeyType() const
 {
-    if (!key_type->isValueRepresentedByInteger() && !isStringOrFixedString(*key_type) && !WhichDataType(key_type).isNothing())
+    if (!key_type->isValueRepresentedByInteger()
+        && !isStringOrFixedString(*key_type)
+        && !WhichDataType(key_type).isNothing()
+        && !WhichDataType(key_type).isUUID())
         throw Exception(ErrorCodes::BAD_ARGUMENTS,
-            "Type of Map key must be a type, that can be represented by integer or string,"
+            "Type of Map key must be a type, that can be represented by integer or string or UUID,"
             " but {} given", key_type->getName());
 }
 
diff --git a/src/DataTypes/DataTypeNumberBase.cpp b/src/DataTypes/DataTypeNumberBase.cpp
index a9df7db73349..12d1989a9d67 100644
--- a/src/DataTypes/DataTypeNumberBase.cpp
+++ b/src/DataTypes/DataTypeNumberBase.cpp
@@ -43,7 +43,7 @@ template class DataTypeNumberBase<UInt8>;
 template class DataTypeNumberBase<UInt16>;
 template class DataTypeNumberBase<UInt32>;
 template class DataTypeNumberBase<UInt64>;
-template class DataTypeNumberBase<UInt128>; // base for UUID
+template class DataTypeNumberBase<UInt128>;
 template class DataTypeNumberBase<UInt256>;
 template class DataTypeNumberBase<Int8>;
 template class DataTypeNumberBase<Int16>;
diff --git a/src/DataTypes/DataTypeNumberBase.h b/src/DataTypes/DataTypeNumberBase.h
index 97c3563b032c..c24778691d9a 100644
--- a/src/DataTypes/DataTypeNumberBase.h
+++ b/src/DataTypes/DataTypeNumberBase.h
@@ -1,6 +1,5 @@
 #pragma once
 
-#include <Common/UInt128.h>
 #include <DataTypes/IDataType.h>
 #include <DataTypes/Serializations/SerializationNumber.h>
 
@@ -16,19 +15,17 @@ class ColumnVector;
 template <typename T>
 class DataTypeNumberBase : public IDataType
 {
-    static_assert(IsNumber<T>);
+    static_assert(is_arithmetic_v<T>);
 
 public:
     static constexpr bool is_parametric = false;
+    static constexpr auto family_name = TypeName<T>;
 
     using FieldType = T;
-    static constexpr auto type_id = TypeId<T>::value;
-    static constexpr auto family_name = TypeName<T>::get();
-
     using ColumnType = ColumnVector<T>;
 
-    const char * getFamilyName() const override { return family_name; }
-    TypeIndex getTypeId() const override { return type_id; }
+    const char * getFamilyName() const override { return TypeName<T>; }
+    TypeIndex getTypeId() const override { return TypeId<T>; }
 
     Field getDefault() const override;
 
@@ -63,7 +60,7 @@ extern template class DataTypeNumberBase<UInt8>;
 extern template class DataTypeNumberBase<UInt16>;
 extern template class DataTypeNumberBase<UInt32>;
 extern template class DataTypeNumberBase<UInt64>;
-extern template class DataTypeNumberBase<UInt128>; // base for UUID
+extern template class DataTypeNumberBase<UInt128>;
 extern template class DataTypeNumberBase<UInt256>;
 extern template class DataTypeNumberBase<Int16>;
 extern template class DataTypeNumberBase<Int8>;
diff --git a/src/DataTypes/DataTypeUUID.cpp b/src/DataTypes/DataTypeUUID.cpp
index 387ccc56a712..44182a700b44 100644
--- a/src/DataTypes/DataTypeUUID.cpp
+++ b/src/DataTypes/DataTypeUUID.cpp
@@ -16,6 +16,16 @@ SerializationPtr DataTypeUUID::doGetDefaultSerialization() const
     return std::make_shared<SerializationUUID>();
 }
 
+Field DataTypeUUID::getDefault() const
+{
+    return UUID{};
+}
+
+MutableColumnPtr DataTypeUUID::createColumn() const
+{
+    return ColumnVector<UUID>::create();
+}
+
 void registerDataTypeUUID(DataTypeFactory & factory)
 {
     factory.registerSimpleDataType("UUID", [] { return DataTypePtr(std::make_shared<DataTypeUUID>()); });
diff --git a/src/DataTypes/DataTypeUUID.h b/src/DataTypes/DataTypeUUID.h
index 1546ca385a44..70104a034786 100644
--- a/src/DataTypes/DataTypeUUID.h
+++ b/src/DataTypes/DataTypeUUID.h
@@ -1,26 +1,44 @@
 #pragma once
 
-#include <Common/UInt128.h>
-#include <DataTypes/DataTypeNumberBase.h>
 #include <DataTypes/IDataType.h>
+#include <Columns/ColumnVector.h>
+#include <Core/UUID.h>
+
 
 namespace DB
 {
 
-class DataTypeUUID final : public DataTypeNumberBase<UInt128>
+class DataTypeUUID : public IDataType
 {
-
 public:
+    static constexpr bool is_parametric = false;
+
+    using FieldType = UUID;
+    using ColumnType = ColumnVector<UUID>;
+
     const char * getFamilyName() const override { return "UUID"; }
     TypeIndex getTypeId() const override { return TypeIndex::UUID; }
 
+    Field getDefault() const override;
+
+    MutableColumnPtr createColumn() const override;
+
+    bool isParametric() const override { return false; }
+    bool haveSubtypes() const override { return false; }
+
     bool equals(const IDataType & rhs) const override;
 
     bool canBeUsedInBitOperations() const override { return true; }
     bool canBeInsideNullable() const override { return true; }
-    bool canBeInsideLowCardinality() const override { return false; }
-
     bool canBePromoted() const override { return false; }
+    bool shouldAlignRightInPrettyFormats() const override { return false; }
+    bool textCanContainOnlyValidUTF8() const override { return true; }
+    bool isComparable() const override { return true; }
+    bool isValueUnambiguouslyRepresentedInContiguousMemoryRegion() const override { return true; }
+    bool haveMaximumSizeOfValue() const override { return true; }
+    size_t getSizeOfValueInMemory() const override { return sizeof(UUID); }
+    bool isCategorial() const override { return true; }
+    bool canBeInsideLowCardinality() const override { return true; }
 
     SerializationPtr doGetDefaultSerialization() const override;
 };
diff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h
index 5aeac78b2efa..f08bdb80d41f 100644
--- a/src/DataTypes/DataTypesDecimal.h
+++ b/src/DataTypes/DataTypesDecimal.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <common/arithmeticOverflow.h>
+#include <common/extended_types.h>
 #include <Common/typeid_cast.h>
 #include <DataTypes/IDataType.h>
 #include <DataTypes/DataTypeDecimalBase.h>
@@ -38,7 +39,7 @@ class DataTypeDecimal final : public DataTypeDecimalBase<T>
 
     const char * getFamilyName() const override { return family_name; }
     std::string doGetName() const override;
-    TypeIndex getTypeId() const override { return TypeId<T>::value; }
+    TypeIndex getTypeId() const override { return TypeId<T>; }
     bool canBePromoted() const override { return true; }
     DataTypePtr promoteNumericType() const override;
 
@@ -150,7 +151,7 @@ tryConvertDecimals(const typename FromDataType::FieldType & value, UInt32 scale_
 }
 
 template <typename FromDataType, typename ToDataType, typename ReturnType>
-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, ReturnType>
+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && is_arithmetic_v<typename ToDataType::FieldType>, ReturnType>
 convertFromDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)
 {
     using FromFieldType = typename FromDataType::FieldType;
@@ -160,7 +161,7 @@ convertFromDecimalImpl(const typename FromDataType::FieldType & value, UInt32 sc
 }
 
 template <typename FromDataType, typename ToDataType>
-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, typename ToDataType::FieldType>
+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && is_arithmetic_v<typename ToDataType::FieldType>, typename ToDataType::FieldType>
 convertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale)
 {
     typename ToDataType::FieldType result;
@@ -171,14 +172,14 @@ convertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale)
 }
 
 template <typename FromDataType, typename ToDataType>
-inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && IsNumber<typename ToDataType::FieldType>, bool>
+inline std::enable_if_t<IsDataTypeDecimal<FromDataType> && is_arithmetic_v<typename ToDataType::FieldType>, bool>
 tryConvertFromDecimal(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)
 {
     return convertFromDecimalImpl<FromDataType, ToDataType, bool>(value, scale, result);
 }
 
 template <typename FromDataType, typename ToDataType, typename ReturnType>
-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, ReturnType>
+inline std::enable_if_t<is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, ReturnType>
 convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)
 {
     using FromFieldType = typename FromDataType::FieldType;
@@ -199,35 +200,18 @@ convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scal
         }
 
         auto out = value * static_cast<FromFieldType>(DecimalUtils::scaleMultiplier<ToNativeType>(scale));
-        if constexpr (std::is_same_v<ToNativeType, Int128>)
-        {
-            static constexpr Int128 min_int128 = minInt128();
-            static constexpr Int128 max_int128 = maxInt128();
-
-            if (out <= static_cast<ToNativeType>(min_int128) || out >= static_cast<ToNativeType>(max_int128))
-            {
-                if constexpr (throw_exception)
-                    throw Exception(std::string(ToDataType::family_name) + " convert overflow. Float is out of Decimal range",
-                                    ErrorCodes::DECIMAL_OVERFLOW);
-                else
-                    return ReturnType(false);
-            }
-        }
-        else
+
+        if (out <= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::min()) ||
+            out >= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::max()))
         {
-            if (out <= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::min()) ||
-                out >= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::max()))
-            {
-                if constexpr (throw_exception)
-                    throw Exception(std::string(ToDataType::family_name) + " convert overflow. Float is out of Decimal range",
-                                    ErrorCodes::DECIMAL_OVERFLOW);
-                else
-                    return ReturnType(false);
-            }
+            if constexpr (throw_exception)
+                throw Exception(std::string(ToDataType::family_name) + " convert overflow. Float is out of Decimal range",
+                                ErrorCodes::DECIMAL_OVERFLOW);
+            else
+                return ReturnType(false);
         }
 
         result = static_cast<ToNativeType>(out);
-
         return ReturnType(true);
     }
     else
@@ -235,25 +219,23 @@ convertToDecimalImpl(const typename FromDataType::FieldType & value, UInt32 scal
         if constexpr (is_big_int_v<FromFieldType>)
             return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal256>, ToDataType, ReturnType>(static_cast<Int256>(value), 0, scale, result));
         else if constexpr (std::is_same_v<FromFieldType, UInt64>)
-            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal128>, ToDataType, ReturnType>(value, 0, scale, result));
+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal128>, ToDataType, ReturnType>(static_cast<Int128>(value), 0, scale, result));
         else
-            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal64>, ToDataType, ReturnType>(value, 0, scale, result));
+            return ReturnType(convertDecimalsImpl<DataTypeDecimal<Decimal64>, ToDataType, ReturnType>(static_cast<Int64>(value), 0, scale, result));
     }
 }
 
 template <typename FromDataType, typename ToDataType>
-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>
+inline std::enable_if_t<is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, typename ToDataType::FieldType>
 convertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale)
 {
     typename ToDataType::FieldType result;
-
     convertToDecimalImpl<FromDataType, ToDataType, void>(value, scale, result);
-
     return result;
 }
 
 template <typename FromDataType, typename ToDataType>
-inline std::enable_if_t<IsNumber<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, bool>
+inline std::enable_if_t<is_arithmetic_v<typename FromDataType::FieldType> && IsDataTypeDecimal<ToDataType>, bool>
 tryConvertToDecimal(const typename FromDataType::FieldType & value, UInt32 scale, typename ToDataType::FieldType& result)
 {
     return convertToDecimalImpl<FromDataType, ToDataType, bool>(value, scale, result);
diff --git a/src/DataTypes/DataTypesNumber.cpp b/src/DataTypes/DataTypesNumber.cpp
index 5cfffa878f23..6a1aed888c9e 100644
--- a/src/DataTypes/DataTypesNumber.cpp
+++ b/src/DataTypes/DataTypesNumber.cpp
@@ -21,12 +21,12 @@ static DataTypePtr createNumericDataType(const ASTPtr & arguments)
         if (std::is_integral_v<T>)
         {
             if (arguments->children.size() > 1)
-                throw Exception(String(TypeName<T>::get()) + " data type family must not have more than one argument - display width", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "{} data type family must not have more than one argument - display width", TypeName<T>);
         }
         else
         {
             if (arguments->children.size() > 2)
-                throw Exception(String(TypeName<T>::get()) + " data type family must not have more than two arguments - total number of digits and number of digits following the decimal point", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "{} data type family must not have more than two arguments - total number of digits and number of digits following the decimal point", TypeName<T>);
         }
     }
     return std::make_shared<DataTypeNumber<T>>();
@@ -44,10 +44,13 @@ void registerDataTypeNumbers(DataTypeFactory & factory)
     factory.registerDataType("Int16", createNumericDataType<Int16>);
     factory.registerDataType("Int32", createNumericDataType<Int32>);
     factory.registerDataType("Int64", createNumericDataType<Int64>);
+
     factory.registerDataType("Float32", createNumericDataType<Float32>);
     factory.registerDataType("Float64", createNumericDataType<Float64>);
 
+    factory.registerSimpleDataType("UInt128", [] { return DataTypePtr(std::make_shared<DataTypeUInt128>()); });
     factory.registerSimpleDataType("UInt256", [] { return DataTypePtr(std::make_shared<DataTypeUInt256>()); });
+
     factory.registerSimpleDataType("Int128", [] { return DataTypePtr(std::make_shared<DataTypeInt128>()); });
     factory.registerSimpleDataType("Int256", [] { return DataTypePtr(std::make_shared<DataTypeInt256>()); });
 
diff --git a/src/DataTypes/DataTypesNumber.h b/src/DataTypes/DataTypesNumber.h
index 792727564650..9f026e061277 100644
--- a/src/DataTypes/DataTypesNumber.h
+++ b/src/DataTypes/DataTypesNumber.h
@@ -44,6 +44,7 @@ using DataTypeInt64 = DataTypeNumber<Int64>;
 using DataTypeFloat32 = DataTypeNumber<Float32>;
 using DataTypeFloat64 = DataTypeNumber<Float64>;
 
+using DataTypeUInt128 = DataTypeNumber<UInt128>;
 using DataTypeInt128 = DataTypeNumber<Int128>;
 using DataTypeUInt256 = DataTypeNumber<UInt256>;
 using DataTypeInt256 = DataTypeNumber<Int256>;
diff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp
index 95f033851212..a8d439612f50 100644
--- a/src/DataTypes/FieldToDataType.cpp
+++ b/src/DataTypes/FieldToDataType.cpp
@@ -1,4 +1,3 @@
-#include <Common/FieldVisitors.h>
 #include <DataTypes/FieldToDataType.h>
 #include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/DataTypeMap.h>
@@ -8,6 +7,7 @@
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <DataTypes/DataTypeNothing.h>
+#include <DataTypes/DataTypeUUID.h>
 #include <DataTypes/getLeastSupertype.h>
 #include <DataTypes/DataTypeFactory.h>
 #include <Common/Exception.h>
@@ -20,7 +20,6 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int EMPTY_DATA_PASSED;
-    extern const int NOT_IMPLEMENTED;
 }
 
 
@@ -37,11 +36,6 @@ DataTypePtr FieldToDataType::operator() (const UInt64 & x) const
     return std::make_shared<DataTypeUInt64>();
 }
 
-DataTypePtr FieldToDataType::operator() (const UInt128 &) const
-{
-    throw Exception("There are no UInt128 literals in SQL", ErrorCodes::NOT_IMPLEMENTED);
-}
-
 DataTypePtr FieldToDataType::operator() (const Int64 & x) const
 {
     if (x <= std::numeric_limits<Int8>::max() && x >= std::numeric_limits<Int8>::min()) return std::make_shared<DataTypeInt8>();
@@ -50,18 +44,34 @@ DataTypePtr FieldToDataType::operator() (const Int64 & x) const
     return std::make_shared<DataTypeInt64>();
 }
 
-DataTypePtr FieldToDataType::operator() (const Int128 & x) const
+DataTypePtr FieldToDataType::operator() (const Float64 &) const
+{
+    return std::make_shared<DataTypeFloat64>();
+}
+
+DataTypePtr FieldToDataType::operator() (const UInt128 &) const
+{
+    return std::make_shared<DataTypeUInt128>();
+}
+
+DataTypePtr FieldToDataType::operator() (const Int128 &) const
 {
-    if (x <= std::numeric_limits<Int8>::max() && x >= std::numeric_limits<Int8>::min()) return std::make_shared<DataTypeInt8>();
-    if (x <= std::numeric_limits<Int16>::max() && x >= std::numeric_limits<Int16>::min()) return std::make_shared<DataTypeInt16>();
-    if (x <= std::numeric_limits<Int32>::max() && x >= std::numeric_limits<Int32>::min()) return std::make_shared<DataTypeInt32>();
-    if (x <= std::numeric_limits<Int64>::max() && x >= std::numeric_limits<Int64>::min()) return std::make_shared<DataTypeInt64>();
     return std::make_shared<DataTypeInt128>();
 }
 
-DataTypePtr FieldToDataType::operator() (const Float64 &) const
+DataTypePtr FieldToDataType::operator() (const UInt256 &) const
 {
-    return std::make_shared<DataTypeFloat64>();
+    return std::make_shared<DataTypeUInt256>();
+}
+
+DataTypePtr FieldToDataType::operator() (const Int256 &) const
+{
+    return std::make_shared<DataTypeInt256>();
+}
+
+DataTypePtr FieldToDataType::operator() (const UUID &) const
+{
+    return std::make_shared<DataTypeUUID>();
 }
 
 DataTypePtr FieldToDataType::operator() (const String &) const
@@ -143,14 +153,4 @@ DataTypePtr FieldToDataType::operator() (const AggregateFunctionStateData & x) c
     return DataTypeFactory::instance().get(name);
 }
 
-DataTypePtr FieldToDataType::operator() (const UInt256 &) const
-{
-    throw Exception("There are no UInt256 literals in SQL", ErrorCodes::NOT_IMPLEMENTED);
-}
-
-DataTypePtr FieldToDataType::operator() (const Int256 &) const
-{
-    throw Exception("There are no Int256 literals in SQL", ErrorCodes::NOT_IMPLEMENTED);
-}
-
 }
diff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h
index 39457564a2f2..ca83ce868fc6 100644
--- a/src/DataTypes/FieldToDataType.h
+++ b/src/DataTypes/FieldToDataType.h
@@ -1,5 +1,8 @@
 #pragma once
 
+#include <memory>
+#include <Core/Types.h>
+#include <Core/Field.h>
 #include <Common/FieldVisitors.h>
 
 
@@ -20,8 +23,11 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>
     DataTypePtr operator() (const Null & x) const;
     DataTypePtr operator() (const UInt64 & x) const;
     DataTypePtr operator() (const UInt128 & x) const;
+    DataTypePtr operator() (const UInt256 & x) const;
     DataTypePtr operator() (const Int64 & x) const;
     DataTypePtr operator() (const Int128 & x) const;
+    DataTypePtr operator() (const Int256 & x) const;
+    DataTypePtr operator() (const UUID & x) const;
     DataTypePtr operator() (const Float64 & x) const;
     DataTypePtr operator() (const String & x) const;
     DataTypePtr operator() (const Array & x) const;
@@ -32,8 +38,6 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>
     DataTypePtr operator() (const DecimalField<Decimal128> & x) const;
     DataTypePtr operator() (const DecimalField<Decimal256> & x) const;
     DataTypePtr operator() (const AggregateFunctionStateData & x) const;
-    DataTypePtr operator() (const UInt256 & x) const;
-    DataTypePtr operator() (const Int256 & x) const;
 };
 
 }
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 5a676819b77b..4602083f4887 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -342,7 +342,7 @@ struct WhichDataType
     constexpr bool isFunction() const { return idx == TypeIndex::Function; }
     constexpr bool isAggregateFunction() const { return idx == TypeIndex::AggregateFunction; }
 
-    constexpr bool IsBigIntOrDeimal() const { return isInt128() || isInt256() || isUInt256() || isDecimal256(); }
+    constexpr bool IsBigIntOrDeimal() const { return isInt128() || isUInt128() || isInt256() || isUInt256() || isDecimal256(); }
 };
 
 /// IDataType helpers (alternative for IDataType virtual methods with single point of truth)
@@ -430,7 +430,7 @@ template <typename T, typename DataType>
 inline bool isColumnedAsDecimalT(const DataType & data_type)
 {
     const WhichDataType which(data_type);
-    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>::value;
+    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>;
 }
 
 template <typename T>
@@ -469,19 +469,6 @@ inline bool isCompilableType(const DataTypePtr & data_type)
     return data_type->isValueRepresentedByNumber() && !isDecimal(data_type);
 }
 
-template <TypeIndex TYPE_IDX, typename DataType>
-inline bool isDataType(const DataType & data_type)
-{
-    WhichDataType which(data_type);
-    return which.idx == TYPE_IDX;
-}
-
-template <typename ExpectedDataType, typename DataType>
-inline bool isDataType(const DataType & data_type)
-{
-    return isDataType<ExpectedDataType::type_id>(data_type);
-}
-
 template <typename DataType> constexpr bool IsDataTypeDecimal = false;
 template <typename DataType> constexpr bool IsDataTypeNumber = false;
 template <typename DataType> constexpr bool IsDataTypeDateOrDateTime = false;
diff --git a/src/DataTypes/NumberTraits.h b/src/DataTypes/NumberTraits.h
index c3b0d956ef5a..dc96f2db128f 100644
--- a/src/DataTypes/NumberTraits.h
+++ b/src/DataTypes/NumberTraits.h
@@ -3,7 +3,6 @@
 #include <type_traits>
 
 #include <Core/Types.h>
-#include <Common/UInt128.h>
 
 
 namespace DB
@@ -47,7 +46,7 @@ template <> struct Construct<false, false, 1> { using Type = UInt8; };
 template <> struct Construct<false, false, 2> { using Type = UInt16; };
 template <> struct Construct<false, false, 4> { using Type = UInt32; };
 template <> struct Construct<false, false, 8> { using Type = UInt64; };
-template <> struct Construct<false, false, 16> { using Type = UInt256; }; /// TODO: we cannot use our UInt128 here
+template <> struct Construct<false, false, 16> { using Type = UInt128; };
 template <> struct Construct<false, false, 32> { using Type = UInt256; };
 template <> struct Construct<false, true, 1> { using Type = Float32; };
 template <> struct Construct<false, true, 2> { using Type = Float32; };
@@ -183,11 +182,12 @@ struct ResultOfIf
                 ? max(sizeof(A), sizeof(B)) * 2
                 : max(sizeof(A), sizeof(B))>::Type;
 
-    using ConstructedTypeWithoutUUID = std::conditional_t<std::is_same_v<A, UInt128> || std::is_same_v<B, UInt128>, Error, ConstructedType>;
-    using ConstructedWithUUID = std::conditional_t<std::is_same_v<A, UInt128> && std::is_same_v<B, UInt128>, A, ConstructedTypeWithoutUUID>;
-
-    using Type = std::conditional_t<!IsDecimalNumber<A> && !IsDecimalNumber<B>, ConstructedWithUUID,
-        std::conditional_t<IsDecimalNumber<A> && IsDecimalNumber<B>, std::conditional_t<(sizeof(A) > sizeof(B)), A, B>, Error>>;
+    using Type =
+        std::conditional_t<std::is_same_v<A, B>, A,
+        std::conditional_t<IsDecimalNumber<A> && IsDecimalNumber<B>,
+            std::conditional_t<(sizeof(A) > sizeof(B)), A, B>,
+        std::conditional_t<!IsDecimalNumber<A> && !IsDecimalNumber<B>,
+            ConstructedType, Error>>>;
 };
 
 /** Before applying operator `%` and bitwise operations, operands are casted to whole numbers. */
diff --git a/src/DataTypes/Serializations/SerializationNumber.cpp b/src/DataTypes/Serializations/SerializationNumber.cpp
index 36cbd6a5ef8d..347db5d0aa5f 100644
--- a/src/DataTypes/Serializations/SerializationNumber.cpp
+++ b/src/DataTypes/Serializations/SerializationNumber.cpp
@@ -157,7 +157,7 @@ template class SerializationNumber<UInt8>;
 template class SerializationNumber<UInt16>;
 template class SerializationNumber<UInt32>;
 template class SerializationNumber<UInt64>;
-template class SerializationNumber<UInt128>; // base for UUID
+template class SerializationNumber<UInt128>;
 template class SerializationNumber<UInt256>;
 template class SerializationNumber<Int8>;
 template class SerializationNumber<Int16>;
diff --git a/src/DataTypes/Serializations/SerializationNumber.h b/src/DataTypes/Serializations/SerializationNumber.h
index 09976a4bc4f2..cb40b6c5437e 100644
--- a/src/DataTypes/Serializations/SerializationNumber.h
+++ b/src/DataTypes/Serializations/SerializationNumber.h
@@ -9,7 +9,7 @@ namespace DB
 template <typename T>
 class SerializationNumber : public SimpleTextSerialization
 {
-    static_assert(IsNumber<T>);
+    static_assert(is_arithmetic_v<T>);
 
 public:
     using FieldType = T;
diff --git a/src/DataTypes/Serializations/SerializationUUID.cpp b/src/DataTypes/Serializations/SerializationUUID.cpp
index 1a0640a5e69d..3c1ba869466d 100644
--- a/src/DataTypes/Serializations/SerializationUUID.cpp
+++ b/src/DataTypes/Serializations/SerializationUUID.cpp
@@ -6,19 +6,20 @@
 #include <IO/ReadHelpers.h>
 #include <Common/assert_cast.h>
 
+
 namespace DB
 {
 
 void SerializationUUID::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const
 {
-    writeText(UUID(assert_cast<const ColumnUInt128 &>(column).getData()[row_num]), ostr);
+    writeText(assert_cast<const ColumnUUID &>(column).getData()[row_num], ostr);
 }
 
 void SerializationUUID::deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const
 {
     UUID x;
     readText(x, istr);
-    assert_cast<ColumnUInt128 &>(column).getData().push_back(x);
+    assert_cast<ColumnUUID &>(column).getData().push_back(x);
 }
 
 void SerializationUUID::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
@@ -44,7 +45,7 @@ void SerializationUUID::deserializeTextQuoted(IColumn & column, ReadBuffer & ist
     assertChar('\'', istr);
     readText(x, istr);
     assertChar('\'', istr);
-    assert_cast<ColumnUInt128 &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.
+    assert_cast<ColumnUUID &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.
 }
 
 void SerializationUUID::serializeTextJSON(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
@@ -60,7 +61,7 @@ void SerializationUUID::deserializeTextJSON(IColumn & column, ReadBuffer & istr,
     assertChar('"', istr);
     readText(x, istr);
     assertChar('"', istr);
-    assert_cast<ColumnUInt128 &>(column).getData().push_back(x);
+    assert_cast<ColumnUUID &>(column).getData().push_back(x);
 }
 
 void SerializationUUID::serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
@@ -74,7 +75,55 @@ void SerializationUUID::deserializeTextCSV(IColumn & column, ReadBuffer & istr,
 {
     UUID value;
     readCSV(value, istr);
-    assert_cast<ColumnUInt128 &>(column).getData().push_back(value);
+    assert_cast<ColumnUUID &>(column).getData().push_back(value);
+}
+
+
+void SerializationUUID::serializeBinary(const Field & field, WriteBuffer & ostr) const
+{
+    UUID x = get<UUID>(field);
+    writeBinary(x, ostr);
+}
+
+void SerializationUUID::deserializeBinary(Field & field, ReadBuffer & istr) const
+{
+    UUID x;
+    readBinary(x, istr);
+    field = NearestFieldType<UUID>(x);
+}
+
+void SerializationUUID::serializeBinary(const IColumn & column, size_t row_num, WriteBuffer & ostr) const
+{
+    writeBinary(assert_cast<const ColumnVector<UUID> &>(column).getData()[row_num], ostr);
+}
+
+void SerializationUUID::deserializeBinary(IColumn & column, ReadBuffer & istr) const
+{
+    UUID x;
+    readBinary(x, istr);
+    assert_cast<ColumnVector<UUID> &>(column).getData().push_back(x);
+}
+
+void SerializationUUID::serializeBinaryBulk(const IColumn & column, WriteBuffer & ostr, size_t offset, size_t limit) const
+{
+    const typename ColumnVector<UUID>::Container & x = typeid_cast<const ColumnVector<UUID> &>(column).getData();
+
+    size_t size = x.size();
+
+    if (limit == 0 || offset + limit > size)
+        limit = size - offset;
+
+    if (limit)
+        ostr.write(reinterpret_cast<const char *>(&x[offset]), sizeof(UUID) * limit);
+}
+
+void SerializationUUID::deserializeBinaryBulk(IColumn & column, ReadBuffer & istr, size_t limit, double /*avg_value_size_hint*/) const
+{
+    typename ColumnVector<UUID>::Container & x = typeid_cast<ColumnVector<UUID> &>(column).getData();
+    size_t initial_size = x.size();
+    x.resize(initial_size + limit);
+    size_t size = istr.readBig(reinterpret_cast<char*>(&x[initial_size]), sizeof(UUID) * limit);
+    x.resize(initial_size + size / sizeof(UUID));
 }
 
 }
diff --git a/src/DataTypes/Serializations/SerializationUUID.h b/src/DataTypes/Serializations/SerializationUUID.h
index 93bf166bbd97..3100e1288485 100644
--- a/src/DataTypes/Serializations/SerializationUUID.h
+++ b/src/DataTypes/Serializations/SerializationUUID.h
@@ -5,7 +5,7 @@
 namespace DB
 {
 
-class SerializationUUID : public SerializationNumber<UInt128>
+class SerializationUUID : public SimpleTextSerialization
 {
 public:
     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
@@ -18,6 +18,13 @@ class SerializationUUID : public SerializationNumber<UInt128>
     void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;
     void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
     void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override;
+
+    void serializeBinary(const Field & field, WriteBuffer & ostr) const override;
+    void deserializeBinary(Field & field, ReadBuffer & istr) const override;
+    void serializeBinary(const IColumn & column, size_t row_num, WriteBuffer & ostr) const override;
+    void deserializeBinary(IColumn & column, ReadBuffer & istr) const override;
+    void serializeBinaryBulk(const IColumn & column, WriteBuffer & ostr, size_t offset, size_t limit) const override;
+    void deserializeBinaryBulk(IColumn & column, ReadBuffer & istr, size_t limit, double avg_value_size_hint) const override;
 };
 
 }
diff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp
index 31e8613a88e4..a04d16ef7cd7 100644
--- a/src/DataTypes/getLeastSupertype.cpp
+++ b/src/DataTypes/getLeastSupertype.cpp
@@ -390,6 +390,8 @@ DataTypePtr getLeastSupertype(const DataTypes & types)
                 maximize(max_bits_of_unsigned_integer, 32);
             else if (typeid_cast<const DataTypeUInt64 *>(type.get()))
                 maximize(max_bits_of_unsigned_integer, 64);
+            else if (typeid_cast<const DataTypeUInt128 *>(type.get()))
+                maximize(max_bits_of_unsigned_integer, 128);
             else if (typeid_cast<const DataTypeUInt256 *>(type.get()))
                 maximize(max_bits_of_unsigned_integer, 256);
             else if (typeid_cast<const DataTypeInt8 *>(type.get()) || typeid_cast<const DataTypeEnum8 *>(type.get()))
@@ -482,6 +484,8 @@ DataTypePtr getLeastSupertype(const DataTypes & types)
                     return std::make_shared<DataTypeUInt32>();
                 else if (min_bit_width_of_integer <= 64)
                     return std::make_shared<DataTypeUInt64>();
+                else if (min_bit_width_of_integer <= 128)
+                    return std::make_shared<DataTypeUInt128>();
                 else if (min_bit_width_of_integer <= 256)
                     return std::make_shared<DataTypeUInt256>();
                 else
diff --git a/src/Dictionaries/CacheDictionaryStorage.h b/src/Dictionaries/CacheDictionaryStorage.h
index 720800e63577..a79d83eea057 100644
--- a/src/Dictionaries/CacheDictionaryStorage.h
+++ b/src/Dictionaries/CacheDictionaryStorage.h
@@ -594,16 +594,20 @@ class CacheDictionaryStorage final : public ICacheDictionaryStorage
             PaddedPODArray<UInt32>,
             PaddedPODArray<UInt64>,
             PaddedPODArray<UInt128>,
+            PaddedPODArray<UInt256>,
             PaddedPODArray<Int8>,
             PaddedPODArray<Int16>,
             PaddedPODArray<Int32>,
             PaddedPODArray<Int64>,
+            PaddedPODArray<Int128>,
+            PaddedPODArray<Int256>,
             PaddedPODArray<Decimal32>,
             PaddedPODArray<Decimal64>,
             PaddedPODArray<Decimal128>,
             PaddedPODArray<Decimal256>,
             PaddedPODArray<Float32>,
             PaddedPODArray<Float64>,
+            PaddedPODArray<UUID>,
             PaddedPODArray<StringRef>,
             std::vector<Field>> attribute_container;
     };
diff --git a/src/Dictionaries/CassandraBlockInputStream.cpp b/src/Dictionaries/CassandraBlockInputStream.cpp
index 4e71c2124515..9afc0069d480 100644
--- a/src/Dictionaries/CassandraBlockInputStream.cpp
+++ b/src/Dictionaries/CassandraBlockInputStream.cpp
@@ -138,7 +138,7 @@ void CassandraBlockInputStream::insertValue(IColumn & column, ValueType type, co
             cass_value_get_uuid(cass_value, &value);
             std::array<char, CASS_UUID_STRING_LENGTH> uuid_str;
             cass_uuid_string(value, uuid_str.data());
-            assert_cast<ColumnUInt128 &>(column).insert(parse<UUID>(uuid_str.data(), uuid_str.size()));
+            assert_cast<ColumnUUID &>(column).insert(parse<UUID>(uuid_str.data(), uuid_str.size()));
             break;
         }
         default:
diff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h
index c2071d8136ae..6d459bab85f6 100644
--- a/src/Dictionaries/DictionaryHelpers.h
+++ b/src/Dictionaries/DictionaryHelpers.h
@@ -243,13 +243,19 @@ class DictionaryAttributeColumnProvider
         {
             return ColumnType::create();
         }
-        if constexpr (IsDecimalNumber<DictionaryAttributeType>)
+        else if constexpr (std::is_same_v<DictionaryAttributeType, UUID>)
+        {
+            return ColumnType::create(size);
+        }
+        else if constexpr (IsDecimalNumber<DictionaryAttributeType>)
         {
             auto scale = getDecimalScale(*dictionary_attribute.nested_type);
             return ColumnType::create(size, scale);
         }
-        else if constexpr (IsNumber<DictionaryAttributeType>)
+        else if constexpr (is_arithmetic_v<DictionaryAttributeType>)
+        {
             return ColumnType::create(size);
+        }
         else
             throw Exception(ErrorCodes::TYPE_MISMATCH, "Unsupported attribute type.");
     }
@@ -563,7 +569,7 @@ static const PaddedPODArray<T> & getColumnVectorData(
         throw Exception(ErrorCodes::TYPE_MISMATCH,
             "{}: type mismatch: column has wrong type expected {}",
             dictionary->getDictionaryID().getNameForLogs(),
-            TypeName<T>::get());
+            TypeName<T>);
     }
 
     if (is_const_column)
diff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp
index dd53e31041bd..c0d00d3ae40d 100644
--- a/src/Dictionaries/DictionaryStructure.cpp
+++ b/src/Dictionaries/DictionaryStructure.cpp
@@ -14,6 +14,7 @@
 #include <unordered_set>
 #include <ext/range.h>
 
+
 namespace DB
 {
 namespace ErrorCodes
@@ -48,36 +49,39 @@ AttributeUnderlyingType getAttributeUnderlyingType(const DataTypePtr & type)
 
     switch (type_index)
     {
-        case TypeIndex::UInt8:          return AttributeUnderlyingType::utUInt8;
-        case TypeIndex::UInt16:         return AttributeUnderlyingType::utUInt16;
-        case TypeIndex::UInt32:         return AttributeUnderlyingType::utUInt32;
-        case TypeIndex::UInt64:         return AttributeUnderlyingType::utUInt64;
-        case TypeIndex::UInt128:        return AttributeUnderlyingType::utUInt128;
+        case TypeIndex::UInt8:          return AttributeUnderlyingType::UInt8;
+        case TypeIndex::UInt16:         return AttributeUnderlyingType::UInt16;
+        case TypeIndex::UInt32:         return AttributeUnderlyingType::UInt32;
+        case TypeIndex::UInt64:         return AttributeUnderlyingType::UInt64;
+        case TypeIndex::UInt128:        return AttributeUnderlyingType::UInt128;
+        case TypeIndex::UInt256:        return AttributeUnderlyingType::UInt256;
 
-        case TypeIndex::Int8:           return AttributeUnderlyingType::utInt8;
-        case TypeIndex::Int16:          return AttributeUnderlyingType::utInt16;
-        case TypeIndex::Int32:          return AttributeUnderlyingType::utInt32;
-        case TypeIndex::Int64:          return AttributeUnderlyingType::utInt64;
+        case TypeIndex::Int8:           return AttributeUnderlyingType::Int8;
+        case TypeIndex::Int16:          return AttributeUnderlyingType::Int16;
+        case TypeIndex::Int32:          return AttributeUnderlyingType::Int32;
+        case TypeIndex::Int64:          return AttributeUnderlyingType::Int64;
+        case TypeIndex::Int128:         return AttributeUnderlyingType::Int128;
+        case TypeIndex::Int256:         return AttributeUnderlyingType::Int256;
 
-        case TypeIndex::Float32:        return AttributeUnderlyingType::utFloat32;
-        case TypeIndex::Float64:        return AttributeUnderlyingType::utFloat64;
+        case TypeIndex::Float32:        return AttributeUnderlyingType::Float32;
+        case TypeIndex::Float64:        return AttributeUnderlyingType::Float64;
 
-        case TypeIndex::Decimal32:      return AttributeUnderlyingType::utDecimal32;
-        case TypeIndex::Decimal64:      return AttributeUnderlyingType::utDecimal64;
-        case TypeIndex::Decimal128:     return AttributeUnderlyingType::utDecimal128;
-        case TypeIndex::Decimal256:     return AttributeUnderlyingType::utDecimal256;
+        case TypeIndex::Decimal32:      return AttributeUnderlyingType::Decimal32;
+        case TypeIndex::Decimal64:      return AttributeUnderlyingType::Decimal64;
+        case TypeIndex::Decimal128:     return AttributeUnderlyingType::Decimal128;
+        case TypeIndex::Decimal256:     return AttributeUnderlyingType::Decimal256;
 
-        case TypeIndex::Date:           return AttributeUnderlyingType::utUInt16;
-        case TypeIndex::DateTime:       return AttributeUnderlyingType::utUInt32;
-        case TypeIndex::DateTime64:     return AttributeUnderlyingType::utUInt64;
+        case TypeIndex::Date:           return AttributeUnderlyingType::UInt16;
+        case TypeIndex::DateTime:       return AttributeUnderlyingType::UInt32;
+        case TypeIndex::DateTime64:     return AttributeUnderlyingType::UInt64;
 
-        case TypeIndex::UUID:           return AttributeUnderlyingType::utUInt128;
+        case TypeIndex::UUID:           return AttributeUnderlyingType::UUID;
 
-        case TypeIndex::String:         return AttributeUnderlyingType::utString;
+        case TypeIndex::String:         return AttributeUnderlyingType::String;
 
         // Temporary hack to allow arrays in keys, since they are never retrieved for polygon dictionaries.
         // TODO: This should be fixed by fully supporting arrays in dictionaries.
-        case TypeIndex::Array:          return AttributeUnderlyingType::utString;
+        case TypeIndex::Array:          return AttributeUnderlyingType::String;
 
         default: break;
     }
@@ -90,38 +94,9 @@ std::string toString(AttributeUnderlyingType type)
 {
     switch (type)
     {
-        case AttributeUnderlyingType::utUInt8:
-            return "UInt8";
-        case AttributeUnderlyingType::utUInt16:
-            return "UInt16";
-        case AttributeUnderlyingType::utUInt32:
-            return "UInt32";
-        case AttributeUnderlyingType::utUInt64:
-            return "UInt64";
-        case AttributeUnderlyingType::utUInt128:
-            return "UUID";
-        case AttributeUnderlyingType::utInt8:
-            return "Int8";
-        case AttributeUnderlyingType::utInt16:
-            return "Int16";
-        case AttributeUnderlyingType::utInt32:
-            return "Int32";
-        case AttributeUnderlyingType::utInt64:
-            return "Int64";
-        case AttributeUnderlyingType::utFloat32:
-            return "Float32";
-        case AttributeUnderlyingType::utFloat64:
-            return "Float64";
-        case AttributeUnderlyingType::utDecimal32:
-            return "Decimal32";
-        case AttributeUnderlyingType::utDecimal64:
-            return "Decimal64";
-        case AttributeUnderlyingType::utDecimal128:
-            return "Decimal128";
-        case AttributeUnderlyingType::utDecimal256:
-            return "Decimal256";
-        case AttributeUnderlyingType::utString:
-            return "String";
+#define M(TYPE) case AttributeUnderlyingType::TYPE: return #TYPE;
+    FOR_ATTRIBUTE_TYPES(M)
+#undef M
     }
 
     throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "Unknown dictionary attribute type {}", toString(static_cast<int>(type)));
@@ -208,7 +183,7 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration
 
         if (attribute.hierarchical)
         {
-            if (id && attribute.underlying_type != AttributeUnderlyingType::utUInt64)
+            if (id && attribute.underlying_type != AttributeUnderlyingType::UInt64)
                 throw Exception(ErrorCodes::TYPE_MISMATCH,
                     "Hierarchical attribute type for dictionary with simple key must be UInt64. Actual {}",
                     toString(attribute.underlying_type));
@@ -320,7 +295,7 @@ bool DictionaryStructure::isKeySizeFixed() const
         return true;
 
     for (const auto & key_i : *key)
-        if (key_i.underlying_type == AttributeUnderlyingType::utString)
+        if (key_i.underlying_type == AttributeUnderlyingType::String)
             return false;
 
     return true;
diff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h
index ce5dd3dd422c..4815501b6962 100644
--- a/src/Dictionaries/DictionaryStructure.h
+++ b/src/Dictionaries/DictionaryStructure.h
@@ -5,7 +5,6 @@
 #include <string>
 #include <vector>
 
-
 #include <Poco/Util/AbstractConfiguration.h>
 
 #include <Core/Field.h>
@@ -13,27 +12,43 @@
 #include <DataTypes/IDataType.h>
 #include <Interpreters/IExternalLoadable.h>
 
+#if defined(__GNUC__)
+    /// GCC mistakenly warns about the names in enum class.
+    #pragma GCC diagnostic ignored "-Wshadow"
+#endif
+
+
+#define FOR_ATTRIBUTE_TYPES(M) \
+    M(UInt8) \
+    M(UInt16) \
+    M(UInt32) \
+    M(UInt64) \
+    M(UInt128) \
+    M(UInt256) \
+    M(Int8) \
+    M(Int16) \
+    M(Int32) \
+    M(Int64) \
+    M(Int128) \
+    M(Int256) \
+    M(Float32) \
+    M(Float64) \
+    M(Decimal32) \
+    M(Decimal64) \
+    M(Decimal128) \
+    M(Decimal256) \
+    M(UUID) \
+    M(String) \
+
+
 namespace DB
 {
 
 enum class AttributeUnderlyingType
 {
-    utUInt8,
-    utUInt16,
-    utUInt32,
-    utUInt64,
-    utUInt128,
-    utInt8,
-    utInt16,
-    utInt32,
-    utInt64,
-    utFloat32,
-    utFloat64,
-    utDecimal32,
-    utDecimal64,
-    utDecimal128,
-    utDecimal256,
-    utString
+#define M(TYPE) TYPE,
+    FOR_ATTRIBUTE_TYPES(M)
+#undef M
 };
 
 
@@ -81,54 +96,12 @@ void callOnDictionaryAttributeType(AttributeUnderlyingType type, F&& func)
 {
     switch (type)
     {
-        case AttributeUnderlyingType::utUInt8:
-            func(DictionaryAttributeType<UInt8>());
-            break;
-        case AttributeUnderlyingType::utUInt16:
-            func(DictionaryAttributeType<UInt16>());
-            break;
-        case AttributeUnderlyingType::utUInt32:
-            func(DictionaryAttributeType<UInt32>());
-            break;
-        case AttributeUnderlyingType::utUInt64:
-            func(DictionaryAttributeType<UInt64>());
-            break;
-        case AttributeUnderlyingType::utUInt128:
-            func(DictionaryAttributeType<UInt128>());
-            break;
-        case AttributeUnderlyingType::utInt8:
-            func(DictionaryAttributeType<Int8>());
-            break;
-        case AttributeUnderlyingType::utInt16:
-            func(DictionaryAttributeType<Int16>());
-            break;
-        case AttributeUnderlyingType::utInt32:
-            func(DictionaryAttributeType<Int32>());
-            break;
-        case AttributeUnderlyingType::utInt64:
-            func(DictionaryAttributeType<Int64>());
-            break;
-        case AttributeUnderlyingType::utFloat32:
-            func(DictionaryAttributeType<Float32>());
-            break;
-        case AttributeUnderlyingType::utFloat64:
-            func(DictionaryAttributeType<Float64>());
-            break;
-        case AttributeUnderlyingType::utString:
-            func(DictionaryAttributeType<String>());
-            break;
-        case AttributeUnderlyingType::utDecimal32:
-            func(DictionaryAttributeType<Decimal32>());
-            break;
-        case AttributeUnderlyingType::utDecimal64:
-            func(DictionaryAttributeType<Decimal64>());
-            break;
-        case AttributeUnderlyingType::utDecimal128:
-            func(DictionaryAttributeType<Decimal128>());
-            break;
-        case AttributeUnderlyingType::utDecimal256:
-            func(DictionaryAttributeType<Decimal256>());
+#define M(TYPE) \
+        case AttributeUnderlyingType::TYPE: \
+            func(DictionaryAttributeType<TYPE>()); \
             break;
+    FOR_ATTRIBUTE_TYPES(M)
+#undef M
     }
 };
 
diff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h
index 61a1099aa6df..211b1cdc33dc 100644
--- a/src/Dictionaries/FlatDictionary.h
+++ b/src/Dictionaries/FlatDictionary.h
@@ -121,16 +121,20 @@ class FlatDictionary final : public IDictionary
             UInt32,
             UInt64,
             UInt128,
+            UInt256,
             Int8,
             Int16,
             Int32,
             Int64,
+            Int128,
+            Int256,
             Decimal32,
             Decimal64,
             Decimal128,
             Decimal256,
             Float32,
             Float64,
+            UUID,
             StringRef>
             null_values;
         std::variant<
@@ -139,16 +143,20 @@ class FlatDictionary final : public IDictionary
             ContainerType<UInt32>,
             ContainerType<UInt64>,
             ContainerType<UInt128>,
+            ContainerType<UInt256>,
             ContainerType<Int8>,
             ContainerType<Int16>,
             ContainerType<Int32>,
             ContainerType<Int64>,
+            ContainerType<Int128>,
+            ContainerType<Int256>,
             ContainerType<Decimal32>,
             ContainerType<Decimal64>,
             ContainerType<Decimal128>,
             ContainerType<Decimal256>,
             ContainerType<Float32>,
             ContainerType<Float64>,
+            ContainerType<UUID>,
             ContainerType<StringRef>>
             container;
 
diff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h
index eeb873fb190a..cc04c6805eef 100644
--- a/src/Dictionaries/HashedDictionary.h
+++ b/src/Dictionaries/HashedDictionary.h
@@ -153,16 +153,20 @@ class HashedDictionary final : public IDictionary
             UInt32,
             UInt64,
             UInt128,
+            UInt256,
             Int8,
             Int16,
             Int32,
             Int64,
+            Int128,
+            Int256,
             Decimal32,
             Decimal64,
             Decimal128,
             Decimal256,
             Float32,
             Float64,
+            UUID,
             StringRef>
             null_values;
 
@@ -172,16 +176,20 @@ class HashedDictionary final : public IDictionary
             CollectionType<UInt32>,
             CollectionType<UInt64>,
             CollectionType<UInt128>,
+            CollectionType<UInt256>,
             CollectionType<Int8>,
             CollectionType<Int16>,
             CollectionType<Int32>,
             CollectionType<Int64>,
+            CollectionType<Int128>,
+            CollectionType<Int256>,
             CollectionType<Decimal32>,
             CollectionType<Decimal64>,
             CollectionType<Decimal128>,
             CollectionType<Decimal256>,
             CollectionType<Float32>,
             CollectionType<Float64>,
+            CollectionType<UUID>,
             CollectionType<StringRef>>
             container;
 
diff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h
index 9c58a93de8ac..edca68aedbaa 100644
--- a/src/Dictionaries/IPAddressDictionary.h
+++ b/src/Dictionaries/IPAddressDictionary.h
@@ -102,16 +102,20 @@ class IPAddressDictionary final : public IDictionary
             UInt32,
             UInt64,
             UInt128,
+            UInt256,
             Int8,
             Int16,
             Int32,
             Int64,
+            Int128,
+            Int256,
             Decimal32,
             Decimal64,
             Decimal128,
             Decimal256,
             Float32,
             Float64,
+            UUID,
             String>
             null_values;
         std::variant<
@@ -120,16 +124,20 @@ class IPAddressDictionary final : public IDictionary
             ContainerType<UInt32>,
             ContainerType<UInt64>,
             ContainerType<UInt128>,
+            ContainerType<UInt256>,
             ContainerType<Int8>,
             ContainerType<Int16>,
             ContainerType<Int32>,
             ContainerType<Int64>,
+            ContainerType<Int128>,
+            ContainerType<Int256>,
             ContainerType<Decimal32>,
             ContainerType<Decimal64>,
             ContainerType<Decimal128>,
             ContainerType<Decimal256>,
             ContainerType<Float32>,
             ContainerType<Float64>,
+            ContainerType<UUID>,
             ContainerType<StringRef>>
             maps;
         std::unique_ptr<Arena> string_arena;
diff --git a/src/Dictionaries/MongoDBDictionarySource.cpp b/src/Dictionaries/MongoDBDictionarySource.cpp
index 0ab45dc45938..634951740377 100644
--- a/src/Dictionaries/MongoDBDictionarySource.cpp
+++ b/src/Dictionaries/MongoDBDictionarySource.cpp
@@ -50,7 +50,6 @@ void registerDictionarySourceMongoDB(DictionarySourceFactory & factory)
 // Poco/MongoDB/BSONWriter.h:54: void writeCString(const std::string & value);
 // src/IO/WriteHelpers.h:146 #define writeCString(s, buf)
 #include <IO/WriteHelpers.h>
-#include <Common/FieldVisitors.h>
 #include <ext/enumerate.h>
 #include <DataStreams/MongoDBBlockInputStream.h>
 
@@ -59,6 +58,7 @@ namespace DB
 {
 namespace ErrorCodes
 {
+    extern const int NOT_IMPLEMENTED;
     extern const int UNSUPPORTED_METHOD;
     extern const int MONGODB_CANNOT_AUTHENTICATE;
 }
@@ -186,28 +186,26 @@ BlockInputStreamPtr MongoDBDictionarySource::loadKeys(const Columns & key_column
         {
             switch (attr.second.underlying_type)
             {
-                case AttributeUnderlyingType::utUInt8:
-                case AttributeUnderlyingType::utUInt16:
-                case AttributeUnderlyingType::utUInt32:
-                case AttributeUnderlyingType::utUInt64:
-                case AttributeUnderlyingType::utUInt128:
-                case AttributeUnderlyingType::utInt8:
-                case AttributeUnderlyingType::utInt16:
-                case AttributeUnderlyingType::utInt32:
-                case AttributeUnderlyingType::utInt64:
-                case AttributeUnderlyingType::utDecimal32:
-                case AttributeUnderlyingType::utDecimal64:
-                case AttributeUnderlyingType::utDecimal128:
-                case AttributeUnderlyingType::utDecimal256:
+                case AttributeUnderlyingType::UInt8:
+                case AttributeUnderlyingType::UInt16:
+                case AttributeUnderlyingType::UInt32:
+                case AttributeUnderlyingType::UInt64:
+                case AttributeUnderlyingType::Int8:
+                case AttributeUnderlyingType::Int16:
+                case AttributeUnderlyingType::Int32:
+                case AttributeUnderlyingType::Int64:
+                {
                     key.add(attr.second.name, Int32(key_columns[attr.first]->get64(row_idx)));
                     break;
-
-                case AttributeUnderlyingType::utFloat32:
-                case AttributeUnderlyingType::utFloat64:
+                }
+                case AttributeUnderlyingType::Float32:
+                case AttributeUnderlyingType::Float64:
+                {
                     key.add(attr.second.name, key_columns[attr.first]->getFloat64(row_idx));
                     break;
-
-                case AttributeUnderlyingType::utString:
+                }
+                case AttributeUnderlyingType::String:
+                {
                     String loaded_str(get<String>((*key_columns[attr.first])[row_idx]));
                     /// Convert string to ObjectID
                     if (attr.second.is_object_id)
@@ -220,6 +218,9 @@ BlockInputStreamPtr MongoDBDictionarySource::loadKeys(const Columns & key_column
                         key.add(attr.second.name, loaded_str);
                     }
                     break;
+                }
+                default:
+                    throw Exception("Unsupported dictionary attribute type for MongoDB dictionary source", ErrorCodes::NOT_IMPLEMENTED);
             }
         }
     }
diff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h
index 76dc00135685..edd8275acd1c 100644
--- a/src/Dictionaries/RangeHashedDictionary.h
+++ b/src/Dictionaries/RangeHashedDictionary.h
@@ -113,16 +113,20 @@ class RangeHashedDictionary final : public IDictionary
             UInt32,
             UInt64,
             UInt128,
+            UInt256,
             Int8,
             Int16,
             Int32,
             Int64,
+            Int128,
+            Int256,
             Decimal32,
             Decimal64,
             Decimal128,
             Decimal256,
             Float32,
             Float64,
+            UUID,
             StringRef>
             null_values;
         std::variant<
@@ -131,16 +135,20 @@ class RangeHashedDictionary final : public IDictionary
             Ptr<UInt32>,
             Ptr<UInt64>,
             Ptr<UInt128>,
+            Ptr<UInt256>,
             Ptr<Int8>,
             Ptr<Int16>,
             Ptr<Int32>,
             Ptr<Int64>,
+            Ptr<Int128>,
+            Ptr<Int256>,
             Ptr<Decimal32>,
             Ptr<Decimal64>,
             Ptr<Decimal128>,
             Ptr<Decimal256>,
             Ptr<Float32>,
             Ptr<Float64>,
+            Ptr<UUID>,
             Ptr<StringRef>>
             maps;
         std::unique_ptr<Arena> string_arena;
diff --git a/src/Dictionaries/RedisBlockInputStream.cpp b/src/Dictionaries/RedisBlockInputStream.cpp
index f74ac348a99d..bb8ef92eeea7 100644
--- a/src/Dictionaries/RedisBlockInputStream.cpp
+++ b/src/Dictionaries/RedisBlockInputStream.cpp
@@ -109,7 +109,7 @@ namespace DB
                     break;
                 }
                 case ValueType::vtUUID:
-                    assert_cast<ColumnUInt128 &>(column).insertValue(parse<UUID>(string_value));
+                    assert_cast<ColumnUUID &>(column).insertValue(parse<UUID>(string_value));
                     break;
                 default:
                     throw Exception(ErrorCodes::UNKNOWN_TYPE,
diff --git a/src/Dictionaries/RedisDictionarySource.cpp b/src/Dictionaries/RedisDictionarySource.cpp
index 8144b37e63df..f62dc0d74bd9 100644
--- a/src/Dictionaries/RedisDictionarySource.cpp
+++ b/src/Dictionaries/RedisDictionarySource.cpp
@@ -30,7 +30,6 @@ void registerDictionarySourceRedis(DictionarySourceFactory & factory)
 #include <Poco/Util/AbstractConfiguration.h>
 
 #include <IO/WriteHelpers.h>
-#include <Common/FieldVisitors.h>
 
 #include "RedisBlockInputStream.h"
 
diff --git a/src/Formats/MySQLBlockInputStream.cpp b/src/Formats/MySQLBlockInputStream.cpp
index be0cb31f22d2..b12b4f755ed2 100644
--- a/src/Formats/MySQLBlockInputStream.cpp
+++ b/src/Formats/MySQLBlockInputStream.cpp
@@ -177,8 +177,8 @@ namespace
                 break;
             }
             case ValueType::vtUUID:
-                assert_cast<ColumnUInt128 &>(column).insert(parse<UUID>(value.data(), value.size()));
-                read_bytes_size += assert_cast<ColumnUInt128 &>(column).byteSize();
+                assert_cast<ColumnUUID &>(column).insert(parse<UUID>(value.data(), value.size()));
+                read_bytes_size += assert_cast<ColumnUUID &>(column).byteSize();
                 break;
             case ValueType::vtDateTime64:[[fallthrough]];
             case ValueType::vtDecimal32: [[fallthrough]];
diff --git a/src/Formats/ProtobufSerializer.cpp b/src/Formats/ProtobufSerializer.cpp
index 3539628f98e9..962df507f824 100644
--- a/src/Formats/ProtobufSerializer.cpp
+++ b/src/Formats/ProtobufSerializer.cpp
@@ -237,7 +237,7 @@ namespace
             }
             catch (...)
             {
-                cannotConvertValue(str, "String", TypeName<DestType>::get());
+                cannotConvertValue(str, "String", TypeName<DestType>);
             }
         }
 
@@ -254,7 +254,7 @@ namespace
             }
             catch (boost::numeric::bad_numeric_cast &)
             {
-                cannotConvertValue(toString(value), TypeName<SrcType>::get(), TypeName<DestType>::get());
+                cannotConvertValue(toString(value), TypeName<SrcType>, TypeName<DestType>);
             }
             return result;
         }
@@ -429,7 +429,7 @@ namespace
                         else if (value == 1)
                             writeUInt(1);
                         else
-                            cannotConvertValue(toString(value), TypeName<NumberType>::get(), field_descriptor.type_name());
+                            cannotConvertValue(toString(value), TypeName<NumberType>, field_descriptor.type_name());
                     };
 
                     read_function = [this]() -> NumberType
@@ -438,7 +438,7 @@ namespace
                         if (u64 < 2)
                             return static_cast<NumberType>(u64);
                         else
-                            cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<NumberType>::get());
+                            cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<NumberType>);
                     };
 
                     default_function = [this]() -> NumberType { return static_cast<NumberType>(field_descriptor.default_value_bool()); };
@@ -492,7 +492,7 @@ namespace
         {
             throw Exception(
                 "The field " + quoteString(field_descriptor.full_name()) + " has an incompatible type " + field_descriptor.type_name()
-                    + " for serialization of the data type " + quoteString(TypeName<NumberType>::get()),
+                    + " for serialization of the data type " + quoteString(TypeName<NumberType>),
                 ErrorCodes::DATA_TYPE_INCOMPATIBLE_WITH_PROTOBUF_FIELD);
         }
 
@@ -507,7 +507,7 @@ namespace
         {
             const auto * enum_value_descriptor = field_descriptor.enum_type()->FindValueByNumber(value);
             if (!enum_value_descriptor)
-                cannotConvertValue(toString(value), TypeName<NumberType>::get(), field_descriptor.type_name());
+                cannotConvertValue(toString(value), TypeName<NumberType>, field_descriptor.type_name());
         }
 
     protected:
@@ -1240,7 +1240,7 @@ namespace
                             {
                                 WriteBufferFromOwnString buf;
                                 writeText(decimal, scale, buf);
-                                cannotConvertValue(buf.str(), TypeName<DecimalType>::get(), field_descriptor.type_name());
+                                cannotConvertValue(buf.str(), TypeName<DecimalType>, field_descriptor.type_name());
                             }
                         };
 
@@ -1250,7 +1250,7 @@ namespace
                             if (u64 < 2)
                                 return numberToDecimal(static_cast<UInt64>(u64 != 0));
                             else
-                                cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<DecimalType>::get());
+                                cannotConvertValue(toString(u64), field_descriptor.type_name(), TypeName<DecimalType>);
                         };
 
                         default_function = [this]() -> DecimalType
@@ -1289,7 +1289,7 @@ namespace
         {
             throw Exception(
                 "The field " + quoteString(field_descriptor.full_name()) + " has an incompatible type " + field_descriptor.type_name()
-                    + " for serialization of the data type " + quoteString(TypeName<DecimalType>::get()),
+                    + " for serialization of the data type " + quoteString(TypeName<DecimalType>),
                 ErrorCodes::DATA_TYPE_INCOMPATIBLE_WITH_PROTOBUF_FIELD);
         }
 
@@ -1503,18 +1503,42 @@ namespace
     };
 
 
-    /// Serializes a ColumnVector<UInt128> containing UUIDs to a field of type TYPE_STRING or TYPE_BYTES.
-    class ProtobufSerializerUUID : public ProtobufSerializerNumber<UInt128>
+    /// Serializes a ColumnVector<UUID> containing UUIDs to a field of type TYPE_STRING or TYPE_BYTES.
+    class ProtobufSerializerUUID : public ProtobufSerializerSingleValue
     {
     public:
         ProtobufSerializerUUID(
             const google::protobuf::FieldDescriptor & field_descriptor_,
             const ProtobufReaderOrWriter & reader_or_writer_)
-            : ProtobufSerializerNumber<UInt128>(field_descriptor_, reader_or_writer_)
+            : ProtobufSerializerSingleValue(field_descriptor_, reader_or_writer_)
         {
             setFunctions();
         }
 
+        void writeRow(size_t row_num) override
+        {
+            const auto & column_vector = assert_cast<const ColumnVector<UUID> &>(*column);
+            write_function(column_vector.getElement(row_num));
+        }
+
+        void readRow(size_t row_num) override
+        {
+            UUID value = read_function();
+            auto & column_vector = assert_cast<ColumnVector<UUID> &>(column->assumeMutableRef());
+            if (row_num < column_vector.size())
+                column_vector.getElement(row_num) = value;
+            else
+                column_vector.insertValue(value);
+        }
+
+        void insertDefaults(size_t row_num) override
+        {
+            auto & column_vector = assert_cast<ColumnVector<UUID> &>(column->assumeMutableRef());
+            if (row_num < column_vector.size())
+                return;
+            column_vector.insertDefault();
+        }
+
     private:
         void setFunctions()
         {
@@ -1526,19 +1550,19 @@ namespace
                     ErrorCodes::DATA_TYPE_INCOMPATIBLE_WITH_PROTOBUF_FIELD);
             }
 
-            write_function = [this](UInt128 value)
+            write_function = [this](UUID value)
             {
-                uuidToString(static_cast<UUID>(value), text_buffer);
+                uuidToString(value, text_buffer);
                 writeStr(text_buffer);
             };
 
-            read_function = [this]() -> UInt128
+            read_function = [this]() -> UUID
             {
                 readStr(text_buffer);
-                return stringToUUID(text_buffer);
+                return parse<UUID>(text_buffer);
             };
 
-            default_function = [this]() -> UInt128 { return stringToUUID(field_descriptor.default_value_string()); };
+            default_function = [this]() -> UUID { return parse<UUID>(field_descriptor.default_value_string()); };
         }
 
         static void uuidToString(const UUID & uuid, String & str)
@@ -1547,13 +1571,10 @@ namespace
             writeText(uuid, buf);
         }
 
-        static UUID stringToUUID(const String & str)
-        {
-            ReadBufferFromString buf{str};
-            UUID uuid;
-            readUUIDText(uuid, buf);
-            return uuid;
-        }
+        std::function<void(UUID)> write_function;
+        std::function<UUID()> read_function;
+        std::function<UUID()> default_function;
+        String text_buffer;
     };
 
 
diff --git a/src/Functions/CustomWeekTransforms.h b/src/Functions/CustomWeekTransforms.h
index 28da546eb93a..98b7c38f2668 100644
--- a/src/Functions/CustomWeekTransforms.h
+++ b/src/Functions/CustomWeekTransforms.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <regex>
+
 #include <Columns/ColumnVector.h>
 #include <Columns/ColumnsNumber.h>
 #include <common/types.h>
@@ -13,6 +13,7 @@
 /// The default mode value to use for the WEEK() function
 #define DEFAULT_WEEK_MODE 0
 
+
 namespace DB
 {
 namespace ErrorCodes
diff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h
index c299b9c4169c..86cac4f42226 100644
--- a/src/Functions/DateTimeTransforms.h
+++ b/src/Functions/DateTimeTransforms.h
@@ -1,9 +1,9 @@
 #pragma once
+
 #include <common/types.h>
 #include <Core/DecimalFunctions.h>
 #include <Common/Exception.h>
 #include <common/DateLUTImpl.h>
-//#include <common/TimeZone.h>
 #include <Columns/ColumnVector.h>
 #include <Columns/ColumnDecimal.h>
 #include <Functions/FunctionHelpers.h>
@@ -12,6 +12,7 @@
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
 
+
 namespace DB
 {
 
@@ -857,7 +858,8 @@ struct Transformer
 template <typename FromDataType, typename ToDataType, typename Transform>
 struct DateTimeTransformImpl
 {
-    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/, const Transform & transform = {})
+    static ColumnPtr execute(
+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/, const Transform & transform = {})
     {
         using Op = Transformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform>;
 
diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h
index e6c3a50a206e..508c598b0ede 100644
--- a/src/Functions/FunctionBinaryArithmetic.h
+++ b/src/Functions/FunctionBinaryArithmetic.h
@@ -5,7 +5,7 @@
 // sanitizer/asan_interface.h
 #include <memory>
 #include <type_traits>
-#include <Common/Arena.h>
+#include <common/wide_integer_to_string.h>
 
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypesDecimal.h>
@@ -29,6 +29,7 @@
 #include "DivisionUtils.h"
 #include "castTypeToEither.h"
 #include "FunctionFactory.h"
+#include <Common/Arena.h>
 #include <Common/typeid_cast.h>
 #include <Common/assert_cast.h>
 #include <Common/FieldVisitors.h>
@@ -86,6 +87,7 @@ template <> inline constexpr bool IsIntegral<DataTypeInt32> = true;
 template <> inline constexpr bool IsIntegral<DataTypeInt64> = true;
 
 template <typename DataType> constexpr bool IsExtended = false;
+template <> inline constexpr bool IsExtended<DataTypeUInt128> = true;
 template <> inline constexpr bool IsExtended<DataTypeUInt256> = true;
 template <> inline constexpr bool IsExtended<DataTypeInt128> = true;
 template <> inline constexpr bool IsExtended<DataTypeInt256> = true;
@@ -523,6 +525,7 @@ class FunctionBinaryArithmetic : public IFunction
             DataTypeUInt16,
             DataTypeUInt32,
             DataTypeUInt64,
+            DataTypeUInt128,
             DataTypeUInt256,
             DataTypeInt8,
             DataTypeInt16,
@@ -550,6 +553,7 @@ class FunctionBinaryArithmetic : public IFunction
             DataTypeUInt16,
             DataTypeUInt32,
             DataTypeUInt64,
+            DataTypeUInt128,
             DataTypeUInt256,
             DataTypeInt8,
             DataTypeInt16,
@@ -782,7 +786,7 @@ class FunctionBinaryArithmetic : public IFunction
         return function->execute(new_arguments, result_type, input_rows_count);
     }
 
-    template <class T, class ResultDataType, class CC, class C>
+    template <typename T, typename ResultDataType, typename CC, typename C>
     static auto helperGetOrConvert(const CC & col_const, const C & col)
     {
         using ResultType = typename ResultDataType::FieldType;
@@ -790,12 +794,14 @@ class FunctionBinaryArithmetic : public IFunction
 
         if constexpr (IsFloatingPoint<ResultDataType> && IsDecimalNumber<T>)
             return DecimalUtils::convertTo<NativeResultType>(col_const->template getValue<T>(), col.getScale());
+        else if constexpr (IsDecimalNumber<T>)
+            return col_const->template getValue<T>().value;
         else
             return col_const->template getValue<T>();
     }
 
-    template <OpCase op_case, bool left_decimal, bool right_decimal, class OpImpl, class OpImplCheck,
-              class L, class R, class VR, class SA, class SB>
+    template <OpCase op_case, bool left_decimal, bool right_decimal, typename OpImpl, typename OpImplCheck,
+              typename L, typename R, typename VR, typename SA, typename SB>
     void helperInvokeEither(const L& left, const R& right, VR& vec_res, SA scale_a, SB scale_b) const
     {
         if (check_decimal_overflow)
diff --git a/src/Functions/FunctionFactory.h b/src/Functions/FunctionFactory.h
index 96238a884206..7a49c79e2bf7 100644
--- a/src/Functions/FunctionFactory.h
+++ b/src/Functions/FunctionFactory.h
@@ -51,6 +51,13 @@ class FunctionFactory : private boost::noncopyable,
     FunctionOverloadResolverImplPtr getImpl(const std::string & name, ContextPtr context) const;
     FunctionOverloadResolverImplPtr tryGetImpl(const std::string & name, ContextPtr context) const;
 
+    /// Register a function by its name.
+    /// No locking, you must register all functions before usage of get.
+    void registerFunction(
+        const std::string & name,
+        Value creator,
+        CaseSensitiveness case_sensitiveness = CaseSensitive);
+
 private:
     using Functions = std::unordered_map<std::string, Value>;
 
@@ -68,13 +75,6 @@ class FunctionFactory : private boost::noncopyable,
     const Functions & getCaseInsensitiveMap() const override { return case_insensitive_functions; }
 
     String getFactoryName() const override { return "FunctionFactory"; }
-
-    /// Register a function by its name.
-    /// No locking, you must register all functions before usage of get.
-    void registerFunction(
-            const std::string & name,
-            Value creator,
-            CaseSensitiveness case_sensitiveness = CaseSensitive);
 };
 
 }
diff --git a/src/Functions/FunctionMathBinaryFloat64.h b/src/Functions/FunctionMathBinaryFloat64.h
index 00f6909f65cd..7b54d59d852b 100644
--- a/src/Functions/FunctionMathBinaryFloat64.h
+++ b/src/Functions/FunctionMathBinaryFloat64.h
@@ -76,18 +76,8 @@ class FunctionMathBinaryFloat64 : public IFunction
             if (rows_remaining != 0)
             {
                 RightType right_src_remaining[Impl::rows_per_iteration];
-                if constexpr (!is_big_int_v<RightType> && !std::is_same_v<RightType, Decimal256>)
-                {
-                    memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));
-                    memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));
-                }
-                else
-                {
-                    for (size_t i = 0; i < rows_remaining; i++)
-                        right_src_remaining[i] = right_src_data[rows_size + i];
-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)
-                        right_src_remaining[i] = 0;
-                }
+                memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));
+                memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));
                 Float64 dst_remaining[Impl::rows_per_iteration];
 
                 Impl::execute(left_src_data, right_src_remaining, dst_remaining);
@@ -123,32 +113,13 @@ class FunctionMathBinaryFloat64 : public IFunction
             if (rows_remaining != 0)
             {
                 LeftType left_src_remaining[Impl::rows_per_iteration];
-                if constexpr (!is_big_int_v<LeftType> && !std::is_same_v<LeftType, Decimal256>)
-                {
-                    memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));
-                    memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));
-                }
-                else
-                {
-                    for (size_t i = 0; i < rows_remaining; i++)
-                        left_src_remaining[i] = left_src_data[rows_size + i];
-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)
-                        left_src_remaining[i] = 0;
-                }
+                memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));
+                memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));
 
                 RightType right_src_remaining[Impl::rows_per_iteration];
-                if constexpr (!is_big_int_v<RightType> && !std::is_same_v<RightType, Decimal256>)
-                {
-                    memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));
-                    memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));
-                }
-                else
-                {
-                    for (size_t i = 0; i < rows_remaining; i++)
-                        right_src_remaining[i] = right_src_data[rows_size + i];
-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)
-                        right_src_remaining[i] = 0;
-                }
+                memcpy(right_src_remaining, &right_src_data[rows_size], rows_remaining * sizeof(RightType));
+                memset(right_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(RightType));
+
                 Float64 dst_remaining[Impl::rows_per_iteration];
 
                 Impl::execute(left_src_remaining, right_src_remaining, dst_remaining);
@@ -178,18 +149,8 @@ class FunctionMathBinaryFloat64 : public IFunction
             if (rows_remaining != 0)
             {
                 LeftType left_src_remaining[Impl::rows_per_iteration];
-                if constexpr (!is_big_int_v<LeftType> && !std::is_same_v<LeftType, Decimal256>)
-                {
-                    memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));
-                    memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));
-                }
-                else
-                {
-                    for (size_t i = 0; i < rows_remaining; i++)
-                        left_src_remaining[i] = left_src_data[rows_size + i];
-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)
-                        left_src_remaining[i] = 0;
-                }
+                memcpy(left_src_remaining, &left_src_data[rows_size], rows_remaining * sizeof(LeftType));
+                memset(left_src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(LeftType));
 
                 Float64 dst_remaining[Impl::rows_per_iteration];
 
diff --git a/src/Functions/FunctionMathUnary.h b/src/Functions/FunctionMathUnary.h
index e24d19e5a9b4..78c6cf3ce0ba 100644
--- a/src/Functions/FunctionMathUnary.h
+++ b/src/Functions/FunctionMathUnary.h
@@ -87,18 +87,8 @@ class FunctionMathUnary : public IFunction
             if (rows_remaining != 0)
             {
                 T src_remaining[Impl::rows_per_iteration];
-                if constexpr (is_big_int_v<T> || std::is_same_v<T, Decimal256>)
-                {
-                    for (size_t i = 0; i < rows_remaining; i++)
-                        src_remaining[i] = src_data[rows_size + i];
-                    for (size_t i = rows_remaining; i < Impl::rows_per_iteration; i++)
-                        src_remaining[i] = 0;
-                }
-                else
-                {
-                    memcpy(src_remaining, &src_data[rows_size], rows_remaining * sizeof(T));
-                    memset(src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(T));
-                }
+                memcpy(src_remaining, &src_data[rows_size], rows_remaining * sizeof(T));
+                memset(src_remaining + rows_remaining, 0, (Impl::rows_per_iteration - rows_remaining) * sizeof(T));
                 ReturnType dst_remaining[Impl::rows_per_iteration];
 
                 Impl::execute(src_remaining, dst_remaining);
diff --git a/src/Functions/FunctionUnaryArithmetic.h b/src/Functions/FunctionUnaryArithmetic.h
index 0c5c3f629616..0b616fd8ab6f 100644
--- a/src/Functions/FunctionUnaryArithmetic.h
+++ b/src/Functions/FunctionUnaryArithmetic.h
@@ -91,6 +91,7 @@ class FunctionUnaryArithmetic : public IFunction
             DataTypeUInt16,
             DataTypeUInt32,
             DataTypeUInt64,
+            DataTypeUInt128,
             DataTypeUInt256,
             DataTypeInt8,
             DataTypeInt16,
diff --git a/src/Functions/FunctionUnixTimestamp64.h b/src/Functions/FunctionUnixTimestamp64.h
index 18f9c7a8b020..d8d8a1b7a06b 100644
--- a/src/Functions/FunctionUnixTimestamp64.h
+++ b/src/Functions/FunctionUnixTimestamp64.h
@@ -5,145 +5,131 @@
 #include <Functions/FunctionHelpers.h>
 #include <DataTypes/DataTypeDateTime64.h>
 #include <DataTypes/DataTypesNumber.h>
+#include <Columns/ColumnsNumber.h>
 
 #include <common/arithmeticOverflow.h>
 
+
 namespace DB
 {
 
 namespace ErrorCodes
 {
+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
     extern const int DECIMAL_OVERFLOW;
 }
 
-/** Casts DateTim64 to or from Int64 representation narrowed down (or scaled up) to any scale value defined in Impl.
- */
-template <typename Impl>
-class FunctionUnixTimestamp64 : public IFunction
+/// Cast DateTime64 to Int64 representation narrowed down (or scaled up) to any scale value defined in Impl.
+class FunctionToUnixTimestamp64 : public IFunction
 {
+private:
+    size_t target_scale;
+    const char * name;
 public:
-    static constexpr auto name = Impl::name;
-    static constexpr auto target_scale = Impl::target_scale;
-
-    using SourceDataType = typename Impl::SourceDataType;
-    using ResultDataType = typename Impl::ResultDataType;
-
-    static constexpr bool is_result_datetime64 = std::is_same_v<ResultDataType, DataTypeDateTime64>;
-
-    static_assert(std::is_same_v<SourceDataType, DataTypeDateTime64> || std::is_same_v<ResultDataType, DataTypeDateTime64>);
-
-    static auto create(ContextPtr)
+    FunctionToUnixTimestamp64(size_t target_scale_, const char * name_)
+        : target_scale(target_scale_), name(name_)
     {
-        return std::make_shared<FunctionUnixTimestamp64<Impl>>();
     }
 
     String getName() const override { return name; }
-    size_t getNumberOfArguments() const override { return is_result_datetime64 ? 2 : 1; }
-    bool isVariadic() const override { return is_result_datetime64; }
+    size_t getNumberOfArguments() const override { return 1; }
+    bool isVariadic() const override { return false; }
     bool useDefaultImplementationForConstants() const override { return true; }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if constexpr (is_result_datetime64)
-        {
-            validateFunctionArgumentTypes(*this, arguments,
-                    FunctionArgumentDescriptors{{"value", isDataType<SourceDataType>, nullptr, std::string(SourceDataType::family_name).c_str()}},
-                    // optional
-                    FunctionArgumentDescriptors{
-    //                    {"precision", isDataType<DataTypeUInt8>, isColumnConst, ("Precision of the result, default is " + std::to_string(target_scale)).c_str()},
-                        {"timezone", isStringOrFixedString, isColumnConst, "Timezone of the result"},
-                    });
-            const auto timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);
-            return std::make_shared<DataTypeDateTime64>(target_scale, timezone);
-        }
-        else
-        {
-            validateFunctionArgumentTypes(*this, arguments,
-                    FunctionArgumentDescriptors{{"value", isDataType<SourceDataType>, nullptr, std::string(SourceDataType::family_name).c_str()}});
-            return std::make_shared<DataTypeInt64>();
-        }
+        if (!isDateTime64(arguments[0].type))
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The only argument for function {} must be DateTime64", name);
+
+        return std::make_shared<DataTypeInt64>();
     }
 
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
     {
-        using SourceColumnType = typename SourceDataType::ColumnType;
-        using ResultColumnType = typename ResultDataType::ColumnType;
-
         const auto & src = arguments[0];
         const auto & col = *src.column;
 
-        const SourceColumnType * source_col_typed = checkAndGetColumn<SourceColumnType>(col);
-        if (!source_col_typed && !(source_col_typed = checkAndGetColumnConstData<SourceColumnType>(&col)))
-            throw Exception("Invalid column type" + col.getName() + " expected "
-                    + std::string(SourceDataType::family_name),
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-
-        auto res_column = result_type->createColumn();
-
-        if (input_rows_count == 0)
-            return res_column;
+        auto res_column = ColumnInt64::create(input_rows_count);
+        auto & result_data = res_column->getData();
 
-        auto & result_data = assert_cast<ResultColumnType &>(res_column->assumeMutableRef()).getData();
-        result_data.reserve(source_col_typed->size());
-        const auto & source_data = source_col_typed->getData();
+        const auto & source_data = typeid_cast<const ColumnDecimal<DateTime64> &>(col).getData();
 
-        const auto scale_diff = getScaleDiff(*checkAndGetDataType<SourceDataType>(src.type.get()), *checkAndGetDataType<ResultDataType>(result_type.get()));
+        Int32 scale_diff = typeid_cast<const DataTypeDateTime64 &>(*src.type).getScale() - target_scale;
         if (scale_diff == 0)
         {
-            static_assert(sizeof(typename SourceColumnType::Container::value_type) == sizeof(typename ResultColumnType::Container::value_type));
-            // no conversion necessary
-            result_data.push_back_raw_many(source_data.size(), source_data.data());
+            for (size_t i = 0; i < input_rows_count; ++i)
+                result_data[i] = source_data[i];
         }
         else if (scale_diff < 0)
         {
-            const Int64 scale_multiplier = DecimalUtils::scaleMultiplier<Int64>(std::abs(scale_diff));
-            for (const auto & v : source_data)
+            const Int64 scale_multiplier = DecimalUtils::scaleMultiplier<Int64>(-scale_diff);
+            for (size_t i = 0; i < input_rows_count; ++i)
             {
-                Int64 result_value = toDestValue(v);
+                Int64 result_value = source_data[i];
                 if (common::mulOverflow(result_value, scale_multiplier, result_value))
                     throw Exception("Decimal overflow in " + getName(), ErrorCodes::DECIMAL_OVERFLOW);
 
-                result_data.push_back(result_value);
+                result_data[i] = result_value;
             }
         }
         else
         {
             const Int64 scale_multiplier = DecimalUtils::scaleMultiplier<Int64>(scale_diff);
-            for (const auto & v : source_data)
-                result_data.push_back(static_cast<Int64>(toDestValue(v) / scale_multiplier));
+            for (size_t i = 0; i < input_rows_count; ++i)
+                result_data[i] = Int64(source_data[i]) / scale_multiplier;
         }
 
         return res_column;
     }
+};
+
 
+class FunctionFromUnixTimestamp64 : public IFunction
+{
 private:
-    static Int64 getScaleDiff(const SourceDataType & src, const ResultDataType & dst)
+    size_t target_scale;
+    const char * name;
+public:
+    FunctionFromUnixTimestamp64(size_t target_scale_, const char * name_)
+        : target_scale(target_scale_), name(name_)
     {
-        Int64 src_scale = target_scale;
-        if constexpr (std::is_same_v<SourceDataType, DataTypeDateTime64>)
-        {
-            src_scale = src.getScale();
-        }
-
-        Int64 dst_scale = target_scale;
-        if constexpr (std::is_same_v<ResultDataType, DataTypeDateTime64>)
-        {
-            dst_scale = dst.getScale();
-        }
-
-        return src_scale - dst_scale;
     }
 
-    static auto toDestValue(const DateTime64 & v)
+    String getName() const override { return name; }
+    size_t getNumberOfArguments() const override { return 0; }
+    bool isVariadic() const override { return true; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        return Int64{v.value};
+        if (arguments.size() < 1 || arguments.size() > 2)
+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Function {} takes one or two arguments", name);
+
+        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The first argument for function {} must be Int64", name);
+
+        std::string timezone;
+        if (arguments.size() == 2)
+            timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);
+
+        return std::make_shared<DataTypeDateTime64>(target_scale, timezone);
     }
 
-    template <typename T>
-    static auto toDestValue(const T & v)
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
     {
-        return Int64{v};
+        const auto & src = arguments[0];
+        const auto & col = *src.column;
+
+        auto res_column = ColumnDecimal<DateTime64>::create(input_rows_count, target_scale);
+        auto & result_data = res_column->getData();
+
+        const auto & source_data = typeid_cast<const ColumnInt64 &>(col).getData();
+
+        for (size_t i = 0; i < input_rows_count; ++i)
+            result_data[i] = source_data[i];
+
+        return res_column;
     }
 };
 
diff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp
index 3110a204deb6..b4cf875adfbd 100644
--- a/src/Functions/FunctionsConversion.cpp
+++ b/src/Functions/FunctionsConversion.cpp
@@ -13,6 +13,7 @@ void registerFunctionsConversion(FunctionFactory & factory)
     factory.registerFunction<FunctionToUInt16>();
     factory.registerFunction<FunctionToUInt32>();
     factory.registerFunction<FunctionToUInt64>();
+    factory.registerFunction<FunctionToUInt128>();
     factory.registerFunction<FunctionToUInt256>();
     factory.registerFunction<FunctionToInt8>();
     factory.registerFunction<FunctionToInt16>();
@@ -50,6 +51,7 @@ void registerFunctionsConversion(FunctionFactory & factory)
     factory.registerFunction<FunctionToUInt16OrZero>();
     factory.registerFunction<FunctionToUInt32OrZero>();
     factory.registerFunction<FunctionToUInt64OrZero>();
+    factory.registerFunction<FunctionToUInt128OrZero>();
     factory.registerFunction<FunctionToUInt256OrZero>();
     factory.registerFunction<FunctionToInt8OrZero>();
     factory.registerFunction<FunctionToInt16OrZero>();
@@ -74,6 +76,7 @@ void registerFunctionsConversion(FunctionFactory & factory)
     factory.registerFunction<FunctionToUInt16OrNull>();
     factory.registerFunction<FunctionToUInt32OrNull>();
     factory.registerFunction<FunctionToUInt64OrNull>();
+    factory.registerFunction<FunctionToUInt128OrNull>();
     factory.registerFunction<FunctionToUInt256OrNull>();
     factory.registerFunction<FunctionToInt8OrNull>();
     factory.registerFunction<FunctionToInt16OrNull>();
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index 1cd308c774d3..8830107b170f 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -36,7 +36,6 @@
 #include <Columns/ColumnTuple.h>
 #include <Columns/ColumnMap.h>
 #include <Columns/ColumnsCommon.h>
-#include <Common/FieldVisitors.h>
 #include <Common/assert_cast.h>
 #include <Common/quoteString.h>
 #include <Core/AccurateComparison.h>
@@ -125,7 +124,7 @@ struct ConvertImpl
 
     template <typename Additions = void *>
     static ColumnPtr NO_SANITIZE_UNDEFINED execute(
-        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t /*input_rows_count*/,
+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type [[maybe_unused]], size_t input_rows_count,
         Additions additions [[maybe_unused]] = Additions())
     {
         const ColumnWithTypeAndName & named_from = arguments[0];
@@ -173,31 +172,19 @@ struct ConvertImpl
 
             const auto & vec_from = col_from->getData();
             auto & vec_to = col_to->getData();
-            size_t size = vec_from.size();
-            vec_to.resize(size);
+            vec_to.resize(input_rows_count);
 
             ColumnUInt8::MutablePtr col_null_map_to;
             ColumnUInt8::Container * vec_null_map_to [[maybe_unused]] = nullptr;
             if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)
             {
-                col_null_map_to = ColumnUInt8::create(size, false);
+                col_null_map_to = ColumnUInt8::create(input_rows_count, false);
                 vec_null_map_to = &col_null_map_to->getData();
             }
 
-            for (size_t i = 0; i < size; ++i)
+            for (size_t i = 0; i < input_rows_count; ++i)
             {
-                if constexpr ((is_big_int_v<FromFieldType> || is_big_int_v<ToFieldType>) &&
-                    (std::is_same_v<FromFieldType, UInt128> || std::is_same_v<ToFieldType, UInt128>))
-                {
-                    if constexpr (std::is_same_v<Additions, AccurateOrNullConvertStrategyAdditions>)
-                    {
-                        vec_to[i] = 0;
-                        (*vec_null_map_to)[i] = true;
-                    }
-                    else
-                        throw Exception("Unexpected UInt128 to big int conversion", ErrorCodes::NOT_IMPLEMENTED);
-                }
-                else if constexpr (std::is_same_v<FromDataType, DataTypeUUID> != std::is_same_v<ToDataType, DataTypeUUID>)
+                if constexpr (std::is_same_v<FromDataType, DataTypeUUID> != std::is_same_v<ToDataType, DataTypeUUID>)
                 {
                     throw Exception("Conversion between numeric types and UUID is not supported", ErrorCodes::NOT_IMPLEMENTED);
                 }
@@ -784,7 +771,7 @@ inline void parseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer & rb
 {
     UUID tmp;
     readUUIDText(tmp, rb);
-    x = tmp;
+    x = tmp.toUnderType();
 }
 
 
@@ -824,7 +811,7 @@ inline bool tryParseImpl<DataTypeUUID>(DataTypeUUID::FieldType & x, ReadBuffer &
     if (!tryReadUUIDText(tmp, rb))
         return false;
 
-    x = tmp;
+    x = tmp.toUnderType();
     return true;
 }
 
@@ -1454,7 +1441,7 @@ class FunctionConvert : public IFunction
     ColumnPtr executeInternal(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const
     {
         if (arguments.empty())
-            throw Exception{"Function " + getName() + " expects at least 1 arguments",
+            throw Exception{"Function " + getName() + " expects at least 1 argument",
                ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION};
 
         const IDataType * from_type = arguments[0].type.get();
@@ -1471,7 +1458,7 @@ class FunctionConvert : public IFunction
             {
                 if constexpr (std::is_same_v<RightDataType, DataTypeDateTime64>)
                 {
-                    // account for optional timezone argument
+                    /// Account for optional timezone argument.
                     if (arguments.size() != 2 && arguments.size() != 3)
                         throw Exception{"Function " + getName() + " expects 2 or 3 arguments for DataTypeDateTime64.",
                             ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION};
@@ -1958,6 +1945,7 @@ struct NameToUInt8 { static constexpr auto name = "toUInt8"; };
 struct NameToUInt16 { static constexpr auto name = "toUInt16"; };
 struct NameToUInt32 { static constexpr auto name = "toUInt32"; };
 struct NameToUInt64 { static constexpr auto name = "toUInt64"; };
+struct NameToUInt128 { static constexpr auto name = "toUInt128"; };
 struct NameToUInt256 { static constexpr auto name = "toUInt256"; };
 struct NameToInt8 { static constexpr auto name = "toInt8"; };
 struct NameToInt16 { static constexpr auto name = "toInt16"; };
@@ -1973,6 +1961,7 @@ using FunctionToUInt8 = FunctionConvert<DataTypeUInt8, NameToUInt8, ToNumberMono
 using FunctionToUInt16 = FunctionConvert<DataTypeUInt16, NameToUInt16, ToNumberMonotonicity<UInt16>>;
 using FunctionToUInt32 = FunctionConvert<DataTypeUInt32, NameToUInt32, ToNumberMonotonicity<UInt32>>;
 using FunctionToUInt64 = FunctionConvert<DataTypeUInt64, NameToUInt64, ToNumberMonotonicity<UInt64>>;
+using FunctionToUInt128 = FunctionConvert<DataTypeUInt128, NameToUInt128, ToNumberMonotonicity<UInt128>>;
 using FunctionToUInt256 = FunctionConvert<DataTypeUInt256, NameToUInt256, ToNumberMonotonicity<UInt256>>;
 using FunctionToInt8 = FunctionConvert<DataTypeInt8, NameToInt8, ToNumberMonotonicity<Int8>>;
 using FunctionToInt16 = FunctionConvert<DataTypeInt16, NameToInt16, ToNumberMonotonicity<Int16>>;
@@ -2001,6 +1990,7 @@ template <> struct FunctionTo<DataTypeUInt8> { using Type = FunctionToUInt8; };
 template <> struct FunctionTo<DataTypeUInt16> { using Type = FunctionToUInt16; };
 template <> struct FunctionTo<DataTypeUInt32> { using Type = FunctionToUInt32; };
 template <> struct FunctionTo<DataTypeUInt64> { using Type = FunctionToUInt64; };
+template <> struct FunctionTo<DataTypeUInt128> { using Type = FunctionToUInt128; };
 template <> struct FunctionTo<DataTypeUInt256> { using Type = FunctionToUInt256; };
 template <> struct FunctionTo<DataTypeInt8> { using Type = FunctionToInt8; };
 template <> struct FunctionTo<DataTypeInt16> { using Type = FunctionToInt16; };
@@ -2030,6 +2020,7 @@ struct NameToUInt8OrZero { static constexpr auto name = "toUInt8OrZero"; };
 struct NameToUInt16OrZero { static constexpr auto name = "toUInt16OrZero"; };
 struct NameToUInt32OrZero { static constexpr auto name = "toUInt32OrZero"; };
 struct NameToUInt64OrZero { static constexpr auto name = "toUInt64OrZero"; };
+struct NameToUInt128OrZero { static constexpr auto name = "toUInt128OrZero"; };
 struct NameToUInt256OrZero { static constexpr auto name = "toUInt256OrZero"; };
 struct NameToInt8OrZero { static constexpr auto name = "toInt8OrZero"; };
 struct NameToInt16OrZero { static constexpr auto name = "toInt16OrZero"; };
@@ -2052,6 +2043,7 @@ using FunctionToUInt8OrZero = FunctionConvertFromString<DataTypeUInt8, NameToUIn
 using FunctionToUInt16OrZero = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrZero, ConvertFromStringExceptionMode::Zero>;
 using FunctionToUInt32OrZero = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrZero, ConvertFromStringExceptionMode::Zero>;
 using FunctionToUInt64OrZero = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrZero, ConvertFromStringExceptionMode::Zero>;
+using FunctionToUInt128OrZero = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrZero, ConvertFromStringExceptionMode::Zero>;
 using FunctionToUInt256OrZero = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrZero, ConvertFromStringExceptionMode::Zero>;
 using FunctionToInt8OrZero = FunctionConvertFromString<DataTypeInt8, NameToInt8OrZero, ConvertFromStringExceptionMode::Zero>;
 using FunctionToInt16OrZero = FunctionConvertFromString<DataTypeInt16, NameToInt16OrZero, ConvertFromStringExceptionMode::Zero>;
@@ -2074,6 +2066,7 @@ struct NameToUInt8OrNull { static constexpr auto name = "toUInt8OrNull"; };
 struct NameToUInt16OrNull { static constexpr auto name = "toUInt16OrNull"; };
 struct NameToUInt32OrNull { static constexpr auto name = "toUInt32OrNull"; };
 struct NameToUInt64OrNull { static constexpr auto name = "toUInt64OrNull"; };
+struct NameToUInt128OrNull { static constexpr auto name = "toUInt128OrNull"; };
 struct NameToUInt256OrNull { static constexpr auto name = "toUInt256OrNull"; };
 struct NameToInt8OrNull { static constexpr auto name = "toInt8OrNull"; };
 struct NameToInt16OrNull { static constexpr auto name = "toInt16OrNull"; };
@@ -2096,6 +2089,7 @@ using FunctionToUInt8OrNull = FunctionConvertFromString<DataTypeUInt8, NameToUIn
 using FunctionToUInt16OrNull = FunctionConvertFromString<DataTypeUInt16, NameToUInt16OrNull, ConvertFromStringExceptionMode::Null>;
 using FunctionToUInt32OrNull = FunctionConvertFromString<DataTypeUInt32, NameToUInt32OrNull, ConvertFromStringExceptionMode::Null>;
 using FunctionToUInt64OrNull = FunctionConvertFromString<DataTypeUInt64, NameToUInt64OrNull, ConvertFromStringExceptionMode::Null>;
+using FunctionToUInt128OrNull = FunctionConvertFromString<DataTypeUInt128, NameToUInt128OrNull, ConvertFromStringExceptionMode::Null>;
 using FunctionToUInt256OrNull = FunctionConvertFromString<DataTypeUInt256, NameToUInt256OrNull, ConvertFromStringExceptionMode::Null>;
 using FunctionToInt8OrNull = FunctionConvertFromString<DataTypeInt8, NameToInt8OrNull, ConvertFromStringExceptionMode::Null>;
 using FunctionToInt16OrNull = FunctionConvertFromString<DataTypeInt16, NameToInt16OrNull, ConvertFromStringExceptionMode::Null>;
@@ -3043,6 +3037,7 @@ class FunctionCast final : public IFunctionBaseImpl
                 std::is_same_v<ToDataType, DataTypeUInt16> ||
                 std::is_same_v<ToDataType, DataTypeUInt32> ||
                 std::is_same_v<ToDataType, DataTypeUInt64> ||
+                std::is_same_v<ToDataType, DataTypeUInt128> ||
                 std::is_same_v<ToDataType, DataTypeUInt256> ||
                 std::is_same_v<ToDataType, DataTypeInt8> ||
                 std::is_same_v<ToDataType, DataTypeInt16> ||
@@ -3122,43 +3117,45 @@ class MonotonicityHelper
 
     static MonotonicityForRange getMonotonicityInformation(const DataTypePtr & from_type, const IDataType * to_type)
     {
-        if (const auto *const type = checkAndGetDataType<DataTypeUInt8>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeUInt8>(to_type))
+            return monotonicityForType(type);
+        if (const auto * type = checkAndGetDataType<DataTypeUInt16>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeUInt16>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeUInt32>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeUInt32>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeUInt64>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeUInt64>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeUInt128>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeUInt256>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeUInt256>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeInt8>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeInt8>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeInt16>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeInt16>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeInt32>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeInt32>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeInt64>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeInt64>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeInt128>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeInt128>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeInt256>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeInt256>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeFloat32>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeFloat32>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeFloat64>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeFloat64>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeDate>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeDate>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeDateTime>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeDateTime>(to_type))
             return monotonicityForType(type);
-        if (const auto *const type = checkAndGetDataType<DataTypeString>(to_type))
+        if (const auto * type = checkAndGetDataType<DataTypeString>(to_type))
             return monotonicityForType(type);
         if (isEnum(from_type))
         {
-            if (const auto *const type = checkAndGetDataType<DataTypeEnum8>(to_type))
+            if (const auto * type = checkAndGetDataType<DataTypeEnum8>(to_type))
                 return monotonicityForType(type);
-            if (const auto *const type = checkAndGetDataType<DataTypeEnum16>(to_type))
+            if (const auto * type = checkAndGetDataType<DataTypeEnum16>(to_type))
                 return monotonicityForType(type);
         }
         /// other types like Null, FixedString, Array and Tuple have no monotonicity defined
diff --git a/src/Functions/FunctionsEmbeddedDictionaries.h b/src/Functions/FunctionsEmbeddedDictionaries.h
index 7584a217a26e..82b6ebb021b2 100644
--- a/src/Functions/FunctionsEmbeddedDictionaries.h
+++ b/src/Functions/FunctionsEmbeddedDictionaries.h
@@ -165,14 +165,14 @@ class FunctionTransformWithDictionary : public IFunction
                 + toString(arguments.size()) + ", should be 1 or 2.",
                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
-        if (arguments[0]->getName() != TypeName<T>::get())
+        if (arguments[0]->getName() != TypeName<T>)
             throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName()
-                + " (must be " + String(TypeName<T>::get()) + ")",
+                + " (must be " + String(TypeName<T>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>::get())
+        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>)
             throw Exception("Illegal type " + arguments[1]->getName() + " of the second ('point of view') argument of function " + getName()
-                + " (must be " + String(TypeName<T>::get()) + ")",
+                + " (must be " + String(TypeName<T>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         return arguments[0];
@@ -259,19 +259,19 @@ class FunctionIsInWithDictionary : public IFunction
                 + toString(arguments.size()) + ", should be 2 or 3.",
                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
-        if (arguments[0]->getName() != TypeName<T>::get())
+        if (arguments[0]->getName() != TypeName<T>)
             throw Exception("Illegal type " + arguments[0]->getName() + " of first argument of function " + getName()
-                + " (must be " + String(TypeName<T>::get()) + ")",
+                + " (must be " + String(TypeName<T>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        if (arguments[1]->getName() != TypeName<T>::get())
+        if (arguments[1]->getName() != TypeName<T>)
             throw Exception("Illegal type " + arguments[1]->getName() + " of second argument of function " + getName()
-                + " (must be " + String(TypeName<T>::get()) + ")",
+                + " (must be " + String(TypeName<T>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        if (arguments.size() == 3 && arguments[2]->getName() != TypeName<String>::get())
+        if (arguments.size() == 3 && arguments[2]->getName() != TypeName<String>)
             throw Exception("Illegal type " + arguments[2]->getName() + " of the third ('point of view') argument of function " + getName()
-                + " (must be " + String(TypeName<String>::get()) + ")",
+                + " (must be " + String(TypeName<String>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         return std::make_shared<DataTypeUInt8>();
@@ -397,14 +397,14 @@ class FunctionHierarchyWithDictionary : public IFunction
                 + toString(arguments.size()) + ", should be 1 or 2.",
                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
-        if (arguments[0]->getName() != TypeName<T>::get())
+        if (arguments[0]->getName() != TypeName<T>)
             throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName()
-            + " (must be " + String(TypeName<T>::get()) + ")",
+            + " (must be " + String(TypeName<T>) + ")",
             ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>::get())
+        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>)
             throw Exception("Illegal type " + arguments[1]->getName() + " of the second ('point of view') argument of function " + getName()
-                + " (must be " + String(TypeName<String>::get()) + ")",
+                + " (must be " + String(TypeName<String>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         return std::make_shared<DataTypeArray>(arguments[0]);
@@ -602,14 +602,14 @@ class FunctionRegionToName : public IFunction
                 + toString(arguments.size()) + ", should be 1 or 2.",
                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
-        if (arguments[0]->getName() != TypeName<UInt32>::get())
+        if (arguments[0]->getName() != TypeName<UInt32>)
             throw Exception("Illegal type " + arguments[0]->getName() + " of the first argument of function " + getName()
-                + " (must be " + String(TypeName<UInt32>::get()) + ")",
+                + " (must be " + String(TypeName<UInt32>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>::get())
+        if (arguments.size() == 2 && arguments[1]->getName() != TypeName<String>)
             throw Exception("Illegal type " + arguments[0]->getName() + " of the second argument of function " + getName()
-                + " (must be " + String(TypeName<String>::get()) + ")",
+                + " (must be " + String(TypeName<String>) + ")",
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         return std::make_shared<DataTypeString>();
diff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h
index 94f8acbdf666..e664d0e035df 100644
--- a/src/Functions/FunctionsHashing.h
+++ b/src/Functions/FunctionsHashing.h
@@ -973,7 +973,7 @@ class FunctionAnyHash : public IFunction
         else if (which.isUInt16()) executeIntType<UInt16, first>(icolumn, vec_to);
         else if (which.isUInt32()) executeIntType<UInt32, first>(icolumn, vec_to);
         else if (which.isUInt64()) executeIntType<UInt64, first>(icolumn, vec_to);
-        else if (which.isUInt128() || which.isUUID()) executeBigIntType<UInt128, first>(icolumn, vec_to);
+        else if (which.isUInt128()) executeBigIntType<UInt128, first>(icolumn, vec_to);
         else if (which.isUInt256()) executeBigIntType<UInt256, first>(icolumn, vec_to);
         else if (which.isInt8()) executeIntType<Int8, first>(icolumn, vec_to);
         else if (which.isInt16()) executeIntType<Int16, first>(icolumn, vec_to);
@@ -981,6 +981,7 @@ class FunctionAnyHash : public IFunction
         else if (which.isInt64()) executeIntType<Int64, first>(icolumn, vec_to);
         else if (which.isInt128()) executeBigIntType<Int128, first>(icolumn, vec_to);
         else if (which.isInt256()) executeBigIntType<Int256, first>(icolumn, vec_to);
+        else if (which.isUUID()) executeBigIntType<UUID, first>(icolumn, vec_to);
         else if (which.isEnum8()) executeIntType<Int8, first>(icolumn, vec_to);
         else if (which.isEnum16()) executeIntType<Int16, first>(icolumn, vec_to);
         else if (which.isDate()) executeIntType<UInt16, first>(icolumn, vec_to);
diff --git a/src/Functions/FunctionsRound.h b/src/Functions/FunctionsRound.h
index 01074984ebf3..e62d9524675f 100644
--- a/src/Functions/FunctionsRound.h
+++ b/src/Functions/FunctionsRound.h
@@ -444,13 +444,7 @@ class DecimalRoundingImpl
         }
         else
         {
-            if constexpr (!is_big_int_v<NativeType>)
-                memcpy(out.data(), in.data(), in.size() * sizeof(T));
-            else
-            {
-                for (size_t i = 0; i < in.size(); i++)
-                    out[i] = in[i];
-            }
+            memcpy(out.data(), in.data(), in.size() * sizeof(T));
         }
     }
 };
@@ -511,7 +505,7 @@ class Dispatcher
 public:
     static ColumnPtr apply(const IColumn * column, Scale scale_arg)
     {
-        if constexpr (IsNumber<T>)
+        if constexpr (is_arithmetic_v<T>)
             return apply(checkAndGetColumn<ColumnVector<T>>(column), scale_arg);
         else if constexpr (IsDecimalNumber<T>)
             return apply(checkAndGetColumn<ColumnDecimal<T>>(column), scale_arg);
diff --git a/src/Functions/GCDLCMImpl.h b/src/Functions/GCDLCMImpl.h
index b83fe37abb67..f13a6dc3f95b 100644
--- a/src/Functions/GCDLCMImpl.h
+++ b/src/Functions/GCDLCMImpl.h
@@ -2,7 +2,7 @@
 
 #include <DataTypes/NumberTraits.h>
 #include <Common/Exception.h>
-#include <numeric>
+#include <common/extended_types.h>
 #include <limits>
 #include <type_traits>
 
@@ -16,12 +16,9 @@ namespace DB
 
 namespace ErrorCodes
 {
-    extern const int NOT_IMPLEMENTED;
     extern const int DECIMAL_OVERFLOW;
 }
 
-template <class T>
-inline constexpr bool is_gcd_lcm_implemeted = !is_big_int_v<T>;
 
 template <typename A, typename B, typename Impl, typename Name>
 struct GCDLCMImpl
@@ -30,15 +27,7 @@ struct GCDLCMImpl
     static const constexpr bool allow_fixed_string = false;
 
     template <typename Result = ResultType>
-    static inline std::enable_if_t<!is_gcd_lcm_implemeted<Result>, Result>
-    apply(A, B)
-    {
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "{} is not implemented for big integers", Name::name);
-    }
-
-    template <typename Result = ResultType>
-    static inline std::enable_if_t<is_gcd_lcm_implemeted<Result>, Result>
-    apply(A a, B b)
+    static inline Result apply(A a, B b)
     {
         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));
         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<B>::Type(b), typename NumberTraits::ToInteger<A>::Type(a));
@@ -50,7 +39,7 @@ struct GCDLCMImpl
             /// gcd() internally uses std::abs()
             Int a_s = static_cast<Int>(a);
             Int b_s = static_cast<Int>(b);
-            Int min = std::numeric_limits<Int>::min();
+            Int min = std::numeric_limits<Int>::lowest();
             Int max = std::numeric_limits<Int>::max();
             if (unlikely((a_s == min || a_s == max) || (b_s == min || b_s == max)))
                 throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Intermediate result overflow (signed a = {}, signed b = {}, min = {}, max = {})", a_s, b_s, min, max);
diff --git a/src/Functions/GatherUtils/Algorithms.h b/src/Functions/GatherUtils/Algorithms.h
index 1a962089d0c6..d17ab0820040 100644
--- a/src/Functions/GatherUtils/Algorithms.h
+++ b/src/Functions/GatherUtils/Algorithms.h
@@ -13,7 +13,6 @@ namespace DB::ErrorCodes
 {
     extern const int LOGICAL_ERROR;
     extern const int TOO_LARGE_ARRAY_SIZE;
-    extern const int NOT_IMPLEMENTED;
 }
 
 namespace DB::GatherUtils
@@ -45,11 +44,7 @@ void writeSlice(const NumericArraySlice<T> & slice, NumericArraySink<U> & sink)
 
         if constexpr (OverBigInt<T> || OverBigInt<U>)
         {
-            if constexpr (std::is_same_v<U, UInt128>)
-            {
-                throw Exception("No conversion between UInt128 and " + demangle(typeid(T).name()), ErrorCodes::NOT_IMPLEMENTED);
-            }
-            else if constexpr (IsDecimalNumber<T>)
+            if constexpr (IsDecimalNumber<T>)
                 dst = static_cast<NativeU>(src.value);
             else
                 dst = static_cast<NativeU>(src);
diff --git a/src/Functions/GatherUtils/ArraySinkVisitor.h b/src/Functions/GatherUtils/ArraySinkVisitor.h
index b146780924fd..7a53da258691 100644
--- a/src/Functions/GatherUtils/ArraySinkVisitor.h
+++ b/src/Functions/GatherUtils/ArraySinkVisitor.h
@@ -14,7 +14,7 @@ struct GenericArraySink;
 template <typename ArraySink>
 struct NullableArraySink;
 
-using NumericArraySinks = typename TypeListMap<NumericArraySink, TypeListNumbersAndUInt128>::Type;
+using NumericArraySinks = typename TypeListMap<NumericArraySink, TypeListNumbersAndUUID>::Type;
 using BasicArraySinks = typename AppendToTypeList<GenericArraySink, NumericArraySinks>::Type;
 using NullableArraySinks = typename TypeListMap<NullableArraySink, BasicArraySinks>::Type;
 using TypeListArraySinks = typename TypeListConcat<BasicArraySinks, NullableArraySinks>::Type;
diff --git a/src/Functions/GatherUtils/ArraySourceVisitor.h b/src/Functions/GatherUtils/ArraySourceVisitor.h
index 260e9a871616..1b92a9d2e815 100644
--- a/src/Functions/GatherUtils/ArraySourceVisitor.h
+++ b/src/Functions/GatherUtils/ArraySourceVisitor.h
@@ -17,7 +17,7 @@ struct NullableArraySource;
 template <typename Base>
 struct ConstSource;
 
-using NumericArraySources = typename TypeListMap<NumericArraySource, TypeListNumbersAndUInt128>::Type;
+using NumericArraySources = typename TypeListMap<NumericArraySource, TypeListNumbersAndUUID>::Type;
 using BasicArraySources = typename AppendToTypeList<GenericArraySource, NumericArraySources>::Type;
 
 class ArraySourceVisitor : public ApplyTypeListForClass<Visitor, BasicArraySources>::Type
diff --git a/src/Functions/GatherUtils/ValueSourceVisitor.h b/src/Functions/GatherUtils/ValueSourceVisitor.h
index 538ee156e5da..be503cdcfcf2 100644
--- a/src/Functions/GatherUtils/ValueSourceVisitor.h
+++ b/src/Functions/GatherUtils/ValueSourceVisitor.h
@@ -17,7 +17,7 @@ struct NullableValueSource;
 template <typename Base>
 struct ConstSource;
 
-using NumericValueSources = typename TypeListMap<NumericValueSource, TypeListNumbersAndUInt128>::Type;
+using NumericValueSources = typename TypeListMap<NumericValueSource, TypeListNumbersAndUUID>::Type;
 using BasicValueSources = typename AppendToTypeList<GenericValueSource, NumericValueSources>::Type;
 using NullableValueSources = typename TypeListMap<NullableValueSource, BasicValueSources>::Type;
 using BasicAndNullableValueSources = typename TypeListConcat<BasicValueSources, NullableValueSources>::Type;
diff --git a/src/Functions/GatherUtils/createArraySink.cpp b/src/Functions/GatherUtils/createArraySink.cpp
index 00b33cf98212..90983c9c25c6 100644
--- a/src/Functions/GatherUtils/createArraySink.cpp
+++ b/src/Functions/GatherUtils/createArraySink.cpp
@@ -55,7 +55,7 @@ struct ArraySinkCreator<>
 
 std::unique_ptr<IArraySink> createArraySink(ColumnArray & col, size_t column_size)
 {
-    using Creator = ApplyTypeListForClass<ArraySinkCreator, TypeListNumbersAndUInt128>::Type;
+    using Creator = ApplyTypeListForClass<ArraySinkCreator, TypeListNumbersAndUUID>::Type;
     return Creator::create(col.getData(), col.getOffsets(), column_size);
 }
 }
diff --git a/src/Functions/GatherUtils/createArraySource.cpp b/src/Functions/GatherUtils/createArraySource.cpp
index 0744e2f2ea31..d98a72e456f8 100644
--- a/src/Functions/GatherUtils/createArraySource.cpp
+++ b/src/Functions/GatherUtils/createArraySource.cpp
@@ -58,7 +58,7 @@ struct ArraySourceCreator<>
 
 std::unique_ptr<IArraySource> createArraySource(const ColumnArray & col, bool is_const, size_t total_rows)
 {
-    using Creator = typename ApplyTypeListForClass<ArraySourceCreator, TypeListNumbersAndUInt128>::Type;
+    using Creator = typename ApplyTypeListForClass<ArraySourceCreator, TypeListNumbersAndUUID>::Type;
     if (const auto * column_nullable = typeid_cast<const ColumnNullable *>(&col.getData()))
     {
         auto column = ColumnArray::create(column_nullable->getNestedColumnPtr(), col.getOffsetsPtr());
diff --git a/src/Functions/GatherUtils/createValueSource.cpp b/src/Functions/GatherUtils/createValueSource.cpp
index 201100662147..4f538b95369e 100644
--- a/src/Functions/GatherUtils/createValueSource.cpp
+++ b/src/Functions/GatherUtils/createValueSource.cpp
@@ -58,7 +58,7 @@ struct ValueSourceCreator<>
 
 std::unique_ptr<IValueSource> createValueSource(const IColumn & col, bool is_const, size_t total_rows)
 {
-    using Creator = typename ApplyTypeListForClass<ValueSourceCreator, TypeListNumbersAndUInt128>::Type;
+    using Creator = typename ApplyTypeListForClass<ValueSourceCreator, TypeListNumbersAndUUID>::Type;
     if (const auto * column_nullable = typeid_cast<const ColumnNullable *>(&col))
     {
         return Creator::create(column_nullable->getNestedColumn(), &column_nullable->getNullMapData(), is_const, total_rows);
diff --git a/src/Functions/GregorianDate.h b/src/Functions/GregorianDate.h
index 844fb180e5e3..5f179483b536 100644
--- a/src/Functions/GregorianDate.h
+++ b/src/Functions/GregorianDate.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <common/extended_types.h>
 #include <Common/Exception.h>
 #include <Core/Types.h>
 #include <IO/ReadBuffer.h>
@@ -9,6 +10,7 @@
 
 #include <cstdint>
 
+
 namespace DB
 {
     namespace ErrorCodes
@@ -27,8 +29,6 @@ namespace DB
     class GregorianDate
     {
     public:
-        GregorianDate() = delete;
-
         /** Construct from date in text form 'YYYY-MM-DD' by reading from
           * ReadBuffer.
           */
@@ -38,14 +38,14 @@ namespace DB
           * integral type which should be at least 32 bits wide, and
           * should preferably signed.
           */
-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>
+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>
         GregorianDate(T mjd);
 
         /** Convert to Modified Julian Day. The type T is an integral type
           * which should be at least 32 bits wide, and should preferably
           * signed.
           */
-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>
+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>
         T toModifiedJulianDay() const;
 
         /** Write the date in text form 'YYYY-MM-DD' to a buffer.
@@ -90,14 +90,14 @@ namespace DB
           * integral type which should be at least 32 bits wide, and
           * should preferably signed.
           */
-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>
+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>
         OrdinalDate(T mjd);
 
         /** Convert to Modified Julian Day. The type T is an integral
           * type which should be at least 32 bits wide, and should
           * preferably be signed.
           */
-        template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> * = nullptr>
+        template <typename T, std::enable_if_t<is_integer_v<T>> * = nullptr>
         T toModifiedJulianDay() const noexcept;
 
         YearT year() const noexcept
@@ -259,7 +259,7 @@ namespace DB
     }
 
     template <typename YearT>
-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>
+    template <typename T, std::enable_if_t<is_integer_v<T>> *>
     GregorianDate<YearT>::GregorianDate(T mjd)
     {
         const OrdinalDate<YearT> ord(mjd);
@@ -270,7 +270,7 @@ namespace DB
     }
 
     template <typename YearT>
-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>
+    template <typename T, std::enable_if_t<is_integer_v<T>> *>
     T GregorianDate<YearT>::toModifiedJulianDay() const
     {
         const MonthDay md(month_, day_of_month_);
@@ -332,7 +332,7 @@ namespace DB
     }
 
     template <typename YearT>
-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>
+    template <typename T, std::enable_if_t<is_integer_v<T>> *>
     OrdinalDate<YearT>::OrdinalDate(T mjd)
     {
         const auto a         = mjd + 678575;
@@ -348,7 +348,7 @@ namespace DB
     }
 
     template <typename YearT>
-    template <typename T, std::enable_if_t<wide::IntegralConcept<T>()> *>
+    template <typename T, std::enable_if_t<is_integer_v<T>> *>
     T OrdinalDate<YearT>::toModifiedJulianDay() const noexcept
     {
         const auto y = year_ - 1;
diff --git a/src/Functions/IFunction.cpp b/src/Functions/IFunction.cpp
index e65d07cf6ac8..c8a3bd22c3cc 100644
--- a/src/Functions/IFunction.cpp
+++ b/src/Functions/IFunction.cpp
@@ -64,8 +64,7 @@ class ExecutableFunctionLowCardinalityResultCache
         size_t operator()(const DictionaryKey & key) const
         {
             SipHash hash;
-            hash.update(key.hash.low);
-            hash.update(key.hash.high);
+            hash.update(key.hash);
             hash.update(key.size);
             return hash.get64();
         }
diff --git a/src/Functions/PolygonUtils.h b/src/Functions/PolygonUtils.h
index 27ee1d2a99fc..4226e3ae0b03 100644
--- a/src/Functions/PolygonUtils.h
+++ b/src/Functions/PolygonUtils.h
@@ -646,7 +646,7 @@ UInt128 sipHash128(Polygon && polygon)
         hash_ring(inner);
 
     UInt128 res;
-    hash.get128(res.low, res.high);
+    hash.get128(res);
     return res;
 }
 
diff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp
index 784beb9fc3a2..3d40dfe83eac 100644
--- a/src/Functions/array/arrayAggregation.cpp
+++ b/src/Functions/array/arrayAggregation.cpp
@@ -68,12 +68,13 @@ struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::sum>
 {
     using Result =
         std::conditional_t<std::is_same_v<ArrayElement, Int128>, Int128,
-            std::conditional_t<std::is_same_v<ArrayElement, Int256>, Int256,
-                std::conditional_t<std::is_same_v<ArrayElement, UInt256>, UInt256,
-                    std::conditional_t<IsDecimalNumber<ArrayElement>, Decimal128,
-                        std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,
-                            std::conditional_t<std::is_signed_v<ArrayElement>, Int64,
-                                UInt64>>>>>>;
+        std::conditional_t<std::is_same_v<ArrayElement, UInt128>, UInt128,
+        std::conditional_t<std::is_same_v<ArrayElement, Int256>, Int256,
+        std::conditional_t<std::is_same_v<ArrayElement, UInt256>, UInt256,
+        std::conditional_t<IsDecimalNumber<ArrayElement>, Decimal128,
+        std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,
+        std::conditional_t<std::is_signed_v<ArrayElement>, Int64,
+            UInt64>>>>>>>;
 };
 
 template <typename ArrayElement, AggregateOperation operation>
@@ -173,7 +174,7 @@ struct ArrayAggregateImpl
                 {
                     size_t array_size = offsets[i] - pos;
                     /// Just multiply the value by array size.
-                    res[i] = x * array_size;
+                    res[i] = x * ResultType(array_size);
                 }
                 else if constexpr (aggregate_operation == AggregateOperation::min ||
                                 aggregate_operation == AggregateOperation::max)
@@ -244,12 +245,15 @@ struct ArrayAggregateImpl
         size_t pos = 0;
         for (size_t i = 0; i < offsets.size(); ++i)
         {
-            AggregationType aggregate_value = 0;
+            AggregationType aggregate_value{};
 
             /// Array is empty
             if (offsets[i] == pos)
             {
-                res[i] = aggregate_value;
+                if constexpr (IsDecimalNumber<AggregationType>)
+                    res[i] = aggregate_value.value;
+                else
+                    res[i] = aggregate_value;
                 continue;
             }
 
@@ -304,7 +308,7 @@ struct ArrayAggregateImpl
             {
                 if constexpr (IsDecimalNumber<Element>)
                 {
-                    aggregate_value = aggregate_value / count;
+                    aggregate_value = aggregate_value / AggregationType(count);
                     res[i] = DecimalUtils::convertTo<ResultType>(aggregate_value, data.getScale());
                 }
                 else
@@ -340,6 +344,7 @@ struct ArrayAggregateImpl
             executeType<UInt16>(mapped, offsets, res) ||
             executeType<UInt32>(mapped, offsets, res) ||
             executeType<UInt64>(mapped, offsets, res) ||
+            executeType<UInt128>(mapped, offsets, res) ||
             executeType<UInt256>(mapped, offsets, res) ||
             executeType<Int8>(mapped, offsets, res) ||
             executeType<Int16>(mapped, offsets, res) ||
diff --git a/src/Functions/array/arrayCumSumNonNegative.cpp b/src/Functions/array/arrayCumSumNonNegative.cpp
index 2c7362a16057..288422c1c9c1 100644
--- a/src/Functions/array/arrayCumSumNonNegative.cpp
+++ b/src/Functions/array/arrayCumSumNonNegative.cpp
@@ -60,8 +60,8 @@ struct ArrayCumSumNonNegativeImpl
             for (; pos < offset; ++pos)
             {
                 accumulated += src_values[pos];
-                if (accumulated < 0)
-                    accumulated = 0;
+                if (accumulated < Dst{})
+                    accumulated = {};
                 res_values[pos] = accumulated;
             }
         }
diff --git a/src/Functions/array/arrayDifference.cpp b/src/Functions/array/arrayDifference.cpp
index 45ff117bfdf1..7d11c6e89c8b 100644
--- a/src/Functions/array/arrayDifference.cpp
+++ b/src/Functions/array/arrayDifference.cpp
@@ -58,7 +58,7 @@ struct ArrayDifferenceImpl
         {
             if (pos == begin)
             {
-                dst[pos] = 0;
+                dst[pos] = {};
                 prev = src[pos];
             }
             else
@@ -70,7 +70,10 @@ struct ArrayDifferenceImpl
                     using ResultNativeType = typename Result::NativeType;
 
                     ResultNativeType result_value;
-                    bool overflow = common::subOverflow(static_cast<ResultNativeType>(curr.value), static_cast<ResultNativeType>(prev), result_value);
+                    bool overflow = common::subOverflow(
+                        static_cast<ResultNativeType>(curr.value),
+                        static_cast<ResultNativeType>(prev.value),
+                        result_value);
                     if (overflow)
                         throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
 
diff --git a/src/Functions/array/arrayDistinct.cpp b/src/Functions/array/arrayDistinct.cpp
index cf73a577def0..c43047a0c564 100644
--- a/src/Functions/array/arrayDistinct.cpp
+++ b/src/Functions/array/arrayDistinct.cpp
@@ -270,7 +270,7 @@ void FunctionArrayDistinct::executeHashed(
             UInt128 hash;
             SipHash hash_function;
             src_data.updateHashWithValue(j, hash_function);
-            hash_function.get128(reinterpret_cast<char *>(&hash));
+            hash_function.get128(hash);
 
             if (!set.find(hash))
             {
diff --git a/src/Functions/array/arrayElement.cpp b/src/Functions/array/arrayElement.cpp
index 4254b00e4bcf..f49739d75cc4 100644
--- a/src/Functions/array/arrayElement.cpp
+++ b/src/Functions/array/arrayElement.cpp
@@ -876,7 +876,7 @@ bool FunctionArrayElement::matchKeyToIndexNumberConst(
     Field::dispatch([&](const auto & value)
     {
         using FieldType = std::decay_t<decltype(value)>;
-        if constexpr (is_integer_v<FieldType> && std::is_convertible_v<FieldType, DataType>)
+        if constexpr (std::is_same_v<FieldType, DataType> || (is_integer_v<FieldType> && std::is_convertible_v<FieldType, DataType>))
             index_as_integer = static_cast<DataType>(value);
     }, index);
 
@@ -914,14 +914,15 @@ bool FunctionArrayElement::matchKeyToIndex(
         || matchKeyToIndexNumber<UInt16>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<UInt32>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<UInt64>(data, offsets, arguments, matched_idxs)
+        || matchKeyToIndexNumber<UInt128>(data, offsets, arguments, matched_idxs)
+        || matchKeyToIndexNumber<UInt256>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<Int8>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<Int16>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<Int32>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<Int64>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<Int128>(data, offsets, arguments, matched_idxs)
-        || matchKeyToIndexNumber<UInt128>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexNumber<Int256>(data, offsets, arguments, matched_idxs)
-        || matchKeyToIndexNumber<UInt256>(data, offsets, arguments, matched_idxs)
+        || matchKeyToIndexNumber<UUID>(data, offsets, arguments, matched_idxs)
         || matchKeyToIndexString(data, offsets, arguments, matched_idxs);
 }
 
@@ -933,14 +934,15 @@ bool FunctionArrayElement::matchKeyToIndexConst(
         || matchKeyToIndexNumberConst<UInt16>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<UInt32>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<UInt64>(data, offsets, index, matched_idxs)
+        || matchKeyToIndexNumberConst<UInt128>(data, offsets, index, matched_idxs)
+        || matchKeyToIndexNumberConst<UInt256>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<Int8>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<Int16>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<Int32>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<Int64>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<Int128>(data, offsets, index, matched_idxs)
-        || matchKeyToIndexNumberConst<UInt128>(data, offsets, index, matched_idxs)
         || matchKeyToIndexNumberConst<Int256>(data, offsets, index, matched_idxs)
-        || matchKeyToIndexNumberConst<UInt256>(data, offsets, index, matched_idxs)
+        || matchKeyToIndexNumberConst<UUID>(data, offsets, index, matched_idxs)
         || matchKeyToIndexStringConst(data, offsets, index, matched_idxs);
 }
 
diff --git a/src/Functions/array/arrayEnumerateRanked.h b/src/Functions/array/arrayEnumerateRanked.h
index 2d13482b01ef..789c2c38e96f 100644
--- a/src/Functions/array/arrayEnumerateRanked.h
+++ b/src/Functions/array/arrayEnumerateRanked.h
@@ -142,7 +142,7 @@ static inline UInt128 ALWAYS_INLINE hash128depths(const std::vector<size_t> & in
         key_columns[j]->updateHashWithValue(indices[j], hash);
     }
 
-    hash.get128(key.low, key.high);
+    hash.get128(key);
 
     return key;
 }
diff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp
index 7275a1395c08..05bb4351c3ec 100644
--- a/src/Functions/array/arrayIntersect.cpp
+++ b/src/Functions/array/arrayIntersect.cpp
@@ -518,7 +518,9 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable
                     typename Map::mapped_type * value = nullptr;
 
                     if constexpr (is_numeric_column)
+                    {
                         value = &map[columns[arg_num]->getElement(i)];
+                    }
                     else if constexpr (std::is_same<ColumnType, ColumnString>::value || std::is_same<ColumnType, ColumnFixedString>::value)
                         value = &map[columns[arg_num]->getDataAt(i)];
                     else
diff --git a/src/Functions/array/mapOp.cpp b/src/Functions/array/mapOp.cpp
index 78b7ce2b1557..1a19ee41d2f1 100644
--- a/src/Functions/array/mapOp.cpp
+++ b/src/Functions/array/mapOp.cpp
@@ -30,15 +30,15 @@ struct TupArg
     const IColumn::Offsets & val_offsets;
     bool is_const;
 };
-using TupleMaps = std::vector<struct TupArg>;
+using TupleMaps = std::vector<TupArg>;
 
-namespace OpTypes
+enum class OpTypes
 {
-    extern const int ADD = 0;
-    extern const int SUBTRACT = 1;
-}
+    ADD = 0,
+    SUBTRACT = 1
+};
 
-template <int op_type>
+template <OpTypes op_type>
 class FunctionMapOp : public IFunction
 {
 public:
@@ -160,7 +160,7 @@ class FunctionMapOp : public IFunction
                     KeyType key;
                     if constexpr (is_str_key)
                     {
-                        // have to use Field structs to get strings
+                        // have to use Field to get strings
                         key = arg.key_column[offset + j].get<KeyType>();
                     }
                     else
@@ -209,7 +209,8 @@ class FunctionMapOp : public IFunction
     {
         const auto & promoted_type = (assert_cast<const DataTypeArray *>(res_type.getElements()[1].get()))->getNestedType();
 #define MATCH_EXECUTE(is_str) \
-        switch (promoted_type->getTypeId()) { \
+        switch (promoted_type->getTypeId()) \
+        { \
             case TypeIndex::Int64: return execute2<KeyType, is_str, Int64>(row_count, args, res_type); \
             case TypeIndex::UInt64: return execute2<KeyType, is_str, UInt64>(row_count, args, res_type); \
             case TypeIndex::Float64: return execute2<KeyType, is_str, Float64>(row_count, args, res_type); \
@@ -290,6 +291,10 @@ class FunctionMapOp : public IFunction
                 return execute1<Int32, false>(row_count, res_type, args);
             case TypeIndex::Int64:
                 return execute1<Int64, false>(row_count, res_type, args);
+            case TypeIndex::Int128:
+                return execute1<Int128, false>(row_count, res_type, args);
+            case TypeIndex::Int256:
+                return execute1<Int256, false>(row_count, res_type, args);
             case TypeIndex::UInt8:
                 return execute1<UInt8, false>(row_count, res_type, args);
             case TypeIndex::Date:
@@ -300,8 +305,12 @@ class FunctionMapOp : public IFunction
                 return execute1<UInt32, false>(row_count, res_type, args);
             case TypeIndex::UInt64:
                 return execute1<UInt64, false>(row_count, res_type, args);
-            case TypeIndex::UUID:
+            case TypeIndex::UInt128:
                 return execute1<UInt128, false>(row_count, res_type, args);
+            case TypeIndex::UInt256:
+                return execute1<UInt256, false>(row_count, res_type, args);
+            case TypeIndex::UUID:
+                return execute1<UUID, false>(row_count, res_type, args);
             case TypeIndex::FixedString:
             case TypeIndex::String:
                 return execute1<String, true>(row_count, res_type, args);
diff --git a/src/Functions/bar.cpp b/src/Functions/bar.cpp
index c2b5f93994ec..821cd8bcfab9 100644
--- a/src/Functions/bar.cpp
+++ b/src/Functions/bar.cpp
@@ -3,7 +3,6 @@
 #include <DataTypes/DataTypeString.h>
 #include <Columns/ColumnString.h>
 #include <Common/UnicodeBar.h>
-#include <Common/FieldVisitors.h>
 #include <IO/WriteHelpers.h>
 
 
diff --git a/src/Functions/fromUnixTimestamp64Micro.cpp b/src/Functions/fromUnixTimestamp64Micro.cpp
index a4bac327a3a0..6cc22b31758f 100644
--- a/src/Functions/fromUnixTimestamp64Micro.cpp
+++ b/src/Functions/fromUnixTimestamp64Micro.cpp
@@ -4,17 +4,11 @@
 namespace DB
 {
 
-struct TransformFromMicro
-{
-    static constexpr auto name = "fromUnixTimestamp64Micro";
-    static constexpr auto target_scale = 6;
-    using SourceDataType = DataTypeInt64;
-    using ResultDataType = DataTypeDateTime64;
-};
-
 void registerFromUnixTimestamp64Micro(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionUnixTimestamp64<TransformFromMicro>>();
+    factory.registerFunction("fromUnixTimestamp64Micro",
+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(
+            std::make_shared<FunctionFromUnixTimestamp64>(6, "fromUnixTimestamp64Micro")); });
 }
 
 }
diff --git a/src/Functions/fromUnixTimestamp64Milli.cpp b/src/Functions/fromUnixTimestamp64Milli.cpp
index a4ce79ecebbe..6973fb471762 100644
--- a/src/Functions/fromUnixTimestamp64Milli.cpp
+++ b/src/Functions/fromUnixTimestamp64Milli.cpp
@@ -4,17 +4,11 @@
 namespace DB
 {
 
-struct TransformFromMilli
-{
-    static constexpr auto name = "fromUnixTimestamp64Milli";
-    static constexpr auto target_scale = 3;
-    using SourceDataType = DataTypeInt64;
-    using ResultDataType = DataTypeDateTime64;
-};
-
 void registerFromUnixTimestamp64Milli(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionUnixTimestamp64<TransformFromMilli>>();
+    factory.registerFunction("fromUnixTimestamp64Milli",
+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(
+            std::make_shared<FunctionFromUnixTimestamp64>(3, "fromUnixTimestamp64Milli")); });
 }
 
 }
diff --git a/src/Functions/fromUnixTimestamp64Nano.cpp b/src/Functions/fromUnixTimestamp64Nano.cpp
index cd69aa56a2c0..50c4e4dc8d8d 100644
--- a/src/Functions/fromUnixTimestamp64Nano.cpp
+++ b/src/Functions/fromUnixTimestamp64Nano.cpp
@@ -4,17 +4,11 @@
 namespace DB
 {
 
-struct TransformFromNano
-{
-    static constexpr auto name = "fromUnixTimestamp64Nano";
-    static constexpr auto target_scale = 9;
-    using SourceDataType = DataTypeInt64;
-    using ResultDataType = DataTypeDateTime64;
-};
-
 void registerFromUnixTimestamp64Nano(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionUnixTimestamp64<TransformFromNano>>();
+    factory.registerFunction("fromUnixTimestamp64Nano",
+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(
+            std::make_shared<FunctionFromUnixTimestamp64>(9, "fromUnixTimestamp64Nano")); });
 }
 
 }
diff --git a/src/Functions/gcd.cpp b/src/Functions/gcd.cpp
index 52addfc66edf..f42f8f96cdb7 100644
--- a/src/Functions/gcd.cpp
+++ b/src/Functions/gcd.cpp
@@ -2,6 +2,8 @@
 #include <Functions/FunctionBinaryArithmetic.h>
 #include <Functions/GCDLCMImpl.h>
 
+#include <boost/integer/common_factor.hpp>
+
 
 namespace DB
 {
@@ -19,7 +21,7 @@ struct GCDImpl : public GCDLCMImpl<A, B, GCDImpl<A, B>, NameGCD>
     static ResultType applyImpl(A a, B b)
     {
         using Int = typename NumberTraits::ToInteger<ResultType>::Type;
-        return std::gcd(Int(a), Int(b));
+        return boost::integer::gcd(Int(a), Int(b));
     }
 };
 
diff --git a/src/Functions/generateUUIDv4.cpp b/src/Functions/generateUUIDv4.cpp
index a1e50e3c54fc..7ca127857df7 100644
--- a/src/Functions/generateUUIDv4.cpp
+++ b/src/Functions/generateUUIDv4.cpp
@@ -32,21 +32,22 @@ class FunctionGenerateUUIDv4 : public IFunction
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override
     {
-        auto col_res = ColumnVector<UInt128>::create();
-        typename ColumnVector<UInt128>::Container & vec_to = col_res->getData();
+        auto col_res = ColumnVector<UUID>::create();
+        typename ColumnVector<UUID>::Container & vec_to = col_res->getData();
 
         size_t size = input_rows_count;
         vec_to.resize(size);
 
         /// RandImpl is target-dependent and is not the same in different TargetSpecific namespaces.
-        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), vec_to.size() * sizeof(UInt128));
+        RandImpl::execute(reinterpret_cast<char *>(vec_to.data()), vec_to.size() * sizeof(UUID));
 
-        for (UInt128 & uuid: vec_to)
+        for (UUID & uuid : vec_to)
         {
-            /** https://tools.ietf.org/html/rfc4122#section-4.4
-             */
-            uuid.low = (uuid.low & 0xffffffffffff0fffull) | 0x0000000000004000ull;
-            uuid.high = (uuid.high & 0x3fffffffffffffffull) | 0x8000000000000000ull;
+            /// https://tools.ietf.org/html/rfc4122#section-4.4
+
+            UInt128 & impl = uuid.toUnderType();
+            impl.items[0] = (impl.items[0] & 0xffffffffffff0fffull) | 0x0000000000004000ull;
+            impl.items[1] = (impl.items[1] & 0x3fffffffffffffffull) | 0x8000000000000000ull;
         }
 
         return col_res;
diff --git a/src/Functions/if.cpp b/src/Functions/if.cpp
index a9b3a2245bd5..e1acd830dcb6 100644
--- a/src/Functions/if.cpp
+++ b/src/Functions/if.cpp
@@ -986,7 +986,7 @@ class FunctionIf : public FunctionIfBase
             right_id = right_array->getNestedType()->getTypeId();
 
         if (!(callOnBasicTypes<true, true, true, false>(left_id, right_id, call)
-            || (res = executeTyped<UInt128, UInt128>(cond_col, arguments, result_type, input_rows_count))
+            || (res = executeTyped<UUID, UUID>(cond_col, arguments, result_type, input_rows_count))
             || (res = executeString(cond_col, arguments, result_type))
             || (res = executeGenericArray(cond_col, arguments, result_type))
             || (res = executeTuple(arguments, result_type, input_rows_count))))
diff --git a/src/Functions/lcm.cpp b/src/Functions/lcm.cpp
index f46e11dfa172..672d47d06b90 100644
--- a/src/Functions/lcm.cpp
+++ b/src/Functions/lcm.cpp
@@ -2,6 +2,9 @@
 #include <Functions/FunctionBinaryArithmetic.h>
 #include <Functions/GCDLCMImpl.h>
 
+#include <boost/integer/common_factor.hpp>
+
+
 namespace
 {
 
@@ -46,7 +49,7 @@ struct LCMImpl : public GCDLCMImpl<A, B, LCMImpl<A, B>, NameLCM>
           * (example: throw an exception or overflow in implementation specific way).
           */
 
-        Unsigned val1 = abs<Int>(a) / std::gcd(Int(a), Int(b));
+        Unsigned val1 = abs<Int>(a) / boost::integer::gcd(Int(a), Int(b));
         Unsigned val2 = abs<Int>(b);
 
         /// Overflow in implementation specific way.
diff --git a/src/Functions/reinterpretAs.cpp b/src/Functions/reinterpretAs.cpp
index f8a7b8eec841..94c9eec58687 100644
--- a/src/Functions/reinterpretAs.cpp
+++ b/src/Functions/reinterpretAs.cpp
@@ -409,6 +409,7 @@ struct NameReinterpretAsUInt8       { static constexpr auto name = "reinterpretA
 struct NameReinterpretAsUInt16      { static constexpr auto name = "reinterpretAsUInt16"; };
 struct NameReinterpretAsUInt32      { static constexpr auto name = "reinterpretAsUInt32"; };
 struct NameReinterpretAsUInt64      { static constexpr auto name = "reinterpretAsUInt64"; };
+struct NameReinterpretAsUInt128     { static constexpr auto name = "reinterpretAsUInt128"; };
 struct NameReinterpretAsUInt256     { static constexpr auto name = "reinterpretAsUInt256"; };
 struct NameReinterpretAsInt8        { static constexpr auto name = "reinterpretAsInt8"; };
 struct NameReinterpretAsInt16       { static constexpr auto name = "reinterpretAsInt16"; };
@@ -428,6 +429,7 @@ using FunctionReinterpretAsUInt8 = FunctionReinterpretAs<DataTypeUInt8, NameRein
 using FunctionReinterpretAsUInt16 = FunctionReinterpretAs<DataTypeUInt16, NameReinterpretAsUInt16>;
 using FunctionReinterpretAsUInt32 = FunctionReinterpretAs<DataTypeUInt32, NameReinterpretAsUInt32>;
 using FunctionReinterpretAsUInt64 = FunctionReinterpretAs<DataTypeUInt64, NameReinterpretAsUInt64>;
+using FunctionReinterpretAsUInt128 = FunctionReinterpretAs<DataTypeUInt128, NameReinterpretAsUInt128>;
 using FunctionReinterpretAsUInt256 = FunctionReinterpretAs<DataTypeUInt256, NameReinterpretAsUInt256>;
 using FunctionReinterpretAsInt8 = FunctionReinterpretAs<DataTypeInt8, NameReinterpretAsInt8>;
 using FunctionReinterpretAsInt16 = FunctionReinterpretAs<DataTypeInt16, NameReinterpretAsInt16>;
@@ -453,6 +455,7 @@ void registerFunctionsReinterpretAs(FunctionFactory & factory)
     factory.registerFunction<FunctionReinterpretAsUInt16>();
     factory.registerFunction<FunctionReinterpretAsUInt32>();
     factory.registerFunction<FunctionReinterpretAsUInt64>();
+    factory.registerFunction<FunctionReinterpretAsUInt128>();
     factory.registerFunction<FunctionReinterpretAsUInt256>();
     factory.registerFunction<FunctionReinterpretAsInt8>();
     factory.registerFunction<FunctionReinterpretAsInt16>();
diff --git a/src/Functions/roundToExp2.cpp b/src/Functions/roundToExp2.cpp
index 50a548e095ed..2abe94b2b263 100644
--- a/src/Functions/roundToExp2.cpp
+++ b/src/Functions/roundToExp2.cpp
@@ -27,18 +27,6 @@ roundDownToPowerOfTwo(T x)
     return x <= 0 ? 0 : (T(1) << (63 - __builtin_clzll(x)));
 }
 
-template <typename T>
-inline std::enable_if_t<std::is_same_v<T, Int128>, T>
-roundDownToPowerOfTwo(T x)
-{
-    if (x <= 0)
-        return 0;
-
-    if (Int64 x64 = Int64(x >> 64))
-        return Int128(roundDownToPowerOfTwo(x64)) << 64;
-    return roundDownToPowerOfTwo(Int64(x));
-}
-
 template <typename T>
 inline std::enable_if_t<std::is_same_v<T, Float32>, T>
 roundDownToPowerOfTwo(T x)
diff --git a/src/Functions/sign.cpp b/src/Functions/sign.cpp
index 3c03f4e1f2ef..8e2964c18597 100644
--- a/src/Functions/sign.cpp
+++ b/src/Functions/sign.cpp
@@ -1,7 +1,7 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionUnaryArithmetic.h>
 #include <DataTypes/NumberTraits.h>
-#include <Common/FieldVisitors.h>
+
 
 namespace DB
 {
diff --git a/src/Functions/toUnixTimestamp64Micro.cpp b/src/Functions/toUnixTimestamp64Micro.cpp
index e1a9382e69af..f91f04dc519b 100644
--- a/src/Functions/toUnixTimestamp64Micro.cpp
+++ b/src/Functions/toUnixTimestamp64Micro.cpp
@@ -3,22 +3,12 @@
 
 namespace DB
 {
-namespace
-{
-
-struct TransformToMicro
-{
-    static constexpr auto name = "toUnixTimestamp64Micro";
-    static constexpr auto target_scale = 6;
-    using SourceDataType = DataTypeDateTime64;
-    using ResultDataType = DataTypeInt64;
-};
-
-}
 
 void registerToUnixTimestamp64Micro(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionUnixTimestamp64<TransformToMicro>>();
+    factory.registerFunction("toUnixTimestamp64Micro",
+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(
+            std::make_shared<FunctionToUnixTimestamp64>(6, "toUnixTimestamp64Micro")); });
 }
 
 }
diff --git a/src/Functions/toUnixTimestamp64Milli.cpp b/src/Functions/toUnixTimestamp64Milli.cpp
index b49b1c9042b3..857ce973c563 100644
--- a/src/Functions/toUnixTimestamp64Milli.cpp
+++ b/src/Functions/toUnixTimestamp64Milli.cpp
@@ -3,22 +3,12 @@
 
 namespace DB
 {
-namespace
-{
-
-struct TransformToMilli
-{
-    static constexpr auto name = "toUnixTimestamp64Milli";
-    static constexpr auto target_scale = 3;
-    using SourceDataType = DataTypeDateTime64;
-    using ResultDataType = DataTypeInt64;
-};
-
-}
 
 void registerToUnixTimestamp64Milli(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionUnixTimestamp64<TransformToMilli>>();
+    factory.registerFunction("toUnixTimestamp64Milli",
+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(
+            std::make_shared<FunctionToUnixTimestamp64>(3, "toUnixTimestamp64Milli")); });
 }
 
 }
diff --git a/src/Functions/toUnixTimestamp64Nano.cpp b/src/Functions/toUnixTimestamp64Nano.cpp
index 832d845434cd..7f065568f9f4 100644
--- a/src/Functions/toUnixTimestamp64Nano.cpp
+++ b/src/Functions/toUnixTimestamp64Nano.cpp
@@ -3,22 +3,12 @@
 
 namespace DB
 {
-namespace
-{
-
-struct TransformToNano
-{
-    static constexpr auto name = "toUnixTimestamp64Nano";
-    static constexpr auto target_scale = 9;
-    using SourceDataType = DataTypeDateTime64;
-    using ResultDataType = DataTypeInt64;
-};
-
-}
 
 void registerToUnixTimestamp64Nano(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionUnixTimestamp64<TransformToNano>>();
+    factory.registerFunction("toUnixTimestamp64Nano",
+        [](ContextPtr){ return std::make_unique<DefaultOverloadResolver>(
+            std::make_shared<FunctionToUnixTimestamp64>(9, "toUnixTimestamp64Nano")); });
 }
 
 }
diff --git a/src/IO/MMappedFileCache.h b/src/IO/MMappedFileCache.h
index cbd1977350b8..adbb85a18cf7 100644
--- a/src/IO/MMappedFileCache.h
+++ b/src/IO/MMappedFileCache.h
@@ -1,8 +1,9 @@
 #pragma once
 
+#include <Core/Types.h>
+#include <Common/HashTable/Hash.h>
 #include <Common/LRUCache.h>
 #include <Common/SipHash.h>
-#include <Common/UInt128.h>
 #include <Common/ProfileEvents.h>
 #include <IO/MMappedFile.h>
 
@@ -39,8 +40,7 @@ class MMappedFileCache : public LRUCache<UInt128, MMappedFile, UInt128TrivialHas
         hash.update(offset);
         hash.update(length);
 
-        hash.get128(key.low, key.high);
-
+        hash.get128(key);
         return key;
     }
 
diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp
index 72ffd74a42d6..8e9a14a20fb6 100644
--- a/src/IO/ReadHelpers.cpp
+++ b/src/IO/ReadHelpers.cpp
@@ -81,11 +81,6 @@ void parseUUIDWithoutSeparator(const UInt8 * src36, std::reverse_iterator<UInt8
     parseHex(&src36[16], dst16, 8);
 }
 
-UInt128 stringToUUID(const String & str)
-{
-    return parseFromString<UUID>(str);
-}
-
 void NO_INLINE throwAtAssertionFailed(const char * s, ReadBuffer & buf)
 {
     WriteBufferFromOwnString out;
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index cf25b819e6c0..9003ec2d9ed0 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -21,7 +21,6 @@
 #include <Common/Exception.h>
 #include <Common/StringUtils/StringUtils.h>
 #include <Common/Arena.h>
-#include <Common/UInt128.h>
 #include <Common/intExp.h>
 
 #include <Formats/FormatSettings.h>
@@ -51,7 +50,6 @@ namespace ErrorCodes
     extern const int CANNOT_PARSE_UUID;
     extern const int CANNOT_READ_ARRAY_FROM_TEXT;
     extern const int CANNOT_PARSE_NUMBER;
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
     extern const int INCORRECT_DATA;
 }
 
@@ -257,13 +255,12 @@ enum class ReadIntTextCheckOverflow
 template <typename T, typename ReturnType = void, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW>
 ReturnType readIntTextImpl(T & x, ReadBuffer & buf)
 {
-    /// TODO: disabled for big ints cause of 127 vs 128 bit conversion
-    using UnsignedT = std::conditional_t<is_big_int_v<T>, T, make_unsigned_t<T>>;
+    using UnsignedT = make_unsigned_t<T>;
 
     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;
 
     bool negative = false;
-    UnsignedT res = 0;
+    UnsignedT res{};
     if (buf.eof())
     {
         if constexpr (throw_exception)
@@ -305,7 +302,7 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)
             case '8': [[fallthrough]];
             case '9':
             {
-                if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW)
+                if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW && !is_big_int_v<T>)
                 {
                     /// Perform relativelly slow overflow check only when
                     /// number of decimal digits so far is close to the max for given type.
@@ -318,12 +315,8 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)
                             || common::addOverflow<T>(signed_res, (*buf.position() - '0'), signed_res))
                             return ReturnType(false);
 
-                        /// Cannot assign signed to unsigned for big ints. Ignore fast path.
-                        if constexpr (!is_big_int_v<T>)
-                        {
-                            res = signed_res;
-                            break;
-                        }
+                        res = signed_res;
+                        break;
                     }
                 }
                 res *= 10;
@@ -535,9 +528,6 @@ void parseUUIDWithoutSeparator(const UInt8 * src36, UInt8 * dst16);
 void parseUUID(const UInt8 * src36, std::reverse_iterator<UInt8 *> dst16);
 void parseUUIDWithoutSeparator(const UInt8 * src36, std::reverse_iterator<UInt8 *> dst16);
 
-template <typename IteratorSrc, typename IteratorDst>
-void formatHex(IteratorSrc src, IteratorDst dst, size_t num_bytes);
-
 
 template <typename ReturnType>
 ReturnType readDateTextFallback(LocalDate & date, ReadBuffer & buf);
@@ -686,13 +676,6 @@ inline T parseFromString(const std::string_view & str)
     return parse<T>(str.data(), str.size());
 }
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wredundant-decls"
-// Just dont mess with it. If the redundant redeclaration is removed then ReaderHelpers.h should be included.
-// This leads to Arena.h inclusion which has a problem with ASAN stuff included properly and messing macro definition
-// which intefrers with... You dont want to know, really.
-UInt128 stringToUUID(const String & str);
-#pragma GCC diagnostic pop
 
 template <typename ReturnType = void>
 ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const DateLUTImpl & date_lut);
@@ -839,16 +822,15 @@ readBinary(T & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 
 inline void readBinary(String & x, ReadBuffer & buf) { readStringBinary(x, buf); }
 inline void readBinary(Int128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
+inline void readBinary(Int256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 inline void readBinary(UInt128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
-inline void readBinary(DummyUInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
+inline void readBinary(UInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 inline void readBinary(Decimal32 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 inline void readBinary(Decimal64 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 inline void readBinary(Decimal128 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 inline void readBinary(Decimal256 & x, ReadBuffer & buf) { readPODBinary(x.value, buf); }
 inline void readBinary(LocalDate & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 
-inline void readBinary(UInt256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
-inline void readBinary(Int256 & x, ReadBuffer & buf) { readPODBinary(x, buf); }
 
 template <typename T>
 inline std::enable_if_t<is_arithmetic_v<T> && (sizeof(T) <= 8), void>
@@ -889,13 +871,6 @@ inline void readText(String & x, ReadBuffer & buf) { readEscapedString(x, buf);
 inline void readText(LocalDate & x, ReadBuffer & buf) { readDateText(x, buf); }
 inline void readText(LocalDateTime & x, ReadBuffer & buf) { readDateTimeText(x, buf); }
 inline void readText(UUID & x, ReadBuffer & buf) { readUUIDText(x, buf); }
-[[noreturn]] inline void readText(UInt128 &, ReadBuffer &)
-{
-    /** Because UInt128 isn't a natural type, without arithmetic operator and only use as an intermediary type -for UUID-
-     *  it should never arrive here. But because we used the DataTypeNumber class we should have at least a definition of it.
-     */
-    throw Exception("UInt128 cannot be read as a text", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-}
 
 /// Generic methods to read value in text format,
 ///  possibly in single quotes (only for data types that use quotes in VALUES format of INSERT statement in SQL).
@@ -975,13 +950,8 @@ inline void readCSV(String & x, ReadBuffer & buf, const FormatSettings::CSV & se
 inline void readCSV(LocalDate & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(LocalDateTime & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(UUID & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
-[[noreturn]] inline void readCSV(UInt128 &, ReadBuffer &)
-{
-    /** Because UInt128 isn't a natural type, without arithmetic operator and only use as an intermediary type -for UUID-
-     *  it should never arrive here. But because we used the DataTypeNumber class we should have at least a definition of it.
-     */
-    throw Exception("UInt128 cannot be read as a text", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-}
+inline void readCSV(UInt128 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
+inline void readCSV(Int128 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(UInt256 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(Int256 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 
diff --git a/src/IO/UncompressedCache.h b/src/IO/UncompressedCache.h
index b2f62ef2ada6..5826b7f020a0 100644
--- a/src/IO/UncompressedCache.h
+++ b/src/IO/UncompressedCache.h
@@ -2,8 +2,8 @@
 
 #include <Common/LRUCache.h>
 #include <Common/SipHash.h>
-#include <Common/UInt128.h>
 #include <Common/ProfileEvents.h>
+#include <Common/HashTable/Hash.h>
 #include <IO/BufferWithOwnMemory.h>
 
 
@@ -53,7 +53,7 @@ class UncompressedCache : public LRUCache<UInt128, UncompressedCacheCell, UInt12
         SipHash hash;
         hash.update(path_to_file.data(), path_to_file.size() + 1);
         hash.update(offset);
-        hash.get128(key.low, key.high);
+        hash.get128(key);
 
         return key;
     }
diff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h
index 0f8b5adee1af..3a79951e144a 100644
--- a/src/IO/WriteHelpers.h
+++ b/src/IO/WriteHelpers.h
@@ -6,12 +6,14 @@
 #include <algorithm>
 #include <iterator>
 
+#include <pcg-random/pcg_random.hpp>
+
 #include <common/DateLUT.h>
 #include <common/LocalDate.h>
 #include <common/LocalDateTime.h>
 #include <common/find_symbols.h>
 #include <common/StringRef.h>
-#include <common/wide_integer_to_string.h>
+#include <common/DecomposedFloat.h>
 
 #include <Core/DecimalFunctions.h>
 #include <Core/Types.h>
@@ -19,7 +21,6 @@
 
 #include <Common/Exception.h>
 #include <Common/StringUtils/StringUtils.h>
-#include <Common/UInt128.h>
 #include <Common/NaNUtils.h>
 
 #include <IO/CompressionMethod.h>
@@ -48,14 +49,8 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER;
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
-template <typename T>
-inline std::string bigintToString(const T & x)
-{
-    return to_string(x);
-}
 
 /// Helper functions for formatted and binary output.
 
@@ -137,81 +132,6 @@ inline void writeBoolText(bool x, WriteBuffer & buf)
 }
 
 
-struct DecomposedFloat64
-{
-    DecomposedFloat64(double x)
-    {
-        memcpy(&x_uint, &x, sizeof(x));
-    }
-
-    uint64_t x_uint;
-
-    bool sign() const
-    {
-        return x_uint >> 63;
-    }
-
-    uint16_t exponent() const
-    {
-        return (x_uint >> 52) & 0x7FF;
-    }
-
-    int16_t normalized_exponent() const
-    {
-        return int16_t(exponent()) - 1023;
-    }
-
-    uint64_t mantissa() const
-    {
-        return x_uint & 0x5affffffffffffful;
-    }
-
-    /// NOTE Probably floating point instructions can be better.
-    bool is_inside_int64() const
-    {
-        return x_uint == 0
-            || (normalized_exponent() >= 0 && normalized_exponent() <= 52
-                && ((mantissa() & ((1ULL << (52 - normalized_exponent())) - 1)) == 0));
-    }
-};
-
-struct DecomposedFloat32
-{
-    DecomposedFloat32(float x)
-    {
-        memcpy(&x_uint, &x, sizeof(x));
-    }
-
-    uint32_t x_uint;
-
-    bool sign() const
-    {
-        return x_uint >> 31;
-    }
-
-    uint16_t exponent() const
-    {
-        return (x_uint >> 23) & 0xFF;
-    }
-
-    int16_t normalized_exponent() const
-    {
-        return int16_t(exponent()) - 127;
-    }
-
-    uint32_t mantissa() const
-    {
-        return x_uint & 0x7fffff;
-    }
-
-    bool is_inside_int32() const
-    {
-        return x_uint == 0
-            || (normalized_exponent() >= 0 && normalized_exponent() <= 23
-                && ((mantissa() & ((1ULL << (23 - normalized_exponent())) - 1)) == 0));
-    }
-};
-
 template <typename T>
 inline size_t writeFloatTextFastPath(T x, char * buffer)
 {
@@ -222,14 +142,14 @@ inline size_t writeFloatTextFastPath(T x, char * buffer)
         /// The library Ryu has low performance on integers.
         /// This workaround improves performance 6..10 times.
 
-        if (DecomposedFloat64(x).is_inside_int64())
+        if (DecomposedFloat64(x).is_integer_in_representable_range())
             result = itoa(Int64(x), buffer) - buffer;
         else
             result = jkj::dragonbox::to_chars_n(x, buffer) - buffer;
     }
     else
     {
-        if (DecomposedFloat32(x).is_inside_int32())
+        if (DecomposedFloat32(x).is_integer_in_representable_range())
             result = itoa(Int32(x), buffer) - buffer;
         else
             result = jkj::dragonbox::to_chars_n(x, buffer) - buffer;
@@ -742,13 +662,12 @@ void formatUUID(std::reverse_iterator<const UInt8 *> src16, UInt8 * dst36);
 inline void writeUUIDText(const UUID & uuid, WriteBuffer & buf)
 {
     char s[36];
-
     formatUUID(std::reverse_iterator<const UInt8 *>(reinterpret_cast<const UInt8 *>(&uuid) + 16), reinterpret_cast<UInt8 *>(s));
     buf.write(s, sizeof(s));
 }
 
-template<typename DecimalType>
-inline void writeDecimalTypeFractionalText(typename DecimalType::NativeType fractional, UInt32 scale, WriteBuffer & buf)
+template <typename DecimalType>
+inline void writeDateTime64FractionalText(typename DecimalType::NativeType fractional, UInt32 scale, WriteBuffer & buf)
 {
     static constexpr UInt32 MaxScale = DecimalUtils::max_precision<DecimalType>;
 
@@ -878,7 +797,7 @@ inline void writeDateTimeText(DateTime64 datetime64, UInt32 scale, WriteBuffer &
     if (scale > 0)
     {
         buf.write(fractional_time_delimiter);
-        writeDecimalTypeFractionalText<DateTime64>(components.fractional, scale, buf);
+        writeDateTime64FractionalText<DateTime64>(components.fractional, scale, buf);
     }
 }
 
@@ -931,7 +850,7 @@ inline void writeDateTimeUnixTimestamp(DateTime64 datetime64, UInt32 scale, Writ
     if (scale > 0) //-V547
     {
         buf.write('.');
-        writeDecimalTypeFractionalText<DateTime64>(components.fractional, scale, buf);
+        writeDateTime64FractionalText<DateTime64>(components.fractional, scale, buf);
     }
 }
 
@@ -943,23 +862,17 @@ writeBinary(const T & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const String & x, WriteBuffer & buf) { writeStringBinary(x, buf); }
 inline void writeBinary(const StringRef & x, WriteBuffer & buf) { writeStringBinary(x, buf); }
 inline void writeBinary(const std::string_view & x, WriteBuffer & buf) { writeStringBinary(x, buf); }
-inline void writeBinary(const Int128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
-inline void writeBinary(const UInt128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
-inline void writeBinary(const UUID & x, WriteBuffer & buf) { writePODBinary(x, buf); }
-inline void writeBinary(const DummyUInt256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const Decimal32 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const Decimal64 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const Decimal128 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const Decimal256 & x, WriteBuffer & buf) { writePODBinary(x.value, buf); }
 inline void writeBinary(const LocalDate & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const LocalDateTime & x, WriteBuffer & buf) { writePODBinary(x, buf); }
-
-inline void writeBinary(const UInt256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
-inline void writeBinary(const Int256 & x, WriteBuffer & buf) { writePODBinary(x, buf); }
+inline void writeBinary(const UUID & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 
 /// Methods for outputting the value in text form for a tab-separated format.
 template <typename T>
-inline std::enable_if_t<is_integer_v<T> && !is_big_int_v<T>, void>
+inline std::enable_if_t<is_integer_v<T>, void>
 writeText(const T & x, WriteBuffer & buf) { writeIntText(x, buf); }
 
 template <typename T>
@@ -980,23 +893,18 @@ inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(Local
 inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }
 inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }
 inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }
-inline void writeText(const UInt128 & x, WriteBuffer & buf) { writeText(UUID(x), buf); }
-inline void writeText(const UInt256 & x, WriteBuffer & buf) { writeText(bigintToString(x), buf); }
-inline void writeText(const Int256 & x, WriteBuffer & buf) { writeText(bigintToString(x), buf); }
 
 template <typename T>
 String decimalFractional(const T & x, UInt32 scale)
 {
     if constexpr (std::is_same_v<T, Int256>)
     {
-        static constexpr Int128 max_int128 = (Int128(0x7fffffffffffffffll) << 64) + 0xffffffffffffffffll;
-
         if (x <= std::numeric_limits<UInt32>::max())
             return decimalFractional(static_cast<UInt32>(x), scale);
         else if (x <= std::numeric_limits<UInt64>::max())
             return decimalFractional(static_cast<UInt64>(x), scale);
-        else if (x <= max_int128)
-            return decimalFractional(static_cast<Int128>(x), scale);
+        else if (x <= std::numeric_limits<UInt128>::max())
+            return decimalFractional(static_cast<UInt128>(x), scale);
     }
     else if constexpr (std::is_same_v<T, Int128>)
     {
@@ -1023,10 +931,7 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr)
         writeChar('-', ostr); /// avoid crop leading minus when whole part is zero
     }
 
-    if constexpr (std::is_same_v<T, Int256>)
-        writeText(part, ostr);
-    else
-        writeIntText(part, ostr);
+    writeIntText(part, ostr);
 
     if (scale)
     {
@@ -1069,19 +974,6 @@ inline void writeQuoted(const UUID & x, WriteBuffer & buf)
     writeChar('\'', buf);
 }
 
-inline void writeQuoted(const UInt256 & x, WriteBuffer & buf)
-{
-    writeChar('\'', buf);
-    writeText(x, buf);
-    writeChar('\'', buf);
-}
-
-inline void writeQuoted(const Int256 & x, WriteBuffer & buf)
-{
-    writeChar('\'', buf);
-    writeText(x, buf);
-    writeChar('\'', buf);
-}
 
 /// String, date, datetime are in double quotes with C-style escaping. Numbers - without.
 template <typename T>
@@ -1125,13 +1017,6 @@ inline void writeCSV(const String & x, WriteBuffer & buf) { writeCSVString<>(x,
 inline void writeCSV(const LocalDate & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }
 inline void writeCSV(const LocalDateTime & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }
 inline void writeCSV(const UUID & x, WriteBuffer & buf) { writeDoubleQuoted(x, buf); }
-[[noreturn]] inline void writeCSV(const UInt128, WriteBuffer &)
-{
-    /** Because UInt128 isn't a natural type, without arithmetic operator and only use as an intermediary type -for UUID-
-     *  it should never arrive here. But because we used the DataTypeNumber class we should have at least a definition of it.
-     */
-    throw Exception("UInt128 cannot be write as a text", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-}
 
 template <typename T>
 void writeBinary(const std::vector<T> & x, WriteBuffer & buf)
diff --git a/src/IO/WriteIntText.h b/src/IO/WriteIntText.h
index 93444e7df730..456aed350fcb 100644
--- a/src/IO/WriteIntText.h
+++ b/src/IO/WriteIntText.h
@@ -4,8 +4,24 @@
 #include <IO/WriteBuffer.h>
 #include <common/itoa.h>
 
-/// 40 digits or 39 digits and a sign
-#define WRITE_HELPERS_MAX_INT_WIDTH 40U
+
+namespace
+{
+    template <typename T> constexpr size_t max_int_width = 20;
+    template <> inline constexpr size_t max_int_width<UInt8> = 3;    /// 255
+    template <> inline constexpr size_t max_int_width<Int8> = 4;     /// -128
+    template <> inline constexpr size_t max_int_width<UInt16> = 5;   /// 65535
+    template <> inline constexpr size_t max_int_width<Int16> = 6;    /// -32768
+    template <> inline constexpr size_t max_int_width<UInt32> = 10;  /// 4294967295
+    template <> inline constexpr size_t max_int_width<Int32> = 11;   /// -2147483648
+    template <> inline constexpr size_t max_int_width<UInt64> = 20;  /// 18446744073709551615
+    template <> inline constexpr size_t max_int_width<Int64> = 20;   /// -9223372036854775808
+    template <> inline constexpr size_t max_int_width<UInt128> = 39; /// 340282366920938463463374607431768211455
+    template <> inline constexpr size_t max_int_width<Int128> = 40;  /// -170141183460469231731687303715884105728
+    template <> inline constexpr size_t max_int_width<UInt256> = 78; /// 115792089237316195423570985008687907853269984665640564039457584007913129639935
+    template <> inline constexpr size_t max_int_width<Int256> = 78;  /// -57896044618658097711785492504343953926634992332820282019728792003956564819968
+}
+
 
 namespace DB
 {
@@ -15,16 +31,16 @@ namespace detail
     template <typename T>
     void NO_INLINE writeUIntTextFallback(T x, WriteBuffer & buf)
     {
-        char tmp[WRITE_HELPERS_MAX_INT_WIDTH];
-        int len = itoa(x, tmp) - tmp;
-        buf.write(tmp, len);
+        char tmp[max_int_width<T>];
+        char * end = itoa(x, tmp);
+        buf.write(tmp, end - tmp);
     }
 }
 
 template <typename T>
 void writeIntText(T x, WriteBuffer & buf)
 {
-    if (likely(reinterpret_cast<intptr_t>(buf.position()) + WRITE_HELPERS_MAX_INT_WIDTH < reinterpret_cast<intptr_t>(buf.buffer().end())))
+    if (likely(reinterpret_cast<uintptr_t>(buf.position()) + max_int_width<T> < reinterpret_cast<uintptr_t>(buf.buffer().end())))
         buf.position() = itoa(x, buf.position());
     else
         detail::writeUIntTextFallback(x, buf);
diff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h
index 203d8e3963bb..6545155aa6e0 100644
--- a/src/IO/readDecimalText.h
+++ b/src/IO/readDecimalText.h
@@ -3,6 +3,7 @@
 #include <limits>
 #include <IO/ReadHelpers.h>
 #include <Common/intExp.h>
+#include <common/wide_integer_to_string.h>
 
 
 namespace DB
@@ -160,7 +161,7 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_
             " Expected to read decimal with scale {} and precision {}";
 
         if constexpr (is_big_int_v<typename T::NativeType>)
-            throw Exception(fmt::format(pattern, digits, bigintToString(x.value), exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+            throw Exception(fmt::format(pattern, digits, x.value, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
         else
             throw Exception(fmt::format(pattern, digits, x, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
     }
diff --git a/src/Interpreters/AggregationCommon.h b/src/Interpreters/AggregationCommon.h
index 43b0671f6612..dc94c2981b33 100644
--- a/src/Interpreters/AggregationCommon.h
+++ b/src/Interpreters/AggregationCommon.h
@@ -4,7 +4,6 @@
 
 #include <Common/SipHash.h>
 #include <Common/Arena.h>
-#include <Common/UInt128.h>
 #include <Common/HashTable/Hash.h>
 #include <Common/memcpySmall.h>
 #include <Common/assert_cast.h>
@@ -265,7 +264,7 @@ static inline UInt128 ALWAYS_INLINE hash128(
     for (size_t j = 0; j < keys_size; ++j)
         key_columns[j]->updateHashWithValue(i, hash);
 
-    hash.get128(key.low, key.high);
+    hash.get128(key);
 
     return key;
 }
diff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp
index b78e1186cc98..18482a2ef0ad 100644
--- a/src/Interpreters/Aggregator.cpp
+++ b/src/Interpreters/Aggregator.cpp
@@ -325,7 +325,7 @@ AggregatedDataVariants::Type Aggregator::chooseAggregationMethod()
             /// into a fixed 16- or 32-byte blob.
             if (std::tuple_size<KeysNullMap<UInt128>>::value + keys_bytes <= 16)
                 return AggregatedDataVariants::Type::nullable_keys128;
-            if (std::tuple_size<KeysNullMap<DummyUInt256>>::value + keys_bytes <= 32)
+            if (std::tuple_size<KeysNullMap<UInt256>>::value + keys_bytes <= 32)
                 return AggregatedDataVariants::Type::nullable_keys256;
         }
 
diff --git a/src/Interpreters/Aggregator.h b/src/Interpreters/Aggregator.h
index 31eefe03b3ce..38b80d8923b2 100644
--- a/src/Interpreters/Aggregator.h
+++ b/src/Interpreters/Aggregator.h
@@ -15,7 +15,6 @@
 #include <Common/HashTable/TwoLevelStringHashMap.h>
 
 #include <Common/ThreadPool.h>
-#include <Common/UInt128.h>
 #include <Common/ColumnsHashing.h>
 #include <Common/assert_cast.h>
 #include <Common/filesystemHelpers.h>
@@ -78,7 +77,7 @@ using AggregatedDataWithShortStringKey = StringHashMap<AggregateDataPtr>;
 using AggregatedDataWithStringKey = HashMapWithSavedHash<StringRef, AggregateDataPtr>;
 
 using AggregatedDataWithKeys128 = HashMap<UInt128, AggregateDataPtr, UInt128HashCRC32>;
-using AggregatedDataWithKeys256 = HashMap<DummyUInt256, AggregateDataPtr, UInt256HashCRC32>;
+using AggregatedDataWithKeys256 = HashMap<UInt256, AggregateDataPtr, UInt256HashCRC32>;
 
 using AggregatedDataWithUInt32KeyTwoLevel = TwoLevelHashMap<UInt32, AggregateDataPtr, HashCRC32<UInt32>>;
 using AggregatedDataWithUInt64KeyTwoLevel = TwoLevelHashMap<UInt64, AggregateDataPtr, HashCRC32<UInt64>>;
@@ -88,7 +87,7 @@ using AggregatedDataWithShortStringKeyTwoLevel = TwoLevelStringHashMap<Aggregate
 using AggregatedDataWithStringKeyTwoLevel = TwoLevelHashMapWithSavedHash<StringRef, AggregateDataPtr>;
 
 using AggregatedDataWithKeys128TwoLevel = TwoLevelHashMap<UInt128, AggregateDataPtr, UInt128HashCRC32>;
-using AggregatedDataWithKeys256TwoLevel = TwoLevelHashMap<DummyUInt256, AggregateDataPtr, UInt256HashCRC32>;
+using AggregatedDataWithKeys256TwoLevel = TwoLevelHashMap<UInt256, AggregateDataPtr, UInt256HashCRC32>;
 
 /** Variants with better hash function, using more than 32 bits for hash.
   * Using for merging phase of external aggregation, where number of keys may be far greater than 4 billion,
@@ -100,7 +99,7 @@ using AggregatedDataWithKeys256TwoLevel = TwoLevelHashMap<DummyUInt256, Aggregat
 using AggregatedDataWithUInt64KeyHash64 = HashMap<UInt64, AggregateDataPtr, DefaultHash<UInt64>>;
 using AggregatedDataWithStringKeyHash64 = HashMapWithSavedHash<StringRef, AggregateDataPtr, StringRefHash64>;
 using AggregatedDataWithKeys128Hash64 = HashMap<UInt128, AggregateDataPtr, UInt128Hash>;
-using AggregatedDataWithKeys256Hash64 = HashMap<DummyUInt256, AggregateDataPtr, UInt256Hash>;
+using AggregatedDataWithKeys256Hash64 = HashMap<UInt256, AggregateDataPtr, UInt256Hash>;
 
 template <typename Base>
 struct AggregationDataWithNullKey : public Base
diff --git a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
index 5c071ed9134c..bdd9ce327078 100644
--- a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
+++ b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
@@ -64,6 +64,8 @@ Field zeroField(const Field & value)
         case Field::Types::Float64: return Float64(0);
         case Field::Types::UInt128: return UInt128(0);
         case Field::Types::Int128: return Int128(0);
+        case Field::Types::UInt256: return UInt256(0);
+        case Field::Types::Int256: return Int256(0);
         default:
             break;
     }
diff --git a/src/Interpreters/BloomFilterHash.h b/src/Interpreters/BloomFilterHash.h
index b64f7bae79d5..b88ca36ad845 100644
--- a/src/Interpreters/BloomFilterHash.h
+++ b/src/Interpreters/BloomFilterHash.h
@@ -93,7 +93,7 @@ struct BloomFilterHash
         else if (which.isDateTime()) return build_hash_column(getNumberTypeHash<UInt64, UInt32>(field));
         else if (which.isFloat32()) return build_hash_column(getNumberTypeHash<Float64, Float64>(field));
         else if (which.isFloat64()) return build_hash_column(getNumberTypeHash<Float64, Float64>(field));
-        else if (which.isUUID()) return build_hash_column(getNumberTypeHash<UInt128, UInt128>(field));
+        else if (which.isUUID()) return build_hash_column(getNumberTypeHash<UUID, UUID>(field));
         else if (which.isString()) return build_hash_column(getStringTypeHash(field));
         else if (which.isFixedString()) return build_hash_column(getFixedStringTypeHash(field, data_type));
         else throw Exception("Unexpected type " + data_type->getName() + " of bloom filter index.", ErrorCodes::BAD_ARGUMENTS);
@@ -154,7 +154,7 @@ struct BloomFilterHash
         else if (which.isDateTime()) getNumberTypeHash<UInt32, is_first>(column, vec, pos);
         else if (which.isFloat32()) getNumberTypeHash<Float32, is_first>(column, vec, pos);
         else if (which.isFloat64()) getNumberTypeHash<Float64, is_first>(column, vec, pos);
-        else if (which.isUUID()) getNumberTypeHash<UInt128, is_first>(column, vec, pos);
+        else if (which.isUUID()) getNumberTypeHash<UUID, is_first>(column, vec, pos);
         else if (which.isString()) getStringTypeHash<is_first>(column, vec, pos);
         else if (which.isFixedString()) getStringTypeHash<is_first>(column, vec, pos);
         else throw Exception("Unexpected type " + data_type->getName() + " of bloom filter index.", ErrorCodes::BAD_ARGUMENTS);
diff --git a/src/Interpreters/ClientInfo.cpp b/src/Interpreters/ClientInfo.cpp
index 223837aaf3d5..248c8cc6b807 100644
--- a/src/Interpreters/ClientInfo.cpp
+++ b/src/Interpreters/ClientInfo.cpp
@@ -71,7 +71,7 @@ void ClientInfo::write(WriteBuffer & out, const UInt64 server_protocol_revision)
 
     if (server_protocol_revision >= DBMS_MIN_REVISION_WITH_OPENTELEMETRY)
     {
-        if (client_trace_context.trace_id)
+        if (client_trace_context.trace_id != UUID())
         {
             // Have OpenTelemetry header.
             writeBinary(uint8_t(1), out);
diff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h
index 60abb0dd671e..b4579877ef66 100644
--- a/src/Interpreters/ClientInfo.h
+++ b/src/Interpreters/ClientInfo.h
@@ -2,7 +2,6 @@
 
 #include <Core/UUID.h>
 #include <Poco/Net/SocketAddress.h>
-#include <Common/UInt128.h>
 #include <common/types.h>
 #include <Common/OpenTelemetryTraceContext.h>
 
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index 8d3a4719ceeb..76a921c81e94 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -1228,13 +1228,13 @@ void Context::setCurrentQueryId(const String & query_id)
             UInt64 a;
             UInt64 b;
         } words;
-        __uint128_t uuid;
+        UUID uuid{};
     } random;
 
     random.words.a = thread_local_rng(); //-V656
     random.words.b = thread_local_rng(); //-V656
 
-    if (client_info.client_trace_context.trace_id != 0)
+    if (client_info.client_trace_context.trace_id != UUID())
     {
         // Use the OpenTelemetry trace context we received from the client, and
         // create a new span for the query.
diff --git a/src/Interpreters/DatabaseCatalog.h b/src/Interpreters/DatabaseCatalog.h
index 4fa6c5c0a108..5f6936f8b189 100644
--- a/src/Interpreters/DatabaseCatalog.h
+++ b/src/Interpreters/DatabaseCatalog.h
@@ -226,7 +226,7 @@ class DatabaseCatalog : boost::noncopyable, WithContext
 
     static inline size_t getFirstLevelIdx(const UUID & uuid)
     {
-        return uuid.toUnderType().low >> (64 - bits_for_first_level);
+        return uuid.toUnderType().items[0] >> (64 - bits_for_first_level);
     }
 
     struct TableMarkedAsDropped
diff --git a/src/Interpreters/ExpressionJIT.h b/src/Interpreters/ExpressionJIT.h
index 899c08a5296b..b7a7dd64cdda 100644
--- a/src/Interpreters/ExpressionJIT.h
+++ b/src/Interpreters/ExpressionJIT.h
@@ -7,6 +7,7 @@
 #if USE_EMBEDDED_COMPILER
 #    include <Functions/IFunctionImpl.h>
 #    include <Common/LRUCache.h>
+#    include <Common/HashTable/Hash.h>
 
 
 namespace DB
diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp
index d6163ff773a3..51373ea49d4a 100644
--- a/src/Interpreters/HashJoin.cpp
+++ b/src/Interpreters/HashJoin.cpp
@@ -384,7 +384,7 @@ template <typename Value, typename Mapped> struct KeyGetterForTypeImpl<HashJoin:
 };
 template <typename Value, typename Mapped> struct KeyGetterForTypeImpl<HashJoin::Type::keys256, Value, Mapped>
 {
-    using Type = ColumnsHashing::HashMethodKeysFixed<Value, DummyUInt256, Mapped, false, false, false, use_offset>;
+    using Type = ColumnsHashing::HashMethodKeysFixed<Value, UInt256, Mapped, false, false, false, use_offset>;
 };
 template <typename Value, typename Mapped> struct KeyGetterForTypeImpl<HashJoin::Type::hashed, Value, Mapped>
 {
diff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h
index c0a699d0a127..5ec8ed92f105 100644
--- a/src/Interpreters/HashJoin.h
+++ b/src/Interpreters/HashJoin.h
@@ -224,15 +224,15 @@ class HashJoin : public IJoin
     template <typename Mapped>
     struct MapsTemplate
     {
-        std::unique_ptr<FixedHashMap<UInt8, Mapped>>   key8;
-        std::unique_ptr<FixedHashMap<UInt16, Mapped>> key16;
-        std::unique_ptr<HashMap<UInt32, Mapped, HashCRC32<UInt32>>>                     key32;
-        std::unique_ptr<HashMap<UInt64, Mapped, HashCRC32<UInt64>>>                     key64;
-        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>                        key_string;
-        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>                        key_fixed_string;
-        std::unique_ptr<HashMap<UInt128, Mapped, UInt128HashCRC32>>                     keys128;
-        std::unique_ptr<HashMap<DummyUInt256, Mapped, UInt256HashCRC32>>                keys256;
-        std::unique_ptr<HashMap<UInt128, Mapped, UInt128TrivialHash>>                   hashed;
+        std::unique_ptr<FixedHashMap<UInt8, Mapped>>                  key8;
+        std::unique_ptr<FixedHashMap<UInt16, Mapped>>                 key16;
+        std::unique_ptr<HashMap<UInt32, Mapped, HashCRC32<UInt32>>>   key32;
+        std::unique_ptr<HashMap<UInt64, Mapped, HashCRC32<UInt64>>>   key64;
+        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>      key_string;
+        std::unique_ptr<HashMapWithSavedHash<StringRef, Mapped>>      key_fixed_string;
+        std::unique_ptr<HashMap<UInt128, Mapped, UInt128HashCRC32>>   keys128;
+        std::unique_ptr<HashMap<UInt256, Mapped, UInt256HashCRC32>>   keys256;
+        std::unique_ptr<HashMap<UInt128, Mapped, UInt128TrivialHash>> hashed;
 
         void create(Type which)
         {
diff --git a/src/Interpreters/JIT/CompileDAG.cpp b/src/Interpreters/JIT/CompileDAG.cpp
index 6737069f31c2..5fc88e7884cb 100644
--- a/src/Interpreters/JIT/CompileDAG.cpp
+++ b/src/Interpreters/JIT/CompileDAG.cpp
@@ -171,7 +171,7 @@ UInt128 CompileDAG::hash() const
     }
 
     UInt128 result;
-    hash.get128(result.low, result.high);
+    hash.get128(result);
     return result;
 }
 
diff --git a/src/Interpreters/JIT/CompileDAG.h b/src/Interpreters/JIT/CompileDAG.h
index 3872a896e383..a981c801e304 100644
--- a/src/Interpreters/JIT/CompileDAG.h
+++ b/src/Interpreters/JIT/CompileDAG.h
@@ -9,7 +9,6 @@
 #include <vector>
 
 #include <Core/Types.h>
-#include <Common/UInt128.h>
 
 #include <Columns/IColumn.h>
 #include <DataTypes/IDataType.h>
diff --git a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
index 2420255c5c1b..40508488d051 100644
--- a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
+++ b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
@@ -185,7 +185,7 @@ static inline std::tuple<NamesAndTypesList, NamesAndTypesList, NamesAndTypesList
                     {
                         const auto & prefix_limit = function->arguments->children[0]->as<ASTLiteral>();
 
-                        if (prefix_limit && isInt64FieldType(prefix_limit->value.getType()))
+                        if (prefix_limit && isInt64OrUInt64FieldType(prefix_limit->value.getType()))
                             res->children.back() = std::make_shared<ASTIdentifier>(function->name);
                     }
                 }
diff --git a/src/Interpreters/OpenTelemetrySpanLog.cpp b/src/Interpreters/OpenTelemetrySpanLog.cpp
index c72b0f3d3265..727a60f22608 100644
--- a/src/Interpreters/OpenTelemetrySpanLog.cpp
+++ b/src/Interpreters/OpenTelemetrySpanLog.cpp
@@ -8,6 +8,9 @@
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeUUID.h>
 
+#include <Common/hex.h>
+
+
 namespace DB
 {
 
@@ -43,7 +46,7 @@ void OpenTelemetrySpanLogElement::appendToBlock(MutableColumns & columns) const
 {
     size_t i = 0;
 
-    columns[i++]->insert(UInt128(Int128(trace_id)));
+    columns[i++]->insert(trace_id);
     columns[i++]->insert(span_id);
     columns[i++]->insert(parent_span_id);
     columns[i++]->insert(operation_name);
@@ -79,10 +82,8 @@ OpenTelemetrySpanHolder::OpenTelemetrySpanHolder(const std::string & _operation_
     auto & thread = CurrentThread::get();
 
     trace_id = thread.thread_trace_context.trace_id;
-    if (!trace_id)
-    {
+    if (trace_id == UUID())
         return;
-    }
 
     parent_span_id = thread.thread_trace_context.span_id;
     span_id = thread_local_rng();
@@ -98,10 +99,8 @@ OpenTelemetrySpanHolder::~OpenTelemetrySpanHolder()
 {
     try
     {
-        if (!trace_id)
-        {
+        if (trace_id == UUID())
             return;
-        }
 
         // First of all, return old value of current span.
         auto & thread = CurrentThread::get();
@@ -145,18 +144,31 @@ OpenTelemetrySpanHolder::~OpenTelemetrySpanHolder()
 }
 
 
+template <typename T>
+static T readHex(const char * data)
+{
+    T x{};
+
+    const char * end = data + sizeof(T) * 2;
+    while (data < end)
+    {
+        x *= 16;
+        x += unhex(*data);
+        ++data;
+    }
+
+    return x;
+}
+
+
 bool OpenTelemetryTraceContext::parseTraceparentHeader(const std::string & traceparent,
     std::string & error)
 {
     trace_id = 0;
 
-    uint8_t version = -1;
-    uint64_t trace_id_high = 0;
-    uint64_t trace_id_low = 0;
-
     // Version 00, which is the only one we can parse, is fixed width. Use this
     // fact for an additional sanity check.
-    const int expected_length = 2 + 1 + 32 + 1 + 16 + 1 + 2;
+    const int expected_length = strlen("xx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx-xx");
     if (traceparent.length() != expected_length)
     {
         error = fmt::format("unexpected length {}, expected {}",
@@ -164,39 +176,46 @@ bool OpenTelemetryTraceContext::parseTraceparentHeader(const std::string & trace
         return false;
     }
 
-    // clang-tidy doesn't like sscanf:
-    //   error: 'sscanf' used to convert a string to an unsigned integer value,
-    //   but function will not report conversion errors; consider using 'strtoul'
-    //   instead [cert-err34-c,-warnings-as-errors]
-    // There is no other ready solution, and hand-rolling a more complicated
-    // parser for an HTTP header in C++ sounds like RCE.
-    // NOLINTNEXTLINE(cert-err34-c)
-    int result = sscanf(&traceparent[0],
-        "%2" SCNx8 "-%16" SCNx64 "%16" SCNx64 "-%16" SCNx64 "-%2" SCNx8,
-        &version, &trace_id_high, &trace_id_low, &span_id, &trace_flags);
-
-    if (result == EOF)
+    const char * data = traceparent.data();
+
+    uint8_t version = readHex<uint8_t>(data);
+    data += 2;
+
+    if (version != 0)
     {
-        error = "EOF";
+        error = fmt::format("unexpected version {}, expected 00", version);
         return false;
     }
 
-    // We read uint128 as two uint64, so 5 parts and not 4.
-    if (result != 5)
+    if (*data != '-')
     {
-        error = fmt::format("could only read {} parts instead of the expected 5",
-            result);
+        error = fmt::format("Malformed traceparant header: {}", traceparent);
         return false;
     }
 
-    if (version != 0)
+    ++data;
+    UInt128 trace_id_128 = readHex<UInt128>(data);
+    trace_id = trace_id_128;
+    data += 32;
+
+    if (*data != '-')
     {
-        error = fmt::format("unexpected version {}, expected 00", version);
+        error = fmt::format("Malformed traceparant header: {}", traceparent);
+        return false;
+    }
+
+    ++data;
+    span_id = readHex<UInt64>(data);
+    data += 16;
+
+    if (*data != '-')
+    {
+        error = fmt::format("Malformed traceparant header: {}", traceparent);
         return false;
     }
 
-    trace_id = static_cast<__uint128_t>(trace_id_high) << 64
-        | trace_id_low;
+    ++data;
+    trace_flags = readHex<UInt8>(data);
     return true;
 }
 
@@ -205,7 +224,7 @@ std::string OpenTelemetryTraceContext::composeTraceparentHeader() const
 {
     // This span is a parent for its children, so we specify this span_id as a
     // parent id.
-    return fmt::format("00-{:032x}-{:016x}-{:02x}", trace_id,
+    return fmt::format("00-{:032x}-{:016x}-{:02x}", __uint128_t(trace_id.toUnderType()),
         span_id,
         // This cast is needed because fmt is being weird and complaining that
         // "mixing character types is not allowed".
diff --git a/src/Interpreters/OpenTelemetrySpanLog.h b/src/Interpreters/OpenTelemetrySpanLog.h
index f74e1f0c9fd8..861293b4f980 100644
--- a/src/Interpreters/OpenTelemetrySpanLog.h
+++ b/src/Interpreters/OpenTelemetrySpanLog.h
@@ -7,7 +7,7 @@ namespace DB
 
 struct OpenTelemetrySpan
 {
-    __uint128_t trace_id;
+    UUID trace_id;
     UInt64 span_id;
     UInt64 parent_span_id;
     std::string operation_name;
diff --git a/src/Interpreters/RewriteSumIfFunctionVisitor.cpp b/src/Interpreters/RewriteSumIfFunctionVisitor.cpp
index 2593c220c631..7b322ca1585a 100644
--- a/src/Interpreters/RewriteSumIfFunctionVisitor.cpp
+++ b/src/Interpreters/RewriteSumIfFunctionVisitor.cpp
@@ -29,7 +29,7 @@ void RewriteSumIfFunctionMatcher::visit(const ASTFunction & func, ASTPtr & ast,
     {
         /// sumIf(1, cond) -> countIf(cond)
         const auto * literal = func_arguments[0]->as<ASTLiteral>();
-        if (!literal || !DB::isInt64FieldType(literal->value.getType()))
+        if (!literal || !DB::isInt64OrUInt64FieldType(literal->value.getType()))
             return;
 
         if (func_arguments.size() == 2 && literal->value.get<UInt64>() == 1)
@@ -54,7 +54,7 @@ void RewriteSumIfFunctionMatcher::visit(const ASTFunction & func, ASTPtr & ast,
 
         if (first_literal && second_literal)
         {
-            if (!DB::isInt64FieldType(first_literal->value.getType()) || !DB::isInt64FieldType(second_literal->value.getType()))
+            if (!DB::isInt64OrUInt64FieldType(first_literal->value.getType()) || !DB::isInt64OrUInt64FieldType(second_literal->value.getType()))
                 return;
 
             auto first_value = first_literal->value.get<UInt64>();
diff --git a/src/Interpreters/Set.cpp b/src/Interpreters/Set.cpp
index b150eabda65a..713be3c1447f 100644
--- a/src/Interpreters/Set.cpp
+++ b/src/Interpreters/Set.cpp
@@ -1,7 +1,6 @@
 #include <optional>
 
 #include <Core/Field.h>
-#include <Common/FieldVisitors.h>
 #include <Core/Row.h>
 
 #include <Columns/ColumnsNumber.h>
diff --git a/src/Interpreters/SetVariants.cpp b/src/Interpreters/SetVariants.cpp
index eb21333e3ecf..1cc0f767ecc2 100644
--- a/src/Interpreters/SetVariants.cpp
+++ b/src/Interpreters/SetVariants.cpp
@@ -122,7 +122,7 @@ typename SetVariantsTemplate<Variant>::Type SetVariantsTemplate<Variant>::choose
                 throw Exception{"Aggregator: keys sizes overflow", ErrorCodes::LOGICAL_ERROR};
             if ((std::tuple_size<KeysNullMap<UInt128>>::value + keys_bytes) <= 16)
                 return Type::nullable_keys128;
-            if ((std::tuple_size<KeysNullMap<DummyUInt256>>::value + keys_bytes) <= 32)
+            if ((std::tuple_size<KeysNullMap<UInt256>>::value + keys_bytes) <= 32)
                 return Type::nullable_keys256;
         }
 
diff --git a/src/Interpreters/SetVariants.h b/src/Interpreters/SetVariants.h
index bcd833e42a81..d6be996effb3 100644
--- a/src/Interpreters/SetVariants.h
+++ b/src/Interpreters/SetVariants.h
@@ -8,7 +8,6 @@
 #include <Common/HashTable/ClearableHashSet.h>
 #include <Common/HashTable/FixedClearableHashSet.h>
 #include <Common/HashTable/FixedHashSet.h>
-#include <Common/UInt128.h>
 
 
 namespace DB
@@ -202,12 +201,12 @@ struct NonClearableSet
     std::unique_ptr<SetMethodString<HashSetWithSavedHash<StringRef>>>                        key_string;
     std::unique_ptr<SetMethodFixedString<HashSetWithSavedHash<StringRef>>>                   key_fixed_string;
     std::unique_ptr<SetMethodKeysFixed<HashSet<UInt128, UInt128HashCRC32>>>                  keys128;
-    std::unique_ptr<SetMethodKeysFixed<HashSet<DummyUInt256, UInt256HashCRC32>>>             keys256;
+    std::unique_ptr<SetMethodKeysFixed<HashSet<UInt256, UInt256HashCRC32>>>                  keys256;
     std::unique_ptr<SetMethodHashed<HashSet<UInt128, UInt128TrivialHash>>>                   hashed;
 
     /// Support for nullable keys (for DISTINCT implementation).
     std::unique_ptr<SetMethodKeysFixed<HashSet<UInt128, UInt128HashCRC32>, true>>            nullable_keys128;
-    std::unique_ptr<SetMethodKeysFixed<HashSet<DummyUInt256, UInt256HashCRC32>, true>>       nullable_keys256;
+    std::unique_ptr<SetMethodKeysFixed<HashSet<UInt256, UInt256HashCRC32>, true>>            nullable_keys256;
     /** Unlike Aggregator, `concat` method is not used here.
       * This is done because `hashed` method, although slower, but in this case, uses less RAM.
       *  since when you use it, the key values themselves are not stored.
@@ -224,12 +223,12 @@ struct ClearableSet
     std::unique_ptr<SetMethodString<ClearableHashSetWithSavedHash<StringRef>>>                       key_string;
     std::unique_ptr<SetMethodFixedString<ClearableHashSetWithSavedHash<StringRef>>>                  key_fixed_string;
     std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt128, UInt128HashCRC32>>>                 keys128;
-    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<DummyUInt256, UInt256HashCRC32>>>            keys256;
+    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt256, UInt256HashCRC32>>>                 keys256;
     std::unique_ptr<SetMethodHashed<ClearableHashSet<UInt128, UInt128TrivialHash>>>                  hashed;
 
     /// Support for nullable keys (for DISTINCT implementation).
     std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt128, UInt128HashCRC32>, true>>           nullable_keys128;
-    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<DummyUInt256, UInt256HashCRC32>, true>>      nullable_keys256;
+    std::unique_ptr<SetMethodKeysFixed<ClearableHashSet<UInt256, UInt256HashCRC32>, true>>           nullable_keys256;
     /** Unlike Aggregator, `concat` method is not used here.
       * This is done because `hashed` method, although slower, but in this case, uses less RAM.
       *  since when you use it, the key values themselves are not stored.
diff --git a/src/Interpreters/ThreadStatusExt.cpp b/src/Interpreters/ThreadStatusExt.cpp
index c04534e11a1b..cff6fb9cbcd2 100644
--- a/src/Interpreters/ThreadStatusExt.cpp
+++ b/src/Interpreters/ThreadStatusExt.cpp
@@ -80,7 +80,7 @@ void ThreadStatus::attachQueryContext(ContextPtr query_context_)
     // on OpenTelemetrySpanHolder due to link order issues.
     // FIXME why and how is this different from setupState()?
     thread_trace_context = query_context_->query_trace_context;
-    if (thread_trace_context.trace_id)
+    if (thread_trace_context.trace_id != UUID())
     {
         thread_trace_context.span_id = thread_local_rng();
     }
@@ -126,7 +126,7 @@ void ThreadStatus::setupState(const ThreadGroupStatusPtr & thread_group_)
         // Generate new span for thread manually here, because we can't depend
         // on OpenTelemetrySpanHolder due to link order issues.
         thread_trace_context = query_context_ptr->query_trace_context;
-        if (thread_trace_context.trace_id)
+        if (thread_trace_context.trace_id != UUID())
         {
             thread_trace_context.span_id = thread_local_rng();
         }
@@ -335,7 +335,7 @@ void ThreadStatus::detachQuery(bool exit_if_already_detached, bool thread_exits)
 
     std::shared_ptr<OpenTelemetrySpanLog> opentelemetry_span_log;
     auto query_context_ptr = query_context.lock();
-    if (thread_trace_context.trace_id && query_context_ptr)
+    if (thread_trace_context.trace_id != UUID() && query_context_ptr)
     {
         opentelemetry_span_log = query_context_ptr->getOpenTelemetrySpanLog();
     }
diff --git a/src/Interpreters/WindowDescription.cpp b/src/Interpreters/WindowDescription.cpp
index 05d75d4647ee..b9f8597706e6 100644
--- a/src/Interpreters/WindowDescription.cpp
+++ b/src/Interpreters/WindowDescription.cpp
@@ -1,9 +1,11 @@
 #include <Interpreters/WindowDescription.h>
 
 #include <Core/Field.h>
+#include <Common/FieldVisitors.h>
 #include <IO/Operators.h>
 #include <Parsers/ASTFunction.h>
 
+
 namespace DB
 {
 
diff --git a/src/Interpreters/WindowDescription.h b/src/Interpreters/WindowDescription.h
index 70a4e0e44e02..4cb478bae85b 100644
--- a/src/Interpreters/WindowDescription.h
+++ b/src/Interpreters/WindowDescription.h
@@ -1,6 +1,5 @@
 #pragma once
 
-#include <Common/FieldVisitors.h>
 #include <Core/Field.h>
 #include <Parsers/IAST_fwd.h>
 #include <AggregateFunctions/IAggregateFunction.h>
diff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp
index 529caec9c800..fa49b7303797 100644
--- a/src/Interpreters/convertFieldToType.cpp
+++ b/src/Interpreters/convertFieldToType.cpp
@@ -14,14 +14,13 @@
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
 #include <DataTypes/DataTypeEnum.h>
+#include <DataTypes/DataTypeUUID.h>
+#include <DataTypes/DataTypeLowCardinality.h>
 #include <DataTypes/DataTypeNullable.h>
 
 #include <Core/AccurateComparison.h>
-#include <Common/FieldVisitors.h>
 #include <Common/typeid_cast.h>
 #include <Common/NaNUtils.h>
-#include <DataTypes/DataTypeUUID.h>
-#include <DataTypes/DataTypeLowCardinality.h>
 
 #include <common/DateLUT.h>
 #include <DataTypes/DataTypeAggregateFunction.h>
@@ -67,6 +66,14 @@ static Field convertNumericType(const Field & from, const IDataType & type)
         return convertNumericTypeImpl<Int64, To>(from);
     if (from.getType() == Field::Types::Float64)
         return convertNumericTypeImpl<Float64, To>(from);
+    if (from.getType() == Field::Types::UInt128)
+        return convertNumericTypeImpl<UInt128, To>(from);
+    if (from.getType() == Field::Types::Int128)
+        return convertNumericTypeImpl<Int128, To>(from);
+    if (from.getType() == Field::Types::UInt256)
+        return convertNumericTypeImpl<UInt256, To>(from);
+    if (from.getType() == Field::Types::Int256)
+        return convertNumericTypeImpl<Int256, To>(from);
 
     throw Exception("Type mismatch in IN or VALUES section. Expected: " + type.getName() + ". Got: "
         + Field::Types::toString(from.getType()), ErrorCodes::TYPE_MISMATCH);
@@ -78,9 +85,9 @@ static Field convertIntToDecimalType(const Field & from, const DataTypeDecimal<T
 {
     From value = from.get<From>();
     if (!type.canStoreWhole(value))
-        throw Exception("Number is too much to place in " + type.getName(), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+        throw Exception("Number is too big to place in " + type.getName(), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
 
-    T scaled_value = type.getScaleMultiplier() * value;
+    T scaled_value = type.getScaleMultiplier() * static_cast<T>(value);
     return DecimalField<T>(scaled_value, type.getScale());
 }
 
@@ -108,6 +115,15 @@ static Field convertDecimalType(const Field & from, const To & type)
         return convertIntToDecimalType<UInt64>(from, type);
     if (from.getType() == Field::Types::Int64)
         return convertIntToDecimalType<Int64>(from, type);
+    if (from.getType() == Field::Types::UInt128)
+        return convertIntToDecimalType<UInt128>(from, type);
+    if (from.getType() == Field::Types::Int128)
+        return convertIntToDecimalType<Int128>(from, type);
+    if (from.getType() == Field::Types::UInt256)
+        return convertIntToDecimalType<UInt256>(from, type);
+    if (from.getType() == Field::Types::Int256)
+        return convertIntToDecimalType<Int256>(from, type);
+
     if (from.getType() == Field::Types::String)
         return convertStringToDecimalType(from, type);
 
@@ -125,7 +141,6 @@ static Field convertDecimalType(const Field & from, const To & type)
 
 Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const IDataType * from_type_hint)
 {
-    // This was added to mitigate converting DateTime64-Field (a typedef to a Decimal64) to DataTypeDate64-compatible type.
     if (from_type_hint && from_type_hint->equals(type))
     {
         return src;
@@ -133,6 +148,7 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID
 
     WhichDataType which_type(type);
     WhichDataType which_from_type;
+
     if (from_type_hint)
     {
         which_from_type = WhichDataType(*from_type_hint);
@@ -179,12 +195,6 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID
             return src;
         }
 
-        if (which_type.isUUID() && src.getType() == Field::Types::UInt128)
-        {
-            /// Already in needed type.
-            return src;
-        }
-
         if (which_type.isDateTime64() && src.getType() == Field::Types::Decimal64)
         {
             /// Already in needed type.
@@ -193,6 +203,11 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID
 
         /// TODO Conversion from integers to DateTime64
     }
+    else if (which_type.isUUID() && src.getType() == Field::Types::UUID)
+    {
+        /// Already in needed type.
+        return src;
+    }
     else if (which_type.isStringOrFixedString())
     {
         if (src.getType() == Field::Types::String)
@@ -364,6 +379,7 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID
 
 }
 
+
 Field convertFieldToType(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint)
 {
     if (from_value.isNull())
@@ -390,18 +406,22 @@ Field convertFieldToType(const Field & from_value, const IDataType & to_type, co
         return convertFieldToTypeImpl(from_value, to_type, from_type_hint);
 }
 
+
 Field convertFieldToTypeOrThrow(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint)
 {
     bool is_null = from_value.isNull();
     if (is_null && !to_type.isNullable())
         throw Exception(ErrorCodes::TYPE_MISMATCH, "Cannot convert NULL to {}", to_type.getName());
+
     Field converted = convertFieldToType(from_value, to_type, from_type_hint);
+
     if (!is_null && converted.isNull())
         throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,
             "Cannot convert value '{}'{}: it cannot be represented as {}",
             toString(from_value),
             from_type_hint ? " from " + from_type_hint->getName() : "",
             to_type.getName());
+
     return converted;
 }
 
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index f310ce0d5299..90e39ae0af7f 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -174,7 +174,7 @@ static void logQuery(const String & query, ContextPtr context, bool internal)
             comment,
             joinLines(query));
 
-        if (client_info.client_trace_context.trace_id)
+        if (client_info.client_trace_context.trace_id != UUID())
         {
             LOG_TRACE(&Poco::Logger::get("executeQuery"),
                 "OpenTelemetry traceparent '{}'",
@@ -289,7 +289,7 @@ static void onExceptionBeforeStart(const String & query_for_logging, ContextPtr
             query_log->add(elem);
 
     if (auto opentelemetry_span_log = context->getOpenTelemetrySpanLog();
-        context->query_trace_context.trace_id
+        context->query_trace_context.trace_id != UUID()
             && opentelemetry_span_log)
     {
         OpenTelemetrySpanLogElement span;
@@ -792,7 +792,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 }
 
                 if (auto opentelemetry_span_log = context->getOpenTelemetrySpanLog();
-                    context->query_trace_context.trace_id
+                    context->query_trace_context.trace_id != UUID()
                         && opentelemetry_span_log)
                 {
                     OpenTelemetrySpanLogElement span;
diff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp
index a0662a471522..d4a420f01289 100644
--- a/src/Parsers/ASTFunction.cpp
+++ b/src/Parsers/ASTFunction.cpp
@@ -415,7 +415,7 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format
                 // them, and we want to have consistent formatting.
                 if (tuple_arguments_valid && lit_right)
                 {
-                    if (isInt64FieldType(lit_right->value.getType())
+                    if (isInt64OrUInt64FieldType(lit_right->value.getType())
                         && lit_right->value.get<Int64>() >= 0)
                     {
                         if (frame.need_parens)
diff --git a/src/Parsers/ASTSampleRatio.h b/src/Parsers/ASTSampleRatio.h
index 09dec6aac999..a3e70b7dab70 100644
--- a/src/Parsers/ASTSampleRatio.h
+++ b/src/Parsers/ASTSampleRatio.h
@@ -2,6 +2,7 @@
 
 #include <Parsers/IAST.h>
 
+
 namespace DB
 {
 
@@ -11,12 +12,7 @@ namespace DB
 class ASTSampleRatio : public IAST
 {
 public:
-#ifdef __SIZEOF_INT128__
     using BigNum = __uint128_t;    /// Must contain the result of multiplying two UInt64.
-#else
-    #warning "No uint128_t type. Sampling ratios cannot work correctly."
-    using BigNum = uint64_t;
-#endif
 
     struct Rational
     {
diff --git a/src/Parsers/ASTWindowDefinition.cpp b/src/Parsers/ASTWindowDefinition.cpp
index 35374df61772..37b27b22c7d7 100644
--- a/src/Parsers/ASTWindowDefinition.cpp
+++ b/src/Parsers/ASTWindowDefinition.cpp
@@ -1,8 +1,10 @@
 #include <Parsers/ASTWindowDefinition.h>
 
 #include <Common/quoteString.h>
+#include <Common/FieldVisitors.h>
 #include <IO/Operators.h>
 
+
 namespace DB
 {
 
diff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp
index 6451a9d0c0dd..3a21d704eb90 100644
--- a/src/Parsers/IAST.cpp
+++ b/src/Parsers/IAST.cpp
@@ -53,7 +53,7 @@ IAST::Hash IAST::getTreeHash() const
     SipHash hash_state;
     updateTreeHash(hash_state);
     IAST::Hash res;
-    hash_state.get128(res.first, res.second);
+    hash_state.get128(res);
     return res;
 }
 
diff --git a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
index 288c6ee09ef9..cc9ae5e65bb1 100644
--- a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
+++ b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
@@ -363,7 +363,7 @@ size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTP
     hash_state.update(salt);
 
     IAST::Hash res128;
-    hash_state.get128(res128.first, res128.second);
+    hash_state.get128(res128);
     size_t res = 0;
     boost::hash_combine(res, res128.first);
     boost::hash_combine(res, res128.second);
diff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
index 701385447b4c..1eb64682faec 100644
--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
@@ -6,7 +6,6 @@
 #include <Parsers/ExpressionListParsers.h>
 #include <Processors/Formats/Impl/ValuesBlockInputFormat.h>
 #include <Formats/FormatFactory.h>
-#include <Common/FieldVisitors.h>
 #include <Core/Block.h>
 #include <common/find_symbols.h>
 #include <Common/typeid_cast.h>
diff --git a/src/Processors/Transforms/LimitByTransform.cpp b/src/Processors/Transforms/LimitByTransform.cpp
index 5c405046a831..cb2804007bd4 100644
--- a/src/Processors/Transforms/LimitByTransform.cpp
+++ b/src/Processors/Transforms/LimitByTransform.cpp
@@ -33,13 +33,13 @@ void LimitByTransform::transform(Chunk & chunk)
 
     for (UInt64 row = 0; row < num_rows; ++row)
     {
-        UInt128 key(0, 0);
+        UInt128 key{};
         SipHash hash;
 
         for (auto position : key_positions)
             columns[position]->updateHashWithValue(row, hash);
 
-        hash.get128(key.low, key.high);
+        hash.get128(key);
 
         auto count = keys_counts[key]++;
         if (count >= group_offset
diff --git a/src/Processors/Transforms/LimitByTransform.h b/src/Processors/Transforms/LimitByTransform.h
index 9773f637f407..8c2b46af69ef 100644
--- a/src/Processors/Transforms/LimitByTransform.h
+++ b/src/Processors/Transforms/LimitByTransform.h
@@ -1,7 +1,7 @@
 #pragma once
 #include <Processors/ISimpleTransform.h>
 #include <Common/HashTable/HashMap.h>
-#include <Common/UInt128.h>
+
 
 namespace DB
 {
diff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp
index df92f911325f..798f19c37ff6 100644
--- a/src/Processors/Transforms/WindowTransform.cpp
+++ b/src/Processors/Transforms/WindowTransform.cpp
@@ -3,6 +3,7 @@
 #include <AggregateFunctions/AggregateFunctionFactory.h>
 #include <Common/Arena.h>
 #include <Common/FieldVisitorsAccurateComparison.h>
+#include <common/arithmeticOverflow.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/getLeastSupertype.h>
 #include <Interpreters/ExpressionActions.h>
@@ -67,15 +68,9 @@ static int compareValuesWithOffset(const IColumn * _compared_column,
 
     bool is_overflow;
     if (offset_is_preceding)
-    {
-        is_overflow = __builtin_sub_overflow(reference_value, offset,
-            &reference_value);
-    }
+        is_overflow = common::subOverflow(reference_value, offset, reference_value);
     else
-    {
-        is_overflow = __builtin_add_overflow(reference_value, offset,
-            &reference_value);
-    }
+        is_overflow = common::addOverflow(reference_value, offset, reference_value);
 
 //    fmt::print(stderr,
 //        "compared [{}] = {}, old ref {}, shifted ref [{}] = {}, offset {} preceding {} overflow {} to negative {}
",
@@ -1465,7 +1460,7 @@ struct WindowFunctionLagLeadInFrame final : public WindowFunction
             return;
         }
 
-        if (!isInt64FieldType(argument_types[1]->getDefault().getType()))
+        if (!isInt64OrUInt64FieldType(argument_types[1]->getDefault().getType()))
         {
             throw Exception(ErrorCodes::BAD_ARGUMENTS,
                 "Offset must be an integer, '{}' given",
diff --git a/src/Processors/Transforms/WindowTransform.h b/src/Processors/Transforms/WindowTransform.h
index 882bf429c0a8..611b03ebf72d 100644
--- a/src/Processors/Transforms/WindowTransform.h
+++ b/src/Processors/Transforms/WindowTransform.h
@@ -8,6 +8,7 @@
 
 #include <deque>
 
+
 namespace DB
 {
 
diff --git a/src/Storages/LiveView/LiveViewBlockOutputStream.h b/src/Storages/LiveView/LiveViewBlockOutputStream.h
index 5a1f75a8c2fd..6b8a5a2cb9ec 100644
--- a/src/Storages/LiveView/LiveViewBlockOutputStream.h
+++ b/src/Storages/LiveView/LiveViewBlockOutputStream.h
@@ -3,6 +3,7 @@
 #include <DataTypes/DataTypesNumber.h>
 #include <DataStreams/IBlockOutputStream.h>
 #include <Storages/LiveView/StorageLiveView.h>
+#include <Common/hex.h>
 
 
 namespace DB
@@ -25,8 +26,8 @@ class LiveViewBlockOutputStream : public IBlockOutputStream
         UInt128 key;
         String key_str;
 
-        new_hash->get128(key.low, key.high);
-        key_str = key.toHexString();
+        new_hash->get128(key);
+        key_str = getHexUIntLowercase(key);
 
         std::lock_guard lock(storage.mutex);
 
diff --git a/src/Storages/LiveView/StorageLiveView.cpp b/src/Storages/LiveView/StorageLiveView.cpp
index 1d81405ec263..19c3992276f8 100644
--- a/src/Storages/LiveView/StorageLiveView.cpp
+++ b/src/Storages/LiveView/StorageLiveView.cpp
@@ -23,6 +23,7 @@ limitations under the License. */
 #include <common/logger_useful.h>
 #include <Common/typeid_cast.h>
 #include <Common/SipHash.h>
+#include <Common/hex.h>
 
 #include <Storages/LiveView/StorageLiveView.h>
 #include <Storages/LiveView/LiveViewBlockInputStream.h>
@@ -366,20 +367,20 @@ bool StorageLiveView::getNewBlocks()
         new_blocks->push_back(block);
     }
 
-    hash.get128(key.low, key.high);
+    hash.get128(key);
 
     /// Update blocks only if hash keys do not match
     /// NOTE: hash could be different for the same result
     ///       if blocks are not in the same order
     bool updated = false;
     {
-        if (getBlocksHashKey() != key.toHexString())
+        if (getBlocksHashKey() != getHexUIntLowercase(key))
         {
             if (new_blocks->empty())
             {
                 new_blocks->push_back(getHeader());
             }
-            new_blocks_metadata->hash = key.toHexString();
+            new_blocks_metadata->hash = getHexUIntLowercase(key);
             new_blocks_metadata->version = getBlocksVersion() + 1;
             new_blocks_metadata->time = std::chrono::system_clock::now();
 
diff --git a/src/Storages/MarkCache.h b/src/Storages/MarkCache.h
index 5dfaa9ef0ea8..ccf8a2e606db 100644
--- a/src/Storages/MarkCache.h
+++ b/src/Storages/MarkCache.h
@@ -50,7 +50,7 @@ class MarkCache : public LRUCache<UInt128, MarksInCompressedFile, UInt128Trivial
 
         SipHash hash;
         hash.update(path_to_file.data(), path_to_file.size() + 1);
-        hash.get128(key.low, key.high);
+        hash.get128(key);
 
         return key;
     }
diff --git a/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp b/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp
index b0eb1cbea70e..3a944b3e7f03 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartChecksum.cpp
@@ -299,7 +299,8 @@ String MergeTreeDataPartChecksums::getTotalChecksumHex() const
         hash_of_all_files.update(checksum.file_hash);
     }
 
-    UInt64 lo, hi;
+    UInt64 lo;
+    UInt64 hi;
     hash_of_all_files.get128(lo, hi);
 
     return getHexUIntUppercase(hi) + getHexUIntUppercase(lo);
@@ -394,7 +395,7 @@ void MinimalisticDataPartChecksums::computeTotalChecksums(const MergeTreeDataPar
 
     auto get_hash = [] (SipHash & hash, uint128 & data)
     {
-        hash.get128(data.first, data.second);
+        hash.get128(data);
     };
 
     get_hash(hash_of_all_files_state, hash_of_all_files);
diff --git a/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp b/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp
index 045ab488adac..fb7431e0bfe9 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartInMemory.cpp
@@ -125,7 +125,7 @@ IMergeTreeDataPart::Checksum MergeTreeDataPartInMemory::calculateBlockChecksum()
         column.column->updateHashFast(hash);
 
     checksum.uncompressed_size = block.bytes();
-    hash.get128(checksum.uncompressed_hash.first, checksum.uncompressed_hash.second);
+    hash.get128(checksum.uncompressed_hash);
     return checksum;
 }
 
diff --git a/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp b/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp
index 17d198557986..3c3a6ecee7f7 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartUUID.cpp
@@ -1,5 +1,7 @@
+#include <vector>
 #include <Storages/MergeTree/MergeTreeDataPartUUID.h>
 
+
 namespace DB
 {
 
diff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
index 8245364d87a1..91448e17c9da 100644
--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
@@ -5,7 +5,6 @@
 
 #include <Poco/File.h>
 
-#include <Common/FieldVisitors.h>
 #include <Storages/MergeTree/MergeTreeDataSelectExecutor.h>
 #include <Storages/MergeTree/MergeTreeSelectProcessor.h>
 #include <Storages/MergeTree/MergeTreeReverseSelectProcessor.h>
@@ -40,6 +39,7 @@
 #include <DataTypes/DataTypesNumber.h>
 #include <Storages/VirtualColumnUtils.h>
 
+
 namespace ProfileEvents
 {
     extern const Event SelectedParts;
diff --git a/src/Storages/StorageGenerateRandom.cpp b/src/Storages/StorageGenerateRandom.cpp
index bc158c38f376..7987fcc3b311 100644
--- a/src/Storages/StorageGenerateRandom.cpp
+++ b/src/Storages/StorageGenerateRandom.cpp
@@ -213,10 +213,7 @@ ColumnPtr fillColumnWithRandomData(
         {
             auto column = ColumnUInt16::create();
             column->getData().resize(limit);
-
-            for (size_t i = 0; i < limit; ++i)
-                column->getData()[i] = rng() % (DATE_LUT_MAX_DAY_NUM + 1);
-
+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt16), rng);
             return column;
         }
         case TypeIndex::UInt32: [[fallthrough]];
@@ -234,14 +231,28 @@ ColumnPtr fillColumnWithRandomData(
             fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt64), rng);
             return column;
         }
-        case TypeIndex::UInt128: [[fallthrough]];
-        case TypeIndex::UUID:
+        case TypeIndex::UInt128:
         {
             auto column = ColumnUInt128::create();
             column->getData().resize(limit);
             fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt128), rng);
             return column;
         }
+        case TypeIndex::UInt256:
+        {
+            auto column = ColumnUInt256::create();
+            column->getData().resize(limit);
+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UInt256), rng);
+            return column;
+        }
+        case TypeIndex::UUID:
+        {
+            auto column = ColumnUUID::create();
+            column->getData().resize(limit);
+            /// NOTE This is slightly incorrect as random UUIDs should have fixed version 4.
+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(UUID), rng);
+            return column;
+        }
         case TypeIndex::Int8:
         {
             auto column = ColumnInt8::create();
@@ -270,6 +281,20 @@ ColumnPtr fillColumnWithRandomData(
             fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(Int64), rng);
             return column;
         }
+        case TypeIndex::Int128:
+        {
+            auto column = ColumnInt128::create();
+            column->getData().resize(limit);
+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(Int128), rng);
+            return column;
+        }
+        case TypeIndex::Int256:
+        {
+            auto column = ColumnInt256::create();
+            column->getData().resize(limit);
+            fillBufferWithRandomData(reinterpret_cast<char *>(column->getData().data()), limit * sizeof(Int256), rng);
+            return column;
+        }
         case TypeIndex::Float32:
         {
             auto column = ColumnFloat32::create();
@@ -308,6 +333,14 @@ ColumnPtr fillColumnWithRandomData(
             fillBufferWithRandomData(reinterpret_cast<char *>(column_concrete.getData().data()), limit * sizeof(Decimal128), rng);
             return column;
         }
+        case TypeIndex::Decimal256:
+        {
+            auto column = type->createColumn();
+            auto & column_concrete = typeid_cast<ColumnDecimal<Decimal256> &>(*column);
+            column_concrete.getData().resize(limit);
+            fillBufferWithRandomData(reinterpret_cast<char *>(column_concrete.getData().data()), limit * sizeof(Decimal256), rng);
+            return column;
+        }
         case TypeIndex::FixedString:
         {
             size_t n = typeid_cast<const DataTypeFixedString &>(*type).getN();
diff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp
index 7eadfc5142d7..c1b64bb2e8b2 100644
--- a/src/Storages/StorageMergeTree.cpp
+++ b/src/Storages/StorageMergeTree.cpp
@@ -3,7 +3,6 @@
 #include <Databases/IDatabase.h>
 #include <Common/escapeForFileName.h>
 #include <Common/typeid_cast.h>
-#include <Common/FieldVisitors.h>
 #include <Common/ThreadPool.h>
 #include <Interpreters/InterpreterAlterQuery.h>
 #include <Interpreters/PartLog.h>
diff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp
index 71645edfbbf4..588a0a830048 100644
--- a/src/Storages/StorageReplicatedMergeTree.cpp
+++ b/src/Storages/StorageReplicatedMergeTree.cpp
@@ -1,6 +1,5 @@
 #include <Core/Defines.h>
 
-#include <Common/FieldVisitors.h>
 #include <Common/Macros.h>
 #include <Common/StringUtils/StringUtils.h>
 #include <Common/ThreadPool.h>
diff --git a/src/Storages/StorageURL.cpp b/src/Storages/StorageURL.cpp
index e6c2f52f9256..824f11648512 100644
--- a/src/Storages/StorageURL.cpp
+++ b/src/Storages/StorageURL.cpp
@@ -79,7 +79,7 @@ namespace
             if (CurrentThread::isInitialized())
             {
                 const auto & thread_trace_context = CurrentThread::get().thread_trace_context;
-                if (thread_trace_context.trace_id)
+                if (thread_trace_context.trace_id != UUID())
                 {
                     header.emplace_back("traceparent",
                         thread_trace_context.composeTraceparentHeader());
diff --git a/src/Storages/System/StorageSystemQuotas.cpp b/src/Storages/System/StorageSystemQuotas.cpp
index 4bba082f66e8..5e1ce220bec8 100644
--- a/src/Storages/System/StorageSystemQuotas.cpp
+++ b/src/Storages/System/StorageSystemQuotas.cpp
@@ -60,7 +60,7 @@ void StorageSystemQuotas::fillData(MutableColumns & res_columns, ContextPtr cont
 
     size_t column_index = 0;
     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);
-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();
+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();
     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);
     auto & column_key_types = assert_cast<ColumnInt8 &>(assert_cast<ColumnArray &>(*res_columns[column_index]).getData()).getData();
     auto & column_key_types_offsets = assert_cast<ColumnArray &>(*res_columns[column_index++]).getOffsets();
@@ -80,7 +80,7 @@ void StorageSystemQuotas::fillData(MutableColumns & res_columns, ContextPtr cont
                        const RolesOrUsersSet & apply_to)
     {
         column_name.insertData(name.data(), name.length());
-        column_id.push_back(id);
+        column_id.push_back(id.toUnderType());
         column_storage.insertData(storage_name.data(), storage_name.length());
 
         if (key_type != KeyType::NONE)
diff --git a/src/Storages/System/StorageSystemRoles.cpp b/src/Storages/System/StorageSystemRoles.cpp
index 65ae74887a75..42983670466e 100644
--- a/src/Storages/System/StorageSystemRoles.cpp
+++ b/src/Storages/System/StorageSystemRoles.cpp
@@ -31,7 +31,7 @@ void StorageSystemRoles::fillData(MutableColumns & res_columns, ContextPtr conte
 
     size_t column_index = 0;
     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);
-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();
+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();
     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);
 
     auto add_row = [&](const String & name,
@@ -39,7 +39,7 @@ void StorageSystemRoles::fillData(MutableColumns & res_columns, ContextPtr conte
                        const String & storage_name)
     {
         column_name.insertData(name.data(), name.length());
-        column_id.push_back(id);
+        column_id.push_back(id.toUnderType());
         column_storage.insertData(storage_name.data(), storage_name.length());
     };
 
diff --git a/src/Storages/System/StorageSystemRowPolicies.cpp b/src/Storages/System/StorageSystemRowPolicies.cpp
index f9d6b14957e2..c7a403a4abe5 100644
--- a/src/Storages/System/StorageSystemRowPolicies.cpp
+++ b/src/Storages/System/StorageSystemRowPolicies.cpp
@@ -63,7 +63,7 @@ void StorageSystemRowPolicies::fillData(MutableColumns & res_columns, ContextPtr
     auto & column_short_name = assert_cast<ColumnString &>(*res_columns[column_index++]);
     auto & column_database = assert_cast<ColumnString &>(*res_columns[column_index++]);
     auto & column_table = assert_cast<ColumnString &>(*res_columns[column_index++]);
-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();
+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();
     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);
 
     ColumnString * column_condition[MAX_CONDITION_TYPE];
@@ -93,7 +93,7 @@ void StorageSystemRowPolicies::fillData(MutableColumns & res_columns, ContextPtr
         column_short_name.insertData(name_parts.short_name.data(), name_parts.short_name.length());
         column_database.insertData(name_parts.database.data(), name_parts.database.length());
         column_table.insertData(name_parts.table_name.data(), name_parts.table_name.length());
-        column_id.push_back(id);
+        column_id.push_back(id.toUnderType());
         column_storage.insertData(storage_name.data(), storage_name.length());
 
         for (auto condition_type : ext::range(MAX_CONDITION_TYPE))
diff --git a/src/Storages/System/StorageSystemSettingsProfiles.cpp b/src/Storages/System/StorageSystemSettingsProfiles.cpp
index c726f54a3249..87847fb80bce 100644
--- a/src/Storages/System/StorageSystemSettingsProfiles.cpp
+++ b/src/Storages/System/StorageSystemSettingsProfiles.cpp
@@ -38,7 +38,7 @@ void StorageSystemSettingsProfiles::fillData(MutableColumns & res_columns, Conte
 
     size_t column_index = 0;
     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);
-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();
+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();
     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);
     auto & column_num_elements = assert_cast<ColumnUInt64 &>(*res_columns[column_index++]).getData();
     auto & column_apply_to_all = assert_cast<ColumnUInt8 &>(*res_columns[column_index++]).getData();
@@ -54,7 +54,7 @@ void StorageSystemSettingsProfiles::fillData(MutableColumns & res_columns, Conte
                        const RolesOrUsersSet & apply_to)
     {
         column_name.insertData(name.data(), name.length());
-        column_id.push_back(id);
+        column_id.push_back(id.toUnderType());
         column_storage.insertData(storage_name.data(), storage_name.length());
         column_num_elements.push_back(elements.size());
 
diff --git a/src/Storages/System/StorageSystemUsers.cpp b/src/Storages/System/StorageSystemUsers.cpp
index e60f1372df93..74ac48c145c4 100644
--- a/src/Storages/System/StorageSystemUsers.cpp
+++ b/src/Storages/System/StorageSystemUsers.cpp
@@ -63,7 +63,7 @@ void StorageSystemUsers::fillData(MutableColumns & res_columns, ContextPtr conte
 
     size_t column_index = 0;
     auto & column_name = assert_cast<ColumnString &>(*res_columns[column_index++]);
-    auto & column_id = assert_cast<ColumnUInt128 &>(*res_columns[column_index++]).getData();
+    auto & column_id = assert_cast<ColumnUUID &>(*res_columns[column_index++]).getData();
     auto & column_storage = assert_cast<ColumnString &>(*res_columns[column_index++]);
     auto & column_auth_type = assert_cast<ColumnInt8 &>(*res_columns[column_index++]).getData();
     auto & column_auth_params = assert_cast<ColumnString &>(*res_columns[column_index++]);
@@ -95,7 +95,7 @@ void StorageSystemUsers::fillData(MutableColumns & res_columns, ContextPtr conte
                        const RolesOrUsersSet & grantees)
     {
         column_name.insertData(name.data(), name.length());
-        column_id.push_back(id);
+        column_id.push_back(id.toUnderType());
         column_storage.insertData(storage_name.data(), storage_name.length());
         column_auth_type.push_back(static_cast<Int8>(authentication.getType()));
 
