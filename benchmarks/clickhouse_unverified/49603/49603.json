{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49603,
  "instance_id": "ClickHouse__ClickHouse-49603",
  "issue_numbers": [
    "49143"
  ],
  "base_commit": "2104baabce4392e5b1034c8d04ba6aaf245741df",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 0e899045c7c8..599b64ef43f1 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -26,19 +26,27 @@ SELECT\n \n ## makeDate\n \n-Creates a [Date](../../sql-reference/data-types/date.md) from a year, month and day argument.\n+Creates a [Date](../../sql-reference/data-types/date.md)\n+- from a year, month and day argument, or\n+- from a year and day of year argument.\n \n **Syntax**\n \n ``` sql\n-makeDate(year, month, day)\n+makeDate(year, month, day);\n+makeDate(year, day_of_year);\n ```\n \n+Alias:\n+- `MAKEDATE(year, month, day);`\n+- `MAKEDATE(year, day_of_year);`\n+\n **Arguments**\n \n - `year` \u2014 Year. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).\n - `month` \u2014 Month. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).\n - `day` \u2014 Day. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).\n+- `day_of_year` \u2014 Day of the year. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).\n \n **Returned value**\n \n@@ -48,6 +56,8 @@ Type: [Date](../../sql-reference/data-types/date.md).\n \n **Example**\n \n+Create a Date from a year, month and day:\n+\n ``` sql\n SELECT makeDate(2023, 2, 28) AS Date;\n ```\n@@ -60,6 +70,19 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+Create a Date from a year and day of year argument:\n+\n+``` sql\n+SELECT makeDate(2023, 42) AS Date;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u2510\n+\u2502 2023-02-11 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n ## makeDate32\n \n Like [makeDate](#makeDate) but produces a [Date32](../../sql-reference/data-types/date32.md).\n@@ -108,6 +131,12 @@ Result:\n \n Like [makeDateTime](#makedatetime) but produces a [DateTime64](../../sql-reference/data-types/datetime64.md).\n \n+**Syntax**\n+\n+``` sql\n+makeDateTime32(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])\n+```\n+\n ## timeZone\n \n Returns the timezone of the server.\ndiff --git a/src/Functions/makeDate.cpp b/src/Functions/makeDate.cpp\nindex 97271386286b..1e4f3604c944 100644\n--- a/src/Functions/makeDate.cpp\n+++ b/src/Functions/makeDate.cpp\n@@ -1,5 +1,6 @@\n #include <Functions/IFunction.h>\n #include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDate32.h>\n #include <DataTypes/DataTypeDateTime.h>\n@@ -20,7 +21,6 @@ namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ARGUMENT_OUT_OF_BOUND;\n }\n@@ -28,13 +28,7 @@ namespace ErrorCodes\n namespace\n {\n \n-/// A helper function to simplify comparisons of valid YYYY-MM-DD values for <,>,=\n-inline constexpr Int64 YearMonthDayToSingleInt(Int64 year, Int64 month, Int64 day)\n-{\n-    return year * 512 + month * 32 + day;\n-}\n-\n-/// Common logic to handle numeric arguments like year, month, day, hour, minute, second\n+/// Functions common to makeDate, makeDate32, makeDateTime, makeDateTime64\n class FunctionWithNumericParamsBase : public IFunction\n {\n public:\n@@ -49,36 +43,23 @@ class FunctionWithNumericParamsBase : public IFunction\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n \n-protected:\n-    template <class ArgumentNames>\n-    void checkRequiredArguments(const ColumnsWithTypeAndName & arguments, const ArgumentNames & argument_names, const size_t optional_argument_count) const\n-    {\n-        if (arguments.size() < argument_names.size() || arguments.size() > argument_names.size() + optional_argument_count)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Function {} requires {} to {} arguments, but {} given\",\n-                getName(), argument_names.size(), argument_names.size() + optional_argument_count, arguments.size());\n+    bool isVariadic() const override { return true; }\n \n-        for (size_t i = 0; i < argument_names.size(); ++i)\n-        {\n-            DataTypePtr argument_type = arguments[i].type;\n-            if (!isNumber(argument_type))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Argument '{}' for function {} must be a number\", std::string(argument_names[i]), getName());\n-        }\n-    }\n+    size_t getNumberOfArguments() const override { return 0; }\n \n+protected:\n     template <class ArgumentNames>\n-    void convertRequiredArguments(const ColumnsWithTypeAndName & arguments, const ArgumentNames & argument_names, Columns & converted_arguments) const\n+    Columns convertMandatoryArguments(const ColumnsWithTypeAndName & arguments, const ArgumentNames & argument_names) const\n     {\n+        Columns converted_arguments;\n         const DataTypePtr converted_argument_type = std::make_shared<DataTypeFloat32>();\n-        converted_arguments.clear();\n-        converted_arguments.reserve(arguments.size());\n         for (size_t i = 0; i < argument_names.size(); ++i)\n         {\n             ColumnPtr argument_column = castColumn(arguments[i], converted_argument_type);\n             argument_column = argument_column->convertToFullColumnIfConst();\n             converted_arguments.push_back(argument_column);\n         }\n+        return converted_arguments;\n     }\n };\n \n@@ -87,7 +68,8 @@ template <typename Traits>\n class FunctionMakeDate : public FunctionWithNumericParamsBase\n {\n private:\n-    static constexpr std::array argument_names = {\"year\", \"month\", \"day\"};\n+    static constexpr std::array mandatory_argument_names_year_month_day = {\"year\", \"month\", \"day\"};\n+    static constexpr std::array mandatory_argument_names_year_dayofyear = {\"year\", \"dayofyear\"};\n \n public:\n     static constexpr auto name = Traits::name;\n@@ -96,56 +78,103 @@ class FunctionMakeDate : public FunctionWithNumericParamsBase\n \n     String getName() const override { return name; }\n \n-    bool isVariadic() const override { return false; }\n-\n-    size_t getNumberOfArguments() const override { return argument_names.size(); }\n-\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        checkRequiredArguments(arguments, argument_names, 0);\n+        const bool isYearMonthDayVariant = (arguments.size() == 3);\n+\n+        if (isYearMonthDayVariant)\n+        {\n+            FunctionArgumentDescriptors args{\n+                {mandatory_argument_names_year_month_day[0], &isNumber<IDataType>, nullptr, \"Number\"},\n+                {mandatory_argument_names_year_month_day[1], &isNumber<IDataType>, nullptr, \"Number\"},\n+                {mandatory_argument_names_year_month_day[2], &isNumber<IDataType>, nullptr, \"Number\"}\n+            };\n+            validateFunctionArgumentTypes(*this, arguments, args);\n+        }\n+        else\n+        {\n+            FunctionArgumentDescriptors args{\n+                {mandatory_argument_names_year_dayofyear[0], &isNumber<IDataType>, nullptr, \"Number\"},\n+                {mandatory_argument_names_year_dayofyear[1], &isNumber<IDataType>, nullptr, \"Number\"}\n+            };\n+            validateFunctionArgumentTypes(*this, arguments, args);\n+        }\n \n         return std::make_shared<typename Traits::ReturnDataType>();\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n+        const bool isYearMonthDayVariant = (arguments.size() == 3);\n+\n         Columns converted_arguments;\n-        convertRequiredArguments(arguments, argument_names, converted_arguments);\n+        if (isYearMonthDayVariant)\n+            converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names_year_month_day);\n+        else\n+            converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names_year_dayofyear);\n \n         auto res_column = Traits::ReturnDataType::ColumnType::create(input_rows_count);\n         auto & result_data = res_column->getData();\n \n-        const auto & year_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[0]).getData();\n-        const auto & month_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[1]).getData();\n-        const auto & day_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[2]).getData();\n-\n         const auto & date_lut = DateLUT::instance();\n+        const Int32 max_days_since_epoch = date_lut.makeDayNum(Traits::MAX_DATE[0], Traits::MAX_DATE[1], Traits::MAX_DATE[2]);\n \n-        for (size_t i = 0; i < input_rows_count; ++i)\n+        if (isYearMonthDayVariant)\n         {\n-            const auto year = year_data[i];\n-            const auto month = month_data[i];\n-            const auto day = day_data[i];\n-\n-            Int32 day_num = 0;\n+            const auto & year_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[0]).getData();\n+            const auto & month_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[1]).getData();\n+            const auto & day_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[2]).getData();\n \n-            if (year >= Traits::MIN_YEAR &&\n-                year <= Traits::MAX_YEAR &&\n-                month >= 1 && month <= 12 &&\n-                day >= 1 && day <= 31 &&\n-                YearMonthDayToSingleInt(static_cast<Int64>(year), static_cast<Int64>(month), static_cast<Int64>(day)) <= Traits::MAX_DATE)\n+            for (size_t i = 0; i < input_rows_count; ++i)\n             {\n-                day_num = date_lut.makeDayNum(static_cast<Int16>(year), static_cast<UInt8>(month), static_cast<UInt8>(day));\n+                const auto year = year_data[i];\n+                const auto month = month_data[i];\n+                const auto day = day_data[i];\n+\n+                Int32 day_num = 0;\n+\n+                if (year >= Traits::MIN_YEAR &&\n+                    year <= Traits::MAX_YEAR &&\n+                    month >= 1 && month <= 12 &&\n+                    day >= 1 && day <= 31)\n+                {\n+                    Int32 days_since_epoch = date_lut.makeDayNum(static_cast<Int16>(year), static_cast<UInt8>(month), static_cast<UInt8>(day));\n+                    if (days_since_epoch <= max_days_since_epoch)\n+                        day_num = days_since_epoch;\n+                }\n+\n+                result_data[i] = day_num;\n             }\n+        }\n+        else\n+        {\n+            const auto & year_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[0]).getData();\n+            const auto & dayofyear_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[1]).getData();\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                const auto year = year_data[i];\n+                const auto dayofyear = dayofyear_data[i];\n+\n+                Int32 day_num = 0;\n+\n+                if (year >= Traits::MIN_YEAR &&\n+                    year <= Traits::MAX_YEAR &&\n+                    dayofyear >= 1 && dayofyear <= 365)\n+                {\n+                    Int32 days_since_epoch = date_lut.makeDayNum(static_cast<Int16>(year), 1, 1) + static_cast<Int32>(dayofyear) - 1;\n+                    if (days_since_epoch <= max_days_since_epoch)\n+                        day_num = days_since_epoch;\n+                }\n \n-            result_data[i] = day_num;\n+                result_data[i] = day_num;\n+            }\n         }\n \n         return res_column;\n     }\n };\n \n-/// makeDate(year, month, day)\n struct MakeDateTraits\n {\n     static constexpr auto name = \"makeDate\";\n@@ -154,10 +183,9 @@ struct MakeDateTraits\n     static constexpr auto MIN_YEAR = 1970;\n     static constexpr auto MAX_YEAR = 2149;\n     /// This date has the maximum day number that fits in 16-bit uint\n-    static constexpr auto MAX_DATE = YearMonthDayToSingleInt(MAX_YEAR, 6, 6);\n+    static constexpr std::array MAX_DATE = {MAX_YEAR, 6, 6};\n };\n \n-/// makeDate32(year, month, day)\n struct MakeDate32Traits\n {\n     static constexpr auto name = \"makeDate32\";\n@@ -165,30 +193,14 @@ struct MakeDate32Traits\n \n     static constexpr auto MIN_YEAR = 1900;\n     static constexpr auto MAX_YEAR = 2299;\n-    static constexpr auto MAX_DATE = YearMonthDayToSingleInt(MAX_YEAR, 12, 31);\n+    static constexpr std::array MAX_DATE = {MAX_YEAR, 12, 31};\n };\n \n /// Common implementation for makeDateTime, makeDateTime64\n class FunctionMakeDateTimeBase : public FunctionWithNumericParamsBase\n {\n protected:\n-    static constexpr std::array argument_names = {\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"};\n-\n-public:\n-    bool isVariadic() const override { return true; }\n-\n-    size_t getNumberOfArguments() const override { return 0; }\n-\n-protected:\n-    void checkRequiredArguments(const ColumnsWithTypeAndName & arguments, const size_t optional_argument_count) const\n-    {\n-        FunctionWithNumericParamsBase::checkRequiredArguments(arguments, argument_names, optional_argument_count);\n-    }\n-\n-    void convertRequiredArguments(const ColumnsWithTypeAndName & arguments, Columns & converted_arguments) const\n-    {\n-        FunctionWithNumericParamsBase::convertRequiredArguments(arguments, argument_names, converted_arguments);\n-    }\n+    static constexpr std::array mandatory_argument_names = {\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"};\n \n     template <typename T>\n     static Int64 dateTime(T year, T month, T day_of_month, T hour, T minute, T second, const DateLUTImpl & lut)\n@@ -235,7 +247,7 @@ class FunctionMakeDateTimeBase : public FunctionWithNumericParamsBase\n class FunctionMakeDateTime : public FunctionMakeDateTimeBase\n {\n private:\n-    static constexpr std::array<const char*, 1> optional_argument_names = {\"timezone\"};\n+    static constexpr std::array optional_argument_names = {\"timezone\"};\n \n public:\n     static constexpr auto name = \"makeDateTime\";\n@@ -246,11 +258,24 @@ class FunctionMakeDateTime : public FunctionMakeDateTimeBase\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        checkRequiredArguments(arguments, optional_argument_names.size());\n+        FunctionArgumentDescriptors mandatory_args{\n+            {mandatory_argument_names[0], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[1], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[2], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[3], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[4], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[5], &isNumber<IDataType>, nullptr, \"Number\"}\n+        };\n+\n+        FunctionArgumentDescriptors optional_args{\n+            {optional_argument_names[0], &isString<IDataType>, nullptr, \"String\"}\n+        };\n+\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n \n         /// Optional timezone argument\n         std::string timezone;\n-        if (arguments.size() == argument_names.size() + 1)\n+        if (arguments.size() == mandatory_argument_names.size() + 1)\n             timezone = extractTimezone(arguments.back());\n \n         return std::make_shared<DataTypeDateTime>(timezone);\n@@ -260,11 +285,10 @@ class FunctionMakeDateTime : public FunctionMakeDateTimeBase\n     {\n         /// Optional timezone argument\n         std::string timezone;\n-        if (arguments.size() == argument_names.size() + 1)\n+        if (arguments.size() == mandatory_argument_names.size() + 1)\n             timezone = extractTimezone(arguments.back());\n \n-        Columns converted_arguments;\n-        convertRequiredArguments(arguments, converted_arguments);\n+        Columns converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names);\n \n         auto res_column = ColumnDateTime::create(input_rows_count);\n         auto & result_data = res_column->getData();\n@@ -300,11 +324,11 @@ class FunctionMakeDateTime : public FunctionMakeDateTimeBase\n     }\n };\n \n-/// makeDateTime64(year, month, day, hour, minute, second, [fraction], [precision], [timezone])\n+/// makeDateTime64(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])\n class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase\n {\n private:\n-    static constexpr std::array<const char*, 3> optional_argument_names = {\"fraction\", \"precision\", \"timezone\"};\n+    static constexpr std::array optional_argument_names = {\"fraction\", \"precision\", \"timezone\"};\n     static constexpr UInt8 DEFAULT_PRECISION = 3;\n \n public:\n@@ -316,11 +340,26 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        checkRequiredArguments(arguments, optional_argument_names.size());\n-\n-        if (arguments.size() >= argument_names.size() + 1)\n+        FunctionArgumentDescriptors mandatory_args{\n+            {mandatory_argument_names[0], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[1], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[2], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[3], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[4], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {mandatory_argument_names[5], &isNumber<IDataType>, nullptr, \"Number\"}\n+        };\n+\n+        FunctionArgumentDescriptors optional_args{\n+            {optional_argument_names[0], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {optional_argument_names[1], &isNumber<IDataType>, nullptr, \"Number\"},\n+            {optional_argument_names[2], &isString<IDataType>, nullptr, \"String\"}\n+        };\n+\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n+\n+        if (arguments.size() >= mandatory_argument_names.size() + 1)\n         {\n-            const auto& fraction_argument = arguments[argument_names.size()];\n+            const auto& fraction_argument = arguments[mandatory_argument_names.size()];\n             if (!isNumber(fraction_argument.type))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Argument 'fraction' for function {} must be a number\", getName());\n@@ -328,12 +367,12 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase\n \n         /// Optional precision argument\n         Int64 precision = DEFAULT_PRECISION;\n-        if (arguments.size() >= argument_names.size() + 2)\n-            precision = extractPrecision(arguments[argument_names.size() + 1]);\n+        if (arguments.size() >= mandatory_argument_names.size() + 2)\n+            precision = extractPrecision(arguments[mandatory_argument_names.size() + 1]);\n \n         /// Optional timezone argument\n         std::string timezone;\n-        if (arguments.size() == argument_names.size() + 3)\n+        if (arguments.size() == mandatory_argument_names.size() + 3)\n             timezone = extractTimezone(arguments.back());\n \n         return std::make_shared<DataTypeDateTime64>(precision, timezone);\n@@ -343,22 +382,21 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase\n     {\n         /// Optional precision argument\n         Int64 precision = DEFAULT_PRECISION;\n-        if (arguments.size() >= argument_names.size() + 2)\n-            precision = extractPrecision(arguments[argument_names.size() + 1]);\n+        if (arguments.size() >= mandatory_argument_names.size() + 2)\n+            precision = extractPrecision(arguments[mandatory_argument_names.size() + 1]);\n \n         /// Optional timezone argument\n         std::string timezone;\n-        if (arguments.size() == argument_names.size() + 3)\n+        if (arguments.size() == mandatory_argument_names.size() + 3)\n             timezone = extractTimezone(arguments.back());\n \n-        Columns converted_arguments;\n-        convertRequiredArguments(arguments, converted_arguments);\n+        Columns converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names);\n \n         /// Optional fraction argument\n         const ColumnVector<Float64>::Container * fraction_data = nullptr;\n-        if (arguments.size() >= argument_names.size() + 1)\n+        if (arguments.size() >= mandatory_argument_names.size() + 1)\n         {\n-            ColumnPtr fraction_column = castColumn(arguments[argument_names.size()], std::make_shared<DataTypeFloat64>());\n+            ColumnPtr fraction_column = castColumn(arguments[mandatory_argument_names.size()], std::make_shared<DataTypeFloat64>());\n             fraction_column = fraction_column->convertToFullColumnIfConst();\n             converted_arguments.push_back(fraction_column);\n             fraction_data = &typeid_cast<const ColumnFloat64 &>(*converted_arguments[6]).getData();\n@@ -439,7 +477,7 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase\n \n REGISTER_FUNCTION(MakeDate)\n {\n-    factory.registerFunction<FunctionMakeDate<MakeDateTraits>>();\n+    factory.registerFunction<FunctionMakeDate<MakeDateTraits>>({}, FunctionFactory::CaseInsensitive);\n     factory.registerFunction<FunctionMakeDate<MakeDate32Traits>>();\n     factory.registerFunction<FunctionMakeDateTime>();\n     factory.registerFunction<FunctionMakeDateTime64>();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02242_make_date.reference b/tests/queries/0_stateless/02242_make_date.reference\nindex 0e8500baeb7f..dc85d872607f 100644\n--- a/tests/queries/0_stateless/02242_make_date.reference\n+++ b/tests/queries/0_stateless/02242_make_date.reference\n@@ -56,6 +56,8 @@ Nullable(Date)\n \\N\n \\N\n \\N\n+1980-01-01\n+1980-01-01\n 1984-02-03\n \\N\n \\N\ndiff --git a/tests/queries/0_stateless/02242_make_date.sql b/tests/queries/0_stateless/02242_make_date.sql\nindex 9e66daa2778b..78feabfffb32 100644\n--- a/tests/queries/0_stateless/02242_make_date.sql\n+++ b/tests/queries/0_stateless/02242_make_date.sql\n@@ -79,9 +79,11 @@ select makeDate(1980, NULL, 4);\n select makeDate(1980, 3, NULL);\n \n select makeDate(1980); -- { serverError 42 }\n-select makeDate(1980, 1); -- { serverError 42 }\n select makeDate(1980, 1, 1, 1); -- { serverError 42 }\n \n+select MAKEDATE(1980, 1, 1);\n+select MAKEDATE(1980, 1);\n+\n select makeDate(year, month, day) from (select NULL as year, 2 as month, 3 as day union all select 1984 as year, 2 as month, 3 as day) order by year, month, day;\n \n select makeDate(year, month, day) from (select NULL as year, 2 as month, 3 as day union all select NULL as year, 2 as month, 3 as day) order by year, month, day;\ndiff --git a/tests/queries/0_stateless/02242_make_date_mysql.reference b/tests/queries/0_stateless/02242_make_date_mysql.reference\nnew file mode 100644\nindex 000000000000..0fc51594a8c0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02242_make_date_mysql.reference\n@@ -0,0 +1,25 @@\n+Date\n+Nullable(Date)\n+Nullable(Date)\n+1970-01-01\n+2020-01-08\n+1970-01-01\n+1970-01-01\n+1980-01-09\n+1970-01-01\n+1980-01-09\n+1970-01-01\n+1980-01-09\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+2149-06-06\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-02\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/02242_make_date_mysql.sql b/tests/queries/0_stateless/02242_make_date_mysql.sql\nnew file mode 100644\nindex 000000000000..82d80579788f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02242_make_date_mysql.sql\n@@ -0,0 +1,41 @@\n+select toTypeName(makeDate(1991, 8));\n+select toTypeName(makeDate(cast(1991 as Nullable(UInt64)), 8));\n+select toTypeName(makeDate(1991, cast(8 as Nullable(UInt64))));\n+\n+select makeDate(1970, 01);\n+select makeDate(2020, 08);\n+select makeDate(-1980, 10);\n+select makeDate(1980, -10);\n+select makeDate(1980.0, 9);\n+select makeDate(-1980.0, 9);\n+select makeDate(cast(1980.1 as Decimal(20,5)), 9);\n+select makeDate(cast('-1980.1' as Decimal(20,5)), 9);\n+select makeDate(cast(1980.1 as Float32), 9);\n+select makeDate(cast(-1980.1 as Float32), 9);\n+\n+select makeDate(cast(1980 as Date), 10); -- { serverError 43 }\n+select makeDate(cast(-1980 as Date), 10); -- { serverError 43 }\n+select makeDate(cast(1980 as Date32), 10); -- { serverError 43 }\n+select makeDate(cast(-1980 as Date32), 10); -- { serverError 43 }\n+select makeDate(cast(1980 as DateTime), 10); -- { serverError 43 }\n+select makeDate(cast(-1980 as DateTime), 10); -- { serverError 43 }\n+select makeDate(cast(1980 as DateTime64), 10); -- { serverError 43 }\n+select makeDate(cast(-1980 as DateTime64), 10); -- { serverError 43 }\n+select makeDate('1980', '10'); -- { serverError 43 }\n+select makeDate('-1980', 3); -- { serverError 43 }\n+select makeDate('aa', 3); -- { serverError 43 }\n+select makeDate(1994, 'aa'); -- { serverError 43 }\n+\n+select makeDate(0, 1);\n+select makeDate(19800, 12);\n+select makeDate(2149, 157);\n+select makeDate(2149, 158);\n+select makeDate(1969,355);\n+select makeDate(1969,356);\n+select makeDate(1969,357);\n+select makeDate(1970,0);\n+select makeDate(1970,1);\n+select makeDate(1970,2);\n+\n+select makeDate(NULL, 3);\n+select makeDate(1980, NULL);\ndiff --git a/tests/queries/0_stateless/02243_make_date32.sql b/tests/queries/0_stateless/02243_make_date32.sql\nindex 2cf4ac6b358d..9b0009b33a28 100644\n--- a/tests/queries/0_stateless/02243_make_date32.sql\n+++ b/tests/queries/0_stateless/02243_make_date32.sql\n@@ -78,7 +78,6 @@ select makeDate32(1980, NULL, 4);\n select makeDate32(1980, 3, NULL);\n \n select makeDate32(1980); -- { serverError 42 }\n-select makeDate32(1980, 1); -- { serverError 42 }\n select makeDate32(1980, 1, 1, 1); -- { serverError 42 }\n \n select makeDate32(year, month, day) from (select NULL as year, 2 as month, 3 as day union all select 1984 as year, 2 as month, 3 as day) order by year, month, day;\ndiff --git a/tests/queries/0_stateless/02243_make_date32_mysql.reference b/tests/queries/0_stateless/02243_make_date32_mysql.reference\nnew file mode 100644\nindex 000000000000..07c08a2ec709\n--- /dev/null\n+++ b/tests/queries/0_stateless/02243_make_date32_mysql.reference\n@@ -0,0 +1,26 @@\n+Date32\n+Nullable(Date32)\n+Nullable(Date32)\n+1900-01-01\n+2020-01-08\n+1970-01-01\n+1970-01-01\n+1980-01-09\n+1970-01-01\n+1980-01-09\n+1970-01-01\n+1980-01-09\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+2299-12-31\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+1900-01-01\n+1900-01-02\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/02243_make_date32_mysql.sql b/tests/queries/0_stateless/02243_make_date32_mysql.sql\nnew file mode 100644\nindex 000000000000..4a67dcd80de4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02243_make_date32_mysql.sql\n@@ -0,0 +1,42 @@\n+select toTypeName(makeDate32(1991, 8));\n+select toTypeName(makeDate32(cast(1991 as Nullable(UInt64)), 8));\n+select toTypeName(makeDate32(1991, cast(8 as Nullable(UInt64))));\n+\n+select makeDate32(1900, 01);\n+select makeDate32(2020, 08);\n+select makeDate32(-1980, 10);\n+select makeDate32(1980, -10);\n+select makeDate32(1980.0, 9);\n+select makeDate32(-1980.0, 9);\n+select makeDate32(cast(1980.1 as Decimal(20,5)), 9);\n+select makeDate32(cast('-1980.1' as Decimal(20,5)), 9);\n+select makeDate32(cast(1980.1 as Float32), 9);\n+select makeDate32(cast(-1980.1 as Float32), 9);\n+\n+select makeDate32(cast(1980 as Date), 10); -- { serverError 43 }\n+select makeDate32(cast(-1980 as Date), 10); -- { serverError 43 }\n+select makeDate32(cast(1980 as Date32), 10); -- { serverError 43 }\n+select makeDate32(cast(-1980 as Date32), 10); -- { serverError 43 }\n+select makeDate32(cast(1980 as DateTime), 10); -- { serverError 43 }\n+select makeDate32(cast(-1980 as DateTime), 10); -- { serverError 43 }\n+select makeDate32(cast(1980 as DateTime64), 10); -- { serverError 43 }\n+select makeDate32(cast(-1980 as DateTime64), 10); -- { serverError 43 }\n+select makeDate32('1980', '10'); -- { serverError 43 }\n+select makeDate32('-1980', 3); -- { serverError 43 }\n+select makeDate32('aa', 3); -- { serverError 43 }\n+select makeDate32(1994, 'aa'); -- { serverError 43 }\n+\n+select makeDate32(0, 1);\n+select makeDate32(19800, 12);\n+select makeDate32(2299, 365);\n+select makeDate32(2299, 366);\n+select makeDate32(2300, 1);\n+select makeDate32(1899, 365);\n+select makeDate32(1899, 366);\n+select makeDate32(1899, 367);\n+select makeDate32(1900, 0);\n+select makeDate32(1900, 1);\n+select makeDate32(1900, 2);\n+\n+select makeDate32(NULL, 3);\n+select makeDate32(1980, NULL);\n",
  "problem_statement": "MySQL compatibility: MAKEDATE function support\n**Use case**\r\n\r\nThis is how QuickSight renders count query with grouping by quarter via MySQL:\r\n\r\n```\r\nSELECT MAKEDATE(YEAR(`created`), 1) + INTERVAL QUARTER(`created`) QUARTER - INTERVAL 1 QUARTER AS `f4245df6-e4eb-428b-9181-8644f65ccaec.created_tg`, COUNT(*) AS `count` FROM `cell_towers` GROUP BY MAKEDATE(YEAR(`created`), 1) + INTERVAL QUARTER(`created`) QUARTER - INTERVAL 1 QUARTER ORDER BY MAKEDATE(YEAR(`created`), 1) + INTERVAL QUARTER(`created`) QUARTER - INTERVAL 1 QUARTER DESC LIMIT 2500;\r\n```\r\n\r\nUnfortunately, this fails because the [MAKEDATE](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_makedate) function is not supported\r\n\r\n```\r\n<Error> executeQuery: Code: 46. DB::Exception: Unknown function MAKEDATE. Maybe you meant: ['makeDate','makeDate32']: While processing (MAKEDATE(toYear(created), 1) + toIntervalQuarter(toQuarter(created))) - toIntervalQuarter(1). (UNKNOWN_FUNCTION) (version 23.4.1.1157 (official build)) (from 35.158.127.201:2813) (in query: /* QuickSight 35ce2892-29a1-4b67-9091-94d1977cee7a \r\n {\"partner\":\"QuickSight\",\"entityId\":\"edcf57ec-4f0c-4b8d-8d7c-aab0cd071809\",\"sheetId\":\"d4027bfe-96ab-4ba3-80ef-2452f9b7b49e\",\"visualId\":\"2927351e-9c0b-4a32-a97e-0469bf69e070\"} */\r\n SELECT MAKEDATE(YEAR(`created`), 1) + INTERVAL QUARTER(`created`) QUARTER - INTERVAL 1 QUARTER AS `f4245df6-e4eb-428b-9181-8644f65ccaec.created_tg`, COUNT(*) AS `count` FROM `cell_towers` GROUP BY MAKEDATE(YEAR(`created`), 1) + INTERVAL QUARTER(`created`) QUARTER - INTERVAL 1 QUARTER ORDER BY MAKEDATE(YEAR(`created`), 1) + INTERVAL QUARTER(`created`) QUARTER - INTERVAL 1 QUARTER DESC LIMIT 2500), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xe31fa95 in /usr/bin/clickhouse\r\n1. ? @ 0x126d4f40 in /usr/bin/clickhouse\r\n2. DB::FunctionFactory::getImpl(String const&, std::shared_ptr<DB::Context const>) const @ 0x126d46eb in /usr/bin/clickhouse\r\n3. DB::FunctionFactory::get(String const&, std::shared_ptr<DB::Context const>) const @ 0x126d518a in /usr/bin/clickhouse\r\n4. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x1306cd14 in /usr/bin/clickhouse\r\n5. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x1306d949 in /usr/bin/clickhouse\r\n6. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x1306d949 in /usr/bin/clickhouse\r\n7. ? @ 0x13061355 in /usr/bin/clickhouse\r\n8. DB::ExpressionAnalyzer::getRootActionsNoMakeSet(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::ActionsDAG>&, bool) @ 0x1303ca3d in /usr/bin/clickhouse\r\n9. DB::ExpressionAnalyzer::analyzeAggregation(std::shared_ptr<DB::ActionsDAG>&) @ 0x1303abb7 in /usr/bin/clickhouse\r\n10. DB::ExpressionAnalyzer::ExpressionAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::TreeRewriterResult const> const&, std::shared_ptr<DB::Context const>, unsigned long, bool, bool, std::shared_ptr<DB::PreparedSets>, bool) @ 0x130391b6 in /usr/bin/clickhouse\r\n11. ? @ 0x13a00a33 in /usr/bin/clickhouse\r\n12. ? @ 0x13a093e6 in /usr/bin/clickhouse\r\n13. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context> const&, std::optional<DB::Pipe>, std::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&, std::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::shared_ptr<DB::PreparedSets>) @ 0x13a040d1 in /usr/bin/clickhouse\r\n14. DB::InterpreterSelectWithUnionQuery::buildCurrentChildInterpreter(std::shared_ptr<DB::IAST> const&, std::vector<String, std::allocator<String>> const&) @ 0x13aa42a2 in /usr/bin/clickhouse\r\n15. DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&) @ 0x13aa1f13 in /usr/bin/clickhouse\r\n16. DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x139bb290 in /usr/bin/clickhouse\r\n17. ? @ 0x13dbf9a2 in /usr/bin/clickhouse\r\n18. ? @ 0x13dc612c in /usr/bin/clickhouse\r\n19. DB::MySQLHandler::comQuery(DB::ReadBuffer&) @ 0x14b68d45 in /usr/bin/clickhouse\r\n20. DB::MySQLHandler::run() @ 0x14b65754 in /usr/bin/clickhouse\r\n21. Poco::Net::TCPServerConnection::start() @ 0x17aeb0d4 in /usr/bin/clickhouse\r\n22. Poco::Net::TCPServerDispatcher::run() @ 0x17aec2fb in /usr/bin/clickhouse\r\n23. Poco::PooledThread::run() @ 0x17c6a7a7 in /usr/bin/clickhouse\r\n24. Poco::ThreadImpl::runnableEntry(void*) @ 0x17c681dd in /usr/bin/clickhouse\r\n25. ? @ 0x7f3f3b701609 in ?\r\n26. __clone @ 0x7f3f3b626133 in ?\r\n\r\n2023.04.25 13:11:27.897575 [ 319 ] {} <Error> MySQLHandler: MySQLHandler: Cannot read packet: : Code: 46. DB::Exception: Unknown function MAKEDATE. Maybe you meant: ['makeDate','makeDate32']: While processing (MAKEDATE(toYear(created), 1) + toIntervalQuarter(toQuarter(created))) - toIntervalQuarter(1). (UNKNOWN_FUNCTION), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xe31fa95 in /usr/bin/clickhouse\r\n1. ? @ 0x126d4f40 in /usr/bin/clickhouse\r\n2. DB::FunctionFactory::getImpl(String const&, std::shared_ptr<DB::Context const>) const @ 0x126d46eb in /usr/bin/clickhouse\r\n3. DB::FunctionFactory::get(String const&, std::shared_ptr<DB::Context const>) const @ 0x126d518a in /usr/bin/clickhouse\r\n4. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x1306cd14 in /usr/bin/clickhouse\r\n5. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x1306d949 in /usr/bin/clickhouse\r\n6. DB::ActionsMatcher::visit(DB::ASTFunction const&, std::shared_ptr<DB::IAST> const&, DB::ActionsMatcher::Data&) @ 0x1306d949 in /usr/bin/clickhouse\r\n7. ? @ 0x13061355 in /usr/bin/clickhouse\r\n8. DB::ExpressionAnalyzer::getRootActionsNoMakeSet(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::ActionsDAG>&, bool) @ 0x1303ca3d in /usr/bin/clickhouse\r\n9. DB::ExpressionAnalyzer::analyzeAggregation(std::shared_ptr<DB::ActionsDAG>&) @ 0x1303abb7 in /usr/bin/clickhouse\r\n10. DB::ExpressionAnalyzer::ExpressionAnalyzer(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::TreeRewriterResult const> const&, std::shared_ptr<DB::Context const>, unsigned long, bool, bool, std::shared_ptr<DB::PreparedSets>, bool) @ 0x130391b6 in /usr/bin/clickhouse\r\n11. ? @ 0x13a00a33 in /usr/bin/clickhouse\r\n12. ? @ 0x13a093e6 in /usr/bin/clickhouse\r\n13. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context> const&, std::optional<DB::Pipe>, std::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&, std::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::shared_ptr<DB::PreparedSets>) @ 0x13a040d1 in /usr/bin/clickhouse\r\n14. DB::InterpreterSelectWithUnionQuery::buildCurrentChildInterpreter(std::shared_ptr<DB::IAST> const&, std::vector<String, std::allocator<String>> const&) @ 0x13aa42a2 in /usr/bin/clickhouse\r\n15. DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::shared_ptr<DB::IAST> const&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&, std::vector<String, std::allocator<String>> const&) @ 0x13aa1f13 in /usr/bin/clickhouse\r\n16. DB::InterpreterFactory::get(std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x139bb290 in /usr/bin/clickhouse\r\n17. ? @ 0x13dbf9a2 in /usr/bin/clickhouse\r\n18. ? @ 0x13dc612c in /usr/bin/clickhouse\r\n19. DB::MySQLHandler::comQuery(DB::ReadBuffer&) @ 0x14b68d45 in /usr/bin/clickhouse\r\n20. DB::MySQLHandler::run() @ 0x14b65754 in /usr/bin/clickhouse\r\n21. Poco::Net::TCPServerConnection::start() @ 0x17aeb0d4 in /usr/bin/clickhouse\r\n22. Poco::Net::TCPServerDispatcher::run() @ 0x17aec2fb in /usr/bin/clickhouse\r\n23. Poco::PooledThread::run() @ 0x17c6a7a7 in /usr/bin/clickhouse\r\n24. Poco::ThreadImpl::runnableEntry(void*) @ 0x17c681dd in /usr/bin/clickhouse\r\n25. ? @ 0x7f3f3b701609 in ?\r\n26. __clone @ 0x7f3f3b626133 in ?\r\n (version 23.4.1.1157 (official build))\r\n```\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use: the latest main branch version will do. I used the head Docker image from the beginning of April: `23.4.1.170`\r\n* Which interface to use, if it matters: MySQL\r\n* `CREATE TABLE` statements for all tables involved: use [cell towers](https://clickhouse.com/docs/en/getting-started/example-datasets/cell-towers) dataset, then query via MySQL protocol\r\n\r\n\r\n**Describe the solution you'd like**\r\n\r\nMySQL's [MAKEDATE](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_makedate) function is supported.\r\n\r\n\n",
  "hints_text": "Need alias for https://github.com/ClickHouse/ClickHouse/pull/35628\r\n\r\nPlus allow to use 1 or 2 arguments\r\n\r\n```\r\nSELECT makeDate(2022, 11)\r\n\r\n\r\n0 rows in set. Elapsed: 0.005 sec.\r\n\r\nReceived exception:\r\nCode: 42. DB::Exception: Number of arguments for function makeDate doesn't match: passed 2, should be 3: While processing makeDate(2022, 11). (NUMBER_OF_ARGUMENTS_DOESNT_MATCH)\r\n```",
  "created_at": "2023-05-06T20:13:17Z",
  "modified_files": [
    "docs/en/sql-reference/functions/date-time-functions.md",
    "src/Functions/makeDate.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02242_make_date.reference",
    "tests/queries/0_stateless/02242_make_date.sql",
    "b/tests/queries/0_stateless/02242_make_date_mysql.reference",
    "b/tests/queries/0_stateless/02242_make_date_mysql.sql",
    "tests/queries/0_stateless/02243_make_date32.sql",
    "b/tests/queries/0_stateless/02243_make_date32_mysql.reference",
    "b/tests/queries/0_stateless/02243_make_date32_mysql.sql"
  ]
}