{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47869,
  "instance_id": "ClickHouse__ClickHouse-47869",
  "issue_numbers": [
    "47530"
  ],
  "base_commit": "d105aa5e80998426829f3649f596bbd6ecbbe61a",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-search-functions.md b/docs/en/sql-reference/functions/string-search-functions.md\nindex 58006f98a4c9..c5304c433c62 100644\n--- a/docs/en/sql-reference/functions/string-search-functions.md\n+++ b/docs/en/sql-reference/functions/string-search-functions.md\n@@ -375,7 +375,7 @@ For a case-insensitive search or/and in UTF-8 format use functions `multiSearchA\n In all `multiSearch*` functions the number of needles should be less than 2<sup>8</sup> because of implementation specification.\n :::\n \n-## match(haystack, pattern)\n+## match(haystack, pattern), haystack REGEXP pattern operator\n \n Checks whether string `haystack` matches the regular expression `pattern`. The pattern is an [re2 regular expression](https://github.com/google/re2/wiki/Syntax) which has a more limited syntax than Perl regular expressions.\n \ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 054a22a0c3a7..7b9477c57427 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -2255,6 +2255,7 @@ std::vector<std::pair<const char *, Operator>> ParserExpressionImpl::operators_t\n         {\"ILIKE\",         Operator(\"ilike\",           8,  2)},\n         {\"NOT LIKE\",      Operator(\"notLike\",         8,  2)},\n         {\"NOT ILIKE\",     Operator(\"notILike\",        8,  2)},\n+        {\"REGEXP\",        Operator(\"match\",           8,  2)},\n         {\"IN\",            Operator(\"in\",              8,  2)},\n         {\"NOT IN\",        Operator(\"notIn\",           8,  2)},\n         {\"GLOBAL IN\",     Operator(\"globalIn\",        8,  2)},\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/25401_regexp_operator.reference b/tests/queries/0_stateless/25401_regexp_operator.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/25401_regexp_operator.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/25401_regexp_operator.sql b/tests/queries/0_stateless/25401_regexp_operator.sql\nnew file mode 100644\nindex 000000000000..5a5275bf1ea4\n--- /dev/null\n+++ b/tests/queries/0_stateless/25401_regexp_operator.sql\n@@ -0,0 +1,1 @@\n+SELECT 'ab' REGEXP 'a.*b';\n",
  "problem_statement": "MySQL compatibility: REGEXP operator support\n**Use case**\r\n\r\n_NB: [the cell towers dataset](https://clickhouse.com/docs/en/getting-started/example-datasets/cell-towers/) is used here as an example._\r\n\r\nWhen using Looker Studio with ClickHouse as a pseudo-MySQL data source, the following generated query fails because [REGEXP](https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp) operator is not supported yet:\r\n\r\n```\r\nSELECT AVG(area) AS qt_3rarca233c, COUNT(1) AS qt_6er8nps33c, MAX(range) AS qt_6huada233c, SUM(area) AS qt_b9ehfa233c, MIN(range) AS qt_ufjdha233c, radio \r\nFROM (SELECT * FROM datasets.cell_towers) AS t \r\nWHERE (radio REGEXP '^^C.*$') \r\nGROUP BY radio;\r\n```\r\n\r\nThis limits the usage of the string-type filters in Looker Studio.\r\n\r\nFull stack trace:\r\n\r\n```\r\n2023.03.10 20:18:39.173880 [ 509 ] {mysql:2648:8e360bc1-262a-4bf6-a488-f612f1c0a444} <Debug> executeQuery: (from 74.125.88.49:37438) SELECT AVG(area) AS qt_3rarca233c, COUNT(1) AS qt_6er8nps33c, MAX(range) AS qt_6huada233c, SUM(area) AS qt_b9ehfa233c, MIN(range) AS qt_ufjdha233c, radio FROM (SELECT * FROM datasets.cell_towers) AS t WHERE (radio REGEXP '^^C.*$') GROUP BY radio; (stage: Complete)\r\n2023.03.10 20:18:39.174241 [ 509 ] {mysql:2648:8e360bc1-262a-4bf6-a488-f612f1c0a444} <Error> executeQuery: Code: 62. DB::Exception: Syntax error: failed at position 215 ('REGEXP'): REGEXP '^^C.*$') GROUP BY radio;. Expected one of: token, Dot, Comma, ClosingRoundBracket, OR, AND, BETWEEN, NOT BETWEEN, LIKE, ILIKE, NOT LIKE, NOT ILIKE, IN, NOT IN, GLOBAL IN, GLOBAL NOT IN, MOD, DIV, IS NULL, IS NOT NULL, alias, AS. (SYNTAX_ERROR) (version 23.3.1.387 (official build)) (from 74.125.88.49:37438) (in query: SELECT AVG(area) AS qt_3rarca233c, COUNT(1) AS qt_6er8nps33c, MAX(range) AS qt_6huada233c, SUM(area) AS qt_b9ehfa233c, MIN(range) AS qt_ufjdha233c, radio FROM (SELECT * FROM datasets.cell_towers) AS t WHERE (radio REGEXP '^^C.*$') GROUP BY radio;), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xe0cb6d5 in /usr/bin/clickhouse\r\n1. ? @ 0x8ccf3ed in /usr/bin/clickhouse\r\n2. DB::parseQueryAndMovePosition(DB::IParser&, char const*&, char const*, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, unsigned long, unsigned long) @ 0x14ddbd5f in /usr/bin/clickhouse\r\n3. ? @ 0x13994a3c in /usr/bin/clickhouse\r\n4. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (DB::QueryResultDetails const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x1399cf32 in /usr/bin/clickhouse\r\n5. DB::MySQLHandler::comQuery(DB::ReadBuffer&) @ 0x146f5a13 in /usr/bin/clickhouse\r\n6. DB::MySQLHandler::run() @ 0x146f2502 in /usr/bin/clickhouse\r\n7. Poco::Net::TCPServerConnection::start() @ 0x176321b4 in /usr/bin/clickhouse\r\n8. Poco::Net::TCPServerDispatcher::run() @ 0x176333db in /usr/bin/clickhouse\r\n9. Poco::PooledThread::run() @ 0x177bac87 in /usr/bin/clickhouse\r\n10. Poco::ThreadImpl::runnableEntry(void*) @ 0x177b86bd in /usr/bin/clickhouse\r\n11. ? @ 0x7fcbd2203609 in ?\r\n12. __clone @ 0x7fcbd2128133 in ?\r\n\r\n2023.03.10 20:18:39.174890 [ 509 ] {} <Error> MySQLHandler: MySQLHandler: Cannot read packet: : Code: 62. DB::Exception: Syntax error: failed at position 215 ('REGEXP'): REGEXP '^^C.*$') GROUP BY radio;. Expected one of: token, Dot, Comma, ClosingRoundBracket, OR, AND, BETWEEN, NOT BETWEEN, LIKE, ILIKE, NOT LIKE, NOT ILIKE, IN, NOT IN, GLOBAL IN, GLOBAL NOT IN, MOD, DIV, IS NULL, IS NOT NULL, alias, AS. (SYNTAX_ERROR), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xe0cb6d5 in /usr/bin/clickhouse\r\n1. ? @ 0x8ccf3ed in /usr/bin/clickhouse\r\n2. DB::parseQueryAndMovePosition(DB::IParser&, char const*&, char const*, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, unsigned long, unsigned long) @ 0x14ddbd5f in /usr/bin/clickhouse\r\n3. ? @ 0x13994a3c in /usr/bin/clickhouse\r\n4. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (DB::QueryResultDetails const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x1399cf32 in /usr/bin/clickhouse\r\n5. DB::MySQLHandler::comQuery(DB::ReadBuffer&) @ 0x146f5a13 in /usr/bin/clickhouse\r\n6. DB::MySQLHandler::run() @ 0x146f2502 in /usr/bin/clickhouse\r\n7. Poco::Net::TCPServerConnection::start() @ 0x176321b4 in /usr/bin/clickhouse\r\n8. Poco::Net::TCPServerDispatcher::run() @ 0x176333db in /usr/bin/clickhouse\r\n9. Poco::PooledThread::run() @ 0x177bac87 in /usr/bin/clickhouse\r\n10. Poco::ThreadImpl::runnableEntry(void*) @ 0x177b86bd in /usr/bin/clickhouse\r\n11. ? @ 0x7fcbd2203609 in ?\r\n12. __clone @ 0x7fcbd2128133 in ?\r\n (version 23.3.1.387 (official build))\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\n[REGEXP](https://dev.mysql.com/doc/refman/8.0/en/regexp.html#operator_regexp) operator is supported via MySQL wire protocol.\r\n\r\nCC @alexey-milovidov @mshustov \n",
  "hints_text": "First of, the MySQL SQL syntax and the MySQL wire protocol have nothing to do with each other. Think of them like a language (English, Russian, ...) and the medium that transports sentences of the language (paper, voice, ...).\r\n\r\nLet's only care about the MySQL SQL syntax. There are two aspects:\r\n\r\n1. The regexp syntax. MySQL [utilizes ICU](https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax) for regexp matching which has a much more expressive/richer language than re2 which ClickHouse's [match()](https://clickhouse.com/docs/en/sql-reference/functions/string-search-functions#matchhaystack-pattern) function utilizes (compare [ICU syntax](https://unicode-org.github.io/icu/userguide/strings/regexp.html) vs. [re2 syntax](https://github.com/google/re2/wiki/Syntax)). This means that internally rewriting the ICU regexp into re2 syntax (similar to what ClickHouse does for [LIKE](https://clickhouse.com/docs/en/sql-reference/functions/string-search-functions#likehaystack-pattern-haystack-like-pattern-operator) expressions) is pretty much infeasible. An alternative to rewriting the expression is supporting ICU regexps directly in ClickHouse (i.e. evaluating them in ICU which ClickHouse links already for other purposes). I see four big drawbacks here: 1. 99% of all users don't need the added expressiveness provided by ICU over re2. 2. Besides re2, ClickHouse offers [a set of SQL functions](https://clickhouse.com/docs/en/sql-reference/functions/string-search-functions#multimatchanyhaystack-pattern1-pattern2--patternn) with [vectorscan](https://github.com/VectorCamp/vectorscan) syntax that is also different from re2. Adding a third syntax will likely add further confusion. 3. Most regexp engines (likely including ICU but for sure except re2) are prone to [Regular expression Denial of Service](https://www.usenix.org/conference/usenixsecurity22/presentation/turonova) (ReDoS) attacks. Rejecting malicious regexps is already quite difficult and adding ICU as a third syntax will not help with that. 4. MySQL is only one of many other DBMS (a popular one though), yet general drop-in compatibility with  MySQL's dialect is not realistic. We should rather see which syntactic sugar other DBMS provide and implement these in ClickHouse. Maybe see [my comment](https://github.com/ClickHouse/ClickHouse/pull/46581#discussion_r1117044078) about compat with Spark's SQL dialect. Overall, I think that we should implement re2 regexps and point out in our docs that/how it is different from MySQL.\r\n\r\n2. The `REGEXP` operator. We don't have that indeed but I think it can be added quickly.",
  "created_at": "2023-03-21T21:31:41Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-search-functions.md",
    "src/Parsers/ExpressionListParsers.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/25401_regexp_operator.reference",
    "b/tests/queries/0_stateless/25401_regexp_operator.sql"
  ]
}