diff --git a/base/common/memory.h b/base/common/memory.h
deleted file mode 100644
index e82c019ceaba..000000000000
--- a/base/common/memory.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#pragma once
-
-#include <new>
-#include "defines.h"
-
-#if USE_JEMALLOC
-#    include <jemalloc/jemalloc.h>
-#endif
-
-#if !USE_JEMALLOC || JEMALLOC_VERSION_MAJOR < 4
-#    include <cstdlib>
-#endif
-
-
-namespace Memory
-{
-
-inline ALWAYS_INLINE void * newImpl(std::size_t size)
-{
-    auto * ptr = malloc(size);
-    if (likely(ptr != nullptr))
-        return ptr;
-
-    /// @note no std::get_new_handler logic implemented
-    throw std::bad_alloc{};
-}
-
-inline ALWAYS_INLINE void * newNoExept(std::size_t size) noexcept
-{
-    return malloc(size);
-}
-
-inline ALWAYS_INLINE void deleteImpl(void * ptr) noexcept
-{
-    free(ptr);
-}
-
-#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 4
-
-inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size) noexcept
-{
-    if (unlikely(ptr == nullptr))
-        return;
-
-    sdallocx(ptr, size, 0);
-}
-
-#else
-
-inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size [[maybe_unused]]) noexcept
-{
-    free(ptr);
-}
-
-#endif
-
-}
diff --git a/contrib/croaring-cmake/CMakeLists.txt b/contrib/croaring-cmake/CMakeLists.txt
index f4a5d8a01dce..f0cb378864b5 100644
--- a/contrib/croaring-cmake/CMakeLists.txt
+++ b/contrib/croaring-cmake/CMakeLists.txt
@@ -24,3 +24,19 @@ add_library(roaring ${SRCS})
 target_include_directories(roaring PRIVATE "${LIBRARY_DIR}/include/roaring")
 target_include_directories(roaring SYSTEM BEFORE PUBLIC "${LIBRARY_DIR}/include")
 target_include_directories(roaring SYSTEM BEFORE PUBLIC "${LIBRARY_DIR}/cpp")
+
+# We redirect malloc/free family of functions to different functions that will track memory in ClickHouse.
+# It will make this library depend on linking to 'clickhouse_common_io' library that is not done explicitly via 'target_link_libraries'.
+# And we check that all libraries dependencies are satisfied and all symbols are resolved if we do build with shared libraries.
+# That's why we enable it only in static build.
+# Also note that we exploit implicit function declarations.
+
+if (USE_STATIC_LIBRARIES)
+    target_compile_definitions(roaring PRIVATE
+        -Dmalloc=clickhouse_malloc
+        -Dcalloc=clickhouse_calloc
+        -Drealloc=clickhouse_realloc
+        -Dreallocarray=clickhouse_reallocarray
+        -Dfree=clickhouse_free
+        -Dposix_memalign=clickhouse_posix_memalign)
+endif ()
diff --git a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h
index 067daf6dc3a6..95c7e6075d7c 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h
@@ -44,7 +44,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
 
     void toLarge()
     {
-        rb = std::make_unique<RoaringBitmap>();
+        rb = std::make_shared<RoaringBitmap>();
         for (const auto & x : small)
             rb->add(static_cast<Value>(x.getValue()));
         small.clear();
@@ -114,7 +114,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
             readVarUInt(size, in);
             std::unique_ptr<char[]> buf(new char[size]);
             in.readStrict(buf.get(), size);
-            rb = std::make_unique<RoaringBitmap>(RoaringBitmap::read(buf.get()));
+            rb = std::make_shared<RoaringBitmap>(RoaringBitmap::read(buf.get()));
         }
     }
 
@@ -141,7 +141,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
      */
     std::shared_ptr<RoaringBitmap> getNewRoaringBitmapFromSmall() const
     {
-        std::shared_ptr<RoaringBitmap> ret = std::make_unique<RoaringBitmap>();
+        std::shared_ptr<RoaringBitmap> ret = std::make_shared<RoaringBitmap>();
         for (const auto & x : small)
             ret->add(static_cast<Value>(x.getValue()));
         return ret;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 2853a2e1a811..6c10d3e2f2ba 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -158,6 +158,8 @@ else()
     target_link_libraries (clickhouse_new_delete PRIVATE clickhouse_common_io jemalloc)
 endif()
 
+target_link_libraries (clickhouse_common_io PRIVATE jemalloc)
+
 add_subdirectory(Common/ZooKeeper)
 add_subdirectory(Common/Config)
 
diff --git a/src/Common/CurrentMemoryTracker.cpp b/src/Common/CurrentMemoryTracker.cpp
index d38a5a9c70c9..bf0745e667e7 100644
--- a/src/Common/CurrentMemoryTracker.cpp
+++ b/src/Common/CurrentMemoryTracker.cpp
@@ -3,6 +3,7 @@
 
 #include <Common/CurrentMemoryTracker.h>
 
+
 namespace
 {
 
@@ -36,6 +37,7 @@ namespace
             if (current_thread)
             {
                 current_thread->untracked_memory += size;
+
                 if (current_thread->untracked_memory > current_thread->untracked_memory_limit)
                 {
                     /// Zero untracked before track. If tracker throws out-of-limit we would be able to alloc up to untracked_memory_limit bytes
@@ -54,6 +56,12 @@ namespace
     }
 }
 
+void check()
+{
+    if (auto * memory_tracker = getMemoryTracker())
+        memory_tracker->allocImpl(0, true);
+}
+
 void alloc(Int64 size)
 {
     bool throw_if_memory_exceeded = true;
diff --git a/src/Common/CurrentMemoryTracker.h b/src/Common/CurrentMemoryTracker.h
index 5090b7c36875..2f9ace4291f9 100644
--- a/src/Common/CurrentMemoryTracker.h
+++ b/src/Common/CurrentMemoryTracker.h
@@ -9,4 +9,5 @@ namespace CurrentMemoryTracker
     void allocNoThrow(Int64 size);
     void realloc(Int64 old_size, Int64 new_size);
     void free(Int64 size);
+    void check();
 }
diff --git a/src/Common/clickhouse_malloc.cpp b/src/Common/clickhouse_malloc.cpp
new file mode 100644
index 000000000000..3f69ebdf58dc
--- /dev/null
+++ b/src/Common/clickhouse_malloc.cpp
@@ -0,0 +1,55 @@
+#include <Common/memory.h>
+#include <cstdlib>
+
+
+/** These functions can be substituted instead of regular ones when memory tracking is needed.
+  */
+
+extern "C" void * clickhouse_malloc(size_t size)
+{
+    void * res = malloc(size);
+    if (res)
+        Memory::trackMemory(size);
+    return res;
+}
+
+extern "C" void * clickhouse_calloc(size_t number_of_members, size_t size)
+{
+    void * res = calloc(number_of_members, size);
+    if (res)
+        Memory::trackMemory(number_of_members * size);
+    return res;
+}
+
+extern "C" void * clickhouse_realloc(void * ptr, size_t size)
+{
+    if (ptr)
+        Memory::untrackMemory(ptr);
+    void * res = realloc(ptr, size);
+    if (res)
+        Memory::trackMemory(size);
+    return res;
+}
+
+extern "C" void * clickhouse_reallocarray(void * ptr, size_t number_of_members, size_t size)
+{
+    size_t real_size = 0;
+    if (__builtin_mul_overflow(number_of_members, size, &real_size))
+        return nullptr;
+
+    return clickhouse_realloc(ptr, real_size);
+}
+
+extern "C" void clickhouse_free(void * ptr)
+{
+    Memory::untrackMemory(ptr);
+    free(ptr);
+}
+
+extern "C" int clickhouse_posix_memalign(void ** memptr, size_t alignment, size_t size)
+{
+    int res = posix_memalign(memptr, alignment, size);
+    if (res == 0)
+        Memory::trackMemory(size);
+    return res;
+}
diff --git a/src/Common/memory.cpp b/src/Common/memory.cpp
new file mode 100644
index 000000000000..a79d35720719
--- /dev/null
+++ b/src/Common/memory.cpp
@@ -0,0 +1,25 @@
+#if defined(OS_DARWIN) && defined(BUNDLED_STATIC_JEMALLOC)
+
+extern "C"
+{
+    extern void zone_register();
+}
+
+struct InitializeJemallocZoneAllocatorForOSX
+{
+    InitializeJemallocZoneAllocatorForOSX()
+    {
+        /// In case of OSX jemalloc register itself as a default zone allocator.
+        ///
+        /// But when you link statically then zone_register() will not be called,
+        /// and even will be optimized out:
+        ///
+        /// It is ok to call it twice (i.e. in case of shared libraries)
+        /// Since zone_register() is a no-op if the default zone is already replaced with something.
+        ///
+        /// https://github.com/jemalloc/jemalloc/issues/708
+        zone_register();
+    }
+} initializeJemallocZoneAllocatorForOSX;
+
+#endif
diff --git a/src/Common/memory.h b/src/Common/memory.h
new file mode 100644
index 000000000000..84c6af9a1bef
--- /dev/null
+++ b/src/Common/memory.h
@@ -0,0 +1,108 @@
+#pragma once
+
+#include <new>
+#include <common/defines.h>
+
+#include <Common/CurrentMemoryTracker.h>
+
+#if USE_JEMALLOC
+#    include <jemalloc/jemalloc.h>
+#endif
+
+#if !USE_JEMALLOC || JEMALLOC_VERSION_MAJOR < 4
+#    include <cstdlib>
+#endif
+
+
+namespace Memory
+{
+
+inline ALWAYS_INLINE void * newImpl(std::size_t size)
+{
+    auto * ptr = malloc(size);
+    if (likely(ptr != nullptr))
+        return ptr;
+
+    /// @note no std::get_new_handler logic implemented
+    throw std::bad_alloc{};
+}
+
+inline ALWAYS_INLINE void * newNoExept(std::size_t size) noexcept
+{
+    return malloc(size);
+}
+
+inline ALWAYS_INLINE void deleteImpl(void * ptr) noexcept
+{
+    free(ptr);
+}
+
+#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 4
+
+inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size) noexcept
+{
+    if (unlikely(ptr == nullptr))
+        return;
+
+    sdallocx(ptr, size, 0);
+}
+
+#else
+
+inline ALWAYS_INLINE void deleteSized(void * ptr, std::size_t size [[maybe_unused]]) noexcept
+{
+    free(ptr);
+}
+
+#endif
+
+#if defined(OS_LINUX)
+#   include <malloc.h>
+#elif defined(OS_DARWIN)
+#   include <malloc/malloc.h>
+#endif
+
+
+inline ALWAYS_INLINE size_t getActualAllocationSize(size_t size)
+{
+    size_t actual_size = size;
+
+#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5
+    /// The nallocx() function allocates no memory, but it performs the same size computation as the mallocx() function
+    /// @note je_mallocx() != je_malloc(). It's expected they don't differ much in allocation logic.
+    if (likely(size != 0))
+        actual_size = nallocx(size, 0);
+#endif
+
+    return actual_size;
+}
+
+inline ALWAYS_INLINE void trackMemory(std::size_t size)
+{
+    std::size_t actual_size = getActualAllocationSize(size);
+    CurrentMemoryTracker::allocNoThrow(actual_size);
+}
+
+inline ALWAYS_INLINE void untrackMemory(void * ptr [[maybe_unused]], std::size_t size [[maybe_unused]] = 0) noexcept
+{
+    try
+    {
+#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5
+        /// @note It's also possible to use je_malloc_usable_size() here.
+        if (likely(ptr != nullptr))
+            CurrentMemoryTracker::free(sallocx(ptr, 0));
+#else
+        if (size)
+            CurrentMemoryTracker::free(size);
+#    if defined(_GNU_SOURCE)
+        /// It's innaccurate resource free for sanitizers. malloc_usable_size() result is greater or equal to allocated size.
+        else
+            CurrentMemoryTracker::free(malloc_usable_size(ptr));
+#    endif
+#endif
+    }
+    catch (...)
+    {}
+}
+
+}
diff --git a/src/Common/new_delete.cpp b/src/Common/new_delete.cpp
index 56173fb108a7..fa32d56b350d 100644
--- a/src/Common/new_delete.cpp
+++ b/src/Common/new_delete.cpp
@@ -1,117 +1,34 @@
-#include <common/memory.h>
-#include <Common/CurrentMemoryTracker.h>
-
-#include <iostream>
+#include <Common/memory.h>
 #include <new>
 
-#if defined(OS_LINUX)
-#   include <malloc.h>
-#elif defined(OS_DARWIN)
-#   include <malloc/malloc.h>
-#endif
-
-#if defined(OS_DARWIN) && defined(BUNDLED_STATIC_JEMALLOC)
-extern "C"
-{
-extern void zone_register();
-}
-
-struct InitializeJemallocZoneAllocatorForOSX
-{
-    InitializeJemallocZoneAllocatorForOSX()
-    {
-        /// In case of OSX jemalloc register itself as a default zone allocator.
-        ///
-        /// But when you link statically then zone_register() will not be called,
-        /// and even will be optimized out:
-        ///
-        /// It is ok to call it twice (i.e. in case of shared libraries)
-        /// Since zone_register() is a no-op if the default zone is already replaced with something.
-        ///
-        /// https://github.com/jemalloc/jemalloc/issues/708
-        zone_register();
-    }
-} initializeJemallocZoneAllocatorForOSX;
-#endif
 
 /// Replace default new/delete with memory tracking versions.
 /// @sa https://en.cppreference.com/w/cpp/memory/new/operator_new
 ///     https://en.cppreference.com/w/cpp/memory/new/operator_delete
 
-namespace Memory
-{
-
-inline ALWAYS_INLINE size_t getActualAllocationSize(size_t size)
-{
-    size_t actual_size = size;
-
-#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5
-    /// The nallocx() function allocates no memory, but it performs the same size computation as the mallocx() function
-    /// @note je_mallocx() != je_malloc(). It's expected they don't differ much in allocation logic.
-    if (likely(size != 0))
-        actual_size = nallocx(size, 0);
-#endif
-
-    return actual_size;
-}
-
-inline ALWAYS_INLINE void trackMemory(std::size_t size)
-{
-    std::size_t actual_size = getActualAllocationSize(size);
-    CurrentMemoryTracker::allocNoThrow(actual_size);
-}
-
-inline ALWAYS_INLINE void untrackMemory(void * ptr [[maybe_unused]], std::size_t size [[maybe_unused]] = 0) noexcept
-{
-    try
-    {
-#if USE_JEMALLOC && JEMALLOC_VERSION_MAJOR >= 5
-        /// @note It's also possible to use je_malloc_usable_size() here.
-        if (likely(ptr != nullptr))
-            CurrentMemoryTracker::free(sallocx(ptr, 0));
-#else
-        if (size)
-            CurrentMemoryTracker::free(size);
-#    if defined(_GNU_SOURCE)
-        /// It's innaccurate resource free for sanitizers. malloc_usable_size() result is greater or equal to allocated size.
-        else
-            CurrentMemoryTracker::free(malloc_usable_size(ptr));
-#    endif
-#endif
-    }
-    catch (...)
-    {}
-}
-
-}
-
 /// new
 
 void * operator new(std::size_t size)
 {
     Memory::trackMemory(size);
-
     return Memory::newImpl(size);
 }
 
 void * operator new[](std::size_t size)
 {
     Memory::trackMemory(size);
-
     return Memory::newImpl(size);
 }
 
 void * operator new(std::size_t size, const std::nothrow_t &) noexcept
 {
     Memory::trackMemory(size);
-
     return Memory::newNoExept(size);
 }
 
 void * operator new[](std::size_t size, const std::nothrow_t &) noexcept
 {
     Memory::trackMemory(size);
-
     return Memory::newNoExept(size);
 }
 
diff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp
index 7ffae761c0c5..69ad1d56359a 100644
--- a/src/Interpreters/Aggregator.cpp
+++ b/src/Interpreters/Aggregator.cpp
@@ -1193,6 +1193,9 @@ bool Aggregator::checkLimits(size_t result_size, bool & no_more_keys) const
         }
     }
 
+    /// Some aggregate functions cannot throw exceptions on allocations (e.g. from C malloc)
+    /// but still tracks memory. Check it here.
+    CurrentMemoryTracker::check();
     return true;
 }
 
