{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36430,
  "instance_id": "ClickHouse__ClickHouse-36430",
  "issue_numbers": [
    "36416"
  ],
  "base_commit": "2f38e7bc5c2113935ab86260439bb543a1737291",
  "patch": "diff --git a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\nindex ca523e6806cc..a3ffaafa4dbc 100644\n--- a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\n+++ b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\n@@ -12,6 +12,7 @@\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTAsterisk.h>\n #include <Parsers/ASTColumnsMatcher.h>\n+#include <Parsers/ASTColumnsTransformers.h>\n #include <Parsers/ASTQualifiedAsterisk.h>\n #include <Parsers/ParserTablesInSelectQuery.h>\n #include <Parsers/ExpressionListParsers.h>\n@@ -81,6 +82,7 @@ class ExtractAsterisksMatcher\n         /// By default should_add_column_predicate returns true for any column name\n         void addTableColumns(\n             const String & table_name,\n+            ASTs & columns,\n             ShouldAddColumnPredicate should_add_column_predicate = [](const String &) { return true; })\n         {\n             auto it = table_columns.find(table_name);\n@@ -105,7 +107,7 @@ class ExtractAsterisksMatcher\n                     else\n                         identifier = std::make_shared<ASTIdentifier>(std::vector<String>{it->first, column.name});\n \n-                    new_select_expression_list->children.emplace_back(std::move(identifier));\n+                    columns.emplace_back(std::move(identifier));\n                 }\n             }\n         }\n@@ -129,14 +131,18 @@ class ExtractAsterisksMatcher\n \n         for (const auto & child : node.children)\n         {\n-            if (child->as<ASTAsterisk>())\n+            ASTs columns;\n+            if (const auto * asterisk = child->as<ASTAsterisk>())\n             {\n                 has_asterisks = true;\n \n                 for (auto & table_name : data.tables_order)\n-                    data.addTableColumns(table_name);\n+                    data.addTableColumns(table_name, columns);\n+\n+                for (const auto & transformer : asterisk->children)\n+                    IASTColumnsTransformer::transform(transformer, columns);\n             }\n-            else if (child->as<ASTQualifiedAsterisk>())\n+            else if (const auto * qualified_asterisk = child->as<ASTQualifiedAsterisk>())\n             {\n                 has_asterisks = true;\n \n@@ -144,17 +150,44 @@ class ExtractAsterisksMatcher\n                     throw Exception(\"Logical error: qualified asterisk must have exactly one child\", ErrorCodes::LOGICAL_ERROR);\n                 auto & identifier = child->children[0]->as<ASTTableIdentifier &>();\n \n-                data.addTableColumns(identifier.name());\n+                data.addTableColumns(identifier.name(), columns);\n+\n+                // QualifiedAsterisk's transformers start to appear at child 1\n+                for (auto it = qualified_asterisk->children.begin() + 1; it != qualified_asterisk->children.end(); ++it)\n+                {\n+                    IASTColumnsTransformer::transform(*it, columns);\n+                }\n             }\n-            else if (auto * columns_matcher = child->as<ASTColumnsMatcher>())\n+            else if (const auto * columns_list_matcher = child->as<ASTColumnsListMatcher>())\n+            {\n+                has_asterisks = true;\n+\n+                for (const auto & ident : columns_list_matcher->column_list->children)\n+                    columns.emplace_back(ident->clone());\n+\n+                for (const auto & transformer : columns_list_matcher->children)\n+                    IASTColumnsTransformer::transform(transformer, columns);\n+            }\n+            else if (const auto * columns_regexp_matcher = child->as<ASTColumnsRegexpMatcher>())\n             {\n                 has_asterisks = true;\n \n                 for (auto & table_name : data.tables_order)\n-                    data.addTableColumns(table_name, [&](const String & column_name) { return columns_matcher->isColumnMatching(column_name); });\n+                    data.addTableColumns(\n+                        table_name,\n+                        columns,\n+                        [&](const String & column_name) { return columns_regexp_matcher->isColumnMatching(column_name); });\n+\n+                for (const auto & transformer : columns_regexp_matcher->children)\n+                    IASTColumnsTransformer::transform(transformer, columns);\n             }\n             else\n                 data.new_select_expression_list->children.push_back(child);\n+\n+            data.new_select_expression_list->children.insert(\n+                data.new_select_expression_list->children.end(),\n+                std::make_move_iterator(columns.begin()),\n+                std::make_move_iterator(columns.end()));\n         }\n \n         if (!has_asterisks)\ndiff --git a/src/Interpreters/PredicateRewriteVisitor.cpp b/src/Interpreters/PredicateRewriteVisitor.cpp\nindex 74ecc247eb1f..910c846d58b9 100644\n--- a/src/Interpreters/PredicateRewriteVisitor.cpp\n+++ b/src/Interpreters/PredicateRewriteVisitor.cpp\n@@ -96,8 +96,8 @@ void PredicateRewriteVisitorData::visitOtherInternalSelect(ASTSelectQuery & sele\n     size_t alias_index = 0;\n     for (auto & ref_select : temp_select_query->refSelect()->children)\n     {\n-        if (!ref_select->as<ASTAsterisk>() && !ref_select->as<ASTQualifiedAsterisk>() && !ref_select->as<ASTColumnsMatcher>() &&\n-            !ref_select->as<ASTIdentifier>())\n+        if (!ref_select->as<ASTAsterisk>() && !ref_select->as<ASTQualifiedAsterisk>() && !ref_select->as<ASTColumnsListMatcher>()\n+            && !ref_select->as<ASTColumnsRegexpMatcher>() && !ref_select->as<ASTIdentifier>())\n         {\n             if (const auto & alias = ref_select->tryGetAlias(); alias.empty())\n                 ref_select->setAlias(\"--predicate_optimizer_\" + toString(alias_index++));\ndiff --git a/src/Interpreters/TranslateQualifiedNamesVisitor.cpp b/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\nindex 6f1c48135eb3..35fb0828b3e5 100644\n--- a/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n+++ b/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n@@ -196,7 +196,7 @@ void TranslateQualifiedNamesMatcher::visit(ASTExpressionList & node, const ASTPt\n         bool has_asterisk = false;\n         for (const auto & child : node.children)\n         {\n-            if (child->as<ASTAsterisk>() || child->as<ASTColumnsMatcher>())\n+            if (child->as<ASTAsterisk>() || child->as<ASTColumnsListMatcher>() || child->as<ASTColumnsRegexpMatcher>())\n             {\n                 if (tables_with_columns.empty())\n                     throw Exception(\"An asterisk cannot be replaced with empty columns.\", ErrorCodes::LOGICAL_ERROR);\n@@ -229,47 +229,40 @@ void TranslateQualifiedNamesMatcher::visit(ASTExpressionList & node, const ASTPt\n                     for (const auto & column : *cols)\n                     {\n                         if (first_table || !data.join_using_columns.contains(column.name))\n-                        {\n                             addIdentifier(columns, table.table, column.name);\n-                        }\n                     }\n                 }\n-\n                 first_table = false;\n             }\n+\n             for (const auto & transformer : asterisk->children)\n-            {\n                 IASTColumnsTransformer::transform(transformer, columns);\n-            }\n         }\n-        else if (const auto * asterisk_pattern = child->as<ASTColumnsMatcher>())\n+        else if (auto * asterisk_column_list = child->as<ASTColumnsListMatcher>())\n         {\n-            if (asterisk_pattern->column_list)\n-            {\n-                for (const auto & ident : asterisk_pattern->column_list->children)\n-                    columns.emplace_back(ident->clone());\n-            }\n-            else\n+            for (const auto & ident : asterisk_column_list->column_list->children)\n+                columns.emplace_back(ident->clone());\n+\n+            for (const auto & transformer : asterisk_column_list->children)\n+                IASTColumnsTransformer::transform(transformer, columns);\n+        }\n+        else if (const auto * asterisk_regexp_pattern = child->as<ASTColumnsRegexpMatcher>())\n+        {\n+            bool first_table = true;\n+            for (const auto & table : tables_with_columns)\n             {\n-                bool first_table = true;\n-                for (const auto & table : tables_with_columns)\n+                for (const auto & column : table.columns)\n                 {\n-                    for (const auto & column : table.columns)\n+                    if (asterisk_regexp_pattern->isColumnMatching(column.name) && (first_table || !data.join_using_columns.count(column.name)))\n                     {\n-                        if (asterisk_pattern->isColumnMatching(column.name) && (first_table || !data.join_using_columns.contains(column.name)))\n-                        {\n-                            addIdentifier(columns, table.table, column.name);\n-                        }\n+                        addIdentifier(columns, table.table, column.name);\n                     }\n-\n-                    first_table = false;\n                 }\n+                first_table = false;\n             }\n-            // ColumnsMatcher's transformers start to appear at child 1\n-            for (auto it = asterisk_pattern->children.begin() + 1; it != asterisk_pattern->children.end(); ++it)\n-            {\n-                IASTColumnsTransformer::transform(*it, columns);\n-            }\n+\n+            for (const auto & transformer : asterisk_regexp_pattern->children)\n+                IASTColumnsTransformer::transform(transformer, columns);\n         }\n         else if (const auto * qualified_asterisk = child->as<ASTQualifiedAsterisk>())\n         {\n@@ -280,12 +273,11 @@ void TranslateQualifiedNamesMatcher::visit(ASTExpressionList & node, const ASTPt\n                 if (ident_db_and_name.satisfies(table.table, true))\n                 {\n                     for (const auto & column : table.columns)\n-                    {\n                         addIdentifier(columns, table.table, column.name);\n-                    }\n                     break;\n                 }\n             }\n+\n             // QualifiedAsterisk's transformers start to appear at child 1\n             for (auto it = qualified_asterisk->children.begin() + 1; it != qualified_asterisk->children.end(); ++it)\n             {\ndiff --git a/src/Parsers/ASTAsterisk.cpp b/src/Parsers/ASTAsterisk.cpp\nindex ed733e62ca35..e2f45d04fa4a 100644\n--- a/src/Parsers/ASTAsterisk.cpp\n+++ b/src/Parsers/ASTAsterisk.cpp\n@@ -17,6 +17,8 @@ void ASTAsterisk::appendColumnName(WriteBuffer & ostr) const { ostr.write('*');\n void ASTAsterisk::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n     settings.ostr << \"*\";\n+\n+    /// Format column transformers\n     for (const auto & child : children)\n     {\n         settings.ostr << ' ';\ndiff --git a/src/Parsers/ASTColumnsMatcher.cpp b/src/Parsers/ASTColumnsMatcher.cpp\nindex 45799cb7ffef..8f167f99b373 100644\n--- a/src/Parsers/ASTColumnsMatcher.cpp\n+++ b/src/Parsers/ASTColumnsMatcher.cpp\n@@ -1,64 +1,117 @@\n-#include \"ASTColumnsMatcher.h\"\n+#include <Parsers/ASTColumnsMatcher.h>\n+\n+#include <IO/Operators.h>\n #include <IO/WriteHelpers.h>\n-#include <Common/quoteString.h>\n #include <re2/re2.h>\n #include <Common/SipHash.h>\n-#include <IO/Operators.h>\n+#include <Common/quoteString.h>\n \n \n namespace DB\n {\n+\n namespace ErrorCodes\n {\n     extern const int CANNOT_COMPILE_REGEXP;\n }\n \n-ASTPtr ASTColumnsMatcher::clone() const\n+ASTPtr ASTColumnsRegexpMatcher::clone() const\n {\n-    auto clone = std::make_shared<ASTColumnsMatcher>(*this);\n+    auto clone = std::make_shared<ASTColumnsRegexpMatcher>(*this);\n     clone->cloneChildren();\n     return clone;\n }\n \n-void ASTColumnsMatcher::appendColumnName(WriteBuffer & ostr) const { writeString(original_pattern, ostr); }\n+void ASTColumnsRegexpMatcher::appendColumnName(WriteBuffer & ostr) const\n+{\n+    writeCString(\"COLUMNS(\", ostr);\n+    writeQuotedString(original_pattern, ostr);\n+    writeChar(')', ostr);\n+}\n \n-void ASTColumnsMatcher::updateTreeHashImpl(SipHash & hash_state) const\n+void ASTColumnsRegexpMatcher::updateTreeHashImpl(SipHash & hash_state) const\n {\n     hash_state.update(original_pattern.size());\n     hash_state.update(original_pattern);\n     IAST::updateTreeHashImpl(hash_state);\n }\n \n-void ASTColumnsMatcher::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+void ASTColumnsRegexpMatcher::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"COLUMNS\" << (settings.hilite ? hilite_none : \"\") << \"(\";\n-    if (column_list)\n-    {\n-        frame.expression_list_prepend_whitespace = false;\n-        column_list->formatImpl(settings, state, frame);\n-    }\n-    else\n-        settings.ostr << quoteString(original_pattern);\n+    settings.ostr << quoteString(original_pattern);\n     settings.ostr << \")\";\n-    for (ASTs::const_iterator it = children.begin() + 1; it != children.end(); ++it)\n+\n+    /// Format column transformers\n+    for (const auto & child : children)\n     {\n         settings.ostr << ' ';\n-        (*it)->formatImpl(settings, state, frame);\n+        child->formatImpl(settings, state, frame);\n     }\n }\n \n-void ASTColumnsMatcher::setPattern(String pattern)\n+void ASTColumnsRegexpMatcher::setPattern(String pattern)\n {\n     original_pattern = std::move(pattern);\n     column_matcher = std::make_shared<RE2>(original_pattern, RE2::Quiet);\n     if (!column_matcher->ok())\n-        throw DB::Exception(\"COLUMNS pattern \" + original_pattern + \" cannot be compiled: \" + column_matcher->error(), DB::ErrorCodes::CANNOT_COMPILE_REGEXP);\n+        throw DB::Exception(\n+            \"COLUMNS pattern \" + original_pattern + \" cannot be compiled: \" + column_matcher->error(),\n+            DB::ErrorCodes::CANNOT_COMPILE_REGEXP);\n }\n \n-bool ASTColumnsMatcher::isColumnMatching(const String & column_name) const\n+bool ASTColumnsRegexpMatcher::isColumnMatching(const String & column_name) const\n {\n     return RE2::PartialMatch(column_name, *column_matcher);\n }\n \n+ASTPtr ASTColumnsListMatcher::clone() const\n+{\n+    auto clone = std::make_shared<ASTColumnsListMatcher>(*this);\n+    clone->column_list = column_list->clone();\n+    clone->cloneChildren();\n+    return clone;\n+}\n+\n+void ASTColumnsListMatcher::updateTreeHashImpl(SipHash & hash_state) const\n+{\n+    column_list->updateTreeHash(hash_state);\n+    IAST::updateTreeHashImpl(hash_state);\n+}\n+\n+void ASTColumnsListMatcher::appendColumnName(WriteBuffer & ostr) const\n+{\n+    writeCString(\"COLUMNS(\", ostr);\n+    for (auto it = column_list->children.begin(); it != column_list->children.end(); ++it)\n+    {\n+        if (it != column_list->children.begin())\n+            writeCString(\", \", ostr);\n+\n+        (*it)->appendColumnName(ostr);\n+    }\n+    writeChar(')', ostr);\n+}\n+\n+void ASTColumnsListMatcher::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+{\n+    settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"COLUMNS\" << (settings.hilite ? hilite_none : \"\") << \"(\";\n+\n+    for (ASTs::const_iterator it = column_list->children.begin(); it != column_list->children.end(); ++it)\n+    {\n+        if (it != column_list->children.begin())\n+        {\n+            settings.ostr << \", \";\n+        }\n+        (*it)->formatImpl(settings, state, frame);\n+    }\n+    settings.ostr << \")\";\n+\n+    /// Format column transformers\n+    for (const auto & child : children)\n+    {\n+        settings.ostr << ' ';\n+        child->formatImpl(settings, state, frame);\n+    }\n+}\n \n }\ndiff --git a/src/Parsers/ASTColumnsMatcher.h b/src/Parsers/ASTColumnsMatcher.h\nindex 76ece9c95cc5..5aaf3cbe30d3 100644\n--- a/src/Parsers/ASTColumnsMatcher.h\n+++ b/src/Parsers/ASTColumnsMatcher.h\n@@ -2,10 +2,9 @@\n \n #include <Parsers/IAST.h>\n \n-\n namespace re2\n {\n-    class RE2;\n+class RE2;\n }\n \n \n@@ -14,21 +13,13 @@ namespace DB\n \n class WriteBuffer;\n \n-namespace ErrorCodes\n-{\n-}\n-\n-struct AsteriskSemantic;\n-struct AsteriskSemanticImpl;\n-\n-\n /** SELECT COLUMNS('regexp') is expanded to multiple columns like * (asterisk).\n   * Optional transformers can be attached to further manipulate these expanded columns.\n   */\n-class ASTColumnsMatcher : public IAST\n+class ASTColumnsRegexpMatcher : public IAST\n {\n public:\n-    String getID(char) const override { return \"ColumnsMatcher\"; }\n+    String getID(char) const override { return \"ColumnsRegexpMatcher\"; }\n     ASTPtr clone() const override;\n \n     void appendColumnName(WriteBuffer & ostr) const override;\n@@ -36,17 +27,26 @@ class ASTColumnsMatcher : public IAST\n     bool isColumnMatching(const String & column_name) const;\n     void updateTreeHashImpl(SipHash & hash_state) const override;\n \n-    ASTPtr column_list;\n-\n protected:\n     void formatImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;\n \n private:\n     std::shared_ptr<re2::RE2> column_matcher;\n     String original_pattern;\n-    std::shared_ptr<AsteriskSemanticImpl> semantic; /// pimpl\n+};\n \n-    friend struct AsteriskSemantic;\n+/// Same as the above but use a list of column names to do matching.\n+class ASTColumnsListMatcher : public IAST\n+{\n+public:\n+    String getID(char) const override { return \"ColumnsListMatcher\"; }\n+    ASTPtr clone() const override;\n+    void appendColumnName(WriteBuffer & ostr) const override;\n+    void updateTreeHashImpl(SipHash & hash_state) const override;\n+\n+    ASTPtr column_list;\n+protected:\n+    void formatImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;\n };\n \n \ndiff --git a/src/Parsers/ASTColumnsTransformers.cpp b/src/Parsers/ASTColumnsTransformers.cpp\nindex 451ecf0d4dd0..d90d1e747f4a 100644\n--- a/src/Parsers/ASTColumnsTransformers.cpp\n+++ b/src/Parsers/ASTColumnsTransformers.cpp\n@@ -105,6 +105,49 @@ void ASTColumnsApplyTransformer::transform(ASTs & nodes) const\n     }\n }\n \n+void ASTColumnsApplyTransformer::appendColumnName(WriteBuffer & ostr) const\n+{\n+    writeCString(\"APPLY \", ostr);\n+    if (!column_name_prefix.empty())\n+        writeChar('(', ostr);\n+\n+    if (lambda)\n+        lambda->appendColumnName(ostr);\n+    else\n+    {\n+        writeString(func_name, ostr);\n+\n+        if (parameters)\n+            parameters->appendColumnName(ostr);\n+    }\n+\n+    if (!column_name_prefix.empty())\n+    {\n+        writeCString(\", '\", ostr);\n+        writeString(column_name_prefix, ostr);\n+        writeCString(\"')\", ostr);\n+    }\n+}\n+\n+void ASTColumnsApplyTransformer::updateTreeHashImpl(SipHash & hash_state) const\n+{\n+    hash_state.update(func_name.size());\n+    hash_state.update(func_name);\n+    if (parameters)\n+        parameters->updateTreeHashImpl(hash_state);\n+\n+    if (lambda)\n+        lambda->updateTreeHashImpl(hash_state);\n+\n+    hash_state.update(lambda_arg.size());\n+    hash_state.update(lambda_arg);\n+\n+    hash_state.update(column_name_prefix.size());\n+    hash_state.update(column_name_prefix);\n+\n+    IAST::updateTreeHashImpl(hash_state);\n+}\n+\n void ASTColumnsExceptTransformer::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"EXCEPT\" << (is_strict ? \" STRICT \" : \" \") << (settings.hilite ? hilite_none : \"\");\n@@ -128,6 +171,38 @@ void ASTColumnsExceptTransformer::formatImpl(const FormatSettings & settings, Fo\n         settings.ostr << \")\";\n }\n \n+void ASTColumnsExceptTransformer::appendColumnName(WriteBuffer & ostr) const\n+{\n+    writeCString(\"EXCEPT \", ostr);\n+    if (is_strict)\n+        writeCString(\"STRICT \", ostr);\n+\n+    if (children.size() > 1)\n+        writeChar('(', ostr);\n+\n+    for (ASTs::const_iterator it = children.begin(); it != children.end(); ++it)\n+    {\n+        if (it != children.begin())\n+            writeCString(\", \", ostr);\n+        (*it)->appendColumnName(ostr);\n+    }\n+\n+    if (!original_pattern.empty())\n+        writeQuotedString(original_pattern, ostr);\n+\n+    if (children.size() > 1)\n+        writeChar(')', ostr);\n+}\n+\n+void ASTColumnsExceptTransformer::updateTreeHashImpl(SipHash & hash_state) const\n+{\n+    hash_state.update(is_strict);\n+    hash_state.update(original_pattern.size());\n+    hash_state.update(original_pattern);\n+\n+    IAST::updateTreeHashImpl(hash_state);\n+}\n+\n void ASTColumnsExceptTransformer::transform(ASTs & nodes) const\n {\n     std::set<String> expected_columns;\n@@ -201,6 +276,21 @@ void ASTColumnsReplaceTransformer::Replacement::formatImpl(\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\") << backQuoteIfNeed(name);\n }\n \n+void ASTColumnsReplaceTransformer::Replacement::appendColumnName(WriteBuffer & ostr) const\n+{\n+    expr->appendColumnName(ostr);\n+    writeCString(\" AS \", ostr);\n+    writeProbablyBackQuotedString(name, ostr);\n+}\n+\n+void ASTColumnsReplaceTransformer::Replacement::updateTreeHashImpl(SipHash & hash_state) const\n+{\n+    hash_state.update(name.size());\n+    hash_state.update(name);\n+    expr->updateTreeHashImpl(hash_state);\n+    IAST::updateTreeHashImpl(hash_state);\n+}\n+\n void ASTColumnsReplaceTransformer::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \"REPLACE\" << (is_strict ? \" STRICT \" : \" \") << (settings.hilite ? hilite_none : \"\");\n@@ -211,9 +301,8 @@ void ASTColumnsReplaceTransformer::formatImpl(const FormatSettings & settings, F\n     for (ASTs::const_iterator it = children.begin(); it != children.end(); ++it)\n     {\n         if (it != children.begin())\n-        {\n             settings.ostr << \", \";\n-        }\n+\n         (*it)->formatImpl(settings, state, frame);\n     }\n \n@@ -221,6 +310,32 @@ void ASTColumnsReplaceTransformer::formatImpl(const FormatSettings & settings, F\n         settings.ostr << \")\";\n }\n \n+void ASTColumnsReplaceTransformer::appendColumnName(WriteBuffer & ostr) const\n+{\n+    writeCString(\"REPLACE \", ostr);\n+    if (is_strict)\n+        writeCString(\"STRICT \", ostr);\n+\n+    if (children.size() > 1)\n+        writeChar('(', ostr);\n+\n+    for (ASTs::const_iterator it = children.begin(); it != children.end(); ++it)\n+    {\n+        if (it != children.begin())\n+            writeCString(\", \", ostr);\n+        (*it)->appendColumnName(ostr);\n+    }\n+\n+    if (children.size() > 1)\n+        writeChar(')', ostr);\n+}\n+\n+void ASTColumnsReplaceTransformer::updateTreeHashImpl(SipHash & hash_state) const\n+{\n+    hash_state.update(is_strict);\n+    IAST::updateTreeHashImpl(hash_state);\n+}\n+\n void ASTColumnsReplaceTransformer::replaceChildren(ASTPtr & node, const ASTPtr & replacement, const String & name)\n {\n     for (auto & child : node->children)\ndiff --git a/src/Parsers/ASTColumnsTransformers.h b/src/Parsers/ASTColumnsTransformers.h\nindex 1064beb44bd2..0f16f6b93e7f 100644\n--- a/src/Parsers/ASTColumnsTransformers.h\n+++ b/src/Parsers/ASTColumnsTransformers.h\n@@ -30,6 +30,8 @@ class ASTColumnsApplyTransformer : public IASTColumnsTransformer\n         return res;\n     }\n     void transform(ASTs & nodes) const override;\n+    void appendColumnName(WriteBuffer & ostr) const override;\n+    void updateTreeHashImpl(SipHash & hash_state) const override;\n \n     // Case 1  APPLY (quantile(0.9))\n     String func_name;\n@@ -59,6 +61,8 @@ class ASTColumnsExceptTransformer : public IASTColumnsTransformer\n     void transform(ASTs & nodes) const override;\n     void setPattern(String pattern);\n     bool isColumnMatching(const String & column_name) const;\n+    void appendColumnName(WriteBuffer & ostr) const override;\n+    void updateTreeHashImpl(SipHash & hash_state) const override;\n \n protected:\n     void formatImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;\n@@ -76,12 +80,13 @@ class ASTColumnsReplaceTransformer : public IASTColumnsTransformer\n         ASTPtr clone() const override\n         {\n             auto replacement = std::make_shared<Replacement>(*this);\n-            replacement->children.clear();\n             replacement->expr = expr->clone();\n-            replacement->children.push_back(replacement->expr);\n             return replacement;\n         }\n \n+        void appendColumnName(WriteBuffer & ostr) const override;\n+        void updateTreeHashImpl(SipHash & hash_state) const override;\n+\n         String name;\n         ASTPtr expr;\n \n@@ -98,6 +103,8 @@ class ASTColumnsReplaceTransformer : public IASTColumnsTransformer\n         return clone;\n     }\n     void transform(ASTs & nodes) const override;\n+    void appendColumnName(WriteBuffer & ostr) const override;\n+    void updateTreeHashImpl(SipHash & hash_state) const override;\n \n protected:\n     void formatImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;\ndiff --git a/src/Parsers/ASTQualifiedAsterisk.cpp b/src/Parsers/ASTQualifiedAsterisk.cpp\nindex 2491dcb36b7c..b755e4eb98ca 100644\n--- a/src/Parsers/ASTQualifiedAsterisk.cpp\n+++ b/src/Parsers/ASTQualifiedAsterisk.cpp\n@@ -17,6 +17,8 @@ void ASTQualifiedAsterisk::formatImpl(const FormatSettings & settings, FormatSta\n     const auto & qualifier = children.at(0);\n     qualifier->formatImpl(settings, state, frame);\n     settings.ostr << \".*\";\n+\n+    /// Format column transformers\n     for (ASTs::const_iterator it = children.begin() + 1; it != children.end(); ++it)\n     {\n         settings.ostr << ' ';\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 29c7846283e2..c13e68317808 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -1796,16 +1796,18 @@ bool ParserColumnsMatcher::parseImpl(Pos & pos, ASTPtr & node, Expected & expect\n         return false;\n     ++pos;\n \n-    auto res = std::make_shared<ASTColumnsMatcher>();\n+    ASTPtr res;\n     if (column_list)\n     {\n-        res->column_list = column_list;\n-        res->children.push_back(res->column_list);\n+        auto list_matcher = std::make_shared<ASTColumnsListMatcher>();\n+        list_matcher->column_list = column_list;\n+        res = list_matcher;\n     }\n     else\n     {\n-        res->setPattern(regex_node->as<ASTLiteral &>().value.get<String>());\n-        res->children.push_back(regex_node);\n+        auto regexp_matcher = std::make_shared<ASTColumnsRegexpMatcher>();\n+        regexp_matcher->setPattern(regex_node->as<ASTLiteral &>().value.get<String>());\n+        res = regexp_matcher;\n     }\n \n     ParserColumnsTransformers transformers_p(allowed_transformers);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02271_fix_column_matcher_and_column_transformer.reference b/tests/queries/0_stateless/02271_fix_column_matcher_and_column_transformer.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02271_fix_column_matcher_and_column_transformer.sql b/tests/queries/0_stateless/02271_fix_column_matcher_and_column_transformer.sql\nnew file mode 100644\nindex 000000000000..f0c0e2bae462\n--- /dev/null\n+++ b/tests/queries/0_stateless/02271_fix_column_matcher_and_column_transformer.sql\n@@ -0,0 +1,64 @@\n+DROP TABLE IF EXISTS github_events;\n+\n+CREATE TABLE github_events\n+(\n+    `file_time` DateTime,\n+    `event_type` Enum8('CommitCommentEvent' = 1, 'CreateEvent' = 2, 'DeleteEvent' = 3, 'ForkEvent' = 4, 'GollumEvent' = 5, 'IssueCommentEvent' = 6, 'IssuesEvent' = 7, 'MemberEvent' = 8, 'PublicEvent' = 9, 'PullRequestEvent' = 10, 'PullRequestReviewCommentEvent' = 11, 'PushEvent' = 12, 'ReleaseEvent' = 13, 'SponsorshipEvent' = 14, 'WatchEvent' = 15, 'GistEvent' = 16, 'FollowEvent' = 17, 'DownloadEvent' = 18, 'PullRequestReviewEvent' = 19, 'ForkApplyEvent' = 20, 'Event' = 21, 'TeamAddEvent' = 22),\n+    `actor_login` LowCardinality(String),\n+    `repo_name` LowCardinality(String),\n+    `created_at` DateTime,\n+    `updated_at` DateTime,\n+    `action` Enum8('none' = 0, 'created' = 1, 'added' = 2, 'edited' = 3, 'deleted' = 4, 'opened' = 5, 'closed' = 6, 'reopened' = 7, 'assigned' = 8, 'unassigned' = 9, 'labeled' = 10, 'unlabeled' = 11, 'review_requested' = 12, 'review_request_removed' = 13, 'synchronize' = 14, 'started' = 15, 'published' = 16, 'update' = 17, 'create' = 18, 'fork' = 19, 'merged' = 20),\n+    `comment_id` UInt64,\n+    `body` String,\n+    `path` String,\n+    `position` Int32,\n+    `line` Int32,\n+    `ref` LowCardinality(String),\n+    `ref_type` Enum8('none' = 0, 'branch' = 1, 'tag' = 2, 'repository' = 3, 'unknown' = 4),\n+    `creator_user_login` LowCardinality(String),\n+    `number` UInt32,\n+    `title` String,\n+    `labels` Array(LowCardinality(String)),\n+    `state` Enum8('none' = 0, 'open' = 1, 'closed' = 2),\n+    `locked` UInt8,\n+    `assignee` LowCardinality(String),\n+    `assignees` Array(LowCardinality(String)),\n+    `comments` UInt32,\n+    `author_association` Enum8('NONE' = 0, 'CONTRIBUTOR' = 1, 'OWNER' = 2, 'COLLABORATOR' = 3, 'MEMBER' = 4, 'MANNEQUIN' = 5),\n+    `closed_at` DateTime,\n+    `merged_at` DateTime,\n+    `merge_commit_sha` String,\n+    `requested_reviewers` Array(LowCardinality(String)),\n+    `requested_teams` Array(LowCardinality(String)),\n+    `head_ref` LowCardinality(String),\n+    `head_sha` String,\n+    `base_ref` LowCardinality(String),\n+    `base_sha` String,\n+    `merged` UInt8,\n+    `mergeable` UInt8,\n+    `rebaseable` UInt8,\n+    `mergeable_state` Enum8('unknown' = 0, 'dirty' = 1, 'clean' = 2, 'unstable' = 3, 'draft' = 4),\n+    `merged_by` LowCardinality(String),\n+    `review_comments` UInt32,\n+    `maintainer_can_modify` UInt8,\n+    `commits` UInt32,\n+    `additions` UInt32,\n+    `deletions` UInt32,\n+    `changed_files` UInt32,\n+    `diff_hunk` String,\n+    `original_position` UInt32,\n+    `commit_id` String,\n+    `original_commit_id` String,\n+    `push_size` UInt32,\n+    `push_distinct_size` UInt32,\n+    `member_login` LowCardinality(String),\n+    `release_tag_name` String,\n+    `release_name` String,\n+    `review_state` Enum8('none' = 0, 'approved' = 1, 'changes_requested' = 2, 'commented' = 3, 'dismissed' = 4, 'pending' = 5)\n+)\n+ENGINE = MergeTree ORDER BY (event_type, repo_name, created_at);\n+\n+with top_repos as ( select repo_name from github_events where event_type = 'WatchEvent' and toDate(created_at) = today() - 1 group by repo_name order by count() desc limit 100 union distinct select repo_name from github_events where event_type = 'WatchEvent' and toMonday(created_at) = toMonday(today() - interval 1 week) group by repo_name order by count() desc limit 100 union distinct select repo_name from github_events where event_type = 'WatchEvent' and toStartOfMonth(created_at) = toStartOfMonth(today()) - interval 1 month group by repo_name order by count() desc limit 100 union distinct select repo_name from github_events where event_type = 'WatchEvent' and toYear(created_at) = toYear(today()) - 1 group by repo_name order by count() desc limit 100 ), last_day as ( select repo_name, count() as count_last_day, rowNumberInAllBlocks() + 1 as position_last_day from github_events where repo_name in (select repo_name from top_repos) and toDate(created_at) = today() - 1 group by repo_name order by count_last_day desc ), last_week as ( select repo_name, count() as count_last_week, rowNumberInAllBlocks() + 1 as position_last_week from github_events where repo_name in (select repo_name from top_repos) and toMonday(created_at) = toMonday(today()) - interval 1 week group by repo_name order by count_last_week desc ), last_month as ( select repo_name, count() as count_last_month, rowNumberInAllBlocks() + 1 as position_last_month from github_events where repo_name in (select repo_name from top_repos) and toStartOfMonth(created_at) = toStartOfMonth(today()) - interval 1 month group by repo_name order by count_last_month desc ) select d.repo_name, columns(count) from last_day d join last_week w on d.repo_name = w.repo_name join last_month m on d.repo_name = m.repo_name FORMAT TabSeparatedWithNamesAndTypes; -- { serverError 47 }\n+\n+DROP TABLE github_events;\n",
  "problem_statement": "Nullptr dereference in JOIN and COLUMNS matcher\nAlways reproduced:\r\n\r\n```\r\nCREATE TABLE github_events\r\n(\r\n    `file_time` DateTime,\r\n    `event_type` Enum8('CommitCommentEvent' = 1, 'CreateEvent' = 2, 'DeleteEvent' = 3, 'ForkEvent' = 4, 'GollumEvent' = 5, 'IssueCommentEvent' = 6, 'IssuesEvent' = 7, 'MemberEvent' = 8, 'PublicEvent' = 9, 'PullRequestEvent' = 10, 'PullRequestReviewCommentEvent' = 11, 'PushEvent' = 12, 'ReleaseEvent' = 13, 'SponsorshipEvent' = 14, 'WatchEvent' = 15, 'GistEvent' = 16, 'FollowEvent' = 17, 'DownloadEvent' = 18, 'PullRequestReviewEvent' = 19, 'ForkApplyEvent' = 20, 'Event' = 21, 'TeamAddEvent' = 22),\r\n    `actor_login` LowCardinality(String),\r\n    `repo_name` LowCardinality(String),\r\n    `created_at` DateTime,\r\n    `updated_at` DateTime,\r\n    `action` Enum8('none' = 0, 'created' = 1, 'added' = 2, 'edited' = 3, 'deleted' = 4, 'opened' = 5, 'closed' = 6, 'reopened' = 7, 'assigned' = 8, 'unassigned' = 9, 'labeled' = 10, 'unlabeled' = 11, 'review_requested' = 12, 'review_request_removed' = 13, 'synchronize' = 14, 'started' = 15, 'published' = 16, 'update' = 17, 'create' = 18, 'fork' = 19, 'merged' = 20),\r\n    `comment_id` UInt64,\r\n    `body` String,\r\n    `path` String,\r\n    `position` Int32,\r\n    `line` Int32,\r\n    `ref` LowCardinality(String),\r\n    `ref_type` Enum8('none' = 0, 'branch' = 1, 'tag' = 2, 'repository' = 3, 'unknown' = 4),\r\n    `creator_user_login` LowCardinality(String),\r\n    `number` UInt32,\r\n    `title` String,\r\n    `labels` Array(LowCardinality(String)),\r\n    `state` Enum8('none' = 0, 'open' = 1, 'closed' = 2),\r\n    `locked` UInt8,\r\n    `assignee` LowCardinality(String),\r\n    `assignees` Array(LowCardinality(String)),\r\n    `comments` UInt32,\r\n    `author_association` Enum8('NONE' = 0, 'CONTRIBUTOR' = 1, 'OWNER' = 2, 'COLLABORATOR' = 3, 'MEMBER' = 4, 'MANNEQUIN' = 5),\r\n    `closed_at` DateTime,\r\n    `merged_at` DateTime,\r\n    `merge_commit_sha` String,\r\n    `requested_reviewers` Array(LowCardinality(String)),\r\n    `requested_teams` Array(LowCardinality(String)),\r\n    `head_ref` LowCardinality(String),\r\n    `head_sha` String,\r\n    `base_ref` LowCardinality(String),\r\n    `base_sha` String,\r\n    `merged` UInt8,\r\n    `mergeable` UInt8,\r\n    `rebaseable` UInt8,\r\n    `mergeable_state` Enum8('unknown' = 0, 'dirty' = 1, 'clean' = 2, 'unstable' = 3, 'draft' = 4),\r\n    `merged_by` LowCardinality(String),\r\n    `review_comments` UInt32,\r\n    `maintainer_can_modify` UInt8,\r\n    `commits` UInt32,\r\n    `additions` UInt32,\r\n    `deletions` UInt32,\r\n    `changed_files` UInt32,\r\n    `diff_hunk` String,\r\n    `original_position` UInt32,\r\n    `commit_id` String,\r\n    `original_commit_id` String,\r\n    `push_size` UInt32,\r\n    `push_distinct_size` UInt32,\r\n    `member_login` LowCardinality(String),\r\n    `release_tag_name` String,\r\n    `release_name` String,\r\n    `review_state` Enum8('none' = 0, 'approved' = 1, 'changes_requested' = 2, 'commented' = 3, 'dismissed' = 4, 'pending' = 5)\r\n)\r\nENGINE = MergeTree ORDER BY (event_type, repo_name, created_at);\r\n\r\nwith top_repos as ( select repo_name from github_events where event_type = 'WatchEvent' and toDate(created_at) = today() - 1 group by repo_name order by count() desc limit 100 union distinct select repo_name from github_events where event_type = 'WatchEvent' and toMonday(created_at) = toMonday(today() - interval 1 week) group by repo_name order by count() desc limit 100 union distinct select repo_name from github_events where event_type = 'WatchEvent' and toStartOfMonth(created_at) = toStartOfMonth(today()) - interval 1 month group by repo_name order by count() desc limit 100 union distinct select repo_name from github_events where event_type = 'WatchEvent' and toYear(created_at) = toYear(today()) - 1 group by repo_name order by count() desc limit 100 ), last_day as ( select repo_name, count() as count_last_day, rowNumberInAllBlocks() + 1 as position_last_day from github_events where repo_name in (select repo_name from top_repos) and toDate(created_at) = today() - 1 group by repo_name order by count_last_day desc ), last_week as ( select repo_name, count() as count_last_week, rowNumberInAllBlocks() + 1 as position_last_week from github_events where repo_name in (select repo_name from top_repos) and toMonday(created_at) = toMonday(today()) - interval 1 week group by repo_name order by count_last_week desc ), last_month as ( select repo_name, count() as count_last_month, rowNumberInAllBlocks() + 1 as position_last_month from github_events where repo_name in (select repo_name from top_repos) and toStartOfMonth(created_at) = toStartOfMonth(today()) - interval 1 month group by repo_name order by count_last_month desc ) select d.repo_name, columns(count) from last_day d join last_week w on d.repo_name = w.repo_name join last_month m on d.repo_name = m.repo_name FORMAT TabSeparatedWithNamesAndTypes;\r\n```\r\n\n",
  "hints_text": "Explanation here: https://github.com/ClickHouse/ClickHouse/pull/14775#issuecomment-1102408744",
  "created_at": "2022-04-19T17:23:24Z",
  "modified_files": [
    "src/Interpreters/JoinToSubqueryTransformVisitor.cpp",
    "src/Interpreters/PredicateRewriteVisitor.cpp",
    "src/Interpreters/TranslateQualifiedNamesVisitor.cpp",
    "src/Parsers/ASTAsterisk.cpp",
    "src/Parsers/ASTColumnsMatcher.cpp",
    "src/Parsers/ASTColumnsMatcher.h",
    "src/Parsers/ASTColumnsTransformers.cpp",
    "src/Parsers/ASTColumnsTransformers.h",
    "src/Parsers/ASTQualifiedAsterisk.cpp",
    "src/Parsers/ExpressionElementParsers.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02271_fix_column_matcher_and_column_transformer.sql"
  ]
}