diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
index 5ee0be5cbcea..e2acccce5166 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
@@ -21,18 +21,21 @@ namespace ErrorCodes
 namespace
 {
 
-/// TODO Proper support for Decimal256.
 template <typename T, typename LimitNumberOfElements>
 struct MovingSum
 {
-    using Data = MovingSumData<std::conditional_t<is_decimal<T>, Decimal128, NearestFieldType<T>>>;
+    using Data = MovingSumData<std::conditional_t<is_decimal<T>,
+        std::conditional_t<sizeof(T) <= sizeof(Decimal128), Decimal128, Decimal256>,
+        NearestFieldType<T>>>;
     using Function = MovingImpl<T, LimitNumberOfElements, Data>;
 };
 
 template <typename T, typename LimitNumberOfElements>
 struct MovingAvg
 {
-    using Data = MovingAvgData<std::conditional_t<is_decimal<T>, Decimal128, Float64>>;
+    using Data = MovingAvgData<std::conditional_t<is_decimal<T>,
+        std::conditional_t<sizeof(T) <= sizeof(Decimal128), Decimal128, Decimal256>,
+        Float64>>;
     using Function = MovingImpl<T, LimitNumberOfElements, Data>;
 };
 
diff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h
index dc27d8ac5bf3..f9a60c0c0b48 100644
--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h
+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h
@@ -33,11 +33,6 @@
 namespace DB
 {
 
-namespace ErrorCodes
-{
-    extern const int LOGICAL_ERROR;
-}
-
 struct Settings;
 
 enum class StatisticsFunctionKind
@@ -57,7 +52,7 @@ struct StatFuncOneArg
     using Type1 = T;
     using Type2 = T;
     using ResultType = std::conditional_t<std::is_same_v<T, Float32>, Float32, Float64>;
-    using Data = std::conditional_t<is_decimal<T>, VarMomentsDecimal<Decimal128, _level>, VarMoments<ResultType, _level>>;
+    using Data = VarMoments<ResultType, _level>;
 
     static constexpr UInt32 num_args = 1;
 };
@@ -89,12 +84,11 @@ class AggregateFunctionVarianceSimple final
     explicit AggregateFunctionVarianceSimple(const DataTypes & argument_types_, StatisticsFunctionKind kind_)
         : IAggregateFunctionDataHelper<typename StatFunc::Data, AggregateFunctionVarianceSimple<StatFunc>>(argument_types_, {}, std::make_shared<DataTypeNumber<ResultType>>())
         , src_scale(0), kind(kind_)
-    {}
-
-    AggregateFunctionVarianceSimple(const IDataType & data_type, const DataTypes & argument_types_, StatisticsFunctionKind kind_)
-        : IAggregateFunctionDataHelper<typename StatFunc::Data, AggregateFunctionVarianceSimple<StatFunc>>(argument_types_, {}, std::make_shared<DataTypeNumber<ResultType>>())
-        , src_scale(getDecimalScale(data_type)), kind(kind_)
-    {}
+    {
+        chassert(!argument_types_.empty());
+        if (isDecimal(argument_types_.front()))
+            src_scale = getDecimalScale(*argument_types_.front());
+    }
 
     String getName() const override
     {
@@ -113,8 +107,9 @@ class AggregateFunctionVarianceSimple final
         {
             if constexpr (is_decimal<T1>)
             {
-                this->data(place).add(static_cast<ResultType>(
-                    static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num].value));
+                this->data(place).add(
+                    convertFromDecimal<DataTypeDecimal<T1>, DataTypeFloat64>(
+                        static_cast<const ColVecT1 &>(*columns[0]).getData()[row_num], src_scale));
             }
             else
                 this->data(place).add(
@@ -142,161 +137,86 @@ class AggregateFunctionVarianceSimple final
         const auto & data = this->data(place);
         auto & dst = static_cast<ColVecResult &>(to).getData();
 
-        if constexpr (is_decimal<T1>)
+        switch (kind)
         {
-            switch (kind)
+            case StatisticsFunctionKind::varPop:
             {
-                case StatisticsFunctionKind::varPop:
-                {
-                    dst.push_back(data.getPopulation(src_scale * 2));
-                    break;
-                }
-                case StatisticsFunctionKind::varSamp:
-                {
-                    dst.push_back(data.getSample(src_scale * 2));
-                    break;
-                }
-                case StatisticsFunctionKind::stddevPop:
-                {
-                    dst.push_back(sqrt(data.getPopulation(src_scale * 2)));
-                    break;
-                }
-                case StatisticsFunctionKind::stddevSamp:
-                {
-                    dst.push_back(sqrt(data.getSample(src_scale * 2)));
-                    break;
-                }
-                case StatisticsFunctionKind::skewPop:
-                {
-                    Float64 var_value = data.getPopulation(src_scale * 2);
-
-                    if (var_value > 0)
-                        dst.push_back(data.getMoment3(src_scale * 3) / pow(var_value, 1.5));
-                    else
-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::skewSamp:
-                {
-                    Float64 var_value = data.getSample(src_scale * 2);
-
-                    if (var_value > 0)
-                        dst.push_back(data.getMoment3(src_scale * 3) / pow(var_value, 1.5));
-                    else
-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::kurtPop:
-                {
-                    Float64 var_value = data.getPopulation(src_scale * 2);
-
-                    if (var_value > 0)
-                        dst.push_back(data.getMoment4(src_scale * 4) / pow(var_value, 2));
-                    else
-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::kurtSamp:
-                {
-                    Float64 var_value = data.getSample(src_scale * 2);
-
-                    if (var_value > 0)
-                        dst.push_back(data.getMoment4(src_scale * 4) / pow(var_value, 2));
-                    else
-                        dst.push_back(std::numeric_limits<Float64>::quiet_NaN());
-
-                    break;
-                }
-                default:
-                    throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected statistical function kind");
+                dst.push_back(data.getPopulation());
+                break;
             }
-        }
-        else
-        {
-            switch (kind)
+            case StatisticsFunctionKind::varSamp:
+            {
+                dst.push_back(data.getSample());
+                break;
+            }
+            case StatisticsFunctionKind::stddevPop:
+            {
+                dst.push_back(sqrt(data.getPopulation()));
+                break;
+            }
+            case StatisticsFunctionKind::stddevSamp:
+            {
+                dst.push_back(sqrt(data.getSample()));
+                break;
+            }
+            case StatisticsFunctionKind::skewPop:
+            {
+                ResultType var_value = data.getPopulation();
+
+                if (var_value > 0)
+                    dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));
+                else
+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
+
+                break;
+            }
+            case StatisticsFunctionKind::skewSamp:
+            {
+                ResultType var_value = data.getSample();
+
+                if (var_value > 0)
+                    dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));
+                else
+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
+
+                break;
+            }
+            case StatisticsFunctionKind::kurtPop:
+            {
+                ResultType var_value = data.getPopulation();
+
+                if (var_value > 0)
+                    dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));
+                else
+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
+
+                break;
+            }
+            case StatisticsFunctionKind::kurtSamp:
+            {
+                ResultType var_value = data.getSample();
+
+                if (var_value > 0)
+                    dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));
+                else
+                    dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
+
+                break;
+            }
+            case StatisticsFunctionKind::covarPop:
+            {
+                dst.push_back(data.getPopulation());
+                break;
+            }
+            case StatisticsFunctionKind::covarSamp:
+            {
+                dst.push_back(data.getSample());
+                break;
+            }
+            case StatisticsFunctionKind::corr:
             {
-                case StatisticsFunctionKind::varPop:
-                {
-                    dst.push_back(data.getPopulation());
-                    break;
-                }
-                case StatisticsFunctionKind::varSamp:
-                {
-                    dst.push_back(data.getSample());
-                    break;
-                }
-                case StatisticsFunctionKind::stddevPop:
-                {
-                    dst.push_back(sqrt(data.getPopulation()));
-                    break;
-                }
-                case StatisticsFunctionKind::stddevSamp:
-                {
-                    dst.push_back(sqrt(data.getSample()));
-                    break;
-                }
-                case StatisticsFunctionKind::skewPop:
-                {
-                    ResultType var_value = data.getPopulation();
-
-                    if (var_value > 0)
-                        dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));
-                    else
-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::skewSamp:
-                {
-                    ResultType var_value = data.getSample();
-
-                    if (var_value > 0)
-                        dst.push_back(static_cast<ResultType>(data.getMoment3() / pow(var_value, 1.5)));
-                    else
-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::kurtPop:
-                {
-                    ResultType var_value = data.getPopulation();
-
-                    if (var_value > 0)
-                        dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));
-                    else
-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::kurtSamp:
-                {
-                    ResultType var_value = data.getSample();
-
-                    if (var_value > 0)
-                        dst.push_back(static_cast<ResultType>(data.getMoment4() / pow(var_value, 2)));
-                    else
-                        dst.push_back(std::numeric_limits<ResultType>::quiet_NaN());
-
-                    break;
-                }
-                case StatisticsFunctionKind::covarPop:
-                {
-                    dst.push_back(data.getPopulation());
-                    break;
-                }
-                case StatisticsFunctionKind::covarSamp:
-                {
-                    dst.push_back(data.getSample());
-                    break;
-                }
-                case StatisticsFunctionKind::corr:
-                {
-                    dst.push_back(data.get());
-                    break;
-                }
+                dst.push_back(data.get());
+                break;
             }
         }
     }
@@ -327,7 +247,7 @@ AggregateFunctionPtr createAggregateFunctionStatisticsUnary(
     AggregateFunctionPtr res;
     const DataTypePtr & data_type = argument_types[0];
     if (isDecimal(data_type))
-        res.reset(createWithDecimalType<FunctionTemplate>(*data_type, *data_type, argument_types, kind));
+        res.reset(createWithDecimalType<FunctionTemplate>(*data_type, argument_types, kind));
     else
         res.reset(createWithNumericType<FunctionTemplate>(*data_type, argument_types, kind));
 
diff --git a/src/AggregateFunctions/AggregateFunctionSum.cpp b/src/AggregateFunctions/AggregateFunctionSum.cpp
index 4f2a935d9e54..e393cb6dd389 100644
--- a/src/AggregateFunctions/AggregateFunctionSum.cpp
+++ b/src/AggregateFunctions/AggregateFunctionSum.cpp
@@ -19,7 +19,7 @@ namespace
 template <typename T>
 struct SumSimple
 {
-    /// @note It uses slow Decimal128 (cause we need such a variant). sumWithOverflow is faster for Decimal32/64
+    /// @note It uses slow Decimal128/256 (cause we need such a variant). sumWithOverflow is faster for Decimal32/64
     using ResultType = std::conditional_t<is_decimal<T>,
                                         std::conditional_t<std::is_same_v<T, Decimal256>, Decimal256, Decimal128>,
                                         NearestFieldType<T>>;
diff --git a/src/AggregateFunctions/HelpersMinMaxAny.h b/src/AggregateFunctions/HelpersMinMaxAny.h
index 1af51c3f8e6d..026a206b109c 100644
--- a/src/AggregateFunctions/HelpersMinMaxAny.h
+++ b/src/AggregateFunctions/HelpersMinMaxAny.h
@@ -41,6 +41,8 @@ static IAggregateFunction * createAggregateFunctionSingleValue(const String & na
         return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal64>>>(argument_type);
     if (which.idx == TypeIndex::Decimal128)
         return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal128>>>(argument_type);
+    if (which.idx == TypeIndex::Decimal256)
+        return new AggregateFunctionTemplate<Data<SingleValueDataFixed<Decimal256>>>(argument_type);
     if (which.idx == TypeIndex::String)
         return new AggregateFunctionTemplate<Data<SingleValueDataString>>(argument_type);
 
@@ -72,6 +74,8 @@ static IAggregateFunction * createAggregateFunctionArgMinMaxSecond(const DataTyp
         return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal64>>>>(res_type, val_type);
     if (which.idx == TypeIndex::Decimal128)
         return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal128>>>>(res_type, val_type);
+    if (which.idx == TypeIndex::Decimal256)
+        return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataFixed<Decimal256>>>>(res_type, val_type);
     if (which.idx == TypeIndex::String)
         return new AggregateFunctionArgMinMax<AggregateFunctionArgMinMaxData<ResData, MinMaxData<SingleValueDataString>>>(res_type, val_type);
 
@@ -106,6 +110,8 @@ static IAggregateFunction * createAggregateFunctionArgMinMax(const String & name
         return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal64>>(res_type, val_type);
     if (which.idx == TypeIndex::Decimal128)
         return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal128>>(res_type, val_type);
+    if (which.idx == TypeIndex::Decimal256)
+        return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataFixed<Decimal256>>(res_type, val_type);
     if (which.idx == TypeIndex::String)
         return createAggregateFunctionArgMinMaxSecond<MinMaxData, SingleValueDataString>(res_type, val_type);
 
diff --git a/src/AggregateFunctions/Moments.h b/src/AggregateFunctions/Moments.h
index 8e8bdd9f2101..a34f960794cc 100644
--- a/src/AggregateFunctions/Moments.h
+++ b/src/AggregateFunctions/Moments.h
@@ -17,7 +17,6 @@ struct Settings;
 namespace ErrorCodes
 {
     extern const int BAD_ARGUMENTS;
-    extern const int DECIMAL_OVERFLOW;
     extern const int LOGICAL_ERROR;
 }
 
@@ -136,114 +135,6 @@ struct VarMoments
     }
 };
 
-template <typename T, size_t _level>
-class VarMomentsDecimal
-{
-public:
-    using NativeType = typename T::NativeType;
-
-    void add(NativeType x)
-    {
-        ++m0;
-        getM(1) += x;
-
-        NativeType tmp;
-        bool overflow = common::mulOverflow(x, x, tmp) || common::addOverflow(getM(2), tmp, getM(2));
-        if constexpr (_level >= 3)
-            overflow = overflow || common::mulOverflow(tmp, x, tmp) || common::addOverflow(getM(3), tmp, getM(3));
-        if constexpr (_level >= 4)
-            overflow = overflow || common::mulOverflow(tmp, x, tmp) || common::addOverflow(getM(4), tmp, getM(4));
-
-        if (overflow)
-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
-    }
-
-    void merge(const VarMomentsDecimal & rhs)
-    {
-        m0 += rhs.m0;
-        getM(1) += rhs.getM(1);
-
-        bool overflow = common::addOverflow(getM(2), rhs.getM(2), getM(2));
-        if constexpr (_level >= 3)
-            overflow = overflow || common::addOverflow(getM(3), rhs.getM(3), getM(3));
-        if constexpr (_level >= 4)
-            overflow = overflow || common::addOverflow(getM(4), rhs.getM(4), getM(4));
-
-        if (overflow)
-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
-    }
-
-    void write(WriteBuffer & buf) const { writePODBinary(*this, buf); }
-    void read(ReadBuffer & buf) { readPODBinary(*this, buf); }
-
-    Float64 get() const
-    {
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Variation moments should be obtained by either 'getSample' or 'getPopulation' method");
-    }
-
-    Float64 getPopulation(UInt32 scale) const
-    {
-        if (m0 == 0)
-            return std::numeric_limits<Float64>::infinity();
-
-        NativeType tmp;
-        if (common::mulOverflow(getM(1), getM(1), tmp) ||
-            common::subOverflow(getM(2), NativeType(tmp / m0), tmp))
-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
-        return std::max(Float64{}, DecimalUtils::convertTo<Float64>(T(tmp / m0), scale));
-    }
-
-    Float64 getSample(UInt32 scale) const
-    {
-        if (m0 == 0)
-            return std::numeric_limits<Float64>::quiet_NaN();
-        if (m0 == 1)
-            return std::numeric_limits<Float64>::infinity();
-
-        NativeType tmp;
-        if (common::mulOverflow(getM(1), getM(1), tmp) ||
-            common::subOverflow(getM(2), NativeType(tmp / m0), tmp))
-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
-        return std::max(Float64{}, DecimalUtils::convertTo<Float64>(T(tmp / (m0 - 1)), scale));
-    }
-
-    Float64 getMoment3(UInt32 scale) const
-    {
-        if (m0 == 0)
-            return std::numeric_limits<Float64>::infinity();
-
-        NativeType tmp;
-        if (common::mulOverflow(2 * getM(1), getM(1), tmp) ||
-            common::subOverflow(3 * getM(2), NativeType(tmp / m0), tmp) ||
-            common::mulOverflow(tmp, getM(1), tmp) ||
-            common::subOverflow(getM(3), NativeType(tmp / m0), tmp))
-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
-        return DecimalUtils::convertTo<Float64>(T(tmp / m0), scale);
-    }
-
-    Float64 getMoment4(UInt32 scale) const
-    {
-        if (m0 == 0)
-            return std::numeric_limits<Float64>::infinity();
-
-        NativeType tmp;
-        if (common::mulOverflow(3 * getM(1), getM(1), tmp) ||
-            common::subOverflow(6 * getM(2), NativeType(tmp / m0), tmp) ||
-            common::mulOverflow(tmp, getM(1), tmp) ||
-            common::subOverflow(4 * getM(3), NativeType(tmp / m0), tmp) ||
-            common::mulOverflow(tmp, getM(1), tmp) ||
-            common::subOverflow(getM(4), NativeType(tmp / m0), tmp))
-            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, "Decimal math overflow");
-        return DecimalUtils::convertTo<Float64>(T(tmp / m0), scale);
-    }
-
-private:
-    UInt64 m0{};
-    NativeType m[_level]{};
-
-    NativeType & getM(size_t i) { return m[i - 1]; }
-    const NativeType & getM(size_t i) const { return m[i - 1]; }
-};
 
 /**
     Calculating multivariate central moments
diff --git a/src/AggregateFunctions/QuantileExactWeighted.h b/src/AggregateFunctions/QuantileExactWeighted.h
index 48ba253cb95a..c6a779ede61e 100644
--- a/src/AggregateFunctions/QuantileExactWeighted.h
+++ b/src/AggregateFunctions/QuantileExactWeighted.h
@@ -33,7 +33,7 @@ struct QuantileExactWeighted
 
     using Weight = UInt64;
     using UnderlyingType = NativeType<Value>;
-    using Hasher = std::conditional_t<std::is_same_v<Value, Decimal128>, Int128Hash, HashCRC32<UnderlyingType>>;
+    using Hasher = HashCRC32<UnderlyingType>;
 
     /// When creating, the hash table must be small.
     using Map = HashMapWithStackMemory<UnderlyingType, Weight, Hasher, 4>;
diff --git a/src/AggregateFunctions/QuantileInterpolatedWeighted.h b/src/AggregateFunctions/QuantileInterpolatedWeighted.h
index eef4f5668899..5b1eb315af3e 100644
--- a/src/AggregateFunctions/QuantileInterpolatedWeighted.h
+++ b/src/AggregateFunctions/QuantileInterpolatedWeighted.h
@@ -34,7 +34,7 @@ struct QuantileInterpolatedWeighted
 
     using Weight = UInt64;
     using UnderlyingType = NativeType<Value>;
-    using Hasher = std::conditional_t<std::is_same_v<Value, Decimal128>, Int128Hash, HashCRC32<UnderlyingType>>;
+    using Hasher = HashCRC32<UnderlyingType>;
 
     /// When creating, the hash table must be small.
     using Map = HashMapWithStackMemory<UnderlyingType, Weight, Hasher, 4>;
diff --git a/src/Client/QueryFuzzer.cpp b/src/Client/QueryFuzzer.cpp
index adcebf8a5f4f..bfcfe6599828 100644
--- a/src/Client/QueryFuzzer.cpp
+++ b/src/Client/QueryFuzzer.cpp
@@ -107,8 +107,9 @@ Field QueryFuzzer::fuzzField(Field field)
         type_index = 1;
     }
     else if (type == Field::Types::Decimal32
-             || type == Field::Types::Decimal64
-             || type == Field::Types::Decimal128)
+        || type == Field::Types::Decimal64
+        || type == Field::Types::Decimal128
+        || type == Field::Types::Decimal256)
     {
         type_index = 2;
     }
diff --git a/src/Core/PostgreSQLProtocol.cpp b/src/Core/PostgreSQLProtocol.cpp
index 553d195605a1..5a96ed7a500a 100644
--- a/src/Core/PostgreSQLProtocol.cpp
+++ b/src/Core/PostgreSQLProtocol.cpp
@@ -37,6 +37,7 @@ ColumnTypeSpec convertTypeIndexToPostgresColumnTypeSpec(TypeIndex type_index)
         case TypeIndex::Decimal32:
         case TypeIndex::Decimal64:
         case TypeIndex::Decimal128:
+        case TypeIndex::Decimal256:
             return {ColumnType::NUMERIC, -1};
 
         case TypeIndex::UUID:
diff --git a/src/DataTypes/DataTypesDecimal.cpp b/src/DataTypes/DataTypesDecimal.cpp
index 2838f5868d4d..1c2a63371eea 100644
--- a/src/DataTypes/DataTypesDecimal.cpp
+++ b/src/DataTypes/DataTypesDecimal.cpp
@@ -40,8 +40,10 @@ bool DataTypeDecimal<T>::equals(const IDataType & rhs) const
 template <is_decimal T>
 DataTypePtr DataTypeDecimal<T>::promoteNumericType() const
 {
-    using PromotedType = DataTypeDecimal<Decimal128>;
-    return std::make_shared<PromotedType>(PromotedType::maxPrecision(), this->scale);
+    if (sizeof(T) <= sizeof(Decimal128))
+        return std::make_shared<DataTypeDecimal<Decimal128>>(DataTypeDecimal<Decimal128>::maxPrecision(), this->scale);
+    else
+        return std::make_shared<DataTypeDecimal<Decimal256>>(DataTypeDecimal<Decimal256>::maxPrecision(), this->scale);
 }
 
 template <is_decimal T>
diff --git a/src/DataTypes/convertMySQLDataType.cpp b/src/DataTypes/convertMySQLDataType.cpp
index db064a7f06f6..bb848bf15261 100644
--- a/src/DataTypes/convertMySQLDataType.cpp
+++ b/src/DataTypes/convertMySQLDataType.cpp
@@ -115,6 +115,8 @@ DataTypePtr convertMySQLDataType(MultiEnum<MySQLDataTypesSupport> type_support,
             res = std::make_shared<DataTypeDecimal<Decimal64>>(precision, scale);
         else if (precision <= DecimalUtils::max_precision<Decimal128>)
             res = std::make_shared<DataTypeDecimal<Decimal128>>(precision, scale);
+        else if (precision <= DecimalUtils::max_precision<Decimal256>)
+            res = std::make_shared<DataTypeDecimal<Decimal256>>(precision, scale);
     }
 
     /// Also String is fallback for all unknown types.
diff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp
index b50aeb76e677..3c33289c3047 100644
--- a/src/DataTypes/getLeastSupertype.cpp
+++ b/src/DataTypes/getLeastSupertype.cpp
@@ -15,11 +15,9 @@
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
-#include <DataTypes/DataTypeEnum.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypesDecimal.h>
 #include <DataTypes/DataTypeFactory.h>
-#include <base/EnumReflection.h>
 
 
 namespace DB
@@ -528,13 +526,14 @@ DataTypePtr getLeastSupertype(const DataTypes & types)
         size_t have_decimal32 = type_ids.count(TypeIndex::Decimal32);
         size_t have_decimal64 = type_ids.count(TypeIndex::Decimal64);
         size_t have_decimal128 = type_ids.count(TypeIndex::Decimal128);
+        size_t have_decimal256 = type_ids.count(TypeIndex::Decimal256);
 
-        if (have_decimal32 || have_decimal64 || have_decimal128)
+        if (have_decimal32 || have_decimal64 || have_decimal128 || have_decimal256)
         {
-            size_t num_supported = have_decimal32 + have_decimal64 + have_decimal128;
+            size_t num_supported = have_decimal32 + have_decimal64 + have_decimal128 + have_decimal256;
 
-            std::vector<TypeIndex> int_ids = {TypeIndex::Int8, TypeIndex::UInt8, TypeIndex::Int16, TypeIndex::UInt16,
-                                              TypeIndex::Int32, TypeIndex::UInt32, TypeIndex::Int64, TypeIndex::UInt64};
+            std::array<TypeIndex, 8> int_ids = {TypeIndex::Int8, TypeIndex::UInt8, TypeIndex::Int16, TypeIndex::UInt16,
+                                                TypeIndex::Int32, TypeIndex::UInt32, TypeIndex::Int64, TypeIndex::UInt64};
 
             TypeIndex max_int = TypeIndex::Nothing;
             for (auto int_id : int_ids)
@@ -552,8 +551,13 @@ DataTypePtr getLeastSupertype(const DataTypes & types)
             for (const auto & type : types)
             {
                 auto type_id = type->getTypeId();
-                if (type_id != TypeIndex::Decimal32 && type_id != TypeIndex::Decimal64 && type_id != TypeIndex::Decimal128)
+                if (type_id != TypeIndex::Decimal32
+                    && type_id != TypeIndex::Decimal64
+                    && type_id != TypeIndex::Decimal128
+                    && type_id != TypeIndex::Decimal256)
+                {
                     continue;
+                }
 
                 UInt32 scale = getDecimalScale(*type);
                 if (scale > max_scale)
@@ -571,11 +575,13 @@ DataTypePtr getLeastSupertype(const DataTypes & types)
                     min_precision = DataTypeDecimal<Decimal64>::maxPrecision();
             }
 
-            if (min_precision > DataTypeDecimal<Decimal128>::maxPrecision())
+            if (min_precision > DataTypeDecimal<Decimal256>::maxPrecision())
                 return throwOrReturn<on_error>(types, "because the least supertype is Decimal("
                                 + toString(min_precision) + ',' + toString(max_scale) + ')',
                                 ErrorCodes::NO_COMMON_TYPE);
 
+            if (have_decimal256 || min_precision > DataTypeDecimal<Decimal128>::maxPrecision())
+                return std::make_shared<DataTypeDecimal<Decimal256>>(DataTypeDecimal<Decimal256>::maxPrecision(), max_scale);
             if (have_decimal128 || min_precision > DataTypeDecimal<Decimal64>::maxPrecision())
                 return std::make_shared<DataTypeDecimal<Decimal128>>(DataTypeDecimal<Decimal128>::maxPrecision(), max_scale);
             if (have_decimal64 || min_precision > DataTypeDecimal<Decimal32>::maxPrecision())
diff --git a/src/DataTypes/getMostSubtype.cpp b/src/DataTypes/getMostSubtype.cpp
index e5d529205d26..33b5735456ea 100644
--- a/src/DataTypes/getMostSubtype.cpp
+++ b/src/DataTypes/getMostSubtype.cpp
@@ -11,6 +11,7 @@
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/DataTypesDecimal.h>
 
 
 namespace DB
@@ -280,6 +281,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth
                 minimize(min_bits_of_unsigned_integer, 32);
             else if (typeid_cast<const DataTypeUInt64 *>(type.get()))
                 minimize(min_bits_of_unsigned_integer, 64);
+            else if (typeid_cast<const DataTypeUInt128 *>(type.get()))
+                minimize(min_bits_of_unsigned_integer, 128);
+            else if (typeid_cast<const DataTypeUInt256 *>(type.get()))
+                minimize(min_bits_of_unsigned_integer, 256);
             else if (typeid_cast<const DataTypeInt8 *>(type.get()))
                 minimize(min_bits_of_signed_integer, 8);
             else if (typeid_cast<const DataTypeInt16 *>(type.get()))
@@ -288,6 +293,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth
                 minimize(min_bits_of_signed_integer, 32);
             else if (typeid_cast<const DataTypeInt64 *>(type.get()))
                 minimize(min_bits_of_signed_integer, 64);
+            else if (typeid_cast<const DataTypeInt128 *>(type.get()))
+                minimize(min_bits_of_signed_integer, 128);
+            else if (typeid_cast<const DataTypeInt256 *>(type.get()))
+                minimize(min_bits_of_signed_integer, 256);
             else if (typeid_cast<const DataTypeFloat32 *>(type.get()))
                 minimize(min_mantissa_bits_of_floating, 24);
             else if (typeid_cast<const DataTypeFloat64 *>(type.get()))
@@ -326,6 +335,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth
                     return std::make_shared<DataTypeUInt32>();
                 else if (min_bits_of_unsigned_integer <= 64)
                     return std::make_shared<DataTypeUInt64>();
+                else if (min_bits_of_unsigned_integer <= 128)
+                    return std::make_shared<DataTypeUInt128>();
+                else if (min_bits_of_unsigned_integer <= 256)
+                    return std::make_shared<DataTypeUInt256>();
                 else
                     throw Exception(ErrorCodes::NO_COMMON_TYPE,
                                     "Logical error: {} but as all data types are integers, "
@@ -343,6 +356,10 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth
                     return std::make_shared<DataTypeInt32>();
                 else if (min_bits_of_signed_integer <= 64)
                     return std::make_shared<DataTypeInt64>();
+                else if (min_bits_of_signed_integer <= 128)
+                    return std::make_shared<DataTypeInt128>();
+                else if (min_bits_of_signed_integer <= 256)
+                    return std::make_shared<DataTypeInt256>();
                 else
                     throw Exception(ErrorCodes::NO_COMMON_TYPE,
                                     "Logical error: {} but as all data types are integers, "
@@ -351,6 +368,29 @@ DataTypePtr getMostSubtype(const DataTypes & types, bool throw_if_result_is_noth
         }
     }
 
+    /// Decimals
+    {
+        bool all_decimals = true;
+        UInt32 min_scale = std::numeric_limits<UInt32>::max();
+        UInt32 min_precision = std::numeric_limits<UInt32>::max();
+        for (const auto & type : types)
+        {
+            if (isDecimal(type))
+            {
+                min_scale = std::min(min_scale, getDecimalScale(*type));
+                min_precision = std::min(min_precision, getDecimalPrecision(*type));
+            }
+            else
+            {
+                all_decimals = false;
+                break;
+            }
+        }
+
+        if (all_decimals)
+            return createDecimal<DataTypeDecimal>(min_precision, min_scale);
+    }
+
     /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).
     return get_nothing_or_throw("");
 }
diff --git a/src/Functions/FunctionsBinaryRepresentation.cpp b/src/Functions/FunctionsBinaryRepresentation.cpp
index d44323f8bf3f..c3a8f51ee4b4 100644
--- a/src/Functions/FunctionsBinaryRepresentation.cpp
+++ b/src/Functions/FunctionsBinaryRepresentation.cpp
@@ -299,6 +299,7 @@ class EncodeToBinaryRepresentation : public IFunction
             tryExecuteDecimal<Decimal32>(column, res_column) ||
             tryExecuteDecimal<Decimal64>(column, res_column) ||
             tryExecuteDecimal<Decimal128>(column, res_column) ||
+            tryExecuteDecimal<Decimal256>(column, res_column) ||
             tryExecuteUUID(column, res_column) ||
             tryExecuteIPv4(column, res_column) ||
             tryExecuteIPv6(column, res_column))
diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h
index d3be5b1200b0..f0dd5553f5ec 100644
--- a/src/Functions/FunctionsExternalDictionaries.h
+++ b/src/Functions/FunctionsExternalDictionaries.h
@@ -721,9 +721,6 @@ struct NameDictGetDateTime { static constexpr auto name = "dictGetDateTime"; };
 struct NameDictGetUUID { static constexpr auto name = "dictGetUUID"; };
 struct NameDictGetIPv4 { static constexpr auto name = "dictGetIPv4"; };
 struct NameDictGetIPv6 { static constexpr auto name = "dictGetIPv6"; };
-struct NameDictGetDecimal32 { static constexpr auto name = "dictGetDecimal32"; };
-struct NameDictGetDecimal64 { static constexpr auto name = "dictGetDecimal64"; };
-struct NameDictGetDecimal128 { static constexpr auto name = "dictGetDecimal128"; };
 struct NameDictGetString { static constexpr auto name = "dictGetString"; };
 
 using FunctionDictGetUInt8 = FunctionDictGet<DataTypeUInt8, NameDictGetUInt8>;
@@ -741,9 +738,6 @@ using FunctionDictGetDateTime = FunctionDictGet<DataTypeDateTime, NameDictGetDat
 using FunctionDictGetUUID = FunctionDictGet<DataTypeUUID, NameDictGetUUID>;
 using FunctionDictGetIPv4 = FunctionDictGet<DataTypeIPv4, NameDictGetIPv4>;
 using FunctionDictGetIPv6 = FunctionDictGet<DataTypeIPv6, NameDictGetIPv6>;
-using FunctionDictGetDecimal32 = FunctionDictGet<DataTypeDecimal<Decimal32>, NameDictGetDecimal32>;
-using FunctionDictGetDecimal64 = FunctionDictGet<DataTypeDecimal<Decimal64>, NameDictGetDecimal64>;
-using FunctionDictGetDecimal128 = FunctionDictGet<DataTypeDecimal<Decimal128>, NameDictGetDecimal128>;
 using FunctionDictGetString = FunctionDictGet<DataTypeString, NameDictGetString>;
 
 template<typename DataType, typename Name>
@@ -764,9 +758,6 @@ struct NameDictGetDateTimeOrDefault { static constexpr auto name = "dictGetDateT
 struct NameDictGetUUIDOrDefault { static constexpr auto name = "dictGetUUIDOrDefault"; };
 struct NameDictGetIPv4OrDefault { static constexpr auto name = "dictGetIPv4OrDefault"; };
 struct NameDictGetIPv6OrDefault { static constexpr auto name = "dictGetIPv6OrDefault"; };
-struct NameDictGetDecimal32OrDefault { static constexpr auto name = "dictGetDecimal32OrDefault"; };
-struct NameDictGetDecimal64OrDefault { static constexpr auto name = "dictGetDecimal64OrDefault"; };
-struct NameDictGetDecimal128OrDefault { static constexpr auto name = "dictGetDecimal128OrDefault"; };
 struct NameDictGetStringOrDefault { static constexpr auto name = "dictGetStringOrDefault"; };
 
 using FunctionDictGetUInt8OrDefault = FunctionDictGetOrDefault<DataTypeUInt8, NameDictGetUInt8OrDefault>;
@@ -784,9 +775,6 @@ using FunctionDictGetDateTimeOrDefault = FunctionDictGetOrDefault<DataTypeDateTi
 using FunctionDictGetUUIDOrDefault = FunctionDictGetOrDefault<DataTypeUUID, NameDictGetUUIDOrDefault>;
 using FunctionDictGetIPv4OrDefault = FunctionDictGetOrDefault<DataTypeIPv4, NameDictGetIPv4OrDefault>;
 using FunctionDictGetIPv6OrDefault = FunctionDictGetOrDefault<DataTypeIPv6, NameDictGetIPv6OrDefault>;
-using FunctionDictGetDecimal32OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal32>, NameDictGetDecimal32OrDefault>;
-using FunctionDictGetDecimal64OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal64>, NameDictGetDecimal64OrDefault>;
-using FunctionDictGetDecimal128OrDefault = FunctionDictGetOrDefault<DataTypeDecimal<Decimal128>, NameDictGetDecimal128OrDefault>;
 using FunctionDictGetStringOrDefault = FunctionDictGetOrDefault<DataTypeString, NameDictGetStringOrDefault>;
 
 class FunctionDictGetOrNull final : public IFunction
diff --git a/src/Functions/FunctionsJSON.cpp b/src/Functions/FunctionsJSON.cpp
index 5df0d1831af7..8bcb1f4d849d 100644
--- a/src/Functions/FunctionsJSON.cpp
+++ b/src/Functions/FunctionsJSON.cpp
@@ -750,42 +750,12 @@ class JSONExtractNumericImpl
 };
 
 
-template <typename JSONParser>
-using JSONExtractInt8Impl = JSONExtractNumericImpl<JSONParser, Int8>;
-template <typename JSONParser>
-using JSONExtractUInt8Impl = JSONExtractNumericImpl<JSONParser, UInt8>;
-template <typename JSONParser>
-using JSONExtractInt16Impl = JSONExtractNumericImpl<JSONParser, Int16>;
-template <typename JSONParser>
-using JSONExtractUInt16Impl = JSONExtractNumericImpl<JSONParser, UInt16>;
-template <typename JSONParser>
-using JSONExtractInt32Impl = JSONExtractNumericImpl<JSONParser, Int32>;
-template <typename JSONParser>
-using JSONExtractUInt32Impl = JSONExtractNumericImpl<JSONParser, UInt32>;
 template <typename JSONParser>
 using JSONExtractInt64Impl = JSONExtractNumericImpl<JSONParser, Int64>;
 template <typename JSONParser>
 using JSONExtractUInt64Impl = JSONExtractNumericImpl<JSONParser, UInt64>;
 template <typename JSONParser>
-using JSONExtractInt128Impl = JSONExtractNumericImpl<JSONParser, Int128>;
-template <typename JSONParser>
-using JSONExtractUInt128Impl = JSONExtractNumericImpl<JSONParser, UInt128>;
-template <typename JSONParser>
-using JSONExtractInt256Impl = JSONExtractNumericImpl<JSONParser, Int256>;
-template <typename JSONParser>
-using JSONExtractUInt256Impl = JSONExtractNumericImpl<JSONParser, UInt256>;
-template <typename JSONParser>
-using JSONExtractFloat32Impl = JSONExtractNumericImpl<JSONParser, Float32>;
-template <typename JSONParser>
 using JSONExtractFloat64Impl = JSONExtractNumericImpl<JSONParser, Float64>;
-template <typename JSONParser>
-using JSONExtractDecimal32Impl = JSONExtractNumericImpl<JSONParser, Decimal32>;
-template <typename JSONParser>
-using JSONExtractDecimal64Impl = JSONExtractNumericImpl<JSONParser, Decimal64>;
-template <typename JSONParser>
-using JSONExtractDecimal128Impl = JSONExtractNumericImpl<JSONParser, Decimal128>;
-template <typename JSONParser>
-using JSONExtractDecimal256Impl = JSONExtractNumericImpl<JSONParser, Decimal256>;
 
 
 template <typename JSONParser>
diff --git a/src/Functions/FunctionsRound.h b/src/Functions/FunctionsRound.h
index 2f2a0c3a1a91..3d1028c6d351 100644
--- a/src/Functions/FunctionsRound.h
+++ b/src/Functions/FunctionsRound.h
@@ -703,7 +703,8 @@ class FunctionRoundDown : public IFunction
             && !executeNum<Float64>(in, out, boundaries)
             && !executeDecimal<Decimal32>(in, out, boundaries)
             && !executeDecimal<Decimal64>(in, out, boundaries)
-            && !executeDecimal<Decimal128>(in, out, boundaries))
+            && !executeDecimal<Decimal128>(in, out, boundaries)
+            && !executeDecimal<Decimal256>(in, out, boundaries))
         {
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of first argument of function {}", in->getName(), getName());
         }
diff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp
index 75ea3a81a7d0..59991b7b3139 100644
--- a/src/Functions/array/arrayAggregation.cpp
+++ b/src/Functions/array/arrayAggregation.cpp
@@ -38,7 +38,7 @@ enum class AggregateOperation
  * During array aggregation we derive result type from operation.
  * For array min or array max we use array element as result type.
  * For array average we use Float64.
- * For array sum for for big integers, we use same type representation, decimal numbers we use Decimal128,
+ * For array sum for big integers, we use same type representation, decimal numbers up to 128-bit will use Decimal128, then Decimal256.
  * for floating point numbers Float64, for numeric unsigned Int64, and for numeric signed UInt64.
  */
 
@@ -77,10 +77,13 @@ struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::sum>
         std::conditional_t<std::is_same_v<ArrayElement, UInt128>, UInt128,
         std::conditional_t<std::is_same_v<ArrayElement, Int256>, Int256,
         std::conditional_t<std::is_same_v<ArrayElement, UInt256>, UInt256,
-        std::conditional_t<is_decimal<ArrayElement>, Decimal128,
+        std::conditional_t<std::is_same_v<ArrayElement, Decimal32>, Decimal128,
+        std::conditional_t<std::is_same_v<ArrayElement, Decimal64>, Decimal128,
+        std::conditional_t<std::is_same_v<ArrayElement, Decimal128>, Decimal128,
+        std::conditional_t<std::is_same_v<ArrayElement, Decimal256>, Decimal256,
         std::conditional_t<std::is_floating_point_v<ArrayElement>, Float64,
         std::conditional_t<std::is_signed_v<ArrayElement>, Int64,
-            UInt64>>>>>>>;
+            UInt64>>>>>>>>>>;
 };
 
 template <typename ArrayElement, AggregateOperation operation>
@@ -364,8 +367,11 @@ struct ArrayAggregateImpl
             executeType<Float64>(mapped, offsets, res) ||
             executeType<Decimal32>(mapped, offsets, res) ||
             executeType<Decimal64>(mapped, offsets, res) ||
-            executeType<Decimal128>(mapped, offsets, res))
+            executeType<Decimal128>(mapped, offsets, res) ||
+            executeType<Decimal256>(mapped, offsets, res))
+        {
             return res;
+        }
         else
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected column for arraySum: {}", mapped->getName());
     }
@@ -396,4 +402,3 @@ REGISTER_FUNCTION(ArrayAggregation)
 }
 
 }
-
diff --git a/src/Functions/array/arrayCompact.cpp b/src/Functions/array/arrayCompact.cpp
index 5c899d4d97e3..15df9f0d0082 100644
--- a/src/Functions/array/arrayCompact.cpp
+++ b/src/Functions/array/arrayCompact.cpp
@@ -151,7 +151,8 @@ struct ArrayCompactImpl
             executeType<Float64>(mapped, array, res)) ||
             executeType<Decimal32>(mapped, array, res) ||
             executeType<Decimal64>(mapped, array, res) ||
-            executeType<Decimal128>(mapped, array, res))
+            executeType<Decimal128>(mapped, array, res) ||
+            executeType<Decimal256>(mapped, array, res))
         {
             executeGeneric(mapped, array, res);
         }
@@ -168,4 +169,3 @@ REGISTER_FUNCTION(ArrayCompact)
 }
 
 }
-
diff --git a/src/Functions/array/arrayCumSum.cpp b/src/Functions/array/arrayCumSum.cpp
index 489014ebe557..b1077bfb18b4 100644
--- a/src/Functions/array/arrayCumSum.cpp
+++ b/src/Functions/array/arrayCumSum.cpp
@@ -41,7 +41,11 @@ struct ArrayCumSumImpl
         if (which.isDecimal())
         {
             UInt32 scale = getDecimalScale(*expression_return);
-            DataTypePtr nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);
+            DataTypePtr nested;
+            if (which.isDecimal256())
+                nested = std::make_shared<DataTypeDecimal<Decimal256>>(DecimalUtils::max_precision<Decimal256>, scale);
+            else
+                nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);
             return std::make_shared<DataTypeArray>(nested);
         }
 
@@ -151,7 +155,8 @@ struct ArrayCumSumImpl
             executeType<Float64,Float64>(mapped, array, res) ||
             executeType<Decimal32, Decimal128>(mapped, array, res) ||
             executeType<Decimal64, Decimal128>(mapped, array, res) ||
-            executeType<Decimal128, Decimal128>(mapped, array, res))
+            executeType<Decimal128, Decimal128>(mapped, array, res) ||
+            executeType<Decimal256, Decimal256>(mapped, array, res))
             return res;
         else
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected column for arrayCumSum: {}", mapped->getName());
@@ -168,4 +173,3 @@ REGISTER_FUNCTION(ArrayCumSum)
 }
 
 }
-
diff --git a/src/Functions/array/arrayCumSumNonNegative.cpp b/src/Functions/array/arrayCumSumNonNegative.cpp
index c0062fd8230d..6b20ad35afcc 100644
--- a/src/Functions/array/arrayCumSumNonNegative.cpp
+++ b/src/Functions/array/arrayCumSumNonNegative.cpp
@@ -42,7 +42,11 @@ struct ArrayCumSumNonNegativeImpl
         if (which.isDecimal())
         {
             UInt32 scale = getDecimalScale(*expression_return);
-            DataTypePtr nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);
+            DataTypePtr nested;
+            if (which.isDecimal256())
+                nested = std::make_shared<DataTypeDecimal<Decimal256>>(DecimalUtils::max_precision<Decimal256>, scale);
+            else
+                nested = std::make_shared<DataTypeDecimal<Decimal128>>(DecimalUtils::max_precision<Decimal128>, scale);
             return std::make_shared<DataTypeArray>(nested);
         }
 
@@ -116,7 +120,8 @@ struct ArrayCumSumNonNegativeImpl
             executeType<Float64,Float64>(mapped, array, res) ||
             executeType<Decimal32, Decimal128>(mapped, array, res) ||
             executeType<Decimal64, Decimal128>(mapped, array, res) ||
-            executeType<Decimal128, Decimal128>(mapped, array, res))
+            executeType<Decimal128, Decimal128>(mapped, array, res) ||
+            executeType<Decimal256, Decimal256>(mapped, array, res))
             return res;
         else
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected column for arrayCumSumNonNegativeImpl: {}", mapped->getName());
@@ -133,4 +138,3 @@ REGISTER_FUNCTION(ArrayCumSumNonNegative)
 }
 
 }
-
diff --git a/src/Functions/array/arrayDifference.cpp b/src/Functions/array/arrayDifference.cpp
index ab7b94f98f1f..2852c5b967c6 100644
--- a/src/Functions/array/arrayDifference.cpp
+++ b/src/Functions/array/arrayDifference.cpp
@@ -145,7 +145,8 @@ struct ArrayDifferenceImpl
             executeType<Float64,Float64>(mapped, array, res) ||
             executeType<Decimal32, Decimal32>(mapped, array, res) ||
             executeType<Decimal64, Decimal64>(mapped, array, res) ||
-            executeType<Decimal128, Decimal128>(mapped, array, res))
+            executeType<Decimal128, Decimal128>(mapped, array, res) ||
+            executeType<Decimal256, Decimal256>(mapped, array, res))
             return res;
         else
             throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected column for arrayDifference: {}", mapped->getName());
@@ -161,4 +162,3 @@ REGISTER_FUNCTION(ArrayDifference)
 }
 
 }
-
diff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp
index 5da9a2025bb1..d1bbd169513b 100644
--- a/src/Functions/array/arrayIntersect.cpp
+++ b/src/Functions/array/arrayIntersect.cpp
@@ -22,7 +22,6 @@
 #include <Common/assert_cast.h>
 #include <base/TypeLists.h>
 #include <Interpreters/castColumn.h>
-#include <base/range.h>
 
 
 namespace DB
@@ -219,11 +218,12 @@ FunctionArrayIntersect::CastArgumentsResult FunctionArrayIntersect::castColumns(
     const auto & type_nested = type_array->getNestedType();
     auto type_not_nullable_nested = removeNullable(type_nested);
 
-    const bool is_numeric_or_string = isNativeNumber(type_not_nullable_nested)
-                                      || isDate(type_not_nullable_nested)
-                                      || isDateTime(type_not_nullable_nested)
-                                      || isDateTime64(type_not_nullable_nested)
-                                      || isStringOrFixedString(type_not_nullable_nested);
+    const bool is_numeric_or_string =
+        isNumber(type_not_nullable_nested)
+        || isDate(type_not_nullable_nested)
+        || isDateTime(type_not_nullable_nested)
+        || isDateTime64(type_not_nullable_nested)
+        || isStringOrFixedString(type_not_nullable_nested);
 
     DataTypePtr nullable_return_type;
 
@@ -303,7 +303,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(
 
     bool all_const = true;
 
-    for (auto i : collections::range(0, columns_number))
+    for (size_t i = 0; i < columns_number; ++i)
     {
         auto & arg = arrays.args[i];
         const auto * argument_column = columns[i].column.get();
@@ -313,7 +313,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(
         {
             arg.is_const = true;
             argument_column = argument_column_const->getDataColumnPtr().get();
-            initial_column = &typeid_cast<const ColumnConst &>(*initial_column).getDataColumn();
+            initial_column = typeid_cast<const ColumnConst &>(*initial_column).getDataColumnPtr().get();
         }
 
         if (const auto * argument_column_array = typeid_cast<const ColumnArray *>(argument_column))
@@ -330,16 +330,21 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(
             {
                 arg.null_map = &column_nullable->getNullMapData();
                 arg.nested_column = &column_nullable->getNestedColumn();
-                initial_column = &typeid_cast<const ColumnNullable &>(*initial_column).getNestedColumn();
+
+                if (initial_column->isNullable())
+                    initial_column = &typeid_cast<const ColumnNullable &>(*initial_column).getNestedColumn();
             }
 
-            /// In case column was casted need to create overflow mask for integer types.
+            /// In case the column was casted, we need to create an overflow mask for integer types.
             if (arg.nested_column != initial_column)
             {
-                const auto & nested_init_type = typeid_cast<const DataTypeArray *>(removeNullable(initial_columns[i].type).get())->getNestedType();
-                const auto & nested_cast_type = typeid_cast<const DataTypeArray *>(removeNullable(columns[i].type).get())->getNestedType();
+                const auto & nested_init_type = typeid_cast<const DataTypeArray &>(*removeNullable(initial_columns[i].type)).getNestedType();
+                const auto & nested_cast_type = typeid_cast<const DataTypeArray &>(*removeNullable(columns[i].type)).getNestedType();
 
-                if (isInteger(nested_init_type) || isDate(nested_init_type) || isDateTime(nested_init_type) || isDateTime64(nested_init_type))
+                if (isInteger(nested_init_type)
+                    || isDate(nested_init_type)
+                    || isDateTime(nested_init_type)
+                    || isDateTime64(nested_init_type))
                 {
                     /// Compare original and casted columns. It seem to be the easiest way.
                     auto overflow_mask = callFunctionNotEquals(
@@ -347,7 +352,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(
                             {initial_column->getPtr(), nested_cast_type, ""},
                             context);
 
-                    arg.overflow_mask = &typeid_cast<const ColumnUInt8 *>(overflow_mask.get())->getData();
+                    arg.overflow_mask = &typeid_cast<const ColumnUInt8 &>(*overflow_mask).getData();
                     arrays.column_holders.emplace_back(std::move(overflow_mask));
                 }
             }
@@ -362,7 +367,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(
     }
     else
     {
-        for (auto i : collections::range(0, columns_number))
+        for (size_t i = 0; i < columns_number; ++i)
         {
             if (arrays.args[i].is_const)
                 continue;
@@ -371,7 +376,7 @@ FunctionArrayIntersect::UnpackedArrays FunctionArrayIntersect::prepareArrays(
             if (arrays.base_rows == 0 && rows > 0)
                 arrays.base_rows = rows;
             else if (arrays.base_rows != rows)
-                throw Exception(ErrorCodes::LOGICAL_ERROR, "Non-const array columns in function {}should have same rows", getName());
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Non-const array columns in function {} should have the same number of rows", getName());
         }
     }
 
@@ -397,7 +402,6 @@ ColumnPtr FunctionArrayIntersect::executeImpl(const ColumnsWithTypeAndName & arg
         data_types.push_back(arguments[i].type);
 
     auto return_type_with_nulls = getMostSubtype(data_types, true, true);
-
     auto casted_columns = castColumns(arguments, result_type, return_type_with_nulls);
 
     UnpackedArrays arrays = prepareArrays(casted_columns.casted, casted_columns.initial);
@@ -501,13 +505,13 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable
     Map map;
     std::vector<size_t> prev_off(args, 0);
     size_t result_offset = 0;
-    for (auto row : collections::range(0, rows))
+    for (size_t row = 0; row < rows; ++row)
     {
         map.clear();
 
         bool all_has_nullable = all_nullable;
 
-        for (auto arg_num : collections::range(0, args))
+        for (size_t arg_num = 0; arg_num < args; ++arg_num)
         {
             const auto & arg = arrays.args[arg_num];
             bool current_has_nullable = false;
diff --git a/src/Functions/array/mapOp.cpp b/src/Functions/array/mapOp.cpp
index 2e13d35488f3..613fd934c41b 100644
--- a/src/Functions/array/mapOp.cpp
+++ b/src/Functions/array/mapOp.cpp
@@ -10,7 +10,6 @@
 #include <DataTypes/DataTypesNumber.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
-#include <base/arithmeticOverflow.h>
 #include "Columns/ColumnMap.h"
 #include "DataTypes/DataTypeMap.h"
 
@@ -294,6 +293,10 @@ class FunctionMapOp : public IFunction
                 return execute2<KeyType, UInt256>(row_count, args, res_type);
             case TypeIndex::Float64:
                 return execute2<KeyType, Float64>(row_count, args, res_type);
+            case TypeIndex::Decimal128:
+                return execute2<KeyType, Decimal128>(row_count, args, res_type);
+            case TypeIndex::Decimal256:
+                return execute2<KeyType, Decimal256>(row_count, args, res_type);
             default:
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal column type {} for values in arguments of function {}",
                     res_value_type->getName(), getName());
diff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp
index 9e4f543db43b..1e69a73e9f2e 100644
--- a/src/Interpreters/convertFieldToType.cpp
+++ b/src/Interpreters/convertFieldToType.cpp
@@ -149,6 +149,8 @@ Field convertDecimalType(const Field & from, const To & type)
         return convertDecimalToDecimalType<Decimal64>(from, type);
     if (from.getType() == Field::Types::Decimal128)
         return convertDecimalToDecimalType<Decimal128>(from, type);
+    if (from.getType() == Field::Types::Decimal256)
+        return convertDecimalToDecimalType<Decimal256>(from, type);
 
     if (from.getType() == Field::Types::Float64)
         return convertFloatToDecimalType<Float64>(from, type);
diff --git a/src/Loggers/OwnPatternFormatter.cpp b/src/Loggers/OwnPatternFormatter.cpp
index 02a2c2e510b3..ccf6c479b80c 100644
--- a/src/Loggers/OwnPatternFormatter.cpp
+++ b/src/Loggers/OwnPatternFormatter.cpp
@@ -5,7 +5,6 @@
 #include <IO/WriteHelpers.h>
 #include <Common/HashTable/Hash.h>
 #include <Interpreters/InternalTextLogsQueue.h>
-#include <Common/CurrentThread.h>
 #include <base/terminalColors.h>
 
 
