diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
index f8084e3716f4..6a0397837a50 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.cpp
@@ -23,15 +23,15 @@ namespace
 template <typename T, typename LimitNumberOfElements>
 struct MovingSum
 {
-    using DataType = MovingSumData<T>;
-    using Function = MovingImpl<T, LimitNumberOfElements, DataType>;
+    using Data = MovingSumData<std::conditional_t<IsDecimalNumber<T>, Decimal128, NearestFieldType<T>>>;
+    using Function = MovingImpl<T, LimitNumberOfElements, Data>;
 };
 
 template <typename T, typename LimitNumberOfElements>
 struct MovingAvg
 {
-    using DataType = MovingAvgData<T>;
-    using Function = MovingImpl<T, LimitNumberOfElements, DataType>;
+    using Data = MovingAvgData<std::conditional_t<IsDecimalNumber<T>, Decimal128, Float64>>;
+    using Function = MovingImpl<T, LimitNumberOfElements, Data>;
 };
 
 template <typename T, typename LimitNumberOfElements> using MovingSumTemplate = typename MovingSum<T, LimitNumberOfElements>::Function;
@@ -71,11 +71,11 @@ AggregateFunctionPtr createAggregateFunctionMoving(const std::string & name, con
     {
         auto type = parameters[0].getType();
         if (type != Field::Types::Int64 && type != Field::Types::UInt64)
-               throw Exception("Parameter for aggregate function " + name + " should be positive number", ErrorCodes::BAD_ARGUMENTS);
+               throw Exception("Parameter for aggregate function " + name + " should be positive integer", ErrorCodes::BAD_ARGUMENTS);
 
         if ((type == Field::Types::Int64 && parameters[0].get<Int64>() < 0) ||
             (type == Field::Types::UInt64 && parameters[0].get<UInt64>() == 0))
-            throw Exception("Parameter for aggregate function " + name + " should be positive number", ErrorCodes::BAD_ARGUMENTS);
+            throw Exception("Parameter for aggregate function " + name + " should be positive integer", ErrorCodes::BAD_ARGUMENTS);
 
         limit_size = true;
         max_elems = parameters[0].get<UInt64>();
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h
index 13895dea8d4c..a933c5dde064 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupArrayMoving.h
@@ -28,60 +28,51 @@ namespace ErrorCodes
     extern const int TOO_LARGE_ARRAY_SIZE;
 }
 
-
 template <typename T>
-struct MovingSumData
+struct MovingData
 {
-    // Switch to ordinary Allocator after 4096 bytes to avoid fragmentation and trash in Arena
+    using Accumulator = T;
+
+    /// Switch to ordinary Allocator after 4096 bytes to avoid fragmentation and trash in Arena
     using Allocator = MixedAlignedArenaAllocator<alignof(T), 4096>;
     using Array = PODArray<T, 32, Allocator>;
 
-    Array value;
-    Array window;
+    Array value;    /// Prefix sums.
     T sum = 0;
 
     void add(T val, Arena * arena)
     {
         sum += val;
-
         value.push_back(sum, arena);
     }
+};
+
+template <typename T>
+struct MovingSumData : public MovingData<T>
+{
+    static constexpr auto name = "groupArrayMovingSum";
 
-    T get(size_t idx, UInt64 win_size) const
+    T get(size_t idx, UInt64 window_size) const
     {
-        if (idx < win_size)
-            return value[idx];
+        if (idx < window_size)
+            return this->value[idx];
         else
-            return value[idx] - value[idx - win_size];
+            return this->value[idx] - this->value[idx - window_size];
     }
-
 };
 
 template <typename T>
-struct MovingAvgData
+struct MovingAvgData : public MovingData<T>
 {
-    // Switch to ordinary Allocator after 4096 bytes to avoid fragmentation and trash in Arena
-    using Allocator = MixedAlignedArenaAllocator<alignof(T), 4096>;
-    using Array = PODArray<T, 32, Allocator>;
-
-    Array value;
-    Array window;
-    T sum = 0;
+    static constexpr auto name = "groupArrayMovingAvg";
 
-    void add(T val, Arena * arena)
-    {
-        sum += val;
-        value.push_back(sum, arena);
-    }
-
-    T get(size_t idx, UInt64 win_size) const
+    T get(size_t idx, UInt64 window_size) const
     {
-        if (idx < win_size)
-            return value[idx] / win_size;
+        if (idx < window_size)
+            return this->value[idx] / window_size;
         else
-            return (value[idx] - value[idx - win_size]) / win_size;
+            return (this->value[idx] - this->value[idx - window_size]) / window_size;
     }
-
 };
 
 
@@ -90,30 +81,43 @@ class MovingImpl final
     : public IAggregateFunctionDataHelper<Data, MovingImpl<T, Tlimit_num_elems, Data>>
 {
     static constexpr bool limit_num_elems = Tlimit_num_elems::value;
-    DataTypePtr & data_type;
-    UInt64 win_size;
+    UInt64 window_size;
 
 public:
-    using ColVecType = std::conditional_t<IsDecimalNumber<T>, ColumnDecimal<T>, ColumnVector<T>>;
-    // probably for overflow function in the future
-    using ColVecResult = std::conditional_t<IsDecimalNumber<T>, ColumnDecimal<T>, ColumnVector<T>>;
+    using ResultT = typename Data::Accumulator;
+
+    using ColumnSource = std::conditional_t<IsDecimalNumber<T>,
+        ColumnDecimal<T>,
+        ColumnVector<T>>;
+
+    /// Probably for overflow function in the future.
+    using ColumnResult = std::conditional_t<IsDecimalNumber<ResultT>,
+        ColumnDecimal<ResultT>,
+        ColumnVector<ResultT>>;
 
-    explicit MovingImpl(const DataTypePtr & data_type_, UInt64 win_size_ = std::numeric_limits<UInt64>::max())
+    using DataTypeResult = std::conditional_t<IsDecimalNumber<ResultT>,
+        DataTypeDecimal<ResultT>,
+        DataTypeNumber<ResultT>>;
+
+    explicit MovingImpl(const DataTypePtr & data_type_, UInt64 window_size_ = std::numeric_limits<UInt64>::max())
         : IAggregateFunctionDataHelper<Data, MovingImpl<T, Tlimit_num_elems, Data>>({data_type_}, {})
-        , data_type(this->argument_types[0]), win_size(win_size_) {}
+        , window_size(window_size_) {}
 
-    String getName() const override { return "movingXXX"; }
+    String getName() const override { return Data::name; }
 
     DataTypePtr getReturnType() const override
     {
-        return std::make_shared<DataTypeArray>(data_type);
+        if constexpr (IsDecimalNumber<ResultT>)
+            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeResult>(
+                DataTypeResult::maxPrecision(), getDecimalScale(*this->argument_types.at(0))));
+        else
+            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeResult>());
     }
 
     void add(AggregateDataPtr place, const IColumn ** columns, size_t row_num, Arena * arena) const override
     {
-        auto val = static_cast<const ColVecType &>(*columns[0]).getData()[row_num];
-
-        this->data(place).add(val, arena);
+        auto value = static_cast<const ColumnSource &>(*columns[0]).getData()[row_num];
+        this->data(place).add(value, arena);
     }
 
     void merge(AggregateDataPtr place, ConstAggregateDataPtr rhs, Arena * arena) const override
@@ -170,7 +174,7 @@ class MovingImpl final
 
         if (size)
         {
-            typename ColVecResult::Container & data_to = static_cast<ColVecResult &>(arr_to.getData()).getData();
+            typename ColumnResult::Container & data_to = assert_cast<ColumnResult &>(arr_to.getData()).getData();
 
             for (size_t i = 0; i < size; ++i)
             {
@@ -180,7 +184,7 @@ class MovingImpl final
                 }
                 else
                 {
-                    data_to.push_back(data.get(i, win_size));
+                    data_to.push_back(data.get(i, window_size));
                 }
             }
         }
