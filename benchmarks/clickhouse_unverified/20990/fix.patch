diff --git a/src/DataStreams/CheckConstraintsBlockOutputStream.cpp b/src/DataStreams/CheckConstraintsBlockOutputStream.cpp
index a967ee285027..90d6560b9a8c 100644
--- a/src/DataStreams/CheckConstraintsBlockOutputStream.cpp
+++ b/src/DataStreams/CheckConstraintsBlockOutputStream.cpp
@@ -1,12 +1,15 @@
-#include <DataStreams/CheckConstraintsBlockOutputStream.h>
-#include <Parsers/formatAST.h>
-#include <Interpreters/ExpressionActions.h>
-#include <Columns/ColumnsCommon.h>
-#include <Columns/ColumnsNumber.h>
-#include <Columns/ColumnConst.h>
 #include <Common/assert_cast.h>
 #include <Common/quoteString.h>
 #include <Common/FieldVisitors.h>
+#include <DataTypes/DataTypeNullable.h>
+#include <DataTypes/DataTypeLowCardinality.h>
+#include <Columns/ColumnsCommon.h>
+#include <Columns/ColumnsNumber.h>
+#include <Columns/ColumnConst.h>
+#include <Columns/ColumnNullable.h>
+#include <DataStreams/CheckConstraintsBlockOutputStream.h>
+#include <Parsers/formatAST.h>
+#include <Interpreters/ExpressionActions.h>
 
 
 namespace DB
@@ -15,7 +18,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int VIOLATED_CONSTRAINT;
-    extern const int LOGICAL_ERROR;
+    extern const int UNSUPPORTED_METHOD;
 }
 
 
@@ -48,62 +51,77 @@ void CheckConstraintsBlockOutputStream::write(const Block & block)
 
             ColumnWithTypeAndName res_column = block_to_calculate.getByName(constraint_ptr->expr->getColumnName());
 
-            if (!isUInt8(res_column.type))
-                throw Exception(ErrorCodes::LOGICAL_ERROR, "Constraint {} does not return a value of type UInt8",
+            auto result_type = removeNullable(removeLowCardinality(res_column.type));
+
+            if (!isUInt8(result_type))
+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Constraint {} does not return a value of type UInt8",
                     backQuote(constraint_ptr->name));
 
-            if (const ColumnConst * res_const = typeid_cast<const ColumnConst *>(res_column.column.get()))
+            auto result_column = res_column.column->convertToFullColumnIfConst()->convertToFullColumnIfLowCardinality();
+
+            if (const auto * column_nullable = checkAndGetColumn<ColumnNullable>(*result_column))
             {
-                UInt8 value = res_const->getValue<UInt64>();
+                const auto & nested_column = column_nullable->getNestedColumnPtr();
 
-                /// Is violated.
-                if (!value)
-                {
-                    throw Exception(ErrorCodes::VIOLATED_CONSTRAINT,
-                                    "Constraint {} for table {} is violated, because it is a constant expression returning 0. "
-                                    "It is most likely an error in table definition.",
-                                    backQuote(constraint_ptr->name), table_id.getNameForLogs());
-                }
+                /// Check if constraint value is nullable
+                const auto & null_map = column_nullable->getNullMapColumn();
+                const auto & data = null_map.getData();
+                const auto * it = std::find(data.begin(), data.end(), true);
+
+                bool null_map_contains_null = it != data.end();
+
+                if (null_map_contains_null)
+                    throw Exception(
+                        ErrorCodes::VIOLATED_CONSTRAINT,
+                        "Constraint {} for table {} is violated. Expression: ({})."\
+                        "Constraint expression returns nullable column that contains null value",
+                        backQuote(constraint_ptr->name),
+                        table_id.getNameForLogs(),
+                        serializeAST(*(constraint_ptr->expr), true));
+
+                result_column = nested_column;
             }
-            else
-            {
-                const ColumnUInt8 & res_column_uint8 = assert_cast<const ColumnUInt8 &>(*res_column.column);
 
-                const UInt8 * data = res_column_uint8.getData().data();
-                size_t size = res_column_uint8.size();
+            const ColumnUInt8 & res_column_uint8 = assert_cast<const ColumnUInt8 &>(*result_column);
+
+            const UInt8 * data = res_column_uint8.getData().data();
+            size_t size = res_column_uint8.size();
 
-                /// Is violated.
-                if (!memoryIsByte(data, size, 1))
+            /// Is violated.
+            if (!memoryIsByte(data, size, 1))
+            {
+                size_t row_idx = 0;
+                for (; row_idx < size; ++row_idx)
+                    if (data[row_idx] != 1)
+                        break;
+
+                Names related_columns = constraint_expr->getRequiredColumns();
+
+                bool first = true;
+                String column_values_msg;
+                constexpr size_t approx_bytes_for_col = 32;
+                column_values_msg.reserve(approx_bytes_for_col * related_columns.size());
+                for (const auto & name : related_columns)
                 {
-                    size_t row_idx = 0;
-                    for (; row_idx < size; ++row_idx)
-                        if (data[row_idx] != 1)
-                            break;
-
-                    Names related_columns = constraint_expr->getRequiredColumns();
-
-                    bool first = true;
-                    String column_values_msg;
-                    constexpr size_t approx_bytes_for_col = 32;
-                    column_values_msg.reserve(approx_bytes_for_col * related_columns.size());
-                    for (const auto & name : related_columns)
-                    {
-                        const IColumn & column = *block.getByName(name).column;
-                        assert(row_idx < column.size());
-
-                        if (!first)
-                            column_values_msg.append(", ");
-                        column_values_msg.append(backQuoteIfNeed(name));
-                        column_values_msg.append(" = ");
-                        column_values_msg.append(applyVisitor(FieldVisitorToString(), column[row_idx]));
-                        first = false;
-                    }
-
-                    throw Exception(ErrorCodes::VIOLATED_CONSTRAINT,
-                                    "Constraint {} for table {} is violated at row {}. Expression: ({}). Column values: {}",
-                                    backQuote(constraint_ptr->name), table_id.getNameForLogs(), rows_written + row_idx + 1,
-                                    serializeAST(*(constraint_ptr->expr), true), column_values_msg);
+                    const IColumn & column = *block.getByName(name).column;
+                    assert(row_idx < column.size());
+
+                    if (!first)
+                        column_values_msg.append(", ");
+                    column_values_msg.append(backQuoteIfNeed(name));
+                    column_values_msg.append(" = ");
+                    column_values_msg.append(applyVisitor(FieldVisitorToString(), column[row_idx]));
+                    first = false;
                 }
+
+                throw Exception(
+                    ErrorCodes::VIOLATED_CONSTRAINT,
+                    "Constraint {} for table {} is violated at row {}. Expression: ({}). Column values: {}",
+                    backQuote(constraint_ptr->name),
+                    table_id.getNameForLogs(),
+                    rows_written + row_idx + 1,
+                    serializeAST(*(constraint_ptr->expr), true),
+                    column_values_msg);
             }
         }
     }
