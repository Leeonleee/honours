diff --git a/.gitmodules b/.gitmodules
index 86fd7832dd9f..c3592372b7eb 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -347,3 +347,15 @@
 [submodule "contrib/incbin"]
 	path = contrib/incbin
 	url = https://github.com/graphitemaster/incbin.git
+[submodule "contrib/usearch"]
+	path = contrib/usearch
+	url = https://github.com/unum-cloud/usearch.git
+[submodule "contrib/SimSIMD"]
+	path = contrib/SimSIMD
+	url = https://github.com/ashvardanian/SimSIMD.git
+[submodule "contrib/FP16"]
+	path = contrib/FP16
+	url = https://github.com/Maratyszcza/FP16.git
+[submodule "contrib/robin-map"]
+	path = contrib/robin-map
+	url = https://github.com/Tessil/robin-map.git
diff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt
index 16135351cce6..2557ebf78ae5 100644
--- a/contrib/CMakeLists.txt
+++ b/contrib/CMakeLists.txt
@@ -196,6 +196,17 @@ if (ARCH_S390X)
     add_contrib(crc32-s390x-cmake crc32-s390x)
 endif()
 add_contrib (annoy-cmake annoy)
+
+option(ENABLE_USEARCH "Enable USearch (Approximate Neighborhood Search, HNSW) support" ${ENABLE_LIBRARIES})
+if (ENABLE_USEARCH)
+    add_contrib (FP16-cmake FP16)
+    add_contrib (robin-map-cmake robin-map)
+    add_contrib (SimSIMD-cmake SimSIMD)
+    add_contrib (usearch-cmake usearch) # requires: FP16, robin-map, SimdSIMD
+else ()
+    message(STATUS "Not using USearch")
+endif ()
+
 add_contrib (xxHash-cmake xxHash)
 
 add_contrib (libbcrypt-cmake libbcrypt)
diff --git a/contrib/FP16 b/contrib/FP16
new file mode 160000
index 000000000000..0a92994d729f
--- /dev/null
+++ b/contrib/FP16
@@ -0,0 +1,1 @@
+Subproject commit 0a92994d729ff76a58f692d3028ca1b64b145d91
diff --git a/contrib/FP16-cmake/CMakeLists.txt b/contrib/FP16-cmake/CMakeLists.txt
new file mode 100644
index 000000000000..f82ad705dcc7
--- /dev/null
+++ b/contrib/FP16-cmake/CMakeLists.txt
@@ -0,0 +1,1 @@
+# See contrib/usearch-cmake/CMakeLists.txt
diff --git a/contrib/SimSIMD b/contrib/SimSIMD
new file mode 160000
index 000000000000..de2cb75b9e9e
--- /dev/null
+++ b/contrib/SimSIMD
@@ -0,0 +1,1 @@
+Subproject commit de2cb75b9e9e3389d5e1e51fd9f8ed151f3c17cf
diff --git a/contrib/SimSIMD-cmake/CMakeLists.txt b/contrib/SimSIMD-cmake/CMakeLists.txt
new file mode 100644
index 000000000000..f82ad705dcc7
--- /dev/null
+++ b/contrib/SimSIMD-cmake/CMakeLists.txt
@@ -0,0 +1,1 @@
+# See contrib/usearch-cmake/CMakeLists.txt
diff --git a/contrib/robin-map b/contrib/robin-map
new file mode 160000
index 000000000000..851a59e0e306
--- /dev/null
+++ b/contrib/robin-map
@@ -0,0 +1,1 @@
+Subproject commit 851a59e0e3063ee0e23089062090a73fd3de482d
diff --git a/contrib/robin-map-cmake/CMakeLists.txt b/contrib/robin-map-cmake/CMakeLists.txt
new file mode 100644
index 000000000000..f82ad705dcc7
--- /dev/null
+++ b/contrib/robin-map-cmake/CMakeLists.txt
@@ -0,0 +1,1 @@
+# See contrib/usearch-cmake/CMakeLists.txt
diff --git a/contrib/usearch b/contrib/usearch
new file mode 160000
index 000000000000..387b78b28b17
--- /dev/null
+++ b/contrib/usearch
@@ -0,0 +1,1 @@
+Subproject commit 387b78b28b17b8954024ffc81e97cbcfa10d1f30
diff --git a/contrib/usearch-cmake/CMakeLists.txt b/contrib/usearch-cmake/CMakeLists.txt
new file mode 100644
index 000000000000..29fbe57106c7
--- /dev/null
+++ b/contrib/usearch-cmake/CMakeLists.txt
@@ -0,0 +1,17 @@
+set(USEARCH_PROJECT_DIR "${ClickHouse_SOURCE_DIR}/contrib/usearch")
+set(USEARCH_SOURCE_DIR "${USEARCH_PROJECT_DIR}/include")
+
+set(FP16_PROJECT_DIR "${ClickHouse_SOURCE_DIR}/contrib/FP16")
+set(ROBIN_MAP_PROJECT_DIR "${ClickHouse_SOURCE_DIR}/contrib/robin-map")
+set(SIMSIMD_PROJECT_DIR "${ClickHouse_SOURCE_DIR}/contrib/SimSIMD-map")
+
+add_library(_usearch INTERFACE)
+
+target_include_directories(_usearch SYSTEM INTERFACE
+    ${FP16_PROJECT_DIR}/include
+    ${ROBIN_MAP_PROJECT_DIR}/include
+    ${SIMSIMD_PROJECT_DIR}/include
+    ${USEARCH_SOURCE_DIR})
+
+add_library(ch_contrib::usearch ALIAS _usearch)
+target_compile_definitions(_usearch INTERFACE ENABLE_USEARCH)
diff --git a/docs/en/engines/table-engines/mergetree-family/annindexes.md b/docs/en/engines/table-engines/mergetree-family/annindexes.md
index 81c69215472a..ee91794b20ee 100644
--- a/docs/en/engines/table-engines/mergetree-family/annindexes.md
+++ b/docs/en/engines/table-engines/mergetree-family/annindexes.md
@@ -142,13 +142,15 @@ was specified for ANN indexes, the default value is 100 million.
 
 - [Annoy](/docs/en/engines/table-engines/mergetree-family/annindexes.md#annoy-annoy)
 
+- [USearch](/docs/en/engines/table-engines/mergetree-family/annindexes.md#usearch-usearch)
+
 ## Annoy {#annoy}
 
 Annoy indexes are currently experimental, to use them you first need to `SET allow_experimental_annoy_index = 1`. They are also currently
 disabled on ARM due to memory safety problems with the algorithm.
 
-This type of ANN index implements [the Annoy algorithm](https://github.com/spotify/annoy) which is based on a recursive division of the
-space in random linear surfaces (lines in 2D, planes in 3D etc.).
+This type of ANN index is based on the [Annoy library](https://github.com/spotify/annoy) which recursively divides the space into random
+linear surfaces (lines in 2D, planes in 3D etc.).
 
 <div class='vimeo-container'>
   <iframe src="//www.youtube.com/embed/QkCCyLW0ehU"
@@ -216,3 +218,60 @@ ORDER BY L2Distance(vectors, Point)
 LIMIT N
 SETTINGS annoy_index_search_k_nodes=100;
 ```
+
+## USearch {#usearch}
+
+This type of ANN index is based on the [the USearch library](https://github.com/unum-cloud/usearch), which implements the [HNSW
+algorithm](https://arxiv.org/abs/1603.09320), i.e., builds a hierarchical graph where each point represents a vector and the edges represent
+similarity. Such hierarchical structures can be very efficient on large collections. They may often fetch 0.05% or less data from the
+overall dataset, while still providing 99% recall. This is especially useful when working with high-dimensional vectors,
+that are expensive to load and compare. The library also has several hardware-specific SIMD optimizations to accelerate further
+distance computations on modern Arm (NEON and SVE) and x86 (AVX2 and AVX-512) CPUs and OS-specific optimizations to allow efficient
+navigation around immutable persistent files, without loading them into RAM.
+
+<div class='vimeo-container'>
+  <iframe src="//www.youtube.com/embed/UMrhB3icP9w"
+    width="640"
+    height="360"
+    frameborder="0"
+    allow="autoplay;
+    fullscreen;
+    picture-in-picture"
+    allowfullscreen>
+  </iframe>
+</div>
+
+Syntax to create an USearch index over an [Array](../../../sql-reference/data-types/array.md) column:
+
+```sql
+CREATE TABLE table_with_usearch_index
+(
+  id Int64,
+  vectors Array(Float32),
+  INDEX [ann_index_name] vectors TYPE usearch([Distance]) [GRANULARITY N]
+)
+ENGINE = MergeTree
+ORDER BY id;
+```
+
+Syntax to create an ANN index over a [Tuple](../../../sql-reference/data-types/tuple.md) column:
+
+```sql
+CREATE TABLE table_with_usearch_index
+(
+  id Int64,
+  vectors Tuple(Float32[, Float32[, ...]]),
+  INDEX [ann_index_name] vectors TYPE usearch([Distance]) [GRANULARITY N]
+)
+ENGINE = MergeTree
+ORDER BY id;
+```
+
+USearch currently supports two distance functions:
+- `L2Distance`, also called Euclidean distance, is the length of a line segment between two points in Euclidean space
+  ([Wikipedia](https://en.wikipedia.org/wiki/Euclidean_distance)).
+- `cosineDistance`, also called cosine similarity, is the cosine of the angle between two (non-zero) vectors
+  ([Wikipedia](https://en.wikipedia.org/wiki/Cosine_similarity)).
+
+For normalized data, `L2Distance` is usually a better choice, otherwise `cosineDistance` is recommended to compensate for scale. If no
+distance function was specified during index creation, `L2Distance` is used as default.
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ddb6fcebd230..e4e9fd19cff4 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -599,6 +599,10 @@ if (TARGET ch_contrib::annoy)
     dbms_target_link_libraries(PUBLIC ch_contrib::annoy)
 endif()
 
+if (TARGET ch_contrib::usearch)
+    dbms_target_link_libraries(PUBLIC ch_contrib::usearch)
+endif()
+
 if (TARGET ch_rust::skim)
     dbms_target_include_directories(PRIVATE $<TARGET_PROPERTY:ch_rust::skim,INTERFACE_INCLUDE_DIRECTORIES>)
     dbms_target_link_libraries(PUBLIC ch_rust::skim)
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 714ac17a15df..14714981c001 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -772,6 +772,7 @@ class IColumn;
     M(Bool, allow_experimental_hash_functions, false, "Enable experimental hash functions", 0) \
     M(Bool, allow_experimental_object_type, false, "Allow Object and JSON data types", 0) \
     M(Bool, allow_experimental_annoy_index, false, "Allows to use Annoy index. Disabled by default because this feature is experimental", 0) \
+    M(Bool, allow_experimental_usearch_index, false, "Allows to use USearch index. Disabled by default because this feature is experimental", 0) \
     M(UInt64, max_limit_for_ann_queries, 1'000'000, "SELECT queries with LIMIT bigger than this setting cannot use ANN indexes. Helps to prevent memory overflows in ANN search indexes.", 0) \
     M(Int64, annoy_index_search_k_nodes, -1, "SELECT queries search up to this many nodes in Annoy indexes.", 0) \
     M(Bool, throw_on_unsupported_query_inside_transaction, true, "Throw exception if unsupported query is used inside transaction", 0) \
diff --git a/src/Databases/DatabaseReplicated.cpp b/src/Databases/DatabaseReplicated.cpp
index 304c0a20e26f..acd3efc74bb3 100644
--- a/src/Databases/DatabaseReplicated.cpp
+++ b/src/Databases/DatabaseReplicated.cpp
@@ -830,6 +830,7 @@ void DatabaseReplicated::recoverLostReplica(const ZooKeeperPtr & current_zookeep
         query_context->setSetting("allow_experimental_hash_functions", 1);
         query_context->setSetting("allow_experimental_object_type", 1);
         query_context->setSetting("allow_experimental_annoy_index", 1);
+        query_context->setSetting("allow_experimental_usearch_index", 1);
         query_context->setSetting("allow_experimental_bigint_types", 1);
         query_context->setSetting("allow_experimental_window_functions", 1);
         query_context->setSetting("allow_experimental_geo_types", 1);
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 571890123177..92d74f4f18a2 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -704,6 +704,9 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::getTableProperti
                 if (index_desc.type == "annoy" && !settings.allow_experimental_annoy_index)
                     throw Exception(ErrorCodes::INCORRECT_QUERY, "Annoy index is disabled. Turn on allow_experimental_annoy_index");
 
+                if (index_desc.type == "usearch" && !settings.allow_experimental_usearch_index)
+                    throw Exception(ErrorCodes::INCORRECT_QUERY, "USearch index is disabled. Turn on allow_experimental_usearch_index");
+
                 properties.indices.push_back(index_desc);
             }
         if (create.columns_list->projections)
diff --git a/src/Parsers/ASTIndexDeclaration.h b/src/Parsers/ASTIndexDeclaration.h
index 6ed241f75abf..1fbf5e126959 100644
--- a/src/Parsers/ASTIndexDeclaration.h
+++ b/src/Parsers/ASTIndexDeclaration.h
@@ -14,6 +14,7 @@ class ASTIndexDeclaration : public IAST
 public:
     static const auto DEFAULT_INDEX_GRANULARITY = 1uz;
     static const auto DEFAULT_ANNOY_INDEX_GRANULARITY = 100'000'000uz;
+    static const auto DEFAULT_USEARCH_INDEX_GRANULARITY = 100'000'000uz;
 
     String name;
     IAST * expr;
diff --git a/src/Parsers/ParserCreateIndexQuery.cpp b/src/Parsers/ParserCreateIndexQuery.cpp
index 67051d84999b..81954e3c2471 100644
--- a/src/Parsers/ParserCreateIndexQuery.cpp
+++ b/src/Parsers/ParserCreateIndexQuery.cpp
@@ -66,6 +66,8 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected
     {
         if (index->type && index->type->name == "annoy")
             index->granularity = ASTIndexDeclaration::DEFAULT_ANNOY_INDEX_GRANULARITY;
+        else if (index->type && index->type->name == "usearch")
+            index->granularity = ASTIndexDeclaration::DEFAULT_USEARCH_INDEX_GRANULARITY;
         else
             index->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;
     }
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index 82674ab1a353..e11c94d03092 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -148,6 +148,8 @@ bool ParserIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
     {
         if (index->type->name == "annoy")
             index->granularity = ASTIndexDeclaration::DEFAULT_ANNOY_INDEX_GRANULARITY;
+        else if (index->type->name == "usearch")
+            index->granularity = ASTIndexDeclaration::DEFAULT_USEARCH_INDEX_GRANULARITY;
         else
             index->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;
     }
diff --git a/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h b/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h
index 310890eba1ec..5092fbdd864f 100644
--- a/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h
+++ b/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h
@@ -9,6 +9,9 @@
 namespace DB
 {
 
+static constexpr auto DISTANCE_FUNCTION_L2 = "L2Distance";
+static constexpr auto DISTANCE_FUNCTION_COSINE = "cosineDistance";
+
 /// Approximate Nearest Neighbour queries have a similar structure:
 /// - reference vector from which all distances are calculated
 /// - metric name (e.g L2Distance, LpDistance, etc.)
diff --git a/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp b/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp
index 1c92645dbfa4..13577229a752 100644
--- a/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp
+++ b/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp
@@ -25,12 +25,6 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
-static constexpr auto DISTANCE_FUNCTION_L2 = "L2Distance";
-static constexpr auto DISTANCE_FUNCTION_COSINE = "cosineDistance";
-
-static constexpr auto DEFAULT_TREES = 100uz;
-static constexpr auto DEFAULT_DISTANCE_FUNCTION = DISTANCE_FUNCTION_L2;
-
 template <typename Distance>
 AnnoyIndexWithSerialization<Distance>::AnnoyIndexWithSerialization(size_t dimensions)
     : Base::AnnoyIndex(dimensions)
@@ -318,10 +312,12 @@ MergeTreeIndexConditionPtr MergeTreeIndexAnnoy::createIndexCondition(const Selec
 
 MergeTreeIndexPtr annoyIndexCreator(const IndexDescription & index)
 {
+    static constexpr auto DEFAULT_DISTANCE_FUNCTION = DISTANCE_FUNCTION_L2;
     String distance_function = DEFAULT_DISTANCE_FUNCTION;
     if (!index.arguments.empty())
         distance_function = index.arguments[0].get<String>();
 
+    static constexpr auto DEFAULT_TREES = 100uz;
     UInt64 trees = DEFAULT_TREES;
     if (index.arguments.size() > 1)
         trees = index.arguments[1].get<UInt64>();
diff --git a/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp b/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp
new file mode 100644
index 000000000000..d2433517766e
--- /dev/null
+++ b/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp
@@ -0,0 +1,377 @@
+#ifdef ENABLE_USEARCH
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wpass-failed"
+
+#include <Storages/MergeTree/MergeTreeIndexUSearch.h>
+
+#include <Columns/ColumnArray.h>
+#include <Common/typeid_cast.h>
+#include <Core/Field.h>
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypeTuple.h>
+#include <IO/ReadHelpers.h>
+#include <IO/WriteHelpers.h>
+#include <Interpreters/Context.h>
+#include <Interpreters/castColumn.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int CANNOT_ALLOCATE_MEMORY;
+    extern const int ILLEGAL_COLUMN;
+    extern const int INCORRECT_DATA;
+    extern const int INCORRECT_NUMBER_OF_COLUMNS;
+    extern const int INCORRECT_QUERY;
+    extern const int LOGICAL_ERROR;
+}
+
+template <unum::usearch::metric_kind_t Metric>
+USearchIndexWithSerialization<Metric>::USearchIndexWithSerialization(size_t dimensions)
+    : Base(Base::make(unum::usearch::metric_punned_t(dimensions, Metric)))
+{
+}
+
+template <unum::usearch::metric_kind_t Metric>
+void USearchIndexWithSerialization<Metric>::serialize([[maybe_unused]] WriteBuffer & ostr) const
+{
+    auto callback = [&ostr](void * from, size_t n)
+    {
+        ostr.write(reinterpret_cast<const char *>(from), n);
+        return true;
+    };
+
+    Base::stream(callback);
+}
+
+template <unum::usearch::metric_kind_t Metric>
+void USearchIndexWithSerialization<Metric>::deserialize([[maybe_unused]] ReadBuffer & istr)
+{
+    BufferBase::Position & pos = istr.position();
+    unum::usearch::memory_mapped_file_t memory_map(pos, istr.buffer().size() - istr.count());
+    Base::view(std::move(memory_map));
+    pos += Base::stream_length();
+
+    auto copy = Base::copy();
+    if (!copy)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Could not copy usearch index");
+    Base::swap(copy.index);
+}
+
+template <unum::usearch::metric_kind_t Metric>
+size_t USearchIndexWithSerialization<Metric>::getDimensions() const
+{
+    return Base::dimensions();
+}
+
+template <unum::usearch::metric_kind_t Metric>
+MergeTreeIndexGranuleUSearch<Metric>::MergeTreeIndexGranuleUSearch(
+    const String & index_name_,
+    const Block & index_sample_block_)
+    : index_name(index_name_)
+    , index_sample_block(index_sample_block_)
+    , index(nullptr)
+{
+}
+
+template <unum::usearch::metric_kind_t Metric>
+MergeTreeIndexGranuleUSearch<Metric>::MergeTreeIndexGranuleUSearch(
+    const String & index_name_,
+    const Block & index_sample_block_,
+    USearchIndexWithSerializationPtr<Metric> index_)
+    : index_name(index_name_)
+    , index_sample_block(index_sample_block_)
+    , index(std::move(index_))
+{
+}
+
+template <unum::usearch::metric_kind_t Metric>
+void MergeTreeIndexGranuleUSearch<Metric>::serializeBinary(WriteBuffer & ostr) const
+{
+    /// Number of dimensions is required in the index constructor,
+    /// so it must be written and read separately from the other part
+    writeIntBinary(static_cast<UInt64>(index->getDimensions()), ostr); // write dimension
+    index->serialize(ostr);
+}
+
+template <unum::usearch::metric_kind_t Metric>
+void MergeTreeIndexGranuleUSearch<Metric>::deserializeBinary(ReadBuffer & istr, MergeTreeIndexVersion /*version*/)
+{
+    UInt64 dimension;
+    readIntBinary(dimension, istr);
+    index = std::make_shared<USearchIndexWithSerialization<Metric>>(dimension);
+    index->deserialize(istr);
+}
+
+template <unum::usearch::metric_kind_t Metric>
+MergeTreeIndexAggregatorUSearch<Metric>::MergeTreeIndexAggregatorUSearch(
+    const String & index_name_,
+    const Block & index_sample_block_)
+    : index_name(index_name_)
+    , index_sample_block(index_sample_block_)
+{
+}
+
+template <unum::usearch::metric_kind_t Metric>
+MergeTreeIndexGranulePtr MergeTreeIndexAggregatorUSearch<Metric>::getGranuleAndReset()
+{
+    auto granule = std::make_shared<MergeTreeIndexGranuleUSearch<Metric>>(index_name, index_sample_block, index);
+    index = nullptr;
+    return granule;
+}
+
+template <unum::usearch::metric_kind_t Metric>
+void MergeTreeIndexAggregatorUSearch<Metric>::update(const Block & block, size_t * pos, size_t limit)
+{
+    if (*pos >= block.rows())
+        throw Exception(
+            ErrorCodes::LOGICAL_ERROR,
+            "The provided position is not less than the number of block rows. Position: {}, Block rows: {}.",
+            *pos,
+            block.rows());
+
+    size_t rows_read = std::min(limit, block.rows() - *pos);
+    if (rows_read == 0)
+        return;
+
+    if (index_sample_block.columns() > 1)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Expected block with single column");
+
+    const String & index_column_name = index_sample_block.getByPosition(0).name;
+    ColumnPtr column_cut = block.getByName(index_column_name).column->cut(*pos, rows_read);
+
+    if (const auto & column_array = typeid_cast<const ColumnArray *>(column_cut.get()))
+    {
+        const auto & data = column_array->getData();
+        const auto & array = typeid_cast<const ColumnFloat32 &>(data).getData();
+
+        if (array.empty())
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Array has 0 rows, {} rows expected", rows_read);
+
+        const auto & offsets = column_array->getOffsets();
+        const size_t num_rows = offsets.size();
+
+
+        /// Check all sizes are the same
+        size_t size = offsets[0];
+        for (size_t i = 0; i < num_rows - 1; ++i)
+            if (offsets[i + 1] - offsets[i] != size)
+                throw Exception(ErrorCodes::INCORRECT_DATA, "All arrays in column {} must have equal length", index_column_name);
+
+
+        index = std::make_shared<USearchIndexWithSerialization<Metric>>(size);
+
+        /// Add all rows of block
+        if (!index->reserve(unum::usearch::ceil2(index->size() + num_rows)))
+            throw Exception(ErrorCodes::CANNOT_ALLOCATE_MEMORY, "Could not reserve memory for usearch index");
+
+        if (auto rc = index->add(index->size(), array.data()); !rc)
+            throw Exception(ErrorCodes::INCORRECT_DATA, rc.error.release());
+        for (size_t current_row = 1; current_row < num_rows; ++current_row)
+            if (auto rc = index->add(index->size(), &array[offsets[current_row - 1]]); !rc)
+                throw Exception(ErrorCodes::INCORRECT_DATA, rc.error.release());
+
+    }
+    else if (const auto & column_tuple = typeid_cast<const ColumnTuple *>(column_cut.get()))
+    {
+        const auto & columns = column_tuple->getColumns();
+        std::vector<std::vector<Float32>> data{column_tuple->size(), std::vector<Float32>()};
+        for (const auto & column : columns)
+        {
+            const auto & pod_array = typeid_cast<const ColumnFloat32 *>(column.get())->getData();
+            for (size_t i = 0; i < pod_array.size(); ++i)
+                data[i].push_back(pod_array[i]);
+        }
+
+        if (data.empty())
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Tuple has 0 rows, {} rows expected", rows_read);
+
+        index = std::make_shared<USearchIndexWithSerialization<Metric>>(data[0].size());
+
+        if (!index->reserve(unum::usearch::ceil2(index->size() + data.size())))
+            throw Exception(ErrorCodes::CANNOT_ALLOCATE_MEMORY, "Could not reserve memory for usearch index");
+
+        for (const auto & item : data)
+            if (auto rc = index->add(index->size(), item.data()); !rc)
+                throw Exception(ErrorCodes::INCORRECT_DATA, rc.error.release());
+    }
+    else
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Expected Array or Tuple column");
+
+    *pos += rows_read;
+}
+
+MergeTreeIndexConditionUSearch::MergeTreeIndexConditionUSearch(
+    const IndexDescription & /*index_description*/,
+    const SelectQueryInfo & query,
+    const String & distance_function_,
+    ContextPtr context)
+    : ann_condition(query, context)
+    , distance_function(distance_function_)
+{
+}
+
+bool MergeTreeIndexConditionUSearch::mayBeTrueOnGranule(MergeTreeIndexGranulePtr /*idx_granule*/) const
+{
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "mayBeTrueOnGranule is not supported for ANN skip indexes");
+}
+
+bool MergeTreeIndexConditionUSearch::alwaysUnknownOrTrue() const
+{
+    return ann_condition.alwaysUnknownOrTrue(distance_function);
+}
+
+std::vector<size_t> MergeTreeIndexConditionUSearch::getUsefulRanges(MergeTreeIndexGranulePtr idx_granule) const
+{
+    if (distance_function == DISTANCE_FUNCTION_L2)
+        return getUsefulRangesImpl<unum::usearch::metric_kind_t::l2sq_k>(idx_granule);
+    else if (distance_function == DISTANCE_FUNCTION_COSINE)
+        return getUsefulRangesImpl<unum::usearch::metric_kind_t::cos_k>(idx_granule);
+    std::unreachable();
+}
+
+template <unum::usearch::metric_kind_t Metric>
+std::vector<size_t> MergeTreeIndexConditionUSearch::getUsefulRangesImpl(MergeTreeIndexGranulePtr idx_granule) const
+{
+    const UInt64 limit = ann_condition.getLimit();
+    const UInt64 index_granularity = ann_condition.getIndexGranularity();
+    const std::optional<float> comparison_distance = ann_condition.getQueryType() == ApproximateNearestNeighborInformation::Type::Where
+        ? std::optional<float>(ann_condition.getComparisonDistanceForWhereQuery())
+        : std::nullopt;
+
+    if (comparison_distance && comparison_distance.value() < 0)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Attempt to optimize query with where without distance");
+
+    const std::vector<float> reference_vector = ann_condition.getReferenceVector();
+    const auto granule = std::dynamic_pointer_cast<MergeTreeIndexGranuleUSearch<Metric>>(idx_granule);
+    if (granule == nullptr)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Granule has the wrong type");
+
+    const USearchIndexWithSerializationPtr<Metric> index = granule->index;
+    if (ann_condition.getDimensions() != index->dimensions())
+        throw Exception(
+            ErrorCodes::INCORRECT_QUERY,
+            "The dimension of the space in the request ({}) "
+            "does not match the dimension in the index ({})",
+            ann_condition.getDimensions(),
+            index->dimensions());
+
+    auto result = index->search(reference_vector.data(), limit);
+    std::vector<UInt64> neighbors(result.size()); /// indexes of dots which were closest to the reference vector
+    std::vector<Float32> distances(result.size());
+    result.dump_to(neighbors.data(), distances.data());
+
+    std::vector<size_t> granule_numbers;
+    granule_numbers.reserve(neighbors.size());
+    for (size_t i = 0; i < neighbors.size(); ++i)
+    {
+        if (comparison_distance && distances[i] > comparison_distance)
+            continue;
+        granule_numbers.push_back(neighbors[i] / index_granularity);
+    }
+
+    /// make unique
+    std::sort(granule_numbers.begin(), granule_numbers.end());
+    granule_numbers.erase(std::unique(granule_numbers.begin(), granule_numbers.end()), granule_numbers.end());
+
+    return granule_numbers;
+}
+
+MergeTreeIndexUSearch::MergeTreeIndexUSearch(const IndexDescription & index_, const String & distance_function_)
+    : IMergeTreeIndex(index_)
+    , distance_function(distance_function_)
+{
+}
+
+MergeTreeIndexGranulePtr MergeTreeIndexUSearch::createIndexGranule() const
+{
+    if (distance_function == DISTANCE_FUNCTION_L2)
+        return std::make_shared<MergeTreeIndexGranuleUSearch<unum::usearch::metric_kind_t::l2sq_k>>(index.name, index.sample_block);
+    else if (distance_function == DISTANCE_FUNCTION_COSINE)
+        return std::make_shared<MergeTreeIndexGranuleUSearch<unum::usearch::metric_kind_t::cos_k>>(index.name, index.sample_block);
+    std::unreachable();
+}
+
+MergeTreeIndexAggregatorPtr MergeTreeIndexUSearch::createIndexAggregator() const
+{
+    if (distance_function == DISTANCE_FUNCTION_L2)
+        return std::make_shared<MergeTreeIndexAggregatorUSearch<unum::usearch::metric_kind_t::l2sq_k>>(index.name, index.sample_block);
+    else if (distance_function == DISTANCE_FUNCTION_COSINE)
+        return std::make_shared<MergeTreeIndexAggregatorUSearch<unum::usearch::metric_kind_t::cos_k>>(index.name, index.sample_block);
+    std::unreachable();
+}
+
+MergeTreeIndexConditionPtr MergeTreeIndexUSearch::createIndexCondition(const SelectQueryInfo & query, ContextPtr context) const
+{
+    return std::make_shared<MergeTreeIndexConditionUSearch>(index, query, distance_function, context);
+};
+
+MergeTreeIndexPtr usearchIndexCreator(const IndexDescription & index)
+{
+    static constexpr auto default_distance_function = DISTANCE_FUNCTION_L2;
+    String distance_function = default_distance_function;
+    if (!index.arguments.empty())
+        distance_function = index.arguments[0].get<String>();
+
+    return std::make_shared<MergeTreeIndexUSearch>(index, distance_function);
+}
+
+void usearchIndexValidator(const IndexDescription & index, bool /* attach */)
+{
+    /// Check number and type of USearch index arguments:
+
+    if (index.arguments.size() > 1)
+        throw Exception(ErrorCodes::INCORRECT_QUERY, "USearch index must not have more than one parameters");
+
+    if (!index.arguments.empty() && index.arguments[0].getType() != Field::Types::String)
+        throw Exception(ErrorCodes::INCORRECT_QUERY, "Distance function argument of USearch index must be of type String");
+
+    /// Check that the index is created on a single column
+
+    if (index.column_names.size() != 1 || index.data_types.size() != 1)
+        throw Exception(ErrorCodes::INCORRECT_NUMBER_OF_COLUMNS, "USearch indexes must be created on a single column");
+
+    /// Check that a supported metric was passed as first argument
+
+    if (!index.arguments.empty())
+    {
+        String distance_name = index.arguments[0].get<String>();
+        if (distance_name != DISTANCE_FUNCTION_L2 && distance_name != DISTANCE_FUNCTION_COSINE)
+            throw Exception(ErrorCodes::INCORRECT_DATA, "USearch index only supports distance functions '{}' and '{}'", DISTANCE_FUNCTION_L2, DISTANCE_FUNCTION_COSINE);
+    }
+
+    /// Check data type of indexed column:
+
+    auto throw_unsupported_underlying_column_exception = []()
+    {
+        throw Exception(
+            ErrorCodes::ILLEGAL_COLUMN, "USearch indexes can only be created on columns of type Array(Float32) and Tuple(Float32)");
+    };
+
+    DataTypePtr data_type = index.sample_block.getDataTypes()[0];
+
+    if (const auto * data_type_array = typeid_cast<const DataTypeArray *>(data_type.get()))
+    {
+        TypeIndex nested_type_index = data_type_array->getNestedType()->getTypeId();
+        if (!WhichDataType(nested_type_index).isFloat32())
+            throw_unsupported_underlying_column_exception();
+    }
+    else if (const auto * data_type_tuple = typeid_cast<const DataTypeTuple *>(data_type.get()))
+    {
+        const DataTypes & inner_types = data_type_tuple->getElements();
+        for (const auto & inner_type : inner_types)
+        {
+            TypeIndex nested_type_index = inner_type->getTypeId();
+            if (!WhichDataType(nested_type_index).isFloat32())
+                throw_unsupported_underlying_column_exception();
+        }
+    }
+    else
+        throw_unsupported_underlying_column_exception();
+}
+
+}
+
+#endif
diff --git a/src/Storages/MergeTree/MergeTreeIndexUSearch.h b/src/Storages/MergeTree/MergeTreeIndexUSearch.h
new file mode 100644
index 000000000000..f1fde934fd5c
--- /dev/null
+++ b/src/Storages/MergeTree/MergeTreeIndexUSearch.h
@@ -0,0 +1,106 @@
+#pragma once
+
+#ifdef ENABLE_USEARCH
+
+#include <Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h>
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wpass-failed"
+#include <usearch/index_dense.hpp>
+#pragma clang diagnostic pop
+
+namespace DB
+{
+
+template <unum::usearch::metric_kind_t Metric>
+class USearchIndexWithSerialization : public unum::usearch::index_dense_t
+{
+    using Base = unum::usearch::index_dense_t;
+
+public:
+    explicit USearchIndexWithSerialization(size_t dimensions);
+    void serialize(WriteBuffer & ostr) const;
+    void deserialize(ReadBuffer & istr);
+    size_t getDimensions() const;
+};
+
+template <unum::usearch::metric_kind_t Metric>
+using USearchIndexWithSerializationPtr = std::shared_ptr<USearchIndexWithSerialization<Metric>>;
+
+template <unum::usearch::metric_kind_t Metric>
+struct MergeTreeIndexGranuleUSearch final : public IMergeTreeIndexGranule
+{
+    MergeTreeIndexGranuleUSearch(const String & index_name_, const Block & index_sample_block_);
+    MergeTreeIndexGranuleUSearch(const String & index_name_, const Block & index_sample_block_, USearchIndexWithSerializationPtr<Metric> index_);
+
+    ~MergeTreeIndexGranuleUSearch() override = default;
+
+    void serializeBinary(WriteBuffer & ostr) const override;
+    void deserializeBinary(ReadBuffer & istr, MergeTreeIndexVersion version) override;
+
+    bool empty() const override { return !index.get(); }
+
+    const String index_name;
+    const Block index_sample_block;
+    USearchIndexWithSerializationPtr<Metric> index;
+};
+
+template <unum::usearch::metric_kind_t Metric>
+struct MergeTreeIndexAggregatorUSearch final : IMergeTreeIndexAggregator
+{
+    MergeTreeIndexAggregatorUSearch(const String & index_name_, const Block & index_sample_block);
+    ~MergeTreeIndexAggregatorUSearch() override = default;
+
+    bool empty() const override { return !index || index->size() == 0; }
+    MergeTreeIndexGranulePtr getGranuleAndReset() override;
+    void update(const Block & block, size_t * pos, size_t limit) override;
+
+    const String index_name;
+    const Block index_sample_block;
+    USearchIndexWithSerializationPtr<Metric> index;
+};
+
+
+class MergeTreeIndexConditionUSearch final : public IMergeTreeIndexConditionApproximateNearestNeighbor
+{
+public:
+    MergeTreeIndexConditionUSearch(const IndexDescription & index_description, const SelectQueryInfo & query, const String & distance_function, ContextPtr context);
+
+    ~MergeTreeIndexConditionUSearch() override = default;
+
+    bool alwaysUnknownOrTrue() const override;
+    bool mayBeTrueOnGranule(MergeTreeIndexGranulePtr idx_granule) const override;
+    std::vector<size_t> getUsefulRanges(MergeTreeIndexGranulePtr idx_granule) const override;
+
+private:
+    template <unum::usearch::metric_kind_t Metric>
+    std::vector<size_t> getUsefulRangesImpl(MergeTreeIndexGranulePtr idx_granule) const;
+
+    const ApproximateNearestNeighborCondition ann_condition;
+    const String distance_function;
+};
+
+
+class MergeTreeIndexUSearch : public IMergeTreeIndex
+{
+public:
+    MergeTreeIndexUSearch(const IndexDescription & index_, const String & distance_function_);
+
+    ~MergeTreeIndexUSearch() override = default;
+
+    MergeTreeIndexGranulePtr createIndexGranule() const override;
+    MergeTreeIndexAggregatorPtr createIndexAggregator() const override;
+    MergeTreeIndexConditionPtr createIndexCondition(const SelectQueryInfo & query, ContextPtr context) const override;
+
+    bool mayBenefitFromIndexForIn(const ASTPtr & /*node*/) const override { return false; }
+
+private:
+    const String distance_function;
+};
+
+
+}
+
+
+#endif
+
diff --git a/src/Storages/MergeTree/MergeTreeIndices.cpp b/src/Storages/MergeTree/MergeTreeIndices.cpp
index 6ae96d001711..322cdd35afe2 100644
--- a/src/Storages/MergeTree/MergeTreeIndices.cpp
+++ b/src/Storages/MergeTree/MergeTreeIndices.cpp
@@ -132,6 +132,11 @@ MergeTreeIndexFactory::MergeTreeIndexFactory()
     registerValidator("annoy", annoyIndexValidator);
 #endif
 
+#ifdef ENABLE_USEARCH
+    registerCreator("usearch", usearchIndexCreator);
+    registerValidator("usearch", usearchIndexValidator);
+#endif
+
     registerCreator("inverted", invertedIndexCreator);
     registerValidator("inverted", invertedIndexValidator);
 
diff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h
index 1ad6b0822235..40128bab9d05 100644
--- a/src/Storages/MergeTree/MergeTreeIndices.h
+++ b/src/Storages/MergeTree/MergeTreeIndices.h
@@ -238,6 +238,11 @@ MergeTreeIndexPtr annoyIndexCreator(const IndexDescription & index);
 void annoyIndexValidator(const IndexDescription & index, bool attach);
 #endif
 
+#ifdef ENABLE_USEARCH
+MergeTreeIndexPtr usearchIndexCreator(const IndexDescription& index);
+void usearchIndexValidator(const IndexDescription& index, bool attach);
+#endif
+
 MergeTreeIndexPtr invertedIndexCreator(const IndexDescription& index);
 void invertedIndexValidator(const IndexDescription& index, bool attach);
 
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 2e231120e418..02358580b161 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -315,6 +315,7 @@ Greenwald
 HDDs
 HHMM
 HMAC
+HNSW
 HSTS
 HTTPConnection
 HTTPThreads
@@ -697,6 +698,7 @@ Promtail
 Protobuf
 ProtobufSingle
 ProxySQL
+PyArrow
 PyCharm
 QEMU
 QTCreator
@@ -921,6 +923,7 @@ URL's
 URLHash
 URLHierarchy
 URLPathHierarchy
+USearch
 UUIDNumToString
 UUIDStringToNum
 UUIDs
@@ -1086,8 +1089,8 @@ authenticators
 autocompletion
 autodetect
 autodetected
-autogenerated
 autogenerate
+autogenerated
 autogeneration
 autostart
 avgWeighted
@@ -2000,7 +2003,6 @@ ptrs
 pushdown
 pwrite
 py
-PyArrow
 qryn
 quantile
 quantileBFloat
@@ -2499,6 +2501,7 @@ uring
 url
 urlCluster
 urls
+usearch
 userspace
 userver
 utils
