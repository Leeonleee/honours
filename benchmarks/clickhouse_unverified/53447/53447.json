{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53447,
  "instance_id": "ClickHouse__ClickHouse-53447",
  "issue_numbers": [
    "52552"
  ],
  "base_commit": "59ecbd8cb1bedce9303a153a11a61225a82b5725",
  "patch": "diff --git a/.gitmodules b/.gitmodules\nindex 86fd7832dd9f..c3592372b7eb 100644\n--- a/.gitmodules\n+++ b/.gitmodules\n@@ -347,3 +347,15 @@\n [submodule \"contrib/incbin\"]\n \tpath = contrib/incbin\n \turl = https://github.com/graphitemaster/incbin.git\n+[submodule \"contrib/usearch\"]\n+\tpath = contrib/usearch\n+\turl = https://github.com/unum-cloud/usearch.git\n+[submodule \"contrib/SimSIMD\"]\n+\tpath = contrib/SimSIMD\n+\turl = https://github.com/ashvardanian/SimSIMD.git\n+[submodule \"contrib/FP16\"]\n+\tpath = contrib/FP16\n+\turl = https://github.com/Maratyszcza/FP16.git\n+[submodule \"contrib/robin-map\"]\n+\tpath = contrib/robin-map\n+\turl = https://github.com/Tessil/robin-map.git\ndiff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt\nindex 16135351cce6..2557ebf78ae5 100644\n--- a/contrib/CMakeLists.txt\n+++ b/contrib/CMakeLists.txt\n@@ -196,6 +196,17 @@ if (ARCH_S390X)\n     add_contrib(crc32-s390x-cmake crc32-s390x)\n endif()\n add_contrib (annoy-cmake annoy)\n+\n+option(ENABLE_USEARCH \"Enable USearch (Approximate Neighborhood Search, HNSW) support\" ${ENABLE_LIBRARIES})\n+if (ENABLE_USEARCH)\n+    add_contrib (FP16-cmake FP16)\n+    add_contrib (robin-map-cmake robin-map)\n+    add_contrib (SimSIMD-cmake SimSIMD)\n+    add_contrib (usearch-cmake usearch) # requires: FP16, robin-map, SimdSIMD\n+else ()\n+    message(STATUS \"Not using USearch\")\n+endif ()\n+\n add_contrib (xxHash-cmake xxHash)\n \n add_contrib (libbcrypt-cmake libbcrypt)\ndiff --git a/contrib/FP16 b/contrib/FP16\nnew file mode 160000\nindex 000000000000..0a92994d729f\n--- /dev/null\n+++ b/contrib/FP16\n@@ -0,0 +1,1 @@\n+Subproject commit 0a92994d729ff76a58f692d3028ca1b64b145d91\ndiff --git a/contrib/FP16-cmake/CMakeLists.txt b/contrib/FP16-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..f82ad705dcc7\n--- /dev/null\n+++ b/contrib/FP16-cmake/CMakeLists.txt\n@@ -0,0 +1,1 @@\n+# See contrib/usearch-cmake/CMakeLists.txt\ndiff --git a/contrib/SimSIMD b/contrib/SimSIMD\nnew file mode 160000\nindex 000000000000..de2cb75b9e9e\n--- /dev/null\n+++ b/contrib/SimSIMD\n@@ -0,0 +1,1 @@\n+Subproject commit de2cb75b9e9e3389d5e1e51fd9f8ed151f3c17cf\ndiff --git a/contrib/SimSIMD-cmake/CMakeLists.txt b/contrib/SimSIMD-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..f82ad705dcc7\n--- /dev/null\n+++ b/contrib/SimSIMD-cmake/CMakeLists.txt\n@@ -0,0 +1,1 @@\n+# See contrib/usearch-cmake/CMakeLists.txt\ndiff --git a/contrib/robin-map b/contrib/robin-map\nnew file mode 160000\nindex 000000000000..851a59e0e306\n--- /dev/null\n+++ b/contrib/robin-map\n@@ -0,0 +1,1 @@\n+Subproject commit 851a59e0e3063ee0e23089062090a73fd3de482d\ndiff --git a/contrib/robin-map-cmake/CMakeLists.txt b/contrib/robin-map-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..f82ad705dcc7\n--- /dev/null\n+++ b/contrib/robin-map-cmake/CMakeLists.txt\n@@ -0,0 +1,1 @@\n+# See contrib/usearch-cmake/CMakeLists.txt\ndiff --git a/contrib/usearch b/contrib/usearch\nnew file mode 160000\nindex 000000000000..387b78b28b17\n--- /dev/null\n+++ b/contrib/usearch\n@@ -0,0 +1,1 @@\n+Subproject commit 387b78b28b17b8954024ffc81e97cbcfa10d1f30\ndiff --git a/contrib/usearch-cmake/CMakeLists.txt b/contrib/usearch-cmake/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..29fbe57106c7\n--- /dev/null\n+++ b/contrib/usearch-cmake/CMakeLists.txt\n@@ -0,0 +1,17 @@\n+set(USEARCH_PROJECT_DIR \"${ClickHouse_SOURCE_DIR}/contrib/usearch\")\n+set(USEARCH_SOURCE_DIR \"${USEARCH_PROJECT_DIR}/include\")\n+\n+set(FP16_PROJECT_DIR \"${ClickHouse_SOURCE_DIR}/contrib/FP16\")\n+set(ROBIN_MAP_PROJECT_DIR \"${ClickHouse_SOURCE_DIR}/contrib/robin-map\")\n+set(SIMSIMD_PROJECT_DIR \"${ClickHouse_SOURCE_DIR}/contrib/SimSIMD-map\")\n+\n+add_library(_usearch INTERFACE)\n+\n+target_include_directories(_usearch SYSTEM INTERFACE\n+    ${FP16_PROJECT_DIR}/include\n+    ${ROBIN_MAP_PROJECT_DIR}/include\n+    ${SIMSIMD_PROJECT_DIR}/include\n+    ${USEARCH_SOURCE_DIR})\n+\n+add_library(ch_contrib::usearch ALIAS _usearch)\n+target_compile_definitions(_usearch INTERFACE ENABLE_USEARCH)\ndiff --git a/docs/en/engines/table-engines/mergetree-family/annindexes.md b/docs/en/engines/table-engines/mergetree-family/annindexes.md\nindex 81c69215472a..ee91794b20ee 100644\n--- a/docs/en/engines/table-engines/mergetree-family/annindexes.md\n+++ b/docs/en/engines/table-engines/mergetree-family/annindexes.md\n@@ -142,13 +142,15 @@ was specified for ANN indexes, the default value is 100 million.\n \n - [Annoy](/docs/en/engines/table-engines/mergetree-family/annindexes.md#annoy-annoy)\n \n+- [USearch](/docs/en/engines/table-engines/mergetree-family/annindexes.md#usearch-usearch)\n+\n ## Annoy {#annoy}\n \n Annoy indexes are currently experimental, to use them you first need to `SET allow_experimental_annoy_index = 1`. They are also currently\n disabled on ARM due to memory safety problems with the algorithm.\n \n-This type of ANN index implements [the Annoy algorithm](https://github.com/spotify/annoy) which is based on a recursive division of the\n-space in random linear surfaces (lines in 2D, planes in 3D etc.).\n+This type of ANN index is based on the [Annoy library](https://github.com/spotify/annoy) which recursively divides the space into random\n+linear surfaces (lines in 2D, planes in 3D etc.).\n \n <div class='vimeo-container'>\n   <iframe src=\"//www.youtube.com/embed/QkCCyLW0ehU\"\n@@ -216,3 +218,60 @@ ORDER BY L2Distance(vectors, Point)\n LIMIT N\n SETTINGS annoy_index_search_k_nodes=100;\n ```\n+\n+## USearch {#usearch}\n+\n+This type of ANN index is based on the [the USearch library](https://github.com/unum-cloud/usearch), which implements the [HNSW\n+algorithm](https://arxiv.org/abs/1603.09320), i.e., builds a hierarchical graph where each point represents a vector and the edges represent\n+similarity. Such hierarchical structures can be very efficient on large collections. They may often fetch 0.05% or less data from the\n+overall dataset, while still providing 99% recall. This is especially useful when working with high-dimensional vectors,\n+that are expensive to load and compare. The library also has several hardware-specific SIMD optimizations to accelerate further\n+distance computations on modern Arm (NEON and SVE) and x86 (AVX2 and AVX-512) CPUs and OS-specific optimizations to allow efficient\n+navigation around immutable persistent files, without loading them into RAM.\n+\n+<div class='vimeo-container'>\n+  <iframe src=\"//www.youtube.com/embed/UMrhB3icP9w\"\n+    width=\"640\"\n+    height=\"360\"\n+    frameborder=\"0\"\n+    allow=\"autoplay;\n+    fullscreen;\n+    picture-in-picture\"\n+    allowfullscreen>\n+  </iframe>\n+</div>\n+\n+Syntax to create an USearch index over an [Array](../../../sql-reference/data-types/array.md) column:\n+\n+```sql\n+CREATE TABLE table_with_usearch_index\n+(\n+  id Int64,\n+  vectors Array(Float32),\n+  INDEX [ann_index_name] vectors TYPE usearch([Distance]) [GRANULARITY N]\n+)\n+ENGINE = MergeTree\n+ORDER BY id;\n+```\n+\n+Syntax to create an ANN index over a [Tuple](../../../sql-reference/data-types/tuple.md) column:\n+\n+```sql\n+CREATE TABLE table_with_usearch_index\n+(\n+  id Int64,\n+  vectors Tuple(Float32[, Float32[, ...]]),\n+  INDEX [ann_index_name] vectors TYPE usearch([Distance]) [GRANULARITY N]\n+)\n+ENGINE = MergeTree\n+ORDER BY id;\n+```\n+\n+USearch currently supports two distance functions:\n+- `L2Distance`, also called Euclidean distance, is the length of a line segment between two points in Euclidean space\n+  ([Wikipedia](https://en.wikipedia.org/wiki/Euclidean_distance)).\n+- `cosineDistance`, also called cosine similarity, is the cosine of the angle between two (non-zero) vectors\n+  ([Wikipedia](https://en.wikipedia.org/wiki/Cosine_similarity)).\n+\n+For normalized data, `L2Distance` is usually a better choice, otherwise `cosineDistance` is recommended to compensate for scale. If no\n+distance function was specified during index creation, `L2Distance` is used as default.\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex ddb6fcebd230..e4e9fd19cff4 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -599,6 +599,10 @@ if (TARGET ch_contrib::annoy)\n     dbms_target_link_libraries(PUBLIC ch_contrib::annoy)\n endif()\n \n+if (TARGET ch_contrib::usearch)\n+    dbms_target_link_libraries(PUBLIC ch_contrib::usearch)\n+endif()\n+\n if (TARGET ch_rust::skim)\n     dbms_target_include_directories(PRIVATE $<TARGET_PROPERTY:ch_rust::skim,INTERFACE_INCLUDE_DIRECTORIES>)\n     dbms_target_link_libraries(PUBLIC ch_rust::skim)\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 714ac17a15df..14714981c001 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -772,6 +772,7 @@ class IColumn;\n     M(Bool, allow_experimental_hash_functions, false, \"Enable experimental hash functions\", 0) \\\n     M(Bool, allow_experimental_object_type, false, \"Allow Object and JSON data types\", 0) \\\n     M(Bool, allow_experimental_annoy_index, false, \"Allows to use Annoy index. Disabled by default because this feature is experimental\", 0) \\\n+    M(Bool, allow_experimental_usearch_index, false, \"Allows to use USearch index. Disabled by default because this feature is experimental\", 0) \\\n     M(UInt64, max_limit_for_ann_queries, 1'000'000, \"SELECT queries with LIMIT bigger than this setting cannot use ANN indexes. Helps to prevent memory overflows in ANN search indexes.\", 0) \\\n     M(Int64, annoy_index_search_k_nodes, -1, \"SELECT queries search up to this many nodes in Annoy indexes.\", 0) \\\n     M(Bool, throw_on_unsupported_query_inside_transaction, true, \"Throw exception if unsupported query is used inside transaction\", 0) \\\ndiff --git a/src/Databases/DatabaseReplicated.cpp b/src/Databases/DatabaseReplicated.cpp\nindex 304c0a20e26f..acd3efc74bb3 100644\n--- a/src/Databases/DatabaseReplicated.cpp\n+++ b/src/Databases/DatabaseReplicated.cpp\n@@ -830,6 +830,7 @@ void DatabaseReplicated::recoverLostReplica(const ZooKeeperPtr & current_zookeep\n         query_context->setSetting(\"allow_experimental_hash_functions\", 1);\n         query_context->setSetting(\"allow_experimental_object_type\", 1);\n         query_context->setSetting(\"allow_experimental_annoy_index\", 1);\n+        query_context->setSetting(\"allow_experimental_usearch_index\", 1);\n         query_context->setSetting(\"allow_experimental_bigint_types\", 1);\n         query_context->setSetting(\"allow_experimental_window_functions\", 1);\n         query_context->setSetting(\"allow_experimental_geo_types\", 1);\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 571890123177..92d74f4f18a2 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -704,6 +704,9 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::getTableProperti\n                 if (index_desc.type == \"annoy\" && !settings.allow_experimental_annoy_index)\n                     throw Exception(ErrorCodes::INCORRECT_QUERY, \"Annoy index is disabled. Turn on allow_experimental_annoy_index\");\n \n+                if (index_desc.type == \"usearch\" && !settings.allow_experimental_usearch_index)\n+                    throw Exception(ErrorCodes::INCORRECT_QUERY, \"USearch index is disabled. Turn on allow_experimental_usearch_index\");\n+\n                 properties.indices.push_back(index_desc);\n             }\n         if (create.columns_list->projections)\ndiff --git a/src/Parsers/ASTIndexDeclaration.h b/src/Parsers/ASTIndexDeclaration.h\nindex 6ed241f75abf..1fbf5e126959 100644\n--- a/src/Parsers/ASTIndexDeclaration.h\n+++ b/src/Parsers/ASTIndexDeclaration.h\n@@ -14,6 +14,7 @@ class ASTIndexDeclaration : public IAST\n public:\n     static const auto DEFAULT_INDEX_GRANULARITY = 1uz;\n     static const auto DEFAULT_ANNOY_INDEX_GRANULARITY = 100'000'000uz;\n+    static const auto DEFAULT_USEARCH_INDEX_GRANULARITY = 100'000'000uz;\n \n     String name;\n     IAST * expr;\ndiff --git a/src/Parsers/ParserCreateIndexQuery.cpp b/src/Parsers/ParserCreateIndexQuery.cpp\nindex 67051d84999b..81954e3c2471 100644\n--- a/src/Parsers/ParserCreateIndexQuery.cpp\n+++ b/src/Parsers/ParserCreateIndexQuery.cpp\n@@ -66,6 +66,8 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected\n     {\n         if (index->type && index->type->name == \"annoy\")\n             index->granularity = ASTIndexDeclaration::DEFAULT_ANNOY_INDEX_GRANULARITY;\n+        else if (index->type && index->type->name == \"usearch\")\n+            index->granularity = ASTIndexDeclaration::DEFAULT_USEARCH_INDEX_GRANULARITY;\n         else\n             index->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;\n     }\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 82674ab1a353..e11c94d03092 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -148,6 +148,8 @@ bool ParserIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     {\n         if (index->type->name == \"annoy\")\n             index->granularity = ASTIndexDeclaration::DEFAULT_ANNOY_INDEX_GRANULARITY;\n+        else if (index->type->name == \"usearch\")\n+            index->granularity = ASTIndexDeclaration::DEFAULT_USEARCH_INDEX_GRANULARITY;\n         else\n             index->granularity = ASTIndexDeclaration::DEFAULT_INDEX_GRANULARITY;\n     }\ndiff --git a/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h b/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h\nindex 310890eba1ec..5092fbdd864f 100644\n--- a/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h\n+++ b/src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h\n@@ -9,6 +9,9 @@\n namespace DB\n {\n \n+static constexpr auto DISTANCE_FUNCTION_L2 = \"L2Distance\";\n+static constexpr auto DISTANCE_FUNCTION_COSINE = \"cosineDistance\";\n+\n /// Approximate Nearest Neighbour queries have a similar structure:\n /// - reference vector from which all distances are calculated\n /// - metric name (e.g L2Distance, LpDistance, etc.)\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp b/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp\nindex 1c92645dbfa4..13577229a752 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp\n@@ -25,12 +25,6 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n-static constexpr auto DISTANCE_FUNCTION_L2 = \"L2Distance\";\n-static constexpr auto DISTANCE_FUNCTION_COSINE = \"cosineDistance\";\n-\n-static constexpr auto DEFAULT_TREES = 100uz;\n-static constexpr auto DEFAULT_DISTANCE_FUNCTION = DISTANCE_FUNCTION_L2;\n-\n template <typename Distance>\n AnnoyIndexWithSerialization<Distance>::AnnoyIndexWithSerialization(size_t dimensions)\n     : Base::AnnoyIndex(dimensions)\n@@ -318,10 +312,12 @@ MergeTreeIndexConditionPtr MergeTreeIndexAnnoy::createIndexCondition(const Selec\n \n MergeTreeIndexPtr annoyIndexCreator(const IndexDescription & index)\n {\n+    static constexpr auto DEFAULT_DISTANCE_FUNCTION = DISTANCE_FUNCTION_L2;\n     String distance_function = DEFAULT_DISTANCE_FUNCTION;\n     if (!index.arguments.empty())\n         distance_function = index.arguments[0].get<String>();\n \n+    static constexpr auto DEFAULT_TREES = 100uz;\n     UInt64 trees = DEFAULT_TREES;\n     if (index.arguments.size() > 1)\n         trees = index.arguments[1].get<UInt64>();\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp b/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp\nnew file mode 100644\nindex 000000000000..d2433517766e\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp\n@@ -0,0 +1,377 @@\n+#ifdef ENABLE_USEARCH\n+\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wpass-failed\"\n+\n+#include <Storages/MergeTree/MergeTreeIndexUSearch.h>\n+\n+#include <Columns/ColumnArray.h>\n+#include <Common/typeid_cast.h>\n+#include <Core/Field.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/castColumn.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_ALLOCATE_MEMORY;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int INCORRECT_DATA;\n+    extern const int INCORRECT_NUMBER_OF_COLUMNS;\n+    extern const int INCORRECT_QUERY;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+USearchIndexWithSerialization<Metric>::USearchIndexWithSerialization(size_t dimensions)\n+    : Base(Base::make(unum::usearch::metric_punned_t(dimensions, Metric)))\n+{\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+void USearchIndexWithSerialization<Metric>::serialize([[maybe_unused]] WriteBuffer & ostr) const\n+{\n+    auto callback = [&ostr](void * from, size_t n)\n+    {\n+        ostr.write(reinterpret_cast<const char *>(from), n);\n+        return true;\n+    };\n+\n+    Base::stream(callback);\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+void USearchIndexWithSerialization<Metric>::deserialize([[maybe_unused]] ReadBuffer & istr)\n+{\n+    BufferBase::Position & pos = istr.position();\n+    unum::usearch::memory_mapped_file_t memory_map(pos, istr.buffer().size() - istr.count());\n+    Base::view(std::move(memory_map));\n+    pos += Base::stream_length();\n+\n+    auto copy = Base::copy();\n+    if (!copy)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Could not copy usearch index\");\n+    Base::swap(copy.index);\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+size_t USearchIndexWithSerialization<Metric>::getDimensions() const\n+{\n+    return Base::dimensions();\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+MergeTreeIndexGranuleUSearch<Metric>::MergeTreeIndexGranuleUSearch(\n+    const String & index_name_,\n+    const Block & index_sample_block_)\n+    : index_name(index_name_)\n+    , index_sample_block(index_sample_block_)\n+    , index(nullptr)\n+{\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+MergeTreeIndexGranuleUSearch<Metric>::MergeTreeIndexGranuleUSearch(\n+    const String & index_name_,\n+    const Block & index_sample_block_,\n+    USearchIndexWithSerializationPtr<Metric> index_)\n+    : index_name(index_name_)\n+    , index_sample_block(index_sample_block_)\n+    , index(std::move(index_))\n+{\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+void MergeTreeIndexGranuleUSearch<Metric>::serializeBinary(WriteBuffer & ostr) const\n+{\n+    /// Number of dimensions is required in the index constructor,\n+    /// so it must be written and read separately from the other part\n+    writeIntBinary(static_cast<UInt64>(index->getDimensions()), ostr); // write dimension\n+    index->serialize(ostr);\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+void MergeTreeIndexGranuleUSearch<Metric>::deserializeBinary(ReadBuffer & istr, MergeTreeIndexVersion /*version*/)\n+{\n+    UInt64 dimension;\n+    readIntBinary(dimension, istr);\n+    index = std::make_shared<USearchIndexWithSerialization<Metric>>(dimension);\n+    index->deserialize(istr);\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+MergeTreeIndexAggregatorUSearch<Metric>::MergeTreeIndexAggregatorUSearch(\n+    const String & index_name_,\n+    const Block & index_sample_block_)\n+    : index_name(index_name_)\n+    , index_sample_block(index_sample_block_)\n+{\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+MergeTreeIndexGranulePtr MergeTreeIndexAggregatorUSearch<Metric>::getGranuleAndReset()\n+{\n+    auto granule = std::make_shared<MergeTreeIndexGranuleUSearch<Metric>>(index_name, index_sample_block, index);\n+    index = nullptr;\n+    return granule;\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+void MergeTreeIndexAggregatorUSearch<Metric>::update(const Block & block, size_t * pos, size_t limit)\n+{\n+    if (*pos >= block.rows())\n+        throw Exception(\n+            ErrorCodes::LOGICAL_ERROR,\n+            \"The provided position is not less than the number of block rows. Position: {}, Block rows: {}.\",\n+            *pos,\n+            block.rows());\n+\n+    size_t rows_read = std::min(limit, block.rows() - *pos);\n+    if (rows_read == 0)\n+        return;\n+\n+    if (index_sample_block.columns() > 1)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected block with single column\");\n+\n+    const String & index_column_name = index_sample_block.getByPosition(0).name;\n+    ColumnPtr column_cut = block.getByName(index_column_name).column->cut(*pos, rows_read);\n+\n+    if (const auto & column_array = typeid_cast<const ColumnArray *>(column_cut.get()))\n+    {\n+        const auto & data = column_array->getData();\n+        const auto & array = typeid_cast<const ColumnFloat32 &>(data).getData();\n+\n+        if (array.empty())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Array has 0 rows, {} rows expected\", rows_read);\n+\n+        const auto & offsets = column_array->getOffsets();\n+        const size_t num_rows = offsets.size();\n+\n+\n+        /// Check all sizes are the same\n+        size_t size = offsets[0];\n+        for (size_t i = 0; i < num_rows - 1; ++i)\n+            if (offsets[i + 1] - offsets[i] != size)\n+                throw Exception(ErrorCodes::INCORRECT_DATA, \"All arrays in column {} must have equal length\", index_column_name);\n+\n+\n+        index = std::make_shared<USearchIndexWithSerialization<Metric>>(size);\n+\n+        /// Add all rows of block\n+        if (!index->reserve(unum::usearch::ceil2(index->size() + num_rows)))\n+            throw Exception(ErrorCodes::CANNOT_ALLOCATE_MEMORY, \"Could not reserve memory for usearch index\");\n+\n+        if (auto rc = index->add(index->size(), array.data()); !rc)\n+            throw Exception(ErrorCodes::INCORRECT_DATA, rc.error.release());\n+        for (size_t current_row = 1; current_row < num_rows; ++current_row)\n+            if (auto rc = index->add(index->size(), &array[offsets[current_row - 1]]); !rc)\n+                throw Exception(ErrorCodes::INCORRECT_DATA, rc.error.release());\n+\n+    }\n+    else if (const auto & column_tuple = typeid_cast<const ColumnTuple *>(column_cut.get()))\n+    {\n+        const auto & columns = column_tuple->getColumns();\n+        std::vector<std::vector<Float32>> data{column_tuple->size(), std::vector<Float32>()};\n+        for (const auto & column : columns)\n+        {\n+            const auto & pod_array = typeid_cast<const ColumnFloat32 *>(column.get())->getData();\n+            for (size_t i = 0; i < pod_array.size(); ++i)\n+                data[i].push_back(pod_array[i]);\n+        }\n+\n+        if (data.empty())\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Tuple has 0 rows, {} rows expected\", rows_read);\n+\n+        index = std::make_shared<USearchIndexWithSerialization<Metric>>(data[0].size());\n+\n+        if (!index->reserve(unum::usearch::ceil2(index->size() + data.size())))\n+            throw Exception(ErrorCodes::CANNOT_ALLOCATE_MEMORY, \"Could not reserve memory for usearch index\");\n+\n+        for (const auto & item : data)\n+            if (auto rc = index->add(index->size(), item.data()); !rc)\n+                throw Exception(ErrorCodes::INCORRECT_DATA, rc.error.release());\n+    }\n+    else\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected Array or Tuple column\");\n+\n+    *pos += rows_read;\n+}\n+\n+MergeTreeIndexConditionUSearch::MergeTreeIndexConditionUSearch(\n+    const IndexDescription & /*index_description*/,\n+    const SelectQueryInfo & query,\n+    const String & distance_function_,\n+    ContextPtr context)\n+    : ann_condition(query, context)\n+    , distance_function(distance_function_)\n+{\n+}\n+\n+bool MergeTreeIndexConditionUSearch::mayBeTrueOnGranule(MergeTreeIndexGranulePtr /*idx_granule*/) const\n+{\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"mayBeTrueOnGranule is not supported for ANN skip indexes\");\n+}\n+\n+bool MergeTreeIndexConditionUSearch::alwaysUnknownOrTrue() const\n+{\n+    return ann_condition.alwaysUnknownOrTrue(distance_function);\n+}\n+\n+std::vector<size_t> MergeTreeIndexConditionUSearch::getUsefulRanges(MergeTreeIndexGranulePtr idx_granule) const\n+{\n+    if (distance_function == DISTANCE_FUNCTION_L2)\n+        return getUsefulRangesImpl<unum::usearch::metric_kind_t::l2sq_k>(idx_granule);\n+    else if (distance_function == DISTANCE_FUNCTION_COSINE)\n+        return getUsefulRangesImpl<unum::usearch::metric_kind_t::cos_k>(idx_granule);\n+    std::unreachable();\n+}\n+\n+template <unum::usearch::metric_kind_t Metric>\n+std::vector<size_t> MergeTreeIndexConditionUSearch::getUsefulRangesImpl(MergeTreeIndexGranulePtr idx_granule) const\n+{\n+    const UInt64 limit = ann_condition.getLimit();\n+    const UInt64 index_granularity = ann_condition.getIndexGranularity();\n+    const std::optional<float> comparison_distance = ann_condition.getQueryType() == ApproximateNearestNeighborInformation::Type::Where\n+        ? std::optional<float>(ann_condition.getComparisonDistanceForWhereQuery())\n+        : std::nullopt;\n+\n+    if (comparison_distance && comparison_distance.value() < 0)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Attempt to optimize query with where without distance\");\n+\n+    const std::vector<float> reference_vector = ann_condition.getReferenceVector();\n+    const auto granule = std::dynamic_pointer_cast<MergeTreeIndexGranuleUSearch<Metric>>(idx_granule);\n+    if (granule == nullptr)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Granule has the wrong type\");\n+\n+    const USearchIndexWithSerializationPtr<Metric> index = granule->index;\n+    if (ann_condition.getDimensions() != index->dimensions())\n+        throw Exception(\n+            ErrorCodes::INCORRECT_QUERY,\n+            \"The dimension of the space in the request ({}) \"\n+            \"does not match the dimension in the index ({})\",\n+            ann_condition.getDimensions(),\n+            index->dimensions());\n+\n+    auto result = index->search(reference_vector.data(), limit);\n+    std::vector<UInt64> neighbors(result.size()); /// indexes of dots which were closest to the reference vector\n+    std::vector<Float32> distances(result.size());\n+    result.dump_to(neighbors.data(), distances.data());\n+\n+    std::vector<size_t> granule_numbers;\n+    granule_numbers.reserve(neighbors.size());\n+    for (size_t i = 0; i < neighbors.size(); ++i)\n+    {\n+        if (comparison_distance && distances[i] > comparison_distance)\n+            continue;\n+        granule_numbers.push_back(neighbors[i] / index_granularity);\n+    }\n+\n+    /// make unique\n+    std::sort(granule_numbers.begin(), granule_numbers.end());\n+    granule_numbers.erase(std::unique(granule_numbers.begin(), granule_numbers.end()), granule_numbers.end());\n+\n+    return granule_numbers;\n+}\n+\n+MergeTreeIndexUSearch::MergeTreeIndexUSearch(const IndexDescription & index_, const String & distance_function_)\n+    : IMergeTreeIndex(index_)\n+    , distance_function(distance_function_)\n+{\n+}\n+\n+MergeTreeIndexGranulePtr MergeTreeIndexUSearch::createIndexGranule() const\n+{\n+    if (distance_function == DISTANCE_FUNCTION_L2)\n+        return std::make_shared<MergeTreeIndexGranuleUSearch<unum::usearch::metric_kind_t::l2sq_k>>(index.name, index.sample_block);\n+    else if (distance_function == DISTANCE_FUNCTION_COSINE)\n+        return std::make_shared<MergeTreeIndexGranuleUSearch<unum::usearch::metric_kind_t::cos_k>>(index.name, index.sample_block);\n+    std::unreachable();\n+}\n+\n+MergeTreeIndexAggregatorPtr MergeTreeIndexUSearch::createIndexAggregator() const\n+{\n+    if (distance_function == DISTANCE_FUNCTION_L2)\n+        return std::make_shared<MergeTreeIndexAggregatorUSearch<unum::usearch::metric_kind_t::l2sq_k>>(index.name, index.sample_block);\n+    else if (distance_function == DISTANCE_FUNCTION_COSINE)\n+        return std::make_shared<MergeTreeIndexAggregatorUSearch<unum::usearch::metric_kind_t::cos_k>>(index.name, index.sample_block);\n+    std::unreachable();\n+}\n+\n+MergeTreeIndexConditionPtr MergeTreeIndexUSearch::createIndexCondition(const SelectQueryInfo & query, ContextPtr context) const\n+{\n+    return std::make_shared<MergeTreeIndexConditionUSearch>(index, query, distance_function, context);\n+};\n+\n+MergeTreeIndexPtr usearchIndexCreator(const IndexDescription & index)\n+{\n+    static constexpr auto default_distance_function = DISTANCE_FUNCTION_L2;\n+    String distance_function = default_distance_function;\n+    if (!index.arguments.empty())\n+        distance_function = index.arguments[0].get<String>();\n+\n+    return std::make_shared<MergeTreeIndexUSearch>(index, distance_function);\n+}\n+\n+void usearchIndexValidator(const IndexDescription & index, bool /* attach */)\n+{\n+    /// Check number and type of USearch index arguments:\n+\n+    if (index.arguments.size() > 1)\n+        throw Exception(ErrorCodes::INCORRECT_QUERY, \"USearch index must not have more than one parameters\");\n+\n+    if (!index.arguments.empty() && index.arguments[0].getType() != Field::Types::String)\n+        throw Exception(ErrorCodes::INCORRECT_QUERY, \"Distance function argument of USearch index must be of type String\");\n+\n+    /// Check that the index is created on a single column\n+\n+    if (index.column_names.size() != 1 || index.data_types.size() != 1)\n+        throw Exception(ErrorCodes::INCORRECT_NUMBER_OF_COLUMNS, \"USearch indexes must be created on a single column\");\n+\n+    /// Check that a supported metric was passed as first argument\n+\n+    if (!index.arguments.empty())\n+    {\n+        String distance_name = index.arguments[0].get<String>();\n+        if (distance_name != DISTANCE_FUNCTION_L2 && distance_name != DISTANCE_FUNCTION_COSINE)\n+            throw Exception(ErrorCodes::INCORRECT_DATA, \"USearch index only supports distance functions '{}' and '{}'\", DISTANCE_FUNCTION_L2, DISTANCE_FUNCTION_COSINE);\n+    }\n+\n+    /// Check data type of indexed column:\n+\n+    auto throw_unsupported_underlying_column_exception = []()\n+    {\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_COLUMN, \"USearch indexes can only be created on columns of type Array(Float32) and Tuple(Float32)\");\n+    };\n+\n+    DataTypePtr data_type = index.sample_block.getDataTypes()[0];\n+\n+    if (const auto * data_type_array = typeid_cast<const DataTypeArray *>(data_type.get()))\n+    {\n+        TypeIndex nested_type_index = data_type_array->getNestedType()->getTypeId();\n+        if (!WhichDataType(nested_type_index).isFloat32())\n+            throw_unsupported_underlying_column_exception();\n+    }\n+    else if (const auto * data_type_tuple = typeid_cast<const DataTypeTuple *>(data_type.get()))\n+    {\n+        const DataTypes & inner_types = data_type_tuple->getElements();\n+        for (const auto & inner_type : inner_types)\n+        {\n+            TypeIndex nested_type_index = inner_type->getTypeId();\n+            if (!WhichDataType(nested_type_index).isFloat32())\n+                throw_unsupported_underlying_column_exception();\n+        }\n+    }\n+    else\n+        throw_unsupported_underlying_column_exception();\n+}\n+\n+}\n+\n+#endif\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexUSearch.h b/src/Storages/MergeTree/MergeTreeIndexUSearch.h\nnew file mode 100644\nindex 000000000000..f1fde934fd5c\n--- /dev/null\n+++ b/src/Storages/MergeTree/MergeTreeIndexUSearch.h\n@@ -0,0 +1,106 @@\n+#pragma once\n+\n+#ifdef ENABLE_USEARCH\n+\n+#include <Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h>\n+\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wpass-failed\"\n+#include <usearch/index_dense.hpp>\n+#pragma clang diagnostic pop\n+\n+namespace DB\n+{\n+\n+template <unum::usearch::metric_kind_t Metric>\n+class USearchIndexWithSerialization : public unum::usearch::index_dense_t\n+{\n+    using Base = unum::usearch::index_dense_t;\n+\n+public:\n+    explicit USearchIndexWithSerialization(size_t dimensions);\n+    void serialize(WriteBuffer & ostr) const;\n+    void deserialize(ReadBuffer & istr);\n+    size_t getDimensions() const;\n+};\n+\n+template <unum::usearch::metric_kind_t Metric>\n+using USearchIndexWithSerializationPtr = std::shared_ptr<USearchIndexWithSerialization<Metric>>;\n+\n+template <unum::usearch::metric_kind_t Metric>\n+struct MergeTreeIndexGranuleUSearch final : public IMergeTreeIndexGranule\n+{\n+    MergeTreeIndexGranuleUSearch(const String & index_name_, const Block & index_sample_block_);\n+    MergeTreeIndexGranuleUSearch(const String & index_name_, const Block & index_sample_block_, USearchIndexWithSerializationPtr<Metric> index_);\n+\n+    ~MergeTreeIndexGranuleUSearch() override = default;\n+\n+    void serializeBinary(WriteBuffer & ostr) const override;\n+    void deserializeBinary(ReadBuffer & istr, MergeTreeIndexVersion version) override;\n+\n+    bool empty() const override { return !index.get(); }\n+\n+    const String index_name;\n+    const Block index_sample_block;\n+    USearchIndexWithSerializationPtr<Metric> index;\n+};\n+\n+template <unum::usearch::metric_kind_t Metric>\n+struct MergeTreeIndexAggregatorUSearch final : IMergeTreeIndexAggregator\n+{\n+    MergeTreeIndexAggregatorUSearch(const String & index_name_, const Block & index_sample_block);\n+    ~MergeTreeIndexAggregatorUSearch() override = default;\n+\n+    bool empty() const override { return !index || index->size() == 0; }\n+    MergeTreeIndexGranulePtr getGranuleAndReset() override;\n+    void update(const Block & block, size_t * pos, size_t limit) override;\n+\n+    const String index_name;\n+    const Block index_sample_block;\n+    USearchIndexWithSerializationPtr<Metric> index;\n+};\n+\n+\n+class MergeTreeIndexConditionUSearch final : public IMergeTreeIndexConditionApproximateNearestNeighbor\n+{\n+public:\n+    MergeTreeIndexConditionUSearch(const IndexDescription & index_description, const SelectQueryInfo & query, const String & distance_function, ContextPtr context);\n+\n+    ~MergeTreeIndexConditionUSearch() override = default;\n+\n+    bool alwaysUnknownOrTrue() const override;\n+    bool mayBeTrueOnGranule(MergeTreeIndexGranulePtr idx_granule) const override;\n+    std::vector<size_t> getUsefulRanges(MergeTreeIndexGranulePtr idx_granule) const override;\n+\n+private:\n+    template <unum::usearch::metric_kind_t Metric>\n+    std::vector<size_t> getUsefulRangesImpl(MergeTreeIndexGranulePtr idx_granule) const;\n+\n+    const ApproximateNearestNeighborCondition ann_condition;\n+    const String distance_function;\n+};\n+\n+\n+class MergeTreeIndexUSearch : public IMergeTreeIndex\n+{\n+public:\n+    MergeTreeIndexUSearch(const IndexDescription & index_, const String & distance_function_);\n+\n+    ~MergeTreeIndexUSearch() override = default;\n+\n+    MergeTreeIndexGranulePtr createIndexGranule() const override;\n+    MergeTreeIndexAggregatorPtr createIndexAggregator() const override;\n+    MergeTreeIndexConditionPtr createIndexCondition(const SelectQueryInfo & query, ContextPtr context) const override;\n+\n+    bool mayBenefitFromIndexForIn(const ASTPtr & /*node*/) const override { return false; }\n+\n+private:\n+    const String distance_function;\n+};\n+\n+\n+}\n+\n+\n+#endif\n+\ndiff --git a/src/Storages/MergeTree/MergeTreeIndices.cpp b/src/Storages/MergeTree/MergeTreeIndices.cpp\nindex 6ae96d001711..322cdd35afe2 100644\n--- a/src/Storages/MergeTree/MergeTreeIndices.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndices.cpp\n@@ -132,6 +132,11 @@ MergeTreeIndexFactory::MergeTreeIndexFactory()\n     registerValidator(\"annoy\", annoyIndexValidator);\n #endif\n \n+#ifdef ENABLE_USEARCH\n+    registerCreator(\"usearch\", usearchIndexCreator);\n+    registerValidator(\"usearch\", usearchIndexValidator);\n+#endif\n+\n     registerCreator(\"inverted\", invertedIndexCreator);\n     registerValidator(\"inverted\", invertedIndexValidator);\n \ndiff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h\nindex 1ad6b0822235..40128bab9d05 100644\n--- a/src/Storages/MergeTree/MergeTreeIndices.h\n+++ b/src/Storages/MergeTree/MergeTreeIndices.h\n@@ -238,6 +238,11 @@ MergeTreeIndexPtr annoyIndexCreator(const IndexDescription & index);\n void annoyIndexValidator(const IndexDescription & index, bool attach);\n #endif\n \n+#ifdef ENABLE_USEARCH\n+MergeTreeIndexPtr usearchIndexCreator(const IndexDescription& index);\n+void usearchIndexValidator(const IndexDescription& index, bool attach);\n+#endif\n+\n MergeTreeIndexPtr invertedIndexCreator(const IndexDescription& index);\n void invertedIndexValidator(const IndexDescription& index, bool attach);\n \ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 2e231120e418..02358580b161 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -315,6 +315,7 @@ Greenwald\n HDDs\n HHMM\n HMAC\n+HNSW\n HSTS\n HTTPConnection\n HTTPThreads\n@@ -697,6 +698,7 @@ Promtail\n Protobuf\n ProtobufSingle\n ProxySQL\n+PyArrow\n PyCharm\n QEMU\n QTCreator\n@@ -921,6 +923,7 @@ URL's\n URLHash\n URLHierarchy\n URLPathHierarchy\n+USearch\n UUIDNumToString\n UUIDStringToNum\n UUIDs\n@@ -1086,8 +1089,8 @@ authenticators\n autocompletion\n autodetect\n autodetected\n-autogenerated\n autogenerate\n+autogenerated\n autogeneration\n autostart\n avgWeighted\n@@ -2000,7 +2003,6 @@ ptrs\n pushdown\n pwrite\n py\n-PyArrow\n qryn\n quantile\n quantileBFloat\n@@ -2499,6 +2501,7 @@ uring\n url\n urlCluster\n urls\n+usearch\n userspace\n userver\n utils\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02354_usearch_index.reference b/tests/queries/0_stateless/02354_usearch_index.reference\nnew file mode 100644\nindex 000000000000..9896f149d453\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_usearch_index.reference\n@@ -0,0 +1,143 @@\n+--- Negative tests ---\n+--- Test default GRANULARITY (should be 100 mio. for usearch)---\n+CREATE TABLE default.tab\\n(\\n    `id` Int32,\\n    `vector` Array(Float32),\\n    INDEX usearch_index vector TYPE usearch GRANULARITY 100000000\\n)\\nENGINE = MergeTree\\nORDER BY id\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.tab\\n(\\n    `id` Int32,\\n    `vector` Array(Float32),\\n    INDEX usearch_index vector TYPE usearch GRANULARITY 100000000\\n)\\nENGINE = MergeTree\\nORDER BY id\\nSETTINGS index_granularity = 8192\n+--- Test with Array, GRANULARITY = 1, index_granularity = 5 ---\n+WHERE type, L2Distance, check that index is used\n+Expression ((Projection + Before ORDER BY))\n+  Limit (preliminary LIMIT (without OFFSET))\n+    ReadFromMergeTree (default.tab)\n+    Indexes:\n+      PrimaryKey\n+        Condition: true\n+        Parts: 1/1\n+        Granules: 3/3\n+      Skip\n+        Name: usearch_index\n+        Description: usearch GRANULARITY 1\n+        Parts: 1/1\n+        Granules: 1/3\n+ORDER BY type, L2Distance, check that index is used\n+Expression (Projection)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression (Before ORDER BY)\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 3/3\n+          Skip\n+            Name: usearch_index\n+            Description: usearch GRANULARITY 1\n+            Parts: 1/1\n+            Granules: 3/3\n+Reference ARRAYs with non-matching dimension are rejected\n+Special case: MaximumDistance is negative\n+WHERE type, L2Distance\n+Special case: setting max_limit_for_ann_queries\n+Expression (Projection)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression (Before ORDER BY)\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 3/3\n+--- Test with Tuple, GRANULARITY = 1, index_granularity = 5 ---\n+WHERE type, L2Distance, check that index is used\n+Expression ((Projection + Before ORDER BY))\n+  Limit (preliminary LIMIT (without OFFSET))\n+    ReadFromMergeTree (default.tab)\n+    Indexes:\n+      PrimaryKey\n+        Condition: true\n+        Parts: 1/1\n+        Granules: 3/3\n+      Skip\n+        Name: usearch_index\n+        Description: usearch GRANULARITY 1\n+        Parts: 1/1\n+        Granules: 1/3\n+ORDER BY type, L2Distance, check that index is used\n+Expression (Projection)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression (Before ORDER BY)\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 3/3\n+          Skip\n+            Name: usearch_index\n+            Description: usearch GRANULARITY 1\n+            Parts: 1/1\n+            Granules: 3/3\n+--- Test non-default metric (cosine distance) ---\n+--- Test with Array, GRANULARITY = 2, index_granularity = 4 ---\n+WHERE type, L2Distance, check that index is used\n+Expression ((Projection + Before ORDER BY))\n+  Limit (preliminary LIMIT (without OFFSET))\n+    ReadFromMergeTree (default.tab)\n+    Indexes:\n+      PrimaryKey\n+        Condition: true\n+        Parts: 1/1\n+        Granules: 4/4\n+      Skip\n+        Name: usearch_index\n+        Description: usearch GRANULARITY 2\n+        Parts: 0/1\n+        Granules: 2/4\n+ORDER BY type, L2Distance, check that index is used\n+Expression (Projection)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression (Before ORDER BY)\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 4/4\n+          Skip\n+            Name: usearch_index\n+            Description: usearch GRANULARITY 2\n+            Parts: 1/1\n+            Granules: 4/4\n+--- Test with Array, GRANULARITY = 4, index_granularity = 4 ---\n+WHERE type, L2Distance, check that index is used\n+Expression ((Projection + Before ORDER BY))\n+  Limit (preliminary LIMIT (without OFFSET))\n+    ReadFromMergeTree (default.tab)\n+    Indexes:\n+      PrimaryKey\n+        Condition: true\n+        Parts: 1/1\n+        Granules: 4/4\n+      Skip\n+        Name: usearch_index\n+        Description: usearch GRANULARITY 4\n+        Parts: 0/1\n+        Granules: 3/4\n+ORDER BY type, L2Distance, check that index is used\n+Expression (Projection)\n+  Limit (preliminary LIMIT (without OFFSET))\n+    Sorting (Sorting for ORDER BY)\n+      Expression (Before ORDER BY)\n+        ReadFromMergeTree (default.tab)\n+        Indexes:\n+          PrimaryKey\n+            Condition: true\n+            Parts: 1/1\n+            Granules: 4/4\n+          Skip\n+            Name: usearch_index\n+            Description: usearch GRANULARITY 4\n+            Parts: 1/1\n+            Granules: 4/4\ndiff --git a/tests/queries/0_stateless/02354_usearch_index.sql b/tests/queries/0_stateless/02354_usearch_index.sql\nnew file mode 100644\nindex 000000000000..f21767ea6def\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_usearch_index.sql\n@@ -0,0 +1,230 @@\n+-- Tags: no-fasttest\n+-- no-fasttest because needs usearch lib\n+\n+SET allow_experimental_usearch_index = 1;\n+SET allow_experimental_analyzer = 0;\n+\n+SELECT '--- Negative tests ---';\n+\n+DROP TABLE IF EXISTS tab;\n+\n+-- must have at most 1 arguments\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch('too', 'many')) ENGINE = MergeTree ORDER BY id; -- { serverError INCORRECT_QUERY }\n+\n+-- first argument (distance_function) must be String\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch(3)) ENGINE = MergeTree ORDER BY id; -- { serverError INCORRECT_QUERY }\n+\n+-- must be created on single column\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index (vector, id) TYPE usearch()) ENGINE = MergeTree ORDER BY id; -- { serverError INCORRECT_NUMBER_OF_COLUMNS }\n+\n+-- reject unsupported distance functions\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch('wormholeDistance')) ENGINE = MergeTree ORDER BY id; -- { serverError INCORRECT_DATA }\n+\n+-- must be created on Array/Tuple(Float32) columns\n+SET allow_suspicious_low_cardinality_types = 1;\n+CREATE TABLE tab(id Int32, vector Float32, INDEX usearch_index vector TYPE usearch()) ENGINE = MergeTree ORDER BY id; -- { serverError ILLEGAL_COLUMN }\n+CREATE TABLE tab(id Int32, vector Array(Float64), INDEX usearch_index vector TYPE usearch()) ENGINE = MergeTree ORDER BY id; -- { serverError ILLEGAL_COLUMN }\n+CREATE TABLE tab(id Int32, vector Tuple(Float64), INDEX usearch_index vector TYPE usearch()) ENGINE = MergeTree ORDER BY id; -- { serverError ILLEGAL_COLUMN }\n+CREATE TABLE tab(id Int32, vector LowCardinality(Float32), INDEX usearch_index vector TYPE usearch()) ENGINE = MergeTree ORDER BY id; -- { serverError ILLEGAL_COLUMN }\n+CREATE TABLE tab(id Int32, vector Nullable(Float32), INDEX usearch_index vector TYPE usearch()) ENGINE = MergeTree ORDER BY id; -- { serverError ILLEGAL_COLUMN }\n+\n+SELECT '--- Test default GRANULARITY (should be 100 mio. for usearch)---';\n+\n+CREATE TABLE tab (id Int32, vector Array(Float32), INDEX usearch_index(vector) TYPE usearch) ENGINE=MergeTree ORDER BY id;\n+SHOW CREATE TABLE tab;\n+DROP TABLE tab;\n+\n+CREATE TABLE tab (id Int32, vector Array(Float32)) ENGINE=MergeTree ORDER BY id;\n+ALTER TABLE tab ADD INDEX usearch_index(vector) TYPE usearch;\n+SHOW CREATE TABLE tab;\n+\n+DROP TABLE tab;\n+\n+\n+SELECT '--- Test with Array, GRANULARITY = 1, index_granularity = 5 ---';\n+\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch() GRANULARITY 1) ENGINE = MergeTree ORDER BY id SETTINGS index_granularity = 5;\n+INSERT INTO tab VALUES (1, [0.0, 0.0, 10.0]), (2, [0.0, 0.0, 10.5]), (3, [0.0, 0.0, 9.5]), (4, [0.0, 0.0, 9.7]), (5, [0.0, 0.0, 10.2]), (6, [10.0, 0.0, 0.0]), (7, [9.5, 0.0, 0.0]), (8, [9.7, 0.0, 0.0]), (9, [10.2, 0.0, 0.0]), (10, [10.5, 0.0, 0.0]), (11, [0.0, 10.0, 0.0]), (12, [0.0, 9.5, 0.0]), (13, [0.0, 9.7, 0.0]), (14, [0.0, 10.2, 0.0]), (15, [0.0, 10.5, 0.0]);\n+\n+-- rows = 15, index_granularity = 5, GRANULARITY = 1 gives 3 usearch-indexed blocks (each comprising a single granule)\n+-- condition 'L2Distance(vector, reference_vector) < 1.0' ensures that only one usearch-indexed block produces results --> \"Granules: 1/3\"\n+\n+-- SELECT 'WHERE type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- WHERE L2Distance(vector, [0.0, 0.0, 10.0]) < 1.0\n+-- LIMIT 3;\n+\n+SELECT 'WHERE type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+WHERE L2Distance(vector, [0.0, 0.0, 10.0]) < 1.0\n+LIMIT 3;\n+\n+-- SELECT 'ORDER BY type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- ORDER BY L2Distance(vector, [0.0, 0.0, 10.0])\n+-- LIMIT 3;\n+\n+SELECT 'ORDER BY type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+ORDER BY L2Distance(vector, [0.0, 0.0, 10.0])\n+LIMIT 3;\n+\n+-- Test special cases. Corresponding special case tests are omitted from later tests.\n+\n+SELECT 'Reference ARRAYs with non-matching dimension are rejected';\n+SELECT *\n+FROM tab\n+ORDER BY L2Distance(vector, [0.0, 0.0])\n+LIMIT 3; -- { serverError INCORRECT_QUERY }\n+\n+SELECT 'Special case: MaximumDistance is negative';\n+SELECT 'WHERE type, L2Distance';\n+SELECT *\n+FROM tab\n+WHERE L2Distance(vector, [0.0, 0.0, 10.0]) < -1.0\n+LIMIT 3; -- { serverError INCORRECT_QUERY }\n+\n+SELECT 'Special case: setting max_limit_for_ann_queries';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+ORDER BY L2Distance(vector, [5.3, 7.3, 2.1])\n+LIMIT 3\n+SETTINGS max_limit_for_ann_queries=2; -- doesn't use the ann index\n+\n+DROP TABLE tab;\n+\n+-- Test Tuple embeddings. Triggers different logic than Array inside MergeTreeIndexUSearch but the same logic as Array above MergeTreeIndexusearch.\n+-- Therefore test Tuple case just once.\n+\n+SELECT '--- Test with Tuple, GRANULARITY = 1, index_granularity = 5 ---';\n+\n+CREATE TABLE tab(id Int32, vector Tuple(Float32, Float32, Float32), INDEX usearch_index vector TYPE usearch() GRANULARITY 1) ENGINE = MergeTree ORDER BY id SETTINGS index_granularity = 5;\n+INSERT INTO tab VALUES (1, (0.0, 0.0, 10.0)), (2, (0.0, 0.0, 10.5)), (3, (0.0, 0.0, 9.5)), (4, (0.0, 0.0, 9.7)), (5, (0.0, 0.0, 10.2)), (6, (10.0, 0.0, 0.0)), (7, (9.5, 0.0, 0.0)), (8, (9.7, 0.0, 0.0)), (9, (10.2, 0.0, 0.0)), (10, (10.5, 0.0, 0.0)), (11, (0.0, 10.0, 0.0)), (12, (0.0, 9.5, 0.0)), (13, (0.0, 9.7, 0.0)), (14, (0.0, 10.2, 0.0)), (15, (0.0, 10.5, 0.0));\n+\n+-- SELECT 'WHERE type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- WHERE L2Distance(vector, (0.0, 0.0, 10.0)) < 1.0\n+-- LIMIT 3;\n+\n+SELECT 'WHERE type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+WHERE L2Distance(vector, (0.0, 0.0, 10.0)) < 1.0\n+LIMIT 3;\n+\n+-- SELECT 'ORDER BY type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- ORDER BY L2Distance(vector, (0.0, 0.0, 10.0))\n+-- LIMIT 3;\n+\n+SELECT 'ORDER BY type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+ORDER BY L2Distance(vector, (0.0, 0.0, 10.0))\n+LIMIT 3;\n+\n+DROP TABLE tab;\n+\n+-- Not a systematic test, just to make sure no bad things happen\n+SELECT '--- Test non-default metric (cosine distance) ---';\n+\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch('cosineDistance') GRANULARITY 1) ENGINE = MergeTree ORDER BY id SETTINGS index_granularity = 5;\n+INSERT INTO tab VALUES (1, [0.0, 0.0, 10.0]), (2, [0.0, 0.0, 10.5]), (3, [0.0, 0.0, 9.5]), (4, [0.0, 0.0, 9.7]), (5, [0.0, 0.0, 10.2]), (6, [10.0, 0.0, 0.0]), (7, [9.5, 0.0, 0.0]), (8, [9.7, 0.0, 0.0]), (9, [10.2, 0.0, 0.0]), (10, [10.5, 0.0, 0.0]), (11, [0.0, 10.0, 0.0]), (12, [0.0, 9.5, 0.0]), (13, [0.0, 9.7, 0.0]), (14, [0.0, 10.2, 0.0]), (15, [0.0, 10.5, 0.0]);\n+\n+-- SELECT 'WHERE type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- WHERE L2Distance(vector, [0.0, 0.0, 10.0]) < 1.0\n+-- LIMIT 3;\n+\n+-- SELECT 'ORDER BY type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- ORDER BY L2Distance(vector, [0.0, 0.0, 10.0])\n+-- LIMIT 3;\n+\n+DROP TABLE tab;\n+\n+SELECT '--- Test with Array, GRANULARITY = 2, index_granularity = 4 ---';\n+\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch() GRANULARITY 2) ENGINE = MergeTree ORDER BY id SETTINGS index_granularity = 4;\n+INSERT INTO tab VALUES (1, [0.0, 0.0, 10.0, 0.0]), (2, [0.0, 0.0, 10.5, 0.0]), (3, [0.0, 0.0, 9.5, 0.0]), (4, [0.0, 0.0, 9.7, 0.0]), (5, [10.0, 0.0, 0.0, 0.0]), (6, [9.5, 0.0, 0.0, 0.0]), (7, [9.7, 0.0, 0.0, 0.0]), (8, [10.2, 0.0, 0.0, 0.0]), (9, [0.0, 10.0, 0.0, 0.0]), (10, [0.0, 9.5, 0.0, 0.0]), (11, [0.0, 9.7, 0.0, 0.0]), (12, [0.0, 9.7, 0.0, 0.0]), (13, [0.0, 0.0, 0.0, 10.3]), (14, [0.0, 0.0, 0.0, 9.5]), (15, [0.0, 0.0, 0.0, 10.0]), (16, [0.0, 0.0, 0.0, 10.5]);\n+\n+-- rows = 16, index_granularity = 4, GRANULARITY = 2 gives 2 usearch-indexed blocks (each comprising two granules)\n+-- condition 'L2Distance(vector, reference_vector) < 1.0' ensures that only one usearch-indexed block produces results --> \"Granules: 2/4\"\n+\n+-- SELECT 'WHERE type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- WHERE L2Distance(vector, [10.0, 0.0, 10.0, 0.0]) < 5.0\n+-- LIMIT 3;\n+\n+SELECT 'WHERE type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+WHERE L2Distance(vector, [10.0, 0.0, 10.0, 0.0]) < 5.0\n+LIMIT 3;\n+\n+-- SELECT 'ORDER BY type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- ORDER BY L2Distance(vector, [10.0, 0.0, 10.0, 0.0])\n+-- LIMIT 3;\n+\n+SELECT 'ORDER BY type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+ORDER BY L2Distance(vector, [10.0, 0.0, 10.0, 0.0])\n+LIMIT 3;\n+\n+DROP TABLE tab;\n+\n+SELECT '--- Test with Array, GRANULARITY = 4, index_granularity = 4 ---';\n+\n+CREATE TABLE tab(id Int32, vector Array(Float32), INDEX usearch_index vector TYPE usearch() GRANULARITY 4) ENGINE = MergeTree ORDER BY id SETTINGS index_granularity = 4;\n+INSERT INTO tab VALUES (1, [0.0, 0.0, 10.0, 0.0]), (2, [0.0, 0.0, 10.5, 0.0]), (3, [0.0, 0.0, 9.5, 0.0]), (4, [0.0, 0.0, 9.7, 0.0]), (5, [10.0, 0.0, 0.0, 0.0]), (6, [9.5, 0.0, 0.0, 0.0]), (7, [9.7, 0.0, 0.0, 0.0]), (8, [10.2, 0.0, 0.0, 0.0]), (9, [0.0, 10.0, 0.0, 0.0]), (10, [0.0, 9.5, 0.0, 0.0]), (11, [0.0, 9.7, 0.0, 0.0]), (12, [0.0, 9.7, 0.0, 0.0]), (13, [0.0, 0.0, 0.0, 10.3]), (14, [0.0, 0.0, 0.0, 9.5]), (15, [0.0, 0.0, 0.0, 10.0]), (16, [0.0, 0.0, 0.0, 10.5]);\n+\n+-- rows = 16, index_granularity = 4, GRANULARITY = 4 gives a single usearch-indexed block (comprising all granules)\n+-- no two matches happen to be located in the same granule, so with LIMIT = 3, we'll get \"Granules: 2/4\"\n+\n+-- SELECT 'WHERE type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- WHERE L2Distance(vector, [10.0, 0.0, 10.0, 0.0]) < 5.0\n+-- LIMIT 3;\n+\n+SELECT 'WHERE type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+WHERE L2Distance(vector, [10.0, 0.0, 10.0, 0.0]) < 5.0\n+LIMIT 3;\n+\n+-- SELECT 'ORDER BY type, L2Distance';\n+-- SELECT *\n+-- FROM tab\n+-- ORDER BY L2Distance(vector, [10.0, 0.0, 10.0, 0.0])\n+-- LIMIT 3;\n+\n+SELECT 'ORDER BY type, L2Distance, check that index is used';\n+EXPLAIN indexes=1\n+SELECT *\n+FROM tab\n+ORDER BY L2Distance(vector, [10.0, 0.0, 10.0, 0.0])\n+LIMIT 3;\n+\n+DROP TABLE tab;\n",
  "problem_statement": "Support for Vector Search HNSW Index \nCan someone clarify what version of Clickhouse is recommended to use HNSW (Hierarchical Navigable Small World) indices? \n",
  "hints_text": "It wasn't merged AFAIK https://github.com/ClickHouse/ClickHouse/pull/37007\n@UnamedRus thx, any idea why it wasn't merged or just abandoned? \n> @UnamedRus thx, any idea why it wasn't merged or just abandoned?\r\n\r\nIt was one of many student projects which tried to integrate Approximate Neighborhood Search indexes into ClickHouse. There was no technical reason to abandon it, the only reason was that the student moved on and the PR got stuck at some point.\r\n\r\nInterestingly, as I write this, an attempt to integrate [usearch](https://github.com/unum-cloud/usearch) which also implements HNSW is underway: https://github.com/ClickHouse/ClickHouse/pull/52603 With a bit of luck, we'll have an (experimental) HNWS-index in a few weeks from now.\nCan this issue be kept open since #52603 was not merged?\nReopened it, assigned myself.\r\n\r\n(#52603 was not intended to be merged, its only purpose was to help the usearch team getting started)\n@alexey-milovidov your help here is highly appreciated, especially this [presentation](https://youtu.be/hGRNcftpqAk?t=1705) creates a feeling that these features exist in the recently released version.\r\n\r\n<img width=\"1691\" alt=\"image\" src=\"https://github.com/ClickHouse/ClickHouse/assets/19474975/a3f3f19c-617b-4663-9e1b-a39d9b64ed5b\">\r\n\nHNSW is questionable because it requires in-memory storage, and its size is similar to the uncompressed data size.\r\nIt will require many additional customizations for real datasets (at least tens of billions of vectors).\n@alexey-milovidov understood, thanks. BTW [Weaviate](https://weaviate.io/developers/weaviate/concepts/vector-index) say:\r\n\r\n> HNSW is a very fast and memory efficient approach of similarity search, because only the highest layer (top layer) is kept in cache instead of all the datapoints in the lowest layer. Only the datapoints that are closest to the search query are loaded once they are requested by a higher layer, which means that only a small amount of memory needs to be reserved.\r\n",
  "created_at": "2023-08-15T12:23:41Z",
  "modified_files": [
    ".gitmodules",
    "contrib/CMakeLists.txt",
    "b/contrib/FP16",
    "b/contrib/FP16-cmake/CMakeLists.txt",
    "b/contrib/SimSIMD",
    "b/contrib/SimSIMD-cmake/CMakeLists.txt",
    "b/contrib/robin-map",
    "b/contrib/robin-map-cmake/CMakeLists.txt",
    "b/contrib/usearch",
    "b/contrib/usearch-cmake/CMakeLists.txt",
    "docs/en/engines/table-engines/mergetree-family/annindexes.md",
    "src/CMakeLists.txt",
    "src/Core/Settings.h",
    "src/Databases/DatabaseReplicated.cpp",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Parsers/ASTIndexDeclaration.h",
    "src/Parsers/ParserCreateIndexQuery.cpp",
    "src/Parsers/ParserCreateQuery.cpp",
    "src/Storages/MergeTree/ApproximateNearestNeighborIndexesCommon.h",
    "src/Storages/MergeTree/MergeTreeIndexAnnoy.cpp",
    "b/src/Storages/MergeTree/MergeTreeIndexUSearch.cpp",
    "b/src/Storages/MergeTree/MergeTreeIndexUSearch.h",
    "src/Storages/MergeTree/MergeTreeIndices.cpp",
    "src/Storages/MergeTree/MergeTreeIndices.h",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02354_usearch_index.reference",
    "b/tests/queries/0_stateless/02354_usearch_index.sql"
  ]
}