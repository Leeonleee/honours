{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62236,
  "instance_id": "ClickHouse__ClickHouse-62236",
  "issue_numbers": [
    "62263"
  ],
  "base_commit": "21abaa14e7627c480511678d32d2e4744e1cb995",
  "patch": "diff --git a/src/Analyzer/ArrayJoinNode.cpp b/src/Analyzer/ArrayJoinNode.cpp\nindex ee6bd80150d1..e817a893af41 100644\n--- a/src/Analyzer/ArrayJoinNode.cpp\n+++ b/src/Analyzer/ArrayJoinNode.cpp\n@@ -33,13 +33,13 @@ void ArrayJoinNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_stat\n     getJoinExpressionsNode()->dumpTreeImpl(buffer, format_state, indent + 4);\n }\n \n-bool ArrayJoinNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool ArrayJoinNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const ArrayJoinNode &>(rhs);\n     return is_left == rhs_typed.is_left;\n }\n \n-void ArrayJoinNode::updateTreeHashImpl(HashState & state) const\n+void ArrayJoinNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     state.update(is_left);\n }\ndiff --git a/src/Analyzer/ArrayJoinNode.h b/src/Analyzer/ArrayJoinNode.h\nindex 89cb0b7b8c10..1772e2b3ca07 100644\n--- a/src/Analyzer/ArrayJoinNode.h\n+++ b/src/Analyzer/ArrayJoinNode.h\n@@ -93,9 +93,9 @@ class ArrayJoinNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & state) const override;\n+    void updateTreeHashImpl(HashState & state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/ColumnNode.cpp b/src/Analyzer/ColumnNode.cpp\nindex 3d9f5d1640ef..b8d2613871dc 100644\n--- a/src/Analyzer/ColumnNode.cpp\n+++ b/src/Analyzer/ColumnNode.cpp\n@@ -70,20 +70,26 @@ void ColumnNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & state, size_t\n     }\n }\n \n-bool ColumnNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool ColumnNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions compare_options) const\n {\n     const auto & rhs_typed = assert_cast<const ColumnNode &>(rhs);\n-    return column == rhs_typed.column;\n+    if (column.name != rhs_typed.column.name)\n+        return false;\n+\n+    return !compare_options.compare_types || column.type->equals(*rhs_typed.column.type);\n }\n \n-void ColumnNode::updateTreeHashImpl(HashState & hash_state) const\n+void ColumnNode::updateTreeHashImpl(HashState & hash_state, CompareOptions compare_options) const\n {\n     hash_state.update(column.name.size());\n     hash_state.update(column.name);\n \n-    const auto & column_type_name = column.type->getName();\n-    hash_state.update(column_type_name.size());\n-    hash_state.update(column_type_name);\n+    if (compare_options.compare_types)\n+    {\n+        const auto & column_type_name = column.type->getName();\n+        hash_state.update(column_type_name.size());\n+        hash_state.update(column_type_name);\n+    }\n }\n \n QueryTreeNodePtr ColumnNode::cloneImpl() const\ndiff --git a/src/Analyzer/ColumnNode.h b/src/Analyzer/ColumnNode.h\nindex 46e7c8eb5007..f6fac5ce7f9a 100644\n--- a/src/Analyzer/ColumnNode.h\n+++ b/src/Analyzer/ColumnNode.h\n@@ -131,9 +131,9 @@ class ColumnNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/ColumnTransformers.cpp b/src/Analyzer/ColumnTransformers.cpp\nindex 3a6b9e3b2916..356344c1aec9 100644\n--- a/src/Analyzer/ColumnTransformers.cpp\n+++ b/src/Analyzer/ColumnTransformers.cpp\n@@ -74,13 +74,13 @@ void ApplyColumnTransformerNode::dumpTreeImpl(WriteBuffer & buffer, FormatState\n     expression_node->dumpTreeImpl(buffer, format_state, indent + 4);\n }\n \n-bool ApplyColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool ApplyColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const ApplyColumnTransformerNode &>(rhs);\n     return apply_transformer_type == rhs_typed.apply_transformer_type;\n }\n \n-void ApplyColumnTransformerNode::updateTreeHashImpl(IQueryTreeNode::HashState & hash_state) const\n+void ApplyColumnTransformerNode::updateTreeHashImpl(IQueryTreeNode::HashState & hash_state, CompareOptions) const\n {\n     hash_state.update(static_cast<size_t>(getTransformerType()));\n     hash_state.update(static_cast<size_t>(getApplyTransformerType()));\n@@ -178,7 +178,7 @@ void ExceptColumnTransformerNode::dumpTreeImpl(WriteBuffer & buffer, FormatState\n     }\n }\n \n-bool ExceptColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool ExceptColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const ExceptColumnTransformerNode &>(rhs);\n     if (except_transformer_type != rhs_typed.except_transformer_type ||\n@@ -198,7 +198,7 @@ bool ExceptColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs) const\n     return column_matcher->pattern() == rhs_column_matcher->pattern();\n }\n \n-void ExceptColumnTransformerNode::updateTreeHashImpl(IQueryTreeNode::HashState & hash_state) const\n+void ExceptColumnTransformerNode::updateTreeHashImpl(IQueryTreeNode::HashState & hash_state, CompareOptions) const\n {\n     hash_state.update(static_cast<size_t>(getTransformerType()));\n     hash_state.update(static_cast<size_t>(getExceptTransformerType()));\n@@ -302,13 +302,13 @@ void ReplaceColumnTransformerNode::dumpTreeImpl(WriteBuffer & buffer, FormatStat\n     }\n }\n \n-bool ReplaceColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool ReplaceColumnTransformerNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const ReplaceColumnTransformerNode &>(rhs);\n     return is_strict == rhs_typed.is_strict && replacements_names == rhs_typed.replacements_names;\n }\n \n-void ReplaceColumnTransformerNode::updateTreeHashImpl(IQueryTreeNode::HashState & hash_state) const\n+void ReplaceColumnTransformerNode::updateTreeHashImpl(IQueryTreeNode::HashState & hash_state, CompareOptions) const\n {\n     hash_state.update(static_cast<size_t>(getTransformerType()));\n \ndiff --git a/src/Analyzer/ColumnTransformers.h b/src/Analyzer/ColumnTransformers.h\nindex 8fa8e28f1947..9ae1f14575b7 100644\n--- a/src/Analyzer/ColumnTransformers.h\n+++ b/src/Analyzer/ColumnTransformers.h\n@@ -137,9 +137,9 @@ class ApplyColumnTransformerNode final : public IColumnTransformerNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(IQueryTreeNode::HashState & hash_state) const override;\n+    void updateTreeHashImpl(IQueryTreeNode::HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \n@@ -214,9 +214,9 @@ class ExceptColumnTransformerNode final : public IColumnTransformerNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(IQueryTreeNode::HashState & hash_state) const override;\n+    void updateTreeHashImpl(IQueryTreeNode::HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \n@@ -290,9 +290,9 @@ class ReplaceColumnTransformerNode final : public IColumnTransformerNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(IQueryTreeNode::HashState & hash_state) const override;\n+    void updateTreeHashImpl(IQueryTreeNode::HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/ConstantNode.cpp b/src/Analyzer/ConstantNode.cpp\nindex e26500a9886f..46c1f7fb1edf 100644\n--- a/src/Analyzer/ConstantNode.cpp\n+++ b/src/Analyzer/ConstantNode.cpp\n@@ -126,17 +126,29 @@ void ConstantNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state\n     }\n }\n \n-bool ConstantNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+void ConstantNode::convertToNullable()\n+{\n+    constant_value = std::make_shared<ConstantValue>(constant_value->getValue(), makeNullableSafe(constant_value->getType()));\n+}\n+\n+bool ConstantNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions compare_options) const\n {\n     const auto & rhs_typed = assert_cast<const ConstantNode &>(rhs);\n-    return *constant_value == *rhs_typed.constant_value && value_string == rhs_typed.value_string;\n+\n+    if (value_string != rhs_typed.value_string || constant_value->getValue() != rhs_typed.constant_value->getValue())\n+        return false;\n+\n+    return !compare_options.compare_types || constant_value->getType()->equals(*rhs_typed.constant_value->getType());\n }\n \n-void ConstantNode::updateTreeHashImpl(HashState & hash_state) const\n+void ConstantNode::updateTreeHashImpl(HashState & hash_state, CompareOptions compare_options) const\n {\n-    auto type_name = constant_value->getType()->getName();\n-    hash_state.update(type_name.size());\n-    hash_state.update(type_name);\n+    if (compare_options.compare_types)\n+    {\n+        auto type_name = constant_value->getType()->getName();\n+        hash_state.update(type_name.size());\n+        hash_state.update(type_name);\n+    }\n \n     hash_state.update(value_string.size());\n     hash_state.update(value_string);\ndiff --git a/src/Analyzer/ConstantNode.h b/src/Analyzer/ConstantNode.h\nindex 98a8eb782776..0c88862b8792 100644\n--- a/src/Analyzer/ConstantNode.h\n+++ b/src/Analyzer/ConstantNode.h\n@@ -87,17 +87,14 @@ class ConstantNode final : public IQueryTreeNode\n         mask_id = id;\n     }\n \n-    void convertToNullable() override\n-    {\n-        constant_value = std::make_shared<ConstantValue>(constant_value->getValue(), makeNullableSafe(constant_value->getType()));\n-    }\n+    void convertToNullable() override;\n \n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions compare_options) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions compare_options) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/ConstantValue.h b/src/Analyzer/ConstantValue.h\nindex a9e2ffd9e658..335072b92867 100644\n--- a/src/Analyzer/ConstantValue.h\n+++ b/src/Analyzer/ConstantValue.h\n@@ -34,14 +34,4 @@ class ConstantValue\n     DataTypePtr data_type;\n };\n \n-inline bool operator==(const ConstantValue & lhs, const ConstantValue & rhs)\n-{\n-    return lhs.getValue() == rhs.getValue() && lhs.getType()->equals(*rhs.getType());\n-}\n-\n-inline bool operator!=(const ConstantValue & lhs, const ConstantValue & rhs)\n-{\n-    return !(lhs == rhs);\n-}\n-\n }\ndiff --git a/src/Analyzer/FunctionNode.cpp b/src/Analyzer/FunctionNode.cpp\nindex e902ac2274e6..f13842cf67cc 100644\n--- a/src/Analyzer/FunctionNode.cpp\n+++ b/src/Analyzer/FunctionNode.cpp\n@@ -142,7 +142,7 @@ void FunctionNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state\n     }\n }\n \n-bool FunctionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool FunctionNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions compare_options) const\n {\n     const auto & rhs_typed = assert_cast<const FunctionNode &>(rhs);\n     if (function_name != rhs_typed.function_name || isAggregateFunction() != rhs_typed.isAggregateFunction()\n@@ -150,6 +150,9 @@ bool FunctionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n         || nulls_action != rhs_typed.nulls_action)\n         return false;\n \n+    if (!compare_options.compare_types)\n+        return true;\n+\n     if (isResolved() != rhs_typed.isResolved())\n         return false;\n     if (!isResolved())\n@@ -168,7 +171,7 @@ bool FunctionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n     return true;\n }\n \n-void FunctionNode::updateTreeHashImpl(HashState & hash_state) const\n+void FunctionNode::updateTreeHashImpl(HashState & hash_state, CompareOptions compare_options) const\n {\n     hash_state.update(function_name.size());\n     hash_state.update(function_name);\n@@ -177,6 +180,9 @@ void FunctionNode::updateTreeHashImpl(HashState & hash_state) const\n     hash_state.update(isWindowFunction());\n     hash_state.update(nulls_action);\n \n+    if (!compare_options.compare_types)\n+        return;\n+\n     if (!isResolved())\n         return;\n \ndiff --git a/src/Analyzer/FunctionNode.h b/src/Analyzer/FunctionNode.h\nindex 0ff3e6896327..8d14b7eeb0dd 100644\n--- a/src/Analyzer/FunctionNode.h\n+++ b/src/Analyzer/FunctionNode.h\n@@ -208,9 +208,9 @@ class FunctionNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions compare_options) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions compare_options) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/HashUtils.h b/src/Analyzer/HashUtils.h\nindex eb6aac88fe96..77ade7a4705b 100644\n--- a/src/Analyzer/HashUtils.h\n+++ b/src/Analyzer/HashUtils.h\n@@ -11,37 +11,37 @@ namespace DB\n   * Example of usage:\n   * std::unordered_map<QueryTreeNodeConstRawPtrWithHash, std::string> map;\n   */\n-template <typename QueryTreeNodePtrType, bool compare_aliases = true>\n+template <typename QueryTreeNodePtrType, bool compare_aliases = true, bool compare_types = true>\n struct QueryTreeNodeWithHash\n {\n     QueryTreeNodeWithHash(QueryTreeNodePtrType node_) /// NOLINT\n         : node(std::move(node_))\n-        , hash(node->getTreeHash({.compare_aliases = compare_aliases}))\n+        , hash(node->getTreeHash({.compare_aliases = compare_aliases, .compare_types = compare_types}))\n     {}\n \n     QueryTreeNodePtrType node = nullptr;\n     CityHash_v1_0_2::uint128 hash;\n };\n \n-template <typename T, bool compare_aliases>\n-inline bool operator==(const QueryTreeNodeWithHash<T, compare_aliases> & lhs, const QueryTreeNodeWithHash<T, compare_aliases> & rhs)\n+template <typename T, bool compare_aliases, bool compare_types>\n+inline bool operator==(const QueryTreeNodeWithHash<T, compare_aliases, compare_types> & lhs, const QueryTreeNodeWithHash<T, compare_aliases, compare_types> & rhs)\n {\n-    return lhs.hash == rhs.hash && lhs.node->isEqual(*rhs.node, {.compare_aliases = compare_aliases});\n+    return lhs.hash == rhs.hash && lhs.node->isEqual(*rhs.node, {.compare_aliases = compare_aliases, .compare_types = compare_types});\n }\n \n-template <typename T, bool compare_aliases>\n-inline bool operator!=(const QueryTreeNodeWithHash<T, compare_aliases> & lhs, const QueryTreeNodeWithHash<T, compare_aliases> & rhs)\n+template <typename T, bool compare_aliases, bool compare_types>\n+inline bool operator!=(const QueryTreeNodeWithHash<T, compare_aliases, compare_types> & lhs, const QueryTreeNodeWithHash<T, compare_aliases, compare_types> & rhs)\n {\n     return !(lhs == rhs);\n }\n \n using QueryTreeNodePtrWithHash = QueryTreeNodeWithHash<QueryTreeNodePtr>;\n-using QueryTreeNodePtrWithHashWithoutAlias = QueryTreeNodeWithHash<QueryTreeNodePtr, /*compare_aliases*/ false>;\n+using QueryTreeNodePtrWithHashIgnoreTypes = QueryTreeNodeWithHash<QueryTreeNodePtr, /*compare_aliases*/ false, /*compare_types*/ false>;\n using QueryTreeNodeRawPtrWithHash = QueryTreeNodeWithHash<IQueryTreeNode *>;\n using QueryTreeNodeConstRawPtrWithHash = QueryTreeNodeWithHash<const IQueryTreeNode *>;\n \n using QueryTreeNodePtrWithHashSet = std::unordered_set<QueryTreeNodePtrWithHash>;\n-using QueryTreeNodePtrWithHashWithoutAliasSet = std::unordered_set<QueryTreeNodePtrWithHashWithoutAlias>;\n+using QueryTreeNodePtrWithHashIgnoreTypesSet = std::unordered_set<QueryTreeNodePtrWithHashIgnoreTypes>;\n using QueryTreeNodeConstRawPtrWithHashSet = std::unordered_set<QueryTreeNodeConstRawPtrWithHash>;\n \n template <typename Value>\n@@ -52,10 +52,10 @@ using QueryTreeNodeConstRawPtrWithHashMap = std::unordered_map<QueryTreeNodeCons\n \n }\n \n-template <typename T, bool compare_aliases>\n-struct std::hash<DB::QueryTreeNodeWithHash<T, compare_aliases>>\n+template <typename T, bool compare_aliases, bool compare_types>\n+struct std::hash<DB::QueryTreeNodeWithHash<T, compare_aliases, compare_types>>\n {\n-    size_t operator()(const DB::QueryTreeNodeWithHash<T, compare_aliases> & node_with_hash) const\n+    size_t operator()(const DB::QueryTreeNodeWithHash<T, compare_aliases, compare_types> & node_with_hash) const\n     {\n         return node_with_hash.hash.low64;\n     }\ndiff --git a/src/Analyzer/IQueryTreeNode.cpp b/src/Analyzer/IQueryTreeNode.cpp\nindex 7815b93c3aca..cd085babf384 100644\n--- a/src/Analyzer/IQueryTreeNode.cpp\n+++ b/src/Analyzer/IQueryTreeNode.cpp\n@@ -107,7 +107,7 @@ bool IQueryTreeNode::isEqual(const IQueryTreeNode & rhs, CompareOptions compare_\n         }\n \n         if (lhs_node_to_compare->getNodeType() != rhs_node_to_compare->getNodeType() ||\n-            !lhs_node_to_compare->isEqualImpl(*rhs_node_to_compare))\n+            !lhs_node_to_compare->isEqualImpl(*rhs_node_to_compare, compare_options))\n             return false;\n \n         if (compare_options.compare_aliases && lhs_node_to_compare->alias != rhs_node_to_compare->alias)\n@@ -207,7 +207,7 @@ IQueryTreeNode::Hash IQueryTreeNode::getTreeHash(CompareOptions compare_options)\n             hash_state.update(node_to_process->alias);\n         }\n \n-        node_to_process->updateTreeHashImpl(hash_state);\n+        node_to_process->updateTreeHashImpl(hash_state, compare_options);\n \n         hash_state.update(node_to_process->children.size());\n \ndiff --git a/src/Analyzer/IQueryTreeNode.h b/src/Analyzer/IQueryTreeNode.h\nindex 92e34616c4d7..fc2cb2c53f66 100644\n--- a/src/Analyzer/IQueryTreeNode.h\n+++ b/src/Analyzer/IQueryTreeNode.h\n@@ -97,6 +97,7 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n     struct CompareOptions\n     {\n         bool compare_aliases = true;\n+        bool compare_types = true;\n     };\n \n     /** Is tree equal to other tree with node root.\n@@ -104,7 +105,7 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n       * With default compare options aliases of query tree nodes are compared during isEqual call.\n       * Original ASTs of query tree nodes are not compared during isEqual call.\n       */\n-    bool isEqual(const IQueryTreeNode & rhs, CompareOptions compare_options = { .compare_aliases = true }) const;\n+    bool isEqual(const IQueryTreeNode & rhs, CompareOptions compare_options = { .compare_aliases = true, .compare_types = true }) const;\n \n     using Hash = CityHash_v1_0_2::uint128;\n     using HashState = SipHash;\n@@ -114,7 +115,7 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n       * Alias of query tree node is part of query tree hash.\n       * Original AST is not part of query tree hash.\n       */\n-    Hash getTreeHash(CompareOptions compare_options = { .compare_aliases = true }) const;\n+    Hash getTreeHash(CompareOptions compare_options = { .compare_aliases = true, .compare_types = true }) const;\n \n     /// Get a deep copy of the query tree\n     QueryTreeNodePtr clone() const;\n@@ -264,12 +265,12 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>\n     /** Subclass must compare its internal state with rhs node internal state and do not compare children or weak pointers to other\n       * query tree nodes.\n       */\n-    virtual bool isEqualImpl(const IQueryTreeNode & rhs) const = 0;\n+    virtual bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions compare_options) const = 0;\n \n     /** Subclass must update tree hash with its internal state and do not update tree hash for children or weak pointers to other\n       * query tree nodes.\n       */\n-    virtual void updateTreeHashImpl(HashState & hash_state) const = 0;\n+    virtual void updateTreeHashImpl(HashState & hash_state, CompareOptions compare_options) const = 0;\n \n     /** Subclass must clone its internal state and do not clone children or weak pointers to other\n       * query tree nodes.\ndiff --git a/src/Analyzer/IdentifierNode.cpp b/src/Analyzer/IdentifierNode.cpp\nindex 88b3daacb125..181e75a57fd8 100644\n--- a/src/Analyzer/IdentifierNode.cpp\n+++ b/src/Analyzer/IdentifierNode.cpp\n@@ -38,13 +38,13 @@ void IdentifierNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_sta\n     }\n }\n \n-bool IdentifierNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool IdentifierNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const IdentifierNode &>(rhs);\n     return identifier == rhs_typed.identifier && table_expression_modifiers == rhs_typed.table_expression_modifiers;\n }\n \n-void IdentifierNode::updateTreeHashImpl(HashState & state) const\n+void IdentifierNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     const auto & identifier_name = identifier.getFullName();\n     state.update(identifier_name.size());\ndiff --git a/src/Analyzer/IdentifierNode.h b/src/Analyzer/IdentifierNode.h\nindex 872bb14d5128..1b07f0b3765c 100644\n--- a/src/Analyzer/IdentifierNode.h\n+++ b/src/Analyzer/IdentifierNode.h\n@@ -53,9 +53,9 @@ class IdentifierNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & state) const override;\n+    void updateTreeHashImpl(HashState & state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/InterpolateNode.cpp b/src/Analyzer/InterpolateNode.cpp\nindex d78993c7b855..e4f7e22b8039 100644\n--- a/src/Analyzer/InterpolateNode.cpp\n+++ b/src/Analyzer/InterpolateNode.cpp\n@@ -28,13 +28,13 @@ void InterpolateNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_st\n     getInterpolateExpression()->dumpTreeImpl(buffer, format_state, indent + 4);\n }\n \n-bool InterpolateNode::isEqualImpl(const IQueryTreeNode &) const\n+bool InterpolateNode::isEqualImpl(const IQueryTreeNode &, CompareOptions) const\n {\n     /// No state in interpolate node\n     return true;\n }\n \n-void InterpolateNode::updateTreeHashImpl(HashState &) const\n+void InterpolateNode::updateTreeHashImpl(HashState &, CompareOptions) const\n {\n     /// No state in interpolate node\n }\ndiff --git a/src/Analyzer/InterpolateNode.h b/src/Analyzer/InterpolateNode.h\nindex c45800ebaaff..9269d3924f5b 100644\n--- a/src/Analyzer/InterpolateNode.h\n+++ b/src/Analyzer/InterpolateNode.h\n@@ -53,9 +53,9 @@ class InterpolateNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/JoinNode.cpp b/src/Analyzer/JoinNode.cpp\nindex 9b61c8b19d0d..1a440ad8abc6 100644\n--- a/src/Analyzer/JoinNode.cpp\n+++ b/src/Analyzer/JoinNode.cpp\n@@ -81,13 +81,13 @@ void JoinNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, si\n     }\n }\n \n-bool JoinNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool JoinNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const JoinNode &>(rhs);\n     return locality == rhs_typed.locality && strictness == rhs_typed.strictness && kind == rhs_typed.kind;\n }\n \n-void JoinNode::updateTreeHashImpl(HashState & state) const\n+void JoinNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     state.update(locality);\n     state.update(strictness);\ndiff --git a/src/Analyzer/JoinNode.h b/src/Analyzer/JoinNode.h\nindex 4f071e03856f..734162d95469 100644\n--- a/src/Analyzer/JoinNode.h\n+++ b/src/Analyzer/JoinNode.h\n@@ -142,9 +142,9 @@ class JoinNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & state) const override;\n+    void updateTreeHashImpl(HashState & state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/LambdaNode.cpp b/src/Analyzer/LambdaNode.cpp\nindex 4be4d69c1907..bca2616d85a9 100644\n--- a/src/Analyzer/LambdaNode.cpp\n+++ b/src/Analyzer/LambdaNode.cpp\n@@ -46,13 +46,13 @@ void LambdaNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state,\n     getExpression()->dumpTreeImpl(buffer, format_state, indent + 4);\n }\n \n-bool LambdaNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool LambdaNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const LambdaNode &>(rhs);\n     return argument_names == rhs_typed.argument_names;\n }\n \n-void LambdaNode::updateTreeHashImpl(HashState & state) const\n+void LambdaNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     state.update(argument_names.size());\n     for (const auto & argument_name : argument_names)\ndiff --git a/src/Analyzer/LambdaNode.h b/src/Analyzer/LambdaNode.h\nindex ea44a7e8187e..0b2882125f0e 100644\n--- a/src/Analyzer/LambdaNode.h\n+++ b/src/Analyzer/LambdaNode.h\n@@ -97,9 +97,9 @@ class LambdaNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & state) const override;\n+    void updateTreeHashImpl(HashState & state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/ListNode.cpp b/src/Analyzer/ListNode.cpp\nindex 799c471d6859..217cd6cefa33 100644\n--- a/src/Analyzer/ListNode.cpp\n+++ b/src/Analyzer/ListNode.cpp\n@@ -38,13 +38,13 @@ void ListNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, si\n     }\n }\n \n-bool ListNode::isEqualImpl(const IQueryTreeNode &) const\n+bool ListNode::isEqualImpl(const IQueryTreeNode &, CompareOptions) const\n {\n     /// No state\n     return true;\n }\n \n-void ListNode::updateTreeHashImpl(HashState &) const\n+void ListNode::updateTreeHashImpl(HashState &, CompareOptions) const\n {\n     /// No state\n }\ndiff --git a/src/Analyzer/ListNode.h b/src/Analyzer/ListNode.h\nindex 5b1abc36ae96..379919f190fb 100644\n--- a/src/Analyzer/ListNode.h\n+++ b/src/Analyzer/ListNode.h\n@@ -51,9 +51,9 @@ class ListNode final : public IQueryTreeNode\n     const_iterator end() const { return children.end(); }\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState &) const override;\n+    void updateTreeHashImpl(HashState &, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/MatcherNode.cpp b/src/Analyzer/MatcherNode.cpp\nindex f573b83e5383..341c4b8eec75 100644\n--- a/src/Analyzer/MatcherNode.cpp\n+++ b/src/Analyzer/MatcherNode.cpp\n@@ -160,7 +160,7 @@ void MatcherNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state,\n     }\n }\n \n-bool MatcherNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool MatcherNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const MatcherNode &>(rhs);\n     if (matcher_type != rhs_typed.matcher_type ||\n@@ -181,7 +181,7 @@ bool MatcherNode::isEqualImpl(const IQueryTreeNode & rhs) const\n     return columns_matcher->pattern() == rhs_columns_matcher->pattern();\n }\n \n-void MatcherNode::updateTreeHashImpl(HashState & hash_state) const\n+void MatcherNode::updateTreeHashImpl(HashState & hash_state, CompareOptions) const\n {\n     hash_state.update(static_cast<size_t>(matcher_type));\n \ndiff --git a/src/Analyzer/MatcherNode.h b/src/Analyzer/MatcherNode.h\nindex d6f077e224be..a7ec7d984c66 100644\n--- a/src/Analyzer/MatcherNode.h\n+++ b/src/Analyzer/MatcherNode.h\n@@ -135,9 +135,9 @@ class MatcherNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex f5474ddb662a..487b40a5ccfd 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -776,7 +776,7 @@ struct IdentifierResolveScope\n     /// Table expression node to data\n     std::unordered_map<QueryTreeNodePtr, TableExpressionData> table_expression_node_to_data;\n \n-    QueryTreeNodePtrWithHashWithoutAliasSet nullable_group_by_keys;\n+    QueryTreeNodePtrWithHashIgnoreTypesSet nullable_group_by_keys;\n     /// Here we count the number of nullable GROUP BY keys we met resolving expression.\n     /// E.g. for a query `SELECT tuple(tuple(number)) FROM numbers(10) GROUP BY (number, tuple(number)) with cube`\n     /// both `number` and `tuple(number)` would be in nullable_group_by_keys.\n@@ -6155,12 +6155,6 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n         return resolved_expression_it->second;\n     }\n \n-    bool is_nullable_group_by_key = scope.nullable_group_by_keys.contains(node) && !scope.expressions_in_resolve_process_stack.hasAggregateFunction();\n-    if (is_nullable_group_by_key)\n-        ++scope.found_nullable_group_by_key_in_scope;\n-\n-    SCOPE_EXIT(scope.found_nullable_group_by_key_in_scope -= is_nullable_group_by_key);\n-\n     String node_alias = node->getAlias();\n     ProjectionNames result_projection_names;\n \n@@ -6452,10 +6446,14 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n \n     validateTreeSize(node, scope.context->getSettingsRef().max_expanded_ast_elements, node_to_tree_size);\n \n-    if (is_nullable_group_by_key && scope.found_nullable_group_by_key_in_scope == 1)\n+    if (!scope.expressions_in_resolve_process_stack.hasAggregateFunction())\n     {\n-        node = node->clone();\n-        node->convertToNullable();\n+        auto it = scope.nullable_group_by_keys.find(node);\n+        if (it != scope.nullable_group_by_keys.end())\n+        {\n+            node = it->node->clone();\n+            node->convertToNullable();\n+        }\n     }\n \n     /** Update aliases after expression node was resolved.\n@@ -6679,48 +6677,45 @@ void QueryAnalyzer::resolveGroupByNode(QueryNode & query_node_typed, IdentifierR\n \n     if (query_node_typed.isGroupByWithGroupingSets())\n     {\n-        QueryTreeNodes nullable_group_by_keys;\n         for (auto & grouping_sets_keys_list_node : query_node_typed.getGroupBy().getNodes())\n         {\n             if (settings.enable_positional_arguments)\n                 replaceNodesWithPositionalArguments(grouping_sets_keys_list_node, query_node_typed.getProjection().getNodes(), scope);\n \n+            resolveExpressionNodeList(grouping_sets_keys_list_node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+\n             // Remove redundant calls to `tuple` function. It simplifies checking if expression is an aggregation key.\n             // It's required to support queries like: SELECT number FROM numbers(3) GROUP BY (number, number % 2)\n             auto & group_by_list = grouping_sets_keys_list_node->as<ListNode &>().getNodes();\n             expandTuplesInList(group_by_list);\n-\n-            if (scope.group_by_use_nulls)\n-                for (const auto & group_by_elem : group_by_list)\n-                    nullable_group_by_keys.push_back(group_by_elem->clone());\n-\n-            resolveExpressionNodeList(grouping_sets_keys_list_node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n         }\n \n-        for (auto & nullable_group_by_key : nullable_group_by_keys)\n-            scope.nullable_group_by_keys.insert(std::move(nullable_group_by_key));\n+        if (scope.group_by_use_nulls)\n+        {\n+            for (const auto & grouping_set : query_node_typed.getGroupBy().getNodes())\n+            {\n+                for (const auto & group_by_elem : grouping_set->as<ListNode>()->getNodes())\n+                    scope.nullable_group_by_keys.insert(group_by_elem);\n+            }\n+        }\n     }\n     else\n     {\n         if (settings.enable_positional_arguments)\n             replaceNodesWithPositionalArguments(query_node_typed.getGroupByNode(), query_node_typed.getProjection().getNodes(), scope);\n \n+        resolveExpressionNodeList(query_node_typed.getGroupByNode(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+\n         // Remove redundant calls to `tuple` function. It simplifies checking if expression is an aggregation key.\n         // It's required to support queries like: SELECT number FROM numbers(3) GROUP BY (number, number % 2)\n         auto & group_by_list = query_node_typed.getGroupBy().getNodes();\n         expandTuplesInList(group_by_list);\n \n-        QueryTreeNodes nullable_group_by_keys;\n         if (scope.group_by_use_nulls)\n         {\n             for (const auto & group_by_elem : query_node_typed.getGroupBy().getNodes())\n-                nullable_group_by_keys.push_back(group_by_elem->clone());\n+                scope.nullable_group_by_keys.insert(group_by_elem);\n         }\n-\n-        resolveExpressionNodeList(query_node_typed.getGroupByNode(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n-\n-        for (auto & nullable_group_by_key : nullable_group_by_keys)\n-            scope.nullable_group_by_keys.insert(std::move(nullable_group_by_key));\n     }\n }\n \n@@ -8031,6 +8026,16 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n     if (query_node_typed.hasGroupBy())\n         resolveGroupByNode(query_node_typed, scope);\n \n+    if (scope.group_by_use_nulls)\n+    {\n+        resolved_expressions.clear();\n+        /// Clone is needed cause aliases share subtrees.\n+        /// If not clone, the same (shared) subtree could be resolved again with different (Nullable) type\n+        /// See 03023_group_by_use_nulls_analyzer_crashes\n+        for (auto & [_, node] : scope.alias_name_to_expression_node)\n+            node = node->clone();\n+    }\n+\n     if (query_node_typed.hasHaving())\n         resolveExpressionNode(query_node_typed.getHaving(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n \ndiff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex bc7a29247e44..f1361c328dbf 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -247,7 +247,7 @@ void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s\n     }\n }\n \n-bool QueryNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool QueryNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const QueryNode &>(rhs);\n \n@@ -266,7 +266,7 @@ bool QueryNode::isEqualImpl(const IQueryTreeNode & rhs) const\n         settings_changes == rhs_typed.settings_changes;\n }\n \n-void QueryNode::updateTreeHashImpl(HashState & state) const\n+void QueryNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     state.update(is_subquery);\n     state.update(is_cte);\ndiff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h\nindex 6f9067908dde..af187df72a80 100644\n--- a/src/Analyzer/QueryNode.h\n+++ b/src/Analyzer/QueryNode.h\n@@ -589,9 +589,9 @@ class QueryNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState &) const override;\n+    void updateTreeHashImpl(HashState &, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/SortNode.cpp b/src/Analyzer/SortNode.cpp\nindex 8e9913af442c..795a639deea7 100644\n--- a/src/Analyzer/SortNode.cpp\n+++ b/src/Analyzer/SortNode.cpp\n@@ -71,7 +71,7 @@ void SortNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, si\n     }\n }\n \n-bool SortNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool SortNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const SortNode &>(rhs);\n     if (sort_direction != rhs_typed.sort_direction ||\n@@ -89,7 +89,7 @@ bool SortNode::isEqualImpl(const IQueryTreeNode & rhs) const\n     return collator->getLocale() == rhs_typed.collator->getLocale();\n }\n \n-void SortNode::updateTreeHashImpl(HashState & hash_state) const\n+void SortNode::updateTreeHashImpl(HashState & hash_state, CompareOptions) const\n {\n     hash_state.update(sort_direction);\n     /// use some determined value if `nulls_sort_direction` is `nullopt`\ndiff --git a/src/Analyzer/SortNode.h b/src/Analyzer/SortNode.h\nindex b860fd19a900..4d1f6f7c0f0d 100644\n--- a/src/Analyzer/SortNode.h\n+++ b/src/Analyzer/SortNode.h\n@@ -131,9 +131,9 @@ class SortNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/TableFunctionNode.cpp b/src/Analyzer/TableFunctionNode.cpp\nindex e5158a06373c..87d2fdcffb52 100644\n--- a/src/Analyzer/TableFunctionNode.cpp\n+++ b/src/Analyzer/TableFunctionNode.cpp\n@@ -82,7 +82,7 @@ void TableFunctionNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_\n     }\n }\n \n-bool TableFunctionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool TableFunctionNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const TableFunctionNode &>(rhs);\n     if (table_function_name != rhs_typed.table_function_name)\n@@ -97,7 +97,7 @@ bool TableFunctionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n     return table_expression_modifiers == rhs_typed.table_expression_modifiers;\n }\n \n-void TableFunctionNode::updateTreeHashImpl(HashState & state) const\n+void TableFunctionNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     state.update(table_function_name.size());\n     state.update(table_function_name);\ndiff --git a/src/Analyzer/TableFunctionNode.h b/src/Analyzer/TableFunctionNode.h\nindex 69237ac84167..98121ef95c59 100644\n--- a/src/Analyzer/TableFunctionNode.h\n+++ b/src/Analyzer/TableFunctionNode.h\n@@ -155,9 +155,9 @@ class TableFunctionNode : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & state) const override;\n+    void updateTreeHashImpl(HashState & state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/TableNode.cpp b/src/Analyzer/TableNode.cpp\nindex f899c1ae6fe9..daf5db08551d 100644\n--- a/src/Analyzer/TableNode.cpp\n+++ b/src/Analyzer/TableNode.cpp\n@@ -52,14 +52,14 @@ void TableNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s\n     }\n }\n \n-bool TableNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool TableNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const TableNode &>(rhs);\n     return storage_id == rhs_typed.storage_id && table_expression_modifiers == rhs_typed.table_expression_modifiers &&\n         temporary_table_name == rhs_typed.temporary_table_name;\n }\n \n-void TableNode::updateTreeHashImpl(HashState & state) const\n+void TableNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     if (!temporary_table_name.empty())\n     {\ndiff --git a/src/Analyzer/TableNode.h b/src/Analyzer/TableNode.h\nindex b0bf91fa01b9..2d66167acd15 100644\n--- a/src/Analyzer/TableNode.h\n+++ b/src/Analyzer/TableNode.h\n@@ -100,9 +100,9 @@ class TableNode : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & state) const override;\n+    void updateTreeHashImpl(HashState & state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp\nindex c60031265544..9bc2a197d9a6 100644\n--- a/src/Analyzer/UnionNode.cpp\n+++ b/src/Analyzer/UnionNode.cpp\n@@ -145,7 +145,7 @@ void UnionNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s\n     getQueriesNode()->dumpTreeImpl(buffer, format_state, indent + 4);\n }\n \n-bool UnionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool UnionNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const UnionNode &>(rhs);\n \n@@ -153,7 +153,7 @@ bool UnionNode::isEqualImpl(const IQueryTreeNode & rhs) const\n         union_mode == rhs_typed.union_mode;\n }\n \n-void UnionNode::updateTreeHashImpl(HashState & state) const\n+void UnionNode::updateTreeHashImpl(HashState & state, CompareOptions) const\n {\n     state.update(is_subquery);\n     state.update(is_cte);\ndiff --git a/src/Analyzer/UnionNode.h b/src/Analyzer/UnionNode.h\nindex 7686b73f5e06..189951f6375d 100644\n--- a/src/Analyzer/UnionNode.h\n+++ b/src/Analyzer/UnionNode.h\n@@ -143,9 +143,9 @@ class UnionNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState &) const override;\n+    void updateTreeHashImpl(HashState &, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \ndiff --git a/src/Analyzer/WindowNode.cpp b/src/Analyzer/WindowNode.cpp\nindex 0fbe7c51bc7c..39a89ca6828f 100644\n--- a/src/Analyzer/WindowNode.cpp\n+++ b/src/Analyzer/WindowNode.cpp\n@@ -80,14 +80,14 @@ void WindowNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state,\n     }\n }\n \n-bool WindowNode::isEqualImpl(const IQueryTreeNode & rhs) const\n+bool WindowNode::isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const\n {\n     const auto & rhs_typed = assert_cast<const WindowNode &>(rhs);\n \n     return window_frame == rhs_typed.window_frame && parent_window_name == rhs_typed.parent_window_name;\n }\n \n-void WindowNode::updateTreeHashImpl(HashState & hash_state) const\n+void WindowNode::updateTreeHashImpl(HashState & hash_state, CompareOptions) const\n {\n     hash_state.update(window_frame.is_default);\n     hash_state.update(window_frame.type);\ndiff --git a/src/Analyzer/WindowNode.h b/src/Analyzer/WindowNode.h\nindex 30e1128b93c7..febbc02bedce 100644\n--- a/src/Analyzer/WindowNode.h\n+++ b/src/Analyzer/WindowNode.h\n@@ -169,9 +169,9 @@ class WindowNode final : public IQueryTreeNode\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\n-    bool isEqualImpl(const IQueryTreeNode & rhs) const override;\n+    bool isEqualImpl(const IQueryTreeNode & rhs, CompareOptions) const override;\n \n-    void updateTreeHashImpl(HashState & hash_state) const override;\n+    void updateTreeHashImpl(HashState & hash_state, CompareOptions) const override;\n \n     QueryTreeNodePtr cloneImpl() const override;\n \n",
  "test_patch": "diff --git a/src/Analyzer/tests/gtest_query_tree_node.cpp b/src/Analyzer/tests/gtest_query_tree_node.cpp\nindex cf1ce78e4232..01556c9f9216 100644\n--- a/src/Analyzer/tests/gtest_query_tree_node.cpp\n+++ b/src/Analyzer/tests/gtest_query_tree_node.cpp\n@@ -22,12 +22,12 @@ class SourceNode final : public IQueryTreeNode\n     {\n     }\n \n-    bool isEqualImpl(const IQueryTreeNode &) const override\n+    bool isEqualImpl(const IQueryTreeNode &, CompareOptions) const override\n     {\n         return true;\n     }\n \n-    void updateTreeHashImpl(HashState &) const override\n+    void updateTreeHashImpl(HashState &, CompareOptions) const override\n     {\n     }\n \ndiff --git a/tests/queries/0_stateless/02802_with_cube_with_totals.reference b/tests/queries/0_stateless/02802_with_cube_with_totals.reference\nindex 206c32e562b0..c7b7b5704560 100644\n--- a/tests/queries/0_stateless/02802_with_cube_with_totals.reference\n+++ b/tests/queries/0_stateless/02802_with_cube_with_totals.reference\n@@ -1,35 +1,5 @@\n ((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n ((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n-((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n \n ((2147483648,(-0,1.1754943508222875e-38,2147483646,'-9223372036854775808',NULL)))\t0\n \\N\ndiff --git a/tests/queries/0_stateless/02802_with_cube_with_totals.sql b/tests/queries/0_stateless/02802_with_cube_with_totals.sql\nindex 168e4d61b681..77adb68eb4b7 100644\n--- a/tests/queries/0_stateless/02802_with_cube_with_totals.sql\n+++ b/tests/queries/0_stateless/02802_with_cube_with_totals.sql\n@@ -1,3 +1,2 @@\n-set allow_experimental_analyzer=1;\n SELECT tuple((2147483648, (-0., 1.1754943508222875e-38, 2147483646, '-9223372036854775808', NULL))), toInt128(0.0001) GROUP BY ((256, toInt64(1.1754943508222875e-38), NULL), NULL, -0., ((65535, '-92233720368547758.07'), 0.9999), tuple(((1., 3.4028234663852886e38, '1', 0.5), NULL, tuple('0.1')))) WITH CUBE WITH TOTALS;\n SELECT NULL GROUP BY toUUID(NULL, '0', NULL, '0.0000065535'), 1 WITH CUBE WITH TOTALS;\ndiff --git a/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.reference b/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.reference\nindex 4081b82a8f5f..17a17484a0cb 100644\n--- a/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.reference\n+++ b/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.reference\n@@ -60,3 +60,9 @@\n (7)\n (8)\n (9)\n+a\tb\n+a\tb\n+a\ta\n+a\ta\n+\n+a\ta\ndiff --git a/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.sql b/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.sql\nindex 012da5475817..687101375429 100644\n--- a/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.sql\n+++ b/tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.sql\n@@ -5,3 +5,19 @@ SELECT tuple(tuple(number)) as x FROM numbers(10) GROUP BY (number, tuple(number\n select tuple(array(number)) as x FROM numbers(10) GROUP BY number, array(number) WITH ROLLUP order by x;\n \n SELECT tuple(number) AS x FROM numbers(10) GROUP BY GROUPING SETS (number) order by x;\n+\n+SELECT ignore(toFixedString('Lambda as function parameter', 28), toNullable(28), ignore(8)), sum(marks) FROM system.parts WHERE database = currentDatabase() GROUP BY GROUPING SETS ((2)) FORMAT Null settings optimize_injective_functions_in_group_by=1, optimize_group_by_function_keys=1, group_by_use_nulls=1; -- { serverError ILLEGAL_AGGREGATION }\n+\n+SELECT toLowCardinality(materialize('a' AS key)),  'b' AS value GROUP BY key WITH CUBE SETTINGS group_by_use_nulls = 1;\n+\n+SELECT tuple(tuple(number)) AS x\n+FROM numbers(10)\n+GROUP BY (number, (toString(x), number))\n+    WITH CUBE\n+SETTINGS group_by_use_nulls = 1 FORMAT Null;\n+\n+SELECT tuple(number + 1) AS x FROM numbers(10) GROUP BY number + 1, toString(x) WITH CUBE settings group_by_use_nulls=1 FORMAT Null;\n+\n+SELECT tuple(tuple(number)) AS x FROM numbers(10) WHERE toString(toUUID(tuple(number), NULL), x) GROUP BY number, (toString(x), number) WITH CUBE SETTINGS group_by_use_nulls = 1 FORMAT Null;\n+\n+SELECT  materialize('a'), 'a' AS key GROUP BY key WITH CUBE WITH TOTALS SETTINGS group_by_use_nulls = 1;\n",
  "problem_statement": "LOGICAL_ERROR: Unexpected return type from materialize. Expected String. Got Nullable\n\r\n**Describe the bug**\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/62185/ccf0953d8013284815102643cb735d6151352c04/ast_fuzzer__asan_/fatal.log\r\n\r\n**How to reproduce**\r\n```\r\nSELECT materialize('a' AS key) GROUP BY key WITH CUBE SETTINGS group_by_use_nulls = 1;\r\n```\r\n**Note: it works without analyzer**\n",
  "hints_text": "",
  "created_at": "2024-04-03T11:51:27Z",
  "modified_files": [
    "src/Analyzer/ArrayJoinNode.cpp",
    "src/Analyzer/ArrayJoinNode.h",
    "src/Analyzer/ColumnNode.cpp",
    "src/Analyzer/ColumnNode.h",
    "src/Analyzer/ColumnTransformers.cpp",
    "src/Analyzer/ColumnTransformers.h",
    "src/Analyzer/ConstantNode.cpp",
    "src/Analyzer/ConstantNode.h",
    "src/Analyzer/ConstantValue.h",
    "src/Analyzer/FunctionNode.cpp",
    "src/Analyzer/FunctionNode.h",
    "src/Analyzer/HashUtils.h",
    "src/Analyzer/IQueryTreeNode.cpp",
    "src/Analyzer/IQueryTreeNode.h",
    "src/Analyzer/IdentifierNode.cpp",
    "src/Analyzer/IdentifierNode.h",
    "src/Analyzer/InterpolateNode.cpp",
    "src/Analyzer/InterpolateNode.h",
    "src/Analyzer/JoinNode.cpp",
    "src/Analyzer/JoinNode.h",
    "src/Analyzer/LambdaNode.cpp",
    "src/Analyzer/LambdaNode.h",
    "src/Analyzer/ListNode.cpp",
    "src/Analyzer/ListNode.h",
    "src/Analyzer/MatcherNode.cpp",
    "src/Analyzer/MatcherNode.h",
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Analyzer/QueryNode.cpp",
    "src/Analyzer/QueryNode.h",
    "src/Analyzer/SortNode.cpp",
    "src/Analyzer/SortNode.h",
    "src/Analyzer/TableFunctionNode.cpp",
    "src/Analyzer/TableFunctionNode.h",
    "src/Analyzer/TableNode.cpp",
    "src/Analyzer/TableNode.h",
    "src/Analyzer/UnionNode.cpp",
    "src/Analyzer/UnionNode.h",
    "src/Analyzer/WindowNode.cpp",
    "src/Analyzer/WindowNode.h"
  ],
  "modified_test_files": [
    "src/Analyzer/tests/gtest_query_tree_node.cpp",
    "tests/queries/0_stateless/02802_with_cube_with_totals.reference",
    "tests/queries/0_stateless/02802_with_cube_with_totals.sql",
    "tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.reference",
    "tests/queries/0_stateless/03023_group_by_use_nulls_analyzer_crashes.sql"
  ]
}