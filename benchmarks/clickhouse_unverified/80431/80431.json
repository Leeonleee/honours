{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80431,
  "instance_id": "ClickHouse__ClickHouse-80431",
  "issue_numbers": [
    "80429"
  ],
  "base_commit": "197719b8336befe74b40c415faf83dc98fc3b07f",
  "patch": "diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 9f365db6d73a..9db38a194322 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -6,7 +6,6 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeNullable.h>\n-#include <DataTypes/DataTypeObjectDeprecated.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeMap.h>\n@@ -509,7 +508,7 @@ QueryTreeNodePtr QueryAnalyzer::tryGetLambdaFromSQLUserDefinedFunctions(const st\n     auto result_node = buildQueryTree(create_function_query->function_core, context);\n     if (result_node->getNodeType() != QueryTreeNodeType::LAMBDA)\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n-            \"SQL user defined function {} must represent lambda expression. Actual {}\",\n+            \"SQL user defined function {} must represent lambda expression. Actual: {}\",\n             function_name,\n             create_function_query->function_core->formatForErrorMessage());\n \n@@ -543,7 +542,7 @@ void QueryAnalyzer::evaluateScalarSubqueryIfNeeded(QueryTreeNodePtr & node, Iden\n     auto * union_node = node->as<UnionNode>();\n     if (!query_node && !union_node)\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n-            \"Node must have query or union type. Actual {} {}\",\n+            \"Node must have query or union type. Actual: {} {}\",\n             node->getNodeTypeName(),\n             node->formatASTForErrorMessage());\n \n@@ -886,7 +885,7 @@ void QueryAnalyzer::convertLimitOffsetExpression(QueryTreeNodePtr & expression_n\n     const auto * limit_offset_constant_node = expression_node->as<ConstantNode>();\n     if (!limit_offset_constant_node || !isNativeNumber(removeNullable(limit_offset_constant_node->getResultType())))\n         throw Exception(ErrorCodes::INVALID_LIMIT_EXPRESSION,\n-            \"{} expression must be constant with numeric type. Actual {}. In scope {}\",\n+            \"{} expression must be constant with numeric type. Actual: {}. In scope {}\",\n             expression_description,\n             expression_node->formatASTForErrorMessage(),\n             scope.scope_node->formatASTForErrorMessage());\n@@ -1059,7 +1058,7 @@ void QueryAnalyzer::expandOrderByAll(QueryNode & query_tree_node_typed, const Se\n             auto projection_names = resolved_expression_it->second;\n             if (projection_names.size() != 1)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                                \"Expression nodes list expected 1 projection names. Actual {}\",\n+                                \"Expression nodes list expected 1 projection names. Actual: {}\",\n                                 projection_names.size());\n             if (boost::iequals(projection_names[0], \"all\"))\n                 throw Exception(ErrorCodes::UNEXPECTED_EXPRESSION,\n@@ -2050,7 +2049,7 @@ QueryAnalyzer::QueryTreeNodesWithNames QueryAnalyzer::resolveUnqualifiedMatcher(\n             size_t num_tables = cross_join_node->getTableExpressions().size();\n             if (stack_size < cross_join_node->getTableExpressions().size())\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Expected at least {} table expressions on stack before CROSS_JOIN processing. Actual {}\",\n+                    \"Expected at least {} table expressions on stack before CROSS_JOIN processing. Actual: {}\",\n                     num_tables,\n                     stack_size);\n \n@@ -2073,7 +2072,7 @@ QueryAnalyzer::QueryTreeNodesWithNames QueryAnalyzer::resolveUnqualifiedMatcher(\n             size_t table_expressions_column_nodes_with_names_stack_size = table_expressions_column_nodes_with_names_stack.size();\n             if (table_expressions_column_nodes_with_names_stack_size < 2)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Expected at least 2 table expressions on stack before JOIN processing. Actual {}\",\n+                    \"Expected at least 2 table expressions on stack before JOIN processing. Actual: {}\",\n                     table_expressions_column_nodes_with_names_stack_size);\n \n             auto right_table_expression_columns = std::move(table_expressions_column_nodes_with_names_stack.back());\n@@ -2333,7 +2332,7 @@ ProjectionNames QueryAnalyzer::resolveMatcher(QueryTreeNodePtr & matcher_node, I\n                 else\n                 {\n                     throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                        \"Unsupported apply matcher expression type. Expected lambda or function apply transformer. Actual {}. In scope {}\",\n+                        \"Unsupported apply matcher expression type. Expected lambda or function apply transformer. Actual: {}. In scope {}\",\n                         transformer->formatASTForErrorMessage(),\n                         scope.scope_node->formatASTForErrorMessage());\n                 }\n@@ -2401,7 +2400,7 @@ ProjectionNames QueryAnalyzer::resolveMatcher(QueryTreeNodePtr & matcher_node, I\n                 }\n \n                 if (node_projection_names.size() != 1)\n-                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Matcher node expected 1 projection name. Actual {}\", node_projection_names.size());\n+                    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Matcher node expected 1 projection name. Actual: {}\", node_projection_names.size());\n \n                 result_projection_names.back() = std::move(node_projection_names[0]);\n                 node_to_projection_name.emplace(node, result_projection_names.back());\n@@ -2445,7 +2444,7 @@ ProjectionNames QueryAnalyzer::resolveMatcher(QueryTreeNodePtr & matcher_node, I\n             default:\n             {\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Expected strict EXCEPT or REPLACE column transformer. Actual type {}. In scope {}\",\n+                    \"Expected strict EXCEPT or REPLACE column transformer. Actual: type {}. In scope {}\",\n                     toString(strict_transformer_type),\n                     scope.scope_node->formatASTForErrorMessage());\n             }\n@@ -2559,14 +2558,14 @@ ProjectionName QueryAnalyzer::resolveWindow(QueryTreeNodePtr & node, IdentifierR\n         const auto * window_frame_begin_constant_node = window_node.getFrameBeginOffsetNode()->as<ConstantNode>();\n         if (!window_frame_begin_constant_node || !isNativeNumber(removeNullable(window_frame_begin_constant_node->getResultType())))\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Window frame begin OFFSET expression must be constant with numeric type. Actual {}. In scope {}\",\n+                \"Window frame begin OFFSET expression must be constant with numeric type. Actual: {}. In scope {}\",\n                 window_node.getFrameBeginOffsetNode()->formatASTForErrorMessage(),\n                 scope.scope_node->formatASTForErrorMessage());\n \n         window_node.getWindowFrame().begin_offset = window_frame_begin_constant_node->getValue();\n         if (frame_begin_offset_projection_names.size() != 1)\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Window FRAME begin offset expected 1 projection name. Actual {}\",\n+                \"Window FRAME begin offset expected 1 projection name. Actual: {}\",\n                 frame_begin_offset_projection_names.size());\n     }\n \n@@ -2580,14 +2579,14 @@ ProjectionName QueryAnalyzer::resolveWindow(QueryTreeNodePtr & node, IdentifierR\n         const auto * window_frame_end_constant_node = window_node.getFrameEndOffsetNode()->as<ConstantNode>();\n         if (!window_frame_end_constant_node || !isNativeNumber(removeNullable(window_frame_end_constant_node->getResultType())))\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Window frame begin OFFSET expression must be constant with numeric type. Actual {}. In scope {}\",\n+                \"Window frame begin OFFSET expression must be constant with numeric type. Actual: {}. In scope {}\",\n                 window_node.getFrameEndOffsetNode()->formatASTForErrorMessage(),\n                 scope.scope_node->formatASTForErrorMessage());\n \n         window_node.getWindowFrame().end_offset = window_frame_end_constant_node->getValue();\n         if (frame_end_offset_projection_names.size() != 1)\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Window FRAME begin offset expected 1 projection name. Actual {}\",\n+                \"Window FRAME begin offset expected 1 projection name. Actual: {}\",\n                 frame_end_offset_projection_names.size());\n     }\n \n@@ -2651,7 +2650,7 @@ ProjectionNames QueryAnalyzer::resolveLambda(const QueryTreeNodePtr & lambda_nod\n     size_t arguments_size = lambda_arguments.size();\n     if (lambda_arguments_nodes_size != arguments_size)\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-            \"Lambda {} expect {} arguments. Actual {}. In scope {}\",\n+            \"Lambda {} expect {} arguments. Actual: {}. In scope {}\",\n             lambda_to_resolve.formatASTForErrorMessage(),\n             lambda_arguments_nodes_size,\n             arguments_size,\n@@ -2767,7 +2766,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n         const auto * constant_node = parameter_node->as<ConstantNode>();\n         if (!constant_node)\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-            \"Parameter for function '{}' expected to have constant value. Actual {}. In scope {}\",\n+            \"Parameter for function '{}' expected to have constant value. Actual: {}. In scope {}\",\n             function_name,\n             parameter_node->formatASTForErrorMessage(),\n             scope.scope_node->formatASTForErrorMessage());\n@@ -3224,7 +3223,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             auto * lambda_expression = lambda_expression_untyped->as<LambdaNode>();\n             if (!lambda_expression)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Function identifier '{}' must be resolved as lambda. Actual {}. In scope {}\",\n+                    \"Function identifier '{}' must be resolved as lambda. Actual: {}. In scope {}\",\n                     function_node.getFunctionName(),\n                     lambda_expression_untyped->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n@@ -3465,7 +3464,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             const auto * function_data_type = typeid_cast<const DataTypeFunction *>(argument_types[function_lambda_argument_index].get());\n             if (!function_data_type)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Function '{}' expected function data type for lambda argument with index {}. Actual {}. In scope {}\",\n+                    \"Function '{}' expected function data type for lambda argument with index {}. Actual: {}. In scope {}\",\n                     function_name,\n                     function_lambda_argument_index,\n                     argument_types[function_lambda_argument_index]->getName(),\n@@ -3477,7 +3476,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n                                 \"Function '{}\"\n                                 \"' function data type for lambda argument with index {} arguments size mismatch. \"\n-                                \"Actual {}. Expected {}. In scope {}\",\n+                                \"Actual: {}. Expected {}. In scope {}\",\n                                 function_name,\n                                 function_data_type_arguments_size,\n                                 lambda_arguments_size,\n@@ -3515,7 +3514,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n                 size_t lambda_projection_names_size =lambda_projection_names.size();\n                 if (lambda_projection_names_size != 1)\n                     throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                        \"Lambda argument inside function expected to have 1 projection name. Actual {}\",\n+                        \"Lambda argument inside function expected to have 1 projection name. Actual: {}\",\n                         lambda_projection_names_size);\n \n                 WriteBufferFromOwnString lambda_argument_projection_name_buffer;\n@@ -4067,7 +4066,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNodeList(\n \n         if (expression_node_projection_names.size() != expected_projection_names_size)\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Expression nodes list expected {} projection names. Actual {}\",\n+                \"Expression nodes list expected {} projection names. Actual: {}\",\n                 expected_projection_names_size,\n                 expression_node_projection_names.size());\n \n@@ -4116,7 +4115,7 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n         size_t sort_expression_projection_names_size = sort_expression_projection_names.size();\n         if (sort_expression_projection_names_size != 1)\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                \"Sort expression expected 1 projection name. Actual {}\",\n+                \"Sort expression expected 1 projection name. Actual: {}\",\n                 sort_expression_projection_names_size);\n \n         if (sort_node.hasFillFrom())\n@@ -4126,14 +4125,14 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n             const auto * constant_node = sort_node.getFillFrom()->as<ConstantNode>();\n             if (!constant_node || !isColumnedAsNumber(constant_node->getResultType()))\n                 throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                    \"Sort FILL FROM expression must be constant with numeric type. Actual {}. In scope {}\",\n+                    \"Sort FILL FROM expression must be constant with numeric type. Actual: {}. In scope {}\",\n                     sort_node.getFillFrom()->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n \n             size_t fill_from_expression_projection_names_size = fill_from_expression_projection_names.size();\n             if (fill_from_expression_projection_names_size != 1)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Sort node FILL FROM expression expected 1 projection name. Actual {}\",\n+                    \"Sort node FILL FROM expression expected 1 projection name. Actual: {}\",\n                     fill_from_expression_projection_names_size);\n         }\n \n@@ -4145,14 +4144,14 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n             if (!constant_node || !isColumnedAsNumber(constant_node->getResultType()))\n                 throw Exception(\n                     ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                    \"Sort FILL TO expression must be constant with numeric type. Actual {}. In scope {}\",\n+                    \"Sort FILL TO expression must be constant with numeric type. Actual: {}. In scope {}\",\n                     sort_node.getFillTo()->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n \n             size_t fill_to_expression_projection_names_size = fill_to_expression_projection_names.size();\n             if (fill_to_expression_projection_names_size != 1)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Sort node FILL TO expression expected 1 projection name. Actual {}\",\n+                    \"Sort node FILL TO expression expected 1 projection name. Actual: {}\",\n                     fill_to_expression_projection_names_size);\n         }\n \n@@ -4163,7 +4162,7 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n             const auto * constant_node = sort_node.getFillStep()->as<ConstantNode>();\n             if (!constant_node)\n                 throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                    \"Sort FILL STEP expression must be constant with numeric or interval type. Actual {}. In scope {}\",\n+                    \"Sort FILL STEP expression must be constant with numeric or interval type. Actual: {}. In scope {}\",\n                     sort_node.getFillStep()->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n \n@@ -4171,14 +4170,14 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n             bool is_interval = WhichDataType(constant_node->getResultType()).isInterval();\n             if (!is_number && !is_interval)\n                 throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                    \"Sort FILL STEP expression must be constant with numeric or interval type. Actual {}. In scope {}\",\n+                    \"Sort FILL STEP expression must be constant with numeric or interval type. Actual: {}. In scope {}\",\n                     sort_node.getFillStep()->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n \n             size_t fill_step_expression_projection_names_size = fill_step_expression_projection_names.size();\n             if (fill_step_expression_projection_names_size != 1)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Sort FILL STEP expression expected 1 projection name. Actual {}\",\n+                    \"Sort FILL STEP expression expected 1 projection name. Actual: {}\",\n                     fill_step_expression_projection_names_size);\n         }\n \n@@ -4189,7 +4188,7 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n             const auto * constant_node = sort_node.getFillStaleness()->as<ConstantNode>();\n             if (!constant_node)\n                 throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                    \"Sort FILL STALENESS expression must be constant with numeric or interval type. Actual {}. In scope {}\",\n+                    \"Sort FILL STALENESS expression must be constant with numeric or interval type. Actual: {}. In scope {}\",\n                     sort_node.getFillStaleness()->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n \n@@ -4197,14 +4196,14 @@ ProjectionNames QueryAnalyzer::resolveSortNodeList(QueryTreeNodePtr & sort_node_\n             bool is_interval = WhichDataType(constant_node->getResultType()).isInterval();\n             if (!is_number && !is_interval)\n                 throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                    \"Sort FILL STALENESS expression must be constant with numeric or interval type. Actual {}. In scope {}\",\n+                    \"Sort FILL STALENESS expression must be constant with numeric or interval type. Actual: {}. In scope {}\",\n                     sort_node.getFillStaleness()->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n \n             size_t fill_staleness_expression_projection_names_size = fill_staleness_expression_projection_names.size();\n             if (fill_staleness_expression_projection_names_size != 1)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Sort FILL STALENESS expression expected 1 projection name. Actual {}\",\n+                    \"Sort FILL STALENESS expression expected 1 projection name. Actual: {}\",\n                     fill_staleness_expression_projection_names_size);\n         }\n \n@@ -4545,7 +4544,7 @@ void QueryAnalyzer::initializeQueryJoinTreeNode(QueryTreeNodePtr & join_tree_nod\n             default:\n             {\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Query FROM section expected table, table function, query, UNION, ARRAY JOIN or JOIN. Actual {} {}. In scope {}\",\n+                    \"Query FROM section expected table, table function, query, UNION, ARRAY JOIN or JOIN. Actual: {} {}. In scope {}\",\n                     current_join_tree_node->getNodeTypeName(),\n                     current_join_tree_node->formatASTForErrorMessage(),\n                     scope.scope_node->formatASTForErrorMessage());\n@@ -4564,7 +4563,7 @@ void QueryAnalyzer::initializeTableExpressionData(const QueryTreeNodePtr & table\n \n     if (!table_node && !table_function_node && !query_node && !union_node)\n         throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-        \"Unexpected table expression. Expected table, table function, query or union node. Actual {}. In scope {}\",\n+        \"Unexpected table expression. Expected table, table function, query or union node. Actual: {}. In scope {}\",\n         table_expression_node->formatASTForErrorMessage(),\n         scope.scope_node->formatASTForErrorMessage());\n \n@@ -5097,7 +5096,7 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n \n             if (!is_array_type && !is_map_type)\n                 throw Exception(ErrorCodes::TYPE_MISMATCH,\n-                    \"ARRAY JOIN {} requires expression {} with Array or Map type. Actual {}. In scope {}\",\n+                    \"ARRAY JOIN {} requires expression {} with Array or Map type. Actual: {}. In scope {}\",\n                     array_join_node_typed.formatASTForErrorMessage(),\n                     expression->formatASTForErrorMessage(),\n                     result_type->getName(),\n@@ -5244,7 +5243,7 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS\n             auto * identifier_node = join_using_node->as<IdentifierNode>();\n             if (!identifier_node)\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"JOIN {} USING clause expected identifier. Actual {}\",\n+                    \"JOIN {} USING clause expected identifier. Actual: {}\",\n                     join_node_typed.formatASTForErrorMessage(),\n                     join_using_node->formatASTForErrorMessage());\n \n@@ -5445,7 +5444,7 @@ void QueryAnalyzer::resolveQueryJoinTreeNode(QueryTreeNodePtr & join_tree_node,\n         default:\n         {\n             throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Query FROM section expected table, table function, query, ARRAY JOIN or JOIN. Actual {}. In scope {}\",\n+                \"Query FROM section expected table, table function, query, ARRAY JOIN or JOIN. Actual: {}. In scope {}\",\n                 join_tree_node->formatASTForErrorMessage(),\n                 scope.scope_node->formatASTForErrorMessage());\n         }\ndiff --git a/src/Functions/UserDefined/UserDefinedSQLFunctionFactory.cpp b/src/Functions/UserDefined/UserDefinedSQLFunctionFactory.cpp\nindex 3dee7e5a61b1..76c234a35bec 100644\n--- a/src/Functions/UserDefined/UserDefinedSQLFunctionFactory.cpp\n+++ b/src/Functions/UserDefined/UserDefinedSQLFunctionFactory.cpp\n@@ -29,7 +29,7 @@ namespace ErrorCodes\n     extern const int FUNCTION_ALREADY_EXISTS;\n     extern const int CANNOT_DROP_FUNCTION;\n     extern const int CANNOT_CREATE_RECURSIVE_FUNCTION;\n-    extern const int UNSUPPORTED_METHOD;\n+    extern const int BAD_ARGUMENTS;\n }\n \n \n@@ -52,17 +52,17 @@ namespace\n         ASTFunction * lambda_function = function->as<ASTFunction>();\n \n         if (!lambda_function)\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Expected function, got: {}\", function->formatForErrorMessage());\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected function, got: {}\", function->formatForErrorMessage());\n \n         auto & lambda_function_expression_list = lambda_function->arguments->children;\n \n         if (lambda_function_expression_list.size() != 2)\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Lambda must have arguments and body\");\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Lambda must have arguments and body\");\n \n         const ASTFunction * tuple_function_arguments = lambda_function_expression_list[0]->as<ASTFunction>();\n \n-        if (!tuple_function_arguments || !tuple_function_arguments->arguments)\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Lambda must have valid arguments\");\n+        if (!tuple_function_arguments || !tuple_function_arguments->arguments || tuple_function_arguments->name != \"tuple\")\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Lambda must have valid arguments\");\n \n         std::unordered_set<String> arguments;\n \n@@ -71,17 +71,17 @@ namespace\n             const auto * argument_identifier = argument->as<ASTIdentifier>();\n \n             if (!argument_identifier)\n-                throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Lambda argument must be identifier\");\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Lambda argument must be identifier\");\n \n             const auto & argument_name = argument_identifier->name();\n             auto [_, inserted] = arguments.insert(argument_name);\n             if (!inserted)\n-                throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Identifier {} already used as function parameter\", argument_name);\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Identifier {} already used as function parameter\", argument_name);\n         }\n \n         ASTPtr function_body = lambda_function_expression_list[1];\n         if (!function_body)\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Lambda must have valid function body\");\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Lambda must have valid function body\");\n \n         validateFunctionRecursiveness(*function_body, name);\n     }\ndiff --git a/src/Parsers/ParserCreateFunctionQuery.cpp b/src/Parsers/ParserCreateFunctionQuery.cpp\nindex b912016a4391..dc360e69a77a 100644\n--- a/src/Parsers/ParserCreateFunctionQuery.cpp\n+++ b/src/Parsers/ParserCreateFunctionQuery.cpp\n@@ -1,8 +1,6 @@\n #include <Parsers/ParserCreateFunctionQuery.h>\n \n #include <Parsers/ASTCreateFunctionQuery.h>\n-#include <Parsers/ASTExpressionList.h>\n-#include <Parsers/ASTIdentifier.h>\n #include <Parsers/CommonParsers.h>\n #include <Parsers/ExpressionElementParsers.h>\n #include <Parsers/ExpressionListParsers.h>\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02181_sql_user_defined_functions_invalid_lambda.sql b/tests/queries/0_stateless/02181_sql_user_defined_functions_invalid_lambda.sql\nindex 115f3b2f9c06..79cc8fd906a0 100644\n--- a/tests/queries/0_stateless/02181_sql_user_defined_functions_invalid_lambda.sql\n+++ b/tests/queries/0_stateless/02181_sql_user_defined_functions_invalid_lambda.sql\n@@ -1,4 +1,4 @@\n-CREATE FUNCTION 02181_invalid_lambda AS lambda(((x * 2) AS x_doubled) + x_doubled); --{serverError UNSUPPORTED_METHOD}\n-CREATE FUNCTION 02181_invalid_lambda AS lambda(x); --{serverError UNSUPPORTED_METHOD}\n-CREATE FUNCTION 02181_invalid_lambda AS lambda(); --{serverError UNSUPPORTED_METHOD}\n-CREATE FUNCTION 02181_invalid_lambda AS lambda(tuple(x)) --{serverError UNSUPPORTED_METHOD}\n+CREATE FUNCTION 02181_invalid_lambda AS lambda(((x * 2) AS x_doubled) + x_doubled); --{serverError BAD_ARGUMENTS}\n+CREATE FUNCTION 02181_invalid_lambda AS lambda(x); --{serverError BAD_ARGUMENTS}\n+CREATE FUNCTION 02181_invalid_lambda AS lambda(); --{serverError BAD_ARGUMENTS}\n+CREATE FUNCTION 02181_invalid_lambda AS lambda(tuple(x)) --{serverError BAD_ARGUMENTS}\ndiff --git a/tests/queries/0_stateless/02292_create_function_validate.sql b/tests/queries/0_stateless/02292_create_function_validate.sql\nindex a1f0afe055e9..56b546789868 100644\n--- a/tests/queries/0_stateless/02292_create_function_validate.sql\n+++ b/tests/queries/0_stateless/02292_create_function_validate.sql\n@@ -1,1 +1,1 @@\n-create function foo as x -- { serverError UNSUPPORTED_METHOD }\n+create function foo as x -- { serverError BAD_ARGUMENTS }\ndiff --git a/tests/queries/0_stateless/03518_bad_sql_udf.reference b/tests/queries/0_stateless/03518_bad_sql_udf.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03518_bad_sql_udf.sql b/tests/queries/0_stateless/03518_bad_sql_udf.sql\nnew file mode 100644\nindex 000000000000..2c60941d0768\n--- /dev/null\n+++ b/tests/queries/0_stateless/03518_bad_sql_udf.sql\n@@ -0,0 +1,1 @@\n+CREATE OR REPLACE FUNCTION 03518_bad_sql_udf AS lambda(identity(x), x); -- { serverError BAD_ARGUMENTS }\n",
  "problem_statement": "Logical error: SQL user defined function ... must represent lambda expression\n### Describe the bug\n\n`Code: 49. DB::Exception: SQL user defined function f must represent lambda expression. Actual lambda(identity(x), x). (LOGICAL_ERROR)`\n\n### How to reproduce\n\n`ch \"CREATE FUNCTION f AS lambda(identity(x), x); f(1)\"`\n\n### Error message and/or stacktrace\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-05-19T01:25:05Z",
  "modified_files": [
    "src/Analyzer/Resolve/QueryAnalyzer.cpp",
    "src/Functions/UserDefined/UserDefinedSQLFunctionFactory.cpp",
    "src/Parsers/ParserCreateFunctionQuery.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02181_sql_user_defined_functions_invalid_lambda.sql",
    "tests/queries/0_stateless/02292_create_function_validate.sql",
    "b/tests/queries/0_stateless/03518_bad_sql_udf.sql"
  ]
}