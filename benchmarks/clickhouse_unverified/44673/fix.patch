diff --git a/src/Processors/QueryPlan/CreatingSetsStep.h b/src/Processors/QueryPlan/CreatingSetsStep.h
index 9995af7bca7d..b4777578a30f 100644
--- a/src/Processors/QueryPlan/CreatingSetsStep.h
+++ b/src/Processors/QueryPlan/CreatingSetsStep.h
@@ -44,9 +44,6 @@ class CreatingSetsStep : public IQueryPlanStep
     QueryPipelineBuilderPtr updatePipeline(QueryPipelineBuilders pipelines, const BuildQueryPipelineSettings &) override;
 
     void describePipeline(FormatSettings & settings) const override;
-
-private:
-    Processors processors;
 };
 
 void addCreatingSetsStep(QueryPlan & query_plan, PreparedSets::SubqueriesForSets subqueries_for_sets, ContextPtr context);
diff --git a/src/Processors/QueryPlan/IQueryPlanStep.cpp b/src/Processors/QueryPlan/IQueryPlanStep.cpp
index b36d1f0e12fc..a0035089c293 100644
--- a/src/Processors/QueryPlan/IQueryPlanStep.cpp
+++ b/src/Processors/QueryPlan/IQueryPlanStep.cpp
@@ -113,4 +113,9 @@ void IQueryPlanStep::describePipeline(const Processors & processors, FormatSetti
         doDescribeProcessor(*prev, count, settings);
 }
 
+void IQueryPlanStep::appendExtraProcessors(const Processors & extra_processors)
+{
+    processors.insert(processors.end(), extra_processors.begin(), extra_processors.end());
+}
+
 }
diff --git a/src/Processors/QueryPlan/IQueryPlanStep.h b/src/Processors/QueryPlan/IQueryPlanStep.h
index 1e00d76b66f7..316ecff9c2e3 100644
--- a/src/Processors/QueryPlan/IQueryPlanStep.h
+++ b/src/Processors/QueryPlan/IQueryPlanStep.h
@@ -110,6 +110,9 @@ class IQueryPlanStep
     /// Get description of processors added in current step. Should be called after updatePipeline().
     virtual void describePipeline(FormatSettings & /*settings*/) const {}
 
+    /// Append extra processors for this step.
+    void appendExtraProcessors(const Processors & extra_processors);
+
 protected:
     DataStreams input_streams;
     std::optional<DataStream> output_stream;
@@ -117,6 +120,10 @@ class IQueryPlanStep
     /// Text description about what current step does.
     std::string step_description;
 
+    /// This field is used to store added processors from this step.
+    /// It is used only for introspection (EXPLAIN PIPELINE).
+    Processors processors;
+
     static void describePipeline(const Processors & processors, FormatSettings & settings);
 };
 
diff --git a/src/Processors/QueryPlan/ISourceStep.h b/src/Processors/QueryPlan/ISourceStep.h
index 08c939b626d3..744b6f9b5c4a 100644
--- a/src/Processors/QueryPlan/ISourceStep.h
+++ b/src/Processors/QueryPlan/ISourceStep.h
@@ -15,10 +15,6 @@ class ISourceStep : public IQueryPlanStep
     virtual void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings & settings) = 0;
 
     void describePipeline(FormatSettings & settings) const override;
-
-protected:
-    /// We collect processors got after pipeline transformation.
-    Processors processors;
 };
 
 }
diff --git a/src/Processors/QueryPlan/ITransformingStep.cpp b/src/Processors/QueryPlan/ITransformingStep.cpp
index 64ad2ec56260..195fa9ad68cb 100644
--- a/src/Processors/QueryPlan/ITransformingStep.cpp
+++ b/src/Processors/QueryPlan/ITransformingStep.cpp
@@ -70,9 +70,4 @@ void ITransformingStep::describePipeline(FormatSettings & settings) const
     IQueryPlanStep::describePipeline(processors, settings);
 }
 
-void ITransformingStep::appendExtraProcessors(const Processors & extra_processors)
-{
-    processors.insert(processors.end(), extra_processors.begin(), extra_processors.end());
-}
-
 }
diff --git a/src/Processors/QueryPlan/ITransformingStep.h b/src/Processors/QueryPlan/ITransformingStep.h
index 8b16e982af51..1513b4307f8e 100644
--- a/src/Processors/QueryPlan/ITransformingStep.h
+++ b/src/Processors/QueryPlan/ITransformingStep.h
@@ -75,9 +75,6 @@ class ITransformingStep : public IQueryPlanStep
 
     void describePipeline(FormatSettings & settings) const override;
 
-    /// Append extra processors for this step.
-    void appendExtraProcessors(const Processors & extra_processors);
-
     /// Enforcement is supposed to be done through the special settings that will be taken into account by remote nodes during query planning (e.g. force_aggregation_in_order).
     /// Should be called only if data_stream_traits.can_enforce_sorting_properties_in_distributed_query == true.
     virtual void adjustSettingsToEnforceSortingPropertiesInDistributedQuery(ContextMutablePtr) const
@@ -100,8 +97,7 @@ class ITransformingStep : public IQueryPlanStep
 private:
     virtual void updateOutputStream() = 0;
 
-    /// We collect processors got after pipeline transformation.
-    Processors processors;
+    /// If we should collect processors got after pipeline transformation.
     bool collect_processors;
 
     const DataStreamTraits data_stream_traits;
diff --git a/src/Processors/QueryPlan/IntersectOrExceptStep.cpp b/src/Processors/QueryPlan/IntersectOrExceptStep.cpp
index c031303cc7f7..afdff44020f5 100644
--- a/src/Processors/QueryPlan/IntersectOrExceptStep.cpp
+++ b/src/Processors/QueryPlan/IntersectOrExceptStep.cpp
@@ -42,10 +42,10 @@ IntersectOrExceptStep::IntersectOrExceptStep(
 QueryPipelineBuilderPtr IntersectOrExceptStep::updatePipeline(QueryPipelineBuilders pipelines, const BuildQueryPipelineSettings &)
 {
     auto pipeline = std::make_unique<QueryPipelineBuilder>();
-    QueryPipelineProcessorsCollector collector(*pipeline, this);
 
     if (pipelines.empty())
     {
+        QueryPipelineProcessorsCollector collector(*pipeline, this);
         pipeline->init(Pipe(std::make_shared<NullSource>(output_stream->header)));
         processors = collector.detachProcessors();
         return pipeline;
@@ -56,6 +56,7 @@ QueryPipelineBuilderPtr IntersectOrExceptStep::updatePipeline(QueryPipelineBuild
         /// Just in case.
         if (!isCompatibleHeader(cur_pipeline->getHeader(), getOutputStream().header))
         {
+            QueryPipelineProcessorsCollector collector(*cur_pipeline, this);
             auto converting_dag = ActionsDAG::makeConvertingActions(
                 cur_pipeline->getHeader().getColumnsWithTypeAndName(),
                 getOutputStream().header.getColumnsWithTypeAndName(),
@@ -66,16 +67,20 @@ QueryPipelineBuilderPtr IntersectOrExceptStep::updatePipeline(QueryPipelineBuild
             {
                 return std::make_shared<ExpressionTransform>(cur_header, converting_actions);
             });
+
+            auto added_processors = collector.detachProcessors();
+            processors.insert(processors.end(), added_processors.begin(), added_processors.end());
         }
 
         /// For the case of union.
         cur_pipeline->addTransform(std::make_shared<ResizeProcessor>(header, cur_pipeline->getNumStreams(), 1));
     }
 
-    *pipeline = QueryPipelineBuilder::unitePipelines(std::move(pipelines), max_threads);
-    pipeline->addTransform(std::make_shared<IntersectOrExceptTransform>(header, current_operator));
+    *pipeline = QueryPipelineBuilder::unitePipelines(std::move(pipelines), max_threads, &processors);
+    auto transform = std::make_shared<IntersectOrExceptTransform>(header, current_operator);
+    processors.push_back(transform);
+    pipeline->addTransform(std::move(transform));
 
-    processors = collector.detachProcessors();
     return pipeline;
 }
 
diff --git a/src/Processors/QueryPlan/IntersectOrExceptStep.h b/src/Processors/QueryPlan/IntersectOrExceptStep.h
index d7eab574431d..d15d2802456a 100644
--- a/src/Processors/QueryPlan/IntersectOrExceptStep.h
+++ b/src/Processors/QueryPlan/IntersectOrExceptStep.h
@@ -24,7 +24,6 @@ class IntersectOrExceptStep : public IQueryPlanStep
     Block header;
     Operator current_operator;
     size_t max_threads;
-    Processors processors;
 };
 
 }
diff --git a/src/Processors/QueryPlan/JoinStep.h b/src/Processors/QueryPlan/JoinStep.h
index fc7f74d4fe8d..a814d541574f 100644
--- a/src/Processors/QueryPlan/JoinStep.h
+++ b/src/Processors/QueryPlan/JoinStep.h
@@ -37,7 +37,6 @@ class JoinStep : public IQueryPlanStep
     size_t max_block_size;
     size_t max_streams;
     bool keep_left_read_in_order;
-    Processors processors;
 };
 
 /// Special step for the case when Join is already filled.
diff --git a/src/Processors/QueryPlan/UnionStep.cpp b/src/Processors/QueryPlan/UnionStep.cpp
index 6290c7417dbc..e111890a8332 100644
--- a/src/Processors/QueryPlan/UnionStep.cpp
+++ b/src/Processors/QueryPlan/UnionStep.cpp
@@ -62,10 +62,10 @@ void UnionStep::updateOutputSortDescription()
 QueryPipelineBuilderPtr UnionStep::updatePipeline(QueryPipelineBuilders pipelines, const BuildQueryPipelineSettings &)
 {
     auto pipeline = std::make_unique<QueryPipelineBuilder>();
-    QueryPipelineProcessorsCollector collector(*pipeline, this);
 
     if (pipelines.empty())
     {
+        QueryPipelineProcessorsCollector collector(*pipeline, this);
         pipeline->init(Pipe(std::make_shared<NullSource>(output_stream->header)));
         processors = collector.detachProcessors();
         return pipeline;
@@ -80,6 +80,7 @@ QueryPipelineBuilderPtr UnionStep::updatePipeline(QueryPipelineBuilders pipeline
         /// But, just in case, convert it to the same header if not.
         if (!isCompatibleHeader(cur_pipeline->getHeader(), getOutputStream().header))
         {
+            QueryPipelineProcessorsCollector collector(*cur_pipeline, this);
             auto converting_dag = ActionsDAG::makeConvertingActions(
                 cur_pipeline->getHeader().getColumnsWithTypeAndName(),
                 getOutputStream().header.getColumnsWithTypeAndName(),
@@ -90,12 +91,13 @@ QueryPipelineBuilderPtr UnionStep::updatePipeline(QueryPipelineBuilders pipeline
             {
                 return std::make_shared<ExpressionTransform>(cur_header, converting_actions);
             });
+
+            auto added_processors = collector.detachProcessors();
+            processors.insert(processors.end(), added_processors.begin(), added_processors.end());
         }
     }
 
-    *pipeline = QueryPipelineBuilder::unitePipelines(std::move(pipelines), max_threads);
-
-    processors = collector.detachProcessors();
+    *pipeline = QueryPipelineBuilder::unitePipelines(std::move(pipelines), max_threads, &processors);
     return pipeline;
 }
 
diff --git a/src/Processors/QueryPlan/UnionStep.h b/src/Processors/QueryPlan/UnionStep.h
index a5a2f6b356e4..6278de076730 100644
--- a/src/Processors/QueryPlan/UnionStep.h
+++ b/src/Processors/QueryPlan/UnionStep.h
@@ -24,7 +24,6 @@ class UnionStep : public IQueryPlanStep
 private:
     Block header;
     size_t max_threads;
-    Processors processors;
 };
 
 }
diff --git a/src/QueryPipeline/QueryPipelineBuilder.cpp b/src/QueryPipeline/QueryPipelineBuilder.cpp
index 626296834a24..a3b3438306eb 100644
--- a/src/QueryPipeline/QueryPipelineBuilder.cpp
+++ b/src/QueryPipeline/QueryPipelineBuilder.cpp
@@ -309,6 +309,7 @@ QueryPipelineBuilder QueryPipelineBuilder::unitePipelines(
         pipeline.limitMaxThreads(max_threads_limit);
     }
 
+    pipeline.setCollectedProcessors(nullptr);
     return pipeline;
 }
 
@@ -384,11 +385,7 @@ std::unique_ptr<QueryPipelineBuilder> QueryPipelineBuilder::joinPipelinesRightLe
     /// Collect the NEW processors for the right pipeline.
     QueryPipelineProcessorsCollector collector(*right);
     /// Remember the last step of the right pipeline.
-    ExpressionStep * step = typeid_cast<ExpressionStep *>(right->pipe.processors->back()->getQueryPlanStep());
-    if (!step)
-    {
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "The top step of the right pipeline should be ExpressionStep");
-    }
+    IQueryPlanStep * step = right->pipe.processors->back()->getQueryPlanStep();
 
     /// In case joined subquery has totals, and we don't, add default chunk to totals.
     bool default_totals = false;
@@ -560,7 +557,8 @@ std::unique_ptr<QueryPipelineBuilder> QueryPipelineBuilder::joinPipelinesRightLe
 
     /// Move the collected processors to the last step in the right pipeline.
     Processors processors = collector.detachProcessors();
-    step->appendExtraProcessors(processors);
+    if (step)
+        step->appendExtraProcessors(processors);
 
     left->pipe.processors->insert(left->pipe.processors->end(), right->pipe.processors->begin(), right->pipe.processors->end());
     left->resources = std::move(right->resources);
