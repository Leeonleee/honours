diff --git a/programs/main.cpp b/programs/main.cpp
index 9ad8b016c824..65fcfb8fadf7 100644
--- a/programs/main.cpp
+++ b/programs/main.cpp
@@ -491,9 +491,13 @@ int main(int argc_, char ** argv_)
     ///     clickhouse -q 'select 1' # use local
     ///     clickhouse # spawn local
     ///     clickhouse local # spawn local
+    ///     clickhouse "select ..." # spawn local
     ///
-    if (main_func == printHelp && !argv.empty() && (argv.size() == 1 || argv[1][0] == '-'))
+    if (main_func == printHelp && !argv.empty() && (argv.size() == 1 || argv[1][0] == '-'
+        || std::string_view(argv[1]).contains(' ')))
+    {
         main_func = mainEntryClickHouseLocal;
+    }
 
     int exit_code = main_func(static_cast<int>(argv.size()), argv.data());
 
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index bd4430648c58..46887d6cefed 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -2909,8 +2909,29 @@ void ClientBase::parseAndCheckOptions(OptionsDescription & options_description,
     }
 
     /// Check positional options.
-    if (std::ranges::count_if(parsed.options, [](const auto & op){ return !op.unregistered && op.string_key.empty() && !op.original_tokens[0].starts_with("--"); }) > 1)
-        throw Exception(ErrorCodes::BAD_ARGUMENTS, "Positional options are not supported.");
+    for (const auto & op : parsed.options)
+    {
+        if (!op.unregistered && op.string_key.empty() && !op.original_tokens[0].starts_with("--")
+            && !op.original_tokens[0].empty() && !op.value.empty())
+        {
+            /// Two special cases for better usability:
+            /// - if the option contains a whitespace, it might be a query: clickhouse "SELECT 1"
+            /// These are relevant for interactive usage - user-friendly, but questionable in general.
+            /// In case of ambiguity or for scripts, prefer using proper options.
+
+            const auto & token = op.original_tokens[0];
+            po::variable_value value(boost::any(op.value), false);
+
+            const char * option;
+            if (token.contains(' '))
+                option = "query";
+            else
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Positional option `{}` is not supported.", token);
+
+            if (!options.emplace(option, value).second)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Positional option `{}` is not supported.", token);
+        }
+    }
 
     po::store(parsed, options);
 }
