diff --git a/docs/en/sql-reference/functions/ip-address-functions.md b/docs/en/sql-reference/functions/ip-address-functions.md
index 469a66d460fa..cf3f92580aa8 100644
--- a/docs/en/sql-reference/functions/ip-address-functions.md
+++ b/docs/en/sql-reference/functions/ip-address-functions.md
@@ -13,10 +13,18 @@ Alias: `INET_NTOA`.
 
 ## IPv4StringToNum(s) {#ipv4stringtonums}
 
-The reverse function of IPv4NumToString. If the IPv4 address has an invalid format, it returns 0.
+The reverse function of IPv4NumToString. If the IPv4 address has an invalid format, it throws exception.
 
 Alias: `INET_ATON`.
 
+## IPv4StringToNumOrDefault(s) {#ipv4stringtonums}
+
+Same as `IPv4StringToNum`, but if the IPv4 address has an invalid format, it returns 0.
+
+## IPv4StringToNumOrNull(s) {#ipv4stringtonums}
+
+Same as `IPv4StringToNum`, but if the IPv4 address has an invalid format, it returns null.
+
 ## IPv4NumToStringClassC(num) {#ipv4numtostringclasscnum}
 
 Similar to IPv4NumToString, but using xxx instead of the last octet.
@@ -123,7 +131,7 @@ LIMIT 10
 
 ## IPv6StringToNum {#ipv6stringtonums}
 
-The reverse function of [IPv6NumToString](#ipv6numtostringx). If the IPv6 address has an invalid format, it returns a string of null bytes.
+The reverse function of [IPv6NumToString](#ipv6numtostringx). If the IPv6 address has an invalid format, it throws exception.
 
 If the input string contains a valid IPv4 address, returns its IPv6 equivalent.
 HEX can be uppercase or lowercase.
@@ -168,6 +176,14 @@ Result:
 
 -   [cutIPv6](#cutipv6x-bytestocutforipv6-bytestocutforipv4).
 
+## IPv6StringToNumOrDefault(s) {#ipv6stringtonums}
+
+Same as `IPv6StringToNum`, but if the IPv6 address has an invalid format, it returns 0.
+
+## IPv6StringToNumOrNull(s) {#ipv6stringtonums}
+
+Same as `IPv6StringToNum`, but if the IPv6 address has an invalid format, it returns null.
+
 ## IPv4ToIPv6(x) {#ipv4toipv6x}
 
 Takes a `UInt32` number. Interprets it as an IPv4 address in [big endian](https://en.wikipedia.org/wiki/Endianness). Returns a `FixedString(16)` value containing the IPv6 address in binary format. Examples:
@@ -261,6 +277,14 @@ SELECT
 └───────────────────────────────────┴──────────────────────────┘
 ```
 
+## toIPv4OrDefault(string) {#toipv4ordefaultstring}
+
+Same as `toIPv4`, but if the IPv4 address has an invalid format, it returns 0.
+
+## toIPv4OrNull(string) {#toipv4ornullstring}
+
+Same as `toIPv4`, but if the IPv4 address has an invalid format, it returns null.
+
 ## toIPv6 {#toipv6string}
 
 Converts a string form of IPv6 address to [IPv6](../../sql-reference/data-types/domains/ipv6.md) type. If the IPv6 address has an invalid format, returns an empty value.
@@ -317,6 +341,14 @@ Result:
 └─────────────────────┘
 ```
 
+## IPv6StringToNumOrDefault(s) {#toipv6ordefaultstring}
+
+Same as `toIPv6`, but if the IPv6 address has an invalid format, it returns 0.
+
+## IPv6StringToNumOrNull(s) {#toipv6ornullstring}
+
+Same as `toIPv6`, but if the IPv6 address has an invalid format, it returns null.
+
 ## isIPv4String {#isipv4string}
 
 Determines whether the input string is an IPv4 address or not. If `string` is IPv6 address returns `0`.
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 15ae646ab378..42a3f3797ff8 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -471,6 +471,7 @@ class IColumn;
     M(Bool, allow_experimental_geo_types, false, "Allow geo data types such as Point, Ring, Polygon, MultiPolygon", 0) \
     M(Bool, data_type_default_nullable, false, "Data types without NULL or NOT NULL will make Nullable", 0) \
     M(Bool, cast_keep_nullable, false, "CAST operator keep Nullable for result data type", 0) \
+    M(Bool, cast_ipv4_ipv6_default_on_conversion_error, false, "CAST operator into IPv4, CAST operator into IPV6 type, toIPv4, toIPv6 functions will return default value instead of throwing exception on conversion error.", 0) \
     M(Bool, alter_partition_verbose_result, false, "Output information about affected parts. Currently works only for FREEZE and ATTACH commands.", 0) \
     M(Bool, allow_experimental_database_materialized_mysql, false, "Allow to create database with Engine=MaterializedMySQL(...).", 0) \
     M(Bool, allow_experimental_database_materialized_postgresql, false, "Allow to create database with Engine=MaterializedPostgreSQL(...).", 0) \
diff --git a/src/Functions/CastOverloadResolver.h b/src/Functions/CastOverloadResolver.h
index ffd5dda4af34..cff17d810feb 100644
--- a/src/Functions/CastOverloadResolver.h
+++ b/src/Functions/CastOverloadResolver.h
@@ -33,22 +33,27 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver
 
     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
 
-    explicit CastOverloadResolverImpl(std::optional<Diagnostic> diagnostic_, bool keep_nullable_)
-        : diagnostic(std::move(diagnostic_)), keep_nullable(keep_nullable_)
+    explicit CastOverloadResolverImpl(std::optional<Diagnostic> diagnostic_, bool keep_nullable_, bool cast_ipv4_ipv6_default_on_conversion_error_)
+        : diagnostic(std::move(diagnostic_))
+        , keep_nullable(keep_nullable_)
+        , cast_ipv4_ipv6_default_on_conversion_error(cast_ipv4_ipv6_default_on_conversion_error_)
     {
     }
 
     static FunctionOverloadResolverPtr create(ContextPtr context)
     {
+        const auto & settings_ref = context->getSettingsRef();
+
         if constexpr (internal)
-            return createImpl();
-        return createImpl({}, context->getSettingsRef().cast_keep_nullable);
+            return createImpl({}, false /*keep_nullable*/, false /*cast_ipv4_ipv6_default_on_conversion_error*/);
+
+        return createImpl({}, settings_ref.cast_keep_nullable, settings_ref.cast_ipv4_ipv6_default_on_conversion_error);
     }
 
-    static FunctionOverloadResolverPtr createImpl(std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false)
+    static FunctionOverloadResolverPtr createImpl(std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false, bool cast_ipv4_ipv6_default_on_conversion_error = false)
     {
         assert(!internal || !keep_nullable);
-        return std::make_unique<CastOverloadResolverImpl>(std::move(diagnostic), keep_nullable);
+        return std::make_unique<CastOverloadResolverImpl>(std::move(diagnostic), keep_nullable, cast_ipv4_ipv6_default_on_conversion_error);
     }
 
 protected:
@@ -61,7 +66,7 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver
             data_types[i] = arguments[i].type;
 
         auto monotonicity = MonotonicityHelper::getMonotonicityInformation(arguments.front().type, return_type.get());
-        return std::make_unique<FunctionCast<FunctionName>>(name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);
+        return std::make_unique<FunctionCast<FunctionName>>(name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type, cast_ipv4_ipv6_default_on_conversion_error);
     }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
@@ -98,6 +103,7 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver
 private:
     std::optional<Diagnostic> diagnostic;
     bool keep_nullable;
+    bool cast_ipv4_ipv6_default_on_conversion_error;
 };
 
 
@@ -115,7 +121,10 @@ struct CastInternalOverloadName
     static constexpr auto accurate_cast_or_null_name = "accurate_CastOrNull";
 };
 
-template <CastType cast_type> using CastOverloadResolver = CastOverloadResolverImpl<cast_type, false, CastOverloadName, CastName>;
-template <CastType cast_type> using CastInternalOverloadResolver = CastOverloadResolverImpl<cast_type, true, CastInternalOverloadName, CastInternalName>;
+template <CastType cast_type>
+using CastOverloadResolver = CastOverloadResolverImpl<cast_type, false, CastOverloadName, CastName>;
+
+template <CastType cast_type>
+using CastInternalOverloadResolver = CastOverloadResolverImpl<cast_type, true, CastInternalOverloadName, CastInternalName>;
 
 }
diff --git a/src/Functions/FunctionsCodingIP.cpp b/src/Functions/FunctionsCodingIP.cpp
index 3e7c8bff4d5d..de814529d033 100644
--- a/src/Functions/FunctionsCodingIP.cpp
+++ b/src/Functions/FunctionsCodingIP.cpp
@@ -2,12 +2,15 @@
 #pragma clang diagnostic ignored "-Wreserved-identifier"
 #endif
 
+#include <Functions/FunctionsCodingIP.h>
+
 #include <Columns/ColumnArray.h>
 #include <Columns/ColumnConst.h>
 #include <Columns/ColumnFixedString.h>
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnTuple.h>
 #include <Columns/ColumnsNumber.h>
+#include <Columns/ColumnNullable.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeFactory.h>
 #include <DataTypes/DataTypeFixedString.h>
@@ -17,7 +20,7 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
 #include <Functions/IFunction.h>
-#include <Interpreters/Context_fwd.h>
+#include <Interpreters/Context.h>
 #include <IO/WriteHelpers.h>
 #include <Common/IPv6ToBinary.h>
 #include <Common/formatIPv6.h>
@@ -239,17 +242,19 @@ class FunctionCutIPv6 : public IFunction
     }
 };
 
-
+template <IPStringToNumExceptionMode exception_mode>
 class FunctionIPv6StringToNum : public IFunction
 {
 public:
-    static constexpr auto name = "IPv6StringToNum";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv6StringToNum>(); }
+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw
+        ? "IPv6StringToNum"
+        : (exception_mode == IPStringToNumExceptionMode::Default ? "IPv6StringToNumOrDefault" : "IPv6StringToNumOrNull");
+
+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionIPv6StringToNum>(context); }
 
-    static inline bool tryParseIPv4(const char * pos)
+    explicit FunctionIPv6StringToNum(ContextPtr context)
+        : cast_ipv4_ipv6_default_on_conversion_error(context->getSettingsRef().cast_ipv4_ipv6_default_on_conversion_error)
     {
-        UInt32 result = 0;
-        return DB::parseIPv4(pos, reinterpret_cast<unsigned char *>(&result));
     }
 
     String getName() const override { return name; }
@@ -258,62 +263,43 @@ class FunctionIPv6StringToNum : public IFunction
 
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
 
+    bool useDefaultImplementationForConstants() const override { return true; }
+
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
-        if (!isString(arguments[0]))
+        if (!isStringOrFixedString(arguments[0]))
+        {
             throw Exception(
-                "Illegal type " + arguments[0]->getName() + " of argument of function " + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type {} of argument of function {}", arguments[0]->getName(), getName());
+        }
 
-        return std::make_shared<DataTypeFixedString>(IPV6_BINARY_LENGTH);
-    }
+        auto result_type = std::make_shared<DataTypeFixedString>(IPV6_BINARY_LENGTH);
 
-    bool useDefaultImplementationForConstants() const override { return true; }
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+        {
+            return makeNullable(result_type);
+        }
+
+        return result_type;
+    }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
         const ColumnPtr & column = arguments[0].column;
 
-        if (const auto * col_in = checkAndGetColumn<ColumnString>(column.get()))
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)
         {
-            auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);
-
-            auto & vec_res = col_res->getChars();
-            vec_res.resize(col_in->size() * IPV6_BINARY_LENGTH);
-
-            const ColumnString::Chars & vec_src = col_in->getChars();
-            const ColumnString::Offsets & offsets_src = col_in->getOffsets();
-            size_t src_offset = 0;
-            char src_ipv4_buf[sizeof("::ffff:") + IPV4_MAX_TEXT_LENGTH + 1] = "::ffff:";
-
-            for (size_t out_offset = 0, i = 0; out_offset < vec_res.size(); out_offset += IPV6_BINARY_LENGTH, ++i)
+            if (cast_ipv4_ipv6_default_on_conversion_error)
             {
-                /// For both cases below: In case of failure, the function parseIPv6 fills vec_res with zero bytes.
-
-                /// If the source IP address is parsable as an IPv4 address, then transform it into a valid IPv6 address.
-                /// Keeping it simple by just prefixing `::ffff:` to the IPv4 address to represent it as a valid IPv6 address.
-                if (tryParseIPv4(reinterpret_cast<const char *>(&vec_src[src_offset])))
-                {
-                    std::memcpy(
-                        src_ipv4_buf + std::strlen("::ffff:"),
-                        reinterpret_cast<const char *>(&vec_src[src_offset]),
-                        std::min<UInt64>(offsets_src[i] - src_offset, IPV4_MAX_TEXT_LENGTH + 1));
-                    parseIPv6(src_ipv4_buf, reinterpret_cast<unsigned char *>(&vec_res[out_offset]));
-                }
-                else
-                {
-                    parseIPv6(
-                        reinterpret_cast<const char *>(&vec_src[src_offset]), reinterpret_cast<unsigned char *>(&vec_res[out_offset]));
-                }
-                src_offset = offsets_src[i];
+                return convertToIPv6<IPStringToNumExceptionMode::Default>(column);
             }
-
-            return col_res;
         }
-        else
-            throw Exception("Illegal column " + arguments[0].column->getName()
-                            + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_COLUMN);
+
+        return convertToIPv6<exception_mode>(column);
     }
+
+private:
+    bool cast_ipv4_ipv6_default_on_conversion_error = false;
 };
 
 
@@ -381,69 +367,64 @@ class FunctionIPv4NumToString : public IFunction
     }
 };
 
-
+template <IPStringToNumExceptionMode exception_mode>
 class FunctionIPv4StringToNum : public IFunction
 {
 public:
-    static constexpr auto name = "IPv4StringToNum";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv4StringToNum>(); }
+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw
+        ? "IPv4StringToNum"
+        : (exception_mode == IPStringToNumExceptionMode::Default ? "IPv4StringToNumOrDefault" : "IPv4StringToNumOrNull");
 
-    String getName() const override
+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionIPv4StringToNum>(context); }
+
+    explicit FunctionIPv4StringToNum(ContextPtr context)
+        : cast_ipv4_ipv6_default_on_conversion_error(context->getSettingsRef().cast_ipv4_ipv6_default_on_conversion_error)
     {
-        return name;
     }
 
+    String getName() const override { return name; }
+
     size_t getNumberOfArguments() const override { return 1; }
 
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
 
+    bool useDefaultImplementationForConstants() const override { return true; }
+
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isString(arguments[0]))
-            throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        {
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type {} of argument of function {}", arguments[0]->getName(), getName());
+        }
 
-        return std::make_shared<DataTypeUInt32>();
-    }
+        auto result_type = std::make_shared<DataTypeUInt32>();
 
-    static inline UInt32 parseIPv4(const char * pos)
-    {
-        UInt32 result = 0;
-        DB::parseIPv4(pos, reinterpret_cast<unsigned char*>(&result));
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+        {
+            return makeNullable(result_type);
+        }
 
-        return result;
+        return result_type;
     }
 
-    bool useDefaultImplementationForConstants() const override { return true; }
-
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
         const ColumnPtr & column = arguments[0].column;
 
-        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)
         {
-            auto col_res = ColumnUInt32::create();
-
-            ColumnUInt32::Container & vec_res = col_res->getData();
-            vec_res.resize(col->size());
-
-            const ColumnString::Chars & vec_src = col->getChars();
-            const ColumnString::Offsets & offsets_src = col->getOffsets();
-            size_t prev_offset = 0;
-
-            for (size_t i = 0; i < vec_res.size(); ++i)
+            if (cast_ipv4_ipv6_default_on_conversion_error)
             {
-                vec_res[i] = parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]));
-                prev_offset = offsets_src[i];
+                return convertToIPv4<IPStringToNumExceptionMode::Default>(column);
             }
-
-            return col_res;
         }
-        else
-            throw Exception("Illegal column " + arguments[0].column->getName()
-                            + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_COLUMN);
+
+        return convertToIPv4<exception_mode>(column);
     }
+
+private:
+    bool cast_ipv4_ipv6_default_on_conversion_error = false;
 };
 
 
@@ -503,16 +484,21 @@ class FunctionIPv4ToIPv6 : public IFunction
     }
 };
 
-class FunctionToIPv4 : public FunctionIPv4StringToNum
+template <IPStringToNumExceptionMode exception_mode>
+class FunctionToIPv4 : public FunctionIPv4StringToNum<exception_mode>
 {
 public:
-    static constexpr auto name = "toIPv4";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToIPv4>(); }
+    using Base = FunctionIPv4StringToNum<exception_mode>;
 
-    String getName() const override
-    {
-        return name;
-    }
+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw
+        ? "toIPv4"
+        : (exception_mode == IPStringToNumExceptionMode::Default ? "toIPv4OrDefault" : "toIPv4OrNull");
+
+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToIPv4>(context); }
+
+    explicit FunctionToIPv4(ContextPtr context) : Base(context) { }
+
+    String getName() const override { return name; }
 
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
 
@@ -521,18 +507,35 @@ class FunctionToIPv4 : public FunctionIPv4StringToNum
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isString(arguments[0]))
-            throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        {
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type {} of argument of function {}", arguments[0]->getName(), getName());
+        }
+
+        auto result_type = DataTypeFactory::instance().get("IPv4");
+
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+        {
+            return makeNullable(result_type);
+        }
 
-        return DataTypeFactory::instance().get("IPv4");
+        return result_type;
     }
 };
 
-class FunctionToIPv6 : public FunctionIPv6StringToNum
+template <IPStringToNumExceptionMode exception_mode>
+class FunctionToIPv6 : public FunctionIPv6StringToNum<exception_mode>
 {
 public:
-    static constexpr auto name = "toIPv6";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToIPv6>(); }
+    using Base = FunctionIPv6StringToNum<exception_mode>;
+
+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw
+        ? "toIPv6"
+        : (exception_mode == IPStringToNumExceptionMode::Default ? "toIPv6OrDefault" : "toIPv6OrNull");
+
+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToIPv6>(context); }
+
+    explicit FunctionToIPv6(ContextPtr context) : Base(context) { }
 
     String getName() const override { return name; }
 
@@ -540,11 +543,20 @@ class FunctionToIPv6 : public FunctionIPv6StringToNum
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
-        if (!isString(arguments[0]))
-            throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        if (!isStringOrFixedString(arguments[0]))
+        {
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type {} of argument of function {}", arguments[0]->getName(), getName());
+        }
+
+        auto result_type = DataTypeFactory::instance().get("IPv6");
 
-        return DataTypeFactory::instance().get("IPv6");
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+        {
+            return makeNullable(result_type);
+        }
+
+        return result_type;
     }
 };
 
@@ -971,7 +983,7 @@ class FunctionIPv4CIDRToRange : public IFunction
     }
 };
 
-class FunctionIsIPv4String : public FunctionIPv4StringToNum
+class FunctionIsIPv4String : public IFunction
 {
 public:
     static constexpr auto name = "isIPv4String";
@@ -980,46 +992,51 @@ class FunctionIsIPv4String : public FunctionIPv4StringToNum
 
     String getName() const override { return name; }
 
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    size_t getNumberOfArguments() const override { return 1; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+
+    bool useDefaultImplementationForConstants() const override { return true; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isString(arguments[0]))
-            throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            throw Exception(
+                "Illegal type " + arguments[0]->getName() + " of argument of function " + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
         return std::make_shared<DataTypeUInt8>();
     }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
-        const ColumnPtr & column = arguments[0].column;
-        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))
+        const ColumnString * input_column = checkAndGetColumn<ColumnString>(arguments[0].column.get());
+
+        if (!input_column)
         {
-            auto col_res = ColumnUInt8::create();
+            throw Exception(
+                ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of argument of function {}", arguments[0].column->getName(), getName());
+        }
 
-            ColumnUInt8::Container & vec_res = col_res->getData();
-            vec_res.resize(col->size());
+        auto col_res = ColumnUInt8::create();
 
-            const ColumnString::Chars & vec_src = col->getChars();
-            const ColumnString::Offsets & offsets_src = col->getOffsets();
-            size_t prev_offset = 0;
-            UInt32 result = 0;
+        ColumnUInt8::Container & vec_res = col_res->getData();
+        vec_res.resize(input_column->size());
 
-            for (size_t i = 0; i < vec_res.size(); ++i)
-            {
-                vec_res[i] = DB::parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char*>(&result));
-                prev_offset = offsets_src[i];
-            }
-            return col_res;
+        const ColumnString::Chars & vec_src = input_column->getChars();
+        const ColumnString::Offsets & offsets_src = input_column->getOffsets();
+        size_t prev_offset = 0;
+        UInt32 result = 0;
+
+        for (size_t i = 0; i < vec_res.size(); ++i)
+        {
+            vec_res[i] = DB::parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(&result));
+            prev_offset = offsets_src[i];
         }
-        else
-            throw Exception("Illegal column " + arguments[0].column->getName()
-                            + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_COLUMN);
+
+        return col_res;
     }
 };
 
-class FunctionIsIPv6String : public FunctionIPv6StringToNum
+class FunctionIsIPv6String : public IFunction
 {
 public:
     static constexpr auto name = "isIPv6String";
@@ -1028,44 +1045,49 @@ class FunctionIsIPv6String : public FunctionIPv6StringToNum
 
     String getName() const override { return name; }
 
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    size_t getNumberOfArguments() const override { return 1; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+
+    bool useDefaultImplementationForConstants() const override { return true; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isString(arguments[0]))
-            throw Exception("Illegal type " + arguments[0]->getName() + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        {
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type {} of argument of function {}", arguments[0]->getName(), getName());
+        }
 
         return std::make_shared<DataTypeUInt8>();
     }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
-        const ColumnPtr & column = arguments[0].column;
-
-        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))
+        const ColumnString * input_column = checkAndGetColumn<ColumnString>(arguments[0].column.get());
+        if (!input_column)
         {
-            auto col_res = ColumnUInt8::create();
+            throw Exception(
+                ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of argument of function {}", arguments[0].column->getName(), getName());
+        }
 
-            ColumnUInt8::Container & vec_res = col_res->getData();
-            vec_res.resize(col->size());
+        auto col_res = ColumnUInt8::create();
 
-            const ColumnString::Chars & vec_src = col->getChars();
-            const ColumnString::Offsets & offsets_src = col->getOffsets();
-            size_t prev_offset = 0;
-            char v[IPV6_BINARY_LENGTH];
+        ColumnUInt8::Container & vec_res = col_res->getData();
+        vec_res.resize(input_column->size());
 
-            for (size_t i = 0; i < vec_res.size(); ++i)
-            {
-                vec_res[i] = DB::parseIPv6(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char*>(v));
-                prev_offset = offsets_src[i];
-            }
-            return col_res;
+        const ColumnString::Chars & vec_src = input_column->getChars();
+        const ColumnString::Offsets & offsets_src = input_column->getOffsets();
+        size_t prev_offset = 0;
+        char buffer[IPV6_BINARY_LENGTH];
+
+        for (size_t i = 0; i < vec_res.size(); ++i)
+        {
+            vec_res[i] = DB::parseIPv6(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(buffer));
+            prev_offset = offsets_src[i];
         }
-        else
-            throw Exception("Illegal column " + arguments[0].column->getName()
-                            + " of argument of function " + getName(),
-                            ErrorCodes::ILLEGAL_COLUMN);
+
+        return col_res;
     }
 };
 
@@ -1079,8 +1101,6 @@ void registerFunctionsCoding(FunctionFactory & factory)
     factory.registerFunction<FunctionMACNumToString>();
     factory.registerFunction<FunctionMACStringTo<ParseMACImpl>>();
     factory.registerFunction<FunctionMACStringTo<ParseOUIImpl>>();
-    factory.registerFunction<FunctionToIPv4>();
-    factory.registerFunction<FunctionToIPv6>();
     factory.registerFunction<FunctionIPv6CIDRToRange>();
     factory.registerFunction<FunctionIPv4CIDRToRange>();
     factory.registerFunction<FunctionIsIPv4String>();
@@ -1089,14 +1109,26 @@ void registerFunctionsCoding(FunctionFactory & factory)
     factory.registerFunction<FunctionIPv4NumToString<0, NameFunctionIPv4NumToString>>();
     factory.registerFunction<FunctionIPv4NumToString<1, NameFunctionIPv4NumToStringClassC>>();
 
-    factory.registerFunction<FunctionIPv4StringToNum>();
+    factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Throw>>();
+    factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Default>>();
+    factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Null>>();
+    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Throw>>();
+    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Default>>();
+    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Null>>();
+
     factory.registerFunction<FunctionIPv6NumToString>();
-    factory.registerFunction<FunctionIPv6StringToNum>();
+    factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Throw>>();
+    factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Default>>();
+    factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Null>>();
+    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Throw>>();
+    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Default>>();
+    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Null>>();
+
 
-    /// MysQL compatibility aliases:
-    factory.registerAlias("INET_ATON", FunctionIPv4StringToNum::name, FunctionFactory::CaseInsensitive);
+    /// MySQL compatibility aliases:
+    factory.registerAlias("INET_ATON", FunctionIPv4StringToNum<IPStringToNumExceptionMode::Throw>::name, FunctionFactory::CaseInsensitive);
     factory.registerAlias("INET6_NTOA", FunctionIPv6NumToString::name, FunctionFactory::CaseInsensitive);
-    factory.registerAlias("INET6_ATON", FunctionIPv6StringToNum::name, FunctionFactory::CaseInsensitive);
+    factory.registerAlias("INET6_ATON", FunctionIPv6StringToNum<IPStringToNumExceptionMode::Throw>::name, FunctionFactory::CaseInsensitive);
     factory.registerAlias("INET_NTOA", NameFunctionIPv4NumToString::name, FunctionFactory::CaseInsensitive);
 }
 
diff --git a/src/Functions/FunctionsCodingIP.h b/src/Functions/FunctionsCodingIP.h
new file mode 100644
index 000000000000..246e62d965cd
--- /dev/null
+++ b/src/Functions/FunctionsCodingIP.h
@@ -0,0 +1,212 @@
+#pragma once
+
+#include <Common/formatIPv6.h>
+
+#include <Columns/ColumnFixedString.h>
+#include <Columns/ColumnNullable.h>
+#include <Columns/ColumnString.h>
+#include <Columns/ColumnsNumber.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;
+    extern const int ILLEGAL_COLUMN;
+}
+
+enum class IPStringToNumExceptionMode : uint8_t
+{
+    Throw,
+    Default,
+    Null
+};
+
+static inline bool tryParseIPv4(const char * pos, UInt32 & result_value)
+{
+    return parseIPv4(pos, reinterpret_cast<unsigned char *>(&result_value));
+}
+
+namespace detail
+{
+    template <IPStringToNumExceptionMode exception_mode, typename StringColumnType>
+    ColumnPtr convertToIPv6(const StringColumnType & string_column)
+    {
+        size_t column_size = string_column.size();
+
+        ColumnUInt8::MutablePtr col_null_map_to;
+        ColumnUInt8::Container * vec_null_map_to = nullptr;
+
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+        {
+            col_null_map_to = ColumnUInt8::create(column_size, false);
+            vec_null_map_to = &col_null_map_to->getData();
+        }
+
+        auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);
+
+        auto & vec_res = col_res->getChars();
+        vec_res.resize(column_size * IPV6_BINARY_LENGTH);
+
+        using Chars = typename StringColumnType::Chars;
+        const Chars & vec_src = string_column.getChars();
+
+        size_t src_offset = 0;
+        char src_ipv4_buf[sizeof("::ffff:") + IPV4_MAX_TEXT_LENGTH + 1] = "::ffff:";
+
+        /// ColumnFixedString contains not null terminated strings. But functions parseIPv6, parseIPv4 expect null terminated string.
+        std::string fixed_string_buffer;
+
+        if constexpr (std::is_same_v<StringColumnType, ColumnFixedString>)
+        {
+            fixed_string_buffer.resize(string_column.getN());
+        }
+
+        for (size_t out_offset = 0, i = 0; out_offset < vec_res.size(); out_offset += IPV6_BINARY_LENGTH, ++i)
+        {
+            size_t src_next_offset = src_offset;
+
+            const char * src_value = nullptr;
+            unsigned char * res_value = reinterpret_cast<unsigned char *>(&vec_res[out_offset]);
+
+            if constexpr (std::is_same_v<StringColumnType, ColumnString>)
+            {
+                src_value = reinterpret_cast<const char *>(&vec_src[src_offset]);
+                src_next_offset = string_column.getOffsets()[i];
+            }
+            else if constexpr (std::is_same_v<StringColumnType, ColumnFixedString>)
+            {
+                size_t fixed_string_size = string_column.getN();
+
+                std::memcpy(fixed_string_buffer.data(), reinterpret_cast<const char *>(&vec_src[src_offset]), fixed_string_size);
+                src_value = fixed_string_buffer.data();
+
+                src_next_offset += fixed_string_size;
+            }
+
+            bool parse_result = false;
+            UInt32 dummy_result = 0;
+
+            /// For both cases below: In case of failure, the function parseIPv6 fills vec_res with zero bytes.
+
+            /// If the source IP address is parsable as an IPv4 address, then transform it into a valid IPv6 address.
+            /// Keeping it simple by just prefixing `::ffff:` to the IPv4 address to represent it as a valid IPv6 address.
+            if (tryParseIPv4(src_value, dummy_result))
+            {
+                std::memcpy(
+                    src_ipv4_buf + std::strlen("::ffff:"),
+                    src_value,
+                    std::min<UInt64>(src_next_offset - src_offset, IPV4_MAX_TEXT_LENGTH + 1));
+                parse_result = parseIPv6(src_ipv4_buf, res_value);
+            }
+            else
+            {
+                parse_result = parseIPv6(src_value, res_value);
+            }
+
+            if (!parse_result)
+            {
+                if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)
+                    throw Exception("Invalid IPv6 value", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);
+                else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)
+                    vec_res[i] = 0;
+                else if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+                    (*vec_null_map_to)[i] = true;
+            }
+
+            src_offset = src_next_offset;
+        }
+
+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+            return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));
+
+        return col_res;
+    }
+}
+
+template <IPStringToNumExceptionMode exception_mode>
+ColumnPtr convertToIPv6(ColumnPtr column)
+{
+    size_t column_size = column->size();
+
+    auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);
+
+    auto & vec_res = col_res->getChars();
+    vec_res.resize(column_size * IPV6_BINARY_LENGTH);
+
+    if (const auto * column_input_string = checkAndGetColumn<ColumnString>(column.get()))
+    {
+        return detail::convertToIPv6<exception_mode>(*column_input_string);
+    }
+    else if (const auto * column_input_fixed_string = checkAndGetColumn<ColumnFixedString>(column.get()))
+    {
+        return detail::convertToIPv6<exception_mode>(*column_input_fixed_string);
+    }
+    else
+    {
+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column type {}. Expected String or FixedString", column->getName());
+    }
+}
+
+template <IPStringToNumExceptionMode exception_mode>
+ColumnPtr convertToIPv4(ColumnPtr column)
+{
+    const ColumnString * column_string = checkAndGetColumn<ColumnString>(column.get());
+
+    if (!column_string)
+    {
+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Illegal column type {}. Expected String.", column->getName());
+    }
+
+    size_t column_size = column_string->size();
+
+    ColumnUInt8::MutablePtr col_null_map_to;
+    ColumnUInt8::Container * vec_null_map_to = nullptr;
+
+    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+    {
+        col_null_map_to = ColumnUInt8::create(column_size, false);
+        vec_null_map_to = &col_null_map_to->getData();
+    }
+
+    auto col_res = ColumnUInt32::create();
+
+    ColumnUInt32::Container & vec_res = col_res->getData();
+    vec_res.resize(column_size);
+
+    const ColumnString::Chars & vec_src = column_string->getChars();
+    const ColumnString::Offsets & offsets_src = column_string->getOffsets();
+    size_t prev_offset = 0;
+
+    for (size_t i = 0; i < vec_res.size(); ++i)
+    {
+        bool parse_result = tryParseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), vec_res[i]);
+
+        if (!parse_result)
+        {
+            if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)
+            {
+                throw Exception("Invalid IPv4 value", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);
+            }
+            else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)
+            {
+                vec_res[i] = 0;
+            }
+            else if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+            {
+                (*vec_null_map_to)[i] = true;
+                vec_res[i] = 0;
+            }
+        }
+
+        prev_offset = offsets_src[i];
+    }
+
+    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)
+        return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));
+
+    return col_res;
+}
+
+}
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index f75d67032f28..f41a461a7287 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -45,6 +45,7 @@
 #include <Functions/DateTimeTransforms.h>
 #include <Functions/toFixedString.h>
 #include <Functions/TransformDateTime64.h>
+#include <Functions/FunctionsCodingIP.h>
 #include <DataTypes/DataTypeLowCardinality.h>
 #include <Columns/ColumnLowCardinality.h>
 #include <Interpreters/Context.h>
@@ -2532,10 +2533,12 @@ class FunctionCast final : public FunctionCastBase
             , const DataTypes & argument_types_
             , const DataTypePtr & return_type_
             , std::optional<Diagnostic> diagnostic_
-            , CastType cast_type_)
+            , CastType cast_type_
+            , bool cast_ipv4_ipv6_default_on_conversion_error_)
         : cast_name(cast_name_), monotonicity_for_range(std::move(monotonicity_for_range_))
         , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))
         , cast_type(cast_type_)
+        , cast_ipv4_ipv6_default_on_conversion_error(cast_ipv4_ipv6_default_on_conversion_error_)
     {
     }
 
@@ -2584,6 +2587,7 @@ class FunctionCast final : public FunctionCastBase
 
     std::optional<Diagnostic> diagnostic;
     CastType cast_type;
+    bool cast_ipv4_ipv6_default_on_conversion_error;
 
     static WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type)
     {
@@ -3381,7 +3385,9 @@ class FunctionCast final : public FunctionCastBase
     /// 'requested_result_is_nullable' is true if CAST to Nullable type is requested.
     WrapperType prepareImpl(const DataTypePtr & from_type, const DataTypePtr & to_type, bool requested_result_is_nullable) const
     {
-        if (from_type->equals(*to_type))
+        bool convert_to_ipv6 = to_type->getCustomName() && to_type->getCustomName()->getName() == "IPv6";
+
+        if (from_type->equals(*to_type) && !convert_to_ipv6)
         {
             if (isUInt8(from_type))
                 return createUInt8ToUInt8Wrapper(from_type, to_type);
@@ -3449,7 +3455,9 @@ class FunctionCast final : public FunctionCastBase
             return false;
         };
 
-        auto make_custom_serialization_wrapper = [&](const auto & types) -> bool
+        bool cast_ipv4_ipv6_default_on_conversion_error_value = cast_ipv4_ipv6_default_on_conversion_error;
+
+        auto make_custom_serialization_wrapper = [&, cast_ipv4_ipv6_default_on_conversion_error_value](const auto & types) -> bool
         {
             using Types = std::decay_t<decltype(types)>;
             using ToDataType = typename Types::RightType;
@@ -3457,8 +3465,45 @@ class FunctionCast final : public FunctionCastBase
 
             if constexpr (WhichDataType(FromDataType::type_id).isStringOrFixedString())
             {
-                if (to_type->getCustomSerialization())
+                if (to_type->getCustomSerialization() && to_type->getCustomName())
                 {
+                    if (to_type->getCustomName()->getName() == "IPv4")
+                    {
+                        ret = [cast_ipv4_ipv6_default_on_conversion_error_value](
+                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t)
+                            -> ColumnPtr
+                        {
+                            if (!WhichDataType(result_type).isUInt32())
+                                throw Exception(ErrorCodes::TYPE_MISMATCH, "Wrong result type {}. Expected UInt32", result_type->getName());
+
+                            if (cast_ipv4_ipv6_default_on_conversion_error_value)
+                                return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column);
+                            else
+                                return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column);
+                        };
+
+                        return true;
+                    }
+
+                    if (to_type->getCustomName()->getName() == "IPv6")
+                    {
+                        ret = [cast_ipv4_ipv6_default_on_conversion_error_value](
+                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t)
+                            -> ColumnPtr
+                        {
+                            if (!WhichDataType(result_type).isFixedString())
+                                throw Exception(
+                                    ErrorCodes::TYPE_MISMATCH, "Wrong result type {}. Expected FixedString", result_type->getName());
+
+                            if (cast_ipv4_ipv6_default_on_conversion_error_value)
+                                return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column);
+                            else
+                                return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column);
+                        };
+
+                        return true;
+                    }
+
                     ret = &ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute;
                     return true;
                 }
