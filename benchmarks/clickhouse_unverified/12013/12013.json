{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12013,
  "instance_id": "ClickHouse__ClickHouse-12013",
  "issue_numbers": [
    "11371"
  ],
  "base_commit": "7376f18467eb238e9f08ff2c7a0b1d5d45e944af",
  "patch": "diff --git a/src/Columns/ColumnArray.cpp b/src/Columns/ColumnArray.cpp\nindex 0006eb04e68d..c148fa7886fa 100644\n--- a/src/Columns/ColumnArray.cpp\n+++ b/src/Columns/ColumnArray.cpp\n@@ -26,7 +26,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_COLUMN;\n     extern const int NOT_IMPLEMENTED;\n     extern const int BAD_ARGUMENTS;\n     extern const int PARAMETER_OUT_OF_BOUND;\n@@ -38,8 +37,18 @@ namespace ErrorCodes\n ColumnArray::ColumnArray(MutableColumnPtr && nested_column, MutableColumnPtr && offsets_column)\n     : data(std::move(nested_column)), offsets(std::move(offsets_column))\n {\n-    if (!typeid_cast<const ColumnOffsets *>(offsets.get()))\n-        throw Exception(\"offsets_column must be a ColumnUInt64\", ErrorCodes::ILLEGAL_COLUMN);\n+    const ColumnOffsets * offsets_concrete = typeid_cast<const ColumnOffsets *>(offsets.get());\n+\n+    if (!offsets_concrete)\n+        throw Exception(\"offsets_column must be a ColumnUInt64\", ErrorCodes::LOGICAL_ERROR);\n+\n+    size_t size = offsets_concrete->size();\n+    if (size != 0 && nested_column)\n+    {\n+        /// This will also prevent possible overflow in offset.\n+        if (nested_column->size() != offsets_concrete->getData()[size - 1])\n+            throw Exception(\"offsets_column has data inconsistent with nested_column\", ErrorCodes::LOGICAL_ERROR);\n+    }\n \n     /** NOTE\n       * Arrays with constant value are possible and used in implementation of higher order functions (see FunctionReplicate).\n@@ -51,7 +60,7 @@ ColumnArray::ColumnArray(MutableColumnPtr && nested_column)\n     : data(std::move(nested_column))\n {\n     if (!data->empty())\n-        throw Exception(\"Not empty data passed to ColumnArray, but no offsets passed\", ErrorCodes::ILLEGAL_COLUMN);\n+        throw Exception(\"Not empty data passed to ColumnArray, but no offsets passed\", ErrorCodes::LOGICAL_ERROR);\n \n     offsets = ColumnOffsets::create();\n }\ndiff --git a/src/Storages/StorageGenerateRandom.cpp b/src/Storages/StorageGenerateRandom.cpp\nindex 1f227265d196..0d5011de4b1c 100644\n--- a/src/Storages/StorageGenerateRandom.cpp\n+++ b/src/Storages/StorageGenerateRandom.cpp\n@@ -38,6 +38,8 @@ namespace ErrorCodes\n {\n     extern const int NOT_IMPLEMENTED;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int TOO_LARGE_ARRAY_SIZE;\n+    extern const int TOO_LARGE_STRING_SIZE;\n }\n \n \n@@ -387,6 +389,16 @@ StorageGenerateRandom::StorageGenerateRandom(const StorageID & table_id_, const\n     UInt64 max_array_length_, UInt64 max_string_length_, std::optional<UInt64> random_seed_)\n     : IStorage(table_id_), max_array_length(max_array_length_), max_string_length(max_string_length_)\n {\n+    static constexpr size_t MAX_ARRAY_SIZE = 1 << 30;\n+    static constexpr size_t MAX_STRING_SIZE = 1 << 30;\n+\n+    if (max_array_length > MAX_ARRAY_SIZE)\n+        throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, \"Too large array size in GenerateRandom: {}, maximum: {}\",\n+                        max_array_length, MAX_ARRAY_SIZE);\n+    if (max_string_length > MAX_STRING_SIZE)\n+        throw Exception(ErrorCodes::TOO_LARGE_STRING_SIZE, \"Too large string size in GenerateRandom: {}, maximum: {}\",\n+                        max_string_length, MAX_STRING_SIZE);\n+\n     random_seed = random_seed_ ? sipHash64(*random_seed_) : randomSeed();\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n@@ -422,7 +434,6 @@ void registerStorageGenerateRandom(StorageFactory & factory)\n         if (engine_args.size() == 3)\n             max_array_length = engine_args[2]->as<const ASTLiteral &>().value.safeGet<UInt64>();\n \n-\n         return StorageGenerateRandom::create(args.table_id, args.columns, max_array_length, max_string_length, random_seed);\n     });\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01352_generate_random_overflow.reference b/tests/queries/0_stateless/01352_generate_random_overflow.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01352_generate_random_overflow.sql b/tests/queries/0_stateless/01352_generate_random_overflow.sql\nnew file mode 100644\nindex 000000000000..d49f8cb26878\n--- /dev/null\n+++ b/tests/queries/0_stateless/01352_generate_random_overflow.sql\n@@ -0,0 +1,1 @@\n+SELECT i FROM generateRandom('i Array(Nullable(Enum8(\\'hello\\' = 1, \\'world\\' = 5)))', 1025, 65535, 9223372036854775807) LIMIT 10; -- { serverError 128 }\n",
  "problem_statement": "select from generateRandom: PODArray::operator[]: Assertion failed\n```\r\nSELECT i FROM generateRandom('i Array(Nullable(Enum8(\\'hello\\' = 1, \\'world\\' = 5)))', 1025, 65535, 9223372036854775807) LIMIT 10\r\n```\r\n\r\n@qoega FYI\n",
  "hints_text": "",
  "created_at": "2020-06-28T14:34:04Z",
  "modified_files": [
    "src/Columns/ColumnArray.cpp",
    "src/Storages/StorageGenerateRandom.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01352_generate_random_overflow.sql"
  ]
}