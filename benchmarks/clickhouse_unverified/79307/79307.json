{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79307,
  "instance_id": "ClickHouse__ClickHouse-79307",
  "issue_numbers": [
    "74833"
  ],
  "base_commit": "44b7e9f7b0d226138efcce3f74b1669bde247ff9",
  "patch": "diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex 1e2c530ffb87..7771541a0280 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -295,6 +295,7 @@\n     \\\n     M(MutationTotalParts, \"Number of total parts for which mutations tried to be applied\", ValueType::Number) \\\n     M(MutationUntouchedParts, \"Number of total parts for which mutations tried to be applied but which was completely skipped according to predicate\", ValueType::Number) \\\n+    M(MutationCreatedEmptyParts, \"Number of total parts which were replaced to empty parts instead of running mutation\", ValueType::Number) \\\n     M(MutatedRows, \"Rows read for mutations. This is the number of rows before mutation\", ValueType::Number) \\\n     M(MutatedUncompressedBytes, \"Uncompressed bytes (for columns as they stored in memory) that was read for mutations. This is the number before mutation.\", ValueType::Bytes) \\\n     M(MutationTotalMilliseconds, \"Total time spent for mutations.\", ValueType::Milliseconds) \\\ndiff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp\nindex 7f1a7ae11d98..345cfd213f61 100644\n--- a/src/Interpreters/MutationsInterpreter.cpp\n+++ b/src/Interpreters/MutationsInterpreter.cpp\n@@ -160,15 +160,19 @@ ColumnDependencies getAllColumnDependencies(\n }\n \n \n-bool isStorageTouchedByMutations(\n+IsStorageTouched isStorageTouchedByMutations(\n     MergeTreeData::DataPartPtr source_part,\n     MergeTreeData::MutationsSnapshotPtr mutations_snapshot,\n     const StorageMetadataPtr & metadata_snapshot,\n     const std::vector<MutationCommand> & commands,\n     ContextPtr context)\n {\n+    static constexpr IsStorageTouched no_rows = {.any_rows_affected = false, .all_rows_affected = false};\n+    static constexpr IsStorageTouched all_rows = {.any_rows_affected = true, .all_rows_affected = true};\n+    static constexpr IsStorageTouched some_rows = {.any_rows_affected = true, .all_rows_affected = false};\n+\n     if (commands.empty())\n-        return false;\n+        return no_rows;\n \n     auto storage_from_part = std::make_shared<StorageFromMergeTreeDataPart>(source_part, mutations_snapshot);\n     bool all_commands_can_be_skipped = true;\n@@ -178,12 +182,12 @@ bool isStorageTouchedByMutations(\n         if (command.type == MutationCommand::APPLY_DELETED_MASK)\n         {\n             if (source_part->hasLightweightDelete())\n-                return true;\n+                return some_rows;\n         }\n         else\n         {\n             if (!command.predicate) /// The command touches all rows.\n-                return true;\n+                return all_rows;\n \n             if (command.partition)\n             {\n@@ -199,7 +203,7 @@ bool isStorageTouchedByMutations(\n     }\n \n     if (all_commands_can_be_skipped)\n-        return false;\n+        return no_rows;\n \n     std::optional<InterpreterSelectQuery> interpreter_select_query;\n     BlockIO io;\n@@ -229,7 +233,7 @@ bool isStorageTouchedByMutations(\n     while (block.rows() == 0 && executor.pull(block));\n \n     if (!block.rows())\n-        return false;\n+        return no_rows;\n     if (block.rows() != 1)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"count() expression returned {} rows, not 1\", block.rows());\n \n@@ -237,7 +241,11 @@ bool isStorageTouchedByMutations(\n     while (executor.pull(tmp_block));\n \n     auto count = (*block.getByName(\"count()\").column)[0].safeGet<UInt64>();\n-    return count != 0;\n+\n+    IsStorageTouched result;\n+    result.any_rows_affected = (count != 0);\n+    result.all_rows_affected = (count == source_part->rows_count);\n+    return result;\n }\n \n ASTPtr getPartitionAndPredicateExpressionForMutationCommand(\ndiff --git a/src/Interpreters/MutationsInterpreter.h b/src/Interpreters/MutationsInterpreter.h\nindex e6a07c1081ae..0fd53a2d768a 100644\n--- a/src/Interpreters/MutationsInterpreter.h\n+++ b/src/Interpreters/MutationsInterpreter.h\n@@ -16,8 +16,14 @@ class QueryPlan;\n class QueryPipelineBuilder;\n using QueryPipelineBuilderPtr = std::unique_ptr<QueryPipelineBuilder>;\n \n+struct IsStorageTouched\n+{\n+    bool any_rows_affected = false;\n+    bool all_rows_affected = false;\n+};\n+\n /// Return false if the data isn't going to be changed by mutations.\n-bool isStorageTouchedByMutations(\n+IsStorageTouched isStorageTouchedByMutations(\n     MergeTreeData::DataPartPtr source_part,\n     MergeTreeData::MutationsSnapshotPtr mutations_snapshot,\n     const StorageMetadataPtr & metadata_snapshot,\ndiff --git a/src/Storages/MergeTree/MutateTask.cpp b/src/Storages/MergeTree/MutateTask.cpp\nindex c6196f7965ae..8bb70182529d 100644\n--- a/src/Storages/MergeTree/MutateTask.cpp\n+++ b/src/Storages/MergeTree/MutateTask.cpp\n@@ -44,6 +44,7 @@ namespace ProfileEvents\n {\n     extern const Event MutationTotalParts;\n     extern const Event MutationUntouchedParts;\n+    extern const Event MutationCreatedEmptyParts;\n     extern const Event MutationTotalMilliseconds;\n     extern const Event MutationExecuteMilliseconds;\n     extern const Event MutationAllPartColumns;\n@@ -2240,7 +2241,9 @@ bool MutateTask::prepare()\n         if (!canSkipMutationCommandForPart(ctx->source_part, command, context_for_reading))\n             ctx->commands_for_part.emplace_back(command);\n \n-    if (!isStorageTouchedByMutations(ctx->source_part, mutations_snapshot, ctx->metadata_snapshot, ctx->commands_for_part, context_for_reading))\n+    auto is_storage_touched = isStorageTouchedByMutations(ctx->source_part, mutations_snapshot, ctx->metadata_snapshot, ctx->commands_for_part, context_for_reading);\n+\n+    if (!is_storage_touched.any_rows_affected)\n     {\n         NameSet files_to_copy_instead_of_hardlinks;\n         auto settings_ptr = ctx->data->getSettings();\n@@ -2286,6 +2289,31 @@ bool MutateTask::prepare()\n         return false;\n     }\n \n+    if (is_storage_touched.all_rows_affected)\n+    {\n+        bool has_only_delete_commands = std::ranges::all_of(ctx->commands_for_part, [](const auto & command)\n+        {\n+            return command.type == MutationCommand::DELETE;\n+        });\n+\n+        if (has_only_delete_commands)\n+        {\n+            LOG_TRACE(ctx->log,\n+                \"Part {} is fully deleted, creating empty part with mutation version {}\",\n+                ctx->source_part->name, ctx->future_part->part_info.mutation);\n+\n+            auto [empty_part, _] = ctx->data->createEmptyPart(\n+                ctx->future_part->part_info,\n+                ctx->source_part->partition,\n+                ctx->future_part->name,\n+                ctx->txn);\n+\n+            ProfileEvents::increment(ProfileEvents::MutationCreatedEmptyParts);\n+            promise.set_value(std::move(empty_part));\n+            return false;\n+        }\n+    }\n+\n     LOG_TRACE(ctx->log, \"Mutating part {} to mutation version {}\", ctx->source_part->name, ctx->future_part->part_info.mutation);\n \n     /// We must read with one thread because it guarantees that output stream will be sorted.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03442_alter_delete_empty_part.reference b/tests/queries/0_stateless/03442_alter_delete_empty_part.reference\nnew file mode 100644\nindex 000000000000..662eb9081063\n--- /dev/null\n+++ b/tests/queries/0_stateless/03442_alter_delete_empty_part.reference\n@@ -0,0 +1,4 @@\n+1500\n+1_1_1_0_4\t1\t0\t0\n+2_2_2_0_4\t1\t0\t1\n+3_3_3_0_4\t1\t1\t0\ndiff --git a/tests/queries/0_stateless/03442_alter_delete_empty_part.sql b/tests/queries/0_stateless/03442_alter_delete_empty_part.sql\nnew file mode 100644\nindex 000000000000..528f928c1bdb\n--- /dev/null\n+++ b/tests/queries/0_stateless/03442_alter_delete_empty_part.sql\n@@ -0,0 +1,26 @@\n+DROP TABLE IF EXISTS t_delete_empty_part;\n+\n+CREATE TABLE t_delete_empty_part (a UInt64, b UInt64)\n+ENGINE = MergeTree ORDER BY b PARTITION BY a;\n+\n+INSERT INTO t_delete_empty_part SELECT 1, number FROM numbers(1000);\n+INSERT INTO t_delete_empty_part SELECT 2, number FROM numbers(1000);\n+INSERT INTO t_delete_empty_part SELECT 3, number FROM numbers(2000, 1000);\n+\n+SET mutations_sync = 2;\n+ALTER TABLE t_delete_empty_part DELETE WHERE a = 2 OR b < 500;\n+\n+SELECT count() FROM t_delete_empty_part;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT\n+    part_name,\n+    ProfileEvents['MutationTotalParts'],\n+    ProfileEvents['MutationUntouchedParts'],\n+    ProfileEvents['MutationCreatedEmptyParts']\n+FROM system.part_log\n+WHERE database = currentDatabase() AND table = 't_delete_empty_part' AND event_type = 'MutatePart'\n+ORDER BY part_name;\n+\n+DROP TABLE t_delete_empty_part;\ndiff --git a/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.reference b/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.reference\nnew file mode 100644\nindex 000000000000..402351ef7251\n--- /dev/null\n+++ b/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.reference\n@@ -0,0 +1,4 @@\n+1500\n+1_0_0_0_1\t1\t0\t0\n+2_0_0_0_1\t1\t0\t1\n+3_0_0_0_1\t1\t1\t0\ndiff --git a/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.sql b/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.sql\nnew file mode 100644\nindex 000000000000..1d0f6330dd07\n--- /dev/null\n+++ b/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS t_delete_empty_part_rmt;\n+\n+CREATE TABLE t_delete_empty_part_rmt (a UInt64, b UInt64)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/t_delete_empty_part_rmt', '1')\n+ORDER BY b PARTITION BY a;\n+\n+SET insert_keeper_fault_injection_probability = 0.0;\n+\n+INSERT INTO t_delete_empty_part_rmt SELECT 1, number FROM numbers(1000);\n+INSERT INTO t_delete_empty_part_rmt SELECT 2, number FROM numbers(1000);\n+INSERT INTO t_delete_empty_part_rmt SELECT 3, number FROM numbers(2000, 1000);\n+\n+SET mutations_sync = 2;\n+ALTER TABLE t_delete_empty_part_rmt DELETE WHERE a = 2 OR b < 500;\n+\n+SELECT count() FROM t_delete_empty_part_rmt;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT\n+    part_name,\n+    ProfileEvents['MutationTotalParts'],\n+    ProfileEvents['MutationUntouchedParts'],\n+    ProfileEvents['MutationCreatedEmptyParts']\n+FROM system.part_log\n+WHERE database = currentDatabase() AND table = 't_delete_empty_part_rmt' AND event_type = 'MutatePart'\n+ORDER BY part_name;\n+\n+DROP TABLE t_delete_empty_part_rmt;\n",
  "problem_statement": "Optimize `ALTER ... DELETE` mutation for parts in which all rows satisfy the condition\n### Company or project name\n\nClickHouse Inc.\n\n### Use case\n\nOptimize bulk deletes that delete all rows in some parts.\n\n### Describe the solution you'd like\n\nIf there are only `DELETE` commands in mutation and the condition is satisfied on all rows in part, do not run the mutation but create an empty result part.\n\n\n### Additional context\n\nWe already run the `SELECT count()` query to determine whether mutation touches the part. See: https://github.com/ClickHouse/ClickHouse/blob/422850398a1de5a70d0112d9b513b5080d1dfb5b/src/Interpreters/MutationsInterpreter.cpp#L163\n https://github.com/ClickHouse/ClickHouse/blob/422850398a1de5a70d0112d9b513b5080d1dfb5b/src/Interpreters/MutationsInterpreter.cpp#L239\n\nWe can use this count to check whether it equals the number of rows in part and optimize deletes. So, no extra complexity is added.\n",
  "hints_text": "",
  "created_at": "2025-04-17T15:16:41Z",
  "modified_files": [
    "src/Common/ProfileEvents.cpp",
    "src/Interpreters/MutationsInterpreter.cpp",
    "src/Interpreters/MutationsInterpreter.h",
    "src/Storages/MergeTree/MutateTask.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03442_alter_delete_empty_part.reference",
    "b/tests/queries/0_stateless/03442_alter_delete_empty_part.sql",
    "b/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.reference",
    "b/tests/queries/0_stateless/03442_alter_delete_empty_part_rmt.sql"
  ]
}