{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16774,
  "instance_id": "ClickHouse__ClickHouse-16774",
  "issue_numbers": [
    "16123"
  ],
  "base_commit": "4e85d6a4c3137cb4769ff4e09033d838ce9ba421",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionFactory.cpp b/src/AggregateFunctions/AggregateFunctionFactory.cpp\nindex f7c6fe9da14a..1c66650be451 100644\n--- a/src/AggregateFunctions/AggregateFunctionFactory.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionFactory.cpp\n@@ -56,11 +56,7 @@ static DataTypes convertLowCardinalityTypesToNested(const DataTypes & types)\n }\n \n AggregateFunctionPtr AggregateFunctionFactory::get(\n-    const String & name,\n-    const DataTypes & argument_types,\n-    const Array & parameters,\n-    AggregateFunctionProperties & out_properties,\n-    int recursion_level) const\n+    const String & name, const DataTypes & argument_types, const Array & parameters, AggregateFunctionProperties & out_properties) const\n {\n     auto type_without_low_cardinality = convertLowCardinalityTypesToNested(argument_types);\n \n@@ -81,11 +77,11 @@ AggregateFunctionPtr AggregateFunctionFactory::get(\n             [](const auto & type) { return type->onlyNull(); });\n \n         AggregateFunctionPtr nested_function = getImpl(\n-            name, nested_types, nested_parameters, out_properties, has_null_arguments, recursion_level);\n+            name, nested_types, nested_parameters, out_properties, has_null_arguments);\n         return combinator->transformAggregateFunction(nested_function, out_properties, type_without_low_cardinality, parameters);\n     }\n \n-    auto res = getImpl(name, type_without_low_cardinality, parameters, out_properties, false, recursion_level);\n+    auto res = getImpl(name, type_without_low_cardinality, parameters, out_properties, false);\n     if (!res)\n         throw Exception(\"Logical error: AggregateFunctionFactory returned nullptr\", ErrorCodes::LOGICAL_ERROR);\n     return res;\n@@ -97,8 +93,7 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(\n     const DataTypes & argument_types,\n     const Array & parameters,\n     AggregateFunctionProperties & out_properties,\n-    bool has_null_arguments,\n-    int recursion_level) const\n+    bool has_null_arguments) const\n {\n     String name = getAliasToOrName(name_param);\n     Value found;\n@@ -108,13 +103,9 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(\n     {\n         found = it->second;\n     }\n-    /// Find by case-insensitive name.\n-    /// Combinators cannot apply for case insensitive (SQL-style) aggregate function names. Only for native names.\n-    else if (recursion_level == 0)\n-    {\n-        if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())\n-            found = jt->second;\n-    }\n+\n+    if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())\n+        found = jt->second;\n \n     if (found.creator)\n     {\n@@ -140,7 +131,7 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(\n         DataTypes nested_types = combinator->transformArguments(argument_types);\n         Array nested_parameters = combinator->transformParameters(parameters);\n \n-        AggregateFunctionPtr nested_function = get(nested_name, nested_types, nested_parameters, out_properties, recursion_level + 1);\n+        AggregateFunctionPtr nested_function = get(nested_name, nested_types, nested_parameters, out_properties);\n         return combinator->transformAggregateFunction(nested_function, out_properties, argument_types, parameters);\n     }\n \n@@ -162,7 +153,7 @@ AggregateFunctionPtr AggregateFunctionFactory::tryGet(\n }\n \n \n-std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPropertiesImpl(const String & name_param, int recursion_level) const\n+std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPropertiesImpl(const String & name_param) const\n {\n     String name = getAliasToOrName(name_param);\n     Value found;\n@@ -172,13 +163,9 @@ std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPrope\n     {\n         found = it->second;\n     }\n-    /// Find by case-insensitive name.\n-    /// Combinators cannot apply for case insensitive (SQL-style) aggregate function names. Only for native names.\n-    else if (recursion_level == 0)\n-    {\n-        if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())\n-            found = jt->second;\n-    }\n+\n+    if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())\n+        found = jt->second;\n \n     if (found.creator)\n         return found.properties;\n@@ -195,7 +182,7 @@ std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPrope\n         String nested_name = name.substr(0, name.size() - combinator->getName().size());\n \n         /// NOTE: It's reasonable to also allow to transform properties by combinator.\n-        return tryGetPropertiesImpl(nested_name, recursion_level + 1);\n+        return tryGetPropertiesImpl(nested_name);\n     }\n \n     return {};\n@@ -204,21 +191,21 @@ std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPrope\n \n std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetProperties(const String & name) const\n {\n-    return tryGetPropertiesImpl(name, 0);\n+    return tryGetPropertiesImpl(name);\n }\n \n \n-bool AggregateFunctionFactory::isAggregateFunctionName(const String & name, int recursion_level) const\n+bool AggregateFunctionFactory::isAggregateFunctionName(const String & name) const\n {\n     if (aggregate_functions.count(name) || isAlias(name))\n         return true;\n \n     String name_lowercase = Poco::toLower(name);\n-    if (recursion_level == 0 && (case_insensitive_aggregate_functions.count(name_lowercase) || isAlias(name_lowercase)))\n+    if (case_insensitive_aggregate_functions.count(name_lowercase) || isAlias(name_lowercase))\n         return true;\n \n     if (AggregateFunctionCombinatorPtr combinator = AggregateFunctionCombinatorFactory::instance().tryFindSuffix(name))\n-        return isAggregateFunctionName(name.substr(0, name.size() - combinator->getName().size()), recursion_level + 1);\n+        return isAggregateFunctionName(name.substr(0, name.size() - combinator->getName().size()));\n \n     return false;\n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionFactory.h b/src/AggregateFunctions/AggregateFunctionFactory.h\nindex 143e6562a305..7bbe04aff705 100644\n--- a/src/AggregateFunctions/AggregateFunctionFactory.h\n+++ b/src/AggregateFunctions/AggregateFunctionFactory.h\n@@ -59,12 +59,11 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto\n         CaseSensitiveness case_sensitiveness = CaseSensitive);\n \n     /// Throws an exception if not found.\n-    AggregateFunctionPtr get(\n-        const String & name,\n+    AggregateFunctionPtr\n+    get(const String & name,\n         const DataTypes & argument_types,\n         const Array & parameters,\n-        AggregateFunctionProperties & out_properties,\n-        int recursion_level = 0) const;\n+        AggregateFunctionProperties & out_properties) const;\n \n     /// Returns nullptr if not found.\n     AggregateFunctionPtr tryGet(\n@@ -76,7 +75,7 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto\n     /// Get properties if the aggregate function exists.\n     std::optional<AggregateFunctionProperties> tryGetProperties(const String & name) const;\n \n-    bool isAggregateFunctionName(const String & name, int recursion_level = 0) const;\n+    bool isAggregateFunctionName(const String & name) const;\n \n private:\n     AggregateFunctionPtr getImpl(\n@@ -84,10 +83,9 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto\n         const DataTypes & argument_types,\n         const Array & parameters,\n         AggregateFunctionProperties & out_properties,\n-        bool has_null_arguments,\n-        int recursion_level) const;\n+        bool has_null_arguments) const;\n \n-    std::optional<AggregateFunctionProperties> tryGetPropertiesImpl(const String & name, int recursion_level) const;\n+    std::optional<AggregateFunctionProperties> tryGetPropertiesImpl(const String & name) const;\n \n private:\n     using AggregateFunctions = std::unordered_map<String, Value>;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.reference b/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.reference\nnew file mode 100644\nindex 000000000000..929e088bb7a2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.reference\n@@ -0,0 +1,8 @@\n+0\n+0\n+0\n+0\n+-1\n+-1\n+-1\n+\\N\ndiff --git a/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.sql b/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.sql\nnew file mode 100644\nindex 000000000000..5955dee37f8f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.sql\n@@ -0,0 +1,91 @@\n+SELECT MAX(aggr)\n+FROM \n+(\n+\tSELECT MAX(-1) AS aggr\n+\tFROM system.one\n+\tWHERE NOT 1\n+\tUNION ALL\n+\tSELECT MAX(-1) AS aggr\n+\tFROM system.one\n+\tWHERE 1\n+\n+);\n+SELECT MaX(aggr)\n+FROM \n+(\n+    SELECT mAX(-1) AS aggr\n+    FROM system.one\n+    WHERE NOT 1\n+    UNION ALL\n+    SELECT MAx(-1) AS aggr\n+    FROM system.one\n+    WHERE 1\n+);\n+SELECT MaX(aggr)\n+FROM \n+(\n+    SELECT mAX(-1) AS aggr\n+    FROM system.one\n+    WHERE NOT 1\n+    UNION ALL\n+    SELECT max(-1) AS aggr\n+    FROM system.one\n+    WHERE 1\n+);\n+SELECT MaX(aggr)\n+FROM \n+(\n+    SELECT mAX(-1) AS aggr\n+    FROM system.one\n+    WHERE NOT 1\n+    UNION ALL\n+    SELECT max(-1) AS aggr\n+    FROM system.one\n+    WHERE not 1\n+);\n+SET aggregate_functions_null_for_empty=1;\n+SELECT MAX(aggr)\n+FROM \n+(\n+\tSELECT MAX(-1) AS aggr\n+\tFROM system.one\n+\tWHERE NOT 1\n+\tUNION ALL\n+\tSELECT MAX(-1) AS aggr\n+\tFROM system.one\n+\tWHERE 1\n+\n+);\n+SELECT MaX(aggr)\n+FROM \n+(\n+    SELECT mAX(-1) AS aggr\n+    FROM system.one\n+    WHERE NOT 1\n+    UNION ALL\n+    SELECT MAx(-1) AS aggr\n+    FROM system.one\n+    WHERE 1\n+);\n+SELECT MaX(aggr)\n+FROM \n+(\n+    SELECT mAX(-1) AS aggr\n+    FROM system.one\n+    WHERE NOT 1\n+    UNION ALL\n+    SELECT max(-1) AS aggr\n+    FROM system.one\n+    WHERE 1\n+);\n+SELECT MaX(aggr)\n+FROM \n+(\n+    SELECT mAX(-1) AS aggr\n+    FROM system.one\n+    WHERE NOT 1\n+    UNION ALL\n+    SELECT max(-1) AS aggr\n+    FROM system.one\n+    WHERE not 1\n+);\ndiff --git a/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.reference b/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.reference\nnew file mode 100644\nindex 000000000000..6fd1fc6c5722\n--- /dev/null\n+++ b/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.reference\n@@ -0,0 +1,5 @@\n+1\n+1\n+1\n+1\n+\\N\ndiff --git a/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.sql b/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.sql\nnew file mode 100644\nindex 000000000000..096ba663923a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.sql\n@@ -0,0 +1,5 @@\n+SELECT Sum(1);\n+SELECT SumOrNull(1);\n+SELECT SUMOrNull(1);\n+SELECT SUMOrNullIf(1, 1);\n+SELECT SUMOrNullIf(1, 0);\n",
  "problem_statement": "Add setting `aggregate_functions_null_for_empty`\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- New Feature\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\n\r\nAdd setting `aggregate_functions_null_for_empty`, this option will rewrite all aggregate functions in a query, adding -OrNull suffix to them. fix [10273](https://github.com/ClickHouse/ClickHouse/issues/10273)\r\n\r\nDetailed description / Documentation draft:\r\n\r\n...\r\n\r\nBy adding documentation, you'll allow users to try your new feature immediately, not when someone else will have time to document it later. Documentation is necessary for all features that affect user experience in any way. You can add brief documentation draft above, or add documentation right into your patch as Markdown files in [docs](https://github.com/ClickHouse/ClickHouse/tree/master/docs) folder.\r\n\r\nIf you are doing this for the first time, it's recommended to read the lightweight [Contributing to ClickHouse Documentation](https://github.com/ClickHouse/ClickHouse/tree/master/docs/README.md) guide first.\r\n\r\n\r\nInformation about CI checks: https://clickhouse.tech/docs/en/development/continuous-integration/\r\n\n",
  "hints_text": "It leads to 6x performance drop even if the argument is not nullable:\r\n\r\n```\r\nmilovidov-desktop :) SELECT sum(number) FROM system.numbers\r\n\r\nSELECT sum(number)\r\nFROM system.numbers\r\n\r\nQuery id: 2f21a1b4-c469-4a0b-a8ed-e86efe2edd43\r\n\r\nCancelling query.\r\nOk.\r\nQuery was cancelled.\r\n\r\n0 rows in set. Elapsed: 2.906 sec. Processed 8.84 billion rows, 70.74 GB (3.04 billion rows/s., 24.34 GB/s.) \r\n\r\nmilovidov-desktop :) SELECT sumOrNull(number) FROM system.numbers\r\n\r\nSELECT sumOrNull(number)\r\nFROM system.numbers\r\n\r\nQuery id: 06dda4aa-9168-41fe-8d2d-63f7857e44fb\r\n\r\nCancelling query.\r\nOk.\r\nQuery was cancelled.\r\n\r\n0 rows in set. Elapsed: 4.409 sec. Processed 2.20 billion rows, 17.59 GB (498.66 million rows/s., 3.99 GB/s.)\r\n```\nPlease cherry-pick this commit: c7618ea\r\nI reordered the settings and removed some of the obsolete settings.\nIt's tricky that the function `count` and `count(DISTINCT ...)` and some other functions have to continue to return zero value when `aggregate_functions_null_for_empty` is enabled (if we aim for SQL compatibility), in contrast to countOrNull, uniqExactOrNull, etc...\nIt is controlled by `AggregateFunctionProperties`.\n> It's tricky that the function `count` and `count(DISTINCT ...)` and some other functions have to continue to return zero value when `aggregate_functions_null_for_empty` is enabled (if we aim for SQL compatibility), in contrast to countOrNull, uniqExactOrNull, etc...\r\n\r\nSo, what is the best way to resolve this?\nLook at the function properties (from AggregateFunctionFactory) and don't rewrite functions that should not return NULL.\n@ucasFL We forgot about one little thing...\r\n\r\nFor -State and -Merge functions we need to add -OrNull before, not after...\r\nNeed to check how it will work.",
  "created_at": "2020-11-07T04:18:43Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionFactory.cpp",
    "src/AggregateFunctions/AggregateFunctionFactory.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.reference",
    "b/tests/queries/0_stateless/01559_aggregate_null_for_empty_fix.sql",
    "b/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.reference",
    "b/tests/queries/0_stateless/01560_cancel_agg_func_combinator_native_name_constraint.sql"
  ]
}