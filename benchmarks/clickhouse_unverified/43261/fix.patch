diff --git a/src/Analyzer/ConstantNode.cpp b/src/Analyzer/ConstantNode.cpp
index ce3774a9bc4c..28b2f5a0ed07 100644
--- a/src/Analyzer/ConstantNode.cpp
+++ b/src/Analyzer/ConstantNode.cpp
@@ -48,7 +48,7 @@ void ConstantNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state
 
     if (getSourceExpression())
     {
-        buffer << '
' << std::string(indent + 2, ' ') << "EXPRESSION " << '
';
+        buffer << '
' << std::string(indent + 2, ' ') << "EXPRESSION" << '
';
         getSourceExpression()->dumpTreeImpl(buffer, format_state, indent + 4);
     }
 }
diff --git a/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp
new file mode 100644
index 000000000000..a61a2388d765
--- /dev/null
+++ b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp
@@ -0,0 +1,113 @@
+#include <Analyzer/Passes/OptimizeGroupByFunctionKeysPass.h>
+#include <Analyzer/FunctionNode.h>
+#include <Analyzer/HashUtils.h>
+#include <Analyzer/IQueryTreeNode.h>
+#include <Analyzer/InDepthQueryTreeVisitor.h>
+#include <Analyzer/QueryNode.h>
+
+#include <algorithm>
+#include <queue>
+
+namespace DB
+{
+
+class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitor<OptimizeGroupByFunctionKeysVisitor>
+{
+public:
+    static bool needChildVisit(QueryTreeNodePtr & /*parent*/, QueryTreeNodePtr & child)
+    {
+        return !child->as<FunctionNode>();
+    }
+
+    static void visitImpl(QueryTreeNodePtr & node)
+    {
+        auto * query = node->as<QueryNode>();
+        if (!query)
+            return;
+
+        if (!query->hasGroupBy())
+            return;
+
+        auto & group_by = query->getGroupBy().getNodes();
+        if (query->isGroupByWithGroupingSets())
+        {
+            for (auto & set : group_by)
+            {
+                auto & grouping_set = set->as<ListNode>()->getNodes();
+                optimizeGroupingSet(grouping_set);
+            }
+        }
+        else
+            optimizeGroupingSet(group_by);
+    }
+private:
+
+    static bool canBeEliminated(QueryTreeNodePtr & node, const QueryTreeNodePtrWithHashSet & group_by_keys)
+    {
+        auto * function = node->as<FunctionNode>();
+        if (!function || function->getArguments().getNodes().empty())
+            return false;
+
+        QueryTreeNodes candidates;
+        auto & function_arguments = function->getArguments().getNodes();
+        for (auto it = function_arguments.rbegin(); it != function_arguments.rend(); ++it)
+            candidates.push_back(*it);
+
+        // Using DFS we traverse function tree and try to find if it uses other keys as function arguments.
+        // TODO: Also process CONSTANT here. We can simplify GROUP BY x, x + 1 to GROUP BY x.
+        while (!candidates.empty())
+        {
+            auto candidate = candidates.back();
+            candidates.pop_back();
+
+            bool found = group_by_keys.contains(candidate);
+
+            switch (candidate->getNodeType())
+            {
+                case QueryTreeNodeType::FUNCTION:
+                {
+                    auto * func = candidate->as<FunctionNode>();
+                    auto & arguments = func->getArguments().getNodes();
+                    if (arguments.empty())
+                        return false;
+
+                    if (!found)
+                    {
+                        for (auto it = arguments.rbegin(); it != arguments.rend(); ++it)
+                            candidates.push_back(*it);
+                    }
+                    break;
+                }
+                case QueryTreeNodeType::COLUMN:
+                    if (!found)
+                        return false;
+                    break;
+                default:
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    static void optimizeGroupingSet(QueryTreeNodes & grouping_set)
+    {
+        QueryTreeNodePtrWithHashSet group_by_keys(grouping_set.begin(), grouping_set.end());
+
+        QueryTreeNodes new_group_by_keys;
+        new_group_by_keys.reserve(grouping_set.size());
+        for (auto & group_by_elem : grouping_set)
+        {
+            if (!canBeEliminated(group_by_elem, group_by_keys))
+                new_group_by_keys.push_back(group_by_elem);
+        }
+
+        grouping_set = std::move(new_group_by_keys);
+    }
+};
+
+void OptimizeGroupByFunctionKeysPass::run(QueryTreeNodePtr query_tree_node, ContextPtr /*context*/)
+{
+    OptimizeGroupByFunctionKeysVisitor().visit(query_tree_node);
+}
+
+}
diff --git a/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.h b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.h
new file mode 100644
index 000000000000..632960c45bbb
--- /dev/null
+++ b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include <Analyzer/IQueryTreePass.h>
+
+namespace DB
+{
+
+/* Eliminates functions of other keys in GROUP BY section.
+ * Ex.:    GROUP BY x, f(x)
+ * Output: GROUP BY x
+ */
+class OptimizeGroupByFunctionKeysPass final : public IQueryTreePass
+{
+public:
+    String getName() override { return "OptimizeGroupByFunctionKeys"; }
+
+    String getDescription() override { return "Eliminates functions of other keys in GROUP BY section."; }
+
+    void run(QueryTreeNodePtr query_tree_node, ContextPtr context) override;
+};
+
+}
diff --git a/src/Analyzer/QueryTreePassManager.cpp b/src/Analyzer/QueryTreePassManager.cpp
index 4a1ab74130df..bbcea363dcb2 100644
--- a/src/Analyzer/QueryTreePassManager.cpp
+++ b/src/Analyzer/QueryTreePassManager.cpp
@@ -27,6 +27,7 @@
 #include <Analyzer/Passes/UniqInjectiveFunctionsEliminationPass.h>
 #include <Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.h>
 #include <Analyzer/Passes/FuseFunctionsPass.h>
+#include <Analyzer/Passes/OptimizeGroupByFunctionKeysPass.h>
 #include <Analyzer/Passes/IfTransformStringsToEnumPass.h>
 #include <Analyzer/Passes/OptimizeRedundantFunctionsInOrderByPass.h>
 
@@ -125,7 +126,6 @@ class ValidationChecker : public InDepthQueryTreeVisitor<ValidationChecker>
   * TODO: Support setting optimize_using_constraints.
   * TODO: Support setting optimize_substitute_columns.
   * TODO: Support GROUP BY injective function elimination.
-  * TODO: Support GROUP BY functions of other keys elimination.
   * TODO: Support setting optimize_move_functions_out_of_any.
   * TODO: Support setting optimize_aggregators_of_group_by_keys.
   * TODO: Support setting optimize_duplicate_order_by_and_distinct.
@@ -232,6 +232,9 @@ void addQueryTreePasses(QueryTreePassManager & manager)
     if (settings.optimize_injective_functions_inside_uniq)
         manager.addPass(std::make_unique<UniqInjectiveFunctionsEliminationPass>());
 
+    if (settings.optimize_group_by_function_keys)
+        manager.addPass(std::make_unique<OptimizeGroupByFunctionKeysPass>());
+
     if (settings.optimize_multiif_to_if)
         manager.addPass(std::make_unique<MultiIfToIfPass>());
 
