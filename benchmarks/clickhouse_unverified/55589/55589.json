{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55589,
  "instance_id": "ClickHouse__ClickHouse-55589",
  "issue_numbers": [
    "54794"
  ],
  "base_commit": "a47cff19811f8d1c25798a91040a8a3902196cfa",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 0602cf31c58e..9b6eba9b5f00 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -587,20 +587,22 @@ The two-argument form of `toDayOfWeek()` enables you to specify whether the week\n | 2    | Sunday            | 0-6: Sunday = 0, Monday = 1, ..., Saturday = 6 |\n | 3    | Sunday            | 1-7: Sunday = 1, Monday = 2, ..., Saturday = 7 |\n \n-Alias: `DAYOFWEEK`.\n-\n **Syntax**\n \n ``` sql\n toDayOfWeek(t[, mode[, timezone]])\n ```\n \n+Alias: `DAYOFWEEK`.\n+\n **Arguments**\n \n - `t` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n - `mode` - determines what the first day of the week is. Possible values are 0, 1, 2 or 3. See the table above for the differences.\n - `timezone` - optional parameter, it behaves like any other conversion function\n \n+The first argument can also be specified as [String](../data-types/string.md) in a format supported by [parseDateTime64BestEffort()](type-conversion-functions.md#parsedatetime64besteffort). Support for string arguments exists only for reasons of compatibility with MySQL which is expected by certain 3rd party tools. As string argument support may in future be made dependent on new MySQL-compatibility settings and because string parsing is generally slow, it is recommended to not use it.\n+\n **Returned value**\n \n - The day of the month (1 - 31) of the given date/time\n@@ -1489,12 +1491,16 @@ For mode values with a meaning of \u201ccontains January 1\u201d, the week contains Ja\n toWeek(t[, mode[, time_zone]])\n ```\n \n+Alias: `WEEK`\n+\n **Arguments**\n \n - `t` \u2013 Date or DateTime.\n - `mode` \u2013 Optional parameter, Range of values is \\[0,9\\], default is 0.\n - `Timezone` \u2013 Optional parameter, it behaves like any other conversion function.\n \n+The first argument can also be specified as [String](../data-types/string.md) in a format supported by [parseDateTime64BestEffort()](type-conversion-functions.md#parsedatetime64besteffort). Support for string arguments exists only for reasons of compatibility with MySQL which is expected by certain 3rd party tools. As string argument support may in future be made dependent on new MySQL-compatibility settings and because string parsing is generally slow, it is recommended to not use it.\n+\n **Example**\n \n ``` sql\n@@ -1525,6 +1531,10 @@ The week number returned by `toYearWeek()` can be different from what the `toWee\n toYearWeek(t[, mode[, timezone]])\n ```\n \n+Alias: `YEARWEEK`\n+\n+The first argument can also be specified as [String](../data-types/string.md) in a format supported by [parseDateTime64BestEffort()](type-conversion-functions.md#parsedatetime64besteffort). Support for string arguments exists only for reasons of compatibility with MySQL which is expected by certain 3rd party tools. As string argument support may in future be made dependent on new MySQL-compatibility settings and because string parsing is generally slow, it is recommended to not use it.\n+\n **Example**\n \n ``` sql\ndiff --git a/src/Functions/CustomWeekTransforms.h b/src/Functions/CustomWeekTransforms.h\nindex 2a82912d5d6f..b8d25cc30b63 100644\n--- a/src/Functions/CustomWeekTransforms.h\n+++ b/src/Functions/CustomWeekTransforms.h\n@@ -1,18 +1,19 @@\n #pragma once\n \n+#include <Columns/ColumnString.h>\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnsNumber.h>\n-#include <base/types.h>\n+#include <Common/DateLUTImpl.h>\n+#include <Common/Exception.h>\n #include <Core/DecimalFunctions.h>\n+#include <DataTypes/DataTypeString.h>\n #include <Functions/DateTimeTransforms.h>\n #include <Functions/FunctionHelpers.h>\n-#include <Functions/extractTimeZoneFromFunctionArguments.h>\n #include <Functions/IFunction.h>\n-#include <Common/Exception.h>\n-#include <Common/DateLUTImpl.h>\n-\n-/// The default mode value to use for the WEEK() function\n-#define DEFAULT_WEEK_MODE 0\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n+#include <IO/ReadBufferFromString.h>\n+#include <IO/parseDateTimeBestEffort.h>\n+#include <base/types.h>\n \n \n namespace DB\n@@ -22,132 +23,6 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n }\n \n-/**\n- * CustomWeek Transformations.\n-  */\n-\n-struct ToYearWeekImpl\n-{\n-    static constexpr auto name = \"toYearWeek\";\n-\n-    static inline UInt32 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        // TODO: ditch toDayNum()\n-        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n-        return yw.first * 100 + yw.second;\n-    }\n-\n-    static inline UInt32 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n-        return yw.first * 100 + yw.second;\n-    }\n-    static inline UInt32 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        YearWeek yw = time_zone.toYearWeek(ExtendedDayNum (d), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n-        return yw.first * 100 + yw.second;\n-    }\n-    static inline UInt32 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        YearWeek yw = time_zone.toYearWeek(DayNum(d), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n-        return yw.first * 100 + yw.second;\n-    }\n-\n-    using FactorTransform = ZeroTransform;\n-};\n-\n-struct ToStartOfWeekImpl\n-{\n-    static constexpr auto name = \"toStartOfWeek\";\n-\n-    static inline UInt16 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n-    }\n-    static inline UInt16 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n-    }\n-    static inline UInt16 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d), week_mode);\n-    }\n-    static inline UInt16 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toFirstDayNumOfWeek(DayNum(d), week_mode);\n-    }\n-    static inline Int64 executeExtendedResult(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n-    }\n-    static inline Int32 executeExtendedResult(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d), week_mode);\n-    }\n-\n-    using FactorTransform = ZeroTransform;\n-};\n-\n-struct ToLastDayOfWeekImpl\n-{\n-    static constexpr auto name = \"toLastDayOfWeek\";\n-\n-    static inline UInt16 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toLastDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n-    }\n-    static inline UInt16 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toLastDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n-    }\n-    static inline UInt16 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toLastDayNumOfWeek(ExtendedDayNum(d), week_mode);\n-    }\n-    static inline UInt16 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toLastDayNumOfWeek(DayNum(d), week_mode);\n-    }\n-    static inline Int64 executeExtendedResult(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toLastDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n-    }\n-    static inline Int32 executeExtendedResult(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        return time_zone.toLastDayNumOfWeek(ExtendedDayNum(d), week_mode);\n-    }\n-\n-    using FactorTransform = ZeroTransform;\n-};\n-\n-struct ToWeekImpl\n-{\n-    static constexpr auto name = \"toWeek\";\n-\n-    static inline UInt8 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        // TODO: ditch conversion to DayNum, since it doesn't support extended range.\n-        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode);\n-        return yw.second;\n-    }\n-    static inline UInt8 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode);\n-        return yw.second;\n-    }\n-    static inline UInt8 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        YearWeek yw = time_zone.toYearWeek(ExtendedDayNum(d), week_mode);\n-        return yw.second;\n-    }\n-    static inline UInt8 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n-    {\n-        YearWeek yw = time_zone.toYearWeek(DayNum(d), week_mode);\n-        return yw.second;\n-    }\n-\n-    using FactorTransform = ToStartOfYearImpl;\n-};\n \n template <typename FromType, typename ToType, typename Transform, bool is_extended_result = false>\n struct WeekTransformer\n@@ -157,8 +32,7 @@ struct WeekTransformer\n     {}\n \n     template <typename FromVectorType, typename ToVectorType>\n-    void\n-    vector(const FromVectorType & vec_from, ToVectorType & vec_to, UInt8 week_mode, const DateLUTImpl & time_zone) const\n+    void vector(const FromVectorType & vec_from, ToVectorType & vec_to, UInt8 week_mode, const DateLUTImpl & time_zone) const\n     {\n         using ValueType = typename ToVectorType::value_type;\n         size_t size = vec_from.size();\n@@ -186,7 +60,8 @@ struct CustomWeekTransformImpl\n     {\n         const auto op = WeekTransformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform, is_extended_result>{std::move(transform)};\n \n-        UInt8 week_mode = DEFAULT_WEEK_MODE;\n+        static constexpr UInt8 default_week_mode = 0;\n+        UInt8 week_mode = default_week_mode;\n         if (arguments.size() > 1)\n         {\n             if (const auto * week_mode_column = checkAndGetColumnConst<ColumnUInt8>(arguments[1].column.get()))\n@@ -195,7 +70,26 @@ struct CustomWeekTransformImpl\n \n         const DateLUTImpl & time_zone = extractTimeZoneFromFunctionArguments(arguments, 2, 0);\n         const ColumnPtr source_col = arguments[0].column;\n-        if (const auto * sources = checkAndGetColumn<typename FromDataType::ColumnType>(source_col.get()))\n+\n+        if constexpr (std::is_same_v<FromDataType, DataTypeString>)\n+        {\n+            static const DateLUTImpl & utc_time_zone = DateLUT::instance(\"UTC\");\n+            const auto * sources = checkAndGetColumn<DataTypeString::ColumnType>(source_col.get());\n+\n+            auto col_to = ToDataType::ColumnType::create();\n+            col_to->getData().resize(sources->size());\n+\n+            for (size_t i = 0; i < sources->size(); ++i)\n+            {\n+                DateTime64 dt64;\n+                ReadBufferFromString buf(sources->getDataAt(i).toView());\n+                parseDateTime64BestEffort(dt64, 0, buf, time_zone, utc_time_zone);\n+                col_to->getData()[i] = static_cast<ToDataType::FieldType>(transform.execute(dt64, week_mode, time_zone));\n+            }\n+\n+            return col_to;\n+        }\n+        else if (const auto * sources = checkAndGetColumn<typename FromDataType::ColumnType>(source_col.get()))\n         {\n             auto col_to = ToDataType::ColumnType::create();\n             op.vector(sources->getData(), col_to->getData(), week_mode, time_zone);\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 3a729cfe39f6..ad1f6694185c 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -305,6 +305,132 @@ struct ToStartOfYearImpl\n     using FactorTransform = ZeroTransform;\n };\n \n+struct ToYearWeekImpl\n+{\n+    static constexpr auto name = \"toYearWeek\";\n+    static constexpr bool value_may_be_string = true;\n+\n+    static UInt32 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        // TODO: ditch toDayNum()\n+        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n+        return yw.first * 100 + yw.second;\n+    }\n+\n+    static UInt32 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n+        return yw.first * 100 + yw.second;\n+    }\n+    static UInt32 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        YearWeek yw = time_zone.toYearWeek(ExtendedDayNum (d), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n+        return yw.first * 100 + yw.second;\n+    }\n+    static UInt32 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        YearWeek yw = time_zone.toYearWeek(DayNum(d), week_mode | static_cast<UInt32>(WeekModeFlag::YEAR));\n+        return yw.first * 100 + yw.second;\n+    }\n+\n+    using FactorTransform = ZeroTransform;\n+};\n+\n+struct ToStartOfWeekImpl\n+{\n+    static constexpr auto name = \"toStartOfWeek\";\n+    static constexpr bool value_may_be_string = false;\n+\n+    static UInt16 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static UInt16 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static UInt16 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d), week_mode);\n+    }\n+    static UInt16 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(DayNum(d), week_mode);\n+    }\n+    static Int64 executeExtendedResult(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static Int32 executeExtendedResult(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d), week_mode);\n+    }\n+\n+    using FactorTransform = ZeroTransform;\n+};\n+\n+struct ToLastDayOfWeekImpl\n+{\n+    static constexpr auto name = \"toLastDayOfWeek\";\n+    static constexpr bool value_may_be_string = false;\n+\n+    static UInt16 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static UInt16 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static UInt16 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfWeek(ExtendedDayNum(d), week_mode);\n+    }\n+    static UInt16 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfWeek(DayNum(d), week_mode);\n+    }\n+    static Int64 executeExtendedResult(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfWeek(time_zone.toDayNum(t), week_mode);\n+    }\n+    static Int32 executeExtendedResult(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toLastDayNumOfWeek(ExtendedDayNum(d), week_mode);\n+    }\n+\n+    using FactorTransform = ZeroTransform;\n+};\n+\n+struct ToWeekImpl\n+{\n+    static constexpr auto name = \"toWeek\";\n+    static constexpr bool value_may_be_string = true;\n+\n+    static UInt8 execute(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        // TODO: ditch conversion to DayNum, since it doesn't support extended range.\n+        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode);\n+        return yw.second;\n+    }\n+    static UInt8 execute(UInt32 t, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        YearWeek yw = time_zone.toYearWeek(time_zone.toDayNum(t), week_mode);\n+        return yw.second;\n+    }\n+    static UInt8 execute(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        YearWeek yw = time_zone.toYearWeek(ExtendedDayNum(d), week_mode);\n+        return yw.second;\n+    }\n+    static UInt8 execute(UInt16 d, UInt8 week_mode, const DateLUTImpl & time_zone)\n+    {\n+        YearWeek yw = time_zone.toYearWeek(DayNum(d), week_mode);\n+        return yw.second;\n+    }\n+\n+    using FactorTransform = ToStartOfYearImpl;\n+};\n \n template <IntervalKind::Kind unit>\n struct ToStartOfInterval;\n@@ -1176,6 +1302,7 @@ struct ToDayOfMonthImpl\n struct ToDayOfWeekImpl\n {\n     static constexpr auto name = \"toDayOfWeek\";\n+    static constexpr bool value_may_be_string = true;\n \n     static UInt8 execute(Int64 t, UInt8 mode, const DateLUTImpl & time_zone)\n     {\ndiff --git a/src/Functions/FunctionCustomWeekToDateOrDate32.h b/src/Functions/FunctionCustomWeekToDateOrDate32.h\nindex cb1ae77de997..c904bfaec304 100644\n--- a/src/Functions/FunctionCustomWeekToDateOrDate32.h\n+++ b/src/Functions/FunctionCustomWeekToDateOrDate32.h\n@@ -16,19 +16,19 @@ class FunctionCustomWeekToDateOrDate32 : public IFunctionCustomWeek<Transform>\n     const bool enable_extended_results_for_datetime_functions = false;\n \n public:\n-    static FunctionPtr create(ContextPtr context_)\n+    static FunctionPtr create(ContextPtr context)\n     {\n-        return std::make_shared<FunctionCustomWeekToDateOrDate32>(context_);\n+        return std::make_shared<FunctionCustomWeekToDateOrDate32>(context);\n     }\n \n-    explicit FunctionCustomWeekToDateOrDate32(ContextPtr context_)\n-        : enable_extended_results_for_datetime_functions(context_->getSettingsRef().enable_extended_results_for_datetime_functions)\n+    explicit FunctionCustomWeekToDateOrDate32(ContextPtr context)\n+        : enable_extended_results_for_datetime_functions(context->getSettingsRef().enable_extended_results_for_datetime_functions)\n     {\n     }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ true);\n+        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ true, Transform::value_may_be_string);\n \n         const IDataType * from_type = arguments[0].type.get();\n         WhichDataType which(from_type);\n@@ -44,16 +44,13 @@ class FunctionCustomWeekToDateOrDate32 : public IFunctionCustomWeek<Transform>\n         WhichDataType which(from_type);\n \n         if (which.isDate())\n-            return CustomWeekTransformImpl<DataTypeDate, DataTypeDate>::execute(\n-                arguments, result_type, input_rows_count, Transform{});\n+            return CustomWeekTransformImpl<DataTypeDate, DataTypeDate>::execute(arguments, result_type, input_rows_count, Transform{});\n         else if (which.isDate32())\n         {\n             if (enable_extended_results_for_datetime_functions)\n-                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate32, /*is_extended_result*/ true>::execute(\n-                    arguments, result_type, input_rows_count, Transform{});\n+                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate32, /*is_extended_result*/ true>::execute(arguments, result_type, input_rows_count, Transform{});\n             else\n-                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate>::execute(\n-                    arguments, result_type, input_rows_count, Transform{});\n+                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate>::execute(arguments, result_type, input_rows_count, Transform{});\n         }\n         else if (which.isDateTime())\n             return CustomWeekTransformImpl<DataTypeDateTime, DataTypeDate>::execute(\n@@ -61,14 +58,14 @@ class FunctionCustomWeekToDateOrDate32 : public IFunctionCustomWeek<Transform>\n         else if (which.isDateTime64())\n         {\n             if (enable_extended_results_for_datetime_functions)\n-                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate32, /*is_extended_result*/ true>::execute(\n-                    arguments, result_type, input_rows_count,\n+                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate32, /*is_extended_result*/ true>::execute(arguments, result_type, input_rows_count,\n                     TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});\n             else\n-                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate>::execute(\n-                    arguments, result_type, input_rows_count,\n+                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate>::execute(arguments, result_type, input_rows_count,\n                     TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});\n         }\n+        else if (Transform::value_may_be_string && which.isString())\n+            return CustomWeekTransformImpl<DataTypeString, DataTypeDate>::execute(arguments, result_type, input_rows_count, Transform{}); // TODO\n         else\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type {} of argument of function {}\",\ndiff --git a/src/Functions/FunctionCustomWeekToSomething.h b/src/Functions/FunctionCustomWeekToSomething.h\nindex 7a23747d8a0e..a631a0118cb2 100644\n--- a/src/Functions/FunctionCustomWeekToSomething.h\n+++ b/src/Functions/FunctionCustomWeekToSomething.h\n@@ -19,8 +19,7 @@ class FunctionCustomWeekToSomething : public IFunctionCustomWeek<Transform>\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        this->checkArguments(arguments);\n-\n+        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ false, Transform::value_may_be_string);\n         return std::make_shared<ToDataType>();\n     }\n \n@@ -30,20 +29,16 @@ class FunctionCustomWeekToSomething : public IFunctionCustomWeek<Transform>\n         WhichDataType which(from_type);\n \n         if (which.isDate())\n-            return CustomWeekTransformImpl<DataTypeDate, ToDataType>::execute(\n-                arguments, result_type, input_rows_count, Transform{});\n+            return CustomWeekTransformImpl<DataTypeDate, ToDataType>::execute(arguments, result_type, input_rows_count, Transform{});\n         else if (which.isDate32())\n-            return CustomWeekTransformImpl<DataTypeDate32, ToDataType>::execute(\n-                arguments, result_type, input_rows_count, Transform{});\n+            return CustomWeekTransformImpl<DataTypeDate32, ToDataType>::execute(arguments, result_type, input_rows_count, Transform{});\n         else if (which.isDateTime())\n-            return CustomWeekTransformImpl<DataTypeDateTime, ToDataType>::execute(\n-                arguments, result_type, input_rows_count, Transform{});\n+            return CustomWeekTransformImpl<DataTypeDateTime, ToDataType>::execute(arguments, result_type, input_rows_count, Transform{});\n         else if (which.isDateTime64())\n-        {\n-            return CustomWeekTransformImpl<DataTypeDateTime64, ToDataType>::execute(\n-                arguments, result_type, input_rows_count,\n+            return CustomWeekTransformImpl<DataTypeDateTime64, ToDataType>::execute(arguments, result_type, input_rows_count,\n                 TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});\n-        }\n+        else if (Transform::value_may_be_string && which.isString())\n+            return CustomWeekTransformImpl<DataTypeString, ToDataType>::execute(arguments, result_type, input_rows_count, Transform{});\n         else\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type {} of argument of function {}\",\ndiff --git a/src/Functions/IFunctionCustomWeek.h b/src/Functions/IFunctionCustomWeek.h\nindex 8f34108dcb4c..51542c9cab18 100644\n--- a/src/Functions/IFunctionCustomWeek.h\n+++ b/src/Functions/IFunctionCustomWeek.h\n@@ -65,41 +65,47 @@ class IFunctionCustomWeek : public IFunction\n     }\n \n protected:\n-    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32 = false) const\n+    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32, bool value_may_be_string) const\n     {\n         if (arguments.size() == 1)\n         {\n-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+            auto type0 = arguments[0].type;\n+            if (!isDate(type0) && !isDate32(type0) && !isDateTime(type0) && !isDateTime64(type0) && !(value_may_be_string && isString(type0)))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of argument of function {}. Must be Date, Date32, DateTime or DateTime64.\",\n-                    arguments[0].type->getName(), getName());\n+                    type0->getName(), getName());\n         }\n         else if (arguments.size() == 2)\n         {\n-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+            auto type0 = arguments[0].type;\n+            auto type1 = arguments[1].type;\n+            if (!isDate(type0) && !isDate32(type0) && !isDateTime(type0) && !isDateTime64(type0) && !(value_may_be_string && isString(type0)))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of 1st argument of function {}. Must be Date, Date32, DateTime or DateTime64.\",\n-                    arguments[0].type->getName(), getName());\n-            if (!isUInt8(arguments[1].type))\n+                    type0->getName(), getName());\n+            if (!isUInt8(type1))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of 2nd (optional) argument of function {}. Must be constant UInt8 (week mode).\",\n-                    arguments[1].type->getName(), getName());\n+                    type1->getName(), getName());\n         }\n         else if (arguments.size() == 3)\n         {\n-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+            auto type0 = arguments[0].type;\n+            auto type1 = arguments[1].type;\n+            auto type2 = arguments[2].type;\n+            if (!isDate(type0) && !isDate32(type0) && !isDateTime(type0) && !isDateTime64(type0) && !(value_may_be_string && isString(type0)))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of argument of function {}. Must be Date, Date32, DateTime or DateTime64\",\n-                    arguments[0].type->getName(), getName());\n-            if (!isUInt8(arguments[1].type))\n+                    type0->getName(), getName());\n+            if (!isUInt8(type1))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of 2nd (optional) argument of function {}. Must be constant UInt8 (week mode).\",\n-                    arguments[1].type->getName(), getName());\n-            if (!isString(arguments[2].type))\n+                    type1->getName(), getName());\n+            if (!isString(type2))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of 3rd (optional) argument of function {}. Must be constant string (timezone name).\",\n-                    arguments[2].type->getName(), getName());\n-            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && is_result_type_date_or_date32)\n+                    type2->getName(), getName());\n+            if (is_result_type_date_or_date32 && (isDate(type0) || isDate32(type0)))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"The timezone argument of function {} is allowed only when the 1st argument is DateTime or DateTime64.\",\n                     getName());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01661_week_functions_string_args.reference b/tests/queries/0_stateless/01661_week_functions_string_args.reference\nnew file mode 100644\nindex 000000000000..9bb1118928a5\n--- /dev/null\n+++ b/tests/queries/0_stateless/01661_week_functions_string_args.reference\n@@ -0,0 +1,17 @@\n+-- Constant argument\n+3\t3\t3\t3\n+24\t24\t24\t24\n+201624\t201624\t201624\t201624\n+-- Non-constant argument\n+3\t3\t3\t3\t3\t3\n+7\t7\t7\t7\t7\t7\n+1\t1\t1\t1\t1\t1\n+4\t4\t4\t4\t4\t4\n+37\t37\t37\t37\t37\t37\n+39\t39\t39\t39\t39\t39\n+4\t4\t4\t4\t4\t4\n+7\t7\t7\t7\t7\t7\n+201737\t201737\t201737\t201737\t201737\t201737\n+201739\t201739\t201739\t201739\t201739\t201739\n+201804\t201804\t201804\t201804\t201804\t201804\n+201907\t201907\t201907\t201907\t201907\t201907\ndiff --git a/tests/queries/0_stateless/01661_week_functions_string_args.sql b/tests/queries/0_stateless/01661_week_functions_string_args.sql\nnew file mode 100644\nindex 000000000000..f0e14d989524\n--- /dev/null\n+++ b/tests/queries/0_stateless/01661_week_functions_string_args.sql\n@@ -0,0 +1,40 @@\n+-- Tests that functions `toDayOfWeek()`, 'toWeek()' and 'toYearWeek()' accepts a date given as string (for compatibility with MySQL)\n+\n+SELECT '-- Constant argument';\n+\n+SELECT toDayOfWeek(toDateTime('2016-06-15 23:00:00')), toDayOfWeek('2016-06-15'), toDayOfWeek('2016-06-15 23:00:00'), toDayOfWeek('2016-06-15 23:00:00.123456');\n+SELECT toWeek(toDateTime('2016-06-15 23:00:00')), toWeek('2016-06-15'), toWeek('2016-06-15 23:00:00'), toWeek('2016-06-15 23:00:00.123456');\n+SELECT toYearWeek(toDateTime('2016-06-15 23:00:00')), toYearWeek('2016-06-15'), toYearWeek('2016-06-15 23:00:00'), toYearWeek('2016-06-15 23:00:00.123456');\n+\n+SELECT toDayOfWeek('invalid'); -- { serverError CANNOT_PARSE_DATETIME }\n+SELECT toWeek('invalid'); -- { serverError CANNOT_PARSE_DATETIME }\n+SELECT toYearWeek('invalid'); -- { serverError CANNOT_PARSE_DATETIME }\n+\n+SELECT '-- Non-constant argument';\n+\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab\n+(\n+    d        Date,\n+    dt       DateTime('UTC'),\n+    dt64     DateTime64(6, 'UTC'),\n+    str_d    String,\n+    str_dt   String,\n+    str_dt64 String,\n+    invalid  String\n+) ENGINE MergeTree ORDER BY dt;\n+\n+INSERT INTO `tab` VALUES (toDate('2017-09-13'), toDateTime('2017-09-13 19:10:22', 'UTC'), toDateTime64('2017-09-13 19:10:22.123456', 6, 'UTC'), '2017-09-13', '2017-09-13 19:10:22', '2017-09-13 19:10:22.123456', 'foo');\n+INSERT INTO `tab` VALUES (toDate('2017-09-24'), toDateTime('2017-09-24 12:05:34', 'UTC'), toDateTime64('2017-09-24 12:05:34.123456', 6, 'UTC'), '2017-09-24', '2017-09-24 12:05:34', '2017-09-24 12:05:34.123456', 'bar');\n+INSERT INTO `tab` VALUES (toDate('2018-01-29'), toDateTime('2018-01-29 02:09:48', 'UTC'), toDateTime64('2018-01-29 02:09:48.123456', 6, 'UTC'), '2018-01-29', '2018-01-29 02:09:48', '2018-01-29 02:09:48.123456', 'qaz');\n+INSERT INTO `tab` VALUES (toDate('2019-02-21'), toDateTime('2019-02-21 15:07:43', 'UTC'), toDateTime64('2019-02-21 15:07:43.123456', 6, 'UTC'), '2019-02-21', '2019-02-21 15:07:43', '2019-02-21 15:07:43.123456', 'qux');\n+\n+SELECT toDayOfWeek(d), toDayOfWeek(dt), toDayOfWeek(dt64), toDayOfWeek(str_d), toDayOfWeek(str_dt), toDayOfWeek(str_dt64) FROM tab ORDER BY d;\n+SELECT toWeek(d), toWeek(dt), toWeek(dt64), toWeek(str_d), toWeek(str_dt), toWeek(str_dt64) FROM tab ORDER BY d;\n+SELECT toYearWeek(d), toYearWeek(dt), toYearWeek(dt64), toYearWeek(str_d), toYearWeek(str_dt), toYearWeek(str_dt64) FROM tab ORDER BY d;\n+\n+SELECT toDayOfWeek(invalid) FROM `tab`; -- { serverError CANNOT_PARSE_DATETIME }\n+SELECT toWeek(invalid) FROM `tab`; -- { serverError CANNOT_PARSE_DATETIME }\n+SELECT toYearWeek(invalid) FROM `tab`; -- { serverError CANNOT_PARSE_DATETIME }\n+\n+DROP TABLE tab;\n",
  "problem_statement": "MySQL compatibility: Illegal type String of argument of function toDayOfWeek\nRequired for Tableau Online. \r\n\r\nSample rendered query:\r\n\r\n```sql\r\nSELECT FLOOR(((((7 + DAYOFYEAR(cell_towers.updated)) - 1) +\r\n               DAYOFWEEK(DATE_FORMAT(cell_towers.updated, '%Y-01-01 00:00:00'))) - 1) / 7) AS wk_updated_ok\r\nFROM cell_towers\r\nGROUP BY 1;\r\n```\r\n\r\nfails with\r\n\r\n```\r\nDB::Exception: Illegal type String of argument of function toDayOfWeek. Must be Date, Date32, DateTime or DateTime64.: In scope SELECT FLOOR(((((7 + DAYOFYEAR(cell_towers.updated)) - 1) + DAYOFWEEK(DATE_FORMAT(cell_towers.updated, '%Y-01-01 00:00:00'))) - 1) / 7) AS wk_updated_ok FROM cell_towers GROUP BY 1. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use: latest master\r\n* Which interface to use, if matters: MySQL\r\n* Sample data for all these tables: cell_towers sample dataset\r\n\r\n**Expected behavior**\r\n\r\nDAYOFWEEK accepts String argument like in MySQL.\n",
  "hints_text": "",
  "created_at": "2023-10-13T10:33:51Z",
  "modified_files": [
    "docs/en/sql-reference/functions/date-time-functions.md",
    "src/Functions/CustomWeekTransforms.h",
    "src/Functions/DateTimeTransforms.h",
    "src/Functions/FunctionCustomWeekToDateOrDate32.h",
    "src/Functions/FunctionCustomWeekToSomething.h",
    "src/Functions/IFunctionCustomWeek.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01661_week_functions_string_args.reference",
    "b/tests/queries/0_stateless/01661_week_functions_string_args.sql"
  ]
}