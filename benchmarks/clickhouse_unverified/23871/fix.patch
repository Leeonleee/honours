diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index 3e635b2acccf..7c91d4ee89b2 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -794,7 +794,101 @@ bool ParserCodec::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     return true;
 }
 
-bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+ASTPtr createFunctionCast(const ASTPtr & expr_ast, const ASTPtr & type_ast)
+{
+    /// Convert to canonical representation in functional form: CAST(expr, 'type')
+    auto type_literal = std::make_shared<ASTLiteral>(queryToString(type_ast));
+
+    auto expr_list_args = std::make_shared<ASTExpressionList>();
+    expr_list_args->children.push_back(expr_ast);
+    expr_list_args->children.push_back(std::move(type_literal));
+
+    auto func_node = std::make_shared<ASTFunction>();
+    func_node->name = "CAST";
+    func_node->arguments = std::move(expr_list_args);
+    func_node->children.push_back(func_node->arguments);
+
+    return func_node;
+}
+
+template <TokenType ...tokens>
+static bool isOneOf(TokenType token)
+{
+    return ((token == tokens) || ...);
+}
+
+
+bool ParserCastOperator::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    /// Parse numbers (including decimals), strings and arrays of them.
+
+    const char * data_begin = pos->begin;
+    bool is_string_literal = pos->type == TokenType::StringLiteral;
+    if (pos->type == TokenType::Number || is_string_literal)
+    {
+        ++pos;
+    }
+    else if (pos->type == TokenType::OpeningSquareBracket)
+    {
+        TokenType last_token = TokenType::OpeningSquareBracket;
+        while (pos.isValid())
+        {
+            if (pos->type == TokenType::OpeningSquareBracket)
+            {
+                if (!isOneOf<TokenType::OpeningSquareBracket, TokenType::Comma>(last_token))
+                    return false;
+            }
+            else if (pos->type == TokenType::ClosingSquareBracket)
+            {
+                if (last_token == TokenType::Comma)
+                    return false;
+            }
+            else if (pos->type == TokenType::Comma)
+            {
+                if (isOneOf<TokenType::OpeningSquareBracket, TokenType::Comma>(last_token))
+                    return false;
+            }
+            else if (isOneOf<TokenType::Number, TokenType::StringLiteral>(pos->type))
+            {
+                if (!isOneOf<TokenType::OpeningSquareBracket, TokenType::Comma>(last_token))
+                    return false;
+            }
+            else
+            {
+                break;
+            }
+
+            last_token = pos->type;
+            ++pos;
+        }
+    }
+
+    ASTPtr type_ast;
+    const char * data_end = pos->begin;
+
+    if (ParserToken(TokenType::DoubleColon).ignore(pos, expected)
+        && ParserDataType().parse(pos, type_ast, expected))
+    {
+        String s;
+        size_t data_size = data_end - data_begin;
+        if (is_string_literal)
+        {
+            ReadBufferFromMemory buf(data_begin, data_size);
+            readQuotedStringWithSQLStyle(s, buf);
+            assert(buf.count() == data_size);
+        }
+        else
+            s = String(data_begin, data_size);
+
+        auto literal = std::make_shared<ASTLiteral>(std::move(s));
+        node = createFunctionCast(literal, type_ast);
+        return true;
+    }
+
+    return false;
+}
+
+bool ParserCastAsExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     /// Either CAST(expr AS type) or CAST(expr, 'type')
     /// The latter will be parsed normally as a function later.
@@ -809,20 +903,7 @@ bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expect
         && ParserDataType().parse(pos, type_node, expected)
         && ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))
     {
-        /// Convert to canonical representation in functional form: CAST(expr, 'type')
-
-        auto type_literal = std::make_shared<ASTLiteral>(queryToString(type_node));
-
-        auto expr_list_args = std::make_shared<ASTExpressionList>();
-        expr_list_args->children.push_back(expr_node);
-        expr_list_args->children.push_back(std::move(type_literal));
-
-        auto func_node = std::make_shared<ASTFunction>();
-        func_node->name = "CAST";
-        func_node->arguments = std::move(expr_list_args);
-        func_node->children.push_back(func_node->arguments);
-
-        node = std::move(func_node);
+        node = createFunctionCast(expr_node, type_node);
         return true;
     }
 
@@ -1951,12 +2032,13 @@ bool ParserMySQLGlobalVariable::parseImpl(Pos & pos, ASTPtr & node, Expected & e
 bool ParserExpressionElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     return ParserSubquery().parse(pos, node, expected)
+        || ParserCastOperator().parse(pos, node, expected)
         || ParserTupleOfLiterals().parse(pos, node, expected)
         || ParserParenthesisExpression().parse(pos, node, expected)
         || ParserArrayOfLiterals().parse(pos, node, expected)
         || ParserArray().parse(pos, node, expected)
         || ParserLiteral().parse(pos, node, expected)
-        || ParserCastExpression().parse(pos, node, expected)
+        || ParserCastAsExpression().parse(pos, node, expected)
         || ParserExtractExpression().parse(pos, node, expected)
         || ParserDateAddExpression().parse(pos, node, expected)
         || ParserDateDiffExpression().parse(pos, node, expected)
diff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h
index f8b2408ac166..9ba92ad6f665 100644
--- a/src/Parsers/ExpressionElementParsers.h
+++ b/src/Parsers/ExpressionElementParsers.h
@@ -209,10 +209,22 @@ class ParserCodec : public IParserBase
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
 };
 
-class ParserCastExpression : public IParserBase
+/// Fast path of cast operator "::".
+/// It tries to read literal as text.
+/// If it fails, later operator will be transformed to function CAST.
+/// Examples: "0.1::Decimal(38, 38)", "[1, 2]::Array(UInt8)"
+class ParserCastOperator : public IParserBase
 {
 protected:
-    const char * getName() const override { return "CAST expression"; }
+    const char * getName() const override { return "CAST operator"; }
+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
+};
+
+ASTPtr createFunctionCast(const ASTPtr & expr_ast, const ASTPtr & type_ast);
+class ParserCastAsExpression : public IParserBase
+{
+protected:
+    const char * getName() const override { return "CAST AS expression"; }
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
 };
 
diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp
index e9ad65af471a..eec79edc05e7 100644
--- a/src/Parsers/ExpressionListParsers.cpp
+++ b/src/Parsers/ExpressionListParsers.cpp
@@ -3,7 +3,6 @@
 #include <Parsers/ASTExpressionList.h>
 #include <Parsers/ASTFunction.h>
 #include <Parsers/ASTFunctionWithKeyValueArguments.h>
-#include <Parsers/ExpressionElementParsers.h>
 #include <Parsers/ParserCreateQuery.h>
 #include <Parsers/parseIntervalKind.h>
 #include <Common/StringUtils/StringUtils.h>
@@ -558,11 +557,32 @@ bool ParserUnaryMinusExpression::parseImpl(Pos & pos, ASTPtr & node, Expected &
 }
 
 
+bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    ASTPtr expr_ast;
+    if (!elem_parser.parse(pos, expr_ast, expected))
+        return false;
+
+    ASTPtr type_ast;
+    if (ParserToken(TokenType::DoubleColon).ignore(pos, expected)
+        && ParserDataType().parse(pos, type_ast, expected))
+    {
+        node = createFunctionCast(expr_ast, type_ast);
+    }
+    else
+    {
+        node = expr_ast;
+    }
+
+    return true;
+}
+
+
 bool ParserArrayElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected &expected)
 {
     return ParserLeftAssociativeBinaryOperatorList{
         operators,
-        std::make_unique<ParserExpressionElement>(),
+        std::make_unique<ParserCastExpression>(),
         std::make_unique<ParserExpressionWithOptionalAlias>(false)
     }.parse(pos, node, expected);
 }
diff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h
index 2371e006c099..3a65141d7513 100644
--- a/src/Parsers/ExpressionListParsers.h
+++ b/src/Parsers/ExpressionListParsers.h
@@ -6,6 +6,7 @@
 #include <Parsers/CommonParsers.h>
 
 #include <Parsers/ASTSelectWithUnionQuery.h>
+#include <Parsers/ExpressionElementParsers.h>
 #include <Common/IntervalKind.h>
 
 namespace DB
@@ -205,6 +206,20 @@ class ParserPrefixUnaryOperatorExpression : public IParserBase
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
 };
 
+/// CAST operator "::". This parser is used if left argument
+/// of operator cannot be read as simple literal from text of query.
+/// Example: "[1, 1 + 1, 1 + 2]::Array(UInt8)"
+class ParserCastExpression : public IParserBase
+{
+private:
+    ParserExpressionElement elem_parser;
+
+protected:
+    const char * getName() const override { return "CAST expression"; }
+
+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
+};
+
 
 class ParserArrayElementExpression : public IParserBase
 {
diff --git a/src/Parsers/Lexer.cpp b/src/Parsers/Lexer.cpp
index 1fa4d3961133..241abbd98ded 100644
--- a/src/Parsers/Lexer.cpp
+++ b/src/Parsers/Lexer.cpp
@@ -316,7 +316,12 @@ Token Lexer::nextTokenImpl()
         case '?':
             return Token(TokenType::QuestionMark, token_begin, ++pos);
         case ':':
-            return Token(TokenType::Colon, token_begin, ++pos);
+        {
+            ++pos;
+            if (pos < end && *pos == ':')
+                return Token(TokenType::DoubleColon, token_begin, ++pos);
+            return Token(TokenType::Colon, token_begin, pos);
+        }
         case '|':
         {
             ++pos;
diff --git a/src/Parsers/Lexer.h b/src/Parsers/Lexer.h
index dc1c9824b6b9..447964355c87 100644
--- a/src/Parsers/Lexer.h
+++ b/src/Parsers/Lexer.h
@@ -40,6 +40,7 @@ namespace DB
     M(Arrow)                  /** ->. Should be distinguished from minus operator. */ \
     M(QuestionMark) \
     M(Colon) \
+    M(DoubleColon) \
     M(Equals) \
     M(NotEquals) \
     M(Less) \
