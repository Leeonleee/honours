{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62619,
  "instance_id": "ClickHouse__ClickHouse-62619",
  "issue_numbers": [
    "47819"
  ],
  "base_commit": "d8b3b48a25f8b1c33cf2c32f73d10c23a96dc1cd",
  "patch": "diff --git a/docs/en/sql-reference/statements/select/index.md b/docs/en/sql-reference/statements/select/index.md\nindex 86a4e9639f5d..1fea29aa40e3 100644\n--- a/docs/en/sql-reference/statements/select/index.md\n+++ b/docs/en/sql-reference/statements/select/index.md\n@@ -21,6 +21,8 @@ SELECT [DISTINCT [ON (column1, column2, ...)]] expr_list\n [WHERE expr]\n [GROUP BY expr_list] [WITH ROLLUP|WITH CUBE] [WITH TOTALS]\n [HAVING expr]\n+[WINDOW window_expr_list]\n+[QUALIFY expr]\n [ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr] [INTERPOLATE [(expr_list)]]\n [LIMIT [offset_value, ]n BY columns]\n [LIMIT [n, ]m] [WITH TIES]\n@@ -45,6 +47,7 @@ Specifics of each optional clause are covered in separate sections, which are li\n - [GROUP BY clause](../../../sql-reference/statements/select/group-by.md)\n - [LIMIT BY clause](../../../sql-reference/statements/select/limit-by.md)\n - [HAVING clause](../../../sql-reference/statements/select/having.md)\n+- [QUALIFY clause](../../../sql-reference/statements/select/qualify.md)\n - [LIMIT clause](../../../sql-reference/statements/select/limit.md)\n - [OFFSET clause](../../../sql-reference/statements/select/offset.md)\n - [UNION clause](../../../sql-reference/statements/select/union.md)\ndiff --git a/docs/en/sql-reference/statements/select/qualify.md b/docs/en/sql-reference/statements/select/qualify.md\nnew file mode 100644\nindex 000000000000..ccb3fce5efa4\n--- /dev/null\n+++ b/docs/en/sql-reference/statements/select/qualify.md\n@@ -0,0 +1,34 @@\n+---\n+slug: /en/sql-reference/statements/select/qualify\n+sidebar_label: QUALIFY\n+---\n+\n+# QUALIFY Clause\n+\n+Allows filtering window functions results. It is similar to the [WHERE](../../../sql-reference/statements/select/where.md) clause, but the difference is that `WHERE` is performed before window functions evaluation, while `QUALIFY` is performed after it.\n+\n+It is possible to reference window functions results from `SELECT` clause in `QUALIFY` clause by their alias. Alternatively, `QUALIFY` clause can filter on results of additional window functions that are not returned in query results.\n+\n+## Limitations\n+\n+`QUALIFY` can\u2019t be used if there are no window functions to evaluate. Use `WHERE` instead.\n+\n+## Examples\n+\n+Example:\n+\n+``` sql\n+SELECT number, COUNT() OVER (PARTITION BY number % 3) AS partition_count\n+FROM numbers(10)\n+QUALIFY partition_count = 4\n+ORDER BY number;\n+```\n+\n+``` text\n+\u250c\u2500number\u2500\u252c\u2500partition_count\u2500\u2510\n+\u2502      0 \u2502               4 \u2502\n+\u2502      3 \u2502               4 \u2502\n+\u2502      6 \u2502               4 \u2502\n+\u2502      9 \u2502               4 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex 5faf8dd97c0a..a3c60c76132e 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -7895,6 +7895,9 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n     if (query_node_typed.hasHaving() && query_node_typed.isGroupByWithTotals() && is_rollup_or_cube)\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"WITH TOTALS and WITH ROLLUP or CUBE are not supported together in presence of HAVING\");\n \n+    if (query_node_typed.hasQualify() && query_node_typed.isGroupByWithTotals() && is_rollup_or_cube)\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"WITH TOTALS and WITH ROLLUP or CUBE are not supported together in presence of QUALIFY\");\n+\n     /// Initialize aliases in query node scope\n     QueryExpressionsAliasVisitor visitor(scope);\n \n@@ -7919,6 +7922,9 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n     if (query_node_typed.hasWindow())\n         visitor.visit(query_node_typed.getWindowNode());\n \n+    if (query_node_typed.hasQualify())\n+        visitor.visit(query_node_typed.getQualify());\n+\n     if (query_node_typed.hasOrderBy())\n         visitor.visit(query_node_typed.getOrderByNode());\n \n@@ -8067,6 +8073,9 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n     if (query_node_typed.hasWindow())\n         resolveWindowNodeList(query_node_typed.getWindowNode(), scope);\n \n+    if (query_node_typed.hasQualify())\n+        resolveExpressionNode(query_node_typed.getQualify(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+\n     if (query_node_typed.hasOrderBy())\n     {\n         replaceNodesWithPositionalArguments(query_node_typed.getOrderByNode(), query_node_typed.getProjection().getNodes(), scope);\ndiff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex f1361c328dbf..c0659e1998ba 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -197,6 +197,12 @@ void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s\n         getWindow().dumpTreeImpl(buffer, format_state, indent + 4);\n     }\n \n+    if (hasQualify())\n+    {\n+        buffer << '\\n' << std::string(indent + 2, ' ') << \"QUALIFY\\n\";\n+        getQualify()->dumpTreeImpl(buffer, format_state, indent + 4);\n+    }\n+\n     if (hasOrderBy())\n     {\n         buffer << '\\n' << std::string(indent + 2, ' ') << \"ORDER BY\\n\";\n@@ -381,6 +387,9 @@ ASTPtr QueryNode::toASTImpl(const ConvertToASTOptions & options) const\n     if (hasWindow())\n         select_query->setExpression(ASTSelectQuery::Expression::WINDOW, getWindow().toAST(options));\n \n+    if (hasQualify())\n+        select_query->setExpression(ASTSelectQuery::Expression::QUALIFY, getQualify()->toAST(options));\n+\n     if (hasOrderBy())\n         select_query->setExpression(ASTSelectQuery::Expression::ORDER_BY, getOrderBy().toAST(options));\n \ndiff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h\nindex af187df72a80..efabf604730b 100644\n--- a/src/Analyzer/QueryNode.h\n+++ b/src/Analyzer/QueryNode.h\n@@ -416,6 +416,24 @@ class QueryNode final : public IQueryTreeNode\n         return children[window_child_index];\n     }\n \n+    /// Returns true if query node QUALIFY section is not empty, false otherwise\n+    bool hasQualify() const\n+    {\n+        return getQualify() != nullptr;\n+    }\n+\n+    /// Get QUALIFY section node\n+    const QueryTreeNodePtr & getQualify() const\n+    {\n+        return children[qualify_child_index];\n+    }\n+\n+    /// Get QUALIFY section node\n+    QueryTreeNodePtr & getQualify()\n+    {\n+        return children[qualify_child_index];\n+    }\n+\n     /// Returns true if query node ORDER BY section is not empty, false otherwise\n     bool hasOrderBy() const\n     {\n@@ -622,13 +640,14 @@ class QueryNode final : public IQueryTreeNode\n     static constexpr size_t group_by_child_index = 5;\n     static constexpr size_t having_child_index = 6;\n     static constexpr size_t window_child_index = 7;\n-    static constexpr size_t order_by_child_index = 8;\n-    static constexpr size_t interpolate_child_index = 9;\n-    static constexpr size_t limit_by_limit_child_index = 10;\n-    static constexpr size_t limit_by_offset_child_index = 11;\n-    static constexpr size_t limit_by_child_index = 12;\n-    static constexpr size_t limit_child_index = 13;\n-    static constexpr size_t offset_child_index = 14;\n+    static constexpr size_t qualify_child_index = 8;\n+    static constexpr size_t order_by_child_index = 9;\n+    static constexpr size_t interpolate_child_index = 10;\n+    static constexpr size_t limit_by_limit_child_index = 11;\n+    static constexpr size_t limit_by_offset_child_index = 12;\n+    static constexpr size_t limit_by_child_index = 13;\n+    static constexpr size_t limit_child_index = 14;\n+    static constexpr size_t offset_child_index = 15;\n     static constexpr size_t children_size = offset_child_index + 1;\n };\n \ndiff --git a/src/Analyzer/QueryTreeBuilder.cpp b/src/Analyzer/QueryTreeBuilder.cpp\nindex a4f204724320..876e583d3937 100644\n--- a/src/Analyzer/QueryTreeBuilder.cpp\n+++ b/src/Analyzer/QueryTreeBuilder.cpp\n@@ -330,6 +330,10 @@ QueryTreeNodePtr QueryTreeBuilder::buildSelectExpression(const ASTPtr & select_q\n     if (window_list)\n         current_query_tree->getWindowNode() = buildWindowList(window_list, current_context);\n \n+    auto qualify_expression = select_query_typed.qualify();\n+    if (qualify_expression)\n+        current_query_tree->getQualify() = buildExpression(qualify_expression, current_context);\n+\n     auto select_order_by_list = select_query_typed.orderBy();\n     if (select_order_by_list)\n         current_query_tree->getOrderByNode() = buildSortList(select_order_by_list, current_context);\ndiff --git a/src/Analyzer/ValidationUtils.cpp b/src/Analyzer/ValidationUtils.cpp\nindex af35632ab81f..60cc1dd521fe 100644\n--- a/src/Analyzer/ValidationUtils.cpp\n+++ b/src/Analyzer/ValidationUtils.cpp\n@@ -56,6 +56,9 @@ void validateFilters(const QueryTreeNodePtr & query_node)\n \n     if (query_node_typed.hasHaving())\n         validateFilter(query_node_typed.getHaving(), \"HAVING\", query_node);\n+\n+    if (query_node_typed.hasQualify())\n+        validateFilter(query_node_typed.getQualify(), \"QUALIFY\", query_node);\n }\n \n namespace\ndiff --git a/src/Client/Suggest.cpp b/src/Client/Suggest.cpp\nindex f63dbc64d271..ebfa2e89ea1d 100644\n--- a/src/Client/Suggest.cpp\n+++ b/src/Client/Suggest.cpp\n@@ -47,7 +47,7 @@ Suggest::Suggest()\n               \"GRANT\",        \"REVOKE\",        \"OPTION\",       \"ADMIN\",      \"EXCEPT\",   \"REPLACE\",     \"IDENTIFIED\", \"HOST\",\n               \"NAME\",         \"READONLY\",      \"WRITABLE\",     \"PERMISSIVE\", \"FOR\",      \"RESTRICTIVE\", \"RANDOMIZED\", \"INTERVAL\",\n               \"LIMITS\",       \"ONLY\",          \"TRACKING\",     \"IP\",         \"REGEXP\",   \"ILIKE\",       \"CLEANUP\",    \"APPEND\",\n-              \"IGNORE NULLS\", \"RESPECT NULLS\", \"OVER\",         \"PASTE\"});\n+              \"IGNORE NULLS\", \"RESPECT NULLS\", \"OVER\",         \"PASTE\",      \"WINDOW\",   \"QUALIFY\"});\n }\n \n static String getLoadSuggestionQuery(Int32 suggestion_limit, bool basic_suggestion)\ndiff --git a/src/Parsers/ASTSelectQuery.cpp b/src/Parsers/ASTSelectQuery.cpp\nindex 586477e1cfdc..f99933b79692 100644\n--- a/src/Parsers/ASTSelectQuery.cpp\n+++ b/src/Parsers/ASTSelectQuery.cpp\n@@ -144,6 +144,12 @@ void ASTSelectQuery::formatImpl(const FormatSettings & s, FormatState & state, F\n         window()->as<ASTExpressionList &>().formatImplMultiline(s, state, frame);\n     }\n \n+    if (qualify())\n+    {\n+        s.ostr << (s.hilite ? hilite_keyword : \"\") << s.nl_or_ws << indent_str << \"QUALIFY \" << (s.hilite ? hilite_none : \"\");\n+        qualify()->formatImpl(s, state, frame);\n+    }\n+\n     if (!order_by_all && orderBy())\n     {\n         s.ostr << (s.hilite ? hilite_keyword : \"\") << s.nl_or_ws << indent_str << \"ORDER BY\" << (s.hilite ? hilite_none : \"\");\ndiff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h\nindex eb171dc00ee7..9fd6becbaaab 100644\n--- a/src/Parsers/ASTSelectQuery.h\n+++ b/src/Parsers/ASTSelectQuery.h\n@@ -25,6 +25,7 @@ class ASTSelectQuery : public IAST\n         GROUP_BY,\n         HAVING,\n         WINDOW,\n+        QUALIFY,\n         ORDER_BY,\n         LIMIT_BY_OFFSET,\n         LIMIT_BY_LENGTH,\n@@ -55,6 +56,8 @@ class ASTSelectQuery : public IAST\n                 return \"HAVING\";\n             case Expression::WINDOW:\n                 return \"WINDOW\";\n+            case Expression::QUALIFY:\n+                return \"QUALIFY\";\n             case Expression::ORDER_BY:\n                 return \"ORDER BY\";\n             case Expression::LIMIT_BY_OFFSET:\n@@ -95,6 +98,7 @@ class ASTSelectQuery : public IAST\n     ASTPtr & refPrewhere()  { return getExpression(Expression::PREWHERE); }\n     ASTPtr & refWhere()     { return getExpression(Expression::WHERE); }\n     ASTPtr & refHaving()    { return getExpression(Expression::HAVING); }\n+    ASTPtr & refQualify()    { return getExpression(Expression::QUALIFY); }\n \n     ASTPtr with()           const { return getExpression(Expression::WITH); }\n     ASTPtr select()         const { return getExpression(Expression::SELECT); }\n@@ -104,6 +108,7 @@ class ASTSelectQuery : public IAST\n     ASTPtr groupBy()        const { return getExpression(Expression::GROUP_BY); }\n     ASTPtr having()         const { return getExpression(Expression::HAVING); }\n     ASTPtr window()         const { return getExpression(Expression::WINDOW); }\n+    ASTPtr qualify()         const { return getExpression(Expression::QUALIFY); }\n     ASTPtr orderBy()        const { return getExpression(Expression::ORDER_BY); }\n     ASTPtr limitByOffset()  const { return getExpression(Expression::LIMIT_BY_OFFSET); }\n     ASTPtr limitByLength()  const { return getExpression(Expression::LIMIT_BY_LENGTH); }\n@@ -113,7 +118,7 @@ class ASTSelectQuery : public IAST\n     ASTPtr settings()       const { return getExpression(Expression::SETTINGS); }\n     ASTPtr interpolate()    const { return getExpression(Expression::INTERPOLATE); }\n \n-    bool hasFiltration() const { return where() || prewhere() || having(); }\n+    bool hasFiltration() const { return where() || prewhere() || having() || qualify(); }\n \n     /// Set/Reset/Remove expression.\n     void setExpression(Expression expr, ASTPtr && ast);\ndiff --git a/src/Parsers/CommonParsers.h b/src/Parsers/CommonParsers.h\nindex 2277e348b0f2..12c452d38c44 100644\n--- a/src/Parsers/CommonParsers.h\n+++ b/src/Parsers/CommonParsers.h\n@@ -507,6 +507,7 @@ namespace DB\n     MR_MACROS(WHEN, \"WHEN\") \\\n     MR_MACROS(WHERE, \"WHERE\") \\\n     MR_MACROS(WINDOW, \"WINDOW\") \\\n+    MR_MACROS(QUALIFY, \"QUALIFY\") \\\n     MR_MACROS(WITH_ADMIN_OPTION, \"WITH ADMIN OPTION\") \\\n     MR_MACROS(WITH_CHECK, \"WITH CHECK\") \\\n     MR_MACROS(WITH_FILL, \"WITH FILL\") \\\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex dce0bc62d5b5..a483ac92f394 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -1481,6 +1481,7 @@ const char * ParserAlias::restricted_keywords[] =\n     \"USING\",\n     \"WHERE\",\n     \"WINDOW\",\n+    \"QUALIFY\",\n     \"WITH\",\n     \"INTERSECT\",\n     \"EXCEPT\",\ndiff --git a/src/Parsers/ParserSelectQuery.cpp b/src/Parsers/ParserSelectQuery.cpp\nindex ce15c7b03fd8..e1ded0ab902a 100644\n--- a/src/Parsers/ParserSelectQuery.cpp\n+++ b/src/Parsers/ParserSelectQuery.cpp\n@@ -49,6 +49,7 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ParserKeyword s_totals(Keyword::TOTALS);\n     ParserKeyword s_having(Keyword::HAVING);\n     ParserKeyword s_window(Keyword::WINDOW);\n+    ParserKeyword s_qualify(Keyword::QUALIFY);\n     ParserKeyword s_order_by(Keyword::ORDER_BY);\n     ParserKeyword s_limit(Keyword::LIMIT);\n     ParserKeyword s_settings(Keyword::SETTINGS);\n@@ -86,6 +87,7 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ASTPtr group_expression_list;\n     ASTPtr having_expression;\n     ASTPtr window_list;\n+    ASTPtr qualify_expression;\n     ASTPtr order_expression_list;\n     ASTPtr interpolate_expression_list;\n     ASTPtr limit_by_length;\n@@ -266,6 +268,13 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         }\n     }\n \n+    /// QUALIFY expr\n+    if (s_qualify.ignore(pos, expected))\n+    {\n+        if (!exp_elem.parse(pos, qualify_expression, expected))\n+            return false;\n+    }\n+\n     /// ORDER BY expr ASC|DESC COLLATE 'locale' list\n     if (s_order_by.ignore(pos, expected))\n     {\n@@ -489,6 +498,7 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     select_query->setExpression(ASTSelectQuery::Expression::GROUP_BY, std::move(group_expression_list));\n     select_query->setExpression(ASTSelectQuery::Expression::HAVING, std::move(having_expression));\n     select_query->setExpression(ASTSelectQuery::Expression::WINDOW, std::move(window_list));\n+    select_query->setExpression(ASTSelectQuery::Expression::QUALIFY, std::move(qualify_expression));\n     select_query->setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(order_expression_list));\n     select_query->setExpression(ASTSelectQuery::Expression::LIMIT_BY_OFFSET, std::move(limit_by_offset));\n     select_query->setExpression(ASTSelectQuery::Expression::LIMIT_BY_LENGTH, std::move(limit_by_length));\ndiff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp\nindex d75573c8d999..b21dd5203e82 100644\n--- a/src/Planner/Planner.cpp\n+++ b/src/Planner/Planner.cpp\n@@ -1367,6 +1367,16 @@ void Planner::buildPlanForQueryNode()\n     select_query_info.has_aggregates = hasAggregateFunctionNodes(query_tree);\n     select_query_info.need_aggregate = query_node.hasGroupBy() || select_query_info.has_aggregates;\n \n+    if (!select_query_info.has_window && query_node.hasQualify())\n+    {\n+        if (query_node.hasHaving())\n+            query_node.getHaving() = mergeConditionNodes({query_node.getHaving(), query_node.getQualify()}, query_context);\n+        else\n+            query_node.getHaving() = query_node.getQualify();\n+\n+        query_node.getQualify() = {};\n+    }\n+\n     if (!select_query_info.need_aggregate && query_node.hasHaving())\n     {\n         if (query_node.hasWhere())\n@@ -1636,6 +1646,9 @@ void Planner::buildPlanForQueryNode()\n                 addWindowSteps(query_plan, planner_context, window_analysis_result);\n             }\n \n+            if (expression_analysis_result.hasQualify())\n+                addFilterStep(query_plan, expression_analysis_result.getQualify(), \"QUALIFY\", result_actions_to_execute);\n+\n             const auto & projection_analysis_result = expression_analysis_result.getProjection();\n             addExpressionStep(query_plan, projection_analysis_result.projection_actions, \"Projection\", result_actions_to_execute);\n \ndiff --git a/src/Planner/PlannerExpressionAnalysis.cpp b/src/Planner/PlannerExpressionAnalysis.cpp\nindex dd3769ee10b4..ad8db83d66c4 100644\n--- a/src/Planner/PlannerExpressionAnalysis.cpp\n+++ b/src/Planner/PlannerExpressionAnalysis.cpp\n@@ -513,6 +513,16 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n     if (window_analysis_result_optional)\n         current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n \n+    std::optional<FilterAnalysisResult> qualify_analysis_result_optional;\n+    std::optional<size_t> qualify_action_step_index_optional;\n+\n+    if (query_node.hasQualify())\n+    {\n+        qualify_analysis_result_optional = analyzeFilter(query_node.getQualify(), current_output_columns, planner_context, actions_chain);\n+        qualify_action_step_index_optional = actions_chain.getLastStepIndex();\n+        current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n+    }\n+\n     auto projection_analysis_result = analyzeProjection(query_node, current_output_columns, planner_context, actions_chain);\n     current_output_columns = actions_chain.getLastStepAvailableOutputColumns();\n \n@@ -604,7 +614,7 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n \n     PlannerExpressionsAnalysisResult expressions_analysis_result(std::move(projection_analysis_result));\n \n-    if (where_action_step_index_optional && where_analysis_result_optional)\n+    if (where_analysis_result_optional && where_action_step_index_optional)\n     {\n         auto & where_analysis_result = *where_analysis_result_optional;\n         auto & where_actions_chain_node = actions_chain.at(*where_action_step_index_optional);\n@@ -615,7 +625,7 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n     if (aggregation_analysis_result_optional)\n         expressions_analysis_result.addAggregation(std::move(*aggregation_analysis_result_optional));\n \n-    if (having_action_step_index_optional && having_analysis_result_optional)\n+    if (having_analysis_result_optional && having_action_step_index_optional)\n     {\n         auto & having_analysis_result = *having_analysis_result_optional;\n         auto & having_actions_chain_node = actions_chain.at(*having_action_step_index_optional);\n@@ -626,6 +636,14 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNo\n     if (window_analysis_result_optional)\n         expressions_analysis_result.addWindow(std::move(*window_analysis_result_optional));\n \n+    if (qualify_analysis_result_optional && qualify_action_step_index_optional)\n+    {\n+        auto & qualify_analysis_result = *qualify_analysis_result_optional;\n+        auto & qualify_actions_chain_node = actions_chain.at(*qualify_action_step_index_optional);\n+        qualify_analysis_result.remove_filter_column = !qualify_actions_chain_node->getChildRequiredOutputColumnsNames().contains(qualify_analysis_result.filter_column_name);\n+        expressions_analysis_result.addQualify(std::move(qualify_analysis_result));\n+    }\n+\n     if (sort_analysis_result_optional)\n         expressions_analysis_result.addSort(std::move(*sort_analysis_result_optional));\n \ndiff --git a/src/Planner/PlannerExpressionAnalysis.h b/src/Planner/PlannerExpressionAnalysis.h\nindex 792cfdec2ffe..0773272e49a9 100644\n--- a/src/Planner/PlannerExpressionAnalysis.h\n+++ b/src/Planner/PlannerExpressionAnalysis.h\n@@ -129,6 +129,21 @@ class PlannerExpressionsAnalysisResult\n         window_analysis_result = std::move(window_analysis_result_);\n     }\n \n+    bool hasQualify() const\n+    {\n+        return qualify_analysis_result.filter_actions != nullptr;\n+    }\n+\n+    const FilterAnalysisResult & getQualify() const\n+    {\n+        return qualify_analysis_result;\n+    }\n+\n+    void addQualify(FilterAnalysisResult qualify_analysis_result_)\n+    {\n+        qualify_analysis_result = std::move(qualify_analysis_result_);\n+    }\n+\n     bool hasSort() const\n     {\n         return sort_analysis_result.before_order_by_actions != nullptr;\n@@ -165,6 +180,7 @@ class PlannerExpressionsAnalysisResult\n     AggregationAnalysisResult aggregation_analysis_result;\n     FilterAnalysisResult having_analysis_result;\n     WindowAnalysisResult window_analysis_result;\n+    FilterAnalysisResult qualify_analysis_result;\n     SortAnalysisResult sort_analysis_result;\n     LimitByAnalysisResult limit_by_analysis_result;\n };\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03035_internal_functions_direct_call.reference b/tests/queries/0_stateless/03035_internal_functions_direct_call.reference\nindex 4dc02ffa71d4..d45b44f6052c 100644\n--- a/tests/queries/0_stateless/03035_internal_functions_direct_call.reference\n+++ b/tests/queries/0_stateless/03035_internal_functions_direct_call.reference\n@@ -1,5 +1,4 @@\n aaa\n-(1,1)\t(1,1)\n 1\n a1\t1\n 1\ndiff --git a/tests/queries/0_stateless/03035_internal_functions_direct_call.sql b/tests/queries/0_stateless/03035_internal_functions_direct_call.sql\nindex d90c4dceab5d..951e0733dbb8 100644\n--- a/tests/queries/0_stateless/03035_internal_functions_direct_call.sql\n+++ b/tests/queries/0_stateless/03035_internal_functions_direct_call.sql\n@@ -16,8 +16,6 @@ SELECT __getScalar(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n SELECT __getScalar(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT __getScalar(materialize('1')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n \n-WITH ( SELECT (1,1) ) as a SELECT materialize(a), __getScalar('17789833925953107877_7493841889429261611') SETTINGS allow_experimental_analyzer = 1;\n-\n SELECT __scalarSubqueryResult('1');\n SELECT 'a' || __scalarSubqueryResult(a), materialize('1') as a;\n SELECT __scalarSubqueryResult(a, a), materialize('1') as a; -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\ndiff --git a/tests/queries/0_stateless/03095_window_functions_qualify.reference b/tests/queries/0_stateless/03095_window_functions_qualify.reference\nnew file mode 100644\nindex 000000000000..c74a212428ba\n--- /dev/null\n+++ b/tests/queries/0_stateless/03095_window_functions_qualify.reference\n@@ -0,0 +1,74 @@\n+0\t4\n+3\t4\n+6\t4\n+9\t4\n+--\n+0\n+3\n+6\n+9\n+--\n+6\n+7\n+8\n+9\n+--\n+0\t5\n+--\n+0\t5\n+--\n+0\t4\n+3\t4\n+6\t4\n+9\t4\n+--\n+Expression (Project names)\n+Header: number UInt64\n+        partition_count UInt64\n+Actions: INPUT : 0 -> __table1.number UInt64 : 0\n+         INPUT : 1 -> count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64 : 1\n+         ALIAS __table1.number :: 0 -> number UInt64 : 2\n+         ALIAS count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) :: 1 -> partition_count UInt64 : 0\n+Positions: 2 0\n+  Sorting (Sorting for ORDER BY)\n+  Header: __table1.number UInt64\n+          count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64\n+  Sort description: __table1.number ASC\n+    Expression ((Before ORDER BY + Projection))\n+    Header: __table1.number UInt64\n+            count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64\n+    Actions: INPUT :: 0 -> __table1.number UInt64 : 0\n+             INPUT :: 1 -> count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64 : 1\n+    Positions: 0 1\n+      Filter (QUALIFY)\n+      Header: __table1.number UInt64\n+              count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64\n+      Filter column: equals(count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)), 4_UInt8) (removed)\n+      Actions: INPUT :: 0 -> __table1.number UInt64 : 0\n+               INPUT :: 1 -> count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64 : 1\n+               INPUT : 2 -> count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64 : 2\n+               COLUMN Const(UInt8) -> 4_UInt8 UInt8 : 3\n+               FUNCTION equals(count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) :: 2, 4_UInt8 :: 3) -> equals(count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)), 4_UInt8) UInt8 : 4\n+      Positions: 4 0 1\n+        Window (Window step for window \\'PARTITION BY modulo(__table1.number, 3_UInt8)\\')\n+        Header: modulo(__table1.number, 3_UInt8) UInt8\n+                __table1.number UInt64\n+                count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64\n+                count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8)) UInt64\n+        Window: (PARTITION BY modulo(__table1.number, 3_UInt8))\n+        Functions: count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8))\n+                   count() OVER (PARTITION BY modulo(__table1.number, 3_UInt8))\n+          Sorting (Sorting for window \\'PARTITION BY modulo(__table1.number, 3_UInt8)\\')\n+          Header: modulo(__table1.number, 3_UInt8) UInt8\n+                  __table1.number UInt64\n+          Sort description: modulo(__table1.number, 3_UInt8) ASC\n+            Expression ((Before WINDOW + Change column names to column identifiers))\n+            Header: modulo(__table1.number, 3_UInt8) UInt8\n+                    __table1.number UInt64\n+            Actions: INPUT : 0 -> number UInt64 : 0\n+                     COLUMN Const(UInt8) -> 3_UInt8 UInt8 : 1\n+                     ALIAS number :: 0 -> __table1.number UInt64 : 2\n+                     FUNCTION modulo(__table1.number : 2, 3_UInt8 :: 1) -> modulo(__table1.number, 3_UInt8) UInt8 : 0\n+            Positions: 0 2\n+              ReadFromSystemNumbers\n+              Header: number UInt64\ndiff --git a/tests/queries/0_stateless/03095_window_functions_qualify.sql b/tests/queries/0_stateless/03095_window_functions_qualify.sql\nnew file mode 100644\nindex 000000000000..35e203a2ffcf\n--- /dev/null\n+++ b/tests/queries/0_stateless/03095_window_functions_qualify.sql\n@@ -0,0 +1,36 @@\n+SET allow_experimental_analyzer = 1;\n+\n+SELECT number, COUNT() OVER (PARTITION BY number % 3) AS partition_count FROM numbers(10) QUALIFY partition_count = 4 ORDER BY number;\n+\n+SELECT '--';\n+\n+SELECT number FROM numbers(10) QUALIFY (COUNT() OVER (PARTITION BY number % 3) AS partition_count) = 4 ORDER BY number;\n+\n+SELECT '--';\n+\n+SELECT number FROM numbers(10) QUALIFY number > 5 ORDER BY number;\n+\n+SELECT '--';\n+\n+SELECT (number % 2) AS key, count() FROM numbers(10) GROUP BY key HAVING key = 0 QUALIFY key == 0;\n+\n+SELECT '--';\n+\n+SELECT (number % 2) AS key, count() FROM numbers(10) GROUP BY key QUALIFY key == 0;\n+\n+SELECT '--';\n+\n+SELECT number, COUNT() OVER (PARTITION BY number % 3) AS partition_count FROM numbers(10) QUALIFY COUNT() OVER (PARTITION BY number % 3) = 4 ORDER BY number;\n+\n+SELECT '--';\n+\n+EXPLAIN header = 1, actions = 1\n+SELECT number, COUNT() OVER (PARTITION BY number % 3) AS partition_count FROM numbers(10) QUALIFY COUNT() OVER (PARTITION BY number % 3) = 4 ORDER BY number;\n+\n+SELECT number % toUInt256(2) AS key, count() FROM numbers(10) GROUP BY key WITH CUBE WITH TOTALS QUALIFY key = toNullable(toNullable(0)); -- { serverError 48 }\n+\n+SELECT number % 2 AS key, count(materialize(5)) IGNORE NULLS FROM numbers(10) WHERE toLowCardinality(toLowCardinality(materialize(2))) GROUP BY key WITH CUBE WITH TOTALS QUALIFY key = 0; -- { serverError 48 }\n+\n+SELECT 4, count(4) IGNORE NULLS, number % 2 AS key FROM numbers(10) GROUP BY key WITH ROLLUP WITH TOTALS QUALIFY key = materialize(0); -- { serverError 48 }\n+\n+SELECT 3, number % toLowCardinality(2) AS key, count() IGNORE NULLS FROM numbers(10) GROUP BY key WITH ROLLUP WITH TOTALS QUALIFY key = 0; -- { serverError 48 }\n",
  "problem_statement": "QUALIFY Clause (Just like HAVING but for window functions)\n**Use case**\r\n\r\n```\r\nSELECT <column_list>\r\n  FROM <data_source>\r\n  [GROUP BY ...]\r\n  [HAVING ...]\r\n  QUALIFY <predicate>\r\n  [ ... ]\r\n\r\n\r\n    WITH dense_rank() OVER (ORDER BY number DESC) AS row\r\n    SELECT row\r\n    FROM numbers(10)\r\n    QUALIFY row < 3\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nSubquery\r\n\r\n```\r\nSELECT *\r\nFROM\r\n(\r\n    WITH dense_rank() OVER (ORDER BY number DESC) AS row\r\n    SELECT row\r\n    FROM numbers(10)\r\n)\r\nWHERE row < 3\r\n```\r\n\r\n**Additional context**\r\nhttps://github.com/ClickHouse/ClickHouse/issues/47818\r\n\r\n\r\nhttps://docs.teradata.com/r/2_MC9vCtAJRlKle2Rpb0mA/19NnI91neorAi7LX6SJXBw\r\nhttps://docs.snowflake.com/en/sql-reference/constructs/qualify\n",
  "hints_text": "Would this help with https://github.com/ClickHouse/ClickHouse/issues/35056 ?\nI don't think so.\r\n\r\nYour question is about smart? condition pushdown\r\n\r\n```\r\nSELECT\r\n    count(),\r\n    sum(wf)\r\nFROM\r\n(\r\n    SELECT\r\n        number,\r\n        max(number) OVER (PARTITION BY floor(number / 5)) AS wf\r\n    FROM\r\n    (\r\n        SELECT *\r\n        FROM system.numbers\r\n        LIMIT 100000000.\r\n    )\r\n    ORDER BY number ASC\r\n)\r\nWHERE number = 1\r\n```\r\n\r\nTO\r\n\r\n```\r\nSELECT\r\n    count(),\r\n    sum(wf)\r\nFROM\r\n(\r\n    SELECT\r\n        number,\r\n        max(number) OVER (PARTITION BY floor(number / 5)) AS wf\r\n    FROM\r\n    (\r\n        SELECT *\r\n        FROM system.numbers\r\n        LIMIT 100000000.\r\n    )\r\n    WHERE floor(number / 5) = floor(1 / 5)\r\n    ORDER BY number ASC\r\n)\r\nWHERE number = 1\r\n\r\nQuery id: 6ea32797-31db-48a4-8cc2-cd1cc8332f9d\r\n\r\n\u250c\u2500count()\u2500\u252c\u2500sum(wf)\u2500\u2510\r\n\u2502       1 \u2502       4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.145 sec. Processed 70.64 million rows, 565.13 MB (487.51 million rows/s., 3.90 GB/s.)\r\n```\nJust adding some context I have to bump up this issue. I would really love if ClickHouse added `QUALIFY`. [Snowflake](https://docs.snowflake.com/en/sql-reference/constructs/qualify), [BigQuery](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#qualify_clause), and [DuckDB](https://duckdb.org/docs/sql/query_syntax/qualify.html) have the `QUALIFY` keyword. As an analytics engineer I use it primarily to deduplicate data, like so:\r\n\r\n```\r\nSelect user_id, amount, updated_at\r\nfrom table\r\nqualify row_number() over (partition by user_id order by updated_at desc) = 1\r\n```\r\n\r\nThis query deduplicates the table to get the row with the most recently updated user id. It's handy because it requires no subquery or modification to the main query beyond this single line. If this feature is added I would consider proposing we move my company's data stack to ClickHouse Cloud.",
  "created_at": "2024-04-13T15:49:21Z",
  "modified_files": [
    "docs/en/sql-reference/statements/select/index.md",
    "b/docs/en/sql-reference/statements/select/qualify.md",
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Analyzer/QueryNode.cpp",
    "src/Analyzer/QueryNode.h",
    "src/Analyzer/QueryTreeBuilder.cpp",
    "src/Analyzer/ValidationUtils.cpp",
    "src/Client/Suggest.cpp",
    "src/Parsers/ASTSelectQuery.cpp",
    "src/Parsers/ASTSelectQuery.h",
    "src/Parsers/CommonParsers.h",
    "src/Parsers/ExpressionElementParsers.cpp",
    "src/Parsers/ParserSelectQuery.cpp",
    "src/Planner/Planner.cpp",
    "src/Planner/PlannerExpressionAnalysis.cpp",
    "src/Planner/PlannerExpressionAnalysis.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/03035_internal_functions_direct_call.reference",
    "tests/queries/0_stateless/03035_internal_functions_direct_call.sql",
    "b/tests/queries/0_stateless/03095_window_functions_qualify.reference",
    "b/tests/queries/0_stateless/03095_window_functions_qualify.sql"
  ]
}