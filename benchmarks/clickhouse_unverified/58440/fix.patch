diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 988c4f357e09..9516ef720775 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -157,7 +157,7 @@ class IColumn;
     M(Bool, allow_suspicious_fixed_string_types, false, "In CREATE TABLE statement allows creating columns of type FixedString(n) with n > 256. FixedString with length >= 256 is suspicious and most likely indicates misusage", 0) \
     M(Bool, allow_suspicious_indices, false, "Reject primary/secondary indexes and sorting keys with identical expressions", 0) \
     M(Bool, allow_suspicious_ttl_expressions, false, "Reject TTL expressions that don't depend on any of table's columns. It indicates a user error most of the time.", 0) \
-    M(Bool, compile_expressions, false, "Compile some scalar functions and operators to native code.", 0) \
+    M(Bool, compile_expressions, true, "Compile some scalar functions and operators to native code.", 0) \
     M(UInt64, min_count_to_compile_expression, 3, "The number of identical expressions before they are JIT-compiled", 0) \
     M(Bool, compile_aggregate_expressions, true, "Compile aggregate functions to native code.", 0) \
     M(UInt64, min_count_to_compile_aggregate_expression, 3, "The number of identical aggregate expressions before they are JIT-compiled", 0) \
diff --git a/src/Interpreters/Aggregator.cpp b/src/Interpreters/Aggregator.cpp
index cdc4292a79c0..07c52d50e182 100644
--- a/src/Interpreters/Aggregator.cpp
+++ b/src/Interpreters/Aggregator.cpp
@@ -664,26 +664,26 @@ void Aggregator::compileAggregateFunctionsIfNeeded()
     for (size_t i = 0; i < aggregate_functions.size(); ++i)
     {
         const auto * function = aggregate_functions[i];
-        size_t offset_of_aggregate_function = offsets_of_aggregate_states[i];
+        bool function_is_compilable = function->isCompilable();
+        if (!function_is_compilable)
+            continue;
 
-        if (function->isCompilable())
+        size_t offset_of_aggregate_function = offsets_of_aggregate_states[i];
+        AggregateFunctionWithOffset function_to_compile
         {
-            AggregateFunctionWithOffset function_to_compile
-            {
-                .function = function,
-                .aggregate_data_offset = offset_of_aggregate_function
-            };
+            .function = function,
+            .aggregate_data_offset = offset_of_aggregate_function
+        };
 
-            functions_to_compile.emplace_back(std::move(function_to_compile));
+        functions_to_compile.emplace_back(std::move(function_to_compile));
 
-            functions_description += function->getDescription();
-            functions_description += ' ';
+        functions_description += function->getDescription();
+        functions_description += ' ';
 
-            functions_description += std::to_string(offset_of_aggregate_function);
-            functions_description += ' ';
-        }
+        functions_description += std::to_string(offset_of_aggregate_function);
+        functions_description += ' ';
 
-        is_aggregate_function_compiled[i] = function->isCompilable();
+        is_aggregate_function_compiled[i] = true;
     }
 
     if (functions_to_compile.empty())
@@ -1685,14 +1685,13 @@ bool Aggregator::executeOnBlock(Columns columns,
     /// For the case when there are no keys (all aggregate into one row).
     if (result.type == AggregatedDataVariants::Type::without_key)
     {
-        /// TODO: Enable compilation after investigation
-// #if USE_EMBEDDED_COMPILER
-//         if (compiled_aggregate_functions_holder)
-//         {
-//             executeWithoutKeyImpl<true>(result.without_key, row_begin, row_end, aggregate_functions_instructions.data(), result.aggregates_pool);
-//         }
-//         else
-// #endif
+#if USE_EMBEDDED_COMPILER
+        if (compiled_aggregate_functions_holder && !hasSparseArguments(aggregate_functions_instructions.data()))
+        {
+            executeWithoutKeyImpl<true>(result.without_key, row_begin, row_end, aggregate_functions_instructions.data(), result.aggregates_pool);
+        }
+        else
+#endif
         {
             executeWithoutKeyImpl<false>(result.without_key, row_begin, row_end, aggregate_functions_instructions.data(), result.aggregates_pool);
         }
diff --git a/src/Interpreters/JIT/compileFunction.cpp b/src/Interpreters/JIT/compileFunction.cpp
index f50a122f9a28..1c6b324dad7a 100644
--- a/src/Interpreters/JIT/compileFunction.cpp
+++ b/src/Interpreters/JIT/compileFunction.cpp
@@ -67,7 +67,8 @@ static void compileFunction(llvm::Module & module, const IFunctionBase & functio
 {
     const auto & function_argument_types = function.getArgumentTypes();
 
-    llvm::IRBuilder<> b(module.getContext());
+    auto & context = module.getContext();
+    llvm::IRBuilder<> b(context);
     auto * size_type = b.getIntNTy(sizeof(size_t) * 8);
     auto * data_type = llvm::StructType::get(b.getInt8PtrTy(), b.getInt8PtrTy());
     auto * func_type = llvm::FunctionType::get(b.getVoidTy(), { size_type, data_type->getPointerTo() }, /*isVarArg=*/false);
@@ -75,6 +76,8 @@ static void compileFunction(llvm::Module & module, const IFunctionBase & functio
     /// Create function in module
 
     auto * func = llvm::Function::Create(func_type, llvm::Function::ExternalLinkage, function.getName(), module);
+    func->setAttributes(llvm::AttributeList::get(context, {{2, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));
+
     auto * args = func->args().begin();
     llvm::Value * rows_count_arg = args++;
     llvm::Value * columns_arg = args++;
@@ -196,6 +199,9 @@ static void compileCreateAggregateStatesFunctions(llvm::Module & module, const s
     auto * create_aggregate_states_function_type = llvm::FunctionType::get(b.getVoidTy(), { aggregate_data_places_type }, false);
     auto * create_aggregate_states_function = llvm::Function::Create(create_aggregate_states_function_type, llvm::Function::ExternalLinkage, name, module);
 
+    create_aggregate_states_function->setAttributes(
+        llvm::AttributeList::get(context, {{1, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));
+
     auto * arguments = create_aggregate_states_function->args().begin();
     llvm::Value * aggregate_data_place_arg = arguments++;
 
@@ -241,6 +247,11 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,
     auto * add_into_aggregate_states_func_declaration = llvm::FunctionType::get(b.getVoidTy(), { size_type, size_type, column_type->getPointerTo(), places_type }, false);
     auto * add_into_aggregate_states_func = llvm::Function::Create(add_into_aggregate_states_func_declaration, llvm::Function::ExternalLinkage, name, module);
 
+    add_into_aggregate_states_func->setAttributes(llvm::AttributeList::get(
+        context,
+        {{3, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)},
+         {4, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));
+
     auto * arguments = add_into_aggregate_states_func->args().begin();
     llvm::Value * row_start_arg = arguments++;
     llvm::Value * row_end_arg = arguments++;
@@ -296,7 +307,7 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,
     llvm::Value * aggregation_place = nullptr;
 
     if (places_argument_type == AddIntoAggregateStatesPlacesArgumentType::MultiplePlaces)
-        aggregation_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateGEP(b.getInt8Ty()->getPointerTo(), places_arg, counter_phi));
+        aggregation_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateInBoundsGEP(b.getInt8Ty()->getPointerTo(), places_arg, counter_phi));
     else
         aggregation_place = places_arg;
 
@@ -313,7 +324,7 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,
             auto & column = columns[previous_columns_size + column_argument_index];
             const auto & argument_type = arguments_types[column_argument_index];
 
-            auto * column_data_element = b.CreateLoad(column.data_element_type, b.CreateGEP(column.data_element_type, column.data_ptr, counter_phi));
+            auto * column_data_element = b.CreateLoad(column.data_element_type, b.CreateInBoundsGEP(column.data_element_type, column.data_ptr, counter_phi));
 
             if (!argument_type->isNullable())
             {
@@ -321,7 +332,7 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,
                 continue;
             }
 
-            auto * column_null_data_with_offset = b.CreateGEP(b.getInt8Ty(), column.null_data_ptr, counter_phi);
+            auto * column_null_data_with_offset = b.CreateInBoundsGEP(b.getInt8Ty(), column.null_data_ptr, counter_phi);
             auto * is_null = b.CreateICmpNE(b.CreateLoad(b.getInt8Ty(), column_null_data_with_offset), b.getInt8(0));
             auto * nullable_unitialized = llvm::Constant::getNullValue(toNullableType(b, column.data_element_type));
             auto * first_insert = b.CreateInsertValue(nullable_unitialized, column_data_element, {0});
@@ -354,7 +365,8 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,
 
 static void compileMergeAggregatesStates(llvm::Module & module, const std::vector<AggregateFunctionWithOffset> & functions, const std::string & name)
 {
-    llvm::IRBuilder<> b(module.getContext());
+    auto & context = module.getContext();
+    llvm::IRBuilder<> b(context);
 
     auto * aggregate_data_place_type = b.getInt8Ty()->getPointerTo();
     auto * aggregate_data_places_type = aggregate_data_place_type->getPointerTo();
@@ -365,6 +377,11 @@ static void compileMergeAggregatesStates(llvm::Module & module, const std::vecto
     auto * merge_aggregates_states_func
         = llvm::Function::Create(merge_aggregates_states_func_declaration, llvm::Function::ExternalLinkage, name, module);
 
+    merge_aggregates_states_func->setAttributes(llvm::AttributeList::get(
+        context,
+        {{1, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)},
+         {2, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));
+
     auto * arguments = merge_aggregates_states_func->args().begin();
     llvm::Value * aggregate_data_places_dst_arg = arguments++;
     llvm::Value * aggregate_data_places_src_arg = arguments++;
@@ -426,6 +443,11 @@ static void compileInsertAggregatesIntoResultColumns(llvm::Module & module, cons
     auto * insert_aggregates_into_result_func_declaration = llvm::FunctionType::get(b.getVoidTy(), { size_type, size_type, column_type->getPointerTo(), aggregate_data_places_type }, false);
     auto * insert_aggregates_into_result_func = llvm::Function::Create(insert_aggregates_into_result_func_declaration, llvm::Function::ExternalLinkage, name, module);
 
+    insert_aggregates_into_result_func->setAttributes(llvm::AttributeList::get(
+        context,
+        {{3, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)},
+         {4, llvm::Attribute::get(context, llvm::Attribute::AttrKind::NoAlias)}}));
+
     auto * arguments = insert_aggregates_into_result_func->args().begin();
     llvm::Value * row_start_arg = arguments++;
     llvm::Value * row_end_arg = arguments++;
@@ -460,7 +482,7 @@ static void compileInsertAggregatesIntoResultColumns(llvm::Module & module, cons
     auto * counter_phi = b.CreatePHI(row_start_arg->getType(), 2);
     counter_phi->addIncoming(row_start_arg, entry);
 
-    auto * aggregate_data_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateGEP(b.getInt8Ty()->getPointerTo(), aggregate_data_places_arg, counter_phi));
+    auto * aggregate_data_place = b.CreateLoad(b.getInt8Ty()->getPointerTo(), b.CreateInBoundsGEP(b.getInt8Ty()->getPointerTo(), aggregate_data_places_arg, counter_phi));
 
     for (size_t i = 0; i < functions.size(); ++i)
     {
@@ -470,11 +492,11 @@ static void compileInsertAggregatesIntoResultColumns(llvm::Module & module, cons
         const auto * aggregate_function_ptr = functions[i].function;
         auto * final_value = aggregate_function_ptr->compileGetResult(b, aggregation_place_with_offset);
 
-        auto * result_column_data_element = b.CreateGEP(columns[i].data_element_type, columns[i].data_ptr, counter_phi);
+        auto * result_column_data_element = b.CreateInBoundsGEP(columns[i].data_element_type, columns[i].data_ptr, counter_phi);
         if (columns[i].null_data_ptr)
         {
             b.CreateStore(b.CreateExtractValue(final_value, {0}), result_column_data_element);
-            auto * result_column_is_null_element = b.CreateGEP(b.getInt8Ty(), columns[i].null_data_ptr, counter_phi);
+            auto * result_column_is_null_element = b.CreateInBoundsGEP(b.getInt8Ty(), columns[i].null_data_ptr, counter_phi);
             b.CreateStore(b.CreateSelect(b.CreateExtractValue(final_value, {1}), b.getInt8(1), b.getInt8(0)), result_column_is_null_element);
         }
         else
