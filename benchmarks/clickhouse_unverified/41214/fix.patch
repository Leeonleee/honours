diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index 3869168becd7..dde40acb91a5 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -3145,6 +3145,17 @@ Result:
 └─────┴─────┴───────┘
 ```
 
+## enable_extended_results_for_datetime_functions {#enable-extended-results-for-datetime-functions}
+
+Enables or disables returning results of type `Date32` with extended range (compared to type `Date`) for functions [toStartOfYear](../../sql-reference/functions/date-time-functions.md#tostartofyear), [toStartOfISOYear](../../sql-reference/functions/date-time-functions.md#tostartofisoyear), [toStartOfQuarter](../../sql-reference/functions/date-time-functions.md#tostartofquarter), [toStartOfMonth](../../sql-reference/functions/date-time-functions.md#tostartofmonth), [toStartOfWeek](../../sql-reference/functions/date-time-functions.md#tostartofweek), [toMonday](../../sql-reference/functions/date-time-functions.md#tomonday) and [toLastDayOfMonth](../../sql-reference/functions/date-time-functions.md#tolastdayofmonth).
+
+Possible values:
+
+-   0 — Functions return `Date` for all types of arguments.
+-   1 — Functions return `Date32` for `Date32` or `DateTime64` arguments and `Date` otherwise.
+
+Default value: `0`.
+
 ## optimize_move_to_prewhere {#optimize_move_to_prewhere}
 
 Enables or disables automatic [PREWHERE](../../sql-reference/statements/select/prewhere.md) optimization in [SELECT](../../sql-reference/statements/select/index.md) queries.
@@ -3530,8 +3541,8 @@ desc format(JSONEachRow, '{"x" : 1, "y" : "String", "z" : "0.0.0.0" }') settings
 
 Result:
 ```sql
-x	UInt8					
-y	Nullable(String)					
+x	UInt8
+y	Nullable(String)
 z	IPv4
 ```
 
diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 8688f3eb3a06..001c78224338 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -268,13 +268,15 @@ Result:
 ```
 
 :::note
-The return type of `toStartOf*`, `toLastDayOfMonth`, `toMonday` functions described below is `Date` or `DateTime`.
-Though these functions can take values of the extended types `Date32` and `DateTime64` as an argument, passing them a time outside the normal range (year 1970 to 2149 for `Date` / 2106 for `DateTime`) will produce wrong results.
-In case argument is out of normal range:
+The return type of `toStartOf*`, `toLastDayOfMonth`, `toMonday` functions described below is determined by the configuration parameter [enable_extended_results_for_datetime_functions](../../operations/settings/settings#enable-extended-results-for-datetime-functions) which is `0` by default.
+
+Behavior for
+* `enable_extended_results_for_datetime_functions = 0`: Functions `toStartOf*`, `toLastDayOfMonth`, `toMonday` return `Date` or `DateTime`. Though these functions can take values of the extended types `Date32` and `DateTime64` as an argument, passing them a time outside the normal range (year 1970 to 2149 for `Date` / 2106 for `DateTime`) will produce wrong results. In case argument is out of normal range:
   * If the argument is smaller than 1970, the result will be calculated from the argument `1970-01-01 (00:00:00)` instead.
   * If the return type is `DateTime` and the argument is larger than `2106-02-07 08:28:15`, the result will be calculated from the argument `2106-02-07 08:28:15` instead.
   * If the return type is `Date` and the argument is larger than `2149-06-06`, the result will be calculated from the argument `2149-06-06` instead.
   *  If `toLastDayOfMonth` is called with an argument greater then `2149-05-31`, the result will be calculated from the argument `2149-05-31` instead.
+* `enable_extended_results_for_datetime_functions = 1`: Functions `toStartOfYear`, `toStartOfISOYear`, `toStartOfQuarter`, `toStartOfMonth`, `toStartOfWeek`, `toLastDayOfMonth`, `toMonday` return `Date` or `DateTime` if their argument is a `Date` or `DateTime`, and they return `Date32` or `DateTime64` if their argument is a `Date32` or `DateTime64`.
 :::
 
 ## toStartOfYear
@@ -303,6 +305,8 @@ Returns the date.
 Rounds up a date or date with time to the last day of the month.
 Returns the date.
 
+If `toLastDayOfMonth` is called with an argument of type `Date` greater then 2149-05-31, the result will be calculated from the argument 2149-05-31 instead.
+
 ## toMonday
 
 Rounds down a date or date with time to the nearest Monday.
@@ -640,7 +644,7 @@ Result:
 
 ## date\_diff
 
-Returns the difference between two dates or dates with time values. 
+Returns the difference between two dates or dates with time values.
 The difference is calculated using relative units, e.g. the difference between `2022-01-01` and `2021-12-29` is 3 days for day unit (see [toRelativeDayNum](#torelativedaynum)), 1 month for month unit (see [toRelativeMonthNum](#torelativemonthnum)), 1 year for year unit (see [toRelativeYearNum](#torelativeyearnum)).
 
 **Syntax**
@@ -1059,9 +1063,9 @@ SELECT
 
 ## timeSlots(StartTime, Duration,\[, Size\])
 
-For a time interval starting at ‘StartTime’ and continuing for ‘Duration’ seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the ‘Size’ in seconds. ‘Size’ is an optional parameter set to 1800 (30 minutes) by default.  
-This is necessary, for example, when searching for pageviews in the corresponding session.  
-Accepts DateTime and DateTime64 as ’StartTime’ argument. For DateTime, ’Duration’ and ’Size’ arguments must be `UInt32`. For ’DateTime64’ they must be `Decimal64`.  
+For a time interval starting at ‘StartTime’ and continuing for ‘Duration’ seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the ‘Size’ in seconds. ‘Size’ is an optional parameter set to 1800 (30 minutes) by default.
+This is necessary, for example, when searching for pageviews in the corresponding session.
+Accepts DateTime and DateTime64 as ’StartTime’ argument. For DateTime, ’Duration’ and ’Size’ arguments must be `UInt32`. For ’DateTime64’ they must be `Decimal64`.
 Returns an array of DateTime/DateTime64 (return type matches the type of ’StartTime’). For DateTime64, the return value's scale can differ from the scale of ’StartTime’ --- the highest scale among all given arguments is taken.
 
 Example:
diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md
index 5ddc684ce2a4..0d4f0c632107 100644
--- a/docs/ru/operations/settings/settings.md
+++ b/docs/ru/operations/settings/settings.md
@@ -3799,6 +3799,17 @@ Exception: Total regexp lengths too large.
 
 Значение по умолчанию: `1`.
 
+## enable_extended_results_for_datetime_functions {#enable-extended-results-for-datetime-functions}
+
+Включает или отключает возвращение результатов типа `Date32` с расширенным диапазоном (по сравнению с типом `Date`) для функций [toStartOfYear](../../sql-reference/functions/date-time-functions.md#tostartofyear), [toStartOfISOYear](../../sql-reference/functions/date-time-functions.md#tostartofisoyear), [toStartOfQuarter](../../sql-reference/functions/date-time-functions.md#tostartofquarter), [toStartOfMonth](../../sql-reference/functions/date-time-functions.md#tostartofmonth), [toStartOfWeek](../../sql-reference/functions/date-time-functions.md#tostartofweek), [toMonday](../../sql-reference/functions/date-time-functions.md#tomonday) и [toLastDayOfMonth](../../sql-reference/functions/date-time-functions.md#tolastdayofmonth).
+
+Возможные значения:
+
+-   0 — Функции возвращают результаты типа `Date` для всех типов аргументов.
+-   1 — Функции возвращают результаты типа `Date32` для аргументов типа `Date32` или `DateTime64` и возвращают `Date` в других случаях.
+
+Значение по умолчанию: `0`.
+
 **Пример**
 
 Запрос:
diff --git a/docs/ru/sql-reference/functions/date-time-functions.md b/docs/ru/sql-reference/functions/date-time-functions.md
index 1c623cd1dabd..27689426cbe0 100644
--- a/docs/ru/sql-reference/functions/date-time-functions.md
+++ b/docs/ru/sql-reference/functions/date-time-functions.md
@@ -268,24 +268,18 @@ SELECT toUnixTimestamp('2017-11-05 08:07:47', 'Asia/Tokyo') AS unix_timestamp;
 ```
 
 :::note
-Тип возвращаемого описанными далее функциями `toStartOf*`, `toMonday` значения - `Date` или `DateTime`.
-Хотя эти функции могут принимать значения типа `Date32` или `DateTime64` в качестве аргумента, при обработке аргумента вне нормального диапазона значений (`1970` - `2148` для `Date` и `1970-01-01 00:00:00`-`2106-02-07 08:28:15` для `DateTime`) будет получен некорректный результат.
-Возвращаемые значения для значений вне нормального диапазона:
-* `1970-01-01 (00:00:00)` будет возвращён для моментов времени до 1970 года,
-* `2106-02-07 08:28:15` будет взят в качестве аргумента, если полученный аргумент превосходит данное значение и возвращаемый тип - `DateTime`,
-* `2149-06-06` будет взят в качестве аргумента, если полученный аргумент превосходит данное значение и возвращаемый тип - `Date`,
-* `2149-05-31` будет результатом функции `toLastDayOfMonth` при обработке аргумента больше `2149-05-31`.
+Тип возвращаемого значения описанными далее функциями `toStartOf*`, `toLastDayOfMonth`, `toMonday` определяется конфигурационным параметром [enable_extended_results_for_datetime_functions](../../operations/settings/settings#enable-extended-results-for-datetime-functions) имеющим по умолчанию значение `0`.
+
+Поведение для
+* `enable_extended_results_for_datetime_functions = 0`: Функции `toStartOf*`, `toLastDayOfMonth`, `toMonday` возвращают `Date` или `DateTime`. Хотя эти функции могут принимать значения типа `Date32` или `DateTime64` в качестве аргумента, при обработке аргумента вне нормального диапазона значений (`1970` - `2148` для `Date` и `1970-01-01 00:00:00`-`2106-02-07 08:28:15` для `DateTime`) будет получен некорректный результат.
+В случае если значение аргумента вне нормального диапазона:
+    * `1970-01-01 (00:00:00)` будет возвращён для моментов времени до 1970 года,
+    * `2106-02-07 08:28:15` будет взят в качестве аргумента, если полученный аргумент превосходит данное значение и возвращаемый тип - `DateTime`,
+    * `2149-06-06` будет взят в качестве аргумента, если полученный аргумент превосходит данное значение и возвращаемый тип - `Date`,
+    * `2149-05-31` будет результатом функции `toLastDayOfMonth` при обработке аргумента больше `2149-05-31`.
+* `enable_extended_results_for_datetime_functions = 1`: Функции `toStartOfYear`, `toStartOfISOYear`, `toStartOfQuarter`, `toStartOfMonth`, `toStartOfWeek`, `toLastDayOfMonth`, `toMonday` возвращают `Date` или `DateTime` если их аргумент `Date` или `DateTime` и они возвращают `Date32` или `DateTime64` если их аргумент `Date32` или `DateTime64`.
 :::
 
-:::note
-Тип возвращаемого описанными далее функциями `toStartOf*`, `toLastDayOfMonth`, `toMonday` значения - `Date` или `DateTime`.
-Хотя эти функции могут принимать значения типа `Date32` или `DateTime64` в качестве аргумента, при обработке аргумента вне нормального диапазона значений (`1970` - `2148` для `Date` и `1970-01-01 00:00:00`-`2106-02-07 08:28:15` для `DateTime`) будет получен некорректный результат.
-Возвращаемые значения для значений вне нормального диапазона:
-* `1970-01-01 (00:00:00)` будет возвращён для моментов времени до 1970 года,
-* `2106-02-07 08:28:15` будет взят в качестве аргумента, если полученный аргумент превосходит данное значение и возвращаемый тип - `DateTime`,
-* `2149-06-06` будет взят в качестве аргумента, если полученный аргумент превосходит данное значение и возвращаемый тип - `Date`.
-  :::
-*
 ## toStartOfYear {#tostartofyear}
 
 Округляет дату или дату-с-временем вниз до первого дня года.
@@ -324,6 +318,8 @@ SELECT toStartOfISOYear(toDate('2017-01-01')) AS ISOYear20170101;
 Округляет дату или дату-с-временем до последнего числа месяца.
 Возвращается дата.
 
+Если `toLastDayOfMonth` вызывается с аргументом типа `Date` большим чем 2149-05-31, то результат будет вычислен от аргумента 2149-05-31.
+
 ## toMonday {#tomonday}
 
 Округляет дату или дату-с-временем вниз до ближайшего понедельника.
@@ -977,7 +973,7 @@ SELECT now('Europe/Moscow');
 ## timeSlots(StartTime, Duration,\[, Size\]) {#timeslotsstarttime-duration-size}
 Для интервала, начинающегося в `StartTime` и длящегося `Duration` секунд, возвращает массив моментов времени, кратных `Size`. Параметр `Size` указывать необязательно, по умолчанию он равен 1800 секундам (30 минутам) - необязательный параметр.
 Данная функция может использоваться, например, для анализа количества просмотров страницы за соответствующую сессию.
-Аргумент `StartTime` может иметь тип `DateTime` или `DateTime64`. В случае, если используется `DateTime`, аргументы `Duration` и `Size` должны иметь тип `UInt32`; Для DateTime64 они должны быть типа `Decimal64`.  
+Аргумент `StartTime` может иметь тип `DateTime` или `DateTime64`. В случае, если используется `DateTime`, аргументы `Duration` и `Size` должны иметь тип `UInt32`; Для DateTime64 они должны быть типа `Decimal64`.
 Возвращает массив DateTime/DateTime64 (тип будет совпадать с типом параметра ’StartTime’). Для DateTime64 масштаб(scale) возвращаемой величины может отличаться от масштаба фргумента ’StartTime’ --- результат будет иметь наибольший масштаб среди всех данных аргументов.
 
 Пример использования:
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 8793bbb30112..d677c7900bc2 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -136,6 +136,7 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     M(Bool, distributed_aggregation_memory_efficient, true, "Is the memory-saving mode of distributed aggregation enabled.", 0) \
     M(UInt64, aggregation_memory_efficient_merge_threads, 0, "Number of threads to use for merge intermediate aggregation results in memory efficient mode. When bigger, then more memory is consumed. 0 means - same as 'max_threads'.", 0) \
     M(Bool, enable_positional_arguments, true, "Enable positional arguments in ORDER BY, GROUP BY and LIMIT BY", 0) \
+    M(Bool, enable_extended_results_for_datetime_functions, false, "Enable date functions like toLastDayOfMonth return Date32 results (instead of Date results) for Date32/DateTime64 arguments.", 0) \
     \
     M(Bool, group_by_use_nulls, false, "Treat columns mentioned in ROLLUP, CUBE or GROUPING SETS as Nullable", 0) \
     \
diff --git a/src/Functions/CustomWeekTransforms.h b/src/Functions/CustomWeekTransforms.h
index 3378aec02d5b..5fa51d5f5e0b 100644
--- a/src/Functions/CustomWeekTransforms.h
+++ b/src/Functions/CustomWeekTransforms.h
@@ -82,6 +82,14 @@ struct ToStartOfWeekImpl
     {
         return time_zone.toFirstDayNumOfWeek(DayNum(d), week_mode);
     }
+    static inline Int64 execute_extended_result(Int64 t, UInt8 week_mode, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t), week_mode);
+    }
+    static inline Int32 execute_extended_result(Int32 d, UInt8 week_mode, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d), week_mode);
+    }
 
     using FactorTransform = ZeroTransform;
 };
@@ -115,7 +123,7 @@ struct ToWeekImpl
     using FactorTransform = ToStartOfYearImpl;
 };
 
-template <typename FromType, typename ToType, typename Transform>
+template <typename FromType, typename ToType, typename Transform, bool is_extended_result = false>
 struct WeekTransformer
 {
     explicit WeekTransformer(Transform transform_)
@@ -130,7 +138,10 @@ struct WeekTransformer
         vec_to.resize(size);
 
         for (size_t i = 0; i < size; ++i)
-            vec_to[i] = transform.execute(vec_from[i], week_mode, time_zone);
+            if constexpr (is_extended_result)
+                vec_to[i] = transform.execute_extended_result(vec_from[i], week_mode, time_zone);
+            else
+                vec_to[i] = transform.execute(vec_from[i], week_mode, time_zone);
     }
 
 private:
@@ -138,13 +149,13 @@ struct WeekTransformer
 };
 
 
-template <typename FromDataType, typename ToDataType>
+template <typename FromDataType, typename ToDataType, bool is_extended_result = false>
 struct CustomWeekTransformImpl
 {
     template <typename Transform>
     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/, Transform transform = {})
     {
-        const auto op = WeekTransformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform>{std::move(transform)};
+        const auto op = WeekTransformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform, is_extended_result>{std::move(transform)};
 
         UInt8 week_mode = DEFAULT_WEEK_MODE;
         if (arguments.size() > 1)
diff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h
index 66d57f2463f6..fbe8e4bfcfee 100644
--- a/src/Functions/DateTimeTransforms.h
+++ b/src/Functions/DateTimeTransforms.h
@@ -161,7 +161,14 @@ struct ToMondayImpl
     {
         return time_zone.toFirstDayNumOfWeek(DayNum(d));
     }
-
+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfWeek(time_zone.toDayNum(t));
+    }
+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfWeek(ExtendedDayNum(d));
+    }
     using FactorTransform = ZeroTransform;
 };
 
@@ -185,6 +192,14 @@ struct ToStartOfMonthImpl
     {
         return time_zone.toFirstDayNumOfMonth(DayNum(d));
     }
+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfMonth(time_zone.toDayNum(t));
+    }
+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfMonth(ExtendedDayNum(d));
+    }
 
     using FactorTransform = ZeroTransform;
 };
@@ -218,7 +233,14 @@ struct ToLastDayOfMonthImpl
         /// 0xFFF9 is Int value for 2149-05-31 -- the last day where we can actually find LastDayOfMonth. This will also be the return value.
         return time_zone.toLastDayNumOfMonth(DayNum(std::min(d, UInt16(0xFFF9))));
     }
-
+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toLastDayNumOfMonth(time_zone.toDayNum(t));
+    }
+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toLastDayNumOfMonth(ExtendedDayNum(d));
+    }
     using FactorTransform = ZeroTransform;
 };
 
@@ -242,7 +264,14 @@ struct ToStartOfQuarterImpl
     {
         return time_zone.toFirstDayNumOfQuarter(DayNum(d));
     }
-
+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfQuarter(time_zone.toDayNum(t));
+    }
+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfQuarter(ExtendedDayNum(d));
+    }
     using FactorTransform = ZeroTransform;
 };
 
@@ -266,6 +295,14 @@ struct ToStartOfYearImpl
     {
         return time_zone.toFirstDayNumOfYear(DayNum(d));
     }
+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfYear(time_zone.toDayNum(t));
+    }
+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfYear(ExtendedDayNum(d));
+    }
 
     using FactorTransform = ZeroTransform;
 };
@@ -893,7 +930,7 @@ struct ToStartOfISOYearImpl
 
     static inline UInt16 execute(Int64 t, const DateLUTImpl & time_zone)
     {
-        return time_zone.toFirstDayNumOfISOYear(time_zone.toDayNum(t));
+        return t < 0 ? 0 : time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(std::min(Int32(time_zone.toDayNum(t)), Int32(DATE_LUT_MAX_DAY_NUM))));
     }
     static inline UInt16 execute(UInt32 t, const DateLUTImpl & time_zone)
     {
@@ -901,12 +938,20 @@ struct ToStartOfISOYearImpl
     }
     static inline UInt16 execute(Int32 d, const DateLUTImpl & time_zone)
     {
-        return time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(d));
+        return d < 0 ? 0 : time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(std::min(d, Int32(DATE_LUT_MAX_DAY_NUM))));
     }
     static inline UInt16 execute(UInt16 d, const DateLUTImpl & time_zone)
     {
         return time_zone.toFirstDayNumOfISOYear(DayNum(d));
     }
+    static inline Int64 execute_extended_result(Int64 t, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfISOYear(time_zone.toDayNum(t));
+    }
+    static inline Int32 execute_extended_result(Int32 d, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toFirstDayNumOfISOYear(ExtendedDayNum(d));
+    }
 
     using FactorTransform = ZeroTransform;
 };
@@ -1201,7 +1246,7 @@ struct ToYYYYMMDDhhmmssImpl
 };
 
 
-template <typename FromType, typename ToType, typename Transform>
+template <typename FromType, typename ToType, typename Transform, bool is_extended_result = false>
 struct Transformer
 {
     template <typename FromTypeVector, typename ToTypeVector>
@@ -1211,18 +1256,21 @@ struct Transformer
         vec_to.resize(size);
 
         for (size_t i = 0; i < size; ++i)
-            vec_to[i] = transform.execute(vec_from[i], time_zone);
+            if constexpr (is_extended_result)
+                vec_to[i] = transform.execute_extended_result(vec_from[i], time_zone);
+            else
+                vec_to[i] = transform.execute(vec_from[i], time_zone);
     }
 };
 
 
-template <typename FromDataType, typename ToDataType, typename Transform>
+template <typename FromDataType, typename ToDataType, typename Transform, bool is_extended_result = false>
 struct DateTimeTransformImpl
 {
     static ColumnPtr execute(
         const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/, const Transform & transform = {})
     {
-        using Op = Transformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform>;
+        using Op = Transformer<typename FromDataType::FieldType, typename ToDataType::FieldType, Transform, is_extended_result>;
 
         const ColumnPtr source_col = arguments[0].column;
         if (const auto * sources = checkAndGetColumn<typename FromDataType::ColumnType>(source_col.get()))
diff --git a/src/Functions/FunctionCustomWeekToDateOrDate32.h b/src/Functions/FunctionCustomWeekToDateOrDate32.h
new file mode 100644
index 000000000000..0b91fbb3bbe1
--- /dev/null
+++ b/src/Functions/FunctionCustomWeekToDateOrDate32.h
@@ -0,0 +1,78 @@
+#pragma once
+#include <Functions/IFunctionCustomWeek.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
+
+template <typename Transform>
+class FunctionCustomWeekToDateOrDate32 : public IFunctionCustomWeek<Transform>, WithContext
+{
+public:
+    const bool enable_extended_results_for_datetime_functions = false;
+
+    static FunctionPtr create(ContextPtr context_)
+    {
+        return std::make_shared<FunctionCustomWeekToDateOrDate32>(context_);
+    }
+
+    explicit FunctionCustomWeekToDateOrDate32(ContextPtr context_)
+        : WithContext(context_)
+        , enable_extended_results_for_datetime_functions(context_->getSettingsRef().enable_extended_results_for_datetime_functions)
+    {
+    }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ true);
+
+        const IDataType * from_type = arguments[0].type.get();
+        WhichDataType which(from_type);
+        if ((which.isDate32() || which.isDateTime64()) && enable_extended_results_for_datetime_functions)
+            return std::make_shared<DataTypeDate32>();
+        else
+            return std::make_shared<DataTypeDate>();
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+    {
+        const IDataType * from_type = arguments[0].type.get();
+        WhichDataType which(from_type);
+
+        if (which.isDate())
+            return CustomWeekTransformImpl<DataTypeDate, DataTypeDate>::execute(
+                arguments, result_type, input_rows_count, Transform{});
+        else if (which.isDate32())
+            if (enable_extended_results_for_datetime_functions)
+                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate32, /*is_extended_result*/ true>::execute(
+                    arguments, result_type, input_rows_count, Transform{});
+            else
+                return CustomWeekTransformImpl<DataTypeDate32, DataTypeDate>::execute(
+                    arguments, result_type, input_rows_count, Transform{});
+        else if (which.isDateTime())
+            return CustomWeekTransformImpl<DataTypeDateTime, DataTypeDate>::execute(
+                arguments, result_type, input_rows_count, Transform{});
+        else if (which.isDateTime64())
+        {
+            if (enable_extended_results_for_datetime_functions)
+                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate32, /*is_extended_result*/ true>::execute(
+                    arguments, result_type, input_rows_count,
+                    TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});
+            else
+                return CustomWeekTransformImpl<DataTypeDateTime64, DataTypeDate>::execute(
+                    arguments, result_type, input_rows_count,
+                    TransformDateTime64<Transform>{assert_cast<const DataTypeDateTime64 *>(from_type)->getScale()});
+        }
+        else
+            throw Exception(
+                "Illegal type " + arguments[0].type->getName() + " of argument of function " + this->getName(),
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+    }
+
+};
+
+}
diff --git a/src/Functions/FunctionCustomWeekToSomething.h b/src/Functions/FunctionCustomWeekToSomething.h
index 8a0f474a7e87..eb65d5622211 100644
--- a/src/Functions/FunctionCustomWeekToSomething.h
+++ b/src/Functions/FunctionCustomWeekToSomething.h
@@ -1,14 +1,5 @@
 #pragma once
-#include <DataTypes/DataTypeDate.h>
-#include <DataTypes/DataTypeDate32.h>
-#include <DataTypes/DataTypeDateTime.h>
-#include <DataTypes/DataTypeDateTime64.h>
-#include <Functions/CustomWeekTransforms.h>
-#include <Functions/IFunction.h>
-#include <Functions/TransformDateTime64.h>
-#include <IO/WriteHelpers.h>
-#include <Interpreters/Context_fwd.h>
-
+#include <Functions/IFunctionCustomWeek.h>
 
 namespace DB
 {
@@ -16,82 +7,23 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
 }
 
 
 /// See CustomWeekTransforms.h
 template <typename ToDataType, typename Transform>
-class FunctionCustomWeekToSomething : public IFunction
+class FunctionCustomWeekToSomething : public IFunctionCustomWeek<Transform>
 {
 public:
-    static constexpr auto name = Transform::name;
     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionCustomWeekToSomething>(); }
 
-    String getName() const override { return name; }
-
-    bool isVariadic() const override { return true; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-    size_t getNumberOfArguments() const override { return 0; }
-
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if (arguments.size() == 1)
-        {
-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
-                throw Exception(
-                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
-                        + ". Must be Date, Date32, DateTime or DateTime64.",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        }
-        else if (arguments.size() == 2)
-        {
-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
-                throw Exception(
-                    "Illegal type " + arguments[0].type->getName() + " of 1st argument of function " + getName()
-                        + ". Must be Date, Date32, DateTime or DateTime64.",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            if (!isUInt8(arguments[1].type))
-                throw Exception(
-                    "Illegal type of 2nd (optional) argument of function " + getName()
-                        + ". Must be constant UInt8 (week mode).",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        }
-        else if (arguments.size() == 3)
-        {
-            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
-                throw Exception(
-                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
-                        + ". Must be Date, Date32, DateTime or DateTime64",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            if (!isUInt8(arguments[1].type))
-                throw Exception(
-                    "Illegal type of 2nd (optional) argument of function " + getName()
-                        + ". Must be constant UInt8 (week mode).",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            if (!isString(arguments[2].type))
-                throw Exception(
-                    "Illegal type of 3rd (optional) argument of function " + getName()
-                        + ". Must be constant string (timezone name).",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            if ((isDate(arguments[0].type) || isDate32(arguments[0].type))
-                && (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>))
-                throw Exception(
-                    "The timezone argument of function " + getName() + " is allowed only when the 1st argument is DateTime or DateTime64.",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        }
-        else
-            throw Exception(
-                "Number of arguments for function " + getName() + " doesn't match: passed " + toString(arguments.size())
-                    + ", expected 1, 2 or 3.",
-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+        this->checkArguments(arguments);
 
         return std::make_shared<ToDataType>();
     }
 
-    bool useDefaultImplementationForConstants() const override { return true; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }
-
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
     {
         const IDataType * from_type = arguments[0].type.get();
@@ -114,44 +46,10 @@ class FunctionCustomWeekToSomething : public IFunction
         }
         else
             throw Exception(
-                "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName(),
+                "Illegal type " + arguments[0].type->getName() + " of argument of function " + this->getName(),
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
     }
 
-
-    bool hasInformationAboutMonotonicity() const override { return true; }
-
-    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override
-    {
-        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)
-            return { .is_monotonic = true, .is_always_monotonic = true };
-
-        const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };
-        const IFunction::Monotonicity is_not_monotonic;
-
-        /// This method is called only if the function has one argument. Therefore, we do not care about the non-local time zone.
-        const DateLUTImpl & date_lut = DateLUT::instance();
-
-        if (left.isNull() || right.isNull())
-            return {};
-
-        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.
-
-        if (checkAndGetDataType<DataTypeDate>(&type))
-        {
-            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), date_lut)
-                    == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), date_lut)
-                ? is_monotonic
-                : is_not_monotonic;
-        }
-        else
-        {
-            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), date_lut)
-                    == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), date_lut)
-                ? is_monotonic
-                : is_not_monotonic;
-        }
-    }
 };
 
 }
diff --git a/src/Functions/FunctionDateOrDateTimeToDateOrDate32.h b/src/Functions/FunctionDateOrDateTimeToDateOrDate32.h
new file mode 100644
index 000000000000..3ff90cb57fbc
--- /dev/null
+++ b/src/Functions/FunctionDateOrDateTimeToDateOrDate32.h
@@ -0,0 +1,81 @@
+#pragma once
+#include <Functions/IFunctionDateOrDateTime.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
+
+template <typename Transform>
+class FunctionDateOrDateTimeToDateOrDate32 : public IFunctionDateOrDateTime<Transform>, WithContext
+{
+public:
+    const bool enable_extended_results_for_datetime_functions = false;
+
+    static FunctionPtr create(ContextPtr context_)
+    {
+        return std::make_shared<FunctionDateOrDateTimeToDateOrDate32>(context_);
+    }
+
+    explicit FunctionDateOrDateTimeToDateOrDate32(ContextPtr context_)
+        : WithContext(context_)
+        , enable_extended_results_for_datetime_functions(context_->getSettingsRef().enable_extended_results_for_datetime_functions)
+    {
+    }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        this->checkArguments(arguments, /*is_result_type_date_or_date32*/ true);
+
+        const IDataType * from_type = arguments[0].type.get();
+        WhichDataType which(from_type);
+
+        /// If the time zone is specified but empty, throw an exception.
+        /// only validate the time_zone part if the number of arguments is 2.
+        if ((which.isDateTime() || which.isDateTime64()) && arguments.size() == 2
+            && extractTimeZoneNameFromFunctionArguments(arguments, 1, 0).empty())
+            throw Exception(
+                "Function " + this->getName() + " supports a 2nd argument (optional) that must be non-empty and be a valid time zone",
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+        if ((which.isDate32() || which.isDateTime64()) && enable_extended_results_for_datetime_functions)
+            return std::make_shared<DataTypeDate32>();
+        else
+            return std::make_shared<DataTypeDate>();
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+    {
+        const IDataType * from_type = arguments[0].type.get();
+        WhichDataType which(from_type);
+
+        if (which.isDate())
+            return DateTimeTransformImpl<DataTypeDate, DataTypeDate, Transform>::execute(arguments, result_type, input_rows_count);
+        else if (which.isDate32())
+            if (enable_extended_results_for_datetime_functions)
+                return DateTimeTransformImpl<DataTypeDate32, DataTypeDate32, Transform, /*is_extended_result*/ true>::execute(arguments, result_type, input_rows_count);
+            else
+                return DateTimeTransformImpl<DataTypeDate32, DataTypeDate, Transform>::execute(arguments, result_type, input_rows_count);
+        else if (which.isDateTime())
+            return DateTimeTransformImpl<DataTypeDateTime, DataTypeDate, Transform>::execute(arguments, result_type, input_rows_count);
+        else if (which.isDateTime64())
+        {
+            const auto scale = static_cast<const DataTypeDateTime64 *>(from_type)->getScale();
+
+            const TransformDateTime64<Transform> transformer(scale);
+            if (enable_extended_results_for_datetime_functions)
+                return DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate32, decltype(transformer), /*is_extended_result*/ true>::execute(arguments, result_type, input_rows_count, transformer);
+            else
+                return DateTimeTransformImpl<DataTypeDateTime64, DataTypeDate, decltype(transformer)>::execute(arguments, result_type, input_rows_count, transformer);
+        }
+        else
+            throw Exception("Illegal type " + arguments[0].type->getName() + " of argument of function " + this->getName(),
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+    }
+
+};
+
+}
diff --git a/src/Functions/FunctionDateOrDateTimeToSomething.h b/src/Functions/FunctionDateOrDateTimeToSomething.h
index d734c7f87c19..5c1c54c1b849 100644
--- a/src/Functions/FunctionDateOrDateTimeToSomething.h
+++ b/src/Functions/FunctionDateOrDateTimeToSomething.h
@@ -1,14 +1,5 @@
 #pragma once
-#include <DataTypes/DataTypeDate.h>
-#include <DataTypes/DataTypeDate32.h>
-#include <DataTypes/DataTypeDateTime.h>
-#include <Functions/IFunction.h>
-#include <DataTypes/DataTypeDateTime64.h>
-#include <Functions/extractTimeZoneFromFunctionArguments.h>
-#include <Functions/DateTimeTransforms.h>
-#include <Functions/TransformDateTime64.h>
-#include <IO/WriteHelpers.h>
-
+#include <Functions/IFunctionDateOrDateTime.h>
 
 namespace DB
 {
@@ -16,59 +7,18 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
 }
 
 /// See DateTimeTransforms.h
 template <typename ToDataType, typename Transform>
-class FunctionDateOrDateTimeToSomething : public IFunction
+class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transform>
 {
 public:
-    static constexpr auto name = Transform::name;
     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionDateOrDateTimeToSomething>(); }
 
-    String getName() const override
-    {
-        return name;
-    }
-
-    bool isVariadic() const override { return true; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
-    size_t getNumberOfArguments() const override { return 0; }
-
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        if (arguments.size() == 1)
-        {
-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
-                throw Exception(
-                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
-                        + ". Should be a date or a date with time",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        }
-        else if (arguments.size() == 2)
-        {
-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
-                throw Exception(
-                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
-                        + ". Should be a date or a date with time",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            if (!isString(arguments[1].type))
-                throw Exception(
-                    "Function " + getName() + " supports 1 or 2 arguments. The 1st argument "
-                          "must be of type Date or DateTime. The 2nd argument (optional) must be "
-                          "a constant string with timezone name",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>))
-                throw Exception(
-                    "The timezone argument of function " + getName() + " is allowed only when the 1st argument has the type DateTime",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        }
-        else
-            throw Exception(
-                "Number of arguments for function " + getName() + " doesn't match: passed " + toString(arguments.size())
-                    + ", should be 1 or 2",
-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+        this->checkArguments(arguments, (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>));
 
         /// For DateTime, if time zone is specified, attach it to type.
         /// If the time zone is specified but empty, throw an exception.
@@ -79,7 +29,7 @@ class FunctionDateOrDateTimeToSomething : public IFunction
             /// to accommodate functions like toStartOfDay(today()), toStartOfDay(yesterday()) etc.
             if (arguments.size() == 2 && time_zone.empty())
                 throw Exception(
-                    "Function " + getName() + " supports a 2nd argument (optional) that must be non-empty and be a valid time zone",
+                    "Function " + this->getName() + " supports a 2nd argument (optional) that must be non-empty and be a valid time zone",
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
             return std::make_shared<ToDataType>(time_zone);
         }
@@ -109,9 +59,6 @@ class FunctionDateOrDateTimeToSomething : public IFunction
             return std::make_shared<ToDataType>();
     }
 
-    bool useDefaultImplementationForConstants() const override { return true; }
-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
-
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
     {
         const IDataType * from_type = arguments[0].type.get();
@@ -131,51 +78,10 @@ class FunctionDateOrDateTimeToSomething : public IFunction
             return DateTimeTransformImpl<DataTypeDateTime64, ToDataType, decltype(transformer)>::execute(arguments, result_type, input_rows_count, transformer);
         }
         else
-            throw Exception("Illegal type " + arguments[0].type->getName() + " of argument of function " + getName(),
+            throw Exception("Illegal type " + arguments[0].type->getName() + " of argument of function " + this->getName(),
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
     }
 
-    bool hasInformationAboutMonotonicity() const override
-    {
-        return true;
-    }
-
-    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override
-    {
-        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)
-            return { .is_monotonic = true, .is_always_monotonic = true };
-
-        const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };
-        const IFunction::Monotonicity is_not_monotonic;
-
-        const DateLUTImpl * date_lut = &DateLUT::instance();
-        if (const auto * timezone = dynamic_cast<const TimezoneMixin *>(&type))
-            date_lut = &timezone->getTimeZone();
-
-        if (left.isNull() || right.isNull())
-            return is_not_monotonic;
-
-        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.
-
-        if (checkAndGetDataType<DataTypeDate>(&type))
-        {
-            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), *date_lut)
-                == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), *date_lut)
-                ? is_monotonic : is_not_monotonic;
-        }
-        else if (checkAndGetDataType<DataTypeDate32>(&type))
-        {
-            return Transform::FactorTransform::execute(Int32(left.get<UInt64>()), *date_lut)
-                   == Transform::FactorTransform::execute(Int32(right.get<UInt64>()), *date_lut)
-                   ? is_monotonic : is_not_monotonic;
-        }
-        else
-        {
-            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), *date_lut)
-                == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), *date_lut)
-                ? is_monotonic : is_not_monotonic;
-        }
-    }
 };
 
 }
diff --git a/src/Functions/IFunctionCustomWeek.h b/src/Functions/IFunctionCustomWeek.h
new file mode 100644
index 000000000000..1bc4e44655ac
--- /dev/null
+++ b/src/Functions/IFunctionCustomWeek.h
@@ -0,0 +1,122 @@
+#pragma once
+#include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeDate32.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <DataTypes/DataTypeDateTime64.h>
+#include <Functions/CustomWeekTransforms.h>
+#include <Functions/IFunction.h>
+#include <Functions/TransformDateTime64.h>
+#include <IO/WriteHelpers.h>
+#include <Interpreters/Context.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+}
+
+template <typename Transform>
+class IFunctionCustomWeek : public IFunction
+{
+public:
+    static constexpr auto name = Transform::name;
+    String getName() const override { return name; }
+    bool isVariadic() const override { return true; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    size_t getNumberOfArguments() const override { return 0; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1, 2}; }
+
+    bool hasInformationAboutMonotonicity() const override { return true; }
+
+    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override
+    {
+        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)
+            return {.is_monotonic = true, .is_always_monotonic = true};
+
+        const IFunction::Monotonicity is_monotonic = {.is_monotonic = true};
+        const IFunction::Monotonicity is_not_monotonic;
+
+        /// This method is called only if the function has one argument. Therefore, we do not care about the non-local time zone.
+        const DateLUTImpl & date_lut = DateLUT::instance();
+
+        if (left.isNull() || right.isNull())
+            return {};
+
+        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.
+
+        if (checkAndGetDataType<DataTypeDate>(&type))
+        {
+            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), date_lut)
+                    == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), date_lut)
+                ? is_monotonic
+                : is_not_monotonic;
+        }
+        else
+        {
+            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), date_lut)
+                    == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), date_lut)
+                ? is_monotonic
+                : is_not_monotonic;
+        }
+    }
+
+protected:
+    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32 = false) const
+    {
+        if (arguments.size() == 1)
+        {
+            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+                throw Exception(
+                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
+                        + ". Must be Date, Date32, DateTime or DateTime64.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else if (arguments.size() == 2)
+        {
+            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+                throw Exception(
+                    "Illegal type " + arguments[0].type->getName() + " of 1st argument of function " + getName()
+                        + ". Must be Date, Date32, DateTime or DateTime64.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if (!isUInt8(arguments[1].type))
+                throw Exception(
+                    "Illegal type of 2nd (optional) argument of function " + getName()
+                        + ". Must be constant UInt8 (week mode).",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else if (arguments.size() == 3)
+        {
+            if (!isDate(arguments[0].type) && !isDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+                throw Exception(
+                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
+                        + ". Must be Date, Date32, DateTime or DateTime64",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if (!isUInt8(arguments[1].type))
+                throw Exception(
+                    "Illegal type of 2nd (optional) argument of function " + getName()
+                        + ". Must be constant UInt8 (week mode).",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if (!isString(arguments[2].type))
+                throw Exception(
+                    "Illegal type of 3rd (optional) argument of function " + getName()
+                        + ". Must be constant string (timezone name).",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && is_result_type_date_or_date32)
+                throw Exception(
+                    "The timezone argument of function " + getName() + " is allowed only when the 1st argument is DateTime or DateTime64.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else
+            throw Exception(
+                "Number of arguments for function " + getName() + " doesn't match: passed " + toString(arguments.size())
+                    + ", expected 1, 2 or 3.",
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+    }
+
+};
+
+}
diff --git a/src/Functions/IFunctionDateOrDateTime.h b/src/Functions/IFunctionDateOrDateTime.h
new file mode 100644
index 000000000000..1efe89c7fe94
--- /dev/null
+++ b/src/Functions/IFunctionDateOrDateTime.h
@@ -0,0 +1,118 @@
+#pragma once
+#include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeDate32.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <Functions/IFunction.h>
+#include <DataTypes/DataTypeDateTime64.h>
+#include <Functions/extractTimeZoneFromFunctionArguments.h>
+#include <Functions/DateTimeTransforms.h>
+#include <Functions/TransformDateTime64.h>
+#include <IO/WriteHelpers.h>
+#include <Interpreters/Context.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+}
+
+template <typename Transform>
+class IFunctionDateOrDateTime : public IFunction
+{
+public:
+    static constexpr auto name = Transform::name;
+    String getName() const override { return name; }
+
+    bool isVariadic() const override { return true; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+
+    size_t getNumberOfArguments() const override { return 0; }
+
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
+
+    bool hasInformationAboutMonotonicity() const override
+    {
+        return true;
+    }
+
+    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override
+    {
+        if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)
+            return { .is_monotonic = true, .is_always_monotonic = true };
+
+        const IFunction::Monotonicity is_monotonic = { .is_monotonic = true };
+        const IFunction::Monotonicity is_not_monotonic;
+
+        const DateLUTImpl * date_lut = &DateLUT::instance();
+        if (const auto * timezone = dynamic_cast<const TimezoneMixin *>(&type))
+            date_lut = &timezone->getTimeZone();
+
+        if (left.isNull() || right.isNull())
+            return is_not_monotonic;
+
+        /// The function is monotonous on the [left, right] segment, if the factor transformation returns the same values for them.
+
+        if (checkAndGetDataType<DataTypeDate>(&type))
+        {
+            return Transform::FactorTransform::execute(UInt16(left.get<UInt64>()), *date_lut)
+                == Transform::FactorTransform::execute(UInt16(right.get<UInt64>()), *date_lut)
+                ? is_monotonic : is_not_monotonic;
+        }
+        else if (checkAndGetDataType<DataTypeDate32>(&type))
+        {
+            return Transform::FactorTransform::execute(Int32(left.get<UInt64>()), *date_lut)
+                   == Transform::FactorTransform::execute(Int32(right.get<UInt64>()), *date_lut)
+                   ? is_monotonic : is_not_monotonic;
+        }
+        else
+        {
+            return Transform::FactorTransform::execute(UInt32(left.get<UInt64>()), *date_lut)
+                == Transform::FactorTransform::execute(UInt32(right.get<UInt64>()), *date_lut)
+                ? is_monotonic : is_not_monotonic;
+        }
+    }
+
+protected:
+    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32) const
+    {
+        if (arguments.size() == 1)
+        {
+            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+                throw Exception(
+                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
+                        + ". Should be Date, Date32, DateTime or DateTime64",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else if (arguments.size() == 2)
+        {
+            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))
+                throw Exception(
+                    "Illegal type " + arguments[0].type->getName() + " of argument of function " + getName()
+                        + ". Should be Date, Date32, DateTime or DateTime64",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if (!isString(arguments[1].type))
+                throw Exception(
+                    "Function " + getName() + " supports 1 or 2 arguments. The optional 2nd argument must be "
+                    "a constant string with a timezone name",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            if ((isDate(arguments[0].type) || isDate32(arguments[0].type)) && is_result_type_date_or_date32)
+                throw Exception(
+                    "The timezone argument of function " + getName() + " is allowed only when the 1st argument has the type DateTime or DateTime64",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else
+            throw Exception(
+                "Number of arguments for function " + getName() + " doesn't match: passed " + toString(arguments.size())
+                    + ", should be 1 or 2",
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+    }
+};
+
+}
diff --git a/src/Functions/TransformDateTime64.h b/src/Functions/TransformDateTime64.h
index 9ac28118b8f2..fbe7e2e82506 100644
--- a/src/Functions/TransformDateTime64.h
+++ b/src/Functions/TransformDateTime64.h
@@ -87,6 +87,46 @@ class TransformDateTime64
         return wrapped_transform.execute(t, std::forward<Args>(args)...);
     }
 
+
+    template <typename ... Args>
+    inline auto NO_SANITIZE_UNDEFINED execute_extended_result(const DateTime64 & t, Args && ... args) const
+    {
+        /// Type conversion from float to integer may be required.
+        /// We are Ok with implementation specific result for out of range and denormals conversion.
+
+        if constexpr (TransformHasExecuteOverload_v<DateTime64, decltype(scale_multiplier), Args...>)
+        {
+            return wrapped_transform.execute_extended_result(t, scale_multiplier, std::forward<Args>(args)...);
+        }
+        else if constexpr (TransformHasExecuteOverload_v<DecimalUtils::DecimalComponents<DateTime64>, Args...>)
+        {
+            auto components = DecimalUtils::splitWithScaleMultiplier(t, scale_multiplier);
+
+            const auto result = wrapped_transform.execute_extended_result(components, std::forward<Args>(args)...);
+            using ResultType = std::decay_t<decltype(result)>;
+
+            if constexpr (std::is_same_v<DecimalUtils::DecimalComponents<DateTime64>, ResultType>)
+            {
+                return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(result, scale_multiplier);
+            }
+            else
+            {
+                return result;
+            }
+        }
+        else
+        {
+            const auto components = DecimalUtils::splitWithScaleMultiplier(t, scale_multiplier);
+            return wrapped_transform.execute_extended_result(static_cast<Int64>(components.whole), std::forward<Args>(args)...);
+        }
+    }
+
+    template <typename T, typename ... Args, typename = std::enable_if_t<!std::is_same_v<T, DateTime64>>>
+    inline auto execute_extended_result(const T & t, Args && ... args) const
+    {
+        return wrapped_transform.execute_extended_result(t, std::forward<Args>(args)...);
+    }
+
 private:
     DateTime64::NativeType scale_multiplier = 1;
     Transform wrapped_transform = {};
diff --git a/src/Functions/toCustomWeek.cpp b/src/Functions/toCustomWeek.cpp
index 13dc76b6389f..b773cc7df966 100644
--- a/src/Functions/toCustomWeek.cpp
+++ b/src/Functions/toCustomWeek.cpp
@@ -1,6 +1,7 @@
 #include <DataTypes/DataTypesNumber.h>
 #include <Functions/CustomWeekTransforms.h>
 #include <Functions/FunctionCustomWeekToSomething.h>
+#include <Functions/FunctionCustomWeekToDateOrDate32.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/IFunction.h>
 
@@ -9,7 +10,7 @@ namespace DB
 {
 using FunctionToWeek = FunctionCustomWeekToSomething<DataTypeUInt8, ToWeekImpl>;
 using FunctionToYearWeek = FunctionCustomWeekToSomething<DataTypeUInt32, ToYearWeekImpl>;
-using FunctionToStartOfWeek = FunctionCustomWeekToSomething<DataTypeDate, ToStartOfWeekImpl>;
+using FunctionToStartOfWeek = FunctionCustomWeekToDateOrDate32<ToStartOfWeekImpl>;
 
 REGISTER_FUNCTION(ToCustomWeek)
 {
diff --git a/src/Functions/toLastDayOfMonth.cpp b/src/Functions/toLastDayOfMonth.cpp
index a7faab15f9fa..9365880bfb83 100644
--- a/src/Functions/toLastDayOfMonth.cpp
+++ b/src/Functions/toLastDayOfMonth.cpp
@@ -1,12 +1,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/DateTimeTransforms.h>
-#include <Functions/FunctionDateOrDateTimeToSomething.h>
+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>
 
 
 namespace DB
 {
 
-using FunctionToLastDayOfMonth = FunctionDateOrDateTimeToSomething<DataTypeDate, ToLastDayOfMonthImpl>;
+using FunctionToLastDayOfMonth = FunctionDateOrDateTimeToDateOrDate32<ToLastDayOfMonthImpl>;
 
 REGISTER_FUNCTION(ToLastDayOfMonth)
 {
diff --git a/src/Functions/toMonday.cpp b/src/Functions/toMonday.cpp
index 89145634e456..280c8a93b1a9 100644
--- a/src/Functions/toMonday.cpp
+++ b/src/Functions/toMonday.cpp
@@ -1,12 +1,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/DateTimeTransforms.h>
-#include <Functions/FunctionDateOrDateTimeToSomething.h>
+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>
 
 
 namespace DB
 {
 
-using FunctionToMonday = FunctionDateOrDateTimeToSomething<DataTypeDate, ToMondayImpl>;
+using FunctionToMonday = FunctionDateOrDateTimeToDateOrDate32<ToMondayImpl>;
 
 REGISTER_FUNCTION(ToMonday)
 {
diff --git a/src/Functions/toStartOfISOYear.cpp b/src/Functions/toStartOfISOYear.cpp
index 366ba8dd09fd..245d043f0b6a 100644
--- a/src/Functions/toStartOfISOYear.cpp
+++ b/src/Functions/toStartOfISOYear.cpp
@@ -1,12 +1,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/DateTimeTransforms.h>
-#include <Functions/FunctionDateOrDateTimeToSomething.h>
+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>
 
 
 namespace DB
 {
 
-using FunctionToStartOfISOYear = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfISOYearImpl>;
+using FunctionToStartOfISOYear = FunctionDateOrDateTimeToDateOrDate32<ToStartOfISOYearImpl>;
 
 REGISTER_FUNCTION(ToStartOfISOYear)
 {
diff --git a/src/Functions/toStartOfMonth.cpp b/src/Functions/toStartOfMonth.cpp
index 9674462097b0..00146e25d442 100644
--- a/src/Functions/toStartOfMonth.cpp
+++ b/src/Functions/toStartOfMonth.cpp
@@ -1,12 +1,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/DateTimeTransforms.h>
-#include <Functions/FunctionDateOrDateTimeToSomething.h>
+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>
 
 
 namespace DB
 {
 
-using FunctionToStartOfMonth = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfMonthImpl>;
+using FunctionToStartOfMonth = FunctionDateOrDateTimeToDateOrDate32<ToStartOfMonthImpl>;
 
 REGISTER_FUNCTION(ToStartOfMonth)
 {
diff --git a/src/Functions/toStartOfQuarter.cpp b/src/Functions/toStartOfQuarter.cpp
index c7d697431982..74966d515843 100644
--- a/src/Functions/toStartOfQuarter.cpp
+++ b/src/Functions/toStartOfQuarter.cpp
@@ -1,12 +1,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/DateTimeTransforms.h>
-#include <Functions/FunctionDateOrDateTimeToSomething.h>
+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>
 
 
 namespace DB
 {
 
-using FunctionToStartOfQuarter = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfQuarterImpl>;
+using FunctionToStartOfQuarter = FunctionDateOrDateTimeToDateOrDate32<ToStartOfQuarterImpl>;
 
 REGISTER_FUNCTION(ToStartOfQuarter)
 {
diff --git a/src/Functions/toStartOfYear.cpp b/src/Functions/toStartOfYear.cpp
index 13729f2f812e..27019bfd69f0 100644
--- a/src/Functions/toStartOfYear.cpp
+++ b/src/Functions/toStartOfYear.cpp
@@ -1,12 +1,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/DateTimeTransforms.h>
-#include <Functions/FunctionDateOrDateTimeToSomething.h>
+#include <Functions/FunctionDateOrDateTimeToDateOrDate32.h>
 
 
 namespace DB
 {
 
-using FunctionToStartOfYear = FunctionDateOrDateTimeToSomething<DataTypeDate, ToStartOfYearImpl>;
+using FunctionToStartOfYear = FunctionDateOrDateTimeToDateOrDate32<ToStartOfYearImpl>;
 
 REGISTER_FUNCTION(ToStartOfYear)
 {
