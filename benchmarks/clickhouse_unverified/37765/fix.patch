diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index 822bdf8d72af..045f6aad2b50 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -1683,20 +1683,40 @@ bool ParserNumber::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 
     char buf[MAX_LENGTH_OF_NUMBER + 1];
 
-    memcpy(buf, pos->begin, pos->size());
-    buf[pos->size()] = 0;
+    size_t size = pos->size();
+    memcpy(buf, pos->begin, size);
+    buf[size] = 0;
+    char * start_pos = buf;
 
-    char * pos_double = buf;
-    errno = 0;    /// Functions strto* don't clear errno.
-    Float64 float_value = std::strtod(buf, &pos_double);
-    if (pos_double != buf + pos->size() || errno == ERANGE)
+    if (*start_pos == '0')
     {
-        /// Try to parse number as binary literal representation. Example: 0b0001.
-        if (pos->size() > 2 && buf[0] == '0' && buf[1] == 'b')
+        ++start_pos;
+        --size;
+
+        /// binary
+        if (*start_pos == 'b')
         {
-            char * buf_skip_prefix = buf + 2;
+            ++start_pos;
+            --size;
+            if (parseNumber(start_pos, size, negative, 2, res))
+            {
+                auto literal = std::make_shared<ASTLiteral>(res);
+                literal->begin = literal_begin;
+                literal->end = ++pos;
+                node = literal;
 
-            if (parseNumber(buf_skip_prefix, pos->size() - 2, negative, 2, res))
+                return true;
+            }
+            else
+                return false;
+        }
+
+        /// hexadecimal
+        if (*start_pos == 'x' || *start_pos == 'X')
+        {
+            ++start_pos;
+            --size;
+            if (parseNumber(start_pos, size, negative, 16, res))
             {
                 auto literal = std::make_shared<ASTLiteral>(res);
                 literal->begin = literal_begin;
@@ -1706,29 +1726,58 @@ bool ParserNumber::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
                 return true;
             }
         }
+        else
+        {
+            /// possible leading zeroes in integer
+            while (*start_pos == '0')
+            {
+                ++start_pos;
+                --size;
+            }
+            if (parseNumber(start_pos, size, negative, 10, res))
+            {
+                auto literal = std::make_shared<ASTLiteral>(res);
+                literal->begin = literal_begin;
+                literal->end = ++pos;
+                node = literal;
 
-        expected.add(pos, "number");
-        return false;
+                return true;
+            }
+        }
     }
+    else if (parseNumber(start_pos, size, negative, 10, res))
+    {
+        auto literal = std::make_shared<ASTLiteral>(res);
+        literal->begin = literal_begin;
+        literal->end = ++pos;
+        node = literal;
 
-    if (float_value < 0)
-        throw Exception("Logical error: token number cannot begin with minus, but parsed float number is less than zero.", ErrorCodes::LOGICAL_ERROR);
+        return true;
+    }
 
-    if (negative)
-        float_value = -float_value;
+    char * pos_double = buf;
+    errno = 0;    /// Functions strto* don't clear errno.
+    Float64 float_value = std::strtod(buf, &pos_double);
+    if (pos_double == buf + pos->size() && errno != ERANGE)
+    {
+        if (float_value < 0)
+            throw Exception("Logical error: token number cannot begin with minus, but parsed float number is less than zero.", ErrorCodes::LOGICAL_ERROR);
 
-    res = float_value;
+        if (negative)
+            float_value = -float_value;
 
-    /// try to use more exact type: UInt64
+        res = float_value;
 
-    parseNumber(buf, pos->size(), negative, 0, res);
+        auto literal = std::make_shared<ASTLiteral>(res);
+        literal->begin = literal_begin;
+        literal->end = ++pos;
+        node = literal;
 
-    auto literal = std::make_shared<ASTLiteral>(res);
-    literal->begin = literal_begin;
-    literal->end = ++pos;
-    node = literal;
+        return true;
+    }
 
-    return true;
+    expected.add(pos, "number");
+    return false;
 }
 
 
