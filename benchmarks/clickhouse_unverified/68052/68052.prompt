You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
ALTER DELETE with skip index on where clause not longer pruning parts
**Describe the issue**

I have a large event table from which we infrequently (1 or 2 per day) need to remove some of the most freshly written data.
We put a minmax skip index on the numeric field we use in the delete where clause, and when we have to run this mutation, it's always very fast because only the latest handful of parts are rewritten.

After I upgraded from 23.12 to 24.5, the same mutation is rewriting every part of the table, like if no parts pruning based on the filter happens anymore. This is a total blocker for us as delete mutations are made unusable by this new behaviour.

After having downgraded to 24.4, then 24.3 then 24.2, I finally managed to find out that this "regression" appeared in 24.3 (24.2 is working as before).

* Which ClickHouse server versions are incompatible

- 24.3
- 24.4
- 24.5

* `CREATE TABLE` statements for all tables involved

```sql
CREATE TABLE evm_blocks_ethereum_mainnet
ON CLUSTER <SOME_CLUSTER> (
    block_hash String,
    block_number UInt64,
    parent_hash String,
    transactions_root String,
    state_root String,
    receipts_root String,
    miner String,
    difficulty UInt256,
    total_difficulty UInt256,
    size UInt32,
    extra_data String,
    gas_limit UInt32,
    gas_used UInt32,
    timestamp DateTime,
    base_fee_per_gas UInt64,
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/tables/{installation}/{cluster}/{shard}/{database}/{uuid}', '{replica}')
PARTITION BY toYYYYMM(timestamp)
ORDER BY (timestamp, block_number);

ALTER TABLE  evm_blocks_ethereum_mainnet
ON CLUSTER <SOME_CLUSTER>
ADD INDEX block_number block_number TYPE minmax GRANULARITY 4;
```

* Queries to run that lead to unexpected result

```sql
ALTER TABLE evm_blocks_ethereum_mainnet DELETE WHERE block_number > <SOME_RECENT_BLOCK_NUMBER>
```

Lightweight deletes using subqueries significantly slower in 24.3
**Describe the unexpected behaviour**

In 24.3, lightweight deletions of the following form appear to run much slower in 24.3 vs 24.2.

```
DELETE FROM tbl
WHERE (a,b,c) in (
  select a,b,c from another_tbl
)
```

The subquery returns very quickly (typically only a few hundred rows), but adding the `DELETE` causes the drop in performance compared to 24.2.

After the CH upgrade we go from few seconds to >1min for the mutation to complete.

We have found a workaround that speeds up the mutation significantly, but is less than ideal : 

```
DELETE FROM tbl
WHERE concatWithSeparator('|', a,b,c) in (
  select concatWithSeparator('|', a,b,c) from another_tbl
)
```

* Both tables have `ORDER BY a,b,c` and do not have partitions specified.
* `a` is a time dimension, where values are in _hourly_ granularity
* `tbl` contains about a million rows for each hour
* the subquery always returns values for deletion for a single hour (the rows _are not_ distributed over all time).
* as mentioned above the subquery returns a small number of rows to delete, up to a few hundred at most
* if the subquery returns no rows, the statement completes quickly, so it looks like it is slow only when there is one or more rows to delete
* deleting a single row takes about the same time as deleting a few hundred.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
