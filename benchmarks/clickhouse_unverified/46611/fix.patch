diff --git a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp
index 49458be42325..531f48377a90 100644
--- a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp
+++ b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.cpp
@@ -170,16 +170,16 @@ ChunkAndProgress IMergeTreeSelectAlgorithm::read()
             return ChunkAndProgress{
                 .chunk = Chunk(ordered_columns, res.row_count),
                 .num_read_rows = res.num_read_rows,
-                .num_read_bytes = res.num_read_bytes};
+                .num_read_bytes = res.num_read_bytes,
+                .is_finished = false};
         }
         else
         {
-            num_read_rows += res.num_read_rows;
-            num_read_bytes += res.num_read_bytes;
+            return {Chunk(), res.num_read_rows, res.num_read_bytes, false};
         }
     }
 
-    return {Chunk(), num_read_rows, num_read_bytes};
+    return {Chunk(), num_read_rows, num_read_bytes, true};
 }
 
 void IMergeTreeSelectAlgorithm::initializeMergeTreeReadersForCurrentTask(
diff --git a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h
index c6680676ce93..22c15635529f 100644
--- a/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h
+++ b/src/Storages/MergeTree/MergeTreeBaseSelectProcessor.h
@@ -20,6 +20,9 @@ struct ChunkAndProgress
     Chunk chunk;
     size_t num_read_rows = 0;
     size_t num_read_bytes = 0;
+    /// Explicitly indicate that we have read all data.
+    /// This is needed to occasionally return empty chunk to indicate the progress while the rows are filtered out in PREWHERE.
+    bool is_finished = false;
 };
 
 struct ParallelReadingExtension
diff --git a/src/Storages/MergeTree/MergeTreeSource.cpp b/src/Storages/MergeTree/MergeTreeSource.cpp
index ae1679cebfd5..a37d1d3ec2cc 100644
--- a/src/Storages/MergeTree/MergeTreeSource.cpp
+++ b/src/Storages/MergeTree/MergeTreeSource.cpp
@@ -176,15 +176,16 @@ ISource::Status MergeTreeSource::prepare()
 }
 
 
-std::optional<Chunk> MergeTreeSource::reportProgress(ChunkAndProgress chunk)
+Chunk MergeTreeSource::processReadResult(ChunkAndProgress chunk)
 {
     if (chunk.num_read_rows || chunk.num_read_bytes)
         progress(chunk.num_read_rows, chunk.num_read_bytes);
 
-    if (chunk.chunk.hasRows())
-        return std::move(chunk.chunk);
+    finished = chunk.is_finished;
 
-    return {};
+    /// We can return a chunk with no rows even if are not finished.
+    /// This allows to report progress when all the rows are filtered out inside MergeTreeBaseSelectProcessor by PREWHERE logic.
+    return std::move(chunk.chunk);
 }
 
 
@@ -194,7 +195,7 @@ std::optional<Chunk> MergeTreeSource::tryGenerate()
     if (async_reading_state)
     {
         if (async_reading_state->getStage() == AsyncReadingState::Stage::IsFinished)
-            return reportProgress(async_reading_state->getResult());
+            return processReadResult(async_reading_state->getResult());
 
         chassert(async_reading_state->getStage() == AsyncReadingState::Stage::NotStarted);
 
@@ -220,7 +221,7 @@ std::optional<Chunk> MergeTreeSource::tryGenerate()
     }
 #endif
 
-    return reportProgress(algorithm->read());
+    return processReadResult(algorithm->read());
 }
 
 #if defined(OS_LINUX)
diff --git a/src/Storages/MergeTree/MergeTreeSource.h b/src/Storages/MergeTree/MergeTreeSource.h
index bba0c0af80e4..463faad0fabe 100644
--- a/src/Storages/MergeTree/MergeTreeSource.h
+++ b/src/Storages/MergeTree/MergeTreeSource.h
@@ -36,7 +36,7 @@ class MergeTreeSource final : public ISource
     std::unique_ptr<AsyncReadingState> async_reading_state;
 #endif
 
-    std::optional<Chunk> reportProgress(ChunkAndProgress chunk);
+    Chunk processReadResult(ChunkAndProgress chunk);
 };
 
 }
