diff --git a/docs/en/sql-reference/statements/drop.md b/docs/en/sql-reference/statements/drop.md
index 8ed00f625d61..159ab09ab946 100644
--- a/docs/en/sql-reference/statements/drop.md
+++ b/docs/en/sql-reference/statements/drop.md
@@ -30,9 +30,11 @@ Also see [UNDROP TABLE](/docs/en/sql-reference/statements/undrop.md)
 Syntax:
 
 ``` sql
-DROP [TEMPORARY] TABLE [IF EXISTS] [IF EMPTY] [db.]name [ON CLUSTER cluster] [SYNC]
+DROP [TEMPORARY] TABLE [IF EXISTS] [IF EMPTY]  [db1.]name_1[, [db2.]name_2, ...] [ON CLUSTER cluster] [SYNC]
 ```
 
+Note that deleting multiple tables at the same time is a non-atomic deletion. If a table fails to be deleted, subsequent tables will not be deleted.
+
 ## DROP DICTIONARY
 
 Deletes the dictionary.
diff --git a/src/Interpreters/DDLTask.cpp b/src/Interpreters/DDLTask.cpp
index a37b4db029ae..37954850851d 100644
--- a/src/Interpreters/DDLTask.cpp
+++ b/src/Interpreters/DDLTask.cpp
@@ -16,6 +16,7 @@
 #include <Parsers/parseQuery.h>
 #include <Parsers/queryToString.h>
 #include <Parsers/ASTQueryWithTableAndOutput.h>
+#include <Parsers/ASTDropQuery.h>
 
 
 namespace DB
@@ -200,6 +201,14 @@ void DDLTaskBase::parseQueryFromEntry(ContextPtr context)
     ParserQuery parser_query(end, settings.allow_settings_after_format_in_insert);
     String description;
     query = parseQuery(parser_query, begin, end, description, 0, settings.max_parser_depth, settings.max_parser_backtracks);
+    if (auto * query_drop = query->as<ASTDropQuery>())
+    {
+        ASTs drops = query_drop->getRewrittenASTsOfSingleTable();
+        if (drops.size() > 1)
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Not supports drop multiple tables for ddl task.");
+
+        query = drops[0];
+    }
 }
 
 void DDLTaskBase::formatRewrittenQuery(ContextPtr context)
diff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp
index c6df401c5550..e29e59ee4c34 100644
--- a/src/Interpreters/InterpreterDropQuery.cpp
+++ b/src/Interpreters/InterpreterDropQuery.cpp
@@ -8,6 +8,7 @@
 #include <Interpreters/QueryLog.h>
 #include <Access/Common/AccessRightsElement.h>
 #include <Parsers/ASTDropQuery.h>
+#include <Parsers/ASTIdentifier.h>
 #include <Storages/IStorage.h>
 #include <Storages/MergeTree/MergeTreeData.h>
 #include <Common/escapeForFileName.h>
@@ -54,16 +55,27 @@ InterpreterDropQuery::InterpreterDropQuery(const ASTPtr & query_ptr_, ContextMut
 {
 }
 
-
 BlockIO InterpreterDropQuery::execute()
 {
+    BlockIO res;
     auto & drop = query_ptr->as<ASTDropQuery &>();
+    ASTs drops = drop.getRewrittenASTsOfSingleTable();
+    for (const auto & drop_query_ptr : drops)
+    {
+        current_query_ptr = drop_query_ptr;
+        res = executeSingleDropQuery(drop_query_ptr);
+    }
+    return res;
+}
 
-    if (!drop.cluster.empty() && drop.table && !drop.if_empty && !maybeRemoveOnCluster(query_ptr, getContext()))
+BlockIO InterpreterDropQuery::executeSingleDropQuery(const ASTPtr & drop_query_ptr)
+{
+    auto & drop = drop_query_ptr->as<ASTDropQuery &>();
+    if (!drop.cluster.empty() && drop.table && !drop.if_empty && !maybeRemoveOnCluster(current_query_ptr, getContext()))
     {
         DDLQueryOnClusterParams params;
         params.access_to_check = getRequiredAccessForDDLOnCluster();
-        return executeDDLQueryOnCluster(query_ptr, getContext(), params);
+        return executeDDLQueryOnCluster(current_query_ptr, getContext(), params);
     }
 
     if (getContext()->getSettingsRef().database_atomic_wait_for_drop_and_detach_synchronously)
@@ -71,11 +83,11 @@ BlockIO InterpreterDropQuery::execute()
 
     if (drop.table)
         return executeToTable(drop);
-    else if (drop.database && !drop.cluster.empty() && !maybeRemoveOnCluster(query_ptr, getContext()))
+    else if (drop.database && !drop.cluster.empty() && !maybeRemoveOnCluster(current_query_ptr, getContext()))
     {
-            DDLQueryOnClusterParams params;
-            params.access_to_check = getRequiredAccessForDDLOnCluster();
-            return executeDDLQueryOnCluster(query_ptr, getContext(), params);
+        DDLQueryOnClusterParams params;
+        params.access_to_check = getRequiredAccessForDDLOnCluster();
+        return executeDDLQueryOnCluster(current_query_ptr, getContext(), params);
     }
     else if (drop.database)
         return executeToDatabase(drop);
@@ -83,7 +95,6 @@ BlockIO InterpreterDropQuery::execute()
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Nothing to drop, both names are empty");
 }
 
-
 void InterpreterDropQuery::waitForTableToBeActuallyDroppedOrDetached(const ASTDropQuery & query, const DatabasePtr & db, const UUID & uuid_to_wait)
 {
     if (uuid_to_wait == UUIDHelpers::Nil)
@@ -156,7 +167,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue
         table_id.uuid = database->tryGetTableUUID(table_id.table_name);
 
         /// Prevents recursive drop from drop database query. The original query must specify a table.
-        bool is_drop_or_detach_database = !query_ptr->as<ASTDropQuery>()->table;
+        bool is_drop_or_detach_database = !current_query_ptr->as<ASTDropQuery>()->table;
 
         AccessFlags drop_storage;
 
@@ -179,7 +190,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue
             return executeDDLQueryOnCluster(new_query_ptr, getContext(), params);
         }
 
-        if (database->shouldReplicateQuery(getContext(), query_ptr))
+        if (database->shouldReplicateQuery(getContext(), current_query_ptr))
         {
             if (query.kind == ASTDropQuery::Kind::Detach)
                 context_->checkAccess(drop_storage, table_id);
@@ -249,7 +260,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue
 
             auto metadata_snapshot = table->getInMemoryMetadataPtr();
             /// Drop table data, don't touch metadata
-            table->truncate(query_ptr, metadata_snapshot, context_, table_excl_lock);
+            table->truncate(current_query_ptr, metadata_snapshot, context_, table_excl_lock);
         }
         else if (query.kind == ASTDropQuery::Kind::Drop)
         {
@@ -308,7 +319,7 @@ BlockIO InterpreterDropQuery::executeToTemporaryTable(const String & table_name,
                     = table->lockExclusively(getContext()->getCurrentQueryId(), getContext()->getSettingsRef().lock_acquire_timeout);
                 /// Drop table data, don't touch metadata
                 auto metadata_snapshot = table->getInMemoryMetadataPtr();
-                table->truncate(query_ptr, metadata_snapshot, getContext(), table_lock);
+                table->truncate(current_query_ptr, metadata_snapshot, getContext(), table_lock);
             }
             else if (kind == ASTDropQuery::Kind::Drop)
             {
@@ -441,11 +452,39 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,
     return {};
 }
 
+void InterpreterDropQuery::extendQueryLogElemImpl(DB::QueryLogElement & elem, const DB::ASTPtr & ast, DB::ContextPtr context_) const
+{
+    auto & drop = ast->as<ASTDropQuery &>();
+    if (drop.database_and_tables)
+    {
+        auto & list = drop.database_and_tables->as<ASTExpressionList &>();
+        for (auto & child : list.children)
+        {
+            auto identifier = dynamic_pointer_cast<ASTTableIdentifier>(child);
+            if (!identifier)
+                throw Exception(ErrorCodes::SYNTAX_ERROR, "Unexpected type for list of table names.");
+
+            String query_database = identifier->getDatabaseName();
+            String query_table = identifier->shortName();
+            if (!query_database.empty() && query_table.empty())
+            {
+                elem.query_databases.insert(backQuoteIfNeed(query_database));
+            }
+            else if (!query_table.empty())
+            {
+                auto quoted_database = query_database.empty() ? backQuoteIfNeed(context_->getCurrentDatabase())
+                                                              : backQuoteIfNeed(query_database);
+                elem.query_databases.insert(quoted_database);
+                elem.query_tables.insert(quoted_database + "." + backQuoteIfNeed(query_table));
+            }
+        }
+    }
+}
 
 AccessRightsElements InterpreterDropQuery::getRequiredAccessForDDLOnCluster() const
 {
     AccessRightsElements required_access;
-    const auto & drop = query_ptr->as<const ASTDropQuery &>();
+    const auto & drop = current_query_ptr->as<const ASTDropQuery &>();
 
     if (!drop.table)
     {
@@ -518,7 +557,7 @@ bool InterpreterDropQuery::supportsTransactions() const
     return drop.cluster.empty()
             && !drop.temporary
             && drop.kind == ASTDropQuery::Kind::Truncate
-            && drop.table;
+            && drop.database_and_tables;
 }
 
 void registerInterpreterDropQuery(InterpreterFactory & factory)
diff --git a/src/Interpreters/InterpreterDropQuery.h b/src/Interpreters/InterpreterDropQuery.h
index 7ae544a7356a..08668f47225a 100644
--- a/src/Interpreters/InterpreterDropQuery.h
+++ b/src/Interpreters/InterpreterDropQuery.h
@@ -29,10 +29,14 @@ class InterpreterDropQuery : public IInterpreter, WithMutableContext
 
     bool supportsTransactions() const override;
 
+    void extendQueryLogElemImpl(QueryLogElement & elem, const ASTPtr & ast, ContextPtr context_) const override;
+
 private:
     AccessRightsElements getRequiredAccessForDDLOnCluster() const;
     ASTPtr query_ptr;
+    ASTPtr current_query_ptr;
 
+    BlockIO executeSingleDropQuery(const ASTPtr & drop_query_ptr);
     BlockIO executeToDatabase(const ASTDropQuery & query);
     BlockIO executeToDatabaseImpl(const ASTDropQuery & query, DatabasePtr & database, std::vector<UUID> & uuids_to_wait);
 
diff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp
index b491be1ea2c0..ecb9ad8169b4 100644
--- a/src/Parsers/ASTDropQuery.cpp
+++ b/src/Parsers/ASTDropQuery.cpp
@@ -1,4 +1,6 @@
 #include <Parsers/ASTDropQuery.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTExpressionList.h>
 #include <Common/quoteString.h>
 #include <IO/Operators.h>
 
@@ -49,7 +51,7 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState
 
     if (has_all_tables)
         settings.ostr << "ALL TABLES ";
-    else if (!table && database)
+    else if (!table && !database_and_tables && database)
         settings.ostr << "DATABASE ";
     else if (is_dictionary)
         settings.ostr << "DICTIONARY ";
@@ -66,10 +68,33 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState
 
     settings.ostr << (settings.hilite ? hilite_none : "");
 
-    if (!table && database)
+    if (!table && !database_and_tables && database)
     {
         database->formatImpl(settings, state, frame);
     }
+    else if (database_and_tables)
+    {
+        auto & list = database_and_tables->as<ASTExpressionList &>();
+        for (auto * it = list.children.begin(); it != list.children.end(); ++it)
+        {
+            if (it != list.children.begin())
+                settings.ostr << ", ";
+
+            auto identifier = dynamic_pointer_cast<ASTTableIdentifier>(*it);
+            if (!identifier)
+                throw Exception(ErrorCodes::SYNTAX_ERROR, "Unexpected type for list of table names.");
+
+            if (auto db = identifier->getDatabase())
+            {
+                db->formatImpl(settings, state, frame);
+                settings.ostr << '.';
+            }
+
+            auto tb = identifier->getTable();
+            chassert(tb);
+            tb->formatImpl(settings, state, frame);
+        }
+    }
     else
     {
         if (database)
@@ -91,4 +116,39 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState
         settings.ostr << (settings.hilite ? hilite_keyword : "") << " SYNC" << (settings.hilite ? hilite_none : "");
 }
 
+ASTs ASTDropQuery::getRewrittenASTsOfSingleTable()
+{
+    ASTs res;
+    if (database_and_tables == nullptr)
+    {
+        res.push_back(shared_from_this());
+        return res;
+    }
+
+    auto & list = database_and_tables->as<ASTExpressionList &>();
+    for (const auto & child : list.children)
+    {
+        auto cloned = clone();
+        auto & query = cloned->as<ASTDropQuery &>();
+        query.database_and_tables = nullptr;
+        query.children.clear();
+
+        auto database_and_table = dynamic_pointer_cast<ASTTableIdentifier>(child);
+        if (!database_and_table)
+            throw Exception(ErrorCodes::SYNTAX_ERROR, "Unexpected type for list of table names.");
+
+        query.database = database_and_table->getDatabase();
+        query.table = database_and_table->getTable();
+
+        if (query.database)
+            query.children.push_back(query.database);
+
+        if (query.table)
+            query.children.push_back(query.table);
+
+        res.push_back(cloned);
+    }
+    return res;
+}
+
 }
diff --git a/src/Parsers/ASTDropQuery.h b/src/Parsers/ASTDropQuery.h
index fe79bdf8bf12..e0e908733e5c 100644
--- a/src/Parsers/ASTDropQuery.h
+++ b/src/Parsers/ASTDropQuery.h
@@ -40,6 +40,9 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu
     // We detach the object permanently, so it will not be reattached back during server restart.
     bool permanently{false};
 
+    /// Example: Drop TABLE t1, t2, t3...
+    ASTPtr database_and_tables;
+
     /** Get the text that identifies this element. */
     String getID(char) const override;
     ASTPtr clone() const override;
@@ -49,6 +52,8 @@ class ASTDropQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnClu
         return removeOnCluster<ASTDropQuery>(clone(), params.default_database);
     }
 
+    ASTs getRewrittenASTsOfSingleTable();
+
     QueryKind getQueryKind() const override { return QueryKind::Drop; }
 
 protected:
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index f2c09e9b0501..1510cc8e1954 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -168,7 +168,7 @@ bool ParserColumnDeclarationList::parseImpl(Pos & pos, ASTPtr & node, Expected &
 
 bool ParserNameList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
-    return ParserList(std::make_unique<ParserCompoundIdentifier>(), std::make_unique<ParserToken>(TokenType::Comma), false)
+    return ParserList(std::make_unique<ParserCompoundIdentifier>(true, true), std::make_unique<ParserToken>(TokenType::Comma), false)
         .parse(pos, node, expected);
 }
 
diff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp
index 75ea5fc89e1c..09f15e9649fd 100644
--- a/src/Parsers/ParserDropQuery.cpp
+++ b/src/Parsers/ParserDropQuery.cpp
@@ -2,7 +2,7 @@
 
 #include <Parsers/CommonParsers.h>
 #include <Parsers/ParserDropQuery.h>
-
+#include <Parsers/ParserCreateQuery.h>
 
 namespace DB
 {
@@ -26,9 +26,10 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     ParserKeyword s_permanently(Keyword::PERMANENTLY);
     ParserKeyword s_no_delay(Keyword::NO_DELAY);
     ParserKeyword s_sync(Keyword::SYNC);
+    ParserNameList tables_p;
 
     ASTPtr database;
-    ASTPtr table;
+    ASTPtr database_and_tables;
     String cluster_str;
     bool if_exists = false;
     bool if_empty = false;
@@ -81,15 +82,8 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
         if (s_if_empty.ignore(pos, expected))
             if_empty = true;
 
-        if (!name_p.parse(pos, table, expected))
+        if (!tables_p.parse(pos, database_and_tables, expected))
             return false;
-
-        if (s_dot.ignore(pos, expected))
-        {
-            database = table;
-            if (!name_p.parse(pos, table, expected))
-                return false;
-        }
     }
 
     /// common for tables / dictionaries / databases
@@ -119,13 +113,13 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     query->sync = sync;
     query->permanently = permanently;
     query->database = database;
-    query->table = table;
+    query->database_and_tables = database_and_tables;
 
     if (database)
         query->children.push_back(database);
 
-    if (table)
-        query->children.push_back(table);
+    if (database_and_tables)
+        query->children.push_back(database_and_tables);
 
     query->cluster = cluster_str;
 
