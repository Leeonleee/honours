{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10534,
  "instance_id": "ClickHouse__ClickHouse-10534",
  "issue_numbers": [
    "9990"
  ],
  "base_commit": "114f09cfcaa0d29b71884ad14bf4a14a78faa644",
  "patch": "diff --git a/src/Functions/FunctionsStringRegex.cpp b/src/Functions/FunctionsStringRegex.cpp\nindex 2f4c2432d547..72d167e51ec7 100644\n--- a/src/Functions/FunctionsStringRegex.cpp\n+++ b/src/Functions/FunctionsStringRegex.cpp\n@@ -44,6 +44,7 @@ namespace ErrorCodes\n     extern const int TOO_MANY_BYTES;\n     extern const int NOT_IMPLEMENTED;\n     extern const int HYPERSCAN_CANNOT_SCAN_TEXT;\n+    extern const int CANNOT_COMPILE_REGEXP;\n }\n \n /// Is the LIKE expression reduced to finding a substring in a string?\n@@ -1081,6 +1082,148 @@ class FunctionStringReplace : public IFunction\n     }\n };\n \n+/** Match all groups of given input string with given re, return array of arrays of matches.\n+ *\n+ *  SELECT extractAllGroups('abc=111, def=222, ghi=333', '(\"[^\"]+\"|\\\\w+)=(\"[^\"]+\"|\\\\w+)')\n+ * should produce:\n+ *   [['abc','def','ghi'], ['111','333','333']]\n+ */\n+class FunctionExtractAllGroups : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"extractAllGroups\";\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionExtractAllGroups>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    bool useDefaultImplementationForConstants() const override { return false; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args{\n+            {\"haystack\", isStringOrFixedString, nullptr, \"const String or const FixedString\"},\n+            {\"needle\", isStringOrFixedString, isColumnConst, \"const String or const FixedString\"},\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n+\n+        // twodimensional array of strings, each `row` of root array represents a group match.\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(std::make_shared<DataTypeString>()));\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) override\n+    {\n+        const ColumnPtr column_haystack = block.getByPosition(arguments[0]).column;\n+        const ColumnPtr column_needle = block.getByPosition(arguments[1]).column;\n+\n+        const auto needle = typeid_cast<const ColumnConst &>(*column_needle).getDataAt(0);\n+\n+        if (needle.size == 0)\n+            throw Exception(getName() + \" length of 'needle' argument must be greater than 0.\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+\n+        re2::RE2 re{re2::StringPiece(needle.data, needle.size)};\n+        if (!re.ok())\n+            throw Exception(getName() + \" invalid regular expression: \" + re.error(), ErrorCodes::CANNOT_COMPILE_REGEXP);\n+\n+        const size_t groups_count = re.NumberOfCapturingGroups();\n+        std::vector<re2::StringPiece> all_matches;\n+        // number of times RE matched on each row of haystack column.\n+        std::vector<size_t> number_of_matches_per_row;\n+\n+        // we expect RE to match multiple times on each row, `* 8` is arbitrary to reduce number of re-allocations.\n+        all_matches.reserve(column_haystack->size() * groups_count * 8);\n+        number_of_matches_per_row.reserve(column_haystack->size());\n+\n+        // including 0-group, which is the whole RE\n+        std::vector<re2::StringPiece> matched_groups(groups_count + 1);\n+\n+        for (size_t i = 0; i < column_haystack->size(); ++i)\n+        {\n+            size_t matches_per_row = 0;\n+            const auto & current_row = column_haystack->getDataAt(i);\n+            const auto haystack = re2::StringPiece(current_row.data, current_row.size);\n+\n+            // Extract all non-intersecting matches from haystack except group #0.\n+            size_t start_pos = 0;\n+            while (start_pos < haystack.size() && re.Match(haystack,\n+                    start_pos, haystack.size(),\n+                    re2::RE2::UNANCHORED,\n+                    matched_groups.data(), matched_groups.size()))\n+            {\n+                // +1 is to exclude group #0 which is whole re match.\n+                all_matches.insert(all_matches.end(), matched_groups.begin() + 1, matched_groups.end());\n+                start_pos = (matched_groups[0].begin() - haystack.begin()) + matched_groups[0].size();\n+\n+                ++matches_per_row;\n+            }\n+\n+            number_of_matches_per_row.push_back(matches_per_row);\n+        }\n+\n+        ColumnString::MutablePtr data_col = ColumnString::create();\n+        {\n+            size_t total_matched_groups_string_len = 0;\n+            for (const auto & m : all_matches)\n+                total_matched_groups_string_len += m.length();\n+\n+            data_col->reserve(total_matched_groups_string_len);\n+        }\n+\n+        ColumnArray::ColumnOffsets::MutablePtr nested_offsets_col = ColumnArray::ColumnOffsets::create();\n+        ColumnArray::ColumnOffsets::MutablePtr root_offsets_col = ColumnArray::ColumnOffsets::create();\n+        nested_offsets_col->reserve(matched_groups.size());\n+        root_offsets_col->reserve(groups_count);\n+\n+        // Re-arrange `all_matches` from:\n+        // [\n+        //      \"ROW 0: 1st group 1st match\",\n+        //      \"ROW 0: 2nd group 1st match\",\n+        //      ...,\n+        //      \"ROW 0: 1st group 2nd match\",\n+        //      \"ROW 0: 2nd group 2nd match\",\n+        //      ...,\n+        //      \"ROW 1: 1st group 1st match\",\n+        //      ...\n+        // ]\n+        //\n+        // into column of 2D arrays:\n+        // [\n+        //      /* all matchig groups from ROW 0 of haystack column */\n+        //      [\"ROW 0: 1st group 1st match\", \"ROW 0: 1st group 2nd match\", ...],\n+        //      [\"ROW 0: 2nd group 1st match\", \"ROW 0: 2nd group 2nd match\", ...],\n+        //      ...\n+        // ],\n+        // [\n+        //      /* all matchig groups from row 1 of haystack column */\n+        //      [\"ROW 1: 1st group 1st match\", ...],\n+        //      ...\n+        // ]\n+\n+        size_t row_offset = 0;\n+        for (const auto matches_per_row : number_of_matches_per_row)\n+        {\n+            const size_t next_row_offset = row_offset + matches_per_row * groups_count;\n+            for (size_t group_id = 0; group_id < groups_count; ++group_id)\n+            {\n+                for (size_t i = row_offset + group_id; i < next_row_offset && i < all_matches.size(); i += groups_count)\n+                {\n+                    const auto & match = all_matches[i];\n+                    data_col->insertData(match.begin(), match.length());\n+                }\n+                nested_offsets_col->insertValue(data_col->size());\n+            }\n+            root_offsets_col->insertValue(nested_offsets_col->size());\n+            row_offset = next_row_offset;\n+        }\n+\n+        ColumnArray::MutablePtr nested_array_col = ColumnArray::create(std::move(data_col), std::move(nested_offsets_col));\n+        ColumnArray::MutablePtr root_array_col = ColumnArray::create(std::move(nested_array_col), std::move(root_offsets_col));\n+        block.getByPosition(result).column = std::move(root_array_col);\n+    }\n+};\n+\n struct NameMatch\n {\n     static constexpr auto name = \"match\";\n@@ -1198,5 +1341,7 @@ void registerFunctionsStringRegex(FunctionFactory & factory)\n     factory.registerFunction<FunctionMultiFuzzyMatchAnyIndex>();\n     factory.registerFunction<FunctionMultiFuzzyMatchAllIndices>();\n     factory.registerAlias(\"replace\", NameReplaceAll::name, FunctionFactory::CaseInsensitive);\n+\n+    factory.registerFunction<FunctionExtractAllGroups>();\n }\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01246_extractAllGroups.reference b/tests/queries/0_stateless/01246_extractAllGroups.reference\nnew file mode 100644\nindex 000000000000..b3d61c3b8416\n--- /dev/null\n+++ b/tests/queries/0_stateless/01246_extractAllGroups.reference\n@@ -0,0 +1,23 @@\n+0 groups, zero matches\n+[]\n+1 group, multiple matches, String and FixedString\n+[['hello','world']]\n+[['hello','world']]\n+[['hello','world']]\n+[['hello','world']]\n+[['hello','world']]\n+[['hello','world']]\n+mutiple groups, multiple matches\n+[['abc','def','ghi','\"jkl mno\"'],['111','222','333','\"444 foo bar\"']]\n+big match\n+0\t1\t0\t[]\n+260\t1\t1\t[156]\n+520\t1\t3\t[156,156,156]\n+lots of matches\n+0\t1\t0\t0\n+260\t1\t260\t260\n+520\t1\t520\t520\n+lots of groups\n+0\t100\t0\t[]\n+260\t100\t2\t[1,1]\n+520\t100\t5\t[1,1,1,1,1]\ndiff --git a/tests/queries/0_stateless/01246_extractAllGroups.sql b/tests/queries/0_stateless/01246_extractAllGroups.sql\nnew file mode 100644\nindex 000000000000..c199aeafc4af\n--- /dev/null\n+++ b/tests/queries/0_stateless/01246_extractAllGroups.sql\n@@ -0,0 +1,51 @@\n+-- error cases\n+SELECT extractAllGroups();  --{serverError 42} not enough arguments\n+SELECT extractAllGroups('hello');  --{serverError 42} not enough arguments\n+SELECT extractAllGroups('hello', 123);  --{serverError 43} invalid argument type\n+SELECT extractAllGroups(123, 'world');  --{serverError 43}  invalid argument type\n+SELECT extractAllGroups('hello world', '((('); --{serverError 427}  invalid re\n+SELECT extractAllGroups('hello world', materialize('\\\\w+')); --{serverError 44} non-cons needle\n+\n+SELECT '0 groups, zero matches';\n+SELECT extractAllGroups('hello world', '\\\\w+');\n+\n+SELECT '1 group, multiple matches, String and FixedString';\n+SELECT extractAllGroups('hello world', '(\\\\w+)');\n+SELECT extractAllGroups('hello world', CAST('(\\\\w+)' as FixedString(5)));\n+SELECT extractAllGroups(CAST('hello world' AS FixedString(12)), '(\\\\w+)');\n+SELECT extractAllGroups(CAST('hello world' AS FixedString(12)), CAST('(\\\\w+)' as FixedString(5)));\n+SELECT extractAllGroups(materialize(CAST('hello world' AS FixedString(12))), '(\\\\w+)');\n+SELECT extractAllGroups(materialize(CAST('hello world' AS FixedString(12))), CAST('(\\\\w+)' as FixedString(5)));\n+\n+SELECT 'mutiple groups, multiple matches';\n+SELECT extractAllGroups('abc=111, def=222, ghi=333 \"jkl mno\"=\"444 foo bar\"', '(\"[^\"]+\"|\\\\w+)=(\"[^\"]+\"|\\\\w+)');\n+\n+SELECT 'big match';\n+SELECT\n+\tlength(haystack), length(matches), length(matches[1]), arrayMap((x) -> length(x), matches[1])\n+FROM (\n+\tSELECT\n+\t\trepeat('abcdefghijklmnopqrstuvwxyz', number * 10) AS haystack,\n+\t\textractAllGroups(haystack, '(abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz)') AS matches\n+\tFROM numbers(3)\n+);\n+\n+SELECT 'lots of matches';\n+SELECT\n+\tlength(haystack), length(matches), length(matches[1]), arrayReduce('sum', arrayMap((x) -> length(x), matches[1]))\n+FROM (\n+\tSELECT\n+\t\trepeat('abcdefghijklmnopqrstuvwxyz', number * 10) AS haystack,\n+\t\textractAllGroups(haystack, '(\\\\w)') AS matches\n+\tFROM numbers(3)\n+);\n+\n+SELECT 'lots of groups';\n+SELECT\n+\tlength(haystack), length(matches), length(matches[1]), arrayMap((x) -> length(x), matches[1])\n+FROM (\n+\tSELECT\n+\t\trepeat('abcdefghijklmnopqrstuvwxyz', number * 10) AS haystack,\n+\t\textractAllGroups(haystack, repeat('(\\\\w)', 100)) AS matches\n+\tFROM numbers(3)\n+);\n",
  "problem_statement": "Add multiExtractAll similar to multiMatchAllIndices but doing actual extract\n**Use case**\r\nNeed to extract multiple expressions in an efficient way. \r\n\r\n**Describe the solution you'd like**\r\n```\r\nSELECT multiMatchAllIndices('abc=111, def=222, ghi=333', ['abc=', 'klm=', 'ghi='])\r\n\r\n\u250c\u2500multiMatchAllIndices('abc=1, def=2, ghi=3', ['abc=', 'klm=', 'ghi='])\u2500\u2510\r\n\u2502 [1,3]                                                                 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nThe function should follow the same logic but return actual matching expressions with respect to capture groups:\r\n\r\n```\r\nSELECT multiExtractAll('abc=111, def=222, ghi=333', ['abc=(\"[^\"]*?\"|[\\\\w]*)', 'klm=(\"[^\"]*?\"|[\\\\w]*)', 'ghi=(\"[^\"]*?\"|[\\\\w]*)'])\r\n\r\nshould return\r\n\r\n['111',333']\r\n```\r\n\r\nCombined with reuse of aliases (#2283) it allows to extract multiple things from a row in a single pass.\r\n\r\nThe alternative is to run multiple regexp searches that is expensive when multiple matches are required.\r\n\r\nSee #7299 for multiMatchAllIndices implementation details.\n",
  "hints_text": "Currently, Hyperscan does not support that:\r\nhttps://github.com/intel/hyperscan/issues/189\r\n\r\n>     * Hyperscan doesn't support _greedy_ or _ungreedy_ semantics but reports all matches instead. So in your case, `\"2\"`, `\"20\"`, `\"201\"` and `\"2018\"` are all valid matches for `[0-9]+`.\r\n>       You can refer to http://intel.github.io/hyperscan/dev-reference/compilation.html#semantics for more details.\r\n> \r\n>     * Hyperscan doesn't support capturing so you are not able to get matched sub-strings from your input.\r\n> \r\n> \r\n> In general, Hyperscan's major targeting use case is networking which takes performance as top priority so as to avoid deny of services. The underlying design of Hyperscan, differing from traditional regex matching library like PCRE, Boost, etc, avoid using backtracking-based approach that doesn't have worst performance guarantee. Greediness and capturing need to be addressed with backtracking so we don't support them so far.\r\n\r\nhttps://github.com/intel/hyperscan/issues/189#issuecomment-542471139\r\n\r\nEven though there is seems to be an [API that does that](https://github.com/intel/hyperscan/blob/865c256dbba20f7f1e1d562b574a3b691af8c47d/src/hs_runtime.h#L125\r\n), in practice it does not work: [the `from` value is always 0](https://github.com/intel/hyperscan/blob/865c256dbba20f7f1e1d562b574a3b691af8c47d/src/report.h#L268) and there is no easy way to fix it.\r\n\nThat sound like more about captured groups in regexps (i.e. smth like `xyz=([0-9]+)([a-z]+)`). \r\n\r\nHere we need to return whole match (by several regexps) \n@filimonov \r\n\r\nFor single regular expression we can add `extractGroups` that will return an array of captured groups starting from 1 in the first match. Also we can add `extractAllGroups` that will return two-dimensional array of groups from all matches.\n> @filimonov\r\n> \r\n> For single regular expression we can add `extractGroups` that will return an array of captured groups starting from 1 in the first match. Also we can add `extractAllGroups` that will return two-dimensional array of groups from all matches.\r\n\r\nYep. Re2-based, based on extractAll , w/o 'multi-' prefix and w/o hyperscan (as @Enmk mentioned hyperscan does not support capture groups).\nI like extractAllGroups. Taking the example above\r\n\r\n```\r\nSELECT extractAllGroups('abc=111, def=222, ghi=333', '(\"[^\"]*?\"|[\\\\w]*)=(\"[^\"]*?\"|[\\\\w]*)')\r\n\r\nshould return\r\n\r\n[['abc','def','ghi'], ['111','333','333']]\r\n```\r\n\n@alex-zaitsev \r\n```\r\n[['abc', 111], ['def', 222], ['ghi', 333]]\r\n```\n@alexey-milovidov , I prefer two arrays that maps better to nested structures. Also not sure it makes sense to perform type inference. The data may be dirty.",
  "created_at": "2020-04-27T14:05:35Z",
  "modified_files": [
    "src/Functions/FunctionsStringRegex.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01246_extractAllGroups.reference",
    "b/tests/queries/0_stateless/01246_extractAllGroups.sql"
  ]
}