{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11037,
  "instance_id": "ClickHouse__ClickHouse-11037",
  "issue_numbers": [
    "10669"
  ],
  "base_commit": "bc5f68f1eed3bb815463121a8d349859946b0ebf",
  "patch": "diff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 91a48f13a395..1921177d0d40 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -594,7 +594,7 @@ bool AlterCommand::isCommentAlter() const\n     return false;\n }\n \n-std::optional<MutationCommand> AlterCommand::tryConvertToMutationCommand(const StorageInMemoryMetadata & metadata) const\n+std::optional<MutationCommand> AlterCommand::tryConvertToMutationCommand(StorageInMemoryMetadata & metadata) const\n {\n     if (!isRequireMutationStage(metadata))\n         return {};\n@@ -637,6 +637,7 @@ std::optional<MutationCommand> AlterCommand::tryConvertToMutationCommand(const S\n     }\n \n     result.ast = ast->clone();\n+    apply(metadata);\n     return result;\n }\n \n@@ -733,6 +734,7 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n     auto all_columns = metadata.columns;\n     /// Default expression for all added/modified columns\n     ASTPtr default_expr_list = std::make_shared<ASTExpressionList>();\n+    NameSet modified_columns, renamed_columns;\n     for (size_t i = 0; i < size(); ++i)\n     {\n         const auto & command = (*this)[i];\n@@ -740,7 +742,7 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n         const auto & column_name = command.column_name;\n         if (command.type == AlterCommand::ADD_COLUMN)\n         {\n-            if (metadata.columns.has(column_name) || metadata.columns.hasNested(column_name))\n+            if (all_columns.has(column_name) || all_columns.hasNested(column_name))\n             {\n                 if (!command.if_not_exists)\n                     throw Exception{\"Cannot add column \" + backQuote(column_name) + \": column with this name already exists\",\n@@ -757,7 +759,7 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n         }\n         else if (command.type == AlterCommand::MODIFY_COLUMN)\n         {\n-            if (!metadata.columns.has(column_name))\n+            if (!all_columns.has(column_name))\n             {\n                 if (!command.if_exists)\n                     throw Exception{\"Wrong column name. Cannot find column \" + backQuote(column_name) + \" to modify\",\n@@ -765,18 +767,23 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n                 else\n                     continue;\n             }\n+\n+            if (renamed_columns.count(column_name))\n+                throw Exception{\"Cannot rename and modify the same column \" + backQuote(column_name) + \" in a single ALTER query\",\n+                                ErrorCodes::NOT_IMPLEMENTED};\n+            modified_columns.emplace(column_name);\n         }\n         else if (command.type == AlterCommand::DROP_COLUMN)\n         {\n-            if (metadata.columns.has(command.column_name) || metadata.columns.hasNested(command.column_name))\n+            if (all_columns.has(command.column_name) || all_columns.hasNested(command.column_name))\n             {\n-                for (const ColumnDescription & column : metadata.columns)\n+                for (const ColumnDescription & column : all_columns)\n                 {\n                     const auto & default_expression = column.default_desc.expression;\n                     if (default_expression)\n                     {\n                         ASTPtr query = default_expression->clone();\n-                        auto syntax_result = SyntaxAnalyzer(context).analyze(query, metadata.columns.getAll());\n+                        auto syntax_result = SyntaxAnalyzer(context).analyze(query, all_columns.getAll());\n                         const auto actions = ExpressionAnalyzer(query, syntax_result, context).getActions(true);\n                         const auto required_columns = actions->getRequiredColumns();\n \n@@ -786,6 +793,7 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n                                 ErrorCodes::ILLEGAL_COLUMN);\n                     }\n                 }\n+                all_columns.remove(command.column_name);\n             }\n             else if (!command.if_exists)\n                 throw Exception(\n@@ -794,7 +802,7 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n         }\n         else if (command.type == AlterCommand::COMMENT_COLUMN)\n         {\n-            if (!metadata.columns.has(command.column_name))\n+            if (!all_columns.has(command.column_name))\n             {\n                 if (!command.if_exists)\n                     throw Exception{\"Wrong column name. Cannot find column \" + backQuote(command.column_name) + \" to comment\",\n@@ -842,6 +850,10 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n                 throw Exception{\"Cannot rename to \" + backQuote(command.rename_to) + \": column with this name already exists\",\n                                 ErrorCodes::DUPLICATE_COLUMN};\n \n+            if (modified_columns.count(column_name))\n+                throw Exception{\"Cannot rename and modify the same column \" + backQuote(column_name) + \" in a single ALTER query\",\n+                                ErrorCodes::NOT_IMPLEMENTED};\n+\n             String from_nested_table_name = Nested::extractTableName(command.column_name);\n             String to_nested_table_name = Nested::extractTableName(command.rename_to);\n             bool from_nested = from_nested_table_name != command.column_name;\n@@ -855,6 +867,8 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n             else if (!from_nested && !to_nested)\n             {\n                 all_columns.rename(command.column_name, command.rename_to);\n+                renamed_columns.emplace(command.column_name);\n+                renamed_columns.emplace(command.rename_to);\n             }\n             else\n             {\n@@ -886,9 +900,9 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n                     default_expr_list->children.emplace_back(setAlias(command.default_expression->clone(), tmp_column_name));\n                 }\n             } /// if we change data type for column with default\n-            else if (metadata.columns.has(column_name) && command.data_type)\n+            else if (all_columns.has(column_name) && command.data_type)\n             {\n-                auto column_in_table = metadata.columns.get(column_name);\n+                auto column_in_table = all_columns.get(column_name);\n                 /// Column doesn't have a default, nothing to check\n                 if (!column_in_table.default_desc.expression)\n                     continue;\n@@ -931,7 +945,7 @@ bool AlterCommands::isCommentAlter() const\n }\n \n \n-MutationCommands AlterCommands::getMutationCommands(const StorageInMemoryMetadata & metadata) const\n+MutationCommands AlterCommands::getMutationCommands(StorageInMemoryMetadata metadata) const\n {\n     MutationCommands result;\n     for (const auto & alter_cmd : *this)\ndiff --git a/src/Storages/AlterCommands.h b/src/Storages/AlterCommands.h\nindex c1c913dad73a..94cf2a2ba37c 100644\n--- a/src/Storages/AlterCommands.h\n+++ b/src/Storages/AlterCommands.h\n@@ -121,7 +121,7 @@ struct AlterCommand\n     /// If possible, convert alter command to mutation command. In other case\n     /// return empty optional. Some storages may execute mutations after\n     /// metadata changes.\n-    std::optional<MutationCommand> tryConvertToMutationCommand(const StorageInMemoryMetadata & metadata) const;\n+    std::optional<MutationCommand> tryConvertToMutationCommand(StorageInMemoryMetadata & metadata) const;\n };\n \n /// Return string representation of AlterCommand::Type\n@@ -162,7 +162,7 @@ class AlterCommands : public std::vector<AlterCommand>\n     /// Return mutation commands which some storages may execute as part of\n     /// alter. If alter can be performed is pure metadata update, than result is\n     /// empty.\n-    MutationCommands getMutationCommands(const StorageInMemoryMetadata & metadata) const;\n+    MutationCommands getMutationCommands(StorageInMemoryMetadata metadata) const;\n };\n \n }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex d84a82dd372b..8e6533575f3a 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -407,7 +407,7 @@ MergeTreeData::DataPartsVector MergeTreeDataMergerMutator::selectAllPartsFromPar\n \n /// PK columns are sorted and merged, ordinary columns are gathered using info from merge step\n static void extractMergingAndGatheringColumns(\n-    const NamesAndTypesList & all_columns,\n+    const NamesAndTypesList & storage_columns,\n     const ExpressionActionsPtr & sorting_key_expr,\n     const MergeTreeIndices & indexes,\n     const MergeTreeData::MergingParams & merging_params,\n@@ -437,11 +437,11 @@ static void extractMergingAndGatheringColumns(\n \n     /// Force to merge at least one column in case of empty key\n     if (key_columns.empty())\n-        key_columns.emplace(all_columns.front().name);\n+        key_columns.emplace(storage_columns.front().name);\n \n     /// TODO: also force \"summing\" and \"aggregating\" columns to make Horizontal merge only for such columns\n \n-    for (const auto & column : all_columns)\n+    for (const auto & column : storage_columns)\n     {\n         if (key_columns.count(column.name))\n         {\n@@ -600,14 +600,14 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n     MergeTreeData::DataPart::ColumnToSize merged_column_to_size;\n \n     Names all_column_names = data.getColumns().getNamesOfPhysical();\n-    NamesAndTypesList all_columns = data.getColumns().getAllPhysical();\n+    NamesAndTypesList storage_columns = data.getColumns().getAllPhysical();\n     const auto data_settings = data.getSettings();\n \n     NamesAndTypesList gathering_columns;\n     NamesAndTypesList merging_columns;\n     Names gathering_column_names, merging_column_names;\n     extractMergingAndGatheringColumns(\n-        all_columns, data.sorting_key_expr, data.skip_indices,\n+        storage_columns, data.sorting_key_expr, data.skip_indices,\n         data.merging_params, gathering_columns, gathering_column_names, merging_columns, merging_column_names);\n \n     MergeTreeData::MutableDataPartPtr new_data_part = data.createPart(\n@@ -617,7 +617,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n         disk,\n         TMP_PREFIX + future_part.name);\n \n-    new_data_part->setColumns(all_columns);\n+    new_data_part->setColumns(storage_columns);\n     new_data_part->partition.assign(future_part.getPartition());\n     new_data_part->is_temp = true;\n \n@@ -669,7 +669,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n     }\n     else\n     {\n-        merging_columns = all_columns;\n+        merging_columns = storage_columns;\n         merging_column_names = all_column_names;\n         gathering_columns.clear();\n         gathering_column_names.clear();\n@@ -959,7 +959,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n     if (merge_alg != MergeAlgorithm::Vertical)\n         to.writeSuffixAndFinalizePart(new_data_part);\n     else\n-        to.writeSuffixAndFinalizePart(new_data_part, &all_columns, &checksums_gathered_columns);\n+        to.writeSuffixAndFinalizePart(new_data_part, &storage_columns, &checksums_gathered_columns);\n \n     return new_data_part;\n }\n@@ -1018,7 +1018,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mutatePartToTempor\n     UInt64 watch_prev_elapsed = 0;\n     MergeStageProgress stage_progress(1.0);\n \n-    NamesAndTypesList all_columns = data.getColumns().getAllPhysical();\n+    NamesAndTypesList storage_columns = data.getColumns().getAllPhysical();\n \n     if (!for_interpreter.empty())\n     {\n@@ -1036,7 +1036,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mutatePartToTempor\n \n     /// It shouldn't be changed by mutation.\n     new_data_part->index_granularity_info = source_part->index_granularity_info;\n-    new_data_part->setColumns(getColumnsForNewDataPart(source_part, updated_header, all_columns, for_file_renames));\n+    new_data_part->setColumns(getColumnsForNewDataPart(source_part, updated_header, storage_columns, for_file_renames));\n     new_data_part->partition.assign(source_part->partition);\n \n     auto disk = new_data_part->disk;\n@@ -1113,7 +1113,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mutatePartToTempor\n             disk->createHardLink(it->path(), destination);\n         }\n \n-        merge_entry->columns_written = all_columns.size() - updated_header.columns();\n+        merge_entry->columns_written = storage_columns.size() - updated_header.columns();\n \n         new_data_part->checksums = source_part->checksums;\n \n@@ -1255,74 +1255,85 @@ void MergeTreeDataMergerMutator::splitMutationCommands(\n     MutationCommands & for_interpreter,\n     MutationCommands & for_file_renames)\n {\n-    NameSet removed_columns_from_compact_part;\n-    NameSet already_changed_columns;\n-    bool is_compact_part = isCompactPart(part);\n-    for (const auto & command : commands)\n+    ColumnsDescription part_columns(part->getColumns());\n+\n+    if (isCompactPart(part))\n     {\n-        if (command.type == MutationCommand::Type::DELETE\n-            || command.type == MutationCommand::Type::UPDATE\n-            || command.type == MutationCommand::Type::MATERIALIZE_INDEX\n-            || command.type == MutationCommand::Type::MATERIALIZE_TTL)\n+        NameSet mutated_columns;\n+        for (const auto & command : commands)\n         {\n-            for_interpreter.push_back(command);\n-            for (const auto & [column_name, expr] : command.column_to_update_expression)\n-                already_changed_columns.emplace(column_name);\n-        }\n-        else if (command.type == MutationCommand::Type::READ_COLUMN)\n-        {\n-            /// If we don't have this column in source part, than we don't\n-            /// need to materialize it\n-            if (part->getColumns().contains(command.column_name))\n+            if (command.type == MutationCommand::Type::MATERIALIZE_INDEX\n+                || command.type == MutationCommand::Type::MATERIALIZE_TTL\n+                || command.type == MutationCommand::Type::DELETE\n+                || command.type == MutationCommand::Type::UPDATE)\n             {\n                 for_interpreter.push_back(command);\n-                if (!command.column_name.empty())\n-                    already_changed_columns.emplace(command.column_name);\n+                for (const auto & [column_name, expr] : command.column_to_update_expression)\n+                    mutated_columns.emplace(column_name);\n             }\n-            else\n+            else if (command.type == MutationCommand::Type::DROP_INDEX)\n+            {\n                 for_file_renames.push_back(command);\n-\n-        }\n-        else if (is_compact_part && command.type == MutationCommand::Type::DROP_COLUMN)\n-        {\n-            removed_columns_from_compact_part.emplace(command.column_name);\n-            for_file_renames.push_back(command);\n-        }\n-        else if (command.type == MutationCommand::Type::RENAME_COLUMN)\n-        {\n-            if (is_compact_part)\n+            }\n+            else if (part_columns.has(command.column_name))\n             {\n-                for_interpreter.push_back(\n+                if (command.type == MutationCommand::Type::DROP_COLUMN)\n+                {\n+                    mutated_columns.emplace(command.column_name);\n+                }\n+                else if (command.type == MutationCommand::Type::RENAME_COLUMN)\n                 {\n-                    .type = MutationCommand::Type::READ_COLUMN,\n-                    .column_name = command.rename_to,\n-                });\n-                already_changed_columns.emplace(command.column_name);\n+                    for_interpreter.push_back(\n+                    {\n+                        .type = MutationCommand::Type::READ_COLUMN,\n+                        .column_name = command.rename_to,\n+                    });\n+                    mutated_columns.emplace(command.column_name);\n+                    part_columns.rename(command.column_name, command.rename_to);\n+                }\n             }\n-            else\n-                for_file_renames.push_back(command);\n         }\n-        else\n+        /// If it's compact part than we don't need to actually remove files\n+        /// from disk we just don't read dropped columns\n+        for (const auto & column : part->getColumns())\n         {\n-            for_file_renames.push_back(command);\n+            if (!mutated_columns.count(column.name))\n+                for_interpreter.emplace_back(\n+                    MutationCommand{.type = MutationCommand::Type::READ_COLUMN, .column_name = column.name, .data_type = column.type});\n         }\n     }\n-\n-    if (is_compact_part)\n+    else\n     {\n-        /// If it's compact part than we don't need to actually remove files from disk\n-        /// we just don't read dropped columns\n-        for (const auto & column : part->getColumns())\n+        for (const auto & command : commands)\n         {\n-            if (!removed_columns_from_compact_part.count(column.name)\n-                && !already_changed_columns.count(column.name))\n+            if (command.type == MutationCommand::Type::MATERIALIZE_INDEX\n+                || command.type == MutationCommand::Type::MATERIALIZE_TTL\n+                || command.type == MutationCommand::Type::DELETE\n+                || command.type == MutationCommand::Type::UPDATE)\n+            {\n+                for_interpreter.push_back(command);\n+            }\n+            else if (command.type == MutationCommand::Type::DROP_INDEX)\n+            {\n+                for_file_renames.push_back(command);\n+            }\n+            /// If we don't have this column in source part, than we don't need\n+            /// to materialize it\n+            else if (part_columns.has(command.column_name))\n             {\n-                for_interpreter.emplace_back(MutationCommand\n+                if (command.type == MutationCommand::Type::READ_COLUMN)\n                 {\n-                    .type = MutationCommand::Type::READ_COLUMN,\n-                    .column_name = column.name,\n-                    .data_type = column.type\n-                });\n+                    for_interpreter.push_back(command);\n+                }\n+                else if (command.type == MutationCommand::Type::RENAME_COLUMN)\n+                {\n+                    part_columns.rename(command.column_name, command.rename_to);\n+                    for_file_renames.push_back(command);\n+                }\n+                else\n+                {\n+                    for_file_renames.push_back(command);\n+                }\n             }\n         }\n     }\n@@ -1429,9 +1440,14 @@ NameSet MergeTreeDataMergerMutator::collectFilesToSkip(\n NamesAndTypesList MergeTreeDataMergerMutator::getColumnsForNewDataPart(\n     MergeTreeData::DataPartPtr source_part,\n     const Block & updated_header,\n-    NamesAndTypesList all_columns,\n+    NamesAndTypesList storage_columns,\n     const MutationCommands & commands_for_removes)\n {\n+    /// In compact parts we read all columns, because they all stored in a\n+    /// single file\n+    if (isCompactPart(source_part))\n+        return updated_header.getNamesAndTypesList();\n+\n     NameSet removed_columns;\n     NameToNameMap renamed_columns;\n     for (const auto & command : commands_for_removes)\n@@ -1443,7 +1459,7 @@ NamesAndTypesList MergeTreeDataMergerMutator::getColumnsForNewDataPart(\n     }\n     Names source_column_names = source_part->getColumns().getNames();\n     NameSet source_columns_name_set(source_column_names.begin(), source_column_names.end());\n-    for (auto it = all_columns.begin(); it != all_columns.end();)\n+    for (auto it = storage_columns.begin(); it != storage_columns.end();)\n     {\n         if (updated_header.has(it->name))\n         {\n@@ -1461,9 +1477,12 @@ NamesAndTypesList MergeTreeDataMergerMutator::getColumnsForNewDataPart(\n             ++it;\n         }\n         else\n-            it = all_columns.erase(it);\n+        {\n+            it = storage_columns.erase(it);\n+        }\n     }\n-    return all_columns;\n+\n+    return storage_columns;\n }\n \n MergeTreeIndices MergeTreeDataMergerMutator::getIndicesForNewDataPart(\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.h b/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\nindex 78de7375d70e..431d059ba60f 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.h\n@@ -153,11 +153,11 @@ class MergeTreeDataMergerMutator\n     /// Because we will generate new versions of them after we perform mutation.\n     static NameSet collectFilesToSkip(const Block & updated_header, const std::set<MergeTreeIndexPtr> & indices_to_recalc, const String & mrk_extension);\n \n-    /// Get the columns list of the resulting part in the same order as all_columns.\n+    /// Get the columns list of the resulting part in the same order as storage_columns.\n     static NamesAndTypesList getColumnsForNewDataPart(\n         MergeTreeData::DataPartPtr source_part,\n         const Block & updated_header,\n-        NamesAndTypesList all_columns,\n+        NamesAndTypesList storage_columns,\n         const MutationCommands & commands_for_removes);\n \n     /// Get skip indcies, that should exists in the resulting data part.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01281_alter_rename_and_other_renames.reference b/tests/queries/0_stateless/01281_alter_rename_and_other_renames.reference\nnew file mode 100644\nindex 000000000000..f0a906147ac3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01281_alter_rename_and_other_renames.reference\n@@ -0,0 +1,24 @@\n+CREATE TABLE default.rename_table_multiple\\n(\\n    `key` Int32, \\n    `value1_string` String, \\n    `value2` Int32\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+key\tvalue1_string\tvalue2\n+1\t2\t3\n+CREATE TABLE default.rename_table_multiple\\n(\\n    `key` Int32, \\n    `value1_string` String, \\n    `value2_old` Int32, \\n    `value2` Int64 DEFAULT 7\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+key\tvalue1_string\tvalue2_old\tvalue2\n+1\t2\t3\t7\n+4\t5\t6\t7\n+CREATE TABLE default.rename_table_multiple\\n(\\n    `key` Int32, \\n    `value1_string` String, \\n    `value2_old` Int64 DEFAULT 7\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+key\tvalue1_string\tvalue2_old\n+1\t2\t7\n+4\t5\t7\n+7\t8\t10\n+CREATE TABLE default.rename_table_multiple_compact\\n(\\n    `key` Int32, \\n    `value1_string` String, \\n    `value2` Int32\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS min_rows_for_wide_part = 100000, index_granularity = 8192\n+key\tvalue1_string\tvalue2\n+1\t2\t3\n+CREATE TABLE default.rename_table_multiple_compact\\n(\\n    `key` Int32, \\n    `value1_string` String, \\n    `value2_old` Int32, \\n    `value2` Int64 DEFAULT 7\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS min_rows_for_wide_part = 100000, index_granularity = 8192\n+key\tvalue1_string\tvalue2_old\tvalue2\n+1\t2\t3\t7\n+4\t5\t6\t7\n+CREATE TABLE default.rename_table_multiple_compact\\n(\\n    `key` Int32, \\n    `value1_string` String, \\n    `value2_old` Int64 DEFAULT 7\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS min_rows_for_wide_part = 100000, index_granularity = 8192\n+key\tvalue1_string\tvalue2_old\n+1\t2\t7\n+4\t5\t7\n+7\t8\t10\ndiff --git a/tests/queries/0_stateless/01281_alter_rename_and_other_renames.sql b/tests/queries/0_stateless/01281_alter_rename_and_other_renames.sql\nnew file mode 100644\nindex 000000000000..f9462f0478e3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01281_alter_rename_and_other_renames.sql\n@@ -0,0 +1,67 @@\n+DROP TABLE IF EXISTS rename_table_multiple;\n+\n+CREATE TABLE rename_table_multiple (key Int32, value1 String, value2 Int32) ENGINE = MergeTree ORDER BY tuple();\n+\n+INSERT INTO rename_table_multiple VALUES (1, 2, 3);\n+\n+ALTER TABLE rename_table_multiple RENAME COLUMN value1 TO value1_string, MODIFY COLUMN value1_string String; --{serverError 48}\n+ALTER TABLE rename_table_multiple MODIFY COLUMN value1 String, RENAME COLUMN value1 to value1_string; --{serverError 48}\n+\n+ALTER TABLE rename_table_multiple RENAME COLUMN value1 TO value1_string;\n+ALTER TABLE rename_table_multiple MODIFY COLUMN value1_string String;\n+\n+SHOW CREATE TABLE rename_table_multiple;\n+\n+SELECT * FROM rename_table_multiple FORMAT TSVWithNames;\n+\n+INSERT INTO rename_table_multiple VALUES (4, '5', 6);\n+\n+ALTER TABLE rename_table_multiple RENAME COLUMN value2 TO value2_old, ADD COLUMN value2 Int64 DEFAULT 7;\n+\n+SHOW CREATE TABLE rename_table_multiple;\n+\n+SELECT * FROM rename_table_multiple ORDER BY key FORMAT TSVWithNames;\n+\n+INSERT INTO rename_table_multiple VALUES (7, '8', 9, 10);\n+\n+ALTER TABLE rename_table_multiple DROP COLUMN value2_old, RENAME COLUMN value2 TO value2_old;\n+\n+SHOW CREATE TABLE rename_table_multiple;\n+\n+SELECT * FROM rename_table_multiple ORDER BY key FORMAT TSVWithNames;\n+\n+DROP TABLE IF EXISTS rename_table_multiple;\n+\n+DROP TABLE IF EXISTS rename_table_multiple_compact;\n+\n+CREATE TABLE rename_table_multiple_compact (key Int32, value1 String, value2 Int32) ENGINE = MergeTree ORDER BY tuple() SETTINGS min_rows_for_wide_part = 100000;\n+\n+INSERT INTO rename_table_multiple_compact VALUES (1, 2, 3);\n+\n+ALTER TABLE rename_table_multiple_compact RENAME COLUMN value1 TO value1_string, MODIFY COLUMN value1_string String; --{serverError 48}\n+ALTER TABLE rename_table_multiple_compact MODIFY COLUMN value1 String, RENAME COLUMN value1 to value1_string; --{serverError 48}\n+\n+ALTER TABLE rename_table_multiple_compact RENAME COLUMN value1 TO value1_string;\n+ALTER TABLE rename_table_multiple_compact MODIFY COLUMN value1_string String;\n+\n+SHOW CREATE TABLE rename_table_multiple_compact;\n+\n+SELECT * FROM rename_table_multiple_compact FORMAT TSVWithNames;\n+\n+INSERT INTO rename_table_multiple_compact VALUES (4, '5', 6);\n+\n+ALTER TABLE rename_table_multiple_compact RENAME COLUMN value2 TO value2_old, ADD COLUMN value2 Int64 DEFAULT 7;\n+\n+SHOW CREATE TABLE rename_table_multiple_compact;\n+\n+SELECT * FROM rename_table_multiple_compact ORDER BY key FORMAT TSVWithNames;\n+\n+INSERT INTO rename_table_multiple_compact VALUES (7, '8', 9, 10);\n+\n+ALTER TABLE rename_table_multiple_compact DROP COLUMN value2_old, RENAME COLUMN value2 TO value2_old;\n+\n+SHOW CREATE TABLE rename_table_multiple_compact;\n+\n+SELECT * FROM rename_table_multiple_compact ORDER BY key FORMAT TSVWithNames;\n+\n+DROP TABLE IF EXISTS rename_table_multiple_compact;\n",
  "problem_statement": "It's impossible to rename and modify the same column in one alter query.\n**Describe the bug**\r\nAll of the following variants to run `ALTER` with `MODIFY` and `RENAME` don't work.\r\n\r\n**How to reproduce**\r\n```\r\nCREATE TABLE t (i Int32) ENGINE = MergeTree ORDER BY tuple();\r\nINSERT INTO t VALUES (1);\r\n```\r\n\r\n- ```ALTER TABLE t MODIFY COLUMN i String, RENAME COLUMN i TO s```\r\nAlter starts, but fails with stacktrace:\r\n```\r\n2020.05.05 03:25:58.620584 [ 27017 ] {} <Error> void DB::BackgroundProcessingPool::threadFunction(): Code: 47, e.displayText() = DB::Exception: Missing columns: 'i' while processing query: 'i, i', required columns: 'i', source columns: 's', Stack trace (when copying this message, always include the lines below):\r\n\r\n0. Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x10564e40 in /usr/lib/debug/usr/bin/clickhouse\r\n1. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/new:324: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x90b8d3d in /usr/lib/debug/usr/bin/clickhouse\r\n2. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/__tree:1833: std::__1::__shared_ptr_emplace<DB::NullBlockOutputStream, std::__1::allocator<DB::NullBlockOutputStream> >::~__shared_ptr_emplace() @ 0xd62d7bb in /usr/lib/debug/usr/bin/clickhouse\r\n3. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/new:324: std::__1::__list_imp<DB::InputPort, std::__1::allocator<DB::InputPort> >::clear() (.part.0) @ 0xd625dcb in /usr/lib/debug/usr/bin/clickhouse\r\n4. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/memory:3554: std::__1::__shared_ptr_emplace<DB::ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry, std::__1::allocator<DB::ReplicatedMergeTreeLogEntryData::ReplaceRangeEntry> >::~__shared_ptr_emplace() @ 0xd5b0512 in /usr/lib/debug/usr/bin/clickhouse\r\n5. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/__tree:1834: std::__1::__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::__unordered_map_hasher<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::set<long, std::__1::less<long>, std::__1::allocator<long> > > > >::~__hash_table() @ 0xd5b89bc in /usr/lib/debug/usr/bin/clickhouse\r\n6. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/stdexcept:251: DB::MutationsInterpreter::MutationsInterpreter(std::__1::shared_ptr<DB::IStorage>, DB::MutationCommands, DB::Context const&, bool) @ 0xd5baaf9 in /usr/lib/debug/usr/bin/clickhouse\r\n7. /build/obj-x86_64-linux-gnu/../base/common/../common/itoa.h:127: char* impl::convert::uitoa<unsigned long, 8ul>(char*, unsigned long) @ 0xd83f79b in /usr/lib/debug/usr/bin/clickhouse\r\n8. /build/obj-x86_64-linux-gnu/../dbms/src/DataTypes/DataTypeString.h:11: ? @ 0xd8406cb in /usr/lib/debug/usr/bin/clickhouse\r\n9. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/list:758: DB::BackgroundProcessingPool::threadFunction() @ 0xd97e245 in /usr/lib/debug/usr/bin/clickhouse\r\n10. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/string:1498: ? @ 0xd97eb72 in /usr/lib/debug/usr/bin/clickhouse\r\n11. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/string:1519: std::__1::__tree_iterator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::__tree_node<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, void*>*, long> std::__1::__tree<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >::find<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x90e04ab in /usr/lib/debug/usr/bin/clickhouse\r\n12. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/future:1164: std::__1::future<Coordination::GetResponse>::~future() @ 0x90de993 in /usr/lib/debug/usr/bin/clickhouse\r\n13. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n14. /build/glibc-OTsEL5/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97: clone @ 0x12188f in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n (version 20.5.1.3239 (official build))\r\n```\r\n\r\n- ```ALTER TABLE t RENAME COLUMN i TO s, MODIFY COLUMN s String```\r\nFails with:\r\n```\r\nReceived exception from server (version 20.5.1):\r\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Wrong column name. Cannot find column `s` to modify.\r\n```\r\n\r\n- ```ALTER TABLE t RENAME COLUMN i TO s, MODIFY COLUMN i String```\r\nFails with:\r\n```\r\nReceived exception from server (version 20.5.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Cannot find column i in ColumnsDescription.\r\n```\r\n\r\n**Expected behavior**\r\nAlter with modify and rename column should be possible or should be thrown clear exception, which tells that such functionality is not implemented.\r\n\n",
  "hints_text": "ALTER TABLE t RENAME COLUMN x TO old, rename COLUMN new to x\r\n\r\nalso does not work\n> ALTER TABLE t RENAME COLUMN x TO old, rename COLUMN new to x\r\n> \r\n> also does not work\r\n\r\nFix for this: https://github.com/ClickHouse/ClickHouse/pull/10895\nWill fix combined modify and rename in the next PR.",
  "created_at": "2020-05-19T10:54:28Z",
  "modified_files": [
    "src/Storages/AlterCommands.cpp",
    "src/Storages/AlterCommands.h",
    "src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp",
    "src/Storages/MergeTree/MergeTreeDataMergerMutator.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01281_alter_rename_and_other_renames.reference",
    "b/tests/queries/0_stateless/01281_alter_rename_and_other_renames.sql"
  ]
}