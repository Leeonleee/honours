{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25300,
  "instance_id": "ClickHouse__ClickHouse-25300",
  "issue_numbers": [
    "25134"
  ],
  "base_commit": "b29804752717749cb3f1056c2f2611219d92e58c",
  "patch": "diff --git a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\nindex 19ead09ae4b5..a31d4941535b 100644\n--- a/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n+++ b/src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp\n@@ -10,6 +10,7 @@\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeCustomSimpleAggregateFunction.h>\n #include <DataTypes/NestedUtils.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n #include <IO/WriteHelpers.h>\n \n \n@@ -44,6 +45,11 @@ struct SummingSortedAlgorithm::AggregateDescription\n     AlignedBuffer state;\n     bool created = false;\n \n+    /// Those types are used only for simple aggregate functions.\n+    /// For LowCardinality, convert to nested type. nested_type is nullptr if no conversion needed.\n+    DataTypePtr nested_type; /// Nested type for LowCardinality, if it is.\n+    DataTypePtr real_type; /// Type in header.\n+\n     /// In case when column has type AggregateFunction:\n     /// use the aggregate function from itself instead of 'function' above.\n     bool is_agg_func_type = false;\n@@ -266,6 +272,11 @@ static SummingSortedAlgorithm::ColumnsDefinition defineColumns(\n                     desc.init(simple->getFunction(), true);\n                     if (desc.function->allocatesMemoryInArena())\n                         def.allocates_memory_in_arena = true;\n+\n+                    desc.real_type = column.type;\n+                    desc.nested_type = recursiveRemoveLowCardinality(desc.real_type);\n+                    if (desc.real_type.get() == desc.nested_type.get())\n+                        desc.nested_type = nullptr;\n                 }\n                 else if (!is_agg_func)\n                 {\n@@ -384,6 +395,12 @@ static MutableColumns getMergedDataColumns(\n \n             columns.emplace_back(ColumnTuple::create(std::move(tuple_columns)));\n         }\n+        else if (desc.is_simple_agg_func_type)\n+        {\n+            const auto & type = desc.nested_type ? desc.nested_type\n+                                                 : desc.real_type;\n+            columns.emplace_back(type->createColumn());\n+        }\n         else\n             columns.emplace_back(header.safeGetByPosition(desc.column_numbers[0]).column->cloneEmpty());\n     }\n@@ -394,7 +411,7 @@ static MutableColumns getMergedDataColumns(\n     return columns;\n }\n \n-static void preprocessChunk(Chunk & chunk)\n+static void preprocessChunk(Chunk & chunk, const SummingSortedAlgorithm::ColumnsDefinition & def)\n {\n     auto num_rows = chunk.getNumRows();\n     auto columns = chunk.detachColumns();\n@@ -402,6 +419,15 @@ static void preprocessChunk(Chunk & chunk)\n     for (auto & column : columns)\n         column = column->convertToFullColumnIfConst();\n \n+    for (const auto & desc : def.columns_to_aggregate)\n+    {\n+        if (desc.is_simple_agg_func_type && desc.nested_type)\n+        {\n+            auto & col = columns[desc.column_numbers[0]];\n+            col = recursiveRemoveLowCardinality(col);\n+        }\n+    }\n+\n     chunk.setColumns(std::move(columns), num_rows);\n }\n \n@@ -427,6 +453,12 @@ static void postprocessChunk(\n             for (size_t i = 0; i < tuple_size; ++i)\n                 res_columns[desc.column_numbers[i]] = assert_cast<const ColumnTuple &>(*column).getColumnPtr(i);\n         }\n+        else if (desc.is_simple_agg_func_type && desc.nested_type)\n+        {\n+            const auto & from_type = desc.nested_type;\n+            const auto & to_type = desc.real_type;\n+            res_columns[desc.column_numbers[0]] = recursiveTypeConversion(std::move(column), from_type, to_type);\n+        }\n         else\n             res_columns[desc.column_numbers[0]] = std::move(column);\n     }\n@@ -670,14 +702,14 @@ void SummingSortedAlgorithm::initialize(Inputs inputs)\n {\n     for (auto & input : inputs)\n         if (input.chunk)\n-            preprocessChunk(input.chunk);\n+            preprocessChunk(input.chunk, columns_definition);\n \n     initializeQueue(std::move(inputs));\n }\n \n void SummingSortedAlgorithm::consume(Input & input, size_t source_num)\n {\n-    preprocessChunk(input.chunk);\n+    preprocessChunk(input.chunk, columns_definition);\n     updateCursor(input, source_num);\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01532_execute_merges_on_single_replica.sql b/tests/queries/0_stateless/01532_execute_merges_on_single_replica.sql\nindex 2fa89ed3464c..69369321d262 100644\n--- a/tests/queries/0_stateless/01532_execute_merges_on_single_replica.sql\n+++ b/tests/queries/0_stateless/01532_execute_merges_on_single_replica.sql\n@@ -115,7 +115,7 @@ SELECT\n     arraySort(groupArrayIf(table, event_type = 'MergeParts')) AS mergers,\n     arraySort(groupArrayIf(table, event_type = 'DownloadPart')) AS fetchers\n FROM system.part_log\n-WHERE (event_time > (now() - 40))\n+WHERE (event_time > (now() - 120))\n   AND (table LIKE 'execute\\\\_on\\\\_single\\\\_replica\\\\_r%')\n   AND (part_name NOT LIKE '%\\\\_0')\n   AND (database = currentDatabase())\ndiff --git a/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.reference b/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.reference\nnew file mode 100644\nindex 000000000000..b9a964c80d0f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.reference\n@@ -0,0 +1,2 @@\n+1\tx\n+1\ty\ndiff --git a/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.sql b/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.sql\nnew file mode 100644\nindex 000000000000..f4785c963125\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.sql\n@@ -0,0 +1,21 @@\n+drop table if exists smta;\n+\n+CREATE TABLE smta\n+(\n+    `k` Int64,\n+    `a` AggregateFunction(max, Int64),\n+    `city` SimpleAggregateFunction(max, LowCardinality(String))\n+)\n+ENGINE = SummingMergeTree\n+ORDER BY k;\n+\n+insert into smta(k, city) values (1, 'x');\n+\n+select k, city from smta;\n+\n+insert into smta(k, city) values (1, 'y');\n+optimize table smta;\n+\n+select k, city from smta;\n+\n+drop table if exists smta;\n",
  "problem_statement": "crash SimpleAggregateFunction + LowCardinality(String)\n```\r\nCREATE TABLE smta\r\n(\r\n    `k` Int64,\r\n    `a` AggregateFunction(max, Int64),\r\n    `city` SimpleAggregateFunction(max, LowCardinality(String))\r\n)\r\nENGINE = SummingMergeTree\r\nORDER BY k;\r\n\r\ninsert  into smta(k, city) values (1, 'x');\r\n\r\nBaseDaemon: ########################################\r\nBaseDaemon: (version 21.7.1.7020 (official build), build id: F609E0F0A9A1245F3A29AA02CB5A58D597BFA40D) (from thread 2\r\n\r\nBaseDaemon: Address: 0x1 Access: read. Address not mapped to object.\r\nBaseDaemon: Stack trace: 0x8d33350 0x10855b5b 0x1085a947 0x1040e6d8 0x1040f628 0x102fbcca 0xfa627b2 0xfa6c46b 0xfa6ca\r\n\r\nBaseDaemon: 1. memcpy @ 0x8d33350 in /usr/bin/clickhouse\r\nBaseDaemon: 2. DB::SummingSortedAlgorithm::SummingMergedData::addRowImpl(std::__1::vector<DB::IColumn const*, std::__\r\nBaseDaemon: 3. DB::SummingSortedAlgorithm::merge() @ 0x1085a947 in /usr/bin/clickhouse\r\nBaseDaemon: 4. DB::MergeTreeDataWriter::mergeBlock(DB::Block const&, std::__1::vector<DB::SortColumnDescription, std:\r\nar> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > >&\r\n\r\nBaseDaemon: 5. DB::MergeTreeDataWriter::writeTempPart(DB::BlockWithPartition&, std::__1::shared_ptr<DB::StorageInMemo\r\n\r\nBaseDaemon: 6. DB::MergeTreeBlockOutputStream::write(DB::Block const&) @ 0x102fbcca in /usr/bin/clickhouse\r\nBaseDaemon: 7. DB::PushingToViewsBlockOutputStream::write(DB::Block const&) @ 0xfa627b2 in /usr/bin/clickhouse\r\nBaseDaemon: 8. DB::AddingDefaultBlockOutputStream::write(DB::Block const&) @ 0xfa6c46b in /usr/bin/clickhouse\r\nBaseDaemon: 9. DB::SquashingBlockOutputStream::finalize() @ 0xfa6caec in /usr/bin/clickhouse\r\nBaseDaemon: 10. DB::SquashingBlockOutputStream::writeSuffix() @ 0xfa6cb89 in /usr/bin/clickhouse\r\nBaseDaemon: 11. DB::TCPHandler::processInsertQuery(DB::Settings const&) @ 0x106470ef in /usr/bin/clickhouse\r\nBaseDaemon: 12. DB::TCPHandler::runImpl() @ 0x1063f989 in /usr/bin/clickhouse\r\nBaseDaemon: 13. DB::TCPHandler::run() @ 0x10652679 in /usr/bin/clickhouse\r\nBaseDaemon: 14. Poco::Net::TCPServerConnection::start() @ 0x132f6e2f in /usr/bin/clickhouse\r\nBaseDaemon: 15. Poco::Net::TCPServerDispatcher::run() @ 0x132f88ba in /usr/bin/clickhouse\r\nBaseDaemon: 16. Poco::PooledThread::run() @ 0x1342c3f9 in /usr/bin/clickhouse\r\nBaseDaemon: 17. Poco::ThreadImpl::runnableEntry(void*) @ 0x1342868a in /usr/bin/clickhouse\r\nBaseDaemon: 18. start_thread @ 0x7fa3 in /lib/x86_64-linux-gnu/libpthread-2.28.so\r\nBaseDaemon: 19. clone @ 0xf94cf in /lib/x86_64-linux-gnu/libc-2.28.so\r\nBaseDaemon: Checksum of the binary: 368AF822681E77D6553F41BA8FB4AD91, integrity check passed.\r\n\r\n```\n",
  "hints_text": "",
  "created_at": "2021-06-15T18:32:57Z",
  "modified_files": [
    "src/Processors/Merges/Algorithms/SummingSortedAlgorithm.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01532_execute_merges_on_single_replica.sql",
    "b/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.reference",
    "b/tests/queries/0_stateless/01913_summing_mt_and_simple_agg_function_with_lc.sql"
  ]
}