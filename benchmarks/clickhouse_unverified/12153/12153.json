{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12153,
  "instance_id": "ClickHouse__ClickHouse-12153",
  "issue_numbers": [
    "12106",
    "9088"
  ],
  "base_commit": "4f63af957de8c916417689b37f6ae19f6048c90e",
  "patch": "diff --git a/src/Functions/isZeroOrNull.cpp b/src/Functions/isZeroOrNull.cpp\nnew file mode 100644\nindex 000000000000..ee2b87e9bab7\n--- /dev/null\n+++ b/src/Functions/isZeroOrNull.cpp\n@@ -0,0 +1,118 @@\n+#include <Functions/IFunctionImpl.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/castTypeToEither.h>\n+#include <Functions/FunctionFactory.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <Core/ColumnNumbers.h>\n+#include <Columns/ColumnNullable.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+/// Returns 1 if argument is zero or NULL.\n+/// It can be used to negate filter in WHERE condition.\n+/// \"WHERE isZeroOrNull(expr)\" will return exactly the same rows that \"WHERE expr\" will filter out.\n+class FunctionIsZeroOrNull : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"isZeroOrNull\";\n+\n+    static FunctionPtr create(const Context &)\n+    {\n+        return std::make_shared<FunctionIsZeroOrNull>();\n+    }\n+\n+    std::string getName() const override\n+    {\n+        return name;\n+    }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatDontImplyNullableReturnType(size_t /*number_of_arguments*/) const override { return {0}; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & types) const override\n+    {\n+        if (!isNumber(removeNullable(types.at(0))))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The argument of function {} must have simple numeric type, possibly Nullable\", name);\n+\n+        return std::make_shared<DataTypeUInt8>();\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const ColumnPtr & input_column = block.getByPosition(arguments[0]).column;\n+\n+        if (const ColumnNullable * input_column_nullable = checkAndGetColumn<ColumnNullable>(input_column.get()))\n+        {\n+            const NullMap & null_map = input_column_nullable->getNullMapData();\n+            const IColumn * nested_column = &input_column_nullable->getNestedColumn();\n+\n+            if (!castTypeToEither<\n+                ColumnUInt8, ColumnUInt16, ColumnUInt32, ColumnUInt64,\n+                ColumnInt8, ColumnInt16, ColumnInt32, ColumnInt64,\n+                ColumnFloat32, ColumnFloat64>(\n+                nested_column, [&](const auto & column)\n+                {\n+                    auto res = ColumnUInt8::create(input_rows_count);\n+                    processNullable(column.getData(), null_map, res->getData(), input_rows_count);\n+                    block.getByPosition(result).column = std::move(res);\n+                    return true;\n+                }))\n+            {\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"The argument of function {} must have simple numeric type, possibly Nullable\", name);\n+            }\n+        }\n+        else\n+        {\n+            if (!castTypeToEither<\n+                ColumnUInt8, ColumnUInt16, ColumnUInt32, ColumnUInt64,\n+                ColumnInt8, ColumnInt16, ColumnInt32, ColumnInt64,\n+                ColumnFloat32, ColumnFloat64>(\n+                input_column.get(), [&](const auto & column)\n+                {\n+                    auto res = ColumnUInt8::create(input_rows_count);\n+                    processNotNullable(column.getData(), res->getData(), input_rows_count);\n+                    block.getByPosition(result).column = std::move(res);\n+                    return true;\n+                }))\n+            {\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"The argument of function {} must have simple numeric type, possibly Nullable\", name);\n+            }\n+        }\n+    }\n+\n+private:\n+    template <typename InputData>\n+    void processNotNullable(const InputData & input_data, ColumnUInt8::Container & result_data, size_t input_rows_count)\n+    {\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+            result_data[i] = !input_data[i];\n+    }\n+\n+    template <typename InputData>\n+    void processNullable(const InputData & input_data, const NullMap & input_null_map,\n+        ColumnUInt8::Container & result_data, size_t input_rows_count)\n+    {\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+            result_data[i] = input_null_map[i] || !input_data[i];\n+    }\n+};\n+\n+\n+void registerFunctionIsZeroOrNull(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionIsZeroOrNull>();\n+}\n+\n+}\n+\ndiff --git a/src/Functions/registerFunctionsNull.cpp b/src/Functions/registerFunctionsNull.cpp\nindex e8894e199077..238133fbb67f 100644\n--- a/src/Functions/registerFunctionsNull.cpp\n+++ b/src/Functions/registerFunctionsNull.cpp\n@@ -10,6 +10,7 @@ void registerFunctionIfNull(FunctionFactory & factory);\n void registerFunctionNullIf(FunctionFactory & factory);\n void registerFunctionAssumeNotNull(FunctionFactory & factory);\n void registerFunctionToNullable(FunctionFactory & factory);\n+void registerFunctionIsZeroOrNull(FunctionFactory & factory);\n \n \n void registerFunctionsNull(FunctionFactory & factory)\n@@ -21,6 +22,7 @@ void registerFunctionsNull(FunctionFactory & factory)\n     registerFunctionNullIf(factory);\n     registerFunctionAssumeNotNull(factory);\n     registerFunctionToNullable(factory);\n+    registerFunctionIsZeroOrNull(factory);\n }\n \n }\ndiff --git a/src/Functions/ya.make b/src/Functions/ya.make\nindex 86d2425eac43..c820916e2226 100644\n--- a/src/Functions/ya.make\n+++ b/src/Functions/ya.make\n@@ -241,6 +241,7 @@ SRCS(\n     isNotNull.cpp\n     isNull.cpp\n     isValidUTF8.cpp\n+    isZeroOrNull.cpp\n     jumpConsistentHash.cpp\n     lcm.cpp\n     least.cpp\ndiff --git a/src/Interpreters/MutationsInterpreter.cpp b/src/Interpreters/MutationsInterpreter.cpp\nindex dc5880bf1ca6..6ea656f0056b 100644\n--- a/src/Interpreters/MutationsInterpreter.cpp\n+++ b/src/Interpreters/MutationsInterpreter.cpp\n@@ -344,7 +344,7 @@ ASTPtr MutationsInterpreter::prepare(bool dry_run)\n             if (stages.empty() || !stages.back().column_to_updated.empty())\n                 stages.emplace_back(context);\n \n-            auto negated_predicate = makeASTFunction(\"not\", command.predicate->clone());\n+            auto negated_predicate = makeASTFunction(\"isZeroOrNull\", command.predicate->clone());\n             stages.back().filters.push_back(negated_predicate);\n         }\n         else if (command.type == MutationCommand::UPDATE)\ndiff --git a/src/Parsers/makeASTForLogicalFunction.cpp b/src/Parsers/makeASTForLogicalFunction.cpp\nindex eaae38740aa8..02c9da926c90 100644\n--- a/src/Parsers/makeASTForLogicalFunction.cpp\n+++ b/src/Parsers/makeASTForLogicalFunction.cpp\n@@ -7,21 +7,6 @@\n \n namespace DB\n {\n-ASTPtr makeASTForLogicalNot(ASTPtr argument)\n-{\n-    bool b;\n-    if (tryGetLiteralBool(argument.get(), b))\n-        return std::make_shared<ASTLiteral>(Field{UInt8(!b)});\n-\n-    auto function = std::make_shared<ASTFunction>();\n-    auto exp_list = std::make_shared<ASTExpressionList>();\n-    function->name = \"not\";\n-    function->arguments = exp_list;\n-    function->children.push_back(exp_list);\n-    exp_list->children.push_back(argument);\n-    return function;\n-}\n-\n \n ASTPtr makeASTForLogicalAnd(ASTs && arguments)\n {\n@@ -100,4 +85,5 @@ bool tryGetLiteralBool(const IAST * ast, bool & value)\n         return false;\n     }\n }\n+\n }\ndiff --git a/src/Parsers/makeASTForLogicalFunction.h b/src/Parsers/makeASTForLogicalFunction.h\nindex 5c1096cab6ee..8c3718bfcded 100644\n--- a/src/Parsers/makeASTForLogicalFunction.h\n+++ b/src/Parsers/makeASTForLogicalFunction.h\n@@ -5,9 +5,6 @@\n \n namespace DB\n {\n-/// Makes an AST calculating NOT argument.\n-ASTPtr makeASTForLogicalNot(ASTPtr argument);\n-\n /// Makes an AST calculating argument1 AND argument2 AND ... AND argumentN.\n ASTPtr makeASTForLogicalAnd(ASTs && arguments);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01358_mutation_delete_null_rows.reference b/tests/queries/0_stateless/01358_mutation_delete_null_rows.reference\nnew file mode 100644\nindex 000000000000..126874237b7e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01358_mutation_delete_null_rows.reference\n@@ -0,0 +1,20 @@\n+--------\n+0\t1\tx=0\n+1\t0\tx<>0\n+3\t0\tx<>0\n+\\N\t\\N\tx<>0\n+--------\n+2020-01-01\t\t2\t0\tleave\n+2020-01-02\taaa\t0\t1\tdelete\n+2020-01-03\t\t2\t0\tleave\n+2020-01-04\t\t2\t0\tleave\n+2020-01-05\t\\N\t2\t0\tleave\n+2020-01-06\taaa\t0\t1\tdelete\n+2020-01-07\taaa\t0\t1\tdelete\n+2020-01-08\taaa\t\\N\t\\N\tleave\n+--------\n+2020-01-01\t\t2\n+2020-01-03\t\t2\n+2020-01-04\t\t2\n+2020-01-05\t\\N\t2\n+2020-01-08\taaa\t\\N\ndiff --git a/tests/queries/0_stateless/01358_mutation_delete_null_rows.sql b/tests/queries/0_stateless/01358_mutation_delete_null_rows.sql\nnew file mode 100644\nindex 000000000000..e8aabf1aa375\n--- /dev/null\n+++ b/tests/queries/0_stateless/01358_mutation_delete_null_rows.sql\n@@ -0,0 +1,26 @@\n+select '--------';\n+SELECT arrayJoin([0, 1, 3, NULL]) AS x,  x = 0,  if(x = 0, 'x=0', 'x<>0') ORDER BY x;\n+\n+select '--------';\n+drop table if exists mutation_delete_null_rows;\n+\n+CREATE TABLE mutation_delete_null_rows\n+(\n+    `EventDate` Date,\n+    `CounterID` Nullable(String),\n+    `UserID` Nullable(UInt32)\n+)\n+ENGINE = MergeTree()\n+ORDER BY EventDate;\n+\n+INSERT INTO mutation_delete_null_rows VALUES ('2020-01-01', '', 2)('2020-01-02', 'aaa', 0);\n+INSERT INTO mutation_delete_null_rows VALUES ('2020-01-03', '', 2)('2020-01-04', '', 2)('2020-01-05', NULL, 2)('2020-01-06', 'aaa', 0)('2020-01-07', 'aaa', 0)('2020-01-08', 'aaa', NULL);\n+\n+SELECT *,UserID = 0 as UserIDEquals0, if(UserID = 0, 'delete', 'leave') as verdict FROM mutation_delete_null_rows ORDER BY EventDate;\n+\n+ALTER TABLE mutation_delete_null_rows DELETE WHERE UserID = 0 SETTINGS mutations_sync=1;\n+\n+select '--------';\n+SELECT * FROM mutation_delete_null_rows ORDER BY EventDate;\n+\n+drop table mutation_delete_null_rows;\ndiff --git a/tests/queries/0_stateless/01373_is_zero_or_null.reference b/tests/queries/0_stateless/01373_is_zero_or_null.reference\nnew file mode 100644\nindex 000000000000..d9caaa2089ad\n--- /dev/null\n+++ b/tests/queries/0_stateless/01373_is_zero_or_null.reference\n@@ -0,0 +1,22 @@\n+1\t1\n+1\t1\n+0\t0\n+\\N\t1\n+---\n+1\t1\n+1\t1\n+0\t0\n+---\n+hello\n+world\n+---\n+hello\n+world\n+---\n+hello\n+world\n+\\N\n+---\n+3\n+---\n+4\ndiff --git a/tests/queries/0_stateless/01373_is_zero_or_null.sql b/tests/queries/0_stateless/01373_is_zero_or_null.sql\nnew file mode 100644\nindex 000000000000..32458dc9f62f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01373_is_zero_or_null.sql\n@@ -0,0 +1,29 @@\n+SELECT NOT x, isZeroOrNull(x) FROM (SELECT arrayJoin([1, 2, 3, NULL]) = 3 AS x);\n+SELECT '---';\n+SELECT NOT x, isZeroOrNull(x) FROM (SELECT arrayJoin([1, 2, 3]) = 3 AS x);\n+SELECT '---';\n+CREATE TEMPORARY TABLE test (x String NULL);\n+INSERT INTO test VALUES ('hello'), ('world'), ('xyz'), (NULL);\n+\n+SELECT * FROM test WHERE x != 'xyz';\n+SELECT '---';\n+SELECT * FROM test WHERE NOT x = 'xyz';\n+SELECT '---';\n+SELECT * FROM test WHERE isZeroOrNull(x = 'xyz');\n+SELECT '---';\n+\n+SELECT count() FROM\n+(\n+    SELECT * FROM test WHERE x != 'xyz'\n+    UNION ALL\n+    SELECT * FROM test WHERE NOT x != 'xyz'\n+);\n+\n+SELECT '---';\n+\n+SELECT count() FROM\n+(\n+    SELECT * FROM test WHERE x != 'xyz'\n+    UNION ALL\n+    SELECT * FROM test WHERE isZeroOrNull(x != 'xyz')\n+);\ndiff --git a/tests/queries/0_stateless/01374_if_nullable_filimonov.reference b/tests/queries/0_stateless/01374_if_nullable_filimonov.reference\nnew file mode 100644\nindex 000000000000..ebe52278bb31\n--- /dev/null\n+++ b/tests/queries/0_stateless/01374_if_nullable_filimonov.reference\n@@ -0,0 +1,8 @@\n+2\t0\tleave\n+0\t1\tdelete\n+\\N\t\\N\tleave\n+---\n+0\t1\tDefinitely x = 0\n+1\t0\tWe cannot say that x = 0\n+3\t0\tWe cannot say that x = 0\n+\\N\t\\N\tWe cannot say that x = 0\ndiff --git a/tests/queries/0_stateless/01374_if_nullable_filimonov.sql b/tests/queries/0_stateless/01374_if_nullable_filimonov.sql\nnew file mode 100644\nindex 000000000000..0fadfb85fe4b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01374_if_nullable_filimonov.sql\n@@ -0,0 +1,9 @@\n+SELECT\n+    UserID,\n+    UserID = 0,\n+    if(UserID = 0, 'delete', 'leave')\n+FROM VALUES('UserID Nullable(UInt8)', (2), (0), (NULL));\n+\n+SELECT '---';\n+\n+SELECT arrayJoin([0, 1, 3, NULL]) AS x, x = 0, if(x = 0, 'Definitely x = 0', 'We cannot say that x = 0');\n",
  "problem_statement": "Test for issue #9088\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- Not for changelog (changelog entry is not required)\r\n\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nALTER DELETE unexpectedly deletes NULL rows\r\n\r\nDetailed description / Documentation draft:\r\nIt seems #11807 didn't fix it. \nALTER DELETE unexpectedly deletes NULL rows\nWhen I delete specific rows, CH also delete NULL rows too.\r\nIs it normal?\r\nHow can I control this?\r\n\r\n```sql\r\nSELECT *\r\nFROM test2\r\n\r\n\u250c\u2500\u2500EventDate\u2500\u252c\u2500CounterID\u2500\u252c\u2500UserID\u2500\u2510\r\n\u2502 2020-01-02 \u2502           \u2502      2 \u2502\r\n\u2502 2020-01-03 \u2502 aaa       \u2502      0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500EventDate\u2500\u252c\u2500CounterID\u2500\u252c\u2500UserID\u2500\u2510\r\n\u2502 2020-01-02 \u2502           \u2502      2 \u2502\r\n\u2502 2020-01-02 \u2502           \u2502      2 \u2502\r\n\u2502 2020-01-02 \u2502 \u1d3a\u1d41\u1d38\u1d38      \u2502      2 \u2502\r\n\u2502 2020-01-03 \u2502 aaa       \u2502      0 \u2502\r\n\u2502 2020-01-03 \u2502 aaa       \u2502      0 \u2502\r\n\u2502 2020-01-03 \u2502 aaa       \u2502   \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n8 rows in set. Elapsed: 0.002 sec. \r\n\r\n\r\nALTER TABLE test2\r\n    DELETE WHERE UserID = 0\r\n\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.085 sec. \r\n\r\n\r\nSELECT *\r\nFROM test2\r\n\r\n\u250c\u2500\u2500EventDate\u2500\u252c\u2500CounterID\u2500\u252c\u2500UserID\u2500\u2510\r\n\u2502 2020-01-02 \u2502           \u2502      2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500EventDate\u2500\u252c\u2500CounterID\u2500\u252c\u2500UserID\u2500\u2510\r\n\u2502 2020-01-02 \u2502           \u2502      2 \u2502\r\n\u2502 2020-01-02 \u2502           \u2502      2 \u2502\r\n\u2502 2020-01-02 \u2502 \u1d3a\u1d41\u1d38\u1d38      \u2502      2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n4 rows in set. Elapsed: 0.002 sec. \r\n```\n",
  "hints_text": "\nCould you attach your schema here too?\n```sql\r\nCREATE TABLE default.test2\r\n(\r\n    `EventDate` Date,\r\n    `CounterID` Nullable(String),\r\n    `UserID` Nullable(UInt32)\r\n)\r\nENGINE = MergeTree()\r\nORDER BY EventDate;\r\n\r\nINSERT INTO test2 VALUES ('2020-01-02', '', 2)('2020-01-03', 'aaa', 0);\r\nINSERT INTO test2 VALUES ('2020-01-02', '', 2)('2020-01-02', '', 2)('2020-01-02', NULL, 2)('2020-01-03', 'aaa', 0)('2020-01-03', 'aaa', 0)('2020-01-03', 'aaa', NULL);\r\n```\r\n\r\n\r\n\nCannot reproduce on master build. Could you update to the last release and reproduce it?\nreproduced 19.13.1.11, 19.13.6.51, 19.17.8.54 , 20.1.2,  20.2.1.2343,  20.2.1.2362 -- today nightbuilt\r\n\r\ncat t_del.sql\r\n```\r\ndrop table if exists default.test2;\r\n\r\nCREATE TABLE default.test2\r\n(\r\n    `EventDate` Date,\r\n    `CounterID` Nullable(String),\r\n    `UserID` Nullable(UInt32)\r\n)\r\nENGINE = MergeTree()\r\nORDER BY EventDate;\r\n\r\nINSERT INTO default.test2 VALUES ('2020-01-02', '', 2)('2020-01-03', 'aaa', 0);\r\nINSERT INTO default.test2 VALUES ('2020-01-02', '', 2)('2020-01-02', '', 2)('2020-01-02', NULL, 2)('2020-01-03', 'aaa', 0)('2020-01-03', 'aaa', 0)('2020-01-03', 'aaa', NULL);\r\n\r\n\r\nSELECT * FROM default.test2;\r\nALTER TABLE default.test2 DELETE WHERE UserID = 0;\r\nselect sleep(3) format Null;\r\nselect '--------';\r\nSELECT * FROM default.test2;\r\n```\r\n\r\ncat t_del.sql |clickhouse-client -mn\r\n```\r\n2020-01-02\t\t2\r\n2020-01-02\t\t2\r\n2020-01-02\t\\N\t2\r\n2020-01-03\taaa\t0\r\n2020-01-03\taaa\t0\r\n2020-01-03\taaa\t\\N\r\n2020-01-02\t\t2\r\n2020-01-03\taaa\t0\r\n--------\r\n2020-01-02\t\t2\r\n2020-01-02\t\t2\r\n2020-01-02\t\t2\r\n2020-01-02\t\\N\t2\r\n```\nReason:\r\n```\r\nSELECT \r\n    UserID, \r\n    UserID = 0, \r\n    if(UserID = 0, 'delete', 'leave')\r\nFROM default.test2\r\nFORMAT TSV\r\n\r\n2\t0\tleave\r\n0\t1\tdelete\r\n2\t0\tleave\r\n2\t0\tleave\r\n2\t0\tleave\r\n0\t1\tdelete\r\n0\t1\tdelete\r\n\\N\t\\N\tdelete\r\n```\nReproduces on 20.4.1 (master).\r\n\r\n```\r\nSELECT arrayJoin([0, 1, 3, NULL]) AS x,  x = 0,  if(x = 0, 'x=0', 'x<>0');\r\n```\r\n\r\nRelated https://github.com/ClickHouse/ClickHouse/pull/5238\r\n/cc @janplus",
  "created_at": "2020-07-06T02:51:10Z",
  "modified_files": [
    "b/src/Functions/isZeroOrNull.cpp",
    "src/Functions/registerFunctionsNull.cpp",
    "src/Functions/ya.make",
    "src/Interpreters/MutationsInterpreter.cpp",
    "src/Parsers/makeASTForLogicalFunction.cpp",
    "src/Parsers/makeASTForLogicalFunction.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01358_mutation_delete_null_rows.reference",
    "b/tests/queries/0_stateless/01358_mutation_delete_null_rows.sql",
    "b/tests/queries/0_stateless/01373_is_zero_or_null.reference",
    "b/tests/queries/0_stateless/01373_is_zero_or_null.sql",
    "b/tests/queries/0_stateless/01374_if_nullable_filimonov.reference",
    "b/tests/queries/0_stateless/01374_if_nullable_filimonov.sql"
  ]
}