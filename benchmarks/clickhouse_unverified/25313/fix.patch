diff --git a/src/AggregateFunctions/ReservoirSamplerDeterministic.h b/src/AggregateFunctions/ReservoirSamplerDeterministic.h
index 468a5c7c6a0a..2687e0b4a673 100644
--- a/src/AggregateFunctions/ReservoirSamplerDeterministic.h
+++ b/src/AggregateFunctions/ReservoirSamplerDeterministic.h
@@ -59,9 +59,10 @@ template <typename T,
     ReservoirSamplerDeterministicOnEmpty OnEmpty = ReservoirSamplerDeterministicOnEmpty::THROW>
 class ReservoirSamplerDeterministic
 {
-    bool good(const UInt32 hash)
+private:
+    bool good(UInt32 hash) const
     {
-        return !(hash & skip_mask);
+        return (hash & skip_mask) == 0;
     }
 
 public:
@@ -77,15 +78,12 @@ class ReservoirSamplerDeterministic
         total_values = 0;
     }
 
-    void insert(const T & v, const UInt64 determinator)
+    void insert(const T & v, UInt64 determinator)
     {
         if (isNaN(v))
             return;
 
-        const UInt32 hash = intHash64(determinator);
-        if (!good(hash))
-            return;
-
+        UInt32 hash = intHash64(determinator);
         insertImpl(v, hash);
         sorted = false;
         ++total_values;
@@ -144,8 +142,7 @@ class ReservoirSamplerDeterministic
             setSkipDegree(b.skip_degree);
 
         for (const auto & sample : b.samples)
-            if (good(sample.second))
-                insertImpl(sample.first, sample.second);
+            insertImpl(sample.first, sample.second);
 
         total_values += b.total_values;
     }
@@ -220,10 +217,19 @@ class ReservoirSamplerDeterministic
 
     void insertImpl(const T & v, const UInt32 hash)
     {
+        if (!good(hash))
+            return;
+
         /// Make a room for plus one element.
         while (samples.size() >= max_sample_size)
+        {
             setSkipDegree(skip_degree + 1);
 
+            /// Still good?
+            if (!good(hash))
+                return;
+        }
+
         samples.emplace_back(v, hash);
     }
 
