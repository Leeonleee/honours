diff --git a/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp b/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp
index f8d5e3d61aa9..851ea3518766 100644
--- a/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp
+++ b/src/Databases/MySQL/MaterializeMySQLSyncThread.cpp
@@ -246,7 +246,7 @@ static inline BlockOutputStreamPtr getTableOutput(const String & database_name,
         if (iterator != insert_columns_names.begin())
             insert_columns_str << ", ";
 
-        insert_columns_str << iterator->name;
+        insert_columns_str << backQuoteIfNeed(iterator->name);
     }
 
 
diff --git a/src/Parsers/Lexer.cpp b/src/Parsers/Lexer.cpp
index f8043c6865a8..baf547a0a1ab 100644
--- a/src/Parsers/Lexer.cpp
+++ b/src/Parsers/Lexer.cpp
@@ -146,13 +146,20 @@ Token Lexer::nextTokenImpl()
                 }
             }
 
-            /// word character cannot go just after number (SELECT 123FROM)
+            /// Try to parse it to a identifier(1identifier_name), otherwise it return ErrorWrongNumber
             if (pos < end && isWordCharASCII(*pos))
             {
                 ++pos;
                 while (pos < end && isWordCharASCII(*pos))
                     ++pos;
-                return Token(TokenType::ErrorWrongNumber, token_begin, pos);
+
+                for (const char * iterator = token_begin; iterator < pos; ++iterator)
+                {
+                    if (!isWordCharASCII(*iterator) && *iterator != '$')
+                        return Token(TokenType::ErrorWrongNumber, token_begin, pos);
+                }
+
+                return Token(TokenType::BareWord, token_begin, pos);
             }
 
             return Token(TokenType::Number, token_begin, pos);
@@ -313,10 +320,10 @@ Token Lexer::nextTokenImpl()
         }
 
         default:
-            if (isWordCharASCII(*pos))
+            if (isWordCharASCII(*pos) || *pos == '$')
             {
                 ++pos;
-                while (pos < end && isWordCharASCII(*pos))
+                while (pos < end && (isWordCharASCII(*pos) || *pos == '$'))
                     ++pos;
                 return Token(TokenType::BareWord, token_begin, pos);
             }
