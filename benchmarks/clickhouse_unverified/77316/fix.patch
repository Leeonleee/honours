diff --git a/src/Analyzer/IQueryTreeNode.h b/src/Analyzer/IQueryTreeNode.h
index 175879879257..f24cec87d999 100644
--- a/src/Analyzer/IQueryTreeNode.h
+++ b/src/Analyzer/IQueryTreeNode.h
@@ -71,6 +71,21 @@ using QueryTreeNodesDeque = std::deque<QueryTreeNodePtr>;
 using QueryTreeNodeWeakPtr = std::weak_ptr<IQueryTreeNode>;
 using QueryTreeWeakNodes = std::vector<QueryTreeNodeWeakPtr>;
 
+struct ConvertToASTOptions
+{
+    /// Add _CAST if constant literal type is different from column type
+    bool add_cast_for_constants = true;
+
+    /// Identifiers are fully qualified (`database.table.column`), otherwise names are just column names (`column`)
+    bool fully_qualified_identifiers = true;
+
+    /// Identifiers are qualified but database name is not added (`table.column`) if set to false.
+    bool qualify_indentifiers_with_database = true;
+
+    /// Set CTE name in ASTSubquery field.
+    bool set_subquery_cte_name = true;
+};
+
 class IQueryTreeNode : public TypePromotion<IQueryTreeNode>
 {
 public:
@@ -197,20 +212,8 @@ class IQueryTreeNode : public TypePromotion<IQueryTreeNode>
       */
     String formatOriginalASTForErrorMessage() const;
 
-    struct ConvertToASTOptions
-    {
-        /// Add _CAST if constant literal type is different from column type
-        bool add_cast_for_constants = true;
-
-        /// Identifiers are fully qualified (`database.table.column`), otherwise names are just column names (`column`)
-        bool fully_qualified_identifiers = true;
-
-        /// Identifiers are qualified but database name is not added (`table.column`) if set to false.
-        bool qualify_indentifiers_with_database = true;
-    };
-
     /// Convert query tree to AST
-    ASTPtr toAST(const ConvertToASTOptions & options = { .add_cast_for_constants = true, .fully_qualified_identifiers = true, .qualify_indentifiers_with_database = true }) const;
+    ASTPtr toAST(const ConvertToASTOptions & options = {}) const;
 
     /// Convert query tree to AST and then format it for error message.
     String formatConvertedASTForErrorMessage() const;
diff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp
index a5984e71140f..59bc60f73c0a 100644
--- a/src/Analyzer/QueryNode.cpp
+++ b/src/Analyzer/QueryNode.cpp
@@ -552,7 +552,8 @@ ASTPtr QueryNode::toASTImpl(const ConvertToASTOptions & options) const
     if (is_subquery)
     {
         auto subquery = std::make_shared<ASTSubquery>(std::move(result_select_query));
-        subquery->cte_name = cte_name;
+        if (options.set_subquery_cte_name)
+            subquery->cte_name = cte_name;
         return subquery;
     }
 
diff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp
index 7f8662f2608d..34a4b2b69749 100644
--- a/src/Analyzer/UnionNode.cpp
+++ b/src/Analyzer/UnionNode.cpp
@@ -232,7 +232,7 @@ ASTPtr UnionNode::toASTImpl(const ConvertToASTOptions & options) const
     select_with_union_query->list_of_selects = select_with_union_query->children.back();
 
     ASTPtr result_query = std::move(select_with_union_query);
-    bool set_subquery_cte_name = true;
+    bool set_subquery_cte_name = options.set_subquery_cte_name;
 
     if (recursive_cte_table)
     {
diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp
index d2626e08653e..9e419d4a5cf0 100644
--- a/src/Analyzer/Utils.cpp
+++ b/src/Analyzer/Utils.cpp
@@ -366,7 +366,10 @@ std::optional<bool> tryExtractConstantFromConditionNode(const QueryTreeNodePtr &
     return predicate_value > 0;
 }
 
-static ASTPtr convertIntoTableExpressionAST(const QueryTreeNodePtr & table_expression_node)
+static ASTPtr convertIntoTableExpressionAST(
+    const QueryTreeNodePtr & table_expression_node,
+    const ConvertToASTOptions & convert_to_ast_options
+)
 {
     ASTPtr table_expression_node_ast;
     auto node_type = table_expression_node->getNodeType();
@@ -389,7 +392,7 @@ static ASTPtr convertIntoTableExpressionAST(const QueryTreeNodePtr & table_expre
     }
     else
     {
-        table_expression_node_ast = table_expression_node->toAST();
+        table_expression_node_ast = table_expression_node->toAST(convert_to_ast_options);
     }
 
     auto result_table_expression = std::make_shared<ASTTableExpression>();
@@ -440,7 +443,11 @@ static ASTPtr convertIntoTableExpressionAST(const QueryTreeNodePtr & table_expre
     return result_table_expression;
 }
 
-void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_query_ast, const QueryTreeNodePtr & table_expression, const IQueryTreeNode::ConvertToASTOptions & convert_to_ast_options)
+void addTableExpressionOrJoinIntoTablesInSelectQuery(
+    ASTPtr & tables_in_select_query_ast,
+    const QueryTreeNodePtr & table_expression,
+    const ConvertToASTOptions & convert_to_ast_options
+)
 {
     auto table_expression_node_type = table_expression->getNodeType();
 
@@ -456,7 +463,7 @@ void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_q
             [[fallthrough]];
         case QueryTreeNodeType::TABLE_FUNCTION:
         {
-            auto table_expression_ast = convertIntoTableExpressionAST(table_expression);
+            auto table_expression_ast = convertIntoTableExpressionAST(table_expression, convert_to_ast_options);
 
             auto tables_in_select_query_element_ast = std::make_shared<ASTTablesInSelectQueryElement>();
             tables_in_select_query_element_ast->children.push_back(std::move(table_expression_ast));
diff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h
index e0063d51bd94..bd34c54bac01 100644
--- a/src/Analyzer/Utils.h
+++ b/src/Analyzer/Utils.h
@@ -92,7 +92,7 @@ std::optional<bool> tryExtractConstantFromConditionNode(const QueryTreeNodePtr &
 /** Add table expression in tables in select query children.
   * If table expression node is not of identifier node, table node, query node, table function node, join node or array join node type throws logical error exception.
   */
-void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_query_ast, const QueryTreeNodePtr & table_expression, const IQueryTreeNode::ConvertToASTOptions & convert_to_ast_options);
+void addTableExpressionOrJoinIntoTablesInSelectQuery(ASTPtr & tables_in_select_query_ast, const QueryTreeNodePtr & table_expression, const ConvertToASTOptions & convert_to_ast_options);
 
 /// Extract all TableNodes from the query tree.
 QueryTreeNodes extractAllTableReferences(const QueryTreeNodePtr & tree);
diff --git a/src/Planner/CollectSets.cpp b/src/Planner/CollectSets.cpp
index aaa33b7a86f5..ec3b88bdcfe1 100644
--- a/src/Planner/CollectSets.cpp
+++ b/src/Planner/CollectSets.cpp
@@ -105,7 +105,7 @@ class CollectSetsVisitor : public ConstInDepthQueryTreeVisitor<CollectSetsVisito
             if (in_second_argument->as<TableNode>())
                 subquery_to_execute = buildSubqueryToReadColumnsFromTableExpression(subquery_to_execute, planner_context.getQueryContext());
 
-            auto ast = in_second_argument->toAST();
+            auto ast = in_second_argument->toAST({ .set_subquery_cte_name = false });
             sets.addFromSubquery(set_key, std::move(ast), std::move(subquery_to_execute), settings);
         }
         else
diff --git a/src/Planner/Utils.cpp b/src/Planner/Utils.cpp
index c4ec9fecbd72..7b3c1ccd0c69 100644
--- a/src/Planner/Utils.cpp
+++ b/src/Planner/Utils.cpp
@@ -162,13 +162,16 @@ void addConvertingToCommonHeaderActionsIfNeeded(
     }
 }
 
-ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node)
+ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node, bool set_subquery_cte_name)
 {
     auto & query_node_typed = query_node->as<QueryNode &>();
 
     // In case of cross-replication we don't know what database is used for the table.
     // Each shard will use the default database (in the case of cross-replication shards may have different defaults).
-    auto result_ast = query_node_typed.toAST({ .qualify_indentifiers_with_database = false });
+    auto result_ast = query_node_typed.toAST({
+        .qualify_indentifiers_with_database = false,
+        .set_subquery_cte_name = set_subquery_cte_name
+    });
 
     while (true)
     {
@@ -188,31 +191,13 @@ ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node)
     return result_ast;
 }
 
-static void removeCTEs(ASTPtr & ast)
-{
-    std::stack<IAST *> stack;
-    stack.push(ast.get());
-    while (!stack.empty())
-    {
-        auto * node = stack.top();
-        stack.pop();
-
-        if (auto * subquery = typeid_cast<ASTSubquery *>(node))
-            subquery->cte_name = {};
-
-        for (const auto & child : node->children)
-            stack.push(child.get());
-    }
-}
-
 ASTPtr queryNodeToDistributedSelectQuery(const QueryTreeNodePtr & query_node)
 {
-    auto ast = queryNodeToSelectQuery(query_node);
     /// Remove CTEs information from distributed queries.
     /// Now, if cte_name is set for subquery node, AST -> String serialization will only print cte name.
     /// But CTE is defined only for top-level query part, so may not be sent.
     /// Removing cte_name forces subquery to be always printed.
-    removeCTEs(ast);
+    auto ast = queryNodeToSelectQuery(query_node, /*set_subquery_cte_name=*/false);
     return ast;
 }
 
diff --git a/src/Planner/Utils.h b/src/Planner/Utils.h
index bd7be4b1bd86..1aedcd417986 100644
--- a/src/Planner/Utils.h
+++ b/src/Planner/Utils.h
@@ -42,7 +42,7 @@ void addConvertingToCommonHeaderActionsIfNeeded(
     Blocks & query_plans_headers);
 
 /// Convert query node to ASTSelectQuery
-ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node);
+ASTPtr queryNodeToSelectQuery(const QueryTreeNodePtr & query_node, bool set_subquery_cte_name = true);
 
 /// Convert query node to ASTSelectQuery for distributed processing
 ASTPtr queryNodeToDistributedSelectQuery(const QueryTreeNodePtr & query_node);
