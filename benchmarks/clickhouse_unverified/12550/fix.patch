diff --git a/base/common/StringRef.h b/base/common/StringRef.h
index 2247f0de2ed5..410e13ba7d8c 100644
--- a/base/common/StringRef.h
+++ b/base/common/StringRef.h
@@ -21,21 +21,26 @@
 #endif
 
 
-/// The thing to avoid creating strings to find substrings in the hash table.
+/**
+ * The std::string_view-like container to avoid creating strings to find substrings in the hash table.
+ */
 struct StringRef
 {
     const char * data = nullptr;
     size_t size = 0;
 
+    /// Non-constexpr due to reinterpret_cast.
     template <typename CharT, typename = std::enable_if_t<sizeof(CharT) == 1>>
-    constexpr StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_)
+    StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_)
     {
         /// Sanity check for overflowed values.
         assert(size < 0x8000000000000000ULL);
     }
 
+    constexpr StringRef(const char * data_, size_t size_) : data(data_), size(size_) {}
+
     StringRef(const std::string & s) : data(s.data()), size(s.size()) {}
-    constexpr explicit StringRef(const std::string_view & s) : data(s.data()), size(s.size()) {}
+    constexpr explicit StringRef(std::string_view s) : data(s.data()), size(s.size()) {}
     constexpr StringRef(const char * data_) : StringRef(std::string_view{data_}) {}
     constexpr StringRef() = default;
 
@@ -45,6 +50,12 @@ struct StringRef
     constexpr explicit operator std::string_view() const { return {data, size}; }
 };
 
+/// Here constexpr doesn't implicate inline, see https://www.viva64.com/en/w/v1043/
+/// nullptr can't be used because the StringRef values are used in SipHash's pointer arithmetics
+/// and the UBSan thinks that something like nullptr + 8 is UB.
+constexpr const inline char empty_string_ref_addr{};
+constexpr const inline StringRef EMPTY_STRING_REF{&empty_string_ref_addr, 0};
+
 using StringRefs = std::vector<StringRef>;
 
 
diff --git a/src/Columns/ColumnLowCardinality.h b/src/Columns/ColumnLowCardinality.h
index ba077fcf1682..e3b879d6dd5b 100644
--- a/src/Columns/ColumnLowCardinality.h
+++ b/src/Columns/ColumnLowCardinality.h
@@ -15,6 +15,15 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
+/**
+ * How data is stored (in a nutshell):
+ * we have a dictionary @e reverse_index in ColumnUnique that holds pairs (DataType, UIntXX) and a column
+ * with UIntXX holding actual data indices.
+ * To obtain the value's index, call #getOrFindIndex.
+ * To operate on the data (so called indices column), call #getIndexes.
+ *
+ * @note The indices column always contains the default value (empty StringRef) with the first index.
+ */
 class ColumnLowCardinality final : public COWHelper<IColumn, ColumnLowCardinality>
 {
     friend class COWHelper<IColumn, ColumnLowCardinality>;
diff --git a/src/Columns/ColumnNullable.cpp b/src/Columns/ColumnNullable.cpp
index 1f378c5d41e4..888410202f0a 100644
--- a/src/Columns/ColumnNullable.cpp
+++ b/src/Columns/ColumnNullable.cpp
@@ -14,7 +14,6 @@ namespace DB
 
 namespace ErrorCodes
 {
-    extern const int NOT_IMPLEMENTED;
     extern const int LOGICAL_ERROR;
     extern const int ILLEGAL_COLUMN;
     extern const int SIZES_OF_NESTED_COLUMNS_ARE_INCONSISTENT;
@@ -105,11 +104,6 @@ void ColumnNullable::get(size_t n, Field & res) const
         getNestedColumn().get(n, res);
 }
 
-StringRef ColumnNullable::getDataAt(size_t /*n*/) const
-{
-    throw Exception{"Method getDataAt is not supported for " + getName(), ErrorCodes::NOT_IMPLEMENTED};
-}
-
 void ColumnNullable::insertData(const char * pos, size_t length)
 {
     if (pos == nullptr)
diff --git a/src/Columns/ColumnNullable.h b/src/Columns/ColumnNullable.h
index 4e72de6b1157..e4033e227370 100644
--- a/src/Columns/ColumnNullable.h
+++ b/src/Columns/ColumnNullable.h
@@ -51,9 +51,20 @@ class ColumnNullable final : public COWHelper<IColumn, ColumnNullable>
     bool isNullAt(size_t n) const override { return assert_cast<const ColumnUInt8 &>(*null_map).getData()[n] != 0;}
     Field operator[](size_t n) const override;
     void get(size_t n, Field & res) const override;
-    bool getBool(size_t n) const override { return isNullAt(n) ? 0 : nested_column->getBool(n); }
+    bool getBool(size_t n) const override { return isNullAt(n) ? false : nested_column->getBool(n); }
     UInt64 get64(size_t n) const override { return nested_column->get64(n); }
-    StringRef getDataAt(size_t n) const override;
+
+    /**
+     * If isNullAt(n) returns false, returns the nested column's getDataAt(n), otherwise returns a special value
+     * EMPTY_STRING_REF indicating that data is not present.
+     */
+    StringRef getDataAt(size_t n) const override
+    {
+        if (isNullAt(n))
+            return EMPTY_STRING_REF;
+
+        return getNestedColumn().getDataAt(n);
+    }
 
     /// Will insert null value if pos=nullptr
     void insertData(const char * pos, size_t length) override;
diff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h
index d2d93647538c..d0edf65edd85 100644
--- a/src/Columns/ColumnUnique.h
+++ b/src/Columns/ColumnUnique.h
@@ -16,6 +16,7 @@
 #include <ext/range.h>
 
 #include <common/unaligned.h>
+#include "Columns/ColumnConst.h"
 
 
 namespace DB
@@ -90,14 +91,13 @@ class ColumnUnique final : public COWHelper<IColumnUnique, ColumnUnique<ColumnTy
     void protect() override { column_holder->protect(); }
     size_t allocatedBytes() const override
     {
-        return column_holder->allocatedBytes()
-               + index.allocatedBytes()
-               + (nested_null_mask ? nested_null_mask->allocatedBytes() : 0);
+        return column_holder->allocatedBytes() + reverse_index.allocatedBytes()
+            + (nested_null_mask ? nested_null_mask->allocatedBytes() : 0);
     }
     void forEachSubcolumn(IColumn::ColumnCallback callback) override
     {
         callback(column_holder);
-        index.setColumn(getRawColumnPtr());
+        reverse_index.setColumn(getRawColumnPtr());
         if (is_nullable)
             nested_column_nullable = ColumnNullable::create(column_holder, nested_null_mask);
     }
@@ -109,16 +109,30 @@ class ColumnUnique final : public COWHelper<IColumnUnique, ColumnUnique<ColumnTy
         return false;
     }
 
-    const UInt64 * tryGetSavedHash() const override { return index.tryGetSavedHash(); }
+    const UInt64 * tryGetSavedHash() const override { return reverse_index.tryGetSavedHash(); }
 
     UInt128 getHash() const override { return hash.getHash(*getRawColumnPtr()); }
 
-private:
+    std::optional<UInt64> getOrFindValueIndex(StringRef value) const override
+    {
+        if (std::optional<UInt64> res = reverse_index.getIndex(value); res)
+            return res;
+
+        auto& nested = *getNestedColumn();
+
+        for (size_t i = 0; i < nested.size(); ++i)
+            if (nested.getDataAt(i) == value)
+                return i;
+
+        return {};
+    }
 
+private:
     IColumn::WrappedPtr column_holder;
     bool is_nullable;
     size_t size_of_value_if_fixed = 0;
-    ReverseIndex<UInt64, ColumnType> index;
+
+    ReverseIndex<UInt64, ColumnType> reverse_index;
 
     /// For DataTypeNullable, stores null map.
     IColumn::WrappedPtr nested_null_mask;
@@ -169,21 +183,20 @@ template <typename ColumnType>
 ColumnUnique<ColumnType>::ColumnUnique(const ColumnUnique & other)
     : column_holder(other.column_holder)
     , is_nullable(other.is_nullable)
-    , size_of_value_if_fixed (other.size_of_value_if_fixed)
-    , index(numSpecialValues(is_nullable), 0)
+    , size_of_value_if_fixed(other.size_of_value_if_fixed)
+    , reverse_index(numSpecialValues(is_nullable), 0)
 {
-    index.setColumn(getRawColumnPtr());
+    reverse_index.setColumn(getRawColumnPtr());
     createNullMask();
 }
 
 template <typename ColumnType>
 ColumnUnique<ColumnType>::ColumnUnique(const IDataType & type)
-    : is_nullable(type.isNullable())
-    , index(numSpecialValues(is_nullable), 0)
+    : is_nullable(type.isNullable()), reverse_index(numSpecialValues(is_nullable), 0)
 {
     const auto & holder_type = is_nullable ? *static_cast<const DataTypeNullable &>(type).getNestedType() : type;
     column_holder = holder_type.createColumn()->cloneResized(numSpecialValues());
-    index.setColumn(getRawColumnPtr());
+    reverse_index.setColumn(getRawColumnPtr());
     createNullMask();
 
     if (column_holder->valuesHaveFixedSize())
@@ -192,16 +205,14 @@ ColumnUnique<ColumnType>::ColumnUnique(const IDataType & type)
 
 template <typename ColumnType>
 ColumnUnique<ColumnType>::ColumnUnique(MutableColumnPtr && holder, bool is_nullable_)
-    : column_holder(std::move(holder))
-    , is_nullable(is_nullable_)
-    , index(numSpecialValues(is_nullable_), 0)
+    : column_holder(std::move(holder)), is_nullable(is_nullable_), reverse_index(numSpecialValues(is_nullable_), 0)
 {
     if (column_holder->size() < numSpecialValues())
         throw Exception("Too small holder column for ColumnUnique.", ErrorCodes::ILLEGAL_COLUMN);
     if (isColumnNullable(*column_holder))
         throw Exception("Holder column for ColumnUnique can't be nullable.", ErrorCodes::ILLEGAL_COLUMN);
 
-    index.setColumn(getRawColumnPtr());
+    reverse_index.setColumn(getRawColumnPtr());
     createNullMask();
 
     if (column_holder->valuesHaveFixedSize())
@@ -288,12 +299,10 @@ size_t ColumnUnique<ColumnType>::uniqueInsertFrom(const IColumn & src, size_t n)
 template <typename ColumnType>
 size_t ColumnUnique<ColumnType>::uniqueInsertData(const char * pos, size_t length)
 {
-    auto column = getRawColumnPtr();
+    if (auto index = getNestedTypeDefaultValueIndex(); getRawColumnPtr()->getDataAt(index) == StringRef(pos, length))
+        return index;
 
-    if (column->getDataAt(getNestedTypeDefaultValueIndex()) == StringRef(pos, length))
-        return getNestedTypeDefaultValueIndex();
-
-    auto insertion_point = index.insert(StringRef(pos, length));
+    auto insertion_point = reverse_index.insert({pos, length});
 
     updateNullMask();
 
@@ -320,6 +329,7 @@ StringRef ColumnUnique<ColumnType>::serializeValueIntoArena(size_t n, Arena & ar
         return StringRef(nested_ref.data - s, nested_ref.size + s);
     }
 
+
     return column_holder->serializeValueIntoArena(n, arena, begin);
 }
 
@@ -513,14 +523,14 @@ MutableColumnPtr ColumnUnique<ColumnType>::uniqueInsertRangeImpl(
 
             if (secondary_index && next_position >= max_dictionary_size)
             {
-                auto insertion_point = index.getInsertionPoint(ref);
-                if (insertion_point == index.lastInsertionPoint())
+                auto insertion_point = reverse_index.getInsertionPoint(ref);
+                if (insertion_point == reverse_index.lastInsertionPoint())
                     res = insert_key(ref, *secondary_index);
                 else
                     positions[num_added_rows] = insertion_point;
             }
             else
-                res = insert_key(ref, index);
+                res = insert_key(ref, reverse_index);
 
             if (res)
                 return res;
diff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h
index 818ac82cf0b5..d2c4846193ca 100644
--- a/src/Columns/ColumnVector.h
+++ b/src/Columns/ColumnVector.h
@@ -22,11 +22,11 @@ namespace ErrorCodes
   * Floating-point numbers are compared this way that NaNs always end up at the end
   *  (if you don't do this, the sort would not work at all).
   */
-template <typename T>
+template <class T, class U = T>
 struct CompareHelper
 {
-    static bool less(T a, T b, int /*nan_direction_hint*/) { return a < b; }
-    static bool greater(T a, T b, int /*nan_direction_hint*/) { return a > b; }
+    static constexpr bool less(T a, U b, int /*nan_direction_hint*/) { return a < b; }
+    static constexpr bool greater(T a, U b, int /*nan_direction_hint*/) { return a > b; }
 
     /** Compares two numbers. Returns a number less than zero, equal to zero, or greater than zero if a < b, a == b, a > b, respectively.
       * If one of the values is NaN, then
@@ -34,19 +34,19 @@ struct CompareHelper
       * - if nan_direction_hint == 1 - NaN are considered to be larger than all numbers;
       * Essentially: nan_direction_hint == -1 says that the comparison is for sorting in descending order.
       */
-    static int compare(T a, T b, int /*nan_direction_hint*/)
+    static constexpr int compare(T a, U b, int /*nan_direction_hint*/)
     {
         return a > b ? 1 : (a < b ? -1 : 0);
     }
 };
 
-template <typename T>
+template <class T>
 struct FloatCompareHelper
 {
-    static bool less(T a, T b, int nan_direction_hint)
+    static constexpr bool less(T a, T b, int nan_direction_hint)
     {
-        bool isnan_a = std::isnan(a);
-        bool isnan_b = std::isnan(b);
+        const bool isnan_a = std::isnan(a);
+        const bool isnan_b = std::isnan(b);
 
         if (isnan_a && isnan_b)
             return false;
@@ -58,10 +58,10 @@ struct FloatCompareHelper
         return a < b;
     }
 
-    static bool greater(T a, T b, int nan_direction_hint)
+    static constexpr bool greater(T a, T b, int nan_direction_hint)
     {
-        bool isnan_a = std::isnan(a);
-        bool isnan_b = std::isnan(b);
+        const bool isnan_a = std::isnan(a);
+        const bool isnan_b = std::isnan(b);
 
         if (isnan_a && isnan_b)
             return false;
@@ -73,10 +73,11 @@ struct FloatCompareHelper
         return a > b;
     }
 
-    static int compare(T a, T b, int nan_direction_hint)
+    static constexpr int compare(T a, T b, int nan_direction_hint)
     {
-        bool isnan_a = std::isnan(a);
-        bool isnan_b = std::isnan(b);
+        const bool isnan_a = std::isnan(a);
+        const bool isnan_b = std::isnan(b);
+
         if (unlikely(isnan_a || isnan_b))
         {
             if (isnan_a && isnan_b)
@@ -91,9 +92,8 @@ struct FloatCompareHelper
     }
 };
 
-template <> struct CompareHelper<Float32> : public FloatCompareHelper<Float32> {};
-template <> struct CompareHelper<Float64> : public FloatCompareHelper<Float64> {};
-
+template <class U> struct CompareHelper<Float32, U> : public FloatCompareHelper<Float32> {};
+template <class U> struct CompareHelper<Float64, U> : public FloatCompareHelper<Float64> {};
 
 /** A template for columns that use a simple array to store.
  */
@@ -201,6 +201,12 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>
         data.push_back(value);
     }
 
+    template <class U>
+    constexpr int compareAtOther(size_t n, size_t m, const ColumnVector<U> & rhs, int nan_direction_hint) const
+    {
+        return CompareHelper<T, U>::compare(data[n], rhs.data[m], nan_direction_hint);
+    }
+
     /// This method implemented in header because it could be possibly devirtualized.
     int compareAt(size_t n, size_t m, const IColumn & rhs_, int nan_direction_hint) const override
     {
diff --git a/src/Columns/IColumnUnique.h b/src/Columns/IColumnUnique.h
index e91000b0a61f..99facea60553 100644
--- a/src/Columns/IColumnUnique.h
+++ b/src/Columns/IColumnUnique.h
@@ -1,4 +1,5 @@
 #pragma once
+#include <optional>
 #include <Columns/IColumn.h>
 #include <Common/UInt128.h>
 
@@ -9,6 +10,7 @@ namespace ErrorCodes
     extern const int NOT_IMPLEMENTED;
 }
 
+/// Sort of a dictionary
 class IColumnUnique : public IColumn
 {
 public:
@@ -68,6 +70,24 @@ class IColumnUnique : public IColumn
     const char * getFamilyName() const override { return "ColumnUnique"; }
     TypeIndex getDataType() const override { return getNestedColumn()->getDataType(); }
 
+    /**
+     * Given some value (usually, of type @e ColumnType) @p value that is convertible to DB::StringRef, obtains its
+     * index in the DB::ColumnUnique::reverse_index hashtable.
+     *
+     * The reverse index (StringRef => UInt64) is built lazily, so there are two variants:
+     * - On the function call it's present. Therefore we obtain the index in O(1).
+     * - The reverse index is absent. We search for the index linearly.
+     *
+     * @see DB::ReverseIndex
+     * @see DB::ColumnUnique
+     *
+     * The most common example uses https://clickhouse.tech/docs/en/sql-reference/data-types/lowcardinality/ columns.
+     * Consider data type @e LC(String). The inner type here is @e String which is more or less a contigous memory
+     * region, so it can be easily represented as a @e StringRef. So we pass that ref to this function and get its
+     * index in the dictionary, which can be used to operate with the indices column.
+     */
+    virtual std::optional<UInt64> getOrFindValueIndex(StringRef value) const = 0;
+
     void insert(const Field &) override
     {
         throw Exception("Method insert is not supported for ColumnUnique.", ErrorCodes::NOT_IMPLEMENTED);
diff --git a/src/Columns/ReverseIndex.h b/src/Columns/ReverseIndex.h
index 0c897e4f397a..154293acf99a 100644
--- a/src/Columns/ReverseIndex.h
+++ b/src/Columns/ReverseIndex.h
@@ -325,7 +325,21 @@ class ReverseIndex
     static constexpr bool use_saved_hash = !is_numeric_column;
 
     UInt64 insert(const StringRef & data);
-    UInt64 getInsertionPoint(const StringRef & data);
+
+    /// Returns the found data's index in the dictionary. If index is not built, builds it.
+    UInt64 getInsertionPoint(StringRef data)
+    {
+        if (!index) buildIndex();
+        return getIndexImpl(data);
+    }
+
+    /// Returns the found data's index in the dictionary if the #index is built, otherwise, returns a std::nullopt.
+    std::optional<UInt64> getIndex(StringRef data) const
+    {
+        if (!index) return {};
+        return getIndexImpl(data);
+    }
+
     UInt64 lastInsertionPoint() const { return size() + base_index; }
 
     ColumnType * getColumn() const { return column; }
@@ -380,6 +394,8 @@ class ReverseIndex
     }
 
     ColumnUInt64::MutablePtr calcHashes() const;
+
+    UInt64 getIndexImpl(StringRef data) const;
 };
 
 
@@ -499,11 +515,8 @@ UInt64 ReverseIndex<IndexType, ColumnType>::insert(const StringRef & data)
 }
 
 template <typename IndexType, typename ColumnType>
-UInt64 ReverseIndex<IndexType, ColumnType>::getInsertionPoint(const StringRef & data)
+UInt64 ReverseIndex<IndexType, ColumnType>::getIndexImpl(StringRef data) const
 {
-    if (!index)
-        buildIndex();
-
     using IteratorType = typename IndexMapType::iterator;
     IteratorType iterator;
 
@@ -512,5 +525,4 @@ UInt64 ReverseIndex<IndexType, ColumnType>::getInsertionPoint(const StringRef &
 
     return iterator == index->end() ? size() + base_index : iterator->getValue();
 }
-
 }
diff --git a/src/Functions/array/arrayIndex.h b/src/Functions/array/arrayIndex.h
index e3c0cbcb92cb..b12372d28ce2 100644
--- a/src/Functions/array/arrayIndex.h
+++ b/src/Functions/array/arrayIndex.h
@@ -1,3 +1,5 @@
+#include <optional>
+#include <type_traits>
 #include <Functions/IFunctionImpl.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
@@ -12,6 +14,9 @@
 #include <Common/FieldVisitorsAccurateComparison.h>
 #include <Common/memcmpSmall.h>
 #include <Common/assert_cast.h>
+#include "Columns/ColumnLowCardinality.h"
+#include "DataTypes/DataTypeLowCardinality.h"
+#include "Interpreters/castColumn.h"
 
 
 namespace DB
@@ -23,179 +28,132 @@ namespace ErrorCodes
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
-/// For has.
-struct IndexToOne
+using NullMap = PaddedPODArray<UInt8>;
+
+/// ConcreteActions -- what to do when the index was found.
+
+struct HasAction
 {
     using ResultType = UInt8;
-    static bool apply(size_t, ResultType & current) { current = 1; return false; }
+    static constexpr const bool resume_execution = false;
+    static constexpr void apply(ResultType& current, size_t) noexcept { current = 1; }
 };
 
-/// For indexOf.
-struct IndexIdentity
+/// The index is returned starting from 1.
+struct IndexOfAction
 {
     using ResultType = UInt64;
-    /// The index is returned starting from 1.
-    static bool apply(size_t j, ResultType & current) { current = j + 1; return false; }
+    static constexpr const bool resume_execution = false;
+    static constexpr void apply(ResultType& current, size_t j) noexcept { current = j + 1; }
 };
 
-/// For countEqual.
-struct IndexCount
+struct CountEqualAction
 {
     using ResultType = UInt64;
-    static bool apply(size_t, ResultType & current) { ++current; return true; }
+    static constexpr const bool resume_execution = true;
+    static constexpr void apply(ResultType & current, size_t) noexcept { ++current; }
 };
 
-
-template <typename T, typename U, typename IndexConv>
-struct ArrayIndexNumImpl
+/// How to perform the search depending on the arguments data types.
+namespace Impl
+{
+template <
+    class ConcreteAction,
+    bool RightArgIsConstant = false,
+    class IntegralInitial = UInt64,
+    class IntegralResult = UInt64>
+struct Main
 {
 private:
+    using Initial = IntegralInitial;
+    using Result = IntegralResult;
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wsign-compare"
+    using ResultType = typename ConcreteAction::ResultType;
+    using ResultArr = PaddedPODArray<ResultType>;
 
-    /// compares `lhs` against `i`-th element of `rhs`
-    static bool compare(const T & lhs, const PaddedPODArray<U> & rhs, const size_t i) { return lhs == rhs[i]; }
-    /// compares `lhs against `rhs`, third argument unused
-    static bool compare(const T & lhs, const U & rhs, size_t) { return lhs == rhs; }
+    using ArrOffset = ColumnArray::Offset;
+    using ArrOffsets = ColumnArray::Offsets;
 
-#pragma GCC diagnostic pop
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wsign-compare"
 
-    static bool hasNull(const PaddedPODArray<UInt8> & null_map, size_t i)
+    static constexpr bool compare(const Initial & left, const PaddedPODArray<Result> & right, size_t, size_t i) noexcept
     {
-        return null_map[i];
+        return left == right[i];
     }
 
-    /// Both function arguments are ordinary.
-    template <typename ScalarOrVector>
-    static void vectorCase1(
-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,
-        const ScalarOrVector & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result)
+    static constexpr bool compare(const PaddedPODArray<Initial> & left, const Result & right, size_t i, size_t) noexcept
     {
-        size_t size = offsets.size();
-        result.resize(size);
-
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
-
-            for (size_t j = 0; j < array_size; ++j)
-            {
-                if (compare(data[current_offset + j], value, i))
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+        return left[i] == right;
+    }
 
-            result[i] = current;
-            current_offset = offsets[i];
-        }
+    static constexpr bool compare(
+            const PaddedPODArray<Initial> & left, const PaddedPODArray<Result> & right, size_t i, size_t j) noexcept
+    {
+        return left[i] == right[j];
     }
 
-    /// The 2nd function argument is nullable.
-    template <typename ScalarOrVector>
-    static void vectorCase2(
-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,
-        const ScalarOrVector & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> & null_map_item)
+    /// LowCardinality
+    static bool compare(const IColumn & left, const Result& right, size_t i, size_t)
     {
-        size_t size = offsets.size();
-        result.resize(size);
+        return left.getUInt(i) == right;
+    }
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+    /// Generic
+    static bool compare(const IColumn& left, const IColumn& right, size_t i, size_t j)
+    {
+        return 0 == left.compareAt(i, RightArgIsConstant ? 0 : j, right, 1);
+    }
 
-            for (size_t j = 0; j < array_size; ++j)
-            {
-                if (!hasNull(null_map_item, i) && compare(data[current_offset + j], value, i))
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+#pragma GCC diagnostic pop
 
-            result[i] = current;
-            current_offset = offsets[i];
-        }
-    }
+    static constexpr bool hasNull(const NullMap * const null_map, size_t i) noexcept { return (*null_map)[i]; }
 
-    /// The 1st function argument is a non-constant array of nullable values.
-    template <typename ScalarOrVector>
-    static void vectorCase3(
-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,
-        const ScalarOrVector & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> & null_map_data)
+    template <size_t Case, class Data, class Target>
+    static void process(
+        const Data & data, const ArrOffsets & offsets, const Target & target, ResultArr & result,
+        [[maybe_unused]] const NullMap * const null_map_data,
+        [[maybe_unused]] const NullMap * const null_map_item)
     {
-        size_t size = offsets.size();
+        const size_t size = offsets.size();
+
         result.resize(size);
 
-        ColumnArray::Offset current_offset = 0;
+        ArrOffset current_offset = 0;
+
         for (size_t i = 0; i < size; ++i)
         {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+            const size_t array_size = offsets[i] - current_offset;
+            ResultType current = 0;
 
             for (size_t j = 0; j < array_size; ++j)
             {
-                if (null_map_data[current_offset + j])
-                {
-                }
-                else if (compare(data[current_offset + j], value, i))
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+                if constexpr (Case == 2) /// Right arg is Nullable
+                     if (hasNull(null_map_item, i))
+                        continue;
 
-            result[i] = current;
-            current_offset = offsets[i];
-        }
-    }
+                if constexpr (Case == 3) /// Left arg is an array of Nullables
+                    if (hasNull(null_map_data, current_offset + j))
+                        continue;
 
-    /// The 1st function argument is a non-constant array of nullable values.
-    /// The 2nd function argument is nullable.
-    template <typename ScalarOrVector>
-    static void vectorCase4(
-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,
-        const ScalarOrVector & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> & null_map_data,
-        const PaddedPODArray<UInt8> & null_map_item)
-    {
-        size_t size = offsets.size();
-        result.resize(size);
+                if constexpr (Case == 4) /// Both args are nullable
+                {
+                    const bool right_is_null = hasNull(null_map_data, current_offset + j);
+                    const bool left_is_null = hasNull(null_map_item, i);
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+                    if (right_is_null != left_is_null)
+                        continue;
 
-            for (size_t j = 0; j < array_size; ++j)
-            {
-                bool hit = false;
-                if (null_map_data[current_offset + j])
-                {
-                    if (hasNull(null_map_item, i))
-                        hit = true;
+                    if (!right_is_null && !compare(data, target, current_offset + j, i))
+                        continue;
                 }
-                else if (compare(data[current_offset + j], value, i))
-                    hit = true;
+                else if (!compare(data, target, current_offset + j, i))
+                        continue;
 
-                if (hit)
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
+                ConcreteAction::apply(current, j);
+
+                if constexpr (!ConcreteAction::resume_execution)
+                    break;
             }
 
             result[i] = current;
@@ -204,86 +162,63 @@ struct ArrayIndexNumImpl
     }
 
 public:
-    template <typename ScalarOrVector>
+    template <class Data, class Target>
     static void vector(
-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,
-        const ScalarOrVector & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data,
-        const PaddedPODArray<UInt8> * null_map_item)
+        const Data & data,
+        const ArrOffsets & offsets,
+        const Target & value,
+        ResultArr & result,
+        const NullMap * const null_map_data,
+        const NullMap * const null_map_item)
     {
-        /// Processing is split into 4 cases.
         if (!null_map_data && !null_map_item)
-            vectorCase1(data, offsets, value, result);
+            process<1>(data, offsets, value, result, null_map_data, null_map_item);
         else if (!null_map_data && null_map_item)
-            vectorCase2(data, offsets, value, result, *null_map_item);
+            process<2>(data, offsets, value, result, null_map_data, null_map_item);
         else if (null_map_data && !null_map_item)
-            vectorCase3(data, offsets, value, result, *null_map_data);
+            process<3>(data, offsets, value, result, null_map_data, null_map_item);
         else
-            vectorCase4(data, offsets, value, result, *null_map_data, *null_map_item);
+            process<4>(data, offsets, value, result, null_map_data, null_map_item);
     }
 };
 
-
-/// Implementation for arrays of numbers when the 2nd function argument
-/// is a NULL value.
-template <typename T, typename IndexConv>
-struct ArrayIndexNumNullImpl
+/// When the 2nd function argument is a NULL value.
+template <class ConcreteAction>
+struct Null
 {
-    static void vector(
-        const PaddedPODArray<T> & /*data*/, const ColumnArray::Offsets & offsets,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data)
+    using ResultType = typename ConcreteAction::ResultType;
+
+    static void process(
+        const ColumnArray::Offsets & offsets,
+        PaddedPODArray<ResultType> & result,
+        [[maybe_unused]] const NullMap * null_map_data)
     {
-        size_t size = offsets.size();
-        result.resize(size);
+        const size_t size = offsets.size();
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        if (!null_map_data)
         {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
-
-            for (size_t j = 0; j < array_size; ++j)
-            {
-                if (null_map_data && (*null_map_data)[current_offset + j])
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
-
-            result[i] = current;
-            current_offset = offsets[i];
+            result.resize_fill(size);
+            return;
         }
-    }
-};
 
-/// Implementation for arrays of strings when the 2nd function argument is a NULL value.
-template <typename IndexConv>
-struct ArrayIndexStringNullImpl
-{
-    static void vector_const(
-        const ColumnString::Chars & /*data*/, const ColumnArray::Offsets & offsets, const ColumnString::Offsets & /*string_offsets*/,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data)
-    {
-        const auto size = offsets.size();
         result.resize(size);
 
         ColumnArray::Offset current_offset = 0;
+
         for (size_t i = 0; i < size; ++i)
         {
-            const auto array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+            ResultType current = 0;
+            const size_t array_size = offsets[i] - current_offset;
 
             for (size_t j = 0; j < array_size; ++j)
             {
-                if (null_map_data && (*null_map_data)[current_offset + j])
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
+                if (!(*null_map_data)[current_offset + j])
+                    continue;
+
+                ConcreteAction::apply(current, j);
+
+                if constexpr (!ConcreteAction::resume_execution)
+                    break;
             }
 
             result[i] = current;
@@ -292,40 +227,84 @@ struct ArrayIndexStringNullImpl
     }
 };
 
-template <typename IndexConv>
-struct ArrayIndexStringImpl
+template <class ConcreteAction>
+struct String
 {
-    static void vector_const(
-        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets, const ColumnString::Offsets & string_offsets,
-        const ColumnString::Chars & value, ColumnString::Offset value_size,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data)
+private:
+    using Offset = ColumnString::Offset;
+    template <bool IsConst> using OffsetT = std::conditional_t<IsConst, Offset, const ColumnString::Offsets &>;
+    using ArrayOffset = ColumnArray::Offset;
+    using ResultType = typename ConcreteAction::ResultType;
+
+    template <bool IsConst, bool HasNullMapData, bool HasNullMapItem>
+    static void processImpl(
+        const ColumnString::Chars & data,
+        const ColumnArray::Offsets & offsets,
+        const ColumnString::Offsets & string_offsets,
+        const ColumnString::Chars & item_values,
+        OffsetT<IsConst> item_offsets,
+        PaddedPODArray<ResultType> & result,
+        [[maybe_unused]] const NullMap * data_map,
+        [[maybe_unused]] const NullMap * item_map)
     {
-        const auto size = offsets.size();
+        const size_t size = offsets.size();
+
         result.resize(size);
 
-        ColumnArray::Offset current_offset = 0;
+        ArrayOffset current_offset = 0;
+
         for (size_t i = 0; i < size; ++i)
         {
-            const auto array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+            const ArrayOffset array_size = offsets[i] - current_offset;
+
+            [[maybe_unused]] Offset value_pos = 0;
+            [[maybe_unused]] Offset value_size = 0;
+
+            if constexpr (!IsConst) // workaround because ?: ternary operator is not constexpr
+            {
+                if (0 != i) value_pos = item_offsets[i - 1];
+                value_size = item_offsets[i] - value_pos;
+            }
+
+            ResultType current = 0;
 
             for (size_t j = 0; j < array_size; ++j)
             {
-                ColumnArray::Offset string_pos = current_offset == 0 && j == 0
+                const ArrayOffset string_pos = current_offset + j == 0
                     ? 0
                     : string_offsets[current_offset + j - 1];
 
-                ColumnArray::Offset string_size = string_offsets[current_offset + j] - string_pos - 1;
+                const ArrayOffset string_size = string_offsets[current_offset + j] - string_pos - IsConst * 1;
 
-                if (null_map_data && (*null_map_data)[current_offset + j])
+                if constexpr (IsConst)
                 {
+                    if constexpr (HasNullMapData)
+                        if ((*data_map)[current_offset + j])
+                            continue;
+
+                    if (!memequalSmallAllowOverflow15(item_values.data(), item_offsets, &data[string_pos], string_size))
+                        continue;
                 }
-                else if (memequalSmallAllowOverflow15(value.data(), value_size, &data[string_pos], string_size))
+                else if constexpr (HasNullMapData)
                 {
-                    if (!IndexConv::apply(j, current))
-                        break;
+                    if ((*data_map)[current_offset + j])
+                    {
+                        if constexpr (!HasNullMapItem)
+                            continue;
+
+                        if (!(*item_map)[i])
+                            continue;
+                    }
+                    else if (!memequalSmallAllowOverflow15(&item_values[value_pos], value_size, &data[string_pos], string_size))
+                        continue;
                 }
+                else if (!memequalSmallAllowOverflow15(&item_values[value_pos], value_size, &data[string_pos], string_size))
+                    continue;
+
+                ConcreteAction::apply(current, j);
+
+                if constexpr (!ConcreteAction::resume_execution)
+                    break;
             }
 
             result[i] = current;
@@ -333,439 +312,690 @@ struct ArrayIndexStringImpl
         }
     }
 
-    static void vectorVector(
-        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets, const ColumnString::Offsets & string_offsets,
-        const ColumnString::Chars & item_values, const ColumnString::Offsets & item_offsets,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data,
-        const PaddedPODArray<UInt8> * null_map_item)
+    template <bool IsConst>
+    static inline void invokeCheckNullMaps(
+        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets,
+        const ColumnString::Offsets & str_offsets, const ColumnString::Chars & values,
+        OffsetT<IsConst> item_offsets,
+        PaddedPODArray<ResultType> & result, const NullMap * data_map, const NullMap * item_map)
     {
-        const auto size = offsets.size();
-        result.resize(size);
+        if (data_map && item_map)
+            processImpl<IsConst, true, true>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);
+        else if (data_map)
+            processImpl<IsConst, true, false>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);
+        else if (item_map)
+            processImpl<IsConst, false, true>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);
+        else
+            processImpl<IsConst, false, false>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);
+    }
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            const auto array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
-            const auto value_pos = 0 == i ? 0 : item_offsets[i - 1];
-            const auto value_size = item_offsets[i] - value_pos;
+public:
+    static inline void process(
+        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets,
+        const ColumnString::Offsets & string_offsets, const ColumnString::Chars & item_values,
+        Offset item_offsets, PaddedPODArray<ResultType> & result,
+        const NullMap * data_map, const NullMap * item_map)
+    {
+        invokeCheckNullMaps<true>(data, offsets, string_offsets, item_values, item_offsets, result, data_map, item_map);
+    }
 
-            for (size_t j = 0; j < array_size; ++j)
-            {
-                ColumnArray::Offset string_pos = current_offset == 0 && j == 0
-                    ? 0
-                    : string_offsets[current_offset + j - 1];
+    static inline void process(
+        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets,
+        const ColumnString::Offsets & string_offsets, const ColumnString::Chars & item_values,
+        const ColumnString::Offsets & item_offsets, PaddedPODArray<ResultType> & result,
+        const NullMap * data_map, const NullMap * item_map)
+    {
+        invokeCheckNullMaps<false>(data, offsets, string_offsets, item_values, item_offsets, result, data_map, item_map);
+    }
+};
+}
 
-                ColumnArray::Offset string_size = string_offsets[current_offset + j] - string_pos;
+template <class ConcreteAction, class Name>
+class FunctionArrayIndex : public IFunction
+{
+public:
+    static constexpr auto name = Name::name;
+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionArrayIndex>(); }
 
-                bool hit = false;
+    /// Get function name.
+    String getName() const override { return name; }
 
-                if (null_map_data && (*null_map_data)[current_offset + j])
-                {
-                    if (null_map_item && (*null_map_item)[i])
-                        hit = true;
-                }
-                else if (memequalSmallAllowOverflow15(&item_values[value_pos], value_size, &data[string_pos], string_size))
-                    hit = true;
+    bool useDefaultImplementationForNulls() const override { return false; }
+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }
 
-                if (hit)
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+    size_t getNumberOfArguments() const override { return 2; }
 
-            result[i] = current;
-            current_offset = offsets[i];
-        }
+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    {
+        const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[0].get());
+
+        if (!array_type)
+            throw Exception("First argument for function " + getName() + " must be an array.",
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+        if (!arguments[1]->onlyNull() && !allowArguments(array_type->getNestedType(), arguments[1]))
+            throw Exception("Types of array and 2nd argument of function \""
+                + getName() + "\" must be identical up to nullability, cardinality, "
+                "numeric types, or Enum and numeric type. Passed: "
+                + arguments[0]->getName() + " and " + arguments[1]->getName() + ".",
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+        return std::make_shared<DataTypeNumber<ResultType>>();
     }
-};
 
-/// Catch-all implementation for arrays of arbitrary type.
-/// To compare with constant value, create non-constant column with single element,
-/// and pass is_value_has_single_element_to_compare = true.
-template <typename IndexConv, bool is_value_has_single_element_to_compare>
-struct ArrayIndexGenericImpl
-{
-private:
-    /// Both function arguments are ordinary.
-    static void vectorCase1(
-        const IColumn & data, const ColumnArray::Offsets & offsets,
-        const IColumn & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result)
+    /**
+      * If one or both arguments passed to this function are nullable,
+      * we create a new block that contains non-nullable arguments:
+      *
+      * - if the 1st argument is a non-constant array of nullable values,
+      * it is turned into a non-constant array of ordinary values + a null
+      * byte map;
+      * - if the 2nd argument is a nullable value, it is turned into an
+      * ordinary value + a null byte map.
+      *
+      * Note that since constant arrays have quite a specific structure
+      * (they are vectors of Fields, which may represent the NULL value),
+      * they do not require any preprocessing.
+      */
+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) const override
     {
-        size_t size = offsets.size();
-        result.resize(size);
+        ColumnPtr& ptr = block.getByPosition(arguments[0]).column;
+
+        /**
+         * The columns here have two general cases, either being Array(T) or Const(Array(T)).
+         * The last type will return nullptr after casting to ColumnArray, so we leave the casting
+         * to execute* functions.
+         */
+        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(ptr.get());
+        const ColumnNullable * nullable = nullptr;
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        if (col_array)
+            nullable = checkAndGetColumn<ColumnNullable>(col_array->getData());
+
+        auto & arg_column = block.getByPosition(arguments[1]).column;
+        const ColumnNullable * arg_nullable = checkAndGetColumn<ColumnNullable>(*arg_column);
+
+        if (!nullable && !arg_nullable)
+            executeOnNonNullable(block, arguments, result);
+        else
         {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+            /**
+             * To correctly process the Nullable values (either #col_array, #arg_column or both) we create a new block
+             * and operate on it. The block structure follows:
+             * {0, 1, 2, 3, 4}
+             * {data (array) argument, "value" argument, data null map, "value" null map, function result}.
+             */
+            Block source_block = { {}, {}, {}, {}, {nullptr, block.getByPosition(result).type, ""} };
 
-            for (size_t j = 0; j < array_size; ++j)
+            if (nullable)
             {
-                if (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1))
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+                const auto & nested_col = nullable->getNestedColumnPtr();
 
-            result[i] = current;
-            current_offset = offsets[i];
-        }
-    }
+                auto & data = source_block.getByPosition(0);
 
-    /// The 2nd function argument is nullable.
-    static void vectorCase2(
-        const IColumn & data, const ColumnArray::Offsets & offsets,
-        const IColumn & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> & null_map_item)
-    {
-        size_t size = offsets.size();
-        result.resize(size);
+                data.column = ColumnArray::create(nested_col, col_array->getOffsetsPtr());
+                data.type = std::make_shared<DataTypeArray>(
+                    static_cast<const DataTypeNullable &>(
+                        *static_cast<const DataTypeArray &>(
+                            *block.getByPosition(arguments[0]).type
+                        ).getNestedType()
+                    ).getNestedType());
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+                auto & null_map = source_block.getByPosition(2);
 
-            for (size_t j = 0; j < array_size; ++j)
+                null_map.column = nullable->getNullMapColumnPtr();
+                null_map.type = std::make_shared<DataTypeUInt8>();
+            }
+            else
             {
-                if ((null_map_item[i] == 0) &&
-                    (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1)))
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
+                auto & data = source_block.getByPosition(0);
+                data = block.getByPosition(arguments[0]);
             }
 
-            result[i] = current;
-            current_offset = offsets[i];
+            if (arg_nullable)
+            {
+                auto & arg = source_block.getByPosition(1);
+                arg.column = arg_nullable->getNestedColumnPtr();
+                arg.type =
+                    static_cast<const DataTypeNullable &>(
+                        *block.getByPosition(arguments[1]).type
+                    ).getNestedType();
+
+                auto & null_map = source_block.getByPosition(3);
+                null_map.column = arg_nullable->getNullMapColumnPtr();
+                null_map.type = std::make_shared<DataTypeUInt8>();
+            }
+            else
+            {
+                auto & arg = source_block.getByPosition(1);
+                arg = block.getByPosition(arguments[1]);
+            }
+
+            /// Now perform the function.
+            executeOnNonNullable(source_block, {0, 1, 2, 3}, 4);
+
+            /// Move the result to its final position.
+            const ColumnWithTypeAndName & source_col = source_block.getByPosition(4);
+            ColumnWithTypeAndName & dest_col = block.getByPosition(result);
+            dest_col.column = std::move(source_col.column);
         }
     }
 
-    /// The 1st function argument is a non-constant array of nullable values.
-    static void vectorCase3(
-        const IColumn & data, const ColumnArray::Offsets & offsets,
-        const IColumn & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> & null_map_data)
+private:
+    using ResultType = typename ConcreteAction::ResultType;
+    using ResultColumnType = ColumnVector<ResultType>;
+    using ResultColumnPtr = decltype(ResultColumnType::create());
+
+    using NullMaps = std::pair<const NullMap *, const NullMap *>;
+
+    struct ExecutionData
     {
-        size_t size = offsets.size();
-        result.resize(size);
+        const IColumn& left;
+        const IColumn& right;
+        const ColumnArray::Offsets& offsets;
+        Block & block;
+        size_t result_pos;
+        NullMaps maps;
+        ResultColumnPtr result { ResultColumnType::create() };
+
+        inline void move_result() { block.getByPosition(result_pos).column = std::move(result); }
+    };
+
+    static inline bool allowNested(const DataTypePtr & left, const DataTypePtr & right)
+    {
+        return ((isNativeNumber(left) || isEnum(left)) && isNativeNumber(right)) || left->equals(*right);
+    }
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
-        {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+    static inline bool allowArguments(const DataTypePtr & array_inner_type, const DataTypePtr & arg)
+    {
+        if (allowNested(array_inner_type, arg))
+            return true;
 
-            for (size_t j = 0; j < array_size; ++j)
-            {
-                if (null_map_data[current_offset + j])
-                {
-                }
-                else if (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1))
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+        /// Nullable
 
-            result[i] = current;
-            current_offset = offsets[i];
+        const bool array_is_nullable = array_inner_type->isNullable();
+        const bool arg_is_nullable = arg->isNullable();
+
+        const DataTypePtr arg_or_arg_nullable_nested = arg_is_nullable
+            ? checkAndGetDataType<DataTypeNullable>(arg.get())->getNestedType()
+            : arg;
+
+        if (array_is_nullable) // comparing Array(Nullable(T)) elem and U
+        {
+            const DataTypePtr array_nullable_nested =
+                checkAndGetDataType<DataTypeNullable>(array_inner_type.get())->getNestedType();
+
+            return allowNested(
+                    array_nullable_nested,
+                    arg_or_arg_nullable_nested);
         }
-    }
+        else if (arg_is_nullable) // cannot compare Array(T) elem (namely, T) and Nullable(T)
+            return false;
 
-    /// The 1st function argument is a non-constant array of nullable values.
-    /// The 2nd function argument is nullable.
-    static void vectorCase4(
-        const IColumn & data, const ColumnArray::Offsets & offsets,
-        const IColumn & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> & null_map_data,
-        const PaddedPODArray<UInt8> & null_map_item)
-    {
-        size_t size = offsets.size();
-        result.resize(size);
+        /// LowCardinality
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+        const auto * const array_lc_ptr = checkAndGetDataType<DataTypeLowCardinality>(array_inner_type.get());
+        const auto * const arg_lc_ptr = checkAndGetDataType<DataTypeLowCardinality>(arg.get());
+
+        const DataTypePtr array_lc_inner_type = recursiveRemoveLowCardinality(array_inner_type);
+        const DataTypePtr arg_lc_inner_type = recursiveRemoveLowCardinality(arg);
+
+        const bool array_is_lc = nullptr != array_lc_ptr;
+        const bool arg_is_lc = nullptr != arg_lc_ptr;
+
+        const bool array_lc_inner_type_is_nullable = array_is_lc && array_lc_inner_type->isNullable();
+        const bool arg_lc_inner_type_is_nullable = arg_is_lc && arg_lc_inner_type->isNullable();
+
+        if (array_is_lc) // comparing LC(T) and U
         {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
+            const DataTypePtr array_lc_nested_or_lc_nullable_nested = array_lc_inner_type_is_nullable
+                ? checkAndGetDataType<DataTypeNullable>(array_lc_inner_type.get())->getNestedType()
+                : array_lc_inner_type;
 
-            for (size_t j = 0; j < array_size; ++j)
+            if (arg_is_lc) // comparing LC(T) and LC(U)
             {
-                bool hit = false;
-                if (null_map_data[current_offset + j])
-                {
-                    if (null_map_item[i])
-                        hit = true;
-                }
-                else if (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1))
-                        hit = true;
+                const DataTypePtr arg_lc_nested_or_lc_nullable_nested = arg_lc_inner_type_is_nullable
+                    ? checkAndGetDataType<DataTypeNullable>(arg_lc_inner_type.get())->getNestedType()
+                    : arg_lc_inner_type;
 
-                if (hit)
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
+                return allowNested(
+                        array_lc_nested_or_lc_nullable_nested,
+                        arg_lc_nested_or_lc_nullable_nested);
+            }
+            else if (arg_is_nullable) // Comparing LC(T) and Nullable(U)
+            {
+                if (!array_lc_inner_type_is_nullable)
+                    return false; // Can't compare Array(LC(U)) elem and Nullable(T);
+
+                return allowNested(
+                        array_lc_nested_or_lc_nullable_nested,
+                        arg_or_arg_nullable_nested);
             }
+            else // Comparing LC(T) and U (U neither Nullable nor LC)
+                return allowNested(array_lc_nested_or_lc_nullable_nested, arg);
         }
-    }
 
-public:
-    static void vector(
-        const IColumn & data, const ColumnArray::Offsets & offsets,
-        const IColumn & value,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data,
-        const PaddedPODArray<UInt8> * null_map_item)
-    {
-        /// Processing is split into 4 cases.
-        if (!null_map_data && !null_map_item)
-            vectorCase1(data, offsets, value, result);
-        else if (!null_map_data && null_map_item)
-            vectorCase2(data, offsets, value, result, *null_map_item);
-        else if (null_map_data && !null_map_item)
-            vectorCase3(data, offsets, value, result, *null_map_data);
-        else
-            vectorCase4(data, offsets, value, result, *null_map_data, *null_map_item);
+        return false;
     }
-};
 
-/// Catch-all implementation for arrays of arbitrary type
-/// when the 2nd function argument is a NULL value.
-template <typename IndexConv>
-struct ArrayIndexGenericNullImpl
-{
-    static void vector(
-        const IColumn & /*data*/, const ColumnArray::Offsets & offsets,
-        PaddedPODArray<typename IndexConv::ResultType> & result,
-        const PaddedPODArray<UInt8> * null_map_data)
-    {
-        size_t size = offsets.size();
-        result.resize(size);
+#define INTEGRAL_TPL_PACK UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+    void executeOnNonNullable(Block & block, const ColumnNumbers & arguments, size_t result) const
+    {
+        if (const auto* const left_arr = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get()))
         {
-            size_t array_size = offsets[i] - current_offset;
-            typename IndexConv::ResultType current = 0;
-
-            for (size_t j = 0; j < array_size; ++j)
+            if (checkAndGetColumn<ColumnLowCardinality>(&left_arr->getData()))
             {
-                if (null_map_data && (*null_map_data)[current_offset + j])
-                {
-                    if (!IndexConv::apply(j, current))
-                        break;
-                }
-            }
+                if (executeLowCardinality(block, arguments, result))
+                    return;
 
-            result[i] = current;
-            current_offset = offsets[i];
+                throw Exception(
+                    "Illegal internal type of first argument of function " + getName(),
+                    ErrorCodes::ILLEGAL_COLUMN);
+            }
         }
-    }
-};
 
+        if (!(executeIntegral<INTEGRAL_TPL_PACK>(block, arguments, result)
+              || executeConst(block, arguments, result)
+              || executeString(block, arguments, result)
+              || executeGeneric(block, arguments, result)))
+            throw Exception(
+                "Illegal internal type of first argument of function " + getName(),
+                ErrorCodes::ILLEGAL_COLUMN);
+    }
 
-inline bool allowArrayIndex(const DataTypePtr & type0, const DataTypePtr & type1)
-{
-    DataTypePtr data_type0 = removeNullable(type0);
-    DataTypePtr data_type1 = removeNullable(type1);
+    /**
+     * The Array's internal data type may be quite tricky (containing a Nullable type somewhere). To process the
+     * Nullable types correctly, for each data type specialisation we provide two null maps (one for the data and one
+     * for the items). By convention they are passed as the third and the fourth argument, respectively
+     * (counting from 1).
+     *
+     * @return {nullptr, nullptr} if there are less than 3 arguments.
+     * @return {null_map_data, nullptr} if there are three arguments
+     * @return {nullptr, null_map_item} if there are four arguments but the third is missing.
+     * @return {null_map_data, null_map_item} if there are four arguments.
+     */
+    static NullMaps getNullMaps(const Block & block, const ColumnNumbers & arguments) noexcept
+    {
+        if (arguments.size() < 3)
+            return {nullptr, nullptr};
 
-    return ((isNativeNumber(data_type0) || isEnum(data_type0)) && isNativeNumber(data_type1))
-        || data_type0->equals(*data_type1);
-}
+        const NullMap * null_map_data = nullptr;
+        const NullMap * null_map_item = nullptr;
 
+        if (const auto & data_map = block.getByPosition(arguments[2]).column; data_map)
+            null_map_data = &assert_cast<const ColumnUInt8 &>(*data_map).getData();
 
-template <typename IndexConv, typename Name>
-class FunctionArrayIndex : public IFunction
-{
-public:
-    static constexpr auto name = Name::name;
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionArrayIndex>(); }
-
-private:
-    using ResultColumnType = ColumnVector<typename IndexConv::ResultType>;
+        if (const auto & item_map = block.getByPosition(arguments[3]).column; item_map)
+            null_map_item = &assert_cast<const ColumnUInt8 &>(*item_map).getData();
 
-    template <typename T>
-    bool executeNumber(Block & block, const ColumnNumbers & arguments, size_t result) const
-    {
-        return executeNumberNumber<T, UInt8>(block, arguments, result)
-            || executeNumberNumber<T, UInt16>(block, arguments, result)
-            || executeNumberNumber<T, UInt32>(block, arguments, result)
-            || executeNumberNumber<T, UInt64>(block, arguments, result)
-            || executeNumberNumber<T, Int8>(block, arguments, result)
-            || executeNumberNumber<T, Int16>(block, arguments, result)
-            || executeNumberNumber<T, Int32>(block, arguments, result)
-            || executeNumberNumber<T, Int64>(block, arguments, result)
-            || executeNumberNumber<T, Float32>(block, arguments, result)
-            || executeNumberNumber<T, Float64>(block, arguments, result);
+        return {null_map_data, null_map_item};
     }
 
-    template <typename T, typename U>
-    bool executeNumberNumber(Block & block, const ColumnNumbers & arguments, size_t result) const
+    /**
+     * Given a variadic pack #Integral, apply executeIntegralExpanded with such parameters:
+     * Integral s = {s1, s2, ...}
+     * (s1, s1, s2, ...), (s2, s1, s2, ...), (s3, s1, s2, ...)
+     */
+    template <class ...Integral>
+    static inline bool executeIntegral(Block & block, const ColumnNumbers & arguments, size_t result_pos)
     {
-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
+        const ColumnArray * const left = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
 
-        if (!col_array)
+        if (!left)
             return false;
 
-        const ColumnVector<T> * col_nested = checkAndGetColumn<ColumnVector<T>>(&col_array->getData());
+        const IColumn& right = *block.getByPosition(arguments[1]).column.get();
 
-        if (!col_nested)
-            return false;
+        ExecutionData data = {
+            left->getData(),
+            right,
+            left->getOffsets(),
+            block,
+            result_pos,
+            getNullMaps(block, arguments)
+        };
 
-        auto col_res = ResultColumnType::create();
+        return executeIntegral<Integral...>(data);
+    }
 
-        /// Null maps of the 1st and second function arguments,
-        /// if it applies.
-        const PaddedPODArray<UInt8> * null_map_data = nullptr;
-        const PaddedPODArray<UInt8> * null_map_item = nullptr;
+    template <class ...Integral>
+    static inline bool executeIntegral(ExecutionData& data)
+    {
+        return (executeIntegralExpanded<Integral, Integral...>(data) || ...);
+    }
 
-        if (arguments.size() > 2)
-        {
-            const auto & null_map1 = block.getByPosition(arguments[2]).column;
-            if (null_map1)
-                null_map_data = &assert_cast<const ColumnUInt8 &>(*null_map1).getData();
+    /// Invoke executeIntegralImpl with such parameters: (A, other1), (A, other2), ...
+    template <class A, class ...Other>
+    static inline bool executeIntegralExpanded(ExecutionData& data)
+    {
+        return (executeIntegralImpl<A, Other>(data) || ...);
+    }
 
-            const auto & null_map2 = block.getByPosition(arguments[3]).column;
-            if (null_map2)
-                null_map_item = &assert_cast<const ColumnUInt8 &>(*null_map2).getData();
-        }
+    /**
+     * The internal data type of the first argument (target array), if it's integral, like UInt8, may differ from the
+     * second argument, namely, the @e value, so it's possible to invoke the <tt>has(Array(Int8), UInt64)</tt> e.g.
+     * so we have to check all possible variants for #Initial and #Resulting types.
+     */
+    template <class Initial, class Resulting>
+    static bool executeIntegralImpl(ExecutionData& data)
+    {
+        const ColumnVector<Initial> * col_nested = checkAndGetColumn<ColumnVector<Initial>>(&data.left);
+
+        if (!col_nested)
+            return false;
 
-        const auto item_arg = block.getByPosition(arguments[1]).column.get();
-
-        if (item_arg->onlyNull())
-            ArrayIndexNumNullImpl<T, IndexConv>::vector(col_nested->getData(), col_array->getOffsets(),
-                col_res->getData(), null_map_data);
-        else if (const auto item_arg_const = checkAndGetColumnConst<ColumnVector<U>>(item_arg))
-            ArrayIndexNumImpl<T, U, IndexConv>::vector(col_nested->getData(), col_array->getOffsets(),
-                item_arg_const->template getValue<U>(), col_res->getData(), null_map_data, nullptr);
-        else if (const auto item_arg_vector = checkAndGetColumn<ColumnVector<U>>(item_arg))
-            ArrayIndexNumImpl<T, U, IndexConv>::vector(col_nested->getData(), col_array->getOffsets(),
-                item_arg_vector->getData(), col_res->getData(), null_map_data, null_map_item);
+        const auto [null_map_data, null_map_item] = data.maps;
+
+        if (data.right.onlyNull())
+            Impl::Null<ConcreteAction>::process(
+                data.offsets,
+                data.result->getData(),
+                null_map_data);
+        else if (const auto item_arg_const = checkAndGetColumnConst<ColumnVector<Resulting>>(&data.right))
+            Impl::Main<ConcreteAction, true, Initial, Resulting>::vector(
+                col_nested->getData(),
+                data.offsets,
+                item_arg_const->template getValue<Resulting>(),
+                data.result->getData(),
+                null_map_data,
+                nullptr);
+        else if (const auto item_arg_vector = checkAndGetColumn<ColumnVector<Resulting>>(&data.right))
+            Impl::Main<ConcreteAction, false, Initial, Resulting>::vector(
+                col_nested->getData(),
+                data.offsets,
+                item_arg_vector->getData(),
+                data.result->getData(),
+                null_map_data,
+                null_map_item);
         else
             return false;
 
-        block.getByPosition(result).column = std::move(col_res);
+        data.move_result();
         return true;
     }
 
-    bool executeString(Block & block, const ColumnNumbers & arguments, size_t result) const
+    /**
+     * Catches arguments of type LC(T) (left) and U (right).
+     *
+     * The perftests
+     * https://clickhouse-test-reports.s3.yandex.net/12550/2d27fa0fa8c198a82bf1fe3625050ccf56695976/integration_tests_(release).html
+     * showed that the amount of action needed to convert the non-constant right argument to the index column
+     * (similar to the left one's) is significantly higher than converting the array itself to an ordinary column.
+     *
+     * So, in terms of performance it's more optimal to fall back to default implementation and catch only constant
+     * right arguments.
+     *
+     * Tips and tricks tried can be found at https://github.com/ClickHouse/ClickHouse/pull/12550 .
+     */
+    static bool executeLowCardinality(Block & block, const ColumnNumbers & arguments, size_t result)
     {
-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
+        const ColumnArray * const col_array = checkAndGetColumn<ColumnArray>(
+                block.getByPosition(arguments[0]).column.get());
 
         if (!col_array)
             return false;
 
-        const ColumnString * col_nested = checkAndGetColumn<ColumnString>(&col_array->getData());
+        const ColumnLowCardinality * const col_lc = checkAndGetColumn<ColumnLowCardinality>(&col_array->getData());
 
-        if (!col_nested)
+        if (!col_lc)
             return false;
 
-        auto col_res = ResultColumnType::create();
+        const auto [null_map_data, null_map_item] = getNullMaps(block, arguments);
 
-        /// Null maps of the 1st and second function arguments,
-        /// if it applies.
-        const PaddedPODArray<UInt8> * null_map_data = nullptr;
-        const PaddedPODArray<UInt8> * null_map_item = nullptr;
+        const IColumn& col_arg = *block.getByPosition(arguments[1]).column.get();
 
-        if (arguments.size() > 2)
+        if (const ColumnConst * const col_arg_const = checkAndGetColumn<ColumnConst>(col_arg))
         {
-            const auto & col1 = block.getByPosition(arguments[2]).column;
-            if (col1)
-                null_map_data = &assert_cast<const ColumnUInt8 &>(*col1).getData();
+            const IColumnUnique& col_lc_dict = col_lc->getDictionary();
+
+            const bool different_inner_types = col_lc_dict.isNullable()
+                ? !col_arg_const->structureEquals(*col_lc_dict.getNestedColumn().get())
+                : true; // Can't compare so ignore this check
 
-            const auto & col2 = block.getByPosition(arguments[3]).column;
-            if (col2)
-                null_map_item = &assert_cast<const ColumnUInt8 &>(*col2).getData();
+            const bool use_cloned_arg = col_arg_const->isNumeric()
+                // outer types do not match
+                && !col_arg_const->structureEquals(col_lc_dict)
+                // inner types do not match (like A and Nullable(B) or A and Const(B));
+                && different_inner_types;
+
+            const DataTypeArray * const array_type = checkAndGetDataType<DataTypeArray>(
+                    block.getByPosition(arguments[0]).type.get());
+            const DataTypePtr target_type_ptr = recursiveRemoveLowCardinality(array_type->getNestedType());
+
+            const ColumnPtr col_arg_cloned = use_cloned_arg
+                ? castColumn(block.getByPosition(arguments[1]), target_type_ptr)
+                : col_arg_const->getPtr();
+
+            const StringRef elem = col_arg_cloned->getDataAt(0);
+            ResultColumnPtr col_result = ResultColumnType::create();
+
+            UInt64 index = 0;
+
+            if (elem != EMPTY_STRING_REF)
+            {
+                if (std::optional<UInt64> maybe_index = col_lc_dict.getOrFindValueIndex(elem); maybe_index)
+                    index = *maybe_index;
+                else
+                {
+                    const size_t offsets_size = col_array->getOffsets().size();
+                    auto& data = col_result->getData();
+
+                    data.resize_fill(offsets_size);
+
+                    block.getByPosition(result).column = std::move(col_result);
+                    return true;
+                }
+            }
+
+            Impl::Main<ConcreteAction, true>::vector(
+                col_lc->getIndexes(),
+                col_array->getOffsets(),
+                index,
+                col_result->getData(),
+                null_map_data,
+                null_map_item);
+
+            block.getByPosition(result).column = std::move(col_result);
+            return true;
         }
+        else if (col_lc->getDictionaryPtr()->isNullable()) // LC(Nullable(T)) and U
+        {
+            const ColumnPtr left_casted = col_lc->convertToFullColumnIfLowCardinality(); // Nullable(T)
+            const ColumnNullable& left_nullable = *checkAndGetColumn<ColumnNullable>(left_casted.get());
+
+            const NullMap * const null_map_left_casted = &left_nullable.getNullMapColumn().getData();
 
-        const auto item_arg = block.getByPosition(arguments[1]).column.get();
+            const IColumn& left_ptr = left_nullable.getNestedColumn();
 
-        if (item_arg->onlyNull())
+            const ColumnPtr right_casted = col_arg.convertToFullColumnIfLowCardinality();
+            const ColumnNullable * const right_nullable = checkAndGetColumn<ColumnNullable>(right_casted.get());
+
+            const NullMap * const null_map_right_casted = right_nullable
+                ? &right_nullable->getNullMapColumn().getData()
+                : null_map_item;
+
+            const IColumn& right_ptr = right_nullable
+                ? right_nullable->getNestedColumn()
+                : *right_casted.get();
+
+            ExecutionData data = {
+                left_ptr, right_ptr,
+                col_array->getOffsets(),
+                block, result,
+                {null_map_left_casted, null_map_right_casted}};
+
+            return dispatchConvertedLCColumns(data);
+        }
+        else // LC(T) and U, T not Nullable
         {
-            ArrayIndexStringNullImpl<IndexConv>::vector_const(col_nested->getChars(), col_array->getOffsets(),
-                col_nested->getOffsets(), col_res->getData(), null_map_data);
+            if (col_arg.isNullable())
+                return false;
+
+            if (const auto* const arg_lc = checkAndGetColumn<ColumnLowCardinality>(&col_arg);
+                arg_lc && arg_lc->isNullable())
+                return false;
+
+            // LC(T) and U (possibly LC(V))
+
+            const ColumnPtr left_casted = col_lc->convertToFullColumnIfLowCardinality();
+            const ColumnPtr right_casted = col_arg.convertToFullColumnIfLowCardinality();
+
+            ExecutionData data = {
+                *left_casted.get(), *right_casted.get(), col_array->getOffsets(),
+                block, result, {null_map_data, null_map_item}
+            };
+
+            return dispatchConvertedLCColumns(data);
         }
-        else if (const auto item_arg_const = checkAndGetColumnConstStringOrFixedString(item_arg))
+    }
+
+    static bool dispatchConvertedLCColumns(ExecutionData& data)
+    {
+        if (data.left.isNumeric() && data.right.isNumeric()) // ColumnArrays
+            return executeIntegral<INTEGRAL_TPL_PACK>(data);
+
+        if (checkAndGetColumn<ColumnString>(&data.left))
+            return executeStringImpl(data);
+
+        Impl::Main<ConcreteAction, true>::vector(
+            data.left,
+            data.offsets, data.right,
+            data.result->getData(),
+            data.maps.first, data.maps.second);
+
+        data.move_result();
+        return true;
+    }
+
+#undef INTEGRAL_TPL_PACK
+
+    static bool executeString(Block & block, const ColumnNumbers & arguments, size_t result_pos)
+    {
+        const ColumnArray * array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
+
+        if (!array)
+            return false;
+
+        const ColumnString * left = checkAndGetColumn<ColumnString>(&array->getData());
+
+        if (!left)
+            return false;
+
+        const IColumn & right = *block.getByPosition(arguments[1]).column.get();
+
+        ExecutionData data = {
+            *left, right, array->getOffsets(),
+            block, result_pos, getNullMaps(block, arguments),
+            std::move(ResultColumnType::create())
+        };
+
+        return executeStringImpl(data);
+    }
+
+    static bool executeStringImpl(ExecutionData& data)
+    {
+        const auto [null_map_data, null_map_item] = data.maps;
+        const ColumnString& left = *typeid_cast<const ColumnString* const>(&data.left);
+
+        if (data.right.onlyNull())
+            Impl::Null<ConcreteAction>::process(
+                data.offsets,
+                data.result->getData(),
+                null_map_data);
+        else if (const auto *const item_arg_const = checkAndGetColumnConstStringOrFixedString(&data.right))
         {
-            const ColumnString * item_const_string = checkAndGetColumn<ColumnString>(&item_arg_const->getDataColumn());
-            const ColumnFixedString * item_const_fixedstring = checkAndGetColumn<ColumnFixedString>(&item_arg_const->getDataColumn());
+            const ColumnString * item_const_string =
+                checkAndGetColumn<ColumnString>(&item_arg_const->getDataColumn());
+
+            const ColumnFixedString * item_const_fixedstring =
+                checkAndGetColumn<ColumnFixedString>(&item_arg_const->getDataColumn());
 
             if (item_const_string)
-                ArrayIndexStringImpl<IndexConv>::vector_const(col_nested->getChars(), col_array->getOffsets(), col_nested->getOffsets(),
-                    item_const_string->getChars(), item_const_string->getDataAt(0).size,
-                    col_res->getData(), null_map_data);
+                Impl::String<ConcreteAction>::process(
+                    left.getChars(),
+                    data.offsets,
+                    left.getOffsets(),
+                    item_const_string->getChars(),
+                    item_const_string->getDataAt(0).size,
+                    data.result->getData(),
+                    null_map_data,
+                    null_map_item);
             else if (item_const_fixedstring)
-                ArrayIndexStringImpl<IndexConv>::vector_const(col_nested->getChars(), col_array->getOffsets(), col_nested->getOffsets(),
-                    item_const_fixedstring->getChars(), item_const_fixedstring->getN(),
-                    col_res->getData(), null_map_data);
+                Impl::String<ConcreteAction>::process(
+                    left.getChars(),
+                    data.offsets,
+                    left.getOffsets(),
+                    item_const_fixedstring->getChars(),
+                    item_const_fixedstring->getN(),
+                    data.result->getData(),
+                    null_map_data,
+                    null_map_item);
             else
-                throw Exception("Logical error: ColumnConst contains not String nor FixedString column", ErrorCodes::ILLEGAL_COLUMN);
+                throw Exception(
+                    "Logical error: ColumnConst contains not String nor FixedString column",
+                        ErrorCodes::ILLEGAL_COLUMN);
         }
-        else if (const auto item_arg_vector = checkAndGetColumn<ColumnString>(item_arg))
+        else if (const auto *const item_arg_vector = checkAndGetColumn<ColumnString>(&data.right))
         {
-            ArrayIndexStringImpl<IndexConv>::vectorVector(col_nested->getChars(), col_array->getOffsets(),
-                col_nested->getOffsets(), item_arg_vector->getChars(), item_arg_vector->getOffsets(),
-                col_res->getData(), null_map_data, null_map_item);
+            Impl::String<ConcreteAction>::process(
+                left.getChars(),
+                data.offsets,
+                left.getOffsets(),
+                item_arg_vector->getChars(),
+                item_arg_vector->getOffsets(),
+                data.result->getData(),
+                null_map_data,
+                null_map_item);
         }
         else
             return false;
 
-        block.getByPosition(result).column = std::move(col_res);
+        data.move_result();
         return true;
     }
 
-    bool executeConst(Block & block, const ColumnNumbers & arguments, size_t result) const
+    static bool executeConst(Block & block, const ColumnNumbers & arguments, size_t result)
     {
-        const ColumnConst * col_array = checkAndGetColumnConst<ColumnArray>(block.getByPosition(arguments[0]).column.get());
+        const ColumnConst * col_array = checkAndGetColumnConst<ColumnArray>(
+                block.getByPosition(arguments[0]).column.get());
 
         if (!col_array)
             return false;
 
         Array arr = col_array->getValue<Array>();
 
-        const auto item_arg = block.getByPosition(arguments[1]).column.get();
+        const IColumn * item_arg = block.getByPosition(arguments[1]).column.get();
+
         if (isColumnConst(*item_arg))
         {
-            typename IndexConv::ResultType current = 0;
+            ResultType current = 0;
             const auto & value = (*item_arg)[0];
 
             for (size_t i = 0, size = arr.size(); i < size; ++i)
             {
-                if (applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))
-                {
-                    if (!IndexConv::apply(i, current))
-                        break;
-                }
+                if (!applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))
+                    continue;
+
+                ConcreteAction::apply(current, i);
+
+                if constexpr (!ConcreteAction::resume_execution)
+                    break;
             }
 
             block.getByPosition(result).column = block.getByPosition(result).type->createColumnConst(
-                item_arg->size(),
-                static_cast<typename IndexConv::ResultType>(current));
+                item_arg->size(), static_cast<ResultType>(current));
         }
         else
         {
             /// Null map of the 2nd function argument, if it applies.
-            const PaddedPODArray<UInt8> * null_map = nullptr;
+            const NullMap * null_map = nullptr;
 
             if (arguments.size() > 2)
-            {
-                const auto & col = block.getByPosition(arguments[3]).column;
-                if (col)
+                if (const auto & col = block.getByPosition(arguments[3]).column; col)
                     null_map = &assert_cast<const ColumnUInt8 &>(*col).getData();
-            }
 
-            const auto size = item_arg->size();
+            const size_t size = item_arg->size();
             auto col_res = ResultColumnType::create(size);
 
             auto & data = col_res->getData();
@@ -775,23 +1005,24 @@ class FunctionArrayIndex : public IFunction
                 const auto & value = (*item_arg)[row];
 
                 data[row] = 0;
+
                 for (size_t i = 0, arr_size = arr.size(); i < arr_size; ++i)
                 {
-                    bool hit = false;
-
                     if (arr[i].isNull())
                     {
-                        if (null_map && (*null_map)[row])
-                            hit = true;
-                    }
-                    else if (applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))
-                        hit = true;
+                        if (!null_map)
+                            continue;
 
-                    if (hit)
-                    {
-                        if (!IndexConv::apply(i, data[row]))
-                            break;
+                        if (!(*null_map)[row])
+                            continue;
                     }
+                    else if (!applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))
+                        continue;
+
+                    ConcreteAction::apply(data[row], i);
+
+                    if constexpr (!ConcreteAction::resume_execution)
+                        break;
                 }
             }
 
@@ -801,208 +1032,44 @@ class FunctionArrayIndex : public IFunction
         return true;
     }
 
-    bool executeGeneric(Block & block, const ColumnNumbers & arguments, size_t result) const
+    static bool executeGeneric(Block & block, const ColumnNumbers & arguments, size_t result)
     {
-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
+        const ColumnArray * col = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
 
-        if (!col_array)
+        if (!col)
             return false;
 
-        const IColumn & col_nested = col_array->getData();
+        const IColumn & col_nested = col->getData();
         const IColumn & item_arg = *block.getByPosition(arguments[1]).column;
 
         auto col_res = ResultColumnType::create();
 
-        /// Null maps of the 1st and second function arguments,
-        /// if it applies.
-        const PaddedPODArray<UInt8> * null_map_data = nullptr;
-        const PaddedPODArray<UInt8> * null_map_item = nullptr;
-
-        if (arguments.size() > 2)
-        {
-            const auto & null_map1 = block.getByPosition(arguments[2]).column;
-            if (null_map1)
-                null_map_data = &assert_cast<const ColumnUInt8 &>(*null_map1).getData();
-
-            const auto & null_map2 = block.getByPosition(arguments[3]).column;
-            if (null_map2)
-                null_map_item = &assert_cast<const ColumnUInt8 &>(*null_map2).getData();
-        }
+        auto [null_map_data, null_map_item] = getNullMaps(block, arguments);
 
         if (item_arg.onlyNull())
-            ArrayIndexGenericNullImpl<IndexConv>::vector(col_nested, col_array->getOffsets(),
-                col_res->getData(), null_map_data);
+            Impl::Null<ConcreteAction>::process(
+                col->getOffsets(),
+                col_res->getData(),
+                null_map_data);
         else if (isColumnConst(item_arg))
-            ArrayIndexGenericImpl<IndexConv, true>::vector(col_nested, col_array->getOffsets(),
-                assert_cast<const ColumnConst &>(item_arg).getDataColumn(), col_res->getData(),    /// TODO This is wrong.
-                null_map_data, nullptr);
+            Impl::Main<ConcreteAction, true>::vector(
+                col_nested,
+                col->getOffsets(),
+                typeid_cast<const ColumnConst &>(item_arg).getDataColumn(),
+                col_res->getData(), /// TODO This is wrong.
+                null_map_data,
+                nullptr);
         else
-        {
-            ArrayIndexGenericImpl<IndexConv, false>::vector(
-                col_nested, col_array->getOffsets(), *item_arg.convertToFullColumnIfConst(), col_res->getData(),
-                null_map_data, null_map_item);
-        }
+            Impl::Main<ConcreteAction>::vector(
+                col_nested,
+                col->getOffsets(),
+                item_arg,
+                col_res->getData(),
+                null_map_data,
+                null_map_item);
 
         block.getByPosition(result).column = std::move(col_res);
         return true;
     }
-
-
-public:
-    /// Get function name.
-    String getName() const override
-    {
-        return name;
-    }
-
-    bool useDefaultImplementationForNulls() const override { return false; }
-
-    size_t getNumberOfArguments() const override { return 2; }
-
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
-    {
-        const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[0].get());
-        if (!array_type)
-            throw Exception("First argument for function " + getName() + " must be an array.",
-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-
-        if (!arguments[1]->onlyNull())
-        {
-            if (!allowArrayIndex(array_type->getNestedType(), arguments[1]))
-                throw Exception("Types of array and 2nd argument of function "
-                    + getName() + " must be identical up to nullability or numeric types or Enum and numeric type. Passed: "
-                    + arguments[0]->getName() + " and " + arguments[1]->getName() + ".",
-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-        }
-
-        return std::make_shared<DataTypeNumber<typename IndexConv::ResultType>>();
-    }
-
-    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) const override
-    {
-        /// If one or both arguments passed to this function are nullable,
-        /// we create a new block that contains non-nullable arguments:
-        /// - if the 1st argument is a non-constant array of nullable values,
-        /// it is turned into a non-constant array of ordinary values + a null
-        /// byte map;
-        /// - if the 2nd argument is a nullable value, it is turned into an
-        /// ordinary value + a null byte map.
-        /// Note that since constant arrays have quite a specific structure
-        /// (they are vectors of Fields, which may represent the NULL value),
-        /// they do not require any preprocessing
-
-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());
-
-        const ColumnNullable * nullable = nullptr;
-        if (col_array)
-            nullable = checkAndGetColumn<ColumnNullable>(col_array->getData());
-
-        auto & arg_column = block.getByPosition(arguments[1]).column;
-
-        const ColumnNullable * arg_nullable = nullptr;
-        arg_nullable = checkAndGetColumn<ColumnNullable>(*arg_column);
-
-        if (!nullable && !arg_nullable)
-        {
-            /// Simple case: no nullable values passeded.
-            perform(block, arguments, result);
-        }
-        else
-        {
-            /// Template of the block on which we will actually apply the function.
-            /// Its elements will be filled later.
-            Block source_block =
-            {
-                /// 1st function argument (data)
-                {
-                },
-
-                /// 2nd function argument
-                {
-                },
-
-                /// 1st argument null map
-                {
-                },
-
-                /// 2nd argument null map
-                {
-                },
-
-                /// Function result.
-                {
-                    nullptr,
-                    block.getByPosition(result).type,
-                    ""
-                }
-            };
-
-            if (nullable)
-            {
-                const auto & nested_col = nullable->getNestedColumnPtr();
-
-                auto & data = source_block.getByPosition(0);
-                data.column = ColumnArray::create(nested_col, col_array->getOffsetsPtr());
-                data.type = std::make_shared<DataTypeArray>(
-                    static_cast<const DataTypeNullable &>(
-                        *static_cast<const DataTypeArray &>(*block.getByPosition(arguments[0]).type).getNestedType()).getNestedType());
-
-                auto & null_map = source_block.getByPosition(2);
-                null_map.column = nullable->getNullMapColumnPtr();
-                null_map.type = std::make_shared<DataTypeUInt8>();
-            }
-            else
-            {
-                auto & data = source_block.getByPosition(0);
-                data = block.getByPosition(arguments[0]);
-            }
-
-            if (arg_nullable)
-            {
-                auto & arg = source_block.getByPosition(1);
-                arg.column = arg_nullable->getNestedColumnPtr();
-                arg.type = static_cast<const DataTypeNullable &>(*block.getByPosition(arguments[1]).type).getNestedType();
-
-                auto & null_map = source_block.getByPosition(3);
-                null_map.column = arg_nullable->getNullMapColumnPtr();
-                null_map.type = std::make_shared<DataTypeUInt8>();
-            }
-            else
-            {
-                auto & arg = source_block.getByPosition(1);
-                arg = block.getByPosition(arguments[1]);
-            }
-
-            /// Now perform the function.
-            perform(source_block, {0, 1, 2, 3}, 4);
-
-            /// Move the result to its final position.
-            const ColumnWithTypeAndName & source_col = source_block.getByPosition(4);
-            ColumnWithTypeAndName & dest_col = block.getByPosition(result);
-            dest_col.column = std::move(source_col.column);
-        }
-    }
-
-private:
-    /// Perform function on the given block. Internal version.
-    void perform(Block & block, const ColumnNumbers & arguments, size_t result) const
-    {
-        if (!(executeNumber<UInt8>(block, arguments, result)
-            || executeNumber<UInt16>(block, arguments, result)
-            || executeNumber<UInt32>(block, arguments, result)
-            || executeNumber<UInt64>(block, arguments, result)
-            || executeNumber<Int8>(block, arguments, result)
-            || executeNumber<Int16>(block, arguments, result)
-            || executeNumber<Int32>(block, arguments, result)
-            || executeNumber<Int64>(block, arguments, result)
-            || executeNumber<Float32>(block, arguments, result)
-            || executeNumber<Float64>(block, arguments, result)
-            || executeConst(block, arguments, result)
-            || executeString(block, arguments, result)
-            || executeGeneric(block, arguments, result)))
-            throw Exception{"Illegal column " + block.getByPosition(arguments[0]).column->getName()
-                + " of first argument of function " + getName(), ErrorCodes::ILLEGAL_COLUMN};
-    }
 };
-
 }
diff --git a/src/Functions/array/countEqual.cpp b/src/Functions/array/countEqual.cpp
index fd4914e90f40..4c0fc495f389 100644
--- a/src/Functions/array/countEqual.cpp
+++ b/src/Functions/array/countEqual.cpp
@@ -1,18 +1,14 @@
 #include "arrayIndex.h"
 #include <Functions/FunctionFactory.h>
 
-
 namespace DB
 {
-
 struct NameCountEqual { static constexpr auto name = "countEqual"; };
 
-using FunctionCountEqual = FunctionArrayIndex<IndexCount, NameCountEqual>;
+using FunctionCountEqual = FunctionArrayIndex<CountEqualAction, NameCountEqual>;
 
 void registerFunctionCountEqual(FunctionFactory & factory)
 {
     factory.registerFunction<FunctionCountEqual>();
 }
-
-
 }
diff --git a/src/Functions/array/has.cpp b/src/Functions/array/has.cpp
index 772facea52d0..1a00c44671e3 100644
--- a/src/Functions/array/has.cpp
+++ b/src/Functions/array/has.cpp
@@ -1,18 +1,12 @@
 #include "arrayIndex.h"
 #include <Functions/FunctionFactory.h>
 
-
 namespace DB
 {
-
 struct NameHas { static constexpr auto name = "has"; };
 
 /// has(arr, x) - whether there is an element x in the array.
-using FunctionHas = FunctionArrayIndex<IndexToOne, NameHas>;
-
-void registerFunctionHas(FunctionFactory & factory)
-{
-    factory.registerFunction<FunctionHas>();
-}
+using FunctionHas = FunctionArrayIndex<HasAction, NameHas>;
 
+void registerFunctionHas(FunctionFactory & factory) { factory.registerFunction<FunctionHas>(); }
 }
diff --git a/src/Functions/array/indexOf.cpp b/src/Functions/array/indexOf.cpp
index d180a9f65d4f..6ab87e6182c4 100644
--- a/src/Functions/array/indexOf.cpp
+++ b/src/Functions/array/indexOf.cpp
@@ -1,19 +1,16 @@
 #include "arrayIndex.h"
 #include <Functions/FunctionFactory.h>
 
-
 namespace DB
 {
-
 struct NameIndexOf { static constexpr auto name = "indexOf"; };
 
-/// indexOf(arr, x) - returns the index of the element x (starting with 1), if it exists in the array, or 0 if it is not.
-using FunctionIndexOf = FunctionArrayIndex<IndexIdentity, NameIndexOf>;
+/// indexOf(arr, x) - returns the index of the element x (starting with 1), if it exists in the array, or 0 if it
+/// doesn't.
+using FunctionIndexOf = FunctionArrayIndex<IndexOfAction, NameIndexOf>;
 
 void registerFunctionIndexOf(FunctionFactory & factory)
 {
     factory.registerFunction<FunctionIndexOf>();
 }
-
-
 }
