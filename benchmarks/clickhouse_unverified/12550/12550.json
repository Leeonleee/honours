{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12550,
  "instance_id": "ClickHouse__ClickHouse-12550",
  "issue_numbers": [
    "13392",
    "10880",
    "13576",
    "6005",
    "13917"
  ],
  "base_commit": "859eaf98f0f0436a2f7c6fe7963aff29f65c877f",
  "patch": "diff --git a/base/common/StringRef.h b/base/common/StringRef.h\nindex 2247f0de2ed5..410e13ba7d8c 100644\n--- a/base/common/StringRef.h\n+++ b/base/common/StringRef.h\n@@ -21,21 +21,26 @@\n #endif\n \n \n-/// The thing to avoid creating strings to find substrings in the hash table.\n+/**\n+ * The std::string_view-like container to avoid creating strings to find substrings in the hash table.\n+ */\n struct StringRef\n {\n     const char * data = nullptr;\n     size_t size = 0;\n \n+    /// Non-constexpr due to reinterpret_cast.\n     template <typename CharT, typename = std::enable_if_t<sizeof(CharT) == 1>>\n-    constexpr StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_)\n+    StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_)\n     {\n         /// Sanity check for overflowed values.\n         assert(size < 0x8000000000000000ULL);\n     }\n \n+    constexpr StringRef(const char * data_, size_t size_) : data(data_), size(size_) {}\n+\n     StringRef(const std::string & s) : data(s.data()), size(s.size()) {}\n-    constexpr explicit StringRef(const std::string_view & s) : data(s.data()), size(s.size()) {}\n+    constexpr explicit StringRef(std::string_view s) : data(s.data()), size(s.size()) {}\n     constexpr StringRef(const char * data_) : StringRef(std::string_view{data_}) {}\n     constexpr StringRef() = default;\n \n@@ -45,6 +50,12 @@ struct StringRef\n     constexpr explicit operator std::string_view() const { return {data, size}; }\n };\n \n+/// Here constexpr doesn't implicate inline, see https://www.viva64.com/en/w/v1043/\n+/// nullptr can't be used because the StringRef values are used in SipHash's pointer arithmetics\n+/// and the UBSan thinks that something like nullptr + 8 is UB.\n+constexpr const inline char empty_string_ref_addr{};\n+constexpr const inline StringRef EMPTY_STRING_REF{&empty_string_ref_addr, 0};\n+\n using StringRefs = std::vector<StringRef>;\n \n \ndiff --git a/src/Columns/ColumnLowCardinality.h b/src/Columns/ColumnLowCardinality.h\nindex ba077fcf1682..e3b879d6dd5b 100644\n--- a/src/Columns/ColumnLowCardinality.h\n+++ b/src/Columns/ColumnLowCardinality.h\n@@ -15,6 +15,15 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+/**\n+ * How data is stored (in a nutshell):\n+ * we have a dictionary @e reverse_index in ColumnUnique that holds pairs (DataType, UIntXX) and a column\n+ * with UIntXX holding actual data indices.\n+ * To obtain the value's index, call #getOrFindIndex.\n+ * To operate on the data (so called indices column), call #getIndexes.\n+ *\n+ * @note The indices column always contains the default value (empty StringRef) with the first index.\n+ */\n class ColumnLowCardinality final : public COWHelper<IColumn, ColumnLowCardinality>\n {\n     friend class COWHelper<IColumn, ColumnLowCardinality>;\ndiff --git a/src/Columns/ColumnNullable.cpp b/src/Columns/ColumnNullable.cpp\nindex 1f378c5d41e4..888410202f0a 100644\n--- a/src/Columns/ColumnNullable.cpp\n+++ b/src/Columns/ColumnNullable.cpp\n@@ -14,7 +14,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int NOT_IMPLEMENTED;\n     extern const int LOGICAL_ERROR;\n     extern const int ILLEGAL_COLUMN;\n     extern const int SIZES_OF_NESTED_COLUMNS_ARE_INCONSISTENT;\n@@ -105,11 +104,6 @@ void ColumnNullable::get(size_t n, Field & res) const\n         getNestedColumn().get(n, res);\n }\n \n-StringRef ColumnNullable::getDataAt(size_t /*n*/) const\n-{\n-    throw Exception{\"Method getDataAt is not supported for \" + getName(), ErrorCodes::NOT_IMPLEMENTED};\n-}\n-\n void ColumnNullable::insertData(const char * pos, size_t length)\n {\n     if (pos == nullptr)\ndiff --git a/src/Columns/ColumnNullable.h b/src/Columns/ColumnNullable.h\nindex 4e72de6b1157..e4033e227370 100644\n--- a/src/Columns/ColumnNullable.h\n+++ b/src/Columns/ColumnNullable.h\n@@ -51,9 +51,20 @@ class ColumnNullable final : public COWHelper<IColumn, ColumnNullable>\n     bool isNullAt(size_t n) const override { return assert_cast<const ColumnUInt8 &>(*null_map).getData()[n] != 0;}\n     Field operator[](size_t n) const override;\n     void get(size_t n, Field & res) const override;\n-    bool getBool(size_t n) const override { return isNullAt(n) ? 0 : nested_column->getBool(n); }\n+    bool getBool(size_t n) const override { return isNullAt(n) ? false : nested_column->getBool(n); }\n     UInt64 get64(size_t n) const override { return nested_column->get64(n); }\n-    StringRef getDataAt(size_t n) const override;\n+\n+    /**\n+     * If isNullAt(n) returns false, returns the nested column's getDataAt(n), otherwise returns a special value\n+     * EMPTY_STRING_REF indicating that data is not present.\n+     */\n+    StringRef getDataAt(size_t n) const override\n+    {\n+        if (isNullAt(n))\n+            return EMPTY_STRING_REF;\n+\n+        return getNestedColumn().getDataAt(n);\n+    }\n \n     /// Will insert null value if pos=nullptr\n     void insertData(const char * pos, size_t length) override;\ndiff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h\nindex d2d93647538c..d0edf65edd85 100644\n--- a/src/Columns/ColumnUnique.h\n+++ b/src/Columns/ColumnUnique.h\n@@ -16,6 +16,7 @@\n #include <ext/range.h>\n \n #include <common/unaligned.h>\n+#include \"Columns/ColumnConst.h\"\n \n \n namespace DB\n@@ -90,14 +91,13 @@ class ColumnUnique final : public COWHelper<IColumnUnique, ColumnUnique<ColumnTy\n     void protect() override { column_holder->protect(); }\n     size_t allocatedBytes() const override\n     {\n-        return column_holder->allocatedBytes()\n-               + index.allocatedBytes()\n-               + (nested_null_mask ? nested_null_mask->allocatedBytes() : 0);\n+        return column_holder->allocatedBytes() + reverse_index.allocatedBytes()\n+            + (nested_null_mask ? nested_null_mask->allocatedBytes() : 0);\n     }\n     void forEachSubcolumn(IColumn::ColumnCallback callback) override\n     {\n         callback(column_holder);\n-        index.setColumn(getRawColumnPtr());\n+        reverse_index.setColumn(getRawColumnPtr());\n         if (is_nullable)\n             nested_column_nullable = ColumnNullable::create(column_holder, nested_null_mask);\n     }\n@@ -109,16 +109,30 @@ class ColumnUnique final : public COWHelper<IColumnUnique, ColumnUnique<ColumnTy\n         return false;\n     }\n \n-    const UInt64 * tryGetSavedHash() const override { return index.tryGetSavedHash(); }\n+    const UInt64 * tryGetSavedHash() const override { return reverse_index.tryGetSavedHash(); }\n \n     UInt128 getHash() const override { return hash.getHash(*getRawColumnPtr()); }\n \n-private:\n+    std::optional<UInt64> getOrFindValueIndex(StringRef value) const override\n+    {\n+        if (std::optional<UInt64> res = reverse_index.getIndex(value); res)\n+            return res;\n+\n+        auto& nested = *getNestedColumn();\n+\n+        for (size_t i = 0; i < nested.size(); ++i)\n+            if (nested.getDataAt(i) == value)\n+                return i;\n+\n+        return {};\n+    }\n \n+private:\n     IColumn::WrappedPtr column_holder;\n     bool is_nullable;\n     size_t size_of_value_if_fixed = 0;\n-    ReverseIndex<UInt64, ColumnType> index;\n+\n+    ReverseIndex<UInt64, ColumnType> reverse_index;\n \n     /// For DataTypeNullable, stores null map.\n     IColumn::WrappedPtr nested_null_mask;\n@@ -169,21 +183,20 @@ template <typename ColumnType>\n ColumnUnique<ColumnType>::ColumnUnique(const ColumnUnique & other)\n     : column_holder(other.column_holder)\n     , is_nullable(other.is_nullable)\n-    , size_of_value_if_fixed (other.size_of_value_if_fixed)\n-    , index(numSpecialValues(is_nullable), 0)\n+    , size_of_value_if_fixed(other.size_of_value_if_fixed)\n+    , reverse_index(numSpecialValues(is_nullable), 0)\n {\n-    index.setColumn(getRawColumnPtr());\n+    reverse_index.setColumn(getRawColumnPtr());\n     createNullMask();\n }\n \n template <typename ColumnType>\n ColumnUnique<ColumnType>::ColumnUnique(const IDataType & type)\n-    : is_nullable(type.isNullable())\n-    , index(numSpecialValues(is_nullable), 0)\n+    : is_nullable(type.isNullable()), reverse_index(numSpecialValues(is_nullable), 0)\n {\n     const auto & holder_type = is_nullable ? *static_cast<const DataTypeNullable &>(type).getNestedType() : type;\n     column_holder = holder_type.createColumn()->cloneResized(numSpecialValues());\n-    index.setColumn(getRawColumnPtr());\n+    reverse_index.setColumn(getRawColumnPtr());\n     createNullMask();\n \n     if (column_holder->valuesHaveFixedSize())\n@@ -192,16 +205,14 @@ ColumnUnique<ColumnType>::ColumnUnique(const IDataType & type)\n \n template <typename ColumnType>\n ColumnUnique<ColumnType>::ColumnUnique(MutableColumnPtr && holder, bool is_nullable_)\n-    : column_holder(std::move(holder))\n-    , is_nullable(is_nullable_)\n-    , index(numSpecialValues(is_nullable_), 0)\n+    : column_holder(std::move(holder)), is_nullable(is_nullable_), reverse_index(numSpecialValues(is_nullable_), 0)\n {\n     if (column_holder->size() < numSpecialValues())\n         throw Exception(\"Too small holder column for ColumnUnique.\", ErrorCodes::ILLEGAL_COLUMN);\n     if (isColumnNullable(*column_holder))\n         throw Exception(\"Holder column for ColumnUnique can't be nullable.\", ErrorCodes::ILLEGAL_COLUMN);\n \n-    index.setColumn(getRawColumnPtr());\n+    reverse_index.setColumn(getRawColumnPtr());\n     createNullMask();\n \n     if (column_holder->valuesHaveFixedSize())\n@@ -288,12 +299,10 @@ size_t ColumnUnique<ColumnType>::uniqueInsertFrom(const IColumn & src, size_t n)\n template <typename ColumnType>\n size_t ColumnUnique<ColumnType>::uniqueInsertData(const char * pos, size_t length)\n {\n-    auto column = getRawColumnPtr();\n+    if (auto index = getNestedTypeDefaultValueIndex(); getRawColumnPtr()->getDataAt(index) == StringRef(pos, length))\n+        return index;\n \n-    if (column->getDataAt(getNestedTypeDefaultValueIndex()) == StringRef(pos, length))\n-        return getNestedTypeDefaultValueIndex();\n-\n-    auto insertion_point = index.insert(StringRef(pos, length));\n+    auto insertion_point = reverse_index.insert({pos, length});\n \n     updateNullMask();\n \n@@ -320,6 +329,7 @@ StringRef ColumnUnique<ColumnType>::serializeValueIntoArena(size_t n, Arena & ar\n         return StringRef(nested_ref.data - s, nested_ref.size + s);\n     }\n \n+\n     return column_holder->serializeValueIntoArena(n, arena, begin);\n }\n \n@@ -513,14 +523,14 @@ MutableColumnPtr ColumnUnique<ColumnType>::uniqueInsertRangeImpl(\n \n             if (secondary_index && next_position >= max_dictionary_size)\n             {\n-                auto insertion_point = index.getInsertionPoint(ref);\n-                if (insertion_point == index.lastInsertionPoint())\n+                auto insertion_point = reverse_index.getInsertionPoint(ref);\n+                if (insertion_point == reverse_index.lastInsertionPoint())\n                     res = insert_key(ref, *secondary_index);\n                 else\n                     positions[num_added_rows] = insertion_point;\n             }\n             else\n-                res = insert_key(ref, index);\n+                res = insert_key(ref, reverse_index);\n \n             if (res)\n                 return res;\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex 818ac82cf0b5..d2c4846193ca 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -22,11 +22,11 @@ namespace ErrorCodes\n   * Floating-point numbers are compared this way that NaNs always end up at the end\n   *  (if you don't do this, the sort would not work at all).\n   */\n-template <typename T>\n+template <class T, class U = T>\n struct CompareHelper\n {\n-    static bool less(T a, T b, int /*nan_direction_hint*/) { return a < b; }\n-    static bool greater(T a, T b, int /*nan_direction_hint*/) { return a > b; }\n+    static constexpr bool less(T a, U b, int /*nan_direction_hint*/) { return a < b; }\n+    static constexpr bool greater(T a, U b, int /*nan_direction_hint*/) { return a > b; }\n \n     /** Compares two numbers. Returns a number less than zero, equal to zero, or greater than zero if a < b, a == b, a > b, respectively.\n       * If one of the values is NaN, then\n@@ -34,19 +34,19 @@ struct CompareHelper\n       * - if nan_direction_hint == 1 - NaN are considered to be larger than all numbers;\n       * Essentially: nan_direction_hint == -1 says that the comparison is for sorting in descending order.\n       */\n-    static int compare(T a, T b, int /*nan_direction_hint*/)\n+    static constexpr int compare(T a, U b, int /*nan_direction_hint*/)\n     {\n         return a > b ? 1 : (a < b ? -1 : 0);\n     }\n };\n \n-template <typename T>\n+template <class T>\n struct FloatCompareHelper\n {\n-    static bool less(T a, T b, int nan_direction_hint)\n+    static constexpr bool less(T a, T b, int nan_direction_hint)\n     {\n-        bool isnan_a = std::isnan(a);\n-        bool isnan_b = std::isnan(b);\n+        const bool isnan_a = std::isnan(a);\n+        const bool isnan_b = std::isnan(b);\n \n         if (isnan_a && isnan_b)\n             return false;\n@@ -58,10 +58,10 @@ struct FloatCompareHelper\n         return a < b;\n     }\n \n-    static bool greater(T a, T b, int nan_direction_hint)\n+    static constexpr bool greater(T a, T b, int nan_direction_hint)\n     {\n-        bool isnan_a = std::isnan(a);\n-        bool isnan_b = std::isnan(b);\n+        const bool isnan_a = std::isnan(a);\n+        const bool isnan_b = std::isnan(b);\n \n         if (isnan_a && isnan_b)\n             return false;\n@@ -73,10 +73,11 @@ struct FloatCompareHelper\n         return a > b;\n     }\n \n-    static int compare(T a, T b, int nan_direction_hint)\n+    static constexpr int compare(T a, T b, int nan_direction_hint)\n     {\n-        bool isnan_a = std::isnan(a);\n-        bool isnan_b = std::isnan(b);\n+        const bool isnan_a = std::isnan(a);\n+        const bool isnan_b = std::isnan(b);\n+\n         if (unlikely(isnan_a || isnan_b))\n         {\n             if (isnan_a && isnan_b)\n@@ -91,9 +92,8 @@ struct FloatCompareHelper\n     }\n };\n \n-template <> struct CompareHelper<Float32> : public FloatCompareHelper<Float32> {};\n-template <> struct CompareHelper<Float64> : public FloatCompareHelper<Float64> {};\n-\n+template <class U> struct CompareHelper<Float32, U> : public FloatCompareHelper<Float32> {};\n+template <class U> struct CompareHelper<Float64, U> : public FloatCompareHelper<Float64> {};\n \n /** A template for columns that use a simple array to store.\n  */\n@@ -201,6 +201,12 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>\n         data.push_back(value);\n     }\n \n+    template <class U>\n+    constexpr int compareAtOther(size_t n, size_t m, const ColumnVector<U> & rhs, int nan_direction_hint) const\n+    {\n+        return CompareHelper<T, U>::compare(data[n], rhs.data[m], nan_direction_hint);\n+    }\n+\n     /// This method implemented in header because it could be possibly devirtualized.\n     int compareAt(size_t n, size_t m, const IColumn & rhs_, int nan_direction_hint) const override\n     {\ndiff --git a/src/Columns/IColumnUnique.h b/src/Columns/IColumnUnique.h\nindex e91000b0a61f..99facea60553 100644\n--- a/src/Columns/IColumnUnique.h\n+++ b/src/Columns/IColumnUnique.h\n@@ -1,4 +1,5 @@\n #pragma once\n+#include <optional>\n #include <Columns/IColumn.h>\n #include <Common/UInt128.h>\n \n@@ -9,6 +10,7 @@ namespace ErrorCodes\n     extern const int NOT_IMPLEMENTED;\n }\n \n+/// Sort of a dictionary\n class IColumnUnique : public IColumn\n {\n public:\n@@ -68,6 +70,24 @@ class IColumnUnique : public IColumn\n     const char * getFamilyName() const override { return \"ColumnUnique\"; }\n     TypeIndex getDataType() const override { return getNestedColumn()->getDataType(); }\n \n+    /**\n+     * Given some value (usually, of type @e ColumnType) @p value that is convertible to DB::StringRef, obtains its\n+     * index in the DB::ColumnUnique::reverse_index hashtable.\n+     *\n+     * The reverse index (StringRef => UInt64) is built lazily, so there are two variants:\n+     * - On the function call it's present. Therefore we obtain the index in O(1).\n+     * - The reverse index is absent. We search for the index linearly.\n+     *\n+     * @see DB::ReverseIndex\n+     * @see DB::ColumnUnique\n+     *\n+     * The most common example uses https://clickhouse.tech/docs/en/sql-reference/data-types/lowcardinality/ columns.\n+     * Consider data type @e LC(String). The inner type here is @e String which is more or less a contigous memory\n+     * region, so it can be easily represented as a @e StringRef. So we pass that ref to this function and get its\n+     * index in the dictionary, which can be used to operate with the indices column.\n+     */\n+    virtual std::optional<UInt64> getOrFindValueIndex(StringRef value) const = 0;\n+\n     void insert(const Field &) override\n     {\n         throw Exception(\"Method insert is not supported for ColumnUnique.\", ErrorCodes::NOT_IMPLEMENTED);\ndiff --git a/src/Columns/ReverseIndex.h b/src/Columns/ReverseIndex.h\nindex 0c897e4f397a..154293acf99a 100644\n--- a/src/Columns/ReverseIndex.h\n+++ b/src/Columns/ReverseIndex.h\n@@ -325,7 +325,21 @@ class ReverseIndex\n     static constexpr bool use_saved_hash = !is_numeric_column;\n \n     UInt64 insert(const StringRef & data);\n-    UInt64 getInsertionPoint(const StringRef & data);\n+\n+    /// Returns the found data's index in the dictionary. If index is not built, builds it.\n+    UInt64 getInsertionPoint(StringRef data)\n+    {\n+        if (!index) buildIndex();\n+        return getIndexImpl(data);\n+    }\n+\n+    /// Returns the found data's index in the dictionary if the #index is built, otherwise, returns a std::nullopt.\n+    std::optional<UInt64> getIndex(StringRef data) const\n+    {\n+        if (!index) return {};\n+        return getIndexImpl(data);\n+    }\n+\n     UInt64 lastInsertionPoint() const { return size() + base_index; }\n \n     ColumnType * getColumn() const { return column; }\n@@ -380,6 +394,8 @@ class ReverseIndex\n     }\n \n     ColumnUInt64::MutablePtr calcHashes() const;\n+\n+    UInt64 getIndexImpl(StringRef data) const;\n };\n \n \n@@ -499,11 +515,8 @@ UInt64 ReverseIndex<IndexType, ColumnType>::insert(const StringRef & data)\n }\n \n template <typename IndexType, typename ColumnType>\n-UInt64 ReverseIndex<IndexType, ColumnType>::getInsertionPoint(const StringRef & data)\n+UInt64 ReverseIndex<IndexType, ColumnType>::getIndexImpl(StringRef data) const\n {\n-    if (!index)\n-        buildIndex();\n-\n     using IteratorType = typename IndexMapType::iterator;\n     IteratorType iterator;\n \n@@ -512,5 +525,4 @@ UInt64 ReverseIndex<IndexType, ColumnType>::getInsertionPoint(const StringRef &\n \n     return iterator == index->end() ? size() + base_index : iterator->getValue();\n }\n-\n }\ndiff --git a/src/Functions/array/arrayIndex.h b/src/Functions/array/arrayIndex.h\nindex e3c0cbcb92cb..b12372d28ce2 100644\n--- a/src/Functions/array/arrayIndex.h\n+++ b/src/Functions/array/arrayIndex.h\n@@ -1,3 +1,5 @@\n+#include <optional>\n+#include <type_traits>\n #include <Functions/IFunctionImpl.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n@@ -12,6 +14,9 @@\n #include <Common/FieldVisitorsAccurateComparison.h>\n #include <Common/memcmpSmall.h>\n #include <Common/assert_cast.h>\n+#include \"Columns/ColumnLowCardinality.h\"\n+#include \"DataTypes/DataTypeLowCardinality.h\"\n+#include \"Interpreters/castColumn.h\"\n \n \n namespace DB\n@@ -23,179 +28,132 @@ namespace ErrorCodes\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n-/// For has.\n-struct IndexToOne\n+using NullMap = PaddedPODArray<UInt8>;\n+\n+/// ConcreteActions -- what to do when the index was found.\n+\n+struct HasAction\n {\n     using ResultType = UInt8;\n-    static bool apply(size_t, ResultType & current) { current = 1; return false; }\n+    static constexpr const bool resume_execution = false;\n+    static constexpr void apply(ResultType& current, size_t) noexcept { current = 1; }\n };\n \n-/// For indexOf.\n-struct IndexIdentity\n+/// The index is returned starting from 1.\n+struct IndexOfAction\n {\n     using ResultType = UInt64;\n-    /// The index is returned starting from 1.\n-    static bool apply(size_t j, ResultType & current) { current = j + 1; return false; }\n+    static constexpr const bool resume_execution = false;\n+    static constexpr void apply(ResultType& current, size_t j) noexcept { current = j + 1; }\n };\n \n-/// For countEqual.\n-struct IndexCount\n+struct CountEqualAction\n {\n     using ResultType = UInt64;\n-    static bool apply(size_t, ResultType & current) { ++current; return true; }\n+    static constexpr const bool resume_execution = true;\n+    static constexpr void apply(ResultType & current, size_t) noexcept { ++current; }\n };\n \n-\n-template <typename T, typename U, typename IndexConv>\n-struct ArrayIndexNumImpl\n+/// How to perform the search depending on the arguments data types.\n+namespace Impl\n+{\n+template <\n+    class ConcreteAction,\n+    bool RightArgIsConstant = false,\n+    class IntegralInitial = UInt64,\n+    class IntegralResult = UInt64>\n+struct Main\n {\n private:\n+    using Initial = IntegralInitial;\n+    using Result = IntegralResult;\n \n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wsign-compare\"\n+    using ResultType = typename ConcreteAction::ResultType;\n+    using ResultArr = PaddedPODArray<ResultType>;\n \n-    /// compares `lhs` against `i`-th element of `rhs`\n-    static bool compare(const T & lhs, const PaddedPODArray<U> & rhs, const size_t i) { return lhs == rhs[i]; }\n-    /// compares `lhs against `rhs`, third argument unused\n-    static bool compare(const T & lhs, const U & rhs, size_t) { return lhs == rhs; }\n+    using ArrOffset = ColumnArray::Offset;\n+    using ArrOffsets = ColumnArray::Offsets;\n \n-#pragma GCC diagnostic pop\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wsign-compare\"\n \n-    static bool hasNull(const PaddedPODArray<UInt8> & null_map, size_t i)\n+    static constexpr bool compare(const Initial & left, const PaddedPODArray<Result> & right, size_t, size_t i) noexcept\n     {\n-        return null_map[i];\n+        return left == right[i];\n     }\n \n-    /// Both function arguments are ordinary.\n-    template <typename ScalarOrVector>\n-    static void vectorCase1(\n-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,\n-        const ScalarOrVector & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result)\n+    static constexpr bool compare(const PaddedPODArray<Initial> & left, const Result & right, size_t i, size_t) noexcept\n     {\n-        size_t size = offsets.size();\n-        result.resize(size);\n-\n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n-\n-            for (size_t j = 0; j < array_size; ++j)\n-            {\n-                if (compare(data[current_offset + j], value, i))\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+        return left[i] == right;\n+    }\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n-        }\n+    static constexpr bool compare(\n+            const PaddedPODArray<Initial> & left, const PaddedPODArray<Result> & right, size_t i, size_t j) noexcept\n+    {\n+        return left[i] == right[j];\n     }\n \n-    /// The 2nd function argument is nullable.\n-    template <typename ScalarOrVector>\n-    static void vectorCase2(\n-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,\n-        const ScalarOrVector & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> & null_map_item)\n+    /// LowCardinality\n+    static bool compare(const IColumn & left, const Result& right, size_t i, size_t)\n     {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+        return left.getUInt(i) == right;\n+    }\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+    /// Generic\n+    static bool compare(const IColumn& left, const IColumn& right, size_t i, size_t j)\n+    {\n+        return 0 == left.compareAt(i, RightArgIsConstant ? 0 : j, right, 1);\n+    }\n \n-            for (size_t j = 0; j < array_size; ++j)\n-            {\n-                if (!hasNull(null_map_item, i) && compare(data[current_offset + j], value, i))\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+#pragma GCC diagnostic pop\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n-        }\n-    }\n+    static constexpr bool hasNull(const NullMap * const null_map, size_t i) noexcept { return (*null_map)[i]; }\n \n-    /// The 1st function argument is a non-constant array of nullable values.\n-    template <typename ScalarOrVector>\n-    static void vectorCase3(\n-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,\n-        const ScalarOrVector & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> & null_map_data)\n+    template <size_t Case, class Data, class Target>\n+    static void process(\n+        const Data & data, const ArrOffsets & offsets, const Target & target, ResultArr & result,\n+        [[maybe_unused]] const NullMap * const null_map_data,\n+        [[maybe_unused]] const NullMap * const null_map_item)\n     {\n-        size_t size = offsets.size();\n+        const size_t size = offsets.size();\n+\n         result.resize(size);\n \n-        ColumnArray::Offset current_offset = 0;\n+        ArrOffset current_offset = 0;\n+\n         for (size_t i = 0; i < size; ++i)\n         {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+            const size_t array_size = offsets[i] - current_offset;\n+            ResultType current = 0;\n \n             for (size_t j = 0; j < array_size; ++j)\n             {\n-                if (null_map_data[current_offset + j])\n-                {\n-                }\n-                else if (compare(data[current_offset + j], value, i))\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+                if constexpr (Case == 2) /// Right arg is Nullable\n+                     if (hasNull(null_map_item, i))\n+                        continue;\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n-        }\n-    }\n+                if constexpr (Case == 3) /// Left arg is an array of Nullables\n+                    if (hasNull(null_map_data, current_offset + j))\n+                        continue;\n \n-    /// The 1st function argument is a non-constant array of nullable values.\n-    /// The 2nd function argument is nullable.\n-    template <typename ScalarOrVector>\n-    static void vectorCase4(\n-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,\n-        const ScalarOrVector & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> & null_map_data,\n-        const PaddedPODArray<UInt8> & null_map_item)\n-    {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+                if constexpr (Case == 4) /// Both args are nullable\n+                {\n+                    const bool right_is_null = hasNull(null_map_data, current_offset + j);\n+                    const bool left_is_null = hasNull(null_map_item, i);\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+                    if (right_is_null != left_is_null)\n+                        continue;\n \n-            for (size_t j = 0; j < array_size; ++j)\n-            {\n-                bool hit = false;\n-                if (null_map_data[current_offset + j])\n-                {\n-                    if (hasNull(null_map_item, i))\n-                        hit = true;\n+                    if (!right_is_null && !compare(data, target, current_offset + j, i))\n+                        continue;\n                 }\n-                else if (compare(data[current_offset + j], value, i))\n-                    hit = true;\n+                else if (!compare(data, target, current_offset + j, i))\n+                        continue;\n \n-                if (hit)\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n+                ConcreteAction::apply(current, j);\n+\n+                if constexpr (!ConcreteAction::resume_execution)\n+                    break;\n             }\n \n             result[i] = current;\n@@ -204,86 +162,63 @@ struct ArrayIndexNumImpl\n     }\n \n public:\n-    template <typename ScalarOrVector>\n+    template <class Data, class Target>\n     static void vector(\n-        const PaddedPODArray<T> & data, const ColumnArray::Offsets & offsets,\n-        const ScalarOrVector & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data,\n-        const PaddedPODArray<UInt8> * null_map_item)\n+        const Data & data,\n+        const ArrOffsets & offsets,\n+        const Target & value,\n+        ResultArr & result,\n+        const NullMap * const null_map_data,\n+        const NullMap * const null_map_item)\n     {\n-        /// Processing is split into 4 cases.\n         if (!null_map_data && !null_map_item)\n-            vectorCase1(data, offsets, value, result);\n+            process<1>(data, offsets, value, result, null_map_data, null_map_item);\n         else if (!null_map_data && null_map_item)\n-            vectorCase2(data, offsets, value, result, *null_map_item);\n+            process<2>(data, offsets, value, result, null_map_data, null_map_item);\n         else if (null_map_data && !null_map_item)\n-            vectorCase3(data, offsets, value, result, *null_map_data);\n+            process<3>(data, offsets, value, result, null_map_data, null_map_item);\n         else\n-            vectorCase4(data, offsets, value, result, *null_map_data, *null_map_item);\n+            process<4>(data, offsets, value, result, null_map_data, null_map_item);\n     }\n };\n \n-\n-/// Implementation for arrays of numbers when the 2nd function argument\n-/// is a NULL value.\n-template <typename T, typename IndexConv>\n-struct ArrayIndexNumNullImpl\n+/// When the 2nd function argument is a NULL value.\n+template <class ConcreteAction>\n+struct Null\n {\n-    static void vector(\n-        const PaddedPODArray<T> & /*data*/, const ColumnArray::Offsets & offsets,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data)\n+    using ResultType = typename ConcreteAction::ResultType;\n+\n+    static void process(\n+        const ColumnArray::Offsets & offsets,\n+        PaddedPODArray<ResultType> & result,\n+        [[maybe_unused]] const NullMap * null_map_data)\n     {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+        const size_t size = offsets.size();\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        if (!null_map_data)\n         {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n-\n-            for (size_t j = 0; j < array_size; ++j)\n-            {\n-                if (null_map_data && (*null_map_data)[current_offset + j])\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n-\n-            result[i] = current;\n-            current_offset = offsets[i];\n+            result.resize_fill(size);\n+            return;\n         }\n-    }\n-};\n \n-/// Implementation for arrays of strings when the 2nd function argument is a NULL value.\n-template <typename IndexConv>\n-struct ArrayIndexStringNullImpl\n-{\n-    static void vector_const(\n-        const ColumnString::Chars & /*data*/, const ColumnArray::Offsets & offsets, const ColumnString::Offsets & /*string_offsets*/,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data)\n-    {\n-        const auto size = offsets.size();\n         result.resize(size);\n \n         ColumnArray::Offset current_offset = 0;\n+\n         for (size_t i = 0; i < size; ++i)\n         {\n-            const auto array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+            ResultType current = 0;\n+            const size_t array_size = offsets[i] - current_offset;\n \n             for (size_t j = 0; j < array_size; ++j)\n             {\n-                if (null_map_data && (*null_map_data)[current_offset + j])\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n+                if (!(*null_map_data)[current_offset + j])\n+                    continue;\n+\n+                ConcreteAction::apply(current, j);\n+\n+                if constexpr (!ConcreteAction::resume_execution)\n+                    break;\n             }\n \n             result[i] = current;\n@@ -292,40 +227,84 @@ struct ArrayIndexStringNullImpl\n     }\n };\n \n-template <typename IndexConv>\n-struct ArrayIndexStringImpl\n+template <class ConcreteAction>\n+struct String\n {\n-    static void vector_const(\n-        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets, const ColumnString::Offsets & string_offsets,\n-        const ColumnString::Chars & value, ColumnString::Offset value_size,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data)\n+private:\n+    using Offset = ColumnString::Offset;\n+    template <bool IsConst> using OffsetT = std::conditional_t<IsConst, Offset, const ColumnString::Offsets &>;\n+    using ArrayOffset = ColumnArray::Offset;\n+    using ResultType = typename ConcreteAction::ResultType;\n+\n+    template <bool IsConst, bool HasNullMapData, bool HasNullMapItem>\n+    static void processImpl(\n+        const ColumnString::Chars & data,\n+        const ColumnArray::Offsets & offsets,\n+        const ColumnString::Offsets & string_offsets,\n+        const ColumnString::Chars & item_values,\n+        OffsetT<IsConst> item_offsets,\n+        PaddedPODArray<ResultType> & result,\n+        [[maybe_unused]] const NullMap * data_map,\n+        [[maybe_unused]] const NullMap * item_map)\n     {\n-        const auto size = offsets.size();\n+        const size_t size = offsets.size();\n+\n         result.resize(size);\n \n-        ColumnArray::Offset current_offset = 0;\n+        ArrayOffset current_offset = 0;\n+\n         for (size_t i = 0; i < size; ++i)\n         {\n-            const auto array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+            const ArrayOffset array_size = offsets[i] - current_offset;\n+\n+            [[maybe_unused]] Offset value_pos = 0;\n+            [[maybe_unused]] Offset value_size = 0;\n+\n+            if constexpr (!IsConst) // workaround because ?: ternary operator is not constexpr\n+            {\n+                if (0 != i) value_pos = item_offsets[i - 1];\n+                value_size = item_offsets[i] - value_pos;\n+            }\n+\n+            ResultType current = 0;\n \n             for (size_t j = 0; j < array_size; ++j)\n             {\n-                ColumnArray::Offset string_pos = current_offset == 0 && j == 0\n+                const ArrayOffset string_pos = current_offset + j == 0\n                     ? 0\n                     : string_offsets[current_offset + j - 1];\n \n-                ColumnArray::Offset string_size = string_offsets[current_offset + j] - string_pos - 1;\n+                const ArrayOffset string_size = string_offsets[current_offset + j] - string_pos - IsConst * 1;\n \n-                if (null_map_data && (*null_map_data)[current_offset + j])\n+                if constexpr (IsConst)\n                 {\n+                    if constexpr (HasNullMapData)\n+                        if ((*data_map)[current_offset + j])\n+                            continue;\n+\n+                    if (!memequalSmallAllowOverflow15(item_values.data(), item_offsets, &data[string_pos], string_size))\n+                        continue;\n                 }\n-                else if (memequalSmallAllowOverflow15(value.data(), value_size, &data[string_pos], string_size))\n+                else if constexpr (HasNullMapData)\n                 {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n+                    if ((*data_map)[current_offset + j])\n+                    {\n+                        if constexpr (!HasNullMapItem)\n+                            continue;\n+\n+                        if (!(*item_map)[i])\n+                            continue;\n+                    }\n+                    else if (!memequalSmallAllowOverflow15(&item_values[value_pos], value_size, &data[string_pos], string_size))\n+                        continue;\n                 }\n+                else if (!memequalSmallAllowOverflow15(&item_values[value_pos], value_size, &data[string_pos], string_size))\n+                    continue;\n+\n+                ConcreteAction::apply(current, j);\n+\n+                if constexpr (!ConcreteAction::resume_execution)\n+                    break;\n             }\n \n             result[i] = current;\n@@ -333,439 +312,690 @@ struct ArrayIndexStringImpl\n         }\n     }\n \n-    static void vectorVector(\n-        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets, const ColumnString::Offsets & string_offsets,\n-        const ColumnString::Chars & item_values, const ColumnString::Offsets & item_offsets,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data,\n-        const PaddedPODArray<UInt8> * null_map_item)\n+    template <bool IsConst>\n+    static inline void invokeCheckNullMaps(\n+        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets,\n+        const ColumnString::Offsets & str_offsets, const ColumnString::Chars & values,\n+        OffsetT<IsConst> item_offsets,\n+        PaddedPODArray<ResultType> & result, const NullMap * data_map, const NullMap * item_map)\n     {\n-        const auto size = offsets.size();\n-        result.resize(size);\n+        if (data_map && item_map)\n+            processImpl<IsConst, true, true>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);\n+        else if (data_map)\n+            processImpl<IsConst, true, false>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);\n+        else if (item_map)\n+            processImpl<IsConst, false, true>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);\n+        else\n+            processImpl<IsConst, false, false>(data, offsets, str_offsets, values, item_offsets, result, data_map, item_map);\n+    }\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            const auto array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n-            const auto value_pos = 0 == i ? 0 : item_offsets[i - 1];\n-            const auto value_size = item_offsets[i] - value_pos;\n+public:\n+    static inline void process(\n+        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets,\n+        const ColumnString::Offsets & string_offsets, const ColumnString::Chars & item_values,\n+        Offset item_offsets, PaddedPODArray<ResultType> & result,\n+        const NullMap * data_map, const NullMap * item_map)\n+    {\n+        invokeCheckNullMaps<true>(data, offsets, string_offsets, item_values, item_offsets, result, data_map, item_map);\n+    }\n \n-            for (size_t j = 0; j < array_size; ++j)\n-            {\n-                ColumnArray::Offset string_pos = current_offset == 0 && j == 0\n-                    ? 0\n-                    : string_offsets[current_offset + j - 1];\n+    static inline void process(\n+        const ColumnString::Chars & data, const ColumnArray::Offsets & offsets,\n+        const ColumnString::Offsets & string_offsets, const ColumnString::Chars & item_values,\n+        const ColumnString::Offsets & item_offsets, PaddedPODArray<ResultType> & result,\n+        const NullMap * data_map, const NullMap * item_map)\n+    {\n+        invokeCheckNullMaps<false>(data, offsets, string_offsets, item_values, item_offsets, result, data_map, item_map);\n+    }\n+};\n+}\n \n-                ColumnArray::Offset string_size = string_offsets[current_offset + j] - string_pos;\n+template <class ConcreteAction, class Name>\n+class FunctionArrayIndex : public IFunction\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionArrayIndex>(); }\n \n-                bool hit = false;\n+    /// Get function name.\n+    String getName() const override { return name; }\n \n-                if (null_map_data && (*null_map_data)[current_offset + j])\n-                {\n-                    if (null_map_item && (*null_map_item)[i])\n-                        hit = true;\n-                }\n-                else if (memequalSmallAllowOverflow15(&item_values[value_pos], value_size, &data[string_pos], string_size))\n-                    hit = true;\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n \n-                if (hit)\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+    size_t getNumberOfArguments() const override { return 2; }\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n-        }\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[0].get());\n+\n+        if (!array_type)\n+            throw Exception(\"First argument for function \" + getName() + \" must be an array.\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        if (!arguments[1]->onlyNull() && !allowArguments(array_type->getNestedType(), arguments[1]))\n+            throw Exception(\"Types of array and 2nd argument of function \\\"\"\n+                + getName() + \"\\\" must be identical up to nullability, cardinality, \"\n+                \"numeric types, or Enum and numeric type. Passed: \"\n+                + arguments[0]->getName() + \" and \" + arguments[1]->getName() + \".\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeNumber<ResultType>>();\n     }\n-};\n \n-/// Catch-all implementation for arrays of arbitrary type.\n-/// To compare with constant value, create non-constant column with single element,\n-/// and pass is_value_has_single_element_to_compare = true.\n-template <typename IndexConv, bool is_value_has_single_element_to_compare>\n-struct ArrayIndexGenericImpl\n-{\n-private:\n-    /// Both function arguments are ordinary.\n-    static void vectorCase1(\n-        const IColumn & data, const ColumnArray::Offsets & offsets,\n-        const IColumn & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result)\n+    /**\n+      * If one or both arguments passed to this function are nullable,\n+      * we create a new block that contains non-nullable arguments:\n+      *\n+      * - if the 1st argument is a non-constant array of nullable values,\n+      * it is turned into a non-constant array of ordinary values + a null\n+      * byte map;\n+      * - if the 2nd argument is a nullable value, it is turned into an\n+      * ordinary value + a null byte map.\n+      *\n+      * Note that since constant arrays have quite a specific structure\n+      * (they are vectors of Fields, which may represent the NULL value),\n+      * they do not require any preprocessing.\n+      */\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) const override\n     {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+        ColumnPtr& ptr = block.getByPosition(arguments[0]).column;\n+\n+        /**\n+         * The columns here have two general cases, either being Array(T) or Const(Array(T)).\n+         * The last type will return nullptr after casting to ColumnArray, so we leave the casting\n+         * to execute* functions.\n+         */\n+        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(ptr.get());\n+        const ColumnNullable * nullable = nullptr;\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        if (col_array)\n+            nullable = checkAndGetColumn<ColumnNullable>(col_array->getData());\n+\n+        auto & arg_column = block.getByPosition(arguments[1]).column;\n+        const ColumnNullable * arg_nullable = checkAndGetColumn<ColumnNullable>(*arg_column);\n+\n+        if (!nullable && !arg_nullable)\n+            executeOnNonNullable(block, arguments, result);\n+        else\n         {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+            /**\n+             * To correctly process the Nullable values (either #col_array, #arg_column or both) we create a new block\n+             * and operate on it. The block structure follows:\n+             * {0, 1, 2, 3, 4}\n+             * {data (array) argument, \"value\" argument, data null map, \"value\" null map, function result}.\n+             */\n+            Block source_block = { {}, {}, {}, {}, {nullptr, block.getByPosition(result).type, \"\"} };\n \n-            for (size_t j = 0; j < array_size; ++j)\n+            if (nullable)\n             {\n-                if (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1))\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+                const auto & nested_col = nullable->getNestedColumnPtr();\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n-        }\n-    }\n+                auto & data = source_block.getByPosition(0);\n \n-    /// The 2nd function argument is nullable.\n-    static void vectorCase2(\n-        const IColumn & data, const ColumnArray::Offsets & offsets,\n-        const IColumn & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> & null_map_item)\n-    {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+                data.column = ColumnArray::create(nested_col, col_array->getOffsetsPtr());\n+                data.type = std::make_shared<DataTypeArray>(\n+                    static_cast<const DataTypeNullable &>(\n+                        *static_cast<const DataTypeArray &>(\n+                            *block.getByPosition(arguments[0]).type\n+                        ).getNestedType()\n+                    ).getNestedType());\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+                auto & null_map = source_block.getByPosition(2);\n \n-            for (size_t j = 0; j < array_size; ++j)\n+                null_map.column = nullable->getNullMapColumnPtr();\n+                null_map.type = std::make_shared<DataTypeUInt8>();\n+            }\n+            else\n             {\n-                if ((null_map_item[i] == 0) &&\n-                    (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1)))\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n+                auto & data = source_block.getByPosition(0);\n+                data = block.getByPosition(arguments[0]);\n             }\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n+            if (arg_nullable)\n+            {\n+                auto & arg = source_block.getByPosition(1);\n+                arg.column = arg_nullable->getNestedColumnPtr();\n+                arg.type =\n+                    static_cast<const DataTypeNullable &>(\n+                        *block.getByPosition(arguments[1]).type\n+                    ).getNestedType();\n+\n+                auto & null_map = source_block.getByPosition(3);\n+                null_map.column = arg_nullable->getNullMapColumnPtr();\n+                null_map.type = std::make_shared<DataTypeUInt8>();\n+            }\n+            else\n+            {\n+                auto & arg = source_block.getByPosition(1);\n+                arg = block.getByPosition(arguments[1]);\n+            }\n+\n+            /// Now perform the function.\n+            executeOnNonNullable(source_block, {0, 1, 2, 3}, 4);\n+\n+            /// Move the result to its final position.\n+            const ColumnWithTypeAndName & source_col = source_block.getByPosition(4);\n+            ColumnWithTypeAndName & dest_col = block.getByPosition(result);\n+            dest_col.column = std::move(source_col.column);\n         }\n     }\n \n-    /// The 1st function argument is a non-constant array of nullable values.\n-    static void vectorCase3(\n-        const IColumn & data, const ColumnArray::Offsets & offsets,\n-        const IColumn & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> & null_map_data)\n+private:\n+    using ResultType = typename ConcreteAction::ResultType;\n+    using ResultColumnType = ColumnVector<ResultType>;\n+    using ResultColumnPtr = decltype(ResultColumnType::create());\n+\n+    using NullMaps = std::pair<const NullMap *, const NullMap *>;\n+\n+    struct ExecutionData\n     {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+        const IColumn& left;\n+        const IColumn& right;\n+        const ColumnArray::Offsets& offsets;\n+        Block & block;\n+        size_t result_pos;\n+        NullMaps maps;\n+        ResultColumnPtr result { ResultColumnType::create() };\n+\n+        inline void move_result() { block.getByPosition(result_pos).column = std::move(result); }\n+    };\n+\n+    static inline bool allowNested(const DataTypePtr & left, const DataTypePtr & right)\n+    {\n+        return ((isNativeNumber(left) || isEnum(left)) && isNativeNumber(right)) || left->equals(*right);\n+    }\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+    static inline bool allowArguments(const DataTypePtr & array_inner_type, const DataTypePtr & arg)\n+    {\n+        if (allowNested(array_inner_type, arg))\n+            return true;\n \n-            for (size_t j = 0; j < array_size; ++j)\n-            {\n-                if (null_map_data[current_offset + j])\n-                {\n-                }\n-                else if (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1))\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+        /// Nullable\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n+        const bool array_is_nullable = array_inner_type->isNullable();\n+        const bool arg_is_nullable = arg->isNullable();\n+\n+        const DataTypePtr arg_or_arg_nullable_nested = arg_is_nullable\n+            ? checkAndGetDataType<DataTypeNullable>(arg.get())->getNestedType()\n+            : arg;\n+\n+        if (array_is_nullable) // comparing Array(Nullable(T)) elem and U\n+        {\n+            const DataTypePtr array_nullable_nested =\n+                checkAndGetDataType<DataTypeNullable>(array_inner_type.get())->getNestedType();\n+\n+            return allowNested(\n+                    array_nullable_nested,\n+                    arg_or_arg_nullable_nested);\n         }\n-    }\n+        else if (arg_is_nullable) // cannot compare Array(T) elem (namely, T) and Nullable(T)\n+            return false;\n \n-    /// The 1st function argument is a non-constant array of nullable values.\n-    /// The 2nd function argument is nullable.\n-    static void vectorCase4(\n-        const IColumn & data, const ColumnArray::Offsets & offsets,\n-        const IColumn & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> & null_map_data,\n-        const PaddedPODArray<UInt8> & null_map_item)\n-    {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+        /// LowCardinality\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+        const auto * const array_lc_ptr = checkAndGetDataType<DataTypeLowCardinality>(array_inner_type.get());\n+        const auto * const arg_lc_ptr = checkAndGetDataType<DataTypeLowCardinality>(arg.get());\n+\n+        const DataTypePtr array_lc_inner_type = recursiveRemoveLowCardinality(array_inner_type);\n+        const DataTypePtr arg_lc_inner_type = recursiveRemoveLowCardinality(arg);\n+\n+        const bool array_is_lc = nullptr != array_lc_ptr;\n+        const bool arg_is_lc = nullptr != arg_lc_ptr;\n+\n+        const bool array_lc_inner_type_is_nullable = array_is_lc && array_lc_inner_type->isNullable();\n+        const bool arg_lc_inner_type_is_nullable = arg_is_lc && arg_lc_inner_type->isNullable();\n+\n+        if (array_is_lc) // comparing LC(T) and U\n         {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n+            const DataTypePtr array_lc_nested_or_lc_nullable_nested = array_lc_inner_type_is_nullable\n+                ? checkAndGetDataType<DataTypeNullable>(array_lc_inner_type.get())->getNestedType()\n+                : array_lc_inner_type;\n \n-            for (size_t j = 0; j < array_size; ++j)\n+            if (arg_is_lc) // comparing LC(T) and LC(U)\n             {\n-                bool hit = false;\n-                if (null_map_data[current_offset + j])\n-                {\n-                    if (null_map_item[i])\n-                        hit = true;\n-                }\n-                else if (0 == data.compareAt(current_offset + j, is_value_has_single_element_to_compare ? 0 : i, value, 1))\n-                        hit = true;\n+                const DataTypePtr arg_lc_nested_or_lc_nullable_nested = arg_lc_inner_type_is_nullable\n+                    ? checkAndGetDataType<DataTypeNullable>(arg_lc_inner_type.get())->getNestedType()\n+                    : arg_lc_inner_type;\n \n-                if (hit)\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n+                return allowNested(\n+                        array_lc_nested_or_lc_nullable_nested,\n+                        arg_lc_nested_or_lc_nullable_nested);\n+            }\n+            else if (arg_is_nullable) // Comparing LC(T) and Nullable(U)\n+            {\n+                if (!array_lc_inner_type_is_nullable)\n+                    return false; // Can't compare Array(LC(U)) elem and Nullable(T);\n+\n+                return allowNested(\n+                        array_lc_nested_or_lc_nullable_nested,\n+                        arg_or_arg_nullable_nested);\n             }\n+            else // Comparing LC(T) and U (U neither Nullable nor LC)\n+                return allowNested(array_lc_nested_or_lc_nullable_nested, arg);\n         }\n-    }\n \n-public:\n-    static void vector(\n-        const IColumn & data, const ColumnArray::Offsets & offsets,\n-        const IColumn & value,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data,\n-        const PaddedPODArray<UInt8> * null_map_item)\n-    {\n-        /// Processing is split into 4 cases.\n-        if (!null_map_data && !null_map_item)\n-            vectorCase1(data, offsets, value, result);\n-        else if (!null_map_data && null_map_item)\n-            vectorCase2(data, offsets, value, result, *null_map_item);\n-        else if (null_map_data && !null_map_item)\n-            vectorCase3(data, offsets, value, result, *null_map_data);\n-        else\n-            vectorCase4(data, offsets, value, result, *null_map_data, *null_map_item);\n+        return false;\n     }\n-};\n \n-/// Catch-all implementation for arrays of arbitrary type\n-/// when the 2nd function argument is a NULL value.\n-template <typename IndexConv>\n-struct ArrayIndexGenericNullImpl\n-{\n-    static void vector(\n-        const IColumn & /*data*/, const ColumnArray::Offsets & offsets,\n-        PaddedPODArray<typename IndexConv::ResultType> & result,\n-        const PaddedPODArray<UInt8> * null_map_data)\n-    {\n-        size_t size = offsets.size();\n-        result.resize(size);\n+#define INTEGRAL_TPL_PACK UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64\n \n-        ColumnArray::Offset current_offset = 0;\n-        for (size_t i = 0; i < size; ++i)\n+    void executeOnNonNullable(Block & block, const ColumnNumbers & arguments, size_t result) const\n+    {\n+        if (const auto* const left_arr = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get()))\n         {\n-            size_t array_size = offsets[i] - current_offset;\n-            typename IndexConv::ResultType current = 0;\n-\n-            for (size_t j = 0; j < array_size; ++j)\n+            if (checkAndGetColumn<ColumnLowCardinality>(&left_arr->getData()))\n             {\n-                if (null_map_data && (*null_map_data)[current_offset + j])\n-                {\n-                    if (!IndexConv::apply(j, current))\n-                        break;\n-                }\n-            }\n+                if (executeLowCardinality(block, arguments, result))\n+                    return;\n \n-            result[i] = current;\n-            current_offset = offsets[i];\n+                throw Exception(\n+                    \"Illegal internal type of first argument of function \" + getName(),\n+                    ErrorCodes::ILLEGAL_COLUMN);\n+            }\n         }\n-    }\n-};\n \n+        if (!(executeIntegral<INTEGRAL_TPL_PACK>(block, arguments, result)\n+              || executeConst(block, arguments, result)\n+              || executeString(block, arguments, result)\n+              || executeGeneric(block, arguments, result)))\n+            throw Exception(\n+                \"Illegal internal type of first argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_COLUMN);\n+    }\n \n-inline bool allowArrayIndex(const DataTypePtr & type0, const DataTypePtr & type1)\n-{\n-    DataTypePtr data_type0 = removeNullable(type0);\n-    DataTypePtr data_type1 = removeNullable(type1);\n+    /**\n+     * The Array's internal data type may be quite tricky (containing a Nullable type somewhere). To process the\n+     * Nullable types correctly, for each data type specialisation we provide two null maps (one for the data and one\n+     * for the items). By convention they are passed as the third and the fourth argument, respectively\n+     * (counting from 1).\n+     *\n+     * @return {nullptr, nullptr} if there are less than 3 arguments.\n+     * @return {null_map_data, nullptr} if there are three arguments\n+     * @return {nullptr, null_map_item} if there are four arguments but the third is missing.\n+     * @return {null_map_data, null_map_item} if there are four arguments.\n+     */\n+    static NullMaps getNullMaps(const Block & block, const ColumnNumbers & arguments) noexcept\n+    {\n+        if (arguments.size() < 3)\n+            return {nullptr, nullptr};\n \n-    return ((isNativeNumber(data_type0) || isEnum(data_type0)) && isNativeNumber(data_type1))\n-        || data_type0->equals(*data_type1);\n-}\n+        const NullMap * null_map_data = nullptr;\n+        const NullMap * null_map_item = nullptr;\n \n+        if (const auto & data_map = block.getByPosition(arguments[2]).column; data_map)\n+            null_map_data = &assert_cast<const ColumnUInt8 &>(*data_map).getData();\n \n-template <typename IndexConv, typename Name>\n-class FunctionArrayIndex : public IFunction\n-{\n-public:\n-    static constexpr auto name = Name::name;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionArrayIndex>(); }\n-\n-private:\n-    using ResultColumnType = ColumnVector<typename IndexConv::ResultType>;\n+        if (const auto & item_map = block.getByPosition(arguments[3]).column; item_map)\n+            null_map_item = &assert_cast<const ColumnUInt8 &>(*item_map).getData();\n \n-    template <typename T>\n-    bool executeNumber(Block & block, const ColumnNumbers & arguments, size_t result) const\n-    {\n-        return executeNumberNumber<T, UInt8>(block, arguments, result)\n-            || executeNumberNumber<T, UInt16>(block, arguments, result)\n-            || executeNumberNumber<T, UInt32>(block, arguments, result)\n-            || executeNumberNumber<T, UInt64>(block, arguments, result)\n-            || executeNumberNumber<T, Int8>(block, arguments, result)\n-            || executeNumberNumber<T, Int16>(block, arguments, result)\n-            || executeNumberNumber<T, Int32>(block, arguments, result)\n-            || executeNumberNumber<T, Int64>(block, arguments, result)\n-            || executeNumberNumber<T, Float32>(block, arguments, result)\n-            || executeNumberNumber<T, Float64>(block, arguments, result);\n+        return {null_map_data, null_map_item};\n     }\n \n-    template <typename T, typename U>\n-    bool executeNumberNumber(Block & block, const ColumnNumbers & arguments, size_t result) const\n+    /**\n+     * Given a variadic pack #Integral, apply executeIntegralExpanded with such parameters:\n+     * Integral s = {s1, s2, ...}\n+     * (s1, s1, s2, ...), (s2, s1, s2, ...), (s3, s1, s2, ...)\n+     */\n+    template <class ...Integral>\n+    static inline bool executeIntegral(Block & block, const ColumnNumbers & arguments, size_t result_pos)\n     {\n-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n+        const ColumnArray * const left = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n \n-        if (!col_array)\n+        if (!left)\n             return false;\n \n-        const ColumnVector<T> * col_nested = checkAndGetColumn<ColumnVector<T>>(&col_array->getData());\n+        const IColumn& right = *block.getByPosition(arguments[1]).column.get();\n \n-        if (!col_nested)\n-            return false;\n+        ExecutionData data = {\n+            left->getData(),\n+            right,\n+            left->getOffsets(),\n+            block,\n+            result_pos,\n+            getNullMaps(block, arguments)\n+        };\n \n-        auto col_res = ResultColumnType::create();\n+        return executeIntegral<Integral...>(data);\n+    }\n \n-        /// Null maps of the 1st and second function arguments,\n-        /// if it applies.\n-        const PaddedPODArray<UInt8> * null_map_data = nullptr;\n-        const PaddedPODArray<UInt8> * null_map_item = nullptr;\n+    template <class ...Integral>\n+    static inline bool executeIntegral(ExecutionData& data)\n+    {\n+        return (executeIntegralExpanded<Integral, Integral...>(data) || ...);\n+    }\n \n-        if (arguments.size() > 2)\n-        {\n-            const auto & null_map1 = block.getByPosition(arguments[2]).column;\n-            if (null_map1)\n-                null_map_data = &assert_cast<const ColumnUInt8 &>(*null_map1).getData();\n+    /// Invoke executeIntegralImpl with such parameters: (A, other1), (A, other2), ...\n+    template <class A, class ...Other>\n+    static inline bool executeIntegralExpanded(ExecutionData& data)\n+    {\n+        return (executeIntegralImpl<A, Other>(data) || ...);\n+    }\n \n-            const auto & null_map2 = block.getByPosition(arguments[3]).column;\n-            if (null_map2)\n-                null_map_item = &assert_cast<const ColumnUInt8 &>(*null_map2).getData();\n-        }\n+    /**\n+     * The internal data type of the first argument (target array), if it's integral, like UInt8, may differ from the\n+     * second argument, namely, the @e value, so it's possible to invoke the <tt>has(Array(Int8), UInt64)</tt> e.g.\n+     * so we have to check all possible variants for #Initial and #Resulting types.\n+     */\n+    template <class Initial, class Resulting>\n+    static bool executeIntegralImpl(ExecutionData& data)\n+    {\n+        const ColumnVector<Initial> * col_nested = checkAndGetColumn<ColumnVector<Initial>>(&data.left);\n+\n+        if (!col_nested)\n+            return false;\n \n-        const auto item_arg = block.getByPosition(arguments[1]).column.get();\n-\n-        if (item_arg->onlyNull())\n-            ArrayIndexNumNullImpl<T, IndexConv>::vector(col_nested->getData(), col_array->getOffsets(),\n-                col_res->getData(), null_map_data);\n-        else if (const auto item_arg_const = checkAndGetColumnConst<ColumnVector<U>>(item_arg))\n-            ArrayIndexNumImpl<T, U, IndexConv>::vector(col_nested->getData(), col_array->getOffsets(),\n-                item_arg_const->template getValue<U>(), col_res->getData(), null_map_data, nullptr);\n-        else if (const auto item_arg_vector = checkAndGetColumn<ColumnVector<U>>(item_arg))\n-            ArrayIndexNumImpl<T, U, IndexConv>::vector(col_nested->getData(), col_array->getOffsets(),\n-                item_arg_vector->getData(), col_res->getData(), null_map_data, null_map_item);\n+        const auto [null_map_data, null_map_item] = data.maps;\n+\n+        if (data.right.onlyNull())\n+            Impl::Null<ConcreteAction>::process(\n+                data.offsets,\n+                data.result->getData(),\n+                null_map_data);\n+        else if (const auto item_arg_const = checkAndGetColumnConst<ColumnVector<Resulting>>(&data.right))\n+            Impl::Main<ConcreteAction, true, Initial, Resulting>::vector(\n+                col_nested->getData(),\n+                data.offsets,\n+                item_arg_const->template getValue<Resulting>(),\n+                data.result->getData(),\n+                null_map_data,\n+                nullptr);\n+        else if (const auto item_arg_vector = checkAndGetColumn<ColumnVector<Resulting>>(&data.right))\n+            Impl::Main<ConcreteAction, false, Initial, Resulting>::vector(\n+                col_nested->getData(),\n+                data.offsets,\n+                item_arg_vector->getData(),\n+                data.result->getData(),\n+                null_map_data,\n+                null_map_item);\n         else\n             return false;\n \n-        block.getByPosition(result).column = std::move(col_res);\n+        data.move_result();\n         return true;\n     }\n \n-    bool executeString(Block & block, const ColumnNumbers & arguments, size_t result) const\n+    /**\n+     * Catches arguments of type LC(T) (left) and U (right).\n+     *\n+     * The perftests\n+     * https://clickhouse-test-reports.s3.yandex.net/12550/2d27fa0fa8c198a82bf1fe3625050ccf56695976/integration_tests_(release).html\n+     * showed that the amount of action needed to convert the non-constant right argument to the index column\n+     * (similar to the left one's) is significantly higher than converting the array itself to an ordinary column.\n+     *\n+     * So, in terms of performance it's more optimal to fall back to default implementation and catch only constant\n+     * right arguments.\n+     *\n+     * Tips and tricks tried can be found at https://github.com/ClickHouse/ClickHouse/pull/12550 .\n+     */\n+    static bool executeLowCardinality(Block & block, const ColumnNumbers & arguments, size_t result)\n     {\n-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n+        const ColumnArray * const col_array = checkAndGetColumn<ColumnArray>(\n+                block.getByPosition(arguments[0]).column.get());\n \n         if (!col_array)\n             return false;\n \n-        const ColumnString * col_nested = checkAndGetColumn<ColumnString>(&col_array->getData());\n+        const ColumnLowCardinality * const col_lc = checkAndGetColumn<ColumnLowCardinality>(&col_array->getData());\n \n-        if (!col_nested)\n+        if (!col_lc)\n             return false;\n \n-        auto col_res = ResultColumnType::create();\n+        const auto [null_map_data, null_map_item] = getNullMaps(block, arguments);\n \n-        /// Null maps of the 1st and second function arguments,\n-        /// if it applies.\n-        const PaddedPODArray<UInt8> * null_map_data = nullptr;\n-        const PaddedPODArray<UInt8> * null_map_item = nullptr;\n+        const IColumn& col_arg = *block.getByPosition(arguments[1]).column.get();\n \n-        if (arguments.size() > 2)\n+        if (const ColumnConst * const col_arg_const = checkAndGetColumn<ColumnConst>(col_arg))\n         {\n-            const auto & col1 = block.getByPosition(arguments[2]).column;\n-            if (col1)\n-                null_map_data = &assert_cast<const ColumnUInt8 &>(*col1).getData();\n+            const IColumnUnique& col_lc_dict = col_lc->getDictionary();\n+\n+            const bool different_inner_types = col_lc_dict.isNullable()\n+                ? !col_arg_const->structureEquals(*col_lc_dict.getNestedColumn().get())\n+                : true; // Can't compare so ignore this check\n \n-            const auto & col2 = block.getByPosition(arguments[3]).column;\n-            if (col2)\n-                null_map_item = &assert_cast<const ColumnUInt8 &>(*col2).getData();\n+            const bool use_cloned_arg = col_arg_const->isNumeric()\n+                // outer types do not match\n+                && !col_arg_const->structureEquals(col_lc_dict)\n+                // inner types do not match (like A and Nullable(B) or A and Const(B));\n+                && different_inner_types;\n+\n+            const DataTypeArray * const array_type = checkAndGetDataType<DataTypeArray>(\n+                    block.getByPosition(arguments[0]).type.get());\n+            const DataTypePtr target_type_ptr = recursiveRemoveLowCardinality(array_type->getNestedType());\n+\n+            const ColumnPtr col_arg_cloned = use_cloned_arg\n+                ? castColumn(block.getByPosition(arguments[1]), target_type_ptr)\n+                : col_arg_const->getPtr();\n+\n+            const StringRef elem = col_arg_cloned->getDataAt(0);\n+            ResultColumnPtr col_result = ResultColumnType::create();\n+\n+            UInt64 index = 0;\n+\n+            if (elem != EMPTY_STRING_REF)\n+            {\n+                if (std::optional<UInt64> maybe_index = col_lc_dict.getOrFindValueIndex(elem); maybe_index)\n+                    index = *maybe_index;\n+                else\n+                {\n+                    const size_t offsets_size = col_array->getOffsets().size();\n+                    auto& data = col_result->getData();\n+\n+                    data.resize_fill(offsets_size);\n+\n+                    block.getByPosition(result).column = std::move(col_result);\n+                    return true;\n+                }\n+            }\n+\n+            Impl::Main<ConcreteAction, true>::vector(\n+                col_lc->getIndexes(),\n+                col_array->getOffsets(),\n+                index,\n+                col_result->getData(),\n+                null_map_data,\n+                null_map_item);\n+\n+            block.getByPosition(result).column = std::move(col_result);\n+            return true;\n         }\n+        else if (col_lc->getDictionaryPtr()->isNullable()) // LC(Nullable(T)) and U\n+        {\n+            const ColumnPtr left_casted = col_lc->convertToFullColumnIfLowCardinality(); // Nullable(T)\n+            const ColumnNullable& left_nullable = *checkAndGetColumn<ColumnNullable>(left_casted.get());\n+\n+            const NullMap * const null_map_left_casted = &left_nullable.getNullMapColumn().getData();\n \n-        const auto item_arg = block.getByPosition(arguments[1]).column.get();\n+            const IColumn& left_ptr = left_nullable.getNestedColumn();\n \n-        if (item_arg->onlyNull())\n+            const ColumnPtr right_casted = col_arg.convertToFullColumnIfLowCardinality();\n+            const ColumnNullable * const right_nullable = checkAndGetColumn<ColumnNullable>(right_casted.get());\n+\n+            const NullMap * const null_map_right_casted = right_nullable\n+                ? &right_nullable->getNullMapColumn().getData()\n+                : null_map_item;\n+\n+            const IColumn& right_ptr = right_nullable\n+                ? right_nullable->getNestedColumn()\n+                : *right_casted.get();\n+\n+            ExecutionData data = {\n+                left_ptr, right_ptr,\n+                col_array->getOffsets(),\n+                block, result,\n+                {null_map_left_casted, null_map_right_casted}};\n+\n+            return dispatchConvertedLCColumns(data);\n+        }\n+        else // LC(T) and U, T not Nullable\n         {\n-            ArrayIndexStringNullImpl<IndexConv>::vector_const(col_nested->getChars(), col_array->getOffsets(),\n-                col_nested->getOffsets(), col_res->getData(), null_map_data);\n+            if (col_arg.isNullable())\n+                return false;\n+\n+            if (const auto* const arg_lc = checkAndGetColumn<ColumnLowCardinality>(&col_arg);\n+                arg_lc && arg_lc->isNullable())\n+                return false;\n+\n+            // LC(T) and U (possibly LC(V))\n+\n+            const ColumnPtr left_casted = col_lc->convertToFullColumnIfLowCardinality();\n+            const ColumnPtr right_casted = col_arg.convertToFullColumnIfLowCardinality();\n+\n+            ExecutionData data = {\n+                *left_casted.get(), *right_casted.get(), col_array->getOffsets(),\n+                block, result, {null_map_data, null_map_item}\n+            };\n+\n+            return dispatchConvertedLCColumns(data);\n         }\n-        else if (const auto item_arg_const = checkAndGetColumnConstStringOrFixedString(item_arg))\n+    }\n+\n+    static bool dispatchConvertedLCColumns(ExecutionData& data)\n+    {\n+        if (data.left.isNumeric() && data.right.isNumeric()) // ColumnArrays\n+            return executeIntegral<INTEGRAL_TPL_PACK>(data);\n+\n+        if (checkAndGetColumn<ColumnString>(&data.left))\n+            return executeStringImpl(data);\n+\n+        Impl::Main<ConcreteAction, true>::vector(\n+            data.left,\n+            data.offsets, data.right,\n+            data.result->getData(),\n+            data.maps.first, data.maps.second);\n+\n+        data.move_result();\n+        return true;\n+    }\n+\n+#undef INTEGRAL_TPL_PACK\n+\n+    static bool executeString(Block & block, const ColumnNumbers & arguments, size_t result_pos)\n+    {\n+        const ColumnArray * array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n+\n+        if (!array)\n+            return false;\n+\n+        const ColumnString * left = checkAndGetColumn<ColumnString>(&array->getData());\n+\n+        if (!left)\n+            return false;\n+\n+        const IColumn & right = *block.getByPosition(arguments[1]).column.get();\n+\n+        ExecutionData data = {\n+            *left, right, array->getOffsets(),\n+            block, result_pos, getNullMaps(block, arguments),\n+            std::move(ResultColumnType::create())\n+        };\n+\n+        return executeStringImpl(data);\n+    }\n+\n+    static bool executeStringImpl(ExecutionData& data)\n+    {\n+        const auto [null_map_data, null_map_item] = data.maps;\n+        const ColumnString& left = *typeid_cast<const ColumnString* const>(&data.left);\n+\n+        if (data.right.onlyNull())\n+            Impl::Null<ConcreteAction>::process(\n+                data.offsets,\n+                data.result->getData(),\n+                null_map_data);\n+        else if (const auto *const item_arg_const = checkAndGetColumnConstStringOrFixedString(&data.right))\n         {\n-            const ColumnString * item_const_string = checkAndGetColumn<ColumnString>(&item_arg_const->getDataColumn());\n-            const ColumnFixedString * item_const_fixedstring = checkAndGetColumn<ColumnFixedString>(&item_arg_const->getDataColumn());\n+            const ColumnString * item_const_string =\n+                checkAndGetColumn<ColumnString>(&item_arg_const->getDataColumn());\n+\n+            const ColumnFixedString * item_const_fixedstring =\n+                checkAndGetColumn<ColumnFixedString>(&item_arg_const->getDataColumn());\n \n             if (item_const_string)\n-                ArrayIndexStringImpl<IndexConv>::vector_const(col_nested->getChars(), col_array->getOffsets(), col_nested->getOffsets(),\n-                    item_const_string->getChars(), item_const_string->getDataAt(0).size,\n-                    col_res->getData(), null_map_data);\n+                Impl::String<ConcreteAction>::process(\n+                    left.getChars(),\n+                    data.offsets,\n+                    left.getOffsets(),\n+                    item_const_string->getChars(),\n+                    item_const_string->getDataAt(0).size,\n+                    data.result->getData(),\n+                    null_map_data,\n+                    null_map_item);\n             else if (item_const_fixedstring)\n-                ArrayIndexStringImpl<IndexConv>::vector_const(col_nested->getChars(), col_array->getOffsets(), col_nested->getOffsets(),\n-                    item_const_fixedstring->getChars(), item_const_fixedstring->getN(),\n-                    col_res->getData(), null_map_data);\n+                Impl::String<ConcreteAction>::process(\n+                    left.getChars(),\n+                    data.offsets,\n+                    left.getOffsets(),\n+                    item_const_fixedstring->getChars(),\n+                    item_const_fixedstring->getN(),\n+                    data.result->getData(),\n+                    null_map_data,\n+                    null_map_item);\n             else\n-                throw Exception(\"Logical error: ColumnConst contains not String nor FixedString column\", ErrorCodes::ILLEGAL_COLUMN);\n+                throw Exception(\n+                    \"Logical error: ColumnConst contains not String nor FixedString column\",\n+                        ErrorCodes::ILLEGAL_COLUMN);\n         }\n-        else if (const auto item_arg_vector = checkAndGetColumn<ColumnString>(item_arg))\n+        else if (const auto *const item_arg_vector = checkAndGetColumn<ColumnString>(&data.right))\n         {\n-            ArrayIndexStringImpl<IndexConv>::vectorVector(col_nested->getChars(), col_array->getOffsets(),\n-                col_nested->getOffsets(), item_arg_vector->getChars(), item_arg_vector->getOffsets(),\n-                col_res->getData(), null_map_data, null_map_item);\n+            Impl::String<ConcreteAction>::process(\n+                left.getChars(),\n+                data.offsets,\n+                left.getOffsets(),\n+                item_arg_vector->getChars(),\n+                item_arg_vector->getOffsets(),\n+                data.result->getData(),\n+                null_map_data,\n+                null_map_item);\n         }\n         else\n             return false;\n \n-        block.getByPosition(result).column = std::move(col_res);\n+        data.move_result();\n         return true;\n     }\n \n-    bool executeConst(Block & block, const ColumnNumbers & arguments, size_t result) const\n+    static bool executeConst(Block & block, const ColumnNumbers & arguments, size_t result)\n     {\n-        const ColumnConst * col_array = checkAndGetColumnConst<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n+        const ColumnConst * col_array = checkAndGetColumnConst<ColumnArray>(\n+                block.getByPosition(arguments[0]).column.get());\n \n         if (!col_array)\n             return false;\n \n         Array arr = col_array->getValue<Array>();\n \n-        const auto item_arg = block.getByPosition(arguments[1]).column.get();\n+        const IColumn * item_arg = block.getByPosition(arguments[1]).column.get();\n+\n         if (isColumnConst(*item_arg))\n         {\n-            typename IndexConv::ResultType current = 0;\n+            ResultType current = 0;\n             const auto & value = (*item_arg)[0];\n \n             for (size_t i = 0, size = arr.size(); i < size; ++i)\n             {\n-                if (applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))\n-                {\n-                    if (!IndexConv::apply(i, current))\n-                        break;\n-                }\n+                if (!applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))\n+                    continue;\n+\n+                ConcreteAction::apply(current, i);\n+\n+                if constexpr (!ConcreteAction::resume_execution)\n+                    break;\n             }\n \n             block.getByPosition(result).column = block.getByPosition(result).type->createColumnConst(\n-                item_arg->size(),\n-                static_cast<typename IndexConv::ResultType>(current));\n+                item_arg->size(), static_cast<ResultType>(current));\n         }\n         else\n         {\n             /// Null map of the 2nd function argument, if it applies.\n-            const PaddedPODArray<UInt8> * null_map = nullptr;\n+            const NullMap * null_map = nullptr;\n \n             if (arguments.size() > 2)\n-            {\n-                const auto & col = block.getByPosition(arguments[3]).column;\n-                if (col)\n+                if (const auto & col = block.getByPosition(arguments[3]).column; col)\n                     null_map = &assert_cast<const ColumnUInt8 &>(*col).getData();\n-            }\n \n-            const auto size = item_arg->size();\n+            const size_t size = item_arg->size();\n             auto col_res = ResultColumnType::create(size);\n \n             auto & data = col_res->getData();\n@@ -775,23 +1005,24 @@ class FunctionArrayIndex : public IFunction\n                 const auto & value = (*item_arg)[row];\n \n                 data[row] = 0;\n+\n                 for (size_t i = 0, arr_size = arr.size(); i < arr_size; ++i)\n                 {\n-                    bool hit = false;\n-\n                     if (arr[i].isNull())\n                     {\n-                        if (null_map && (*null_map)[row])\n-                            hit = true;\n-                    }\n-                    else if (applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))\n-                        hit = true;\n+                        if (!null_map)\n+                            continue;\n \n-                    if (hit)\n-                    {\n-                        if (!IndexConv::apply(i, data[row]))\n-                            break;\n+                        if (!(*null_map)[row])\n+                            continue;\n                     }\n+                    else if (!applyVisitor(FieldVisitorAccurateEquals(), arr[i], value))\n+                        continue;\n+\n+                    ConcreteAction::apply(data[row], i);\n+\n+                    if constexpr (!ConcreteAction::resume_execution)\n+                        break;\n                 }\n             }\n \n@@ -801,208 +1032,44 @@ class FunctionArrayIndex : public IFunction\n         return true;\n     }\n \n-    bool executeGeneric(Block & block, const ColumnNumbers & arguments, size_t result) const\n+    static bool executeGeneric(Block & block, const ColumnNumbers & arguments, size_t result)\n     {\n-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n+        const ColumnArray * col = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n \n-        if (!col_array)\n+        if (!col)\n             return false;\n \n-        const IColumn & col_nested = col_array->getData();\n+        const IColumn & col_nested = col->getData();\n         const IColumn & item_arg = *block.getByPosition(arguments[1]).column;\n \n         auto col_res = ResultColumnType::create();\n \n-        /// Null maps of the 1st and second function arguments,\n-        /// if it applies.\n-        const PaddedPODArray<UInt8> * null_map_data = nullptr;\n-        const PaddedPODArray<UInt8> * null_map_item = nullptr;\n-\n-        if (arguments.size() > 2)\n-        {\n-            const auto & null_map1 = block.getByPosition(arguments[2]).column;\n-            if (null_map1)\n-                null_map_data = &assert_cast<const ColumnUInt8 &>(*null_map1).getData();\n-\n-            const auto & null_map2 = block.getByPosition(arguments[3]).column;\n-            if (null_map2)\n-                null_map_item = &assert_cast<const ColumnUInt8 &>(*null_map2).getData();\n-        }\n+        auto [null_map_data, null_map_item] = getNullMaps(block, arguments);\n \n         if (item_arg.onlyNull())\n-            ArrayIndexGenericNullImpl<IndexConv>::vector(col_nested, col_array->getOffsets(),\n-                col_res->getData(), null_map_data);\n+            Impl::Null<ConcreteAction>::process(\n+                col->getOffsets(),\n+                col_res->getData(),\n+                null_map_data);\n         else if (isColumnConst(item_arg))\n-            ArrayIndexGenericImpl<IndexConv, true>::vector(col_nested, col_array->getOffsets(),\n-                assert_cast<const ColumnConst &>(item_arg).getDataColumn(), col_res->getData(),    /// TODO This is wrong.\n-                null_map_data, nullptr);\n+            Impl::Main<ConcreteAction, true>::vector(\n+                col_nested,\n+                col->getOffsets(),\n+                typeid_cast<const ColumnConst &>(item_arg).getDataColumn(),\n+                col_res->getData(), /// TODO This is wrong.\n+                null_map_data,\n+                nullptr);\n         else\n-        {\n-            ArrayIndexGenericImpl<IndexConv, false>::vector(\n-                col_nested, col_array->getOffsets(), *item_arg.convertToFullColumnIfConst(), col_res->getData(),\n-                null_map_data, null_map_item);\n-        }\n+            Impl::Main<ConcreteAction>::vector(\n+                col_nested,\n+                col->getOffsets(),\n+                item_arg,\n+                col_res->getData(),\n+                null_map_data,\n+                null_map_item);\n \n         block.getByPosition(result).column = std::move(col_res);\n         return true;\n     }\n-\n-\n-public:\n-    /// Get function name.\n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    bool useDefaultImplementationForNulls() const override { return false; }\n-\n-    size_t getNumberOfArguments() const override { return 2; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[0].get());\n-        if (!array_type)\n-            throw Exception(\"First argument for function \" + getName() + \" must be an array.\",\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        if (!arguments[1]->onlyNull())\n-        {\n-            if (!allowArrayIndex(array_type->getNestedType(), arguments[1]))\n-                throw Exception(\"Types of array and 2nd argument of function \"\n-                    + getName() + \" must be identical up to nullability or numeric types or Enum and numeric type. Passed: \"\n-                    + arguments[0]->getName() + \" and \" + arguments[1]->getName() + \".\",\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-\n-        return std::make_shared<DataTypeNumber<typename IndexConv::ResultType>>();\n-    }\n-\n-    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) const override\n-    {\n-        /// If one or both arguments passed to this function are nullable,\n-        /// we create a new block that contains non-nullable arguments:\n-        /// - if the 1st argument is a non-constant array of nullable values,\n-        /// it is turned into a non-constant array of ordinary values + a null\n-        /// byte map;\n-        /// - if the 2nd argument is a nullable value, it is turned into an\n-        /// ordinary value + a null byte map.\n-        /// Note that since constant arrays have quite a specific structure\n-        /// (they are vectors of Fields, which may represent the NULL value),\n-        /// they do not require any preprocessing\n-\n-        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(block.getByPosition(arguments[0]).column.get());\n-\n-        const ColumnNullable * nullable = nullptr;\n-        if (col_array)\n-            nullable = checkAndGetColumn<ColumnNullable>(col_array->getData());\n-\n-        auto & arg_column = block.getByPosition(arguments[1]).column;\n-\n-        const ColumnNullable * arg_nullable = nullptr;\n-        arg_nullable = checkAndGetColumn<ColumnNullable>(*arg_column);\n-\n-        if (!nullable && !arg_nullable)\n-        {\n-            /// Simple case: no nullable values passeded.\n-            perform(block, arguments, result);\n-        }\n-        else\n-        {\n-            /// Template of the block on which we will actually apply the function.\n-            /// Its elements will be filled later.\n-            Block source_block =\n-            {\n-                /// 1st function argument (data)\n-                {\n-                },\n-\n-                /// 2nd function argument\n-                {\n-                },\n-\n-                /// 1st argument null map\n-                {\n-                },\n-\n-                /// 2nd argument null map\n-                {\n-                },\n-\n-                /// Function result.\n-                {\n-                    nullptr,\n-                    block.getByPosition(result).type,\n-                    \"\"\n-                }\n-            };\n-\n-            if (nullable)\n-            {\n-                const auto & nested_col = nullable->getNestedColumnPtr();\n-\n-                auto & data = source_block.getByPosition(0);\n-                data.column = ColumnArray::create(nested_col, col_array->getOffsetsPtr());\n-                data.type = std::make_shared<DataTypeArray>(\n-                    static_cast<const DataTypeNullable &>(\n-                        *static_cast<const DataTypeArray &>(*block.getByPosition(arguments[0]).type).getNestedType()).getNestedType());\n-\n-                auto & null_map = source_block.getByPosition(2);\n-                null_map.column = nullable->getNullMapColumnPtr();\n-                null_map.type = std::make_shared<DataTypeUInt8>();\n-            }\n-            else\n-            {\n-                auto & data = source_block.getByPosition(0);\n-                data = block.getByPosition(arguments[0]);\n-            }\n-\n-            if (arg_nullable)\n-            {\n-                auto & arg = source_block.getByPosition(1);\n-                arg.column = arg_nullable->getNestedColumnPtr();\n-                arg.type = static_cast<const DataTypeNullable &>(*block.getByPosition(arguments[1]).type).getNestedType();\n-\n-                auto & null_map = source_block.getByPosition(3);\n-                null_map.column = arg_nullable->getNullMapColumnPtr();\n-                null_map.type = std::make_shared<DataTypeUInt8>();\n-            }\n-            else\n-            {\n-                auto & arg = source_block.getByPosition(1);\n-                arg = block.getByPosition(arguments[1]);\n-            }\n-\n-            /// Now perform the function.\n-            perform(source_block, {0, 1, 2, 3}, 4);\n-\n-            /// Move the result to its final position.\n-            const ColumnWithTypeAndName & source_col = source_block.getByPosition(4);\n-            ColumnWithTypeAndName & dest_col = block.getByPosition(result);\n-            dest_col.column = std::move(source_col.column);\n-        }\n-    }\n-\n-private:\n-    /// Perform function on the given block. Internal version.\n-    void perform(Block & block, const ColumnNumbers & arguments, size_t result) const\n-    {\n-        if (!(executeNumber<UInt8>(block, arguments, result)\n-            || executeNumber<UInt16>(block, arguments, result)\n-            || executeNumber<UInt32>(block, arguments, result)\n-            || executeNumber<UInt64>(block, arguments, result)\n-            || executeNumber<Int8>(block, arguments, result)\n-            || executeNumber<Int16>(block, arguments, result)\n-            || executeNumber<Int32>(block, arguments, result)\n-            || executeNumber<Int64>(block, arguments, result)\n-            || executeNumber<Float32>(block, arguments, result)\n-            || executeNumber<Float64>(block, arguments, result)\n-            || executeConst(block, arguments, result)\n-            || executeString(block, arguments, result)\n-            || executeGeneric(block, arguments, result)))\n-            throw Exception{\"Illegal column \" + block.getByPosition(arguments[0]).column->getName()\n-                + \" of first argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n-    }\n };\n-\n }\ndiff --git a/src/Functions/array/countEqual.cpp b/src/Functions/array/countEqual.cpp\nindex fd4914e90f40..4c0fc495f389 100644\n--- a/src/Functions/array/countEqual.cpp\n+++ b/src/Functions/array/countEqual.cpp\n@@ -1,18 +1,14 @@\n #include \"arrayIndex.h\"\n #include <Functions/FunctionFactory.h>\n \n-\n namespace DB\n {\n-\n struct NameCountEqual { static constexpr auto name = \"countEqual\"; };\n \n-using FunctionCountEqual = FunctionArrayIndex<IndexCount, NameCountEqual>;\n+using FunctionCountEqual = FunctionArrayIndex<CountEqualAction, NameCountEqual>;\n \n void registerFunctionCountEqual(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionCountEqual>();\n }\n-\n-\n }\ndiff --git a/src/Functions/array/has.cpp b/src/Functions/array/has.cpp\nindex 772facea52d0..1a00c44671e3 100644\n--- a/src/Functions/array/has.cpp\n+++ b/src/Functions/array/has.cpp\n@@ -1,18 +1,12 @@\n #include \"arrayIndex.h\"\n #include <Functions/FunctionFactory.h>\n \n-\n namespace DB\n {\n-\n struct NameHas { static constexpr auto name = \"has\"; };\n \n /// has(arr, x) - whether there is an element x in the array.\n-using FunctionHas = FunctionArrayIndex<IndexToOne, NameHas>;\n-\n-void registerFunctionHas(FunctionFactory & factory)\n-{\n-    factory.registerFunction<FunctionHas>();\n-}\n+using FunctionHas = FunctionArrayIndex<HasAction, NameHas>;\n \n+void registerFunctionHas(FunctionFactory & factory) { factory.registerFunction<FunctionHas>(); }\n }\ndiff --git a/src/Functions/array/indexOf.cpp b/src/Functions/array/indexOf.cpp\nindex d180a9f65d4f..6ab87e6182c4 100644\n--- a/src/Functions/array/indexOf.cpp\n+++ b/src/Functions/array/indexOf.cpp\n@@ -1,19 +1,16 @@\n #include \"arrayIndex.h\"\n #include <Functions/FunctionFactory.h>\n \n-\n namespace DB\n {\n-\n struct NameIndexOf { static constexpr auto name = \"indexOf\"; };\n \n-/// indexOf(arr, x) - returns the index of the element x (starting with 1), if it exists in the array, or 0 if it is not.\n-using FunctionIndexOf = FunctionArrayIndex<IndexIdentity, NameIndexOf>;\n+/// indexOf(arr, x) - returns the index of the element x (starting with 1), if it exists in the array, or 0 if it\n+/// doesn't.\n+using FunctionIndexOf = FunctionArrayIndex<IndexOfAction, NameIndexOf>;\n \n void registerFunctionIndexOf(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionIndexOf>();\n }\n-\n-\n }\n",
  "test_patch": "diff --git a/tests/performance/array_index_low_cardinality_numbers.xml b/tests/performance/array_index_low_cardinality_numbers.xml\nnew file mode 100644\nindex 000000000000..a9f0703c9a88\n--- /dev/null\n+++ b/tests/performance/array_index_low_cardinality_numbers.xml\n@@ -0,0 +1,28 @@\n+<test>\n+    <create_query>DROP TABLE IF EXISTS perf_lc_num</create_query>\n+    <create_query>CREATE TABLE perf_lc_num(\n+        num UInt8,\n+        arr Array(LowCardinality(Int64)) default [num]\n+        ) ENGINE = MergeTree() ORDER BY tuple()\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO perf_lc_num (num)\n+        SELECT toUInt8(number)\n+        FROM numbers(1500000000)\n+    </fill_query>\n+\n+    <query>SELECT count() FROM perf_lc_num WHERE num = 42</query>\n+    <query>SELECT count() FROM perf_lc_num WHERE arr[1] = 42</query>\n+    <query>SELECT count() FROM perf_lc_num WHERE has(arr, 42)</query>\n+    <query>SELECT count() FROM perf_lc_num WHERE indexOf(arr, 42) > 0</query>\n+\n+    <query>SELECT count() FROM perf_lc_num WHERE arr[1] = num</query>\n+    <query>SELECT count() FROM perf_lc_num WHERE has(arr, num)</query>\n+    <query>SELECT count() FROM perf_lc_num WHERE indexOf(arr, num) > 0</query>\n+\n+    <query>SELECT count() FROM perf_lc_num WHERE has(arr, num * 10)</query>\n+    <query>SELECT count() FROM perf_lc_num WHERE has(arr, (num * 1000 + 20) % 137)</query>\n+\n+    <drop_query>DROP TABLE IF EXISTS perf_lc_num</drop_query>\n+</test>\ndiff --git a/tests/performance/array_index_low_cardinality_strings.xml b/tests/performance/array_index_low_cardinality_strings.xml\nnew file mode 100644\nindex 000000000000..bbfea083f0ac\n--- /dev/null\n+++ b/tests/performance/array_index_low_cardinality_strings.xml\n@@ -0,0 +1,29 @@\n+<test>\n+    <create_query>DROP TABLE IF EXISTS perf_lc_str</create_query>\n+    <create_query>CREATE TABLE perf_lc_str(\n+        str LowCardinality(String),\n+        arr Array(LowCardinality(String)) default [str]\n+        ) ENGINE = MergeTree() ORDER BY tuple()\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO perf_lc_str (str)\n+        SELECT concat('asdf', toString(number % 10000))\n+        FROM numbers(100000000)\n+    </fill_query>\n+\n+    <query>SELECT count() FROM perf_lc_str WHERE str = 'asdf337'</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE arr[1] = 'asdf337'</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE has(arr, 'asdf337')</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE indexOf(arr, 'asdf337') > 0</query>\n+\n+    <query>SELECT count() FROM perf_lc_str WHERE arr[1] = str</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE has(arr, str)</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE indexOf(arr, str) > 0</query>\n+\n+    <query>SELECT count() FROM perf_lc_str WHERE has(arr, concat('0', str))</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE has(arr, concat(str, 'str'))</query>\n+    <query>SELECT count() FROM perf_lc_str WHERE has(arr, concat(str, '0'))</query>\n+\n+    <drop_query>DROP TABLE IF EXISTS perf_lc_str</drop_query>\n+</test>\ndiff --git a/tests/queries/0_stateless/00931_low_cardinality_read_with_empty_array.sql b/tests/queries/0_stateless/00931_low_cardinality_read_with_empty_array.sql\nindex a3b90f94f74d..257116fe0f5e 100644\n--- a/tests/queries/0_stateless/00931_low_cardinality_read_with_empty_array.sql\n+++ b/tests/queries/0_stateless/00931_low_cardinality_read_with_empty_array.sql\n@@ -1,7 +1,23 @@\n-drop table if exists lc_00931;\n-create table lc_00931 (key UInt64, value Array(LowCardinality(String))) engine = MergeTree order by key;\n-insert into lc_00931 select number, if(number < 10000 or number > 100000, [toString(number)], emptyArrayString()) from system.numbers limit 200000;\n-select * from lc_00931 where (key < 100 or key > 50000) and not has(value, toString(key)) and length(value) == 1 limit 10 settings max_block_size = 8192, max_threads = 1;\n+DROP TABLE IF EXISTS lc_00931;\n \n-drop table if exists lc_00931;\n+CREATE TABLE lc_00931 (\n+    key UInt64,\n+    value Array(LowCardinality(String)))\n+ENGINE = MergeTree\n+ORDER BY key;\n \n+INSERT INTO lc_00931 SELECT number,\n+if (number < 10000 OR number > 100000,\n+    [toString(number)],\n+    emptyArrayString())\n+    FROM system.numbers LIMIT 200000;\n+\n+SELECT * FROM lc_00931\n+WHERE (key < 100 OR key > 50000)\n+    AND NOT has(value, toString(key))\n+    AND length(value) == 1\n+LIMIT 10\n+SETTINGS max_block_size = 8192,\n+         max_threads = 1;\n+\n+DROP TABLE IF EXISTS lc_00931;\ndiff --git a/tests/queries/0_stateless/00945_bloom_filter_index.sql b/tests/queries/0_stateless/00945_bloom_filter_index.sql\nindex d509b99229ab..083caba710bd 100755\n--- a/tests/queries/0_stateless/00945_bloom_filter_index.sql\n+++ b/tests/queries/0_stateless/00945_bloom_filter_index.sql\n@@ -162,8 +162,47 @@ DROP TABLE IF EXISTS bloom_filter_lc_null_types_test;\n \n DROP TABLE IF EXISTS bloom_filter_array_lc_null_types_test;\n \n-CREATE TABLE bloom_filter_array_lc_null_types_test (order_key   Array(LowCardinality(Nullable((UInt64)))), i8 Array(LowCardinality(Nullable((Int8)))), i16 Array(LowCardinality(Nullable((Int16)))), i32 Array(LowCardinality(Nullable((Int32)))), i64 Array(LowCardinality(Nullable((Int64)))), u8 Array(LowCardinality(Nullable((UInt8)))), u16 Array(LowCardinality(Nullable((UInt16)))), u32 Array(LowCardinality(Nullable((UInt32)))), u64 Array(LowCardinality(Nullable((UInt64)))), f32 Array(LowCardinality(Nullable((Float32)))), f64 Array(LowCardinality(Nullable((Float64)))), date Array(LowCardinality(Nullable((Date)))), date_time Array(LowCardinality(Nullable(DateTime('Europe/Moscow')))), str Array(LowCardinality(Nullable((String)))), fixed_string Array(LowCardinality(Nullable(FixedString(5)))), INDEX idx (i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, date, date_time, str, fixed_string) TYPE bloom_filter GRANULARITY 1) ENGINE = MergeTree() ORDER BY order_key SETTINGS index_granularity = 6;\n-INSERT INTO bloom_filter_array_lc_null_types_test SELECT groupArray(number) AS order_key, groupArray(toInt8(number)) AS i8, groupArray(toInt16(number)) AS i16, groupArray(toInt32(number)) AS i32, groupArray(toInt64(number)) AS i64, groupArray(toUInt8(number)) AS u8, groupArray(toUInt16(number)) AS u16, groupArray(toUInt32(number)) AS u32, groupArray(toUInt64(number)) AS u64, groupArray(toFloat32(number)) AS f32, groupArray(toFloat64(number)) AS f64, groupArray(toDate(number, 'Europe/Moscow')) AS date, groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time, groupArray(toString(number)) AS str, groupArray(toFixedString(toString(number), 5)) AS fixed_string FROM (SELECT number FROM system.numbers LIMIT 15);\n+CREATE TABLE bloom_filter_array_lc_null_types_test (\n+    order_key   Array(LowCardinality(Nullable((UInt64)))),\n+\n+    i8 Array(LowCardinality(Nullable((Int8)))),\n+    i16 Array(LowCardinality(Nullable((Int16)))),\n+    i32 Array(LowCardinality(Nullable((Int32)))),\n+    i64 Array(LowCardinality(Nullable((Int64)))),\n+    u8 Array(LowCardinality(Nullable((UInt8)))),\n+    u16 Array(LowCardinality(Nullable((UInt16)))),\n+    u32 Array(LowCardinality(Nullable((UInt32)))),\n+    u64 Array(LowCardinality(Nullable((UInt64)))),\n+    f32 Array(LowCardinality(Nullable((Float32)))),\n+    f64 Array(LowCardinality(Nullable((Float64)))),\n+\n+    date Array(LowCardinality(Nullable((Date)))),\n+    date_time Array(LowCardinality(Nullable(DateTime('Europe/Moscow')))),\n+\n+    str Array(LowCardinality(Nullable((String)))),\n+    fixed_string Array(LowCardinality(Nullable(FixedString(5)))),\n+    INDEX idx (i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, date, date_time, str, fixed_string)\n+    TYPE bloom_filter GRANULARITY 1)\n+ENGINE = MergeTree() ORDER BY order_key SETTINGS index_granularity = 6;\n+\n+INSERT INTO bloom_filter_array_lc_null_types_test\n+SELECT groupArray(number) AS order_key,\n+    groupArray(toInt8(number)) AS i8,\n+    groupArray(toInt16(number)) AS i16,\n+    groupArray(toInt32(number)) AS i32,\n+    groupArray(toInt64(number)) AS i64,\n+    groupArray(toUInt8(number)) AS u8,\n+    groupArray(toUInt16(number)) AS u16,\n+    groupArray(toUInt32(number)) AS u32,\n+    groupArray(toUInt64(number)) AS u64,\n+    groupArray(toFloat32(number)) AS f32,\n+    groupArray(toFloat64(number)) AS f64,\n+    groupArray(toDate(number, 'Europe/Moscow')) AS date,\n+    groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time,\n+    groupArray(toString(number)) AS str,\n+    groupArray(toFixedString(toString(number), 5)) AS fixed_string\n+    FROM (SELECT number FROM system.numbers LIMIT 15);\n+\n INSERT INTO bloom_filter_array_lc_null_types_test SELECT groupArray(number) AS order_key, groupArray(toInt8(number)) AS i8, groupArray(toInt16(number)) AS i16, groupArray(toInt32(number)) AS i32, groupArray(toInt64(number)) AS i64, groupArray(toUInt8(number)) AS u8, groupArray(toUInt16(number)) AS u16, groupArray(toUInt32(number)) AS u32, groupArray(toUInt64(number)) AS u64, groupArray(toFloat32(number)) AS f32, groupArray(toFloat64(number)) AS f64, groupArray(toDate(number, 'Europe/Moscow')) AS date, groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time, groupArray(toString(number)) AS str, groupArray(toFixedString(toString(number), 5)) AS fixed_string FROM (SELECT number FROM system.numbers WHERE number >= 5 LIMIT 15);\n INSERT INTO bloom_filter_array_lc_null_types_test SELECT groupArray(number) AS order_key, groupArray(toInt8(number)) AS i8, groupArray(toInt16(number)) AS i16, groupArray(toInt32(number)) AS i32, groupArray(toInt64(number)) AS i64, groupArray(toUInt8(number)) AS u8, groupArray(toUInt16(number)) AS u16, groupArray(toUInt32(number)) AS u32, groupArray(toUInt64(number)) AS u64, groupArray(toFloat32(number)) AS f32, groupArray(toFloat64(number)) AS f64, groupArray(toDate(number, 'Europe/Moscow')) AS date, groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time, groupArray(toString(number)) AS str, groupArray(toFixedString(toString(number), 5)) AS fixed_string FROM (SELECT number FROM system.numbers WHERE number >= 10 LIMIT 15);\n INSERT INTO bloom_filter_array_lc_null_types_test SELECT n AS order_key, n AS i8, n AS i16, n AS i32, n AS i64, n AS u8, n AS u16, n AS u32, n AS u64, n AS f32, n AS f64, n AS date, n AS date_time, n AS str, n AS fixed_string FROM (SELECT [NULL] AS n);\ndiff --git a/tests/queries/0_stateless/01414_low_cardinality_nullable.reference b/tests/queries/0_stateless/01414_low_cardinality_nullable.reference\nnew file mode 100644\nindex 000000000000..bf7b6cf4f76f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_low_cardinality_nullable.reference\n@@ -0,0 +1,82 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+3\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01414_low_cardinality_nullable.sql b/tests/queries/0_stateless/01414_low_cardinality_nullable.sql\nnew file mode 100644\nindex 000000000000..6e311f9d519c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_low_cardinality_nullable.sql\n@@ -0,0 +1,220 @@\n+DROP TABLE IF EXISTS lc_nullable;\n+\n+CREATE TABLE lc_nullable (\n+    order_key   Array(LowCardinality(Nullable((UInt64)))),\n+\n+    i8  Array(LowCardinality(Nullable(Int8))),\n+    i16 Array(LowCardinality(Nullable(Int16))),\n+    i32 Array(LowCardinality(Nullable(Int32))),\n+    i64 Array(LowCardinality(Nullable(Int64))),\n+    u8  Array(LowCardinality(Nullable(UInt8))),\n+    u16 Array(LowCardinality(Nullable(UInt16))),\n+    u32 Array(LowCardinality(Nullable(UInt32))),\n+    u64 Array(LowCardinality(Nullable(UInt64))),\n+    f32 Array(LowCardinality(Nullable(Float32))),\n+    f64 Array(LowCardinality(Nullable(Float64))),\n+\n+    date Array(LowCardinality(Nullable((Date)))),\n+    date_time Array(LowCardinality(Nullable(DateTime('Europe/Moscow')))),\n+\n+    str Array(LowCardinality(Nullable((String)))),\n+    fixed_string Array(LowCardinality(Nullable(FixedString(5))))\n+) ENGINE = MergeTree() ORDER BY order_key;\n+\n+INSERT INTO lc_nullable SELECT\n+    groupArray(number) AS order_key,\n+    groupArray(toInt8(number)) AS i8,\n+    groupArray(toInt16(number)) AS i16,\n+    groupArray(toInt32(number)) AS i32,\n+    groupArray(toInt64(number)) AS i64,\n+    groupArray(toUInt8(number)) AS u8,\n+    groupArray(toUInt16(number)) AS u16,\n+    groupArray(toUInt32(number)) AS u32,\n+    groupArray(toUInt64(number)) AS u64,\n+    groupArray(toFloat32(number)) AS f32,\n+    groupArray(toFloat64(number)) AS f64,\n+    groupArray(toDate(number, 'Europe/Moscow')) AS date,\n+    groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time,\n+    groupArray(toString(number)) AS str,\n+    groupArray(toFixedString(toString(number), 5)) AS fixed_string\n+    FROM (SELECT number FROM system.numbers LIMIT 15);\n+\n+INSERT INTO lc_nullable SELECT\n+    groupArray(num) AS order_key,\n+    groupArray(toInt8(num)) AS i8,\n+    groupArray(toInt16(num)) AS i16,\n+    groupArray(toInt32(num)) AS i32,\n+    groupArray(toInt64(num)) AS i64,\n+    groupArray(toUInt8(num)) AS u8,\n+    groupArray(toUInt16(num)) AS u16,\n+    groupArray(toUInt32(num)) AS u32,\n+    groupArray(toUInt64(num)) AS u64,\n+    groupArray(toFloat32(num)) AS f32,\n+    groupArray(toFloat64(num)) AS f64,\n+    groupArray(toDate(num, 'Europe/Moscow')) AS date,\n+    groupArray(toDateTime(num, 'Europe/Moscow')) AS date_time,\n+    groupArray(toString(num)) AS str,\n+    groupArray(toFixedString(toString(num), 5)) AS fixed_string\n+    FROM (SELECT negate(number) as num FROM system.numbers LIMIT 15);\n+\n+INSERT INTO lc_nullable SELECT\n+    groupArray(number) AS order_key,\n+    groupArray(toInt8(number)) AS i8,\n+    groupArray(toInt16(number)) AS i16,\n+    groupArray(toInt32(number)) AS i32,\n+    groupArray(toInt64(number)) AS i64,\n+    groupArray(toUInt8(number)) AS u8,\n+    groupArray(toUInt16(number)) AS u16,\n+    groupArray(toUInt32(number)) AS u32,\n+    groupArray(toUInt64(number)) AS u64,\n+    groupArray(toFloat32(number)) AS f32,\n+    groupArray(toFloat64(number)) AS f64,\n+    groupArray(toDate(number, 'Europe/Moscow')) AS date,\n+    groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time,\n+    groupArray(toString(number)) AS str,\n+    groupArray(toFixedString(toString(number), 5)) AS fixed_string\n+    FROM (SELECT number FROM system.numbers WHERE number >= 5 LIMIT 15);\n+\n+INSERT INTO lc_nullable SELECT\n+    groupArray(number) AS order_key,\n+    groupArray(toInt8(number)) AS i8,\n+    groupArray(toInt16(number)) AS i16,\n+    groupArray(toInt32(number)) AS i32,\n+    groupArray(toInt64(number)) AS i64,\n+    groupArray(toUInt8(number)) AS u8,\n+    groupArray(toUInt16(number)) AS u16,\n+    groupArray(toUInt32(number)) AS u32,\n+    groupArray(toUInt64(number)) AS u64,\n+    groupArray(toFloat32(number)) AS f32,\n+    groupArray(toFloat64(number)) AS f64,\n+    groupArray(toDate(number, 'Europe/Moscow')) AS date,\n+    groupArray(toDateTime(number, 'Europe/Moscow')) AS date_time,\n+    groupArray(toString(number)) AS str,\n+    groupArray(toFixedString(toString(number), 5)) AS fixed_string\n+    FROM (SELECT number FROM system.numbers WHERE number >= 10 LIMIT 15);\n+\n+INSERT INTO lc_nullable SELECT\n+    n AS order_key,\n+    n AS i8,\n+    n AS i16,\n+    n AS i32,\n+    n AS i64,\n+    n AS u8,\n+    n AS u16,\n+    n AS u32,\n+    n AS u64,\n+    n AS f32,\n+    n AS f64,\n+    n AS date,\n+    n AS date_time,\n+    n AS str,\n+    n AS fixed_string\n+    FROM (SELECT [NULL] AS n);\n+\n+INSERT INTO lc_nullable SELECT\n+    [NULL, n] AS order_key,\n+    [NULL, toInt8(n)] AS i8,\n+    [NULL, toInt16(n)] AS i16,\n+    [NULL, toInt32(n)] AS i32,\n+    [NULL, toInt64(n)] AS i64,\n+    [NULL, toUInt8(n)] AS u8,\n+    [NULL, toUInt16(n)] AS u16,\n+    [NULL, toUInt32(n)] AS u32,\n+    [NULL, toUInt64(n)] AS u64,\n+    [NULL, toFloat32(n)] AS f32,\n+    [NULL, toFloat64(n)] AS f64,\n+    [NULL, toDate(n, 'Europe/Moscow')] AS date,\n+    [NULL, toDateTime(n, 'Europe/Moscow')] AS date_time,\n+    [NULL, toString(n)] AS str,\n+    [NULL, toFixedString(toString(n), 5)] AS fixed_string\n+    FROM (SELECT 100 as n);\n+\n+SELECT count() FROM lc_nullable WHERE has(i8, 1);\n+SELECT count() FROM lc_nullable WHERE has(i16, 1);\n+SELECT count() FROM lc_nullable WHERE has(i32, 1);\n+SELECT count() FROM lc_nullable WHERE has(i64, 1);\n+SELECT count() FROM lc_nullable WHERE has(u8, 1);\n+SELECT count() FROM lc_nullable WHERE has(u16, 1);\n+SELECT count() FROM lc_nullable WHERE has(u32, 1);\n+SELECT count() FROM lc_nullable WHERE has(u64, 1);\n+SELECT count() FROM lc_nullable WHERE has(f32, 1);\n+SELECT count() FROM lc_nullable WHERE has(f64, 1);\n+SELECT count() FROM lc_nullable WHERE has(date, toDate('1970-01-02'));\n+SELECT count() FROM lc_nullable WHERE has(date_time, toDateTime('1970-01-01 03:00:01', 'Europe/Moscow'));\n+SELECT count() FROM lc_nullable WHERE has(str, '1');\n+SELECT count() FROM lc_nullable WHERE has(fixed_string, toFixedString('1', 5));\n+\n+SELECT count() FROM lc_nullable WHERE has(i8,  -1);\n+SELECT count() FROM lc_nullable WHERE has(i16, -1);\n+SELECT count() FROM lc_nullable WHERE has(i32, -1);\n+SELECT count() FROM lc_nullable WHERE has(i64, -1);\n+SELECT count() FROM lc_nullable WHERE has(u8,  -1);\n+SELECT count() FROM lc_nullable WHERE has(u16, -1);\n+SELECT count() FROM lc_nullable WHERE has(u32, -1);\n+SELECT count() FROM lc_nullable WHERE has(u64, -1);\n+SELECT count() FROM lc_nullable WHERE has(f32, -1);\n+SELECT count() FROM lc_nullable WHERE has(f64, -1);\n+SELECT count() FROM lc_nullable WHERE has(str, '-1');\n+SELECT count() FROM lc_nullable WHERE has(fixed_string, toFixedString('-1', 5));\n+\n+SELECT count() FROM lc_nullable WHERE has(i8, 5);\n+SELECT count() FROM lc_nullable WHERE has(i16, 5);\n+SELECT count() FROM lc_nullable WHERE has(i32, 5);\n+SELECT count() FROM lc_nullable WHERE has(i64, 5);\n+SELECT count() FROM lc_nullable WHERE has(u8, 5);\n+SELECT count() FROM lc_nullable WHERE has(u16, 5);\n+SELECT count() FROM lc_nullable WHERE has(u32, 5);\n+SELECT count() FROM lc_nullable WHERE has(u64, 5);\n+SELECT count() FROM lc_nullable WHERE has(f32, 5);\n+SELECT count() FROM lc_nullable WHERE has(f64, 5);\n+SELECT count() FROM lc_nullable WHERE has(date, toDate('1970-01-06'));\n+SELECT count() FROM lc_nullable WHERE has(date_time, toDateTime('1970-01-01 03:00:05', 'Europe/Moscow'));\n+SELECT count() FROM lc_nullable WHERE has(str, '5');\n+SELECT count() FROM lc_nullable WHERE has(fixed_string, toFixedString('5', 5));\n+\n+SELECT count() FROM lc_nullable WHERE has(i8, 10);\n+SELECT count() FROM lc_nullable WHERE has(i16, 10);\n+SELECT count() FROM lc_nullable WHERE has(i32, 10);\n+SELECT count() FROM lc_nullable WHERE has(i64, 10);\n+SELECT count() FROM lc_nullable WHERE has(u8, 10);\n+SELECT count() FROM lc_nullable WHERE has(u16, 10);\n+SELECT count() FROM lc_nullable WHERE has(u32, 10);\n+SELECT count() FROM lc_nullable WHERE has(u64, 10);\n+SELECT count() FROM lc_nullable WHERE has(f32, 10);\n+SELECT count() FROM lc_nullable WHERE has(f64, 10);\n+SELECT count() FROM lc_nullable WHERE has(date, toDate('1970-01-11'));\n+SELECT count() FROM lc_nullable WHERE has(date_time, toDateTime('1970-01-01 03:00:10', 'Europe/Moscow'));\n+SELECT count() FROM lc_nullable WHERE has(str, '10');\n+SELECT count() FROM lc_nullable WHERE has(fixed_string, toFixedString('10', 5));\n+\n+SELECT count() FROM lc_nullable WHERE has(i8, NULL);\n+SELECT count() FROM lc_nullable WHERE has(i16, NULL);\n+SELECT count() FROM lc_nullable WHERE has(i32, NULL);\n+SELECT count() FROM lc_nullable WHERE has(i64, NULL);\n+SELECT count() FROM lc_nullable WHERE has(u8, NULL);\n+SELECT count() FROM lc_nullable WHERE has(u16, NULL);\n+SELECT count() FROM lc_nullable WHERE has(u32, NULL);\n+SELECT count() FROM lc_nullable WHERE has(u64, NULL);\n+SELECT count() FROM lc_nullable WHERE has(f32, NULL);\n+SELECT count() FROM lc_nullable WHERE has(f64, NULL);\n+SELECT count() FROM lc_nullable WHERE has(date, NULL);\n+SELECT count() FROM lc_nullable WHERE has(date_time, NULL);\n+SELECT count() FROM lc_nullable WHERE has(str, NULL);\n+SELECT count() FROM lc_nullable WHERE has(fixed_string, NULL);\n+\n+SELECT count() FROM lc_nullable WHERE has(i8, 100);\n+SELECT count() FROM lc_nullable WHERE has(i16, 100);\n+SELECT count() FROM lc_nullable WHERE has(i32, 100);\n+SELECT count() FROM lc_nullable WHERE has(i64, 100);\n+SELECT count() FROM lc_nullable WHERE has(u8, 100);\n+SELECT count() FROM lc_nullable WHERE has(u16, 100);\n+SELECT count() FROM lc_nullable WHERE has(u32, 100);\n+SELECT count() FROM lc_nullable WHERE has(u64, 100);\n+SELECT count() FROM lc_nullable WHERE has(f32, 100);\n+SELECT count() FROM lc_nullable WHERE has(f64, 100);\n+SELECT count() FROM lc_nullable WHERE has(date, toDate('1970-04-11'));\n+SELECT count() FROM lc_nullable WHERE has(date_time, toDateTime('1970-01-01 03:01:40', 'Europe/Moscow'));\n+SELECT count() FROM lc_nullable WHERE has(str, '100');\n+SELECT count() FROM lc_nullable WHERE has(fixed_string, toFixedString('100', 5));\n+\n+DROP TABLE IF EXISTS lc_nullable;\ndiff --git a/tests/queries/0_stateless/01441_low_cardinality_array_index.reference b/tests/queries/0_stateless/01441_low_cardinality_array_index.reference\nnew file mode 100644\nindex 000000000000..4e68594ce22f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01441_low_cardinality_array_index.reference\n@@ -0,0 +1,15 @@\n+100\n+100\n+100\n+100\n+1000000\n+1000000\n+1000000\n+4000\n+4000\n+4000\n+4000\n+1000000\n+1000000\n+1000000\n+1000000\ndiff --git a/tests/queries/0_stateless/01441_low_cardinality_array_index.sql b/tests/queries/0_stateless/01441_low_cardinality_array_index.sql\nnew file mode 100644\nindex 000000000000..45d69b5aa64b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01441_low_cardinality_array_index.sql\n@@ -0,0 +1,41 @@\n+DROP TABLE IF EXISTS t_01411;\n+\n+CREATE TABLE t_01411(\n+    str LowCardinality(String),\n+    arr Array(LowCardinality(String)) default [str]\n+) ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO t_01411 (str) SELECT concat('asdf', toString(number % 10000)) FROM numbers(1000000);\n+\n+SELECT count() FROM t_01411 WHERE str = 'asdf337';\n+SELECT count() FROM t_01411 WHERE arr[1] = 'asdf337';\n+SELECT count() FROM t_01411 WHERE has(arr, 'asdf337');\n+SELECT count() FROM t_01411 WHERE indexOf(arr, 'asdf337') > 0;\n+\n+SELECT count() FROM t_01411 WHERE arr[1] = str;\n+SELECT count() FROM t_01411 WHERE has(arr, str);\n+SELECT count() FROM t_01411 WHERE indexOf(arr, str) > 0;\n+\n+DROP TABLE IF EXISTS t_01411;\n+DROP TABLE IF EXISTS t_01411_num;\n+\n+CREATE TABLE t_01411_num(\n+    num UInt8,\n+    arr Array(LowCardinality(Int64)) default [num]\n+) ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO t_01411_num (num) SELECT number % 1000 FROM numbers(1000000);\n+\n+SELECT count() FROM t_01411_num WHERE num = 42;\n+SELECT count() FROM t_01411_num WHERE arr[1] = 42;\n+SELECT count() FROM t_01411_num WHERE has(arr, 42);\n+SELECT count() FROM t_01411_num WHERE indexOf(arr, 42) > 0;\n+\n+SELECT count() FROM t_01411_num WHERE arr[1] = num;\n+SELECT count() FROM t_01411_num WHERE has(arr, num);\n+SELECT count() FROM t_01411_num WHERE indexOf(arr, num) > 0;\n+SELECT count() FROM t_01411_num WHERE indexOf(arr, num % 337) > 0;\n+\n+DROP TABLE IF EXISTS t_01411_num;\n",
  "problem_statement": "countEqual: PODArray.h:342: Assertion `(n >= (static_cast<ssize_t>(pad_left_) ? -1 : 0)) ... failed\n```\r\nSELECT countEqual(materialize([null AS x, 1]), materialize(x))\r\n\r\nclickhouse-server: /home/akuzm/ch2/ch/src/Common/PODArray.h:342: const T &DB::PODArray<char8_t, 4096, Allocator<false, false>, 15, 16>::operator[](ssize_t) const [T = char8_t, initial_bytes = 4096, TAllocator = Allocator<false, false>, pad_right_ = 15, pad_left_ = 16]: Assertion `(n >= (static_cast<ssize_t>(pad_left_) ? -1 : 0)) && (n <= static_cast<ssize_t>(this->size()))' failed.\r\n2020.08.06 00:27:42.648640 [ 444733 ] {} <Trace> BaseDaemon: Received signal 6\r\n2020.08.06 00:27:42.658561 [ 444825 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.08.06 00:27:42.664533 [ 444825 ] {} <Fatal> BaseDaemon: (version 20.7.1.1, build id: D3FC167BA205D4A1) (from thread 444804) (query_id: 88d7de8e-f9c7-42cd-a1ee-3057cebde663) Received signal Aborted (6)\r\n2020.08.06 00:27:42.664869 [ 444825 ] {} <Fatal> BaseDaemon: \r\n2020.08.06 00:27:42.665424 [ 444825 ] {} <Fatal> BaseDaemon: Stack trace: 0x7efdd8c3d18b 0x7efdd8c1c859 0x7efdd8c1c729 0x7efdd8c2df36 0x7efdd787723d 0x7efdd292852f 0x7efdc45426d0 0x7efdc4541b75 0x7efdc44b2f97 0x7efdc44b088a 0x7efdc44b00bf 0x7efdd28aea2f 0x7efdd30deffb 0x7efdd30e00cd 0x7efdcb964483 0x7efdcb967bb3 0x7efdc73de9dc 0x7efdca060035 0x7efdc7ea3eea 0x7efdc7ce632c 0x7efdc7ce628f 0x7efdc7ce624d 0x7efdc7ce61fd 0x7efdc7ce61cd 0x7efdc7ce531e 0x7efddd3a78c5 0x7efddd3a7865 0x7efdc7ce3c35\r\n2020.08.06 00:27:42.666139 [ 444825 ] {} <Fatal> BaseDaemon: 4. /build/glibc-YYA7BZ/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:51: raise @ 0x4618b in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.06 00:27:42.666653 [ 444825 ] {} <Fatal> BaseDaemon: 5. /build/glibc-YYA7BZ/glibc-2.31/stdlib/abort.c:81: __GI_abort @ 0x25859 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.06 00:27:42.667310 [ 444825 ] {} <Fatal> BaseDaemon: 6. /build/glibc-YYA7BZ/glibc-2.31/intl/loadmsgcat.c:509: _nl_load_domain.cold @ 0x25729 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.06 00:27:42.674461 [ 444825 ] {} <Fatal> BaseDaemon: 7. ? @ 0x36f36 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.06 00:27:42.678103 [ 444825 ] {} <Fatal> BaseDaemon: 8. /home/akuzm/ch2/ch/src/Common/PODArray.h:0: DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul>::operator[](long) const @ 0x25bd23d in /home/akuzm/ch2/build-clang10/src/AggregateFunctions/libclickhouse_aggregate_functionsd.so\r\n2020.08.06 00:27:42.686531 [ 444825 ] {} <Fatal> BaseDaemon: 9. /home/akuzm/ch2/ch/src/Columns/ColumnVector.h:190: DB::ColumnVector<char8_t>::compareAt(unsigned long, unsigned long, DB::IColumn const&, int) const @ 0x292a52f in /home/akuzm/ch2/build-clang10/src/Functions/libclickhouse_functionsd.so\r\n2020.08.06 00:27:42.731203 [ 444825 ] {} <Fatal> BaseDaemon: 10. /home/akuzm/ch2/ch/src/Functions/array/arrayIndex.h:511: DB::ArrayIndexGenericImpl<DB::IndexCount, false>::vectorCase4(DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul>&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const&) @ 0x8606d0 in /home/akuzm/ch2/build-clang10/src/Functions/array/libclickhouse_functions_arrayd.so\r\n2020.08.06 00:27:42.767709 [ 444825 ] {} <Fatal> BaseDaemon: 11. /home/akuzm/ch2/ch/src/Functions/array/arrayIndex.h:0: DB::ArrayIndexGenericImpl<DB::IndexCount, false>::vector(DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul>&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const*, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const*) @ 0x85fb75 in /home/akuzm/ch2/build-clang10/src/Functions/array/libclickhouse_functions_arrayd.so\r\n2020.08.06 00:27:42.779483 [ 444825 ] {} <Fatal> BaseDaemon: 12. /home/akuzm/ch2/ch/src/Functions/array/arrayIndex.h:841: DB::FunctionArrayIndex<DB::IndexCount, DB::NameCountEqual>::executeGeneric(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) const @ 0x7d0f97 in /home/akuzm/ch2/build-clang10/src/Functions/array/libclickhouse_functions_arrayd.so\r\n2020.08.06 00:27:42.783997 [ 444825 ] {} <Fatal> BaseDaemon: 13. /home/akuzm/ch2/ch/src/Functions/array/arrayIndex.h:990: DB::FunctionArrayIndex<DB::IndexCount, DB::NameCountEqual>::perform(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) const @ 0x7ce88a in /home/akuzm/ch2/build-clang10/src/Functions/array/libclickhouse_functions_arrayd.so\r\n2020.08.06 00:27:42.798702 [ 444825 ] {} <Fatal> BaseDaemon: 14. /home/akuzm/ch2/ch/src/Functions/array/arrayIndex.h:977: DB::FunctionArrayIndex<DB::IndexCount, DB::NameCountEqual>::executeImpl(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) const @ 0x7ce0bf in /home/akuzm/ch2/build-clang10/src/Functions/array/libclickhouse_functions_arrayd.so\r\n2020.08.06 00:27:42.799962 [ 444825 ] {} <Fatal> BaseDaemon: 15. /home/akuzm/ch2/ch/src/Functions/IFunctionAdaptors.h:152: DB::DefaultExecutable::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) @ 0x28b0a2f in /home/akuzm/ch2/build-clang10/src/Functions/libclickhouse_functionsd.so\r\n2020.08.06 00:27:42.803910 [ 444825 ] {} <Fatal> BaseDaemon: 16. /home/akuzm/ch2/ch/src/Functions/IFunction.cpp:326: DB::ExecutableFunctionAdaptor::executeWithoutLowCardinalityColumns(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) @ 0x30e0ffb in /home/akuzm/ch2/build-clang10/src/Functions/libclickhouse_functionsd.so\r\n2020.08.06 00:27:42.817062 [ 444825 ] {} <Fatal> BaseDaemon: 17. /home/akuzm/ch2/ch/src/Functions/IFunction.cpp:486: DB::ExecutableFunctionAdaptor::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) @ 0x30e20cd in /home/akuzm/ch2/build-clang10/src/Functions/libclickhouse_functionsd.so\r\n2020.08.06 00:27:42.823957 [ 444825 ] {} <Fatal> BaseDaemon: 18. /home/akuzm/ch2/ch/src/Interpreters/ExpressionActions.cpp:365: DB::ExpressionAction::execute(DB::Block&, bool) const @ 0x122c483 in /home/akuzm/ch2/build-clang10/src/libclickhouse_interpretersd.so\r\n2020.08.06 00:27:42.826630 [ 444825 ] {} <Fatal> BaseDaemon: 19. /home/akuzm/ch2/ch/src/Interpreters/ExpressionActions.cpp:684: DB::ExpressionActions::execute(DB::Block&, bool) const @ 0x122fbb3 in /home/akuzm/ch2/build-clang10/src/libclickhouse_interpretersd.so\r\n2020.08.06 00:27:42.827838 [ 444825 ] {} <Fatal> BaseDaemon: 20. /home/akuzm/ch2/ch/src/Processors/Transforms/ExpressionTransform.cpp:41: DB::ExpressionTransform::transform(DB::Chunk&) @ 0x25e9dc in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_transformsd.so\r\n2020.08.06 00:27:42.846966 [ 444825 ] {} <Fatal> BaseDaemon: 21. /home/akuzm/ch2/ch/src/Processors/ISimpleTransform.h:43: DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0xa96035 in /home/akuzm/ch2/build-clang10/src/libclickhouse_storagesd.so\r\n2020.08.06 00:27:42.847879 [ 444825 ] {} <Fatal> BaseDaemon: 22. /home/akuzm/ch2/ch/src/Processors/ISimpleTransform.cpp:89: DB::ISimpleTransform::work() @ 0x18eeea in /home/akuzm/ch2/build-clang10/src/libclickhouse_processorsd.so\r\n2020.08.06 00:27:42.855219 [ 444825 ] {} <Fatal> BaseDaemon: 23. /home/akuzm/ch2/ch/src/Processors/Executors/PipelineExecutor.cpp:78: DB::executeJob(DB::IProcessor*) @ 0x13132c in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n2020.08.06 00:27:42.856128 [ 444825 ] {} <Fatal> BaseDaemon: 24. /home/akuzm/ch2/ch/src/Processors/Executors/PipelineExecutor.cpp:95: DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0::operator()() const @ 0x13128f in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n2020.08.06 00:27:42.857007 [ 444825 ] {} <Fatal> BaseDaemon: 25. /home/akuzm/ch2/ch/contrib/libcxx/include/type_traits:3519: decltype(std::__1::forward<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(fp)()) std::__1::__invoke<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&) @ 0x13124d in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n2020.08.06 00:27:42.857881 [ 444825 ] {} <Fatal> BaseDaemon: 26. /home/akuzm/ch2/ch/contrib/libcxx/include/__functional_base:349: void std::__1::__invoke_void_return_wrapper<void>::__call<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&) @ 0x1311fd in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n2020.08.06 00:27:42.858739 [ 444825 ] {} <Fatal> BaseDaemon: 27. /home/akuzm/ch2/ch/contrib/libcxx/include/functional:1540: std::__1::__function::__alloc_func<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0, std::__1::allocator<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0>, void ()>::operator()() @ 0x1311cd in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n2020.08.06 00:27:42.859589 [ 444825 ] {} <Fatal> BaseDaemon: 28. /home/akuzm/ch2/ch/contrib/libcxx/include/functional:1714: std::__1::__function::__func<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0, std::__1::allocator<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0>, void ()>::operator()() @ 0x13031e in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n2020.08.06 00:27:42.863662 [ 444825 ] {} <Fatal> BaseDaemon: 29. /home/akuzm/ch2/ch/contrib/libcxx/include/functional:1867: std::__1::__function::__value_func<void ()>::operator()() const @ 0x1d68c5 in /home/akuzm/ch2/build-clang10/programs/server/libclickhouse-server-libd.so\r\n2020.08.06 00:27:42.867753 [ 444825 ] {} <Fatal> BaseDaemon: 30. /home/akuzm/ch2/ch/contrib/libcxx/include/functional:2473: std::__1::function<void ()>::operator()() const @ 0x1d6865 in /home/akuzm/ch2/build-clang10/programs/server/libclickhouse-server-libd.so\r\n2020.08.06 00:27:42.868542 [ 444825 ] {} <Fatal> BaseDaemon: 31. /home/akuzm/ch2/ch/src/Processors/Executors/PipelineExecutor.cpp:559: DB::PipelineExecutor::executeStepImpl(unsigned long, unsigned long, std::__1::atomic<bool>*) @ 0x12ec35 in /home/akuzm/ch2/build-clang10/src/libclickhouse_processors_executorsd.so\r\n```\nArray(LowCardinality(String)) has() function slower\nhello,\r\n\r\nI store the  exp_id list in an Array using Array(LowCardinality(String)) for our A/B test \u3002 \r\nexample exps  array data:  ['zeyudu_rec_6096_1','default','zeyudu_rec_6096_2','zeyudu_rec_6096_3',....]\r\n     \r\nMy Query:\r\n```\r\nSELECT\r\n    multiIf(has(exps_lowcard, 'zeyudu_rec_6096_1'), 'control', has(exps_lowcard, 'zeyudu_rec_6096_2'), '6096_2', 'other') AS expr_model_v20,\r\n    SUM(multiIf(windowType = 'CLICK', ((((4 * hasFollow) + hasLike) + hasComment) + (4 * hasShare)) + hasCollect, NULL) * SampleWeight) AS `SUM(ces)`\r\nFROM default.explore_feed_bitmap\r\nGROUP BY expr_model_v20\r\n```\r\n\r\nresult:  1.1E rows  taken 34 seconds\r\n\r\n\r\nI make anther test : \r\n       I manage  an  external exp_id dictionay and then store the exp_id list  like  [1001,3001,4002,6001,6002.....]  \r\n \r\ntest query:\r\n```\r\nSELECT\r\n    multiIf(has(exps_array, 6001), 'control', has(exps_array, 6002), '6002', 'other') AS expr_model_v20,\r\n    SUM(multiIf(windowType = 'CLICK', ((((4 * hasFollow) + hasLike) + hasComment) + (4 * hasShare)) + hasCollect, NULL) * SampleWeight) AS `SUM(ces)`\r\nFROM default.explore_feed_bitmap\r\nGROUP BY expr_model_v20\r\n```\r\nresult: 1.1E rows  taken 3.2 seconds ,  \r\n\r\nclickhouser version: 19.17.4.11  \r\n\r\ncan you help check this issue. I think the LowCardinality Array should has the close performance with an Array stores Int\u3002  \r\n\r\nIf you need more information,  I will update .\r\n\r\nthanks\r\njohnny \nBad cast from type DB::ColumnNothing to DB::ColumnString\n```\r\nSELECT has(materialize(['bbbbbb\\0b', NULL]), materialize(NULL))\r\n\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.009029 [ 254 ] <Fatal> BaseDaemon: ########################################\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.009462 [ 254 ] <Fatal> BaseDaemon: (version 20.8.1.4327, build id: 3F5D7E4E592D8D67) (from thread 252) (query_id: 4102f664-45a8-4755-9523-045562b22768) Received signal Aborted (6)\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.009632 [ 254 ] <Fatal> BaseDaemon: \r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.009835 [ 254 ] <Fatal> BaseDaemon: Stack trace: 0x7f7d5e357f47 0x7f7d5e3598b1 0x7f7d5e34942a 0x7f7d5e3494a2 0x17f2f9f1 0x1819a044 0x1f4a88b0 0x1d57338c 0x1d572855 0x1d4e7fa7 0x1d4e594a 0x1d4e51ad 0x195235bf 0x1958b19b 0x1958c27d 0x1fa9dcc1 0x1faa1453 0x20bd17cc 0x20288a55 0x20948eca 0x209a54ac 0x209a540f 0x209a53cd 0x209a537d 0x209a534d 0x209a44ae 0x17f52735 0x17f51655\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.010205 [ 254 ] <Fatal> BaseDaemon: 4. /build/glibc-2ORdQG/glibc-2.27/signal/../sysdeps/unix/sysv/linux/raise.c:51: raise @ 0x3ef47 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.010499 [ 254 ] <Fatal> BaseDaemon: 5. /build/glibc-2ORdQG/glibc-2.27/stdlib/abort.c:81: __GI_abort @ 0x408b1 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.010732 [ 254 ] <Fatal> BaseDaemon: 6. /build/glibc-2ORdQG/glibc-2.27/assert/assert.c:89: __assert_fail_base @ 0x3042a in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.011171 [ 254 ] <Fatal> BaseDaemon: 7. ? @ 0x304a2 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.011551 [ 254 ] <Fatal> BaseDaemon: 8. /build/obj-x86_64-linux-gnu/../src/Common/Exception.cpp:48: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x17f2f9f1 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.014577 [ 254 ] <Fatal> BaseDaemon: 9. /build/obj-x86_64-linux-gnu/../src/Common/assert_cast.h:47: DB::ColumnString const& assert_cast<DB::ColumnString const&, DB::IColumn const&>(DB::IColumn const&) @ 0x1819a044 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.055259 [ 254 ] <Fatal> BaseDaemon: 10. /build/obj-x86_64-linux-gnu/../src/Columns/ColumnString.h:223: DB::ColumnString::compareAt(unsigned long, unsigned long, DB::IColumn const&, int) const @ 0x1f4a88b0 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.087783 [ 254 ] <Fatal> BaseDaemon: 11. /build/obj-x86_64-linux-gnu/../src/Functions/array/arrayIndex.h:511: DB::ArrayIndexGenericImpl<DB::IndexToOne, false>::vectorCase4(DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::IColumn const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul>&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const&) @ 0x1d57338c in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.121014 [ 254 ] <Fatal> BaseDaemon: 12. /build/obj-x86_64-linux-gnu/../src/Functions/array/arrayIndex.h:0: DB::ArrayIndexGenericImpl<DB::IndexToOne, false>::vector(DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::IColumn const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul>&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const*, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const*) @ 0x1d572855 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.147898 [ 254 ] <Fatal> BaseDaemon: 13. /build/obj-x86_64-linux-gnu/../src/Functions/array/arrayIndex.h:841: DB::FunctionArrayIndex<DB::IndexToOne, DB::NameHas>::executeGeneric(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) const @ 0x1d4e7fa7 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.173993 [ 254 ] <Fatal> BaseDaemon: 14. /build/obj-x86_64-linux-gnu/../src/Functions/array/arrayIndex.h:990: DB::FunctionArrayIndex<DB::IndexToOne, DB::NameHas>::perform(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) const @ 0x1d4e594a in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.200296 [ 254 ] <Fatal> BaseDaemon: 15. /build/obj-x86_64-linux-gnu/../src/Functions/array/arrayIndex.h:977: DB::FunctionArrayIndex<DB::IndexToOne, DB::NameHas>::executeImpl(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) const @ 0x1d4e51ad in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.206417 [ 254 ] <Fatal> BaseDaemon: 16. /build/obj-x86_64-linux-gnu/../src/Functions/IFunctionAdaptors.h:152: DB::DefaultExecutable::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) @ 0x195235bf in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.212449 [ 254 ] <Fatal> BaseDaemon: 17. /build/obj-x86_64-linux-gnu/../src/Functions/IFunction.cpp:326: DB::ExecutableFunctionAdaptor::executeWithoutLowCardinalityColumns(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) @ 0x1958b19b in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.217997 [ 254 ] <Fatal> BaseDaemon: 18. /build/obj-x86_64-linux-gnu/../src/Functions/IFunction.cpp:486: DB::ExecutableFunctionAdaptor::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) @ 0x1958c27d in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.258414 [ 254 ] <Fatal> BaseDaemon: 19. /build/obj-x86_64-linux-gnu/../src/Interpreters/ExpressionActions.cpp:365: DB::ExpressionAction::execute(DB::Block&, bool) const @ 0x1fa9dcc1 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.300618 [ 254 ] <Fatal> BaseDaemon: 20. /build/obj-x86_64-linux-gnu/../src/Interpreters/ExpressionActions.cpp:684: DB::ExpressionActions::execute(DB::Block&, bool) const @ 0x1faa1453 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.353500 [ 254 ] <Fatal> BaseDaemon: 21. /build/obj-x86_64-linux-gnu/../src/Processors/Transforms/ExpressionTransform.cpp:41: DB::ExpressionTransform::transform(DB::Chunk&) @ 0x20bd17cc in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.400610 [ 254 ] <Fatal> BaseDaemon: 22. /build/obj-x86_64-linux-gnu/../src/Processors/ISimpleTransform.h:43: DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x20288a55 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.449961 [ 254 ] <Fatal> BaseDaemon: 23. /build/obj-x86_64-linux-gnu/../src/Processors/ISimpleTransform.cpp:89: DB::ISimpleTransform::work() @ 0x20948eca in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.498091 [ 254 ] <Fatal> BaseDaemon: 24. /build/obj-x86_64-linux-gnu/../src/Processors/Executors/PipelineExecutor.cpp:78: DB::executeJob(DB::IProcessor*) @ 0x209a54ac in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.548950 [ 254 ] <Fatal> BaseDaemon: 25. /build/obj-x86_64-linux-gnu/../src/Processors/Executors/PipelineExecutor.cpp:95: DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0::operator()() const @ 0x209a540f in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.599582 [ 254 ] <Fatal> BaseDaemon: 26. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/type_traits:3519: decltype(std::__1::forward<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(fp)()) std::__1::__invoke<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&) @ 0x209a53cd in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.651028 [ 254 ] <Fatal> BaseDaemon: 27. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/__functional_base:349: void std::__1::__invoke_void_return_wrapper<void>::__call<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&) @ 0x209a537d in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.701525 [ 254 ] <Fatal> BaseDaemon: 28. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/functional:1540: std::__1::__function::__alloc_func<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0, std::__1::allocator<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0>, void ()>::operator()() @ 0x209a534d in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.753390 [ 254 ] <Fatal> BaseDaemon: 29. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/functional:1714: std::__1::__function::__func<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0, std::__1::allocator<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0>, void ()>::operator()() @ 0x209a44ae in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.754032 [ 254 ] <Fatal> BaseDaemon: 30. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/functional:1867: std::__1::__function::__value_func<void ()>::operator()() const @ 0x17f52735 in /workspace/clickhouse\r\n[linux-ubuntu-14-04-trusty] 2020.08.10 03:22:06.754411 [ 254 ] <Fatal> BaseDaemon: 31. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/functional:2473: std::__1::function<void ()>::operator()() const @ 0x17f51655 in /workspace/clickhouse\r\nError on processing query: SELECT has(materialize(['bbbbbb\\0b', NULL]), materialize(NULL))\r\n\r\n```\r\n\r\nhttps://clickhouse-test-reports.s3.yandex.net/13495/3b9f5a827c5ee1d8c5376a8948ecf97516092978/fuzzer/fuzzer.log\nArrays of LowCardinality are not optimized for function calculations\nArrays of LowCardinality Strings do not use LowCardinality optimisations for string operations.\r\n\r\n```\r\ncreate table test_lc_array (\r\n s LowCardinality(String),\r\n a Array(LowCardinality(String)) default array(s)\r\n) Engine = MergeTree \r\nPARTITION BY tuple()\r\nORDER BY tuple()\r\n;\r\n\r\ninsert into test_lc_array (s)\r\nselect concat('qwertyuiopasdfghjkl', toString(number%10))\r\nfrom numbers(100000000)\r\n;  \r\n\r\nselect count() from test_lc_array where s = 'qwertyuiopasdfghjkl0';\r\n\r\n1 rows in set. Elapsed: 0.200 sec. Processed 100.00 million rows, 100.46 MB (501.07 million rows/s., 503.36 MB/s.) \r\n<Debug> MemoryTracker: Peak memory usage (for query): 2.04 MiB.\r\n\r\nselect count() from test_lc_array where a[1] = 'qwertyuiopasdfghjkl0';\r\n\r\n1 rows in set. Elapsed: 2.033 sec. Processed 100.00 million rows, 900.46 MB (49.19 million rows/s., 442.93 MB/s.) \r\n<Debug> MemoryTracker: Peak memory usage (for query): 16.74 MiB.\r\n\r\nselect count() from test_lc_array where has(a, 'qwertyuiopasdfghjkl0');\r\n\r\n1 rows in set. Elapsed: 1.136 sec. Processed 100.00 million rows, 900.46 MB (88.06 million rows/s., 792.97 MB/s.) \r\n <Debug> MemoryTracker: Peak memory usage (for query): 10.99 MiB.\r\n\r\nselect count() from test_lc_array where indexOf(a, 'qwertyuiopasdfghjkl0')>0;\r\n\r\n1 rows in set. Elapsed: 1.211 sec. Processed 100.00 million rows, 900.46 MB (82.60 million rows/s., 743.81 MB/s.) \r\n<Debug> MemoryTracker: Peak memory usage (for query): 12.74 MiB.\r\n```\nBad cast from type DB::ColumnNothing to DB::ColumnString assertion failed\n```sql\r\nSELECT [100, NULL, 1048575, 0.5, NULL, NULL], has(materialize(['', NULL, '', '', '']), materialize(NULL))\r\n```\r\n```bash\r\n2020.08.20 14:48:08.253558 [ 35345 ] {9e364f20-0959-4230-abea-beff566d9286} <Error> : Logical error: 'Bad cast from type DB::ColumnNothing to DB::ColumnString'.\r\nclickhouse: ../src/Common/Exception.cpp:45: DB::Exception::Exception(const std::string &, int): Assertion `false' failed.\r\n2020.08.20 14:48:08.254004 [ 35241 ] {} <Trace> BaseDaemon: Received signal 6\r\n2020.08.20 14:48:08.254358 [ 35502 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.08.20 14:48:08.254717 [ 35502 ] {} <Fatal> BaseDaemon: (version 20.8.1.1, build id: 8924309CF00424A4) (from thread 35345) (query_id: 9e364f20-0959-4230-abea-beff566d9286) Received signal Aborted (6)\r\n2020.08.20 14:48:08.254923 [ 35502 ] {} <Fatal> BaseDaemon: \r\n2020.08.20 14:48:08.255094 [ 35502 ] {} <Fatal> BaseDaemon: Stack trace: 0x7fda15ec218b 0x7fda15ea1859 0x7fda15ea1729 0x7fda15eb2f36 0x183349f1 0x1859d444 0x1f96ae60 0x1d987f5c 0x1d987425 0x1d8fcb77 0x1d8fa51a 0x1d8f9d7d 0x1993540f 0x1999cfcb 0x1999e0ad 0x1ffa9a41 0x1ffad1d3 0x210fdb9c 0x207a9d55 0x20e722a8 0x20ed236c 0x20ed22cf 0x20ed228d 0x20ed223d 0x20ed220d 0x20ed136e 0x18357735 0x18356655\r\n2020.08.20 14:48:08.256857 [ 35502 ] {} <Fatal> BaseDaemon: 4. /build/glibc-YYA7BZ/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:51: __GI_raise @ 0x4618b in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.20 14:48:08.257419 [ 35502 ] {} <Fatal> BaseDaemon: 5. /build/glibc-YYA7BZ/glibc-2.31/stdlib/abort.c:81: abort @ 0x25859 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.20 14:48:08.258151 [ 35502 ] {} <Fatal> BaseDaemon: 6. /build/glibc-YYA7BZ/glibc-2.31/intl/loadmsgcat.c:509: _nl_load_domain.cold @ 0x25729 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.20 14:48:08.258492 [ 35502 ] {} <Fatal> BaseDaemon: 7. ? @ 0x36f36 in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so\r\n2020.08.20 14:48:08.258754 [ 35502 ] {} <Fatal> BaseDaemon: 8. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Common/Exception.cpp:48: DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int) @ 0x183349f1 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.260954 [ 35502 ] {} <Fatal> BaseDaemon: 9. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Common/assert_cast.h:47: DB::ColumnString const& assert_cast<DB::ColumnString const&, DB::IColumn const&>(DB::IColumn const&) @ 0x1859d444 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.292489 [ 35502 ] {} <Fatal> BaseDaemon: 10. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Columns/ColumnString.h:223: DB::ColumnString::compareAt(unsigned long, unsigned long, DB::IColumn const&, int) const @ 0x1f96ae60 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.317481 [ 35502 ] {} <Fatal> BaseDaemon: 11. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/array/arrayIndex.h:511: DB::ArrayIndexGenericImpl<DB::IndexToOne, false>::vectorCase4(DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::IColumn const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul>&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const&) @ 0x1d987f5c in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.342336 [ 35502 ] {} <Fatal> BaseDaemon: 12. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/array/arrayIndex.h:0: DB::ArrayIndexGenericImpl<DB::IndexToOne, false>::vector(DB::IColumn const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 15ul, 16ul> const&, DB::IColumn const&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul>&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const*, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const*) @ 0x1d987425 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.362049 [ 35502 ] {} <Fatal> BaseDaemon: 13. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/array/arrayIndex.h:841: DB::FunctionArrayIndex<DB::IndexToOne, DB::NameHas>::executeGeneric(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) const @ 0x1d8fcb77 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.381610 [ 35502 ] {} <Fatal> BaseDaemon: 14. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/array/arrayIndex.h:990: DB::FunctionArrayIndex<DB::IndexToOne, DB::NameHas>::perform(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long) const @ 0x1d8fa51a in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.401617 [ 35502 ] {} <Fatal> BaseDaemon: 15. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/array/arrayIndex.h:977: DB::FunctionArrayIndex<DB::IndexToOne, DB::NameHas>::executeImpl(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) const @ 0x1d8f9d7d in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.406696 [ 35502 ] {} <Fatal> BaseDaemon: 16. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/IFunctionAdaptors.h:152: DB::DefaultExecutable::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long) @ 0x1993540f in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.411046 [ 35502 ] {} <Fatal> BaseDaemon: 17. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/IFunction.cpp:326: DB::ExecutableFunctionAdaptor::executeWithoutLowCardinalityColumns(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) @ 0x1999cfcb in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.415358 [ 35502 ] {} <Fatal> BaseDaemon: 18. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Functions/IFunction.cpp:486: DB::ExecutableFunctionAdaptor::execute(DB::Block&, std::__1::vector<unsigned long, std::__1::allocator<unsigned long> > const&, unsigned long, unsigned long, bool) @ 0x1999e0ad in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.445813 [ 35502 ] {} <Fatal> BaseDaemon: 19. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Interpreters/ExpressionActions.cpp:365: DB::ExpressionAction::execute(DB::Block&, bool) const @ 0x1ffa9a41 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.476374 [ 35502 ] {} <Fatal> BaseDaemon: 20. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Interpreters/ExpressionActions.cpp:684: DB::ExpressionActions::execute(DB::Block&, bool) const @ 0x1ffad1d3 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.515426 [ 35502 ] {} <Fatal> BaseDaemon: 21. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Processors/Transforms/ExpressionTransform.cpp:41: DB::ExpressionTransform::transform(DB::Chunk&) @ 0x210fdb9c in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.551551 [ 35502 ] {} <Fatal> BaseDaemon: 22. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Processors/ISimpleTransform.h:43: DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x207a9d55 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.589600 [ 35502 ] {} <Fatal> BaseDaemon: 23. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Processors/ISimpleTransform.cpp:89: DB::ISimpleTransform::work() @ 0x20e722a8 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.627165 [ 35502 ] {} <Fatal> BaseDaemon: 24. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Processors/Executors/PipelineExecutor.cpp:78: DB::executeJob(DB::IProcessor*) @ 0x20ed236c in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.664775 [ 35502 ] {} <Fatal> BaseDaemon: 25. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../src/Processors/Executors/PipelineExecutor.cpp:95: DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0::operator()() const @ 0x20ed22cf in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.703204 [ 35502 ] {} <Fatal> BaseDaemon: 26. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../contrib/libcxx/include/type_traits:3519: decltype(std::__1::forward<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(fp)()) std::__1::__invoke<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&) @ 0x20ed228d in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.741536 [ 35502 ] {} <Fatal> BaseDaemon: 27. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../contrib/libcxx/include/__functional_base:349: void std::__1::__invoke_void_return_wrapper<void>::__call<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&>(DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0&) @ 0x20ed223d in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.780169 [ 35502 ] {} <Fatal> BaseDaemon: 28. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../contrib/libcxx/include/functional:1540: std::__1::__function::__alloc_func<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0, std::__1::allocator<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0>, void ()>::operator()() @ 0x20ed220d in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.818795 [ 35502 ] {} <Fatal> BaseDaemon: 29. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../contrib/libcxx/include/functional:1714: std::__1::__function::__func<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0, std::__1::allocator<DB::PipelineExecutor::addJob(DB::ExecutingGraph::Node*)::$_0>, void ()>::operator()() @ 0x20ed136e in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.819258 [ 35502 ] {} <Fatal> BaseDaemon: 30. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../contrib/libcxx/include/functional:1867: std::__1::__function::__value_func<void ()>::operator()() const @ 0x18357735 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n2020.08.20 14:48:08.819909 [ 35502 ] {} <Fatal> BaseDaemon: 31. /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/../contrib/libcxx/include/functional:2473: std::__1::function<void ()>::operator()() const @ 0x18356655 in /home/jakalletti/ClickHouse/ClickHouse/build-clang-debug/programs/clickhouse\r\n```\r\nFrom https://clickhouse-test-reports.s3.yandex.net/13624/00fde75e2bd00a9d1fcba81c5442f07d5aab3612/fuzzer/fuzzer.log#fail1\n",
  "hints_text": "\ntested version 20.3.8.53   \uff0c same\n\n@alex-zaitsev Do you have a moment to shed some light on how Array(LowCardinality(String)) columns work? My understanding (please correct me if I'm wrong) is that the storage engines in clickhouse can basically do whatever they want but when a query is executed they're responsible for generating \"native format\" blocks for the query execution engine to operate on.\r\n\r\nMy understanding of the Array() column native format is that its basically $NUM_ROWS uint64 offsets where each offset defines the beginning of an individual array, and then each array is an integer describing the number of elements in the array, and then the array itself is just encoded using the standard native format encoding of a non-nullable column for that type (so Array(uint64) the array itself would just be $ARRAY_LENGTH 8 byte uint64s)\r\n\r\nThat implies to me that implementing Array(LowCardinality(String)) would be difficult because the format would imply a dictionary per array (the native format for a LowCardinality(string) has the dictionary at the beginning of each block) where what you'd really want is a dictionary per Array column. Is that whats going on here? My understanding was that Array(LowCardinality(string)) definitely saves disk space so I'm curious about the interaction between the storage engine, the native format, and the query execution engine here.\nI guess the `LowCardinality` native format does have flags for re-using the same dictionary as the previous block, so I guess that could be used where the first array element has the dictionary and all subsequent arrays just set the flag to keep reusing the previous dictionary?\n@richardartoul \r\n\r\n> My understanding (please correct me if I'm wrong) is that the storage engines in clickhouse can basically do whatever they want but when a query is executed they're responsible for generating \"native format\" blocks for the query execution engine to operate on.\r\n\r\nTrue.\r\n\r\n> My understanding of the Array() column native format is that its basically $NUM_ROWS uint64 offsets where each offset defines the beginning of an individual array, and then each array is an integer describing the number of elements in the array, and then the array itself is just encoded using the standard native format encoding of a non-nullable column for that type (so Array(uint64) the array itself would just be $ARRAY_LENGTH 8 byte uint64s)\r\n\r\nAlmost correct. The values may be represented by any column, including Nullable and LowCardinality... and LowCardinality(Nullable(...)) as well.\r\n\r\n> That implies to me that implementing Array(LowCardinality(String)) would be difficult because the format would imply a dictionary per array\r\n\r\nBut `Array(LowCardinality(String))` already works. It doesn't use dictionary per array. Dictionaries are used for column with array values and in this column, array bounds are not accounted (they are accounted in offsets column) - all elements of all arrays are simply placed one to each other in a single column in memory.\r\n\r\nWhat this task is about is to optimize functions calculation for `Array(LowCardinality(...))`. Currently, LowCardinality is converted to full column first and then function is calculated. The goal is to calculate function once per each dictionary value - it's what is already done for LowCardinality without Array.\n",
  "created_at": "2020-07-16T15:18:33Z",
  "modified_files": [
    "base/common/StringRef.h",
    "src/Columns/ColumnLowCardinality.h",
    "src/Columns/ColumnNullable.cpp",
    "src/Columns/ColumnNullable.h",
    "src/Columns/ColumnUnique.h",
    "src/Columns/ColumnVector.h",
    "src/Columns/IColumnUnique.h",
    "src/Columns/ReverseIndex.h",
    "src/Functions/array/arrayIndex.h",
    "src/Functions/array/countEqual.cpp",
    "src/Functions/array/has.cpp",
    "src/Functions/array/indexOf.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/array_index_low_cardinality_numbers.xml",
    "b/tests/performance/array_index_low_cardinality_strings.xml",
    "tests/queries/0_stateless/00931_low_cardinality_read_with_empty_array.sql",
    "tests/queries/0_stateless/00945_bloom_filter_index.sql",
    "b/tests/queries/0_stateless/01414_low_cardinality_nullable.reference",
    "b/tests/queries/0_stateless/01414_low_cardinality_nullable.sql",
    "b/tests/queries/0_stateless/01441_low_cardinality_array_index.reference",
    "b/tests/queries/0_stateless/01441_low_cardinality_array_index.sql"
  ]
}