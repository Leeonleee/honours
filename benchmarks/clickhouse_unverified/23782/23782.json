{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23782,
  "instance_id": "ClickHouse__ClickHouse-23782",
  "issue_numbers": [
    "21613"
  ],
  "base_commit": "f537a6ee5183212d22cc402468e39d8a17c91b37",
  "patch": "diff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp\nindex e0e246b8af4f..784beb9fc3a2 100644\n--- a/src/Functions/array/arrayAggregation.cpp\n+++ b/src/Functions/array/arrayAggregation.cpp\n@@ -15,6 +15,8 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int DECIMAL_OVERFLOW;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n }\n \n enum class AggregateOperation\n@@ -22,7 +24,8 @@ enum class AggregateOperation\n     min,\n     max,\n     sum,\n-    average\n+    average,\n+    product\n };\n \n /**\n@@ -54,6 +57,12 @@ struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::average>\n     using Result = Float64;\n };\n \n+template <typename ArrayElement>\n+struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::product>\n+{\n+    using Result = Float64;\n+};\n+\n template <typename ArrayElement>\n struct ArrayAggregateResultImpl<ArrayElement, AggregateOperation::sum>\n {\n@@ -86,7 +95,7 @@ struct ArrayAggregateImpl\n             using Types = std::decay_t<decltype(types)>;\n             using DataType = typename Types::LeftType;\n \n-            if constexpr (aggregate_operation == AggregateOperation::average)\n+            if constexpr (aggregate_operation == AggregateOperation::average || aggregate_operation == AggregateOperation::product)\n             {\n                 result = std::make_shared<DataTypeFloat64>();\n \n@@ -124,17 +133,17 @@ struct ArrayAggregateImpl\n     template <typename Element>\n     static NO_SANITIZE_UNDEFINED bool executeType(const ColumnPtr & mapped, const ColumnArray::Offsets & offsets, ColumnPtr & res_ptr)\n     {\n-        using Result = ArrayAggregateResult<Element, aggregate_operation>;\n+        using ResultType = ArrayAggregateResult<Element, aggregate_operation>;\n         using ColVecType = std::conditional_t<IsDecimalNumber<Element>, ColumnDecimal<Element>, ColumnVector<Element>>;\n-        using ColVecResult = std::conditional_t<IsDecimalNumber<Result>, ColumnDecimal<Result>, ColumnVector<Result>>;\n+        using ColVecResultType = std::conditional_t<IsDecimalNumber<ResultType>, ColumnDecimal<ResultType>, ColumnVector<ResultType>>;\n \n-        /// For average of array we return Float64 as result, but we want to keep precision\n-        /// so we convert to Float64 as last step, but intermediate sum is represented as result of sum operation\n-        static constexpr bool is_average_operation = aggregate_operation == AggregateOperation::average;\n+        /// For average and product of array we return Float64 as result, but we want to keep precision\n+        /// so we convert to Float64 as last step, but intermediate value is represented as result of sum operation\n+        static constexpr bool is_average_or_product_operation = aggregate_operation == AggregateOperation::average ||\n+            aggregate_operation == AggregateOperation::product;\n         using SummAggregationType = ArrayAggregateResult<Element, AggregateOperation::sum>;\n \n-        using AggregationType = std::conditional_t<is_average_operation, SummAggregationType, Result>;\n-\n+        using AggregationType = std::conditional_t<is_average_or_product_operation, SummAggregationType, ResultType>;\n \n         const ColVecType * column = checkAndGetColumn<ColVecType>(&*mapped);\n \n@@ -147,18 +156,15 @@ struct ArrayAggregateImpl\n                 return false;\n \n             const AggregationType x = column_const->template getValue<Element>(); // NOLINT\n-            const typename ColVecType::Container & data\n-                = checkAndGetColumn<ColVecType>(&column_const->getDataColumn())->getData();\n+            const auto & data = checkAndGetColumn<ColVecType>(&column_const->getDataColumn())->getData();\n \n-            typename ColVecResult::MutablePtr res_column;\n+            typename ColVecResultType::MutablePtr res_column;\n             if constexpr (IsDecimalNumber<Element>)\n-            {\n-                res_column = ColVecResult::create(offsets.size(), data.getScale());\n-            }\n+                res_column = ColVecResultType::create(offsets.size(), data.getScale());\n             else\n-                res_column = ColVecResult::create(offsets.size());\n+                res_column = ColVecResultType::create(offsets.size());\n \n-            typename ColVecResult::Container & res = res_column->getData();\n+            auto & res = res_column->getData();\n \n             size_t pos = 0;\n             for (size_t i = 0; i < offsets.size(); ++i)\n@@ -178,13 +184,45 @@ struct ArrayAggregateImpl\n                 {\n                     if constexpr (IsDecimalNumber<Element>)\n                     {\n-                        res[i] = DecimalUtils::convertTo<Result>(x, data.getScale());\n+                        res[i] = DecimalUtils::convertTo<ResultType>(x, data.getScale());\n                     }\n                     else\n                     {\n                         res[i] = x;\n                     }\n                 }\n+                else if constexpr (aggregate_operation == AggregateOperation::product)\n+                {\n+                    size_t array_size = offsets[i] - pos;\n+                    AggregationType product = x;\n+\n+                    if constexpr (IsDecimalNumber<Element>)\n+                    {\n+                        using T = decltype(x.value);\n+                        T x_val = x.value;\n+\n+                        for (size_t array_index = 1; array_index < array_size; ++array_index)\n+                        {\n+                            T product_val = product.value;\n+\n+                            if (common::mulOverflow(x_val, product_val, product.value))\n+                                throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n+                        }\n+\n+                        auto result_scale = data.getScale() * array_size;\n+                        if (unlikely(result_scale > DecimalUtils::max_precision<AggregationType>))\n+                            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Scale {} is out of bounds\", result_scale);\n+\n+                        res[i] = DecimalUtils::convertTo<ResultType>(product, data.getScale() * array_size);\n+                    }\n+                    else\n+                    {\n+                        for (size_t array_index = 1; array_index < array_size; ++array_index)\n+                            product = product * x;\n+\n+                        res[i] = product;\n+                    }\n+                }\n \n                 pos = offsets[i];\n             }\n@@ -193,30 +231,30 @@ struct ArrayAggregateImpl\n             return true;\n         }\n \n-        const typename ColVecType::Container & data = column->getData();\n+        const auto & data = column->getData();\n \n-        typename ColVecResult::MutablePtr res_column;\n+        typename ColVecResultType::MutablePtr res_column;\n         if constexpr (IsDecimalNumber<Element>)\n-            res_column = ColVecResult::create(offsets.size(), data.getScale());\n+            res_column = ColVecResultType::create(offsets.size(), data.getScale());\n         else\n-            res_column = ColVecResult::create(offsets.size());\n+            res_column = ColVecResultType::create(offsets.size());\n \n-        typename ColVecResult::Container & res = res_column->getData();\n+        typename ColVecResultType::Container & res = res_column->getData();\n \n         size_t pos = 0;\n         for (size_t i = 0; i < offsets.size(); ++i)\n         {\n-            AggregationType s = 0;\n+            AggregationType aggregate_value = 0;\n \n             /// Array is empty\n             if (offsets[i] == pos)\n             {\n-                res[i] = s;\n+                res[i] = aggregate_value;\n                 continue;\n             }\n \n             size_t count = 1;\n-            s = data[pos]; // NOLINT\n+            aggregate_value = data[pos]; // NOLINT\n             ++pos;\n \n             for (; pos < offsets[i]; ++pos)\n@@ -226,20 +264,36 @@ struct ArrayAggregateImpl\n                 if constexpr (aggregate_operation == AggregateOperation::sum ||\n                             aggregate_operation == AggregateOperation::average)\n                 {\n-                    s += element;\n+                    aggregate_value += element;\n                 }\n                 else if constexpr (aggregate_operation == AggregateOperation::min)\n                 {\n-                    if (element < s)\n+                    if (element < aggregate_value)\n                     {\n-                        s = element;\n+                        aggregate_value = element;\n                     }\n                 }\n                 else if constexpr (aggregate_operation == AggregateOperation::max)\n                 {\n-                    if (element > s)\n+                    if (element > aggregate_value)\n                     {\n-                        s = element;\n+                        aggregate_value = element;\n+                    }\n+                }\n+                else if constexpr (aggregate_operation == AggregateOperation::product)\n+                {\n+                    if constexpr (IsDecimalNumber<Element>)\n+                    {\n+                        using AggregateValueDecimalUnderlyingValue = decltype(aggregate_value.value);\n+                        AggregateValueDecimalUnderlyingValue current_aggregate_value = aggregate_value.value;\n+                        AggregateValueDecimalUnderlyingValue element_value = static_cast<AggregateValueDecimalUnderlyingValue>(element.value);\n+\n+                        if (common::mulOverflow(current_aggregate_value, element_value, aggregate_value.value))\n+                            throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n+                    }\n+                    else\n+                    {\n+                        aggregate_value *= element;\n                     }\n                 }\n \n@@ -250,17 +304,26 @@ struct ArrayAggregateImpl\n             {\n                 if constexpr (IsDecimalNumber<Element>)\n                 {\n-                    s = s / count;\n-                    res[i] = DecimalUtils::convertTo<Result>(s, data.getScale());\n+                    aggregate_value = aggregate_value / count;\n+                    res[i] = DecimalUtils::convertTo<ResultType>(aggregate_value, data.getScale());\n                 }\n                 else\n                 {\n-                    res[i] = static_cast<Result>(s) / count;\n+                    res[i] = static_cast<ResultType>(aggregate_value) / count;\n                 }\n             }\n+            else if constexpr (aggregate_operation == AggregateOperation::product && IsDecimalNumber<Element>)\n+            {\n+                auto result_scale = data.getScale() * count;\n+\n+                if (unlikely(result_scale > DecimalUtils::max_precision<AggregationType>))\n+                    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Scale {} is out of bounds\", result_scale);\n+\n+                res[i] = DecimalUtils::convertTo<ResultType>(aggregate_value, result_scale);\n+            }\n             else\n             {\n-                res[i] = s;\n+                res[i] = aggregate_value;\n             }\n         }\n \n@@ -291,7 +354,7 @@ struct ArrayAggregateImpl\n             executeType<Decimal128>(mapped, offsets, res))\n             return res;\n         else\n-            throw Exception(\"Unexpected column for arraySum: \" + mapped->getName(), ErrorCodes::ILLEGAL_COLUMN);\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arraySum: {}\" + mapped->getName());\n     }\n };\n \n@@ -307,12 +370,16 @@ using FunctionArraySum = FunctionArrayMapped<ArrayAggregateImpl<AggregateOperati\n struct NameArrayAverage { static constexpr auto name = \"arrayAvg\"; };\n using FunctionArrayAverage = FunctionArrayMapped<ArrayAggregateImpl<AggregateOperation::average>, NameArrayAverage>;\n \n+struct NameArrayProduct { static constexpr auto name = \"arrayProduct\"; };\n+using FunctionArrayProduct = FunctionArrayMapped<ArrayAggregateImpl<AggregateOperation::product>, NameArrayProduct>;\n+\n void registerFunctionArrayAggregation(FunctionFactory & factory)\n {\n     factory.registerFunction<FunctionArrayMin>();\n     factory.registerFunction<FunctionArrayMax>();\n     factory.registerFunction<FunctionArraySum>();\n     factory.registerFunction<FunctionArrayAverage>();\n+    factory.registerFunction<FunctionArrayProduct>();\n }\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01768_array_product.reference b/tests/queries/0_stateless/01768_array_product.reference\nnew file mode 100644\nindex 000000000000..af2508e1aff2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01768_array_product.reference\n@@ -0,0 +1,18 @@\n+Array product with constant column\n+720\tFloat64\n+24\tFloat64\n+3.5\tFloat64\n+6\tFloat64\n+Array product with non constant column\n+24\n+0\n+6\n+24\n+0\n+6\n+Types of aggregation result array product\n+Float64\tFloat64\tFloat64\tFloat64\n+Float64\tFloat64\tFloat64\tFloat64\n+Float64\tFloat64\tFloat64\n+Float64\tFloat64\n+Float64\tFloat64\tFloat64\ndiff --git a/tests/queries/0_stateless/01768_array_product.sql b/tests/queries/0_stateless/01768_array_product.sql\nnew file mode 100644\nindex 000000000000..75056888ef26\n--- /dev/null\n+++ b/tests/queries/0_stateless/01768_array_product.sql\n@@ -0,0 +1,26 @@\n+SELECT 'Array product with constant column';\n+\n+SELECT arrayProduct([1,2,3,4,5,6]) as a, toTypeName(a);\n+SELECT arrayProduct(array(1.0,2.0,3.0,4.0)) as a, toTypeName(a);\n+SELECT arrayProduct(array(1,3.5)) as a, toTypeName(a);\n+SELECT arrayProduct([toDecimal64(1,8), toDecimal64(2,8), toDecimal64(3,8)]) as a, toTypeName(a);\n+\n+SELECT 'Array product with non constant column';\n+\n+DROP TABLE IF EXISTS test_aggregation;\n+CREATE TABLE test_aggregation (x Array(Int)) ENGINE=TinyLog;\n+INSERT INTO test_aggregation VALUES ([1,2,3,4]), ([]), ([1,2,3]);\n+SELECT arrayProduct(x) FROM test_aggregation;\n+DROP TABLE test_aggregation;\n+\n+CREATE TABLE test_aggregation (x Array(Decimal64(8))) ENGINE=TinyLog;\n+INSERT INTO test_aggregation VALUES ([1,2,3,4]), ([]), ([1,2,3]);\n+SELECT arrayProduct(x) FROM test_aggregation;\n+DROP TABLE test_aggregation;\n+\n+SELECT 'Types of aggregation result array product';\n+SELECT toTypeName(arrayProduct([toInt8(0)])), toTypeName(arrayProduct([toInt16(0)])), toTypeName(arrayProduct([toInt32(0)])), toTypeName(arrayProduct([toInt64(0)]));\n+SELECT toTypeName(arrayProduct([toUInt8(0)])), toTypeName(arrayProduct([toUInt16(0)])), toTypeName(arrayProduct([toUInt32(0)])), toTypeName(arrayProduct([toUInt64(0)]));\n+SELECT toTypeName(arrayProduct([toInt128(0)])), toTypeName(arrayProduct([toInt256(0)])), toTypeName(arrayProduct([toUInt256(0)]));\n+SELECT toTypeName(arrayProduct([toFloat32(0)])), toTypeName(arrayProduct([toFloat64(0)]));\n+SELECT toTypeName(arrayProduct([toDecimal32(0, 8)])), toTypeName(arrayProduct([toDecimal64(0, 8)])), toTypeName(arrayProduct([toDecimal128(0, 8)]));\n",
  "problem_statement": "arrayProduct\nfor the last year I replied 3 times with a silly snippet:\r\n```\r\nSELECT\r\n    [2, 3, 4] AS x,\r\n    pow(2, arraySum(i -> log2(i), x)) AS arrayProduct\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500arrayProduct\u2500\u2510\r\n\u2502 [2,3,4] \u2502           24 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI think we need a function to multiply elements of an array.\n",
  "hints_text": "assign to me, should I use `pow(2, arraySum(i -> log2(i), x))` the algorithm  to implement arrayProduct?\n> assign to me, should I use pow(2, arraySum(i -> log2(i), x)) the algorithm to implement arrayProduct?\r\n\r\nI don't think so, it would produce Float value from multiplying integers.\r\n\r\n\r\n```\r\nSELECT\r\n    [2, 3, 40] AS x,\r\n    pow(2, arraySum(i -> log2(i), x)) AS arrayProduct\r\n\r\nQuery id: 1fcc62b2-fd29-4cff-b9ed-f4e434c9043a\r\n\r\n[LAPTOP-319G0GMQ] 2021.03.12 04:55:33.309638 [ 10268 ] {1fcc62b2-fd29-4cff-b9ed-f4e434c9043a} <Debug> executeQuery: (from 127.0.0.1:38504, using production parser) SELECT [2, 3, 40] AS x, pow(2, arraySum(i -> log2(i), x)) AS arrayProduct;\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500arrayProduct\u2500\u2510\r\n\u2502 [2,3,40] \u2502 240.00000000000003 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThere is actually arrayFold function in development, which is generalized version of arrayProduct i guess.\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/pull/21589\r\n\nIt should calculate `2*3*4`\r\n\r\narrayProduct([2,3,4]) -> `2*3*4` = 24\n> should I use pow(2, arraySum(i -> log2(i), x)) the algorithm to implement arrayProduct?\r\n\r\nJust simply do the multiplication.\nIt should be \r\naccumulate(v.begin(), v.end(), 1, multiplies<int>())\r\n This function in c++ multiplies all the element of the array in c++\r\nvector<int>arr = {1,2,3,4};\r\nint ans =  accumulate(arr.begin(), arr.end(), 1, multiplies<int>())\r\nans = 24\nYes, you can implement product of elements via `arrayFold`: `SELECT arrayFold(x,acc -> x*acc, [1,2,3,4,5], toInt64(1));`\r\nPR #21589 (`arrayFold` function) on review now.\n@den-crane \r\nWhen I process Array(Decimal(P, S)) , which kind of type should  I return ?  Decimal(P,S) or enlarge scale by multiply the array size, or Decimal128(s)?\r\nBecause I need to return the type  in `getReturnTypeImpl` function, so I think the scale of Decimal of the result should be static not dynamic like operator `*` in below example. \r\nSo Can I just make the result type of `DataTypeDecimal<Decimal128>(DecimalUtils::max_precision<Decimal128>, DecimalUtils::max_precision<Decimal128>-1)` == `Decimal128(38, 37)`?\r\n\r\n\r\nI find the type of operator  `*` result's  scale enlarged by add all the operators `8 = 4+4`: \r\n```\r\nselect toDecimal32(0.111, 4) as a,  toDecimal32(0.112, 4) as b, a *b\u3000as k , toTypeName(k) ,toTypeName(a), toTypeName(b);\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500b\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500k\u2500\u252c\u2500toTypeName(multiply(toDecimal32(0.111, 4), toDecimal32(0.112, 4)))\u2500\u252c\u2500toTy\u2502\r\npeName(toDecimal32(0.111, 4))\u2500\u252c\u2500toTypeName(toDecimal32(0.112, 4))\u2500\u2510                                       \u2502\r\n\u2502 0.1110 \u2502 0.1120 \u2502 0.01243200 \u2502 Decimal(9, 8)                                                      \u2502 Deci\u2502\r\nmal(9, 4)                     \u2502 Decimal(9, 4)                     \u2502                                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2502\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nand `Decimal(3, 1)+Decimal(3, 1)=Decimal(9, 1)`, \r\n`Decimal(3, 1) * Decimal(3, 1) = Decimal(9, 2)`",
  "created_at": "2021-04-30T06:56:34Z",
  "modified_files": [
    "src/Functions/array/arrayAggregation.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01768_array_product.reference",
    "b/tests/queries/0_stateless/01768_array_product.sql"
  ]
}