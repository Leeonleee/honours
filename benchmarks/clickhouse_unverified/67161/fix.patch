diff --git a/.gitmodules b/.gitmodules
index 69958ef07cb8..e596765f112e 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -357,6 +357,9 @@
 [submodule "contrib/mongo-c-driver"]
 	path = contrib/mongo-c-driver
 	url = https://github.com/ClickHouse/mongo-c-driver.git
+[submodule "contrib/sz3"]
+	path = contrib/sz3
+	url = https://github.com/ClickHouse/SZ3.git
 [submodule "contrib/numactl"]
 	path = contrib/numactl
 	url = https://github.com/ClickHouse/numactl.git
diff --git a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt
index e9d6b0f1f8d1..b46aae34d640 100644
--- a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt
+++ b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt
@@ -582,6 +582,7 @@ LogsLevel
 Logstash
 LookML
 LoongArch
+Lossy
 LowCardinality
 LpDistance
 LpNorm
@@ -2209,6 +2210,7 @@ loghouse
 london
 lookups
 loongarch
+lossy
 lowCardinalityIndices
 lowCardinalityKeys
 lowcardinality
diff --git a/contrib/CMakeLists.txt b/contrib/CMakeLists.txt
index fbf4747f462b..dcbec7a0b9ed 100644
--- a/contrib/CMakeLists.txt
+++ b/contrib/CMakeLists.txt
@@ -250,6 +250,8 @@ add_contrib (sha3iuf-cmake SHA3IUF)
 
 add_contrib (bech32)
 
+add_contrib (sz3-cmake sz3)
+
 # Put all targets defined here and in subdirectories under "contrib/<immediate-subdir>" folders in GUI-based IDEs.
 # Some of third-party projects may override CMAKE_FOLDER or FOLDER property of their targets, so they would not appear
 # in "contrib/..." as originally planned, so we workaround this by fixing FOLDER properties of all targets manually,
diff --git a/contrib/sz3 b/contrib/sz3
new file mode 160000
index 000000000000..346c37af88a9
--- /dev/null
+++ b/contrib/sz3
@@ -0,0 +1,1 @@
+Subproject commit 346c37af88a9e0201729f4a73da90b6aff3481a7
diff --git a/contrib/sz3-cmake/CMakeLists.txt b/contrib/sz3-cmake/CMakeLists.txt
new file mode 100644
index 000000000000..eac9974a8873
--- /dev/null
+++ b/contrib/sz3-cmake/CMakeLists.txt
@@ -0,0 +1,23 @@
+option(ENABLE_SZ3 "Enable SZ3" ${ENABLE_LIBRARIES})
+
+if (NOT ENABLE_SZ3)
+    message (STATUS "Not using SZ3")
+    return()
+endif()
+
+# SZ3 is still under development, it writes its current version into the serialized compressed data.
+# Therefore, update SZ3 with care to avoid breaking existing persistencies.
+
+# File contrib/sz3-cmake/SZ3/version.hpp was statically generated from version.hpp.in in contrib/sz3.
+# It must be updated when the library is updated. Refer to contrib/sz3/README.md for that (section #Installation).
+# Turn off ska hash because ska::unordered_map (this is inner hash map) doesn't work with UB sanitizer.
+set(SZ3_USE_SKA_HASH OFF)
+set(SZ3_PROJECT_DIR "${ClickHouse_SOURCE_DIR}/contrib/sz3")
+set(SZ3_SOURCE_DIR "${SZ3_PROJECT_DIR}/include")
+set(SZ3_VERSION_DIR "${ClickHouse_SOURCE_DIR}/contrib/sz3-cmake")
+
+add_library(_sz3 INTERFACE)
+target_include_directories(_sz3 SYSTEM INTERFACE ${SZ3_SOURCE_DIR})
+target_include_directories(_sz3 SYSTEM INTERFACE ${SZ3_VERSION_DIR})
+
+add_library(ch_contrib::sz3 ALIAS _sz3)
diff --git a/contrib/sz3-cmake/SZ3/version.hpp b/contrib/sz3-cmake/SZ3/version.hpp
new file mode 100644
index 000000000000..ee571b4d9c11
--- /dev/null
+++ b/contrib/sz3-cmake/SZ3/version.hpp
@@ -0,0 +1,36 @@
+//
+// DO NOT MODIFY version.hpp, it is automatically generated by cmake
+// Change the version numbers in CMakeLists.txt
+//
+
+#ifndef SZ3_VERSION_HPP
+#define SZ3_VERSION_HPP
+#include <sstream>
+
+#define SZ3_MAGIC_NUMBER 0xF342F310
+
+#define SZ3_NAME "SZ3"
+#define SZ3_VER  "3.2.2"
+#define SZ3_VER_MAJOR 3
+#define SZ3_VER_MINOR 2
+#define SZ3_VER_PATCH 2
+#define SZ3_VER_TWEAK 0
+
+#define SZ3_DATA_VER "3.2.2"
+
+inline uint32_t versionInt(const std::string& version) {
+    uint32_t major = 0, minor = 0, patch = 0;
+    char dot;
+    std::stringstream ss(version);
+    ss >> major >> dot >> minor >> dot >> patch;
+    return (major << 24) | (minor << 16) | (patch<<8);
+}
+
+inline std::string versionStr(uint32_t version) {
+    uint32_t major = (version >> 24) & 0xFF;
+    uint32_t minor = (version >> 16) & 0xFF;
+    uint32_t patch = (version >> 8) & 0xFF;
+    return std::to_string(major) + "." + std::to_string(minor) + "." + std::to_string(patch);
+}
+
+#endif //SZ3_VERSION_HPP
diff --git a/docs/en/sql-reference/statements/create/table.md b/docs/en/sql-reference/statements/create/table.md
index 931fbc473a5f..d923c4aad9ce 100644
--- a/docs/en/sql-reference/statements/create/table.md
+++ b/docs/en/sql-reference/statements/create/table.md
@@ -465,6 +465,10 @@ These codecs are designed to make compression more effective by exploiting speci
 
 `FPC(level, float_size)` - Repeatedly predicts the next floating point value in the sequence using the better of two predictors, then XORs the actual with the predicted value, and leading-zero compresses the result. Similar to Gorilla, this is efficient when storing a series of floating point values that change slowly. For 64-bit values (double), FPC is faster than Gorilla, for 32-bit values your mileage may vary. Possible `level` values: 1-28, the default value is 12.  Possible `float_size` values: 4, 8, the default value is `sizeof(type)` if type is Float. In all other cases, it's 4. For a detailed description of the algorithm see [High Throughput Compression of Double-Precision Floating-Point Data](https://userweb.cs.txstate.edu/~burtscher/papers/dcc07a.pdf).
 
+#### SZ3 {#sz3}
+
+`SZ3` or `SZ3(algorithm, error_bound_mode, error_bound)` - A lossy but error-bound codec ([SZ3 Lossy Compressor](https://szcompressor.org/)) for columns of type Float32, Float64, Array(Float32), or Array(Float64). If the column type is of array type, then all inserted arrays must have the same length. Supported values for 'algorithm' are `ALGO_LORENZO_REG`, `ALGO_INTERP_LORENZO` and `ALGO_INTERP`. Supported values for 'error_bound_mode' are `ABS`, `REL`, `PSNR` and `ABS_AND_REL`. Argument 'error_bound' is the maximum error and of type Float64.
+
 #### T64 {#t64}
 
 `T64` — Compression approach that crops unused high bits of values in integer data types (including `Enum`, `Date` and `DateTime`). At each step of its algorithm, codec takes a block of 64 values, puts them into 64x64 bit matrix, transposes it, crops the unused bits of values and returns the rest as a sequence. Unused bits are the bits, that do not differ between maximum and minimum values in the whole data part for which the compression is used.
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index d0fab9702f6c..2b4cef4b14bd 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -111,6 +111,10 @@ list (REMOVE_ITEM clickhouse_common_io_sources Common/malloc.cpp Common/new_dele
 add_headers_and_sources(clickhouse_compression Compression)
 add_library(clickhouse_compression ${clickhouse_compression_headers} ${clickhouse_compression_sources})
 
+if (TARGET ch_contrib::sz3)
+    target_link_libraries (clickhouse_compression PUBLIC ch_contrib::sz3)
+endif()
+
 add_headers_and_sources(dbms Disks/IO)
 add_headers_and_sources(dbms Disks/ObjectStorages)
 if (TARGET ch_contrib::sqlite)
diff --git a/src/Common/config.h.in b/src/Common/config.h.in
index c11e4dc8bcd0..4b3739570009 100644
--- a/src/Common/config.h.in
+++ b/src/Common/config.h.in
@@ -56,6 +56,7 @@
 #cmakedefine01 USE_SQLITE
 #cmakedefine01 USE_NURAFT
 #cmakedefine01 USE_KRB5
+#cmakedefine01 USE_SZ3
 #cmakedefine01 USE_FILELOG
 #cmakedefine01 USE_BLAKE3
 #cmakedefine01 USE_USEARCH
diff --git a/src/Compression/CompressionCodecDeflateQpl.h b/src/Compression/CompressionCodecDeflateQpl.h
index 75d3527082f5..b85c52521725 100644
--- a/src/Compression/CompressionCodecDeflateQpl.h
+++ b/src/Compression/CompressionCodecDeflateQpl.h
@@ -110,7 +110,7 @@ class CompressionCodecDeflateQpl final : public ICompressionCodec
     bool isGenericCompression() const override { return true; }
     bool isDeflateQpl() const override { return true; }
 
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Requires hardware support for Intel’s QuickAssist Technology for DEFLATE compression; enhanced performance for specific hardware.";
     }
diff --git a/src/Compression/CompressionCodecDelta.cpp b/src/Compression/CompressionCodecDelta.cpp
index f3ff161eef82..79d7b76f3e28 100644
--- a/src/Compression/CompressionCodecDelta.cpp
+++ b/src/Compression/CompressionCodecDelta.cpp
@@ -29,7 +29,7 @@ class CompressionCodecDelta : public ICompressionCodec
     bool isGenericCompression() const override { return false; }
     bool isDeltaCompression() const override { return true; }
 
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Preprocessor (should be followed by some compression codec). Stores difference between neighboring values; good for monotonically increasing or decreasing data.";
     }
diff --git a/src/Compression/CompressionCodecDoubleDelta.cpp b/src/Compression/CompressionCodecDoubleDelta.cpp
index 15ae8515a8ee..adbacd9d41f2 100644
--- a/src/Compression/CompressionCodecDoubleDelta.cpp
+++ b/src/Compression/CompressionCodecDoubleDelta.cpp
@@ -138,11 +138,7 @@ class CompressionCodecDoubleDelta : public ICompressionCodec
     bool isCompression() const override { return true; }
     bool isGenericCompression() const override { return false; }
     bool isDeltaCompression() const override { return true; }
-    std::string getDescription() const override
-    {
-        return "Stores difference between neighboring delta values; suitable for time series data.";
-    }
-
+    String getDescription() const override { return "Stores difference between neighboring delta values; suitable for time series data."; }
 
 private:
     UInt8 data_bytes_size;
diff --git a/src/Compression/CompressionCodecEncrypted.h b/src/Compression/CompressionCodecEncrypted.h
index 632294e598ee..229eccf032b9 100644
--- a/src/Compression/CompressionCodecEncrypted.h
+++ b/src/Compression/CompressionCodecEncrypted.h
@@ -110,11 +110,8 @@ class CompressionCodecEncrypted final : public ICompressionCodec
     bool isCompression() const override { return false; }
     bool isGenericCompression() const override { return false; }
     bool isEncryption() const override { return true; }
+    String getDescription() const override { return "Encrypts and decrypts blocks with AES-128 in GCM-SIV mode (RFC-8452)."; }
 
-    std::string getDescription() const override
-    {
-        return "Encrypts and decrypts blocks with AES-128 in GCM-SIV mode (RFC-8452).";
-    }
 protected:
     UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;
 
diff --git a/src/Compression/CompressionCodecFPC.cpp b/src/Compression/CompressionCodecFPC.cpp
index e6ba5c6c7ae2..1b35a0612681 100644
--- a/src/Compression/CompressionCodecFPC.cpp
+++ b/src/Compression/CompressionCodecFPC.cpp
@@ -21,7 +21,7 @@ namespace DB
 class CompressionCodecFPC : public ICompressionCodec
 {
 public:
-    CompressionCodecFPC(UInt8 float_size, UInt8 compression_level);
+    CompressionCodecFPC(UInt8 float_width_, UInt8 compression_level_);
 
     uint8_t getMethodByte() const override;
 
@@ -40,18 +40,14 @@ class CompressionCodecFPC : public ICompressionCodec
     bool isCompression() const override { return true; }
     bool isGenericCompression() const override { return false; }
     bool isFloatingPointTimeSeriesCodec() const override { return true; }
-    std::string getDescription() const override
-    {
-        return "High Throughput Compression of Double-Precision Floating-Point Data.";
-    }
-
+    String getDescription() const override { return "High Throughput Compression of Double-Precision Floating-Point Data."; }
 
 private:
     static constexpr UInt32 HEADER_SIZE = 2;
 
     // below members are used by compression, decompression ignores them:
     const UInt8 float_width; // size of uncompressed float in bytes
-    const UInt8 level; // compression level, 2^level * float_width is the size of predictors table in bytes
+    const UInt8 compression_level; // compression level, 2^level * float_width is the size of predictors table in bytes
 };
 
 
@@ -74,10 +70,11 @@ void CompressionCodecFPC::updateHash(SipHash & hash) const
     getCodecDesc()->updateTreeHash(hash, /*ignore_aliases=*/ true);
 }
 
-CompressionCodecFPC::CompressionCodecFPC(UInt8 float_size, UInt8 compression_level)
-    : float_width{float_size}, level{compression_level}
+CompressionCodecFPC::CompressionCodecFPC(UInt8 float_width_, UInt8 compression_level_)
+    : float_width(float_width_)
+    , compression_level(compression_level_)
 {
-    setCodecDescription("FPC", {std::make_shared<ASTLiteral>(static_cast<UInt64>(level))});
+    setCodecDescription("FPC", {std::make_shared<ASTLiteral>(static_cast<UInt64>(compression_level))});
 }
 
 UInt32 CompressionCodecFPC::getMaxCompressedDataSize(UInt32 uncompressed_size) const
@@ -91,20 +88,15 @@ UInt32 CompressionCodecFPC::getMaxCompressedDataSize(UInt32 uncompressed_size) c
 namespace
 {
 
-UInt8 getFloatBytesSize(const IDataType & column_type)
+UInt8 getFloatByteWidth(const IDataType & column_type)
 {
-    if (!WhichDataType(column_type).isFloat())
-    {
-        throw Exception(ErrorCodes::BAD_ARGUMENTS, "FPC codec is not applicable for {} because the data type is not float",
-                        column_type.getName());
-    }
+    if (!WhichDataType(column_type).isNativeFloat())
+        throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "Codec 'FPC' is not applicable for {} because the data type is not Float*",
+                column_type.getName());
 
-    if (auto float_size = column_type.getSizeOfValueInMemory(); float_size >= 4)
-    {
-        return static_cast<UInt8>(float_size);
-    }
-    throw Exception(ErrorCodes::BAD_ARGUMENTS, "FPC codec is not applicable for floats of size less than 4 bytes. Given type {}",
-                    column_type.getName());
+    return column_type.getSizeOfValueInMemory();
 }
 
 }
@@ -114,38 +106,35 @@ void registerCodecFPC(CompressionCodecFactory & factory)
     auto method_code = static_cast<UInt8>(CompressionMethodByte::FPC);
     auto codec_builder = [&](const ASTPtr & arguments, const IDataType * column_type) -> CompressionCodecPtr
     {
-        /// Set default float width to 4.
         UInt8 float_width = 4;
-        if (column_type != nullptr)
-            float_width = getFloatBytesSize(*column_type);
+        if (column_type)
+            float_width = getFloatByteWidth(*column_type);
 
         UInt8 level = CompressionCodecFPC::DEFAULT_COMPRESSION_LEVEL;
         if (arguments && !arguments->children.empty())
         {
             if (arguments->children.size() > 2)
-            {
                 throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_CODEC_TYPE,
-                                "FPC codec must have from 0 to 2 parameters, given {}", arguments->children.size());
-            }
+                                "Codec 'FPC' must have from 0 to 2 parameters, given {}", arguments->children.size());
 
-            const auto * literal = arguments->children.front()->as<ASTLiteral>();
+            const auto * literal = arguments->children[0]->as<ASTLiteral>();
             if (!literal || literal->value.getType() != Field::Types::Which::UInt64)
-                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "FPC codec argument must be unsigned integer");
+                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "1st argument of codec 'FPC' must be unsigned integer");
 
             level = literal->value.safeGet<UInt8>();
             if (level < 1 || level > CompressionCodecFPC::MAX_COMPRESSION_LEVEL)
-                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "FPC codec level must be between {} and {}",
+                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "Codec 'FPC' level must be between {} and {}",
                                 1, static_cast<int>(CompressionCodecFPC::MAX_COMPRESSION_LEVEL));
 
             if (arguments->children.size() == 2)
             {
                 literal = arguments->children[1]->as<ASTLiteral>();
                 if (!literal || !isInt64OrUInt64FieldType(literal->value.getType()))
-                    throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "FPC codec argument must be unsigned integer");
+                    throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "2nd argument of codec 'FPC' must be unsigned integer");
 
                 size_t user_float_width = literal->value.safeGet<UInt64>();
                 if (user_float_width != 4 && user_float_width != 8)
-                    throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "Float size for FPC codec can be 4 or 8, given {}", user_float_width);
+                    throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "Float size for codec 'FPC' can be 4 or 8, given {}", user_float_width);
                 float_width = static_cast<UInt8>(user_float_width);
             }
         }
@@ -473,7 +462,7 @@ class FPCOperation
 UInt32 CompressionCodecFPC::doCompressData(const char * source, UInt32 source_size, char * dest) const
 {
     dest[0] = static_cast<char>(float_width);
-    dest[1] = static_cast<char>(level);
+    dest[1] = static_cast<char>(compression_level);
 
     auto dest_size = getMaxCompressedDataSize(source_size);
     auto destination = std::as_writable_bytes(std::span(dest, dest_size).subspan(HEADER_SIZE));
@@ -481,13 +470,13 @@ UInt32 CompressionCodecFPC::doCompressData(const char * source, UInt32 source_si
     switch (float_width)
     {
         case sizeof(Float64):
-            return static_cast<UInt32>(HEADER_SIZE + FPCOperation<UInt64>(destination, level).encode(src));
+            return static_cast<UInt32>(HEADER_SIZE + FPCOperation<UInt64>(destination, compression_level).encode(src));
         case sizeof(Float32):
-            return static_cast<UInt32>(HEADER_SIZE + FPCOperation<UInt32>(destination, level).encode(src));
+            return static_cast<UInt32>(HEADER_SIZE + FPCOperation<UInt32>(destination, compression_level).encode(src));
         default:
             break;
     }
-    throw Exception(ErrorCodes::CANNOT_COMPRESS, "Cannot compress with FPC codec. File has incorrect float width");
+    throw Exception(ErrorCodes::CANNOT_COMPRESS, "Cannot compress with codec 'FPC'. File has incorrect float width");
 }
 
 void CompressionCodecFPC::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const
diff --git a/src/Compression/CompressionCodecGCD.cpp b/src/Compression/CompressionCodecGCD.cpp
index 998975e2c554..34065da4d741 100644
--- a/src/Compression/CompressionCodecGCD.cpp
+++ b/src/Compression/CompressionCodecGCD.cpp
@@ -31,12 +31,11 @@ class CompressionCodecGCD : public ICompressionCodec
 
     bool isCompression() const override { return false; }
     bool isGenericCompression() const override { return false; }
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Preprocessor. Greatest common divisor compression; divides values by a common divisor; effective for divisible integer sequences.";
     }
 
-
 private:
     const UInt8 gcd_bytes_size;
 };
diff --git a/src/Compression/CompressionCodecGorilla.cpp b/src/Compression/CompressionCodecGorilla.cpp
index 6a22be45e812..5693d2205d44 100644
--- a/src/Compression/CompressionCodecGorilla.cpp
+++ b/src/Compression/CompressionCodecGorilla.cpp
@@ -124,12 +124,11 @@ class CompressionCodecGorilla : public ICompressionCodec
     bool isGenericCompression() const override { return false; }
     bool isFloatingPointTimeSeriesCodec() const override { return true; }
 
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Calculates XOR between current and previous value; suitable for slowly changing numbers.";
     }
 
-
 private:
     const UInt8 data_bytes_size;
 };
diff --git a/src/Compression/CompressionCodecLZ4.cpp b/src/Compression/CompressionCodecLZ4.cpp
index 136b7a98c838..4cb424b318cc 100644
--- a/src/Compression/CompressionCodecLZ4.cpp
+++ b/src/Compression/CompressionCodecLZ4.cpp
@@ -35,10 +35,7 @@ class CompressionCodecLZ4 : public ICompressionCodec
 
     bool isCompression() const override { return true; }
     bool isGenericCompression() const override { return true; }
-    std::string getDescription() const override
-    {
-        return "Extremely fast; good compression; balanced speed and efficiency.";
-    }
+    String getDescription() const override { return "Extremely fast; good compression; balanced speed and efficiency."; }
 
 private:
     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;
diff --git a/src/Compression/CompressionCodecMultiple.h b/src/Compression/CompressionCodecMultiple.h
index 35cb79f3e4d6..2c2573bacf54 100644
--- a/src/Compression/CompressionCodecMultiple.h
+++ b/src/Compression/CompressionCodecMultiple.h
@@ -28,11 +28,7 @@ class CompressionCodecMultiple final : public ICompressionCodec
     bool isCompression() const override;
     bool isGenericCompression() const override { return false; }
 
-    std::string getDescription() const override
-    {
-        return "Apply multiple codecs consecutively defined by user.";
-    }
-
+    String getDescription() const override { return "Apply multiple codecs consecutively defined by user."; }
 
 private:
     Codecs codecs;
diff --git a/src/Compression/CompressionCodecNone.h b/src/Compression/CompressionCodecNone.h
index 9f41a0c6f6cc..89cf12bbe826 100644
--- a/src/Compression/CompressionCodecNone.h
+++ b/src/Compression/CompressionCodecNone.h
@@ -25,11 +25,7 @@ class CompressionCodecNone final : public ICompressionCodec
     bool isGenericCompression() const override { return false; }
     bool isNone() const override { return true; }
 
-    std::string getDescription() const override
-    {
-        return "No compression at all. Can be used on the columns that can not be compressed anyway.";
-    }
-
+    String getDescription() const override { return "No compression. Can be used on columns that can not be compressed anyway."; }
 };
 
 }
diff --git a/src/Compression/CompressionCodecSZ3.cpp b/src/Compression/CompressionCodecSZ3.cpp
new file mode 100644
index 000000000000..7d8043a763cd
--- /dev/null
+++ b/src/Compression/CompressionCodecSZ3.cpp
@@ -0,0 +1,306 @@
+#include "config.h"
+
+#if USE_SZ3
+#  include "base/types.h"
+#  include "Common/Exception.h"
+#  include <Common/SipHash.h>
+#  include <Core/TypeId.h>
+#  include <Compression/CompressionFactory.h>
+#  include <Compression/CompressionInfo.h>
+#  include <Compression/ICompressionCodec.h>
+#  include <DataTypes/IDataType.h>
+#  include <IO/BufferWithOwnMemory.h>
+#  include <IO/WriteBuffer.h>
+#  include <IO/WriteHelpers.h>
+#  include <Interpreters/Context.h>
+#  include <Parsers/ASTLiteral.h>
+#  include <Parsers/IAST.h>
+
+#  include <SZ3/api/sz.hpp>
+#  include <SZ3/utils/Config.hpp>
+
+namespace DB
+{
+
+class CompressionCodecSZ3 : public ICompressionCodec
+{
+public:
+    CompressionCodecSZ3(UInt8 float_size_, SZ3::ALGO algorithm_, SZ3::EB error_bound_mode_, double error_value_);
+
+    uint8_t getMethodByte() const override;
+
+    UInt32 getAdditionalSizeAtTheEndOfBuffer() const override { return 0; }
+
+    void updateHash(SipHash & hash) const override;
+
+    void setAndCheckVectorDimension(size_t dimension) override;
+
+protected:
+    bool isCompression() const override { return true; }
+    bool isGenericCompression() const override { return true; }
+    /// SZ3 is still under development, it writes its current version into the serialized compressed data.
+    /// Therefore, update SZ3 with care to avoid breaking existing persistencies.
+    /// We mark it as experimental for now.
+    bool isLossyCompression() const override { return true; }
+    bool isExperimental() const override { return true; }
+    bool needsVectorDimensionUpfront() const override { return true; }
+    String getDescription() const override { return "SZ3 is a lossy compressor for floating-point data with error bounds."; }
+
+private:
+    UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;
+    void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;
+
+    UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;
+
+    std::optional<size_t> dimension;
+    const UInt8 float_width;
+    const SZ3::ALGO algorithm;
+    const SZ3::EB error_bound_mode;
+    const Float64 error_value;
+};
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+    extern const int CORRUPTED_DATA;
+    extern const int ILLEGAL_CODEC_PARAMETER;
+    extern const int LOGICAL_ERROR;
+}
+
+String getSZ3AlgorithmString(SZ3::ALGO algorithm)
+{
+    for (const auto & [algorithm_string, algorithm_id] : SZ3::ALGO_MAP)
+    {
+        if (algorithm_id == algorithm)
+            return algorithm_string;
+    }
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Invalid algorithm");
+}
+
+String getSZ3ErrorBoundModeString(SZ3::EB error_bound_mode)
+{
+    for (const auto & [error_bound_string, error_bound_mode_id] : SZ3::EB_MAP)
+    {
+        if (error_bound_mode_id == error_bound_mode)
+            return error_bound_string;
+    }
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Invalid error bound mode");
+}
+
+CompressionCodecSZ3::CompressionCodecSZ3(
+    UInt8 float_size_, SZ3::ALGO algorithm_, SZ3::EB error_bound_mode_, double error_value_)
+    : float_width(float_size_)
+    , algorithm(algorithm_)
+    , error_bound_mode(error_bound_mode_)
+    , error_value(error_value_)
+{
+    setCodecDescription(
+        "SZ3", {std::make_shared<ASTLiteral>(getSZ3AlgorithmString(algorithm)),
+                std::make_shared<ASTLiteral>(getSZ3ErrorBoundModeString(error_bound_mode)),
+                std::make_shared<ASTLiteral>(error_value)});
+}
+
+uint8_t CompressionCodecSZ3::getMethodByte() const
+{
+    return static_cast<uint8_t>(CompressionMethodByte::SZ3);
+}
+
+void CompressionCodecSZ3::updateHash(SipHash & hash) const
+{
+    getCodecDesc()->updateTreeHash(hash, true);
+    hash.update(float_width);
+}
+
+UInt32 CompressionCodecSZ3::getMaxCompressedDataSize(UInt32 uncompressed_size) const
+{
+    return sizeof(UInt8) + sizeof(SZ3::Config) + uncompressed_size;
+}
+
+UInt32 CompressionCodecSZ3::doCompressData(const char * source, UInt32 source_size, char * dest) const
+{
+    SZ3::Config config;
+
+    std::vector<size_t> result_dimensions;
+    size_t num_floats = (source_size / float_width) / dimension.value_or(1);
+
+    result_dimensions.push_back(num_floats);
+    result_dimensions.push_back(dimension.value_or(1));
+
+    config.setDims(result_dimensions.begin(), result_dimensions.end());
+
+    config.cmprAlgo = algorithm;
+    config.errorBoundMode = error_bound_mode;
+
+    switch (error_bound_mode)
+    {
+        case SZ3::EB_REL:
+            config.relErrorBound = error_value;
+            break;
+        case SZ3::EB_ABS:
+            config.absErrorBound = error_value;
+            break;
+        case SZ3::EB_PSNR:
+            config.psnrErrorBound = error_value;
+            break;
+        case SZ3::EB_L2NORM:
+            config.l2normErrorBound = error_value;
+            break;
+        default:
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Invalid error bound mode");
+    }
+
+    std::unique_ptr<char[]> compressed;
+    size_t compressed_size;
+    switch (float_width)
+    {
+        case 4: {
+            try
+            {
+                compressed.reset(SZ_compress(config, reinterpret_cast<const float *>(source), compressed_size));
+            }
+            catch (...)
+            {
+                throw Exception(ErrorCodes::CORRUPTED_DATA, "Unexpected data to compress");
+            }
+            break;
+        }
+        case 8: {
+            try
+            {
+                compressed.reset(SZ_compress(config, reinterpret_cast<const double *>(source), compressed_size));
+            }
+            catch (...)
+            {
+                throw Exception(ErrorCodes::CORRUPTED_DATA, "Unexpected data to compress");
+            }
+            break;
+        }
+        default:
+            throw Exception(ErrorCodes::CORRUPTED_DATA, "Unexpected float width in SZ3 compressed data");
+    }
+
+    size_t offset = 0;
+    memcpy(dest + offset, &float_width, sizeof(UInt8));
+    offset += sizeof(UInt8);
+
+    memcpy(dest + offset, compressed.get(), compressed_size);
+    return static_cast<UInt32>(offset + compressed_size);
+}
+
+void CompressionCodecSZ3::setAndCheckVectorDimension(size_t dimension_)
+{
+    if (dimension.has_value() && *dimension != dimension_)
+        throw Exception(ErrorCodes::BAD_ARGUMENTS, "Vector dimensions are not equals: {} and {}", dimension_, *dimension);
+    dimension = dimension_;
+}
+
+void CompressionCodecSZ3::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 /*uncompressed_size*/) const
+{
+    UInt8 width = static_cast<UInt8>(*source);
+    --source_size;
+    ++source;
+
+    SZ3::Config config;
+    switch (width)
+    {
+        case 4: {
+            try
+            {
+                float * dest_typed = reinterpret_cast<float *>(dest);
+                SZ_decompress<float>(config, const_cast<char *>(source), source_size, dest_typed);
+            }
+            catch (...)
+            {
+                throw Exception(ErrorCodes::CORRUPTED_DATA, "Unexpected data to compress");
+            }
+            break;
+        }
+        case 8: {
+            try
+            {
+                double * dest_typed = reinterpret_cast<double *>(dest);
+                SZ_decompress<double>(config, const_cast<char *>(source), source_size, dest_typed);
+            }
+            catch (...)
+            {
+                throw Exception(ErrorCodes::CORRUPTED_DATA, "Unexpected data to compress");
+            }
+            break;
+        }
+        default:
+            throw Exception(ErrorCodes::CORRUPTED_DATA, "Unexpected float width in SZ3 compressed data");
+    }
+}
+
+UInt8 getFloatByteWidth(const IDataType & column_type)
+{
+    if (!WhichDataType(column_type).isNativeFloat())
+        throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "Codec 'SZ3' is not applicable for {} because the data type is not Float*",
+                column_type.getName());
+
+    return column_type.getSizeOfValueInMemory();
+}
+
+SZ3::ALGO getSZ3Algorithm(const String & algorithm)
+{
+    return SZ3::ALGO_MAP.at(algorithm);
+}
+
+SZ3::EB getSZ3ErrorBoundMode(const String & error_bound_mode)
+{
+    return SZ3::EB_MAP.at(error_bound_mode);
+}
+
+void registerCodecSZ3(CompressionCodecFactory & factory)
+{
+    auto method_code = static_cast<UInt8>(CompressionMethodByte::SZ3);
+    auto codec_builder = [&](const ASTPtr & arguments, const IDataType * column_type) -> CompressionCodecPtr
+    {
+        UInt8 float_width = 4;
+        if (column_type)
+            float_width = getFloatByteWidth(*column_type);
+
+        if (!arguments || arguments->children.empty())
+        {
+            static constexpr auto default_algorithm = SZ3::ALGO_INTERP_LORENZO;
+            static constexpr auto default_error_bound_mode = SZ3::EB_REL;
+            static constexpr auto default_error_bound = 1e-2;
+
+            return std::make_shared<CompressionCodecSZ3>(
+                float_width, default_algorithm, default_error_bound_mode, default_error_bound);
+        }
+        else if (arguments->children.size() == 3)
+        {
+            const auto & children = arguments->children;
+            const auto * literal = children[0]->as<ASTLiteral>();
+            if (!literal || literal->value.getType() != Field::Types::Which::String)
+                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "1st argument of codec 'SZ3' must be a String");
+            auto algorithm_string = static_cast<String>(literal->value.safeGet<String>());
+            auto algorithm = getSZ3Algorithm(algorithm_string);
+
+            literal = children[1]->as<ASTLiteral>();
+            if (!literal || literal->value.getType() != Field::Types::Which::String)
+                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "2nd argument of codec 'SZ3' be a String");
+            auto error_bound_mode_string = static_cast<String>(literal->value.safeGet<String>());
+            auto error_bound_mode = getSZ3ErrorBoundMode(error_bound_mode_string);
+
+            literal = children[2]->as<ASTLiteral>();
+            if (!literal || literal->value.getType() != Field::Types::Which::Float64)
+                throw Exception(ErrorCodes::ILLEGAL_CODEC_PARAMETER, "3rd argument of codec 'SZ3' be a Float64");
+            auto error_value = static_cast<double>(literal->value.safeGet<Float64>());
+
+            return std::make_shared<CompressionCodecSZ3>(float_width, algorithm, error_bound_mode, error_value);
+        }
+        else
+        {
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS, "Codec SZ3 must have 0 or 3 arguments but {} arguments are given", arguments->children.size());
+        }
+    };
+    factory.registerCompressionCodecWithType("SZ3", method_code, codec_builder);
+}
+
+}
+#endif
diff --git a/src/Compression/CompressionCodecT64.cpp b/src/Compression/CompressionCodecT64.cpp
index 5582368863d0..b724e8510b7d 100644
--- a/src/Compression/CompressionCodecT64.cpp
+++ b/src/Compression/CompressionCodecT64.cpp
@@ -53,12 +53,11 @@ class CompressionCodecT64 : public ICompressionCodec
 
     bool isCompression() const override { return true; }
     bool isGenericCompression() const override { return false; }
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Preprocessor. Crops unused high bits; puts them into a 64x64 bit matrix; optimized for 64-bit data types.";
     }
 
-
 private:
     std::optional<TypeIndex> type_idx;
     Variant variant;
diff --git a/src/Compression/CompressionCodecZSTD.h b/src/Compression/CompressionCodecZSTD.h
index 1c985799c98d..f363f1af69e1 100644
--- a/src/Compression/CompressionCodecZSTD.h
+++ b/src/Compression/CompressionCodecZSTD.h
@@ -29,12 +29,11 @@ class CompressionCodecZSTD : public ICompressionCodec
     bool isCompression() const override { return true; }
     bool isGenericCompression() const override { return true; }
 
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Good compression; pretty fast; best for high compression needs. Don’t use levels higher than 3.";
     }
 
-
 private:
     const int level;
     const bool enable_long_range;
diff --git a/src/Compression/CompressionCodecZSTDQAT.cpp b/src/Compression/CompressionCodecZSTDQAT.cpp
index 5da4ba38f8ed..7fdf475d623d 100644
--- a/src/Compression/CompressionCodecZSTDQAT.cpp
+++ b/src/Compression/CompressionCodecZSTDQAT.cpp
@@ -31,12 +31,11 @@ class CompressionCodecZSTDQAT : public CompressionCodecZSTD
 
     explicit CompressionCodecZSTDQAT(int level_);
 
-    std::string getDescription() const override
+    String getDescription() const override
     {
         return "Requires hardware support for QuickAssist Technology (QAT) hardware; provides accelerated compression tasks.";
     }
 
-
 protected:
     bool isZstdQat() const override { return true; }
     UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;
diff --git a/src/Compression/CompressionFactory.cpp b/src/Compression/CompressionFactory.cpp
index 7ab5cb4691f8..f2ea45a70b88 100644
--- a/src/Compression/CompressionFactory.cpp
+++ b/src/Compression/CompressionFactory.cpp
@@ -212,6 +212,9 @@ void registerCodecGorilla(CompressionCodecFactory & factory);
 void registerCodecEncrypted(CompressionCodecFactory & factory);
 void registerCodecFPC(CompressionCodecFactory & factory);
 void registerCodecGCD(CompressionCodecFactory & factory);
+#if USE_SZ3
+void registerCodecSZ3(CompressionCodecFactory & factory);
+#endif
 
 CompressionCodecFactory::CompressionCodecFactory()
 {
@@ -233,6 +236,9 @@ CompressionCodecFactory::CompressionCodecFactory()
     registerCodecDeflateQpl(*this);
 #endif
     registerCodecGCD(*this);
+#if USE_SZ3
+    registerCodecSZ3(*this);
+#endif
 
     default_codec = get("LZ4", {});
 }
diff --git a/src/Compression/CompressionFactoryAdditions.cpp b/src/Compression/CompressionFactoryAdditions.cpp
index d897400a171e..d6164b52ee21 100644
--- a/src/Compression/CompressionFactoryAdditions.cpp
+++ b/src/Compression/CompressionFactoryAdditions.cpp
@@ -156,19 +156,19 @@ ASTPtr CompressionCodecFactory::validateCodecAndGetPreprocessedAST(
                 if (!allow_experimental_codecs && result_codec->isExperimental())
                     throw Exception(ErrorCodes::BAD_ARGUMENTS,
                         "Codec {} is experimental and not meant to be used in production."
-                        " You can enable it with the 'allow_experimental_codecs' setting.",
+                        " You can enable it with the 'allow_experimental_codecs' setting",
                         codec_family_name);
 
                 if (!enable_deflate_qpl_codec && result_codec->isDeflateQpl())
                     throw Exception(ErrorCodes::BAD_ARGUMENTS,
                         "Codec {} is disabled by default."
-                        " You can enable it with the 'enable_deflate_qpl_codec' setting.",
+                        " You can enable it with the 'enable_deflate_qpl_codec' setting",
                         codec_family_name);
 
                 if (!enable_zstd_qat_codec && result_codec->isZstdQat())
                     throw Exception(ErrorCodes::BAD_ARGUMENTS,
                         "Codec {} is disabled by default."
-                        " You can enable it with the 'enable_zstd_qat_codec' setting.",
+                        " You can enable it with the 'enable_zstd_qat_codec' setting",
                         codec_family_name);
 
                 codecs_descriptions->children.emplace_back(result_codec->getCodecDesc());
diff --git a/src/Compression/CompressionInfo.h b/src/Compression/CompressionInfo.h
index 93ceef156d3a..9079f1412b80 100644
--- a/src/Compression/CompressionInfo.h
+++ b/src/Compression/CompressionInfo.h
@@ -49,6 +49,7 @@ enum class CompressionMethodByte : uint8_t
     DeflateQpl      = 0x99,
     GCD             = 0x9a,
     ZSTD_QPL        = 0x9b,
+    SZ3             = 0x9c,
 };
 
 }
diff --git a/src/Compression/ICompressionCodec.cpp b/src/Compression/ICompressionCodec.cpp
index aac0d66dd474..29d217fcc155 100644
--- a/src/Compression/ICompressionCodec.cpp
+++ b/src/Compression/ICompressionCodec.cpp
@@ -22,9 +22,15 @@ namespace DB
 
 namespace ErrorCodes
 {
+    extern const int BAD_ARGUMENTS;
     extern const int LOGICAL_ERROR;
 }
 
+void ICompressionCodec::setAndCheckVectorDimension(size_t /*dimension*/)
+{
+    if (!needsVectorDimensionUpfront())
+        throw Exception(ErrorCodes::BAD_ARGUMENTS, "Can not set dimensions for a non-vector codec");
+}
 
 void ICompressionCodec::setCodecDescription(const String & codec_name, const ASTs & arguments)
 {
diff --git a/src/Compression/ICompressionCodec.h b/src/Compression/ICompressionCodec.h
index f391471f27ab..c64bb8e503df 100644
--- a/src/Compression/ICompressionCodec.h
+++ b/src/Compression/ICompressionCodec.h
@@ -96,6 +96,12 @@ class ICompressionCodec : private boost::noncopyable
     /// Read size of decompressed block from compressed source
     UInt32 readDecompressedBlockSize(const char * source) const;
 
+    /// Does the codec need to know the vector (Array) dimension before compression?
+    virtual bool needsVectorDimensionUpfront() const { return false; }
+
+    /// Setting dimension is useful for vector codecs (only SZ3 codec at the moment).
+    virtual void setAndCheckVectorDimension(size_t /*dimension*/);
+
     /// Read method byte from compressed source
     static uint8_t readMethod(const char * source);
 
@@ -114,6 +120,8 @@ class ICompressionCodec : private boost::noncopyable
     /// If the codec's purpose is to calculate deltas between consecutive values.
     virtual bool isDeltaCompression() const { return false; }
 
+    virtual bool isLossyCompression() const { return false; }
+
     /// It is a codec available only for evaluation purposes and not meant to be used in production.
     /// It will not be allowed to use unless the user will turn off the safety switch.
     virtual bool isExperimental() const { return false; }
@@ -128,7 +136,7 @@ class ICompressionCodec : private boost::noncopyable
     virtual bool isNone() const { return false; }
 
     // Returns a string with a high level codec description.
-    virtual std::string getDescription() const = 0;
+    virtual String getDescription() const = 0;
 
 protected:
     /// This is used for fuzz testing
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp
index 4c8bc9415b2a..4c258331b9ed 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp
@@ -73,6 +73,8 @@ MergeTreeDataPartWriterCompact::MergeTreeDataPartWriterCompact(
 
 void MergeTreeDataPartWriterCompact::addStreams(const NameAndTypePair & name_and_type, const ColumnPtr & column, const ASTPtr & effective_codec_desc)
 {
+    CompressedStreamPtr prev_stream;
+
     ISerialization::StreamCallback callback = [&](const auto & substream_path)
     {
         assert(!substream_path.empty());
@@ -91,12 +93,18 @@ void MergeTreeDataPartWriterCompact::addStreams(const NameAndTypePair & name_and
         else /// otherwise return only generic codecs and don't use info about data_type
             compression_codec = CompressionCodecFactory::instance().get(effective_codec_desc, nullptr, default_codec, true);
 
+        /// If previous stream is not null it means it was Array offsets stream.
+        /// Can't apply lossy compression for offsets.
+        if (prev_stream && prev_stream->compressed_buf.getCodec()->isLossyCompression())
+            prev_stream->compressed_buf.setCodec(CompressionCodecFactory::instance().getDefaultCodec());
+
         UInt64 codec_id = compression_codec->getHash();
         auto & stream = streams_by_codec[codec_id];
         if (!stream)
             stream = std::make_shared<CompressedStream>(plain_hashing, compression_codec);
 
         compressed_streams.emplace(stream_name, stream);
+        prev_stream = stream;
     };
 
     ISerialization::EnumerateStreamsSettings enumerate_settings;
@@ -258,6 +266,13 @@ void MergeTreeDataPartWriterCompact::writeDataBlock(const Block & block, const G
                 String stream_name = ISerialization::getFileNameForStream(*name_and_type, substream_path);
 
                 auto & result_stream = compressed_streams[stream_name];
+
+                /// Some vector codecs (e.g., SZ3) used for compressing arrays like Array<Float>
+                /// require specifying the array dimensions before compression starts.
+                /// For 1D arrays, it's simply the length.
+                auto compression_codec = result_stream->compressed_buf.getCodec();
+                setVectorDimensionsIfNeeded(compression_codec, block.getColumnOrSubcolumnByName(name_and_type->name).column.get());
+
                 /// Write one compressed block per column in granule for more optimal reading.
                 if (prev_stream && prev_stream != result_stream)
                 {
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp
index cfad4fa5f8fc..ec722c9bd5ea 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.cpp
@@ -6,6 +6,7 @@
 #include <Common/ElapsedTimeProfileEventIncrement.h>
 #include <Common/MemoryTrackerBlockerInThread.h>
 #include <Common/logger_useful.h>
+#include "Columns/IColumn.h"
 #include <Compression/CompressionFactory.h>
 
 namespace ProfileEvents
@@ -603,6 +604,31 @@ void MergeTreeDataPartWriterOnDisk::initOrAdjustDynamicStructureIfNeeded(Block &
     }
 }
 
+void MergeTreeDataPartWriterOnDisk::setVectorDimensionsIfNeeded(CompressionCodecPtr codec, const IColumn * column)
+{
+    if (codec->needsVectorDimensionUpfront())
+    {
+        Field sample_field;
+        column->get(0, sample_field);
+        if (sample_field.getType() == Field::Types::Array)
+        {
+            for (size_t j = 0; j < column->size(); ++j)
+            {
+                column->get(j, sample_field);
+                codec->setAndCheckVectorDimension(sample_field.safeGet<Array>().size());
+            }
+        }
+        if (sample_field.getType() == Field::Types::Tuple)
+        {
+            for (size_t j = 0; j < column->size(); ++j)
+            {
+                column->get(j, sample_field);
+                codec->setAndCheckVectorDimension(sample_field.safeGet<Tuple>().size());
+            }
+        }
+    }
+}
+
 template struct MergeTreeDataPartWriterOnDisk::Stream<false>;
 template struct MergeTreeDataPartWriterOnDisk::Stream<true>;
 
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.h b/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.h
index 626215867d4a..75350d8712d4 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.h
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterOnDisk.h
@@ -10,6 +10,8 @@
 #include <Parsers/parseQuery.h>
 #include <Storages/Statistics/Statistics.h>
 #include <Storages/MarkCache.h>
+#include "Columns/IColumn_fwd.h"
+#include "Compression/ICompressionCodec.h"
 
 namespace DB
 {
@@ -176,6 +178,9 @@ class MergeTreeDataPartWriterOnDisk : public IMergeTreeDataPartWriter
     /// the structure from the sample.
     void initOrAdjustDynamicStructureIfNeeded(Block & block);
 
+    /// This is useful only for vector codecs (like SZ3).
+    static void setVectorDimensionsIfNeeded(CompressionCodecPtr codec, const IColumn * column);
+
     const MergeTreeIndices skip_indices;
 
     const ColumnsStatistics stats;
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
index 9caaca8ef676..da3725e1c1a1 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
@@ -227,6 +227,7 @@ ISerialization::OutputStreamGetter MergeTreeDataPartWriterWide::createStreamGett
         if (is_offsets && offset_columns.contains(stream_name))
             return nullptr;
 
+
         return &column_streams.at(stream_name)->compressed_hashing;
     };
 }
@@ -447,6 +448,12 @@ void MergeTreeDataPartWriterWide::writeSingleGranule(
         if (is_offsets && offset_columns.contains(stream_name))
             return;
 
+        /// Some vector codecs (e.g., SZ3) used for compressing arrays like Array<Float>
+        /// require specifying the array dimensions before compression starts.
+        /// For 1D arrays, it's simply the length.
+        auto compression_codec = column_streams.at(stream_name)->compressor.getCodec();
+        setVectorDimensionsIfNeeded(compression_codec, &column);
+
         column_streams.at(stream_name)->compressed_hashing.nextIfAtEnd();
     }, name_and_type.type, column.getPtr());
 }
diff --git a/src/configure_config.cmake b/src/configure_config.cmake
index 436c24ac4085..5b8b24d30c35 100644
--- a/src/configure_config.cmake
+++ b/src/configure_config.cmake
@@ -204,4 +204,8 @@ if (TARGET ch_contrib::sha3iuf)
     set(USE_SHA3IUF 1)
 endif()
 
+if (TARGET ch_contrib::sz3)
+    set(USE_SZ3 1)
+endif()
+
 set(SOURCE_DIR ${PROJECT_SOURCE_DIR})
