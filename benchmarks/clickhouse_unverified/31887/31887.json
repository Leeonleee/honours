{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 31887,
  "instance_id": "ClickHouse__ClickHouse-31887",
  "issue_numbers": [
    "31485"
  ],
  "base_commit": "06b8421cb66fcda280ca0edb7aa3389812fa5e30",
  "patch": "diff --git a/src/Parsers/ASTPartition.h b/src/Parsers/ASTPartition.h\nindex c513eb7328e9..87092f532c42 100644\n--- a/src/Parsers/ASTPartition.h\n+++ b/src/Parsers/ASTPartition.h\n@@ -12,7 +12,6 @@ class ASTPartition : public IAST\n {\n public:\n     ASTPtr value;\n-    String fields_str; /// The extent of comma-separated partition expression fields without parentheses.\n     size_t fields_count = 0;\n \n     String id;\ndiff --git a/src/Parsers/ParserPartition.cpp b/src/Parsers/ParserPartition.cpp\nindex a3ec4943e1c9..c10999361deb 100644\n--- a/src/Parsers/ParserPartition.cpp\n+++ b/src/Parsers/ParserPartition.cpp\n@@ -35,7 +35,6 @@ bool ParserPartition::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             return false;\n \n         size_t fields_count;\n-        String fields_str;\n \n         const auto * tuple_ast = value->as<ASTFunction>();\n         bool surrounded_by_parens = false;\n@@ -58,7 +57,6 @@ bool ParserPartition::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             else\n             {\n                 fields_count = 1;\n-                fields_str = String(begin->begin, pos->begin - begin->begin);\n             }\n         }\n         else\n@@ -78,13 +76,10 @@ bool ParserPartition::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n                 --right_paren;\n             if (right_paren->type != TokenType::ClosingRoundBracket)\n                 return false;\n-\n-            fields_str = String(left_paren->end, right_paren->begin - left_paren->end);\n         }\n \n         partition->value = value;\n         partition->children.push_back(value);\n-        partition->fields_str = std::move(fields_str);\n         partition->fields_count = fields_count;\n     }\n \ndiff --git a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\nindex 2120c00b3b57..c362a6166479 100644\n--- a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n+++ b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n@@ -37,6 +37,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int SYNTAX_ERROR;\n+    extern const int BAD_ARGUMENTS;\n }\n \n \n@@ -342,6 +343,10 @@ ConstantExpressionTemplate::TemplateStructure::TemplateStructure(LiteralsInfo &\n     auto syntax_result = TreeRewriter(context).analyze(expression, literals.getNamesAndTypesList());\n     result_column_name = expression->getColumnName();\n     actions_on_literals = ExpressionAnalyzer(expression, syntax_result, context).getActions(false);\n+    if (actions_on_literals->hasArrayJoin())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                        \"Array joins are not allowed in constant expressions for IN, VALUES, LIMIT and similar sections.\");\n+\n }\n \n size_t ConstantExpressionTemplate::TemplateStructure::getTemplateHash(const ASTPtr & expression,\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 5522edf86a30..d166556b666d 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -26,6 +26,8 @@\n #include <Interpreters/inplaceBlockConversions.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+#include <Interpreters/convertFieldToType.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTNameTypePair.h>\n@@ -3659,56 +3661,54 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr loc\n     /// Re-parse partition key fields using the information about expected field types.\n \n     auto metadata_snapshot = getInMemoryMetadataPtr();\n-    size_t fields_count = metadata_snapshot->getPartitionKey().sample_block.columns();\n+    const Block & key_sample_block = metadata_snapshot->getPartitionKey().sample_block;\n+    size_t fields_count = key_sample_block.columns();\n     if (partition_ast.fields_count != fields_count)\n-        throw Exception(\n-            \"Wrong number of fields in the partition expression: \" + toString(partition_ast.fields_count) +\n-            \", must be: \" + toString(fields_count),\n-            ErrorCodes::INVALID_PARTITION_VALUE);\n+        throw Exception(ErrorCodes::INVALID_PARTITION_VALUE,\n+                        \"Wrong number of fields in the partition expression: {}, must be: {}\",\n+                        partition_ast.fields_count, fields_count);\n \n-    if (auto * f = partition_ast.value->as<ASTFunction>())\n+    Row partition_row(fields_count);\n+    if (fields_count == 0)\n+    {\n+        /// Function tuple(...) requires at least one argument, so empty key is a special case\n+        assert(!partition_ast.fields_count);\n+        assert(typeid_cast<ASTFunction *>(partition_ast.value.get()));\n+        assert(partition_ast.value->as<ASTFunction>()->name == \"tuple\");\n+        assert(partition_ast.value->as<ASTFunction>()->arguments);\n+        bool empty_tuple = partition_ast.value->as<ASTFunction>()->arguments->children.empty();\n+        if (!empty_tuple)\n+            throw Exception(ErrorCodes::INVALID_PARTITION_VALUE, \"Partition key is empty, expected 'tuple()' as partition key\");\n+    }\n+    else if (fields_count == 1)\n     {\n-        assert(f->name == \"tuple\");\n-        if (f->arguments && !f->arguments->as<ASTExpressionList>()->children.empty())\n+        ASTPtr partition_value_ast = partition_ast.value;\n+        if (auto * tuple = partition_value_ast->as<ASTFunction>())\n         {\n-            ASTPtr query = partition_ast.value->clone();\n-            auto syntax_analyzer_result\n-                = TreeRewriter(local_context)\n-                      .analyze(query, metadata_snapshot->getPartitionKey().sample_block.getNamesAndTypesList(), {}, {}, false, false);\n-            auto actions = ExpressionAnalyzer(query, syntax_analyzer_result, local_context).getActions(true);\n-            if (actions->hasArrayJoin())\n-                throw Exception(\"The partition expression cannot contain array joins\", ErrorCodes::INVALID_PARTITION_VALUE);\n+            assert(tuple->name == \"tuple\");\n+            assert(tuple->arguments);\n+            assert(tuple->arguments->children.size() == 1);\n+            partition_value_ast = tuple->arguments->children[0];\n         }\n+        /// Simple partition key, need to evaluate and cast\n+        Field partition_key_value = evaluateConstantExpression(partition_value_ast, local_context).first;\n+        partition_row[0] = convertFieldToTypeOrThrow(partition_key_value, *key_sample_block.getByPosition(0).type);\n     }\n-\n-    const FormatSettings format_settings;\n-    Row partition_row(fields_count);\n-\n-    if (fields_count)\n+    else\n     {\n-        ConcatReadBuffer buf;\n-        buf.appendBuffer(std::make_unique<ReadBufferFromMemory>(\"(\", 1));\n-        buf.appendBuffer(std::make_unique<ReadBufferFromMemory>(partition_ast.fields_str.data(), partition_ast.fields_str.size()));\n-        buf.appendBuffer(std::make_unique<ReadBufferFromMemory>(\")\", 1));\n-\n-        auto input_format = local_context->getInputFormat(\n-            \"Values\",\n-            buf,\n-            metadata_snapshot->getPartitionKey().sample_block,\n-            local_context->getSettingsRef().max_block_size);\n-        QueryPipeline pipeline(std::move(input_format));\n-        PullingPipelineExecutor executor(pipeline);\n+        /// Complex key, need to evaluate, untuple and cast\n+        Field partition_key_value = evaluateConstantExpression(partition_ast.value, local_context).first;\n+        if (partition_key_value.getType() != Field::Types::Tuple)\n+            throw Exception(ErrorCodes::INVALID_PARTITION_VALUE,\n+                            \"Expected tuple for complex partition key, got {}\", partition_key_value.getTypeName());\n \n-        Block block;\n-        executor.pull(block);\n-\n-        if (!block || !block.rows())\n-            throw Exception(\n-                \"Could not parse partition value: `\" + partition_ast.fields_str + \"`\",\n-                ErrorCodes::INVALID_PARTITION_VALUE);\n+        const Tuple & tuple = partition_key_value.get<Tuple>();\n+        if (tuple.size() != fields_count)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                            \"Wrong number of fields in the partition expression: {}, must be: {}\", tuple.size(), fields_count);\n \n         for (size_t i = 0; i < fields_count; ++i)\n-            block.getByPosition(i).column->get(0, partition_row[i]);\n+            partition_row[i] = convertFieldToTypeOrThrow(tuple[i], *key_sample_block.getByPosition(i).type);\n     }\n \n     MergeTreePartition partition(std::move(partition_row));\n@@ -3720,11 +3720,10 @@ String MergeTreeData::getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr loc\n         if (existing_part_in_partition && existing_part_in_partition->partition.value != partition.value)\n         {\n             WriteBufferFromOwnString buf;\n-            writeCString(\"Parsed partition value: \", buf);\n-            partition.serializeText(*this, buf, format_settings);\n-            writeCString(\" doesn't match partition value for an existing part with the same partition ID: \", buf);\n-            writeString(existing_part_in_partition->name, buf);\n-            throw Exception(buf.str(), ErrorCodes::INVALID_PARTITION_VALUE);\n+            partition.serializeText(*this, buf, FormatSettings{});\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Parsed partition value: {} \"\n+                            \"doesn't match partition value for an existing part with the same partition ID: {}\",\n+                            buf.str(), existing_part_in_partition->name);\n         }\n     }\n \ndiff --git a/src/Storages/MergeTree/MergeTreePartition.cpp b/src/Storages/MergeTree/MergeTreePartition.cpp\nindex 54011cc0924a..06fcb24f8463 100644\n--- a/src/Storages/MergeTree/MergeTreePartition.cpp\n+++ b/src/Storages/MergeTree/MergeTreePartition.cpp\n@@ -20,6 +20,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int INVALID_PARTITION_VALUE;\n }\n \n namespace\n@@ -182,6 +183,8 @@ String MergeTreePartition::getID(const Block & partition_key_sample) const\n \n     /// In case all partition fields are represented by integral types, try to produce a human-readable ID.\n     /// Otherwise use a hex-encoded hash.\n+    /// NOTE It will work in unexpected way if some partition key column is Nullable:\n+    /// are_all_integral will be false if some value is NULL. Maybe we should fix it.\n     bool are_all_integral = true;\n     for (const Field & field : value)\n     {\n@@ -228,6 +231,94 @@ String MergeTreePartition::getID(const Block & partition_key_sample) const\n     return result;\n }\n \n+std::optional<Row> MergeTreePartition::tryParseValueFromID(const String & partition_id, const Block & partition_key_sample)\n+{\n+    size_t num_keys = partition_key_sample.columns();\n+    Row res;\n+    res.reserve(num_keys);\n+\n+    ReadBufferFromString buf(partition_id);\n+    if (num_keys == 0)\n+    {\n+        checkString(\"all\", buf);\n+        assertEOF(buf);\n+        return res;\n+    }\n+\n+    enum KeyType { DATE, UNSIGNED, SIGNED };\n+\n+    std::vector<KeyType> key_types;\n+    key_types.reserve(num_keys);\n+    for (size_t i = 0; i < num_keys; ++i)\n+    {\n+        auto type = partition_key_sample.getByPosition(i).type;\n+\n+        /// NOTE Sometimes it's possible to parse Nullable key, but easier to ignore it.\n+        if (type->isNullable())\n+            return {};\n+\n+        /// We use Field::Types when serializing partition_id, let's get some Field to check type\n+        Field sample_field = type->getDefault();\n+\n+        if (typeid_cast<const DataTypeDate *>(type.get()))\n+            key_types.emplace_back(DATE);\n+        else if (sample_field.getType() == Field::Types::UInt64)\n+            key_types.emplace_back(UNSIGNED);\n+        else if (sample_field.getType() == Field::Types::Int64)\n+            key_types.emplace_back(SIGNED);\n+        else\n+            return {};\n+    }\n+\n+    /// All columns are numeric, will parse partition value\n+    for (size_t i = 0; i < num_keys; ++i)\n+    {\n+        switch (key_types[i])\n+        {\n+            case DATE:\n+            {\n+                UInt32 date_yyyymmdd;\n+                readText(date_yyyymmdd, buf);\n+                constexpr UInt32 min_yyyymmdd = 10000000;\n+                constexpr UInt32 max_yyyymmdd = 99999999;\n+                if (date_yyyymmdd < min_yyyymmdd || max_yyyymmdd < date_yyyymmdd)\n+                    throw Exception(\n+                        ErrorCodes::INVALID_PARTITION_VALUE, \"Cannot parse partition_id: got unexpected Date: {}\", date_yyyymmdd);\n+\n+                UInt32 date = DateLUT::instance().YYYYMMDDToDayNum(date_yyyymmdd);\n+                res.emplace_back(date);\n+                break;\n+            }\n+            case UNSIGNED:\n+            {\n+                UInt64 value;\n+                readText(value, buf);\n+                res.emplace_back(value);\n+                break;\n+            }\n+            case SIGNED:\n+            {\n+                Int64 value;\n+                readText(value, buf);\n+                res.emplace_back(value);\n+                break;\n+            }\n+        }\n+\n+        if (i + 1 != num_keys)\n+            assertChar('-', buf);\n+    }\n+\n+    assertEOF(buf);\n+\n+    String expected_partition_id = MergeTreePartition{res}.getID(partition_key_sample);\n+    if (expected_partition_id != partition_id)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Partition ID was parsed incorrectly: expected {}, got {}\",\n+                        expected_partition_id, partition_id);\n+\n+    return res;\n+}\n+\n void MergeTreePartition::serializeText(const MergeTreeData & storage, WriteBuffer & out, const FormatSettings & format_settings) const\n {\n     auto metadata_snapshot = storage.getInMemoryMetadataPtr();\ndiff --git a/src/Storages/MergeTree/MergeTreePartition.h b/src/Storages/MergeTree/MergeTreePartition.h\nindex acc565e2ce9f..d501d615621f 100644\n--- a/src/Storages/MergeTree/MergeTreePartition.h\n+++ b/src/Storages/MergeTree/MergeTreePartition.h\n@@ -33,6 +33,8 @@ struct MergeTreePartition\n     String getID(const MergeTreeData & storage) const;\n     String getID(const Block & partition_key_sample) const;\n \n+    static std::optional<Row> tryParseValueFromID(const String & partition_id, const Block & partition_key_sample);\n+\n     void serializeText(const MergeTreeData & storage, WriteBuffer & out, const FormatSettings & format_settings) const;\n \n     void load(const MergeTreeData & storage, const DiskPtr & disk, const String & part_path);\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 60b576d8eac5..dac091adcd83 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -7380,13 +7380,23 @@ bool StorageReplicatedMergeTree::createEmptyPartInsteadOfLost(zkutil::ZooKeeperP\n     {\n         auto lock = lockParts();\n         auto parts_in_partition = getDataPartsPartitionRange(new_part_info.partition_id);\n-        if (parts_in_partition.empty())\n+        if (!parts_in_partition.empty())\n         {\n-            LOG_WARNING(log, \"Empty part {} is not created instead of lost part because there are no parts in partition {} (it's empty), resolve this manually using DROP PARTITION.\", lost_part_name, new_part_info.partition_id);\n+            new_data_part->partition = (*parts_in_partition.begin())->partition;\n+        }\n+        else if (auto parsed_partition = MergeTreePartition::tryParseValueFromID(\n+                     new_part_info.partition_id,\n+                     metadata_snapshot->getPartitionKey().sample_block))\n+        {\n+            new_data_part->partition = MergeTreePartition(*parsed_partition);\n+        }\n+        else\n+        {\n+            LOG_WARNING(log, \"Empty part {} is not created instead of lost part because there are no parts in partition {} (it's empty), \"\n+                             \"resolve this manually using DROP/DETACH PARTITION.\", lost_part_name, new_part_info.partition_id);\n             return false;\n         }\n \n-        new_data_part->partition = (*parts_in_partition.begin())->partition;\n     }\n \n     new_data_part->minmax_idx = std::move(minmax_idx);\n",
  "test_patch": "diff --git a/tests/integration/test_lost_part/test.py b/tests/integration/test_lost_part/test.py\nindex 614df52063f2..7b2d54a5ea46 100644\n--- a/tests/integration/test_lost_part/test.py\n+++ b/tests/integration/test_lost_part/test.py\n@@ -178,18 +178,20 @@ def test_lost_part_mutation(start_cluster):\n def test_lost_last_part(start_cluster):\n     for node in [node1, node2]:\n         node.query(\n-            \"CREATE TABLE mt3 (id UInt64) ENGINE ReplicatedMergeTree('/clickhouse/tables/t3', '{}') ORDER BY tuple()\".format(node.name))\n+            \"CREATE TABLE mt3 (id UInt64, p String) ENGINE ReplicatedMergeTree('/clickhouse/tables/t3', '{}') \"\n+            \"ORDER BY tuple() PARTITION BY p\".format(node.name))\n \n     node1.query(\"SYSTEM STOP MERGES mt3\")\n     node2.query(\"SYSTEM STOP REPLICATION QUEUES\")\n \n     for i in range(1):\n-        node1.query(\"INSERT INTO mt3 VALUES ({})\".format(i))\n+        node1.query(\"INSERT INTO mt3 VALUES ({}, 'x')\".format(i))\n \n     # actually not important\n     node1.query(\"ALTER TABLE mt3 UPDATE id = 777 WHERE 1\", settings={\"mutations_sync\": \"0\"})\n \n-    remove_part_from_disk(node1, 'mt3', 'all_0_0_0')\n+    partition_id = node1.query(\"select partitionId('x')\").strip()\n+    remove_part_from_disk(node1, 'mt3', '{}_0_0_0'.format(partition_id))\n \n     # other way to detect broken parts\n     node1.query(\"CHECK TABLE mt3\")\n@@ -199,13 +201,13 @@ def test_lost_last_part(start_cluster):\n     for i in range(10):\n         result = node1.query(\"SELECT count() FROM system.replication_queue\")\n         assert int(result) <= 1, \"Have a lot of entries in queue {}\".format(node1.query(\"SELECT * FROM system.replication_queue FORMAT Vertical\"))\n-        if node1.contains_in_log(\"Cannot create empty part\") and node1.contains_in_log(\"DROP PARTITION\"):\n+        if node1.contains_in_log(\"Cannot create empty part\") and node1.contains_in_log(\"DROP/DETACH PARTITION\"):\n             break\n         time.sleep(1)\n     else:\n         assert False, \"Don't have required messages in node1 log\"\n \n-    node1.query(\"ALTER TABLE mt3 DROP PARTITION ID 'all'\")\n+    node1.query(\"ALTER TABLE mt3 DROP PARTITION ID '{}'\".format(partition_id))\n \n     assert_eq_with_retry(node1, \"SELECT COUNT() FROM mt3\", \"0\")\n     assert_eq_with_retry(node1, \"SELECT COUNT() FROM system.replication_queue\", \"0\")\ndiff --git a/tests/queries/0_stateless/01165_lost_part_empty_partition.reference b/tests/queries/0_stateless/01165_lost_part_empty_partition.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01165_lost_part_empty_partition.sql b/tests/queries/0_stateless/01165_lost_part_empty_partition.sql\nnew file mode 100644\nindex 000000000000..9279de1a5b39\n--- /dev/null\n+++ b/tests/queries/0_stateless/01165_lost_part_empty_partition.sql\n@@ -0,0 +1,37 @@\n+-- Tags: zookeeper\n+\n+create table rmt1 (d DateTime, n int) engine=ReplicatedMergeTree('/test/01165/{database}/rmt', '1') order by n partition by toYYYYMMDD(d);\n+create table rmt2 (d DateTime, n int) engine=ReplicatedMergeTree('/test/01165/{database}/rmt', '2') order by n partition by toYYYYMMDD(d);\n+\n+system stop replicated sends rmt1;\n+insert into rmt1 values (now(), arrayJoin([1, 2])); -- { clientError 36 }\n+insert into rmt1(n) select * from system.numbers limit arrayJoin([1, 2]); -- { serverError 36 }\n+insert into rmt1 values (now(), rand());\n+drop table rmt1;\n+\n+system sync replica rmt2;\n+drop table rmt2;\n+\n+\n+create table rmt1 (d DateTime, n int) engine=ReplicatedMergeTree('/test/01165/{database}/rmt', '1') order by n partition by tuple();\n+create table rmt2 (d DateTime, n int) engine=ReplicatedMergeTree('/test/01165/{database}/rmt', '2') order by n partition by tuple();\n+\n+system stop replicated sends rmt1;\n+insert into rmt1 values (now(), rand());\n+drop table rmt1;\n+\n+system sync replica rmt2;\n+drop table rmt2;\n+\n+\n+create table rmt1 (n UInt8, m Int32, d Date, t DateTime) engine=ReplicatedMergeTree('/test/01165/{database}/rmt', '1') order by n partition by (n, m, d, t);\n+create table rmt2 (n UInt8, m Int32, d Date, t DateTime) engine=ReplicatedMergeTree('/test/01165/{database}/rmt', '2') order by n partition by (n, m, d, t);\n+\n+system stop replicated sends rmt1;\n+insert into rmt1 values (rand(), rand(), now(), now());\n+insert into rmt1 values (rand(), rand(), now(), now());\n+insert into rmt1 values (rand(), rand(), now(), now());\n+drop table rmt1;\n+\n+system sync replica rmt2;\n+drop table rmt2;\ndiff --git a/tests/queries/0_stateless/02009_array_join_partition.sql b/tests/queries/0_stateless/02009_array_join_partition.sql\nindex a78efe96f66a..b8eedb5592f4 100644\n--- a/tests/queries/0_stateless/02009_array_join_partition.sql\n+++ b/tests/queries/0_stateless/02009_array_join_partition.sql\n@@ -1,4 +1,4 @@\n CREATE TABLE table_2009_part (`i` Int64, `d` Date, `s` String) ENGINE = MergeTree PARTITION BY toYYYYMM(d) ORDER BY i;\n \n-ALTER TABLE table_2009_part ATTACH PARTITION tuple(arrayJoin([0, 1])); -- {serverError 248}\n-ALTER TABLE table_2009_part ATTACH PARTITION tuple(toYYYYMM(toDate([arrayJoin([arrayJoin([arrayJoin([arrayJoin([3, materialize(NULL), arrayJoin([1025, materialize(NULL), materialize(NULL)]), NULL])])]), materialize(NULL)])], NULL))); -- {serverError 248}\n+ALTER TABLE table_2009_part ATTACH PARTITION tuple(arrayJoin([0, 1])); -- {serverError 36}\n+ALTER TABLE table_2009_part ATTACH PARTITION tuple(toYYYYMM(toDate([arrayJoin([arrayJoin([arrayJoin([arrayJoin([3, materialize(NULL), arrayJoin([1025, materialize(NULL), materialize(NULL)]), NULL])])]), materialize(NULL)])], NULL))); -- {serverError 36}\n",
  "problem_statement": "Improve lost parts replacement with empty parts\nAt the moment we have a problem when we trying to replace last empty part in partition: https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/StorageReplicatedMergeTree.cpp#L7385\r\n\r\nThe problem source is inability to restore `partition` name from some partition keys because we hash them https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/MergeTree/MergeTreePartition.cpp#L217-L226. So let's implement an ad-hoc solution which will allow to restore partition name from ID if partition key values were not hashed.\n",
  "hints_text": "",
  "created_at": "2021-11-26T14:56:35Z",
  "modified_files": [
    "src/Parsers/ASTPartition.h",
    "src/Parsers/ParserPartition.cpp",
    "src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreePartition.cpp",
    "src/Storages/MergeTree/MergeTreePartition.h",
    "src/Storages/StorageReplicatedMergeTree.cpp"
  ],
  "modified_test_files": [
    "tests/integration/test_lost_part/test.py",
    "b/tests/queries/0_stateless/01165_lost_part_empty_partition.sql",
    "tests/queries/0_stateless/02009_array_join_partition.sql"
  ]
}