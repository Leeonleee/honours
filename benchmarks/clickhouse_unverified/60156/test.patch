diff --git a/src/Functions/tests/gtest_hilbert_curve.cpp b/src/Functions/tests/gtest_hilbert_curve.cpp
new file mode 100644
index 000000000000..8e2c1b1b1aa2
--- /dev/null
+++ b/src/Functions/tests/gtest_hilbert_curve.cpp
@@ -0,0 +1,81 @@
+#include <gtest/gtest.h>
+#include "Functions/hilbertDecode2DLUT.h"
+#include "Functions/hilbertEncode2DLUT.h"
+#include "base/types.h"
+
+
+TEST(HilbertLookupTable, EncodeBit1And3Consistency)
+{
+    const size_t bound = 1000;
+    for (size_t x = 0; x < bound; ++x)
+    {
+        for (size_t y = 0; y < bound; ++y)
+        {
+            auto hilbert1bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<1>::encode(x, y);
+            auto hilbert3bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);
+            ASSERT_EQ(hilbert1bit, hilbert3bit);
+        }
+    }
+}
+
+TEST(HilbertLookupTable, EncodeBit2And3Consistency)
+{
+    const size_t bound = 1000;
+    for (size_t x = 0; x < bound; ++x)
+    {
+        for (size_t y = 0; y < bound; ++y)
+        {
+            auto hilbert2bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<2>::encode(x, y);
+            auto hilbert3bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);
+            ASSERT_EQ(hilbert3bit, hilbert2bit);
+        }
+    }
+}
+
+TEST(HilbertLookupTable, DecodeBit1And3Consistency)
+{
+    const size_t bound = 1000 * 1000;
+    for (size_t hilbert_code = 0; hilbert_code < bound; ++hilbert_code)
+    {
+        auto res1 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<1>::decode(hilbert_code);
+        auto res3 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);
+        ASSERT_EQ(res1, res3);
+    }
+}
+
+TEST(HilbertLookupTable, DecodeBit2And3Consistency)
+{
+    const size_t bound = 1000 * 1000;
+    for (size_t hilbert_code = 0; hilbert_code < bound; ++hilbert_code)
+    {
+        auto res2 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<2>::decode(hilbert_code);
+        auto res3 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);
+        ASSERT_EQ(res2, res3);
+    }
+}
+
+TEST(HilbertLookupTable, DecodeAndEncodeAreInverseOperations)
+{
+    const size_t bound = 1000;
+    for (size_t x = 0; x < bound; ++x)
+    {
+        for (size_t y = 0; y < bound; ++y)
+        {
+            auto hilbert_code = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);
+            auto [x_new, y_new] = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);
+            ASSERT_EQ(x_new, x);
+            ASSERT_EQ(y_new, y);
+        }
+    }
+}
+
+TEST(HilbertLookupTable, EncodeAndDecodeAreInverseOperations)
+{
+    const size_t bound = 1000 * 1000;
+    for (size_t hilbert_code = 0; hilbert_code < bound; ++hilbert_code)
+    {
+        auto [x, y] = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);
+        auto hilbert_new = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);
+        ASSERT_EQ(hilbert_new, hilbert_code);
+    }
+}
diff --git a/tests/queries/0_stateless/03131_hilbert_coding.reference b/tests/queries/0_stateless/03131_hilbert_coding.reference
new file mode 100644
index 000000000000..bdb578483faf
--- /dev/null
+++ b/tests/queries/0_stateless/03131_hilbert_coding.reference
@@ -0,0 +1,8 @@
+----- START -----
+----- CONST -----
+133
+31
+(3,4)
+----- 4294967296, 2 -----
+----- ERRORS -----
+----- END -----
diff --git a/tests/queries/0_stateless/03131_hilbert_coding.sql b/tests/queries/0_stateless/03131_hilbert_coding.sql
new file mode 100644
index 000000000000..ed293dc6910a
--- /dev/null
+++ b/tests/queries/0_stateless/03131_hilbert_coding.sql
@@ -0,0 +1,55 @@
+SELECT '----- START -----';
+drop table if exists hilbert_numbers_03131;
+create table hilbert_numbers_03131(
+    n1 UInt32,
+    n2 UInt32
+)
+    Engine=MergeTree()
+    ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
+
+SELECT '----- CONST -----';
+select hilbertEncode(133);
+select hilbertEncode(3, 4);
+select hilbertDecode(2, 31);
+
+SELECT '----- 4294967296, 2 -----';
+insert into hilbert_numbers_03131
+select n1.number, n2.number
+from numbers(pow(2, 32)-8,8) n1
+    cross join numbers(pow(2, 32)-8, 8) n2
+;
+
+drop table if exists hilbert_numbers_1_03131;
+create table hilbert_numbers_1_03131(
+    n1 UInt64,
+    n2 UInt64
+)
+    Engine=MergeTree()
+    ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';
+
+insert into hilbert_numbers_1_03131
+select untuple(hilbertDecode(2, hilbertEncode(n1, n2)))
+from hilbert_numbers_03131;
+
+(
+    select n1, n2 from hilbert_numbers_03131
+    union distinct
+    select n1, n2 from hilbert_numbers_1_03131
+)
+except
+(
+    select n1, n2 from hilbert_numbers_03131
+    intersect
+    select n1, n2 from hilbert_numbers_1_03131
+);
+drop table if exists hilbert_numbers_1_03131;
+
+select '----- ERRORS -----';
+select hilbertEncode(); -- { serverError TOO_FEW_ARGUMENTS_FOR_FUNCTION }
+select hilbertDecode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }
+select hilbertEncode('text'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+select hilbertDecode('text', 'text'); -- { serverError ILLEGAL_COLUMN }
+select hilbertEncode((1, 2), 3); -- { serverError ARGUMENT_OUT_OF_BOUND }
+
+SELECT '----- END -----';
+drop table if exists hilbert_numbers_03131;
