diff --git a/base/base/find_symbols.h b/base/base/find_symbols.h
index 6d4c96f911c3..eb1290dd2894 100644
--- a/base/base/find_symbols.h
+++ b/base/base/find_symbols.h
@@ -33,6 +33,10 @@
   *
   * Allow to search for the last matching character in a string.
   * If no such characters, returns nullptr.
+  *
+  * count_symbols<c1, c2, ...>(begin, end):
+  *
+  * Count the number of symbols of the set in a string.
   */
 
 struct SearchSymbols
@@ -441,6 +445,15 @@ inline char * find_last_not_symbols_or_null(char * begin, char * end)
     return const_cast<char *>(detail::find_last_symbols_sse2<false, detail::ReturnMode::Nullptr, symbols...>(begin, end));
 }
 
+template <char... symbols>
+inline size_t count_symbols(const char * begin, const char * end)
+{
+    size_t res = 0;
+    for (const auto * ptr = begin; ptr < end; ++ptr)
+        res += detail::is_in<symbols...>(*ptr);
+    return res;
+}
+
 
 /// Slightly resembles boost::split. The drawback of boost::split is that it fires a false positive in clang static analyzer.
 /// See https://github.com/boostorg/algorithm/issues/63
diff --git a/docs/en/operations/system-tables/query_log.md b/docs/en/operations/system-tables/query_log.md
index 0975771dfd4d..5e34f130b143 100644
--- a/docs/en/operations/system-tables/query_log.md
+++ b/docs/en/operations/system-tables/query_log.md
@@ -94,6 +94,8 @@ Columns:
 - `client_version_major` ([UInt32](../../sql-reference/data-types/int-uint.md)) — Major version of the [clickhouse-client](../../interfaces/cli.md) or another TCP client.
 - `client_version_minor` ([UInt32](../../sql-reference/data-types/int-uint.md)) — Minor version of the [clickhouse-client](../../interfaces/cli.md) or another TCP client.
 - `client_version_patch` ([UInt32](../../sql-reference/data-types/int-uint.md)) — Patch component of the [clickhouse-client](../../interfaces/cli.md) or another TCP client version.
+- `script_query_number` ([UInt32](../../sql-reference/data-types/int-uint.md)) — A sequential query number in a multi-query script in [clickhouse-client](../../interfaces/cli.md).
+- `script_line_number` ([UInt32](../../sql-reference/data-types/int-uint.md)) — A line number in a multi-query script in [clickhouse-client](../../interfaces/cli.md) where the current query starts.
 - `http_method` (UInt8) — HTTP method that initiated the query. Possible values:
     - 0 — The query was launched from the TCP interface.
     - 1 — `GET` method was used.
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index 393188a0bd64..3948b17f7ef9 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -1172,7 +1172,8 @@ void ClientBase::processOrdinaryQuery(const String & query_to_execute, ASTPtr pa
             query_interrupt_handler.start(signals_before_stop);
             SCOPE_EXIT({ query_interrupt_handler.stop(); });
 
-            try {
+            try
+            {
                 connection->sendQuery(
                     connection_parameters.timeouts,
                     query,
@@ -2417,6 +2418,10 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
     const char * this_query_end;
     const char * all_queries_end = all_queries_text.data() + all_queries_text.size();
 
+    const char * prev_query_begin = all_queries_text.data();
+    UInt32 script_query_number = 0;
+    UInt32 script_line_number = 0;
+
     String full_query; // full_query is the query + inline INSERT data + trailing comments (the latter is our best guess for now).
     String query_to_execute;
     ASTPtr parsed_query;
@@ -2480,6 +2485,12 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)
             {
                 is_first = false;
                 full_query = all_queries_text.substr(this_query_begin - all_queries_text.data(), this_query_end - this_query_begin);
+
+                ++script_query_number;
+                script_line_number += count_symbols<'
'>(prev_query_begin, this_query_begin);
+                prev_query_begin = this_query_begin;
+                client_context->setScriptLineNumbers(script_query_number, 1 + script_line_number);
+
                 if (query_fuzzer_runs)
                 {
                     if (!processWithFuzzing(full_query))
diff --git a/src/Core/ProtocolDefines.h b/src/Core/ProtocolDefines.h
index a1c2f4b94fa2..bc98cc94f9a7 100644
--- a/src/Core/ProtocolDefines.h
+++ b/src/Core/ProtocolDefines.h
@@ -39,10 +39,11 @@ static constexpr auto DBMS_MIN_SUPPORTED_PARALLEL_REPLICAS_PROTOCOL_VERSION = 3;
 static constexpr auto DBMS_PARALLEL_REPLICAS_MIN_VERSION_WITH_MARK_SEGMENT_SIZE_FIELD = 4;
 static constexpr auto DBMS_PARALLEL_REPLICAS_PROTOCOL_VERSION = 4;
 static constexpr auto DBMS_MIN_REVISION_WITH_PARALLEL_REPLICAS = 54453;
+static constexpr auto DBMS_MIN_REVISION_WITH_QUERY_AND_LINE_NUMBERS = 54475;
 
 static constexpr auto DBMS_MERGE_TREE_PART_INFO_VERSION = 1;
 
-static constexpr auto DBMS_QUERY_PLAN_SERIALIZATIONL_VERSION = 0;
+static constexpr auto DBMS_QUERY_PLAN_SERIALIZATION_VERSION = 0;
 
 static constexpr auto DBMS_MIN_REVISION_WITH_INTERSERVER_SECRET = 54441;
 
@@ -108,6 +109,6 @@ static constexpr auto DBMS_MIN_REVISION_WITH_SERVER_SETTINGS = 54474;
 /// NOTE: DBMS_TCP_PROTOCOL_VERSION has nothing common with VERSION_REVISION,
 /// later is just a number for server version (one number instead of commit SHA)
 /// for simplicity (sometimes it may be more convenient in some use cases).
-static constexpr auto DBMS_TCP_PROTOCOL_VERSION = 54474;
+static constexpr auto DBMS_TCP_PROTOCOL_VERSION = 54475;
 
 }
diff --git a/src/Interpreters/ClientInfo.cpp b/src/Interpreters/ClientInfo.cpp
index a2ade948a29d..6a06b20b07a2 100644
--- a/src/Interpreters/ClientInfo.cpp
+++ b/src/Interpreters/ClientInfo.cpp
@@ -98,6 +98,12 @@ void ClientInfo::write(WriteBuffer & out, UInt64 server_protocol_revision) const
         writeVarUInt(obsolete_count_participating_replicas, out);
         writeVarUInt(number_of_current_replica, out);
     }
+
+    if (server_protocol_revision >= DBMS_MIN_REVISION_WITH_QUERY_AND_LINE_NUMBERS)
+    {
+        writeVarUInt(script_query_number, out);
+        writeVarUInt(script_line_number, out);
+    }
 }
 
 
@@ -188,6 +194,12 @@ void ClientInfo::read(ReadBuffer & in, UInt64 client_protocol_revision)
         readVarUInt(obsolete_count_participating_replicas, in);
         readVarUInt(number_of_current_replica, in);
     }
+
+    if (client_protocol_revision >= DBMS_MIN_REVISION_WITH_QUERY_AND_LINE_NUMBERS)
+    {
+        readVarUInt(script_query_number, in);
+        readVarUInt(script_line_number, in);
+    }
 }
 
 
diff --git a/src/Interpreters/ClientInfo.h b/src/Interpreters/ClientInfo.h
index 9777e3044d9c..3212d9b65842 100644
--- a/src/Interpreters/ClientInfo.h
+++ b/src/Interpreters/ClientInfo.h
@@ -86,7 +86,11 @@ class ClientInfo
     UInt64 client_version_major = 0;
     UInt64 client_version_minor = 0;
     UInt64 client_version_patch = 0;
-    unsigned client_tcp_protocol_version = 0;
+    UInt32 client_tcp_protocol_version = 0;
+
+    /// Numbers are starting from 1. Zero means unset.
+    UInt32 script_query_number = 0;
+    UInt32 script_line_number = 0;
 
     /// In case of distributed query, client info for query is actually a client info of client.
     /// In order to get a version of server-initiator, use connection_ values.
@@ -94,7 +98,7 @@ class ClientInfo
     UInt64 connection_client_version_major = 0;
     UInt64 connection_client_version_minor = 0;
     UInt64 connection_client_version_patch = 0;
-    unsigned connection_tcp_protocol_version = 0;
+    UInt32 connection_tcp_protocol_version = 0;
 
     /// For http
     HTTPMethod http_method = HTTPMethod::UNKNOWN;
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index 432e60913072..12ba20e41e24 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -5376,6 +5376,12 @@ void Context::setClientVersion(UInt64 client_version_major, UInt64 client_versio
     client_info.client_tcp_protocol_version = client_tcp_protocol_version;
 }
 
+void Context::setScriptLineNumbers(uint32_t query_number, uint32_t line_number)
+{
+    client_info.script_query_number = query_number;
+    client_info.script_line_number = line_number;
+}
+
 void Context::setClientConnectionId(uint32_t connection_id_)
 {
     client_info.connection_id = connection_id_;
diff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h
index 67524d0f7930..86973521b977 100644
--- a/src/Interpreters/Context.h
+++ b/src/Interpreters/Context.h
@@ -721,6 +721,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>
     void setClientInterface(ClientInfo::Interface interface);
     void setClientVersion(UInt64 client_version_major, UInt64 client_version_minor, UInt64 client_version_patch, unsigned client_tcp_protocol_version);
     void setClientConnectionId(uint32_t connection_id);
+    void setScriptLineNumbers(uint32_t query_number, uint32_t line_number);
     void setHTTPClientInfo(const Poco::Net::HTTPRequest & request);
     void setForwardedFor(const String & forwarded_for);
     void setQueryKind(ClientInfo::QueryKind query_kind);
diff --git a/src/Interpreters/QueryLog.cpp b/src/Interpreters/QueryLog.cpp
index 527159dc981b..1c3f0db5f315 100644
--- a/src/Interpreters/QueryLog.cpp
+++ b/src/Interpreters/QueryLog.cpp
@@ -109,6 +109,8 @@ ColumnsDescription QueryLogElement::getColumnsDescription()
         {"client_version_major", std::make_shared<DataTypeUInt32>(), "Major version of the clickhouse-client or another TCP client."},
         {"client_version_minor", std::make_shared<DataTypeUInt32>(), "Minor version of the clickhouse-client or another TCP client."},
         {"client_version_patch", std::make_shared<DataTypeUInt32>(), "Patch component of the clickhouse-client or another TCP client version."},
+        {"script_query_number", std::make_shared<DataTypeUInt32>(), "A sequential query number in a multi-query script."},
+        {"script_line_number", std::make_shared<DataTypeUInt32>(), "A line number in a multi-query script where the current query starts."},
         {"http_method", std::make_shared<DataTypeUInt8>(), "HTTP method that initiated the query. Possible values: 0 — The query was launched from the TCP interface, 1 — GET method was used, 2 — POST method was used."},
         {"http_user_agent", low_cardinality_string, "HTTP header UserAgent passed in the HTTP query."},
         {"http_referer", std::make_shared<DataTypeString>(), "HTTP header Referer passed in the HTTP query (contains an absolute or partial address of the page making the query)."},
@@ -337,6 +339,9 @@ void QueryLogElement::appendClientInfo(const ClientInfo & client_info, MutableCo
     columns[i++]->insert(client_info.client_version_minor);
     columns[i++]->insert(client_info.client_version_patch);
 
+    columns[i++]->insert(client_info.script_query_number);
+    columns[i++]->insert(client_info.script_line_number);
+
     columns[i++]->insert(static_cast<UInt64>(client_info.http_method));
     columns[i++]->insert(client_info.http_user_agent);
     columns[i++]->insert(client_info.http_referer);
diff --git a/src/Interpreters/QueryThreadLog.cpp b/src/Interpreters/QueryThreadLog.cpp
index f50458745b9b..c46ee278c6a0 100644
--- a/src/Interpreters/QueryThreadLog.cpp
+++ b/src/Interpreters/QueryThreadLog.cpp
@@ -70,6 +70,8 @@ ColumnsDescription QueryThreadLogElement::getColumnsDescription()
         {"client_version_major", std::make_shared<DataTypeUInt32>(), "Major version of the clickhouse-client or another TCP client."},
         {"client_version_minor", std::make_shared<DataTypeUInt32>(), "Minor version of the clickhouse-client or another TCP client."},
         {"client_version_patch", std::make_shared<DataTypeUInt32>(), "Patch component of the clickhouse-client or another TCP client version."},
+        {"script_query_number", std::make_shared<DataTypeUInt32>(), "A sequential query number in a multi-query script."},
+        {"script_line_number", std::make_shared<DataTypeUInt32>(), "A line number in a multi-query script where the current query starts."},
         {"http_method", std::make_shared<DataTypeUInt8>(), "HTTP method that initiated the query. Possible values: 0 — The query was launched from the TCP interface, 1 — GET method was used., 2 — POST method was used."},
         {"http_user_agent", low_cardinality_string, "The UserAgent header passed in the HTTP request."},
         {"http_referer", std::make_shared<DataTypeString>(), "HTTP header `Referer` passed in the HTTP query (contains an absolute or partial address of the page making the query)."},
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index fe6d15c06e0a..2e9ceeb274e2 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -223,16 +223,21 @@ static void logQuery(const String & query, ContextPtr context, bool internal, Qu
         if (!comment.empty())
             comment = fmt::format(" (comment: {})", comment);
 
+        String line_info;
+        if (client_info.script_line_number)
+            line_info = fmt::format(" (query {}, line {})", client_info.script_query_number, client_info.script_line_number);
+
         String transaction_info;
         if (auto txn = context->getCurrentTransaction())
             transaction_info = fmt::format(" (TID: {}, TIDH: {})", txn->tid, txn->tid.getHash());
 
-        LOG_DEBUG(getLogger("executeQuery"), "(from {}{}{}){}{} {} (stage: {})",
+        LOG_DEBUG(getLogger("executeQuery"), "(from {}{}{}){}{}{} {} (stage: {})",
             client_info.current_address.toString(),
             (current_user != "default" ? ", user: " + current_user : ""),
             (!initial_query_id.empty() && current_query_id != initial_query_id ? ", initial_query_id: " + initial_query_id : std::string()),
             transaction_info,
             comment,
+            line_info,
             toOneLineQuery(query),
             QueryProcessingStage::toString(stage));
 
@@ -278,17 +283,24 @@ static void logException(ContextPtr context, QueryLogElement & elem, bool log_er
     message.format_string = elem.exception_format_string;
     message.format_string_args = elem.exception_format_string_args;
 
+    const auto & client_info = context->getClientInfo();
+    String line_info;
+    if (client_info.script_line_number)
+        line_info = fmt::format(" (query {}, line {})", client_info.script_query_number, client_info.script_line_number);
+
     if (elem.stack_trace.empty() || !log_error)
-        message.text = fmt::format("{} (from {}){} (in query: {})", elem.exception,
+        message.text = fmt::format("{} (from {}){}{} (in query: {})", elem.exception,
                         context->getClientInfo().current_address.toString(),
                         comment,
+                        line_info,
                         toOneLineQuery(elem.query));
     else
         message.text = fmt::format(
-            "{} (from {}){} (in query: {}), Stack trace (when copying this message, always include the lines below):

{}",
+            "{} (from {}){}{} (in query: {}), Stack trace (when copying this message, always include the lines below):

{}",
             elem.exception,
             context->getClientInfo().current_address.toString(),
             comment,
+            line_info,
             toOneLineQuery(elem.query),
             elem.stack_trace);
 
diff --git a/src/Processors/QueryPlan/Serialization.cpp b/src/Processors/QueryPlan/Serialization.cpp
index 16d78496e509..172929efd4e8 100644
--- a/src/Processors/QueryPlan/Serialization.cpp
+++ b/src/Processors/QueryPlan/Serialization.cpp
@@ -64,7 +64,7 @@ struct QueryPlan::SerializationFlags
 
 void QueryPlan::serialize(WriteBuffer & out, size_t max_supported_version) const
 {
-    UInt64 version = std::min<UInt64>(max_supported_version, DBMS_QUERY_PLAN_SERIALIZATIONL_VERSION);
+    UInt64 version = std::min<UInt64>(max_supported_version, DBMS_QUERY_PLAN_SERIALIZATION_VERSION);
     writeVarUInt(version, out);
 
     SerializationFlags flags;
@@ -135,10 +135,10 @@ QueryPlanAndSets QueryPlan::deserialize(ReadBuffer & in, const ContextPtr & cont
     UInt64 version;
     readVarUInt(version, in);
 
-    if (version > DBMS_QUERY_PLAN_SERIALIZATIONL_VERSION)
+    if (version > DBMS_QUERY_PLAN_SERIALIZATION_VERSION)
         throw Exception(ErrorCodes::NOT_IMPLEMENTED,
             "Query plan serialization version {} is not supported. The last supported version is {}",
-            version, DBMS_QUERY_PLAN_SERIALIZATIONL_VERSION);
+            version, DBMS_QUERY_PLAN_SERIALIZATION_VERSION);
 
     SerializationFlags flags;
     return deserialize(in, context, flags);
