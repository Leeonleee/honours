diff --git a/dbms/src/Functions/neighbor.cpp b/dbms/src/Functions/neighbor.cpp
index 0253aed65d3f..c37a3313a806 100644
--- a/dbms/src/Functions/neighbor.cpp
+++ b/dbms/src/Functions/neighbor.cpp
@@ -40,6 +40,8 @@ class FunctionNeighbor : public IFunction
 
     bool isVariadic() const override { return true; }
 
+    bool isStateful() const override { return true; }
+
     bool isDeterministic() const override { return false; }
 
     bool isDeterministicInScopeOfQuery() const override { return false; }
diff --git a/dbms/src/Interpreters/DatabaseAndTableWithAlias.h b/dbms/src/Interpreters/DatabaseAndTableWithAlias.h
index 3567a351b14c..ad1f747b6fd1 100644
--- a/dbms/src/Interpreters/DatabaseAndTableWithAlias.h
+++ b/dbms/src/Interpreters/DatabaseAndTableWithAlias.h
@@ -72,4 +72,6 @@ struct TableWithColumnNames
 std::vector<DatabaseAndTableWithAlias> getDatabaseAndTables(const ASTSelectQuery & select_query, const String & current_database);
 std::optional<DatabaseAndTableWithAlias> getDatabaseAndTable(const ASTSelectQuery & select, size_t table_number);
 
+using TablesWithColumnNames = std::vector<TableWithColumnNames>;
+
 }
diff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp
index 59dff858cf0c..fa199f94efcf 100644
--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp
@@ -26,7 +26,6 @@
 #include <Interpreters/ExpressionActions.h>
 #include <Interpreters/InJoinSubqueriesPreprocessor.h>
 #include <Interpreters/LogicalExpressionsOptimizer.h>
-#include <Interpreters/PredicateExpressionsOptimizer.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
 #include <Interpreters/Set.h>
 #include <Interpreters/AnalyzedJoin.h>
diff --git a/dbms/src/Interpreters/ExtractExpressionInfoVisitor.cpp b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.cpp
new file mode 100644
index 000000000000..1240b6a09d65
--- /dev/null
+++ b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.cpp
@@ -0,0 +1,79 @@
+#include <Interpreters/ExtractExpressionInfoVisitor.h>
+#include <Functions/FunctionFactory.h>
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+#include <Interpreters/IdentifierSemantic.h>
+#include <Parsers/ASTSubquery.h>
+
+
+namespace DB
+{
+
+void ExpressionInfoMatcher::visit(const ASTPtr & ast, Data & data)
+{
+    if (const auto * function = ast->as<ASTFunction>())
+        visit(*function, ast, data);
+    else if (const auto * identifier = ast->as<ASTIdentifier>())
+        visit(*identifier, ast, data);
+}
+
+void ExpressionInfoMatcher::visit(const ASTFunction & ast_function, const ASTPtr &, Data & data)
+{
+    if (ast_function.name == "arrayJoin")
+        data.is_array_join = true;
+    else if (AggregateFunctionFactory::instance().isAggregateFunctionName(ast_function.name))
+        data.is_aggregate_function = true;
+    else
+    {
+        const auto & function = FunctionFactory::instance().tryGet(ast_function.name, data.context);
+
+        /// Skip lambda, tuple and other special functions
+        if (function && function->isStateful())
+            data.is_stateful_function = true;
+    }
+}
+
+void ExpressionInfoMatcher::visit(const ASTIdentifier & identifier, const ASTPtr &, Data & data)
+{
+    if (!identifier.compound())
+    {
+        for (size_t index = 0; index < data.tables.size(); ++index)
+        {
+            const auto & columns = data.tables[index].columns;
+
+            // TODO: make sure no collision ever happens
+            if (std::find(columns.begin(), columns.end(), identifier.name) != columns.end())
+            {
+                data.unique_reference_tables_pos.emplace(index);
+                break;
+            }
+        }
+    }
+    else
+    {
+        size_t best_table_pos = 0;
+        if (IdentifierSemantic::chooseTable(identifier, data.tables, best_table_pos))
+            data.unique_reference_tables_pos.emplace(best_table_pos);
+    }
+}
+
+bool ExpressionInfoMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)
+{
+    return !node->as<ASTSubquery>();
+}
+
+bool hasStatefulFunction(const ASTPtr & node, const Context & context)
+{
+    for (const auto & select_expression : node->children)
+    {
+        ExpressionInfoVisitor::Data expression_info{.context = context, .tables = {}};
+        ExpressionInfoVisitor(expression_info).visit(select_expression);
+
+        if (expression_info.is_stateful_function)
+            return true;
+    }
+
+    return false;
+}
+
+}
+
diff --git a/dbms/src/Interpreters/ExtractExpressionInfoVisitor.h b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.h
new file mode 100644
index 000000000000..65d23057e526
--- /dev/null
+++ b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.h
@@ -0,0 +1,40 @@
+#pragma once
+
+#include <Parsers/IAST_fwd.h>
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Interpreters/InDepthNodeVisitor.h>
+#include <Interpreters/DatabaseAndTableWithAlias.h>
+
+namespace DB
+{
+
+class Context;
+
+struct ExpressionInfoMatcher
+{
+    struct Data
+    {
+        const Context & context;
+        const std::vector<TableWithColumnNames> & tables;
+
+        bool is_array_join = false;
+        bool is_stateful_function = false;
+        bool is_aggregate_function = false;
+        std::unordered_set<size_t> unique_reference_tables_pos = {};
+    };
+
+    static void visit(const ASTPtr & ast, Data & data);
+
+    static bool needChildVisit(const ASTPtr & node, const ASTPtr &);
+
+    static void visit(const ASTFunction & ast_function, const ASTPtr &, Data & data);
+
+    static void visit(const ASTIdentifier & identifier, const ASTPtr &, Data & data);
+};
+
+using ExpressionInfoVisitor = ConstInDepthNodeVisitor<ExpressionInfoMatcher, true>;
+
+bool hasStatefulFunction(const ASTPtr & node, const Context & context);
+
+}
diff --git a/dbms/src/Interpreters/ExtractFunctionDataVisitor.cpp b/dbms/src/Interpreters/ExtractFunctionDataVisitor.cpp
deleted file mode 100644
index d7a0d9001d53..000000000000
--- a/dbms/src/Interpreters/ExtractFunctionDataVisitor.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-#include <Interpreters/ExtractFunctionDataVisitor.h>
-#include <AggregateFunctions/AggregateFunctionFactory.h>
-
-
-namespace DB
-{
-
-void ExtractFunctionData::visit(ASTFunction & function, ASTPtr &)
-{
-    if (AggregateFunctionFactory::instance().isAggregateFunctionName(function.name))
-        aggregate_functions.emplace_back(&function);
-    else
-        functions.emplace_back(&function);
-}
-
-}
diff --git a/dbms/src/Interpreters/ExtractFunctionDataVisitor.h b/dbms/src/Interpreters/ExtractFunctionDataVisitor.h
deleted file mode 100644
index ed3dbb868c4e..000000000000
--- a/dbms/src/Interpreters/ExtractFunctionDataVisitor.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#pragma once
-
-#include <Parsers/IAST.h>
-#include <Parsers/ASTFunction.h>
-#include <Parsers/ASTSelectQuery.h>
-#include <Parsers/ASTSelectWithUnionQuery.h>
-#include <Interpreters/InDepthNodeVisitor.h>
-
-namespace DB
-{
-
-struct ExtractFunctionData
-{
-    using TypeToVisit = ASTFunction;
-
-    std::vector<ASTFunction *> functions;
-    std::vector<ASTFunction *> aggregate_functions;
-
-    void visit(ASTFunction & identifier, ASTPtr &);
-};
-
-using ExtractFunctionMatcher = OneTypeMatcher<ExtractFunctionData>;
-using ExtractFunctionVisitor = InDepthNodeVisitor<ExtractFunctionMatcher, true>;
-
-}
diff --git a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.cpp b/dbms/src/Interpreters/FindIdentifierBestTableVisitor.cpp
deleted file mode 100644
index 56897ec15c72..000000000000
--- a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-#include <Interpreters/FindIdentifierBestTableVisitor.h>
-#include <Interpreters/IdentifierSemantic.h>
-
-
-namespace DB
-{
-
-FindIdentifierBestTableData::FindIdentifierBestTableData(const std::vector<TableWithColumnNames> & tables_)
-    : tables(tables_)
-{
-}
-
-void FindIdentifierBestTableData::visit(ASTIdentifier & identifier, ASTPtr &)
-{
-    const DatabaseAndTableWithAlias * best_table = nullptr;
-
-    if (!identifier.compound())
-    {
-        for (const auto & table_names : tables)
-        {
-            auto & columns = table_names.columns;
-            if (std::find(columns.begin(), columns.end(), identifier.name) != columns.end())
-            {
-                // TODO: make sure no collision ever happens
-                if (!best_table)
-                    best_table = &table_names.table;
-            }
-        }
-    }
-    else
-    {
-        size_t best_table_pos = 0;
-        if (IdentifierSemantic::chooseTable(identifier, tables, best_table_pos))
-            best_table = &tables[best_table_pos].table;
-    }
-
-    identifier_table.emplace_back(&identifier, best_table);
-}
-
-}
diff --git a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.h b/dbms/src/Interpreters/FindIdentifierBestTableVisitor.h
deleted file mode 100644
index 498ee60ab0bd..000000000000
--- a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.h
+++ /dev/null
@@ -1,27 +0,0 @@
-#pragma once
-
-#include <Parsers/IAST.h>
-#include <Parsers/ASTIdentifier.h>
-#include <Interpreters/InDepthNodeVisitor.h>
-#include <Interpreters/DatabaseAndTableWithAlias.h>
-
-namespace DB
-{
-
-struct FindIdentifierBestTableData
-{
-    using TypeToVisit = ASTIdentifier;
-    using IdentifierWithTable = std::pair<ASTIdentifier *, const DatabaseAndTableWithAlias *>;
-
-    const std::vector<TableWithColumnNames> & tables;
-    std::vector<IdentifierWithTable> identifier_table;
-
-    FindIdentifierBestTableData(const std::vector<TableWithColumnNames> & tables_);
-
-    void visit(ASTIdentifier & identifier, ASTPtr &);
-};
-
-using FindIdentifierBestTableMatcher = OneTypeMatcher<FindIdentifierBestTableData>;
-using FindIdentifierBestTableVisitor = InDepthNodeVisitor<FindIdentifierBestTableMatcher, true>;
-
-}
diff --git a/dbms/src/Interpreters/InDepthNodeVisitor.h b/dbms/src/Interpreters/InDepthNodeVisitor.h
index 18b84b11b242..7bb4f5e4d549 100644
--- a/dbms/src/Interpreters/InDepthNodeVisitor.h
+++ b/dbms/src/Interpreters/InDepthNodeVisitor.h
@@ -59,7 +59,13 @@ class OneTypeMatcher
     using Data = Data_;
     using TypeToVisit = typename Data::TypeToVisit;
 
-    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return visit_children; }
+    static bool needChildVisit(const ASTPtr & node, const ASTPtr &)
+    {
+        if (node && node->as<TypeToVisit>())
+            return visit_children;
+
+        return true;
+    }
 
     static void visit(T & ast, Data & data)
     {
diff --git a/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp b/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp
index 050ee637d185..9927091874c1 100644
--- a/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp
+++ b/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp
@@ -1,32 +1,13 @@
-#include <iostream>
-
-#include <Common/typeid_cast.h>
-#include <Storages/IStorage.h>
 #include <Interpreters/PredicateExpressionsOptimizer.h>
-#include <Interpreters/InterpreterSelectQuery.h>
-#include <Interpreters/IdentifierSemantic.h>
-#include <AggregateFunctions/AggregateFunctionFactory.h>
+
 #include <Parsers/IAST.h>
 #include <Parsers/ASTFunction.h>
-#include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTSelectQuery.h>
-#include <Parsers/ASTSelectWithUnionQuery.h>
-#include <Parsers/ASTSubquery.h>
 #include <Parsers/ASTTablesInSelectQuery.h>
-#include <Parsers/ASTAsterisk.h>
-#include <Parsers/ASTQualifiedAsterisk.h>
-#include <Parsers/ASTColumnsMatcher.h>
-#include <Parsers/queryToString.h>
 #include <Interpreters/Context.h>
-#include <Interpreters/ExpressionActions.h>
-#include <Interpreters/QueryNormalizer.h>
-#include <Interpreters/QueryAliasesVisitor.h>
-#include <Interpreters/MarkTableIdentifiersVisitor.h>
-#include <Interpreters/TranslateQualifiedNamesVisitor.h>
-#include <Interpreters/FindIdentifierBestTableVisitor.h>
-#include <Interpreters/ExtractFunctionDataVisitor.h>
 #include <Interpreters/getTableExpressions.h>
-#include <Functions/FunctionFactory.h>
+#include <Interpreters/PredicateRewriteVisitor.h>
+#include <Interpreters/ExtractExpressionInfoVisitor.h>
 
 
 namespace DB
@@ -38,155 +19,105 @@ namespace ErrorCodes
     extern const int UNKNOWN_ELEMENT_IN_AST;
 }
 
-namespace
-{
-
-constexpr auto and_function_name = "and";
-
-String qualifiedName(ASTIdentifier * identifier, const String & prefix)
-{
-    if (identifier->isShort())
-        return prefix + identifier->getAliasOrColumnName();
-    return identifier->getAliasOrColumnName();
-}
-
-}
-
 PredicateExpressionsOptimizer::PredicateExpressionsOptimizer(
-    ASTSelectQuery * ast_select_, ExtractedSettings && settings_, const Context & context_)
-    : ast_select(ast_select_), settings(settings_), context(context_)
+    const Context & context_, const TablesWithColumnNames & tables_with_columns_, const Settings & settings_)
+    : context(context_), tables_with_columns(tables_with_columns_), settings(settings_)
 {
 }
 
-bool PredicateExpressionsOptimizer::optimize()
+bool PredicateExpressionsOptimizer::optimize(ASTSelectQuery & select_query)
 {
-    if (!settings.enable_optimize_predicate_expression || !ast_select || !ast_select->tables() || ast_select->tables()->children.empty())
+    if (!settings.enable_optimize_predicate_expression)
         return false;
 
-    if (!ast_select->where() && !ast_select->prewhere())
+    if (select_query.having() && (!select_query.group_by_with_cube && !select_query.group_by_with_rollup && !select_query.group_by_with_totals))
+        tryMovePredicatesFromHavingToWhere(select_query);
+
+    if (!select_query.tables() || select_query.tables()->children.empty())
         return false;
 
-    if (ast_select->array_join_expression_list())
+    if ((!select_query.where() && !select_query.prewhere()) || select_query.array_join_expression_list())
         return false;
 
-    SubqueriesProjectionColumns all_subquery_projection_columns = getAllSubqueryProjectionColumns();
+    const auto & tables_predicates = extractTablesPredicates(select_query.where(), select_query.prewhere());
 
-    bool is_rewrite_subqueries = false;
-    if (!all_subquery_projection_columns.empty())
-    {
-        is_rewrite_subqueries |= optimizeImpl(ast_select->where(), all_subquery_projection_columns, OptimizeKind::PUSH_TO_WHERE);
-        is_rewrite_subqueries |= optimizeImpl(ast_select->prewhere(), all_subquery_projection_columns, OptimizeKind::PUSH_TO_PREWHERE);
-    }
+    if (!tables_predicates.empty())
+        return tryRewritePredicatesToTables(select_query.refTables()->children, tables_predicates);
 
-    return is_rewrite_subqueries;
+    return false;
 }
 
-bool PredicateExpressionsOptimizer::optimizeImpl(
-    const ASTPtr & outer_expression, const SubqueriesProjectionColumns & subqueries_projection_columns, OptimizeKind expression_kind)
+static ASTs splitConjunctionPredicate(const std::initializer_list<const ASTPtr> & predicates)
 {
-    /// split predicate with `and`
-    std::vector<ASTPtr> outer_predicate_expressions = splitConjunctionPredicate(outer_expression);
+    std::vector<ASTPtr> res;
 
-    std::vector<const ASTTableExpression *> table_expressions = getTableExpressions(*ast_select);
-    std::vector<TableWithColumnNames> tables_with_columns = getDatabaseAndTablesWithColumnNames(table_expressions, context);
+    auto remove_expression_at_index = [&res] (const size_t index)
+    {
+        if (index < res.size() - 1)
+            std::swap(res[index], res.back());
+        res.pop_back();
+    };
 
-    bool is_rewrite_subquery = false;
-    for (auto & outer_predicate : outer_predicate_expressions)
+    for (const auto & predicate : predicates)
     {
-        if (isArrayJoinFunction(outer_predicate))
+        if (!predicate)
             continue;
 
-        auto outer_predicate_dependencies = getDependenciesAndQualifiers(outer_predicate, tables_with_columns);
+        res.emplace_back(predicate);
 
-        /// TODO: remove origin expression
-        for (const auto & [subquery, projection_columns] : subqueries_projection_columns)
+        for (size_t idx = 0; idx < res.size();)
         {
-            OptimizeKind optimize_kind = OptimizeKind::NONE;
-            if (allowPushDown(subquery, outer_predicate, projection_columns, outer_predicate_dependencies, optimize_kind))
+            const auto & expression = res.at(idx);
+
+            if (const auto * function = expression->as<ASTFunction>(); function && function->name == "and")
             {
-                if (optimize_kind == OptimizeKind::NONE)
-                    optimize_kind = expression_kind;
-
-                ASTPtr inner_predicate = outer_predicate->clone();
-                cleanExpressionAlias(inner_predicate); /// clears the alias name contained in the outer predicate
-
-                std::vector<IdentifierWithQualifier> inner_predicate_dependencies =
-                    getDependenciesAndQualifiers(inner_predicate, tables_with_columns);
-
-                setNewAliasesForInnerPredicate(projection_columns, inner_predicate_dependencies);
-
-                switch (optimize_kind)
-                {
-                    case OptimizeKind::NONE: continue;
-                    case OptimizeKind::PUSH_TO_WHERE:
-                        is_rewrite_subquery |= optimizeExpression(inner_predicate, subquery, ASTSelectQuery::Expression::WHERE);
-                        continue;
-                    case OptimizeKind::PUSH_TO_HAVING:
-                        is_rewrite_subquery |= optimizeExpression(inner_predicate, subquery, ASTSelectQuery::Expression::HAVING);
-                        continue;
-                    case OptimizeKind::PUSH_TO_PREWHERE:
-                        is_rewrite_subquery |= optimizeExpression(inner_predicate, subquery, ASTSelectQuery::Expression::PREWHERE);
-                        continue;
-                }
+                for (auto & child : function->arguments->children)
+                    res.emplace_back(child);
+
+                remove_expression_at_index(idx);
+                continue;
             }
+            ++idx;
         }
     }
-    return is_rewrite_subquery;
+
+    return res;
 }
 
-bool PredicateExpressionsOptimizer::allowPushDown(
-    const ASTSelectQuery * subquery,
-    const ASTPtr &,
-    const std::vector<ProjectionWithAlias> & projection_columns,
-    const std::vector<IdentifierWithQualifier> & dependencies,
-    OptimizeKind & optimize_kind)
+std::vector<ASTs> PredicateExpressionsOptimizer::extractTablesPredicates(const ASTPtr & where, const ASTPtr & prewhere)
 {
-    if (!subquery
-        || (!settings.enable_optimize_predicate_expression_to_final_subquery && subquery->final())
-        || subquery->limitBy() || subquery->limitLength()
-        || subquery->with() || subquery->withFill())
-        return false;
-    else
+    std::vector<ASTs> tables_predicates(tables_with_columns.size());
+
+    for (const auto & predicate_expression : splitConjunctionPredicate({where, prewhere}))
     {
-        ASTPtr expr_list = ast_select->select();
-        ExtractFunctionVisitor::Data extract_data;
-        ExtractFunctionVisitor(extract_data).visit(expr_list);
+        ExpressionInfoVisitor::Data expression_info{.context = context, .tables = tables_with_columns};
+        ExpressionInfoVisitor(expression_info).visit(predicate_expression);
 
-        for (const auto & subquery_function : extract_data.functions)
-        {
-            const auto & function = FunctionFactory::instance().tryGet(subquery_function->name, context);
+        if (expression_info.is_stateful_function)
+            return {};   /// give up the optimization when the predicate contains stateful function
 
-            /// Skip lambda, tuple and other special functions
-            if (function && function->isStateful())
-                return false;
+        if (!expression_info.is_array_join)
+        {
+            if (expression_info.unique_reference_tables_pos.size() == 1)
+                tables_predicates[*expression_info.unique_reference_tables_pos.begin()].emplace_back(predicate_expression);
+            else if (expression_info.unique_reference_tables_pos.size() == 0)
+            {
+                for (size_t index = 0; index < tables_predicates.size(); ++index)
+                    tables_predicates[index].emplace_back(predicate_expression);
+            }
         }
     }
 
-    const auto * ast_join = ast_select->join();
-    const ASTTableExpression * left_table_expr = nullptr;
-    const ASTTableExpression * right_table_expr = nullptr;
-    const ASTSelectQuery * left_subquery = nullptr;
-    const ASTSelectQuery * right_subquery = nullptr;
+    return tables_predicates;    /// everything is OK, it can be optimized
+}
+
+bool PredicateExpressionsOptimizer::tryRewritePredicatesToTables(ASTs & tables_element, const std::vector<ASTs> & tables_predicates)
+{
+    bool is_rewrite_tables = false;
 
-    if (ast_join)
+    for (size_t index = tables_element.size(); index > 0; --index)
     {
-        left_table_expr = ast_select
-                                ->tables()->as<ASTTablesInSelectQuery>()
-                                ->children[0]->as<ASTTablesInSelectQueryElement>()
-                                ->table_expression->as<ASTTableExpression>();
-        right_table_expr = ast_select
-                                ->tables()->as<ASTTablesInSelectQuery>()
-                                ->children[1]->as<ASTTablesInSelectQueryElement>()
-                                ->table_expression->as<ASTTableExpression>();
-
-        if (left_table_expr && left_table_expr->subquery)
-            left_subquery = left_table_expr->subquery
-                                ->children[0]->as<ASTSelectWithUnionQuery>()
-                                ->list_of_selects->children[0]->as<ASTSelectQuery>();
-        if (right_table_expr && right_table_expr->subquery)
-            right_subquery = right_table_expr->subquery
-                                ->children[0]->as<ASTSelectWithUnionQuery>()
-                                ->list_of_selects->children[0]->as<ASTSelectQuery>();
+        size_t table_pos = index - 1;
 
         /// NOTE: the syntactic way of pushdown has limitations and should be partially disabled in case of JOINs.
         ///       Let's take a look at the query:
@@ -201,326 +132,84 @@ bool PredicateExpressionsOptimizer::allowPushDown(
         ///       It happens because the not-matching columns are replaced with a global default values on JOIN.
         ///       Same is true for RIGHT JOIN and FULL JOIN.
 
-        /// Check right side for LEFT'o'FULL JOIN
-        if (isLeftOrFull(ast_join->table_join->as<ASTTableJoin>()->kind) && right_subquery == subquery)
-            return false;
-
-        /// Check left side for RIGHT'o'FULL JOIN
-        if (isRightOrFull(ast_join->table_join->as<ASTTableJoin>()->kind) && left_subquery == subquery)
-            return false;
-    }
-
-    return checkDependencies(projection_columns, dependencies, optimize_kind);
-}
-
-bool PredicateExpressionsOptimizer::checkDependencies(
-    const std::vector<ProjectionWithAlias> & projection_columns,
-    const std::vector<IdentifierWithQualifier> & dependencies,
-    OptimizeKind & optimize_kind)
-{
-    for (const auto & [identifier, prefix] : dependencies)
-    {
-        bool is_found = false;
-        String qualified_name = qualifiedName(identifier, prefix);
-
-        for (const auto & [ast, alias] : projection_columns)
+        if (const auto & table_element = tables_element[table_pos]->as<ASTTablesInSelectQueryElement>())
         {
-            if (alias == qualified_name)
-            {
-                is_found = true;
-                ASTPtr projection_column = ast;
-                ExtractFunctionVisitor::Data extract_data;
-                ExtractFunctionVisitor(extract_data).visit(projection_column);
-
-                if (!extract_data.aggregate_functions.empty())
-                    optimize_kind = OptimizeKind::PUSH_TO_HAVING;
-            }
-        }
-
-        if (!is_found)
-            return false;
-    }
-
-    return true;
-}
-
-std::vector<ASTPtr> PredicateExpressionsOptimizer::splitConjunctionPredicate(const ASTPtr & predicate_expression)
-{
-    std::vector<ASTPtr> predicate_expressions;
+            if (table_element->table_join && isLeft(table_element->table_join->as<ASTTableJoin>()->kind))
+                continue;  /// Skip right table optimization
 
-    if (predicate_expression)
-    {
-        predicate_expressions.emplace_back(predicate_expression);
+            if (table_element->table_join && isFull(table_element->table_join->as<ASTTableJoin>()->kind))
+                break;  /// Skip left and right table optimization
 
-        auto remove_expression_at_index = [&predicate_expressions] (const size_t index)
-        {
-            if (index < predicate_expressions.size() - 1)
-                std::swap(predicate_expressions[index], predicate_expressions.back());
-            predicate_expressions.pop_back();
-        };
+            is_rewrite_tables |= tryRewritePredicatesToTable(tables_element[table_pos], tables_predicates[table_pos],
+                tables_with_columns[table_pos].columns);
 
-        for (size_t idx = 0; idx < predicate_expressions.size();)
-        {
-            const auto expression = predicate_expressions.at(idx);
-
-            if (const auto * function = expression->as<ASTFunction>())
-            {
-                if (function->name == and_function_name)
-                {
-                    for (auto & child : function->arguments->children)
-                        predicate_expressions.emplace_back(child);
-
-                    remove_expression_at_index(idx);
-                    continue;
-                }
-            }
-            ++idx;
+            if (table_element->table_join && isRight(table_element->table_join->as<ASTTableJoin>()->kind))
+                break;  /// Skip left table optimization
         }
     }
-    return predicate_expressions;
-}
 
-std::vector<PredicateExpressionsOptimizer::IdentifierWithQualifier>
-PredicateExpressionsOptimizer::getDependenciesAndQualifiers(ASTPtr & expression, std::vector<TableWithColumnNames> & tables)
-{
-    FindIdentifierBestTableVisitor::Data find_data(tables);
-    FindIdentifierBestTableVisitor(find_data).visit(expression);
-
-    std::vector<IdentifierWithQualifier> dependencies;
-
-    for (const auto & [identifier, table] : find_data.identifier_table)
-    {
-        String table_alias;
-        if (table)
-            table_alias = table->getQualifiedNamePrefix();
-
-        dependencies.emplace_back(identifier, table_alias);
-    }
-
-    return dependencies;
+    return is_rewrite_tables;
 }
 
-void PredicateExpressionsOptimizer::setNewAliasesForInnerPredicate(
-    const std::vector<ProjectionWithAlias> & projection_columns,
-    const std::vector<IdentifierWithQualifier> & dependencies)
+bool PredicateExpressionsOptimizer::tryRewritePredicatesToTable(ASTPtr & table_element, const ASTs & table_predicates, const Names & table_column) const
 {
-    for (auto & [identifier, prefix] : dependencies)
+    if (!table_predicates.empty())
     {
-        String qualified_name = qualifiedName(identifier, prefix);
-
-        for (auto & [ast, alias] : projection_columns)
-        {
-            if (alias == qualified_name)
-            {
-                String name;
-                if (auto * id = ast->as<ASTIdentifier>())
-                {
-                    name = id->tryGetAlias();
-                    if (name.empty())
-                        name = id->shortName();
-                }
-                else
-                {
-                    if (ast->tryGetAlias().empty())
-                        ast->setAlias(ast->getColumnName());
-                    name = ast->getAliasOrColumnName();
-                }
-
-                identifier->setShortName(name);
-            }
-        }
-    }
-}
+        auto optimize_final = settings.enable_optimize_predicate_expression_to_final_subquery;
+        PredicateRewriteVisitor::Data data(context, table_predicates, table_column, optimize_final);
 
-bool PredicateExpressionsOptimizer::isArrayJoinFunction(const ASTPtr & node)
-{
-    if (const auto * function = node->as<ASTFunction>())
-    {
-        if (function->name == "arrayJoin")
-            return true;
+        PredicateRewriteVisitor(data).visit(table_element);
+        return data.is_rewrite;
     }
 
-    for (auto & child : node->children)
-        if (isArrayJoinFunction(child))
-            return true;
-
     return false;
 }
 
-bool PredicateExpressionsOptimizer::optimizeExpression(const ASTPtr & outer_expression, ASTSelectQuery * subquery,
-                                                       ASTSelectQuery::Expression expr)
-{
-    ASTPtr subquery_expression = subquery->getExpression(expr, false);
-    subquery_expression = subquery_expression ? makeASTFunction(and_function_name, outer_expression, subquery_expression) : outer_expression;
-
-    subquery->setExpression(expr, std::move(subquery_expression));
-    return true;
-}
-
-PredicateExpressionsOptimizer::SubqueriesProjectionColumns PredicateExpressionsOptimizer::getAllSubqueryProjectionColumns()
-{
-    SubqueriesProjectionColumns projection_columns;
-
-    for (const auto & table_expression : getTableExpressions(*ast_select))
-        if (table_expression->subquery)
-            getSubqueryProjectionColumns(table_expression->subquery, projection_columns);
-
-    return projection_columns;
-}
-
-void PredicateExpressionsOptimizer::getSubqueryProjectionColumns(const ASTPtr & subquery, SubqueriesProjectionColumns & projection_columns)
+bool PredicateExpressionsOptimizer::tryMovePredicatesFromHavingToWhere(ASTSelectQuery & select_query)
 {
-    String qualified_name_prefix = subquery->tryGetAlias();
-    if (!qualified_name_prefix.empty())
-        qualified_name_prefix += '.';
-
-    const ASTPtr & subselect = subquery->children[0];
-
-    ASTs select_with_union_projections;
-    const auto * select_with_union_query = subselect->as<ASTSelectWithUnionQuery>();
+    ASTs where_predicates;
+    ASTs having_predicates;
 
-    for (auto & select : select_with_union_query->list_of_selects->children)
+    const auto & reduce_predicates = [&](const ASTs & predicates)
     {
-        std::vector<ProjectionWithAlias> subquery_projections;
-        auto select_projection_columns = getSelectQueryProjectionColumns(select);
-
-        if (!select_projection_columns.empty())
-        {
-            if (select_with_union_projections.empty())
-                select_with_union_projections = select_projection_columns;
+        ASTPtr res = predicates[0];
+        for (size_t index = 1; index < predicates.size(); ++index)
+            res = makeASTFunction("and", res, predicates[index]);
 
-            for (size_t i = 0; i < select_projection_columns.size(); i++)
-                subquery_projections.emplace_back(std::pair(select_projection_columns[i],
-                                                            qualified_name_prefix + select_with_union_projections[i]->getAliasOrColumnName()));
-
-            projection_columns.insert(std::pair(select->as<ASTSelectQuery>(), subquery_projections));
-        }
-    }
-}
+        return res;
+    };
 
-ASTs PredicateExpressionsOptimizer::getSelectQueryProjectionColumns(ASTPtr & ast)
-{
-    ASTs projection_columns;
-    auto * select_query = ast->as<ASTSelectQuery>();
-
-    /// first should normalize query tree.
-    std::unordered_map<String, ASTPtr> aliases;
-    std::vector<DatabaseAndTableWithAlias> tables = getDatabaseAndTables(*select_query, context.getCurrentDatabase());
-
-    /// TODO: get tables from evaluateAsterisk instead of tablesOnly() to extract asterisks in general way
-    std::vector<TableWithColumnNames> tables_with_columns = TranslateQualifiedNamesVisitor::Data::tablesOnly(tables);
-    TranslateQualifiedNamesVisitor::Data qn_visitor_data({}, std::move(tables_with_columns), false);
-    TranslateQualifiedNamesVisitor(qn_visitor_data).visit(ast);
-
-    QueryAliasesVisitor::Data query_aliases_data{aliases};
-    QueryAliasesVisitor(query_aliases_data).visit(ast);
-
-    MarkTableIdentifiersVisitor::Data mark_tables_data{aliases};
-    MarkTableIdentifiersVisitor(mark_tables_data).visit(ast);
-
-    QueryNormalizer::Data normalizer_data(aliases, settings);
-    QueryNormalizer(normalizer_data).visit(ast);
-
-    for (const auto & projection_column : select_query->select()->children)
+    for (const auto & moving_predicate: splitConjunctionPredicate({select_query.having()}))
     {
-        if (projection_column->as<ASTAsterisk>() || projection_column->as<ASTQualifiedAsterisk>() || projection_column->as<ASTColumnsMatcher>())
-        {
-            ASTs evaluated_columns = evaluateAsterisk(select_query, projection_column);
+        ExpressionInfoVisitor::Data expression_info{.context = context, .tables = {}};
+        ExpressionInfoVisitor(expression_info).visit(moving_predicate);
 
-            for (const auto & column : evaluated_columns)
-                projection_columns.emplace_back(column);
-
-            continue;
-        }
+        /// TODO: If there is no group by, where, and prewhere expression, we can push down the stateful function
+        if (expression_info.is_stateful_function)
+            return false;
 
-        projection_columns.emplace_back(projection_column);
+        if (expression_info.is_aggregate_function)
+            having_predicates.emplace_back(moving_predicate);
+        else
+            where_predicates.emplace_back(moving_predicate);
     }
-    return projection_columns;
-}
-
-ASTs PredicateExpressionsOptimizer::evaluateAsterisk(ASTSelectQuery * select_query, const ASTPtr & asterisk)
-{
-    /// SELECT *, SELECT dummy, SELECT 1 AS id
-    if (!select_query->tables() || select_query->tables()->children.empty())
-        return {};
-
-    std::vector<const ASTTableExpression *> tables_expression = getTableExpressions(*select_query);
 
-    if (const auto * qualified_asterisk = asterisk->as<ASTQualifiedAsterisk>())
+    if (having_predicates.empty())
+        select_query.setExpression(ASTSelectQuery::Expression::HAVING, {});
+    else
     {
-        if (qualified_asterisk->children.size() != 1)
-            throw Exception("Logical error: qualified asterisk must have exactly one child", ErrorCodes::LOGICAL_ERROR);
-
-        DatabaseAndTableWithAlias ident_db_and_name(qualified_asterisk->children[0]);
-
-        for (auto it = tables_expression.begin(); it != tables_expression.end();)
-        {
-            const ASTTableExpression * table_expression = *it;
-            DatabaseAndTableWithAlias database_and_table_with_alias(*table_expression, context.getCurrentDatabase());
-
-            if (ident_db_and_name.satisfies(database_and_table_with_alias, true))
-                ++it;
-            else
-                it = tables_expression.erase(it); /// It's not a required table
-        }
+        auto having_predicate = reduce_predicates(having_predicates);
+        select_query.setExpression(ASTSelectQuery::Expression::HAVING, std::move(having_predicate));
     }
 
-    ASTs projection_columns;
-    for (auto & table_expression : tables_expression)
+    if (!where_predicates.empty())
     {
-        if (table_expression->subquery)
-        {
-            const auto * subquery = table_expression->subquery->as<ASTSubquery>();
-            const auto * select_with_union_query = subquery->children[0]->as<ASTSelectWithUnionQuery>();
-            const auto subquery_projections = getSelectQueryProjectionColumns(select_with_union_query->list_of_selects->children[0]);
-            projection_columns.insert(projection_columns.end(), subquery_projections.begin(), subquery_projections.end());
-        }
-        else
-        {
-            StoragePtr storage;
-
-            if (table_expression->table_function)
-            {
-                auto query_context = const_cast<Context *>(&context.getQueryContext());
-                storage = query_context->executeTableFunction(table_expression->table_function);
-            }
-            else if (table_expression->database_and_table_name)
-            {
-                const auto * database_and_table_ast = table_expression->database_and_table_name->as<ASTIdentifier>();
-                DatabaseAndTableWithAlias database_and_table_name(*database_and_table_ast);
-                storage = context.getTable(database_and_table_name.database, database_and_table_name.table);
-            }
-            else
-                throw Exception("Logical error: unexpected table expression", ErrorCodes::LOGICAL_ERROR);
-
-            const auto block = storage->getSampleBlock();
-            if (const auto * asterisk_pattern = asterisk->as<ASTColumnsMatcher>())
-            {
-                for (size_t idx = 0; idx < block.columns(); ++idx)
-                {
-                    auto & col = block.getByPosition(idx);
-                    if (asterisk_pattern->isColumnMatching(col.name))
-                        projection_columns.emplace_back(std::make_shared<ASTIdentifier>(col.name));
-                }
-            }
-            else
-            {
-                for (size_t idx = 0; idx < block.columns(); ++idx)
-                    projection_columns.emplace_back(std::make_shared<ASTIdentifier>(block.getByPosition(idx).name));
-            }
-        }
+        auto moved_predicate = reduce_predicates(where_predicates);
+        moved_predicate = select_query.where() ? makeASTFunction("and", select_query.where(), moved_predicate) : moved_predicate;
+        select_query.setExpression(ASTSelectQuery::Expression::WHERE, std::move(moved_predicate));
     }
-    return projection_columns;
-}
-
-void PredicateExpressionsOptimizer::cleanExpressionAlias(ASTPtr & expression)
-{
-    const auto my_alias = expression->tryGetAlias();
-    if (!my_alias.empty())
-        expression->setAlias("");
 
-    for (auto & child : expression->children)
-        cleanExpressionAlias(child);
+    return true;
 }
 
 }
diff --git a/dbms/src/Interpreters/PredicateExpressionsOptimizer.h b/dbms/src/Interpreters/PredicateExpressionsOptimizer.h
index ca2c8b8766d4..da6b98987a64 100644
--- a/dbms/src/Interpreters/PredicateExpressionsOptimizer.h
+++ b/dbms/src/Interpreters/PredicateExpressionsOptimizer.h
@@ -1,110 +1,53 @@
 #pragma once
 
-#include "DatabaseAndTableWithAlias.h"
 #include <Parsers/ASTSelectQuery.h>
-#include <map>
+#include <Interpreters/DatabaseAndTableWithAlias.h>
 
 namespace DB
 {
 
-class ASTIdentifier;
-class ASTSubquery;
 class Context;
+struct Settings;
 
-/** This class provides functions for Push-Down predicate expressions
- *
- *  The Example:
- *      - Query before optimization :
- *          SELECT id_1, name_1 FROM (SELECT id_1, name_1 FROM table_a UNION ALL SELECT id_2, name_2 FROM table_b)
- *              WHERE id_1 = 1
- *      - Query after optimization :
- *          SELECT id_1, name_1 FROM (SELECT id_1, name_1 FROM table_a WHERE id_1 = 1 UNION ALL SELECT id_2, name_2 FROM table_b WHERE id_2 = 1)
- *              WHERE id_1 = 1
+/** Predicate optimization based on rewriting ast rules
  *  For more details : https://github.com/ClickHouse/ClickHouse/pull/2015#issuecomment-374283452
+ *  The optimizer does two different optimizations
+ *      - Move predicates from having to where
+ *      - Push the predicate down from the current query to the having of the subquery
  */
 class PredicateExpressionsOptimizer
 {
-    using ProjectionWithAlias = std::pair<ASTPtr, String>;
-    using SubqueriesProjectionColumns = std::map<ASTSelectQuery *, std::vector<ProjectionWithAlias>>;
-    using IdentifierWithQualifier = std::pair<ASTIdentifier *, String>;
+public:
+    PredicateExpressionsOptimizer(const Context & context_, const TablesWithColumnNames & tables_with_columns_, const Settings & settings_);
+
+    bool optimize(ASTSelectQuery & select_query);
 
+private:
     /// Extracts settings, mostly to show which are used and which are not.
     struct ExtractedSettings
     {
-        /// QueryNormalizer settings
-        const UInt64 max_ast_depth;
-        const UInt64 max_expanded_ast_elements;
-        const String count_distinct_implementation;
-
-        /// for PredicateExpressionsOptimizer
         const bool enable_optimize_predicate_expression;
         const bool enable_optimize_predicate_expression_to_final_subquery;
-        const bool join_use_nulls;
 
         template<typename T>
         ExtractedSettings(const T & settings_)
-        :   max_ast_depth(settings_.max_ast_depth),
-            max_expanded_ast_elements(settings_.max_expanded_ast_elements),
-            count_distinct_implementation(settings_.count_distinct_implementation),
-            enable_optimize_predicate_expression(settings_.enable_optimize_predicate_expression),
-            enable_optimize_predicate_expression_to_final_subquery(settings_.enable_optimize_predicate_expression_to_final_subquery),
-            join_use_nulls(settings_.join_use_nulls)
+            :   enable_optimize_predicate_expression(settings_.enable_optimize_predicate_expression),
+                enable_optimize_predicate_expression_to_final_subquery(settings_.enable_optimize_predicate_expression_to_final_subquery)
         {}
     };
 
-public:
-    PredicateExpressionsOptimizer(ASTSelectQuery * ast_select_, ExtractedSettings && settings_, const Context & context_);
-
-    bool optimize();
-
-private:
-    ASTSelectQuery * ast_select;
-    const ExtractedSettings settings;
     const Context & context;
+    const std::vector<TableWithColumnNames> & tables_with_columns;
 
-    enum OptimizeKind
-    {
-        NONE,
-        PUSH_TO_PREWHERE,
-        PUSH_TO_WHERE,
-        PUSH_TO_HAVING,
-    };
-
-    bool isArrayJoinFunction(const ASTPtr & node);
-
-    std::vector<ASTPtr> splitConjunctionPredicate(const ASTPtr & predicate_expression);
-
-    std::vector<IdentifierWithQualifier> getDependenciesAndQualifiers(ASTPtr & expression,
-                                                                      std::vector<TableWithColumnNames> & tables_with_aliases);
-
-    bool optimizeExpression(const ASTPtr & outer_expression, ASTSelectQuery * subquery, ASTSelectQuery::Expression expr);
-
-    bool optimizeImpl(const ASTPtr & outer_expression, const SubqueriesProjectionColumns & subqueries_projection_columns, OptimizeKind optimize_kind);
-
-    bool allowPushDown(
-        const ASTSelectQuery * subquery,
-        const ASTPtr & outer_predicate,
-        const std::vector<ProjectionWithAlias> & subquery_projection_columns,
-        const std::vector<IdentifierWithQualifier> & outer_predicate_dependencies,
-        OptimizeKind & optimize_kind);
-
-    bool checkDependencies(
-        const std::vector<ProjectionWithAlias> & projection_columns,
-        const std::vector<IdentifierWithQualifier> & dependencies,
-        OptimizeKind & optimize_kind);
-
-    void setNewAliasesForInnerPredicate(const std::vector<ProjectionWithAlias> & projection_columns,
-                                        const std::vector<IdentifierWithQualifier> & inner_predicate_dependencies);
-
-    SubqueriesProjectionColumns getAllSubqueryProjectionColumns();
+    const ExtractedSettings settings;
 
-    void getSubqueryProjectionColumns(const ASTPtr & subquery, SubqueriesProjectionColumns & all_subquery_projection_columns);
+    std::vector<ASTs> extractTablesPredicates(const ASTPtr & where, const ASTPtr & prewhere);
 
-    ASTs getSelectQueryProjectionColumns(ASTPtr & ast);
+    bool tryRewritePredicatesToTables(ASTs & tables_element, const std::vector<ASTs> & tables_predicates);
 
-    ASTs evaluateAsterisk(ASTSelectQuery * select_query, const ASTPtr & asterisk);
+    bool tryRewritePredicatesToTable(ASTPtr & table_element, const ASTs & table_predicates, const Names & table_column) const;
 
-    void cleanExpressionAlias(ASTPtr & expression);
+    bool tryMovePredicatesFromHavingToWhere(ASTSelectQuery & select_query);
 };
 
 }
diff --git a/dbms/src/Interpreters/PredicateRewriteVisitor.cpp b/dbms/src/Interpreters/PredicateRewriteVisitor.cpp
new file mode 100644
index 000000000000..6bd16ddc0668
--- /dev/null
+++ b/dbms/src/Interpreters/PredicateRewriteVisitor.cpp
@@ -0,0 +1,119 @@
+#include <Interpreters/PredicateRewriteVisitor.h>
+
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTAsterisk.h>
+#include <Parsers/ASTSubquery.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTColumnsMatcher.h>
+#include <Parsers/ASTQualifiedAsterisk.h>
+#include <Interpreters/IdentifierSemantic.h>
+#include <Interpreters/getTableExpressions.h>
+#include <Interpreters/InterpreterSelectQuery.h>
+#include <Interpreters/ExtractExpressionInfoVisitor.h>
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+
+
+namespace DB
+{
+
+PredicateRewriteVisitorData::PredicateRewriteVisitorData(
+    const Context & context_, const ASTs & predicates_, const Names & column_names_, bool optimize_final_)
+    : context(context_), predicates(predicates_), column_names(column_names_), optimize_final(optimize_final_)
+{
+}
+
+void PredicateRewriteVisitorData::visit(ASTSelectWithUnionQuery & union_select_query, ASTPtr &)
+{
+    auto & internal_select_list = union_select_query.list_of_selects->children;
+
+    if (internal_select_list.size() > 0)
+        visitFirstInternalSelect(*internal_select_list[0]->as<ASTSelectQuery>(), internal_select_list[0]);
+
+    for (size_t index = 1; index < internal_select_list.size(); ++index)
+        visitOtherInternalSelect(*internal_select_list[index]->as<ASTSelectQuery>(), internal_select_list[index]);
+}
+
+void PredicateRewriteVisitorData::visitFirstInternalSelect(ASTSelectQuery & select_query, ASTPtr &)
+{
+    is_rewrite |= rewriteSubquery(select_query, column_names, column_names);
+}
+
+void PredicateRewriteVisitorData::visitOtherInternalSelect(ASTSelectQuery & select_query, ASTPtr &)
+{
+    /// For non first select, its alias has no more significance, so we can set a temporary alias for them
+    ASTPtr temp_internal_select = select_query.clone();
+    ASTSelectQuery * temp_select_query = temp_internal_select->as<ASTSelectQuery>();
+
+    size_t alias_index = 0;
+    for (auto & ref_select : temp_select_query->refSelect()->children)
+    {
+        if (!ref_select->as<ASTAsterisk>() && !ref_select->as<ASTQualifiedAsterisk>() && !ref_select->as<ASTColumnsMatcher>() &&
+            !ref_select->as<ASTIdentifier>())
+        {
+            if (const auto & alias = ref_select->tryGetAlias(); alias.empty())
+                ref_select->setAlias("--predicate_optimizer_" + toString(alias_index++));
+        }
+    }
+
+    const Names & internal_columns = InterpreterSelectQuery(
+        temp_internal_select, context, SelectQueryOptions().analyze()).getSampleBlock().getNames();
+
+    if (rewriteSubquery(*temp_select_query, column_names, internal_columns))
+    {
+        is_rewrite |= true;
+        select_query.setExpression(ASTSelectQuery::Expression::SELECT, std::move(temp_select_query->refSelect()));
+        select_query.setExpression(ASTSelectQuery::Expression::HAVING, std::move(temp_select_query->refHaving()));
+    }
+}
+
+static void cleanAliasAndCollectIdentifiers(ASTPtr & predicate, std::vector<ASTIdentifier *> & identifiers)
+{
+    /// Skip WHERE x in (SELECT ...)
+    if (!predicate->as<ASTSubquery>())
+    {
+        for (auto & children : predicate->children)
+            cleanAliasAndCollectIdentifiers(children, identifiers);
+    }
+
+    if (const auto alias = predicate->tryGetAlias(); !alias.empty())
+        predicate->setAlias("");
+
+    if (ASTIdentifier * identifier = predicate->as<ASTIdentifier>())
+        identifiers.emplace_back(identifier);
+}
+
+bool PredicateRewriteVisitorData::rewriteSubquery(ASTSelectQuery & subquery, const Names & outer_columns, const Names & inner_columns)
+{
+    if ((!optimize_final && subquery.final())
+        || subquery.with() || subquery.withFill()
+        || subquery.limitBy() || subquery.limitLength()
+        || hasStatefulFunction(subquery.select(), context))
+        return false;
+
+    for (const auto & predicate : predicates)
+    {
+        std::vector<ASTIdentifier *> identifiers;
+        ASTPtr optimize_predicate = predicate->clone();
+        cleanAliasAndCollectIdentifiers(optimize_predicate, identifiers);
+
+        for (size_t index = 0; index < identifiers.size(); ++index)
+        {
+            const auto & column_name = identifiers[index]->shortName();
+            const auto & outer_column_iterator = std::find(outer_columns.begin(), outer_columns.end(), column_name);
+
+            /// For lambda functions, we can't always find them in the list of columns
+            /// For example: SELECT * FROM system.one WHERE arrayMap(x -> x, [dummy]) = [0]
+            if (outer_column_iterator != outer_columns.end())
+                identifiers[index]->setShortName(inner_columns[outer_column_iterator - outer_columns.begin()]);
+        }
+
+        /// We only need to push all the predicates to subquery having
+        /// The subquery optimizer will move the appropriate predicates from having to where
+        subquery.setExpression(ASTSelectQuery::Expression::HAVING,
+            subquery.having() ? makeASTFunction("and", optimize_predicate, subquery.having()) : optimize_predicate);
+    }
+
+    return true;
+}
+
+}
diff --git a/dbms/src/Interpreters/PredicateRewriteVisitor.h b/dbms/src/Interpreters/PredicateRewriteVisitor.h
new file mode 100644
index 000000000000..e07df922c155
--- /dev/null
+++ b/dbms/src/Interpreters/PredicateRewriteVisitor.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include <Parsers/IAST.h>
+#include <Parsers/ASTSelectQuery.h>
+#include <Parsers/ASTSelectWithUnionQuery.h>
+#include <Interpreters/InDepthNodeVisitor.h>
+
+namespace DB
+{
+
+class PredicateRewriteVisitorData
+{
+public:
+    bool is_rewrite = false;
+    using TypeToVisit = ASTSelectWithUnionQuery;
+
+    void visit(ASTSelectWithUnionQuery & union_select_query, ASTPtr &);
+
+    PredicateRewriteVisitorData(const Context & context_, const ASTs & predicates_, const Names & column_names_, bool optimize_final_);
+
+private:
+    const Context & context;
+    const ASTs & predicates;
+    const Names & column_names;
+    bool optimize_final;
+
+    void visitFirstInternalSelect(ASTSelectQuery & select_query, ASTPtr &);
+
+    void visitOtherInternalSelect(ASTSelectQuery & select_query, ASTPtr &);
+
+    bool rewriteSubquery(ASTSelectQuery & subquery, const Names & outer_columns, const Names & inner_columns);
+};
+
+using PredicateRewriteMatcher = OneTypeMatcher<PredicateRewriteVisitorData, false>;
+using PredicateRewriteVisitor = InDepthNodeVisitor<PredicateRewriteMatcher, true>;
+}
diff --git a/dbms/src/Interpreters/SyntaxAnalyzer.cpp b/dbms/src/Interpreters/SyntaxAnalyzer.cpp
index 85135c71c6ff..3680947c8f1a 100644
--- a/dbms/src/Interpreters/SyntaxAnalyzer.cpp
+++ b/dbms/src/Interpreters/SyntaxAnalyzer.cpp
@@ -920,6 +920,9 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(
 
     if (select_query)
     {
+        /// Push the predicate expression down to the subqueries.
+        result.rewrite_subqueries = PredicateExpressionsOptimizer(context, tables_with_columns, settings).optimize(*select_query);
+
         /// GROUP BY injective function elimination.
         optimizeGroupBy(select_query, source_columns_set, context);
 
@@ -935,9 +938,6 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(
         /// array_join_alias_to_name, array_join_result_to_source.
         getArrayJoinedColumns(query, result, select_query, result.source_columns, source_columns_set);
 
-        /// Push the predicate expression down to the subqueries.
-        result.rewrite_subqueries = PredicateExpressionsOptimizer(select_query, settings, context).optimize();
-
         setJoinStrictness(*select_query, settings.join_default_strictness, settings.any_join_distinct_right_table_keys,
                           result.analyzed_join->table_join);
         collectJoinedColumns(*result.analyzed_join, *select_query, tables_with_columns, result.aliases);
diff --git a/dbms/src/Storages/StorageView.cpp b/dbms/src/Storages/StorageView.cpp
index 824856dfc4e3..5c8543bbb337 100644
--- a/dbms/src/Storages/StorageView.cpp
+++ b/dbms/src/Storages/StorageView.cpp
@@ -1,6 +1,7 @@
 #include <Interpreters/InterpreterSelectQuery.h>
 #include <Interpreters/InterpreterSelectWithUnionQuery.h>
 #include <Interpreters/PredicateExpressionsOptimizer.h>
+#include <Interpreters/getTableExpressions.h>
 
 #include <Parsers/ASTCreateQuery.h>
 #include <Parsers/ASTSubquery.h>
@@ -23,6 +24,7 @@ namespace ErrorCodes
 {
     extern const int INCORRECT_QUERY;
     extern const int LOGICAL_ERROR;
+    extern const int ALIAS_REQUIRED;
 }
 
 
@@ -62,8 +64,23 @@ BlockInputStreams StorageView::read(
 
         replaceTableNameWithSubquery(new_outer_select, new_inner_query);
 
-        if (PredicateExpressionsOptimizer(new_outer_select, context.getSettings(), context).optimize())
-            current_inner_query = new_inner_query;
+        /// TODO: remove getTableExpressions and getTablesWithColumns
+        {
+            const auto & table_expressions = getTableExpressions(*new_outer_select);
+            const auto & tables_with_columns = getDatabaseAndTablesWithColumnNames(table_expressions, context);
+
+            auto & settings = context.getSettingsRef();
+            if (settings.joined_subquery_requires_alias && tables_with_columns.size() > 1)
+            {
+                for (auto & pr : tables_with_columns)
+                    if (pr.table.table.empty() && pr.table.alias.empty())
+                        throw Exception("Not unique subquery in FROM requires an alias (or joined_subquery_requires_alias=0 to disable restriction).",
+                            ErrorCodes::ALIAS_REQUIRED);
+            }
+
+            if (PredicateExpressionsOptimizer(context, tables_with_columns, context.getSettings()).optimize(*new_outer_select))
+                current_inner_query = new_inner_query;
+        }
     }
 
     QueryPipeline pipeline;
