{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50559,
  "instance_id": "ClickHouse__ClickHouse-50559",
  "issue_numbers": [
    "49290"
  ],
  "base_commit": "9f45513acf61d05e3cd9274236ce38b26fafc304",
  "patch": "diff --git a/docs/en/sql-reference/table-functions/file.md b/docs/en/sql-reference/table-functions/file.md\nindex c78ffc1d61c1..00917414e0cd 100644\n--- a/docs/en/sql-reference/table-functions/file.md\n+++ b/docs/en/sql-reference/table-functions/file.md\n@@ -134,7 +134,7 @@ Multiple path components can have globs. For being processed file must exist and\n \n - `*` \u2014 Substitutes any number of any characters except `/` including empty string.\n - `?` \u2014 Substitutes any single character.\n-- `{some_string,another_string,yet_another_one}` \u2014 Substitutes any of strings `'some_string', 'another_string', 'yet_another_one'`.\n+- `{some_string,another_string,yet_another_one}` \u2014 Substitutes any of strings `'some_string', 'another_string', 'yet_another_one'`, including `/`.\n - `{N..M}` \u2014 Substitutes any number in range from N to M including both borders.\n - `**` - Fetches all files inside the folder recursively.\n \ndiff --git a/docs/ru/sql-reference/table-functions/file.md b/docs/ru/sql-reference/table-functions/file.md\nindex 0983c51d954c..83ef115aacd0 100644\n--- a/docs/ru/sql-reference/table-functions/file.md\n+++ b/docs/ru/sql-reference/table-functions/file.md\n@@ -79,7 +79,7 @@ SELECT * FROM file('test.csv', 'CSV', 'column1 UInt32, column2 UInt32, column3 U\n \n -   `*` \u2014 \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442 \u043b\u044e\u0431\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043b\u044e\u0431\u044b\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u043a\u0440\u043e\u043c\u0435 `/`, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432.\n -   `?` \u2014 \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442 \u0440\u043e\u0432\u043d\u043e \u043e\u0434\u0438\u043d \u043b\u044e\u0431\u043e\u0439 \u0441\u0438\u043c\u0432\u043e\u043b.\n--   `{some_string,another_string,yet_another_one}` \u2014 \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442 \u043b\u044e\u0431\u0443\u044e \u0438\u0437 \u0441\u0442\u0440\u043e\u043a `'some_string', 'another_string', 'yet_another_one'`.\n+-   `{some_string,another_string,yet_another_one}` \u2014 \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442 \u043b\u044e\u0431\u0443\u044e \u0438\u0437 \u0441\u0442\u0440\u043e\u043a `'some_string', 'another_string', 'yet_another_one'`, \u043f\u0440\u0438\u0447\u0451\u043c \u0441\u0442\u0440\u043e\u043a\u0430 \u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c `/`.\n -   `{N..M}` \u2014 \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442 \u043b\u044e\u0431\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0432 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0435 \u043e\u0442 `N` \u0434\u043e `M` \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e (\u043c\u043e\u0436\u0435\u0442 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0432\u0435\u0434\u0443\u0449\u0438\u0435 \u043d\u0443\u043b\u0438).\n \n \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u0441 `{}` \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u0430 \u0442\u0430\u0431\u043b\u0438\u0447\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 [remote](remote.md).\ndiff --git a/src/Storages/HDFS/StorageHDFS.cpp b/src/Storages/HDFS/StorageHDFS.cpp\nindex a41c65cdb2e2..3d7e2b05f5a9 100644\n--- a/src/Storages/HDFS/StorageHDFS.cpp\n+++ b/src/Storages/HDFS/StorageHDFS.cpp\n@@ -64,23 +64,131 @@ namespace ErrorCodes\n }\n namespace\n {\n+    /// Forward-declared to use in LSWithFoldedRegexpMatching w/o circular dependency.\n+    std::vector<StorageHDFS::PathWithInfo> LSWithRegexpMatching(const String & path_for_ls,\n+                                                                const HDFSFSPtr & fs,\n+                                                                const String & for_match);\n+\n+    /*\n+     * When `{...}` has any `/`s, it must be processed in a different way:\n+     * Basically, a path with globs is processed by LSWithRegexpMatching. In case it detects multi-dir glob {.../..., .../...},\n+     * LSWithFoldedRegexpMatching is in charge from now on.\n+     * It works a bit different: it still recursively goes through subdirectories, but does not match every directory to glob.\n+     * Instead, it goes many levels down (until the approximate max_depth is reached) and compares this multi-dir path to a glob.\n+     * StorageFile.cpp has the same logic.\n+    */\n+    std::vector<StorageHDFS::PathWithInfo> LSWithFoldedRegexpMatching(const String & path_for_ls,\n+        const HDFSFSPtr & fs,\n+        const String & processed_suffix,\n+        const String & suffix_with_globs,\n+        re2::RE2 & matcher,\n+        const size_t max_depth,\n+        const size_t next_slash_after_glob_pos)\n+    {\n+        /// We don't need to go all the way in every directory if max_depth is reached\n+        /// as it is upper limit of depth by simply counting `/`s in curly braces\n+        if (!max_depth)\n+            return {};\n+\n+        HDFSFileInfo ls;\n+        ls.file_info = hdfsListDirectory(fs.get(), path_for_ls.data(), &ls.length);\n+        if (ls.file_info == nullptr && errno != ENOENT) // NOLINT\n+        {\n+            // ignore file not found exception, keep throw other exception, libhdfs3 doesn't have function to get exception type, so use errno.\n+            throw Exception(\n+                ErrorCodes::ACCESS_DENIED, \"Cannot list directory {}: {}\", path_for_ls, String(hdfsGetLastError()));\n+        }\n+\n+        std::vector<StorageHDFS::PathWithInfo> result;\n+\n+        if (!ls.file_info && ls.length > 0)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"file_info shouldn't be null\");\n+\n+        for (int i = 0; i < ls.length; ++i)\n+        {\n+            const String full_path = String(ls.file_info[i].mName);\n+            const size_t last_slash = full_path.rfind('/');\n+            const String dir_or_file_name = full_path.substr(last_slash);\n+            const bool is_directory = ls.file_info[i].mKind == 'D';\n+\n+            if (re2::RE2::FullMatch(processed_suffix + dir_or_file_name, matcher))\n+            {\n+                if (next_slash_after_glob_pos == std::string::npos)\n+                {\n+                    result.emplace_back(\n+                        String(ls.file_info[i].mName),\n+                        StorageHDFS::PathInfo{ls.file_info[i].mLastMod, static_cast<size_t>(ls.file_info[i].mSize)});\n+                }\n+                else\n+                {\n+                    std::vector<StorageHDFS::PathWithInfo> result_part = LSWithRegexpMatching(\n+                        fs::path(full_path) / \"\" , fs, suffix_with_globs.substr(next_slash_after_glob_pos));\n+                    std::move(result_part.begin(), result_part.end(), std::back_inserter(result));\n+                }\n+            }\n+            else if (is_directory)\n+            {\n+                std::vector<StorageHDFS::PathWithInfo> result_part = LSWithFoldedRegexpMatching(\n+                    fs::path(full_path), fs, processed_suffix + dir_or_file_name,\n+                    suffix_with_globs, matcher, max_depth - 1, next_slash_after_glob_pos);\n+                std::move(result_part.begin(), result_part.end(), std::back_inserter(result));\n+            }\n+        }\n+        return result;\n+    }\n+\n     /* Recursive directory listing with matched paths as a result.\n      * Have the same method in StorageFile.\n      */\n-    std::vector<StorageHDFS::PathWithInfo> LSWithRegexpMatching(const String & path_for_ls, const HDFSFSPtr & fs, const String & for_match)\n+    std::vector<StorageHDFS::PathWithInfo> LSWithRegexpMatching(\n+        const String & path_for_ls,\n+        const HDFSFSPtr & fs,\n+        const String & for_match)\n     {\n-        const size_t first_glob = for_match.find_first_of(\"*?{\");\n+        const size_t first_glob_pos = for_match.find_first_of(\"*?{\");\n+        const bool has_glob = first_glob_pos != std::string::npos;\n \n-        const size_t end_of_path_without_globs = for_match.substr(0, first_glob).rfind('/');\n+        const size_t end_of_path_without_globs = for_match.substr(0, first_glob_pos).rfind('/');\n         const String suffix_with_globs = for_match.substr(end_of_path_without_globs);   /// begin with '/'\n         const String prefix_without_globs = path_for_ls + for_match.substr(1, end_of_path_without_globs); /// ends with '/'\n \n-        const size_t next_slash = suffix_with_globs.find('/', 1);\n-        re2::RE2 matcher(makeRegexpPatternFromGlobs(suffix_with_globs.substr(0, next_slash)));\n+        size_t slashes_in_glob = 0;\n+        const size_t next_slash_after_glob_pos = [&]()\n+        {\n+            if (!has_glob)\n+                return suffix_with_globs.find('/', 1);\n+\n+            size_t in_curly = 0;\n+            for (std::string::const_iterator it = ++suffix_with_globs.begin(); it != suffix_with_globs.end(); it++)\n+            {\n+                if (*it == '{')\n+                    ++in_curly;\n+                else if (*it == '/')\n+                {\n+                    if (in_curly)\n+                        ++slashes_in_glob;\n+                    else\n+                        return size_t(std::distance(suffix_with_globs.begin(), it));\n+                }\n+                else if (*it == '}')\n+                    --in_curly;\n+            }\n+            return std::string::npos;\n+        }();\n+\n+        const std::string current_glob = suffix_with_globs.substr(0, next_slash_after_glob_pos);\n+\n+        re2::RE2 matcher(makeRegexpPatternFromGlobs(current_glob));\n         if (!matcher.ok())\n             throw Exception(ErrorCodes::CANNOT_COMPILE_REGEXP,\n                 \"Cannot compile regex from glob ({}): {}\", for_match, matcher.error());\n \n+        if (slashes_in_glob)\n+        {\n+            return LSWithFoldedRegexpMatching(fs::path(prefix_without_globs), fs, \"\", suffix_with_globs,\n+                                              matcher, slashes_in_glob, next_slash_after_glob_pos);\n+        }\n+\n         HDFSFileInfo ls;\n         ls.file_info = hdfsListDirectory(fs.get(), prefix_without_globs.data(), &ls.length);\n         if (ls.file_info == nullptr && errno != ENOENT) // NOLINT\n@@ -97,7 +205,7 @@ namespace\n             const String full_path = String(ls.file_info[i].mName);\n             const size_t last_slash = full_path.rfind('/');\n             const String file_name = full_path.substr(last_slash);\n-            const bool looking_for_directory = next_slash != std::string::npos;\n+            const bool looking_for_directory = next_slash_after_glob_pos != std::string::npos;\n             const bool is_directory = ls.file_info[i].mKind == 'D';\n             /// Condition with type of current file_info means what kind of path is it in current iteration of ls\n             if (!is_directory && !looking_for_directory)\n@@ -111,7 +219,7 @@ namespace\n             {\n                 if (re2::RE2::FullMatch(file_name, matcher))\n                 {\n-                    std::vector<StorageHDFS::PathWithInfo> result_part = LSWithRegexpMatching(fs::path(full_path) / \"\", fs, suffix_with_globs.substr(next_slash));\n+                    std::vector<StorageHDFS::PathWithInfo> result_part = LSWithRegexpMatching(fs::path(full_path) / \"\", fs, suffix_with_globs.substr(next_slash_after_glob_pos));\n                     /// Recursion depth is limited by pattern. '*' works only for depth = 1, for depth = 2 pattern path is '*/*'. So we do not need additional check.\n                     std::move(result_part.begin(), result_part.end(), std::back_inserter(result));\n                 }\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 5cb7575c3aea..cbd32460f7e0 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -93,6 +93,65 @@ namespace ErrorCodes\n namespace\n {\n \n+/// Forward-declare to use in listFilesWithFoldedRegexpMatchingImpl()\n+void listFilesWithRegexpMatchingImpl(\n+    const std::string & path_for_ls,\n+    const std::string & for_match,\n+    size_t & total_bytes_to_read,\n+    std::vector<std::string> & result,\n+    bool recursive = false);\n+\n+/*\n+ * When `{...}` has any `/`s, it must be processed in a different way:\n+ * Basically, a path with globs is processed by listFilesWithRegexpMatchingImpl. In case it detects multi-dir glob {.../..., .../...},\n+ * listFilesWithFoldedRegexpMatchingImpl is in charge from now on.\n+ * It works a bit different: it still recursively goes through subdirectories, but does not match every directory to glob.\n+ * Instead, it goes many levels down (until the approximate max_depth is reached) and compares this multi-dir path to a glob.\n+ * StorageHDFS.cpp has the same logic.\n+*/\n+void listFilesWithFoldedRegexpMatchingImpl(const std::string & path_for_ls,\n+                                           const std::string & processed_suffix,\n+                                           const std::string & suffix_with_globs,\n+                                           re2::RE2 & matcher,\n+                                           size_t & total_bytes_to_read,\n+                                           const size_t max_depth,\n+                                           const size_t next_slash_after_glob_pos,\n+                                           std::vector<std::string> & result)\n+{\n+    if (!max_depth)\n+        return;\n+\n+    const fs::directory_iterator end;\n+    for (fs::directory_iterator it(path_for_ls); it != end; ++it)\n+    {\n+        const std::string full_path = it->path().string();\n+        const size_t last_slash = full_path.rfind('/');\n+        const String dir_or_file_name = full_path.substr(last_slash);\n+\n+        if (re2::RE2::FullMatch(processed_suffix + dir_or_file_name, matcher))\n+        {\n+            if (next_slash_after_glob_pos == std::string::npos)\n+            {\n+                total_bytes_to_read += it->file_size();\n+                result.push_back(it->path().string());\n+            }\n+            else\n+            {\n+                listFilesWithRegexpMatchingImpl(fs::path(full_path) / \"\" ,\n+                                                suffix_with_globs.substr(next_slash_after_glob_pos),\n+                                                total_bytes_to_read, result);\n+            }\n+        }\n+        else if (it->is_directory())\n+        {\n+            listFilesWithFoldedRegexpMatchingImpl(fs::path(full_path), processed_suffix + dir_or_file_name,\n+                                                  suffix_with_globs, matcher, total_bytes_to_read,\n+                                                  max_depth - 1, next_slash_after_glob_pos, result);\n+        }\n+\n+    }\n+}\n+\n /* Recursive directory listing with matched paths as a result.\n  * Have the same method in StorageHDFS.\n  */\n@@ -101,15 +160,42 @@ void listFilesWithRegexpMatchingImpl(\n     const std::string & for_match,\n     size_t & total_bytes_to_read,\n     std::vector<std::string> & result,\n-    bool recursive = false)\n+    bool recursive)\n {\n-    const size_t first_glob = for_match.find_first_of(\"*?{\");\n+    const size_t first_glob_pos = for_match.find_first_of(\"*?{\");\n+    const bool has_glob = first_glob_pos != std::string::npos;\n \n-    const size_t end_of_path_without_globs = for_match.substr(0, first_glob).rfind('/');\n+    const size_t end_of_path_without_globs = for_match.substr(0, first_glob_pos).rfind('/');\n     const std::string suffix_with_globs = for_match.substr(end_of_path_without_globs);   /// begin with '/'\n \n-    const size_t next_slash = suffix_with_globs.find('/', 1);\n-    const std::string current_glob = suffix_with_globs.substr(0, next_slash);\n+    /// slashes_in_glob counter is a upper-bound estimate of recursion depth\n+    /// needed to process complex cases when `/` is included into glob, e.g. /pa{th1/a,th2/b}.csv\n+    size_t slashes_in_glob = 0;\n+    const size_t next_slash_after_glob_pos = [&]()\n+    {\n+        if (!has_glob)\n+            return suffix_with_globs.find('/', 1);\n+\n+        size_t in_curly = 0;\n+        for (std::string::const_iterator it = ++suffix_with_globs.begin(); it != suffix_with_globs.end(); it++)\n+        {\n+            if (*it == '{')\n+                ++in_curly;\n+            else if (*it == '/')\n+            {\n+                if (in_curly)\n+                    ++slashes_in_glob;\n+                else\n+                    return size_t(std::distance(suffix_with_globs.begin(), it));\n+            }\n+            else if (*it == '}')\n+                --in_curly;\n+        }\n+        return std::string::npos;\n+    }();\n+\n+    const std::string current_glob = suffix_with_globs.substr(0, next_slash_after_glob_pos);\n+\n     auto regexp = makeRegexpPatternFromGlobs(current_glob);\n \n     re2::RE2 matcher(regexp);\n@@ -126,13 +212,22 @@ void listFilesWithRegexpMatchingImpl(\n     if (!fs::exists(prefix_without_globs))\n         return;\n \n+    const bool looking_for_directory = next_slash_after_glob_pos != std::string::npos;\n+\n+    if (slashes_in_glob)\n+    {\n+        listFilesWithFoldedRegexpMatchingImpl(fs::path(prefix_without_globs), \"\", suffix_with_globs,\n+                                              matcher, total_bytes_to_read, slashes_in_glob,\n+                                              next_slash_after_glob_pos, result);\n+        return;\n+    }\n+\n     const fs::directory_iterator end;\n     for (fs::directory_iterator it(prefix_without_globs); it != end; ++it)\n     {\n         const std::string full_path = it->path().string();\n         const size_t last_slash = full_path.rfind('/');\n         const String file_name = full_path.substr(last_slash);\n-        const bool looking_for_directory = next_slash != std::string::npos;\n \n         /// Condition is_directory means what kind of path is it in current iteration of ls\n         if (!it->is_directory() && !looking_for_directory)\n@@ -148,14 +243,12 @@ void listFilesWithRegexpMatchingImpl(\n             if (recursive)\n             {\n                 listFilesWithRegexpMatchingImpl(fs::path(full_path).append(it->path().string()) / \"\" ,\n-                                                looking_for_directory ? suffix_with_globs.substr(next_slash) : current_glob ,\n+                                                looking_for_directory ? suffix_with_globs.substr(next_slash_after_glob_pos) : current_glob ,\n                                                 total_bytes_to_read, result, recursive);\n             }\n             else if (looking_for_directory && re2::RE2::FullMatch(file_name, matcher))\n-            {\n                 /// Recursion depth is limited by pattern. '*' works only for depth = 1, for depth = 2 pattern path is '*/*'. So we do not need additional check.\n-                listFilesWithRegexpMatchingImpl(fs::path(full_path) / \"\", suffix_with_globs.substr(next_slash), total_bytes_to_read, result);\n-            }\n+                listFilesWithRegexpMatchingImpl(fs::path(full_path) / \"\", suffix_with_globs.substr(next_slash_after_glob_pos), total_bytes_to_read, result);\n         }\n     }\n }\n",
  "test_patch": "diff --git a/tests/integration/test_storage_hdfs/test.py b/tests/integration/test_storage_hdfs/test.py\nindex 5ac1d3bea6f1..8ff88791a3a1 100644\n--- a/tests/integration/test_storage_hdfs/test.py\n+++ b/tests/integration/test_storage_hdfs/test.py\n@@ -85,6 +85,32 @@ def test_read_write_storage_with_globs(started_cluster):\n         assert \"in readonly mode\" in str(ex)\n \n \n+def test_storage_with_multidirectory_glob(started_cluster):\n+    hdfs_api = started_cluster.hdfs_api\n+    for i in [\"1\", \"2\"]:\n+        hdfs_api.write_data(\n+            f\"/multiglob/p{i}/path{i}/postfix/data{i}\", f\"File{i}\\t{i}{i}\\n\"\n+        )\n+        assert (\n+            hdfs_api.read_data(f\"/multiglob/p{i}/path{i}/postfix/data{i}\")\n+            == f\"File{i}\\t{i}{i}\\n\"\n+        )\n+\n+    r = node1.query(\n+        \"SELECT * FROM hdfs('hdfs://hdfs1:9000/multiglob/{p1/path1,p2/path2}/postfix/data{1,2}', TSV)\"\n+    )\n+    assert (r == f\"File1\\t11\\nFile2\\t22\\n\") or (r == f\"File2\\t22\\nFile1\\t11\\n\")\n+\n+    try:\n+        node1.query(\n+            \"SELECT * FROM hdfs('hdfs://hdfs1:9000/multiglob/{p4/path1,p2/path3}/postfix/data{1,2}.nonexist', TSV)\"\n+        )\n+        assert False, \"Exception have to be thrown\"\n+    except Exception as ex:\n+        print(ex)\n+        assert \"no files\" in str(ex)\n+\n+\n def test_read_write_table(started_cluster):\n     hdfs_api = started_cluster.hdfs_api\n \ndiff --git a/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.reference b/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.reference\nnew file mode 100644\nindex 000000000000..e1b420ecf37e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.reference\n@@ -0,0 +1,4 @@\n+This is file data1\tdata1.csv\n+This is file data2\tdata2.csv\n+This is file data1\tdata1.csv\n+This is file data2\tdata2.csv\ndiff --git a/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.sql b/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.sql\nnew file mode 100644\nindex 000000000000..1d1259202204\n--- /dev/null\n+++ b/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.sql\n@@ -0,0 +1,12 @@\n+-- Tags: no-replicated-database, no-parallel\n+\n+SELECT *, _file FROM file('02771/dir{?/subdir?1/da,2/subdir2?/da}ta/non_existing.csv', CSV); -- {serverError CANNOT_EXTRACT_TABLE_STRUCTURE}\n+\n+INSERT INTO TABLE FUNCTION file('02771/dir1/subdir11/data1.csv', 'CSV', 's String') SELECT 'This is file data1' SETTINGS engine_file_truncate_on_insert=1;\n+INSERT INTO TABLE FUNCTION file('02771/dir2/subdir22/data2.csv', 'CSV', 's String') SELECT 'This is file data2' SETTINGS engine_file_truncate_on_insert=1;\n+\n+SELECT *, _file FROM file('02771/dir{?/subdir?1/da,2/subdir2?/da}ta1.csv', CSV);\n+SELECT *, _file FROM file('02771/dir{?/subdir?1/da,2/subdir2?/da}ta2.csv', CSV);\n+\n+SELECT *, _file FROM file('02771/dir?/{subdir?1/data1,subdir2?/data2}.csv', CSV) WHERE _file == 'data1.csv';\n+SELECT *, _file FROM file('02771/dir?/{subdir?1/data1,subdir2?/data2}.csv', CSV) WHERE _file == 'data2.csv';\n",
  "problem_statement": "file/(hdfs?) globs allow to have patterns across different directories\n**Use case**\r\n\r\nWe want to read only specific files in each directory, and do not have access to other files.\r\n\r\n**Describe the solution you'd like**\r\n\r\n```\r\nSELECT\r\n    *,\r\n    _path,\r\n    _file\r\nFROM file('{a/1,b/2}.csv', CSV)\r\n\r\n\r\n0 rows in set. Elapsed: 0.050 sec.\r\n\r\nReceived exception:\r\nCode: 636. DB::Exception: Cannot extract table structure from CSV format file, because there are no files with provided path. You must specify table structure manually. (CANNOT_EXTRACT_TABLE_STRUCTURE)\r\n\r\nSELECT\r\n    *,\r\n    _path,\r\n    _file\r\nFROM file('a/1.csv', CSV)\r\n\r\n\u250c\u2500c1\u2500\u252c\u2500c2\u2500\u252c\u2500_path\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500_file\u2500\u2510\r\n\u2502  1 \u2502  2 \u2502 /home/xxxxxxx/a/1.csv \u2502 1.csv \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT\r\n    *,\r\n    _path,\r\n    _file\r\nFROM file('b/2.csv', CSV)\r\n\r\n\u250c\u2500c1\u2500\u252c\u2500c2\u2500\u252c\u2500_path\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500_file\u2500\u2510\r\n\u2502  3 \u2502  4 \u2502 /home/xxxxxxx/b/2.csv \u2502 2.csv \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt's already working in such way for s3(because there is no real directories here, but still)\r\n\r\nSo you can write something like:\r\n\r\n```\r\nSELECT     *, _path, _file\r\nFROM s3('https://clickhouse-public-datasets.s3.amazonaws.com/my-test-bucket-768/{some/some_file_1,another/another_file_3}.csv',   NOSIGN, CSVWithNames);\r\n```\r\n\r\nRelated https://github.com/ClickHouse/ClickHouse/issues/16682\n",
  "hints_text": "",
  "created_at": "2023-06-05T01:27:32Z",
  "modified_files": [
    "docs/en/sql-reference/table-functions/file.md",
    "docs/ru/sql-reference/table-functions/file.md",
    "src/Storages/HDFS/StorageHDFS.cpp",
    "src/Storages/StorageFile.cpp"
  ],
  "modified_test_files": [
    "tests/integration/test_storage_hdfs/test.py",
    "b/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.reference",
    "b/tests/queries/0_stateless/02771_complex_globs_in_storage_file_path.sql"
  ]
}