{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51850,
  "instance_id": "ClickHouse__ClickHouse-51850",
  "issue_numbers": [
    "27622"
  ],
  "base_commit": "2cbe79b529e84166055d2af469fde9c28d1757c0",
  "patch": "diff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp\nindex d1bbd169513b..ee84e3138e81 100644\n--- a/src/Functions/array/arrayIntersect.cpp\n+++ b/src/Functions/array/arrayIntersect.cpp\n@@ -510,11 +510,12 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n         map.clear();\n \n         bool all_has_nullable = all_nullable;\n+        bool current_has_nullable = false;\n \n         for (size_t arg_num = 0; arg_num < args; ++arg_num)\n         {\n             const auto & arg = arrays.args[arg_num];\n-            bool current_has_nullable = false;\n+            current_has_nullable = false;\n \n             size_t off;\n             // const array has only one row\n@@ -549,44 +550,93 @@ ColumnPtr FunctionArrayIntersect::execute(const UnpackedArrays & arrays, Mutable\n                 }\n             }\n \n-            prev_off[arg_num] = off;\n-            if (arg.is_const)\n-                prev_off[arg_num] = 0;\n-\n+            // We update offsets for all the arrays except the first one. Offsets for the first array would be updated later.\n+            // It is needed to iterate the first array again so that the elements in the result would have fixed order.\n+            if (arg_num)\n+            {\n+                prev_off[arg_num] = off;\n+                if (arg.is_const)\n+                    prev_off[arg_num] = 0;\n+            }\n             if (!current_has_nullable)\n                 all_has_nullable = false;\n         }\n \n-        if (all_has_nullable)\n-        {\n-            ++result_offset;\n-            result_data.insertDefault();\n-            null_map.push_back(1);\n-        }\n+        // We have NULL in output only once if it should be there\n+        bool null_added = false;\n+        const auto & arg = arrays.args[0];\n+        size_t off;\n+        // const array has only one row\n+        if (arg.is_const)\n+            off = (*arg.offsets)[0];\n+        else\n+            off = (*arg.offsets)[row];\n \n-        for (const auto & pair : map)\n+        for (auto i : collections::range(prev_off[0], off))\n         {\n-            if (pair.getMapped() == args)\n+            all_has_nullable = all_nullable;\n+            typename Map::LookupResult pair = nullptr;\n+\n+            if (arg.null_map && (*arg.null_map)[i])\n+            {\n+                current_has_nullable = true;\n+                if (all_has_nullable && !null_added)\n+                {\n+                    ++result_offset;\n+                    result_data.insertDefault();\n+                    null_map.push_back(1);\n+                    null_added = true;\n+                }\n+                if (null_added)\n+                    continue;\n+            }\n+            else if constexpr (is_numeric_column)\n+            {\n+                pair = map.find(columns[0]->getElement(i));\n+            }\n+            else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n+                pair = map.find(columns[0]->getDataAt(i));\n+            else\n+            {\n+                const char * data = nullptr;\n+                pair = map.find(columns[0]->serializeValueIntoArena(i, arena, data));\n+            }\n+            prev_off[0] = off;\n+            if (arg.is_const)\n+                prev_off[0] = 0;\n+\n+            if (!current_has_nullable)\n+                all_has_nullable = false;\n+\n+            if (pair && pair->getMapped() == args)\n             {\n+                // We increase pair->getMapped() here to not skip duplicate values from the first array.\n+                ++pair->getMapped();\n                 ++result_offset;\n                 if constexpr (is_numeric_column)\n-                    result_data.insertValue(pair.getKey());\n+                {\n+                    result_data.insertValue(pair->getKey());\n+                }\n                 else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n-                    result_data.insertData(pair.getKey().data, pair.getKey().size);\n+                {\n+                    result_data.insertData(pair->getKey().data, pair->getKey().size);\n+                }\n                 else\n-                    result_data.deserializeAndInsertFromArena(pair.getKey().data);\n-\n+                {\n+                    result_data.deserializeAndInsertFromArena(pair->getKey().data);\n+                }\n                 if (all_nullable)\n                     null_map.push_back(0);\n             }\n         }\n         result_offsets.getElement(row) = result_offset;\n-    }\n \n+    }\n     ColumnPtr result_column = std::move(result_data_ptr);\n     if (all_nullable)\n         result_column = ColumnNullable::create(result_column, std::move(null_map_column));\n     return ColumnArray::create(result_column, std::move(result_offsets_ptr));\n+\n }\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00556_array_intersect.reference b/tests/queries/0_stateless/00556_array_intersect.reference\nindex fad9b2f507dc..b9841ef42c4d 100644\n--- a/tests/queries/0_stateless/00556_array_intersect.reference\n+++ b/tests/queries/0_stateless/00556_array_intersect.reference\n@@ -5,7 +5,7 @@\n [1]\n [1]\n [1]\n-[NULL,1]\n+[1,NULL]\n [1]\n [1]\n [[1,1]]\n",
  "problem_statement": "arrayIntersect output elements order\nDoc. arrayIntersect(arr) \r\n\r\n_Takes multiple arrays, returns an array with elements that are present in all source arrays. \r\nElements order in the resulting array is the same as in the first array._\r\n\r\n```\r\nSELECT arrayIntersect(materialize([999, -11, 2, 3]), materialize([3, 2, 1, 999, -11]))\r\n\u250c\u2500arrayIntersect(materialize([999, -11, 2, 3]), materialize([3, 2, 1, 999, -11]))\u2500\u2510\r\n\u2502 [-11,3,999,2]                                                                   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT arrayIntersect([1, 2, 3], [3, 2, 1]) AS l\r\n\u250c\u2500l\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 [3,2,1] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "It's Ok (should be documented).\r\nIt does not aim to maintain the order.\nBut I don't understand why it returns data out of order...\r\nThe implementation for keeping the order should be natural...\n@KochetovNicolai What do you think? \nIt's cause we fill a hash table first, then iterate it - the order is not preserved. It is easy for fix if need.\nI thought we first fill hash table for second array,\r\nthen iterate on the elements of the first array *in their order*\r\nmaking lookups to the hash table \r\nand leaving only elements that were found.\nThere may be more than two arrays.\r\nWe support a map: `key -> the number of arrays seen` instead.\nMaybe correct the docs and close?\nOr we can fix it :)\r\n@den-crane do you need this feature?\nI don't need this feature. I'll fix the doc.\nIt would be really nice to have stable option of arrayIntersect, other alternatives are much more expensive...",
  "created_at": "2023-07-05T15:57:11Z",
  "modified_files": [
    "src/Functions/array/arrayIntersect.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00556_array_intersect.reference"
  ]
}