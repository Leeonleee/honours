{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39129,
  "instance_id": "ClickHouse__ClickHouse-39129",
  "issue_numbers": [
    "28967"
  ],
  "base_commit": "ef455904132829089bf58fd79af88280b15ee7f2",
  "patch": "diff --git a/docs/en/sql-reference/syntax.md b/docs/en/sql-reference/syntax.md\nindex 837022a424f9..0a2a832d2fc2 100644\n--- a/docs/en/sql-reference/syntax.md\n+++ b/docs/en/sql-reference/syntax.md\n@@ -77,8 +77,9 @@ Numeric literal tries to be parsed:\n \n Literal value has the smallest type that the value fits in.\n For example, 1 is parsed as `UInt8`, but 256 is parsed as `UInt16`. For more information, see [Data types](../sql-reference/data-types/index.md).\n+Underscores `_` inside numeric literals are ignored and can be used for better readability.\n \n-Examples: `1`, `18446744073709551615`, `0xDEADBEEF`, `01`, `0.1`, `1e100`, `-1e-100`, `inf`, `nan`.\n+Examples: `1`, `10_000_000`, `0xffff_ffff`, `18446744073709551615`, `0xDEADBEEF`, `01`, `0.1`, `1e100`, `-1e-100`, `inf`, `nan`.\n \n ### String\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02354_numeric_literals_with_underscores.reference b/tests/queries/0_stateless/02354_numeric_literals_with_underscores.reference\nnew file mode 100644\nindex 000000000000..f737a774e093\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_numeric_literals_with_underscores.reference\n@@ -0,0 +1,6 @@\n+1000\n+1.000001\n+100.00001\n+305419896\n+610839792\n+583\ndiff --git a/tests/queries/0_stateless/02354_numeric_literals_with_underscores.sql b/tests/queries/0_stateless/02354_numeric_literals_with_underscores.sql\nnew file mode 100644\nindex 000000000000..b58bbfc58504\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_numeric_literals_with_underscores.sql\n@@ -0,0 +1,6 @@\n+select 1_000;\n+select 1.00_00_01;\n+select 1.000_0001e2;\n+select 0x12_34_56_78;\n+select 0x12_34_56_78p1;\n+select 0b0010_0100_0111;\n",
  "problem_statement": "Should we support numeric literals in form of 1_000_000? (with underscore separator of groups).\nPros:\r\n- it is convenient to type and read numbers this way;\r\n- Ada, Perl, C++, Go and Rust already support that;\r\n- can support thousands as well as lakhs and crores;\r\n\r\nCons:\r\n- standard SQL does not have this support;\r\n- PostgreSQL treat `SELECT 1_000_000` as number one with `_000_000` alias: http://sqlfiddle.com/#!17/0a28f/400\r\n- C++ has `1'000'000` instead of `1_000_000`;\r\n\r\nWhat do you think?\r\n\n",
  "hints_text": "I'd like to have such feature... I'm always confusing number of zeros. I'd prefer to have `1'000'000` but I understand that it's impossible in SQL.\nbeing able to do an output format with a separator would be nice too.  :)\nOnly one thumb up in 4 months.\nOnly one thumb up in 8 months.",
  "created_at": "2022-07-12T15:57:22Z",
  "modified_files": [
    "docs/en/sql-reference/syntax.md"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02354_numeric_literals_with_underscores.reference",
    "b/tests/queries/0_stateless/02354_numeric_literals_with_underscores.sql"
  ]
}