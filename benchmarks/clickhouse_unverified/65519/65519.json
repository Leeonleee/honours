{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 65519,
  "instance_id": "ClickHouse__ClickHouse-65519",
  "issue_numbers": [
    "65039"
  ],
  "base_commit": "e63a799b35d7cb54db93269dba5b69560b25acde",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex eb825c8b12f9..1eda4436b36d 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -1213,7 +1213,7 @@ SELECT parseTimeDelta('1yr2mo')\n \n ## least\n \n-Returns the smaller value of a and b.\n+Returns the smallest arguments of one or more input arguments.  NULL arguments are ignored.\n \n **Syntax**\n \n@@ -1223,7 +1223,7 @@ least(a, b)\n \n ## greatest\n \n-Returns the larger value of a and b.\n+Returns the largest arguments of one or more input arguments.  NULL arguments are ignored.\n \n **Syntax**\n \n",
  "test_patch": "diff --git a/src/Functions/LeastGreatestGeneric.h b/src/Functions/LeastGreatestGeneric.h\nindex bbab001b00db..e647aaa4d80a 100644\n--- a/src/Functions/LeastGreatestGeneric.h\n+++ b/src/Functions/LeastGreatestGeneric.h\n@@ -8,7 +8,6 @@\n #include <Functions/FunctionFactory.h>\n #include <base/map.h>\n \n-\n namespace DB\n {\n \n@@ -37,6 +36,7 @@ class FunctionLeastGreatestGeneric : public IFunction\n     size_t getNumberOfArguments() const override { return 0; }\n     bool isVariadic() const override { return true; }\n     bool useDefaultImplementationForConstants() const override { return true; }\n+    bool useDefaultImplementationForNulls() const override { return false; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & types) const override\n@@ -49,13 +49,22 @@ class FunctionLeastGreatestGeneric : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n-        size_t num_arguments = arguments.size();\n-        if (1 == num_arguments)\n+        if (arguments.size() == 1)\n             return arguments[0].column;\n \n-        Columns converted_columns(num_arguments);\n-        for (size_t arg = 0; arg < num_arguments; ++arg)\n-            converted_columns[arg] = castColumn(arguments[arg], result_type)->convertToFullColumnIfConst();\n+        Columns converted_columns;\n+        for (const auto & argument : arguments)\n+        {\n+            if (argument.type->onlyNull())\n+                continue; /// ignore NULL arguments\n+            auto converted_col = castColumn(argument, result_type)->convertToFullColumnIfConst();\n+            converted_columns.emplace_back(converted_col);\n+        }\n+\n+        if (converted_columns.empty())\n+            return arguments[0].column;\n+        else if (converted_columns.size() == 1)\n+            return converted_columns[0];\n \n         auto result_column = result_type->createColumn();\n         result_column->reserve(input_rows_count);\n@@ -63,17 +72,17 @@ class FunctionLeastGreatestGeneric : public IFunction\n         for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n         {\n             size_t best_arg = 0;\n-            for (size_t arg = 1; arg < num_arguments; ++arg)\n+            for (size_t arg = 1; arg < converted_columns.size(); ++arg)\n             {\n-                auto cmp_result = converted_columns[arg]->compareAt(row_num, row_num, *converted_columns[best_arg], 1);\n-\n                 if constexpr (kind == LeastGreatest::Least)\n                 {\n+                    auto cmp_result = converted_columns[arg]->compareAt(row_num, row_num, *converted_columns[best_arg], 1);\n                     if (cmp_result < 0)\n                         best_arg = arg;\n                 }\n                 else\n                 {\n+                    auto cmp_result = converted_columns[arg]->compareAt(row_num, row_num, *converted_columns[best_arg], -1);\n                     if (cmp_result > 0)\n                         best_arg = arg;\n                 }\n@@ -86,7 +95,6 @@ class FunctionLeastGreatestGeneric : public IFunction\n     }\n };\n \n-\n template <LeastGreatest kind, typename SpecializedFunction>\n class LeastGreatestOverloadResolver : public IFunctionOverloadResolver\n {\n@@ -103,6 +111,7 @@ class LeastGreatestOverloadResolver : public IFunctionOverloadResolver\n     String getName() const override { return name; }\n     size_t getNumberOfArguments() const override { return 0; }\n     bool isVariadic() const override { return true; }\n+    bool useDefaultImplementationForNulls() const override { return false; }\n \n     FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override\n     {\n@@ -111,7 +120,7 @@ class LeastGreatestOverloadResolver : public IFunctionOverloadResolver\n             argument_types.push_back(argument.type);\n \n         /// More efficient specialization for two numeric arguments.\n-        if (arguments.size() == 2 && isNumber(removeNullable(arguments[0].type)) && isNumber(removeNullable(arguments[1].type)))\n+        if (arguments.size() == 2 && isNumber(arguments[0].type) && isNumber(arguments[1].type))\n             return std::make_unique<FunctionToFunctionBaseAdaptor>(SpecializedFunction::create(context), argument_types, return_type);\n \n         return std::make_unique<FunctionToFunctionBaseAdaptor>(\n@@ -123,7 +132,7 @@ class LeastGreatestOverloadResolver : public IFunctionOverloadResolver\n         if (types.empty())\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} cannot be called without arguments\", getName());\n \n-        if (types.size() == 2 && isNumber(removeNullable(types[0])) && isNumber(removeNullable(types[1])))\n+        if (types.size() == 2 && isNumber(types[0]) && isNumber(types[1]))\n             return SpecializedFunction::create(context)->getReturnTypeImpl(types);\n \n         return getLeastSupertype(types);\ndiff --git a/tests/performance/least_greatest.xml b/tests/performance/least_greatest.xml\ndeleted file mode 100644\nindex 522bcd9004d7..000000000000\n--- a/tests/performance/least_greatest.xml\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-<test>\n-    <create_query>CREATE TABLE test (id Int32, x1 Nullable(Int32), x2 Nullable(Float32)) ENGINE = MergeTree() ORDER BY id</create_query>\n-\n-    <fill_query>INSERT INTO test SELECT number, number+1, number + 2 FROM numbers(1000000)</fill_query>\n-\n-    <query tag='LEAST'>SELECT COUNT(1) FROM test WHERE least(x1, x2) > 1</query>\n-    <query tag='GREATEST'>SELECT COUNT(1) FROM test WHERE GREATEST(x1, x2) > 1</query>\n-    \n-    <drop_query>DROP TABLE IF EXISTS test</drop_query>\n-</test>\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/01246_least_greatest_generic.reference b/tests/queries/0_stateless/01246_least_greatest_generic.reference\nindex 9dd5f8e5ffd4..2508618b9a4d 100644\n--- a/tests/queries/0_stateless/01246_least_greatest_generic.reference\n+++ b/tests/queries/0_stateless/01246_least_greatest_generic.reference\n@@ -5,9 +5,9 @@ z\n hello\n world\n 1\n-\\N\n-\\N\n-nan\n+1\n+inf\n+inf\n inf\n -0\n 123\n@@ -20,4 +20,4 @@ inf\n []\n [NULL]\n [0]\n-[NULL]\n+[0]\ndiff --git a/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.reference b/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.reference\nnew file mode 100644\nindex 000000000000..6dbf5ace437d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.reference\n@@ -0,0 +1,21 @@\n+Test with one const argument\n+\\N\t\\N\n+Test with two const arguments\n+1\t1\n+1\t1\n+1.1\t1.1\n+1.1\t1.1\n+a\ta\n+a\ta\n+Test with one non-const argument\n+\\N\t\\N\n+Test with two non-const arguments\n+1\t1\n+1\t1\n+1.1\t1.1\n+1.1\t1.1\n+a\ta\n+a\ta\n+Special cases\n+2\t1\n+1\t1\ndiff --git a/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.sql b/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.sql\nnew file mode 100644\nindex 000000000000..68578821c0c3\n--- /dev/null\n+++ b/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.sql\n@@ -0,0 +1,27 @@\n+-- Tests functions \"greatest\" and \"least\" with NULL arguments\n+\n+SELECT 'Test with one const argument';\n+SELECT greatest(NULL), least(NULL);\n+\n+SELECT 'Test with two const arguments';\n+SELECT greatest(1, NULL), least(1, NULL);\n+SELECT greatest(NULL, 1), least(NULL, 1);\n+SELECT greatest(NULL, 1.1), least(NULL, 1.1);\n+SELECT greatest(1.1, NULL), least(1.1, NULL);\n+SELECT greatest(NULL, 'a'), least(NULL, 'a');\n+SELECT greatest('a', NULL), least('a', NULL);\n+\n+SELECT 'Test with one non-const argument';\n+SELECT greatest(materialize(NULL)), least(materialize(NULL));\n+\n+SELECT 'Test with two non-const arguments';\n+SELECT greatest(materialize(1), NULL), least(materialize(1), NULL);\n+SELECT greatest(materialize(NULL), 1), least(materialize(NULL), 1);\n+SELECT greatest(materialize(NULL), 1.1), least(materialize(NULL), 1.1);\n+SELECT greatest(materialize(1.1), NULL), least(materialize(1.1), NULL);\n+SELECT greatest(materialize(NULL), 'a'), least(materialize(NULL), 'a');\n+SELECT greatest(materialize('a'), NULL), least(materialize('a'), NULL);\n+\n+SELECT 'Special cases';\n+SELECT greatest(toNullable(1), 2), least(toNullable(1), 2);\n+SELECT greatest(toLowCardinality(1), NULL), least(toLowCardinality(1), NULL);\n",
  "problem_statement": "LEAST/GREATEST return null if present\n**Describe the unexpected behaviour**\r\nShould return 1 for `SELECT LEAST(1, 2, null);` \r\n\r\n**How to reproduce**\r\n`SELECT LEAST(1, 2, null);` \r\n\r\n* Which ClickHouse server version to use:\r\n24.5\r\n\r\n* Queries to run that lead to unexpected result\r\n`SELECT LEAST(1, 2, null);` \r\n`SELECT greatest(1, 2, null)`\r\n\r\n**Expected behavior**\r\nShould return 1 or 2 like PostgreSQL/DuckBD\r\n\n",
  "hints_text": "Hello,  this problem also happens in our `gluten` case while compare to spark, and I submit a pr to fix it. @melvynator ",
  "created_at": "2024-06-21T07:21:33Z",
  "modified_files": [
    "docs/en/sql-reference/functions/other-functions.md"
  ],
  "modified_test_files": [
    "src/Functions/LeastGreatestGeneric.h",
    "tests/performance/least_greatest.xml",
    "tests/queries/0_stateless/01246_least_greatest_generic.reference",
    "b/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.reference",
    "b/tests/queries/0_stateless/03174_least_greatest_ignore_null_input_values.sql"
  ]
}