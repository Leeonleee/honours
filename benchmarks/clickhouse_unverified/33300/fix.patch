diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 5c0322ac1d9f..7049dfc03f69 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -401,7 +401,7 @@ InterpreterSelectQuery::InterpreterSelectQuery(
             view = nullptr;
         }
 
-        if (try_move_to_prewhere && storage && storage->supportsPrewhere() && query.where() && !query.prewhere())
+        if (try_move_to_prewhere && storage && storage->canMoveConditionsToPrewhere() && query.where() && !query.prewhere())
         {
             /// PREWHERE optimization: transfer some condition from WHERE to PREWHERE if enabled and viable
             if (const auto & column_sizes = storage->getColumnSizes(); !column_sizes.empty())
diff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h
index bcbc771815b6..6342c3f6b476 100644
--- a/src/Storages/IStorage.h
+++ b/src/Storages/IStorage.h
@@ -135,6 +135,9 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo
     /// Returns true if the storage supports queries with the PREWHERE section.
     virtual bool supportsPrewhere() const { return false; }
 
+    /// Returns true if the storage supports optimization of moving conditions to PREWHERE section.
+    virtual bool canMoveConditionsToPrewhere() const { return supportsPrewhere(); }
+
     /// Returns true if the storage replicates SELECT, INSERT and ALTER commands among replicas.
     virtual bool supportsReplication() const { return false; }
 
diff --git a/src/Storages/StorageDistributed.h b/src/Storages/StorageDistributed.h
index 06fa89056392..e47e0fddd6cf 100644
--- a/src/Storages/StorageDistributed.h
+++ b/src/Storages/StorageDistributed.h
@@ -53,6 +53,10 @@ class StorageDistributed final : public shared_ptr_helper<StorageDistributed>, p
     bool supportsSubcolumns() const override { return true; }
     StoragePolicyPtr getStoragePolicy() const override;
 
+    /// Do not apply moving to PREWHERE optimization for distributed tables,
+    /// because we can't be sure that underlying table supports PREWHERE.
+    bool canMoveConditionsToPrewhere() const override { return false; }
+
     bool isRemote() const override { return true; }
 
     QueryProcessingStage::Enum
diff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp
index bdb7ddb744aa..0dc6f2931d3a 100644
--- a/src/Storages/StorageMerge.cpp
+++ b/src/Storages/StorageMerge.cpp
@@ -116,6 +116,15 @@ StoragePtr StorageMerge::getFirstTable(F && predicate) const
     return {};
 }
 
+template <typename F>
+void StorageMerge::forEachTable(F && func) const
+{
+    getFirstTable([&func](const auto & table)
+    {
+        func(table);
+        return false;
+    });
+}
 
 bool StorageMerge::isRemote() const
 {
@@ -123,6 +132,16 @@ bool StorageMerge::isRemote() const
     return first_remote_table != nullptr;
 }
 
+bool StorageMerge::canMoveConditionsToPrewhere() const
+{
+    /// NOTE: This check is used during query analysis as condition for applying
+    /// "move to PREWHERE" optimization. However, it contains a logical race:
+    /// If new table that matches regexp for current storage and doesn't support PREWHERE
+    /// will appear after this check and before calling "read" method, the optimized query may fail.
+    /// Since it's quite rare case, we just ignore this possibility.
+
+    return getFirstTable([](const auto & table) { return !table->canMoveConditionsToPrewhere(); }) == nullptr;
+}
 
 bool StorageMerge::mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, ContextPtr query_context, const StorageMetadataPtr & /*metadata_snapshot*/) const
 {
@@ -771,10 +790,15 @@ void StorageMerge::convertingSourceStream(
 
 IStorage::ColumnSizeByName StorageMerge::getColumnSizes() const
 {
-    auto first_materialized_mysql = getFirstTable([](const StoragePtr & table) { return table && table->getName() == "MaterializedMySQL"; });
-    if (!first_materialized_mysql)
-        return {};
-    return first_materialized_mysql->getColumnSizes();
+    ColumnSizeByName column_sizes;
+
+    forEachTable([&](const auto & table)
+    {
+        for (const auto & [name, size] : table->getColumnSizes())
+            column_sizes[name].add(size);
+    });
+
+    return column_sizes;
 }
 
 
diff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h
index ad3075efd085..e0d815313255 100644
--- a/src/Storages/StorageMerge.h
+++ b/src/Storages/StorageMerge.h
@@ -22,10 +22,12 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora
 
     /// The check is delayed to the read method. It checks the support of the tables used.
     bool supportsSampling() const override { return true; }
-    bool supportsPrewhere() const override { return true; }
     bool supportsFinal() const override { return true; }
     bool supportsIndexForIn() const override { return true; }
     bool supportsSubcolumns() const override { return true; }
+    bool supportsPrewhere() const override { return true; }
+
+    bool canMoveConditionsToPrewhere() const override;
 
     QueryProcessingStage::Enum
     getQueryProcessingStage(ContextPtr, QueryProcessingStage::Enum, const StorageMetadataPtr &, SelectQueryInfo &) const override;
@@ -75,6 +77,9 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora
     template <typename F>
     StoragePtr getFirstTable(F && predicate) const;
 
+    template <typename F>
+    void forEachTable(F && func) const;
+
     DatabaseTablesIteratorPtr getDatabaseIterator(const String & database_name, ContextPtr context) const;
 
     DatabaseTablesIterators getDatabaseIterators(ContextPtr context) const;
