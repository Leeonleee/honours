diff --git a/src/Processors/Transforms/MergingAggregatedTransform.cpp b/src/Processors/Transforms/MergingAggregatedTransform.cpp
index 37419f55aaec..dd2b315d53cd 100644
--- a/src/Processors/Transforms/MergingAggregatedTransform.cpp
+++ b/src/Processors/Transforms/MergingAggregatedTransform.cpp
@@ -1,5 +1,6 @@
 #include <Processors/Transforms/MergingAggregatedTransform.h>
 #include <Processors/Transforms/AggregatingTransform.h>
+#include <Processors/Transforms/AggregatingInOrderTransform.h>
 
 namespace DB
 {
@@ -34,21 +35,30 @@ void MergingAggregatedTransform::consume(Chunk chunk)
     if (!info)
         throw Exception("Chunk info was not set for chunk in MergingAggregatedTransform.", ErrorCodes::LOGICAL_ERROR);
 
-    const auto * agg_info = typeid_cast<const AggregatedChunkInfo *>(info.get());
-    if (!agg_info)
-        throw Exception("Chunk should have AggregatedChunkInfo in MergingAggregatedTransform.", ErrorCodes::LOGICAL_ERROR);
+    if (const auto * agg_info = typeid_cast<const AggregatedChunkInfo *>(info.get()))
+    {
+        /** If the remote servers used a two-level aggregation method,
+        *  then blocks will contain information about the number of the bucket.
+        * Then the calculations can be parallelized by buckets.
+        * We decompose the blocks to the bucket numbers indicated in them.
+        */
 
-    /** If the remote servers used a two-level aggregation method,
-      *  then blocks will contain information about the number of the bucket.
-      * Then the calculations can be parallelized by buckets.
-      * We decompose the blocks to the bucket numbers indicated in them.
-      */
+        auto block = getInputPort().getHeader().cloneWithColumns(chunk.getColumns());
+        block.info.is_overflows = agg_info->is_overflows;
+        block.info.bucket_num = agg_info->bucket_num;
 
-    auto block = getInputPort().getHeader().cloneWithColumns(chunk.getColumns());
-    block.info.is_overflows = agg_info->is_overflows;
-    block.info.bucket_num = agg_info->bucket_num;
+        bucket_to_blocks[agg_info->bucket_num].emplace_back(std::move(block));
+    }
+    else if (const auto * in_order_info = typeid_cast<const ChunkInfoWithAllocatedBytes *>(info.get()))
+    {
+        auto block = getInputPort().getHeader().cloneWithColumns(chunk.getColumns());
+        block.info.is_overflows = false;
+        block.info.bucket_num = -1;
 
-    bucket_to_blocks[agg_info->bucket_num].emplace_back(std::move(block));
+        bucket_to_blocks[block.info.bucket_num].emplace_back(std::move(block));
+    }
+    else
+        throw Exception("Chunk should have AggregatedChunkInfo in MergingAggregatedTransform.", ErrorCodes::LOGICAL_ERROR);
 }
 
 Chunk MergingAggregatedTransform::generate()
