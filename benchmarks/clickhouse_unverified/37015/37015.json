{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37015,
  "instance_id": "ClickHouse__ClickHouse-37015",
  "issue_numbers": [
    "35693"
  ],
  "base_commit": "c8481b018d265f53aa92f9e0de9bfef9d18ba985",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 2e6d657698cf..13c2889e2470 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -182,6 +182,8 @@ static constexpr UInt64 operator\"\"_GiB(unsigned long long value)\n     \\\n     M(Int64, network_zstd_compression_level, 1, \"Allows you to select the level of ZSTD compression.\", 0) \\\n     \\\n+    M(Int64, zstd_window_log_max, 0, \"Allows you to select the max window log of ZSTD (it will not be used for MergeTree family)\", 0) \\\n+    \\\n     M(UInt64, priority, 0, \"Priority of the query. 1 - the highest, higher value - lower priority; 0 - do not use priorities.\", 0) \\\n     M(Int64, os_thread_priority, 0, \"If non zero - set corresponding 'nice' value for query processing threads. Can be used to adjust query priority for OS scheduler.\", 0) \\\n     \\\ndiff --git a/src/IO/CompressionMethod.cpp b/src/IO/CompressionMethod.cpp\nindex fe4772948ad4..0da235c074ca 100644\n--- a/src/IO/CompressionMethod.cpp\n+++ b/src/IO/CompressionMethod.cpp\n@@ -99,7 +99,7 @@ CompressionMethod chooseCompressionMethod(const std::string & path, const std::s\n }\n \n static std::unique_ptr<CompressedReadBufferWrapper> createCompressedWrapper(\n-    std::unique_ptr<ReadBuffer> nested, CompressionMethod method, size_t buf_size, char * existing_memory, size_t alignment)\n+    std::unique_ptr<ReadBuffer> nested, CompressionMethod method, size_t buf_size, char * existing_memory, size_t alignment, int zstd_window_log_max)\n {\n     if (method == CompressionMethod::Gzip || method == CompressionMethod::Zlib)\n         return std::make_unique<ZlibInflatingReadBuffer>(std::move(nested), method, buf_size, existing_memory, alignment);\n@@ -110,7 +110,7 @@ static std::unique_ptr<CompressedReadBufferWrapper> createCompressedWrapper(\n     if (method == CompressionMethod::Xz)\n         return std::make_unique<LZMAInflatingReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n     if (method == CompressionMethod::Zstd)\n-        return std::make_unique<ZstdInflatingReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n+        return std::make_unique<ZstdInflatingReadBuffer>(std::move(nested), buf_size, existing_memory, alignment, zstd_window_log_max);\n     if (method == CompressionMethod::Lz4)\n         return std::make_unique<Lz4InflatingReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n #if USE_BZIP2\n@@ -126,14 +126,13 @@ static std::unique_ptr<CompressedReadBufferWrapper> createCompressedWrapper(\n }\n \n std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n-    std::unique_ptr<ReadBuffer> nested, CompressionMethod method, size_t buf_size, char * existing_memory, size_t alignment)\n+    std::unique_ptr<ReadBuffer> nested, CompressionMethod method, int zstd_window_log_max, size_t buf_size, char * existing_memory, size_t alignment)\n {\n     if (method == CompressionMethod::None)\n         return nested;\n-    return createCompressedWrapper(std::move(nested), method, buf_size, existing_memory, alignment);\n+    return createCompressedWrapper(std::move(nested), method, buf_size, existing_memory, alignment, zstd_window_log_max);\n }\n \n-\n std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n     std::unique_ptr<WriteBuffer> nested, CompressionMethod method, int level, size_t buf_size, char * existing_memory, size_t alignment)\n {\ndiff --git a/src/IO/CompressionMethod.h b/src/IO/CompressionMethod.h\nindex 3953ba9d212f..a399a756c13b 100644\n--- a/src/IO/CompressionMethod.h\n+++ b/src/IO/CompressionMethod.h\n@@ -5,7 +5,6 @@\n \n #include <Core/Defines.h>\n \n-\n namespace DB\n {\n class ReadBuffer;\n@@ -50,10 +49,12 @@ CompressionMethod chooseCompressionMethod(const std::string & path, const std::s\n std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n     std::unique_ptr<ReadBuffer> nested,\n     CompressionMethod method,\n+    int zstd_window_log_max = 0,\n     size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n     char * existing_memory = nullptr,\n     size_t alignment = 0);\n \n+\n std::unique_ptr<WriteBuffer> wrapWriteBufferWithCompressionMethod(\n     std::unique_ptr<WriteBuffer> nested,\n     CompressionMethod method,\ndiff --git a/src/IO/ZstdInflatingReadBuffer.cpp b/src/IO/ZstdInflatingReadBuffer.cpp\nindex 712ea6960ef0..0d026cdab9a3 100644\n--- a/src/IO/ZstdInflatingReadBuffer.cpp\n+++ b/src/IO/ZstdInflatingReadBuffer.cpp\n@@ -8,7 +8,7 @@ namespace ErrorCodes\n     extern const int ZSTD_DECODER_FAILED;\n }\n \n-ZstdInflatingReadBuffer::ZstdInflatingReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char * existing_memory, size_t alignment)\n+ZstdInflatingReadBuffer::ZstdInflatingReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char * existing_memory, size_t alignment, int zstd_window_log_max)\n     : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n {\n     dctx = ZSTD_createDCtx();\n@@ -19,6 +19,12 @@ ZstdInflatingReadBuffer::ZstdInflatingReadBuffer(std::unique_ptr<ReadBuffer> in_\n     {\n         throw Exception(ErrorCodes::ZSTD_DECODER_FAILED, \"zstd_stream_decoder init failed: zstd version: {}\", ZSTD_VERSION_STRING);\n     }\n+\n+    size_t ret = ZSTD_DCtx_setParameter(dctx, ZSTD_d_windowLogMax, zstd_window_log_max);\n+    if (ZSTD_isError(ret))\n+    {\n+        throw Exception(ErrorCodes::ZSTD_DECODER_FAILED, \"zstd_stream_decoder init failed: {}\", ZSTD_getErrorName(ret));\n+    }\n }\n \n ZstdInflatingReadBuffer::~ZstdInflatingReadBuffer()\ndiff --git a/src/IO/ZstdInflatingReadBuffer.h b/src/IO/ZstdInflatingReadBuffer.h\nindex a0c20b79d807..faa6231d4e2c 100644\n--- a/src/IO/ZstdInflatingReadBuffer.h\n+++ b/src/IO/ZstdInflatingReadBuffer.h\n@@ -20,7 +20,8 @@ class ZstdInflatingReadBuffer : public CompressedReadBufferWrapper\n         std::unique_ptr<ReadBuffer> in_,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         char * existing_memory = nullptr,\n-        size_t alignment = 0);\n+        size_t alignment = 0,\n+        int zstd_window_log_max = 0);\n \n     ~ZstdInflatingReadBuffer() override;\n \ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex 4a1de7ddf2d3..f139ff8897d9 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -643,7 +643,7 @@ void HTTPHandler::processQuery(\n     /// Request body can be compressed using algorithm specified in the Content-Encoding header.\n     String http_request_compression_method_str = request.get(\"Content-Encoding\", \"\");\n     auto in_post = wrapReadBufferWithCompressionMethod(\n-        wrapReadBufferReference(request.getStream()), chooseCompressionMethod({}, http_request_compression_method_str));\n+        wrapReadBufferReference(request.getStream()), chooseCompressionMethod({}, http_request_compression_method_str), context->getSettingsRef().zstd_window_log_max);\n \n     /// The data can also be compressed using incompatible internal algorithm. This is indicated by\n     /// 'decompress' query parameter.\ndiff --git a/src/Storages/HDFS/StorageHDFS.cpp b/src/Storages/HDFS/StorageHDFS.cpp\nindex 0176487bbfe0..4ba200dfd09a 100644\n--- a/src/Storages/HDFS/StorageHDFS.cpp\n+++ b/src/Storages/HDFS/StorageHDFS.cpp\n@@ -194,8 +194,9 @@ ColumnsDescription StorageHDFS::getTableStructureFromData(\n         if (it == paths.end())\n             return nullptr;\n         auto compression = chooseCompressionMethod(*it, compression_method);\n+        auto zstd_window_log_max = ctx->getSettingsRef().zstd_window_log_max;\n         return wrapReadBufferWithCompressionMethod(\n-            std::make_unique<ReadBufferFromHDFS>(uri_without_path, *it++, ctx->getGlobalContext()->getConfigRef()), compression);\n+            std::make_unique<ReadBufferFromHDFS>(uri_without_path, *it++, ctx->getGlobalContext()->getConfigRef()), compression, zstd_window_log_max);\n     };\n     return readSchemaFromFormat(format, std::nullopt, read_buffer_iterator, paths.size() > 1, ctx);\n }\n@@ -324,7 +325,8 @@ bool HDFSSource::initialize()\n     const auto [path_from_uri, uri_without_path] = getPathFromUriAndUriWithoutPath(current_path);\n \n     auto compression = chooseCompressionMethod(path_from_uri, storage->compression_method);\n-    read_buf = wrapReadBufferWithCompressionMethod(std::make_unique<ReadBufferFromHDFS>(uri_without_path, path_from_uri, getContext()->getGlobalContext()->getConfigRef()), compression);\n+    const auto zstd_window_log_max = getContext()->getSettingsRef().zstd_window_log_max;\n+    read_buf = wrapReadBufferWithCompressionMethod(std::make_unique<ReadBufferFromHDFS>(uri_without_path, path_from_uri, getContext()->getGlobalContext()->getConfigRef()), compression, zstd_window_log_max);\n \n     auto input_format = getContext()->getInputFormat(storage->format_name, *read_buf, block_for_format, max_block_size);\n \ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 5b191b37f5ea..63923c51b005 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -207,7 +207,8 @@ std::unique_ptr<ReadBuffer> createReadBuffer(\n         in.setProgressCallback(context);\n     }\n \n-    return wrapReadBufferWithCompressionMethod(std::move(nested_buffer), method);\n+    auto zstd_window_log_max = context->getSettingsRef().zstd_window_log_max;\n+    return wrapReadBufferWithCompressionMethod(std::move(nested_buffer), method, zstd_window_log_max);\n }\n \n }\ndiff --git a/src/Storages/StorageS3.cpp b/src/Storages/StorageS3.cpp\nindex 6107c1a5117c..04806539dc0a 100644\n--- a/src/Storages/StorageS3.cpp\n+++ b/src/Storages/StorageS3.cpp\n@@ -302,7 +302,8 @@ bool StorageS3Source::initialize()\n \n     file_path = fs::path(bucket) / current_key;\n \n-    read_buf = wrapReadBufferWithCompressionMethod(createS3ReadBuffer(current_key), chooseCompressionMethod(current_key, compression_hint));\n+    auto zstd_window_log_max = getContext()->getSettingsRef().zstd_window_log_max;\n+    read_buf = wrapReadBufferWithCompressionMethod(createS3ReadBuffer(current_key), chooseCompressionMethod(current_key, compression_hint), zstd_window_log_max);\n \n     auto input_format = getContext()->getInputFormat(format, *read_buf, sample_block, max_block_size, format_settings);\n     QueryPipelineBuilder builder;\n@@ -1022,10 +1023,12 @@ ColumnsDescription StorageS3::getTableStructureFromDataImpl(\n             read_keys_in_distributed_processing->push_back(key);\n \n         first = false;\n+        const auto zstd_window_log_max = ctx->getSettingsRef().zstd_window_log_max;\n         return wrapReadBufferWithCompressionMethod(\n             std::make_unique<ReadBufferFromS3>(\n                 s3_configuration.client, s3_configuration.uri.bucket, key, s3_configuration.uri.version_id, s3_configuration.rw_settings.max_single_read_retries, ctx->getReadSettings()),\n-            chooseCompressionMethod(key, compression_method));\n+            chooseCompressionMethod(key, compression_method),\n+            zstd_window_log_max);\n     };\n \n     return readSchemaFromFormat(format, format_settings, read_buffer_iterator, is_key_with_globs, ctx);\ndiff --git a/src/Storages/StorageURL.cpp b/src/Storages/StorageURL.cpp\nindex 03bd1d5e7d99..efb5a26a0c6e 100644\n--- a/src/Storages/StorageURL.cpp\n+++ b/src/Storages/StorageURL.cpp\n@@ -349,7 +349,8 @@ namespace\n                                         std::move(read_buffer_factory),\n                                         threadPoolCallbackRunner(IOThreadPool::get()),\n                                         download_threads),\n-                                    chooseCompressionMethod(request_uri.getPath(), compression_method));\n+                                    chooseCompressionMethod(request_uri.getPath(), compression_method),\n+                                    settings.zstd_window_log_max);\n                             }\n                         }\n                         catch (const Poco::Exception & e)\n@@ -380,7 +381,8 @@ namespace\n                             delay_initialization,\n                             /* use_external_buffer */ false,\n                             /* skip_url_not_found_error */ skip_url_not_found_error),\n-                        chooseCompressionMethod(request_uri.getPath(), compression_method));\n+                        chooseCompressionMethod(request_uri.getPath(), compression_method),\n+                        settings.zstd_window_log_max);\n                 }\n                 catch (...)\n                 {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02293_test_zstd_window_log_max.reference b/tests/queries/0_stateless/02293_test_zstd_window_log_max.reference\nnew file mode 100644\nindex 000000000000..98ca7fb2d292\n--- /dev/null\n+++ b/tests/queries/0_stateless/02293_test_zstd_window_log_max.reference\n@@ -0,0 +1,2 @@\n+1\n+40\ndiff --git a/tests/queries/0_stateless/02293_test_zstd_window_log_max.sh b/tests/queries/0_stateless/02293_test_zstd_window_log_max.sh\nnew file mode 100755\nindex 000000000000..0683d1947389\n--- /dev/null\n+++ b/tests/queries/0_stateless/02293_test_zstd_window_log_max.sh\n@@ -0,0 +1,11 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+# reuse the test data in 01946_test_zstd_decompression_with_escape_sequence_at_the_end_of_buffer.sh\n+$CLICKHOUSE_LOCAL --query \"SELECT count() FROM file('$CUR_DIR/data_zstd/test_01946.zstd', JSONEachRow, 'foo String') SETTINGS zstd_window_log_max=20\" 2>&1  | grep -c \\\n+    \"Code: 561. DB::Exception: Zstd stream encoding failed: error 'Frame requires too much memory for decoding'; zstd version: 1.5.0: While executing File. (ZSTD_DECODER_FAILED)\"\n+$CLICKHOUSE_LOCAL --query \"SELECT count() FROM file('$CUR_DIR/data_zstd/test_01946.zstd', JSONEachRow, 'foo String') SETTINGS zstd_window_log_max=21\"\n",
  "problem_statement": "Allow to use more memory for zstd decompression.\n**Use case**\r\n\r\n```\r\nSELECT count() FROM url('http://files.pushshift.io/reddit/comments/RC_{2018..2021}-{01..12}.zst', JSONEachRow)\r\n```\r\n\r\n```\r\nCode: 561. DB::Exception: Zstd stream encoding failed: error 'Frame requires too much memory for decoding'; zstd version: 1.5.0. (ZSTD_DECODER_FAILED) (version 22.4.1.662)\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nA setting for max memory usage on decoding.\r\n\n",
  "hints_text": "> </div><div id=\":6slv\" style=\"color: rgb(34, 34, 34); font-family: Roboto, RobotoDraft, Helvetica, Arial, sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><div class=\"qQVYZb\"></div><div class=\"utdU2e\"></div><div class=\"lQs8Hd\" jsaction=\"SN3rtf:rcuQ6b\" jscontroller=\"i3Ohde\"></div><div class=\"btm\"></div></div><div class=\"\" style=\"color: rgb(34, 34, 34); font-family: Roboto, RobotoDraft, Helvetica, Arial, sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><div class=\"aHl\" style=\"margin-left: -38px;\"></div><div id=\":a7j5\" tabindex=\"-1\"></div><div id=\":a7fq\" class=\"ii gt\" jslog=\"20277; u014N:xr6bB; 4:W251bGwsbnVsbCxbXV0.\" style=\"direction: ltr; margin: 8px 0px 0px; padding: 0px; position: relative; font-size: 0.875rem;\"><div id=\":6sgx\" class=\"a3s aiL \" style=\"font: small / 1.5 Arial, Helvetica, sans-serif; overflow: hidden;\"><div class=\"adM\"><p></p></div><p dir=\"auto\">I'd like to try, thanks!</p></div></div></div>\r\n\r\n@hongbin This will be wonderful!\nI think we can configure zstd decompression context's parameter `windowLogMax` to allow zstd use more memory. the zstd decompressor uses `(1 << windowLogMax)` memory at most. Do you think this parameter can solve the problem? May i try to pull a request to fix this issue?\r\n\r\nYou can read the [comments](https://facebook.github.io/zstd/zstd_manual.html#Chapter6) about `ZSTD_d_windowLogMax` in zsdt manual to find more infomation about `windowLogMax`.\r\n\r\n\r\n\r\n\n@wuxiaobai24 Yes, it will solve the task. Let's do it.",
  "created_at": "2022-05-08T06:09:47Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/IO/CompressionMethod.cpp",
    "src/IO/CompressionMethod.h",
    "src/IO/ZstdInflatingReadBuffer.cpp",
    "src/IO/ZstdInflatingReadBuffer.h",
    "src/Server/HTTPHandler.cpp",
    "src/Storages/HDFS/StorageHDFS.cpp",
    "src/Storages/StorageFile.cpp",
    "src/Storages/StorageS3.cpp",
    "src/Storages/StorageURL.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02293_test_zstd_window_log_max.reference",
    "b/tests/queries/0_stateless/02293_test_zstd_window_log_max.sh"
  ]
}