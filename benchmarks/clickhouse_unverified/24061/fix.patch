diff --git a/src/Columns/ColumnLowCardinality.h b/src/Columns/ColumnLowCardinality.h
index fc607021ccfe..4af2cb2f36e3 100644
--- a/src/Columns/ColumnLowCardinality.h
+++ b/src/Columns/ColumnLowCardinality.h
@@ -188,6 +188,7 @@ class ColumnLowCardinality final : public COWHelper<IColumn, ColumnLowCardinalit
      */
     bool nestedIsNullable() const { return isColumnNullable(*dictionary.getColumnUnique().getNestedColumn()); }
     void nestedToNullable() { dictionary.getColumnUnique().nestedToNullable(); }
+    void nestedRemoveNullable() { dictionary.getColumnUnique().nestedRemoveNullable(); }
 
     const IColumnUnique & getDictionary() const { return dictionary.getColumnUnique(); }
     const ColumnPtr & getDictionaryPtr() const { return dictionary.getColumnUniquePtr(); }
diff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h
index d1fa8ecdf933..8ca4baff7c74 100644
--- a/src/Columns/ColumnUnique.h
+++ b/src/Columns/ColumnUnique.h
@@ -51,6 +51,7 @@ class ColumnUnique final : public COWHelper<IColumnUnique, ColumnUnique<ColumnTy
     const ColumnPtr & getNestedNotNullableColumn() const override { return column_holder; }
     bool nestedColumnIsNullable() const override { return is_nullable; }
     void nestedToNullable() override;
+    void nestedRemoveNullable() override;
 
     size_t uniqueInsert(const Field & x) override;
     size_t uniqueInsertFrom(const IColumn & src, size_t n) override;
@@ -271,6 +272,14 @@ void ColumnUnique<ColumnType>::nestedToNullable()
     createNullMask();
 }
 
+template <typename ColumnType>
+void ColumnUnique<ColumnType>::nestedRemoveNullable()
+{
+    is_nullable = false;
+    nested_null_mask = nullptr;
+    nested_column_nullable = nullptr;
+}
+
 template <typename ColumnType>
 const ColumnPtr & ColumnUnique<ColumnType>::getNestedColumn() const
 {
diff --git a/src/Columns/IColumnUnique.h b/src/Columns/IColumnUnique.h
index 2c1c542fce5e..5e6473219d18 100644
--- a/src/Columns/IColumnUnique.h
+++ b/src/Columns/IColumnUnique.h
@@ -24,6 +24,7 @@ class IColumnUnique : public IColumn
 
     virtual bool nestedColumnIsNullable() const = 0;
     virtual void nestedToNullable() = 0;
+    virtual void nestedRemoveNullable() = 0;
 
     /// Returns array with StringRefHash calculated for each row of getNestedNotNullableColumn() column.
     /// Returns nullptr if nested column doesn't contain strings. Otherwise calculates hash (if it wasn't).
diff --git a/src/Functions/materialize.h b/src/Functions/materialize.h
index 4676b263f393..5d36a4b23402 100644
--- a/src/Functions/materialize.h
+++ b/src/Functions/materialize.h
@@ -1,6 +1,8 @@
 #pragma once
 #include <Functions/IFunction.h>
 #include <Functions/FunctionFactory.h>
+#include <Columns/ColumnLowCardinality.h>
+#include <DataTypes/DataTypeLowCardinality.h>
 
 namespace DB
 {
diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp
index 09c4c538347b..8023a96374fb 100644
--- a/src/Interpreters/HashJoin.cpp
+++ b/src/Interpreters/HashJoin.cpp
@@ -160,7 +160,7 @@ static ColumnWithTypeAndName correctNullability(ColumnWithTypeAndName && column,
 {
     if (nullable)
     {
-        JoinCommon::convertColumnToNullable(column, true);
+        JoinCommon::convertColumnToNullable(column);
         if (column.type->isNullable() && !negative_null_map.empty())
         {
             MutableColumnPtr mutable_column = IColumn::mutate(std::move(column.column));
@@ -1096,8 +1096,13 @@ void HashJoin::joinBlockImpl(
 
             const auto & col = block.getByName(left_name);
             bool is_nullable = nullable_right_side || right_key.type->isNullable();
+
             auto right_col_name = getTableJoin().renamedRightColumnName(right_key.name);
-            block.insert(correctNullability({col.column, col.type, right_col_name}, is_nullable));
+            ColumnWithTypeAndName right_col(col.column, col.type, right_col_name);
+            if (right_col.type->lowCardinality() != right_key.type->lowCardinality())
+                JoinCommon::changeLowCardinalityInplace(right_col);
+            right_col = correctNullability(std::move(right_col), is_nullable);
+            block.insert(right_col);
         }
     }
     else if (has_required_right_keys)
@@ -1122,8 +1127,13 @@ void HashJoin::joinBlockImpl(
             bool is_nullable = nullable_right_side || right_key.type->isNullable();
 
             ColumnPtr thin_column = filterWithBlanks(col.column, filter);
+
             auto right_col_name = getTableJoin().renamedRightColumnName(right_key.name);
-            block.insert(correctNullability({thin_column, col.type, right_col_name}, is_nullable, null_map_filter));
+            ColumnWithTypeAndName right_col(thin_column, col.type, right_col_name);
+            if (right_col.type->lowCardinality() != right_key.type->lowCardinality())
+                JoinCommon::changeLowCardinalityInplace(right_col);
+            right_col = correctNullability(std::move(right_col), is_nullable, null_map_filter);
+            block.insert(right_col);
 
             if constexpr (need_replication)
                 right_keys_to_replicate.push_back(block.getPositionByName(right_key.name));
diff --git a/src/Interpreters/MergeJoin.cpp b/src/Interpreters/MergeJoin.cpp
index a9f50cdda0e8..26463c8c6edd 100644
--- a/src/Interpreters/MergeJoin.cpp
+++ b/src/Interpreters/MergeJoin.cpp
@@ -464,6 +464,12 @@ MergeJoin::MergeJoin(std::shared_ptr<TableJoin> table_join_, const Block & right
                             ErrorCodes::PARAMETER_OUT_OF_BOUND);
     }
 
+    for (const auto & right_key : table_join->keyNamesRight())
+    {
+        if (right_sample_block.getByName(right_key).type->lowCardinality())
+            lowcard_right_keys.push_back(right_key);
+    }
+
     table_join->splitAdditionalColumns(right_sample_block, right_table_keys, right_columns_to_add);
     JoinCommon::removeLowCardinalityInplace(right_table_keys);
     JoinCommon::removeLowCardinalityInplace(right_sample_block, table_join->keyNamesRight());
@@ -607,10 +613,18 @@ bool MergeJoin::addJoinedBlock(const Block & src_block, bool)
 
 void MergeJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)
 {
+    Names lowcard_keys = lowcard_right_keys;
     if (block)
     {
         JoinCommon::checkTypesOfKeys(block, table_join->keyNamesLeft(), right_table_keys, table_join->keyNamesRight());
         materializeBlockInplace(block);
+
+        for (const auto & column_name : table_join->keyNamesLeft())
+        {
+            if (block.getByName(column_name).type->lowCardinality())
+                lowcard_keys.push_back(column_name);
+        }
+
         JoinCommon::removeLowCardinalityInplace(block, table_join->keyNamesLeft(), false);
 
         sortBlock(block, left_sort_description);
@@ -646,14 +660,20 @@ void MergeJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)
     if (!not_processed && left_blocks_buffer)
         not_processed = std::make_shared<NotProcessed>(NotProcessed{{}, 0, 0, 0});
 
+    for (const auto & column_name : lowcard_keys)
+    {
+        if (!block.has(column_name))
+            continue;
+        if (auto & col = block.getByName(column_name); !col.type->lowCardinality())
+            JoinCommon::changeLowCardinalityInplace(col);
+    }
+
     JoinCommon::restoreLowCardinalityInplace(block);
 }
 
 template <bool in_memory, bool is_all>
 void MergeJoin::joinSortedBlock(Block & block, ExtraBlockPtr & not_processed)
 {
-    //std::shared_lock lock(rwlock);
-
     size_t rows_to_reserve = is_left ? block.rows() : 0;
     MutableColumns left_columns = makeMutableColumns(block, (is_all ? rows_to_reserve : 0));
     MutableColumns right_columns = makeMutableColumns(right_columns_to_add, rows_to_reserve);
@@ -702,7 +722,6 @@ void MergeJoin::joinSortedBlock(Block & block, ExtraBlockPtr & not_processed)
 
         left_cursor.nextN(left_key_tail);
         joinInequalsLeft<is_all>(block, left_columns, right_columns_to_add, right_columns, left_cursor.position(), left_cursor.end());
-        //left_cursor.nextN(left_cursor.end() - left_cursor.position());
 
         changeLeftColumns(block, std::move(left_columns));
         addRightColumns(block, std::move(right_columns));
diff --git a/src/Interpreters/MergeJoin.h b/src/Interpreters/MergeJoin.h
index f286e74b3857..b6bde8fb1312 100644
--- a/src/Interpreters/MergeJoin.h
+++ b/src/Interpreters/MergeJoin.h
@@ -103,6 +103,8 @@ class MergeJoin : public IJoin
     const size_t max_rows_in_right_block;
     const size_t max_files_to_merge;
 
+    Names lowcard_right_keys;
+
     void changeLeftColumns(Block & block, MutableColumns && columns) const;
     void addRightColumns(Block & block, MutableColumns && columns);
 
diff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp
index 80299610a441..9f725c3cd59e 100644
--- a/src/Interpreters/join_common.cpp
+++ b/src/Interpreters/join_common.cpp
@@ -49,6 +49,21 @@ ColumnPtr changeLowCardinality(const ColumnPtr & column, const ColumnPtr & dst_s
 namespace JoinCommon
 {
 
+void changeLowCardinalityInplace(ColumnWithTypeAndName & column)
+{
+    if (column.type->lowCardinality())
+    {
+        column.type = recursiveRemoveLowCardinality(column.type);
+        column.column = column.column->convertToFullColumnIfLowCardinality();
+    }
+    else
+    {
+        column.type = std::make_shared<DataTypeLowCardinality>(column.type);
+        MutableColumnPtr lc = column.type->createColumn();
+        typeid_cast<ColumnLowCardinality &>(*lc).insertRangeFromFullColumn(*column.column, 0, column.column->size());
+        column.column = std::move(lc);
+    }
+}
 
 bool canBecomeNullable(const DataTypePtr & type)
 {
@@ -89,9 +104,11 @@ void convertColumnToNullable(ColumnWithTypeAndName & column, bool remove_low_car
         if (column.column->lowCardinality())
         {
             /// Convert nested to nullable, not LowCardinality itself
-            ColumnLowCardinality * col_as_lc = assert_cast<ColumnLowCardinality *>(column.column->assumeMutable().get());
+            auto mut_col = IColumn::mutate(std::move(column.column));
+            ColumnLowCardinality * col_as_lc = assert_cast<ColumnLowCardinality *>(mut_col.get());
             if (!col_as_lc->nestedIsNullable())
                 col_as_lc->nestedToNullable();
+            column.column = std::move(mut_col);
         }
         else
             column.column = makeNullable(column.column);
@@ -107,6 +124,19 @@ void convertColumnsToNullable(Block & block, size_t starting_pos)
 /// @warning It assumes that every NULL has default value in nested column (or it does not matter)
 void removeColumnNullability(ColumnWithTypeAndName & column)
 {
+    if (column.type->lowCardinality())
+    {
+        /// LowCardinality(Nullable(T)) case
+        const auto & dict_type = typeid_cast<const DataTypeLowCardinality *>(column.type.get())->getDictionaryType();
+        column.type = std::make_shared<DataTypeLowCardinality>(removeNullable(dict_type));
+
+        ColumnLowCardinality * col_as_lc = typeid_cast<ColumnLowCardinality *>(column.column->assumeMutable().get());
+        if (col_as_lc && col_as_lc->nestedIsNullable())
+            col_as_lc->nestedRemoveNullable();
+
+        return;
+    }
+
     if (!column.type->isNullable())
         return;
 
diff --git a/src/Interpreters/join_common.h b/src/Interpreters/join_common.h
index 9a000aa107af..9334b9d672fc 100644
--- a/src/Interpreters/join_common.h
+++ b/src/Interpreters/join_common.h
@@ -41,6 +41,8 @@ void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count);
 
 bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type);
 
+void changeLowCardinalityInplace(ColumnWithTypeAndName & column);
+
 }
 
 /// Creates result from right table data in RIGHT and FULL JOIN when keys are not present in left table.
