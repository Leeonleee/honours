{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56424,
  "instance_id": "ClickHouse__ClickHouse-56424",
  "issue_numbers": [
    "56344"
  ],
  "base_commit": "8fb594dd5eeff60e0ac0811d9c10e086bc5c7d13",
  "patch": "diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex eb963de0c352..e11f74cfef5d 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -2469,6 +2469,7 @@ This function is designed to load a NumPy array from a .npy file into ClickHouse\n | u2       |    UInt16       |\n | u4       |    UInt32       |\n | u8       |    UInt64       |\n+| f2       |    Float32      |\n | f4       |    Float32      |\n | f8       |    Float64      |\n | S        |    String       |\ndiff --git a/src/Formats/NumpyDataTypes.h b/src/Formats/NumpyDataTypes.h\nindex 43fd9064daea..712797515c9d 100644\n--- a/src/Formats/NumpyDataTypes.h\n+++ b/src/Formats/NumpyDataTypes.h\n@@ -17,6 +17,7 @@ enum class NumpyDataTypeIndex\n     UInt16,\n     UInt32,\n     UInt64,\n+    Float16,\n     Float32,\n     Float64,\n     String,\n@@ -79,6 +80,7 @@ class NumpyDataTypeFloat : public NumpyDataType\n     {\n         switch (size)\n         {\n+            case 2: type_index = NumpyDataTypeIndex::Float16; break;\n             case 4: type_index = NumpyDataTypeIndex::Float32; break;\n             case 8: type_index = NumpyDataTypeIndex::Float64; break;\n             default:\ndiff --git a/src/Processors/Formats/Impl/NpyRowInputFormat.cpp b/src/Processors/Formats/Impl/NpyRowInputFormat.cpp\nindex 9acb2909626d..1edf2438ab69 100644\n--- a/src/Processors/Formats/Impl/NpyRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/NpyRowInputFormat.cpp\n@@ -1,20 +1,16 @@\n+#include <cmath>\n #include <string>\n-#include <vector>\n #include <Processors/Formats/Impl/NpyRowInputFormat.h>\n #include <DataTypes/DataTypeString.h>\n-#include <Common/assert_cast.h>\n-#include <Common/Exception.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Formats/FormatFactory.h>\n-#include <Formats/NumpyDataTypes.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnsNumber.h>\n #include <DataTypes/IDataType.h>\n #include <IO/ReadBuffer.h>\n-#include <Processors/Formats/IRowInputFormat.h>\n #include <boost/algorithm/string/split.hpp>\n #include <IO/ReadBufferFromString.h>\n \n@@ -34,6 +30,46 @@ namespace ErrorCodes\n namespace\n {\n \n+float convertFloat16ToFloat32(uint16_t float16_value)\n+{\n+    uint16_t sign = (float16_value >> 15) & 0x1;\n+    uint16_t exponent = (float16_value >> 10) & 0x1F;\n+    uint16_t fraction = float16_value & 0x3FF;\n+\n+    if (exponent == 0 && fraction == 0)\n+    {\n+        uint32_t float32_value = sign << 31;\n+        return std::bit_cast<float>(float32_value);\n+    }\n+\n+    // Handling special cases for exponent\n+    if (exponent == 0x1F)\n+    {\n+        // NaN or Infinity in float16\n+        return (fraction == 0) ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::quiet_NaN();\n+    }\n+\n+    // Convert exponent from float16 to float32 format\n+    int32_t new_exponent = static_cast<int32_t>(exponent) - 15 + 127;\n+\n+    // Constructing the float32 representation\n+    uint32_t float32_value = (static_cast<uint32_t>(sign) << 31) |\n+                             (static_cast<uint32_t>(new_exponent) << 23) |\n+                             (static_cast<uint32_t>(fraction) << 13);\n+\n+    // Interpret the binary representation as a float\n+    float result;\n+    std::memcpy(&result, &float32_value, sizeof(float));\n+\n+    // Determine decimal places dynamically based on the magnitude of the number\n+    int decimal_places = std::max(0, 6 - static_cast<int>(std::log10(std::abs(result))));\n+    // Truncate the decimal part to the determined number of decimal places\n+    float multiplier = static_cast<float>(std::pow(10.0f, decimal_places));\n+    result = std::round(result * multiplier) / multiplier;\n+\n+    return result;\n+}\n+\n DataTypePtr getDataTypeFromNumpyType(const std::shared_ptr<NumpyDataType> & numpy_type)\n {\n     switch (numpy_type->getTypeIndex())\n@@ -54,6 +90,8 @@ DataTypePtr getDataTypeFromNumpyType(const std::shared_ptr<NumpyDataType> & nump\n             return std::make_shared<DataTypeUInt32>();\n         case NumpyDataTypeIndex::UInt64:\n             return std::make_shared<DataTypeUInt64>();\n+        case NumpyDataTypeIndex::Float16:\n+            return std::make_shared<DataTypeFloat32>();\n         case NumpyDataTypeIndex::Float32:\n             return std::make_shared<DataTypeFloat32>();\n         case NumpyDataTypeIndex::Float64:\n@@ -273,7 +311,18 @@ void NpyRowInputFormat::readBinaryValueAndInsert(MutableColumnPtr column, NumpyD\n         readBinaryBigEndian(value, *in);\n     else\n         readBinaryLittleEndian(value, *in);\n-    assert_cast<ColumnVector<ColumnValue> &>(*column).insertValue(static_cast<ColumnValue>(value));\n+    assert_cast<ColumnVector<ColumnValue> &>(*column).insertValue((static_cast<ColumnValue>(value)));\n+}\n+\n+template <typename ColumnValue>\n+void NpyRowInputFormat::readBinaryValueAndInsertFloat16(MutableColumnPtr column, NumpyDataType::Endianness endianness)\n+{\n+    uint16_t value;\n+    if (endianness == NumpyDataType::Endianness::BIG)\n+        readBinaryBigEndian(value, *in);\n+    else\n+        readBinaryLittleEndian(value, *in);\n+    assert_cast<ColumnVector<ColumnValue> &>(*column).insertValue(static_cast<ColumnValue>(convertFloat16ToFloat32(value)));\n }\n \n template <typename T>\n@@ -300,6 +349,7 @@ void NpyRowInputFormat::readAndInsertFloat(IColumn * column, const DataTypePtr &\n {\n     switch (npy_type.getTypeIndex())\n     {\n+        case NumpyDataTypeIndex::Float16: readBinaryValueAndInsertFloat16<T>(column->getPtr(), npy_type.getEndianness()); break;\n         case NumpyDataTypeIndex::Float32: readBinaryValueAndInsert<T, Float32>(column->getPtr(), npy_type.getEndianness()); break;\n         case NumpyDataTypeIndex::Float64: readBinaryValueAndInsert<T, Float64>(column->getPtr(), npy_type.getEndianness()); break;\n         default:\ndiff --git a/src/Processors/Formats/Impl/NpyRowInputFormat.h b/src/Processors/Formats/Impl/NpyRowInputFormat.h\nindex ad32bdba3bf2..358dac72f5a4 100644\n--- a/src/Processors/Formats/Impl/NpyRowInputFormat.h\n+++ b/src/Processors/Formats/Impl/NpyRowInputFormat.h\n@@ -45,6 +45,9 @@ class NpyRowInputFormat final : public IRowInputFormat\n     template <typename ColumnValue, typename DataValue>\n     void readBinaryValueAndInsert(MutableColumnPtr column, NumpyDataType::Endianness endianness);\n \n+    template <typename ColumnValue>\n+    void readBinaryValueAndInsertFloat16(MutableColumnPtr column, NumpyDataType::Endianness endianness);\n+\n     void readRows(MutableColumns & columns);\n \n     void readValue(IColumn * column);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02895_npy_format.reference b/tests/queries/0_stateless/02895_npy_format.reference\nindex 0c90fbfd418f..76c8a7a2abf4 100644\n--- a/tests/queries/0_stateless/02895_npy_format.reference\n+++ b/tests/queries/0_stateless/02895_npy_format.reference\n@@ -84,3 +84,8 @@ c\n 0\n 0\n 1\n+[2.199219,1.099609,3.300781]\n+[4.25,3.34961,6.628906]\n+inf\n+nan\n+0\ndiff --git a/tests/queries/0_stateless/02895_npy_format.sh b/tests/queries/0_stateless/02895_npy_format.sh\nindex 1dbf62ceaa23..c4fb2e2f67d2 100755\n--- a/tests/queries/0_stateless/02895_npy_format.sh\n+++ b/tests/queries/0_stateless/02895_npy_format.sh\n@@ -56,3 +56,7 @@ $CLICKHOUSE_LOCAL -q \"select * from file('$CURDIR/data_npy/one_dim_str.npy', Npy\n $CLICKHOUSE_LOCAL -q \"select * from file('$CURDIR/data_npy/one_dim_unicode.npy', Npy, 'value Float32')\" 2>&1 | grep -c \"BAD_ARGUMENTS\"\n \n $CLICKHOUSE_LOCAL -q \"select * from file('$CURDIR/data_npy/complex.npy')\" 2>&1 | grep -c \"BAD_ARGUMENTS\"\n+\n+$CLICKHOUSE_LOCAL -q \"select * from file('$CURDIR/data_npy/float_16.npy')\"\n+\n+$CLICKHOUSE_LOCAL -q \"select * from file('$CURDIR/data_npy/npy_inf_nan_null.npy')\"\ndiff --git a/tests/queries/0_stateless/data_npy/float_16.npy b/tests/queries/0_stateless/data_npy/float_16.npy\nnew file mode 100644\nindex 000000000000..3224d1e57e3e\nBinary files /dev/null and b/tests/queries/0_stateless/data_npy/float_16.npy differ\ndiff --git a/tests/queries/0_stateless/data_npy/npy_inf_nan_null.npy b/tests/queries/0_stateless/data_npy/npy_inf_nan_null.npy\nnew file mode 100644\nindex 000000000000..12ee359f6658\nBinary files /dev/null and b/tests/queries/0_stateless/data_npy/npy_inf_nan_null.npy differ\n",
  "problem_statement": "Npy format should support 16-bit float by converting it to Float32.\n**Use case**\r\n\r\n\r\nhttps://pastila.nl/?0e0eb514/37c1d09e8f925eb452046bf272119a78#J7MgyKpFZ5kjSFXSTwCZRQ==\r\n\r\n```\r\nwget --tries=100 https://deploy.laion.ai/8f83b608504d46bb81708ec86e912220/embeddings/img_emb/img_emb_1.npy\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2023-11-07T18:01:34Z",
  "modified_files": [
    "docs/en/interfaces/formats.md",
    "src/Formats/NumpyDataTypes.h",
    "src/Processors/Formats/Impl/NpyRowInputFormat.cpp",
    "src/Processors/Formats/Impl/NpyRowInputFormat.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02895_npy_format.reference",
    "tests/queries/0_stateless/02895_npy_format.sh"
  ]
}