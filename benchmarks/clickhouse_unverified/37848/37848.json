{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37848,
  "instance_id": "ClickHouse__ClickHouse-37848",
  "issue_numbers": [
    "19857"
  ],
  "base_commit": "7700c26076efc9c5087f9c74d6dceab7afb7a8e4",
  "patch": "diff --git a/docs/en/sql-reference/window-functions/index.md b/docs/en/sql-reference/window-functions/index.md\nindex d7f4a696476d..0a563cd6d66a 100644\n--- a/docs/en/sql-reference/window-functions/index.md\n+++ b/docs/en/sql-reference/window-functions/index.md\n@@ -10,7 +10,7 @@ ClickHouse supports the standard grammar for defining windows and window functio\n | Feature | Support or workaround |\n | --------| ----------|\n | ad hoc window specification (`count(*) over (partition by id order by time desc)`) | supported |\n-| expressions involving window functions, e.g. `(count(*) over ()) / 2)` | not supported, wrap in a subquery ([feature request](https://github.com/ClickHouse/ClickHouse/issues/19857)) |\n+| expressions involving window functions, e.g. `(count(*) over ()) / 2)` | supported |\n | `WINDOW` clause (`select ... from table window w as (partition by id)`) | supported |\n | `ROWS` frame | supported |\n | `RANGE` frame | supported, the default |\ndiff --git a/src/AggregateFunctions/AggregateFunctionFactory.h b/src/AggregateFunctions/AggregateFunctionFactory.h\nindex e5263a54d790..a860831cb881 100644\n--- a/src/AggregateFunctions/AggregateFunctionFactory.h\n+++ b/src/AggregateFunctions/AggregateFunctionFactory.h\n@@ -2,6 +2,7 @@\n \n #include <AggregateFunctions/IAggregateFunction.h>\n #include <Common/IFactoryWithAliases.h>\n+#include <Parsers/ASTFunction.h>\n \n \n #include <functional>\n@@ -105,4 +106,12 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto\n \n };\n \n+struct AggregateUtils\n+{\n+    static bool isAggregateFunction(const ASTFunction & node)\n+    {\n+        return AggregateFunctionFactory::instance().isAggregateFunctionName(node.name);\n+    }\n+};\n+\n }\ndiff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex f9d18cda777a..e25a6260787e 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -467,6 +467,15 @@ class ScopeStack::Index\n     }\n \n     bool contains(const std::string & name) const { return map.contains(name); }\n+\n+    std::vector<std::string_view> getAllNames() const\n+    {\n+        std::vector<std::string_view> result;\n+        result.reserve(map.size());\n+        for (auto const & e : map)\n+            result.emplace_back(e.first);\n+        return result;\n+    }\n };\n \n ActionsMatcher::Data::Data(\n@@ -481,7 +490,8 @@ ActionsMatcher::Data::Data(\n     bool no_makeset_,\n     bool only_consts_,\n     bool create_source_for_in_,\n-    AggregationKeysInfo aggregation_keys_info_)\n+    AggregationKeysInfo aggregation_keys_info_,\n+    bool build_expression_with_window_functions_)\n     : WithContext(context_)\n     , set_size_limit(set_size_limit_)\n     , subquery_depth(subquery_depth_)\n@@ -495,6 +505,7 @@ ActionsMatcher::Data::Data(\n     , visit_depth(0)\n     , actions_stack(std::move(actions_dag), context_)\n     , aggregation_keys_info(aggregation_keys_info_)\n+    , build_expression_with_window_functions(build_expression_with_window_functions_)\n     , next_unique_suffix(actions_stack.getLastActions().getIndex().size() + 1)\n {\n }\n@@ -504,6 +515,12 @@ bool ActionsMatcher::Data::hasColumn(const String & column_name) const\n     return actions_stack.getLastActionsIndex().contains(column_name);\n }\n \n+std::vector<std::string_view> ActionsMatcher::Data::getAllColumnNames() const\n+{\n+    const auto & index = actions_stack.getLastActionsIndex();\n+    return index.getAllNames();\n+}\n+\n ScopeStack::ScopeStack(ActionsDAGPtr actions_dag, ContextPtr context_) : WithContext(context_)\n {\n     auto & level = stack.emplace_back();\n@@ -803,8 +820,9 @@ void ActionsMatcher::visit(const ASTIdentifier & identifier, const ASTPtr &, Dat\n         {\n             if (column_name_type.name == column_name)\n             {\n-                throw Exception(\"Column \" + backQuote(column_name) + \" is not under aggregate function and not in GROUP BY\",\n-                                ErrorCodes::NOT_AN_AGGREGATE);\n+                throw Exception(ErrorCodes::NOT_AN_AGGREGATE,\n+                    \"Column {} is not under aggregate function and not in GROUP BY. Have columns: {}\",\n+                    backQuote(column_name), toString(data.getAllColumnNames()));\n             }\n         }\n \n@@ -921,6 +939,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         return;\n     }\n \n+    // Now we need to correctly process window functions and any expression which depend on them.\n     if (node.is_window_function)\n     {\n         // Also add columns from PARTITION BY and ORDER BY of window functions.\n@@ -928,7 +947,6 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         {\n             visit(node.window_definition, data);\n         }\n-\n         // Also manually add columns for arguments of the window function itself.\n         // ActionVisitor is written in such a way that this method must itself\n         // descend into all needed function children. Window functions can't have\n@@ -945,12 +963,45 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         // Don't need to do anything more for window functions here -- the\n         // resulting column is added in ExpressionAnalyzer, similar to the\n         // aggregate functions.\n+        if (data.window_dependancy_state == WindowDependancyState::MAY_DEPEND)\n+            data.window_function_in_subtree = true;\n         return;\n     }\n+    else if (node.compute_after_window_functions)\n+    {\n+        // In this case we have window function call in subtree\n+        // Add this function to actions index only if Data::build_expression_with_window_functions is set.\n+        data.window_dependancy_state = WindowDependancyState::MAY_DEPEND;\n+        for (const auto & arg : node.arguments->children)\n+        {\n+            data.window_function_in_subtree = false;\n+            visit(arg, data);\n+            // There is no point to check value of window_function_in_subtree here,\n+            // because after window functions are computed, this variable is always false.\n+        }\n+        data.window_dependancy_state = WindowDependancyState::NONE;\n+        if (!data.build_expression_with_window_functions)\n+            return;\n+    }\n+    else if (data.window_dependancy_state == WindowDependancyState::MAY_DEPEND)\n+    {\n+        // This function may depend on evaluation of window function.\n+        // We need to check it and add it to the index only if Data::build_expression_with_window_functions is set.\n+        bool subtree_contains_window_call = false;\n+        for (const auto & arg : node.arguments->children)\n+        {\n+            data.window_function_in_subtree = false;\n+            visit(arg, data);\n+            subtree_contains_window_call = subtree_contains_window_call || data.window_function_in_subtree;\n+        }\n+        data.window_function_in_subtree = subtree_contains_window_call;\n+        if (subtree_contains_window_call && !data.build_expression_with_window_functions)\n+            return;\n+    }\n \n     // An aggregate function can also be calculated as a window function, but we\n     // checked for it above, so no need to do anything more.\n-    if (AggregateFunctionFactory::instance().isAggregateFunctionName(node.name))\n+    if (AggregateUtils::isAggregateFunction(node))\n         return;\n \n     FunctionOverloadResolverPtr function_builder;\ndiff --git a/src/Interpreters/ActionsVisitor.h b/src/Interpreters/ActionsVisitor.h\nindex 5a74124192c2..afdf2948d473 100644\n--- a/src/Interpreters/ActionsVisitor.h\n+++ b/src/Interpreters/ActionsVisitor.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <string_view>\n #include <Core/NamesAndTypes.h>\n #include <Interpreters/Context_fwd.h>\n #include <Interpreters/InDepthNodeVisitor.h>\n@@ -120,6 +121,12 @@ class ActionsMatcher\n public:\n     using Visitor = ConstInDepthNodeVisitor<ActionsMatcher, true>;\n \n+    enum class WindowDependancyState\n+    {\n+        NONE,\n+        MAY_DEPEND,\n+    };\n+\n     struct Data : public WithContext\n     {\n         SizeLimits set_size_limit;\n@@ -134,6 +141,7 @@ class ActionsMatcher\n         size_t visit_depth;\n         ScopeStack actions_stack;\n         AggregationKeysInfo aggregation_keys_info;\n+        bool build_expression_with_window_functions;\n \n         /*\n          * Remember the last unique column suffix to avoid quadratic behavior\n@@ -142,6 +150,9 @@ class ActionsMatcher\n          */\n         int next_unique_suffix;\n \n+        WindowDependancyState window_dependancy_state = WindowDependancyState::NONE;\n+        bool window_function_in_subtree = false;\n+\n         Data(\n             ContextPtr context_,\n             SizeLimits set_size_limit_,\n@@ -154,10 +165,13 @@ class ActionsMatcher\n             bool no_makeset_,\n             bool only_consts_,\n             bool create_source_for_in_,\n-            AggregationKeysInfo aggregation_keys_info_);\n+            AggregationKeysInfo aggregation_keys_info_,\n+            bool build_expression_with_window_functions_ = false);\n \n         /// Does result of the calculation already exists in the block.\n         bool hasColumn(const String & column_name) const;\n+        std::vector<std::string_view> getAllColumnNames() const;\n+\n         void addColumn(ColumnWithTypeAndName column)\n         {\n             actions_stack.addColumn(std::move(column));\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 00333503db1e..cfe1167c36ce 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -137,7 +137,7 @@ bool checkPositionalArguments(ASTPtr & argument, const ASTSelectQuery * select_q\n         {\n             if (const auto * function = typeid_cast<const ASTFunction *>(node.get()))\n             {\n-                auto is_aggregate_function = AggregateFunctionFactory::instance().isAggregateFunctionName(function->name);\n+                auto is_aggregate_function = AggregateUtils::isAggregateFunction(*function);\n                 if (is_aggregate_function)\n                 {\n                     throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n@@ -659,6 +659,28 @@ void ExpressionAnalyzer::getRootActionsForHaving(\n }\n \n \n+void ExpressionAnalyzer::getRootActionsForWindowFunctions(const ASTPtr & ast, bool no_makeset_for_subqueries, ActionsDAGPtr & actions)\n+{\n+    LogAST log;\n+    ActionsVisitor::Data visitor_data(\n+        getContext(),\n+        settings.size_limits_for_set,\n+        subquery_depth,\n+        sourceColumns(),\n+        std::move(actions),\n+        prepared_sets,\n+        subqueries_for_sets,\n+        no_makeset_for_subqueries,\n+        false /* no_makeset */,\n+        false /*only_consts */,\n+        !isRemoteStorage() /* create_source_for_in */,\n+        getAggregationKeysInfo(),\n+        true);\n+    ActionsVisitor(visitor_data, log.stream()).visit(ast);\n+    actions = visitor_data.getActions();\n+}\n+\n+\n void ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions, AggregateDescriptions & descriptions)\n {\n     for (const ASTFunction * node : aggregates())\n@@ -895,7 +917,6 @@ void ExpressionAnalyzer::makeWindowDescriptions(ActionsDAGPtr actions)\n                 window_function.argument_types,\n                 window_function.function_parameters, properties);\n \n-\n         // Find the window corresponding to this function. It may be either\n         // referenced by name and previously defined in WINDOW clause, or it\n         // may be defined inline.\n@@ -1388,6 +1409,15 @@ void SelectQueryExpressionAnalyzer::appendWindowFunctionsArguments(\n     }\n }\n \n+void SelectQueryExpressionAnalyzer::appendExpressionsAfterWindowFunctions(ExpressionActionsChain & chain, bool /* only_types */)\n+{\n+    ExpressionActionsChain::Step & step = chain.lastStep(columns_after_window);\n+    for (const auto & expression : syntax->expressions_with_window_function)\n+    {\n+        getRootActionsForWindowFunctions(expression->clone(), true, step.actions());\n+    }\n+}\n+\n bool SelectQueryExpressionAnalyzer::appendHaving(ExpressionActionsChain & chain, bool only_types)\n {\n     const auto * select_query = getAggregatingQuery();\n@@ -1415,7 +1445,7 @@ void SelectQueryExpressionAnalyzer::appendSelect(ExpressionActionsChain & chain,\n     {\n         if (const auto * function = typeid_cast<const ASTFunction *>(child.get());\n             function\n-            && function->is_window_function)\n+            && (function->is_window_function || function->compute_after_window_functions))\n         {\n             // Skip window function columns here -- they are calculated after\n             // other SELECT expressions by a special step.\n@@ -1891,6 +1921,12 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n             before_window = chain.getLastActions();\n             finalize_chain(chain);\n \n+            query_analyzer.appendExpressionsAfterWindowFunctions(chain, only_types || !first_stage);\n+            for (const auto & x : chain.getLastActions()->getNamesAndTypesList())\n+            {\n+                query_analyzer.columns_after_window.push_back(x);\n+            }\n+\n             auto & step = chain.lastStep(query_analyzer.columns_after_window);\n \n             // The output of this expression chain is the result of\ndiff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex 80c664832e52..6c27d8c6760c 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -191,6 +191,8 @@ class ExpressionAnalyzer : protected ExpressionAnalyzerData, private boost::nonc\n \n     void getRootActionsForHaving(const ASTPtr & ast, bool no_makeset_for_subqueries, ActionsDAGPtr & actions, bool only_consts = false);\n \n+    void getRootActionsForWindowFunctions(const ASTPtr & ast, bool no_makeset_for_subqueries, ActionsDAGPtr & actions);\n+\n     /** Add aggregation keys to aggregation_keys, aggregate functions to aggregate_descriptions,\n       * Create a set of columns aggregated_columns resulting after the aggregation, if any,\n       *  or after all the actions that are normally performed before aggregation.\n@@ -406,6 +408,8 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n     void appendAggregateFunctionsArguments(ExpressionActionsChain & chain, bool only_types);\n     void appendWindowFunctionsArguments(ExpressionActionsChain & chain, bool only_types);\n \n+    void appendExpressionsAfterWindowFunctions(ExpressionActionsChain & chain, bool only_types);\n+\n     /// After aggregation:\n     bool appendHaving(ExpressionActionsChain & chain, bool only_types);\n     ///  appendSelect\ndiff --git a/src/Interpreters/GetAggregatesVisitor.cpp b/src/Interpreters/GetAggregatesVisitor.cpp\nnew file mode 100644\nindex 000000000000..a9d96a6d15a4\n--- /dev/null\n+++ b/src/Interpreters/GetAggregatesVisitor.cpp\n@@ -0,0 +1,90 @@\n+#include <Interpreters/GetAggregatesVisitor.h>\n+\n+namespace DB\n+{\n+\n+struct WindowExpressionsCollectorChildInfo\n+{\n+    void update(const WindowExpressionsCollectorChildInfo & other)\n+    {\n+        window_function_in_subtree = window_function_in_subtree || other.window_function_in_subtree;\n+    }\n+\n+    bool window_function_in_subtree = false;\n+};\n+\n+// This visitor travers AST and collects the list of expressions which depend on\n+// evaluation of window functions. Expression is collected only if\n+// it's not a part of another expression.\n+//\n+// Also all collected AST nodes are marked as dependent on window function.\n+// This information is used during ActionsDAG building process.\n+struct WindowExpressionsCollectorMatcher\n+{\n+    using ChildInfo = WindowExpressionsCollectorChildInfo;\n+\n+    static bool needVisitChild(ASTPtr & node, const ASTPtr & child)\n+    {\n+        if (child->as<ASTSubquery>() || child->as<ASTSelectQuery>())\n+            return false;\n+        if (auto * select = node->as<ASTSelectQuery>())\n+        {\n+            // We don't analysis WITH statement because it might contain useless aggregates\n+            if (child == select->with())\n+                return false;\n+        }\n+        // We procces every expression manually\n+        if (auto * func = node->as<ASTFunction>())\n+            return false;\n+        return true;\n+    }\n+\n+    WindowExpressionsCollectorChildInfo visitNode(\n+        ASTPtr & ast,\n+        const ASTPtr & parent,\n+        WindowExpressionsCollectorChildInfo const &)\n+    {\n+        return visitNode(ast, parent);\n+    }\n+\n+    WindowExpressionsCollectorChildInfo visitNode(\n+        ASTPtr & ast,\n+        const ASTPtr & parent)\n+    {\n+        if (auto * func = ast->as<ASTFunction>())\n+        {\n+            if (func->is_window_function)\n+                return { .window_function_in_subtree = true };\n+\n+            WindowExpressionsCollectorChildInfo result;\n+            for (auto & arg : func->arguments->children)\n+            {\n+                auto subtree_result = visitNode(arg, ast);\n+                result.update(subtree_result);\n+            }\n+\n+            // We mark functions only on the top of AST\n+            if ((!parent || !parent->as<ASTFunction>()) && result.window_function_in_subtree)\n+            {\n+                expressions_with_window_functions.push_back(func);\n+                func->compute_after_window_functions = true;\n+            }\n+\n+            return result;\n+        }\n+        return {};\n+    }\n+\n+    std::vector<const ASTFunction *> expressions_with_window_functions {};\n+};\n+\n+using WindowExpressionsCollectorVisitor = InDepthNodeVisitorWithChildInfo<WindowExpressionsCollectorMatcher>;\n+\n+std::vector<const ASTFunction *> getExpressionsWithWindowFunctions(ASTPtr & ast)\n+{\n+    WindowExpressionsCollectorVisitor visitor;\n+    visitor.visit(ast);\n+    return std::move(visitor.expressions_with_window_functions);\n+}\n+\n+}\ndiff --git a/src/Interpreters/GetAggregatesVisitor.h b/src/Interpreters/GetAggregatesVisitor.h\nindex 3966653235aa..036d50ba4d61 100644\n--- a/src/Interpreters/GetAggregatesVisitor.h\n+++ b/src/Interpreters/GetAggregatesVisitor.h\n@@ -95,9 +95,7 @@ class GetAggregatesMatcher\n     {\n         // Aggregate functions can also be calculated as window functions, but\n         // here we are interested in aggregate functions calculated in GROUP BY.\n-        return !node.is_window_function\n-            && AggregateFunctionFactory::instance().isAggregateFunctionName(\n-                node.name);\n+        return !node.is_window_function && AggregateUtils::isAggregateFunction(node);\n     }\n };\n \n@@ -116,4 +114,6 @@ inline void assertNoAggregates(const ASTPtr & ast, const char * description)\n     GetAggregatesVisitor(data).visit(ast);\n }\n \n+std::vector<const ASTFunction *> getExpressionsWithWindowFunctions(ASTPtr & ast);\n+\n }\ndiff --git a/src/Interpreters/InDepthNodeVisitor.h b/src/Interpreters/InDepthNodeVisitor.h\nindex b7353f2c2431..736a764e8e93 100644\n--- a/src/Interpreters/InDepthNodeVisitor.h\n+++ b/src/Interpreters/InDepthNodeVisitor.h\n@@ -95,4 +95,33 @@ class OneTypeMatcher\n template <typename Data, NeedChild::Condition need_child = NeedChild::all>\n using ConstOneTypeMatcher = OneTypeMatcher<Data, need_child, const ASTPtr>;\n \n+template <typename Visitor, typename T = ASTPtr>\n+struct InDepthNodeVisitorWithChildInfo : Visitor\n+{\n+    using ChildInfo = typename Visitor::ChildInfo;\n+\n+    ChildInfo visit(T & ast, const T & parent = {})\n+    {\n+        ChildInfo all_children_info;\n+        for (auto & child : ast->children)\n+        {\n+            if (Visitor::needVisitChild(ast, child))\n+            {\n+                ChildInfo child_info = visit(child, ast);\n+                all_children_info.update(child_info);\n+            }\n+        }\n+\n+        try\n+        {\n+            return Visitor::visitNode(ast, parent, all_children_info);\n+        }\n+        catch (Exception & e)\n+        {\n+            e.addMessage(\"While processing {}\", ast->formatForErrorMessage());\n+            throw;\n+        }\n+    }\n+};\n+\n }\ndiff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex 241ab1b0f759..4ed293e85304 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -162,7 +162,7 @@ Block InterpreterInsertQuery::getSampleBlock(\n static bool hasAggregateFunctions(const IAST * ast)\n {\n     if (const auto * func = typeid_cast<const ASTFunction *>(ast))\n-        if (AggregateFunctionFactory::instance().isAggregateFunctionName(func->name))\n+        if (AggregateUtils::isAggregateFunction(*func))\n             return true;\n \n     for (const auto & child : ast->children)\ndiff --git a/src/Interpreters/MonotonicityCheckVisitor.h b/src/Interpreters/MonotonicityCheckVisitor.h\nindex 00347388de20..4b9f36ab72dd 100644\n--- a/src/Interpreters/MonotonicityCheckVisitor.h\n+++ b/src/Interpreters/MonotonicityCheckVisitor.h\n@@ -47,8 +47,7 @@ class MonotonicityCheckMatcher\n             /// if ORDER BY contains aggregate function or window functions, it\n             /// shouldn't be optimized\n             if (ast_function.is_window_function\n-                || AggregateFunctionFactory::instance().isAggregateFunctionName(\n-                    ast_function.name))\n+                || AggregateUtils::isAggregateFunction(ast_function))\n             {\n                 return false;\n             }\ndiff --git a/src/Interpreters/RewriteAnyFunctionVisitor.cpp b/src/Interpreters/RewriteAnyFunctionVisitor.cpp\nindex 33362648ae18..163e117f93d1 100644\n--- a/src/Interpreters/RewriteAnyFunctionVisitor.cpp\n+++ b/src/Interpreters/RewriteAnyFunctionVisitor.cpp\n@@ -41,8 +41,7 @@ bool extractIdentifiers(const ASTFunction & func, std::unordered_set<ASTPtr *> &\n             // be inside `any`, but this check in GetAggregatesMatcher happens\n             // later, so we have to explicitly skip these nested functions here.\n             if (arg_func->is_window_function\n-                || AggregateFunctionFactory::instance().isAggregateFunctionName(\n-                    arg_func->name))\n+                || AggregateUtils::isAggregateFunction(*arg_func))\n             {\n                 return false;\n             }\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 70aa859e741f..3d14955c16a6 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -511,7 +511,7 @@ void removeUnneededColumnsFromSelectClause(ASTSelectQuery * select_query, const\n                 new_elements.push_back(elem);\n \n             /// removing aggregation can change number of rows, so `count()` result in outer sub-query would be wrong\n-            if (func && AggregateFunctionFactory::instance().isAggregateFunctionName(func->name) && !select_query->groupBy())\n+            if (func && AggregateUtils::isAggregateFunction(*func) && !select_query->groupBy())\n                 new_elements.push_back(elem);\n         }\n     }\n@@ -1248,6 +1248,7 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n \n     result.aggregates = getAggregates(query, *select_query);\n     result.window_function_asts = getWindowFunctions(query, *select_query);\n+    result.expressions_with_window_function = getExpressionsWithWindowFunctions(query);\n     result.collectUsedColumns(query, true);\n     result.required_source_columns_before_expanding_alias_columns = result.required_source_columns.getNames();\n \n@@ -1271,6 +1272,7 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n         {\n             result.aggregates = getAggregates(query, *select_query);\n             result.window_function_asts = getWindowFunctions(query, *select_query);\n+            result.expressions_with_window_function = getExpressionsWithWindowFunctions(query);\n             result.collectUsedColumns(query, true);\n         }\n     }\ndiff --git a/src/Interpreters/TreeRewriter.h b/src/Interpreters/TreeRewriter.h\nindex 2c246455ade7..f9d8d2bfdd6a 100644\n--- a/src/Interpreters/TreeRewriter.h\n+++ b/src/Interpreters/TreeRewriter.h\n@@ -44,6 +44,8 @@ struct TreeRewriterResult\n \n     std::vector<const ASTFunction *> window_function_asts;\n \n+    std::vector<const ASTFunction *> expressions_with_window_function;\n+\n     /// Which column is needed to be ARRAY-JOIN'ed to get the specified.\n     /// For example, for `SELECT s.v ... ARRAY JOIN a AS s` will get \"s.v\" -> \"a.v\".\n     NameToNameMap array_join_result_to_source;\ndiff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp\nindex b86929b054c0..69927c430dc7 100644\n--- a/src/Parsers/ASTFunction.cpp\n+++ b/src/Parsers/ASTFunction.cpp\n@@ -89,6 +89,24 @@ void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr) const\n     }\n }\n \n+void ASTFunction::finishFormatWithWindow(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+{\n+    if (!is_window_function)\n+        return;\n+\n+    settings.ostr << \" OVER \";\n+    if (!window_name.empty())\n+    {\n+        settings.ostr << backQuoteIfNeed(window_name);\n+    }\n+    else\n+    {\n+        settings.ostr << \"(\";\n+        window_definition->formatImpl(settings, state, frame);\n+        settings.ostr << \")\";\n+    }\n+}\n+\n /** Get the text that identifies this element. */\n String ASTFunction::getID(char delim) const\n {\n@@ -563,7 +581,7 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n \n     if (written)\n     {\n-        return;\n+        return finishFormatWithWindow(settings, state, frame);\n     }\n \n     settings.ostr << (settings.hilite ? hilite_function : \"\") << name;\n@@ -603,22 +621,7 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n \n     settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n-    if (!is_window_function)\n-    {\n-        return;\n-    }\n-\n-    settings.ostr << \" OVER \";\n-    if (!window_name.empty())\n-    {\n-        settings.ostr << backQuoteIfNeed(window_name);\n-    }\n-    else\n-    {\n-        settings.ostr << \"(\";\n-        window_definition->formatImpl(settings, state, frame);\n-        settings.ostr << \")\";\n-    }\n+    return finishFormatWithWindow(settings, state, frame);\n }\n \n String getFunctionName(const IAST * ast)\ndiff --git a/src/Parsers/ASTFunction.h b/src/Parsers/ASTFunction.h\nindex 6efbe512cf41..6d5089f802e3 100644\n--- a/src/Parsers/ASTFunction.h\n+++ b/src/Parsers/ASTFunction.h\n@@ -22,6 +22,8 @@ class ASTFunction : public ASTWithAlias\n \n     bool is_window_function = false;\n \n+    bool compute_after_window_functions = false;\n+\n     // We have to make these fields ASTPtr because this is what the visitors\n     // expect. Some of them take const ASTPtr & (makes no sense), and some\n     // take ASTPtr & and modify it. I don't understand how the latter is\n@@ -54,6 +56,8 @@ class ASTFunction : public ASTWithAlias\n protected:\n     void formatImplWithoutAlias(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n     void appendColumnNameImpl(WriteBuffer & ostr) const override;\n+private:\n+    void finishFormatWithWindow(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const;\n };\n \n \ndiff --git a/src/Storages/TTLDescription.cpp b/src/Storages/TTLDescription.cpp\nindex b745da134848..41c9c1996b13 100644\n--- a/src/Storages/TTLDescription.cpp\n+++ b/src/Storages/TTLDescription.cpp\n@@ -92,7 +92,7 @@ class FindAggregateFunctionData\n     {\n         /// Do not throw if found aggregate function inside another aggregate function,\n         /// because it will be checked, while creating expressions.\n-        if (AggregateFunctionFactory::instance().isAggregateFunctionName(func.name))\n+        if (AggregateUtils::isAggregateFunction(func))\n             has_aggregate_function = true;\n     }\n };\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01591_window_functions.reference b/tests/queries/0_stateless/01591_window_functions.reference\nindex 0f21ba9b99ca..aaa88d66ca09 100644\n--- a/tests/queries/0_stateless/01591_window_functions.reference\n+++ b/tests/queries/0_stateless/01591_window_functions.reference\n@@ -62,9 +62,18 @@ select number, quantileExact(number) over (partition by intDiv(number, 3) AS val\n 7\t7\n 8\t7\n 9\t9\n--- can't reference it yet -- the window functions are calculated at the\n--- last stage of select, after all other functions.\n-select q * 10, quantileExact(number) over (partition by intDiv(number, 3) rows unbounded preceding) q from numbers(10); -- { serverError 47 }\n+-- now we should be able to compute expressions with window functions\n+select number, q * 10, quantileExact(number) over (partition by intDiv(number, 3) order by number rows unbounded preceding) q from numbers(10) order by number;\n+0\t0\t0\n+1\t10\t1\n+2\t10\t1\n+3\t30\t3\n+4\t40\t4\n+5\t40\t4\n+6\t60\t6\n+7\t70\t7\n+8\t70\t7\n+9\t90\t9\n -- must work in WHERE if you wrap it in a subquery\n select * from (select count(*) over (rows unbounded preceding) c from numbers(3)) where c > 0;\n 1\ndiff --git a/tests/queries/0_stateless/01591_window_functions.sql b/tests/queries/0_stateless/01591_window_functions.sql\nindex 31cfa181f9c7..3f4a028eac2a 100644\n--- a/tests/queries/0_stateless/01591_window_functions.sql\n+++ b/tests/queries/0_stateless/01591_window_functions.sql\n@@ -20,9 +20,8 @@ select number, quantileExact(number) over (partition by intDiv(number, 3) AS val\n -- can add an alias after window spec\n select number, quantileExact(number) over (partition by intDiv(number, 3) AS value order by number rows unbounded preceding) q from numbers(10);\n \n--- can't reference it yet -- the window functions are calculated at the\n--- last stage of select, after all other functions.\n-select q * 10, quantileExact(number) over (partition by intDiv(number, 3) rows unbounded preceding) q from numbers(10); -- { serverError 47 }\n+-- now we should be able to compute expressions with window functions\n+select number, q * 10, quantileExact(number) over (partition by intDiv(number, 3) order by number rows unbounded preceding) q from numbers(10) order by number;\n \n -- must work in WHERE if you wrap it in a subquery\n select * from (select count(*) over (rows unbounded preceding) c from numbers(3)) where c > 0;\ndiff --git a/tests/queries/0_stateless/02316_expressions_with_window_functions.reference b/tests/queries/0_stateless/02316_expressions_with_window_functions.reference\nnew file mode 100644\nindex 000000000000..2560e90408c3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02316_expressions_with_window_functions.reference\n@@ -0,0 +1,254 @@\n+-- { echoOn }\n+-- SELECT number, sum(number) + 1 OVER (PARTITION BY (number % 10))\n+-- FROM numbers(100)\n+-- ORDER BY number; -- { clientError SYNTAX_ERROR }\n+\n+SELECT number, 1 + sum(number) OVER (PARTITION BY number % 10)\n+FROM numbers(100)\n+ORDER BY number;\n+0\t451\n+1\t461\n+2\t471\n+3\t481\n+4\t491\n+5\t501\n+6\t511\n+7\t521\n+8\t531\n+9\t541\n+10\t451\n+11\t461\n+12\t471\n+13\t481\n+14\t491\n+15\t501\n+16\t511\n+17\t521\n+18\t531\n+19\t541\n+20\t451\n+21\t461\n+22\t471\n+23\t481\n+24\t491\n+25\t501\n+26\t511\n+27\t521\n+28\t531\n+29\t541\n+30\t451\n+31\t461\n+32\t471\n+33\t481\n+34\t491\n+35\t501\n+36\t511\n+37\t521\n+38\t531\n+39\t541\n+40\t451\n+41\t461\n+42\t471\n+43\t481\n+44\t491\n+45\t501\n+46\t511\n+47\t521\n+48\t531\n+49\t541\n+50\t451\n+51\t461\n+52\t471\n+53\t481\n+54\t491\n+55\t501\n+56\t511\n+57\t521\n+58\t531\n+59\t541\n+60\t451\n+61\t461\n+62\t471\n+63\t481\n+64\t491\n+65\t501\n+66\t511\n+67\t521\n+68\t531\n+69\t541\n+70\t451\n+71\t461\n+72\t471\n+73\t481\n+74\t491\n+75\t501\n+76\t511\n+77\t521\n+78\t531\n+79\t541\n+80\t451\n+81\t461\n+82\t471\n+83\t481\n+84\t491\n+85\t501\n+86\t511\n+87\t521\n+88\t531\n+89\t541\n+90\t451\n+91\t461\n+92\t471\n+93\t481\n+94\t491\n+95\t501\n+96\t511\n+97\t521\n+98\t531\n+99\t541\n+SELECT sum(number) + 1 AS x\n+FROM numbers(100)\n+GROUP BY number % 10\n+ORDER BY x;\n+451\n+461\n+471\n+481\n+491\n+501\n+511\n+521\n+531\n+541\n+SELECT\n+    number,\n+    sum(number) OVER (PARTITION BY number % 10) / count() OVER (PARTITION BY number % 10),\n+    avg(number) OVER (PARTITION BY number % 10)\n+FROM numbers(100)\n+ORDER BY number ASC;\n+0\t45\t45\n+1\t46\t46\n+2\t47\t47\n+3\t48\t48\n+4\t49\t49\n+5\t50\t50\n+6\t51\t51\n+7\t52\t52\n+8\t53\t53\n+9\t54\t54\n+10\t45\t45\n+11\t46\t46\n+12\t47\t47\n+13\t48\t48\n+14\t49\t49\n+15\t50\t50\n+16\t51\t51\n+17\t52\t52\n+18\t53\t53\n+19\t54\t54\n+20\t45\t45\n+21\t46\t46\n+22\t47\t47\n+23\t48\t48\n+24\t49\t49\n+25\t50\t50\n+26\t51\t51\n+27\t52\t52\n+28\t53\t53\n+29\t54\t54\n+30\t45\t45\n+31\t46\t46\n+32\t47\t47\n+33\t48\t48\n+34\t49\t49\n+35\t50\t50\n+36\t51\t51\n+37\t52\t52\n+38\t53\t53\n+39\t54\t54\n+40\t45\t45\n+41\t46\t46\n+42\t47\t47\n+43\t48\t48\n+44\t49\t49\n+45\t50\t50\n+46\t51\t51\n+47\t52\t52\n+48\t53\t53\n+49\t54\t54\n+50\t45\t45\n+51\t46\t46\n+52\t47\t47\n+53\t48\t48\n+54\t49\t49\n+55\t50\t50\n+56\t51\t51\n+57\t52\t52\n+58\t53\t53\n+59\t54\t54\n+60\t45\t45\n+61\t46\t46\n+62\t47\t47\n+63\t48\t48\n+64\t49\t49\n+65\t50\t50\n+66\t51\t51\n+67\t52\t52\n+68\t53\t53\n+69\t54\t54\n+70\t45\t45\n+71\t46\t46\n+72\t47\t47\n+73\t48\t48\n+74\t49\t49\n+75\t50\t50\n+76\t51\t51\n+77\t52\t52\n+78\t53\t53\n+79\t54\t54\n+80\t45\t45\n+81\t46\t46\n+82\t47\t47\n+83\t48\t48\n+84\t49\t49\n+85\t50\t50\n+86\t51\t51\n+87\t52\t52\n+88\t53\t53\n+89\t54\t54\n+90\t45\t45\n+91\t46\t46\n+92\t47\t47\n+93\t48\t48\n+94\t49\t49\n+95\t50\t50\n+96\t51\t51\n+97\t52\t52\n+98\t53\t53\n+99\t54\t54\n+SELECT sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10))\n+FROM numbers(10000)\n+GROUP BY number % 10;\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+SELECT 1 + sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10))\n+FROM numbers(10000)\n+GROUP BY number % 10;\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\ndiff --git a/tests/queries/0_stateless/02316_expressions_with_window_functions.sql b/tests/queries/0_stateless/02316_expressions_with_window_functions.sql\nnew file mode 100644\nindex 000000000000..c3137ef37465\n--- /dev/null\n+++ b/tests/queries/0_stateless/02316_expressions_with_window_functions.sql\n@@ -0,0 +1,28 @@\n+-- { echoOn }\n+-- SELECT number, sum(number) + 1 OVER (PARTITION BY (number % 10))\n+-- FROM numbers(100)\n+-- ORDER BY number; -- { clientError SYNTAX_ERROR }\n+\n+SELECT number, 1 + sum(number) OVER (PARTITION BY number % 10)\n+FROM numbers(100)\n+ORDER BY number;\n+\n+SELECT sum(number) + 1 AS x\n+FROM numbers(100)\n+GROUP BY number % 10\n+ORDER BY x;\n+\n+SELECT\n+    number,\n+    sum(number) OVER (PARTITION BY number % 10) / count() OVER (PARTITION BY number % 10),\n+    avg(number) OVER (PARTITION BY number % 10)\n+FROM numbers(100)\n+ORDER BY number ASC;\n+\n+SELECT sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10))\n+FROM numbers(10000)\n+GROUP BY number % 10;\n+\n+SELECT 1 + sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10))\n+FROM numbers(10000)\n+GROUP BY number % 10;\n",
  "problem_statement": "SUM(col) / SUM(SUM(col)) OVER (PARTITION BY col2) aggregate function over WINDOW is not supported.\n\r\n**How to reproduce**\r\n\r\n```\r\nSELECT sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10))\r\nFROM numbers(10000)\r\nGROUP BY number % 10\r\n\r\nQuery id: 76ed1093-b378-45c2-b644-1de44783734a\r\n\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n\r\nReceived exception from server (version 21.2.1):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown identifier: sum(sum(number)) OVER (PARTITION BY number % 10) there are columns: modulo(number, 10), sum(number): While processing sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10)).\r\n\r\n\r\n\r\npostgres=# SELECT sum(generate_series) / sum(sum(generate_series))  OVER (PARTITION BY (generate_series % 10)) FROM generate_series(0,10000) GROUP BY generate_series % 10;\r\n        ?column?\r\n------------------------\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n 1.00000000000000000000\r\n(10 rows)\r\n\r\n**Expected behavior**\r\nQuery works\n",
  "hints_text": "This is expected for now -- the window functions are processed at the latest stage of the query execution, so we can't calculate any expressions with them, and have to use a subselect.\r\nProper support for this will be complicated: we'll have to account for window functions in `ActionsDAG`, then split it into alternating `WindowStep` and `ExpressionStep` instances.\nNot actively working on this ATM.\nBy the way, it is going to be simpler to implement than I tought. Window functions can't be inside other window functions, so we can always topo-sort the execution graph into three parts:\r\n\r\n1. Base expressions w/o window functions\r\n2. Window functions that reference the base expressions\r\n3. Expressions that reference window functions\r\n\r\nThis means we'll need at most ExpressionStep + WindowStep + ExpressionStep.\nI need this :wink: \nI want this too! \ud83e\udd24 We used this pattern all the time at FB. \nHi, is this feature being worked on? Is it in the roadmap somewhere? Window functions are amazing otherwise :-)\nSo where is the hard part, I am very eager to use this new feature Otherwise I need to parse out the subquery\n@novikd is doing this task.\nThanks @den-crane.\r\n@novikd can you please update when this fix is going to be fixed? \r\nmost of our queries use window function on a complex way on postgres and if this fix is not going to happen maybe I need to postpone the migration to CH.\nIs there a work-around for now?\r\nI saw someone mentioned subquery, but what's the subquery version of this one\ud83d\udc47?\r\n\r\n```sql\r\nSELECT sum(number) / sum(sum(number)) OVER (PARTITION BY (number % 10))\r\nFROM numbers(10000)\r\nGROUP BY number % 10\r\n``` \nOnce done, this should also enable some interesting performance boosts, I would expect, based on the availability of short circuit function evaluation. Am I right on this?\r\n\r\nImagine that we have a table containing two harmonized sources, a big one (let's call it web_traffic) and a small one (transactions).\r\n\r\nThanks to short circuiting, will this sample query perform more efficiently once it's syntactically doable in ClickHouse?\r\n\r\n```\r\nselect\r\ncustomer_id,\r\ncase\r\n        when source = 'web_traffic' then toDate('1970-01-01')\r\n        when source = 'transactions' then max(date) over (partition by customer_id)\r\n        else toDate('1970-01-01')\r\nend as last_transaction_date\r\nfrom mytdb.mytable\r\n```\r\nCurrently, one could do the following:\r\n\r\n```\r\nselect\r\ncustomer_id,\r\nmaxIf(date, source = 'transactions') over (partition by customer_id) as last_transaction_date\r\nfrom mytdb.mytable\r\n```\r\n\r\nwhich is reading all rows despite the -If suffix.",
  "created_at": "2022-06-04T02:04:59Z",
  "modified_files": [
    "docs/en/sql-reference/window-functions/index.md",
    "src/AggregateFunctions/AggregateFunctionFactory.h",
    "src/Interpreters/ActionsVisitor.cpp",
    "src/Interpreters/ActionsVisitor.h",
    "src/Interpreters/ExpressionAnalyzer.cpp",
    "src/Interpreters/ExpressionAnalyzer.h",
    "b/src/Interpreters/GetAggregatesVisitor.cpp",
    "src/Interpreters/GetAggregatesVisitor.h",
    "src/Interpreters/InDepthNodeVisitor.h",
    "src/Interpreters/InterpreterInsertQuery.cpp",
    "src/Interpreters/MonotonicityCheckVisitor.h",
    "src/Interpreters/RewriteAnyFunctionVisitor.cpp",
    "src/Interpreters/TreeRewriter.cpp",
    "src/Interpreters/TreeRewriter.h",
    "src/Parsers/ASTFunction.cpp",
    "src/Parsers/ASTFunction.h",
    "src/Storages/TTLDescription.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01591_window_functions.reference",
    "tests/queries/0_stateless/01591_window_functions.sql",
    "b/tests/queries/0_stateless/02316_expressions_with_window_functions.reference",
    "b/tests/queries/0_stateless/02316_expressions_with_window_functions.sql"
  ]
}