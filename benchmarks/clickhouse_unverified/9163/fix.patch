diff --git a/dbms/src/Common/OptimizedRegularExpression.cpp b/dbms/src/Common/OptimizedRegularExpression.cpp
index 3a2247094478..6c06a28c343f 100644
--- a/dbms/src/Common/OptimizedRegularExpression.cpp
+++ b/dbms/src/Common/OptimizedRegularExpression.cpp
@@ -290,31 +290,44 @@ OptimizedRegularExpressionImpl<thread_safe>::OptimizedRegularExpressionImpl(cons
                 throw DB::Exception("OptimizedRegularExpression: too many subpatterns in regexp: " + regexp_, DB::ErrorCodes::CANNOT_COMPILE_REGEXP);
         }
     }
+
+    if (!required_substring.empty())
+    {
+        if (is_case_insensitive)
+            case_insensitive_substring_searcher.emplace(required_substring.data(), required_substring.size());
+        else
+            case_sensitive_substring_searcher.emplace(required_substring.data(), required_substring.size());
+    }
 }
 
 
 template <bool thread_safe>
 bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, size_t subject_size) const
 {
+    const UInt8 * haystack = reinterpret_cast<const UInt8 *>(subject);
+    const UInt8 * haystack_end = haystack + subject_size;
+
     if (is_trivial)
     {
         if (is_case_insensitive)
-            return nullptr != strcasestr(subject, required_substring.data());
+            return haystack_end != case_insensitive_substring_searcher->search(haystack, subject_size);
         else
-            return nullptr != strstr(subject, required_substring.data());
+            return haystack_end != case_sensitive_substring_searcher->search(haystack, subject_size);
     }
     else
     {
         if (!required_substring.empty())
         {
-            const char * pos;
             if (is_case_insensitive)
-                pos = strcasestr(subject, required_substring.data());
+            {
+                if (haystack_end == case_insensitive_substring_searcher->search(haystack, subject_size))
+                    return false;
+            }
             else
-                pos = strstr(subject, required_substring.data());
-
-            if (nullptr == pos)
-                return 0;
+            {
+                if (haystack_end == case_sensitive_substring_searcher->search(haystack, subject_size))
+                    return false;
+            }
         }
 
         return re2->Match(StringPieceType(subject, subject_size), 0, subject_size, RegexType::UNANCHORED, nullptr, 0);
@@ -325,19 +338,22 @@ bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, si
 template <bool thread_safe>
 bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, size_t subject_size, Match & match) const
 {
+    const UInt8 * haystack = reinterpret_cast<const UInt8 *>(subject);
+    const UInt8 * haystack_end = haystack + subject_size;
+
     if (is_trivial)
     {
-        const char * pos;
+        const UInt8 * pos;
         if (is_case_insensitive)
-            pos = strcasestr(subject, required_substring.data());
+            pos = case_insensitive_substring_searcher->search(haystack, subject_size);
         else
-            pos = strstr(subject, required_substring.data());
+            pos = case_sensitive_substring_searcher->search(haystack, subject_size);
 
-        if (pos == nullptr)
-            return 0;
+        if (haystack_end == pos)
+            return false;
         else
         {
-            match.offset = pos - subject;
+            match.offset = pos - haystack;
             match.length = required_substring.size();
             return 1;
         }
@@ -346,25 +362,25 @@ bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, si
     {
         if (!required_substring.empty())
         {
-            const char * pos;
+            const UInt8 * pos;
             if (is_case_insensitive)
-                pos = strcasestr(subject, required_substring.data());
+                pos = case_insensitive_substring_searcher->search(haystack, subject_size);
             else
-                pos = strstr(subject, required_substring.data());
+                pos = case_sensitive_substring_searcher->search(haystack, subject_size);
 
-            if (nullptr == pos)
-                return 0;
+            if (haystack_end == pos)
+                return false;
         }
 
         StringPieceType piece;
 
         if (!RegexType::PartialMatch(StringPieceType(subject, subject_size), *re2, &piece))
-            return 0;
+            return false;
         else
         {
             match.offset = piece.data() - subject;
             match.length = piece.length();
-            return 1;
+            return true;
         }
     }
 }
@@ -373,6 +389,9 @@ bool OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, si
 template <bool thread_safe>
 unsigned OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject, size_t subject_size, MatchVec & matches, unsigned limit) const
 {
+    const UInt8 * haystack = reinterpret_cast<const UInt8 *>(subject);
+    const UInt8 * haystack_end = haystack + subject_size;
+
     matches.clear();
 
     if (limit == 0)
@@ -383,18 +402,18 @@ unsigned OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject
 
     if (is_trivial)
     {
-        const char * pos;
+        const UInt8 * pos;
         if (is_case_insensitive)
-            pos = strcasestr(subject, required_substring.data());
+            pos = case_insensitive_substring_searcher->search(haystack, subject_size);
         else
-            pos = strstr(subject, required_substring.data());
+            pos = case_sensitive_substring_searcher->search(haystack, subject_size);
 
-        if (pos == nullptr)
+        if (haystack_end == pos)
             return 0;
         else
         {
             Match match;
-            match.offset = pos - subject;
+            match.offset = pos - haystack;
             match.length = required_substring.size();
             matches.push_back(match);
             return 1;
@@ -404,17 +423,17 @@ unsigned OptimizedRegularExpressionImpl<thread_safe>::match(const char * subject
     {
         if (!required_substring.empty())
         {
-            const char * pos;
+            const UInt8 * pos;
             if (is_case_insensitive)
-                pos = strcasestr(subject, required_substring.data());
+                pos = case_insensitive_substring_searcher->search(haystack, subject_size);
             else
-                pos = strstr(subject, required_substring.data());
+                pos = case_sensitive_substring_searcher->search(haystack, subject_size);
 
-            if (nullptr == pos)
+            if (haystack_end == pos)
                 return 0;
         }
 
-        DB::PODArrayWithStackMemory<StringPieceType, sizeof(StringPieceType) * (MAX_SUBPATTERNS+1)> pieces(limit);
+        DB::PODArrayWithStackMemory<StringPieceType, sizeof(StringPieceType) * (MAX_SUBPATTERNS + 1)> pieces(limit);
 
         if (!re2->Match(StringPieceType(subject, subject_size), 0, subject_size, RegexType::UNANCHORED, pieces.data(), pieces.size()))
             return 0;
diff --git a/dbms/src/Common/OptimizedRegularExpression.h b/dbms/src/Common/OptimizedRegularExpression.h
index ccbd8a517d2c..0c31558cecb9 100644
--- a/dbms/src/Common/OptimizedRegularExpression.h
+++ b/dbms/src/Common/OptimizedRegularExpression.h
@@ -3,6 +3,8 @@
 #include <string>
 #include <vector>
 #include <memory>
+#include <optional>
+#include <Common/StringSearcher.h>
 #include <Common/config.h>
 #include <re2/re2.h>
 #if USE_RE2_ST
@@ -101,6 +103,8 @@ class OptimizedRegularExpressionImpl
     bool required_substring_is_prefix;
     bool is_case_insensitive;
     std::string required_substring;
+    std::optional<DB::StringSearcher<true, true>> case_sensitive_substring_searcher;
+    std::optional<DB::StringSearcher<false, true>> case_insensitive_substring_searcher;
     std::unique_ptr<RegexType> re2;
     unsigned number_of_subpatterns;
 };
diff --git a/dbms/src/Common/StringSearcher.h b/dbms/src/Common/StringSearcher.h
index d395e6f254a8..b399a256052c 100644
--- a/dbms/src/Common/StringSearcher.h
+++ b/dbms/src/Common/StringSearcher.h
@@ -222,6 +222,8 @@ class StringSearcher<false, false> : private StringSearcherBase
         return false;
     }
 
+    /** Returns haystack_end if not found.
+      */
     const UInt8 * search(const UInt8 * haystack, const UInt8 * const haystack_end) const
     {
         if (0 == needle_size)
diff --git a/dbms/src/DataStreams/IBlockInputStream.h b/dbms/src/DataStreams/IBlockInputStream.h
index 7ca415512983..095e41717cc5 100644
--- a/dbms/src/DataStreams/IBlockInputStream.h
+++ b/dbms/src/DataStreams/IBlockInputStream.h
@@ -284,7 +284,7 @@ class IBlockInputStream : public TypePromotion<IBlockInputStream>
     /// The approximate total number of rows to read. For progress bar.
     size_t total_rows_approx = 0;
 
-    /// The successors must implement this function.
+    /// Derived classes must implement this function.
     virtual Block readImpl() = 0;
 
     /// Here you can do a preliminary initialization.
diff --git a/dbms/src/Functions/FunctionsStringRegex.cpp b/dbms/src/Functions/FunctionsStringRegex.cpp
index dc8bbc9a9372..ec515395c069 100644
--- a/dbms/src/Functions/FunctionsStringRegex.cpp
+++ b/dbms/src/Functions/FunctionsStringRegex.cpp
@@ -89,6 +89,8 @@ inline bool likePatternIsStrstr(const String & pattern, String & res)
 template <bool like, bool revert = false>
 struct MatchImpl
 {
+    static constexpr bool use_default_implementation_for_constants = true;
+
     using ResultType = UInt8;
 
     static void vector_constant(
@@ -240,12 +242,6 @@ struct MatchImpl
         }
     }
 
-    static void constant_constant(const std::string & data, const std::string & pattern, UInt8 & res)
-    {
-        const auto & regexp = Regexps::get<like, true>(pattern);
-        res = revert ^ regexp->match(data);
-    }
-
     template <typename... Args>
     static void vector_vector(Args &&...)
     {
@@ -846,29 +842,6 @@ struct ReplaceStringImpl
 #undef COPY_REST_OF_CURRENT_STRING
         }
     }
-
-    static void constant(const std::string & data, const std::string & needle, const std::string & replacement, std::string & res_data)
-    {
-        res_data = "";
-        int replace_cnt = 0;
-        for (size_t i = 0; i < data.size(); ++i)
-        {
-            bool match = true;
-            if (i + needle.size() > data.size() || (replace_one && replace_cnt > 0))
-                match = false;
-            for (size_t j = 0; match && j < needle.size(); ++j)
-                if (data[i + j] != needle[j])
-                    match = false;
-            if (match)
-            {
-                ++replace_cnt;
-                res_data += replacement;
-                i = i + needle.size() - 1;
-            }
-            else
-                res_data += data[i];
-        }
-    }
 };
 
 
diff --git a/dbms/src/Functions/FunctionsStringSearch.cpp b/dbms/src/Functions/FunctionsStringSearch.cpp
index c39d536927ce..6c20cdaf0684 100644
--- a/dbms/src/Functions/FunctionsStringSearch.cpp
+++ b/dbms/src/Functions/FunctionsStringSearch.cpp
@@ -146,6 +146,8 @@ struct PositionCaseInsensitiveUTF8
 template <typename Impl>
 struct PositionImpl
 {
+    static constexpr bool use_default_implementation_for_constants = false;
+
     using ResultType = UInt64;
 
     /// Find one substring in many strings.
@@ -459,6 +461,8 @@ struct HasTokenImpl
 {
     using ResultType = UInt8;
 
+    static constexpr bool use_default_implementation_for_constants = true;
+
     static void vector_constant(
         const ColumnString::Chars & data, const ColumnString::Offsets & offsets, const std::string & pattern, PaddedPODArray<UInt8> & res)
     {
@@ -499,13 +503,6 @@ struct HasTokenImpl
             memset(&res[i], negate_result, (res.size() - i) * sizeof(res[0]));
     }
 
-    static void constant_constant(const std::string & data, const std::string & pattern, UInt8 & res)
-    {
-        TokenSearcher searcher(pattern.data(), pattern.size(), data.size());
-        const auto found = searcher.search(data.c_str(), data.size()) != data.end().base();
-        res = negate_result ^ found;
-    }
-
     template <typename... Args>
     static void vector_vector(Args &&...)
     {
diff --git a/dbms/src/Functions/FunctionsStringSearch.h b/dbms/src/Functions/FunctionsStringSearch.h
index 03fdfe22b95b..8cbf92902ab1 100644
--- a/dbms/src/Functions/FunctionsStringSearch.h
+++ b/dbms/src/Functions/FunctionsStringSearch.h
@@ -82,6 +82,15 @@ class FunctionsStringSearch : public IFunction
 
     size_t getNumberOfArguments() const override { return 2; }
 
+    bool useDefaultImplementationForConstants() const override { return Impl::use_default_implementation_for_constants; }
+
+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override
+    {
+        return Impl::use_default_implementation_for_constants
+            ? ColumnNumbers{1, 2}
+            : ColumnNumbers{};
+    }
+
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
         if (!isString(arguments[0]))
@@ -105,13 +114,16 @@ class FunctionsStringSearch : public IFunction
         const ColumnConst * col_haystack_const = typeid_cast<const ColumnConst *>(&*column_haystack);
         const ColumnConst * col_needle_const = typeid_cast<const ColumnConst *>(&*column_needle);
 
-        if (col_haystack_const && col_needle_const)
+        if constexpr (!Impl::use_default_implementation_for_constants)
         {
-            ResultType res{};
-            Impl::constant_constant(col_haystack_const->getValue<String>(), col_needle_const->getValue<String>(), res);
-            block.getByPosition(result).column
-                = block.getByPosition(result).type->createColumnConst(col_haystack_const->size(), toField(res));
-            return;
+            if (col_haystack_const && col_needle_const)
+            {
+                ResultType res{};
+                Impl::constant_constant(col_haystack_const->getValue<String>(), col_needle_const->getValue<String>(), res);
+                block.getByPosition(result).column
+                    = block.getByPosition(result).type->createColumnConst(col_haystack_const->size(), toField(res));
+                return;
+            }
         }
 
         auto col_res = ColumnVector<ResultType>::create();
diff --git a/dbms/src/Functions/FunctionsVisitParam.h b/dbms/src/Functions/FunctionsVisitParam.h
index 99d84f8bc6da..03dee724fd79 100644
--- a/dbms/src/Functions/FunctionsVisitParam.h
+++ b/dbms/src/Functions/FunctionsVisitParam.h
@@ -78,6 +78,8 @@ struct ExtractParamImpl
 {
     using ResultType = typename ParamExtractor::ResultType;
 
+    static constexpr bool use_default_implementation_for_constants = true;
+
     /// It is assumed that `res` is the correct size and initialized with zeros.
     static void vector_constant(const ColumnString::Chars & data, const ColumnString::Offsets & offsets,
         std::string needle,
@@ -119,19 +121,6 @@ struct ExtractParamImpl
             memset(&res[i], 0, (res.size() - i) * sizeof(res[0]));
     }
 
-    static void constant_constant(const std::string & data, std::string needle, ResultType & res)
-    {
-        needle = "\"" + needle + "\":";
-        size_t pos = data.find(needle);
-        if (pos == std::string::npos)
-            res = 0;
-        else
-            res = ParamExtractor::extract(
-                reinterpret_cast<const UInt8 *>(data.data() + pos + needle.size()),
-                reinterpret_cast<const UInt8 *>(data.data() + data.size())
-            );
-    }
-
     template <typename... Args> static void vector_vector(Args &&...)
     {
         throw Exception("Functions 'visitParamHas' and 'visitParamExtract*' doesn't support non-constant needle argument", ErrorCodes::ILLEGAL_COLUMN);
diff --git a/dbms/src/IO/WriteBuffer.h b/dbms/src/IO/WriteBuffer.h
index 25c93b227e39..b8bf53e18fd9 100644
--- a/dbms/src/IO/WriteBuffer.h
+++ b/dbms/src/IO/WriteBuffer.h
@@ -22,7 +22,7 @@ namespace ErrorCodes
   * Unlike std::ostream, it provides access to the internal buffer,
   *  and also allows you to manually manage the position inside the buffer.
   *
-  * The successors must implement the nextImpl() method.
+  * Derived classes must implement the nextImpl() method.
   */
 class WriteBuffer : public BufferBase
 {
@@ -55,7 +55,7 @@ class WriteBuffer : public BufferBase
         pos = working_buffer.begin();
     }
 
-    /** it is desirable in the successors to place the next() call in the destructor,
+    /** it is desirable in the derived classes to place the next() call in the destructor,
       * so that the last data is written
       */
     virtual ~WriteBuffer() {}
