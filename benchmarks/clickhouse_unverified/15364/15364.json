{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 15364,
  "instance_id": "ClickHouse__ClickHouse-15364",
  "issue_numbers": [
    "15349"
  ],
  "base_commit": "ca6e56f997e6beb88cfb5951899cdac0fb31f49f",
  "patch": "diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 522149d3cfd7..e9f37ff97525 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -367,6 +367,8 @@ void registerInputFormatProcessorArrow(FormatFactory & factory);\n void registerOutputFormatProcessorArrow(FormatFactory & factory);\n void registerInputFormatProcessorAvro(FormatFactory & factory);\n void registerOutputFormatProcessorAvro(FormatFactory & factory);\n+void registerInputFormatProcessorRawBLOB(FormatFactory & factory);\n+void registerOutputFormatProcessorRawBLOB(FormatFactory & factory);\n \n /// Output only (presentational) formats.\n \n@@ -426,6 +428,9 @@ FormatFactory::FormatFactory()\n     registerOutputFormatProcessorTemplate(*this);\n     registerInputFormatProcessorMsgPack(*this);\n     registerOutputFormatProcessorMsgPack(*this);\n+    registerInputFormatProcessorRawBLOB(*this);\n+    registerOutputFormatProcessorRawBLOB(*this);\n+\n #if !defined(ARCADIA_BUILD)\n     registerInputFormatProcessorORC(*this);\n     registerOutputFormatProcessorORC(*this);\n@@ -456,6 +461,7 @@ FormatFactory::FormatFactory()\n     registerInputFormatProcessorRegexp(*this);\n     registerInputFormatProcessorJSONAsString(*this);\n     registerInputFormatProcessorLineAsString(*this);\n+\n #if !defined(ARCADIA_BUILD)\n     registerInputFormatProcessorCapnProto(*this);\n #endif\ndiff --git a/src/Processors/Formats/Impl/JSONAsStringRowInputFormat.cpp b/src/Processors/Formats/Impl/JSONAsStringRowInputFormat.cpp\nindex 42fa764f011c..bc57803152fb 100644\n--- a/src/Processors/Formats/Impl/JSONAsStringRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/JSONAsStringRowInputFormat.cpp\n@@ -1,5 +1,7 @@\n #include <Processors/Formats/Impl/JSONAsStringRowInputFormat.h>\n #include <Formats/JSONEachRowUtils.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n #include <common/find_symbols.h>\n #include <IO/ReadHelpers.h>\n \n@@ -8,17 +10,22 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int LOGICAL_ERROR;\n+    extern const int BAD_ARGUMENTS;\n     extern const int INCORRECT_DATA;\n }\n \n JSONAsStringRowInputFormat::JSONAsStringRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_) :\n     IRowInputFormat(header_, in_, std::move(params_)), buf(in)\n {\n-    if (header_.columns() > 1 || header_.getDataTypes()[0]->getTypeId() != TypeIndex::String)\n-    {\n-        throw Exception(\"This input format is only suitable for tables with a single column of type String.\", ErrorCodes::LOGICAL_ERROR);\n-    }\n+    if (header_.columns() > 1)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"This input format is only suitable for tables with a single column of type String but the number of columns is {}\",\n+            header_.columns());\n+\n+    if (!isString(removeNullable(removeLowCardinality(header_.getByPosition(0).type))))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"This input format is only suitable for tables with a single column of type String but the column type is {}\",\n+            header_.getByPosition(0).type->getName());\n }\n \n void JSONAsStringRowInputFormat::resetParser()\ndiff --git a/src/Processors/Formats/Impl/RawBLOBRowInputFormat.cpp b/src/Processors/Formats/Impl/RawBLOBRowInputFormat.cpp\nnew file mode 100644\nindex 000000000000..bd9eaada05e2\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/RawBLOBRowInputFormat.cpp\n@@ -0,0 +1,55 @@\n+#include <Formats/FormatFactory.h>\n+#include <Processors/Formats/Impl/RawBLOBRowInputFormat.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <IO/ReadHelpers.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+RawBLOBRowInputFormat::RawBLOBRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_)\n+    : IRowInputFormat(header_, in_, std::move(params_))\n+{\n+    if (header_.columns() > 1)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"This input format is only suitable for tables with a single column of type String but the number of columns is {}\",\n+            header_.columns());\n+\n+    if (!isString(removeNullable(removeLowCardinality(header_.getByPosition(0).type))))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"This input format is only suitable for tables with a single column of type String but the column type is {}\",\n+            header_.getByPosition(0).type->getName());\n+}\n+\n+bool RawBLOBRowInputFormat::readRow(MutableColumns & columns, RowReadExtension &)\n+{\n+    if (in.eof())\n+        return false;\n+\n+    /// One excessive copy.\n+    String blob;\n+    readStringUntilEOF(blob, in);\n+    columns.at(0)->insertData(blob.data(), blob.size());\n+    return false;\n+}\n+\n+void registerInputFormatProcessorRawBLOB(FormatFactory & factory)\n+{\n+    factory.registerInputFormatProcessor(\"RawBLOB\", [](\n+            ReadBuffer & buf,\n+            const Block & sample,\n+            const RowInputFormatParams & params,\n+            const FormatSettings &)\n+    {\n+        return std::make_shared<RawBLOBRowInputFormat>(sample, buf, params);\n+    });\n+}\n+\n+}\n+\ndiff --git a/src/Processors/Formats/Impl/RawBLOBRowInputFormat.h b/src/Processors/Formats/Impl/RawBLOBRowInputFormat.h\nnew file mode 100644\nindex 000000000000..fd2c849687aa\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/RawBLOBRowInputFormat.h\n@@ -0,0 +1,24 @@\n+#pragma once\n+\n+#include <Processors/Formats/IRowInputFormat.h>\n+\n+\n+namespace DB\n+{\n+\n+class ReadBuffer;\n+\n+/// This format slurps all input data into single value.\n+/// This format can only parse a table with single field of type String or similar.\n+\n+class RawBLOBRowInputFormat : public IRowInputFormat\n+{\n+public:\n+    RawBLOBRowInputFormat(const Block & header_, ReadBuffer & in_, Params params_);\n+\n+    bool readRow(MutableColumns & columns, RowReadExtension &) override;\n+    String getName() const override { return \"RawBLOBRowInputFormat\"; }\n+};\n+\n+}\n+\ndiff --git a/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.cpp b/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.cpp\nnew file mode 100644\nindex 000000000000..786edce5edc1\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.cpp\n@@ -0,0 +1,38 @@\n+#include <Processors/Formats/Impl/RawBLOBRowOutputFormat.h>\n+#include <Formats/FormatFactory.h>\n+#include <IO/WriteBuffer.h>\n+\n+namespace DB\n+{\n+\n+\n+RawBLOBRowOutputFormat::RawBLOBRowOutputFormat(\n+    WriteBuffer & out_,\n+    const Block & header_,\n+    FormatFactory::WriteCallback callback)\n+    : IRowOutputFormat(header_, out_, callback)\n+{\n+}\n+\n+\n+void RawBLOBRowOutputFormat::writeField(const IColumn & column, const IDataType &, size_t row_num)\n+{\n+    StringRef value = column.getDataAt(row_num);\n+    out.write(value.data, value.size);\n+}\n+\n+\n+void registerOutputFormatProcessorRawBLOB(FormatFactory & factory)\n+{\n+    factory.registerOutputFormatProcessor(\"RawBLOB\", [](\n+        WriteBuffer & buf,\n+        const Block & sample,\n+        FormatFactory::WriteCallback callback,\n+        const FormatSettings &)\n+    {\n+        return std::make_shared<RawBLOBRowOutputFormat>(buf, sample, callback);\n+    });\n+}\n+\n+}\n+\ndiff --git a/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.h b/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.h\nnew file mode 100644\nindex 000000000000..b6c13597d4b7\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.h\n@@ -0,0 +1,41 @@\n+#pragma once\n+\n+#include <Core/Block.h>\n+#include <Processors/Formats/IRowOutputFormat.h>\n+\n+\n+namespace DB\n+{\n+\n+class WriteBuffer;\n+\n+\n+/** This format only allows to output columns of type String\n+  *  or types that have contiguous representation in memory.\n+  * They are output as raw bytes without any delimiters or escaping.\n+  *\n+  * The difference between RawBLOB and TSVRaw:\n+  * - data is output in binary, no escaping;\n+  * - no delimiters between values;\n+  * - no newline at the end of each value.\n+  *\n+  * The difference between RawBLOB and RowBinary:\n+  * - strings are output without their lengths.\n+  *\n+  * If you are output more than one value, the output format is ambiguous and you may not be able to read data back.\n+  */\n+class RawBLOBRowOutputFormat : public IRowOutputFormat\n+{\n+public:\n+    RawBLOBRowOutputFormat(\n+        WriteBuffer & out_,\n+        const Block & header_,\n+        FormatFactory::WriteCallback callback);\n+\n+    String getName() const override { return \"RawBLOBRowOutputFormat\"; }\n+\n+    void writeField(const IColumn & column, const IDataType &, size_t row_num) override;\n+};\n+\n+}\n+\ndiff --git a/src/Processors/ya.make b/src/Processors/ya.make\nindex c69d274a70e0..b2f8b9ba7c27 100644\n--- a/src/Processors/ya.make\n+++ b/src/Processors/ya.make\n@@ -47,6 +47,8 @@ SRCS(\n     Formats/Impl/PrettySpaceBlockOutputFormat.cpp\n     Formats/Impl/ProtobufRowInputFormat.cpp\n     Formats/Impl/ProtobufRowOutputFormat.cpp\n+    Formats/Impl/RawBLOBRowInputFormat.cpp\n+    Formats/Impl/RawBLOBRowOutputFormat.cpp\n     Formats/Impl/RegexpRowInputFormat.cpp\n     Formats/Impl/TabSeparatedRowInputFormat.cpp\n     Formats/Impl/TabSeparatedRowOutputFormat.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01509_format_raw_blob.reference b/tests/queries/0_stateless/01509_format_raw_blob.reference\nnew file mode 100644\nindex 000000000000..dfa8f538e679\n--- /dev/null\n+++ b/tests/queries/0_stateless/01509_format_raw_blob.reference\n@@ -0,0 +1,2 @@\n+96b229180107fd2d23fd0a2ef9326701  -\n+96b229180107fd2d23fd0a2ef9326701  -\ndiff --git a/tests/queries/0_stateless/01509_format_raw_blob.sh b/tests/queries/0_stateless/01509_format_raw_blob.sh\nnew file mode 100755\nindex 000000000000..68d3844d727d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01509_format_raw_blob.sh\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CLIENT} -n --query \"\n+DROP TABLE IF EXISTS t;\n+CREATE TABLE t (a LowCardinality(Nullable(String))) ENGINE = Memory;\n+\"\n+\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO t FORMAT RawBLOB\" < ${BASH_SOURCE[0]}\n+\n+cat ${BASH_SOURCE[0]} | md5sum\n+${CLICKHOUSE_CLIENT} -n --query \"SELECT * FROM t FORMAT RawBLOB\" | md5sum\n+\n+${CLICKHOUSE_CLIENT} --query \"\n+DROP TABLE t;\n+\"\n",
  "problem_statement": "Input format RawBLOB\n**Use case**\r\nImport binary data as a single row single column of String or similar type.\r\nIt will just read all input as a single value.\r\n\r\nLoading large blobs as well as loading data by single rows are typical anipatterns in ClickHouse.\r\nBut sometimes it is needed.\n",
  "hints_text": "",
  "created_at": "2020-09-28T00:12:13Z",
  "modified_files": [
    "src/Formats/FormatFactory.cpp",
    "src/Processors/Formats/Impl/JSONAsStringRowInputFormat.cpp",
    "b/src/Processors/Formats/Impl/RawBLOBRowInputFormat.cpp",
    "b/src/Processors/Formats/Impl/RawBLOBRowInputFormat.h",
    "b/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.cpp",
    "b/src/Processors/Formats/Impl/RawBLOBRowOutputFormat.h",
    "src/Processors/ya.make"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01509_format_raw_blob.reference",
    "b/tests/queries/0_stateless/01509_format_raw_blob.sh"
  ]
}