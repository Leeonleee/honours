diff --git a/src/Analyzer/FunctionNode.h b/src/Analyzer/FunctionNode.h
index 92d3ab84722e..41751ec3f093 100644
--- a/src/Analyzer/FunctionNode.h
+++ b/src/Analyzer/FunctionNode.h
@@ -145,6 +145,11 @@ class FunctionNode final : public IQueryTreeNode
       */
     void resolveAsFunction(FunctionBasePtr function_value);
 
+    void resolveAsFunction(const FunctionOverloadResolverPtr & resolver)
+    {
+        resolveAsFunction(resolver->build(getArgumentColumns()));
+    }
+
     /** Resolve function node as aggregate function.
       * It is important that function name is updated with resolved function name.
       * Main motivation for this is query tree optimizations.
diff --git a/src/Analyzer/InDepthQueryTreeVisitor.h b/src/Analyzer/InDepthQueryTreeVisitor.h
index 96972024d872..1d096ece1a19 100644
--- a/src/Analyzer/InDepthQueryTreeVisitor.h
+++ b/src/Analyzer/InDepthQueryTreeVisitor.h
@@ -1,8 +1,13 @@
 #pragma once
 
+#include <optional>
+#include <utility>
+#include <Common/SettingsChanges.h>
 #include <Common/Exception.h>
+#include <Core/Settings.h>
 
 #include <Analyzer/IQueryTreeNode.h>
+#include <Analyzer/QueryNode.h>
 
 
 namespace DB
diff --git a/src/Analyzer/ListNode.h b/src/Analyzer/ListNode.h
index 5b328d0f8702..4e09512d7802 100644
--- a/src/Analyzer/ListNode.h
+++ b/src/Analyzer/ListNode.h
@@ -16,6 +16,8 @@ using ListNodePtr = std::shared_ptr<ListNode>;
 class ListNode final : public IQueryTreeNode
 {
 public:
+    using iterator = QueryTreeNodes::iterator;
+
     /// Initialize list node with empty nodes
     ListNode();
 
@@ -41,6 +43,9 @@ class ListNode final : public IQueryTreeNode
 
     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;
 
+    iterator begin() { return children.begin(); }
+    iterator end() { return children.end(); }
+
 protected:
     bool isEqualImpl(const IQueryTreeNode & rhs) const override;
 
diff --git a/src/Analyzer/Passes/ConvertOrLikeChainPass.cpp b/src/Analyzer/Passes/ConvertOrLikeChainPass.cpp
new file mode 100644
index 000000000000..e1b11ceb8de9
--- /dev/null
+++ b/src/Analyzer/Passes/ConvertOrLikeChainPass.cpp
@@ -0,0 +1,134 @@
+#include <memory>
+#include <unordered_map>
+#include <vector>
+#include <Analyzer/Passes/ConvertOrLikeChainPass.h>
+#include <Analyzer/ConstantNode.h>
+#include <Analyzer/UnionNode.h>
+#include <Analyzer/FunctionNode.h>
+#include <Analyzer/HashUtils.h>
+#include <Analyzer/InDepthQueryTreeVisitor.h>
+#include <Core/Field.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/likePatternToRegexp.h>
+#include <Interpreters/Context.h>
+
+namespace DB
+{
+
+namespace
+{
+
+class ConvertOrLikeChainVisitor : public InDepthQueryTreeVisitor<ConvertOrLikeChainVisitor>
+{
+    using FunctionNodes = std::vector<std::shared_ptr<FunctionNode>>;
+
+    const FunctionOverloadResolverPtr match_function_ref;
+    const FunctionOverloadResolverPtr or_function_resolver;
+public:
+
+    explicit ConvertOrLikeChainVisitor(ContextPtr context)
+        : InDepthQueryTreeVisitor<ConvertOrLikeChainVisitor>()
+        , match_function_ref(FunctionFactory::instance().get("multiMatchAny", context))
+        , or_function_resolver(FunctionFactory::instance().get("or", context))
+    {}
+
+    static bool needChildVisit(VisitQueryTreeNodeType & parent, VisitQueryTreeNodeType &)
+    {
+        ContextPtr context;
+        if (auto * query = parent->as<QueryNode>())
+            context = query->getContext();
+        else if (auto * union_node = parent->as<UnionNode>())
+            context = union_node->getContext();
+        if (context)
+        {
+            const auto & settings = context->getSettingsRef();
+            return settings.optimize_or_like_chain
+                && settings.allow_hyperscan
+                && settings.max_hyperscan_regexp_length == 0
+                && settings.max_hyperscan_regexp_total_length == 0;
+        }
+        return true;
+    }
+
+    void visitImpl(QueryTreeNodePtr & node)
+    {
+        auto * function_node = node->as<FunctionNode>();
+        if (!function_node || function_node->getFunctionName() != "or")
+            return;
+
+        QueryTreeNodes unique_elems;
+
+        QueryTreeNodePtrWithHashMap<Array> node_to_patterns;
+        FunctionNodes match_functions;
+        for (auto & arg : function_node->getArguments())
+        {
+            unique_elems.push_back(arg);
+
+            auto * arg_func = arg->as<FunctionNode>();
+            if (!arg_func)
+                continue;
+
+            const bool is_like  = arg_func->getFunctionName() == "like";
+            const bool is_ilike = arg_func->getFunctionName() == "ilike";
+
+            /// Not {i}like -> bail out.
+            if (!is_like && !is_ilike)
+                continue;
+
+            const auto & like_arguments = arg_func->getArguments().getNodes();
+            if (like_arguments.size() != 2)
+                continue;
+
+            auto identifier = like_arguments[0];
+            auto * pattern = like_arguments[1]->as<ConstantNode>();
+            if (!pattern || !isString(pattern->getResultType()))
+                continue;
+
+            auto regexp = likePatternToRegexp(pattern->getValue().get<String>());
+            /// Case insensitive. Works with UTF-8 as well.
+            if (is_ilike)
+                regexp = "(?i)" + regexp;
+
+            unique_elems.pop_back();
+            auto it = node_to_patterns.find(identifier);
+            if (it == node_to_patterns.end())
+            {
+                it = node_to_patterns.insert({identifier, Array{}}).first;
+                /// The second argument will be added when all patterns are known.
+                auto match_function = std::make_shared<FunctionNode>("multiMatchAny");
+                match_function->getArguments().getNodes().push_back(identifier);
+
+                match_functions.push_back(match_function);
+                unique_elems.push_back(std::move(match_function));
+            }
+            it->second.push_back(regexp);
+        }
+
+        /// Add all the patterns into the function arguments lists.
+        for (auto & match_function : match_functions)
+        {
+            auto & arguments = match_function->getArguments().getNodes();
+            auto & patterns = node_to_patterns.at(arguments[0]);
+            arguments.push_back(std::make_shared<ConstantNode>(Field{std::move(patterns)}));
+            match_function->resolveAsFunction(match_function_ref);
+        }
+
+        /// OR must have at least two arguments.
+        if (unique_elems.size() == 1)
+            unique_elems.push_back(std::make_shared<ConstantNode>(false));
+
+        function_node->getArguments().getNodes() = std::move(unique_elems);
+        function_node->resolveAsFunction(or_function_resolver);
+    }
+};
+
+}
+
+void ConvertOrLikeChainPass::run(QueryTreeNodePtr query_tree_node, ContextPtr  context)
+{
+    ConvertOrLikeChainVisitor visitor(context);
+    visitor.visit(query_tree_node);
+}
+
+}
diff --git a/src/Analyzer/Passes/ConvertOrLikeChainPass.h b/src/Analyzer/Passes/ConvertOrLikeChainPass.h
new file mode 100644
index 000000000000..0f734bfa73dd
--- /dev/null
+++ b/src/Analyzer/Passes/ConvertOrLikeChainPass.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <Analyzer/IQueryTreePass.h>
+
+namespace DB
+{
+
+/** Replaces all the "or"'s with {i}like to multiMatchAny
+ */
+class ConvertOrLikeChainPass final : public IQueryTreePass
+{
+public:
+    String getName() override { return "ConvertOrLikeChain"; }
+
+    String getDescription() override { return "Replaces all the 'or's with {i}like to multiMatchAny"; }
+
+    void run(QueryTreeNodePtr query_tree_node, ContextPtr context) override;
+};
+
+}
diff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp
index 618cbd6d9e8c..3d4e012bb93f 100644
--- a/src/Analyzer/QueryNode.cpp
+++ b/src/Analyzer/QueryNode.cpp
@@ -17,6 +17,7 @@
 #include <Parsers/ASTSetQuery.h>
 
 #include <Analyzer/Utils.h>
+#include <fmt/core.h>
 
 namespace DB
 {
@@ -179,6 +180,16 @@ void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, s
         buffer << '
' << std::string(indent + 2, ' ') << "OFFSET
";
         getOffset()->dumpTreeImpl(buffer, format_state, indent + 4);
     }
+
+    if (hasSettingsChanges())
+    {
+        buffer << '
' << std::string(indent + 2, ' ') << "SETTINGS";
+        for (const auto & change : settings_changes)
+        {
+            buffer << fmt::format(" {}={}", change.name, toString(change.value));
+        }
+        buffer << '
';
+    }
 }
 
 bool QueryNode::isEqualImpl(const IQueryTreeNode & rhs) const
diff --git a/src/Analyzer/QueryTreePassManager.cpp b/src/Analyzer/QueryTreePassManager.cpp
index bbcea363dcb2..66b060de6c4a 100644
--- a/src/Analyzer/QueryTreePassManager.cpp
+++ b/src/Analyzer/QueryTreePassManager.cpp
@@ -1,3 +1,4 @@
+#include <memory>
 #include <Analyzer/QueryTreePassManager.h>
 
 #include <Common/Exception.h>
@@ -29,6 +30,7 @@
 #include <Analyzer/Passes/FuseFunctionsPass.h>
 #include <Analyzer/Passes/OptimizeGroupByFunctionKeysPass.h>
 #include <Analyzer/Passes/IfTransformStringsToEnumPass.h>
+#include <Analyzer/Passes/ConvertOrLikeChainPass.h>
 #include <Analyzer/Passes/OptimizeRedundantFunctionsInOrderByPass.h>
 
 namespace DB
@@ -254,6 +256,8 @@ void addQueryTreePasses(QueryTreePassManager & manager)
 
     if (settings.optimize_if_transform_strings_to_enum)
         manager.addPass(std::make_unique<IfTransformStringsToEnumPass>());
+
+    manager.addPass(std::make_unique<ConvertOrLikeChainPass>());
 }
 
 }
