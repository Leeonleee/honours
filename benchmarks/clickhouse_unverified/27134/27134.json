{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27134,
  "instance_id": "ClickHouse__ClickHouse-27134",
  "issue_numbers": [
    "3473"
  ],
  "base_commit": "3184902c6804ecc6de61238f58a3e1d8d2a69b67",
  "patch": "diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex c5e43449557e..5b204751ba01 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -197,7 +197,7 @@ class Client : public Poco::Util::Application\n     std::unique_ptr<ShellCommand> pager_cmd;\n \n     /// The user can specify to redirect query output to a file.\n-    std::optional<WriteBufferFromFile> out_file_buf;\n+    std::unique_ptr<WriteBuffer> out_file_buf;\n     BlockOutputStreamPtr block_out_stream;\n \n     /// The user could specify special file for server logs (stderr by default)\n@@ -2238,8 +2238,11 @@ class Client : public Poco::Util::Application\n                     const auto & out_file_node = query_with_output->out_file->as<ASTLiteral &>();\n                     const auto & out_file = out_file_node.value.safeGet<std::string>();\n \n-                    out_file_buf.emplace(out_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_EXCL | O_CREAT);\n-                    out_buf = &*out_file_buf;\n+                    out_file_buf = wrapWriteBufferWithCompressionMethod(\n+                        std::make_unique<WriteBufferFromFile>(out_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_EXCL | O_CREAT),\n+                        chooseCompressionMethod(out_file, \"\"),\n+                        /* compression level = */ 3\n+                    );\n \n                     // We are writing to file, so default format is the same as in non-interactive mode.\n                     if (is_interactive && is_default_format)\n@@ -2259,9 +2262,9 @@ class Client : public Poco::Util::Application\n \n             /// It is not clear how to write progress with parallel formatting. It may increase code complexity significantly.\n             if (!need_render_progress)\n-                block_out_stream = context->getOutputStreamParallelIfPossible(current_format, *out_buf, block);\n+                block_out_stream = context->getOutputStreamParallelIfPossible(current_format, out_file_buf ? *out_file_buf : *out_buf, block);\n             else\n-                block_out_stream = context->getOutputStream(current_format, *out_buf, block);\n+                block_out_stream = context->getOutputStream(current_format, out_file_buf ? *out_file_buf : *out_buf, block);\n \n             block_out_stream->writePrefix();\n         }\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 75b895548201..c59cbc772e7c 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -1010,22 +1010,31 @@ void executeQuery(\n             const auto * ast_query_with_output = dynamic_cast<const ASTQueryWithOutput *>(ast.get());\n \n             WriteBuffer * out_buf = &ostr;\n-            std::optional<WriteBufferFromFile> out_file_buf;\n+            std::unique_ptr<WriteBuffer> compressed_buffer;\n             if (ast_query_with_output && ast_query_with_output->out_file)\n             {\n                 if (!allow_into_outfile)\n                     throw Exception(\"INTO OUTFILE is not allowed\", ErrorCodes::INTO_OUTFILE_NOT_ALLOWED);\n \n                 const auto & out_file = ast_query_with_output->out_file->as<ASTLiteral &>().value.safeGet<std::string>();\n-                out_file_buf.emplace(out_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_EXCL | O_CREAT);\n-                out_buf = &*out_file_buf;\n+                compressed_buffer = wrapWriteBufferWithCompressionMethod(\n+                    std::make_unique<WriteBufferFromFile>(out_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_EXCL | O_CREAT),\n+                    chooseCompressionMethod(out_file, \"\"),\n+                    /* compression level = */ 3\n+                );\n             }\n \n             String format_name = ast_query_with_output && (ast_query_with_output->format != nullptr)\n                 ? getIdentifierName(ast_query_with_output->format)\n                 : context->getDefaultFormat();\n \n-            auto out = FormatFactory::instance().getOutputStreamParallelIfPossible(format_name, *out_buf, streams.in->getHeader(), context, {}, output_format_settings);\n+            auto out = FormatFactory::instance().getOutputStreamParallelIfPossible(\n+                format_name,\n+                compressed_buffer ? *compressed_buffer : *out_buf,\n+                streams.in->getHeader(),\n+                context,\n+                {},\n+                output_format_settings);\n \n             /// Save previous progress callback if any. TODO Do it more conveniently.\n             auto previous_progress_callback = context->getProgressCallback();\n@@ -1049,15 +1058,18 @@ void executeQuery(\n             const ASTQueryWithOutput * ast_query_with_output = dynamic_cast<const ASTQueryWithOutput *>(ast.get());\n \n             WriteBuffer * out_buf = &ostr;\n-            std::optional<WriteBufferFromFile> out_file_buf;\n+            std::unique_ptr<WriteBuffer> compressed_buffer;\n             if (ast_query_with_output && ast_query_with_output->out_file)\n             {\n                 if (!allow_into_outfile)\n                     throw Exception(\"INTO OUTFILE is not allowed\", ErrorCodes::INTO_OUTFILE_NOT_ALLOWED);\n \n                 const auto & out_file = typeid_cast<const ASTLiteral &>(*ast_query_with_output->out_file).value.safeGet<std::string>();\n-                out_file_buf.emplace(out_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_EXCL | O_CREAT);\n-                out_buf = &*out_file_buf;\n+                compressed_buffer = wrapWriteBufferWithCompressionMethod(\n+                    std::make_unique<WriteBufferFromFile>(out_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_EXCL | O_CREAT),\n+                    chooseCompressionMethod(out_file, \"\"),\n+                    /* compression level = */ 3\n+                );\n             }\n \n             String format_name = ast_query_with_output && (ast_query_with_output->format != nullptr)\n@@ -1071,7 +1083,14 @@ void executeQuery(\n                     return std::make_shared<MaterializingTransform>(header);\n                 });\n \n-                auto out = FormatFactory::instance().getOutputFormatParallelIfPossible(format_name, *out_buf, pipeline.getHeader(), context, {}, output_format_settings);\n+                auto out = FormatFactory::instance().getOutputFormatParallelIfPossible(\n+                    format_name,\n+                    compressed_buffer ? *compressed_buffer : *out_buf,\n+                    pipeline.getHeader(),\n+                    context,\n+                    {},\n+                    output_format_settings);\n+\n                 out->setAutoFlush();\n \n                 /// Save previous progress callback if any. TODO Do it more conveniently.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02001_compress_output_file.reference b/tests/queries/0_stateless/02001_compress_output_file.reference\nnew file mode 100644\nindex 000000000000..6f51dfc24e1e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02001_compress_output_file.reference\n@@ -0,0 +1,2 @@\n+Hello, World! From client.\n+Hello, World! From local.\ndiff --git a/tests/queries/0_stateless/02001_compress_output_file.sh b/tests/queries/0_stateless/02001_compress_output_file.sh\nnew file mode 100755\nindex 000000000000..11df227cc145\n--- /dev/null\n+++ b/tests/queries/0_stateless/02001_compress_output_file.sh\n@@ -0,0 +1,23 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+set -e\n+\n+[ -e \"${CLICKHOUSE_TMP}\"/test_compression_of_output_file_from_client.gz ] && rm \"${CLICKHOUSE_TMP}\"/test_compression_of_output_file_from_client.gz\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM (SELECT 'Hello, World! From client.') INTO OUTFILE '${CLICKHOUSE_TMP}/test_compression_of_output_file_from_client.gz'\"\n+gunzip ${CLICKHOUSE_TMP}/test_compression_of_output_file_from_client.gz\n+cat ${CLICKHOUSE_TMP}/test_compression_of_output_file_from_client\n+\n+rm -f \"${CLICKHOUSE_TMP}/test_compression_of_output_file_from_client\"\n+\n+[ -e \"${CLICKHOUSE_TMP}\"/test_compression_of_output_file_from_local.gz ] && rm \"${CLICKHOUSE_TMP}\"/test_compression_of_output_file_from_local.gz\n+\n+${CLICKHOUSE_LOCAL} --query \"SELECT * FROM (SELECT 'Hello, World! From local.') INTO OUTFILE '${CLICKHOUSE_TMP}/test_compression_of_output_file_from_local.gz'\"\n+gunzip ${CLICKHOUSE_TMP}/test_compression_of_output_file_from_local.gz\n+cat ${CLICKHOUSE_TMP}/test_compression_of_output_file_from_local\n+\n+rm -f \"${CLICKHOUSE_TMP}/test_compression_of_output_file_from_local\"\n",
  "problem_statement": "compressed output formats\nQuite often I have cases when some data need to be extracted from ClickHouse and passed/uploaded somewhere.\r\n\r\nRight now I do `SELECT ... INTO OUTFILE ... FORMAT ... ` and compress the resulting file afterwards. In some cases compression takes more time than extracting data from clickhouse :)\r\n\r\nAFAIK for clickhouse steaming compressed data should not be a big problem, so may be for ```INTO OUTFILE ... ``` additional clause like ```COMPRESSION='gzip'```  or even just ```INTO COMPRESSED OUTFILE ...``` can be added. \r\n \n",
  "hints_text": "We can support compression for INTO OUTFILE in the same way as for File-related storages (with a switch: `auto`, `none`, `gz`, `br` where auto means \"detect by file extension\" and it is by default).\r\n\r\nThe question is where to place this switch: in settings (easy) or in special syntax clause.\r\nI prefer first. (Most of the time, the default (autodetect) will be used and it will work as expected magically).\r\n\nThis will be **VERY** useful. Our **.native** backup files are quite huge, so we smash them into tarballs after output with the **--remove-files** flag. This way we reduce their size about 5 times.",
  "created_at": "2021-08-03T12:00:44Z",
  "modified_files": [
    "programs/client/Client.cpp",
    "src/Interpreters/executeQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02001_compress_output_file.reference",
    "b/tests/queries/0_stateless/02001_compress_output_file.sh"
  ]
}