{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25960,
  "instance_id": "ClickHouse__ClickHouse-25960",
  "issue_numbers": [
    "11124"
  ],
  "base_commit": "c68c74634d077c4af3115193cc230cb51b6f8286",
  "patch": "diff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 28a12f6aa2d5..82a006427dfa 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -9,6 +9,7 @@\n #include <Parsers/ASTIdentifier.h>\n \n #include <IO/ReadBufferFromFile.h>\n+#include <IO/ReadBufferFromFileDescriptor.h>\n #include <IO/ReadHelpers.h>\n #include <IO/WriteBufferFromFile.h>\n #include <IO/WriteHelpers.h>\n@@ -24,6 +25,7 @@\n #include <Storages/ColumnsDescription.h>\n #include <Storages/StorageInMemoryMetadata.h>\n \n+#include <sys/stat.h>\n #include <fcntl.h>\n #include <unistd.h>\n \n@@ -55,6 +57,8 @@ namespace ErrorCodes\n     extern const int FILE_DOESNT_EXIST;\n     extern const int TIMEOUT_EXCEEDED;\n     extern const int INCOMPATIBLE_COLUMNS;\n+    extern const int CANNOT_READ_FROM_FILE_DESCRIPTOR;\n+    extern const int CANNOT_STAT;\n }\n \n namespace\n@@ -298,23 +302,6 @@ class StorageFileSource : public SourceWithProgress\n     {\n         if (storage->use_table_fd)\n         {\n-            unique_lock = std::unique_lock(storage->rwlock, getLockTimeout(context));\n-            if (!unique_lock)\n-                throw Exception(\"Lock timeout exceeded\", ErrorCodes::TIMEOUT_EXCEEDED);\n-\n-            /// We could use common ReadBuffer and WriteBuffer in storage to leverage cache\n-            ///  and add ability to seek unseekable files, but cache sync isn't supported.\n-\n-            if (storage->table_fd_was_used) /// We need seek to initial position\n-            {\n-                if (storage->table_fd_init_offset < 0)\n-                    throw Exception(\"File descriptor isn't seekable, inside \" + storage->getName(), ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n-\n-                /// ReadBuffer's seek() doesn't make sense, since cache is empty\n-                if (lseek(storage->table_fd, storage->table_fd_init_offset, SEEK_SET) < 0)\n-                    throwFromErrno(\"Cannot seek file descriptor, inside \" + storage->getName(), ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n-            }\n-\n             storage->table_fd_was_used = true;\n         }\n         else\n@@ -497,6 +484,7 @@ Pipe StorageFile::read(\n     }\n \n     auto this_ptr = std::static_pointer_cast<StorageFile>(shared_from_this());\n+    ReadBufferFromFileDescriptorPRead table_fd_seek(this_ptr->table_fd);\n \n     if (num_streams > paths.size())\n         num_streams = paths.size();\n@@ -519,6 +507,27 @@ Pipe StorageFile::read(\n             else\n                 return metadata_snapshot->getColumns();\n         };\n+        // if we do multiple reads from pipe, we want to check if pipe is a regular file or a pipe\n+        if (this_ptr->table_fd_was_used)\n+        {\n+            struct stat fd_stat;\n+            if (fstat(this_ptr->table_fd, &fd_stat) == -1)\n+            {\n+                throw Exception(\"Cannot stat table file descriptor, inside \" + this_ptr->getName(), ErrorCodes::CANNOT_STAT);\n+            }\n+            if (S_ISREG(fd_stat.st_mode))\n+            {\n+                if (this_ptr->table_fd_init_offset < 0)\n+                {\n+                    throw Exception(\"File descriptor isn't seekable, inside \" + this_ptr->getName(), ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n+                }\n+            }\n+            else\n+            {\n+                // else if fd is not a regular file, then throw an Exception\n+                throw Exception(\"Cannot read from a pipe twice\", ErrorCodes::CANNOT_READ_FROM_FILE_DESCRIPTOR);\n+            }\n+        }\n         pipes.emplace_back(std::make_shared<StorageFileSource>(\n             this_ptr, metadata_snapshot, context, max_block_size, files_info, get_columns_for_format()));\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01947_multiple_pipe_read.reference b/tests/queries/0_stateless/01947_multiple_pipe_read.reference\nnew file mode 100644\nindex 000000000000..5a0b27d4867e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01947_multiple_pipe_read.reference\n@@ -0,0 +1,27 @@\n+File generated:\n+0,\"BBB\"\n+1,\"BBB\"\n+2,\"BBB\"\n+3,\"BBB\"\n+4,\"AAA\"\n+5,\"BBB\"\n+6,\"AAA\"\n+******************\n+Attempt to read twice from a regular file\n+0,\"BBB\"\n+1,\"BBB\"\n+2,\"BBB\"\n+3,\"BBB\"\n+4,\"AAA\"\n+5,\"BBB\"\n+6,\"AAA\"\n+0,\"BBB\"\n+1,\"BBB\"\n+2,\"BBB\"\n+3,\"BBB\"\n+4,\"AAA\"\n+5,\"BBB\"\n+6,\"AAA\"\n+******************\n+Attempt to read twice from a pipe\n+OK: stderr contains a message 'Cannot read from a pipe twice'\ndiff --git a/tests/queries/0_stateless/01947_multiple_pipe_read.sh b/tests/queries/0_stateless/01947_multiple_pipe_read.sh\nnew file mode 100755\nindex 000000000000..77176223cd4b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01947_multiple_pipe_read.sh\n@@ -0,0 +1,23 @@\n+#!/usr/bin/env bash\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+SAMPLE_FILE=$(mktemp 01947_multiple_pipe_read_sample_data_XXXXXX.csv)\n+STD_ERROR_CAPTURED=$(mktemp 01947_multiple_pipe_read_std_error_captured_XXXXXX.log)\n+\n+echo 'File generated:'\n+${CLICKHOUSE_LOCAL} -q \"SELECT number, if(number in (4,6), 'AAA', 'BBB') from numbers(7) FORMAT CSV\" --format_csv_delimiter=, >\"$SAMPLE_FILE\"\n+cat \"$SAMPLE_FILE\"\n+\n+echo '******************'\n+echo 'Attempt to read twice from a regular file'\n+${CLICKHOUSE_LOCAL} --structure 'key String' -q 'select * from table; select * from table;' --file \"$SAMPLE_FILE\"\n+\n+echo '******************'\n+echo 'Attempt to read twice from a pipe'\n+echo 1 | ${CLICKHOUSE_LOCAL} --structure \"a int\" --query \"select a from table where a in (select a from table)\" 2>\"$STD_ERROR_CAPTURED\"\n+expected_error_message='Cannot read from a pipe twice'\n+cat \"$STD_ERROR_CAPTURED\" | grep -q \"$expected_error_message\" && echo \"OK: stderr contains a message '$expected_error_message'\" || echo \"FAILED: Error message is wrong\"\n+\n+rm \"$SAMPLE_FILE\" \"$STD_ERROR_CAPTURED\"\n",
  "problem_statement": "clickhouse-local freezes on multiple read from pipe\n```\r\necho 1 | build-clang10/programs/clickhouse-local --structure \"a int\" --query \"select a from table where a in (select a from table)\"\r\n```\r\n\r\nThis does not finish. Works fine if I put this `1` into a file and specify it with `--file`.\r\nThis is a usability problem for using `clickhouse-local` in a pipeline. Also sometimes it doesn't freeze but returns unexpected result, which is even worse. I've had this happen but don't remember the exact scenario now.\n",
  "hints_text": "This is considered as the expected behaviour.\r\nYou have specified that table data is streamed from pipe. You cannot read this data twice.\r\n\r\nBut we can do better:\r\n- check if it's a regular file or pipe;\r\n- if it's a regular file, seek to begin before read;\r\n- if it's pipe, throw exception if we are trying to read the same pipe twice.\n@Amesaru\nAmesaru did not try to do this task.\nI'll try to do the task.",
  "created_at": "2021-07-03T18:36:05Z",
  "modified_files": [
    "src/Storages/StorageFile.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01947_multiple_pipe_read.reference",
    "b/tests/queries/0_stateless/01947_multiple_pipe_read.sh"
  ]
}