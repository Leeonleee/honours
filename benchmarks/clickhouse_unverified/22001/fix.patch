diff --git a/src/Functions/registerFunctionsMiscellaneous.cpp b/src/Functions/registerFunctionsMiscellaneous.cpp
index 592f0d6774d0..ca9bc32486e6 100644
--- a/src/Functions/registerFunctionsMiscellaneous.cpp
+++ b/src/Functions/registerFunctionsMiscellaneous.cpp
@@ -41,7 +41,8 @@ void registerFunctionThrowIf(FunctionFactory &);
 void registerFunctionVersion(FunctionFactory &);
 void registerFunctionBuildId(FunctionFactory &);
 void registerFunctionUptime(FunctionFactory &);
-void registerFunctionTimeZone(FunctionFactory &);
+void registerFunctionTimezone(FunctionFactory &);
+void registerFunctionTimezoneOf(FunctionFactory &);
 void registerFunctionRunningAccumulate(FunctionFactory &);
 void registerFunctionRunningDifference(FunctionFactory &);
 void registerFunctionRunningDifferenceStartingWithFirstValue(FunctionFactory &);
@@ -111,7 +112,8 @@ void registerFunctionsMiscellaneous(FunctionFactory & factory)
     registerFunctionVersion(factory);
     registerFunctionBuildId(factory);
     registerFunctionUptime(factory);
-    registerFunctionTimeZone(factory);
+    registerFunctionTimezone(factory);
+    registerFunctionTimezoneOf(factory);
     registerFunctionRunningAccumulate(factory);
     registerFunctionRunningDifference(factory);
     registerFunctionRunningDifferenceStartingWithFirstValue(factory);
diff --git a/src/Functions/timezone.cpp b/src/Functions/timezone.cpp
index 4522f21c8b2e..2cd0c28612ba 100644
--- a/src/Functions/timezone.cpp
+++ b/src/Functions/timezone.cpp
@@ -12,13 +12,13 @@ namespace
 
 /** Returns the server time zone.
   */
-class FunctionTimeZone : public IFunction
+class FunctionTimezone : public IFunction
 {
 public:
     static constexpr auto name = "timezone";
     static FunctionPtr create(const Context &)
     {
-        return std::make_shared<FunctionTimeZone>();
+        return std::make_shared<FunctionTimezone>();
     }
 
     String getName() const override
@@ -45,9 +45,10 @@ class FunctionTimeZone : public IFunction
 
 }
 
-void registerFunctionTimeZone(FunctionFactory & factory)
+void registerFunctionTimezone(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionTimeZone>();
+    factory.registerFunction<FunctionTimezone>();
+    factory.registerAlias("timeZone", "timezone");
 }
 
 }
diff --git a/src/Functions/timezoneOf.cpp b/src/Functions/timezoneOf.cpp
new file mode 100644
index 000000000000..1d007a6e10ee
--- /dev/null
+++ b/src/Functions/timezoneOf.cpp
@@ -0,0 +1,118 @@
+#include <Functions/IFunctionImpl.h>
+#include <Functions/FunctionFactory.h>
+#include <DataTypes/DataTypeString.h>
+#include <DataTypes/DataTypeNullable.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <common/DateLUTImpl.h>
+#include <Core/Field.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+}
+
+
+namespace
+{
+
+
+/** timezoneOf(x) - get the name of the timezone of DateTime data type.
+  * Example: Europe/Moscow.
+  */
+class ExecutableFunctionTimezoneOf : public IExecutableFunctionImpl
+{
+public:
+    static constexpr auto name = "timezoneOf";
+    String getName() const override { return name; }
+
+    bool useDefaultImplementationForNulls() const override { return false; }
+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }
+
+    /// Execute the function on the columns.
+    ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        DataTypePtr type_no_nullable = removeNullable(arguments[0].type);
+
+        return DataTypeString().createColumnConst(input_rows_count,
+            dynamic_cast<const TimezoneMixin &>(*type_no_nullable).getTimeZone().getTimeZone());
+    }
+};
+
+
+class BaseFunctionTimezoneOf : public IFunctionBaseImpl
+{
+public:
+    BaseFunctionTimezoneOf(DataTypes argument_types_, DataTypePtr return_type_)
+        : argument_types(std::move(argument_types_)), return_type(std::move(return_type_)) {}
+
+    static constexpr auto name = "timezoneOf";
+    String getName() const override { return name; }
+
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
+
+    const DataTypes & getArgumentTypes() const override { return argument_types; }
+    const DataTypePtr & getResultType() const override { return return_type; }
+
+    ExecutableFunctionImplPtr prepare(const ColumnsWithTypeAndName &) const override
+    {
+        return std::make_unique<ExecutableFunctionTimezoneOf>();
+    }
+
+    ColumnPtr getResultIfAlwaysReturnsConstantAndHasArguments(const ColumnsWithTypeAndName & arguments) const override
+    {
+        DataTypePtr type_no_nullable = removeNullable(arguments[0].type);
+
+        return DataTypeString().createColumnConst(1,
+            dynamic_cast<const TimezoneMixin &>(*type_no_nullable).getTimeZone().getTimeZone());
+    }
+
+private:
+    DataTypes argument_types;
+    DataTypePtr return_type;
+};
+
+
+class FunctionTimezoneOfBuilder : public IFunctionOverloadResolverImpl
+{
+public:
+    static constexpr auto name = "timezoneOf";
+    String getName() const override { return name; }
+    static FunctionOverloadResolverImplPtr create(const Context &) { return std::make_unique<FunctionTimezoneOfBuilder>(); }
+
+    size_t getNumberOfArguments() const override { return 1; }
+
+    DataTypePtr getReturnType(const DataTypes & types) const override
+    {
+        DataTypePtr type_no_nullable = removeNullable(types[0]);
+
+        if (isDateTime(type_no_nullable) || isDateTime64(type_no_nullable))
+            return std::make_shared<DataTypeString>();
+        else
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Bad argument for function {}, should be DateTime or DateTime64", name);
+    }
+
+    FunctionBaseImplPtr build(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override
+    {
+        return std::make_unique<BaseFunctionTimezoneOf>(DataTypes{arguments[0].type}, return_type);
+    }
+
+    bool useDefaultImplementationForNulls() const override { return false; }
+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }
+    ColumnNumbers getArgumentsThatDontImplyNullableReturnType(size_t /*number_of_arguments*/) const override { return {0}; }
+};
+
+}
+
+void registerFunctionTimezoneOf(FunctionFactory & factory)
+{
+    factory.registerFunction<FunctionTimezoneOfBuilder>();
+    factory.registerAlias("timeZoneOf", "timezoneOf");
+}
+
+}
+
diff --git a/src/Functions/toTimeZone.cpp b/src/Functions/toTimezone.cpp
similarity index 90%
rename from src/Functions/toTimeZone.cpp
rename to src/Functions/toTimezone.cpp
index fbf3a0778a61..d12f926b2847 100644
--- a/src/Functions/toTimeZone.cpp
+++ b/src/Functions/toTimezone.cpp
@@ -21,11 +21,11 @@ namespace
 {
 
 /// Just changes time zone information for data type. The calculation is free.
-class FunctionToTimeZone : public IFunction
+class FunctionToTimezone : public IFunction
 {
 public:
-    static constexpr auto name = "toTimeZone";
-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionToTimeZone>(); }
+    static constexpr auto name = "toTimezone";
+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionToTimezone>(); }
 
     String getName() const override
     {
@@ -64,7 +64,8 @@ class FunctionToTimeZone : public IFunction
 
 void registerFunctionToTimeZone(FunctionFactory & factory)
 {
-    factory.registerFunction<FunctionToTimeZone>();
+    factory.registerFunction<FunctionToTimezone>();
+    factory.registerAlias("toTimeZone", "toTimezone");
 }
 
 }
diff --git a/src/Functions/ya.make b/src/Functions/ya.make
index 3ac64828b9c1..aed2bd9b70d6 100644
--- a/src/Functions/ya.make
+++ b/src/Functions/ya.make
@@ -467,6 +467,7 @@ SRCS(
     timeSlot.cpp
     timeSlots.cpp
     timezone.cpp
+    timezoneOf.cpp
     timezoneOffset.cpp
     toColumnTypeName.cpp
     toCustomWeek.cpp
@@ -506,7 +507,7 @@ SRCS(
     toStartOfTenMinutes.cpp
     toStartOfYear.cpp
     toTime.cpp
-    toTimeZone.cpp
+    toTimezone.cpp
     toTypeName.cpp
     toUnixTimestamp64Micro.cpp
     toUnixTimestamp64Milli.cpp
