{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 84305,
  "instance_id": "ClickHouse__ClickHouse-84305",
  "issue_numbers": [
    "75485"
  ],
  "base_commit": "b28a1e80588789f54ad9872258adf069e36820d5",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeIndexSet.cpp b/src/Storages/MergeTree/MergeTreeIndexSet.cpp\nindex 65796f1e0371..b4792e15d8cb 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexSet.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexSet.cpp\n@@ -404,9 +404,13 @@ bool MergeTreeIndexConditionSet::mayBeTrueOnGranule(MergeTreeIndexGranulePtr idx\n     actions->execute(result);\n \n     const auto & column = result.getByName(actions_output_column_name).column;\n+    const bool nullable = column->isNullable();\n \n     for (size_t i = 0; i < size; ++i)\n-        if (!column->isNullAt(i) && (column->get64(i) & 1))\n+        /// The first part of the condition checks if any of them pass the filter.\n+        /// The second part of the conditions checks if column is nullable, in that case there is no need to check null map since filter function possibly handles null values.\n+        /// Only in case the column is not nullable, check the null map.\n+        if ((column->get64(i) & 1) && (nullable || !column->isNullAt(i)))\n             return true;\n \n     return false;\n@@ -451,11 +455,13 @@ MergeTreeIndexConditionSet::FilteredGranules MergeTreeIndexConditionSet::getPoss\n \n     const auto * col_uint8 = typeid_cast<const ColumnUInt8 *>(column.get());\n     const NullMap * null_map = nullptr;\n+    bool nullable = false;\n \n     if (const auto * col_nullable = checkAndGetColumn<ColumnNullable>(&*column))\n     {\n         col_uint8 = typeid_cast<const ColumnUInt8 *>(&col_nullable->getNestedColumn());\n         null_map = &col_nullable->getNullMapData();\n+        nullable = true;\n     }\n \n     if (!col_uint8)\n@@ -483,17 +489,18 @@ MergeTreeIndexConditionSet::FilteredGranules MergeTreeIndexConditionSet::getPoss\n         {\n             /// This granule has set elements - check if any of them pass the filter.\n             chassert(current_granule == current_granule_in_block);\n-            bool passed = false;\n-            while (block_pos < block_size && current_granule_in_block == granule_nums[block_pos])\n+            for (bool passed = false; block_pos < block_size && current_granule_in_block == granule_nums[block_pos]; ++block_pos)\n             {\n                 if (!passed)\n                 {\n-                    passed = (!null_map || !(*null_map)[block_pos]) && (filter_result[block_pos] & 1);\n+                    /// The first part of the condition checks if any of them pass the filter.\n+                    /// The second part of the conditions checks if column is nullable, in that case there is no need to check null map since filter function possibly handles null values.\n+                    /// Only in case the column is not nullable, check the null map.\n+                    passed = (filter_result[block_pos] & 1) && (nullable || !null_map || !(*null_map)[block_pos]);\n                     if (passed)\n                         res.push_back(current_granule);\n                     /// After we found that it passes, we just iterate over the block to the next granule or the end.\n                 }\n-                ++block_pos;\n             }\n         }\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.reference b/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.reference\nindex e6ce356cd457..9febebee174a 100644\n--- a/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.reference\n+++ b/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.reference\n@@ -1,1 +1,9 @@\n v1\tv2\n+Bulk filtering enabled\n+2\n+3\n+2\n+Bulk filtering disabled\n+2\n+3\n+2\ndiff --git a/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.sql b/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.sql\nindex fed030f170dc..dee0418d107e 100644\n--- a/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.sql\n+++ b/tests/queries/0_stateless/02789_set_index_nullable_condition_bug.sql\n@@ -1,15 +1,118 @@\n-drop table if exists test_table;\n-CREATE TABLE test_table\n+DROP TABLE IF EXISTS tab;\n+\n+CREATE TABLE tab\n (\n     col1 String,\n     col2 String,\n     INDEX test_table_col2_idx col2 TYPE set(0) GRANULARITY 1\n ) ENGINE = MergeTree()\n-      ORDER BY col1\n+ORDER BY col1\n AS SELECT 'v1', 'v2';\n \n-SELECT * FROM test_table\n+SELECT * FROM tab\n WHERE 1 == 1 AND col1 == col1 OR\n        0 AND col2 == NULL;\n \n-drop table if exists test_table;\n+DROP TABLE tab;\n+\n+-- Test for issue #75485\n+\n+SELECT 'Bulk filtering enabled';\n+set secondary_indices_enable_bulk_filtering = 1;\n+\n+CREATE TABLE tab\n+(\n+    col Nullable(Boolean),\n+    INDEX col_idx col TYPE set(0)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO tab VALUES\n+    (DEFAULT),\n+    (DEFAULT);\n+\n+SELECT count() FROM tab WHERE col OR col IS NULL;\n+DROP TABLE tab;\n+\n+CREATE TABLE tab\n+(\n+    col Nullable(Boolean),\n+    INDEX col_idx col TYPE set(0)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO tab VALUES\n+    (DEFAULT),\n+    (DEFAULT),\n+    (TRUE);\n+\n+SELECT count() FROM tab WHERE col OR col IS NULL;\n+DROP TABLE tab;\n+\n+CREATE TABLE tab\n+(\n+    col Nullable(Boolean),\n+    INDEX col_idx col TYPE set(0)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO tab VALUES\n+    (DEFAULT),\n+    (DEFAULT),\n+    (FALSE);\n+\n+SELECT count() FROM tab WHERE col OR col IS NULL;\n+DROP TABLE tab;\n+\n+SELECT 'Bulk filtering disabled';\n+set secondary_indices_enable_bulk_filtering = 0;\n+\n+CREATE TABLE tab\n+(\n+    col Nullable(Boolean),\n+    INDEX col_idx col TYPE set(0)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO tab VALUES\n+    (DEFAULT),\n+    (DEFAULT);\n+\n+SELECT count() FROM tab WHERE col OR col IS NULL;\n+DROP TABLE tab;\n+\n+CREATE TABLE tab\n+(\n+    col Nullable(Boolean),\n+    INDEX col_idx col TYPE set(0)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO tab VALUES\n+    (DEFAULT),\n+    (DEFAULT),\n+    (TRUE);\n+\n+SELECT count() FROM tab WHERE col OR col IS NULL;\n+DROP TABLE tab;\n+\n+CREATE TABLE tab\n+(\n+    col Nullable(Boolean),\n+    INDEX col_idx col TYPE set(0)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+INSERT INTO tab VALUES\n+    (DEFAULT),\n+    (DEFAULT),\n+    (FALSE);\n+\n+SELECT count() FROM tab WHERE col OR col IS NULL;\n+DROP TABLE tab;\n",
  "problem_statement": "Bad index default value\n### Describe the bug\n\nAfter inserting a default value into a column backed by a set index, the count() query returns a wrong result. Check Fiddle.\n\n### How to reproduce\n\nRun Fiddle: https://fiddle.clickhouse.com/0cf22543-05a2-49a7-b4e1-1fe61407d251 \n\n### Error message and/or stacktrace\n\n_No response_\n",
  "hints_text": "Hi @PedroTadim, can I work on this task ?",
  "created_at": "2025-07-23T14:39:48Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeIndexSet.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02789_set_index_nullable_condition_bug.reference",
    "tests/queries/0_stateless/02789_set_index_nullable_condition_bug.sql"
  ]
}