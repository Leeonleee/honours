{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 67930,
  "instance_id": "ClickHouse__ClickHouse-67930",
  "issue_numbers": [
    "67742"
  ],
  "base_commit": "82ffa75b7a2375cf073d12de256416f6ebf3fe0c",
  "patch": "diff --git a/docs/en/engines/table-engines/mergetree-family/mergetree.md b/docs/en/engines/table-engines/mergetree-family/mergetree.md\nindex 7ffbd9a5baef..183b94f46418 100644\n--- a/docs/en/engines/table-engines/mergetree-family/mergetree.md\n+++ b/docs/en/engines/table-engines/mergetree-family/mergetree.md\n@@ -1005,7 +1005,7 @@ They can be used for prewhere optimization only if we enable `set allow_statisti\n \n ## Column-level Settings {#column-level-settings}\n \n-Certain MergeTree settings can be override at column level:\n+Certain MergeTree settings can be overridden at column level:\n \n - `max_compress_block_size` \u2014 Maximum size of blocks of uncompressed data before compressing for writing to a table.\n - `min_compress_block_size` \u2014 Minimum size of blocks of uncompressed data required for compression when writing the next mark.\ndiff --git a/src/Storages/Statistics/ConditionSelectivityEstimator.cpp b/src/Storages/Statistics/ConditionSelectivityEstimator.cpp\nindex 57dff958b9a9..432659f51f8d 100644\n--- a/src/Storages/Statistics/ConditionSelectivityEstimator.cpp\n+++ b/src/Storages/Statistics/ConditionSelectivityEstimator.cpp\n@@ -19,7 +19,7 @@ void ConditionSelectivityEstimator::ColumnSelectivityEstimator::merge(String par\n Float64 ConditionSelectivityEstimator::ColumnSelectivityEstimator::estimateLess(const Field & val, Float64 rows) const\n {\n     if (part_statistics.empty())\n-        return default_normal_cond_factor * rows;\n+        return default_cond_range_factor * rows;\n     Float64 result = 0;\n     Float64 part_rows = 0;\n     for (const auto & [key, estimator] : part_statistics)\n@@ -39,13 +39,7 @@ Float64 ConditionSelectivityEstimator::ColumnSelectivityEstimator::estimateEqual\n {\n     if (part_statistics.empty())\n     {\n-        auto float_val = StatisticsUtils::tryConvertToFloat64(val);\n-        if (!float_val)\n-            return default_unknown_cond_factor * rows;\n-        else if (float_val.value() < - threshold || float_val.value() > threshold)\n-            return default_normal_cond_factor * rows;\n-        else\n-            return default_good_cond_factor * rows;\n+        return default_cond_equal_factor * rows;\n     }\n     Float64 result = 0;\n     Float64 partial_cnt = 0;\n@@ -149,30 +143,22 @@ Float64 ConditionSelectivityEstimator::estimateRowCount(const RPNBuilderTreeNode\n \n     auto [op, val] = extractBinaryOp(node, col);\n \n-    if (op == \"equals\")\n+    if (dummy)\n     {\n-        if (dummy)\n-        {\n-            auto float_val = StatisticsUtils::tryConvertToFloat64(val);\n-            if (!float_val || (float_val < - threshold || float_val > threshold))\n-                return default_normal_cond_factor * total_rows;\n-            else\n-                return default_good_cond_factor * total_rows;\n-        }\n-        return estimator.estimateEqual(val, total_rows);\n+        if (op == \"equals\")\n+            return default_cond_equal_factor * total_rows;\n+        else if (op == \"less\" || op == \"lessOrEquals\" || op == \"greater\" || op == \"greaterOrEquals\")\n+            return default_cond_range_factor * total_rows;\n+        else\n+            return default_unknown_cond_factor * total_rows;\n     }\n+\n+    if (op == \"equals\")\n+        return estimator.estimateEqual(val, total_rows);\n     else if (op == \"less\" || op == \"lessOrEquals\")\n-    {\n-        if (dummy)\n-            return default_normal_cond_factor * total_rows;\n         return estimator.estimateLess(val, total_rows);\n-    }\n     else if (op == \"greater\" || op == \"greaterOrEquals\")\n-    {\n-        if (dummy)\n-            return default_normal_cond_factor * total_rows;\n         return estimator.estimateGreater(val, total_rows);\n-    }\n     else\n         return default_unknown_cond_factor * total_rows;\n }\ndiff --git a/src/Storages/Statistics/ConditionSelectivityEstimator.h b/src/Storages/Statistics/ConditionSelectivityEstimator.h\nindex ce7fdd12e925..269ee9ac6cb7 100644\n--- a/src/Storages/Statistics/ConditionSelectivityEstimator.h\n+++ b/src/Storages/Statistics/ConditionSelectivityEstimator.h\n@@ -38,12 +38,10 @@ class ConditionSelectivityEstimator\n \n     std::pair<String, Field> extractBinaryOp(const RPNBuilderTreeNode & node, const String & column_name) const;\n \n-    static constexpr auto default_good_cond_factor = 0.1;\n-    static constexpr auto default_normal_cond_factor = 0.5;\n-    static constexpr auto default_unknown_cond_factor = 1.0;\n-    /// Conditions like \"x = N\" are considered good if abs(N) > threshold.\n-    /// This is used to assume that condition is likely to have good selectivity.\n-    static constexpr auto threshold = 2;\n+    /// Used to estimate the selectivity of a condition when there is no statistics.\n+    static constexpr auto default_cond_range_factor = 0.5;\n+    static constexpr auto default_cond_equal_factor = 0.01;\n+    static constexpr auto default_unknown_cond_factor = 1;\n \n     UInt64 total_rows = 0;\n     std::map<String, ColumnSelectivityEstimator> column_estimators;\ndiff --git a/src/Storages/Statistics/Statistics.cpp b/src/Storages/Statistics/Statistics.cpp\nindex ade3326288a5..fd686c5f0aae 100644\n--- a/src/Storages/Statistics/Statistics.cpp\n+++ b/src/Storages/Statistics/Statistics.cpp\n@@ -1,14 +1,17 @@\n #include <Storages/Statistics/Statistics.h>\n+#include <Common/Exception.h>\n+#include <Common/FieldVisitorConvertToNumber.h>\n+#include <Common/logger_useful.h>\n+#include <DataTypes/DataTypeFactory.h>\n #include <IO/ReadHelpers.h>\n #include <IO/WriteHelpers.h>\n+#include <Interpreters/convertFieldToType.h>\n #include <Storages/ColumnsDescription.h>\n #include <Storages/Statistics/ConditionSelectivityEstimator.h>\n #include <Storages/Statistics/StatisticsCountMinSketch.h>\n #include <Storages/Statistics/StatisticsTDigest.h>\n #include <Storages/Statistics/StatisticsUniq.h>\n #include <Storages/StatisticsDescription.h>\n-#include <Common/Exception.h>\n-#include <Common/logger_useful.h>\n \n \n #include \"config.h\" /// USE_DATASKETCHES\n@@ -27,33 +30,26 @@ enum StatisticsFileVersion : UInt16\n     V0 = 0,\n };\n \n-std::optional<Float64> StatisticsUtils::tryConvertToFloat64(const Field & field)\n+std::optional<Float64> StatisticsUtils::tryConvertToFloat64(const Field & value, const DataTypePtr & data_type)\n {\n-    switch (field.getType())\n+    if (data_type->isValueRepresentedByNumber())\n     {\n-        case Field::Types::Int64:\n-            return field.get<Int64>();\n-        case Field::Types::UInt64:\n-            return field.get<UInt64>();\n-        case Field::Types::Float64:\n-            return field.get<Float64>();\n-        case Field::Types::Int128:\n-            return field.get<Int128>();\n-        case Field::Types::UInt128:\n-            return field.get<UInt128>();\n-        case Field::Types::Int256:\n-            return field.get<Int256>();\n-        case Field::Types::UInt256:\n-            return field.get<UInt256>();\n-        default:\n+        Field value_converted;\n+\n+        if (isInteger(data_type) && (value.getType() == Field::Types::Float64 || value.getType() == Field::Types::String))\n+            /// For case val_int32 < 10.5 or val_int32 < '10.5' we should convert 10.5 to Float64.\n+            value_converted = convertFieldToType(value, *DataTypeFactory::instance().get(\"Float64\"));\n+        else\n+            /// We should convert value to the real column data type and then translate it to Float64.\n+            /// For example for expression col_date > '2024-08-07', if we directly convert '2024-08-07' to Float64, we will get null.\n+            value_converted = convertFieldToType(value, *data_type);\n+\n+        if (value_converted.isNull())\n             return {};\n-    }\n-}\n \n-std::optional<String> StatisticsUtils::tryConvertToString(const DB::Field & field)\n-{\n-    if (field.getType() == Field::Types::String)\n-        return field.get<String>();\n+        Float64 value_as_float = applyVisitor(FieldVisitorConvertToNumber<Float64>(), value_converted);\n+        return value_as_float;\n+    }\n     return {};\n }\n \n@@ -89,21 +85,23 @@ Float64 IStatistics::estimateLess(const Field & /*val*/) const\n     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Less-than estimation is not implemented for this type of statistics\");\n }\n \n-/// -------------------------------------\n-/// Implementation of the estimation:\n-/// Note: Each statistics object supports certain types predicates natively, e.g.\n-/// - TDigest: '< X' (less-than predicates)\n-/// - Count-min sketches: '= X' (equal predicates)\n-/// - Uniq (HyperLogLog): 'count distinct(*)' (column cardinality)\n-/// If multiple statistics objects are available per column, it is sometimes also possible to combine them in a clever way.\n-/// For that reason, all estimation are performed in a central place (here), and we don't simply pass the predicate to the first statistics\n-/// object that supports it natively.\n+/// Notes:\n+/// - Statistics object usually only support estimation for certain types of predicates, e.g.\n+///    - TDigest: '< X' (less-than predicates)\n+///    - Count-min sketches: '= X' (equal predicates)\n+///    - Uniq (HyperLogLog): 'count distinct(*)' (column cardinality)\n+///\n+/// If multiple statistics objects in a column support estimating a predicate, we want to try statistics in order of descending accuracy\n+/// (e.g. MinMax statistics are simpler than TDigest statistics and thus worse for estimating 'less' predicates).\n+///\n+/// Sometimes, it is possible to combine multiple statistics in a clever way. For that reason, all estimation are performed in a central\n+/// place (here), and we don't simply pass the predicate to the first statistics object that supports it natively.\n \n Float64 ColumnStatistics::estimateLess(const Field & val) const\n {\n     if (stats.contains(StatisticsType::TDigest))\n         return stats.at(StatisticsType::TDigest)->estimateLess(val);\n-    return rows * ConditionSelectivityEstimator::default_normal_cond_factor;\n+    return rows * ConditionSelectivityEstimator::default_cond_range_factor;\n }\n \n Float64 ColumnStatistics::estimateGreater(const Field & val) const\n@@ -113,8 +111,7 @@ Float64 ColumnStatistics::estimateGreater(const Field & val) const\n \n Float64 ColumnStatistics::estimateEqual(const Field & val) const\n {\n-    auto float_val = StatisticsUtils::tryConvertToFloat64(val);\n-    if (float_val.has_value() && stats.contains(StatisticsType::Uniq) && stats.contains(StatisticsType::TDigest))\n+    if (stats_desc.data_type->isValueRepresentedByNumber() && stats.contains(StatisticsType::Uniq) && stats.contains(StatisticsType::TDigest))\n     {\n         /// 2048 is the default number of buckets in TDigest. In this case, TDigest stores exactly one value (with many rows) for every bucket.\n         if (stats.at(StatisticsType::Uniq)->estimateCardinality() < 2048)\n@@ -124,10 +121,7 @@ Float64 ColumnStatistics::estimateEqual(const Field & val) const\n     if (stats.contains(StatisticsType::CountMinSketch))\n         return stats.at(StatisticsType::CountMinSketch)->estimateEqual(val);\n #endif\n-    if (!float_val.has_value() && (float_val < - ConditionSelectivityEstimator::threshold || float_val > ConditionSelectivityEstimator::threshold))\n-        return rows * ConditionSelectivityEstimator::default_normal_cond_factor;\n-    else\n-        return rows * ConditionSelectivityEstimator::default_good_cond_factor;\n+    return rows * ConditionSelectivityEstimator::default_cond_equal_factor;\n }\n \n /// -------------------------------------\n@@ -204,15 +198,15 @@ void MergeTreeStatisticsFactory::registerValidator(StatisticsType stats_type, Va\n \n MergeTreeStatisticsFactory::MergeTreeStatisticsFactory()\n {\n-    registerValidator(StatisticsType::TDigest, tdigestValidator);\n-    registerCreator(StatisticsType::TDigest, tdigestCreator);\n+    registerValidator(StatisticsType::TDigest, tdigestStatisticsValidator);\n+    registerCreator(StatisticsType::TDigest, tdigestStatisticsCreator);\n \n-    registerValidator(StatisticsType::Uniq, uniqValidator);\n-    registerCreator(StatisticsType::Uniq, uniqCreator);\n+    registerValidator(StatisticsType::Uniq, uniqStatisticsValidator);\n+    registerCreator(StatisticsType::Uniq, uniqStatisticsCreator);\n \n #if USE_DATASKETCHES\n-    registerValidator(StatisticsType::CountMinSketch, countMinSketchValidator);\n-    registerCreator(StatisticsType::CountMinSketch, countMinSketchCreator);\n+    registerValidator(StatisticsType::CountMinSketch, countMinSketchStatisticsValidator);\n+    registerCreator(StatisticsType::CountMinSketch, countMinSketchStatisticsCreator);\n #endif\n }\n \n@@ -222,7 +216,7 @@ MergeTreeStatisticsFactory & MergeTreeStatisticsFactory::instance()\n     return instance;\n }\n \n-void MergeTreeStatisticsFactory::validate(const ColumnStatisticsDescription & stats, DataTypePtr data_type) const\n+void MergeTreeStatisticsFactory::validate(const ColumnStatisticsDescription & stats, const DataTypePtr & data_type) const\n {\n     for (const auto & [type, desc] : stats.types_to_desc)\n     {\ndiff --git a/src/Storages/Statistics/Statistics.h b/src/Storages/Statistics/Statistics.h\nindex 16f0c67eabd8..2a30c0de315d 100644\n--- a/src/Storages/Statistics/Statistics.h\n+++ b/src/Storages/Statistics/Statistics.h\n@@ -14,12 +14,11 @@ namespace DB\n constexpr auto STATS_FILE_PREFIX = \"statistics_\";\n constexpr auto STATS_FILE_SUFFIX = \".stats\";\n \n-\n struct StatisticsUtils\n {\n     /// Returns std::nullopt if input Field cannot be converted to a concrete value\n-    static std::optional<Float64> tryConvertToFloat64(const Field & field);\n-    static std::optional<String> tryConvertToString(const Field & field);\n+    /// - `data_type` is the type of the column on which the statistics object was build on\n+    static std::optional<Float64> tryConvertToFloat64(const Field & value, const DataTypePtr & data_type);\n };\n \n /// Statistics describe properties of the values in the column,\n@@ -87,10 +86,10 @@ class MergeTreeStatisticsFactory : private boost::noncopyable\n public:\n     static MergeTreeStatisticsFactory & instance();\n \n-    void validate(const ColumnStatisticsDescription & stats, DataTypePtr data_type) const;\n+    void validate(const ColumnStatisticsDescription & stats, const DataTypePtr & data_type) const;\n \n-    using Validator = std::function<void(const SingleStatisticsDescription & stats, DataTypePtr data_type)>;\n-    using Creator = std::function<StatisticsPtr(const SingleStatisticsDescription & stats, DataTypePtr data_type)>;\n+    using Validator = std::function<void(const SingleStatisticsDescription & stats, const DataTypePtr & data_type)>;\n+    using Creator = std::function<StatisticsPtr(const SingleStatisticsDescription & stats, const DataTypePtr & data_type)>;\n \n     ColumnStatisticsPtr get(const ColumnStatisticsDescription & stats) const;\n     ColumnsStatistics getMany(const ColumnsDescription & columns) const;\ndiff --git a/src/Storages/Statistics/StatisticsCountMinSketch.cpp b/src/Storages/Statistics/StatisticsCountMinSketch.cpp\nindex e69bbc1515be..0dc01f5fcf0e 100644\n--- a/src/Storages/Statistics/StatisticsCountMinSketch.cpp\n+++ b/src/Storages/Statistics/StatisticsCountMinSketch.cpp\n@@ -25,8 +25,8 @@ extern const int ILLEGAL_STATISTICS;\n static constexpr auto num_hashes = 7uz;\n static constexpr auto num_buckets = 2718uz;\n \n-StatisticsCountMinSketch::StatisticsCountMinSketch(const SingleStatisticsDescription & stat_, DataTypePtr data_type_)\n-    : IStatistics(stat_)\n+StatisticsCountMinSketch::StatisticsCountMinSketch(const SingleStatisticsDescription & description, const DataTypePtr & data_type_)\n+    : IStatistics(description)\n     , sketch(num_hashes, num_buckets)\n     , data_type(data_type_)\n {\n@@ -84,17 +84,17 @@ void StatisticsCountMinSketch::deserialize(ReadBuffer & buf)\n }\n \n \n-void countMinSketchValidator(const SingleStatisticsDescription &, DataTypePtr data_type)\n+void countMinSketchStatisticsValidator(const SingleStatisticsDescription & /*description*/, const DataTypePtr & data_type)\n {\n-    data_type = removeNullable(data_type);\n-    data_type = removeLowCardinalityAndNullable(data_type);\n-    if (!data_type->isValueRepresentedByNumber() && !isStringOrFixedString(data_type))\n+    DataTypePtr inner_data_type = removeNullable(data_type);\n+    inner_data_type = removeLowCardinalityAndNullable(inner_data_type);\n+    if (!inner_data_type->isValueRepresentedByNumber() && !isStringOrFixedString(inner_data_type))\n         throw Exception(ErrorCodes::ILLEGAL_STATISTICS, \"Statistics of type 'count_min' does not support type {}\", data_type->getName());\n }\n \n-StatisticsPtr countMinSketchCreator(const SingleStatisticsDescription & stat, DataTypePtr data_type)\n+StatisticsPtr countMinSketchStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type)\n {\n-    return std::make_shared<StatisticsCountMinSketch>(stat, data_type);\n+    return std::make_shared<StatisticsCountMinSketch>(description, data_type);\n }\n \n }\ndiff --git a/src/Storages/Statistics/StatisticsCountMinSketch.h b/src/Storages/Statistics/StatisticsCountMinSketch.h\nindex 6c8b74f8c359..d1de1a3aea5c 100644\n--- a/src/Storages/Statistics/StatisticsCountMinSketch.h\n+++ b/src/Storages/Statistics/StatisticsCountMinSketch.h\n@@ -14,7 +14,7 @@ namespace DB\n class StatisticsCountMinSketch : public IStatistics\n {\n public:\n-    StatisticsCountMinSketch(const SingleStatisticsDescription & stat_, DataTypePtr data_type_);\n+    StatisticsCountMinSketch(const SingleStatisticsDescription & description, const DataTypePtr & data_type_);\n \n     Float64 estimateEqual(const Field & val) const override;\n \n@@ -31,8 +31,8 @@ class StatisticsCountMinSketch : public IStatistics\n };\n \n \n-void countMinSketchValidator(const SingleStatisticsDescription &, DataTypePtr data_type);\n-StatisticsPtr countMinSketchCreator(const SingleStatisticsDescription & stat, DataTypePtr);\n+void countMinSketchStatisticsValidator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n+StatisticsPtr countMinSketchStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n \n }\n \ndiff --git a/src/Storages/Statistics/StatisticsTDigest.cpp b/src/Storages/Statistics/StatisticsTDigest.cpp\nindex 66150e00fdb2..285b779036f3 100644\n--- a/src/Storages/Statistics/StatisticsTDigest.cpp\n+++ b/src/Storages/Statistics/StatisticsTDigest.cpp\n@@ -1,33 +1,29 @@\n #include <Storages/Statistics/StatisticsTDigest.h>\n-#include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n namespace DB\n {\n namespace ErrorCodes\n {\n extern const int ILLEGAL_STATISTICS;\n-extern const int LOGICAL_ERROR;\n }\n \n-StatisticsTDigest::StatisticsTDigest(const SingleStatisticsDescription & stat_)\n-    : IStatistics(stat_)\n+StatisticsTDigest::StatisticsTDigest(const SingleStatisticsDescription & description, const DataTypePtr & data_type_)\n+    : IStatistics(description)\n+    , data_type(data_type_)\n {\n }\n \n void StatisticsTDigest::update(const ColumnPtr & column)\n {\n-    size_t rows = column->size();\n-    for (size_t row = 0; row < rows; ++row)\n+    for (size_t row = 0; row < column->size(); ++row)\n     {\n-        Field field;\n-        column->get(row, field);\n-\n-        if (field.isNull())\n+        if (column->isNullAt(row))\n             continue;\n \n-        if (auto field_as_float = StatisticsUtils::tryConvertToFloat64(field))\n-            t_digest.add(*field_as_float, 1);\n+        auto data = column->getFloat64(row);\n+        t_digest.add(data, 1);\n     }\n }\n \n@@ -43,31 +39,31 @@ void StatisticsTDigest::deserialize(ReadBuffer & buf)\n \n Float64 StatisticsTDigest::estimateLess(const Field & val) const\n {\n-    auto val_as_float = StatisticsUtils::tryConvertToFloat64(val);\n-    if (val_as_float)\n-        return t_digest.getCountLessThan(*val_as_float);\n-    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Statistics 'tdigest' does not support estimating value of type {}\", val.getTypeName());\n+    auto val_as_float = StatisticsUtils::tryConvertToFloat64(val, data_type);\n+    if (!val_as_float.has_value())\n+        return 0;\n+    return t_digest.getCountLessThan(*val_as_float);\n }\n \n Float64 StatisticsTDigest::estimateEqual(const Field & val) const\n {\n-    auto val_as_float = StatisticsUtils::tryConvertToFloat64(val);\n-    if (val_as_float)\n-        return t_digest.getCountEqual(*val_as_float);\n-    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Statistics 'tdigest' does not support estimating value of type {}\", val.getTypeName());\n+    auto val_as_float = StatisticsUtils::tryConvertToFloat64(val, data_type);\n+    if (!val_as_float.has_value())\n+        return 0;\n+    return t_digest.getCountEqual(*val_as_float);\n }\n \n-void tdigestValidator(const SingleStatisticsDescription &, DataTypePtr data_type)\n+void tdigestStatisticsValidator(const SingleStatisticsDescription & /*description*/, const DataTypePtr & data_type)\n {\n-    data_type = removeNullable(data_type);\n-    data_type = removeLowCardinalityAndNullable(data_type);\n-    if (!data_type->isValueRepresentedByNumber())\n+    DataTypePtr inner_data_type = removeNullable(data_type);\n+    inner_data_type = removeLowCardinalityAndNullable(inner_data_type);\n+    if (!inner_data_type->isValueRepresentedByNumber())\n         throw Exception(ErrorCodes::ILLEGAL_STATISTICS, \"Statistics of type 'tdigest' do not support type {}\", data_type->getName());\n }\n \n-StatisticsPtr tdigestCreator(const SingleStatisticsDescription & stat, DataTypePtr)\n+StatisticsPtr tdigestStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type)\n {\n-    return std::make_shared<StatisticsTDigest>(stat);\n+    return std::make_shared<StatisticsTDigest>(description, data_type);\n }\n \n }\ndiff --git a/src/Storages/Statistics/StatisticsTDigest.h b/src/Storages/Statistics/StatisticsTDigest.h\nindex 614973e5d8b6..5e744fee2ce2 100644\n--- a/src/Storages/Statistics/StatisticsTDigest.h\n+++ b/src/Storages/Statistics/StatisticsTDigest.h\n@@ -9,7 +9,7 @@ namespace DB\n class StatisticsTDigest : public IStatistics\n {\n public:\n-    explicit StatisticsTDigest(const SingleStatisticsDescription & stat_);\n+    explicit StatisticsTDigest(const SingleStatisticsDescription & description, const DataTypePtr & data_type_);\n \n     void update(const ColumnPtr & column) override;\n \n@@ -21,9 +21,10 @@ class StatisticsTDigest : public IStatistics\n \n private:\n     QuantileTDigest<Float64> t_digest;\n+    DataTypePtr data_type;\n };\n \n-void tdigestValidator(const SingleStatisticsDescription &, DataTypePtr data_type);\n-StatisticsPtr tdigestCreator(const SingleStatisticsDescription & stat, DataTypePtr);\n+void tdigestStatisticsValidator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n+StatisticsPtr tdigestStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n \n }\ndiff --git a/src/Storages/Statistics/StatisticsUniq.cpp b/src/Storages/Statistics/StatisticsUniq.cpp\nindex 8f60ffcf0b59..07311b5b86d0 100644\n--- a/src/Storages/Statistics/StatisticsUniq.cpp\n+++ b/src/Storages/Statistics/StatisticsUniq.cpp\n@@ -11,8 +11,8 @@ namespace ErrorCodes\n     extern const int ILLEGAL_STATISTICS;\n }\n \n-StatisticsUniq::StatisticsUniq(const SingleStatisticsDescription & stat_, const DataTypePtr & data_type)\n-    : IStatistics(stat_)\n+StatisticsUniq::StatisticsUniq(const SingleStatisticsDescription & description, const DataTypePtr & data_type)\n+    : IStatistics(description)\n {\n     arena = std::make_unique<Arena>();\n     AggregateFunctionProperties properties;\n@@ -52,17 +52,17 @@ UInt64 StatisticsUniq::estimateCardinality() const\n     return column->getUInt(0);\n }\n \n-void uniqValidator(const SingleStatisticsDescription &, DataTypePtr data_type)\n+void uniqStatisticsValidator(const SingleStatisticsDescription & /*description*/, const DataTypePtr & data_type)\n {\n-    data_type = removeNullable(data_type);\n-    data_type = removeLowCardinalityAndNullable(data_type);\n-    if (!data_type->isValueRepresentedByNumber())\n+    DataTypePtr inner_data_type = removeNullable(data_type);\n+    inner_data_type = removeLowCardinalityAndNullable(inner_data_type);\n+    if (!inner_data_type->isValueRepresentedByNumber())\n         throw Exception(ErrorCodes::ILLEGAL_STATISTICS, \"Statistics of type 'uniq' do not support type {}\", data_type->getName());\n }\n \n-StatisticsPtr uniqCreator(const SingleStatisticsDescription & stat, DataTypePtr data_type)\n+StatisticsPtr uniqStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type)\n {\n-    return std::make_shared<StatisticsUniq>(stat, data_type);\n+    return std::make_shared<StatisticsUniq>(description, data_type);\n }\n \n }\ndiff --git a/src/Storages/Statistics/StatisticsUniq.h b/src/Storages/Statistics/StatisticsUniq.h\nindex faabde8d47c4..1fdcab8bd891 100644\n--- a/src/Storages/Statistics/StatisticsUniq.h\n+++ b/src/Storages/Statistics/StatisticsUniq.h\n@@ -10,7 +10,7 @@ namespace DB\n class StatisticsUniq : public IStatistics\n {\n public:\n-    StatisticsUniq(const SingleStatisticsDescription & stat_, const DataTypePtr & data_type);\n+    StatisticsUniq(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n     ~StatisticsUniq() override;\n \n     void update(const ColumnPtr & column) override;\n@@ -27,7 +27,7 @@ class StatisticsUniq : public IStatistics\n \n };\n \n-void uniqValidator(const SingleStatisticsDescription &, DataTypePtr data_type);\n-StatisticsPtr uniqCreator(const SingleStatisticsDescription & stat, DataTypePtr data_type);\n+void uniqStatisticsValidator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n+StatisticsPtr uniqStatisticsCreator(const SingleStatisticsDescription & description, const DataTypePtr & data_type);\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02864_statistics_bugs.reference b/tests/queries/0_stateless/02864_statistics_bugs.reference\nnew file mode 100644\nindex 000000000000..a7eeae9def6c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02864_statistics_bugs.reference\n@@ -0,0 +1,3 @@\n+10\n+11\n+0\ndiff --git a/tests/queries/0_stateless/02864_statistics_bugs.sql b/tests/queries/0_stateless/02864_statistics_bugs.sql\nnew file mode 100644\nindex 000000000000..01bbe221b0fd\n--- /dev/null\n+++ b/tests/queries/0_stateless/02864_statistics_bugs.sql\n@@ -0,0 +1,27 @@\n+SET allow_experimental_statistics = 1;\n+SET allow_statistics_optimize = 1;\n+SET mutations_sync = 1;\n+\n+DROP TABLE IF EXISTS bug_67742;\n+CREATE TABLE bug_67742 (a Float64 STATISTICS(tdigest)) Engine = MergeTree() ORDER BY tuple();\n+INSERT INTO bug_67742 SELECT number FROM system.numbers LIMIT 10000;\n+SELECT count(*) FROM bug_67742 WHERE a < '10';\n+DROP TABLE bug_67742;\n+\n+DROP TABLE IF EXISTS bug_67742;\n+CREATE TABLE bug_67742 (a Int32 STATISTICS(tdigest)) Engine = MergeTree() ORDER BY tuple();\n+INSERT INTO bug_67742 SELECT number FROM system.numbers LIMIT 10000;\n+SELECT count(*) FROM bug_67742 WHERE a < '10.5'; -- { serverError TYPE_MISMATCH }\n+DROP TABLE bug_67742;\n+\n+DROP TABLE IF EXISTS bug_67742;\n+CREATE TABLE bug_67742 (a Int32 STATISTICS(tdigest)) Engine = MergeTree() ORDER BY tuple();\n+INSERT INTO bug_67742 SELECT number FROM system.numbers LIMIT 10000;\n+SELECT count(*) FROM bug_67742 WHERE a < 10.5;\n+DROP TABLE bug_67742;\n+\n+DROP TABLE IF EXISTS bug_67742;\n+CREATE TABLE bug_67742 (a Int16 STATISTICS(tdigest)) Engine = MergeTree() ORDER BY tuple();\n+INSERT INTO bug_67742 SELECT number FROM system.numbers LIMIT 10000;\n+SELECT count(*) FROM bug_67742 WHERE a < '9999999999999999999999999';\n+DROP TABLE bug_67742;\n",
  "problem_statement": "Logical error: 'Statistics 'tdigest' does not support estimating value of type String'.\nhttps://s3.amazonaws.com/clickhouse-test-reports/67727/fc651cc0c61feb37e9cf104612cc0ac0cd7448e9/ast_fuzzer__ubsan_.html\r\n\r\nRevert this: https://github.com/ClickHouse/ClickHouse/pull/59357\n",
  "hints_text": "https://github.com/ClickHouse/ClickHouse/pull/67013#issuecomment-2268722942\nWill be fixed by #67013\nWill be also fixed by https://github.com/ClickHouse/ClickHouse/pull/67858 ",
  "created_at": "2024-08-06T15:28:06Z",
  "modified_files": [
    "docs/en/engines/table-engines/mergetree-family/mergetree.md",
    "src/Storages/Statistics/ConditionSelectivityEstimator.cpp",
    "src/Storages/Statistics/ConditionSelectivityEstimator.h",
    "src/Storages/Statistics/Statistics.cpp",
    "src/Storages/Statistics/Statistics.h",
    "src/Storages/Statistics/StatisticsCountMinSketch.cpp",
    "src/Storages/Statistics/StatisticsCountMinSketch.h",
    "src/Storages/Statistics/StatisticsTDigest.cpp",
    "src/Storages/Statistics/StatisticsTDigest.h",
    "src/Storages/Statistics/StatisticsUniq.cpp",
    "src/Storages/Statistics/StatisticsUniq.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02864_statistics_bugs.reference",
    "b/tests/queries/0_stateless/02864_statistics_bugs.sql"
  ]
}