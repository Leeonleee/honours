{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19858,
  "instance_id": "ClickHouse__ClickHouse-19858",
  "issue_numbers": [
    "19691"
  ],
  "base_commit": "1684be296cd70125b0d49360efd1c43cad3d3f6a",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 6237cd6a9764..3ca36f41c78a 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -303,81 +303,44 @@ SELECT toFixedString('foo\\0bar', 8) AS s, toStringCutToZero(s) AS s_cut\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## reinterpretAsUInt(8\\|16\\|32\\|64) {#reinterpretasuint8163264}\n+## reinterpretAs(x, T) {#type_conversion_function-cast}\n \n-## reinterpretAsInt(8\\|16\\|32\\|64) {#reinterpretasint8163264}\n+Performs byte reinterpretation of \u2018x\u2019 as \u2018t\u2019 data type.\n \n-## reinterpretAsFloat(32\\|64) {#reinterpretasfloat3264}\n-\n-## reinterpretAsDate {#reinterpretasdate}\n-\n-## reinterpretAsDateTime {#reinterpretasdatetime}\n-\n-These functions accept a string and interpret the bytes placed at the beginning of the string as a number in host order (little endian). If the string isn\u2019t long enough, the functions work as if the string is padded with the necessary number of null bytes. If the string is longer than needed, the extra bytes are ignored. A date is interpreted as the number of days since the beginning of the Unix Epoch, and a date with time is interpreted as the number of seconds since the beginning of the Unix Epoch.\n-\n-## reinterpretAsString {#type_conversion_functions-reinterpretAsString}\n-\n-This function accepts a number or date or date with time, and returns a string containing bytes representing the corresponding value in host order (little endian). Null bytes are dropped from the end. For example, a UInt32 type value of 255 is a string that is one byte long.\n-\n-## reinterpretAsFixedString {#reinterpretasfixedstring}\n-\n-This function accepts a number or date or date with time, and returns a FixedString containing bytes representing the corresponding value in host order (little endian). Null bytes are dropped from the end. For example, a UInt32 type value of 255 is a FixedString that is one byte long.\n-\n-## reinterpretAsUUID {#reinterpretasuuid}\n-\n-This function accepts 16 bytes string, and returns UUID containing bytes representing the corresponding value in network byte order (big-endian). If the string isn't long enough, the functions work as if the string is padded with the necessary number of null bytes to the end. If the string longer than 16 bytes, the extra bytes at the end are ignored. \n-\n-**Syntax**\n+Following reinterpretations are allowed:\n+1. Any type that has fixed size and value of that type can be represented continuously into FixedString.\n+2. Any type that if value of that type can be represented continuously into String. Null bytes are dropped from the end. For example, a UInt32 type value of 255 is a string that is one byte long.\n+3. FixedString, String, types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID) into types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID) into FixedString,\n \n ``` sql\n-reinterpretAsUUID(fixed_string)\n+SELECT reinterpretAs(toInt8(-1), 'UInt8') as int_to_uint,\n+    reinterpretAs(toInt8(1), 'Float32') as int_to_float,\n+    reinterpretAs('1', 'UInt32') as string_to_int;\n ```\n \n-**Parameters**\n-\n--   `fixed_string` \u2014 Big-endian byte string. [FixedString](../../sql-reference/data-types/fixedstring.md#fixedstring).\n-\n-**Returned value**\n-\n--   The UUID type value. [UUID](../../sql-reference/data-types/uuid.md#uuid-data-type).\n-\n-**Examples**\n-\n-String to UUID.\n+``` text\n+\u250c\u2500int_to_uint\u2500\u252c\u2500int_to_float\u2500\u252c\u2500string_to_int\u2500\u2510\n+\u2502         255 \u2502        1e-45 \u2502            49 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n \n-Query:\n+## reinterpretAsUInt(8\\|16\\|32\\|64\\|256) {#reinterpretasuint8163264256}\n \n-``` sql\n-SELECT reinterpretAsUUID(reverse(unhex('000102030405060708090a0b0c0d0e0f')))\n-```\n+## reinterpretAsInt(8\\|16\\|32\\|64\\|128\\|256) {#reinterpretasint8163264128256}\n \n-Result:\n+## reinterpretAsFloat(32\\|64) {#reinterpretasfloat3264}\n \n-``` text\n-\u250c\u2500reinterpretAsUUID(reverse(unhex('000102030405060708090a0b0c0d0e0f')))\u2500\u2510\n-\u2502                                  08090a0b-0c0d-0e0f-0001-020304050607 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n+## reinterpretAsDate {#reinterpretasdate}\n \n-Going back and forth from String to UUID.\n+## reinterpretAsDateTime {#reinterpretasdatetime}\n \n-Query:\n+## reinterpretAsString {#type_conversion_functions-reinterpretAsString}\n \n-``` sql\n-WITH\n-    generateUUIDv4() AS uuid,\n-    identity(lower(hex(reverse(reinterpretAsString(uuid))))) AS str,\n-    reinterpretAsUUID(reverse(unhex(str))) AS uuid2\n-SELECT uuid = uuid2;\n-```\n+## reinterpretAsFixedString {#reinterpretasfixedstring}\n \n-Result:\n+## reinterpretAsUUID {#reinterpretasuuid}\n \n-``` text\n-\u250c\u2500equals(uuid, uuid2)\u2500\u2510\n-\u2502                   1 \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n+These functions are aliases for `reinterpretAs`function.\n \n ## CAST(x, T) {#type_conversion_function-cast}\n \ndiff --git a/src/Core/callOnTypeIndex.h b/src/Core/callOnTypeIndex.h\nindex ccbccd7105ae..2d6134ab9fc8 100644\n--- a/src/Core/callOnTypeIndex.h\n+++ b/src/Core/callOnTypeIndex.h\n@@ -207,4 +207,22 @@ bool callOnIndexAndDataType(TypeIndex number, F && f, ExtraArgs && ... args)\n     return false;\n }\n \n+template <typename F>\n+static bool callOnTwoTypeIndexes(TypeIndex left_type, TypeIndex right_type, F && func)\n+{\n+    return callOnIndexAndDataType<void>(left_type, [&](const auto & left_types) -> bool\n+    {\n+        using LeftTypes = std::decay_t<decltype(left_types)>;\n+        using LeftType = typename LeftTypes::LeftType;\n+\n+        return callOnIndexAndDataType<void>(right_type, [&](const auto & right_types) -> bool\n+        {\n+            using RightTypes = std::decay_t<decltype(right_types)>;\n+            using RightType = typename RightTypes::LeftType;\n+\n+            return std::forward<F>(func)(TypePair<LeftType, RightType>());\n+        });\n+    });\n+}\n+\n }\ndiff --git a/src/Functions/registerFunctionsReinterpret.cpp b/src/Functions/registerFunctionsReinterpret.cpp\nindex d82274ce9ed4..e6fa0402071d 100644\n--- a/src/Functions/registerFunctionsReinterpret.cpp\n+++ b/src/Functions/registerFunctionsReinterpret.cpp\n@@ -4,14 +4,10 @@ namespace DB\n class FunctionFactory;\n \n void registerFunctionsReinterpretAs(FunctionFactory & factory);\n-void registerFunctionReinterpretAsString(FunctionFactory & factory);\n-void registerFunctionReinterpretAsFixedString(FunctionFactory & factory);\n \n void registerFunctionsReinterpret(FunctionFactory & factory)\n {\n     registerFunctionsReinterpretAs(factory);\n-    registerFunctionReinterpretAsString(factory);\n-    registerFunctionReinterpretAsFixedString(factory);\n }\n \n }\ndiff --git a/src/Functions/reinterpretAs.cpp b/src/Functions/reinterpretAs.cpp\nindex 64facaf0840a..363455cb38fa 100644\n--- a/src/Functions/reinterpretAs.cpp\n+++ b/src/Functions/reinterpretAs.cpp\n@@ -1,5 +1,8 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/castTypeToEither.h>\n+#include <Functions/FunctionHelpers.h>\n+\n+#include <Core/callOnTypeIndex.h>\n \n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeString.h>\n@@ -7,6 +10,7 @@\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeUUID.h>\n+#include <DataTypes/DataTypeFactory.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnConst.h>\n@@ -21,178 +25,389 @@ namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n namespace\n {\n-template <typename ToDataType, typename Name, bool support_between_float_integer>\n+\n+/** Performs byte reinterpretation similar to reinterpret_cast.\n+ *\n+ * Following reinterpretations are allowed:\n+ * 1. Any type that isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion into FixedString.\n+ * 2. Any type that isValueUnambiguouslyRepresentedInContiguousMemoryRegion into String.\n+ * 3. Types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID) into FixedString,\n+ * String, and types that can be interpreted as numeric (Integers, Float, Date, DateTime, UUID).\n+ */\n class FunctionReinterpretAs : public IFunction\n {\n-    template <typename F>\n-    static bool castType(const IDataType * type, F && f)\n-    {\n-        return castTypeToEither<DataTypeUInt32, DataTypeInt32, DataTypeUInt64, DataTypeInt64, DataTypeFloat32, DataTypeFloat64>(\n-            type, std::forward<F>(f));\n-    }\n-\n-    template <typename From, typename To>\n-    static void reinterpretImpl(const PaddedPODArray<From> & from, PaddedPODArray<To> & to)\n-    {\n-        size_t size = from.size();\n-        to.resize(size);\n-        for (size_t i = 0; i < size; ++i)\n-        {\n-            to[i] = unalignedLoad<To>(&(from.data()[i]));\n-        }\n-    }\n-\n public:\n-    static constexpr auto name = Name::name;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAs>(); }\n+    static constexpr auto name = \"reinterpretAs\";\n \n-    using ToFieldType = typename ToDataType::FieldType;\n-    using ColumnType = typename ToDataType::ColumnType;\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAs>(); }\n \n     String getName() const override { return name; }\n \n-    size_t getNumberOfArguments() const override { return 1; }\n+    size_t getNumberOfArguments() const override { return 2; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        const IDataType & type = *arguments[0];\n-        if constexpr (support_between_float_integer)\n-        {\n-            if (!isStringOrFixedString(type) && !isNumber(type))\n-                throw Exception(\n-                    \"Cannot reinterpret \" + type.getName() + \" as \" + ToDataType().getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        const auto & column = arguments.back().column;\n \n-            if (isNumber(type))\n-            {\n-                if (type.getSizeOfValueInMemory() != ToDataType{}.getSizeOfValueInMemory())\n-                    throw Exception(\n-                        \"Cannot reinterpret \" + type.getName() + \" as \" + ToDataType().getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            }\n+        DataTypePtr from_type = arguments[0].type;\n+\n+        const auto * type_col = checkAndGetColumnConst<ColumnString>(column.get());\n+        if (!type_col)\n+            throw Exception(\"Second argument to \" + getName() + \" must be a constant string describing type.\"\n+                \" Instead there is non-constant column of type \" + arguments.back().type->getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        DataTypePtr to_type = DataTypeFactory::instance().get(type_col->getValue<String>());\n+\n+        WhichDataType result_reinterpret_type(to_type);\n+\n+        if (result_reinterpret_type.isFixedString())\n+        {\n+            if (!from_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())\n+                throw Exception(\"Cannot reinterpret \" + from_type->getName() +\n+                    \" as FixedString because it is not fixed size and contiguous in memory\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         }\n-        else\n+        else if (result_reinterpret_type.isString())\n         {\n-            if (!isStringOrFixedString(type))\n-                throw Exception(\n-                    \"Cannot reinterpret \" + type.getName() + \" as \" + ToDataType().getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            if (!from_type->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n+                throw Exception(\"Cannot reinterpret \" + from_type->getName() +\n+                    \" as String because it is not contiguous in memory\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         }\n-        return std::make_shared<ToDataType>();\n-    }\n+        else if (canBeReinterpretedAsNumeric(result_reinterpret_type))\n+        {\n+            WhichDataType from_data_type(from_type);\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n+            if (!canBeReinterpretedAsNumeric(from_data_type) && !from_data_type.isStringOrFixedString())\n+                throw Exception(\"Cannot reinterpret \" + from_type->getName() + \" as \" + to_type->getName()\n+                    + \" because only Numeric, String or FixedString can be reinterpreted in Numeric\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        }\n+\n+        return to_type;\n+    }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n     {\n-        if (const ColumnString * col_from = typeid_cast<const ColumnString *>(arguments[0].column.get()))\n+        auto from_type = arguments[0].type;\n+\n+        ColumnPtr result;\n+\n+        if (!callOnTwoTypeIndexes(from_type->getTypeId(), result_type->getTypeId(), [&](const auto & types)\n         {\n-            auto col_res = ColumnType::create();\n+            using Types = std::decay_t<decltype(types)>;\n+            using FromType = typename Types::LeftType;\n+            using ToType = typename Types::RightType;\n+\n+            /// Place this check before std::is_same_v<FromType, ToType> because same FixedString\n+            /// types does not necessary have the same byte size fixed value.\n+            if constexpr (std::is_same_v<ToType, DataTypeFixedString>)\n+            {\n+                const IColumn & src = *arguments[0].column;\n+                MutableColumnPtr dst = result_type->createColumn();\n \n-            const ColumnString::Chars & data_from = col_from->getChars();\n-            const ColumnString::Offsets & offsets_from = col_from->getOffsets();\n-            size_t size = offsets_from.size();\n-            typename ColumnType::Container & vec_res = col_res->getData();\n-            vec_res.resize(size);\n+                ColumnFixedString * dst_concrete = assert_cast<ColumnFixedString *>(dst.get());\n \n-            size_t offset = 0;\n-            for (size_t i = 0; i < size; ++i)\n+                if (src.isFixedAndContiguous() && src.sizeOfValueIfFixed() == dst_concrete->getN())\n+                    executeContiguousToFixedString(src, *dst_concrete, dst_concrete->getN());\n+                else\n+                    executeToFixedString(src, *dst_concrete, dst_concrete->getN());\n+\n+                result = std::move(dst);\n+\n+                return true;\n+            }\n+            else if constexpr (std::is_same_v<FromType, ToType>)\n             {\n-                ToFieldType value{};\n-                memcpy(&value, &data_from[offset], std::min(static_cast<UInt64>(sizeof(ToFieldType)), offsets_from[i] - offset - 1));\n-                vec_res[i] = value;\n-                offset = offsets_from[i];\n+                result = arguments[0].column;\n+\n+                return true;\n             }\n+            else if constexpr (std::is_same_v<ToType, DataTypeString>)\n+            {\n+                const IColumn & src = *arguments[0].column;\n+                MutableColumnPtr dst = result_type->createColumn();\n \n-            return col_res;\n-        }\n-        else if (const ColumnFixedString * col_from_fixed = typeid_cast<const ColumnFixedString *>(arguments[0].column.get()))\n-        {\n-            auto col_res = ColumnVector<ToFieldType>::create();\n+                ColumnString * dst_concrete = assert_cast<ColumnString *>(dst.get());\n+                executeToString(src, *dst_concrete);\n \n-            const ColumnString::Chars & data_from = col_from_fixed->getChars();\n-            size_t step = col_from_fixed->getN();\n-            size_t size = data_from.size() / step;\n-            typename ColumnVector<ToFieldType>::Container & vec_res = col_res->getData();\n-            vec_res.resize(size);\n+                result = std::move(dst);\n \n-            size_t offset = 0;\n-            size_t copy_size = std::min(step, sizeof(ToFieldType));\n-            for (size_t i = 0; i < size; ++i)\n-            {\n-                ToFieldType value{};\n-                memcpy(&value, &data_from[offset], copy_size);\n-                vec_res[i] = value;\n-                offset += step;\n+                return true;\n             }\n+            else if constexpr (CanBeReinterpretedAsNumeric<ToType>)\n+            {\n+                using ToColumnType = typename ToType::ColumnType;\n+                using ToFieldType = typename ToType::FieldType;\n \n-            return col_res;\n-        }\n-        else if constexpr (support_between_float_integer)\n-        {\n-            ColumnPtr res;\n-            if (castType(arguments[0].type.get(), [&](const auto & type)\n+                if constexpr (std::is_same_v<FromType, DataTypeString>)\n                 {\n-                    using DataType = std::decay_t<decltype(type)>;\n-                    using T = typename DataType::FieldType;\n+                    const auto * col_from = assert_cast<const ColumnString *>(arguments[0].column.get());\n+\n+                    auto col_res = ToColumnType::create();\n+\n+                    const ColumnString::Chars & data_from = col_from->getChars();\n+                    const ColumnString::Offsets & offsets_from = col_from->getOffsets();\n+                    size_t size = offsets_from.size();\n+                    typename ToColumnType::Container & vec_res = col_res->getData();\n+                    vec_res.resize(size);\n \n-                    const ColumnVector<T> * col = checkAndGetColumn<ColumnVector<T>>(arguments[0].column.get());\n-                    auto col_res = ColumnType::create();\n+                    size_t offset = 0;\n+                    for (size_t i = 0; i < size; ++i)\n+                    {\n+                        ToFieldType value{};\n+                        memcpy(&value,\n+                            &data_from[offset],\n+                            std::min(static_cast<UInt64>(sizeof(ToFieldType)), offsets_from[i] - offset - 1));\n+                        vec_res[i] = value;\n+                        offset = offsets_from[i];\n+                    }\n+\n+                    result = std::move(col_res);\n+\n+                    return true;\n+                }\n+                else if constexpr (std::is_same_v<FromType, DataTypeFixedString>)\n+                {\n+                    const auto * col_from_fixed = assert_cast<const ColumnFixedString *>(arguments[0].column.get());\n+\n+                    auto col_res = ToColumnType::create();\n+\n+                    const ColumnString::Chars & data_from = col_from_fixed->getChars();\n+                    size_t step = col_from_fixed->getN();\n+                    size_t size = data_from.size() / step;\n+                    typename ToColumnType::Container & vec_res = col_res->getData();\n+                    vec_res.resize(size);\n+\n+                    size_t offset = 0;\n+                    size_t copy_size = std::min(step, sizeof(ToFieldType));\n+                    for (size_t i = 0; i < size; ++i)\n+                    {\n+                        ToFieldType value{};\n+                        memcpy(&value, &data_from[offset], copy_size);\n+                        vec_res[i] = value;\n+                        offset += step;\n+                    }\n+\n+                    result = std::move(col_res);\n+\n+                    return true;\n+                }\n+                else if constexpr (CanBeReinterpretedAsNumeric<FromType>)\n+                {\n+                    using FromTypeFieldType = typename FromType::FieldType;\n+                    const auto * col = assert_cast<const ColumnVector<FromTypeFieldType>*>(arguments[0].column.get());\n+\n+                    auto col_res = ToColumnType::create();\n                     reinterpretImpl(col->getData(), col_res->getData());\n-                    res = std::move(col_res);\n+                    result = std::move(col_res);\n \n                     return true;\n-                }))\n-            {\n-                return res;\n-            }\n-            else\n-            {\n-                throw Exception(\n-                    \"Illegal column \" + arguments[0].column->getName() + \" of argument of function \" + getName(),\n-                    ErrorCodes::ILLEGAL_COLUMN);\n+                }\n             }\n+\n+            return false;\n+        }))\n+        {\n+            throw Exception(\"Cannot reinterpret \" + from_type->getName() + \" as \" + result_type->getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         }\n-        else\n+\n+        return result;\n+    }\n+private:\n+    template <typename T>\n+    static constexpr auto CanBeReinterpretedAsNumeric =\n+        IsDataTypeNumber<T> ||\n+        std::is_same_v<T, DataTypeDate> ||\n+        std::is_same_v<T, DataTypeDateTime> ||\n+        std::is_same_v<T, DataTypeUUID>;\n+\n+    static bool canBeReinterpretedAsNumeric(const WhichDataType & type)\n+    {\n+        return type.isUInt() ||\n+            type.isInt() ||\n+            type.isDateOrDateTime() ||\n+            type.isFloat() ||\n+            type.isUUID();\n+    }\n+\n+    static void NO_INLINE executeToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)\n+    {\n+        size_t rows = src.size();\n+        ColumnFixedString::Chars & data_to = dst.getChars();\n+        data_to.resize_fill(n * rows);\n+\n+        ColumnFixedString::Offset offset = 0;\n+        for (size_t i = 0; i < rows; ++i)\n         {\n-            throw Exception(\n-                \"Illegal column \" + arguments[0].column->getName() + \" of argument of function \" + getName(),\n-                ErrorCodes::ILLEGAL_COLUMN);\n+            StringRef data = src.getDataAt(i);\n+\n+            std::memcpy(&data_to[offset], data.data, std::min(n, data.size));\n+            offset += n;\n+        }\n+    }\n+\n+    static void NO_INLINE executeContiguousToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)\n+    {\n+        size_t rows = src.size();\n+        ColumnFixedString::Chars & data_to = dst.getChars();\n+        data_to.resize(n * rows);\n+\n+        memcpy(data_to.data(), src.getRawData().data, data_to.size());\n+    }\n+\n+    static void NO_INLINE executeToString(const IColumn & src, ColumnString & dst)\n+    {\n+        size_t rows = src.size();\n+        ColumnString::Chars & data_to = dst.getChars();\n+        ColumnString::Offsets & offsets_to = dst.getOffsets();\n+        offsets_to.resize(rows);\n+\n+        ColumnString::Offset offset = 0;\n+        for (size_t i = 0; i < rows; ++i)\n+        {\n+            StringRef data = src.getDataAt(i);\n+\n+            /// Cut trailing zero bytes.\n+            while (data.size && data.data[data.size - 1] == 0)\n+                --data.size;\n+\n+            data_to.resize(offset + data.size + 1);\n+            memcpy(&data_to[offset], data.data, data.size);\n+            offset += data.size;\n+            data_to[offset] = 0;\n+            ++offset;\n+            offsets_to[i] = offset;\n+        }\n+    }\n+\n+    template <typename From, typename To>\n+    static void reinterpretImpl(const PaddedPODArray<From> & from, PaddedPODArray<To> & to)\n+    {\n+        size_t size = from.size();\n+        to.resize_fill(size);\n+\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            memcpy(static_cast<void*>(&to[i]),\n+                static_cast<const void*>(&from[i]),\n+                std::min(sizeof(From), sizeof(To)));\n         }\n     }\n };\n \n+template <typename ToDataType, typename Name>\n+class FunctionReinterpretAsTyped : public IFunction\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAsTyped>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    static ColumnsWithTypeAndName addTypeColumnToArguments(const ColumnsWithTypeAndName & arguments)\n+    {\n+        const auto & argument = arguments[0];\n+\n+        DataTypePtr data_type;\n+\n+        if constexpr (std::is_same_v<ToDataType, DataTypeFixedString>)\n+        {\n+            const auto & type = argument.type;\n+\n+            if (!type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())\n+                throw Exception(\"Cannot reinterpret \" + type->getName() +\n+                    \" as FixedString because it is not fixed size and contiguous in memory\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+            size_t type_value_size_in_memory = type->getSizeOfValueInMemory();\n+            data_type = std::make_shared<DataTypeFixedString>(type_value_size_in_memory);\n+        }\n+        else\n+            data_type = std::make_shared<ToDataType>();\n+\n+        auto type_name_column = DataTypeString().createColumnConst(1, data_type->getName());\n+        ColumnWithTypeAndName type_column(type_name_column, std::make_shared<DataTypeString>(), \"\");\n+\n+        ColumnsWithTypeAndName arguments_with_type\n+        {\n+            argument,\n+            type_column\n+        };\n+\n+        return arguments_with_type;\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        auto arguments_with_type = addTypeColumnToArguments(arguments);\n+        return impl.getReturnTypeImpl(arguments_with_type);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type, size_t input_rows_count) const override\n+    {\n+        auto arguments_with_type = addTypeColumnToArguments(arguments);\n+        return impl.executeImpl(arguments_with_type, return_type, input_rows_count);\n+    }\n+\n+    FunctionReinterpretAs impl;\n+};\n \n struct NameReinterpretAsUInt8       { static constexpr auto name = \"reinterpretAsUInt8\"; };\n struct NameReinterpretAsUInt16      { static constexpr auto name = \"reinterpretAsUInt16\"; };\n struct NameReinterpretAsUInt32      { static constexpr auto name = \"reinterpretAsUInt32\"; };\n struct NameReinterpretAsUInt64      { static constexpr auto name = \"reinterpretAsUInt64\"; };\n+struct NameReinterpretAsUInt256     { static constexpr auto name = \"reinterpretAsUInt256\"; };\n struct NameReinterpretAsInt8        { static constexpr auto name = \"reinterpretAsInt8\"; };\n struct NameReinterpretAsInt16       { static constexpr auto name = \"reinterpretAsInt16\"; };\n struct NameReinterpretAsInt32       { static constexpr auto name = \"reinterpretAsInt32\"; };\n struct NameReinterpretAsInt64       { static constexpr auto name = \"reinterpretAsInt64\"; };\n+struct NameReinterpretAsInt128      { static constexpr auto name = \"reinterpretAsInt128\"; };\n+struct NameReinterpretAsInt256      { static constexpr auto name = \"reinterpretAsInt256\"; };\n struct NameReinterpretAsFloat32     { static constexpr auto name = \"reinterpretAsFloat32\"; };\n struct NameReinterpretAsFloat64     { static constexpr auto name = \"reinterpretAsFloat64\"; };\n struct NameReinterpretAsDate        { static constexpr auto name = \"reinterpretAsDate\"; };\n struct NameReinterpretAsDateTime    { static constexpr auto name = \"reinterpretAsDateTime\"; };\n struct NameReinterpretAsUUID        { static constexpr auto name = \"reinterpretAsUUID\"; };\n+struct NameReinterpretAsString      { static constexpr auto name = \"reinterpretAsString\"; };\n+struct NameReinterpretAsFixedString { static constexpr auto name = \"reinterpretAsFixedString\"; };\n+\n+using FunctionReinterpretAsUInt8 = FunctionReinterpretAsTyped<DataTypeUInt8, NameReinterpretAsUInt8>;\n+using FunctionReinterpretAsUInt16 = FunctionReinterpretAsTyped<DataTypeUInt16, NameReinterpretAsUInt16>;\n+using FunctionReinterpretAsUInt32 = FunctionReinterpretAsTyped<DataTypeUInt32, NameReinterpretAsUInt32>;\n+using FunctionReinterpretAsUInt64 = FunctionReinterpretAsTyped<DataTypeUInt64, NameReinterpretAsUInt64>;\n+using FunctionReinterpretAsUInt256 = FunctionReinterpretAsTyped<DataTypeUInt256, NameReinterpretAsUInt256>;\n+using FunctionReinterpretAsInt8 = FunctionReinterpretAsTyped<DataTypeInt8, NameReinterpretAsInt8>;\n+using FunctionReinterpretAsInt16 = FunctionReinterpretAsTyped<DataTypeInt16, NameReinterpretAsInt16>;\n+using FunctionReinterpretAsInt32 = FunctionReinterpretAsTyped<DataTypeInt32, NameReinterpretAsInt32>;\n+using FunctionReinterpretAsInt64 = FunctionReinterpretAsTyped<DataTypeInt64, NameReinterpretAsInt64>;\n+using FunctionReinterpretAsInt128 = FunctionReinterpretAsTyped<DataTypeInt128, NameReinterpretAsInt128>;\n+using FunctionReinterpretAsInt256 = FunctionReinterpretAsTyped<DataTypeInt256, NameReinterpretAsInt256>;\n+using FunctionReinterpretAsFloat32 = FunctionReinterpretAsTyped<DataTypeFloat32, NameReinterpretAsFloat32>;\n+using FunctionReinterpretAsFloat64 = FunctionReinterpretAsTyped<DataTypeFloat64, NameReinterpretAsFloat64>;\n+using FunctionReinterpretAsDate = FunctionReinterpretAsTyped<DataTypeDate, NameReinterpretAsDate>;\n+using FunctionReinterpretAsDateTime = FunctionReinterpretAsTyped<DataTypeDateTime, NameReinterpretAsDateTime>;\n+using FunctionReinterpretAsUUID = FunctionReinterpretAsTyped<DataTypeUUID, NameReinterpretAsUUID>;\n+\n+using FunctionReinterpretAsString = FunctionReinterpretAsTyped<DataTypeString, NameReinterpretAsString>;\n+\n+using FunctionReinterpretAsFixedString = FunctionReinterpretAsTyped<DataTypeFixedString, NameReinterpretAsFixedString>;\n \n-using FunctionReinterpretAsUInt8 = FunctionReinterpretAs<DataTypeUInt8, NameReinterpretAsUInt8, false>;\n-using FunctionReinterpretAsUInt16 = FunctionReinterpretAs<DataTypeUInt16, NameReinterpretAsUInt16, false>;\n-using FunctionReinterpretAsUInt32 = FunctionReinterpretAs<DataTypeUInt32, NameReinterpretAsUInt32, true>;\n-using FunctionReinterpretAsUInt64 = FunctionReinterpretAs<DataTypeUInt64, NameReinterpretAsUInt64, true>;\n-using FunctionReinterpretAsInt8 = FunctionReinterpretAs<DataTypeInt8, NameReinterpretAsInt8, false>;\n-using FunctionReinterpretAsInt16 = FunctionReinterpretAs<DataTypeInt16, NameReinterpretAsInt16, false>;\n-using FunctionReinterpretAsInt32 = FunctionReinterpretAs<DataTypeInt32, NameReinterpretAsInt32, true>;\n-using FunctionReinterpretAsInt64 = FunctionReinterpretAs<DataTypeInt64, NameReinterpretAsInt64, true>;\n-using FunctionReinterpretAsFloat32 = FunctionReinterpretAs<DataTypeFloat32, NameReinterpretAsFloat32, true>;\n-using FunctionReinterpretAsFloat64 = FunctionReinterpretAs<DataTypeFloat64, NameReinterpretAsFloat64, true>;\n-using FunctionReinterpretAsDate = FunctionReinterpretAs<DataTypeDate, NameReinterpretAsDate, false>;\n-using FunctionReinterpretAsDateTime = FunctionReinterpretAs<DataTypeDateTime, NameReinterpretAsDateTime, false>;\n-using FunctionReinterpretAsUUID = FunctionReinterpretAs<DataTypeUUID, NameReinterpretAsUUID, false>;\n }\n \n void registerFunctionsReinterpretAs(FunctionFactory & factory)\n@@ -201,15 +416,24 @@ void registerFunctionsReinterpretAs(FunctionFactory & factory)\n     factory.registerFunction<FunctionReinterpretAsUInt16>();\n     factory.registerFunction<FunctionReinterpretAsUInt32>();\n     factory.registerFunction<FunctionReinterpretAsUInt64>();\n+    factory.registerFunction<FunctionReinterpretAsUInt256>();\n     factory.registerFunction<FunctionReinterpretAsInt8>();\n     factory.registerFunction<FunctionReinterpretAsInt16>();\n     factory.registerFunction<FunctionReinterpretAsInt32>();\n     factory.registerFunction<FunctionReinterpretAsInt64>();\n+    factory.registerFunction<FunctionReinterpretAsInt128>();\n+    factory.registerFunction<FunctionReinterpretAsInt256>();\n     factory.registerFunction<FunctionReinterpretAsFloat32>();\n     factory.registerFunction<FunctionReinterpretAsFloat64>();\n     factory.registerFunction<FunctionReinterpretAsDate>();\n     factory.registerFunction<FunctionReinterpretAsDateTime>();\n     factory.registerFunction<FunctionReinterpretAsUUID>();\n+\n+    factory.registerFunction<FunctionReinterpretAsString>();\n+\n+    factory.registerFunction<FunctionReinterpretAsFixedString>();\n+\n+    factory.registerFunction<FunctionReinterpretAs>();\n }\n \n }\ndiff --git a/src/Functions/reinterpretAsFixedString.cpp b/src/Functions/reinterpretAsFixedString.cpp\ndeleted file mode 100644\nindex 465e7dffc6ac..000000000000\n--- a/src/Functions/reinterpretAsFixedString.cpp\n+++ /dev/null\n@@ -1,96 +0,0 @@\n-#include <Functions/FunctionFactory.h>\n-\n-#include <DataTypes/DataTypeFixedString.h>\n-#include <Columns/ColumnFixedString.h>\n-#include <Common/typeid_cast.h>\n-#include <Common/memcpySmall.h>\n-\n-\n-namespace DB\n-{\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int ILLEGAL_COLUMN;\n-}\n-\n-namespace\n-{\n-\n-class FunctionReinterpretAsFixedString : public IFunction\n-{\n-public:\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAsFixedString>(); }\n-\n-    static constexpr auto name = \"reinterpretAsFixedString\";\n-\n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    size_t getNumberOfArguments() const override { return 1; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        const IDataType & type = *arguments[0];\n-\n-        if (type.isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())\n-            return std::make_shared<DataTypeFixedString>(type.getSizeOfValueInMemory());\n-        throw Exception(\"Cannot reinterpret \" + type.getName() + \" as FixedString because it is not fixed size and contiguous in memory\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-    }\n-\n-    static void NO_INLINE executeToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)\n-    {\n-        size_t rows = src.size();\n-        ColumnFixedString::Chars & data_to = dst.getChars();\n-        data_to.resize(n * rows);\n-\n-        ColumnFixedString::Offset offset = 0;\n-        for (size_t i = 0; i < rows; ++i)\n-        {\n-            StringRef data = src.getDataAt(i);\n-            memcpySmallAllowReadWriteOverflow15(&data_to[offset], data.data, n);\n-            offset += n;\n-        }\n-    }\n-\n-    static void NO_INLINE executeContiguousToFixedString(const IColumn & src, ColumnFixedString & dst, size_t n)\n-    {\n-        size_t rows = src.size();\n-        ColumnFixedString::Chars & data_to = dst.getChars();\n-        data_to.resize(n * rows);\n-\n-        memcpy(data_to.data(), src.getRawData().data, data_to.size());\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n-    {\n-        const IColumn & src = *arguments[0].column;\n-        MutableColumnPtr dst = result_type->createColumn();\n-\n-        if (ColumnFixedString * dst_concrete = typeid_cast<ColumnFixedString *>(dst.get()))\n-        {\n-            if (src.isFixedAndContiguous() && src.sizeOfValueIfFixed() == dst_concrete->getN())\n-                executeContiguousToFixedString(src, *dst_concrete, dst_concrete->getN());\n-            else\n-                executeToFixedString(src, *dst_concrete, dst_concrete->getN());\n-        }\n-        else\n-            throw Exception(\"Illegal column \" + src.getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN);\n-\n-        return dst;\n-    }\n-};\n-\n-}\n-\n-void registerFunctionReinterpretAsFixedString(FunctionFactory & factory)\n-{\n-    factory.registerFunction<FunctionReinterpretAsFixedString>();\n-}\n-\n-}\n-\ndiff --git a/src/Functions/reinterpretAsString.cpp b/src/Functions/reinterpretAsString.cpp\ndeleted file mode 100644\nindex 70db8f315bd3..000000000000\n--- a/src/Functions/reinterpretAsString.cpp\n+++ /dev/null\n@@ -1,92 +0,0 @@\n-#include <Functions/FunctionFactory.h>\n-\n-#include <DataTypes/DataTypeString.h>\n-#include <Columns/ColumnString.h>\n-#include <Common/typeid_cast.h>\n-#include <Common/memcpySmall.h>\n-\n-\n-namespace DB\n-{\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-}\n-\n-namespace\n-{\n-\n-/** Function for transforming numbers and dates to strings that contain the same set of bytes in the machine representation. */\n-class FunctionReinterpretAsString : public IFunction\n-{\n-public:\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionReinterpretAsString>(); }\n-\n-    static constexpr auto name = \"reinterpretAsString\";\n-\n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    size_t getNumberOfArguments() const override { return 1; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        const IDataType & type = *arguments[0];\n-\n-        if (type.isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n-            return std::make_shared<DataTypeString>();\n-        throw Exception(\"Cannot reinterpret \" + type.getName() + \" as String because it is not contiguous in memory\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-    }\n-\n-    static void executeToString(const IColumn & src, ColumnString & dst)\n-    {\n-        size_t rows = src.size();\n-        ColumnString::Chars & data_to = dst.getChars();\n-        ColumnString::Offsets & offsets_to = dst.getOffsets();\n-        offsets_to.resize(rows);\n-\n-        ColumnString::Offset offset = 0;\n-        for (size_t i = 0; i < rows; ++i)\n-        {\n-            StringRef data = src.getDataAt(i);\n-\n-            /// Cut trailing zero bytes.\n-            while (data.size && data.data[data.size - 1] == 0)\n-                --data.size;\n-\n-            data_to.resize(offset + data.size + 1);\n-            memcpySmallAllowReadWriteOverflow15(&data_to[offset], data.data, data.size);\n-            offset += data.size;\n-            data_to[offset] = 0;\n-            ++offset;\n-            offsets_to[i] = offset;\n-        }\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n-    {\n-        const IColumn & src = *arguments[0].column;\n-        MutableColumnPtr dst = result_type->createColumn();\n-\n-        if (ColumnString * dst_concrete = typeid_cast<ColumnString *>(dst.get()))\n-            executeToString(src, *dst_concrete);\n-        else\n-            throw Exception(\"Illegal column \" + src.getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN);\n-\n-        return dst;\n-    }\n-};\n-\n-}\n-\n-void registerFunctionReinterpretAsString(FunctionFactory & factory)\n-{\n-    factory.registerFunction<FunctionReinterpretAsString>();\n-}\n-\n-}\ndiff --git a/src/Functions/ya.make b/src/Functions/ya.make\nindex 9488c9d7d4e5..9032a80dfd69 100644\n--- a/src/Functions/ya.make\n+++ b/src/Functions/ya.make\n@@ -409,8 +409,6 @@ SRCS(\n     registerFunctionsUnixTimestamp64.cpp\n     registerFunctionsVisitParam.cpp\n     reinterpretAs.cpp\n-    reinterpretAsFixedString.cpp\n-    reinterpretAsString.cpp\n     repeat.cpp\n     replaceAll.cpp\n     replaceOne.cpp\n",
  "test_patch": "diff --git a/tests/performance/reinterpret_as.xml b/tests/performance/reinterpret_as.xml\nnew file mode 100644\nindex 000000000000..50cf0cb22781\n--- /dev/null\n+++ b/tests/performance/reinterpret_as.xml\n@@ -0,0 +1,257 @@\n+<test max_ignored_relative_change=\"0.2\">\n+    <settings>\n+        <allow_experimental_bigint_types>1</allow_experimental_bigint_types>\n+        <max_memory_usage>15G</max_memory_usage>\n+    </settings>\n+\n+    <query>\n+        SELECT\n+            reinterpretAsUInt8(a),\n+            reinterpretAsUInt8(b),\n+            reinterpretAsUInt8(c),\n+            reinterpretAsUInt8(d),\n+            reinterpretAsUInt8(f),\n+            reinterpretAsUInt8(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsUInt16(a),\n+            reinterpretAsUInt16(b),\n+            reinterpretAsUInt16(c),\n+            reinterpretAsUInt16(d),\n+            reinterpretAsUInt16(f),\n+            reinterpretAsUInt16(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsUInt32(a),\n+            reinterpretAsUInt32(b),\n+            reinterpretAsUInt32(c),\n+            reinterpretAsUInt32(d),\n+            reinterpretAsUInt32(f),\n+            reinterpretAsUInt32(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsUInt64(a),\n+            reinterpretAsUInt64(b),\n+            reinterpretAsUInt64(c),\n+            reinterpretAsUInt64(d),\n+            reinterpretAsUInt64(f),\n+            reinterpretAsUInt64(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsUInt256(a),\n+            reinterpretAsUInt256(b),\n+            reinterpretAsUInt256(c),\n+            reinterpretAsUInt256(d),\n+            reinterpretAsUInt256(f),\n+            reinterpretAsUInt256(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+\n+    <query>\n+        SELECT\n+            reinterpretAsInt8(a),\n+            reinterpretAsInt8(b),\n+            reinterpretAsInt8(c),\n+            reinterpretAsInt8(d),\n+            reinterpretAsInt8(f),\n+            reinterpretAsInt8(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsInt16(a),\n+            reinterpretAsInt16(b),\n+            reinterpretAsInt16(c),\n+            reinterpretAsInt16(d),\n+            reinterpretAsInt16(f),\n+            reinterpretAsInt16(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsInt32(a),\n+            reinterpretAsInt32(b),\n+            reinterpretAsInt32(c),\n+            reinterpretAsInt32(d),\n+            reinterpretAsInt32(f),\n+            reinterpretAsInt32(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsInt64(a),\n+            reinterpretAsInt64(b),\n+            reinterpretAsInt64(c),\n+            reinterpretAsInt64(d),\n+            reinterpretAsInt64(f),\n+            reinterpretAsInt64(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsInt128(a),\n+            reinterpretAsInt128(b),\n+            reinterpretAsInt128(c),\n+            reinterpretAsInt128(d),\n+            reinterpretAsInt128(f),\n+            reinterpretAsInt128(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    <query>\n+        SELECT\n+            reinterpretAsInt256(a),\n+            reinterpretAsInt256(b),\n+            reinterpretAsInt256(c),\n+            reinterpretAsInt256(d),\n+            reinterpretAsInt256(f),\n+            reinterpretAsInt256(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+\n+    <query>\n+        SELECT\n+            reinterpretAsString(a),\n+            reinterpretAsString(b),\n+            reinterpretAsString(c),\n+            reinterpretAsString(d),\n+            reinterpretAsString(f),\n+            reinterpretAsString(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+    \n+    <query>\n+         SELECT\n+            reinterpretAsFixedString(a),\n+            reinterpretAsFixedString(b),\n+            reinterpretAsFixedString(c),\n+            reinterpretAsFixedString(d),\n+            reinterpretAsFixedString(g),\n+\n+            toUInt64(number) as a,\n+            toUInt256(number) as b,\n+            toInt128(number) as c,\n+            toInt256(number) as d,\n+            toString(number) as f,\n+            toFixedString(f, 20) as g\n+        FROM numbers_mt(200000000)\n+        SETTINGS max_threads = 8\n+        FORMAT Null\n+    </query>\n+\n+</test>\ndiff --git a/tests/queries/0_stateless/01676_reinterpret_as.reference b/tests/queries/0_stateless/01676_reinterpret_as.reference\nnew file mode 100644\nindex 000000000000..bbde2d5ed575\n--- /dev/null\n+++ b/tests/queries/0_stateless/01676_reinterpret_as.reference\n@@ -0,0 +1,30 @@\n+Into String\n+1\n+Into FixedString\n+1\n+1\\0\n+1\\0\\0\n+1\\0\\0\\0\n+1\n+Into Numeric Representable\n+Integer and Integer types\n+1\t1\n+1\t1\n+257\t257\n+257\t257\n+257\t257\n+257\t257\n+257\t257\n+257\t257\n+257\t257\n+257\t257\n+257\t257\n+Integer and Float types\n+1045220557\t1045220557\n+4596373779694328218\t4596373779694328218\n+0.2\t1045220557\n+0.2\t4596373779694328218\n+Integer and String types\n+1\t49\n+1\t49\n+11\t12593\ndiff --git a/tests/queries/0_stateless/01676_reinterpret_as.sql b/tests/queries/0_stateless/01676_reinterpret_as.sql\nnew file mode 100644\nindex 000000000000..88dc64370439\n--- /dev/null\n+++ b/tests/queries/0_stateless/01676_reinterpret_as.sql\n@@ -0,0 +1,30 @@\n+SELECT 'Into String';\n+SELECT reinterpretAs(49, 'String');\n+SELECT 'Into FixedString';\n+SELECT reinterpretAs(49, 'FixedString(1)');\n+SELECT reinterpretAs(49, 'FixedString(2)');\n+SELECT reinterpretAs(49, 'FixedString(3)');\n+SELECT reinterpretAs(49, 'FixedString(4)');\n+SELECT reinterpretAsFixedString(49);\n+SELECT 'Into Numeric Representable';\n+SELECT 'Integer and Integer types';\n+SELECT reinterpretAs(257, 'UInt8'), reinterpretAsUInt8(257);\n+SELECT reinterpretAs(257, 'Int8'), reinterpretAsInt8(257);\n+SELECT reinterpretAs(257, 'UInt16'), reinterpretAsUInt16(257);\n+SELECT reinterpretAs(257, 'Int16'), reinterpretAsInt16(257);\n+SELECT reinterpretAs(257, 'UInt32'), reinterpretAsUInt32(257);\n+SELECT reinterpretAs(257, 'Int32'), reinterpretAsInt32(257);\n+SELECT reinterpretAs(257, 'UInt64'), reinterpretAsUInt64(257);\n+SELECT reinterpretAs(257, 'Int64'), reinterpretAsInt64(257);\n+SELECT reinterpretAs(257, 'Int128'), reinterpretAsInt128(257);\n+SELECT reinterpretAs(257, 'UInt256'), reinterpretAsUInt256(257);\n+SELECT reinterpretAs(257, 'Int256'), reinterpretAsInt256(257);\n+SELECT 'Integer and Float types';\n+SELECT reinterpretAs(toFloat32(0.2), 'UInt32'), reinterpretAsUInt32(toFloat32(0.2));\n+SELECT reinterpretAs(toFloat64(0.2), 'UInt64'), reinterpretAsUInt64(toFloat64(0.2));\n+SELECT reinterpretAsFloat32(a), reinterpretAsUInt32(toFloat32(0.2)) as a;\n+SELECT reinterpretAsFloat64(a), reinterpretAsUInt64(toFloat64(0.2)) as a;\n+SELECT 'Integer and String types';\n+SELECT reinterpretAsString(a), reinterpretAsUInt8('1') as a;\n+SELECT reinterpretAsString(a), reinterpretAsUInt8('11') as a;\n+SELECT reinterpretAsString(a), reinterpretAsUInt16('11') as a;\n",
  "problem_statement": "how to convert FixedString(16) to UInt256 in CH?\n\n",
  "hints_text": "Hello, @chenk818 \r\n\r\n```SQL\r\nCREATE TABLE test_fixed_string(value FixedString(16)) ENGINE=TinyLog;\r\nINSERT INTO test_fixed_string VALUES ('1'), ('2'), ('3');\r\nSELECT value, toInt256(value), cast(value, 'Int256') FROM test_fixed_string\r\n```\r\nResult:\r\n```\r\n\u250c\u2500value\u2500\u252c\u2500toInt256(value)\u2500\u252c\u2500cast(value, 'Int256')\u2500\u2510\r\n\u2502 1     \u2502               1 \u2502                     1 \u2502\r\n\u2502 2     \u2502               2 \u2502                     2 \u2502\r\n\u2502 3     \u2502               3 \u2502                     3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nFor additional reference:\r\nInformation about type conversions: https://clickhouse.tech/docs/en/sql-reference/functions/type-conversion-functions/#toint8163264128256\r\nLink to our test ClickHouse setup where you can experiment with queries: https://gh-api.clickhouse.tech/play.\n> Hello, @chenk818\r\n> \r\n> ```sql\r\n> CREATE TABLE test_fixed_string(value FixedString(16)) ENGINE=TinyLog;\r\n> INSERT INTO test_fixed_string VALUES ('1'), ('2'), ('3');\r\n> SELECT value, toInt256(value), cast(value, 'Int256') FROM test_fixed_string\r\n> ```\r\n> \r\n> Result:\r\n> \r\n> ```\r\n> \u250c\u2500value\u2500\u252c\u2500toInt256(value)\u2500\u252c\u2500cast(value, 'Int256')\u2500\u2510\r\n> \u2502 1     \u2502               1 \u2502                     1 \u2502\r\n> \u2502 2     \u2502               2 \u2502                     2 \u2502\r\n> \u2502 3     \u2502               3 \u2502                     3 \u2502\r\n> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n> ```\r\n> \r\n> For additional reference:\r\n> Information about type conversions: https://clickhouse.tech/docs/en/sql-reference/functions/type-conversion-functions/#toint8163264128256\r\n> Link to our test ClickHouse setup where you can experiment with queries: https://gh-api.clickhouse.tech/play.\r\n\r\n@kitaisreal  thanks,but my question is not like this.\r\nI have a cloumn with String type,and want to convert it to UInt type\u3002So i used sipHash128 function to convert the String colunn into FixedString(16).Just like below:\r\n\r\nSELECT sipHash128('hello') AS a\r\n\r\n\u250c\u2500a\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 T3\"X!\r\n\r\nThen how to convert a to UInt256?\r\n",
  "created_at": "2021-01-30T19:58:38Z",
  "modified_files": [
    "docs/en/sql-reference/functions/type-conversion-functions.md",
    "src/Core/callOnTypeIndex.h",
    "src/Functions/registerFunctionsReinterpret.cpp",
    "src/Functions/reinterpretAs.cpp",
    "src/Functions/reinterpretAsFixedString.cpp",
    "src/Functions/reinterpretAsString.cpp",
    "src/Functions/ya.make"
  ],
  "modified_test_files": [
    "b/tests/performance/reinterpret_as.xml",
    "b/tests/queries/0_stateless/01676_reinterpret_as.reference",
    "b/tests/queries/0_stateless/01676_reinterpret_as.sql"
  ]
}