diff --git a/src/Columns/tests/gtest_column_object.cpp b/src/Columns/tests/gtest_column_object.cpp
index d5e58e5fce24..e1ad949f6a80 100644
--- a/src/Columns/tests/gtest_column_object.cpp
+++ b/src/Columns/tests/gtest_column_object.cpp
@@ -89,7 +89,7 @@ TEST(ColumnObject, InsertRangeFrom)
 
         const auto & type_dst = subcolumn_dst.getLeastCommonType();
         const auto & type_src = subcolumn_src.getLeastCommonType();
-        auto type_res = getLeastSupertype(DataTypes{type_dst, type_src}, true);
+        auto type_res = getLeastSupertypeOrString(DataTypes{type_dst, type_src});
 
         size_t from = rng() % subcolumn_src.size();
         size_t to = rng() % subcolumn_src.size();
diff --git a/tests/performance/json_type.xml b/tests/performance/json_type.xml
new file mode 100644
index 000000000000..b6406f525793
--- /dev/null
+++ b/tests/performance/json_type.xml
@@ -0,0 +1,41 @@
+<test>
+    <settings>
+        <allow_experimental_object_type>1</allow_experimental_object_type>
+    </settings>
+
+    <!-- Looks like the only way to use json in test's queries is to put them to substitution.
+         Otherwise jsons are interpreted as substitutions themselves -->
+
+    <substitutions>
+        <substitution>
+            <name>json1</name>
+            <values>
+                <value>'{"k1":1, "k2": "some"}'</value>
+            </values>
+        </substitution>
+        <substitution>
+            <name>json2</name>
+            <values>
+                <value>'{"col' || toString(number % 100) || '":' || toString(number) || '}'</value>
+            </values>
+        </substitution>
+        <substitution>
+            <name>json3</name>
+            <values>
+                <value>'{"k1":[{"k2":"aaa","k3":[{"k4":"bbb"},{"k4":"ccc"}]},{"k2":"ddd","k3":[{"k4":"eee"},{"k4":"fff"}]}]}'</value>
+            </values>
+        </substitution>
+    </substitutions>
+
+    <create_query>CREATE TABLE t_json_1(data JSON) ENGINE = MergeTree ORDER BY tuple()</create_query>
+    <create_query>CREATE TABLE t_json_2(data JSON) ENGINE = MergeTree ORDER BY tuple()</create_query>
+    <create_query>CREATE TABLE t_json_3(data JSON) ENGINE = MergeTree ORDER BY tuple()</create_query>
+
+    <query>INSERT INTO t_json_1 SELECT materialize({json1}) FROM numbers(200000)</query>
+    <query>INSERT INTO t_json_2 SELECT {json2} FROM numbers(100000)</query>
+    <query>INSERT INTO t_json_3 SELECT materialize({json3}) FROM numbers_mt(100000)</query>
+
+    <drop_query>DROP TABLE IF EXISTS t_json_1</drop_query>
+    <drop_query>DROP TABLE IF EXISTS t_json_2</drop_query>
+    <drop_query>DROP TABLE IF EXISTS t_json_3</drop_query>
+</test>
diff --git a/tests/queries/0_stateless/01825_type_json_parallel_insert.reference b/tests/queries/0_stateless/01825_type_json_parallel_insert.reference
index ac512064a436..158d61d46f7b 100644
--- a/tests/queries/0_stateless/01825_type_json_parallel_insert.reference
+++ b/tests/queries/0_stateless/01825_type_json_parallel_insert.reference
@@ -1,1 +1,1 @@
-Tuple(k1 Int8, k2 String)	3000000
+Tuple(k1 Int8, k2 String)	500000
diff --git a/tests/queries/0_stateless/01825_type_json_parallel_insert.sql b/tests/queries/0_stateless/01825_type_json_parallel_insert.sql
index 93d1eecfbd76..e443c9455d58 100644
--- a/tests/queries/0_stateless/01825_type_json_parallel_insert.sql
+++ b/tests/queries/0_stateless/01825_type_json_parallel_insert.sql
@@ -1,10 +1,10 @@
 -- Tags: long, no-backward-compatibility-check:22.3.2.1
 DROP TABLE IF EXISTS t_json_parallel;
 
-SET allow_experimental_object_type = 1, max_insert_threads = 20, max_threads = 20;
+SET allow_experimental_object_type = 1, max_insert_threads = 20, max_threads = 20, min_insert_block_size_rows = 65536;
 CREATE TABLE t_json_parallel (data JSON) ENGINE = MergeTree ORDER BY tuple();
 
-INSERT INTO t_json_parallel SELECT materialize('{"k1":1, "k2": "some"}') FROM numbers_mt(3000000);
+INSERT INTO t_json_parallel SELECT materialize('{"k1":1, "k2": "some"}') FROM numbers_mt(500000);
 SELECT any(toTypeName(data)), count() FROM t_json_parallel;
 
 DROP TABLE t_json_parallel;
