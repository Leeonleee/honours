diff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h
index 18d4526e0f35..b55083cd671a 100644
--- a/src/Columns/ColumnDecimal.h
+++ b/src/Columns/ColumnDecimal.h
@@ -87,7 +87,7 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T
 
 public:
     const char * getFamilyName() const override { return TypeName<T>.data(); }
-    TypeIndex getDataType() const override { return TypeId<T>; }
+    TypeIndex getDataType() const override { return TypeToTypeIndex<T>; }
 
     bool isNumeric() const override { return false; }
     bool canBeInsideNullable() const override { return true; }
diff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h
index bee7bfa738c7..62a0e3a11904 100644
--- a/src/Columns/ColumnVector.h
+++ b/src/Columns/ColumnVector.h
@@ -238,7 +238,7 @@ class ColumnVector final : public COWHelper<ColumnVectorHelper, ColumnVector<T>>
     }
 
     const char * getFamilyName() const override { return TypeName<T>.data(); }
-    TypeIndex getDataType() const override { return TypeId<T>; }
+    TypeIndex getDataType() const override { return TypeToTypeIndex<T>; }
 
     MutableColumnPtr cloneResized(size_t size) const override;
 
diff --git a/src/Core/TypeId.h b/src/Core/TypeId.h
index 3218db10778a..390587731842 100644
--- a/src/Core/TypeId.h
+++ b/src/Core/TypeId.h
@@ -10,12 +10,12 @@ namespace DB
  * Returns TypeIndex::Nothing if type was not present in TypeIndex;
  * Returns TypeIndex element otherwise.
  *
- * @example TypeId<UInt8> == TypeIndex::UInt8
- * @example TypeId<MySuperType> == TypeIndex::Nothing
+ * @example TypeToTypeIndex<UInt8> == TypeIndex::UInt8
+ * @example TypeToTypeIndex<MySuperType> == TypeIndex::Nothing
  */
-template <class T> inline constexpr TypeIndex TypeId = TypeIndex::Nothing;
+template <class T> inline constexpr TypeIndex TypeToTypeIndex = TypeIndex::Nothing;
 
-template <TypeIndex index> struct ReverseTypeIdT : std::false_type {};
+template <TypeIndex index> struct TypeIndexToTypeHelper : std::false_type {};
 
 /**
  * Obtain real type from TypeIndex if possible.
@@ -23,14 +23,14 @@ template <TypeIndex index> struct ReverseTypeIdT : std::false_type {};
  * Returns a type alias if is corresponds to TypeIndex value.
  * Yields a compiler error otherwise.
  *
- * @example ReverseTypeId<TypeIndex::UInt8> == UInt8
+ * @example TypeIndexToType<TypeIndex::UInt8> == UInt8
  */
-template <TypeIndex index> using ReverseTypeId = typename ReverseTypeIdT<index>::T;
-template <TypeIndex index> constexpr bool HasReverseTypeId = ReverseTypeIdT<index>::value;
+template <TypeIndex index> using TypeIndexToType = typename TypeIndexToTypeHelper<index>::T;
+template <TypeIndex index> constexpr bool TypeIndexHasType = TypeIndexToTypeHelper<index>::value;
 
 #define TYPEID_MAP(_A) \
-    template <> inline constexpr TypeIndex TypeId<_A> = TypeIndex::_A; \
-    template <> struct ReverseTypeIdT<TypeIndex::_A> : std::true_type { using T = _A; };
+    template <> inline constexpr TypeIndex TypeToTypeIndex<_A> = TypeIndex::_A; \
+    template <> struct TypeIndexToTypeHelper<TypeIndex::_A> : std::true_type { using T = _A; };
 
 TYPEID_MAP(UInt8)
 TYPEID_MAP(UInt16)
@@ -58,4 +58,7 @@ TYPEID_MAP(String)
 
 struct Array;
 TYPEID_MAP(Array)
+
+#undef TYPEID_MAP
+
 }
diff --git a/src/DataTypes/DataTypeDecimalBase.h b/src/DataTypes/DataTypeDecimalBase.h
index c0585095eebe..a92defea8249 100644
--- a/src/DataTypes/DataTypeDecimalBase.h
+++ b/src/DataTypes/DataTypeDecimalBase.h
@@ -74,7 +74,7 @@ class DataTypeDecimalBase : public IDataType
             throw Exception("Scale " + std::to_string(scale) + " is out of bounds", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
     }
 
-    TypeIndex getTypeId() const override { return TypeId<T>; }
+    TypeIndex getTypeId() const override { return TypeToTypeIndex<T>; }
 
     Field getDefault() const override;
     MutableColumnPtr createColumn() const override;
diff --git a/src/DataTypes/DataTypeNumberBase.h b/src/DataTypes/DataTypeNumberBase.h
index 959750516008..842ae1bb9eaa 100644
--- a/src/DataTypes/DataTypeNumberBase.h
+++ b/src/DataTypes/DataTypeNumberBase.h
@@ -25,7 +25,7 @@ class DataTypeNumberBase : public IDataType
     using ColumnType = ColumnVector<T>;
 
     const char * getFamilyName() const override { return TypeName<T>.data(); }
-    TypeIndex getTypeId() const override { return TypeId<T>; }
+    TypeIndex getTypeId() const override { return TypeToTypeIndex<T>; }
 
     Field getDefault() const override;
 
diff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h
index 199f7796f025..fb590dd1d4b2 100644
--- a/src/DataTypes/DataTypesDecimal.h
+++ b/src/DataTypes/DataTypesDecimal.h
@@ -38,7 +38,7 @@ class DataTypeDecimal final : public DataTypeDecimalBase<T>
 
     const char * getFamilyName() const override { return family_name; }
     std::string doGetName() const override;
-    TypeIndex getTypeId() const override { return TypeId<T>; }
+    TypeIndex getTypeId() const override { return TypeToTypeIndex<T>; }
     bool canBePromoted() const override { return true; }
     DataTypePtr promoteNumericType() const override;
 
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 864dde0e86e0..da4bb448e39c 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -473,7 +473,7 @@ template <typename T, typename DataType>
 inline bool isColumnedAsDecimalT(const DataType & data_type)
 {
     const WhichDataType which(data_type);
-    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeId<T>;
+    return (which.isDecimal() || which.isDateTime64()) && which.idx == TypeToTypeIndex<T>;
 }
 
 template <typename T>
diff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp
index 21d430312048..4bf8419df5ba 100644
--- a/src/Dictionaries/DictionaryStructure.cpp
+++ b/src/Dictionaries/DictionaryStructure.cpp
@@ -1,17 +1,20 @@
-#include "DictionaryStructure.h"
+#include <Dictionaries/DictionaryStructure.h>
+
+#include <numeric>
+#include <unordered_map>
+#include <unordered_set>
+
+#include <IO/WriteHelpers.h>
+#include <IO/Operators.h>
+
+#include <Common/StringUtils/StringUtils.h>
+
+#include <Formats/FormatSettings.h>
 #include <Columns/IColumn.h>
 #include <DataTypes/DataTypeFactory.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <DataTypes/DataTypeArray.h>
 #include <Functions/FunctionHelpers.h>
-#include <Formats/FormatSettings.h>
-#include <IO/WriteHelpers.h>
-#include <IO/Operators.h>
-#include <Common/StringUtils/StringUtils.h>
-
-#include <numeric>
-#include <unordered_map>
-#include <unordered_set>
 
 
 namespace DB
@@ -38,13 +41,14 @@ DictionaryTypedSpecialAttribute makeDictionaryTypedSpecialAttribute(
     return DictionaryTypedSpecialAttribute{std::move(name), std::move(expression), DataTypeFactory::instance().get(type_name)};
 }
 
-std::optional<AttributeUnderlyingType> maybeGetAttributeUnderlyingType(TypeIndex index)
+std::optional<AttributeUnderlyingType> tryGetAttributeUnderlyingType(TypeIndex index)
 {
     switch (index) /// Special cases which do not map TypeIndex::T -> AttributeUnderlyingType::T
     {
         case TypeIndex::Date:       return AttributeUnderlyingType::UInt16;
+        case TypeIndex::Date32:     return AttributeUnderlyingType::Int32;
         case TypeIndex::DateTime:   return AttributeUnderlyingType::UInt32;
-        case TypeIndex::DateTime64: return AttributeUnderlyingType::UInt64;
+        case TypeIndex::DateTime64: return AttributeUnderlyingType::Int64;
         default: break;
     }
 
@@ -296,7 +300,7 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(
 
         auto non_nullable_type = removeNullable(initial_type);
 
-        const auto underlying_type_opt = maybeGetAttributeUnderlyingType(non_nullable_type->getTypeId());
+        const auto underlying_type_opt = tryGetAttributeUnderlyingType(non_nullable_type->getTypeId());
 
         if (!underlying_type_opt)
             throw Exception(ErrorCodes::UNKNOWN_TYPE,
diff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h
index 4de00ddd259d..f0aa372ec9a6 100644
--- a/src/Dictionaries/DictionaryStructure.h
+++ b/src/Dictionaries/DictionaryStructure.h
@@ -26,7 +26,7 @@ using TypeIndexUnderlying = magic_enum::underlying_type_t<TypeIndex>;
 // We need to be able to map TypeIndex -> AttributeUnderlyingType and AttributeUnderlyingType -> real type
 // The first can be done by defining AttributeUnderlyingType enum values to TypeIndex values and then performing
 // a enum_cast.
-// The second can be achieved by using ReverseTypeId
+// The second can be achieved by using TypeIndexToType
 #define map_item(__T) __T = static_cast<TypeIndexUnderlying>(TypeIndex::__T)
 
 enum class AttributeUnderlyingType : TypeIndexUnderlying
@@ -73,7 +73,7 @@ template <AttributeUnderlyingType type>
 struct DictionaryAttributeType
 {
     /// Converts @c type to it underlying type e.g. AttributeUnderlyingType::UInt8 -> UInt8
-    using AttributeType = ReverseTypeId<
+    using AttributeType = TypeIndexToType<
         static_cast<TypeIndex>(
             static_cast<TypeIndexUnderlying>(type))>;
 };
diff --git a/src/Functions/FunctionsConversion.cpp b/src/Functions/FunctionsConversion.cpp
index f32d5df8a213..4f5f6ae483f4 100644
--- a/src/Functions/FunctionsConversion.cpp
+++ b/src/Functions/FunctionsConversion.cpp
@@ -32,7 +32,7 @@ void registerFunctionsConversion(FunctionFactory & factory)
     factory.registerFunction<FunctionToDecimal256>();
 
     factory.registerFunction<FunctionToDate>();
-    /// MysQL compatibility alias.
+    /// MySQL compatibility alias.
     factory.registerFunction<FunctionToDate>("DATE", FunctionFactory::CaseInsensitive);
     factory.registerFunction<FunctionToDate32>();
     factory.registerFunction<FunctionToDateTime>();
