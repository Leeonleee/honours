diff --git a/src/AggregateFunctions/AggregateFunctionFactory.cpp b/src/AggregateFunctions/AggregateFunctionFactory.cpp
index 4c2c64ef5e19..eac761c1a827 100644
--- a/src/AggregateFunctions/AggregateFunctionFactory.cpp
+++ b/src/AggregateFunctions/AggregateFunctionFactory.cpp
@@ -178,6 +178,12 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(
         /// uniqCombinedIfMergeIf is useful in cases when the underlying
         /// storage stores AggregateFunction(uniqCombinedIf) and in SELECT you
         /// need to filter aggregation result based on another column.
+
+#if defined(UNBUNDLED)
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wstringop-overread"
+#endif
+
         if (!combinator->supportsNesting() && nested_name.ends_with(combinator_name))
         {
             throw Exception(ErrorCodes::ILLEGAL_AGGREGATION,
@@ -185,6 +191,10 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(
                 combinator_name);
         }
 
+#if defined(UNBUNDLED)
+#pragma GCC diagnostic pop
+#endif
+
         DataTypes nested_types = combinator->transformArguments(argument_types);
         Array nested_parameters = combinator->transformParameters(parameters);
 
diff --git a/src/Common/Macros.cpp b/src/Common/Macros.cpp
index 339f3f43fc41..f66e3462e825 100644
--- a/src/Common/Macros.cpp
+++ b/src/Common/Macros.cpp
@@ -106,6 +106,16 @@ String Macros::expand(const String & s,
             res += toString(info.table_id.uuid);
             info.expanded_uuid = true;
         }
+        else if (info.shard && macro_name == "shard")
+        {
+            res += *info.shard;
+            info.expanded_uuid = true;
+        }
+        else if (info.replica && macro_name == "replica")
+        {
+            res += *info.replica;
+            info.expanded_uuid = true;
+        }
         else if (info.ignore_unknown || info.expand_special_macros_only)
         {
             if (info.expand_special_macros_only)
diff --git a/src/Common/Macros.h b/src/Common/Macros.h
index 3e6fbff1519f..dea3a3851f01 100644
--- a/src/Common/Macros.h
+++ b/src/Common/Macros.h
@@ -34,6 +34,8 @@ class Macros
         StorageID table_id = StorageID::createEmpty();
         bool ignore_unknown = false;
         bool expand_special_macros_only = false;
+        std::optional<String> shard;
+        std::optional<String> replica;
 
         /// Information about macro expansion
         size_t level = 0;
diff --git a/src/Databases/DatabaseFactory.cpp b/src/Databases/DatabaseFactory.cpp
index 264807534b39..e5fdff97c86e 100644
--- a/src/Databases/DatabaseFactory.cpp
+++ b/src/Databases/DatabaseFactory.cpp
@@ -8,6 +8,7 @@
 #include <Databases/DatabaseOrdinary.h>
 #include <Databases/DatabaseReplicated.h>
 #include <Interpreters/Context.h>
+#include <Interpreters/evaluateConstantExpression.h>
 #include <Parsers/ASTCreateQuery.h>
 #include <Parsers/ASTFunction.h>
 #include <Parsers/ASTIdentifier.h>
@@ -30,7 +31,6 @@
 
 #if USE_MYSQL || USE_LIBPQXX
 #include <Common/parseRemoteDescription.h>
-#include <Interpreters/evaluateConstantExpression.h>
 #include <Common/parseAddress.h>
 #endif
 
@@ -258,7 +258,9 @@ DatabasePtr DatabaseFactory::getImpl(const ASTCreateQuery & create, const String
         if (!engine->arguments || engine->arguments->children.size() != 3)
             throw Exception("Replicated database requires 3 arguments: zookeeper path, shard name and replica name", ErrorCodes::BAD_ARGUMENTS);
 
-        const auto & arguments = engine->arguments->children;
+        auto & arguments = engine->arguments->children;
+        for (auto & engine_arg : arguments)
+            engine_arg = evaluateConstantExpressionOrIdentifierAsLiteral(engine_arg, context);
 
         String zookeeper_path = safeGetLiteralValue<String>(arguments[0], "Replicated");
         String shard_name = safeGetLiteralValue<String>(arguments[1], "Replicated");
diff --git a/src/Databases/DatabaseReplicated.h b/src/Databases/DatabaseReplicated.h
index cc25b2128fbf..fcb8a2c4d330 100644
--- a/src/Databases/DatabaseReplicated.h
+++ b/src/Databases/DatabaseReplicated.h
@@ -50,6 +50,8 @@ class DatabaseReplicated : public DatabaseAtomic
 
     void stopReplication() override;
 
+    String getShardName() const { return shard_name; }
+    String getReplicaName() const { return replica_name; }
     String getFullReplicaName() const;
     static std::pair<String, String> parseFullReplicaName(const String & name);
 
diff --git a/src/Databases/DatabaseReplicatedHelpers.cpp b/src/Databases/DatabaseReplicatedHelpers.cpp
new file mode 100644
index 000000000000..26090547e2cd
--- /dev/null
+++ b/src/Databases/DatabaseReplicatedHelpers.cpp
@@ -0,0 +1,17 @@
+#include <Databases/DatabaseReplicatedHelpers.h>
+#include <Databases/DatabaseReplicated.h>
+
+namespace DB
+{
+
+String getReplicatedDatabaseShardName(const DatabasePtr & database)
+{
+    return assert_cast<const DatabaseReplicated *>(database.get())->getShardName();
+}
+
+String getReplicatedDatabaseReplicaName(const DatabasePtr & database)
+{
+    return assert_cast<const DatabaseReplicated *>(database.get())->getReplicaName();
+}
+
+}
diff --git a/src/Databases/DatabaseReplicatedHelpers.h b/src/Databases/DatabaseReplicatedHelpers.h
new file mode 100644
index 000000000000..ee9077e213ca
--- /dev/null
+++ b/src/Databases/DatabaseReplicatedHelpers.h
@@ -0,0 +1,14 @@
+#pragma once
+#include <Core/Types.h>
+#include <memory>
+
+namespace DB
+{
+
+class IDatabase;
+using DatabasePtr = std::shared_ptr<IDatabase>;
+
+String getReplicatedDatabaseShardName(const DatabasePtr & database);
+String getReplicatedDatabaseReplicaName(const DatabasePtr & database);
+
+}
diff --git a/src/Databases/TablesLoader.cpp b/src/Databases/TablesLoader.cpp
index 31581a97fcc0..b8c380b7be19 100644
--- a/src/Databases/TablesLoader.cpp
+++ b/src/Databases/TablesLoader.cpp
@@ -36,8 +36,19 @@ void mergeDependenciesGraphs(DependenciesInfos & main_dependencies_info, const D
             if (maybe_existing_info.dependencies.empty())
                 maybe_existing_info.dependencies = dependencies;
             else if (maybe_existing_info.dependencies != dependencies)
-                throw Exception(ErrorCodes::LOGICAL_ERROR, "Have different dependencies for {}: {} and {}, it's a bug",
-                                table, fmt::join(maybe_existing_info.dependencies, ", "), fmt::join(dependencies, ", "));
+            {
+                /// Can happen on DatabaseReplicated recovery
+                LOG_WARNING(&Poco::Logger::get("TablesLoader"), "Replacing outdated dependencies ({}) of {} with: {}",
+                            fmt::join(maybe_existing_info.dependencies, ", "),
+                            table,
+                            fmt::join(dependencies, ", "));
+                for (const auto & old_dependency : maybe_existing_info.dependencies)
+                {
+                    [[maybe_unused]] bool removed = main_dependencies_info[old_dependency].dependent_database_objects.erase(table);
+                    assert(removed);
+                }
+                maybe_existing_info.dependencies = dependencies;
+            }
         }
     }
 }
diff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp
index e2f0fc761b1e..cb52c8b86c0a 100644
--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp
+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp
@@ -22,6 +22,7 @@
 #include <Interpreters/Context.h>
 #include <Interpreters/evaluateConstantExpression.h>
 
+#include <Databases/DatabaseReplicatedHelpers.h>
 
 namespace DB
 {
@@ -541,6 +542,12 @@ static StoragePtr create(const StorageFactory::Arguments & args)
         /// to make possible copying metadata files between replicas.
         Macros::MacroExpansionInfo info;
         info.table_id = args.table_id;
+        if (is_replicated_database)
+        {
+            auto database = DatabaseCatalog::instance().getDatabase(args.table_id.database_name);
+            info.shard = getReplicatedDatabaseShardName(database);
+            info.replica = getReplicatedDatabaseReplicaName(database);
+        }
         if (!allow_uuid_macro)
             info.table_id.uuid = UUIDHelpers::Nil;
         zookeeper_path = args.getContext()->getMacros()->expand(zookeeper_path, info);
