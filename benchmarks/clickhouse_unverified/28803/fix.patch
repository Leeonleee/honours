diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp
index d2661874beb9..c70f0c07ea92 100644
--- a/programs/local/LocalServer.cpp
+++ b/programs/local/LocalServer.cpp
@@ -13,7 +13,7 @@
 #include <Interpreters/executeQuery.h>
 #include <Interpreters/loadMetadata.h>
 #include <Interpreters/DatabaseCatalog.h>
-#include <Interpreters/UserDefinedObjectsLoader.h>
+#include <Interpreters/UserDefinedSQLObjectsLoader.h>
 #include <Interpreters/Session.h>
 #include <Common/Exception.h>
 #include <Common/Macros.h>
@@ -295,7 +295,7 @@ try
         fs::create_directories(fs::path(path) / "user_defined/");
         LOG_DEBUG(log, "Loading user defined objects from {}", path);
         Poco::File(path + "user_defined/").createDirectories();
-        UserDefinedObjectsLoader::instance().loadObjects(global_context);
+        UserDefinedSQLObjectsLoader::instance().loadObjects(global_context);
         LOG_DEBUG(log, "Loaded user defined objects.");
 
         LOG_DEBUG(log, "Loading metadata from {}", path);
diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp
index 5ca9007bdcc4..961d8e7b4cf6 100644
--- a/programs/server/Server.cpp
+++ b/programs/server/Server.cpp
@@ -51,8 +51,8 @@
 #include <Interpreters/ExternalModelsLoader.h>
 #include <Interpreters/ProcessList.h>
 #include <Interpreters/loadMetadata.h>
+#include <Interpreters/UserDefinedSQLObjectsLoader.h>
 #include <Interpreters/JIT/CompiledExpressionCache.h>
-#include <Interpreters/UserDefinedObjectsLoader.h>
 #include <Access/AccessControlManager.h>
 #include <Storages/StorageReplicatedMergeTree.h>
 #include <Storages/System/attachSystemTables.h>
@@ -1086,7 +1086,7 @@ if (ThreadFuzzer::instance().isEffective())
     LOG_INFO(log, "Loading user defined objects from {}", path_str);
     try
     {
-        UserDefinedObjectsLoader::instance().loadObjects(global_context);
+        UserDefinedSQLObjectsLoader::instance().loadObjects(global_context);
     }
     catch (...)
     {
@@ -1473,6 +1473,17 @@ if (ThreadFuzzer::instance().isEffective())
             throw;
         }
 
+        /// try to load user defined executable functions, throw on error and die
+        try
+        {
+            global_context->loadUserDefinedExecutableFunctions(config());
+        }
+        catch (...)
+        {
+            LOG_ERROR(log, "Caught exception while loading user defined executable functions.");
+            throw;
+        }
+
         if (has_zookeeper && config().has("distributed_ddl"))
         {
             /// DDL worker should be started after all tables were loaded
diff --git a/programs/server/config.xml b/programs/server/config.xml
index fe17d5045a4f..bd1c20ffa927 100644
--- a/programs/server/config.xml
+++ b/programs/server/config.xml
@@ -1003,6 +1003,9 @@
     -->
     <dictionaries_config>*_dictionary.xml</dictionaries_config>
 
+    <!-- Configuration of user defined executable functions -->
+    <user_defined_executable_functions_config>*_function.xml</user_defined_executable_functions_config>
+
     <!-- Uncomment if you want data to be compressed 30-100% better.
          Don't do that if you just started using ClickHouse.
       -->
diff --git a/src/Access/AccessType.h b/src/Access/AccessType.h
index 8e6a8be8e36f..df060d46658e 100644
--- a/src/Access/AccessType.h
+++ b/src/Access/AccessType.h
@@ -143,6 +143,7 @@ enum class AccessType
     M(SYSTEM_RELOAD_SYMBOLS, "RELOAD SYMBOLS", GLOBAL, SYSTEM_RELOAD) \
     M(SYSTEM_RELOAD_DICTIONARY, "SYSTEM RELOAD DICTIONARIES, RELOAD DICTIONARY, RELOAD DICTIONARIES", GLOBAL, SYSTEM_RELOAD) \
     M(SYSTEM_RELOAD_MODEL, "SYSTEM RELOAD MODELS, RELOAD MODEL, RELOAD MODELS", GLOBAL, SYSTEM_RELOAD) \
+    M(SYSTEM_RELOAD_FUNCTION, "SYSTEM RELOAD FUNCTIONS, RELOAD FUNCTION, RELOAD FUNCTIONS", GLOBAL, SYSTEM_RELOAD) \
     M(SYSTEM_RELOAD_EMBEDDED_DICTIONARIES, "RELOAD EMBEDDED DICTIONARIES", GLOBAL, SYSTEM_RELOAD) /* implicitly enabled by the grant SYSTEM_RELOAD_DICTIONARY ON *.* */\
     M(SYSTEM_RELOAD, "", GROUP, SYSTEM) \
     M(SYSTEM_RESTART_DISK, "SYSTEM RESTART DISK", GLOBAL, SYSTEM) \
diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp
index 90ee30904c70..953eb68cff7d 100644
--- a/src/Interpreters/ActionsVisitor.cpp
+++ b/src/Interpreters/ActionsVisitor.cpp
@@ -37,6 +37,8 @@
 #include <Interpreters/interpretSubquery.h>
 #include <Interpreters/DatabaseAndTableWithAlias.h>
 #include <Interpreters/IdentifierSemantic.h>
+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>
+
 
 namespace DB
 {
@@ -854,17 +856,21 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &
     if (AggregateFunctionFactory::instance().isAggregateFunctionName(node.name))
         return;
 
-    FunctionOverloadResolverPtr function_builder;
-    try
-    {
-        function_builder = FunctionFactory::instance().get(node.name, data.getContext());
-    }
-    catch (Exception & e)
+    FunctionOverloadResolverPtr function_builder = UserDefinedExecutableFunctionFactory::instance().tryGet(node.name, data.getContext());
+
+    if (!function_builder)
     {
-        auto hints = AggregateFunctionFactory::instance().getHints(node.name);
-        if (!hints.empty())
-            e.addMessage("Or unknown aggregate function " + node.name + ". Maybe you meant: " + toString(hints));
-        throw;
+        try
+        {
+            function_builder = FunctionFactory::instance().get(node.name, data.getContext());
+        }
+        catch (Exception & e)
+        {
+            auto hints = AggregateFunctionFactory::instance().getHints(node.name);
+            if (!hints.empty())
+                e.addMessage("Or unknown aggregate function " + node.name + ". Maybe you meant: " + toString(hints));
+            throw;
+        }
     }
 
     Names argument_names;
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index be1cb21bbc35..14a91959d5cc 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -50,6 +50,7 @@
 #include <Dictionaries/Embedded/GeoDictionariesLoader.h>
 #include <Interpreters/EmbeddedDictionaries.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
+#include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>
 #include <Interpreters/ExternalModelsLoader.h>
 #include <Interpreters/ExpressionActions.h>
 #include <Interpreters/ProcessList.h>
@@ -145,6 +146,7 @@ struct ContextSharedPart
     /// Separate mutex for access of dictionaries. Separate mutex to avoid locks when server doing request to itself.
     mutable std::mutex embedded_dictionaries_mutex;
     mutable std::mutex external_dictionaries_mutex;
+    mutable std::mutex external_user_defined_executable_functions_mutex;
     mutable std::mutex external_models_mutex;
     /// Separate mutex for storage policies. During server startup we may
     /// initialize some important storages (system logs with MergeTree engine)
@@ -183,11 +185,13 @@ struct ContextSharedPart
 
     mutable std::optional<EmbeddedDictionaries> embedded_dictionaries;    /// Metrica's dictionaries. Have lazy initialization.
     mutable std::optional<ExternalDictionariesLoader> external_dictionaries_loader;
+    mutable std::optional<ExternalUserDefinedExecutableFunctionsLoader> external_user_defined_executable_functions_loader;
     mutable std::optional<ExternalModelsLoader> external_models_loader;
     ConfigurationPtr external_models_config;
     scope_guard models_repository_guard;
 
     scope_guard dictionaries_xmls;
+    scope_guard user_defined_executable_functions_xmls;
 
 #if USE_NLP
     mutable std::optional<SynonymsExtensions> synonyms_extensions;
@@ -341,10 +345,12 @@ struct ContextSharedPart
             /// But they cannot be created before storages since they may required table as a source,
             /// but at least they can be preserved for storage termination.
             dictionaries_xmls.reset();
+            user_defined_executable_functions_xmls.reset();
 
             delete_system_logs = std::move(system_logs);
             embedded_dictionaries.reset();
             external_dictionaries_loader.reset();
+            external_user_defined_executable_functions_loader.reset();
             models_repository_guard.reset();
             external_models_loader.reset();
             buffer_flush_schedule_pool.reset();
@@ -1324,6 +1330,18 @@ ExternalDictionariesLoader & Context::getExternalDictionariesLoader()
     return *shared->external_dictionaries_loader;
 }
 
+const ExternalUserDefinedExecutableFunctionsLoader & Context::getExternalUserDefinedExecutableFunctionsLoader() const
+{
+    return const_cast<Context *>(this)->getExternalUserDefinedExecutableFunctionsLoader();
+}
+
+ExternalUserDefinedExecutableFunctionsLoader & Context::getExternalUserDefinedExecutableFunctionsLoader()
+{
+    std::lock_guard lock(shared->external_user_defined_executable_functions_mutex);
+    if (!shared->external_user_defined_executable_functions_loader)
+        shared->external_user_defined_executable_functions_loader.emplace(getGlobalContext());
+    return *shared->external_user_defined_executable_functions_loader;
+}
 
 const ExternalModelsLoader & Context::getExternalModelsLoader() const
 {
@@ -1391,6 +1409,13 @@ void Context::loadDictionaries(const Poco::Util::AbstractConfiguration & config)
         std::make_unique<ExternalLoaderXMLConfigRepository>(config, "dictionaries_config"));
 }
 
+void Context::loadUserDefinedExecutableFunctions(const Poco::Util::AbstractConfiguration & config)
+{
+    getExternalUserDefinedExecutableFunctionsLoader().enableAlwaysLoadEverything(true);
+    shared->user_defined_executable_functions_xmls = getExternalUserDefinedExecutableFunctionsLoader().addConfigRepository(
+        std::make_unique<ExternalLoaderXMLConfigRepository>(config, "user_defined_executable_functions_config"));
+}
+
 #if USE_NLP
 
 SynonymsExtensions & Context::getSynonymsExtensions() const
diff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h
index 815bd3d23e72..b7472fb1c29b 100644
--- a/src/Interpreters/Context.h
+++ b/src/Interpreters/Context.h
@@ -48,6 +48,7 @@ class AccessRightsElements;
 class EmbeddedDictionaries;
 class ExternalDictionariesLoader;
 class ExternalModelsLoader;
+class ExternalUserDefinedExecutableFunctionsLoader;
 class InterserverCredentials;
 using InterserverCredentialsPtr = std::shared_ptr<const InterserverCredentials>;
 class InterserverIOHandler;
@@ -545,12 +546,15 @@ class Context: public std::enable_shared_from_this<Context>
     const EmbeddedDictionaries & getEmbeddedDictionaries() const;
     const ExternalDictionariesLoader & getExternalDictionariesLoader() const;
     const ExternalModelsLoader & getExternalModelsLoader() const;
+    const ExternalUserDefinedExecutableFunctionsLoader & getExternalUserDefinedExecutableFunctionsLoader() const;
     EmbeddedDictionaries & getEmbeddedDictionaries();
     ExternalDictionariesLoader & getExternalDictionariesLoader();
+    ExternalUserDefinedExecutableFunctionsLoader & getExternalUserDefinedExecutableFunctionsLoader();
     ExternalModelsLoader & getExternalModelsLoader();
     ExternalModelsLoader & getExternalModelsLoaderUnlocked();
     void tryCreateEmbeddedDictionaries() const;
     void loadDictionaries(const Poco::Util::AbstractConfiguration & config);
+    void loadUserDefinedExecutableFunctions(const Poco::Util::AbstractConfiguration & config);
 
 #if USE_NLP
     SynonymsExtensions & getSynonymsExtensions() const;
diff --git a/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp
new file mode 100644
index 000000000000..0b1c30f2b142
--- /dev/null
+++ b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp
@@ -0,0 +1,123 @@
+#include "ExternalUserDefinedExecutableFunctionsLoader.h"
+
+#include <DataTypes/DataTypeFactory.h>
+
+#include <Interpreters/UserDefinedExecutableFunction.h>
+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>
+#include <Functions/FunctionFactory.h>
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+    extern const int FUNCTION_ALREADY_EXISTS;
+}
+
+ExternalUserDefinedExecutableFunctionsLoader::ExternalUserDefinedExecutableFunctionsLoader(ContextPtr global_context_)
+    : ExternalLoader("external user defined function", &Poco::Logger::get("ExternalUserDefinedExecutableFunctionsLoader"))
+    , WithContext(global_context_)
+{
+    setConfigSettings({"function", "name", "database", "uuid"});
+    enableAsyncLoading(false);
+    enablePeriodicUpdates(true);
+}
+
+ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr ExternalUserDefinedExecutableFunctionsLoader::getUserDefinedFunction(const std::string & user_defined_function_name) const
+{
+    return std::static_pointer_cast<const UserDefinedExecutableFunction>(load(user_defined_function_name));
+}
+
+ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr ExternalUserDefinedExecutableFunctionsLoader::tryGetUserDefinedFunction(const std::string & user_defined_function_name) const
+{
+    return std::static_pointer_cast<const UserDefinedExecutableFunction>(tryLoad(user_defined_function_name));
+}
+
+void ExternalUserDefinedExecutableFunctionsLoader::reloadFunction(const std::string & user_defined_function_name) const
+{
+    loadOrReload(user_defined_function_name);
+}
+
+ExternalLoader::LoadablePtr ExternalUserDefinedExecutableFunctionsLoader::create(const std::string & name,
+    const Poco::Util::AbstractConfiguration & config,
+    const std::string & key_in_config,
+    const std::string &) const
+{
+    if (FunctionFactory::instance().hasNameOrAlias(name))
+        throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, "The function '{}' already exists", name);
+
+    if (AggregateFunctionFactory::instance().hasNameOrAlias(name))
+        throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, "The aggregate function '{}' already exists", name);
+
+    String type = config.getString(key_in_config + ".type");
+    UserDefinedExecutableFunctionType function_type;
+
+    if (type == "executable")
+        function_type = UserDefinedExecutableFunctionType::executable;
+    else if (type == "executable_pool")
+        function_type = UserDefinedExecutableFunctionType::executable_pool;
+    else
+        throw Exception(ErrorCodes::BAD_ARGUMENTS,
+            "Wrong user defined function type expected 'executable' or 'executable_pool' actual {}",
+            function_type);
+
+    String command = config.getString(key_in_config + ".command");
+    String format = config.getString(key_in_config + ".format");
+    DataTypePtr result_type = DataTypeFactory::instance().get(config.getString(key_in_config + ".return_type"));
+    bool send_chunk_header = config.getBool(key_in_config + ".send_chunk_header", false);
+
+    size_t pool_size = 0;
+    size_t command_termination_timeout = 0;
+    size_t max_command_execution_time = 0;
+    if (function_type == UserDefinedExecutableFunctionType::executable_pool)
+    {
+        pool_size = config.getUInt64(key_in_config + ".pool_size", 16);
+        command_termination_timeout = config.getUInt64(key_in_config + ".command_termination_timeout", 10);
+        max_command_execution_time = config.getUInt64(key_in_config + ".max_command_execution_time", 10);
+
+        size_t max_execution_time_seconds = static_cast<size_t>(getContext()->getSettings().max_execution_time.totalSeconds());
+        if (max_execution_time_seconds != 0 && max_command_execution_time > max_execution_time_seconds)
+            max_command_execution_time = max_execution_time_seconds;
+    }
+
+    ExternalLoadableLifetime lifetime;
+
+    if (config.has(key_in_config + ".lifetime"))
+        lifetime = ExternalLoadableLifetime(config, key_in_config + ".lifetime");
+
+    std::vector<DataTypePtr> argument_types;
+
+    Poco::Util::AbstractConfiguration::Keys config_elems;
+    config.keys(key_in_config, config_elems);
+
+    for (const auto & config_elem : config_elems)
+    {
+        if (!startsWith(config_elem, "argument"))
+            continue;
+
+        const auto argument_prefix = key_in_config + '.' + config_elem + '.';
+        auto argument_type = DataTypeFactory::instance().get(config.getString(argument_prefix + "type"));
+        argument_types.emplace_back(std::move(argument_type));
+    }
+
+    UserDefinedExecutableFunctionConfiguration function_configuration
+    {
+        .type = function_type,
+        .name = std::move(name),
+        .script_path = std::move(command),
+        .format = std::move(format),
+        .argument_types = std::move(argument_types),
+        .result_type = std::move(result_type),
+        .pool_size = pool_size,
+        .command_termination_timeout = command_termination_timeout,
+        .max_command_execution_time = max_command_execution_time,
+        .send_chunk_header = send_chunk_header
+    };
+
+    return std::make_shared<UserDefinedExecutableFunction>(function_configuration, lifetime);
+}
+
+}
diff --git a/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h
new file mode 100644
index 000000000000..4d4843e86779
--- /dev/null
+++ b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include <memory>
+
+#include <Interpreters/Context_fwd.h>
+#include <Interpreters/ExternalLoader.h>
+#include <Interpreters/UserDefinedExecutableFunction.h>
+
+namespace DB
+{
+
+class IExternalLoaderConfigRepository;
+
+/// Manages external user-defined functions.
+class ExternalUserDefinedExecutableFunctionsLoader : public ExternalLoader, WithContext
+{
+public:
+
+    using UserDefinedExecutableFunctionPtr = std::shared_ptr<const UserDefinedExecutableFunction>;
+
+    /// External user-defined functions will be loaded immediately and then will be updated in separate thread, each 'reload_period' seconds.
+    explicit ExternalUserDefinedExecutableFunctionsLoader(ContextPtr global_context_);
+
+    UserDefinedExecutableFunctionPtr getUserDefinedFunction(const std::string & user_defined_function_name) const;
+
+    UserDefinedExecutableFunctionPtr tryGetUserDefinedFunction(const std::string & user_defined_function_name) const;
+
+    void reloadFunction(const std::string & user_defined_function_name) const;
+
+protected:
+    LoadablePtr create(const std::string & name,
+        const Poco::Util::AbstractConfiguration & config,
+        const std::string & key_in_config,
+        const std::string & repository_name) const override;
+
+};
+
+}
diff --git a/src/Interpreters/InterpreterCreateFunctionQuery.cpp b/src/Interpreters/InterpreterCreateFunctionQuery.cpp
index 01fc60060b3a..74d8c9cf9805 100644
--- a/src/Interpreters/InterpreterCreateFunctionQuery.cpp
+++ b/src/Interpreters/InterpreterCreateFunctionQuery.cpp
@@ -6,8 +6,8 @@
 #include <Interpreters/ExpressionAnalyzer.h>
 #include <Interpreters/InterpreterCreateFunctionQuery.h>
 #include <Interpreters/FunctionNameNormalizer.h>
-#include <Interpreters/UserDefinedObjectsLoader.h>
-#include <Interpreters/UserDefinedFunctionFactory.h>
+#include <Interpreters/UserDefinedSQLObjectsLoader.h>
+#include <Interpreters/UserDefinedSQLFunctionFactory.h>
 
 
 namespace DB
@@ -34,17 +34,17 @@ BlockIO InterpreterCreateFunctionQuery::execute()
     auto & function_name = create_function_query->function_name;
     validateFunction(create_function_query->function_core, function_name);
 
-    UserDefinedFunctionFactory::instance().registerFunction(function_name, query_ptr);
+    UserDefinedSQLFunctionFactory::instance().registerFunction(function_name, query_ptr);
 
     if (!is_internal)
     {
         try
         {
-            UserDefinedObjectsLoader::instance().storeObject(current_context, UserDefinedObjectType::Function, function_name, *query_ptr);
+            UserDefinedSQLObjectsLoader::instance().storeObject(current_context, UserDefinedSQLObjectType::Function, function_name, *query_ptr);
         }
         catch (Exception & exception)
         {
-            UserDefinedFunctionFactory::instance().unregisterFunction(function_name);
+            UserDefinedSQLFunctionFactory::instance().unregisterFunction(function_name);
             exception.addMessage(fmt::format("while storing user defined function {} on disk", backQuote(function_name)));
             throw;
         }
diff --git a/src/Interpreters/InterpreterDropFunctionQuery.cpp b/src/Interpreters/InterpreterDropFunctionQuery.cpp
index 9f945c11aac5..53cb96b42fe5 100644
--- a/src/Interpreters/InterpreterDropFunctionQuery.cpp
+++ b/src/Interpreters/InterpreterDropFunctionQuery.cpp
@@ -2,8 +2,8 @@
 #include <Interpreters/Context.h>
 #include <Interpreters/FunctionNameNormalizer.h>
 #include <Interpreters/InterpreterDropFunctionQuery.h>
-#include <Interpreters/UserDefinedObjectsLoader.h>
-#include <Interpreters/UserDefinedFunctionFactory.h>
+#include <Interpreters/UserDefinedSQLObjectsLoader.h>
+#include <Interpreters/UserDefinedSQLFunctionFactory.h>
 #include <Parsers/ASTDropFunctionQuery.h>
 
 
@@ -18,8 +18,8 @@ BlockIO InterpreterDropFunctionQuery::execute()
     FunctionNameNormalizer().visit(query_ptr.get());
     auto & drop_function_query = query_ptr->as<ASTDropFunctionQuery &>();
 
-    UserDefinedFunctionFactory::instance().unregisterFunction(drop_function_query.function_name);
-    UserDefinedObjectsLoader::instance().removeObject(current_context, UserDefinedObjectType::Function, drop_function_query.function_name);
+    UserDefinedSQLFunctionFactory::instance().unregisterFunction(drop_function_query.function_name);
+    UserDefinedSQLObjectsLoader::instance().removeObject(current_context, UserDefinedSQLObjectType::Function, drop_function_query.function_name);
 
     return {};
 }
diff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp
index 8d25e464271e..226ff124cfbb 100644
--- a/src/Interpreters/InterpreterSystemQuery.cpp
+++ b/src/Interpreters/InterpreterSystemQuery.cpp
@@ -11,6 +11,7 @@
 #include <Interpreters/DatabaseCatalog.h>
 #include <Interpreters/ExternalDictionariesLoader.h>
 #include <Interpreters/ExternalModelsLoader.h>
+#include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>
 #include <Interpreters/EmbeddedDictionaries.h>
 #include <Interpreters/ActionLocksManager.h>
 #include <Interpreters/InterpreterDropQuery.h>
@@ -296,7 +297,6 @@ BlockIO InterpreterSystemQuery::execute()
             auto & external_dictionaries_loader = system_context->getExternalDictionariesLoader();
             external_dictionaries_loader.reloadDictionary(query.table, getContext());
 
-
             ExternalDictionariesLoader::resetAll();
             break;
         }
@@ -326,6 +326,22 @@ BlockIO InterpreterSystemQuery::execute()
             external_models_loader.reloadAllTriedToLoad();
             break;
         }
+        case Type::RELOAD_FUNCTION:
+        {
+            getContext()->checkAccess(AccessType::SYSTEM_RELOAD_FUNCTION);
+
+            auto & external_user_defined_executable_functions_loader = system_context->getExternalUserDefinedExecutableFunctionsLoader();
+            external_user_defined_executable_functions_loader.reloadFunction(query.target_function);
+            break;
+        }
+        case Type::RELOAD_FUNCTIONS:
+        {
+            getContext()->checkAccess(AccessType::SYSTEM_RELOAD_FUNCTION);
+
+            auto & external_user_defined_executable_functions_loader = system_context->getExternalUserDefinedExecutableFunctionsLoader();
+            external_user_defined_executable_functions_loader.reloadAllTriedToLoad();
+            break;
+        }
         case Type::RELOAD_EMBEDDED_DICTIONARIES:
             getContext()->checkAccess(AccessType::SYSTEM_RELOAD_EMBEDDED_DICTIONARIES);
             system_context->getEmbeddedDictionaries().reload();
@@ -740,6 +756,12 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()
             required_access.emplace_back(AccessType::SYSTEM_RELOAD_MODEL);
             break;
         }
+        case Type::RELOAD_FUNCTION: [[fallthrough]];
+        case Type::RELOAD_FUNCTIONS:
+        {
+            required_access.emplace_back(AccessType::SYSTEM_RELOAD_FUNCTION);
+            break;
+        }
         case Type::RELOAD_CONFIG:
         {
             required_access.emplace_back(AccessType::SYSTEM_RELOAD_CONFIG);
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index 11402e052dca..f92baf5536e3 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -14,7 +14,7 @@
 #include <Interpreters/CollectJoinOnKeysVisitor.h>
 #include <Interpreters/RequiredSourceColumnsVisitor.h>
 #include <Interpreters/GetAggregatesVisitor.h>
-#include <Interpreters/UserDefinedFunctionsVisitor.h>
+#include <Interpreters/UserDefinedSQLFunctionVisitor.h>
 #include <Interpreters/TableJoin.h>
 #include <Interpreters/ExpressionActions.h> /// getSmallestColumn()
 #include <Interpreters/getTableExpressions.h>
@@ -1041,8 +1041,8 @@ TreeRewriterResultPtr TreeRewriter::analyze(
 void TreeRewriter::normalize(
     ASTPtr & query, Aliases & aliases, const NameSet & source_columns_set, bool ignore_alias, const Settings & settings, bool allow_self_aliases)
 {
-    UserDefinedFunctionsVisitor::Data data_user_defined_functions_visitor;
-    UserDefinedFunctionsVisitor(data_user_defined_functions_visitor).visit(query);
+    UserDefinedSQLFunctionVisitor::Data data_user_defined_functions_visitor;
+    UserDefinedSQLFunctionVisitor(data_user_defined_functions_visitor).visit(query);
 
     CustomizeCountDistinctVisitor::Data data_count_distinct{settings.count_distinct_implementation};
     CustomizeCountDistinctVisitor(data_count_distinct).visit(query);
diff --git a/src/Interpreters/UserDefinedExecutableFunction.cpp b/src/Interpreters/UserDefinedExecutableFunction.cpp
new file mode 100644
index 000000000000..06830df68e6c
--- /dev/null
+++ b/src/Interpreters/UserDefinedExecutableFunction.cpp
@@ -0,0 +1,26 @@
+#include "UserDefinedExecutableFunction.h"
+
+#include <Functions/IFunction.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+
+#include <DataStreams/ShellCommandSource.h>
+#include <DataStreams/formatBlock.h>
+
+
+namespace DB
+{
+
+UserDefinedExecutableFunction::UserDefinedExecutableFunction(
+    const UserDefinedExecutableFunctionConfiguration & configuration_,
+    const ExternalLoadableLifetime & lifetime_,
+    std::shared_ptr<ProcessPool> process_pool_)
+    : configuration(configuration_)
+    , lifetime(lifetime_)
+    , process_pool(process_pool_)
+{
+    if (!process_pool && configuration.type == UserDefinedExecutableFunctionType::executable_pool)
+        process_pool = std::make_shared<ProcessPool>(configuration.pool_size == 0 ? std::numeric_limits<int>::max() : configuration.pool_size);
+}
+
+};
diff --git a/src/Interpreters/UserDefinedExecutableFunction.h b/src/Interpreters/UserDefinedExecutableFunction.h
new file mode 100644
index 000000000000..dc5b92ea7451
--- /dev/null
+++ b/src/Interpreters/UserDefinedExecutableFunction.h
@@ -0,0 +1,100 @@
+#pragma once
+
+#include <string>
+
+#include <DataTypes/IDataType.h>
+#include <DataStreams/ShellCommandSource.h>
+#include <Interpreters/IExternalLoadable.h>
+
+
+namespace DB
+{
+
+enum class UserDefinedExecutableFunctionType
+{
+    executable,
+    executable_pool
+};
+
+struct UserDefinedExecutableFunctionConfiguration
+{
+    UserDefinedExecutableFunctionType type = UserDefinedExecutableFunctionType::executable;
+    std::string name;
+    std::string script_path;
+    std::string format;
+    std::vector<DataTypePtr> argument_types;
+    DataTypePtr result_type;
+    /// Pool settings
+    size_t pool_size = 0;
+    size_t command_termination_timeout = 0;
+    size_t max_command_execution_time = 0;
+    /// Send number_of_rows
 before sending chunk to process
+    bool send_chunk_header = false;
+};
+
+class UserDefinedExecutableFunction final : public IExternalLoadable
+{
+public:
+
+    UserDefinedExecutableFunction(
+        const UserDefinedExecutableFunctionConfiguration & configuration_,
+        const ExternalLoadableLifetime & lifetime_,
+        std::shared_ptr<ProcessPool> process_pool_ = nullptr);
+
+    const ExternalLoadableLifetime & getLifetime() const override
+    {
+        return lifetime;
+    }
+
+    const std::string & getLoadableName() const override
+    {
+        return configuration.name;
+    }
+
+    bool supportUpdates() const override
+    {
+        return true;
+    }
+
+    bool isModified() const override
+    {
+        return true;
+    }
+
+    std::shared_ptr<const IExternalLoadable> clone() const override
+    {
+        std::cerr << "UserDefinedExecutableFunction::clone " << this << std::endl;
+        return std::make_shared<UserDefinedExecutableFunction>(configuration, lifetime, process_pool);
+    }
+
+    const UserDefinedExecutableFunctionConfiguration & getConfiguration() const
+    {
+        return configuration;
+    }
+
+    std::shared_ptr<ProcessPool> getProcessPool() const
+    {
+        return process_pool;
+    }
+
+    std::shared_ptr<UserDefinedExecutableFunction> shared_from_this()
+    {
+        return std::static_pointer_cast<UserDefinedExecutableFunction>(IExternalLoadable::shared_from_this());
+    }
+
+    std::shared_ptr<const UserDefinedExecutableFunction> shared_from_this() const
+    {
+        return std::static_pointer_cast<const UserDefinedExecutableFunction>(IExternalLoadable::shared_from_this());
+    }
+
+private:
+    UserDefinedExecutableFunction(const UserDefinedExecutableFunctionConfiguration & configuration_,
+        std::shared_ptr<ProcessPool> process_pool_,
+        const ExternalLoadableLifetime & lifetime_);
+
+    UserDefinedExecutableFunctionConfiguration configuration;
+    ExternalLoadableLifetime lifetime;
+    std::shared_ptr<ProcessPool> process_pool;
+};
+
+}
diff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp
new file mode 100644
index 000000000000..b6fb4d8d5e57
--- /dev/null
+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp
@@ -0,0 +1,218 @@
+#include "UserDefinedExecutableFunctionFactory.h"
+
+#include <IO/WriteHelpers.h>
+
+#include <DataStreams/ShellCommandSource.h>
+#include <DataStreams/formatBlock.h>
+
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+#include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>
+#include <Interpreters/Context.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int UNSUPPORTED_METHOD;
+    extern const int TIMEOUT_EXCEEDED;
+}
+
+class UserDefinedFunction final : public IFunction
+{
+public:
+
+    explicit UserDefinedFunction(
+        ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr executable_function_,
+        ContextPtr context_)
+        : executable_function(std::move(executable_function_))
+        , context(context_)
+    {
+    }
+
+    String getName() const override { return executable_function->getConfiguration().name; }
+
+    bool isVariadic() const override { return false; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+    size_t getNumberOfArguments() const override { return executable_function->getConfiguration().argument_types.size(); }
+
+    bool useDefaultImplementationForConstants() const override { return true; }
+    bool useDefaultImplementationForNulls() const override { return true; }
+    bool isDeterministic() const override { return false; }
+
+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    {
+        const auto & configuration = executable_function->getConfiguration();
+
+        for (size_t i = 0; i < arguments.size(); ++i)
+        {
+            const auto & expected_argument_type = configuration.argument_types[i];
+            if (!areTypesEqual(expected_argument_type, arguments[i]))
+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+                    "Function {} for {} argument expected {} actual {}",
+                    getName(),
+                    i,
+                    expected_argument_type->getName(),
+                    arguments[i]->getName());
+        }
+
+        return configuration.result_type;
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+    {
+        std::unique_ptr<ShellCommand> process = getProcess();
+
+        ColumnWithTypeAndName result(result_type, "result");
+        Block result_block({result});
+
+        Block arguments_block(arguments);
+        auto * process_in = &process->in;
+
+        const auto & configuration = executable_function->getConfiguration();
+        auto process_pool = executable_function->getProcessPool();
+        bool is_executable_pool_function = (process_pool != nullptr);
+
+        ShellCommandSourceConfiguration shell_command_source_configuration;
+
+        if (is_executable_pool_function)
+        {
+            shell_command_source_configuration.read_fixed_number_of_rows = true;
+            shell_command_source_configuration.number_of_rows_to_read = input_rows_count;
+        }
+
+        ShellCommandSource::SendDataTask task = {[process_in, arguments_block, &configuration, is_executable_pool_function, this]()
+        {
+            auto & out = *process_in;
+
+            if (configuration.send_chunk_header)
+            {
+                writeText(arguments_block.rows(), out);
+                writeChar('
', out);
+            }
+
+            auto output_stream = context->getOutputStream(configuration.format, out, arguments_block.cloneEmpty());
+            formatBlock(output_stream, arguments_block);
+            if (!is_executable_pool_function)
+                out.close();
+        }};
+        std::vector<ShellCommandSource::SendDataTask> tasks = {std::move(task)};
+
+        Pipe pipe(std::make_unique<ShellCommandSource>(
+            context,
+            configuration.format,
+            result_block.cloneEmpty(),
+            std::move(process),
+            std::move(tasks),
+            shell_command_source_configuration,
+            process_pool));
+
+        QueryPipeline pipeline;
+        pipeline.init(std::move(pipe));
+
+        PullingPipelineExecutor executor(pipeline);
+
+        auto result_column = result_type->createColumn();
+        result_column->reserve(input_rows_count);
+
+        Block block;
+        while (executor.pull(block))
+        {
+            const auto & result_column_to_add = *block.safeGetByPosition(0).column;
+            result_column->insertRangeFrom(result_column_to_add, 0, result_column_to_add.size());
+        }
+
+        size_t result_column_size = result_column->size();
+        if (result_column_size != input_rows_count)
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+                "Function {} wrong result rows count expected {} actual {}",
+                getName(),
+                input_rows_count,
+                result_column_size);
+
+        return result_column;
+    }
+
+private:
+
+    std::unique_ptr<ShellCommand> getProcess() const
+    {
+        auto process_pool = executable_function->getProcessPool();
+        auto executable_function_configuration = executable_function->getConfiguration();
+
+        std::unique_ptr<ShellCommand> process;
+        bool is_executable_pool_function = (process_pool != nullptr);
+        if (is_executable_pool_function)
+        {
+            bool result = process_pool->tryBorrowObject(process, [&]()
+            {
+                ShellCommand::Config process_config(executable_function_configuration.script_path);
+                process_config.terminate_in_destructor_strategy = ShellCommand::DestructorStrategy{ true /*terminate_in_destructor*/, executable_function_configuration.command_termination_timeout };
+                auto shell_command = ShellCommand::execute(process_config);
+                return shell_command;
+            }, executable_function_configuration.max_command_execution_time * 1000);
+
+            if (!result)
+                throw Exception(ErrorCodes::TIMEOUT_EXCEEDED,
+                    "Could not get process from pool, max command execution timeout exceeded {} seconds",
+                    executable_function_configuration.max_command_execution_time);
+        }
+        else
+        {
+            process = ShellCommand::execute(executable_function_configuration.script_path);
+        }
+
+        return process;
+    }
+
+    ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr executable_function;
+    ContextPtr context;
+};
+
+UserDefinedExecutableFunctionFactory & UserDefinedExecutableFunctionFactory::instance()
+{
+    static UserDefinedExecutableFunctionFactory result;
+    return result;
+}
+
+FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::get(const String & function_name, ContextPtr context)
+{
+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();
+    auto executable_function = std::static_pointer_cast<const UserDefinedExecutableFunction>(loader.load(function_name));
+    auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context));
+    return std::make_unique<FunctionToOverloadResolverAdaptor>(std::move(function));
+}
+
+FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::tryGet(const String & function_name, ContextPtr context)
+{
+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();
+    auto load_result = loader.getLoadResult(function_name);
+
+    if (load_result.object)
+    {
+        auto executable_function = std::static_pointer_cast<const UserDefinedExecutableFunction>(load_result.object);
+        auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context));
+        return std::make_unique<FunctionToOverloadResolverAdaptor>(std::move(function));
+    }
+
+    return nullptr;
+}
+
+std::vector<String> UserDefinedExecutableFunctionFactory::getRegisteredNames(ContextPtr context)
+{
+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();
+    auto loaded_objects = loader.getLoadedObjects();
+
+    std::vector<std::string> registered_names;
+    registered_names.reserve(loaded_objects.size());
+
+    for (auto & loaded_object : loaded_objects)
+        registered_names.emplace_back(loaded_object->getLoadableName());
+
+    return registered_names;
+}
+
+}
diff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.h b/src/Interpreters/UserDefinedExecutableFunctionFactory.h
new file mode 100644
index 000000000000..0afeeecbca7f
--- /dev/null
+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include <functional>
+#include <memory>
+#include <string>
+#include <unordered_map>
+
+#include <Common/NamePrompter.h>
+#include <Interpreters/Context_fwd.h>
+#include <Functions/IFunction.h>
+
+
+namespace DB
+{
+
+class UserDefinedExecutableFunctionFactory
+{
+public:
+    using Creator = std::function<FunctionOverloadResolverPtr(ContextPtr)>;
+
+    static UserDefinedExecutableFunctionFactory & instance();
+
+    static FunctionOverloadResolverPtr get(const String & function_name, ContextPtr context);
+
+    static FunctionOverloadResolverPtr tryGet(const String & function_name, ContextPtr context);
+
+    static std::vector<String> getRegisteredNames(ContextPtr context);
+
+};
+
+}
diff --git a/src/Interpreters/UserDefinedFunctionFactory.h b/src/Interpreters/UserDefinedFunctionFactory.h
deleted file mode 100644
index 0d7167eb1b78..000000000000
--- a/src/Interpreters/UserDefinedFunctionFactory.h
+++ /dev/null
@@ -1,39 +0,0 @@
-#pragma once
-
-#include <unordered_map>
-#include <mutex>
-
-#include <Common/NamePrompter.h>
-
-#include <Parsers/ASTCreateFunctionQuery.h>
-
-namespace DB
-{
-
-///Factory for user defined functions stores functions.
-class UserDefinedFunctionFactory : public IHints<1, UserDefinedFunctionFactory>
-{
-public:
-    static UserDefinedFunctionFactory & instance();
-
-    /// Register function with function_name. create_function_query pointer must be ASTCreateFunctionQuery.
-    void registerFunction(const String & function_name, ASTPtr create_function_query);
-
-    /// Unregister function with function_name.
-    void unregisterFunction(const String & function_name);
-
-    /// Throws an exception if not found. Result ast pointer safely can be casted to ASTCreateFunctionQuery.
-    ASTPtr get(const String & function_name) const;
-
-    /// Returns nullptr if not found. Result ast pointer safely can be casted to ASTCreateFunctionQuery.
-    ASTPtr tryGet(const String & function_name) const;
-
-    /// Get all registered function names.
-    std::vector<String> getAllRegisteredNames() const override;
-
-private:
-    std::unordered_map<String, ASTPtr> function_name_to_create_query;
-    mutable std::mutex mutex;
-};
-
-}
diff --git a/src/Interpreters/UserDefinedObjectsLoader.h b/src/Interpreters/UserDefinedObjectsLoader.h
deleted file mode 100644
index f0054fac450b..000000000000
--- a/src/Interpreters/UserDefinedObjectsLoader.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#pragma once
-
-#include <Interpreters/Context_fwd.h>
-#include <Parsers/IAST.h>
-
-#include <boost/noncopyable.hpp>
-
-
-namespace DB
-{
-
-enum class UserDefinedObjectType
-{
-    Function
-};
-
-class UserDefinedObjectsLoader : private boost::noncopyable
-{
-public:
-    static UserDefinedObjectsLoader & instance();
-    UserDefinedObjectsLoader();
-
-    void loadObjects(ContextPtr context);
-    void storeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name, const IAST & ast);
-    void removeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name);
-
-private:
-
-    void loadUserDefinedObject(ContextPtr context, UserDefinedObjectType object_type, const std::string_view & object_name, const String & file_path);
-    Poco::Logger * log;
-};
-
-}
diff --git a/src/Interpreters/UserDefinedFunctionFactory.cpp b/src/Interpreters/UserDefinedSQLFunctionFactory.cpp
similarity index 79%
rename from src/Interpreters/UserDefinedFunctionFactory.cpp
rename to src/Interpreters/UserDefinedSQLFunctionFactory.cpp
index 0970b09f8638..434f5523b428 100644
--- a/src/Interpreters/UserDefinedFunctionFactory.cpp
+++ b/src/Interpreters/UserDefinedSQLFunctionFactory.cpp
@@ -1,4 +1,4 @@
-#include "UserDefinedFunctionFactory.h"
+#include "UserDefinedSQLFunctionFactory.h"
 
 #include <Functions/FunctionFactory.h>
 #include <AggregateFunctions/AggregateFunctionFactory.h>
@@ -13,13 +13,13 @@ namespace ErrorCodes
     extern const int CANNOT_DROP_SYSTEM_FUNCTION;
 }
 
-UserDefinedFunctionFactory & UserDefinedFunctionFactory::instance()
+UserDefinedSQLFunctionFactory & UserDefinedSQLFunctionFactory::instance()
 {
-    static UserDefinedFunctionFactory result;
+    static UserDefinedSQLFunctionFactory result;
     return result;
 }
 
-void UserDefinedFunctionFactory::registerFunction(const String & function_name, ASTPtr create_function_query)
+void UserDefinedSQLFunctionFactory::registerFunction(const String & function_name, ASTPtr create_function_query)
 {
     if (FunctionFactory::instance().hasNameOrAlias(function_name))
         throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, "The function '{}' already exists", function_name);
@@ -36,7 +36,7 @@ void UserDefinedFunctionFactory::registerFunction(const String & function_name,
             function_name);
 }
 
-void UserDefinedFunctionFactory::unregisterFunction(const String & function_name)
+void UserDefinedSQLFunctionFactory::unregisterFunction(const String & function_name)
 {
     if (FunctionFactory::instance().hasNameOrAlias(function_name) ||
         AggregateFunctionFactory::instance().hasNameOrAlias(function_name))
@@ -53,7 +53,7 @@ void UserDefinedFunctionFactory::unregisterFunction(const String & function_name
     function_name_to_create_query.erase(it);
 }
 
-ASTPtr UserDefinedFunctionFactory::get(const String & function_name) const
+ASTPtr UserDefinedSQLFunctionFactory::get(const String & function_name) const
 {
     std::lock_guard lock(mutex);
 
@@ -66,7 +66,7 @@ ASTPtr UserDefinedFunctionFactory::get(const String & function_name) const
     return it->second;
 }
 
-ASTPtr UserDefinedFunctionFactory::tryGet(const std::string & function_name) const
+ASTPtr UserDefinedSQLFunctionFactory::tryGet(const std::string & function_name) const
 {
     std::lock_guard lock(mutex);
 
@@ -77,7 +77,7 @@ ASTPtr UserDefinedFunctionFactory::tryGet(const std::string & function_name) con
     return it->second;
 }
 
-std::vector<std::string> UserDefinedFunctionFactory::getAllRegisteredNames() const
+std::vector<std::string> UserDefinedSQLFunctionFactory::getAllRegisteredNames() const
 {
     std::vector<std::string> registered_names;
 
diff --git a/src/Interpreters/UserDefinedSQLFunctionFactory.h b/src/Interpreters/UserDefinedSQLFunctionFactory.h
new file mode 100644
index 000000000000..366e27e833da
--- /dev/null
+++ b/src/Interpreters/UserDefinedSQLFunctionFactory.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include <unordered_map>
+#include <mutex>
+
+#include <Common/NamePrompter.h>
+
+#include <Parsers/ASTCreateFunctionQuery.h>
+
+namespace DB
+{
+
+class UserDefinedSQLFunctionFactory : public IHints<1, UserDefinedSQLFunctionFactory>
+{
+public:
+    static UserDefinedSQLFunctionFactory & instance();
+
+    void registerFunction(const String & function_name, ASTPtr create_function_query);
+
+    void unregisterFunction(const String & function_name);
+
+    ASTPtr get(const String & function_name) const;
+
+    ASTPtr tryGet(const String & function_name) const;
+
+    std::vector<String> getAllRegisteredNames() const override;
+
+private:
+    std::unordered_map<String, ASTPtr> function_name_to_create_query;
+    mutable std::mutex mutex;
+};
+
+}
diff --git a/src/Interpreters/UserDefinedFunctionsVisitor.cpp b/src/Interpreters/UserDefinedSQLFunctionVisitor.cpp
similarity index 86%
rename from src/Interpreters/UserDefinedFunctionsVisitor.cpp
rename to src/Interpreters/UserDefinedSQLFunctionVisitor.cpp
index 2a793d178176..6471f9cbf628 100644
--- a/src/Interpreters/UserDefinedFunctionsVisitor.cpp
+++ b/src/Interpreters/UserDefinedSQLFunctionVisitor.cpp
@@ -1,4 +1,4 @@
-#include "UserDefinedFunctionsVisitor.h"
+#include "UserDefinedSQLFunctionVisitor.h"
 
 #include <unordered_map>
 #include <stack>
@@ -7,7 +7,7 @@
 #include <Parsers/ASTCreateFunctionQuery.h>
 #include <Parsers/ASTExpressionList.h>
 #include <Parsers/ASTIdentifier.h>
-#include <Interpreters/UserDefinedFunctionFactory.h>
+#include <Interpreters/UserDefinedSQLFunctionFactory.h>
 
 
 namespace DB
@@ -18,7 +18,7 @@ namespace ErrorCodes
     extern const int UNSUPPORTED_METHOD;
 }
 
-void UserDefinedFunctionsMatcher::visit(ASTPtr & ast, Data &)
+void UserDefinedSQLFunctionMatcher::visit(ASTPtr & ast, Data &)
 {
     auto * function = ast->as<ASTFunction>();
     if (!function)
@@ -29,14 +29,14 @@ void UserDefinedFunctionsMatcher::visit(ASTPtr & ast, Data &)
         ast = result;
 }
 
-bool UserDefinedFunctionsMatcher::needChildVisit(const ASTPtr &, const ASTPtr &)
+bool UserDefinedSQLFunctionMatcher::needChildVisit(const ASTPtr &, const ASTPtr &)
 {
     return true;
 }
 
-ASTPtr UserDefinedFunctionsMatcher::tryToReplaceFunction(const ASTFunction & function)
+ASTPtr UserDefinedSQLFunctionMatcher::tryToReplaceFunction(const ASTFunction & function)
 {
-    auto user_defined_function = UserDefinedFunctionFactory::instance().tryGet(function.name);
+    auto user_defined_function = UserDefinedSQLFunctionFactory::instance().tryGet(function.name);
     if (!user_defined_function)
         return nullptr;
 
diff --git a/src/Interpreters/UserDefinedFunctionsVisitor.h b/src/Interpreters/UserDefinedSQLFunctionVisitor.h
similarity index 82%
rename from src/Interpreters/UserDefinedFunctionsVisitor.h
rename to src/Interpreters/UserDefinedSQLFunctionVisitor.h
index c24e0327ddc7..46f95f29ab90 100644
--- a/src/Interpreters/UserDefinedFunctionsVisitor.h
+++ b/src/Interpreters/UserDefinedSQLFunctionVisitor.h
@@ -19,10 +19,10 @@ class ASTFunction;
   * After applying visitor:
   * SELECT number + 1 FROM system.numbers LIMIT 10;
   */
-class UserDefinedFunctionsMatcher
+class UserDefinedSQLFunctionMatcher
 {
 public:
-    using Visitor = InDepthNodeVisitor<UserDefinedFunctionsMatcher, true>;
+    using Visitor = InDepthNodeVisitor<UserDefinedSQLFunctionMatcher, true>;
 
     struct Data
     {
@@ -39,6 +39,6 @@ class UserDefinedFunctionsMatcher
 };
 
 /// Visits AST nodes and collect their aliases in one map (with links to source nodes).
-using UserDefinedFunctionsVisitor = UserDefinedFunctionsMatcher::Visitor;
+using UserDefinedSQLFunctionVisitor = UserDefinedSQLFunctionMatcher::Visitor;
 
 }
diff --git a/src/Interpreters/UserDefinedObjectsLoader.cpp b/src/Interpreters/UserDefinedSQLObjectsLoader.cpp
similarity index 79%
rename from src/Interpreters/UserDefinedObjectsLoader.cpp
rename to src/Interpreters/UserDefinedSQLObjectsLoader.cpp
index 5237de594f48..5b2a5605de7a 100644
--- a/src/Interpreters/UserDefinedObjectsLoader.cpp
+++ b/src/Interpreters/UserDefinedSQLObjectsLoader.cpp
@@ -1,4 +1,4 @@
-#include "UserDefinedObjectsLoader.h"
+#include "UserDefinedSQLObjectsLoader.h"
 
 #include <filesystem>
 
@@ -32,17 +32,17 @@ namespace ErrorCodes
     extern const int OBJECT_WAS_NOT_STORED_ON_DISK;
 }
 
-UserDefinedObjectsLoader & UserDefinedObjectsLoader::instance()
+UserDefinedSQLObjectsLoader & UserDefinedSQLObjectsLoader::instance()
 {
-    static UserDefinedObjectsLoader ret;
+    static UserDefinedSQLObjectsLoader ret;
     return ret;
 }
 
-UserDefinedObjectsLoader::UserDefinedObjectsLoader()
-    : log(&Poco::Logger::get("UserDefinedObjectsLoader"))
+UserDefinedSQLObjectsLoader::UserDefinedSQLObjectsLoader()
+    : log(&Poco::Logger::get("UserDefinedSQLObjectsLoader"))
 {}
 
-void UserDefinedObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDefinedObjectType object_type, const std::string_view & name, const String & path)
+void UserDefinedSQLObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDefinedSQLObjectType object_type, const std::string_view & name, const String & path)
 {
     auto name_ref = StringRef(name.data(), name.size());
     LOG_DEBUG(log, "Loading user defined object {} from file {}", backQuote(name_ref), path);
@@ -57,7 +57,7 @@ void UserDefinedObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDef
     {
         switch (object_type)
         {
-            case UserDefinedObjectType::Function:
+            case UserDefinedSQLObjectType::Function:
             {
                 ParserCreateFunctionQuery parser;
                 ASTPtr ast = parseQuery(
@@ -80,7 +80,7 @@ void UserDefinedObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDef
     }
 }
 
-void UserDefinedObjectsLoader::loadObjects(ContextPtr context)
+void UserDefinedSQLObjectsLoader::loadObjects(ContextPtr context)
 {
     LOG_DEBUG(log, "loading user defined objects");
 
@@ -102,19 +102,19 @@ void UserDefinedObjectsLoader::loadObjects(ContextPtr context)
             std::string_view object_name = file_name;
             object_name.remove_suffix(strlen(".sql"));
             object_name.remove_prefix(strlen("function_"));
-            loadUserDefinedObject(context, UserDefinedObjectType::Function, object_name, dir_path + it.name());
+            loadUserDefinedObject(context, UserDefinedSQLObjectType::Function, object_name, dir_path + it.name());
         }
     }
 }
 
-void UserDefinedObjectsLoader::storeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name, const IAST & ast)
+void UserDefinedSQLObjectsLoader::storeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name, const IAST & ast)
 {
     String dir_path = context->getPath() + "user_defined/";
     String file_path;
 
     switch (object_type)
     {
-        case UserDefinedObjectType::Function:
+        case UserDefinedSQLObjectType::Function:
         {
             file_path = dir_path + "function_" + escapeForFileName(object_name) + ".sql";
         }
@@ -140,7 +140,7 @@ void UserDefinedObjectsLoader::storeObject(ContextPtr context, UserDefinedObject
     LOG_DEBUG(log, "Stored object {}", backQuote(object_name));
 }
 
-void UserDefinedObjectsLoader::removeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name)
+void UserDefinedSQLObjectsLoader::removeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name)
 {
     String dir_path = context->getPath() + "user_defined/";
     LOG_DEBUG(log, "Removing file for user defined object {} from {}", backQuote(object_name), dir_path);
@@ -149,7 +149,7 @@ void UserDefinedObjectsLoader::removeObject(ContextPtr context, UserDefinedObjec
 
     switch (object_type)
     {
-        case UserDefinedObjectType::Function:
+        case UserDefinedSQLObjectType::Function:
         {
             file_path = dir_path + "function_" + escapeForFileName(object_name) + ".sql";
         }
diff --git a/src/Interpreters/UserDefinedSQLObjectsLoader.h b/src/Interpreters/UserDefinedSQLObjectsLoader.h
new file mode 100644
index 000000000000..6daf3e99833e
--- /dev/null
+++ b/src/Interpreters/UserDefinedSQLObjectsLoader.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include <Interpreters/Context_fwd.h>
+#include <Parsers/IAST.h>
+
+#include <boost/noncopyable.hpp>
+
+
+namespace DB
+{
+
+enum class UserDefinedSQLObjectType
+{
+    Function
+};
+
+class UserDefinedSQLObjectsLoader : private boost::noncopyable
+{
+public:
+    static UserDefinedSQLObjectsLoader & instance();
+    UserDefinedSQLObjectsLoader();
+
+    void loadObjects(ContextPtr context);
+    void storeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name, const IAST & ast);
+    void removeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name);
+
+private:
+
+    void loadUserDefinedObject(ContextPtr context, UserDefinedSQLObjectType object_type, const std::string_view & object_name, const String & file_path);
+    Poco::Logger * log;
+};
+
+}
diff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make
index ed9e28b5a11b..e8b33d09914c 100644
--- a/src/Interpreters/ya.make
+++ b/src/Interpreters/ya.make
@@ -60,6 +60,7 @@ SRCS(
     ExternalLoaderTempConfigRepository.cpp
     ExternalLoaderXMLConfigRepository.cpp
     ExternalModelsLoader.cpp
+    ExternalUserDefinedExecutableFunctionsLoader.cpp
     ExtractExpressionInfoVisitor.cpp
     FillingRow.cpp
     FunctionNameNormalizer.cpp
@@ -165,9 +166,11 @@ SRCS(
     TranslateQualifiedNamesVisitor.cpp
     TreeOptimizer.cpp
     TreeRewriter.cpp
-    UserDefinedFunctionFactory.cpp
-    UserDefinedFunctionsVisitor.cpp
-    UserDefinedObjectsLoader.cpp
+    UserDefinedExecutableFunction.cpp
+    UserDefinedExecutableFunctionFactory.cpp
+    UserDefinedSQLFunctionFactory.cpp
+    UserDefinedSQLFunctionVisitor.cpp
+    UserDefinedSQLObjectsLoader.cpp
     WindowDescription.cpp
     ZooKeeperLog.cpp
     addMissingDefaults.cpp
diff --git a/src/Parsers/ASTSystemQuery.h b/src/Parsers/ASTSystemQuery.h
index a14537957d10..f55ccc591605 100644
--- a/src/Parsers/ASTSystemQuery.h
+++ b/src/Parsers/ASTSystemQuery.h
@@ -39,6 +39,8 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster
         RELOAD_DICTIONARIES,
         RELOAD_MODEL,
         RELOAD_MODELS,
+        RELOAD_FUNCTION,
+        RELOAD_FUNCTIONS,
         RELOAD_EMBEDDED_DICTIONARIES,
         RELOAD_CONFIG,
         RELOAD_SYMBOLS,
@@ -65,6 +67,7 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster
     Type type = Type::UNKNOWN;
 
     String target_model;
+    String target_function;
     String database;
     String table;
     String replica;
diff --git a/src/Parsers/ParserSystemQuery.cpp b/src/Parsers/ParserSystemQuery.cpp
index 147436d0d834..5381566263e9 100644
--- a/src/Parsers/ParserSystemQuery.cpp
+++ b/src/Parsers/ParserSystemQuery.cpp
@@ -125,6 +125,35 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &
 
             break;
         }
+        case Type::RELOAD_FUNCTION:
+        {
+            String cluster_str;
+            if (ParserKeyword{"ON"}.ignore(pos, expected))
+            {
+                if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))
+                    return false;
+            }
+            res->cluster = cluster_str;
+            ASTPtr ast;
+            if (ParserStringLiteral{}.parse(pos, ast, expected))
+            {
+                res->target_function = ast->as<ASTLiteral &>().value.safeGet<String>();
+            }
+            else
+            {
+                ParserIdentifier function_parser;
+                ASTPtr function;
+                String target_function;
+
+                if (!function_parser.parse(pos, function, expected))
+                    return false;
+
+                if (!tryGetIdentifierNameInto(function, res->target_function))
+                    return false;
+            }
+
+            break;
+        }
         case Type::DROP_REPLICA:
         {
             ASTPtr ast;
diff --git a/src/Storages/System/StorageSystemFunctions.cpp b/src/Storages/System/StorageSystemFunctions.cpp
index f19cffee37cc..b3f1231bd1a7 100644
--- a/src/Storages/System/StorageSystemFunctions.cpp
+++ b/src/Storages/System/StorageSystemFunctions.cpp
@@ -1,24 +1,34 @@
 #include <AggregateFunctions/AggregateFunctionFactory.h>
 #include <DataTypes/DataTypeString.h>
 #include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/DataTypeEnum.h>
 #include <Parsers/queryToString.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/IFunction.h>
 #include <Interpreters/Context.h>
-#include <Interpreters/UserDefinedFunctionFactory.h>
+#include <Interpreters/UserDefinedSQLFunctionFactory.h>
+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>
 #include <Storages/System/StorageSystemFunctions.h>
 
 namespace DB
 {
+
+enum class FunctionOrigin : Int8
+{
+    SYSTEM = 0,
+    SQL_USER_DEFINED = 1,
+    EXECUTABLE_USER_DEFINED = 2
+};
+
 namespace
 {
     template <typename Factory>
-    void fillRow(MutableColumns & res_columns, const String & name, UInt64 is_aggregate, const String & create_query, const Factory & f)
+    void fillRow(MutableColumns & res_columns, const String & name, UInt64 is_aggregate, const String & create_query, FunctionOrigin function_origin, const Factory & f)
     {
         res_columns[0]->insert(name);
         res_columns[1]->insert(is_aggregate);
 
-        if constexpr (std::is_same_v<Factory, UserDefinedFunctionFactory>)
+        if constexpr (std::is_same_v<Factory, UserDefinedSQLFunctionFactory> || std::is_same_v<Factory, UserDefinedExecutableFunctionFactory>)
         {
             res_columns[2]->insert(false);
             res_columns[3]->insertDefault();
@@ -33,9 +43,19 @@ namespace
         }
 
         res_columns[4]->insert(create_query);
+        res_columns[5]->insert(static_cast<Int8>(function_origin));
     }
 }
 
+std::vector<std::pair<String, Int8>> getOriginEnumsAndValues()
+{
+    return std::vector<std::pair<String, Int8>>{
+        {"System", static_cast<Int8>(FunctionOrigin::SYSTEM)},
+        {"SQLUserDefined", static_cast<Int8>(FunctionOrigin::SQL_USER_DEFINED)},
+        {"ExecutableUserDefined", static_cast<Int8>(FunctionOrigin::EXECUTABLE_USER_DEFINED)}
+    };
+}
+
 NamesAndTypesList StorageSystemFunctions::getNamesAndTypes()
 {
     return {
@@ -43,32 +63,40 @@ NamesAndTypesList StorageSystemFunctions::getNamesAndTypes()
         {"is_aggregate", std::make_shared<DataTypeUInt8>()},
         {"case_insensitive", std::make_shared<DataTypeUInt8>()},
         {"alias_to", std::make_shared<DataTypeString>()},
-        {"create_query", std::make_shared<DataTypeString>()}
+        {"create_query", std::make_shared<DataTypeString>()},
+        {"origin", std::make_shared<DataTypeEnum8>(getOriginEnumsAndValues())}
     };
 }
 
-void StorageSystemFunctions::fillData(MutableColumns & res_columns, ContextPtr, const SelectQueryInfo &) const
+void StorageSystemFunctions::fillData(MutableColumns & res_columns, ContextPtr context, const SelectQueryInfo &) const
 {
     const auto & functions_factory = FunctionFactory::instance();
     const auto & function_names = functions_factory.getAllRegisteredNames();
     for (const auto & function_name : function_names)
     {
-        fillRow(res_columns, function_name, UInt64(0), "", functions_factory);
+        fillRow(res_columns, function_name, UInt64(0), "", FunctionOrigin::SYSTEM, functions_factory);
     }
 
     const auto & aggregate_functions_factory = AggregateFunctionFactory::instance();
     const auto & aggregate_function_names = aggregate_functions_factory.getAllRegisteredNames();
     for (const auto & function_name : aggregate_function_names)
     {
-        fillRow(res_columns, function_name, UInt64(1), "", aggregate_functions_factory);
+        fillRow(res_columns, function_name, UInt64(1), "", FunctionOrigin::SYSTEM, aggregate_functions_factory);
+    }
+
+    const auto & user_defined_sql_functions_factory = UserDefinedSQLFunctionFactory::instance();
+    const auto & user_defined_sql_functions_names = user_defined_sql_functions_factory.getAllRegisteredNames();
+    for (const auto & function_name : user_defined_sql_functions_names)
+    {
+        auto create_query = queryToString(user_defined_sql_functions_factory.get(function_name));
+        fillRow(res_columns, function_name, UInt64(0), create_query, FunctionOrigin::SQL_USER_DEFINED, user_defined_sql_functions_factory);
     }
 
-    const auto & user_defined_functions_factory = UserDefinedFunctionFactory::instance();
-    const auto & user_defined_functions_names = user_defined_functions_factory.getAllRegisteredNames();
-    for (const auto & function_name : user_defined_functions_names)
+    const auto & user_defined_executable_functions_factory = UserDefinedExecutableFunctionFactory::instance();
+    const auto & user_defined_executable_functions_names = user_defined_executable_functions_factory.getRegisteredNames(context);
+    for (const auto & function_name : user_defined_executable_functions_names)
     {
-        auto create_query = queryToString(user_defined_functions_factory.get(function_name));
-        fillRow(res_columns, function_name, UInt64(0), create_query, user_defined_functions_factory);
+        fillRow(res_columns, function_name, UInt64(0), "", FunctionOrigin::EXECUTABLE_USER_DEFINED, user_defined_executable_functions_factory);
     }
 }
 }
