{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56090,
  "instance_id": "ClickHouse__ClickHouse-56090",
  "issue_numbers": [
    "55942"
  ],
  "base_commit": "59e3d64d2c9770b4a584bdb975552ebed80d4e1a",
  "patch": "diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 291a287919d7..446d6c008f06 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1279,8 +1279,15 @@ class FunctionComparison : public IFunction\n         bool date_and_datetime = (which_left.idx != which_right.idx) && (which_left.isDate() || which_left.isDate32() || which_left.isDateTime() || which_left.isDateTime64())\n             && (which_right.isDate() || which_right.isDate32() || which_right.isDateTime() || which_right.isDateTime64());\n \n+        /// Interval data types can be compared only when having equal units.\n+        bool left_is_interval = which_left.isInterval();\n+        bool right_is_interval = which_right.isInterval();\n+\n+        bool types_equal = left_type->equals(*right_type);\n+\n         ColumnPtr res;\n-        if (left_is_num && right_is_num && !date_and_datetime)\n+        if (left_is_num && right_is_num && !date_and_datetime\n+            && (!left_is_interval || !right_is_interval || types_equal))\n         {\n             if (!((res = executeNumLeftType<UInt8>(col_left_untyped, col_right_untyped))\n                 || (res = executeNumLeftType<UInt16>(col_left_untyped, col_right_untyped))\n@@ -1372,7 +1379,7 @@ class FunctionComparison : public IFunction\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Date related common types can only be UInt32/UInt64/Int32/Decimal\");\n             return res;\n         }\n-        else if (left_type->equals(*right_type))\n+        else if (types_equal)\n         {\n             return executeGenericIdenticalTypes(col_left_untyped, col_right_untyped);\n         }\ndiff --git a/src/Interpreters/InterpreterShowIndexesQuery.cpp b/src/Interpreters/InterpreterShowIndexesQuery.cpp\nindex 63cda814683b..549afd325062 100644\n--- a/src/Interpreters/InterpreterShowIndexesQuery.cpp\n+++ b/src/Interpreters/InterpreterShowIndexesQuery.cpp\n@@ -89,7 +89,7 @@ ORDER BY index_type, expression, column_name, seq_in_index;)\", database, table,\n     ///   can be functional indexes.\n     /// Above SELECT tries to emulate that. Caveats:\n     /// 1. The primary key index sub-SELECT assumes the primary key expression is non-functional. Non-functional primary key indexes in\n-    ///    ClickHouse are possible but quiete obscure. In MySQL they are not possible at all.\n+    ///    ClickHouse are possible but quite obscure. In MySQL they are not possible at all.\n     /// 2. Related to 1.: Poor man's tuple parsing with splitByString() in the PK sub-SELECT messes up for functional primary key index\n     ///    expressions where the comma is not only used as separator between tuple components, e.g. in 'col1 + 1, concat(col2, col3)'.\n     /// 3. The data skipping index sub-SELECT assumes the index expression is functional. 3rd party tools that expect MySQL semantics from\n@@ -106,4 +106,3 @@ BlockIO InterpreterShowIndexesQuery::execute()\n \n \n }\n-\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02906_interval_comparison.reference b/tests/queries/0_stateless/02906_interval_comparison.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02906_interval_comparison.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/02906_interval_comparison.sql b/tests/queries/0_stateless/02906_interval_comparison.sql\nnew file mode 100644\nindex 000000000000..92400caa8786\n--- /dev/null\n+++ b/tests/queries/0_stateless/02906_interval_comparison.sql\n@@ -0,0 +1,7 @@\n+-- Comparing the same types is ok:\n+SELECT INTERVAL 1 SECOND = INTERVAL 1 SECOND;\n+-- It is reasonable to not give an answer for this:\n+SELECT INTERVAL 30 DAY < INTERVAL 1 MONTH; -- { serverError 386 }\n+-- This we could change in the future:\n+SELECT INTERVAL 1 SECOND = INTERVAL 1 YEAR; -- { serverError 386 }\n+SELECT INTERVAL 1 SECOND <= INTERVAL 1 YEAR; -- { serverError 386 }\n",
  "problem_statement": "interval comparison apparently ignore units\nComparison of intervals appear to ignore units, and just compare the numeric values.\r\n\r\nHere's what happens (clearly 1 microsecond is not equal to 1 second, and similarly 100us is not greater than 1 second).\r\n\r\n```\r\n\r\ndf3efe7565e7 :) select toIntervalMicrosecond(1) = toIntervalSecond(1)\r\n\r\nSELECT toIntervalMicrosecond(1) = toIntervalSecond(1)\r\n\r\nQuery id: 49f6631d-92c2-42c8-9b2f-99c40b3fae8f\r\n\r\n\u250c\u2500equals(toIntervalMicrosecond(1), toIntervalSecond(1))\u2500\u2510\r\n\u2502                                                     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.004 sec. \r\n\r\ndf3efe7565e7 :) select toIntervalMicrosecond(100) > toIntervalSecond(1)\r\n\r\nSELECT toIntervalMicrosecond(100) > toIntervalSecond(1)\r\n\r\nQuery id: a4ccf74f-e04c-4ef2-b6c8-6c22002b48aa\r\n\r\n\u250c\u2500greater(toIntervalMicrosecond(100), toIntervalSecond(1))\u2500\u2510\r\n\u2502                                                        1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec. \r\n\r\ndf3efe7565e7 :) select version()\r\n\r\nSELECT version()\r\n\r\nQuery id: 17b10304-ea34-4f8e-9223-788c7d4a4df6\r\n\r\n\u250c\u2500version()\u2500\u2500\u2500\u2510\r\n\u2502 23.8.1.2992 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.003 sec. \r\n```\r\n\r\nhttps://fiddle.clickhouse.com/19443d43-8d8d-4d27-adf9-33a02ec1d6cf\n",
  "hints_text": "Thanks for reporting. I'm not sure the comparison function covers this, given they are different types: https://clickhouse.com/docs/en/sql-reference/functions/comparison-functions \nThanks @melvynator.\r\n\r\nAs mentioned by @cwurm via email, at the very least an error should be raised if you compare intervals with different units.\r\n\r\nBut to be clear, our SQL translation logic would be a great deal cleaner if different units were correctly supported across comparison.\nYes, probably an error message when different units are used is the solution. Ideally, automatically converts to a standard unit. \nIt is not possible to compare intervals of different types. For example, `INTERVAL 1 MONTH` and `INTERVAL 30 DAY`, or `INTERVAL 1 DAY` and `INTERVAL 24 HOUR`. It should throw an exception.\r\n\r\nCurrently, it compares the underlying numeric representation of intervals.",
  "created_at": "2023-10-27T21:26:47Z",
  "modified_files": [
    "src/Functions/FunctionsComparison.h",
    "src/Interpreters/InterpreterShowIndexesQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02906_interval_comparison.reference",
    "b/tests/queries/0_stateless/02906_interval_comparison.sql"
  ]
}