diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index dc74b6072898..deef82ee6996 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -2629,12 +2629,6 @@ Sets the maximum number of inserted blocks after which mergeable blocks are drop
 
 Default value: `64`.
 
-## temporary_live_view_timeout {#temporary-live-view-timeout}
-
-Sets the interval in seconds after which [live view](../../sql-reference/statements/create/view.md#live-view) with timeout is deleted.
-
-Default value: `5`.
-
 ## periodic_live_view_refresh {#periodic-live-view-refresh}
 
 Sets the interval in seconds after which periodically refreshed [live view](../../sql-reference/statements/create/view.md#live-view) is forced to refresh.
diff --git a/docs/en/sql-reference/statements/create/view.md b/docs/en/sql-reference/statements/create/view.md
index 46dd7e6fdd70..5833c43f55dc 100644
--- a/docs/en/sql-reference/statements/create/view.md
+++ b/docs/en/sql-reference/statements/create/view.md
@@ -166,23 +166,6 @@ SELECT * FROM [db.]live_view WHERE ...
 
 You can force live view refresh using the `ALTER LIVE VIEW [db.]table_name REFRESH` statement.
 
-### WITH TIMEOUT Clause
-
-When a live view is created with a `WITH TIMEOUT` clause then the live view will be dropped automatically after the specified number of seconds elapse since the end of the last [WATCH](../../../sql-reference/statements/watch.md) query that was watching the live view.
-
-```sql
-CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AS SELECT ...
-```
-
-If the timeout value is not specified then the value specified by the [temporary_live_view_timeout](../../../operations/settings/settings.md#temporary-live-view-timeout) setting is used.
-
-**Example:**
-
-```sql
-CREATE TABLE mt (x Int8) Engine = MergeTree ORDER BY x;
-CREATE LIVE VIEW lv WITH TIMEOUT 15 AS SELECT sum(x) FROM mt;
-```
-
 ### WITH REFRESH Clause
 
 When a live view is created with a `WITH REFRESH` clause then it will be automatically refreshed after the specified number of seconds elapse since the last refresh or trigger.
@@ -212,20 +195,6 @@ WATCH lv
 └─────────────────────┴──────────┘
 ```
 
-You can combine `WITH TIMEOUT` and `WITH REFRESH` clauses using an `AND` clause.
-
-```sql
-CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AND REFRESH [value_in_sec] AS SELECT ...
-```
-
-**Example:**
-
-```sql
-CREATE LIVE VIEW lv WITH TIMEOUT 15 AND REFRESH 5 AS SELECT now();
-```
-
-After 15 sec the live view will be automatically dropped if there are no active `WATCH` queries.
-
 ```sql
 WATCH lv
 ```
diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md
index 3d765b03d58e..05cfbcb4a87e 100644
--- a/docs/ru/operations/settings/settings.md
+++ b/docs/ru/operations/settings/settings.md
@@ -3258,12 +3258,6 @@ SELECT * FROM test2;
 
 Значение по умолчанию: `64`.
 
-## temporary_live_view_timeout {#temporary-live-view-timeout}
-
-Задает время в секундах, после которого [LIVE VIEW](../../sql-reference/statements/create/view.md#live-view) удаляется.
-
-Значение по умолчанию: `5`.
-
 ## periodic_live_view_refresh {#periodic-live-view-refresh}
 
 Задает время в секундах, по истечении которого [LIVE VIEW](../../sql-reference/statements/create/view.md#live-view) с установленным автообновлением обновляется.
diff --git a/docs/ru/sql-reference/statements/create/view.md b/docs/ru/sql-reference/statements/create/view.md
index 573db8938b2a..6cbd4c6a30cd 100644
--- a/docs/ru/sql-reference/statements/create/view.md
+++ b/docs/ru/sql-reference/statements/create/view.md
@@ -156,23 +156,6 @@ SELECT * FROM [db.]live_view WHERE ...
 
 Чтобы принудительно обновить LIVE-представление, используйте запрос `ALTER LIVE VIEW [db.]table_name REFRESH`.
 
-### Секция WITH TIMEOUT {#live-view-with-timeout}
-
-LIVE-представление, созданное с параметром `WITH TIMEOUT`, будет автоматически удалено через определенное количество секунд с момента предыдущего запроса [WATCH](../../../sql-reference/statements/watch.md), примененного к данному LIVE-представлению.
-
-```sql
-CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AS SELECT ...
-```
-
-Если временной промежуток не указан, используется значение настройки [temporary_live_view_timeout](../../../operations/settings/settings.md#temporary-live-view-timeout).
-
-**Пример:**
-
-```sql
-CREATE TABLE mt (x Int8) Engine = MergeTree ORDER BY x;
-CREATE LIVE VIEW lv WITH TIMEOUT 15 AS SELECT sum(x) FROM mt;
-```
-
 ### Секция WITH REFRESH {#live-view-with-refresh}
 
 LIVE-представление, созданное с параметром `WITH REFRESH`, будет автоматически обновляться через указанные промежутки времени, начиная с момента последнего обновления.
@@ -202,20 +185,6 @@ WATCH lv;
 └─────────────────────┴──────────┘
 ```
 
-Параметры `WITH TIMEOUT` и `WITH REFRESH` можно сочетать с помощью `AND`.
-
-```sql
-CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AND REFRESH [value_in_sec] AS SELECT ...
-```
-
-**Пример:**
-
-```sql
-CREATE LIVE VIEW lv WITH TIMEOUT 15 AND REFRESH 5 AS SELECT now();
-```
-
-По истечении 15 секунд представление будет автоматически удалено, если нет активного запроса `WATCH`.
-
 ```sql
 WATCH lv;
 ```
diff --git a/docs/zh/sql-reference/statements/create/view.md b/docs/zh/sql-reference/statements/create/view.md
index 12ffe35dde0d..be2f8d6ded3d 100644
--- a/docs/zh/sql-reference/statements/create/view.md
+++ b/docs/zh/sql-reference/statements/create/view.md
@@ -164,23 +164,6 @@ SELECT * FROM [db.]live_view WHERE ...
 
 您可以使用`ALTER LIVE VIEW [db.]table_name REFRESH`语法.
 
-### WITH TIMEOUT条件 {#live-view-with-timeout}
-
-当使用`WITH TIMEOUT`子句创建实时视图时，[WATCH](../../../sql-reference/statements/watch.md)观察实时视图的查询。
-
-```sql
-CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AS SELECT ...
-```
-
-如果未指定超时值，则由指定的值[temporary_live_view_timeout](../../../operations/settings/settings.md#temporary-live-view-timeout)决定.
-
-**示例:**
-
-```sql
-CREATE TABLE mt (x Int8) Engine = MergeTree ORDER BY x;
-CREATE LIVE VIEW lv WITH TIMEOUT 15 AS SELECT sum(x) FROM mt;
-```
-
 ### WITH REFRESH条件 {#live-view-with-refresh}
 
 当使用`WITH REFRESH`子句创建实时视图时，它将在自上次刷新或触发后经过指定的秒数后自动刷新。
@@ -210,20 +193,6 @@ WATCH lv
 └─────────────────────┴──────────┘
 ```
 
-您可以使用`AND`子句组合`WITH TIMEOUT`和`WITH REFRESH`子句。
-
-```sql
-CREATE LIVE VIEW [db.]table_name WITH TIMEOUT [value_in_sec] AND REFRESH [value_in_sec] AS SELECT ...
-```
-
-**示例:**
-
-```sql
-CREATE LIVE VIEW lv WITH TIMEOUT 15 AND REFRESH 5 AS SELECT now();
-```
-
-15 秒后，如果没有活动的`WATCH`查询，实时视图将自动删除。
-
 ```sql
 WATCH lv
 ```
diff --git a/src/Core/Defines.h b/src/Core/Defines.h
index 9665a20a397b..80efe4f77bff 100644
--- a/src/Core/Defines.h
+++ b/src/Core/Defines.h
@@ -31,7 +31,6 @@
   */
 #define DEFAULT_MERGE_BLOCK_SIZE 8192
 
-#define DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC 5
 #define DEFAULT_PERIODIC_LIVE_VIEW_REFRESH_SEC 60
 #define SHOW_CHARS_ON_SYNTAX_ERROR ptrdiff_t(160)
 #define DBMS_CONNECTION_POOL_WITH_FAILOVER_DEFAULT_MAX_TRIES 3
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 26b6fd56ade7..f429b7560d5a 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -501,7 +501,6 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     M(Bool, validate_polygons, true, "Throw exception if polygon is invalid in function pointInPolygon (e.g. self-tangent, self-intersecting). If the setting is false, the function will accept invalid polygons but may silently return wrong result.", 0) \
     M(UInt64, max_parser_depth, DBMS_DEFAULT_MAX_PARSER_DEPTH, "Maximum parser depth (recursion depth of recursive descend parser).", 0) \
     M(Bool, allow_settings_after_format_in_insert, false, "Allow SETTINGS after FORMAT, but note, that this is not always safe (note: this is a compatibility setting).", 0) \
-    M(Seconds, temporary_live_view_timeout, DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC, "Timeout after which temporary live view is deleted.", 0) \
     M(Seconds, periodic_live_view_refresh, DEFAULT_PERIODIC_LIVE_VIEW_REFRESH_SEC, "Interval after which periodically refreshed live view is forced to refresh.", 0) \
     M(Bool, transform_null_in, false, "If enabled, NULL values will be matched with 'IN' operator as if they are considered equal.", 0) \
     M(Bool, allow_nondeterministic_mutations, false, "Allow non-deterministic functions in ALTER UPDATE/ALTER DELETE statements", 0) \
@@ -691,7 +690,8 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     MAKE_OBSOLETE(M, UInt64, background_message_broker_schedule_pool_size, 16) \
     MAKE_OBSOLETE(M, UInt64, background_distributed_schedule_pool_size, 16) \
     MAKE_OBSOLETE(M, DefaultDatabaseEngine, default_database_engine, DefaultDatabaseEngine::Atomic) \
-    MAKE_OBSOLETE(M, UInt64, max_pipeline_depth, 0) \
+    MAKE_OBSOLETE(M, UInt64, max_pipeline_depth, 0)                                                                                 \
+    MAKE_OBSOLETE(M, Seconds, temporary_live_view_timeout, 1) \
 
     /** The section above is for obsolete settings. Do not add anything there. */
 
diff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp
index 67fb256b1c9b..73189979d85f 100644
--- a/src/Interpreters/DatabaseCatalog.cpp
+++ b/src/Interpreters/DatabaseCatalog.cpp
@@ -8,7 +8,6 @@
 #include <Disks/IDisk.h>
 #include <Common/quoteString.h>
 #include <Storages/StorageMemory.h>
-#include <Storages/LiveView/TemporaryLiveViewCleaner.h>
 #include <Core/BackgroundSchedulePool.h>
 #include <Parsers/formatAST.h>
 #include <IO/ReadHelpers.h>
@@ -171,16 +170,10 @@ void DatabaseCatalog::loadDatabases()
     std::lock_guard lock{tables_marked_dropped_mutex};
     if (!tables_marked_dropped.empty())
         (*drop_task)->schedule();
-
-    /// Another background thread which drops temporary LiveViews.
-    /// We should start it after loadMarkedAsDroppedTables() to avoid race condition.
-    TemporaryLiveViewCleaner::instance().startup();
 }
 
 void DatabaseCatalog::shutdownImpl()
 {
-    TemporaryLiveViewCleaner::shutdown();
-
     if (cleanup_task)
         (*cleanup_task)->deactivate();
 
@@ -657,7 +650,6 @@ std::unique_ptr<DatabaseCatalog> DatabaseCatalog::database_catalog;
 DatabaseCatalog::DatabaseCatalog(ContextMutablePtr global_context_)
     : WithMutableContext(global_context_), log(&Poco::Logger::get("DatabaseCatalog"))
 {
-    TemporaryLiveViewCleaner::init(global_context_);
 }
 
 DatabaseCatalog & DatabaseCatalog::init(ContextMutablePtr global_context_)
diff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp
index a277960643bc..f8853d211784 100644
--- a/src/Parsers/ASTCreateQuery.cpp
+++ b/src/Parsers/ASTCreateQuery.cpp
@@ -297,18 +297,10 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM " << (settings.hilite ? hilite_none : "")
                           << quoteString(*attach_from_path);
 
-        if (live_view_timeout)
-            settings.ostr << (settings.hilite ? hilite_keyword : "") << " WITH TIMEOUT " << (settings.hilite ? hilite_none : "")
-                          << *live_view_timeout;
-
         if (live_view_periodic_refresh)
         {
-            if (live_view_timeout)
-                settings.ostr << (settings.hilite ? hilite_keyword : "") << " AND" << (settings.hilite ? hilite_none : "");
-            else
-                settings.ostr << (settings.hilite ? hilite_keyword : "") << " WITH" << (settings.hilite ? hilite_none : "");
-
-            settings.ostr << (settings.hilite ? hilite_keyword : "") << " PERIODIC REFRESH " << (settings.hilite ? hilite_none : "")
+            settings.ostr << (settings.hilite ? hilite_keyword : "") << " WITH" << (settings.hilite ? hilite_none : "")
+                << (settings.hilite ? hilite_keyword : "") << " PERIODIC REFRESH " << (settings.hilite ? hilite_none : "")
                 << *live_view_periodic_refresh;
         }
 
diff --git a/src/Parsers/ASTCreateQuery.h b/src/Parsers/ASTCreateQuery.h
index f3729b1523f5..de0f187f0e2a 100644
--- a/src/Parsers/ASTCreateQuery.h
+++ b/src/Parsers/ASTCreateQuery.h
@@ -93,7 +93,6 @@ class ASTCreateQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnC
     ASTExpressionList * dictionary_attributes_list = nullptr; /// attributes of
     ASTDictionary * dictionary = nullptr; /// dictionary definition (layout, primary key, etc.)
 
-    std::optional<UInt64> live_view_timeout;    /// For CREATE LIVE VIEW ... WITH TIMEOUT ...
     std::optional<UInt64> live_view_periodic_refresh;    /// For CREATE LIVE VIEW ... WITH [PERIODIC] REFRESH ...
 
     bool is_watermark_strictly_ascending{false}; /// STRICTLY ASCENDING WATERMARK STRATEGY FOR WINDOW VIEW
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index fc90f9ce3ed2..77540141b536 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -708,7 +708,6 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     ASTPtr as_database;
     ASTPtr as_table;
     ASTPtr select;
-    ASTPtr live_view_timeout;
     ASTPtr live_view_periodic_refresh;
 
     String cluster_str;
@@ -740,20 +739,6 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
 
     if (ParserKeyword{"WITH"}.ignore(pos, expected))
     {
-        if (ParserKeyword{"TIMEOUT"}.ignore(pos, expected))
-        {
-            if (!ParserNumber{}.parse(pos, live_view_timeout, expected))
-            {
-                live_view_timeout = std::make_shared<ASTLiteral>(static_cast<UInt64>(DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC));
-            }
-
-            /// Optional - AND
-            if (ParserKeyword{"AND"}.ignore(pos, expected))
-                with_and = true;
-
-            with_timeout = true;
-        }
-
         if (ParserKeyword{"REFRESH"}.ignore(pos, expected) || ParserKeyword{"PERIODIC REFRESH"}.ignore(pos, expected))
         {
             if (!ParserNumber{}.parse(pos, live_view_periodic_refresh, expected))
@@ -828,9 +813,6 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     tryGetIdentifierNameInto(as_table, query->as_table);
     query->set(query->select, select);
 
-    if (live_view_timeout)
-        query->live_view_timeout.emplace(live_view_timeout->as<ASTLiteral &>().value.safeGet<UInt64>());
-
     if (live_view_periodic_refresh)
         query->live_view_periodic_refresh.emplace(live_view_periodic_refresh->as<ASTLiteral &>().value.safeGet<UInt64>());
 
diff --git a/src/Storages/LiveView/StorageLiveView.cpp b/src/Storages/LiveView/StorageLiveView.cpp
index 4f52267a7fec..e3d19d0a4338 100644
--- a/src/Storages/LiveView/StorageLiveView.cpp
+++ b/src/Storages/LiveView/StorageLiveView.cpp
@@ -21,25 +21,19 @@ limitations under the License. */
 #include <Processors/Executors/PullingAsyncPipelineExecutor.h>
 #include <Processors/Executors/PipelineExecutor.h>
 #include <Processors/Transforms/SquashingChunksTransform.h>
-#include <Processors/Transforms/ExpressionTransform.h>
 #include <QueryPipeline/QueryPipelineBuilder.h>
 #include <Common/logger_useful.h>
 #include <Common/typeid_cast.h>
 #include <Common/SipHash.h>
 #include <Common/hex.h>
-#include "QueryPipeline/printPipeline.h"
 
 #include <Storages/LiveView/StorageLiveView.h>
 #include <Storages/LiveView/LiveViewSource.h>
 #include <Storages/LiveView/LiveViewSink.h>
 #include <Storages/LiveView/LiveViewEventsSource.h>
 #include <Storages/LiveView/StorageBlocks.h>
-#include <Storages/LiveView/TemporaryLiveViewCleaner.h>
 
 #include <Storages/StorageFactory.h>
-#include <Parsers/ASTTablesInSelectQuery.h>
-#include <Parsers/ASTSubquery.h>
-#include <Parsers/queryToString.h>
 #include <Interpreters/DatabaseAndTableWithAlias.h>
 #include <Interpreters/DatabaseCatalog.h>
 #include <Interpreters/getTableExpressions.h>
@@ -312,12 +306,6 @@ StorageLiveView::StorageLiveView(
 
     DatabaseCatalog::instance().addDependency(select_table_id, table_id_);
 
-    if (query.live_view_timeout)
-    {
-        is_temporary = true;
-        temporary_live_view_timeout = Seconds {*query.live_view_timeout};
-    }
-
     if (query.live_view_periodic_refresh)
     {
         is_periodically_refreshed = true;
@@ -456,9 +444,6 @@ void StorageLiveView::checkTableCanBeDropped() const
 
 void StorageLiveView::startup()
 {
-    if (is_temporary)
-        TemporaryLiveViewCleaner::instance().addView(std::static_pointer_cast<StorageLiveView>(shared_from_this()));
-
     if (is_periodically_refreshed)
         periodic_refresh_task->activate();
 }
diff --git a/src/Storages/LiveView/StorageLiveView.h b/src/Storages/LiveView/StorageLiveView.h
index 4d140f6a82a9..c6a0379e2abf 100644
--- a/src/Storages/LiveView/StorageLiveView.h
+++ b/src/Storages/LiveView/StorageLiveView.h
@@ -86,19 +86,6 @@ friend class LiveViewSink;
 
     NamesAndTypesList getVirtuals() const override;
 
-    bool isTemporary() const { return is_temporary; }
-    bool isPeriodicallyRefreshed() const { return is_periodically_refreshed; }
-
-    Seconds getTimeout() const { return temporary_live_view_timeout; }
-    Seconds getPeriodicRefresh() const { return periodic_live_view_refresh; }
-
-    /// Check if we have any readers
-    /// must be called with mutex locked
-    bool hasUsers()
-    {
-        return blocks_ptr.use_count() > 1;
-    }
-
     /// Check we have any active readers
     /// must be called with mutex locked
     bool hasActiveUsers()
@@ -200,10 +187,7 @@ friend class LiveViewSink;
 
     Poco::Logger * log;
 
-    bool is_temporary = false;
     bool is_periodically_refreshed = false;
-
-    Seconds temporary_live_view_timeout;
     Seconds periodic_live_view_refresh;
 
     /// Mutex to protect access to sample block and inner_blocks_query
diff --git a/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp b/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp
deleted file mode 100644
index 12af472247d0..000000000000
--- a/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-#include <Storages/LiveView/TemporaryLiveViewCleaner.h>
-
-#include <Interpreters/DatabaseCatalog.h>
-#include <Interpreters/InterpreterDropQuery.h>
-#include <Parsers/ASTDropQuery.h>
-#include <Storages/LiveView/StorageLiveView.h>
-
-
-namespace DB
-{
-namespace ErrorCodes
-{
-    extern const int LOGICAL_ERROR;
-}
-
-
-namespace
-{
-    void executeDropQuery(const StorageID & storage_id, ContextMutablePtr context)
-    {
-        if (!DatabaseCatalog::instance().isTableExist(storage_id, context))
-            return;
-        try
-        {
-            /// We create and execute `drop` query for this table
-            auto drop_query = std::make_shared<ASTDropQuery>();
-            drop_query->setDatabase(storage_id.database_name);
-            drop_query->setTable(storage_id.table_name);
-            drop_query->kind = ASTDropQuery::Kind::Drop;
-            ASTPtr ast_drop_query = drop_query;
-            InterpreterDropQuery drop_interpreter(ast_drop_query, context);
-            drop_interpreter.execute();
-        }
-        catch (...)
-        {
-            tryLogCurrentException(__PRETTY_FUNCTION__);
-        }
-    }
-}
-
-
-std::unique_ptr<TemporaryLiveViewCleaner> TemporaryLiveViewCleaner::the_instance;
-
-
-void TemporaryLiveViewCleaner::init(ContextMutablePtr global_context_)
-{
-    if (the_instance)
-        throw Exception("TemporaryLiveViewCleaner already initialized", ErrorCodes::LOGICAL_ERROR);
-    the_instance.reset(new TemporaryLiveViewCleaner(global_context_));
-}
-
-void TemporaryLiveViewCleaner::startup()
-{
-    background_thread_can_start = true;
-
-    std::lock_guard lock{mutex};
-    if (!views.empty())
-        startBackgroundThread();
-}
-
-void TemporaryLiveViewCleaner::shutdown()
-{
-    the_instance.reset();
-}
-
-TemporaryLiveViewCleaner::TemporaryLiveViewCleaner(ContextMutablePtr global_context_) : WithMutableContext(global_context_)
-{
-}
-
-TemporaryLiveViewCleaner::~TemporaryLiveViewCleaner()
-{
-    stopBackgroundThread();
-}
-
-
-void TemporaryLiveViewCleaner::addView(const std::shared_ptr<StorageLiveView> & view)
-{
-    if (!view->isTemporary() || background_thread_should_exit)
-        return;
-
-    auto current_time = std::chrono::system_clock::now();
-    auto time_of_next_check = current_time + view->getTimeout();
-
-    /// Keep the vector `views` sorted by time of next check.
-    StorageAndTimeOfCheck storage_and_time_of_check{view, time_of_next_check};
-    std::lock_guard lock{mutex};
-    views.insert(std::upper_bound(views.begin(), views.end(), storage_and_time_of_check), storage_and_time_of_check);
-
-    if (background_thread_can_start)
-    {
-        startBackgroundThread();
-        background_thread_wake_up.notify_one();
-    }
-}
-
-
-void TemporaryLiveViewCleaner::backgroundThreadFunc()
-{
-    std::unique_lock lock{mutex};
-    while (!background_thread_should_exit)
-    {
-        if (views.empty())
-            background_thread_wake_up.wait(lock);
-        else
-            background_thread_wake_up.wait_until(lock, views.front().time_of_check);
-
-        if (background_thread_should_exit)
-            break;
-
-        auto current_time = std::chrono::system_clock::now();
-        std::vector<StorageID> storages_to_drop;
-
-        auto it = views.begin();
-        while (it != views.end())
-        {
-            std::shared_ptr<StorageLiveView> storage = it->storage.lock();
-            auto & time_of_check = it->time_of_check;
-            if (!storage)
-            {
-                /// Storage has been already removed.
-                it = views.erase(it);
-                continue;
-            }
-
-            if (current_time < time_of_check)
-                break; /// It's not the time to check it yet.
-
-            auto storage_id = storage->getStorageID();
-            if (!storage->hasUsers() && DatabaseCatalog::instance().getDependencies(storage_id).empty())
-            {
-                /// No users and no dependencies so we can remove the storage.
-                storages_to_drop.emplace_back(storage_id);
-                it = views.erase(it);
-                continue;
-            }
-
-            /// Calculate time of the next check.
-            time_of_check = current_time + storage->getTimeout();
-
-            ++it;
-        }
-
-        lock.unlock();
-        for (const auto & storage_id : storages_to_drop)
-            executeDropQuery(storage_id, getContext());
-        lock.lock();
-    }
-}
-
-
-void TemporaryLiveViewCleaner::startBackgroundThread()
-{
-    if (!background_thread.joinable() && background_thread_can_start && !background_thread_should_exit)
-        background_thread = ThreadFromGlobalPool{&TemporaryLiveViewCleaner::backgroundThreadFunc, this};
-}
-
-void TemporaryLiveViewCleaner::stopBackgroundThread()
-{
-    background_thread_should_exit = true;
-    background_thread_wake_up.notify_one();
-    if (background_thread.joinable())
-        background_thread.join();
-}
-
-}
diff --git a/src/Storages/LiveView/TemporaryLiveViewCleaner.h b/src/Storages/LiveView/TemporaryLiveViewCleaner.h
deleted file mode 100644
index 9cc5933eb894..000000000000
--- a/src/Storages/LiveView/TemporaryLiveViewCleaner.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#pragma once
-
-#include <Interpreters/Context_fwd.h>
-#include <Common/ThreadPool.h>
-
-#include <chrono>
-
-
-namespace DB
-{
-
-class StorageLiveView;
-struct StorageID;
-
-/// This class removes temporary live views in the background thread when it's possible.
-/// There should only a single instance of this class.
-class TemporaryLiveViewCleaner : WithMutableContext
-{
-public:
-    static TemporaryLiveViewCleaner & instance() { return *the_instance; }
-
-    /// Drops a specified live view after a while if it's temporary.
-    void addView(const std::shared_ptr<StorageLiveView> & view);
-
-    /// Should be called once.
-    static void init(ContextMutablePtr global_context_);
-    static void shutdown();
-
-    void startup();
-
-private:
-    friend std::unique_ptr<TemporaryLiveViewCleaner>::deleter_type;
-
-    explicit TemporaryLiveViewCleaner(ContextMutablePtr global_context_);
-    ~TemporaryLiveViewCleaner();
-
-    void backgroundThreadFunc();
-    void startBackgroundThread();
-    void stopBackgroundThread();
-
-    struct StorageAndTimeOfCheck
-    {
-        std::weak_ptr<StorageLiveView> storage;
-        std::chrono::system_clock::time_point time_of_check;
-        bool operator <(const StorageAndTimeOfCheck & other) const { return time_of_check < other.time_of_check; }
-    };
-
-    static std::unique_ptr<TemporaryLiveViewCleaner> the_instance;
-    std::mutex mutex;
-    std::vector<StorageAndTimeOfCheck> views;
-    ThreadFromGlobalPool background_thread;
-    std::atomic<bool> background_thread_can_start = false;
-    std::atomic<bool> background_thread_should_exit = false;
-    std::condition_variable background_thread_wake_up;
-};
-
-}
