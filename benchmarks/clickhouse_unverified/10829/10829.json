{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10829,
  "instance_id": "ClickHouse__ClickHouse-10829",
  "issue_numbers": [
    "10532"
  ],
  "base_commit": "19b4e68ecf00c8b323f8fb9eefb087f7a58c6ab9",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\nindex 72c2ce014e4e..96c07cc3d41b 100644\n--- a/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n+++ b/src/AggregateFunctions/AggregateFunctionStatisticsSimple.h\n@@ -80,20 +80,28 @@ struct VarMoments\n         readPODBinary(*this, buf);\n     }\n \n-    T NO_SANITIZE_UNDEFINED getPopulation() const\n+    T getPopulation() const\n     {\n-        return (m[2] - m[1] * m[1] / m[0]) / m[0];\n+        if (m[0] == 0)\n+            return std::numeric_limits<T>::quiet_NaN();\n+\n+        /// Due to numerical errors, the result can be slightly less than zero,\n+        /// but it should be impossible. Trim to zero.\n+\n+        return std::max(T{}, (m[2] - m[1] * m[1] / m[0]) / m[0]);\n     }\n \n-    T NO_SANITIZE_UNDEFINED getSample() const\n+    T getSample() const\n     {\n-        if (m[0] == 0)\n+        if (m[0] <= 1)\n             return std::numeric_limits<T>::quiet_NaN();\n-        return (m[2] - m[1] * m[1] / m[0]) / (m[0] - 1);\n+        return std::max(T{}, (m[2] - m[1] * m[1] / m[0]) / (m[0] - 1));\n     }\n \n-    T NO_SANITIZE_UNDEFINED getMoment3() const\n+    T getMoment3() const\n     {\n+        if (m[0] == 0)\n+            return std::numeric_limits<T>::quiet_NaN();\n         // to avoid accuracy problem\n         if (m[0] == 1)\n             return 0;\n@@ -104,8 +112,10 @@ struct VarMoments\n         ) / m[0];\n     }\n \n-    T NO_SANITIZE_UNDEFINED getMoment4() const\n+    T getMoment4() const\n     {\n+        if (m[0] == 0)\n+            return std::numeric_limits<T>::quiet_NaN();\n         // to avoid accuracy problem\n         if (m[0] == 1)\n             return 0;\n@@ -180,7 +190,7 @@ struct VarMomentsDecimal\n         if (common::mulOverflow(getM(1), getM(1), tmp) ||\n             common::subOverflow(getM(2), NativeType(tmp / m0), tmp))\n             throw Exception(\"Decimal math overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n-        return convertFromDecimal<DataTypeDecimal<T>, DataTypeNumber<Float64>>(tmp / m0, scale);\n+        return std::max(Float64{}, convertFromDecimal<DataTypeDecimal<T>, DataTypeNumber<Float64>>(tmp / m0, scale));\n     }\n \n     Float64 getSample(UInt32 scale) const\n@@ -194,7 +204,7 @@ struct VarMomentsDecimal\n         if (common::mulOverflow(getM(1), getM(1), tmp) ||\n             common::subOverflow(getM(2), NativeType(tmp / m0), tmp))\n             throw Exception(\"Decimal math overflow\", ErrorCodes::DECIMAL_OVERFLOW);\n-        return convertFromDecimal<DataTypeDecimal<T>, DataTypeNumber<Float64>>(tmp / (m0 - 1), scale);\n+        return std::max(Float64{}, convertFromDecimal<DataTypeDecimal<T>, DataTypeNumber<Float64>>(tmp / (m0 - 1), scale));\n     }\n \n     Float64 getMoment3(UInt32 scale) const\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01278_variance_nonnegative.reference b/tests/queries/0_stateless/01278_variance_nonnegative.reference\nnew file mode 100644\nindex 000000000000..405d33487754\n--- /dev/null\n+++ b/tests/queries/0_stateless/01278_variance_nonnegative.reference\n@@ -0,0 +1,8 @@\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/01278_variance_nonnegative.sql b/tests/queries/0_stateless/01278_variance_nonnegative.sql\nnew file mode 100644\nindex 000000000000..aa676d8b269d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01278_variance_nonnegative.sql\n@@ -0,0 +1,9 @@\n+SELECT varSamp(0.1) FROM numbers(1000000);\n+SELECT varPop(0.1) FROM numbers(1000000);\n+SELECT stddevSamp(0.1) FROM numbers(1000000);\n+SELECT stddevPop(0.1) FROM numbers(1000000);\n+\n+SELECT varSampStable(0.1) FROM numbers(1000000);\n+SELECT varPopStable(0.1) FROM numbers(1000000);\n+SELECT stddevSampStable(0.1) FROM numbers(1000000);\n+SELECT stddevPopStable(0.1) FROM numbers(1000000);\n",
  "problem_statement": "BUG: (small) negative variance & nan standard deviation\n**Describe the bug**\r\nI tried to calculate the standard deviation on a variable using `stddevSamp`. However, the command returned nan. Investigating this problem revealed, that `varSamp` returns a really small *and* _negative_ value, which cannot be the case. I thought about switching to log-scale to avoid the problem with too small numbers. Maybe this would be also a possibility for other users.\r\n\r\n**How to reproduce**\r\nI am using version 20.1.8.41. Sadly, I am not able to share the data set. However, I am calculating the variance on a single element of a float array `SELECT stddevSamp(features[73]) as ft_s FROM tbl`. I calculated it for multiple elements in the array and one out of 5 showed this behaviour. \r\n\r\n**Expected behavior**\r\nVariance should never be negative. This should trigger at least a warning. \r\n\r\n**Error message and/or stacktrace**\r\nNo error message, just a nan in case of stddevSamp and a negative value for varSamp.\r\n\r\n**Additional context**\r\nI guess the problem is, that my numbers are really small (always between 0 and 1) and may contain nulls. \r\n\n",
  "hints_text": "We have two variants of every statistical function:\r\n\r\nOrdinary:\r\n`varSamp`\r\n`varPop`\r\n`stddevSamp`\r\n`stddevPop`\r\n`covarSamp`\r\n`covarPop`\r\n`corr`\r\n\r\nAnd numerically stable:\r\n`varSampStable`\r\n`varPopStable`\r\n`stddevSampStable`\r\n`stddevPopStable`\r\n`covarSampStable`\r\n`covarPopStable`\r\n`corrStable`\r\n\r\nThe difference is that numerically stable variants use sophisticated algorithm (similar to Kahan summation) to avoid growth of error during computations.\r\n\r\nBy default you get faster version of functions, because the difference is small enough in almost every use case. Most of other DBMS also use numerically unstable algorithm.\r\n\r\nBut we obviously should not return negative value for variance and stddev. Let's just trim to zero.\nThanks! I wasn't aware of the stable functions!",
  "created_at": "2020-05-12T00:33:31Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionStatisticsSimple.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01278_variance_nonnegative.reference",
    "b/tests/queries/0_stateless/01278_variance_nonnegative.sql"
  ]
}