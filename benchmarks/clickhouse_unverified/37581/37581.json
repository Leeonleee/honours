{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37581,
  "instance_id": "ClickHouse__ClickHouse-37581",
  "issue_numbers": [
    "37274"
  ],
  "base_commit": "351956d1089399e9e4f976e965d40c41db67cf9b",
  "patch": "diff --git a/src/Dictionaries/HTTPDictionarySource.cpp b/src/Dictionaries/HTTPDictionarySource.cpp\nindex cf8b60f3681e..17592a8d9da9 100644\n--- a/src/Dictionaries/HTTPDictionarySource.cpp\n+++ b/src/Dictionaries/HTTPDictionarySource.cpp\n@@ -8,6 +8,7 @@\n #include <IO/WriteHelpers.h>\n #include <Processors/Formats/IInputFormat.h>\n #include <Interpreters/Context.h>\n+#include <Storages/ExternalDataSourceConfiguration.h>\n #include <Poco/Net/HTTPRequest.h>\n #include <Common/logger_useful.h>\n #include \"DictionarySourceFactory.h\"\n@@ -228,45 +229,80 @@ void registerDictionarySourceHTTP(DictionarySourceFactory & factory)\n         if (dict_struct.has_expressions)\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"Dictionary source of type `http` does not support attribute expressions\");\n \n-        auto context = copyContextAndApplySettingsFromDictionaryConfig(global_context, config, config_prefix);\n-\n-        const auto & settings_config_prefix = config_prefix + \".http\";\n-        const auto & credentials_prefix = settings_config_prefix + \".credentials\";\n-\n+        auto settings_config_prefix = config_prefix + \".http\";\n         Poco::Net::HTTPBasicCredentials credentials;\n-\n-        if (config.has(credentials_prefix))\n+        ReadWriteBufferFromHTTP::HTTPHeaderEntries header_entries;\n+        String url;\n+        String endpoint;\n+        String format;\n+\n+        auto named_collection = created_from_ddl\n+                            ? getURLBasedDataSourceConfiguration(config, settings_config_prefix, global_context)\n+                            : std::nullopt;\n+        if (named_collection)\n         {\n-            credentials.setUsername(config.getString(credentials_prefix + \".user\", \"\"));\n-            credentials.setPassword(config.getString(credentials_prefix + \".password\", \"\"));\n-        }\n+            url = named_collection->configuration.url;\n+            endpoint = named_collection->configuration.endpoint;\n+            format = named_collection->configuration.format;\n \n-        const auto & headers_prefix = settings_config_prefix + \".headers\";\n-        ReadWriteBufferFromHTTP::HTTPHeaderEntries header_entries;\n+            credentials.setUsername(named_collection->configuration.user);\n+            credentials.setPassword(named_collection->configuration.password);\n \n-        if (config.has(headers_prefix))\n+            header_entries.reserve(named_collection->configuration.headers.size());\n+            for (const auto & header : named_collection->configuration.headers)\n+                header_entries.emplace_back(std::make_tuple(header.first, header.second.get<String>()));\n+        }\n+        else\n         {\n-            Poco::Util::AbstractConfiguration::Keys config_keys;\n-            config.keys(headers_prefix, config_keys);\n+            const auto & credentials_prefix = settings_config_prefix + \".credentials\";\n \n-            header_entries.reserve(config_keys.size());\n-            for (const auto & key : config_keys)\n+            if (config.has(credentials_prefix))\n             {\n-                const auto header_key = config.getString(headers_prefix + \".\" + key + \".name\", \"\");\n-                const auto header_value = config.getString(headers_prefix + \".\" + key + \".value\", \"\");\n-                header_entries.emplace_back(std::make_tuple(header_key, header_value));\n+                credentials.setUsername(config.getString(credentials_prefix + \".user\", \"\"));\n+                credentials.setPassword(config.getString(credentials_prefix + \".password\", \"\"));\n             }\n+\n+            const auto & headers_prefix = settings_config_prefix + \".headers\";\n+\n+\n+            if (config.has(headers_prefix))\n+            {\n+                Poco::Util::AbstractConfiguration::Keys config_keys;\n+                config.keys(headers_prefix, config_keys);\n+\n+                header_entries.reserve(config_keys.size());\n+                for (const auto & key : config_keys)\n+                {\n+                    const auto header_key = config.getString(headers_prefix + \".\" + key + \".name\", \"\");\n+                    const auto header_value = config.getString(headers_prefix + \".\" + key + \".value\", \"\");\n+                    header_entries.emplace_back(std::make_tuple(header_key, header_value));\n+                }\n+            }\n+\n+            url = config.getString(settings_config_prefix + \".url\", \"\");\n+            endpoint = config.getString(settings_config_prefix + \".endpoint\", \"\");\n+            format =config.getString(settings_config_prefix + \".format\", \"\");\n         }\n \n+        if (url.ends_with('/'))\n+        {\n+            if (endpoint.starts_with('/'))\n+                url.pop_back();\n+        }\n+        else if (!endpoint.empty() && !endpoint.starts_with('/'))\n+            url.push_back('/');\n+\n         auto configuration = HTTPDictionarySource::Configuration\n         {\n-            .url = config.getString(settings_config_prefix + \".url\", \"\"),\n-            .format =config.getString(settings_config_prefix + \".format\", \"\"),\n+            .url = url + endpoint,\n+            .format = format,\n             .update_field = config.getString(settings_config_prefix + \".update_field\", \"\"),\n             .update_lag = config.getUInt64(settings_config_prefix + \".update_lag\", 1),\n             .header_entries = std::move(header_entries) //-V1030\n         };\n \n+        auto context = copyContextAndApplySettingsFromDictionaryConfig(global_context, config, config_prefix);\n+\n         return std::make_unique<HTTPDictionarySource>(dict_struct, configuration, credentials, sample_block, context, created_from_ddl);\n     };\n     factory.registerSource(\"http\", create_table_source);\ndiff --git a/src/Storages/ExternalDataSourceConfiguration.cpp b/src/Storages/ExternalDataSourceConfiguration.cpp\nindex abd20e6e5fdb..f916ac8c2af0 100644\n--- a/src/Storages/ExternalDataSourceConfiguration.cpp\n+++ b/src/Storages/ExternalDataSourceConfiguration.cpp\n@@ -248,6 +248,65 @@ std::optional<ExternalDataSourceInfo> getExternalDataSourceConfiguration(\n     return std::nullopt;\n }\n \n+std::optional<URLBasedDataSourceConfig> getURLBasedDataSourceConfiguration(\n+    const Poco::Util::AbstractConfiguration & dict_config, const String & dict_config_prefix, ContextPtr context)\n+{\n+    URLBasedDataSourceConfiguration configuration;\n+    auto collection_name = dict_config.getString(dict_config_prefix + \".name\", \"\");\n+    if (!collection_name.empty())\n+    {\n+        const auto & config = context->getConfigRef();\n+        const auto & collection_prefix = fmt::format(\"named_collections.{}\", collection_name);\n+\n+        if (!config.has(collection_prefix))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"There is no collection named `{}` in config\", collection_name);\n+\n+        configuration.url =\n+            dict_config.getString(dict_config_prefix + \".url\", config.getString(collection_prefix + \".url\", \"\"));\n+        configuration.endpoint =\n+            dict_config.getString(dict_config_prefix + \".endpoint\", config.getString(collection_prefix + \".endpoint\", \"\"));\n+        configuration.format =\n+            dict_config.getString(dict_config_prefix + \".format\", config.getString(collection_prefix + \".format\", \"\"));\n+        configuration.compression_method =\n+            dict_config.getString(dict_config_prefix + \".compression\", config.getString(collection_prefix + \".compression_method\", \"\"));\n+        configuration.structure =\n+            dict_config.getString(dict_config_prefix + \".structure\", config.getString(collection_prefix + \".structure\", \"\"));\n+        configuration.user =\n+            dict_config.getString(dict_config_prefix + \".credentials.user\", config.getString(collection_prefix + \".credentials.user\", \"\"));\n+        configuration.password =\n+            dict_config.getString(dict_config_prefix + \".credentials.password\", config.getString(collection_prefix + \".credentials.password\", \"\"));\n+\n+        String headers_prefix;\n+        const Poco::Util::AbstractConfiguration *headers_config = nullptr;\n+        if (dict_config.has(dict_config_prefix + \".headers\"))\n+        {\n+            headers_prefix = dict_config_prefix + \".headers\";\n+            headers_config = &dict_config;\n+        }\n+        else\n+        {\n+            headers_prefix = collection_prefix + \".headers\";\n+            headers_config = &config;\n+        }\n+\n+        if (headers_config)\n+        {\n+            Poco::Util::AbstractConfiguration::Keys header_keys;\n+            headers_config->keys(headers_prefix, header_keys);\n+            headers_prefix += \".\";\n+            for (const auto & header : header_keys)\n+            {\n+                const auto header_prefix = headers_prefix + header;\n+                configuration.headers.emplace_back(\n+                    std::make_pair(headers_config->getString(header_prefix + \".name\"), headers_config->getString(header_prefix + \".value\")));\n+            }\n+        }\n+\n+        return URLBasedDataSourceConfig{ .configuration = configuration };\n+    }\n+\n+    return std::nullopt;\n+}\n \n ExternalDataSourcesByPriority getExternalDataSourceConfigurationByPriority(\n     const Poco::Util::AbstractConfiguration & dict_config, const String & dict_config_prefix, ContextPtr context, HasConfigKeyFunc has_config_key)\ndiff --git a/src/Storages/ExternalDataSourceConfiguration.h b/src/Storages/ExternalDataSourceConfiguration.h\nindex dfac101e22d1..4ed46e1b26c0 100644\n--- a/src/Storages/ExternalDataSourceConfiguration.h\n+++ b/src/Storages/ExternalDataSourceConfiguration.h\n@@ -99,10 +99,14 @@ getExternalDataSourceConfigurationByPriority(const Poco::Util::AbstractConfigura\n struct URLBasedDataSourceConfiguration\n {\n     String url;\n+    String endpoint;\n     String format = \"auto\";\n     String compression_method = \"auto\";\n     String structure = \"auto\";\n \n+    String user;\n+    String password;\n+\n     std::vector<std::pair<String, Field>> headers;\n     String http_method;\n \n@@ -129,6 +133,9 @@ struct URLBasedDataSourceConfig\n \n std::optional<URLBasedDataSourceConfig> getURLBasedDataSourceConfiguration(const ASTs & args, ContextPtr context);\n \n+std::optional<URLBasedDataSourceConfig> getURLBasedDataSourceConfiguration(\n+    const Poco::Util::AbstractConfiguration & dict_config, const String & dict_config_prefix, ContextPtr context);\n+\n template<typename T>\n bool getExternalDataSourceConfiguration(const ASTs & args, BaseSettings<T> & settings, ContextPtr context);\n \n",
  "test_patch": "diff --git a/tests/integration/test_storage_dict/__init__.py b/tests/integration/test_storage_dict/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_storage_dict/configs/conf.xml b/tests/integration/test_storage_dict/configs/conf.xml\nnew file mode 100644\nindex 000000000000..e37ca358e634\n--- /dev/null\n+++ b/tests/integration/test_storage_dict/configs/conf.xml\n@@ -0,0 +1,25 @@\n+<?xml version=\"1.0\"?>\n+<clickhouse>\n+    <named_collections>\n+        <urldb>\n+            <url>http://nginx:80/test_dict</url>\n+            <method>PUT</method>\n+            <format>TSV</format>\n+            <structure>k String, v String</structure>\n+        </urldb>\n+        <urldict>\n+            <url>http://nginx:80/</url>\n+            <endpoint>/test_dict</endpoint>\n+            <format>TabSeparated</format>\n+        </urldict>\n+        <urldict1>\n+            <url>http://nginx:80/</url>\n+            <endpoint>/test_dict</endpoint>\n+        </urldict1>\n+        <urldict2>\n+            <url>http://nginx:80/</url>\n+            <endpoint>/test_dict</endpoint>\n+            <format>CSV</format>\n+        </urldict2>\n+    </named_collections>\n+</clickhouse>\ndiff --git a/tests/integration/test_storage_dict/test.py b/tests/integration/test_storage_dict/test.py\nnew file mode 100644\nindex 000000000000..1ed974f267d7\n--- /dev/null\n+++ b/tests/integration/test_storage_dict/test.py\n@@ -0,0 +1,46 @@\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+\n+uuids = []\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def cluster():\n+    try:\n+        cluster = ClickHouseCluster(__file__)\n+        cluster.add_instance(\n+            \"node1\", main_configs=[\"configs/conf.xml\"], with_nginx=True\n+        )\n+        cluster.start()\n+\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_storage_dict(cluster):\n+    node1 = cluster.instances[\"node1\"]\n+\n+    node1.query(f\"insert into table function url(urldb) values ('foo', 'bar')\")\n+    result = node1.query(f\"select * from url(urldb)\")\n+    assert result.strip() == \"foo\\tbar\"\n+\n+    node1.query(\n+        f\"create dictionary dict (k String, v String) primary key k source(http(name urldict)) layout(complex_key_hashed()) lifetime(min 0 max 100)\"\n+    )\n+    result = node1.query(f\"select * from dict\")\n+    assert result.strip() == \"foo\\tbar\"\n+\n+    node1.query(\n+        f\"create dictionary dict1 (k String, v String) primary key k source(http(name urldict1 format TabSeparated)) layout(complex_key_hashed()) lifetime(min 0 max 100)\"\n+    )\n+    result = node1.query(f\"select * from dict1\")\n+    assert result.strip() == \"foo\\tbar\"\n+\n+    node1.query(\n+        f\"create dictionary dict2 (k String, v String) primary key k source(http(name urldict2 format TabSeparated)) layout(complex_key_hashed()) lifetime(min 0 max 100)\"\n+    )\n+    result = node1.query(f\"select * from dict2\")\n+    assert result.strip() == \"foo\\tbar\"\n",
  "problem_statement": "Add support for HTTP source for Data Dictionaries in Named Collections\n**Use case**\r\n\r\nFor creating external data dictionary with settings (url, headers, etc.) from config.xml `<named_collections>`  for HTTP sources.\r\nThis is to allow updating per environment test, staging, prod without updating `CREATE DICTIONARY` statement, values set externally.\r\n\r\n**Describe the solution you'd like**\r\n\r\nAdd HTTP source options as currently available for PostgreSQL, MySQL, S3 and Kafka:\r\nhttps://clickhouse.com/docs/en/operations/named-collections/\r\nkeys should be `url`, `user`,`password`, `headers`.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nuse different data source for named collections.\r\nuse custom settings.\r\n\r\ncc: @kssenii \r\n\n",
  "hints_text": "Perfect, thank you :)\r\nOne comment / suggestion: would be nice if externalized url key is treated as base url, and can be reused for different endpoints of same source, smth like '{url}/my-service/some-dictionary',  '{url}/my-service/another-dictionary'",
  "created_at": "2022-05-27T00:52:09Z",
  "modified_files": [
    "src/Dictionaries/HTTPDictionarySource.cpp",
    "src/Storages/ExternalDataSourceConfiguration.cpp",
    "src/Storages/ExternalDataSourceConfiguration.h"
  ],
  "modified_test_files": [
    "b/tests/integration/test_storage_dict/configs/conf.xml",
    "b/tests/integration/test_storage_dict/test.py"
  ]
}