{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63186,
  "instance_id": "ClickHouse__ClickHouse-63186",
  "issue_numbers": [
    "66194"
  ],
  "base_commit": "2ff09bdf18b344885aae7355c36f1a9cea765b40",
  "patch": "diff --git a/docs/en/operations/settings/merge-tree-settings.md b/docs/en/operations/settings/merge-tree-settings.md\nindex 22c8c704ba26..7278b91f90da 100644\n--- a/docs/en/operations/settings/merge-tree-settings.md\n+++ b/docs/en/operations/settings/merge-tree-settings.md\n@@ -1030,7 +1030,7 @@ A table with no primary key represents the extreme case of a single equivalence\n \n The fewer and the larger the equivalence classes are, the higher the degree of freedom when re-shuffling rows.\n \n-The heuristics applied to find the best row order within each equivalence class is suggested by D. Lemir, O. Kaser in [Reordering columns for smaller indexes](https://doi.org/10.1016/j.ins.2011.02.002) and based on sorting the rows within each equivalence class by ascending cardinality of the non-primary key columns.\n+The heuristics applied to find the best row order within each equivalence class is suggested by D. Lemire, O. Kaser in [Reordering columns for smaller indexes](https://doi.org/10.1016/j.ins.2011.02.002) and based on sorting the rows within each equivalence class by ascending cardinality of the non-primary key columns.\n It performs three steps:\n 1. Find all equivalence classes based on the row values in primary key columns.\n 2. For each equivalence class, calculate (usually estimate) the cardinalities of the non-primary-key columns.\ndiff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 46b1167fa33c..4f5e5a5d716a 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -2698,6 +2698,204 @@ Like function `YYYYMMDDhhmmssToDate()` but produces a [DateTime64](../data-types\n \n Accepts an additional, optional `precision` parameter after the `timezone` parameter.\n \n+## changeYear\n+\n+Changes the year component of a date or date time.\n+\n+**Syntax**\n+``` sql\n+\n+changeYear(date_or_datetime, value)\n+```\n+\n+**Arguments**\n+\n+- `date_or_datetime` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a new value of the year. [Integer](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+- The same type as `date_or_datetime`.\n+\n+**Example**\n+\n+``` sql\n+SELECT changeYear(toDate('1999-01-01'), 2000), changeYear(toDateTime64('1999-01-01 00:00:00.000', 3), 2000);\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500changeYear(toDate('1999-01-01'), 2000)\u2500\u252c\u2500changeYear(toDateTime64('1999-01-01 00:00:00.000', 3), 2000)\u2500\u2510\n+\u2502                             2000-01-01 \u2502                                      2000-01-01 00:00:00.000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## changeMonth\n+\n+Changes the month component of a date or date time.\n+\n+**Syntax**\n+\n+``` sql\n+changeMonth(date_or_datetime, value)\n+```\n+\n+**Arguments**\n+\n+- `date_or_datetime` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a new value of the month. [Integer](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+- Returns a value of same type as `date_or_datetime`.\n+\n+**Example**\n+\n+``` sql\n+SELECT changeMonth(toDate('1999-01-01'), 2), changeMonth(toDateTime64('1999-01-01 00:00:00.000', 3), 2);\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500changeMonth(toDate('1999-01-01'), 2)\u2500\u252c\u2500changeMonth(toDateTime64('1999-01-01 00:00:00.000', 3), 2)\u2500\u2510\n+\u2502                           1999-02-01 \u2502                                    1999-02-01 00:00:00.000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## changeDay\n+\n+Changes the day component of a date or date time.\n+\n+**Syntax**\n+\n+``` sql\n+changeDay(date_or_datetime, value)\n+```\n+\n+**Arguments**\n+\n+- `date_or_datetime` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a new value of the day. [Integer](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+- Returns a value of same type as `date_or_datetime`.\n+\n+**Example**\n+\n+``` sql\n+SELECT changeDay(toDate('1999-01-01'), 5), changeDay(toDateTime64('1999-01-01 00:00:00.000', 3), 5);\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500changeDay(toDate('1999-01-01'), 5)\u2500\u252c\u2500changeDay(toDateTime64('1999-01-01 00:00:00.000', 3), 5)\u2500\u2510\n+\u2502                         1999-01-05 \u2502                                  1999-01-05 00:00:00.000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## changeHour\n+\n+Changes the hour component of a date or date time.\n+\n+**Syntax**\n+\n+``` sql\n+changeHour(date_or_datetime, value)\n+```\n+\n+**Arguments**\n+\n+- `date_or_datetime` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a new value of the hour. [Integer](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+- Returns a value of same type as `date_or_datetime`. If the input is a [Date](../data-types/date.md), return [DateTime](../data-types/datetime.md). If the input is a [Date32](../data-types/date32.md), return [DateTime64](../data-types/datetime64.md).\n+\n+**Example**\n+\n+``` sql\n+SELECT changeHour(toDate('1999-01-01'), 14), changeHour(toDateTime64('1999-01-01 00:00:00.000', 3), 14);\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500changeHour(toDate('1999-01-01'), 14)\u2500\u252c\u2500changeHour(toDateTime64('1999-01-01 00:00:00.000', 3), 14)\u2500\u2510\n+\u2502                  1999-01-01 14:00:00 \u2502                                    1999-01-01 14:00:00.000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## changeMinute\n+\n+Changes the minute component of a date or date time.\n+\n+**Syntax**\n+\n+``` sql\n+changeMinute(date_or_datetime, value)\n+```\n+\n+**Arguments**\n+\n+- `date_or_datetime` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a new value of the minute. [Integer](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+- Returns a value of same type as `date_or_datetime`. If the input is a [Date](../data-types/date.md), return [DateTime](../data-types/datetime.md). If the input is a [Date32](../data-types/date32.md), return [DateTime64](../data-types/datetime64.md).\n+\n+**Example**\n+\n+``` sql\n+    SELECT changeMinute(toDate('1999-01-01'), 15), changeMinute(toDateTime64('1999-01-01 00:00:00.000', 3), 15);\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500changeMinute(toDate('1999-01-01'), 15)\u2500\u252c\u2500changeMinute(toDateTime64('1999-01-01 00:00:00.000', 3), 15)\u2500\u2510\n+\u2502                    1999-01-01 00:15:00 \u2502                                      1999-01-01 00:15:00.000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## changeSecond\n+\n+Changes the second component of a date or date time.\n+\n+**Syntax**\n+\n+``` sql\n+changeSecond(date_or_datetime, value)\n+```\n+\n+**Arguments**\n+\n+- `date_or_datetime` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a new value of the second. [Integer](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+- Returns a value of same type as `date_or_datetime`. If the input is a [Date](../data-types/date.md), return [DateTime](../data-types/datetime.md). If the input is a [Date32](../data-types/date32.md), return [DateTime64](../data-types/datetime64.md).\n+\n+**Example**\n+\n+``` sql\n+SELECT changeSecond(toDate('1999-01-01'), 15), changeSecond(toDateTime64('1999-01-01 00:00:00.000', 3), 15);\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500changeSecond(toDate('1999-01-01'), 15)\u2500\u252c\u2500changeSecond(toDateTime64('1999-01-01 00:00:00.000', 3), 15)\u2500\u2510\n+\u2502                    1999-01-01 00:00:15 \u2502                                      1999-01-01 00:00:15.000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## addYears\n \n Adds a specified number of years to a date, a date with time or a string-encoded date / date with time.\n@@ -2714,6 +2912,7 @@ addYears(date, num)\n - `num`: Number of years to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` years. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2751,6 +2950,7 @@ addQuarters(date, num)\n - `num`: Number of quarters to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` quarters. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2788,6 +2988,7 @@ addMonths(date, num)\n - `num`: Number of months to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` months. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2825,6 +3026,7 @@ addWeeks(date, num)\n - `num`: Number of weeks to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` weeks. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2862,6 +3064,7 @@ addDays(date, num)\n - `num`: Number of days to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` days. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2899,6 +3102,7 @@ addHours(date, num)\n - `num`: Number of hours to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+o\n - Returns `date` plus `num` hours. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2936,6 +3140,7 @@ addMinutes(date, num)\n - `num`: Number of minutes to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` minutes. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -2973,6 +3178,7 @@ addSeconds(date, num)\n - `num`: Number of seconds to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` plus `num` seconds. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3010,6 +3216,7 @@ addMilliseconds(date_time, num)\n - `num`: Number of milliseconds to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date_time` plus `num` milliseconds. [DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3045,6 +3252,7 @@ addMicroseconds(date_time, num)\n - `num`: Number of microseconds to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date_time` plus `num` microseconds. [DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3080,6 +3288,7 @@ addNanoseconds(date_time, num)\n - `num`: Number of nanoseconds to add. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date_time` plus `num` nanoseconds. [DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3115,6 +3324,7 @@ addInterval(interval_1, interval_2)\n - `interval_2`: Second interval to be added. [interval](../data-types/special-data-types/interval.md).\n \n **Returned value**\n+\n - Returns a tuple of intervals. [tuple](../data-types/tuple.md)([interval](../data-types/special-data-types/interval.md)).\n \n :::note\n@@ -3161,6 +3371,7 @@ addTupleOfIntervals(interval_1, interval_2)\n - `intervals`: Tuple of intervals to add to `date`. [tuple](../data-types/tuple.md)([interval](../data-types/special-data-types/interval.md)).\n \n **Returned value**\n+\n - Returns `date` with added `intervals`. [date](../data-types/date.md)/[date32](../data-types/date32.md)/[datetime](../data-types/datetime.md)/[datetime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3195,6 +3406,7 @@ subtractYears(date, num)\n - `num`: Number of years to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` years. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3232,6 +3444,7 @@ subtractQuarters(date, num)\n - `num`: Number of quarters to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` quarters. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3269,6 +3482,7 @@ subtractMonths(date, num)\n - `num`: Number of months to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` months. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3306,6 +3520,7 @@ subtractWeeks(date, num)\n - `num`: Number of weeks to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` weeks. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3343,6 +3558,7 @@ subtractDays(date, num)\n - `num`: Number of days to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` days. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3380,6 +3596,7 @@ subtractHours(date, num)\n - `num`: Number of hours to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` hours. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[Datetime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3417,6 +3634,7 @@ subtractMinutes(date, num)\n - `num`: Number of minutes to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` minutes. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3454,6 +3672,7 @@ subtractSeconds(date, num)\n - `num`: Number of seconds to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date` minus `num` seconds. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3491,6 +3710,7 @@ subtractMilliseconds(date_time, num)\n - `num`: Number of milliseconds to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date_time` minus `num` milliseconds. [DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3526,6 +3746,7 @@ subtractMicroseconds(date_time, num)\n - `num`: Number of microseconds to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date_time` minus `num` microseconds. [DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3561,6 +3782,7 @@ subtractNanoseconds(date_time, num)\n - `num`: Number of nanoseconds to subtract. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n \n **Returned value**\n+\n - Returns `date_time` minus `num` nanoseconds. [DateTime64](../data-types/datetime64.md).\n \n **Example**\n@@ -3596,6 +3818,7 @@ subtractInterval(interval_1, interval_2)\n - `interval_2`: Second interval to be negated. [interval](../data-types/special-data-types/interval.md).\n \n **Returned value**\n+\n - Returns a tuple of intervals. [tuple](../data-types/tuple.md)([interval](../data-types/special-data-types/interval.md)).\n \n :::note\n@@ -3642,6 +3865,7 @@ subtractTupleOfIntervals(interval_1, interval_2)\n - `intervals`: Tuple of intervals to subtract from `date`. [tuple](../data-types/tuple.md)([interval](../data-types/special-data-types/interval.md)).\n \n **Returned value**\n+\n - Returns `date` with subtracted `intervals`. [Date](../data-types/date.md)/[Date32](../data-types/date32.md)/[DateTime](../data-types/datetime.md)/[DateTime64](../data-types/datetime64.md).\n \n **Example**\ndiff --git a/src/Functions/changeDate.cpp b/src/Functions/changeDate.cpp\nnew file mode 100644\nindex 000000000000..19e4c165ee37\n--- /dev/null\n+++ b/src/Functions/changeDate.cpp\n@@ -0,0 +1,399 @@\n+#include \"Common/DateLUTImpl.h\"\n+#include \"Common/Exception.h\"\n+#include <Columns/ColumnDecimal.h>\n+#include <Columns/ColumnsDateTime.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/IColumn.h>\n+#include <Common/DateLUT.h>\n+#include <Common/typeid_cast.h>\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/IDataType.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <Interpreters/castColumn.h>\n+\n+#include <memory>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+namespace\n+{\n+\n+enum class Component\n+{\n+    Year,\n+    Month,\n+    Day,\n+    Hour,\n+    Minute,\n+    Second\n+};\n+\n+}\n+\n+template <typename Traits>\n+class FunctionChangeDate : public IFunction\n+{\n+public:\n+    static constexpr auto name = Traits::name;\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionChangeDate>(); }\n+    String getName() const override { return Traits::name; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return 2; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args{\n+            {\"date_or_datetime\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isDateOrDate32OrDateTimeOrDateTime64), nullptr, \"Date or date with time\"},\n+            {\"value\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isNativeInteger), nullptr, \"Integer\"}\n+        };\n+        validateFunctionArguments(*this, arguments, args);\n+\n+        const auto & input_type = arguments[0].type;\n+\n+        if constexpr (Traits::component == Component::Hour || Traits::component == Component::Minute || Traits::component == Component::Second)\n+        {\n+            if (isDate(input_type))\n+                return std::make_shared<DataTypeDateTime>();\n+            if (isDate32(input_type))\n+                return std::make_shared<DataTypeDateTime64>(DataTypeDateTime64::default_scale);\n+        }\n+\n+        return input_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        const auto & input_type = arguments[0].type;\n+        if (isDate(input_type))\n+        {\n+            if constexpr (Traits::component == Component::Hour || Traits::component == Component::Minute || Traits::component == Component::Second)\n+                return execute<DataTypeDate, DataTypeDateTime>(arguments, input_type, result_type, input_rows_count);\n+            return execute<DataTypeDate, DataTypeDate>(arguments, input_type, result_type, input_rows_count);\n+        }\n+        if (isDate32(input_type))\n+        {\n+            if constexpr (Traits::component == Component::Hour || Traits::component == Component::Minute || Traits::component == Component::Second)\n+                return execute<DataTypeDate32, DataTypeDateTime64>(arguments, input_type, result_type, input_rows_count);\n+            return execute<DataTypeDate32, DataTypeDate32>(arguments, input_type, result_type, input_rows_count);\n+        }\n+        if (isDateTime(input_type))\n+            return execute<DataTypeDateTime, DataTypeDateTime>(arguments, input_type, result_type, input_rows_count);\n+        if (isDateTime64(input_type))\n+            return execute<DataTypeDateTime64, DataTypeDateTime64>(arguments, input_type, result_type, input_rows_count);\n+\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid input type\");\n+    }\n+\n+    template <typename InputDataType, typename ResultDataType>\n+    ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & input_type, const DataTypePtr & result_type, size_t input_rows_count) const\n+    {\n+        typename ResultDataType::ColumnType::MutablePtr result_col;\n+        if constexpr (std::is_same_v<ResultDataType, DataTypeDateTime64>)\n+        {\n+            auto scale = DataTypeDateTime64::default_scale;\n+            if constexpr (std::is_same_v<InputDataType, DateTime64>)\n+                scale = typeid_cast<const DataTypeDateTime64 &>(*result_type).getScale();\n+            result_col = ResultDataType::ColumnType::create(input_rows_count, scale);\n+        }\n+        else\n+            result_col = ResultDataType::ColumnType::create(input_rows_count);\n+\n+        auto date_time_col = arguments[0].column->convertToFullIfNeeded();\n+        const auto & date_time_col_data = typeid_cast<const typename InputDataType::ColumnType &>(*date_time_col).getData();\n+\n+        auto value_col = castColumn(arguments[1], std::make_shared<DataTypeFloat64>());\n+        value_col = value_col->convertToFullIfNeeded();\n+        const auto & value_col_data = typeid_cast<const ColumnFloat64 &>(*value_col).getData();\n+\n+        auto & result_col_data = result_col->getData();\n+\n+        if constexpr (std::is_same_v<InputDataType, DataTypeDateTime64>)\n+        {\n+            const auto scale = typeid_cast<const DataTypeDateTime64 &>(*result_type).getScale();\n+            const auto & date_lut = typeid_cast<const DataTypeDateTime64 &>(*result_type).getTimeZone();\n+\n+            Int64 deg = 1;\n+            for (size_t j = 0; j < scale; ++j)\n+                deg *= 10;\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                Int64 time = date_lut.toNumYYYYMMDDhhmmss(date_time_col_data[i] / deg);\n+                Int64 fraction = date_time_col_data[i] % deg;\n+\n+                result_col_data[i] = getChangedDate(time, value_col_data[i], result_type, date_lut, scale, fraction);\n+            }\n+        }\n+        else if constexpr (std::is_same_v<InputDataType, DataTypeDate32> && std::is_same_v<ResultDataType, DataTypeDateTime64>)\n+        {\n+            const auto & date_lut = typeid_cast<const DataTypeDateTime64 &>(*result_type).getTimeZone();\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                Int64 time = static_cast<Int64>(date_lut.toNumYYYYMMDD(ExtendedDayNum(date_time_col_data[i]))) * 1'000'000;\n+                result_col_data[i] = getChangedDate(time, value_col_data[i], result_type, date_lut, 3, 0);\n+            }\n+        }\n+        else if constexpr (std::is_same_v<InputDataType, DataTypeDate> && std::is_same_v<ResultDataType, DataTypeDateTime>)\n+        {\n+            const auto & date_lut = typeid_cast<const DataTypeDateTime &>(*result_type).getTimeZone();\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                Int64 time = static_cast<Int64>(date_lut.toNumYYYYMMDD(ExtendedDayNum(date_time_col_data[i]))) * 1'000'000;\n+                result_col_data[i] = static_cast<UInt32>(getChangedDate(time, value_col_data[i], result_type, date_lut));\n+            }\n+        }\n+        else if constexpr (std::is_same_v<InputDataType, DataTypeDateTime>)\n+        {\n+            const auto & date_lut = typeid_cast<const DataTypeDateTime &>(*result_type).getTimeZone();\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                Int64 time = date_lut.toNumYYYYMMDDhhmmss(date_time_col_data[i]);\n+                result_col_data[i] = static_cast<UInt32>(getChangedDate(time, value_col_data[i], result_type, date_lut));\n+            }\n+        }\n+        else\n+        {\n+            const auto & date_lut = DateLUT::instance();\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                Int64 time;\n+                if (isDate(input_type))\n+                    time = static_cast<Int64>(date_lut.toNumYYYYMMDD(DayNum(date_time_col_data[i]))) * 1'000'000;\n+                else\n+                    time = static_cast<Int64>(date_lut.toNumYYYYMMDD(ExtendedDayNum(date_time_col_data[i]))) * 1'000'000;\n+\n+                if (isDate(result_type))\n+                    result_col_data[i] = static_cast<UInt16>(getChangedDate(time, value_col_data[i], result_type, date_lut));\n+                else\n+                    result_col_data[i] = static_cast<Int32>(getChangedDate(time, value_col_data[i], result_type, date_lut));\n+            }\n+        }\n+\n+        return result_col;\n+    }\n+\n+    Int64 getChangedDate(Int64 time, Float64 new_value, const DataTypePtr & result_type, const DateLUTImpl & date_lut, Int64 scale = 0, Int64 fraction = 0) const\n+    {\n+        auto year = time / 10'000'000'000;\n+        auto month = (time % 10'000'000'000) / 100'000'000;\n+        auto day = (time % 100'000'000) / 1'000'000;\n+        auto hours = (time % 1'000'000) / 10'000;\n+        auto minutes = (time % 10'000) / 100;\n+        auto seconds = time % 100;\n+\n+        Int64 min_date = 0, max_date = 0;\n+        Int16 min_year, max_year;\n+        if (isDate(result_type))\n+        {\n+            min_date = date_lut.makeDayNum(1970, 1, 1);\n+            max_date = date_lut.makeDayNum(2149, 6, 6);\n+            min_year = 1970;\n+            max_year = 2149;\n+        }\n+        else if (isDate32(result_type))\n+        {\n+            min_date = date_lut.makeDayNum(1900, 1, 1);\n+            max_date = date_lut.makeDayNum(2299, 12, 31);\n+            min_year = 1900;\n+            max_year = 2299;\n+        }\n+        else if (isDateTime(result_type))\n+        {\n+            min_date = 0;\n+            max_date = 0x0FFFFFFFFLL;\n+            min_year = 1970;\n+            max_year = 2106;\n+        }\n+        else\n+        {\n+            min_date = DecimalUtils::decimalFromComponents<DateTime64>(\n+                date_lut.makeDateTime(1900, 1, 1, 0, 0, 0),\n+                static_cast<Int64>(0),\n+                static_cast<UInt32>(scale));\n+            Int64 deg = 1;\n+            for (Int64 j = 0; j < scale; ++j)\n+                deg *= 10;\n+            max_date = DecimalUtils::decimalFromComponents<DateTime64>(\n+                date_lut.makeDateTime(2299, 12, 31, 23, 59, 59),\n+                static_cast<Int64>(deg - 1),\n+                static_cast<UInt32>(scale));\n+            min_year = 1900;\n+            max_year = 2299;\n+        }\n+\n+        switch (Traits::component)\n+        {\n+            case Component::Year:\n+                if (new_value < min_year)\n+                    return min_date;\n+                else if (new_value > max_year)\n+                    return max_date;\n+                year = static_cast<Int16>(new_value);\n+                break;\n+            case Component::Month:\n+                if (new_value < 1 || new_value > 12)\n+                    return min_date;\n+                month = static_cast<UInt8>(new_value);\n+                break;\n+            case Component::Day:\n+                if (new_value < 1 || new_value > 31)\n+                    return min_date;\n+                day = static_cast<UInt8>(new_value);\n+                break;\n+            case Component::Hour:\n+                if (new_value < 0 || new_value > 23)\n+                    return min_date;\n+                hours = static_cast<UInt8>(new_value);\n+                break;\n+            case Component::Minute:\n+                if (new_value < 0 || new_value > 59)\n+                    return min_date;\n+                minutes = static_cast<UInt8>(new_value);\n+                break;\n+            case Component::Second:\n+                if (new_value < 0 || new_value > 59)\n+                    return min_date;\n+                seconds = static_cast<UInt8>(new_value);\n+                break;\n+        }\n+\n+        Int64 result;\n+        if (isDate(result_type) || isDate32(result_type))\n+            result = date_lut.makeDayNum(year, month, day);\n+        else if (isDateTime(result_type))\n+            result = date_lut.makeDateTime(year, month, day, hours, minutes, seconds);\n+        else\n+#ifndef __clang_analyzer__\n+            /// ^^ This looks funny. It is the least terrible suppression of a false positive reported by clang-analyzer (a sub-class\n+            /// of clang-tidy checks) deep down in 'decimalFromComponents'. Usual suppressions of the form NOLINT* don't work here (they\n+            /// would only affect code in _this_ file), and suppressing the issue in 'decimalFromComponents' may suppress true positives.\n+            result = DecimalUtils::decimalFromComponents<DateTime64>(\n+                date_lut.makeDateTime(year, month, day, hours, minutes, seconds),\n+                fraction,\n+                static_cast<UInt32>(scale));\n+#else\n+        {\n+            UNUSED(fraction);\n+            result = 0;\n+        }\n+#endif\n+\n+        if (result < min_date)\n+            return min_date;\n+\n+        if (result > max_date)\n+            return max_date;\n+\n+        return result;\n+    }\n+};\n+\n+\n+struct ChangeYearTraits\n+{\n+    static constexpr auto name = \"changeYear\";\n+    static constexpr auto component = Component::Year;\n+};\n+\n+struct ChangeMonthTraits\n+{\n+    static constexpr auto name = \"changeMonth\";\n+    static constexpr auto component = Component::Month;\n+};\n+\n+struct ChangeDayTraits\n+{\n+    static constexpr auto name = \"changeDay\";\n+    static constexpr auto component = Component::Day;\n+};\n+\n+struct ChangeHourTraits\n+{\n+    static constexpr auto name = \"changeHour\";\n+    static constexpr auto component = Component::Hour;\n+};\n+\n+struct ChangeMinuteTraits\n+{\n+    static constexpr auto name = \"changeMinute\";\n+    static constexpr auto component = Component::Minute;\n+};\n+\n+struct ChangeSecondTraits\n+{\n+    static constexpr auto name = \"changeSecond\";\n+    static constexpr auto component = Component::Second;\n+};\n+\n+REGISTER_FUNCTION(ChangeDate)\n+{\n+    {\n+        FunctionDocumentation::Description description = \"Changes the year component of a date or date time.\";\n+        FunctionDocumentation::Syntax syntax = \"changeYear(date_or_datetime, value);\";\n+        FunctionDocumentation::Arguments arguments = {{\"date_or_datetime\", \"The value to change. Type: Date, Date32, DateTime, or DateTime64\"}, {\"value\", \"The new value. Type: [U]Int*\"}};\n+        FunctionDocumentation::ReturnedValue returned_value = \"The same type as date_or_datetime.\";\n+        FunctionDocumentation::Categories categories = {\"Dates and Times\"};\n+        FunctionDocumentation function_documentation = {.description = description, .syntax = syntax, .arguments = arguments, .returned_value = returned_value, .categories = categories};\n+        factory.registerFunction<FunctionChangeDate<ChangeYearTraits>>(function_documentation);\n+    }\n+    {\n+        FunctionDocumentation::Description description = \"Changes the month component of a date or date time.\";\n+        FunctionDocumentation::Syntax syntax = \"changeMonth(date_or_datetime, value);\";\n+        FunctionDocumentation::Arguments arguments = {{\"date_or_datetime\", \"The value to change. Type: Date, Date32, DateTime, or DateTime64\"}, {\"value\", \"The new value. Type: [U]Int*\"}};\n+        FunctionDocumentation::ReturnedValue returned_value = \"The same type as date_or_datetime.\";\n+        FunctionDocumentation::Categories categories = {\"Dates and Times\"};\n+        FunctionDocumentation function_documentation = {.description = description, .syntax = syntax, .arguments = arguments, .returned_value = returned_value, .categories = categories};\n+        factory.registerFunction<FunctionChangeDate<ChangeMonthTraits>>(function_documentation);\n+    }\n+    {\n+        FunctionDocumentation::Description description = \"Changes the day component of a date or date time.\";\n+        FunctionDocumentation::Syntax syntax = \"changeDay(date_or_datetime, value);\";\n+        FunctionDocumentation::Arguments arguments = {{\"date_or_datetime\", \"The value to change. Type: Date, Date32, DateTime, or DateTime64\"}, {\"value\", \"The new value. Type: [U]Int*\"}};\n+        FunctionDocumentation::ReturnedValue returned_value = \"The same type as date_or_datetime.\";\n+        FunctionDocumentation::Categories categories = {\"Dates and Times\"};\n+        FunctionDocumentation function_documentation = {.description = description, .syntax = syntax, .arguments = arguments, .returned_value = returned_value, .categories = categories};\n+        factory.registerFunction<FunctionChangeDate<ChangeDayTraits>>(function_documentation);\n+    }\n+    {\n+        FunctionDocumentation::Description description = \"Changes the hour component of a date or date time.\";\n+        FunctionDocumentation::Syntax syntax = \"changeHour(date_or_datetime, value);\";\n+        FunctionDocumentation::Arguments arguments = {{\"date_or_datetime\", \"The value to change. Type: Date, Date32, DateTime, or DateTime64\"}, {\"value\", \"The new value. Type: [U]Int*\"}};\n+        FunctionDocumentation::ReturnedValue returned_value = \"The same type as date_or_datetime. If the input is a Date, return DateTime. If the input is a Date32, return DateTime64.\";\n+        FunctionDocumentation::Categories categories = {\"Dates and Times\"};\n+        FunctionDocumentation function_documentation = {.description = description, .syntax = syntax, .arguments = arguments, .returned_value = returned_value, .categories = categories};\n+        factory.registerFunction<FunctionChangeDate<ChangeHourTraits>>(function_documentation);\n+    }\n+    {\n+        FunctionDocumentation::Description description = \"Changes the minute component of a date or date time.\";\n+        FunctionDocumentation::Syntax syntax = \"changeMinute(date_or_datetime, value);\";\n+        FunctionDocumentation::Arguments arguments = {{\"date_or_datetime\", \"The value to change. Type: Date, Date32, DateTime, or DateTime64\"}, {\"value\", \"The new value. Type: [U]Int*\"}};\n+        FunctionDocumentation::ReturnedValue returned_value = \"The same type as date_or_datetime. If the input is a Date, return DateTime. If the input is a Date32, return DateTime64.\";\n+        FunctionDocumentation::Categories categories = {\"Dates and Times\"};\n+        FunctionDocumentation function_documentation = {.description = description, .syntax = syntax, .arguments = arguments, .returned_value = returned_value, .categories = categories};\n+        factory.registerFunction<FunctionChangeDate<ChangeMinuteTraits>>(function_documentation);\n+    }\n+    {\n+        FunctionDocumentation::Description description = \"Changes the second component of a date or date time.\";\n+        FunctionDocumentation::Syntax syntax = \"changeSecond(date_or_datetime, value);\";\n+        FunctionDocumentation::Arguments arguments = {{\"date_or_datetime\", \"The value to change. Type: Date, Date32, DateTime, or DateTime64\"}, {\"value\", \"The new value. Type: [U]Int*\"}};\n+        FunctionDocumentation::ReturnedValue returned_value = \"The same type as date_or_datetime. If the input is a Date, return DateTime. If the input is a Date32, return DateTime64.\";\n+        FunctionDocumentation::Categories categories = {\"Dates and Times\"};\n+        FunctionDocumentation function_documentation = {.description = description, .syntax = syntax, .arguments = arguments, .returned_value = returned_value, .categories = categories};\n+        factory.registerFunction<FunctionChangeDate<ChangeSecondTraits>>(function_documentation);\n+    }\n+}\n+\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex ca2c4ec41925..af3fe2b4f95f 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -467,7 +467,7 @@ LOCALTIME\n LOCALTIMESTAMP\n LONGLONG\n LOONGARCH\n-Lemir\n+Lemire\n Levenshtein\n Liao\n LibFuzzer\n@@ -1319,6 +1319,12 @@ cfg\n cgroup\n cgroups\n chadmin\n+changeDay\n+changeHour\n+changeMinute\n+changeMonth\n+changeSecond\n+changeYear\n changelog\n changelogs\n charset\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02982_changeDate.reference b/tests/queries/0_stateless/02982_changeDate.reference\nnew file mode 100644\nindex 000000000000..4a7f093ca2b3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02982_changeDate.reference\n@@ -0,0 +1,169 @@\n+Negative tests\n+changeYear\n+-- Date\n+2001-01-01\n+1970-01-01\n+1970-01-01\n+2149-06-06\n+-- Date32\n+2001-01-01\n+1900-01-01\n+1900-01-01\n+2299-12-31\n+-- DateTime\n+2001-01-01 11:22:33\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+2106-02-07 07:28:15\n+-- DateTime64\n+2001-01-01 11:22:33.4444\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+2299-12-31 23:59:59.9999\n+changeMonth\n+-- Date\n+2000-01-01\n+2000-02-01\n+2000-12-01\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+-- Date32\n+2000-01-01\n+2000-02-01\n+2000-12-01\n+1900-01-01\n+1900-01-01\n+1900-01-01\n+-- DateTime\n+2000-01-01 11:22:33\n+2000-02-01 11:22:33\n+2000-12-01 11:22:33\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- DateTime64\n+2000-01-01 11:22:33.4444\n+2000-02-01 11:22:33.4444\n+2000-12-01 11:22:33.4444\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+changeDay\n+-- Date\n+2000-01-01\n+2000-01-02\n+2000-01-31\n+1970-01-01\n+1970-01-01\n+1970-01-01\n+-- Date32\n+2000-01-01\n+2000-01-02\n+2000-01-31\n+1900-01-01\n+1900-01-01\n+1900-01-01\n+-- DateTime\n+2000-01-01 11:22:33\n+2000-01-02 11:22:33\n+2000-01-31 11:22:33\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- DateTime64\n+2000-01-01 11:22:33.4444\n+2000-01-02 11:22:33.4444\n+2000-01-31 11:22:33.4444\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+-- Special case: change to 29 Feb in a leap year\n+2000-02-29\n+2000-02-29\n+2000-02-29 11:22:33\n+2000-02-29 11:22:33.4444\n+changeHour\n+-- Date\n+2000-01-01 00:00:00\n+2000-01-01 02:00:00\n+2000-01-01 23:00:00\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- Date32\n+2000-01-01 00:00:00.000\n+2000-01-01 02:00:00.000\n+2000-01-01 23:00:00.000\n+1900-01-01 00:00:00.000\n+1900-01-01 00:00:00.000\n+-- DateTime\n+2000-01-01 00:22:33\n+2000-01-01 02:22:33\n+2000-01-01 23:22:33\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- DateTime64\n+2000-01-01 00:22:33.4444\n+2000-01-01 02:22:33.4444\n+2000-01-01 23:22:33.4444\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+-- With different timezone\n+1970-01-01 07:00:00\n+1970-01-01 07:00:00\n+changeMinute\n+-- Date\n+2000-01-01 00:00:00\n+2000-01-01 00:02:00\n+2000-01-01 00:59:00\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- Date32\n+2000-01-01 00:00:00.000\n+2000-01-01 00:02:00.000\n+2000-01-01 00:59:00.000\n+1900-01-01 00:00:00.000\n+1900-01-01 00:00:00.000\n+-- DateTime\n+2000-01-01 11:00:33\n+2000-01-01 11:02:33\n+2000-01-01 11:59:33\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- DateTime64\n+2000-01-01 11:00:33.4444\n+2000-01-01 11:02:33.4444\n+2000-01-01 11:59:33.4444\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+-- With different timezone\n+1970-01-01 07:00:00\n+1970-01-01 07:00:00\n+changeSecond\n+-- Date\n+2000-01-01 00:00:00\n+2000-01-01 00:00:02\n+2000-01-01 00:00:59\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- Date32\n+2000-01-01 00:00:00.000\n+2000-01-01 00:00:02.000\n+2000-01-01 00:00:59.000\n+1900-01-01 00:00:00.000\n+1900-01-01 00:00:00.000\n+-- DateTime\n+2000-01-01 11:22:00\n+2000-01-01 11:22:02\n+2000-01-01 11:22:59\n+1970-01-01 01:00:00\n+1970-01-01 01:00:00\n+-- DateTime64\n+2000-01-01 11:22:00.4444\n+2000-01-01 11:22:02.4444\n+2000-01-01 11:22:59.4444\n+1900-01-01 00:00:00.0000\n+1900-01-01 00:00:00.0000\n+-- With different timezone\n+1970-01-01 07:00:00\n+1970-01-01 07:00:00\ndiff --git a/tests/queries/0_stateless/02982_changeDate.sql b/tests/queries/0_stateless/02982_changeDate.sql\nnew file mode 100644\nindex 000000000000..2bc9aa955699\n--- /dev/null\n+++ b/tests/queries/0_stateless/02982_changeDate.sql\n@@ -0,0 +1,185 @@\n+SELECT 'Negative tests';\n+-- as changeYear, changeMonth, changeDay, changeMinute, changeSecond share the same implementation, just testing one of them\n+SELECT changeYear(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT changeYear(toDate('2000-01-01')); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT changeYear(toDate('2000-01-01'), 2000, 1); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT changeYear(1999, 2000); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT changeYear(toDate('2000-01-01'), 'abc'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT changeYear(toDate('2000-01-01'), 1.5); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+-- Disable timezone randomization\n+SET session_timezone='CET';\n+\n+SELECT 'changeYear';\n+SELECT '-- Date';\n+SELECT changeYear(toDate('2000-01-01'), 2001);\n+SELECT changeYear(toDate('2000-01-01'), 1800); -- out-of-bounds\n+SELECT changeYear(toDate('2000-01-01'), -5000); -- out-of-bounds\n+SELECT changeYear(toDate('2000-01-01'), 2500); -- out-of-bounds\n+SELECT '-- Date32';\n+SELECT changeYear(toDate32('2000-01-01'), 2001);\n+SELECT changeYear(toDate32('2000-01-01'), 1800); -- out-of-bounds\n+SELECT changeYear(toDate32('2000-01-01'), -5000); -- out-of-bounds\n+SELECT changeYear(toDate32('2000-01-01'), 2500); -- out-of-bounds\n+SELECT '-- DateTime';\n+SELECT changeYear(toDateTime('2000-01-01 11:22:33'), 2001);\n+SELECT changeYear(toDateTime('2000-01-01 11:22:33'), 1800); -- out-of-bounds\n+SELECT changeYear(toDateTime('2000-01-01 11:22:33'), -5000); -- out-of-bounds\n+SELECT changeYear(toDateTime('2000-01-01 11:22:33'), 2500); -- out-of-bounds\n+SELECT '-- DateTime64';\n+SELECT changeYear(toDateTime64('2000-01-01 11:22:33.4444', 4), 2001);\n+SELECT changeYear(toDateTime64('2000-01-01 11:22:33.4444', 4), 1800); -- out-of-bounds\n+SELECT changeYear(toDateTime64('2000-01-01 11:22:33.4444', 4), -5000); -- out-of-bounds\n+SELECT changeYear(toDateTime64('2000-01-01 11:22:33.4444', 4), 2500); -- out-of-bounds\n+\n+SELECT 'changeMonth';\n+SELECT '-- Date';\n+SELECT changeMonth(toDate('2000-01-01'), 1);\n+SELECT changeMonth(toDate('2000-01-01'), 2);\n+SELECT changeMonth(toDate('2000-01-01'), 12);\n+SELECT changeMonth(toDate('2000-01-01'), 0); -- out-of-bounds\n+SELECT changeMonth(toDate('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeMonth(toDate('2000-01-01'), 13); -- out-of-bounds\n+SELECT '-- Date32';\n+SELECT changeMonth(toDate32('2000-01-01'), 1);\n+SELECT changeMonth(toDate32('2000-01-01'), 2);\n+SELECT changeMonth(toDate32('2000-01-01'), 12);\n+SELECT changeMonth(toDate32('2000-01-01'), 0); -- out-of-bounds\n+SELECT changeMonth(toDate32('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeMonth(toDate32('2000-01-01'), 13); -- out-of-bounds\n+SELECT '-- DateTime';\n+SELECT changeMonth(toDateTime('2000-01-01 11:22:33'), 1);\n+SELECT changeMonth(toDateTime('2000-01-01 11:22:33'), 2);\n+SELECT changeMonth(toDateTime('2000-01-01 11:22:33'), 12);\n+SELECT changeMonth(toDateTime('2000-01-01 11:22:33'), 0); -- out-of-bounds\n+SELECT changeMonth(toDateTime('2000-01-01 11:22:33'), -1); -- out-of-bounds\n+SELECT changeMonth(toDateTime('2000-01-01 11:22:33'), 13); -- out-of-bounds\n+SELECT '-- DateTime64';\n+SELECT changeMonth(toDateTime64('2000-01-01 11:22:33.4444', 4), 1);\n+SELECT changeMonth(toDateTime64('2000-01-01 11:22:33.4444', 4), 2);\n+SELECT changeMonth(toDateTime64('2000-01-01 11:22:33.4444', 4), 12);\n+SELECT changeMonth(toDateTime64('2000-01-01 11:22:33.4444', 4), 0); -- out-of-bounds\n+SELECT changeMonth(toDateTime64('2000-01-01 11:22:33.4444', 4), -1); -- out-of-bounds\n+SELECT changeMonth(toDateTime64('2000-01-01 11:22:33.4444', 4), 13); -- out-of-bounds\n+\n+SELECT 'changeDay';\n+SELECT '-- Date';\n+SELECT changeDay(toDate('2000-01-01'), 1);\n+SELECT changeDay(toDate('2000-01-01'), 2);\n+SELECT changeDay(toDate('2000-01-01'), 31);\n+SELECT changeDay(toDate('2000-01-01'), 0); -- out-of-bounds\n+SELECT changeDay(toDate('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeDay(toDate('2000-01-01'), 32); -- out-of-bounds\n+SELECT '-- Date32';\n+SELECT changeDay(toDate32('2000-01-01'), 1);\n+SELECT changeDay(toDate32('2000-01-01'), 2);\n+SELECT changeDay(toDate32('2000-01-01'), 31);\n+SELECT changeDay(toDate32('2000-01-01'), 0); -- out-of-bounds\n+SELECT changeDay(toDate32('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeDay(toDate32('2000-01-01'), 32); -- out-of-bounds\n+SELECT '-- DateTime';\n+SELECT changeDay(toDateTime('2000-01-01 11:22:33'), 1);\n+SELECT changeDay(toDateTime('2000-01-01 11:22:33'), 2);\n+SELECT changeDay(toDateTime('2000-01-01 11:22:33'), 31);\n+SELECT changeDay(toDateTime('2000-01-01 11:22:33'), 0); -- out-of-bounds\n+SELECT changeDay(toDateTime('2000-01-01 11:22:33'), -1); -- out-of-bounds\n+SELECT changeDay(toDateTime('2000-01-01 11:22:33'), 32); -- out-of-bounds\n+SELECT '-- DateTime64';\n+SELECT changeDay(toDateTime64('2000-01-01 11:22:33.4444', 4), 1);\n+SELECT changeDay(toDateTime64('2000-01-01 11:22:33.4444', 4), 2);\n+SELECT changeDay(toDateTime64('2000-01-01 11:22:33.4444', 4), 31);\n+SELECT changeDay(toDateTime64('2000-01-01 11:22:33.4444', 4), 0); -- out-of-bounds\n+SELECT changeDay(toDateTime64('2000-01-01 11:22:33.4444', 4), -1); -- out-of-bounds\n+SELECT changeDay(toDateTime64('2000-01-01 11:22:33.4444', 4), 32); -- out-of-bounds\n+SELECT '-- Special case: change to 29 Feb in a leap year';\n+SELECT changeDay(toDate('2000-02-28'), 29);\n+SELECT changeDay(toDate32('2000-02-01'), 29);\n+SELECT changeDay(toDateTime('2000-02-01 11:22:33'), 29);\n+SELECT changeDay(toDateTime64('2000-02-01 11:22:33.4444', 4), 29);\n+\n+SELECT 'changeHour';\n+SELECT '-- Date';\n+SELECT changeHour(toDate('2000-01-01'), 0);\n+SELECT changeHour(toDate('2000-01-01'), 2);\n+SELECT changeHour(toDate('2000-01-01'), 23);\n+SELECT changeHour(toDate('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeHour(toDate('2000-01-01'), 24); -- out-of-bounds\n+SELECT '-- Date32';\n+SELECT changeHour(toDate32('2000-01-01'), 0);\n+SELECT changeHour(toDate32('2000-01-01'), 2);\n+SELECT changeHour(toDate32('2000-01-01'), 23);\n+SELECT changeHour(toDate32('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeHour(toDate32('2000-01-01'), 24); -- out-of-bounds\n+SELECT '-- DateTime';\n+SELECT changeHour(toDateTime('2000-01-01 11:22:33'), 0);\n+SELECT changeHour(toDateTime('2000-01-01 11:22:33'), 2);\n+SELECT changeHour(toDateTime('2000-01-01 11:22:33'), 23);\n+SELECT changeHour(toDateTime('2000-01-01 11:22:33'), -1); -- out-of-bounds\n+SELECT changeHour(toDateTime('2000-01-01 11:22:33'), 24); -- out-of-bounds\n+SELECT '-- DateTime64';\n+SELECT changeHour(toDateTime64('2000-01-01 11:22:33.4444', 4), 0);\n+SELECT changeHour(toDateTime64('2000-01-01 11:22:33.4444', 4), 2);\n+SELECT changeHour(toDateTime64('2000-01-01 11:22:33.4444', 4), 23);\n+SELECT changeHour(toDateTime64('2000-01-01 11:22:33.4444', 4), -1); -- out-of-bounds\n+SELECT changeHour(toDateTime64('2000-01-01 11:22:33.4444', 4), 24); -- out-of-bounds\n+SELECT '-- With different timezone';\n+SELECT changeHour(toDate('2000-01-01'), -1) SETTINGS session_timezone = 'Asia/Novosibirsk';\n+SELECT changeHour(toDate('2000-01-01'), 24) SETTINGS session_timezone = 'Asia/Novosibirsk';\n+\n+SELECT 'changeMinute';\n+SELECT '-- Date';\n+SELECT changeMinute(toDate('2000-01-01'), 0);\n+SELECT changeMinute(toDate('2000-01-01'), 2);\n+SELECT changeMinute(toDate('2000-01-01'), 59);\n+SELECT changeMinute(toDate('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeMinute(toDate('2000-01-01'), 60); -- out-of-bounds\n+SELECT '-- Date32';\n+SELECT changeMinute(toDate32('2000-01-01'), 0);\n+SELECT changeMinute(toDate32('2000-01-01'), 2);\n+SELECT changeMinute(toDate32('2000-01-01'), 59);\n+SELECT changeMinute(toDate32('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeMinute(toDate32('2000-01-01'), 60); -- out-of-bounds\n+SELECT '-- DateTime';\n+SELECT changeMinute(toDateTime('2000-01-01 11:22:33'), 0);\n+SELECT changeMinute(toDateTime('2000-01-01 11:22:33'), 2);\n+SELECT changeMinute(toDateTime('2000-01-01 11:22:33'), 59);\n+SELECT changeMinute(toDateTime('2000-01-01 11:22:33'), -1); -- out-of-bounds\n+SELECT changeMinute(toDateTime('2000-01-01 11:22:33'), 60); -- out-of-bounds\n+SELECT '-- DateTime64';\n+SELECT changeMinute(toDateTime64('2000-01-01 11:22:33.4444', 4), 0);\n+SELECT changeMinute(toDateTime64('2000-01-01 11:22:33.4444', 4), 2);\n+SELECT changeMinute(toDateTime64('2000-01-01 11:22:33.4444', 4), 59);\n+SELECT changeMinute(toDateTime64('2000-01-01 11:22:33.4444', 4), -1); -- out-of-bounds\n+SELECT changeMinute(toDateTime64('2000-01-01 11:22:33.4444', 4), 60); -- out-of-bounds\n+SELECT '-- With different timezone';\n+SELECT changeMinute(toDate('2000-01-01'), -1) SETTINGS session_timezone = 'Asia/Novosibirsk';\n+SELECT changeMinute(toDate('2000-01-01'), 60) SETTINGS session_timezone = 'Asia/Novosibirsk';\n+\n+SELECT 'changeSecond';\n+SELECT '-- Date';\n+SELECT changeSecond(toDate('2000-01-01'), 0);\n+SELECT changeSecond(toDate('2000-01-01'), 2);\n+SELECT changeSecond(toDate('2000-01-01'), 59);\n+SELECT changeSecond(toDate('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeSecond(toDate('2000-01-01'), 60); -- out-of-bounds\n+SELECT '-- Date32';\n+SELECT changeSecond(toDate32('2000-01-01'), 0);\n+SELECT changeSecond(toDate32('2000-01-01'), 2);\n+SELECT changeSecond(toDate32('2000-01-01'), 59);\n+SELECT changeSecond(toDate32('2000-01-01'), -1); -- out-of-bounds\n+SELECT changeSecond(toDate32('2000-01-01'), 60); -- out-of-bounds\n+SELECT '-- DateTime';\n+SELECT changeSecond(toDateTime('2000-01-01 11:22:33'), 0);\n+SELECT changeSecond(toDateTime('2000-01-01 11:22:33'), 2);\n+SELECT changeSecond(toDateTime('2000-01-01 11:22:33'), 59);\n+SELECT changeSecond(toDateTime('2000-01-01 11:22:33'), -1); -- out-of-bounds\n+SELECT changeSecond(toDateTime('2000-01-01 11:22:33'), 60); -- out-of-bounds\n+SELECT '-- DateTime64';\n+SELECT changeSecond(toDateTime64('2000-01-01 11:22:33.4444', 4), 0);\n+SELECT changeSecond(toDateTime64('2000-01-01 11:22:33.4444', 4), 2);\n+SELECT changeSecond(toDateTime64('2000-01-01 11:22:33.4444', 4), 59);\n+SELECT changeSecond(toDateTime64('2000-01-01 11:22:33.4444', 4), -1); -- out-of-bounds\n+SELECT changeSecond(toDateTime64('2000-01-01 11:22:33.4444', 4), 60); -- out-of-bounds\n+SELECT '-- With different timezone';\n+SELECT changeSecond(toDate('2000-01-01'), -1) SETTINGS session_timezone = 'Asia/Novosibirsk';\n+SELECT changeSecond(toDate('2000-01-01'), 60) SETTINGS session_timezone = 'Asia/Novosibirsk';\n",
  "problem_statement": "Functions `changeYear` and similar.\n**Describe solution you'd like:**\r\n\r\n```\r\n-- returns the same data type as dt:\r\nchangeYear(dt, new_value)\r\nchangeMonth(dt, new_value)\r\nchangeDay(dt, new_value)\r\n\r\n-- if argument is Date - returns DateTime, if Date32, returns DateTime64:\r\nchangeHour(dt, new_value)\r\nchangeMinute(dt, new_value)\r\nchangeSecond(dt, new_value)\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2024-04-30T13:22:45Z",
  "modified_files": [
    "docs/en/operations/settings/merge-tree-settings.md",
    "docs/en/sql-reference/functions/date-time-functions.md",
    "b/src/Functions/changeDate.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02982_changeDate.reference",
    "b/tests/queries/0_stateless/02982_changeDate.sql"
  ]
}