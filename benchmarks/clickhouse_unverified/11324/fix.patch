diff --git a/src/Common/UTF8Helpers.cpp b/src/Common/UTF8Helpers.cpp
index 3cc29371b645..d8ba1bac5e99 100644
--- a/src/Common/UTF8Helpers.cpp
+++ b/src/Common/UTF8Helpers.cpp
@@ -89,7 +89,18 @@ static int wcwidth(wchar_t wc)
     }
 }
 
-size_t computeWidth(const UInt8 * data, size_t size, size_t prefix) noexcept
+
+namespace
+{
+
+enum ComputeWidthMode
+{
+    Width,              /// Calcualte and return visible width
+    BytesBeforLimit     /// Calculate and return the maximum number of bytes when substring fits in visible width.
+};
+
+template <ComputeWidthMode mode>
+static size_t computeWidthImpl(const UInt8 * data, size_t size, size_t prefix, size_t limit) noexcept
 {
     UTF8Decoder decoder;
     size_t width = 0;
@@ -132,16 +143,24 @@ size_t computeWidth(const UInt8 * data, size_t size, size_t prefix) noexcept
             ++i;
         }
 
+        /// Now i points to position in bytes after regular ASCII sequence
+        /// and if width > limit, then (width - limit) is the number of extra ASCII characters after width limit.
+        if (mode == BytesBeforLimit && width > limit)
+            return i - (width - limit);
+
         switch (decoder.decode(data[i]))
         {
             case UTF8Decoder::REJECT:
+            {
                 decoder.reset();
                 // invalid sequences seem to have zero width in modern terminals
                 // tested in libvte-based, alacritty, urxvt and xterm
                 i -= rollback;
                 rollback = 0;
                 break;
+            }
             case UTF8Decoder::ACCEPT:
+            {
                 // there are special control characters that manipulate the terminal output.
                 // (`0x08`, `0x09`, `0x0a`, `0x0b`, `0x0c`, `0x0d`, `0x1b`)
                 // Since we don't touch the original column data, there is no easy way to escape them.
@@ -149,12 +168,19 @@ size_t computeWidth(const UInt8 * data, size_t size, size_t prefix) noexcept
                 // TODO: multiline support for '
'
 
                 // special treatment for '\t'
+                size_t next_width = width;
                 if (decoder.codepoint == '\t')
-                    width += 8 - (prefix + width) % 8;
+                    next_width += 8 - (prefix + width) % 8;
                 else
-                    width += wcwidth(decoder.codepoint);
+                    next_width += wcwidth(decoder.codepoint);
+
+                if (mode == BytesBeforLimit && next_width > limit)
+                    return i - rollback;
+                width = next_width;
+
                 rollback = 0;
                 break;
+            }
             // continue if we meet other values here
             default:
                 ++rollback;
@@ -162,7 +188,21 @@ size_t computeWidth(const UInt8 * data, size_t size, size_t prefix) noexcept
     }
 
     // no need to handle trailing sequence as they have zero width
-    return width;
+    return (mode == BytesBeforLimit) ? size : width;
+}
+
+}
+
+
+size_t computeWidth(const UInt8 * data, size_t size, size_t prefix) noexcept
+{
+    return computeWidthImpl<Width>(data, size, prefix, 0);
+}
+
+size_t computeBytesBeforeWidth(const UInt8 * data, size_t size, size_t prefix, size_t limit) noexcept
+{
+    return computeWidthImpl<BytesBeforLimit>(data, size, prefix, limit);
 }
+
 }
 }
diff --git a/src/Common/UTF8Helpers.h b/src/Common/UTF8Helpers.h
index c1c73783870d..926bb6a7f92e 100644
--- a/src/Common/UTF8Helpers.h
+++ b/src/Common/UTF8Helpers.h
@@ -99,6 +99,19 @@ int queryConvert(const CharT * bytes, int length)
 /// and include `\t` to the nearest longer length with multiple of eight.
 size_t computeWidth(const UInt8 * data, size_t size, size_t prefix = 0) noexcept;
 
+
+/** Calculate the maximum number of bytes, so that substring of this size fits in 'limit' width.
+  *
+  * For example, we have string "x你好", it has 3 code points and visible width of 5 and byte size of 7.
+
+  * Suppose we have limit = 3.
+  * Then we have to return 4 as maximum number of bytes
+  *  and the truncated string will be "x你": two code points, visible width 3, byte size 4.
+  *
+  * The same result will be for limit 4, because the last character would not fit.
+  */
+size_t computeBytesBeforeWidth(const UInt8 * data, size_t size, size_t prefix, size_t limit) noexcept;
+
 }
 
 
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index c3c8eedbb124..d1e36e9f3de0 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -211,6 +211,7 @@ struct Settings : public SettingsCollection<Settings>
     \
     M(SettingUInt64, output_format_pretty_max_rows, 10000, "Rows limit for Pretty formats.", 0) \
     M(SettingUInt64, output_format_pretty_max_column_pad_width, 250, "Maximum width to pad all values in a column in Pretty formats.", 0) \
+    M(SettingUInt64, output_format_pretty_max_value_width, 10000, "Maximum width of value to display in Pretty formats. If greater - it will be cut.", 0) \
     M(SettingBool, output_format_pretty_color, true, "Use ANSI escape sequences to paint colors in Pretty formats", 0) \
     M(SettingUInt64, output_format_parquet_row_group_size, 1000000, "Row group size in rows.", 0) \
     M(SettingString, output_format_avro_codec, "", "Compression codec used for output. Possible values: 'null', 'deflate', 'snappy'.", 0) \
diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp
index 669baace2f5b..9182c728600b 100644
--- a/src/Formats/FormatFactory.cpp
+++ b/src/Formats/FormatFactory.cpp
@@ -101,6 +101,7 @@ static FormatSettings getOutputFormatSetting(const Settings & settings, const Co
     format_settings.csv.crlf_end_of_line = settings.output_format_csv_crlf_end_of_line;
     format_settings.pretty.max_rows = settings.output_format_pretty_max_rows;
     format_settings.pretty.max_column_pad_width = settings.output_format_pretty_max_column_pad_width;
+    format_settings.pretty.max_value_width = settings.output_format_pretty_max_value_width;
     format_settings.pretty.color = settings.output_format_pretty_color;
     format_settings.template_settings.resultset_format = settings.format_template_resultset;
     format_settings.template_settings.row_format = settings.format_template_row;
diff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h
index 5382d0e0b9d7..26195c9ae0a6 100644
--- a/src/Formats/FormatSettings.h
+++ b/src/Formats/FormatSettings.h
@@ -42,6 +42,7 @@ struct FormatSettings
     {
         UInt64 max_rows = 10000;
         UInt64 max_column_pad_width = 250;
+        UInt64 max_value_width = 10000;
         bool color = true;
     };
 
diff --git a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp
index 96b1ff5a5113..59d3814adea8 100644
--- a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp
+++ b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.cpp
@@ -30,14 +30,14 @@ PrettyBlockOutputFormat::PrettyBlockOutputFormat(
 /// Note that number of code points is just a rough approximation of visible string width.
 void PrettyBlockOutputFormat::calculateWidths(
     const Block & header, const Chunk & chunk,
-    WidthsPerColumn & widths, Widths & max_widths, Widths & name_widths)
+    WidthsPerColumn & widths, Widths & max_padded_widths, Widths & name_widths)
 {
-    size_t num_rows = chunk.getNumRows();
+    size_t num_rows = std::min(chunk.getNumRows(), format_settings.pretty.max_rows);
     size_t num_columns = chunk.getNumColumns();
     const auto & columns = chunk.getColumns();
 
     widths.resize(num_columns);
-    max_widths.resize_fill(num_columns);
+    max_padded_widths.resize_fill(num_columns);
     name_widths.resize(num_columns);
 
     /// Calculate widths of all values.
@@ -57,9 +57,21 @@ void PrettyBlockOutputFormat::calculateWidths(
                 elem.type->serializeAsText(*column, j, out_serialize, format_settings);
             }
 
-            widths[i][j] = std::min<UInt64>(format_settings.pretty.max_column_pad_width,
-                UTF8::computeWidth(reinterpret_cast<const UInt8 *>(serialized_value.data()), serialized_value.size(), prefix));
-            max_widths[i] = std::max(max_widths[i], widths[i][j]);
+            /// Avoid calculating width of too long strings by limiting the size in bytes.
+            /// Note that it is just an estimation. 4 is the maximum size of Unicode code point in bytes in UTF-8.
+            /// But it's possible that the string is long in bytes but very short in visible size.
+            /// (e.g. non-printable characters, diacritics, combining characters)
+            if (format_settings.pretty.max_value_width)
+            {
+                size_t max_byte_size = format_settings.pretty.max_value_width * 4;
+                if (serialized_value.size() > max_byte_size)
+                    serialized_value.resize(max_byte_size);
+            }
+
+            widths[i][j] = UTF8::computeWidth(reinterpret_cast<const UInt8 *>(serialized_value.data()), serialized_value.size(), prefix);
+            max_padded_widths[i] = std::max<UInt64>(max_padded_widths[i],
+                std::min<UInt64>(format_settings.pretty.max_column_pad_width,
+                    std::min<UInt64>(format_settings.pretty.max_value_width, widths[i][j])));
         }
 
         /// And also calculate widths for names of columns.
@@ -67,9 +79,9 @@ void PrettyBlockOutputFormat::calculateWidths(
             // name string doesn't contain Tab, no need to pass `prefix`
             name_widths[i] = std::min<UInt64>(format_settings.pretty.max_column_pad_width,
                 UTF8::computeWidth(reinterpret_cast<const UInt8 *>(elem.name.data()), elem.name.size()));
-            max_widths[i] = std::max(max_widths[i], name_widths[i]);
+            max_padded_widths[i] = std::max<UInt64>(max_padded_widths[i], name_widths[i]);
         }
-        prefix += max_widths[i] + 3;
+        prefix += max_padded_widths[i] + 3;
     }
 }
 
@@ -174,18 +186,20 @@ void PrettyBlockOutputFormat::write(const Chunk & chunk, PortKind port_kind)
         if (i != 0)
             writeString(middle_values_separator_s, out);
 
-        writeCString("│ ", out);
+        writeCString("│", out);
 
         for (size_t j = 0; j < num_columns; ++j)
         {
             if (j != 0)
-                writeCString(" │ ", out);
+                writeCString("│", out);
 
             const auto & type = *header.getByPosition(j).type;
-            writeValueWithPadding(*columns[j], type, i, widths[j].empty() ? max_widths[j] : widths[j][i], max_widths[j]);
+            writeValueWithPadding(*columns[j], type, i,
+                widths[j].empty() ? max_widths[j] : widths[j][i],
+                max_widths[j]);
         }
 
-        writeCString(" │
", out);
+        writeCString("│
", out);
     }
 
     writeString(bottom_separator_s, out);
@@ -197,20 +211,42 @@ void PrettyBlockOutputFormat::write(const Chunk & chunk, PortKind port_kind)
 void PrettyBlockOutputFormat::writeValueWithPadding(
         const IColumn & column, const IDataType & type, size_t row_num, size_t value_width, size_t pad_to_width)
 {
+    String serialized_value = " ";
+    {
+        WriteBufferFromString out_serialize(serialized_value, WriteBufferFromString::AppendModeTag());
+        type.serializeAsText(column, row_num, out_serialize, format_settings);
+    }
+
+    if (value_width > format_settings.pretty.max_value_width)
+    {
+        serialized_value.resize(UTF8::computeBytesBeforeWidth(
+            reinterpret_cast<const UInt8 *>(serialized_value.data()), serialized_value.size(), 0, 1 + format_settings.pretty.max_value_width));
+
+        if (format_settings.pretty.color)
+            serialized_value += "\033[31;1m⋯\033[0m";
+        else
+            serialized_value += "⋯";
+
+        value_width = format_settings.pretty.max_value_width;
+    }
+    else
+        serialized_value += ' ';
+
     auto write_padding = [&]()
     {
-        for (size_t k = 0; k < pad_to_width - value_width; ++k)
-            writeChar(' ', out);
+        if (pad_to_width > value_width)
+            for (size_t k = 0; k < pad_to_width - value_width; ++k)
+                writeChar(' ', out);
     };
 
     if (type.shouldAlignRightInPrettyFormats())
     {
         write_padding();
-        type.serializeAsText(column, row_num, out, format_settings);
+        out.write(serialized_value.data(), serialized_value.size());
     }
     else
     {
-        type.serializeAsText(column, row_num, out, format_settings);
+        out.write(serialized_value.data(), serialized_value.size());
         write_padding();
     }
 }
diff --git a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h
index eae1c3e9eb12..a873e02c1e48 100644
--- a/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h
+++ b/src/Processors/Formats/Impl/PrettyBlockOutputFormat.h
@@ -52,7 +52,7 @@ class PrettyBlockOutputFormat : public IOutputFormat
 
     void calculateWidths(
         const Block & header, const Chunk & chunk,
-        WidthsPerColumn & widths, Widths & max_widths, Widths & name_widths);
+        WidthsPerColumn & widths, Widths & max_padded_widths, Widths & name_widths);
 
     void writeValueWithPadding(
         const IColumn & column, const IDataType & type, size_t row_num, size_t value_width, size_t pad_to_width);
diff --git a/src/Processors/Formats/Impl/PrettyCompactBlockOutputFormat.cpp b/src/Processors/Formats/Impl/PrettyCompactBlockOutputFormat.cpp
index 4726332e554a..e9040f672b4b 100644
--- a/src/Processors/Formats/Impl/PrettyCompactBlockOutputFormat.cpp
+++ b/src/Processors/Formats/Impl/PrettyCompactBlockOutputFormat.cpp
@@ -83,19 +83,19 @@ void PrettyCompactBlockOutputFormat::writeRow(
 {
     size_t num_columns = max_widths.size();
 
-    writeCString("│ ", out);
+    writeCString("│", out);
 
     for (size_t j = 0; j < num_columns; ++j)
     {
         if (j != 0)
-            writeCString(" │ ", out);
+            writeCString("│", out);
 
         const auto & type = *header.getByPosition(j).type;
         const auto & cur_widths = widths[j].empty() ? max_widths[j] : widths[j][row_num];
         writeValueWithPadding(*columns[j], type, row_num, cur_widths, max_widths[j]);
     }
 
-    writeCString(" │
", out);
+    writeCString("│
", out);
 }
 
 void PrettyCompactBlockOutputFormat::write(const Chunk & chunk, PortKind port_kind)
diff --git a/src/Processors/Formats/Impl/PrettySpaceBlockOutputFormat.cpp b/src/Processors/Formats/Impl/PrettySpaceBlockOutputFormat.cpp
index ca9d1b674d47..6b42ea57e1f2 100644
--- a/src/Processors/Formats/Impl/PrettySpaceBlockOutputFormat.cpp
+++ b/src/Processors/Formats/Impl/PrettySpaceBlockOutputFormat.cpp
@@ -34,6 +34,8 @@ void PrettySpaceBlockOutputFormat::write(const Chunk & chunk, PortKind port_kind
     {
         if (i != 0)
             writeCString("   ", out);
+        else
+            writeChar(' ', out);
 
         const ColumnWithTypeAndName & col = header.getByPosition(i);
 
@@ -67,7 +69,7 @@ void PrettySpaceBlockOutputFormat::write(const Chunk & chunk, PortKind port_kind
         for (size_t column = 0; column < num_columns; ++column)
         {
             if (column != 0)
-                writeCString("   ", out);
+                writeCString(" ", out);
 
             const auto & type = *header.getByPosition(column).type;
             auto & cur_width = widths[column].empty() ? max_widths[column] : widths[column][row];
