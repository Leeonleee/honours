diff --git a/src/Functions/bitCount.cpp b/src/Functions/bitCount.cpp
index 566a11481be9..f1a3ac897c18 100644
--- a/src/Functions/bitCount.cpp
+++ b/src/Functions/bitCount.cpp
@@ -1,6 +1,7 @@
 #include <base/bit_cast.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionUnaryArithmetic.h>
+#include <bit>
 
 
 namespace DB
@@ -21,19 +22,19 @@ struct BitCountImpl
         {
             ResultType res = 0;
             for (auto item : a.items)
-                res += __builtin_popcountll(item);
+                res += std::popcount(item);
             return res;
         }
         if constexpr (std::is_same_v<A, UInt64> || std::is_same_v<A, Int64>)
-            return __builtin_popcountll(a);
+            return std::popcount(static_cast<UInt64>(a));
         if constexpr (std::is_same_v<A, UInt32> || std::is_same_v<A, Int32> || std::is_unsigned_v<A>)
-            return __builtin_popcount(a);
+            return std::popcount(static_cast<UInt32>(a));
         if constexpr (std::is_same_v<A, Int16>)
-            return __builtin_popcount(static_cast<UInt16>(a));
+            return std::popcount(static_cast<UInt16>(a));
         if constexpr (std::is_same_v<A, Int8>)
-            return __builtin_popcount(static_cast<UInt8>(a));
+            return std::popcount(static_cast<uint8_t>(a));
         else
-            return __builtin_popcountll(bit_cast<uint64_t>(a));
+            return std::popcount(bit_cast<uint64_t>(a));
     }
 
 #if USE_EMBEDDED_COMPILER
diff --git a/src/Functions/bitHammingDistance.cpp b/src/Functions/bitHammingDistance.cpp
index 2eaa397dd041..f00f38b61af6 100644
--- a/src/Functions/bitHammingDistance.cpp
+++ b/src/Functions/bitHammingDistance.cpp
@@ -2,20 +2,44 @@
 #include <Functions/FunctionFactory.h>
 #include <bit>
 
+
 namespace DB
 {
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_COLUMN;
+}
+
 template <typename A, typename B>
 struct BitHammingDistanceImpl
 {
-    using ResultType = UInt8;
+    using ResultType = std::conditional_t<(sizeof(A) * 8 >= 256), UInt16, UInt8>;
     static constexpr bool allow_fixed_string = true;
     static constexpr bool allow_string_integer = false;
 
     template <typename Result = ResultType>
     static inline NO_SANITIZE_UNDEFINED Result apply(A a, B b)
     {
-        UInt64 res = static_cast<UInt64>(a) ^ static_cast<UInt64>(b);
-        return std::popcount(res);
+        /// Note: it's unspecified if signed integers should be promoted with sign-extension or with zero-fill.
+        /// This behavior can change in the future.
+
+        if constexpr (sizeof(A) <= sizeof(UInt64) && sizeof(B) <= sizeof(UInt64))
+        {
+            UInt64 res = static_cast<UInt64>(a) ^ static_cast<UInt64>(b);
+            return std::popcount(res);
+        }
+        else if constexpr (is_big_int_v<A> && is_big_int_v<B>)
+        {
+            auto xored = a ^ b;
+
+            ResultType res = 0;
+            for (auto item : xored.items)
+                res += std::popcount(item);
+            return res;
+        }
+        else
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unsupported data type combination in function 'bitHammingDistance'");
     }
 
 #if USE_EMBEDDED_COMPILER
