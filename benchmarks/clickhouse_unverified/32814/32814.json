{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32814,
  "instance_id": "ClickHouse__ClickHouse-32814",
  "issue_numbers": [
    "17882"
  ],
  "base_commit": "774620e5c0aa3944d572f35e02f4c0ffd0fbdec2",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 9e6002862143..1b7be8ca98d7 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -3743,6 +3743,27 @@ std::unordered_set<String> MergeTreeData::getPartitionIDsFromQuery(const ASTs &\n     return partition_ids;\n }\n \n+std::set<String> MergeTreeData::getPartitionIdsAffectedByCommands(\n+    const MutationCommands & commands, ContextPtr query_context) const\n+{\n+    std::set<String> affected_partition_ids;\n+\n+    for (const auto & command : commands)\n+    {\n+        if (!command.partition)\n+        {\n+            affected_partition_ids.clear();\n+            break;\n+        }\n+\n+        affected_partition_ids.insert(\n+            getPartitionIDFromQuery(command.partition, query_context)\n+        );\n+    }\n+\n+    return affected_partition_ids;\n+}\n+\n \n MergeTreeData::DataPartsVector MergeTreeData::getDataPartsVector(\n     const DataPartStates & affordable_states, DataPartStateVector * out_states, bool require_projection_parts) const\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 5a3dda785a0e..380c2f4f4c59 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -688,6 +688,7 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// For ATTACH/DETACH/DROP PARTITION.\n     String getPartitionIDFromQuery(const ASTPtr & ast, ContextPtr context) const;\n     std::unordered_set<String> getPartitionIDsFromQuery(const ASTs & asts, ContextPtr context) const;\n+    std::set<String> getPartitionIdsAffectedByCommands(const MutationCommands & commands, ContextPtr query_context) const;\n \n     /// Extracts MergeTreeData of other *MergeTree* storage\n     ///  and checks that their structure suitable for ALTER TABLE ATTACH PARTITION FROM\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex f83ab0c3f9e3..03ac27d0e46b 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -508,6 +508,9 @@ void StorageMergeTree::waitForMutation(Int64 version, const String & file_name)\n \n void StorageMergeTree::mutate(const MutationCommands & commands, ContextPtr query_context)\n {\n+    /// Validate partition IDs (if any) before starting mutation\n+    getPartitionIdsAffectedByCommands(commands, query_context);\n+\n     String mutation_file_name;\n     Int64 version = startMutation(commands, mutation_file_name);\n \n@@ -898,6 +901,7 @@ std::shared_ptr<MergeMutateSelectedEntry> StorageMergeTree::selectPartsToMutate(\n         auto commands = MutationCommands::create();\n \n         size_t current_ast_elements = 0;\n+        auto last_mutation_to_apply = mutations_end_it;\n         for (auto it = mutations_begin_it; it != mutations_end_it; ++it)\n         {\n             size_t commands_size = 0;\n@@ -934,7 +938,8 @@ std::shared_ptr<MergeMutateSelectedEntry> StorageMergeTree::selectPartsToMutate(\n                     MergeTreeMutationEntry & entry = it->second;\n                     entry.latest_fail_time = time(nullptr);\n                     entry.latest_fail_reason = getCurrentExceptionMessage(false);\n-                    continue;\n+                    /// NOTE we should not skip mutations, because exception may be retryable (e.g. MEMORY_LIMIT_EXCEEDED)\n+                    break;\n                 }\n             }\n \n@@ -943,8 +948,10 @@ std::shared_ptr<MergeMutateSelectedEntry> StorageMergeTree::selectPartsToMutate(\n \n             current_ast_elements += commands_size;\n             commands->insert(commands->end(), it->second.commands.begin(), it->second.commands.end());\n+            last_mutation_to_apply = it;\n         }\n \n+        assert(commands->empty() == (last_mutation_to_apply == mutations_end_it));\n         if (!commands->empty())\n         {\n             bool is_partition_affected = false;\n@@ -969,13 +976,13 @@ std::shared_ptr<MergeMutateSelectedEntry> StorageMergeTree::selectPartsToMutate(\n                 /// Shall not create a new part, but will do that later if mutation with higher version appear.\n                 /// This is needed in order to not produce excessive mutations of non-related parts.\n                 auto block_range = std::make_pair(part->info.min_block, part->info.max_block);\n-                updated_version_by_block_range[block_range] = current_mutations_by_version.rbegin()->first;\n+                updated_version_by_block_range[block_range] = last_mutation_to_apply->first;\n                 were_some_mutations_for_some_parts_skipped = true;\n                 continue;\n             }\n \n             auto new_part_info = part->info;\n-            new_part_info.mutation = current_mutations_by_version.rbegin()->first;\n+            new_part_info.mutation = last_mutation_to_apply->first;\n \n             future_part->parts.push_back(part);\n             future_part->part_info = new_part_info;\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex ca877d8a72d7..60535ed5211e 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -4532,28 +4532,6 @@ bool StorageReplicatedMergeTree::executeMetadataAlter(const StorageReplicatedMer\n }\n \n \n-std::set<String> StorageReplicatedMergeTree::getPartitionIdsAffectedByCommands(\n-    const MutationCommands & commands, ContextPtr query_context) const\n-{\n-    std::set<String> affected_partition_ids;\n-\n-    for (const auto & command : commands)\n-    {\n-        if (!command.partition)\n-        {\n-            affected_partition_ids.clear();\n-            break;\n-        }\n-\n-        affected_partition_ids.insert(\n-            getPartitionIDFromQuery(command.partition, query_context)\n-        );\n-    }\n-\n-    return affected_partition_ids;\n-}\n-\n-\n PartitionBlockNumbersHolder StorageReplicatedMergeTree::allocateBlockNumbersInAffectedPartitions(\n     const MutationCommands & commands, ContextPtr query_context, const zkutil::ZooKeeperPtr & zookeeper) const\n {\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex bcd364df30e3..6861d89f0704 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -717,7 +717,6 @@ class StorageReplicatedMergeTree final : public shared_ptr_helper<StorageReplica\n \n     std::unique_ptr<MergeTreeSettings> getDefaultSettings() const override;\n \n-    std::set<String> getPartitionIdsAffectedByCommands(const MutationCommands & commands, ContextPtr query_context) const;\n     PartitionBlockNumbersHolder allocateBlockNumbersInAffectedPartitions(\n         const MutationCommands & commands, ContextPtr query_context, const zkutil::ZooKeeperPtr & zookeeper) const;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02004_invalid_partition_mutation_stuck.sql b/tests/queries/0_stateless/02004_invalid_partition_mutation_stuck.sql\nindex 481a5565095f..71c8b9af6527 100644\n--- a/tests/queries/0_stateless/02004_invalid_partition_mutation_stuck.sql\n+++ b/tests/queries/0_stateless/02004_invalid_partition_mutation_stuck.sql\n@@ -28,6 +28,6 @@ PARTITION BY p\n ORDER BY t\n SETTINGS number_of_free_entries_in_pool_to_execute_mutation=0;\n INSERT INTO data VALUES (1, now());\n-ALTER TABLE data MATERIALIZE INDEX idx IN PARTITION ID 'NO_SUCH_PART'; -- { serverError 341 }\n+ALTER TABLE data MATERIALIZE INDEX idx IN PARTITION ID 'NO_SUCH_PART'; -- { serverError 248 }\n ALTER TABLE data MATERIALIZE INDEX idx IN PARTITION ID '1';\n ALTER TABLE data MATERIALIZE INDEX idx IN PARTITION ID '2';\n",
  "problem_statement": "Is it a bug when number of ast elements >  max_expanded_ast_elements if there are many mutations.\nI am reading clickhouse mutation code. In StorageMergeTree->selectPartsToMutate() function, there is a check \r\n`if (current_ast_elements + commands_size >= max_ast_elements)\r\n                break;`\r\n\r\nI think if there are many mutations then the check result will be true, so that it will skip the remaining mutations.\r\nBut the new part's mutation is set to the last one in mutation map, and it does not apply the remaining mutations actually.\r\n`new_part_info.mutation = current_mutations_by_version.rbegin()->first;`\r\n\r\nThen the new part will miss the remaining mutations in future mutation job.\r\n\r\nI think it's wrong here. Am I right?\r\n\r\nIf it is right, I will submit a PR \r\n\n",
  "hints_text": "",
  "created_at": "2021-12-15T18:25:51Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/StorageMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02004_invalid_partition_mutation_stuck.sql"
  ]
}