{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 4213,
  "instance_id": "ClickHouse__ClickHouse-4213",
  "issue_numbers": [
    "1403"
  ],
  "base_commit": "37b1d8369c177ded183562dc2bd30f1fbdd136a2",
  "patch": "diff --git a/dbms/programs/server/HTTPHandler.cpp b/dbms/programs/server/HTTPHandler.cpp\nindex a645019875a3..261504926f5b 100644\n--- a/dbms/programs/server/HTTPHandler.cpp\n+++ b/dbms/programs/server/HTTPHandler.cpp\n@@ -4,6 +4,7 @@\n #include <Poco/File.h>\n #include <Poco/Net/HTTPBasicCredentials.h>\n #include <Poco/Net/HTTPServerRequest.h>\n+#include <Poco/Net/HTTPServerRequestImpl.h>\n #include <Poco/Net/HTTPServerResponse.h>\n #include <Poco/Net/NetException.h>\n \n@@ -558,9 +559,47 @@ void HTTPHandler::processQuery(\n     client_info.http_method = http_method;\n     client_info.http_user_agent = request.get(\"User-Agent\", \"\");\n \n+    auto appendCallback = [&context] (ProgressCallback callback)\n+    {\n+        auto prev = context.getProgressCallback();\n+\n+        context.setProgressCallback([prev, callback] (const Progress & progress)\n+        {\n+            if (prev)\n+                prev(progress);\n+\n+            callback(progress);\n+        });\n+    };\n+\n     /// While still no data has been sent, we will report about query execution progress by sending HTTP headers.\n     if (settings.send_progress_in_http_headers)\n-        context.setProgressCallback([&used_output] (const Progress & progress) { used_output.out->onProgress(progress); });\n+        appendCallback([&used_output] (const Progress & progress) { used_output.out->onProgress(progress); });\n+\n+    if (settings.readonly > 0 && settings.cancel_http_readonly_queries_on_client_close)\n+    {\n+        Poco::Net::StreamSocket & socket = dynamic_cast<Poco::Net::HTTPServerRequestImpl &>(request).socket();\n+\n+        appendCallback([&context, &socket](const Progress &)\n+        {\n+            /// Assume that at the point this method is called no one is reading data from the socket any more.\n+            /// True for read-only queries.\n+            try\n+            {\n+                char b;\n+                int status = socket.receiveBytes(&b, 1, MSG_DONTWAIT | MSG_PEEK);\n+                if (status == 0)\n+                    context.killCurrentQuery();\n+            }\n+            catch (Poco::TimeoutException &)\n+            {\n+            }\n+            catch (...)\n+            {\n+                context.killCurrentQuery();\n+            }\n+        });\n+    }\n \n     executeQuery(*in, *used_output.out_maybe_delayed_and_compressed, /* allow_into_outfile = */ false, context,\n         [&response] (const String & content_type) { response.setContentType(content_type); });\ndiff --git a/dbms/src/Interpreters/Context.cpp b/dbms/src/Interpreters/Context.cpp\nindex f5c99c140bcb..d9453f58e6a2 100644\n--- a/dbms/src/Interpreters/Context.cpp\n+++ b/dbms/src/Interpreters/Context.cpp\n@@ -1077,6 +1077,13 @@ void Context::setCurrentQueryId(const String & query_id)\n     client_info.current_query_id = query_id_to_set;\n }\n \n+void Context::killCurrentQuery()\n+{\n+    if (process_list_elem)\n+    {\n+        process_list_elem->cancelQuery(true);\n+    }\n+};\n \n String Context::getDefaultFormat() const\n {\ndiff --git a/dbms/src/Interpreters/Context.h b/dbms/src/Interpreters/Context.h\nindex a0c6d59cd6de..93ff7a8484e4 100644\n--- a/dbms/src/Interpreters/Context.h\n+++ b/dbms/src/Interpreters/Context.h\n@@ -236,6 +236,8 @@ class Context\n     void setCurrentDatabase(const String & name);\n     void setCurrentQueryId(const String & query_id);\n \n+    void killCurrentQuery();\n+\n     void setInsertionTable(std::pair<String, String> && db_and_table) { insertion_table = db_and_table; }\n     const std::pair<String, String> & getInsertionTable() const { return insertion_table; }\n \ndiff --git a/dbms/src/Interpreters/InterpreterKillQueryQuery.cpp b/dbms/src/Interpreters/InterpreterKillQueryQuery.cpp\nindex 43f4e55297f8..0360fed05dee 100644\n--- a/dbms/src/Interpreters/InterpreterKillQueryQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterKillQueryQuery.cpp\n@@ -26,9 +26,6 @@ namespace ErrorCodes\n     extern const int CANNOT_KILL;\n }\n \n-\n-using CancellationCode = ProcessList::CancellationCode;\n-\n static const char * cancellationCodeToStatus(CancellationCode code)\n {\n     switch (code)\ndiff --git a/dbms/src/Interpreters/ProcessList.cpp b/dbms/src/Interpreters/ProcessList.cpp\nindex 0ba14316a3ec..12d77c5fa354 100644\n--- a/dbms/src/Interpreters/ProcessList.cpp\n+++ b/dbms/src/Interpreters/ProcessList.cpp\n@@ -325,6 +325,29 @@ bool QueryStatus::tryGetQueryStreams(BlockInputStreamPtr & in, BlockOutputStream\n     return true;\n }\n \n+CancellationCode QueryStatus::cancelQuery(bool kill)\n+{\n+    /// Streams are destroyed, and ProcessListElement will be deleted from ProcessList soon. We need wait a little bit\n+    if (streamsAreReleased())\n+        return CancellationCode::CancelSent;\n+\n+    BlockInputStreamPtr input_stream;\n+    BlockOutputStreamPtr output_stream;\n+\n+    if (tryGetQueryStreams(input_stream, output_stream))\n+    {\n+        if (input_stream)\n+        {\n+            input_stream->cancel(kill);\n+            return CancellationCode::CancelSent;\n+        }\n+        return CancellationCode::CancelCannotBeSent;\n+    }\n+    /// Query is not even started\n+    is_killed.store(true);\n+    return CancellationCode::CancelSent;\n+}\n+\n \n void QueryStatus::setUserProcessList(ProcessListForUser * user_process_list_)\n {\n@@ -356,7 +379,7 @@ QueryStatus * ProcessList::tryGetProcessListElement(const String & current_query\n }\n \n \n-ProcessList::CancellationCode ProcessList::sendCancelToQuery(const String & current_query_id, const String & current_user, bool kill)\n+CancellationCode ProcessList::sendCancelToQuery(const String & current_query_id, const String & current_user, bool kill)\n {\n     std::lock_guard lock(mutex);\n \n@@ -365,25 +388,7 @@ ProcessList::CancellationCode ProcessList::sendCancelToQuery(const String & curr\n     if (!elem)\n         return CancellationCode::NotFound;\n \n-    /// Streams are destroyed, and ProcessListElement will be deleted from ProcessList soon. We need wait a little bit\n-    if (elem->streamsAreReleased())\n-        return CancellationCode::CancelSent;\n-\n-    BlockInputStreamPtr input_stream;\n-    BlockOutputStreamPtr output_stream;\n-\n-    if (elem->tryGetQueryStreams(input_stream, output_stream))\n-    {\n-        if (input_stream)\n-        {\n-            input_stream->cancel(kill);\n-            return CancellationCode::CancelSent;\n-        }\n-        return CancellationCode::CancelCannotBeSent;\n-    }\n-    /// Query is not even started\n-    elem->is_killed.store(true);\n-    return CancellationCode::CancelSent;\n+    return elem->cancelQuery(kill);\n }\n \n \ndiff --git a/dbms/src/Interpreters/ProcessList.h b/dbms/src/Interpreters/ProcessList.h\nindex 5d2b6db95d07..c9eff51bf7bb 100644\n--- a/dbms/src/Interpreters/ProcessList.h\n+++ b/dbms/src/Interpreters/ProcessList.h\n@@ -70,6 +70,14 @@ struct QueryStatusInfo\n     std::shared_ptr<Settings> query_settings;\n };\n \n+enum class CancellationCode\n+{\n+    NotFound = 0,                     /// already cancelled\n+    QueryIsNotInitializedYet = 1,\n+    CancelCannotBeSent = 2,\n+    CancelSent = 3,\n+    Unknown\n+};\n \n /// Query and information about its execution.\n class QueryStatus\n@@ -192,6 +200,8 @@ class QueryStatus\n     /// Get query in/out pointers from BlockIO\n     bool tryGetQueryStreams(BlockInputStreamPtr & in, BlockOutputStreamPtr & out) const;\n \n+    CancellationCode cancelQuery(bool kill);\n+\n     bool isKilled() const { return is_killed; }\n };\n \n@@ -312,15 +322,6 @@ class ProcessList\n         max_size = max_size_;\n     }\n \n-    enum class CancellationCode\n-    {\n-        NotFound = 0,                     /// already cancelled\n-        QueryIsNotInitializedYet = 1,\n-        CancelCannotBeSent = 2,\n-        CancelSent = 3,\n-        Unknown\n-    };\n-\n     /// Try call cancel() for input and output streams of query with specified id and user\n     CancellationCode sendCancelToQuery(const String & current_query_id, const String & current_user, bool kill = false);\n };\ndiff --git a/dbms/src/Interpreters/Settings.h b/dbms/src/Interpreters/Settings.h\nindex 156b220a35a3..fdeba24b92eb 100644\n--- a/dbms/src/Interpreters/Settings.h\n+++ b/dbms/src/Interpreters/Settings.h\n@@ -299,6 +299,7 @@ struct Settings\n     M(SettingBool, low_cardinality_allow_in_native_format, true, \"Use LowCardinality type in Native format. Otherwise, convert LowCardinality columns to ordinary for select query, and convert ordinary columns to required LowCardinality for insert query.\") \\\n     M(SettingBool, allow_experimental_multiple_joins_emulation, false, \"Emulate multiple joins using subselects\") \\\n     M(SettingBool, allow_experimental_cross_to_join_conversion, false, \"Convert CROSS JOIN to INNER JOIN if possible\") \\\n+    M(SettingBool, cancel_http_readonly_queries_on_client_close, false, \"Cancel HTTP readonly queries when a client closes the connection without waiting for response.\") \\\n \n #define DECLARE(TYPE, NAME, DEFAULT, DESCRIPTION) \\\n     TYPE NAME {DEFAULT};\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.reference b/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.reference\nnew file mode 100644\nindex 000000000000..b261da18d51a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.reference\n@@ -0,0 +1,2 @@\n+1\n+0\ndiff --git a/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.sh b/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.sh\nnew file mode 100755\nindex 000000000000..4bb8d4df3531\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.sh\n@@ -0,0 +1,19 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}?query_id=cancel_http_readonly_queries_on_client_close&cancel_http_readonly_queries_on_client_close=1&query=SELECT+count()+FROM+system.numbers\" &\n+REQUEST_CURL_PID=$!\n+sleep 0.1\n+\n+# Check query is registered\n+$CLICKHOUSE_CLIENT -q \"SELECT count() FROM system.processes where query_id='cancel_http_readonly_queries_on_client_close'\"\n+\n+# Kill client (curl process)\n+kill -SIGTERM $REQUEST_CURL_PID\n+sleep 0.1\n+\n+# Check query is killed after client is gone\n+$CLICKHOUSE_CLIENT -q \"SELECT count() FROM system.processes where query_id='cancel_http_readonly_queries_on_client_close'\"\n",
  "problem_statement": "HTTP interface: kill queries after disconnect.\nIf you will just close the HTTP connection with lasting query, the execution of that query is not stopped.\r\n\r\nMay be for DDL queries that bahaviour can be considered as acceptable, but for usual SELECTs - continuing the query execution after disconnect - is only wasting of server resources.\r\n\r\nI know that there is replace_running_query and KILL QUERY  but it not always possible (for example if client just died, and server have a lot of clients, and can't distinguish which are active and which - not) and requires some extra actions.\r\n\r\nI think that for SELECTs you should check if connection is still active and kill / replace the query if connection was closed by the client / timeout, for DDLs / INSERTs - that behaviour probably should be configurable.\n",
  "hints_text": "@filimonov , try using [chproxy](https://github.com/Vertamedia/chproxy). It must kill the query immediately after the client closes http connection.\n> @filimonov , try using [chproxy](https://github.com/Vertamedia/chproxy). It must kill the query immediately after the client closes http connection.\r\n\r\nUsing proxy is of course an option but it seems that much more users would benefit from the feature if it was implemented in the server itself.",
  "created_at": "2019-02-01T02:05:25Z",
  "modified_files": [
    "dbms/programs/server/HTTPHandler.cpp",
    "dbms/src/Interpreters/Context.cpp",
    "dbms/src/Interpreters/Context.h",
    "dbms/src/Interpreters/InterpreterKillQueryQuery.cpp",
    "dbms/src/Interpreters/ProcessList.cpp",
    "dbms/src/Interpreters/ProcessList.h",
    "dbms/src/Interpreters/Settings.h"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.reference",
    "b/dbms/tests/queries/0_stateless/00834_cancel_http_readonly_queries_on_client_close.sh"
  ]
}