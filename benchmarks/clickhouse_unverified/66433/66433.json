{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66433,
  "instance_id": "ClickHouse__ClickHouse-66433",
  "issue_numbers": [
    "65468"
  ],
  "base_commit": "9bbd24f2ca1a63a8ccf1e6a4393e4c796b87c688",
  "patch": "diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 576c4943ccb5..818e75f95944 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -3410,14 +3410,14 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             function_base = function->build(argument_columns);\n \n         /// Do not constant fold get scalar functions\n-        bool disable_constant_folding = function_name == \"__getScalar\" || function_name == \"shardNum\" ||\n-            function_name == \"shardCount\" || function_name == \"hostName\" || function_name == \"tcpPort\";\n+        // bool disable_constant_folding = function_name == \"__getScalar\" || function_name == \"shardNum\" ||\n+        //     function_name == \"shardCount\" || function_name == \"hostName\" || function_name == \"tcpPort\";\n \n         /** If function is suitable for constant folding try to convert it to constant.\n           * Example: SELECT plus(1, 1);\n           * Result: SELECT 2;\n           */\n-        if (function_base->isSuitableForConstantFolding() && !disable_constant_folding)\n+        if (function_base->isSuitableForConstantFolding()) // && !disable_constant_folding)\n         {\n             auto result_type = function_base->getResultType();\n             auto executable_function = function_base->prepare(argument_columns);\ndiff --git a/src/Functions/IFunction.h b/src/Functions/IFunction.h\nindex a66456cabeea..12931b51df2b 100644\n--- a/src/Functions/IFunction.h\n+++ b/src/Functions/IFunction.h\n@@ -230,6 +230,17 @@ class IFunctionBase : public IResolvedFunction\n \n     virtual bool isDeterministicInScopeOfQuery() const { return true; }\n \n+    /** This is a special flags for functions which return constant value for the server,\n+      * but the result could be different for different servers in distributed query.\n+      *\n+      * This functions can't support constant folding on the initiator, but can on the follower.\n+      * We can't apply some optimizations as well (e.g. can't remove constant result from GROUP BY key).\n+      * So, it is convenient to have a special flag for them.\n+      *\n+      * Examples are: \"__getScalar\" and every function from serverConstants.cpp\n+      */\n+    virtual bool isServerConstant() const { return false; }\n+\n     /** Lets you know if the function is monotonic in a range of values.\n       * This is used to work with the index in a sorted chunk of data.\n       * And allows to use the index not only when it is written, for example `date >= const`, but also, for example, `toMonth(date) >= 11`.\n@@ -488,6 +499,7 @@ class IFunction\n     virtual bool isInjective(const ColumnsWithTypeAndName & /*sample_columns*/) const { return false; }\n     virtual bool isDeterministic() const { return true; }\n     virtual bool isDeterministicInScopeOfQuery() const { return true; }\n+    virtual bool isServerConstant() const { return false; }\n     virtual bool isStateful() const { return false; }\n \n     using ShortCircuitSettings = IFunctionBase::ShortCircuitSettings;\ndiff --git a/src/Functions/IFunctionAdaptors.h b/src/Functions/IFunctionAdaptors.h\nindex 04bd03a776e8..c9929a083c12 100644\n--- a/src/Functions/IFunctionAdaptors.h\n+++ b/src/Functions/IFunctionAdaptors.h\n@@ -86,6 +86,8 @@ class FunctionToFunctionBaseAdaptor final : public IFunctionBase\n \n     bool isDeterministicInScopeOfQuery() const override { return function->isDeterministicInScopeOfQuery(); }\n \n+    bool isServerConstant() const override  { return function->isServerConstant(); }\n+\n     bool isShortCircuit(ShortCircuitSettings & settings, size_t number_of_arguments) const override { return function->isShortCircuit(settings, number_of_arguments); }\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & args) const override { return function->isSuitableForShortCircuitArgumentsExecution(args); }\ndiff --git a/src/Functions/getMacro.cpp b/src/Functions/getMacro.cpp\nindex 8172fc8ba2e8..b7f0b34d6523 100644\n--- a/src/Functions/getMacro.cpp\n+++ b/src/Functions/getMacro.cpp\n@@ -53,6 +53,8 @@ class FunctionGetMacro : public IFunction\n     /// getMacro may return different values on different shards/replicas, so it's not constant for distributed query\n     bool isSuitableForConstantFolding() const override { return !is_distributed; }\n \n+    bool isServerConstant() const override { return true; }\n+\n     size_t getNumberOfArguments() const override\n     {\n         return 1;\ndiff --git a/src/Functions/getScalar.cpp b/src/Functions/getScalar.cpp\nindex 7196cbc0a361..5131dca962e4 100644\n--- a/src/Functions/getScalar.cpp\n+++ b/src/Functions/getScalar.cpp\n@@ -49,6 +49,8 @@ class FunctionGetScalar : public IFunction, WithContext\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n+    bool isServerConstant() const override { return true; }\n+\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         if (arguments.size() != 1 || !isString(arguments[0].type) || !arguments[0].column || !isColumnConst(*arguments[0].column))\n@@ -105,6 +107,8 @@ class FunctionGetSpecialScalar : public IFunction\n \n     bool isDeterministic() const override { return false; }\n \n+    bool isServerConstant() const override { return true; }\n+\n     bool isSuitableForConstantFolding() const override { return !is_distributed; }\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\ndiff --git a/src/Functions/serverConstants.cpp b/src/Functions/serverConstants.cpp\nindex e7e423058f11..1e2c8c48babc 100644\n--- a/src/Functions/serverConstants.cpp\n+++ b/src/Functions/serverConstants.cpp\n@@ -20,117 +20,125 @@ namespace DB\n namespace\n {\n \n+    template<typename Derived, typename T, typename ColumnT>\n+    class FunctionServerConstantBase : public FunctionConstantBase<Derived, T, ColumnT>\n+    {\n+    public:\n+        using FunctionConstantBase<Derived, T, ColumnT>::FunctionConstantBase;\n+        bool isServerConstant() const override { return true; }\n+    };\n+\n #if defined(__ELF__) && !defined(OS_FREEBSD)\n     /// buildId() - returns the compiler build id of the running binary.\n-    class FunctionBuildId : public FunctionConstantBase<FunctionBuildId, String, DataTypeString>\n+    class FunctionBuildId : public FunctionServerConstantBase<FunctionBuildId, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"buildId\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionBuildId>(context); }\n-        explicit FunctionBuildId(ContextPtr context) : FunctionConstantBase(SymbolIndex::instance().getBuildIDHex(), context->isDistributed()) {}\n+        explicit FunctionBuildId(ContextPtr context) : FunctionServerConstantBase(SymbolIndex::instance().getBuildIDHex(), context->isDistributed()) {}\n     };\n #endif\n \n \n     /// Get the host name. It is constant on single server, but is not constant in distributed queries.\n-    class FunctionHostName : public FunctionConstantBase<FunctionHostName, String, DataTypeString>\n+    class FunctionHostName : public FunctionServerConstantBase<FunctionHostName, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"hostName\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionHostName>(context); }\n-        explicit FunctionHostName(ContextPtr context) : FunctionConstantBase(DNSResolver::instance().getHostName(), context->isDistributed()) {}\n+        explicit FunctionHostName(ContextPtr context) : FunctionServerConstantBase(DNSResolver::instance().getHostName(), context->isDistributed()) {}\n     };\n \n \n-    class FunctionServerUUID : public FunctionConstantBase<FunctionServerUUID, UUID, DataTypeUUID>\n+    class FunctionServerUUID : public FunctionServerConstantBase<FunctionServerUUID, UUID, DataTypeUUID>\n     {\n     public:\n         static constexpr auto name = \"serverUUID\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionServerUUID>(context); }\n-        explicit FunctionServerUUID(ContextPtr context) : FunctionConstantBase(ServerUUID::get(), context->isDistributed()) {}\n+        explicit FunctionServerUUID(ContextPtr context) : FunctionServerConstantBase(ServerUUID::get(), context->isDistributed()) {}\n     };\n \n \n-    class FunctionTCPPort : public FunctionConstantBase<FunctionTCPPort, UInt16, DataTypeUInt16>\n+    class FunctionTCPPort : public FunctionServerConstantBase<FunctionTCPPort, UInt16, DataTypeUInt16>\n     {\n     public:\n         static constexpr auto name = \"tcpPort\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionTCPPort>(context); }\n-        explicit FunctionTCPPort(ContextPtr context) : FunctionConstantBase(context->getTCPPort(), context->isDistributed()) {}\n+        explicit FunctionTCPPort(ContextPtr context) : FunctionServerConstantBase(context->getTCPPort(), context->isDistributed()) {}\n     };\n \n \n     /// Returns timezone for current session.\n-    class FunctionTimezone : public FunctionConstantBase<FunctionTimezone, String, DataTypeString>\n+    class FunctionTimezone : public FunctionServerConstantBase<FunctionTimezone, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"timezone\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionTimezone>(context); }\n-        explicit FunctionTimezone(ContextPtr context) : FunctionConstantBase(DateLUT::instance().getTimeZone(), context->isDistributed()) {}\n+        explicit FunctionTimezone(ContextPtr context) : FunctionServerConstantBase(DateLUT::instance().getTimeZone(), context->isDistributed()) {}\n     };\n \n     /// Returns the server time zone (timezone in which server runs).\n-    class FunctionServerTimezone : public FunctionConstantBase<FunctionServerTimezone, String, DataTypeString>\n+    class FunctionServerTimezone : public FunctionServerConstantBase<FunctionServerTimezone, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"serverTimezone\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionServerTimezone>(context); }\n-        explicit FunctionServerTimezone(ContextPtr context) : FunctionConstantBase(DateLUT::serverTimezoneInstance().getTimeZone(), context->isDistributed()) {}\n+        explicit FunctionServerTimezone(ContextPtr context) : FunctionServerConstantBase(DateLUT::serverTimezoneInstance().getTimeZone(), context->isDistributed()) {}\n     };\n \n \n     /// Returns server uptime in seconds.\n-    class FunctionUptime : public FunctionConstantBase<FunctionUptime, UInt32, DataTypeUInt32>\n+    class FunctionUptime : public FunctionServerConstantBase<FunctionUptime, UInt32, DataTypeUInt32>\n     {\n     public:\n         static constexpr auto name = \"uptime\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionUptime>(context); }\n-        explicit FunctionUptime(ContextPtr context) : FunctionConstantBase(context->getUptimeSeconds(), context->isDistributed()) {}\n+        explicit FunctionUptime(ContextPtr context) : FunctionServerConstantBase(context->getUptimeSeconds(), context->isDistributed()) {}\n     };\n \n \n     /// version() - returns the current version as a string.\n-    class FunctionVersion : public FunctionConstantBase<FunctionVersion, String, DataTypeString>\n+    class FunctionVersion : public FunctionServerConstantBase<FunctionVersion, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"version\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionVersion>(context); }\n-        explicit FunctionVersion(ContextPtr context) : FunctionConstantBase(VERSION_STRING, context->isDistributed()) {}\n+        explicit FunctionVersion(ContextPtr context) : FunctionServerConstantBase(VERSION_STRING, context->isDistributed()) {}\n     };\n \n     /// revision() - returns the current revision.\n-    class FunctionRevision : public FunctionConstantBase<FunctionRevision, UInt32, DataTypeUInt32>\n+    class FunctionRevision : public FunctionServerConstantBase<FunctionRevision, UInt32, DataTypeUInt32>\n     {\n     public:\n         static constexpr auto name = \"revision\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionRevision>(context); }\n-        explicit FunctionRevision(ContextPtr context) : FunctionConstantBase(ClickHouseRevision::getVersionRevision(), context->isDistributed()) {}\n+        explicit FunctionRevision(ContextPtr context) : FunctionServerConstantBase(ClickHouseRevision::getVersionRevision(), context->isDistributed()) {}\n     };\n \n-    class FunctionZooKeeperSessionUptime : public FunctionConstantBase<FunctionZooKeeperSessionUptime, UInt32, DataTypeUInt32>\n+    class FunctionZooKeeperSessionUptime : public FunctionServerConstantBase<FunctionZooKeeperSessionUptime, UInt32, DataTypeUInt32>\n     {\n     public:\n         static constexpr auto name = \"zookeeperSessionUptime\";\n         explicit FunctionZooKeeperSessionUptime(ContextPtr context)\n-            : FunctionConstantBase(context->getZooKeeperSessionUptime(), context->isDistributed())\n+            : FunctionServerConstantBase(context->getZooKeeperSessionUptime(), context->isDistributed())\n         {\n         }\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionZooKeeperSessionUptime>(context); }\n     };\n \n-    class FunctionGetOSKernelVersion : public FunctionConstantBase<FunctionGetOSKernelVersion, String, DataTypeString>\n+    class FunctionGetOSKernelVersion : public FunctionServerConstantBase<FunctionGetOSKernelVersion, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"getOSKernelVersion\";\n-        explicit FunctionGetOSKernelVersion(ContextPtr context) : FunctionConstantBase(Poco::Environment::osName() + \" \" + Poco::Environment::osVersion(), context->isDistributed()) {}\n+        explicit FunctionGetOSKernelVersion(ContextPtr context) : FunctionServerConstantBase(Poco::Environment::osName() + \" \" + Poco::Environment::osVersion(), context->isDistributed()) {}\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionGetOSKernelVersion>(context); }\n     };\n \n-    class FunctionDisplayName : public FunctionConstantBase<FunctionDisplayName, String, DataTypeString>\n+    class FunctionDisplayName : public FunctionServerConstantBase<FunctionDisplayName, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"displayName\";\n-        explicit FunctionDisplayName(ContextPtr context) : FunctionConstantBase(context->getConfigRef().getString(\"display_name\", getFQDNOrHostName()), context->isDistributed()) {}\n+        explicit FunctionDisplayName(ContextPtr context) : FunctionServerConstantBase(context->getConfigRef().getString(\"display_name\", getFQDNOrHostName()), context->isDistributed()) {}\n         static FunctionPtr create(ContextPtr context) {return std::make_shared<FunctionDisplayName>(context); }\n     };\n }\ndiff --git a/src/Planner/PlannerExpressionAnalysis.cpp b/src/Planner/PlannerExpressionAnalysis.cpp\nindex ceb506d1bbb9..f0de3e691137 100644\n--- a/src/Planner/PlannerExpressionAnalysis.cpp\n+++ b/src/Planner/PlannerExpressionAnalysis.cpp\n@@ -85,14 +85,14 @@ bool canRemoveConstantFromGroupByKey(const ConstantNode & root)\n         else if (function_node)\n         {\n             /// Do not allow removing constants like `hostName()`\n-            if (!function_node->getFunctionOrThrow()->isDeterministic())\n+            if (function_node->getFunctionOrThrow()->isServerConstant())\n                 return false;\n \n             for (const auto & child : function_node->getArguments())\n                 nodes.push(child.get());\n         }\n-        else\n-            return false;\n+        // else\n+        //     return false;\n     }\n \n     return true;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02992_analyzer_group_by_const.sql b/tests/queries/0_stateless/02992_analyzer_group_by_const.sql\nindex ede6e0deed99..2a9e673d7bc7 100644\n--- a/tests/queries/0_stateless/02992_analyzer_group_by_const.sql\n+++ b/tests/queries/0_stateless/02992_analyzer_group_by_const.sql\n@@ -30,3 +30,46 @@ SELECT\n     min(dummy)\n FROM remote('127.0.0.{2,3}', system.one)\n GROUP BY y;\n+\n+CREATE TABLE ttt (hr DateTime, ts DateTime) ENGINE=Memory\n+as select '2000-01-01' d, d;\n+\n+SELECT\n+    count(),\n+    now() AS c1\n+FROM remote('127.0.0.{1,2}', currentDatabase(), ttt)\n+GROUP BY c1 FORMAT Null;\n+\n+SELECT\n+    count(),\n+    now() AS c1\n+FROM remote('127.0.0.{3,2}', currentDatabase(), ttt)\n+GROUP BY c1 FORMAT Null;\n+\n+SELECT\n+    count(),\n+    now() AS c1\n+FROM remote('127.0.0.{1,2}', currentDatabase(), ttt)\n+GROUP BY c1 + 1 FORMAT Null;\n+\n+SELECT\n+    count(),\n+    now() AS c1\n+FROM remote('127.0.0.{3,2}', currentDatabase(), ttt)\n+GROUP BY c1 + 1 FORMAT Null;\n+\n+SELECT\n+  count(),\n+  tuple(nullIf(toDateTime(formatDateTime(hr, '%F %T', 'America/Los_Angeles'), 'America/Los_Angeles'), toDateTime(0)))  as c1,\n+  defaultValueOfArgumentType(toTimeZone(ts, 'America/Los_Angeles'))  as c2,\n+  formatDateTime(hr, '%F %T', 'America/Los_Angeles')  as c3\n+FROM   remote('127.0.0.{1,2}', currentDatabase(),  ttt)\n+GROUP BY c1, c2, c3 FORMAT Null;\n+\n+SELECT\n+  count(),\n+  tuple(nullIf(toDateTime(formatDateTime(hr, '%F %T', 'America/Los_Angeles'), 'America/Los_Angeles'), toDateTime(0)))  as c1,\n+  defaultValueOfArgumentType(toTimeZone(ts, 'America/Los_Angeles'))  as c2,\n+  formatDateTime(hr, '%F %T', 'America/Los_Angeles')  as c3\n+FROM   remote('127.0.0.{3,2}', currentDatabase(),  ttt)\n+GROUP BY c1, c2, c3 FORMAT Null;\n",
  "problem_statement": "Cannot find column _CAST with allow_experimental_analyzer\n24.6.1\r\n\r\n```sql\r\nCREATE TABLE t (hr DateTime, ts DateTime) ENGINE=Memory\r\nas select '2000-01-01' d, d;\r\n```\r\n\r\nQ1) Not distributed table + analyzer https://fiddle.clickhouse.com/7e58d62f-4442-4a1a-ae49-20a38a0c649b\r\nexpected result, all OK:\r\n\r\n```sql\r\nSELECT\r\n  count(),\r\n  tuple(nullIf(toDateTime(formatDateTime(hr, '%F %T', 'America/Los_Angeles'), 'America/Los_Angeles'), toDateTime(0)))  as c1,\r\n  defaultValueOfArgumentType(toTimeZone(ts, 'America/Los_Angeles'))  as c2,\r\n  formatDateTime(hr, '%F %T', 'America/Los_Angeles')  as c3\r\nFROM   t\r\nGROUP BY c1, c2, c3\r\nsettings allow_experimental_analyzer=1 \r\nformat Pretty;\r\n\r\n   +---------+-------------------------+---------------------+---------------------+\r\n   | count() | c1                      |                  c2 | c3                  |\r\n   +---------+-------------------------+---------------------+---------------------+\r\n1. |       1 | ('1999-12-31 16:00:00') | 1969-12-31 16:00:00 | 1999-12-31 16:00:00 |\r\n   +---------+-------------------------+---------------------+---------------------+\r\n```\r\n\r\nQ2) distributed table + analyzer  https://fiddle.clickhouse.com/e8a9dfea-1ff5-4614-a4ef-8449cfda66f3\r\n\r\n```sql\r\nSELECT\r\n  count(),\r\n  tuple(nullIf(toDateTime(formatDateTime(hr, '%F %T', 'America/Los_Angeles'), 'America/Los_Angeles'), toDateTime(0)))  as c1,\r\n  defaultValueOfArgumentType(toTimeZone(ts, 'America/Los_Angeles'))  as c2,\r\n  formatDateTime(hr, '%F %T', 'America/Los_Angeles')  as c3\r\nFROM   remote('127.0.0.{1,2}', default,  t)\r\nGROUP BY c1, c2, c3\r\nsettings allow_experimental_analyzer=1;\r\n\r\nDB::Exception: THERE_IS_NO_COLUMN\r\n```\r\n\r\nQ3)  Not distributed table + No analyzer https://fiddle.clickhouse.com/ca357000-b2c9-4897-8468-4d32bcad2062\r\n\r\n```sql\r\nSELECT\r\n   count(),\r\n   tuple(nullIf(toDateTime(formatDateTime(hr, '%F %T', 'America/Los_Angeles'), 'America/Los_Angeles'), toDateTime(0)))  as c1,\r\n   defaultValueOfArgumentType(toTimeZone(ts, 'America/Los_Angeles'))  as c2,\r\n   formatDateTime(hr, '%F %T', 'America/Los_Angeles')  as c3\r\nFROM t\r\nGROUP BY c1, c2, c3\r\nsettings allow_experimental_analyzer=0;\r\n\r\nDB::Exception: Column `ts` is not under aggregate function and not in GROUP BY\r\n```\r\n\r\n----\r\n\r\nProbably it's another/known issue https://fiddle.clickhouse.com/fa39a068-cfc1-4eab-8d7f-c848c5ba9092\r\n\r\n```sql\r\nCREATE TABLE t (hr DateTime, ts DateTime) ENGINE=Memory\r\nas select '2000-01-01' d, d;\r\n\r\nSELECT\r\n     count(),\r\n     now() as c1\r\nFROM remote('127.0.0.{1,2}', default,  t)\r\nGROUP BY c1\r\nsettings allow_experimental_analyzer=1;\r\n\r\nDB::Exception: Cannot find column `_CAST(1718827653_DateTime\r\n```\r\n\n",
  "hints_text": "Broken between 24.4.1 and 24.4.2\r\nhttps://fiddle.clickhouse.com/1f8fed05-0e1a-4515-8e3c-5af31654e757\nI see. It worked in `24.3.3.102` https://fiddle.clickhouse.com/9efe251e-3bbe-433a-8d14-3ab55baa8ec0\r\nand it's broken in `24.3.4.147` https://fiddle.clickhouse.com/5c8ae9e3-7428-4d88-964e-79d7d930b462\r\n\r\nmaybe it should be separate issue.",
  "created_at": "2024-07-12T10:51:31Z",
  "modified_files": [
    "src/Analyzer/Resolve/QueryAnalyzer.cpp",
    "src/Functions/IFunction.h",
    "src/Functions/IFunctionAdaptors.h",
    "src/Functions/getMacro.cpp",
    "src/Functions/getScalar.cpp",
    "src/Functions/serverConstants.cpp",
    "src/Planner/PlannerExpressionAnalysis.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02992_analyzer_group_by_const.sql"
  ]
}