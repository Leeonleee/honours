diff --git a/docs/en/sql-reference/functions/arithmetic-functions.md b/docs/en/sql-reference/functions/arithmetic-functions.md
index 69f1816b7dfa..1aa9c982f33f 100644
--- a/docs/en/sql-reference/functions/arithmetic-functions.md
+++ b/docs/en/sql-reference/functions/arithmetic-functions.md
@@ -441,3 +441,40 @@ DB::Exception: Decimal result's scale is less than argument's one: While process
 │ -12 │ 2.1 │                                                       -5.7 │                                                   -5.71428 │
 └─────┴─────┴────────────────────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
 ```
+
+## byteSwap
+
+Reverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness). Currently, integers of up to 64 bit are supported.
+
+**Syntax**
+
+```sql
+byteSwap(a)
+```
+
+**Example**
+
+```sql
+byteSwap(3351772109)
+```
+
+Result:
+
+```result
+┌─byteSwap(3351772109)─┐
+│           3455829959 │
+└──────────────────────┘
+```
+
+The above example can be worked out in the following manner:
+1. Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)
+2. Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7
+3. Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7  -> 3455829959
+
+One use case of this function is reversing IPv4s:
+
+```result
+┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
+│ 199.199.251.205                                       │
+└───────────────────────────────────────────────────────┘
+```
diff --git a/src/Functions/byteSwap.cpp b/src/Functions/byteSwap.cpp
new file mode 100644
index 000000000000..bdc6eb6c3864
--- /dev/null
+++ b/src/Functions/byteSwap.cpp
@@ -0,0 +1,97 @@
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionUnaryArithmetic.h>
+
+namespace DB
+{
+namespace ErrorCodes
+{
+extern const int NOT_IMPLEMENTED;
+}
+
+namespace
+{
+template <typename T>
+requires std::is_integral_v<T>
+T byteSwap(T x)
+{
+    return std::byteswap(x);
+}
+
+template <typename T>
+T byteSwap(T)
+{
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "byteSwap() is not implemented for {} datatype", demangle(typeid(T).name()));
+}
+
+template <typename T>
+struct ByteSwapImpl
+{
+    using ResultType = T;
+    static constexpr const bool allow_string_or_fixed_string = false;
+    static T apply(T x) { return byteSwap<T>(x); }
+
+#if USE_EMBEDDED_COMPILER
+    static constexpr bool compilable = false;
+#endif
+};
+
+struct NameByteSwap
+{
+    static constexpr auto name = "byteSwap";
+};
+using FunctionByteSwap = FunctionUnaryArithmetic<ByteSwapImpl, NameByteSwap, true>;
+
+}
+
+template <>
+struct FunctionUnaryArithmeticMonotonicity<NameByteSwap>
+{
+    static bool has() { return false; }
+    static IFunction::Monotonicity get(const Field &, const Field &) { return {}; }
+};
+
+REGISTER_FUNCTION(ByteSwap)
+{
+    factory.registerFunction<FunctionByteSwap>(
+        FunctionDocumentation{
+            .description = R"(
+Reverses the bytes of an integer, i.e. changes its [endianness](https://en.wikipedia.org/wiki/Endianness). Currently, integers of up to 64 bit are supported.
+
+**Example**
+
+```sql
+byteSwap(3351772109)
+```
+
+Result:
+
+```result
+┌─byteSwap(3351772109)─┐
+│           3455829959 │
+└──────────────────────┘
+```
+
+The above example can be worked out in the following manner:
+1. Convert the base-10 integer to its equivalent hexadecimal format in big-endian format, i.e. 3351772109 -> C7 C7 FB CD (4 bytes)
+2. Reverse the bytes, i.e. C7 C7 FB CD -> CD FB C7 C7
+3. Convert the result back to an integer assuming big-endian, i.e. CD FB C7 C7  -> 3455829959
+
+One use-case of this function is reversing IPv4s:
+
+```result
+┌─toIPv4(byteSwap(toUInt32(toIPv4('205.251.199.199'))))─┐
+│ 199.199.251.205                                       │
+└───────────────────────────────────────────────────────┘
+```
+)",
+            .examples{
+                {"8-bit", "SELECT byteSwap(54)", "54"},
+                {"16-bit", "SELECT byteSwap(4135)", "10000"},
+                {"32-bit", "SELECT byteSwap(3351772109)", "3455829959"},
+                {"64-bit", "SELECT byteSwap(123294967295)", "18439412204227788800"},
+            },
+            .categories{"Mathematical", "Arithmetic"}},
+        FunctionFactory::CaseInsensitive);
+}
+
+}
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index e5a031dabe3e..d4a307c15da2 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1176,6 +1176,7 @@ buildId
 buildable
 builtins
 byteSize
+byteSwap
 bytebase
 bytesToCutForIPv
 cLoki
@@ -1414,6 +1415,7 @@ encodeXMLComponent
 encodings
 encryptions
 endian
+endianness
 endsWith
 endsWithUTF
 enum
