diff --git a/src/Backups/BackupIO_AzureBlobStorage.cpp b/src/Backups/BackupIO_AzureBlobStorage.cpp
index a9716ff02cab..7444828669f0 100644
--- a/src/Backups/BackupIO_AzureBlobStorage.cpp
+++ b/src/Backups/BackupIO_AzureBlobStorage.cpp
@@ -26,6 +26,48 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
+/// This function compares the authorization methods used to access AzureBlobStorage
+/// It takes 2 variables of variant type as input and checks if they are the same type and value
+static bool compareAuthMethod (AzureBlobStorage::AuthMethod auth_method_a, AzureBlobStorage::AuthMethod auth_method_b)
+{
+    const auto * conn_string_a = std::get_if<AzureBlobStorage::ConnectionString>(&auth_method_a);
+    const auto * conn_string_b = std::get_if<AzureBlobStorage::ConnectionString>(&auth_method_b);
+
+    if (conn_string_a && conn_string_b)
+    {
+        return *conn_string_a == *conn_string_b;
+    }
+
+    const auto * shared_key_a = std::get_if<std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>>(&auth_method_a);
+    const auto * shared_key_b = std::get_if<std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>>(&auth_method_b);
+
+    if (shared_key_a && shared_key_b)
+    {
+        return (shared_key_a->get()->AccountName == shared_key_b->get()->AccountName);
+    }
+
+    const auto * workload_identity_a = std::get_if<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(&auth_method_a);
+    const auto * workload_identity_b = std::get_if<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(&auth_method_b);
+
+    if (workload_identity_a && workload_identity_b)
+    {
+        Azure::Core::Credentials::TokenRequestContext tokenRequestContext;
+        return workload_identity_a->get()->GetToken(tokenRequestContext, {}).Token == workload_identity_b->get()->GetToken(tokenRequestContext, {}).Token;
+    }
+
+    const auto * managed_identity_a = std::get_if<std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>(&auth_method_a);
+    const auto * managed_identity_b = std::get_if<std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>(&auth_method_b);
+
+    if (managed_identity_a && managed_identity_b)
+    {
+        Azure::Core::Credentials::TokenRequestContext tokenRequestContext;
+        return managed_identity_a->get()->GetToken(tokenRequestContext, {}).Token == managed_identity_b->get()->GetToken(tokenRequestContext, {}).Token;
+    }
+
+    return false;
+
+}
+
 BackupReaderAzureBlobStorage::BackupReaderAzureBlobStorage(
     const AzureBlobStorage::ConnectionParams & connection_params_,
     const String & blob_path_,
@@ -39,10 +81,11 @@ BackupReaderAzureBlobStorage::BackupReaderAzureBlobStorage(
     , blob_path(blob_path_)
 {
     auto client_ptr = AzureBlobStorage::getContainerClient(connection_params, /*readonly=*/ false);
-    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_->getSettingsRef(), allow_azure_native_copy);
+    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_, connection_params.endpoint.storage_account_url, allow_azure_native_copy);
 
     object_storage = std::make_unique<AzureObjectStorage>(
         "BackupReaderAzureBlobStorage",
+        connection_params.auth_method,
         std::move(client_ptr),
         std::move(settings_ptr),
         connection_params.getContainer(),
@@ -103,6 +146,7 @@ void BackupReaderAzureBlobStorage::copyFileToDisk(const String & path_in_backup,
                 /* dest_path */ dst_blob_path[0],
                 settings,
                 read_settings,
+                compareAuthMethod(connection_params.auth_method, destination_disk->getObjectStorage()->getAzureBlobStorageAuthMethod()),
                 threadPoolCallbackRunnerUnsafe<void>(getBackupsIOThreadPool().get(), "BackupRDAzure"));
 
             return file_size;
@@ -134,15 +178,17 @@ BackupWriterAzureBlobStorage::BackupWriterAzureBlobStorage(
         connection_params.endpoint.container_already_exists = true;
 
     auto client_ptr = AzureBlobStorage::getContainerClient(connection_params, /*readonly=*/ false);
-    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_->getSettingsRef(), allow_azure_native_copy);
+    auto settings_ptr = AzureBlobStorage::getRequestSettingsForBackup(context_, connection_params.endpoint.storage_account_url, allow_azure_native_copy);
 
     object_storage = std::make_unique<AzureObjectStorage>(
         "BackupWriterAzureBlobStorage",
+        connection_params.auth_method,
         std::move(client_ptr),
         std::move(settings_ptr),
         connection_params.getContainer(),
         connection_params.getConnectionURL());
 
+
     client = object_storage->getAzureBlobStorageClient();
     settings = object_storage->getSettings();
 }
@@ -177,6 +223,7 @@ void BackupWriterAzureBlobStorage::copyFileFromDisk(
                 fs::path(blob_path) / path_in_backup,
                 settings,
                 read_settings,
+                compareAuthMethod(src_disk->getObjectStorage()->getAzureBlobStorageAuthMethod(), connection_params.auth_method),
                 threadPoolCallbackRunnerUnsafe<void>(getBackupsIOThreadPool().get(), "BackupWRAzure"));
             return; /// copied!
         }
@@ -200,6 +247,7 @@ void BackupWriterAzureBlobStorage::copyFile(const String & destination, const St
        /* dest_path */ destination,
        settings,
        read_settings,
+       true,
        threadPoolCallbackRunnerUnsafe<void>(getBackupsIOThreadPool().get(), "BackupWRAzure"));
 }
 
diff --git a/src/Backups/BackupsWorker.cpp b/src/Backups/BackupsWorker.cpp
index 0b968a3d6a79..fc82128b8bed 100644
--- a/src/Backups/BackupsWorker.cpp
+++ b/src/Backups/BackupsWorker.cpp
@@ -866,6 +866,7 @@ BackupPtr BackupsWorker::openBackupForReading(const BackupInfo & backup_info, co
     backup_open_params.base_backup_info = restore_settings.base_backup_info;
     backup_open_params.password = restore_settings.password;
     backup_open_params.allow_s3_native_copy = restore_settings.allow_s3_native_copy;
+    backup_open_params.allow_azure_native_copy = restore_settings.allow_azure_native_copy;
     backup_open_params.use_same_s3_credentials_for_base_backup = restore_settings.use_same_s3_credentials_for_base_backup;
     backup_open_params.use_same_password_for_base_backup = restore_settings.use_same_password_for_base_backup;
     backup_open_params.read_settings = getReadSettingsForRestore(context);
diff --git a/src/Backups/RestoreSettings.cpp b/src/Backups/RestoreSettings.cpp
index f77ac876f01f..ee6531d8111b 100644
--- a/src/Backups/RestoreSettings.cpp
+++ b/src/Backups/RestoreSettings.cpp
@@ -164,6 +164,7 @@ namespace
     M(Bool, skip_unresolved_access_dependencies) \
     M(Bool, update_access_entities_dependents) \
     M(RestoreUDFCreationMode, create_function) \
+    M(Bool, allow_azure_native_copy) \
     M(Bool, allow_s3_native_copy) \
     M(Bool, use_same_s3_credentials_for_base_backup) \
     M(Bool, use_same_password_for_base_backup) \
diff --git a/src/Backups/RestoreSettings.h b/src/Backups/RestoreSettings.h
index b5456db8296f..1b3b5bae47dc 100644
--- a/src/Backups/RestoreSettings.h
+++ b/src/Backups/RestoreSettings.h
@@ -127,6 +127,9 @@ struct RestoreSettings
     /// Whether native copy is allowed (optimization for cloud storages, that sometimes could have bugs)
     bool allow_s3_native_copy = true;
 
+    /// Whether native copy is allowed for AzureBlobStorage
+    bool allow_azure_native_copy = true;
+
     /// Whether base backup from S3 should inherit credentials from the RESTORE query.
     bool use_same_s3_credentials_for_base_backup = false;
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 27954fbcc50f..0f7a3cf851b1 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -104,6 +104,7 @@ add_headers_and_sources(clickhouse_common_io IO/Archives)
 add_headers_and_sources(clickhouse_common_io IO/Protobuf)
 add_headers_and_sources(clickhouse_common_io IO/S3)
 add_headers_and_sources(clickhouse_common_io IO/AzureBlobStorage)
+add_headers_and_sources(clickhouse_common_io Disks/ObjectStorages/AzureBlobStorage)
 list (REMOVE_ITEM clickhouse_common_io_sources Common/malloc.cpp Common/new_delete.cpp)
 
 
diff --git a/src/Client/BuzzHouse/Generator/TableSetttings.cpp b/src/Client/BuzzHouse/Generator/TableSetttings.cpp
index e6a37d59d1e3..80cdc372086c 100644
--- a/src/Client/BuzzHouse/Generator/TableSetttings.cpp
+++ b/src/Client/BuzzHouse/Generator/TableSetttings.cpp
@@ -199,7 +199,8 @@ static std::unordered_map<String, CHSetting> mergeTreeTableSettings
 std::unordered_map<TableEngineValues, std::unordered_map<String, CHSetting>> allTableSettings;
 
 std::unordered_map<String, CHSetting> restoreSettings
-    = {{"allow_different_database_def", CHSetting(trueOrFalse, {}, false)},
+    = {{"allow_azure_native_copy", CHSetting(trueOrFalse, {}, false)},
+       {"allow_different_database_def", CHSetting(trueOrFalse, {}, false)},
        {"allow_different_table_def", CHSetting(trueOrFalse, {}, false)},
        {"allow_non_empty_tables", CHSetting(trueOrFalse, {}, false)},
        {"allow_s3_native_copy", CHSetting(trueOrFalse, {}, false)},
diff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp
index f6c2c6fdeea4..90ea8844356a 100644
--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp
+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.cpp
@@ -2,16 +2,23 @@
 
 #if USE_AZURE_BLOB_STORAGE
 
+#include <azure/identity/managed_identity_credential.hpp>
+#include <azure/identity/workload_identity_credential.hpp>
+#include <azure/storage/blobs/blob_options.hpp>
+#include <azure/storage/blobs/blob_responses.hpp>
+#include <azure/storage/blobs/rest_client.hpp>
+#include <azure/core/credentials/credentials.hpp>
+
+#endif
+
 #include <Common/Exception.h>
 #include <Common/ProfileEvents.h>
 #include <Common/re2.h>
 #include <Core/Settings.h>
-#include <azure/identity/managed_identity_credential.hpp>
-#include <azure/identity/workload_identity_credential.hpp>
-#include <azure/storage/blobs/blob_options.hpp>
 #include <Poco/Util/AbstractConfiguration.h>
 #include <Interpreters/Context.h>
 #include <filesystem>
+#include <Common/logger_useful.h>
 
 namespace ProfileEvents
 {
@@ -54,6 +61,8 @@ namespace ErrorCodes
 namespace AzureBlobStorage
 {
 
+#if USE_AZURE_BLOB_STORAGE
+
 static void validateStorageAccountUrl(const String & storage_account_url)
 {
     const auto * storage_account_url_pattern_str = R"(http(()|s)://[a-z0-9-.:]+(()|/)[a-z0-9]*(()|/))";
@@ -403,6 +412,8 @@ BlobClientOptions getClientOptions(const RequestSettings & settings, bool for_di
     return client_options;
 }
 
+#endif
+
 std::unique_ptr<RequestSettings> getRequestSettings(const Settings & query_settings)
 {
     auto settings = std::make_unique<RequestSettings>();
@@ -428,17 +439,23 @@ std::unique_ptr<RequestSettings> getRequestSettings(const Settings & query_setti
     return settings;
 }
 
-std::unique_ptr<RequestSettings> getRequestSettingsForBackup(const Settings & query_settings, bool use_native_copy)
+std::unique_ptr<RequestSettings> getRequestSettingsForBackup(ContextPtr context, String endpoint, bool use_native_copy)
 {
-    auto settings = getRequestSettings(query_settings);
-    settings->use_native_copy = use_native_copy;
+    auto settings = getRequestSettings(context->getSettingsRef());
+
+    auto endpoint_settings = context->getStorageAzureSettings().getSettings(endpoint);
+    if (endpoint_settings)
+        settings->use_native_copy = endpoint_settings->use_native_copy;
+
+    if (!use_native_copy)
+        settings->use_native_copy = false;
+
     return settings;
 }
 
-std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, ContextPtr context)
+std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, const Settings & settings_ref)
 {
     auto settings = std::make_unique<RequestSettings>();
-    const auto & settings_ref = context->getSettingsRef();
 
     settings->min_bytes_for_seek = config.getUInt64(config_prefix + ".min_bytes_for_seek", 1024 * 1024);
     settings->use_native_copy = config.getBool(config_prefix + ".use_native_copy", false);
@@ -464,6 +481,8 @@ std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractCo
 
     settings->check_objects_after_upload = config.getBool(config_prefix + ".check_objects_after_upload", settings_ref[Setting::azure_check_objects_after_upload]);
 
+
+#if USE_AZURE_BLOB_STORAGE
     if (config.has(config_prefix + ".curl_ip_resolve"))
     {
         using CurlOptions = Azure::Core::Http::CurlTransportOptions;
@@ -476,12 +495,76 @@ std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractCo
         else
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unexpected value for option 'curl_ip_resolve': {}. Expected one of 'ipv4' or 'ipv6'", value);
     }
+#endif
 
     return settings;
 }
 
 }
 
+
+void AzureSettingsByEndpoint::loadFromConfig(
+    const Poco::Util::AbstractConfiguration & config,
+    const std::string & config_prefix,
+    const DB::Settings & settings)
+{
+    std::lock_guard lock(mutex);
+    azure_settings.clear();
+    if (!config.has(config_prefix))
+        return;
+
+
+    Poco::Util::AbstractConfiguration::Keys config_keys;
+    config.keys(config_prefix, config_keys);
+
+    for (const String & key : config_keys)
+    {
+        const auto key_path = config_prefix + "." + key;
+        String endpoint_path = key_path + ".connection_string";
+
+        if (!config.has(endpoint_path))
+        {
+            endpoint_path = key_path + ".storage_account_url";
+
+            if (!config.has(endpoint_path))
+            {
+                endpoint_path = key_path + ".endpoint";
+
+                if (!config.has(endpoint_path))
+                {
+                    /// Error, shouldn't hit this todo:: throw error
+                    continue;
+                }
+            }
+        }
+
+        auto request_settings = AzureBlobStorage::getRequestSettings(config, key_path, settings);
+
+        azure_settings.emplace(
+                config.getString(endpoint_path),
+                std::move(*request_settings));
+
+    }
+}
+
+std::optional<AzureBlobStorage::RequestSettings> AzureSettingsByEndpoint::getSettings(
+    const String & endpoint) const
+{
+    std::lock_guard lock(mutex);
+    auto next_prefix_setting = azure_settings.upper_bound(endpoint);
+
+    /// Linear time algorithm may be replaced with logarithmic with prefix tree map.
+    for (auto possible_prefix_setting = next_prefix_setting; possible_prefix_setting != azure_settings.begin();)
+    {
+        std::advance(possible_prefix_setting, -1);
+        const auto & [endpoint_prefix, settings] = *possible_prefix_setting;
+        if (endpoint.starts_with(endpoint_prefix))
+            return possible_prefix_setting->second;
+    }
+
+    return {};
+}
+
 }
 
-#endif
+
diff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h
index cc9b102ee2a9..2808ffc4bf63 100644
--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h
+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h
@@ -4,14 +4,17 @@
 #if USE_AZURE_BLOB_STORAGE
 
 #include <azure/storage/blobs.hpp>
+#include <azure/core/response.hpp>
 #include <azure/storage/blobs/blob_client.hpp>
 #include <azure/storage/blobs/blob_options.hpp>
 #include <azure/storage/blobs/blob_service_client.hpp>
 #include <azure/core/http/curl_transport.hpp>
-#include <azure/identity/managed_identity_credential.hpp>
-#include <azure/identity/workload_identity_credential.hpp>
+
+#endif
+
 
 #include <Poco/Util/AbstractConfiguration.h>
+#include <Disks/ObjectStorages/IObjectStorage.h>
 #include <Interpreters/Context_fwd.h>
 #include <base/strong_typedef.h>
 #include <filesystem>
@@ -52,8 +55,10 @@ struct RequestSettings
     bool check_objects_after_upload = false;
     bool read_only = false;
 
+#if USE_AZURE_BLOB_STORAGE
     using CurlOptions = Azure::Core::Http::CurlTransportOptions;
     CurlOptions::CurlOptIPResolve curl_ip_resolve = CurlOptions::CURL_IPRESOLVE_WHATEVER;
+#endif
 };
 
 struct Endpoint
@@ -97,6 +102,8 @@ struct Endpoint
     }
 };
 
+#if USE_AZURE_BLOB_STORAGE
+
 using BlobClient = Azure::Storage::Blobs::BlobClient;
 using BlockBlobClient = Azure::Storage::Blobs::BlockBlobClient;
 using RawContainerClient = Azure::Storage::Blobs::BlobContainerClient;
@@ -126,13 +133,6 @@ class ContainerClientWrapper
 using ContainerClient = ContainerClientWrapper;
 using ServiceClient = Azure::Storage::Blobs::BlobServiceClient;
 using BlobClientOptions = Azure::Storage::Blobs::BlobClientOptions;
-using ConnectionString = StrongTypedef<String, struct ConnectionStringTag>;
-
-using AuthMethod = std::variant<
-    ConnectionString,
-    std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>,
-    std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>,
-    std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>;
 
 struct ConnectionParams
 {
@@ -155,12 +155,32 @@ std::unique_ptr<ContainerClient> getContainerClient(const ConnectionParams & par
 BlobClientOptions getClientOptions(const RequestSettings & settings, bool for_disk);
 AuthMethod getAuthMethod(const Poco::Util::AbstractConfiguration & config, const String & config_prefix);
 
+#endif
+
 std::unique_ptr<RequestSettings> getRequestSettings(const Settings & query_settings);
-std::unique_ptr<RequestSettings> getRequestSettingsForBackup(const Settings & query_settings, bool use_native_copy);
-std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, ContextPtr context);
+std::unique_ptr<RequestSettings> getRequestSettingsForBackup(ContextPtr context, String endpoint, bool use_native_copy);
+std::unique_ptr<RequestSettings> getRequestSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix, const Settings & settings_ref);
 
 }
 
-}
 
-#endif
+/// AzureSettingsByEndpoint contains a map of AzureBlobStorage endpoints and their settings, used in Context level
+/// When any endpoint is used, the settings are looked up in this map and applied
+class AzureSettingsByEndpoint
+{
+public:
+    void loadFromConfig(
+        const Poco::Util::AbstractConfiguration & config,
+        const std::string & config_prefix,
+        const DB::Settings & settings);
+
+    std::optional<AzureBlobStorage::RequestSettings> getSettings(
+        const std::string & endpoint) const;
+
+private:
+    mutable std::mutex mutex;
+    std::map<const String, const AzureBlobStorage::RequestSettings> azure_settings;
+};
+
+
+}
diff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp
index e09a2307a8ad..25d789bef792 100644
--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp
+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.cpp
@@ -105,11 +105,13 @@ class AzureIteratorAsync final : public IObjectStorageIteratorAsync
 
 AzureObjectStorage::AzureObjectStorage(
     const String & name_,
+    AzureBlobStorage::AuthMethod auth_method_,
     ClientPtr && client_,
     SettingsPtr && settings_,
     const String & object_namespace_,
     const String & description_)
     : name(name_)
+    , auth_method(std::move(auth_method_))
     , client(std::move(client_))
     , settings(std::move(settings_))
     , object_namespace(object_namespace_)
@@ -343,7 +345,7 @@ void AzureObjectStorage::applyNewSettings(
     ContextPtr context,
     const ApplyNewSettingsOptions & options)
 {
-    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context);
+    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context->getSettingsRef());
     settings.set(std::move(new_settings));
 
     if (!options.allow_client_change)
@@ -369,7 +371,7 @@ std::unique_ptr<IObjectStorage> AzureObjectStorage::cloneObjectStorage(
     const std::string & config_prefix,
     ContextPtr context)
 {
-    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context);
+    auto new_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context->getSettingsRef());
     bool is_client_for_disk = client.get()->IsClientForDisk();
 
     AzureBlobStorage::ConnectionParams params
@@ -380,7 +382,7 @@ std::unique_ptr<IObjectStorage> AzureObjectStorage::cloneObjectStorage(
     };
 
     auto new_client = AzureBlobStorage::getContainerClient(params, /*readonly=*/ true);
-    return std::make_unique<AzureObjectStorage>(name, std::move(new_client), std::move(new_settings), new_namespace, params.endpoint.getServiceEndpoint());
+    return std::make_unique<AzureObjectStorage>(name, params.auth_method, std::move(new_client), std::move(new_settings), new_namespace, params.endpoint.getServiceEndpoint());
 }
 
 }
diff --git a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h
index 01af82c89689..becd0dccd70e 100644
--- a/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h
+++ b/src/Disks/ObjectStorages/AzureBlobStorage/AzureObjectStorage.h
@@ -26,6 +26,7 @@ class AzureObjectStorage : public IObjectStorage
 
     AzureObjectStorage(
         const String & name_,
+        AzureBlobStorage::AuthMethod auth_method,
         ClientPtr && client_,
         SettingsPtr && settings_,
         const String & object_namespace_,
@@ -46,6 +47,8 @@ class AzureObjectStorage : public IObjectStorage
 
     bool exists(const StoredObject & object) const override;
 
+    AzureBlobStorage::AuthMethod getAzureBlobStorageAuthMethod() const override { return auth_method; }
+
     std::unique_ptr<ReadBufferFromFileBase> readObject( /// NOLINT
         const StoredObject & object,
         const ReadSettings & read_settings,
@@ -111,6 +114,7 @@ class AzureObjectStorage : public IObjectStorage
         bool if_exists);
 
     const String name;
+    AzureBlobStorage::AuthMethod auth_method;
     /// client used to access the files in the Blob Storage cloud
     MultiVersion<AzureBlobStorage::ContainerClient> client;
     MultiVersion<AzureBlobStorage::RequestSettings> settings;
diff --git a/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h b/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h
index 00f236c1e89d..087f02d67539 100644
--- a/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h
+++ b/src/Disks/ObjectStorages/Cached/CachedObjectStorage.h
@@ -124,6 +124,11 @@ class CachedObjectStorage final : public IObjectStorage
     {
         return object_storage->getAzureBlobStorageClient();
     }
+
+    AzureBlobStorage::AuthMethod getAzureBlobStorageAuthMethod() const override
+    {
+        return object_storage->getAzureBlobStorageAuthMethod();
+    }
 #endif
 
 #if USE_AWS_S3
diff --git a/src/Disks/ObjectStorages/IObjectStorage.h b/src/Disks/ObjectStorages/IObjectStorage.h
index 26d28906c17d..3c727c50e79e 100644
--- a/src/Disks/ObjectStorages/IObjectStorage.h
+++ b/src/Disks/ObjectStorages/IObjectStorage.h
@@ -5,6 +5,7 @@
 #include <mutex>
 #include <optional>
 #include <filesystem>
+#include <variant>
 
 #include <Poco/Timestamp.h>
 #include <Poco/Util/AbstractConfiguration.h>
@@ -28,11 +29,27 @@
 #include "config.h"
 
 #if USE_AZURE_BLOB_STORAGE
+#include <azure/core/credentials/credentials.hpp>
+#include <azure/storage/common/storage_credential.hpp>
+#include <azure/identity/managed_identity_credential.hpp>
+#include <azure/identity/workload_identity_credential.hpp>
+
 namespace DB::AzureBlobStorage
 {
 class ContainerClientWrapper;
 using ContainerClient = ContainerClientWrapper;
+
+using ConnectionString = StrongTypedef<String, struct ConnectionStringTag>;
+
+using AuthMethod = std::variant<
+    ConnectionString,
+    std::shared_ptr<Azure::Storage::StorageSharedKeyCredential>,
+    std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>,
+    std::shared_ptr<Azure::Identity::ManagedIdentityCredential>>;
+
 }
+
+
 #endif
 
 #if USE_AWS_S3
@@ -263,6 +280,11 @@ class IObjectStorage
     {
         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "This function is only implemented for AzureBlobStorage");
     }
+
+    virtual AzureBlobStorage::AuthMethod getAzureBlobStorageAuthMethod() const
+    {
+        throw Exception(ErrorCodes::NOT_IMPLEMENTED, "This function is only implemented for AzureBlobStorage");
+    }
 #endif
 
 #if USE_AWS_S3
diff --git a/src/Disks/ObjectStorages/ObjectStorageFactory.cpp b/src/Disks/ObjectStorages/ObjectStorageFactory.cpp
index 7cacfc152978..39200b1571cb 100644
--- a/src/Disks/ObjectStorages/ObjectStorageFactory.cpp
+++ b/src/Disks/ObjectStorages/ObjectStorageFactory.cpp
@@ -296,7 +296,7 @@ void registerAzureObjectStorage(ObjectStorageFactory & factory)
         const ContextPtr & context,
         bool /* skip_access_check */) -> ObjectStoragePtr
     {
-        auto azure_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context);
+        auto azure_settings = AzureBlobStorage::getRequestSettings(config, config_prefix, context->getSettingsRef());
 
         AzureBlobStorage::ConnectionParams params
         {
@@ -307,7 +307,7 @@ void registerAzureObjectStorage(ObjectStorageFactory & factory)
 
         return createObjectStorage<AzureObjectStorage>(
             ObjectStorageType::Azure, config, config_prefix, name,
-            AzureBlobStorage::getContainerClient(params, /*readonly=*/ false), std::move(azure_settings),
+            params.auth_method, AzureBlobStorage::getContainerClient(params, /*readonly=*/ false), std::move(azure_settings),
             params.endpoint.prefix.empty() ? params.endpoint.container_name : params.endpoint.container_name + "/" + params.endpoint.prefix,
             params.endpoint.getServiceEndpoint());
     };
diff --git a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp
index d9dfaccc530c..b49e34dd2d3a 100644
--- a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp
+++ b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.cpp
@@ -14,6 +14,12 @@
 #include <Disks/IO/WriteBufferFromAzureBlobStorage.h>
 #include <Common/getRandomASCIIString.h>
 
+
+#include <azure/core/credentials/credentials.hpp>
+#include <azure/storage/common/storage_credential.hpp>
+#include <azure/identity/managed_identity_credential.hpp>
+#include <azure/identity/workload_identity_credential.hpp>
+
 namespace ProfileEvents
 {
     extern const Event AzureCopyObject;
@@ -347,19 +353,21 @@ void copyAzureBlobStorageFile(
     const String & dest_blob,
     std::shared_ptr<const AzureBlobStorage::RequestSettings> settings,
     const ReadSettings & read_settings,
+    bool same_credentials,
     ThreadPoolCallbackRunnerUnsafe<void> schedule)
 {
     auto log = getLogger("copyAzureBlobStorageFile");
 
-    if (settings->use_native_copy)
+    if (settings->use_native_copy && same_credentials)
     {
-        LOG_TRACE(log, "Copying Blob: {} from Container: {} using native copy", src_container_for_logging, src_blob);
+        LOG_TRACE(log, "Copying Blob: {} from Container: {} using native copy", src_blob, src_container_for_logging);
         ProfileEvents::increment(ProfileEvents::AzureCopyObject);
         if (dest_client->IsClientForDisk())
             ProfileEvents::increment(ProfileEvents::DiskAzureCopyObject);
 
         auto block_blob_client_src = src_client->GetBlockBlobClient(src_blob);
         auto block_blob_client_dest = dest_client->GetBlockBlobClient(dest_blob);
+
         auto source_uri = block_blob_client_src.GetUrl();
 
         if (size < settings->max_single_part_copy_size)
@@ -398,7 +406,7 @@ void copyAzureBlobStorageFile(
     }
     else
     {
-        LOG_TRACE(log, "Reading from Container: {}, Blob: {}", src_container_for_logging, src_blob);
+        LOG_TRACE(log, "Copying Blob: {} from Container: {} native copy is disabled {}", src_blob, src_container_for_logging, same_credentials ? "" : " because of different credentials");
         auto create_read_buffer = [&]
         {
             return std::make_unique<ReadBufferFromAzureBlobStorage>(
diff --git a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h
index 79539a870862..036fbf34b0da 100644
--- a/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h
+++ b/src/IO/AzureBlobStorage/copyAzureBlobStorageFile.h
@@ -30,6 +30,7 @@ void copyAzureBlobStorageFile(
     const String & dest_blob,
     std::shared_ptr<const AzureBlobStorage::RequestSettings> settings,
     const ReadSettings & read_settings,
+    bool same_credentials = true,
     ThreadPoolCallbackRunnerUnsafe<void> schedule_ = {});
 
 
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index a351d7564483..233f7ccbba7e 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -43,6 +43,7 @@
 #include <Storages/Distributed/DistributedSettings.h>
 #include <Storages/CompressionCodecSelector.h>
 #include <IO/S3Settings.h>
+#include <Disks/ObjectStorages/AzureBlobStorage/AzureBlobStorageCommon.h>
 #include <Disks/DiskLocal.h>
 #include <Disks/ObjectStorages/DiskObjectStorage.h>
 #include <Disks/ObjectStorages/IObjectStorage.h>
@@ -543,6 +544,7 @@ struct ContextSharedPart : boost::noncopyable
     std::optional<Context::Dashboards> dashboards;
 
     std::optional<S3SettingsByEndpoint> storage_s3_settings TSA_GUARDED_BY(mutex);   /// Settings of S3 storage
+    std::optional<AzureSettingsByEndpoint> storage_azure_settings TSA_GUARDED_BY(mutex);   /// Settings of AzureBlobStorage
     std::unordered_map<Context::WarningType, PreformattedMessage> warnings TSA_GUARDED_BY(mutex); /// Store warning messages about server.
 
     /// Background executors for *MergeTree tables
@@ -5235,6 +5237,12 @@ void Context::updateStorageConfiguration(const Poco::Util::AbstractConfiguration
             shared->storage_s3_settings->loadFromConfig(config, /* config_prefix */"s3", getSettingsRef());
     }
 
+    {
+        std::lock_guard lock(shared->mutex);
+        if (shared->storage_azure_settings)
+            shared->storage_azure_settings->loadFromConfig(config, /* config_prefix */"configuration.disks.", getSettingsRef());
+    }
+
 }
 
 
@@ -5307,6 +5315,19 @@ const S3SettingsByEndpoint & Context::getStorageS3Settings() const
     return *shared->storage_s3_settings;
 }
 
+const AzureSettingsByEndpoint & Context::getStorageAzureSettings() const
+{
+    std::lock_guard lock(shared->mutex);
+
+    if (!shared->storage_azure_settings)
+    {
+        const auto & config = shared->getConfigRefWithLock(lock);
+        shared->storage_azure_settings.emplace().loadFromConfig(config, "storage_configuration.disks", getSettingsRef());
+    }
+
+    return *shared->storage_azure_settings;
+}
+
 void Context::checkCanBeDropped(const String & database, const String & table, const size_t & size, const size_t & max_size_to_drop) const
 {
     if (!max_size_to_drop || size <= max_size_to_drop)
diff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h
index b05967a73419..000545a37f50 100644
--- a/src/Interpreters/Context.h
+++ b/src/Interpreters/Context.h
@@ -140,6 +140,7 @@ struct InitialAllRangesAnnouncement;
 struct ParallelReadRequest;
 struct ParallelReadResponse;
 class S3SettingsByEndpoint;
+class AzureSettingsByEndpoint;
 class IDatabase;
 class DDLWorker;
 class ITableFunction;
@@ -1327,6 +1328,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>
     const MergeTreeSettings & getReplicatedMergeTreeSettings() const;
     const DistributedSettings & getDistributedSettings() const;
     const S3SettingsByEndpoint & getStorageS3Settings() const;
+    const AzureSettingsByEndpoint & getStorageAzureSettings() const;
 
     /// Prevents DROP TABLE if its size is greater than max_size (50GB by default, max_size=0 turn off this check)
     void setMaxTableSizeToDrop(size_t max_size);
diff --git a/src/Storages/ObjectStorage/Azure/Configuration.cpp b/src/Storages/ObjectStorage/Azure/Configuration.cpp
index 083509c1a9c3..eec50b5aadb4 100644
--- a/src/Storages/ObjectStorage/Azure/Configuration.cpp
+++ b/src/Storages/ObjectStorage/Azure/Configuration.cpp
@@ -89,6 +89,7 @@ ObjectStoragePtr StorageAzureConfiguration::createObjectStorage(ContextPtr conte
 
     return std::make_unique<AzureObjectStorage>(
         "AzureBlobStorage",
+        connection_params.auth_method,
         std::move(client),
         std::move(settings),
         connection_params.getContainer(),
