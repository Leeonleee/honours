You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
windowFunnel: same event gets counted twice
(you don't have to strictly follow this form)

**Describe the unexpected behaviour**
Test 1: running `windowFunnel` on different events without duplicate timestamp, it works well:
```sql
SELECT
    uid,
    windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 2) AS level
FROM
    (
    /* emulate test dataset */
    SELECT data.1 event_id, data.2  event_ms, data.3 uid
    FROM (
        SELECT arrayJoin(
        [(1, 100, 123),
        (1, 200, 345),
        (1, 210, 345),
        (2, 99, 123),
        (2, 250, 234),
        (2, 230, 345),
        (2, 240, 345)]) data)
    )
WHERE
    event_ms >= 0
    AND event_ms <= 300
GROUP BY
    uid;

Results:
┌─uid─┬─level─┐
│ 123 │     1 │
│ 234 │     0 │
│ 345 │     2 │
└─────┴───────┘
```

Test 2: running `windowFunnel` on different events with duplicate timestamp, it count unexpected event into result.
In this case, user 123 has event 1 and event 2 both happened at 100(event_ms), theoretically, it should not count this match because timestamp of event 2 is not greater than event 1.
```sql
SELECT
    uid,
    windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 2) AS level
FROM
    (
    /* emulate test dataset */
    SELECT data.1 event_id, data.2  event_ms, data.3 uid
    FROM (
        SELECT arrayJoin(
        [(1, 100, 123),
        (1, 200, 345),
        (1, 210, 345),
        (2, 100, 123),
        (2, 250, 234),
        (2, 230, 345),
        (2, 240, 345)]) data)
    )
WHERE
    event_ms >= 0
    AND event_ms <= 300
GROUP BY
    uid;

Results:
┌─uid─┬─level─┐
│ 123 │     2 │
│ 234 │     0 │
│ 345 │     2 │
└─────┴───────┘
```

Test 3: running `windowFunnel` on two same event count all events twice:
```sql
SELECT
    uid,
    windowFunnel(50)(toUInt32(event_ms), event_id = 1, event_id = 1) AS level
FROM
    (
    /* emulate test dataset */
    SELECT data.1 event_id, data.2  event_ms, data.3 uid
    FROM (
        SELECT arrayJoin(
        [(1, 100, 123),
        (1, 200, 345)]) data)
    )
WHERE
    event_ms >= 0
    AND event_ms <= 300
GROUP BY
    uid;

Results:
┌─uid─┬─level─┐
│ 123 │     2 │
│ 345 │     2 │
└─────┴───────┘
```

**How to reproduce**: run SQL query pasted above
* Which ClickHouse server version to use: 21.2.3.15
* Which interface to use, if matters
* Non-default settings, if any
* `CREATE TABLE` statements for all tables involved
* Sample data for all these tables, use [clickhouse-obfuscator](https://github.com/ClickHouse/ClickHouse/blob/master/programs/obfuscator/Obfuscator.cpp#L42-L80) if necessary
* Queries to run that lead to unexpected result

**Expected behavior**
When searching for qualified event chain, it should satisfy: 
**timestamp of first event < timestamp of second event <= timestamp of first event + window**

I guess currently it follows:
timestamp of first event <= timestamp of second event <= timestamp of first event + window

With that, Test 2 will generate results:
```
┌─uid─┬─level─┐
│ 123 │     1 │
│ 234 │     0 │
│ 345 │     2 │
└─────┴───────┘
```

Test 3 will generate results:
```
┌─uid─┬─level─┐
│ 123 │     1 │
│ 345 │     1 │
└─────┴───────┘

```


**Error message and/or stacktrace**
If applicable, add screenshots to help explain your problem.

**Additional context**
Add any other context about the problem here.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
