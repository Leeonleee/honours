diff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp
index e305dc534dd1..43ab67b37612 100644
--- a/src/Core/Settings.cpp
+++ b/src/Core/Settings.cpp
@@ -5777,7 +5777,7 @@ Only has an effect in ClickHouse Cloud. Wait time to lock cache for space reserv
 )", 0) \
     \
     DECLARE(Bool, parallelize_output_from_storages, true, R"(
-Parallelize output for reading step from storage. It allows parallelization of  query processing right after reading from storage if possible
+Parallelize output for reading step from storage. It allows parallelization of query processing right after reading from storage if possible
 )", 0) \
     DECLARE(String, insert_deduplication_token, "", R"(
 The setting allows a user to provide own deduplication semantic in MergeTree/ReplicatedMergeTree
diff --git a/src/Storages/IStorage.cpp b/src/Storages/IStorage.cpp
index bdc84221c57f..d8b74764e773 100644
--- a/src/Storages/IStorage.cpp
+++ b/src/Storages/IStorage.cpp
@@ -23,6 +23,7 @@ namespace DB
 namespace Setting
 {
     extern const SettingsBool parallelize_output_from_storages;
+    extern const SettingsBool distributed_aggregation_memory_efficient;
 }
 
 namespace ErrorCodes
@@ -185,7 +186,15 @@ void IStorage::read(
     /// parallelize processing if not yet
     const size_t output_ports = pipe.numOutputPorts();
     const bool parallelize_output = context->getSettingsRef()[Setting::parallelize_output_from_storages];
-    if (parallelize_output && parallelizeOutputAfterReading(context) && output_ports > 0 && output_ports < num_streams)
+
+    /// For distributed_aggregation_memory_efficient with Two-Level-Hash aggregation, the `GroupingAggregatedTransform`
+    /// need to receive buckets from Remote in order of bucket number, while resize here will break the buckets order
+    /// return from `RemoteSource`. See https://github.com/ClickHouse/ClickHouse/issues/76934.
+    const bool should_not_resize = context->getSettingsRef()[Setting::distributed_aggregation_memory_efficient]
+        && processed_stage == QueryProcessingStage::Enum::WithMergeableState;
+
+    if (!should_not_resize && parallelize_output && parallelizeOutputAfterReading(context) && output_ports > 0
+        && output_ports < num_streams)
         pipe.resize(num_streams);
 
     readFromPipe(query_plan, std::move(pipe), column_names, storage_snapshot, query_info, context, shared_from_this());
