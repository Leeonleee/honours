diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index c241955b268f..0fad546d0ecb 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -458,6 +458,7 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     M(Bool, optimize_duplicate_order_by_and_distinct, true, "Remove duplicate ORDER BY and DISTINCT if it's possible", 0) \
     M(Bool, optimize_redundant_functions_in_order_by, true, "Remove functions from ORDER BY if its argument is also in ORDER BY", 0) \
     M(Bool, optimize_if_chain_to_multiif, false, "Replace if(cond1, then1, if(cond2, ...)) chains to multiIf. Currently it's not beneficial for numeric types.", 0) \
+    M(Bool, optimize_multiif_to_if, true, "Replace 'multiIf' with only one condition to 'if'.", 0) \
     M(Bool, optimize_if_transform_strings_to_enum, false, "Replaces string-type arguments in If and Transform to enum. Disabled by default cause it could make inconsistent change in distributed query that would lead to its fail.", 0) \
     M(Bool, optimize_monotonous_functions_in_order_by, true, "Replace monotonous function with its argument in ORDER BY", 0) \
     M(Bool, optimize_functions_to_subcolumns, false, "Transform functions to subcolumns, if possible, to reduce amount of read data. E.g. 'length(arr)' -> 'arr.size0', 'col IS NULL' -> 'col.null' ", 0) \
diff --git a/src/Interpreters/OptimizeIfChains.h b/src/Interpreters/OptimizeIfChains.h
index 5dbdb9bee500..79a4f497ff85 100644
--- a/src/Interpreters/OptimizeIfChains.h
+++ b/src/Interpreters/OptimizeIfChains.h
@@ -1,6 +1,8 @@
 #pragma once
 
 #include <Parsers/IAST.h>
+#include <Parsers/ASTFunction.h>
+#include <Interpreters/InDepthNodeVisitor.h>
 
 namespace DB
 {
@@ -16,4 +18,22 @@ class OptimizeIfChainsVisitor
     ASTs ifChain(const ASTPtr & child);
 };
 
+/// Replaces multiIf with one condition to if,
+/// because it's more efficient.
+class OptimizeMultiIfToIfData
+{
+public:
+    using TypeToVisit = ASTFunction;
+
+    void visit(ASTFunction & function, ASTPtr &)
+    {
+        /// 3 args: condition, then branch, else branch.
+        if (function.name == "multiIf" && (function.arguments && function.arguments->children.size() == 3))
+            function.name = "if";
+    }
+};
+
+using OptimizeMultiIfToIfMatcher = OneTypeMatcher<OptimizeMultiIfToIfData>;
+using OptimizeMultiIfToIfVisitor = InDepthNodeVisitor<OptimizeMultiIfToIfMatcher, true>;
+
 }
diff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp
index 42628fbb9059..cf79cd158e8a 100644
--- a/src/Interpreters/TreeOptimizer.cpp
+++ b/src/Interpreters/TreeOptimizer.cpp
@@ -674,6 +674,12 @@ void optimizeSumIfFunctions(ASTPtr & query)
     RewriteSumIfFunctionVisitor(data).visit(query);
 }
 
+void optimizeMultiIfToIf(ASTPtr & query)
+{
+    OptimizeMultiIfToIfVisitor::Data data;
+    OptimizeMultiIfToIfVisitor(data).visit(query);
+}
+
 void optimizeInjectiveFunctionsInsideUniq(ASTPtr & query, ContextPtr context)
 {
     RemoveInjectiveFunctionsVisitor::Data data(context);
@@ -820,6 +826,9 @@ void TreeOptimizer::apply(ASTPtr & query, TreeRewriterResult & result,
     if (settings.optimize_rewrite_sum_if_to_count_if)
         optimizeSumIfFunctions(query);
 
+    if (settings.optimize_multiif_to_if)
+        optimizeMultiIfToIf(query);
+
     /// Remove injective functions inside uniq
     if (settings.optimize_injective_functions_inside_uniq)
         optimizeInjectiveFunctionsInsideUniq(query, context);
