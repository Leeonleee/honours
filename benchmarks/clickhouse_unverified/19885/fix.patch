diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp
index 12942371d4f7..91862fbe8ba8 100644
--- a/src/Interpreters/ActionsDAG.cpp
+++ b/src/Interpreters/ActionsDAG.cpp
@@ -679,7 +679,9 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
     const ColumnsWithTypeAndName & source,
     const ColumnsWithTypeAndName & result,
     MatchColumnsMode mode,
-    bool ignore_constant_values)
+    bool ignore_constant_values,
+    bool add_casted_columns,
+    NameToNameMap * new_names)
 {
     size_t num_input_columns = source.size();
     size_t num_result_columns = result.size();
@@ -687,6 +689,9 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
     if (mode == MatchColumnsMode::Position && num_input_columns != num_result_columns)
         throw Exception("Number of columns doesn't match", ErrorCodes::NUMBER_OF_COLUMNS_DOESNT_MATCH);
 
+    if (add_casted_columns && mode != MatchColumnsMode::Name)
+        throw Exception("Converting with add_casted_columns supported only for MatchColumnsMode::Name", ErrorCodes::LOGICAL_ERROR);
+
     auto actions_dag = std::make_shared<ActionsDAG>(source);
     std::vector<Node *> projection(num_result_columns);
 
@@ -706,12 +711,13 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
     {
         const auto & res_elem = result[result_col_num];
         Node * src_node = nullptr;
+        Node * dst_node = nullptr;
 
         switch (mode)
         {
             case MatchColumnsMode::Position:
             {
-                src_node = actions_dag->inputs[result_col_num];
+                src_node = dst_node = actions_dag->inputs[result_col_num];
                 break;
             }
 
@@ -722,7 +728,7 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
                     throw Exception("Cannot find column " + backQuote(res_elem.name) + " in source stream",
                                     ErrorCodes::THERE_IS_NO_COLUMN);
 
-                src_node = actions_dag->inputs[input.front()];
+                src_node = dst_node = actions_dag->inputs[input.front()];
                 input.pop_front();
                 break;
             }
@@ -731,10 +737,10 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
         /// Check constants.
         if (const auto * res_const = typeid_cast<const ColumnConst *>(res_elem.column.get()))
         {
-            if (const auto * src_const = typeid_cast<const ColumnConst *>(src_node->column.get()))
+            if (const auto * src_const = typeid_cast<const ColumnConst *>(dst_node->column.get()))
             {
                 if (ignore_constant_values)
-                   src_node = const_cast<Node *>(&actions_dag->addColumn(res_elem, true));
+                    dst_node = const_cast<Node *>(&actions_dag->addColumn(res_elem, true));
                 else if (res_const->getField() != src_const->getField())
                     throw Exception("Cannot convert column " + backQuote(res_elem.name) + " because "
                                     "it is constant but values of constants are different in source and result",
@@ -747,7 +753,7 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
         }
 
         /// Add CAST function to convert into result type if needed.
-        if (!res_elem.type->equals(*src_node->result_type))
+        if (!res_elem.type->equals(*dst_node->result_type))
         {
             ColumnWithTypeAndName column;
             column.name = res_elem.type->getName();
@@ -755,27 +761,49 @@ ActionsDAGPtr ActionsDAG::makeConvertingActions(
             column.type = std::make_shared<DataTypeString>();
 
             auto * right_arg = const_cast<Node *>(&actions_dag->addColumn(std::move(column), true));
-            auto * left_arg = src_node;
+            auto * left_arg = dst_node;
 
-            FunctionCast::Diagnostic diagnostic = {src_node->result_name, res_elem.name};
+            FunctionCast::Diagnostic diagnostic = {dst_node->result_name, res_elem.name};
             FunctionOverloadResolverPtr func_builder_cast =
                     std::make_shared<FunctionOverloadResolverAdaptor>(
                             CastOverloadResolver<CastType::nonAccurate>::createImpl(false, std::move(diagnostic)));
 
             Inputs children = { left_arg, right_arg };
-            src_node = &actions_dag->addFunction(func_builder_cast, std::move(children), {}, true);
+            dst_node = &actions_dag->addFunction(func_builder_cast, std::move(children), {}, true);
         }
 
-        if (src_node->column && isColumnConst(*src_node->column) && !(res_elem.column && isColumnConst(*res_elem.column)))
+        if (dst_node->column && isColumnConst(*dst_node->column) && !(res_elem.column && isColumnConst(*res_elem.column)))
         {
-            Inputs children = {src_node};
-            src_node = &actions_dag->addFunction(func_builder_materialize, std::move(children), {}, true);
+            Inputs children = {dst_node};
+            dst_node = &actions_dag->addFunction(func_builder_materialize, std::move(children), {}, true);
         }
 
-        if (src_node->result_name != res_elem.name)
-            src_node = &actions_dag->addAlias(*src_node, res_elem.name, true);
+        if (dst_node->result_name != res_elem.name)
+        {
+            if (add_casted_columns)
+            {
+                if (inputs.contains(dst_node->result_name))
+                    throw Exception("Cannot convert column " + backQuote(res_elem.name) +
+                                    " to "+ backQuote(dst_node->result_name) +
+                                    " because other column have same name",
+                                    ErrorCodes::ILLEGAL_COLUMN);
+                if (new_names)
+                    new_names->emplace(res_elem.name, dst_node->result_name);
 
-        projection[result_col_num] = src_node;
+                /// Leave current column on same place, add converted to back
+                projection[result_col_num] = src_node;
+                projection.push_back(dst_node);
+            }
+            else
+            {
+                dst_node = &actions_dag->addAlias(*dst_node, res_elem.name, true);
+                projection[result_col_num] = dst_node;
+            }
+        }
+        else
+        {
+            projection[result_col_num] = dst_node;
+        }
     }
 
     actions_dag->removeUnusedActions(projection);
diff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h
index 3c8778e239a0..48cc3449d39f 100644
--- a/src/Interpreters/ActionsDAG.h
+++ b/src/Interpreters/ActionsDAG.h
@@ -248,11 +248,15 @@ class ActionsDAG
     /// Create ActionsDAG which converts block structure from source to result.
     /// It is needed to convert result from different sources to the same structure, e.g. for UNION query.
     /// Conversion should be possible with only usage of CAST function and renames.
+    /// @param ignore_constant_values - Do not check that constants are same. Use value from result_header.
+    /// @param add_casted_columns - Create new columns with converted values instead of replacing original.
     static ActionsDAGPtr makeConvertingActions(
         const ColumnsWithTypeAndName & source,
         const ColumnsWithTypeAndName & result,
         MatchColumnsMode mode,
-        bool ignore_constant_values = false); /// Do not check that constants are same. Use value from result_header.
+        bool ignore_constant_values = false,
+        bool add_casted_columns = false,
+        NameToNameMap * new_names = nullptr);
 
     /// Create expression which add const column and then materialize it.
     static ActionsDAGPtr makeAddingColumnActions(ColumnWithTypeAndName column);
diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp
index ca78c3708343..cf9f937736d7 100644
--- a/src/Interpreters/ActionsVisitor.cpp
+++ b/src/Interpreters/ActionsVisitor.cpp
@@ -674,7 +674,7 @@ void ActionsMatcher::visit(const ASTIdentifier & identifier, const ASTPtr & ast,
             if (column_name_type.name == column_name)
             {
                 throw Exception("Column " + backQuote(column_name) + " is not under aggregate function and not in GROUP BY",
-                ErrorCodes::NOT_AN_AGGREGATE);
+                                ErrorCodes::NOT_AN_AGGREGATE);
             }
         }
 
diff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp
index b1fd23d43114..f06f8248fec2 100644
--- a/src/Interpreters/ExpressionActions.cpp
+++ b/src/Interpreters/ExpressionActions.cpp
@@ -726,7 +726,7 @@ ExpressionActionsChain::JoinStep::JoinStep(
     for (const auto & column : result_columns)
         required_columns.emplace_back(column.name, column.type);
 
-    analyzed_join->addJoinedColumnsAndCorrectNullability(result_columns);
+    analyzed_join->addJoinedColumnsAndCorrectTypes(result_columns);
 }
 
 void ExpressionActionsChain::JoinStep::finalize(const Names & required_output_)
@@ -747,8 +747,8 @@ void ExpressionActionsChain::JoinStep::finalize(const Names & required_output_)
     }
 
     /// Result will also contain joined columns.
-    for (const auto & column : analyzed_join->columnsAddedByJoin())
-        required_names.emplace(column.name);
+    for (const auto & column_name : analyzed_join->columnsAddedByJoin())
+        required_names.emplace(column_name);
 
     for (const auto & column : result_columns)
     {
diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 55dc622a976f..dd53717a189c 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -42,14 +42,13 @@
 
 #include <DataTypes/DataTypeFactory.h>
 #include <Parsers/parseQuery.h>
-#include <Interpreters/interpretSubquery.h>
-#include <Interpreters/DatabaseAndTableWithAlias.h>
-#include <Interpreters/misc.h>
 
 #include <Interpreters/ActionsVisitor.h>
-
-#include <Interpreters/GlobalSubqueriesVisitor.h>
 #include <Interpreters/GetAggregatesVisitor.h>
+#include <Interpreters/GlobalSubqueriesVisitor.h>
+#include <Interpreters/interpretSubquery.h>
+#include <Interpreters/join_common.h>
+#include <Interpreters/misc.h>
 
 #include <IO/Operators.h>
 #include <IO/WriteBufferFromString.h>
@@ -208,13 +207,12 @@ void ExpressionAnalyzer::analyzeAggregation()
         {
             getRootActionsNoMakeSet(analyzedJoin().leftKeysList(), true, temp_actions, false);
             auto sample_columns = temp_actions->getResultColumns();
-            analyzedJoin().addJoinedColumnsAndCorrectNullability(sample_columns);
+            analyzedJoin().addJoinedColumnsAndCorrectTypes(sample_columns);
             temp_actions = std::make_shared<ActionsDAG>(sample_columns);
         }
 
         columns_after_join = columns_after_array_join;
-        const auto & added_by_join = analyzedJoin().columnsAddedByJoin();
-        columns_after_join.insert(columns_after_join.end(), added_by_join.begin(), added_by_join.end());
+        analyzedJoin().addJoinedColumnsAndCorrectTypes(columns_after_join, false);
     }
 
     has_aggregation = makeAggregateDescriptions(temp_actions);
@@ -724,13 +722,17 @@ bool SelectQueryExpressionAnalyzer::appendJoinLeftKeys(ExpressionActionsChain &
 
 JoinPtr SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain)
 {
-    JoinPtr table_join = makeTableJoin(*syntax->ast_join);
-
-    ExpressionActionsChain::Step & step = chain.lastStep(columns_after_array_join);
+    const ColumnsWithTypeAndName & left_sample_columns = chain.getLastStep().getResultColumns();
+    JoinPtr table_join = makeTableJoin(*syntax->ast_join, left_sample_columns);
 
-    chain.steps.push_back(std::make_unique<ExpressionActionsChain::JoinStep>(
-            syntax->analyzed_join, table_join, step.getResultColumns()));
+    if (syntax->analyzed_join->needConvert())
+    {
+        chain.steps.push_back(std::make_unique<ExpressionActionsChain::ExpressionActionsStep>(syntax->analyzed_join->leftConvertingActions()));
+        chain.addStep();
+    }
 
+    ExpressionActionsChain::Step & step = chain.lastStep(columns_after_array_join);
+    chain.steps.push_back(std::make_unique<ExpressionActionsChain::JoinStep>(syntax->analyzed_join, table_join, step.getResultColumns()));
     chain.addStep();
     return table_join;
 }
@@ -795,7 +797,8 @@ static std::shared_ptr<IJoin> makeJoin(std::shared_ptr<TableJoin> analyzed_join,
     return std::make_shared<JoinSwitcher>(analyzed_join, sample_block);
 }
 
-JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(const ASTTablesInSelectQueryElement & join_element)
+JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(
+    const ASTTablesInSelectQueryElement & join_element, const ColumnsWithTypeAndName & left_sample_columns)
 {
     /// Two JOINs are not supported with the same subquery, but different USINGs.
     auto join_hash = join_element.getTreeHash();
@@ -831,7 +834,13 @@ JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(const ASTTablesInSelectQuer
         }
 
         /// TODO You do not need to set this up when JOIN is only needed on remote servers.
-        subquery_for_join.setJoinActions(joined_block_actions); /// changes subquery_for_join.sample_block inside
+        subquery_for_join.addJoinActions(joined_block_actions); /// changes subquery_for_join.sample_block inside
+
+        const ColumnsWithTypeAndName & right_sample_columns = subquery_for_join.sample_block.getColumnsWithTypeAndName();
+        bool need_convert = syntax->analyzed_join->applyJoinKeyConvert(left_sample_columns, right_sample_columns);
+        if (need_convert)
+            subquery_for_join.addJoinActions(std::make_shared<ExpressionActions>(syntax->analyzed_join->rightConvertingActions()));
+
         subquery_for_join.join = makeJoin(syntax->analyzed_join, subquery_for_join.sample_block, context);
 
         /// Do not make subquery for join over dictionary.
@@ -1426,9 +1435,9 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(
         if (query_analyzer.hasTableJoin())
         {
             query_analyzer.appendJoinLeftKeys(chain, only_types || !first_stage);
-
             before_join = chain.getLastActions();
             join = query_analyzer.appendJoin(chain);
+            converting_join_columns = query_analyzer.analyzedJoin().leftConvertingActions();
             chain.addStep();
         }
 
diff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h
index 319be9c1409a..1a0f88f95ac5 100644
--- a/src/Interpreters/ExpressionAnalyzer.h
+++ b/src/Interpreters/ExpressionAnalyzer.h
@@ -1,15 +1,16 @@
 #pragma once
 
-#include <DataStreams/IBlockStream_fwd.h>
 #include <Columns/FilterDescription.h>
+#include <DataStreams/IBlockStream_fwd.h>
 #include <Interpreters/AggregateDescription.h>
-#include <Interpreters/WindowDescription.h>
-#include <Interpreters/TreeRewriter.h>
+#include <Interpreters/DatabaseCatalog.h>
 #include <Interpreters/SubqueryForSet.h>
+#include <Interpreters/TreeRewriter.h>
+#include <Interpreters/WindowDescription.h>
+#include <Interpreters/join_common.h>
 #include <Parsers/IAST_fwd.h>
 #include <Storages/IStorage_fwd.h>
 #include <Storages/SelectQueryInfo.h>
-#include <Interpreters/DatabaseCatalog.h>
 
 namespace DB
 {
@@ -199,6 +200,7 @@ struct ExpressionAnalysisResult
     ActionsDAGPtr before_array_join;
     ArrayJoinActionPtr array_join;
     ActionsDAGPtr before_join;
+    ActionsDAGPtr converting_join_columns;
     JoinPtr join;
     ActionsDAGPtr before_where;
     ActionsDAGPtr before_aggregation;
@@ -313,7 +315,9 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer
     /// Create Set-s that we make from IN section to use index on them.
     void makeSetsForIndex(const ASTPtr & node);
 
-    JoinPtr makeTableJoin(const ASTTablesInSelectQueryElement & join_element);
+    JoinPtr makeTableJoin(
+        const ASTTablesInSelectQueryElement & join_element,
+        const ColumnsWithTypeAndName & left_sample_columns);
 
     const ASTSelectQuery * getAggregatingQuery() const;
 
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index da6ad7ab102d..5e3b878f795a 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -493,7 +493,10 @@ InterpreterSelectQuery::InterpreterSelectQuery(
 
     if (need_analyze_again)
     {
-        subquery_for_sets = std::move(query_analyzer->getSubqueriesForSets());
+        LOG_TRACE(log, "Running 'analyze' second time");
+        query_analyzer->getSubqueriesForSets().clear();
+        subquery_for_sets = SubqueriesForSets();
+
         /// Do not try move conditions to PREWHERE for the second time.
         /// Otherwise, we won't be able to fallback from inefficient PREWHERE to WHERE later.
         analyze(/* try_move_to_prewhere = */ false);
@@ -1002,14 +1005,22 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu
                 query_plan.addStep(std::move(before_join_step));
             }
 
+            /// Optional step to convert key columns to common supertype.
+            /// Columns with changed types will be returned to user,
+            ///  so its only suitable for `USING` join.
+            if (expressions.converting_join_columns)
+            {
+                QueryPlanStepPtr convert_join_step = std::make_unique<ExpressionStep>(
+                    query_plan.getCurrentDataStream(),
+                    expressions.converting_join_columns);
+                convert_join_step->setStepDescription("Convert JOIN columns");
+                query_plan.addStep(std::move(convert_join_step));
+            }
+
             if (expressions.hasJoin())
             {
-                Block join_result_sample;
                 JoinPtr join = expressions.join;
 
-                join_result_sample = JoiningTransform::transformHeader(
-                    query_plan.getCurrentDataStream().header, expressions.join);
-
                 QueryPlanStepPtr join_step = std::make_unique<JoinStep>(
                     query_plan.getCurrentDataStream(),
                     expressions.join);
@@ -1019,6 +1030,7 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu
 
                 if (expressions.join_has_delayed_stream)
                 {
+                    const Block & join_result_sample = query_plan.getCurrentDataStream().header;
                     auto stream = std::make_shared<LazyNonJoinedBlockInputStream>(*join, join_result_sample, settings.max_block_size);
                     auto source = std::make_shared<SourceFromInputStream>(std::move(stream));
                     auto add_non_joined_rows_step = std::make_unique<AddingDelayedSourceStep>(
diff --git a/src/Interpreters/SubqueryForSet.cpp b/src/Interpreters/SubqueryForSet.cpp
index 6ca0ecc50c82..c81b7a710aef 100644
--- a/src/Interpreters/SubqueryForSet.cpp
+++ b/src/Interpreters/SubqueryForSet.cpp
@@ -39,10 +39,20 @@ void SubqueryForSet::renameColumns(Block & block)
     }
 }
 
-void SubqueryForSet::setJoinActions(ExpressionActionsPtr actions)
+void SubqueryForSet::addJoinActions(ExpressionActionsPtr actions)
 {
     actions->execute(sample_block);
-    joined_block_actions = actions;
+    if (joined_block_actions == nullptr)
+    {
+        joined_block_actions = actions;
+    }
+    else
+    {
+        auto new_dag = ActionsDAG::merge(
+            std::move(*joined_block_actions->getActionsDAG().clone()),
+            std::move(*actions->getActionsDAG().clone()));
+        joined_block_actions = std::make_shared<ExpressionActions>(new_dag);
+    }
 }
 
 bool SubqueryForSet::insertJoinedBlock(Block & block)
diff --git a/src/Interpreters/SubqueryForSet.h b/src/Interpreters/SubqueryForSet.h
index fd073500dc2d..a42bf296d6c4 100644
--- a/src/Interpreters/SubqueryForSet.h
+++ b/src/Interpreters/SubqueryForSet.h
@@ -40,7 +40,7 @@ struct SubqueryForSet
     void makeSource(std::shared_ptr<InterpreterSelectWithUnionQuery> & interpreter,
                     NamesWithAliases && joined_block_aliases_);
 
-    void setJoinActions(ExpressionActionsPtr actions);
+    void addJoinActions(ExpressionActionsPtr actions);
 
     bool insertJoinedBlock(Block & block);
     void setTotals(Block totals);
diff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp
index c1777711d9ec..c50c61c418c4 100644
--- a/src/Interpreters/TableJoin.cpp
+++ b/src/Interpreters/TableJoin.cpp
@@ -1,5 +1,7 @@
 #include <Interpreters/TableJoin.h>
 
+#include <common/logger_useful.h>
+
 #include <Parsers/ASTExpressionList.h>
 
 #include <Core/Settings.h>
@@ -15,6 +17,11 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int TYPE_MISMATCH;
+}
+
 TableJoin::TableJoin(const Settings & settings, VolumePtr tmp_volume_)
     : size_limits(SizeLimits{settings.max_rows_in_join, settings.max_bytes_in_join, settings.join_overflow_mode})
     , default_max_bytes(settings.default_max_bytes_in_join)
@@ -40,6 +47,10 @@ void TableJoin::resetCollected()
     columns_added_by_join.clear();
     original_names.clear();
     renames.clear();
+    left_type_map.clear();
+    right_type_map.clear();
+    left_converting_actions = nullptr;
+    right_converting_actions = nullptr;
 }
 
 void TableJoin::addUsingKey(const ASTPtr & ast)
@@ -105,14 +116,6 @@ void TableJoin::deduplicateAndQualifyColumnNames(const NameSet & left_table_colu
     columns_from_joined_table.swap(dedup_columns);
 }
 
-NameSet TableJoin::getQualifiedColumnsSet() const
-{
-    NameSet out;
-    for (const auto & names : original_names)
-        out.insert(names.first);
-    return out;
-}
-
 NamesWithAliases TableJoin::getNamesWithAliases(const NameSet & required_columns) const
 {
     NamesWithAliases out;
@@ -221,49 +224,54 @@ bool TableJoin::rightBecomeNullable(const DataTypePtr & column_type) const
 
 void TableJoin::addJoinedColumn(const NameAndTypePair & joined_column)
 {
-    if (rightBecomeNullable(joined_column.type))
-        columns_added_by_join.emplace_back(NameAndTypePair(joined_column.name, makeNullable(joined_column.type)));
-    else
-        columns_added_by_join.push_back(joined_column);
+    DataTypePtr type = joined_column.type;
+
+    if (hasUsing())
+    {
+        if (auto it = right_type_map.find(joined_column.name); it != right_type_map.end())
+            type = it->second;
+    }
+
+    if (rightBecomeNullable(type))
+        type = makeNullable(type);
+
+    columns_added_by_join.emplace_back(joined_column.name, type);
+}
+
+void TableJoin::addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability) const
+{
+    ColumnsWithTypeAndName columns;
+    for (auto & pair : names_and_types)
+        columns.emplace_back(nullptr, std::move(pair.type), std::move(pair.name));
+    names_and_types.clear();
+
+    addJoinedColumnsAndCorrectTypes(columns, correct_nullability);
+
+    for (auto & col : columns)
+        names_and_types.emplace_back(std::move(col.name), std::move(col.type));
 }
 
-void TableJoin::addJoinedColumnsAndCorrectNullability(ColumnsWithTypeAndName & columns) const
+void TableJoin::addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns, bool correct_nullability) const
 {
     for (auto & col : columns)
     {
-        if (leftBecomeNullable(col.type))
+        if (hasUsing())
+        {
+            if (auto it = left_type_map.find(col.name); it != left_type_map.end())
+                col.type = it->second;
+        }
+        if (correct_nullability && leftBecomeNullable(col.type))
         {
             /// No need to nullify constants
-            if (!(col.column && isColumnConst(*col.column)))
-            {
+            bool is_column_const = col.column && isColumnConst(*col.column);
+            if (!is_column_const)
                 col.type = makeNullable(col.type);
-            }
         }
     }
 
+    /// Types in columns_added_by_join already converted and set nullable if needed
     for (const auto & col : columns_added_by_join)
-    {
-        auto res_type = col.type;
-
-        if (rightBecomeNullable(res_type))
-            res_type = makeNullable(res_type);
-
-        columns.emplace_back(nullptr, res_type, col.name);
-    }
-}
-
-bool TableJoin::sameJoin(const TableJoin * x, const TableJoin * y)
-{
-    if (!x && !y)
-        return true;
-    if (!x || !y)
-        return false;
-
-    return x->table_join.kind == y->table_join.kind
-        && x->table_join.strictness == y->table_join.strictness
-        && x->key_names_left == y->key_names_left
-        && x->key_names_right == y->key_names_right
-        && x->columns_added_by_join == y->columns_added_by_join;
+        columns.emplace_back(nullptr, col.type, col.name);
 }
 
 bool TableJoin::sameStrictnessAndKind(ASTTableJoin::Strictness strictness_, ASTTableJoin::Kind kind_) const
@@ -336,4 +344,124 @@ bool TableJoin::allowDictJoin(const String & dict_key, const Block & sample_bloc
     return true;
 }
 
+bool TableJoin::applyJoinKeyConvert(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns)
+{
+    bool need_convert = needConvert();
+    if (!need_convert && !hasUsing())
+    {
+        /// For `USING` we already inferred common type an syntax analyzer stage
+        NamesAndTypesList left_list;
+        NamesAndTypesList right_list;
+        for (const auto & col : left_sample_columns)
+            left_list.emplace_back(col.name, col.type);
+        for (const auto & col : right_sample_columns)
+            right_list.emplace_back(col.name, col.type);
+
+        need_convert = inferJoinKeyCommonType(left_list, right_list);
+    }
+
+    if (need_convert)
+    {
+        left_converting_actions = applyKeyConvertToTable(left_sample_columns, left_type_map, key_names_left);
+        right_converting_actions = applyKeyConvertToTable(right_sample_columns, right_type_map, key_names_right);
+    }
+
+    return need_convert;
+}
+
+bool TableJoin::inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right)
+{
+    std::unordered_map<String, DataTypePtr> left_types;
+    for (const auto & col : left)
+    {
+        left_types[col.name] = col.type;
+    }
+
+    std::unordered_map<String, DataTypePtr> right_types;
+    for (const auto & col : right)
+    {
+        if (auto it = renames.find(col.name); it != renames.end())
+            right_types[it->second] = col.type;
+        else
+            right_types[col.name] = col.type;
+    }
+
+    for (size_t i = 0; i < key_names_left.size(); ++i)
+    {
+        auto ltype = left_types.find(key_names_left[i]);
+        auto rtype = right_types.find(key_names_right[i]);
+        if (ltype == left_types.end() || rtype == right_types.end())
+        {
+            /// Name mismatch, give up
+            left_type_map.clear();
+            right_type_map.clear();
+            return false;
+        }
+
+        if (JoinCommon::typesEqualUpToNullability(ltype->second, rtype->second))
+            continue;
+
+        DataTypePtr supertype;
+        try
+        {
+            supertype = DB::getLeastSupertype({ltype->second, rtype->second});
+        }
+        catch (DB::Exception & ex)
+        {
+            throw Exception(
+                "Type mismatch of columns to JOIN by: " +
+                    key_names_left[i] + ": " + ltype->second->getName() + " at left, " +
+                    key_names_right[i] + ": " + rtype->second->getName() + " at right. " +
+                    "Can't get supertype: " + ex.message(),
+                ErrorCodes::TYPE_MISMATCH);
+        }
+        left_type_map[key_names_left[i]] = right_type_map[key_names_right[i]] = supertype;
+    }
+
+    if (!left_type_map.empty() || !right_type_map.empty())
+    {
+        auto format_type_map = [](NameToTypeMap mapping) -> std::string
+        {
+            std::vector<std::string> text;
+            for (const auto & [k, v] : mapping)
+                text.push_back(k + ": " + v->getName());
+            return fmt::format("{}", fmt::join(text, ", "));
+        };
+        LOG_TRACE(
+            &Poco::Logger::get("TableJoin"),
+            "Infer supertype for joined columns. Left: [{}], Right: [{}]",
+            format_type_map(left_type_map),
+            format_type_map(right_type_map));
+    }
+
+    return !left_type_map.empty();
+}
+
+ActionsDAGPtr TableJoin::applyKeyConvertToTable(
+    const ColumnsWithTypeAndName & cols_src, const NameToTypeMap & type_mapping, Names & names_to_rename) const
+{
+    ColumnsWithTypeAndName cols_dst = cols_src;
+    for (auto & col : cols_dst)
+    {
+        if (auto it = type_mapping.find(col.name); it != type_mapping.end())
+        {
+            col.type = it->second;
+            col.column = nullptr;
+        }
+    }
+
+    NameToNameMap key_column_rename;
+    /// Returns converting actions for tables that need to be performed before join
+    auto dag = ActionsDAG::makeConvertingActions(
+        cols_src, cols_dst, ActionsDAG::MatchColumnsMode::Name, true, !hasUsing(), &key_column_rename);
+
+    for (auto & name : names_to_rename)
+    {
+        const auto it = key_column_rename.find(name);
+        if (it != key_column_rename.end())
+            name = it->second;
+    }
+    return dag;
+}
+
 }
diff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h
index 9dcbc30f07b7..71a27849297d 100644
--- a/src/Interpreters/TableJoin.h
+++ b/src/Interpreters/TableJoin.h
@@ -5,9 +5,11 @@
 #include <Core/SettingsEnums.h>
 #include <Parsers/ASTTablesInSelectQuery.h>
 #include <Interpreters/IJoin.h>
+#include <Interpreters/join_common.h>
 #include <Interpreters/asof.h>
 #include <DataStreams/IBlockStream_fwd.h>
 #include <DataStreams/SizeLimits.h>
+#include <DataTypes/getLeastSupertype.h>
 #include <Storages/IStorage_fwd.h>
 
 #include <utility>
@@ -32,6 +34,11 @@ using VolumePtr = std::shared_ptr<IVolume>;
 
 class TableJoin
 {
+
+public:
+    using NameToTypeMap = std::unordered_map<String, DataTypePtr>;
+
+private:
     /** Query of the form `SELECT expr(x) AS k FROM t1 ANY LEFT JOIN (SELECT expr(x) AS k FROM t2) USING k`
       * The join is made by column k.
       * During the JOIN,
@@ -59,23 +66,39 @@ class TableJoin
 
     Names key_names_left;
     Names key_names_right; /// Duplicating names are qualified.
+
     ASTs key_asts_left;
     ASTs key_asts_right;
     ASTTableJoin table_join;
+
     ASOF::Inequality asof_inequality = ASOF::Inequality::GreaterOrEquals;
 
     /// All columns which can be read from joined table. Duplicating names are qualified.
     NamesAndTypesList columns_from_joined_table;
-    /// Columns will be added to block by JOIN. It's a subset of columns_from_joined_table with corrected Nullability
+    /// Columns will be added to block by JOIN.
+    /// It's a subset of columns_from_joined_table with corrected Nullability and type (if inplace type conversion is required)
     NamesAndTypesList columns_added_by_join;
 
+    /// Target type to convert key columns before join
+    NameToTypeMap left_type_map;
+    NameToTypeMap right_type_map;
+
+    ActionsDAGPtr left_converting_actions;
+    ActionsDAGPtr right_converting_actions;
+
     /// Name -> original name. Names are the same as in columns_from_joined_table list.
     std::unordered_map<String, String> original_names;
-    /// Original name -> name. Only ranamed columns.
+    /// Original name -> name. Only renamed columns.
     std::unordered_map<String, String> renames;
 
     VolumePtr tmp_volume;
 
+    Names requiredJoinedNames() const;
+
+    /// Create converting actions and change key column names if required
+    ActionsDAGPtr applyKeyConvertToTable(
+        const ColumnsWithTypeAndName & cols_src, const NameToTypeMap & type_mapping, Names & names_to_rename) const;
+
 public:
     TableJoin() = default;
     TableJoin(const Settings &, VolumePtr tmp_volume);
@@ -125,7 +148,6 @@ class TableJoin
     bool hasUsing() const { return table_join.using_expression_list != nullptr; }
     bool hasOn() const { return table_join.on_expression != nullptr; }
 
-    NameSet getQualifiedColumnsSet() const;
     NamesWithAliases getNamesWithAliases(const NameSet & required_columns) const;
     NamesWithAliases getRequiredColumns(const Block & sample, const Names & action_required_columns) const;
 
@@ -136,7 +158,23 @@ class TableJoin
     bool leftBecomeNullable(const DataTypePtr & column_type) const;
     bool rightBecomeNullable(const DataTypePtr & column_type) const;
     void addJoinedColumn(const NameAndTypePair & joined_column);
-    void addJoinedColumnsAndCorrectNullability(ColumnsWithTypeAndName & columns) const;
+
+    void addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability = true) const;
+    void addJoinedColumnsAndCorrectTypes(ColumnsWithTypeAndName & columns, bool correct_nullability = true) const;
+
+    /// Calculates common supertypes for corresponding join key columns.
+    bool inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right);
+
+    /// Calculate converting actions, rename key columns in required
+    /// For `USING` join we will convert key columns inplace and affect into types in the result table
+    /// For `JOIN ON` we will create new columns with converted keys to join by.
+    bool applyJoinKeyConvert(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns);
+
+    bool needConvert() const { return !left_type_map.empty(); }
+
+    /// Key columns should be converted before join.
+    ActionsDAGPtr leftConvertingActions() const { return left_converting_actions; }
+    ActionsDAGPtr rightConvertingActions() const { return right_converting_actions; }
 
     void setAsofInequality(ASOF::Inequality inequality) { asof_inequality = inequality; }
     ASOF::Inequality getAsofInequality() { return asof_inequality; }
@@ -144,11 +182,16 @@ class TableJoin
     ASTPtr leftKeysList() const;
     ASTPtr rightKeysList() const; /// For ON syntax only
 
-    Names requiredJoinedNames() const;
     const Names & keyNamesLeft() const { return key_names_left; }
     const Names & keyNamesRight() const { return key_names_right; }
     const NamesAndTypesList & columnsFromJoinedTable() const { return columns_from_joined_table; }
-    const NamesAndTypesList & columnsAddedByJoin() const { return columns_added_by_join; }
+    Names columnsAddedByJoin() const
+    {
+        Names res;
+        for (const auto & col : columns_added_by_join)
+            res.push_back(col.name);
+        return res;
+    }
 
     /// StorageJoin overrides key names (cause of different names qualification)
     void setRightKeys(const Names & keys) { key_names_right = keys; }
@@ -156,8 +199,6 @@ class TableJoin
     /// Split key and other columns by keys name list
     void splitAdditionalColumns(const Block & sample_block, Block & block_keys, Block & block_others) const;
     Block getRequiredRightKeys(const Block & right_table_keys, std::vector<String> & keys_sources) const;
-
-    static bool sameJoin(const TableJoin * x, const TableJoin * y);
 };
 
 }
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index bcfdf6869c3b..9318f87175ad 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -418,6 +418,13 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTSelectQuery & sele
         const auto & keys = table_join.using_expression_list->as<ASTExpressionList &>();
         for (const auto & key : keys.children)
             analyzed_join.addUsingKey(key);
+
+        /// `USING` semantic allows to have columns with changed types in result table.
+        /// `JOIN ON` should preserve types from original table
+        /// We can infer common type on syntax stage for `USING` because join is performed only by columns (not expressions)
+        /// We need to know  changed types in result tables because some analysis (e.g. analyzeAggregation) performed before join
+        /// For `JOIN ON expr1 == expr2` we will infer common type later in ExpressionAnalyzer, when types of expression will be known
+        analyzed_join.inferJoinKeyCommonType(tables[0].columns, tables[1].columns);
     }
     else if (table_join.on_expression)
     {
@@ -571,7 +578,6 @@ void TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select
         source_column_names.insert(column.name);
 
     NameSet required = columns_context.requiredColumns();
-
     if (columns_context.has_table_join)
     {
         NameSet available_columns;
diff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp
index 69727a2a6bb5..4c124f99e571 100644
--- a/src/Interpreters/join_common.cpp
+++ b/src/Interpreters/join_common.cpp
@@ -1,9 +1,11 @@
 #include <Interpreters/join_common.h>
 #include <Interpreters/TableJoin.h>
+#include <Interpreters/ActionsDAG.h>
 #include <Columns/ColumnNullable.h>
 #include <Columns/ColumnLowCardinality.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <DataTypes/DataTypeLowCardinality.h>
+#include <DataTypes/getLeastSupertype.h>
 #include <DataStreams/materializeBlock.h>
 #include <IO/WriteHelpers.h>
 
@@ -293,6 +295,13 @@ void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count)
         type->insertDefaultInto(column);
 }
 
+bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type)
+{
+    DataTypePtr left_type_strict = removeNullable(recursiveRemoveLowCardinality(left_type));
+    DataTypePtr right_type_strict = removeNullable(recursiveRemoveLowCardinality(right_type));
+    return left_type_strict->equals(*right_type_strict);
+}
+
 }
 
 
@@ -307,19 +316,21 @@ NotJoined::NotJoined(const TableJoin & table_join, const Block & saved_block_sam
     table_join.splitAdditionalColumns(right_sample_block, right_table_keys, sample_block_with_columns_to_add);
     Block required_right_keys = table_join.getRequiredRightKeys(right_table_keys, tmp);
 
-    bool remap_keys = table_join.hasUsing();
     std::unordered_map<size_t, size_t> left_to_right_key_remap;
 
-    for (size_t i = 0; i < table_join.keyNamesLeft().size(); ++i)
+    if (table_join.hasUsing())
     {
-        const String & left_key_name = table_join.keyNamesLeft()[i];
-        const String & right_key_name = table_join.keyNamesRight()[i];
+        for (size_t i = 0; i < table_join.keyNamesLeft().size(); ++i)
+        {
+            const String & left_key_name = table_join.keyNamesLeft()[i];
+            const String & right_key_name = table_join.keyNamesRight()[i];
 
-        size_t left_key_pos = result_sample_block.getPositionByName(left_key_name);
-        size_t right_key_pos = saved_block_sample.getPositionByName(right_key_name);
+            size_t left_key_pos = result_sample_block.getPositionByName(left_key_name);
+            size_t right_key_pos = saved_block_sample.getPositionByName(right_key_name);
 
-        if (remap_keys && !required_right_keys.has(right_key_name))
-            left_to_right_key_remap[left_key_pos] = right_key_pos;
+            if (!required_right_keys.has(right_key_name))
+                left_to_right_key_remap[left_key_pos] = right_key_pos;
+        }
     }
 
     /// result_sample_block: left_sample_block + left expressions, right not key columns, required right keys
diff --git a/src/Interpreters/join_common.h b/src/Interpreters/join_common.h
index 76fbcf8d87d5..cec414384484 100644
--- a/src/Interpreters/join_common.h
+++ b/src/Interpreters/join_common.h
@@ -2,6 +2,8 @@
 
 #include <Core/Block.h>
 #include <Interpreters/IJoin.h>
+#include <Interpreters/ActionsDAG.h>
+#include <Interpreters/ExpressionActions.h>
 
 namespace DB
 {
@@ -36,6 +38,8 @@ void joinTotals(const Block & totals, const Block & columns_to_add, const TableJ
 
 void addDefaultValues(IColumn & column, const DataTypePtr & type, size_t count);
 
+bool typesEqualUpToNullability(DataTypePtr left_type, DataTypePtr right_type);
+
 }
 
 /// Creates result from right table data in RIGHT and FULL JOIN when keys are not present in left table.
