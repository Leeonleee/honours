{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40020,
  "instance_id": "ClickHouse__ClickHouse-40020",
  "issue_numbers": [
    "39818"
  ],
  "base_commit": "eb1ac41ac52e78c2c6931ab610e39de89ec4d555",
  "patch": "diff --git a/src/Common/ColumnsHashing.h b/src/Common/ColumnsHashing.h\nindex e921f4fbf9ab..c3a087c0a6ef 100644\n--- a/src/Common/ColumnsHashing.h\n+++ b/src/Common/ColumnsHashing.h\n@@ -6,11 +6,9 @@\n #include <Common/Arena.h>\n #include <Common/LRUCache.h>\n #include <Common/assert_cast.h>\n-#include \"Columns/IColumn.h\"\n #include <base/unaligned.h>\n \n #include <Columns/ColumnString.h>\n-#include <Columns/ColumnConst.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnLowCardinality.h>\n \n@@ -85,11 +83,8 @@ struct HashMethodString\n \n     HashMethodString(const ColumnRawPtrs & key_columns, const Sizes & /*key_sizes*/, const HashMethodContextPtr &)\n     {\n-        const IColumn * column = key_columns[0];\n-        if (isColumnConst(*column))\n-            column = &assert_cast<const ColumnConst &>(*column).getDataColumn();\n-\n-        const ColumnString & column_string = assert_cast<const ColumnString &>(*column);\n+        const IColumn & column = *key_columns[0];\n+        const ColumnString & column_string = assert_cast<const ColumnString &>(column);\n         offsets = column_string.getOffsets().data();\n         chars = column_string.getChars().data();\n     }\ndiff --git a/src/Processors/Transforms/IntersectOrExceptTransform.cpp b/src/Processors/Transforms/IntersectOrExceptTransform.cpp\nindex 3e39123ae4ba..1ac82e99cf2d 100644\n--- a/src/Processors/Transforms/IntersectOrExceptTransform.cpp\n+++ b/src/Processors/Transforms/IntersectOrExceptTransform.cpp\n@@ -128,7 +128,11 @@ void IntersectOrExceptTransform::accumulate(Chunk chunk)\n     column_ptrs.reserve(key_columns_pos.size());\n \n     for (auto pos : key_columns_pos)\n+    {\n+        /// Hash methods expect non-const column\n+        columns[pos] = columns[pos]->convertToFullColumnIfConst();\n         column_ptrs.emplace_back(columns[pos].get());\n+    }\n \n     if (!data)\n         data.emplace();\n@@ -160,8 +164,11 @@ void IntersectOrExceptTransform::filter(Chunk & chunk)\n     column_ptrs.reserve(key_columns_pos.size());\n \n     for (auto pos : key_columns_pos)\n+    {\n+        /// Hash methods expect non-const column\n+        columns[pos] = columns[pos]->convertToFullColumnIfConst();\n         column_ptrs.emplace_back(columns[pos].get());\n-\n+    }\n     if (!data)\n         data.emplace();\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02381_intersect_except_const_column.reference b/tests/queries/0_stateless/02381_intersect_except_const_column.reference\nnew file mode 100644\nindex 000000000000..290835b412ec\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_intersect_except_const_column.reference\n@@ -0,0 +1,61 @@\n+fooooo\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\ndiff --git a/tests/queries/0_stateless/02381_intersect_except_const_column.sql b/tests/queries/0_stateless/02381_intersect_except_const_column.sql\nnew file mode 100644\nindex 000000000000..b10f913dd1e8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_intersect_except_const_column.sql\n@@ -0,0 +1,13 @@\n+-- Test: crash the server\n+SELECT 'fooooo' INTERSECT SELECT 'fooooo';\n+SELECT 'fooooo' EXCEPT SELECT 'fooooo';\n+\n+-- Test: intersect return incorrect result for const column\n+SELECT 1 FROM numbers(10) INTERSECT SELECT 1 FROM numbers(10);\n+SELECT toString(1) FROM numbers(10) INTERSECT SELECT toString(1) FROM numbers(10);\n+SELECT '1' FROM numbers(10) INTERSECT SELECT '1' FROM numbers(10);\n+\n+-- Test: except return incorrect result for const column\n+SELECT 2 FROM numbers(10) EXCEPT SELECT 1 FROM numbers(5);\n+SELECT toString(2) FROM numbers(10) EXCEPT SELECT toString(1) FROM numbers(5);\n+SELECT '2' FROM numbers(10) EXCEPT SELECT '1' FROM numbers(5);\n\\ No newline at end of file\n",
  "problem_statement": "Wrong result of intersect\n```sql\r\nselect 1 from numbers(10) intersect select 1 from numbers(10)\r\n\r\nSELECT 1\r\nFROM numbers(10)\r\nINTERSECT\r\nSELECT 1\r\nFROM numbers(10)\r\n\r\nQuery id: 9f2d11c5-269c-41dc-9b4c-8f1423aafcc7\r\n\r\n\u250c\u25001\u2500\u2510\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n\r\n8 rows in set. Elapsed: 0.002 sec. \r\n```\n",
  "hints_text": "Related to https://github.com/ClickHouse/ClickHouse/issues/39787. To get your behaviour need to implement `intersect distinct`. \n> Related to #39787. To get your behaviour need to implement `intersect distinct`.\r\n\r\nBut it's also strange that the result have 8 rows, and it will produce different results when execute it more than one time.\noh, did not notice it was 8 rows and not 10",
  "created_at": "2022-08-09T08:48:19Z",
  "modified_files": [
    "src/Common/ColumnsHashing.h",
    "src/Processors/Transforms/IntersectOrExceptTransform.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02381_intersect_except_const_column.reference",
    "b/tests/queries/0_stateless/02381_intersect_except_const_column.sql"
  ]
}