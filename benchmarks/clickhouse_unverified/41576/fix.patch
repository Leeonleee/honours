diff --git a/src/Processors/Transforms/PartialSortingTransform.cpp b/src/Processors/Transforms/PartialSortingTransform.cpp
index 3a2cecd3b262..33c2d870b761 100644
--- a/src/Processors/Transforms/PartialSortingTransform.cpp
+++ b/src/Processors/Transforms/PartialSortingTransform.cpp
@@ -111,7 +111,6 @@ void PartialSortingTransform::transform(Chunk & chunk)
         read_rows->add(chunk.getNumRows());
 
     auto block = getInputPort().getHeader().cloneWithColumns(chunk.detachColumns());
-    size_t block_rows_before_filter = block.rows();
 
     /** If we've saved columns from previously blocks we could filter all rows from current block
       * which are unnecessary for sortBlock(...) because they obviously won't be in the top LIMIT rows.
@@ -138,10 +137,8 @@ void PartialSortingTransform::transform(Chunk & chunk)
 
     sortBlock(block, description, limit);
 
-    size_t block_rows_after_filter = block.rows();
-
     /// Check if we can use this block for optimization.
-    if (min_limit_for_partial_sort_optimization <= limit && block_rows_after_filter > 0 && limit <= block_rows_before_filter)
+    if (min_limit_for_partial_sort_optimization <= limit && limit <= block.rows())
     {
         /** If we filtered more than limit rows from block take block last row.
           * Otherwise take last limit row.
@@ -149,7 +146,7 @@ void PartialSortingTransform::transform(Chunk & chunk)
           * If current threshold value is empty, update current threshold value.
           * If min block value is less than current threshold value, update current threshold value.
           */
-        size_t min_row_to_compare = limit <= block_rows_after_filter ? (limit - 1) : (block_rows_after_filter - 1);
+        size_t min_row_to_compare = limit - 1;
         auto raw_block_columns = extractRawColumns(block, description_with_positions);
 
         if (sort_description_threshold_columns.empty() ||
