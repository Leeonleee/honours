diff --git a/programs/server/config.xml b/programs/server/config.xml
index 372315c79227..849d3dc32ba1 100644
--- a/programs/server/config.xml
+++ b/programs/server/config.xml
@@ -321,9 +321,9 @@
              Parameters:
                 host - LDAP server hostname or IP, this parameter is mandatory and cannot be empty.
                 port - LDAP server port, default is 636 if enable_tls is set to true, 389 otherwise.
-                auth_dn_prefix, auth_dn_suffix - prefix and suffix used to construct the DN to bind to.
-                        Effectively, the resulting DN will be constructed as auth_dn_prefix + escape(user_name) + auth_dn_suffix string.
-                        Note, that this implies that auth_dn_suffix should usually have comma ',' as its first non-space character.
+                bind_dn - template used to construct the DN to bind to.
+                        The resulting DN will be constructed by replacing all '{user_name}' substrings of the template with the actual
+                         user name during each authentication attempt.
                 verification_cooldown - a period of time, in seconds, after a successful bind attempt, during which a user will be assumed
                          to be successfully authenticated for all consecutive requests without contacting the LDAP server.
                         Specify 0 (the default) to disable caching and force contacting the LDAP server for each authentication request.
@@ -344,8 +344,7 @@
                 <my_ldap_server>
                     <host>localhost</host>
                     <port>636</port>
-                    <auth_dn_prefix>uid=</auth_dn_prefix>
-                    <auth_dn_suffix>,ou=users,dc=example,dc=com</auth_dn_suffix>
+                    <bind_dn>uid={user_name},ou=users,dc=example,dc=com</bind_dn>
                     <verification_cooldown>300</verification_cooldown>
                     <enable_tls>yes</enable_tls>
                     <tls_minimum_protocol_version>tls1.2</tls_minimum_protocol_version>
@@ -375,9 +374,29 @@
                 server - one of LDAP server names defined in 'ldap_servers' config section above.
                         This parameter is mandatory and cannot be empty.
                 roles - section with a list of locally defined roles that will be assigned to each user retrieved from the LDAP server.
-                        If no roles are specified, user will not be able to perform any actions after authentication.
-                        If any of the listed roles is not defined locally at the time of authentication, the authenthication attempt
-                         will fail as if the provided password was incorrect.
+                        If no roles are specified here or assigned during role mapping (below), user will not be able to perform any
+                         actions after authentication.
+                role_mapping - section with LDAP search parameters and mapping rules.
+                        When a user authenticates, while still bound to LDAP, an LDAP search is performed using search_filter and the
+                         name of the logged in user. For each entry found during that search, the value of the specified attribute is
+                         extracted. For each attribute value that has the specified prefix, the prefix is removed, and the rest of the
+                         value becomes the name of a local role defined in ClickHouse, which is expected to be created beforehand by
+                         CREATE ROLE command.
+                        There can be multiple 'role_mapping' sections defined inside the same 'ldap' section. All of them will be
+                         applied.
+                    base_dn - template used to construct the base DN for the LDAP search.
+                            The resulting DN will be constructed by replacing all '{user_name}' and '{bind_dn}' substrings
+                             of the template with the actual user name and bind DN during each LDAP search.
+                    scope - scope of the LDAP search.
+                            Accepted values are: 'base', 'one_level', 'children', 'subtree' (the default).
+                    search_filter - template used to construct the search filter for the LDAP search.
+                            The resulting filter will be constructed by replacing all '{user_name}', '{bind_dn}', and '{base_dn}'
+                             substrings of the template with the actual user name, bind DN, and base DN during each LDAP search.
+                            Note, that the special characters must be escaped properly in XML.
+                    attribute - attribute name whose values will be returned by the LDAP search.
+                    prefix - prefix, that will be expected to be in front of each string in the original list of strings returned by
+                             the LDAP search. Prefix will be removed from the original strings and resulting strings will be treated
+                             as local role names. Empty, by default.
              Example:
                 <ldap>
                     <server>my_ldap_server</server>
@@ -385,6 +404,13 @@
                         <my_local_role1 />
                         <my_local_role2 />
                     </roles>
+                    <role_mapping>
+                        <base_dn>ou=groups,dc=example,dc=com</base_dn>
+                        <scope>subtree</scope>
+                        <search_filter>(&amp;(objectClass=groupOfNames)(member={bind_dn}))</search_filter>
+                        <attribute>cn</attribute>
+                        <prefix>clickhouse_</prefix>
+                    </role_mapping>
                 </ldap>
         -->
     </user_directories>
diff --git a/src/Access/Authentication.cpp b/src/Access/Authentication.cpp
index 5fab2c92624e..19c40c068b47 100644
--- a/src/Access/Authentication.cpp
+++ b/src/Access/Authentication.cpp
@@ -33,13 +33,13 @@ Authentication::Digest Authentication::getPasswordDoubleSHA1() const
         }
 
         case SHA256_PASSWORD:
-            throw Exception("Cannot get password double SHA1 for user with 'SHA256_PASSWORD' authentication.", ErrorCodes::BAD_ARGUMENTS);
+            throw Exception("Cannot get password double SHA1 for user with 'SHA256_PASSWORD' authentication", ErrorCodes::BAD_ARGUMENTS);
 
         case DOUBLE_SHA1_PASSWORD:
             return password_hash;
 
         case LDAP_SERVER:
-            throw Exception("Cannot get password double SHA1 for user with 'LDAP_SERVER' authentication.", ErrorCodes::BAD_ARGUMENTS);
+            throw Exception("Cannot get password double SHA1 for user with 'LDAP_SERVER' authentication", ErrorCodes::BAD_ARGUMENTS);
 
         case MAX_TYPE:
             break;
diff --git a/src/Access/Authentication.h b/src/Access/Authentication.h
index f98d2ed46792..bd22b7f0ff50 100644
--- a/src/Access/Authentication.h
+++ b/src/Access/Authentication.h
@@ -6,6 +6,8 @@
 #include <Poco/SHA1Engine.h>
 #include <boost/algorithm/hex.hpp>
 #include <boost/algorithm/string/case_conv.hpp>
+#include <set>
+#include <vector>
 
 
 namespace DB
@@ -19,6 +21,10 @@ namespace ErrorCodes
 }
 
 class ExternalAuthenticators;
+struct LDAPSearchParams;
+using LDAPSearchParamsList = std::vector<LDAPSearchParams>;
+using LDAPSearchResults = std::set<String>;
+using LDAPSearchResultsList = std::vector<LDAPSearchResults>;
 
 /// Authentication type and encrypted password for checking when an user logins.
 class Authentication
diff --git a/src/Access/ExternalAuthenticators.cpp b/src/Access/ExternalAuthenticators.cpp
index 81ab1af3b295..6f66f4303e16 100644
--- a/src/Access/ExternalAuthenticators.cpp
+++ b/src/Access/ExternalAuthenticators.cpp
@@ -31,6 +31,7 @@ auto parseLDAPServer(const Poco::Util::AbstractConfiguration & config, const Str
 
     const bool has_host = config.has(ldap_server_config + ".host");
     const bool has_port = config.has(ldap_server_config + ".port");
+    const bool has_bind_dn = config.has(ldap_server_config + ".bind_dn");
     const bool has_auth_dn_prefix = config.has(ldap_server_config + ".auth_dn_prefix");
     const bool has_auth_dn_suffix = config.has(ldap_server_config + ".auth_dn_suffix");
     const bool has_verification_cooldown = config.has(ldap_server_config + ".verification_cooldown");
@@ -51,11 +52,19 @@ auto parseLDAPServer(const Poco::Util::AbstractConfiguration & config, const Str
     if (params.host.empty())
         throw Exception("Empty 'host' entry", ErrorCodes::BAD_ARGUMENTS);
 
-    if (has_auth_dn_prefix)
-        params.auth_dn_prefix = config.getString(ldap_server_config + ".auth_dn_prefix");
+    if (has_bind_dn)
+    {
+        if (has_auth_dn_prefix || has_auth_dn_suffix)
+            throw Exception("Deprecated 'auth_dn_prefix' and 'auth_dn_suffix' entries cannot be used with 'bind_dn' entry", ErrorCodes::BAD_ARGUMENTS);
 
-    if (has_auth_dn_suffix)
-        params.auth_dn_suffix = config.getString(ldap_server_config + ".auth_dn_suffix");
+        params.bind_dn = config.getString(ldap_server_config + ".bind_dn");
+    }
+    else if (has_auth_dn_prefix || has_auth_dn_suffix)
+    {
+        const auto auth_dn_prefix = config.getString(ldap_server_config + ".auth_dn_prefix");
+        const auto auth_dn_suffix = config.getString(ldap_server_config + ".auth_dn_suffix");
+        params.bind_dn = auth_dn_prefix + "{user_name}" + auth_dn_suffix;
+    }
 
     if (has_verification_cooldown)
         params.verification_cooldown = std::chrono::seconds{config.getUInt64(ldap_server_config + ".verification_cooldown")};
@@ -168,7 +177,8 @@ void ExternalAuthenticators::setConfiguration(const Poco::Util::AbstractConfigur
     }
 }
 
-bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const String & user_name, const String & password) const
+bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const String & user_name, const String & password,
+    const LDAPSearchParamsList * search_params, LDAPSearchResultsList * search_results) const
 {
     std::optional<LDAPServerParams> params;
     std::size_t params_hash = 0;
@@ -184,7 +194,15 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const S
         params = pit->second;
         params->user = user_name;
         params->password = password;
-        params_hash = params->getCoreHash();
+
+        params->combineCoreHash(params_hash);
+        if (search_params)
+        {
+            for (const auto & params_instance : *search_params)
+            {
+                params_instance.combineHash(params_hash);
+            }
+        }
 
         // Check the cache, but only if the caching is enabled at all.
         if (params->verification_cooldown > std::chrono::seconds{0})
@@ -208,9 +226,19 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const S
                         // Check if we can safely "reuse" the result of the previous successful password verification.
                         entry.last_successful_params_hash == params_hash &&
                         last_check_period >= std::chrono::seconds{0} &&
-                        last_check_period <= params->verification_cooldown
+                        last_check_period <= params->verification_cooldown &&
+
+                        // Ensure that search_params are compatible.
+                        (
+                            search_params == nullptr ?
+                            entry.last_successful_search_results.empty() :
+                            search_params->size() == entry.last_successful_search_results.size()
+                        )
                     )
                     {
+                        if (search_results)
+                            *search_results = entry.last_successful_search_results;
+
                         return true;
                     }
 
@@ -227,7 +255,7 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const S
     }
 
     LDAPSimpleAuthClient client(params.value());
-    const auto result = client.check();
+    const auto result = client.authenticate(search_params, search_results);
     const auto current_check_timestamp = std::chrono::steady_clock::now();
 
     // Update the cache, but only if this is the latest check and the server is still configured in a compatible way.
@@ -244,8 +272,18 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const S
         new_params.user = user_name;
         new_params.password = password;
 
+        std::size_t new_params_hash = 0;
+        new_params.combineCoreHash(new_params_hash);
+        if (search_params)
+        {
+            for (const auto & params_instance : *search_params)
+            {
+                params_instance.combineHash(new_params_hash);
+            }
+        }
+
         // If the critical server params have changed while we were checking the password, we discard the current result.
-        if (params_hash != new_params.getCoreHash())
+        if (params_hash != new_params_hash)
             return false;
 
         auto & entry = ldap_server_caches[server][user_name];
@@ -253,8 +291,20 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const S
         {
             entry.last_successful_params_hash = params_hash;
             entry.last_successful_authentication_timestamp = current_check_timestamp;
+
+            if (search_results)
+                entry.last_successful_search_results = *search_results;
+            else
+                entry.last_successful_search_results.clear();
         }
-        else if (entry.last_successful_params_hash != params_hash)
+        else if (
+            entry.last_successful_params_hash != params_hash ||
+            (
+                search_params == nullptr ?
+                !entry.last_successful_search_results.empty() :
+                search_params->size() != entry.last_successful_search_results.size()
+            )
+        )
         {
             // Somehow a newer check with different params/password succeeded, so the current result is obsolete and we discard it.
             return false;
diff --git a/src/Access/ExternalAuthenticators.h b/src/Access/ExternalAuthenticators.h
index fa618c92b3f4..abcc8e8d10d6 100644
--- a/src/Access/ExternalAuthenticators.h
+++ b/src/Access/ExternalAuthenticators.h
@@ -28,13 +28,15 @@ class ExternalAuthenticators
 public:
     void reset();
     void setConfiguration(const Poco::Util::AbstractConfiguration & config, Poco::Logger * log);
-    bool checkLDAPCredentials(const String & server, const String & user_name, const String & password) const;
+    bool checkLDAPCredentials(const String & server, const String & user_name, const String & password,
+        const LDAPSearchParamsList * search_params = nullptr, LDAPSearchResultsList * search_results = nullptr) const;
 
 private:
     struct LDAPCacheEntry
     {
         std::size_t last_successful_params_hash = 0;
         std::chrono::steady_clock::time_point last_successful_authentication_timestamp;
+        LDAPSearchResultsList last_successful_search_results;
     };
 
     using LDAPServerCache = std::unordered_map<String, LDAPCacheEntry>; // user name   -> cache entry
diff --git a/src/Access/LDAPAccessStorage.cpp b/src/Access/LDAPAccessStorage.cpp
index 92de7fce8d79..2602422a59ac 100644
--- a/src/Access/LDAPAccessStorage.cpp
+++ b/src/Access/LDAPAccessStorage.cpp
@@ -1,7 +1,9 @@
 #include <Access/LDAPAccessStorage.h>
 #include <Access/AccessControlManager.h>
+#include <Access/ExternalAuthenticators.h>
 #include <Access/User.h>
 #include <Access/Role.h>
+#include <Access/LDAPClient.h>
 #include <Common/Exception.h>
 #include <common/logger_useful.h>
 #include <ext/scope_guard.h>
@@ -9,9 +11,11 @@
 #include <Poco/JSON/JSON.h>
 #include <Poco/JSON/Object.h>
 #include <Poco/JSON/Stringifier.h>
+#include <boost/container_hash/hash.hpp>
 #include <boost/range/algorithm/copy.hpp>
 #include <iterator>
 #include <sstream>
+#include <unordered_map>
 
 
 namespace DB
@@ -44,95 +48,327 @@ void LDAPAccessStorage::setConfiguration(AccessControlManager * access_control_m
 
     const bool has_server = config.has(prefix_str + "server");
     const bool has_roles = config.has(prefix_str + "roles");
+    const bool has_role_mapping = config.has(prefix_str + "role_mapping");
 
     if (!has_server)
-        throw Exception("Missing 'server' field for LDAP user directory.", ErrorCodes::BAD_ARGUMENTS);
+        throw Exception("Missing 'server' field for LDAP user directory", ErrorCodes::BAD_ARGUMENTS);
 
     const auto ldap_server_cfg = config.getString(prefix_str + "server");
     if (ldap_server_cfg.empty())
-        throw Exception("Empty 'server' field for LDAP user directory.", ErrorCodes::BAD_ARGUMENTS);
+        throw Exception("Empty 'server' field for LDAP user directory", ErrorCodes::BAD_ARGUMENTS);
 
-    std::set<String> roles_cfg;
+    std::set<String> common_roles_cfg;
     if (has_roles)
     {
         Poco::Util::AbstractConfiguration::Keys role_names;
         config.keys(prefix_str + "roles", role_names);
 
         // Currently, we only extract names of roles from the section names and assign them directly and unconditionally.
-        roles_cfg.insert(role_names.begin(), role_names.end());
+        common_roles_cfg.insert(role_names.begin(), role_names.end());
+    }
+
+    LDAPSearchParamsList role_search_params_cfg;
+    if (has_role_mapping)
+    {
+        Poco::Util::AbstractConfiguration::Keys all_keys;
+        config.keys(prefix, all_keys);
+        for (const auto & key : all_keys)
+        {
+            if (key != "role_mapping" && key.find("role_mapping[") != 0)
+                continue;
+
+            const String rm_prefix = prefix_str + key;
+            const String rm_prefix_str = rm_prefix + '.';
+            role_search_params_cfg.emplace_back();
+            auto & rm_params = role_search_params_cfg.back();
+
+            rm_params.base_dn = config.getString(rm_prefix_str + "base_dn", "");
+            rm_params.search_filter = config.getString(rm_prefix_str + "search_filter", "");
+            rm_params.attribute = config.getString(rm_prefix_str + "attribute", "cn");
+            rm_params.prefix = config.getString(rm_prefix_str + "prefix", "");
+
+            auto scope = config.getString(rm_prefix_str + "scope", "subtree");
+            boost::algorithm::to_lower(scope);
+            if (scope == "base")           rm_params.scope = LDAPSearchParams::Scope::BASE;
+            else if (scope == "one_level") rm_params.scope = LDAPSearchParams::Scope::ONE_LEVEL;
+            else if (scope == "subtree")   rm_params.scope = LDAPSearchParams::Scope::SUBTREE;
+            else if (scope == "children")  rm_params.scope = LDAPSearchParams::Scope::CHILDREN;
+            else
+                throw Exception("Invalid value of 'scope' field in '" + key + "' section of LDAP user directory, must be one of 'base', 'one_level', 'subtree', or 'children'", ErrorCodes::BAD_ARGUMENTS);
+        }
     }
 
     access_control_manager = access_control_manager_;
     ldap_server = ldap_server_cfg;
-    default_role_names.swap(roles_cfg);
-    roles_of_interest.clear();
+    role_search_params.swap(role_search_params_cfg);
+    common_role_names.swap(common_roles_cfg);
+
+    external_role_hashes.clear();
+    users_per_roles.clear();
+    roles_per_users.clear();
+    granted_role_names.clear();
+    granted_role_ids.clear();
+
     role_change_subscription = access_control_manager->subscribeForChanges<Role>(
         [this] (const UUID & id, const AccessEntityPtr & entity)
         {
             return this->processRoleChange(id, entity);
         }
     );
-
-    /// Update `roles_of_interests` with initial values.
-    for (const auto & role_name : default_role_names)
-    {
-        if (auto role_id = access_control_manager->find<Role>(role_name))
-            roles_of_interest.emplace(*role_id, role_name);
-    }
 }
 
 
 void LDAPAccessStorage::processRoleChange(const UUID & id, const AccessEntityPtr & entity)
 {
     std::scoped_lock lock(mutex);
+    const auto role = typeid_cast<std::shared_ptr<const Role>>(entity);
+    const auto it = granted_role_names.find(id);
+
+    if (role) // Added or renamed a role.
+    {
+        const auto & new_role_name = role->getName();
+        if (it != granted_role_names.end()) // Renamed a granted role.
+        {
+            const auto & old_role_name = it->second;
+            if (new_role_name != old_role_name)
+            {
+                // Revoke the old role first, then grant the new role.
+                applyRoleChangeNoLock(false /* revoke */, id, old_role_name);
+                applyRoleChangeNoLock(true /* grant */, id, new_role_name);
+            }
+        }
+        else // Added a role.
+        {
+            applyRoleChangeNoLock(true /* grant */, id, new_role_name);
+        }
+    }
+    else // Removed a role.
+    {
+        if (it != granted_role_names.end()) // Removed a granted role.
+        {
+            const auto & old_role_name = it->second;
+            applyRoleChangeNoLock(false /* revoke */, id, old_role_name);
+        }
+    }
+}
+
 
-    /// Update `roles_of_interests`.
-    auto role = typeid_cast<std::shared_ptr<const Role>>(entity);
-    bool need_to_update_users = false;
+void LDAPAccessStorage::applyRoleChangeNoLock(bool grant, const UUID & role_id, const String & role_name)
+{
+    std::vector<UUID> user_ids;
 
-    if (role && default_role_names.count(role->getName()))
+    // Build a list of ids of the relevant users.
+    if (common_role_names.count(role_name))
     {
-        /// If a role was created with one of the `default_role_names` or renamed to one of the `default_role_names`,
-        /// then set `need_to_update_users`.
-        need_to_update_users = roles_of_interest.insert_or_assign(id, role->getName()).second;
+        user_ids = memory_storage.findAll<User>();
     }
     else
     {
-        /// If a role was removed or renamed to a name which isn't contained in the `default_role_names`,
-        /// then set `need_to_update_users`.
-        need_to_update_users = roles_of_interest.erase(id) > 0;
+        const auto it = users_per_roles.find(role_name);
+        if (it != users_per_roles.end())
+        {
+            const auto & user_names = it->second;
+            user_ids.reserve(user_names.size());
+
+            for (const auto & user_name : user_names)
+            {
+                if (const auto user_id = memory_storage.find<User>(user_name))
+                    user_ids.emplace_back(*user_id);
+            }
+        }
     }
 
-    /// Update users which have been created.
-    if (need_to_update_users)
+    // Update the granted roles of the relevant users.
+    if (!user_ids.empty())
     {
-        auto update_func = [this] (const AccessEntityPtr & entity_) -> AccessEntityPtr
+        auto update_func = [&role_id, &grant] (const AccessEntityPtr & entity_) -> AccessEntityPtr
         {
             if (auto user = typeid_cast<std::shared_ptr<const User>>(entity_))
             {
                 auto changed_user = typeid_cast<std::shared_ptr<User>>(user->clone());
                 auto & granted_roles = changed_user->granted_roles.roles;
-                granted_roles.clear();
-                boost::range::copy(roles_of_interest | boost::adaptors::map_keys, std::inserter(granted_roles, granted_roles.end()));
+
+                if (grant)
+                    granted_roles.insert(role_id);
+                else
+                    granted_roles.erase(role_id);
+
                 return changed_user;
             }
             return entity_;
         };
-        memory_storage.update(memory_storage.findAll<User>(), update_func);
+
+        memory_storage.update(user_ids, update_func);
     }
+
+    // Actualize granted_role_* mappings.
+    if (grant)
+    {
+        if (!user_ids.empty())
+        {
+            granted_role_names.insert_or_assign(role_id, role_name);
+            granted_role_ids.insert_or_assign(role_name, role_id);
+        }
+    }
+    else
+    {
+        granted_role_names.erase(role_id);
+        granted_role_ids.erase(role_name);
+    }
+}
+
+
+void LDAPAccessStorage::assignRolesNoLock(User & user, const LDAPSearchResultsList & external_roles) const
+{
+    const auto external_roles_hash = boost::hash<LDAPSearchResultsList>{}(external_roles);
+    return assignRolesNoLock(user, external_roles, external_roles_hash);
 }
 
 
-void LDAPAccessStorage::checkAllDefaultRoleNamesFoundNoLock() const
+void LDAPAccessStorage::assignRolesNoLock(User & user, const LDAPSearchResultsList & external_roles, const std::size_t external_roles_hash) const
 {
-    boost::container::flat_set<std::string_view> role_names_of_interest;
-    boost::range::copy(roles_of_interest | boost::adaptors::map_values, std::inserter(role_names_of_interest, role_names_of_interest.end()));
+    const auto & user_name = user.getName();
+    auto & granted_roles = user.granted_roles.roles;
+    const auto local_role_names = mapExternalRolesNoLock(external_roles);
 
-    for (const auto & role_name : default_role_names)
+    auto grant_role = [this, &user_name, &granted_roles] (const String & role_name, const bool common)
     {
-        if (!role_names_of_interest.count(role_name))
-            throwDefaultRoleNotFound(role_name);
+        auto it = granted_role_ids.find(role_name);
+        if (it == granted_role_ids.end())
+        {
+            if (const auto role_id = access_control_manager->find<Role>(role_name))
+            {
+                granted_role_names.insert_or_assign(*role_id, role_name);
+                it = granted_role_ids.insert_or_assign(role_name, *role_id).first;
+            }
+        }
+
+        if (it != granted_role_ids.end())
+        {
+            const auto & role_id = it->second;
+            granted_roles.insert(role_id);
+        }
+        else
+        {
+            LOG_WARNING(getLogger(), "Unable to grant {} role '{}' to user '{}': role not found", (common ? "common" : "mapped"), role_name, user_name);
+        }
+    };
+
+    external_role_hashes.erase(user_name);
+    granted_roles.clear();
+    const auto old_role_names = std::move(roles_per_users[user_name]);
+
+    // Grant the common roles first.
+    for (const auto & role_name : common_role_names)
+    {
+        grant_role(role_name, true /* common */);
     }
+
+    // Grant the mapped external roles and actualize users_per_roles mapping.
+    // local_role_names allowed to overlap with common_role_names.
+    for (const auto & role_name : local_role_names)
+    {
+        grant_role(role_name, false /* mapped */);
+        users_per_roles[role_name].insert(user_name);
+    }
+
+    // Cleanup users_per_roles and granted_role_* mappings.
+    for (const auto & old_role_name : old_role_names)
+    {
+        if (local_role_names.count(old_role_name))
+            continue;
+
+        const auto rit = users_per_roles.find(old_role_name);
+        if (rit == users_per_roles.end())
+            continue;
+
+        auto & user_names = rit->second;
+        user_names.erase(user_name);
+
+        if (!user_names.empty())
+            continue;
+
+        users_per_roles.erase(rit);
+
+        if (common_role_names.count(old_role_name))
+            continue;
+
+        const auto iit = granted_role_ids.find(old_role_name);
+        if (iit == granted_role_ids.end())
+            continue;
+
+        const auto old_role_id = iit->second;
+        granted_role_names.erase(old_role_id);
+        granted_role_ids.erase(iit);
+    }
+
+    // Actualize roles_per_users mapping and external_role_hashes cache.
+    if (local_role_names.empty())
+        roles_per_users.erase(user_name);
+    else
+        roles_per_users[user_name] = std::move(local_role_names);
+
+    external_role_hashes[user_name] = external_roles_hash;
+}
+
+
+void LDAPAccessStorage::updateAssignedRolesNoLock(const UUID & id, const String & user_name, const LDAPSearchResultsList & external_roles) const
+{
+    // No need to include common_role_names in this hash each time, since they don't change.
+    const auto external_roles_hash = boost::hash<LDAPSearchResultsList>{}(external_roles);
+
+    // Map and grant the roles from scratch only if the list of external role has changed.
+    const auto it = external_role_hashes.find(user_name);
+    if (it != external_role_hashes.end() && it->second == external_roles_hash)
+        return;
+
+    auto update_func = [this, &external_roles, external_roles_hash] (const AccessEntityPtr & entity_) -> AccessEntityPtr
+    {
+        if (auto user = typeid_cast<std::shared_ptr<const User>>(entity_))
+        {
+            auto changed_user = typeid_cast<std::shared_ptr<User>>(user->clone());
+            assignRolesNoLock(*changed_user, external_roles, external_roles_hash);
+            return changed_user;
+        }
+        return entity_;
+    };
+
+    memory_storage.update(id, update_func);
+}
+
+
+std::set<String> LDAPAccessStorage::mapExternalRolesNoLock(const LDAPSearchResultsList & external_roles) const
+{
+    std::set<String> role_names;
+
+    if (external_roles.size() != role_search_params.size())
+        throw Exception("Unable to map external roles", ErrorCodes::BAD_ARGUMENTS);
+
+    for (std::size_t i = 0; i < external_roles.size(); ++i)
+    {
+        const auto & external_role_set = external_roles[i];
+        const auto & prefix = role_search_params[i].prefix;
+
+        for (const auto & external_role : external_role_set)
+        {
+            if (
+                prefix.size() < external_role.size() &&
+                external_role.compare(0, prefix.size(), prefix) == 0
+            )
+            {
+                role_names.emplace(external_role, prefix.size());
+            }
+        }
+    }
+
+    return role_names;
+}
+
+
+bool LDAPAccessStorage::isPasswordCorrectLDAPNoLock(const String & user_name, const String & password,
+    const ExternalAuthenticators & external_authenticators, LDAPSearchResultsList & search_results) const
+{
+    return external_authenticators.checkLDAPCredentials(ldap_server, user_name, password, &role_search_params, &search_results);
 }
 
 
@@ -148,7 +384,37 @@ String LDAPAccessStorage::getStorageParamsJSON() const
     Poco::JSON::Object params_json;
 
     params_json.set("server", ldap_server);
-    params_json.set("roles", default_role_names);
+
+    Poco::JSON::Array common_role_names_json;
+    for (const auto & role : common_role_names)
+    {
+        common_role_names_json.add(role);
+    }
+    params_json.set("roles", common_role_names_json);
+
+    Poco::JSON::Array role_mappings_json;
+    for (const auto & role_mapping : role_search_params)
+    {
+        Poco::JSON::Object role_mapping_json;
+
+        role_mapping_json.set("base_dn", role_mapping.base_dn);
+        role_mapping_json.set("search_filter", role_mapping.search_filter);
+        role_mapping_json.set("attribute", role_mapping.attribute);
+        role_mapping_json.set("prefix", role_mapping.prefix);
+
+        String scope;
+        switch (role_mapping.scope)
+        {
+            case LDAPSearchParams::Scope::BASE:      scope = "base"; break;
+            case LDAPSearchParams::Scope::ONE_LEVEL: scope = "one_level"; break;
+            case LDAPSearchParams::Scope::SUBTREE:   scope = "subtree"; break;
+            case LDAPSearchParams::Scope::CHILDREN:  scope = "children"; break;
+        }
+        role_mapping_json.set("scope", scope);
+
+        role_mappings_json.add(role_mapping_json);
+    }
+    params_json.set("role_mappings", role_mappings_json);
 
     std::ostringstream oss;     // STYLE_CHECK_ALLOW_STD_STRING_STREAM
     oss.exceptions(std::ios::failbit);
@@ -251,17 +517,21 @@ bool LDAPAccessStorage::hasSubscriptionImpl(EntityType type) const
 UUID LDAPAccessStorage::loginImpl(const String & user_name, const String & password, const Poco::Net::IPAddress & address, const ExternalAuthenticators & external_authenticators) const
 {
     std::scoped_lock lock(mutex);
+    LDAPSearchResultsList external_roles;
     auto id = memory_storage.find<User>(user_name);
     if (id)
     {
         auto user = memory_storage.read<User>(*id);
 
-        if (!isPasswordCorrectImpl(*user, password, external_authenticators))
+        if (!isPasswordCorrectLDAPNoLock(user->getName(), password, external_authenticators, external_roles))
             throwInvalidPassword();
 
         if (!isAddressAllowedImpl(*user, address))
             throwAddressNotAllowed(address);
 
+        // Just in case external_roles are changed. This will be no-op if they are not.
+        updateAssignedRolesNoLock(*id, user_name, external_roles);
+
         return *id;
     }
     else
@@ -272,16 +542,13 @@ UUID LDAPAccessStorage::loginImpl(const String & user_name, const String & passw
         user->authentication = Authentication(Authentication::Type::LDAP_SERVER);
         user->authentication.setServerName(ldap_server);
 
-        if (!isPasswordCorrectImpl(*user, password, external_authenticators))
+        if (!isPasswordCorrectLDAPNoLock(user->getName(), password, external_authenticators, external_roles))
             throwInvalidPassword();
 
         if (!isAddressAllowedImpl(*user, address))
             throwAddressNotAllowed(address);
 
-        checkAllDefaultRoleNamesFoundNoLock();
-
-        auto & granted_roles = user->granted_roles.roles;
-        boost::range::copy(roles_of_interest | boost::adaptors::map_keys, std::inserter(granted_roles, granted_roles.end()));
+        assignRolesNoLock(*user, external_roles);
 
         return memory_storage.insert(user);
     }
@@ -303,18 +570,14 @@ UUID LDAPAccessStorage::getIDOfLoggedUserImpl(const String & user_name) const
         user->authentication = Authentication(Authentication::Type::LDAP_SERVER);
         user->authentication.setServerName(ldap_server);
 
-        checkAllDefaultRoleNamesFoundNoLock();
+        LDAPSearchResultsList external_roles;
+
+        // TODO: mapped external roles are not available here. Without a password we can't authenticate and retrieve roles from LDAP server.
 
-        auto & granted_roles = user->granted_roles.roles;
-        boost::range::copy(roles_of_interest | boost::adaptors::map_keys, std::inserter(granted_roles, granted_roles.end()));
+        assignRolesNoLock(*user, external_roles);
 
         return memory_storage.insert(user);
     }
 }
 
-void LDAPAccessStorage::throwDefaultRoleNotFound(const String & role_name)
-{
-    throw Exception("One of the default roles, the role '" + role_name + "', is not found", IAccessEntity::TypeInfo::get(IAccessEntity::Type::ROLE).not_found_error_code);
-}
-
 }
diff --git a/src/Access/LDAPAccessStorage.h b/src/Access/LDAPAccessStorage.h
index b1b0001d9bcc..b3d82d1e86bb 100644
--- a/src/Access/LDAPAccessStorage.h
+++ b/src/Access/LDAPAccessStorage.h
@@ -6,6 +6,7 @@
 #include <map>
 #include <mutex>
 #include <set>
+#include <vector>
 
 
 namespace Poco
@@ -20,6 +21,10 @@ namespace Poco
 namespace DB
 {
 class AccessControlManager;
+struct LDAPSearchParams;
+using LDAPSearchParamsList = std::vector<LDAPSearchParams>;
+using LDAPSearchResults = std::set<String>;
+using LDAPSearchResultsList = std::vector<LDAPSearchResults>;
 
 /// Implementation of IAccessStorage which allows attaching users from a remote LDAP server.
 /// Currently, any user name will be treated as a name of an existing remote user,
@@ -58,15 +63,25 @@ class LDAPAccessStorage : public IAccessStorage
 private:
     void setConfiguration(AccessControlManager * access_control_manager_, const Poco::Util::AbstractConfiguration & config, const String & prefix);
     void processRoleChange(const UUID & id, const AccessEntityPtr & entity);
-    void checkAllDefaultRoleNamesFoundNoLock() const;
 
-    [[noreturn]] static void throwDefaultRoleNotFound(const String & role_name);
+    void applyRoleChangeNoLock(bool grant, const UUID & role_id, const String & role_name);
+    void assignRolesNoLock(User & user, const LDAPSearchResultsList & external_roles) const;
+    void assignRolesNoLock(User & user, const LDAPSearchResultsList & external_roles, const std::size_t external_roles_hash) const;
+    void updateAssignedRolesNoLock(const UUID & id, const String & user_name, const LDAPSearchResultsList & external_roles) const;
+    std::set<String> mapExternalRolesNoLock(const LDAPSearchResultsList & external_roles) const;
+    bool isPasswordCorrectLDAPNoLock(const String & user_name, const String & password,
+        const ExternalAuthenticators & external_authenticators, LDAPSearchResultsList & search_results) const;
 
     mutable std::recursive_mutex mutex;
     AccessControlManager * access_control_manager = nullptr;
     String ldap_server;
-    std::set<String> default_role_names;
-    std::map<UUID, String> roles_of_interest;
+    LDAPSearchParamsList role_search_params;
+    std::set<String> common_role_names;                         // role name that should be granted to all users at all times
+    mutable std::map<String, std::size_t> external_role_hashes; // user name -> LDAPSearchResultsList hash (most recently retrieved and processed)
+    mutable std::map<String, std::set<String>> users_per_roles; // role name -> user names (...it should be granted to; may but don't have to exist for common roles)
+    mutable std::map<String, std::set<String>> roles_per_users; // user name -> role names (...that should be granted to it; may but don't have to include common roles)
+    mutable std::map<UUID, String> granted_role_names;          // (currently granted) role id -> its name
+    mutable std::map<String, UUID> granted_role_ids;            // (currently granted) role name -> its id
     ext::scope_guard role_change_subscription;
     mutable MemoryAccessStorage memory_storage;
 };
diff --git a/src/Access/LDAPClient.cpp b/src/Access/LDAPClient.cpp
index a32239023611..41756aebb9a5 100644
--- a/src/Access/LDAPClient.cpp
+++ b/src/Access/LDAPClient.cpp
@@ -1,8 +1,14 @@
 #include <Access/LDAPClient.h>
 #include <Common/Exception.h>
 #include <ext/scope_guard.h>
+#include <common/logger_useful.h>
+
+#include <Poco/Logger.h>
+#include <boost/algorithm/string/predicate.hpp>
 
 #include <mutex>
+#include <utility>
+#include <vector>
 
 #include <cstring>
 
@@ -63,38 +69,63 @@ namespace
         return dest;
     }
 
+    auto replacePlaceholders(const String & src, const std::vector<std::pair<String, String>> & pairs)
+    {
+        String dest = src;
+
+        for (const auto & pair : pairs)
+        {
+            const auto & placeholder = pair.first;
+            const auto & value = pair.second;
+            for (
+                 auto pos = dest.find(placeholder);
+                 pos != std::string::npos;
+                 pos = dest.find(placeholder, pos)
+            )
+            {
+                dest.replace(pos, placeholder.size(), value);
+                pos += value.size();
+            }
+        }
+
+        return dest;
+    }
+
 }
 
-void LDAPClient::diag(const int rc)
+void LDAPClient::diag(const int rc, String text)
 {
     std::scoped_lock lock(ldap_global_mutex);
 
     if (rc != LDAP_SUCCESS)
     {
-        String text;
         const char * raw_err_str = ldap_err2string(rc);
-
-        if (raw_err_str)
-            text = raw_err_str;
+        if (raw_err_str && *raw_err_str != '\0')
+        {
+            if (!text.empty())
+                text += ": ";
+            text += raw_err_str;
+        }
 
         if (handle)
         {
-            String message;
             char * raw_message = nullptr;
-            ldap_get_option(handle, LDAP_OPT_DIAGNOSTIC_MESSAGE, &raw_message);
 
-            if (raw_message)
-            {
-                message = raw_message;
-                ldap_memfree(raw_message);
-                raw_message = nullptr;
-            }
+            SCOPE_EXIT({
+                if (raw_message)
+                {
+                    ldap_memfree(raw_message);
+                    raw_message = nullptr;
+                }
+            });
+
+            ldap_get_option(handle, LDAP_OPT_DIAGNOSTIC_MESSAGE, &raw_message);
 
-            if (!message.empty())
+            if (raw_message && *raw_message != '\0')
             {
                 if (!text.empty())
                     text += ": ";
-                text += message;
+                text += raw_message;
             }
         }
 
@@ -240,20 +271,20 @@ void LDAPClient::openConnection()
     {
         case LDAPServerParams::SASLMechanism::SIMPLE:
         {
-            const String dn = params.auth_dn_prefix + escapeForLDAP(params.user) + params.auth_dn_suffix;
+            const auto escaped_user_name = escapeForLDAP(params.user);
+            const auto bind_dn = replacePlaceholders(params.bind_dn, { {"{user_name}", escaped_user_name} });
 
             ::berval cred;
             cred.bv_val = const_cast<char *>(params.password.c_str());
             cred.bv_len = params.password.size();
 
-            diag(ldap_sasl_bind_s(handle, dn.c_str(), LDAP_SASL_SIMPLE, &cred, nullptr, nullptr, nullptr));
+            diag(ldap_sasl_bind_s(handle, bind_dn.c_str(), LDAP_SASL_SIMPLE, &cred, nullptr, nullptr, nullptr));
 
             break;
         }
+
         default:
-        {
             throw Exception("Unknown SASL mechanism", ErrorCodes::LDAP_ERROR);
-        }
     }
 }
 
@@ -268,13 +299,167 @@ void LDAPClient::closeConnection() noexcept
     handle = nullptr;
 }
 
-bool LDAPSimpleAuthClient::check()
+LDAPSearchResults LDAPClient::search(const LDAPSearchParams & search_params)
 {
     std::scoped_lock lock(ldap_global_mutex);
 
+    LDAPSearchResults result;
+
+    int scope = 0;
+    switch (search_params.scope)
+    {
+        case LDAPSearchParams::Scope::BASE:      scope = LDAP_SCOPE_BASE;     break;
+        case LDAPSearchParams::Scope::ONE_LEVEL: scope = LDAP_SCOPE_ONELEVEL; break;
+        case LDAPSearchParams::Scope::SUBTREE:   scope = LDAP_SCOPE_SUBTREE;  break;
+        case LDAPSearchParams::Scope::CHILDREN:  scope = LDAP_SCOPE_CHILDREN; break;
+    }
+
+    const auto escaped_user_name = escapeForLDAP(params.user);
+    const auto bind_dn = replacePlaceholders(params.bind_dn, { {"{user_name}", escaped_user_name} });
+    const auto base_dn = replacePlaceholders(search_params.base_dn, { {"{user_name}", escaped_user_name}, {"{bind_dn}", bind_dn} });
+    const auto search_filter = replacePlaceholders(search_params.search_filter, { {"{user_name}", escaped_user_name}, {"{bind_dn}", bind_dn}, {"{base_dn}", base_dn} });
+    char * attrs[] = { const_cast<char *>(search_params.attribute.c_str()), nullptr };
+    ::timeval timeout = { params.search_timeout.count(), 0 };
+    LDAPMessage* msgs = nullptr;
+
+    SCOPE_EXIT({
+        if (msgs)
+        {
+            ldap_msgfree(msgs);
+            msgs = nullptr;
+        }
+    });
+
+    diag(ldap_search_ext_s(handle, base_dn.c_str(), scope, search_filter.c_str(), attrs, 0, nullptr, nullptr, &timeout, params.search_limit, &msgs));
+
+    for (
+         auto * msg = ldap_first_message(handle, msgs);
+         msg != nullptr;
+         msg = ldap_next_message(handle, msg)
+    )
+    {
+        switch (ldap_msgtype(msg))
+        {
+            case LDAP_RES_SEARCH_ENTRY:
+            {
+                BerElement * ber = nullptr;
+
+                SCOPE_EXIT({
+                    if (ber)
+                    {
+                        ber_free(ber, 0);
+                        ber = nullptr;
+                    }
+                });
+
+                for (
+                     auto * attr = ldap_first_attribute(handle, msg, &ber);
+                     attr != nullptr;
+                     attr = ldap_next_attribute(handle, msg, ber)
+                )
+                {
+                    SCOPE_EXIT({
+                        ldap_memfree(attr);
+                        attr = nullptr;
+                    });
+
+                    if (search_params.attribute.empty() || boost::iequals(attr, search_params.attribute))
+                    {
+                        auto ** vals = ldap_get_values_len(handle, msg, attr);
+                        if (vals)
+                        {
+                            SCOPE_EXIT({
+                                ldap_value_free_len(vals);
+                                vals = nullptr;
+                            });
+
+                            for (std::size_t i = 0; vals[i]; i++)
+                            {
+                                if (vals[i]->bv_val && vals[i]->bv_len > 0)
+                                    result.emplace(vals[i]->bv_val, vals[i]->bv_len);
+                            }
+                        }
+                    }
+                }
+
+                break;
+            }
+
+            case LDAP_RES_SEARCH_REFERENCE:
+            {
+                char ** referrals = nullptr;
+                diag(ldap_parse_reference(handle, msg, &referrals, nullptr, 0));
+
+                if (referrals)
+                {
+                    SCOPE_EXIT({
+//                      ldap_value_free(referrals);
+                        ber_memvfree(reinterpret_cast<void **>(referrals));
+                        referrals = nullptr;
+                    });
+
+                    for (std::size_t i = 0; referrals[i]; i++)
+                    {
+                        LOG_WARNING(&Poco::Logger::get("LDAPClient"), "Received reference during LDAP search but not following it: {}", referrals[i]);
+                    }
+                }
+
+                break;
+            }
+
+            case LDAP_RES_SEARCH_RESULT:
+            {
+                int rc = LDAP_SUCCESS;
+                char * matched_msg = nullptr;
+                char * error_msg = nullptr;
+
+                diag(ldap_parse_result(handle, msg, &rc, &matched_msg, &error_msg, nullptr, nullptr, 0));
+
+                if (rc != LDAP_SUCCESS)
+                {
+                    String message = "LDAP search failed";
+
+                    const char * raw_err_str = ldap_err2string(rc);
+                    if (raw_err_str && *raw_err_str != '\0')
+                    {
+                        message += ": ";
+                        message += raw_err_str;
+                    }
+
+                    if (error_msg && *error_msg != '\0')
+                    {
+                        message += ", ";
+                        message += error_msg;
+                    }
+
+                    if (matched_msg && *matched_msg != '\0')
+                    {
+                        message += ", matching DN part: ";
+                        message += matched_msg;
+                    }
+
+                    throw Exception(message, ErrorCodes::LDAP_ERROR);
+                }
+
+                break;
+            }
+
+            case -1:
+                throw Exception("Failed to process LDAP search message", ErrorCodes::LDAP_ERROR);
+        }
+    }
+
+    return result;
+}
+
+bool LDAPSimpleAuthClient::authenticate(const LDAPSearchParamsList * search_params, LDAPSearchResultsList * search_results)
+{
     if (params.user.empty())
         throw Exception("LDAP authentication of a user with empty name is not allowed", ErrorCodes::BAD_ARGUMENTS);
 
+    if (!search_params != !search_results)
+        throw Exception("Cannot return LDAP search results", ErrorCodes::BAD_ARGUMENTS);
+
     // Silently reject authentication attempt if the password is empty as if it didn't match.
     if (params.password.empty())
         return false;
@@ -284,12 +469,32 @@ bool LDAPSimpleAuthClient::check()
     // Will throw on any error, including invalid credentials.
     openConnection();
 
+    // While connected, run search queries and save the results, if asked.
+    if (search_params)
+    {
+        search_results->clear();
+        search_results->reserve(search_params->size());
+
+        try
+        {
+            for (const auto & single_search_params : *search_params)
+            {
+                search_results->emplace_back(search(single_search_params));
+            }
+        }
+        catch (...)
+        {
+            search_results->clear();
+            throw;
+        }
+    }
+
     return true;
 }
 
 #else // USE_LDAP
 
-void LDAPClient::diag(const int)
+void LDAPClient::diag(const int, String)
 {
     throw Exception("ClickHouse was built without LDAP support", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);
 }
@@ -303,7 +508,12 @@ void LDAPClient::closeConnection() noexcept
 {
 }
 
-bool LDAPSimpleAuthClient::check()
+LDAPSearchResults LDAPClient::search(const LDAPSearchParams &)
+{
+    throw Exception("ClickHouse was built without LDAP support", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);
+}
+
+bool LDAPSimpleAuthClient::authenticate(const LDAPSearchParamsList *, LDAPSearchResultsList *)
 {
     throw Exception("ClickHouse was built without LDAP support", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);
 }
diff --git a/src/Access/LDAPClient.h b/src/Access/LDAPClient.h
index 777c87c5b943..f0ace69649bf 100644
--- a/src/Access/LDAPClient.h
+++ b/src/Access/LDAPClient.h
@@ -30,9 +30,10 @@ class LDAPClient
     LDAPClient & operator= (LDAPClient &&) = delete;
 
 protected:
-    MAYBE_NORETURN void diag(const int rc);
+    MAYBE_NORETURN void diag(const int rc, String text = "");
     MAYBE_NORETURN void openConnection();
     void closeConnection() noexcept;
+    LDAPSearchResults search(const LDAPSearchParams & search_params);
 
 protected:
     const LDAPServerParams params;
@@ -46,7 +47,7 @@ class LDAPSimpleAuthClient
 {
 public:
     using LDAPClient::LDAPClient;
-    bool check();
+    bool authenticate(const LDAPSearchParamsList * search_params, LDAPSearchResultsList * search_results);
 };
 
 }
diff --git a/src/Access/LDAPParams.h b/src/Access/LDAPParams.h
index 28dcc5fe50fd..5181b2d16214 100644
--- a/src/Access/LDAPParams.h
+++ b/src/Access/LDAPParams.h
@@ -5,11 +5,43 @@
 #include <boost/container_hash/hash.hpp>
 
 #include <chrono>
+#include <set>
+#include <vector>
 
 
 namespace DB
 {
 
+struct LDAPSearchParams
+{
+    enum class Scope
+    {
+        BASE,
+        ONE_LEVEL,
+        SUBTREE,
+        CHILDREN
+    };
+
+    String base_dn;
+    Scope scope = Scope::SUBTREE;
+    String search_filter;
+    String attribute = "cn";
+    String prefix;
+
+    void combineHash(std::size_t & seed) const
+    {
+        boost::hash_combine(seed, base_dn);
+        boost::hash_combine(seed, static_cast<int>(scope));
+        boost::hash_combine(seed, search_filter);
+        boost::hash_combine(seed, attribute);
+        boost::hash_combine(seed, prefix);
+    }
+};
+
+using LDAPSearchParamsList = std::vector<LDAPSearchParams>;
+using LDAPSearchResults = std::set<String>;
+using LDAPSearchResultsList = std::vector<LDAPSearchResults>;
+
 struct LDAPServerParams
 {
     enum class ProtocolVersion
@@ -64,9 +96,7 @@ struct LDAPServerParams
 
     SASLMechanism sasl_mechanism = SASLMechanism::SIMPLE;
 
-    String auth_dn_prefix;
-    String auth_dn_suffix;
-
+    String bind_dn;
     String user;
     String password;
 
@@ -77,18 +107,13 @@ struct LDAPServerParams
     std::chrono::seconds search_timeout{20};
     std::uint32_t search_limit = 100;
 
-    std::size_t getCoreHash() const
+    void combineCoreHash(std::size_t & seed) const
     {
-        std::size_t seed = 0;
-
         boost::hash_combine(seed, host);
         boost::hash_combine(seed, port);
-        boost::hash_combine(seed, auth_dn_prefix);
-        boost::hash_combine(seed, auth_dn_suffix);
+        boost::hash_combine(seed, bind_dn);
         boost::hash_combine(seed, user);
         boost::hash_combine(seed, password);
-
-        return seed;
     }
 };
 
