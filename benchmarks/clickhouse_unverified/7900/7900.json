{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7900,
  "instance_id": "ClickHouse__ClickHouse-7900",
  "issue_numbers": [
    "7369"
  ],
  "base_commit": "e7540dcf686936a490f89d0735f74c2f5f009821",
  "patch": "diff --git a/dbms/programs/server/CMakeLists.txt b/dbms/programs/server/CMakeLists.txt\nindex 1ebf227c3da8..e36307198b40 100644\n--- a/dbms/programs/server/CMakeLists.txt\n+++ b/dbms/programs/server/CMakeLists.txt\n@@ -1,9 +1,12 @@\n set(CLICKHOUSE_SERVER_SOURCES\n     ${CMAKE_CURRENT_SOURCE_DIR}/HTTPHandler.cpp\n+    ${CMAKE_CURRENT_SOURCE_DIR}/HTTPHandlerFactory.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/InterserverIOHTTPHandler.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/MetricsTransmitter.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/NotFoundHandler.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/PingRequestHandler.cpp\n+    ${CMAKE_CURRENT_SOURCE_DIR}/PrometheusMetricsWriter.cpp\n+    ${CMAKE_CURRENT_SOURCE_DIR}/PrometheusRequestHandler.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/ReplicasStatusHandler.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/RootRequestHandler.cpp\n     ${CMAKE_CURRENT_SOURCE_DIR}/Server.cpp\ndiff --git a/dbms/programs/server/HTTPHandlerFactory.cpp b/dbms/programs/server/HTTPHandlerFactory.cpp\nnew file mode 100644\nindex 000000000000..ab8fb4f73362\n--- /dev/null\n+++ b/dbms/programs/server/HTTPHandlerFactory.cpp\n@@ -0,0 +1,43 @@\n+#include \"HTTPHandlerFactory.h\"\n+\n+\n+namespace DB\n+{\n+\n+HTTPRequestHandlerFactoryMain::HTTPRequestHandlerFactoryMain(IServer & server_, const std::string & name_)\n+    : server(server_), log(&Logger::get(name_)), name(name_)\n+{\n+}\n+\n+Poco::Net::HTTPRequestHandler * HTTPRequestHandlerFactoryMain::createRequestHandler(\n+    const Poco::Net::HTTPServerRequest & request) // override\n+{\n+    LOG_TRACE(log, \"HTTP Request for \" << name << \". \"\n+        << \"Method: \"\n+        << request.getMethod()\n+        << \", Address: \"\n+        << request.clientAddress().toString()\n+        << \", User-Agent: \"\n+        << (request.has(\"User-Agent\") ? request.get(\"User-Agent\") : \"none\")\n+        << (request.hasContentLength() ? (\", Length: \" + std::to_string(request.getContentLength())) : (\"\"))\n+        << \", Content Type: \" << request.getContentType()\n+        << \", Transfer Encoding: \" << request.getTransferEncoding());\n+\n+    for (auto & handlerFactory: child_handler_factories)\n+    {\n+        auto handler = handlerFactory->createRequestHandler(request);\n+        if (handler != nullptr)\n+            return handler;\n+    }\n+\n+    if (request.getMethod() == Poco::Net::HTTPRequest::HTTP_GET\n+        || request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD\n+        || request.getMethod() == Poco::Net::HTTPRequest::HTTP_POST)\n+    {\n+        return new NotFoundHandler;\n+    }\n+\n+    return nullptr;\n+}\n+\n+}\ndiff --git a/dbms/programs/server/HTTPHandlerFactory.h b/dbms/programs/server/HTTPHandlerFactory.h\nindex ce65f4476c0f..fcd7fb5d4a2f 100644\n--- a/dbms/programs/server/HTTPHandlerFactory.h\n+++ b/dbms/programs/server/HTTPHandlerFactory.h\n@@ -9,6 +9,7 @@\n #include \"InterserverIOHTTPHandler.h\"\n #include \"NotFoundHandler.h\"\n #include \"PingRequestHandler.h\"\n+#include \"PrometheusRequestHandler.h\"\n #include \"ReplicasStatusHandler.h\"\n #include \"RootRequestHandler.h\"\n \n@@ -16,60 +17,111 @@\n namespace DB\n {\n \n-template <typename HandlerType>\n-class HTTPRequestHandlerFactory : public Poco::Net::HTTPRequestHandlerFactory\n+/// Handle request using child handlers\n+class HTTPRequestHandlerFactoryMain : public Poco::Net::HTTPRequestHandlerFactory\n {\n private:\n+    using TThis = HTTPRequestHandlerFactoryMain;\n+\n     IServer & server;\n     Logger * log;\n     std::string name;\n \n+    std::vector<std::unique_ptr<Poco::Net::HTTPRequestHandlerFactory>> child_handler_factories;\n+\n public:\n-    HTTPRequestHandlerFactory(IServer & server_, const std::string & name_) : server(server_), log(&Logger::get(name_)), name(name_)\n+    HTTPRequestHandlerFactoryMain(IServer & server_, const std::string & name_);\n+\n+    Poco::Net::HTTPRequestHandler * createRequestHandler(const Poco::Net::HTTPServerRequest & request) override;\n+\n+    template <typename T, typename... TArgs>\n+    TThis * addHandler(TArgs &&... args)\n     {\n+        child_handler_factories.emplace_back(std::make_unique<T>(server, std::forward<TArgs>(args)...));\n+        return this;\n     }\n+};\n+\n+\n+/// Handle POST or GET with params\n+template <typename HandleType>\n+class HTTPQueryRequestHandlerFactory : public Poco::Net::HTTPRequestHandlerFactory\n+{\n+private:\n+    IServer & server;\n+\n+public:\n+    HTTPQueryRequestHandlerFactory(IServer & server_) : server(server_) {}\n \n     Poco::Net::HTTPRequestHandler * createRequestHandler(const Poco::Net::HTTPServerRequest & request) override\n     {\n-        LOG_TRACE(log, \"HTTP Request for \" << name << \". \"\n-            << \"Method: \"\n-            << request.getMethod()\n-            << \", Address: \"\n-            << request.clientAddress().toString()\n-            << \", User-Agent: \"\n-            << (request.has(\"User-Agent\") ? request.get(\"User-Agent\") : \"none\")\n-            << (request.hasContentLength() ? (\", Length: \" + std::to_string(request.getContentLength())) : (\"\"))\n-            << \", Content Type: \" << request.getContentType()\n-            << \", Transfer Encoding: \" << request.getTransferEncoding());\n-\n-        const auto & uri = request.getURI();\n-\n-        if (request.getMethod() == Poco::Net::HTTPRequest::HTTP_GET || request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD)\n-        {\n-            if (uri == \"/\")\n-                return new RootRequestHandler(server);\n-            if (uri == \"/ping\")\n-                return new PingRequestHandler(server);\n-            else if (startsWith(uri, \"/replicas_status\"))\n-                return new ReplicasStatusHandler(server.context());\n-        }\n-\n-        if (uri.find('?') != std::string::npos || request.getMethod() == Poco::Net::HTTPRequest::HTTP_POST)\n-        {\n-            return new HandlerType(server);\n-        }\n-\n-        if (request.getMethod() == Poco::Net::HTTPRequest::HTTP_GET || request.getMethod() == Poco::Net::HTTPRequest::HTTP_HEAD\n-            || request.getMethod() == Poco::Net::HTTPRequest::HTTP_POST)\n-        {\n-            return new NotFoundHandler;\n-        }\n+        if (request.getURI().find('?') != std::string::npos || request.getMethod() == Poco::Net::HTTPRequest::HTTP_POST)\n+            return new HandleType(server);\n+        return nullptr;\n+    }\n+};\n+\n+\n+/// Handle GET or HEAD endpoint on specified path\n+template <typename TGetEndpoint>\n+class HTTPGetRequestHandlerFactory : public Poco::Net::HTTPRequestHandlerFactory\n+{\n+private:\n+    IServer & server;\n+public:\n+    HTTPGetRequestHandlerFactory(IServer & server_) : server(server_) {}\n+\n+    Poco::Net::HTTPRequestHandler * createRequestHandler(const Poco::Net::HTTPServerRequest & request) override\n+    {\n+        auto & method = request.getMethod();\n+        if (!(method == Poco::Net::HTTPRequest::HTTP_GET || method == Poco::Net::HTTPRequest::HTTP_HEAD))\n+            return nullptr;\n+\n+        auto & uri = request.getURI();\n+        bool uri_match = TGetEndpoint::strict_path ? uri == TGetEndpoint::path : startsWith(uri, TGetEndpoint::path);\n+        if (uri_match)\n+            return new typename TGetEndpoint::HandleType(server);\n \n         return nullptr;\n     }\n };\n \n-using HTTPHandlerFactory = HTTPRequestHandlerFactory<HTTPHandler>;\n-using InterserverIOHTTPHandlerFactory = HTTPRequestHandlerFactory<InterserverIOHTTPHandler>;\n+\n+struct RootEndpoint\n+{\n+    static constexpr auto path = \"/\";\n+    static constexpr auto strict_path = true;\n+    using HandleType = RootRequestHandler;\n+};\n+\n+struct PingEndpoint\n+{\n+    static constexpr auto path = \"/ping\";\n+    static constexpr auto strict_path = true;\n+    using HandleType = PingRequestHandler;\n+};\n+\n+struct ReplicasStatusEndpoint\n+{\n+    static constexpr auto path = \"/replicas_status\";\n+    static constexpr auto strict_path = false;\n+    using HandleType = ReplicasStatusHandler;\n+};\n+\n+using HTTPRootRequestHandlerFactory = HTTPGetRequestHandlerFactory<RootEndpoint>;\n+using HTTPPingRequestHandlerFactory = HTTPGetRequestHandlerFactory<PingEndpoint>;\n+using HTTPReplicasStatusRequestHandlerFactory = HTTPGetRequestHandlerFactory<ReplicasStatusEndpoint>;\n+\n+template <typename HandleType>\n+HTTPRequestHandlerFactoryMain * createDefaultHandlerFatory(IServer & server, const std::string & name)\n+{\n+    auto handlerFactory = new HTTPRequestHandlerFactoryMain(server, name);\n+    handlerFactory->addHandler<HTTPRootRequestHandlerFactory>()\n+                  ->addHandler<HTTPPingRequestHandlerFactory>()\n+                  ->addHandler<HTTPReplicasStatusRequestHandlerFactory>()\n+                  ->addHandler<HTTPQueryRequestHandlerFactory<HandleType>>();\n+    return handlerFactory;\n+}\n+\n \n }\ndiff --git a/dbms/programs/server/PrometheusMetricsWriter.cpp b/dbms/programs/server/PrometheusMetricsWriter.cpp\nnew file mode 100644\nindex 000000000000..b45e66f70562\n--- /dev/null\n+++ b/dbms/programs/server/PrometheusMetricsWriter.cpp\n@@ -0,0 +1,90 @@\n+#include \"PrometheusMetricsWriter.h\"\n+\n+#include <IO/WriteHelpers.h>\n+\n+namespace\n+{\n+\n+template <typename T>\n+void writeOutLine(DB::WriteBuffer & wb, T && val)\n+{\n+    DB::writeText(std::forward<T>(val), wb);\n+    DB::writeChar('\\n', wb);\n+}\n+\n+template <typename T, typename... TArgs>\n+void writeOutLine(DB::WriteBuffer & wb, T && val, TArgs &&... args)\n+{\n+    DB::writeText(std::forward<T>(val), wb);\n+    DB::writeChar(' ', wb);\n+    writeOutLine(wb, std::forward<TArgs>(args)...);\n+}\n+\n+}\n+\n+\n+namespace DB\n+{\n+\n+PrometheusMetricsWriter::PrometheusMetricsWriter(\n+    const Poco::Util::AbstractConfiguration & config, const std::string & config_name,\n+    const AsynchronousMetrics & async_metrics_)\n+    : async_metrics(async_metrics_)\n+    , send_events(config.getBool(config_name + \".events\", true))\n+    , send_metrics(config.getBool(config_name + \".metrics\", true))\n+    , send_asynchronous_metrics(config.getBool(config_name + \".asynchronous_metrics\", true))\n+{\n+}\n+\n+void PrometheusMetricsWriter::write(WriteBuffer & wb) const\n+{\n+    if (send_events)\n+    {\n+        for (size_t i = 0, end = ProfileEvents::end(); i < end; ++i)\n+        {\n+            const auto counter = ProfileEvents::global_counters[i].load(std::memory_order_relaxed);\n+\n+            std::string metric_name{ProfileEvents::getName(static_cast<ProfileEvents::Event>(i))};\n+            std::string metric_doc{ProfileEvents::getDocumentation(static_cast<ProfileEvents::Event>(i))};\n+\n+            std::string key{profile_events_prefix + metric_name};\n+\n+            writeOutLine(wb, \"# HELP\", key, metric_doc);\n+            writeOutLine(wb, \"# TYPE\", key, \"counter\");\n+            writeOutLine(wb, key, counter);\n+        }\n+    }\n+\n+    if (send_metrics)\n+    {\n+        for (size_t i = 0, end = CurrentMetrics::end(); i < end; ++i)\n+        {\n+            const auto value = CurrentMetrics::values[i].load(std::memory_order_relaxed);\n+\n+            std::string metric_name{CurrentMetrics::getName(static_cast<CurrentMetrics::Metric>(i))};\n+            std::string metric_doc{CurrentMetrics::getDocumentation(static_cast<CurrentMetrics::Metric>(i))};\n+\n+            std::string key{current_metrics_prefix + metric_name};\n+\n+            writeOutLine(wb, \"# HELP\", key, metric_doc);\n+            writeOutLine(wb, \"# TYPE\", key, \"gauge\");\n+            writeOutLine(wb, key, value);\n+        }\n+    }\n+\n+    if (send_asynchronous_metrics)\n+    {\n+        auto async_metrics_values = async_metrics.getValues();\n+        for (const auto & name_value : async_metrics_values)\n+        {\n+            std::string key{asynchronous_metrics_prefix + name_value.first};\n+            auto value = name_value.second;\n+\n+            // TODO: add HELP section? asynchronous_metrics contains only key and value\n+            writeOutLine(wb, \"# TYPE\", key, \"gauge\");\n+            writeOutLine(wb, key, value);\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/dbms/programs/server/PrometheusMetricsWriter.h b/dbms/programs/server/PrometheusMetricsWriter.h\nnew file mode 100644\nindex 000000000000..1b253b2b954a\n--- /dev/null\n+++ b/dbms/programs/server/PrometheusMetricsWriter.h\n@@ -0,0 +1,36 @@\n+#pragma once\n+\n+#include <string>\n+\n+#include <Interpreters/AsynchronousMetrics.h>\n+\n+#include <IO/WriteBuffer.h>\n+\n+#include <Poco/Util/AbstractConfiguration.h>\n+\n+namespace DB\n+{\n+\n+/// Write metrics in Prometheus format\n+class PrometheusMetricsWriter\n+{\n+public:\n+    PrometheusMetricsWriter(\n+        const Poco::Util::AbstractConfiguration & config, const std::string & config_name,\n+        const AsynchronousMetrics & async_metrics_);\n+\n+    void write(WriteBuffer & wb) const;\n+\n+private:\n+    const AsynchronousMetrics & async_metrics;\n+\n+    const bool send_events;\n+    const bool send_metrics;\n+    const bool send_asynchronous_metrics;\n+\n+    static inline constexpr auto profile_events_prefix = \"ClickHouseProfileEvents\";\n+    static inline constexpr auto current_metrics_prefix = \"ClickHouseMetrics\";\n+    static inline constexpr auto asynchronous_metrics_prefix = \"ClickHouseAsyncMetrics\";\n+};\n+\n+}\ndiff --git a/dbms/programs/server/PrometheusRequestHandler.cpp b/dbms/programs/server/PrometheusRequestHandler.cpp\nnew file mode 100644\nindex 000000000000..b5a48d13b647\n--- /dev/null\n+++ b/dbms/programs/server/PrometheusRequestHandler.cpp\n@@ -0,0 +1,42 @@\n+#include \"PrometheusRequestHandler.h\"\n+\n+#include <IO/HTTPCommon.h>\n+\n+#include <Common/Exception.h>\n+\n+#include <Poco/Net/HTTPServerRequest.h>\n+#include <Poco/Net/HTTPServerResponse.h>\n+\n+#include <Common/ProfileEvents.h>\n+#include <Common/CurrentMetrics.h>\n+\n+#include <IO/WriteBufferFromHTTPServerResponse.h>\n+\n+\n+namespace DB\n+{\n+\n+void PrometheusRequestHandler::handleRequest(\n+    Poco::Net::HTTPServerRequest & request,\n+    Poco::Net::HTTPServerResponse & response)\n+{\n+    try\n+    {\n+        const auto & config = server.config();\n+        unsigned keep_alive_timeout = config.getUInt(\"keep_alive_timeout\", 10);\n+\n+        setResponseDefaultHeaders(response, keep_alive_timeout);\n+\n+        response.setContentType(\"text/plain; version=0.0.4; charset=UTF-8\");\n+\n+        auto wb = WriteBufferFromHTTPServerResponse(request, response, keep_alive_timeout);\n+        metrics_writer.write(wb);\n+        wb.finalize();\n+    }\n+    catch (...)\n+    {\n+        tryLogCurrentException(\"PrometheusRequestHandler\");\n+    }\n+}\n+\n+}\ndiff --git a/dbms/programs/server/PrometheusRequestHandler.h b/dbms/programs/server/PrometheusRequestHandler.h\nnew file mode 100644\nindex 000000000000..439a01c7d6f9\n--- /dev/null\n+++ b/dbms/programs/server/PrometheusRequestHandler.h\n@@ -0,0 +1,61 @@\n+#pragma once\n+\n+#include \"IServer.h\"\n+#include \"PrometheusMetricsWriter.h\"\n+\n+#include <Poco/Net/HTTPServerRequest.h>\n+#include <Poco/Net/HTTPServerResponse.h>\n+#include <Poco/Net/HTTPRequestHandler.h>\n+#include <Poco/Net/HTTPRequestHandlerFactory.h>\n+\n+namespace DB\n+{\n+\n+class PrometheusRequestHandler : public Poco::Net::HTTPRequestHandler\n+{\n+private:\n+    IServer & server;\n+    const PrometheusMetricsWriter & metrics_writer;\n+\n+public:\n+    explicit PrometheusRequestHandler(IServer & server_, PrometheusMetricsWriter & metrics_writer_)\n+        : server(server_)\n+        , metrics_writer(metrics_writer_)\n+    {\n+    }\n+\n+    void handleRequest(\n+        Poco::Net::HTTPServerRequest & request,\n+        Poco::Net::HTTPServerResponse & response) override;\n+};\n+\n+\n+template <typename HandlerType>\n+class PrometeusRequestHandlerFactory : public Poco::Net::HTTPRequestHandlerFactory\n+{\n+private:\n+    IServer & server;\n+    std::string endpoint_path;\n+    PrometheusMetricsWriter metrics_writer;\n+\n+public:\n+    PrometeusRequestHandlerFactory(IServer & server_, const AsynchronousMetrics & async_metrics_)\n+        : server(server_)\n+        , endpoint_path(server_.config().getString(\"prometheus.endpoint\", \"/metrics\"))\n+        , metrics_writer(server_.config(), \"prometheus\", async_metrics_)\n+    {\n+    }\n+\n+    Poco::Net::HTTPRequestHandler * createRequestHandler(const Poco::Net::HTTPServerRequest & request) override\n+    {\n+        if (request.getMethod() == Poco::Net::HTTPRequest::HTTP_GET\n+            && request.getURI() == endpoint_path)\n+            return new HandlerType(server, metrics_writer);\n+\n+        return nullptr;\n+    }\n+};\n+\n+using PrometeusHandlerFactory = PrometeusRequestHandlerFactory<PrometheusRequestHandler>;\n+\n+}\ndiff --git a/dbms/programs/server/ReplicasStatusHandler.cpp b/dbms/programs/server/ReplicasStatusHandler.cpp\nindex 22e059d9cccf..4d72c6da3cfa 100644\n--- a/dbms/programs/server/ReplicasStatusHandler.cpp\n+++ b/dbms/programs/server/ReplicasStatusHandler.cpp\n@@ -15,8 +15,8 @@ namespace DB\n {\n \n \n-ReplicasStatusHandler::ReplicasStatusHandler(Context & context_)\n-    : context(context_)\n+ReplicasStatusHandler::ReplicasStatusHandler(IServer & server)\n+    : context(server.context())\n {\n }\n \ndiff --git a/dbms/programs/server/ReplicasStatusHandler.h b/dbms/programs/server/ReplicasStatusHandler.h\nindex 02759bbc8ac3..479b013cfe8c 100644\n--- a/dbms/programs/server/ReplicasStatusHandler.h\n+++ b/dbms/programs/server/ReplicasStatusHandler.h\n@@ -1,5 +1,7 @@\n #pragma once\n \n+#include \"IServer.h\"\n+\n #include <Poco/Net/HTTPRequestHandler.h>\n \n \n@@ -15,7 +17,7 @@ class ReplicasStatusHandler : public Poco::Net::HTTPRequestHandler\n     Context & context;\n \n public:\n-    explicit ReplicasStatusHandler(Context & context_);\n+    explicit ReplicasStatusHandler(IServer & server);\n \n     void handleRequest(Poco::Net::HTTPServerRequest & request, Poco::Net::HTTPServerResponse & response) override;\n };\ndiff --git a/dbms/programs/server/Server.cpp b/dbms/programs/server/Server.cpp\nindex bd820e5eb0ae..f53e7b825a89 100644\n--- a/dbms/programs/server/Server.cpp\n+++ b/dbms/programs/server/Server.cpp\n@@ -668,6 +668,10 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                return address;\n         };\n \n+        /// This object will periodically calculate some metrics.\n+        AsynchronousMetrics async_metrics(*global_context);\n+        attachSystemTablesAsync(*global_context->getDatabase(\"system\"), async_metrics);\n+\n         for (const auto & listen_host : listen_hosts)\n         {\n             auto create_server = [&](const char * port_name, auto && func)\n@@ -707,8 +711,12 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 auto address = socket_bind_listen(socket, listen_host, port);\n                 socket.setReceiveTimeout(settings.http_receive_timeout);\n                 socket.setSendTimeout(settings.http_send_timeout);\n+                auto handler_factory = createDefaultHandlerFatory<HTTPHandler>(*this, \"HTTPHandler-factory\");\n+                if (config().has(\"prometheus\") && config().getInt(\"prometheus.port\", 0) == 0)\n+                    handler_factory->addHandler<PrometeusHandlerFactory>(async_metrics);\n+\n                 servers.emplace_back(std::make_unique<Poco::Net::HTTPServer>(\n-                    new HTTPHandlerFactory(*this, \"HTTPHandler-factory\"),\n+                    handler_factory,\n                     server_pool,\n                     socket,\n                     http_params));\n@@ -725,7 +733,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 socket.setReceiveTimeout(settings.http_receive_timeout);\n                 socket.setSendTimeout(settings.http_send_timeout);\n                 servers.emplace_back(std::make_unique<Poco::Net::HTTPServer>(\n-                    new HTTPHandlerFactory(*this, \"HTTPSHandler-factory\"),\n+                    createDefaultHandlerFatory<HTTPHandler>(*this, \"HTTPSHandler-factory\"),\n                     server_pool,\n                     socket,\n                     http_params));\n@@ -783,7 +791,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 socket.setReceiveTimeout(settings.http_receive_timeout);\n                 socket.setSendTimeout(settings.http_send_timeout);\n                 servers.emplace_back(std::make_unique<Poco::Net::HTTPServer>(\n-                    new InterserverIOHTTPHandlerFactory(*this, \"InterserverIOHTTPHandler-factory\"),\n+                    createDefaultHandlerFatory<InterserverIOHTTPHandler>(*this, \"InterserverIOHTTPHandler-factory\"),\n                     server_pool,\n                     socket,\n                     http_params));\n@@ -799,7 +807,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n                 socket.setReceiveTimeout(settings.http_receive_timeout);\n                 socket.setSendTimeout(settings.http_send_timeout);\n                 servers.emplace_back(std::make_unique<Poco::Net::HTTPServer>(\n-                    new InterserverIOHTTPHandlerFactory(*this, \"InterserverIOHTTPHandler-factory\"),\n+                    createDefaultHandlerFatory<InterserverIOHTTPHandler>(*this, \"InterserverIOHTTPHandler-factory\"),\n                     server_pool,\n                     socket,\n                     http_params));\n@@ -826,6 +834,24 @@ int Server::main(const std::vector<std::string> & /*args*/)\n \n                 LOG_INFO(log, \"Listening for MySQL compatibility protocol: \" + address.toString());\n             });\n+\n+            /// Prometheus (if defined and not setup yet with http_port)\n+            create_server(\"prometheus.port\", [&](UInt16 port)\n+            {\n+                Poco::Net::ServerSocket socket;\n+                auto address = socket_bind_listen(socket, listen_host, port);\n+                socket.setReceiveTimeout(settings.http_receive_timeout);\n+                socket.setSendTimeout(settings.http_send_timeout);\n+                auto handler_factory = new HTTPRequestHandlerFactoryMain(*this, \"PrometheusHandler-factory\");\n+                handler_factory->addHandler<PrometeusHandlerFactory>(async_metrics);\n+                servers.emplace_back(std::make_unique<Poco::Net::HTTPServer>(\n+                    handler_factory,\n+                    server_pool,\n+                    socket,\n+                    http_params));\n+\n+                LOG_INFO(log, \"Listening http://\" + address.toString());\n+            });\n         }\n \n         if (servers.empty())\n@@ -928,10 +954,6 @@ int Server::main(const std::vector<std::string> & /*args*/)\n             throw;\n         }\n \n-        /// This object will periodically calculate some metrics.\n-        AsynchronousMetrics async_metrics(*global_context);\n-        attachSystemTablesAsync(*global_context->getDatabase(\"system\"), async_metrics);\n-\n         std::vector<std::unique_ptr<MetricsTransmitter>> metrics_transmitters;\n         for (const auto & graphite_key : DB::getMultipleKeysFromConfig(config(), \"\", \"graphite\"))\n         {\ndiff --git a/dbms/programs/server/config.xml b/dbms/programs/server/config.xml\nindex 6e9bb527c973..d49a6a76f3c1 100644\n--- a/dbms/programs/server/config.xml\n+++ b/dbms/programs/server/config.xml\n@@ -289,6 +289,24 @@\n     </graphite>\n     -->\n \n+    <!-- Serve endpoint fot Prometheus monitoring. -->\n+    <!--\n+        endpoint - mertics path (relative to root, statring with \"/\")\n+        port - port to setup server. If not defined or 0 than http_port used\n+        metrics - send data from table system.metrics\n+        events - send data from table system.events\n+        asynchronous_metrics - send data from table system.asynchronous_metrics\n+    -->\n+    <!--\n+    <prometheus>\n+        <endpoint>/metrics</endpoint>\n+        <port>8001</port>\n+\n+        <metrics>true</metrics>\n+        <events>true</events>\n+        <asynchronous_metrics>true</asynchronous_metrics>\n+    </prometheus>\n+    -->\n \n     <!-- Query log. Used only for queries with setting log_queries = 1. -->\n     <query_log>\n",
  "test_patch": "diff --git a/dbms/tests/integration/test_prometheus_endpoint/__init__.py b/dbms/tests/integration/test_prometheus_endpoint/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/integration/test_prometheus_endpoint/configs/prom_conf.xml b/dbms/tests/integration/test_prometheus_endpoint/configs/prom_conf.xml\nnew file mode 100644\nindex 000000000000..6e31324eac2a\n--- /dev/null\n+++ b/dbms/tests/integration/test_prometheus_endpoint/configs/prom_conf.xml\n@@ -0,0 +1,13 @@\n+<yandex>\n+    <http_port>8123</http_port>\n+    <tcp_port>9000</tcp_port>\n+\n+    <prometheus>\n+        <endpoint>/metrics</endpoint>\n+        <port>8001</port>\n+\n+        <metrics>true</metrics>\n+        <events>true</events>\n+        <asynchronous_metrics>true</asynchronous_metrics>\n+    </prometheus>\n+</yandex>\ndiff --git a/dbms/tests/integration/test_prometheus_endpoint/test.py b/dbms/tests/integration/test_prometheus_endpoint/test.py\nnew file mode 100644\nindex 000000000000..10f49c230724\n--- /dev/null\n+++ b/dbms/tests/integration/test_prometheus_endpoint/test.py\n@@ -0,0 +1,67 @@\n+from __future__ import print_function\n+import pytest\n+\n+import re\n+import requests\n+\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+node = cluster.add_instance('node', main_configs=['configs/prom_conf.xml'])\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def parse_response_line(line):\n+    allowed_prefixes = [\n+        \"ClickHouse\",\n+        \"# HELP\",\n+        \"# TYPE\",\n+    ]\n+    assert any(line.startswith(prefix) for prefix in allowed_prefixes), msg\n+\n+    if line.startswith(\"#\"):\n+        return {}\n+    match = re.match('^([a-zA-Z_:][a-zA-Z0-9_:]+)(\\{.*\\})? (\\d)', line)\n+    assert match, line\n+    name, _, val = match.groups()\n+    return {name: int(val)}\n+\n+\n+def get_and_check_metrics():\n+    response = requests.get(\"http://{host}:{port}/metrics\".format(\n+        host=node.ip_address, port=8001), allow_redirects=False)\n+\n+    if response.status_code != 200:\n+        response.raise_for_status()\n+\n+    assert response.headers['content-type'].startswith('text/plain')\n+\n+    results = {}\n+    for resp_line in response.text.split('\\n'):\n+        resp_line = resp_line.rstrip()\n+        if not resp_line:\n+            continue\n+        res = parse_response_line(resp_line)\n+        results.update(res)\n+    return results\n+\n+\n+def test_prometheus_endpoint(start_cluster):\n+\n+    metrics_dict = get_and_check_metrics()\n+    assert metrics_dict['ClickHouseProfileEventsQuery'] >= 0\n+    prev_query_count = metrics_dict['ClickHouseProfileEventsQuery']\n+\n+    resp = node.query(\"SELECT 1\")\n+    resp = node.query(\"SELECT 2\")\n+    resp = node.query(\"SELECT 3\")\n+\n+    metrics_dict = get_and_check_metrics()\n+    assert metrics_dict['ClickHouseProfileEventsQuery'] >= prev_query_count + 3\n",
  "problem_statement": "Add native Prometheus metrics endpoint\nHello.\r\nI haven't found any related issue and decided to create a new feature request.\r\nI think it's a good idea to implement native Prometheus metrics endpoint. So we don't need to use external exporters, which aren't supported and often don't work or deprecated. For example https://github.com/f1yegor/clickhouse_exporter\r\n\r\n**Use case**\r\nPrometheus is now the most popular open-source monitoring solution. Many products already implemented native Prometheus metrics. Even Nginx \ud83d\ude04 \r\nI believe ClickHouse can do the same and add an optional metrics endpoint for Prometheus.\r\n\r\n**Describe the solution you'd like**\r\nA new option to enable **/metrics** endpoint with Prometheus metrics.\r\n\r\n**Describe alternatives you've considered**\r\nOnly use exporters from the community. Which aren't in-sync with ClickHouse releases. For example, today we haven't any working exporer at all for new ClickHouse versions https://github.com/f1yegor/clickhouse_exporter/issues/39\r\n\r\n* https://github.com/f1yegor/clickhouse_exporter - not maintained\r\n* https://github.com/percona-lab/clickhouse_exporter - fork, but not updated too\r\n\r\nSo I found only one fork that is working with current ClickHouse atm https://github.com/ajardan/clickhouse_exporter\r\n\r\n**Additional context**\r\nNone\r\n\n",
  "hints_text": "As I understand ClickHouse have graphite support ([GraphiteWriter](https://github.com/ClickHouse/ClickHouse/blob/09f3d68f6e3adf74bd8106c6bb9532a4b9e3c82d/libs/libdaemon/include/daemon/GraphiteWriter.h#L15), [MetricsTransmitter](https://github.com/ClickHouse/ClickHouse/blob/4952c6bc65a42be52627ae0fdd66b3fa7d400c04/dbms/programs/server/MetricsTransmitter.h#L35))\r\n\r\nPrometheus unlike Graphite uses pull strategy to get metrics. Possible solution is to use same method to retrieve metric values as `MetricsTransmitter` do, but serve results using  `HTTPHandler` like in [query server](https://github.com/ClickHouse/ClickHouse/blob/594c535bd419d153efe97bd9e93caef4b96cd692/dbms/programs/server/Server.cpp#L703)\r\n\r\nTask seems interesting for me, I can try to start implementing it. But I'm not very familiar with Prometheus or ClickHouse internals. I think it is good to see any comments from someone from ClickHouse team. \r\n\r\nUPD: Another possible solution is to use official prometheus [graphite_exporter](https://github.com/prometheus/graphite_exporter) over existing click\u0440ouse Graphite writer",
  "created_at": "2019-11-24T17:08:51Z",
  "modified_files": [
    "dbms/programs/server/CMakeLists.txt",
    "b/dbms/programs/server/HTTPHandlerFactory.cpp",
    "dbms/programs/server/HTTPHandlerFactory.h",
    "b/dbms/programs/server/PrometheusMetricsWriter.cpp",
    "b/dbms/programs/server/PrometheusMetricsWriter.h",
    "b/dbms/programs/server/PrometheusRequestHandler.cpp",
    "b/dbms/programs/server/PrometheusRequestHandler.h",
    "dbms/programs/server/ReplicasStatusHandler.cpp",
    "dbms/programs/server/ReplicasStatusHandler.h",
    "dbms/programs/server/Server.cpp",
    "dbms/programs/server/config.xml"
  ],
  "modified_test_files": [
    "b/dbms/tests/integration/test_prometheus_endpoint/configs/prom_conf.xml",
    "b/dbms/tests/integration/test_prometheus_endpoint/test.py"
  ]
}