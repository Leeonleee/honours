{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 84607,
  "instance_id": "ClickHouse__ClickHouse-84607",
  "issue_numbers": [
    "77096"
  ],
  "base_commit": "5fab80942734f3faf6dbac832c164bb06f654968",
  "patch": "diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex 13d187a9d80b..aba5a770d7a3 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -81,7 +81,7 @@ The supported formats are:\n | [JSONCompactEachRow](#jsoncompacteachrow)                                                 | \u2714   | \u2714     |\n | [JSONCompactEachRowWithNames](#jsoncompacteachrowwithnames)                               | \u2714   | \u2714     |\n | [JSONCompactEachRowWithNamesAndTypes](#jsoncompacteachrowwithnamesandtypes)               | \u2714   | \u2714     |\n-| [JSONCompactEachRowWithProgress](#jsoncompacteachrow)                                     | \u2717    | \u2714     |\n+| [JSONCompactEachRowWithProgress](#jsoncompacteachrow)                                     | \u2717   | \u2714     |\n | [JSONCompactStringsEachRow](#jsoncompactstringseachrow)                                   | \u2714   | \u2714     |\n | [JSONCompactStringsEachRowWithNames](#jsoncompactstringseachrowwithnames)                 | \u2714   | \u2714     |\n | [JSONCompactStringsEachRowWithNamesAndTypes](#jsoncompactstringseachrowwithnamesandtypes) | \u2714   | \u2714     |\n@@ -104,7 +104,7 @@ The supported formats are:\n | [Prometheus](#prometheus)                                                                 | \u2717   | \u2714     |\n | [Protobuf](#protobuf)                                                                     | \u2714   | \u2714     |\n | [ProtobufSingle](#protobufsingle)                                                         | \u2714   | \u2714     |\n-| [ProtobufList](#protobuflist)                                                                                     | \u2714   | \u2714     |\n+| [ProtobufList](#protobuflist)                                                             | \u2714   | \u2714     |\n | [Avro](#data-format-avro)                                                                 | \u2714   | \u2714     |\n | [AvroConfluent](#data-format-avro-confluent)                                              | \u2714   | \u2717     |\n | [Parquet](#data-format-parquet)                                                           | \u2714   | \u2714     |\n@@ -120,6 +120,7 @@ The supported formats are:\n | [RowBinaryWithDefaults](#rowbinarywithdefaults)                                           | \u2714   | \u2717     |\n | [Native](#native)                                                                         | \u2714   | \u2714     |\n | [Null](#null)                                                                             | \u2717   | \u2714     |\n+| [Hash](#hash)                                                                             | \u2717   | \u2714     |\n | [XML](#xml)                                                                               | \u2717   | \u2714     |\n | [CapnProto](#capnproto)                                                                   | \u2714   | \u2714     |\n | [LineAsString](#lineasstring)                                                             | \u2714   | \u2714     |\n@@ -301,6 +302,10 @@ See [Native](/interfaces/formats/Native)\n \n See [Null](/interfaces/formats/Null)\n \n+### Hash {#hash}\n+\n+See [Hash](/interfaces/formats/Hash)\n+\n ### Pretty {#pretty}\n \n See [Pretty](/interfaces/formats/Pretty)\ndiff --git a/docs/en/interfaces/formats/Hash.md b/docs/en/interfaces/formats/Hash.md\nnew file mode 100644\nindex 000000000000..32b11d0f259e\n--- /dev/null\n+++ b/docs/en/interfaces/formats/Hash.md\n@@ -0,0 +1,64 @@\n+---\n+alias: []\n+description: 'Documentation for the Hash format'\n+input_format: false\n+keywords: ['hash', 'format']\n+output_format: true\n+slug: /interfaces/formats/Hash\n+title: 'Hash'\n+---\n+\n+| Input | Output | Alias |\n+|-------|--------|-------|\n+| \u2717     | \u2714      |       |\n+\n+## Description {#description}\n+\n+The `Hash` output format calculates a single hash value for all columns and rows of the result.\n+This is useful for calculating a \"fingerprint\" of the result, for example in situations where data transfer is the bottleneck.\n+\n+## Example usage {#example-usage}\n+\n+### Reading data {#reading-data}\n+\n+Consider a table `football` with the following data:\n+\n+```text\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u252c\u2500season\u2500\u252c\u2500home_team\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500away_team\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500home_team_goals\u2500\u252c\u2500away_team_goals\u2500\u2510\n+ 1. \u2502 2022-04-30 \u2502   2021 \u2502 Sutton United         \u2502 Bradford City       \u2502               1 \u2502               4 \u2502\n+ 2. \u2502 2022-04-30 \u2502   2021 \u2502 Swindon Town          \u2502 Barrow              \u2502               2 \u2502               1 \u2502\n+ 3. \u2502 2022-04-30 \u2502   2021 \u2502 Tranmere Rovers       \u2502 Oldham Athletic     \u2502               2 \u2502               0 \u2502\n+ 4. \u2502 2022-05-02 \u2502   2021 \u2502 Port Vale             \u2502 Newport County      \u2502               1 \u2502               2 \u2502\n+ 5. \u2502 2022-05-02 \u2502   2021 \u2502 Salford City          \u2502 Mansfield Town      \u2502               2 \u2502               2 \u2502\n+ 6. \u2502 2022-05-07 \u2502   2021 \u2502 Barrow                \u2502 Northampton Town    \u2502               1 \u2502               3 \u2502\n+ 7. \u2502 2022-05-07 \u2502   2021 \u2502 Bradford City         \u2502 Carlisle United     \u2502               2 \u2502               0 \u2502\n+ 8. \u2502 2022-05-07 \u2502   2021 \u2502 Bristol Rovers        \u2502 Scunthorpe United   \u2502               7 \u2502               0 \u2502\n+ 9. \u2502 2022-05-07 \u2502   2021 \u2502 Exeter City           \u2502 Port Vale           \u2502               0 \u2502               1 \u2502\n+10. \u2502 2022-05-07 \u2502   2021 \u2502 Harrogate Town A.F.C. \u2502 Sutton United       \u2502               0 \u2502               2 \u2502\n+11. \u2502 2022-05-07 \u2502   2021 \u2502 Hartlepool United     \u2502 Colchester United   \u2502               0 \u2502               2 \u2502\n+12. \u2502 2022-05-07 \u2502   2021 \u2502 Leyton Orient         \u2502 Tranmere Rovers     \u2502               0 \u2502               1 \u2502\n+13. \u2502 2022-05-07 \u2502   2021 \u2502 Mansfield Town        \u2502 Forest Green Rovers \u2502               2 \u2502               2 \u2502\n+14. \u2502 2022-05-07 \u2502   2021 \u2502 Newport County        \u2502 Rochdale            \u2502               0 \u2502               2 \u2502\n+15. \u2502 2022-05-07 \u2502   2021 \u2502 Oldham Athletic       \u2502 Crawley Town        \u2502               3 \u2502               3 \u2502\n+16. \u2502 2022-05-07 \u2502   2021 \u2502 Stevenage Borough     \u2502 Salford City        \u2502               4 \u2502               2 \u2502\n+17. \u2502 2022-05-07 \u2502   2021 \u2502 Walsall               \u2502 Swindon Town        \u2502               0 \u2502               3 \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Read data using the `Hash` format:\n+\n+```sql\n+SELECT *\n+FROM football\n+FORMAT Hash\n+```\n+\n+The query will process the data, but will not output anything.\n+\n+```response\n+df2ec2f0669b000edff6adee264e7d68\n+\n+1 rows in set. Elapsed: 0.154 sec.\n+```\n+\n+## Format settings {#format-settings}\ndiff --git a/src/Formats/registerFormats.cpp b/src/Formats/registerFormats.cpp\nindex 768ba4a6edbb..20f4cb6523df 100644\n--- a/src/Formats/registerFormats.cpp\n+++ b/src/Formats/registerFormats.cpp\n@@ -94,6 +94,7 @@ void registerOutputFormatMarkdown(FormatFactory & factory);\n void registerOutputFormatPostgreSQLWire(FormatFactory & factory);\n void registerOutputFormatPrometheus(FormatFactory & factory);\n void registerOutputFormatSQLInsert(FormatFactory & factory);\n+void registerOutputFormatHash(FormatFactory & factory);\n \n /// Input only formats.\n \n@@ -240,6 +241,7 @@ void registerFormats()\n     registerOutputFormatCapnProto(factory);\n     registerOutputFormatPrometheus(factory);\n     registerOutputFormatSQLInsert(factory);\n+    registerOutputFormatHash(factory);\n \n     registerInputFormatRegexp(factory);\n     registerInputFormatJSONAsString(factory);\ndiff --git a/src/Processors/Formats/Impl/HashOutputFormat.cpp b/src/Processors/Formats/Impl/HashOutputFormat.cpp\nnew file mode 100644\nindex 000000000000..ae5c88051f45\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/HashOutputFormat.cpp\n@@ -0,0 +1,50 @@\n+#include <Processors/Formats/Impl/HashOutputFormat.h>\n+\n+#include <Columns/IColumn.h>\n+#include <Core/Block.h>\n+#include <Formats/FormatFactory.h>\n+#include <Formats/FormatSettings.h>\n+#include <IO/WriteBuffer.h>\n+#include <Processors/Port.h>\n+\n+\n+namespace DB\n+{\n+\n+HashOutputFormat::HashOutputFormat(WriteBuffer & out_, SharedHeader header_)\n+    : IOutputFormat(header_, out_)\n+{\n+}\n+\n+String HashOutputFormat::getName() const\n+{\n+    return \"HashOutputFormat\";\n+}\n+\n+void HashOutputFormat::consume(Chunk chunk)\n+{\n+    for (const auto & column : chunk.getColumns())\n+    {\n+        for (size_t i = 0; i < column->size(); ++i)\n+            column->updateHashWithValue(i, hash);\n+    }\n+}\n+\n+void HashOutputFormat::finalizeImpl()\n+{\n+    std::string hash_string = getSipHash128AsHexString(hash);\n+    out.write(hash_string.data(), hash_string.size());\n+    out.write(\"\\n\", 1);\n+    out.next();\n+}\n+\n+void registerOutputFormatHash(FormatFactory & factory)\n+{\n+    factory.registerOutputFormat(\"Hash\",\n+        [](WriteBuffer & buf, const Block & header, const FormatSettings &)\n+        {\n+            return std::make_shared<HashOutputFormat>(buf, std::make_shared<const Block>(header));\n+        });\n+}\n+\n+}\ndiff --git a/src/Processors/Formats/Impl/HashOutputFormat.h b/src/Processors/Formats/Impl/HashOutputFormat.h\nnew file mode 100644\nindex 000000000000..ac0e81069ca6\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/HashOutputFormat.h\n@@ -0,0 +1,27 @@\n+#pragma once\n+\n+#include <Common/SipHash.h>\n+#include <Processors/Formats/IOutputFormat.h>\n+#include <Processors/Chunk.h>\n+#include <Core/Block_fwd.h>\n+\n+namespace DB\n+{\n+\n+class WriteBuffer;\n+\n+/// Computes a single hash value from all columns and rows of the input.\n+class HashOutputFormat final  : public IOutputFormat\n+{\n+public:\n+    HashOutputFormat(WriteBuffer & out_, SharedHeader header_);\n+    String getName() const override;\n+\n+private:\n+    void consume(Chunk chunk) override;\n+    void finalizeImpl() override;\n+\n+    SipHash hash;\n+};\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03577_hash_output_format.reference b/tests/queries/0_stateless/03577_hash_output_format.reference\nnew file mode 100644\nindex 000000000000..7f2336a0083a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03577_hash_output_format.reference\n@@ -0,0 +1,3 @@\n+75b419a3aa739a211291e7cc119bd3c9\n+d3b90098d049660862d6dc53ac7505e5\n+92d47ccfb2950a8e10ac9ddf4314f1bf\ndiff --git a/tests/queries/0_stateless/03577_hash_output_format.sql b/tests/queries/0_stateless/03577_hash_output_format.sql\nnew file mode 100644\nindex 000000000000..1b21ac2ad3a9\n--- /dev/null\n+++ b/tests/queries/0_stateless/03577_hash_output_format.sql\n@@ -0,0 +1,3 @@\n+SELECT number FROM system.numbers LIMIT 1 FORMAT Hash;\n+SELECT number FROM system.numbers LIMIT 20 FORMAT Hash;\n+SELECT number AS hello, toString(number) AS world, (hello, world) AS tuple, nullIf(hello % 3, 0) AS sometimes_nulls FROM system.numbers LIMIT 20 FORMAT Hash;\n",
  "problem_statement": "Introduce output FORMAT Hash\n### Use case\n\nSometmes for testing we do not need to get result, but use it to check that result is correct\n\n\n### Describe the solution you'd like\n\nThere can be a default `Hash` algorithm used, but explicit algo can be chosen either via special setting or via explicit `HashCRC32` etc.\n\nResult should be the same as \n``` sql\nSELECT Hash(*) FROM ( SELECT ...).\n```\n",
  "hints_text": "I would like to work on this. And please give some implementation suggestions and the file changes involved @qoega \nHey @qoega can you give some recommendations for locations of code change? I want to attempt this. Thanks!\nOk. Use HashingWriteBuffer with Native.\n1. Is this new output format supposed to write a single hash for an input containing many rows? Or do we want this new output format to calculate a separate hash for each input row (as `SELECT cityHash64(*) FROM ( SELECT ...)` does)?\n\n2. It seems it's better to add a setting specifying the hashing algorithm which this new output format uses. For example,\n```\nSET output_format_hash_function = 'sipHash64';\nSELECT * FROM table FORMAT Hash;\n```\n\n1. Single hash as the output. The hash is printed in hex, and then a newline.\n2. It's ok to name it \"Hash\" and everything else (if we ever need this) to make it tunable with settings.\n\nThe proposal didn't specify how to normalize the order of records. Let's not normalize it. So the hash depends on the order.\nWe can think about ordered mode as well that can be enabled explicitly. Adding row number as a column or something as trivial\n> The proposal didn't specify how to normalize the order of records. Let's not normalize it. So the hash depends on the order.\n\nWe could make the hash independent on the order of rows by calculating each row's hash separately and then summing up all of them.\n\nThough I agree it's better for the hash by default to be dependent on the order of rows.\nLet's use the `sipHash128` algorithm by default for the `Hash` format?\nBecause this algorithm is already implemented for every column type.\nYes.",
  "created_at": "2025-07-28T15:08:21Z",
  "modified_files": [
    "docs/en/interfaces/formats.md",
    "b/docs/en/interfaces/formats/Hash.md",
    "src/Formats/registerFormats.cpp",
    "b/src/Processors/Formats/Impl/HashOutputFormat.cpp",
    "b/src/Processors/Formats/Impl/HashOutputFormat.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03577_hash_output_format.reference",
    "b/tests/queries/0_stateless/03577_hash_output_format.sql"
  ]
}