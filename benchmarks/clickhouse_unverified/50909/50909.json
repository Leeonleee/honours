{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50909,
  "instance_id": "ClickHouse__ClickHouse-50909",
  "issue_numbers": [
    "48582"
  ],
  "base_commit": "c6fecfb1af0bb3e66ad702537f8f5bfeb72d226e",
  "patch": "diff --git a/docs/en/operations/system-tables/numbers.md b/docs/en/operations/system-tables/numbers.md\nindex 68efeb2ee386..002bf8a75df2 100644\n--- a/docs/en/operations/system-tables/numbers.md\n+++ b/docs/en/operations/system-tables/numbers.md\n@@ -31,3 +31,26 @@ SELECT * FROM system.numbers LIMIT 10;\n \n 10 rows in set. Elapsed: 0.001 sec.\n ```\n+\n+You can also limit the output by predicates.\n+\n+```sql\n+SELECT * FROM system.numbers < 10;\n+```\n+\n+```response\n+\u250c\u2500number\u2500\u2510\n+\u2502      0 \u2502\n+\u2502      1 \u2502\n+\u2502      2 \u2502\n+\u2502      3 \u2502\n+\u2502      4 \u2502\n+\u2502      5 \u2502\n+\u2502      6 \u2502\n+\u2502      7 \u2502\n+\u2502      8 \u2502\n+\u2502      9 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+10 rows in set. Elapsed: 0.001 sec.\n+```\ndiff --git a/docs/en/sql-reference/statements/explain.md b/docs/en/sql-reference/statements/explain.md\nindex 9afc7099108d..e7c2000301a1 100644\n--- a/docs/en/sql-reference/statements/explain.md\n+++ b/docs/en/sql-reference/statements/explain.md\n@@ -415,7 +415,7 @@ ExpressionTransform\n         ExpressionTransform \u00d7 2\n           (SettingQuotaAndLimits)\n             (ReadFromStorage)\n-            NumbersMt \u00d7 2 0 \u2192 1\n+            NumbersRange \u00d7 2 0 \u2192 1\n ```\n ### EXPLAIN ESTIMATE\n \ndiff --git a/docs/en/sql-reference/table-functions/numbers.md b/docs/en/sql-reference/table-functions/numbers.md\nindex 32f51363a0a2..7d3437b7d53f 100644\n--- a/docs/en/sql-reference/table-functions/numbers.md\n+++ b/docs/en/sql-reference/table-functions/numbers.md\n@@ -17,6 +17,8 @@ The following queries are equivalent:\n SELECT * FROM numbers(10);\n SELECT * FROM numbers(0, 10);\n SELECT * FROM system.numbers LIMIT 10;\n+SELECT * FROM system.numbers WHERE number BETWEEN 0 AND 9;\n+SELECT * FROM system.numbers WHERE number IN (0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n ```\n \n Examples:\ndiff --git a/docs/ru/sql-reference/statements/explain.md b/docs/ru/sql-reference/statements/explain.md\nindex 4e0a13f7eaec..4d1d4ad4de55 100644\n--- a/docs/ru/sql-reference/statements/explain.md\n+++ b/docs/ru/sql-reference/statements/explain.md\n@@ -371,7 +371,7 @@ ExpressionTransform\n         ExpressionTransform \u00d7 2\n           (SettingQuotaAndLimits)\n             (ReadFromStorage)\n-            NumbersMt \u00d7 2 0 \u2192 1\n+            NumbersRange \u00d7 2 0 \u2192 1\n ```\n \n ### EXPLAIN ESTIMATE {#explain-estimate}\ndiff --git a/src/Core/PlainRanges.cpp b/src/Core/PlainRanges.cpp\nnew file mode 100644\nindex 000000000000..298c801d2e6f\n--- /dev/null\n+++ b/src/Core/PlainRanges.cpp\n@@ -0,0 +1,157 @@\n+#include <Core/PlainRanges.h>\n+\n+namespace DB\n+{\n+\n+PlainRanges::PlainRanges(const Range & range)\n+{\n+    ranges.push_back(range);\n+}\n+\n+\n+PlainRanges::PlainRanges(const Ranges & ranges_, bool may_have_intersection, bool ordered)\n+{\n+    if (may_have_intersection)\n+        ranges = ordered ? makePlainFromOrdered(ranges_) : makePlainFromUnordered(ranges_);\n+    else\n+        ranges = ranges_;\n+}\n+\n+Ranges PlainRanges::makePlainFromOrdered(const Ranges & ranges_)\n+{\n+    if (ranges_.size() <= 1)\n+        return ranges_;\n+\n+    Ranges ret{ranges_.front()};\n+\n+    for (size_t i = 1; i < ranges_.size(); ++i)\n+    {\n+        const auto & cur = ranges_[i];\n+        if (ret.back().intersectsRange(cur))\n+            ret.back() = *ret.back().unionWith(cur);\n+        else\n+            ret.push_back(cur);\n+    }\n+\n+    return ret;\n+}\n+\n+Ranges PlainRanges::makePlainFromUnordered(Ranges ranges_)\n+{\n+    if (ranges_.size() <= 1)\n+        return ranges_;\n+\n+    std::sort(ranges_.begin(), ranges_.end(), compareByLeftBound);\n+    return makePlainFromOrdered(ranges_);\n+}\n+\n+PlainRanges PlainRanges::unionWith(const PlainRanges & other)\n+{\n+    auto left_itr = ranges.begin();\n+    auto right_itr = other.ranges.begin();\n+\n+    Ranges new_range;\n+    for (; left_itr != ranges.end() && right_itr != other.ranges.end();)\n+    {\n+        if (left_itr->leftThan(*right_itr))\n+        {\n+            new_range.push_back(*left_itr);\n+            left_itr++;\n+        }\n+        else if (left_itr->rightThan(*right_itr))\n+        {\n+            new_range.push_back(*right_itr);\n+            right_itr++;\n+        }\n+        else /// union\n+        {\n+            new_range.emplace_back(*(left_itr->unionWith(*right_itr)));\n+            if (compareByRightBound(*left_itr, *right_itr))\n+                left_itr++;\n+            else\n+                right_itr++;\n+        }\n+    }\n+\n+    while (left_itr != ranges.end())\n+    {\n+        new_range.push_back(*left_itr);\n+        left_itr++;\n+    }\n+\n+    while (right_itr != other.ranges.end())\n+    {\n+        new_range.push_back(*right_itr);\n+        right_itr++;\n+    }\n+\n+    /// After union two PlainRanges, new ranges may like: [1, 4], [2, 5]\n+    /// We must make them plain.\n+\n+    return PlainRanges(makePlainFromOrdered(new_range));\n+}\n+\n+PlainRanges PlainRanges::intersectWith(const PlainRanges & other)\n+{\n+    auto left_itr = ranges.begin();\n+    auto right_itr = other.ranges.begin();\n+\n+    Ranges new_ranges;\n+    for (; left_itr != ranges.end() && right_itr != other.ranges.end();)\n+    {\n+        if (left_itr->leftThan(*right_itr))\n+        {\n+            left_itr++;\n+        }\n+        else if (left_itr->rightThan(*right_itr))\n+        {\n+            right_itr++;\n+        }\n+        else /// intersection\n+        {\n+            auto intersected = left_itr->intersectWith(*right_itr);\n+\n+            if (intersected) /// skip blank range\n+                new_ranges.emplace_back(*intersected);\n+\n+            if (compareByRightBound(*left_itr, *right_itr))\n+                left_itr++;\n+            else\n+                right_itr++;\n+        }\n+    }\n+    return PlainRanges(new_ranges);\n+}\n+\n+bool PlainRanges::compareByLeftBound(const Range & lhs, const Range & rhs)\n+{\n+    if (lhs.left == NEGATIVE_INFINITY && rhs.left == NEGATIVE_INFINITY)\n+        return false;\n+    return Range::less(lhs.left, rhs.left) || ((!lhs.left_included && rhs.left_included) && Range::equals(lhs.left, rhs.left));\n+};\n+\n+bool PlainRanges::compareByRightBound(const Range & lhs, const Range & rhs)\n+{\n+    if (lhs.right == POSITIVE_INFINITY && rhs.right == POSITIVE_INFINITY)\n+        return false;\n+    return Range::less(lhs.right, rhs.right) || ((!lhs.right_included && rhs.right_included) && Range::equals(lhs.right, rhs.right));\n+};\n+\n+\n+std::vector<Ranges> PlainRanges::invert(const Ranges & to_invert_ranges)\n+{\n+    /// invert a blank ranges\n+    if (to_invert_ranges.empty())\n+        return {makeUniverse().ranges};\n+\n+    std::vector<Ranges> reverted_ranges;\n+    for (const auto & range : to_invert_ranges)\n+    {\n+        if (range.isInfinite())\n+            /// return a blank ranges\n+            return {{}};\n+        reverted_ranges.push_back(range.invertRange());\n+    }\n+    return reverted_ranges;\n+};\n+}\ndiff --git a/src/Core/PlainRanges.h b/src/Core/PlainRanges.h\nnew file mode 100644\nindex 000000000000..0d8a7d093a7c\n--- /dev/null\n+++ b/src/Core/PlainRanges.h\n@@ -0,0 +1,46 @@\n+#pragma once\n+\n+#include <Core/Range.h>\n+\n+namespace DB\n+{\n+\n+/** A plain ranges is a series of ranges who\n+ *      1. have no intersection in any two of the ranges\n+ *      2. ordered by left side\n+ *      3. does not contain blank range\n+ *\n+ * Example:\n+ *      query: (k > 1 and key < 5) or (k > 3 and k < 10) or key in (2, 12)\n+ *      original ranges: (1, 5), (3, 10), [2, 2], [12, 12]\n+ *      plain ranges: (1, 10), [12, 12]\n+ *\n+ * If it is blank, ranges is empty.\n+ */\n+struct PlainRanges\n+{\n+    Ranges ranges;\n+\n+    explicit PlainRanges(const Range & range);\n+\n+    explicit PlainRanges(const Ranges & ranges_, bool may_have_intersection = false, bool ordered = true);\n+\n+    PlainRanges unionWith(const PlainRanges & other);\n+    PlainRanges intersectWith(const PlainRanges & other);\n+\n+    /// Union ranges and return a new plain(ordered and no intersection) ranges.\n+    /// Example:\n+    ///         [1, 3], [2, 4], [6, 8] -> [1, 4], [6, 8]\n+    ///         [1, 3], [2, 4], (4, 5] -> [1, 4], [5, 5]\n+    static Ranges makePlainFromUnordered(Ranges ranges_);\n+    static Ranges makePlainFromOrdered(const Ranges & ranges_);\n+\n+    static bool compareByLeftBound(const Range & lhs, const Range & rhs);\n+    static bool compareByRightBound(const Range & lhs, const Range & rhs);\n+\n+    static std::vector<Ranges> invert(const Ranges & to_invert_ranges);\n+\n+    static PlainRanges makeBlank() { return PlainRanges({}); }\n+    static PlainRanges makeUniverse() { return PlainRanges({Range::createWholeUniverseWithoutNull()}); }\n+};\n+}\ndiff --git a/src/Core/Range.cpp b/src/Core/Range.cpp\nindex 441c6b5cafe7..956b96653a16 100644\n--- a/src/Core/Range.cpp\n+++ b/src/Core/Range.cpp\n@@ -123,6 +123,27 @@ bool Range::leftThan(const FieldRef & x) const\n     return less(x, right) || (right_included && equals(x, right));\n }\n \n+bool Range::rightThan(const Range & x) const\n+{\n+    return less(x.right, left) || (!(left_included && x.right_included) && equals(left, x.right));\n+}\n+\n+bool Range::leftThan(const Range & x) const\n+{\n+    return less(right, x.left) || (!(x.left_included && right_included) && equals(right, x.left));\n+}\n+\n+bool Range::fullBounded() const\n+{\n+    return left.getType() != Field::Types::Null && right.getType() != Field::Types::Null;\n+}\n+\n+/// (-inf, +inf)\n+bool Range::isInfinite() const\n+{\n+    return left.isNegativeInfinity() && right.isPositiveInfinity();\n+}\n+\n bool Range::intersectsRange(const Range & r) const\n {\n     /// r to the left of me.\n@@ -159,6 +180,95 @@ void Range::invert()\n     std::swap(left_included, right_included);\n }\n \n+Ranges Range::invertRange() const\n+{\n+    Ranges ranges;\n+    /// For full bounded range will generate two ranges.\n+    if (fullBounded()) /// case: [1, 3] -> (-inf, 1), (3, +inf)\n+    {\n+        ranges.push_back({NEGATIVE_INFINITY, false, left, !left_included});\n+        ranges.push_back({right, !right_included, POSITIVE_INFINITY, false});\n+    }\n+    else if (isInfinite())\n+    {\n+        /// blank ranges\n+    }\n+    else /// case: (-inf, 1] or [1, +inf)\n+    {\n+        Range r = *this;\n+        std::swap(r.left, r.right);\n+        if (r.left.isPositiveInfinity()) /// [1, +inf)\n+        {\n+            r.left = NEGATIVE_INFINITY;\n+            r.right_included = !r.left_included;\n+            r.left_included = false;\n+        }\n+        else if (r.right.isNegativeInfinity()) /// (-inf, 1]\n+        {\n+            r.right = POSITIVE_INFINITY;\n+            r.left_included = !r.right_included;\n+            r.right_included = false;\n+        }\n+        ranges.push_back(r);\n+    }\n+    return ranges;\n+}\n+\n+std::optional<Range> Range::intersectWith(const Range & r) const\n+{\n+    if (!intersectsRange(r))\n+        return {};\n+\n+    bool left_bound_use_mine = true;\n+    bool right_bound_use_mine = true;\n+\n+    if (less(left, r.left) || ((!left_included && r.left_included) && equals(left, r.left)))\n+        left_bound_use_mine = false;\n+\n+    if (less(r.right, right) || ((!r.right_included && right_included) && equals(r.right, right)))\n+        right_bound_use_mine = false;\n+\n+    return Range(\n+        left_bound_use_mine ? left : r.left,\n+        left_bound_use_mine ? left_included : r.left_included,\n+        right_bound_use_mine ? right : r.right,\n+        right_bound_use_mine ? right_included : r.right_included);\n+}\n+\n+std::optional<Range> Range::unionWith(const Range & r) const\n+{\n+    if (!intersectsRange(r) && !nearByWith(r))\n+        return {};\n+\n+    bool left_bound_use_mine = false;\n+    bool right_bound_use_mine = false;\n+\n+    if (less(left, r.left) || ((!left_included && r.left_included) && equals(left, r.left)))\n+        left_bound_use_mine = true;\n+\n+    if (less(r.right, right) || ((!r.right_included && right_included) && equals(r.right, right)))\n+        right_bound_use_mine = true;\n+\n+    return Range(\n+        left_bound_use_mine ? left : r.left,\n+        left_bound_use_mine ? left_included : r.left_included,\n+        right_bound_use_mine ? right : r.right,\n+        right_bound_use_mine ? right_included : r.right_included);\n+}\n+\n+bool Range::nearByWith(const Range & r) const\n+{\n+    /// me locates at left\n+    if (((right_included && !r.left_included) || (!right_included && r.left_included)) && equals(right, r.left))\n+        return true;\n+\n+    /// r locate left\n+    if (((r.right_included && !left_included) || (r.right_included && !left_included)) && equals(r.right, left))\n+        return true;\n+\n+    return false;\n+}\n+\n Range intersect(const Range & a, const Range & b)\n {\n     Range res = Range::createWholeUniverse();\ndiff --git a/src/Core/Range.h b/src/Core/Range.h\nindex 63bb895e6b78..fed594ce2f2c 100644\n--- a/src/Core/Range.h\n+++ b/src/Core/Range.h\n@@ -38,6 +38,13 @@ struct FieldRef : public Field\n     size_t column_idx = 0;\n };\n \n+/** Range with open or closed ends; possibly unbounded.\n+ */\n+struct Range;\n+/** A serious of range who can overlap or non-overlap.\n+ */\n+using Ranges = std::vector<Range>;\n+\n /** Range with open or closed ends; possibly unbounded.\n   */\n struct Range\n@@ -79,12 +86,37 @@ struct Range\n     /// x is to the right\n     bool leftThan(const FieldRef & x) const;\n \n+    /// completely right than x\n+    bool rightThan(const Range & x) const;\n+    /// completely left than x\n+    bool leftThan(const Range & x) const;\n+\n+    /// range like [1, 2]\n+    bool fullBounded() const;\n+    /// (-inf, +inf)\n+    bool isInfinite() const;\n+\n+    bool isBlank() const;\n+\n     bool intersectsRange(const Range & r) const;\n \n     bool containsRange(const Range & r) const;\n \n+    /// Invert left and right\n     void invert();\n \n+    /// Invert the range.\n+    /// Example:\n+    ///     [1, 3] -> (-inf, 1), (3, +inf)\n+    Ranges invertRange() const;\n+\n+    std::optional<Range> intersectWith(const Range & r) const;\n+    std::optional<Range> unionWith(const Range & r) const;\n+\n+    /// If near by r, they can be combined to a continuous range.\n+    /// TODO If field is integer, case like [2, 3], [4, 5] is excluded.\n+    bool nearByWith(const Range & r) const;\n+\n     String toString() const;\n };\n \ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 400fdf2871c6..4f4e96a9be74 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -105,7 +105,6 @@ namespace DB\n {\n \n static UInt64 getLimitUIntValue(const ASTPtr & node, const ContextPtr & context, const std::string & expr);\n-static std::pair<UInt64, UInt64> getLimitLengthAndOffset(const ASTSelectQuery & query, const ContextPtr & context);\n \n namespace ErrorCodes\n {\n@@ -1314,19 +1313,19 @@ static UInt64 getLimitUIntValue(const ASTPtr & node, const ContextPtr & context,\n }\n \n \n-static std::pair<UInt64, UInt64> getLimitLengthAndOffset(const ASTSelectQuery & query, const ContextPtr & context)\n+std::pair<UInt64, UInt64> InterpreterSelectQuery::getLimitLengthAndOffset(const ASTSelectQuery & query, const ContextPtr & context_)\n {\n     UInt64 length = 0;\n     UInt64 offset = 0;\n \n     if (query.limitLength())\n     {\n-        length = getLimitUIntValue(query.limitLength(), context, \"LIMIT\");\n+        length = getLimitUIntValue(query.limitLength(), context_, \"LIMIT\");\n         if (query.limitOffset() && length)\n-            offset = getLimitUIntValue(query.limitOffset(), context, \"OFFSET\");\n+            offset = getLimitUIntValue(query.limitOffset(), context_, \"OFFSET\");\n     }\n     else if (query.limitOffset())\n-        offset = getLimitUIntValue(query.limitOffset(), context, \"OFFSET\");\n+        offset = getLimitUIntValue(query.limitOffset(), context_, \"OFFSET\");\n     return {length, offset};\n }\n \ndiff --git a/src/Interpreters/InterpreterSelectQuery.h b/src/Interpreters/InterpreterSelectQuery.h\nindex 7c2555deaa77..ec9612ad248b 100644\n--- a/src/Interpreters/InterpreterSelectQuery.h\n+++ b/src/Interpreters/InterpreterSelectQuery.h\n@@ -134,9 +134,13 @@ class InterpreterSelectQuery : public IInterpreterUnionOrSelectQuery\n \n     static bool isQueryWithFinal(const SelectQueryInfo & info);\n \n+\n+    static std::pair<UInt64, UInt64> getLimitLengthAndOffset(const ASTSelectQuery & query, const ContextPtr & context);\n+\n     /// Adjust the parallel replicas settings (enabled, disabled) based on the query analysis\n     bool adjustParallelReplicasAfterAnalysis();\n \n+\n private:\n     InterpreterSelectQuery(\n         const ASTPtr & query_ptr_,\ndiff --git a/src/Interpreters/Set.h b/src/Interpreters/Set.h\nindex fa134174d644..7136b090c42f 100644\n--- a/src/Interpreters/Set.h\n+++ b/src/Interpreters/Set.h\n@@ -232,12 +232,12 @@ class MergeTreeSetIndex\n \n     size_t size() const { return ordered_set.at(0)->size(); }\n \n-    const Columns & getOrderedSet() const { return ordered_set; }\n-\n     bool hasMonotonicFunctionsChain() const;\n \n     BoolMask checkInRange(const std::vector<Range> & key_ranges, const DataTypes & data_types, bool single_point = false) const;\n \n+    const Columns & getOrderedSet() const { return ordered_set; }\n+\n private:\n     // If all arguments in tuple are key columns, we can optimize NOT IN when there is only one element.\n     bool has_all_keys;\ndiff --git a/src/Planner/CollectSets.cpp b/src/Planner/CollectSets.cpp\nindex beddfd38e361..e150b8a5956b 100644\n--- a/src/Planner/CollectSets.cpp\n+++ b/src/Planner/CollectSets.cpp\n@@ -67,7 +67,6 @@ class CollectSetsVisitor : public ConstInDepthQueryTreeVisitor<CollectSetsVisito\n                 constant_node->getValue(),\n                 constant_node->getResultType(),\n                 settings.transform_null_in);\n-\n             DataTypes set_element_types = {in_first_argument->getResultType()};\n             const auto * left_tuple_type = typeid_cast<const DataTypeTuple *>(set_element_types.front().get());\n             if (left_tuple_type && left_tuple_type->getElements().size() != 1)\n@@ -90,32 +89,25 @@ class CollectSetsVisitor : public ConstInDepthQueryTreeVisitor<CollectSetsVisito\n                 return;\n \n             auto subquery_to_execute = in_second_argument;\n-\n             if (auto * table_node = in_second_argument->as<TableNode>())\n             {\n                 auto storage_snapshot = table_node->getStorageSnapshot();\n                 auto columns_to_select = storage_snapshot->getColumns(GetColumnsOptions(GetColumnsOptions::Ordinary));\n-\n                 size_t columns_to_select_size = columns_to_select.size();\n-\n                 auto column_nodes_to_select = std::make_shared<ListNode>();\n                 column_nodes_to_select->getNodes().reserve(columns_to_select_size);\n-\n                 NamesAndTypes projection_columns;\n                 projection_columns.reserve(columns_to_select_size);\n-\n                 for (auto & column : columns_to_select)\n                 {\n                     column_nodes_to_select->getNodes().emplace_back(std::make_shared<ColumnNode>(column, subquery_to_execute));\n                     projection_columns.emplace_back(column.name, column.type);\n                 }\n-\n                 auto subquery_for_table = std::make_shared<QueryNode>(Context::createCopy(planner_context.getQueryContext()));\n                 subquery_for_table->setIsSubquery(true);\n                 subquery_for_table->getProjectionNode() = std::move(column_nodes_to_select);\n                 subquery_for_table->getJoinTree() = std::move(subquery_to_execute);\n                 subquery_for_table->resolveProjectionColumns(std::move(projection_columns));\n-\n                 subquery_to_execute = std::move(subquery_for_table);\n             }\n \ndiff --git a/src/Planner/PlannerContext.h b/src/Planner/PlannerContext.h\nindex 44b24d09c5d2..d7ea4fd95dd1 100644\n--- a/src/Planner/PlannerContext.h\n+++ b/src/Planner/PlannerContext.h\n@@ -135,7 +135,6 @@ class PlannerContext\n     static SetKey createSetKey(const DataTypePtr & left_operand_type, const QueryTreeNodePtr & set_source_node);\n \n     PreparedSets & getPreparedSets() { return prepared_sets; }\n-\n private:\n     /// Query context\n     ContextMutablePtr query_context;\ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\nnew file mode 100644\nindex 000000000000..41690c1b1327\n--- /dev/null\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n@@ -0,0 +1,529 @@\n+#include <Processors/QueryPlan/ReadFromSystemNumbersStep.h>\n+\n+#include <Core/ColumnWithTypeAndName.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Processors/LimitTransform.h>\n+#include <Processors/Sources/NullSource.h>\n+#include <QueryPipeline/QueryPipelineBuilder.h>\n+#include <Storages/MergeTree/KeyCondition.h>\n+#include <Storages/System/StorageSystemNumbers.h>\n+#include <Common/typeid_cast.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int TOO_MANY_ROWS;\n+}\n+\n+namespace\n+{\n+\n+class NumbersSource : public ISource\n+{\n+public:\n+    NumbersSource(UInt64 block_size_, UInt64 offset_, UInt64 step_)\n+        : ISource(createHeader()), block_size(block_size_), next(offset_), step(step_)\n+    {\n+    }\n+\n+    String getName() const override { return \"Numbers\"; }\n+\n+    static Block createHeader() { return {ColumnWithTypeAndName(ColumnUInt64::create(), std::make_shared<DataTypeUInt64>(), \"number\")}; }\n+\n+protected:\n+    Chunk generate() override\n+    {\n+        auto column = ColumnUInt64::create(block_size);\n+        ColumnUInt64::Container & vec = column->getData();\n+\n+        size_t curr = next; /// The local variable for some reason works faster (>20%) than member of class.\n+        UInt64 * pos = vec.data(); /// This also accelerates the code.\n+        UInt64 * end = &vec[block_size];\n+        while (pos < end)\n+            *pos++ = curr++;\n+\n+        next += step;\n+\n+        progress(column->size(), column->byteSize());\n+\n+        return {Columns{std::move(column)}, block_size};\n+    }\n+\n+private:\n+    UInt64 block_size;\n+    UInt64 next;\n+    UInt64 step;\n+};\n+\n+\n+UInt128 sizeOfRange(const Range & r)\n+{\n+    UInt128 size;\n+    if (r.right.isPositiveInfinity())\n+        return static_cast<UInt128>(std::numeric_limits<uint64_t>::max()) - r.left.get<UInt64>() + r.left_included;\n+\n+    size = static_cast<UInt128>(r.right.get<UInt64>()) - r.left.get<UInt64>() + 1;\n+\n+    if (!r.left_included)\n+        size--;\n+\n+    if (!r.right_included)\n+        size--;\n+    assert(size >= 0);\n+    return size;\n+};\n+\n+auto sizeOfRanges(const Ranges & rs)\n+{\n+    UInt128 total_size{};\n+    for (const Range & r : rs)\n+    {\n+        /// total_size will never overflow\n+        total_size += sizeOfRange(r);\n+    }\n+    return total_size;\n+};\n+\n+/// Generate numbers according to ranges.\n+/// Numbers generated is ordered in one stream.\n+/// Notice that we will not generate additional numbers out of ranges.\n+class NumbersRangedSource : public ISource\n+{\n+public:\n+    /// Represent a position in Ranges list.\n+    struct RangesPos\n+    {\n+        size_t offset_in_ranges;\n+        UInt128 offset_in_range;\n+    };\n+\n+    struct RangesState\n+    {\n+        RangesPos pos;\n+        mutable std::mutex mutex;\n+    };\n+\n+    using RangesStatePtr = std::shared_ptr<RangesState>;\n+\n+    NumbersRangedSource(const Ranges & ranges_, RangesStatePtr & ranges_state_, UInt64 base_block_size_)\n+        : ISource(NumbersSource::createHeader()), ranges(ranges_), ranges_state(ranges_state_), base_block_size(base_block_size_)\n+    {\n+    }\n+\n+    String getName() const override { return \"NumbersRange\"; }\n+\n+protected:\n+    /// Find the data range in ranges and return how many item found.\n+    /// If no data left in ranges return 0.\n+    UInt64 findRanges(RangesPos & start, RangesPos & end, UInt64 base_block_size_)\n+    {\n+        std::lock_guard lock(ranges_state->mutex);\n+\n+        UInt64 need = base_block_size_;\n+        UInt64 size = 0; /// how many item found.\n+\n+        /// find start\n+        start = ranges_state->pos;\n+        end = start;\n+\n+        /// find end\n+        while (need != 0)\n+        {\n+            UInt128 can_provide = end.offset_in_ranges == ranges.size() ? static_cast<UInt128>(0)\n+                                                                        : sizeOfRange(ranges[end.offset_in_ranges]) - end.offset_in_range;\n+            if (can_provide == 0)\n+                break;\n+\n+            if (can_provide > need)\n+            {\n+                end.offset_in_range += need;\n+                size += need;\n+                need = 0;\n+            }\n+            else if (can_provide == need)\n+            {\n+                end.offset_in_ranges++;\n+                end.offset_in_range = 0;\n+                size += need;\n+                need = 0;\n+            }\n+            else\n+            {\n+                end.offset_in_ranges++;\n+                end.offset_in_range = 0;\n+                size += static_cast<UInt64>(can_provide);\n+                need -= static_cast<UInt64>(can_provide);\n+            }\n+        }\n+\n+        ranges_state->pos = end;\n+        return size;\n+    }\n+\n+    Chunk generate() override\n+    {\n+        if (ranges.empty())\n+            return {};\n+\n+        auto first_value = [](const Range & r) { return r.left.get<UInt64>() + (r.left_included ? 0 : 1); };\n+\n+        auto last_value = [](const Range & r) { return r.right.get<UInt64>() - (r.right_included ? 0 : 1); };\n+\n+        /// Find the data range.\n+        /// If data left is small, shrink block size.\n+        RangesPos start, end;\n+        auto block_size = findRanges(start, end, base_block_size);\n+\n+        if (!block_size)\n+            return {};\n+\n+        auto column = ColumnUInt64::create(block_size);\n+        ColumnUInt64::Container & vec = column->getData();\n+\n+        /// This will accelerates the code.\n+        UInt64 * pos = vec.data();\n+\n+        UInt64 provided = 0;\n+        RangesPos cursor = start;\n+\n+        while (block_size - provided != 0)\n+        {\n+            UInt64 need = block_size - provided;\n+            auto & range = ranges[cursor.offset_in_ranges];\n+\n+            UInt128 can_provide = cursor.offset_in_ranges == end.offset_in_ranges\n+                ? end.offset_in_range - cursor.offset_in_range\n+                : static_cast<UInt128>(last_value(range)) - first_value(range) + 1 - cursor.offset_in_range;\n+\n+            /// set value to block\n+            auto set_value = [&pos](UInt128 & start_value, UInt128 & end_value)\n+            {\n+                if (end_value > std::numeric_limits<UInt64>::max())\n+                {\n+                    while (start_value < end_value)\n+                        *(pos++) = start_value++;\n+                }\n+                else\n+                {\n+                    auto start_value_64 = static_cast<UInt64>(start_value);\n+                    auto end_value_64 = static_cast<UInt64>(end_value);\n+                    while (start_value_64 < end_value_64)\n+                        *(pos++) = start_value_64++;\n+                }\n+            };\n+\n+            if (can_provide > need)\n+            {\n+                UInt64 start_value = first_value(range) + cursor.offset_in_range;\n+                UInt64 end_value = start_value + need; /// end_value will never overflow\n+                while (start_value < end_value)\n+                    *(pos++) = start_value++;\n+\n+                provided += need;\n+                cursor.offset_in_range += need;\n+            }\n+            else if (can_provide == need)\n+            {\n+                /// to avoid UInt64 overflow\n+                UInt128 start_value = static_cast<UInt128>(first_value(range)) + cursor.offset_in_range;\n+                UInt128 end_value = start_value + need;\n+                set_value(start_value, end_value);\n+\n+                provided += need;\n+                cursor.offset_in_ranges++;\n+                cursor.offset_in_range = 0;\n+            }\n+            else\n+            {\n+                /// to avoid UInt64 overflow\n+                UInt128 start_value = static_cast<UInt128>(first_value(range)) + cursor.offset_in_range;\n+                UInt128 end_value = start_value + can_provide;\n+                set_value(start_value, end_value);\n+\n+                provided += static_cast<UInt64>(can_provide);\n+                cursor.offset_in_ranges++;\n+                cursor.offset_in_range = 0;\n+            }\n+        }\n+\n+        chassert(block_size == UInt64(pos - vec.begin()));\n+        progress(column->size(), column->byteSize());\n+\n+        return {Columns{std::move(column)}, block_size};\n+    }\n+\n+private:\n+    /// The ranges is shared between all streams.\n+    Ranges ranges;\n+\n+    /// Ranges state shared between all streams, actually is the start of the ranges.\n+    RangesStatePtr ranges_state;\n+\n+    /// Base block size, will shrink when data left is not enough.\n+    UInt64 base_block_size;\n+};\n+\n+}\n+\n+namespace\n+{\n+/// Whether we should push limit down to scan.\n+bool shouldPushdownLimit(SelectQueryInfo & query_info, UInt64 limit_length)\n+{\n+    const auto & query = query_info.query->as<ASTSelectQuery &>();\n+    /// Just ignore some minor cases, such as:\n+    ///     select * from system.numbers order by number asc limit 10\n+    return !query.distinct && !query.limitBy() && !query_info.has_order_by\n+        && !query_info.need_aggregate\n+        /// For new analyzer, window will be delete from AST, so we should not use query.window()\n+        && !query_info.has_window && !query_info.additional_filter_ast && (limit_length > 0 && !query.limit_with_ties);\n+}\n+\n+/// Shrink ranges to size.\n+///     For example: ranges: [1, 5], [8, 100]; size: 7, we will get [1, 5], [8, 9]\n+void shrinkRanges(Ranges & ranges, size_t size)\n+{\n+    size_t last_range_idx = 0;\n+    for (size_t i = 0; i < ranges.size(); i++)\n+    {\n+        auto range_size = sizeOfRange(ranges[i]);\n+        if (range_size < size)\n+        {\n+            size -= static_cast<UInt64>(range_size);\n+            continue;\n+        }\n+        else if (range_size == size)\n+        {\n+            last_range_idx = i;\n+            break;\n+        }\n+        else\n+        {\n+            auto & range = ranges[i];\n+            UInt64 right = range.left.get<UInt64>() + static_cast<UInt64>(size);\n+            range.right = Field(right);\n+            range.right_included = !range.left_included;\n+            last_range_idx = i;\n+            break;\n+        }\n+    }\n+\n+    /// delete the additional ranges\n+    ranges.erase(ranges.begin() + (last_range_idx + 1), ranges.end());\n+}\n+\n+}\n+\n+ReadFromSystemNumbersStep::ReadFromSystemNumbersStep(\n+    const Names & column_names_,\n+    StoragePtr storage_,\n+    const StorageSnapshotPtr & storage_snapshot_,\n+    SelectQueryInfo & query_info,\n+    ContextPtr context_,\n+    size_t max_block_size_,\n+    size_t num_streams_)\n+    : SourceStepWithFilter{DataStream{.header = storage_snapshot_->getSampleBlockForColumns(column_names_)}}\n+    , column_names{column_names_}\n+    , storage{std::move(storage_)}\n+    , storage_snapshot{storage_snapshot_}\n+    , context{std::move(context_)}\n+    , key_expression{KeyDescription::parse(column_names[0], storage_snapshot->getMetadataForQuery()->columns, context).expression}\n+    , max_block_size{max_block_size_}\n+    , num_streams{num_streams_}\n+    , limit_length_and_offset(InterpreterSelectQuery::getLimitLengthAndOffset(query_info.query->as<ASTSelectQuery&>(), context))\n+    , should_pushdown_limit(shouldPushdownLimit(query_info, limit_length_and_offset.first))\n+    , limit(query_info.limit)\n+    , storage_limits(query_info.storage_limits)\n+{\n+    storage_snapshot->check(column_names);\n+    chassert(column_names.size() == 1);\n+    chassert(storage->as<StorageSystemNumbers>() != nullptr);\n+}\n+\n+\n+void ReadFromSystemNumbersStep::initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)\n+{\n+    auto pipe = makePipe();\n+\n+    if (pipe.empty())\n+    {\n+        assert(output_stream != std::nullopt);\n+        pipe = Pipe(std::make_shared<NullSource>(output_stream->header));\n+    }\n+\n+    /// Add storage limits.\n+    for (const auto & processor : pipe.getProcessors())\n+        processor->setStorageLimits(storage_limits);\n+\n+    /// Add to processors to get processor info through explain pipeline statement.\n+    for (const auto & processor : pipe.getProcessors())\n+        processors.emplace_back(processor);\n+\n+    pipeline.init(std::move(pipe));\n+}\n+\n+Pipe ReadFromSystemNumbersStep::makePipe()\n+{\n+    auto & numbers_storage = storage->as<StorageSystemNumbers &>();\n+\n+    if (!numbers_storage.multithreaded)\n+        num_streams = 1;\n+\n+    /// Build rpn of query filters\n+    KeyCondition condition(buildFilterDAG(), context, column_names, key_expression, NameSet{});\n+\n+    Pipe pipe;\n+    Ranges ranges;\n+\n+    if (condition.extractPlainRanges(ranges))\n+    {\n+        /// Intersect ranges with table range\n+        std::optional<Range> table_range;\n+        std::optional<Range> overflowed_table_range;\n+\n+        if (numbers_storage.limit.has_value())\n+        {\n+            if (std::numeric_limits<UInt64>::max() - numbers_storage.offset >= *(numbers_storage.limit))\n+            {\n+                table_range.emplace(FieldRef(numbers_storage.offset), true, FieldRef(numbers_storage.offset + *(numbers_storage.limit)), false);\n+            }\n+            /// UInt64 overflow, for example: SELECT number FROM numbers(18446744073709551614, 5)\n+            else\n+            {\n+                table_range.emplace(FieldRef(numbers_storage.offset), true, std::numeric_limits<UInt64>::max(), true);\n+                auto overflow_end = UInt128(numbers_storage.offset) + UInt128(*numbers_storage.limit);\n+                overflowed_table_range.emplace(\n+                    FieldRef(UInt64(0)), true, FieldRef(UInt64(overflow_end - std::numeric_limits<UInt64>::max() - 1)), false);\n+            }\n+        }\n+        else\n+        {\n+            table_range.emplace(FieldRef(numbers_storage.offset), true, FieldRef(std::numeric_limits<UInt64>::max()), true);\n+        }\n+\n+        Ranges intersected_ranges;\n+        for (auto & r : ranges)\n+        {\n+            auto intersected_range = table_range->intersectWith(r);\n+            if (intersected_range)\n+                intersected_ranges.push_back(*intersected_range);\n+        }\n+        /// intersection with overflowed_table_range goes back.\n+        if (overflowed_table_range.has_value())\n+        {\n+            for (auto & r : ranges)\n+            {\n+                auto intersected_range = overflowed_table_range->intersectWith(r);\n+                if (intersected_range)\n+                    intersected_ranges.push_back(*overflowed_table_range);\n+            }\n+        }\n+\n+        /// ranges is blank, return a source who has no data\n+        if (intersected_ranges.empty())\n+        {\n+            pipe.addSource(std::make_shared<NullSource>(NumbersSource::createHeader()));\n+            return pipe;\n+        }\n+        const auto & limit_length = limit_length_and_offset.first;\n+        const auto & limit_offset = limit_length_and_offset.second;\n+\n+        /// If intersected ranges is limited or we can pushdown limit.\n+        if (!intersected_ranges.rbegin()->right.isPositiveInfinity() || should_pushdown_limit)\n+        {\n+            UInt128 total_size = sizeOfRanges(intersected_ranges);\n+            UInt128 query_limit = limit_length + limit_offset;\n+\n+            /// limit total_size by query_limit\n+            if (should_pushdown_limit && query_limit < total_size)\n+            {\n+                total_size = query_limit;\n+                /// We should shrink intersected_ranges for case:\n+                ///     intersected_ranges: [1, 4], [7, 100]; query_limit: 2\n+                shrinkRanges(intersected_ranges, total_size);\n+            }\n+\n+            checkLimits(size_t(total_size));\n+\n+            if (total_size / max_block_size < num_streams)\n+                num_streams = static_cast<size_t>(total_size / max_block_size);\n+\n+            if (num_streams == 0)\n+                num_streams = 1;\n+\n+            /// Ranges state, all streams will share the state.\n+            auto ranges_state = std::make_shared<NumbersRangedSource::RangesState>();\n+            for (size_t i = 0; i < num_streams; ++i)\n+            {\n+                auto source = std::make_shared<NumbersRangedSource>(intersected_ranges, ranges_state, max_block_size);\n+\n+                if (i == 0)\n+                    source->addTotalRowsApprox(total_size);\n+\n+                pipe.addSource(std::move(source));\n+            }\n+            return pipe;\n+        }\n+    }\n+\n+    /// Fall back to NumbersSource\n+    for (size_t i = 0; i < num_streams; ++i)\n+    {\n+        auto source\n+            = std::make_shared<NumbersSource>(max_block_size, numbers_storage.offset + i * max_block_size, num_streams * max_block_size);\n+\n+        if (numbers_storage.limit && i == 0)\n+        {\n+            auto rows_appr = *(numbers_storage.limit);\n+            if (limit > 0 && limit < rows_appr)\n+                rows_appr = limit;\n+            source->addTotalRowsApprox(rows_appr);\n+        }\n+\n+        pipe.addSource(std::move(source));\n+    }\n+\n+    if (numbers_storage.limit)\n+    {\n+        size_t i = 0;\n+        auto storage_limit = *(numbers_storage.limit);\n+        /// This formula is how to split 'limit' elements to 'num_streams' chunks almost uniformly.\n+        pipe.addSimpleTransform(\n+            [&](const Block & header)\n+            {\n+                ++i;\n+                return std::make_shared<LimitTransform>(header, storage_limit * i / num_streams - storage_limit * (i - 1) / num_streams, 0);\n+            });\n+    }\n+\n+    return pipe;\n+}\n+\n+ActionsDAGPtr ReadFromSystemNumbersStep::buildFilterDAG()\n+{\n+    std::unordered_map<std::string, ColumnWithTypeAndName> node_name_to_input_node_column;\n+    return ActionsDAG::buildFilterActionsDAG(filter_nodes.nodes, node_name_to_input_node_column, context);\n+}\n+\n+void ReadFromSystemNumbersStep::checkLimits(size_t rows)\n+{\n+    const auto & settings = context->getSettingsRef();\n+\n+    if (settings.read_overflow_mode == OverflowMode::THROW && settings.max_rows_to_read)\n+    {\n+        const auto limits = SizeLimits(settings.max_rows_to_read, 0, settings.read_overflow_mode);\n+        limits.check(rows, 0, \"rows (controlled by 'max_rows_to_read' setting)\", ErrorCodes::TOO_MANY_ROWS);\n+    }\n+\n+    if (settings.read_overflow_mode_leaf == OverflowMode::THROW && settings.max_rows_to_read_leaf)\n+    {\n+        const auto leaf_limits = SizeLimits(settings.max_rows_to_read_leaf, 0, settings.read_overflow_mode_leaf);\n+        leaf_limits.check(rows, 0, \"rows (controlled by 'max_rows_to_read_leaf' setting)\", ErrorCodes::TOO_MANY_ROWS);\n+    }\n+}\n+\n+}\ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\nnew file mode 100644\nindex 000000000000..0a8c62b30af3\n--- /dev/null\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\n@@ -0,0 +1,49 @@\n+#pragma once\n+\n+#include <Core/QueryProcessingStage.h>\n+#include <Interpreters/Context_fwd.h>\n+#include <Processors/QueryPlan/SourceStepWithFilter.h>\n+#include <QueryPipeline/Pipe.h>\n+#include <Storages/IStorage_fwd.h>\n+#include <Storages/SelectQueryInfo.h>\n+#include <Storages/StorageSnapshot.h>\n+\n+namespace DB\n+{\n+\n+class ReadFromSystemNumbersStep final : public SourceStepWithFilter\n+{\n+public:\n+    ReadFromSystemNumbersStep(\n+        const Names & column_names_,\n+        StoragePtr storage_,\n+        const StorageSnapshotPtr & storage_snapshot_,\n+        SelectQueryInfo & query_info,\n+        ContextPtr context_,\n+        size_t max_block_size_,\n+        size_t num_streams_);\n+\n+    String getName() const override { return \"ReadFromSystemNumbers\"; }\n+\n+    void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &) override;\n+\n+private:\n+    /// Fail fast if estimated number of rows to read exceeds the limit\n+    void checkLimits(size_t rows);\n+\n+    Pipe makePipe();\n+    ActionsDAGPtr buildFilterDAG();\n+\n+    const Names column_names;\n+    StoragePtr storage;\n+    StorageSnapshotPtr storage_snapshot;\n+    ContextPtr context;\n+    ExpressionActionsPtr key_expression;\n+    size_t max_block_size;\n+    size_t num_streams;\n+    std::pair<UInt64, UInt64> limit_length_and_offset;\n+    bool should_pushdown_limit;\n+    UInt64 limit;\n+    std::shared_ptr<const StorageLimitsList> storage_limits;\n+};\n+}\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 2932bce42625..868428e3ea20 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -46,7 +46,6 @@ namespace ErrorCodes\n     extern const int BAD_TYPE_OF_FIELD;\n }\n \n-\n /// Returns the prefix of like_pattern before the first wildcard, e.g. 'Hello\\_World% ...' --> 'Hello\\_World'\n /// We call a pattern \"perfect prefix\" if:\n /// - (1) the pattern has a wildcard\n@@ -799,10 +798,13 @@ KeyCondition::KeyCondition(\n \n     if (!filter_node)\n     {\n+        has_filter = false;\n         rpn.emplace_back(RPNElement::FUNCTION_UNKNOWN);\n         return;\n     }\n \n+    has_filter = true;\n+\n     /** When non-strictly monotonic functions are employed in functional index (e.g. ORDER BY toStartOfHour(dateTime)),\n       * the use of NOT operator in predicate will result in the indexing algorithm leave out some data.\n       * This is caused by rewriting in KeyCondition::tryParseAtomFromAST of relational operators to less strict\n@@ -875,10 +877,13 @@ KeyCondition::KeyCondition(\n \n     if (!filter_dag)\n     {\n+        has_filter = false;\n         rpn.emplace_back(RPNElement::FUNCTION_UNKNOWN);\n         return;\n     }\n \n+    has_filter = true;\n+\n     auto inverted_dag = cloneASTWithInversionPushDown({filter_dag->getOutputs().at(0)}, context);\n     assert(inverted_dag->getOutputs().size() == 1);\n \n@@ -2540,6 +2545,173 @@ bool KeyCondition::matchesExactContinuousRange() const\n     return true;\n }\n \n+bool KeyCondition::extractPlainRanges(Ranges & ranges) const\n+{\n+    if (key_indices.empty() || key_indices.size() > 1)\n+        return false;\n+\n+    if (hasMonotonicFunctionsChain())\n+        return false;\n+\n+    /// All Ranges in rpn_stack is plain.\n+    std::stack<PlainRanges> rpn_stack;\n+\n+    for (const auto & element : rpn)\n+    {\n+        if (element.function == RPNElement::FUNCTION_AND)\n+        {\n+            auto right_ranges = rpn_stack.top();\n+            rpn_stack.pop();\n+\n+            auto left_ranges = rpn_stack.top();\n+            rpn_stack.pop();\n+\n+            auto new_range = left_ranges.intersectWith(right_ranges);\n+            rpn_stack.emplace(std::move(new_range));\n+        }\n+        else if (element.function == RPNElement::FUNCTION_OR)\n+        {\n+            auto right_ranges = rpn_stack.top();\n+            rpn_stack.pop();\n+\n+            auto left_ranges = rpn_stack.top();\n+            rpn_stack.pop();\n+\n+            auto new_range = left_ranges.unionWith(right_ranges);\n+            rpn_stack.emplace(std::move(new_range));\n+        }\n+        else if (element.function == RPNElement::FUNCTION_NOT)\n+        {\n+            auto to_invert_ranges = rpn_stack.top();\n+            rpn_stack.pop();\n+\n+            std::vector<Ranges> reverted_ranges = PlainRanges::invert(to_invert_ranges.ranges);\n+\n+            if (reverted_ranges.size() == 1)\n+                rpn_stack.emplace(std::move(reverted_ranges[0]));\n+            else\n+            {\n+                /// intersect reverted ranges\n+                PlainRanges intersected_ranges(reverted_ranges[0]);\n+                for (size_t i = 1; i < reverted_ranges.size(); i++)\n+                {\n+                    intersected_ranges = intersected_ranges.intersectWith(PlainRanges(reverted_ranges[i]));\n+                }\n+                rpn_stack.emplace(std::move(intersected_ranges));\n+            }\n+        }\n+        else /// atom relational expression or constants\n+        {\n+            if (element.function == RPNElement::FUNCTION_IN_RANGE)\n+            {\n+                rpn_stack.push(PlainRanges(element.range));\n+            }\n+            else if (element.function == RPNElement::FUNCTION_NOT_IN_RANGE)\n+            {\n+                rpn_stack.push(PlainRanges(element.range.invertRange()));\n+            }\n+            else if (element.function == RPNElement::FUNCTION_IN_SET)\n+            {\n+                if (element.set_index->hasMonotonicFunctionsChain())\n+                    return false;\n+\n+                if (element.set_index->size() == 0)\n+                {\n+                    rpn_stack.push(PlainRanges::makeBlank()); /// skip blank range\n+                    continue;\n+                }\n+\n+                const auto & values = element.set_index->getOrderedSet();\n+                Ranges points_range;\n+\n+                /// values in set_index are ordered and no duplication\n+                for (size_t i=0; i<element.set_index->size(); i++)\n+                {\n+                    FieldRef f;\n+                    values[0]->get(i, f);\n+                    if (f.isNull())\n+                        return false;\n+                    points_range.push_back({f});\n+                }\n+                rpn_stack.push(PlainRanges(points_range));\n+            }\n+            else if (element.function == RPNElement::FUNCTION_NOT_IN_SET)\n+            {\n+                if (element.set_index->hasMonotonicFunctionsChain())\n+                    return false;\n+\n+                if (element.set_index->size() == 0)\n+                {\n+                    rpn_stack.push(PlainRanges::makeUniverse());\n+                    continue;\n+                }\n+\n+                const auto & values = element.set_index->getOrderedSet();\n+                Ranges points_range;\n+\n+                std::optional<FieldRef> pre;\n+                for (size_t i=0; i<element.set_index->size(); i++)\n+                {\n+                    FieldRef cur;\n+                    values[0]->get(i, cur);\n+\n+                    if (cur.isNull())\n+                        return false;\n+                    if (pre)\n+                    {\n+                        Range r(*pre, false, cur, false);\n+                        /// skip blank range\n+                        if (!(r.left > r.right || (r.left == r.right && !r.left_included && !r.right_included)))\n+                            points_range.push_back(r);\n+                    }\n+                    else\n+                    {\n+                        points_range.push_back(Range::createRightBounded(cur, false));\n+                    }\n+                    pre = cur;\n+                }\n+\n+                points_range.push_back(Range::createLeftBounded(*pre, false));\n+                rpn_stack.push(PlainRanges(points_range));\n+            }\n+            else if (element.function == RPNElement::ALWAYS_FALSE)\n+            {\n+                /// skip blank range\n+                rpn_stack.push(PlainRanges::makeBlank());\n+            }\n+            else if (element.function == RPNElement::ALWAYS_TRUE)\n+            {\n+                rpn_stack.push(PlainRanges::makeUniverse());\n+            }\n+            else if (element.function == RPNElement::FUNCTION_IS_NULL)\n+            {\n+                /// key values can not be null, so isNull will get blank range.\n+                rpn_stack.push(PlainRanges::makeBlank());\n+            }\n+            else if (element.function == RPNElement::FUNCTION_IS_NOT_NULL)\n+            {\n+                rpn_stack.push(PlainRanges::makeUniverse());\n+            }\n+            else /// FUNCTION_UNKNOWN\n+            {\n+                if (!has_filter)\n+                    rpn_stack.push(PlainRanges::makeUniverse());\n+                else\n+                    return false;\n+            }\n+        }\n+    }\n+\n+    if (rpn_stack.size() != 1)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected stack size in KeyCondition::extractPlainRanges\");\n+\n+    for (auto & r : rpn_stack.top().ranges)\n+    {\n+        ranges.push_back(std::move(r));\n+    }\n+    return true;\n+}\n+\n BoolMask KeyCondition::checkInHyperrectangle(\n     const Hyperrectangle & hyperrectangle,\n     const DataTypes & data_types) const\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex 151b35b6d6dd..3b430d80c4dc 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -4,6 +4,7 @@\n \n #include <Core/SortDescription.h>\n #include <Core/Range.h>\n+#include <Core/PlainRanges.h>\n \n #include <Parsers/ASTExpressionList.h>\n \n@@ -162,6 +163,16 @@ class KeyCondition\n \n     bool matchesExactContinuousRange() const;\n \n+    /// Extract plain ranges of the condition.\n+    /// Note that only support one column key condition.\n+    ///\n+    /// Now some cases are parsed to unknown function:\n+    ///     1. where 1=1\n+    ///     2. where true\n+    ///     3. no where\n+    /// TODO handle the cases when generate RPN.\n+    bool extractPlainRanges(Ranges & ranges) const;\n+\n     /// The expression is stored as Reverse Polish Notation.\n     struct RPNElement\n     {\n@@ -326,6 +337,10 @@ class KeyCondition\n \n     RPN rpn;\n \n+    /// If query has no filter, rpn will has one element with unknown function.\n+    /// This flag identify whether there are filters.\n+    bool has_filter;\n+\n     ColumnIndices key_columns;\n     std::vector<size_t> key_indices;\n \ndiff --git a/src/Storages/StorageExecutable.cpp b/src/Storages/StorageExecutable.cpp\nindex df03301b5e89..2acbf3f46106 100644\n--- a/src/Storages/StorageExecutable.cpp\n+++ b/src/Storages/StorageExecutable.cpp\n@@ -20,6 +20,7 @@\n #include <Processors/Sources/SourceFromSingleChunk.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n+#include <Interpreters/InterpreterSelectQueryAnalyzer.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Storages/StorageFactory.h>\n #include <Storages/checkAndGetLiteralArgument.h>\n@@ -145,8 +146,11 @@ void StorageExecutable::read(\n \n     for (auto & input_query : input_queries)\n     {\n-        InterpreterSelectWithUnionQuery interpreter(input_query, context, {});\n-        auto builder = interpreter.buildQueryPipeline();\n+        QueryPipelineBuilder builder;\n+        if (context->getSettings().allow_experimental_analyzer)\n+            builder = InterpreterSelectQueryAnalyzer(input_query, context, {}).buildQueryPipeline();\n+        else\n+            builder = InterpreterSelectWithUnionQuery(input_query, context, {}).buildQueryPipeline();\n         inputs.emplace_back(QueryPipelineBuilder::getPipe(std::move(builder), resources));\n     }\n \ndiff --git a/src/Storages/System/StorageSystemNumbers.cpp b/src/Storages/System/StorageSystemNumbers.cpp\nindex 6b5fd46fe1e4..b100be7cdf45 100644\n--- a/src/Storages/System/StorageSystemNumbers.cpp\n+++ b/src/Storages/System/StorageSystemNumbers.cpp\n@@ -1,201 +1,40 @@\n-#include <Common/Exception.h>\n-#include <Columns/ColumnsNumber.h>\n-#include <DataTypes/DataTypesNumber.h>\n #include <Storages/System/StorageSystemNumbers.h>\n-#include <Storages/SelectQueryInfo.h>\n \n+#include <mutex>\n+#include <Columns/ColumnsNumber.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n #include <Processors/ISource.h>\n-#include <QueryPipeline/Pipe.h>\n #include <Processors/LimitTransform.h>\n-\n+#include <Processors/QueryPlan/QueryPlan.h>\n+#include <Processors/QueryPlan/ReadFromSystemNumbersStep.h>\n+#include <Processors/Sources/NullSource.h>\n+#include <QueryPipeline/Pipe.h>\n+#include <Storages/SelectQueryInfo.h>\n \n namespace DB\n {\n \n-namespace\n-{\n-\n-class NumbersSource : public ISource\n-{\n-public:\n-    NumbersSource(UInt64 block_size_, UInt64 offset_, UInt64 step_)\n-        : ISource(createHeader()), block_size(block_size_), next(offset_), step(step_) {}\n-\n-    String getName() const override { return \"Numbers\"; }\n-\n-protected:\n-    Chunk generate() override\n-    {\n-        auto column = ColumnUInt64::create(block_size);\n-        ColumnUInt64::Container & vec = column->getData();\n-\n-        size_t curr = next;     /// The local variable for some reason works faster (>20%) than member of class.\n-        UInt64 * pos = vec.data(); /// This also accelerates the code.\n-        UInt64 * end = &vec[block_size];\n-        while (pos < end)\n-            *pos++ = curr++;\n-\n-        next += step;\n-\n-        progress(column->size(), column->byteSize());\n-\n-        return { Columns {std::move(column)}, block_size };\n-    }\n-\n-private:\n-    UInt64 block_size;\n-    UInt64 next;\n-    UInt64 step;\n-\n-    static Block createHeader()\n-    {\n-        return { ColumnWithTypeAndName(ColumnUInt64::create(), std::make_shared<DataTypeUInt64>(), \"number\") };\n-    }\n-};\n-\n-\n-struct NumbersMultiThreadedState\n-{\n-    std::atomic<UInt64> counter;\n-    explicit NumbersMultiThreadedState(UInt64 offset) : counter(offset) {}\n-};\n-\n-using NumbersMultiThreadedStatePtr = std::shared_ptr<NumbersMultiThreadedState>;\n-\n-class NumbersMultiThreadedSource : public ISource\n-{\n-public:\n-    NumbersMultiThreadedSource(NumbersMultiThreadedStatePtr state_, UInt64 block_size_, UInt64 max_counter_)\n-        : ISource(createHeader())\n-        , state(std::move(state_))\n-        , block_size(block_size_)\n-        , max_counter(max_counter_) {}\n-\n-    String getName() const override { return \"NumbersMt\"; }\n-\n-protected:\n-    Chunk generate() override\n-    {\n-        if (block_size == 0)\n-            return {};\n-\n-        UInt64 curr = state->counter.fetch_add(block_size, std::memory_order_relaxed);\n-\n-        if (curr >= max_counter)\n-            return {};\n-\n-        if (curr + block_size > max_counter)\n-            block_size = max_counter - curr;\n-\n-        auto column = ColumnUInt64::create(block_size);\n-        ColumnUInt64::Container & vec = column->getData();\n-\n-        UInt64 * pos = vec.data();\n-        UInt64 * end = &vec[block_size];\n-        while (pos < end)\n-            *pos++ = curr++;\n-\n-        progress(column->size(), column->byteSize());\n-\n-        return { Columns {std::move(column)}, block_size };\n-    }\n-\n-private:\n-    NumbersMultiThreadedStatePtr state;\n-\n-    UInt64 block_size;\n-    UInt64 max_counter;\n-\n-    static Block createHeader()\n-    {\n-        return { ColumnWithTypeAndName(ColumnUInt64::create(), std::make_shared<DataTypeUInt64>(), \"number\") };\n-    }\n-};\n-\n-}\n-\n-\n-StorageSystemNumbers::StorageSystemNumbers(const StorageID & table_id, bool multithreaded_, std::optional<UInt64> limit_, UInt64 offset_, bool even_distribution_)\n-    : IStorage(table_id), multithreaded(multithreaded_), even_distribution(even_distribution_), limit(limit_), offset(offset_)\n+StorageSystemNumbers::StorageSystemNumbers(const StorageID & table_id, bool multithreaded_, std::optional<UInt64> limit_, UInt64 offset_)\n+    : IStorage(table_id), multithreaded(multithreaded_), limit(limit_), offset(offset_)\n {\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(ColumnsDescription({{\"number\", std::make_shared<DataTypeUInt64>()}}));\n     setInMemoryMetadata(storage_metadata);\n }\n \n-Pipe StorageSystemNumbers::read(\n+void StorageSystemNumbers::read(\n+    QueryPlan & query_plan,\n     const Names & column_names,\n     const StorageSnapshotPtr & storage_snapshot,\n     SelectQueryInfo & query_info,\n-    ContextPtr /*context*/,\n+    ContextPtr context,\n     QueryProcessingStage::Enum /*processed_stage*/,\n     size_t max_block_size,\n     size_t num_streams)\n {\n-    storage_snapshot->check(column_names);\n-\n-    if (limit && *limit < max_block_size)\n-    {\n-        max_block_size = static_cast<size_t>(*limit);\n-        multithreaded = false;\n-    }\n-\n-    if (!multithreaded)\n-        num_streams = 1;\n-\n-    Pipe pipe;\n-\n-    if (num_streams > 1 && !even_distribution && limit)\n-    {\n-        auto state = std::make_shared<NumbersMultiThreadedState>(offset);\n-        UInt64 max_counter = offset + *limit;\n-\n-        for (size_t i = 0; i < num_streams; ++i)\n-        {\n-            auto source = std::make_shared<NumbersMultiThreadedSource>(state, max_block_size, max_counter);\n-\n-            if (i == 0)\n-            {\n-                auto rows_appr = *limit;\n-                if (query_info.limit > 0 && query_info.limit < rows_appr)\n-                    rows_appr = query_info.limit;\n-                source->addTotalRowsApprox(rows_appr);\n-            }\n-\n-            pipe.addSource(std::move(source));\n-        }\n-\n-        return pipe;\n-    }\n-\n-    for (size_t i = 0; i < num_streams; ++i)\n-    {\n-        auto source = std::make_shared<NumbersSource>(max_block_size, offset + i * max_block_size, num_streams * max_block_size);\n-\n-        if (limit && i == 0)\n-        {\n-            auto rows_appr = *limit;\n-            if (query_info.limit > 0 && query_info.limit < rows_appr)\n-                rows_appr = query_info.limit;\n-            source->addTotalRowsApprox(rows_appr);\n-        }\n-\n-        pipe.addSource(std::move(source));\n-    }\n-\n-    if (limit)\n-    {\n-        size_t i = 0;\n-        /// This formula is how to split 'limit' elements to 'num_streams' chunks almost uniformly.\n-        pipe.addSimpleTransform([&](const Block & header)\n-        {\n-            ++i;\n-            return std::make_shared<LimitTransform>(\n-                header, *limit * i / num_streams - *limit * (i - 1) / num_streams, 0);\n-        });\n-    }\n-\n-    return pipe;\n+    query_plan.addStep(std::make_unique<ReadFromSystemNumbersStep>(\n+        column_names, shared_from_this(), storage_snapshot, query_info, std::move(context), max_block_size, num_streams));\n }\n \n }\ndiff --git a/src/Storages/System/StorageSystemNumbers.h b/src/Storages/System/StorageSystemNumbers.h\nindex acddac681efd..4c98a359ed58 100644\n--- a/src/Storages/System/StorageSystemNumbers.h\n+++ b/src/Storages/System/StorageSystemNumbers.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <optional>\n+#include <Parsers/ASTIdentifier.h>\n #include <Storages/IStorage.h>\n \n \n@@ -15,38 +16,62 @@ class Context;\n   * From this table, you can read all natural numbers, starting from 0 (to 2^64 - 1, and then again).\n   *\n   * You could also specify a limit (how many numbers to give).\n+  *\n+  * How to generate numbers?\n+  *\n+  * 1. First try a smart fashion:\n+  *\n+  * In this fashion we try to push filters and limit down to scanning.\n+  * Firstly extract plain ranges(no overlapping and ordered) by filter expressions.\n+  *\n+  * For example:\n+  *     where (numbers > 1 and numbers < 3) or (numbers in (4, 6)) or (numbers > 7 and numbers < 9)\n+  *\n+  * We will get ranges\n+  *     (1, 3), [4, 4], [6, 6], (7, 9)\n+  *\n+  * Then split the ranges evenly to one or multi-streams. With this way we will get result without large scanning.\n+  *\n+  * 2. If fail to extract plain ranges, fall back to ordinary scanning.\n+  *\n   * If multithreaded is specified, numbers will be generated in several streams\n   *  (and result could be out of order). If both multithreaded and limit are specified,\n   *  the table could give you not exactly 1..limit range, but some arbitrary 'limit' numbers.\n-  *\n-  *  In multithreaded case, if even_distributed is False, implementation with atomic is used,\n-  *     and result is always in [0 ... limit - 1] range.\n   */\n class StorageSystemNumbers final : public IStorage\n {\n public:\n-    /// If even_distribution is true, numbers are distributed evenly between streams.\n     /// Otherwise, streams concurrently increment atomic.\n-    StorageSystemNumbers(const StorageID & table_id, bool multithreaded_, std::optional<UInt64> limit_ = std::nullopt, UInt64 offset_ = 0, bool even_distribution_ = true);\n+    StorageSystemNumbers(const StorageID & table_id, bool multithreaded_, std::optional<UInt64> limit_ = std::nullopt, UInt64 offset_ = 0);\n \n     std::string getName() const override { return \"SystemNumbers\"; }\n \n-    Pipe read(\n+    void read(\n+        QueryPlan & query_plan,\n         const Names & column_names,\n         const StorageSnapshotPtr & storage_snapshot,\n         SelectQueryInfo & query_info,\n         ContextPtr context,\n-        QueryProcessingStage::Enum processed_stage,\n+        QueryProcessingStage::Enum /*processed_stage*/,\n         size_t max_block_size,\n         size_t num_streams) override;\n \n     bool hasEvenlyDistributedRead() const override { return true; }\n     bool isSystemStorage() const override { return true; }\n+\n     bool supportsTransactions() const override { return true; }\n+    bool supportsIndexForIn() const override { return true; }\n+\n+    bool mayBenefitFromIndexForIn(\n+        const ASTPtr & left_in_operand, ContextPtr /* query_context */, const StorageMetadataPtr & /* metadata_snapshot */) const override\n+    {\n+        return left_in_operand->as<ASTIdentifier>() && left_in_operand->getColumnName() == \"number\";\n+    }\n \n private:\n+    friend class ReadFromSystemNumbersStep;\n+\n     bool multithreaded;\n-    bool even_distribution;\n     std::optional<UInt64> limit;\n     UInt64 offset;\n };\ndiff --git a/src/TableFunctions/TableFunctionNumbers.cpp b/src/TableFunctions/TableFunctionNumbers.cpp\nindex 9abd764f91d2..262018f108ca 100644\n--- a/src/TableFunctions/TableFunctionNumbers.cpp\n+++ b/src/TableFunctions/TableFunctionNumbers.cpp\n@@ -63,7 +63,7 @@ StoragePtr TableFunctionNumbers<multithreaded>::executeImpl(const ASTPtr & ast_f\n         UInt64 offset = arguments.size() == 2 ? evaluateArgument(context, arguments[0]) : 0;\n         UInt64 length = arguments.size() == 2 ? evaluateArgument(context, arguments[1]) : evaluateArgument(context, arguments[0]);\n \n-        auto res = std::make_shared<StorageSystemNumbers>(StorageID(getDatabaseName(), table_name), multithreaded, length, offset, false);\n+        auto res = std::make_shared<StorageSystemNumbers>(StorageID(getDatabaseName(), table_name), multithreaded, length, offset);\n         res->startup();\n         return res;\n     }\n",
  "test_patch": "diff --git a/tests/integration/test_grpc_protocol/test.py b/tests/integration/test_grpc_protocol/test.py\nindex 0dc08630b774..0332e5bb90f5 100644\n--- a/tests/integration/test_grpc_protocol/test.py\n+++ b/tests/integration/test_grpc_protocol/test.py\n@@ -388,8 +388,6 @@ def test_progress():\n                 rows=8,\n                 blocks=4,\n                 allocated_bytes=1092,\n-                applied_limit=True,\n-                rows_before_limit=8,\n             )\n         ),\n     ]\ndiff --git a/tests/integration/test_storage_numbers/__init__.py b/tests/integration/test_storage_numbers/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_storage_numbers/test.py b/tests/integration/test_storage_numbers/test.py\nnew file mode 100644\nindex 000000000000..61fe8719ea2e\n--- /dev/null\n+++ b/tests/integration/test_storage_numbers/test.py\n@@ -0,0 +1,244 @@\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+node = cluster.add_instance(\"node\", main_configs=[])\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster(request):\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def check_read_rows(query_id, read_rows):\n+    node.query(\"SYSTEM FLUSH LOGS\")\n+    real_read_rows = node.query(\n+        f\"\"\"SELECT read_rows\n+            FROM system.query_log\n+            WHERE\n+                type = 'QueryFinish' and\n+                query_id = '{query_id}'\n+            ORDER BY initial_query_start_time_microseconds DESC\n+            LIMIT 1\"\"\"\n+    )\n+    assert real_read_rows == str(read_rows) + \"\\n\"\n+\n+\n+def test_simple_range(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number=1 FORMAT Values\",\n+        query_id=\"test_equal\",\n+    )\n+    assert response == \"(1)\"\n+    check_read_rows(\"test_equal\", 1)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number > 1 and number < 6 FORMAT Values\",\n+        query_id=\"test_single_range\",\n+    )\n+    assert response == \"(2),(3),(4),(5)\"\n+    check_read_rows(\"test_single_range\", 4)\n+\n+\n+def test_between(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number between 1 and 6 FORMAT Values\",\n+        query_id=\"test_between\",\n+    )\n+    assert response == \"(1),(2),(3),(4),(5),(6)\"\n+    check_read_rows(\"test_between\", 6)\n+\n+\n+def test_blank_range(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number < 1 and number > 6 FORMAT Values\",\n+        query_id=\"test_blank_range\",\n+    )\n+    assert response == \"\"\n+    check_read_rows(\"test_blank_range\", 0)\n+\n+\n+def test_in(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number in (2, 3) FORMAT Values\",\n+        query_id=\"test_in_simple\",\n+    )\n+    assert response == \"(2),(3)\"\n+    check_read_rows(\"test_in_simple\", 2)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number in (2, 3, 3) FORMAT Values\",\n+        query_id=\"test_in_with_duplicated_values\",\n+    )\n+    assert response == \"(2),(3)\"\n+    check_read_rows(\"test_in_with_duplicated_values\", 2)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number in (2, 3, 1) FORMAT Values\",\n+        query_id=\"test_in_with_unordered_values\",\n+    )\n+    assert response == \"(1),(2),(3)\"\n+    check_read_rows(\"test_in_with_unordered_values\", 3)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number in (1, 2, 5) FORMAT Values\",\n+        query_id=\"test_in_multiple_ranges\",\n+    )\n+    assert response == \"(1),(2),(5)\"\n+    check_read_rows(\"test_in_multiple_ranges\", 3)\n+\n+\n+def test_not_in(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number not in (2, 3) limit 3 FORMAT Values\",\n+        query_id=\"test_not_in\",\n+    )\n+    assert response == \"(0),(1),(4)\"\n+    check_read_rows(\"test_not_in\", 3)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number not in (2, 4, 5) limit 4 FORMAT Values\",\n+        query_id=\"test_not_in_multiple_ranges\",\n+    )\n+    assert response == \"(0),(1),(3),(6)\"\n+    check_read_rows(\"test_not_in_multiple_ranges\", 4)\n+\n+\n+def test_and(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number in (2, 4) and number > 2 FORMAT Values\",\n+        query_id=\"test_and\",\n+    )\n+    assert response == \"(4)\"\n+    check_read_rows(\"test_and\", 1)\n+\n+\n+def test_or(started_cluster):\n+    response = node.query(\n+        \"\"\"SELECT\n+                *\n+            FROM\n+                system.numbers\n+            WHERE\n+                (number > 1 and number < 3) or (number in (4, 6)) or (number > 7 and number < 9)\n+            FORMAT Values\"\"\",\n+        query_id=\"test_simple_or\",\n+    )\n+    assert response == \"(2),(4),(6),(8)\"\n+    check_read_rows(\"test_simple_or\", 4)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE (number > 1 and number < 3) or (number < 6) FORMAT Values\",\n+        query_id=\"test_or_with_overlapping_ranges\",\n+    )\n+    assert response == \"(0),(1),(2),(3),(4),(5)\"\n+    check_read_rows(\"test_or_with_overlapping_ranges\", 6)\n+\n+\n+def test_not(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE not (number > 1 and number < 3) limit 5 FORMAT Values\",\n+        query_id=\"test_not\",\n+    )\n+    assert response == \"(0),(1),(3),(4),(5)\"\n+    check_read_rows(\"test_not\", 5)\n+\n+\n+def test_true_or_false(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number < 3 and 1 limit 5 FORMAT Values\",\n+        query_id=\"test_true\",\n+    )\n+    assert response == \"(0),(1),(2)\"\n+    check_read_rows(\"test_true\", 3)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number < 3 and 0 FORMAT Values\",\n+        query_id=\"test_false\",\n+    )\n+    assert response == \"\"\n+    check_read_rows(\"test_false\", 0)\n+\n+\n+def test_limit(started_cluster):\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number > 2 limit 1 FORMAT Values\",\n+        query_id=\"test_simple_limit\",\n+    )\n+    assert response == \"(3)\"\n+    check_read_rows(\"test_simple_limit\", 1)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number not in (2, 3) limit 1 FORMAT Values\",\n+        query_id=\"test_limit_with_multi_ranges\",\n+    )\n+    assert response == \"(0)\"\n+    check_read_rows(\"test_limit_with_multi_ranges\", 1)\n+\n+    response = node.query(\n+        \"SELECT * FROM system.numbers WHERE number not in (2, 3) limit 1, 2 FORMAT Values\",\n+        query_id=\"test_limit_with_offset\",\n+    )\n+    assert response == \"(1),(4)\"\n+    check_read_rows(\"test_limit_with_offset\", 3)\n+\n+\n+def test_subquery(started_cluster):\n+    response = node.query(\n+        \"\"\"SELECT\n+                *\n+            FROM\n+                (select * FROM system.numbers WHERE number < 2) AS n\n+            FORMAT Values\"\"\",\n+        query_id=\"test_subquery\",\n+    )\n+    assert response == \"(0),(1)\"\n+    check_read_rows(\"test_subquery\", 2)\n+\n+\n+def test_multi_streams(started_cluster):\n+    response = node.query(\n+        \"\"\"SELECT\n+                *\n+            FROM\n+                system.numbers_mt\n+            WHERE\n+                number > 1 and number < 7\n+            ORDER BY\n+                number\n+            FORMAT Values\n+            settings max_block_size=2\"\"\",\n+        query_id=\"test_multi_streams\",\n+    )\n+    assert response == \"(2),(3),(4),(5),(6)\"\n+    check_read_rows(\"test_multi_streams\", 5)\n+\n+    response = node.query(\n+        \"\"\"SELECT\n+                *\n+            FROM\n+                system.numbers_mt\n+            WHERE\n+                (number > 1 and number < 3) or (number in (4, 6)) or (number > 7 and number < 10)\n+            ORDER BY\n+                number\n+            FORMAT Values\n+            settings max_block_size=2\"\"\",\n+        query_id=\"test_multi_streams_with_multi_ranges\",\n+    )\n+    assert response == \"(2),(4),(6),(8),(9)\"\n+    check_read_rows(\"test_multi_streams\", 5)\n+\n+\n+def test_overflow(started_cluster):\n+    response = node.query(\n+        \"SELECT number FROM numbers(18446744073709551614, 5) FORMAT Values\",\n+        query_id=\"test_overflow\",\n+    )\n+    assert response == \"(18446744073709551614),(18446744073709551615),(0),(1),(2)\"\n+    check_read_rows(\"test_overflow\", 5)\ndiff --git a/tests/queries/0_stateless/00344_row_number_in_all_blocks.sql b/tests/queries/0_stateless/00344_row_number_in_all_blocks.sql\nindex 43727f2a14e8..56a04c85c253 100644\n--- a/tests/queries/0_stateless/00344_row_number_in_all_blocks.sql\n+++ b/tests/queries/0_stateless/00344_row_number_in_all_blocks.sql\n@@ -1,4 +1,5 @@\n SET max_block_size = 1000;\n+SET max_threads = 10;\n SELECT\n     groupUniqArray(blockSize()),\n     uniqExact(rowNumberInAllBlocks()),\ndiff --git a/tests/queries/0_stateless/00416_pocopatch_progress_in_http_headers.reference b/tests/queries/0_stateless/00416_pocopatch_progress_in_http_headers.reference\nindex c6db9cc16149..462f2f63fe1d 100644\n--- a/tests/queries/0_stateless/00416_pocopatch_progress_in_http_headers.reference\n+++ b/tests/queries/0_stateless/00416_pocopatch_progress_in_http_headers.reference\n@@ -24,4 +24,4 @@\n 7\n 8\n 9\n-< X-ClickHouse-Summary: {\"read_rows\":\"10\",\"read_bytes\":\"80\",\"written_rows\":\"10\",\"written_bytes\":\"40\",\"total_rows_to_read\":\"0\",\"result_rows\":\"10\",\"result_bytes\":\"40\"}\r\n+< X-ClickHouse-Summary: {\"read_rows\":\"10\",\"read_bytes\":\"80\",\"written_rows\":\"10\",\"written_bytes\":\"40\",\"total_rows_to_read\":\"10\",\"result_rows\":\"10\",\"result_bytes\":\"40\"}\r\ndiff --git a/tests/queries/0_stateless/01472_many_rows_in_totals.reference b/tests/queries/0_stateless/01472_many_rows_in_totals.reference\nindex 28f78731283c..92a9e4bbb53a 100644\n--- a/tests/queries/0_stateless/01472_many_rows_in_totals.reference\n+++ b/tests/queries/0_stateless/01472_many_rows_in_totals.reference\n@@ -63,8 +63,6 @@ Totals:\n \t\t\"s\": \"6\"\n \t},\n \n-\t\"rows\": 4,\n-\n-\t\"rows_before_limit_at_least\": 4\n+\t\"rows\": 4\n }\n --\ndiff --git a/tests/queries/0_stateless/01553_settings_early_apply.reference b/tests/queries/0_stateless/01553_settings_early_apply.reference\nindex a42a7daadaa0..860d8d48c856 100644\n--- a/tests/queries/0_stateless/01553_settings_early_apply.reference\n+++ b/tests/queries/0_stateless/01553_settings_early_apply.reference\n@@ -70,7 +70,5 @@ UInt64\n \t\t[\"9\"]\n \t],\n \n-\t\"rows\": 10,\n-\n-\t\"rows_before_limit_at_least\": 10\n+\t\"rows\": 10\n }\ndiff --git a/tests/queries/0_stateless/01591_window_functions.reference b/tests/queries/0_stateless/01591_window_functions.reference\nindex ce9c6f4589e0..5d12a09a8460 100644\n--- a/tests/queries/0_stateless/01591_window_functions.reference\n+++ b/tests/queries/0_stateless/01591_window_functions.reference\n@@ -921,7 +921,7 @@ Expression ((Project names + Projection))\n       Window (Window step for window \\'PARTITION BY p_0 ORDER BY o_1 ASC\\')\n         Sorting (Sorting for window \\'PARTITION BY p_0 ORDER BY o_1 ASC\\')\n           Expression ((Before WINDOW + (Change column names to column identifiers + (Project names + (Projection + Change column names to column identifiers)))))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n explain select\n     count(*) over (order by o, number),\n     count(*) over (order by number)\n@@ -936,7 +936,7 @@ Expression ((Project names + Projection))\n         Expression ((Before WINDOW + (Change column names to column identifiers + (Project names + (Projection + Change column names to column identifiers)))) [lifted up part])\n           Sorting (Sorting for window \\'ORDER BY number_1 ASC\\')\n             Expression ((Before WINDOW + (Change column names to column identifiers + (Project names + (Projection + Change column names to column identifiers)))))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n -- A test case for the sort comparator found by fuzzer.\n SELECT\n     max(number) OVER (ORDER BY number DESC NULLS FIRST),\ndiff --git a/tests/queries/0_stateless/01722_long_brotli_http_compression_json_format.reference b/tests/queries/0_stateless/01722_long_brotli_http_compression_json_format.reference\nindex 7c089a2fd059..4b7a52a1f13d 100644\n--- a/tests/queries/0_stateless/01722_long_brotli_http_compression_json_format.reference\n+++ b/tests/queries/0_stateless/01722_long_brotli_http_compression_json_format.reference\n@@ -1,3 +1,5 @@\n+\t\t\t\"detail\": \"clickhouse\",\n+\t\t\t\"row_number\": \"999997\"\n \t\t},\n \t\t{\n \t\t\t\"datetime\": \"2020-12-12\",\n@@ -19,5 +21,3 @@\n \n \t\"rows\": 1000000,\n \n-\t\"rows_before_limit_at_least\": 1048080,\n-\ndiff --git a/tests/queries/0_stateless/01746_long_zlib_http_compression_json_format.reference b/tests/queries/0_stateless/01746_long_zlib_http_compression_json_format.reference\nindex 92dfd99c259f..c8cd971ab908 100644\n--- a/tests/queries/0_stateless/01746_long_zlib_http_compression_json_format.reference\n+++ b/tests/queries/0_stateless/01746_long_zlib_http_compression_json_format.reference\n@@ -1,3 +1,5 @@\n+\t\t\t\"detail\": \"clickhouse\",\n+\t\t\t\"row_number\": \"99997\"\n \t\t},\n \t\t{\n \t\t\t\"datetime\": \"2020-12-12\",\n@@ -19,5 +21,3 @@\n \n \t\"rows\": 100000,\n \n-\t\"rows_before_limit_at_least\": 131010,\n-\ndiff --git a/tests/queries/0_stateless/01746_long_zstd_http_compression_json_format.reference b/tests/queries/0_stateless/01746_long_zstd_http_compression_json_format.reference\nindex 7c089a2fd059..4b7a52a1f13d 100644\n--- a/tests/queries/0_stateless/01746_long_zstd_http_compression_json_format.reference\n+++ b/tests/queries/0_stateless/01746_long_zstd_http_compression_json_format.reference\n@@ -1,3 +1,5 @@\n+\t\t\t\"detail\": \"clickhouse\",\n+\t\t\t\"row_number\": \"999997\"\n \t\t},\n \t\t{\n \t\t\t\"datetime\": \"2020-12-12\",\n@@ -19,5 +21,3 @@\n \n \t\"rows\": 1000000,\n \n-\t\"rows_before_limit_at_least\": 1048080,\n-\ndiff --git a/tests/queries/0_stateless/01883_with_grouping_sets.reference b/tests/queries/0_stateless/01883_with_grouping_sets.reference\nindex 499e930541fb..643fc6fa70c5 100644\n--- a/tests/queries/0_stateless/01883_with_grouping_sets.reference\n+++ b/tests/queries/0_stateless/01883_with_grouping_sets.reference\n@@ -104,8 +104,8 @@ ExpressionTransform\n                   Copy \u00d7 3 1 \u2192 2\n                     (Expression)\n                     ExpressionTransform \u00d7 3\n-                      (ReadFromStorage)\n-                      NumbersMt \u00d7 3 0 \u2192 1\n+                      (ReadFromSystemNumbers)\n+                      NumbersRange \u00d7 3 0 \u2192 1\n 4999500000\t10000\n 4999510000\t10000\n 4999520000\t10000\ndiff --git a/tests/queries/0_stateless/01951_distributed_push_down_limit.reference b/tests/queries/0_stateless/01951_distributed_push_down_limit.reference\nindex d175d31846bc..fcdf9ba502f9 100644\n--- a/tests/queries/0_stateless/01951_distributed_push_down_limit.reference\n+++ b/tests/queries/0_stateless/01951_distributed_push_down_limit.reference\n@@ -6,7 +6,7 @@ Expression\n       Union\n         Sorting\n           Expression\n-            ReadFromStorage\n+            ReadFromSystemNumbers\n         ReadFromRemote\n explain description=0 select * from remote('127.{1,2}', view(select * from numbers(1e6))) order by number limit 10 settings distributed_push_down_limit=1;\n Expression\n@@ -15,5 +15,5 @@ Expression\n       Union\n         Sorting\n           Expression\n-            ReadFromStorage\n+            ReadFromSystemNumbers\n         ReadFromRemote\ndiff --git a/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference b/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference\nindex 6adb2382a6f6..ddfa6929d693 100644\n--- a/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference\n+++ b/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference\n@@ -5,7 +5,7 @@ Expression (Projection)\n     Union\n       Distinct (Preliminary DISTINCT)\n         Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n       ReadFromRemote (Read from remote replica)\n explain select distinct k1, k2 from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)); -- optimized\n Union\n@@ -13,14 +13,14 @@ Union\n     Distinct\n       Distinct (Preliminary DISTINCT)\n         Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n   ReadFromRemote (Read from remote replica)\n explain select distinct on (k1) k2 from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)); -- not optimized\n Expression (Projection)\n   LimitBy\n     Union\n       Expression ((Before LIMIT BY + (Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY))))))\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n       Expression\n         ReadFromRemote (Read from remote replica)\n explain select distinct on (k1, k2) v from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)); -- optimized\n@@ -28,7 +28,7 @@ Union\n   Expression (Projection)\n     LimitBy\n       Expression ((Before LIMIT BY + (Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY))))))\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n   ReadFromRemote (Read from remote replica)\n explain select distinct k1 from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)) order by v; -- not optimized\n Expression (Projection)\n@@ -38,7 +38,7 @@ Expression (Projection)\n         Sorting (Sorting for ORDER BY)\n           Distinct (Preliminary DISTINCT)\n             Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n         ReadFromRemote (Read from remote replica)\n explain select distinct k1, k2 from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)) order by v; -- optimized\n Expression (Projection)\n@@ -48,7 +48,7 @@ Expression (Projection)\n         Sorting (Sorting for ORDER BY)\n           Distinct (Preliminary DISTINCT)\n             Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n       ReadFromRemote (Read from remote replica)\n explain select distinct on (k1) k2 from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)) order by v; -- not optimized\n Expression (Projection)\n@@ -59,7 +59,7 @@ Expression (Projection)\n           Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))) [lifted up part])\n             Sorting (Sorting for ORDER BY)\n               Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))))\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n           ReadFromRemote (Read from remote replica)\n explain select distinct on (k1, k2) v from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)) order by v; -- optimized\n Expression (Projection)\n@@ -69,5 +69,5 @@ Expression (Projection)\n         Expression ((Before LIMIT BY + (Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))) [lifted up part]))\n           Sorting (Sorting for ORDER BY)\n             Expression ((Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY)))))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n       ReadFromRemote (Read from remote replica)\ndiff --git a/tests/queries/0_stateless/02050_client_profile_events.reference b/tests/queries/0_stateless/02050_client_profile_events.reference\nindex 99b0fa6c9811..bb22feab1574 100644\n--- a/tests/queries/0_stateless/02050_client_profile_events.reference\n+++ b/tests/queries/0_stateless/02050_client_profile_events.reference\n@@ -1,7 +1,7 @@\n do not print any ProfileEvents packets\n 0\n print only last (and also number of rows to provide more info in case of failures)\n-[ 0 ] SelectedRows: 131010 (increment)\n+[ 0 ] SelectedRows: 100000 (increment)\n regression test for incorrect filtering out snapshots\n 0\n regression test for overlap profile events snapshots between queries\ndiff --git a/tests/queries/0_stateless/02136_kill_scalar_queries.reference b/tests/queries/0_stateless/02136_kill_scalar_queries.reference\nindex a598447cff52..fad9fad21b96 100644\n--- a/tests/queries/0_stateless/02136_kill_scalar_queries.reference\n+++ b/tests/queries/0_stateless/02136_kill_scalar_queries.reference\n@@ -1,2 +1,1 @@\n finished\tdefault_TEST02132KILL_QUERY1\tdefault\tselect (SELECT max(number) from system.numbers) + 1;\n-finished\tdefault_TEST02132KILL_QUERY2\tdefault\tSELECT (SELECT number FROM system.numbers WHERE number = 1000000000000);\ndiff --git a/tests/queries/0_stateless/02136_kill_scalar_queries.sh b/tests/queries/0_stateless/02136_kill_scalar_queries.sh\nindex 382f6555c667..c8691b623601 100755\n--- a/tests/queries/0_stateless/02136_kill_scalar_queries.sh\n+++ b/tests/queries/0_stateless/02136_kill_scalar_queries.sh\n@@ -14,9 +14,4 @@ QUERY_1_ID=\"${CLICKHOUSE_DATABASE}_TEST02132KILL_QUERY1\"\n wait_for_query_to_start \"${QUERY_1_ID}\"\n ${CLICKHOUSE_CLIENT} --query=\"KILL QUERY WHERE query_id='${QUERY_1_ID}' SYNC\"\n \n-QUERY_2_ID=\"${CLICKHOUSE_DATABASE}_TEST02132KILL_QUERY2\"\n-(${CLICKHOUSE_CLIENT} --query_id=\"${QUERY_2_ID}\" --query='SELECT (SELECT number FROM system.numbers WHERE number = 1000000000000);'  2>&1 | grep -q \"Code: 394.\" || echo 'FAIL') &\n-wait_for_query_to_start \"${QUERY_2_ID}\"\n-${CLICKHOUSE_CLIENT} --query=\"KILL QUERY WHERE query_id='${QUERY_2_ID}' SYNC\"\n-\n wait\ndiff --git a/tests/queries/0_stateless/02136_scalar_progress.reference b/tests/queries/0_stateless/02136_scalar_progress.reference\nindex 5bb4f5640a8d..5378c52de895 100644\n--- a/tests/queries/0_stateless/02136_scalar_progress.reference\n+++ b/tests/queries/0_stateless/02136_scalar_progress.reference\n@@ -1,6 +1,6 @@\n < X-ClickHouse-Progress: {\"read_rows\":\"0\",\"read_bytes\":\"0\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"0\",\"result_bytes\":\"0\"}\r\n < X-ClickHouse-Progress: {\"read_rows\":\"65505\",\"read_bytes\":\"524040\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"0\",\"result_bytes\":\"0\"}\r\n-< X-ClickHouse-Progress: {\"read_rows\":\"131010\",\"read_bytes\":\"1048080\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"0\",\"result_bytes\":\"0\"}\r\n-< X-ClickHouse-Progress: {\"read_rows\":\"131011\",\"read_bytes\":\"1048081\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"0\",\"result_bytes\":\"0\"}\r\n-< X-ClickHouse-Progress: {\"read_rows\":\"131011\",\"read_bytes\":\"1048081\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"1\",\"result_bytes\":\"272\"}\r\n-< X-ClickHouse-Summary: {\"read_rows\":\"131011\",\"read_bytes\":\"1048081\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"1\",\"result_bytes\":\"272\"}\r\n+< X-ClickHouse-Progress: {\"read_rows\":\"100000\",\"read_bytes\":\"800000\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"0\",\"result_bytes\":\"0\"}\r\n+< X-ClickHouse-Progress: {\"read_rows\":\"100001\",\"read_bytes\":\"800001\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"0\",\"result_bytes\":\"0\"}\r\n+< X-ClickHouse-Progress: {\"read_rows\":\"100001\",\"read_bytes\":\"800001\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"1\",\"result_bytes\":\"272\"}\r\n+< X-ClickHouse-Summary: {\"read_rows\":\"100001\",\"read_bytes\":\"800001\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"100000\",\"result_rows\":\"1\",\"result_bytes\":\"272\"}\r\ndiff --git a/tests/queries/0_stateless/02136_scalar_read_rows_json.reference b/tests/queries/0_stateless/02136_scalar_read_rows_json.reference\nindex f83351252330..19857446e9cd 100644\n--- a/tests/queries/0_stateless/02136_scalar_read_rows_json.reference\n+++ b/tests/queries/0_stateless/02136_scalar_read_rows_json.reference\n@@ -17,8 +17,6 @@\n \n \t\"rows\": 1,\n \n-\t\"rows_before_limit_at_least\": 100,\n-\n \t\"statistics\":\n \t{\n \t\t\"rows_read\": 100,\n@@ -44,7 +42,7 @@\n \n \t\"statistics\":\n \t{\n-\t\t\"rows_read\": 131011,\n-\t\t\"bytes_read\": 1048081\n+\t\t\"rows_read\": 100001,\n+\t\t\"bytes_read\": 800001\n \t}\n }\ndiff --git a/tests/queries/0_stateless/02210_processors_profile_log_2.reference b/tests/queries/0_stateless/02210_processors_profile_log_2.reference\nindex b9a848131fd1..dfedb851e02d 100644\n--- a/tests/queries/0_stateless/02210_processors_profile_log_2.reference\n+++ b/tests/queries/0_stateless/02210_processors_profile_log_2.reference\n@@ -6,7 +6,7 @@ ExpressionTransform\t1000000\t8000000\t1000000\t8000000\n LazyOutputFormat\t1\t8\t0\t0\n LimitsCheckingTransform\t1\t8\t1\t8\n NullSource\t0\t0\t0\t0\n-NumbersMt\t0\t0\t1000000\t8000000\n+NumbersRange\t0\t0\t1000000\t8000000\n Resize\t1\t8\t1\t8\n Resize\t1\t8\t1\t8\n 1\ndiff --git a/tests/queries/0_stateless/02236_explain_pipeline_join.reference b/tests/queries/0_stateless/02236_explain_pipeline_join.reference\nindex 5d7a7bfc488a..73d0ca8cb5e6 100644\n--- a/tests/queries/0_stateless/02236_explain_pipeline_join.reference\n+++ b/tests/queries/0_stateless/02236_explain_pipeline_join.reference\n@@ -6,12 +6,12 @@ ExpressionTransform\n     ExpressionTransform\n       (Limit)\n       Limit\n-        (ReadFromStorage)\n-        Numbers 0 \u2192 1\n+        (ReadFromSystemNumbers)\n+        NumbersRange 0 \u2192 1\n     (Expression)\n     FillingRightJoinSide\n       ExpressionTransform\n         (Limit)\n         Limit\n-          (ReadFromStorage)\n-          Numbers 0 \u2192 1\n+          (ReadFromSystemNumbers)\n+          NumbersRange 0 \u2192 1\ndiff --git a/tests/queries/0_stateless/02343_aggregation_pipeline.reference b/tests/queries/0_stateless/02343_aggregation_pipeline.reference\nindex acb0368c3ccb..bf61eb6da0a8 100644\n--- a/tests/queries/0_stateless/02343_aggregation_pipeline.reference\n+++ b/tests/queries/0_stateless/02343_aggregation_pipeline.reference\n@@ -14,9 +14,8 @@ ExpressionTransform \u00d7 16\n             AggregatingTransform\n               (Expression)\n               ExpressionTransform\n-                (ReadFromStorage)\n-                Limit\n-                  Numbers 0 \u2192 1\n+                (ReadFromSystemNumbers)\n+                NumbersRange 0 \u2192 1\n explain pipeline select * from (select * from numbers_mt(1e8) group by number) group by number;\n (Expression)\n ExpressionTransform \u00d7 16\n@@ -31,8 +30,8 @@ ExpressionTransform \u00d7 16\n             AggregatingTransform \u00d7 16\n               (Expression)\n               ExpressionTransform \u00d7 16\n-                (ReadFromStorage)\n-                NumbersMt \u00d7 16 0 \u2192 1\n+                (ReadFromSystemNumbers)\n+                NumbersRange \u00d7 16 0 \u2192 1\n explain pipeline select * from (select * from numbers_mt(1e8) group by number) order by number;\n (Expression)\n ExpressionTransform\n@@ -48,8 +47,8 @@ ExpressionTransform\n               AggregatingTransform \u00d7 16\n                 (Expression)\n                 ExpressionTransform \u00d7 16\n-                  (ReadFromStorage)\n-                  NumbersMt \u00d7 16 0 \u2192 1\n+                  (ReadFromSystemNumbers)\n+                  NumbersRange \u00d7 16 0 \u2192 1\n explain pipeline select number from remote('127.0.0.{1,2,3}', system, numbers_mt) group by number settings distributed_aggregation_memory_efficient = 1;\n (Expression)\n ExpressionTransform \u00d7 16\n@@ -65,8 +64,8 @@ ExpressionTransform \u00d7 16\n                 AggregatingTransform \u00d7 16\n                   (Expression)\n                   ExpressionTransform \u00d7 16\n-                    (ReadFromStorage)\n-                    Numbers \u00d7 16 0 \u2192 1\n+                    (ReadFromSystemNumbers)\n+                    NumbersRange \u00d7 16 0 \u2192 1\n               (ReadFromRemote)\n explain pipeline select number from remote('127.0.0.{1,2,3}', system, numbers_mt) group by number settings distributed_aggregation_memory_efficient = 0;\n (Expression)\n@@ -81,8 +80,8 @@ ExpressionTransform \u00d7 16\n             AggregatingTransform \u00d7 16\n               (Expression)\n               ExpressionTransform \u00d7 16\n-                (ReadFromStorage)\n-                Numbers \u00d7 16 0 \u2192 1\n+                (ReadFromSystemNumbers)\n+                NumbersRange \u00d7 16 0 \u2192 1\n           (ReadFromRemote)\n -- { echoOn }\n \ndiff --git a/tests/queries/0_stateless/02350_views_max_insert_threads.sql b/tests/queries/0_stateless/02350_views_max_insert_threads.sql\nindex b8883a8d6e3a..25e0fdeadbaa 100644\n--- a/tests/queries/0_stateless/02350_views_max_insert_threads.sql\n+++ b/tests/queries/0_stateless/02350_views_max_insert_threads.sql\n@@ -7,7 +7,7 @@ drop table if exists t_mv;\n create table t (a UInt64) Engine = Null;\n create materialized view t_mv Engine = Null AS select now() as ts, max(a) from t group by ts;\n \n-insert into t select * from numbers_mt(10e6) settings max_threads = 16, max_insert_threads=16;\n+insert into t select * from numbers_mt(10e6) settings max_threads = 16, max_insert_threads=16, max_block_size=100000;\n system flush logs;\n \n select arrayUniq(thread_ids)>=16 from system.query_log where\ndiff --git a/tests/queries/0_stateless/02421_formats_with_totals_and_extremes.reference b/tests/queries/0_stateless/02421_formats_with_totals_and_extremes.reference\nindex ee8e589089c1..1e96bda15f3d 100644\nBinary files a/tests/queries/0_stateless/02421_formats_with_totals_and_extremes.reference and b/tests/queries/0_stateless/02421_formats_with_totals_and_extremes.reference differ\ndiff --git a/tests/queries/0_stateless/02494_query_cache_explain.reference b/tests/queries/0_stateless/02494_query_cache_explain.reference\nindex 690e75bca7c2..71e8d2beff0c 100644\n--- a/tests/queries/0_stateless/02494_query_cache_explain.reference\n+++ b/tests/queries/0_stateless/02494_query_cache_explain.reference\n@@ -2,20 +2,20 @@\n 1\n Expression ((Project names + (Projection + Change column names to column identifiers)))\n   Limit (preliminary LIMIT (without OFFSET))\n-    ReadFromStorage (SystemNumbers)\n+    ReadFromSystemNumbers\n Expression ((Project names + (Projection + Change column names to column identifiers)))\n   Limit (preliminary LIMIT (without OFFSET))\n-    ReadFromStorage (SystemNumbers)\n+    ReadFromSystemNumbers\n (Expression)\n ExpressionTransform\n   (Limit)\n   Limit\n-    (ReadFromStorage)\n-    Numbers 0 \u2192 1\n+    (ReadFromSystemNumbers)\n+    NumbersRange 0 \u2192 1\n (Expression)\n ExpressionTransform\n   (Limit)\n   Limit\n-    (ReadFromStorage)\n-    Numbers 0 \u2192 1\n+    (ReadFromSystemNumbers)\n+    NumbersRange 0 \u2192 1\n 1\ndiff --git a/tests/queries/0_stateless/02496_remove_redundant_sorting.reference b/tests/queries/0_stateless/02496_remove_redundant_sorting.reference\nindex ca1384fd177a..b318157835d3 100644\n--- a/tests/queries/0_stateless/02496_remove_redundant_sorting.reference\n+++ b/tests/queries/0_stateless/02496_remove_redundant_sorting.reference\n@@ -7,7 +7,7 @@ Expression (Projection)\n         Expression ((Before ORDER BY + Projection))\n           Sorting (Sorting for ORDER BY)\n             Expression (Before ORDER BY)\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n -- Enabled query_plan_remove_redundant_sorting\n -- ORDER BY removes ORDER BY clauses in subqueries\n -- query\n@@ -28,7 +28,7 @@ ORDER BY number ASC\n Expression (Projection)\n   Sorting (Sorting for ORDER BY)\n     Expression ((Before ORDER BY + (Projection + (Before ORDER BY + (Projection + Before ORDER BY)))))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -55,7 +55,7 @@ Expression (Projection)\n       Filling\n         Sorting (Sorting for ORDER BY)\n           Expression ((Before ORDER BY + (Projection + Before ORDER BY)))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -84,7 +84,7 @@ Expression (Projection)\n         Expression (Before LIMIT BY)\n           Sorting (Sorting for ORDER BY)\n             Expression ((Before ORDER BY + (Projection + Before ORDER BY)))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -119,11 +119,11 @@ Expression ((Projection + Before ORDER BY))\n     Expression ((Before JOIN + Projection))\n       Sorting (Sorting for ORDER BY)\n         Expression ((Before ORDER BY + (Projection + Before ORDER BY)))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n     Expression ((Joined actions + (Rename joined columns + Projection)))\n       Sorting (Sorting for ORDER BY)\n         Expression ((Before ORDER BY + (Projection + Before ORDER BY)))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\t2\n 0\t1\n@@ -165,9 +165,9 @@ Expression (Projection)\n     Expression (Before ORDER BY)\n       Join (JOIN FillRightFirst)\n         Expression ((Before JOIN + (Projection + (Before ORDER BY + (Projection + Before ORDER BY)))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n         Expression ((Joined actions + (Rename joined columns + (Projection + (Before ORDER BY + (Projection + Before ORDER BY))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\t0\n 0\t1\n@@ -197,7 +197,7 @@ GROUP BY number\n Expression ((Projection + Before ORDER BY))\n   Aggregating\n     Expression ((Before GROUP BY + (Projection + (Before ORDER BY + (Projection + Before ORDER BY)))))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -221,7 +221,7 @@ GROUP BY number\n Expression ((Projection + Before ORDER BY))\n   Aggregating\n     Expression ((Before GROUP BY + (Projection + (Before ORDER BY + (Projection + Before ORDER BY)))))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -239,7 +239,7 @@ FROM\n Expression ((Projection + Before ORDER BY))\n   Aggregating\n     Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 45\n -- check that optimization is applied recursively to subqueries as well\n@@ -264,7 +264,7 @@ Expression (Projection)\n     Expression ((Before ORDER BY + (Projection + Before ORDER BY)))\n       Aggregating\n         Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -290,7 +290,7 @@ Expression (Projection)\n     Expression ((Before ORDER BY + (Projection + Before ORDER BY)))\n       Aggregating\n         Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -320,7 +320,7 @@ Expression ((Projection + (Before ORDER BY + )))\n   Aggregating\n     Filter\n       Filter (( + (Before GROUP BY + (Projection + (Before ORDER BY + (Projection + Before ORDER BY))))))\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 2\n 1\n@@ -346,7 +346,7 @@ Expression (Projection)\n     Expression ((Before ORDER BY + (Projection + (Before ORDER BY + (Projection + Before ORDER BY)))))\n       Aggregating\n         Expression (Before GROUP BY)\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -467,7 +467,7 @@ Expression (Projection)\n       Expression (Projection)\n         Sorting (Sorting for ORDER BY)\n           Expression (Before ORDER BY)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\t0\n 1\t0\n@@ -496,7 +496,7 @@ Expression (Projection)\n     Expression (Projection)\n       Sorting (Sorting for ORDER BY)\n         Expression (Before ORDER BY)\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 9\t11\n 8\t10\ndiff --git a/tests/queries/0_stateless/02496_remove_redundant_sorting_analyzer.reference b/tests/queries/0_stateless/02496_remove_redundant_sorting_analyzer.reference\nindex ddc89a728219..ee2099c62ba9 100644\n--- a/tests/queries/0_stateless/02496_remove_redundant_sorting_analyzer.reference\n+++ b/tests/queries/0_stateless/02496_remove_redundant_sorting_analyzer.reference\n@@ -7,7 +7,7 @@ Expression (Project names)\n         Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + Project names))))\n           Sorting (Sorting for ORDER BY)\n             Expression ((Before ORDER BY + (Projection + Change column names to column identifiers)))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n -- Enabled query_plan_remove_redundant_sorting\n -- ORDER BY removes ORDER BY clauses in subqueries\n -- query\n@@ -28,7 +28,7 @@ ORDER BY number ASC\n Expression (Project names)\n   Sorting (Sorting for ORDER BY)\n     Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))))))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -55,7 +55,7 @@ Expression (Project names)\n       Filling\n         Sorting (Sorting for ORDER BY)\n           Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -84,7 +84,7 @@ Expression (Project names)\n         Expression (Before LIMIT BY)\n           Sorting (Sorting for ORDER BY)\n             Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -119,11 +119,11 @@ Expression ((Project names + (Projection + DROP unused columns after JOIN)))\n     Expression ((Change column names to column identifiers + Project names))\n       Sorting (Sorting for ORDER BY)\n         Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n     Expression ((Change column names to column identifiers + Project names))\n       Sorting (Sorting for ORDER BY)\n         Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\t2\n 0\t1\n@@ -165,9 +165,9 @@ Expression (Project names)\n     Expression ((Before ORDER BY + (Projection + DROP unused columns after JOIN)))\n       Join (JOIN FillRightFirst)\n         Expression ((Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n         Expression ((Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\t0\n 0\t1\n@@ -197,7 +197,7 @@ GROUP BY number\n Expression ((Project names + Projection))\n   Aggregating\n     Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers))))))))))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -223,7 +223,7 @@ Expression ((Project names + Projection))\n     Expression ((Before GROUP BY + (Change column names to column identifiers + Project names)))\n       Sorting (Sorting for ORDER BY)\n         Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -241,7 +241,7 @@ FROM\n Expression ((Project names + Projection))\n   Aggregating\n     Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers))))))\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n -- execute\n 45\n -- check that optimization is applied recursively to subqueries as well\n@@ -266,7 +266,7 @@ Expression (Project names)\n     Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + Projection)))))\n       Aggregating\n         Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers))))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -294,7 +294,7 @@ Expression (Project names)\n         Expression ((Before GROUP BY + (Change column names to column identifiers + Project names)))\n           Sorting (Sorting for ORDER BY)\n             Expression ((Before ORDER BY + (Projection + Change column names to column identifiers)))\n-              ReadFromStorage (SystemNumbers)\n+              ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -326,7 +326,7 @@ Expression ((Project names + Projection))\n       Expression ((Before GROUP BY + (Change column names to column identifiers + Project names)))\n         Sorting (Sorting for ORDER BY)\n           Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + Change column names to column identifiers)))))))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 2\n 1\n@@ -352,7 +352,7 @@ Expression (Project names)\n     Expression ((Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + (Projection + (Change column names to column identifiers + (Project names + (Before ORDER BY + Projection))))))))))\n       Aggregating\n         Expression ((Before GROUP BY + Change column names to column identifiers))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -477,7 +477,7 @@ Expression (Project names)\n               Expression (Before ORDER BY)\n                 Expression (Projection)\n                   Expression (Change column names to column identifiers)\n-                    ReadFromStorage (SystemNumbers)\n+                    ReadFromSystemNumbers\n -- execute\n 0\t0\n 1\t0\n@@ -509,7 +509,7 @@ Expression (Project names)\n           Expression (Before ORDER BY)\n             Expression (Projection)\n               Expression (Change column names to column identifiers)\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n -- execute\n 9\t11\n 8\t10\ndiff --git a/tests/queries/0_stateless/02500_remove_redundant_distinct.reference b/tests/queries/0_stateless/02500_remove_redundant_distinct.reference\nindex 763a7cc42866..3f580763dba8 100644\n--- a/tests/queries/0_stateless/02500_remove_redundant_distinct.reference\n+++ b/tests/queries/0_stateless/02500_remove_redundant_distinct.reference\n@@ -9,7 +9,7 @@ Expression (Projection)\n               Distinct\n                 Distinct (Preliminary DISTINCT)\n                   Expression (Before ORDER BY)\n-                    ReadFromStorage (SystemNumbers)\n+                    ReadFromSystemNumbers\n -- Enabled query_plan_remove_redundant_distinct\n -- DISTINCT is only in most inner subquery\n -- query\n@@ -28,7 +28,7 @@ Expression ((Projection + (Before ORDER BY + (Projection + (Before ORDER BY + Pr\n   Distinct\n     Distinct (Preliminary DISTINCT)\n       Expression (Before ORDER BY)\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -52,12 +52,12 @@ Expression (Projection)\n             Distinct\n               Distinct (Preliminary DISTINCT)\n                 Expression (Before ORDER BY)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n           Expression (( + Projection))\n             Distinct\n               Distinct (Preliminary DISTINCT)\n                 Expression (Before ORDER BY)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -83,12 +83,12 @@ Expression (Projection)\n             Distinct\n               Distinct (Preliminary DISTINCT)\n                 Expression (Before ORDER BY)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n           Expression ((Joined actions + (Rename joined columns + Projection)))\n             Distinct\n               Distinct (Preliminary DISTINCT)\n                 Expression (Before ORDER BY)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 0\t0\n 0\t1\n@@ -111,7 +111,7 @@ Expression ((Projection + (Before ORDER BY + (Projection + (Before ORDER BY + Pr\n   Distinct\n     Distinct (Preliminary DISTINCT)\n       Expression (Before ORDER BY)\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 0\t0\n 1\t2\n@@ -133,7 +133,7 @@ Expression ((Projection + (Before ORDER BY + (Projection + (Before ORDER BY + Pr\n   Distinct\n     Distinct (Preliminary DISTINCT)\n       Expression (Before ORDER BY)\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 2\t0\t0\n 2\t1\t2\n@@ -229,9 +229,9 @@ Expression ((Projection + (Before ORDER BY + (Projection + Before ORDER BY))))\n     Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n       Join (JOIN FillRightFirst)\n         Expression (Before JOIN)\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n         Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -262,9 +262,9 @@ Expression (Projection)\n           Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n             Join (JOIN FillRightFirst)\n               Expression (Before JOIN)\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n               Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n -- execute\n 12\n -- GROUP BY WITH ROLLUP before DISTINCT with on different columns => do _not_ remove DISTINCT\n@@ -294,9 +294,9 @@ Expression (Projection)\n             Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n               Join (JOIN FillRightFirst)\n                 Expression (Before JOIN)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n                 Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 12\n 36\n@@ -324,9 +324,9 @@ Expression ((Projection + (Before ORDER BY + (Projection + Before ORDER BY))))\n       Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n         Join (JOIN FillRightFirst)\n           Expression (Before JOIN)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n           Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -359,9 +359,9 @@ Expression (Projection)\n             Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n               Join (JOIN FillRightFirst)\n                 Expression (Before JOIN)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n                 Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 12\n 36\n@@ -389,9 +389,9 @@ Expression ((Projection + (Before ORDER BY + (Projection + Before ORDER BY))))\n       Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n         Join (JOIN FillRightFirst)\n           Expression (Before JOIN)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n           Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -424,9 +424,9 @@ Expression (Projection)\n             Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n               Join (JOIN FillRightFirst)\n                 Expression (Before JOIN)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n                 Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 12\n \n@@ -455,9 +455,9 @@ Expression ((Projection + (Before ORDER BY + (Projection + Before ORDER BY))))\n       Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\n         Join (JOIN FillRightFirst)\n           Expression (Before JOIN)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n           Expression ((Joined actions + (Rename joined columns + (Projection + Before ORDER BY))))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -474,7 +474,7 @@ Expression (Projection)\n       Expression (Before ORDER BY)\n         Aggregating\n           Expression (Before GROUP BY)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 1\n -- UNION ALL with DISTINCT => do _not_ remove DISTINCT\n@@ -497,12 +497,12 @@ Expression (Projection)\n           Distinct\n             Distinct (Preliminary DISTINCT)\n               Expression (Before ORDER BY)\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n         Expression (( + Projection))\n           Distinct\n             Distinct (Preliminary DISTINCT)\n               Expression (Before ORDER BY)\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n -- execute\n 0\n 1\ndiff --git a/tests/queries/0_stateless/02500_remove_redundant_distinct_analyzer.reference b/tests/queries/0_stateless/02500_remove_redundant_distinct_analyzer.reference\nindex 50ca5981cf12..a5f2c3e5ca3d 100644\n--- a/tests/queries/0_stateless/02500_remove_redundant_distinct_analyzer.reference\n+++ b/tests/queries/0_stateless/02500_remove_redundant_distinct_analyzer.reference\n@@ -9,7 +9,7 @@ Expression (Project names)\n               Distinct (DISTINCT)\n                 Distinct (Preliminary DISTINCT)\n                   Expression ((Projection + Change column names to column identifiers))\n-                    ReadFromStorage (SystemNumbers)\n+                    ReadFromSystemNumbers\n -- Enabled query_plan_remove_redundant_distinct\n -- DISTINCT is only in most inner subquery\n -- query\n@@ -28,7 +28,7 @@ Expression ((Project names + (Projection + (Change column names to column identi\n   Distinct (DISTINCT)\n     Distinct (Preliminary DISTINCT)\n       Expression ((Projection + Change column names to column identifiers))\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -53,12 +53,12 @@ Expression (Project names)\n               Distinct (DISTINCT)\n                 Distinct (Preliminary DISTINCT)\n                   Expression ((Projection + Change column names to column identifiers))\n-                    ReadFromStorage (SystemNumbers)\n+                    ReadFromSystemNumbers\n             Expression (( + ( + Project names)))\n               Distinct (DISTINCT)\n                 Distinct (Preliminary DISTINCT)\n                   Expression ((Projection + Change column names to column identifiers))\n-                    ReadFromStorage (SystemNumbers)\n+                    ReadFromSystemNumbers\n -- execute\n 0\n 1\n@@ -84,12 +84,12 @@ Expression (Project names)\n             Distinct (DISTINCT)\n               Distinct (Preliminary DISTINCT)\n                 Expression ((Projection + Change column names to column identifiers))\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n           Expression ((Change column names to column identifiers + Project names))\n             Distinct (DISTINCT)\n               Distinct (Preliminary DISTINCT)\n                 Expression ((Projection + Change column names to column identifiers))\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 0\t0\n 0\t1\n@@ -112,7 +112,7 @@ Expression ((Project names + (Projection + (Change column names to column identi\n   Distinct (DISTINCT)\n     Distinct (Preliminary DISTINCT)\n       Expression ((Projection + Change column names to column identifiers))\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 0\t0\n 1\t2\n@@ -134,7 +134,7 @@ Expression ((Project names + (Projection + (Change column names to column identi\n   Distinct (DISTINCT)\n     Distinct (Preliminary DISTINCT)\n       Expression ((Projection + Change column names to column identifiers))\n-        ReadFromStorage (SystemNumbers)\n+        ReadFromSystemNumbers\n -- execute\n 2\t0\t0\n 2\t1\t2\n@@ -231,9 +231,9 @@ Expression ((Project names + (Projection + (Change column names to column identi\n     Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n       Join (JOIN FillRightFirst)\n         Expression (Change column names to column identifiers)\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n         Expression (Change column names to column identifiers)\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -264,9 +264,9 @@ Expression (Project names)\n           Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n             Join (JOIN FillRightFirst)\n               Expression (Change column names to column identifiers)\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n               Expression (Change column names to column identifiers)\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n -- execute\n 12\n -- GROUP BY WITH ROLLUP before DISTINCT with on different columns => do _not_ remove DISTINCT\n@@ -296,9 +296,9 @@ Expression (Project names)\n             Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n               Join (JOIN FillRightFirst)\n                 Expression (Change column names to column identifiers)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n                 Expression (Change column names to column identifiers)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 12\n 36\n@@ -326,9 +326,9 @@ Expression ((Project names + (Projection + (Change column names to column identi\n       Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n         Join (JOIN FillRightFirst)\n           Expression (Change column names to column identifiers)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n           Expression (Change column names to column identifiers)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -361,9 +361,9 @@ Expression (Project names)\n             Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n               Join (JOIN FillRightFirst)\n                 Expression (Change column names to column identifiers)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n                 Expression (Change column names to column identifiers)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 12\n 36\n@@ -391,9 +391,9 @@ Expression ((Project names + (Projection + (Change column names to column identi\n       Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n         Join (JOIN FillRightFirst)\n           Expression (Change column names to column identifiers)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n           Expression (Change column names to column identifiers)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -426,9 +426,9 @@ Expression (Project names)\n             Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n               Join (JOIN FillRightFirst)\n                 Expression (Change column names to column identifiers)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n                 Expression (Change column names to column identifiers)\n-                  ReadFromStorage (SystemNumbers)\n+                  ReadFromSystemNumbers\n -- execute\n 12\n \n@@ -457,9 +457,9 @@ Expression ((Project names + (Projection + (Change column names to column identi\n       Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + DROP unused columns after JOIN)))))\n         Join (JOIN FillRightFirst)\n           Expression (Change column names to column identifiers)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n           Expression (Change column names to column identifiers)\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 0\n 2\n@@ -476,7 +476,7 @@ Expression (Project names)\n       Expression (Projection)\n         Aggregating\n           Expression ((Before GROUP BY + Change column names to column identifiers))\n-            ReadFromStorage (SystemNumbers)\n+            ReadFromSystemNumbers\n -- execute\n 1\n -- UNION ALL with DISTINCT => do _not_ remove DISTINCT\n@@ -499,12 +499,12 @@ Expression (Project names)\n           Distinct (DISTINCT)\n             Distinct (Preliminary DISTINCT)\n               Expression ((Projection + Change column names to column identifiers))\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n         Expression (( + ( + Project names)))\n           Distinct (DISTINCT)\n             Distinct (Preliminary DISTINCT)\n               Expression ((Projection + Change column names to column identifiers))\n-                ReadFromStorage (SystemNumbers)\n+                ReadFromSystemNumbers\n -- execute\n 0\n 1\ndiff --git a/tests/queries/0_stateless/02514_analyzer_drop_join_on.reference b/tests/queries/0_stateless/02514_analyzer_drop_join_on.reference\nindex 1b177b84afa8..51e009dcd912 100644\n--- a/tests/queries/0_stateless/02514_analyzer_drop_join_on.reference\n+++ b/tests/queries/0_stateless/02514_analyzer_drop_join_on.reference\n@@ -147,5 +147,5 @@ Header: bx String\n                       c2 String\n         Expression ((JOIN actions + (Change column names to column identifiers + (Project names + (Projection + Change column names to column identifiers)))))\n         Header: d1_4 UInt64\n-          ReadFromStorage (SystemNumbers)\n+          ReadFromSystemNumbers\n           Header: number UInt64\ndiff --git a/tests/queries/0_stateless/02576_predicate_push_down_sorting_fix.reference b/tests/queries/0_stateless/02576_predicate_push_down_sorting_fix.reference\nindex 3d169126eef5..b8c68f90135d 100644\n--- a/tests/queries/0_stateless/02576_predicate_push_down_sorting_fix.reference\n+++ b/tests/queries/0_stateless/02576_predicate_push_down_sorting_fix.reference\n@@ -18,5 +18,5 @@ Positions: 1\n              ALIAS number :: 0 -> number_1 UInt64 : 2\n              FUNCTION ignore(2_UInt8 :: 1) -> ignore(2_UInt8) UInt8 : 0\n     Positions: 0 2\n-      ReadFromStorage (SystemNumbers)\n+      ReadFromSystemNumbers\n       Header: number UInt64\ndiff --git a/tests/queries/0_stateless/02767_into_outfile_extensions_msan.reference b/tests/queries/0_stateless/02767_into_outfile_extensions_msan.reference\nindex 0c8b489c2fd0..50955368998c 100644\n--- a/tests/queries/0_stateless/02767_into_outfile_extensions_msan.reference\n+++ b/tests/queries/0_stateless/02767_into_outfile_extensions_msan.reference\n@@ -1,2 +1,2 @@\n Expression ((Projection + Before ORDER BY))\n-  ReadFromStorage (SystemNumbers)\n+  ReadFromSystemNumbers\n",
  "problem_statement": "Use `number` as an index for `system.numbers`\n**Use case**\r\n\r\nPeople want to write queries as follows:\r\n```\r\nSELECT number FROM system.numbers WHERE number BETWEEN 10 AND 100;\r\nSELECT number FROM system.numbers WHERE number IN (123, 456);\r\n```\r\nand expect the query to be smart enough to read only requested ranges.\r\n\r\n**Describe the solution you'd like**\r\n\r\nDetermine ranges by `KeyCondition`.\n",
  "hints_text": "",
  "created_at": "2023-06-13T07:34:43Z",
  "modified_files": [
    "docs/en/operations/system-tables/numbers.md",
    "docs/en/sql-reference/statements/explain.md",
    "docs/en/sql-reference/table-functions/numbers.md",
    "docs/ru/sql-reference/statements/explain.md",
    "b/src/Core/PlainRanges.cpp",
    "b/src/Core/PlainRanges.h",
    "src/Core/Range.cpp",
    "src/Core/Range.h",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Interpreters/InterpreterSelectQuery.h",
    "src/Interpreters/Set.h",
    "src/Planner/CollectSets.cpp",
    "src/Planner/PlannerContext.h",
    "b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp",
    "b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h",
    "src/Storages/MergeTree/KeyCondition.cpp",
    "src/Storages/MergeTree/KeyCondition.h",
    "src/Storages/StorageExecutable.cpp",
    "src/Storages/System/StorageSystemNumbers.cpp",
    "src/Storages/System/StorageSystemNumbers.h",
    "src/TableFunctions/TableFunctionNumbers.cpp"
  ],
  "modified_test_files": [
    "tests/integration/test_grpc_protocol/test.py",
    "b/tests/integration/test_storage_numbers/test.py",
    "tests/queries/0_stateless/00344_row_number_in_all_blocks.sql",
    "tests/queries/0_stateless/00416_pocopatch_progress_in_http_headers.reference",
    "tests/queries/0_stateless/01472_many_rows_in_totals.reference",
    "tests/queries/0_stateless/01553_settings_early_apply.reference",
    "tests/queries/0_stateless/01591_window_functions.reference",
    "tests/queries/0_stateless/01722_long_brotli_http_compression_json_format.reference",
    "tests/queries/0_stateless/01746_long_zlib_http_compression_json_format.reference",
    "tests/queries/0_stateless/01746_long_zstd_http_compression_json_format.reference",
    "tests/queries/0_stateless/01883_with_grouping_sets.reference",
    "tests/queries/0_stateless/01951_distributed_push_down_limit.reference",
    "tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference",
    "tests/queries/0_stateless/02050_client_profile_events.reference",
    "tests/queries/0_stateless/02136_kill_scalar_queries.reference",
    "tests/queries/0_stateless/02136_kill_scalar_queries.sh",
    "tests/queries/0_stateless/02136_scalar_progress.reference",
    "tests/queries/0_stateless/02136_scalar_read_rows_json.reference",
    "tests/queries/0_stateless/02210_processors_profile_log_2.reference",
    "tests/queries/0_stateless/02236_explain_pipeline_join.reference",
    "tests/queries/0_stateless/02343_aggregation_pipeline.reference",
    "tests/queries/0_stateless/02350_views_max_insert_threads.sql",
    "tests/queries/0_stateless/02494_query_cache_explain.reference",
    "tests/queries/0_stateless/02496_remove_redundant_sorting.reference",
    "tests/queries/0_stateless/02496_remove_redundant_sorting_analyzer.reference",
    "tests/queries/0_stateless/02500_remove_redundant_distinct.reference",
    "tests/queries/0_stateless/02500_remove_redundant_distinct_analyzer.reference",
    "tests/queries/0_stateless/02514_analyzer_drop_join_on.reference",
    "tests/queries/0_stateless/02576_predicate_push_down_sorting_fix.reference",
    "tests/queries/0_stateless/02767_into_outfile_extensions_msan.reference"
  ]
}