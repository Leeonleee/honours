diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md
index d85092d683af..234e801de4eb 100644
--- a/docs/en/sql-reference/functions/array-functions.md
+++ b/docs/en/sql-reference/functions/array-functions.md
@@ -1392,6 +1392,12 @@ Returns the first element in the `arr1` array for which `func` returns something
 
 Note that the `arrayFirst` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can’t be omitted.
 
+## arrayLast(func, arr1, …) {#array-last}
+
+Returns the last element in the `arr1` array for which `func` returns something other than 0.
+
+Note that the `arrayLast` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You must pass a lambda function to it as the first argument, and it can’t be omitted.
+
 ## arrayFirstIndex(func, arr1, …) {#array-first-index}
 
 Returns the index of the first element in the `arr1` array for which `func` returns something other than 0.
diff --git a/src/Functions/array/arrayFirst.cpp b/src/Functions/array/arrayFirst.cpp
index dbe545ea3875..edbf7ef6269c 100644
--- a/src/Functions/array/arrayFirst.cpp
+++ b/src/Functions/array/arrayFirst.cpp
@@ -11,7 +11,14 @@ namespace ErrorCodes
     extern const int ILLEGAL_COLUMN;
 }
 
-struct ArrayFirstImpl
+enum class ArrayFirstLastStrategy
+{
+    First,
+    Last
+};
+
+template <ArrayFirstLastStrategy strategy>
+struct ArrayFirstLastImpl
 {
     static bool needBoolean() { return false; }
     static bool needExpression() { return true; }
@@ -40,15 +47,23 @@ struct ArrayFirstImpl
                 auto out = data.cloneEmpty();
                 out->reserve(data.size());
 
-                size_t pos{};
-                for (auto offset : offsets)
+                size_t offsets_size = offsets.size();
+                for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)
                 {
-                    if (offset - pos > 0)
-                        out->insert(data[pos]);
+                    size_t start_offset = offsets[offset_index - 1];
+                    size_t end_offset = offsets[offset_index];
+
+                    if (end_offset > start_offset)
+                    {
+                        if constexpr (strategy == ArrayFirstLastStrategy::First)
+                            out->insert(data[start_offset]);
+                        else
+                            out->insert(data[end_offset - 1]);
+                    }
                     else
+                    {
                         out->insertDefault();
-
-                    pos = offset;
+                    }
                 }
 
                 return out;
@@ -67,18 +82,36 @@ struct ArrayFirstImpl
         auto out = data.cloneEmpty();
         out->reserve(data.size());
 
-        size_t pos{};
-        for (auto offset : offsets)
+        size_t offsets_size = offsets.size();
+        for (size_t offset_index = 0; offset_index < offsets_size; ++offset_index)
         {
-            auto exists = false;
-            for (; pos < offset; ++pos)
+            size_t start_offset = offsets[offset_index - 1];
+            size_t end_offset = offsets[offset_index];
+
+            bool exists = false;
+
+            if constexpr (strategy == ArrayFirstLastStrategy::First)
             {
-                if (filter[pos])
+                for (; start_offset != end_offset; ++start_offset)
                 {
-                    out->insert(data[pos]);
-                    exists = true;
-                    pos = offset;
-                    break;
+                    if (filter[start_offset])
+                    {
+                        out->insert(data[start_offset]);
+                        exists = true;
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                for (; end_offset != start_offset; --end_offset)
+                {
+                    if (filter[end_offset - 1])
+                    {
+                        out->insert(data[end_offset - 1]);
+                        exists = true;
+                        break;
+                    }
                 }
             }
 
@@ -91,11 +124,17 @@ struct ArrayFirstImpl
 };
 
 struct NameArrayFirst { static constexpr auto name = "arrayFirst"; };
+using ArrayFirstImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::First>;
 using FunctionArrayFirst = FunctionArrayMapped<ArrayFirstImpl, NameArrayFirst>;
 
+struct NameArrayLast { static constexpr auto name = "arrayLast"; };
+using ArrayLastImpl = ArrayFirstLastImpl<ArrayFirstLastStrategy::Last>;
+using FunctionArrayLast = FunctionArrayMapped<ArrayLastImpl, NameArrayLast>;
+
 void registerFunctionArrayFirst(FunctionFactory & factory)
 {
     factory.registerFunction<FunctionArrayFirst>();
+    factory.registerFunction<FunctionArrayLast>();
 }
 
 }
