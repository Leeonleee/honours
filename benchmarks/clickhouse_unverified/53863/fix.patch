diff --git a/docs/en/operations/utilities/clickhouse-local.md b/docs/en/operations/utilities/clickhouse-local.md
index 0b17afb7e12d..737c2b81deef 100644
--- a/docs/en/operations/utilities/clickhouse-local.md
+++ b/docs/en/operations/utilities/clickhouse-local.md
@@ -30,7 +30,7 @@ curl https://clickhouse.com/ | sh
 The binary you just downloaded can run all sorts of ClickHouse tools and utilities. If you want to run ClickHouse as a database server, check out the [Quick Start](../../quick-start.mdx).
 :::
 
-## Query data in a CSV file using SQL
+## Query data in a file using SQL {#query_data_in_file}
 
 A common use of `clickhouse-local` is to run ad-hoc queries on files: where you don't have to insert the data into a table. `clickhouse-local` can stream the data from a file into a temporary table and execute your SQL.
 
@@ -57,6 +57,19 @@ The `file` table function creates a table, and you can use `DESCRIBE` to see the
 ./clickhouse local -q "DESCRIBE file('reviews.tsv')"
 ```
 
+:::tip
+You are allowed to use globs in file name (See [glob substitutions](/docs/en/sql-reference/table-functions/file.md/#globs-in-path)).
+
+Examples:
+
+```bash
+./clickhouse local -q "SELECT * FROM 'reviews*.jsonl'"
+./clickhouse local -q "SELECT * FROM 'review_?.csv'"
+./clickhouse local -q "SELECT * FROM 'review_{1..3}.csv'"
+```
+
+:::
+
 ```response
 marketplace	Nullable(String)
 customer_id	Nullable(Int64)
diff --git a/docs/ru/operations/utilities/clickhouse-local.md b/docs/ru/operations/utilities/clickhouse-local.md
index 61fba2dd7cc8..8851be326d41 100644
--- a/docs/ru/operations/utilities/clickhouse-local.md
+++ b/docs/ru/operations/utilities/clickhouse-local.md
@@ -110,3 +110,42 @@ Read 186 rows, 4.15 KiB in 0.035 sec., 5302 rows/sec., 118.34 KiB/sec.
 ├──────────┼──────────┤
 ...
 ```
+
+## Запрос данных в файле с помощью SQL {#query_data_in_file}
+
+Часто `clickhouse-local` используется для выполнения специальных запросов к файлам, когда не нужно вставлять данные в таблицу. `clickhouse-local` может транслировать данные из файла во временную таблицу и выполнить ваш SQL.
+
+Если файл находится на той же машине, что и `clickhouse-local`, то можно просто указать файл для загрузки. Следующий файл `reviews.tsv` содержит выборку отзывов о товарах Amazon:
+
+```bash
+./clickhouse local -q "SELECT * FROM 'reviews.tsv'"
+```
+
+Эта команда является сокращением команды:
+
+```bash
+./clickhouse local -q "SELECT * FROM file('reviews.tsv')"
+```
+
+ClickHouse знает, что файл использует формат, разделенный табуляцией, из расширения имени файла. Если необходимо явно указать формат, просто добавьте один из [множества входных форматов ClickHouse](../../interfaces/formats.md):
+
+```bash
+./clickhouse local -q "SELECT * FROM file('reviews.tsv', 'TabSeparated')"
+```
+
+Функция таблицы `file` создает таблицу, и вы можете использовать `DESCRIBE` для просмотра предполагаемой схемы:
+
+```bash
+./clickhouse local -q "DESCRIBE file('reviews.tsv')"
+```
+
+:::tip
+В имени файла разрешается использовать [Шаблоны поиска](/docs/ru/sql-reference/table-functions/file.md/#globs-in-path).
+
+Примеры:
+
+```bash
+./clickhouse local -q "SELECT * FROM 'reviews*.jsonl'"
+./clickhouse local -q "SELECT * FROM 'review_?.csv'"
+./clickhouse local -q "SELECT * FROM 'review_{1..3}.csv'"
+```
diff --git a/src/Common/StringUtils/StringUtils.h b/src/Common/StringUtils/StringUtils.h
index 8e8df19adeee..2c9331a43e25 100644
--- a/src/Common/StringUtils/StringUtils.h
+++ b/src/Common/StringUtils/StringUtils.h
@@ -318,3 +318,8 @@ inline void trim(std::string & str, char c = ' ')
     trimRight(str, c);
     trimLeft(str, c);
 }
+
+constexpr bool containsGlobs(const std::string & str)
+{
+    return str.find_first_of("*?{") != std::string::npos;
+}
diff --git a/src/Databases/DatabaseFilesystem.cpp b/src/Databases/DatabaseFilesystem.cpp
index 59f9ee67d7bd..49f260034db2 100644
--- a/src/Databases/DatabaseFilesystem.cpp
+++ b/src/Databases/DatabaseFilesystem.cpp
@@ -81,22 +81,24 @@ bool DatabaseFilesystem::checkTableFilePath(const std::string & table_path, Cont
         throw Exception(ErrorCodes::PATH_ACCESS_DENIED, "File is not inside {}", user_files_path);
     }
 
-    /// Check if the corresponding file exists.
-    if (!fs::exists(table_path))
+    if (!containsGlobs(table_path))
     {
-        if (throw_on_error)
-            throw Exception(ErrorCodes::FILE_DOESNT_EXIST, "File does not exist: {}", table_path);
-        else
-            return false;
-    }
-
-    if (!fs::is_regular_file(table_path))
-    {
-        if (throw_on_error)
-            throw Exception(ErrorCodes::FILE_DOESNT_EXIST,
-                            "File is directory, but expected a file: {}", table_path);
-        else
-            return false;
+        /// Check if the corresponding file exists.
+        if (!fs::exists(table_path))
+        {
+            if (throw_on_error)
+                throw Exception(ErrorCodes::FILE_DOESNT_EXIST, "File does not exist: {}", table_path);
+            else
+                return false;
+        }
+
+        if (!fs::is_regular_file(table_path))
+        {
+            if (throw_on_error)
+                throw Exception(ErrorCodes::FILE_DOESNT_EXIST, "File is directory, but expected a file: {}", table_path);
+            else
+                return false;
+        }
     }
 
     return true;
@@ -141,19 +143,18 @@ StoragePtr DatabaseFilesystem::getTableImpl(const String & name, ContextPtr cont
     if (!checkTableFilePath(table_path, context_, throw_on_error))
         return {};
 
-    String format = FormatFactory::instance().getFormatFromFileName(table_path, throw_on_error);
+    auto format = FormatFactory::instance().getFormatFromFileName(table_path, throw_on_error);
     if (format.empty())
         return {};
 
-    /// If the file exists, create a new table using TableFunctionFile and return it.
-    auto args = makeASTFunction("file", std::make_shared<ASTLiteral>(table_path), std::make_shared<ASTLiteral>(format));
+    auto ast_function_ptr = makeASTFunction("file", std::make_shared<ASTLiteral>(table_path), std::make_shared<ASTLiteral>(format));
 
-    auto table_function = TableFunctionFactory::instance().get(args, context_);
+    auto table_function = TableFunctionFactory::instance().get(ast_function_ptr, context_);
     if (!table_function)
         return nullptr;
 
     /// TableFunctionFile throws exceptions, if table cannot be created.
-    auto table_storage = table_function->execute(args, context_, name);
+    auto table_storage = table_function->execute(ast_function_ptr, context_, name);
     if (table_storage)
         addTable(name, table_storage);
 
