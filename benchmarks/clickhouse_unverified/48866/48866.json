{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48866,
  "instance_id": "ClickHouse__ClickHouse-48866",
  "issue_numbers": [
    "48848"
  ],
  "base_commit": "ba5ca15c408025ea33be44583ec0ddcc3f7c26d9",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 9d2f89c1837e..fbf1904bd1e6 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -18,7 +18,7 @@ empty([x])\n \n An array is considered empty if it does not contain any elements.\n \n-:::note    \n+:::note\n Can be optimized by enabling the [optimize_functions_to_subcolumns](../../operations/settings/settings.md#optimize-functions-to-subcolumns) setting. With `optimize_functions_to_subcolumns = 1` the function reads only [size0](../../sql-reference/data-types/array.md#array-size) subcolumn instead of reading and processing the whole array column. The query `SELECT empty(arr) FROM TABLE;` transforms to `SELECT arr.size0 = 0 FROM TABLE;`.\n :::\n \n@@ -26,11 +26,11 @@ The function also works for [strings](string-functions.md#empty) or [UUID](uuid-\n \n **Arguments**\n \n--   `[x]` \u2014 Input array. [Array](../data-types/array.md).\n+- `[x]` \u2014 Input array. [Array](../data-types/array.md).\n \n **Returned value**\n \n--   Returns `1` for an empty array or `0` for a non-empty array.\n+- Returns `1` for an empty array or `0` for a non-empty array.\n \n Type: [UInt8](../data-types/int-uint.md).\n \n@@ -62,7 +62,7 @@ notEmpty([x])\n \n An array is considered non-empty if it contains at least one element.\n \n-:::note    \n+:::note\n Can be optimized by enabling the [optimize_functions_to_subcolumns](../../operations/settings/settings.md#optimize-functions-to-subcolumns) setting. With `optimize_functions_to_subcolumns = 1` the function reads only [size0](../../sql-reference/data-types/array.md#array-size) subcolumn instead of reading and processing the whole array column. The query `SELECT notEmpty(arr) FROM table` transforms to `SELECT arr.size0 != 0 FROM TABLE`.\n :::\n \n@@ -70,11 +70,11 @@ The function also works for [strings](string-functions.md#notempty) or [UUID](uu\n \n **Arguments**\n \n--   `[x]` \u2014 Input array. [Array](../data-types/array.md).\n+- `[x]` \u2014 Input array. [Array](../data-types/array.md).\n \n **Returned value**\n \n--   Returns `1` for a non-empty array or `0` for an empty array.\n+- Returns `1` for a non-empty array or `0` for an empty array.\n \n Type: [UInt8](../data-types/int-uint.md).\n \n@@ -118,38 +118,41 @@ Accepts zero arguments and returns an empty array of the appropriate type.\n \n Accepts an empty array and returns a one-element array that is equal to the default value.\n \n-\n ## range(end), range(\\[start, \\] end \\[, step\\])\n \n Returns an array of numbers from `start` to `end - 1` by `step`. The supported types are [UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64](../data-types/int-uint.md).\n \n **Syntax**\n+\n ``` sql\n range([start, ] end [, step])\n ```\n \n **Arguments**\n \n--   `start` \u2014 The first element of the array. Optional, required if `step` is used. Default value: 0.\n--   `end` \u2014 The number before which the array is constructed. Required.\n--   `step` \u2014 Determines the incremental step between each element in the array. Optional. Default value: 1.\n+- `start` \u2014 The first element of the array. Optional, required if `step` is used. Default value: 0.\n+- `end` \u2014 The number before which the array is constructed. Required.\n+- `step` \u2014 Determines the incremental step between each element in the array. Optional. Default value: 1.\n \n **Returned value**\n \n--   Array of numbers from `start` to `end - 1` by `step`.\n+- Array of numbers from `start` to `end - 1` by `step`.\n \n **Implementation details**\n \n--   All arguments `start`, `end`, `step` must be below data types: `UInt8`, `UInt16`, `UInt32`, `UInt64`,`Int8`, `Int16`, `Int32`, `Int64`, as well as elements of the returned array, which's type is a super type of all arguments's.\n--   An exception is thrown if query results in arrays with a total length of more than number of elements specified by the [function_range_max_elements_in_block](../../operations/settings/settings.md#settings-function_range_max_elements_in_block) setting.\n+- All arguments `start`, `end`, `step` must be below data types: `UInt8`, `UInt16`, `UInt32`, `UInt64`,`Int8`, `Int16`, `Int32`, `Int64`, as well as elements of the returned array, which's type is a super type of all arguments's.\n+- An exception is thrown if query results in arrays with a total length of more than number of elements specified by the [function_range_max_elements_in_block](../../operations/settings/settings.md#settings-function_range_max_elements_in_block) setting.\n \n **Examples**\n \n Query:\n+\n ``` sql\n SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);\n ```\n+\n Result:\n+\n ```txt\n \u250c\u2500range(5)\u2500\u2500\u2500\u2500\u252c\u2500range(1, 5)\u2500\u252c\u2500range(1, 5, 2)\u2500\u252c\u2500range(-1, 5, 2)\u2500\u2510\n \u2502 [0,1,2,3,4] \u2502 [1,2,3,4]   \u2502 [1,3]          \u2502 [-1,1,3]        \u2502\n@@ -176,7 +179,7 @@ arrayConcat(arrays)\n \n **Arguments**\n \n--   `arrays` \u2013 Arbitrary number of arguments of [Array](../../sql-reference/data-types/array.md) type.\n+- `arrays` \u2013 Arbitrary number of arguments of [Array](../../sql-reference/data-types/array.md) type.\n     **Example**\n \n <!-- -->\n@@ -226,19 +229,19 @@ hasAll(set, subset)\n \n **Arguments**\n \n--   `set` \u2013 Array of any type with a set of elements.\n--   `subset` \u2013 Array of any type with elements that should be tested to be a subset of `set`.\n+- `set` \u2013 Array of any type with a set of elements.\n+- `subset` \u2013 Array of any type with elements that should be tested to be a subset of `set`.\n \n **Return values**\n \n--   `1`, if `set` contains all of the elements from `subset`.\n--   `0`, otherwise.\n+- `1`, if `set` contains all of the elements from `subset`.\n+- `0`, otherwise.\n \n **Peculiar properties**\n \n--   An empty array is a subset of any array.\n--   `Null` processed as a value.\n--   Order of values in both of arrays does not matter.\n+- An empty array is a subset of any array.\n+- `Null` processed as a value.\n+- Order of values in both of arrays does not matter.\n \n **Examples**\n \n@@ -264,18 +267,18 @@ hasAny(array1, array2)\n \n **Arguments**\n \n--   `array1` \u2013 Array of any type with a set of elements.\n--   `array2` \u2013 Array of any type with a set of elements.\n+- `array1` \u2013 Array of any type with a set of elements.\n+- `array2` \u2013 Array of any type with a set of elements.\n \n **Return values**\n \n--   `1`, if `array1` and `array2` have one similar element at least.\n--   `0`, otherwise.\n+- `1`, if `array1` and `array2` have one similar element at least.\n+- `0`, otherwise.\n \n **Peculiar properties**\n \n--   `Null` processed as a value.\n--   Order of values in both of arrays does not matter.\n+- `Null` processed as a value.\n+- Order of values in both of arrays does not matter.\n \n **Examples**\n \n@@ -301,24 +304,25 @@ In other words, the functions will check whether all the elements of `array2` ar\n the `hasAll` function. In addition, it will check that the elements are observed in the same order in both `array1` and `array2`.\n \n For Example:\n+\n - `hasSubstr([1,2,3,4], [2,3])` returns 1. However, `hasSubstr([1,2,3,4], [3,2])` will return `0`.\n - `hasSubstr([1,2,3,4], [1,2,3])` returns 1. However, `hasSubstr([1,2,3,4], [1,2,4])` will return `0`.\n \n **Arguments**\n \n--   `array1` \u2013 Array of any type with a set of elements.\n--   `array2` \u2013 Array of any type with a set of elements.\n+- `array1` \u2013 Array of any type with a set of elements.\n+- `array2` \u2013 Array of any type with a set of elements.\n \n **Return values**\n \n--   `1`, if `array1` contains `array2`.\n--   `0`, otherwise.\n+- `1`, if `array1` contains `array2`.\n+- `0`, otherwise.\n \n **Peculiar properties**\n \n--   The function will return `1` if `array2` is empty.\n--   `Null` processed as a value. In other words `hasSubstr([1, 2, NULL, 3, 4], [2,3])` will return `0`. However, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` will return `1`\n--   Order of values in both of arrays does matter.\n+- The function will return `1` if `array2` is empty.\n+- `Null` processed as a value. In other words `hasSubstr([1, 2, NULL, 3, 4], [2,3])` will return `0`. However, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` will return `1`\n+- Order of values in both of arrays does matter.\n \n **Examples**\n \n@@ -484,7 +488,7 @@ arrayPopBack(array)\n \n **Arguments**\n \n--   `array` \u2013 Array.\n+- `array` \u2013 Array.\n \n **Example**\n \n@@ -508,7 +512,7 @@ arrayPopFront(array)\n \n **Arguments**\n \n--   `array` \u2013 Array.\n+- `array` \u2013 Array.\n \n **Example**\n \n@@ -532,8 +536,8 @@ arrayPushBack(array, single_value)\n \n **Arguments**\n \n--   `array` \u2013 Array.\n--   `single_value` \u2013 A single value. Only numbers can be added to an array with numbers, and only strings can be added to an array of strings. When adding numbers, ClickHouse automatically sets the `single_value` type for the data type of the array. For more information about the types of data in ClickHouse, see \u201c[Data types](../../sql-reference/data-types/index.md#data_types)\u201d. Can be `NULL`. The function adds a `NULL` element to an array, and the type of array elements converts to `Nullable`.\n+- `array` \u2013 Array.\n+- `single_value` \u2013 A single value. Only numbers can be added to an array with numbers, and only strings can be added to an array of strings. When adding numbers, ClickHouse automatically sets the `single_value` type for the data type of the array. For more information about the types of data in ClickHouse, see \u201c[Data types](../../sql-reference/data-types/index.md#data_types)\u201d. Can be `NULL`. The function adds a `NULL` element to an array, and the type of array elements converts to `Nullable`.\n \n **Example**\n \n@@ -557,8 +561,8 @@ arrayPushFront(array, single_value)\n \n **Arguments**\n \n--   `array` \u2013 Array.\n--   `single_value` \u2013 A single value. Only numbers can be added to an array with numbers, and only strings can be added to an array of strings. When adding numbers, ClickHouse automatically sets the `single_value` type for the data type of the array. For more information about the types of data in ClickHouse, see \u201c[Data types](../../sql-reference/data-types/index.md#data_types)\u201d. Can be `NULL`. The function adds a `NULL` element to an array, and the type of array elements converts to `Nullable`.\n+- `array` \u2013 Array.\n+- `single_value` \u2013 A single value. Only numbers can be added to an array with numbers, and only strings can be added to an array of strings. When adding numbers, ClickHouse automatically sets the `single_value` type for the data type of the array. For more information about the types of data in ClickHouse, see \u201c[Data types](../../sql-reference/data-types/index.md#data_types)\u201d. Can be `NULL`. The function adds a `NULL` element to an array, and the type of array elements converts to `Nullable`.\n \n **Example**\n \n@@ -582,11 +586,11 @@ arrayResize(array, size[, extender])\n \n **Arguments:**\n \n--   `array` \u2014 Array.\n--   `size` \u2014 Required length of the array.\n-    -   If `size` is less than the original size of the array, the array is truncated from the right.\n--   If `size` is larger than the initial size of the array, the array is extended to the right with `extender` values or default values for the data type of the array items.\n--   `extender` \u2014 Value for extending an array. Can be `NULL`.\n+- `array` \u2014 Array.\n+- `size` \u2014 Required length of the array.\n+  - If `size` is less than the original size of the array, the array is truncated from the right.\n+- If `size` is larger than the initial size of the array, the array is extended to the right with `extender` values or default values for the data type of the array items.\n+- `extender` \u2014 Value for extending an array. Can be `NULL`.\n \n **Returned value:**\n \n@@ -682,10 +686,10 @@ SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n--   `-Inf` values are first in the array.\n--   `NULL` values are last in the array.\n--   `NaN` values are right before `NULL`.\n--   `Inf` values are right before `NaN`.\n+- `-Inf` values are first in the array.\n+- `NULL` values are last in the array.\n+- `NaN` values are right before `NULL`.\n+- `Inf` values are right before `NaN`.\n \n Note that `arraySort` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You can pass a lambda function to it as the first argument. In this case, sorting order is determined by the result of the lambda function applied to the elements of the array.\n \n@@ -739,7 +743,7 @@ SELECT arraySort((x, y) -> -y, [0, 1, 2], [1, 2, 3]) as res;\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-:::note    \n+:::note\n To improve sorting efficiency, the [Schwartzian transform](https://en.wikipedia.org/wiki/Schwartzian_transform) is used.\n :::\n \n@@ -783,10 +787,10 @@ SELECT arrayReverseSort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]) as res;\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n--   `Inf` values are first in the array.\n--   `NULL` values are last in the array.\n--   `NaN` values are right before `NULL`.\n--   `-Inf` values are right before `NaN`.\n+- `Inf` values are first in the array.\n+- `NULL` values are last in the array.\n+- `NaN` values are right before `NULL`.\n+- `-Inf` values are right before `NaN`.\n \n Note that the `arrayReverseSort` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You can pass a lambda function to it as the first argument. Example is shown below.\n \n@@ -802,8 +806,8 @@ SELECT arrayReverseSort((x) -> -x, [1, 2, 3]) as res;\n \n The array is sorted in the following way:\n \n-1.  At first, the source array (\\[1, 2, 3\\]) is sorted according to the result of the lambda function applied to the elements of the array. The result is an array \\[3, 2, 1\\].\n-2.  Array that is obtained on the previous step, is reversed. So, the final result is \\[1, 2, 3\\].\n+1. At first, the source array (\\[1, 2, 3\\]) is sorted according to the result of the lambda function applied to the elements of the array. The result is an array \\[3, 2, 1\\].\n+2. Array that is obtained on the previous step, is reversed. So, the final result is \\[1, 2, 3\\].\n \n The lambda function can accept multiple arguments. In this case, you need to pass the `arrayReverseSort` function several arrays of identical length that the arguments of lambda function will correspond to. The resulting array will consist of elements from the first input array; elements from the next input array(s) specify the sorting keys. For example:\n \n@@ -819,8 +823,8 @@ SELECT arrayReverseSort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;\n \n In this example, the array is sorted in the following way:\n \n-1.  At first, the source array (\\[\u2018hello\u2019, \u2018world\u2019\\]) is sorted according to the result of the lambda function applied to the elements of the arrays. The elements that are passed in the second array (\\[2, 1\\]), define the sorting keys for corresponding elements from the source array. The result is an array \\[\u2018world\u2019, \u2018hello\u2019\\].\n-2.  Array that was sorted on the previous step, is reversed. So, the final result is \\[\u2018hello\u2019, \u2018world\u2019\\].\n+1. At first, the source array (\\[\u2018hello\u2019, \u2018world\u2019\\]) is sorted according to the result of the lambda function applied to the elements of the arrays. The elements that are passed in the second array (\\[2, 1\\]), define the sorting keys for corresponding elements from the source array. The result is an array \\[\u2018world\u2019, \u2018hello\u2019\\].\n+2. Array that was sorted on the previous step, is reversed. So, the final result is \\[\u2018hello\u2019, \u2018world\u2019\\].\n \n Other examples are shown below.\n \n@@ -867,7 +871,7 @@ arrayDifference(array)\n \n **Arguments**\n \n--   `array` \u2013 [Array](https://clickhouse.com/docs/en/data_types/array/).\n+- `array` \u2013 [Array](https://clickhouse.com/docs/en/data_types/array/).\n \n **Returned values**\n \n@@ -919,7 +923,7 @@ arrayDistinct(array)\n \n **Arguments**\n \n--   `array` \u2013 [Array](https://clickhouse.com/docs/en/data_types/array/).\n+- `array` \u2013 [Array](https://clickhouse.com/docs/en/data_types/array/).\n \n **Returned values**\n \n@@ -987,8 +991,8 @@ arrayReduce(agg_func, arr1, arr2, ..., arrN)\n \n **Arguments**\n \n--   `agg_func` \u2014 The name of an aggregate function which should be a constant [string](../../sql-reference/data-types/string.md).\n--   `arr` \u2014 Any number of [array](../../sql-reference/data-types/array.md) type columns as the parameters of the aggregation function.\n+- `agg_func` \u2014 The name of an aggregate function which should be a constant [string](../../sql-reference/data-types/string.md).\n+- `arr` \u2014 Any number of [array](../../sql-reference/data-types/array.md) type columns as the parameters of the aggregation function.\n \n **Returned value**\n \n@@ -1052,13 +1056,13 @@ arrayReduceInRanges(agg_func, ranges, arr1, arr2, ..., arrN)\n \n **Arguments**\n \n--   `agg_func` \u2014 The name of an aggregate function which should be a constant [string](../../sql-reference/data-types/string.md).\n--   `ranges` \u2014 The ranges to aggretate which should be an [array](../../sql-reference/data-types/array.md) of [tuples](../../sql-reference/data-types/tuple.md) which containing the index and the length of each range.\n--   `arr` \u2014 Any number of [Array](../../sql-reference/data-types/array.md) type columns as the parameters of the aggregation function.\n+- `agg_func` \u2014 The name of an aggregate function which should be a constant [string](../../sql-reference/data-types/string.md).\n+- `ranges` \u2014 The ranges to aggretate which should be an [array](../../sql-reference/data-types/array.md) of [tuples](../../sql-reference/data-types/tuple.md) which containing the index and the length of each range.\n+- `arr` \u2014 Any number of [Array](../../sql-reference/data-types/array.md) type columns as the parameters of the aggregation function.\n \n **Returned value**\n \n--   Array containing results of the aggregate function over specified ranges.\n+- Array containing results of the aggregate function over specified ranges.\n \n Type: [Array](../../sql-reference/data-types/array.md).\n \n@@ -1108,8 +1112,8 @@ Converts an array of arrays to a flat array.\n \n Function:\n \n--   Applies to any depth of nested arrays.\n--   Does not change arrays that are already flat.\n+- Applies to any depth of nested arrays.\n+- Does not change arrays that are already flat.\n \n The flattened array contains all the elements from all source arrays.\n \n@@ -1123,7 +1127,7 @@ Alias: `flatten`.\n \n **Arguments**\n \n--   `array_of_arrays` \u2014 [Array](../../sql-reference/data-types/array.md) of arrays. For example, `[[1,2,3], [4,5]]`.\n+- `array_of_arrays` \u2014 [Array](../../sql-reference/data-types/array.md) of arrays. For example, `[[1,2,3], [4,5]]`.\n \n **Examples**\n \n@@ -1185,13 +1189,13 @@ arrayZip(arr1, arr2, ..., arrN)\n \n **Arguments**\n \n--   `arrN` \u2014 [Array](../../sql-reference/data-types/array.md).\n+- `arrN` \u2014 [Array](../../sql-reference/data-types/array.md).\n \n The function can take any number of arrays of different types. All the input arrays must be of equal size.\n \n **Returned value**\n \n--   Array with elements from the source arrays grouped into [tuples](../../sql-reference/data-types/tuple.md). Data types in the tuple are the same as types of the input arrays and in the same order as arrays are passed.\n+- Array with elements from the source arrays grouped into [tuples](../../sql-reference/data-types/tuple.md). Data types in the tuple are the same as types of the input arrays and in the same order as arrays are passed.\n \n Type: [Array](../../sql-reference/data-types/array.md).\n \n@@ -1213,7 +1217,7 @@ Result:\n \n ## arrayAUC\n \n-Calculate AUC (Area Under the Curve, which is a concept in machine learning, see more details: https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).\n+Calculate AUC (Area Under the Curve, which is a concept in machine learning, see more details: <https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve>).\n \n **Syntax**\n \n@@ -1433,12 +1437,12 @@ arrayMin([func,] arr)\n \n **Arguments**\n \n--   `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n--   `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n+- `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n+- `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n \n **Returned value**\n \n--   The minimum of function values (or the array minimum).\n+- The minimum of function values (or the array minimum).\n \n Type: if `func` is specified, matches `func` return value type, else matches the array elements type.\n \n@@ -1488,12 +1492,12 @@ arrayMax([func,] arr)\n \n **Arguments**\n \n--   `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n--   `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n+- `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n+- `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n \n **Returned value**\n \n--   The maximum of function values (or the array maximum).\n+- The maximum of function values (or the array maximum).\n \n Type: if `func` is specified, matches `func` return value type, else matches the array elements type.\n \n@@ -1543,12 +1547,12 @@ arraySum([func,] arr)\n \n **Arguments**\n \n--   `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n--   `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n+- `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n+- `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n \n **Returned value**\n \n--   The sum of the function values (or the array sum).\n+- The sum of the function values (or the array sum).\n \n Type: for decimal numbers in source array (or for converted values, if `func` is specified) \u2014 [Decimal128](../../sql-reference/data-types/decimal.md), for floating point numbers \u2014 [Float64](../../sql-reference/data-types/float.md), for numeric unsigned \u2014 [UInt64](../../sql-reference/data-types/int-uint.md), and for numeric signed \u2014 [Int64](../../sql-reference/data-types/int-uint.md).\n \n@@ -1598,12 +1602,12 @@ arrayAvg([func,] arr)\n \n **Arguments**\n \n--   `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n--   `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n+- `func` \u2014 Function. [Expression](../../sql-reference/data-types/special-data-types/expression.md).\n+- `arr` \u2014 Array. [Array](../../sql-reference/data-types/array.md).\n \n **Returned value**\n \n--   The average of function values (or the array average).\n+- The average of function values (or the array average).\n \n Type: [Float64](../../sql-reference/data-types/float.md).\n \n@@ -1641,6 +1645,22 @@ Result:\n \n Returns an array of partial sums of elements in the source array (a running sum). If the `func` function is specified, then the values of the array elements are converted by `func(arr1[i], \u2026, arrN[i])` before summing.\n \n+**Syntax**\n+\n+``` sql\n+arrayCumSum(arr)\n+```\n+\n+**Arguments**\n+\n+- `arr` \u2014 [Array](../../sql-reference/data-types/array.md) of numeric values.\n+\n+**Returned value**\n+\n+- Returns an array of partial sums of elements in the source array.\n+\n+Type: [UInt\\*](https://clickhouse.com/docs/en/data_types/int_uint/#uint-ranges), [Int\\*](https://clickhouse.com/docs/en/data_types/int_uint/#int-ranges), [Float\\*](https://clickhouse.com/docs/en/data_types/float/).\n+\n Example:\n \n ``` sql\n@@ -1659,6 +1679,22 @@ Note that the `arrayCumSum` is a [higher-order function](../../sql-reference/fun\n \n Same as `arrayCumSum`, returns an array of partial sums of elements in the source array (a running sum). Different `arrayCumSum`, when then returned value contains a value less than zero, the value is replace with zero and the subsequent calculation is performed with zero parameters. For example:\n \n+**Syntax**\n+\n+``` sql\n+arrayCumSumNonNegative(arr)\n+```\n+\n+**Arguments**\n+\n+- `arr` \u2014 [Array](../../sql-reference/data-types/array.md) of numeric values.\n+\n+**Returned value**\n+\n+- Returns an array of non-negative partial sums of elements in the source array.\n+\n+Type: [UInt\\*](https://clickhouse.com/docs/en/data_types/int_uint/#uint-ranges), [Int\\*](https://clickhouse.com/docs/en/data_types/int_uint/#int-ranges), [Float\\*](https://clickhouse.com/docs/en/data_types/float/).\n+\n ``` sql\n SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res\n ```\n@@ -1668,6 +1704,7 @@ SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res\n \u2502 [1,2,0,1] \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n Note that the `arraySumNonNegative` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You can pass a lambda function to it as the first argument.\n \n ## arrayProduct\n@@ -1682,11 +1719,11 @@ arrayProduct(arr)\n \n **Arguments**\n \n--   `arr` \u2014 [Array](../../sql-reference/data-types/array.md) of numeric values.\n+- `arr` \u2014 [Array](../../sql-reference/data-types/array.md) of numeric values.\n \n **Returned value**\n \n--   A product of array's elements.\n+- A product of array's elements.\n \n Type: [Float64](../../sql-reference/data-types/float.md).\n \ndiff --git a/src/Functions/array/arrayCumSum.cpp b/src/Functions/array/arrayCumSum.cpp\nindex b1077bfb18b4..86766e441432 100644\n--- a/src/Functions/array/arrayCumSum.cpp\n+++ b/src/Functions/array/arrayCumSum.cpp\n@@ -29,15 +29,28 @@ struct ArrayCumSumImpl\n     {\n         WhichDataType which(expression_return);\n \n-        if (which.isNativeUInt())\n-            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+        if (which.isUInt())\n+        {\n+            if (which.isNativeUInt())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+            if (which.isUInt256())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt256>());\n+            else\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt128>());\n+        }\n \n-        if (which.isNativeInt())\n-            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt64>());\n+        if (which.isInt())\n+        {\n+            if (which.isNativeInt())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt64>());\n+            if (which.isInt256())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt256>());\n+            else\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt128>());\n+        }\n \n         if (which.isFloat())\n             return std::make_shared<DataTypeArray>(std::make_shared<DataTypeFloat64>());\n-\n         if (which.isDecimal())\n         {\n             UInt32 scale = getDecimalScale(*expression_return);\n@@ -54,8 +67,8 @@ struct ArrayCumSumImpl\n \n \n     template <typename Src, typename Dst>\n-    static void NO_SANITIZE_UNDEFINED implConst(\n-        size_t size, const IColumn::Offset * __restrict offsets, Dst * __restrict res_values, Src src_value)\n+    static void NO_SANITIZE_UNDEFINED\n+    implConst(size_t size, const IColumn::Offset * __restrict offsets, Dst * __restrict res_values, Src src_value)\n     {\n         size_t pos = 0;\n         for (const auto * end = offsets + size; offsets < end; ++offsets)\n@@ -71,8 +84,8 @@ struct ArrayCumSumImpl\n     }\n \n     template <typename Src, typename Dst>\n-    static void NO_SANITIZE_UNDEFINED implVector(\n-        size_t size, const IColumn::Offset * __restrict offsets, Dst * __restrict res_values, const Src * __restrict src_values)\n+    static void NO_SANITIZE_UNDEFINED\n+    implVector(size_t size, const IColumn::Offset * __restrict offsets, Dst * __restrict res_values, const Src * __restrict src_values)\n     {\n         size_t pos = 0;\n         for (const auto * end = offsets + size; offsets < end; ++offsets)\n@@ -136,35 +149,31 @@ struct ArrayCumSumImpl\n         implVector(offsets.size(), offsets.data(), res_values.data(), data.data());\n         res_ptr = ColumnArray::create(std::move(res_nested), array.getOffsetsPtr());\n         return true;\n-\n     }\n \n     static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)\n     {\n         ColumnPtr res;\n \n-        if (executeType< UInt8 , UInt64>(mapped, array, res) ||\n-            executeType< UInt16, UInt64>(mapped, array, res) ||\n-            executeType< UInt32, UInt64>(mapped, array, res) ||\n-            executeType< UInt64, UInt64>(mapped, array, res) ||\n-            executeType<  Int8 ,  Int64>(mapped, array, res) ||\n-            executeType<  Int16,  Int64>(mapped, array, res) ||\n-            executeType<  Int32,  Int64>(mapped, array, res) ||\n-            executeType<  Int64,  Int64>(mapped, array, res) ||\n-            executeType<Float32,Float64>(mapped, array, res) ||\n-            executeType<Float64,Float64>(mapped, array, res) ||\n-            executeType<Decimal32, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal64, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal128, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal256, Decimal256>(mapped, array, res))\n+        if (executeType<UInt8, UInt64>(mapped, array, res) || executeType<UInt16, UInt64>(mapped, array, res)\n+            || executeType<UInt32, UInt64>(mapped, array, res) || executeType<UInt64, UInt64>(mapped, array, res)\n+            || executeType<UInt128, UInt128>(mapped, array, res) || executeType<UInt256, UInt256>(mapped, array, res)\n+            || executeType<Int8, Int64>(mapped, array, res) || executeType<Int16, Int64>(mapped, array, res)\n+            || executeType<Int32, Int64>(mapped, array, res) || executeType<Int64, Int64>(mapped, array, res)\n+            || executeType<Int128, Int128>(mapped, array, res) || executeType<Int256, Int256>(mapped, array, res)\n+            || executeType<Float32, Float64>(mapped, array, res) || executeType<Float64, Float64>(mapped, array, res)\n+            || executeType<Decimal32, Decimal128>(mapped, array, res) || executeType<Decimal64, Decimal128>(mapped, array, res)\n+            || executeType<Decimal128, Decimal128>(mapped, array, res) || executeType<Decimal256, Decimal256>(mapped, array, res))\n             return res;\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arrayCumSum: {}\", mapped->getName());\n     }\n-\n };\n \n-struct NameArrayCumSum { static constexpr auto name = \"arrayCumSum\"; };\n+struct NameArrayCumSum\n+{\n+    static constexpr auto name = \"arrayCumSum\";\n+};\n using FunctionArrayCumSum = FunctionArrayMapped<ArrayCumSumImpl, NameArrayCumSum>;\n \n REGISTER_FUNCTION(ArrayCumSum)\ndiff --git a/src/Functions/array/arrayCumSumNonNegative.cpp b/src/Functions/array/arrayCumSumNonNegative.cpp\nindex 6b20ad35afcc..a06d06c246d5 100644\n--- a/src/Functions/array/arrayCumSumNonNegative.cpp\n+++ b/src/Functions/array/arrayCumSumNonNegative.cpp\n@@ -30,11 +30,25 @@ struct ArrayCumSumNonNegativeImpl\n     {\n         WhichDataType which(expression_return);\n \n-        if (which.isNativeUInt())\n-            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+        if (which.isUInt())\n+        {\n+            if (which.isNativeUInt())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+            if (which.isUInt256())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt256>());\n+            else\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt128>());\n+        }\n \n-        if (which.isNativeInt())\n-            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt64>());\n+        if (which.isInt())\n+        {\n+            if (which.isNativeInt())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt64>());\n+            if (which.isInt256())\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt256>());\n+            else\n+                return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt128>());\n+        }\n \n         if (which.isFloat())\n             return std::make_shared<DataTypeArray>(std::make_shared<DataTypeFloat64>());\n@@ -50,14 +64,14 @@ struct ArrayCumSumNonNegativeImpl\n             return std::make_shared<DataTypeArray>(nested);\n         }\n \n-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                        \"arrayCumSumNonNegativeImpl cannot add values of type {}\", expression_return->getName());\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"arrayCumSumNonNegativeImpl cannot add values of type {}\", expression_return->getName());\n     }\n \n \n     template <typename Src, typename Dst>\n-    static void NO_SANITIZE_UNDEFINED implVector(\n-        size_t size, const IColumn::Offset * __restrict offsets, Dst * __restrict res_values, const Src * __restrict src_values)\n+    static void NO_SANITIZE_UNDEFINED\n+    implVector(size_t size, const IColumn::Offset * __restrict offsets, Dst * __restrict res_values, const Src * __restrict src_values)\n     {\n         size_t pos = 0;\n         for (const auto * end = offsets + size; offsets < end; ++offsets)\n@@ -100,7 +114,6 @@ struct ArrayCumSumNonNegativeImpl\n         implVector(offsets.size(), offsets.data(), res_values.data(), data.data());\n         res_ptr = ColumnArray::create(std::move(res_nested), array.getOffsetsPtr());\n         return true;\n-\n     }\n \n     static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)\n@@ -108,28 +121,25 @@ struct ArrayCumSumNonNegativeImpl\n         ColumnPtr res;\n \n         mapped = mapped->convertToFullColumnIfConst();\n-        if (executeType< UInt8 , UInt64>(mapped, array, res) ||\n-            executeType< UInt16, UInt64>(mapped, array, res) ||\n-            executeType< UInt32, UInt64>(mapped, array, res) ||\n-            executeType< UInt64, UInt64>(mapped, array, res) ||\n-            executeType<  Int8 ,  Int64>(mapped, array, res) ||\n-            executeType<  Int16,  Int64>(mapped, array, res) ||\n-            executeType<  Int32,  Int64>(mapped, array, res) ||\n-            executeType<  Int64,  Int64>(mapped, array, res) ||\n-            executeType<Float32,Float64>(mapped, array, res) ||\n-            executeType<Float64,Float64>(mapped, array, res) ||\n-            executeType<Decimal32, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal64, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal128, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal256, Decimal256>(mapped, array, res))\n+        if (executeType<UInt8, UInt64>(mapped, array, res) || executeType<UInt16, UInt64>(mapped, array, res)\n+            || executeType<UInt32, UInt64>(mapped, array, res) || executeType<UInt64, UInt64>(mapped, array, res)\n+            || executeType<UInt128, UInt128>(mapped, array, res) || executeType<UInt256, UInt256>(mapped, array, res)\n+            || executeType<Int8, Int64>(mapped, array, res) || executeType<Int16, Int64>(mapped, array, res)\n+            || executeType<Int32, Int64>(mapped, array, res) || executeType<Int64, Int64>(mapped, array, res)\n+            || executeType<Int128, Int128>(mapped, array, res) || executeType<Int256, Int256>(mapped, array, res)\n+            || executeType<Float32, Float64>(mapped, array, res) || executeType<Float64, Float64>(mapped, array, res)\n+            || executeType<Decimal32, Decimal128>(mapped, array, res) || executeType<Decimal64, Decimal128>(mapped, array, res)\n+            || executeType<Decimal128, Decimal128>(mapped, array, res) || executeType<Decimal256, Decimal256>(mapped, array, res))\n             return res;\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arrayCumSumNonNegativeImpl: {}\", mapped->getName());\n     }\n-\n };\n \n-struct NameArrayCumSumNonNegative { static constexpr auto name = \"arrayCumSumNonNegative\"; };\n+struct NameArrayCumSumNonNegative\n+{\n+    static constexpr auto name = \"arrayCumSumNonNegative\";\n+};\n using FunctionArrayCumSumNonNegative = FunctionArrayMapped<ArrayCumSumNonNegativeImpl, NameArrayCumSumNonNegative>;\n \n REGISTER_FUNCTION(ArrayCumSumNonNegative)\ndiff --git a/src/Functions/array/arrayDifference.cpp b/src/Functions/array/arrayDifference.cpp\nindex d210a2559a26..9dcc730d4f61 100644\n--- a/src/Functions/array/arrayDifference.cpp\n+++ b/src/Functions/array/arrayDifference.cpp\n@@ -41,6 +41,12 @@ struct ArrayDifferenceImpl\n         if (which.isUInt32() || which.isUInt64() || which.isInt32() || which.isInt64() || which.isDate32() || which.isDateTime())\n             return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt64>());\n \n+        if (which.isUInt128() || which.isInt128())\n+            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt128>());\n+\n+        if (which.isUInt256() || which.isInt256())\n+            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeInt256>());\n+\n         if (which.isFloat32() || which.isFloat64())\n             return std::make_shared<DataTypeArray>(std::make_shared<DataTypeFloat64>());\n \n@@ -55,7 +61,8 @@ struct ArrayDifferenceImpl\n             return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDecimal<Decimal64>>(precision, scale));\n         }\n \n-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"arrayDifference cannot process values of type {}\", expression_return->getName());\n+        throw Exception(\n+            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"arrayDifference cannot process values of type {}\", expression_return->getName());\n     }\n \n \n@@ -82,9 +89,7 @@ struct ArrayDifferenceImpl\n \n                     ResultNativeType result_value;\n                     bool overflow = common::subOverflow(\n-                        static_cast<ResultNativeType>(curr.value),\n-                        static_cast<ResultNativeType>(prev.value),\n-                        result_value);\n+                        static_cast<ResultNativeType>(curr.value), static_cast<ResultNativeType>(prev.value), result_value);\n                     if (overflow)\n                         throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"Decimal math overflow\");\n \n@@ -141,28 +146,26 @@ struct ArrayDifferenceImpl\n         ColumnPtr res;\n \n         mapped = mapped->convertToFullColumnIfConst();\n-        if (executeType< UInt8 ,  Int16>(mapped, array, res) ||\n-            executeType< UInt16,  Int32>(mapped, array, res) ||\n-            executeType< UInt32,  Int64>(mapped, array, res) ||\n-            executeType< UInt64,  Int64>(mapped, array, res) ||\n-            executeType<  Int8 ,  Int16>(mapped, array, res) ||\n-            executeType<  Int16,  Int32>(mapped, array, res) ||\n-            executeType<  Int32,  Int64>(mapped, array, res) ||\n-            executeType<  Int64,  Int64>(mapped, array, res) ||\n-            executeType<Float32,Float64>(mapped, array, res) ||\n-            executeType<Float64,Float64>(mapped, array, res) ||\n-            executeType<Decimal32, Decimal32>(mapped, array, res) ||\n-            executeType<Decimal64, Decimal64>(mapped, array, res) ||\n-            executeType<Decimal128, Decimal128>(mapped, array, res) ||\n-            executeType<Decimal256, Decimal256>(mapped, array, res) ||\n-            executeType<DateTime64, Decimal64>(mapped, array, res))\n+        if (executeType<UInt8, Int16>(mapped, array, res) || executeType<UInt16, Int32>(mapped, array, res)\n+            || executeType<UInt32, Int64>(mapped, array, res) || executeType<UInt64, Int64>(mapped, array, res)\n+            || executeType<Int8, Int16>(mapped, array, res) || executeType<Int16, Int32>(mapped, array, res)\n+            || executeType<Int32, Int64>(mapped, array, res) || executeType<Int64, Int64>(mapped, array, res)\n+            || executeType<UInt128, Int128>(mapped, array, res) || executeType<Int128, Int128>(mapped, array, res)\n+            || executeType<UInt256, Int256>(mapped, array, res) || executeType<Int256, Int256>(mapped, array, res)\n+            || executeType<Float32, Float64>(mapped, array, res) || executeType<Float64, Float64>(mapped, array, res)\n+            || executeType<Decimal32, Decimal32>(mapped, array, res) || executeType<Decimal64, Decimal64>(mapped, array, res)\n+            || executeType<Decimal128, Decimal128>(mapped, array, res) || executeType<Decimal256, Decimal256>(mapped, array, res)\n+            || executeType<DateTime64, Decimal64>(mapped, array, res))\n             return res;\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Unexpected column for arrayDifference: {}\", mapped->getName());\n     }\n };\n \n-struct NameArrayDifference { static constexpr auto name = \"arrayDifference\"; };\n+struct NameArrayDifference\n+{\n+    static constexpr auto name = \"arrayDifference\";\n+};\n using FunctionArrayDifference = FunctionArrayMapped<ArrayDifferenceImpl, NameArrayDifference>;\n \n REGISTER_FUNCTION(ArrayDifference)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02716_int256_arrayfunc.reference b/tests/queries/0_stateless/02716_int256_arrayfunc.reference\nnew file mode 100644\nindex 000000000000..4f6df732d504\n--- /dev/null\n+++ b/tests/queries/0_stateless/02716_int256_arrayfunc.reference\n@@ -0,0 +1,26 @@\n+[1,3]\n+[1,3]\n+[1,3]\n+[1,3]\n+[3,4,5]\n+[1,2]\n+Array(UInt128)\n+Array(Int128)\n+Array(UInt256)\n+Array(Int256)\n+[0,2]\n+[0,2]\n+[0,2]\n+[0,2]\n+Array(Int128)\n+Array(Int128)\n+Array(Int256)\n+Array(Int256)\n+[1,0]\n+[1,0]\n+[1,3]\n+[1,3]\n+Array(Int128)\n+Array(Int256)\n+Array(UInt128)\n+Array(UInt256)\ndiff --git a/tests/queries/0_stateless/02716_int256_arrayfunc.sql b/tests/queries/0_stateless/02716_int256_arrayfunc.sql\nnew file mode 100644\nindex 000000000000..20721d228ac5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02716_int256_arrayfunc.sql\n@@ -0,0 +1,28 @@\n+SELECT arrayCumSum([CAST('1', 'Int128'), 2]);\n+SELECT arrayCumSum([CAST('1', 'Int256'), 2]);\n+SELECT arrayCumSum([CAST('1', 'UInt128'), 2]);\n+SELECT arrayCumSum([CAST('1', 'UInt256'), 2]);\n+SELECT arrayCumSum([3, CAST('1', 'Int128'),CAST('1', 'Int256')]);\n+SELECT arrayCumSum([CAST('1', 'Int256'), CAST('1', 'Int128')]);\n+SELECT toTypeName(arrayCumSum([CAST('1', 'UInt128'), 2]));\n+SELECT toTypeName(arrayCumSum([CAST('1', 'Int128'), 2]));\n+SELECT toTypeName(arrayCumSum([CAST('1', 'UInt256'), CAST('1', 'UInt128')]));\n+SELECT toTypeName(arrayCumSum([CAST('1', 'Int256'), CAST('1', 'Int128')]));\n+\n+SELECT arrayDifference([CAST('1', 'Int256'), 3]);\n+SELECT arrayDifference([CAST('1', 'UInt256'), 3]);\n+SELECT arrayDifference([CAST('1', 'UInt128'), 3]);\n+SELECT arrayDifference([CAST('1', 'Int128'), 3]);\n+SELECT toTypeName(arrayDifference([CAST('1', 'UInt128'), 3]));\n+SELECT toTypeName(arrayDifference([CAST('1', 'Int128'), 3]));\n+SELECT toTypeName(arrayDifference([CAST('1', 'UInt256'), 3]));\n+SELECT toTypeName(arrayDifference([CAST('1', 'Int256'), 3]));\n+\n+SELECT arrayCumSumNonNegative([CAST('1', 'Int128'), -2]);\n+SELECT arrayCumSumNonNegative([CAST('1', 'Int256'), -2]);\n+SELECT arrayCumSumNonNegative([CAST('1', 'UInt128'), 2]);\n+SELECT arrayCumSumNonNegative([CAST('1', 'UInt256'), 2]);\n+SELECT toTypeName(arrayCumSumNonNegative([CAST('1', 'Int128'), -2]));\n+SELECT toTypeName(arrayCumSumNonNegative([CAST('1', 'Int256'), -2]));\n+SELECT toTypeName(arrayCumSumNonNegative([CAST('1', 'UInt128'), 2]));\n+SELECT toTypeName(arrayCumSumNonNegative([CAST('1', 'UInt256'), 2]));\n",
  "problem_statement": "arrayMax, arrayMin, arrayDifference, arrayCumSum doesn't have support for wide ints (Int256)\n**Use case**\r\n\r\n```\r\nSELECT arrayCumSum([CAST('1', 'Int256'), 2])\r\n\r\nQuery id: abeebc3d-13d4-4cb5-b69c-f20e8c1b0d51\r\n\r\n\r\n0 rows in set. Elapsed: 0.007 sec.\r\n\r\nReceived exception from server (version 23.3.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: arrayCumSum cannot add values of type Int256: While processing arrayCumSum([CAST('1', 'Int256'), 2]). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nArray functions will work for wide int (*Int256, *int128)\r\n\r\nJust like https://github.com/ClickHouse/ClickHouse/pull/47594 but for Int256\n",
  "hints_text": "",
  "created_at": "2023-04-17T17:27:32Z",
  "modified_files": [
    "docs/en/sql-reference/functions/array-functions.md",
    "src/Functions/array/arrayCumSum.cpp",
    "src/Functions/array/arrayCumSumNonNegative.cpp",
    "src/Functions/array/arrayDifference.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02716_int256_arrayfunc.reference",
    "b/tests/queries/0_stateless/02716_int256_arrayfunc.sql"
  ]
}