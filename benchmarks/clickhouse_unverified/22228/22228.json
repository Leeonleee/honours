{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 22228,
  "instance_id": "ClickHouse__ClickHouse-22228",
  "issue_numbers": [
    "20253"
  ],
  "base_commit": "662888aee0b4e95120fd19660a72bf4164d13fbd",
  "patch": "diff --git a/docs/en/operations/external-authenticators/ldap.md b/docs/en/operations/external-authenticators/ldap.md\nindex 1b65ecc968b4..805d45e1b386 100644\n--- a/docs/en/operations/external-authenticators/ldap.md\n+++ b/docs/en/operations/external-authenticators/ldap.md\n@@ -17,6 +17,7 @@ To define LDAP server you must add `ldap_servers` section to the `config.xml`.\n <yandex>\n     <!- ... -->\n     <ldap_servers>\n+        <!- Typical LDAP server. -->\n         <my_ldap_server>\n             <host>localhost</host>\n             <port>636</port>\n@@ -31,6 +32,18 @@ To define LDAP server you must add `ldap_servers` section to the `config.xml`.\n             <tls_ca_cert_dir>/path/to/tls_ca_cert_dir</tls_ca_cert_dir>\n             <tls_cipher_suite>ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:AES256-GCM-SHA384</tls_cipher_suite>\n         </my_ldap_server>\n+\n+        <!- Typical Active Directory with configured user DN detection for further role mapping. -->\n+        <my_ad_server>\n+            <host>localhost</host>\n+            <port>389</port>\n+            <bind_dn>EXAMPLE\\{user_name}</bind_dn>\n+            <user_dn_detection>\n+                <base_dn>CN=Users,DC=example,DC=com</base_dn>\n+                <search_filter>(&amp;(objectClass=user)(sAMAccountName={user_name}))</search_filter>\n+            </user_dn_detection>\n+            <enable_tls>no</enable_tls>\n+        </my_ad_server>\n     </ldap_servers>\n </yandex>\n ```\n@@ -43,6 +56,15 @@ Note, that you can define multiple LDAP servers inside the `ldap_servers` sectio\n - `port` \u2014 LDAP server port, default is `636` if `enable_tls` is set to `true`, `389` otherwise.\n - `bind_dn` \u2014 Template used to construct the DN to bind to.\n     - The resulting DN will be constructed by replacing all `{user_name}` substrings of the template with the actual user name during each authentication attempt.\n+- `user_dn_detection` - Section with LDAP search parameters for detecting the actual user DN of the bound user.\n+    - This is mainly used in search filters for further role mapping when the server is Active Directory. The resulting user DN will be used when replacing `{user_dn}` substrings wherever they are allowed. By default, user DN is set equal to bind DN, but once search is performed, it will be updated with to the actual detected user DN value.\n+        - `base_dn` - Template used to construct the base DN for the LDAP search.\n+            - The resulting DN will be constructed by replacing all `{user_name}` and `{bind_dn}` substrings of the template with the actual user name and bind DN during the LDAP search.\n+        - `scope` - Scope of the LDAP search.\n+            - Accepted values are: `base`, `one_level`, `children`, `subtree` (the default).\n+        - `search_filter` - Template used to construct the search filter for the LDAP search.\n+            - The resulting filter will be constructed by replacing all `{user_name}`, `{bind_dn}`, and `{base_dn}` substrings of the template with the actual user name, bind DN, and base DN during the LDAP search.\n+            - Note, that the special characters must be escaped properly in XML.\n - `verification_cooldown` \u2014 A period of time, in seconds, after a successful bind attempt, during which the user will be assumed to be successfully authenticated for all consecutive requests without contacting the LDAP server.\n     - Specify `0` (the default) to disable caching and force contacting the LDAP server for each authentication request.\n - `enable_tls` \u2014 A flag to trigger the use of the secure connection to the LDAP server.\n@@ -107,7 +129,7 @@ Goes into `config.xml`.\n <yandex>\n     <!- ... -->\n     <user_directories>\n-        <!- ... -->\n+        <!- Typical LDAP server. -->\n         <ldap>\n             <server>my_ldap_server</server>\n             <roles>\n@@ -122,6 +144,18 @@ Goes into `config.xml`.\n                 <prefix>clickhouse_</prefix>\n             </role_mapping>\n         </ldap>\n+\n+        <!- Typical Active Directory with role mapping that relies on the detected user DN. -->\n+        <ldap>\n+            <server>my_ad_server</server>\n+            <role_mapping>\n+                <base_dn>CN=Users,DC=example,DC=com</base_dn>\n+                <attribute>CN</attribute>\n+                <scope>subtree</scope>\n+                <search_filter>(&amp;(objectClass=group)(member={user_dn}))</search_filter>\n+                <prefix>clickhouse_</prefix>\n+            </role_mapping>\n+        </ldap>\n     </user_directories>\n </yandex>\n ```\n@@ -137,13 +171,13 @@ Note that `my_ldap_server` referred in the `ldap` section inside the `user_direc\n     - When a user authenticates, while still bound to LDAP, an LDAP search is performed using `search_filter` and the name of the logged-in user. For each entry found during that search, the value of the specified attribute is extracted. For each attribute value that has the specified prefix, the prefix is removed, and the rest of the value becomes the name of a local role defined in ClickHouse, which is expected to be created beforehand by the [CREATE ROLE](../../sql-reference/statements/create/role.md#create-role-statement) statement.\n     - There can be multiple `role_mapping` sections defined inside the same `ldap` section. All of them will be applied.\n         - `base_dn` \u2014 Template used to construct the base DN for the LDAP search.\n-           - The resulting DN will be constructed by replacing all `{user_name}` and `{bind_dn}` substrings of the template with the actual user name and bind DN during each LDAP search.\n+            - The resulting DN will be constructed by replacing all `{user_name}`, `{bind_dn}`, and `{user_dn}` substrings of the template with the actual user name, bind DN, and user DN during each LDAP search.\n         - `scope` \u2014 Scope of the LDAP search.\n             - Accepted values are: `base`, `one_level`, `children`, `subtree` (the default).\n         - `search_filter` \u2014 Template used to construct the search filter for the LDAP search.\n-            - The resulting filter will be constructed by replacing all `{user_name}`, `{bind_dn}` and `{base_dn}` substrings of the template with the actual user name, bind DN and base DN during each LDAP search.\n+            - The resulting filter will be constructed by replacing all `{user_name}`, `{bind_dn}`, `{user_dn}`, and `{base_dn}` substrings of the template with the actual user name, bind DN, user DN, and base DN during each LDAP search.\n             - Note, that the special characters must be escaped properly in XML.\n-        - `attribute` \u2014 Attribute name whose values will be returned by the LDAP search.\n+        - `attribute` \u2014 Attribute name whose values will be returned by the LDAP search. `cn`, by default.\n         - `prefix` \u2014 Prefix, that will be expected to be in front of each string in the original list of strings returned by the LDAP search. The prefix will be removed from the original strings and the resulting strings will be treated as local role names. Empty by default.\n \n [Original article](https://clickhouse.tech/docs/en/operations/external-authenticators/ldap/) <!--hide-->\ndiff --git a/programs/server/config.xml b/programs/server/config.xml\nindex df8a5266c399..75647b10416d 100644\n--- a/programs/server/config.xml\n+++ b/programs/server/config.xml\n@@ -362,6 +362,20 @@\n                 bind_dn - template used to construct the DN to bind to.\n                         The resulting DN will be constructed by replacing all '{user_name}' substrings of the template with the actual\n                          user name during each authentication attempt.\n+                user_dn_detection - section with LDAP search parameters for detecting the actual user DN of the bound user.\n+                        This is mainly used in search filters for further role mapping when the server is Active Directory. The\n+                         resulting user DN will be used when replacing '{user_dn}' substrings wherever they are allowed. By default,\n+                         user DN is set equal to bind DN, but once search is performed, it will be updated with to the actual detected\n+                         user DN value.\n+                    base_dn - template used to construct the base DN for the LDAP search.\n+                            The resulting DN will be constructed by replacing all '{user_name}' and '{bind_dn}' substrings\n+                             of the template with the actual user name and bind DN during the LDAP search.\n+                    scope - scope of the LDAP search.\n+                            Accepted values are: 'base', 'one_level', 'children', 'subtree' (the default).\n+                    search_filter - template used to construct the search filter for the LDAP search.\n+                            The resulting filter will be constructed by replacing all '{user_name}', '{bind_dn}', and '{base_dn}'\n+                             substrings of the template with the actual user name, bind DN, and base DN during the LDAP search.\n+                            Note, that the special characters must be escaped properly in XML.\n                 verification_cooldown - a period of time, in seconds, after a successful bind attempt, during which a user will be assumed\n                          to be successfully authenticated for all consecutive requests without contacting the LDAP server.\n                         Specify 0 (the default) to disable caching and force contacting the LDAP server for each authentication request.\n@@ -393,6 +407,17 @@\n                     <tls_ca_cert_dir>/path/to/tls_ca_cert_dir</tls_ca_cert_dir>\n                     <tls_cipher_suite>ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:AES256-GCM-SHA384</tls_cipher_suite>\n                 </my_ldap_server>\n+             Example (typical Active Directory with configured user DN detection for further role mapping):\n+                <my_ad_server>\n+                    <host>localhost</host>\n+                    <port>389</port>\n+                    <bind_dn>EXAMPLE\\{user_name}</bind_dn>\n+                    <user_dn_detection>\n+                        <base_dn>CN=Users,DC=example,DC=com</base_dn>\n+                        <search_filter>(&amp;(objectClass=user)(sAMAccountName={user_name}))</search_filter>\n+                    </user_dn_detection>\n+                    <enable_tls>no</enable_tls>\n+                </my_ad_server>\n         -->\n     </ldap_servers>\n \n@@ -444,15 +469,16 @@\n                         There can be multiple 'role_mapping' sections defined inside the same 'ldap' section. All of them will be\n                          applied.\n                     base_dn - template used to construct the base DN for the LDAP search.\n-                            The resulting DN will be constructed by replacing all '{user_name}' and '{bind_dn}' substrings\n-                             of the template with the actual user name and bind DN during each LDAP search.\n+                            The resulting DN will be constructed by replacing all '{user_name}', '{bind_dn}', and '{user_dn}'\n+                             substrings of the template with the actual user name, bind DN, and user DN during each LDAP search.\n                     scope - scope of the LDAP search.\n                             Accepted values are: 'base', 'one_level', 'children', 'subtree' (the default).\n                     search_filter - template used to construct the search filter for the LDAP search.\n-                            The resulting filter will be constructed by replacing all '{user_name}', '{bind_dn}', and '{base_dn}'\n-                             substrings of the template with the actual user name, bind DN, and base DN during each LDAP search.\n+                            The resulting filter will be constructed by replacing all '{user_name}', '{bind_dn}', '{user_dn}', and\n+                             '{base_dn}' substrings of the template with the actual user name, bind DN, user DN, and base DN during\n+                             each LDAP search.\n                             Note, that the special characters must be escaped properly in XML.\n-                    attribute - attribute name whose values will be returned by the LDAP search.\n+                    attribute - attribute name whose values will be returned by the LDAP search. 'cn', by default.\n                     prefix - prefix, that will be expected to be in front of each string in the original list of strings returned by\n                              the LDAP search. Prefix will be removed from the original strings and resulting strings will be treated\n                              as local role names. Empty, by default.\n@@ -471,6 +497,17 @@\n                         <prefix>clickhouse_</prefix>\n                     </role_mapping>\n                 </ldap>\n+             Example (typical Active Directory with role mapping that relies on the detected user DN):\n+                <ldap>\n+                    <server>my_ad_server</server>\n+                    <role_mapping>\n+                        <base_dn>CN=Users,DC=example,DC=com</base_dn>\n+                        <attribute>CN</attribute>\n+                        <scope>subtree</scope>\n+                        <search_filter>(&amp;(objectClass=group)(member={user_dn}))</search_filter>\n+                        <prefix>clickhouse_</prefix>\n+                    </role_mapping>\n+                </ldap>\n         -->\n     </user_directories>\n \ndiff --git a/src/Access/ExternalAuthenticators.cpp b/src/Access/ExternalAuthenticators.cpp\nindex 0c4d2f417c97..d4100c4e520d 100644\n--- a/src/Access/ExternalAuthenticators.cpp\n+++ b/src/Access/ExternalAuthenticators.cpp\n@@ -20,13 +20,42 @@ namespace ErrorCodes\n namespace\n {\n \n-auto parseLDAPServer(const Poco::Util::AbstractConfiguration & config, const String & name)\n+void parseLDAPSearchParams(LDAPClient::SearchParams & params, const Poco::Util::AbstractConfiguration & config, const String & prefix)\n+{\n+    const bool has_base_dn = config.has(prefix + \".base_dn\");\n+    const bool has_search_filter = config.has(prefix + \".search_filter\");\n+    const bool has_attribute = config.has(prefix + \".attribute\");\n+    const bool has_scope = config.has(prefix + \".scope\");\n+\n+    if (has_base_dn)\n+        params.base_dn = config.getString(prefix + \".base_dn\");\n+\n+    if (has_search_filter)\n+        params.search_filter = config.getString(prefix + \".search_filter\");\n+\n+    if (has_attribute)\n+        params.attribute = config.getString(prefix + \".attribute\");\n+\n+    if (has_scope)\n+    {\n+        auto scope = config.getString(prefix + \".scope\");\n+        boost::algorithm::to_lower(scope);\n+\n+        if (scope == \"base\")           params.scope = LDAPClient::SearchParams::Scope::BASE;\n+        else if (scope == \"one_level\") params.scope = LDAPClient::SearchParams::Scope::ONE_LEVEL;\n+        else if (scope == \"subtree\")   params.scope = LDAPClient::SearchParams::Scope::SUBTREE;\n+        else if (scope == \"children\")  params.scope = LDAPClient::SearchParams::Scope::CHILDREN;\n+        else\n+            throw Exception(\"Invalid value for 'scope' field of LDAP search parameters in '\" + prefix +\n+                \"' section, must be one of 'base', 'one_level', 'subtree', or 'children'\", ErrorCodes::BAD_ARGUMENTS);\n+    }\n+}\n+\n+void parseLDAPServer(LDAPClient::Params & params, const Poco::Util::AbstractConfiguration & config, const String & name)\n {\n     if (name.empty())\n         throw Exception(\"LDAP server name cannot be empty\", ErrorCodes::BAD_ARGUMENTS);\n \n-    LDAPClient::Params params;\n-\n     const String ldap_server_config = \"ldap_servers.\" + name;\n \n     const bool has_host = config.has(ldap_server_config + \".host\");\n@@ -34,6 +63,7 @@ auto parseLDAPServer(const Poco::Util::AbstractConfiguration & config, const Str\n     const bool has_bind_dn = config.has(ldap_server_config + \".bind_dn\");\n     const bool has_auth_dn_prefix = config.has(ldap_server_config + \".auth_dn_prefix\");\n     const bool has_auth_dn_suffix = config.has(ldap_server_config + \".auth_dn_suffix\");\n+    const bool has_user_dn_detection = config.has(ldap_server_config + \".user_dn_detection\");\n     const bool has_verification_cooldown = config.has(ldap_server_config + \".verification_cooldown\");\n     const bool has_enable_tls = config.has(ldap_server_config + \".enable_tls\");\n     const bool has_tls_minimum_protocol_version = config.has(ldap_server_config + \".tls_minimum_protocol_version\");\n@@ -66,6 +96,17 @@ auto parseLDAPServer(const Poco::Util::AbstractConfiguration & config, const Str\n         params.bind_dn = auth_dn_prefix + \"{user_name}\" + auth_dn_suffix;\n     }\n \n+    if (has_user_dn_detection)\n+    {\n+        if (!params.user_dn_detection)\n+        {\n+            params.user_dn_detection.emplace();\n+            params.user_dn_detection->attribute = \"dn\";\n+        }\n+\n+        parseLDAPSearchParams(*params.user_dn_detection, config, ldap_server_config + \".user_dn_detection\");\n+    }\n+\n     if (has_verification_cooldown)\n         params.verification_cooldown = std::chrono::seconds{config.getUInt64(ldap_server_config + \".verification_cooldown\")};\n \n@@ -143,14 +184,10 @@ auto parseLDAPServer(const Poco::Util::AbstractConfiguration & config, const Str\n     }\n     else\n         params.port = (params.enable_tls == LDAPClient::Params::TLSEnable::YES ? 636 : 389);\n-\n-    return params;\n }\n \n-auto parseKerberosParams(const Poco::Util::AbstractConfiguration & config)\n+void parseKerberosParams(GSSAcceptorContext::Params & params, const Poco::Util::AbstractConfiguration & config)\n {\n-    GSSAcceptorContext::Params params;\n-\n     Poco::Util::AbstractConfiguration::Keys keys;\n     config.keys(\"kerberos\", keys);\n \n@@ -180,10 +217,18 @@ auto parseKerberosParams(const Poco::Util::AbstractConfiguration & config)\n \n     params.realm = config.getString(\"kerberos.realm\", \"\");\n     params.principal = config.getString(\"kerberos.principal\", \"\");\n+}\n \n-    return params;\n }\n \n+void parseLDAPRoleSearchParams(LDAPClient::RoleSearchParams & params, const Poco::Util::AbstractConfiguration & config, const String & prefix)\n+{\n+    parseLDAPSearchParams(params, config, prefix);\n+\n+    const bool has_prefix = config.has(prefix + \".prefix\");\n+\n+    if (has_prefix)\n+        params.prefix = config.getString(prefix + \".prefix\");\n }\n \n void ExternalAuthenticators::reset()\n@@ -229,7 +274,8 @@ void ExternalAuthenticators::setConfiguration(const Poco::Util::AbstractConfigur\n     {\n         try\n         {\n-            ldap_client_params_blueprint.insert_or_assign(ldap_server_name, parseLDAPServer(config, ldap_server_name));\n+            ldap_client_params_blueprint.erase(ldap_server_name);\n+            parseLDAPServer(ldap_client_params_blueprint.emplace(ldap_server_name, LDAPClient::Params{}).first->second, config, ldap_server_name);\n         }\n         catch (...)\n         {\n@@ -240,7 +286,7 @@ void ExternalAuthenticators::setConfiguration(const Poco::Util::AbstractConfigur\n     try\n     {\n         if (kerberos_keys_count > 0)\n-            kerberos_params = parseKerberosParams(config);\n+            parseKerberosParams(kerberos_params.emplace(), config);\n     }\n     catch (...)\n     {\n@@ -249,7 +295,7 @@ void ExternalAuthenticators::setConfiguration(const Poco::Util::AbstractConfigur\n }\n \n bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const BasicCredentials & credentials,\n-    const LDAPClient::SearchParamsList * search_params, LDAPClient::SearchResultsList * search_results) const\n+    const LDAPClient::RoleSearchParamsList * role_search_params, LDAPClient::SearchResultsList * role_search_results) const\n {\n     std::optional<LDAPClient::Params> params;\n     std::size_t params_hash = 0;\n@@ -267,9 +313,9 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const B\n         params->password = credentials.getPassword();\n \n         params->combineCoreHash(params_hash);\n-        if (search_params)\n+        if (role_search_params)\n         {\n-            for (const auto & params_instance : *search_params)\n+            for (const auto & params_instance : *role_search_params)\n             {\n                 params_instance.combineHash(params_hash);\n             }\n@@ -301,14 +347,14 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const B\n \n                         // Ensure that search_params are compatible.\n                         (\n-                            search_params == nullptr ?\n-                            entry.last_successful_search_results.empty() :\n-                            search_params->size() == entry.last_successful_search_results.size()\n+                            role_search_params == nullptr ?\n+                            entry.last_successful_role_search_results.empty() :\n+                            role_search_params->size() == entry.last_successful_role_search_results.size()\n                         )\n                     )\n                     {\n-                        if (search_results)\n-                            *search_results = entry.last_successful_search_results;\n+                        if (role_search_results)\n+                            *role_search_results = entry.last_successful_role_search_results;\n \n                         return true;\n                     }\n@@ -326,7 +372,7 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const B\n     }\n \n     LDAPSimpleAuthClient client(params.value());\n-    const auto result = client.authenticate(search_params, search_results);\n+    const auto result = client.authenticate(role_search_params, role_search_results);\n     const auto current_check_timestamp = std::chrono::steady_clock::now();\n \n     // Update the cache, but only if this is the latest check and the server is still configured in a compatible way.\n@@ -345,9 +391,9 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const B\n \n         std::size_t new_params_hash = 0;\n         new_params.combineCoreHash(new_params_hash);\n-        if (search_params)\n+        if (role_search_params)\n         {\n-            for (const auto & params_instance : *search_params)\n+            for (const auto & params_instance : *role_search_params)\n             {\n                 params_instance.combineHash(new_params_hash);\n             }\n@@ -363,17 +409,17 @@ bool ExternalAuthenticators::checkLDAPCredentials(const String & server, const B\n             entry.last_successful_params_hash = params_hash;\n             entry.last_successful_authentication_timestamp = current_check_timestamp;\n \n-            if (search_results)\n-                entry.last_successful_search_results = *search_results;\n+            if (role_search_results)\n+                entry.last_successful_role_search_results = *role_search_results;\n             else\n-                entry.last_successful_search_results.clear();\n+                entry.last_successful_role_search_results.clear();\n         }\n         else if (\n             entry.last_successful_params_hash != params_hash ||\n             (\n-                search_params == nullptr ?\n-                !entry.last_successful_search_results.empty() :\n-                search_params->size() != entry.last_successful_search_results.size()\n+                role_search_params == nullptr ?\n+                !entry.last_successful_role_search_results.empty() :\n+                role_search_params->size() != entry.last_successful_role_search_results.size()\n             )\n         )\n         {\ndiff --git a/src/Access/ExternalAuthenticators.h b/src/Access/ExternalAuthenticators.h\nindex c8feea7eada9..24f1f7b65282 100644\n--- a/src/Access/ExternalAuthenticators.h\n+++ b/src/Access/ExternalAuthenticators.h\n@@ -34,7 +34,7 @@ class ExternalAuthenticators\n \n     // The name and readiness of the credentials must be verified before calling these.\n     bool checkLDAPCredentials(const String & server, const BasicCredentials & credentials,\n-        const LDAPClient::SearchParamsList * search_params = nullptr, LDAPClient::SearchResultsList * search_results = nullptr) const;\n+        const LDAPClient::RoleSearchParamsList * role_search_params = nullptr, LDAPClient::SearchResultsList * role_search_results = nullptr) const;\n     bool checkKerberosCredentials(const String & realm, const GSSAcceptorContext & credentials) const;\n \n     GSSAcceptorContext::Params getKerberosParams() const;\n@@ -44,7 +44,7 @@ class ExternalAuthenticators\n     {\n         std::size_t last_successful_params_hash = 0;\n         std::chrono::steady_clock::time_point last_successful_authentication_timestamp;\n-        LDAPClient::SearchResultsList last_successful_search_results;\n+        LDAPClient::SearchResultsList last_successful_role_search_results;\n     };\n \n     using LDAPCache = std::unordered_map<String, LDAPCacheEntry>; // user name   -> cache entry\n@@ -58,4 +58,6 @@ class ExternalAuthenticators\n     std::optional<GSSAcceptorContext::Params> kerberos_params;\n };\n \n+void parseLDAPRoleSearchParams(LDAPClient::RoleSearchParams & params, const Poco::Util::AbstractConfiguration & config, const String & prefix);\n+\n }\ndiff --git a/src/Access/LDAPAccessStorage.cpp b/src/Access/LDAPAccessStorage.cpp\nindex b47a9b3e0418..c1d54e8c9aa7 100644\n--- a/src/Access/LDAPAccessStorage.cpp\n+++ b/src/Access/LDAPAccessStorage.cpp\n@@ -68,34 +68,15 @@ void LDAPAccessStorage::setConfiguration(AccessControlManager * access_control_m\n         common_roles_cfg.insert(role_names.begin(), role_names.end());\n     }\n \n-    LDAPClient::SearchParamsList role_search_params_cfg;\n+    LDAPClient::RoleSearchParamsList role_search_params_cfg;\n     if (has_role_mapping)\n     {\n         Poco::Util::AbstractConfiguration::Keys all_keys;\n         config.keys(prefix, all_keys);\n         for (const auto & key : all_keys)\n         {\n-            if (key != \"role_mapping\" && key.find(\"role_mapping[\") != 0)\n-                continue;\n-\n-            const String rm_prefix = prefix_str + key;\n-            const String rm_prefix_str = rm_prefix + '.';\n-            role_search_params_cfg.emplace_back();\n-            auto & rm_params = role_search_params_cfg.back();\n-\n-            rm_params.base_dn = config.getString(rm_prefix_str + \"base_dn\", \"\");\n-            rm_params.search_filter = config.getString(rm_prefix_str + \"search_filter\", \"\");\n-            rm_params.attribute = config.getString(rm_prefix_str + \"attribute\", \"cn\");\n-            rm_params.prefix = config.getString(rm_prefix_str + \"prefix\", \"\");\n-\n-            auto scope = config.getString(rm_prefix_str + \"scope\", \"subtree\");\n-            boost::algorithm::to_lower(scope);\n-            if (scope == \"base\")           rm_params.scope = LDAPClient::SearchParams::Scope::BASE;\n-            else if (scope == \"one_level\") rm_params.scope = LDAPClient::SearchParams::Scope::ONE_LEVEL;\n-            else if (scope == \"subtree\")   rm_params.scope = LDAPClient::SearchParams::Scope::SUBTREE;\n-            else if (scope == \"children\")  rm_params.scope = LDAPClient::SearchParams::Scope::CHILDREN;\n-            else\n-                throw Exception(\"Invalid value of 'scope' field in '\" + key + \"' section of LDAP user directory, must be one of 'base', 'one_level', 'subtree', or 'children'\", ErrorCodes::BAD_ARGUMENTS);\n+            if (key == \"role_mapping\" || key.find(\"role_mapping[\") == 0)\n+                parseLDAPRoleSearchParams(role_search_params_cfg.emplace_back(), config, prefix_str + key);\n         }\n     }\n \n@@ -364,7 +345,7 @@ std::set<String> LDAPAccessStorage::mapExternalRolesNoLock(const LDAPClient::Sea\n \n \n bool LDAPAccessStorage::areLDAPCredentialsValidNoLock(const User & user, const Credentials & credentials,\n-    const ExternalAuthenticators & external_authenticators, LDAPClient::SearchResultsList & search_results) const\n+    const ExternalAuthenticators & external_authenticators, LDAPClient::SearchResultsList & role_search_results) const\n {\n     if (!credentials.isReady())\n         return false;\n@@ -373,7 +354,7 @@ bool LDAPAccessStorage::areLDAPCredentialsValidNoLock(const User & user, const C\n         return false;\n \n     if (const auto * basic_credentials = dynamic_cast<const BasicCredentials *>(&credentials))\n-        return external_authenticators.checkLDAPCredentials(ldap_server_name, *basic_credentials, &role_search_params, &search_results);\n+        return external_authenticators.checkLDAPCredentials(ldap_server_name, *basic_credentials, &role_search_params, &role_search_results);\n \n     return false;\n }\ndiff --git a/src/Access/LDAPAccessStorage.h b/src/Access/LDAPAccessStorage.h\nindex ea0ab47c2259..33ac9f0a914d 100644\n--- a/src/Access/LDAPAccessStorage.h\n+++ b/src/Access/LDAPAccessStorage.h\n@@ -68,12 +68,12 @@ class LDAPAccessStorage : public IAccessStorage\n     void updateAssignedRolesNoLock(const UUID & id, const String & user_name, const LDAPClient::SearchResultsList & external_roles) const;\n     std::set<String> mapExternalRolesNoLock(const LDAPClient::SearchResultsList & external_roles) const;\n     bool areLDAPCredentialsValidNoLock(const User & user, const Credentials & credentials,\n-        const ExternalAuthenticators & external_authenticators, LDAPClient::SearchResultsList & search_results) const;\n+        const ExternalAuthenticators & external_authenticators, LDAPClient::SearchResultsList & role_search_results) const;\n \n     mutable std::recursive_mutex mutex;\n     AccessControlManager * access_control_manager = nullptr;\n     String ldap_server_name;\n-    LDAPClient::SearchParamsList role_search_params;\n+    LDAPClient::RoleSearchParamsList role_search_params;\n     std::set<String> common_role_names;                         // role name that should be granted to all users at all times\n     mutable std::map<String, std::size_t> external_role_hashes; // user name -> LDAPClient::SearchResultsList hash (most recently retrieved and processed)\n     mutable std::map<String, std::set<String>> users_per_roles; // role name -> user names (...it should be granted to; may but don't have to exist for common roles)\ndiff --git a/src/Access/LDAPClient.cpp b/src/Access/LDAPClient.cpp\nindex 5c4b7dd8d991..a8f9675774b0 100644\n--- a/src/Access/LDAPClient.cpp\n+++ b/src/Access/LDAPClient.cpp\n@@ -32,6 +32,11 @@ void LDAPClient::SearchParams::combineHash(std::size_t & seed) const\n     boost::hash_combine(seed, static_cast<int>(scope));\n     boost::hash_combine(seed, search_filter);\n     boost::hash_combine(seed, attribute);\n+}\n+\n+void LDAPClient::RoleSearchParams::combineHash(std::size_t & seed) const\n+{\n+    SearchParams::combineHash(seed);\n     boost::hash_combine(seed, prefix);\n }\n \n@@ -42,6 +47,9 @@ void LDAPClient::Params::combineCoreHash(std::size_t & seed) const\n     boost::hash_combine(seed, bind_dn);\n     boost::hash_combine(seed, user);\n     boost::hash_combine(seed, password);\n+\n+    if (user_dn_detection)\n+        user_dn_detection->combineHash(seed);\n }\n \n LDAPClient::LDAPClient(const Params & params_)\n@@ -286,18 +294,33 @@ void LDAPClient::openConnection()\n     if (params.enable_tls == LDAPClient::Params::TLSEnable::YES_STARTTLS)\n         diag(ldap_start_tls_s(handle, nullptr, nullptr));\n \n+    final_user_name = escapeForLDAP(params.user);\n+    final_bind_dn = replacePlaceholders(params.bind_dn, { {\"{user_name}\", final_user_name} });\n+    final_user_dn = final_bind_dn; // The default value... may be updated right after a successful bind.\n+\n     switch (params.sasl_mechanism)\n     {\n         case LDAPClient::Params::SASLMechanism::SIMPLE:\n         {\n-            const auto escaped_user_name = escapeForLDAP(params.user);\n-            const auto bind_dn = replacePlaceholders(params.bind_dn, { {\"{user_name}\", escaped_user_name} });\n-\n             ::berval cred;\n             cred.bv_val = const_cast<char *>(params.password.c_str());\n             cred.bv_len = params.password.size();\n \n-            diag(ldap_sasl_bind_s(handle, bind_dn.c_str(), LDAP_SASL_SIMPLE, &cred, nullptr, nullptr, nullptr));\n+            diag(ldap_sasl_bind_s(handle, final_bind_dn.c_str(), LDAP_SASL_SIMPLE, &cred, nullptr, nullptr, nullptr));\n+\n+            // Once bound, run the user DN search query and update the default value, if asked.\n+            if (params.user_dn_detection)\n+            {\n+                const auto user_dn_search_results = search(*params.user_dn_detection);\n+\n+                if (user_dn_search_results.empty())\n+                    throw Exception(\"Failed to detect user DN: empty search results\", ErrorCodes::LDAP_ERROR);\n+\n+                if (user_dn_search_results.size() > 1)\n+                    throw Exception(\"Failed to detect user DN: more than one entry in the search results\", ErrorCodes::LDAP_ERROR);\n+\n+                final_user_dn = *user_dn_search_results.begin();\n+            }\n \n             break;\n         }\n@@ -316,6 +339,9 @@ void LDAPClient::closeConnection() noexcept\n \n     ldap_unbind_ext_s(handle, nullptr, nullptr);\n     handle = nullptr;\n+    final_user_name.clear();\n+    final_bind_dn.clear();\n+    final_user_dn.clear();\n }\n \n LDAPClient::SearchResults LDAPClient::search(const SearchParams & search_params)\n@@ -333,10 +359,19 @@ LDAPClient::SearchResults LDAPClient::search(const SearchParams & search_params)\n         case SearchParams::Scope::CHILDREN:  scope = LDAP_SCOPE_CHILDREN; break;\n     }\n \n-    const auto escaped_user_name = escapeForLDAP(params.user);\n-    const auto bind_dn = replacePlaceholders(params.bind_dn, { {\"{user_name}\", escaped_user_name} });\n-    const auto base_dn = replacePlaceholders(search_params.base_dn, { {\"{user_name}\", escaped_user_name}, {\"{bind_dn}\", bind_dn} });\n-    const auto search_filter = replacePlaceholders(search_params.search_filter, { {\"{user_name}\", escaped_user_name}, {\"{bind_dn}\", bind_dn}, {\"{base_dn}\", base_dn} });\n+    const auto final_base_dn = replacePlaceholders(search_params.base_dn, {\n+        {\"{user_name}\", final_user_name},\n+        {\"{bind_dn}\", final_bind_dn},\n+        {\"{user_dn}\", final_user_dn}\n+    });\n+\n+    const auto final_search_filter = replacePlaceholders(search_params.search_filter, {\n+        {\"{user_name}\", final_user_name},\n+        {\"{bind_dn}\", final_bind_dn},\n+        {\"{user_dn}\", final_user_dn},\n+        {\"{base_dn}\", final_base_dn}\n+    });\n+\n     char * attrs[] = { const_cast<char *>(search_params.attribute.c_str()), nullptr };\n     ::timeval timeout = { params.search_timeout.count(), 0 };\n     LDAPMessage* msgs = nullptr;\n@@ -349,7 +384,7 @@ LDAPClient::SearchResults LDAPClient::search(const SearchParams & search_params)\n         }\n     });\n \n-    diag(ldap_search_ext_s(handle, base_dn.c_str(), scope, search_filter.c_str(), attrs, 0, nullptr, nullptr, &timeout, params.search_limit, &msgs));\n+    diag(ldap_search_ext_s(handle, final_base_dn.c_str(), scope, final_search_filter.c_str(), attrs, 0, nullptr, nullptr, &timeout, params.search_limit, &msgs));\n \n     for (\n          auto * msg = ldap_first_message(handle, msgs);\n@@ -361,6 +396,27 @@ LDAPClient::SearchResults LDAPClient::search(const SearchParams & search_params)\n         {\n             case LDAP_RES_SEARCH_ENTRY:\n             {\n+                // Extract DN separately, if the requested attribute is DN.\n+                if (boost::iequals(\"dn\", search_params.attribute))\n+                {\n+                    BerElement * ber = nullptr;\n+\n+                    SCOPE_EXIT({\n+                        if (ber)\n+                        {\n+                            ber_free(ber, 0);\n+                            ber = nullptr;\n+                        }\n+                    });\n+\n+                    ::berval bv;\n+\n+                    diag(ldap_get_dn_ber(handle, msg, &ber, &bv));\n+\n+                    if (bv.bv_val && bv.bv_len > 0)\n+                        result.emplace(bv.bv_val, bv.bv_len);\n+                }\n+\n                 BerElement * ber = nullptr;\n \n                 SCOPE_EXIT({\n@@ -471,12 +527,12 @@ LDAPClient::SearchResults LDAPClient::search(const SearchParams & search_params)\n     return result;\n }\n \n-bool LDAPSimpleAuthClient::authenticate(const SearchParamsList * search_params, SearchResultsList * search_results)\n+bool LDAPSimpleAuthClient::authenticate(const RoleSearchParamsList * role_search_params, SearchResultsList * role_search_results)\n {\n     if (params.user.empty())\n         throw Exception(\"LDAP authentication of a user with empty name is not allowed\", ErrorCodes::BAD_ARGUMENTS);\n \n-    if (!search_params != !search_results)\n+    if (!role_search_params != !role_search_results)\n         throw Exception(\"Cannot return LDAP search results\", ErrorCodes::BAD_ARGUMENTS);\n \n     // Silently reject authentication attempt if the password is empty as if it didn't match.\n@@ -489,21 +545,21 @@ bool LDAPSimpleAuthClient::authenticate(const SearchParamsList * search_params,\n     openConnection();\n \n     // While connected, run search queries and save the results, if asked.\n-    if (search_params)\n+    if (role_search_params)\n     {\n-        search_results->clear();\n-        search_results->reserve(search_params->size());\n+        role_search_results->clear();\n+        role_search_results->reserve(role_search_params->size());\n \n         try\n         {\n-            for (const auto & single_search_params : *search_params)\n+            for (const auto & params_instance : *role_search_params)\n             {\n-                search_results->emplace_back(search(single_search_params));\n+                role_search_results->emplace_back(search(params_instance));\n             }\n         }\n         catch (...)\n         {\n-            search_results->clear();\n+            role_search_results->clear();\n             throw;\n         }\n     }\n@@ -532,7 +588,7 @@ LDAPClient::SearchResults LDAPClient::search(const SearchParams &)\n     throw Exception(\"ClickHouse was built without LDAP support\", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);\n }\n \n-bool LDAPSimpleAuthClient::authenticate(const SearchParamsList *, SearchResultsList *)\n+bool LDAPSimpleAuthClient::authenticate(const RoleSearchParamsList *, SearchResultsList *)\n {\n     throw Exception(\"ClickHouse was built without LDAP support\", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);\n }\ndiff --git a/src/Access/LDAPClient.h b/src/Access/LDAPClient.h\nindex 4fc97bb957b2..388e7ad0f0d3 100644\n--- a/src/Access/LDAPClient.h\n+++ b/src/Access/LDAPClient.h\n@@ -38,12 +38,20 @@ class LDAPClient\n         Scope scope = Scope::SUBTREE;\n         String search_filter;\n         String attribute = \"cn\";\n+\n+        void combineHash(std::size_t & seed) const;\n+    };\n+\n+    struct RoleSearchParams\n+        : public SearchParams\n+    {\n         String prefix;\n \n         void combineHash(std::size_t & seed) const;\n     };\n \n-    using SearchParamsList = std::vector<SearchParams>;\n+    using RoleSearchParamsList = std::vector<RoleSearchParams>;\n+\n     using SearchResults = std::set<String>;\n     using SearchResultsList = std::vector<SearchResults>;\n \n@@ -105,6 +113,8 @@ class LDAPClient\n         String user;\n         String password;\n \n+        std::optional<SearchParams> user_dn_detection;\n+\n         std::chrono::seconds verification_cooldown{0};\n \n         std::chrono::seconds operation_timeout{40};\n@@ -134,6 +144,9 @@ class LDAPClient\n #if USE_LDAP\n     LDAP * handle = nullptr;\n #endif\n+    String final_user_name;\n+    String final_bind_dn;\n+    String final_user_dn;\n };\n \n class LDAPSimpleAuthClient\n@@ -141,7 +154,7 @@ class LDAPSimpleAuthClient\n {\n public:\n     using LDAPClient::LDAPClient;\n-    bool authenticate(const SearchParamsList * search_params, SearchResultsList * search_results);\n+    bool authenticate(const RoleSearchParamsList * role_search_params, SearchResultsList * role_search_results);\n };\n \n }\n",
  "test_patch": "diff --git a/tests/testflows/ldap/role_mapping/tests/user_dn_detection.py b/tests/testflows/ldap/role_mapping/tests/user_dn_detection.py\nindex b1a74d6e6b5f..147da8a5dcc7 100644\n--- a/tests/testflows/ldap/role_mapping/tests/user_dn_detection.py\n+++ b/tests/testflows/ldap/role_mapping/tests/user_dn_detection.py\n@@ -33,7 +33,7 @@ def check_config(self, entries, valid=True, ldap_server=\"openldap1\", user=\"user1\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_BaseDN(\"1.0\")\n )\n def config_invalid_base_dn(self):\n     \"\"\"Check when invalid `base_dn` is specified in the user_dn_detection section.\n@@ -62,7 +62,7 @@ def config_invalid_base_dn(self):\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_BaseDN(\"1.0\")\n )\n def config_empty_base_dn(self):\n     \"\"\"Check when empty `base_dn` is specified in the user_dn_detection section.\n@@ -90,7 +90,7 @@ def config_empty_base_dn(self):\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_BaseDN(\"1.0\")\n )\n def config_missing_base_dn(self):\n     \"\"\"Check when missing `base_dn` is specified in the user_dn_detection section.\n@@ -145,7 +145,7 @@ def config_invalid_search_filter(self):\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_SearchFilter(\"1.0\")\n )\n def config_missing_search_filter(self):\n     \"\"\"Check when missing `search_filter` is specified in the user_dn_detection section.\n@@ -172,7 +172,7 @@ def config_missing_search_filter(self):\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_SearchFilter(\"1.0\")\n )\n def config_empty_search_filter(self):\n     \"\"\"Check when empty `search_filter` is specified in the user_dn_detection section.\n@@ -200,7 +200,8 @@ def config_empty_search_filter(self):\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_BaseDN(\"1.0\"),\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_SearchFilter(\"1.0\")\n )\n def config_valid(self):\n     \"\"\"Check valid config with valid user_dn_detection section.\n@@ -228,7 +229,8 @@ def config_valid(self):\n @TestScenario\n @Tags(\"config\")\n @Requirements(\n-    # FIXME\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_BaseDN(\"1.0\"),\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_SearchFilter(\"1.0\")\n )\n def config_valid_tls_connection(self):\n     \"\"\"Check valid config with valid user_dn_detection section when\n@@ -256,6 +258,9 @@ def config_valid_tls_connection(self):\n     check_config(entries=entries, valid=True, ldap_server=\"openldap2\", user=\"user2\", password=\"user2\")\n \n @TestOutline(Scenario)\n+@Requirements(\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection_Scope(\"1.0\")\n+)\n @Examples(\"scope base_dn\", [\n     (\"base\", \"cn=user1,ou=users,dc=company,dc=com\"),\n     (\"one_level\",\"ou=users,dc=company,dc=com\"),\n@@ -399,9 +404,6 @@ def setup_different_bind_dn_and_user_dn(self, uid, map_by, user_dn_detection):\n             role_mappings=role_mappings, restart=True)\n \n @TestScenario\n-@Requirements(\n-    # FIXME:\n-)\n def map_roles_by_user_dn_when_base_dn_and_user_dn_are_different(self):\n     \"\"\"Check the case when we map roles using user_dn then\n     the first user has uid of second user and second user\n@@ -429,9 +431,6 @@ def map_roles_by_user_dn_when_base_dn_and_user_dn_are_different(self):\n         assert f\"GRANT role0_{uid} TO second_user\" in r.output, error()\n \n @TestScenario\n-@Requirements(\n-    # FIXME:\n-)\n def map_roles_by_bind_dn_when_base_dn_and_user_dn_are_different(self):\n     \"\"\"Check the case when we map roles by bind_dn when bind_dn and user_dn\n     are different.\n@@ -457,7 +456,7 @@ def map_roles_by_bind_dn_when_base_dn_and_user_dn_are_different(self):\n @TestFeature\n @Name(\"user dn detection\")\n @Requirements(\n-    #RQ_SRS_014_LDAP_UserDNDetection(\"1.0\")\n+    RQ_SRS_014_LDAP_RoleMapping_Configuration_Server_UserDNDetection(\"1.0\")\n )\n def feature(self):\n     \"\"\"Check LDAP user DN detection.\ndiff --git a/tests/testflows/regression.py b/tests/testflows/regression.py\nindex 21e65ef73c5d..2547463a91d5 100755\n--- a/tests/testflows/regression.py\n+++ b/tests/testflows/regression.py\n@@ -29,7 +29,7 @@ def regression(self, local, clickhouse_binary_path, stress=None, parallel=None):\n             run_scenario(pool, tasks, Feature(test=load(\"map_type.regression\", \"regression\")), args)\n             run_scenario(pool, tasks, Feature(test=load(\"window_functions.regression\", \"regression\")), args)\n             run_scenario(pool, tasks, Feature(test=load(\"datetime64_extended_range.regression\", \"regression\")), args)\n-            # run_scenario(pool, tasks, Feature(test=load(\"kerberos.regression\", \"regression\")), args)\n+            #run_scenario(pool, tasks, Feature(test=load(\"kerberos.regression\", \"regression\")), args)\n         finally:\n             join(tasks)\n \n",
  "problem_statement": "Use service account for LDAP\n**Use case**\r\nIn some organisations are using AD with hierarchical structure (nested organisation unit) and DN follow this structure. As result we can not  use permanent build_dn for users with different OU.\r\n\r\n**Describe the solution you'd like**\r\nSolution can be look like:\r\n1) bind as service account\r\n2) set dn for user_name by some filter string to user_dn\r\n3) bind as user_dn with password\r\n3) use user_dn with filter for group/roles fetching\r\n\r\nThis approach is implemented in Metabase.\r\n\n",
  "hints_text": "/cc @traceon \nAre users defined in `ou`s or referenced there? They should be referenced there but defined somewhere else, as I understand. And that place should serve as a `bind_dn`.\r\n\r\nIf not, nothing prevents you from defining multiple ldap servers with different `bind_dn`'s for users in different `ou`s.\nAs I can understand they are defined in this OU.\r\n\r\nDo you mean define in `user_directories` multiple `ldap` section  with different `server`. But this do not solve second problem. For example.\r\n\r\nWe have such users\r\n```\r\nCN=\u0418\u0432\u0430\u043d\u043e\u0432 \u0418\u0432\u0430\u043d \u0418\u0432\u0430\u043d\u043e\u0432\u0438\u0447,OU=users_l0.1.1.2,OU=users_l0.1.1,OU=users_l0.1,OU=users_l0,DC=domain,DC=tld + sAMAccountName=i.i.ivanov\r\n\r\nCN=\u041f\u0435\u0442\u0440\u043e\u0432 \u0421\u0435\u0440\u0433\u0435\u0439 \u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440\u043e\u0432\u0438\u0447,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld + sAMAccountName=s.v.petrov\r\n```\r\nWith ldap_server configured as:\r\n```\r\n<my_ldap_server>\r\n  <host>ldap.domain.tld</host>\r\n  <port>389</port>\r\n  <bind_dn>DOMAIN\\{user_name}</bind_dn>\r\n  <verification_cooldown>300</verification_cooldown>\r\n  <enable_tls>no</enable_tls>\r\n</my_ldap_server>\r\n```\r\nWe can successful bind user and login to clickhouse with `i.i.ivanov` or `s.v.petrov`. \r\nFor get the groups we should build filter strings:\r\n```\r\n(&(objectClass=group)(member=CN=\u0418\u0432\u0430\u043d\u043e\u0432 \u0418\u0432\u0430\u043d \u0418\u0432\u0430\u043d\u043e\u0432\u0438\u0447,OU=users_l0.1.1,OU=users_l0.1.1,OU=users_l0.1,OU=users_l0,DC=domain,DC=tld))\r\n\r\n(&(objectClass=group)(member=CN=\u041f\u0435\u0442\u0440\u043e\u0432 \u0421\u0435\u0440\u0433\u0435\u0439 \u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440\u043e\u0432\u0438\u0447,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld))\r\n```\r\nBut I don\u2019t know how to do it.\nHow does the content of `OU=users_l0.2,OU=users_l0,DC=domain,DC=tld` look like?\n```\r\nCN=\u041f\u0435\u0442\u0440\u043e\u0432 \u0421\u0435\u0440\u0433\u0435\u0439 \u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440\u043e\u0432\u0438\u0447,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld  objectClass=person,top,user\r\nCN=\u0421\u043c\u0438\u0440\u043d\u043e\u0432 \u0414\u043c\u0438\u0442\u0440\u0438\u0439 \u0412\u0438\u0442\u0430\u043b\u044c\u0435\u0432\u0438\u0447,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld objectClass=person,top,user\r\nOU=users_l0.2.1,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld objectClass=top,organizationalUnit\r\nOU=users_l0.2.2,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld objectClass=top,organizationalUnit\r\n...\r\n```\r\n\r\nI am consulted with our admins, we can't make DN with flat structure.\r\n\n> We can successful bind user and login to clickhouse with i.i.ivanov or s.v.petrov.\r\n\r\nWhere is this specified? How do the records above associate to these user names?\n> > We can successful bind user and login to clickhouse with i.i.ivanov or s.v.petrov.\r\n> \r\n> Where is this specified? How do the records above associate to these user names?\r\n\r\nIn config:\r\n```\r\n<bind_dn>DOMAIN\\{user_name}</bind_dn>\r\n```\r\nIt's allow bind user. AD support this DN string and if I'm made request from console:\r\n```\r\nldapwhoami -H \"ldap://ldap.domain.tld\" -D 'CN=\u041f\u0435\u0442\u0440\u043e\u0432 \u0421\u0435\u0440\u0433\u0435\u0439 \u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440\u043e\u0432\u0438\u0447,OU=users_l0.2,OU=users_l0,DC=domain,DC=tld'  -W\r\nldapwhoami -H \"ldap://ldap.domain.tld\" -D 'DOMAIN\\s.v.petrov'  -W\r\n```\r\nI get the same result: `DOMAIN\\s.v.petrov`\nOU is a \"group\", you usually put references there (the `member=CN=\u041f\u0435\u0442\u0440\u043e\u0432 \u0421\u0435\u0440\u0433\u0435\u0439 \u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440\u043e\u0432\u0438\u0447` attribute), to the actual DN with user definition. So I am asking, where that user definition is located?\r\n\nWhat is the output of\r\n\r\n```sh\r\ndsquery user -name s.v.petrov\r\n```\r\n\r\nand\r\n\r\n```sh \r\ndsquery group -name users_l0.2\r\n```\r\n?\nAfter discussing this in chat, the missing part was identified to be a `{user_dn}` substitution in `<search_filter>` section specifically, which would store the real DN of the user. By default, it could be equal to `bind_dn` itself, but for cases like this issue, a separate LDAP search should be performed to retrieve that `user_dn`. So another search filter must be configured for that: `<user_dn_search_filter>` and `<user_dn_search_base>`.",
  "created_at": "2021-03-28T22:33:05Z",
  "modified_files": [
    "docs/en/operations/external-authenticators/ldap.md",
    "programs/server/config.xml",
    "src/Access/ExternalAuthenticators.cpp",
    "src/Access/ExternalAuthenticators.h",
    "src/Access/LDAPAccessStorage.cpp",
    "src/Access/LDAPAccessStorage.h",
    "src/Access/LDAPClient.cpp",
    "src/Access/LDAPClient.h"
  ],
  "modified_test_files": [
    "tests/testflows/ldap/role_mapping/tests/user_dn_detection.py",
    "tests/testflows/regression.py"
  ]
}