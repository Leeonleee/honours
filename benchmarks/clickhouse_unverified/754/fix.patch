diff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h b/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h
index 30d17f3cd0d8..92ba5da9f4ed 100644
--- a/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h
+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h
@@ -96,7 +96,7 @@ class Crypto_API Cipher: public Poco::RefCountedObject
 		ENC_BASE64       = 0x01, /// Base64-encoded output
 		ENC_BINHEX       = 0x02, /// BinHex-encoded output
 		ENC_BASE64_NO_LF = 0x81, /// Base64-encoded output, no linefeeds
-		ENC_BINHEX_NO_LF = 0x82, /// BinHex-encoded output, no linefeeds
+		ENC_BINHEX_NO_LF = 0x82  /// BinHex-encoded output, no linefeeds
 		
 	};
 
diff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h b/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h
index 1ed50941da1e..fcfb20ec26f5 100644
--- a/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h
+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h
@@ -22,7 +22,6 @@
 #define Crypto_Crypto_INCLUDED
 
 
-#pragma GCC diagnostic push
 #if defined(__APPLE__)
 // OS X 10.7 deprecates some OpenSSL functions
 #pragma GCC diagnostic ignored "-Wdeprecated-declarations" 
@@ -116,6 +115,5 @@ void Crypto_API uninitializeCrypto();
 
 } } // namespace Poco::Crypto
 
-#pragma GCC diagnostic pop
 
 #endif // Crypto_Crypto_INCLUDED
diff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h b/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h
index 5de75392a833..e2121c414dfd 100644
--- a/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h
+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h
@@ -61,7 +61,7 @@ class Crypto_API DigestEngine: public Poco::DigestEngine
 	
 private:
 	std::string _name;
-	EVP_MD_CTX* _ctx;
+	EVP_MD_CTX* _pContext;
 	Poco::DigestEngine::Digest _digest;
 	OpenSSLInitializer _openSSLInitializer;
 };
diff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h b/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h
index 472c537637ef..a6d86901248d 100644
--- a/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h
+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h
@@ -130,6 +130,14 @@ class Crypto_API X509Certificate
 		/// Returns true if verification against the issuer certificate
 		/// was successfull, false otherwise.
 
+	bool equals(const X509Certificate& otherCertificate) const;
+		/// Checks whether the certificate is equal to
+		/// the other certificate, by comparing the hashes
+		/// of both certificates.
+		///
+		/// Returns true if both certificates are identical,
+		/// otherwise false.
+
 	const X509* certificate() const;
 		/// Returns the underlying OpenSSL certificate.
 
diff --git a/contrib/libpoco/Crypto/src/CipherImpl.cpp b/contrib/libpoco/Crypto/src/CipherImpl.cpp
index c953aae52e2e..b8708a78c81d 100644
--- a/contrib/libpoco/Crypto/src/CipherImpl.cpp
+++ b/contrib/libpoco/Crypto/src/CipherImpl.cpp
@@ -30,7 +30,7 @@ namespace
 	{
 		unsigned long err;
 		std::string msg;
-
+		
 		while ((err = ERR_get_error()))
 		{
 			if (!msg.empty())
@@ -60,24 +60,28 @@ namespace
 			Direction         dir);
 
 		~CryptoTransformImpl();
-
+		
 		std::size_t blockSize() const;
 
-		int setPadding(int padding);
+		int setPadding(int padding);	
 
 		std::streamsize transform(
 			const unsigned char* input,
 			std::streamsize      inputLength,
 			unsigned char*       output,
 			std::streamsize      outputLength);
-
+		
 		std::streamsize finalize(
 			unsigned char*  output,
 			std::streamsize length);
 
 	private:
 		const EVP_CIPHER* _pCipher;
-		EVP_CIPHER_CTX    _ctx;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		EVP_CIPHER_CTX*   _pContext;
+#else
+		EVP_CIPHER_CTX    _context;
+#endif
 		ByteVec           _key;
 		ByteVec           _iv;
 	};
@@ -92,32 +96,54 @@ namespace
 		_key(key),
 		_iv(iv)
 	{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		_pContext = EVP_CIPHER_CTX_new();
 		EVP_CipherInit(
-			&_ctx,
+			_pContext,
 			_pCipher,
 			&_key[0],
 			_iv.empty() ? 0 : &_iv[0],
 			(dir == DIR_ENCRYPT) ? 1 : 0);
+#else
+		EVP_CipherInit(
+			&_context,
+			_pCipher,
+			&_key[0],
+			_iv.empty() ? 0 : &_iv[0],
+			(dir == DIR_ENCRYPT) ? 1 : 0);
+#endif
 	}
 
 
 	CryptoTransformImpl::~CryptoTransformImpl()
 	{
-		EVP_CIPHER_CTX_cleanup(&_ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		EVP_CIPHER_CTX_cleanup(_pContext);
+#else
+		EVP_CIPHER_CTX_cleanup(&_context);
+#endif
 	}
 
 
 	std::size_t CryptoTransformImpl::blockSize() const
 	{
-		return EVP_CIPHER_CTX_block_size(&_ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		return EVP_CIPHER_CTX_block_size(_pContext);
+#else
+		return EVP_CIPHER_CTX_block_size(&_context);
+#endif
 	}
 
-
+	
 	int CryptoTransformImpl::setPadding(int padding)
 	{
-		return EVP_CIPHER_CTX_set_padding(&_ctx, padding);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		return EVP_CIPHER_CTX_block_size(_pContext);
+#else
+		return EVP_CIPHER_CTX_set_padding(&_context, padding);
+#endif
 	}
-
+	
 
 	std::streamsize CryptoTransformImpl::transform(
 		const unsigned char* input,
@@ -125,16 +151,24 @@ namespace
 		unsigned char*       output,
 		std::streamsize      outputLength)
 	{
-		poco_assert (outputLength >= std::streamsize(inputLength + blockSize() - 1));
+		poco_assert (outputLength >= (inputLength + blockSize() - 1));
 
 		int outLen = static_cast<int>(outputLength);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
 		int rc = EVP_CipherUpdate(
-			&_ctx,
+			_pContext,
 			output,
 			&outLen,
 			input,
 			static_cast<int>(inputLength));
-
+#else
+		int rc = EVP_CipherUpdate(
+			&_context,
+			output,
+			&outLen,
+			input,
+			static_cast<int>(inputLength));
+#endif
 		if (rc == 0)
 			throwError();
 
@@ -146,18 +180,22 @@ namespace
 		unsigned char*	output,
 		std::streamsize length)
 	{
-		poco_assert (length >= (std::streamsize)blockSize());
-
+		poco_assert (length >= blockSize());
+		
 		int len = static_cast<int>(length);
 
 		// Use the '_ex' version that does not perform implicit cleanup since we
 		// will call EVP_CIPHER_CTX_cleanup() from the dtor as there is no
 		// guarantee that finalize() will be called if an error occurred.
-		int rc = EVP_CipherFinal_ex(&_ctx, output, &len);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		int rc = EVP_CipherFinal_ex(_pContext, output, &len);
+#else
+		int rc = EVP_CipherFinal_ex(&_context, output, &len);
+#endif
 
 		if (rc == 0)
 			throwError();
-
+			
 		return static_cast<std::streamsize>(len);
 	}
 }
diff --git a/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp b/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp
index 58b51c9424dc..bcd7452c696f 100644
--- a/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp
+++ b/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp
@@ -27,8 +27,8 @@ namespace Poco {
 namespace Crypto {
 
 
-CipherKeyImpl::CipherKeyImpl(const std::string& name,
-	const std::string& passphrase,
+CipherKeyImpl::CipherKeyImpl(const std::string& name, 
+	const std::string& passphrase, 
 	const std::string& salt,
 	int iterationCount):
 	_pCipher(0),
@@ -48,8 +48,8 @@ CipherKeyImpl::CipherKeyImpl(const std::string& name,
 }
 
 
-CipherKeyImpl::CipherKeyImpl(const std::string& name,
-	const ByteVec& key,
+CipherKeyImpl::CipherKeyImpl(const std::string& name, 
+	const ByteVec& key, 
 	const ByteVec& iv):
 	_pCipher(0),
 	_name(name),
@@ -64,7 +64,7 @@ CipherKeyImpl::CipherKeyImpl(const std::string& name,
 		throw Poco::NotFoundException("Cipher " + name + " was not found");
 }
 
-
+	
 CipherKeyImpl::CipherKeyImpl(const std::string& name):
 	_pCipher(0),
 	_name(name),
@@ -117,7 +117,7 @@ void CipherKeyImpl::generateKey()
 
 	getRandomBytes(vec, keySize());
 	setKey(vec);
-
+	
 	getRandomBytes(vec, ivSize());
 	setIV(vec);
 }
@@ -126,11 +126,11 @@ void CipherKeyImpl::generateKey()
 void CipherKeyImpl::getRandomBytes(ByteVec& vec, std::size_t count)
 {
 	Poco::RandomInputStream random;
-
+	
 	vec.clear();
 	vec.reserve(count);
 
-	for (std::size_t i = 0; i < count; ++i)
+	for (int i = 0; i < count; ++i)
 		vec.push_back(static_cast<unsigned char>(random.get()));
 }
 
diff --git a/contrib/libpoco/Crypto/src/CryptoStream.cpp b/contrib/libpoco/Crypto/src/CryptoStream.cpp
index 34ce13b4c397..97e73ce810f0 100644
--- a/contrib/libpoco/Crypto/src/CryptoStream.cpp
+++ b/contrib/libpoco/Crypto/src/CryptoStream.cpp
@@ -43,7 +43,7 @@ CryptoStreamBuf::CryptoStreamBuf(std::istream& istr, CryptoTransform* pTransform
 	_buffer(static_cast<std::size_t>(bufferSize))
 {
 	poco_check_ptr (pTransform);
-	poco_assert ((size_t)bufferSize > 2 * pTransform->blockSize());
+	poco_assert (bufferSize > 2 * pTransform->blockSize());
 }
 
 
@@ -56,7 +56,7 @@ CryptoStreamBuf::CryptoStreamBuf(std::ostream& ostr, CryptoTransform* pTransform
 	_buffer(static_cast<std::size_t>(bufferSize))
 {
 	poco_check_ptr (pTransform);
-	poco_assert ((size_t)bufferSize > 2 * pTransform->blockSize());
+	poco_assert (bufferSize > 2 * pTransform->blockSize());
 }
 
 
@@ -88,10 +88,10 @@ void CryptoStreamBuf::close()
 		// thrown.
 		std::ostream* pOstr = _pOstr;
 		_pOstr = 0;
-
+		
 		// Finalize transformation.
 		std::streamsize n = _pTransform->finalize(_buffer.begin(), static_cast<std::streamsize>(_buffer.size()));
-
+		
 		if (n > 0)
 		{
 			pOstr->write(reinterpret_cast<char*>(_buffer.begin()), n);
@@ -159,7 +159,7 @@ int CryptoStreamBuf::writeToDevice(const char* buffer, std::streamsize length)
 	std::size_t maxChunkSize = _buffer.size()/2;
 	std::size_t count = 0;
 
-	while (count < (size_t)length)
+	while (count < length)
 	{
 		// Truncate chunk size so that the maximum output fits into _buffer.
 		std::size_t n = static_cast<std::size_t>(length) - count;
diff --git a/contrib/libpoco/Crypto/src/DigestEngine.cpp b/contrib/libpoco/Crypto/src/DigestEngine.cpp
index 6e574ab42e11..64042589f172 100644
--- a/contrib/libpoco/Crypto/src/DigestEngine.cpp
+++ b/contrib/libpoco/Crypto/src/DigestEngine.cpp
@@ -23,46 +23,51 @@ namespace Crypto {
 
 
 DigestEngine::DigestEngine(const std::string& name):
-	_name(name)
+	_name(name),
+	_pContext(EVP_MD_CTX_create())
 {
 	const EVP_MD* md = EVP_get_digestbyname(_name.c_str());
 	if (!md) throw Poco::NotFoundException(_name);
-	_ctx = EVP_MD_CTX_create();
-	EVP_DigestInit_ex(_ctx, md, NULL);	
+	EVP_DigestInit_ex(_pContext, md, NULL);	
 }
 
 	
 DigestEngine::~DigestEngine()
 {
-	EVP_MD_CTX_destroy(_ctx);
+	EVP_MD_CTX_destroy(_pContext);
 }
 
 int DigestEngine::nid() const
 {
-	return EVP_MD_nid(_ctx->digest);
+	return EVP_MD_nid(EVP_MD_CTX_md(_pContext));
 }
 
 std::size_t DigestEngine::digestLength() const
 {
-	return EVP_MD_CTX_size(_ctx);
+	return EVP_MD_CTX_size(_pContext);
 }
 
 
 void DigestEngine::reset()
 {
-	EVP_MD_CTX_cleanup(_ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	EVP_MD_CTX_free(_pContext);
+	_pContext = EVP_MD_CTX_create();
+#else
+	EVP_MD_CTX_cleanup(_pContext);
+#endif
 	const EVP_MD* md = EVP_get_digestbyname(_name.c_str());
 	if (!md) throw Poco::NotFoundException(_name);
-	EVP_DigestInit_ex(_ctx, md, NULL);
+	EVP_DigestInit_ex(_pContext, md, NULL);
 }
 
 
 const Poco::DigestEngine::Digest& DigestEngine::digest()
 {
 	_digest.clear();
-	unsigned len = EVP_MD_CTX_size(_ctx);
+	unsigned len = EVP_MD_CTX_size(_pContext);
 	_digest.resize(len);
-	EVP_DigestFinal_ex(_ctx, &_digest[0], &len);
+	EVP_DigestFinal_ex(_pContext, &_digest[0], &len);
 	reset();
 	return _digest;
 }
@@ -70,7 +75,7 @@ const Poco::DigestEngine::Digest& DigestEngine::digest()
 
 void DigestEngine::updateImpl(const void* data, std::size_t length)
 {
-	EVP_DigestUpdate(_ctx, data, length);
+	EVP_DigestUpdate(_pContext, data, length);
 }
 
 
diff --git a/contrib/libpoco/Crypto/src/RSACipherImpl.cpp b/contrib/libpoco/Crypto/src/RSACipherImpl.cpp
index 01b238512825..91c5b815d618 100644
--- a/contrib/libpoco/Crypto/src/RSACipherImpl.cpp
+++ b/contrib/libpoco/Crypto/src/RSACipherImpl.cpp
@@ -32,7 +32,7 @@ namespace
 	{
 		unsigned long err;
 		std::string msg;
-
+		
 		while ((err = ERR_get_error()))
 		{
 			if (!msg.empty())
@@ -68,7 +68,7 @@ namespace
 	public:
 		RSAEncryptImpl(const RSA* pRSA, RSAPaddingMode paddingMode);
 		~RSAEncryptImpl();
-
+		
 		std::size_t blockSize() const;
 		std::size_t maxDataSize() const;
 
@@ -77,7 +77,7 @@ namespace
 			std::streamsize		 inputLength,
 			unsigned char*		 output,
 			std::streamsize		 outputLength);
-
+		
 		std::streamsize finalize(unsigned char*	output, std::streamsize length);
 
 	private:
@@ -156,7 +156,7 @@ namespace
 				output += n;
 				outputLength -= n;
 				_pos = 0;
-
+				
 			}
 			else
 			{
@@ -175,8 +175,8 @@ namespace
 
 	std::streamsize RSAEncryptImpl::finalize(unsigned char*	output, std::streamsize length)
 	{
-		poco_assert ((size_t)length >= blockSize());
-		poco_assert ((size_t)_pos <= maxDataSize());
+		poco_assert (length >= blockSize());
+		poco_assert (_pos <= maxDataSize());
 		int rc = 0;
 		if (_pos > 0)
 		{
@@ -192,7 +192,7 @@ namespace
 	public:
 		RSADecryptImpl(const RSA* pRSA, RSAPaddingMode paddingMode);
 		~RSADecryptImpl();
-
+		
 		std::size_t blockSize() const;
 
 		std::streamsize transform(
@@ -200,7 +200,7 @@ namespace
 			std::streamsize		 inputLength,
 			unsigned char*		 output,
 			std::streamsize		 outputLength);
-
+		
 		std::streamsize finalize(
 			unsigned char*	output,
 			std::streamsize length);
@@ -241,7 +241,7 @@ namespace
 		unsigned char*		 output,
 		std::streamsize		 outputLength)
 	{
-
+		
 		// always fill up the buffer before decrypting!
 		std::streamsize rsaSize = static_cast<std::streamsize>(blockSize());
 		poco_assert_dbg(_pos <= rsaSize);
@@ -261,7 +261,7 @@ namespace
 				output += tmp;
 				outputLength -= tmp;
 				_pos = 0;
-
+				
 			}
 			else
 			{
@@ -280,7 +280,7 @@ namespace
 
 	std::streamsize RSADecryptImpl::finalize(unsigned char*	output, std::streamsize length)
 	{
-		poco_assert ((size_t)length >= blockSize());
+		poco_assert (length >= blockSize());
 		int rc = 0;
 		if (_pos > 0)
 		{
diff --git a/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp b/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp
index 8333453cee02..3a1580f69124 100644
--- a/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp
+++ b/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp
@@ -207,19 +207,43 @@ int RSAKeyImpl::size() const
 
 RSAKeyImpl::ByteVec RSAKeyImpl::modulus() const
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	const BIGNUM* n = 0;
+	const BIGNUM* e = 0;
+	const BIGNUM* d = 0;
+	RSA_get0_key(_pRSA, &n, &e, &d);
+	return convertToByteVec(n);
+#else
 	return convertToByteVec(_pRSA->n);
+#endif
 }
 
 
 RSAKeyImpl::ByteVec RSAKeyImpl::encryptionExponent() const
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	const BIGNUM* n = 0;
+	const BIGNUM* e = 0;
+	const BIGNUM* d = 0;
+	RSA_get0_key(_pRSA, &n, &e, &d);
+	return convertToByteVec(e);
+#else
 	return convertToByteVec(_pRSA->e);
+#endif
 }
 
 
 RSAKeyImpl::ByteVec RSAKeyImpl::decryptionExponent() const
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	const BIGNUM* n = 0;
+	const BIGNUM* e = 0;
+	const BIGNUM* d = 0;
+	RSA_get0_key(_pRSA, &n, &e, &d);
+	return convertToByteVec(d);
+#else
 	return convertToByteVec(_pRSA->d);
+#endif
 }
 
 
diff --git a/contrib/libpoco/Crypto/src/X509Certificate.cpp b/contrib/libpoco/Crypto/src/X509Certificate.cpp
index dd9ebd2cab36..f7f37965ed83 100644
--- a/contrib/libpoco/Crypto/src/X509Certificate.cpp
+++ b/contrib/libpoco/Crypto/src/X509Certificate.cpp
@@ -59,7 +59,11 @@ X509Certificate::X509Certificate(X509* pCert, bool shared):
 	
 	if (shared)
 	{
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+		X509_up_ref(_pCert);
+#else
 		_pCert->references++;
+#endif
 	}
 
 	init();
@@ -205,10 +209,10 @@ std::string X509Certificate::issuerName(NID nid) const
 	if (X509_NAME* issuer = X509_get_issuer_name(_pCert))
     {
 		char buffer[NAME_BUFFER_SIZE];
-		X509_NAME_get_text_by_NID(issuer, nid, buffer, sizeof(buffer));
-		return std::string(buffer);
+		if (X509_NAME_get_text_by_NID(issuer, nid, buffer, sizeof(buffer)) >= 0)
+			return std::string(buffer);
     }
-    else return std::string();
+    return std::string();
 }
 
 
@@ -217,10 +221,10 @@ std::string X509Certificate::subjectName(NID nid) const
 	if (X509_NAME* subj = X509_get_subject_name(_pCert))
     {
 		char buffer[NAME_BUFFER_SIZE];
-		X509_NAME_get_text_by_NID(subj, nid, buffer, sizeof(buffer));
-		return std::string(buffer);
+		if (X509_NAME_get_text_by_NID(subj, nid, buffer, sizeof(buffer)) >= 0)
+			return std::string(buffer);
     }
-    else return std::string();
+    return std::string();
 }
 
 
@@ -280,4 +284,12 @@ bool X509Certificate::issuedBy(const X509Certificate& issuerCertificate) const
 }
 
 
+bool X509Certificate::equals(const X509Certificate& otherCertificate) const
+{
+	X509* pCert = const_cast<X509*>(_pCert);
+	X509* pOtherCert = const_cast<X509*>(otherCertificate.certificate());
+	return X509_cmp(pCert, pOtherCert) == 0;
+}
+
+
 } } // namespace Poco::Crypto
diff --git a/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp b/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp
index 6a1e922a8a47..a4325c45e7e2 100644
--- a/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp
+++ b/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp
@@ -46,6 +46,7 @@ void registerAggregateFunctionsStatistics(AggregateFunctionFactory & factory);
 void registerAggregateFunctionSum(AggregateFunctionFactory & factory);
 void registerAggregateFunctionsUniq(AggregateFunctionFactory & factory);
 void registerAggregateFunctionUniqUpTo(AggregateFunctionFactory & factory);
+void registerAggregateFunctionTopK(AggregateFunctionFactory & factory);
 void registerAggregateFunctionDebug(AggregateFunctionFactory & factory);
 
 AggregateFunctionPtr createAggregateFunctionArray(AggregateFunctionPtr & nested);
@@ -76,6 +77,7 @@ AggregateFunctionFactory::AggregateFunctionFactory()
     registerAggregateFunctionSum(*this);
     registerAggregateFunctionsUniq(*this);
     registerAggregateFunctionUniqUpTo(*this);
+    registerAggregateFunctionTopK(*this);
     registerAggregateFunctionDebug(*this);
 }
 
diff --git a/dbms/src/AggregateFunctions/AggregateFunctionTopK.cpp b/dbms/src/AggregateFunctions/AggregateFunctionTopK.cpp
new file mode 100644
index 000000000000..3310691a8ab4
--- /dev/null
+++ b/dbms/src/AggregateFunctions/AggregateFunctionTopK.cpp
@@ -0,0 +1,70 @@
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+#include <AggregateFunctions/AggregateFunctionTopK.h>
+#include <AggregateFunctions/Helpers.h>
+
+namespace DB
+{
+
+namespace
+{
+
+/// Substitute return type for Date and DateTime
+class AggregateFunctionTopKDate : public AggregateFunctionTopK<DataTypeDate::FieldType>
+{
+    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDate>()); }
+};
+
+class AggregateFunctionTopKDateTime : public AggregateFunctionTopK<DataTypeDateTime::FieldType>
+{
+    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDateTime>()); }
+};
+
+
+static IAggregateFunction * createWithExtraTypes(const IDataType & argument_type)
+{
+         if (typeid_cast<const DataTypeDate *>(&argument_type))     return new AggregateFunctionTopKDate;
+    else if (typeid_cast<const DataTypeDateTime *>(&argument_type))    return new AggregateFunctionTopKDateTime;
+    else
+    {
+        /// Check that we can use plain version of AggregateFunctionTopKGeneric
+        if (typeid_cast<const DataTypeString*>(&argument_type) || typeid_cast<const DataTypeFixedString*>(&argument_type))
+            return new AggregateFunctionTopKGeneric<true>;
+
+        auto * array_type = typeid_cast<const DataTypeArray *>(&argument_type);
+        if (array_type)
+        {
+            auto nested_type = array_type->getNestedType();
+            if (nested_type->isNumeric() || typeid_cast<DataTypeFixedString *>(nested_type.get()))
+                return new AggregateFunctionTopKGeneric<true>;
+        }
+
+        return new AggregateFunctionTopKGeneric<false>;
+    }
+}
+
+AggregateFunctionPtr createAggregateFunctionTopK(const std::string & name, const DataTypes & argument_types)
+{
+    if (argument_types.size() != 1)
+        throw Exception("Incorrect number of arguments for aggregate function " + name,
+            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+
+    AggregateFunctionPtr res(createWithNumericType<AggregateFunctionTopK>(*argument_types[0]));
+
+    if (!res)
+        res = AggregateFunctionPtr(createWithExtraTypes(*argument_types[0]));
+
+    if (!res)
+        throw Exception("Illegal type " + argument_types[0]->getName() +
+            " of argument for aggregate function " + name, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+    return res;
+}
+
+}
+
+void registerAggregateFunctionTopK(AggregateFunctionFactory & factory)
+{
+    factory.registerFunction("topK", createAggregateFunctionTopK);
+}
+
+}
diff --git a/dbms/src/AggregateFunctions/AggregateFunctionTopK.h b/dbms/src/AggregateFunctions/AggregateFunctionTopK.h
new file mode 100644
index 000000000000..b93780d127e2
--- /dev/null
+++ b/dbms/src/AggregateFunctions/AggregateFunctionTopK.h
@@ -0,0 +1,264 @@
+#pragma once
+
+#include <IO/WriteHelpers.h>
+#include <IO/ReadHelpers.h>
+
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/DataTypeString.h>
+
+#include <Columns/ColumnArray.h>
+
+#include <Common/SpaceSaving.h>
+
+#include <Core/FieldVisitors.h>
+
+#include <AggregateFunctions/AggregateFunctionGroupArray.h>
+
+
+namespace DB
+{
+
+
+// Allow NxK more space before calculating top K to increase accuracy
+#define TOP_K_LOAD_FACTOR 3
+#define TOP_K_MAX_SIZE 0xFFFFFF
+
+
+template <typename T>
+struct AggregateFunctionTopKData
+{
+    using Set = SpaceSaving<T, DefaultHash<T>>;
+    Set value;
+};
+
+
+template <typename T>
+class AggregateFunctionTopK
+    : public IUnaryAggregateFunction<AggregateFunctionTopKData<T>, AggregateFunctionTopK<T>>
+{
+private:
+    using State = AggregateFunctionTopKData<T>;
+    size_t threshold = 10; // Default value if the parameter is not specified.
+    size_t reserved = TOP_K_LOAD_FACTOR * threshold;
+
+public:
+    String getName() const override { return "topK"; }
+
+    DataTypePtr getReturnType() const override
+    {
+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeNumber<T>>());
+    }
+
+    void setArgument(const DataTypePtr & argument)
+    {
+    }
+
+    void setParameters(const Array & params) override
+    {
+        if (params.size() != 1)
+            throw Exception("Aggregate function " + getName() + " requires exactly one parameter.", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+
+        std::size_t k = applyVisitor(FieldVisitorConvertToNumber<size_t>(), params[0]);
+
+        if (k > TOP_K_MAX_SIZE)
+            throw Exception("Too large parameter for aggregate function " + getName() + ". Maximum: " + toString(TOP_K_MAX_SIZE),
+                ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+
+        threshold = k;
+        reserved = TOP_K_LOAD_FACTOR * k;
+    }
+
+    void addImpl(AggregateDataPtr place, const IColumn & column, size_t row_num, Arena *) const
+    {
+        auto & set = this->data(place).value;
+        if (set.capacity() != reserved) {
+            set.resize(reserved);
+        }
+        set.insert(static_cast<const ColumnVector<T> &>(column).getData()[row_num]);
+    }
+
+    void merge(AggregateDataPtr place, ConstAggregateDataPtr rhs, Arena * arena) const override
+    {
+        this->data(place).value.merge(this->data(rhs).value);
+    }
+
+    void serialize(ConstAggregateDataPtr place, WriteBuffer & buf) const override
+    {
+        this->data(place).value.write(buf);
+    }
+
+    void deserialize(AggregateDataPtr place, ReadBuffer & buf, Arena *) const override
+    {
+        auto & set = this->data(place).value;
+        set.resize(reserved);
+        set.read(buf);
+    }
+
+    void insertResultInto(ConstAggregateDataPtr place, IColumn & to) const override
+    {
+        ColumnArray & arr_to = static_cast<ColumnArray &>(to);
+        ColumnArray::Offsets_t & offsets_to = arr_to.getOffsets();
+
+        const typename State::Set & set = this->data(place).value;
+        auto resultVec = set.topK(threshold);
+        size_t size = resultVec.size();
+
+        offsets_to.push_back((offsets_to.size() == 0 ? 0 : offsets_to.back()) + size);
+
+        typename ColumnVector<T>::Container_t & data_to = static_cast<ColumnVector<T> &>(arr_to.getData()).getData();
+        size_t old_size = data_to.size();
+        data_to.resize(old_size + size);
+
+        size_t i = 0;
+        for (auto it = resultVec.begin(); it != resultVec.end(); ++it, ++i)
+            data_to[old_size + i] = it->key;
+    }
+};
+
+
+/// Generic implementation, it uses serialized representation as object descriptor.
+struct AggregateFunctionTopKGenericData
+{
+    using Set = SpaceSaving<StringRef, StringRefHash>;
+
+    Set value;
+};
+
+/** Template parameter with true value should be used for columns that store their elements in memory continuously.
+ *  For such columns topK() can be implemented more efficently (especially for small numeric arrays).
+ */
+template <bool is_plain_column = false>
+class AggregateFunctionTopKGeneric : public IUnaryAggregateFunction<AggregateFunctionTopKGenericData, AggregateFunctionTopKGeneric<is_plain_column>>
+{
+private:
+    using State = AggregateFunctionTopKGenericData;
+    DataTypePtr input_data_type;
+    size_t threshold = 10; // Default value if the parameter is not specified.
+    size_t reserved = TOP_K_LOAD_FACTOR * threshold;
+
+    static StringRef getSerialization(const IColumn & column, size_t row_num, Arena & arena);
+    static void deserializeAndInsert(StringRef str, IColumn & data_to);
+
+public:
+    String getName() const override { return "topK"; }
+
+    void setArgument(const DataTypePtr & argument)
+    {
+        input_data_type = argument;
+    }
+
+    void setParameters(const Array & params) override
+    {
+        if (params.size() != 1)
+            throw Exception("Aggregate function " + getName() + " requires exactly one parameter.", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+
+        size_t k = applyVisitor(FieldVisitorConvertToNumber<size_t>(), params[0]);
+
+        if (k > TOP_K_MAX_SIZE)
+            throw Exception("Too large parameter for aggregate function " + getName() + ". Maximum: " + toString(TOP_K_MAX_SIZE),
+                ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+
+        threshold = k;
+        reserved = TOP_K_LOAD_FACTOR * k;
+    }
+
+    DataTypePtr getReturnType() const override
+    {
+        return std::make_shared<DataTypeArray>(input_data_type->clone());
+    }
+
+    bool allocatesMemoryInArena() const override
+    {
+        return true;
+    }
+
+    void serialize(ConstAggregateDataPtr place, WriteBuffer & buf) const override
+    {
+        this->data(place).value.write(buf);
+    }
+
+    void deserialize(AggregateDataPtr place, ReadBuffer & buf, Arena * arena) const override
+    {
+        auto & set = this->data(place).value;
+        set.resize(reserved);
+
+        size_t count = 0;
+        readVarUInt(count, buf);
+        for (size_t i = 0; i < count; ++i) {
+            auto key = readStringBinaryInto(*arena, buf);
+            UInt64 count, error;
+            readVarUInt(count, buf);
+            readVarUInt(error, buf);
+            set.insert(key, count, error);
+        }
+    }
+
+    void addImpl(AggregateDataPtr place, const IColumn & column, size_t row_num, Arena * arena) const
+    {
+        auto & set = this->data(place).value;
+        if (set.capacity() != reserved) {
+            set.resize(reserved);
+        }
+
+        StringRef str_serialized = getSerialization(column, row_num, *arena);
+        if (is_plain_column) {
+            auto ptr = arena->insert(str_serialized.data, str_serialized.size);
+            str_serialized = StringRef(ptr, str_serialized.size);
+        }
+
+        set.insert(str_serialized);
+    }
+
+    void merge(AggregateDataPtr place, ConstAggregateDataPtr rhs, Arena * arena) const override
+    {
+        this->data(place).value.merge(this->data(rhs).value);
+    }
+
+    void insertResultInto(ConstAggregateDataPtr place, IColumn & to) const override
+    {
+        ColumnArray & arr_to = static_cast<ColumnArray &>(to);
+        ColumnArray::Offsets_t & offsets_to = arr_to.getOffsets();
+        IColumn & data_to = arr_to.getData();
+
+        auto resultVec = this->data(place).value.topK(threshold);
+        offsets_to.push_back((offsets_to.size() == 0 ? 0 : offsets_to.back()) + resultVec.size());
+
+        for (auto & elem : resultVec)
+        {
+            deserializeAndInsert(elem.key, data_to);
+        }
+    }
+};
+
+
+template <>
+inline StringRef AggregateFunctionTopKGeneric<false>::getSerialization(const IColumn & column, size_t row_num, Arena & arena)
+{
+    const char * begin = nullptr;
+    return column.serializeValueIntoArena(row_num, arena, begin);
+}
+
+template <>
+inline StringRef AggregateFunctionTopKGeneric<true>::getSerialization(const IColumn & column, size_t row_num, Arena &)
+{
+    return column.getDataAt(row_num);
+}
+
+template <>
+inline void AggregateFunctionTopKGeneric<false>::deserializeAndInsert(StringRef str, IColumn & data_to)
+{
+    data_to.deserializeAndInsertFromArena(str.data);
+}
+
+template <>
+inline void AggregateFunctionTopKGeneric<true>::deserializeAndInsert(StringRef str, IColumn & data_to)
+{
+    data_to.insertData(str.data, str.size);
+}
+
+
+#undef TOP_K_MAX_SIZE
+#undef TOP_K_LOAD_FACTOR
+
+}
diff --git a/dbms/src/Common/SpaceSaving.h b/dbms/src/Common/SpaceSaving.h
new file mode 100644
index 000000000000..4f11ebc3bbe8
--- /dev/null
+++ b/dbms/src/Common/SpaceSaving.h
@@ -0,0 +1,254 @@
+#pragma once
+
+#include <iostream>
+#include <list>
+#include <vector>
+
+#include <boost/range/adaptor/reversed.hpp>
+
+#include <Common/UInt128.h>
+#include <Common/HashTable/Hash.h>
+#include <Common/HashTable/HashMap.h>
+
+#include <IO/WriteBuffer.h>
+#include <IO/WriteHelpers.h>
+#include <IO/ReadBuffer.h>
+#include <IO/ReadHelpers.h>
+#include <IO/VarInt.h>
+
+/*
+ * Implementation of the Filtered Space-Saving for TopK streaming analysis.
+ *   http://www.l2f.inesc-id.pt/~fmmb/wiki/uploads/Work/misnis.ref0a.pdf
+ * It implements suggested reduce-and-combine algorithm from Parallel Space Saving:
+ *   https://arxiv.org/pdf/1401.0702.pdf
+ */
+
+namespace DB
+{
+
+template <typename TKey, typename Hash = DefaultHash<TKey>>
+class SpaceSaving
+{
+public:
+    struct Counter {
+        Counter() {}
+
+        Counter(const TKey & k, UInt64 c = 0, UInt64 e = 0)
+          : key(k), slot(0), count(c), error(e) {}
+
+        void write(DB::WriteBuffer & wb) const
+        {
+              DB::writeBinary(key, wb);
+              DB::writeVarUInt(count, wb);
+              DB::writeVarUInt(error, wb);
+        }
+
+        void read(DB::ReadBuffer & rb)
+        {
+            DB::readBinary(key, rb);
+            DB::readVarUInt(count, rb);
+            DB::readVarUInt(error, rb);
+        }
+
+        // greater() taking slot error into account
+        bool operator >(const Counter &b) const
+        {
+            return (count > b.count) || (count == b.count && error < b.error);
+        }
+
+        TKey key;
+        size_t slot;
+        UInt64 count, error;
+    };
+
+    // Suggested constants in the paper "Finding top-k elements in data streams", chap 6. equation (24)
+    SpaceSaving(size_t c = 10) : counterMap(), counterList(), alphaMap(6 * c), cap(c) {}
+    ~SpaceSaving() { destroyElements(); }
+
+    inline size_t size() const
+    {
+        return counterList.size();
+    }
+
+    inline size_t capacity() const
+    {
+        return cap;
+    }
+
+    void resize(size_t c)
+    {
+        counterList.reserve(c);
+        alphaMap.resize(c * 6);
+        cap = c;
+    }
+
+    Counter * insert(const TKey & key, UInt64 increment = 1, UInt64 error = 0)
+    {
+        // Increase weight of a key that already exists
+        // It uses hashtable for both value mapping as a presence test (c_i != 0)
+        auto hash = counterMap.hash(key);
+        auto it = counterMap.find(key, hash);
+        if (it != counterMap.end()) {
+            auto c = it->second;
+            c->count += increment;
+            c->error += error;
+            percolate(c);
+            return c;
+        }
+
+        // Key doesn't exist, but can fit in the top K
+        if (size() < capacity()) {
+            auto c = new Counter(key, increment, error);
+            push(c);
+            return c;
+        }
+
+        auto min = counterList.back();
+        auto & alpha = alphaMap[hash % alphaMap.size()];
+        if (alpha + increment < min->count) {
+            alpha += increment;
+            return nullptr;
+        }
+
+        // Erase the current minimum element
+        auto minHash = counterMap.hash(min->key);
+        it = counterMap.find(min->key, minHash);
+        if (it != counterMap.end()) {
+            auto cell = it.getPtr();
+            cell->setZero();
+        }
+
+        // Replace minimum with newly inserted element
+        bool inserted = false;
+        counterMap.emplace(key, it, inserted, hash);
+        if (inserted) {
+            alphaMap[minHash % alphaMap.size()] = min->count;
+            min->key = key;
+            min->count = alpha + increment;
+            min->error = alpha + error;
+            it->second = min;
+            percolate(min);
+        }
+
+        return min;
+    }
+
+    /*
+     * Parallel Space Saving reduction and combine step from:
+     *  https://arxiv.org/pdf/1401.0702.pdf
+     */
+    void merge(const SpaceSaving<TKey, Hash> & rhs)
+    {
+        UInt64 m1 = 0, m2 = 0;
+        if (size() == capacity()) {
+            m1 = counterList.back()->count;
+        }
+        if (rhs.size() == rhs.capacity()) {
+            m2 = rhs.counterList.back()->count;
+        }
+
+        /*
+         * Updated algorithm to mutate current table in place
+         * without mutating rhs table or creating new one
+         * in the first step we expect that no elements overlap
+         * and in the second sweep we correct the error if they do.
+         */
+        if (m2 > 0) {
+            for (auto c : counterList) {
+                c->count += m2;
+                c->error += m2;
+            }
+        }
+
+        // The list is sorted in descending order, we have to scan in reverse
+        for (auto c : boost::adaptors::reverse(rhs.counterList)) {
+            if (counterMap.find(c->key) != counterMap.end()) {
+                // Subtract m2 previously added, guaranteed not negative
+                insert(c->key, c->count - m2, c->error - m2);
+            } else {
+                // Counters not monitored in S1
+                insert(c->key, c->count + m1, c->error + m1);
+            }
+        }
+    }
+
+    std::vector<Counter> topK(size_t k) const
+    {
+        std::vector<Counter> res;
+        for (auto c : counterList) {
+            res.push_back(*c);
+            if (res.size() == k) {
+                break;
+            }
+        }
+        return res;
+    }
+
+    void write(DB::WriteBuffer & wb) const
+    {
+        DB::writeVarUInt(size(), wb);
+        for (auto c : counterList) {
+            c->write(wb);
+        }
+        for (auto a : alphaMap) {
+            DB::writeVarUInt(a, wb);
+        }
+    }
+
+    void read(DB::ReadBuffer & rb)
+    {
+        destroyElements();
+        size_t count = 0;
+        DB::readVarUInt(count, rb);
+
+        for (size_t i = 0; i < count; ++i) {
+            auto c = new Counter();
+            c->read(rb);
+            push(c);
+        }
+
+        for (size_t i = 0; i < capacity() * 6; ++i) {
+            UInt64 alpha = 0;
+            DB::readVarUInt(alpha, rb);
+            alphaMap.push_back(alpha);
+        }
+    }
+
+protected:
+    void push(Counter * c) {
+        c->slot = counterList.size();
+        counterList.push_back(c);
+        counterMap[c->key] = c;
+        percolate(c);
+    }
+
+    // This is equivallent to one step of bubble sort
+    void percolate(Counter * c) {
+        while (c->slot > 0) {
+            auto next = counterList[c->slot - 1];
+            if (*c > *next) {
+                std::swap(next->slot, c->slot);
+                std::swap(counterList[next->slot], counterList[c->slot]);
+            } else {
+                break;
+            }
+        }
+    }
+
+private:
+    void destroyElements() {
+        for (auto c : counterList) {
+            delete c;
+        }
+        counterMap.clear();
+        counterList.clear();
+        alphaMap.clear();
+    }
+
+    HashMap<TKey, Counter *, Hash> counterMap;
+    std::vector<Counter *> counterList;
+    std::vector<UInt64> alphaMap;
+    size_t cap;
+};
+
+};
\ No newline at end of file
diff --git a/dbms/src/IO/WriteHelpers.h b/dbms/src/IO/WriteHelpers.h
index 46084d622eb7..c8f46aabfc33 100644
--- a/dbms/src/IO/WriteHelpers.h
+++ b/dbms/src/IO/WriteHelpers.h
@@ -583,6 +583,7 @@ inline typename std::enable_if<std::is_arithmetic<T>::value, void>::type
 writeBinary(const T & x, WriteBuffer & buf) { writePODBinary(x, buf); }
 
 inline void writeBinary(const String & x,    WriteBuffer & buf) { writeStringBinary(x, buf); }
+inline void writeBinary(const StringRef & x,    WriteBuffer & buf) { writeStringBinary(x, buf); }
 inline void writeBinary(const uint128 & x,     WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const LocalDate & x,        WriteBuffer & buf) { writePODBinary(x, buf); }
 inline void writeBinary(const LocalDateTime & x,    WriteBuffer & buf) { writePODBinary(x, buf); }
diff --git a/website/reference_en.html b/website/reference_en.html
index eef67e1e5486..3c288135dabb 100644
--- a/website/reference_en.html
+++ b/website/reference_en.html
@@ -6418,6 +6418,17 @@ <h1>Aggregate functions</h1>
 Problem: Generate a report that shows only keywords that produced at least 5 unique users.
 Solution: Write in the query <span class="inline-example">GROUP BY SearchPhrase HAVING uniqUpTo(4)(UserID) >= 5</span>
 
+==topK(N)(x)==
+
+Returns the K most frequent argument values as an array sorted by their relative frequency.
+
+Recommended for use with small Ns, up to 10. The maximum N value is 65536.
+
+For the state of an aggregate function, it uses approximately the amount of memory equal to K * (the size of the key + 16) for counters, and 48 * N bytes for alpha value map.
+
+Usage example:
+Problem: Generate a report that shows top 5 frequent queries.
+Solution: Write in the query <span class="inline-example">SELECT topK(5)(SearchPhrase)</span>
 
 ==Aggregate function combinators==
 
diff --git a/website/reference_ru.html b/website/reference_ru.html
index 90de231cb801..b85a0d032235 100644
--- a/website/reference_ru.html
+++ b/website/reference_ru.html
@@ -6534,6 +6534,17 @@ <h1>Агрегатные функции</h1>
 Задача: показывать в отчёте только поисковые фразы, по которым было хотя бы 5 уникальных посетителей.
 Решение: пишем в запросе %%GROUP BY SearchPhrase HAVING uniqUpTo(4)(UserID) &gt;= 5%%
 
+==topK(N)(x)==
+
+Returns the K most frequent argument values as an array sorted by their relative frequency.
+
+Recommended for use with small Ns, up to 10. The maximum N value is 65536.
+
+For the state of an aggregate function, it uses approximately the amount of memory equal to K * (the size of the key + 16) for counters, and 48 * N bytes for alpha value map.
+
+Usage example:
+Problem: Generate a report that shows top 5 frequent queries.
+Solution: Write in the query <span class="inline-example">SELECT topK(5)(SearchPhrase)</span>
 
 ==Комбинаторы агрегатных функций==
 
