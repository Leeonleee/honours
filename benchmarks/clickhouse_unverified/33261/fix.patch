diff --git a/src/Databases/DatabaseDictionary.cpp b/src/Databases/DatabaseDictionary.cpp
index db7da95fb27a..82766c1e384a 100644
--- a/src/Databases/DatabaseDictionary.cpp
+++ b/src/Databases/DatabaseDictionary.cpp
@@ -29,10 +29,13 @@ namespace
                 return nullptr;
 
             DictionaryStructure dictionary_structure = ExternalDictionariesLoader::getDictionaryStructure(*load_result.config);
+            auto comment = load_result.config->config->getString("dictionary.comment", "");
+
             return StorageDictionary::create(
                 StorageID(database_name, load_result.name),
                 load_result.name,
                 dictionary_structure,
+                comment,
                 StorageDictionary::Location::DictionaryDatabase,
                 context);
         }
diff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp
index ffb39f5b113f..1c3f417b4317 100644
--- a/src/Databases/DatabasesCommon.cpp
+++ b/src/Databases/DatabasesCommon.cpp
@@ -30,27 +30,33 @@ void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemo
     auto & ast_create_query = query->as<ASTCreateQuery &>();
 
     bool has_structure = ast_create_query.columns_list && ast_create_query.columns_list->columns;
+
     if (ast_create_query.as_table_function && !has_structure)
         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot alter table {} because it was created AS table function"
                                                      " and doesn't have structure in metadata", backQuote(ast_create_query.getTable()));
 
-    assert(has_structure);
-    ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);
-    ASTPtr new_indices = InterpreterCreateQuery::formatIndices(metadata.secondary_indices);
-    ASTPtr new_constraints = InterpreterCreateQuery::formatConstraints(metadata.constraints);
-    ASTPtr new_projections = InterpreterCreateQuery::formatProjections(metadata.projections);
+    if (!has_structure && !ast_create_query.is_dictionary)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot alter table {} metadata doesn't have structure", backQuote(ast_create_query.getTable()));
 
-    ast_create_query.columns_list->replace(ast_create_query.columns_list->columns, new_columns);
-    ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->indices, new_indices);
-    ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->constraints, new_constraints);
-    ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->projections, new_projections);
+    if (!ast_create_query.is_dictionary)
+    {
+        ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);
+        ASTPtr new_indices = InterpreterCreateQuery::formatIndices(metadata.secondary_indices);
+        ASTPtr new_constraints = InterpreterCreateQuery::formatConstraints(metadata.constraints);
+        ASTPtr new_projections = InterpreterCreateQuery::formatProjections(metadata.projections);
+
+        ast_create_query.columns_list->replace(ast_create_query.columns_list->columns, new_columns);
+        ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->indices, new_indices);
+        ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->constraints, new_constraints);
+        ast_create_query.columns_list->setOrReplace(ast_create_query.columns_list->projections, new_projections);
+    }
 
     if (metadata.select.select_query)
     {
         query->replace(ast_create_query.select, metadata.select.select_query);
     }
 
-    /// MaterializedView is one type of CREATE query without storage.
+    /// MaterializedView, Dictionary are types of CREATE query without storage.
     if (ast_create_query.storage)
     {
         ASTStorage & storage_ast = *ast_create_query.storage;
diff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp
index 5f7c54e427fd..2475d437acbe 100644
--- a/src/Interpreters/InterpreterAlterQuery.cpp
+++ b/src/Interpreters/InterpreterAlterQuery.cpp
@@ -48,10 +48,15 @@ BlockIO InterpreterAlterQuery::execute()
     FunctionNameNormalizer().visit(query_ptr.get());
     const auto & alter = query_ptr->as<ASTAlterQuery &>();
     if (alter.alter_object == ASTAlterQuery::AlterObjectType::DATABASE)
+    {
         return executeToDatabase(alter);
+    }
     else if (alter.alter_object == ASTAlterQuery::AlterObjectType::TABLE
             || alter.alter_object == ASTAlterQuery::AlterObjectType::LIVE_VIEW)
+    {
         return executeToTable(alter);
+    }
+
     throw Exception(ErrorCodes::LOGICAL_ERROR, "Unknown alter object type");
 }
 
diff --git a/src/Storages/IStorage.cpp b/src/Storages/IStorage.cpp
index 021335fea1ff..a923258b111c 100644
--- a/src/Storages/IStorage.cpp
+++ b/src/Storages/IStorage.cpp
@@ -139,7 +139,6 @@ void IStorage::alter(const AlterCommands & params, ContextPtr context, AlterLock
     setInMemoryMetadata(new_metadata);
 }
 
-
 void IStorage::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const
 {
     for (const auto & command : commands)
diff --git a/src/Storages/StorageDictionary.cpp b/src/Storages/StorageDictionary.cpp
index f6b330fe3dfa..da8c5f115b26 100644
--- a/src/Storages/StorageDictionary.cpp
+++ b/src/Storages/StorageDictionary.cpp
@@ -11,6 +11,7 @@
 #include <QueryPipeline/Pipe.h>
 #include <IO/Operators.h>
 #include <Dictionaries/getDictionaryConfigurationFromAST.h>
+#include <Storages/AlterCommands.h>
 
 
 namespace DB
@@ -21,6 +22,7 @@ namespace ErrorCodes
     extern const int THERE_IS_NO_COLUMN;
     extern const int CANNOT_DETACH_DICTIONARY_AS_TABLE;
     extern const int DICTIONARY_ALREADY_EXISTS;
+    extern const int NOT_IMPLEMENTED;
 }
 
 namespace
@@ -111,10 +113,11 @@ StorageDictionary::StorageDictionary(
     const StorageID & table_id_,
     const String & dictionary_name_,
     const DictionaryStructure & dictionary_structure_,
+    const String & comment,
     Location location_,
     ContextPtr context_)
     : StorageDictionary(
-        table_id_, dictionary_name_, ColumnsDescription{getNamesAndTypes(dictionary_structure_)}, String{}, location_, context_)
+        table_id_, dictionary_name_, ColumnsDescription{getNamesAndTypes(dictionary_structure_)}, comment, location_, context_)
 {
 }
 
@@ -126,6 +129,7 @@ StorageDictionary::StorageDictionary(
         table_id,
         table_id.getFullNameNotQuoted(),
         context_->getExternalDictionariesLoader().getDictionaryStructure(*dictionary_configuration),
+        dictionary_configuration->getString("dictionary.comment", ""),
         Location::SameDatabaseAndNameAsDictionary,
         context_)
 {
@@ -230,7 +234,7 @@ void StorageDictionary::renameInMemory(const StorageID & new_table_id)
         if (move_to_atomic)
             configuration->setString("dictionary.uuid", toString(new_table_id.uuid));
         else if (move_to_ordinary)
-                configuration->remove("dictionary.uuid");
+            configuration->remove("dictionary.uuid");
     }
 
     /// Dictionary is moving between databases of different engines or is renaming inside Ordinary database
@@ -260,6 +264,40 @@ void StorageDictionary::renameInMemory(const StorageID & new_table_id)
     }
 }
 
+void StorageDictionary::checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const
+{
+    for (const auto & command : commands)
+    {
+        if (location == Location::DictionaryDatabase || command.type != AlterCommand::COMMENT_TABLE)
+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Alter of type '{}' is not supported by storage {}",
+                command.type, getName());
+    }
+}
+
+void StorageDictionary::alter(const AlterCommands & params, ContextPtr alter_context, AlterLockHolder & lock_holder)
+{
+    IStorage::alter(params, alter_context, lock_holder);
+
+    if (location == Location::Custom)
+        return;
+
+    auto new_comment = getInMemoryMetadataPtr()->comment;
+
+    auto storage_id = getStorageID();
+    const auto & external_dictionaries_loader = getContext()->getExternalDictionariesLoader();
+    auto result = external_dictionaries_loader.getLoadResult(storage_id.getInternalDictionaryName());
+
+    if (result.object)
+    {
+        auto dictionary = std::static_pointer_cast<const IDictionary>(result.object);
+        auto * dictionary_non_const = const_cast<IDictionary *>(dictionary.get());
+        dictionary_non_const->setDictionaryComment(new_comment);
+    }
+
+    std::lock_guard<std::mutex> lock(dictionary_config_mutex);
+    configuration->setString("dictionary.comment", std::move(new_comment));
+}
+
 void registerStorageDictionary(StorageFactory & factory)
 {
     factory.registerStorage("Dictionary", [](const StorageFactory::Arguments & args)
diff --git a/src/Storages/StorageDictionary.h b/src/Storages/StorageDictionary.h
index 7d0af8c0ee32..855d02b0947f 100644
--- a/src/Storages/StorageDictionary.h
+++ b/src/Storages/StorageDictionary.h
@@ -42,6 +42,10 @@ class StorageDictionary final : public shared_ptr_helper<StorageDictionary>, pub
 
     void renameInMemory(const StorageID & new_table_id) override;
 
+    void checkAlterIsPossible(const AlterCommands & commands, ContextPtr /* context */) const override;
+
+    void alter(const AlterCommands & params, ContextPtr alter_context, AlterLockHolder &) override;
+
     Poco::Timestamp getUpdateTime() const;
     LoadablesConfigurationPtr getConfiguration() const;
 
@@ -89,6 +93,7 @@ class StorageDictionary final : public shared_ptr_helper<StorageDictionary>, pub
         const StorageID & table_id_,
         const String & dictionary_name_,
         const DictionaryStructure & dictionary_structure,
+        const String & comment,
         Location location_,
         ContextPtr context_);
 
diff --git a/src/Storages/System/StorageSystemDictionaries.cpp b/src/Storages/System/StorageSystemDictionaries.cpp
index d8f92d380815..c0d7d8cc4edb 100644
--- a/src/Storages/System/StorageSystemDictionaries.cpp
+++ b/src/Storages/System/StorageSystemDictionaries.cpp
@@ -142,7 +142,9 @@ void StorageSystemDictionaries::fillData(MutableColumns & res_columns, ContextPt
             res_columns[i++]->insertDefault();
 
         if (dict_ptr)
+        {
             res_columns[i++]->insert(dict_ptr->getDictionaryComment());
+        }
         else
         {
             if (load_result.config && load_result.config->config->has("dictionary.comment"))
