{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64582,
  "instance_id": "ClickHouse__ClickHouse-64582",
  "issue_numbers": [
    "51073"
  ],
  "base_commit": "db09d239dc84a87be0eca6b4c01ad2373f46d42e",
  "patch": "diff --git a/docs/en/sql-reference/functions/math-functions.md b/docs/en/sql-reference/functions/math-functions.md\nindex 7f50fa933b6a..12098efc6350 100644\n--- a/docs/en/sql-reference/functions/math-functions.md\n+++ b/docs/en/sql-reference/functions/math-functions.md\n@@ -415,8 +415,8 @@ Alias: `power(x, y)`\n \n **Arguments**\n \n-- `x` - [(U)Int8/16/32/64](../data-types/int-uint.md) or [Float*](../data-types/float.md)\n-- `y` - [(U)Int8/16/32/64](../data-types/int-uint.md) or [Float*](../data-types/float.md)\n+- `x` - [(U)Int8/16/32/64](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md)\n+- `y` - [(U)Int8/16/32/64](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md)\n \n **Returned value**\n \n@@ -635,8 +635,8 @@ atan2(y, x)\n \n **Arguments**\n \n-- `y` \u2014 y-coordinate of the point through which the ray passes. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n-- `x` \u2014 x-coordinate of the point through which the ray passes. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n+- `y` \u2014 y-coordinate of the point through which the ray passes. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md).\n+- `x` \u2014 x-coordinate of the point through which the ray passes. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md).\n \n **Returned value**\n \n@@ -670,8 +670,8 @@ hypot(x, y)\n \n **Arguments**\n \n-- `x` \u2014 The first cathetus of a right-angle triangle. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n-- `y` \u2014 The second cathetus of a right-angle triangle. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md).\n+- `x` \u2014 The first cathetus of a right-angle triangle. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md).\n+- `y` \u2014 The second cathetus of a right-angle triangle. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md).\n \n **Returned value**\n \n@@ -838,6 +838,7 @@ degrees(x)\n \n **Arguments**\n \n+- `x` \u2014 Input in radians. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md).\n - `x` \u2014 Input in radians. [(U)Int*](../data-types/int-uint.md), [Float*](../data-types/float.md) or [Decimal*](../data-types/decimal.md).  \n \n **Returned value**\ndiff --git a/docs/ru/sql-reference/functions/math-functions.md b/docs/ru/sql-reference/functions/math-functions.md\nindex 367451a5b324..caacbb216bfb 100644\n--- a/docs/ru/sql-reference/functions/math-functions.md\n+++ b/docs/ru/sql-reference/functions/math-functions.md\n@@ -304,8 +304,8 @@ atan2(y, x)\n \n **\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n \n--   `y` \u2014 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 y \u0442\u043e\u0447\u043a\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0440\u043e\u0432\u0435\u0434\u0435\u043d\u0430 \u043b\u0438\u043d\u0438\u044f. [Float64](../../sql-reference/data-types/float.md#float32-float64).\n--   `x` \u2014 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 \u0445 \u0442\u043e\u0447\u043a\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0440\u043e\u0432\u0435\u0434\u0435\u043d\u0430 \u043b\u0438\u043d\u0438\u044f. [Float64](../../sql-reference/data-types/float.md#float32-float64).\n+-   `y` \u2014 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 y \u0442\u043e\u0447\u043a\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0440\u043e\u0432\u0435\u0434\u0435\u043d\u0430 \u043b\u0438\u043d\u0438\u044f. [Float64](../../sql-reference/data-types/float.md#float32-float64) \u0438\u043b\u0438 [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `x` \u2014 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 \u0445 \u0442\u043e\u0447\u043a\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043f\u0440\u043e\u0432\u0435\u0434\u0435\u043d\u0430 \u043b\u0438\u043d\u0438\u044f. [Float64](../../sql-reference/data-types/float.md#float32-float64) \u0438\u043b\u0438 [Decimal](../../sql-reference/data-types/decimal.md).\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n \n@@ -341,8 +341,8 @@ hypot(x, y)\n \n **\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n \n--   `x` \u2014 \u043f\u0435\u0440\u0432\u044b\u0439 \u043a\u0430\u0442\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. [Float64](../../sql-reference/data-types/float.md#float32-float64).\n--   `y` \u2014 \u0432\u0442\u043e\u0440\u043e\u0439 \u043a\u0430\u0442\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. [Float64](../../sql-reference/data-types/float.md#float32-float64).\n+-   `x` \u2014 \u043f\u0435\u0440\u0432\u044b\u0439 \u043a\u0430\u0442\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. [Float64](../../sql-reference/data-types/float.md#float32-float64) \u0438\u043b\u0438 [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `y` \u2014 \u0432\u0442\u043e\u0440\u043e\u0439 \u043a\u0430\u0442\u0435\u0442 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. [Float64](../../sql-reference/data-types/float.md#float32-float64) \u0438\u043b\u0438 [Decimal](../../sql-reference/data-types/decimal.md).\n \n **\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n \ndiff --git a/src/Functions/FunctionMathBinaryFloat64.h b/src/Functions/FunctionMathBinaryFloat64.h\nindex d17e9cf3358c..1b75ee688f48 100644\n--- a/src/Functions/FunctionMathBinaryFloat64.h\n+++ b/src/Functions/FunctionMathBinaryFloat64.h\n@@ -8,6 +8,7 @@\n #include <Columns/ColumnConst.h>\n #include <Functions/IFunction.h>\n #include <Functions/FunctionHelpers.h>\n+#include <Interpreters/castColumn.h>\n \n #include \"config.h\"\n \n@@ -41,7 +42,7 @@ class FunctionMathBinaryFloat64 : public IFunction\n     {\n         const auto check_argument_type = [this] (const IDataType * arg)\n         {\n-            if (!isNativeNumber(arg))\n+            if (!isNativeNumber(arg) && !isDecimal(arg))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\",\n                     arg->getName(), getName());\n         };\n@@ -53,7 +54,7 @@ class FunctionMathBinaryFloat64 : public IFunction\n     }\n \n     template <typename LeftType, typename RightType>\n-    ColumnPtr executeTyped(const ColumnConst * left_arg, const IColumn * right_arg) const\n+    static ColumnPtr executeTyped(const ColumnConst * left_arg, const IColumn * right_arg)\n     {\n         if (const auto right_arg_typed = checkAndGetColumn<ColumnVector<RightType>>(right_arg))\n         {\n@@ -91,7 +92,7 @@ class FunctionMathBinaryFloat64 : public IFunction\n     }\n \n     template <typename LeftType, typename RightType>\n-    ColumnPtr executeTyped(const ColumnVector<LeftType> * left_arg, const IColumn * right_arg) const\n+    static ColumnPtr executeTyped(const ColumnVector<LeftType> * left_arg, const IColumn * right_arg)\n     {\n         if (const auto right_arg_typed = checkAndGetColumn<ColumnVector<RightType>>(right_arg))\n         {\n@@ -168,6 +169,25 @@ class FunctionMathBinaryFloat64 : public IFunction\n     {\n         const ColumnWithTypeAndName & col_left = arguments[0];\n         const ColumnWithTypeAndName & col_right = arguments[1];\n+\n+        ColumnPtr col_ptr_left = col_left.column;\n+        ColumnPtr col_ptr_right = col_right.column;\n+\n+        TypeIndex left_index = col_left.type->getTypeId();\n+        TypeIndex right_index = col_right.type->getTypeId();\n+\n+        if (WhichDataType(col_left.type).isDecimal())\n+        {\n+            col_ptr_left = castColumn(col_left, std::make_shared<DataTypeFloat64>());\n+            left_index = TypeIndex::Float64;\n+        }\n+\n+        if (WhichDataType(col_right.type).isDecimal())\n+        {\n+            col_ptr_right = castColumn(col_right, std::make_shared<DataTypeFloat64>());\n+            right_index = TypeIndex::Float64;\n+        }\n+\n         ColumnPtr res;\n \n         auto call = [&](const auto & types) -> bool\n@@ -177,8 +197,8 @@ class FunctionMathBinaryFloat64 : public IFunction\n             using RightType = typename Types::RightType;\n             using ColVecLeft = ColumnVector<LeftType>;\n \n-            const IColumn * left_arg = col_left.column.get();\n-            const IColumn * right_arg = col_right.column.get();\n+            const IColumn * left_arg = col_ptr_left.get();\n+            const IColumn * right_arg = col_ptr_right.get();\n \n             if (const auto left_arg_typed = checkAndGetColumn<ColVecLeft>(left_arg))\n             {\n@@ -200,9 +220,6 @@ class FunctionMathBinaryFloat64 : public IFunction\n             return false;\n         };\n \n-        TypeIndex left_index = col_left.type->getTypeId();\n-        TypeIndex right_index = col_right.type->getTypeId();\n-\n         if (!callOnBasicTypes<true, true, false, false>(left_index, right_index, call))\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n                 col_left.column->getName(), getName());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00700_decimal_math.reference b/tests/queries/0_stateless/00700_decimal_math.reference\nindex 389b428e27bd..613fbc1ecd52 100644\n--- a/tests/queries/0_stateless/00700_decimal_math.reference\n+++ b/tests/queries/0_stateless/00700_decimal_math.reference\n@@ -28,3 +28,6 @@\n 0\t0\t1\t0\n 3.14159265358979\t0\t-1\t-0\n 1\t1.5707963267948966\t0\t0.7853981633974483\n+4.2\t17.64\t2.04939015319192\n+4.2\t17.64\t2.04939015319192\n+4.2\t17.64\t2.04939015319192\ndiff --git a/tests/queries/0_stateless/00700_decimal_math.sql b/tests/queries/0_stateless/00700_decimal_math.sql\nindex 7f695a5b0173..5dc8f800334b 100644\n--- a/tests/queries/0_stateless/00700_decimal_math.sql\n+++ b/tests/queries/0_stateless/00700_decimal_math.sql\n@@ -40,6 +40,6 @@ SELECT toDecimal128(pi(), 14) AS x, round(sin(x), 8), round(cos(x), 8), round(ta\n SELECT toDecimal128('1.0', 2) AS x, asin(x), acos(x), atan(x);\n \n \n-SELECT toDecimal32('4.2', 1) AS x, pow(x, 2), pow(x, 0.5); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT toDecimal64('4.2', 1) AS x, pow(x, 2), pow(x, 0.5); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT toDecimal128('4.2', 1) AS x, pow(x, 2), pow(x, 0.5); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toDecimal32('4.2', 1) AS x, pow(x, 2), pow(x, 0.5);\n+SELECT toDecimal64('4.2', 1) AS x, pow(x, 2), pow(x, 0.5);\n+SELECT toDecimal128('4.2', 1) AS x, pow(x, 2), pow(x, 0.5);\ndiff --git a/tests/queries/0_stateless/02011_tuple_vector_functions.sql b/tests/queries/0_stateless/02011_tuple_vector_functions.sql\nindex d0cd89dc4640..8bfe5e53a72b 100644\n--- a/tests/queries/0_stateless/02011_tuple_vector_functions.sql\n+++ b/tests/queries/0_stateless/02011_tuple_vector_functions.sql\n@@ -78,7 +78,7 @@ SELECT max2(NULL, 1) - min2(NULL, 1);\n SELECT L1Norm(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT (1, 1) / toString(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT -(1, toString(1)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT LpNorm((1, 2), toDecimal32(2, 4)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT LpNorm((1, 2), toDecimal32(2, 4)); -- { serverError ILLEGAL_COLUMN }\n SELECT (1, 2) * toDecimal32(3.1, 8);\n \n SELECT cosineDistance((1, 2), (2, 3, 4)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\ndiff --git a/tests/queries/0_stateless/03161_decimal_binary_math.reference b/tests/queries/0_stateless/03161_decimal_binary_math.reference\nnew file mode 100644\nindex 000000000000..f7d9761c7c5d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03161_decimal_binary_math.reference\n@@ -0,0 +1,75 @@\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+42.4242\t2.42\t8686.104718\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+0.4242\t0.24\t0.514871\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t2.42\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+42.4242\t2.42\t42.4242\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\n+0.4242\t0.4242\t0.599909\ndiff --git a/tests/queries/0_stateless/03161_decimal_binary_math.sql b/tests/queries/0_stateless/03161_decimal_binary_math.sql\nnew file mode 100644\nindex 000000000000..5484cc6a9bb0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03161_decimal_binary_math.sql\n@@ -0,0 +1,79 @@\n+SELECT toDecimal32('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT toDecimal64('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, toDecimal64('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT toDecimal64('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(pow(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, toDecimal32('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(pow(x, y), 6);\n+SELECT 42.4242 AS x, toDecimal32('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, 2.42 AS y, round(pow(x, y), 6);\n+SELECT materialize(42.4242) AS x, toDecimal32('2.42', 2) AS y, round(pow(x, y), 6);\n+SELECT 42.4242 AS x, materialize(toDecimal32('2.42', 2)) AS y, round(pow(x, y), 6);\n+SELECT materialize(42.4242) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(pow(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, 2.42 AS y, round(pow(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, materialize(2.42) AS y, round(pow(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, materialize(2.42) AS y, round(pow(x, y), 6);\n+\n+SELECT toDecimal32('0.4242', 4) AS x, toDecimal32('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT toDecimal64('0.4242', 4) AS x, toDecimal32('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, toDecimal64('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT toDecimal64('0.4242', 4) AS x, toDecimal64('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, materialize(toDecimal32('0.24', 2)) AS y, round(atan2(y, x), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, toDecimal32('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, materialize(toDecimal32('0.24', 2)) AS y, round(atan2(y, x), 6);\n+SELECT 0.4242 AS x, toDecimal32('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, 0.24 AS y, round(atan2(y, x), 6);\n+SELECT materialize(0.4242) AS x, toDecimal32('0.24', 2) AS y, round(atan2(y, x), 6);\n+SELECT 0.4242 AS x, materialize(toDecimal32('0.24', 2)) AS y, round(atan2(y, x), 6);\n+SELECT materialize(0.4242) AS x, materialize(toDecimal32('0.24', 2)) AS y, round(atan2(y, x), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, 0.24 AS y, round(atan2(y, x), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, materialize(0.24) AS y, round(atan2(y, x), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, materialize(0.24) AS y, round(atan2(y, x), 6);\n+\n+SELECT toDecimal32('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT toDecimal64('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, toDecimal64('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT toDecimal64('42.4242', 4) AS x, toDecimal64('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(min2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, toDecimal32('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(min2(x, y), 6);\n+SELECT 42.4242 AS x, toDecimal32('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, 2.42 AS y, round(min2(x, y), 6);\n+SELECT materialize(42.4242) AS x, toDecimal32('2.42', 2) AS y, round(min2(x, y), 6);\n+SELECT 42.4242 AS x, materialize(toDecimal32('2.42', 2)) AS y, round(min2(x, y), 6);\n+SELECT materialize(42.4242) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(min2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, 2.42 AS y, round(min2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, materialize(2.42) AS y, round(min2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, materialize(2.42) AS y, round(min2(x, y), 6);\n+\n+SELECT toDecimal32('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT toDecimal64('42.4242', 4) AS x, toDecimal32('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, toDecimal64('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT toDecimal64('42.4242', 4) AS x, toDecimal64('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(max2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, toDecimal32('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(max2(x, y), 6);\n+SELECT 42.4242 AS x, toDecimal32('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, 2.42 AS y, round(max2(x, y), 6);\n+SELECT materialize(42.4242) AS x, toDecimal32('2.42', 2) AS y, round(max2(x, y), 6);\n+SELECT 42.4242 AS x, materialize(toDecimal32('2.42', 2)) AS y, round(max2(x, y), 6);\n+SELECT materialize(42.4242) AS x, materialize(toDecimal32('2.42', 2)) AS y, round(max2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, 2.42 AS y, round(max2(x, y), 6);\n+SELECT toDecimal32('42.4242', 4) AS x, materialize(2.42) AS y, round(max2(x, y), 6);\n+SELECT materialize(toDecimal32('42.4242', 4)) AS x, materialize(2.42) AS y, round(max2(x, y), 6);\n+\n+SELECT toDecimal32('0.4242', 4) AS x, toDecimal32('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT toDecimal64('0.4242', 4) AS x, toDecimal32('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, toDecimal64('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT toDecimal64('0.4242', 4) AS x, toDecimal64('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, materialize(toDecimal32('0.4242', 4)) AS y, round(hypot(x, y), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, toDecimal32('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, materialize(toDecimal32('0.4242', 4)) AS y, round(hypot(x, y), 6);\n+SELECT 0.4242 AS x, toDecimal32('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, 0.4242 AS y, round(hypot(x, y), 6);\n+SELECT materialize(0.4242) AS x, toDecimal32('0.4242', 4) AS y, round(hypot(x, y), 6);\n+SELECT 0.4242 AS x, materialize(toDecimal32('0.4242', 4)) AS y, round(hypot(x, y), 6);\n+SELECT materialize(0.4242) AS x, materialize(toDecimal32('0.4242', 4)) AS y, round(hypot(x, y), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, 0.4242 AS y, round(hypot(x, y), 6);\n+SELECT toDecimal32('0.4242', 4) AS x, materialize(0.4242) AS y, round(hypot(x, y), 6);\n+SELECT materialize(toDecimal32('0.4242', 4)) AS x, materialize(0.4242) AS y, round(hypot(x, y), 6);\n",
  "problem_statement": "use decimal type with pow function\nhello,\r\n\r\nversion 23.5.2\r\n\r\n`SELECT pow(toDecimal32(2, 2), 3)`\r\n\r\nproduce DB::Exception: Illegal type Decimal(9, 2) of argument of function pow: While processing pow(toDecimal32(2, 2), 3). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n\r\nthanks a lot\r\n\r\n\r\n\n",
  "hints_text": "I am currently working on adding support for decimal types in pow function. Please assign this task to me if possible.\n@KochetovNicolai @kitaisreal @4ertus2\r\nHello!\r\n\r\n- I did research on how Decimals are processed in CH functions:\r\n\r\n+, -, *, / - 2 arguments, supported in all combinations with other types (FunctionBinaryArithmetics/DecimalBinaryOperation - does scaling to adjust precision)\r\n\r\nmultiplyDecimal, divideDecimal - 2 arguments, only Decimals supported (FunctionsDecimalArithmetics, with bound checks)\r\n\r\nlog - 1 argument, supported (FunctionMathUnary)\r\nlgamma - 1 argument, supported (FunctionMathUnary)\r\nsin - 1 argument, supported (FunctionMathUnary)\r\ntan - 1 argument, supported (FunctionMathUnary)\r\nexp2 - 1 argument, supported (FunctionMathUnary)\r\n\u2026\r\n\r\npow - 2 arguments, not supported (FunctionMathBinaryFloat64) \r\natan2 - 2 arguments, not supported (FunctionMathBinaryFloat64) \r\nmax2 - 2 arguments, not supported (FunctionMathBinaryFloat64)\r\nmin2 - 2 arguments, not supported (FunctionMathBinaryFloat64)\r\nhypot - 2 arguments, not supported (FunctionMathBinaryFloat64)\r\n\r\nSo, we need to support Decimals in pow() function (both arguments). For other binary functions, like atan2 or max2, this is done for free.  \r\n- The proposal is to adapt FunctionMathBinaryFloat64 for handling Decimals (since we don't need scaling, but cast to Float64 only), exactly as it is done in FunctionMathUnary.\r\n- Class rename is not needed, since the implementation keeps returning Float64, but extends the functionality to handle Decimals as well.\r\n- Outline of necessary steps:\r\n\r\n1. allow decimals in check_argument_type;\r\n2. check for ColumnVectorOrDecimal for both arguments in executeImpl lambda;\r\n3. split executeTyped to executeTyped and executeInIterations, like in FunctionMathUnary;\r\n4. overload the combinations of parameter types in executeTyped (ColumnDecimal + ColumnDecimal, ColumnDecimal + ColumnVector, ColumnVector + ColumnDecimal, ColumnVector + ColumnVector);\r\n5. perform DecimalsUtils::convertTo< Float64 > for ColumnDecimal.\r\n\r\n- This approach is proven to work fine:\r\n![pow](https://github.com/ClickHouse/ClickHouse/assets/5475799/54a2e8c7-510e-4ff5-a62d-7be8f6f9b801)\r\n\r\n- Please give some feedback if this approach is ok for the community.\n@rschu1ze @azat Could you please comment if the selected approach is OK, so Mikhail could fine-tune the implementation and create a PR. \nI think it makes sense for pow() of decimal to operate and return decimal, not float. Otherwise what's the point?\n> I think it makes sense for pow() of decimal to operate and return decimal, not float. Otherwise what's the point?\r\n\r\nUnary functions, like sinus, always return Float64, as I understand, but for some binary functions, like max2/min2 it makes sense returning decimal, if both arguments are decimals, to save the precision, but what if one is decimal, and the other one is float?\r\nThe underlying C API for pow, atan2, and hypot accepts doubles, and return doubles, so the client will not benefit from returning decimal for these.\nAre we still taking about pow()? Because I understand why sin() would return a Float, but not why pow() would loose precision unnecessarily.\r\n\r\n> The underlying C API for pow, atan2, and hypot accepts doubles, and return doubles, so the client will not benefit from returning decimal for these.\r\n\r\nThen maybe we need to not use the underlying C API to implement this. The same way we don't use the std for add 2 decimals.\n> Are we still taking about pow()? Because I understand why sin() would return a Float, but not why pow() would loose precision unnecessarily.\r\n> \r\n> > The underlying C API for pow, atan2, and hypot accepts doubles, and return doubles, so the client will not benefit from returning decimal for these.\r\n> \r\n> Then maybe we need to not use the underlying C API to implement this. The same way we don't use the std for add 2 decimals.\r\n\r\nOk, I see. I need to think about it.\nI think decimals are good (and used in production this way) for currency calculations. So it makes sense to use decimal arithmetic for addition and subtraction (and OK for multiplication/division by integers). But not for functions like `pow`. While it's OK to pass decimal arguments to `pow`.\r\n\r\n> Are we still taking about pow()? Because I understand why sin() would return a Float, but not why pow() would loose precision unnecessarily.\r\n> \r\n\r\nWhen using\r\n\r\n```sql\r\nSELECT pow(toDecimal32(2.12323, 2), toDecimal32(3.12323, 3)) \r\n```\r\n\r\nWhat should be the resulting precision? 2, 3, 6?\r\n\r\nSo I think this we still use C `pow` function which returns double and we need to return Float64.\r\n\r\n\r\n \r\n> Then maybe we need to not use the underlying C API to implement this. The same way we don't use the std for add 2 decimals.\r\n\r\nFor addition/subtraction it's OK to use decimal arithmetic implemented in ClickHouse. But not for functions like `pow`, `sin`, `cos`. \n> So I think this we still use C pow function which returns double and we need to return Float64.\r\n\r\nJust because we need to think how to do it properly it's not ok to do it wrong.\r\n\r\n```\r\nSELECT\r\n    CAST('0.1', 'Decimal(20, 10)') AS a,\r\n    a * a AS b,\r\n    toTypeName(b)\r\n\r\nQuery id: 4fe512f9-ed3d-4d43-8625-b42d4d8397a6\r\n\r\n   \u250c\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500\u2500b\u2500\u252c\u2500toTypeName(b)\u2500\u2500\u2500\u2510\r\n1. \u2502 0.1 \u2502 0.01 \u2502 Decimal(38, 20) \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nPow() is closer to multiply than it is to sine, as the result of sin() is known and limited and the we can understand the loss in precision. What's the point of having a fixed point type if you are going to always use the flawed floating point type?\n> > So I think this we still use C pow function which returns double and we need to return Float64.\r\n> \r\n> Just because we need to think how to do it properly it's not ok to do it wrong.\r\n> \r\n> ```\r\n> SELECT\r\n>     CAST('0.1', 'Decimal(20, 10)') AS a,\r\n>     a * a AS b,\r\n>     toTypeName(b)\r\n> \r\n> Query id: 4fe512f9-ed3d-4d43-8625-b42d4d8397a6\r\n> \r\n>    \u250c\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500\u2500b\u2500\u252c\u2500toTypeName(b)\u2500\u2500\u2500\u2510\r\n> 1. \u2502 0.1 \u2502 0.01 \u2502 Decimal(38, 20) \u2502\r\n>    \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n> ```\r\n> \r\n> Pow() is closer to multiply than it is to sine, as the result of sin() is known and limited and the we can understand the loss in precision. What's the point of having a fixed point type if you are going to always use the flawed floating point type?\r\n\r\nYou see, we may do the following:\r\n1. In the first phase we can make a Float64 type cast inside CH instead of having the client do this manually (probably, the initial ask was about this). That's what I suggested. This will not spoil the precision compared to what we have now.\r\n2. In the second phase we can tune up \"the flawed\" functions: pow(), min2(), max2().\r\nWhat do you think about this?\n2 phases and changing the return type is a breaking change that I'd rather not have.",
  "created_at": "2024-05-29T14:03:25Z",
  "modified_files": [
    "docs/en/sql-reference/functions/math-functions.md",
    "docs/ru/sql-reference/functions/math-functions.md",
    "src/Functions/FunctionMathBinaryFloat64.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00700_decimal_math.reference",
    "tests/queries/0_stateless/00700_decimal_math.sql",
    "tests/queries/0_stateless/02011_tuple_vector_functions.sql",
    "b/tests/queries/0_stateless/03161_decimal_binary_math.reference",
    "b/tests/queries/0_stateless/03161_decimal_binary_math.sql"
  ]
}