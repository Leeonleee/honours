diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp
index dffe2239e62a..915d14466b6b 100644
--- a/src/Common/ProfileEvents.cpp
+++ b/src/Common/ProfileEvents.cpp
@@ -22,10 +22,6 @@
     M(WriteBufferFromFileDescriptorWrite, "Number of writes (write/pwrite) to a file descriptor. Does not include sockets.") \
     M(WriteBufferFromFileDescriptorWriteFailed, "Number of times the write (write/pwrite) to a file descriptor have failed.") \
     M(WriteBufferFromFileDescriptorWriteBytes, "Number of bytes written to file descriptors. If the file is compressed, this will show compressed data size.") \
-    M(ReadBufferAIORead, "") \
-    M(ReadBufferAIOReadBytes, "") \
-    M(WriteBufferAIOWrite, "") \
-    M(WriteBufferAIOWriteBytes, "") \
     M(ReadCompressedBytes, "Number of bytes (the number of bytes before decompression) read from compressed sources (files, network).") \
     M(CompressedReadBufferBlocks, "Number of compressed blocks (the blocks of data that are compressed independent of each other) read from compressed sources (files, network).") \
     M(CompressedReadBufferBytes, "Number of uncompressed bytes (the number of bytes after decompression) read from compressed sources (files, network).") \
@@ -34,6 +30,10 @@
     M(UncompressedCacheWeightLost, "") \
     M(MMappedFileCacheHits, "") \
     M(MMappedFileCacheMisses, "") \
+    M(AIOWrite, "Number of writes with Linux or FreeBSD AIO interface") \
+    M(AIOWriteBytes, "Number of bytes written with Linux or FreeBSD AIO interface") \
+    M(AIORead, "Number of reads with Linux or FreeBSD AIO interface") \
+    M(AIOReadBytes, "Number of bytes read with Linux or FreeBSD AIO interface") \
     M(IOBufferAllocs, "") \
     M(IOBufferAllocBytes, "") \
     M(ArenaAllocChunks, "") \
@@ -43,8 +43,8 @@
     M(MarkCacheHits, "") \
     M(MarkCacheMisses, "") \
     M(CreatedReadBufferOrdinary, "") \
-    M(CreatedReadBufferAIO, "") \
-    M(CreatedReadBufferAIOFailed, "") \
+    M(CreatedReadBufferDirectIO, "") \
+    M(CreatedReadBufferDirectIOFailed, "") \
     M(CreatedReadBufferMMap, "") \
     M(CreatedReadBufferMMapFailed, "") \
     M(DiskReadElapsedMicroseconds, "Total time spent waiting for read syscall. This include reads from page cache.") \
diff --git a/src/Compression/CompressedReadBufferFromFile.cpp b/src/Compression/CompressedReadBufferFromFile.cpp
index e14a1784b144..22ffb74f61a7 100644
--- a/src/Compression/CompressedReadBufferFromFile.cpp
+++ b/src/Compression/CompressedReadBufferFromFile.cpp
@@ -47,13 +47,13 @@ CompressedReadBufferFromFile::CompressedReadBufferFromFile(std::unique_ptr<ReadB
 CompressedReadBufferFromFile::CompressedReadBufferFromFile(
     const std::string & path,
     size_t estimated_size,
-    size_t aio_threshold,
+    size_t direct_io_threshold,
     size_t mmap_threshold,
     MMappedFileCache * mmap_cache,
     size_t buf_size,
     bool allow_different_codecs_)
     : BufferWithOwnMemory<ReadBuffer>(0)
-    , p_file_in(createReadBufferFromFileBase(path, estimated_size, aio_threshold, mmap_threshold, mmap_cache, buf_size))
+    , p_file_in(createReadBufferFromFileBase(path, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache, buf_size))
     , file_in(*p_file_in)
 {
     compressed_in = &file_in;
diff --git a/src/Compression/CompressedReadBufferFromFile.h b/src/Compression/CompressedReadBufferFromFile.h
index 2ee7021b35ad..fe9add6f0153 100644
--- a/src/Compression/CompressedReadBufferFromFile.h
+++ b/src/Compression/CompressedReadBufferFromFile.h
@@ -33,7 +33,7 @@ class CompressedReadBufferFromFile : public CompressedReadBufferBase, public Buf
     CompressedReadBufferFromFile(std::unique_ptr<ReadBufferFromFileBase> buf, bool allow_different_codecs_ = false);
 
     CompressedReadBufferFromFile(
-        const std::string & path, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,
+        const std::string & path, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE, bool allow_different_codecs_ = false);
 
     void seek(size_t offset_in_compressed_file, size_t offset_in_decompressed_block);
diff --git a/src/Dictionaries/SSDCacheDictionaryStorage.h b/src/Dictionaries/SSDCacheDictionaryStorage.h
index 7232d2d01b73..395328a904d7 100644
--- a/src/Dictionaries/SSDCacheDictionaryStorage.h
+++ b/src/Dictionaries/SSDCacheDictionaryStorage.h
@@ -26,8 +26,10 @@
 namespace ProfileEvents
 {
     extern const Event FileOpen;
-    extern const Event WriteBufferAIOWrite;
-    extern const Event WriteBufferAIOWriteBytes;
+    extern const Event AIOWrite;
+    extern const Event AIOWriteBytes;
+    extern const Event AIORead;
+    extern const Event AIOReadBytes;
 }
 
 namespace DB
@@ -531,8 +533,8 @@ class SSDCacheFileBuffer : private boost::noncopyable
 
         auto bytes_written = eventResult(event);
 
-        ProfileEvents::increment(ProfileEvents::WriteBufferAIOWrite);
-        ProfileEvents::increment(ProfileEvents::WriteBufferAIOWriteBytes, bytes_written);
+        ProfileEvents::increment(ProfileEvents::AIOWrite);
+        ProfileEvents::increment(ProfileEvents::AIOWriteBytes, bytes_written);
 
         if (bytes_written != static_cast<decltype(bytes_written)>(block_size * buffer_size_in_blocks))
             throw Exception(ErrorCodes::AIO_WRITE_ERROR,
@@ -600,6 +602,9 @@ class SSDCacheFileBuffer : private boost::noncopyable
                 buffer_size_in_bytes,
                 read_bytes);
 
+        ProfileEvents::increment(ProfileEvents::AIORead);
+        ProfileEvents::increment(ProfileEvents::AIOReadBytes, read_bytes);
+
         SSDCacheBlock block(block_size);
 
         for (size_t i = 0; i < blocks_length; ++i)
@@ -687,6 +692,9 @@ class SSDCacheFileBuffer : private boost::noncopyable
                     throw Exception(ErrorCodes::AIO_READ_ERROR,
                         "GC: AIO failed to read file ({}). Expected bytes ({}). Actual bytes ({})", file_path, block_size, read_bytes);
 
+                ProfileEvents::increment(ProfileEvents::AIORead);
+                ProfileEvents::increment(ProfileEvents::AIOReadBytes, read_bytes);
+
                 char * request_buffer = getRequestBuffer(request);
 
                 // Unpoison the memory returned from an uninstrumented system function.
diff --git a/src/Disks/DiskCacheWrapper.cpp b/src/Disks/DiskCacheWrapper.cpp
index d5b82edb134a..f672376841e2 100644
--- a/src/Disks/DiskCacheWrapper.cpp
+++ b/src/Disks/DiskCacheWrapper.cpp
@@ -90,17 +90,17 @@ DiskCacheWrapper::readFile(
     const String & path,
     size_t buf_size,
     size_t estimated_size,
-    size_t aio_threshold,
+    size_t direct_io_threshold,
     size_t mmap_threshold,
     MMappedFileCache * mmap_cache) const
 {
     if (!cache_file_predicate(path))
-        return DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+        return DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
 
     LOG_DEBUG(log, "Read file {} from cache", backQuote(path));
 
     if (cache_disk->exists(path))
-        return cache_disk->readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+        return cache_disk->readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
 
     auto metadata = acquireDownloadMetadata(path);
 
@@ -134,7 +134,7 @@ DiskCacheWrapper::readFile(
 
                 auto tmp_path = path + ".tmp";
                 {
-                    auto src_buffer = DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+                    auto src_buffer = DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
                     auto dst_buffer = cache_disk->writeFile(tmp_path, buf_size, WriteMode::Rewrite);
                     copyData(*src_buffer, *dst_buffer);
                 }
@@ -158,9 +158,9 @@ DiskCacheWrapper::readFile(
     }
 
     if (metadata->status == DOWNLOADED)
-        return cache_disk->readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+        return cache_disk->readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
 
-    return DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+    return DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
 }
 
 std::unique_ptr<WriteBufferFromFileBase>
diff --git a/src/Disks/DiskCacheWrapper.h b/src/Disks/DiskCacheWrapper.h
index 6d58394640fd..7e711dd521c4 100644
--- a/src/Disks/DiskCacheWrapper.h
+++ b/src/Disks/DiskCacheWrapper.h
@@ -38,7 +38,7 @@ class DiskCacheWrapper : public DiskDecorator
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
 
diff --git a/src/Disks/DiskDecorator.cpp b/src/Disks/DiskDecorator.cpp
index d1ff3f9f8277..7237a249bcb2 100644
--- a/src/Disks/DiskDecorator.cpp
+++ b/src/Disks/DiskDecorator.cpp
@@ -115,9 +115,9 @@ void DiskDecorator::listFiles(const String & path, std::vector<String> & file_na
 
 std::unique_ptr<ReadBufferFromFileBase>
 DiskDecorator::readFile(
-    const String & path, size_t buf_size, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const
+    const String & path, size_t buf_size, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const
 {
-    return delegate->readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+    return delegate->readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
 }
 
 std::unique_ptr<WriteBufferFromFileBase>
diff --git a/src/Disks/DiskDecorator.h b/src/Disks/DiskDecorator.h
index 401078e6b2eb..0910f4c28cd6 100644
--- a/src/Disks/DiskDecorator.h
+++ b/src/Disks/DiskDecorator.h
@@ -39,7 +39,7 @@ class DiskDecorator : public IDisk
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
 
diff --git a/src/Disks/DiskLocal.cpp b/src/Disks/DiskLocal.cpp
index 89c1514f5c88..4ceb76ab0593 100644
--- a/src/Disks/DiskLocal.cpp
+++ b/src/Disks/DiskLocal.cpp
@@ -211,9 +211,9 @@ void DiskLocal::replaceFile(const String & from_path, const String & to_path)
 
 std::unique_ptr<ReadBufferFromFileBase>
 DiskLocal::readFile(
-    const String & path, size_t buf_size, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const
+    const String & path, size_t buf_size, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const
 {
-    return createReadBufferFromFileBase(fs::path(disk_path) / path, estimated_size, aio_threshold, mmap_threshold, mmap_cache, buf_size);
+    return createReadBufferFromFileBase(fs::path(disk_path) / path, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache, buf_size);
 }
 
 std::unique_ptr<WriteBufferFromFileBase>
diff --git a/src/Disks/DiskLocal.h b/src/Disks/DiskLocal.h
index 47482ad8d673..63a6fe59beaa 100644
--- a/src/Disks/DiskLocal.h
+++ b/src/Disks/DiskLocal.h
@@ -74,7 +74,7 @@ class DiskLocal : public IDisk
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
 
diff --git a/src/Disks/DiskMemory.h b/src/Disks/DiskMemory.h
index d5c57b20a4a8..40fd2b2a9f91 100644
--- a/src/Disks/DiskMemory.h
+++ b/src/Disks/DiskMemory.h
@@ -66,7 +66,7 @@ class DiskMemory : public IDisk
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
 
diff --git a/src/Disks/DiskRestartProxy.cpp b/src/Disks/DiskRestartProxy.cpp
index 2600dc5a1e14..1bd5b2acf50f 100644
--- a/src/Disks/DiskRestartProxy.cpp
+++ b/src/Disks/DiskRestartProxy.cpp
@@ -187,11 +187,11 @@ void DiskRestartProxy::listFiles(const String & path, std::vector<String> & file
 }
 
 std::unique_ptr<ReadBufferFromFileBase> DiskRestartProxy::readFile(
-    const String & path, size_t buf_size, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache)
+    const String & path, size_t buf_size, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache)
     const
 {
     ReadLock lock (mutex);
-    auto impl = DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);
+    auto impl = DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);
     return std::make_unique<RestartAwareReadBuffer>(*this, std::move(impl));
 }
 
diff --git a/src/Disks/DiskRestartProxy.h b/src/Disks/DiskRestartProxy.h
index f5502d9d68f5..e6c94d9ad7bc 100644
--- a/src/Disks/DiskRestartProxy.h
+++ b/src/Disks/DiskRestartProxy.h
@@ -47,7 +47,7 @@ class DiskRestartProxy : public DiskDecorator
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
     std::unique_ptr<WriteBufferFromFileBase> writeFile(const String & path, size_t buf_size, WriteMode mode) override;
diff --git a/src/Disks/HDFS/DiskHDFS.h b/src/Disks/HDFS/DiskHDFS.h
index 49fdf44728b7..1f93192fd573 100644
--- a/src/Disks/HDFS/DiskHDFS.h
+++ b/src/Disks/HDFS/DiskHDFS.h
@@ -48,7 +48,7 @@ class DiskHDFS final : public IDiskRemote
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
 
diff --git a/src/Disks/IDisk.h b/src/Disks/IDisk.h
index ecaf7d63fdcc..f9e7624f4ab8 100644
--- a/src/Disks/IDisk.h
+++ b/src/Disks/IDisk.h
@@ -156,7 +156,7 @@ class IDisk : public Space
         const String & path,
         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,
         size_t estimated_size = 0,
-        size_t aio_threshold = 0,
+        size_t direct_io_threshold = 0,
         size_t mmap_threshold = 0,
         MMappedFileCache * mmap_cache = nullptr) const = 0;
 
diff --git a/src/Disks/S3/DiskS3.h b/src/Disks/S3/DiskS3.h
index 21bf0d3867b9..fc7c832e45d6 100644
--- a/src/Disks/S3/DiskS3.h
+++ b/src/Disks/S3/DiskS3.h
@@ -77,7 +77,7 @@ class DiskS3 final : public IDiskRemote
         const String & path,
         size_t buf_size,
         size_t estimated_size,
-        size_t aio_threshold,
+        size_t direct_io_threshold,
         size_t mmap_threshold,
         MMappedFileCache * mmap_cache) const override;
 
diff --git a/src/IO/HashingReadBuffer.h b/src/IO/HashingReadBuffer.h
index 08b6de69dcbf..5d42c64478c6 100644
--- a/src/IO/HashingReadBuffer.h
+++ b/src/IO/HashingReadBuffer.h
@@ -34,7 +34,7 @@ class HashingReadBuffer : public IHashingBuffer<ReadBuffer>
         working_buffer = in.buffer();
         pos = in.position();
 
-        // `pos` may be different from working_buffer.begin() when using AIO.
+        // `pos` may be different from working_buffer.begin() when using sophisticated ReadBuffers.
         calculateHash(pos, working_buffer.end() - pos);
 
         return res;
diff --git a/src/IO/ReadBufferAIO.cpp b/src/IO/ReadBufferAIO.cpp
deleted file mode 100644
index c064e0d4ed9b..000000000000
--- a/src/IO/ReadBufferAIO.cpp
+++ /dev/null
@@ -1,312 +0,0 @@
-#if defined(OS_LINUX) || defined(__FreeBSD__)
-
-#include <IO/ReadBufferAIO.h>
-#include <IO/AIOContextPool.h>
-#include <Common/ProfileEvents.h>
-#include <Common/Stopwatch.h>
-#include <Common/MemorySanitizer.h>
-#include <Core/Defines.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <errno.h>
-
-#include <optional>
-
-
-namespace ProfileEvents
-{
-    extern const Event FileOpen;
-    extern const Event ReadBufferAIORead;
-    extern const Event ReadBufferAIOReadBytes;
-}
-
-namespace CurrentMetrics
-{
-    extern const Metric Read;
-}
-
-namespace DB
-{
-
-namespace ErrorCodes
-{
-    extern const int FILE_DOESNT_EXIST;
-    extern const int CANNOT_OPEN_FILE;
-    extern const int LOGICAL_ERROR;
-    extern const int ARGUMENT_OUT_OF_BOUND;
-    extern const int AIO_READ_ERROR;
-}
-
-
-/// Note: an additional page is allocated that will contain the data that
-/// does not fit into the main buffer.
-ReadBufferAIO::ReadBufferAIO(const std::string & filename_, size_t buffer_size_, int flags_, char * existing_memory_)
-    : ReadBufferFromFileBase(buffer_size_ + DEFAULT_AIO_FILE_BLOCK_SIZE, existing_memory_, DEFAULT_AIO_FILE_BLOCK_SIZE),
-      fill_buffer(BufferWithOwnMemory<ReadBuffer>(internalBuffer().size(), nullptr, DEFAULT_AIO_FILE_BLOCK_SIZE)),
-      filename(filename_)
-{
-    ProfileEvents::increment(ProfileEvents::FileOpen);
-
-    int open_flags = (flags_ == -1) ? O_RDONLY : flags_;
-    open_flags |= O_DIRECT;
-    open_flags |= O_CLOEXEC;
-
-    fd = ::open(filename.c_str(), open_flags);
-    if (fd == -1)
-    {
-        auto error_code = (errno == ENOENT) ? ErrorCodes::FILE_DOESNT_EXIST : ErrorCodes::CANNOT_OPEN_FILE;
-        throwFromErrnoWithPath("Cannot open file " + filename, filename, error_code);
-    }
-}
-
-ReadBufferAIO::~ReadBufferAIO()
-{
-    if (!aio_failed)
-    {
-        try
-        {
-            (void) waitForAIOCompletion();
-        }
-        catch (...)
-        {
-            tryLogCurrentException(__PRETTY_FUNCTION__);
-        }
-    }
-
-    if (fd != -1)
-        ::close(fd);
-}
-
-void ReadBufferAIO::setMaxBytes(size_t max_bytes_read_)
-{
-    if (is_started)
-        throw Exception("Illegal attempt to set the maximum number of bytes to read from file " + filename, ErrorCodes::LOGICAL_ERROR);
-    max_bytes_read = max_bytes_read_;
-}
-
-bool ReadBufferAIO::nextImpl()
-{
-    /// If the end of the file has already been reached by calling this function,
-    /// then the current call is wrong.
-    if (is_eof)
-        return false;
-
-    std::optional<Stopwatch> watch;
-    if (profile_callback)
-        watch.emplace(clock_type);
-
-    if (!is_pending_read)
-        synchronousRead();
-    else
-        receive();
-
-    if (profile_callback)
-    {
-        ProfileInfo info;
-        info.bytes_requested = requested_byte_count;
-        info.bytes_read = bytes_read;
-        info.nanoseconds = watch->elapsed(); //-V1007
-        profile_callback(info);
-    }
-
-    is_started = true;
-
-    /// If the end of the file is just reached, do nothing else.
-    if (is_eof)
-        return bytes_read != 0;
-
-    /// Create an asynchronous request.
-    prepare();
-
-#if defined(__FreeBSD__)
-    request.aio.aio_lio_opcode = LIO_READ;
-    request.aio.aio_fildes = fd;
-    request.aio.aio_buf = reinterpret_cast<volatile void *>(buffer_begin);
-    request.aio.aio_nbytes = region_aligned_size;
-    request.aio.aio_offset = region_aligned_begin;
-#else
-    request.aio_lio_opcode = IOCB_CMD_PREAD;
-    request.aio_fildes = fd;
-    request.aio_buf = reinterpret_cast<UInt64>(buffer_begin);
-    request.aio_nbytes = region_aligned_size;
-    request.aio_offset = region_aligned_begin;
-#endif
-
-    /// Send the request.
-    try
-    {
-        future_bytes_read = AIOContextPool::instance().post(request);
-    }
-    catch (...)
-    {
-        aio_failed = true;
-        throw;
-    }
-
-    is_pending_read = true;
-    return true;
-}
-
-off_t ReadBufferAIO::seek(off_t off, int whence)
-{
-    off_t new_pos_in_file;
-
-    if (whence == SEEK_SET)
-    {
-        if (off < 0)
-            throw Exception("SEEK_SET underflow", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-        new_pos_in_file = off;
-    }
-    else if (whence == SEEK_CUR)
-    {
-        if (off >= 0)
-        {
-            if (off > (std::numeric_limits<off_t>::max() - getPosition()))
-                throw Exception("SEEK_CUR overflow", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-        }
-        else if (off < -getPosition())
-            throw Exception("SEEK_CUR underflow", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-        new_pos_in_file = getPosition() + off;
-    }
-    else
-        throw Exception("ReadBufferAIO::seek expects SEEK_SET or SEEK_CUR as whence", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-
-    if (new_pos_in_file != getPosition())
-    {
-        off_t first_read_pos_in_file = first_unread_pos_in_file - static_cast<off_t>(working_buffer.size());
-        if (hasPendingData() && (new_pos_in_file >= first_read_pos_in_file) && (new_pos_in_file <= first_unread_pos_in_file))
-        {
-            /// Moved, but remained within the buffer.
-            pos = working_buffer.begin() + (new_pos_in_file - first_read_pos_in_file);
-        }
-        else
-        {
-            /// Moved past the buffer.
-            pos = working_buffer.end();
-            first_unread_pos_in_file = new_pos_in_file;
-
-            /// If we go back, than it's not eof
-            is_eof = false;
-
-            /// We can not use the result of the current asynchronous request.
-            skip();
-        }
-    }
-
-    return new_pos_in_file;
-}
-
-void ReadBufferAIO::synchronousRead()
-{
-    CurrentMetrics::Increment metric_increment_read{CurrentMetrics::Read};
-
-    prepare();
-    bytes_read = ::pread(fd, buffer_begin, region_aligned_size, region_aligned_begin);
-
-    ProfileEvents::increment(ProfileEvents::ReadBufferAIORead);
-    ProfileEvents::increment(ProfileEvents::ReadBufferAIOReadBytes, bytes_read);
-
-    finalize();
-}
-
-void ReadBufferAIO::receive()
-{
-    if (!waitForAIOCompletion())
-    {
-        throw Exception("Trying to receive data from AIO, but nothing was queued. It's a bug", ErrorCodes::LOGICAL_ERROR);
-    }
-    finalize();
-}
-
-void ReadBufferAIO::skip()
-{
-    if (!waitForAIOCompletion())
-        return;
-
-    /// @todo I presume this assignment is redundant since waitForAIOCompletion() performs a similar one
-//    bytes_read = future_bytes_read.get();
-    if ((bytes_read < 0) || (static_cast<size_t>(bytes_read) < region_left_padding))
-        throw Exception("Asynchronous read error on file " + filename, ErrorCodes::AIO_READ_ERROR);
-}
-
-bool ReadBufferAIO::waitForAIOCompletion()
-{
-    if (is_eof || !is_pending_read)
-        return false;
-
-    CurrentMetrics::Increment metric_increment_read{CurrentMetrics::Read};
-
-    bytes_read = future_bytes_read.get();
-    is_pending_read = false;
-
-    ProfileEvents::increment(ProfileEvents::ReadBufferAIORead);
-    ProfileEvents::increment(ProfileEvents::ReadBufferAIOReadBytes, bytes_read);
-
-    return true;
-}
-
-void ReadBufferAIO::prepare()
-{
-    requested_byte_count = std::min(fill_buffer.internalBuffer().size() - DEFAULT_AIO_FILE_BLOCK_SIZE, max_bytes_read);
-
-    /// Region of the disk from which we want to read data.
-    const off_t region_begin = first_unread_pos_in_file;
-
-    if ((requested_byte_count > static_cast<size_t>(std::numeric_limits<off_t>::max())) ||
-        (first_unread_pos_in_file > (std::numeric_limits<off_t>::max() - static_cast<off_t>(requested_byte_count))))
-        throw Exception("An overflow occurred during file operation", ErrorCodes::LOGICAL_ERROR);
-
-    const off_t region_end = first_unread_pos_in_file + requested_byte_count;
-
-    /// The aligned region of the disk from which we will read the data.
-    region_left_padding = region_begin % DEFAULT_AIO_FILE_BLOCK_SIZE;
-    const size_t region_right_padding = (DEFAULT_AIO_FILE_BLOCK_SIZE - (region_end % DEFAULT_AIO_FILE_BLOCK_SIZE)) % DEFAULT_AIO_FILE_BLOCK_SIZE;
-
-    region_aligned_begin = region_begin - region_left_padding;
-
-    if (region_end > (std::numeric_limits<off_t>::max() - static_cast<off_t>(region_right_padding)))
-        throw Exception("An overflow occurred during file operation", ErrorCodes::LOGICAL_ERROR);
-
-    const off_t region_aligned_end = region_end + region_right_padding;
-    region_aligned_size = region_aligned_end - region_aligned_begin;
-
-    buffer_begin = fill_buffer.internalBuffer().begin();
-
-    /// Unpoison because msan doesn't instrument linux AIO
-    __msan_unpoison(buffer_begin, fill_buffer.internalBuffer().size());
-}
-
-void ReadBufferAIO::finalize()
-{
-    if ((bytes_read < 0) || (static_cast<size_t>(bytes_read) < region_left_padding))
-        throw Exception("Asynchronous read error on file " + filename, ErrorCodes::AIO_READ_ERROR);
-
-    /// Ignore redundant bytes on the left.
-    bytes_read -= region_left_padding;
-
-    /// Ignore redundant bytes on the right.
-    bytes_read = std::min(static_cast<off_t>(bytes_read), static_cast<off_t>(requested_byte_count));
-
-    if (bytes_read > 0)
-        fill_buffer.buffer().resize(region_left_padding + bytes_read);
-    if (static_cast<size_t>(bytes_read) < requested_byte_count)
-        is_eof = true;
-
-    if (first_unread_pos_in_file > (std::numeric_limits<off_t>::max() - bytes_read))
-        throw Exception("An overflow occurred during file operation", ErrorCodes::LOGICAL_ERROR);
-
-    first_unread_pos_in_file += bytes_read;
-    total_bytes_read += bytes_read;
-    nextimpl_working_buffer_offset = region_left_padding;
-
-    if (total_bytes_read == max_bytes_read)
-        is_eof = true;
-
-    /// Swap the main and duplicate buffers.
-    swap(fill_buffer);
-}
-
-}
-
-#endif
diff --git a/src/IO/ReadBufferAIO.h b/src/IO/ReadBufferAIO.h
deleted file mode 100644
index d476865747db..000000000000
--- a/src/IO/ReadBufferAIO.h
+++ /dev/null
@@ -1,111 +0,0 @@
-#pragma once
-
-#if defined(OS_LINUX) || defined(__FreeBSD__)
-
-#include <IO/ReadBufferFromFileBase.h>
-#include <IO/ReadBuffer.h>
-#include <IO/BufferWithOwnMemory.h>
-#include <IO/AIO.h>
-#include <Core/Defines.h>
-#include <Common/CurrentMetrics.h>
-#include <string>
-#include <limits>
-#include <future>
-#include <unistd.h>
-#include <fcntl.h>
-
-
-namespace CurrentMetrics
-{
-    extern const Metric OpenFileForRead;
-}
-
-namespace DB
-{
-
-/** Class for asynchronous data reading.
-  */
-class ReadBufferAIO final : public ReadBufferFromFileBase
-{
-public:
-    ReadBufferAIO(const std::string & filename_, size_t buffer_size_ = DBMS_DEFAULT_BUFFER_SIZE, int flags_ = -1,
-        char * existing_memory_ = nullptr);
-    ~ReadBufferAIO() override;
-
-    ReadBufferAIO(const ReadBufferAIO &) = delete;
-    ReadBufferAIO & operator=(const ReadBufferAIO &) = delete;
-
-    void setMaxBytes(size_t max_bytes_read_);
-    off_t getPosition() override { return first_unread_pos_in_file - (working_buffer.end() - pos); }
-    std::string getFileName() const override { return filename; }
-    int getFD() const { return fd; }
-
-    off_t seek(off_t off, int whence) override;
-
-private:
-    ///
-    bool nextImpl() override;
-    /// Synchronously read the data.
-    void synchronousRead();
-    /// Get data from an asynchronous request.
-    void receive();
-    /// Ignore data from an asynchronous request.
-    void skip();
-    /// Wait for the end of the current asynchronous task.
-    bool waitForAIOCompletion();
-    /// Prepare the request.
-    void prepare();
-    /// Prepare for reading a duplicate buffer containing data from
-    /// of the last request.
-    void finalize();
-
-private:
-    /// Buffer for asynchronous data read operations.
-    BufferWithOwnMemory<ReadBuffer> fill_buffer;
-
-    /// Description of the asynchronous read request.
-    iocb request{};
-    std::future<ssize_t> future_bytes_read;
-
-    const std::string filename;
-
-    /// The maximum number of bytes that can be read.
-    size_t max_bytes_read = std::numeric_limits<size_t>::max();
-    /// Number of bytes requested.
-    size_t requested_byte_count = 0;
-    /// The number of bytes read at the last request.
-    ssize_t bytes_read = 0;
-    /// The total number of bytes read.
-    size_t total_bytes_read = 0;
-
-    /// The position of the first unread byte in the file.
-    off_t first_unread_pos_in_file = 0;
-
-    /// The starting position of the aligned region of the disk from which the data is read.
-    off_t region_aligned_begin = 0;
-    /// Left offset to align the region of the disk.
-    size_t region_left_padding = 0;
-    /// The size of the aligned region of the disk.
-    size_t region_aligned_size = 0;
-
-    /// The file descriptor for read.
-    int fd = -1;
-
-    /// The buffer to which the received data is written.
-    Position buffer_begin = nullptr;
-
-    /// The asynchronous read operation is not yet completed.
-    bool is_pending_read = false;
-    /// The end of the file is reached.
-    bool is_eof = false;
-    /// At least one read request was sent.
-    bool is_started = false;
-    /// Did the asynchronous operation fail?
-    bool aio_failed = false;
-
-    CurrentMetrics::Increment metric_increment{CurrentMetrics::OpenFileForRead};
-};
-
-}
-
-#endif
diff --git a/src/IO/ReadBufferFromFileDescriptor.cpp b/src/IO/ReadBufferFromFileDescriptor.cpp
index 893c2bcb5d8c..c3b7f33f533c 100644
--- a/src/IO/ReadBufferFromFileDescriptor.cpp
+++ b/src/IO/ReadBufferFromFileDescriptor.cpp
@@ -128,8 +128,8 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)
     if (new_pos + (working_buffer.end() - pos) == file_offset_of_buffer_end)
         return new_pos;
 
-    // file_offset_of_buffer_end corresponds to working_buffer.end(); it's a past-the-end pos,
-    // so the second inequality is strict.
+    /// file_offset_of_buffer_end corresponds to working_buffer.end(); it's a past-the-end pos,
+    /// so the second inequality is strict.
     if (file_offset_of_buffer_end - working_buffer.size() <= static_cast<size_t>(new_pos)
         && new_pos < file_offset_of_buffer_end)
     {
@@ -142,19 +142,29 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)
     }
     else
     {
+        size_t seek_pos = required_alignment > 1
+            ? new_pos / required_alignment * required_alignment
+            : new_pos;
+
+        size_t offset_after_seek_pos = new_pos - seek_pos;
+
         ProfileEvents::increment(ProfileEvents::Seek);
         Stopwatch watch(profile_callback ? clock_type : CLOCK_MONOTONIC);
 
         pos = working_buffer.end();
-        off_t res = ::lseek(fd, new_pos, SEEK_SET);
+        off_t res = ::lseek(fd, seek_pos, SEEK_SET);
         if (-1 == res)
             throwFromErrnoWithPath("Cannot seek through file " + getFileName(), getFileName(),
                 ErrorCodes::CANNOT_SEEK_THROUGH_FILE);
-        file_offset_of_buffer_end = new_pos;
 
         watch.stop();
         ProfileEvents::increment(ProfileEvents::DiskReadElapsedMicroseconds, watch.elapsedMicroseconds());
 
+        file_offset_of_buffer_end = seek_pos;
+
+        if (offset_after_seek_pos > 0)
+            ignore(offset_after_seek_pos);
+
         return res;
     }
 }
diff --git a/src/IO/ReadBufferFromFileDescriptor.h b/src/IO/ReadBufferFromFileDescriptor.h
index 1883c6802bc7..5a79193445ea 100644
--- a/src/IO/ReadBufferFromFileDescriptor.h
+++ b/src/IO/ReadBufferFromFileDescriptor.h
@@ -14,8 +14,9 @@ namespace DB
 class ReadBufferFromFileDescriptor : public ReadBufferFromFileBase
 {
 protected:
+    const size_t required_alignment = 0;    /// For O_DIRECT both file offsets and memory addresses have to be aligned.
+    size_t file_offset_of_buffer_end = 0;       /// What offset in file corresponds to working_buffer.end().
     int fd;
-    size_t file_offset_of_buffer_end; /// What offset in file corresponds to working_buffer.end().
 
     bool nextImpl() override;
 
@@ -24,7 +25,7 @@ class ReadBufferFromFileDescriptor : public ReadBufferFromFileBase
 
 public:
     ReadBufferFromFileDescriptor(int fd_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE, char * existing_memory = nullptr, size_t alignment = 0)
-        : ReadBufferFromFileBase(buf_size, existing_memory, alignment), fd(fd_), file_offset_of_buffer_end(0) {}
+        : ReadBufferFromFileBase(buf_size, existing_memory, alignment), required_alignment(alignment), fd(fd_) {}
 
     int getFD() const
     {
diff --git a/src/IO/createReadBufferFromFileBase.cpp b/src/IO/createReadBufferFromFileBase.cpp
index 230f049b2cba..11a0937ee48f 100644
--- a/src/IO/createReadBufferFromFileBase.cpp
+++ b/src/IO/createReadBufferFromFileBase.cpp
@@ -1,8 +1,5 @@
 #include <IO/createReadBufferFromFileBase.h>
 #include <IO/ReadBufferFromFile.h>
-#if defined(OS_LINUX) || defined(__FreeBSD__)
-#include <IO/ReadBufferAIO.h>
-#endif
 #include <IO/MMapReadBufferFromFileWithCache.h>
 #include <Common/ProfileEvents.h>
 
@@ -10,8 +7,8 @@
 namespace ProfileEvents
 {
     extern const Event CreatedReadBufferOrdinary;
-    extern const Event CreatedReadBufferAIO;
-    extern const Event CreatedReadBufferAIOFailed;
+    extern const Event CreatedReadBufferDirectIO;
+    extern const Event CreatedReadBufferDirectIOFailed;
     extern const Event CreatedReadBufferMMap;
     extern const Event CreatedReadBufferMMapFailed;
 }
@@ -20,48 +17,82 @@ namespace DB
 {
 
 std::unique_ptr<ReadBufferFromFileBase> createReadBufferFromFileBase(
-    const std::string & filename_,
-    size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,
-    size_t buffer_size_, int flags_, char * existing_memory_, size_t alignment)
+    const std::string & filename,
+    size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,
+    size_t buffer_size, int flags, char * existing_memory, size_t alignment)
 {
-#if defined(OS_LINUX) || defined(__FreeBSD__)
-    if (aio_threshold && estimated_size >= aio_threshold)
+    if (!existing_memory && mmap_threshold && mmap_cache && estimated_size >= mmap_threshold)
     {
-        /// Attempt to open a file with O_DIRECT
         try
         {
-            auto res = std::make_unique<ReadBufferAIO>(filename_, buffer_size_, flags_, existing_memory_);
-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferAIO);
+            auto res = std::make_unique<MMapReadBufferFromFileWithCache>(*mmap_cache, filename, 0);
+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMap);
             return res;
         }
         catch (const ErrnoException &)
         {
-            /// Fallback to cached IO if O_DIRECT is not supported.
-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferAIOFailed);
+            /// Fallback if mmap is not supported (example: pipe).
+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMapFailed);
         }
     }
-#else
-    (void)aio_threshold;
-    (void)estimated_size;
-#endif
 
-    if (!existing_memory_ && mmap_threshold && mmap_cache && estimated_size >= mmap_threshold)
+#if defined(OS_LINUX) || defined(__FreeBSD__)
+    if (direct_io_threshold && estimated_size >= direct_io_threshold)
     {
+        /** O_DIRECT
+          * The O_DIRECT flag may impose alignment restrictions on the length and address of user-space buffers and the file offset of I/Os.
+          * In Linux alignment restrictions vary by filesystem and kernel version and might be absent entirely.
+          * However there is currently no filesystem-independent interface for an application to discover these restrictions
+          * for a given file or filesystem. Some filesystems provide their own interfaces for doing so, for example the
+          * XFS_IOC_DIOINFO operation in xfsctl(3).
+          *
+          * Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be
+          * multiples of the logical block size of the filesystem. Since Linux 2.6.0, alignment to the logical block size
+          * of the underlying storage (typically 512 bytes) suffices.
+          *
+          * - man 2 open
+          */
+        constexpr size_t min_alignment = DEFAULT_AIO_FILE_BLOCK_SIZE;
+
+        auto align_up = [=](size_t value) { return (value + min_alignment - 1) / min_alignment * min_alignment; };
+
+        if (alignment == 0)
+            alignment = min_alignment;
+        else if (alignment % min_alignment)
+            alignment = align_up(alignment);
+
+        if (buffer_size % min_alignment)
+        {
+            existing_memory = nullptr;  /// Cannot reuse existing memory is it has unaligned size.
+            buffer_size = align_up(buffer_size);
+        }
+
+        if (reinterpret_cast<uintptr_t>(existing_memory) % min_alignment)
+        {
+            existing_memory = nullptr;  /// Cannot reuse existing memory is it has unaligned offset.
+        }
+
+        /// Attempt to open a file with O_DIRECT
         try
         {
-            auto res = std::make_unique<MMapReadBufferFromFileWithCache>(*mmap_cache, filename_, 0);
-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMap);
+            auto res = std::make_unique<ReadBufferFromFile>(
+                filename, buffer_size, (flags == -1 ? O_RDONLY | O_CLOEXEC : flags) | O_DIRECT, existing_memory, alignment);
+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferDirectIO);
             return res;
         }
         catch (const ErrnoException &)
         {
-            /// Fallback if mmap is not supported (example: pipe).
-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMapFailed);
+            /// Fallback to cached IO if O_DIRECT is not supported.
+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferDirectIOFailed);
         }
     }
+#else
+    (void)direct_io_threshold;
+    (void)estimated_size;
+#endif
 
     ProfileEvents::increment(ProfileEvents::CreatedReadBufferOrdinary);
-    return std::make_unique<ReadBufferFromFile>(filename_, buffer_size_, flags_, existing_memory_, alignment);
+    return std::make_unique<ReadBufferFromFile>(filename, buffer_size, flags, existing_memory, alignment);
 }
 
 }
diff --git a/src/IO/createReadBufferFromFileBase.h b/src/IO/createReadBufferFromFileBase.h
index 46d5b39ea449..dc2912ea7528 100644
--- a/src/IO/createReadBufferFromFileBase.h
+++ b/src/IO/createReadBufferFromFileBase.h
@@ -13,20 +13,20 @@ class MMappedFileCache;
 
 /** Create an object to read data from a file.
   * estimated_size - the number of bytes to read
-  * aio_threshold - the minimum number of bytes for asynchronous reads
+  * direct_io_threshold - the minimum number of bytes for asynchronous reads
   *
-  * If aio_threshold = 0 or estimated_size < aio_threshold, read operations are executed synchronously.
+  * If direct_io_threshold = 0 or estimated_size < direct_io_threshold, read operations are executed synchronously.
   * Otherwise, the read operations are performed asynchronously.
   */
 std::unique_ptr<ReadBufferFromFileBase> createReadBufferFromFileBase(
-    const std::string & filename_,
+    const std::string & filename,
     size_t estimated_size,
-    size_t aio_threshold,
+    size_t direct_io_threshold,
     size_t mmap_threshold,
     MMappedFileCache * mmap_cache,
-    size_t buffer_size_ = DBMS_DEFAULT_BUFFER_SIZE,
+    size_t buffer_size = DBMS_DEFAULT_BUFFER_SIZE,
     int flags_ = -1,
-    char * existing_memory_ = nullptr,
+    char * existing_memory = nullptr,
     size_t alignment = 0);
 
 }
diff --git a/src/IO/examples/CMakeLists.txt b/src/IO/examples/CMakeLists.txt
index bcd0a8bba241..d5907bf67ad9 100644
--- a/src/IO/examples/CMakeLists.txt
+++ b/src/IO/examples/CMakeLists.txt
@@ -49,11 +49,6 @@ target_link_libraries (io_operators PRIVATE clickhouse_common_io)
 add_executable (write_int write_int.cpp)
 target_link_libraries (write_int PRIVATE clickhouse_common_io)
 
-if (OS_LINUX OR OS_FREEBSD)
-    add_executable(read_buffer_aio read_buffer_aio.cpp)
-    target_link_libraries (read_buffer_aio PRIVATE clickhouse_common_io)
-endif ()
-
 add_executable (zlib_buffers zlib_buffers.cpp)
 target_link_libraries (zlib_buffers PRIVATE clickhouse_common_io)
 
diff --git a/src/IO/examples/read_buffer_aio.cpp b/src/IO/examples/read_buffer_aio.cpp
deleted file mode 100644
index 01ac9808cbb6..000000000000
--- a/src/IO/examples/read_buffer_aio.cpp
+++ /dev/null
@@ -1,670 +0,0 @@
-#include <IO/ReadBufferAIO.h>
-#include <Core/Defines.h>
-#include <filesystem>
-#include <vector>
-#include <iostream>
-#include <fstream>
-#include <functional>
-#include <cstdlib>
-#include <unistd.h>
-
-
-namespace
-{
-
-void run();
-void prepare(std::string & filename, std::string & buf);
-void prepare2(std::string & filename, std::string & buf);
-void prepare3(std::string & filename, std::string & buf);
-void prepare4(std::string & filename, std::string & buf);
-std::string createTmpFile();
-[[noreturn]] void die(const std::string & msg);
-void runTest(unsigned int num, const std::function<bool()> & func);
-
-bool test1(const std::string & filename);
-bool test2(const std::string & filename, const std::string & buf);
-bool test3(const std::string & filename, const std::string & buf);
-bool test4(const std::string & filename, const std::string & buf);
-bool test5(const std::string & filename, const std::string & buf);
-bool test6(const std::string & filename, const std::string & buf);
-bool test7(const std::string & filename, const std::string & buf);
-bool test8(const std::string & filename, const std::string & buf);
-bool test9(const std::string & filename, const std::string & buf);
-bool test10(const std::string & filename, const std::string & buf);
-bool test11(const std::string & filename);
-bool test12(const std::string & filename, const std::string & buf);
-bool test13(const std::string & filename, const std::string & buf);
-bool test14(const std::string & filename, const std::string & buf);
-bool test15(const std::string & filename, const std::string & buf);
-bool test16(const std::string & filename, const std::string & buf);
-bool test17(const std::string & filename, const std::string & buf);
-bool test18(const std::string & filename, const std::string & buf);
-bool test19(const std::string & filename, const std::string & buf);
-bool test20(const std::string & filename, const std::string & buf);
-
-void run()
-{
-    namespace fs = std::filesystem;
-
-    std::string filename;
-    std::string buf;
-    prepare(filename, buf);
-
-    std::string filename2;
-    std::string buf2;
-    prepare(filename2, buf2);
-
-    std::string filename3;
-    std::string buf3;
-    prepare2(filename3, buf3);
-
-    std::string filename4;
-    std::string buf4;
-    prepare3(filename4, buf4);
-
-    std::string filename5;
-    std::string buf5;
-    prepare4(filename5, buf5);
-
-    const std::vector<std::function<bool()>> tests =
-    {
-        [&]{ return test1(filename); },
-        [&]{ return test2(filename, buf); },
-        [&]{ return test3(filename, buf); },
-        [&]{ return test4(filename, buf); },
-        [&]{ return test5(filename, buf); },
-        [&]{ return test6(filename, buf); },
-        [&]{ return test7(filename, buf); },
-        [&]{ return test8(filename, buf); },
-        [&]{ return test9(filename, buf); },
-        [&]{ return test10(filename, buf); },
-        [&]{ return test11(filename); },
-        [&]{ return test12(filename, buf); },
-        [&]{ return test13(filename2, buf2); },
-        [&]{ return test14(filename, buf); },
-        [&]{ return test15(filename3, buf3); },
-        [&]{ return test16(filename3, buf3); },
-        [&]{ return test17(filename4, buf4); },
-        [&]{ return test18(filename5, buf5); },
-        [&]{ return test19(filename, buf); },
-        [&]{ return test20(filename, buf); }
-    };
-
-    unsigned int num = 0;
-    for (const auto & test : tests)
-    {
-        ++num;
-        runTest(num, test);
-    }
-
-    fs::remove_all(fs::path(filename).parent_path().string());
-    fs::remove_all(fs::path(filename2).parent_path().string());
-    fs::remove_all(fs::path(filename3).parent_path().string());
-    fs::remove_all(fs::path(filename4).parent_path().string());
-    fs::remove_all(fs::path(filename5).parent_path().string());
-}
-
-void prepare(std::string & filename, std::string & buf)
-{
-    static const std::string symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
-
-    filename = createTmpFile();
-
-    size_t n = 10 * DEFAULT_AIO_FILE_BLOCK_SIZE;
-    buf.reserve(n);
-
-    for (size_t i = 0; i < n; ++i)
-        buf += symbols[i % symbols.length()];
-
-    std::ofstream out(filename.c_str());
-    if (!out.is_open())
-        die("Could not open file");
-
-    out << buf;
-}
-
-void prepare2(std::string & filename, std::string & buf)
-{
-    filename = createTmpFile();
-
-    buf = "122333444455555666666777777788888888999999999";
-
-    std::ofstream out(filename.c_str());
-    if (!out.is_open())
-        die("Could not open file");
-
-    out << buf;
-}
-
-void prepare3(std::string & filename, std::string & buf)
-{
-    filename = createTmpFile();
-
-    buf = "122333444455555666666777777788888888999999999";
-
-    std::ofstream out(filename.c_str());
-    if (!out.is_open())
-        die("Could not open file");
-
-    out.seekp(7, std::ios_base::beg);
-    out << buf;
-}
-
-void prepare4(std::string & filename, std::string & buf)
-{
-    static const std::string symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
-
-    filename = createTmpFile();
-
-    std::ofstream out(filename.c_str());
-    if (!out.is_open())
-        die("Could not open file");
-
-    for (size_t i = 0; i < 1340; ++i)
-        buf += symbols[i % symbols.length()];
-
-    out.seekp(2984, std::ios_base::beg);
-    out << buf;
-}
-
-std::string createTmpFile()
-{
-    char pattern[] = "/tmp/fileXXXXXX";
-    char * dir = ::mkdtemp(pattern);
-    if (dir == nullptr)
-        die("Could not create directory");
-
-    return std::string(dir) + "/foo";
-}
-
-void die(const std::string & msg)
-{
-    std::cout << msg << "
";
-    ::exit(EXIT_FAILURE);
-}
-
-void runTest(unsigned int num, const std::function<bool()> & func)
-{
-    bool ok;
-
-    try
-    {
-        ok = func();
-    }
-    catch (const DB::Exception & ex)
-    {
-        ok = false;
-        std::cout << "Caught exception " << ex.displayText() << "
";
-    }
-    catch (const std::exception & ex)
-    {
-        ok = false;
-        std::cout << "Caught exception " << ex.what() << "
";
-    }
-
-    if (ok)
-        std::cout << "Test " << num << " passed
";
-    else
-        std::cout << "Test " << num << " failed
";
-}
-
-bool test1(const std::string & filename)
-{
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    if (in.getFileName() != filename)
-        return false;
-    if (in.getFD() == -1)
-        return false;
-    return true;
-}
-
-bool test2(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(buf.length());
-
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    size_t count = in.read(newbuf.data(), newbuf.length());
-    if (count != newbuf.length())
-        return false;
-
-    return (newbuf == buf);
-}
-
-bool test3(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(buf.length());
-
-    size_t requested = 9 * DEFAULT_AIO_FILE_BLOCK_SIZE;
-
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    in.setMaxBytes(requested);
-    size_t count = in.read(newbuf.data(), newbuf.length());
-
-    newbuf.resize(count);
-    return (newbuf == buf.substr(0, requested));
-}
-
-bool test4(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(buf.length());
-
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    in.setMaxBytes(0);
-    size_t n_read = in.read(newbuf.data(), newbuf.length());
-
-    return n_read == 0;
-}
-
-bool test5(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(1 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));
-
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-    in.setMaxBytes(1 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));
-
-    size_t count = in.read(newbuf.data(), newbuf.length());
-    if (count != newbuf.length())
-        return false;
-
-    if (newbuf != buf.substr(0, newbuf.length()))
-        return false;
-
-    return true;
-}
-
-bool test6(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(buf.length());
-
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    if (in.getPosition() != 0)
-        return false;
-
-    size_t count = in.read(newbuf.data(), newbuf.length());
-    if (count != newbuf.length())
-        return false;
-
-    if (static_cast<size_t>(in.getPosition()) != buf.length())
-        return false;
-
-    return true;
-}
-
-bool test7(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(buf.length() - DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    (void) in.seek(DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_SET);
-    size_t count = in.read(newbuf.data(), newbuf.length());
-    if (count != (9 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-        return false;
-
-    return (newbuf == buf.substr(DEFAULT_AIO_FILE_BLOCK_SIZE));
-}
-
-bool test8(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(DEFAULT_AIO_FILE_BLOCK_SIZE - 1);
-
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    (void) in.seek(DEFAULT_AIO_FILE_BLOCK_SIZE + 1, SEEK_CUR);
-    size_t count = in.read(newbuf.data(), newbuf.length());
-
-    if (count != newbuf.length())
-        return false;
-
-    if (newbuf != buf.substr(DEFAULT_AIO_FILE_BLOCK_SIZE + 1, newbuf.length()))
-        return false;
-
-    return true;
-}
-
-bool test9(const std::string & filename, const std::string & buf)
-{
-    bool ok = false;
-
-    try
-    {
-        std::string newbuf;
-        newbuf.resize(buf.length());
-
-        DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-        size_t count = in.read(newbuf.data(), newbuf.length());
-        if (count != newbuf.length())
-            return false;
-        in.setMaxBytes(9 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-    }
-    catch (const DB::Exception &)
-    {
-        ok = true;
-    }
-
-    return ok;
-}
-
-bool test10(const std::string & filename, const std::string & buf)
-{
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    {
-        std::string newbuf;
-        newbuf.resize(4 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        size_t count1 = in.read(newbuf.data(), newbuf.length());
-        if (count1 != newbuf.length())
-            return false;
-
-        if (newbuf != buf.substr(0, 4 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-            return false;
-    }
-
-    (void) in.seek(2 * DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_CUR);
-
-    {
-        std::string newbuf;
-        newbuf.resize(4 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        size_t count2 = in.read(newbuf.data(), newbuf.length());
-        if (count2 != newbuf.length())
-            return false;
-
-        if (newbuf != buf.substr(6 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-            return false;
-    }
-
-    return true;
-}
-
-bool test11(const std::string & filename)
-{
-    bool ok = false;
-
-    try
-    {
-        DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-        (void) in.seek(-DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_SET);
-    }
-    catch (const DB::Exception &)
-    {
-        ok = true;
-    }
-
-    return ok;
-}
-
-bool test12(const std::string & filename, const std::string &)
-{
-    bool ok = false;
-
-    try
-    {
-        std::string newbuf;
-        newbuf.resize(4 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-        size_t count = in.read(newbuf.data(), newbuf.length());
-        if (count != newbuf.length())
-            return false;
-
-        (void) in.seek(-(10 * DEFAULT_AIO_FILE_BLOCK_SIZE), SEEK_CUR);
-    }
-    catch (const DB::Exception &)
-    {
-        ok = true;
-    }
-
-    return ok;
-}
-
-bool test13(const std::string & filename, const std::string &)
-{
-    std::string newbuf;
-    newbuf.resize(2 * DEFAULT_AIO_FILE_BLOCK_SIZE - 3);
-
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-    size_t count1 = in.read(newbuf.data(), newbuf.length());
-    return count1 == newbuf.length();
-}
-
-bool test14(const std::string & filename, const std::string & buf)
-{
-    std::string newbuf;
-    newbuf.resize(1 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));
-
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-    (void) in.seek(2, SEEK_SET);
-    in.setMaxBytes(3 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));
-
-    size_t count = in.read(newbuf.data(), newbuf.length());
-    if (count != newbuf.length())
-        return false;
-
-    if (newbuf != buf.substr(2, newbuf.length()))
-        return false;
-
-    return true;
-}
-
-bool test15(const std::string & filename, const std::string &)
-{
-    std::string newbuf;
-    newbuf.resize(1000);
-
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    size_t count = in.read(newbuf.data(), 1);
-    if (count != 1)
-        return false;
-    if (newbuf[0] != '1')
-        return false;
-    return true;
-}
-
-bool test16(const std::string & filename, const std::string &)
-{
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-    size_t count;
-
-    {
-        std::string newbuf;
-        newbuf.resize(1);
-        count = in.read(newbuf.data(), 1);
-        if (count != 1)
-            return false;
-        if (newbuf[0] != '1')
-            return false;
-    }
-
-    in.seek(2, SEEK_CUR);
-
-    {
-        std::string newbuf;
-        newbuf.resize(3);
-        count = in.read(newbuf.data(), 3);
-        if (count != 3)
-            return false;
-        if (newbuf != "333")
-            return false;
-    }
-
-    in.seek(4, SEEK_CUR);
-
-    {
-        std::string newbuf;
-        newbuf.resize(5);
-        count = in.read(newbuf.data(), 5);
-        if (count != 5)
-            return false;
-        if (newbuf != "55555")
-            return false;
-    }
-
-    in.seek(6, SEEK_CUR);
-
-    {
-        std::string newbuf;
-        newbuf.resize(7);
-        count = in.read(newbuf.data(), 7);
-        if (count != 7)
-            return false;
-        if (newbuf != "7777777")
-            return false;
-    }
-
-    in.seek(8, SEEK_CUR);
-
-    {
-        std::string newbuf;
-        newbuf.resize(9);
-        count = in.read(newbuf.data(), 9);
-        if (count != 9)
-            return false;
-        if (newbuf != "999999999")
-            return false;
-    }
-
-    return true;
-}
-
-bool test17(const std::string & filename, const std::string & buf)
-{
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-    size_t count;
-
-    {
-        std::string newbuf;
-        newbuf.resize(10);
-        count = in.read(newbuf.data(), 10);
-
-        if (count != 10)
-            return false;
-        if (newbuf.substr(0, 7) != std::string(7, '\0'))
-            return false;
-        if (newbuf.substr(7) != "122")
-            return false;
-    }
-
-    in.seek(7 + buf.length() - 2, SEEK_SET);
-
-    {
-        std::string newbuf;
-        newbuf.resize(160);
-        count = in.read(newbuf.data(), 160);
-
-        if (count != 2)
-            return false;
-        if (newbuf.substr(0, 2) != "99")
-            return false;
-    }
-
-    in.seek(7 + buf.length() + DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_SET);
-
-    {
-        std::string newbuf;
-        newbuf.resize(50);
-        count = in.read(newbuf.data(), 50);
-        if (count != 0)
-            return false;
-    }
-
-    return true;
-}
-
-bool test18(const std::string & filename, const std::string & buf)
-{
-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    std::string newbuf;
-    newbuf.resize(1340);
-
-    in.seek(2984, SEEK_SET);
-    size_t count = in.read(newbuf.data(), 1340);
-
-    if (count != 1340)
-        return false;
-    if (newbuf != buf)
-        return false;
-
-    return true;
-}
-
-bool test19(const std::string & filename, const std::string & buf)
-{
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    {
-        std::string newbuf;
-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        size_t count1 = in.read(newbuf.data(), newbuf.length());
-        if (count1 != newbuf.length())
-            return false;
-
-        if (newbuf != buf.substr(0, 5 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-            return false;
-    }
-
-    {
-        std::string newbuf;
-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        size_t count2 = in.read(newbuf.data(), newbuf.length());
-        if (count2 != newbuf.length())
-            return false;
-
-        if (newbuf != buf.substr(5 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-            return false;
-    }
-
-    return true;
-}
-
-bool test20(const std::string & filename, const std::string & buf)
-{
-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-    {
-        std::string newbuf;
-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        size_t count1 = in.read(newbuf.data(), newbuf.length());
-        if (count1 != newbuf.length())
-            return false;
-
-        if (newbuf != buf.substr(0, 5 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-            return false;
-    }
-
-    (void) in.getPosition();
-
-    {
-        std::string newbuf;
-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);
-
-        size_t count2 = in.read(newbuf.data(), newbuf.length());
-        if (count2 != newbuf.length())
-            return false;
-
-        if (newbuf != buf.substr(5 * DEFAULT_AIO_FILE_BLOCK_SIZE))
-            return false;
-    }
-
-    return true;
-}
-
-}
-
-int main()
-{
-    run();
-    return 0;
-}
diff --git a/src/IO/ya.make b/src/IO/ya.make
index d8bdfa95295e..bca108ca4269 100644
--- a/src/IO/ya.make
+++ b/src/IO/ya.make
@@ -44,7 +44,6 @@ SRCS(
     NullWriteBuffer.cpp
     PeekableReadBuffer.cpp
     Progress.cpp
-    ReadBufferAIO.cpp
     ReadBufferFromFile.cpp
     ReadBufferFromFileBase.cpp
     ReadBufferFromFileDecorator.cpp
diff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp
index f9ed30ed4ed1..a777c244426d 100644
--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp
@@ -828,7 +828,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor
     UInt64 watch_prev_elapsed = 0;
 
     /// We count total amount of bytes in parts
-    /// and use direct_io + aio if there is more than min_merge_bytes_to_use_direct_io
+    /// and use direct_io if there is more than min_merge_bytes_to_use_direct_io
     bool read_with_direct_io = false;
     if (data_settings->min_merge_bytes_to_use_direct_io != 0)
     {
diff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp
index e82b1966461a..2a3c7ed00a1d 100644
--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp
+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp
@@ -54,7 +54,7 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(
 
     MergeTreeReaderSettings reader_settings =
     {
-        /// bytes to use AIO (this is hack)
+        /// bytes to use direct IO (this is hack)
         .min_bytes_to_use_direct_io = read_with_direct_io ? 1UL : std::numeric_limits<size_t>::max(),
         .max_read_buffer_size = DBMS_DEFAULT_BUFFER_SIZE,
         .save_marks_in_cache = false
diff --git a/src/Storages/System/StorageSystemStackTrace.cpp b/src/Storages/System/StorageSystemStackTrace.cpp
index 8b119492340d..7a8ee75803f4 100644
--- a/src/Storages/System/StorageSystemStackTrace.cpp
+++ b/src/Storages/System/StorageSystemStackTrace.cpp
@@ -223,7 +223,7 @@ void StorageSystemStackTrace::fillData(MutableColumns & res_columns, ContextPtr,
         {
             constexpr size_t comm_buf_size = 32; /// More than enough for thread name
             ReadBufferFromFile comm(thread_name_path.string(), comm_buf_size);
-            readStringUntilEOF(thread_name, comm);
+            readEscapedStringUntilEOL(thread_name, comm);
             comm.close();
         }
 
