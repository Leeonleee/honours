diff --git a/dbms/src/Interpreters/Cluster.cpp b/dbms/src/Interpreters/Cluster.cpp
index 12ba58507507..2c75bd821fe8 100644
--- a/dbms/src/Interpreters/Cluster.cpp
+++ b/dbms/src/Interpreters/Cluster.cpp
@@ -83,7 +83,8 @@ Cluster::Address::Address(const Poco::Util::AbstractConfiguration & config, cons
     default_database = config.getString(config_prefix + ".default_database", "");
     secure = config.getBool(config_prefix + ".secure", false) ? Protocol::Secure::Enable : Protocol::Secure::Disable;
     compression = config.getBool(config_prefix + ".compression", true) ? Protocol::Compression::Enable : Protocol::Compression::Disable;
-    is_local = isLocal(config.getInt("tcp_port", 0));
+    const char * port_type = secure == Protocol::Secure::Enable ? "tcp_port_secure" : "tcp_port";
+    is_local = isLocal(config.getInt(port_type, 0));
 }
 
 
diff --git a/dbms/src/Interpreters/DDLWorker.cpp b/dbms/src/Interpreters/DDLWorker.cpp
index afa4fca79f85..861a6b5ff03c 100644
--- a/dbms/src/Interpreters/DDLWorker.cpp
+++ b/dbms/src/Interpreters/DDLWorker.cpp
@@ -645,7 +645,8 @@ void DDLWorker::processTask(DDLTask & task, const ZooKeeperPtr & zookeeper)
         }
         catch (...)
         {
-            task.execution_status = ExecutionStatus::fromCurrentException("An error occured before execution");
+            tryLogCurrentException(log, "An error occurred before execution of DDL task: ");
+            task.execution_status = ExecutionStatus::fromCurrentException("An error occurred before execution");
         }
 
         /// We need to distinguish ZK errors occured before and after query executing
diff --git a/dbms/src/Storages/Distributed/DirectoryMonitor.cpp b/dbms/src/Storages/Distributed/DirectoryMonitor.cpp
index 2befe19308a3..111d1ff7aab3 100644
--- a/dbms/src/Storages/Distributed/DirectoryMonitor.cpp
+++ b/dbms/src/Storages/Distributed/DirectoryMonitor.cpp
@@ -81,7 +81,10 @@ namespace
 
 StorageDistributedDirectoryMonitor::StorageDistributedDirectoryMonitor(
     StorageDistributed & storage_, const std::string & name_, const ConnectionPoolPtr & pool_, ActionBlocker & monitor_blocker_)
-    : storage(storage_), pool{pool_}, path{storage.path + name_ + '/'}
+    : storage(storage_)
+    , pool{pool_}
+    , name{name_}
+    , path{storage.path + name + '/'}
     , current_batch_file_path{path + "current_batch.txt"}
     , default_sleep_time{storage.global_context.getSettingsRef().distributed_directory_monitor_sleep_time_ms.totalMilliseconds()}
     , sleep_time{default_sleep_time}
@@ -642,4 +645,11 @@ std::string StorageDistributedDirectoryMonitor::getLoggerName() const
     return storage.table_name + '.' + storage.getName() + ".DirectoryMonitor";
 }
 
+void StorageDistributedDirectoryMonitor::updatePath()
+{
+    std::lock_guard lock{mutex};
+    path = storage.path + name + '/';
+    current_batch_file_path = path + "current_batch.txt";
+}
+
 }
diff --git a/dbms/src/Storages/Distributed/DirectoryMonitor.h b/dbms/src/Storages/Distributed/DirectoryMonitor.h
index be613aec6e08..7e8f6a298f74 100644
--- a/dbms/src/Storages/Distributed/DirectoryMonitor.h
+++ b/dbms/src/Storages/Distributed/DirectoryMonitor.h
@@ -26,6 +26,8 @@ class StorageDistributedDirectoryMonitor
 
     static ConnectionPoolPtr createPool(const std::string & name, const StorageDistributed & storage);
 
+    void updatePath();
+
     void flushAllData();
 
     void shutdownAndDropAllData();
@@ -43,6 +45,7 @@ class StorageDistributedDirectoryMonitor
 
     StorageDistributed & storage;
     ConnectionPoolPtr pool;
+    std::string name;
     std::string path;
 
     bool should_batch_inserts = false;
diff --git a/dbms/src/Storages/StorageDistributed.cpp b/dbms/src/Storages/StorageDistributed.cpp
index 152712a72f44..f93f014e0795 100644
--- a/dbms/src/Storages/StorageDistributed.cpp
+++ b/dbms/src/Storages/StorageDistributed.cpp
@@ -596,6 +596,21 @@ void StorageDistributed::flushClusterNodesAllData()
         it->second.flushAllData();
 }
 
+void StorageDistributed::rename(const String & new_path_to_db, const String & new_database_name, const String & new_table_name,
+                                TableStructureWriteLockHolder &)
+{
+    table_name = new_table_name;
+    database_name = new_database_name;
+    if (!path.empty())
+    {
+        Poco::File(path).renameTo(new_path_to_db + escapeForFileName(new_table_name));
+        path = new_path_to_db + escapeForFileName(new_table_name) + '/';
+        std::lock_guard lock(cluster_nodes_mutex);
+        for (auto & node : cluster_nodes_data)
+            node.second.directory_monitor->updatePath();
+    }
+}
+
 
 void registerStorageDistributed(StorageFactory & factory)
 {
diff --git a/dbms/src/Storages/StorageDistributed.h b/dbms/src/Storages/StorageDistributed.h
index e2409fe136ec..7d4bda94ef3e 100644
--- a/dbms/src/Storages/StorageDistributed.h
+++ b/dbms/src/Storages/StorageDistributed.h
@@ -82,11 +82,7 @@ class StorageDistributed : public ext::shared_ptr_helper<StorageDistributed>, pu
     /// Removes temporary data in local filesystem.
     void truncate(const ASTPtr &, const Context &, TableStructureWriteLockHolder &) override;
 
-    void rename(const String & /*new_path_to_db*/, const String & new_database_name, const String & new_table_name, TableStructureWriteLockHolder &) override
-    {
-        table_name = new_table_name;
-        database_name = new_database_name;
-    }
+    void rename(const String & new_path_to_db, const String & new_database_name, const String & new_table_name, TableStructureWriteLockHolder &) override;
 
     /// in the sub-tables, you need to manually add and delete columns
     /// the structure of the sub-table is not checked
