{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62432,
  "instance_id": "ClickHouse__ClickHouse-62432",
  "issue_numbers": [
    "62426"
  ],
  "base_commit": "26c9c156c4c74f527e2760a4cf25e21e1d0aed63",
  "patch": "diff --git a/src/Processors/QueryPlan/PartsSplitter.cpp b/src/Processors/QueryPlan/PartsSplitter.cpp\nindex 6d70aa8a60dc..ed4b1906635e 100644\n--- a/src/Processors/QueryPlan/PartsSplitter.cpp\n+++ b/src/Processors/QueryPlan/PartsSplitter.cpp\n@@ -624,14 +624,11 @@ SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts,\n     }\n \n     /// Process parts ranges with undefined value at end mark\n-    bool is_intersecting = part_index_start_to_range.size() > 1;\n+    /// The last parts ranges could be non-intersect only if: (1) there is only one part range left, (2) it belongs to a non-L0 part,\n+    /// and (3) the begin value of this range is larger than the largest end value of all previous ranges. This is too complicated\n+    /// to check, so we just add the last part ranges to the intersecting ranges.\n     for (const auto & [part_range_index, mark_range] : part_index_start_to_range)\n-    {\n-        if (is_intersecting)\n-            add_intersecting_range(part_range_index.part_index, mark_range);\n-        else\n-            add_non_intersecting_range(part_range_index.part_index, mark_range);\n-    }\n+        add_intersecting_range(part_range_index.part_index, mark_range);\n \n     auto && non_intersecting_ranges_in_data_parts = std::move(non_intersecting_ranges_in_data_parts_builder.getCurrentRangesInDataParts());\n     auto && intersecting_ranges_in_data_parts = std::move(intersecting_ranges_in_data_parts_builder.getCurrentRangesInDataParts());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03033_final_undefined_last_mark.reference b/tests/queries/0_stateless/03033_final_undefined_last_mark.reference\nnew file mode 100644\nindex 000000000000..a30b755709b4\n--- /dev/null\n+++ b/tests/queries/0_stateless/03033_final_undefined_last_mark.reference\n@@ -0,0 +1,2 @@\n+Disabled\t11338881281426660955\t14765404159170880511\n+Enabled\t11338881281426660955\t14765404159170880511\ndiff --git a/tests/queries/0_stateless/03033_final_undefined_last_mark.sql b/tests/queries/0_stateless/03033_final_undefined_last_mark.sql\nnew file mode 100644\nindex 000000000000..25a30a365a5d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03033_final_undefined_last_mark.sql\n@@ -0,0 +1,23 @@\n+-- Tags: no-random-settings, no-random-merge-tree-settings\n+\n+DROP TABLE IF EXISTS account_test;\n+\n+CREATE TABLE account_test\n+(\n+    `id` UInt64,\n+    `row_ver` UInt64,\n+)\n+ENGINE = ReplacingMergeTree(row_ver)\n+ORDER BY id\n+SETTINGS index_granularity = 16, index_granularity_bytes = 0,\n+         min_rows_for_wide_part = 0, min_bytes_for_wide_part = 0,\n+         min_rows_for_compact_part = 0, min_bytes_for_compact_part = 0;\n+\n+SYSTEM STOP MERGES account_test;\n+\n+INSERT INTO account_test VALUES (11338881281426660955,717769962224129342),(12484100559155738267,7950971667203174918),(7603729260199571867,3255798127676911942),(7023543111808724827,911615979861855126),(10293135086416484571,3264379259750736572),(15561193439904316763,8419819469587131454),(17632407413882870235,7252071832370181502),(17009726455991851227,7525297506591593939),(12392078953873778779,8473049173389293961),(15283366022689446555,11692491360262171467),(9087459014730986523,2783662960221838603),(293823584550906267,4847630088179732782),(15693186194430465755,8163804880526285623),(7353080168325584795,17315892478487497859),(5980311238303466523,6943353798059390089),(14242621660019578011,8684624667957352769),(8241843507567433563,15731952080102886438);\n+INSERT INTO account_test VALUES (11338881281426660955, 14765404159170880511);\n+\n+SELECT 'Disabled', * FROM account_test FINAL WHERE id = 11338881281426660955 SETTINGS split_parts_ranges_into_intersecting_and_non_intersecting_final = 0;\n+SELECT 'Enabled', * FROM account_test FINAL WHERE id = 11338881281426660955 SETTINGS split_parts_ranges_into_intersecting_and_non_intersecting_final = 1;\n+\n",
  "problem_statement": "final stopped working after 23.12 for ReplacingMergeTree  tables with a lot of partitions and records\nGetting duplicate records for ReplacingMergeTree for queries with final modifier. \r\nSetting compatibility = '23.12' restores proper behavior.\r\n\r\nTest case for 24.3 : https://fiddle.clickhouse.com/399466fd-51fa-45a1-a183-c13b5a0e41d5\r\n\r\nSeems like it needs a lot of partitions and records. \r\n\n",
  "hints_text": "hmm, seems like `index_granularity_bytes = 0;` causes this. ",
  "created_at": "2024-04-09T09:57:19Z",
  "modified_files": [
    "src/Processors/QueryPlan/PartsSplitter.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03033_final_undefined_last_mark.reference",
    "b/tests/queries/0_stateless/03033_final_undefined_last_mark.sql"
  ]
}