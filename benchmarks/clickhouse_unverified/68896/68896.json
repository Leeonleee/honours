{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68896,
  "instance_id": "ClickHouse__ClickHouse-68896",
  "issue_numbers": [
    "66714"
  ],
  "base_commit": "d0c36c613d1bc2453cf28081ee212b90be65f8ee",
  "patch": "diff --git a/src/Core/ExternalTable.cpp b/src/Core/ExternalTable.cpp\nindex 4ff0d7092d89..7fe23f844b6e 100644\n--- a/src/Core/ExternalTable.cpp\n+++ b/src/Core/ExternalTable.cpp\n@@ -17,11 +17,12 @@\n \n #include <Core/ExternalTable.h>\n #include <Core/Settings.h>\n-#include <Poco/Net/MessageHeader.h>\n #include <Parsers/ASTNameTypePair.h>\n+#include <Parsers/IdentifierQuotingStyle.h>\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/parseQuery.h>\n #include <base/scope_guard.h>\n+#include <Poco/Net/MessageHeader.h>\n \n \n namespace DB\n@@ -85,7 +86,15 @@ void BaseExternalTable::parseStructureFromStructureField(const std::string & arg\n         /// We use `formatWithPossiblyHidingSensitiveData` instead of `getColumnNameWithoutAlias` because `column->type` is an ASTFunction.\n         /// `getColumnNameWithoutAlias` will return name of the function with `(arguments)` even if arguments is empty.\n         if (column)\n-            structure.emplace_back(column->name, column->type->formatWithPossiblyHidingSensitiveData(0, true, true, false));\n+            structure.emplace_back(\n+                column->name,\n+                column->type->formatWithPossiblyHidingSensitiveData(\n+                    /*max_length=*/0,\n+                    /*one_line=*/true,\n+                    /*show_secrets=*/true,\n+                    /*print_pretty_type_names=*/false,\n+                    /*always_quote_identifiers=*/false,\n+                    /*identifier_quoting_style=*/IdentifierQuotingStyle::Backticks));\n         else\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Error while parsing table structure: expected column definition, got {}\", child->formatForErrorMessage());\n     }\n@@ -102,7 +111,15 @@ void BaseExternalTable::parseStructureFromTypesField(const std::string & argumen\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Error while parsing table structure: {}\", error);\n \n     for (size_t i = 0; i < type_list_raw->children.size(); ++i)\n-        structure.emplace_back(\"_\" + toString(i + 1), type_list_raw->children[i]->formatWithPossiblyHidingSensitiveData(0, true, true, false));\n+        structure.emplace_back(\n+            \"_\" + toString(i + 1),\n+            type_list_raw->children[i]->formatWithPossiblyHidingSensitiveData(\n+                /*max_length=*/0,\n+                /*one_line=*/true,\n+                /*show_secrets=*/true,\n+                /*print_pretty_type_names=*/false,\n+                /*always_quote_identifiers=*/false,\n+                /*identifier_quoting_style=*/IdentifierQuotingStyle::Backticks));\n }\n \n void BaseExternalTable::initSampleBlock()\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 23dc2a8fdc53..0e58562c745f 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -1296,6 +1296,9 @@ class IColumn;\n     M(Bool, precise_float_parsing, false, \"Prefer more precise (but slower) float parsing algorithm\", 0) \\\n     M(DateTimeOverflowBehavior, date_time_overflow_behavior, \"ignore\", \"Overflow mode for Date, Date32, DateTime, DateTime64 types. Possible values: 'ignore', 'throw', 'saturate'.\", 0) \\\n     M(Bool, validate_experimental_and_suspicious_types_inside_nested_types, true, \"Validate usage of experimental and suspicious types inside nested types like Array/Map/Tuple\", 0) \\\n+    \\\n+    M(Bool, output_format_always_quote_identifiers, false, \"Always quote identifiers\", 0) \\\n+    M(IdentifierQuotingStyle, output_format_identifier_quoting_style, IdentifierQuotingStyle::Backticks, \"Set the quoting style for identifiers\", 0) \\\n \n \n // End of FORMAT_FACTORY_SETTINGS\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 5e831c6301c3..258065dcfd45 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -75,6 +75,8 @@ static std::initializer_list<std::pair<ClickHouseVersion, SettingsChangesHistory\n             {\"join_output_by_rowlist_perkey_rows_threshold\", 0, 5, \"The lower limit of per-key average rows in the right table to determine whether to output by row list in hash join.\"},\n             {\"create_if_not_exists\", false, false, \"New setting.\"},\n             {\"allow_materialized_view_with_bad_select\", true, true, \"Support (but not enable yet) stricter validation in CREATE MATERIALIZED VIEW\"},\n+            {\"output_format_always_quote_identifiers\", false, false, \"New setting.\"},\n+            {\"output_format_identifier_quoting_style\", \"Backticks\", \"Backticks\", \"New setting.\"}\n         }\n     },\n     {\"24.8\",\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex 30e60f246f4e..0c43b5256d6b 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -244,4 +244,10 @@ IMPLEMENT_SETTING_ENUM(\n     GroupArrayActionWhenLimitReached,\n     ErrorCodes::BAD_ARGUMENTS,\n     {{\"throw\", GroupArrayActionWhenLimitReached::THROW}, {\"discard\", GroupArrayActionWhenLimitReached::DISCARD}})\n+\n+IMPLEMENT_SETTING_ENUM(IdentifierQuotingStyle, ErrorCodes::BAD_ARGUMENTS,\n+    {{\"None\", IdentifierQuotingStyle::None},\n+     {\"Backticks\", IdentifierQuotingStyle::Backticks},\n+     {\"DoubleQuotes\", IdentifierQuotingStyle::DoubleQuotes},\n+     {\"BackticksMySQL\", IdentifierQuotingStyle::BackticksMySQL}})\n }\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex 5c2d8825e761..d358a2d44a0c 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -10,6 +10,7 @@\n #include <Formats/FormatSettings.h>\n #include <IO/ReadSettings.h>\n #include <Parsers/ASTSQLSecurity.h>\n+#include <Parsers/IdentifierQuotingStyle.h>\n #include <QueryPipeline/SizeLimits.h>\n #include <Common/ShellCommandSettings.h>\n \n@@ -351,6 +352,8 @@ DECLARE_SETTING_ENUM_WITH_RENAME(DateTimeOverflowBehavior, FormatSettings::DateT\n \n DECLARE_SETTING_ENUM(SQLSecurityType)\n \n+DECLARE_SETTING_ENUM(IdentifierQuotingStyle)\n+\n enum class GroupArrayActionWhenLimitReached : uint8_t\n {\n     THROW,\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex decc16a3704c..e04e27440153 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -786,7 +786,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             /// Verify that AST formatting is consistent:\n             /// If you format AST, parse it back, and format it again, you get the same string.\n \n-            String formatted1 = ast->formatWithPossiblyHidingSensitiveData(0, true, true, false);\n+            String formatted1 = ast->formatWithPossiblyHidingSensitiveData(0, true, true, false, false, IdentifierQuotingStyle::Backticks);\n \n             /// The query can become more verbose after formatting, so:\n             size_t new_max_query_size = max_query_size > 0 ? (1000 + 2 * max_query_size) : 0;\n@@ -811,7 +811,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n \n             chassert(ast2);\n \n-            String formatted2 = ast2->formatWithPossiblyHidingSensitiveData(0, true, true, false);\n+            String formatted2 = ast2->formatWithPossiblyHidingSensitiveData(0, true, true, false, false, IdentifierQuotingStyle::Backticks);\n \n             if (formatted1 != formatted2)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\ndiff --git a/src/Interpreters/formatWithPossiblyHidingSecrets.h b/src/Interpreters/formatWithPossiblyHidingSecrets.h\nindex 14e84f1d1a42..61f689fb821c 100644\n--- a/src/Interpreters/formatWithPossiblyHidingSecrets.h\n+++ b/src/Interpreters/formatWithPossiblyHidingSecrets.h\n@@ -26,7 +26,12 @@ inline String format(const SecretHidingFormatSettings & settings)\n         && settings.ctx->getAccess()->isGranted(AccessType::displaySecretsInShowAndSelect);\n \n     return settings.query.formatWithPossiblyHidingSensitiveData(\n-        settings.max_length, settings.one_line, show_secrets, settings.ctx->getSettingsRef().print_pretty_type_names);\n+        settings.max_length,\n+        settings.one_line,\n+        show_secrets,\n+        settings.ctx->getSettingsRef().print_pretty_type_names,\n+        settings.ctx->getSettingsRef().output_format_always_quote_identifiers,\n+        settings.ctx->getSettingsRef().output_format_identifier_quoting_style);\n }\n \n }\ndiff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp\nindex 23d653012f86..d7728462df3e 100644\n--- a/src/Parsers/ASTColumnDeclaration.cpp\n+++ b/src/Parsers/ASTColumnDeclaration.cpp\n@@ -66,8 +66,8 @@ void ASTColumnDeclaration::formatImpl(const FormatSettings & format_settings, Fo\n {\n     frame.need_parens = false;\n \n-    /// We have to always backquote column names to avoid ambiguity with INDEX and other declarations in CREATE query.\n-    format_settings.ostr << backQuote(name);\n+    /// We have to always quote column names to avoid ambiguity with INDEX and other declarations in CREATE query.\n+    format_settings.quoteIdentifier(name);\n \n     if (type)\n     {\ndiff --git a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\nindex daf708c9478c..a600987dc45e 100644\n--- a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\n+++ b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\n@@ -35,7 +35,7 @@ void ASTDictionaryAttributeDeclaration::formatImpl(const FormatSettings & settin\n {\n     frame.need_parens = false;\n \n-    settings.ostr << backQuote(name);\n+    settings.quoteIdentifier(name);\n \n     if (type)\n     {\ndiff --git a/src/Parsers/ASTIndexDeclaration.cpp b/src/Parsers/ASTIndexDeclaration.cpp\nindex 0c36644356f3..1e39eacaac7d 100644\n--- a/src/Parsers/ASTIndexDeclaration.cpp\n+++ b/src/Parsers/ASTIndexDeclaration.cpp\n@@ -79,7 +79,7 @@ void ASTIndexDeclaration::formatImpl(const FormatSettings & s, FormatState & sta\n         }\n         else\n         {\n-            s.ostr << backQuoteIfNeed(name);\n+            s.writeIdentifier(name);\n             s.ostr << \" \";\n             expr->formatImpl(s, state, frame);\n         }\ndiff --git a/src/Parsers/ASTProjectionDeclaration.cpp b/src/Parsers/ASTProjectionDeclaration.cpp\nindex 60050986161a..af79745a88e4 100644\n--- a/src/Parsers/ASTProjectionDeclaration.cpp\n+++ b/src/Parsers/ASTProjectionDeclaration.cpp\n@@ -17,7 +17,7 @@ ASTPtr ASTProjectionDeclaration::clone() const\n \n void ASTProjectionDeclaration::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n-    settings.ostr << backQuoteIfNeed(name);\n+    settings.writeIdentifier(name);\n     std::string indent_str = settings.one_line ? \"\" : std::string(4u * frame.indent, ' ');\n     std::string nl_or_nothing = settings.one_line ? \"\" : \"\\n\";\n     settings.ostr << settings.nl_or_ws << indent_str << \"(\" << nl_or_nothing;\ndiff --git a/src/Parsers/ASTTableOverrides.cpp b/src/Parsers/ASTTableOverrides.cpp\nindex ccb485f6c699..8352e68b1568 100644\n--- a/src/Parsers/ASTTableOverrides.cpp\n+++ b/src/Parsers/ASTTableOverrides.cpp\n@@ -22,10 +22,8 @@ ASTPtr ASTTableOverride::clone() const\n     return res;\n }\n \n-void ASTTableOverride::formatImpl(const FormatSettings & settings_, FormatState & state, FormatStateStacked frame) const\n+void ASTTableOverride::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n-    FormatSettings settings = settings_;\n-    settings.always_quote_identifiers = true;\n     String nl_or_nothing = settings.one_line ? \"\" : \"\\n\";\n     String nl_or_ws = settings.one_line ? \" \" : \"\\n\";\n     String hl_keyword = settings.hilite ? hilite_keyword : \"\";\ndiff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp\nindex 5bd2c92c60ae..54b11f2888e5 100644\n--- a/src/Parsers/IAST.cpp\n+++ b/src/Parsers/IAST.cpp\n@@ -165,12 +165,21 @@ size_t IAST::checkDepthImpl(size_t max_depth) const\n     return res;\n }\n \n-String IAST::formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets, bool print_pretty_type_names) const\n+String IAST::formatWithPossiblyHidingSensitiveData(\n+    size_t max_length,\n+    bool one_line,\n+    bool show_secrets,\n+    bool print_pretty_type_names,\n+    bool always_quote_identifiers,\n+    IdentifierQuotingStyle identifier_quoting_style) const\n {\n+\n     WriteBufferFromOwnString buf;\n     FormatSettings settings(buf, one_line);\n     settings.show_secrets = show_secrets;\n     settings.print_pretty_type_names = print_pretty_type_names;\n+    settings.always_quote_identifiers = always_quote_identifiers;\n+    settings.identifier_quoting_style = identifier_quoting_style;\n     format(settings);\n     return wipeSensitiveDataAndCutToLength(buf.str(), max_length);\n }\n@@ -248,6 +257,34 @@ void IAST::FormatSettings::writeIdentifier(const String & name) const\n     }\n }\n \n+\n+void IAST::FormatSettings::quoteIdentifier(const String & name) const\n+{\n+    switch (identifier_quoting_style)\n+    {\n+        case IdentifierQuotingStyle::None:\n+        {\n+            writeBackQuotedString(name, ostr);\n+            break;\n+        }\n+        case IdentifierQuotingStyle::Backticks:\n+        {\n+            writeBackQuotedString(name, ostr);\n+            break;\n+        }\n+        case IdentifierQuotingStyle::DoubleQuotes:\n+        {\n+            writeDoubleQuotedString(name, ostr);\n+            break;\n+        }\n+        case IdentifierQuotingStyle::BackticksMySQL:\n+        {\n+            writeBackQuotedStringMySQL(name, ostr);\n+            break;\n+        }\n+    }\n+}\n+\n void IAST::dumpTree(WriteBuffer & ostr, size_t indent) const\n {\n     String indent_str(indent, '-');\ndiff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h\nindex 2293d50b0eca..dfb6a6cbeba4 100644\n--- a/src/Parsers/IAST.h\n+++ b/src/Parsers/IAST.h\n@@ -238,6 +238,9 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n         }\n \n         void writeIdentifier(const String & name) const;\n+        // Quote identifier `name` even when `always_quote_identifiers` is false.\n+        // If `identifier_quoting_style` is `IdentifierQuotingStyle::None`, quote it with `IdentifierQuotingStyle::Backticks`\n+        void quoteIdentifier(const String & name) const;\n     };\n \n     /// State. For example, a set of nodes can be remembered, which we already walk through.\n@@ -278,7 +281,13 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n \n     /// Secrets are displayed regarding show_secrets, then SensitiveDataMasker is applied.\n     /// You can use Interpreters/formatWithPossiblyHidingSecrets.h for convenience.\n-    String formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets, bool print_pretty_type_names) const;\n+    String formatWithPossiblyHidingSensitiveData(\n+        size_t max_length,\n+        bool one_line,\n+        bool show_secrets,\n+        bool print_pretty_type_names,\n+        bool always_quote_identifiers,\n+        IdentifierQuotingStyle identifier_quoting_style) const;\n \n     /** formatForLogging and formatForErrorMessage always hide secrets. This inconsistent\n       * behaviour is due to the fact such functions are called from Client which knows nothing about\n@@ -287,12 +296,12 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n       */\n     String formatForLogging(size_t max_length = 0) const\n     {\n-        return formatWithPossiblyHidingSensitiveData(max_length, true, false, false);\n+        return formatWithPossiblyHidingSensitiveData(max_length, true, false, false, false, IdentifierQuotingStyle::Backticks);\n     }\n \n     String formatForErrorMessage() const\n     {\n-        return formatWithPossiblyHidingSensitiveData(0, true, false, false);\n+        return formatWithPossiblyHidingSensitiveData(0, true, false, false, false, IdentifierQuotingStyle::Backticks);\n     }\n \n     virtual bool hasSecretParts() const { return childrenHaveSecretParts(); }\n",
  "test_patch": "diff --git a/src/Parsers/tests/gtest_Parser.cpp b/src/Parsers/tests/gtest_Parser.cpp\nindex f0abc68f9660..47f7a54389b8 100644\n--- a/src/Parsers/tests/gtest_Parser.cpp\n+++ b/src/Parsers/tests/gtest_Parser.cpp\n@@ -231,47 +231,47 @@ INSTANTIATE_TEST_SUITE_P(ParserCreateDatabaseQuery, ParserTest,\n         },\n         {\n             \"CREATE DATABASE db ENGINE=MaterializeMySQL('addr:port', 'db', 'user', 'pw') TABLE OVERRIDE `tbl`\\n(PARTITION BY toYYYYMM(created))\",\n-            \"CREATE DATABASE db\\nENGINE = MaterializeMySQL('addr:port', 'db', 'user', 'pw')\\nTABLE OVERRIDE `tbl`\\n(\\n    PARTITION BY toYYYYMM(`created`)\\n)\"\n+            \"CREATE DATABASE db\\nENGINE = MaterializeMySQL('addr:port', 'db', 'user', 'pw')\\nTABLE OVERRIDE tbl\\n(\\n    PARTITION BY toYYYYMM(created)\\n)\"\n         },\n         {\n             \"CREATE DATABASE db ENGINE=Foo TABLE OVERRIDE `tbl` (), TABLE OVERRIDE a (COLUMNS (_created DateTime MATERIALIZED now())), TABLE OVERRIDE b (PARTITION BY rand())\",\n-            \"CREATE DATABASE db\\nENGINE = Foo\\nTABLE OVERRIDE `tbl`\\n(\\n\\n),\\nTABLE OVERRIDE `a`\\n(\\n    COLUMNS\\n    (\\n        `_created` DateTime MATERIALIZED now()\\n    )\\n),\\nTABLE OVERRIDE `b`\\n(\\n    PARTITION BY rand()\\n)\"\n+            \"CREATE DATABASE db\\nENGINE = Foo\\nTABLE OVERRIDE tbl\\n(\\n\\n),\\nTABLE OVERRIDE a\\n(\\n    COLUMNS\\n    (\\n        `_created` DateTime MATERIALIZED now()\\n    )\\n),\\nTABLE OVERRIDE b\\n(\\n    PARTITION BY rand()\\n)\"\n         },\n         {\n             \"CREATE DATABASE db ENGINE=MaterializeMySQL('addr:port', 'db', 'user', 'pw') TABLE OVERRIDE tbl (COLUMNS (id UUID) PARTITION BY toYYYYMM(created))\",\n-            \"CREATE DATABASE db\\nENGINE = MaterializeMySQL('addr:port', 'db', 'user', 'pw')\\nTABLE OVERRIDE `tbl`\\n(\\n    COLUMNS\\n    (\\n        `id` UUID\\n    )\\n    PARTITION BY toYYYYMM(`created`)\\n)\"\n+            \"CREATE DATABASE db\\nENGINE = MaterializeMySQL('addr:port', 'db', 'user', 'pw')\\nTABLE OVERRIDE tbl\\n(\\n    COLUMNS\\n    (\\n        `id` UUID\\n    )\\n    PARTITION BY toYYYYMM(created)\\n)\"\n         },\n         {\n             \"CREATE DATABASE db TABLE OVERRIDE tbl (COLUMNS (INDEX foo foo TYPE minmax GRANULARITY 1) PARTITION BY if(_staged = 1, 'staging', toYYYYMM(created)))\",\n-            \"CREATE DATABASE db\\nTABLE OVERRIDE `tbl`\\n(\\n    COLUMNS\\n    (\\n        INDEX foo `foo` TYPE minmax GRANULARITY 1\\n    )\\n    PARTITION BY if(`_staged` = 1, 'staging', toYYYYMM(`created`))\\n)\"\n+            \"CREATE DATABASE db\\nTABLE OVERRIDE tbl\\n(\\n    COLUMNS\\n    (\\n        INDEX foo foo TYPE minmax GRANULARITY 1\\n    )\\n    PARTITION BY if(_staged = 1, 'staging', toYYYYMM(created))\\n)\"\n         },\n         {\n             \"CREATE DATABASE db TABLE OVERRIDE t1 (TTL inserted + INTERVAL 1 MONTH DELETE), TABLE OVERRIDE t2 (TTL `inserted` + INTERVAL 2 MONTH DELETE)\",\n-            \"CREATE DATABASE db\\nTABLE OVERRIDE `t1`\\n(\\n    TTL `inserted` + toIntervalMonth(1)\\n),\\nTABLE OVERRIDE `t2`\\n(\\n    TTL `inserted` + toIntervalMonth(2)\\n)\"\n+            \"CREATE DATABASE db\\nTABLE OVERRIDE t1\\n(\\n    TTL inserted + toIntervalMonth(1)\\n),\\nTABLE OVERRIDE t2\\n(\\n    TTL inserted + toIntervalMonth(2)\\n)\"\n         },\n         {\n             \"CREATE DATABASE db ENGINE = MaterializeMySQL('127.0.0.1:3306', 'db', 'root', 'pw') SETTINGS allows_query_when_mysql_lost = 1 TABLE OVERRIDE tab3 (COLUMNS (_staged UInt8 MATERIALIZED 1) PARTITION BY (c3) TTL c3 + INTERVAL 10 minute), TABLE OVERRIDE tab5 (PARTITION BY (c3) TTL c3 + INTERVAL 10 minute)\",\n-            \"CREATE DATABASE db\\nENGINE = MaterializeMySQL('127.0.0.1:3306', 'db', 'root', 'pw')\\nSETTINGS allows_query_when_mysql_lost = 1\\nTABLE OVERRIDE `tab3`\\n(\\n    COLUMNS\\n    (\\n        `_staged` UInt8 MATERIALIZED 1\\n    )\\n    PARTITION BY `c3`\\n    TTL `c3` + toIntervalMinute(10)\\n),\\nTABLE OVERRIDE `tab5`\\n(\\n    PARTITION BY `c3`\\n    TTL `c3` + toIntervalMinute(10)\\n)\"\n+            \"CREATE DATABASE db\\nENGINE = MaterializeMySQL('127.0.0.1:3306', 'db', 'root', 'pw')\\nSETTINGS allows_query_when_mysql_lost = 1\\nTABLE OVERRIDE tab3\\n(\\n    COLUMNS\\n    (\\n        `_staged` UInt8 MATERIALIZED 1\\n    )\\n    PARTITION BY c3\\n    TTL c3 + toIntervalMinute(10)\\n),\\nTABLE OVERRIDE tab5\\n(\\n    PARTITION BY c3\\n    TTL c3 + toIntervalMinute(10)\\n)\"\n         },\n         {\n             \"CREATE DATABASE db TABLE OVERRIDE tbl (PARTITION BY toYYYYMM(created) COLUMNS (created DateTime CODEC(Delta)))\",\n-            \"CREATE DATABASE db\\nTABLE OVERRIDE `tbl`\\n(\\n    COLUMNS\\n    (\\n        `created` DateTime CODEC(Delta)\\n    )\\n    PARTITION BY toYYYYMM(`created`)\\n)\"\n+            \"CREATE DATABASE db\\nTABLE OVERRIDE tbl\\n(\\n    COLUMNS\\n    (\\n        `created` DateTime CODEC(Delta)\\n    )\\n    PARTITION BY toYYYYMM(created)\\n)\"\n         },\n         {\n-            \"CREATE DATABASE db ENGINE = Foo() SETTINGS a = 1\",\n+            \"CREATE DATABASE db ENGINE = Foo() SETTINGS a = 1\", \n             \"CREATE DATABASE db\\nENGINE = Foo\\nSETTINGS a = 1\"\n         },\n         {\n-            \"CREATE DATABASE db ENGINE = Foo() SETTINGS a = 1, b = 2\",\n+            \"CREATE DATABASE db ENGINE = Foo() SETTINGS a = 1, b = 2\", \n             \"CREATE DATABASE db\\nENGINE = Foo\\nSETTINGS a = 1, b = 2\"\n         },\n         {\n             \"CREATE DATABASE db ENGINE = Foo() SETTINGS a = 1, b = 2 TABLE OVERRIDE a (ORDER BY (id, version))\",\n-            \"CREATE DATABASE db\\nENGINE = Foo\\nSETTINGS a = 1, b = 2\\nTABLE OVERRIDE `a`\\n(\\n    ORDER BY (`id`, `version`)\\n)\"\n+            \"CREATE DATABASE db\\nENGINE = Foo\\nSETTINGS a = 1, b = 2\\nTABLE OVERRIDE a\\n(\\n    ORDER BY (id, version)\\n)\"\n         },\n         {\n             \"CREATE DATABASE db ENGINE = Foo() SETTINGS a = 1, b = 2 COMMENT 'db comment' TABLE OVERRIDE a (ORDER BY (id, version))\",\n-            \"CREATE DATABASE db\\nENGINE = Foo\\nSETTINGS a = 1, b = 2\\nTABLE OVERRIDE `a`\\n(\\n    ORDER BY (`id`, `version`)\\n)\\nCOMMENT 'db comment'\"\n+            \"CREATE DATABASE db\\nENGINE = Foo\\nSETTINGS a = 1, b = 2\\nTABLE OVERRIDE a\\n(\\n    ORDER BY (id, version)\\n)\\nCOMMENT 'db comment'\"\n         }\n })));\n \ndiff --git a/tests/integration/test_materialized_mysql_database/materialized_with_ddl.py b/tests/integration/test_materialized_mysql_database/materialized_with_ddl.py\nindex 86000799ae4c..9a99f0c9aa80 100644\n--- a/tests/integration/test_materialized_mysql_database/materialized_with_ddl.py\n+++ b/tests/integration/test_materialized_mysql_database/materialized_with_ddl.py\n@@ -2353,7 +2353,7 @@ def table_overrides(clickhouse_node, mysql_node, service_name):\n     )\n     check_query(clickhouse_node, \"SELECT count() FROM table_overrides.t1\", \"1001\\n\")\n     show_db = clickhouse_node.query(\"SHOW CREATE DATABASE table_overrides\")\n-    assert \"TABLE OVERRIDE `t1`\\\\n(\\\\n\\\\n)\" in show_db, show_db\n+    assert \"TABLE OVERRIDE t1\\\\n(\\\\n\\\\n)\" in show_db, show_db\n \n     clickhouse_node.query(\"DROP DATABASE IF EXISTS table_overrides\")\n     mysql_node.query(\"DROP DATABASE IF EXISTS table_overrides\")\ndiff --git a/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.reference b/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.reference\nnew file mode 100644\nindex 000000000000..c563617a01c7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.reference\n@@ -0,0 +1,40 @@\n+CREATE TABLE default.uk_price_paid\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `postcode1` LowCardinality(String),\\n    `postcode2` LowCardinality(String),\\n    `type` Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    `is_new` UInt8,\\n    `duration` Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `locality` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String),\\n    INDEX county_index county TYPE set(10) GRANULARITY 1,\\n    PROJECTION town_date_projection\\n    (\\n        SELECT \\n            town,\\n            date,\\n            price\\n        ORDER BY \\n            town,\\n            date\\n    ),\\n    PROJECTION handy_aggs_projection\\n    (\\n        SELECT \\n            avg(price),\\n            max(price),\\n            sum(price)\\n        GROUP BY town\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (postcode1, postcode2, date)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.prices_by_year_view TO default.prices_by_year_dest\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String)\\n)\\nAS SELECT\\n    price,\\n    date,\\n    addr1,\\n    addr2,\\n    street,\\n    town,\\n    district,\\n    county\\nFROM default.uk_price_paid\n+CREATE TABLE default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY month\\nORDER BY month\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.uk_prices_aggs_view TO default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nAS WITH toStartOfMonth(date) AS month\\nSELECT\\n    month,\\n    minSimpleState(price) AS min_price,\\n    maxSimpleState(price) AS max_price,\\n    countState(price) AS volume,\\n    avgState(price) AS avg_price\\nFROM default.uk_price_paid\\nGROUP BY month\n+CREATE DICTIONARY default.uk_mortgage_rates_dict\\n(\\n    `date` DateTime64,\\n    `variable` Decimal32(2),\\n    `fixed` Decimal32(2),\\n    `bank` Decimal32(2)\\n)\\nPRIMARY KEY date\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE default.uk_price_paid\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `postcode1` LowCardinality(String),\\n    `postcode2` LowCardinality(String),\\n    `type` Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    `is_new` UInt8,\\n    `duration` Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `locality` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String),\\n    INDEX county_index county TYPE set(10) GRANULARITY 1,\\n    PROJECTION town_date_projection\\n    (\\n        SELECT \\n            town,\\n            date,\\n            price\\n        ORDER BY \\n            town,\\n            date\\n    ),\\n    PROJECTION handy_aggs_projection\\n    (\\n        SELECT \\n            avg(price),\\n            max(price),\\n            sum(price)\\n        GROUP BY town\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (postcode1, postcode2, date)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.prices_by_year_view TO default.prices_by_year_dest\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String)\\n)\\nAS SELECT\\n    price,\\n    date,\\n    addr1,\\n    addr2,\\n    street,\\n    town,\\n    district,\\n    county\\nFROM default.uk_price_paid\n+CREATE TABLE default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY month\\nORDER BY month\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.uk_prices_aggs_view TO default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nAS WITH toStartOfMonth(date) AS month\\nSELECT\\n    month,\\n    minSimpleState(price) AS min_price,\\n    maxSimpleState(price) AS max_price,\\n    countState(price) AS volume,\\n    avgState(price) AS avg_price\\nFROM default.uk_price_paid\\nGROUP BY month\n+CREATE DICTIONARY default.uk_mortgage_rates_dict\\n(\\n    `date` DateTime64,\\n    `variable` Decimal32(2),\\n    `fixed` Decimal32(2),\\n    `bank` Decimal32(2)\\n)\\nPRIMARY KEY date\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE `default`.`uk_price_paid`\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `postcode1` LowCardinality(String),\\n    `postcode2` LowCardinality(String),\\n    `type` Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    `is_new` UInt8,\\n    `duration` Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `locality` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String),\\n    INDEX `county_index` `county` TYPE set(10) GRANULARITY 1,\\n    PROJECTION `town_date_projection`\\n    (\\n        SELECT \\n            `town`,\\n            `date`,\\n            `price`\\n        ORDER BY \\n            `town`,\\n            `date`\\n    ),\\n    PROJECTION `handy_aggs_projection`\\n    (\\n        SELECT \\n            avg(`price`),\\n            max(`price`),\\n            sum(`price`)\\n        GROUP BY `town`\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (`postcode1`, `postcode2`, `date`)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW `default`.`prices_by_year_view` TO default.prices_by_year_dest\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String)\\n)\\nAS SELECT\\n    `price`,\\n    `date`,\\n    `addr1`,\\n    `addr2`,\\n    `street`,\\n    `town`,\\n    `district`,\\n    `county`\\nFROM `default`.`uk_price_paid`\n+CREATE TABLE `default`.`uk_prices_aggs_dest`\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(`min`, UInt32),\\n    `max_price` SimpleAggregateFunction(`max`, UInt32),\\n    `volume` AggregateFunction(`count`, UInt32),\\n    `avg_price` AggregateFunction(`avg`, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY `month`\\nORDER BY `month`\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW `default`.`uk_prices_aggs_view` TO default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(`min`, UInt32),\\n    `max_price` SimpleAggregateFunction(`max`, UInt32),\\n    `volume` AggregateFunction(`count`, UInt32),\\n    `avg_price` AggregateFunction(`avg`, UInt32)\\n)\\nAS WITH toStartOfMonth(`date`) AS `month`\\nSELECT\\n    `month`,\\n    minSimpleState(`price`) AS `min_price`,\\n    maxSimpleState(`price`) AS `max_price`,\\n    countState(`price`) AS `volume`,\\n    avgState(`price`) AS `avg_price`\\nFROM `default`.`uk_price_paid`\\nGROUP BY `month`\n+CREATE DICTIONARY `default`.`uk_mortgage_rates_dict`\\n(\\n    `date` DateTime64,\\n    `variable` Decimal32(2),\\n    `fixed` Decimal32(2),\\n    `bank` Decimal32(2)\\n)\\nPRIMARY KEY `date`\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE default.uk_price_paid\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `postcode1` LowCardinality(String),\\n    `postcode2` LowCardinality(String),\\n    `type` Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    `is_new` UInt8,\\n    `duration` Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `locality` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String),\\n    INDEX county_index county TYPE set(10) GRANULARITY 1,\\n    PROJECTION town_date_projection\\n    (\\n        SELECT \\n            town,\\n            date,\\n            price\\n        ORDER BY \\n            town,\\n            date\\n    ),\\n    PROJECTION handy_aggs_projection\\n    (\\n        SELECT \\n            avg(price),\\n            max(price),\\n            sum(price)\\n        GROUP BY town\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (postcode1, postcode2, date)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.prices_by_year_view TO default.prices_by_year_dest\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String)\\n)\\nAS SELECT\\n    price,\\n    date,\\n    addr1,\\n    addr2,\\n    street,\\n    town,\\n    district,\\n    county\\nFROM default.uk_price_paid\n+CREATE TABLE default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY month\\nORDER BY month\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.uk_prices_aggs_view TO default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nAS WITH toStartOfMonth(date) AS month\\nSELECT\\n    month,\\n    minSimpleState(price) AS min_price,\\n    maxSimpleState(price) AS max_price,\\n    countState(price) AS volume,\\n    avgState(price) AS avg_price\\nFROM default.uk_price_paid\\nGROUP BY month\n+CREATE DICTIONARY default.uk_mortgage_rates_dict\\n(\\n    `date` DateTime64,\\n    `variable` Decimal32(2),\\n    `fixed` Decimal32(2),\\n    `bank` Decimal32(2)\\n)\\nPRIMARY KEY date\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE \"default\".\"uk_price_paid\"\\n(\\n    \"price\" UInt32,\\n    \"date\" Date,\\n    \"postcode1\" LowCardinality(String),\\n    \"postcode2\" LowCardinality(String),\\n    \"type\" Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    \"is_new\" UInt8,\\n    \"duration\" Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    \"addr1\" String,\\n    \"addr2\" String,\\n    \"street\" LowCardinality(String),\\n    \"locality\" LowCardinality(String),\\n    \"town\" LowCardinality(String),\\n    \"district\" LowCardinality(String),\\n    \"county\" LowCardinality(String),\\n    INDEX \"county_index\" \"county\" TYPE set(10) GRANULARITY 1,\\n    PROJECTION \"town_date_projection\"\\n    (\\n        SELECT \\n            \"town\",\\n            \"date\",\\n            \"price\"\\n        ORDER BY \\n            \"town\",\\n            \"date\"\\n    ),\\n    PROJECTION \"handy_aggs_projection\"\\n    (\\n        SELECT \\n            avg(\"price\"),\\n            max(\"price\"),\\n            sum(\"price\")\\n        GROUP BY \"town\"\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (\"postcode1\", \"postcode2\", \"date\")\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW \"default\".\"prices_by_year_view\" TO default.prices_by_year_dest\\n(\\n    \"price\" UInt32,\\n    \"date\" Date,\\n    \"addr1\" String,\\n    \"addr2\" String,\\n    \"street\" LowCardinality(String),\\n    \"town\" LowCardinality(String),\\n    \"district\" LowCardinality(String),\\n    \"county\" LowCardinality(String)\\n)\\nAS SELECT\\n    \"price\",\\n    \"date\",\\n    \"addr1\",\\n    \"addr2\",\\n    \"street\",\\n    \"town\",\\n    \"district\",\\n    \"county\"\\nFROM \"default\".\"uk_price_paid\"\n+CREATE TABLE \"default\".\"uk_prices_aggs_dest\"\\n(\\n    \"month\" Date,\\n    \"min_price\" SimpleAggregateFunction(\"min\", UInt32),\\n    \"max_price\" SimpleAggregateFunction(\"max\", UInt32),\\n    \"volume\" AggregateFunction(\"count\", UInt32),\\n    \"avg_price\" AggregateFunction(\"avg\", UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY \"month\"\\nORDER BY \"month\"\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW \"default\".\"uk_prices_aggs_view\" TO default.uk_prices_aggs_dest\\n(\\n    \"month\" Date,\\n    \"min_price\" SimpleAggregateFunction(\"min\", UInt32),\\n    \"max_price\" SimpleAggregateFunction(\"max\", UInt32),\\n    \"volume\" AggregateFunction(\"count\", UInt32),\\n    \"avg_price\" AggregateFunction(\"avg\", UInt32)\\n)\\nAS WITH toStartOfMonth(\"date\") AS \"month\"\\nSELECT\\n    \"month\",\\n    minSimpleState(\"price\") AS \"min_price\",\\n    maxSimpleState(\"price\") AS \"max_price\",\\n    countState(\"price\") AS \"volume\",\\n    avgState(\"price\") AS \"avg_price\"\\nFROM \"default\".\"uk_price_paid\"\\nGROUP BY \"month\"\n+CREATE DICTIONARY \"default\".\"uk_mortgage_rates_dict\"\\n(\\n    \"date\" DateTime64,\\n    \"variable\" Decimal32(2),\\n    \"fixed\" Decimal32(2),\\n    \"bank\" Decimal32(2)\\n)\\nPRIMARY KEY \"date\"\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE default.uk_price_paid\\n(\\n    \"price\" UInt32,\\n    \"date\" Date,\\n    \"postcode1\" LowCardinality(String),\\n    \"postcode2\" LowCardinality(String),\\n    \"type\" Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    \"is_new\" UInt8,\\n    \"duration\" Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    \"addr1\" String,\\n    \"addr2\" String,\\n    \"street\" LowCardinality(String),\\n    \"locality\" LowCardinality(String),\\n    \"town\" LowCardinality(String),\\n    \"district\" LowCardinality(String),\\n    \"county\" LowCardinality(String),\\n    INDEX county_index county TYPE set(10) GRANULARITY 1,\\n    PROJECTION town_date_projection\\n    (\\n        SELECT \\n            town,\\n            date,\\n            price\\n        ORDER BY \\n            town,\\n            date\\n    ),\\n    PROJECTION handy_aggs_projection\\n    (\\n        SELECT \\n            avg(price),\\n            max(price),\\n            sum(price)\\n        GROUP BY town\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (postcode1, postcode2, date)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.prices_by_year_view TO default.prices_by_year_dest\\n(\\n    \"price\" UInt32,\\n    \"date\" Date,\\n    \"addr1\" String,\\n    \"addr2\" String,\\n    \"street\" LowCardinality(String),\\n    \"town\" LowCardinality(String),\\n    \"district\" LowCardinality(String),\\n    \"county\" LowCardinality(String)\\n)\\nAS SELECT\\n    price,\\n    date,\\n    addr1,\\n    addr2,\\n    street,\\n    town,\\n    district,\\n    county\\nFROM default.uk_price_paid\n+CREATE TABLE default.uk_prices_aggs_dest\\n(\\n    \"month\" Date,\\n    \"min_price\" SimpleAggregateFunction(min, UInt32),\\n    \"max_price\" SimpleAggregateFunction(max, UInt32),\\n    \"volume\" AggregateFunction(count, UInt32),\\n    \"avg_price\" AggregateFunction(avg, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY month\\nORDER BY month\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.uk_prices_aggs_view TO default.uk_prices_aggs_dest\\n(\\n    \"month\" Date,\\n    \"min_price\" SimpleAggregateFunction(min, UInt32),\\n    \"max_price\" SimpleAggregateFunction(max, UInt32),\\n    \"volume\" AggregateFunction(count, UInt32),\\n    \"avg_price\" AggregateFunction(avg, UInt32)\\n)\\nAS WITH toStartOfMonth(date) AS month\\nSELECT\\n    month,\\n    minSimpleState(price) AS min_price,\\n    maxSimpleState(price) AS max_price,\\n    countState(price) AS volume,\\n    avgState(price) AS avg_price\\nFROM default.uk_price_paid\\nGROUP BY month\n+CREATE DICTIONARY default.uk_mortgage_rates_dict\\n(\\n    \"date\" DateTime64,\\n    \"variable\" Decimal32(2),\\n    \"fixed\" Decimal32(2),\\n    \"bank\" Decimal32(2)\\n)\\nPRIMARY KEY date\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE `default`.`uk_price_paid`\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `postcode1` LowCardinality(String),\\n    `postcode2` LowCardinality(String),\\n    `type` Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    `is_new` UInt8,\\n    `duration` Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `locality` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String),\\n    INDEX `county_index` `county` TYPE set(10) GRANULARITY 1,\\n    PROJECTION `town_date_projection`\\n    (\\n        SELECT \\n            `town`,\\n            `date`,\\n            `price`\\n        ORDER BY \\n            `town`,\\n            `date`\\n    ),\\n    PROJECTION `handy_aggs_projection`\\n    (\\n        SELECT \\n            avg(`price`),\\n            max(`price`),\\n            sum(`price`)\\n        GROUP BY `town`\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (`postcode1`, `postcode2`, `date`)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW `default`.`prices_by_year_view` TO default.prices_by_year_dest\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String)\\n)\\nAS SELECT\\n    `price`,\\n    `date`,\\n    `addr1`,\\n    `addr2`,\\n    `street`,\\n    `town`,\\n    `district`,\\n    `county`\\nFROM `default`.`uk_price_paid`\n+CREATE TABLE `default`.`uk_prices_aggs_dest`\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(`min`, UInt32),\\n    `max_price` SimpleAggregateFunction(`max`, UInt32),\\n    `volume` AggregateFunction(`count`, UInt32),\\n    `avg_price` AggregateFunction(`avg`, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY `month`\\nORDER BY `month`\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW `default`.`uk_prices_aggs_view` TO default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(`min`, UInt32),\\n    `max_price` SimpleAggregateFunction(`max`, UInt32),\\n    `volume` AggregateFunction(`count`, UInt32),\\n    `avg_price` AggregateFunction(`avg`, UInt32)\\n)\\nAS WITH toStartOfMonth(`date`) AS `month`\\nSELECT\\n    `month`,\\n    minSimpleState(`price`) AS `min_price`,\\n    maxSimpleState(`price`) AS `max_price`,\\n    countState(`price`) AS `volume`,\\n    avgState(`price`) AS `avg_price`\\nFROM `default`.`uk_price_paid`\\nGROUP BY `month`\n+CREATE DICTIONARY `default`.`uk_mortgage_rates_dict`\\n(\\n    `date` DateTime64,\\n    `variable` Decimal32(2),\\n    `fixed` Decimal32(2),\\n    `bank` Decimal32(2)\\n)\\nPRIMARY KEY `date`\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\n+CREATE TABLE default.uk_price_paid\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `postcode1` LowCardinality(String),\\n    `postcode2` LowCardinality(String),\\n    `type` Enum8(\\'other\\' = 0, \\'terraced\\' = 1, \\'semi-detached\\' = 2, \\'detached\\' = 3, \\'flat\\' = 4),\\n    `is_new` UInt8,\\n    `duration` Enum8(\\'unknown\\' = 0, \\'freehold\\' = 1, \\'leasehold\\' = 2),\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `locality` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String),\\n    INDEX county_index county TYPE set(10) GRANULARITY 1,\\n    PROJECTION town_date_projection\\n    (\\n        SELECT \\n            town,\\n            date,\\n            price\\n        ORDER BY \\n            town,\\n            date\\n    ),\\n    PROJECTION handy_aggs_projection\\n    (\\n        SELECT \\n            avg(price),\\n            max(price),\\n            sum(price)\\n        GROUP BY town\\n    )\\n)\\nENGINE = MergeTree\\nORDER BY (postcode1, postcode2, date)\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.prices_by_year_view TO default.prices_by_year_dest\\n(\\n    `price` UInt32,\\n    `date` Date,\\n    `addr1` String,\\n    `addr2` String,\\n    `street` LowCardinality(String),\\n    `town` LowCardinality(String),\\n    `district` LowCardinality(String),\\n    `county` LowCardinality(String)\\n)\\nAS SELECT\\n    price,\\n    date,\\n    addr1,\\n    addr2,\\n    street,\\n    town,\\n    district,\\n    county\\nFROM default.uk_price_paid\n+CREATE TABLE default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nENGINE = AggregatingMergeTree\\nPRIMARY KEY month\\nORDER BY month\\nSETTINGS index_granularity = 8192\n+CREATE MATERIALIZED VIEW default.uk_prices_aggs_view TO default.uk_prices_aggs_dest\\n(\\n    `month` Date,\\n    `min_price` SimpleAggregateFunction(min, UInt32),\\n    `max_price` SimpleAggregateFunction(max, UInt32),\\n    `volume` AggregateFunction(count, UInt32),\\n    `avg_price` AggregateFunction(avg, UInt32)\\n)\\nAS WITH toStartOfMonth(date) AS month\\nSELECT\\n    month,\\n    minSimpleState(price) AS min_price,\\n    maxSimpleState(price) AS max_price,\\n    countState(price) AS volume,\\n    avgState(price) AS avg_price\\nFROM default.uk_price_paid\\nGROUP BY month\n+CREATE DICTIONARY default.uk_mortgage_rates_dict\\n(\\n    `date` DateTime64,\\n    `variable` Decimal32(2),\\n    `fixed` Decimal32(2),\\n    `bank` Decimal32(2)\\n)\\nPRIMARY KEY date\\nSOURCE(CLICKHOUSE(TABLE \\'uk_mortgage_rates\\'))\\nLIFETIME(MIN 0 MAX 2628000000)\\nLAYOUT(COMPLEX_KEY_HASHED())\ndiff --git a/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.sql b/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.sql\nnew file mode 100644\nindex 000000000000..c500dd4e4c6e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.sql\n@@ -0,0 +1,328 @@\n+DROP DICTIONARY IF EXISTS uk_mortgage_rates_dict;\n+DROP TABLE IF EXISTS uk_mortgage_rates;\n+DROP VIEW IF EXISTS uk_prices_aggs_view;\n+DROP TABLE IF EXISTS uk_prices_aggs_dest;\n+DROP VIEW IF EXISTS prices_by_year_view;\n+DROP TABLE IF EXISTS prices_by_year_dest;\n+DROP TABLE IF EXISTS uk_price_paid;\n+\n+-- Create tables, views, dictionaries\n+\n+CREATE TABLE uk_price_paid\n+(\n+    price UInt32,\n+    date Date,\n+    postcode1 LowCardinality(String),\n+    postcode2 LowCardinality(String),\n+    type Enum('terraced' = 1, 'semi-detached' = 2, 'detached' = 3, 'flat' = 4, 'other' = 0),\n+    is_new UInt8,\n+    duration Enum('freehold' = 1, 'leasehold' = 2, 'unknown' = 0),\n+    addr1 String,\n+    addr2 String,\n+    street LowCardinality(String),\n+    locality LowCardinality(String),\n+    town LowCardinality(String),\n+    district LowCardinality(String),\n+    county LowCardinality(String),\n+    INDEX county_index county TYPE set(10) GRANULARITY 1,\n+    PROJECTION town_date_projection\n+    (\n+        SELECT \n+            town,\n+            date,\n+            price\n+        ORDER BY \n+            town,\n+            date\n+    ),\n+    PROJECTION handy_aggs_projection\n+    (\n+        SELECT \n+            avg(price),\n+            max(price),\n+            sum(price)\n+        GROUP BY town\n+    )\n+)\n+ENGINE = MergeTree\n+ORDER BY (postcode1, postcode2, date);\n+\n+CREATE TABLE prices_by_year_dest (\n+    price UInt32,\n+    date Date,\n+    addr1 String,\n+    addr2 String,\n+    street LowCardinality(String),\n+    town LowCardinality(String),\n+    district LowCardinality(String),\n+    county LowCardinality(String)\n+)\n+ENGINE = MergeTree\n+PRIMARY KEY (town, date)\n+PARTITION BY toYear(date);\n+\n+CREATE MATERIALIZED VIEW prices_by_year_view\n+TO prices_by_year_dest\n+AS\n+    SELECT\n+        price,\n+        date,\n+        addr1,\n+        addr2,\n+        street,\n+        town,\n+        district,\n+        county\n+    FROM uk_price_paid;\n+\n+CREATE TABLE uk_prices_aggs_dest (\n+    month Date,\n+    min_price SimpleAggregateFunction(min, UInt32),\n+    max_price SimpleAggregateFunction(max, UInt32),\n+    volume AggregateFunction(count, UInt32),\n+    avg_price AggregateFunction(avg, UInt32)\n+)\n+ENGINE = AggregatingMergeTree\n+PRIMARY KEY month;\n+\n+CREATE MATERIALIZED VIEW uk_prices_aggs_view\n+TO uk_prices_aggs_dest\n+AS\n+    WITH\n+        toStartOfMonth(date) AS month\n+    SELECT\n+        month,\n+        minSimpleState(price) AS min_price,\n+        maxSimpleState(price) AS max_price,\n+        countState(price) AS volume,\n+        avgState(price) AS avg_price\n+    FROM uk_price_paid\n+    GROUP BY month;\n+\n+CREATE TABLE uk_mortgage_rates (\n+    date DateTime64,\n+    variable Decimal32(2),\n+    fixed Decimal32(2),\n+    bank Decimal32(2)\n+)\n+ENGINE Memory();\n+\n+INSERT INTO uk_mortgage_rates VALUES ('2004-02-29', 5.02, 4.9, 4);\n+INSERT INTO uk_mortgage_rates VALUES ('2004-03-31', 5.11, 4.91, 4);\n+\n+CREATE DICTIONARY uk_mortgage_rates_dict (\n+    date DateTime64,\n+    variable Decimal32(2),\n+    fixed Decimal32(2),\n+    bank Decimal32(2)\n+)\n+PRIMARY KEY date\n+SOURCE(\n+  CLICKHOUSE(TABLE 'uk_mortgage_rates')\n+)\n+LAYOUT(COMPLEX_KEY_HASHED())\n+LIFETIME(2628000000);\n+\n+\n+-- Show tables, views, dictionaries with default settings\n+SHOW CREATE TABLE uk_price_paid;\n+\n+SHOW CREATE VIEW prices_by_year_view;\n+\n+SHOW CREATE uk_prices_aggs_dest;\n+\n+SHOW CREATE VIEW uk_prices_aggs_view;\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict;\n+\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=false, output_format_identifier_quoting_style='None' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='None';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='None';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='None';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='None';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='None';\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=true, output_format_identifier_quoting_style='Backticks' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=false, output_format_identifier_quoting_style='Backticks' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='Backticks';\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=true, output_format_identifier_quoting_style='DoubleQuotes' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=false, output_format_identifier_quoting_style='DoubleQuotes' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='DoubleQuotes';\n+\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=true, output_format_identifier_quoting_style='BackticksMySQL' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=true,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+-- Show tables, views, dictionaries with output_format_always_quote_identifiers=false, output_format_identifier_quoting_style='BackticksMySQL' \n+SHOW CREATE TABLE uk_price_paid\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE VIEW prices_by_year_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE uk_prices_aggs_dest\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE VIEW uk_prices_aggs_view\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+SHOW CREATE DICTIONARY uk_mortgage_rates_dict\n+SETTINGS\n+    output_format_always_quote_identifiers=false,\n+    output_format_identifier_quoting_style='BackticksMySQL';\n+\n+DROP DICTIONARY uk_mortgage_rates_dict;\n+DROP TABLE uk_mortgage_rates;\n+DROP VIEW uk_prices_aggs_view;\n+DROP TABLE uk_prices_aggs_dest;\n+DROP VIEW prices_by_year_view;\n+DROP TABLE prices_by_year_dest;\n+DROP TABLE uk_price_paid;\n",
  "problem_statement": "SHOW CREATE TABLE Output With Quotes Instead of Backticks\n**Use case**\r\nWe're writing a script to automate generation of documentation for the tables in markdown. Copying and pasting a query into markdown or languages like javascript/typescript with backticks may require that they be escaped, which looks messy and is annoying.\r\n\r\n**Describe the solution you'd like**\r\nA `SETTING` to output `SHOW CREATE TABLE foo` or `DESCRIBE foo` with quotes instead of backticks. For example:\r\n\r\n```sql\r\nSHOW CREATE TABLE foo\r\n```\r\n\r\n```sql\r\nCREATE TABLE foo (\r\n  `id` UInt64,\r\n  `bar` Nested (\r\n    `baz` String,\r\n    `shibby` String\r\n  )\r\n)\r\nENGINE = MergeTree\r\nORDER BY (`bar.baz`)\r\n```\r\n\r\n```sql\r\nSHOW CREATE TABLE foo SETTINGS format_identifiers_with_quotes=1\r\n```\r\n\r\n```sql\r\nCREATE TABLE foo (\r\n  \"id\" UInt64,\r\n  \"bar\" Nested (\r\n    \"baz\" String,\r\n    \"shibby\" String\r\n  )\r\n)\r\nENGINE = MergeTree\r\nORDER BY (\"bar.baz\")\r\n```\r\n\r\n\r\n**Additional context**\r\nAny script could do a `.replaceAll` to replace backticks with quotes, but it would be nice to have it be natively supported --especially as a server-wide setting so it was consistent in developers' database clients of choice.\n",
  "hints_text": "",
  "created_at": "2024-08-26T15:36:43Z",
  "modified_files": [
    "src/Core/ExternalTable.cpp",
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.cpp",
    "src/Core/SettingsEnums.cpp",
    "src/Core/SettingsEnums.h",
    "src/Interpreters/executeQuery.cpp",
    "src/Interpreters/formatWithPossiblyHidingSecrets.h",
    "src/Parsers/ASTColumnDeclaration.cpp",
    "src/Parsers/ASTDictionaryAttributeDeclaration.cpp",
    "src/Parsers/ASTIndexDeclaration.cpp",
    "src/Parsers/ASTProjectionDeclaration.cpp",
    "src/Parsers/ASTTableOverrides.cpp",
    "src/Parsers/IAST.cpp",
    "src/Parsers/IAST.h"
  ],
  "modified_test_files": [
    "src/Parsers/tests/gtest_Parser.cpp",
    "tests/integration/test_materialized_mysql_database/materialized_with_ddl.py",
    "b/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.reference",
    "b/tests/queries/0_stateless/03230_output_format_identifier_quoting_style.sql"
  ]
}