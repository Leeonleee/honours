{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25064,
  "instance_id": "ClickHouse__ClickHouse-25064",
  "issue_numbers": [
    "776"
  ],
  "base_commit": "8351f1db9923100e411c380a8ba3fa52b5dff4d3",
  "patch": "diff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex d91ea9208e43..f814e1d8c02d 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -103,6 +103,24 @@ ASTPtr evaluateConstantExpressionForDatabaseName(const ASTPtr & node, ContextPtr\n     return res;\n }\n \n+std::tuple<bool, ASTPtr> evaluateDatabaseNameForMergeEngine(const ASTPtr & node, ContextPtr context)\n+{\n+    if (const auto * func = node->as<ASTFunction>(); func && func->name == \"REGEXP\")\n+    {\n+        if (func->arguments->children.size() != 1)\n+            throw Exception(\"Arguments for REGEXP in Merge ENGINE should be 1\", ErrorCodes::BAD_ARGUMENTS);\n+\n+        auto * literal = func->arguments->children[0]->as<ASTLiteral>();\n+        if (!literal || literal->value.safeGet<String>().empty())\n+            throw Exception(\"Argument for REGEXP in Merge ENGINE should be a non empty String Literal\", ErrorCodes::BAD_ARGUMENTS);\n+\n+        return std::tuple{true, func->arguments->children[0]};\n+    }\n+\n+    auto ast = evaluateConstantExpressionForDatabaseName(node, context);\n+    return std::tuple{false, ast};\n+}\n+\n namespace\n {\n     using Conjunction = ColumnsWithTypeAndName;\ndiff --git a/src/Interpreters/evaluateConstantExpression.h b/src/Interpreters/evaluateConstantExpression.h\nindex b95982f5b996..3b817080fe0e 100644\n--- a/src/Interpreters/evaluateConstantExpression.h\n+++ b/src/Interpreters/evaluateConstantExpression.h\n@@ -53,4 +53,6 @@ ASTPtr evaluateConstantExpressionForDatabaseName(const ASTPtr & node, ContextPtr\n   */\n std::optional<Blocks> evaluateExpressionOverConstantCondition(const ASTPtr & node, const ExpressionActionsPtr & target_expr, size_t & limit);\n \n+// Evaluate database name or regexp for StorageMerge and TableFunction merge\n+std::tuple<bool, ASTPtr> evaluateDatabaseNameForMergeEngine(const ASTPtr & node, ContextPtr context);\n }\ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex a076393e7e6d..2d5bbfc712d6 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -47,13 +47,16 @@ StorageMerge::StorageMerge(\n     const StorageID & table_id_,\n     const ColumnsDescription & columns_,\n     const String & comment,\n-    const String & source_database_,\n-    const Strings & source_tables_,\n+    const String & source_database_name_or_regexp_,\n+    bool database_is_regexp_,\n+    const DbToTableSetMap & source_databases_and_tables_,\n     ContextPtr context_)\n     : IStorage(table_id_)\n     , WithContext(context_->getGlobalContext())\n-    , source_database(source_database_)\n-    , source_tables(std::in_place, source_tables_.begin(), source_tables_.end())\n+    , source_database_regexp(source_database_name_or_regexp_)\n+    , source_databases_and_tables(source_databases_and_tables_)\n+    , source_database_name_or_regexp(source_database_name_or_regexp_)\n+    , database_is_regexp(database_is_regexp_)\n {\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n@@ -65,13 +68,16 @@ StorageMerge::StorageMerge(\n     const StorageID & table_id_,\n     const ColumnsDescription & columns_,\n     const String & comment,\n-    const String & source_database_,\n+    const String & source_database_name_or_regexp_,\n+    bool database_is_regexp_,\n     const String & source_table_regexp_,\n     ContextPtr context_)\n     : IStorage(table_id_)\n     , WithContext(context_->getGlobalContext())\n-    , source_database(source_database_)\n+    , source_database_regexp(source_database_name_or_regexp_)\n     , source_table_regexp(source_table_regexp_)\n+    , source_database_name_or_regexp(source_database_name_or_regexp_)\n+    , database_is_regexp(database_is_regexp_)\n {\n     StorageInMemoryMetadata storage_metadata;\n     storage_metadata.setColumns(columns_);\n@@ -82,15 +88,18 @@ StorageMerge::StorageMerge(\n template <typename F>\n StoragePtr StorageMerge::getFirstTable(F && predicate) const\n {\n-    auto iterator = getDatabaseIterator(getContext());\n+    auto database_table_iterators = getDatabaseIterators(getContext());\n \n-    while (iterator->isValid())\n+    for (auto & iterator : database_table_iterators)\n     {\n-        const auto & table = iterator->table();\n-        if (table.get() != this && predicate(table))\n-            return table;\n+        while (iterator->isValid())\n+        {\n+            const auto & table = iterator->table();\n+            if (table.get() != this && predicate(table))\n+                return table;\n \n-        iterator->next();\n+            iterator->next();\n+        }\n     }\n \n     return {};\n@@ -112,7 +121,7 @@ bool StorageMerge::mayBenefitFromIndexForIn(const ASTPtr & left_in_operand, Cont\n     size_t i = 0;\n     for (const auto & table : selected_tables)\n     {\n-        const auto & storage_ptr = std::get<0>(table);\n+        const auto & storage_ptr = std::get<1>(table);\n         auto metadata_snapshot = storage_ptr->getInMemoryMetadataPtr();\n         if (storage_ptr->mayBenefitFromIndexForIn(left_in_operand, query_context, metadata_snapshot))\n             return true;\n@@ -145,22 +154,25 @@ QueryProcessingStage::Enum StorageMerge::getQueryProcessingStage(\n \n     auto stage_in_source_tables = QueryProcessingStage::FetchColumns;\n \n-    DatabaseTablesIteratorPtr iterator = getDatabaseIterator(local_context);\n+    DatabaseTablesIterators database_table_iterators = getDatabaseIterators(local_context);\n \n     size_t selected_table_size = 0;\n \n-    while (iterator->isValid())\n+    for (const auto & iterator : database_table_iterators)\n     {\n-        const auto & table = iterator->table();\n-        if (table && table.get() != this)\n+        while (iterator->isValid())\n         {\n-            ++selected_table_size;\n-            stage_in_source_tables = std::max(\n-                stage_in_source_tables,\n-                table->getQueryProcessingStage(local_context, to_stage, table->getInMemoryMetadataPtr(), query_info));\n-        }\n+            const auto & table = iterator->table();\n+            if (table && table.get() != this)\n+            {\n+                ++selected_table_size;\n+                stage_in_source_tables = std::max(\n+                    stage_in_source_tables,\n+                    table->getQueryProcessingStage(local_context, to_stage, table->getInMemoryMetadataPtr(), query_info));\n+            }\n \n-        iterator->next();\n+            iterator->next();\n+        }\n     }\n \n     return selected_table_size == 1 ? stage_in_source_tables : std::min(stage_in_source_tables, QueryProcessingStage::WithMergeableState);\n@@ -178,13 +190,16 @@ Pipe StorageMerge::read(\n {\n     Pipes pipes;\n \n+    bool has_database_virtual_column = false;\n     bool has_table_virtual_column = false;\n     Names real_column_names;\n     real_column_names.reserve(column_names.size());\n \n     for (const auto & column_name : column_names)\n     {\n-        if (column_name == \"_table\" && isVirtualColumn(column_name, metadata_snapshot))\n+        if (column_name == \"_database\" && isVirtualColumn(column_name, metadata_snapshot))\n+            has_database_virtual_column = true;\n+        else if (column_name == \"_table\" && isVirtualColumn(column_name, metadata_snapshot))\n             has_table_virtual_column = true;\n         else\n             real_column_names.push_back(column_name);\n@@ -202,12 +217,24 @@ Pipe StorageMerge::read(\n     /** First we make list of selected tables to find out its size.\n       * This is necessary to correctly pass the recommended number of threads to each table.\n       */\n-    StorageListWithLocks selected_tables = getSelectedTables(local_context, query_info.query, has_table_virtual_column);\n+    StorageListWithLocks selected_tables\n+        = getSelectedTables(local_context, query_info.query, has_database_virtual_column, has_table_virtual_column);\n \n     if (selected_tables.empty())\n         /// FIXME: do we support sampling in this case?\n         return createSources(\n-            {}, query_info, processed_stage, max_block_size, header, {}, {}, real_column_names, modified_context, 0, has_table_virtual_column);\n+            {},\n+            query_info,\n+            processed_stage,\n+            max_block_size,\n+            header,\n+            {},\n+            {},\n+            real_column_names,\n+            modified_context,\n+            0,\n+            has_database_virtual_column,\n+            has_table_virtual_column);\n \n     size_t tables_count = selected_tables.size();\n     Float64 num_streams_multiplier\n@@ -220,7 +247,7 @@ Pipe StorageMerge::read(\n     {\n         for (auto it = selected_tables.begin(); it != selected_tables.end(); ++it)\n         {\n-            auto storage_ptr = std::get<0>(*it);\n+            auto storage_ptr = std::get<1>(*it);\n             auto storage_metadata_snapshot = storage_ptr->getInMemoryMetadataPtr();\n             auto current_info = query_info.order_optimizer->getInputOrder(storage_metadata_snapshot, local_context);\n             if (it == selected_tables.begin())\n@@ -245,7 +272,7 @@ Pipe StorageMerge::read(\n         remaining_streams -= current_streams;\n         current_streams = std::max(size_t(1), current_streams);\n \n-        const auto & storage = std::get<0>(table);\n+        const auto & storage = std::get<1>(table);\n \n         /// If sampling requested, then check that table supports it.\n         if (query_info.query->as<ASTSelectQuery>()->sampleSize() && !storage->supportsSampling())\n@@ -293,9 +320,18 @@ Pipe StorageMerge::read(\n         }\n \n         auto source_pipe = createSources(\n-            storage_metadata_snapshot, query_info, processed_stage,\n-            max_block_size, header, aliases, table, required_columns.empty() ? real_column_names : required_columns,\n-            modified_context, current_streams, has_table_virtual_column);\n+            storage_metadata_snapshot,\n+            query_info,\n+            processed_stage,\n+            max_block_size,\n+            header,\n+            aliases,\n+            table,\n+            required_columns.empty() ? real_column_names : required_columns,\n+            modified_context,\n+            current_streams,\n+            has_database_virtual_column,\n+            has_table_virtual_column);\n \n         pipes.emplace_back(std::move(source_pipe));\n     }\n@@ -321,10 +357,11 @@ Pipe StorageMerge::createSources(\n     Names & real_column_names,\n     ContextMutablePtr modified_context,\n     size_t streams_num,\n+    bool has_database_virtual_column,\n     bool has_table_virtual_column,\n     bool concat_streams)\n {\n-    const auto & [storage, struct_lock, table_name] = storage_with_lock;\n+    const auto & [database_name, storage, struct_lock, table_name] = storage_with_lock;\n     SelectQueryInfo modified_query_info = query_info;\n     modified_query_info.query = query_info.query->clone();\n \n@@ -336,6 +373,7 @@ Pipe StorageMerge::createSources(\n     modified_query_info.syntax_analyzer_result = std::make_shared<TreeRewriterResult>(std::move(new_analyzer_res));\n \n     VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, \"_table\", table_name);\n+    VirtualColumnUtils::rewriteEntityInAst(modified_query_info.query, \"_database\", database_name);\n \n     Pipe pipe;\n \n@@ -369,7 +407,7 @@ Pipe StorageMerge::createSources(\n     }\n     else if (processed_stage > storage_stage)\n     {\n-        modified_select.replaceDatabaseAndTable(source_database, table_name);\n+        modified_select.replaceDatabaseAndTable(database_name, table_name);\n \n         /// Maximum permissible parallelism is streams_num\n         modified_context->setSetting(\"max_threads\", streams_num);\n@@ -394,6 +432,24 @@ Pipe StorageMerge::createSources(\n             // Using concat instead.\n             pipe.addTransform(std::make_shared<ConcatProcessor>(pipe.getHeader(), pipe.numOutputPorts()));\n \n+        if (has_database_virtual_column)\n+        {\n+            ColumnWithTypeAndName column;\n+            column.name = \"_database\";\n+            column.type = std::make_shared<DataTypeString>();\n+            column.column = column.type->createColumnConst(0, Field(database_name));\n+\n+            auto adding_column_dag = ActionsDAG::makeAddingColumnActions(std::move(column));\n+            auto adding_column_actions = std::make_shared<ExpressionActions>(\n+                std::move(adding_column_dag),\n+                ExpressionActionsSettings::fromContext(modified_context, CompileExpressions::yes));\n+\n+            pipe.addSimpleTransform([&](const Block & stream_header)\n+            {\n+                return std::make_shared<ExpressionTransform>(stream_header, adding_column_actions);\n+            });\n+        }\n+\n         if (has_table_virtual_column)\n         {\n             ColumnWithTypeAndName column;\n@@ -425,41 +481,67 @@ Pipe StorageMerge::createSources(\n }\n \n StorageMerge::StorageListWithLocks StorageMerge::getSelectedTables(\n-        ContextPtr query_context,\n-        const ASTPtr & query /* = nullptr */,\n-        bool filter_by_virtual_column /* = false */) const\n+    ContextPtr query_context,\n+    const ASTPtr & query /* = nullptr */,\n+    bool filter_by_database_virtual_column /* = false */,\n+    bool filter_by_table_virtual_column /* = false */) const\n {\n-    assert(!filter_by_virtual_column || query);\n+    assert(!filter_by_database_virtual_column || !filter_by_table_virtual_column || query);\n \n     const Settings & settings = query_context->getSettingsRef();\n     StorageListWithLocks selected_tables;\n-    DatabaseTablesIteratorPtr iterator = getDatabaseIterator(getContext());\n+    DatabaseTablesIterators database_table_iterators = getDatabaseIterators(getContext());\n \n+    MutableColumnPtr database_name_virtual_column;\n     MutableColumnPtr table_name_virtual_column;\n-    if (filter_by_virtual_column)\n+    if (filter_by_database_virtual_column)\n+    {\n+        database_name_virtual_column = ColumnString::create();\n+    }\n+\n+    if (filter_by_table_virtual_column)\n+    {\n         table_name_virtual_column = ColumnString::create();\n+    }\n \n-    while (iterator->isValid())\n+    for (const auto & iterator : database_table_iterators)\n     {\n-        StoragePtr storage = iterator->table();\n-        if (!storage)\n-            continue;\n+        if (filter_by_database_virtual_column)\n+            database_name_virtual_column->insert(iterator->databaseName());\n+        while (iterator->isValid())\n+        {\n+            StoragePtr storage = iterator->table();\n+            if (!storage)\n+                continue;\n \n-        if (query && query->as<ASTSelectQuery>()->prewhere() && !storage->supportsPrewhere())\n-            throw Exception(\"Storage \" + storage->getName() + \" doesn't support PREWHERE.\", ErrorCodes::ILLEGAL_PREWHERE);\n+            if (query && query->as<ASTSelectQuery>()->prewhere() && !storage->supportsPrewhere())\n+                throw Exception(\"Storage \" + storage->getName() + \" doesn't support PREWHERE.\", ErrorCodes::ILLEGAL_PREWHERE);\n \n-        if (storage.get() != this)\n-        {\n-            auto table_lock = storage->lockForShare(query_context->getCurrentQueryId(), settings.lock_acquire_timeout);\n-            selected_tables.emplace_back(storage, std::move(table_lock), iterator->name());\n-            if (filter_by_virtual_column)\n-                table_name_virtual_column->insert(iterator->name());\n+            if (storage.get() != this)\n+            {\n+                auto table_lock = storage->lockForShare(query_context->getCurrentQueryId(), settings.lock_acquire_timeout);\n+                selected_tables.emplace_back(iterator->databaseName(), storage, std::move(table_lock), iterator->name());\n+                if (filter_by_table_virtual_column)\n+                    table_name_virtual_column->insert(iterator->name());\n+            }\n+\n+            iterator->next();\n         }\n+    }\n+\n+    if (filter_by_database_virtual_column)\n+    {\n+        /// Filter names of selected tables if there is a condition on \"_database\" virtual column in WHERE clause\n+        Block virtual_columns_block\n+            = Block{ColumnWithTypeAndName(std::move(database_name_virtual_column), std::make_shared<DataTypeString>(), \"_database\")};\n+        VirtualColumnUtils::filterBlockWithQuery(query, virtual_columns_block, query_context);\n+        auto values = VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_database\");\n \n-        iterator->next();\n+        /// Remove unused databases from the list\n+        selected_tables.remove_if([&](const auto & elem) { return values.find(std::get<0>(elem)) == values.end(); });\n     }\n \n-    if (filter_by_virtual_column)\n+    if (filter_by_table_virtual_column)\n     {\n         /// Filter names of selected tables if there is a condition on \"_table\" virtual column in WHERE clause\n         Block virtual_columns_block = Block{ColumnWithTypeAndName(std::move(table_name_virtual_column), std::make_shared<DataTypeString>(), \"_table\")};\n@@ -467,13 +549,30 @@ StorageMerge::StorageListWithLocks StorageMerge::getSelectedTables(\n         auto values = VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_table\");\n \n         /// Remove unused tables from the list\n-        selected_tables.remove_if([&] (const auto & elem) { return values.find(std::get<2>(elem)) == values.end(); });\n+        selected_tables.remove_if([&](const auto & elem) { return values.find(std::get<3>(elem)) == values.end(); });\n     }\n \n     return selected_tables;\n }\n \n-DatabaseTablesIteratorPtr StorageMerge::getDatabaseIterator(ContextPtr local_context) const\n+DatabaseTablesIteratorPtr StorageMerge::getDatabaseIterator(const String & database_name, ContextPtr local_context) const\n+{\n+    auto database = DatabaseCatalog::instance().getDatabase(database_name);\n+\n+    auto table_name_match = [this, &database_name](const String & table_name_) -> bool {\n+        if (source_databases_and_tables)\n+        {\n+            const auto & source_tables = (*source_databases_and_tables).at(database_name);\n+            return source_tables.count(table_name_);\n+        }\n+        else\n+            return source_table_regexp->match(table_name_);\n+    };\n+\n+    return database->getTablesIterator(local_context, table_name_match);\n+}\n+\n+StorageMerge::DatabaseTablesIterators StorageMerge::getDatabaseIterators(ContextPtr local_context) const\n {\n     try\n     {\n@@ -485,17 +584,25 @@ DatabaseTablesIteratorPtr StorageMerge::getDatabaseIterator(ContextPtr local_con\n         throw;\n     }\n \n-    auto database = DatabaseCatalog::instance().getDatabase(source_database);\n+    DatabaseTablesIterators database_table_iterators;\n \n-    auto table_name_match = [this](const String & table_name_) -> bool\n+    /// database_name argument is not a regexp\n+    if (!database_is_regexp)\n+        database_table_iterators.emplace_back(getDatabaseIterator(source_database_name_or_regexp, local_context));\n+\n+    /// database_name argument is a regexp\n+    else\n     {\n-        if (source_tables)\n-            return source_tables->count(table_name_);\n-        else\n-            return source_table_regexp->match(table_name_);\n-    };\n+        auto databases = DatabaseCatalog::instance().getDatabases();\n \n-    return database->getTablesIterator(local_context, table_name_match);\n+        for (const auto & db : databases)\n+        {\n+            if (source_database_regexp->match(db.first))\n+                database_table_iterators.emplace_back(getDatabaseIterator(db.first, local_context));\n+        }\n+    }\n+\n+    return database_table_iterators;\n }\n \n \n@@ -632,19 +739,23 @@ void registerStorageMerge(StorageFactory & factory)\n                 \" - name of source database and regexp for table names.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        engine_args[0] = evaluateConstantExpressionForDatabaseName(engine_args[0], args.getLocalContext());\n-        engine_args[1] = evaluateConstantExpressionAsLiteral(engine_args[1], args.getLocalContext());\n+        auto [is_regexp, database_ast] = evaluateDatabaseNameForMergeEngine(engine_args[0], args.getLocalContext());\n \n-        String source_database = engine_args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+        if (!is_regexp)\n+            engine_args[0] = database_ast;\n+        String source_database_name_or_regexp = database_ast->as<ASTLiteral &>().value.safeGet<String>();\n+\n+        engine_args[1] = evaluateConstantExpressionAsLiteral(engine_args[1], args.getLocalContext());\n         String table_name_regexp = engine_args[1]->as<ASTLiteral &>().value.safeGet<String>();\n \n-        return StorageMerge::create(args.table_id, args.columns, args.comment, source_database, table_name_regexp, args.getContext());\n+        return StorageMerge::create(\n+            args.table_id, args.columns, args.comment, source_database_name_or_regexp, is_regexp, table_name_regexp, args.getContext());\n     });\n }\n \n NamesAndTypesList StorageMerge::getVirtuals() const\n {\n-    NamesAndTypesList virtuals{{\"_table\", std::make_shared<DataTypeString>()}};\n+    NamesAndTypesList virtuals{{\"_database\", std::make_shared<DataTypeString>()}, {\"_table\", std::make_shared<DataTypeString>()}};\n \n     auto first_table = getFirstTable([](auto && table) { return table; });\n     if (first_table)\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 068008170ca6..20460e951564 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -49,20 +49,32 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora\n         const ASTPtr & left_in_operand, ContextPtr query_context, const StorageMetadataPtr & metadata_snapshot) const override;\n \n private:\n-    String source_database;\n-    std::optional<std::unordered_set<String>> source_tables;\n+    using DbToTableSetMap = std::map<String, std::set<String>>;\n+\n+    std::optional<OptimizedRegularExpression> source_database_regexp;\n     std::optional<OptimizedRegularExpression> source_table_regexp;\n+    std::optional<DbToTableSetMap> source_databases_and_tables;\n+\n+    String source_database_name_or_regexp;\n+    bool database_is_regexp = false;\n \n-    using StorageWithLockAndName = std::tuple<StoragePtr, TableLockHolder, String>;\n+    /// (Database, Table, Lock, TableName)\n+    using StorageWithLockAndName = std::tuple<String, StoragePtr, TableLockHolder, String>;\n     using StorageListWithLocks = std::list<StorageWithLockAndName>;\n+    using DatabaseTablesIterators = std::vector<DatabaseTablesIteratorPtr>;\n \n     StorageMerge::StorageListWithLocks getSelectedTables(\n-            ContextPtr query_context, const ASTPtr & query = nullptr, bool filter_by_virtual_column = false) const;\n+        ContextPtr query_context,\n+        const ASTPtr & query = nullptr,\n+        bool filter_by_database_virtual_column = false,\n+        bool filter_by_table_virtual_column = false) const;\n \n     template <typename F>\n     StoragePtr getFirstTable(F && predicate) const;\n \n-    DatabaseTablesIteratorPtr getDatabaseIterator(ContextPtr context) const;\n+    DatabaseTablesIteratorPtr getDatabaseIterator(const String & database_name, ContextPtr context) const;\n+\n+    DatabaseTablesIterators getDatabaseIterators(ContextPtr context) const;\n \n     NamesAndTypesList getVirtuals() const override;\n     ColumnSizeByName getColumnSizes() const override;\n@@ -72,15 +84,17 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora\n         const StorageID & table_id_,\n         const ColumnsDescription & columns_,\n         const String & comment,\n-        const String & source_database_,\n-        const Strings & source_tables_,\n+        const String & source_database_name_or_regexp_,\n+        bool database_is_regexp_,\n+        const DbToTableSetMap & source_databases_and_tables_,\n         ContextPtr context_);\n \n     StorageMerge(\n         const StorageID & table_id_,\n         const ColumnsDescription & columns_,\n         const String & comment,\n-        const String & source_database_,\n+        const String & source_database_name_or_regexp_,\n+        bool database_is_regexp_,\n         const String & source_table_regexp_,\n         ContextPtr context_);\n \n@@ -104,6 +118,7 @@ class StorageMerge final : public shared_ptr_helper<StorageMerge>, public IStora\n         Names & real_column_names,\n         ContextMutablePtr modified_context,\n         size_t streams_num,\n+        bool has_database_virtual_column,\n         bool has_table_virtual_column,\n         bool concat_streams = false);\n \ndiff --git a/src/TableFunctions/TableFunctionMerge.cpp b/src/TableFunctions/TableFunctionMerge.cpp\nindex 051aa38398ff..81dde4a12a40 100644\n--- a/src/TableFunctions/TableFunctionMerge.cpp\n+++ b/src/TableFunctions/TableFunctionMerge.cpp\n@@ -18,17 +18,20 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int UNKNOWN_TABLE;\n+    extern const int BAD_ARGUMENTS;\n }\n \n namespace\n {\n-    [[noreturn]] void throwNoTablesMatchRegexp(const String & source_database, const String & source_table_regexp)\n+    [[noreturn]] void throwNoTablesMatchRegexp(const String & source_database_regexp, const String & source_table_regexp)\n     {\n         throw Exception(\n-            \"Error while executing table function merge. In database \" + source_database\n-                + \" no one matches regular expression: \" + source_table_regexp,\n-            ErrorCodes::UNKNOWN_TABLE);\n+            ErrorCodes::BAD_ARGUMENTS,\n+            \"Error while executing table function merge. Either there is no database, which matches regular expression `{}`, or there are \"\n+            \"no tables in database matches `{}`, which fit tables expression: {}\",\n+            source_database_regexp,\n+            source_database_regexp,\n+            source_table_regexp);\n     }\n }\n \n@@ -49,58 +52,72 @@ void TableFunctionMerge::parseArguments(const ASTPtr & ast_function, ContextPtr\n             \" - name of source database and regexp for table names.\",\n             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-    args[0] = evaluateConstantExpressionForDatabaseName(args[0], context);\n-    args[1] = evaluateConstantExpressionAsLiteral(args[1], context);\n+    auto [is_regexp, database_ast] = evaluateDatabaseNameForMergeEngine(args[0], context);\n+\n+    database_is_regexp = is_regexp;\n+\n+    if (!is_regexp)\n+        args[0] = database_ast;\n+    source_database_name_or_regexp = database_ast->as<ASTLiteral &>().value.safeGet<String>();\n \n-    source_database = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+    args[1] = evaluateConstantExpressionAsLiteral(args[1], context);\n     source_table_regexp = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n }\n \n \n-const Strings & TableFunctionMerge::getSourceTables(ContextPtr context) const\n+const TableFunctionMerge::DbToTableSetMap & TableFunctionMerge::getSourceDatabasesAndTables(ContextPtr context) const\n {\n-    if (source_tables)\n-        return *source_tables;\n-\n-    auto database = DatabaseCatalog::instance().getDatabase(source_database);\n+    if (source_databases_and_tables)\n+        return *source_databases_and_tables;\n \n-    OptimizedRegularExpression re(source_table_regexp);\n-    auto table_name_match = [&](const String & table_name_) { return re.match(table_name_); };\n+    source_databases_and_tables.emplace();\n \n-    auto access = context->getAccess();\n-    bool granted_show_on_all_tables = access->isGranted(AccessType::SHOW_TABLES, source_database);\n-    bool granted_select_on_all_tables = access->isGranted(AccessType::SELECT, source_database);\n-\n-    source_tables.emplace();\n-    for (auto it = database->getTablesIterator(context, table_name_match); it->isValid(); it->next())\n+    /// database_name is not a regexp\n+    if (!database_is_regexp)\n     {\n-        if (!it->table())\n-            continue;\n-        bool granted_show = granted_show_on_all_tables || access->isGranted(AccessType::SHOW_TABLES, source_database, it->name());\n-        if (!granted_show)\n-            continue;\n-        if (!granted_select_on_all_tables)\n-            access->checkAccess(AccessType::SELECT, source_database, it->name());\n-        source_tables->emplace_back(it->name());\n+        auto source_tables = getMatchedTablesWithAccess(source_database_name_or_regexp, source_table_regexp, context);\n+        if (source_tables.empty())\n+            throwNoTablesMatchRegexp(source_database_name_or_regexp, source_table_regexp);\n+        (*source_databases_and_tables)[source_database_name_or_regexp] = source_tables;\n     }\n \n-    if (source_tables->empty())\n-        throwNoTablesMatchRegexp(source_database, source_table_regexp);\n+    /// database_name is a regexp\n+    else\n+    {\n+        OptimizedRegularExpression database_re(source_database_name_or_regexp);\n+        auto databases = DatabaseCatalog::instance().getDatabases();\n+\n+        for (const auto & db : databases)\n+        {\n+            if (database_re.match(db.first))\n+            {\n+                auto source_tables = getMatchedTablesWithAccess(db.first, source_table_regexp, context);\n+\n+                if (!source_tables.empty())\n+                    (*source_databases_and_tables)[db.first] = source_tables;\n+            }\n+        }\n+\n+        if ((*source_databases_and_tables).empty())\n+            throwNoTablesMatchRegexp(source_database_name_or_regexp, source_table_regexp);\n+    }\n \n-    return *source_tables;\n+    return *source_databases_and_tables;\n }\n \n-\n ColumnsDescription TableFunctionMerge::getActualTableStructure(ContextPtr context) const\n {\n-    for (const auto & table_name : getSourceTables(context))\n+    for (const auto & db_with_tables : getSourceDatabasesAndTables(context))\n     {\n-        auto storage = DatabaseCatalog::instance().tryGetTable(StorageID{source_database, table_name}, context);\n-        if (storage)\n-            return ColumnsDescription{storage->getInMemoryMetadataPtr()->getColumns().getAllPhysical()};\n+        for (const auto & table : db_with_tables.second)\n+        {\n+            auto storage = DatabaseCatalog::instance().tryGetTable(StorageID{db_with_tables.first, table}, context);\n+            if (storage)\n+                return ColumnsDescription{storage->getInMemoryMetadataPtr()->getColumns().getAllPhysical()};\n+        }\n     }\n \n-    throwNoTablesMatchRegexp(source_database, source_table_regexp);\n+    throwNoTablesMatchRegexp(source_database_name_or_regexp, source_table_regexp);\n }\n \n \n@@ -110,14 +127,44 @@ StoragePtr TableFunctionMerge::executeImpl(const ASTPtr & /*ast_function*/, Cont\n         StorageID(getDatabaseName(), table_name),\n         getActualTableStructure(context),\n         String{},\n-        source_database,\n-        getSourceTables(context),\n+        source_database_name_or_regexp,\n+        database_is_regexp,\n+        getSourceDatabasesAndTables(context),\n         context);\n \n     res->startup();\n     return res;\n }\n \n+TableFunctionMerge::TableSet\n+TableFunctionMerge::getMatchedTablesWithAccess(const String & database_name, const String & table_regexp, const ContextPtr & context)\n+{\n+    OptimizedRegularExpression table_re(table_regexp);\n+\n+    auto table_name_match = [&](const String & table_name) { return table_re.match(table_name); };\n+\n+    auto access = context->getAccess();\n+\n+    auto database = DatabaseCatalog::instance().getDatabase(database_name);\n+\n+    bool granted_show_on_all_tables = access->isGranted(AccessType::SHOW_TABLES, database_name);\n+    bool granted_select_on_all_tables = access->isGranted(AccessType::SELECT, database_name);\n+\n+    TableSet tables;\n+\n+    for (auto it = database->getTablesIterator(context, table_name_match); it->isValid(); it->next())\n+    {\n+        if (!it->table())\n+            continue;\n+        bool granted_show = granted_show_on_all_tables || access->isGranted(AccessType::SHOW_TABLES, database_name, it->name());\n+        if (!granted_show)\n+            continue;\n+        if (!granted_select_on_all_tables)\n+            access->checkAccess(AccessType::SELECT, database_name, it->name());\n+        tables.emplace(it->name());\n+    }\n+    return tables;\n+}\n \n void registerTableFunctionMerge(TableFunctionFactory & factory)\n {\ndiff --git a/src/TableFunctions/TableFunctionMerge.h b/src/TableFunctions/TableFunctionMerge.h\nindex 04027b9d76a2..73b61f8eb799 100644\n--- a/src/TableFunctions/TableFunctionMerge.h\n+++ b/src/TableFunctions/TableFunctionMerge.h\n@@ -15,17 +15,22 @@ class TableFunctionMerge : public ITableFunction\n public:\n     static constexpr auto name = \"merge\";\n     std::string getName() const override { return name; }\n+\n private:\n     StoragePtr executeImpl(const ASTPtr & ast_function, ContextPtr context, const std::string & table_name, ColumnsDescription cached_columns) const override;\n     const char * getStorageTypeName() const override { return \"Merge\"; }\n \n-    const Strings & getSourceTables(ContextPtr context) const;\n+    using TableSet = std::set<String>;\n+    using DbToTableSetMap = std::map<String, TableSet>;\n+    const DbToTableSetMap & getSourceDatabasesAndTables(ContextPtr context) const;\n     ColumnsDescription getActualTableStructure(ContextPtr context) const override;\n     void parseArguments(const ASTPtr & ast_function, ContextPtr context) override;\n+    static TableSet getMatchedTablesWithAccess(const String & database_name, const String & table_regexp, const ContextPtr & context);\n \n-    String source_database;\n+    String source_database_name_or_regexp;\n     String source_table_regexp;\n-    mutable std::optional<Strings> source_tables;\n+    bool database_is_regexp = false;\n+    mutable std::optional<DbToTableSetMap> source_databases_and_tables;\n };\n \n \n",
  "test_patch": "diff --git a/tests/integration/test_table_functions_access_rights/test.py b/tests/integration/test_table_functions_access_rights/test.py\nindex bd2f767413a1..16f184079608 100644\n--- a/tests/integration/test_table_functions_access_rights/test.py\n+++ b/tests/integration/test_table_functions_access_rights/test.py\n@@ -38,7 +38,7 @@ def test_merge():\n     assert \"it's necessary to have grant CREATE TEMPORARY TABLE ON *.*\" in instance.query_and_get_error(select_query, user = 'A')\n \n     instance.query(\"GRANT CREATE TEMPORARY TABLE ON *.* TO A\")\n-    assert \"no one matches regular expression\" in instance.query_and_get_error(select_query, user = 'A')\n+    assert \"no tables in database matches\" in instance.query_and_get_error(select_query, user = 'A')\n     \n     instance.query(\"GRANT SELECT ON default.table1 TO A\")\n     assert instance.query(select_query, user = 'A') == \"1\\n\"\ndiff --git a/tests/queries/0_stateless/01902_table_function_merge_db_repr.reference b/tests/queries/0_stateless/01902_table_function_merge_db_repr.reference\nnew file mode 100644\nindex 000000000000..4fd27ceec776\n--- /dev/null\n+++ b/tests/queries/0_stateless/01902_table_function_merge_db_repr.reference\n@@ -0,0 +1,195 @@\n+CREATE TABLE t_merge as 01902_db.t ENGINE=Merge(REGEXP(^01902_db), ^t)\n+SELECT _database, _table, n FROM 01902_db.t_merge ORDER BY _database, _table, n\n+01902_db\tt\t0\n+01902_db\tt\t1\n+01902_db\tt\t2\n+01902_db\tt\t3\n+01902_db\tt\t4\n+01902_db\tt\t5\n+01902_db\tt\t6\n+01902_db\tt\t7\n+01902_db\tt\t8\n+01902_db\tt\t9\n+01902_db1\tt1\t0\n+01902_db1\tt1\t1\n+01902_db1\tt1\t2\n+01902_db1\tt1\t3\n+01902_db1\tt1\t4\n+01902_db1\tt1\t5\n+01902_db1\tt1\t6\n+01902_db1\tt1\t7\n+01902_db1\tt1\t8\n+01902_db1\tt1\t9\n+01902_db2\tt2\t0\n+01902_db2\tt2\t1\n+01902_db2\tt2\t2\n+01902_db2\tt2\t3\n+01902_db2\tt2\t4\n+01902_db2\tt2\t5\n+01902_db2\tt2\t6\n+01902_db2\tt2\t7\n+01902_db2\tt2\t8\n+01902_db2\tt2\t9\n+01902_db3\tt3\t0\n+01902_db3\tt3\t1\n+01902_db3\tt3\t2\n+01902_db3\tt3\t3\n+01902_db3\tt3\t4\n+01902_db3\tt3\t5\n+01902_db3\tt3\t6\n+01902_db3\tt3\t7\n+01902_db3\tt3\t8\n+01902_db3\tt3\t9\n+SHOW CREATE TABLE 01902_db.t_merge\n+CREATE TABLE `01902_db`.t_merge\\n(\\n    `n` Int8\\n)\\nENGINE = Merge(REGEXP(\\'^01902_db\\'), \\'^t\\')\n+SELECT _database, _table, n FROM merge(REGEXP(^01902_db), ^t) ORDER BY _database, _table, n\n+01902_db\tt\t0\n+01902_db\tt\t1\n+01902_db\tt\t2\n+01902_db\tt\t3\n+01902_db\tt\t4\n+01902_db\tt\t5\n+01902_db\tt\t6\n+01902_db\tt\t7\n+01902_db\tt\t8\n+01902_db\tt\t9\n+01902_db\tt_merge\t0\n+01902_db\tt_merge\t0\n+01902_db\tt_merge\t0\n+01902_db\tt_merge\t0\n+01902_db\tt_merge\t1\n+01902_db\tt_merge\t1\n+01902_db\tt_merge\t1\n+01902_db\tt_merge\t1\n+01902_db\tt_merge\t2\n+01902_db\tt_merge\t2\n+01902_db\tt_merge\t2\n+01902_db\tt_merge\t2\n+01902_db\tt_merge\t3\n+01902_db\tt_merge\t3\n+01902_db\tt_merge\t3\n+01902_db\tt_merge\t3\n+01902_db\tt_merge\t4\n+01902_db\tt_merge\t4\n+01902_db\tt_merge\t4\n+01902_db\tt_merge\t4\n+01902_db\tt_merge\t5\n+01902_db\tt_merge\t5\n+01902_db\tt_merge\t5\n+01902_db\tt_merge\t5\n+01902_db\tt_merge\t6\n+01902_db\tt_merge\t6\n+01902_db\tt_merge\t6\n+01902_db\tt_merge\t6\n+01902_db\tt_merge\t7\n+01902_db\tt_merge\t7\n+01902_db\tt_merge\t7\n+01902_db\tt_merge\t7\n+01902_db\tt_merge\t8\n+01902_db\tt_merge\t8\n+01902_db\tt_merge\t8\n+01902_db\tt_merge\t8\n+01902_db\tt_merge\t9\n+01902_db\tt_merge\t9\n+01902_db\tt_merge\t9\n+01902_db\tt_merge\t9\n+01902_db1\tt1\t0\n+01902_db1\tt1\t1\n+01902_db1\tt1\t2\n+01902_db1\tt1\t3\n+01902_db1\tt1\t4\n+01902_db1\tt1\t5\n+01902_db1\tt1\t6\n+01902_db1\tt1\t7\n+01902_db1\tt1\t8\n+01902_db1\tt1\t9\n+01902_db2\tt2\t0\n+01902_db2\tt2\t1\n+01902_db2\tt2\t2\n+01902_db2\tt2\t3\n+01902_db2\tt2\t4\n+01902_db2\tt2\t5\n+01902_db2\tt2\t6\n+01902_db2\tt2\t7\n+01902_db2\tt2\t8\n+01902_db2\tt2\t9\n+01902_db3\tt3\t0\n+01902_db3\tt3\t1\n+01902_db3\tt3\t2\n+01902_db3\tt3\t3\n+01902_db3\tt3\t4\n+01902_db3\tt3\t5\n+01902_db3\tt3\t6\n+01902_db3\tt3\t7\n+01902_db3\tt3\t8\n+01902_db3\tt3\t9\n+SELECT _database, _table, n FROM 01902_db.t_merge WHERE _database = 01902_db1 ORDER BY _database, _table, n\n+01902_db1\tt1\t0\n+01902_db1\tt1\t1\n+01902_db1\tt1\t2\n+01902_db1\tt1\t3\n+01902_db1\tt1\t4\n+01902_db1\tt1\t5\n+01902_db1\tt1\t6\n+01902_db1\tt1\t7\n+01902_db1\tt1\t8\n+01902_db1\tt1\t9\n+SELECT _database, _table, n FROM 01902_db.t_merge WHERE _table = t1 ORDER BY _database, _table, n\n+01902_db1\tt1\t0\n+01902_db1\tt1\t1\n+01902_db1\tt1\t2\n+01902_db1\tt1\t3\n+01902_db1\tt1\t4\n+01902_db1\tt1\t5\n+01902_db1\tt1\t6\n+01902_db1\tt1\t7\n+01902_db1\tt1\t8\n+01902_db1\tt1\t9\n+CREATE TABLE t_merge1 as 01902_db.t ENGINE=Merge(01902_db, ^t$)\n+SELECT _database, _table, n FROM 01902_db.t_merge1 ORDER BY _database, _table, n\n+01902_db\tt\t0\n+01902_db\tt\t1\n+01902_db\tt\t2\n+01902_db\tt\t3\n+01902_db\tt\t4\n+01902_db\tt\t5\n+01902_db\tt\t6\n+01902_db\tt\t7\n+01902_db\tt\t8\n+01902_db\tt\t9\n+SELECT _database, _table, n FROM merge(01902_db, ^t$) ORDER BY _database, _table, n\n+01902_db\tt\t0\n+01902_db\tt\t1\n+01902_db\tt\t2\n+01902_db\tt\t3\n+01902_db\tt\t4\n+01902_db\tt\t5\n+01902_db\tt\t6\n+01902_db\tt\t7\n+01902_db\tt\t8\n+01902_db\tt\t9\n+CREATE TABLE t_merge_1 as 01902_db.t ENGINE=Merge(currentDatabase(), ^t)\n+SELECT _database, _table, n FROM 01902_db.t_merge_1 ORDER BY _database, _table, n\n+01902_db1\tt1\t0\n+01902_db1\tt1\t1\n+01902_db1\tt1\t2\n+01902_db1\tt1\t3\n+01902_db1\tt1\t4\n+01902_db1\tt1\t5\n+01902_db1\tt1\t6\n+01902_db1\tt1\t7\n+01902_db1\tt1\t8\n+01902_db1\tt1\t9\n+SHOW CREATE TABLE 01902_db.t_merge_1\n+CREATE TABLE `01902_db`.t_merge_1\\n(\\n    `n` Int8\\n)\\nENGINE = Merge(\\'01902_db1\\', \\'^t\\')\n+SELECT _database, _table, n FROM merge(currentDatabase(), ^t) ORDER BY _database, _table, n\n+01902_db1\tt1\t0\n+01902_db1\tt1\t1\n+01902_db1\tt1\t2\n+01902_db1\tt1\t3\n+01902_db1\tt1\t4\n+01902_db1\tt1\t5\n+01902_db1\tt1\t6\n+01902_db1\tt1\t7\n+01902_db1\tt1\t8\n+01902_db1\tt1\t9\ndiff --git a/tests/queries/0_stateless/01902_table_function_merge_db_repr.sql b/tests/queries/0_stateless/01902_table_function_merge_db_repr.sql\nnew file mode 100644\nindex 000000000000..3aabf1a1f36b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01902_table_function_merge_db_repr.sql\n@@ -0,0 +1,66 @@\n+DROP DATABASE IF EXISTS 01902_db;\n+DROP DATABASE IF EXISTS 01902_db1;\n+DROP DATABASE IF EXISTS 01902_db2;\n+DROP DATABASE IF EXISTS 01902_db3;\n+\n+CREATE DATABASE 01902_db;\n+CREATE DATABASE 01902_db1;\n+CREATE DATABASE 01902_db2;\n+CREATE DATABASE 01902_db3;\n+\n+CREATE TABLE 01902_db.t   (n Int8) ENGINE=MergeTree ORDER BY n;\n+CREATE TABLE 01902_db1.t1 (n Int8) ENGINE=MergeTree ORDER BY n;\n+CREATE TABLE 01902_db2.t2 (n Int8) ENGINE=MergeTree ORDER BY n;\n+CREATE TABLE 01902_db3.t3 (n Int8) ENGINE=MergeTree ORDER BY n;\n+\n+INSERT INTO 01902_db.t   SELECT * FROM numbers(10);\n+INSERT INTO 01902_db1.t1 SELECT * FROM numbers(10);\n+INSERT INTO 01902_db2.t2 SELECT * FROM numbers(10);\n+INSERT INTO 01902_db3.t3 SELECT * FROM numbers(10);\n+\n+SELECT 'CREATE TABLE t_merge as 01902_db.t ENGINE=Merge(REGEXP(^01902_db), ^t)';\n+CREATE TABLE 01902_db.t_merge as 01902_db.t ENGINE=Merge(REGEXP('^01902_db'), '^t');\n+\n+SELECT 'SELECT _database, _table, n FROM 01902_db.t_merge ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM 01902_db.t_merge ORDER BY _database, _table, n;\n+\n+SELECT 'SHOW CREATE TABLE 01902_db.t_merge';\n+SHOW CREATE  TABLE 01902_db.t_merge;\n+\n+SELECT 'SELECT _database, _table, n FROM merge(REGEXP(^01902_db), ^t) ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM merge(REGEXP('^01902_db'), '^t') ORDER BY _database, _table, n;\n+\n+SELECT 'SELECT _database, _table, n FROM 01902_db.t_merge WHERE _database = 01902_db1 ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM 01902_db.t_merge WHERE _database = '01902_db1' ORDER BY _database, _table, n;\n+\n+SELECT 'SELECT _database, _table, n FROM 01902_db.t_merge WHERE _table = t1 ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM 01902_db.t_merge WHERE _table = 't1' ORDER BY _database, _table, n;\n+\n+-- not regexp\n+SELECT 'CREATE TABLE t_merge1 as 01902_db.t ENGINE=Merge(01902_db, ^t$)';\n+CREATE TABLE 01902_db.t_merge1 as 01902_db.t ENGINE=Merge('01902_db', '^t$');\n+\n+SELECT 'SELECT _database, _table, n FROM 01902_db.t_merge1 ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM 01902_db.t_merge1 ORDER BY _database, _table, n;\n+\n+SELECT 'SELECT _database, _table, n FROM merge(01902_db, ^t$) ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM merge('01902_db', '^t$') ORDER BY _database, _table, n;\n+\n+USE 01902_db1;\n+\n+SELECT 'CREATE TABLE t_merge_1 as 01902_db.t ENGINE=Merge(currentDatabase(), ^t)';\n+CREATE TABLE 01902_db.t_merge_1 as 01902_db.t ENGINE=Merge(currentDatabase(), '^t');\n+\n+SELECT 'SELECT _database, _table, n FROM 01902_db.t_merge_1 ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM 01902_db.t_merge_1 ORDER BY _database, _table, n;\n+\n+SELECT 'SHOW CREATE TABLE 01902_db.t_merge_1';\n+SHOW CREATE TABLE 01902_db.t_merge_1;\n+\n+SELECT 'SELECT _database, _table, n FROM merge(currentDatabase(), ^t) ORDER BY _database, _table, n';\n+SELECT _database, _table, n FROM merge(currentDatabase(), '^t') ORDER BY _database, _table, n;\n+\n+DROP DATABASE 01902_db;\n+DROP DATABASE 01902_db1;\n+DROP DATABASE 01902_db2;\n+DROP DATABASE 01902_db3;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex be52bee71b1a..a3e4c32c08e1 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -854,6 +854,7 @@\n         \"01914_exchange_dictionaries\",\n         \"01915_create_or_replace_dictionary\",\n         \"01925_test_storage_merge_aliases\",\n-        \"01933_client_replxx_convert_history\" /// Uses non unique history file\n+        \"01933_client_replxx_convert_history\", /// Uses non unique history file\n+        \"01902_table_function_merge_db_repr\"\n     ]\n }\n",
  "problem_statement": "FR: Cross-database Merge table engine\nFeature request:\r\nA new DBMerge table engine, which can run the Merge engine across databases, using a regex for database name matching. For instance:\r\n`Merge('^Web', '^WatchLog')`would return results from all tables that matched `'^WatchLog'` in all databases that matched `'^Web'`. An additional column `database_name` would identify the database where the table data came from.\n",
  "hints_text": "",
  "created_at": "2021-06-08T03:18:39Z",
  "modified_files": [
    "src/Interpreters/evaluateConstantExpression.cpp",
    "src/Interpreters/evaluateConstantExpression.h",
    "src/Storages/StorageMerge.cpp",
    "src/Storages/StorageMerge.h",
    "src/TableFunctions/TableFunctionMerge.cpp",
    "src/TableFunctions/TableFunctionMerge.h"
  ],
  "modified_test_files": [
    "tests/integration/test_table_functions_access_rights/test.py",
    "b/tests/queries/0_stateless/01902_table_function_merge_db_repr.reference",
    "b/tests/queries/0_stateless/01902_table_function_merge_db_repr.sql",
    "tests/queries/skip_list.json"
  ]
}