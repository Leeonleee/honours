diff --git a/src/Common/ICachePolicyUserQuota.h b/src/Common/ICachePolicyUserQuota.h
index 6fa4f7947cb1..d6555785f4a4 100644
--- a/src/Common/ICachePolicyUserQuota.h
+++ b/src/Common/ICachePolicyUserQuota.h
@@ -25,6 +25,9 @@ class ICachePolicyUserQuota
     /// Is the user allowed to write a new entry into the cache?
     virtual bool approveWrite(const UUID & user_id, size_t entry_size_in_bytes) const = 0;
 
+    /// Clears the policy contents
+    virtual void clear() = 0;
+
     virtual ~ICachePolicyUserQuota() = default;
 };
 
@@ -38,6 +41,7 @@ class NoCachePolicyUserQuota : public ICachePolicyUserQuota
     void increaseActual(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) override {}
     void decreaseActual(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) override {}
     bool approveWrite(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) const override { return true; }
+    void clear() override {}
 };
 
 
diff --git a/src/Common/TTLCachePolicy.h b/src/Common/TTLCachePolicy.h
index 338cc543385a..8960b742c74f 100644
--- a/src/Common/TTLCachePolicy.h
+++ b/src/Common/TTLCachePolicy.h
@@ -38,12 +38,12 @@ class PerUserTTLCachePolicyUserQuota : public ICachePolicyUserQuota
     bool approveWrite(const UUID & user_id, size_t entry_size_in_bytes) const override
     {
         auto it_actual = actual.find(user_id);
-        Resources actual_for_user{.size_in_bytes = 0, .num_items = 0}; /// assume zero actual resource consumption is user isn't found
+        Resources actual_for_user{.size_in_bytes = 0, .num_items = 0}; /// if no user is found, the default is no resource consumption
         if (it_actual != actual.end())
             actual_for_user = it_actual->second;
 
         auto it_quota = quotas.find(user_id);
-        Resources quota_for_user{.size_in_bytes = std::numeric_limits<size_t>::max(), .num_items = std::numeric_limits<size_t>::max()}; /// assume no threshold if no quota is found
+        Resources quota_for_user{.size_in_bytes = std::numeric_limits<size_t>::max(), .num_items = std::numeric_limits<size_t>::max()}; /// if no user is found, the default is no threshold
         if (it_quota != quotas.end())
             quota_for_user = it_quota->second;
 
@@ -54,16 +54,21 @@ class PerUserTTLCachePolicyUserQuota : public ICachePolicyUserQuota
             quota_for_user.num_items = std::numeric_limits<UInt64>::max();
 
         /// Check size quota
-        if (actual_for_user.size_in_bytes + entry_size_in_bytes >= quota_for_user.size_in_bytes)
+        if (actual_for_user.size_in_bytes + entry_size_in_bytes > quota_for_user.size_in_bytes)
             return false;
 
         /// Check items quota
-        if (quota_for_user.num_items + 1 >= quota_for_user.num_items)
+        if (actual_for_user.num_items + 1 > quota_for_user.num_items)
             return false;
 
         return true;
     }
 
+    void clear() override
+    {
+        actual.clear();
+    }
+
     struct Resources
     {
         size_t size_in_bytes = 0;
@@ -125,6 +130,7 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc
     void clear() override
     {
         cache.clear();
+        Base::user_quotas->clear();
     }
 
     void remove(const Key & key) override
