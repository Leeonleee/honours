diff --git a/src/AggregateFunctions/AggregateFunctionFactory.cpp b/src/AggregateFunctions/AggregateFunctionFactory.cpp
index eac761c1a827..347f4607dbf6 100644
--- a/src/AggregateFunctions/AggregateFunctionFactory.cpp
+++ b/src/AggregateFunctions/AggregateFunctionFactory.cpp
@@ -70,11 +70,11 @@ static DataTypes convertLowCardinalityTypesToNested(const DataTypes & types)
 AggregateFunctionPtr AggregateFunctionFactory::get(
     const String & name, const DataTypes & argument_types, const Array & parameters, AggregateFunctionProperties & out_properties) const
 {
-    auto type_without_low_cardinality = convertLowCardinalityTypesToNested(argument_types);
+    auto types_without_low_cardinality = convertLowCardinalityTypesToNested(argument_types);
 
     /// If one of the types is Nullable, we apply aggregate function combinator "Null".
 
-    if (std::any_of(type_without_low_cardinality.begin(), type_without_low_cardinality.end(),
+    if (std::any_of(types_without_low_cardinality.begin(), types_without_low_cardinality.end(),
         [](const auto & type) { return type->isNullable(); }))
     {
         AggregateFunctionCombinatorPtr combinator = AggregateFunctionCombinatorFactory::instance().tryFindSuffix("Null");
@@ -82,10 +82,10 @@ AggregateFunctionPtr AggregateFunctionFactory::get(
             throw Exception("Logical error: cannot find aggregate function combinator to apply a function to Nullable arguments.",
                 ErrorCodes::LOGICAL_ERROR);
 
-        DataTypes nested_types = combinator->transformArguments(type_without_low_cardinality);
+        DataTypes nested_types = combinator->transformArguments(types_without_low_cardinality);
         Array nested_parameters = combinator->transformParameters(parameters);
 
-        bool has_null_arguments = std::any_of(type_without_low_cardinality.begin(), type_without_low_cardinality.end(),
+        bool has_null_arguments = std::any_of(types_without_low_cardinality.begin(), types_without_low_cardinality.end(),
             [](const auto & type) { return type->onlyNull(); });
 
         AggregateFunctionPtr nested_function = getImpl(
@@ -97,13 +97,10 @@ AggregateFunctionPtr AggregateFunctionFactory::get(
         // that are rewritten to AggregateFunctionNothing, in this case
         // nested_function is nullptr.
         if (!nested_function || !nested_function->isOnlyWindowFunction())
-        {
-            return combinator->transformAggregateFunction(nested_function,
-                out_properties, type_without_low_cardinality, parameters);
-        }
+            return combinator->transformAggregateFunction(nested_function, out_properties, types_without_low_cardinality, parameters);
     }
 
-    auto with_original_arguments = getImpl(name, type_without_low_cardinality, parameters, out_properties, false);
+    auto with_original_arguments = getImpl(name, types_without_low_cardinality, parameters, out_properties, false);
 
     if (!with_original_arguments)
         throw Exception("Logical error: AggregateFunctionFactory returned nullptr", ErrorCodes::LOGICAL_ERROR);
diff --git a/src/AggregateFunctions/AggregateFunctionIf.cpp b/src/AggregateFunctions/AggregateFunctionIf.cpp
index d752900c0187..5ba54ff8505f 100644
--- a/src/AggregateFunctions/AggregateFunctionIf.cpp
+++ b/src/AggregateFunctions/AggregateFunctionIf.cpp
@@ -40,28 +40,6 @@ class AggregateFunctionCombinatorIf final : public IAggregateFunctionCombinator
     }
 };
 
-/** Given an array of flags, checks if it's all zeros
- *  When the buffer is all zeros, this is slightly faster than doing a memcmp since doesn't require allocating memory
- *  When the buffer has values, this is much faster since it avoids visiting all memory (and the allocation and function calls)
- */
-static bool ALWAYS_INLINE inline is_all_zeros(const UInt8 * flags, size_t size)
-{
-    size_t unroll_size = size - size % 8;
-    size_t i = 0;
-    while (i < unroll_size)
-    {
-        UInt64 v = *reinterpret_cast<const UInt64 *>(&flags[i]);
-        if (v)
-            return false;
-        i += 8;
-    }
-
-    for (; i < size; ++i)
-        if (flags[i])
-            return false;
-
-    return true;
-}
 
 /** There are two cases: for single argument and variadic.
   * Code for single argument is much more efficient.
@@ -73,6 +51,7 @@ class AggregateFunctionIfNullUnary final
 {
 private:
     size_t num_arguments;
+    bool filter_is_nullable = false;
 
     /// The name of the nested function, including combinators (i.e. *If)
     ///
@@ -92,8 +71,26 @@ class AggregateFunctionIfNullUnary final
 
     using Base = AggregateFunctionNullBase<result_is_nullable, serialize_flag,
         AggregateFunctionIfNullUnary<result_is_nullable, serialize_flag>>;
-public:
 
+    inline bool singleFilter(const IColumn ** columns, size_t row_num, size_t num_arguments) const
+    {
+        const IColumn * filter_column = columns[num_arguments - 1];
+
+        if (filter_is_nullable)
+        {
+            const ColumnNullable * nullable_column = assert_cast<const ColumnNullable *>(filter_column);
+            filter_column = nullable_column->getNestedColumnPtr().get();
+            const UInt8 * filter_null_map = nullable_column->getNullMapData().data();
+
+            return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num] && !filter_null_map[row_num];
+        }
+        else
+        {
+            return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num];
+        }
+    }
+
+public:
     String getName() const override
     {
         return name;
@@ -105,17 +102,10 @@ class AggregateFunctionIfNullUnary final
         , name(name_)
     {
         if (num_arguments == 0)
-            throw Exception("Aggregate function " + getName() + " require at least one argument",
-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
-    }
+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Aggregate function {} require at least one argument", getName());
 
-    static inline bool singleFilter(const IColumn ** columns, size_t row_num, size_t num_arguments)
-    {
-        const IColumn * filter_column = columns[num_arguments - 1];
-        if (const ColumnNullable * nullable_column = typeid_cast<const ColumnNullable *>(filter_column))
-            filter_column = nullable_column->getNestedColumnPtr().get();
-
-        return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num];
+        filter_is_nullable = arguments[num_arguments - 1]->isNullable();
     }
 
     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena * arena) const override
@@ -136,29 +126,41 @@ class AggregateFunctionIfNullUnary final
         const IColumn * columns_param[] = {&column->getNestedColumn()};
 
         const IColumn * filter_column = columns[num_arguments - 1];
-        if (const ColumnNullable * nullable_column = typeid_cast<const ColumnNullable *>(filter_column))
-            filter_column = nullable_column->getNestedColumnPtr().get();
-        if constexpr (result_is_nullable)
+
+        const UInt8 * filter_values = nullptr;
+        const UInt8 * filter_null_map = nullptr;
+
+        if (filter_is_nullable)
         {
-            /// We need to check if there is work to do as otherwise setting the flag would be a mistake,
-            /// it would mean that the return value would be the default value of the nested type instead of NULL
-            if (is_all_zeros(assert_cast<const ColumnUInt8 *>(filter_column)->getData().data(), batch_size))
-                return;
+            const ColumnNullable * nullable_column = assert_cast<const ColumnNullable *>(filter_column);
+            filter_column = nullable_column->getNestedColumnPtr().get();
+            filter_null_map = nullable_column->getNullMapData().data();
         }
 
+        filter_values = assert_cast<const ColumnUInt8 *>(filter_column)->getData().data();
+
         /// Combine the 2 flag arrays so we can call a simplified version (one check vs 2)
         /// Note that now the null map will contain 0 if not null and not filtered, or 1 for null or filtered (or both)
-        const auto * filter_flags = assert_cast<const ColumnUInt8 *>(filter_column)->getData().data();
+
         auto final_nulls = std::make_unique<UInt8[]>(batch_size);
-        for (size_t i = 0; i < batch_size; ++i)
-            final_nulls[i] = (!!null_map[i]) | (!filter_flags[i]);
 
-        this->nested_function->addBatchSinglePlaceNotNull(
-            batch_size, this->nestedPlace(place), columns_param, final_nulls.get(), arena, -1);
+        if (filter_null_map)
+            for (size_t i = 0; i < batch_size; ++i)
+                final_nulls[i] = (!!null_map[i]) | (!filter_values[i]) | (!!filter_null_map[i]);
+        else
+            for (size_t i = 0; i < batch_size; ++i)
+                final_nulls[i] = (!!null_map[i]) | (!filter_values[i]);
 
         if constexpr (result_is_nullable)
-            if (!memoryIsByte(null_map, batch_size, 1))
+        {
+            if (!memoryIsByte(final_nulls.get(), batch_size, 1))
                 this->setFlag(place);
+            else
+                return; /// No work to do.
+        }
+
+        this->nested_function->addBatchSinglePlaceNotNull(
+            batch_size, this->nestedPlace(place), columns_param, final_nulls.get(), arena, -1);
     }
 
 #if USE_EMBEDDED_COMPILER
@@ -367,10 +369,14 @@ AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(
     const AggregateFunctionPtr & nested_function, const DataTypes & arguments,
     const Array & params, const AggregateFunctionProperties & properties) const
 {
-    bool return_type_is_nullable = !properties.returns_default_when_only_null && getReturnType()->canBeInsideNullable();
-    size_t nullable_size = std::count_if(arguments.begin(), arguments.end(), [](const auto & element) { return element->isNullable(); });
-    return_type_is_nullable &= nullable_size != 1 || !arguments.back()->isNullable();   /// If only condition is nullable. we should non-nullable type.
-    bool serialize_flag = return_type_is_nullable || properties.returns_default_when_only_null;
+    assert(!arguments.empty());
+
+    /// Nullability of the last argument (condition) does not affect the nullability of the result (NULL is processed as false).
+    /// For other arguments it is as usual (at least one is NULL then the result is NULL if possible).
+    bool return_type_is_nullable = !properties.returns_default_when_only_null && getReturnType()->canBeInsideNullable()
+        && std::any_of(arguments.begin(), arguments.end() - 1, [](const auto & element) { return element->isNullable(); });
+
+    bool need_to_serialize_flag = return_type_is_nullable || properties.returns_default_when_only_null;
 
     if (arguments.size() <= 2 && arguments.front()->isNullable())
     {
@@ -380,7 +386,7 @@ AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(
         }
         else
         {
-            if (serialize_flag)
+            if (need_to_serialize_flag)
                 return std::make_shared<AggregateFunctionIfNullUnary<false, true>>(nested_function->getName(), nested_func, arguments, params);
             else
                 return std::make_shared<AggregateFunctionIfNullUnary<false, false>>(nested_function->getName(), nested_func, arguments, params);
@@ -394,7 +400,7 @@ AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(
         }
         else
         {
-            if (serialize_flag)
+            if (need_to_serialize_flag)
                 return std::make_shared<AggregateFunctionIfNullVariadic<false, true, true>>(nested_function, arguments, params);
             else
                 return std::make_shared<AggregateFunctionIfNullVariadic<false, false, true>>(nested_function, arguments, params);
