{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 20392,
  "instance_id": "ClickHouse__ClickHouse-20392",
  "issue_numbers": [
    "19856"
  ],
  "base_commit": "6ec19b26322970d05eb268c16974ef56e7f24999",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 8afc08da21ad..d3e776958201 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -518,6 +518,7 @@ class IColumn;\n     M(Bool, output_format_write_statistics, true, \"Write statistics about read rows, bytes, time elapsed in suitable output formats.\", 0) \\\n     M(Bool, output_format_pretty_row_numbers, false, \"Add row numbers before each row for pretty output format\", 0) \\\n     M(Bool, insert_distributed_one_random_shard, false, \"If setting is enabled, inserting into distributed table will choose a random shard to write when there is no sharding key\", 0) \\\n+    M(Bool, cross_to_inner_join_rewrite, true, \"Use inner join instead of comma/cross join if possible\", 0) \\\n \n \n // End of FORMAT_FACTORY_SETTINGS\ndiff --git a/src/Interpreters/CrossToInnerJoinVisitor.cpp b/src/Interpreters/CrossToInnerJoinVisitor.cpp\nindex 604bfc7774f9..c4d330831bba 100644\n--- a/src/Interpreters/CrossToInnerJoinVisitor.cpp\n+++ b/src/Interpreters/CrossToInnerJoinVisitor.cpp\n@@ -1,20 +1,21 @@\n #include <Common/typeid_cast.h>\n #include <Functions/FunctionsComparison.h>\n #include <Functions/FunctionsLogical.h>\n+#include <IO/WriteHelpers.h>\n #include <Interpreters/CrossToInnerJoinVisitor.h>\n #include <Interpreters/DatabaseAndTableWithAlias.h>\n #include <Interpreters/IdentifierSemantic.h>\n #include <Interpreters/misc.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTExpressionList.h>\n-#include <Parsers/ParserTablesInSelectQuery.h>\n #include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n #include <Parsers/parseQuery.h>\n-#include <IO/WriteHelpers.h>\n \n namespace DB\n {\n@@ -80,147 +81,150 @@ struct JoinedElement\n     ASTTableJoin * join = nullptr;\n };\n \n-bool isComparison(const String & name)\n-{\n-    return name == NameEquals::name ||\n-        name == NameNotEquals::name ||\n-        name == NameLess::name ||\n-        name == NameGreater::name ||\n-        name == NameLessOrEquals::name ||\n-        name == NameGreaterOrEquals::name;\n-}\n-\n-/// It checks if where expression could be moved to JOIN ON expression partially or entirely.\n-class CheckExpressionVisitorData\n+/// Collect all identifiers from ast\n+class IdentifiersCollector\n {\n public:\n-    using TypeToVisit = const ASTFunction;\n-\n-    CheckExpressionVisitorData(const std::vector<JoinedElement> & tables_,\n-                               const std::vector<TableWithColumnNamesAndTypes> & tables_with_columns,\n-                               const Aliases & aliases_)\n-        : joined_tables(tables_)\n-        , tables(tables_with_columns)\n-        , aliases(aliases_)\n-        , ands_only(true)\n-    {}\n-\n-    void visit(const ASTFunction & node, const ASTPtr & ast)\n+    using ASTIdentPtr = const ASTIdentifier *;\n+    using ASTIdentifiers = std::vector<ASTIdentPtr>;\n+    struct Data\n     {\n-        if (!ands_only)\n-            return;\n-\n-        if (node.name == NameAnd::name)\n-        {\n-            if (!node.arguments || node.arguments->children.empty())\n-                throw Exception(\"Logical error: function requires argument\", ErrorCodes::LOGICAL_ERROR);\n+        ASTIdentifiers idents;\n+    };\n \n-            for (auto & child : node.arguments->children)\n-            {\n-                if (const auto * func = child->as<ASTFunction>())\n-                    visit(*func, child);\n-                else\n-                    ands_only = false;\n-            }\n-        }\n-        else if (node.name == NameEquals::name)\n-        {\n-            if (size_t min_table = canMoveEqualsToJoinOn(node))\n-                asts_to_join_on[min_table].push_back(ast);\n-        }\n-        else if (isComparison(node.name))\n-        {\n-            /// leave other comparisons as is\n-        }\n-        else if (functionIsLikeOperator(node.name) || /// LIKE, NOT LIKE, ILIKE, NOT ILIKE\n-                 functionIsInOperator(node.name))  /// IN, NOT IN\n-        {\n-            /// leave as is. It's not possible to make push down here cause of unknown aliases and not implemented JOIN predicates.\n-            ///     select a as b form t1, t2 where t1.x = t2.x and b in(42)\n-            ///     select a as b form t1 inner join t2 on t1.x = t2.x and b in(42)\n-        }\n-        else\n-        {\n-            ands_only = false;\n-            asts_to_join_on.clear();\n-        }\n+    static void visit(const ASTPtr & node, Data & data)\n+    {\n+        if (const auto * ident = node->as<ASTIdentifier>())\n+            data.idents.push_back(ident);\n     }\n \n-    bool complex() const { return !ands_only; }\n-    bool matchAny(size_t t) const { return asts_to_join_on.count(t); }\n-\n-    ASTPtr makeOnExpression(size_t table_pos)\n+    static bool needChildVisit(const ASTPtr &, const ASTPtr &)\n     {\n-        if (!asts_to_join_on.count(table_pos))\n-            return {};\n-\n-        std::vector<ASTPtr> & expressions = asts_to_join_on[table_pos];\n-\n-        if (expressions.size() == 1)\n-            return expressions[0]->clone();\n+        return true;\n+    }\n \n-        std::vector<ASTPtr> arguments;\n-        arguments.reserve(expressions.size());\n-        for (auto & ast : expressions)\n-            arguments.emplace_back(ast->clone());\n+    static ASTIdentifiers collect(const ASTPtr & node)\n+    {\n+        IdentifiersCollector::Data ident_data;\n+        ConstInDepthNodeVisitor<IdentifiersCollector, true> ident_visitor(ident_data);\n+        ident_visitor.visit(node);\n+        return ident_data.idents;\n+    }\n+};\n \n-        return makeASTFunction(NameAnd::name, std::move(arguments));\n+/// Split expression `expr_1 AND expr_2 AND ... AND expr_n` into vector `[expr_1, expr_2, ..., expr_n]`\n+void collectConjunctions(const ASTPtr & node, std::vector<ASTPtr> & members)\n+{\n+    if (const auto * func = node->as<ASTFunction>(); func && func->name == NameAnd::name)\n+    {\n+        for (const auto & child : func->arguments->children)\n+            collectConjunctions(child, members);\n+        return;\n     }\n+    members.push_back(node);\n+}\n \n-private:\n-    const std::vector<JoinedElement> & joined_tables;\n-    const std::vector<TableWithColumnNamesAndTypes> & tables;\n-    std::map<size_t, std::vector<ASTPtr>> asts_to_join_on;\n-    const Aliases & aliases;\n-    bool ands_only;\n+std::vector<ASTPtr> collectConjunctions(const ASTPtr & node)\n+{\n+    std::vector<ASTPtr> members;\n+    collectConjunctions(node, members);\n+    return members;\n+}\n \n-    size_t canMoveEqualsToJoinOn(const ASTFunction & node)\n-    {\n-        if (!node.arguments)\n-            throw Exception(\"Logical error: function requires arguments\", ErrorCodes::LOGICAL_ERROR);\n-        if (node.arguments->children.size() != 2)\n-            return false;\n+std::optional<size_t> getIdentMembership(const ASTIdentifier & ident, const std::vector<TableWithColumnNamesAndTypes> & tables)\n+{\n+    std::optional<size_t> table_pos = IdentifierSemantic::getMembership(ident);\n+    if (table_pos)\n+        return table_pos;\n+    return IdentifierSemantic::chooseTableColumnMatch(ident, tables);\n+}\n \n-        const auto * left = node.arguments->children[0]->as<ASTIdentifier>();\n-        const auto * right = node.arguments->children[1]->as<ASTIdentifier>();\n-        if (!left || !right)\n-            return false;\n+std::optional<size_t> getIdentsMembership(const ASTPtr ast,\n+                                          const std::vector<TableWithColumnNamesAndTypes> & tables,\n+                                          const Aliases & aliases)\n+{\n+    auto idents = IdentifiersCollector::collect(ast);\n \n+    std::optional<size_t> result;\n+    for (const auto * ident : idents)\n+    {\n         /// Moving expressions that use column aliases is not supported.\n-        if (left->isShort() && aliases.count(left->shortName()))\n-            return false;\n-        if (right->isShort() && aliases.count(right->shortName()))\n-            return false;\n+        if (ident->isShort() && aliases.count(ident->shortName()))\n+            return {};\n+        const auto pos = getIdentMembership(*ident, tables);\n+        if (!pos)\n+            return {};\n+        if (result && *pos != *result)\n+            return {};\n+        result = pos;\n+    }\n+    return result;\n+}\n \n-        return checkIdentifiers(*left, *right);\n+bool isAllowedToRewriteCrossJoin(const ASTPtr & node, const Aliases & aliases)\n+{\n+    if (node->as<ASTFunction>())\n+    {\n+        auto idents = IdentifiersCollector::collect(node);\n+        for (const auto * ident : idents)\n+        {\n+            if (ident->isShort() && aliases.count(ident->shortName()))\n+                return false;\n+        }\n+        return true;\n     }\n+    return node->as<ASTIdentifier>() || node->as<ASTLiteral>();\n+}\n \n-    /// Check if the identifiers are from different joined tables. If it's a self joint, tables should have aliases.\n-    /// select * from t1 a cross join t2 b where a.x = b.x\n-    /// @return table position to attach expression to or 0.\n-    size_t checkIdentifiers(const ASTIdentifier & left, const ASTIdentifier & right)\n+/// Return mapping table_no -> expression with expression that can be moved into JOIN ON section\n+std::map<size_t, std::vector<ASTPtr>> moveExpressionToJoinOn(\n+    const ASTPtr & ast,\n+    const std::vector<JoinedElement> & joined_tables,\n+    const std::vector<TableWithColumnNamesAndTypes> & tables,\n+    const Aliases & aliases)\n+{\n+    std::map<size_t, std::vector<ASTPtr>> asts_to_join_on;\n+    for (const auto & node : collectConjunctions(ast))\n     {\n-        std::optional<size_t> left_table_pos = IdentifierSemantic::getMembership(left);\n-        if (!left_table_pos)\n-            left_table_pos = IdentifierSemantic::chooseTableColumnMatch(left, tables);\n+        if (const auto * func = node->as<ASTFunction>(); func && func->name == NameEquals::name)\n+        {\n+            if (!func->arguments || func->arguments->children.size() != 2)\n+                return {};\n \n-        std::optional<size_t> right_table_pos = IdentifierSemantic::getMembership(right);\n-        if (!right_table_pos)\n-            right_table_pos = IdentifierSemantic::chooseTableColumnMatch(right, tables);\n+            /// Check if the identifiers are from different joined tables.\n+            /// If it's a self joint, tables should have aliases.\n+            auto left_table_pos = getIdentsMembership(func->arguments->children[0], tables, aliases);\n+            auto right_table_pos = getIdentsMembership(func->arguments->children[1], tables, aliases);\n \n-        if (left_table_pos && right_table_pos && (*left_table_pos != *right_table_pos))\n-        {\n-            size_t table_pos = std::max(*left_table_pos, *right_table_pos);\n-            if (joined_tables[table_pos].canAttachOnExpression())\n-                return table_pos;\n+            /// Identifiers from different table move to JOIN ON\n+            if (left_table_pos && right_table_pos && *left_table_pos != *right_table_pos)\n+            {\n+                size_t table_pos = std::max(*left_table_pos, *right_table_pos);\n+                if (joined_tables[table_pos].canAttachOnExpression())\n+                    asts_to_join_on[table_pos].push_back(node);\n+                else\n+                    return {};\n+            }\n         }\n-        return 0;\n+\n+        if (!isAllowedToRewriteCrossJoin(node, aliases))\n+            return {};\n     }\n-};\n+    return asts_to_join_on;\n+}\n+\n+ASTPtr makeOnExpression(const std::vector<ASTPtr> & expressions)\n+{\n+    if (expressions.size() == 1)\n+        return expressions[0]->clone();\n \n-using CheckExpressionMatcher = ConstOneTypeMatcher<CheckExpressionVisitorData, NeedChild::none>;\n-using CheckExpressionVisitor = ConstInDepthNodeVisitor<CheckExpressionMatcher, true>;\n+    std::vector<ASTPtr> arguments;\n+    arguments.reserve(expressions.size());\n+    for (const auto & ast : expressions)\n+        arguments.emplace_back(ast->clone());\n \n+    return makeASTFunction(NameAnd::name, std::move(arguments));\n+}\n \n bool getTables(ASTSelectQuery & select, std::vector<JoinedElement> & joined_tables, size_t & num_comma)\n {\n@@ -320,7 +324,6 @@ void CrossToInnerJoinMatcher::visit(ASTSelectQuery & select, ASTPtr &, Data & da\n     }\n \n     /// COMMA to CROSS\n-\n     if (num_comma)\n     {\n         for (auto & table : joined_tables)\n@@ -328,22 +331,17 @@ void CrossToInnerJoinMatcher::visit(ASTSelectQuery & select, ASTPtr &, Data & da\n     }\n \n     /// CROSS to INNER\n-\n-    if (!select.where())\n-        return;\n-\n-    CheckExpressionVisitor::Data visitor_data{joined_tables, data.tables_with_columns, data.aliases};\n-    CheckExpressionVisitor(visitor_data).visit(select.where());\n-\n-    if (visitor_data.complex())\n-        return;\n-\n-    for (size_t i = 1; i < joined_tables.size(); ++i)\n+    if (data.cross_to_inner_join_rewrite && select.where())\n     {\n-        if (visitor_data.matchAny(i))\n+        auto asts_to_join_on = moveExpressionToJoinOn(select.where(), joined_tables, data.tables_with_columns, data.aliases);\n+        for (size_t i = 1; i < joined_tables.size(); ++i)\n         {\n-            if (joined_tables[i].rewriteCrossToInner(visitor_data.makeOnExpression(i)))\n-                data.done = true;\n+            const auto & expr_it = asts_to_join_on.find(i);\n+            if (expr_it != asts_to_join_on.end())\n+            {\n+                if (joined_tables[i].rewriteCrossToInner(makeOnExpression(expr_it->second)))\n+                    data.done = true;\n+            }\n         }\n     }\n }\ndiff --git a/src/Interpreters/CrossToInnerJoinVisitor.h b/src/Interpreters/CrossToInnerJoinVisitor.h\nindex 7cd5c93b1e38..885cf8162c10 100644\n--- a/src/Interpreters/CrossToInnerJoinVisitor.h\n+++ b/src/Interpreters/CrossToInnerJoinVisitor.h\n@@ -19,6 +19,7 @@ class CrossToInnerJoinMatcher\n         const Aliases & aliases;\n         const String current_database;\n         bool done = false;\n+        bool cross_to_inner_join_rewrite = true;\n     };\n \n     static bool needChildVisit(ASTPtr &, const ASTPtr &);\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 341af15cd246..d0c8966cf077 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -204,7 +204,7 @@ static Context getSubqueryContext(const Context & context)\n     return subquery_context;\n }\n \n-static void rewriteMultipleJoins(ASTPtr & query, const TablesWithColumns & tables, const String & database)\n+static void rewriteMultipleJoins(ASTPtr & query, const TablesWithColumns & tables, const String & database, const Settings & settings)\n {\n     ASTSelectQuery & select = query->as<ASTSelectQuery &>();\n \n@@ -214,6 +214,7 @@ static void rewriteMultipleJoins(ASTPtr & query, const TablesWithColumns & table\n     QueryAliasesNoSubqueriesVisitor(aliases).visit(select.select());\n \n     CrossToInnerJoinVisitor::Data cross_to_inner{tables, aliases, database};\n+    cross_to_inner.cross_to_inner_join_rewrite = settings.cross_to_inner_join_rewrite;\n     CrossToInnerJoinVisitor(cross_to_inner).visit(query);\n \n     JoinToSubqueryTransformVisitor::Data join_to_subs_data{tables, aliases};\n@@ -331,7 +332,7 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n     /// Rewrite JOINs\n     if (!has_input && joined_tables.tablesCount() > 1)\n     {\n-        rewriteMultipleJoins(query_ptr, joined_tables.tablesWithColumns(), context->getCurrentDatabase());\n+        rewriteMultipleJoins(query_ptr, joined_tables.tablesWithColumns(), context->getCurrentDatabase(), context->getSettingsRef());\n \n         joined_tables.reset(getSelectQuery());\n         joined_tables.resolveTables();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00826_cross_to_inner_join.reference b/tests/queries/0_stateless/00826_cross_to_inner_join.reference\nindex 84867de28495..9b630d0d3919 100644\n--- a/tests/queries/0_stateless/00826_cross_to_inner_join.reference\n+++ b/tests/queries/0_stateless/00826_cross_to_inner_join.reference\n@@ -1,18 +1,18 @@\n 0\t0\n-cross\n+--- cross ---\n 1\t1\t1\t1\n 1\t1\t1\t2\n 2\t2\t2\t\\N\n-cross nullable\n+--- cross nullable ---\n 1\t1\t1\t1\n 2\t2\t1\t2\n-cross nullable vs not nullable\n+--- cross nullable vs not nullable ---\n 1\t1\t1\t1\n 2\t2\t1\t2\n-cross self\n+--- cross self ---\n 1\t1\t1\t1\n 2\t2\t2\t2\n-cross one table expr\n+--- cross one table expr ---\n 1\t1\t1\t1\n 1\t1\t1\t2\n 1\t1\t2\t\\N\n@@ -21,20 +21,34 @@ cross one table expr\n 2\t2\t1\t2\n 2\t2\t2\t\\N\n 2\t2\t3\t\\N\n-cross multiple ands\n+--- cross multiple ands ---\n 1\t1\t1\t1\n-cross and inside and\n+--- cross and inside and ---\n 1\t1\t1\t1\n-cross split conjunction\n+--- cross split conjunction ---\n 1\t1\t1\t1\n-comma\n+--- and or ---\n+1\t1\t1\t1\n+--- arithmetic expr ---\n+2\t2\t1\t2\n+--- is null or ---\n+1\t1\t1\t2\n+2\t2\t2\t\\N\n+--- do not rewrite alias ---\n+1\n+1\n+2\n+--- comma ---\n 1\t1\t1\t1\n 1\t1\t1\t2\n 2\t2\t2\t\\N\n-comma nullable\n+--- comma nullable ---\n 1\t1\t1\t1\n 2\t2\t1\t2\n-cross\n+--- comma and or ---\n+1\t1\t1\t1\n+2\t2\t2\t\\N\n+--- cross ---\n SELECT\n     a,\n     b,\n@@ -43,7 +57,7 @@ SELECT\n FROM t1_00826\n ALL INNER JOIN t2_00826 ON a = t2_00826.a\n WHERE a = t2_00826.a\n-cross nullable\n+--- cross nullable ---\n SELECT\n     a,\n     b,\n@@ -52,7 +66,7 @@ SELECT\n FROM t1_00826\n ALL INNER JOIN t2_00826 ON a = t2_00826.a\n WHERE a = t2_00826.a\n-cross nullable vs not nullable\n+--- cross nullable vs not nullable ---\n SELECT\n     a,\n     b,\n@@ -61,7 +75,7 @@ SELECT\n FROM t1_00826\n ALL INNER JOIN t2_00826 ON a = t2_00826.b\n WHERE a = t2_00826.b\n-cross self\n+--- cross self ---\n SELECT\n     a,\n     b,\n@@ -70,7 +84,7 @@ SELECT\n FROM t1_00826 AS x\n ALL INNER JOIN t1_00826 AS y ON (a = y.a) AND (b = y.b)\n WHERE (a = y.a) AND (b = y.b)\n-cross one table expr\n+--- cross one table expr ---\n SELECT\n     a,\n     b,\n@@ -79,7 +93,7 @@ SELECT\n FROM t1_00826\n CROSS JOIN t2_00826\n WHERE a = b\n-cross multiple ands\n+--- cross multiple ands ---\n SELECT\n     a,\n     b,\n@@ -88,7 +102,7 @@ SELECT\n FROM t1_00826\n ALL INNER JOIN t2_00826 ON (a = t2_00826.a) AND (b = t2_00826.b)\n WHERE (a = t2_00826.a) AND (b = t2_00826.b)\n-cross and inside and\n+--- cross and inside and ---\n SELECT\n     a,\n     b,\n@@ -97,7 +111,7 @@ SELECT\n FROM t1_00826\n ALL INNER JOIN t2_00826 ON (((a = t2_00826.a) AND (a = t2_00826.a)) AND (a = t2_00826.a)) AND (b = t2_00826.b)\n WHERE (a = t2_00826.a) AND ((a = t2_00826.a) AND ((a = t2_00826.a) AND (b = t2_00826.b)))\n-cross split conjunction\n+--- cross split conjunction ---\n SELECT\n     a,\n     b,\n@@ -106,3 +120,62 @@ SELECT\n FROM t1_00826\n ALL INNER JOIN t2_00826 ON (a = t2_00826.a) AND (b = t2_00826.b)\n WHERE (a = t2_00826.a) AND (b = t2_00826.b) AND (a >= 1) AND (t2_00826.b > 0)\n+--- and or ---\n+SELECT\n+    a,\n+    b,\n+    t2_00826.a,\n+    t2_00826.b\n+FROM t1_00826\n+ALL INNER JOIN t2_00826 ON (a = t2_00826.a) AND (b = t2_00826.b)\n+WHERE (a = t2_00826.a) AND (b = t2_00826.b) AND ((a >= 1) OR (t2_00826.b = 1))\n+--- arithmetic expr ---\n+SELECT\n+    a,\n+    b,\n+    t2_00826.a,\n+    t2_00826.b\n+FROM t1_00826\n+ALL INNER JOIN t2_00826 ON (a + 1) = (t2_00826.a + t2_00826.b)\n+WHERE ((a + 1) = (t2_00826.a + t2_00826.b)) AND ((((a + b) + t2_00826.a) + t2_00826.b) > 5)\n+--- is null or ---\n+SELECT\n+    a,\n+    b,\n+    t2_00826.a,\n+    t2_00826.b\n+FROM t1_00826\n+ALL INNER JOIN t2_00826 ON b = t2_00826.a\n+WHERE (b = t2_00826.a) AND (isNull(t2_00826.b) OR (t2_00826.b > t2_00826.a))\n+--- do not rewrite alias ---\n+SELECT a AS b\n+FROM t1_00826\n+CROSS JOIN t2_00826\n+WHERE (b = t2_00826.a) AND (b > 0)\n+--- comma ---\n+SELECT\n+    a,\n+    b,\n+    t2_00826.a,\n+    t2_00826.b\n+FROM t1_00826\n+ALL INNER JOIN t2_00826 ON a = t2_00826.a\n+WHERE a = t2_00826.a\n+--- comma nullable ---\n+SELECT\n+    a,\n+    b,\n+    t2_00826.a,\n+    t2_00826.b\n+FROM t1_00826\n+ALL INNER JOIN t2_00826 ON b = t2_00826.b\n+WHERE b = t2_00826.b\n+--- comma and or ---\n+SELECT\n+    a,\n+    b,\n+    t2_00826.a,\n+    t2_00826.b\n+FROM t1_00826\n+ALL INNER JOIN t2_00826 ON a = t2_00826.a\n+WHERE (a = t2_00826.a) AND (isNull(t2_00826.b) OR (t2_00826.b < 2))\ndiff --git a/tests/queries/0_stateless/00826_cross_to_inner_join.sql b/tests/queries/0_stateless/00826_cross_to_inner_join.sql\nindex 674718646866..392ade02ab78 100644\n--- a/tests/queries/0_stateless/00826_cross_to_inner_join.sql\n+++ b/tests/queries/0_stateless/00826_cross_to_inner_join.sql\n@@ -12,46 +12,79 @@ INSERT INTO t1_00826 values (1,1), (2,2);\n INSERT INTO t2_00826 values (1,1), (1,2);\n INSERT INTO t2_00826 (a) values (2), (3);\n \n-SELECT 'cross';\n+SELECT '--- cross ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a;\n-SELECT 'cross nullable';\n+SELECT '--- cross nullable ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.b = t2_00826.b;\n-SELECT 'cross nullable vs not nullable';\n+SELECT '--- cross nullable vs not nullable ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.b;\n-SELECT 'cross self';\n+SELECT '--- cross self ---';\n SELECT * FROM t1_00826 x cross join t1_00826 y where x.a = y.a and x.b = y.b;\n-SELECT 'cross one table expr';\n+SELECT '--- cross one table expr ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t1_00826.b order by (t1_00826.a, t2_00826.a, t2_00826.b);\n-SELECT 'cross multiple ands';\n+SELECT '--- cross multiple ands ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b;\n-SELECT 'cross and inside and';\n+SELECT '--- cross and inside and ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and (t1_00826.b = t2_00826.b and 1);\n-SELECT 'cross split conjunction';\n+SELECT '--- cross split conjunction ---';\n SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b and t1_00826.a >= 1 and t2_00826.b = 1;\n \n-SELECT 'comma';\n+SELECT '--- and or ---';\n+SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b and (t1_00826.a >= 1 OR t2_00826.b = 1);\n+\n+SELECT '--- arithmetic expr ---';\n+SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a + 1 = t2_00826.a + t2_00826.b AND (t1_00826.a + t1_00826.b + t2_00826.a + t2_00826.b > 5);\n+\n+SELECT '--- is null or ---';\n+SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.b = t2_00826.a AND (t2_00826.b IS NULL OR t2_00826.b > t2_00826.a);\n+\n+SELECT '--- do not rewrite alias ---';\n+SELECT a as b FROM t1_00826 cross join t2_00826 where t1_00826.b = t2_00826.a AND b > 0;\n+\n+SELECT '--- comma ---';\n SELECT * FROM t1_00826, t2_00826 where t1_00826.a = t2_00826.a;\n-SELECT 'comma nullable';\n+SELECT '--- comma nullable ---';\n SELECT * FROM t1_00826, t2_00826 where t1_00826.b = t2_00826.b;\n+SELECT '--- comma and or ---';\n+SELECT * FROM t1_00826, t2_00826 where t1_00826.a = t2_00826.a AND (t2_00826.b IS NULL OR t2_00826.b < 2);\n \n \n-SELECT 'cross';\n+SELECT '--- cross ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a;\n-SELECT 'cross nullable';\n+SELECT '--- cross nullable ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826, t2_00826 where t1_00826.a = t2_00826.a;\n-SELECT 'cross nullable vs not nullable';\n+SELECT '--- cross nullable vs not nullable ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.b;\n-SELECT 'cross self';\n+SELECT '--- cross self ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 x cross join t1_00826 y where x.a = y.a and x.b = y.b;\n-SELECT 'cross one table expr';\n+SELECT '--- cross one table expr ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t1_00826.b;\n-SELECT 'cross multiple ands';\n+SELECT '--- cross multiple ands ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b;\n-SELECT 'cross and inside and';\n+SELECT '--- cross and inside and ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and (t1_00826.a = t2_00826.a and (t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b));\n \n-SELECT 'cross split conjunction';\n+SELECT '--- cross split conjunction ---';\n EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b and t1_00826.a >= 1 and t2_00826.b > 0;\n \n+SELECT '--- and or ---';\n+EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a = t2_00826.a and t1_00826.b = t2_00826.b and (t1_00826.a >= 1 OR t2_00826.b = 1);\n+\n+SELECT '--- arithmetic expr ---';\n+EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.a + 1 = t2_00826.a + t2_00826.b AND (t1_00826.a + t1_00826.b + t2_00826.a + t2_00826.b > 5);\n+\n+SELECT '--- is null or ---';\n+EXPLAIN SYNTAX SELECT * FROM t1_00826 cross join t2_00826 where t1_00826.b = t2_00826.a AND (t2_00826.b IS NULL OR t2_00826.b > t2_00826.a);\n+\n+SELECT '--- do not rewrite alias ---';\n+EXPLAIN SYNTAX SELECT a as b FROM t1_00826 cross join t2_00826 where t1_00826.b = t2_00826.a AND b > 0;\n+\n+SELECT '--- comma ---';\n+EXPLAIN SYNTAX SELECT * FROM t1_00826, t2_00826 where t1_00826.a = t2_00826.a;\n+SELECT '--- comma nullable ---';\n+EXPLAIN SYNTAX SELECT * FROM t1_00826, t2_00826 where t1_00826.b = t2_00826.b;\n+SELECT '--- comma and or ---';\n+EXPLAIN SYNTAX SELECT * FROM t1_00826, t2_00826 where t1_00826.a = t2_00826.a AND (t2_00826.b IS NULL OR t2_00826.b < 2);\n+\n DROP TABLE t1_00826;\n DROP TABLE t2_00826;\n",
  "problem_statement": "AND (cond OR cond) prevent CROSS JOIN to INNER JOIN rewrite\n**Describe the bug**\r\nIt's possible to rewrite CROSS JOIN TO INNER JOIN in certain conditions, but clickhouse doesn't do that when we have ```AND (cond OR cond)``` in WHERE clause.\r\n\r\n**Does it reproduce on recent release?**\r\nYes\r\n\r\n**How to reproduce**\r\nClickhouse version 21.2\r\n\r\n```\r\nEXPLAIN SYNTAX\r\nWITH tbl AS\r\n    (\r\n        SELECT *\r\n        FROM numbers(1000)\r\n    )\r\nSELECT count(x.number)\r\nFROM tbl AS x\r\n, tbl AS z\r\nWHERE x.number = z.number\r\n\r\nQuery id: ea50c6a4-618d-4f87-a089-01ef2ba956fe\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 WITH tbl AS                                  \u2502\r\n\u2502     (                                        \u2502\r\n\u2502         SELECT *                             \u2502\r\n\u2502         FROM numbers(1000)                   \u2502\r\n\u2502     )                                        \u2502\r\n\u2502 SELECT count(number)                         \u2502\r\n\u2502 FROM tbl AS x                                \u2502\r\n\u2502 ALL INNER JOIN tbl AS z ON number = z.number \u2502\r\n\u2502 WHERE number = z.number                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nEXPLAIN SYNTAX\r\nWITH tbl AS\r\n    (\r\n        SELECT *\r\n        FROM numbers(1000)\r\n    )\r\nSELECT count(x.number)\r\nFROM tbl AS x\r\n, tbl AS z\r\nWHERE (x.number = z.number) AND ((x.number = 1) OR (x.number = 2))\r\n\r\nQuery id: 4f3f6e5a-f7fc-41c0-a2f2-675525e5d63e\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 WITH tbl AS                                                  \u2502\r\n\u2502     (                                                        \u2502\r\n\u2502         SELECT *                                             \u2502\r\n\u2502         FROM numbers(1000)                                   \u2502\r\n\u2502     )                                                        \u2502\r\n\u2502 SELECT count(number)                                         \u2502\r\n\u2502 FROM tbl AS x                                                \u2502\r\n\u2502 CROSS JOIN tbl AS z                                          \u2502\r\n\u2502 WHERE (number = z.number) AND ((number = 1) OR (number = 2)) \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nEXPLAIN SYNTAX\r\nWITH tbl AS\r\n    (\r\n        SELECT *\r\n        FROM numbers(1000)\r\n    )\r\nSELECT count(x.number)\r\nFROM tbl AS x\r\n, tbl AS z\r\nWHERE (x.number = z.number) AND 1\r\n\r\nQuery id: 3ba0c863-8432-441a-b04c-e06047436cbc\r\n\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 WITH tbl AS                     \u2502\r\n\u2502     (                           \u2502\r\n\u2502         SELECT *                \u2502\r\n\u2502         FROM numbers(1000)      \u2502\r\n\u2502     )                           \u2502\r\n\u2502 SELECT count(number)            \u2502\r\n\u2502 FROM tbl AS x                   \u2502\r\n\u2502 CROSS JOIN tbl AS z             \u2502\r\n\u2502 WHERE (number = z.number) AND 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\n",
  "hints_text": "Missing optimization (not a bug).",
  "created_at": "2021-02-12T14:51:12Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Interpreters/CrossToInnerJoinVisitor.cpp",
    "src/Interpreters/CrossToInnerJoinVisitor.h",
    "src/Interpreters/InterpreterSelectQuery.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00826_cross_to_inner_join.reference",
    "tests/queries/0_stateless/00826_cross_to_inner_join.sql"
  ]
}