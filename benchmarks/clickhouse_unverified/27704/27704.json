{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27704,
  "instance_id": "ClickHouse__ClickHouse-27704",
  "issue_numbers": [
    "27058"
  ],
  "base_commit": "73f3b2f15cf926371dc757c3848e867be2bfb19a",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex efd28def6883..ad6edaea312b 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -1339,3 +1339,149 @@ Result:\n \u2502 2,\"good\"                                  \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n+## snowflakeToDateTime {#snowflakeToDateTime}\n+\n+Extract time from snowflake id as DateTime format.\n+\n+**Syntax**\n+\n+``` sql\n+snowflakeToDateTime(value [, time_zone])\n+```\n+\n+**Parameters**\n+\n+-   `value` \u2014 `snowflake id`, Int64 value.\n+-   `time_zone` \u2014 [Timezone](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-timezone). The function parses `time_string` according to the timezone. Optional. [String](../../sql-reference/data-types/string.md).\n+\n+**Returned value**\n+\n+-  value converted to the `DateTime` data type.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT snowflakeToDateTime(CAST('1426860702823350272', 'Int64'), 'UTC');\n+```\n+\n+Result:\n+\n+``` text\n+\n+\u250c\u2500snowflakeToDateTime(CAST('1426860702823350272', 'Int64'), 'UTC')\u2500\u2510\n+\u2502                                              2021-08-15 10:57:56 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## snowflakeToDateTime64 {#snowflakeToDateTime64}\n+\n+Extract time from snowflake id as DateTime64 format.\n+\n+**Syntax**\n+\n+``` sql\n+snowflakeToDateTime64(value [, time_zone])\n+```\n+\n+**Parameters**\n+\n+-   `value` \u2014 `snowflake id`, Int64 value.\n+-   `time_zone` \u2014 [Timezone](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-timezone). The function parses `time_string` according to the timezone. Optional. [String](../../sql-reference/data-types/string.md).\n+\n+**Returned value**\n+\n+-  value converted to the `DateTime64` data type.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT snowflakeToDateTime64(CAST('1426860802823350272', 'Int64'), 'UTC');\n+```\n+\n+Result:\n+\n+``` text\n+\n+\u250c\u2500snowflakeToDateTime64(CAST('1426860802823350272', 'Int64'), 'UTC')\u2500\u2510\n+\u2502                                            2021-08-15 10:58:19.841 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## dateTimeToSnowflake {#dateTimeToSnowflake}\n+\n+Convert DateTime to the first snowflake id at the giving time.\n+\n+**Syntax**\n+\n+``` sql\n+dateTimeToSnowflake(value)\n+```\n+\n+**Parameters**\n+\n+-   `value` \u2014 Date and time. [DateTime](../../sql-reference/data-types/datetime.md).\n+\n+\n+**Returned value**\n+\n+-   `value` converted to the `Int64` data type as the first snowflake id at that time.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+WITH toDateTime('2021-08-15 18:57:56', 'Asia/Shanghai') AS dt\n+SELECT dateTimeToSnowflake(dt);\n+```\n+\n+Result:\n+\n+``` text\n+\n+\u250c\u2500dateTimeToSnowflake(dt)\u2500\u2510\n+\u2502     1426860702823350272 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\n+## dateTime64ToSnowflake {#dateTime64ToSnowflake}\n+\n+Convert DateTime64 to the first snowflake id at the giving time.\n+\n+**Syntax**\n+\n+``` sql\n+dateTime64ToSnowflake(value)\n+```\n+\n+**Parameters**\n+\n+-   `value` \u2014 Date and time. [DateTime64](../../sql-reference/data-types/datetime64.md).\n+\n+\n+**Returned value**\n+\n+-   `value` converted to the `Int64` data type as the first snowflake id at that time.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+WITH toDateTime64('2021-08-15 18:57:56.492', 3, 'Asia/Shanghai') AS dt64\n+SELECT dateTime64ToSnowflake(dt64);\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500dateTime64ToSnowflake(dt64)\u2500\u2510\n+\u2502         1426860704886947840 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n\\ No newline at end of file\ndiff --git a/src/Functions/FunctionSnowflake.h b/src/Functions/FunctionSnowflake.h\nnew file mode 100644\nindex 000000000000..95d02de3a2bb\n--- /dev/null\n+++ b/src/Functions/FunctionSnowflake.h\n@@ -0,0 +1,207 @@\n+#pragma once\n+\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Columns/ColumnsNumber.h>\n+\n+#include <common/arithmeticOverflow.h>\n+\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+/** According to Twitter's post on Snowflake, we can extract the timestamp for a snowflake ID by right shifting\n+ * the snowflake ID by 22 bits(10 bits machine ID and 12 bits sequence ID) and adding the Twitter epoch time of 1288834974657.\n+ * https://en.wikipedia.org/wiki/Snowflake_ID\n+ * https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake\n+ * https://ws-dl.blogspot.com/2019/08/2019-08-03-tweetedat-finding-tweet.html\n+*/\n+static constexpr long snowflake_epoch = 1288834974657L;\n+static constexpr int time_shift = 22;\n+\n+class FunctionDateTimeToSnowflake : public IFunction\n+{\n+private:\n+    const char * name;\n+\n+public:\n+    FunctionDateTimeToSnowflake(const char * name_) : name(name_) { }\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isVariadic() const override { return false; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (!isDateTime(arguments[0].type))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be DateTime\", name);\n+\n+        return std::make_shared<DataTypeInt64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto & src = arguments[0];\n+        const auto & col = *src.column;\n+\n+        auto res_column = ColumnInt64::create(input_rows_count);\n+        auto & result_data = res_column->getData();\n+\n+        const auto & source_data = typeid_cast<const ColumnUInt32 &>(col).getData();\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            result_data[i] = (Int64(source_data[i]) * 1000 - snowflake_epoch) << time_shift;\n+        }\n+\n+        return res_column;\n+    }\n+};\n+\n+\n+class FunctionSnowflakeToDateTime : public IFunction\n+{\n+private:\n+    const char * name;\n+\n+public:\n+    FunctionSnowflakeToDateTime(const char * name_) : name(name_) { }\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() < 1 || arguments.size() > 2)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} takes one or two arguments\", name);\n+\n+        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The first argument for function {} must be Int64\", name);\n+\n+        std::string timezone;\n+        if (arguments.size() == 2)\n+            timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);\n+\n+        return std::make_shared<DataTypeDateTime>(timezone);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto & src = arguments[0];\n+        const auto & col = *src.column;\n+\n+        auto res_column = ColumnUInt32::create(input_rows_count);\n+        auto & result_data = res_column->getData();\n+\n+        const auto & source_data = typeid_cast<const ColumnInt64 &>(col).getData();\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            result_data[i] = ((source_data[i] >> time_shift) + snowflake_epoch) / 1000;\n+        }\n+        return res_column;\n+    }\n+};\n+\n+\n+class FunctionDateTime64ToSnowflake : public IFunction\n+{\n+private:\n+    const char * name;\n+\n+public:\n+    FunctionDateTime64ToSnowflake(const char * name_) : name(name_) { }\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isVariadic() const override { return false; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (!isDateTime64(arguments[0].type))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be DateTime64\", name);\n+\n+        return std::make_shared<DataTypeInt64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto & src = arguments[0];\n+        const auto & col = *src.column;\n+\n+        auto res_column = ColumnInt64::create(input_rows_count);\n+        auto & result_data = res_column->getData();\n+\n+        const auto & source_data = typeid_cast<const ColumnDecimal<DateTime64> &>(col).getData();\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            result_data[i] = (source_data[i] - snowflake_epoch) << time_shift;\n+        }\n+\n+        return res_column;\n+    }\n+};\n+\n+\n+class FunctionSnowflakeToDateTime64 : public IFunction\n+{\n+private:\n+    const char * name;\n+\n+public:\n+    FunctionSnowflakeToDateTime64(const char * name_) : name(name_) { }\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() < 1 || arguments.size() > 2)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} takes one or two arguments\", name);\n+\n+        if (!typeid_cast<const DataTypeInt64 *>(arguments[0].type.get()))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The first argument for function {} must be Int64\", name);\n+\n+        std::string timezone;\n+        if (arguments.size() == 2)\n+            timezone = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);\n+\n+        return std::make_shared<DataTypeDateTime64>(3, timezone);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto & src = arguments[0];\n+        const auto & col = *src.column;\n+\n+        auto res_column = ColumnDecimal<DateTime64>::create(input_rows_count, 3);\n+        auto & result_data = res_column->getData();\n+\n+        const auto & source_data = typeid_cast<const ColumnInt64 &>(col).getData();\n+\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+        {\n+            result_data[i] = (source_data[i] >> time_shift) + snowflake_epoch;\n+        }\n+        return res_column;\n+    }\n+};\n+\n+}\ndiff --git a/src/Functions/registerFunctions.cpp b/src/Functions/registerFunctions.cpp\nindex 7e8f35bc0c4b..9b1a7faebbe5 100644\n--- a/src/Functions/registerFunctions.cpp\n+++ b/src/Functions/registerFunctions.cpp\n@@ -51,6 +51,7 @@ void registerFunctionBitHammingDistance(FunctionFactory & factory);\n void registerFunctionTupleHammingDistance(FunctionFactory & factory);\n void registerFunctionsStringHash(FunctionFactory & factory);\n void registerFunctionValidateNestedArraySizes(FunctionFactory & factory);\n+void registerFunctionsSnowflake(FunctionFactory & factory);\n #if !defined(ARCADIA_BUILD)\n void registerFunctionBayesAB(FunctionFactory &);\n #endif\n@@ -115,6 +116,7 @@ void registerFunctions()\n     registerFunctionTupleHammingDistance(factory);\n     registerFunctionsStringHash(factory);\n     registerFunctionValidateNestedArraySizes(factory);\n+    registerFunctionsSnowflake(factory);\n \n #if !defined(ARCADIA_BUILD)\n     registerFunctionBayesAB(factory);\ndiff --git a/src/Functions/registerFunctionsSnowflake.cpp b/src/Functions/registerFunctionsSnowflake.cpp\nnew file mode 100644\nindex 000000000000..7a0569ee16a3\n--- /dev/null\n+++ b/src/Functions/registerFunctionsSnowflake.cpp\n@@ -0,0 +1,22 @@\n+namespace DB\n+{\n+\n+class FunctionFactory;\n+\n+void registerDateTimeToSnowflake(FunctionFactory &);\n+void registerSnowflakeToDateTime(FunctionFactory &);\n+\n+void registerDateTime64ToSnowflake(FunctionFactory &);\n+void registerSnowflakeToDateTime64(FunctionFactory &);\n+\n+\n+void registerFunctionsSnowflake(FunctionFactory & factory)\n+{\n+    registerDateTimeToSnowflake(factory);\n+    registerSnowflakeToDateTime(factory);\n+\n+    registerDateTime64ToSnowflake(factory);\n+    registerSnowflakeToDateTime64(factory);\n+}\n+\n+}\ndiff --git a/src/Functions/snowflake.cpp b/src/Functions/snowflake.cpp\nnew file mode 100644\nindex 000000000000..5ac1d229d17c\n--- /dev/null\n+++ b/src/Functions/snowflake.cpp\n@@ -0,0 +1,34 @@\n+#include <Functions/FunctionSnowflake.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+\n+void registerDateTimeToSnowflake(FunctionFactory & factory)\n+{\n+    factory.registerFunction(\"dateTimeToSnowflake\",\n+        [](ContextPtr){ return std::make_unique<FunctionToOverloadResolverAdaptor>(\n+            std::make_shared<FunctionDateTimeToSnowflake>(\"dateTimeToSnowflake\")); });\n+}\n+\n+void registerDateTime64ToSnowflake(FunctionFactory & factory)\n+{\n+    factory.registerFunction(\"dateTime64ToSnowflake\",\n+        [](ContextPtr){ return std::make_unique<FunctionToOverloadResolverAdaptor>(\n+            std::make_shared<FunctionDateTime64ToSnowflake>(\"dateTime64ToSnowflake\")); });\n+}\n+\n+void registerSnowflakeToDateTime(FunctionFactory & factory)\n+{\n+    factory.registerFunction(\"snowflakeToDateTime\",\n+        [](ContextPtr){ return std::make_unique<FunctionToOverloadResolverAdaptor>(\n+            std::make_shared<FunctionSnowflakeToDateTime>(\"snowflakeToDateTime\")); });\n+}\n+void registerSnowflakeToDateTime64(FunctionFactory & factory)\n+{\n+    factory.registerFunction(\"snowflakeToDateTime64\",\n+        [](ContextPtr){ return std::make_unique<FunctionToOverloadResolverAdaptor>(\n+            std::make_shared<FunctionSnowflakeToDateTime64>(\"snowflakeToDateTime64\")); });\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference b/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference\nnew file mode 100644\nindex 000000000000..dfca3a10eeb3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference\n@@ -0,0 +1,6 @@\n+const column\n+2021-08-15 18:57:56\t1426860702823350272\n+2021-08-15 18:57:56.492\t1426860704886947840\n+non-const column\n+2021-08-15 18:57:56\t1426860702823350272\n+2021-08-15 18:57:56.492\t1426860704886947840\ndiff --git a/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql b/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql\nnew file mode 100644\nindex 000000000000..047d8be7be5d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql\n@@ -0,0 +1,23 @@\n+-- Error cases\n+SELECT dateTimeToSnowflake();  -- {serverError 42}\n+SELECT dateTime64ToSnowflake();  -- {serverError 42}\n+\n+SELECT dateTimeToSnowflake('abc');  -- {serverError 43}\n+SELECT dateTime64ToSnowflake('abc');  -- {serverError 43}\n+\n+SELECT dateTimeToSnowflake('abc', 123);  -- {serverError 42}\n+SELECT dateTime64ToSnowflake('abc', 123);  -- {serverError 42}\n+\n+SELECT 'const column';\n+WITH toDateTime('2021-08-15 18:57:56', 'Asia/Shanghai') AS dt\n+SELECT dt, dateTimeToSnowflake(dt);\n+\n+WITH toDateTime64('2021-08-15 18:57:56.492', 3, 'Asia/Shanghai') AS dt64\n+SELECT dt64, dateTime64ToSnowflake(dt64);\n+\n+SELECT 'non-const column';\n+WITH toDateTime('2021-08-15 18:57:56', 'Asia/Shanghai') AS x\n+SELECT materialize(x) as dt, dateTimeToSnowflake(dt);;\n+\n+WITH toDateTime64('2021-08-15 18:57:56.492', 3, 'Asia/Shanghai') AS x\n+SELECT materialize(x) as dt64, dateTime64ToSnowflake(dt64);\ndiff --git a/tests/queries/0_stateless/01942_snowflakeToDateTime.reference b/tests/queries/0_stateless/01942_snowflakeToDateTime.reference\nnew file mode 100644\nindex 000000000000..bed18023f6a0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01942_snowflakeToDateTime.reference\n@@ -0,0 +1,3 @@\n+const column\n+UTC\t1426860704886947840\t2021-08-15 10:57:56\tDateTime(\\'UTC\\')\t2021-08-15 10:57:56.492\tDateTime64(3, \\'UTC\\')\n+Asia/Shanghai\t1426860704886947840\t2021-08-15 18:57:56\tDateTime(\\'Asia/Shanghai\\')\t2021-08-15 18:57:56.492\tDateTime64(3, \\'Asia/Shanghai\\')\ndiff --git a/tests/queries/0_stateless/01942_snowflakeToDateTime.sql b/tests/queries/0_stateless/01942_snowflakeToDateTime.sql\nnew file mode 100644\nindex 000000000000..f6f171afabf6\n--- /dev/null\n+++ b/tests/queries/0_stateless/01942_snowflakeToDateTime.sql\n@@ -0,0 +1,32 @@\n+-- -- Error cases\n+SELECT snowflakeToDateTime();  -- {serverError 42}\n+SELECT snowflakeToDateTime64();  -- {serverError 42}\n+\n+SELECT snowflakeToDateTime('abc');  -- {serverError 43}\n+SELECT snowflakeToDateTime64('abc');  -- {serverError 43}\n+\n+SELECT snowflakeToDateTime('abc', 123);  -- {serverError 43}\n+SELECT snowflakeToDateTime64('abc', 123);  -- {serverError 43}\n+\n+SELECT 'const column';\n+WITH\n+\tCAST(1426860704886947840 AS Int64) AS i64,\n+\t'UTC' AS tz\n+SELECT\n+\ttz,\n+\ti64,\n+\tsnowflakeToDateTime(i64, tz) as dt,\n+\ttoTypeName(dt),\n+\tsnowflakeToDateTime64(i64, tz) as dt64,\n+\ttoTypeName(dt64);\n+\n+WITH\n+\tCAST(1426860704886947840 AS Int64) AS i64,\n+\t'Asia/Shanghai' AS tz\n+SELECT\n+\ttz,\n+\ti64,\n+\tsnowflakeToDateTime(i64, tz) as dt,\n+\ttoTypeName(dt),\n+\tsnowflakeToDateTime64(i64, tz) as dt64,\n+\ttoTypeName(dt64);\n\\ No newline at end of file\n",
  "problem_statement": "snowflake id (not to confuse with Snowflake service) time extract and convert functions\n**Use case**\r\n[snowflake id](https://en.wikipedia.org/wiki/Snowflake_ID) is a form of unique identifier used in distributed computing. The format was created by Twitter and it is widely used in many products such as discord api and etc. \r\n\r\nsnowflake is a int64 number and generated based on timestamp, so it is comparable between two ids and it is sorting friendly,   therefore it is a good replacement to uuid  to be used as primary key in many occasions \r\n\r\nwhen it comes to clickhouse merge key engine,\r\n- we can use snowflake to be the order key or primary key and extract time from it to be the partitioning key at the same time\r\n- some time based queries can be applied on snowflack primary keys after converting time to snowflake and speed up the queries \r\n\r\n**Describe the solution you'd like**\r\n\r\nI'd like to add a group of snowflake time extract and convert  functions to solve above questions, and I wonder whether the community will accept this feature. \r\n\n",
  "hints_text": "Yes, it is rather easy to implement (just do bit shifts accordingly).\r\n\r\nYou can already do it with `bitShiftRight(snowflake_id, 41)::DateTime64(3)`.\r\nMaybe a separate function(s) will be more convenient.\r\nIf there will be a pull request, most likely it will be accepted.\r\n\r\nProposed names:\r\n`snowflakeToDateTime`\r\n`snowflakeToDateTime64`\r\n\n> Yes, it is rather easy to implement (just do bit shifts accordingly).\r\n> \r\n> You can already do it with `bitShiftRight(snowflake_id, 41)::DateTime64(3)`.\r\n> Maybe a separate function(s) will be more convenient.\r\n> If there will be a pull request, most likely it will be accepted.\r\n> \r\n> Proposed names:\r\n> `snowflakeToDateTime`\r\n> `snowflakeToDateTime64`\r\n\r\n@alexey-milovidov  thanks, it is a long formula,   and snowflake time base on an epoch (default `1288834974657` which is Nov 04 2010 01:42:54 UTC), currently I use \r\n\r\n```fromUnixTimestamp64Milli(((bitShiftRight(snowflake_id, 22)+1288834974657))::Int64)```\r\n\r\n so a function is more convenient and I will create a pull request later. \r\n\r\nby the way, as you suggested, I tried to use `::DateTime64(3)` to replace `fromUnixTimestamp64Milli`, and it seems that converting from number to DateTime64(3) has wrong result, and from string to  DateTime64(3) is correct, is it a bug ? \r\n\r\nfor example  \r\n\r\n`select 1627807940674::DateTime64(3);`  has correct result: `2021-08-01 08:52:20.476` but `select 1627807940674::Int64::DateTime64(3)` result `2282-12-31 00:00:00.000`\r\n\nCorrect way of data casting.\r\n\r\n```\r\nSELECT\r\n    fromUnixTimestamp64Milli(CAST('1627807940674', 'Int64')),\r\n    CAST(1627807940674 / 1000, 'DateTime64(3)')\r\n\r\n\u250c\u2500fromUnixTimestamp64Milli(CAST('1627807940674', 'Int64'))\u2500\u252c\u2500CAST(divide(1627807940674, 1000), 'DateTime64(3)')\u2500\u2510\r\n\u2502                                  2021-08-01 11:52:20.674 \u2502                            2021-08-01 11:52:20.674 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@UnamedRus got it, thanks\nSimilar https://github.com/sony/sonyflake ",
  "created_at": "2021-08-15T14:31:40Z",
  "modified_files": [
    "docs/en/sql-reference/functions/type-conversion-functions.md",
    "b/src/Functions/FunctionSnowflake.h",
    "src/Functions/registerFunctions.cpp",
    "b/src/Functions/registerFunctionsSnowflake.cpp",
    "b/src/Functions/snowflake.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01942_dateTimeToSnowflake.reference",
    "b/tests/queries/0_stateless/01942_dateTimeToSnowflake.sql",
    "b/tests/queries/0_stateless/01942_snowflakeToDateTime.reference",
    "b/tests/queries/0_stateless/01942_snowflakeToDateTime.sql"
  ]
}