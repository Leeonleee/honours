diff --git a/src/Columns/tests/gtest_column_object.cpp b/src/Columns/tests/gtest_column_object.cpp
new file mode 100644
index 000000000000..d5e58e5fce24
--- /dev/null
+++ b/src/Columns/tests/gtest_column_object.cpp
@@ -0,0 +1,120 @@
+#include <Common/FieldVisitorsAccurateComparison.h>
+#include <DataTypes/getLeastSupertype.h>
+#include <Interpreters/castColumn.h>
+#include <Interpreters/convertFieldToType.h>
+#include <Columns/ColumnObject.h>
+#include <Common/FieldVisitorToString.h>
+
+#include <Common/randomSeed.h>
+#include <fmt/core.h>
+#include <pcg_random.hpp>
+#include <gtest/gtest.h>
+#include <random>
+
+using namespace DB;
+
+static pcg64 rng(randomSeed());
+
+Field getRandomField(size_t type)
+{
+    switch (type)
+    {
+        case 0:
+            return rng();
+        case 1:
+            return std::uniform_real_distribution<>(0.0, 1.0)(rng);
+        case 2:
+            return std::string(rng() % 10, 'a' + rng() % 26);
+        default:
+            return Field();
+    }
+}
+
+std::pair<ColumnObject::Subcolumn, std::vector<Field>> generate(size_t size)
+{
+    bool has_defaults = rng() % 3 == 0;
+    size_t num_defaults = has_defaults ? rng() % size : 0;
+
+    ColumnObject::Subcolumn subcolumn(num_defaults, false);
+    std::vector<Field> fields;
+
+    while (subcolumn.size() < size)
+    {
+        size_t part_size = rng() % (size - subcolumn.size()) + 1;
+        size_t field_type = rng() % 3;
+
+        for (size_t i = 0; i < part_size; ++i)
+        {
+            fields.push_back(getRandomField(field_type));
+            subcolumn.insert(fields.back());
+        }
+    }
+
+    std::vector<Field> result_fields;
+    for (size_t i = 0; i < num_defaults; ++i)
+        result_fields.emplace_back();
+
+    result_fields.insert(result_fields.end(), fields.begin(), fields.end());
+    return {std::move(subcolumn), std::move(result_fields)};
+}
+
+void checkFieldsAreEqual(ColumnObject::Subcolumn subcolumn, const std::vector<Field> & fields)
+{
+    ASSERT_EQ(subcolumn.size(), fields.size());
+    for (size_t i = 0; i < subcolumn.size(); ++i)
+    {
+        Field field;
+        subcolumn.get(i, field); // Also check 'get' method.
+        if (!applyVisitor(FieldVisitorAccurateEquals(), field, fields[i]))
+        {
+            std::cerr << fmt::format("Wrong value at position {}, expected {}, got {}",
+                i, applyVisitor(FieldVisitorToString(), fields[i]), applyVisitor(FieldVisitorToString(), field));
+            ASSERT_TRUE(false);
+        }
+    }
+}
+
+constexpr size_t T = 1000;
+constexpr size_t N = 1000;
+
+TEST(ColumnObject, InsertRangeFrom)
+{
+    for (size_t t = 0; t < T; ++t)
+    {
+        auto [subcolumn_dst, fields_dst] = generate(N);
+        auto [subcolumn_src, fields_src] = generate(N);
+
+        ASSERT_EQ(subcolumn_dst.size(), fields_dst.size());
+        ASSERT_EQ(subcolumn_src.size(), fields_src.size());
+
+        const auto & type_dst = subcolumn_dst.getLeastCommonType();
+        const auto & type_src = subcolumn_src.getLeastCommonType();
+        auto type_res = getLeastSupertype(DataTypes{type_dst, type_src}, true);
+
+        size_t from = rng() % subcolumn_src.size();
+        size_t to = rng() % subcolumn_src.size();
+        if (from > to)
+            std::swap(from, to);
+        ++to;
+
+        for (auto & field : fields_dst)
+        {
+            if (field.isNull())
+                field = type_res->getDefault();
+            else
+                field = convertFieldToTypeOrThrow(field, *type_res);
+        }
+
+        for (size_t i = from; i < to; ++i)
+        {
+            if (fields_src[i].isNull())
+                fields_dst.push_back(type_res->getDefault());
+            else
+                fields_dst.push_back(convertFieldToTypeOrThrow(fields_src[i], *type_res));
+
+        }
+
+        subcolumn_dst.insertRangeFrom(subcolumn_src, from, to - from);
+        checkFieldsAreEqual(subcolumn_dst, fields_dst);
+    }
+}
diff --git a/src/Columns/tests/gtest_column_sparse.cpp b/src/Columns/tests/gtest_column_sparse.cpp
index 35ac68b4e2ee..b5b226c6862b 100644
--- a/src/Columns/tests/gtest_column_sparse.cpp
+++ b/src/Columns/tests/gtest_column_sparse.cpp
@@ -11,7 +11,7 @@
 #include <Common/FieldVisitors.h>
 
 using namespace DB;
-pcg64 rng(randomSeed());
+static pcg64 rng(randomSeed());
 
 std::pair<MutableColumnPtr, MutableColumnPtr> createColumns(size_t n, size_t k)
 {
diff --git a/tests/queries/0_stateless/01825_type_json_insert_select.reference b/tests/queries/0_stateless/01825_type_json_insert_select.reference
index 6e50983f5eef..6778da508f25 100644
--- a/tests/queries/0_stateless/01825_type_json_insert_select.reference
+++ b/tests/queries/0_stateless/01825_type_json_insert_select.reference
@@ -13,3 +13,6 @@ Tuple(arr Nested(k11 Int8, k22 String, k33 Int8), k1 Int8, k2 String, k3 String)
 {"data":{"k1":1,"k10":[{"a":"1","b":"2","c":{"k11":""}},{"a":"2","b":"3","c":{"k11":""}}]}}
 {"data":{"k1":2,"k10":[{"a":"1","b":"2","c":{"k11":"haha"}}]}}
 Tuple(k1 Int8, k10 Nested(a String, b String, c Tuple(k11 String)))
+{"data":{"k1":1,"k10":[{"a":"1","b":"2","c":{"k11":""}},{"a":"2","b":"3","c":{"k11":""}}]}}
+{"data":{"k1":2,"k10":[{"a":"1","b":"2","c":{"k11":"haha"}}]}}
+Tuple(k1 Int8, k10 Nested(a String, b String, c Tuple(k11 String)))
diff --git a/tests/queries/0_stateless/01825_type_json_insert_select.sql b/tests/queries/0_stateless/01825_type_json_insert_select.sql
index a54c2c4a709d..cd0b280c3609 100644
--- a/tests/queries/0_stateless/01825_type_json_insert_select.sql
+++ b/tests/queries/0_stateless/01825_type_json_insert_select.sql
@@ -38,18 +38,29 @@ DROP TABLE type_json_dst;
 CREATE TABLE type_json_dst (data JSON) ENGINE = MergeTree ORDER BY tuple();
 CREATE TABLE type_json_src (data String) ENGINE = MergeTree ORDER BY tuple();
 
+SYSTEM STOP MERGES type_json_src;
+
+SET max_threads = 1;
+SET max_insert_threads = 1;
+SET output_format_json_named_tuples_as_objects = 1;
+
 INSERT INTO type_json_src FORMAT JSONAsString {"k1": 1, "k10": [{"a": "1", "b": "2"}, {"a": "2", "b": "3"}]};
 INSERT INTO type_json_src FORMAT JSONAsString  {"k1": 2, "k10": [{"a": "1", "b": "2", "c": {"k11": "haha"}}]};
 
--- Temporarily fix test by optimizing data to one part.
--- If order of insertion of above two lines will be changed,
--- which can happen during insertion with multiple threads,
--- this test will fail. TODO: fix this.
-OPTIMIZE TABLE type_json_src FINAL;
+INSERT INTO type_json_dst SELECT data FROM type_json_src;
+
+SELECT * FROM type_json_dst ORDER BY data.k1 FORMAT JSONEachRow;
+SELECT toTypeName(data) FROM type_json_dst LIMIT 1;
+
+TRUNCATE TABLE type_json_src;
+TRUNCATE TABLE type_json_dst;
+
+-- Insert in another order. Order is important, because a way how defaults are filled differs.
+INSERT INTO type_json_src FORMAT JSONAsString  {"k1": 2, "k10": [{"a": "1", "b": "2", "c": {"k11": "haha"}}]};
+INSERT INTO type_json_src FORMAT JSONAsString {"k1": 1, "k10": [{"a": "1", "b": "2"}, {"a": "2", "b": "3"}]};
 
 INSERT INTO type_json_dst SELECT data FROM type_json_src;
 
-SET output_format_json_named_tuples_as_objects = 1;
 SELECT * FROM type_json_dst ORDER BY data.k1 FORMAT JSONEachRow;
 SELECT toTypeName(data) FROM type_json_dst LIMIT 1;
 
