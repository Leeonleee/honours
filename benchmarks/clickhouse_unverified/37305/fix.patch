diff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp
index 0913f6b8da9f..d3e68273d03f 100644
--- a/src/Columns/ColumnObject.cpp
+++ b/src/Columns/ColumnObject.cpp
@@ -22,8 +22,8 @@ namespace ErrorCodes
     extern const int ILLEGAL_COLUMN;
     extern const int DUPLICATE_COLUMN;
     extern const int NUMBER_OF_DIMENSIONS_MISMATHED;
-    extern const int NOT_IMPLEMENTED;
     extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;
+    extern const int ARGUMENT_OUT_OF_BOUND;
 }
 
 namespace
@@ -179,7 +179,7 @@ ColumnObject::Subcolumn::Subcolumn(
 {
 }
 
-size_t ColumnObject::Subcolumn::Subcolumn::size() const
+size_t ColumnObject::Subcolumn::size() const
 {
     size_t res = num_of_defaults_in_prefix;
     for (const auto & part : data)
@@ -187,7 +187,7 @@ size_t ColumnObject::Subcolumn::Subcolumn::size() const
     return res;
 }
 
-size_t ColumnObject::Subcolumn::Subcolumn::byteSize() const
+size_t ColumnObject::Subcolumn::byteSize() const
 {
     size_t res = 0;
     for (const auto & part : data)
@@ -195,7 +195,7 @@ size_t ColumnObject::Subcolumn::Subcolumn::byteSize() const
     return res;
 }
 
-size_t ColumnObject::Subcolumn::Subcolumn::allocatedBytes() const
+size_t ColumnObject::Subcolumn::allocatedBytes() const
 {
     size_t res = 0;
     for (const auto & part : data)
@@ -203,6 +203,37 @@ size_t ColumnObject::Subcolumn::Subcolumn::allocatedBytes() const
     return res;
 }
 
+void ColumnObject::Subcolumn::get(size_t n, Field & res) const
+{
+    if (isFinalized())
+    {
+        getFinalizedColumn().get(n, res);
+        return;
+    }
+
+    size_t ind = n;
+    if (ind < num_of_defaults_in_prefix)
+    {
+        res = least_common_type.get()->getDefault();
+        return;
+    }
+
+    ind -= num_of_defaults_in_prefix;
+    for (const auto & part : data)
+    {
+        if (ind < part->size())
+        {
+            part->get(ind, res);
+            res = convertFieldToTypeOrThrow(res, *least_common_type.get());
+            return;
+        }
+
+        ind -= part->size();
+    }
+
+    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "Index ({}) for getting field is out of range", n);
+}
+
 void ColumnObject::Subcolumn::checkTypes() const
 {
     DataTypes prefix_types;
@@ -221,7 +252,7 @@ void ColumnObject::Subcolumn::checkTypes() const
 
 void ColumnObject::Subcolumn::insert(Field field)
 {
-    auto info = getFieldInfo(field);
+    auto info = DB::getFieldInfo(field);
     insert(std::move(field), std::move(info));
 }
 
@@ -244,8 +275,8 @@ static bool isConversionRequiredBetweenIntegers(const IDataType & lhs, const IDa
     bool is_native_int = which_lhs.isNativeInt() && which_rhs.isNativeInt();
     bool is_native_uint = which_lhs.isNativeUInt() && which_rhs.isNativeUInt();
 
-    return (is_native_int || is_native_uint)
-        && lhs.getSizeOfValueInMemory() <= rhs.getSizeOfValueInMemory();
+    return (!is_native_int && !is_native_uint)
+        || lhs.getSizeOfValueInMemory() > rhs.getSizeOfValueInMemory();
 }
 
 void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
@@ -288,7 +319,7 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
     }
     else if (!least_common_base_type->equals(*base_type) && !isNothing(base_type))
     {
-        if (!isConversionRequiredBetweenIntegers(*base_type, *least_common_base_type))
+        if (isConversionRequiredBetweenIntegers(*base_type, *least_common_base_type))
         {
             base_type = getLeastSupertype(DataTypes{std::move(base_type), least_common_base_type}, true);
             type_changed = true;
@@ -305,35 +336,96 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
 
 void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t start, size_t length)
 {
-    assert(src.isFinalized());
-    const auto & src_column = src.data.back();
-    const auto & src_type = src.least_common_type.get();
+    assert(start + length <= src.size());
+    size_t end = start + length;
 
     if (data.empty())
     {
-        addNewColumnPart(src.least_common_type.get());
-        data.back()->insertRangeFrom(*src_column, start, length);
+        addNewColumnPart(src.getLeastCommonType());
     }
-    else if (least_common_type.get()->equals(*src_type))
+    else if (!least_common_type.get()->equals(*src.getLeastCommonType()))
     {
-        data.back()->insertRangeFrom(*src_column, start, length);
+        auto new_least_common_type = getLeastSupertype(DataTypes{least_common_type.get(), src.getLeastCommonType()}, true);
+        if (!new_least_common_type->equals(*least_common_type.get()))
+            addNewColumnPart(std::move(new_least_common_type));
     }
-    else
+
+    if (end <= src.num_of_defaults_in_prefix)
     {
-        auto new_least_common_type = getLeastSupertype(DataTypes{least_common_type.get(), src_type}, true);
-        auto casted_column = castColumn({src_column, src_type, ""}, new_least_common_type);
+        data.back()->insertManyDefaults(length);
+        return;
+    }
 
-        if (!least_common_type.get()->equals(*new_least_common_type))
-            addNewColumnPart(std::move(new_least_common_type));
+    if (start < src.num_of_defaults_in_prefix)
+        data.back()->insertManyDefaults(src.num_of_defaults_in_prefix - start);
+
+    auto insert_from_part = [&](const auto & column, size_t from, size_t n)
+    {
+        assert(from + n <= column->size());
+        auto column_type = getDataTypeByColumn(*column);
+
+        if (column_type->equals(*least_common_type.get()))
+        {
+            data.back()->insertRangeFrom(*column, from, n);
+            return;
+        }
+
+        /// If we need to insert large range, there is no sense to cut part of column and cast it.
+        /// Casting of all column and inserting from it can be faster.
+        /// Threshold is just a guess.
+
+        if (n * 3 >= column->size())
+        {
+            auto casted_column = castColumn({column, column_type, ""}, least_common_type.get());
+            data.back()->insertRangeFrom(*casted_column, from, n);
+            return;
+        }
+
+        auto casted_column = column->cut(from, n);
+        casted_column = castColumn({casted_column, column_type, ""}, least_common_type.get());
+        data.back()->insertRangeFrom(*casted_column, 0, n);
+    };
+
+    size_t pos = 0;
+    size_t processed_rows = src.num_of_defaults_in_prefix;
+
+    /// Find the first part of the column that intersects the range.
+    while (pos < src.data.size() && processed_rows + src.data[pos]->size() < start)
+    {
+        processed_rows += src.data[pos]->size();
+        ++pos;
+    }
+
+    /// Insert from the first part of column.
+    if (pos < src.data.size() && processed_rows < start)
+    {
+        size_t part_start = start - processed_rows;
+        size_t part_length = std::min(src.data[pos]->size() - part_start, end - start);
+        insert_from_part(src.data[pos], part_start, part_length);
+        processed_rows += src.data[pos]->size();
+        ++pos;
+    }
+
+    /// Insert from the parts of column in the middle of range.
+    while (pos < src.data.size() && processed_rows + src.data[pos]->size() < end)
+    {
+        insert_from_part(src.data[pos], 0, src.data[pos]->size());
+        processed_rows += src.data[pos]->size();
+        ++pos;
+    }
 
-        data.back()->insertRangeFrom(*casted_column, start, length);
+    /// Insert from the last part of column if needed.
+    if (pos < src.data.size() && processed_rows < end)
+    {
+        size_t part_end = end - processed_rows;
+        insert_from_part(src.data[pos], 0, part_end);
     }
 }
 
 bool ColumnObject::Subcolumn::isFinalized() const
 {
-    return data.empty() ||
-        (data.size() == 1 && !data[0]->isSparse() && num_of_defaults_in_prefix == 0);
+    return num_of_defaults_in_prefix == 0 &&
+        (data.empty() || (data.size() == 1 && !data[0]->isSparse()));
 }
 
 void ColumnObject::Subcolumn::finalize()
@@ -432,6 +524,13 @@ void ColumnObject::Subcolumn::popBack(size_t n)
     num_of_defaults_in_prefix -= n;
 }
 
+ColumnObject::Subcolumn ColumnObject::Subcolumn::cut(size_t start, size_t length) const
+{
+    Subcolumn new_subcolumn(0, is_nullable);
+    new_subcolumn.insertRangeFrom(*this, start, length);
+    return new_subcolumn;
+}
+
 Field ColumnObject::Subcolumn::getLastField() const
 {
     if (data.empty())
@@ -442,6 +541,18 @@ Field ColumnObject::Subcolumn::getLastField() const
     return (*last_part)[last_part->size() - 1];
 }
 
+FieldInfo ColumnObject::Subcolumn::getFieldInfo() const
+{
+    const auto & base_type = least_common_type.getBase();
+    return FieldInfo
+    {
+        .scalar_type = base_type,
+        .have_nulls = base_type->isNullable(),
+        .need_convert = false,
+        .num_dimensions = least_common_type.getNumberOfDimensions(),
+    };
+}
+
 ColumnObject::Subcolumn ColumnObject::Subcolumn::recreateWithDefaultValues(const FieldInfo & field_info) const
 {
     auto scalar_type = field_info.scalar_type;
@@ -479,6 +590,13 @@ const ColumnPtr & ColumnObject::Subcolumn::getFinalizedColumnPtr() const
     return data[0];
 }
 
+ColumnObject::Subcolumn::LeastCommonType::LeastCommonType()
+    : type(std::make_shared<DataTypeNothing>())
+    , base_type(type)
+    , num_dimensions(0)
+{
+}
+
 ColumnObject::Subcolumn::LeastCommonType::LeastCommonType(DataTypePtr type_)
     : type(std::move(type_))
     , base_type(getBaseTypeOfArray(type))
@@ -525,16 +643,6 @@ size_t ColumnObject::size() const
     return num_rows;
 }
 
-MutableColumnPtr ColumnObject::cloneResized(size_t new_size) const
-{
-    /// cloneResized with new_size == 0 is used for cloneEmpty().
-    if (new_size != 0)
-        throw Exception(ErrorCodes::NOT_IMPLEMENTED,
-            "ColumnObject doesn't support resize to non-zero length");
-
-    return ColumnObject::create(is_nullable);
-}
-
 size_t ColumnObject::byteSize() const
 {
     size_t res = 0;
@@ -553,23 +661,21 @@ size_t ColumnObject::allocatedBytes() const
 
 void ColumnObject::forEachSubcolumn(ColumnCallback callback)
 {
-    if (!isFinalized())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot iterate over non-finalized ColumnObject");
-
     for (auto & entry : subcolumns)
-        callback(entry->data.data.back());
+        for (auto & part : entry->data.data)
+            callback(part);
 }
 
 void ColumnObject::insert(const Field & field)
 {
     const auto & object = field.get<const Object &>();
 
-    HashSet<StringRef, StringRefHash> inserted;
+    HashSet<StringRef, StringRefHash> inserted_paths;
     size_t old_size = size();
     for (const auto & [key_str, value] : object)
     {
         PathInData key(key_str);
-        inserted.insert(key_str);
+        inserted_paths.insert(key_str);
         if (!hasSubcolumn(key))
             addSubcolumn(key, old_size);
 
@@ -578,8 +684,14 @@ void ColumnObject::insert(const Field & field)
     }
 
     for (auto & entry : subcolumns)
-        if (!inserted.has(entry->path.getPath()))
-            entry->data.insertDefault();
+    {
+        if (!inserted_paths.has(entry->path.getPath()))
+        {
+            bool inserted = tryInsertDefaultFromNested(entry);
+            if (!inserted)
+                entry->data.insertDefault();
+        }
+    }
 
     ++num_rows;
 }
@@ -594,26 +706,21 @@ void ColumnObject::insertDefault()
 
 Field ColumnObject::operator[](size_t n) const
 {
-    if (!isFinalized())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot get Field from non-finalized ColumnObject");
-
-    Object object;
-    for (const auto & entry : subcolumns)
-        object[entry->path.getPath()] = (*entry->data.data.back())[n];
-
+    Field object;
+    get(n, object);
     return object;
 }
 
 void ColumnObject::get(size_t n, Field & res) const
 {
-    if (!isFinalized())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot get Field from non-finalized ColumnObject");
+    assert(n < size());
+    res = Object();
 
     auto & object = res.get<Object &>();
     for (const auto & entry : subcolumns)
     {
         auto it = object.try_emplace(entry->path.getPath()).first;
-        entry->data.data.back()->get(n, it->second);
+        entry->data.get(n, it->second);
     }
 }
 
@@ -626,61 +733,33 @@ void ColumnObject::insertFrom(const IColumn & src, size_t n)
 void ColumnObject::insertRangeFrom(const IColumn & src, size_t start, size_t length)
 {
     const auto & src_object = assert_cast<const ColumnObject &>(src);
-    if (!src_object.isFinalized())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot insertRangeFrom non-finalized ColumnObject");
-
-    for (auto & entry : subcolumns)
-    {
-        if (src_object.hasSubcolumn(entry->path))
-            entry->data.insertRangeFrom(src_object.getSubcolumn(entry->path), start, length);
-        else
-            entry->data.insertManyDefaults(length);
-    }
 
     for (const auto & entry : src_object.subcolumns)
     {
         if (!hasSubcolumn(entry->path))
         {
             if (entry->path.hasNested())
-            {
-                const auto & base_type = entry->data.getLeastCommonTypeBase();
-                FieldInfo field_info
-                {
-                    .scalar_type = base_type,
-                    .have_nulls = base_type->isNullable(),
-                    .need_convert = false,
-                    .num_dimensions = entry->data.getNumberOfDimensions(),
-                };
-
-                addNestedSubcolumn(entry->path, field_info, num_rows);
-            }
+                addNestedSubcolumn(entry->path, entry->data.getFieldInfo(), num_rows);
             else
-            {
                 addSubcolumn(entry->path, num_rows);
-            }
-
-            auto & subcolumn = getSubcolumn(entry->path);
-            subcolumn.insertRangeFrom(entry->data, start, length);
         }
-    }
-
-    num_rows += length;
-    finalize();
-}
 
-ColumnPtr ColumnObject::replicate(const Offsets & offsets) const
-{
-    if (!isFinalized())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot replicate non-finalized ColumnObject");
+        auto & subcolumn = getSubcolumn(entry->path);
+        subcolumn.insertRangeFrom(entry->data, start, length);
+    }
 
-    auto res_column = ColumnObject::create(is_nullable);
-    for (const auto & entry : subcolumns)
+    for (auto & entry : subcolumns)
     {
-        auto replicated_data = entry->data.data.back()->replicate(offsets)->assumeMutable();
-        res_column->addSubcolumn(entry->path, std::move(replicated_data));
+        if (!src_object.hasSubcolumn(entry->path))
+        {
+            bool inserted = tryInsertManyDefaultsFromNested(entry);
+            if (!inserted)
+                entry->data.insertManyDefaults(length);
+        }
     }
 
-    return res_column;
+    num_rows += length;
+    finalize();
 }
 
 void ColumnObject::popBack(size_t length)
@@ -692,10 +771,15 @@ void ColumnObject::popBack(size_t length)
 }
 
 template <typename Func>
-ColumnPtr ColumnObject::applyForSubcolumns(Func && func, std::string_view func_name) const
+MutableColumnPtr ColumnObject::applyForSubcolumns(Func && func) const
 {
     if (!isFinalized())
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot {} non-finalized ColumnObject", func_name);
+    {
+        auto finalized = IColumn::mutate(getPtr());
+        auto & finalized_object = assert_cast<ColumnObject &>(*finalized);
+        finalized_object.finalize();
+        return finalized_object.applyForSubcolumns(std::forward<Func>(func));
+    }
 
     auto res = ColumnObject::create(is_nullable);
     for (const auto & subcolumn : subcolumns)
@@ -703,22 +787,36 @@ ColumnPtr ColumnObject::applyForSubcolumns(Func && func, std::string_view func_n
         auto new_subcolumn = func(subcolumn->data.getFinalizedColumn());
         res->addSubcolumn(subcolumn->path, new_subcolumn->assumeMutable());
     }
+
     return res;
 }
 
 ColumnPtr ColumnObject::permute(const Permutation & perm, size_t limit) const
 {
-    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.permute(perm, limit); }, "permute");
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.permute(perm, limit); });
 }
 
 ColumnPtr ColumnObject::filter(const Filter & filter, ssize_t result_size_hint) const
 {
-    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.filter(filter, result_size_hint); }, "filter");
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.filter(filter, result_size_hint); });
 }
 
 ColumnPtr ColumnObject::index(const IColumn & indexes, size_t limit) const
 {
-    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.index(indexes, limit); }, "index");
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.index(indexes, limit); });
+}
+
+ColumnPtr ColumnObject::replicate(const Offsets & offsets) const
+{
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.replicate(offsets); });
+}
+
+MutableColumnPtr ColumnObject::cloneResized(size_t new_size) const
+{
+    if (new_size == 0)
+        return ColumnObject::create(is_nullable);
+
+    return applyForSubcolumns([&](const auto & subcolumn) { return subcolumn.cloneResized(new_size); });
 }
 
 const ColumnObject::Subcolumn & ColumnObject::getSubcolumn(const PathInData & key) const
@@ -810,6 +908,92 @@ void ColumnObject::addNestedSubcolumn(const PathInData & key, const FieldInfo &
 
     if (num_rows == 0)
         num_rows = new_size;
+    else if (new_size != num_rows)
+        throw Exception(ErrorCodes::SIZES_OF_COLUMNS_DOESNT_MATCH,
+            "Required size of subcolumn {} ({}) is inconsistent with column size ({})",
+            key.getPath(), new_size, num_rows);
+}
+
+const ColumnObject::Subcolumns::Node * ColumnObject::getLeafOfTheSameNested(const Subcolumns::NodePtr & entry) const
+{
+    if (!entry->path.hasNested())
+        return nullptr;
+
+    size_t old_size = entry->data.size();
+    const auto * current_node = subcolumns.findLeaf(entry->path);
+    const Subcolumns::Node * leaf = nullptr;
+
+    while (current_node)
+    {
+        /// Try to find the first Nested up to the current node.
+        const auto * node_nested = subcolumns.findParent(current_node,
+            [](const auto & candidate) { return candidate.isNested(); });
+
+        if (!node_nested)
+            break;
+
+        /// Find the leaf with subcolumn that contains values
+        /// for the last rows.
+        /// If there are no leaves, skip current node and find
+        /// the next node up to the current.
+        leaf = subcolumns.findLeaf(node_nested,
+            [&](const auto & candidate)
+            {
+                return candidate.data.size() > old_size;
+            });
+
+        if (leaf)
+            break;
+
+        current_node = node_nested->parent;
+    }
+
+    if (leaf && isNothing(leaf->data.getLeastCommonTypeBase()))
+        return nullptr;
+
+    return leaf;
+}
+
+bool ColumnObject::tryInsertManyDefaultsFromNested(const Subcolumns::NodePtr & entry) const
+{
+    const auto * leaf = getLeafOfTheSameNested(entry);
+    if (!leaf)
+        return false;
+
+    size_t old_size = entry->data.size();
+    auto field_info = entry->data.getFieldInfo();
+
+    /// Cut the needed range from the found leaf
+    /// and replace scalar values to the correct
+    /// default values for given entry.
+    auto new_subcolumn = leaf->data
+        .cut(old_size, leaf->data.size() - old_size)
+        .recreateWithDefaultValues(field_info);
+
+    entry->data.insertRangeFrom(new_subcolumn, 0, new_subcolumn.size());
+    return true;
+}
+
+bool ColumnObject::tryInsertDefaultFromNested(const Subcolumns::NodePtr & entry) const
+{
+    const auto * leaf = getLeafOfTheSameNested(entry);
+    if (!leaf)
+        return false;
+
+    auto last_field = leaf->data.getLastField();
+    if (last_field.isNull())
+        return false;
+
+    size_t leaf_num_dimensions = leaf->data.getNumberOfDimensions();
+    size_t entry_num_dimensions = entry->data.getNumberOfDimensions();
+
+    auto default_scalar = entry_num_dimensions > leaf_num_dimensions
+        ? createEmptyArrayField(entry_num_dimensions - leaf_num_dimensions)
+        : entry->data.getLeastCommonTypeBase()->getDefault();
+
+    auto default_field = applyVisitor(FieldVisitorReplaceScalars(default_scalar, leaf_num_dimensions), last_field);
+    entry->data.insert(std::move(default_field));
+    return true;
 }
 
 PathsInData ColumnObject::getKeys() const
@@ -835,7 +1019,7 @@ void ColumnObject::finalize()
     {
         const auto & least_common_type = entry->data.getLeastCommonType();
 
-        /// Do not add subcolumns, which consists only from NULLs.
+        /// Do not add subcolumns, which consist only from NULLs.
         if (isNothing(getBaseTypeOfArray(least_common_type)))
             continue;
 
diff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h
index 73fc738cb8d4..89e42183ea01 100644
--- a/src/Columns/ColumnObject.h
+++ b/src/Columns/ColumnObject.h
@@ -65,6 +65,7 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
         size_t size() const;
         size_t byteSize() const;
         size_t allocatedBytes() const;
+        void get(size_t n, Field & res) const;
 
         bool isFinalized() const;
         const DataTypePtr & getLeastCommonType() const { return least_common_type.get(); }
@@ -84,6 +85,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
         void insertRangeFrom(const Subcolumn & src, size_t start, size_t length);
         void popBack(size_t n);
 
+        Subcolumn cut(size_t start, size_t length) const;
+
         /// Converts all column's parts to the common type and
         /// creates a single column that stores all values.
         void finalize();
@@ -91,6 +94,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
         /// Returns last inserted field.
         Field getLastField() const;
 
+        FieldInfo getFieldInfo() const;
+
         /// Recreates subcolumn with default scalar values and keeps sizes of arrays.
         /// Used to create columns of type Nested with consistent array sizes.
         Subcolumn recreateWithDefaultValues(const FieldInfo & field_info) const;
@@ -101,13 +106,16 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
         const IColumn & getFinalizedColumn() const;
         const ColumnPtr & getFinalizedColumnPtr() const;
 
+        const std::vector<WrappedPtr> & getData() const { return data; }
+        size_t getNumberOfDefaultsInPrefix() const { return num_of_defaults_in_prefix; }
+
         friend class ColumnObject;
 
     private:
         class LeastCommonType
         {
         public:
-            LeastCommonType() = default;
+            LeastCommonType();
             explicit LeastCommonType(DataTypePtr type_);
 
             const DataTypePtr & get() const { return type; }
@@ -175,6 +183,11 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     /// It cares about consistency of sizes of Nested arrays.
     void addNestedSubcolumn(const PathInData & key, const FieldInfo & field_info, size_t new_size);
 
+    /// Finds a subcolumn from the same Nested type as @entry and inserts
+    /// an array with default values with consistent sizes as in Nested type.
+    bool tryInsertDefaultFromNested(const Subcolumns::NodePtr & entry) const;
+    bool tryInsertManyDefaultsFromNested(const Subcolumns::NodePtr & entry) const;
+
     const Subcolumns & getSubcolumns() const { return subcolumns; }
     Subcolumns & getSubcolumns() { return subcolumns; }
     PathsInData getKeys() const;
@@ -189,7 +202,6 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     TypeIndex getDataType() const override { return TypeIndex::Object; }
 
     size_t size() const override;
-    MutableColumnPtr cloneResized(size_t new_size) const override;
     size_t byteSize() const override;
     size_t allocatedBytes() const override;
     void forEachSubcolumn(ColumnCallback callback) override;
@@ -197,13 +209,14 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     void insertDefault() override;
     void insertFrom(const IColumn & src, size_t n) override;
     void insertRangeFrom(const IColumn & src, size_t start, size_t length) override;
-    ColumnPtr replicate(const Offsets & offsets) const override;
     void popBack(size_t length) override;
     Field operator[](size_t n) const override;
     void get(size_t n, Field & res) const override;
     ColumnPtr permute(const Permutation & perm, size_t limit) const override;
     ColumnPtr filter(const Filter & filter, ssize_t result_size_hint) const override;
     ColumnPtr index(const IColumn & indexes, size_t limit) const override;
+    ColumnPtr replicate(const Offsets & offsets) const override;
+    MutableColumnPtr cloneResized(size_t new_size) const override;
 
     /// All other methods throw exception.
 
@@ -236,7 +249,11 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     }
 
     template <typename Func>
-    ColumnPtr applyForSubcolumns(Func && func, std::string_view func_name) const;
+    MutableColumnPtr applyForSubcolumns(Func && func) const;
+
+    /// For given subcolumn return subcolumn from the same Nested type.
+    /// It's used to get shared sized of Nested to insert correct default values.
+    const Subcolumns::Node * getLeafOfTheSameNested(const Subcolumns::NodePtr & entry) const;
 };
 
 }
diff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp
index 8f4daddc9e8e..0858c2c254eb 100644
--- a/src/DataTypes/ObjectUtils.cpp
+++ b/src/DataTypes/ObjectUtils.cpp
@@ -718,9 +718,9 @@ void replaceMissedSubcolumnsByConstants(
             addConstantToWithClause(query, name, type);
 }
 
-void finalizeObjectColumns(MutableColumns & columns)
+void finalizeObjectColumns(const MutableColumns & columns)
 {
-    for (auto & column : columns)
+    for (const auto & column : columns)
         if (auto * column_object = typeid_cast<ColumnObject *>(column.get()))
             column_object->finalize();
 }
diff --git a/src/DataTypes/ObjectUtils.h b/src/DataTypes/ObjectUtils.h
index 7ec7f6c9f389..602d40cef6ad 100644
--- a/src/DataTypes/ObjectUtils.h
+++ b/src/DataTypes/ObjectUtils.h
@@ -51,7 +51,7 @@ void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescript
 
 NameSet getNamesOfObjectColumns(const NamesAndTypesList & columns_list);
 bool hasObjectColumns(const ColumnsDescription & columns);
-void finalizeObjectColumns(MutableColumns & columns);
+void finalizeObjectColumns(const MutableColumns & columns);
 
 /// Updates types of objects in @object_columns inplace
 /// according to types in new_columns.
diff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp
index 8b5f37d342b8..85831df271a3 100644
--- a/src/DataTypes/Serializations/SerializationObject.cpp
+++ b/src/DataTypes/Serializations/SerializationObject.cpp
@@ -33,71 +33,6 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
-namespace
-{
-
-using Node = typename ColumnObject::Subcolumns::Node;
-
-/// Finds a subcolumn from the same Nested type as @entry and inserts
-/// an array with default values with consistent sizes as in Nested type.
-bool tryInsertDefaultFromNested(
-    const std::shared_ptr<Node> & entry, const ColumnObject::Subcolumns & subcolumns)
-{
-    if (!entry->path.hasNested())
-        return false;
-
-    const Node * current_node = subcolumns.findLeaf(entry->path);
-    const Node * leaf = nullptr;
-    size_t num_skipped_nested = 0;
-
-    while (current_node)
-    {
-        /// Try to find the first Nested up to the current node.
-        const auto * node_nested = subcolumns.findParent(current_node,
-            [](const auto & candidate) { return candidate.isNested(); });
-
-        if (!node_nested)
-            break;
-
-        /// If there are no leaves, skip current node and find
-        /// the next node up to the current.
-        leaf = subcolumns.findLeaf(node_nested,
-            [&](const auto & candidate)
-            {
-                return candidate.data.size() == entry->data.size() + 1;
-            });
-
-        if (leaf)
-            break;
-
-        current_node = node_nested->parent;
-        ++num_skipped_nested;
-    }
-
-    if (!leaf)
-        return false;
-
-    auto last_field = leaf->data.getLastField();
-    if (last_field.isNull())
-        return false;
-
-    const auto & least_common_type = entry->data.getLeastCommonType();
-    size_t num_dimensions = getNumberOfDimensions(*least_common_type);
-    assert(num_skipped_nested < num_dimensions);
-
-    /// Replace scalars to default values with consistent array sizes.
-    size_t num_dimensions_to_keep = num_dimensions - num_skipped_nested;
-    auto default_scalar = num_skipped_nested
-        ? createEmptyArrayField(num_skipped_nested)
-        : getBaseTypeOfArray(least_common_type)->getDefault();
-
-    auto default_field = applyVisitor(FieldVisitorReplaceScalars(default_scalar, num_dimensions_to_keep), last_field);
-    entry->data.insert(std::move(default_field));
-    return true;
-}
-
-}
-
 template <typename Parser>
 template <typename Reader>
 void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader && reader) const
@@ -159,7 +94,7 @@ void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader &
     {
         if (!paths_set.has(entry->path.getPath()))
         {
-            bool inserted = tryInsertDefaultFromNested(entry, subcolumns);
+            bool inserted = column_object.tryInsertDefaultFromNested(entry);
             if (!inserted)
                 entry->data.insertDefault();
         }
