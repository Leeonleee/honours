diff --git a/src/Databases/Iceberg/RestCatalog.cpp b/src/Databases/Iceberg/RestCatalog.cpp
index ab51bb8a4959..078d9960ce48 100644
--- a/src/Databases/Iceberg/RestCatalog.cpp
+++ b/src/Databases/Iceberg/RestCatalog.cpp
@@ -53,7 +53,8 @@ std::pair<std::string, std::string> parseCatalogCredential(const std::string & c
     /// Parse a string of format "<client_id>:<client_secret>"
     /// into separare strings client_id and client_secret.
 
-    std::string client_id, client_secret;
+    std::string client_id;
+    std::string client_secret;
     if (!catalog_credential.empty())
     {
         auto pos = catalog_credential.find(':');
@@ -623,7 +624,9 @@ bool RestCatalog::getTableMetadataImpl(
                 static constexpr auto secret_access_key_str = "s3.secret-access-key";
                 static constexpr auto session_token_str = "s3.session-token";
 
-                std::string access_key_id, secret_access_key, session_token;
+                std::string access_key_id;
+                std::string secret_access_key;
+                std::string session_token;
                 if (config_object->has(access_key_id_str))
                     access_key_id = config_object->get(access_key_id_str).extract<String>();
                 if (config_object->has(secret_access_key_str))
diff --git a/src/Functions/currentQueryID.cpp b/src/Functions/currentQueryID.cpp
new file mode 100644
index 000000000000..1d2e5f9b9542
--- /dev/null
+++ b/src/Functions/currentQueryID.cpp
@@ -0,0 +1,70 @@
+#include <Functions/IFunction.h>
+#include <Functions/FunctionFactory.h>
+#include <Interpreters/Context.h>
+#include <DataTypes/DataTypeString.h>
+#include <Core/Field.h>
+
+
+namespace DB
+{
+namespace
+{
+
+class FunctionCurrentQueryID : public IFunction
+{
+public:
+    static constexpr auto name = "currentQueryID";
+    static FunctionPtr create(ContextPtr context)
+    {
+        return std::make_shared<FunctionCurrentQueryID>(context->getCurrentQueryId());
+    }
+
+    explicit FunctionCurrentQueryID(const String & query_id_) : query_id{query_id_} {}
+
+    String getName() const override { return name; }
+
+    size_t getNumberOfArguments() const override { return 0; }
+
+    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override
+    {
+        return std::make_shared<DataTypeString>();
+    }
+
+    bool isDeterministic() const override { return false; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        return DataTypeString().createColumnConst(input_rows_count, query_id);
+    }
+
+private:
+    const String query_id;
+};
+
+}
+
+REGISTER_FUNCTION(CurrentQueryID)
+{
+    factory.registerFunction<FunctionCurrentQueryID>(FunctionDocumentation{
+        .description = R"(
+Returns current Query id.
+)",
+        .syntax = {"currentQueryID()"},
+        .examples = {{{
+            "Example",
+            R"(
+SELECT currentQueryID();
+)",
+            R"(
+┌─currentQueryID()─────────────────────┐
+│ 1280d0e8-1a08-4524-be6e-77975bb68e7d │
+└──────────────────────────────────────┘
+)"}}},
+        .categories{"Other"},
+    });
+    factory.registerAlias("current_query_id", FunctionCurrentQueryID::name, FunctionFactory::Case::Insensitive);
+}
+
+}
diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp
index 194aa90542e5..71cf4952d06a 100644
--- a/src/IO/ReadHelpers.cpp
+++ b/src/IO/ReadHelpers.cpp
@@ -211,6 +211,20 @@ void readStringUntilCharsInto(Vector & s, ReadBuffer & buf)
     }
 }
 
+template <char... chars>
+void skipStringUntilChars(ReadBuffer & buf)
+{
+    while (!buf.eof())
+    {
+        char * next_pos = find_first_symbols<chars...>(buf.position(), buf.buffer().end());
+
+        buf.position() = next_pos;
+
+        if (buf.hasPendingData())
+            return;
+    }
+}
+
 template <typename Vector>
 void readStringInto(Vector & s, ReadBuffer & buf)
 {
@@ -245,6 +259,11 @@ void readStringUntilWhitespace(String & s, ReadBuffer & buf)
     readStringUntilWhitespaceInto(s, buf);
 }
 
+void skipStringUntilWhitespace(ReadBuffer & buf)
+{
+    skipStringUntilChars<' '>(buf);
+}
+
 void readStringUntilAmpersand(String & s, ReadBuffer & buf)
 {
     s.clear();
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index 1775fc0673a1..86de497c438f 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -625,6 +625,7 @@ void readEscapedStringUntilEOL(String & s, ReadBuffer & buf);
 
 /// Only 0x20 as whitespace character
 void readStringUntilWhitespace(String & s, ReadBuffer & buf);
+void skipStringUntilWhitespace(ReadBuffer & buf);
 
 void readStringUntilAmpersand(String & s, ReadBuffer & buf);
 void readStringUntilEquals(String & s, ReadBuffer & buf);
diff --git a/src/Server/ProxyV1Handler.cpp b/src/Server/ProxyV1Handler.cpp
index d733454b2ab4..139d5259a390 100644
--- a/src/Server/ProxyV1Handler.cpp
+++ b/src/Server/ProxyV1Handler.cpp
@@ -43,6 +43,8 @@ void ProxyV1Handler::run()
     if (word != "TCP4" && word != "TCP6" && word != "UNKNOWN")
         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, "PROXY protocol violation");
 
+    bool is_tcp6 = (word == "TCP6");
+
     if (word == "UNKNOWN" && eol)
         return;
 
@@ -53,7 +55,10 @@ void ProxyV1Handler::run()
     if (!readWord(39, word, eol) || eol)
         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, "PROXY protocol violation");
 
-    stack_data.forwarded_for = std::move(word);
+    if (is_tcp6)
+        stack_data.forwarded_for = "[" + word + "]";
+    else
+        stack_data.forwarded_for = std::move(word);
 
     // read address
     if (!readWord(39, word, eol) || eol)
@@ -63,6 +68,8 @@ void ProxyV1Handler::run()
     if (!readWord(5, word, eol) || eol)
         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, "PROXY protocol violation");
 
+    stack_data.forwarded_for += ":" + word;
+
     // read port and "\r
"
     if (!readWord(5, word, eol) || !eol)
         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, "PROXY protocol violation");
diff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp
index 6d96905462ab..b6ae2fedaaa9 100644
--- a/src/Server/TCPHandler.cpp
+++ b/src/Server/TCPHandler.cpp
@@ -1548,12 +1548,28 @@ bool TCPHandler::receiveProxyHeader()
             return false;
         }
 
+        bool is_tcp6 = ('6' == *limit_in.position());
+
         ++limit_in.position();
         assertChar(' ', limit_in);
 
         /// Read the first field and ignore other.
         readStringUntilWhitespace(forwarded_address, limit_in);
 
+        if (is_tcp6)
+            forwarded_address = "[" + forwarded_address + "]";
+
+        /// Skip second field (destination address)
+        assertChar(' ', limit_in);
+        skipStringUntilWhitespace(limit_in);
+        assertChar(' ', limit_in);
+
+        /// Read source port
+        String port;
+        readStringUntilWhitespace(port, limit_in);
+
+        forwarded_address += ":" + port;
+
         /// Skip until \r

         while (!limit_in.eof() && *limit_in.position() != '\r')
             ++limit_in.position();
@@ -2612,7 +2628,7 @@ Poco::Net::SocketAddress TCPHandler::getClientAddress(const ClientInfo & client_
     /// Only the last proxy can be trusted (if any).
     String forwarded_address = client_info.getLastForwardedFor();
     if (!forwarded_address.empty() && server.config().getBool("auth_use_forwarded_address", false))
-        return Poco::Net::SocketAddress(forwarded_address, socket().peerAddress().port());
+        return Poco::Net::SocketAddress(forwarded_address);
     return socket().peerAddress();
 }
 
