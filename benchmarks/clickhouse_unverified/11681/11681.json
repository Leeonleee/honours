{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11681,
  "instance_id": "ClickHouse__ClickHouse-11681",
  "issue_numbers": [
    "11611"
  ],
  "base_commit": "24059efad5dadac02a728d0aedbc419e0a4b0e53",
  "patch": "diff --git a/src/Storages/MergeTree/ActiveDataPartSet.h b/src/Storages/MergeTree/ActiveDataPartSet.h\nindex beb538e2ca59..e17f4903a26f 100644\n--- a/src/Storages/MergeTree/ActiveDataPartSet.h\n+++ b/src/Storages/MergeTree/ActiveDataPartSet.h\n@@ -67,6 +67,18 @@ class ActiveDataPartSet\n         return result;\n     }\n \n+    /// Remove only covered parts from active set\n+    bool removePartsCoveredBy(const String & part_name)\n+    {\n+        Strings parts_covered_by = getPartsCoveredBy(MergeTreePartInfo::fromPartName(part_name, format_version));\n+        bool result = true;\n+        for (const auto & part : parts_covered_by)\n+            if (part != part_name)\n+                result &= remove(part);\n+\n+        return result;\n+    }\n+\n     /// If not found, return an empty string.\n     String getContainingPart(const MergeTreePartInfo & part_info) const;\n     String getContainingPart(const String & name) const;\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\nindex 8a9dbceba045..f6abbe4bbb45 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp\n@@ -201,21 +201,25 @@ void ReplicatedMergeTreeQueue::updateStateOnQueueEntryRemoval(\n \n     if (is_successful)\n     {\n-\n         if (!entry->actual_new_part_name.empty())\n         {\n             /// We don't add bigger fetched part to current_parts because we\n             /// have an invariant `virtual_parts` = `current_parts` + `queue`.\n-            /// But we can remove it from mutations, because we actually have it.\n-            removePartFromMutations(entry->actual_new_part_name);\n+            ///\n+            /// But we remove covered parts from mutations, because we actually\n+            /// have replacing part.\n+            ///\n+            /// NOTE actual_new_part_name is very confusing and error-prone. This approach must be fixed.\n+            removeCoveredPartsFromMutations(entry->actual_new_part_name, /*remove_part = */ false, /*remove_covered_parts = */ true);\n         }\n \n         for (const String & virtual_part_name : entry->getVirtualPartNames())\n         {\n             current_parts.add(virtual_part_name);\n-            /// Each processed part may be already mutated, so we try to remove\n-            /// all current parts from mutations.\n-            removePartFromMutations(virtual_part_name);\n+\n+            /// These parts are already covered by newer part, we don't have to\n+            /// mutate it.\n+            removeCoveredPartsFromMutations(virtual_part_name, /*remove_part = */ false, /*remove_covered_parts = */ true);\n         }\n \n         String drop_range_part_name;\n@@ -240,16 +244,16 @@ void ReplicatedMergeTreeQueue::updateStateOnQueueEntryRemoval(\n     {\n         for (const String & virtual_part_name : entry->getVirtualPartNames())\n         {\n-            /// Because execution of the entry is unsuccessful, `virtual_part_name` will never appear\n-            /// so we won't need to mutate it.\n-            removePartFromMutations(virtual_part_name);\n+            /// Because execution of the entry is unsuccessful,\n+            /// `virtual_part_name` will never appear so we won't need to mutate\n+            /// it.\n+            removeCoveredPartsFromMutations(virtual_part_name, /*remove_part = */ true, /*remove_covered_parts = */ false);\n         }\n-\n     }\n }\n \n \n-void ReplicatedMergeTreeQueue::removePartFromMutations(const String & part_name)\n+void ReplicatedMergeTreeQueue::removeCoveredPartsFromMutations(const String & part_name, bool remove_part, bool remove_covered_parts)\n {\n     auto part_info = MergeTreePartInfo::fromPartName(part_name, format_version);\n     auto in_partition = mutations_by_partition.find(part_info.partition_id);\n@@ -263,7 +267,15 @@ void ReplicatedMergeTreeQueue::removePartFromMutations(const String & part_name)\n     {\n         MutationStatus & status = *it->second;\n \n-        status.parts_to_do.removePartAndCoveredParts(part_name);\n+        if (remove_part && remove_covered_parts)\n+            status.parts_to_do.removePartAndCoveredParts(part_name);\n+        else if (remove_covered_parts)\n+            status.parts_to_do.removePartsCoveredBy(part_name);\n+        else if (remove_part)\n+            status.parts_to_do.remove(part_name);\n+        else\n+            throw Exception(\"Called remove part from mutations, but nothing removed\", ErrorCodes::LOGICAL_ERROR);\n+\n         if (status.parts_to_do.size() == 0)\n             some_mutations_are_probably_done = true;\n \n@@ -678,6 +690,7 @@ void ReplicatedMergeTreeQueue::updateMutations(zkutil::ZooKeeperPtr zookeeper, C\n                     const String & partition_id = pair.first;\n                     Int64 block_num = pair.second;\n                     mutations_by_partition[partition_id].emplace(block_num, &mutation);\n+                    LOG_TRACE(log, \"Adding mutation {} for partition {} for all block numbers less than {}\", entry->znode_name, partition_id, block_num);\n                 }\n \n                 /// Initialize `mutation.parts_to_do`. First we need to mutate all parts in `current_parts`.\n@@ -1961,6 +1974,7 @@ void ReplicatedMergeTreeQueue::removeCurrentPartsFromMutations()\n {\n     std::lock_guard state_lock(state_mutex);\n     for (const auto & part_name : current_parts.getParts())\n-        removePartFromMutations(part_name);\n+        removeCoveredPartsFromMutations(part_name, /*remove_part = */ true, /*remove_covered_parts = */ true);\n }\n+\n }\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\nindex e093e1933819..989b5d7d5a10 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h\n@@ -107,8 +107,13 @@ class ReplicatedMergeTreeQueue\n \n         ReplicatedMergeTreeMutationEntryPtr entry;\n \n-        /// Parts we have to mutate to complete mutation. We use ActiveDataPartSet structure\n-        /// to be able to manage covering and covered parts.\n+        /// Current parts we have to mutate to complete mutation.\n+        ///\n+        /// current_part_name =mutation> result_part_name\n+        /// ^~~parts_to_do~~^            ^~virtual_parts~^\n+        ///\n+        /// We use ActiveDataPartSet structure to be able to manage covering and\n+        /// covered parts.\n         ActiveDataPartSet parts_to_do;\n \n         /// Note that is_done is not equivalent to parts_to_do.size() == 0\n@@ -204,11 +209,16 @@ class ReplicatedMergeTreeQueue\n     /// Add part for mutations with block_number > part.getDataVersion()\n     void addPartToMutations(const String & part_name);\n \n-    /// Remove part from mutations which were assigned to mutate it\n-    /// with block_number > part.getDataVersion()\n-    /// and block_number == part.getDataVersion()\n-    ///     ^ (this may happen if we downloaded mutated part from other replica)\n-    void removePartFromMutations(const String & part_name);\n+    /// Remove covered parts from mutations (parts_to_do) which were assigned\n+    /// for mutation. If remove_covered_parts = true, than remove parts covered\n+    /// by first argument. If remove_part == true, than also remove part itself.\n+    /// Both negative flags will throw exception.\n+    ///\n+    /// Part removed from mutations which satisfy contitions:\n+    /// block_number > part.getDataVersion()\n+    /// or block_number == part.getDataVersion()\n+    ///    ^ (this may happen if we downloaded mutated part from other replica)\n+    void removeCoveredPartsFromMutations(const String & part_name, bool remove_part, bool remove_covered_parts);\n \n     /// Update the insertion times in ZooKeeper.\n     void updateTimesInZooKeeper(zkutil::ZooKeeperPtr zookeeper,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01076_parallel_alter_replicated_zookeeper.sh b/tests/queries/0_stateless/01076_parallel_alter_replicated_zookeeper.sh\nindex 15bb851fc77a..4ae0ed851376 100755\n--- a/tests/queries/0_stateless/01076_parallel_alter_replicated_zookeeper.sh\n+++ b/tests/queries/0_stateless/01076_parallel_alter_replicated_zookeeper.sh\n@@ -105,11 +105,14 @@ sleep 1\n counter=0\n \n while [[ $($CLICKHOUSE_CLIENT --query \"select * from system.mutations where table like 'concurrent_mutate_mt_%' and is_done=0\" 2>&1) ]]; do\n-    if [ \"$counter\" -gt 40 ]\n+    if [ \"$counter\" -gt 120 ]\n     then\n         break\n     fi\n     sleep 1\n+    for i in `seq $REPLICAS`; do\n+        $CLICKHOUSE_CLIENT --query \"ATTACH TABLE concurrent_mutate_mt_$i\" 2> /dev/null\n+    done\n     counter=$(($counter + 1))\n done\n \ndiff --git a/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.reference b/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.reference\nnew file mode 100644\nindex 000000000000..785123ae030e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.reference\n@@ -0,0 +1,6 @@\n+90001\n+2\n+waiting\tdefault\tmutation_table\t0000000000\tMODIFY COLUMN `value` UInt64\n+is_done\tparts_to_do\n+0\t1\n+MUTATE_PART\t0_0_0_0_2\ndiff --git a/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.sh b/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.sh\nnew file mode 100755\nindex 000000000000..3dc8b34fff64\n--- /dev/null\n+++ b/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.sh\n@@ -0,0 +1,57 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS mutation_table\"\n+\n+$CLICKHOUSE_CLIENT --query \"\n+    CREATE TABLE mutation_table(\n+        key UInt64,\n+        value String\n+    )\n+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/mutation_table', '1')\n+    ORDER BY key\n+    PARTITION BY key % 10\n+\"\n+\n+$CLICKHOUSE_CLIENT --query \"INSERT INTO mutation_table select number, toString(number) from numbers(100000) where number % 10 != 0\"\n+\n+$CLICKHOUSE_CLIENT --query \"INSERT INTO mutation_table VALUES(0, 'hello')\"\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT COUNT() FROM mutation_table\"\n+\n+$CLICKHOUSE_CLIENT --query \"ALTER TABLE mutation_table MODIFY COLUMN value UInt64 SETTINGS replication_alter_partitions_sync=0\"\n+\n+first_mutation_id=$($CLICKHOUSE_CLIENT --query \"SELECT mutation_id FROM system.mutations where table='mutation_table' and database='$CLICKHOUSE_DATABASE'\")\n+\n+# Here we have long sleeps, but they shouldn't lead to flaps. We just check that\n+# background mutation finalization function will be triggered at least once. In\n+# rare cases this test doesn't check anything, but will report OK.\n+sleep 7\n+\n+$CLICKHOUSE_CLIENT --query \"ALTER TABLE mutation_table MODIFY COLUMN value UInt32 SETTINGS replication_alter_partitions_sync=0\"\n+\n+\n+#### just check that both mutations started\n+check_query=\"SELECT count() FROM system.mutations WHERE table='mutation_table' and database='$CLICKHOUSE_DATABASE'\"\n+\n+query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+\n+while [ \"$query_result\" != \"2\" ]\n+do\n+    query_result=`$CLICKHOUSE_CLIENT --query=\"$check_query\" 2>&1`\n+    sleep 0.5\n+done\n+\n+echo $query_result\n+\n+$CLICKHOUSE_CLIENT --query \"KILL MUTATION WHERE mutation_id='$first_mutation_id'\"\n+\n+sleep 7\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT is_done, parts_to_do FROM system.mutations where table='mutation_table' and database='$CLICKHOUSE_DATABASE' FORMAT TSVWithNames\"\n+\n+$CLICKHOUSE_CLIENT --query \"SELECT type, new_part_name FROM system.replication_queue WHERE table='mutation_table' and database='$CLICKHOUSE_DATABASE'\"\n+\n+$CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS mutation_table\"\n",
  "problem_statement": "20.3.10 Mutation got finalized but continued to run\nA mutation was converting String to Int, and wasn't able to do so for some parts.\r\nIt was finalized and marked as 'done', however it was still running and trying to mutate those failing parts.\r\nsystem.mutations:\r\n```\r\nmutation_id        | 0000000014            \r\ncreate_time        | 2020-06-10 10:31:45\r\nparts_to_do_names  | []                    \r\nparts_to_do        | 0                     \r\nis_done            | 1                     \r\nlatest_failed_part | 202006_1192_1221_2_1229\r\nlatest_fail_time   | 2020-06-10 20:10:54\r\nlatest_fail_reason | Code: 32, e.displayText() = DB::Exception: Attempt to read after eof: Cannot parse Int8 from String, because value is too short (version 20.3.10.75 (official build))\r\n```\r\nThe story of 0000000014:\r\n```\r\n0000000012 was running and failing on the same part (version 1228 -> 1229):\r\n\r\n2020.06.10 10:28:47.826412 [ 26695 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1228 to 202006_1192_1221_2_1229\r\n2020.06.10 10:28:47.827488 [ 26695 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1228, approx. 11558912 rows starting from 0\r\n2020.06.10 10:30:31.935293 [ 26695 ] {} <Trace> db.table (MergerMutator): Mutating part 202006_1192_1221_2_1228 to mutation version 1229\r\n2020.06.10 10:30:31.936320 [ 26695 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1228, approx. 11558912 rows starting from 0\r\n2020.06.10 10:30:32.009757 [ 26695 ] {} <Error> db.table: Cannot quickly remove directory /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1229 by removing files; fallback to recursive removal. Reason: Code: 458, e.displayText() = DB::ErrnoException: Cannot unlink file /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1229/checksums.txt, errno: 2, strerror: No such file or directory (version 20.3.10.75 (official build))\r\n\r\n0000000014 got created (version 1229 -> 1248):\r\n\r\n2020.06.10 10:31:45.605614 [ 4235 ] {476aa847-b984-42b0-a3c0-8349b7042ff7} <Trace> db.table: Created mutation with ID 0000000014\r\n2020.06.10 10:31:45.606070 [ 26653 ] {} <Information> db.table (ReplicatedMergeTreeQueue): Loading 1 mutation entries: 0000000014 - 0000000014\r\n\r\n0000000012 continued to run and fail on the part (version 1228 -> 1229):\r\n\r\n2020.06.10 10:31:45.633427 [ 26671 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1228 to 202006_1192_1221_2_1229\r\n2020.06.10 10:31:45.634615 [ 26671 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1228, approx. 11558912 rows starting from 0\r\n2020.06.10 10:32:24.525870 [ 26671 ] {} <Trace> db.table (MergerMutator): Mutating part 202006_1192_1221_2_1228 to mutation version 1229\r\n2020.06.10 10:32:24.526939 [ 26671 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1228, approx. 11558912 rows starting from 0\r\n2020.06.10 10:32:24.561595 [ 26671 ] {} <Error> db.table: Cannot quickly remove directory /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1229 by removing files; fallback to recursive removal. Reason: Code: 458, e.displayText() = DB::ErrnoException: Cannot unlink file /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1229/checksums.txt, errno: 2, strerror: No such file or directory (version 20.3.10.75 (official build))\r\n\r\n0000000012 got killed (version 1228 -> 1229):\r\n\r\n2020.06.10 18:06:16.428289 [ 1126 ] {2039d7f7-6bf5-489b-b7de-6d1dfab3cd13} <Trace> db.table: Killing mutation 0000000012\r\n\r\nThe part got cloned to the 1229 version:\r\n\r\n2020.06.10 18:13:10.573852 [ 26688 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1228 to 202006_1192_1221_2_1229\r\n2020.06.10 18:13:10.573895 [ 26688 ] {} <Warning> db.table (ReplicatedMergeTreeQueue): Mutation with version 1229 not found in partition ID 202006 (trying to mutate part 202006_1192_1221_2_1228)\r\n2020.06.10 18:13:10.574039 [ 26688 ] {} <Trace> db.table (MergerMutator): Part 202006_1192_1221_2_1228 doesn''t change up to mutation version 1229\r\n2020.06.10 18:13:10.574074 [ 26688 ] {} <Debug> db.table: Cloning part /var/lib/clickhouse/data/db/table/202006_1192_1221_2_1228/ to /var/lib/clickhouse/data/db/table/tmp_clone_202006_1192_1221_2_1229\r\n2020.06.10 18:13:10.713473 [ 26688 ] {} <Trace> db.table: Renaming temporary part tmp_clone_202006_1192_1221_2_1229 to 202006_1192_1221_2_1229.\r\n\r\n0000000014 started to mutate the part and it was failing as well (version 1229 -> 1248):\r\n\r\n2020.06.10 18:13:10.735040 [ 26647 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1229 to 202006_1192_1221_2_1248\r\n2020.06.10 18:13:10.739230 [ 26647 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1229, approx. 11558912 rows starting from 0\r\n2020.06.10 18:14:14.883896 [ 26647 ] {} <Trace> db.table (MergerMutator): Mutating part 202006_1192_1221_2_1229 to mutation version 1248\r\n2020.06.10 18:14:14.884930 [ 26647 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1229, approx. 11558912 rows starting from 0\r\n2020.06.10 18:14:14.974299 [ 26647 ] {} <Error> db.table: Cannot quickly remove directory /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1248 by removing files; fallback to recursive removal. Reason: Code: 458, e.displayText() = DB::ErrnoException: Cannot unlink file /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1248/checksums.txt, errno: 2, strerror: No such file or directory (version 20.3.10.75 (official build))\r\n2020.06.10 18:25:10.439701 [ 26691 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1229 to 202006_1192_1221_2_1248\r\n2020.06.10 18:25:10.443038 [ 26691 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1229, approx. 11558912 rows starting from 0\r\n2020.06.10 18:26:58.842872 [ 26691 ] {} <Trace> db.table (MergerMutator): Mutating part 202006_1192_1221_2_1229 to mutation version 1248\r\n2020.06.10 18:26:58.843956 [ 26691 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1229, approx. 11558912 rows starting from 0\r\n2020.06.10 18:26:58.988338 [ 26691 ] {} <Error> db.table: Cannot quickly remove directory /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1248 by removing files; fallback to recursive removal. Reason: Code: 458, e.displayText() = DB::ErrnoException: Cannot unlink file /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1248/checksums.txt, errno: 2, strerror: No such file or directory (version 20.3.10.75 (official build))\r\n2020.06.10 18:35:07.134128 [ 26657 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1229 to 202006_1192_1221_2_1248\r\n2020.06.10 18:35:07.138542 [ 26657 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1229, approx. 11558912 rows starting from 0\r\n\r\nIn the meantime 0000000014 got marked as done:\r\n\r\n2020.06.10 18:35:07.172604 [ 26681 ] {} <Trace> db.table (ReplicatedMergeTreeQueue): Will check if mutation 0000000014 is done\r\n2020.06.10 18:35:07.183031 [ 26681 ] {} <Trace> db.table (ReplicatedMergeTreeQueue): Mutation 0000000014 is not done yet because 1 parts to mutate suddenly appeared.\r\n2020.06.10 18:35:12.183202 [ 26683 ] {} <Trace> db.table (ReplicatedMergeTreeQueue): Will check if mutation 0000000014 is done\r\n2020.06.10 18:35:12.193077 [ 26683 ] {} <Trace> db.table (ReplicatedMergeTreeQueue): Mutation 0000000014 is done\r\n\r\n0000000014 continued to run and fail on the part (version 1229 -> 1248):\r\n\r\n2020.06.10 18:37:08.455340 [ 26657 ] {} <Trace> db.table (MergerMutator): Mutating part 202006_1192_1221_2_1229 to mutation version 1248\r\n2020.06.10 18:37:08.456411 [ 26657 ] {} <Trace> MergeTreeSelectProcessor: Reading 1 ranges from part 202006_1192_1221_2_1229, approx. 11558912 rows starting from 0\r\n2020.06.10 18:37:08.513344 [ 26657 ] {} <Error> db.table: Cannot quickly remove directory /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1248 by removing files; fallback to recursive removal. Reason: Code: 458, e.displayText() = DB::ErrnoException: Cannot unlink file /var/lib/clickhouse/data/db/table/delete_tmp_202006_1192_1221_2_1248/checksums.txt, errno: 2, strerror: No such file or directory (version 20.3.10.75 (official build))\r\n\r\n0000000014 got killed:\r\n\r\n2020.06.10 20:15:18.256147 [ 8727 ] {37dfb115-15fe-435f-9414-6d78a657b445} <Debug> executeQuery: (from [::1]:56162) SELECT * FROM system.mutations WHERE (table = 'table') AND (mutation_id = '0000000014')\r\n2020.06.10 20:16:14.973545 [ 8727 ] {fa5fd0d0-6683-40a9-9517-8cf9d96a0bd1} <Debug> executeQuery: (from [::1]:56162) KILL MUTATION WHERE (table = 'table') AND (mutation_id = '0000000014') ASYNC\r\n2020.06.10 20:16:14.973692 [ 8727 ] {fa5fd0d0-6683-40a9-9517-8cf9d96a0bd1} <Debug> executeQuery: (internal) SELECT database, table, mutation_id FROM system.mutations WHERE (table = 'table') AND (mutation_id = '0000000014')\r\n2020.06.10 20:16:14.975910 [ 8727 ] {fa5fd0d0-6683-40a9-9517-8cf9d96a0bd1} <Trace> db.table: Killing mutation 0000000014\r\n2020.06.10 20:16:14.979650 [ 8727 ] {fa5fd0d0-6683-40a9-9517-8cf9d96a0bd1} <Debug> db.table (ReplicatedMergeTreeQueue): Removed mutation 0000000014 from ZooKeeper.\r\n2020.06.10 20:16:14.979665 [ 8727 ] {fa5fd0d0-6683-40a9-9517-8cf9d96a0bd1} <Debug> db.table (ReplicatedMergeTreeQueue): Removed mutation 0000000014 from local state.\r\n\r\nThe part got cloned to the 1248 version:\r\n\r\n2020.06.10 20:23:46.249605 [ 26652 ] {} <Trace> db.table: Executing log entry to mutate part 202006_1192_1221_2_1229 to 202006_1192_1221_2_1248\r\n2020.06.10 20:23:46.249635 [ 26652 ] {} <Warning> db.table (ReplicatedMergeTreeQueue): There are no mutations for partition ID 202006 (trying to mutate part 202006_1192_1221_2_1229 to 1248)\r\n2020.06.10 20:23:46.249778 [ 26652 ] {} <Trace> db.table (MergerMutator): Part 202006_1192_1221_2_1229 doesn''t change up to mutation version 1248\r\n2020.06.10 20:23:46.249808 [ 26652 ] {} <Debug> db.table: Cloning part /var/lib/clickhouse/data/db/table/202006_1192_1221_2_1229/ to /var/lib/clickhouse/data/db/table/tmp_clone_202006_1192_1221_2_1248\r\n2020.06.10 20:23:46.383221 [ 26652 ] {} <Trace> db.table: Renaming temporary part tmp_clone_202006_1192_1221_2_1248 to 202006_1192_1221_2_1248.\r\n```\r\nsystem.replication_queue\r\n```\r\nnode_name              | queue-0000018527                                                                                                                                                     \r\ntype                   | MUTATE_PART                                                                                                                                                          \r\ncreate_time            | 2020-06-10 18:13:10\r\nrequired_quorum        | 0                                                                                                                                                                    \r\nnew_part_name          | 202006_1192_1221_2_1248                                                                                                                                              \r\nparts_to_merge         | ['202006_1192_1221_2_1229']                                                                                                                                          \r\nis_detach              | 0                                                                                                                                                                    \r\nis_currently_executing | 0                                                                                                                                                                    \r\nnum_tries              | 13                                                                                                                                                                   \r\nlast_exception         | Code: 32, e.displayText() = DB::Exception: Attempt to read after eof: Cannot parse Int8 from String, because value is too short (version 20.3.10.75 (official build))\r\nlast_attempt_time      | 2020-06-10 20:08:55\r\nnum_postponed          | 0                                                                                                                                                                    \r\n```\n",
  "hints_text": "",
  "created_at": "2020-06-15T13:41:46Z",
  "modified_files": [
    "src/Storages/MergeTree/ActiveDataPartSet.h",
    "src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeQueue.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01076_parallel_alter_replicated_zookeeper.sh",
    "b/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.reference",
    "b/tests/queries/0_stateless/01318_long_failing_mutation_zookeeper.sh"
  ]
}